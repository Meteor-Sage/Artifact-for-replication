/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void __noreturn start(); // weak
BOOL sub_4017C5();
_BYTE *__stdcall sub_402000(_BYTE *a1, int a2, char *Str);
const CHAR *__cdecl sub_402274(const CHAR *a1);
int __stdcall sub_4024E7(char *Str, char *a2); // idb
// const CHAR *__userpurge sub_402859@<eax>(int a1, const CHAR *a2);
void __stdcall __noreturn TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
DWORD __stdcall sub_402A04(char *Str, char *a2, char *a3);
int sub_402AE6();
void __noreturn sub_402C54(void); // weak
int __stdcall sub_402D7A(char *a1);
const CHAR *__cdecl sub_402EA8(const CHAR *a1);
int __stdcall sub_402FAA(char *Str); // idb
BOOL sub_4033AF();
HRSRC __stdcall sub_4033E3(HMODULE hModule, char *Str);
int sub_4035EE();
int __stdcall sub_40386A(int a1, char *Str, _BYTE *a3, int a4, _BYTE *a5, int a6, int a7, int a8, int a9);
const CHAR *__cdecl sub_403B17(const CHAR *a1);
int sub_403D19();
int sub_403DE5();
int sub_403FD5();
LPVOID __stdcall sub_40419E(int a1, int a2);
void __noreturn sub_404225(void); // weak
int sub_404530(void); // weak
void __cdecl __noreturn sub_404566(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_405000();
void __fastcall sub_405060(LPVOID *a1, char *Str);
int __fastcall sub_405068(LPVOID *a1, char *Str);
// void *__cdecl memset(void *, int Val, size_t Size);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall RemoveDirectoryA(LPCSTR lpPathName);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// UINT __stdcall GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
char *__stdcall sub_4050D0(const char *a1, char *a2, int a3);
char *__stdcall sub_405190(const char *a1, int a2);
CHAR *__stdcall sub_4051B0(char *Str1, int a2, char *Str2, const CHAR *a4);
unsigned int __stdcall sub_4052C0(const char *a1);
__int64 __stdcall sub_4052F0(char *a1);
int __stdcall sub_405440(_BYTE *a1, char *SubStr);
int __stdcall sub_4054A0(_BYTE *a1, _BYTE *a2);
const CHAR *__stdcall sub_405520(unsigned int a1, int a2, int a3, int a4);
const CHAR *__stdcall sub_4055A0(const char *a1, int a2, const CHAR *a3);
char *__stdcall sub_4055E0(char *a1, char *a2, int a3);
char *__stdcall sub_405680(const char *a1, int a2, int a3);
_BYTE *__cdecl sub_4056F0(_BYTE *a1, unsigned int a2, unsigned int a3);
// const CHAR *__usercall sub_4057A0@<eax>(int a1@<eax>, int a2@<ecx>);
const CHAR *__stdcall sub_405860(__int64 a1, int a2);
const CHAR *__stdcall sub_4058F0(char *Destination, char *a2, char a3, int a4, int a5, int a6);
const CHAR *__stdcall sub_405AD0(char *Destination, char *a2, int a3);
char *__stdcall sub_405AF0(const char *a1, int a2);
_BYTE *__stdcall sub_405B50(signed int Size, int a2);
unsigned __int8 *__cdecl sub_405BF0(unsigned __int8 *a1, _BYTE *a2);
void __cdecl sub_405CC0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_405E00(int *a1, int *a2, int a3, int a4);
void __cdecl sub_405F40(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406080(int *a1, int *a2, int a3, int a4);
void __cdecl sub_4061C0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406310(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406460(int *a1, int *a2, int a3, int a4);
void __cdecl sub_4065A0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_4066E0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406840(int *a1, int *a2, int a3, int a4);
void __cdecl sub_4069A0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406B00(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406C60(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406DA0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_406EE0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_407030(int *a1, int *a2, int a3, int a4);
void __cdecl sub_407180(int *a1, int *a2, int a3, int a4);
void __cdecl sub_4072E0(int *a1, int *a2, int a3, int a4);
void __cdecl sub_407440(int *a1, int *a2, int a3, int a4);
void __cdecl sub_407590(int *a1, int *a2, int a3, int a4);
void __stdcall sub_4076E0(_DWORD *a1, char a2, int a3, int a4, _DWORD *a5, int a6);
void __stdcall sub_407A00(_DWORD *a1, char a2, int a3, int a4);
void __stdcall sub_407D30(_DWORD *a1, char a2);
int __stdcall sub_408000(int, int); // weak
int __stdcall sub_408060(char *String1, char *String2); // idb
HRESULT sub_408099();
int __stdcall sub_4080D0(LPCSTR lpCaption, LPCSTR lpText, UINT uType); // idb
int __stdcall sub_4080FF(HWND hWnd, int a2, int a3, LPARAM lParam); // idb
const CHAR *__stdcall sub_408143(int a1, char *Source, int a3);
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2); // idb
void __stdcall sub_40831D(LPARAM lParam);
HWND sub_4083C6();
void **__stdcall sub_4083F4(int a1);
void sub_408421();
const CHAR *__stdcall sub_408450(int a1);
LPSTR __stdcall sub_4084AB(_DWORD *a1);
char *__stdcall sub_40856C(int a1, int a2);
LPSTR sub_4085BA();
BOOL __stdcall sub_4085CD(const CHAR *a1, const CHAR *a2);
_DWORD *__stdcall sub_4085EE(_DWORD *a1, LPCSTR lpFileName);
_DWORD *__stdcall sub_40866D(_DWORD *a1, LPCSTR lpFileName);
int __stdcall sub_4086DB(_DWORD *a1, int a2);
// DWORD __usercall sub_4086FE@<eax>(int a1@<eax>, _BYTE *lpBuffer, int a3, CHAR *lpMultiByteStr, SIZE_T *a5);
DWORD __stdcall sub_40887D(int a1, _BYTE *a2, int a3, CHAR *a4);
int __stdcall sub_40889A(DWORD nNumberOfBytesToWrite, LPCSTR lpFileName, CHAR *lpBuffer);
int __stdcall sub_40892E(HANDLE *a1, unsigned __int8 *lpBuffer, char *lpMem, char *Str);
int __stdcall sub_408A2E(HANDLE *a1, LPCSTR lpFileName, char *Str);
int __stdcall sub_408AD1(int a1, int a2);
int sub_408AD6();
BOOL __cdecl sub_408B3E(int a1);
void __cdecl sub_408B83(int a1);
int __cdecl sub_408CE6(int a1, char *Str1); // idb
BOOL __stdcall sub_408D26(HANDLE *lpMem);
int __stdcall sub_408D4D(_DWORD *a1);
int __stdcall sub_408D71(int); // weak
int __stdcall sub_408D94(int, int); // weak
int __stdcall sub_408DBD(int); // weak
int __stdcall sub_408DCD(int, int, int, int); // weak
int __stdcall sub_408DEC(int, int, int, int); // weak
void sub_408E03();
int __cdecl sub_408E4A(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_408EB2(unsigned __int8 *a1, int a2, _QWORD *a3, int a4, void *Src, int (__cdecl *a6)(int, int));
int __thiscall sub_409032(int *this);
int __cdecl sub_409088(_BYTE *a1, _BYTE *a2, unsigned int a3);
// int __usercall sub_40915E@<eax>(int result@<eax>, int a2);
// int __usercall sub_4091A2@<eax>(int a1@<eax>, unsigned int a2);
int __thiscall sub_4091E5(unsigned __int8 *this);
int sub_409212();
int __cdecl sub_409218(unsigned int a1);
int __cdecl sub_409226(unsigned __int8 *a1, unsigned __int8 *a2, int a3, void *a4);
void __stdcall sub_409379(int a1);
_DWORD *sub_4093B7();
void sub_4093CB();
int *__stdcall sub_4093D7(int a1);
int *__stdcall sub_409411(int a1, int a2);
int __stdcall sub_409441(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_409470(int); // weak
LPTOP_LEVEL_EXCEPTION_FILTER __stdcall sub_4094B0(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
int __stdcall sub_409520(int **a1);
LPTOP_LEVEL_EXCEPTION_FILTER sub_409600();
char *__stdcall sub_409620(int a1, int a2);
char *__stdcall sub_409680(int a1);
_BYTE *__stdcall sub_409694(int a1, _DWORD *dwFlags, int *a3, int a4);
void sub_409726();
void __stdcall sub_409745(LPVOID lpMem);
_DWORD *__stdcall sub_4097AD(int *a1);
int __stdcall sub_40984B(int a1);
_DWORD *__stdcall sub_409855(int a1);
int __stdcall sub_40986A(int *a1);
_DWORD *__stdcall sub_40989E(int a1, int a2);
int __stdcall sub_409971(int **a1, int *a2, int a3);
int __stdcall sub_4099C0(int a1);
int __cdecl sub_409A1E(_DWORD *a1);
BOOL __cdecl sub_409A4B(int a1);
BOOL sub_409A61();
HWND sub_409AD1();
int *__stdcall sub_409AEB(HWND *hdc, int *a2, int *a3);
int __stdcall sub_409BE6(COLORREF *a1, int a2, int a3, HDC hdc, int a5);
HWND __stdcall sub_409C4B(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName, unsigned int a7);
HWND __stdcall sub_409D43(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName);
int __stdcall sub_409D63(int a1, int a2, int a3, HDC hdc, int a5); // idb
LRESULT __stdcall sub_409DF8(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall sub_409E36(HWND *a1, int a2);
LRESULT __stdcall sub_409E59(HWND *a1, int a2, int wParam);
int __stdcall sub_409E84(HWND *hdc, struct tagSIZE *a2, int a3);
HWND __stdcall sub_409F1C(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName, unsigned int a7);
LRESULT __stdcall sub_40A03F(HWND *a1, int a2);
int __stdcall sub_40A061(HWND *a1);
int __stdcall sub_40A07C(HWND *hdc, struct tagSIZE *a2, int a3);
HWND __stdcall sub_40A15C(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName, int a7);
HWND __stdcall sub_40A229(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName);
HWND __stdcall sub_40A249(int a1);
const CHAR *__stdcall sub_40A284(int a1, int a2);
void __stdcall sub_40A2EA(int a1);
BOOL __stdcall sub_40A31C(int a1, int a2, COLORREF color);
int __stdcall sub_40A376(int a1, int a2);
void __stdcall sub_40A39C(int a1);
LRESULT __stdcall sub_40A3B0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
HWND __stdcall sub_40A46D(_DWORD *dwNewLong, _DWORD *a2, HWND hWnd, int a4);
HWND __stdcall sub_40A4E8(HWND hWnd);
void __stdcall sub_40A51B(HWND hWnd, int a2);
HBRUSH __stdcall sub_40A553(COLORREF color);
void __stdcall sub_40A5C0(void *a1);
int sub_40A60F();
void __stdcall sub_40A702(DWORD a1);
void __stdcall sub_40A723(int a1);
void sub_40A839();
HCURSOR sub_40A850();
HWND *__stdcall sub_40A8A8(HWND *a1, int X, int Y, int a4, int a5, LPCSTR lpWindowName, int a7, HWND hWndParent);
HWND *__stdcall sub_40AB60(HWND *a1, int X, int Y, int a4, int a5, LPCSTR lpWindowName, int a7);
int __stdcall sub_40AB83(int a1, int a2, __int16 a3);
int __stdcall sub_40AC9E(DWORD dwMilliseconds); // idb
int sub_40AD87();
int __cdecl sub_40AD8F(HWND hWnd, int a2, int a3, int a4, int a5); // idb
BOOL __stdcall sub_40ADEF(HWND hWnd, LPARAM a2); // idb
int __stdcall sub_40AE05(HWND hWndParent, unsigned int a2, HDC hDC, HWND a4);
int __stdcall sub_40B300(HWND hWnd, UINT uMsg, HDC wParam, HWND lParam);
BOOL __stdcall sub_40B396(HWND hWnd, int a2, HWND a3);
BOOL __stdcall sub_40B457(HWND hWnd, LPARAM a2); // idb
BOOL __stdcall sub_40B4BC(HWND hWnd, LPARAM a2); // idb
HWND __stdcall sub_40B512(int a1);
int __stdcall sub_40B61A(HWND hWnd, int a2); // idb
int __stdcall sub_40B661(HWND hWnd); // idb
BOOL sub_40B768();
BOOL sub_40B821();
BOOL sub_40B8AF();
void __cdecl sub_40B9B8(double a1, double a2);
double __cdecl sub_40BA67(double X);
double **__cdecl sub_40BAD0(int a1, int a2, int a3, int *a4);
// void __usercall sub_40BCEA(int a1@<eax>, void *Block);
// void __usercall sub_40BD29(int a1@<eax>, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_40BE62(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __stdcall sub_40C055(int a1);
void sub_40C0AD();
_DWORD *sub_40C0B9();
int __stdcall sub_40C0CD(int a1, int a2);
LPVOID sub_40C142();
HANDLE sub_40C160();
BOOL sub_40C180();
LPVOID __stdcall sub_40C1D0(int dwBytes);
// int __usercall sub_40C1F0@<eax>(char *a1@<eax>);
// _BYTE *__userpurge sub_40C200@<eax>(_BYTE *result@<eax>, char a2);
const CHAR *__stdcall sub_40C210(const char *Src, int a2, int a3);
// _DWORD *__userpurge sub_40C270@<eax>(_DWORD *result@<eax>, int a2);
_BYTE *__stdcall sub_40C280(const char *Src, int a2);
BOOL __stdcall sub_40C2D0(LPVOID lpMem);
void *__stdcall sub_40C2F0(void *a1, size_t Size);
int __stdcall sub_40C310(void *Src, void *a2, size_t Size); // idb
_BYTE *__stdcall sub_40C340(_BYTE *a1, char *a2, int a3);
SIZE_T __stdcall sub_40C380(LPCVOID lpMem);
// int __usercall sub_40C3A0@<eax>(int a1@<eax>);
LPVOID __stdcall sub_40C3B0(SIZE_T dwBytes, int a2);
_BYTE *__stdcall sub_40C3F0(_BYTE *a1, char *a2);
DWORD sub_40C41B();
void sub_40C427();
BOOL __stdcall sub_40C437(char *Source);
const CHAR *__stdcall sub_40C4AD(int a1);
BOOL __stdcall sub_40C50E(LPCSTR lpFileName, char a2);
BOOL __stdcall sub_40C53C(LPCSTR lpFileName);
const CHAR *__stdcall sub_40C54A(int a1);
BOOL __stdcall sub_40C58A(const CHAR *a1);
void *__stdcall sub_40C59C(char *a1, int a2);
void *__stdcall sub_40C612(char *a1, char a2, int a3);
void *__stdcall sub_40C6BA(char *a1, int a2);
DWORD __stdcall sub_40C6D0(int a1);
void __stdcall sub_40C710(int a1);
void sub_40C780();
_DWORD *sub_40C790();
_DWORD *__cdecl sub_40C7B0(int a1, LPCSTR lpFileName, DWORD dwMoveMethod, char a4);
_DWORD *__stdcall sub_40C930(int a1, LPCSTR lpFileName);
_DWORD *__stdcall sub_40CA00(int a1, LPCSTR lpFileName);
int __stdcall sub_40CAB0(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite);
int __stdcall sub_40CB10(int a1, char *lpBuffer);
DWORD __stdcall sub_40CB90(int a1, char *lpBuffer);
DWORD __stdcall sub_40CC70(int a1, _BYTE *Src, signed int Size);
LRESULT __stdcall sub_40CD69(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lpMem);
_DWORD *__cdecl sub_40CDBA(char **a1);
int sub_40CDD7(); // weak
void sub_40CDE3();
int *__cdecl sub_40CEAC(int a1, int a2, int a3, int a4);
void __cdecl sub_40CEF7(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __cdecl sub_40D077(int a1, int a2, int a3, int a4);
int sub_40D095();
BOOL sub_40D190();
int sub_40D19D();
int sub_40D1AC();
_DWORD *__cdecl sub_40D1BB(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_40D236(int a1);
int __cdecl sub_40D282(int a1);
void sub_40D2B3();
_DWORD *__stdcall sub_40D2D2(int a1, int a2, int *a3, LPVOID *a4, signed int dwBytes);
int *__stdcall sub_40D3A8(int a1, char *String2);
void __stdcall sub_40D3CA(LPVOID lpMem);
int *__stdcall sub_40D433(int a1, char *String2);
_DWORD *__stdcall sub_40D4C5(_DWORD *a1);
int __stdcall sub_40D4D3(int a1);
int __thiscall sub_40D548(_DWORD *this);
int __stdcall sub_40D571(int *a1);
int __stdcall sub_40D5B2(int *a1, int a2, int a3);
int *__stdcall sub_40D62E(int a1, char *Str, int a3);
_DWORD *__stdcall sub_40D706(int a1);
int __cdecl sub_40D786(_BYTE *a1);
int __cdecl sub_40D79F(char *a1);
_DWORD *__stdcall sub_40D7C5(int a1, int a2, int a3);
_DWORD *__stdcall sub_40D857(_DWORD *a1, int a2);
char *__stdcall sub_40D890(int a1, unsigned int a2, int a3);
unsigned int __stdcall sub_40D990(LPCSTR lpFileName, __int64 lDistanceToMove, __int64 a3);
unsigned int __stdcall sub_40DBB0(LPCSTR lpFileName);
_DWORD *__cdecl sub_40DBD0(_DWORD *a1);
int __cdecl sub_40DCC0(_DWORD *a1);
unsigned int __cdecl sub_40E3A0(_DWORD *a1, int a2, unsigned int a3);
void *__cdecl sub_40E460(int a1, char *a2);
_DWORD *__stdcall sub_40E515(int a1, int a2);
_DWORD *__stdcall sub_40E59A(int a1, int a2);
void **__stdcall sub_40E5BF(size_t *a1, int a2);
_DWORD *__stdcall sub_40E5FA(int a1, int a2, int a3);
int __stdcall sub_40E643(int a1);
LPVOID __stdcall sub_40E64A(SIZE_T dwBytes, void (__cdecl *a2)(LPVOID), int a3);
void __stdcall sub_40E672(_DWORD *a1);
void sub_40E6A0();
char *__stdcall sub_40E6B3(int a1, int a2, int a3, int a4);
_DWORD *__stdcall sub_40E7E9(int a1);
void __stdcall sub_40E948(int a1, int a2);
void __stdcall sub_40EA01(int a1);
void __stdcall sub_40EA6F(char *lpMem);
_DWORD *__stdcall sub_40EB0A(_DWORD *a1);
_DWORD *__stdcall sub_40EB2F(_DWORD *a1, int *a2);
int __stdcall sub_40EB82(int a1, void (*a2)(void), _DWORD *a3);
void __stdcall sub_40EB96(union _RTL_RUN_ONCE *a1, void *a2);
__int32 __cdecl sub_40EC24(volatile __int32 *a1, __int32 a2);
signed __int32 __cdecl sub_40EC2F(volatile signed __int32 *a1, signed __int32 a2, signed __int32 a3);
_DWORD *__cdecl sub_40EC40(int a1, SIZE_T dwBytes);
BOOL __cdecl sub_40EC6D(_DWORD *a1, int a2);
_DWORD *__stdcall sub_40ECAD(int a1, int a2, int a3, int *a4, int *a5);
_DWORD *__stdcall sub_40ED3E(int a1, int a2, int a3, int *a4, int *a5);
void sub_40EDAC();
BOOL __stdcall sub_40EDD5(int a1);
BOOL __stdcall sub_40EE20(int);
_DWORD *__stdcall sub_40EE25(int a1, _DWORD *a2);
int __stdcall sub_40EEEC(_DWORD *Src, int a2, int a3);
void *sub_40EFC0();
BOOL sub_40F010();
const CHAR *__stdcall sub_40F040(LPVOID *a1, const CHAR *a2);
int __fastcall sub_40F0C0(char *a1, char *a2);
void __stdcall __spoils<ecx> sub_40F0F0(LPVOID lpMem);
char *__fastcall sub_40F120(int a1, char *a2);
void __stdcall sub_40F180(LPVOID *a1, char *Str);
int __stdcall sub_40F1D0(LPVOID *a1, char *Str);
int __stdcall sub_40F280(unsigned int a1);
char *__stdcall sub_40F2C0(int a1, int a2);
char *__stdcall sub_40F340(int a1);
char *__stdcall sub_40F360(_DWORD *a1, _DWORD *a2, int a3);
char *__stdcall sub_40F3B0(int a1);
const CHAR *__stdcall sub_40F3C0(const CHAR *a1);
const CHAR *__stdcall sub_40F3E0(int a1);
unsigned int __stdcall sub_40F400(unsigned __int64 a1, __int64 a2);
int __stdcall sub_40F46C(int *a1);
int __stdcall sub_40F4B8(int a1, int *a2);
void __stdcall sub_40F63D(_BYTE *a1, signed int Size, char *Str, _BYTE *Src);
void __stdcall __spoils<edx,ecx> sub_40F91A(int a1, int *a2);
// int __usercall sub_40FA10@<eax>(double@<st0>);
int __stdcall sub_40FABB(int a1, int *a2);
CHAR *__stdcall sub_40FBA0(LPCCH lpMultiByteStr);
void __stdcall sub_40FC50(void *Block);
int __stdcall sub_40FC60(int a1, int a2);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl strnicmp(const char *String1, const char *String2, size_t MaxCount);
// int __cdecl stricmp(const char *String1, const char *String2);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// int sprintf(char *const Buffer, const char *const Format, ...);
// double __cdecl fabs(double X);
// double __cdecl ceil(double X);
// void *__cdecl malloc(size_t Size);
// double __cdecl floor(double X);
// void __cdecl free(void *Block);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl tolower(int C);
LRESULT __stdcall sub_40FD25(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
HWND __stdcall sub_40FDEE(HWND a1);
int __stdcall sub_40FF10(char *a1, int a2);
int __stdcall sub_410130(_BYTE *a1, _DWORD *a2, char *a3, _DWORD *a4);
// BOOL __stdcall ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo);
// BOOL __stdcall PathQuoteSpacesA(LPSTR lpsz);
// LPSTR __stdcall PathAddBackslashA(LPSTR pszPath);
// void __stdcall PathRemoveArgsA(LPSTR pszPath);
// LPSTR __stdcall PathGetArgsA(LPCSTR pszPath);
// BOOL __stdcall PathRenameExtensionA(LPSTR pszPath, LPCSTR pszExt);
// BOOL __stdcall PathUnquoteSpacesA(LPSTR lpsz);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_411002; // weak
int dword_4112C0[] = { -1073741819 }; // weak
char *off_4112C4 = "Invalid memory access"; // weak
_UNKNOWN unk_411538; // weak
char byte_41153C[] = { '0' }; // weak
int dword_411550[128] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307
}; // weak
int dword_412001 = -1; // weak
int dword_41200E = 0; // weak
CHAR WindowName = '\0'; // idb
char asc_41201F[2] = " "; // weak
char Str[2] = "*"; // idb
char asc_412023[2] = "?"; // weak
char asc_412025[2] = "\\"; // idb
char aB[2] = "B"; // idb
char asc_412029[2] = "F"; // idb
char aI[2] = "I"; // idb
char aN[2] = "N"; // idb
char aP[2] = "P"; // idb
char aS[2] = "S"; // idb
char asc_412035[2] = "X"; // idb
char aOpen[5] = "open"; // weak
char aSysnative[10] = "sysnative"; // weak
char aBat[] = ".bat"; // idb
char aExe[] = ".exe"; // idb
char asc_412050[3] = "\r\n"; // weak
CHAR aOk[] = "OK"; // idb
char asc_412056[5] = "\r\n\r\n"; // weak
_UNKNOWN unk_41205B; // weak
_UNKNOWN unk_412064; // weak
_UNKNOWN unk_41206C; // weak
_UNKNOWN unk_412074; // weak
const char aA[] = "∆õàåúÛˆ¿çõå‡éõçãîå√Ûˆ¿€ûŒõõàåú€‡ﬁ€Çœﬁ‡ﬁ€ÇŒﬁ‡ﬁ€ÇÕﬁ‡ﬁ€ÇÃﬁ‡ﬁ€ÇÀﬁ‡ﬁ€Ç ﬁ‡ﬁ€Ç…ﬁ‡ﬁ€Ç»ﬁ‡ﬁ€Ç«ﬁ‡¬‡ﬁ€ûŒõåõìêöóîõ€ﬁÛˆ¿çõå‡—ê‡éõçãîå√‡ƒ‡ﬁ€ûŒõåõìêöóîõ€ﬁÛˆ¿úõî‡ﬁ€ûŒõåõìêöóîõ€ﬁÛˆ¿ôëåë∆õëöÛˆÅ"; // idb
_DWORD dword_41230E[5] = { 1476021404, 746147636, 2090454134, 1717019059, 114637695 }; // weak
LPVOID lpMem = NULL; // idb
int dword_412328 = -1; // weak
SIZE_T dwBytes = 4096u; // idb
_UNKNOWN unk_412330; // weak
int dword_412370 = 0; // weak
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *SetEnvironmentVariableA)(LPCSTR lpName, LPCSTR lpValue);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern DWORD (__stdcall *TlsAlloc)();
// extern BOOL (__stdcall *CreateDirectoryA)(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern DWORD (__stdcall *GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *SetFileAttributesA)(LPCSTR lpFileName, DWORD dwFileAttributes);
// extern DWORD (__stdcall *GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *SetCurrentDirectoryA)(LPCSTR lpPathName);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern LPSTR (__stdcall *CharUpperA)(LPSTR lpsz);
// extern LPSTR (__stdcall *CharLowerA)(LPSTR lpsz);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern DWORD (__stdcall *GetWindowThreadProcessId)(HWND hWnd, LPDWORD lpdwProcessId);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *GetForegroundWindow)();
// extern BOOL (__stdcall *IsWindowEnabled)(HWND hWnd);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *EnumWindows)(WNDENUMPROC lpEnumFunc, LPARAM lParam);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern int (__stdcall *GetWindowTextLengthA)(HWND hWnd);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *SetRect)(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern DWORD (__stdcall *GetSysColor)(int nIndex);
// extern HBRUSH (__stdcall *GetSysColorBrush)(int nIndex);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern LRESULT (__stdcall *CallWindowProcA)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern BOOL (__stdcall *RedrawWindow)(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// extern HANDLE (__stdcall *RemovePropA)(HWND hWnd, LPCSTR lpString);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *SetPropA)(HWND hWnd, LPCSTR lpString, HANDLE hData);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern HANDLE (__stdcall *GetPropA)(HWND hWnd, LPCSTR lpString);
// extern HWND (__stdcall *GetWindow)(HWND hWnd, UINT uCmd);
// extern HWND (__stdcall *SetActiveWindow)(HWND hWnd);
// extern BOOL (__stdcall *UnregisterClassA)(LPCSTR lpClassName, HINSTANCE hInstance);
// extern BOOL (__stdcall *DestroyAcceleratorTable)(HACCEL hAccel);
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern BOOL (__stdcall *AdjustWindowRectEx)(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern HACCEL (__stdcall *CreateAcceleratorTableA)(LPACCEL paccel, int cAccel);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern DWORD (__stdcall *MsgWaitForMultipleObjects)(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern HWND (__stdcall *GetActiveWindow)();
// extern int (__stdcall *TranslateAcceleratorA)(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern HWND (__stdcall *GetFocus)();
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern int (__stdcall *FillRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern BOOL (__stdcall *EnumChildWindows)(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
// extern LRESULT (__stdcall *DefFrameProcA)(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *IsChild)(HWND hWndParent, HWND hWnd);
// extern int (__stdcall *GetClassNameA)(HWND hWnd, LPSTR lpClassName, int nMaxCount);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern BOOL (__stdcall *DestroyIcon)(HICON hIcon);
// extern UINT (__stdcall *RegisterWindowMessageA)(LPCSTR lpString);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern BOOL (__stdcall *GetTextExtentPoint32A)(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl);
// extern HBRUSH (__stdcall *CreateSolidBrush)(COLORREF color);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern DWORD (__stdcall *GetObjectType)(HGDIOBJ h);
// extern BOOL (__stdcall *InitCommonControlsEx)(const INITCOMMONCONTROLSEX *picce);
// extern HRESULT (__stdcall *CoInitialize)(LPVOID pvReserved);
// extern void (__stdcall *CoTaskMemFree)(LPVOID pv);
// extern HRESULT (__stdcall *RevokeDragDrop)(HWND hwnd);
// extern MMRESULT (__stdcall *timeBeginPeriod)(UINT uPeriod);
HANDLE hHeap = NULL; // idb
HMODULE hInstance = NULL; // idb
int dword_41345C = 0; // weak
LPCVOID lpBuffer = NULL; // idb
int dword_413464 = 0; // idb
int dword_413468 = 0; // idb
int dword_41346C = 0; // weak
int dword_413470 = 0; // weak
SIZE_T nNumberOfBytesToWrite = 0u; // idb
int dword_413478 = 0; // weak
char *Str1 = NULL; // idb
int dword_413480 = 0; // weak
char *dword_413484 = NULL; // idb
int dword_413488 = 0; // weak
int dword_41348C = 0; // weak
int dword_413490 = 0; // weak
int dword_413494 = 0; // weak
int dword_413498 = 0; // weak
int dword_41349C = 0; // weak
int dword_4134A0 = 0; // weak
int dword_4134A4 = 0; // weak
int dword_4134A8 = 0; // weak
int dword_4134AC = 0; // weak
int dword_4134B0 = 0; // idb
int dword_4134B4 = 0; // weak
int dword_4134B8 = 0; // weak
LPCSTR lpWindowName = NULL; // idb
int dword_4134C0 = 0; // weak
int dword_4134C4 = 0; // weak
int dword_4134C8 = 0; // weak
HMODULE hModule = NULL; // idb
LPCSTR lpFileName = NULL; // idb
int dword_4134D4 = 0; // weak
char *dword_4134D8 = NULL; // idb
int dword_4134DC = 0; // idb
LPCVOID dword_4134E0 = NULL; // idb
LPSTR lpsz = NULL; // idb
int dword_4134E8 = 0; // weak
LPCSTR dword_4134EC = NULL; // idb
LPCSTR dword_4134F0 = NULL; // idb
LPCVOID dword_4134F8 = NULL; // idb
void *dword_4134FC = NULL; // idb
SIZE_T dword_413500 = 0u; // idb
int dword_413504 = 0; // weak
int dword_413508 = 0; // weak
int dword_41350C = 0; // weak
char *dword_413510 = NULL; // idb
int dword_413514 = 0; // idb
int dword_413518 = 0; // weak
LPCSTR pszExt = NULL; // idb
LPCSTR dword_413520 = NULL; // idb
char *SubStr = NULL; // idb
int dword_413528 = 0; // weak
void *dword_41352C = NULL; // idb
LPCSTR lpText = NULL; // idb
int dword_413534 = 0; // weak
LPCSTR dword_413538 = NULL; // idb
int dword_41353C = 0; // weak
LPSTR Source = NULL; // idb
LPCSTR lpPathName = NULL; // idb
LPCSTR lpCaption = NULL; // idb
int dword_41354C = 0; // weak
int dword_413550 = 0; // weak
LPCSTR dword_413554 = NULL; // idb
int dword_413558 = 0; // weak
char *Src = NULL; // idb
int dword_413560 = 0; // weak
int dword_413564 = 0; // weak
DWORD dwFlags = 0u; // idb
int dword_413570 = 0; // weak
DWORD dword_413574 = 0u; // idb
int dword_413578 = 0; // weak
int dword_41357C = 0; // idb
int dword_413580 = 0; // weak
int dword_413584 = 0; // weak
int dword_413588[] = { 0 }; // weak
int dword_41358C[127] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // weak
int dword_413788; // weak
int dword_41378C; // weak
int dword_413790; // weak
LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter; // idb
int dword_413798; // weak
int dword_41379C; // weak
int dword_4137A0; // weak
int dword_4137A4; // weak
int dword_413810; // weak
int dword_413814; // weak
int dword_413828; // weak
int dword_41383C; // weak
WNDPROC lpPrevWndFunc; // idb
int dword_413848; // weak
int dword_41384C; // weak
int dword_413850; // weak
int dword_413854; // weak
int dword_4138B0; // weak
int dword_4138B4; // weak
int dword_4138C0; // weak
int dword_4138C4; // weak
int dword_4138D8; // weak
int dword_4138EC; // weak
int dword_4138F0; // weak
int dword_4138F4; // weak
int dword_413900; // weak
int dword_413904; // weak
int dword_413980; // weak
int dword_413994; // weak
int dword_413998; // weak
int dword_41399C; // weak
double dbl_4139A0; // weak
double dbl_4139A8; // weak
double dbl_4139B0; // weak
double dbl_4139B8; // weak
double dbl_4139C0; // weak
double dbl_4139C8; // weak
double dbl_4139D0; // weak
int dword_4139D8; // weak
HMODULE hLibModule; // idb
BOOL (__stdcall *AlphaBlend)(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
int dword_4139E4; // weak
int dword_4139E8; // idb
int dword_4139EC; // weak
struct _RTL_CRITICAL_SECTION stru_4139F0; // idb
union _RTL_RUN_ONCE stru_413A08; // weak
int (__stdcall *dword_413A28)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A2C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A30)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A34)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A38)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A3C)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A40)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_413A44)(_DWORD); // weak
int (__stdcall *dword_413A48)(_DWORD); // weak
int (__stdcall *dword_413A4C)(_DWORD); // weak
LPCSTR String2; // idb
int (__stdcall *dword_413A54)(_DWORD, _DWORD); // weak
int dword_413A58; // weak
int dword_413A5C; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_413A78; // weak
int dword_413A7C; // weak
int dword_413A80; // weak
int dword_413A84; // weak
int dword_413A88; // weak
int dword_413A8C; // weak
int dword_413A90; // weak
int dword_413A94; // weak
int dword_413A98; // weak
int dword_413A9C; // weak
int dword_413AA0; // weak
int dword_413AA4; // weak
int dword_413AA8; // weak
int dword_413AAC; // weak
int dword_413AB0; // weak
int dword_413AB4; // weak
int dword_413AB8; // weak
int dword_413ABC; // weak
int dword_413AC0; // weak
int dword_413AC4; // weak
int dword_413AC8; // weak
int dword_413ACC; // weak
int dword_413AD0; // weak
int dword_413AD4; // weak
int dword_413AD8; // weak
int dword_413ADC; // weak
int dword_413AE0; // weak
int dword_413AE4; // weak
struct _RTL_CRITICAL_SECTION stru_413AE8; // idb
int dword_413B00; // weak
int dword_413B04; // weak
int dword_413B08; // weak
int dword_413B0C; // weak
int dword_413B10; // weak
int dword_413B14; // weak
int dword_413B18; // weak
int dword_413B1C; // weak
int dword_413B20; // weak
int dword_413B24; // weak
HANDLE dword_413BA0; // idb
int dword_413BA4; // weak
int dword_413BA8; // weak
int dword_413BAC; // weak
HWND hWnd; // idb
int dword_413BB4; // weak
struct _RTL_CRITICAL_SECTION stru_413BB8; // idb
HANDLE dword_413BD0; // idb
SIZE_T dword_413BD4; // idb


//----- (00401000) --------------------------------------------------------
void __noreturn start()
{
  char v0; // al
  const CHAR *v2; // [esp-4h] [ebp-4h]
  const CHAR *v3; // [esp-4h] [ebp-4h]
  const CHAR *v4; // [esp-4h] [ebp-4h]
  const CHAR *v5; // [esp-4h] [ebp-4h]
  const CHAR *v6; // [esp-4h] [ebp-4h]
  const CHAR *v7; // [esp-4h] [ebp-4h]
  const CHAR *v8; // [esp-4h] [ebp-4h]
  const CHAR *v9; // [esp-4h] [ebp-4h]
  const CHAR *v10; // [esp-4h] [ebp-4h]
  const CHAR *v11; // [esp-4h] [ebp-4h]
  const CHAR *v12; // [esp-4h] [ebp-4h]
  const CHAR *v13; // [esp-4h] [ebp-4h]
  const CHAR *v14; // [esp-4h] [ebp-4h]
  const CHAR *v15; // [esp-4h] [ebp-4h]
  const CHAR *v16; // [esp-4h] [ebp-4h]
  const CHAR *v17; // [esp-4h] [ebp-4h]
  const CHAR *v18; // [esp-4h] [ebp-4h]
  const CHAR *v19; // [esp-4h] [ebp-4h]
  const CHAR *v20; // [esp-4h] [ebp-4h]
  const CHAR *v21; // [esp-4h] [ebp-4h]
  const CHAR *v22; // [esp-4h] [ebp-4h]
  const CHAR *v23; // [esp-4h] [ebp-4h]
  const CHAR *v24; // [esp-4h] [ebp-4h]
  const CHAR *v25; // [esp-4h] [ebp-4h]
  const CHAR *v26; // [esp-4h] [ebp-4h]
  const CHAR *v27; // [esp-4h] [ebp-4h]
  const CHAR *v28; // [esp-4h] [ebp-4h]
  const CHAR *v29; // [esp-4h] [ebp-4h]
  const CHAR *v30; // [esp-4h] [ebp-4h]
  const CHAR *v31; // [esp-4h] [ebp-4h]

  memset(&hHeap, 0, 0x12Cu);
  hInstance = GetModuleHandleA(0);
  hHeap = HeapCreate(0, 0x1000u, 0);
  sub_405000();
  dword_413488 = (int)dword_41230E;
  sub_40EFC0();
  sub_40EDAC();
  sub_40D2B3();
  sub_40CDE3();
  sub_40C790();
  sub_40C41B();
  sub_40C160();
  sub_40C142();
  sub_40C0B9();
  sub_40B821();
  sub_40A850();
  sub_409A61();
  sub_409726();
  sub_4093B7();
  sub_408421();
  sub_408099();
  sub_409745((LPVOID)dwFlags);
  sub_409694(8, &dwFlags, (int *)&unk_412064, 7);
  sub_40ECAD(8, 1025, 7, (int *)&unk_412074, &dword_413564);
  sub_40D2D2(4, 21, 0, (LPVOID *)&dword_41357C, 512);
  sub_409745((LPVOID)dword_413574);
  sub_409694(8, &dword_413574, (int *)&unk_41206C, 7);
  sub_405068((LPVOID *)&dword_413510, Str);
  dword_413500 = (char *)dword_41230E - &aA[173];
  dword_413504 = (int)&aA[173];
  dword_4134D4 = (int)sub_40C1D0((char *)dword_41230E - &aA[173]);
  dword_413494 = 0;
  do
  {
    if ( (int)dword_413500 < dword_413494 )
      break;
    v0 = sub_40C1F0((char *)(dword_413494 + dword_413504));
    sub_40C200((_BYTE *)(dword_413494 + dword_4134D4), -v0);
  }
  while ( !__OFADD__(1, dword_413494++) );
  v2 = String2;
  sub_40C210((const char *)(dword_4134D4 + 4), dword_413500 - 8, (int)String2);
  sub_40F040((LPVOID *)&Str1, v2);
  v3 = String2;
  sub_4050D0(Str1, dword_413510, (int)String2);
  sub_40F040((LPVOID *)&Str1, v3);
  v4 = String2;
  sub_4051B0(Str1, 1, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134B4, v4);
  v5 = String2;
  sub_4051B0(Str1, 2, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413508, v5);
  v6 = String2;
  sub_4051B0(Str1, 3, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134AC, v6);
  v7 = String2;
  sub_4051B0(Str1, 4, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413560, v7);
  v8 = String2;
  sub_4051B0(Str1, 5, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134B8, v8);
  v9 = String2;
  sub_4051B0(Str1, 6, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413528, v9);
  v10 = String2;
  sub_4051B0(Str1, 7, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413480, v10);
  v11 = String2;
  sub_4051B0(Str1, 8, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134C4, v11);
  v12 = String2;
  sub_4051B0(Str1, 9, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_41354C, v12);
  v13 = String2;
  sub_4051B0(Str1, 10, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_41348C, v13);
  v14 = String2;
  sub_4051B0(Str1, 11, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413558, v14);
  v15 = String2;
  sub_4051B0(Str1, 12, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413518, v15);
  v16 = String2;
  sub_4051B0(Str1, 13, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134C8, v16);
  v17 = String2;
  sub_4051B0(Str1, 14, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134F8, v17);
  v18 = String2;
  sub_4051B0(Str1, 15, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_41346C, v18);
  v19 = String2;
  sub_4051B0(Str1, 16, dword_413510, String2);
  sub_40F040((LPVOID *)&lpCaption, v19);
  v20 = String2;
  sub_4051B0(Str1, 17, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413490, v20);
  v21 = String2;
  sub_4051B0(Str1, 18, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134F0, v21);
  v22 = String2;
  sub_4051B0(Str1, 19, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413520, v22);
  v23 = String2;
  sub_4051B0(Str1, 20, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134EC, v23);
  v24 = String2;
  sub_4051B0(Str1, 21, dword_413510, String2);
  sub_40F040((LPVOID *)&lpText, v24);
  v25 = String2;
  sub_4051B0(Str1, 22, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413514, v25);
  v26 = String2;
  sub_4051B0(Str1, 23, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413538, v26);
  v27 = String2;
  sub_4051B0(Str1, 24, dword_413510, String2);
  sub_40F040((LPVOID *)&lpWindowName, v27);
  v28 = String2;
  sub_4051B0(Str1, 25, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134C0, v28);
  v29 = String2;
  sub_4051B0(Str1, 26, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_413534, v29);
  v30 = String2;
  sub_4051B0(Str1, 27, dword_413510, String2);
  sub_40F040((LPVOID *)&dword_4134E8, v30);
  if ( sub_40A60F() < 60 )
  {
    sub_4080D0(lpCaption, lpText, 0x10u);
    sub_4017C5();
    sub_40F010();
    HeapDestroy(hHeap);
    ExitProcess(0);
  }
  dword_413494 = dword_41230E[0];
  dword_413488 = (int)&dword_41230E[1];
  dword_413498 = dword_41230E[1];
  dword_413488 = (int)&dword_41230E[2];
  dword_41349C = dword_41230E[2];
  dword_413488 = (int)&dword_41230E[3];
  dword_4134A0 = dword_41230E[3];
  dword_413488 = (int)&dword_41230E[4];
  dword_4134A4 = dword_41230E[4];
  dword_413488 = (int)&dword_41230E[5];
  dword_4134A8 = (int)sub_40C1D0(20);
  sub_40C270((_DWORD *)dword_4134A8, dword_413494);
  sub_40C270((_DWORD *)(dword_4134A8 + 4), dword_413498);
  sub_40C270((_DWORD *)(dword_4134A8 + 8), dword_41349C);
  sub_40C270((_DWORD *)(dword_4134A8 + 12), dword_4134A0);
  sub_40C270((_DWORD *)(dword_4134A8 + 16), dword_4134A4);
  v31 = String2;
  sub_40D890(dword_4134A8, 0x14u, (int)String2);
  sub_40F040((LPVOID *)&Src, v31);
  sub_408AD6();
  sub_405068((LPVOID *)&SubStr, asc_412025);
  sub_405068((LPVOID *)&pszExt, aBat);
  sub_405068((LPVOID *)&dword_4134DC, aExe);
  sub_4094B0((LPTOP_LEVEL_EXCEPTION_FILTER)TopLevelExceptionFilter);
  sub_404225();
}
// 401000: using guessed type void __noreturn start();
// 404225: using guessed type void __noreturn sub_404225(void);
// 41230E: using guessed type _DWORD dword_41230E[5];
// 41346C: using guessed type int dword_41346C;
// 413480: using guessed type int dword_413480;
// 413488: using guessed type int dword_413488;
// 41348C: using guessed type int dword_41348C;
// 413490: using guessed type int dword_413490;
// 413494: using guessed type int dword_413494;
// 413498: using guessed type int dword_413498;
// 41349C: using guessed type int dword_41349C;
// 4134A0: using guessed type int dword_4134A0;
// 4134A4: using guessed type int dword_4134A4;
// 4134A8: using guessed type int dword_4134A8;
// 4134AC: using guessed type int dword_4134AC;
// 4134B4: using guessed type int dword_4134B4;
// 4134B8: using guessed type int dword_4134B8;
// 4134C0: using guessed type int dword_4134C0;
// 4134C4: using guessed type int dword_4134C4;
// 4134C8: using guessed type int dword_4134C8;
// 4134D4: using guessed type int dword_4134D4;
// 4134E8: using guessed type int dword_4134E8;
// 413504: using guessed type int dword_413504;
// 413508: using guessed type int dword_413508;
// 413518: using guessed type int dword_413518;
// 413528: using guessed type int dword_413528;
// 413534: using guessed type int dword_413534;
// 41354C: using guessed type int dword_41354C;
// 413558: using guessed type int dword_413558;
// 413560: using guessed type int dword_413560;
// 413564: using guessed type int dword_413564;

//----- (004017C5) --------------------------------------------------------
BOOL sub_4017C5()
{
  sub_4093CB();
  sub_409600();
  sub_409AD1();
  sub_40A839();
  sub_40B8AF();
  sub_40C0AD();
  sub_40C427();
  sub_40C780();
  sub_40D190();
  return sub_40C180();
}

//----- (00402000) --------------------------------------------------------
_BYTE *__stdcall sub_402000(_BYTE *a1, int a2, char *Str)
{
  char v3; // zf
  bool v4; // of
  _DWORD *v5; // eax
  int v6; // ebp
  _DWORD *v7; // eax
  int v9; // [esp-4h] [ebp-48h]
  int v10; // [esp-4h] [ebp-48h]
  LPVOID lpMem; // [esp+0h] [ebp-44h] BYREF
  int v12; // [esp+4h] [ebp-40h]
  int v13; // [esp+8h] [ebp-3Ch]
  int v14; // [esp+Ch] [ebp-38h]
  int v15; // [esp+10h] [ebp-34h]
  int v16; // [esp+14h] [ebp-30h]
  unsigned int v17; // [esp+18h] [ebp-2Ch]
  _DWORD *v18; // [esp+1Ch] [ebp-28h]
  _BYTE *v19; // [esp+20h] [ebp-24h]
  _BYTE *v20; // [esp+24h] [ebp-20h]
  _DWORD *v21; // [esp+28h] [ebp-1Ch] BYREF
  int v22[5]; // [esp+30h] [ebp-14h] BYREF

  sub_405060(&lpMem, Str);
  v15 = 1;
  sub_40F0C0(0, (char *)lpMem);
  if ( v3 )
  {
    sub_40ECAD(4, 256, 21, 0, (int *)&v21);
    sub_40ECAD(4, 256, 21, 0, v22);
    v17 = sub_4052C0((const char *)lpMem);
    v18 = v21;
    v19 = lpMem;
    v12 = 0;
    do
    {
      if ( v12 > 255 )
        break;
      *v18++ = v12;
      if ( !*v19 )
        v19 = lpMem;
      *(_DWORD *)(v22[0] + 4 * v12) = (char)*v19++;
      v4 = __OFADD__(1, v12++);
    }
    while ( !v4 );
    v15 = 0;
    v12 = 0;
    do
    {
      if ( v12 > 255 )
        break;
      v15 = (unsigned __int8)(*(_BYTE *)(v22[0] + 4 * v12) + LOBYTE(v21[v12]) + v15);
      v5 = &v21[v12];
      v9 = v21[v15];
      v21[v15] = *v5;
      *v5 = v9;
      v4 = __OFADD__(1, v12++);
    }
    while ( !v4 );
    v12 = 0;
    v15 = 0;
    v20 = a1;
    v14 = 0;
    do
    {
      if ( a2 - 1 < v14 )
        break;
      v12 = (unsigned __int8)(v12 + 1);
      v6 = (int)v21;
      v15 = (unsigned __int8)(LOBYTE(v21[v12]) + v15);
      v7 = &v21[v12];
      v10 = v21[v15];
      v21[v15] = *v7;
      *v7 = v10;
      v13 = (unsigned __int8)(*(_DWORD *)(v6 + 4 * v15) + *(_DWORD *)(v6 + 4 * v12));
      v16 = *(_DWORD *)(v6 + 4 * v13);
      *v20++ ^= v16;
      v4 = __OFADD__(1, v14++);
    }
    while ( !v4 );
  }
  sub_40F0F0(lpMem);
  sub_40EDD5((int)v21);
  sub_40EDD5(v22[0]);
  return a1;
}
// 402033: variable 'v3' is possibly undefined
// 402000: using guessed type int var_14[5];

//----- (00402274) --------------------------------------------------------
const CHAR *__cdecl sub_402274(const CHAR *a1)
{
  int v1; // ecx
  char v2; // zf
  unsigned int v3; // eax
  int v4; // ecx
  const CHAR *result; // eax
  const CHAR *v6; // [esp-4h] [ebp-14h]
  LPCSTR v7; // [esp+0h] [ebp-10h]
  LPCSTR v8; // [esp+0h] [ebp-10h]
  const CHAR *v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+4h] [ebp-Ch]
  const CHAR *v11; // [esp+4h] [ebp-Ch]
  LPCSTR v12; // [esp+4h] [ebp-Ch]
  LPVOID lpMem[2]; // [esp+8h] [ebp-8h] BYREF

  lpMem[0] = 0;
  String2 = a1;
  sub_40F0C0(0, (char *)dword_41353C);
  if ( v2 )
  {
    v9 = String2;
    sub_40F120(v1, (char *)dword_41353C);
    sub_40F040(lpMem, v9);
    goto LABEL_13;
  }
  sub_40AB60(0, 0, 0, 200, 110, dword_413538, 13107201);
  sub_409D43((_DWORD *)1, 21, 15, 158, 20, lpWindowName);
  sub_409F1C((_DWORD *)2, 21, 40, 158, 20, &WindowName, 0x20u);
  sub_40A229((_DWORD *)3, 61, 75, 78, 20, aOk);
  sub_40AB83(0, 13, 4);
  sub_40A249(2);
  do
  {
    while ( 1 )
    {
      v10 = sub_40AD87();
      if ( v10 == 13116 )
      {
        RemoveDirectoryA(lpPathName);
        goto LABEL_16;
      }
      if ( v10 != 13101 )
        break;
      if ( sub_40D19D() == 4 )
        goto LABEL_8;
    }
  }
  while ( v10 != 13100 || sub_40D1AC() != 3 );
LABEL_8:
  v6 = String2;
  sub_40A284(2, (int)String2);
  sub_40F040(lpMem, v6);
  sub_40A723(0);
LABEL_13:
  v11 = String2;
  v7 = String2;
  v3 = sub_4052C0((const char *)lpMem[0]);
  sub_40D890((int)lpMem[0], v3, (int)v7);
  v8 = ++String2;
  sub_40C210((const char *)lpBuffer, nNumberOfBytesToWrite, (int)String2);
  String2 = v11;
  sub_40F0C0((char *)&v11[(_DWORD)::lpMem], (char *)&v8[(_DWORD)::lpMem]);
  if ( v2 )
  {
    sub_4080D0(lpCaption, dword_413520, 0x10u);
    RemoveDirectoryA(lpPathName);
LABEL_16:
    JUMPOUT(0x4017AB);
  }
  v12 = String2;
  sub_40F120(v4, (char *)lpMem[0]);
  result = &v12[(_DWORD)::lpMem];
  sub_40F0F0(lpMem[0]);
  return result;
}
// 402386: control flows out of bounds to 4017AB
// 40228E: variable 'v2' is possibly undefined
// 40229C: variable 'v1' is possibly undefined
// 4024BE: variable 'v4' is possibly undefined
// 41353C: using guessed type int dword_41353C;

//----- (004024E7) --------------------------------------------------------
int __stdcall sub_4024E7(char *Str, char *a2)
{
  char v2; // zf
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ebp
  int result; // eax
  LPCSTR v27; // [esp+0h] [ebp-3Ch]
  const CHAR *v28; // [esp+4h] [ebp-38h]
  const CHAR *v29; // [esp+4h] [ebp-38h]
  const CHAR *v30; // [esp+4h] [ebp-38h]
  const CHAR *v31; // [esp+4h] [ebp-38h]
  const CHAR *v32; // [esp+4h] [ebp-38h]
  const CHAR *v33; // [esp+4h] [ebp-38h]
  const CHAR *v34; // [esp+4h] [ebp-38h]
  const CHAR *v35; // [esp+4h] [ebp-38h]
  const CHAR *v36; // [esp+4h] [ebp-38h]
  LPVOID lpMem; // [esp+8h] [ebp-34h] BYREF
  LPVOID v38; // [esp+Ch] [ebp-30h] BYREF
  int i; // [esp+10h] [ebp-2Ch]
  char *Str1; // [esp+14h] [ebp-28h] BYREF
  int v41; // [esp+18h] [ebp-24h]
  LPVOID v42; // [esp+1Ch] [ebp-20h] BYREF
  LPVOID v43; // [esp+20h] [ebp-1Ch] BYREF
  int v44; // [esp+24h] [ebp-18h]
  int v45; // [esp+28h] [ebp-14h]
  LPVOID v46; // [esp+2Ch] [ebp-10h] BYREF
  int v47; // [esp+30h] [ebp-Ch]

  sub_405060(&lpMem, Str);
  sub_405060(&v38, a2);
  for ( i = 1; ; sub_40EE25(i + 1025, &dword_413564) )
  {
    v28 = String2;
    sub_4051B0((char *)lpMem, i, ::Str, String2);
    sub_40F040((LPVOID *)&Str1, v28);
    sub_40F0C0(0, Str1);
    if ( !v2 )
      break;
    if ( i % 2 )
    {
      v29 = String2;
      sub_40F120(2, Str1);
      sub_40F040((LPVOID *)(8 * v41 + dword_413564), v29);
      if ( sub_405440(Str1, SubStr) )
      {
        sub_405068(&v42, &WindowName);
        sub_405068(&v43, &WindowName);
        v44 = sub_4054A0(Str1, SubStr);
        v45 = 0;
        do
        {
          if ( v44 - 1 < v45 )
            break;
          sub_40F0C0((char *)v42, &WindowName);
          if ( v2 )
          {
            v30 = String2;
            sub_40F120(v4, (char *)v42);
            sub_40F040(&v43, v30);
          }
          v31 = String2;
          sub_4051B0(Str1, v45 + 1, SubStr, String2);
          sub_40F040(&v46, v31);
          v32 = String2;
          v27 = String2;
          sub_40F120(v5, (char *)v38);
          sub_40F120(v6, SubStr);
          sub_40F120(v7, (char *)v43);
          sub_40F120(v8, (char *)v46);
          sub_40C437((char *)&v27[(_DWORD)::lpMem]);
          String2 = v32;
          v33 = String2;
          sub_40F120(v9, (char *)v42);
          sub_40F120(v10, (char *)v46);
          sub_40F120(v11, SubStr);
          sub_40F040(&v42, v33);
          v34 = String2;
          sub_40F120(v12, (char *)v38);
          sub_40F120(v13, SubStr);
          sub_40F120(v14, (char *)v43);
          sub_40F120(v15, (char *)v46);
          String2 = v34;
          if ( *sub_40D3A8(dword_41357C, (char *)&v34[(_DWORD)::lpMem]) < 1 )
          {
            v35 = String2;
            sub_40F120(v16, (char *)v38);
            sub_40F120(v17, SubStr);
            sub_40F120(v18, (char *)v43);
            sub_40F120(v19, (char *)v46);
            String2 = v35;
            *sub_40D3A8(dword_41357C, (char *)&v35[(_DWORD)::lpMem]) = 1;
            sub_4097AD((int *)dword_413574);
            v36 = String2;
            sub_40F120(v20, (char *)v38);
            sub_40F120(v21, SubStr);
            sub_40F120(v22, (char *)v43);
            sub_40F120(v23, (char *)v46);
            v24 = dword_413578;
            sub_40F040((LPVOID *)(dword_413578 + 12), v36);
            *(_DWORD *)(v24 + 8) = v47++;
          }
        }
        while ( !__OFADD__(1, v45++) );
      }
    }
    else
    {
      v3 = sub_4052F0(Str1);
      *(_DWORD *)(8 * v41++ + dword_413564 + 4) = v3;
    }
    ++i;
  }
  result = v41;
  sub_40F0F0(lpMem);
  sub_40F0F0(v43);
  sub_40F0F0(v42);
  sub_40F0F0(v46);
  sub_40F0F0(Str1);
  sub_40F0F0(v38);
  return result;
}
// 40254F: variable 'v2' is possibly undefined
// 402633: variable 'v4' is possibly undefined
// 40267D: variable 'v5' is possibly undefined
// 402688: variable 'v6' is possibly undefined
// 402691: variable 'v7' is possibly undefined
// 40269A: variable 'v8' is possibly undefined
// 4026BD: variable 'v9' is possibly undefined
// 4026C6: variable 'v10' is possibly undefined
// 4026D1: variable 'v11' is possibly undefined
// 4026EA: variable 'v12' is possibly undefined
// 4026F5: variable 'v13' is possibly undefined
// 4026FE: variable 'v14' is possibly undefined
// 402707: variable 'v15' is possibly undefined
// 402741: variable 'v16' is possibly undefined
// 40274C: variable 'v17' is possibly undefined
// 402755: variable 'v18' is possibly undefined
// 40275E: variable 'v19' is possibly undefined
// 40279E: variable 'v20' is possibly undefined
// 4027A9: variable 'v21' is possibly undefined
// 4027B2: variable 'v22' is possibly undefined
// 4027BB: variable 'v23' is possibly undefined
// 413564: using guessed type int dword_413564;
// 413578: using guessed type int dword_413578;

//----- (00402859) --------------------------------------------------------
const CHAR *__userpurge sub_402859@<eax>(int a1, const CHAR *a2)
{
  int v2; // ecx
  int v3; // ecx
  char v4; // zf
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  const CHAR *result; // eax
  const CHAR *v11; // [esp-4h] [ebp-1Ch]
  const CHAR *v12; // [esp-4h] [ebp-1Ch]
  const CHAR *v13; // [esp-4h] [ebp-1Ch]
  const CHAR *v14; // [esp-4h] [ebp-1Ch]
  const CHAR *v15; // [esp-4h] [ebp-1Ch]
  LPCSTR v16; // [esp-4h] [ebp-1Ch]
  LPSTR lpsz; // [esp+0h] [ebp-18h] BYREF
  int v18; // [esp+4h] [ebp-14h]
  LPVOID v19; // [esp+8h] [ebp-10h] BYREF
  int v20; // [esp+Ch] [ebp-Ch]
  LPVOID lpMem[2]; // [esp+10h] [ebp-8h] BYREF

  lpMem[0] = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  lpsz = 0;
  String2 = a2;
  sub_408450((int)a2);
  sub_40F040((LPVOID *)&lpsz, a2);
  PathQuoteSpacesA(lpsz);
  if ( a1 <= 0 )
  {
    v15 = String2;
    sub_40F120(v2, lpsz);
    sub_40F040(lpMem, v15);
  }
  else
  {
    v18 = 0;
    do
    {
      if ( a1 - 1 < v18 )
        break;
      v11 = String2;
      sub_40856C(v18, (int)String2);
      sub_40F040(&v19, v11);
      sub_40F0C0((char *)v19, (char *)dword_4134B8);
      if ( v4 )
      {
        if ( v20 == 1 )
        {
          v12 = String2;
          sub_40F120(v3, (char *)v19);
          sub_40F040((LPVOID *)&dword_41353C, v12);
          v20 = 0;
        }
      }
      else
      {
        v20 = 1;
      }
    }
    while ( !__OFADD__(1, v18++) );
    sub_402EA8(String2);
    sub_40F040(lpMem, v13);
    v14 = String2;
    sub_40F120(v6, lpsz);
    sub_40F120(v7, asc_41201F);
    sub_40F120(v8, (char *)lpMem[0]);
    sub_40F040(lpMem, v14);
  }
  v16 = String2;
  sub_40F120(v9, (char *)lpMem[0]);
  result = &v16[(_DWORD)::lpMem];
  sub_40F0F0(lpsz);
  sub_40F0F0(lpMem[0]);
  sub_40F0F0(v19);
  return result;
}
// 4028DB: variable 'v4' is possibly undefined
// 4028FA: variable 'v3' is possibly undefined
// 402929: variable 'v13' is possibly undefined
// 402937: variable 'v6' is possibly undefined
// 402941: variable 'v7' is possibly undefined
// 40294A: variable 'v8' is possibly undefined
// 402964: variable 'v2' is possibly undefined
// 40297D: variable 'v9' is possibly undefined
// 4134B8: using guessed type int dword_4134B8;
// 41353C: using guessed type int dword_41353C;

//----- (004029BA) --------------------------------------------------------
void __stdcall __noreturn TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  LPCSTR v1; // [esp+0h] [ebp-Ch]
  const CHAR *v2; // [esp+8h] [ebp-4h]

  v2 = String2;
  v1 = String2;
  sub_409680((int)String2);
  ++String2;
  sub_4080D0(lpCaption, &v1[(_DWORD)lpMem], 0x10u);
  String2 = v2;
  JUMPOUT(0x4017AB);
}
// 4029FC: control flows out of bounds to 4017AB

//----- (00402A04) --------------------------------------------------------
DWORD __stdcall sub_402A04(char *Str, char *a2, char *a3)
{
  DWORD result; // eax
  LPVOID lpMem; // [esp+4h] [ebp-58h] BYREF
  LPVOID v5; // [esp+8h] [ebp-54h] BYREF
  LPVOID v6; // [esp+Ch] [ebp-50h] BYREF
  SHELLEXECUTEINFOA pExecInfo; // [esp+10h] [ebp-4Ch] BYREF
  BOOL v8; // [esp+4Ch] [ebp-10h]
  DWORD ExitCode[3]; // [esp+50h] [ebp-Ch] BYREF

  sub_405060(&lpMem, Str);
  sub_405060(&v5, a2);
  sub_405060(&v6, a3);
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 320;
  pExecInfo.nShow = 0;
  pExecInfo.lpVerb = aOpen;
  pExecInfo.lpFile = (LPCSTR)lpMem;
  pExecInfo.lpParameters = (LPCSTR)v6;
  pExecInfo.lpDirectory = (LPCSTR)v5;
  v8 = ShellExecuteExA(&pExecInfo);
  do
  {
    do
      sub_40A702(0x19u);
    while ( !GetExitCodeProcess(pExecInfo.hProcess, ExitCode) );
  }
  while ( ExitCode[0] == 259 );
  result = ExitCode[0];
  sub_40F0F0(lpMem);
  sub_40F0F0(v5);
  sub_40F0F0(v6);
  return result;
}
// 402A04: using guessed type DWORD ExitCode[3];

//----- (00402AE6) --------------------------------------------------------
int sub_402AE6()
{
  int v0; // ecx
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int result; // eax
  const CHAR *v5; // [esp-4h] [ebp-10h]
  const CHAR *v6; // [esp-4h] [ebp-10h]
  const CHAR *v7; // [esp-4h] [ebp-10h]
  const CHAR *v8; // [esp-4h] [ebp-10h]
  CHAR *lpTempFileName; // [esp+0h] [ebp-Ch]
  LPCSTR lpPathName; // [esp+4h] [ebp-8h] BYREF
  LPSTR lpsz; // [esp+8h] [ebp-4h] BYREF

  lpsz = 0;
  lpPathName = 0;
  if ( sub_4033E3(hModule, asc_412035) )
  {
    lpTempFileName = (CHAR *)sub_40C1D0(1024);
    v5 = String2;
    sub_40C4AD((int)String2);
    sub_40F040((LPVOID *)&lpPathName, v5);
    GetTempFileNameA(lpPathName, &WindowName, 0, lpTempFileName);
    v6 = String2;
    sub_40C280(lpTempFileName, (int)String2);
    sub_40F040((LPVOID *)&Source, v6);
    sub_40C2D0(lpTempFileName);
    sub_40C53C(Source);
    sub_40C437(Source);
    PathAddBackslashA(Source);
    v7 = String2;
    sub_40F120(v0, Source);
    sub_40F120(v1, (char *)dword_413508);
    sub_40F120(v2, (char *)dword_4134DC);
    sub_40F040((LPVOID *)&lpFileName, v7);
    sub_40C930(0, lpFileName);
    sub_40CAB0(0, lpBuffer, nNumberOfBytesToWrite);
    sub_40C710(0);
    v8 = String2;
    sub_40F120(v3, (char *)lpFileName);
    sub_40F040((LPVOID *)&lpsz, v8);
    PathQuoteSpacesA(lpsz);
    sub_4085CD((const CHAR *)dword_4134B4, lpsz);
    sub_4085CD((const CHAR *)dword_413508, (const CHAR *)dword_4134AC);
    dword_413470 = 1;
  }
  result = 0;
  sub_40F0F0((LPVOID)lpPathName);
  sub_40F0F0(lpsz);
  return result;
}
// 402B97: variable 'v0' is possibly undefined
// 402BA2: variable 'v1' is possibly undefined
// 402BAD: variable 'v2' is possibly undefined
// 402BFA: variable 'v3' is possibly undefined
// 413470: using guessed type int dword_413470;
// 4134AC: using guessed type int dword_4134AC;
// 4134B4: using guessed type int dword_4134B4;
// 413508: using guessed type int dword_413508;

//----- (00402C54) --------------------------------------------------------
void __noreturn sub_402C54()
{
  int v0; // ecx
  char v1; // zf
  LPCSTR v2; // [esp+0h] [ebp-14h]
  LPCSTR v3; // [esp+4h] [ebp-10h]
  LPCSTR v4; // [esp+4h] [ebp-10h]
  LPCSTR v5; // [esp+8h] [ebp-Ch]
  LPCSTR v6; // [esp+8h] [ebp-Ch]
  const CHAR *v7; // [esp+Ch] [ebp-8h]
  const CHAR *v8; // [esp+Ch] [ebp-8h]
  const CHAR *v9; // [esp+Ch] [ebp-8h]
  char *v10; // [esp+10h] [ebp-4h] BYREF

  v10 = 0;
  v7 = String2;
  v5 = String2;
  v3 = String2;
  sub_40C54A((int)String2);
  ++String2;
  sub_408143(dword_413514, (char *)&v3[(_DWORD)lpMem], (int)v5);
  sub_40F040((LPVOID *)&v10, v7);
  sub_40F0C0(0, v10);
  if ( v1 )
  {
    v8 = String2;
    sub_40F120(v0, v10);
    sub_40F040((LPVOID *)&dword_4134D8, v8);
    sub_40C58A(dword_4134D8);
    sub_40F0C0(0, dword_413484);
    if ( v1 )
      sub_402FAA(dword_413484);
    if ( sub_40C930(1, lpsz) )
    {
      sub_40CB10(1, (char *)dword_4134E0);
      sub_40C710(1);
    }
  }
  v9 = String2;
  v6 = String2;
  v4 = String2;
  v2 = String2;
  sub_408450((int)String2);
  sub_40C59C((char *)&v2[(_DWORD)lpMem], (int)v4);
  sub_40C58A(&v6[(_DWORD)lpMem]);
  String2 = v9;
  RemoveDirectoryA(lpPathName);
  JUMPOUT(0x4017AB);
}
// 402D67: control flows out of bounds to 4017AB
// 402CA3: variable 'v1' is possibly undefined
// 402CAE: variable 'v0' is possibly undefined
// 402C54: using guessed type void __noreturn sub_402C54();

//----- (00402D7A) --------------------------------------------------------
int __stdcall sub_402D7A(char *a1)
{
  int v1; // ecx
  int result; // eax
  const CHAR *v3; // [esp-4h] [ebp-18h]
  const CHAR *v4; // [esp+0h] [ebp-14h]
  const CHAR *v5; // [esp+0h] [ebp-14h]
  const CHAR *v6; // [esp+0h] [ebp-14h]
  int v7; // [esp+0h] [ebp-14h]
  CHAR *lpTempFileName; // [esp+4h] [ebp-10h]
  LPCSTR lpPathName; // [esp+8h] [ebp-Ch] BYREF
  int v10; // [esp+Ch] [ebp-8h]

  v10 = 0;
  lpPathName = 0;
  lpTempFileName = (CHAR *)sub_40C1D0(1024);
  v4 = String2;
  sub_40C4AD((int)String2);
  sub_40F040((LPVOID *)&lpPathName, v4);
  GetTempFileNameA(lpPathName, &WindowName, 0, lpTempFileName);
  v5 = String2;
  sub_40C280(lpTempFileName, (int)String2);
  sub_40F040((LPVOID *)&::lpPathName, v5);
  sub_40C2D0(lpTempFileName);
  sub_40C53C(::lpPathName);
  sub_40C437((char *)::lpPathName);
  v6 = String2;
  sub_40C54A((int)String2);
  sub_40F040((LPVOID *)&dword_4134D8, v6);
  v7 = sub_40C1F0(a1);
  if ( v7 )
  {
    if ( v7 == 1 )
      v10 = 1;
  }
  else
  {
    v3 = String2;
    sub_40F120(v1, (char *)::lpPathName);
    sub_40F040((LPVOID *)&dword_4134D8, v3);
    v10 = 2;
  }
  dword_41350C = sub_40C1F0(&a1[v10]);
  dword_41345C = sub_40C1F0(&a1[v10 + 1]);
  result = 1;
  sub_40F0F0((LPVOID)lpPathName);
  return result;
}
// 402E38: variable 'v1' is possibly undefined
// 41345C: using guessed type int dword_41345C;
// 41350C: using guessed type int dword_41350C;

//----- (00402EA8) --------------------------------------------------------
const CHAR *__cdecl sub_402EA8(const CHAR *a1)
{
  const char *CommandLineA; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // ecx
  const CHAR *result; // eax
  LPCSTR v6; // [esp+0h] [ebp-28h]
  LPCSTR v7; // [esp+4h] [ebp-24h]
  const CHAR *v8; // [esp+Ch] [ebp-1Ch]
  const CHAR *v9; // [esp+Ch] [ebp-1Ch]
  LPCSTR v10; // [esp+Ch] [ebp-1Ch]
  LPVOID lpMem; // [esp+10h] [ebp-18h] BYREF
  LPSTR pszPath; // [esp+14h] [ebp-14h] BYREF
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  LPVOID v15; // [esp+20h] [ebp-8h] BYREF

  v15 = 0;
  v14 = 0;
  v13 = 0;
  pszPath = 0;
  lpMem = 0;
  String2 = a1;
  CommandLineA = GetCommandLineA();
  sub_40C280(CommandLineA, (int)a1);
  sub_40F040(&lpMem, a1);
  v8 = String2;
  sub_40F120(v2, (char *)lpMem);
  sub_40F040((LPVOID *)&pszPath, v8);
  PathRemoveArgsA(pszPath);
  v13 = v3;
  v14 = sub_4052C0(pszPath);
  if ( v14 > 0 )
  {
    v9 = String2;
    sub_40F120(v4, asc_41201F);
    v7 = String2;
    v6 = String2;
    sub_4055A0((const char *)lpMem, v14 + 1, String2);
    sub_405190(&v6[(_DWORD)::lpMem], (int)v7);
    sub_40F040(&v15, v9);
  }
  v10 = String2;
  sub_40F120(v4, (char *)v15);
  result = &v10[(_DWORD)::lpMem];
  sub_40F0F0(pszPath);
  sub_40F0F0(lpMem);
  sub_40F0F0(v15);
  return result;
}
// 402EE3: variable 'v2' is possibly undefined
// 402EFC: variable 'v3' is possibly undefined
// 402F20: variable 'v4' is possibly undefined

//----- (00402FAA) --------------------------------------------------------
int __stdcall sub_402FAA(char *Str)
{
  int v1; // ecx
  char v2; // zf
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ebp
  int v8; // ecx
  int v9; // ecx
  signed int v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int result; // eax
  LPCSTR v19; // [esp+Ch] [ebp-40h]
  LPCSTR v20; // [esp+Ch] [ebp-40h]
  char *v21; // [esp+10h] [ebp-3Ch]
  LPCSTR v22; // [esp+10h] [ebp-3Ch]
  LPCSTR v23; // [esp+10h] [ebp-3Ch]
  LPCSTR v24; // [esp+10h] [ebp-3Ch]
  LPCSTR v25; // [esp+14h] [ebp-38h]
  const CHAR *v26; // [esp+14h] [ebp-38h]
  LPCSTR v27; // [esp+14h] [ebp-38h]
  const CHAR *v28; // [esp+18h] [ebp-34h]
  const CHAR *v29; // [esp+18h] [ebp-34h]
  const CHAR *v30; // [esp+18h] [ebp-34h]
  const CHAR *v31; // [esp+18h] [ebp-34h]
  const CHAR *v32; // [esp+18h] [ebp-34h]
  const CHAR *v33; // [esp+18h] [ebp-34h]
  const CHAR *v34; // [esp+18h] [ebp-34h]
  const CHAR *v35; // [esp+18h] [ebp-34h]
  const CHAR *v36; // [esp+18h] [ebp-34h]
  const CHAR *v37; // [esp+18h] [ebp-34h]
  LPVOID lpMem[2]; // [esp+1Ch] [ebp-30h] BYREF
  char *v39; // [esp+24h] [ebp-28h] BYREF
  int v40; // [esp+28h] [ebp-24h]
  int v41; // [esp+2Ch] [ebp-20h]
  LPCSTR lpFileName; // [esp+30h] [ebp-1Ch] BYREF
  char *Destination; // [esp+34h] [ebp-18h] BYREF
  int v44; // [esp+38h] [ebp-14h]
  int v45; // [esp+3Ch] [ebp-10h]
  int v46; // [esp+40h] [ebp-Ch]

  sub_405060(lpMem, Str);
  lpMem[1] = (LPVOID)1;
  sub_40C58A(dword_4134D8);
  v28 = String2;
  v25 = String2;
  v21 = SubStr;
  v19 = String2;
  sub_40C54A((int)String2);
  sub_4055E0((char *)&v19[(_DWORD)::lpMem], v21, (int)v25);
  sub_40F040((LPVOID *)&v39, v28);
  v40 = sub_4024E7((char *)lpMem[0], v39);
  dword_413478 = v40;
  v41 = 0;
  do
  {
    if ( v40 < v41 )
      break;
    v29 = String2;
    sub_40F120(v1, *(char **)(8 * v41 + dword_413564));
    sub_40F040((LPVOID *)&lpFileName, v29);
    if ( dword_41345C == 1 || !sub_40CA00(1, lpFileName) )
    {
      if ( sub_40C930(1, lpFileName) )
      {
        v32 = String2;
        v26 = lpFileName;
        v22 = String2;
        sub_40F120(v5, (char *)dword_413560);
        sub_405860(v44 + 1i64, (int)String2);
        sub_4085CD(&v22[(_DWORD)::lpMem], v26);
        String2 = v32;
        dword_413478 = ++v44;
        nNumberOfBytesToWrite = *(_DWORD *)(8 * v41 + dword_413564 + 4);
        sub_40CAB0(1, (_BYTE *)(v45 + dword_413550), nNumberOfBytesToWrite);
        sub_40C710(1);
        v45 += nNumberOfBytesToWrite;
        sub_4097AD((int *)dwFlags);
        v33 = String2;
        sub_40F120(v6, (char *)lpFileName);
        v7 = dword_413570;
        sub_40F040((LPVOID *)(dword_413570 + 8), v33);
        *(_DWORD *)(v7 + 12) = sub_40DBB0(lpFileName);
      }
      else
      {
        v34 = String2;
        sub_405680(lpFileName, 1, (int)String2);
        String2 = v34;
        sub_40F0C0((char *)&v34[(_DWORD)::lpMem], asc_412023);
        if ( v2 )
        {
          v35 = String2;
          sub_40F120(v1, Destination);
          sub_40F120(v8, (char *)lpFileName);
          sub_40F120(v9, asc_412050);
          sub_40F040((LPVOID *)&Destination, v35);
        }
      }
    }
    else
    {
      sub_40C710(1);
      v30 = String2;
      sub_405680(lpFileName, 1, (int)String2);
      String2 = v30;
      sub_40F0C0((char *)&v30[(_DWORD)::lpMem], asc_412023);
      if ( v2 )
      {
        v31 = String2;
        sub_40F120(v1, Destination);
        sub_40F120(v3, (char *)lpFileName);
        sub_40F120(v4, asc_412050);
        sub_40F040((LPVOID *)&Destination, v31);
      }
    }
  }
  while ( !__OFADD__(1, v41++) );
  v36 = String2;
  v27 = String2;
  v23 = String2;
  v20 = String2;
  sub_405AD0(Destination, asc_412050, (int)String2);
  sub_405190(&v20[(_DWORD)::lpMem], (int)v23);
  v11 = sub_4052C0(&v27[(_DWORD)::lpMem]);
  String2 = v36;
  if ( v11 > 0 )
  {
    v37 = String2;
    v24 = String2;
    sub_40F120(v12, (char *)dword_413490);
    sub_40F120(v13, asc_412056);
    sub_40F120(v14, Destination);
    sub_40F120(v15, asc_412050);
    sub_40F120(v16, (char *)dword_41346C);
    ++String2;
    v17 = sub_4080D0(lpCaption, &v24[(_DWORD)::lpMem], 0x24u);
    String2 = v37;
    v46 = v17;
    if ( v17 == 7 )
    {
      sub_403D19();
      sub_40C53C(lpsz);
      RemoveDirectoryA(lpPathName);
      sub_40C53C(::lpFileName);
      RemoveDirectoryA(Source);
      JUMPOUT(0x4017AB);
    }
  }
  result = 1;
  sub_40F0F0(lpMem[0]);
  sub_40F0F0(Destination);
  sub_40F0F0((LPVOID)lpFileName);
  sub_40F0F0(v39);
  return result;
}
// 403376: control flows out of bounds to 4017AB
// 403061: variable 'v1' is possibly undefined
// 4030D2: variable 'v2' is possibly undefined
// 4030E7: variable 'v3' is possibly undefined
// 4030F1: variable 'v4' is possibly undefined
// 403131: variable 'v5' is possibly undefined
// 4031E3: variable 'v6' is possibly undefined
// 403253: variable 'v8' is possibly undefined
// 40325D: variable 'v9' is possibly undefined
// 4032E5: variable 'v12' is possibly undefined
// 4032EF: variable 'v13' is possibly undefined
// 4032F8: variable 'v14' is possibly undefined
// 403302: variable 'v15' is possibly undefined
// 40330D: variable 'v16' is possibly undefined
// 41345C: using guessed type int dword_41345C;
// 41346C: using guessed type int dword_41346C;
// 413478: using guessed type int dword_413478;
// 413490: using guessed type int dword_413490;
// 413550: using guessed type int dword_413550;
// 413560: using guessed type int dword_413560;
// 413564: using guessed type int dword_413564;
// 413570: using guessed type int dword_413570;

//----- (004033AF) --------------------------------------------------------
BOOL sub_4033AF()
{
  struct _SYSTEM_INFO SystemInfo; // [esp+0h] [ebp-28h] BYREF

  GetNativeSystemInfo(&SystemInfo);
  return SystemInfo.wProcessorArchitecture != 0;
}

//----- (004033E3) --------------------------------------------------------
HRSRC __stdcall sub_4033E3(HMODULE hModule, char *Str)
{
  char v2; // zf
  HRSRC result; // eax
  LPCSTR v6; // [esp+0h] [ebp-34h]
  LPCSTR v7; // [esp+4h] [ebp-30h]
  const CHAR *v8; // [esp+8h] [ebp-2Ch]
  LPVOID v9; // [esp+Ch] [ebp-28h] BYREF
  LPVOID lpMem; // [esp+10h] [ebp-24h]
  LPCSTR lpName; // [esp+14h] [ebp-20h] BYREF
  HRSRC hResInfo; // [esp+18h] [ebp-1Ch]
  int v13; // [esp+1Ch] [ebp-18h]
  int v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h]
  int v16; // [esp+28h] [ebp-Ch]
  LPCVOID v17; // [esp+2Ch] [ebp-8h]

  sub_405060(&v9, Str);
  lpMem = sub_40C1D0(33);
  sub_40C2F0(lpMem, 0x21u);
  sub_40C310(Src, lpMem, 0x20u);
  sub_40C340((_BYTE *)lpMem + 32, (char *)v9, 1);
  v8 = String2;
  v7 = String2;
  v6 = String2;
  sub_40D890((int)lpMem, 0x21u, (int)String2);
  sub_405AF0(&v6[(_DWORD)::lpMem], (int)v7);
  sub_40F040((LPVOID *)&lpName, v8);
  sub_40C2D0(lpMem);
  hResInfo = FindResourceA(hModule, lpName, (LPCSTR)0xA);
  if ( hResInfo )
  {
    lpBuffer = LoadResource(hModule, hResInfo);
    nNumberOfBytesToWrite = SizeofResource(hModule, hResInfo);
    sub_40F0C0((char *)v9, aB);
    if ( !v2
      || (sub_40F0C0((char *)v9, aI), !v2)
      || (sub_40F0C0((char *)v9, aN), !v2)
      || (sub_40F0C0((char *)v9, asc_412035), !v2) )
    {
      v13 = (int)sub_40C1D0(nNumberOfBytesToWrite);
      v14 = 0;
      do
      {
        if ( (int)(nNumberOfBytesToWrite - 1) < v14 )
          break;
        v15 = sub_40C1F0((char *)lpBuffer + v14);
        v16 = -v15;
        sub_40C200((_BYTE *)(v14 + v13), -(char)v15);
      }
      while ( !__OFADD__(1, v14++) );
      sub_402000((_BYTE *)v13, nNumberOfBytesToWrite, Src);
      lpBuffer = (LPCVOID)v13;
      v17 = sub_40419E(v13, nNumberOfBytesToWrite);
      lpBuffer = v17;
      nNumberOfBytesToWrite = sub_40C380(v17);
    }
  }
  result = hResInfo;
  sub_40F0F0((LPVOID)lpName);
  sub_40F0F0(v9);
  return result;
}
// 4034E2: variable 'v2' is possibly undefined

//----- (004035EE) --------------------------------------------------------
int sub_4035EE()
{
  int v0; // ecx
  int result; // eax
  LPCSTR v2; // [esp+0h] [ebp-20h]
  LPCSTR v3; // [esp+0h] [ebp-20h]
  LPCSTR v4; // [esp+0h] [ebp-20h]
  CHAR *v5; // [esp+4h] [ebp-1Ch]
  LPCSTR v6; // [esp+4h] [ebp-1Ch]
  LPCSTR v7; // [esp+4h] [ebp-1Ch]
  LPCSTR v8; // [esp+8h] [ebp-18h]
  LPCSTR v9; // [esp+8h] [ebp-18h]
  LPCSTR v10; // [esp+8h] [ebp-18h]
  LPCSTR v11; // [esp+8h] [ebp-18h]
  LPCSTR v12; // [esp+8h] [ebp-18h]
  const CHAR *v13; // [esp+Ch] [ebp-14h]
  const CHAR *v14; // [esp+Ch] [ebp-14h]
  const CHAR *v15; // [esp+Ch] [ebp-14h]
  const CHAR *v16; // [esp+Ch] [ebp-14h]
  const CHAR *v17; // [esp+Ch] [ebp-14h]
  const CHAR *v18; // [esp+Ch] [ebp-14h]
  const CHAR *v19; // [esp+Ch] [ebp-14h]
  const CHAR *v20; // [esp+Ch] [ebp-14h]
  const CHAR *v21; // [esp+Ch] [ebp-14h]
  const CHAR *v22; // [esp+Ch] [ebp-14h]
  CHAR *lpTempFileName; // [esp+10h] [ebp-10h]
  LPCSTR lpPathName; // [esp+14h] [ebp-Ch] BYREF
  LPSTR lpszShortPath; // [esp+18h] [ebp-8h] BYREF
  LPSTR pszPath; // [esp+1Ch] [ebp-4h] BYREF

  pszPath = 0;
  lpszShortPath = 0;
  lpPathName = 0;
  lpTempFileName = (CHAR *)sub_40C1D0(1024);
  v13 = String2;
  sub_40C4AD((int)String2);
  sub_40F040((LPVOID *)&lpPathName, v13);
  GetTempFileNameA(lpPathName, &WindowName, 0, lpTempFileName);
  v14 = String2;
  sub_40C280(lpTempFileName, (int)String2);
  sub_40F040((LPVOID *)&dword_413554, v14);
  v15 = String2;
  sub_405B50(2048, (int)String2);
  sub_40F040((LPVOID *)&lpszShortPath, v15);
  v16 = String2;
  v5 = lpszShortPath;
  v2 = String2;
  sub_408450((int)String2);
  ++String2;
  GetShortPathNameA(&v2[(_DWORD)lpMem], v5, 0x800u);
  String2 = v16;
  v17 = String2;
  v8 = String2;
  sub_408450((int)String2);
  ++String2;
  sub_4085CD((const CHAR *)dword_413480, &v8[(_DWORD)lpMem]);
  String2 = v17;
  v18 = String2;
  v9 = String2;
  v6 = String2;
  v3 = String2;
  sub_408450((int)String2);
  sub_40C6BA((char *)&v3[(_DWORD)lpMem], (int)v6);
  ++String2;
  sub_4085CD((const CHAR *)dword_4134C4, &v9[(_DWORD)lpMem]);
  String2 = v18;
  v19 = String2;
  v10 = String2;
  v7 = String2;
  v4 = String2;
  sub_408450((int)String2);
  sub_40C59C((char *)&v4[(_DWORD)lpMem], (int)v7);
  ++String2;
  sub_4085CD((const CHAR *)dword_41354C, &v10[(_DWORD)lpMem]);
  String2 = v19;
  v20 = String2;
  v11 = String2;
  sub_405190(lpszShortPath, (int)String2);
  ++String2;
  sub_4085CD((const CHAR *)dword_41348C, &v11[(_DWORD)lpMem]);
  String2 = v20;
  v21 = String2;
  sub_40F120(v0, dword_4134D8);
  sub_40F040((LPVOID *)&pszPath, v21);
  PathAddBackslashA(pszPath);
  sub_4085CD((const CHAR *)dword_413558, pszPath);
  v22 = String2;
  v12 = String2;
  sub_405860(dword_413478, (int)String2);
  ++String2;
  sub_4085CD((const CHAR *)dword_413518, &v12[(_DWORD)lpMem]);
  String2 = v22;
  sub_4085CD((const CHAR *)dword_4134C8, dword_413554);
  result = 0;
  sub_40F0F0(lpszShortPath);
  sub_40F0F0((LPVOID)lpPathName);
  sub_40F0F0(pszPath);
  return result;
}
// 4037D1: variable 'v0' is possibly undefined
// 413478: using guessed type int dword_413478;
// 413480: using guessed type int dword_413480;
// 41348C: using guessed type int dword_41348C;
// 4134C4: using guessed type int dword_4134C4;
// 4134C8: using guessed type int dword_4134C8;
// 413518: using guessed type int dword_413518;
// 41354C: using guessed type int dword_41354C;
// 413558: using guessed type int dword_413558;

//----- (0040386A) --------------------------------------------------------
int __stdcall sub_40386A(int a1, char *Str, _BYTE *a3, int a4, _BYTE *a5, int a6, int a7, int a8, int a9)
{
  _DWORD *v9; // ebp
  _DWORD *v10; // ebp
  _DWORD *v11; // ebp
  _DWORD *v12; // ebp
  LPVOID lpMem; // [esp+0h] [ebp-40h] BYREF
  _DWORD *v17; // [esp+4h] [ebp-3Ch] BYREF
  _DWORD *v18; // [esp+Ch] [ebp-34h] BYREF
  _DWORD *v19; // [esp+14h] [ebp-2Ch] BYREF
  _BYTE *v20; // [esp+1Ch] [ebp-24h]
  int v21; // [esp+20h] [ebp-20h]
  int v22; // [esp+24h] [ebp-1Ch]
  int v23; // [esp+28h] [ebp-18h]
  int v24; // [esp+2Ch] [ebp-14h]
  SIZE_T dwBytes; // [esp+30h] [ebp-10h]

  sub_405060(&lpMem, Str);
  sub_40ECAD(4, 4, 5, 0, (int *)&v17);
  sub_40ECAD(4, 4, 5, 0, (int *)&v18);
  sub_40ECAD(4, 4, 5, 0, (int *)&v19);
  v20 = sub_402000(a3, a7, (char *)lpMem);
  v20 = sub_402000(a5, a9, (char *)lpMem);
  v9 = v17;
  *v17 = a3;
  v9[1] = a4;
  v9[2] = a5;
  v10 = v18;
  *v18 = a7;
  v10[1] = a8;
  v10[2] = a9;
  if ( a6 )
  {
    v21 = sub_40C3A0(a6);
    v22 = sub_40C3A0(a6 + 4);
    v23 = sub_40C3A0(a6 + 8);
    v11 = v19;
    *v19 = v21;
    v11[1] = v22;
    v11[2] = v23;
    v24 = 0;
    do
    {
      if ( v24 > 2 )
        break;
      if ( v19[v24] > v18[v24] )
      {
        dwBytes = (SIZE_T)sub_40C1D0(v19[v24] + 512);
        if ( !dwBytes )
        {
          RemoveDirectoryA(lpPathName);
          sub_4080D0(lpCaption, dword_4134F0, 0x10u);
          JUMPOUT(0x4017AB);
        }
        v12 = v19;
        sub_40C3B0(dwBytes, v19[v24]);
        v18[v24] = v12[v24];
        v17[v24] = dwBytes;
      }
    }
    while ( !__OFADD__(1, v24++) );
  }
  dword_41352C = (void *)*v17;
  dword_413464 = *v18;
  dword_4134B0 = v18[1];
  dword_413468 = v18[2];
  if ( dword_4134B0 > 0 && dword_413468 > 0 )
  {
    dword_4134FC = (void *)v17[1];
    dword_413550 = v17[2];
  }
  sub_40F0F0(lpMem);
  sub_40EDD5((int)v17);
  sub_40EDD5((int)v18);
  sub_40EDD5((int)v19);
  return 1;
}
// 403A6E: control flows out of bounds to 4017AB
// 413550: using guessed type int dword_413550;

//----- (00403B17) --------------------------------------------------------
const CHAR *__cdecl sub_403B17(const CHAR *a1)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  const CHAR *result; // eax
  const CHAR *v11; // [esp-4h] [ebp-1Ch]
  const CHAR *v12; // [esp-4h] [ebp-1Ch]
  const CHAR *v13; // [esp-4h] [ebp-1Ch]
  const CHAR *v14; // [esp-4h] [ebp-1Ch]
  const CHAR *v15; // [esp-4h] [ebp-1Ch]
  const CHAR *v16; // [esp-4h] [ebp-1Ch]
  LPCSTR v17; // [esp-4h] [ebp-1Ch]
  LPSTR lpBuffer; // [esp+0h] [ebp-18h] BYREF
  LPCSTR lpFileName; // [esp+4h] [ebp-14h] BYREF
  LPVOID lpMem; // [esp+8h] [ebp-10h] BYREF
  int v21; // [esp+Ch] [ebp-Ch]
  int v22; // [esp+10h] [ebp-8h]

  v22 = 0;
  v21 = 0;
  lpMem = 0;
  lpFileName = 0;
  lpBuffer = 0;
  String2 = a1;
  if ( sub_4033AF() && sub_40A60F() != 65 )
  {
    v11 = String2;
    sub_405B50(2048, (int)String2);
    sub_40F040((LPVOID *)&lpBuffer, v11);
    GetWindowsDirectoryA(lpBuffer, 0x800u);
    PathAddBackslashA(lpBuffer);
    v12 = String2;
    sub_40F120(v2, lpBuffer);
    sub_40F120(v3, aSysnative);
    sub_40F040((LPVOID *)&lpBuffer, v12);
    PathAddBackslashA(lpBuffer);
    v13 = String2;
    sub_40F120(v4, lpBuffer);
    sub_40F120(v5, (char *)dword_4134C0);
    sub_40F040((LPVOID *)&lpFileName, v13);
    v14 = String2;
    sub_40F120(v6, lpBuffer);
    sub_40F120(v7, (char *)dword_4134C0);
    sub_40F120(v8, (char *)dword_4134DC);
    sub_40F040(&lpMem, v14);
    if ( sub_40CA00(0, lpFileName) )
    {
      v21 = 1;
      sub_40C710(0);
    }
    else
    {
      v21 = 0;
    }
    if ( sub_40CA00(0, (LPCSTR)lpMem) )
    {
      v22 = 1;
      sub_40C710(0);
    }
    else
    {
      v22 = 0;
    }
    if ( !(v22 + v21) )
    {
      v15 = String2;
      sub_405B50(2048, (int)String2);
      sub_40F040((LPVOID *)&lpBuffer, v15);
      GetSystemDirectoryA(lpBuffer, 0x800u);
      PathAddBackslashA(lpBuffer);
    }
  }
  else
  {
    v16 = String2;
    sub_405B50(2048, (int)String2);
    sub_40F040((LPVOID *)&lpBuffer, v16);
    GetSystemDirectoryA(lpBuffer, 0x800u);
    PathAddBackslashA(lpBuffer);
  }
  v17 = String2;
  sub_40F120(v9, lpBuffer);
  result = &v17[(_DWORD)::lpMem];
  sub_40F0F0(lpMem);
  sub_40F0F0(lpBuffer);
  sub_40F0F0((LPVOID)lpFileName);
  return result;
}
// 403B8D: variable 'v2' is possibly undefined
// 403B97: variable 'v3' is possibly undefined
// 403BB7: variable 'v4' is possibly undefined
// 403BC2: variable 'v5' is possibly undefined
// 403BDA: variable 'v6' is possibly undefined
// 403BE5: variable 'v7' is possibly undefined
// 403BF0: variable 'v8' is possibly undefined
// 403CDE: variable 'v9' is possibly undefined
// 4134C0: using guessed type int dword_4134C0;

//----- (00403D19) --------------------------------------------------------
int sub_403D19()
{
  int v0; // ebp

  if ( dword_41350C == 1 )
  {
    if ( sub_40984B(dwFlags) > 0 )
    {
      sub_409855(dwFlags);
      while ( sub_40986A((int *)dwFlags) )
      {
        v0 = dword_413570;
        if ( sub_40DBB0(*(LPCSTR *)(dword_413570 + 8)) == *(_DWORD *)(v0 + 12) )
          sub_40C53C(*(LPCSTR *)(dword_413570 + 8));
      }
    }
    if ( sub_40984B(dword_413574) > 0 )
    {
      sub_407A00((_DWORD *)dword_413574, 1, 0, 5);
      sub_409855(dword_413574);
      while ( sub_40986A((int *)dword_413574) )
        RemoveDirectoryA(*(LPCSTR *)(dword_413578 + 12));
    }
  }
  return 1;
}
// 41350C: using guessed type int dword_41350C;
// 413570: using guessed type int dword_413570;
// 413578: using guessed type int dword_413578;

//----- (00403DE5) --------------------------------------------------------
int sub_403DE5()
{
  const char *CommandLineA; // eax
  const char *ArgsA; // eax
  char v2; // al
  int result; // eax
  LPCSTR v5; // [esp-4h] [ebp-34h]
  LPCSTR v6; // [esp+0h] [ebp-30h]
  const CHAR *v7; // [esp+4h] [ebp-2Ch]
  LPCSTR v8; // [esp+8h] [ebp-28h]
  LPCSTR v9; // [esp+Ch] [ebp-24h]
  LPCSTR v10; // [esp+Ch] [ebp-24h]
  const CHAR *v11; // [esp+10h] [ebp-20h]
  const CHAR *v12; // [esp+10h] [ebp-20h]
  const CHAR *v13; // [esp+10h] [ebp-20h]
  LPVOID lpMem; // [esp+14h] [ebp-1Ch] BYREF
  SIZE_T dwBytes; // [esp+18h] [ebp-18h]
  _BYTE *v16; // [esp+1Ch] [ebp-14h]
  void *Src; // [esp+20h] [ebp-10h]
  int v18; // [esp+24h] [ebp-Ch]

  v18 = 0;
  Src = 0;
  v16 = 0;
  dwBytes = 0;
  lpMem = 0;
  if ( !sub_40C930(1, lpsz) )
  {
    sub_40C53C(lpsz);
    sub_403D19();
    sub_4080D0(lpCaption, dword_4134EC, 0x10u);
    RemoveDirectoryA(lpPathName);
    JUMPOUT(0x4017AB);
  }
  sub_40CB90(1, (char *)dword_4134F8);
  v11 = String2;
  v9 = String2;
  v8 = String2;
  v7 = String2;
  v6 = String2;
  v5 = String2;
  CommandLineA = GetCommandLineA();
  sub_40C280(CommandLineA, (int)v5);
  ++String2;
  ArgsA = PathGetArgsA(&v6[(_DWORD)::lpMem]);
  String2 = v7;
  sub_40C280(ArgsA, (int)v8);
  ++String2;
  sub_4085CD((const CHAR *)dword_413528, &v9[(_DWORD)::lpMem]);
  String2 = v11;
  sub_40CB90(1, (char *)dword_4134E0);
  if ( dword_413470 == 1 )
  {
    v12 = String2;
    sub_40C210(aA, &aA[173] - aA, (int)String2);
    sub_40F040(&lpMem, v12);
    dwBytes = sub_4052C0((const char *)lpMem);
    v16 = sub_40C1D0(dwBytes);
    Src = sub_40C1D0(dwBytes);
    sub_40C3F0(v16, (char *)lpMem);
    v18 = 0;
    do
    {
      if ( (int)dwBytes < v18 )
        break;
      v2 = sub_40C1F0(&v16[v18]);
      sub_40C200((_BYTE *)Src + v18, -v2);
    }
    while ( !__OFADD__(1, v18++) );
    v13 = String2;
    v10 = String2;
    sub_40C280((const char *)Src, (int)String2);
    ++String2;
    sub_40CB90(1, (char *)&v10[(_DWORD)::lpMem]);
    String2 = v13;
  }
  sub_40C710(1);
  result = 0;
  sub_40F0F0(lpMem);
  return result;
}
// 403FC0: control flows out of bounds to 4017AB
// 413470: using guessed type int dword_413470;
// 413528: using guessed type int dword_413528;

//----- (00403FD5) --------------------------------------------------------
int sub_403FD5()
{
  int result; // eax
  const CHAR *v1; // [esp-4h] [ebp-18h]
  const CHAR *v2; // [esp-4h] [ebp-18h]
  const CHAR *v3; // [esp-4h] [ebp-18h]
  const CHAR *v4; // [esp-4h] [ebp-18h]
  _BYTE *v5; // [esp+0h] [ebp-14h]
  LPCVOID v6; // [esp+4h] [ebp-10h]
  _BYTE *v7; // [esp+8h] [ebp-Ch]
  LPVOID lpMem; // [esp+Ch] [ebp-8h] BYREF
  int v9; // [esp+10h] [ebp-4h]

  v9 = 0;
  lpMem = 0;
  v7 = 0;
  v6 = 0;
  if ( !sub_4033E3(hModule, aN) )
    sub_404566(0, 0, 0, lpMem, v9);
  v1 = String2;
  sub_40C210((const char *)lpBuffer, nNumberOfBytesToWrite, (int)String2);
  sub_40F040((LPVOID *)&lpsz, v1);
  if ( !sub_4033E3(hModule, aB) )
    sub_404566(0, 0, 0, lpMem, v9);
  v5 = lpBuffer;
  dword_413464 = nNumberOfBytesToWrite;
  dword_41352C = (void *)lpBuffer;
  if ( sub_4033E3(hModule, aI) )
  {
    v6 = lpBuffer;
    dword_4134B0 = nNumberOfBytesToWrite;
    dword_4134FC = (void *)lpBuffer;
  }
  if ( sub_4033E3(hModule, asc_412029) )
  {
    v7 = lpBuffer;
    dword_413468 = nNumberOfBytesToWrite;
    dword_413550 = (int)lpBuffer;
  }
  if ( sub_4033E3(hModule, aP) )
  {
    sub_402274(String2);
    sub_40F040(&lpMem, v2);
    if ( sub_4033E3(hModule, aS) )
      v9 = (int)lpBuffer;
    sub_40386A((int)hModule, (char *)lpMem, v5, (int)v6, v7, v9, dword_413464, dword_4134B0, dword_413468);
  }
  v3 = String2;
  sub_40C210((const char *)dword_41352C, dword_413464, (int)String2);
  sub_40F040((LPVOID *)&dword_4134E0, v3);
  v4 = String2;
  sub_40C210((const char *)dword_4134FC, dword_4134B0, (int)String2);
  sub_40F040((LPVOID *)&dword_413484, v4);
  result = 0;
  sub_40F0F0(lpMem);
  return result;
}
// 4040E8: variable 'v2' is possibly undefined
// 404566: using guessed type void __cdecl __noreturn sub_404566(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413550: using guessed type int dword_413550;

//----- (0040419E) --------------------------------------------------------
LPVOID __stdcall sub_40419E(int a1, int a2)
{
  signed int dwBytes; // [esp+0h] [ebp-Ch]
  LPVOID v4; // [esp+4h] [ebp-8h]

  dwBytes = sub_40C3A0(a1);
  if ( dwBytes > 1 )
  {
    v4 = sub_40C1D0(dwBytes);
    sub_409441(a1 + 4, a2 - 4, (int)v4, dwBytes, 1651666042);
  }
  else
  {
    v4 = sub_40C1D0(a2 - 4);
    sub_40C310((void *)(a1 + 4), v4, a2 - 4);
  }
  return v4;
}

//----- (00404225) --------------------------------------------------------
void __noreturn sub_404225()
{
  char v0; // zf
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  DWORD v16; // eax
  LPCSTR v17; // [esp+0h] [ebp-2Ch]
  LPCSTR v18; // [esp+4h] [ebp-28h]
  LPCSTR v19; // [esp+4h] [ebp-28h]
  char *v20; // [esp+8h] [ebp-24h]
  LPCSTR v21; // [esp+8h] [ebp-24h]
  CHAR *v22; // [esp+Ch] [ebp-20h]
  LPCSTR v23; // [esp+Ch] [ebp-20h]
  LPCSTR v24; // [esp+Ch] [ebp-20h]
  const CHAR *v25; // [esp+10h] [ebp-1Ch]
  const CHAR *v26; // [esp+10h] [ebp-1Ch]
  const CHAR *v27; // [esp+10h] [ebp-1Ch]
  const CHAR *v28; // [esp+10h] [ebp-1Ch]
  const CHAR *v29; // [esp+10h] [ebp-1Ch]
  const CHAR *v30; // [esp+10h] [ebp-1Ch]
  const CHAR *v31; // [esp+10h] [ebp-1Ch]
  const CHAR *v32; // [esp+10h] [ebp-1Ch]
  const CHAR *v33; // [esp+10h] [ebp-1Ch]
  const CHAR *v34; // [esp+10h] [ebp-1Ch]
  LPSTR v35; // [esp+14h] [ebp-18h]
  LPSTR lpsz; // [esp+18h] [ebp-14h] BYREF
  LPSTR lpTempFileName; // [esp+1Ch] [ebp-10h] BYREF
  char *v38; // [esp+20h] [ebp-Ch] BYREF
  DWORD v39; // [esp+24h] [ebp-8h]

  v39 = 0;
  v38 = 0;
  lpTempFileName = 0;
  lpsz = 0;
  v35 = sub_4085BA();
  hModule = GetModuleHandleA(0);
  sub_402859((int)v35, String2);
  sub_40F040((LPVOID *)&lpsz, v25);
  sub_404530();
  sub_403FD5();
  v26 = String2;
  sub_40856C(0, (int)String2);
  String2 = v26;
  sub_40F0C0((char *)&v26[(_DWORD)lpMem], (char *)dword_4134E8);
  if ( !v0 && v35 == (LPSTR)1 )
    sub_402C54();
  sub_402AE6();
  v27 = String2;
  sub_40F120(v2, (char *)lpPathName);
  sub_40F120(v3, SubStr);
  sub_40F120(v4, ::lpsz);
  sub_40F040((LPVOID *)&::lpsz, v27);
  v28 = String2;
  sub_405B50(2048, (int)String2);
  sub_40F040((LPVOID *)&lpTempFileName, v28);
  v29 = String2;
  v22 = lpTempFileName;
  v17 = String2;
  sub_40F120(v5, (char *)lpPathName);
  sub_40F120(v6, SubStr);
  ++String2;
  GetTempFileNameA(&v17[(_DWORD)lpMem], &WindowName, 0, v22);
  String2 = v29;
  sub_40C53C(lpTempFileName);
  PathRenameExtensionA(lpTempFileName, pszExt);
  v30 = String2;
  sub_40F120(v7, lpTempFileName);
  sub_40F040((LPVOID *)&::lpsz, v30);
  sub_403DE5();
  sub_40F0C0(0, dword_413484);
  if ( v0 )
    sub_402FAA(dword_413484);
  sub_4035EE();
  sub_403B17(String2);
  sub_40F040((LPVOID *)&v38, v31);
  PathQuoteSpacesA(::lpsz);
  v32 = String2;
  sub_40F120(v8, ::lpsz);
  sub_40F120(v9, asc_41201F);
  sub_40F120(v10, lpsz);
  sub_40F040((LPVOID *)&lpsz, v32);
  PathQuoteSpacesA(lpsz);
  v33 = String2;
  v23 = String2;
  sub_40F120(v11, (char *)dword_413534);
  sub_40F120(v12, asc_41201F);
  sub_40F120(v13, lpsz);
  ++String2;
  v20 = dword_4134D8;
  v18 = String2;
  sub_40F120(v14, v38);
  sub_40F120(v15, (char *)dword_4134C0);
  v16 = sub_402A04((char *)&v18[(_DWORD)lpMem], v20, (char *)&v23[(_DWORD)lpMem]);
  String2 = v33;
  v39 = v16;
  sub_403D19();
  PathUnquoteSpacesA(::lpsz);
  sub_40C53C(::lpsz);
  sub_40C53C(dword_413554);
  sub_40C53C(lpFileName);
  v34 = String2;
  v24 = String2;
  v21 = String2;
  v19 = String2;
  sub_408450((int)String2);
  sub_40C59C((char *)&v19[(_DWORD)lpMem], (int)v21);
  sub_40C58A(&v24[(_DWORD)lpMem]);
  String2 = v34;
  RemoveDirectoryA(Source);
  RemoveDirectoryA(lpPathName);
  JUMPOUT(0x4017AB);
}
// 404509: control flows out of bounds to 4017AB
// 404258: variable 'v25' is possibly undefined
// 40429B: variable 'v0' is possibly undefined
// 4042C8: variable 'v2' is possibly undefined
// 4042D3: variable 'v3' is possibly undefined
// 4042DE: variable 'v4' is possibly undefined
// 40432F: variable 'v5' is possibly undefined
// 40433A: variable 'v6' is possibly undefined
// 40437B: variable 'v7' is possibly undefined
// 4043C0: variable 'v31' is possibly undefined
// 4043DC: variable 'v8' is possibly undefined
// 4043E6: variable 'v9' is possibly undefined
// 4043EF: variable 'v10' is possibly undefined
// 404419: variable 'v11' is possibly undefined
// 404423: variable 'v12' is possibly undefined
// 40442C: variable 'v13' is possibly undefined
// 404447: variable 'v14' is possibly undefined
// 404452: variable 'v15' is possibly undefined
// 402C54: using guessed type void __noreturn sub_402C54(void);
// 404225: using guessed type void __noreturn sub_404225();
// 404530: using guessed type int sub_404530(void);
// 4134C0: using guessed type int dword_4134C0;
// 4134E8: using guessed type int dword_4134E8;
// 413534: using guessed type int dword_413534;

//----- (00404530) --------------------------------------------------------
#error "40455B: call analysis failed (funcsize=17)"

//----- (00404566) --------------------------------------------------------
void __noreturn sub_404566()
{
  sub_4080D0(lpCaption, dword_4134EC, 0x10u);
  JUMPOUT(0x4017AB);
}
// 404581: control flows out of bounds to 4017AB
// 404566: using guessed type void __noreturn sub_404566();

//----- (00405000) --------------------------------------------------------
int sub_405000()
{
  unsigned int v0; // kr00_4
  int v1; // ebp
  unsigned int v2; // kr04_4

  v0 = __readeflags();
  v1 = 0;
  __writeeflags(v0 ^ 0x200000);
  v2 = __readeflags();
  if ( v0 != v2 )
  {
    _EAX = 1;
    __asm { cpuid }
    if ( (_EDX & 0x800000) != 0 )
    {
      v1 = 2;
      if ( (_EDX & 0x2000000) != 0 )
      {
        v1 = 10;
        if ( (_EDX & 0x4000000) != 0 )
          v1 = 26;
      }
      _EAX = -2147483647;
      __asm { cpuid }
      if ( _EDX < 0 )
        return v1 | 4;
    }
  }
  return v1;
}

//----- (00405060) --------------------------------------------------------
void __fastcall sub_405060(LPVOID *a1, char *Str)
{
  sub_40F180(a1, Str);
}

//----- (00405068) --------------------------------------------------------
int __fastcall sub_405068(LPVOID *a1, char *Str)
{
  return sub_40F1D0(a1, Str);
}

//----- (004050D0) --------------------------------------------------------
char *__stdcall sub_4050D0(const char *a1, char *a2, int a3)
{
  int v3; // ebx
  const char *v4; // esi
  int v5; // ebp
  unsigned int v6; // edi
  int v7; // ecx
  int v8; // esi
  const char *v9; // eax
  int v10; // ecx
  int v11; // ebx
  char *result; // eax
  char *v13; // esi

  v3 = 32;
  if ( a2 )
    v3 = *a2;
  v4 = a1;
  v5 = sub_4052C0(a1);
  if ( a1 )
  {
    v6 = (unsigned int)a1;
    if ( *a1 == v3 )
    {
      do
        v7 = *++v4;
      while ( v7 == v3 );
    }
    v8 = v4 - a1;
    a2 = (char *)v8;
    if ( v8 >= v5 )
    {
      v5 -= v8;
    }
    else
    {
      v9 = &a1[v5 - 1];
      if ( *v9 == v3 )
      {
        do
          v10 = *--v9;
        while ( v10 == v3 );
      }
      v5 = -(v8 + a1 - v9 - 1);
    }
  }
  else
  {
    v6 = 0;
  }
  v11 = sub_40F280(v6);
  result = sub_40F2C0(v5, a3);
  v13 = result;
  if ( v11 )
  {
    result = sub_40F340(v11);
    v6 = (unsigned int)result;
  }
  if ( v6 )
    return sub_40F360(v13, &a2[v6], v5);
  *v13 = 0;
  return result;
}

//----- (00405190) --------------------------------------------------------
char *__stdcall sub_405190(const char *a1, int a2)
{
  return sub_4050D0(a1, " ", a2);
}

//----- (004051B0) --------------------------------------------------------
CHAR *__stdcall sub_4051B0(char *Str1, int a2, char *Str2, const CHAR *a4)
{
  int v4; // ebp
  char *v5; // esi
  char *v6; // ebx
  size_t v7; // edi
  char v8; // al
  int v9; // edi
  char *v10; // eax
  size_t v11; // ebx
  CHAR *result; // eax
  CHAR *v13; // esi
  size_t Size; // [esp+4h] [ebp-4h]
  char *Str1a; // [esp+Ch] [ebp+4h]

  v4 = 0;
  Size = 0;
  if ( a2 < 1 )
    return (CHAR *)sub_40F3C0(a4);
  v5 = Str1;
  if ( !Str1 )
    v5 = (char *)&unk_411002;
  v6 = Str2;
  if ( !Str2 )
    v6 = (char *)&unk_411002;
  Str1a = v5;
  if ( !*v6 || !v6[1] )
  {
    while ( 1 )
    {
      v8 = *v5;
      if ( *v5 == *v6 || !v8 )
      {
        if ( ++v4 == a2 )
          goto LABEL_21;
        if ( !v8 )
          goto LABEL_22;
        Str1a = v5 + 1;
      }
      ++v5;
    }
  }
  v7 = strlen(v6);
  while ( 1 )
  {
    while ( strncmp(v5, v6, v7) && *v5 )
      ++v5;
    if ( ++v4 == a2 )
      break;
    if ( !*v5 )
      goto LABEL_22;
    v5 += v7;
    Str1a = v5;
  }
LABEL_21:
  Size = v5 - Str1a;
LABEL_22:
  v9 = sub_40F280((unsigned int)v5);
  if ( v9 )
  {
    v10 = sub_40F3B0((int)a4);
    v11 = Size;
    memmove(v10, Str1a, Size);
  }
  else
  {
    v11 = Size;
  }
  result = sub_40F2C0(v11, (int)a4);
  v13 = result;
  if ( !v9 )
    result = strncpy(result, Str1a, v11);
  v13[v11] = 0;
  return result;
}

//----- (004052C0) --------------------------------------------------------
unsigned int __stdcall sub_4052C0(const char *a1)
{
  if ( a1 )
    return strlen(a1);
  else
    return 0;
}

//----- (004052F0) --------------------------------------------------------
__int64 __stdcall sub_4052F0(char *a1)
{
  char *v1; // esi
  __int64 result; // rax
  int v3; // edi
  char v4; // cl
  char v5; // cl
  __int64 v6; // kr00_8
  char v7; // cl
  _BYTE *i; // esi
  unsigned __int64 v9; // rax
  unsigned int v10; // ebx
  int v11; // ebx
  unsigned int v12; // ebp
  int v13; // eax

  v1 = a1;
  result = 0i64;
  if ( !a1 )
    return result;
  while ( *v1 == 32 || *v1 == 9 )
    ++v1;
  if ( *v1 == 45 )
  {
    v3 = 1;
LABEL_8:
    ++v1;
    goto LABEL_9;
  }
  v3 = 0;
  if ( *v1 == 43 )
    goto LABEL_8;
LABEL_9:
  v4 = *v1;
  if ( *v1 == 36 )
  {
    while ( 1 )
    {
      v5 = *++v1;
      if ( (v5 < 48 || v5 > 57) && (v5 < 65 || v5 > 70) && (v5 < 97 || v5 > 102) )
        break;
      if ( v5 > 57 )
      {
        v6 = 16 * result;
        if ( v5 < 97 )
          result = v6 + v5 - 55;
        else
          result = v6 + v5 - 87;
      }
      else
      {
        result = 16 * (result - 3) + v5;
      }
    }
  }
  else if ( v4 == 37 )
  {
    v7 = v1[1];
    for ( i = v1 + 1; v7 >= 48; ++i )
    {
      if ( v7 > 49 )
        break;
      v9 = result - 24;
      HIDWORD(v9) = v9 >> 31;
      v10 = 2 * v9;
      LODWORD(v9) = v7;
      v7 = i[1];
      result = __PAIR64__(HIDWORD(v9), v10) + (int)v9;
    }
  }
  else
  {
    for ( ; v4 >= 48; ++v1 )
    {
      if ( v4 > 57 )
        break;
      v11 = 5 * result;
      v12 = (unsigned __int64)(10 * result) >> 32;
      v13 = v4;
      v4 = v1[1];
      result = __PAIR64__(v12, 2 * v11) + v13 - 48;
    }
  }
  if ( v3 )
    return -result;
  return result;
}
// 40535D: conditional instruction was optimized away because cl.1 is in (30..39|41..46|61..66)

//----- (00405440) --------------------------------------------------------
int __stdcall sub_405440(_BYTE *a1, char *SubStr)
{
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  char *v5; // eax

  v2 = 1;
  v3 = a1;
  if ( !a1 || !SubStr || !*a1 || !*SubStr )
    return 0;
  do
    ++v3;
  while ( *v3 );
  v4 = v3 - a1;
  if ( v4 < 1 )
    v2 = v4 + 1;
  v5 = strstr(&a1[v2 - 1], SubStr);
  if ( v5 )
    return v5 - a1 + 1;
  else
    return 0;
}

//----- (004054A0) --------------------------------------------------------
int __stdcall sub_4054A0(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // ecx
  int v3; // ebx
  char v4; // dl
  char v5; // dl
  _BYTE *v6; // esi
  _BYTE *v7; // edi
  int v9; // [esp+0h] [ebp-4h]

  v2 = a1;
  v3 = 0;
  v9 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( *a2 )
      {
        v4 = *a1;
        if ( *a1 )
        {
          do
          {
            ++v2;
            if ( v4 == *a2 )
            {
              v5 = *v2;
              v6 = a2 + 1;
              v7 = v2;
              if ( *v2 )
              {
                while ( *v6 )
                {
                  if ( v5 == *v6 )
                  {
                    v5 = *++v2;
                    ++v6;
                    if ( v5 )
                      continue;
                  }
                  v3 = v9;
                  goto LABEL_11;
                }
                v3 = v9;
LABEL_16:
                v9 = ++v3;
                goto LABEL_13;
              }
LABEL_11:
              if ( !*v6 )
                goto LABEL_16;
              v2 = v7;
            }
LABEL_13:
            v4 = *v2;
          }
          while ( *v2 );
        }
      }
    }
  }
  return v3;
}

//----- (00405520) --------------------------------------------------------
const CHAR *__stdcall sub_405520(unsigned int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  char *v5; // edi
  int v6; // ebp
  char *v7; // esi
  int v8; // eax
  char v9; // al
  int v10; // edi
  const CHAR *result; // eax

  v4 = a3;
  if ( a3 < 0 )
    v4 = 0;
  v5 = (char *)a1;
  v6 = sub_40F280(a1);
  v7 = sub_40F2C0(v4, a4);
  if ( v6 )
    v5 = sub_40F340(v6);
  if ( v5 )
  {
    v8 = a2;
    if ( a2 <= 1 )
    {
LABEL_9:
      v9 = *v5;
      if ( *v5 )
      {
        v10 = v5 - v7;
        do
        {
          if ( !v4 )
            break;
          *v7 = v9;
          v9 = (v7++)[v10 + 1];
          --v4;
        }
        while ( v9 );
      }
    }
    else
    {
      while ( *v5 )
      {
        --v8;
        ++v5;
        if ( v8 <= 1 )
          goto LABEL_9;
      }
    }
  }
  result = sub_40F3E0(v4);
  *v7 = 0;
  return result;
}

//----- (004055A0) --------------------------------------------------------
const CHAR *__stdcall sub_4055A0(const char *a1, int a2, const CHAR *a3)
{
  if ( a1 )
    return sub_405520((unsigned int)a1, a2, strlen(a1) - a2 + 1, (int)a3);
  else
    return sub_40F3C0(a3);
}

//----- (004055E0) --------------------------------------------------------
char *__stdcall sub_4055E0(char *a1, char *a2, int a3)
{
  int v3; // ebx
  char *v4; // edi
  int v5; // ebp
  char v6; // cl
  int v7; // edx
  char *v8; // esi
  char *v9; // eax
  char *result; // eax
  char *v11; // esi
  int v12; // [esp+14h] [ebp+8h]

  v3 = 0;
  if ( a2 )
    v12 = *a2;
  else
    v12 = 32;
  v4 = a1;
  v5 = sub_40F280((unsigned int)a1);
  if ( a1 )
  {
    v6 = *a1;
    v7 = 0;
    v8 = a1;
    v9 = a1;
    if ( *a1 )
    {
      do
      {
        if ( v6 == v12 )
        {
          if ( !v7 )
          {
            v8 = v9;
            v7 = 1;
          }
        }
        else
        {
          v7 = 0;
        }
        v6 = *++v9;
        ++v3;
      }
      while ( v6 );
      if ( v7 )
        v3 += v8 - v9;
    }
  }
  result = sub_40F2C0(v3, a3);
  v11 = result;
  if ( v5 )
  {
    result = sub_40F340(v5);
    v4 = result;
  }
  if ( v3 )
    return sub_40F360(v11, v4, v3);
  *v11 = 0;
  return result;
}

//----- (00405680) --------------------------------------------------------
char *__stdcall sub_405680(const char *a1, int a2, int a3)
{
  char *v3; // ebx
  signed int v4; // esi
  signed int v5; // eax
  int v6; // edi
  int v7; // ebp
  char *result; // eax
  char *v9; // [esp+10h] [ebp+4h]

  v3 = (char *)a1;
  v4 = sub_4052C0(a1);
  v5 = a2;
  v6 = v4;
  if ( a2 < 0 )
    v5 = 0;
  if ( v4 > v5 )
    v6 = v5;
  v7 = sub_40F280((unsigned int)a1);
  result = sub_40F2C0(v6, a3);
  v9 = result;
  if ( v7 )
  {
    v3 = sub_40F340(v7);
    result = v9;
  }
  if ( v3 )
    return sub_40F360(result, &v3[v4 - v6], v6);
  *result = 0;
  return result;
}

//----- (004056F0) --------------------------------------------------------
_BYTE *__cdecl sub_4056F0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  _BYTE *v5; // ebp
  char *v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // edx
  char v9; // dl
  _BYTE *result; // eax
  char v11[32]; // [esp+10h] [ebp-20h] BYREF

  v5 = a1;
  v6 = v11;
  do
  {
    v7 = sub_40F400(__PAIR64__(a3, a2), 10i64);
    *v6++ = a2 - 10 * v7 + 48;
    a2 = v7;
    a3 = v8;
  }
  while ( __PAIR64__(v8, a2) );
  do
  {
    v9 = *--v6;
    *v5++ = v9;
  }
  while ( v6 != v11 );
  result = a1;
  *v5 = 0;
  return result;
}
// 405733: variable 'v8' is possibly undefined

//----- (004057A0) --------------------------------------------------------
const CHAR *__usercall sub_4057A0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  char *v3; // eax
  char *v4; // edi
  int v5; // esi
  char v6; // cl
  const CHAR *result; // eax
  char v8[16]; // [esp+Ch] [ebp-10h]

  v3 = sub_40F2C0(32, a1);
  v4 = v3;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      *v3 = 45;
      v4 = v3 + 1;
      if ( a2 == 0x80000000 )
      {
        strcpy(v4, "2147483648");
        v4 = v3 + 11;
        a2 = 0;
      }
      else
      {
        a2 = -a2;
      }
    }
    v5 = 0;
    if ( a2 )
    {
      do
      {
        v6 = a2;
        a2 /= 10;
        v8[++v5] = v6 - 10 * a2 + 48;
      }
      while ( a2 );
      for ( ; v5 > 0; ++v4 )
        *v4 = v8[v5--];
    }
  }
  else
  {
    *v3 = 48;
    v4 = v3 + 1;
  }
  result = sub_40F3E0(v3 - v4 + 32);
  *v4 = 0;
  return result;
}
// 4057A0: using guessed type char var_10[16];

//----- (00405860) --------------------------------------------------------
const CHAR *__stdcall sub_405860(__int64 a1, int a2)
{
  __int64 v2; // rdi
  char *v4; // eax
  const char *v5; // ebx

  v2 = a1;
  if ( !((unsigned __int64)(a1 + 0x80000000i64) >> 32) )
    return sub_4057A0(a2, a1);
  v4 = sub_40F2C0(64, a2);
  v5 = v4;
  if ( a1 < 0 )
  {
    *v4++ = 45;
    v2 = -a1;
  }
  sub_4056F0(v4, v2, HIDWORD(v2));
  return sub_40F3E0(64 - strlen(v5));
}

//----- (004058F0) --------------------------------------------------------
const CHAR *__stdcall sub_4058F0(char *Destination, char *a2, char a3, int a4, int a5, int a6)
{
  char *v6; // esi
  char *v7; // ebp
  int v8; // edi
  char *v9; // ebx
  char *v10; // edi
  unsigned int v11; // edi
  char *v12; // ebx
  const CHAR *result; // eax
  int v15; // [esp+10h] [ebp-14h]
  char *v16; // [esp+14h] [ebp-10h]
  char *v17; // [esp+1Ch] [ebp-8h]
  char *lpMem; // [esp+20h] [ebp-4h]
  char *Destinationa; // [esp+28h] [ebp+4h]
  int v20; // [esp+2Ch] [ebp+8h]
  int (__cdecl *v21)(const char *, const char *, size_t); // [esp+3Ch] [ebp+18h]

  v6 = Destination;
  if ( Destination )
    v15 = strlen(Destination);
  else
    v15 = 0;
  v7 = a2;
  v8 = sub_40F280((unsigned int)Destination);
  v20 = sub_40F280((unsigned int)a2);
  v9 = sub_40F2C0(v15, a6);
  Destinationa = v9;
  if ( v8 )
    v6 = sub_40F340(v8);
  if ( v20 )
    v7 = sub_40F340(v20);
  v10 = v9;
  v16 = v9;
  if ( v6 && *v6 )
  {
    if ( v7 && *v7 )
    {
      v17 = v6;
      v11 = strlen(v7);
      if ( v20 )
      {
        v12 = (char *)HeapAlloc(hHeap, 0, v11 + 1);
        lpMem = strcpy(v12, v7);
        v7 = v12;
      }
      v21 = strnicmp;
      if ( (a3 & 1) == 0 )
        v21 = strncmp;
      if ( a4 > 1 )
      {
        strncpy(Destinationa, v6, a4 - 1);
        Destinationa = &Destinationa[a4 - 1];
        v6 = &v6[a4 - 1];
      }
      while ( *v6 )
      {
        if ( v21(v6, v7, v11) )
        {
          *Destinationa++ = *v6++;
        }
        else
        {
          v6 += v11;
          if ( a5 != -1 && --a5 <= 0 )
          {
            strncpy(Destinationa, v6, v17 - v6 + v15);
            Destinationa += v15 + v17 - v6;
            break;
          }
        }
      }
      if ( v20 )
        HeapFree(hHeap, 0, lpMem);
      v10 = v16;
      v9 = Destinationa;
    }
    else
    {
      strcpy(v9, v6);
      v9 += v15;
    }
  }
  result = sub_40F3E0(v15 + v10 - v9);
  *v9 = 0;
  return result;
}
// 405A73: variable 'lpMem' is possibly undefined

//----- (00405AD0) --------------------------------------------------------
const CHAR *__stdcall sub_405AD0(char *Destination, char *a2, int a3)
{
  return sub_4058F0(Destination, a2, 0, 1, -1, a3);
}

//----- (00405AF0) --------------------------------------------------------
char *__stdcall sub_405AF0(const char *a1, int a2)
{
  const char *v2; // esi
  int v3; // ebx
  int v4; // edi
  char *result; // eax
  char *v6; // ebx

  v2 = a1;
  v3 = sub_4052C0(a1);
  v4 = sub_40F280((unsigned int)a1);
  result = sub_40F2C0(v3, a2);
  v6 = result;
  if ( v4 )
  {
    result = sub_40F340(v4);
    v2 = result;
  }
  if ( v2 )
  {
    strcpy(v6, v2);
    return CharUpperA(v6);
  }
  else
  {
    *v6 = 0;
  }
  return result;
}

//----- (00405B50) --------------------------------------------------------
_BYTE *__stdcall sub_405B50(signed int Size, int a2)
{
  size_t v2; // esi
  _BYTE *result; // eax
  _BYTE *v4; // edi

  v2 = Size;
  if ( Size < 0 )
    v2 = 0;
  result = sub_40F2C0(v2, a2);
  v4 = result;
  if ( v2 )
  {
    result = memset(result, 32, v2);
    v4[v2] = 0;
  }
  else
  {
    *result = 0;
  }
  return result;
}

//----- (00405BF0) --------------------------------------------------------
unsigned __int8 *__cdecl sub_405BF0(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 v2; // al
  const char *v3; // esi
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 *v6; // edi
  int v7; // eax
  unsigned __int8 v8; // bl
  int v9; // edi
  CHAR *v11; // [esp-4h] [ebp-28h]
  unsigned __int8 v12; // [esp+13h] [ebp-11h]
  unsigned int v13; // [esp+14h] [ebp-10h]
  unsigned int v14; // [esp+18h] [ebp-Ch]
  int i; // [esp+1Ch] [ebp-8h]
  const char *v16; // [esp+2Ch] [ebp+8h]

  v2 = *a2;
  v3 = a2 + 1;
  v16 = a2 + 1;
  if ( !v2 )
    return a1;
  v4 = (unsigned __int8)CharLowerA((LPSTR)v2);
  v12 = v4;
  v14 = strlen(v3);
  do
  {
LABEL_3:
    v5 = *a1;
    v6 = ++a1;
    if ( !v5 )
      return 0;
  }
  while ( (unsigned __int8)CharLowerA((LPSTR)v5) != v4 );
  v13 = v14;
  if ( v14 )
  {
    v7 = v6 - (unsigned __int8 *)v3;
    for ( i = v6 - (unsigned __int8 *)v3; ; v7 = i )
    {
      v8 = v3[v7];
      v11 = (CHAR *)*(unsigned __int8 *)v3++;
      v9 = (unsigned __int8)CharLowerA(v11);
      if ( (unsigned __int8)CharLowerA((LPSTR)v8) != v9 )
      {
        v4 = v12;
        v3 = v16;
        goto LABEL_3;
      }
      if ( !v8 )
        break;
      if ( !--v13 )
        break;
    }
    v6 = a1;
  }
  return v6 - 1;
}

//----- (00405CC0) --------------------------------------------------------
void __cdecl sub_405CC0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) < *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_405CC0(a1, &v14, v10, a4);
    sub_405CC0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) < *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 405DE6: conditional instruction was optimized away because edi.4!=0

//----- (00405E00) --------------------------------------------------------
void __cdecl sub_405E00(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) > *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_405E00(a1, &v14, v10, a4);
    sub_405E00(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) > *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 405F26: conditional instruction was optimized away because edi.4!=0

//----- (00405F40) --------------------------------------------------------
void __cdecl sub_405F40(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) < *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_405F40(a1, &v14, v10, a4);
    sub_405F40(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) < *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406066: conditional instruction was optimized away because edi.4!=0

//----- (00406080) --------------------------------------------------------
void __cdecl sub_406080(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) > *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406080(a1, &v14, v10, a4);
    sub_406080(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) > *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 4061A6: conditional instruction was optimized away because edi.4!=0

//----- (004061C0) --------------------------------------------------------
void __cdecl sub_4061C0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_WORD *)(*a1 + a4) < *(_WORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_4061C0(a1, &v14, v10, a4);
    sub_4061C0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_WORD *)((char *)v11 + v9) < *(_WORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 4062E8: conditional instruction was optimized away because edi.4!=0

//----- (00406310) --------------------------------------------------------
void __cdecl sub_406310(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_WORD *)(*a1 + a4) > *(_WORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406310(a1, &v14, v10, a4);
    sub_406310(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_WORD *)((char *)v11 + v9) > *(_WORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406438: conditional instruction was optimized away because edi.4!=0

//----- (00406460) --------------------------------------------------------
void __cdecl sub_406460(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_DWORD *)(*a1 + a4) < *(_DWORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406460(a1, &v14, v10, a4);
    sub_406460(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_DWORD *)((char *)v11 + v9) < *(_DWORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406586: conditional instruction was optimized away because edi.4!=0

//----- (004065A0) --------------------------------------------------------
void __cdecl sub_4065A0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_DWORD *)(*a1 + a4) > *(_DWORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_4065A0(a1, &v14, v10, a4);
    sub_4065A0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_DWORD *)((char *)v11 + v9) > *(_DWORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 4066C6: conditional instruction was optimized away because edi.4!=0

//----- (004066E0) --------------------------------------------------------
void __cdecl sub_4066E0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebp
  int v10; // edi
  _DWORD *v11; // edx
  int v12; // ebx
  int *v13; // ecx
  _DWORD *v14; // [esp+8h] [ebp-Ch] BYREF
  int v15; // [esp+Ch] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(float *)(*a2 + a4) > (double)*(float *)(*a1 + a4) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_4066E0(a1, &v14, v10, a4);
    sub_4066E0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(float *)(v12 + v9) > (double)*(float *)((char *)v11 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406820: conditional instruction was optimized away because edi.4!=0

//----- (00406840) --------------------------------------------------------
void __cdecl sub_406840(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebp
  int v10; // edi
  _DWORD *v11; // edx
  int v12; // ebx
  int *v13; // ecx
  _DWORD *v14; // [esp+8h] [ebp-Ch] BYREF
  int v15; // [esp+Ch] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(float *)(*a2 + a4) < (double)*(float *)(*a1 + a4) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406840(a1, &v14, v10, a4);
    sub_406840(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(float *)(v12 + v9) < (double)*(float *)((char *)v11 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406980: conditional instruction was optimized away because edi.4!=0

//----- (004069A0) --------------------------------------------------------
void __cdecl sub_4069A0(int *a1, int *a2, int a3, int a4)
{
  int v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edi
  int v9; // ebp
  int v10; // ebx
  _DWORD *v11; // eax
  int *v12; // esi
  int v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    if ( dword_413A54(*(_DWORD *)(*a1 + a4), *(_DWORD *)(*a2 + a4)) < 0 )
    {
      v5 = (_DWORD *)*a1;
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_4069A0(a1, &v14, v10, a4);
    sub_4069A0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v14 = (_DWORD *)*a1;
    v12 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( dword_413A54(*(_DWORD *)((char *)v11 + v9), *(_DWORD *)(a3 + v9)) < 0 )
        {
          *v12 = a3;
          *(_DWORD *)(a3 + 4) = v12;
          v12 = (int *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v12 = (int)v14;
          v14[1] = v12;
          v12 = v14;
          v11 = (_DWORD *)*v14;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v12 = (int)v11;
        v14[1] = v12;
        v12 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      if ( v8 )
      {
        v13 = a3;
        do
        {
          --v8;
          *v12 = v13;
          *(_DWORD *)(a3 + 4) = v12;
          v12 = (int *)a3;
          v13 = *(_DWORD *)a3;
          a3 = *(_DWORD *)a3;
        }
        while ( v8 );
      }
    }
    *a1 = v15;
    *a2 = (int)v12;
  }
}
// 406AE6: conditional instruction was optimized away because ebx.4!=0
// 413A54: using guessed type int (__stdcall *dword_413A54)(_DWORD, _DWORD);

//----- (00406B00) --------------------------------------------------------
void __cdecl sub_406B00(int *a1, int *a2, int a3, int a4)
{
  int v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edi
  int v9; // ebp
  int v10; // ebx
  _DWORD *v11; // eax
  int *v12; // esi
  int v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    if ( dword_413A54(*(_DWORD *)(*a1 + a4), *(_DWORD *)(*a2 + a4)) > 0 )
    {
      v5 = (_DWORD *)*a1;
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406B00(a1, &v14, v10, a4);
    sub_406B00(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v14 = (_DWORD *)*a1;
    v12 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( dword_413A54(*(_DWORD *)((char *)v11 + v9), *(_DWORD *)(a3 + v9)) > 0 )
        {
          *v12 = a3;
          *(_DWORD *)(a3 + 4) = v12;
          v12 = (int *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v12 = (int)v14;
          v14[1] = v12;
          v12 = v14;
          v11 = (_DWORD *)*v14;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v12 = (int)v11;
        v14[1] = v12;
        v12 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      if ( v8 )
      {
        v13 = a3;
        do
        {
          --v8;
          *v12 = v13;
          *(_DWORD *)(a3 + 4) = v12;
          v12 = (int *)a3;
          v13 = *(_DWORD *)a3;
          a3 = *(_DWORD *)a3;
        }
        while ( v8 );
      }
    }
    *a1 = v15;
    *a2 = (int)v12;
  }
}
// 406C46: conditional instruction was optimized away because ebx.4!=0
// 413A54: using guessed type int (__stdcall *dword_413A54)(_DWORD, _DWORD);

//----- (00406C60) --------------------------------------------------------
void __cdecl sub_406C60(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) < *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406C60(a1, &v14, v10, a4);
    sub_406C60(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) < *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406D86: conditional instruction was optimized away because edi.4!=0

//----- (00406DA0) --------------------------------------------------------
void __cdecl sub_406DA0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ebp
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_BYTE *)(*a1 + a4) > *(_BYTE *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406DA0(a1, &v14, v10, a4);
    sub_406DA0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v11 + v9) > *(_BYTE *)(v9 + v12) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 406EC6: conditional instruction was optimized away because edi.4!=0

//----- (00406EE0) --------------------------------------------------------
void __cdecl sub_406EE0(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebp
  int v10; // edi
  _DWORD *v11; // edx
  int v12; // ebx
  int *v13; // ecx
  _DWORD *v14; // [esp+8h] [ebp-Ch] BYREF
  int v15; // [esp+Ch] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(double *)(a4 + *a2) > *(double *)(*a1 + a4) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_406EE0(a1, &v14, v10, a4);
    sub_406EE0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(double *)(v12 + v9) > *(double *)((char *)v11 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 407010: conditional instruction was optimized away because edi.4!=0

//----- (00407030) --------------------------------------------------------
void __cdecl sub_407030(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebp
  int v10; // edi
  _DWORD *v11; // edx
  int v12; // ebx
  int *v13; // ecx
  _DWORD *v14; // [esp+8h] [ebp-Ch] BYREF
  int v15; // [esp+Ch] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(double *)(a4 + *a2) < *(double *)(*a1 + a4) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_407030(a1, &v14, v10, a4);
    sub_407030(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(double *)(v12 + v9) < *(double *)((char *)v11 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 407160: conditional instruction was optimized away because edi.4!=0

//----- (00407180) --------------------------------------------------------
void __cdecl sub_407180(int *a1, int *a2, int a3, int a4)
{
  int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_QWORD *)(*a1 + a4) < *(_QWORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_407180(a1, &v14, v4 / 2, a4);
    sub_407180(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_QWORD *)((char *)v11 + v9) < *(_QWORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 4072C2: conditional instruction was optimized away because edi.4!=0

//----- (004072E0) --------------------------------------------------------
void __cdecl sub_4072E0(int *a1, int *a2, int a3, int a4)
{
  int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_QWORD *)(*a1 + a4) > *(_QWORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_4072E0(a1, &v14, v4 / 2, a4);
    sub_4072E0(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_QWORD *)((char *)v11 + v9) > *(_QWORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 407422: conditional instruction was optimized away because edi.4!=0

//----- (00407440) --------------------------------------------------------
void __cdecl sub_407440(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_WORD *)(*a1 + a4) < *(_WORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_407440(a1, &v14, v10, a4);
    sub_407440(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_WORD *)((char *)v11 + v9) < *(_WORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 407568: conditional instruction was optimized away because edi.4!=0

//----- (00407590) --------------------------------------------------------
void __cdecl sub_407590(int *a1, int *a2, int a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // edx
  int *v13; // eax
  _DWORD *v14; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h] BYREF

  v4 = a3;
  if ( a3 == 2 )
  {
    v5 = (_DWORD *)*a1;
    if ( *(_WORD *)(*a1 + a4) > *(_WORD *)(a4 + *a2) )
    {
      *a1 = *a2;
      *a2 = (int)v5;
      *(_DWORD *)*a1 = v5;
      *(_DWORD *)(*a2 + 4) = *a1;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = (_DWORD *)*a1;
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    a3 = *a1;
    if ( v4 / 2 )
    {
      do
      {
        --v7;
        v6 = (_DWORD *)*v6;
        a3 = (int)v6;
      }
      while ( v7 );
    }
    v9 = a4;
    v10 = v4 / 2;
    v14 = (_DWORD *)v6[1];
    sub_407590(a1, &v14, v10, a4);
    sub_407590(&a3, a2, v8, v9);
    v11 = (_DWORD *)*a1;
    v12 = a3;
    v14 = (_DWORD *)*a1;
    v13 = &v15;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *(_WORD *)((char *)v11 + v9) > *(_WORD *)(v12 + v9) )
        {
          *v13 = v12;
          *(_DWORD *)(a3 + 4) = v13;
          v13 = (int *)a3;
          v12 = *(_DWORD *)a3;
          v11 = v14;
          a3 = *(_DWORD *)a3;
          --v8;
        }
        else
        {
          *v13 = (int)v11;
          v14[1] = v13;
          v13 = v14;
          v11 = (_DWORD *)*v14;
          v12 = a3;
          v14 = (_DWORD *)*v14;
          --v10;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      do
      {
        --v10;
        *v13 = (int)v11;
        v14[1] = v13;
        v13 = v14;
        v11 = (_DWORD *)*v14;
        v14 = (_DWORD *)*v14;
      }
      while ( v10 );
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        --v8;
        *v13 = v12;
        *(_DWORD *)(a3 + 4) = v13;
        v13 = (int *)a3;
        v12 = *(_DWORD *)a3;
        a3 = *(_DWORD *)a3;
      }
    }
    *a1 = v15;
    *a2 = (int)v13;
  }
}
// 4076B8: conditional instruction was optimized away because edi.4!=0

//----- (004076E0) --------------------------------------------------------
void __stdcall sub_4076E0(_DWORD *a1, char a2, int a3, int a4, _DWORD *a5, int a6)
{
  int v6; // ebp
  _DWORD *v7; // edi
  int v8; // ecx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  int v11; // esi
  _DWORD *v12; // eax
  int v13; // edi
  _DWORD *v14; // esi
  int v15; // edx
  _DWORD *v16; // edx
  int v17; // [esp-10h] [ebp-14h]
  int v18; // [esp-10h] [ebp-14h]
  int v19; // [esp-10h] [ebp-14h]
  int v20; // [esp-10h] [ebp-14h]
  int v21; // [esp-10h] [ebp-14h]
  int v22; // [esp-10h] [ebp-14h]
  int v23; // [esp-10h] [ebp-14h]
  int v24; // [esp-10h] [ebp-14h]
  int v25; // [esp-10h] [ebp-14h]
  int v26; // [esp-10h] [ebp-14h]

  v6 = (int)a1;
  if ( a1 && *a1 )
  {
    v7 = a5;
    if ( a5 == (_DWORD *)-1 )
    {
      v8 = a1[4];
      a1 = (_DWORD *)*a1;
      v9 = *(_DWORD **)(v6 + 4);
    }
    else
    {
      v10 = sub_40989E((int)a1, (int)a5);
      v11 = a6;
      a1 = v10;
      v12 = sub_40989E(v6, a6);
      v8 = v11 - (_DWORD)v7 + 1;
      if ( !a1 || !v12 )
        return;
      a1 -= 2;
      v9 = v12 - 2;
    }
    a5 = v9;
    v13 = *v9;
    v14 = (_DWORD *)a1[1];
    v15 = a4;
    if ( a4 == -1 )
      v15 = *(_DWORD *)(v6 + 44);
    switch ( v15 )
    {
      case 1:
        v18 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_405F40((int *)&a1, (int *)&a5, v8, v18);
        else
          sub_406080((int *)&a1, (int *)&a5, v8, v18);
        break;
      case 3:
        v19 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_4061C0((int *)&a1, (int *)&a5, v8, v19);
        else
          sub_406310((int *)&a1, (int *)&a5, v8, v19);
        break;
      case 5:
      case 21:
        v20 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_406460((int *)&a1, (int *)&a5, v8, v20);
        else
          sub_4065A0((int *)&a1, (int *)&a5, v8, v20);
        break;
      case 8:
        dword_413A54 = (int (__stdcall *)(_DWORD, _DWORD))sub_408060;
        if ( (a2 & 2) == 0 )
          dword_413A54 = sub_408000;
        v21 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_4069A0((int *)&a1, (int *)&a5, v8, v21);
        else
          sub_406B00((int *)&a1, (int *)&a5, v8, v21);
        break;
      case 9:
        v22 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_4066E0((int *)&a1, (int *)&a5, v8, v22);
        else
          sub_406840((int *)&a1, (int *)&a5, v8, v22);
        break;
      case 11:
        v23 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_406C60((int *)&a1, (int *)&a5, v8, v23);
        else
          sub_406DA0((int *)&a1, (int *)&a5, v8, v23);
        break;
      case 12:
        v24 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_406EE0((int *)&a1, (int *)&a5, v8, v24);
        else
          sub_407030((int *)&a1, (int *)&a5, v8, v24);
        break;
      case 13:
        v25 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_407180((int *)&a1, (int *)&a5, v8, v25);
        else
          sub_4072E0((int *)&a1, (int *)&a5, v8, v25);
        break;
      case 24:
        v17 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_405CC0((int *)&a1, (int *)&a5, v8, v17);
        else
          sub_405E00((int *)&a1, (int *)&a5, v8, v17);
        break;
      case 25:
        v26 = a3 + 8;
        if ( (a2 & 1) != 0 )
          sub_407440((int *)&a1, (int *)&a5, v8, v26);
        else
          sub_407590((int *)&a1, (int *)&a5, v8, v26);
        break;
      default:
        break;
    }
    a1[1] = v14;
    *a5 = v13;
    if ( v14 )
      *v14 = a1;
    else
      *(_DWORD *)v6 = a1;
    if ( v13 )
    {
      *(_DWORD *)(v13 + 4) = a5;
      *(_BYTE *)(v6 + 48) = 1;
    }
    else
    {
      v16 = a5;
      *(_BYTE *)(v6 + 48) = 1;
      *(_DWORD *)(v6 + 4) = v16;
    }
  }
}
// 408000: using guessed type int __stdcall sub_408000(int, int);
// 413A54: using guessed type int (__stdcall *dword_413A54)(_DWORD, _DWORD);

//----- (00407A00) --------------------------------------------------------
void __stdcall sub_407A00(_DWORD *a1, char a2, int a3, int a4)
{
  sub_4076E0(a1, a2, a3, a4, (_DWORD *)0xFFFFFFFF, -1);
}

//----- (00407D30) --------------------------------------------------------
void __stdcall sub_407D30(_DWORD *a1, char a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edx
  int v4; // eax
  int v5; // ebp
  _DWORD *v6; // edi
  _DWORD *v7; // ecx
  _DWORD *v8; // [esp+4h] [ebp-4h] BYREF

  v2 = a1;
  if ( a1 && *a1 )
  {
    v3 = (_DWORD *)*a1;
    v4 = a1[4];
    v8 = (_DWORD *)a1[1];
    a1 = v3;
    v5 = *v8;
    v6 = (_DWORD *)v3[1];
    switch ( v2[11] )
    {
      case 1:
        if ( (a2 & 1) != 0 )
          sub_405F40((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_406080((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 3:
        if ( (a2 & 1) != 0 )
          sub_4061C0((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_406310((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 5:
      case 0x15:
        if ( (a2 & 1) != 0 )
          sub_406460((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_4065A0((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 8:
        dword_413A54 = (int (__stdcall *)(_DWORD, _DWORD))sub_408060;
        if ( (a2 & 2) == 0 )
          dword_413A54 = sub_408000;
        if ( (a2 & 1) != 0 )
          sub_4069A0((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_406B00((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 9:
        if ( (a2 & 1) != 0 )
          sub_4066E0((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_406840((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 0xB:
        if ( (a2 & 1) != 0 )
          sub_406C60((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_406DA0((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 0xC:
        if ( (a2 & 1) != 0 )
          sub_406EE0((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_407030((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 0xD:
        if ( (a2 & 1) != 0 )
          sub_407180((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_4072E0((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 0x18:
        if ( (a2 & 1) != 0 )
          sub_405CC0((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_405E00((int *)&a1, (int *)&v8, v4, 8);
        break;
      case 0x19:
        if ( (a2 & 1) != 0 )
          sub_407440((int *)&a1, (int *)&v8, v4, 8);
        else
          sub_407590((int *)&a1, (int *)&v8, v4, 8);
        break;
      default:
        break;
    }
    a1[1] = v6;
    *v8 = v5;
    if ( v6 )
      *v6 = a1;
    else
      *v2 = a1;
    if ( v5 )
    {
      *(_DWORD *)(v5 + 4) = v8;
      *((_BYTE *)v2 + 48) = 1;
    }
    else
    {
      v7 = v8;
      *((_BYTE *)v2 + 48) = 1;
      v2[1] = v7;
    }
  }
}
// 408000: using guessed type int __stdcall sub_408000(int, int);
// 413A54: using guessed type int (__stdcall *dword_413A54)(_DWORD, _DWORD);

//----- (00408060) --------------------------------------------------------
int __stdcall sub_408060(char *String1, char *String2)
{
  if ( String1 )
  {
    if ( String2 )
      return stricmp(String1, String2);
    else
      return 1;
  }
  else if ( String2 && *String2 )
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

//----- (00408099) --------------------------------------------------------
HRESULT sub_408099()
{
  INITCOMMONCONTROLSEX picce; // [esp+0h] [ebp-8h] BYREF

  picce.dwSize = 8;
  picce.dwICC = 2888;
  InitCommonControlsEx(&picce);
  return CoInitialize(0);
}

//----- (004080D0) --------------------------------------------------------
int __stdcall sub_4080D0(LPCSTR lpCaption, LPCSTR lpText, UINT uType)
{
  HWND v3; // eax
  int v4; // esi

  sub_40831D(1);
  v3 = sub_4083C6();
  v4 = MessageBoxA(v3, lpText, lpCaption, uType);
  sub_40831D(0);
  return v4;
}

//----- (004080FF) --------------------------------------------------------
int __stdcall sub_4080FF(HWND hWnd, int a2, int a3, LPARAM lParam)
{
  if ( a2 == 1 && lParam )
  {
    SendMessageA(hWnd, 0x466u, 1u, lParam);
    Sleep(0xC8u);
    PostMessageA(hWnd, 0x466u, 1u, lParam);
  }
  return 0;
}

//----- (00408143) --------------------------------------------------------
const CHAR *__stdcall sub_408143(int a1, char *Source, int a3)
{
  HMODULE LibraryA; // eax
  signed int v4; // eax
  char *v5; // eax
  char *v6; // esi
  size_t v7; // eax
  bool v8; // zf
  char Destination[260]; // [esp+8h] [ebp-134h] BYREF
  int v12[8]; // [esp+10Ch] [ebp-30h] BYREF
  FARPROC SHGetPathFromIDList; // [esp+12Ch] [ebp-10h]
  FARPROC SHBrowseForFolder; // [esp+130h] [ebp-Ch]
  HMODULE hModule; // [esp+134h] [ebp-8h]
  size_t v16; // [esp+138h] [ebp-4h]
  char *Sourcea; // [esp+148h] [ebp+Ch]

  if ( !dword_413580 )
  {
    dword_413580 = 1;
    CoInitialize(0);
  }
  memset(v12, 0, sizeof(v12));
  v16 = 0;
  LibraryA = LoadLibraryA("SHELL32.DLL");
  hModule = LibraryA;
  if ( !LibraryA )
    goto LABEL_13;
  SHBrowseForFolder = GetProcAddress(LibraryA, "SHBrowseForFolder");
  SHGetPathFromIDList = GetProcAddress(hModule, "SHGetPathFromIDList");
  if ( !Source )
    Source = (char *)&unk_411002;
  strncpy(Destination, Source, 0x103u);
  Destination[259] = 0;
  v4 = strlen(Destination);
  if ( v4 > 3 )
  {
    v5 = &Destination[v4 - 1];
    if ( *v5 == 92 )
      *v5 = 0;
  }
  v12[3] = a1;
  v12[0] = (int)sub_4083C6();
  v12[4] = 80;
  v12[5] = (int)sub_4080FF;
  v12[6] = (int)Destination;
  sub_40831D(1);
  Sourcea = (char *)((int (__stdcall *)(int *))SHBrowseForFolder)(v12);
  sub_40831D(0);
  if ( Sourcea )
  {
    v6 = sub_40F2C0(260, a3);
    *v6 = 0;
    ((void (__stdcall *)(char *, char *))SHGetPathFromIDList)(Sourcea, v6);
    CoTaskMemFree(Sourcea);
    v7 = strlen(v6);
    v8 = v6[v7 - 1] == 92;
    v16 = v7;
    if ( !v8 )
    {
      ++v16;
      *(_WORD *)&v6[v7] = 92;
    }
  }
  FreeLibrary(hModule);
  if ( !v16 )
LABEL_13:
    *sub_40F2C0(260, a3) = 0;
  return sub_40F3E0(260 - v16);
}
// 413580: using guessed type int dword_413580;

//----- (0040829B) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2)
{
  DWORD WindowThreadProcessId; // esi
  _DWORD *v3; // esi

  WindowThreadProcessId = GetWindowThreadProcessId(hWnd, 0);
  if ( WindowThreadProcessId == GetCurrentThreadId() && IsWindowVisible(hWnd) )
  {
    v3 = sub_40EC40((int)&dword_413584, 0x14u);
    v3[1] = hWnd;
    *v3 = GetCurrentThreadId();
    *((_WORD *)v3 + 4) = 0;
    if ( (GetWindowLongA(hWnd, -20) & 8) != 0 )
      *((_BYTE *)v3 + 8) = 1;
    if ( hWnd != GetForegroundWindow() && IsWindowEnabled(hWnd) )
    {
      *((_BYTE *)v3 + 9) = 1;
      EnableWindow(hWnd, 0);
    }
  }
  return 1;
}
// 413584: using guessed type int dword_413584;

//----- (0040831D) --------------------------------------------------------
void __stdcall sub_40831D(LPARAM lParam)
{
  int v1; // esi
  int v2; // edi
  int v3; // esi
  int v4; // ebp

  if ( lParam )
  {
    EnumWindows(EnumFunc, lParam);
    v1 = dword_413584;
    if ( dword_413584 )
    {
      do
      {
        v2 = *(_DWORD *)v1;
        if ( *(_DWORD *)(v1 + 8) == GetCurrentThreadId() )
        {
          if ( *(_BYTE *)(v1 + 16) )
            SetWindowPos(*(HWND *)(v1 + 12), (HWND)0xFFFFFFFE, 0, 0, 0, 0, 3u);
        }
        v1 = v2;
      }
      while ( v2 );
    }
  }
  else
  {
    v3 = dword_413584;
    if ( dword_413584 )
    {
      do
      {
        v4 = *(_DWORD *)v3;
        if ( *(_DWORD *)(v3 + 8) == GetCurrentThreadId() )
        {
          if ( *(_BYTE *)(v3 + 17) )
            EnableWindow(*(HWND *)(v3 + 12), 1);
          if ( *(_BYTE *)(v3 + 16) )
            SetWindowPos(*(HWND *)(v3 + 12), HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
          sub_40EC6D(&dword_413584, v3 + 8);
        }
        v3 = v4;
      }
      while ( v4 );
    }
  }
}
// 413584: using guessed type int dword_413584;

//----- (004083C6) --------------------------------------------------------
HWND sub_4083C6()
{
  HWND ForegroundWindow; // esi
  DWORD dwProcessId; // [esp+4h] [ebp-4h] BYREF

  ForegroundWindow = GetForegroundWindow();
  if ( ForegroundWindow )
  {
    GetWindowThreadProcessId(ForegroundWindow, &dwProcessId);
    if ( dwProcessId != GetCurrentProcessId() )
      return 0;
  }
  return ForegroundWindow;
}

//----- (004083F4) --------------------------------------------------------
void **__stdcall sub_4083F4(int a1)
{
  void **result; // eax

  result = (void **)sub_40E59A(dword_413A58, a1);
  if ( result )
  {
    CloseHandle(*result);
    return sub_40E5BF((size_t *)dword_413A58, a1);
  }
  return result;
}
// 413A58: using guessed type int dword_413A58;

//----- (00408421) --------------------------------------------------------
void sub_408421()
{
  dword_413A5C = (int)sub_40E64A(0x10u, 0, 0);
  dword_413A58 = (int)sub_40E5FA(4, 4, (int)sub_4083F4);
  InitializeCriticalSection(&CriticalSection);
}
// 413A58: using guessed type int dword_413A58;
// 413A5C: using guessed type int dword_413A5C;

//----- (00408450) --------------------------------------------------------
const CHAR *__stdcall sub_408450(int a1)
{
  char *v1; // esi
  DWORD ModuleFileNameA; // edi
  const CHAR *result; // eax

  v1 = sub_40F2C0(260, a1);
  ModuleFileNameA = GetModuleFileNameA(hInstance, v1, 0x104u);
  if ( !strcmp(v1, "\\\\?\\") )
  {
    memmove(v1, v1 + 4, ModuleFileNameA - 4);
    ModuleFileNameA -= 4;
  }
  result = sub_40F3E0(260 - ModuleFileNameA);
  v1[ModuleFileNameA] = 0;
  return result;
}

//----- (004084AB) --------------------------------------------------------
LPSTR __stdcall sub_4084AB(_DWORD *a1)
{
  _DWORD *v1; // edi
  LPSTR v2; // esi
  LPSTR result; // eax
  CHAR v4; // cl
  LPSTR v5; // edx
  CHAR v6; // cl
  int v7; // ebx
  char v8; // cl
  _DWORD *v9; // ecx
  int v10; // [esp+Ch] [ebp-4h]

  v10 = -1;
  v1 = (_DWORD *)sub_40E643(dword_413A5C);
  v2 = 0;
  result = GetCommandLineA();
  v4 = *result;
  if ( !*result )
  {
LABEL_25:
    if ( !a1 )
      return (LPSTR)v10;
    v9 = a1;
    goto LABEL_30;
  }
  v5 = (LPSTR)a1;
  while ( 1 )
  {
    if ( v4 == 32 )
    {
      do
        ++result;
      while ( *result == 32 );
    }
    v6 = *result;
    v7 = 1;
    if ( *result == 34 )
    {
      v8 = *++result;
      v2 = result;
      if ( !*result )
        goto LABEL_12;
      do
      {
        if ( v8 == 34 )
          break;
        v8 = *++result;
      }
      while ( *result );
      if ( !*result )
      {
LABEL_12:
        v5 = result;
        goto LABEL_20;
      }
      v5 = result;
LABEL_11:
      ++result;
      goto LABEL_20;
    }
    if ( !v6 )
    {
      v7 = 0;
      goto LABEL_20;
    }
    v2 = result;
    do
    {
      if ( v6 == 32 )
        break;
      v6 = *++result;
    }
    while ( *result );
    v5 = result;
    if ( *result )
      goto LABEL_11;
LABEL_20:
    if ( *v1 == v10 )
    {
      v9 = a1;
      if ( a1 )
        break;
    }
    if ( v7 )
      ++v10;
    v4 = *result;
    v2 = 0;
    if ( !*result )
      goto LABEL_25;
  }
  if ( v2 )
  {
    *a1 = v5 - v2;
    ++*v1;
    return v2;
  }
LABEL_30:
  *v9 = 0;
  return result;
}
// 413A5C: using guessed type int dword_413A5C;

//----- (0040856C) --------------------------------------------------------
char *__stdcall sub_40856C(int a1, int a2)
{
  int *v2; // eax
  LPSTR v3; // eax
  size_t v4; // esi
  const char *v5; // ebx
  char *v6; // edi
  char *result; // eax
  size_t Count; // [esp+0h] [ebp-4h] BYREF

  Count = 0;
  v2 = (int *)sub_40E643(dword_413A5C);
  if ( a1 >= 0 )
    *v2 = a1;
  v3 = sub_4084AB(&Count);
  v4 = Count;
  v5 = v3;
  v6 = sub_40F2C0(Count, a2);
  result = strncpy(v6, v5, v4);
  v6[v4] = 0;
  return result;
}
// 413A5C: using guessed type int dword_413A5C;

//----- (004085BA) --------------------------------------------------------
LPSTR sub_4085BA()
{
  sub_40E643(dword_413A5C);
  return sub_4084AB(0);
}
// 413A5C: using guessed type int dword_413A5C;

//----- (004085CD) --------------------------------------------------------
BOOL __stdcall sub_4085CD(const CHAR *a1, const CHAR *a2)
{
  BOOL result; // eax

  if ( a1 )
  {
    if ( !a2 )
      a2 = (const CHAR *)&unk_411002;
    return SetEnvironmentVariableA(a1, a2);
  }
  return result;
}

//----- (004085EE) --------------------------------------------------------
_DWORD *__stdcall sub_4085EE(_DWORD *a1, LPCSTR lpFileName)
{
  int v2; // edi
  HANDLE FileA; // esi
  _DWORD *v4; // eax
  DWORD NumberOfBytesRead; // [esp+4h] [ebp-4h] BYREF

  v2 = 0;
  if ( lpFileName )
  {
    FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    if ( FileA != (HANDLE)-1 )
    {
      ReadFile(FileA, &lpFileName, 4u, &NumberOfBytesRead, 0);
      if ( lpFileName == (LPCSTR)1886157361 || lpFileName == (LPCSTR)1886157362 )
      {
        v4 = HeapAlloc(hHeap, 8u, 0x18u);
        *v4 = FileA;
        v4[5] = lpFileName;
        *a1 = &dword_413A78;
        a1[1] = v4;
        return v4;
      }
    }
  }
  return (_DWORD *)v2;
}
// 413A78: using guessed type int dword_413A78;

//----- (0040866D) --------------------------------------------------------
_DWORD *__stdcall sub_40866D(_DWORD *a1, LPCSTR lpFileName)
{
  int v2; // edi
  HANDLE FileA; // esi
  _DWORD *v4; // eax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

  v2 = 0;
  if ( lpFileName )
  {
    FileA = CreateFileA(lpFileName, 0xC0000000, 1u, 0, 2u, 0x80u, 0);
    if ( FileA != (HANDLE)-1 )
    {
      lpFileName = (LPCSTR)1886157362;
      WriteFile(FileA, &lpFileName, 4u, &NumberOfBytesWritten, 0);
      v4 = HeapAlloc(hHeap, 8u, 0x18u);
      *v4 = FileA;
      *a1 = &dword_413A78;
      a1[1] = v4;
      return v4;
    }
  }
  return (_DWORD *)v2;
}
// 413A78: using guessed type int dword_413A78;

//----- (004086DB) --------------------------------------------------------
int __stdcall sub_4086DB(_DWORD *a1, int a2)
{
  int result; // eax

  result = (int)a1;
  if ( a1[2] )
    return sub_40FC60(*(_DWORD *)(a1[1] + 4 * a1[4]) + 20, a2);
  return result;
}

//----- (004086FE) --------------------------------------------------------
DWORD __usercall sub_4086FE@<eax>(int a1@<eax>, _BYTE *lpBuffer, int a3, CHAR *lpMultiByteStr, SIZE_T *a5)
{
  SIZE_T *v6; // esi
  _DWORD *v7; // ebx
  DWORD NumberOfBytesRead; // [esp+8h] [ebp-8h] BYREF
  DWORD v10; // [esp+Ch] [ebp-4h]

  v10 = -1;
  v6 = 0;
  if ( lpMultiByteStr && *lpMultiByteStr )
  {
    lpMultiByteStr = sub_40FBA0(lpMultiByteStr);
    v6 = (SIZE_T *)sub_408CE6(a1, lpMultiByteStr);
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 8) )
      goto LABEL_20;
    v6 = *(SIZE_T **)(*(_DWORD *)(a1 + 4) + 4 * *(_DWORD *)(a1 + 16));
  }
  if ( v6 )
  {
    if ( a5 )
    {
      lpBuffer = HeapAlloc(hHeap, 0, *v6);
      a3 = *v6;
    }
    if ( lpBuffer && a3 >= *(_QWORD *)v6 )
    {
      SetFilePointer(*(HANDLE *)a1, v6[4], 0, 0);
      if ( v6[2] == *v6 && v6[3] == v6[1] )
      {
        ReadFile(*(HANDLE *)a1, lpBuffer, *v6, &NumberOfBytesRead, 0);
        if ( *(_QWORD *)v6 == NumberOfBytesRead )
          v10 = NumberOfBytesRead;
      }
      else
      {
        v7 = HeapAlloc(hHeap, 0, v6[2]);
        if ( v7 )
        {
          ReadFile(*(HANDLE *)a1, v7, v6[2], &NumberOfBytesRead, 0);
          if ( *((_QWORD *)v6 + 1) == NumberOfBytesRead && sub_408E4A(v7, lpBuffer, a3) == *(_QWORD *)v6 )
            v10 = *v6;
          HeapFree(hHeap, 0, v7);
        }
      }
    }
  }
LABEL_20:
  if ( a5 )
  {
    if ( v10 == -1 )
    {
      if ( lpBuffer )
        HeapFree(hHeap, 0, lpBuffer);
      v10 = 0;
    }
    else
    {
      v10 = (DWORD)lpBuffer;
      *a5 = *v6;
    }
  }
  if ( lpMultiByteStr && *lpMultiByteStr )
    sub_40FC50(lpMultiByteStr);
  return v10;
}

//----- (0040887D) --------------------------------------------------------
DWORD __stdcall sub_40887D(int a1, _BYTE *a2, int a3, CHAR *a4)
{
  return sub_4086FE(a1, a2, a3, a4, 0);
}

//----- (0040889A) --------------------------------------------------------
int __stdcall sub_40889A(DWORD nNumberOfBytesToWrite, LPCSTR lpFileName, CHAR *lpBuffer)
{
  HANDLE FileA; // ebx
  int v4; // esi
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-8h] BYREF
  int v7; // [esp+8h] [ebp-4h]

  v7 = -1;
  lpBuffer = (CHAR *)sub_4086FE(nNumberOfBytesToWrite, 0, 0, lpBuffer, &nNumberOfBytesToWrite);
  if ( lpBuffer )
  {
    FileA = CreateFileA(lpFileName, 0xC0000000, 1u, 0, 2u, 0x80u, 0);
    if ( FileA != (HANDLE)-1 )
    {
      v4 = nNumberOfBytesToWrite;
      WriteFile(FileA, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
      if ( v4 == NumberOfBytesWritten )
        v7 = v4;
      CloseHandle(FileA);
      if ( v7 == -1 )
        DeleteFileA(lpFileName);
    }
    HeapFree(hHeap, 0, lpBuffer);
  }
  return v7;
}

//----- (0040892E) --------------------------------------------------------
int __stdcall sub_40892E(HANDLE *a1, unsigned __int8 *lpBuffer, char *lpMem, char *Str)
{
  char *v5; // ebx
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  char *v9; // ebx
  __int64 Buffer[2]; // [esp+Ch] [ebp-1Ch] BYREF
  __int16 v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+24h] [ebp-4h] BYREF
  unsigned __int8 *lpMema; // [esp+38h] [ebp+10h]
  char *Stra; // [esp+3Ch] [ebp+14h]

  v13 = 0;
  v5 = lpMem + 24;
  Stra = sub_40FBA0(Str);
  v6 = (unsigned __int8 *)HeapAlloc(hHeap, 0, (SIZE_T)(lpMem + 24));
  v7 = v6;
  lpMema = v6;
  if ( v6 )
  {
    v8 = sub_408EB2(lpBuffer, (int)lpMem, v6, (int)v5, (void *)5, 0);
    v9 = (char *)v8;
    if ( v8 && v8 < (int)lpMem )
      lpBuffer = v7;
    else
      v9 = lpMem;
    v12 = strlen(Stra);
    Buffer[0] = (int)lpMem;
    Buffer[1] = (int)v9;
    WriteFile(*a1, Buffer, 0x12u, &NumberOfBytesWritten, 0);
    if ( NumberOfBytesWritten == 18 )
    {
      WriteFile(*a1, Stra, v12, &NumberOfBytesWritten, 0);
      if ( v12 == NumberOfBytesWritten )
      {
        WriteFile(*a1, lpBuffer, (DWORD)v9, &NumberOfBytesWritten, 0);
        if ( v9 == (char *)NumberOfBytesWritten )
          v13 = 1;
      }
    }
    sub_408B3E((int)a1);
    HeapFree(hHeap, 0, lpMema);
  }
  sub_40FC50(Stra);
  return v13;
}

//----- (00408A2E) --------------------------------------------------------
int __stdcall sub_408A2E(HANDLE *a1, LPCSTR lpFileName, char *Str)
{
  CHAR *FileA; // eax
  char *FileSize; // esi
  void *v5; // ebx
  DWORD NumberOfBytesRead; // [esp+4h] [ebp-8h] BYREF
  int v8; // [esp+8h] [ebp-4h]
  CHAR *lpFileNamea; // [esp+18h] [ebp+Ch]

  v8 = 0;
  if ( lpFileName )
  {
    FileA = (CHAR *)CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    lpFileNamea = FileA;
    if ( FileA != (CHAR *)-1 )
    {
      FileSize = (char *)GetFileSize(FileA, 0);
      v5 = HeapAlloc(hHeap, 0, (SIZE_T)FileSize);
      if ( v5 )
      {
        ReadFile(lpFileNamea, v5, (DWORD)FileSize, &NumberOfBytesRead, 0);
        if ( (char *)NumberOfBytesRead == FileSize && sub_40892E(a1, (unsigned __int8 *)v5, FileSize, Str) )
          v8 = 1;
        HeapFree(hHeap, 0, v5);
      }
      CloseHandle(lpFileNamea);
    }
  }
  return v8;
}

//----- (00408AD1) --------------------------------------------------------
int __stdcall sub_408AD1(int a1, int a2)
{
  return 0;
}

//----- (00408AD6) --------------------------------------------------------
int sub_408AD6()
{
  sub_409411(1651666042, (int)&dword_413A78);
  dword_413A80 = (int)sub_408A2E;
  dword_413A84 = (int)sub_40892E;
  dword_413A88 = (int)sub_40866D;
  dword_413A7C = (int)sub_4085EE;
  dword_413A9C = (int)sub_4086DB;
  dword_413AA4 = (int)sub_40887D;
  dword_413AA0 = (int)sub_40889A;
  dword_413AA8 = (int)sub_408AD1;
  sub_408E03();
  return 1;
}
// 413A78: using guessed type int dword_413A78;
// 413A7C: using guessed type int dword_413A7C;
// 413A80: using guessed type int dword_413A80;
// 413A84: using guessed type int dword_413A84;
// 413A88: using guessed type int dword_413A88;
// 413A9C: using guessed type int dword_413A9C;
// 413AA0: using guessed type int dword_413AA0;
// 413AA4: using guessed type int dword_413AA4;
// 413AA8: using guessed type int dword_413AA8;

//----- (00408B3E) --------------------------------------------------------
BOOL __cdecl sub_408B3E(int a1)
{
  int i; // edi
  BOOL result; // eax

  if ( *(_DWORD *)(a1 + 4) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 12); ++i )
      HeapFree(hHeap, 0, *(LPVOID *)(*(_DWORD *)(a1 + 4) + 4 * i));
    result = HeapFree(hHeap, 0, *(LPVOID *)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (00408B83) --------------------------------------------------------
void __cdecl sub_408B83(int a1)
{
  LPVOID v2; // eax
  int v3; // eax
  _DWORD *v4; // edi
  int v5; // eax
  HANDLE v6; // [esp-14h] [ebp-50h]
  int Buffer[4]; // [esp+8h] [ebp-34h] BYREF
  __int16 v8; // [esp+18h] [ebp-24h]
  int v9; // [esp+20h] [ebp-1Ch] BYREF
  int v10; // [esp+24h] [ebp-18h]
  LONG lDistanceToMove; // [esp+28h] [ebp-14h]
  int v12; // [esp+2Ch] [ebp-10h]
  __int16 v13; // [esp+30h] [ebp-Ch]
  int v14; // [esp+34h] [ebp-8h]
  DWORD NumberOfBytesRead; // [esp+38h] [ebp-4h] BYREF
  int v16; // [esp+44h] [ebp+8h]

  v14 = 64;
  if ( !*(_DWORD *)(a1 + 4) )
  {
    v2 = HeapAlloc(hHeap, 0, 0x100u);
    v6 = *(HANDLE *)a1;
    *(_DWORD *)(a1 + 4) = v2;
    *(_DWORD *)(a1 + 12) = 0;
    SetFilePointer(v6, 4, 0, 0);
    v16 = 4;
    while ( 1 )
    {
      if ( *(_DWORD *)(a1 + 20) == 1886157361 )
      {
        ReadFile(*(HANDLE *)a1, Buffer, 0x18u, &NumberOfBytesRead, 0);
        if ( NumberOfBytesRead != 24 )
          return;
        v9 = Buffer[0];
        v10 = Buffer[1];
        lDistanceToMove = Buffer[2];
        v12 = Buffer[3];
        v13 = v8;
      }
      else
      {
        ReadFile(*(HANDLE *)a1, &v9, 0x12u, &NumberOfBytesRead, 0);
        if ( NumberOfBytesRead != 18 )
          return;
      }
      v3 = v14;
      if ( *(_DWORD *)(a1 + 12) >= v14 )
      {
        v14 += 64;
        *(_DWORD *)(a1 + 4) = HeapReAlloc(hHeap, 8u, *(LPVOID *)(a1 + 4), 4 * (v3 + 64));
      }
      v4 = HeapAlloc(hHeap, 0, v13 + 25);
      *v4 = v9;
      v4[1] = v10;
      v4[2] = lDistanceToMove;
      v4[3] = v12;
      ReadFile(*(HANDLE *)a1, v4 + 5, v13, &NumberOfBytesRead, 0);
      *((_BYTE *)v4 + v13 + 20) = 0;
      if ( *(_DWORD *)(a1 + 20) == 1886157361 )
        v5 = v16 + v13 + 24;
      else
        v5 = v16 + v13 + 18;
      v4[4] = v5;
      v16 = lDistanceToMove + v5;
      *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (*(_DWORD *)(a1 + 12))++) = v4;
      SetFilePointer(*(HANDLE *)a1, lDistanceToMove, 0, 1u);
    }
  }
}

//----- (00408CE6) --------------------------------------------------------
int __cdecl sub_408CE6(int a1, char *Str1)
{
  int v2; // edi

  sub_408B83(a1);
  v2 = 0;
  if ( *(int *)(a1 + 12) <= 0 )
    return 0;
  while ( strcmp(Str1, (const char *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v2) + 20)) )
  {
    if ( ++v2 >= *(_DWORD *)(a1 + 12) )
      return 0;
  }
  return *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v2);
}

//----- (00408D26) --------------------------------------------------------
BOOL __stdcall sub_408D26(HANDLE *lpMem)
{
  sub_408B3E((int)lpMem);
  CloseHandle(*lpMem);
  return HeapFree(hHeap, 0, lpMem);
}

//----- (00408D4D) --------------------------------------------------------
int __stdcall sub_408D4D(_DWORD *a1)
{
  if ( !*a1 )
    return 0;
  sub_408B83((int)a1);
  a1[4] = -1;
  a1[2] = 0;
  return 1;
}

//----- (00408E03) --------------------------------------------------------
void sub_408E03()
{
  dword_413AAC = (int)sub_408DCD;
  dword_413AB0 = (int)sub_408DEC;
  dword_413A78 = (int)sub_408D26;
  dword_413A90 = (int)sub_408D94;
  dword_413A94 = (int)sub_408DBD;
  dword_413A98 = (int)sub_408D71;
  dword_413A8C = (int)sub_408D4D;
}
// 408D71: using guessed type int __stdcall sub_408D71(int);
// 408D94: using guessed type int __stdcall sub_408D94(int, int);
// 408DBD: using guessed type int __stdcall sub_408DBD(int);
// 408DCD: using guessed type int __stdcall sub_408DCD(int, int, int, int);
// 408DEC: using guessed type int __stdcall sub_408DEC(int, int, int, int);
// 413A78: using guessed type int dword_413A78;
// 413A8C: using guessed type int dword_413A8C;
// 413A90: using guessed type int dword_413A90;
// 413A94: using guessed type int dword_413A94;
// 413A98: using guessed type int dword_413A98;
// 413AAC: using guessed type int dword_413AAC;
// 413AB0: using guessed type int dword_413AB0;

//----- (00408E4A) --------------------------------------------------------
int __cdecl sub_408E4A(_DWORD *a1, _BYTE *a2, int a3)
{
  int v4; // ecx
  signed int i; // ebx
  unsigned int v6; // edi
  _BYTE *v8; // [esp+Ch] [ebp+8h]

  v4 = -1;
  if ( *a1 == 1651276337 )
  {
    v8 = a1 + 6;
    if ( a3 >= *((_QWORD *)a1 + 1) )
    {
      for ( i = a1[2]; i; i -= v6 )
      {
        if ( i >= *((_QWORD *)a1 + 2) )
          v6 = a1[4];
        else
          v6 = i;
        v8 += sub_409088(v8, a2, v6);
        a2 += v6;
      }
      return a1[2];
    }
  }
  return v4;
}

//----- (00408EB2) --------------------------------------------------------
int __cdecl sub_408EB2(unsigned __int8 *a1, int a2, _QWORD *a3, int a4, void *Src, int (__cdecl *a6)(int, int))
{
  signed int v6; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // esi
  void *lpMem; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]
  int v17; // [esp+24h] [ebp+Ch]
  char *v18; // [esp+28h] [ebp+10h]
  unsigned __int8 *Srca; // [esp+30h] [ebp+18h]

  v16 = 0;
  switch ( (unsigned int)Src )
  {
    case 0u:
      v6 = 0x2000;
      break;
    case 1u:
      v6 = 0x8000;
      break;
    case 2u:
      v6 = 0x10000;
      break;
    case 3u:
      v6 = 98304;
      break;
    case 4u:
      v6 = 0x20000;
      break;
    case 5u:
      v6 = 0x40000;
      break;
    case 6u:
      v6 = 0x80000;
      break;
    case 7u:
      v6 = 786432;
      break;
    default:
      v6 = 0x100000;
      break;
  }
  v18 = (char *)(a3 + 3);
  v8 = sub_409218(v6);
  Srca = (unsigned __int8 *)HeapAlloc(hHeap, 0, v8);
  if ( Srca )
  {
    v9 = sub_409212();
    lpMem = HeapAlloc(hHeap, 0, v9);
    if ( lpMem )
    {
      v10 = a2;
      a3[2] = v6;
      *(_DWORD *)a3 = 1651276337;
      a3[1] = a2;
      v16 = 24;
      while ( v10 )
      {
        v17 = v10;
        if ( v10 >= v6 )
          v17 = v6;
        v11 = sub_409226(a1, Srca, v17, lpMem);
        v12 = v11;
        if ( v11 )
        {
          v16 += v11;
          if ( v16 < a4 )
          {
            memcpy(v18, Srca, v11);
            v18 += v12;
            a1 += v6;
            v10 -= v17;
            if ( !a6 || a6(a2 - v10, v16) )
              continue;
          }
        }
        v16 = 0;
        break;
      }
      HeapFree(hHeap, 0, lpMem);
    }
    HeapFree(hHeap, 0, Srca);
  }
  return v16;
}

//----- (00409032) --------------------------------------------------------
int __thiscall sub_409032(int *this)
{
  unsigned __int8 *v1; // eax
  int v2; // eax
  int result; // eax

  v1 = (unsigned __int8 *)this[3];
  this[3] = (int)(v1 - 1);
  if ( !v1 )
  {
    v2 = *this + 2;
    this[2] = *(unsigned __int8 *)*this + (*(unsigned __int8 *)(*this + 1) << 8);
    *this = v2;
    this[3] = 15;
  }
  result = ((unsigned int)this[2] >> 15) & 1;
  this[2] *= 2;
  return result;
}

//----- (00409088) --------------------------------------------------------
int __cdecl sub_409088(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  int v4; // esi
  int *v5; // ecx
  int v6; // edi
  int v7; // esi
  int *v8; // ecx
  int v9; // eax
  char *v10; // eax
  int i; // ecx
  _BYTE *v12; // esi
  char v13; // dl
  _BYTE *v14; // ecx
  char v15; // al
  char *v16; // [esp+4h] [ebp-14h] BYREF
  _BYTE *v17; // [esp+8h] [ebp-10h]
  int v18; // [esp+10h] [ebp-8h]
  unsigned int v19; // [esp+14h] [ebp-4h]

  v19 = 1;
  if ( !a3 )
    return 0;
  v18 = 0;
  *a2 = *a1;
  v17 = a2 + 1;
  v16 = a1 + 1;
  if ( a3 > 1 )
  {
    do
    {
      if ( sub_409032((int *)&v16) )
      {
        v4 = 1;
        do
          v4 = sub_409032((int *)&v16) + 2 * v4;
        while ( sub_409032(v5) );
        v6 = v4 + 2;
        v7 = 1;
        do
          v7 = sub_409032((int *)&v16) + 2 * v7;
        while ( sub_409032(v8) );
        v9 = (unsigned __int8)*v16++;
        v10 = &v17[-v9 + 511 + -256 * v7];
        for ( i = v6; i > 0; *v12 = v13 )
        {
          v12 = v17++;
          v13 = *v10++;
          --i;
        }
        v19 += v6;
      }
      else
      {
        v14 = v17++;
        v15 = *v16++;
        ++v19;
        *v14 = v15;
      }
    }
    while ( v19 < a3 );
  }
  return v16 - a1;
}
// 4090DF: variable 'v5' is possibly undefined
// 4090F9: variable 'v8' is possibly undefined

//----- (0040915E) --------------------------------------------------------
int __usercall sub_40915E@<eax>(int result@<eax>, int a2)
{
  int v2; // ecx
  int v3; // ecx

  v2 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = v2 - 1;
  if ( !v2 )
  {
    **(_BYTE **)(result + 8) = *(_BYTE *)(result + 12);
    *(_BYTE *)(*(_DWORD *)(result + 8) + 1) = *(_BYTE *)(result + 13);
    v3 = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 8) = v3;
    *(_DWORD *)(result + 4) = v3 + 2;
    *(_DWORD *)(result + 16) = 15;
  }
  *(_DWORD *)(result + 12) = (a2 != 0) + 2 * *(_DWORD *)(result + 12);
  return result;
}

//----- (004091A2) --------------------------------------------------------
int __usercall sub_4091A2@<eax>(int a1@<eax>, unsigned int a2)
{
  unsigned int i; // esi
  int j; // eax
  int v4; // eax

  for ( i = a2 >> 1; (i & (i - 1)) != 0; i &= i - 1 )
    ;
  for ( j = sub_40915E(a1, a2 & i); ; j = sub_40915E(v4, a2 & i) )
  {
    i >>= 1;
    if ( !i )
      break;
    v4 = sub_40915E(j, 1);
  }
  return sub_40915E(j, 0);
}

//----- (004091E5) --------------------------------------------------------
int __thiscall sub_4091E5(unsigned __int8 *this)
{
  return (this[3] + 317 * (this[2] + 317 * this[1]) - 126555 * *this) & 0x3FFFF;
}

//----- (00409212) --------------------------------------------------------
int sub_409212()
{
  return 0x100000;
}

//----- (00409218) --------------------------------------------------------
int __cdecl sub_409218(unsigned int a1)
{
  return (a1 >> 3) + a1 + 64;
}

//----- (00409226) --------------------------------------------------------
int __cdecl sub_409226(unsigned __int8 *a1, unsigned __int8 *a2, int a3, void *a4)
{
  int result; // eax
  unsigned int v5; // esi
  unsigned __int8 *v6; // ebx
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // edx
  int v11; // eax
  unsigned __int8 *v12; // ecx
  unsigned int v13; // ebx
  unsigned __int8 v14; // al
  unsigned __int8 *v15; // ecx
  unsigned __int8 v16; // al
  unsigned __int8 *v17; // ecx
  unsigned __int8 *v18; // [esp+4h] [ebp-14h] BYREF
  unsigned __int8 *v19; // [esp+8h] [ebp-10h]
  _WORD *v20; // [esp+Ch] [ebp-Ch]
  int v21; // [esp+10h] [ebp-8h]
  int v22; // [esp+14h] [ebp-4h]

  result = 0;
  if ( a3 )
  {
    memset(a4, 0, 0x100000u);
    *a2 = *a1;
    v5 = a3 - 1;
    v6 = a1 + 1;
    v18 = a1 + 1;
    if ( a3 == 1 )
    {
      return 1;
    }
    else
    {
      v20 = a2 + 1;
      v19 = a2 + 3;
      v7 = 0;
      v21 = 0;
      v22 = 16;
      if ( v5 > 4 )
      {
        do
        {
          v8 = 0;
          while ( a1 < v6 )
          {
            v9 = sub_4091E5(a1);
            v10 = a1++;
            *((_DWORD *)a4 + v9) = v10;
          }
          v11 = *((_DWORD *)a4 + sub_4091E5(v6));
          if ( !v11 )
            goto LABEL_14;
          v12 = v6;
          do
          {
            if ( v12[v11 - (_DWORD)v6] != *v12 )
              break;
            ++v8;
            ++v12;
          }
          while ( v8 < v5 );
          if ( v8 > 3 )
          {
            v13 = (unsigned int)&v6[-v11 - 1];
            sub_40915E((int)&v18, 1);
            sub_4091A2((int)&v18, v8 - 2);
            sub_4091A2((int)&v18, (v13 >> 8) + 2);
            *v19++ = v13;
            v6 = &v18[v8];
            v5 -= v8;
          }
          else
          {
LABEL_14:
            sub_40915E((int)&v18, 0);
            v14 = *v18;
            v15 = v19++;
            v6 = v18 + 1;
            *v15 = v14;
            --v5;
          }
          v18 = v6;
        }
        while ( v5 > 4 );
        v7 = v21;
      }
      if ( v5 )
      {
        do
        {
          sub_40915E((int)&v18, 0);
          v16 = *v18;
          v17 = v19++;
          ++v18;
          --v5;
          *v17 = v16;
        }
        while ( v5 );
        v7 = v21;
      }
      *v20 = v7 << v22;
      return v19 - a2;
    }
  }
  return result;
}
// 4092B3: conditional instruction was optimized away because esi.4>=5u

//----- (00409379) --------------------------------------------------------
void __stdcall sub_409379(int a1)
{
  _DWORD *v1; // eax

  if ( a1 == -1 )
  {
    sub_40E672((_DWORD *)dword_413788);
  }
  else
  {
    v1 = sub_40E59A(dword_413788, a1);
    if ( v1 )
    {
      (*(void (__stdcall **)(_DWORD))*v1)(v1[1]);
      sub_40E5BF((size_t *)dword_413788, a1);
    }
  }
}
// 413788: using guessed type int dword_413788;

//----- (004093B7) --------------------------------------------------------
_DWORD *sub_4093B7()
{
  _DWORD *result; // eax

  result = sub_40E5FA(8, 16, (int)sub_409379);
  dword_413788 = (int)result;
  return result;
}
// 413788: using guessed type int dword_413788;

//----- (004093CB) --------------------------------------------------------
void sub_4093CB()
{
  sub_40E672((_DWORD *)dword_413788);
}
// 413788: using guessed type int dword_413788;

//----- (004093D7) --------------------------------------------------------
int *__stdcall sub_4093D7(int a1)
{
  int *result; // eax
  int v2; // edx
  int *v3; // ecx

  result = 0;
  if ( a1 == -1 )
  {
    if ( dword_41378C )
      return &dword_413588;
  }
  else
  {
    v2 = dword_41378C;
    if ( dword_41378C > 0 )
    {
      v3 = &dword_413588;
      do
      {
        if ( *v3 == a1 )
          result = v3;
        v3 += 2;
        --v2;
      }
      while ( v2 );
    }
  }
  return result;
}
// 413588: using guessed type int dword_413588;
// 41378C: using guessed type int dword_41378C;

//----- (00409411) --------------------------------------------------------
int *__stdcall sub_409411(int a1, int a2)
{
  int *result; // eax

  result = sub_4093D7(a1);
  if ( !result )
  {
    result = (int *)dword_41378C++;
    dword_413588[2 * (_DWORD)result] = a1;
    dword_41358C[2 * (_DWORD)result] = a2;
  }
  return result;
}
// 413588: using guessed type int dword_413588[];
// 41358C: using guessed type int dword_41358C[127];
// 41378C: using guessed type int dword_41378C;

//----- (00409441) --------------------------------------------------------
int __stdcall sub_409441(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int *v6; // eax

  v5 = -1;
  v6 = sub_4093D7(a5);
  if ( v6 )
    return (*(int (__stdcall **)(int, int, int, int))(v6[1] + 56))(a1, a2, a3, a4);
  return v5;
}

//----- (004094B0) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER __stdcall sub_4094B0(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
  LPTOP_LEVEL_EXCEPTION_FILTER result; // eax

  dword_413790 = (int)lpTopLevelExceptionFilter;
  if ( sub_409470 )
  {
    if ( ::lpTopLevelExceptionFilter )
    {
      return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_409470);
    }
    else
    {
      result = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_409470);
      ::lpTopLevelExceptionFilter = result;
    }
  }
  else
  {
    result = SetUnhandledExceptionFilter(::lpTopLevelExceptionFilter);
    ::lpTopLevelExceptionFilter = 0;
  }
  return result;
}
// 409470: using guessed type int __stdcall sub_409470(int);
// 413790: using guessed type int dword_413790;

//----- (00409520) --------------------------------------------------------
int __stdcall sub_409520(int **a1)
{
  int *v1; // ecx

  dword_412328 = **a1;
  dword_413AB4 = (*a1)[3];
  dword_413AB8 = dword_412001;
  v1 = *a1;
  if ( **a1 == -1073741819 && (unsigned int)v1[4] >= 2 )
    dword_413ABC = v1[6];
  else
    dword_413ABC = 0;
  dword_413AC0 = a1[1][44];
  dword_413AC4 = a1[1][41];
  dword_413AC8 = a1[1][43];
  dword_413ACC = a1[1][42];
  dword_413AD0 = a1[1][45];
  dword_413AD4 = a1[1][40];
  dword_413AD8 = a1[1][39];
  dword_413ADC = a1[1][49];
  dword_413AE0 = a1[1][48];
  return 1;
}
// 412001: using guessed type int dword_412001;
// 412328: using guessed type int dword_412328;
// 413AB4: using guessed type int dword_413AB4;
// 413AB8: using guessed type int dword_413AB8;
// 413ABC: using guessed type int dword_413ABC;
// 413AC0: using guessed type int dword_413AC0;
// 413AC4: using guessed type int dword_413AC4;
// 413AC8: using guessed type int dword_413AC8;
// 413ACC: using guessed type int dword_413ACC;
// 413AD0: using guessed type int dword_413AD0;
// 413AD4: using guessed type int dword_413AD4;
// 413AD8: using guessed type int dword_413AD8;
// 413ADC: using guessed type int dword_413ADC;
// 413AE0: using guessed type int dword_413AE0;

//----- (00409600) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_409600()
{
  LPTOP_LEVEL_EXCEPTION_FILTER result; // eax

  result = SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
  lpTopLevelExceptionFilter = 0;
  return result;
}

//----- (00409620) --------------------------------------------------------
char *__stdcall sub_409620(int a1, int a2)
{
  const char *v2; // esi
  int v3; // eax
  char *result; // eax
  char v5; // cl

  v2 = "Unknown error code";
  v3 = 0;
  while ( dword_4112C0[2 * v3] != a1 )
  {
    if ( (unsigned int)++v3 >= 0x14 )
      goto LABEL_6;
  }
  v2 = (&off_4112C4)[2 * v3];
LABEL_6:
  result = (char *)(sub_40F2C0(strlen(v2), a2) - v2);
  do
  {
    v5 = *v2;
    v2[(_DWORD)result] = *v2;
    ++v2;
  }
  while ( v5 );
  return result;
}
// 4112C0: using guessed type int dword_4112C0[];
// 4112C4: using guessed type char *off_4112C4;

//----- (00409680) --------------------------------------------------------
char *__stdcall sub_409680(int a1)
{
  return sub_409620(dword_412328, a1);
}
// 412328: using guessed type int dword_412328;

//----- (00409694) --------------------------------------------------------
_BYTE *__stdcall sub_409694(int a1, _DWORD *dwFlags, int *a3, int a4)
{
  _BYTE *v4; // eax
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  char v7; // al

  v4 = HeapAlloc(hHeap, 0, 0x34u);
  v5 = dwFlags;
  v6 = v4;
  if ( dwFlags )
  {
    v4[50] = 0;
  }
  else
  {
    v5 = HeapAlloc(hHeap, 0, 8u);
    v6[50] = 1;
  }
  *((_DWORD *)v6 + 4) = 0;
  *((_DWORD *)v6 + 2) = 0;
  *(_DWORD *)v6 = 0;
  *((_DWORD *)v6 + 1) = 0;
  *((_DWORD *)v6 + 3) = v5 + 1;
  *((_DWORD *)v6 + 10) = a1 + 8;
  *((_DWORD *)v6 + 6) = a3;
  v6[48] = 1;
  *((_DWORD *)v6 + 11) = a4;
  v7 = sub_40F46C(a3);
  *((_DWORD *)v6 + 8) = 0;
  v6[49] = v7;
  *((_DWORD *)v6 + 9) = v5;
  *v5 = v6;
  *((_DWORD *)v6 + 7) = sub_40E6B3(a1 + 8, 16, 0x10000, 4);
  return v6;
}

//----- (00409726) --------------------------------------------------------
void sub_409726()
{
  dword_413A30 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_409694;
  dword_413A3C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_409971;
  dword_413A48 = (int (__stdcall *)(_DWORD))sub_409745;
}
// 413A30: using guessed type int (__stdcall *dword_413A30)(_DWORD, _DWORD, _DWORD, _DWORD);
// 413A3C: using guessed type int (__stdcall *dword_413A3C)(_DWORD, _DWORD, _DWORD);
// 413A48: using guessed type int (__stdcall *dword_413A48)(_DWORD);

//----- (00409745) --------------------------------------------------------
void __stdcall sub_409745(LPVOID lpMem)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebp

  if ( lpMem )
  {
    sub_4099C0((int)lpMem);
    sub_40EA6F(*((char **)lpMem + 7));
    **((_DWORD **)lpMem + 9) = 0;
    *(_DWORD *)(*((_DWORD *)lpMem + 9) + 4) = 0;
    v1 = (_DWORD *)*((_DWORD *)lpMem + 8);
    if ( v1 )
    {
      do
      {
        v2 = (_DWORD *)*v1;
        HeapFree(hHeap, 0, v1);
        v1 = v2;
      }
      while ( v2 );
    }
    if ( *((_BYTE *)lpMem + 50) )
      HeapFree(hHeap, 0, *((LPVOID *)lpMem + 9));
    HeapFree(hHeap, 0, lpMem);
  }
}

//----- (004097AD) --------------------------------------------------------
_DWORD *__stdcall sub_4097AD(int *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax

  v1 = sub_40E7E9(a1[7]);
  v2 = v1;
  if ( !v1 )
    return 0;
  memset(v1, 0, a1[10]);
  if ( *((_BYTE *)a1 + 49) )
    sub_40F4B8((int)(v2 + 2), (int *)a1[6]);
  v4 = a1[2];
  ++a1[4];
  if ( v4 )
  {
    v2[1] = v4;
    *v2 = *(_DWORD *)a1[2];
    v6 = a1[2];
    if ( *(_DWORD *)v6 )
      *(_DWORD *)(*(_DWORD *)v6 + 4) = v2;
    *(_DWORD *)a1[2] = v2;
    ++a1[5];
    a1[2] = (int)v2;
  }
  else
  {
    if ( *a1 )
      *(_DWORD *)(*a1 + 4) = v2;
    v5 = *a1;
    a1[2] = (int)v2;
    *v2 = v5;
    v2[1] = 0;
    a1[5] = 0;
    *((_BYTE *)a1 + 48) = 0;
  }
  v7 = (_DWORD *)a1[2];
  if ( !v7[1] )
    *a1 = (int)v7;
  if ( !*v7 )
    a1[1] = (int)v7;
  *(_DWORD *)a1[3] = v7;
  return v2 + 2;
}

//----- (0040984B) --------------------------------------------------------
int __stdcall sub_40984B(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (00409855) --------------------------------------------------------
_DWORD *__stdcall sub_409855(int a1)
{
  _DWORD *result; // eax

  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 1;
  result = *(_DWORD **)(a1 + 12);
  *result = 0;
  return result;
}

//----- (0040986A) --------------------------------------------------------
int __stdcall sub_40986A(int *a1)
{
  int *v1; // eax
  int result; // eax

  v1 = (int *)a1[2];
  if ( v1 )
  {
    result = *v1;
    if ( result )
    {
      ++a1[5];
      a1[2] = result;
LABEL_5:
      result += 8;
    }
  }
  else
  {
    result = *a1;
    a1[5] = 0;
    a1[2] = result;
    if ( result )
      goto LABEL_5;
  }
  *(_DWORD *)a1[3] = a1[2];
  return result;
}

//----- (0040989E) --------------------------------------------------------
_DWORD *__stdcall sub_40989E(int a1, int a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // esi
  _DWORD *v5; // eax
  int v6; // esi
  int v7; // esi
  int v8; // edi
  int i; // edx
  int v10; // edx
  _DWORD *v11; // edx

  v2 = *(_DWORD *)(a1 + 20);
  v3 = a2;
  *(_DWORD *)(a1 + 20) = a2;
  if ( a2 < 0 || (v4 = *(_DWORD *)(a1 + 16), a2 >= v4) )
  {
    v5 = 0;
  }
  else if ( *(_BYTE *)(a1 + 48) )
  {
    if ( a2 >= v4 / 2 )
    {
      v5 = *(_DWORD **)(a1 + 4);
      v6 = v4 - a2;
      while ( 1 )
      {
        --v6;
        if ( !v5 || !v6 )
          break;
        v5 = (_DWORD *)v5[1];
      }
    }
    else
    {
      v5 = *(_DWORD **)a1;
      while ( v5 && v3 )
      {
        v5 = (_DWORD *)*v5;
        --v3;
      }
    }
  }
  else
  {
    v5 = *(_DWORD **)(a1 + 8);
    if ( a2 <= v2 )
    {
      v10 = v2 - a2;
      if ( v10 < a2 )
      {
        while ( v5 && v10 )
        {
          v5 = (_DWORD *)v5[1];
          --v10;
        }
      }
      else
      {
        v5 = *(_DWORD **)a1;
        while ( v5 && v3 )
        {
          v5 = (_DWORD *)*v5;
          --v3;
        }
      }
    }
    else
    {
      v7 = v4 - a2;
      v8 = a2 - v2;
      if ( a2 - v2 < v7 )
      {
        while ( v5 && v8 )
        {
          v5 = (_DWORD *)*v5;
          --v8;
        }
      }
      else
      {
        v5 = *(_DWORD **)(a1 + 4);
        for ( i = v7 - 1; v5 && i; --i )
          v5 = (_DWORD *)v5[1];
      }
    }
  }
  v11 = *(_DWORD **)(a1 + 12);
  *(_DWORD *)(a1 + 8) = v5;
  *v11 = v5;
  if ( v5 )
  {
    *(_BYTE *)(a1 + 48) = 0;
    return v5 + 2;
  }
  else
  {
    *(_BYTE *)(a1 + 48) = 1;
    return 0;
  }
}

//----- (00409971) --------------------------------------------------------
int __stdcall sub_409971(int **a1, int *a2, int a3)
{
  int result; // eax
  int *i; // esi
  _BYTE *v5; // eax

  result = 0;
  if ( a1 && a2 )
  {
    if ( a3 )
      sub_4099C0((int)a2);
    for ( i = *a1; i; i = (int *)*i )
    {
      v5 = sub_4097AD(a2);
      sub_40F63D(v5, (signed int)(a1[10] - 2), (char *)a1[6], (_BYTE *)i + 8);
    }
    return 1;
  }
  return result;
}

//----- (004099C0) --------------------------------------------------------
int __stdcall sub_4099C0(int a1)
{
  int *v1; // ebp
  _DWORD *v2; // esi
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int result; // eax

  v1 = *(int **)(a1 + 24);
  v2 = *(_DWORD **)a1;
  if ( v1 )
  {
    while ( 1 )
    {
      v3 = (int)v2;
      if ( !v2 )
        break;
      v2 = (_DWORD *)*v2;
      sub_40F91A(v3 + 8, v1);
      sub_40E948(*(_DWORD *)(a1 + 28), v3);
    }
  }
  else
  {
    while ( 1 )
    {
      v4 = (int)v2;
      if ( !v2 )
        break;
      v2 = (_DWORD *)*v2;
      sub_40E948(*(_DWORD *)(a1 + 28), v4);
    }
  }
  v5 = *(_DWORD **)(a1 + 12);
  result = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *v5 = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 48) = 1;
  return result;
}

//----- (00409A1E) --------------------------------------------------------
int __cdecl sub_409A1E(_DWORD *a1)
{
  int result; // eax

  a1[5] = 10;
  a1[3] = HeapAlloc(hHeap, 8u, 0x28u);
  result = dword_413AE4;
  a1[1] = 0;
  a1[2] = result;
  return result;
}
// 413AE4: using guessed type int dword_413AE4;

//----- (00409A4B) --------------------------------------------------------
BOOL __cdecl sub_409A4B(int a1)
{
  return HeapFree(hHeap, 0, *(LPVOID *)(a1 + 12));
}

//----- (00409A61) --------------------------------------------------------
BOOL sub_409A61()
{
  INITCOMMONCONTROLSEX picce; // [esp+0h] [ebp-8h] BYREF

  InitializeCriticalSection(&stru_413AE8);
  dword_413AE4 = (int)GetStockObject(17);
  dword_413B00 = (int)sub_40E5FA(32, 50, (int)sub_40A2EA);
  dword_413B04 = (int)sub_40E64A(0x50u, (void (__cdecl *)(LPVOID))sub_409A1E, (int)sub_409A4B);
  picce.dwSize = 8;
  picce.dwICC = 2888;
  return InitCommonControlsEx(&picce);
}
// 413AE4: using guessed type int dword_413AE4;
// 413B00: using guessed type int dword_413B00;
// 413B04: using guessed type int dword_413B04;

//----- (00409AD1) --------------------------------------------------------
HWND sub_409AD1()
{
  HWND result; // eax

  result = *(HWND *)(sub_40E643(dword_413B04) + 24);
  if ( result )
    return (HWND)DestroyWindow(result);
  return result;
}
// 413B04: using guessed type int dword_413B04;

//----- (00409AEB) --------------------------------------------------------
int *__stdcall sub_409AEB(HWND *hdc, int *a2, int *a3)
{
  int v4; // edi
  int v5; // ebx
  void *v6; // eax
  HGDIOBJ v7; // eax
  LONG right; // edi
  LONG bottom; // ebx
  int *result; // eax
  HWND v11; // [esp-4h] [ebp-2Ch]
  struct tagRECT rc; // [esp+Ch] [ebp-1Ch] BYREF
  HGDIOBJ h; // [esp+1Ch] [ebp-Ch]
  int cchText; // [esp+20h] [ebp-8h]
  LPSTR lpString; // [esp+24h] [ebp-4h]
  HDC hdca; // [esp+30h] [ebp+8h]

  v4 = 0;
  v5 = 0;
  hdca = GetDC(*hdc);
  v6 = (void *)SendMessageA(*hdc, 0x31u, 0, 0);
  v7 = SelectObject(hdca, v6);
  v11 = *hdc;
  h = v7;
  cchText = GetWindowTextLengthA(v11);
  lpString = (LPSTR)HeapAlloc(hHeap, 0, cchText + 1);
  if ( lpString )
  {
    GetWindowTextA(*hdc, lpString, cchText + 1);
    SetRect(&rc, 0, 0, 0, 0);
    DrawTextA(hdca, lpString, cchText, &rc, 0x400u);
    right = rc.right;
    bottom = rc.bottom;
    if ( (GetWindowLongA(*hdc, -20) & 0x200) != 0 )
    {
      v4 = right + 2 * GetSystemMetrics(45);
      v5 = bottom + 2 * GetSystemMetrics(46);
    }
    else
    {
      v4 = right + 2;
      v5 = bottom + 2;
    }
    HeapFree(hHeap, 0, lpString);
  }
  SelectObject(hdca, h);
  ReleaseDC(*hdc, hdca);
  *a2 = v4;
  result = a3;
  *a3 = v5;
  return result;
}

//----- (00409BE6) --------------------------------------------------------
int __stdcall sub_409BE6(COLORREF *a1, int a2, int a3, HDC hdc, int a5)
{
  int SysColorBrush; // ebp
  COLORREF v6; // eax
  COLORREF SysColor; // eax

  SysColorBrush = -791621423;
  if ( a3 == 312 )
  {
    v6 = a1[5];
    if ( v6 != -1 )
    {
      SetTextColor(hdc, v6);
      if ( a1[4] == -1 )
      {
        SysColor = GetSysColor(15);
        SetBkColor(hdc, SysColor);
        SysColorBrush = (int)GetSysColorBrush(15);
      }
    }
    if ( a1[4] != -1 )
    {
      SetBkColor(hdc, a1[4]);
      return a1[6];
    }
  }
  return SysColorBrush;
}

//----- (00409C4B) --------------------------------------------------------
HWND __stdcall sub_409C4B(
        _DWORD *dwNewLong,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        LPCSTR lpWindowName,
        unsigned int a7)
{
  HWND *v7; // ebx
  HWND Window; // esi
  _DWORD *v9; // eax

  v7 = (HWND *)sub_40E643(dword_413B04);
  if ( !dword_41383C )
  {
    dword_41383C = 1;
    memset(&dword_413798, 0, 0xA4u);
    dword_413798 = 3;
    dword_41379C = 164;
    dword_413828 = (int)sub_409AEB;
    dword_4137A0 = (int)sub_409BE6;
    dword_413810 = (int)sub_40A31C;
    dword_413814 = (int)sub_40A376;
    dword_4137A4 = (int)sub_40A39C;
  }
  if ( !lpWindowName )
    lpWindowName = (LPCSTR)&unk_411002;
  Window = CreateWindowExA(
             (a7 >> 8) & 0x200,
             "Static",
             lpWindowName,
             a7 | 0x50020080,
             X,
             Y,
             nWidth,
             nHeight,
             *v7,
             (HMENU)0xFFFFFFFF,
             hInstance,
             0);
  if ( Window )
  {
    v9 = sub_40E515(dword_413B00, (int)dwNewLong);
    v9[5] = -1;
    v9[4] = -1;
    return sub_40A46D(dwNewLong, v9, Window, (int)&dword_413798);
  }
  return Window;
}
// 413798: using guessed type int dword_413798;
// 41379C: using guessed type int dword_41379C;
// 4137A0: using guessed type int dword_4137A0;
// 4137A4: using guessed type int dword_4137A4;
// 413810: using guessed type int dword_413810;
// 413814: using guessed type int dword_413814;
// 413828: using guessed type int dword_413828;
// 41383C: using guessed type int dword_41383C;
// 413B00: using guessed type int dword_413B00;
// 413B04: using guessed type int dword_413B04;

//----- (00409D43) --------------------------------------------------------
HWND __stdcall sub_409D43(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName)
{
  return sub_409C4B(dwNewLong, X, Y, nWidth, nHeight, lpWindowName, 0);
}

//----- (00409D63) --------------------------------------------------------
int __stdcall sub_409D63(int a1, int a2, int a3, HDC hdc, int a5)
{
  int v5; // ebx
  COLORREF v6; // eax
  COLORREF SysColor; // eax
  HBRUSH SysColorBrush; // eax
  COLORREF v9; // eax

  v5 = -791621423;
  if ( a3 == 307 || a3 == 312 && IsWindowEnabled(*(HWND *)a1) )
  {
    v6 = *(_DWORD *)(a1 + 20);
    if ( v6 != -1 )
    {
      SetTextColor(hdc, v6);
      if ( *(_DWORD *)(a1 + 16) == -1 )
      {
        if ( a3 == 312 )
        {
          SysColor = GetSysColor(15);
          SetBkColor(hdc, SysColor);
          SysColorBrush = GetSysColorBrush(15);
        }
        else
        {
          v9 = GetSysColor(5);
          SetBkColor(hdc, v9);
          SysColorBrush = GetSysColorBrush(5);
        }
        v5 = (int)SysColorBrush;
      }
    }
    if ( *(_DWORD *)(a1 + 16) != -1 )
    {
      SetBkColor(hdc, *(_DWORD *)(a1 + 16));
      return *(_DWORD *)(a1 + 24);
    }
  }
  return v5;
}

//----- (00409DF8) --------------------------------------------------------
LRESULT __stdcall sub_409DF8(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( Msg == 7 )
  {
    sub_40A51B(hWnd, 14000);
  }
  else if ( Msg == 8 )
  {
    sub_40A51B(hWnd, 14001);
  }
  return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
}

//----- (00409E36) --------------------------------------------------------
LRESULT __stdcall sub_409E36(HWND *a1, int a2)
{
  if ( a2 == 1 )
    return SendMessageA(*a1, 0xD5u, 0, 0);
  else
    return 0;
}

//----- (00409E59) --------------------------------------------------------
LRESULT __stdcall sub_409E59(HWND *a1, int a2, int wParam)
{
  LRESULT result; // eax

  result = a2 - 1;
  if ( a2 == 1 )
  {
    if ( wParam < 1 )
      wParam = 1;
    return SendMessageA(*a1, 0xC5u, wParam, 0);
  }
  return result;
}

//----- (00409E84) --------------------------------------------------------
int __stdcall sub_409E84(HWND *hdc, struct tagSIZE *a2, int a3)
{
  void *v4; // eax
  struct tagSIZE psizl; // [esp+Ch] [ebp-Ch] BYREF
  HGDIOBJ h; // [esp+14h] [ebp-4h]
  HDC hdca; // [esp+20h] [ebp+8h]

  hdca = GetDC(*hdc);
  v4 = (void *)SendMessageA(*hdc, 0x31u, 0, 0);
  h = SelectObject(hdca, v4);
  GetTextExtentPoint32A(hdca, "Hg", 2, &psizl);
  psizl.cx = 2 * GetSystemMetrics(45);
  psizl.cy += 2 * GetSystemMetrics(46);
  if ( psizl.cy < 20 )
    psizl.cy = 20;
  SelectObject(hdca, h);
  ReleaseDC(*hdc, hdca);
  *a2 = psizl;
  return a3;
}

//----- (00409F1C) --------------------------------------------------------
HWND __stdcall sub_409F1C(
        _DWORD *dwNewLong,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        LPCSTR lpWindowName,
        unsigned int a7)
{
  HWND *v7; // esi
  HWND Window; // edi
  _DWORD *v9; // esi
  LRESULT (__stdcall *v10)(HWND, UINT, WPARAM, LPARAM); // eax

  v7 = (HWND *)sub_40E643(dword_413B04);
  if ( !dword_4138EC )
  {
    memset(&dword_413848, 0, 0xA4u);
    dword_413848 = 2;
    dword_41384C = 164;
    dword_413850 = (int)sub_409D63;
    dword_4138C0 = (int)sub_40A31C;
    dword_4138C4 = (int)sub_40A376;
    dword_413854 = (int)sub_40A39C;
    dword_4138B4 = (int)sub_409E59;
    dword_4138B0 = (int)sub_409E36;
    dword_4138D8 = (int)sub_409E84;
    dword_4138EC = 1;
  }
  if ( !lpWindowName )
    lpWindowName = (LPCSTR)&unk_411002;
  Window = CreateWindowExA(
             ~(unsigned __int16)(a7 >> 8) & 0x200,
             "Edit",
             lpWindowName,
             a7 | 0x50030080,
             X,
             Y,
             nWidth,
             nHeight,
             *v7,
             (HMENU)0xFFFFFFFF,
             hInstance,
             0);
  if ( Window )
  {
    v9 = sub_40E515(dword_413B00, (int)dwNewLong);
    v10 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SetWindowLongA(Window, -4, (LONG)sub_409DF8);
    v9[5] = -1;
    v9[4] = -1;
    lpPrevWndFunc = v10;
    return sub_40A46D(dwNewLong, v9, Window, (int)&dword_413848);
  }
  return Window;
}
// 413848: using guessed type int dword_413848;
// 41384C: using guessed type int dword_41384C;
// 413850: using guessed type int dword_413850;
// 413854: using guessed type int dword_413854;
// 4138B0: using guessed type int dword_4138B0;
// 4138B4: using guessed type int dword_4138B4;
// 4138C0: using guessed type int dword_4138C0;
// 4138C4: using guessed type int dword_4138C4;
// 4138D8: using guessed type int dword_4138D8;
// 4138EC: using guessed type int dword_4138EC;
// 413B00: using guessed type int dword_413B00;
// 413B04: using guessed type int dword_413B04;

//----- (0040A03F) --------------------------------------------------------
LRESULT __stdcall sub_40A03F(HWND *a1, int a2)
{
  if ( a2 )
    return SendMessageA(*a1, 0xF1u, 1u, 0);
  else
    return SendMessageA(*a1, 0xF1u, 0, 0);
}

//----- (0040A061) --------------------------------------------------------
int __stdcall sub_40A061(HWND *a1)
{
  return SendMessageA(*a1, 0xF0u, 0, 0) & 1;
}

//----- (0040A07C) --------------------------------------------------------
int __stdcall sub_40A07C(HWND *hdc, struct tagSIZE *a2, int a3)
{
  void *v4; // eax
  HGDIOBJ v5; // eax
  int WindowTextLengthA; // edi
  CHAR *v7; // eax
  HWND v9; // [esp-4h] [ebp-20h]
  HWND v10; // [esp-4h] [ebp-20h]
  struct tagSIZE psizl; // [esp+Ch] [ebp-10h] BYREF
  HGDIOBJ h; // [esp+14h] [ebp-8h]
  LPCSTR lpString; // [esp+18h] [ebp-4h]
  HDC hdca; // [esp+24h] [ebp+8h]

  v9 = *hdc;
  psizl.cx = 0;
  psizl.cy = 0;
  hdca = GetDC(v9);
  v4 = (void *)SendMessageA(*hdc, 0x31u, 0, 0);
  v5 = SelectObject(hdca, v4);
  v10 = *hdc;
  h = v5;
  WindowTextLengthA = GetWindowTextLengthA(v10);
  v7 = (CHAR *)HeapAlloc(hHeap, 0, WindowTextLengthA + 1);
  lpString = v7;
  if ( v7 )
  {
    GetWindowTextA(*hdc, v7, WindowTextLengthA + 1);
    GetTextExtentPoint32A(hdca, lpString, WindowTextLengthA, &psizl);
    psizl.cx += 2 * GetSystemMetrics(45) + 10;
    psizl.cy += 2 * GetSystemMetrics(46);
    if ( psizl.cy < 24 )
      psizl.cy = 24;
    HeapFree(hHeap, 0, (LPVOID)lpString);
  }
  SelectObject(hdca, h);
  ReleaseDC(*hdc, hdca);
  *a2 = psizl;
  return a3;
}

//----- (0040A15C) --------------------------------------------------------
HWND __stdcall sub_40A15C(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName, int a7)
{
  HWND Window; // esi
  _DWORD *v8; // eax
  HWND *v10; // [esp+Ch] [ebp-4h]

  v10 = (HWND *)sub_40E643(dword_413B04);
  if ( !dword_413994 )
  {
    memset(&dword_4138F0, 0, 0xA4u);
    dword_4138F0 = 1;
    dword_4138F4 = 164;
    dword_413900 = (int)sub_40A061;
    dword_413904 = (int)sub_40A03F;
    dword_413980 = (int)sub_40A07C;
    dword_413994 = 1;
  }
  if ( !lpWindowName )
    lpWindowName = (LPCSTR)&unk_411002;
  Window = CreateWindowExA(
             0,
             "Button",
             lpWindowName,
             a7 | 0x50030000,
             X,
             Y,
             nWidth,
             nHeight,
             *v10,
             (HMENU)0xFFFFFFFF,
             hInstance,
             0);
  if ( Window )
  {
    v8 = sub_40E515(dword_413B00, (int)dwNewLong);
    return sub_40A46D(dwNewLong, v8, Window, (int)&dword_4138F0);
  }
  return Window;
}
// 4138F0: using guessed type int dword_4138F0;
// 4138F4: using guessed type int dword_4138F4;
// 413900: using guessed type int dword_413900;
// 413904: using guessed type int dword_413904;
// 413980: using guessed type int dword_413980;
// 413994: using guessed type int dword_413994;
// 413B00: using guessed type int dword_413B00;
// 413B04: using guessed type int dword_413B04;

//----- (0040A229) --------------------------------------------------------
HWND __stdcall sub_40A229(_DWORD *dwNewLong, int X, int Y, int nWidth, int nHeight, LPCSTR lpWindowName)
{
  return sub_40A15C(dwNewLong, X, Y, nWidth, nHeight, lpWindowName, 0);
}

//----- (0040A249) --------------------------------------------------------
HWND __stdcall sub_40A249(int a1)
{
  HWND result; // eax
  int (__stdcall *v2)(HWND); // ecx

  if ( a1 == -1 )
    return SetFocus(0);
  result = (HWND)sub_40E59A(dword_413B00, a1);
  if ( result )
  {
    v2 = *(int (__stdcall **)(HWND))(*((_DWORD *)result + 1) + 148);
    if ( v2 )
      return (HWND)v2(result);
    else
      return SetFocus(*(HWND *)result);
  }
  return result;
}
// 413B00: using guessed type int dword_413B00;

//----- (0040A284) --------------------------------------------------------
const CHAR *__stdcall sub_40A284(int a1, int a2)
{
  const CHAR *result; // eax
  HWND *v3; // edi
  int (__stdcall *v4)(HWND *, int); // eax
  int WindowTextLengthA; // esi
  char *v6; // ebx
  size_t v7; // eax

  result = (const CHAR *)sub_40E59A(dword_413B00, a1);
  v3 = (HWND *)result;
  if ( result )
  {
    v4 = *(int (__stdcall **)(HWND *, int))(*((_DWORD *)result + 1) + 24);
    if ( v4 )
    {
      return (const CHAR *)v4(v3, a2);
    }
    else
    {
      WindowTextLengthA = GetWindowTextLengthA(*v3);
      v6 = sub_40F2C0(WindowTextLengthA, a2);
      *v6 = 0;
      GetWindowTextA(*v3, v6, WindowTextLengthA + 1);
      v7 = strlen(v6);
      return sub_40F3E0(WindowTextLengthA - v7);
    }
  }
  return result;
}
// 413B00: using guessed type int dword_413B00;

//----- (0040A2EA) --------------------------------------------------------
void __stdcall sub_40A2EA(int a1)
{
  HWND *v1; // eax

  if ( a1 == -1 )
  {
    sub_40E672((_DWORD *)dword_413B00);
  }
  else
  {
    v1 = (HWND *)sub_40E59A(dword_413B00, a1);
    if ( v1 )
      DestroyWindow(*v1);
  }
}
// 413B00: using guessed type int dword_413B00;

//----- (0040A31C) --------------------------------------------------------
BOOL __stdcall sub_40A31C(int a1, int a2, COLORREF color)
{
  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 20) = color;
  }
  else if ( a2 == 2 )
  {
    if ( *(_DWORD *)(a1 + 24) )
      sub_40A5C0(*(void **)(a1 + 24));
    if ( color == -1 )
      *(_DWORD *)(a1 + 24) = 0;
    else
      *(_DWORD *)(a1 + 24) = sub_40A553(color);
    *(_DWORD *)(a1 + 16) = color;
  }
  return RedrawWindow(*(HWND *)a1, 0, 0, 0x407u);
}

//----- (0040A376) --------------------------------------------------------
int __stdcall sub_40A376(int a1, int a2)
{
  if ( a2 == 1 )
    return *(_DWORD *)(a1 + 20);
  if ( a2 == 2 )
    return *(_DWORD *)(a1 + 16);
  return -1;
}

//----- (0040A39C) --------------------------------------------------------
void __stdcall sub_40A39C(int a1)
{
  if ( *(_DWORD *)(a1 + 24) )
    sub_40A5C0(*(void **)(a1 + 24));
}

//----- (0040A3B0) --------------------------------------------------------
LRESULT __stdcall sub_40A3B0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int WindowLongA; // eax
  int v5; // ebx
  _DWORD *v6; // esi
  void (__stdcall *v7)(_DWORD *); // eax
  LPARAM lParama; // [esp+1Ch] [ebp+14h]

  WindowLongA = GetWindowLongA(hWnd, -12);
  v5 = WindowLongA;
  if ( WindowLongA == -1 )
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  v6 = sub_40E59A(dword_413B00, WindowLongA);
  lParama = CallWindowProcA((WNDPROC)v6[3], hWnd, Msg, wParam, lParam);
  if ( Msg == 130 )
  {
    v7 = *(void (__stdcall **)(_DWORD *))(v6[1] + 12);
    if ( v7 )
      v7(v6);
    RemovePropA(hWnd, "PB_ID");
    if ( RemovePropA(hWnd, "PB_DropAccept") )
      RevokeDragDrop(hWnd);
    SetWindowLongA(hWnd, -12, -1);
    sub_40D1BB(13100, v5, -1, -1);
    sub_40E5BF((size_t *)dword_413B00, v5);
  }
  return lParama;
}
// 413B00: using guessed type int dword_413B00;

//----- (0040A46D) --------------------------------------------------------
HWND __stdcall sub_40A46D(_DWORD *dwNewLong, _DWORD *a2, HWND hWnd, int a4)
{
  HWND result; // eax
  int v5; // [esp+Ch] [ebp-4h]

  v5 = sub_40E643(dword_413B04);
  if ( dwNewLong == (_DWORD *)-1 )
    dwNewLong = a2;
  *a2 = hWnd;
  a2[1] = a4;
  a2[3] = SetWindowLongA(hWnd, -4, (LONG)sub_40A3B0);
  SetWindowLongA(hWnd, -12, (LONG)dwNewLong);
  SetPropA(hWnd, "PB_ID", dwNewLong);
  SendMessageA(hWnd, 0x30u, *(_DWORD *)(v5 + 8), 1);
  *(_DWORD *)(v5 + 4) = 0;
  result = (HWND)a2;
  if ( dwNewLong != a2 )
    return hWnd;
  return result;
}
// 413B04: using guessed type int dword_413B04;

//----- (0040A4E8) --------------------------------------------------------
HWND __stdcall sub_40A4E8(HWND hWnd)
{
  HWND v1; // ebx
  HWND i; // eax
  HWND v3; // esi

  v1 = hWnd;
  for ( i = GetParent(hWnd); ; i = GetParent(v3) )
  {
    v3 = i;
    if ( !i || GetPropA(v1, "PB_WindowID") )
      break;
    v1 = v3;
  }
  return v1;
}

//----- (0040A51B) --------------------------------------------------------
void __stdcall sub_40A51B(HWND hWnd, int a2)
{
  HWND v2; // eax
  int WindowLongA; // eax
  char *v4; // [esp-8h] [ebp-8h]

  v2 = sub_40A4E8(hWnd);
  v4 = (char *)GetPropA(v2, "PB_WindowID") - 1;
  WindowLongA = GetWindowLongA(hWnd, -12);
  sub_40D077(13100, WindowLongA, (int)v4, a2);
}

//----- (0040A553) --------------------------------------------------------
HBRUSH __stdcall sub_40A553(COLORREF color)
{
  HBRUSH v1; // edi
  _DWORD *i; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  HBRUSH SolidBrush; // eax

  v1 = 0;
  EnterCriticalSection(&stru_413AE8);
  for ( i = (_DWORD *)dword_413998; i; i = (_DWORD *)*i )
  {
    if ( i[2] == color )
    {
      v1 = (HBRUSH)i[3];
      ++i[4];
      if ( v1 )
        goto LABEL_9;
      break;
    }
  }
  v3 = sub_40EC40((int)&dword_413998, 0x14u);
  v4 = v3;
  if ( v3 )
  {
    *v3 = color;
    SolidBrush = CreateSolidBrush(color);
    v4[1] = SolidBrush;
    v4[2] = 1;
    v1 = SolidBrush;
  }
LABEL_9:
  LeaveCriticalSection(&stru_413AE8);
  return v1;
}
// 413998: using guessed type int dword_413998;

//----- (0040A5C0) --------------------------------------------------------
void __stdcall sub_40A5C0(void *a1)
{
  _DWORD *i; // esi
  void *v2; // eax

  EnterCriticalSection(&stru_413AE8);
  for ( i = (_DWORD *)dword_413998; i; i = (_DWORD *)*i )
  {
    v2 = (void *)i[3];
    if ( v2 == a1 )
    {
      if ( i[4]-- == 1 )
      {
        DeleteObject(v2);
        sub_40EC6D(&dword_413998, (int)(i + 2));
      }
      break;
    }
  }
  LeaveCriticalSection(&stru_413AE8);
}
// 413998: using guessed type int dword_413998;

//----- (0040A60F) --------------------------------------------------------
int sub_40A60F()
{
  int v0; // ebx
  BOOL v1; // esi
  struct _OSVERSIONINFOA v4; // [esp+Ch] [ebp-B8h] BYREF
  char v5; // [esp+A6h] [ebp-1Eh]
  struct _OSVERSIONINFOA VersionInformation; // [esp+A8h] [ebp-1Ch] BYREF

  v0 = 200;
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
    return v0;
  if ( VersionInformation.dwPlatformId == 1 )
  {
    if ( !VersionInformation.dwMinorVersion )
      return 10;
    if ( VersionInformation.dwMinorVersion == 10 )
      return 30;
    if ( VersionInformation.dwMinorVersion != 90 )
      return v0;
    return 40;
  }
  if ( VersionInformation.dwPlatformId != 2 )
    return v0;
  v1 = 0;
  v4.dwOSVersionInfoSize = 156;
  if ( GetVersionExA(&v4) )
    v1 = v5 == 1;
  if ( VersionInformation.dwMajorVersion == 3 )
    return 5;
  if ( VersionInformation.dwMajorVersion == 4 )
    return 20;
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion == 6 )
    {
      if ( VersionInformation.dwMinorVersion )
      {
        if ( VersionInformation.dwMinorVersion == 1 )
        {
          return v1 ? 80 : 85;
        }
        else if ( VersionInformation.dwMinorVersion == 2 )
        {
          return v1 ? 90 : 95;
        }
      }
      else
      {
        return v1 ? 70 : 75;
      }
    }
    return v0;
  }
  switch ( VersionInformation.dwMinorVersion )
  {
    case 0u:
      return 50;
    case 1u:
      return 60;
    case 2u:
      return v1 ? 60 : 65;
  }
  return v0;
}

//----- (0040A702) --------------------------------------------------------
void __stdcall sub_40A702(DWORD a1)
{
  if ( !dword_41399C )
  {
    timeBeginPeriod(1u);
    dword_41399C = 1;
  }
  Sleep(a1);
}
// 41399C: using guessed type int dword_41399C;

//----- (0040A723) --------------------------------------------------------
void __stdcall sub_40A723(int a1)
{
  HWND *v1; // eax
  HWND *v2; // esi
  HWND Window; // eax
  HWND v4; // eax
  HWND v5; // esi
  char Buffer[256]; // [esp+0h] [ebp-100h] BYREF

  if ( a1 == -1 )
  {
    sub_40E672((_DWORD *)dword_413B08);
  }
  else
  {
    v1 = (HWND *)sub_40E59A(dword_413B08, a1);
    v2 = v1;
    if ( v1 )
    {
      Window = GetWindow(*v1, 4u);
      if ( Window && !v2[7] )
        SetActiveWindow(Window);
      RemovePropA(*v2, "PB_WindowID");
      if ( RemovePropA(*v2, "PB_DropAccept") )
        RevokeDragDrop(*v2);
      v4 = v2[7];
      if ( v4 )
      {
        SendMessageA(v4, 0x221u, (WPARAM)*v2, 0);
      }
      else
      {
        DestroyWindow(*v2);
        sprintf(Buffer, "WindowClass_%d", a1);
        UnregisterClassA(Buffer, hInstance);
      }
      if ( v2[1] )
      {
        HeapFree(hHeap, 0, v2[1]);
        DestroyAcceleratorTable((HACCEL)v2[2]);
      }
      v5 = v2[6];
      if ( v5 )
        DeleteObject(v5);
      sub_40D236(a1);
      sub_40D282(a1);
      sub_40E5BF((size_t *)dword_413B08, a1);
    }
  }
}
// 413B08: using guessed type int dword_413B08;

//----- (0040A839) --------------------------------------------------------
void sub_40A839()
{
  sub_40E643(dword_413B0C);
  sub_40E672((_DWORD *)dword_413B08);
}
// 413B08: using guessed type int dword_413B08;
// 413B0C: using guessed type int dword_413B0C;

//----- (0040A850) --------------------------------------------------------
HCURSOR sub_40A850()
{
  HCURSOR result; // eax

  dword_413B08 = (int)sub_40E5FA(52, 16, (int)sub_40A723);
  dword_413B0C = (int)sub_40E64A(0x14u, 0, 0);
  dword_413B10 = (int)sub_40E64A(0x5Cu, 0, 0);
  dword_413B14 = (int)LoadIconA(hInstance, (LPCSTR)1);
  result = LoadCursorA(0, (LPCSTR)0x7F00);
  dword_413B18 = (int)result;
  return result;
}
// 413B08: using guessed type int dword_413B08;
// 413B0C: using guessed type int dword_413B0C;
// 413B10: using guessed type int dword_413B10;
// 413B14: using guessed type int dword_413B14;
// 413B18: using guessed type int dword_413B18;

//----- (0040A8A8) --------------------------------------------------------
HWND *__stdcall sub_40A8A8(HWND *a1, int X, int Y, int a4, int a5, LPCSTR lpWindowName, int a7, HWND hWndParent)
{
  int v8; // edi
  HWND *v9; // eax
  HWND *v10; // esi
  unsigned int v11; // ebx
  unsigned int v12; // ebx
  HWND Window; // eax
  int v14; // edi
  _WORD *v15; // eax
  HACCEL AcceleratorTableA; // eax
  bool v17; // zf
  char Buffer[256]; // [esp+Ch] [ebp-144h] BYREF
  WNDCLASSA WndClass; // [esp+10Ch] [ebp-44h] BYREF
  struct tagRECT Rect; // [esp+134h] [ebp-1Ch] BYREF
  int v22; // [esp+144h] [ebp-Ch]
  int v23; // [esp+148h] [ebp-8h]
  DWORD dwExStyle; // [esp+14Ch] [ebp-4h]

  v8 = 0;
  dwExStyle = 0;
  v23 = 1;
  v9 = (HWND *)sub_40E515(dword_413B08, (int)a1);
  v10 = v9;
  if ( a1 == (HWND *)-1 && (a1 = v9, v9 == (HWND *)-1) )
    sprintf(Buffer, "WindowClass_%d", -1);
  else
    sprintf(Buffer, "WindowClass_%d", a1);
  if ( !lpWindowName )
    lpWindowName = (LPCSTR)&unk_411002;
  memset(&WndClass, 0, sizeof(WndClass));
  WndClass.cbWndExtra = 0;
  WndClass.hInstance = hInstance;
  WndClass.hIcon = (HICON)dword_413B14;
  WndClass.hCursor = (HCURSOR)dword_413B18;
  WndClass.lpszClassName = Buffer;
  WndClass.style = 8;
  WndClass.lpfnWndProc = (WNDPROC)sub_40B300;
  WndClass.hbrBackground = (HBRUSH)16;
  RegisterClassA(&WndClass);
  if ( (a7 & 8) != 0 )
    v23 = 0;
  v11 = a7 & 0xFFFFFFF7;
  if ( (a7 & 0xEFFFFFF4) == 0 )
    v11 = a7 & 0xFF3FFFF7 | 0xC00000;
  if ( (v11 & 0x10000000) != 0 )
  {
    v11 &= ~0x10000000u;
    v22 = 0;
  }
  else
  {
    v22 = 1;
  }
  if ( (v11 & 0x2000000) != 0 )
    v8 = 1;
  if ( (v11 & 4) != 0 )
  {
    v11 = v11 & 0xDE3CFFFF | 0xC00000;
    dwExStyle = 128;
  }
  Rect.left = 0;
  Rect.top = 0;
  Rect.right = a4;
  Rect.bottom = a5;
  AdjustWindowRectEx(&Rect, v11 & 0xFFFFFFF8, 0, dwExStyle);
  if ( X == -65535 || Y == -65535 && (v11 & 3) == 0 )
  {
    X = 0x80000000;
    Y = 0x80000000;
  }
  v12 = v11 & 0xFDFFFFF8;
  Window = CreateWindowExA(
             dwExStyle,
             Buffer,
             lpWindowName,
             v12,
             X,
             Y,
             Rect.right - Rect.left,
             Rect.bottom - Rect.top,
             hWndParent,
             0,
             hInstance,
             0);
  *v10 = Window;
  if ( Window )
  {
    if ( (a7 & 3) != 0 )
      sub_40B396(Window, a7, hWndParent);
    if ( v22 )
    {
      if ( (v12 & 0x1000000) != 0 )
      {
        v14 = v8 != 0 ? 8 : 3;
      }
      else if ( (v12 & 0x20000000) != 0 )
      {
        v14 = v8 != 0 ? 7 : 2;
      }
      else
      {
        v14 = v8 != 0 ? 4 : 1;
      }
      ShowWindow(*v10, v14);
    }
    v10[11] = (HWND)((v12 & 0x21000000) != 0);
    v10[4] = (HWND)2;
    v15 = HeapAlloc(hHeap, 0, 0xCu);
    v10[1] = (HWND)v15;
    v15[1] = 9;
    *((_WORD *)v10[1] + 2) = -1535;
    *(_BYTE *)v10[1] = 3;
    *((_WORD *)v10[1] + 4) = 9;
    *((_WORD *)v10[1] + 5) = -1534;
    *((_BYTE *)v10[1] + 6) = 7;
    AcceleratorTableA = CreateAcceleratorTableA((LPACCEL)v10[1], (int)v10[4]);
    v10[5] = HWND_MESSAGE|0x2;
    v10[7] = 0;
    v17 = v23 == 0;
    v10[2] = (HWND)AcceleratorTableA;
    if ( !v17 )
      sub_40FDEE(*v10);
    SetPropA(*v10, "PB_WindowID", (char *)a1 + 1);
    if ( a1 == v10 )
      return a1;
    else
      return (HWND *)*v10;
  }
  else
  {
    UnregisterClassA(Buffer, hInstance);
    sub_40E5BF((size_t *)dword_413B08, (int)a1);
    return 0;
  }
}
// 413B08: using guessed type int dword_413B08;
// 413B14: using guessed type int dword_413B14;
// 413B18: using guessed type int dword_413B18;

//----- (0040AB60) --------------------------------------------------------
HWND *__stdcall sub_40AB60(HWND *a1, int X, int Y, int a4, int a5, LPCSTR lpWindowName, int a7)
{
  return sub_40A8A8(a1, X, Y, a4, a5, lpWindowName, a7, 0);
}

//----- (0040AB83) --------------------------------------------------------
int __stdcall sub_40AB83(int a1, int a2, __int16 a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v5; // ecx
  int v6; // eax
  unsigned __int8 *v7; // edi
  LPVOID v8; // eax
  int v10; // [esp+4h] [ebp-4h]

  v10 = 3;
  v3 = sub_40E59A(dword_413B08, a1);
  v4 = v3;
  if ( v3 )
  {
    if ( (a2 & 0x10000) != 0 )
      v10 = 7;
    if ( (a2 & 0x20000) != 0 )
      v10 |= 8u;
    if ( (a2 & 0x40000) != 0 )
      v10 |= 0x10u;
    v5 = v3[4];
    v6 = 0;
    if ( v5 <= 0 )
    {
LABEL_13:
      v4[4] = v5 + 1;
      if ( v5 )
        v8 = HeapReAlloc(hHeap, 0, (LPVOID)v4[1], 6 * (v5 + 1));
      else
        v8 = HeapAlloc(hHeap, 0, 6u);
      v4[1] = v8;
      *(_WORD *)(6 * v4[4] + v4[1] - 4) = a2;
      *(_WORD *)(6 * v4[4] + v4[1] - 2) = a3;
      *(_BYTE *)(6 * v4[4] + v4[1] - 6) = v10;
    }
    else
    {
      v7 = (unsigned __int8 *)v4[1];
      while ( (unsigned __int16)a2 != *((unsigned __int16 *)v7 + 1) || v10 != *v7 )
      {
        ++v6;
        v7 += 6;
        if ( v6 >= v5 )
          goto LABEL_13;
      }
      *(_WORD *)(6 * v6 + v4[1] + 4) = a3;
    }
    if ( v4[2] )
      DestroyAcceleratorTable((HACCEL)v4[2]);
    v4[2] = CreateAcceleratorTableA((LPACCEL)v4[1], v4[4]);
  }
  return v4[2];
}
// 413B08: using guessed type int dword_413B08;

//----- (0040AC9E) --------------------------------------------------------
int __stdcall sub_40AC9E(DWORD dwMilliseconds)
{
  WPARAM *v1; // esi
  int result; // eax
  HWND ActiveWindow; // ebx
  HACCEL v4; // eax
  struct tagMSG Msg; // [esp+Ch] [ebp-1Ch] BYREF

  v1 = (WPARAM *)sub_40E643(dword_413B0C);
  result = sub_40D095();
  if ( result )
  {
    *v1 = 0;
    v1[1] = 0;
  }
  else
  {
    if ( dwMilliseconds == -1 )
    {
      GetMessageA(&Msg, 0, 0, 0);
    }
    else if ( !PeekMessageA(&Msg, 0, 0, 0, 3u)
           && (!dwMilliseconds
            || MsgWaitForMultipleObjects(0, 0, 0, dwMilliseconds, 0x5FFu) == 258
            || !PeekMessageA(&Msg, 0, 0, 0, 3u)) )
    {
      return 0;
    }
    ActiveWindow = GetActiveWindow();
    v4 = (HACCEL)sub_40B661(ActiveWindow);
    if ( v4 && TranslateAcceleratorA(ActiveWindow, v4, &Msg) )
    {
      if ( ActiveWindow )
        sub_40B61A(ActiveWindow, 1);
    }
    else
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
    result = Msg.message;
    *v1 = Msg.wParam;
    v1[1] = Msg.lParam;
  }
  v1[2] = *v1;
  v1[3] = v1[1];
  return result;
}
// 413B0C: using guessed type int dword_413B0C;

//----- (0040AD87) --------------------------------------------------------
int sub_40AD87()
{
  return sub_40AC9E(0xFFFFFFFF);
}

//----- (0040AD8F) --------------------------------------------------------
int __cdecl sub_40AD8F(HWND hWnd, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  HANDLE PropA; // edi
  _DWORD *v7; // eax
  int (__stdcall *v8)(_DWORD *, int, int, int, int); // ecx

  v5 = -791621423;
  if ( hWnd )
  {
    PropA = GetPropA(hWnd, "PB_ID");
    if ( PropA == (HANDLE)GetWindowLongA(hWnd, -12) )
    {
      v7 = sub_40E59A(dword_413B00, (int)PropA);
      if ( v7 )
      {
        v8 = *(int (__stdcall **)(_DWORD *, int, int, int, int))(v7[1] + 8);
        if ( v8 )
          return v8(v7, a2, a3, a4, a5);
      }
    }
  }
  return v5;
}
// 413B00: using guessed type int dword_413B00;

//----- (0040ADEF) --------------------------------------------------------
BOOL __stdcall sub_40ADEF(HWND hWnd, LPARAM a2)
{
  SendMessageA(hWnd, 0x15u, 0, 0);
  return 1;
}

//----- (0040AE05) --------------------------------------------------------
int __stdcall sub_40AE05(HWND hWndParent, unsigned int a2, HDC hDC, HWND a4)
{
  HWND *v4; // esi
  HANDLE PropA; // edi
  HDC v6; // edi
  int (__stdcall *v7)(HWND, unsigned int, HDC, HWND); // eax
  int result; // eax
  HWND v9; // eax
  HWND Focus; // eax
  char *v11; // edi
  int (__stdcall *v12)(HDC, HWND); // esi
  int v14; // eax
  HWND v15; // ecx
  char WindowLongA; // al
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // [esp-Ch] [ebp-34h]
  int v22; // [esp-8h] [ebp-30h]
  int v23; // [esp-8h] [ebp-30h]
  int v24; // [esp-8h] [ebp-30h]
  int v25; // [esp-8h] [ebp-30h]
  struct tagRECT Rect; // [esp+Ch] [ebp-1Ch] BYREF
  int v27; // [esp+1Ch] [ebp-Ch]
  HWND hWnd; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]
  int hDCa; // [esp+38h] [ebp+10h]

  v4 = 0;
  v27 = sub_40E643(dword_413B0C);
  hWnd = hWndParent;
  if ( !hWndParent )
    goto LABEL_6;
  do
  {
    PropA = GetPropA(hWnd, "PB_WindowID");
    if ( PropA )
      break;
    hWnd = GetParent(hWnd);
  }
  while ( hWnd );
  if ( hWnd )
  {
    v29 = (int)PropA - 1;
    v4 = (HWND *)sub_40E59A(dword_413B08, (int)PropA - 1);
  }
  else
  {
LABEL_6:
    v29 = -1;
  }
  v6 = hDC;
  if ( (!v4 || (v7 = (int (__stdcall *)(HWND, unsigned int, HDC, HWND))v4[3]) == 0)
    && (v7 = *(int (__stdcall **)(HWND, unsigned int, HDC, HWND))(v27 + 16)) == 0
    || (result = v7(hWndParent, a2, hDC, a4), result == -522133279) )
  {
    hDCa = -791621423;
    if ( a2 <= 0x111 )
    {
      if ( a2 != 273 )
      {
        if ( a2 <= 0x14 )
        {
          if ( a2 == 20 )
          {
            if ( v4 )
            {
              if ( v4[6] )
              {
                GetClientRect(hWndParent, &Rect);
                FillRect(v6, &Rect, (HBRUSH)v4[6]);
                hDCa = 1;
              }
              else if ( *v4 == hWndParent )
              {
                v12 = (int (__stdcall *)(HDC, HWND))v4[8];
                if ( v12 )
                  hDCa = v12(v6, hWndParent);
              }
            }
            sub_40D077(13115, 0, v29, 0);
            return hDCa;
          }
          if ( a2 == 3 )
          {
            if ( v4 && hWndParent == *v4 )
              sub_40D077(13117, v29, v29, 0);
            return 0;
          }
          if ( a2 != 5 )
          {
            if ( a2 == 6 )
            {
              if ( (_WORD)v6 )
              {
                v9 = (HWND)GetPropA(hWndParent, "PB_Focus");
                if ( v9 )
                  SetFocus(v9);
                sub_40D077(13104, 0, v29, 0);
              }
              else
              {
                Focus = GetFocus();
                SetPropA(hWndParent, "PB_Focus", Focus);
                sub_40B61A(hWndParent, 0);
                sub_40D077(13114, 0, v29, 0);
              }
              return 1;
            }
            if ( a2 == 16 )
            {
              if ( v4 )
              {
                if ( hWndParent == *v4 )
                  sub_40D077(13116, v29, v29, 0);
              }
              return 0;
            }
            return hDCa;
          }
          if ( hWnd == hWndParent )
          {
            if ( v29 == -1 )
              return hDCa;
            if ( v6 )
            {
              v11 = (char *)v6 - 1;
              if ( v11 )
              {
                if ( v11 != (char *)1 )
                {
                  v22 = v29;
LABEL_40:
                  sub_40D077(13118, 0, v22, 0);
                  return 0;
                }
                v4[11] = (HWND)1;
                sub_40D077(13108, 0, v29, 0);
                sub_40D077(13118, 0, v29, 0);
              }
              else
              {
                v23 = v29;
                v4[11] = (HWND)1;
                sub_40D077(13107, 0, v23, 0);
              }
              return 0;
            }
            if ( v4[11] )
            {
              v24 = v29;
              v4[11] = 0;
              sub_40D077(13109, 0, v24, 0);
            }
            v22 = v29;
            goto LABEL_40;
          }
          return 1;
        }
        if ( a2 == 21 )
        {
          if ( v4 && !v4[7] )
            EnumChildWindows(hWndParent, sub_40ADEF, 0);
          return hDCa;
        }
        if ( a2 == 36 )
        {
          if ( !v4 )
            return hDCa;
          v14 = *((unsigned __int16 *)v4 + 18);
          if ( (_WORD)v14 )
          {
            v15 = a4;
            *((_DWORD *)a4 + 6) = v14;
          }
          else
          {
            WindowLongA = GetWindowLongA(hWndParent, -20);
            v15 = a4;
            if ( WindowLongA < 0 )
              *((_DWORD *)a4 + 6) = 1;
          }
          v17 = *((unsigned __int16 *)v4 + 19);
          if ( (_WORD)v17 )
            *((_DWORD *)v15 + 7) = v17;
          v18 = *((unsigned __int16 *)v4 + 20);
          if ( (_WORD)v18 )
            *((_DWORD *)v15 + 8) = v18;
          v19 = *((unsigned __int16 *)v4 + 21);
          if ( (_WORD)v19 )
            *((_DWORD *)v15 + 9) = v19;
          return 0;
        }
        if ( a2 != 78 )
        {
          if ( a2 != 130 )
            return hDCa;
          RemovePropA(hWndParent, "PB_Focus");
          return 1;
        }
        return sub_40AD8F(*(HWND *)a4, (int)hWndParent, 78, (int)v6, (int)a4);
      }
      if ( sub_40AD8F(a4, (int)hWndParent, 273, (int)v6, (int)a4) == -791621423 )
      {
        if ( a4 )
        {
          v20 = GetWindowLongA(a4, -12);
          if ( v20 == -10000 )
          {
            v6 = (HDC)(unsigned __int16)v6;
LABEL_79:
            v25 = v29;
            v21 = (int)v6;
LABEL_86:
            sub_40D077(13101, v21, v25, 0);
            return 0;
          }
          sub_40D077(13100, v20, v29, (unsigned int)v6 >> 16);
        }
        else
        {
          if ( !HIWORD(v6) )
            goto LABEL_79;
          if ( (_WORD)v6 != 0xFA01 )
          {
            if ( (_WORD)v6 == 0xFA02 )
            {
              sub_40B512(1);
              return 0;
            }
            v25 = v29;
            v21 = (unsigned __int16)v6;
            goto LABEL_86;
          }
          sub_40B512(0);
        }
      }
      return 0;
    }
    if ( a2 > 0x202 )
    {
      switch ( a2 )
      {
        case 0x203u:
          sub_40D077(13113, 0, v29, 0);
          break;
        case 0x205u:
          sub_40D077(13111, 0, v29, 0);
          break;
        case 0x30D5u:
          if ( a4 == (HWND)513 )
          {
            sub_40D077(13102, (int)v6, v29, 0);
          }
          else if ( a4 == (HWND)515 )
          {
            sub_40D077(13102, (int)v6, v29, 2);
          }
          else if ( a4 == (HWND)516 )
          {
            sub_40D077(13102, (int)v6, v29, 1);
          }
          else if ( a4 == (HWND)518 )
          {
            sub_40D077(13102, (int)v6, v29, 3);
          }
          PostMessageA(hWndParent, 0, 0, 0);
          return 0;
        case 0x3340u:
          return sub_40AD8F(a4, (int)hWndParent, a2, (int)v6, (int)a4);
        default:
          return hDCa;
      }
    }
    else
    {
      if ( a2 != 514 )
      {
        if ( a2 == 275 )
        {
          if ( !v4 )
            return hDCa;
          sub_40D077(13110, (int)v6, v29, 0);
          return 0;
        }
        if ( a2 <= 0x113 || a2 > 0x115 && (a2 <= 0x132 || a2 > 0x135 && a2 != 312) )
          return hDCa;
        return sub_40AD8F(a4, (int)hWndParent, a2, (int)v6, (int)a4);
      }
      sub_40D077(13112, 0, v29, 0);
    }
    return 0;
  }
  return result;
}
// 413B08: using guessed type int dword_413B08;
// 413B0C: using guessed type int dword_413B0C;

//----- (0040B300) --------------------------------------------------------
int __stdcall sub_40B300(HWND hWnd, UINT uMsg, HDC wParam, HWND lParam)
{
  HWND PropA; // eax
  int result; // eax
  int wParama; // [esp+1Ch] [ebp+10h]

  wParama = sub_40AE05(hWnd, uMsg, wParam, lParam);
  if ( uMsg == 5 || (PropA = (HWND)GetPropA(hWnd, "PB_MDI_Gadget")) == 0 )
  {
    SetLastError(0);
    result = wParama;
    if ( wParama == -791621423 )
      return DefWindowProcA(hWnd, uMsg, (WPARAM)wParam, (LPARAM)lParam);
  }
  else if ( wParama == -791621423 || uMsg == 288 || uMsg == 7 )
  {
    return DefFrameProcA(hWnd, PropA, uMsg, (WPARAM)wParam, (LPARAM)lParam);
  }
  else if ( uMsg != 273 || lParam )
  {
    return wParama;
  }
  else
  {
    return DefFrameProcA(hWnd, PropA, 0x111u, (WPARAM)wParam, 0);
  }
  return result;
}

//----- (0040B396) --------------------------------------------------------
BOOL __stdcall sub_40B396(HWND hWnd, int a2, HWND a3)
{
  int v3; // esi
  int v4; // edi
  int SystemMetrics; // eax
  int v6; // esi
  int v7; // eax
  int v8; // eax
  HWND ActiveWindow; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-20h] BYREF
  struct tagRECT v12; // [esp+1Ch] [ebp-10h] BYREF

  GetWindowRect(hWnd, &Rect);
  v3 = Rect.right - Rect.left;
  v4 = Rect.bottom - Rect.top;
  if ( (a2 & 1) != 0 )
  {
    SystemMetrics = GetSystemMetrics(0);
    if ( v3 > SystemMetrics )
      v3 = SystemMetrics;
    v6 = (SystemMetrics - v3) / 2;
    v7 = GetSystemMetrics(1);
    if ( v4 > v7 )
      v4 = v7;
    v8 = (v7 - v4) / 2;
  }
  else if ( (a2 & 2) != 0 && ((ActiveWindow = a3) != 0 || (ActiveWindow = GetActiveWindow()) != 0) )
  {
    GetWindowRect(ActiveWindow, &v12);
    v8 = v12.top + (v12.bottom - v12.top - v4) / 2;
    v6 = v12.left + (v12.right - v12.left - v3) / 2;
    if ( v6 < 0 )
      v6 = 0;
    if ( v8 < 0 )
      v8 = 0;
  }
  else
  {
    v6 = a2;
    v8 = a2;
  }
  return SetWindowPos(hWnd, 0, v6, v8, 0, 0, 0x15u);
}

//----- (0040B457) --------------------------------------------------------
BOOL __stdcall sub_40B457(HWND hWnd, LPARAM a2)
{
  int v2; // ebx

  v2 = 1;
  if ( IsWindowEnabled(hWnd) && IsWindowVisible(hWnd) && (GetWindowLongA(hWnd, -16) & 0x10000) != 0 )
  {
    if ( *(_DWORD *)(a2 + 8) )
    {
      SetFocus(hWnd);
      v2 = 0;
LABEL_9:
      *(_DWORD *)(a2 + 8) = v2;
      return v2;
    }
    if ( *(_DWORD *)a2 )
    {
      if ( *(HWND *)a2 == hWnd )
        goto LABEL_9;
    }
    else
    {
      SetFocus(hWnd);
      return 0;
    }
  }
  return v2;
}

//----- (0040B4BC) --------------------------------------------------------
BOOL __stdcall sub_40B4BC(HWND hWnd, LPARAM a2)
{
  int v2; // edi

  v2 = 1;
  if ( IsWindowEnabled(hWnd) && IsWindowVisible(hWnd) && (GetWindowLongA(hWnd, -16) & 0x10000) != 0 )
  {
    if ( *(HWND *)a2 == hWnd && *(_DWORD *)(a2 + 4) )
    {
      SetFocus(*(HWND *)(a2 + 4));
      *(_DWORD *)(a2 + 12) = 1;
      v2 = 0;
    }
    *(_DWORD *)(a2 + 4) = hWnd;
  }
  return v2;
}

//----- (0040B512) --------------------------------------------------------
HWND __stdcall sub_40B512(int a1)
{
  HWND Focus; // edi
  HWND i; // esi
  HWND result; // eax
  CHAR ClassName[52]; // [esp+Ch] [ebp-48h] BYREF
  LPARAM lParam; // [esp+40h] [ebp-14h] BYREF
  HWND hWnd; // [esp+44h] [ebp-10h]
  int v7; // [esp+48h] [ebp-Ch]
  int v8; // [esp+4Ch] [ebp-8h]
  HWND hWndParent; // [esp+50h] [ebp-4h]

  hWndParent = GetActiveWindow();
  Focus = GetFocus();
  hWnd = 0;
  v7 = 0;
  v8 = 0;
  if ( IsChild(hWndParent, Focus) )
  {
    lParam = (LPARAM)Focus;
    for ( i = Focus; i; i = GetParent(i) )
    {
      GetClassNameA(i, ClassName, 50);
      if ( !strcmp(ClassName, "MDI_ChildClass") )
      {
        hWndParent = i;
        if ( Focus == i )
          lParam = 0;
        continue;
      }
      if ( !strcmp(ClassName, "ComboBoxEx32") )
      {
        if ( (GetWindowLongA(i, -16) & 1) != 0 )
          goto LABEL_10;
      }
      else if ( !strcmp(ClassName, "SysIPAddress32") )
      {
LABEL_10:
        lParam = (LPARAM)i;
      }
    }
  }
  else
  {
    lParam = 0;
  }
  if ( a1 )
  {
    result = (HWND)EnumChildWindows(hWndParent, sub_40B4BC, (LPARAM)&lParam);
    if ( !v8 )
    {
      if ( hWnd )
        return SetFocus(hWnd);
    }
  }
  else
  {
    result = (HWND)EnumChildWindows(hWndParent, sub_40B457, (LPARAM)&lParam);
    if ( v7 )
      return (HWND)EnumChildWindows(hWndParent, sub_40B457, (LPARAM)&lParam);
  }
  return result;
}

//----- (0040B61A) --------------------------------------------------------
int __stdcall sub_40B61A(HWND hWnd, int a2)
{
  int result; // eax

  result = SendMessageA(hWnd, 0x129u, 0, 0);
  if ( a2 )
  {
    if ( (result & 3) != 0 )
      return SendMessageA(hWnd, 0x128u, 0x30002u, 0);
  }
  else
  {
    result &= 3u;
    if ( (_BYTE)result != 3 )
      return SendMessageA(hWnd, 0x128u, 0x30001u, 0);
  }
  return result;
}

//----- (0040B661) --------------------------------------------------------
int __stdcall sub_40B661(HWND hWnd)
{
  HWND Focus; // edi
  HANDLE PropA; // esi
  _DWORD *v4; // eax
  DWORD dwProcessId; // [esp+Ch] [ebp-Ch] BYREF
  CHAR ClassName[8]; // [esp+10h] [ebp-8h] BYREF

  Focus = GetFocus();
  if ( Focus )
  {
    if ( (GetKeyState(9) & 0x80) != 0
      && (GetKeyState(17) & 0x80) == 0
      && (GetKeyState(16) & 0x80) == 0
      && (GetKeyState(18) & 0x80) == 0 )
    {
      GetClassNameA(Focus, ClassName, 5);
      if ( !strncmp(ClassName, "Rich", 4u) && (SendMessageA(Focus, 0x44Eu, 0, 0) & 0x800) == 0 )
        return 0;
    }
  }
  if ( hWnd && ((GetKeyState(17) & 0x80) != 0 || (GetKeyState(16) & 0x80) != 0 || (GetKeyState(18) & 0x80) != 0) )
    sub_40B61A(hWnd, 1);
  if ( (!Focus || !GetPropA(Focus, "PB_Hotkey"))
    && (PropA = GetPropA(hWnd, "PB_WindowID")) != 0
    && GetWindowThreadProcessId(hWnd, &dwProcessId)
    && dwProcessId == GetCurrentProcessId()
    && (v4 = sub_40E59A(dword_413B08, (int)PropA - 1)) != 0 )
  {
    return v4[2];
  }
  else
  {
    return 0;
  }
}
// 413B08: using guessed type int dword_413B08;

//----- (0040B768) --------------------------------------------------------
BOOL sub_40B768()
{
  HMODULE LibraryA; // eax
  HMODULE v1; // ebx
  HMODULE v2; // eax
  HMODULE v3; // esi
  BOOL (__stdcall *IsAppThemed)(); // eax
  int v6[5]; // [esp+Ch] [ebp-20h] BYREF
  FARPROC DllGetVersion; // [esp+20h] [ebp-Ch]
  int v8; // [esp+24h] [ebp-8h]
  BOOL v9; // [esp+28h] [ebp-4h]

  v9 = 0;
  v8 = 1;
  LibraryA = LoadLibraryA("COMCTL32.DLL");
  v1 = LibraryA;
  if ( LibraryA )
  {
    DllGetVersion = GetProcAddress(LibraryA, "DllGetVersion");
    if ( DllGetVersion )
    {
      memset(v6, 0, sizeof(v6));
      v6[0] = 20;
      if ( ((int (__stdcall *)(int *))DllGetVersion)(v6) >= 0 )
        v8 = LOWORD(v6[2]) | (LOWORD(v6[1]) << 16);
    }
    FreeLibrary(v1);
  }
  v2 = LoadLibraryA("uxtheme.dll");
  v3 = v2;
  if ( v2 )
  {
    IsAppThemed = GetProcAddress(v2, "IsAppThemed");
    if ( IsAppThemed )
      v9 = IsAppThemed() && v8 >= 393216;
    FreeLibrary(v3);
  }
  return v9;
}

//----- (0040B821) --------------------------------------------------------
BOOL sub_40B821()
{
  HMODULE LibraryA; // eax
  BOOL result; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+4h] [ebp-1Ch] BYREF

  LibraryA = LoadLibraryA("msimg32.dll");
  hLibModule = LibraryA;
  if ( LibraryA )
    AlphaBlend = (BOOL (__stdcall *)(HDC, int, int, int, int, HDC, int, int, int, int, BLENDFUNCTION))GetProcAddress(LibraryA, "AlphaBlend");
  dword_4139D8 = 1;
  VersionInformation.dwOSVersionInfoSize = 148;
  result = GetVersionExA(&VersionInformation);
  if ( result )
  {
    if ( VersionInformation.dwPlatformId == 1 )
      goto LABEL_12;
    if ( VersionInformation.dwPlatformId != 2 )
      goto LABEL_10;
    if ( VersionInformation.dwMajorVersion < 5 )
    {
LABEL_12:
      dword_4139D8 = 0;
      return result;
    }
    if ( VersionInformation.dwMajorVersion == 5 && !VersionInformation.dwMinorVersion )
      dword_4139D8 = 0;
  }
LABEL_10:
  if ( dword_4139D8 )
  {
    result = sub_40B768();
    if ( !result )
      goto LABEL_12;
  }
  return result;
}
// 4139D8: using guessed type int dword_4139D8;

//----- (0040B8AF) --------------------------------------------------------
BOOL sub_40B8AF()
{
  return FreeLibrary(hLibModule);
}

//----- (0040B9B8) --------------------------------------------------------
void __cdecl sub_40B9B8(double a1, double a2)
{
  dbl_4139D0 = (6.0 - (a1 + a1)) / 6.0;
  dbl_4139C8 = (a1 * 12.0 - 18.0 + a2 * 6.0) / 6.0;
  dbl_4139C0 = (12.0 - a1 * 9.0 - a2 * 6.0) / 6.0;
  dbl_4139B8 = (a1 * 8.0 + a2 * 24.0) / 6.0;
  dbl_4139B0 = (a1 * -12.0 - a2 * 48.0) / 6.0;
  dbl_4139A8 = (a1 * 6.0 + a2 * 30.0) / 6.0;
  dbl_4139A0 = (-a1 - a2 * 6.0) / 6.0;
}
// 4139A0: using guessed type double dbl_4139A0;
// 4139A8: using guessed type double dbl_4139A8;
// 4139B0: using guessed type double dbl_4139B0;
// 4139B8: using guessed type double dbl_4139B8;
// 4139C0: using guessed type double dbl_4139C0;
// 4139C8: using guessed type double dbl_4139C8;
// 4139D0: using guessed type double dbl_4139D0;

//----- (0040BA67) --------------------------------------------------------
double __cdecl sub_40BA67(double X)
{
  double v1; // st7

  v1 = fabs(X);
  if ( v1 < 1.0 )
    return v1 * v1 * (dbl_4139C0 * v1 + dbl_4139C8) + dbl_4139D0;
  if ( v1 >= 2.0 )
    return 0.0;
  return v1 * ((dbl_4139A0 * v1 + dbl_4139A8) * v1 + dbl_4139B0) + dbl_4139B8;
}
// 4139A0: using guessed type double dbl_4139A0;
// 4139A8: using guessed type double dbl_4139A8;
// 4139B0: using guessed type double dbl_4139B0;
// 4139B8: using guessed type double dbl_4139B8;
// 4139C0: using guessed type double dbl_4139C0;
// 4139C8: using guessed type double dbl_4139C8;
// 4139D0: using guessed type double dbl_4139D0;

//----- (0040BAD0) --------------------------------------------------------
double **__cdecl sub_40BAD0(int a1, int a2, int a3, int *a4)
{
  double v4; // st7
  double v5; // st6
  double v6; // st7
  double **v7; // eax
  void **v8; // edi
  int v9; // ebx
  double **v10; // ebx
  double v11; // st7
  int v12; // edi
  double v13; // st7
  double v14; // st7
  int v15; // esi
  double v16; // st7
  double *v17; // ebx
  double v18; // st7
  double v19; // st7
  double v20; // st7
  double v21; // st7
  double *v22; // eax
  int v23; // esi
  double X; // [esp+8h] [ebp-54h]
  double v26; // [esp+24h] [ebp-38h]
  double v27; // [esp+24h] [ebp-38h]
  double v28; // [esp+24h] [ebp-38h]
  double v29; // [esp+34h] [ebp-28h]
  double v30; // [esp+3Ch] [ebp-20h]
  double v31; // [esp+44h] [ebp-18h]
  double **v32; // [esp+4Ch] [ebp-10h]
  int v33; // [esp+50h] [ebp-Ch]
  double **v34; // [esp+54h] [ebp-8h]
  int v35; // [esp+58h] [ebp-4h]
  int v36; // [esp+68h] [ebp+Ch]

  v4 = 1.0;
  v31 = 1.0;
  if ( a1 )
  {
    sub_40B9B8(0.3333333333333333, 0.3333333333333333);
    v4 = 2.0;
  }
  v5 = (double)a2 / (double)a3;
  if ( v5 >= 1.0 )
  {
    v30 = v4;
    v6 = ceil(v4);
  }
  else
  {
    v30 = v4 / v5;
    v31 = v5;
    v6 = ceil(v30);
  }
  v33 = 2 * sub_40FA10(v6) + 1;
  *a4 = a2;
  v7 = (double **)malloc(12 * a2);
  v32 = v7;
  if ( a2 > 0 )
  {
    v8 = (void **)v7;
    v9 = a2;
    do
    {
      *v8 = malloc(8 * v33);
      v8 += 3;
      --v9;
    }
    while ( v9 );
  }
  v35 = 0;
  if ( a2 > 0 )
  {
    v10 = v32;
    v34 = v32;
    do
    {
      v29 = (double)v35 / v5 + 0.5 / v5 - 0.5;
      v26 = v29 - v30;
      v11 = floor(v26);
      if ( sub_40FA10(v11) >= 0 )
      {
        v13 = floor(v26);
        v12 = sub_40FA10(v13);
      }
      else
      {
        v12 = 0;
      }
      v27 = v29 + v30;
      v14 = ceil(v27);
      v15 = a3 - 1;
      if ( sub_40FA10(v14) < a3 - 1 )
      {
        v16 = ceil(v27);
        v15 = sub_40FA10(v16);
      }
      if ( v15 - v12 + 1 > v33 )
      {
        if ( v12 >= a3 )
          --v15;
        else
          ++v12;
      }
      v10[1] = (double *)v12;
      v28 = 0.0;
      v10[2] = (double *)v15;
      v36 = v12;
      if ( v12 <= v15 )
      {
        v17 = *v10;
        do
        {
          X = (v29 - (double)v36) * v31;
          if ( a1 )
          {
            v19 = sub_40BA67(X);
          }
          else
          {
            v18 = fabs(X);
            if ( v18 >= 1.0 )
              v19 = 0.0;
            else
              v19 = 1.0 - v18;
          }
          v20 = v19 * v31;
          ++v36;
          *v17++ = v20;
          v21 = v20 + v28;
          v28 = v21;
        }
        while ( v36 <= v15 );
        if ( v21 > 0.0 && 1.0 != v21 )
        {
          v22 = *v34;
          v23 = v15 - v12 + 1;
          do
          {
            *v22 = *v22 / v21;
            ++v22;
            --v23;
          }
          while ( v23 );
        }
      }
      ++v35;
      v10 = v34 + 3;
      v34 += 3;
    }
    while ( v35 < *a4 );
  }
  return v32;
}

//----- (0040BCEA) --------------------------------------------------------
void __usercall sub_40BCEA(int a1@<eax>, void *Block)
{
  int v2; // edi
  void **v3; // esi

  v2 = a1;
  if ( a1 > 0 )
  {
    v3 = (void **)Block;
    do
    {
      free(*v3);
      v3 += 3;
      --v2;
    }
    while ( v2 );
  }
  free(Block);
}

//----- (0040BD29) --------------------------------------------------------
void __usercall sub_40BD29(int a1@<eax>, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi
  int v8; // eax
  int *v9; // ebx
  int v10; // edi
  int v11; // ecx
  double *v12; // edx
  int v13; // eax
  double v14; // st6
  int v15; // edi
  double *v16; // esi
  int i; // edi
  int v18; // eax
  double v19[4]; // [esp+8h] [ebp-4Ch] BYREF
  int v20; // [esp+28h] [ebp-2Ch] BYREF
  int v21; // [esp+2Ch] [ebp-28h]
  int v22; // [esp+30h] [ebp-24h]
  int v23; // [esp+34h] [ebp-20h]
  double **v24; // [esp+38h] [ebp-1Ch]
  int v25; // [esp+3Ch] [ebp-18h]
  int v26; // [esp+40h] [ebp-14h]
  int v27; // [esp+44h] [ebp-10h]
  int v28; // [esp+48h] [ebp-Ch]
  int v29; // [esp+4Ch] [ebp-8h]
  int v30; // [esp+50h] [ebp-4h]

  v24 = sub_40BAD0(1, a5, a3, &v20);
  if ( v24 )
  {
    if ( a1 > 0 )
    {
      v7 = a6 * a5;
      v8 = a6 * a3;
      v28 = a4;
      v22 = a6 * a5;
      v21 = a6 * a3;
      v29 = a2;
      v25 = a1;
      do
      {
        if ( a5 > 0 )
        {
          v30 = v28;
          v9 = (int *)(v24 + 2);
          v26 = a5;
          do
          {
            v10 = *(v9 - 1);
            v19[0] = 0.0;
            v11 = *v9;
            v19[1] = 0.0;
            v19[2] = 0.0;
            v19[3] = 0.0;
            if ( v10 <= v11 )
            {
              v12 = (double *)*(v9 - 2);
              v13 = v29 + a6 * v10;
              v27 = v11 - v10 + 1;
              do
              {
                v14 = *v12;
                v15 = 0;
                if ( a6 > 0 )
                {
                  do
                  {
                    v23 = *(unsigned __int8 *)(v13 + v15);
                    v16 = &v19[v15++];
                    *v16 = (double)v23 * v14 + *v16;
                  }
                  while ( v15 < a6 );
                  v7 = v22;
                }
                v13 += a6;
                ++v12;
                --v27;
              }
              while ( v27 );
            }
            for ( i = 0; i < a6; ++i )
            {
              v18 = sub_40FA10(0.0);
              if ( v18 < 0 )
              {
                LOBYTE(v18) = 0;
              }
              else if ( v18 >= 255 )
              {
                LOBYTE(v18) = -1;
              }
              *(_BYTE *)(v30 + i) = v18;
            }
            v30 += a6;
            v9 += 3;
            --v26;
          }
          while ( v26 );
          v8 = v21;
        }
        v29 += v8;
        v28 += v7;
        --v25;
      }
      while ( v25 );
    }
    sub_40BCEA(v20, v24);
  }
}
// 40BE17: conditional instruction was optimized away because eax.4<FFu

//----- (0040BE62) --------------------------------------------------------
void __cdecl sub_40BE62(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // edi
  int *v8; // esi
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  double *v12; // edi
  double v13; // st6
  int v14; // ebx
  double *v15; // ecx
  int v16; // ebx
  int v17; // eax
  double v18[4]; // [esp+0h] [ebp-48h] BYREF
  int v19; // [esp+20h] [ebp-28h] BYREF
  int v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  double **v22; // [esp+2Ch] [ebp-1Ch]
  int v23; // [esp+30h] [ebp-18h]
  int v24; // [esp+34h] [ebp-14h]
  int v25; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int v27; // [esp+40h] [ebp-8h]
  int v28; // [esp+44h] [ebp-4h]

  v22 = sub_40BAD0(1, a6, a3, &v19);
  if ( v22 )
  {
    if ( a5 > 0 )
    {
      v28 = 0;
      v23 = a5;
      do
      {
        if ( a6 > 0 )
        {
          v7 = a7 * a5;
          v20 = a7 * a5;
          v27 = a4;
          v8 = (int *)(v22 + 2);
          v24 = a6;
          do
          {
            v9 = *(v8 - 1);
            v18[0] = 0.0;
            v10 = *v8;
            v18[1] = 0.0;
            v18[2] = 0.0;
            v18[3] = 0.0;
            if ( v9 <= v10 )
            {
              v11 = a1 + v28 + a7 * a2 * v9;
              v12 = (double *)*(v8 - 2);
              v25 = v10 - *(v8 - 1) + 1;
              do
              {
                v13 = *v12;
                v14 = 0;
                for ( i = 0; v14 < a7; *v15 = (double)v21 * v13 + *v15 )
                {
                  v15 = &v18[v14];
                  v21 = *(unsigned __int8 *)(v11 + v14);
                  v14 = ++i;
                }
                ++v12;
                v11 += a7 * a2;
                --v25;
              }
              while ( v25 );
              v7 = v20;
            }
            v16 = 0;
            if ( a7 > 0 )
            {
              v21 = v27 + v28;
              do
              {
                v17 = sub_40FA10(0.0);
                if ( v17 < 0 )
                {
                  LOBYTE(v17) = 0;
                }
                else if ( v17 >= 255 )
                {
                  LOBYTE(v17) = -1;
                }
                *(_BYTE *)(v21 + v16++) = v17;
              }
              while ( v16 < a7 );
            }
            v27 += v7;
            v8 += 3;
            --v24;
          }
          while ( v24 );
        }
        v28 += a7;
        --v23;
      }
      while ( v23 );
    }
    sub_40BCEA(v19, v22);
  }
}
// 40BF5F: conditional instruction was optimized away because eax.4<FFu

//----- (0040C055) --------------------------------------------------------
void __stdcall sub_40C055(int a1)
{
  HGDIOBJ *v1; // eax
  HICON *v2; // esi
  DWORD ObjectType; // eax
  HICON v4; // [esp-8h] [ebp-Ch]

  if ( a1 == -1 )
  {
    sub_40E672((_DWORD *)dword_413B1C);
  }
  else
  {
    v1 = (HGDIOBJ *)sub_40E59A(dword_413B1C, a1);
    v2 = (HICON *)v1;
    if ( v1 )
    {
      ObjectType = GetObjectType(*v1);
      v4 = *v2;
      if ( ObjectType == 7 )
        DeleteObject(v4);
      else
        DestroyIcon(v4);
      sub_40E5BF((size_t *)dword_413B1C, a1);
    }
  }
}
// 413B1C: using guessed type int dword_413B1C;

//----- (0040C0AD) --------------------------------------------------------
void sub_40C0AD()
{
  sub_40E672((_DWORD *)dword_413B1C);
}
// 413B1C: using guessed type int dword_413B1C;

//----- (0040C0B9) --------------------------------------------------------
_DWORD *sub_40C0B9()
{
  _DWORD *result; // eax

  result = sub_40E5FA(20, 16, (int)sub_40C055);
  dword_413B1C = (int)result;
  return result;
}
// 413B1C: using guessed type int dword_413B1C;

//----- (0040C0CD) --------------------------------------------------------
int __stdcall sub_40C0CD(int a1, int a2)
{
  int v2; // eax
  int v3; // eax

  switch ( a2 )
  {
    case 1:
      v3 = (a1 + 31) / 32;
      return 4 * v3;
    case 4:
      v3 = (a1 + 7) / 8;
      return 4 * v3;
    case 8:
      v2 = a1 + 3;
      goto LABEL_10;
  }
  if ( a2 <= 14 )
  {
LABEL_13:
    v3 = a1;
    return 4 * v3;
  }
  if ( a2 > 16 )
  {
    if ( a2 == 24 )
    {
      v2 = 3 * (a1 + 1);
LABEL_10:
      v3 = v2 / 4;
      return 4 * v3;
    }
    goto LABEL_13;
  }
  v3 = (a1 + 1) / 2;
  return 4 * v3;
}

//----- (0040C142) --------------------------------------------------------
LPVOID sub_40C142()
{
  LPVOID result; // eax

  dword_413B20 = 0;
  result = sub_40E64A(0x4Cu, 0, 0);
  dword_413B24 = (int)result;
  return result;
}
// 413B20: using guessed type int dword_413B20;
// 413B24: using guessed type int dword_413B24;

//----- (0040C160) --------------------------------------------------------
HANDLE sub_40C160()
{
  HANDLE result; // eax

  result = HeapCreate(0, 0x1000u, 0);
  dword_413BA0 = result;
  return result;
}

//----- (0040C180) --------------------------------------------------------
BOOL sub_40C180()
{
  return HeapDestroy(dword_413BA0);
}

//----- (0040C1D0) --------------------------------------------------------
LPVOID __stdcall sub_40C1D0(int dwBytes)
{
  if ( dwBytes <= 0 )
    return 0;
  else
    return HeapAlloc(dword_413BA0, 8u, dwBytes);
}

//----- (0040C1F0) --------------------------------------------------------
int __usercall sub_40C1F0@<eax>(char *a1@<eax>)
{
  return *a1;
}

//----- (0040C200) --------------------------------------------------------
_BYTE *__userpurge sub_40C200@<eax>(_BYTE *result@<eax>, char a2)
{
  *result = a2;
  return result;
}

//----- (0040C210) --------------------------------------------------------
const CHAR *__stdcall sub_40C210(const char *Src, int a2, int a3)
{
  int v3; // edi
  const CHAR *result; // eax
  char *v5; // eax
  char *v6; // esi
  int v7; // ecx
  char v8; // al

  v3 = a2;
  if ( a2 == -1 )
    return sub_40C280(Src, a3);
  if ( a2 < 0 )
    v3 = 0;
  v5 = sub_40F2C0(v3, a3);
  v6 = v5;
  if ( Src && v3 )
  {
    v7 = Src - v5;
    do
    {
      v8 = v6[v7];
      if ( !v8 )
        break;
      *v6++ = v8;
      --v3;
    }
    while ( v3 );
  }
  result = sub_40F3E0(v3);
  *v6 = 0;
  return result;
}

//----- (0040C270) --------------------------------------------------------
_DWORD *__userpurge sub_40C270@<eax>(_DWORD *result@<eax>, int a2)
{
  *result = a2;
  return result;
}

//----- (0040C280) --------------------------------------------------------
_BYTE *__stdcall sub_40C280(const char *Src, int a2)
{
  unsigned int v2; // esi
  _BYTE *result; // eax
  _BYTE *v4; // edi

  v2 = 0;
  if ( Src )
    v2 = strlen(Src);
  result = sub_40F2C0(v2, a2);
  v4 = result;
  if ( v2 )
    result = memcpy(result, Src, v2);
  v4[v2] = 0;
  return result;
}

//----- (0040C2D0) --------------------------------------------------------
BOOL __stdcall sub_40C2D0(LPVOID lpMem)
{
  return HeapFree(dword_413BA0, 0, lpMem);
}

//----- (0040C2F0) --------------------------------------------------------
void *__stdcall sub_40C2F0(void *a1, size_t Size)
{
  return memset(a1, 0, Size);
}

//----- (0040C310) --------------------------------------------------------
int __stdcall sub_40C310(void *Src, void *a2, size_t Size)
{
  memcpy(a2, Src, Size);
  return (int)a2 + Size;
}

//----- (0040C340) --------------------------------------------------------
_BYTE *__stdcall sub_40C340(_BYTE *a1, char *a2, int a3)
{
  _BYTE *v3; // eax
  char i; // cl

  v3 = a1;
  if ( a2 )
  {
    for ( i = *a2; i; --a3 )
    {
      if ( !a3 )
        break;
      *v3 = i;
      i = (v3++)[a2 - a1 + 1];
    }
  }
  *v3 = 0;
  return (_BYTE *)(v3 - a1);
}

//----- (0040C380) --------------------------------------------------------
SIZE_T __stdcall sub_40C380(LPCVOID lpMem)
{
  if ( lpMem )
    return HeapSize(dword_413BA0, 0, lpMem);
  else
    return 0;
}

//----- (0040C3A0) --------------------------------------------------------
int __usercall sub_40C3A0@<eax>(int a1@<eax>)
{
  return *(_DWORD *)a1;
}

//----- (0040C3B0) --------------------------------------------------------
LPVOID __stdcall sub_40C3B0(SIZE_T dwBytes, int a2)
{
  if ( a2 <= 0 )
    return 0;
  if ( dwBytes )
    return HeapReAlloc(dword_413BA0, 8u, (LPVOID)dwBytes, a2);
  return HeapAlloc(dword_413BA0, 8u, a2);
}
// 40C19E: conditional instruction was optimized away because %arg_4.1==0
// 40C196: conditional instruction was optimized away because %arg_4.4>=1

//----- (0040C3F0) --------------------------------------------------------
_BYTE *__stdcall sub_40C3F0(_BYTE *a1, char *a2)
{
  _BYTE *v2; // eax
  char i; // cl

  v2 = a1;
  if ( a2 )
  {
    for ( i = *a2; i; ++v2 )
    {
      *v2 = i;
      i = v2[a2 - a1 + 1];
    }
  }
  *v2 = 0;
  return (_BYTE *)(v2 - a1);
}

//----- (0040C41B) --------------------------------------------------------
DWORD sub_40C41B()
{
  DWORD result; // eax

  result = TlsAlloc();
  dword_413BA4 = result;
  return result;
}
// 413BA4: using guessed type int dword_413BA4;

//----- (0040C427) --------------------------------------------------------
void sub_40C427()
{
  if ( dword_4139E4 )
    sub_40E672((_DWORD *)dword_4139E4);
}
// 4139E4: using guessed type int dword_4139E4;

//----- (0040C437) --------------------------------------------------------
BOOL __stdcall sub_40C437(char *Source)
{
  char *i; // eax
  char v2; // dl
  char Destination[264]; // [esp+0h] [ebp-108h] BYREF

  if ( !Source )
    return 0;
  strncpy(Destination, Source, 0x104u);
  Destination[260] = 0;
  for ( i = &Destination[strlen(Destination)]; i > Destination; --i )
  {
    v2 = *(i - 1);
    if ( v2 != 32 && v2 != 92 && v2 != 47 )
      break;
  }
  *i = 0;
  return CreateDirectoryA(Destination, 0);
}

//----- (0040C4AD) --------------------------------------------------------
const CHAR *__stdcall sub_40C4AD(int a1)
{
  char *v1; // edi
  DWORD TempPathA; // ebx
  HMODULE LibraryA; // eax
  HMODULE v4; // ebp
  DWORD (__stdcall *GetLongPathNameA)(LPCSTR, LPSTR, DWORD); // eax
  const CHAR *result; // eax

  v1 = sub_40F2C0(260, a1);
  TempPathA = GetTempPathA(0x104u, v1);
  LibraryA = LoadLibraryA("Kernel32.DLL");
  v4 = LibraryA;
  if ( LibraryA )
  {
    GetLongPathNameA = (DWORD (__stdcall *)(LPCSTR, LPSTR, DWORD))GetProcAddress(LibraryA, "GetLongPathNameA");
    if ( GetLongPathNameA )
      TempPathA = GetLongPathNameA(v1, v1, 260);
    FreeLibrary(v4);
  }
  result = sub_40F3E0(260 - TempPathA);
  v1[TempPathA] = 0;
  return result;
}

//----- (0040C50E) --------------------------------------------------------
BOOL __stdcall sub_40C50E(LPCSTR lpFileName, char a2)
{
  if ( !lpFileName )
    return 0;
  if ( (a2 & 2) != 0 )
    SetFileAttributesA(lpFileName, 0x80u);
  return DeleteFileA(lpFileName);
}

//----- (0040C53C) --------------------------------------------------------
BOOL __stdcall sub_40C53C(LPCSTR lpFileName)
{
  return sub_40C50E(lpFileName, 0);
}

//----- (0040C54A) --------------------------------------------------------
const CHAR *__stdcall sub_40C54A(int a1)
{
  char *v1; // edi
  DWORD CurrentDirectoryA; // eax
  DWORD v3; // esi
  const CHAR *result; // eax

  v1 = sub_40F2C0(260, a1);
  CurrentDirectoryA = GetCurrentDirectoryA(0x104u, v1);
  v3 = CurrentDirectoryA;
  if ( CurrentDirectoryA && v1[CurrentDirectoryA - 1] != 92 )
  {
    v1[CurrentDirectoryA] = 92;
    v3 = CurrentDirectoryA + 1;
  }
  result = sub_40F3E0(260 - v3);
  v1[v3] = 0;
  return result;
}

//----- (0040C58A) --------------------------------------------------------
BOOL __stdcall sub_40C58A(const CHAR *a1)
{
  return a1 && SetCurrentDirectoryA(a1);
}

//----- (0040C59C) --------------------------------------------------------
void *__stdcall sub_40C59C(char *a1, int a2)
{
  char *v2; // eax
  char *v3; // edi
  char *v4; // esi
  char v5; // cl
  size_t v6; // esi
  char *v7; // ebx
  void *result; // eax
  int v9; // [esp+14h] [ebp+8h]

  v2 = a1;
  v3 = 0;
  v4 = 0;
  if ( a1 )
  {
    v5 = *a1;
    v3 = a1;
    if ( *a1 == 34 )
      v3 = a1 + 1;
    v4 = v3;
    while ( v5 && v5 != 124 )
    {
      if ( v5 == 47 || v5 == 92 )
        v4 = v2 + 1;
      v5 = *++v2;
    }
  }
  v6 = v4 - v3;
  v9 = sub_40F280((unsigned int)v3);
  v7 = sub_40F2C0(v6, a2);
  if ( v9 )
    v3 = sub_40F340(v9);
  result = memmove(v7, v3, v6);
  v7[v6] = 0;
  return result;
}

//----- (0040C612) --------------------------------------------------------
void *__stdcall sub_40C612(char *a1, char a2, int a3)
{
  char *v3; // eax
  char *v4; // edi
  char *v5; // esi
  char v6; // cl
  char v7; // al
  char *v8; // eax
  size_t v9; // esi
  char *v10; // ebx
  void *result; // eax
  int v12; // [esp+14h] [ebp+8h]

  v3 = a1;
  v4 = 0;
  v5 = 0;
  if ( a1 )
  {
    v6 = *a1;
    v4 = a1;
    if ( *a1 == 34 )
      v4 = a1 + 1;
    while ( v6 )
    {
      if ( v6 == 47 || v6 == 92 )
        v4 = v3 + 1;
      v6 = *++v3;
    }
    v7 = *v4;
    v5 = v4;
    while ( v7 && v7 != 34 )
      v7 = *++v5;
    if ( (a2 & 1) != 0 )
    {
      v8 = v5;
      if ( v5 > v4 )
      {
        while ( *v8 != 32 )
        {
          if ( *v8 == 46 )
          {
            if ( v8 < v5 - 1 )
              v5 = v8;
            break;
          }
          if ( --v8 <= v4 )
            break;
        }
      }
    }
  }
  v9 = v5 - v4;
  v12 = sub_40F280((unsigned int)v4);
  v10 = sub_40F2C0(v9, a3);
  if ( v12 )
    v4 = sub_40F340(v12);
  result = memmove(v10, v4, v9);
  v10[v9] = 0;
  return result;
}

//----- (0040C6BA) --------------------------------------------------------
void *__stdcall sub_40C6BA(char *a1, int a2)
{
  return sub_40C612(a1, 0, a2);
}

//----- (0040C6D0) --------------------------------------------------------
DWORD __stdcall sub_40C6D0(int a1)
{
  DWORD result; // eax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

  result = 0;
  NumberOfBytesWritten = 0;
  if ( !*(_DWORD *)(a1 + 20) )
  {
    WriteFile(*(HANDLE *)a1, *(LPCVOID *)(a1 + 4), *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12), &NumberOfBytesWritten, 0);
    result = NumberOfBytesWritten;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  }
  return result;
}

//----- (0040C710) --------------------------------------------------------
void __stdcall sub_40C710(int a1)
{
  HANDLE *v1; // eax
  HANDLE *v2; // esi

  if ( a1 == -1 )
  {
    sub_40E672((_DWORD *)dword_413BA8);
  }
  else
  {
    v1 = (HANDLE *)sub_40E59A(dword_413BA8, a1);
    v2 = v1;
    if ( v1 )
    {
      if ( v1[1] )
      {
        sub_40C6D0((int)v1);
        HeapFree(hHeap, 0, v2[1]);
      }
      CloseHandle(*v2);
      sub_40E5BF((size_t *)dword_413BA8, a1);
    }
  }
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040C780) --------------------------------------------------------
void sub_40C780()
{
  sub_40E672((_DWORD *)dword_413BA8);
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040C790) --------------------------------------------------------
_DWORD *sub_40C790()
{
  _DWORD *result; // eax

  result = sub_40E5FA(24, 16, (int)sub_40C710);
  dword_413BA8 = (int)result;
  return result;
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040C7B0) --------------------------------------------------------
_DWORD *__cdecl sub_40C7B0(int a1, LPCSTR lpFileName, DWORD dwMoveMethod, char a4)
{
  DWORD v4; // edi
  _DWORD *v5; // ebx
  HANDLE FileA; // esi
  DWORD v7; // eax
  DWORD v8; // edi
  HANDLE v9; // eax

  v4 = dwMoveMethod;
  v5 = sub_40E515(dword_413BA8, a1);
  switch ( dwMoveMethod )
  {
    case 1u:
      FileA = CreateFileA(lpFileName, 0x80000000, (a4 & 1) != 0, 0, 3u, 0x80u, 0);
      break;
    case 2u:
      v7 = (a4 & 1) != 0;
      if ( (a4 & 2) != 0 )
        v7 |= 3u;
      FileA = CreateFileA(lpFileName, 0xC0000000, v7, 0, 4u, 0x80u, 0);
      break;
    case 3u:
      v8 = (a4 & 1) != 0;
      if ( (a4 & 2) != 0 )
        v8 |= 2u;
      FileA = CreateFileA(lpFileName, 0xC0000000, v8, 0, 2u, 0x80u, 0);
      if ( FileA != (HANDLE)-1 )
      {
        v4 = 3;
        goto LABEL_18;
      }
      v9 = CreateFileA(lpFileName, 0x40000000u, v8, 0, 5u, 0, 0);
      v4 = 3;
      FileA = v9;
      break;
    default:
      FileA = (HANDLE)dwMoveMethod;
      break;
  }
  if ( FileA == (HANDLE)-1 )
  {
LABEL_14:
    if ( a1 == -1 )
      sub_40E5BF((size_t *)dword_413BA8, (int)v5);
    return 0;
  }
LABEL_18:
  if ( !FileA )
    goto LABEL_14;
  if ( !dwBytes || (a4 & 4) != 0 )
    v5[1] = 0;
  else
    v5[1] = HeapAlloc(hHeap, 0, dwBytes);
  *v5 = FileA;
  v5[2] = dwBytes;
  v5[3] = 0;
  v5[5] = 1;
  if ( v4 == 2 && (a4 & 8) != 0 )
    SetFilePointer(FileA, 0, 0, 2u);
  if ( a1 == -1 )
    return v5;
  else
    return FileA;
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040C930) --------------------------------------------------------
_DWORD *__stdcall sub_40C930(int a1, LPCSTR lpFileName)
{
  _DWORD *v2; // edi
  HANDLE FileA; // esi

  v2 = sub_40E515(dword_413BA8, a1);
  FileA = CreateFileA(lpFileName, 0xC0000000, 1u, 0, 2u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 && (FileA = CreateFileA(lpFileName, 0x40000000u, 1u, 0, 5u, 0, 0), FileA == (HANDLE)-1)
    || !FileA )
  {
    if ( a1 == -1 )
      sub_40E5BF((size_t *)dword_413BA8, (int)v2);
    return 0;
  }
  else
  {
    if ( dwBytes )
      v2[1] = HeapAlloc(hHeap, 0, dwBytes);
    else
      v2[1] = 0;
    *v2 = FileA;
    v2[2] = dwBytes;
    v2[3] = 0;
    v2[5] = 1;
    if ( a1 == -1 )
      return v2;
    else
      return FileA;
  }
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040CA00) --------------------------------------------------------
_DWORD *__stdcall sub_40CA00(int a1, LPCSTR lpFileName)
{
  _DWORD *v2; // esi
  HANDLE FileA; // eax
  HANDLE v4; // edi

  v2 = sub_40E515(dword_413BA8, a1);
  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v4 = FileA;
  if ( FileA == (HANDLE)-1 || !FileA )
  {
    if ( a1 == -1 )
      sub_40E5BF((size_t *)dword_413BA8, (int)v2);
    return 0;
  }
  else
  {
    if ( dwBytes )
      v2[1] = HeapAlloc(hHeap, 0, dwBytes);
    else
      v2[1] = 0;
    *v2 = v4;
    v2[2] = dwBytes;
    v2[3] = 0;
    v2[5] = 1;
    if ( a1 == -1 )
      return v2;
    else
      return v4;
  }
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040CAB0) --------------------------------------------------------
int __stdcall sub_40CAB0(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)
{
  int result; // eax
  HANDLE *v4; // eax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

  result = 0;
  NumberOfBytesWritten = 0;
  if ( lpBuffer && nNumberOfBytesToWrite )
  {
    v4 = (HANDLE *)sub_40E59A(dword_413BA8, a1);
    if ( v4 )
    {
      if ( v4[1] )
        return sub_40CC70((int)v4, lpBuffer, nNumberOfBytesToWrite);
      WriteFile(*v4, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
    }
    return NumberOfBytesWritten;
  }
  return result;
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040CB10) --------------------------------------------------------
int __stdcall sub_40CB10(int a1, char *lpBuffer)
{
  int result; // eax
  HANDLE *v3; // eax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

  result = 0;
  NumberOfBytesWritten = 0;
  if ( lpBuffer && *lpBuffer )
  {
    v3 = (HANDLE *)sub_40E59A(dword_413BA8, a1);
    if ( v3 )
    {
      if ( v3[1] )
      {
        return sub_40CC70((int)v3, lpBuffer, strlen(lpBuffer));
      }
      else
      {
        WriteFile(*v3, lpBuffer, strlen(lpBuffer), &NumberOfBytesWritten, 0);
        return NumberOfBytesWritten;
      }
    }
    else
    {
      return NumberOfBytesWritten;
    }
  }
  return result;
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040CB90) --------------------------------------------------------
DWORD __stdcall sub_40CB90(int a1, char *lpBuffer)
{
  HANDLE *v2; // eax
  int v3; // esi
  DWORD v4; // eax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-8h] BYREF
  DWORD v7; // [esp+8h] [ebp-4h] BYREF

  NumberOfBytesWritten = 0;
  v7 = 0;
  v2 = (HANDLE *)sub_40E59A(dword_413BA8, a1);
  v3 = (int)v2;
  if ( !v2 )
    return NumberOfBytesWritten;
  if ( lpBuffer && *lpBuffer )
  {
    if ( v2[1] )
      NumberOfBytesWritten = sub_40CC70((int)v2, lpBuffer, strlen(lpBuffer));
    else
      WriteFile(*v2, lpBuffer, strlen(lpBuffer), &NumberOfBytesWritten, 0);
  }
  if ( *(_DWORD *)(v3 + 4) )
  {
    v4 = sub_40CC70(v3, "\r\n", 2);
    return v4 + NumberOfBytesWritten;
  }
  else
  {
    WriteFile(*(HANDLE *)v3, "\r\n", 2u, &v7, 0);
    return v7 + NumberOfBytesWritten;
  }
}
// 413BA8: using guessed type int dword_413BA8;

//----- (0040CC70) --------------------------------------------------------
DWORD __stdcall sub_40CC70(int a1, _BYTE *Src, signed int Size)
{
  bool v3; // zf
  int v4; // edx
  signed int v5; // ecx
  _BYTE *v6; // eax
  signed int v8; // eax
  DWORD NumberOfBytesWritten; // [esp+8h] [ebp-4h] BYREF

  v3 = *(_DWORD *)(a1 + 20) == 1;
  NumberOfBytesWritten = 0;
  if ( v3 )
  {
    SetFilePointer(*(HANDLE *)a1, -*(_DWORD *)(a1 + 12), 0, 1u);
    v4 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 12) = v4;
  }
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 <= Size )
  {
    sub_40C6D0(a1);
    v8 = *(_DWORD *)(a1 + 8);
    if ( Size < v8 )
    {
      memcpy((void *)(v8 + *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 12)), Src, Size);
      *(_DWORD *)(a1 + 12) -= Size;
      return Size;
    }
    else
    {
      WriteFile(*(HANDLE *)a1, Src, Size, &NumberOfBytesWritten, 0);
      return NumberOfBytesWritten;
    }
  }
  else
  {
    v6 = (_BYTE *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) - v5);
    if ( Size == 1 )
    {
      *v6 = *Src;
      --*(_DWORD *)(a1 + 12);
      return 1;
    }
    else if ( Size == 2 )
    {
      *(_WORD *)v6 = *(_WORD *)Src;
      *(_DWORD *)(a1 + 12) -= 2;
      return 2;
    }
    else
    {
      if ( Size == 4 )
        *(_DWORD *)v6 = *(_DWORD *)Src;
      else
        memcpy(v6, Src, Size);
      *(_DWORD *)(a1 + 12) -= Size;
      return Size;
    }
  }
}

//----- (0040CD69) --------------------------------------------------------
LRESULT __stdcall sub_40CD69(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lpMem)
{
  if ( Msg == dword_413BAC )
  {
    sub_40CEF7(lpMem[1], lpMem[3], lpMem[4], lpMem[5], lpMem[6], 0, 1);
    HeapFree(hHeap, 0, lpMem);
  }
  return DefWindowProcA(hWnd, Msg, wParam, (LPARAM)lpMem);
}
// 413BAC: using guessed type int dword_413BAC;

//----- (0040CDBA) --------------------------------------------------------
_DWORD *__cdecl sub_40CDBA(char **a1)
{
  char *v1; // eax

  v1 = sub_40E6B3(32, 16, 256, 2);
  *a1 = v1;
  return sub_40E7E9((int)v1);
}

//----- (0040CDE3) --------------------------------------------------------
void sub_40CDE3()
{
  WNDCLASSA WndClass; // [esp+8h] [ebp-28h] BYREF

  memset(&WndClass, 0, sizeof(WndClass));
  WndClass.hInstance = hInstance;
  WndClass.style = 8;
  WndClass.lpfnWndProc = (WNDPROC)sub_40CD69;
  WndClass.cbWndExtra = 0;
  WndClass.hIcon = 0;
  WndClass.hCursor = 0;
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.lpszClassName = "PostEventClass";
  RegisterClassA(&WndClass);
  hWnd = CreateWindowExA(0, "PostEventClass", 0, 0xC00000u, 0, 0, 1, 1, 0, 0, hInstance, 0);
  dword_413BAC = RegisterWindowMessageA("PB_PostEventMessage");
  dword_413BB4 = (int)sub_40E64A(0x28u, (void (__cdecl *)(LPVOID))sub_40CDBA, (int)sub_40CDD7);
  dword_4139E8 = (int)sub_40D2D2(8, 7, 0, (LPVOID *)&dword_4139E8, 1024);
  if ( dword_41200E )
    InitializeCriticalSection(&stru_413BB8);
}
// 40CDD7: using guessed type int sub_40CDD7();
// 41200E: using guessed type int dword_41200E;
// 413BAC: using guessed type int dword_413BAC;
// 413BB4: using guessed type int dword_413BB4;

//----- (0040CEAC) --------------------------------------------------------
int *__cdecl sub_40CEAC(int a1, int a2, int a3, int a4)
{
  int *result; // eax
  int *v5; // esi
  char Buffer[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(Buffer, "%d:%d:%d:%d", a1, a2, a3, a4);
  result = sub_40D433(dword_4139E8, Buffer);
  if ( result )
  {
    result = (int *)*result;
    if ( result )
    {
      do
      {
        v5 = (int *)*result;
        ((void (*)(void))result[1])();
        result = v5;
      }
      while ( v5 );
    }
  }
  return result;
}

//----- (0040CEF7) --------------------------------------------------------
void __cdecl sub_40CEF7(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int *v7; // esi
  _DWORD *v8; // eax
  int v9; // edx
  int v10; // ebx
  int v11; // ecx
  _DWORD *v12; // eax
  _DWORD *v13; // ecx
  bool v14; // zf
  int v15; // [esp+4h] [ebp-18h]
  int v16; // [esp+8h] [ebp-14h]
  int v17; // [esp+Ch] [ebp-10h]
  int v18; // [esp+10h] [ebp-Ch]
  int v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h]

  v7 = (int *)sub_40E643(dword_413BB4);
  if ( dword_41200E )
    EnterCriticalSection(&stru_413BB8);
  if ( !v7[3] || (a7 & 1) != 0 )
  {
    v8 = (_DWORD *)v7[2];
    if ( v8 && a1 < 0x10000 && (a7 & 2) == 0 && v8[1] == a1 )
    {
      v9 = a2;
      v10 = a3;
      if ( v8[3] == a2 && v8[4] == a3 )
      {
        v11 = a4;
        if ( v8[5] == a4 )
        {
LABEL_19:
          if ( (a7 & 2) == 0 )
          {
            v20 = v7[4];
            v19 = v7[5];
            v18 = v7[6];
            v17 = v7[7];
            v16 = v7[8];
            v15 = v7[9];
            v7[8] = a5;
            v7[4] = a1;
            v7[5] = v10;
            v7[6] = v9;
            v7[7] = v11;
            v7[9] = a6;
            sub_40CEAC(a1, v10, v9, v11);
            sub_40CEAC(a1, a3, a2, -1);
            sub_40CEAC(a1, a3, -1, -1);
            sub_40CEAC(a1, -1, -1, -1);
            sub_40CEAC(a1, -1, a2, a4);
            v7[4] = v20;
            v7[5] = v19;
            v7[6] = v18;
            v7[7] = v17;
            v7[8] = v16;
            v7[9] = v15;
          }
          goto LABEL_21;
        }
      }
    }
    else
    {
      v10 = a3;
    }
    v12 = sub_40E7E9(*v7);
    v13 = (_DWORD *)v7[2];
    if ( v13 )
      *v13 = v12;
    v14 = v7[1] == 0;
    v7[2] = (int)v12;
    if ( v14 )
      v7[1] = (int)v12;
    *v12 = 0;
    v9 = a2;
    v12[3] = a2;
    v12[5] = a4;
    v12[6] = a5;
    v12[7] = a6;
    v12[2] = a7;
    v11 = a4;
    v12[1] = a1;
    v12[4] = v10;
    goto LABEL_19;
  }
LABEL_21:
  if ( dword_41200E )
    LeaveCriticalSection(&stru_413BB8);
}
// 41200E: using guessed type int dword_41200E;
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D077) --------------------------------------------------------
void __cdecl sub_40D077(int a1, int a2, int a3, int a4)
{
  sub_40CEF7(a1, a2, a3, a4, 0, 0, 0);
}

//----- (0040D095) --------------------------------------------------------
int sub_40D095()
{
  int *v0; // esi
  void (__cdecl *v1)(int); // eax
  int *v2; // eax
  int v3; // ebx

  v0 = (int *)sub_40E643(dword_413BB4);
  v0[4] = 0;
  if ( dword_41200E )
    EnterCriticalSection(&stru_413BB8);
  if ( v0[8] )
  {
    v1 = (void (__cdecl *)(int))v0[9];
    if ( v1 )
    {
      v1(v0[8]);
      v0[9] = 0;
      v0[8] = 0;
    }
  }
  v2 = (int *)v0[1];
  v0[7] = -1;
  if ( v2 )
  {
    v0[4] = v2[1];
    v0[6] = v2[3];
    v0[5] = v2[4];
    v0[7] = v2[5];
    v0[8] = v2[6];
    v0[9] = v2[7];
    v3 = v2[2];
    v0[1] = *v2;
    if ( v2 == (int *)v0[2] )
      v0[2] = 0;
    sub_40E948(*v0, (int)v2);
    if ( (v3 & 2) != 0 )
    {
      sub_40CEAC(v0[4], v0[5], v0[6], v0[7]);
      sub_40CEAC(v0[4], v0[5], v0[6], -1);
      sub_40CEAC(v0[4], v0[5], -1, -1);
      sub_40CEAC(v0[4], -1, -1, -1);
      sub_40CEAC(v0[4], -1, v0[6], v0[7]);
    }
  }
  if ( dword_41200E )
    LeaveCriticalSection(&stru_413BB8);
  return v0[4];
}
// 41200E: using guessed type int dword_41200E;
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D190) --------------------------------------------------------
BOOL sub_40D190()
{
  return DestroyWindow(hWnd);
}

//----- (0040D19D) --------------------------------------------------------
int sub_40D19D()
{
  return *(_DWORD *)(sub_40E643(dword_413BB4) + 24);
}
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D1AC) --------------------------------------------------------
int sub_40D1AC()
{
  return *(_DWORD *)(sub_40E643(dword_413BB4) + 24);
}
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D1BB) --------------------------------------------------------
_DWORD *__cdecl sub_40D1BB(int a1, int a2, int a3, int a4)
{
  int *v4; // esi
  _DWORD *result; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // ecx

  v4 = (int *)sub_40E643(dword_413BB4);
  result = (_DWORD *)v4[1];
  v4[2] = 0;
  if ( result )
  {
    do
    {
      v6 = (_DWORD *)*result;
      if ( (a1 == -1 || a1 == result[1])
        && (a2 == -1 || a2 == result[3])
        && (a3 == -1 || a3 == result[4])
        && (a4 == -1 || a4 == result[5]) )
      {
        if ( result == (_DWORD *)v4[1] )
          v4[1] = (int)v6;
        v7 = (_DWORD *)v4[2];
        if ( v7 )
          *v7 = v6;
        sub_40E948(*v4, (int)result);
      }
      else
      {
        v4[2] = (int)result;
      }
      result = v6;
    }
    while ( v6 );
  }
  return result;
}
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D236) --------------------------------------------------------
_DWORD *__cdecl sub_40D236(int a1)
{
  int *v1; // esi
  _DWORD *result; // eax
  _DWORD *v3; // edi
  _DWORD *v4; // ecx

  v1 = (int *)sub_40E643(dword_413BB4);
  result = (_DWORD *)v1[1];
  v1[2] = 0;
  if ( result )
  {
    do
    {
      v3 = (_DWORD *)*result;
      if ( result[4] == a1 )
      {
        if ( result == (_DWORD *)v1[1] )
          v1[1] = (int)v3;
        v4 = (_DWORD *)v1[2];
        if ( v4 )
          *v4 = v3;
        sub_40E948(*v1, (int)result);
      }
      else
      {
        v1[2] = (int)result;
      }
      result = v3;
    }
    while ( v3 );
  }
  return result;
}
// 413BB4: using guessed type int dword_413BB4;

//----- (0040D282) --------------------------------------------------------
int __cdecl sub_40D282(int a1)
{
  int result; // eax

  sub_40D4C5((_DWORD *)dword_4139E8);
  while ( 1 )
  {
    result = sub_40D571((int *)dword_4139E8);
    if ( !result )
      break;
    if ( *(_DWORD *)(result + 4) == a1 )
      sub_40D4D3(dword_4139E8);
  }
  return result;
}

//----- (0040D2B3) --------------------------------------------------------
void sub_40D2B3()
{
  dword_413A34 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_40D2D2;
  dword_413A40 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_40D5B2;
  dword_413A4C = (int (__stdcall *)(_DWORD))sub_40D3CA;
}
// 413A34: using guessed type int (__stdcall *dword_413A34)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A40: using guessed type int (__stdcall *dword_413A40)(_DWORD, _DWORD, _DWORD);
// 413A4C: using guessed type int (__stdcall *dword_413A4C)(_DWORD);

//----- (0040D2D2) --------------------------------------------------------
_DWORD *__stdcall sub_40D2D2(int a1, int a2, int *a3, LPVOID *a4, signed int dwBytes)
{
  _DWORD *v5; // esi
  LPVOID v6; // eax
  _DWORD *v7; // eax

  sub_40D3CA(*a4);
  v5 = HeapAlloc(hHeap, 0, 0x3Cu);
  if ( v5 )
  {
    if ( dwBytes <= 0 )
      dwBytes = 1;
    v6 = HeapAlloc(hHeap, 8u, 4 * dwBytes);
    v5[1] = v6;
    if ( v6 )
    {
      v5[9] = dwBytes;
      v5[7] = a1;
      v5[8] = a2;
      *v5 = 0;
      v5[4] = a3;
      v5[10] = 0;
      v5[11] = 0;
      v5[12] = a4;
      v5[13] = 0;
      if ( sub_40F46C(a3) )
        v5[11] |= 2u;
      v5[14] = sub_40E6B3(a1 + 8, 16, 0x10000, 4);
      v7 = HeapAlloc(hHeap, 8u, a1 + 8);
      v5[3] = v7;
      v7[1] = &unk_411538;
      *a4 = v5;
    }
    else
    {
      HeapFree(hHeap, 0, v5);
      return 0;
    }
  }
  return v5;
}

//----- (0040D3A8) --------------------------------------------------------
int *__stdcall sub_40D3A8(int a1, char *String2)
{
  int *result; // eax

  result = sub_40D433(a1, String2);
  if ( !result )
    return sub_40D62E(a1, String2, 0);
  return result;
}

//----- (0040D3CA) --------------------------------------------------------
void __stdcall sub_40D3CA(LPVOID lpMem)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx

  if ( lpMem )
  {
    sub_40D706((int)lpMem);
    sub_40EA6F(*((char **)lpMem + 14));
    HeapFree(hHeap, 0, *((LPVOID *)lpMem + 1));
    HeapFree(hHeap, 0, *((LPVOID *)lpMem + 3));
    v1 = (_DWORD *)*((_DWORD *)lpMem + 13);
    if ( v1 )
    {
      do
      {
        v2 = (_DWORD *)*v1;
        HeapFree(hHeap, 0, v1);
        v1 = v2;
      }
      while ( v2 );
    }
    **((_DWORD **)lpMem + 12) = 0;
    HeapFree(hHeap, 0, lpMem);
  }
}

//----- (0040D433) --------------------------------------------------------
int *__stdcall sub_40D433(int a1, char *String2)
{
  unsigned int v2; // ebx
  int **i; // edi

  if ( !String2 )
    String2 = (char *)&unk_411002;
  if ( (*(_BYTE *)(a1 + 44) & 1) != 0 )
  {
    v2 = (unsigned int)sub_40D79F(String2) % *(_DWORD *)(a1 + 36);
    for ( i = *(int ***)(*(_DWORD *)(a1 + 4) + 4 * v2); i; i = (int **)*i )
    {
      if ( !stricmp((const char *)i[1], String2) )
        goto LABEL_9;
      *(_DWORD *)(a1 + 8) = i;
    }
  }
  else
  {
    v2 = (unsigned int)sub_40D786(String2) % *(_DWORD *)(a1 + 36);
    for ( i = *(int ***)(*(_DWORD *)(a1 + 4) + 4 * v2); i; i = (int **)*i )
    {
      if ( !strcmp((const char *)i[1], String2) )
      {
LABEL_9:
        *(_DWORD *)(a1 + 20) = v2;
        *(_DWORD *)a1 = i;
        return (int *)(i + 2);
      }
      *(_DWORD *)(a1 + 8) = i;
    }
  }
  return 0;
}

//----- (0040D4C5) --------------------------------------------------------
_DWORD *__stdcall sub_40D4C5(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[5] = -1;
  return result;
}

//----- (0040D4D3) --------------------------------------------------------
int __stdcall sub_40D4D3(int a1)
{
  int v1; // edi
  _DWORD *v2; // eax
  int v3; // eax
  bool v4; // zf

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    v2 = (_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * *(_DWORD *)(a1 + 20));
    if ( *v2 == v1 || (v2 = *(_DWORD **)(a1 + 8)) != 0 )
      *v2 = *(_DWORD *)v1;
    v3 = *(_DWORD *)(a1 + 8);
    --*(_DWORD *)(a1 + 40);
    v4 = (*(_BYTE *)(a1 + 44) & 4) == 0;
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 24);
    if ( v4 )
      HeapFree(hHeap, 0, *(LPVOID *)(v1 + 4));
    if ( *(_DWORD *)(a1 + 16) )
      sub_40F91A(v1 + 8, *(int **)(a1 + 16));
    sub_40E948(*(_DWORD *)(a1 + 56), v1);
  }
  if ( *(_DWORD *)a1 )
    return *(_DWORD *)a1 + 8;
  else
    return 0;
}

//----- (0040D548) --------------------------------------------------------
int __thiscall sub_40D548(_DWORD *this)
{
  int v1; // eax
  int v2; // edx
  _DWORD *i; // esi

  v1 = this[5];
  if ( v1 >= this[9] )
    return 0;
  v2 = this[1];
  for ( i = (_DWORD *)(v2 + 4 * v1); !*i; ++i )
  {
    if ( ++v1 >= this[9] )
      return 0;
  }
  this[5] = v1;
  return *(_DWORD *)(v2 + 4 * v1);
}

//----- (0040D571) --------------------------------------------------------
int __stdcall sub_40D571(int *a1)
{
  int *v1; // ecx
  int *v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax

  v1 = a1;
  v2 = (int *)*a1;
  v3 = a1[5];
  a1[2] = *a1;
  a1[6] = v3;
  if ( v2 )
  {
    v4 = *v2;
    *a1 = v4;
    if ( v4 )
      return *v1 + 8;
    a1[5] = v3 + 1;
  }
  else
  {
    if ( v3 != -1 )
      goto LABEL_7;
    a1[5] = 0;
  }
  v5 = sub_40D548(a1);
  *v1 = v5;
LABEL_7:
  if ( *v1 )
    return *v1 + 8;
  return 0;
}
// 40D59F: variable 'v1' is possibly undefined

//----- (0040D5B2) --------------------------------------------------------
int __stdcall sub_40D5B2(int *a1, int a2, int a3)
{
  int result; // eax
  _BYTE *v5; // eax
  int v6; // eax
  _BYTE *v7; // edi
  char *v8; // [esp-Ch] [ebp-14h]
  int v9; // [esp+4h] [ebp-4h]
  int v10; // [esp+10h] [ebp+8h]

  result = 0;
  if ( a1 && a2 )
  {
    v10 = *a1;
    v9 = a1[5];
    if ( a3 )
      sub_40D706(a2);
    sub_40D4C5(a1);
    while ( 1 )
    {
      v6 = sub_40D571(a1);
      v7 = (_BYTE *)v6;
      if ( !v6 )
        break;
      v8 = *(char **)(v6 - 4);
      if ( (a1[11] & 4) != 0 )
        v5 = sub_40D7C5(a2, (int)v8, 0);
      else
        v5 = sub_40D62E(a2, v8, 0);
      sub_40F63D(v5, a1[7], (char *)a1[4], v7);
    }
    *a1 = v10;
    a1[5] = v9;
    return 1;
  }
  return result;
}

//----- (0040D62E) --------------------------------------------------------
int *__stdcall sub_40D62E(int a1, char *Str, int a3)
{
  int *v3; // edi
  unsigned int v4; // eax
  int v5; // ebx
  size_t v6; // eax
  char *v7; // eax

  if ( a3 )
  {
    v3 = sub_40D433(a1, Str);
    if ( v3 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        sub_40F91A((int)v3, *(int **)(a1 + 16));
      goto LABEL_12;
    }
  }
  if ( !Str )
    Str = (char *)&unk_411002;
  if ( (*(_BYTE *)(a1 + 44) & 1) != 0 )
    v4 = sub_40D79F(Str);
  else
    v4 = sub_40D786(Str);
  v5 = v4 % *(_DWORD *)(a1 + 36);
  v3 = sub_40E7E9(*(_DWORD *)(a1 + 56));
  if ( v3 )
  {
    v6 = strlen(Str);
    v7 = (char *)HeapAlloc(hHeap, 0, v6 + 1);
    v3[1] = (int)v7;
    strcpy(v7, Str);
    *v3 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v5);
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v5) = v3;
    *(_DWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 40);
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 20) = v5;
    v3 += 2;
LABEL_12:
    if ( v3 )
    {
      memset(v3, 0, *(_DWORD *)(a1 + 28));
      if ( (*(_BYTE *)(a1 + 44) & 2) != 0 )
        sub_40F4B8((int)v3, *(int **)(a1 + 16));
    }
  }
  return v3;
}

//----- (0040D706) --------------------------------------------------------
_DWORD *__stdcall sub_40D706(int a1)
{
  int *v1; // ebx
  int v2; // edi
  int v3; // eax
  _DWORD *result; // eax
  int v5; // [esp-8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-8h] BYREF

  v1 = *(int **)(a1 + 16);
  sub_40D4C5((_DWORD *)a1);
  while ( 1 )
  {
    v3 = sub_40D571((int *)a1);
    if ( !v3 )
      break;
    v2 = v3 - 8;
    if ( (*(_BYTE *)(a1 + 44) & 4) == 0 )
      HeapFree(hHeap, 0, *(LPVOID *)(v2 + 4));
    if ( v1 )
      sub_40F91A(v2 + 8, v1);
    v5 = *(_DWORD *)(a1 + 56);
    v6 = *(_DWORD *)v2;
    *(_DWORD *)a1 = &v6;
    sub_40E948(v5, v2);
  }
  memset(*(void **)(a1 + 4), 0, 4 * *(_DWORD *)(a1 + 36));
  result = sub_40D4C5((_DWORD *)a1);
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (0040D786) --------------------------------------------------------
int __cdecl sub_40D786(_BYTE *a1)
{
  int result; // eax
  int v3; // ecx

  for ( result = 0; ; result = v3 + 65599 * result )
  {
    v3 = (char)*a1;
    if ( !*a1 )
      break;
    ++a1;
  }
  return result;
}

//----- (0040D79F) --------------------------------------------------------
int __cdecl sub_40D79F(char *a1)
{
  int i; // edi
  int v3; // eax

  for ( i = 0; ; i = v3 + 65599 * i )
  {
    v3 = tolower(*a1);
    if ( !v3 )
      break;
    ++a1;
  }
  return i;
}

//----- (0040D7C5) --------------------------------------------------------
_DWORD *__stdcall sub_40D7C5(int a1, int a2, int a3)
{
  _DWORD *v3; // edi
  int v4; // ebx
  _DWORD *v5; // eax

  if ( a3 && (v3 = sub_40D857((_DWORD *)a1, a2)) != 0 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      sub_40F91A((int)v3, *(int **)(a1 + 16));
  }
  else
  {
    v4 = a2 % *(_DWORD *)(a1 + 36);
    v5 = sub_40E7E9(*(_DWORD *)(a1 + 56));
    v3 = v5;
    if ( !v5 )
      return v3;
    v5[1] = a2;
    *v5 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v4);
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v4) = v5;
    *(_DWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 40);
    *(_DWORD *)a1 = v5;
    *(_DWORD *)(a1 + 20) = v4;
    v3 = v5 + 2;
  }
  if ( v3 )
  {
    memset(v3, 0, *(_DWORD *)(a1 + 28));
    if ( (*(_BYTE *)(a1 + 44) & 2) != 0 )
      sub_40F4B8((int)v3, *(int **)(a1 + 16));
  }
  return v3;
}

//----- (0040D857) --------------------------------------------------------
_DWORD *__stdcall sub_40D857(_DWORD *a1, int a2)
{
  int v2; // edx
  _DWORD *result; // eax

  v2 = a2 % a1[9];
  for ( result = *(_DWORD **)(a1[1] + 4 * v2); result; result = (_DWORD *)*result )
  {
    if ( result[1] == a2 )
    {
      *a1 = result;
      a1[5] = v2;
      result += 2;
      return result;
    }
    a1[2] = result;
  }
  return result;
}

//----- (0040D890) --------------------------------------------------------
char *__stdcall sub_40D890(int a1, unsigned int a2, int a3)
{
  char *result; // eax
  int i; // ecx
  _BYTE v5[16]; // [esp+0h] [ebp-68h] BYREF
  _DWORD v6[22]; // [esp+10h] [ebp-58h] BYREF

  sub_40DBD0(v6);
  sub_40E3A0(v6, a1, a2);
  sub_40E460((int)v5, (char *)v6);
  result = sub_40F2C0(32, a3);
  for ( i = 0; i < 16; i += 4 )
  {
    *result = byte_41153C[(unsigned __int8)v5[i] >> 4];
    result[1] = byte_41153C[v5[i] & 0xF];
    result[2] = byte_41153C[(unsigned __int8)v5[i + 1] >> 4];
    result[3] = byte_41153C[v5[i + 1] & 0xF];
    result[4] = byte_41153C[(unsigned __int8)v5[i + 2] >> 4];
    result[5] = byte_41153C[v5[i + 2] & 0xF];
    result[6] = byte_41153C[(unsigned __int8)v5[i + 3] >> 4];
    result[7] = byte_41153C[v5[i + 3] & 0xF];
    result += 8;
  }
  *result = 0;
  return result;
}
// 40D890: using guessed type _BYTE var_68[16];

//----- (0040D990) --------------------------------------------------------
unsigned int __stdcall sub_40D990(LPCSTR lpFileName, __int64 lDistanceToMove, __int64 a3)
{
  unsigned int v3; // esi
  int v4; // ebx
  HANDLE FileA; // edi
  void *v6; // ebp
  _BYTE *v7; // eax
  DWORD v8; // edx
  DWORD v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // ecx
  int v17; // ecx
  DWORD nNumberOfBytesToRead; // [esp+8h] [ebp-14h]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-Ch] BYREF
  int v21; // [esp+14h] [ebp-8h]
  HANDLE v22; // [esp+18h] [ebp-4h]
  LPCSTR lpFileNamea; // [esp+20h] [ebp+4h]

  v3 = -1;
  v4 = 0;
  nNumberOfBytesToRead = 0x80000;
  if ( lpFileName )
  {
    FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    v22 = FileA;
    if ( FileA != (HANDLE)-1 )
    {
      v6 = HeapAlloc(hHeap, 0, 0x80000u);
      if ( v6 )
      {
        if ( lDistanceToMove > 0 )
          SetFilePointer(FileA, lDistanceToMove, (PLONG)&lDistanceToMove + 1, 0);
        lpFileNamea = (LPCSTR)(a3 + 0x80000);
        do
        {
          lpFileNamea -= 0x80000;
          v4 += 0x80000;
          if ( (HIDWORD(a3) & (unsigned int)a3) != -1 && v4 > a3 )
            nNumberOfBytesToRead = (DWORD)lpFileNamea;
          ReadFile(FileA, v6, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
          v7 = v6;
          v8 = NumberOfBytesRead;
          if ( NumberOfBytesRead >= 8 )
          {
            v9 = NumberOfBytesRead >> 3;
            do
            {
              v21 = (unsigned __int8)(v3 ^ *v7);
              v10 = dword_411550[v21] ^ (v3 >> 8);
              v11 = dword_411550[(unsigned __int8)(v10 ^ v7[1])] ^ (v10 >> 8);
              v12 = dword_411550[(unsigned __int8)(v11 ^ v7[2])] ^ (v11 >> 8);
              v13 = dword_411550[(unsigned __int8)(v12 ^ v7[3])] ^ (v12 >> 8);
              v14 = dword_411550[(unsigned __int8)(v13 ^ v7[4])] ^ (v13 >> 8);
              v15 = dword_411550[(unsigned __int8)(v14 ^ v7[5])] ^ (v14 >> 8);
              v16 = dword_411550[(unsigned __int8)(v15 ^ v7[6])] ^ (v15 >> 8);
              v17 = dword_411550[(unsigned __int8)(v16 ^ v7[7])] ^ (v16 >> 8);
              v7 += 8;
              v8 -= 8;
              --v9;
              v3 = v17;
            }
            while ( v9 );
            FileA = v22;
          }
          for ( ; v8; --v8 )
            v3 = dword_411550[(unsigned __int8)(v3 ^ *v7++)] ^ (v3 >> 8);
        }
        while ( NumberOfBytesRead == 0x80000 );
        HeapFree(hHeap, 0, v6);
      }
      CloseHandle(FileA);
    }
  }
  return ~v3;
}
// 411550: using guessed type int dword_411550[128];

//----- (0040DBB0) --------------------------------------------------------
unsigned int __stdcall sub_40DBB0(LPCSTR lpFileName)
{
  return sub_40D990(lpFileName, 0i64, -1i64);
}

//----- (0040DBD0) --------------------------------------------------------
_DWORD *__cdecl sub_40DBD0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  return result;
}

//----- (0040DCC0) --------------------------------------------------------
int __cdecl sub_40DCC0(_DWORD *a1)
{
  int v1; // ecx
  unsigned __int16 *v2; // ecx
  int *v3; // edx
  int v4; // esi
  int v5; // esi
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // esi
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // esi
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // esi
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // esi
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // esi
  int v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // esi
  int v32; // eax
  int v33; // ecx
  int v34; // edx
  int v35; // esi
  int v36; // eax
  int v37; // ecx
  int v38; // edx
  int v39; // esi
  int v40; // eax
  int v41; // edi
  int v42; // edx
  int v43; // ecx
  int v44; // eax
  int v45; // esi
  int v46; // edx
  int v47; // ecx
  int v48; // eax
  int v49; // esi
  int v50; // edi
  int v51; // ecx
  int v52; // eax
  int v53; // edx
  int v54; // esi
  int v55; // ecx
  int v56; // eax
  int v57; // edx
  int v58; // esi
  int v59; // ecx
  int v60; // eax
  int v61; // edx
  int v62; // esi
  int v63; // ecx
  int v64; // eax
  int v65; // edx
  int v66; // esi
  int v67; // ecx
  int v68; // eax
  int v69; // edx
  int v70; // ebx
  int v71; // esi
  int v72; // eax
  int result; // eax
  int v74; // [esp+14h] [ebp-40h] BYREF
  int v75; // [esp+18h] [ebp-3Ch]
  int v76; // [esp+1Ch] [ebp-38h]
  int v77; // [esp+20h] [ebp-34h]
  int v78; // [esp+24h] [ebp-30h]
  int v79; // [esp+28h] [ebp-2Ch]
  int v80; // [esp+2Ch] [ebp-28h]
  int v81; // [esp+30h] [ebp-24h]
  int v82; // [esp+34h] [ebp-20h]
  int v83; // [esp+38h] [ebp-1Ch]
  int v84; // [esp+3Ch] [ebp-18h]
  int v85; // [esp+40h] [ebp-14h]
  int v86; // [esp+44h] [ebp-10h]
  int v87; // [esp+48h] [ebp-Ch]
  int v88; // [esp+4Ch] [ebp-8h]
  int v89; // [esp+50h] [ebp-4h]

  v2 = (unsigned __int16 *)(v1 + 2);
  v3 = &v74;
  v4 = 16;
  do
  {
    *v3++ = *((unsigned __int8 *)v2 - 2) | ((*((unsigned __int8 *)v2 - 1) | (*v2 << 8)) << 8);
    v2 += 2;
    --v4;
  }
  while ( v4 );
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  v8 = v5 + __ROL4__(v74 + (v5 & v6 | v7 & ~v5) + *a1 - 680876936, 7);
  v9 = v8 + __ROL4__(v75 + (v8 & v5 | v6 & ~v8) + v7 - 389564586, 12);
  v10 = v9 + __ROR4__(v76 + (v8 & v9 | v5 & ~v9) + v6 + 606105819, 15);
  v11 = v10 + __ROR4__(v77 + (v10 & v9 | v8 & ~v10) + v5 - 1044525330, 10);
  v12 = v11 + __ROL4__(v78 + (v11 & v10 | v9 & ~v11) + v8 - 176418897, 7);
  v13 = v12 + __ROL4__(v79 + (v12 & v11 | v10 & ~v12) + v9 + 1200080426, 12);
  v14 = v13 + __ROR4__(v80 + (v12 & v13 | v11 & ~v13) + v10 - 1473231341, 15);
  v15 = v14 + __ROR4__(v81 + (v14 & v13 | v12 & ~v14) + v11 - 45705983, 10);
  v16 = v15 + __ROL4__(v82 + (v15 & v14 | v13 & ~v15) + v12 + 1770035416, 7);
  v17 = v16 + __ROL4__(v83 + (v16 & v15 | v14 & ~v16) + v13 - 1958414417, 12);
  v18 = v17 + __ROR4__(v84 + (v16 & v17 | v15 & ~v17) + v14 - 42063, 15);
  v19 = v18 + __ROR4__(v85 + (v18 & v17 | v16 & ~v18) + v15 - 1990404162, 10);
  v20 = v19 + __ROL4__(v86 + (v19 & v18 | v17 & ~v19) + v16 + 1804603682, 7);
  v21 = v20 + __ROL4__(v87 + (v20 & v19 | v18 & ~v20) + v17 - 40341101, 12);
  v22 = v21 + __ROR4__(v88 + (v20 & v21 | v19 & ~v21) + v18 - 1502002290, 15);
  v23 = v22 + __ROR4__(v89 + (v22 & v21 | v20 & ~v22) + v19 + 1236535329, 10);
  v24 = v23 + __ROL4__(v75 + (v23 & v21 | v22 & ~v21) + v20 - 165796510, 5);
  v25 = v24 + __ROL4__(v80 + (v24 & v22 | v23 & ~v22) + v21 - 1069501632, 9);
  v26 = v25 + __ROL4__(v85 + (v23 & v25 | v24 & ~v23) + v22 + 643717713, 14);
  v27 = v26 + __ROR4__(v74 + (v24 & v26 | v25 & ~v24) + v23 - 373897302, 12);
  v28 = v27 + __ROL4__(v79 + (v27 & v25 | v26 & ~v25) + v24 - 701558691, 5);
  v29 = v28 + __ROL4__(v84 + (v28 & v26 | v27 & ~v26) + v25 + 38016083, 9);
  v30 = v29 + __ROL4__(v89 + (v27 & v29 | v28 & ~v27) + v26 - 660478335, 14);
  v31 = v30 + __ROR4__(v78 + (v28 & v30 | v29 & ~v28) + v27 - 405537848, 12);
  v32 = v31 + __ROL4__(v83 + (v31 & v29 | v30 & ~v29) + v28 + 568446438, 5);
  v33 = v32 + __ROL4__(v88 + (v32 & v30 | v31 & ~v30) + v29 - 1019803690, 9);
  v34 = v33 + __ROL4__(v77 + (v31 & v33 | v32 & ~v31) + v30 - 187363961, 14);
  v35 = v34 + __ROR4__(v82 + (v32 & v34 | v33 & ~v32) + v31 + 1163531501, 12);
  v36 = v35 + __ROL4__(v87 + (v35 & v33 | v34 & ~v33) + v32 - 1444681467, 5);
  v37 = v36 + __ROL4__(v76 + (v36 & v34 | v35 & ~v34) + v33 - 51403784, 9);
  v38 = v37 + __ROL4__(v81 + (v35 & v37 | v36 & ~v35) + v34 + 1735328473, 14);
  v39 = v38 + __ROR4__(v86 + (v36 & v38 | v37 & ~v36) + v35 - 1926607734, 12);
  v40 = v39 + __ROL4__(v79 + (v39 ^ v38 ^ v37) + v36 - 378558, 4);
  v41 = v40 + __ROL4__(v82 + (v40 ^ v39 ^ v38) + v37 - 2022574463, 11);
  v42 = v41 + __ROL4__(v85 + (v40 ^ v39 ^ v41) + v38 + 1839030562, 16);
  v43 = v42 + __ROR4__(v88 + (v40 ^ v42 ^ v41) + v39 - 35309556, 9);
  v44 = v43 + __ROL4__(v75 + (v43 ^ v42 ^ v41) + v40 - 1530992060, 4);
  v45 = v44 + __ROL4__(v78 + (v44 ^ v43 ^ v42) + v41 + 1272893353, 11);
  v46 = v45 + __ROL4__(v81 + (v44 ^ v43 ^ v45) + v42 - 155497632, 16);
  v47 = v46 + __ROR4__(v84 + (v44 ^ v46 ^ v45) + v43 - 1094730640, 9);
  v48 = v47 + __ROL4__(v87 + (v47 ^ v46 ^ v45) + v44 + 681279174, 4);
  v49 = v48 + __ROL4__(v74 + (v48 ^ v47 ^ v46) + v45 - 358537222, 11);
  v50 = v49 + __ROL4__(v77 + (v48 ^ v47 ^ v49) + v46 - 722521979, 16);
  v51 = v50 + __ROR4__(v80 + (v48 ^ v50 ^ v49) + v47 + 76029189, 9);
  v52 = v51 + __ROL4__(v83 + (v51 ^ v50 ^ v49) + v48 - 640364487, 4);
  v53 = v52 + __ROL4__(v86 + (v52 ^ v51 ^ v50) + v49 - 421815835, 11);
  v54 = v53 + __ROL4__(v89 + (v52 ^ v51 ^ v53) + v50 + 530742520, 16);
  v55 = v54 + __ROR4__(v76 + (v52 ^ v54 ^ v53) + v51 - 995338651, 9);
  v56 = v55 + __ROL4__(v74 + (v54 ^ (v55 | ~v53)) + v52 - 198630844, 6);
  v57 = v56 + __ROL4__(v81 + (v55 ^ (v56 | ~v54)) + v53 + 1126891415, 10);
  v58 = v57 + __ROL4__(v88 + (v56 ^ (v57 | ~v55)) + v54 - 1416354905, 15);
  v59 = v58 + __ROR4__(v79 + (v57 ^ (v58 | ~v56)) + v55 - 57434055, 11);
  v60 = v59 + __ROL4__(v86 + (v58 ^ (v59 | ~v57)) + v56 + 1700485571, 6);
  v61 = v60 + __ROL4__(v77 + (v59 ^ (v60 | ~v58)) + v57 - 1894986606, 10);
  v62 = v61 + __ROL4__(v84 + (v60 ^ (v61 | ~v59)) + v58 - 1051523, 15);
  v63 = v62 + __ROR4__(v75 + (v61 ^ (v62 | ~v60)) + v59 - 2054922799, 11);
  v64 = v63 + __ROL4__(v82 + (v62 ^ (v63 | ~v61)) + v60 + 1873313359, 6);
  v65 = v64 + __ROL4__(v89 + (v63 ^ (v64 | ~v62)) + v61 - 30611744, 10);
  v66 = v65 + __ROL4__(v80 + (v64 ^ (v65 | ~v63)) + v62 - 1560198380, 15);
  v67 = v66 + __ROR4__(v87 + (v65 ^ (v66 | ~v64)) + v63 + 1309151649, 11);
  v68 = v67 + __ROL4__(v78 + (v66 ^ (v67 | ~v65)) + v64 - 145523070, 6);
  v69 = v68 + __ROL4__(v85 + (v67 ^ (v68 | ~v66)) + v65 - 1120210379, 10);
  v70 = v68 + *a1;
  v71 = v69 + __ROL4__(v76 + (v68 ^ (v69 | ~v67)) + v66 + 718787259, 15);
  v72 = v83 + (v69 ^ (v71 | ~v68));
  *a1 = v70;
  a1[1] += v71 + __ROR4__(v72 + v67 - 343485551, 11);
  a1[2] += v71;
  result = v69 + a1[3];
  a1[3] = result;
  return result;
}
// 40DCCB: variable 'v1' is possibly undefined

//----- (0040E3A0) --------------------------------------------------------
unsigned int __cdecl sub_40E3A0(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v3; // eax
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // eax
  unsigned int v7; // ebp
  unsigned int j; // edi
  unsigned int result; // eax
  unsigned int v10; // ebx
  int v11; // ebp
  int v12; // ecx

  v3 = a1[4] + 8 * a3;
  v4 = (a1[4] >> 3) & 0x3F;
  a1[4] = v3;
  if ( v3 < 8 * a3 )
    ++a1[5];
  a1[5] += a3 >> 29;
  v5 = 64 - v4;
  if ( a3 < 64 - v4 )
  {
    v7 = 0;
  }
  else
  {
    for ( i = 0; i < v5; ++i )
      *((_BYTE *)a1 + v4 + i + 24) = *(_BYTE *)(i + a2);
    sub_40DCC0(a1);
    v7 = v5;
    for ( j = v5 + 63; j < a3; v7 += 64 )
    {
      sub_40DCC0(a1);
      j += 64;
    }
    v4 = 0;
  }
  result = 0;
  v10 = a3 - v7;
  if ( a3 != v7 )
  {
    v11 = a2 + v7;
    v12 = (int)a1 + v4 + 24;
    do
    {
      *(_BYTE *)(v12 + result) = *(_BYTE *)(result + v11);
      ++result;
    }
    while ( result < v10 );
  }
  return result;
}

//----- (0040E460) --------------------------------------------------------
void *__cdecl sub_40E460(int a1, char *a2)
{
  unsigned int v2; // ecx
  char *v3; // eax
  unsigned int v4; // ecx
  int v5; // eax
  _BYTE *v6; // ecx
  char *v7; // eax
  int v8; // esi
  char v10[8]; // [esp+8h] [ebp-8h] BYREF

  v2 = 0;
  v3 = a2 + 16;
  do
  {
    v10[v2] = *v3;
    v10[v2 + 1] = v3[1];
    v10[v2 + 2] = v3[2];
    v10[v2 + 3] = v3[3];
    v2 += 4;
    v3 += 4;
  }
  while ( v2 < 8 );
  v4 = (*((_DWORD *)a2 + 4) >> 3) & 0x3F;
  v5 = 56;
  if ( v4 >= 0x38 )
    v5 = 120;
  sub_40E3A0(a2, (int)&unk_412330, v5 - v4);
  sub_40E3A0(a2, (int)v10, 8u);
  v6 = (_BYTE *)(a1 + 1);
  v7 = a2 + 2;
  v8 = 4;
  do
  {
    *(v6 - 1) = *(v7 - 2);
    *v6 = *(v7 - 1);
    v6[1] = *v7;
    v6[2] = v7[1];
    v7 += 4;
    v6 += 4;
    --v8;
  }
  while ( v8 );
  return memset(a2, 0, 0x58u);
}

//----- (0040E515) --------------------------------------------------------
_DWORD *__stdcall sub_40E515(int a1, int a2)
{
  int v3; // eax
  void (__stdcall *v4)(int); // eax

  if ( a2 == -1 )
    return sub_40EC40(a1 + 16, *(_DWORD *)a1 + 8);
  if ( a2 >= *(_DWORD *)(a1 + 8) )
  {
    v3 = a2 + *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 8) = v3;
    *(_DWORD *)(a1 + 12) = HeapReAlloc(hHeap, 8u, *(LPVOID *)(a1 + 12), 4 * v3);
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * a2) )
  {
    v4 = *(void (__stdcall **)(int))(a1 + 20);
    if ( v4 )
      v4(a2);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * a2) = HeapAlloc(hHeap, 8u, *(_DWORD *)a1);
  }
  return *(_DWORD **)(*(_DWORD *)(a1 + 12) + 4 * a2);
}

//----- (0040E59A) --------------------------------------------------------
_DWORD *__stdcall sub_40E59A(int a1, int a2)
{
  _DWORD *result; // eax
  bool v3; // zf

  result = (_DWORD *)a2;
  v3 = a2 == 0;
  if ( a2 >= 0 )
  {
    if ( a2 < *(_DWORD *)(a1 + 8) )
      result = *(_DWORD **)(*(_DWORD *)(a1 + 12) + 4 * a2);
    v3 = result == 0;
  }
  if ( !v3 && !*result )
    return 0;
  return result;
}

//----- (0040E5BF) --------------------------------------------------------
void **__stdcall sub_40E5BF(size_t *a1, int a2)
{
  void **result; // eax

  if ( a2 < 0 || a2 >= (int)a1[2] )
    return (void **)sub_40EC6D(a1 + 4, a2);
  result = (void **)(a1[3] + 4 * a2);
  if ( *result )
    return (void **)memset(*result, 0, *a1);
  return result;
}

//----- (0040E5FA) --------------------------------------------------------
_DWORD *__stdcall sub_40E5FA(int a1, int a2, int a3)
{
  _DWORD *v3; // esi

  v3 = HeapAlloc(hHeap, 8u, 0x20u);
  v3[4] = 0;
  *v3 = a1;
  v3[5] = a3;
  v3[1] = a2;
  v3[2] = a2;
  v3[3] = HeapAlloc(hHeap, 8u, 4 * a2);
  return v3;
}

//----- (0040E643) --------------------------------------------------------
int __stdcall sub_40E643(int a1)
{
  return a1;
}

//----- (0040E64A) --------------------------------------------------------
LPVOID __stdcall sub_40E64A(SIZE_T dwBytes, void (__cdecl *a2)(LPVOID), int a3)
{
  LPVOID v3; // eax
  LPVOID v4; // esi

  v3 = HeapAlloc(hHeap, 8u, dwBytes);
  v4 = v3;
  if ( a2 )
    a2(v3);
  return v4;
}

//----- (0040E672) --------------------------------------------------------
void __stdcall sub_40E672(_DWORD *a1)
{
  _DWORD *v1; // esi

  v1 = a1;
  if ( a1[5] )
  {
    sub_40EB0A(a1);
    while ( sub_40EB2F(v1, (int *)&a1) )
      ((void (__stdcall *)(_DWORD *))v1[5])(a1);
  }
}

//----- (0040E6A0) --------------------------------------------------------
void sub_40E6A0()
{
  InitializeCriticalSection(&stru_4139F0);
  dword_4139EC = 0;
}
// 4139EC: using guessed type int dword_4139EC;

//----- (0040E6B3) --------------------------------------------------------
char *__stdcall sub_40E6B3(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  _DWORD *i; // eax
  _DWORD *v6; // esi
  int v7; // edi
  int v8; // eax
  char *v10; // esi
  int v11; // [esp+Ch] [ebp-4h]

  v4 = a1 + 4;
  v11 = 0;
  if ( (((_BYTE)a1 + 4) & 3) != 0 )
    v4 += 4 - (((_BYTE)a1 + 4) & 3);
  if ( (a4 & 4) == 0 )
  {
    v10 = (char *)HeapAlloc(hHeap, 0, 0x38u);
    if ( v10 )
    {
      *((_DWORD *)v10 + 5) = a2;
      *((_DWORD *)v10 + 6) = a3;
      *(_DWORD *)v10 = 0;
      *((_DWORD *)v10 + 1) = 0;
      *((_DWORD *)v10 + 2) = 0;
      *((_DWORD *)v10 + 4) = v4;
      if ( (a4 & 3) == 1 )
      {
        *((_DWORD *)v10 + 7) = 1;
        InitializeCriticalSection((LPCRITICAL_SECTION)(v10 + 32));
      }
      else
      {
        *((_DWORD *)v10 + 7) = 0;
      }
    }
    return v10;
  }
  sub_40EB96(&stru_413A08, sub_40E6A0);
  EnterCriticalSection(&stru_4139F0);
  for ( i = (_DWORD *)dword_4139EC; ; i = (_DWORD *)*i )
  {
    if ( !i )
      goto LABEL_11;
    if ( i[3] == v4 && i[4] == a4 )
      break;
  }
  ++i[5];
  v11 = i[2];
  if ( v11 )
  {
LABEL_16:
    v7 = v11;
    goto LABEL_17;
  }
LABEL_11:
  v6 = HeapAlloc(hHeap, 0, 0x18u);
  if ( !v6 )
    goto LABEL_16;
  v7 = sub_40E6B3(v4 - 4, a2, a3, a4 & 0xFFFFFFFB);
  if ( v7 )
  {
    *(_DWORD *)(v7 + 8) = v6;
    v6[1] = 0;
    v6[4] = a4;
    v8 = dword_4139EC;
    v6[2] = v7;
    v6[3] = v4;
    v6[5] = 1;
    *v6 = v8;
    if ( v8 )
      *(_DWORD *)(v8 + 4) = v6;
    dword_4139EC = (int)v6;
  }
LABEL_17:
  LeaveCriticalSection(&stru_4139F0);
  return (char *)v7;
}
// 4139EC: using guessed type int dword_4139EC;
// 413A08: using guessed type union _RTL_RUN_ONCE stru_413A08;

//----- (0040E7E9) --------------------------------------------------------
_DWORD *__stdcall sub_40E7E9(int a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // ecx
  signed int v6; // eax
  signed int v7; // ebx
  _DWORD *v8; // eax
  _DWORD *v10; // [esp+10h] [ebp-4h]

  v10 = 0;
  if ( *(_DWORD *)(a1 + 28) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = (*(int *)(a1 + 12) >> 4) & 0xFFFFFFF0;
    if ( v7 < v6 || (v6 = *(_DWORD *)(a1 + 24), v7 > v6) )
      v7 = v6;
    v8 = HeapAlloc(hHeap, 0, v7 * *(_DWORD *)(a1 + 16) + 24);
    v1 = v8;
    if ( v8 )
    {
      v8[3] = v7;
    }
    else
    {
      v1 = HeapAlloc(hHeap, 0, *(_DWORD *)(a1 + 16) + 24);
      if ( !v1 )
      {
LABEL_29:
        v3 = v10;
        goto LABEL_30;
      }
      v1[3] = 1;
    }
    *(_DWORD *)(a1 + 12) += v1[3];
    v1[4] = 1;
    v1[5] = 0;
    v1[2] = 0;
    if ( (int)v1[3] <= 1 )
    {
      *v1 = *(_DWORD *)a1;
      v1[1] = 0;
      *(_DWORD *)a1 = v1;
    }
    else
    {
      *v1 = *(_DWORD *)(a1 + 4);
      v1[1] = 0;
      *(_DWORD *)(a1 + 4) = v1;
    }
    if ( *v1 )
      *(_DWORD *)(*v1 + 4) = v1;
    v10 = v1 + 6;
    goto LABEL_29;
  }
  v2 = v1[5];
  if ( v2 <= 0 )
  {
    v4 = v1[4];
    v5 = (int)v1 + v4 * *(_DWORD *)(a1 + 16) + 24;
    v1[4] = v4 + 1;
    v3 = (_DWORD *)v5;
  }
  else
  {
    v3 = (_DWORD *)v1[2];
    v1[2] = *v3;
    v1[5] = v2 - 1;
  }
  if ( !v1[5] && v1[4] >= v1[3] )
  {
    if ( *v1 )
      *(_DWORD *)(*v1 + 4) = v1[1];
    if ( v1 == *(_DWORD **)(a1 + 4) )
      *(_DWORD *)(a1 + 4) = *v1;
    else
      *(_DWORD *)v1[1] = *v1;
    *v1 = *(_DWORD *)a1;
    v1[1] = 0;
    *(_DWORD *)a1 = v1;
    if ( *v1 )
      *(_DWORD *)(*v1 + 4) = v1;
  }
LABEL_30:
  if ( *(_DWORD *)(a1 + 28) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  if ( !v3 )
    return 0;
  *v3 = v1;
  return v3 + 1;
}

//----- (0040E948) --------------------------------------------------------
void __stdcall sub_40E948(int a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // ecx

  if ( *(_DWORD *)(a1 + 28) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  v2 = *(_DWORD **)(a2 - 4);
  *(_DWORD *)(a2 - 4) = v2[2];
  v3 = ++v2[5];
  v2[2] = a2 - 4;
  v4 = v2[4];
  if ( v3 == v4 )
  {
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2[1];
    if ( v2 == *(_DWORD **)(a1 + 4) )
      *(_DWORD *)(a1 + 4) = *v2;
    else
      *(_DWORD *)v2[1] = *v2;
    *(_DWORD *)(a1 + 12) -= v2[3];
    HeapFree(hHeap, 0, v2);
  }
  else if ( v3 == 1 && v4 >= v2[3] )
  {
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2[1];
    if ( v2 == *(_DWORD **)a1 )
      *(_DWORD *)a1 = *v2;
    else
      *(_DWORD *)v2[1] = *v2;
    v5 = *(_DWORD *)(a1 + 4);
    v2[1] = 0;
    *v2 = v5;
    *(_DWORD *)(a1 + 4) = v2;
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2;
  }
  if ( *(_DWORD *)(a1 + 28) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
}

//----- (0040EA01) --------------------------------------------------------
void __stdcall sub_40EA01(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // edi

  if ( *(_DWORD *)(a1 + 28) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  v1 = *(_DWORD **)(a1 + 4);
  if ( v1 )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      HeapFree(hHeap, 0, v1);
      v1 = v2;
    }
    while ( v2 );
  }
  v3 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    do
    {
      v4 = (_DWORD *)*v3;
      HeapFree(hHeap, 0, v3);
      v3 = v4;
    }
    while ( v4 );
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  if ( *(_DWORD *)(a1 + 28) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
}

//----- (0040EA6F) --------------------------------------------------------
void __stdcall sub_40EA6F(char *lpMem)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax

  v1 = (_DWORD *)*((_DWORD *)lpMem + 2);
  if ( v1 )
  {
    EnterCriticalSection(&stru_4139F0);
    if ( (int)--*(_DWORD *)(*((_DWORD *)lpMem + 2) + 20) <= 0 )
    {
      *((_DWORD *)lpMem + 2) = 0;
      sub_40EA6F(lpMem);
      if ( *v1 )
        *(_DWORD *)(*v1 + 4) = v1[1];
      v2 = (_DWORD *)v1[1];
      if ( v2 )
        *v2 = *v1;
      if ( (_DWORD *)dword_4139EC == v1 )
        dword_4139EC = *v1;
      HeapFree(hHeap, 0, v1);
    }
    LeaveCriticalSection(&stru_4139F0);
  }
  else
  {
    sub_40EA01((int)lpMem);
    if ( *((_DWORD *)lpMem + 7) )
      DeleteCriticalSection((LPCRITICAL_SECTION)(lpMem + 32));
    HeapFree(hHeap, 0, lpMem);
  }
}
// 4139EC: using guessed type int dword_4139EC;

//----- (0040EB0A) --------------------------------------------------------
_DWORD *__stdcall sub_40EB0A(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // ecx

  result = a1;
  v2 = (_DWORD *)a1[4];
  a1[6] = 0;
  a1[7] = v2;
  if ( v2 && *v2 )
  {
    do
    {
      v2 = (_DWORD *)*v2;
      a1[7] = v2;
    }
    while ( *v2 );
  }
  return result;
}

//----- (0040EB2F) --------------------------------------------------------
_DWORD *__stdcall sub_40EB2F(_DWORD *a1, int *a2)
{
  _DWORD *result; // eax
  int v3; // edx
  _DWORD **v4; // esi
  _DWORD *v5; // esi
  int v6; // edx

  result = 0;
  do
  {
    v3 = a1[6];
    if ( v3 < 0 || v3 >= a1[2] )
      break;
    v4 = (_DWORD **)(a1[3] + 4 * v3);
    if ( *v4 )
    {
      v5 = *v4;
      if ( *v5 )
      {
        result = v5;
        *a2 = v3;
      }
    }
    ++a1[6];
  }
  while ( !result );
  if ( !result )
  {
    v6 = a1[7];
    if ( v6 )
    {
      result = (_DWORD *)(v6 + 8);
      *a2 = v6 + 8;
      a1[7] = *(_DWORD *)(a1[7] + 4);
    }
  }
  return result;
}

//----- (0040EB82) --------------------------------------------------------
int __stdcall sub_40EB82(int a1, void (*a2)(void), _DWORD *a3)
{
  a2();
  *a3 = 4;
  return 1;
}

//----- (0040EB96) --------------------------------------------------------
void __stdcall sub_40EB96(union _RTL_RUN_ONCE *a1, void *a2)
{
  int v2; // ebx
  HMODULE LibraryA; // eax
  HMODULE v4; // edi
  BOOL (__stdcall *InitOnceExecuteOnce)(PINIT_ONCE, PINIT_ONCE_FN, PVOID, LPVOID *); // eax
  signed __int32 v6; // eax
  LPVOID v7; // [esp+Ch] [ebp-4h] BYREF

  v2 = 0;
  LibraryA = LoadLibraryA("Kernel32.dll");
  v4 = LibraryA;
  if ( !LibraryA )
    goto LABEL_5;
  InitOnceExecuteOnce = (BOOL (__stdcall *)(PINIT_ONCE, PINIT_ONCE_FN, PVOID, LPVOID *))GetProcAddress(
                                                                                          LibraryA,
                                                                                          "InitOnceExecuteOnce");
  if ( InitOnceExecuteOnce )
  {
    InitOnceExecuteOnce(a1, (PINIT_ONCE_FN)sub_40EB82, a2, &v7);
    v2 = 1;
  }
  FreeLibrary(v4);
  if ( !v2 )
  {
LABEL_5:
    v6 = sub_40EC2F((volatile signed __int32 *)a1, 1, 0);
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        while ( a1->Ptr != (PVOID)2 )
          Sleep(0);
      }
    }
    else
    {
      ((void (*)(void))a2)();
      sub_40EC24((volatile __int32 *)a1, 2);
    }
  }
}
// 40EB96: using guessed type LPVOID var_4;

//----- (0040EC24) --------------------------------------------------------
__int32 __cdecl sub_40EC24(volatile __int32 *a1, __int32 a2)
{
  return _InterlockedExchange(a1, a2);
}

//----- (0040EC2F) --------------------------------------------------------
signed __int32 __cdecl sub_40EC2F(volatile signed __int32 *a1, signed __int32 a2, signed __int32 a3)
{
  return _InterlockedCompareExchange(a1, a2, a3);
}

//----- (0040EC40) --------------------------------------------------------
_DWORD *__cdecl sub_40EC40(int a1, SIZE_T dwBytes)
{
  _DWORD *v2; // eax

  v2 = HeapAlloc(hHeap, 8u, dwBytes);
  if ( v2 )
  {
    if ( *(_DWORD *)a1 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 4) = v2;
      *v2 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v2;
  }
  return v2 + 2;
}

//----- (0040EC6D) --------------------------------------------------------
BOOL __cdecl sub_40EC6D(_DWORD *a1, int a2)
{
  _DWORD **v2; // eax
  int v3; // edx

  v2 = (_DWORD **)(a2 - 8);
  v3 = *(_DWORD *)(a2 - 8);
  if ( *a1 == a2 - 8 )
  {
    *a1 = v3;
    if ( *v2 )
      (*v2)[1] = 0;
  }
  else
  {
    *v2[1] = v3;
    if ( *v2 )
      (*v2)[1] = v2[1];
  }
  return HeapFree(hHeap, 0, v2);
}

//----- (0040ECAD) --------------------------------------------------------
_DWORD *__stdcall sub_40ECAD(int a1, int a2, int a3, int *a4, int *a5)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int v7; // ebx
  int v8; // edi

  sub_40EDD5(*a5);
  v5 = HeapAlloc(hHeap, 0, a2 * a1 + 24);
  v6 = v5;
  if ( v5 )
  {
    v5[1] = a1;
    v5[4] = a2;
    v5[5] = a3;
    v5[2] = a4;
    v5[3] = a5;
    *v5 = 1;
    v6 = v5 + 6;
    memset(v5 + 6, 0, a2 * a1);
    *a5 = (int)v6;
    if ( sub_40F46C(a4) )
    {
      v7 = a2;
      if ( a2 > 0 )
      {
        v8 = (int)v6;
        do
        {
          sub_40F4B8(v8, a4);
          v8 += a1;
          --v7;
        }
        while ( v7 );
      }
    }
  }
  return v6;
}

//----- (0040ED3E) --------------------------------------------------------
_DWORD *__stdcall sub_40ED3E(int a1, int a2, int a3, int *a4, int *a5)
{
  int v6; // esi
  int v7; // edi
  int *v8; // eax
  int v9; // ecx
  int i; // edx
  _DWORD *result; // eax
  int *v12; // [esp+8h] [ebp-8h]
  int v13; // [esp+Ch] [ebp-4h]
  int *v14; // [esp+28h] [ebp+18h]

  v14 = a5 + 1;
  v6 = a1;
  v7 = 1;
  v13 = 1;
  v12 = a5;
  if ( a1 > 0 )
  {
    v8 = v14;
    do
    {
      v13 *= *v8;
      v9 = 1;
      for ( i = v7; i < v6; ++i )
        v9 *= v14[i];
      *v8 = v9;
      ++v7;
      ++v8;
      --a1;
    }
    while ( a1 );
  }
  result = sub_40ECAD(a2, v13, a3, a4, v12);
  *(result - 6) = v6;
  return result;
}

//----- (0040EDAC) --------------------------------------------------------
void sub_40EDAC()
{
  dword_413A28 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_40ECAD;
  dword_413A2C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_40ED3E;
  dword_413A38 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_40EEEC;
  dword_413A44 = sub_40EE20;
}
// 413A28: using guessed type int (__stdcall *dword_413A28)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A2C: using guessed type int (__stdcall *dword_413A2C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A38: using guessed type int (__stdcall *dword_413A38)(_DWORD, _DWORD, _DWORD);
// 413A44: using guessed type int (__stdcall *dword_413A44)(_DWORD);

//----- (0040EDD5) --------------------------------------------------------
BOOL __stdcall sub_40EDD5(int a1)
{
  int v1; // esi
  int v2; // ebx
  int i; // edi
  BOOL result; // eax

  if ( a1 )
  {
    v1 = a1 - 24;
    if ( *(_DWORD *)(a1 - 24 + 8) )
    {
      v2 = 0;
      for ( i = a1; v2 < *(_DWORD *)(v1 + 16); ++v2 )
      {
        sub_40F91A(i, *(int **)(v1 + 8));
        i += *(_DWORD *)(v1 + 4);
      }
    }
    **(_DWORD **)(v1 + 12) = 0;
    return HeapFree(hHeap, 0, (LPVOID)v1);
  }
  return result;
}

//----- (0040EE25) --------------------------------------------------------
_DWORD *__stdcall sub_40EE25(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // esi
  int v4; // ebx
  int **v5; // eax
  int **v6; // esi
  int v7; // ebx
  int i; // ebx

  result = *(_DWORD **)(*a2 - 8);
  v3 = *a2 - 24;
  if ( result != (_DWORD *)a1 )
  {
    if ( (int)result > a1 )
    {
      if ( *(_DWORD *)(v3 + 8) )
      {
        v4 = a1;
        if ( a1 < (int)result )
        {
          do
          {
            sub_40F91A(v4 * *(_DWORD *)(v3 + 4) + v3 + 24, *(int **)(v3 + 8));
            ++v4;
          }
          while ( v4 < *(_DWORD *)(v3 + 16) );
        }
      }
    }
    v5 = (int **)HeapReAlloc(hHeap, 8u, (LPVOID)v3, a1 * *(_DWORD *)(v3 + 4) + 24);
    v6 = v5;
    v7 = 0;
    if ( v5 )
    {
      if ( sub_40F46C(v5[2]) )
      {
        if ( a1 > 0 )
        {
          do
          {
            if ( v7 >= (int)v6[4] )
              break;
            sub_40FABB((int)v6 + v7 * (_DWORD)v6[1] + 24, v6[2]);
            ++v7;
          }
          while ( v7 < a1 );
        }
        for ( i = (int)v6[4]; i < a1; ++i )
          sub_40F4B8((int)v6 + i * (_DWORD)v6[1] + 24, v6[2]);
      }
      result = a2;
      v6[4] = (int *)a1;
      *a2 = v6 + 6;
    }
    else
    {
      result = a2;
      *a2 = 0;
    }
  }
  return result;
}

//----- (0040EEEC) --------------------------------------------------------
int __stdcall sub_40EEEC(_DWORD *Src, int a2, int a3)
{
  int v4; // ebx
  int *v5; // edi
  int v6; // eax
  _BYTE *v7; // edi
  _BYTE *v8; // ebx
  int v9; // eax
  int v11; // [esp+4h] [ebp-4h]
  char *Srca; // [esp+10h] [ebp+8h]

  v11 = 0;
  if ( Src )
  {
    if ( a2 )
    {
      v4 = *(Src - 6);
      v5 = (int *)(a2 - 24);
      if ( v4 == *(_DWORD *)(a2 - 24) )
      {
        if ( a3 )
        {
          v5 = sub_40ECAD(*(Src - 5), *(Src - 2), *(Src - 1), (int *)*(Src - 4), (int *)v5[3]) - 6;
          *v5 = v4;
        }
        if ( v4 > 1 )
          memcpy((void *)(v5[3] + 4), (const void *)(*(Src - 3) + 4), 4 * v4);
        v6 = *(Src - 2);
        if ( v6 == v5[4] )
        {
          v7 = v5 + 6;
          if ( *(Src - 4) )
          {
            Srca = 0;
            v8 = Src;
            if ( v6 > 0 )
            {
              do
              {
                sub_40F63D(v7, *(Src - 5), (char *)*(Src - 4), v8);
                v9 = *(Src - 5);
                v8 += v9;
                v7 += v9;
                ++Srca;
              }
              while ( (int)Srca < *(Src - 2) );
            }
          }
          else
          {
            memcpy(v7, Src, v6 * *(Src - 5));
          }
          return 1;
        }
      }
    }
  }
  return v11;
}

//----- (0040EFC0) --------------------------------------------------------
void *sub_40EFC0()
{
  void *result; // eax

  dword_413BD0 = HeapCreate(0, 0x1000u, 0);
  String2 = 0;
  dword_413BD4 = 16;
  result = HeapAlloc(dword_413BD0, 0, 0x10u);
  lpMem = result;
  return result;
}

//----- (0040F010) --------------------------------------------------------
BOOL sub_40F010()
{
  HeapFree(dword_413BD0, 0, lpMem);
  return HeapDestroy(dword_413BD0);
}

//----- (0040F040) --------------------------------------------------------
const CHAR *__stdcall sub_40F040(LPVOID *a1, const CHAR *a2)
{
  LPVOID v2; // eax
  const CHAR *result; // eax
  const CHAR *v4; // [esp+0h] [ebp-4h]

  v4 = (const CHAR *)(String2 - a2);
  if ( *a1 )
    v2 = HeapReAlloc(dword_413BD0, 0, *a1, (SIZE_T)(v4 + 5));
  else
    v2 = HeapAlloc(dword_413BD0, 0, (SIZE_T)(v4 + 5));
  *a1 = v2;
  sub_40F360(*a1, (char *)lpMem + (_DWORD)a2, (int)v4);
  result = a2;
  String2 = a2;
  return result;
}

//----- (0040F0C0) --------------------------------------------------------
int __fastcall sub_40F0C0(char *a1, char *a2)
{
  char v2; // ah
  char v3; // al

  if ( !a2 )
    a2 = (char *)&unk_41205B;
  if ( !a1 )
    a1 = (char *)&unk_41205B;
  while ( 1 )
  {
    v2 = *a2++;
    v3 = *a1++;
    if ( v2 != v3 )
      break;
    if ( !v2 )
      return 1;
  }
  return 0;
}

//----- (0040F0F0) --------------------------------------------------------
void __stdcall __spoils<ecx> sub_40F0F0(LPVOID lpMem)
{
  if ( lpMem )
    HeapFree(dword_413BD0, 0, lpMem);
}

//----- (0040F120) --------------------------------------------------------
char *__fastcall sub_40F120(int a1, char *a2)
{
  char *result; // eax
  int v4; // [esp+4h] [ebp-8h]
  char *v5; // [esp+8h] [ebp-4h]

  if ( a2 )
  {
    v4 = strlen(a2);
    v5 = sub_40F2C0(v4, (int)String2);
    return sub_40F360(v5, a2, v4);
  }
  else
  {
    result = (char *)lpMem + (_DWORD)String2;
    *((_BYTE *)lpMem + (_DWORD)String2) = 0;
  }
  return result;
}

//----- (0040F180) --------------------------------------------------------
void __stdcall sub_40F180(LPVOID *a1, char *Str)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( Str )
  {
    v2 = strlen(Str);
    *a1 = HeapAlloc(dword_413BD0, 0, v2 + 5);
    sub_40F360(*a1, Str, v2);
  }
}

//----- (0040F1D0) --------------------------------------------------------
int __stdcall sub_40F1D0(LPVOID *a1, char *Str)
{
  LPVOID v2; // eax
  int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( Str )
  {
    v4 = strlen(Str);
    if ( *a1 )
      v2 = HeapReAlloc(dword_413BD0, 0, *a1, v4 + 5);
    else
      v2 = HeapAlloc(dword_413BD0, 0, v4 + 5);
    *a1 = v2;
    sub_40F360(*a1, Str, v4);
  }
  else if ( *a1 )
  {
    HeapFree(dword_413BD0, 0, *a1);
    *a1 = 0;
  }
  return v4 + 1;
}

//----- (0040F280) --------------------------------------------------------
int __stdcall sub_40F280(unsigned int a1)
{
  if ( a1 < (unsigned int)lpMem || (char *)a1 > (char *)lpMem + (int)String2 )
    return 0;
  else
    return a1 - (_DWORD)lpMem + 1;
}

//----- (0040F2C0) --------------------------------------------------------
char *__stdcall sub_40F2C0(int a1, int a2)
{
  const CHAR *v3; // [esp+0h] [ebp-8h]

  v3 = &String2[a1];
  if ( (int)&String2[a1] >= (int)(dword_413BD4 - 4) )
  {
    dword_413BD4 = (SIZE_T)(v3 + 0x4000);
    lpMem = HeapReAlloc(dword_413BD0, 0, lpMem, (SIZE_T)(v3 + 16389));
  }
  String2 = (LPCSTR)(a1 + a2);
  return (char *)lpMem + a2;
}

//----- (0040F340) --------------------------------------------------------
char *__stdcall sub_40F340(int a1)
{
  return (char *)lpMem + a1 - 1;
}

//----- (0040F360) --------------------------------------------------------
char *__stdcall sub_40F360(_DWORD *a1, _DWORD *a2, int a3)
{
  char *result; // eax
  _BYTE *v4; // [esp+0h] [ebp-4h]

  result = (char *)a1 + a3;
  v4 = (char *)a1 + a3;
  while ( a3 > 0 )
  {
    *a1++ = *a2++;
    result = (char *)(a3 - 4);
    a3 -= 4;
  }
  *v4 = 0;
  return result;
}

//----- (0040F3B0) --------------------------------------------------------
char *__stdcall sub_40F3B0(int a1)
{
  return (char *)lpMem + a1;
}

//----- (0040F3C0) --------------------------------------------------------
const CHAR *__stdcall sub_40F3C0(const CHAR *a1)
{
  const CHAR *result; // eax

  result = a1;
  String2 = a1;
  *((_BYTE *)lpMem + (_DWORD)a1) = 0;
  return result;
}

//----- (0040F3E0) --------------------------------------------------------
const CHAR *__stdcall sub_40F3E0(int a1)
{
  const CHAR *result; // eax

  result = &String2[-a1];
  String2 -= a1;
  return result;
}

//----- (0040F400) --------------------------------------------------------
unsigned int __stdcall sub_40F400(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;
    return v3 / (unsigned int)a2;
  }
}

//----- (0040F46C) --------------------------------------------------------
int __stdcall sub_40F46C(int *a1)
{
  int *v1; // esi
  int result; // eax
  int v3; // eax
  int v4; // ecx

  v1 = a1;
  result = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      do
      {
        v4 = *v1;
        if ( *v1 == -1 )
          return result;
        ++v1;
      }
      while ( v4 < -7 );
      if ( v4 <= -4 )
      {
        result = 1;
        goto LABEL_11;
      }
      if ( v4 == -3 )
        break;
      if ( v4 == -2 )
      {
        v3 = v1[3];
        v1 += 4;
LABEL_9:
        result = sub_40F46C(v3);
LABEL_11:
        if ( result )
          return result;
      }
    }
    v3 = v1[2];
    v1 += 3;
    goto LABEL_9;
  }
  return result;
}

//----- (0040F4B8) --------------------------------------------------------
int __stdcall sub_40F4B8(int a1, int *a2)
{
  int *v2; // esi
  int result; // eax
  int v5; // ecx
  int *v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v10; // eax
  int *v11; // esi
  int v12; // eax
  int *v13; // esi
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // eax
  int *v18; // esi
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  int *v22; // esi
  int v23; // ecx
  int v24; // edx
  int v25; // edx
  int v26; // eax
  int *v27; // esi
  int v28; // ecx
  int v29; // edx
  int v30; // edx
  int v31; // edx
  _DWORD *v32; // edx
  int v33; // [esp-10h] [ebp-20h]
  int v34; // [esp-Ch] [ebp-1Ch]
  int v35; // [esp-Ch] [ebp-1Ch]
  int v36; // [esp-Ch] [ebp-1Ch]
  int v37; // [esp+8h] [ebp-8h]
  int v38; // [esp+8h] [ebp-8h]
  int v39; // [esp+Ch] [ebp-4h]
  int v40; // [esp+Ch] [ebp-4h]
  int v41; // [esp+18h] [ebp+8h]
  int v42; // [esp+18h] [ebp+8h]
  int v43; // [esp+18h] [ebp+8h]
  int v44; // [esp+1Ch] [ebp+Ch]
  int v45; // [esp+1Ch] [ebp+Ch]
  int v46; // [esp+1Ch] [ebp+Ch]

  v2 = a2;
  for ( result = *a2; *v2 != -1; result = *v2 )
  {
    ++v2;
    switch ( result )
    {
      case -7:
        v26 = *v2;
        v27 = v2 + 1;
        v28 = *v27++;
        v29 = *v27++;
        v40 = v29;
        v30 = *v27++;
        v43 = v30;
        v31 = *v27;
        v2 = v27 + 1;
        v46 = v31;
        if ( v28 > 0 )
        {
          v32 = (_DWORD *)(v26 + a1 + 4);
          v38 = v28;
          do
          {
            *v32++ = *v2++;
            --v38;
          }
          while ( v38 );
        }
        dword_413A2C(v28, v40, v43, v46, a1 + v26);
        break;
      case -6:
        v21 = *v2;
        v22 = v2 + 1;
        v23 = *v22++;
        v24 = *v22++;
        v42 = v24;
        v25 = *v22++;
        v36 = *v22;
        v2 = v22 + 1;
        dword_413A34(v23, v42, v25, a1 + v21, v36);
        break;
      case -5:
        v17 = *v2;
        v18 = v2 + 1;
        v19 = *v18++;
        v20 = *v18++;
        v35 = *v18;
        v2 = v18 + 1;
        dword_413A30(v19, a1 + v17, v20, v35);
        break;
      case -4:
        v12 = *v2;
        v13 = v2 + 1;
        v14 = *v13++;
        v15 = *v13++;
        v45 = v15;
        v16 = *v13++;
        v33 = *v13;
        v2 = v13 + 1;
        dword_413A28(v14, v45, v16, v33, a1 + v12);
        break;
      case -3:
        v10 = *v2;
        v11 = v2 + 2;
        v34 = *v11;
        v2 = v11 + 1;
        sub_40F4B8(a1 + v10, v34);
        break;
      case -2:
        v5 = *v2;
        v6 = v2 + 1;
        v7 = *v6++;
        v8 = *v6++;
        v39 = v8;
        v9 = *v6;
        v2 = v6 + 1;
        v44 = v9;
        if ( v5 > 0 )
        {
          v41 = a1 + v7;
          v37 = v5;
          do
          {
            sub_40F4B8(v41, v44);
            v41 += v39;
            --v37;
          }
          while ( v37 );
        }
        break;
    }
  }
  return result;
}
// 413A28: using guessed type int (__stdcall *dword_413A28)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A2C: using guessed type int (__stdcall *dword_413A2C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A30: using guessed type int (__stdcall *dword_413A30)(_DWORD, _DWORD, _DWORD, _DWORD);
// 413A34: using guessed type int (__stdcall *dword_413A34)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040F63D) --------------------------------------------------------
void __stdcall sub_40F63D(_BYTE *a1, signed int Size, char *Str, _BYTE *Src)
{
  signed int v5; // ecx
  char *v6; // edi
  int v7; // esi
  LPVOID *v8; // eax
  void *v9; // ecx
  int v10; // eax
  size_t *v11; // edi
  size_t v12; // ecx
  char *v13; // ecx
  char *v14; // ecx
  int v15; // edx
  int v16; // eax
  size_t *v17; // edi
  size_t v18; // eax
  char *v19; // ecx
  int v20; // ecx
  size_t v21; // eax
  int v22; // eax
  int v23; // ecx
  _DWORD *v24; // eax
  int v25; // ecx
  _DWORD *v26; // eax
  int v27; // ecx
  _DWORD *v28; // edi
  size_t v29; // eax
  int v30; // eax
  signed int v31; // eax
  int v32; // [esp+4h] [ebp-14h]
  char *v33; // [esp+8h] [ebp-10h]
  int v34; // [esp+10h] [ebp-8h]
  int v35; // [esp+14h] [ebp-4h]
  size_t v36; // [esp+20h] [ebp+8h]
  size_t v37; // [esp+20h] [ebp+8h]
  size_t v38; // [esp+20h] [ebp+8h]
  size_t v39; // [esp+20h] [ebp+8h]
  size_t v40; // [esp+20h] [ebp+8h]
  size_t v41; // [esp+20h] [ebp+8h]
  size_t v42; // [esp+20h] [ebp+8h]
  char *Stra; // [esp+28h] [ebp+10h]
  char *Strb; // [esp+28h] [ebp+10h]
  char *Strc; // [esp+28h] [ebp+10h]

  v5 = 0;
  v35 = 0;
  if ( Src != a1 )
  {
    v6 = Str;
    if ( Str )
    {
      v7 = *(_DWORD *)Str;
      if ( *(_DWORD *)Str != -1 )
      {
        while ( 1 )
        {
          v6 += 4;
          switch ( v7 )
          {
            case -7:
              v7 = *(_DWORD *)v6;
              v27 = *(_DWORD *)&a1[*(_DWORD *)v6];
              v28 = v6 + 4;
              Strc = (char *)*v28;
              v6 = (char *)&v28[*v28 + 4];
              v29 = *(_DWORD *)&Src[v7];
              v42 = v29;
              if ( v27 )
              {
                dword_413A44(v27);
                v29 = v42;
              }
              if ( v29 )
              {
                v30 = dword_413A28(
                        *(_DWORD *)(v29 - 20),
                        *(_DWORD *)(v29 - 8),
                        *(_DWORD *)(v29 - 4),
                        *(_DWORD *)(v29 - 16),
                        &a1[v7]);
                *(_DWORD *)(v30 - 24) = *(_DWORD *)(v42 - 24);
                dword_413A38(v42, v30, 0);
              }
              v16 = 4 * (_DWORD)Strc + 4;
              goto LABEL_40;
            case -6:
              v7 = *(_DWORD *)v6;
              v25 = *(_DWORD *)&a1[*(_DWORD *)v6];
              v26 = *(_DWORD **)&Src[*(_DWORD *)v6];
              v6 += 20;
              v41 = (size_t)v26;
              if ( v25 )
              {
                dword_413A4C(v25);
                v26 = (_DWORD *)v41;
              }
              if ( v26 )
              {
                dword_413A34(v26[7], v26[8], v26[4], &a1[v7], v26[9]);
                dword_413A40(*(_DWORD *)&Src[v7], *(_DWORD *)&a1[v7], 0);
              }
              break;
            case -5:
              v7 = *(_DWORD *)v6;
              v23 = *(_DWORD *)&a1[*(_DWORD *)v6];
              v24 = *(_DWORD **)&Src[*(_DWORD *)v6];
              v6 += 16;
              v40 = (size_t)v24;
              if ( v23 )
              {
                dword_413A48(v23);
                v24 = (_DWORD *)v40;
              }
              if ( v24 )
              {
                dword_413A30(v24[10] - 8, &a1[v7], v24[6], v24[11]);
                dword_413A3C(*(_DWORD *)&Src[v7], *(_DWORD *)&a1[v7], 0);
              }
              v39 = 8;
              goto LABEL_41;
            case -4:
              v7 = *(_DWORD *)v6;
              v20 = *(_DWORD *)&a1[*(_DWORD *)v6];
              v21 = *(_DWORD *)&Src[*(_DWORD *)v6];
              v6 += 20;
              v38 = v21;
              if ( v20 )
              {
                dword_413A44(v20);
                v21 = v38;
              }
              if ( v21 )
              {
                v22 = dword_413A28(
                        *(_DWORD *)(v21 - 20),
                        *(_DWORD *)(v21 - 8),
                        *(_DWORD *)(v21 - 4),
                        *(_DWORD *)(v21 - 16),
                        &a1[v7]);
                dword_413A38(v38, v22, 0);
              }
              break;
            case -3:
              v7 = *(_DWORD *)v6;
              v17 = (size_t *)(v6 + 4);
              v18 = *v17++;
              v19 = (char *)*v17;
              v6 = (char *)(v17 + 1);
              v37 = v18;
              sub_40F63D(&a1[v7], v18, v19, &Src[v7]);
              v16 = v37;
LABEL_40:
              v39 = v16;
              goto LABEL_41;
            case -2:
              v10 = *(_DWORD *)v6;
              v11 = (size_t *)(v6 + 4);
              v7 = *v11++;
              v12 = *v11++;
              v36 = v12;
              v13 = (char *)*v11;
              v6 = (char *)(v11 + 1);
              v32 = v10;
              v33 = v13;
              if ( v10 > 0 )
              {
                v14 = &a1[v7];
                v15 = Src - a1;
                Strb = &a1[v7];
                v34 = v10;
                while ( 1 )
                {
                  sub_40F63D(v14, v36, v33, &v14[v15]);
                  Strb += v36;
                  if ( !--v34 )
                    break;
                  v14 = Strb;
                  v15 = Src - a1;
                }
                v10 = v32;
              }
              v16 = v36 * v10;
              goto LABEL_40;
            default:
              Stra = *(char **)&Src[v7];
              v8 = (LPVOID *)&a1[v7];
              v9 = *(void **)&a1[v7];
              if ( v9 )
              {
                sub_40F0F0(v9);
                v8 = (LPVOID *)&a1[v7];
                *(_DWORD *)&a1[v7] = 0;
              }
              if ( Stra )
                sub_40F180(v8, Stra);
              break;
          }
          v39 = 4;
LABEL_41:
          if ( v35 < v7 )
            memcpy(&a1[v35], &Src[v35], v7 - v35);
          v31 = v7 + v39;
          v7 = *(_DWORD *)v6;
          v35 = v31;
          if ( *(_DWORD *)v6 == -1 )
          {
            v5 = v31;
            break;
          }
        }
      }
      if ( v5 < Size )
        memcpy(&a1[v5], &Src[v5], Size - v5);
    }
    else
    {
      memcpy(a1, Src, Size);
    }
  }
}
// 413A28: using guessed type int (__stdcall *dword_413A28)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A30: using guessed type int (__stdcall *dword_413A30)(_DWORD, _DWORD, _DWORD, _DWORD);
// 413A34: using guessed type int (__stdcall *dword_413A34)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413A38: using guessed type int (__stdcall *dword_413A38)(_DWORD, _DWORD, _DWORD);
// 413A3C: using guessed type int (__stdcall *dword_413A3C)(_DWORD, _DWORD, _DWORD);
// 413A40: using guessed type int (__stdcall *dword_413A40)(_DWORD, _DWORD, _DWORD);
// 413A44: using guessed type int (__stdcall *dword_413A44)(_DWORD);
// 413A48: using guessed type int (__stdcall *dword_413A48)(_DWORD);
// 413A4C: using guessed type int (__stdcall *dword_413A4C)(_DWORD);

//----- (0040F91A) --------------------------------------------------------
void __stdcall __spoils<edx,ecx> sub_40F91A(int a1, int *a2)
{
  int *v2; // esi
  int v3; // eax
  void *v5; // eax
  int v6; // ecx
  int *v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  int v11; // ebx
  int v12; // eax
  int *v13; // esi
  int v14; // eax
  int v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-8h] [ebp-18h]
  int v17; // [esp-8h] [ebp-18h]
  int v18; // [esp+Ch] [ebp-4h]
  int v19; // [esp+18h] [ebp+8h]
  int v20; // [esp+1Ch] [ebp+Ch]

  v2 = a2;
  v3 = *a2;
  if ( *a2 != -1 )
  {
    while ( 1 )
    {
      ++v2;
      if ( v3 == -7 )
        break;
      if ( v3 == -6 )
      {
        v17 = *(_DWORD *)(*v2 + a1);
        v2 += 5;
        dword_413A4C(v17);
      }
      else
      {
        if ( v3 != -5 )
        {
          if ( v3 != -4 )
          {
            if ( v3 == -3 )
            {
              v12 = *v2;
              v13 = v2 + 2;
              v15 = *v13;
              v2 = v13 + 1;
              sub_40F91A(a1 + v12, v15);
            }
            else if ( v3 == -2 )
            {
              v6 = *v2;
              v7 = v2 + 1;
              v8 = *v7++;
              v9 = *v7++;
              v18 = v9;
              v10 = *v7;
              v2 = v7 + 1;
              v19 = v10;
              if ( v6 > 0 )
              {
                v11 = v8 + a1;
                v20 = v6;
                do
                {
                  sub_40F91A(v11, v19);
                  v11 += v18;
                  --v20;
                }
                while ( v20 );
              }
            }
            else
            {
              v5 = *(void **)(v3 + a1);
              if ( v5 )
                sub_40F0F0(v5);
            }
            goto LABEL_20;
          }
          v14 = *v2;
          v2 += 5;
          goto LABEL_19;
        }
        v16 = *(_DWORD *)(*v2 + a1);
        v2 += 4;
        dword_413A48(v16);
      }
LABEL_20:
      v3 = *v2;
      if ( *v2 == -1 )
        return;
    }
    v14 = *v2;
    v2 += v2[1] + 5;
LABEL_19:
    dword_413A44(*(_DWORD *)(v14 + a1));
    goto LABEL_20;
  }
}
// 413A44: using guessed type int (__stdcall *dword_413A44)(_DWORD);
// 413A48: using guessed type int (__stdcall *dword_413A48)(_DWORD);
// 413A4C: using guessed type int (__stdcall *dword_413A4C)(_DWORD);

//----- (0040FA10) --------------------------------------------------------
int __usercall sub_40FA10@<eax>(double a1@<st0>)
{
  int result; // eax
  int v2; // edx
  float v3; // [esp+0h] [ebp-24h]
  int v4; // [esp+18h] [ebp-Ch]

  if ( dword_412370 )
    return (int)a1;
  *(float *)&v4 = a1;
  v2 = v4;
  result = (__int64)a1;
  if ( result || (v2 = (unsigned __int64)(__int64)a1 >> 32, (v2 & 0x7FFFFFFF) != 0) )
  {
    if ( v2 >= 0 )
    {
      v3 = a1 - (double)(__int64)a1;
      result -= __CFADD__(LODWORD(v3), 0x7FFFFFFF);
    }
    else
    {
      return (__PAIR64__(result, -(float)(a1 - (double)(__int64)a1)) + 0x7FFFFFFF) >> 32;
    }
  }
  return result;
}
// 40FA10: could not find valid save-restore pair for ebp
// 412370: using guessed type int dword_412370;

//----- (0040FABB) --------------------------------------------------------
int __stdcall sub_40FABB(int a1, int *a2)
{
  int *v2; // esi
  int result; // eax
  int v5; // ecx
  int *v6; // esi
  int v7; // eax
  int v8; // ebx
  int v9; // ebx
  int v10; // ebx
  int v11; // eax
  int *v12; // esi
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // [esp-Ch] [ebp-14h]
  int v17; // [esp+4h] [ebp-4h]
  int v18; // [esp+10h] [ebp+8h]
  int v19; // [esp+14h] [ebp+Ch]

  v2 = a2;
  result = *a2;
  if ( *a2 != -1 )
  {
    while ( 1 )
    {
      ++v2;
      if ( result == -7 )
        break;
      if ( result == -6 )
      {
        v15 = *v2;
        v2 += 5;
        *(_DWORD *)(*(_DWORD *)(a1 + v15) + 48) = a1 + v15;
      }
      else
      {
        if ( result != -5 )
        {
          if ( result != -4 )
          {
            if ( result == -3 )
            {
              v11 = *v2;
              v12 = v2 + 2;
              v16 = *v12;
              v2 = v12 + 1;
              sub_40FABB(a1 + v11, v16);
            }
            else if ( result == -2 )
            {
              v5 = *v2;
              v6 = v2 + 1;
              v7 = *v6++;
              v8 = *v6++;
              v17 = v8;
              v9 = *v6;
              v2 = v6 + 1;
              v18 = v9;
              if ( v5 > 0 )
              {
                v10 = v7 + a1;
                v19 = v5;
                do
                {
                  sub_40FABB(v10, v18);
                  v10 += v17;
                  --v19;
                }
                while ( v19 );
              }
            }
            goto LABEL_18;
          }
          v13 = *v2;
          v2 += 5;
          goto LABEL_17;
        }
        v14 = *v2 + a1;
        *(_DWORD *)(*(_DWORD *)v14 + 12) = v14 + 4;
        v2 += 4;
        *(_DWORD *)(*(_DWORD *)v14 + 36) = v14;
      }
LABEL_18:
      result = *v2;
      if ( *v2 == -1 )
        return result;
    }
    v13 = *v2;
    v2 += v2[1] + 5;
LABEL_17:
    *(_DWORD *)(*(_DWORD *)(a1 + v13) - 12) = a1 + v13;
    goto LABEL_18;
  }
  return result;
}

//----- (0040FBA0) --------------------------------------------------------
CHAR *__stdcall sub_40FBA0(LPCCH lpMultiByteStr)
{
  unsigned int v1; // edi
  CHAR *v2; // ebx
  WCHAR *v3; // esi
  int v4; // eax
  int v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  if ( !lpMultiByteStr )
    lpMultiByteStr = (LPCCH)&unk_411002;
  v1 = strlen(lpMultiByteStr);
  v2 = (CHAR *)malloc(4 * v1 + 1);
  if ( v2 )
  {
    if ( v1 )
    {
      v3 = (WCHAR *)malloc(2 * v1 + 2);
      if ( v3 )
      {
        v4 = MultiByteToWideChar(0, 0, lpMultiByteStr, v1 + 1, v3, v1 + 1);
        v6 = WideCharToMultiByte(0xFDE9u, 0, v3, v4, v2, 4 * v1 + 1, 0, 0);
        free(v3);
      }
    }
    v2[v6] = 0;
  }
  return v2;
}

//----- (0040FC50) --------------------------------------------------------
void __stdcall sub_40FC50(void *Block)
{
  free(Block);
}

//----- (0040FC60) --------------------------------------------------------
int __stdcall sub_40FC60(int a1, int a2)
{
  char *v2; // edi
  char *v3; // esi
  int result; // eax
  int v5; // [esp+8h] [ebp-4h] BYREF

  v2 = (char *)a1;
  if ( !a1 )
    v2 = (char *)&unk_411002;
  v5 = strlen(v2);
  a1 = sub_40FF10(v2, v5);
  v3 = sub_40F2C0(a1, a2);
  result = sub_410130(v3, &a1, v2, &v5);
  v3[a1] = 0;
  return result;
}

//----- (0040FD25) --------------------------------------------------------
LRESULT __stdcall sub_40FD25(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HANDLE PropA; // edi
  int v5; // eax
  int v6; // ecx
  void *v7; // eax
  char Buffer[52]; // [esp+8h] [ebp-38h] BYREF
  WNDPROC lpPrevWndFunc; // [esp+3Ch] [ebp-4h]

  sprintf(Buffer, "PB_GadgetStack_%i", hInstance);
  PropA = GetPropA(hWnd, Buffer);
  if ( !PropA )
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  lpPrevWndFunc = (WNDPROC)*((_DWORD *)PropA + 5);
  if ( Msg == 130 )
  {
    v5 = sub_40E643(dword_413B04);
    if ( *(_DWORD *)(v5 + 16) )
      v6 = **(_DWORD **)(v5 + 12);
    else
      v6 = *(_DWORD *)v5;
    if ( *(_DWORD *)PropA == v6 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 16) = 0;
    }
    v7 = (void *)*((_DWORD *)PropA + 2);
    if ( v7 )
      HeapFree(hHeap, 0, v7);
    HeapFree(hHeap, 0, PropA);
    RemovePropA(hWnd, Buffer);
  }
  if ( lpPrevWndFunc )
    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  else
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}
// 413B04: using guessed type int dword_413B04;

//----- (0040FDEE) --------------------------------------------------------
HWND __stdcall sub_40FDEE(HWND a1)
{
  int v1; // eax
  int v2; // esi
  HWND v3; // eax
  _DWORD *PropA; // eax
  _DWORD *v5; // edi
  LPVOID v6; // eax
  _DWORD *v7; // edi
  char Buffer[52]; // [esp+8h] [ebp-38h] BYREF
  HWND hWnd; // [esp+3Ch] [ebp-4h]

  v1 = sub_40E643(dword_413B04);
  v2 = v1;
  if ( *(_DWORD *)(v1 + 16) )
    v3 = **(HWND **)(v1 + 12);
  else
    v3 = *(HWND *)v1;
  hWnd = v3;
  if ( a1 )
  {
    sprintf(Buffer, "PB_GadgetStack_%i", hInstance);
    if ( hWnd )
    {
      PropA = GetPropA(hWnd, Buffer);
      PropA[1] = *(_DWORD *)v2;
      PropA[2] = *(_DWORD *)(v2 + 12);
      PropA[3] = *(_DWORD *)(v2 + 16);
      PropA[4] = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 12) = 0;
    }
    v5 = GetPropA(a1, Buffer);
    if ( v5 )
    {
      if ( *(_DWORD *)(v2 + 12) )
        HeapFree(hHeap, 0, *(LPVOID *)(v2 + 12));
      *(_DWORD *)v2 = v5[1];
      *(_DWORD *)(v2 + 12) = v5[2];
      *(_DWORD *)(v2 + 16) = v5[3];
      *(_DWORD *)(v2 + 20) = v5[4];
      v5[2] = 0;
    }
    else
    {
      if ( *(_DWORD *)(v2 + 12) )
      {
        *(_DWORD *)(v2 + 16) = 0;
      }
      else
      {
        v6 = HeapAlloc(hHeap, 8u, 0x28u);
        *(_DWORD *)(v2 + 16) = 0;
        *(_DWORD *)(v2 + 12) = v6;
        *(_DWORD *)(v2 + 20) = 10;
      }
      *(_DWORD *)v2 = a1;
      v7 = HeapAlloc(hHeap, 8u, 0x18u);
      *v7 = a1;
      SetPropA(a1, Buffer, v7);
      v7[5] = SetWindowLongA(a1, -4, (LONG)sub_40FD25);
    }
    *(_DWORD *)(v2 + 4) = 0;
  }
  return hWnd;
}
// 413B04: using guessed type int dword_413B04;

//----- (0040FF10) --------------------------------------------------------
int __stdcall sub_40FF10(char *a1, int a2)
{
  unsigned int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  char v5; // [esp+8h] [ebp-4h]

  v4 = 0;
  v3 = (unsigned int)&a1[a2];
  while ( (unsigned int)a1 < v3 )
  {
    v5 = *a1;
    if ( (*a1 & 0x80) != 0 )
    {
      if ( (v5 & 0xE0) == 192 && (unsigned int)(a1 + 1) < v3 )
      {
        ++a1;
        ++v4;
        if ( (*a1 & 0xC0) == 128 )
          ++a1;
      }
      else if ( (v5 & 0xF0) == 224 && (unsigned int)(a1 + 2) < v3 )
      {
        ++v4;
        if ( (a1[1] & 0xC0) == 128 && (a1[2] & 0xC0) == 128 )
        {
          a1 += 3;
        }
        else if ( (a1[1] & 0xC0) == 128 )
        {
          a1 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else if ( (v5 & 0xF8) == 240 && (unsigned int)(a1 + 3) < v3 )
      {
        ++v4;
        if ( (a1[1] & 0xC0) == 128 && (a1[2] & 0xC0) == 128 && (a1[3] & 0xC0) == 128 )
        {
          a1 += 4;
        }
        else if ( (a1[1] & 0xC0) == 128 && (a1[2] & 0xC0) == 128 )
        {
          a1 += 3;
        }
        else if ( (a1[1] & 0xC0) == 128 )
        {
          a1 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else
      {
        ++a1;
      }
    }
    else
    {
      ++v4;
      ++a1;
    }
  }
  return v4;
}

//----- (00410130) --------------------------------------------------------
int __stdcall sub_410130(_BYTE *a1, _DWORD *a2, char *a3, _DWORD *a4)
{
  unsigned int v5; // [esp+0h] [ebp-Ch]
  char v6; // [esp+4h] [ebp-8h]
  unsigned __int16 v7; // [esp+4h] [ebp-8h]
  _BYTE *v8; // [esp+8h] [ebp-4h]

  v8 = a1;
  v5 = (unsigned int)&a3[*a4];
  while ( (unsigned int)a3 < v5 )
  {
    v6 = *a3;
    if ( (*a3 & 0x80) != 0 )
    {
      if ( (v6 & 0xE0) == 192 && (unsigned int)(a3 + 1) < v5 )
      {
        if ( (*++a3 & 0xC0) == 128 )
        {
          v7 = *a3 & 0x3F | ((v6 & 0x1F) << 6);
          if ( v7 >= 0x100u )
            *a1 = 63;
          else
            *a1 = v7;
          ++a1;
          ++a3;
        }
        else
        {
          *a1++ = 63;
        }
      }
      else if ( (v6 & 0xF0) == 224 && (unsigned int)(a3 + 2) < v5 )
      {
        *a1++ = 63;
        if ( (a3[1] & 0xC0) == 128 && (a3[2] & 0xC0) == 128 )
        {
          a3 += 3;
        }
        else if ( (a3[1] & 0xC0) == 128 )
        {
          a3 += 2;
        }
        else
        {
          ++a3;
        }
      }
      else if ( (v6 & 0xF8) == 240 && (unsigned int)(a3 + 3) < v5 )
      {
        *a1++ = 63;
        if ( (a3[1] & 0xC0) == 128 && (a3[2] & 0xC0) == 128 && (a3[3] & 0xC0) == 128 )
        {
          a3 += 4;
        }
        else if ( (a3[1] & 0xC0) == 128 && (a3[2] & 0xC0) == 128 )
        {
          a3 += 3;
        }
        else if ( (a3[1] & 0xC0) == 128 )
        {
          a3 += 2;
        }
        else
        {
          ++a3;
        }
      }
      else
      {
        ++a3;
      }
    }
    else
    {
      *a1++ = v6;
      ++a3;
    }
  }
  *a2 = a1 - v8;
  return 0;
}

// nfuncs=377 queued=327 decompiled=327 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 327 function(s)"
