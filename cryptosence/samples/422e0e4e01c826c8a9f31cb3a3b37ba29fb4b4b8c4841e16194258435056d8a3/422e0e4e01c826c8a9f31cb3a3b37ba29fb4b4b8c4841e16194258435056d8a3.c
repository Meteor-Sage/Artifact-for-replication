/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// LPSTR __stdcall GetCommandLineA();
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// LCID __stdcall GetThreadLocale();
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// INT __stdcall SysReAllocStringLen(BSTR *pbstr, const OLECHAR *psz, unsigned int len);
// void __stdcall SysFreeString(BSTR bstrString);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetVersion();
int sub_401098();
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
int sub_4010FC();
// _DWORD *__usercall sub_40114C@<eax>(_DWORD *result@<eax>);
// char __usercall sub_401154@<al>(int *a1@<eax>, int *a2@<edx>);
// int *__usercall sub_401184@<eax>(int *result@<eax>);
// char __usercall sub_40119C@<al>(int *a1@<eax>, int *a2@<edx>, int *a3@<ecx>);
// int *__usercall sub_40120C@<eax>(int *a1@<eax>, int **a2@<edx>);
// char __usercall sub_4012A0@<al>(int a1@<eax>, int *a2@<edx>);
// char __usercall sub_401304@<al>(void *a1@<eax>, int a2@<edx>, int *a3@<ecx>);
// unsigned int *__usercall sub_40137C@<eax>(unsigned int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>);
// LPVOID __usercall sub_401434@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>);
// unsigned int __usercall sub_4014C8@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>);
// int *__usercall sub_401548@<eax>(int a1@<eax>, int *a2@<edx>);
// int *__usercall sub_4015D8@<eax>(void *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>);
// char __usercall sub_4016FC@<al>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>);
char sub_401788();
void sub_40184C();
// _DWORD *__usercall sub_40192C@<eax>(_DWORD *a1@<eax>);
// int *__usercall sub_401990@<eax>(unsigned int a1@<eax>);
// unsigned int *__usercall sub_4019C0@<eax>(unsigned int *result@<eax>, int a2@<edx>);
// int __usercall sub_4019F0@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_401A14@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __usercall sub_401A3C@<eax>(int a1@<eax>);
// int __usercall sub_401AAC@<eax>(int *a1@<eax>);
// char __usercall sub_401AE4@<al>(unsigned int *a1@<eax>, int a2@<edx>);
// char __usercall sub_401B94@<al>(unsigned int *a1@<eax>, int a2@<edx>);
int sub_401C1C();
// char __usercall sub_401C68@<al>(unsigned int *a1@<eax>);
// int __usercall sub_401CF4@<eax>(int a1@<eax>);
// int __usercall sub_401D20@<eax>(void *a1@<eax>, int a2@<edx>);
// int __usercall sub_401D54@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_401D80@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_401E74@<eax>(int a1@<eax>);
// int __usercall sub_402004@<eax>(int a1@<eax>);
// unsigned int __usercall sub_4021A8@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_402384@<eax>(char *a1@<eax>, int a2@<edx>);
// int __usercall sub_402448@<eax>(int a1@<eax>);
// int __usercall sub_402468@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_402488@<eax>(_DWORD *result@<eax>, int a2@<edx>);
// void __usercall __noreturn sub_4024D8(int a1@<eax>, int a2@<edx>, void *a3@<ecx>);
// void __usercall __noreturn sub_4024E4(char a1@<al>, int a2@<edx>, void *a3@<ecx>);
// void __usercall __noreturn sub_402530(char a1@<al>, void *a2@<ecx>);
// _DWORD *__usercall sub_40253C@<eax>(int a1@<eax>);
// int __usercall sub_40254C@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>);
// unsigned __int8 __usercall sub_40258C@<al>(unsigned __int8 result@<al>);
// int __usercall sub_402598@<eax>(int a1@<eax>);
// int __usercall sub_4025F0@<eax>(int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>);
// __int16 __usercall sub_402660@<ax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall Delphi_Random_402680@<eax>(unsigned int a1@<eax>);
// int __usercall sub_40269C@<eax>(int result@<eax>, char **a2@<edx>);
// int __usercall sub_402770@<eax>(_BYTE *a1@<eax>, char *a2@<edx>);
// int __usercall sub_40277C@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// char *__usercall sub_4027A0@<eax>(char *result@<eax>, int a2@<edx>);
// int __stdcall GetKeyboardType(int nTypeFlag);
int sub_402808();
__int16 sub_402838();
int __cdecl sub_4028A9(int, int); // weak
void sub_4028FC();
// _DWORD *__usercall sub_402908@<eax>(_DWORD *result@<eax>);
int sub_402914();
// void __usercall __spoils<edx,ecx> sub_402930(int a1@<eax>, int a2@<edx>);
// void __usercall __spoils<edx,ecx> sub_40296C(int a1@<ebx>);
void sub_402980();
void __fastcall __spoils<edx,ecx> sub_4029A0(int a1, int a2);
void __fastcall sub_4029C8(int a1, int a2);
void __spoils<ecx> sub_4029E4();
int __cdecl sub_402B30(int a1, int a2);
int __cdecl sub_402B68(int a1, int a2);
void __cdecl sub_402BBC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __stdcall sub_402BEC(unsigned int a1, int a2, int a3);
void __thiscall __noreturn sub_402C04(void *this, int *a2);
int __cdecl sub_402CA4(struct _EXCEPTION_POINTERS ExceptionInfo); // idb
// struct _EXCEPTION_REGISTRATION_RECORD **__usercall sub_402D44@<eax>(struct _EXCEPTION_REGISTRATION_RECORD *a1@<ebp>);
int sub_402D64();
int sub_402D8C();
int sub_402DEC();
// int __usercall sub_402E4C@<eax>(int a1@<eax>, int a2@<edx>, struct _EXCEPTION_REGISTRATION_RECORD *a3@<ebp>);
unsigned int __fastcall sub_402E8C(int a1);
BOOL __stdcall sub_402EE8(int a1, int a2, int a3);
void __thiscall sub_402F18(void *this);
void __thiscall __noreturn sub_402FA4(void *this);
// void __usercall __noreturn sub_40307C(int a1@<eax>, void *a2@<ecx>);
void __noreturn sub_403088(void); // weak
// _DWORD *__usercall sub_403094@<eax>(_DWORD *result@<eax>);
// int __usercall sub_4030B8@<eax>(int result@<eax>, int a2@<edx>);
// volatile __int32 *__usercall sub_4030E8@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>);
// volatile __int32 *__usercall sub_40312C@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>);
// int __usercall sub_403158@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_403184@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>);
// _DWORD *__usercall sub_4031B4@<eax>(char **a1@<eax>);
// _DWORD *__usercall sub_4031C4@<eax>(char **a1@<eax>, char *a2@<edx>);
// _DWORD *__usercall sub_4031F4@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>);
// int __usercall sub_40320C@<eax>(int result@<eax>);
// char **__usercall sub_403214@<eax>(char **result@<eax>, __int32 a2@<edx>);
// volatile __int32 *__usercall sub_403258@<eax>(volatile __int32 *a1@<eax>, char *a2@<edx>, char *a3@<ecx>);
// volatile __int32 *__usercall sub_4032CC@<eax>(char **a1@<eax>, int a2@<edx>);
// int __usercall Delphi_CompareCall_403358@<eax>(int result@<eax>, int *a2@<edx>);
// int __usercall sub_4033FC@<eax>(int result@<eax>);
// char *__usercall sub_40340C@<eax>(char *result@<eax>);
// char *__usercall sub_403418@<eax>(char **a1@<eax>);
// char *__usercall sub_40345C@<eax>(char **@<eax>);
// _DWORD *__userpurge Delphi_Copy_403464@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char **a4);
// char *__usercall sub_4034A4@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>);
// _BYTE *__usercall sub_4034EC@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>);
// _DWORD *__usercall sub_403534@<eax>(char **a1@<eax>, int a2@<edx>);
// OLECHAR **__usercall sub_4035A0@<eax>(OLECHAR **result@<eax>);
// void __usercall sub_4035B8(OLECHAR **a1@<eax>, int a2@<edx>);
// OLECHAR **__usercall sub_4035DC@<eax>(OLECHAR **a1@<eax>, const OLECHAR *a2@<edx>);
// int __usercall sub_403600@<eax>(int a1@<eax>, int a2@<edx>);
int __thiscall sub_403634(void *this);
// OLECHAR **__usercall sub_40364C@<eax>(OLECHAR **result@<eax>, char *a2@<edx>, int a3@<ecx>);
int __thiscall sub_403738(void *this);
// int __usercall sub_403750@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// void *__userpurge sub_40386C@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, _BYTE *a3@<ecx>, int a4);
void __thiscall __noreturn sub_403960(void *this);
// int __usercall sub_403968@<eax>(int result@<eax>);
// int __usercall sub_403970@<eax>(int a1@<eax>);
// void *__userpurge sub_403978@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, _BYTE *a3@<ecx>, int a4);
// OLECHAR **__usercall sub_403988@<eax>(OLECHAR **result@<eax>, char *@<edx>, int@<ecx>);
// OLECHAR ***__usercall sub_403990@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>);
// OLECHAR ***__userpurge sub_403998@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>, void *a3@<ecx>, int *a4);
// OLECHAR ***__usercall sub_403B24@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>, void *a3@<ecx>, int a4);
// OLECHAR ***__usercall sub_403B30@<eax>(OLECHAR ***result@<eax>, int a2@<edx>);
// OLECHAR ***__usercall sub_403B6C@<eax>(OLECHAR ***result@<eax>, OLECHAR **a2@<edx>, int a3@<ecx>);
// int __usercall sub_403B94@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_403BF0@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_403C00@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall sub_403C70@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_403C88@<eax>(_DWORD *result@<eax>, int a2@<edx>);
// int __usercall sub_403CB4@<eax>(LCID a1@<eax>);
int sub_403D28();
void sub_403D7C();
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// HLOCAL __stdcall LocalAlloc_0(UINT uFlags, SIZE_T uBytes);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// HLOCAL __usercall sub_403E70@<eax>(SIZE_T a1@<eax>);
int sub_403E7C();
int sub_403E84();
LPVOID sub_403EC8();
_DWORD *sub_403F08();
// int __usercall sub_403F14@<eax>(int a1@<eax>, struct _EXCEPTION_REGISTRATION_RECORD *a2@<ebp>);
int sub_403F58();
void sub_403F88();
int sub_403F90();
void sub_403FC0();
// LSTATUS __stdcall RegCloseKey_0(HKEY hKey);
// LSTATUS __stdcall RegOpenKeyExA_0(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
HANDLE __stdcall sub_404018(LPSECURITY_ATTRIBUTES lpMutexAttributes, int a2, LPCSTR lpName);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FreeLibrary_0(HMODULE hLibModule);
// LPSTR __stdcall GetCommandLineA_0();
// UINT __stdcall GetDriveTypeA(LPCSTR lpRootPathName);
// DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall GetLastError();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);
// UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
// BOOL __stdcall SetCurrentDirectoryA(LPCSTR lpPathName);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow);
// BOOL __stdcall WriteFile_0(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// HBITMAP __stdcall CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// HBRUSH __stdcall CreateSolidBrush(COLORREF color);
// BOOL __stdcall DeleteDC(HDC hdc);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// int __stdcall GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
// int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// int __stdcall SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse);
// int __stdcall StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop);
// DWORD __stdcall CharLowerBuffA(LPSTR lpsz, DWORD cchLength);
// HANDLE __stdcall CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags);
// BOOL __stdcall DestroyIcon(HICON hIcon);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// HDC __stdcall GetDC(HWND hWnd);
// BOOL __stdcall GetIconInfo(HICON hIcon, PICONINFO piconinfo);
// DWORD __stdcall GetSysColor(int nIndex);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// __int16 __usercall sub_404198@<ax>(char *a1@<eax>, int a2@<edx>);
int sub_4041A0();
void sub_4041D0();
int sub_4041D8();
void sub_404208();
int sub_404210();
void sub_404240();
// HICON __stdcall ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex);
// HINSTANCE __stdcall ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
int sub_404258();
void sub_404288();
int sub_404290();
void sub_4042C0();
int sub_4042C8();
void sub_4042F8();
int sub_404300();
void sub_404330();
int sub_404338();
void sub_404368();
int sub_404370();
void sub_4043A0();
int sub_4043A8();
void sub_4043D8();
int sub_4043E0();
void sub_404410();
// void *__usercall sub_404490@<eax>(void *result@<eax>);
void sub_40449C();
__int32 sub_4044A8();
// void __usercall sub_4044B8(int a1@<ebx>);
BOOL sub_4044E0();
// char *__usercall sub_4044F8@<eax>(char *a1@<eax>, int a2@<edx>);
// _DWORD *__usercall sub_404520@<eax>(_DWORD *result@<eax>);
// int __usercall sub_40452C@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall sub_40453C@<eax>(_DWORD *result@<eax>);
char *sub_40456C();
// int __usercall sub_40457C@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall sub_40458C@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall sub_4045B4@<eax>(_DWORD *result@<eax>, int a2@<edx>);
// int __usercall sub_4045D0@<eax>(_DWORD *a1@<eax>);
// unsigned int __usercall sub_4045E8@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __usercall sub_404618@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_404624@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_40465C@<eax>(int a1@<eax>, int a2@<edx>);
// char *__usercall sub_404670@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// signed int __usercall sub_40469C@<eax>(signed int result@<eax>);
// _BYTE *__usercall sub_4046C0@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>);
// const char *__usercall sub_4046DC@<eax>(const char *a1@<eax>, unsigned __int8 a2@<dl>);
// unsigned __int8 __usercall sub_404700@<al>(__int32 a1@<eax>, volatile __int32 *a2@<edx>);
// _DWORD *__usercall sub_404728@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall sub_404750@<eax>(void *a1@<eax>);
// int __usercall sub_404768@<eax>(void *a1@<eax>);
// _DWORD *__usercall sub_404798@<eax>(void **a1@<eax>, char **a2@<ecx>);
// int __usercall sub_4047D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_4047F0@<eax>(int result@<eax>);
// _DWORD *__usercall sub_404808@<eax>(char *a1@<eax>, char **a2@<edx>);
// int __usercall sub_40483C@<eax>(int a1@<eax>);
// char __usercall sub_404845@<al>(__int16 a1@<ax>, _WORD *a2@<edx>, _BYTE *a3@<ecx>);
// int __usercall sub_404894@<eax>(void *a1@<eax>, void *a2@<edx>);
// int __usercall sub_4048D8@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>);
// _BYTE *__usercall sub_4048F8@<eax>(_BYTE *result@<eax>, const char *a2@<edx>);
// int __usercall sub_40493C@<eax>(_BYTE *a1@<eax>);
// const char *__usercall sub_404950@<eax>(void *a1@<eax>);
// _BYTE *__usercall sub_404984@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_4049A4@<eax>(_BYTE *a1@<eax>);
// _DWORD *__usercall sub_4049D0@<eax>(int a1@<eax>, char **a2@<edx>);
int sub_404AE8();
// bool __usercall sub_404B38@<al>(_BYTE *a1@<eax>, _BYTE *a2@<edx>);
// HANDLE __usercall sub_404B68@<eax>(const CHAR *a1@<eax>, DWORD a2@<edx>);
// bool __usercall sub_404B90@<al>(void *a1@<eax>);
// char __usercall sub_404B9C@<al>(void *a1@<eax>);
// DWORD __usercall sub_404BB4@<eax>(void *a1@<eax>, LONG a2@<edx>, unsigned __int8 a3@<cl>);
// int __usercall sub_404BC4@<eax>(DWORD nNumberOfBytesToRead@<ecx>, LPVOID lpBuffer@<edx>, void *a3@<eax>);
// DWORD *__usercall sub_404BE0@<eax>(DWORD nNumberOfBytesToWrite@<ecx>, LPCVOID lpBuffer@<edx>, void *a3@<eax>);
// DWORD *__usercall sub_404BF8@<eax>(char *a1@<eax>, const void *a2@<edx>, DWORD a3@<ecx>);
// int __usercall sub_404C78@<eax>(char *a1@<eax>, void *a2@<edx>, DWORD a3@<ecx>);
// char __usercall sub_404CF8@<al>(const CHAR *a1@<eax>);
// volatile __int32 *__usercall sub_404D08@<eax>(__int32 a1@<eax>, char a2@<dl>, volatile __int32 *a3@<ecx>);
// _DWORD *__usercall sub_404D48@<eax>(__int32 a1@<eax>, char a2@<dl>, volatile __int32 *a3@<ecx>);
// _DWORD *__usercall sub_404DB8@<eax>(__int32 a1@<eax>, volatile __int32 *a2@<edx>);
// volatile __int32 *__usercall sub_404DCC@<eax>(__int32 a1@<eax>, volatile __int32 *a2@<edx>);
// int __usercall sub_404DE0@<eax>(void *a1@<eax>, int a2@<ebx>);
// BOOL __usercall sub_404EB0@<eax>(char *a1@<eax>);
// _DWORD *__usercall sub_404ED0@<eax>(void *a1@<eax>, char **a2@<edx>);
// _DWORD *__usercall sub_404EEC@<eax>(void *a1@<eax>, char **a2@<edx>);
// _DWORD *__usercall sub_404F18@<eax>(void *a1@<eax>, char **a2@<edx>);
// _DWORD *__usercall sub_404F34@<eax>(char *a1@<eax>, char **a2@<edx>);
// char *__usercall sub_404F6C@<eax>(const CHAR *a1@<eax>);
// _DWORD *__usercall sub_404F90@<eax>(volatile __int32 *a1@<eax>);
// _DWORD *__usercall sub_405008@<eax>(volatile __int32 *a1@<eax>);
// int __usercall sub_405080@<eax>(char *a1@<eax>, char *a2@<edx>, char **a3@<ecx>);
// void *__usercall sub_405200@<eax>(void *a1@<eax>, int a2@<ebx>);
// char *__usercall sub_4052AC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// _DWORD *__usercall sub_4052D8@<eax>(_DWORD *result@<eax>);
// int __usercall sub_4052E8@<eax>(_DWORD *a1@<eax>);
// unsigned __int8 __usercall sub_405300@<al>(__int32 a1@<eax>, volatile __int32 *a2@<edx>);
// int __usercall sub_405320@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_40532C@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_405338@<eax>(int a1@<eax>, int a2@<edx>, char **a3@<ecx>);
// BOOL __usercall sub_40534C@<eax>(int a1@<eax>, int a2@<edx>);
// char __userpurge sub_40536C@<al>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4);
// _DWORD *__userpurge sub_405634@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<edi>, int a5);
// HKEY __usercall sub_40575C@<eax>(HKEY a1@<eax>, char *a2@<edx>, HKEY a3@<ecx>);
// BOOL __usercall sub_40578C@<eax>(HKEY a1@<eax>, char *a2@<edx>, char *a3@<ecx>);
// HKEY __usercall sub_4057CC@<eax>(HKEY result@<eax>);
double sub_4057D8();
// bool __usercall sub_4057F8@<al>(unsigned __int16 a1@<ax>);
// char __usercall sub_405834@<al>(unsigned __int16 *a1@<eax>, double *a2@<edx>);
// int __usercall sub_405968@<eax>(int a1@<eax>);
// int __usercall sub_405974@<eax>(int a1@<eax>);
// int __usercall sub_40597C@<eax>(int a1@<eax>);
// int __usercall sub_405980@<eax>(int a1@<eax>);
// int __usercall sub_405984@<eax>(int a1@<eax>);
// int __usercall sub_405988@<eax>(int a1@<eax>);
// int __usercall sub_40598C@<eax>(int a1@<eax>);
// int __usercall sub_405990@<eax>(int a1@<eax>);
// int __usercall sub_405994@<eax>(int a1@<eax>);
// char *__usercall sub_4059A8@<eax>(char *a1@<eax>);
// DWORD __usercall sub_4059E4@<eax>(int a1@<eax>);
int sub_4059FC();
int sub_405A00(); // weak
int sub_405A0C(); // weak
// bool __usercall sub_405A18@<al>(int a1@<eax>);
// int __usercall sub_405AEC@<eax>(int a1@<eax>, unsigned int a2@<edx>);
// char *__usercall sub_405B24@<eax>(const CHAR *a1@<eax>, DWORD a2@<edx>);
// char *__usercall sub_405B60@<eax>(const CHAR *a1@<eax>);
// char *__usercall sub_405B84@<eax>(void *a1@<eax>);
char *sub_405BDC();
// int __usercall sub_405BE8@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
char *sub_405C80();
// int __usercall sub_405C90@<eax>(_DWORD *a1@<eax>);
// int __usercall sub_405CA0@<eax>(int result@<eax>);
// int __usercall sub_405CAC@<eax>(int a1@<eax>, int a2@<edx>);
// _DWORD *__usercall sub_405CBC@<eax>(int a1@<eax>);
// int __usercall sub_405CEC@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// _DWORD *__usercall sub_405D18@<eax>(int a1@<eax>, int a2@<edx>, char **a3@<ecx>);
// _DWORD *__usercall sub_405D30@<eax>(int a1@<eax>, char **a2@<edx>, char **a3@<esi>);
// int __usercall sub_405D84@<eax>(int a1@<eax>, char *a2@<edx>);
// char *__usercall sub_405DC4@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// char *__usercall sub_405E04@<eax>(char *a1@<eax>, const CHAR *a2@<edx>);
// char *__usercall sub_405E50@<eax>(char *a1@<eax>, const CHAR *a2@<edx>, char **a3@<esi>);
// void __usercall sub_405E94(int a1@<eax>, char a2@<cl>);
// int __usercall sub_405F70@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>);
// int __usercall sub_405F98@<eax>(char a1@<al>);
int nullsub_1(); // weak
// char *__usercall sub_405FB4@<eax>(int a1@<eax>, int a2@<edx>);
// char *__usercall sub_405FD8@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_40600C@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_406024@<eax>(int a1@<eax>);
// int __usercall sub_406068@<eax>(int a1@<eax>);
// int __usercall sub_406084@<eax>(_DWORD *a1@<eax>);
// char __userpurge sub_406094@<al>(BITMAPINFO *lpbmi@<ecx>, UINT iUsage@<edx>, int a3@<eax>, HDC a4@<ebx>, int a5@<esi>, int a6);
// void __usercall sub_4060E9(__int32 a1@<esi>);
// bool __usercall sub_406144@<al>(int a1@<eax>);
// int __usercall sub_406154@<eax>(int a1@<eax>);
// __int32 __usercall sub_4061E0@<eax>(int a1@<eax>, void *a2@<edx>);
// char __usercall sub_406218@<al>(int a1@<eax>);
// unsigned int __usercall sub_406268@<eax>(int a1@<eax>);
// void __usercall __spoils<edx,ecx> sub_40627C(int a1@<eax>);
// _DWORD *__usercall sub_40646C@<eax>(int a1@<eax>);
// int __usercall sub_40647C@<eax>(int result@<eax>, char a2@<dl>);
// char __usercall sub_40648C@<al>(int a1@<eax>);
// _DWORD *__usercall sub_4064BC@<eax>(int a1@<eax>);
char *sub_4064CC();
// int __usercall sub_4064E4@<eax>(int result@<eax>);
// int __usercall sub_406500@<eax>(_DWORD *a1@<eax>);
void __fastcall __spoils<edx,ecx> sub_406510(int a1, int a2);
// HBITMAP __usercall sub_406520@<eax>(HBITMAP result@<eax>, HICON a2@<edx>);
// int __usercall sub_406580@<eax>(int a1@<eax>);
int __cdecl sub_406598(int a1);
// __int64 __usercall sub_4065CC@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3);
// __int64 __usercall sub_406624@<edx:eax>(int a1@<eax>, int a2@<edx>);
// char __usercall sub_406638@<al>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// OLECHAR ***__usercall sub_406B48@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// HICON __usercall sub_406CA8@<eax>(UINT nIconIndex@<ecx>, HBITMAP a2@<eax>, char *a3@<edx>);
int sub_406CE0();
void sub_406D38();
// _DWORD *__usercall sub_406D40@<eax>(char **a1@<eax>);
int sub_406E0C();
// int __usercall sub_406E94@<eax>(int a1@<ebx>);
// _DWORD *__usercall sub_406F34@<eax>(char a1@<al>, char **a2@<edx>);
// int __usercall sub_406FE4@<eax>(void *a1@<eax>, char *a2@<edx>, int a3@<ebx>);
// int __usercall sub_407080@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
int sub_4070A4();
void sub_4070D4();
_DWORD *sub_4070DC();
// int __usercall sub_407130@<eax>(const CHAR *a1@<eax>);
// char __usercall sub_4071D0@<al>(char *a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// int __usercall sub_4074B4@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5);
// int __usercall sub_40759C@<eax>(int a1@<ebx>);
int sub_407674(); // weak
// int __usercall sub_407678@<eax>(char *a1@<ecx>, int a2@<ebx>);
// int __usercall sub_4079A0@<eax>(int a1@<ebx>);
// _DWORD *__usercall sub_407AD0@<eax>(char *a1@<eax>, char **a2@<esi>);
// _DWORD *__usercall sub_407BD4@<eax>(unsigned __int8 *a1@<eax>, int a2@<ebx>, char **a3@<esi>);
// int __usercall sub_407D9C@<eax>(unsigned __int8 *a1@<eax>, int a2@<ebx>, int a3@<edi>, char **a4@<esi>);
// int __usercall sub_407E90@<eax>(int a1@<edi>, char **a2@<esi>);
int sub_40802C();
// void __usercall __noreturn start(int a1@<ebx>, int a2@<edi>, char **a3@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40183E; // weak
_UNKNOWN loc_401845; // weak
_UNKNOWN loc_401922; // weak
_UNKNOWN loc_401929; // weak
_UNKNOWN loc_401FF0; // weak
_UNKNOWN loc_401FF7; // weak
_UNKNOWN loc_402196; // weak
_UNKNOWN loc_40219D; // weak
_UNKNOWN loc_402435; // weak
_UNKNOWN loc_40243C; // weak
_UNKNOWN loc_4028B0; // weak
_UNKNOWN loc_402B60; // weak
_UNKNOWN loc_402BB3; // weak
_UNKNOWN loc_402CEA; // weak
_UNKNOWN loc_402DD2; // weak
_UNKNOWN loc_402E32; // weak
int dword_402FA0 = 2573; // weak
char byte_403411 = '\0'; // weak
_UNKNOWN loc_403BCF; // weak
_UNKNOWN loc_403C64; // weak
_UNKNOWN loc_403C6B; // weak
_UNKNOWN loc_403D1A; // weak
_UNKNOWN loc_403D21; // weak
_UNKNOWN loc_403D72; // weak
_UNKNOWN loc_403F7D; // weak
_UNKNOWN loc_403FB5; // weak
_UNKNOWN loc_4041C5; // weak
_UNKNOWN loc_4041FD; // weak
_UNKNOWN loc_404235; // weak
_UNKNOWN loc_40427D; // weak
_UNKNOWN loc_4042B5; // weak
_UNKNOWN loc_4042ED; // weak
_UNKNOWN loc_404325; // weak
_UNKNOWN loc_40435D; // weak
_UNKNOWN loc_404395; // weak
_UNKNOWN loc_4043CD; // weak
_UNKNOWN loc_404405; // weak
int (*off_404424[3])() = { &nullsub_2, &sub_40457C, &off_404438 }; // weak
int (*off_404438[3])() = { &nullsub_2, &sub_405994, &off_40444C }; // weak
int (*off_40444C[3])() = { &sub_405CA0, &sub_405C90, &off_404460 }; // weak
int (*off_404460[3])() = { &nullsub_2, &sub_406084, &off_404474 }; // weak
int (*off_404474[3])() = { &nullsub_2, &sub_406500, &off_404488 }; // weak
int (*off_404488[2])() = { &nullsub_2, &sub_4052E8 }; // weak
_UNKNOWN loc_404ADA; // weak
_UNKNOWN loc_404AE1; // weak
_UNKNOWN loc_404B28; // weak
_UNKNOWN loc_404B2F; // weak
_UNKNOWN loc_404C66; // weak
_UNKNOWN loc_404C6D; // weak
_UNKNOWN loc_404CE6; // weak
_UNKNOWN loc_404CED; // weak
_UNKNOWN loc_404DAB; // weak
_UNKNOWN loc_404DB2; // weak
_UNKNOWN loc_404E9F; // weak
_UNKNOWN loc_404EA6; // weak
_UNKNOWN loc_404FFA; // weak
_UNKNOWN loc_405001; // weak
_UNKNOWN loc_405072; // weak
_UNKNOWN loc_405079; // weak
_UNKNOWN loc_4051DB; // weak
_UNKNOWN loc_4051E2; // weak
int dword_4051F0[3] = { 92, -1, 1 }; // weak
int dword_4051FC = 59; // weak
_UNKNOWN loc_405291; // weak
_UNKNOWN loc_405298; // weak
_UNKNOWN loc_405319; // weak
_UNKNOWN loc_405611; // weak
_UNKNOWN loc_405618; // weak
int dword_405624[3] = { 11777, -1, 2 }; // weak
int dword_405630 = 11822; // weak
char byte_40569B = '*'; // weak
_UNKNOWN loc_4056A7; // weak
_UNKNOWN loc_406B11; // weak
_UNKNOWN loc_406B18; // weak
int dword_406B2C[3] = { 875430673, 1075, 0 }; // weak
_UNKNOWN loc_406C97; // weak
_UNKNOWN loc_406C9E; // weak
_UNKNOWN loc_406D2F; // weak
_UNKNOWN loc_406DFC; // weak
_UNKNOWN loc_406E03; // weak
_UNKNOWN loc_406E88; // weak
_UNKNOWN loc_406E8F; // weak
_UNKNOWN loc_406F22; // weak
_UNKNOWN loc_406F29; // weak
_UNKNOWN loc_406FC7; // weak
_UNKNOWN loc_406FCE; // weak
_UNKNOWN loc_407064; // weak
_UNKNOWN loc_40706B; // weak
int dword_40707C = 46; // weak
_UNKNOWN loc_4070C9; // weak
_UNKNOWN loc_407126; // weak
_UNKNOWN loc_40712D; // weak
_UNKNOWN loc_4071BF; // weak
_UNKNOWN loc_4071C6; // weak
_UNKNOWN loc_40748C; // weak
_UNKNOWN loc_407493; // weak
_UNKNOWN loc_40758B; // weak
_UNKNOWN loc_407592; // weak
_UNKNOWN loc_40765C; // weak
_UNKNOWN loc_407663; // weak
_UNKNOWN loc_407882; // weak
_UNKNOWN loc_407889; // weak
_UNKNOWN loc_40789F; // weak
_UNKNOWN loc_4078A6; // weak
_UNKNOWN loc_40798C; // weak
_UNKNOWN loc_407993; // weak
_UNKNOWN loc_407AC4; // weak
_UNKNOWN loc_407ACB; // weak
_UNKNOWN loc_407B9D; // weak
_UNKNOWN loc_407BA4; // weak
_UNKNOWN loc_407BC7; // weak
_UNKNOWN loc_407BCE; // weak
_UNKNOWN loc_407D4A; // weak
_UNKNOWN loc_407D51; // weak
_UNKNOWN loc_407D8D; // weak
_UNKNOWN loc_407D94; // weak
_UNKNOWN loc_407E75; // weak
_UNKNOWN loc_407E7C; // weak
_UNKNOWN loc_407FFE; // weak
_UNKNOWN loc_408005; // weak
_UNKNOWN loc_408020; // weak
_UNKNOWN loc_408027; // weak
_UNKNOWN loc_40804B; // weak
int dword_408054 = 17; // weak
_UNKNOWN loc_408220; // weak
_UNKNOWN loc_408227; // weak
int dword_409000 = 0; // weak
int dword_409004 = 0; // weak
int dword_409008 = 0; // weak
char byte_40900C = '\x02'; // weak
int (*dword_409010)(void) = NULL; // weak
int (*dword_409014)(void) = NULL; // weak
__int16 word_409018 = 4914; // weak
char byte_40901C = '\0'; // weak
char byte_409024 = '\0'; // weak
int dword_409028 = 0; // weak
int dword_40902C = 0; // weak
int (__cdecl *off_409030)(_DWORD) = &sub_401E74; // weak
int (*off_409034)(void) = &sub_402004; // weak
int (__cdecl *off_409038)(_DWORD) = &sub_402384; // weak
char byte_40903C[28] =
{
  '\0',
  '\xCB',
  '\xCC',
  '\xC8',
  '\xC9',
  '\xD7',
  '\xCF',
  '\xC8',
  '\xCD',
  '\xCE',
  '\xDB',
  '\xD8',
  '\xDA',
  '\xD9',
  '\xCA',
  '\xDC',
  '\xDD',
  '\xDE',
  '\xDF',
  '\xE0',
  '\xE1',
  '\xE3',
  '\0',
  '\xE4',
  '\xE5',
  '\x8D',
  '@',
  '\0'
}; // weak
CHAR Caption[] = "Error"; // idb
CHAR Text[] = "Runtime error     at 00000000"; // idb
char byte_409080[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F'
}; // weak
DWORD TlsIndex = 4294967295u; // idb
_DWORD dword_409094 = 0; // weak
int dword_409098 = 0; // weak
int dword_40909C = 0; // weak
int dword_4090A0 = 0; // weak
char byte_4090AC = '='; // weak
char byte_4090B0 = '\x05'; // weak
_UNKNOWN unk_4090B4; // weak
_DWORD dword_4090E4 = 0; // weak
char *off_4090E8 = "IVXLCDMT"; // weak
void *off_4090F4 = &loc_4059D8; // weak
int (*off_409114)[50] = &dword_405A24; // weak
_UNKNOWN unk_409135; // weak
char byte_409140[72] =
{
  '\0',
  '\xF8',
  '\0',
  '\0',
  '\xE0',
  '\a',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '€',
  '\0',
  '\0',
  '€',
  '\0',
  '\0',
  '\0',
  '€',
  '€',
  '\0',
  '€',
  '\0',
  '\0',
  '\0',
  '€',
  '\0',
  '€',
  '\0',
  '€',
  '€',
  '\0',
  '\0',
  '€',
  '€',
  '€',
  '\0',
  '\xC0',
  '\xC0',
  '\xC0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\0'
}; // weak
char byte_409188[12] =
{
  '\0',
  '\x01',
  '\x04',
  '\b',
  '\x10',
  '\x10',
  '\x18',
  ' ',
  '\0',
  '\x8D',
  '@',
  '\0'
}; // weak
_UNKNOWN unk_409194; // weak
char aE[6] = ",EíÍ˜û"; // weak
char aA[10] = "<AïË½ïW‡Ý"; // weak
char aJ[6] = "{JÖçöJ"; // weak
char asc_4091C0[7] = "}ü„{ëŒ"; // weak
CHAR Name[8] = "íêÄþGÌA2"; // idb
char a2[4] = { '2', '\xAA', '\xCB', '\x90' }; // weak
char asc_4091E0[12] =
{
  '+',
  '^',
  '\xFE',
  '\x90',
  '\xC7',
  '\xBA',
  '\xE3',
  'W',
  '\x97',
  '\xCB',
  '\v',
  '\x90'
}; // weak
char asc_4091EC[28] =
{
  '\xB5',
  '\xE1',
  '\xD9',
  'n',
  '\xCA',
  '\x12',
  'X',
  '\xFD',
  '\xB1',
  '\x15',
  '.',
  '\x9A',
  't',
  '\xDB',
  'N',
  '\xF3',
  '\xC4',
  '\x9E',
  't',
  '\x93',
  '\xEE',
  '\xE2',
  'h',
  '\xEE',
  '\x11',
  '\x84',
  '\x8B',
  '\xC0'
}; // weak
char asc_409208[8] = { '`', '\x88', '\xB2', '\xF2', 'T', '\xF8', '5', '\xFD' }; // weak
char *off_409210 = ",EíÍ˜û"; // weak
int *off_409214 = &dword_409008; // weak
int dword_40A000; // weak
int (*dword_40A004)(void); // weak
int (__fastcall *dword_40A008)(_DWORD, _DWORD); // weak
int (*dword_40A00C)(void); // weak
int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_40A014)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_40A018)(void); // weak
int dword_40A01C; // weak
int dword_40A020; // weak
char byte_40A024; // weak
int dword_40A028; // weak
int dword_40A02C; // weak
_UNKNOWN unk_40A030; // weak
char byte_40A034; // weak
char byte_40A035; // weak
char byte_40A036; // weak
_UNKNOWN unk_40A038; // weak
__int16 word_40A03C; // weak
_UNKNOWN unk_40A204; // weak
__int16 word_40A208; // weak
int dword_40A210; // weak
int (*dword_40A220)(void); // weak
_UNKNOWN unk_40A3D0; // weak
__int16 word_40A3D4; // weak
int dword_40A59C; // weak
int dword_40A5A0; // weak
int dword_40A5A4; // weak
int dword_40A5A8; // weak
char byte_40A5AC; // weak
int dword_40A5B0; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
HLOCAL dword_40A5CC; // idb
int dword_40A5D0; // weak
int dword_40A5D4[4]; // weak
_DWORD dword_40A5E4[4]; // weak
_UNKNOWN unk_40A5F4; // weak
int dword_40A5F8; // weak
int dword_40A600; // weak
int dword_40A604; // weak
int dword_40A608; // weak
HLOCAL hMem; // idb
int dword_40A610; // weak
const void *dword_40A620; // weak
int dword_40A624; // weak
int dword_40A628; // weak
int dword_40A62C; // weak
int dword_40A630; // weak
char byte_40A64C; // weak
HINSTANCE hwnd; // idb
int dword_40A654; // weak
int dword_40A658; // weak
int dword_40A65C; // weak
int dword_40A660; // weak
int dword_40A664; // weak
int dword_40A668; // weak
int dword_40A66C; // weak
int dword_40A670; // weak
int dword_40A674; // weak
int dword_40A678; // weak
int dword_40A67C; // weak
int dword_40A680; // weak
int dword_40A684; // weak
int dword_40A688; // weak
int dword_40A68C; // weak
HMODULE hLibModule; // idb
int dword_40A694; // weak
_UNKNOWN unk_40A698; // weak
_DWORD dword_40AA80[8922]; // weak
char byte_4135E8[6680]; // weak


//----- (00401098) --------------------------------------------------------
int sub_401098()
{
  int v0; // ebx
  struct _STARTUPINFOA v2; // [esp+0h] [ebp-48h] BYREF

  v0 = 10;
  GetStartupInfoA(&v2);
  if ( (v2.dwFlags & 1) != 0 )
    return v2.wShowWindow;
  return v0;
}

//----- (004010FC) --------------------------------------------------------
int sub_4010FC()
{
  _DWORD *v0; // ecx
  int result; // eax
  int i; // edx

  if ( !dword_40A5D0 )
  {
    v0 = LocalAlloc(0, 0x644u);
    if ( !v0 )
      return 0;
    *v0 = dword_40A5CC;
    dword_40A5CC = v0;
    for ( i = 0; i != 100; ++i )
    {
      v0[4 * i + 1] = dword_40A5D0;
      dword_40A5D0 = (int)&v0[4 * i + 1];
    }
  }
  result = dword_40A5D0;
  dword_40A5D0 = *(_DWORD *)dword_40A5D0;
  return result;
}
// 40A5D0: using guessed type int dword_40A5D0;

//----- (0040114C) --------------------------------------------------------
_DWORD *__usercall sub_40114C@<eax>(_DWORD *result@<eax>)
{
  *result = result;
  result[1] = result;
  return result;
}

//----- (00401154) --------------------------------------------------------
char __usercall sub_401154@<al>(int *a1@<eax>, int *a2@<edx>)
{
  int *v4; // eax
  int v6; // edx

  v4 = (int *)sub_4010FC();
  if ( !v4 )
    return 0;
  v4[2] = *a2;
  v4[3] = a2[1];
  v6 = *a1;
  *v4 = *a1;
  v4[1] = (int)a1;
  *(_DWORD *)(v6 + 4) = v4;
  *a1 = (int)v4;
  return 1;
}

//----- (00401184) --------------------------------------------------------
int *__usercall sub_401184@<eax>(int *result@<eax>)
{
  int *v1; // edx
  int v2; // ecx

  v1 = (int *)result[1];
  v2 = *result;
  *v1 = *result;
  *(_DWORD *)(v2 + 4) = v1;
  *result = dword_40A5D0;
  dword_40A5D0 = (int)result;
  return result;
}
// 40A5D0: using guessed type int dword_40A5D0;

//----- (0040119C) --------------------------------------------------------
char __usercall sub_40119C@<al>(int *a1@<eax>, int *a2@<edx>, int *a3@<ecx>)
{
  int *v5; // ebx
  int v6; // edi
  char result; // al

  v5 = (int *)*a1;
  *a3 = *a2;
  a3[1] = a2[1];
  do
  {
    v6 = *v5;
    if ( *a3 == v5[3] + v5[2] )
    {
      sub_401184(v5);
      *a3 = v5[2];
      a3[1] += v5[3];
    }
    else if ( a3[1] + *a3 == v5[2] )
    {
      sub_401184(v5);
      a3[1] += v5[3];
    }
    v5 = (int *)v6;
  }
  while ( a1 != (int *)v6 );
  result = sub_401154(a1, a3);
  if ( !result )
  {
    result = 0;
    *a3 = 0;
  }
  return result;
}

//----- (0040120C) --------------------------------------------------------
int *__usercall sub_40120C@<eax>(int *a1@<eax>, int **a2@<edx>)
{
  int *v2; // ebx
  int *v4; // esi
  int *result; // eax
  int *v6; // edi
  int v7[6]; // [esp+0h] [ebp-18h] BYREF

  v2 = a1;
  while ( 1 )
  {
    v4 = *a2;
    result = (int *)v2[2];
    if ( *a2 >= result && (char *)v4 + (int)a2[1] <= (char *)result + v2[3] )
      break;
    v2 = (int *)*v2;
    if ( a1 == v2 )
      return 0;
  }
  if ( v4 == result )
  {
    v2[2] += (int)a2[1];
    result = a2[1];
    v2[3] -= (int)result;
    if ( !v2[3] )
      result = sub_401184(v2);
  }
  else
  {
    v6 = a2[1];
    if ( (char *)v4 + (_DWORD)v6 == (char *)result + v2[3] )
    {
      v2[3] -= (int)v6;
    }
    else
    {
      v7[0] = (int)*a2 + (_DWORD)a2[1];
      v7[1] = v2[3] + v2[2] - v7[0];
      v2[3] = (char *)v4 - (char *)result;
      if ( !sub_401154(v2, v7) )
        return 0;
    }
  }
  LOBYTE(result) = 1;
  return result;
}

//----- (004012A0) --------------------------------------------------------
char __usercall sub_4012A0@<al>(int a1@<eax>, int *a2@<edx>)
{
  unsigned int v3; // esi
  LPVOID v4; // eax

  if ( a1 >= 0x100000 )
    v3 = (a1 + 0xFFFF) & 0xFFFF0000;
  else
    v3 = 0x100000;
  a2[1] = v3;
  v4 = VirtualAlloc(0, v3, 0x2000u, 1u);
  *a2 = (int)v4;
  if ( v4 )
  {
    LOBYTE(v4) = sub_401154(dword_40A5D4, a2);
    if ( !(_BYTE)v4 )
    {
      VirtualFree((LPVOID)*a2, 0, 0x8000u);
      LOBYTE(v4) = 0;
      *a2 = 0;
    }
  }
  return (char)v4;
}
// 40A5D4: using guessed type int dword_40A5D4[4];

//----- (00401304) --------------------------------------------------------
char __usercall sub_401304@<al>(void *a1@<eax>, int a2@<edx>, int *a3@<ecx>)
{
  LPVOID v6; // eax
  unsigned int v7; // esi

  a3[1] = 0x100000;
  v6 = VirtualAlloc(a1, 0x100000u, 0x2000u, 4u);
  *a3 = (int)v6;
  if ( !v6 )
  {
    v7 = (a2 + 0xFFFF) & 0xFFFF0000;
    a3[1] = v7;
    v6 = VirtualAlloc(a1, v7, 0x2000u, 4u);
    *a3 = (int)v6;
  }
  if ( *a3 )
  {
    LOBYTE(v6) = sub_401154(dword_40A5D4, a3);
    if ( !(_BYTE)v6 )
    {
      VirtualFree((LPVOID)*a3, 0, 0x8000u);
      LOBYTE(v6) = 0;
      *a3 = 0;
    }
  }
  return (char)v6;
}
// 40A5D4: using guessed type int dword_40A5D4[4];

//----- (0040137C) --------------------------------------------------------
unsigned int *__usercall sub_40137C@<eax>(unsigned int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  int *i; // ebx
  int v5; // edi
  void *v6; // esi
  unsigned int *result; // eax
  unsigned int v9; // [esp+8h] [ebp-1Ch]
  unsigned int v10; // [esp+Ch] [ebp-18h]
  unsigned int v11; // [esp+10h] [ebp-14h]

  v9 = -1;
  v10 = 0;
  v11 = a1 + a2;
  for ( i = (int *)dword_40A5D4[0]; i != dword_40A5D4; i = (int *)v5 )
  {
    v5 = *i;
    v6 = (void *)i[2];
    if ( a1 <= (unsigned int)v6 && (unsigned int)v6 + i[3] <= v11 )
    {
      if ( (unsigned int)v6 < v9 )
        v9 = i[2];
      if ( (unsigned int)v6 + i[3] > v10 )
        v10 = (unsigned int)v6 + i[3];
      if ( !VirtualFree(v6, 0, 0x8000u) )
        dword_40A5B0 = 1;
      sub_401184(i);
    }
  }
  result = a3;
  *a3 = 0;
  if ( v10 )
  {
    *a3 = v9;
    result = (unsigned int *)(v10 - v9);
    a3[1] = v10 - v9;
  }
  return result;
}
// 40A5B0: using guessed type int dword_40A5B0;
// 40A5D4: using guessed type int dword_40A5D4[4];

//----- (00401434) --------------------------------------------------------
LPVOID __usercall sub_401434@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v3; // ebp
  LPVOID result; // eax
  int *i; // esi
  char *v6; // ebx
  char *v7; // edi
  unsigned int v9; // [esp+8h] [ebp-14h]

  v3 = a1 & 0xFFFFF000;
  v9 = (a2 + a1 + 4095) & 0xFFFFF000;
  *a3 = a1 & 0xFFFFF000;
  result = (LPVOID)(v9 - (a1 & 0xFFFFF000));
  a3[1] = (unsigned int)result;
  for ( i = (int *)dword_40A5D4; i != &dword_40A5D4; i = (int *)*i )
  {
    v6 = (char *)i[2];
    v7 = &v6[i[3]];
    if ( v3 > (unsigned int)v6 )
      v6 = (char *)v3;
    if ( (unsigned int)v7 > v9 )
      v7 = (char *)v9;
    if ( v7 > v6 )
    {
      result = VirtualAlloc(v6, v7 - v6, 0x1000u, 4u);
      if ( !result )
      {
        result = a3;
        *a3 = 0;
        return result;
      }
    }
  }
  return result;
}
// 40A5D4: using guessed type int dword_40A5D4;

//----- (004014C8) --------------------------------------------------------
unsigned int __usercall sub_4014C8@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v3; // ebp
  unsigned int result; // eax
  int *i; // esi
  char *v6; // ebx
  char *v7; // edi
  unsigned int v8; // [esp+0h] [ebp-14h]

  v8 = (a1 + 4095) & 0xFFFFF000;
  v3 = (a2 + a1) & 0xFFFFF000;
  *a3 = v8;
  result = v3 - v8;
  a3[1] = v3 - v8;
  for ( i = (int *)dword_40A5D4; i != &dword_40A5D4; i = (int *)*i )
  {
    v6 = (char *)i[2];
    v7 = &v6[i[3]];
    if ( (unsigned int)v6 < v8 )
      v6 = (char *)v8;
    if ( v3 < (unsigned int)v7 )
      v7 = (char *)v3;
    if ( v7 > v6 )
    {
      result = VirtualFree(v6, v7 - v6, 0x4000u);
      if ( !result )
        dword_40A5B0 = 2;
    }
  }
  return result;
}
// 40A5B0: using guessed type int dword_40A5B0;
// 40A5D4: using guessed type int dword_40A5D4;

//----- (00401548) --------------------------------------------------------
int *__usercall sub_401548@<eax>(int a1@<eax>, int *a2@<edx>)
{
  int v3; // edi
  int *i; // ebx
  int *result; // eax
  int v6[6]; // [esp+0h] [ebp-18h] BYREF

  v3 = (a1 + 0x3FFF) & 0xFFFFC000;
LABEL_2:
  for ( i = (int *)dword_40A5E4[0]; ; i = (int *)*i )
  {
    if ( i == dword_40A5E4 )
    {
      LOBYTE(result) = sub_4012A0(v3, a2);
      if ( !*a2 )
        return result;
      sub_40119C(dword_40A5E4, a2, v6);
      if ( !v6[0] )
      {
        sub_40137C(*a2, a2[1], (unsigned int *)v6);
        result = 0;
        *a2 = 0;
        return result;
      }
      goto LABEL_2;
    }
    if ( v3 <= i[3] )
      break;
  }
  result = (int *)sub_401434(i[2], v3, (unsigned int *)a2);
  if ( *a2 )
  {
    i[2] += a2[1];
    result = (int *)a2[1];
    i[3] -= (int)result;
    if ( !i[3] )
      return sub_401184(i);
  }
  return result;
}
// 40A5E4: using guessed type _DWORD dword_40A5E4[4];

//----- (004015D8) --------------------------------------------------------
int *__usercall sub_4015D8@<eax>(void *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  int v4; // edi
  int *i; // ebx
  int *result; // eax
  int v8[2]; // [esp+4h] [ebp-20h] BYREF
  int v9[6]; // [esp+Ch] [ebp-18h] BYREF

  v4 = (a2 + 0x3FFF) & 0xFFFFC000;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( i = (int *)dword_40A5E4[0]; i != dword_40A5E4 && a1 != (void *)i[2]; i = (int *)*i )
        ;
      if ( a1 != (void *)i[2] )
        break;
      if ( v4 <= i[3] )
        goto LABEL_14;
      sub_401304((void *)(i[3] + i[2]), v4 - i[3], v8);
      if ( !v8[0] )
        break;
      sub_40119C(dword_40A5E4, v8, v9);
      if ( !v9[0] )
        goto LABEL_10;
    }
    sub_401304(a1, v4, v8);
    if ( !v8[0] )
      break;
    sub_40119C(dword_40A5E4, v8, v9);
    if ( !v9[0] )
    {
LABEL_10:
      sub_40137C(v8[0], v8[1], (unsigned int *)v9);
      result = (int *)a3;
      *a3 = 0;
      return result;
    }
  }
LABEL_14:
  if ( a1 == (void *)i[2] && v4 <= i[3] )
  {
    sub_401434(i[2], v4, a3);
    result = (int *)a3;
    if ( *a3 )
    {
      i[2] += a3[1];
      result = (int *)a3[1];
      i[3] -= (int)result;
      if ( !i[3] )
        return sub_401184(i);
    }
  }
  else
  {
    result = (int *)a3;
    *a3 = 0;
  }
  return result;
}
// 40A5E4: using guessed type _DWORD dword_40A5E4[4];

//----- (004016FC) --------------------------------------------------------
char __usercall sub_4016FC@<al>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char result; // al
  int *v7; // [esp+4h] [ebp-1Ch] BYREF
  int v8; // [esp+8h] [ebp-18h]
  int *v9; // [esp+Ch] [ebp-14h] BYREF
  int v10; // [esp+10h] [ebp-10h]

  v4 = (a1 + 0x3FFF) & 0xFFFFC000;
  v5 = (a1 + a2) & 0xFFFFC000;
  if ( v4 >= v5 )
  {
    result = 0;
    *a3 = 0;
  }
  else
  {
    sub_4014C8((a1 + 0x3FFF) & 0xFFFFC000, v5 - v4, a3);
    result = sub_40119C(dword_40A5E4, (int *)a3, (int *)&v7);
    if ( v7 )
    {
      sub_40137C((unsigned int)v7, v8, (unsigned int *)&v9);
      v7 = v9;
      result = v10;
      v8 = v10;
    }
    if ( v7 )
      return (unsigned __int8)sub_40120C(dword_40A5E4, &v7);
  }
  return result;
}
// 40A5E4: using guessed type _DWORD dword_40A5E4[4];

//----- (00401788) --------------------------------------------------------
char sub_401788()
{
  int i; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-Ch] BYREF
  int *v3; // [esp-4h] [ebp-4h]
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_40183E;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  InitializeCriticalSection(&CriticalSection);
  if ( byte_40A035 )
    EnterCriticalSection(&CriticalSection);
  sub_40114C(dword_40A5D4);
  sub_40114C(dword_40A5E4);
  sub_40114C(&dword_40A610);
  hMem = LocalAlloc(0, 0xFF8u);
  if ( hMem )
  {
    for ( i = 3; i != 1025; ++i )
      *((_DWORD *)hMem + i - 3) = 0;
    *((_DWORD *)&unk_40A5F4 + 1) = &unk_40A5F4;
    unk_40A5F4 = &unk_40A5F4;
    dword_40A600 = (int)&unk_40A5F4;
    byte_40A5AC = 1;
  }
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_401845;
  if ( byte_40A035 )
    LeaveCriticalSection(&CriticalSection);
  return byte_40A5AC;
}
// 40A035: using guessed type char byte_40A035;
// 40A5AC: using guessed type char byte_40A5AC;
// 40A5D4: using guessed type int dword_40A5D4[4];
// 40A5E4: using guessed type _DWORD dword_40A5E4[4];
// 40A600: using guessed type int dword_40A600;
// 40A610: using guessed type int dword_40A610;

//----- (0040184C) --------------------------------------------------------
void sub_40184C()
{
  int i; // ebx
  HLOCAL *j; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-10h] BYREF
  int *v3; // [esp-4h] [ebp-8h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  if ( byte_40A5AC )
  {
    v3 = &savedregs;
    v2[1] = (unsigned int)&loc_401922;
    v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v2);
    if ( byte_40A035 )
      EnterCriticalSection(&CriticalSection);
    byte_40A5AC = 0;
    LocalFree(hMem);
    hMem = 0;
    for ( i = dword_40A5D4[0]; (int *)i != dword_40A5D4; i = *(_DWORD *)i )
      VirtualFree(*(LPVOID *)(i + 8), 0, 0x8000u);
    sub_40114C(dword_40A5D4);
    sub_40114C(dword_40A5E4);
    sub_40114C(&dword_40A610);
    for ( j = (HLOCAL *)dword_40A5CC; dword_40A5CC; j = (HLOCAL *)dword_40A5CC )
    {
      dword_40A5CC = *j;
      LocalFree(j);
    }
    __writefsdword(0, v2[0]);
    v3 = (int *)&loc_401929;
    if ( byte_40A035 )
      LeaveCriticalSection(&CriticalSection);
    DeleteCriticalSection(&CriticalSection);
  }
}
// 40A035: using guessed type char byte_40A035;
// 40A5AC: using guessed type char byte_40A5AC;
// 40A5D4: using guessed type int dword_40A5D4[4];
// 40A5E4: using guessed type _DWORD dword_40A5E4[4];
// 40A610: using guessed type int dword_40A610;

//----- (0040192C) --------------------------------------------------------
_DWORD *__usercall sub_40192C@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // edx
  int v2; // ecx
  _DWORD *result; // eax

  if ( a1 == (_DWORD *)dword_40A600 )
    dword_40A600 = a1[1];
  v1 = (_DWORD *)a1[1];
  v2 = a1[2];
  if ( v2 > 4096 )
  {
    result = (_DWORD *)*a1;
    *v1 = result;
    result[1] = v1;
  }
  else if ( a1 == v1 )
  {
    result = hMem;
    *((_DWORD *)hMem + v2 / 4 - 3) = 0;
  }
  else
  {
    *((_DWORD *)hMem + a1[2] / 4 - 3) = v1;
    result = (_DWORD *)*a1;
    *v1 = result;
    result[1] = v1;
  }
  return result;
}
// 40A600: using guessed type int dword_40A600;

//----- (00401990) --------------------------------------------------------
int *__usercall sub_401990@<eax>(unsigned int a1@<eax>)
{
  int *i; // edx
  unsigned int v2; // ecx

  for ( i = (int *)dword_40A610; i != &dword_40A610; i = (int *)*i )
  {
    v2 = i[2];
    if ( a1 >= v2 && a1 < i[3] + v2 )
      return i;
  }
  dword_40A5B0 = 3;
  return 0;
}
// 40A5B0: using guessed type int dword_40A5B0;
// 40A610: using guessed type int dword_40A610;

//----- (004019C0) --------------------------------------------------------
unsigned int *__usercall sub_4019C0@<eax>(unsigned int *result@<eax>, int a2@<edx>)
{
  unsigned int *v2; // ebx

  v2 = (unsigned int *)((char *)result + a2 - 4);
  if ( a2 < 16 )
  {
    if ( a2 >= 4 )
    {
      *result = a2 | 0x80000002;
      *v2 = a2 | 0x80000002;
    }
  }
  else
  {
    *v2 = -2147483641;
    return (unsigned int *)sub_401B94(a2 - 4, a2 - 4);
  }
  return result;
}
// 401B94: using guessed type int __fastcall sub_401B94(_DWORD, _DWORD);

//----- (004019F0) --------------------------------------------------------
int __usercall sub_4019F0@<eax>(int a1@<eax>)
{
  ++dword_40A59C;
  dword_40A5A0 += (*(_DWORD *)(a1 - 4) & 0x7FFFFFFC) - 4;
  return sub_402004();
}
// 402004: using guessed type int sub_402004(void);
// 40A59C: using guessed type int dword_40A59C;
// 40A5A0: using guessed type int dword_40A5A0;

//----- (00401A14) --------------------------------------------------------
_DWORD *__usercall sub_401A14@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax

  if ( a2 < 12 )
  {
    if ( a2 >= 4 )
      *a1 = a2 | 0x80000002;
    result = (_DWORD *)((char *)a1 + a2);
    *result &= ~1u;
  }
  else
  {
    *a1 = a2 | 2;
    return (_DWORD *)sub_4019F0((int)(a1 + 1));
  }
  return result;
}

//----- (00401A3C) --------------------------------------------------------
int __usercall sub_401A3C@<eax>(int a1@<eax>)
{
  int v1; // edx
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // esi
  _DWORD *v5; // eax

  v1 = *(_DWORD *)(a1 - 4);
  if ( (v1 & 0x80000002) != -2147483646 )
    dword_40A5B0 = 4;
  v2 = v1 & 0x7FFFFFFC;
  v3 = (_DWORD *)(a1 - (v1 & 0x7FFFFFFC));
  if ( ((*v3 ^ v1) & 0xFFFFFFFE) != 0 )
    dword_40A5B0 = 5;
  if ( (*(_BYTE *)v3 & 1) != 0 )
  {
    v4 = *(v3 - 1);
    v5 = (_DWORD *)((char *)v3 - v4);
    if ( v4 != v5[2] )
      dword_40A5B0 = 6;
    sub_40192C(v5);
    v2 += v4;
  }
  return v2;
}
// 40A5B0: using guessed type int dword_40A5B0;

//----- (00401AAC) --------------------------------------------------------
int __usercall sub_401AAC@<eax>(int *a1@<eax>)
{
  int *v1; // ebx
  int v2; // edi
  int v3; // eax
  int v4; // eax

  v1 = a1;
  v2 = 0;
  v3 = *a1;
  if ( v3 < 0 )
  {
    v2 = v3 & 0x7FFFFFFC;
    v1 = (int *)((char *)v1 + (v3 & 0x7FFFFFFC));
    v3 = *v1;
  }
  if ( (v3 & 2) == 0 )
  {
    sub_40192C(v1);
    v4 = v1[2];
    v2 += v4;
    *(int *)((char *)v1 + v4) &= ~1u;
  }
  return v2;
}

//----- (00401AE4) --------------------------------------------------------
char __usercall sub_401AE4@<al>(unsigned int *a1@<eax>, int a2@<edx>)
{
  int *v4; // eax
  int *v5; // ebx
  int v6; // ebp
  int v7; // eax
  int *v8; // ebp
  char v10; // [esp+0h] [ebp-1Ch]
  int *v11; // [esp+1h] [ebp-1Bh] BYREF
  int v12; // [esp+5h] [ebp-17h]

  v10 = 0;
  v4 = sub_401990((unsigned int)a1);
  v5 = v4;
  if ( v4 )
  {
    v6 = v4[2];
    v7 = v4[3] + v6;
    if ( v5[3] + v5[2] - ((int)a1 + a2) <= 12 )
      a2 = v7 - (_DWORD)a1;
    if ( (int)a1 - v6 >= 12 )
      sub_4016FC((int)(a1 + 1), a2 - 4, (unsigned int *)&v11);
    else
      sub_4016FC(v5[2], (int)a1 + a2 - v5[2], (unsigned int *)&v11);
    v8 = v11;
    if ( v11 )
    {
      sub_4019C0(a1, (char *)v11 - (char *)a1);
      if ( (unsigned int)v8 + v12 < v5[3] + v5[2] )
        sub_401A14((int *)((char *)v8 + v12), (char *)a1 + a2 - ((char *)v8 + v12));
      sub_40120C(v5, &v11);
      return 1;
    }
  }
  return v10;
}

//----- (00401B94) --------------------------------------------------------
char __usercall sub_401B94@<al>(unsigned int *a1@<eax>, int a2@<edx>)
{
  int v3; // edx
  unsigned int **v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // edx

  a1[2] = a2;
  *(unsigned int *)((char *)a1 + a2 - 4) = a2;
  if ( a2 > 4096 )
  {
    if ( a2 < 15360 || (LOBYTE(v4) = sub_401AE4(a1, a2), !(_BYTE)v4) )
    {
      v4 = (unsigned int **)dword_40A600;
      dword_40A600 = (int)a1;
      v6 = (unsigned int)*v4;
      a1[1] = (unsigned int)v4;
      *a1 = v6;
      *v4 = a1;
      *(_DWORD *)(v6 + 4) = a1;
    }
  }
  else
  {
    v3 = a2 / 4;
    v4 = (unsigned int **)*((_DWORD *)hMem + v3 - 3);
    if ( v4 )
    {
      v5 = (unsigned int)*v4;
      a1[1] = (unsigned int)v4;
      *a1 = v5;
      *v4 = a1;
      *(_DWORD *)(v5 + 4) = a1;
    }
    else
    {
      LOBYTE(v4) = (_BYTE)hMem;
      *((_DWORD *)hMem + v3 - 3) = a1;
      a1[1] = (unsigned int)a1;
      *a1 = (unsigned int)a1;
    }
  }
  return (char)v4;
}
// 40A600: using guessed type int dword_40A600;

//----- (00401C1C) --------------------------------------------------------
int sub_401C1C()
{
  int result; // eax

  if ( dword_40A604 > 0 )
  {
    if ( dword_40A604 >= 12 )
    {
      *(_DWORD *)dword_40A608 = dword_40A604 | 2;
      sub_4019F0(dword_40A608 + 4);
      dword_40A608 = 0;
      result = 0;
      dword_40A604 = 0;
    }
    else
    {
      dword_40A5B0 = 7;
    }
  }
  return result;
}
// 40A5B0: using guessed type int dword_40A5B0;
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;

//----- (00401C68) --------------------------------------------------------
char __usercall sub_401C68@<al>(unsigned int *a1@<eax>)
{
  unsigned int v1; // ebx
  int v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned int v6; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v7; // [esp+4h] [ebp-18h]
  unsigned int v8; // [esp+8h] [ebp-14h] BYREF
  int v9; // [esp+Ch] [ebp-10h]

  v6 = *a1;
  v7 = a1[1];
  sub_401C1C();
  sub_40119C(&dword_40A610, (int *)&v6, (int *)&v8);
  v1 = v8;
  if ( !v8 )
    return 0;
  if ( v8 < v6 )
  {
    v3 = sub_401A3C(v6);
    v6 -= v3;
    v7 += v3;
  }
  v4 = v9 + v1;
  if ( v7 + v6 < v9 + v1 )
  {
    v5 = sub_401AAC((int *)(v7 + v6));
    v7 += v5;
  }
  if ( v4 == v7 + v6 )
  {
    sub_4019C0((unsigned int *)(v7 + v6 - 4), 4);
    v7 -= 4;
  }
  dword_40A608 = v6;
  dword_40A604 = v7;
  return 1;
}
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;
// 40A610: using guessed type int dword_40A610;

//----- (00401CF4) --------------------------------------------------------
int __usercall sub_401CF4@<eax>(int a1@<eax>)
{
  int result; // eax
  int v2[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_401548(a1 + 4, v2);
  if ( !v2[0] || !sub_401C68((unsigned int *)v2) )
    return 0;
  LOBYTE(result) = 1;
  return result;
}

//----- (00401D20) --------------------------------------------------------
int __usercall sub_401D20@<eax>(void *a1@<eax>, int a2@<edx>)
{
  int result; // eax
  unsigned int v3[4]; // [esp+0h] [ebp-10h] BYREF

  sub_4015D8(a1, a2 + 4, v3);
  if ( !v3[0] || !sub_401C68(v3) )
    return 0;
  LOBYTE(result) = 1;
  return result;
}

//----- (00401D54) --------------------------------------------------------
int __usercall sub_401D54@<eax>(int a1@<eax>)
{
  int v1; // edx
  int v2; // eax

  v1 = 0;
  v2 = a1 / 4;
  if ( v2 <= 1024 )
  {
    do
    {
      v1 = *((_DWORD *)hMem + v2 - 3);
      if ( v1 )
        break;
      ++v2;
    }
    while ( v2 != 1025 );
  }
  return v1;
}

//----- (00401D80) --------------------------------------------------------
_DWORD *__usercall sub_401D80@<eax>(int a1@<eax>)
{
  int *v2; // ebx
  int v3; // eax
  _DWORD *result; // eax
  int *v5; // eax
  int v6; // edx

  do
  {
    v2 = (int *)dword_40A5F8;
    if ( a1 <= *(_DWORD *)(dword_40A5F8 + 8) )
      goto LABEL_15;
    v2 = (int *)dword_40A600;
    v3 = *(_DWORD *)(dword_40A600 + 8);
    if ( a1 <= v3 )
      goto LABEL_15;
    *(_DWORD *)(dword_40A600 + 8) = a1;
    do
      v2 = (int *)v2[1];
    while ( a1 > v2[2] );
    *(_DWORD *)(dword_40A600 + 8) = v3;
    if ( v2 != (int *)dword_40A600 )
    {
      dword_40A600 = (int)v2;
LABEL_15:
      sub_40192C(v2);
      if ( v2[2] - a1 < 12 )
      {
        v6 = v2[2];
        a1 = v6;
        if ( v2 == (int *)dword_40A600 )
          dword_40A600 = v2[1];
        *(int *)((char *)v2 + v6) &= ~1u;
      }
      else
      {
        sub_401B94((unsigned int *)((char *)v2 + a1), v2[2] - a1);
      }
      *v2 = a1 | 2;
      result = v2 + 1;
      ++dword_40A59C;
      dword_40A5A0 += a1 - 4;
      return result;
    }
    if ( a1 <= 4096 )
    {
      v2 = (int *)sub_401D54(a1);
      if ( v2 )
        goto LABEL_15;
    }
    if ( !(unsigned __int8)sub_401CF4(a1) )
      return 0;
  }
  while ( a1 > dword_40A604 );
  dword_40A604 -= a1;
  if ( dword_40A604 < 12 )
  {
    a1 += dword_40A604;
    dword_40A604 = 0;
  }
  v5 = (int *)dword_40A608;
  dword_40A608 += a1;
  *v5 = a1 | 2;
  result = v5 + 1;
  ++dword_40A59C;
  dword_40A5A0 += a1 - 4;
  return result;
}
// 40A59C: using guessed type int dword_40A59C;
// 40A5A0: using guessed type int dword_40A5A0;
// 40A5F8: using guessed type int dword_40A5F8;
// 40A600: using guessed type int dword_40A600;
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;

//----- (00401E74) --------------------------------------------------------
_DWORD *__usercall sub_401E74@<eax>(int a1@<eax>)
{
  int v2; // ebx
  int *v3; // edx
  int *v4; // esi
  int *v5; // eax
  int *v6; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-20h] BYREF
  void *v9; // [esp-8h] [ebp-1Ch]
  int *v10; // [esp-4h] [ebp-18h]
  int v11; // [esp+Ch] [ebp-8h]
  _DWORD *v12; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  if ( !byte_40A5AC && !sub_401788() || a1 > 2147483640 )
    return 0;
  v10 = &savedregs;
  v9 = &loc_401FF0;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( byte_40A035 )
    EnterCriticalSection(&CriticalSection);
  v2 = (a1 + 7) & 0xFFFFFFFC;
  if ( v2 < 12 )
    v2 = 12;
  if ( v2 <= 4096 && (v3 = (int *)*((_DWORD *)hMem + (v2 >> 2) - 3)) != 0 )
  {
    v4 = (int *)*((_DWORD *)hMem + (v2 >> 2) - 3);
    *(int *)((char *)v3 + v2) &= ~1u;
    v5 = (int *)v3[1];
    if ( v3 == v5 )
    {
      *((_DWORD *)hMem + (v2 >> 2) - 3) = 0;
    }
    else
    {
      *((_DWORD *)hMem + (v2 >> 2) - 3) = v5;
      v11 = *v3;
      *(_DWORD *)(v11 + 4) = v5;
      *v5 = v11;
    }
    *v4 = v3[2] | 2;
    v12 = v4 + 1;
    ++dword_40A59C;
    dword_40A5A0 += v2 - 4;
    sub_402BEC((unsigned int)ExceptionList, (int)v9, (int)v10);
  }
  else if ( v2 > dword_40A604 )
  {
    v12 = sub_401D80(v2);
    __writefsdword(0, (unsigned int)ExceptionList);
    v10 = (int *)&loc_401FF7;
    if ( byte_40A035 )
      LeaveCriticalSection(&CriticalSection);
  }
  else
  {
    dword_40A604 -= v2;
    if ( dword_40A604 < 12 )
    {
      v2 += dword_40A604;
      dword_40A604 = 0;
    }
    v6 = (int *)dword_40A608;
    dword_40A608 += v2;
    *v6 = v2 | 2;
    v12 = v6 + 1;
    ++dword_40A59C;
    dword_40A5A0 += v2 - 4;
    sub_402BEC((unsigned int)ExceptionList, (int)v9, (int)v10);
  }
  return v12;
}
// 401EE4: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 401F0E: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 401F28: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 40A035: using guessed type char byte_40A035;
// 40A59C: using guessed type int dword_40A59C;
// 40A5A0: using guessed type int dword_40A5A0;
// 40A5AC: using guessed type char byte_40A5AC;
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;

//----- (00402004) --------------------------------------------------------
int __usercall sub_402004@<eax>(int a1@<eax>)
{
  unsigned int *v2; // esi
  int v3; // ebx
  int v4; // edx
  _DWORD *v5; // eax
  int v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  _DWORD *v9; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v12; // [esp-8h] [ebp-18h]
  int *v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  dword_40A5B0 = 0;
  if ( !byte_40A5AC && !sub_401788() )
  {
    dword_40A5B0 = 8;
    return 8;
  }
  v13 = &savedregs;
  v12 = &loc_402196;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( byte_40A035 )
    EnterCriticalSection(&CriticalSection);
  v2 = (unsigned int *)(a1 - 4);
  v3 = *(_DWORD *)(a1 - 4);
  if ( (v3 & 2) == 0 )
  {
    dword_40A5B0 = 9;
    goto LABEL_29;
  }
  --dword_40A59C;
  dword_40A5A0 -= (v3 & 0x7FFFFFFC) - 4;
  if ( (v3 & 1) != 0 )
  {
    v4 = *(v2 - 1);
    if ( v4 < 12 || (v4 & 0x80000003) != 0 )
    {
      dword_40A5B0 = 10;
      goto LABEL_29;
    }
    v5 = (unsigned int *)((char *)v2 - v4);
    if ( v4 != *(unsigned int *)((char *)v2 - v4 + 8) )
    {
      dword_40A5B0 = 10;
      goto LABEL_29;
    }
    v3 += v4;
    v2 = (unsigned int *)((char *)v2 - v4);
    sub_40192C(v5);
  }
  v6 = v3 & 0x7FFFFFFC;
  v7 = (unsigned int *)((char *)v2 + v6);
  v8 = (unsigned int *)((char *)v2 + v6);
  if ( (unsigned int *)((char *)v2 + v6) != (unsigned int *)dword_40A608 )
  {
    if ( (*v7 & 2) != 0 )
    {
      if ( (*v7 & 0x7FFFFFFCu) < 4 )
      {
        dword_40A5B0 = 11;
        goto LABEL_29;
      }
      *v7 |= 1u;
    }
    else
    {
      v9 = (unsigned int *)((char *)v2 + v6);
      if ( !v8[1] || !*v8 || (int)v8[2] < 12 )
      {
        dword_40A5B0 = 11;
        goto LABEL_29;
      }
      v6 += v8[2];
      sub_40192C(v9);
    }
    sub_401B94(v2, v6);
LABEL_29:
    v14 = dword_40A5B0;
    __writefsdword(0, (unsigned int)ExceptionList);
    v13 = (int *)&loc_40219D;
    if ( byte_40A035 )
      LeaveCriticalSection(&CriticalSection);
    return v14;
  }
  dword_40A608 -= v6;
  dword_40A604 += v6;
  if ( dword_40A604 > 15360 )
    sub_401C1C();
  v14 = 0;
  sub_402BEC((unsigned int)ExceptionList, (int)v12, (int)v13);
  return v14;
}
// 40A035: using guessed type char byte_40A035;
// 40A59C: using guessed type int dword_40A59C;
// 40A5A0: using guessed type int dword_40A5A0;
// 40A5AC: using guessed type char byte_40A5AC;
// 40A5B0: using guessed type int dword_40A5B0;
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;

//----- (004021A8) --------------------------------------------------------
unsigned int __usercall sub_4021A8@<eax>(int a1@<eax>, int a2@<edx>)
{
  signed int v2; // esi
  unsigned int *v3; // ebp
  int v4; // edi
  unsigned int result; // eax
  _DWORD *v6; // ebx
  int v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+0h] [ebp-18h]
  int v10; // [esp+4h] [ebp-14h]

  v2 = (a2 + 7) & 0xFFFFFFFC;
  if ( v2 < 12 )
    v2 = 12;
  v3 = (unsigned int *)(a1 - 4);
  v4 = *(_DWORD *)(a1 - 4) & 0x7FFFFFFC;
  result = v4 + a1 - 4;
  v6 = (_DWORD *)result;
  if ( v4 == v2 )
  {
    LOBYTE(result) = 1;
    return result;
  }
  if ( v4 <= v2 )
  {
    while ( 1 )
    {
      v10 = v2 - v4;
      if ( v6 == (_DWORD *)dword_40A608 )
      {
        if ( dword_40A604 >= v10 )
        {
          dword_40A604 -= v10;
          dword_40A608 += v10;
          if ( dword_40A604 < 12 )
          {
            dword_40A608 += dword_40A604;
            v2 += dword_40A604;
            dword_40A604 = 0;
          }
          dword_40A5A0 += v2 - v4;
          result = *v3 & 0x80000003;
          *v3 = result | v2;
          LOBYTE(result) = 1;
          return result;
        }
        sub_401C1C();
        v6 = (unsigned int *)((char *)v3 + v4);
      }
      if ( (*(_BYTE *)v6 & 2) == 0 )
      {
        v8 = v6[2];
        if ( v8 >= v10 )
        {
          sub_40192C(v6);
          v9 = v8 - v10;
          if ( v9 < 12 )
          {
            v2 += v9;
            *(unsigned int *)((char *)v3 + v2) &= ~1u;
          }
          else
          {
            sub_401B94((unsigned int *)((char *)v3 + v2), v9);
          }
          goto LABEL_30;
        }
        v6 = (_DWORD *)((char *)v6 + v8);
        v10 -= v8;
      }
      if ( (int)*v6 >= 0 || !(unsigned __int8)sub_401D20((char *)v6 + (*v6 & 0x7FFFFFFC), v10) )
        return 0;
      v6 = (unsigned int *)((char *)v3 + v4);
    }
  }
  v7 = v4 - v2;
  if ( result == dword_40A608 )
  {
    dword_40A608 -= v7;
    dword_40A604 += v7;
    if ( dword_40A604 < 12 )
    {
      dword_40A608 += v7;
      dword_40A604 -= v7;
      v2 = v4;
    }
  }
  else
  {
    if ( (*(_BYTE *)result & 2) == 0 )
    {
      v7 += *(_DWORD *)(result + 8);
      sub_40192C((_DWORD *)result);
    }
    if ( v7 < 12 )
    {
      v2 = v4;
    }
    else
    {
      *(unsigned int *)((char *)v3 + v2) = v7 | 2;
      sub_4019F0((int)v3 + v2 + 4);
    }
  }
LABEL_30:
  dword_40A5A0 += v2 - v4;
  result = *v3 & 0x80000003;
  *v3 = result | v2;
  LOBYTE(result) = 1;
  return result;
}
// 40A5A0: using guessed type int dword_40A5A0;
// 40A604: using guessed type int dword_40A604;
// 40A608: using guessed type int dword_40A608;

//----- (00402384) --------------------------------------------------------
int __usercall sub_402384@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char *v4; // edi
  int v5; // eax
  unsigned int v7[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v8; // [esp-4h] [ebp-14h]
  char *v9; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  if ( !byte_40A5AC && !sub_401788() )
    return 0;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_402435;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  if ( byte_40A035 )
    EnterCriticalSection(&CriticalSection);
  if ( (unsigned __int8)sub_4021A8((int)a1, a2) )
  {
    v9 = a1;
  }
  else
  {
    v4 = (char *)sub_401E74(a2);
    v5 = (*((_DWORD *)a1 - 1) & 0x7FFFFFFC) - 4;
    if ( a2 < v5 )
      v5 = a2;
    if ( v4 )
    {
      sub_40254C(a1, v4, v5);
      sub_402004((int)a1);
    }
    v9 = v4;
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_40243C;
  if ( byte_40A035 )
    LeaveCriticalSection(&CriticalSection);
  return (int)v9;
}
// 40A035: using guessed type char byte_40A035;
// 40A5AC: using guessed type char byte_40A5AC;

//----- (00402448) --------------------------------------------------------
int __usercall sub_402448@<eax>(int a1@<eax>)
{
  void *v1; // ecx
  int v2; // ebx

  if ( a1 <= 0 )
    return 0;
  v2 = off_409030();
  if ( !v2 )
    sub_402530(1, v1);
  return v2;
}
// 40245B: variable 'v1' is possibly undefined
// 409030: using guessed type int (*off_409030)(void);

//----- (00402468) --------------------------------------------------------
int __usercall sub_402468@<eax>(int a1@<eax>)
{
  void *v1; // ecx
  int v2; // ebx

  if ( !a1 )
    return 0;
  v2 = off_409034();
  if ( v2 )
    sub_402530(2, v1);
  return v2;
}
// 40247B: variable 'v1' is possibly undefined
// 409034: using guessed type int (*off_409034)(void);

//----- (00402488) --------------------------------------------------------
_DWORD *__usercall sub_402488@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  void *v2; // ecx
  void *v3; // ecx
  _DWORD *v4; // [esp-4h] [ebp-4h]
  _DWORD *v5; // [esp-4h] [ebp-4h]

  if ( *result )
  {
    if ( a2 )
    {
      result = (_DWORD *)off_409038(result);
      v2 = v4;
      if ( result )
      {
        *v4 = result;
        return result;
      }
LABEL_8:
      sub_402530(1, v2);
    }
    *result = 0;
    result = (_DWORD *)off_409034();
    if ( result )
      sub_402530(2, v3);
  }
  else if ( a2 )
  {
    result = (_DWORD *)off_409030(result);
    v2 = v5;
    if ( !result )
      goto LABEL_8;
    *v5 = result;
  }
  return result;
}
// 40249B: variable 'v4' is possibly undefined
// 4024A5: variable 'v3' is possibly undefined
// 4024CD: variable 'v5' is possibly undefined
// 409030: using guessed type int (__cdecl *off_409030)(_DWORD);
// 409034: using guessed type int (*off_409034)(void);
// 409038: using guessed type int (__cdecl *off_409038)(_DWORD);

//----- (004024D8) --------------------------------------------------------
void __usercall __noreturn sub_4024D8(int a1@<eax>, int a2@<edx>, void *a3@<ecx>)
{
  dword_409004 = a2;
  sub_40307C(a1, a3);
}
// 409004: using guessed type int dword_409004;

//----- (004024E4) --------------------------------------------------------
void __usercall __noreturn sub_4024E4(char a1@<al>, int a2@<edx>, void *a3@<ecx>)
{
  int v4; // ebx

  LOBYTE(v4) = a1 & 0x7F;
  if ( dword_40A008 )
    dword_40A008(a3, a2);
  if ( (_BYTE)v4 )
  {
    if ( (unsigned __int8)v4 <= 0x18u )
      LOBYTE(v4) = byte_40903C[(unsigned __int8)v4];
  }
  else
  {
    v4 = *((_DWORD *)sub_403EC8() + 1);
  }
  sub_4024D8((unsigned __int8)v4, a2, a3);
}
// 402526: variable 'a3' is possibly undefined
// 40A008: using guessed type int (__fastcall *dword_40A008)(_DWORD, _DWORD);

//----- (00402530) --------------------------------------------------------
void __usercall __noreturn sub_402530(char a1@<al>, void *a2@<ecx>)
{
  int retaddr; // [esp+0h] [ebp+0h]

  sub_4024E4(a1 & 0x7F, retaddr, a2);
}

//----- (0040253C) --------------------------------------------------------
_DWORD *__usercall sub_40253C@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax

  result = sub_403EC8();
  result[1] = a1;
  return result;
}

//----- (0040254C) --------------------------------------------------------
int __usercall sub_40254C@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v5; // ecx
  char *v6; // esi
  char *v7; // edi
  int v8; // ecx
  int v9; // ecx
  _BYTE *v10; // esi
  _BYTE *v11; // edi

  result = a3;
  if ( a2 > a1 )
  {
    v6 = &a1[a3 - 4];
    v7 = &a2[a3 - 4];
    v8 = a3 >> 2;
    if ( v8 >= 0 )
    {
      while ( v8 )
      {
        *(_DWORD *)v7 = *(_DWORD *)v6;
        v6 -= 4;
        v7 -= 4;
        --v8;
      }
      v9 = result & 3;
      v10 = v6 + 3;
      v11 = v7 + 3;
      while ( v9 )
      {
        *v11-- = *v10--;
        --v9;
      }
    }
  }
  else if ( a2 != a1 )
  {
    v5 = a3 >> 2;
    if ( v5 >= 0 )
      qmemcpy(a2, a1, 4 * v5 + (result & 3));
  }
  return result;
}

//----- (0040258C) --------------------------------------------------------
unsigned __int8 __usercall sub_40258C@<al>(unsigned __int8 result@<al>)
{
  if ( result >= 0x61u && result <= 0x7Au )
    result -= 32;
  return result;
}

//----- (00402598) --------------------------------------------------------
int __usercall sub_402598@<eax>(int a1@<eax>)
{
  int v2; // esi
  unsigned __int16 v3; // ax

  v2 = 0;
  v3 = *(_WORD *)(a1 + 4);
  if ( v3 < 0xD7B1u || v3 > 0xD7B3u )
  {
    if ( (_UNKNOWN *)a1 != &unk_40A038 )
      sub_40253C(103);
  }
  else
  {
    if ( (v3 & 0xD7B2) == 0xD7B2 )
      v2 = (*(int (**)(void))(a1 + 28))();
    if ( !v2 )
      v2 = (*(int (**)(void))(a1 + 36))();
    if ( v2 )
      sub_40253C(v2);
  }
  return v2;
}

//----- (004025F0) --------------------------------------------------------
int __usercall sub_4025F0@<eax>(int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // esi
  unsigned int v4; // esi

  v3 = a3 >> 2;
  if ( a3 >> 2 )
  {
    while ( *(_DWORD *)result == *(_DWORD *)a2 )
    {
      v4 = v3 - 1;
      if ( !v4 )
      {
        result += 4;
        a2 += 4;
        goto LABEL_8;
      }
      if ( *(_DWORD *)(result + 4) != *(_DWORD *)(a2 + 4) )
        return result;
      result += 8;
      a2 += 8;
      v3 = v4 - 1;
      if ( !v3 )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    if ( (a3 & 3) != 0
      && *(_BYTE *)result == *(_BYTE *)a2
      && ((a3 & 3) == 1
       || *(_BYTE *)(result + 1) == *(_BYTE *)(a2 + 1)
       && ((a3 & 3) == 2 || *(_BYTE *)(result + 2) == *(_BYTE *)(a2 + 2))) )
    {
      return 0;
    }
  }
  return result;
}

//----- (00402660) --------------------------------------------------------
__int16 __usercall sub_402660@<ax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax
  int v5; // ecx

  BYTE1(a3) = a3;
  v4 = a3 << 16;
  LOWORD(v4) = a3;
  v5 = a2 >> 2;
  if ( a2 >> 2 >= 0 )
  {
    memset32(a1, v4, v5);
    memset(&a1[4 * v5], v4, a2 & 3);
  }
  return v4;
}

//----- (00402680) --------------------------------------------------------
int __usercall Delphi_Random_402680@<eax>(unsigned int a1@<eax>)
{
  dword_409008 = 134775813 * dword_409008 + 1;
  return ((unsigned int)dword_409008 * (unsigned __int64)a1) >> 32;
}
// 409008: using guessed type int dword_409008;

//----- (0040269C) --------------------------------------------------------
int __usercall sub_40269C@<eax>(int result@<eax>, char **a2@<edx>)
{
  char *v2; // esi
  int v3; // ebx
  char v4; // bl
  char v5; // ch
  char *v6; // esi
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // bl
  int v9; // [esp-4h] [ebp-10h]

  v2 = (char *)result;
  v9 = result;
  if ( !result )
    goto LABEL_21;
  result = 0;
  v3 = 0;
  do
    v4 = *v2++;
  while ( v4 == 32 );
  v5 = 0;
  if ( v4 == 45 )
  {
    v5 = 1;
    goto LABEL_26;
  }
  if ( v4 == 43 )
LABEL_26:
    v4 = *v2++;
  if ( v4 != 36 && v4 != 120 && v4 != 88 )
  {
    if ( v4 != 48 )
    {
      if ( v4 )
      {
LABEL_15:
        while ( 1 )
        {
          LOBYTE(v3) = v4 - 48;
          if ( (unsigned __int8)v3 > 9u || (unsigned int)result > 0xCCCCCCC )
            break;
          result = v3 + 10 * result;
          v4 = *v2++;
          if ( !v4 )
            goto LABEL_18;
        }
      }
      goto LABEL_24;
    }
    v4 = *v2++;
    if ( v4 != 120 && v4 != 88 )
    {
      if ( v4 )
        goto LABEL_15;
LABEL_18:
      if ( v5 == 1 )
      {
        result = -result;
        if ( result >= 1 && result != 0 && result >= 0 )
          goto LABEL_24;
      }
      else if ( result < 0 )
      {
        goto LABEL_24;
      }
LABEL_37:
      v6 = 0;
      goto LABEL_38;
    }
  }
  v7 = *v2++;
  if ( v7 )
  {
    while ( 1 )
    {
      if ( v7 >= 0x61u )
        v7 -= 32;
      LOBYTE(v3) = v7 - 48;
      if ( (unsigned __int8)v3 > 9u )
      {
        v8 = v3 - 17;
        if ( v8 > 5u )
          goto LABEL_24;
        LOBYTE(v3) = v8 + 10;
      }
      if ( (unsigned int)result > 0xFFFFFFF )
        goto LABEL_24;
      result = v3 + 16 * result;
      v7 = *v2++;
      if ( !v7 )
      {
        if ( v5 == 1 )
          result = -result;
        goto LABEL_37;
      }
    }
  }
LABEL_21:
  ++v2;
LABEL_24:
  v6 = &v2[-v9];
LABEL_38:
  *a2 = v6;
  return result;
}

//----- (00402770) --------------------------------------------------------
int __usercall sub_402770@<eax>(_BYTE *a1@<eax>, char *a2@<edx>)
{
  return sub_40277C(a1, a2, 0xFFu);
}

//----- (0040277C) --------------------------------------------------------
int __usercall sub_40277C@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  char v3; // bl
  int result; // eax
  _BYTE *v5; // [esp-4h] [ebp-8h]

  v5 = a1;
  if ( a3 > 0xFF )
    a3 = 255;
  do
  {
    v3 = *a2++;
    if ( !v3 )
      break;
    *++a1 = v3;
    --a3;
  }
  while ( a3 );
  result = a1 - v5;
  *v5 = result;
  return result;
}

//----- (004027A0) --------------------------------------------------------
char *__usercall sub_4027A0@<eax>(char *result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // ecx

  if ( a2 )
  {
    if ( result )
    {
      v3 = *(_DWORD *)(a2 - 4);
      if ( v3 >= 0 )
        *(_DWORD *)&result[v3] = a2;
    }
    else
    {
      result = *(char **)(a2 - 8);
      if ( result )
      {
        result = (char *)sub_402448((int)result);
        if ( result )
        {
          memset(result, 0, *(_DWORD *)(a2 - 8));
          v2 = *(_DWORD *)(a2 - 4);
          if ( v2 >= 0 )
            *(_DWORD *)&result[v2] = a2;
        }
      }
    }
  }
  return result;
}

//----- (00402808) --------------------------------------------------------
int sub_402808()
{
  int v0; // ebx
  int v1; // eax

  v0 = 0;
  if ( GetKeyboardType(0) == 7 )
  {
    v1 = GetKeyboardType(1) & 0xFF00;
    if ( v1 == 3328 || v1 == 1024 )
      LOBYTE(v0) = 1;
  }
  return v0;
}

//----- (00402838) --------------------------------------------------------
__int16 sub_402838()
{
  __int16 result; // ax
  unsigned int v1[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v2; // [esp-4h] [ebp-10h]
  DWORD cbData; // [esp+0h] [ebp-Ch] BYREF
  BYTE Data[4]; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  *(_DWORD *)Data = (unsigned __int16)word_409018;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Borland\\Delphi\\RTL", 0, 1u, &phkResult) )
  {
    v2 = &savedregs;
    v1[1] = (unsigned int)sub_4028A9;
    v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v1);
    cbData = 4;
    RegQueryValueExA(phkResult, "FPUMaskValue", 0, 0, Data, &cbData);
    __writefsdword(0, v1[0]);
    v2 = (int *)&loc_4028B0;
    RegCloseKey(phkResult);
  }
  result = Data[0] & 0x3F | word_409018 & 0xFFC0;
  word_409018 = result;
  return result;
}
// 4028A9: using guessed type int __cdecl sub_4028A9(int, int);
// 409018: using guessed type __int16 word_409018;

//----- (004028FC) --------------------------------------------------------
void sub_4028FC()
{
  __asm { fninit }
}

//----- (00402908) --------------------------------------------------------
_DWORD *__usercall sub_402908@<eax>(_DWORD *result@<eax>)
{
  if ( result )
    return (_DWORD *)(*(int (**)(void))(*result - 4))();
  return result;
}

//----- (00402914) --------------------------------------------------------
int sub_402914()
{
  int result; // eax

  if ( (unsigned __int8)byte_40901C > 1u )
    return dword_40A010(250477279, 0, 0, 0);
  return result;
}
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402930) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_402930(int a1@<eax>, int a2@<edx>)
{
  _DWORD v2[3]; // [esp-Ch] [ebp-Ch] BYREF

  if ( byte_40901C )
  {
    v2[1] = a1;
    v2[0] = a2;
    dword_40A010(250477284, 0, 2, v2);
  }
}
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040296C) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_40296C(int a1@<ebx>)
{
  int v1; // [esp-8h] [ebp-8h] BYREF

  if ( (unsigned __int8)byte_40901C > 1u )
  {
    v1 = a1;
    dword_40A010(250477280, 0, 1, &v1);
  }
}
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402980) --------------------------------------------------------
void sub_402980()
{
  ;
}

//----- (004029A0) --------------------------------------------------------
void __fastcall __spoils<edx,ecx> sub_4029A0(int a1, int a2)
{
  int v2; // ecx
  _DWORD v3[4]; // [esp-10h] [ebp-10h] BYREF

  if ( (unsigned __int8)byte_40901C > 1u )
  {
    v3[2] = a2;
    v3[1] = a1;
    sub_402980();
    v3[0] = v2;
    dword_40A010(250477281, 0, 1, v3);
  }
}
// 4029B1: variable 'v2' is possibly undefined
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004029C8) --------------------------------------------------------
void __fastcall sub_4029C8(int a1, int a2)
{
  int v2; // [esp-4h] [ebp-4h] BYREF

  if ( (unsigned __int8)byte_40901C > 1u )
  {
    v2 = a2;
    dword_40A010(250477282, 0, 1, &v2);
  }
}
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004029E4) --------------------------------------------------------
void __spoils<ecx> sub_4029E4()
{
  int v0; // [esp-8h] [ebp-8h] BYREF

  if ( (unsigned __int8)byte_40901C > 1u )
    dword_40A010(250477283, 0, 2, &v0);
}
// 40901C: using guessed type char byte_40901C;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402B30) --------------------------------------------------------
int __cdecl sub_402B30(int a1, int a2)
{
  int v2; // ecx
  void (*v3)(void); // ecx

  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = &loc_402B60;
    sub_4029A0(v2 + 5, a2);
    v3();
  }
  return 1;
}
// 402B5A: variable 'v3' is possibly undefined

//----- (00402B68) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_402B68(int a1, int a2)
{
  _DWORD **v2; // eax
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  struct _EXCEPTION_REGISTRATION_RECORD **v6; // [esp-14h] [ebp-14h]

  *(_DWORD *)(a2 + 4) = &loc_402BB3;
  v2 = (_DWORD **)sub_403EC8();
  v3 = *v2;
  *v2 = (_DWORD *)**v2;
  v4 = (_DWORD *)v3[3];
  v4[1] &= ~2u;
  if ( *v4 != 250477278 )
  {
    sub_402908((_DWORD *)v3[2]);
    sub_402914();
  }
  *v6 = NtCurrentTeb()->NtTib.ExceptionList->Next;
  return 1;
}
// 402BB3: positive sp value 28 has been found
// 402B68: could not find valid save-restore pair for ebx
// 402B68: could not find valid save-restore pair for ebp
// 402B68: could not find valid save-restore pair for edi
// 402B68: could not find valid save-restore pair for esi
// 402BAD: variable 'v6' is possibly undefined

//----- (00402BBC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_402BBC(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  _DWORD **v12; // eax
  _DWORD *v13; // edx
  unsigned int v15; // [esp-10h] [ebp-10h]
  int v16; // [esp-4h] [ebp-4h]

  v12 = (_DWORD **)sub_403EC8();
  v13 = *v12;
  *v12 = (_DWORD *)**v12;
  sub_402908((_DWORD *)v13[2]);
  __writefsdword(0, v15);
  sub_4029C8(v15, v16);
  __asm { jmp     edx }
}
// 402BD8: positive sp value 4 has been found
// 402BE9: unbalanced stack, ignored a potential tail call
// 402BDF: variable 'v15' is possibly undefined
// 402BE4: variable 'v16' is possibly undefined

//----- (00402BEC) --------------------------------------------------------
int __stdcall sub_402BEC(unsigned int a1, int a2, int a3)
{
  __writefsdword(0, a1);
  return ((int (*)(void))(a2 + 5))();
}

//----- (00402C04) --------------------------------------------------------
void __thiscall __noreturn sub_402C04(void *this, int *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  unsigned int v5; // eax
  bool v6; // cf
  unsigned int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  unsigned __int8 v11; // al

  v2 = *a2;
  if ( *a2 > -1073741678 )
  {
    if ( v2 > -1073741674 )
    {
      v10 = v2 + 1073741571;
      if ( !v10 )
      {
        v11 = -54;
        goto LABEL_33;
      }
      if ( v10 == 61 )
      {
        v11 = -39;
        goto LABEL_33;
      }
    }
    else
    {
      if ( v2 == -1073741674 )
      {
        v11 = -38;
        goto LABEL_33;
      }
      v8 = v2 + 1073741677;
      if ( !v8 )
        goto LABEL_27;
      v9 = v8 - 1;
      if ( !v9 )
      {
        v11 = -56;
        goto LABEL_33;
      }
      if ( v9 == 1 )
      {
        v11 = -41;
        goto LABEL_33;
      }
    }
  }
  else
  {
    if ( *a2 == -1073741678 )
      goto LABEL_24;
    if ( v2 <= -1073741682 )
    {
      if ( v2 == -1073741682 )
      {
        v11 = -56;
        goto LABEL_33;
      }
      v3 = v2 + 1073741819;
      if ( !v3 )
      {
        v11 = -40;
        goto LABEL_33;
      }
      v4 = v3 - 135;
      if ( !v4 )
      {
        v11 = -55;
        goto LABEL_33;
      }
      if ( v4 != 1 )
        goto LABEL_32;
LABEL_27:
      v11 = -50;
      goto LABEL_33;
    }
    v5 = v2 + 1073741681;
    v6 = v5 < 2;
    v7 = v5 - 2;
    if ( v6 )
    {
LABEL_24:
      v11 = -49;
      goto LABEL_33;
    }
    if ( !v7 )
    {
      v11 = -51;
      goto LABEL_33;
    }
  }
LABEL_32:
  v11 = -1;
LABEL_33:
  sub_4024D8(v11, a2[3], this);
}

//----- (00402CA4) --------------------------------------------------------
int __cdecl sub_402CA4(struct _EXCEPTION_POINTERS ExceptionInfo)
{
  int v1; // eax
  ULONG_PTR retaddr; // [esp+10h] [ebp+0h]

  if ( (ExceptionInfo.ExceptionRecord->ExceptionFlags & 6) == 0
    && (byte_40901C || UnhandledExceptionFilter(&ExceptionInfo)) )
  {
    sub_4028FC();
    dword_40A014(ExceptionInfo.ContextRecord, &loc_402CEA, v1, 0);
    if ( ExceptionInfo.ExceptionRecord->ExceptionCode == 250477278 || dword_40A00C && dword_40A00C() )
    {
      sub_4029E4();
      if ( dword_40A004 )
        dword_40A004();
      retaddr = ExceptionInfo.ExceptionRecord->ExceptionInformation[0];
      sub_403088();
    }
    JUMPOUT(0x402C04);
  }
  return 0;
}
// 402D04: control flows out of bounds to 402C04
// 40A014: invalid function type '?' has been ignored
// 402CE4: variable 'v1' is possibly undefined
// 403088: using guessed type void __noreturn sub_403088(void);
// 40901C: using guessed type char byte_40901C;
// 40A004: using guessed type int (*dword_40A004)(void);
// 40A00C: using guessed type int (*dword_40A00C)(void);
// 40A014: using guessed type int (__stdcall *dword_40A014)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402D44) --------------------------------------------------------
struct _EXCEPTION_REGISTRATION_RECORD **__usercall sub_402D44@<eax>(struct _EXCEPTION_REGISTRATION_RECORD *a1@<ebp>)
{
  struct _EXCEPTION_REGISTRATION_RECORD **result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = (struct _EXCEPTION_REGISTRATION_RECORD **)&a1[-2].Handler;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&a1[-2].Handler);
  *result = ExceptionList;
  result[1] = (struct _EXCEPTION_REGISTRATION_RECORD *)sub_402CA4;
  result[2] = a1;
  dword_40A624 = (int)&a1[-2].Handler;
  return result;
}
// 40A624: using guessed type int dword_40A624;

//----- (00402D64) --------------------------------------------------------
int sub_402D64()
{
  int result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = dword_40A624;
  if ( dword_40A624 )
  {
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    if ( (struct _EXCEPTION_REGISTRATION_RECORD *)dword_40A624 == ExceptionList )
    {
      result = *(_DWORD *)dword_40A624;
      __writefsdword(0, *(_DWORD *)dword_40A624);
    }
    else
    {
      while ( ExceptionList != (struct _EXCEPTION_REGISTRATION_RECORD *)-1 )
      {
        if ( ExceptionList->Next == (struct _EXCEPTION_REGISTRATION_RECORD *)dword_40A624 )
        {
          result = *(_DWORD *)dword_40A624;
          ExceptionList->Next = *(struct _EXCEPTION_REGISTRATION_RECORD **)dword_40A624;
          return result;
        }
        ExceptionList = ExceptionList->Next;
      }
    }
  }
  return result;
}
// 40A624: using guessed type int dword_40A624;

//----- (00402D8C) --------------------------------------------------------
int sub_402D8C()
{
  int result; // eax
  int v1; // ebx
  int v2; // esi
  void (__cdecl *v3)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *); // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h] BYREF
  void *v5; // [esp-8h] [ebp-14h]
  int *v6; // [esp-4h] [ebp-10h]
  int vars0; // [esp+Ch] [ebp+0h] BYREF

  result = (int)*(&dword_40A620 + 2);
  if ( result )
  {
    v1 = (int)*(&dword_40A620 + 3);
    v2 = *(_DWORD *)(result + 4);
    v6 = &vars0;
    v5 = &loc_402DD2;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    while ( v1 > 0 )
    {
      *(&dword_40A620 + 3) = (const void *)--v1;
      v3 = *(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *))(v2 + 8 * v1 + 4);
      if ( v3 )
        v3(ExceptionList, v5, v6);
    }
    result = 0;
    __writefsdword(0, (unsigned int)ExceptionList);
  }
  return result;
}
// 40A620: using guessed type const void *dword_40A620;

//----- (00402DEC) --------------------------------------------------------
int sub_402DEC()
{
  int result; // eax
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  void (*v4)(void); // eax
  unsigned int v5[6]; // [esp-Ch] [ebp-18h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  result = dword_40A628;
  if ( dword_40A628 )
  {
    v1 = *(_DWORD *)dword_40A628;
    v2 = 0;
    v3 = *(_DWORD *)(dword_40A628 + 4);
    v5[2] = (unsigned int)&savedregs;
    v5[1] = (unsigned int)&loc_402E32;
    v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v5);
    if ( v1 > 0 )
    {
      do
      {
        v4 = *(void (**)(void))(v3 + 8 * v2++);
        dword_40A62C = v2;
        if ( v4 )
          v4();
      }
      while ( v1 > v2 );
    }
    result = 0;
    __writefsdword(0, v5[0]);
  }
  return result;
}
// 40A628: using guessed type int dword_40A628;
// 40A62C: using guessed type int dword_40A62C;

//----- (00402E4C) --------------------------------------------------------
int __usercall sub_402E4C@<eax>(int a1@<eax>, int a2@<edx>, struct _EXCEPTION_REGISTRATION_RECORD *a3@<ebp>)
{
  dword_40A010 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))RaiseException;
  dword_40A014 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))RtlUnwind;
  dword_40A628 = a1;
  dword_40A62C = 0;
  dword_40A630 = a2;
  dword_40A01C = *(_DWORD *)(a2 + 4);
  sub_402D44(a3);
  byte_40A024 = 0;
  return sub_402DEC();
}
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);
// 40A014: using guessed type int (__stdcall *dword_40A014)(_DWORD, _DWORD, _DWORD, _DWORD);
// 40A01C: using guessed type int dword_40A01C;
// 40A024: using guessed type char byte_40A024;
// 40A628: using guessed type int dword_40A628;
// 40A62C: using guessed type int dword_40A62C;
// 40A630: using guessed type int dword_40A630;

//----- (00402E8C) --------------------------------------------------------
unsigned int __fastcall sub_402E8C(int a1)
{
  int v1; // ebx
  unsigned int result; // eax

  LOBYTE(a1) = 16;
  v1 = dword_409000;
  do
  {
    Text[(unsigned __int8)a1] = v1 % 10 + 48;
    v1 /= 10;
    --a1;
  }
  while ( v1 );
  LOBYTE(a1) = 28;
  result = dword_409004;
  do
  {
    Text[(unsigned __int8)a1] = byte_409080[result & 0xF];
    result >>= 4;
    --a1;
  }
  while ( result );
  return result;
}
// 409000: using guessed type int dword_409000;
// 409004: using guessed type int dword_409004;

//----- (00402EE8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
BOOL __stdcall sub_402EE8(int a1, int a2, int a3)
{
  BOOL result; // eax

  result = _InterlockedExchange(&dword_409000, 0) == 0;
  qmemcpy(&dword_40A620, dword_40A620, 0x2Cu);
  return result;
}
// 402F12: positive sp value 4 has been found
// 402EE8: could not find valid save-restore pair for ebp
// 402EE8: could not find valid save-restore pair for edi
// 402EE8: could not find valid save-restore pair for esi
// 409000: using guessed type int dword_409000;
// 40A620: using guessed type const void *dword_40A620;

//----- (00402F18) --------------------------------------------------------
void __thiscall sub_402F18(void *this)
{
  HANDLE StdHandle; // eax
  HANDLE v2; // eax
  DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF

  NumberOfBytesWritten = (DWORD)this;
  if ( byte_40A034 )
  {
    if ( word_40A208 == -10318 )
    {
      if ( dword_40A210 )
        dword_40A220();
    }
    StdHandle = GetStdHandle(0xFFFFFFF5);
    WriteFile(StdHandle, Text, 0x1Eu, &NumberOfBytesWritten, 0);
    v2 = GetStdHandle(0xFFFFFFF5);
    WriteFile(v2, &dword_402FA0, 2u, &NumberOfBytesWritten, 0);
  }
  else if ( !byte_409024 )
  {
    MessageBoxA(0, Text, Caption, 0);
  }
}
// 402FA0: using guessed type int dword_402FA0;
// 409024: using guessed type char byte_409024;
// 40A034: using guessed type char byte_40A034;
// 40A208: using guessed type __int16 word_40A208;
// 40A210: using guessed type int dword_40A210;
// 40A220: using guessed type int (*dword_40A220)(void);

//----- (00402FA4) --------------------------------------------------------
void __thiscall __noreturn sub_402FA4(void *this)
{
  void (*v1)(void); // eax
  void *v2; // ecx
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int *v8; // [esp+8h] [ebp-8h]

  if ( !*((_BYTE *)&dword_40A620 + 40) && unk_40A030 )
  {
    do
    {
      v1 = (void (*)(void))unk_40A030;
      unk_40A030 = 0;
      v1();
    }
    while ( unk_40A030 );
  }
  if ( dword_409004 )
  {
    sub_402E8C((int)this);
    sub_402F18(v2);
    dword_409004 = 0;
  }
  while ( 1 )
  {
    if ( *((_BYTE *)&dword_40A620 + 40) == 2 && !dword_409000 )
      *(&dword_40A620 + 3) = 0;
    sub_402D8C();
    if ( *((_BYTE *)&dword_40A620 + 40) <= 1u || dword_409000 )
    {
      v3 = *(&dword_40A620 + 4);
      if ( v3 )
      {
        sub_403C00(v3);
        v4 = (int)*(&dword_40A620 + 4);
        v5 = *(_DWORD *)(v4 + 16);
        if ( v5 != *(_DWORD *)(v4 + 4) )
        {
          if ( v5 )
            FreeLibrary(*(HMODULE *)(v4 + 16));
        }
      }
    }
    sub_402D64();
    if ( *((_BYTE *)&dword_40A620 + 40) == 1 )
      ((void (*)(void))*(&dword_40A620 + 9))();
    if ( *((_BYTE *)&dword_40A620 + 40) )
      sub_402EE8(v6, v7, (int)v8);
    if ( !dword_40A620 )
    {
      if ( dword_40A018 )
        dword_40A018();
      ExitProcess(dword_409000);
    }
    v8 = &dword_409000;
    qmemcpy(&dword_40A620, dword_40A620, 0x2Cu);
  }
}
// 402FDC: variable 'this' is possibly undefined
// 402FE1: variable 'v2' is possibly undefined
// 403042: variable 'v6' is possibly undefined
// 403042: variable 'v7' is possibly undefined
// 403042: variable 'v8' is possibly undefined
// 409000: using guessed type int dword_409000;
// 409004: using guessed type int dword_409004;
// 40A018: using guessed type int (*dword_40A018)(void);
// 40A620: using guessed type const void *dword_40A620;

//----- (0040307C) --------------------------------------------------------
void __usercall __noreturn sub_40307C(int a1@<eax>, void *a2@<ecx>)
{
  dword_409000 = a1;
  sub_402FA4(a2);
}
// 409000: using guessed type int dword_409000;

//----- (00403088) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn sub_403088()
{
  int v0; // [esp-4h] [ebp-4h]

  dword_409004 = v0;
  sub_40307C();
}
// 40308E: positive sp value 4 has been found
// 403088: variable 'v0' is possibly undefined
// 40307C: using guessed type void __noreturn sub_40307C();
// 403088: using guessed type void __noreturn sub_403088();
// 409004: using guessed type int dword_409004;

//----- (00403094) --------------------------------------------------------
_DWORD *__usercall sub_403094@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  _DWORD *v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    if ( *(int *)(v1 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v1 - 8)) )
    {
      v2 = result;
      sub_402468(v1 - 8);
      return v2;
    }
  }
  return result;
}

//----- (004030B8) --------------------------------------------------------
int __usercall sub_4030B8@<eax>(int result@<eax>, int a2@<edx>)
{
  int *v2; // ebx
  int v4; // edx

  v2 = (int *)result;
  do
  {
    v4 = *v2;
    if ( *v2 )
    {
      *v2 = 0;
      if ( *(int *)(v4 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v4 - 8)) )
        result = sub_402468(v4 - 8);
    }
    ++v2;
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (004030E8) --------------------------------------------------------
volatile __int32 *__usercall sub_4030E8@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>)
{
  char *v2; // edx
  char *v3; // eax
  __int32 v4; // edx
  char *v5; // [esp-8h] [ebp-8h]
  char *v6; // [esp-8h] [ebp-8h]
  volatile __int32 *v7; // [esp-4h] [ebp-4h]

  if ( a2 )
  {
    if ( (*(_DWORD *)(a2 - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(a2 - 8)) | (*(_DWORD *)(a2 - 8) == -1) )
    {
      v7 = result;
      v5 = (char *)a2;
      v2 = (char *)sub_403158(*(_DWORD *)(a2 - 4));
      v3 = v5;
      v6 = v2;
      sub_40254C(v3, v2, *((_DWORD *)v3 - 1));
      a2 = (__int32)v6;
      result = v7;
    }
    else
    {
      _InterlockedIncrement((volatile signed __int32 *)(a2 - 8));
    }
  }
  v4 = _InterlockedExchange(result, a2);
  if ( v4 && *(int *)(v4 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v4 - 8)) )
    return (volatile __int32 *)sub_402468(v4 - 8);
  return result;
}

//----- (0040312C) --------------------------------------------------------
volatile __int32 *__usercall sub_40312C@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>)
{
  __int32 v2; // edx

  if ( a2 && !((*(_DWORD *)(a2 - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(a2 - 8)) | (*(_DWORD *)(a2 - 8) == -1)) )
    _InterlockedIncrement((volatile signed __int32 *)(a2 - 8));
  v2 = _InterlockedExchange(result, a2);
  if ( v2 && *(int *)(v2 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v2 - 8)) )
    return (volatile __int32 *)sub_402468(v2 - 8);
  return result;
}

//----- (00403158) --------------------------------------------------------
int __usercall sub_403158@<eax>(int a1@<eax>)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp-8h] [ebp-8h]

  if ( a1 <= 0 )
    return 0;
  v3 = (a1 + 10) & 0xFFFFFFFE;
  v1 = sub_402448(v3);
  *(_WORD *)(v3 + v1 - 2) = 0;
  result = v1 + 8;
  *(_DWORD *)(result - 4) = a1;
  *(_DWORD *)(result - 8) = 1;
  return result;
}

//----- (00403184) --------------------------------------------------------
_DWORD *__usercall sub_403184@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  char *v6; // eax
  int v7; // ecx
  char *v8; // edi
  _DWORD *result; // eax

  v6 = (char *)sub_403158(a3);
  v7 = a3;
  v8 = v6;
  if ( a2 )
    sub_40254C(a2, v6, v7);
  result = sub_403094(a1);
  *a1 = v8;
  return result;
}

//----- (004031B4) --------------------------------------------------------
_DWORD *__usercall sub_4031B4@<eax>(char **a1@<eax>)
{
  char v2; // [esp-4h] [ebp-4h] BYREF

  return sub_403184(a1, &v2, 1);
}

//----- (004031C4) --------------------------------------------------------
_DWORD *__usercall sub_4031C4@<eax>(char **a1@<eax>, char *a2@<edx>)
{
  int v2; // ecx
  char *v3; // ecx
  char *v5; // [esp-4h] [ebp-4h]

  v2 = 0;
  if ( a2 )
  {
    v5 = a2;
    while ( *a2 )
    {
      if ( !a2[1] )
        goto LABEL_10;
      if ( !a2[2] )
        goto LABEL_9;
      if ( !a2[3] )
      {
        ++a2;
LABEL_9:
        ++a2;
LABEL_10:
        ++a2;
        break;
      }
      a2 += 4;
    }
    v3 = a2;
    a2 = v5;
    v2 = v3 - v5;
  }
  return sub_403184(a1, a2, v2);
}

//----- (004031F4) --------------------------------------------------------
_DWORD *__usercall sub_4031F4@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  char *v3; // edi
  bool v4; // zf
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a3;
  v3 = a2;
  v4 = 1;
  do
  {
    if ( !a3 )
      break;
    v4 = *v3++ == 0;
    --a3;
  }
  while ( !v4 );
  if ( v4 )
    a3 = ~a3;
  return sub_403184(a1, a2, v6 + a3);
}

//----- (0040320C) --------------------------------------------------------
int __usercall sub_40320C@<eax>(int result@<eax>)
{
  if ( result )
    return *(_DWORD *)(result - 4);
  return result;
}

//----- (00403214) --------------------------------------------------------
char **__usercall sub_403214@<eax>(char **result@<eax>, __int32 a2@<edx>)
{
  char *v2; // ecx
  char **v3; // ebx
  int v5; // edi
  int v6; // edx
  char *v7; // eax
  int v8; // ecx

  if ( a2 )
  {
    v2 = *result;
    if ( *result )
    {
      v3 = result;
      v5 = *((_DWORD *)v2 - 1);
      v6 = v5 + *(_DWORD *)(a2 - 4);
      if ( (char *)a2 == v2 )
      {
        sub_403534(result, v6);
        v7 = *v3;
        v8 = v5;
      }
      else
      {
        sub_403534(result, v6);
        v7 = (char *)a2;
        v8 = *(_DWORD *)(a2 - 4);
      }
      return (char **)sub_40254C(v7, &(*v3)[v5], v8);
    }
    else
    {
      return (char **)sub_4030E8((volatile __int32 *)result, a2);
    }
  }
  return result;
}

//----- (00403258) --------------------------------------------------------
volatile __int32 *__usercall sub_403258@<eax>(volatile __int32 *a1@<eax>, char *a2@<edx>, char *a3@<ecx>)
{
  char *v6; // edi

  if ( !a2 )
    return sub_4030E8(a1, (__int32)a3);
  if ( !a3 )
    return sub_4030E8(a1, (__int32)a2);
  if ( a2 == *(char **)a1 )
    return (volatile __int32 *)sub_403214((char **)a1, (__int32)a3);
  if ( a3 == *(char **)a1 )
  {
    v6 = (char *)sub_403158(*((_DWORD *)a3 - 1) + *((_DWORD *)a2 - 1));
    sub_40254C(a2, v6, *((_DWORD *)a2 - 1));
    sub_40254C(a3, &v6[*((_DWORD *)a2 - 1)], *((_DWORD *)a3 - 1));
    if ( v6 )
      --*((_DWORD *)v6 - 2);
    return sub_4030E8(a1, (__int32)v6);
  }
  else
  {
    sub_4030E8(a1, (__int32)a2);
    return (volatile __int32 *)sub_403214((char **)a1, (__int32)a3);
  }
}

//----- (004032CC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
volatile __int32 *__usercall sub_4032CC@<eax>(char **a1@<eax>, int a2@<edx>)
{
  int v2; // ebx
  char **v3; // edi
  char *v4; // ecx
  int v5; // eax
  char **v6; // ecx
  int v7; // esi
  char *v8; // esi
  char *v9; // eax
  char *v10; // edx
  int v11; // ecx
  volatile __int32 *result; // eax
  char *v13; // [esp-8h] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-4h]

  v2 = a2;
  v3 = 0;
  v4 = (char *)*(&v15 + a2);
  if ( v4 && *a1 == v4 )
  {
    v3 = (char **)*(&v15 + a2);
    v5 = *((_DWORD *)v4 - 1);
    --a2;
  }
  else
  {
    v5 = 0;
  }
  do
  {
    v6 = (char **)*(&v15 + a2);
    if ( v6 )
    {
      v5 += (int)*(v6 - 1);
      if ( v3 == v6 )
        v3 = 0;
    }
    --a2;
  }
  while ( a2 );
  if ( v3 )
  {
    v7 = (int)*(v3 - 1);
    sub_403534(a1, v5);
    v3 = a1;
    v13 = *a1;
    v8 = &(*a1)[v7];
    --v2;
  }
  else
  {
    v13 = (char *)sub_403158(v5);
    v8 = v13;
  }
  do
  {
    v9 = (char *)*(&v15 + v2);
    v10 = v8;
    if ( v9 )
    {
      v11 = *((_DWORD *)v9 - 1);
      v8 += v11;
      sub_40254C(v9, v10, v11);
    }
    --v2;
  }
  while ( v2 );
  result = (volatile __int32 *)a1;
  if ( !v3 )
  {
    if ( v13 )
      --*((_DWORD *)v13 - 2);
    return sub_4030E8((volatile __int32 *)a1, (__int32)v13);
  }
  return result;
}
// 403350: positive sp value 4 has been found

//----- (00403358) --------------------------------------------------------
int __usercall Delphi_CompareCall_403358@<eax>(int result@<eax>, int *a2@<edx>)
{
  int *v2; // esi
  int *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  bool v6; // cc
  unsigned int v7; // edx
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // ebx
  char v11; // [esp-4h] [ebp-10h]

  v2 = (int *)result;
  v3 = a2;
  if ( (int *)result != a2 )
  {
    if ( result )
    {
      if ( a2 )
      {
        v4 = *(_DWORD *)(result - 4);
        v5 = *(a2 - 1);
        v6 = v4 <= v5;
        result = v4 - v5;
        if ( v6 )
          v5 += result;
        v11 = v5;
        v7 = v5 >> 2;
        if ( v7 )
        {
          while ( *v2 == *v3 )
          {
            v8 = v7 - 1;
            if ( !v8 )
            {
              ++v2;
              ++v3;
              goto LABEL_13;
            }
            if ( v2[1] != v3[1] )
              return result;
            v2 += 2;
            v3 += 2;
            v7 = v8 - 1;
            if ( !v7 )
              goto LABEL_13;
          }
        }
        else
        {
LABEL_13:
          if ( (v11 & 3) == 0
            || (v9 = *v2, v10 = *v3, (unsigned __int8)*v2 == (unsigned __int8)*v3)
            && ((v11 & 3) == 1 || BYTE1(v9) == BYTE1(v10) && ((v11 & 3) == 2 || (v9 & 0xFF0000) == (v10 & 0xFF0000))) )
          {
            result *= 2;
          }
        }
      }
      else
      {
        return *(_DWORD *)(result - 4);
      }
    }
    else
    {
      return -*(a2 - 1);
    }
  }
  return result;
}

//----- (004033FC) --------------------------------------------------------
int __usercall sub_4033FC@<eax>(int result@<eax>)
{
  if ( result )
  {
    if ( !((*(_DWORD *)(result - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(result - 8)) | (*(_DWORD *)(result - 8) == -1)) )
      _InterlockedIncrement((volatile signed __int32 *)(result - 8));
  }
  return result;
}

//----- (0040340C) --------------------------------------------------------
char *__usercall sub_40340C@<eax>(char *result@<eax>)
{
  if ( !result )
    return &byte_403411;
  return result;
}
// 403411: using guessed type char byte_403411;

//----- (00403418) --------------------------------------------------------
char *__usercall sub_403418@<eax>(char **a1@<eax>)
{
  char *v1; // edx
  char *v3; // edx
  char *v4; // eax
  char *v6; // [esp-8h] [ebp-8h]

  v1 = *a1;
  if ( *a1 && *((_DWORD *)v1 - 2) != 1 )
  {
    v3 = (char *)sub_403158(*((_DWORD *)v1 - 1));
    v4 = *a1;
    *a1 = v3;
    v6 = v4;
    sub_40254C(v4, v3, *((_DWORD *)v4 - 1));
    if ( *((int *)v6 - 2) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)v6 - 2) )
      sub_402468((int)(v6 - 8));
    return *a1;
  }
  return v1;
}

//----- (00403464) --------------------------------------------------------
_DWORD *__userpurge Delphi_Copy_403464@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char **a4)
{
  int v4; // ebx
  bool v5; // sf
  bool v6; // of
  int v7; // edx
  int v8; // ebx

  if ( !a1 )
    return sub_403094(a4);
  v4 = *(_DWORD *)(a1 - 4);
  if ( !v4 )
    return sub_403094(a4);
  v6 = __OFSUB__(a2, 1);
  v5 = a2 - 1 < 0;
  v7 = a2 - 1;
  if ( v5 != v6 )
  {
    v7 = 0;
  }
  else if ( v7 >= v4 )
  {
    return sub_403094(a4);
  }
  v8 = v4 - v7;
  if ( a3 < 0 )
    return sub_403094(a4);
  if ( a3 > v8 )
    a3 = v8;
  return sub_403184(a4, (char *)(a1 + v7), a3);
}

//----- (004034A4) --------------------------------------------------------
char *__usercall sub_4034A4@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char *result; // eax
  char *v7; // edx
  int v8; // ecx
  bool v9; // sf
  bool v10; // of
  int v11; // esi
  int v12; // ecx

  result = sub_40345C(a1);
  v7 = *a1;
  if ( *a1 )
  {
    v8 = *((_DWORD *)v7 - 1);
    v10 = __OFSUB__(a2, 1);
    v9 = a2 - 1 < 0;
    v11 = a2 - 1;
    if ( v9 == v10 && v11 < v8 && a3 > 0 )
    {
      v12 = v8 - v11;
      if ( a3 > v12 )
        a3 = v12;
      sub_40254C(&v7[v11 + a3], &v7[v11], v12 - a3);
      return (char *)sub_403534(a1, *((_DWORD *)*a1 - 1) - a3);
    }
  }
  return result;
}

//----- (004034EC) --------------------------------------------------------
_BYTE *__usercall sub_4034EC@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>)
{
  _BYTE *v2; // esi
  _BYTE *v3; // edi
  signed int v4; // ecx
  signed int v5; // edx
  unsigned __int8 v6; // al
  const void *v7; // esi
  bool v8; // zf
  bool v9; // cc
  int v10; // ecx
  int v11; // ebx
  _BYTE *v12; // [esp-18h] [ebp-18h]
  const void *v13; // [esp-14h] [ebp-14h]

  if ( result )
  {
    if ( a2 )
    {
      v2 = result;
      v3 = a2;
      v4 = *((_DWORD *)a2 - 1);
      v5 = *((_DWORD *)result - 1) - 1;
      if ( v5 >= 0 )
      {
        v6 = *result;
        v7 = v2 + 1;
        v8 = v4 == v5;
        v9 = v4 <= v5;
        v10 = v4 - v5;
        if ( !v9 )
        {
          while ( 1 )
          {
            do
            {
              if ( !v10 )
                break;
              v8 = *v3++ == v6;
              --v10;
            }
            while ( !v8 );
            if ( !v8 )
              break;
            v11 = v10;
            v13 = v7;
            v12 = v3;
            v8 = memcmp(v7, v3, v5) == 0;
            v3 = v12;
            v7 = v13;
            if ( v8 )
              return (_BYTE *)(v12 - a2);
            v10 = v11;
          }
        }
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00403534) --------------------------------------------------------
_DWORD *__usercall sub_403534@<eax>(char **a1@<eax>, int a2@<edx>)
{
  char *v4; // edi
  char *v5; // eax
  _DWORD *result; // eax
  char *v7; // eax
  int v8; // ecx
  char *v9; // [esp-4h] [ebp-10h] BYREF

  v4 = 0;
  if ( a2 > 0 )
  {
    v5 = *a1;
    if ( *a1 && *((_DWORD *)v5 - 2) == 1 )
    {
      v9 = v5 - 8;
      sub_402488(&v9, a2 + 9);
      result = v9 + 8;
      *a1 = v9 + 8;
      *(result - 1) = a2;
      *((_BYTE *)result + a2) = 0;
      return result;
    }
    v4 = (char *)sub_403158(a2);
    v7 = *a1;
    if ( *a1 )
    {
      v8 = *((_DWORD *)v7 - 1);
      if ( v8 >= a2 )
        v8 = a2;
      sub_40254C(v7, v4, v8);
    }
  }
  result = sub_403094(a1);
  *a1 = v4;
  return result;
}

//----- (004035A0) --------------------------------------------------------
OLECHAR **__usercall sub_4035A0@<eax>(OLECHAR **result@<eax>)
{
  OLECHAR *v1; // edx
  OLECHAR **v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    v2 = result;
    SysFreeString(v1);
    return v2;
  }
  return result;
}

//----- (004035B8) --------------------------------------------------------
void __usercall sub_4035B8(OLECHAR **a1@<eax>, int a2@<edx>)
{
  OLECHAR *v4; // eax

  do
  {
    v4 = *a1;
    if ( *a1 )
    {
      *a1 = 0;
      SysFreeString(v4);
    }
    ++a1;
    --a2;
  }
  while ( a2 );
}

//----- (004035DC) --------------------------------------------------------
OLECHAR **__usercall sub_4035DC@<eax>(OLECHAR **a1@<eax>, const OLECHAR *a2@<edx>)
{
  unsigned int v2; // ecx
  OLECHAR **result; // eax
  void *v4; // ecx

  if ( !a2 )
    return sub_4035A0(a1);
  v2 = *((_DWORD *)a2 - 1) >> 1;
  if ( !v2 )
    return sub_4035A0(a1);
  result = (OLECHAR **)SysReAllocStringLen(a1, a2, v2);
  if ( !result )
    sub_402530(1, v4);
  return result;
}
// 40359A: variable 'v4' is possibly undefined

//----- (00403600) --------------------------------------------------------
int __usercall sub_403600@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx
  _DWORD **v4; // esi
  int v5; // edi

  v2 = *(unsigned __int8 *)(a2 + 1);
  v4 = (_DWORD **)(v2 + a2 + 10);
  v5 = *(_DWORD *)(v2 + a2 + 6);
  do
  {
    sub_40364C(1, **v4);
    v4 += 2;
  }
  while ( v5-- > 1 );
  return a1;
}
// 40364C: using guessed type int __fastcall sub_40364C(_DWORD, _DWORD);

//----- (00403634) --------------------------------------------------------
int __thiscall sub_403634(void *this)
{
  if ( !dword_409010 )
    sub_402530(16, this);
  return dword_409010();
}
// 409010: using guessed type int (*dword_409010)(void);

//----- (0040364C) --------------------------------------------------------
OLECHAR **__usercall sub_40364C@<eax>(OLECHAR **result@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  OLECHAR **v3; // ebx
  int v5; // edi
  char v6; // al
  int v7; // edx
  bool v8; // cc
  int v9; // ebp
  int v10; // ebp
  int v11; // eax
  OLECHAR **v12; // eax
  OLECHAR **v13; // [esp-4h] [ebp-4h]

  if ( a3 )
  {
    v13 = result;
    v3 = result;
    v5 = a3;
    v6 = *a2;
    v7 = (unsigned __int8)a2[1];
    switch ( v6 )
    {
      case 10:
        if ( a3 > 1 )
          sub_4030B8((int)v3, a3);
        else
          sub_403094(v3);
        break;
      case 11:
        if ( a3 > 1 )
          sub_4035B8(v3, a3);
        else
          sub_4035A0(v3);
        break;
      case 12:
        do
        {
          v3 += 4;
          sub_403634((void *)a3);
          v8 = v5-- <= 1;
        }
        while ( !v8 );
        break;
      case 13:
        v9 = v7;
        do
        {
          v3 = (OLECHAR **)((char *)v3 + *(_DWORD *)&a2[v9 + 2]);
          sub_40364C(*(_DWORD *)&a2[v9 + 6], **(_DWORD **)&a2[v9 + 10]);
          v8 = v5-- <= 1;
        }
        while ( !v8 );
        break;
      case 14:
        v10 = v7;
        do
        {
          v11 = (int)v3;
          v3 = (OLECHAR **)((char *)v3 + *(_DWORD *)&a2[v10 + 2]);
          sub_403600(v11, (int)a2);
          v8 = v5-- <= 1;
        }
        while ( !v8 );
        break;
      case 15:
        do
        {
          v12 = v3++;
          sub_403C70(v12);
          v8 = v5-- <= 1;
        }
        while ( !v8 );
        break;
      case 17:
        do
        {
          ++v3;
          sub_403B30();
          v8 = v5-- <= 1;
        }
        while ( !v8 );
        break;
      default:
        sub_402530(2, (void *)a3);
    }
    return v13;
  }
  return result;
}
// 4036C8: variable 'a3' is possibly undefined
// 403B30: using guessed type int sub_403B30(void);

//----- (00403738) --------------------------------------------------------
int __thiscall sub_403738(void *this)
{
  if ( !dword_409014 )
    sub_402530(16, this);
  return dword_409014();
}
// 409014: using guessed type int (*dword_409014)(void);

//----- (00403750) --------------------------------------------------------
int __usercall sub_403750@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // edi
  int v6; // ebp
  int result; // eax
  int v8; // ecx
  bool v9; // cc
  void *v10; // ecx
  int v11; // eax
  _BYTE *v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-8h] [ebp-18h]
  int v17; // [esp-4h] [ebp-14h]

  v5 = *(unsigned __int8 *)(a3 + 1) + a3 + 10;
  v6 = *(_DWORD *)(*(unsigned __int8 *)(a3 + 1) + a3 + 6);
  result = 0;
  v17 = *(_DWORD *)(*(unsigned __int8 *)(a3 + 1) + a3 + 2);
  do
  {
    v8 = *(_DWORD *)(v5 + 4);
    v9 = v8 <= result;
    v10 = (void *)(v8 - result);
    if ( !v9 )
      sub_40254C((char *)(a2 + result), (char *)(a1 + result), (int)v10);
    v11 = *(_DWORD *)(v5 + 4);
    v12 = **(_BYTE ***)v5;
    LOBYTE(v10) = *v12;
    if ( *v12 == 10 )
    {
      sub_4030E8((volatile __int32 *)(a1 + v11), *(_DWORD *)(v11 + a2));
      v13 = 4;
    }
    else
    {
      switch ( (_BYTE)v10 )
      {
        case 0xB:
          sub_4035DC((OLECHAR **)(a1 + v11), *(const OLECHAR **)(v11 + a2));
          v13 = 4;
          break;
        case 0xC:
          sub_403738(v10);
          v13 = 16;
          break;
        case 0xD:
          v14 = (unsigned __int8)v12[1];
          v15 = *(_DWORD *)&v12[v14 + 2];
          sub_40386C(*(_DWORD *)&v12[v14 + 6]);
          v13 = v15;
          break;
        case 0xE:
          sub_403750(v12, v11 + a2, *(_DWORD *)&v12[(unsigned __int8)v12[1] + 2]);
          v13 = v16;
          break;
        case 0xF:
          sub_403C88((_DWORD *)(a1 + v11), *(_DWORD *)(v11 + a2));
          v13 = 4;
          break;
        case 0x11:
          sub_403B6C((OLECHAR ***)(a1 + v11), *(OLECHAR ***)(v11 + a2), **(_DWORD **)v5);
          v13 = 4;
          break;
        default:
          sub_402530(2, v10);
      }
    }
    result = *(_DWORD *)(v5 + 4) + v13;
    v5 += 8;
    --v6;
  }
  while ( v6 );
  if ( v17 > result )
    return sub_40254C((char *)(a2 + result), (char *)(result + a1), v17 - result);
  return result;
}
// 4037B6: variable 'v10' is possibly undefined
// 403824: variable 'v16' is possibly undefined
// 40386C: using guessed type _DWORD __stdcall sub_40386C(_DWORD);

//----- (0040386C) --------------------------------------------------------
void *__userpurge sub_40386C@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, _BYTE *a3@<ecx>, int a4)
{
  int v6; // edi
  void *result; // eax
  _DWORD *v9; // edi

  v6 = (int)a3;
  LOBYTE(a3) = *a3;
  switch ( (_BYTE)a3 )
  {
    case 0xA:
      do
      {
        result = (void *)sub_4030E8(a1++, *a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 0xB:
      do
      {
        result = sub_4035DC((OLECHAR **)a1++, (const OLECHAR *)*a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 0xC:
      do
      {
        result = (void *)sub_403738(a3);
        a1 += 4;
        a2 += 4;
        --a4;
      }
      while ( a4 );
      break;
    case 0xD:
      v9 = (_DWORD *)(*(unsigned __int8 *)(v6 + 1) + v6 + 2);
      do
      {
        result = (void *)sub_40386C(v9[1]);
        a1 = (volatile __int32 *)((char *)a1 + *v9);
        a2 = (__int32 *)((char *)a2 + *v9);
        --a4;
      }
      while ( a4 );
      break;
    case 0xE:
      do
      {
        sub_403750((int)a1, (int)a2, v6);
        result = (void *)*(unsigned __int8 *)(v6 + 1);
        a1 = (volatile __int32 *)((char *)a1 + *(_DWORD *)((char *)result + v6 + 2));
        a2 = (__int32 *)((char *)a2 + *(_DWORD *)((char *)result + v6 + 2));
        --a4;
      }
      while ( a4 );
      break;
    case 0xF:
      do
      {
        result = sub_403C88(a1++, *a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 0x11:
      do
      {
        result = sub_403B6C((OLECHAR ***)a1++, (OLECHAR **)*a2++, v6);
        --a4;
      }
      while ( a4 );
      break;
    default:
      JUMPOUT(0x402530);
  }
  return result;
}
// 4038AD: control flows out of bounds to 402530
// 4038E1: variable 'a3' is possibly undefined

//----- (00403960) --------------------------------------------------------
void __thiscall __noreturn sub_403960(void *this)
{
  sub_402530(17, this);
}

//----- (00403968) --------------------------------------------------------
int __usercall sub_403968@<eax>(int result@<eax>)
{
  if ( result )
    return *(_DWORD *)(result - 4);
  return result;
}

//----- (00403970) --------------------------------------------------------
int __usercall sub_403970@<eax>(int a1@<eax>)
{
  return sub_403968(a1) - 1;
}

//----- (00403978) --------------------------------------------------------
void *__userpurge sub_403978@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, _BYTE *a3@<ecx>, int a4)
{
  return sub_40386C(a1, a2, a3, a4);
}

//----- (00403990) --------------------------------------------------------
// attributes: thunk
OLECHAR ***__usercall sub_403990@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>)
{
  return sub_403B30(a1, a2);
}

//----- (00403998) --------------------------------------------------------
OLECHAR ***__userpurge sub_403998@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>, void *a3@<ecx>, int *a4)
{
  OLECHAR **v4; // ebx
  int v5; // edi
  OLECHAR ***result; // eax
  int *v7; // ebx
  int v8; // eax
  char **v9; // edx
  char *v10; // esi
  int v11; // ebx
  int *v12; // ebx
  OLECHAR **v13; // ebx
  int v14; // edi
  int v15; // edi
  OLECHAR **v16; // [esp+Ch] [ebp-20h] BYREF
  int v17; // [esp+10h] [ebp-1Ch]
  int v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  OLECHAR ***v23; // [esp+28h] [ebp-4h]
  _DWORD *v24; // [esp+34h] [ebp+8h]

  v22 = (int)a3;
  v23 = a1;
  v4 = *a1;
  v5 = *a4;
  if ( *a4 > 0 )
  {
    v20 = 0;
    if ( v4 )
    {
      v7 = (int *)(v4 - 1);
      v20 = *v7;
      v4 = (OLECHAR **)(v7 - 1);
    }
    v8 = *(unsigned __int8 *)(a2 + 1) + a2;
    v18 = *(_DWORD *)(v8 + 2);
    v9 = *(char ***)(v8 + 6);
    if ( v9 )
      v10 = *v9;
    else
      v10 = 0;
    v17 = v18 * v5;
    if ( v18 * v5 / v5 != v18 )
      sub_402530(4, a3);
    v17 += 8;
    if ( v4 && *v4 != (OLECHAR *)1 )
    {
      *v4 = (OLECHAR *)((char *)*v4 - 1);
      v11 = sub_402448(v17);
      v19 = v20;
      if ( v5 < v20 )
        v19 = v5;
      if ( v10 )
      {
        sub_402660((char *)(v11 + 8), v18 * v19, 0);
        sub_403978((volatile __int32 *)(v11 + 8), (__int32 *)*v23, v10, v19);
      }
      else
      {
        sub_40254C((char *)*v23, (char *)(v11 + 8), v18 * v19);
      }
    }
    else
    {
      v16 = v4;
      if ( v5 < v20 && v10 )
        sub_403988((OLECHAR **)((char *)v4 + v18 * v5 + 8), v10, v20 - v5);
      sub_402488(&v16, v17);
      v11 = (int)v16;
    }
    *(_DWORD *)v11 = 1;
    v12 = (int *)(v11 + 4);
    *v12 = v5;
    v13 = (OLECHAR **)(v12 + 1);
    sub_402660((char *)v13 + v20 * v18, v18 * (v5 - v20), 0);
    if ( v22 > 1 )
    {
      v24 = a4 + 1;
      --v22;
      v14 = v5 - 1;
      if ( v14 >= 0 )
      {
        v15 = v14 + 1;
        v21 = 0;
        do
        {
          sub_403998(v24);
          ++v21;
          --v15;
        }
        while ( v15 );
      }
    }
    result = v23;
    *v23 = v13;
  }
  else
  {
    if ( v5 < 0 )
      sub_402530(4, a3);
    return sub_403990(v23, a2);
  }
  return result;
}

//----- (00403B24) --------------------------------------------------------
OLECHAR ***__usercall sub_403B24@<eax>(OLECHAR ***a1@<eax>, int a2@<edx>, void *a3@<ecx>, int a4)
{
  return sub_403998(a1, a2, a3, &a4);
}

//----- (00403B30) --------------------------------------------------------
OLECHAR ***__usercall sub_403B30@<eax>(OLECHAR ***result@<eax>, int a2@<edx>)
{
  OLECHAR **v2; // ecx
  OLECHAR **v3; // eax
  char **v4; // edx
  int v5; // ecx
  OLECHAR ***v6; // [esp-4h] [ebp-4h]

  v2 = *result;
  if ( *result )
  {
    *result = 0;
    if ( !_InterlockedDecrement((volatile signed __int32 *)v2 - 2) )
    {
      v6 = result;
      v3 = v2;
      v4 = *(char ***)(*(unsigned __int8 *)(a2 + 1) + a2 + 6);
      if ( v4 )
      {
        v5 = (int)*(v2 - 1);
        if ( v5 )
          v3 = sub_40364C(v3, *v4, v5);
      }
      sub_402468((int)(v3 - 2));
      return v6;
    }
  }
  return result;
}

//----- (00403B6C) --------------------------------------------------------
OLECHAR ***__usercall sub_403B6C@<eax>(OLECHAR ***result@<eax>, OLECHAR **a2@<edx>, int a3@<ecx>)
{
  OLECHAR **v3; // ebx
  OLECHAR **v4; // [esp-8h] [ebp-Ch]
  OLECHAR ***v5; // [esp-4h] [ebp-8h]

  v3 = *result;
  if ( a2 )
    _InterlockedIncrement((volatile signed __int32 *)a2 - 2);
  if ( v3 && !_InterlockedDecrement((volatile signed __int32 *)v3 - 2) )
  {
    v5 = result;
    v4 = a2;
    *(v3 - 2) = (OLECHAR *)((char *)*(v3 - 2) + 1);
    sub_403B30(result, a3);
    a2 = v4;
    result = v5;
  }
  *result = a2;
  return result;
}

//----- (00403B94) --------------------------------------------------------
int __usercall sub_403B94@<eax>(int a1@<eax>)
{
  int result; // eax
  unsigned int v2[6]; // [esp-Ch] [ebp-20h] BYREF
  int i; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v4 = a1;
  result = dword_40902C;
  for ( i = dword_40902C; i; i = *(_DWORD *)i )
  {
    v2[2] = (unsigned int)&savedregs;
    v2[1] = (unsigned int)&loc_403BCF;
    v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v2);
    (*(void (__cdecl **)(unsigned int, void *, int *))(i + 4))(v2[0], &loc_403BCF, &savedregs);
    __writefsdword(0, v2[0]);
    result = *(_DWORD *)i;
  }
  return result;
}
// 40902C: using guessed type int dword_40902C;

//----- (00403BF0) --------------------------------------------------------
_DWORD *__usercall sub_403BF0@<eax>(_DWORD *result@<eax>)
{
  *result = dword_409028;
  dword_409028 = (int)result;
  return result;
}
// 409028: using guessed type int dword_409028;

//----- (00403C00) --------------------------------------------------------
_DWORD *__usercall sub_403C00@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *result; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-10h] BYREF
  int *v3; // [esp-4h] [ebp-8h]
  _DWORD *v4; // [esp+0h] [ebp-4h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v4 = a1;
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_403C64;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  sub_403B94(a1[1]);
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_403C6B;
  if ( v4 == (_DWORD *)dword_409028 )
  {
    result = (_DWORD *)*v4;
    dword_409028 = *v4;
  }
  else
  {
    result = (_DWORD *)dword_409028;
    if ( dword_409028 )
    {
      while ( (_DWORD *)*result != v4 )
      {
        result = (_DWORD *)*result;
        if ( !result )
          return result;
      }
      *result = *v4;
    }
  }
  return result;
}
// 409028: using guessed type int dword_409028;

//----- (00403C70) --------------------------------------------------------
_DWORD *__usercall sub_403C70@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  _DWORD *v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    v2 = result;
    (*(void (__stdcall **)(int))(*(_DWORD *)v1 + 8))(v1);
    return v2;
  }
  return result;
}

//----- (00403C88) --------------------------------------------------------
_DWORD *__usercall sub_403C88@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  bool v3; // zf
  _DWORD *v4; // [esp-8h] [ebp-8h]

  if ( a2 )
  {
    v4 = result;
    (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 4))(a2);
    result = v4;
    v2 = *v4;
    *v4 = a2;
    if ( !v2 )
      return result;
  }
  else
  {
    v2 = *result;
    v3 = *result == 0;
    *result = 0;
    if ( v3 )
      return result;
  }
  return (_DWORD *)(*(int (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
}

//----- (00403CB4) --------------------------------------------------------
int __usercall sub_403CB4@<eax>(LCID a1@<eax>)
{
  int v1; // ebx
  unsigned int v3[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v4; // [esp-4h] [ebp-18h]
  char *v5; // [esp+4h] [ebp-10h] BYREF
  CHAR LCData[7]; // [esp+9h] [ebp-Bh] BYREF
  char *v7; // [esp+10h] [ebp-4h] BYREF
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v5 = 0;
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_403D1A;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  GetLocaleInfoA(a1, 0x1004u, LCData, 7);
  sub_4031F4(&v5, LCData, 7);
  v1 = sub_40269C((int)v5, &v7);
  if ( v7 )
    v1 = 0;
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_403D21;
  sub_403094(&v5);
  return v1;
}
// 403CB4: using guessed type char *var_10;

//----- (00403D28) --------------------------------------------------------
int sub_403D28()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_403D72;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_40A5A4 )
  {
    sub_402598((int)&unk_40A038);
    sub_402598((int)&unk_40A204);
    sub_402598((int)&unk_40A3D0);
    sub_40184C();
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A5A4: using guessed type int dword_40A5A4;

//----- (00403D7C) --------------------------------------------------------
void sub_403D7C()
{
  LCID ThreadLocale; // eax

  if ( dword_40A5A4-- == 0 )
  {
    byte_40900C = 2;
    dword_40A010 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))RaiseException;
    dword_40A014 = (int)RtlUnwind;
    byte_40A036 = 2;
    dword_40A000 = (int)sub_403960;
    if ( (unsigned __int8)sub_402808() )
      sub_402838();
    sub_4028FC();
    word_40A03C = -10320;
    word_40A208 = -10320;
    word_40A3D4 = -10320;
    dword_40A02C = (int)GetCommandLineA();
    dword_40A028 = sub_401098();
    if ( (GetVersion() & 0x80000000) == 0x80000000 || (unsigned __int8)GetVersion() <= 4u )
    {
      ThreadLocale = GetThreadLocale();
      dword_40A5A8 = sub_403CB4(ThreadLocale);
    }
    else
    {
      dword_40A5A8 = 3;
    }
    dword_40A020 = GetCurrentThreadId();
  }
}
// 40900C: using guessed type char byte_40900C;
// 40A000: using guessed type int dword_40A000;
// 40A010: using guessed type int (__stdcall *dword_40A010)(_DWORD, _DWORD, _DWORD, _DWORD);
// 40A014: using guessed type int dword_40A014;
// 40A020: using guessed type int dword_40A020;
// 40A028: using guessed type int dword_40A028;
// 40A02C: using guessed type int dword_40A02C;
// 40A036: using guessed type char byte_40A036;
// 40A03C: using guessed type __int16 word_40A03C;
// 40A208: using guessed type __int16 word_40A208;
// 40A3D4: using guessed type __int16 word_40A3D4;
// 40A5A4: using guessed type int dword_40A5A4;
// 40A5A8: using guessed type int dword_40A5A8;

//----- (00403E70) --------------------------------------------------------
HLOCAL __usercall sub_403E70@<eax>(SIZE_T a1@<eax>)
{
  return LocalAlloc_0(0x40u, a1);
}

//----- (00403E7C) --------------------------------------------------------
int sub_403E7C()
{
  return 8;
}

//----- (00403E84) --------------------------------------------------------
int sub_403E84()
{
  int result; // eax
  HLOCAL v1; // eax

  result = sub_403E7C();
  if ( result )
  {
    if ( TlsIndex == -1 )
      sub_403088();
    v1 = sub_403E70(result);
    if ( !v1 )
      sub_403088();
    return TlsSetValue(TlsIndex, v1);
  }
  return result;
}
// 403088: using guessed type void __noreturn sub_403088(void);

//----- (00403EC8) --------------------------------------------------------
LPVOID sub_403EC8()
{
  LPVOID result; // eax

  if ( !byte_40A64C )
    return (LPVOID)*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  result = TlsGetValue(TlsIndex);
  if ( !result )
  {
    sub_403E84();
    result = TlsGetValue(TlsIndex);
    if ( !result )
      return (LPVOID)dword_40A658;
  }
  return result;
}
// 40A64C: using guessed type char byte_40A64C;
// 40A658: using guessed type int dword_40A658;

//----- (00403F08) --------------------------------------------------------
_DWORD *sub_403F08()
{
  return sub_403BF0(&dword_409094);
}
// 409094: using guessed type _DWORD dword_409094;

//----- (00403F14) --------------------------------------------------------
int __usercall sub_403F14@<eax>(int a1@<eax>, struct _EXCEPTION_REGISTRATION_RECORD *a2@<ebp>)
{
  TlsIndex = 0;
  hwnd = GetModuleHandleA(0);
  dword_409098 = (int)hwnd;
  dword_40909C = 0;
  dword_4090A0 = 0;
  sub_403F08();
  return sub_402E4C(a1, (int)&dword_409094, a2);
}
// 409094: using guessed type _DWORD dword_409094;
// 409098: using guessed type int dword_409098;
// 40909C: using guessed type int dword_40909C;
// 4090A0: using guessed type int dword_4090A0;

//----- (00403F58) --------------------------------------------------------
int sub_403F58()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_403F7D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A654;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A654: using guessed type int dword_40A654;

//----- (00403F88) --------------------------------------------------------
void sub_403F88()
{
  --dword_40A654;
}
// 40A654: using guessed type int dword_40A654;

//----- (00403F90) --------------------------------------------------------
int sub_403F90()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_403FB5;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A65C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A65C: using guessed type int dword_40A65C;

//----- (00403FC0) --------------------------------------------------------
void sub_403FC0()
{
  --dword_40A65C;
}
// 40A65C: using guessed type int dword_40A65C;

//----- (00404018) --------------------------------------------------------
HANDLE __stdcall sub_404018(LPSECURITY_ATTRIBUTES lpMutexAttributes, int a2, LPCSTR lpName)
{
  return CreateMutexA(lpMutexAttributes, a2 != 0, lpName);
}

//----- (00404198) --------------------------------------------------------
__int16 __usercall sub_404198@<ax>(char *a1@<eax>, int a2@<edx>)
{
  return sub_402660(a1, a2, 0);
}

//----- (004041A0) --------------------------------------------------------
int sub_4041A0()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4041C5;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A660;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A660: using guessed type int dword_40A660;

//----- (004041D0) --------------------------------------------------------
void sub_4041D0()
{
  --dword_40A660;
}
// 40A660: using guessed type int dword_40A660;

//----- (004041D8) --------------------------------------------------------
int sub_4041D8()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4041FD;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A664;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A664: using guessed type int dword_40A664;

//----- (00404208) --------------------------------------------------------
void sub_404208()
{
  --dword_40A664;
}
// 40A664: using guessed type int dword_40A664;

//----- (00404210) --------------------------------------------------------
int sub_404210()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_404235;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A668;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A668: using guessed type int dword_40A668;

//----- (00404240) --------------------------------------------------------
void sub_404240()
{
  --dword_40A668;
}
// 40A668: using guessed type int dword_40A668;

//----- (00404258) --------------------------------------------------------
int sub_404258()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40427D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A66C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A66C: using guessed type int dword_40A66C;

//----- (00404288) --------------------------------------------------------
void sub_404288()
{
  --dword_40A66C;
}
// 40A66C: using guessed type int dword_40A66C;

//----- (00404290) --------------------------------------------------------
int sub_404290()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4042B5;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A670;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A670: using guessed type int dword_40A670;

//----- (004042C0) --------------------------------------------------------
void sub_4042C0()
{
  --dword_40A670;
}
// 40A670: using guessed type int dword_40A670;

//----- (004042C8) --------------------------------------------------------
int sub_4042C8()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4042ED;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A674;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A674: using guessed type int dword_40A674;

//----- (004042F8) --------------------------------------------------------
void sub_4042F8()
{
  --dword_40A674;
}
// 40A674: using guessed type int dword_40A674;

//----- (00404300) --------------------------------------------------------
int sub_404300()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_404325;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A678;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A678: using guessed type int dword_40A678;

//----- (00404330) --------------------------------------------------------
void sub_404330()
{
  --dword_40A678;
}
// 40A678: using guessed type int dword_40A678;

//----- (00404338) --------------------------------------------------------
int sub_404338()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40435D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A67C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A67C: using guessed type int dword_40A67C;

//----- (00404368) --------------------------------------------------------
void sub_404368()
{
  --dword_40A67C;
}
// 40A67C: using guessed type int dword_40A67C;

//----- (00404370) --------------------------------------------------------
int sub_404370()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_404395;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A680;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A680: using guessed type int dword_40A680;

//----- (004043A0) --------------------------------------------------------
void sub_4043A0()
{
  --dword_40A680;
}
// 40A680: using guessed type int dword_40A680;

//----- (004043A8) --------------------------------------------------------
int sub_4043A8()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4043CD;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A684;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A684: using guessed type int dword_40A684;

//----- (004043D8) --------------------------------------------------------
void sub_4043D8()
{
  --dword_40A684;
}
// 40A684: using guessed type int dword_40A684;

//----- (004043E0) --------------------------------------------------------
int sub_4043E0()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_404405;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A688;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A688: using guessed type int dword_40A688;

//----- (00404410) --------------------------------------------------------
void sub_404410()
{
  --dword_40A688;
}
// 40A688: using guessed type int dword_40A688;

//----- (00404490) --------------------------------------------------------
void *__usercall sub_404490@<eax>(void *result@<eax>)
{
  if ( !result )
    return &unk_4090E4;
  return result;
}

//----- (0040449C) --------------------------------------------------------
void sub_40449C()
{
  ;
}

//----- (004044A8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int32 sub_4044A8()
{
  __int32 v1; // [esp-4h] [ebp-4h] BYREF
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v1 = _InterlockedExchange((volatile __int32 *)&retaddr, v1);
  sub_403094(&v1);
  return v1;
}
// 4044A9: positive sp value 4 has been found

//----- (004044B8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_4044B8(int a1@<ebx>)
{
  HDC CompatibleDC; // eax
  int v2; // edx
  void *v3; // eax
  int v4; // [esp-8h] [ebp-8h]
  int v5; // [esp-4h] [ebp-4h]
  HDC v6; // [esp-4h] [ebp-4h]

  CompatibleDC = CreateCompatibleDC(0);
  v2 = v5;
  v6 = CompatibleDC;
  v4 = v2;
  (*(void (**)(void))(a1 + 52))();
  v3 = (void *)sub_406154(a1);
  SelectObject(v6, v3);
  __asm { retn }
}
// 4044C0: positive sp value 4 has been found
// 4044DF: unbalanced stack, ignored a potential tail call
// 4044BF: variable 'v5' is possibly undefined

//----- (004044E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
BOOL sub_4044E0()
{
  void *v1; // [esp-8h] [ebp-8h]
  HDC v2; // [esp-4h] [ebp-4h]

  SelectObject(v2, v1);
  return DeleteDC(v2);
}
// 4044E3: positive sp value C has been found
// 4044E7: variable 'v2' is possibly undefined
// 4044E7: variable 'v1' is possibly undefined

//----- (004044F8) --------------------------------------------------------
char *__usercall sub_4044F8@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char *result; // eax
  char v3; // zf
  char *v4; // [esp-4h] [ebp-4h]

  result = sub_4027A0(a1, a2);
  if ( !v3 )
  {
    v4 = result;
    (**(void (***)(void))result)();
    return v4;
  }
  return result;
}
// 4044FD: variable 'v3' is possibly undefined

//----- (00404520) --------------------------------------------------------
_DWORD *__usercall sub_404520@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  char v2; // cf

  if ( result )
  {
    v1 = result[1];
    v2 = v1 & 1;
    if ( v1 >> 1 )
    {
      if ( v1 & 1 )
        return result;
      --result[1];
      v2 = 1;
    }
    if ( !v2 )
      return (_DWORD *)(*(int (**)(void))(*result + 4))();
  }
  return result;
}

//----- (0040452C) --------------------------------------------------------
int __usercall sub_40452C@<eax>(_DWORD *a1@<eax>)
{
  sub_40453C(a1);
  return sub_402468((int)a1);
}

//----- (0040453C) --------------------------------------------------------
_DWORD *__usercall sub_40453C@<eax>(_DWORD *result@<eax>)
{
  void (*v1)(void); // ecx
  __int32 v2; // ecx
  void (__cdecl **v3)(int); // esi
  int v4; // ecx
  void (__cdecl *v5)(int); // eax
  int v6; // [esp-Ch] [ebp-Ch]
  _DWORD *v7; // [esp-8h] [ebp-8h]
  _DWORD *v8; // [esp-4h] [ebp-4h]

  v1 = (void (*)(void))_InterlockedExchange(result + 2, 0);
  if ( v1 )
  {
    v8 = result;
    v1();
    result = v8;
  }
  v2 = _InterlockedExchange(result + 4, 0);
  if ( v2 )
  {
    v7 = (_DWORD *)v2;
    v3 = *(void (__cdecl ***)(int))(v2 + 24);
    v4 = *(_DWORD *)(v2 + 28);
    do
    {
      v5 = *v3;
      v3 += 2;
      v5(v4);
      v4 = v6 - 2;
    }
    while ( v6 != 2 );
    return sub_404520(v7);
  }
  return result;
}
// 404562: variable 'v6' is possibly undefined

//----- (0040456C) --------------------------------------------------------
char *sub_40456C()
{
  return sub_4044F8(0, (int)off_404424);
}
// 404424: using guessed type int (*off_404424[3])();

//----- (0040457C) --------------------------------------------------------
int __usercall sub_40457C@<eax>(_DWORD *a1@<eax>)
{
  sub_4045D0(a1);
  return sub_40452C(a1);
}

//----- (0040458C) --------------------------------------------------------
_DWORD *__usercall sub_40458C@<eax>(_DWORD *a1@<eax>)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  int v5; // [esp-Ch] [ebp-Ch]
  int v6; // [esp-8h] [ebp-8h]
  _DWORD *v7; // [esp-4h] [ebp-4h]

  if ( a1 )
  {
    v1 = a1[7];
    if ( v1 )
    {
      v2 = a1[6];
      v7 = a1;
      do
      {
        v3 = *(_DWORD *)(v2 + 4 * v1 - 4);
        if ( v3 )
        {
          v6 = v2;
          v5 = v1;
          sub_402468(v3);
          v1 = v5;
          v2 = v6;
        }
        --v1;
      }
      while ( v1 );
      a1 = v7;
    }
  }
  return sub_404520(a1);
}

//----- (004045B4) --------------------------------------------------------
_DWORD *__usercall sub_4045B4@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  if ( a2 < result[7] )
    a2 = result[7];
  if ( a2 != result[8] )
  {
    result[8] = a2;
    return sub_402488(result + 6, 4 * a2);
  }
  return result;
}

//----- (004045D0) --------------------------------------------------------
int __usercall sub_4045D0@<eax>(_DWORD *a1@<eax>)
{
  int v2; // [esp-4h] [ebp-4h]

  v2 = a1[6];
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  return sub_402468(v2);
}

//----- (004045E8) --------------------------------------------------------
unsigned int __usercall sub_4045E8@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  unsigned int v2; // edx
  int v3; // ecx
  unsigned int result; // eax
  unsigned int v6; // [esp-8h] [ebp-8h]

  v2 = a1[7];
  a1[7] = v2 + 1;
  v6 = v2;
  if ( (signed int)v2 >= a1[8] )
  {
    v3 = a1[9];
    if ( !v3 )
      v3 = (v2 >> 2) + 1;
    sub_4045B4(a1, v3 + v2);
  }
  result = v6;
  *(_DWORD *)(a1[6] + 4 * v6) = a2;
  return result;
}

//----- (00404618) --------------------------------------------------------
int __usercall sub_404618@<eax>(int a1@<eax>, int a2@<edx>)
{
  return sub_404624(a1, a2, 1);
}

//----- (00404624) --------------------------------------------------------
int __usercall sub_404624@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx
  int v4; // eax
  int v5; // [esp-8h] [ebp-8h]

  if ( a3 > 0 && a2 < *(_DWORD *)(result + 28) )
  {
    v3 = result;
    if ( (unsigned int)(a3 + a2) > *(_DWORD *)(result + 28) )
      a3 = *(_DWORD *)(result + 28) - a2;
    v4 = *(_DWORD *)(result + 24);
    v5 = *(_DWORD *)(v3 + 28);
    *(_DWORD *)(v3 + 28) = v5 - a3;
    return sub_40254C((char *)(v4 + 4 * a2 + 4 * a3), (char *)(v4 + 4 * a2), 4 * (v5 - (a3 + a2)));
  }
  return result;
}

//----- (0040465C) --------------------------------------------------------
int __usercall sub_40465C@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx

  v2 = 0;
  if ( a2 >= 0 && a2 < *(_DWORD *)(a1 + 28) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * a2);
  return v2;
}

//----- (00404670) --------------------------------------------------------
char *__usercall sub_404670@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char v3; // of
  char *result; // eax
  int v6; // [esp-Ch] [ebp-Ch]
  int v8; // [esp-8h] [ebp-8h]

  v6 = a1[7];
  sub_4045E8(a1, a2);
  result = (char *)(a1[6] + 4 * a2);
  if ( (((v6 - a2) & 0x20000000) != 0) == v3 )
  {
    v8 = a1[6] + 4 * a2;
    sub_40254C(result, result + 4, 4 * (v6 - a2));
    result = (char *)v8;
  }
  *(_DWORD *)result = a3;
  return result;
}
// 40468B: variable 'v3' is possibly undefined

//----- (0040469C) --------------------------------------------------------
signed int __usercall sub_40469C@<eax>(signed int result@<eax>)
{
  if ( result < 0 )
    return GetSysColor((unsigned __int8)result);
  return result;
}

//----- (004046C0) --------------------------------------------------------
_BYTE *__usercall sub_4046C0@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>)
{
  _BYTE *v2; // edi
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  _BYTE *v6; // edi

  v2 = a1;
  v3 = -1;
  v4 = 1;
  do
  {
    if ( !v3 )
      break;
    v4 = *v2++ == 0;
    --v3;
  }
  while ( !v4 );
  v5 = ~v3;
  v6 = a1;
  do
  {
    if ( !v5 )
      break;
    v4 = *v6++ == a2;
    --v5;
  }
  while ( !v4 );
  if ( v4 )
    return v6 - 1;
  else
    return 0;
}

//----- (004046DC) --------------------------------------------------------
const char *__usercall sub_4046DC@<eax>(const char *a1@<eax>, unsigned __int8 a2@<dl>)
{
  unsigned int v2; // ecx
  bool v3; // zf
  const char *v4; // edi
  const char *result; // eax

  v2 = strlen(a1) + 1;
  v4 = &a1[v2 - 1];
  v3 = &a1[v2] == (const char *)1;
  do
  {
    if ( !v2 )
      break;
    v3 = *v4-- == a2;
    --v2;
  }
  while ( !v3 );
  result = 0;
  if ( v3 )
    return v4 + 1;
  return result;
}

//----- (00404700) --------------------------------------------------------
unsigned __int8 __usercall sub_404700@<al>(__int32 a1@<eax>, volatile __int32 *a2@<edx>)
{
  unsigned __int8 v2; // cl
  char *v3; // esi
  unsigned __int8 result; // al
  int i; // ecx
  int v6; // et1
  char v7; // al

  sub_4030E8(a2, a1);
  v3 = sub_40345C((char **)a2);
  v6 = sub_40320C((int)v3);
  result = v2;
  for ( i = v6; i; --i )
  {
    v7 = *v3++;
    result = v7 - 65;
    if ( result < 0x1Au )
      *(v3 - 1) += 32;
  }
  return result;
}
// 404715: variable 'v2' is possibly undefined

//----- (00404728) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *__usercall sub_404728@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)
{
  int v3; // eax
  int v4; // edx
  char **v9; // [esp-4h] [ebp-4h]

  v3 = sub_40320C(a1);
  v4 = a2;
  if ( a2 <= 0 )
    v4 = 1;
  if ( v3 >= v4 )
    return Delphi_Copy_403464(a1, v4, v3 - v4 + 1, v9);
  else
    return sub_403094(a3);
}
// 40474C: positive sp value 4 has been found
// 404747: variable 'v9' is possibly undefined

//----- (00404750) --------------------------------------------------------
int __usercall sub_404750@<eax>(void *a1@<eax>)
{
  unsigned __int8 v1; // dl
  _BYTE *v2; // eax
  _BYTE *v4; // [esp-4h] [ebp-4h]

  v4 = sub_404490(a1);
  v2 = sub_4046C0(v4, v1);
  if ( v2 )
    return v2 - v4 + 1;
  else
    return -1;
}
// 404756: variable 'v1' is possibly undefined

//----- (00404768) --------------------------------------------------------
int __usercall sub_404768@<eax>(void *a1@<eax>)
{
  int result; // eax
  _BYTE *v2; // edx
  _BYTE *v3; // esi
  int v4; // ecx
  bool v5; // cc
  int v6; // et1
  int v7; // [esp-8h] [ebp-Ch]

  sub_40449C();
  v3 = v2;
  v4 = -1;
  do
  {
    while ( 1 )
    {
      LOBYTE(result) = *v3++;
      v5 = (result & 0x80u) != 0;
      if ( !(_BYTE)result )
        break;
      v7 = v4;
      result = sub_404750(a1);
      v4 = v7;
      if ( result > 0 )
      {
        v5 = v7 < 0;
        if ( v7 <= 0 )
          break;
        v5 = result < v7;
        if ( result < v7 )
          break;
      }
    }
    v6 = result;
    result = v4;
    v4 = v6;
  }
  while ( v5 );
  return result;
}
// 40476F: variable 'v2' is possibly undefined
// 40478F: variable 'result' is possibly undefined

//----- (00404798) --------------------------------------------------------
_DWORD *__usercall sub_404798@<eax>(void **a1@<eax>, char **a2@<ecx>)
{
  int v3; // eax
  int v4; // edi

  v3 = sub_404768(*a1) + 1;
  if ( !v3 )
    v3 = sub_40320C((int)*a1) + 2;
  v4 = v3 - 1;
  Delphi_Copy_403464((int)*a1, 1, v3 - 2, a2);
  return sub_404728((int)*a1, v4 + 1, a1);
}

//----- (004047D0) --------------------------------------------------------
int __usercall sub_4047D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>)
{
  int result; // eax
  int v6; // edx
  bool v7; // zf
  unsigned int v8; // ecx

  result = 0;
  v6 = a3 & 3;
  v8 = a3 >> 2;
  v7 = v8 == 0;
  do
  {
    if ( !v8 )
      break;
    v7 = *a1++ == *a2++;
    --v8;
  }
  while ( v7 );
  if ( v7 && !memcmp(a1, a2, v6) )
    return 1;
  return result;
}

//----- (004047F0) --------------------------------------------------------
int __usercall sub_4047F0@<eax>(int result@<eax>)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // [esp-4h] [ebp-4h]
  char *v5; // [esp-4h] [ebp-4h]

  if ( result )
  {
    v4 = result;
    v1 = (char *)sub_402448(result);
    v2 = v4;
    v5 = v1;
    LOBYTE(v3) = 0;
    sub_402660(v1, v2, v3);
    return (int)v5;
  }
  return result;
}
// 4047FE: variable 'v3' is possibly undefined

//----- (00404808) --------------------------------------------------------
_DWORD *__usercall sub_404808@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  int v4; // ebx
  char *v5; // eax
  _DWORD *result; // eax

  v4 = sub_40320C((int)a1);
  v5 = sub_40340C(a1);
  result = sub_403184(a2, v5, v4);
  if ( v4 > 0 )
    return (_DWORD *)CharLowerBuffA(*a2, v4);
  return result;
}

//----- (0040483C) --------------------------------------------------------
int __usercall sub_40483C@<eax>(int a1@<eax>)
{
  if ( !a1 )
    JUMPOUT(0x404893);
  return sub_404845();
}
// 40483E: control flows out of bounds to 404893
// 404845: using guessed type int sub_404845(void);

//----- (00404845) --------------------------------------------------------
char __usercall sub_404845@<al>(__int16 a1@<ax>, _WORD *a2@<edx>, _BYTE *a3@<ecx>)
{
  _BYTE *v3; // edx
  int v4; // ecx

  while ( *a3 | *(_BYTE *)a2 )
  {
    HIBYTE(a1) = 0;
    if ( *a2 == (unsigned __int8)a1 )
      break;
    if ( !*a3 )
    {
      v3 = (char *)a2 - 1;
      do
        ++v3;
      while ( *v3 == (_BYTE)a1 );
      LOBYTE(a1) = *v3 == 0;
      return a1;
    }
    if ( !*(_BYTE *)a2 )
      goto LABEL_15;
    if ( *(_BYTE *)a2 != 63 )
    {
      if ( *(_BYTE *)a2 == (_BYTE)a1 )
      {
        while ( *a3 != HIBYTE(a1) )
        {
          a1 = sub_404845();
          if ( (_BYTE)a1 )
            return a1;
          a3 = (_BYTE *)(v4 + 1);
        }
LABEL_15:
        LOBYTE(a1) = 0;
        return a1;
      }
      if ( *a3 != *(_BYTE *)a2 )
        goto LABEL_15;
    }
    ++a3;
    a2 = (_WORD *)((char *)a2 + 1);
  }
  return a1;
}
// 404886: variable 'v4' is possibly undefined

//----- (00404894) --------------------------------------------------------
int __usercall sub_404894@<eax>(void *a1@<eax>, void *a2@<edx>)
{
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  char *v7; // [esp-8h] [ebp-Ch] BYREF
  char *v8; // [esp-4h] [ebp-8h] BYREF

  v8 = 0;
  v3 = (char *)sub_404490(a2);
  if ( *v3 )
    sub_404808(v3, &v8);
  v7 = 0;
  v4 = (char *)sub_404490(a1);
  if ( *v4 )
    sub_404808(v4, &v7);
  v5 = sub_40483C((int)v7);
  sub_4044A8();
  sub_4044A8();
  return v5;
}

//----- (004048D8) --------------------------------------------------------
int __usercall sub_4048D8@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>)
{
  int v3; // eax
  unsigned int v4; // ecx
  const char *v5; // edi
  int v6; // edx
  bool v7; // zf

  v3 = 0;
  v4 = strlen(a2) + 1;
  v5 = a2;
  v6 = 0;
  do
  {
    if ( !v4 )
      break;
    v7 = *a1++ == *v5++;
    --v4;
  }
  while ( v7 );
  LOBYTE(v3) = *(a1 - 1);
  LOBYTE(v6) = *(v5 - 1);
  return v3 - v6;
}

//----- (004048F8) --------------------------------------------------------
_BYTE *__usercall sub_4048F8@<eax>(_BYTE *result@<eax>, const char *a2@<edx>)
{
  _BYTE *v2; // esi
  unsigned int v3; // ecx
  const char *v4; // edi
  int v5; // edx
  bool v6; // zf

  v2 = result;
  HIWORD(result) = 0;
  v3 = strlen(a2) + 1;
  v4 = a2;
  do
  {
    v5 = 0;
    do
    {
      if ( !v3 )
        break;
      v6 = *v2++ == *v4++;
      --v3;
    }
    while ( v6 );
    LOBYTE(result) = *(v2 - 1);
    if ( (unsigned __int8)((_BYTE)result - 97) <= 0x19u )
      LOBYTE(result) = (_BYTE)result - 32;
    LOBYTE(v5) = *(v4 - 1);
    if ( (unsigned __int8)(v5 - 97) <= 0x19u )
      LOBYTE(v5) = v5 - 32;
    BYTE1(result) = 0;
    result -= v5;
  }
  while ( !result && (_BYTE)v5 );
  return result;
}

//----- (0040493C) --------------------------------------------------------
int __usercall sub_40493C@<eax>(_BYTE *a1@<eax>)
{
  int v2; // ecx
  int result; // eax
  bool v4; // zf

  v2 = -1;
  result = 0;
  if ( a1 )
  {
    do
    {
      if ( !v2 )
        break;
      v4 = *a1++ == 0;
      --v2;
    }
    while ( !v4 );
    return -2 - v2;
  }
  return result;
}

//----- (00404950) --------------------------------------------------------
const char *__usercall sub_404950@<eax>(void *a1@<eax>)
{
  const char *v1; // eax
  unsigned __int8 *v2; // edx
  unsigned __int8 *v3; // esi
  const char *v4; // edx
  unsigned __int8 v5; // al
  const char *v7; // [esp-8h] [ebp-Ch]
  const char *v8; // [esp-4h] [ebp-8h]

  v1 = (const char *)sub_404490(a1);
  v3 = v2;
  v4 = v1;
  while ( *v1 )
    ++v1;
LABEL_4:
  v8 = v1;
  while ( 1 )
  {
    v5 = *v3++;
    if ( !v5 )
      return v8;
    v7 = v4;
    v1 = sub_4046DC(v4, v5);
    v4 = v7;
    if ( v1 && (!*v8 || (int)v1 > (int)v8) )
      goto LABEL_4;
  }
}
// 404956: variable 'v2' is possibly undefined

//----- (00404984) --------------------------------------------------------
_BYTE *__usercall sub_404984@<eax>(_BYTE *result@<eax>)
{
  while ( 1 )
  {
    while ( *result && *result <= 0x20u )
      ++result;
    if ( *result != 34 || result[1] != 34 )
      break;
    result += 2;
  }
  return result;
}

//----- (004049A4) --------------------------------------------------------
_BYTE *__usercall sub_4049A4@<eax>(_BYTE *a1@<eax>)
{
  _BYTE *result; // eax

  result = sub_404984(a1);
  while ( *result > 0x20u )
  {
    if ( *result == 34 )
    {
      ++result;
      while ( *result && *result != 34 )
        ++result;
      if ( *result )
        ++result;
    }
    else
    {
      ++result;
    }
  }
  return result;
}

//----- (004049D0) --------------------------------------------------------
_DWORD *__usercall sub_4049D0@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v2; // esi
  int ModuleFileNameA; // eax
  LPSTR CommandLineA_0; // ebx
  char *v5; // edi
  CHAR *v6; // eax
  int v7; // eax
  int v8; // eax
  char **v10; // [esp-10h] [ebp-12Ch]
  char **v11; // [esp-10h] [ebp-12Ch]
  unsigned int v12[2]; // [esp-Ch] [ebp-128h] BYREF
  int *v13; // [esp-4h] [ebp-120h]
  char *v14; // [esp+Ch] [ebp-110h] BYREF
  CHAR Filename[261]; // [esp+13h] [ebp-109h] BYREF
  char **v16; // [esp+118h] [ebp-4h]
  int savedregs; // [esp+11Ch] [ebp+0h] BYREF

  v14 = 0;
  v16 = a2;
  v2 = a1;
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_404ADA;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  if ( a1 )
  {
    CommandLineA_0 = GetCommandLineA_0();
    do
    {
      v5 = sub_404984(CommandLineA_0);
      v6 = sub_4049A4(v5);
      CommandLineA_0 = v6;
      if ( !v2 )
        break;
      if ( --v2 < 0 )
        break;
    }
    while ( v5 != v6 );
    v10 = v16;
    sub_4031C4(&v14, v5);
    Delphi_Copy_403464((int)v14, 1, CommandLineA_0 - v5, v10);
    if ( sub_40320C((int)*v16) >= 2 && **v16 == 34 )
    {
      v7 = sub_40320C((int)*v16);
      if ( (*v16)[v7 - 1] == 34 )
      {
        v11 = v16;
        v8 = sub_40320C((int)*v16);
        Delphi_Copy_403464((int)*v16, 2, v8 - 2, v11);
      }
    }
  }
  else
  {
    ModuleFileNameA = GetModuleFileNameA(0, Filename, 0x105u);
    sub_403184(v16, Filename, ModuleFileNameA);
  }
  __writefsdword(0, v12[0]);
  v13 = (int *)&loc_404AE1;
  return sub_403094(&v14);
}
// 4049D0: using guessed type char *var_110;

//----- (00404AE8) --------------------------------------------------------
int sub_404AE8()
{
  int i; // ebx
  unsigned int v2[2]; // [esp-10h] [ebp-14h] BYREF
  int *v3; // [esp-8h] [ebp-Ch]
  char *v4; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v4 = 0;
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_404B28;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  for ( i = 0; ; ++i )
  {
    sub_4049D0(i + 1, &v4);
    if ( !v4 )
      break;
  }
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_404B2F;
  sub_403094(&v4);
  return i;
}

//----- (00404B38) --------------------------------------------------------
bool __usercall sub_404B38@<al>(_BYTE *a1@<eax>, _BYTE *a2@<edx>)
{
  int v2; // ecx

  HIWORD(v2) = 0;
  do
  {
    LOBYTE(v2) = *a2++;
    BYTE1(v2) = *a1++;
    if ( !v2 )
      break;
    if ( (unsigned __int8)v2 >= 0x61u && (unsigned __int8)v2 <= 0x7Au )
      LOBYTE(v2) = v2 - 32;
    if ( BYTE1(v2) >= 0x61u && BYTE1(v2) <= 0x7Au )
      BYTE1(v2) -= 32;
  }
  while ( (_BYTE)v2 == BYTE1(v2) );
  return (_BYTE)v2 == 0;
}

//----- (00404B68) --------------------------------------------------------
HANDLE __usercall sub_404B68@<eax>(const CHAR *a1@<eax>, DWORD a2@<edx>)
{
  DWORD v2; // ecx
  DWORD v4; // [esp-Ch] [ebp-Ch]
  DWORD v5; // [esp-8h] [ebp-8h]

  v2 = HIWORD(a2);
  LOWORD(v2) = HIWORD(a2) & 0x1FFF;
  if ( (a2 & 0x1FFF0000) == 0 )
    LOBYTE(v2) = 0x80;
  v5 = v2;
  LOBYTE(v2) = BYTE1(a2);
  v4 = v2;
  LOBYTE(v2) = a2;
  LOWORD(a2) = 0;
  return CreateFileA(a1, a2, v2, 0, v4, v5, 0);
}

//----- (00404B90) --------------------------------------------------------
bool __usercall sub_404B90@<al>(void *a1@<eax>)
{
  return CloseHandle(a1);
}

//----- (00404B9C) --------------------------------------------------------
char __usercall sub_404B9C@<al>(void *a1@<eax>)
{
  const CHAR *v1; // eax
  DWORD v2; // eax

  v1 = (const CHAR *)sub_404490(a1);
  v2 = GetFileAttributesA(v1) + 1;
  if ( v2 )
    LOBYTE(v2) = (((_BYTE)v2 - 1) & 0x10) == 0;
  return v2;
}

//----- (00404BB4) --------------------------------------------------------
DWORD __usercall sub_404BB4@<eax>(void *a1@<eax>, LONG a2@<edx>, unsigned __int8 a3@<cl>)
{
  return SetFilePointer(a1, a2, 0, a3);
}

//----- (00404BC4) --------------------------------------------------------
int __usercall sub_404BC4@<eax>(DWORD nNumberOfBytesToRead@<ecx>, LPVOID lpBuffer@<edx>, void *a3@<eax>)
{
  bool v3; // zf
  int result; // eax
  int v5; // [esp-4h] [ebp-8h] BYREF

  v5 = 0;
  v3 = !ReadFile(a3, lpBuffer, nNumberOfBytesToRead, (LPDWORD)&v5, 0);
  result = v5;
  if ( v3 )
    return 0;
  return result;
}

//----- (00404BE0) --------------------------------------------------------
DWORD *__usercall sub_404BE0@<eax>(DWORD nNumberOfBytesToWrite@<ecx>, LPCVOID lpBuffer@<edx>, void *a3@<eax>)
{
  bool v3; // zf
  DWORD *result; // eax
  DWORD savedregs; // [esp+0h] [ebp+0h] BYREF

  v3 = !WriteFile_0(a3, lpBuffer, nNumberOfBytesToWrite, &savedregs, 0);
  result = &savedregs;
  if ( v3 )
    return 0;
  return result;
}

//----- (00404BF8) --------------------------------------------------------
DWORD *__usercall sub_404BF8@<eax>(char *a1@<eax>, const void *a2@<edx>, DWORD a3@<ecx>)
{
  DWORD *v4; // esi
  HANDLE v5; // eax
  void *v6; // ebx
  unsigned int v8[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v9; // [esp-4h] [ebp-18h]
  char *v10; // [esp+Ch] [ebp-8h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v10 = 0;
  nNumberOfBytesToWrite = a3;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_404C66;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v4 = 0;
  sub_4031C4(&v10, a1);
  v5 = sub_404B68(v10, 0x40000400u);
  v6 = v5;
  if ( v5 != (HANDLE)-1 )
  {
    v4 = sub_404BE0(nNumberOfBytesToWrite, a2, v5);
    sub_404B90(v6);
  }
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_404C6D;
  sub_403094(&v10);
  return v4;
}

//----- (00404C78) --------------------------------------------------------
int __usercall sub_404C78@<eax>(char *a1@<eax>, void *a2@<edx>, DWORD a3@<ecx>)
{
  int v4; // esi
  HANDLE v5; // eax
  void *v6; // ebx
  unsigned int v8[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v9; // [esp-4h] [ebp-18h]
  char *v10; // [esp+Ch] [ebp-8h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v10 = 0;
  nNumberOfBytesToRead = a3;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_404CE6;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v4 = 0;
  sub_4031C4(&v10, a1);
  v5 = sub_404B68(v10, 0x80000301);
  v6 = v5;
  if ( v5 != (HANDLE)-1 )
  {
    v4 = sub_404BC4(nNumberOfBytesToRead, a2, v5);
    sub_404B90(v6);
  }
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_404CED;
  sub_403094(&v10);
  return v4;
}

//----- (00404CF8) --------------------------------------------------------
char __usercall sub_404CF8@<al>(const CHAR *a1@<eax>)
{
  DWORD v1; // eax

  v1 = GetFileAttributesA(a1) + 1;
  if ( v1 )
    LOBYTE(v1) = (((_BYTE)v1 - 1) & 0x10) != 0;
  return v1;
}

//----- (00404D08) --------------------------------------------------------
volatile __int32 *__usercall sub_404D08@<eax>(__int32 a1@<eax>, char a2@<dl>, volatile __int32 *a3@<ecx>)
{
  volatile __int32 *result; // eax
  int v6; // eax

  result = sub_4030E8(a3, a1);
  if ( *a3 )
  {
    result = (volatile __int32 *)sub_40320C(*a3);
    if ( a2 == *((_BYTE *)result + *a3 - 1) )
    {
      v6 = sub_40320C(*a3);
      return (volatile __int32 *)sub_4034A4((char **)a3, v6, 1);
    }
  }
  return result;
}

//----- (00404D48) --------------------------------------------------------
_DWORD *__usercall sub_404D48@<eax>(__int32 a1@<eax>, char a2@<dl>, volatile __int32 *a3@<ecx>)
{
  unsigned int v6[2]; // [esp-18h] [ebp-1Ch] BYREF
  int *v7; // [esp-10h] [ebp-14h]
  char *v8; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v8 = 0;
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_404DAB;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_4030E8(a3, a1);
  if ( !*a3 || a2 != *(_BYTE *)(*a3 + sub_40320C(*a3) - 1) )
  {
    sub_4031B4(&v8);
    sub_403214((char **)a3, (__int32)v8);
  }
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_404DB2;
  return sub_403094(&v8);
}

//----- (00404DB8) --------------------------------------------------------
_DWORD *__usercall sub_404DB8@<eax>(__int32 a1@<eax>, volatile __int32 *a2@<edx>)
{
  return sub_404D48(a1, 92, a2);
}

//----- (00404DCC) --------------------------------------------------------
volatile __int32 *__usercall sub_404DCC@<eax>(__int32 a1@<eax>, volatile __int32 *a2@<edx>)
{
  return sub_404D08(a1, 92, a2);
}

//----- (00404DE0) --------------------------------------------------------
int __usercall sub_404DE0@<eax>(void *a1@<eax>, int a2@<ebx>)
{
  int v2; // eax
  char v3; // zf
  unsigned int v5[2]; // [esp-10h] [ebp-20h] BYREF
  int *v6; // [esp-8h] [ebp-18h]
  int v7; // [esp-4h] [ebp-14h]
  char *v8; // [esp+0h] [ebp-10h] BYREF
  char *v9; // [esp+4h] [ebp-Ch] BYREF
  __int32 v10; // [esp+8h] [ebp-8h] BYREF
  void *v11; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = a2;
  v11 = a1;
  sub_4033FC((int)a1);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_404E9F;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v2 = sub_40320C((int)v11);
  LOBYTE(a2) = v2 > 0;
  if ( v2 > 0 )
  {
    sub_404DCC((__int32)v11, &v10);
    sub_40312C((volatile __int32 *)&v11, v10);
    if ( sub_40320C((int)v11) >= 3 && !sub_404CF8((const CHAR *)v11) )
    {
      sub_404EEC(v11, &v9);
      Delphi_CompareCall_403358((int)v9, (int *)v11);
      if ( !v3 )
      {
        sub_404EEC(v11, &v8);
        if ( (unsigned __int8)sub_404DE0() && sub_404EB0((char *)v11) )
          LOBYTE(a2) = 1;
        else
          a2 = 0;
      }
    }
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_404EA6;
  sub_4030B8((int)&v8, 4);
  return a2;
}
// 404DE0: could not find valid save-restore pair for ebx
// 404E59: variable 'v3' is possibly undefined

//----- (00404EB0) --------------------------------------------------------
BOOL __usercall sub_404EB0@<eax>(char *a1@<eax>)
{
  char *v1; // eax

  v1 = sub_40340C(a1);
  return CreateDirectoryA(v1, 0);
}

//----- (00404ED0) --------------------------------------------------------
_DWORD *__usercall sub_404ED0@<eax>(void *a1@<eax>, char **a2@<edx>)
{
  const char *v2; // eax
  char *v3; // edx

  v2 = sub_404950(a1);
  v3 = (char *)a1;
  if ( *v2 )
    v3 = (char *)(v2 + 1);
  return sub_4031C4(a2, v3);
}

//----- (00404EEC) --------------------------------------------------------
_DWORD *__usercall sub_404EEC@<eax>(void *a1@<eax>, char **a2@<edx>)
{
  char *v2; // edx
  int v3; // ecx
  int v4; // eax
  void *v6; // [esp-8h] [ebp-8h]

  v6 = sub_404490(a1);
  v2 = (char *)sub_404950(v6);
  v3 = 0;
  if ( *v2 )
  {
    v4 = v2 - (_BYTE *)v6 + 1;
    v2 = (char *)v6;
    v3 = v4;
  }
  return sub_403184(a2, v2, v3);
}

//----- (00404F18) --------------------------------------------------------
_DWORD *__usercall sub_404F18@<eax>(void *a1@<eax>, char **a2@<edx>)
{
  void *v2; // eax
  char *v3; // eax

  v2 = sub_404490(a1);
  v3 = (char *)sub_404950(v2);
  return sub_4031C4(a2, v3);
}

//----- (00404F34) --------------------------------------------------------
_DWORD *__usercall sub_404F34@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  char *v3; // eax
  int ShortPathNameA; // eax
  CHAR szShortPath[268]; // [esp+0h] [ebp-10Ch] BYREF

  v3 = sub_40340C(a1);
  ShortPathNameA = GetShortPathNameA(v3, szShortPath, 0x104u);
  return sub_403184(a2, szShortPath, ShortPathNameA);
}

//----- (00404F6C) --------------------------------------------------------
char *__usercall sub_404F6C@<eax>(const CHAR *a1@<eax>)
{
  char *result; // eax
  struct _WIN32_FIND_DATAA v2; // [esp+0h] [ebp-140h] BYREF

  result = (char *)FindFirstFileA(a1, &v2) + 1;
  if ( result )
  {
    FindClose(result - 1);
    return (char *)v2.nFileSizeLow;
  }
  return result;
}

//----- (00404F90) --------------------------------------------------------
_DWORD *__usercall sub_404F90@<eax>(volatile __int32 *a1@<eax>)
{
  unsigned int v3[2]; // [esp-Ch] [ebp-11Ch] BYREF
  int *v4; // [esp-4h] [ebp-114h]
  char *v5; // [esp+4h] [ebp-10Ch] BYREF
  CHAR Buffer[261]; // [esp+Bh] [ebp-105h] BYREF
  int savedregs; // [esp+110h] [ebp+0h] BYREF

  v5 = 0;
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_404FFA;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  GetWindowsDirectoryA(Buffer, 0x105u);
  sub_4031C4(&v5, Buffer);
  sub_404DB8((__int32)v5, a1);
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_405001;
  return sub_403094(&v5);
}
// 404F90: using guessed type char *var_10C;

//----- (00405008) --------------------------------------------------------
_DWORD *__usercall sub_405008@<eax>(volatile __int32 *a1@<eax>)
{
  unsigned int v3[2]; // [esp-Ch] [ebp-11Ch] BYREF
  int *v4; // [esp-4h] [ebp-114h]
  char *v5; // [esp+4h] [ebp-10Ch] BYREF
  CHAR Buffer[261]; // [esp+Bh] [ebp-105h] BYREF
  int savedregs; // [esp+110h] [ebp+0h] BYREF

  v5 = 0;
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_405072;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  GetTempPathA(0x105u, Buffer);
  sub_4031C4(&v5, Buffer);
  sub_404DB8((__int32)v5, a1);
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_405079;
  return sub_403094(&v5);
}
// 405008: using guessed type char *var_10C;

//----- (00405080) --------------------------------------------------------
int __usercall sub_405080@<eax>(char *a1@<eax>, char *a2@<edx>, char **a3@<ecx>)
{
  int v4; // eax
  char *v5; // eax
  HANDLE FirstFileA; // esi
  bool i; // al
  unsigned int v9[2]; // [esp-Ch] [ebp-168h] BYREF
  int *v10; // [esp-4h] [ebp-160h]
  char *v11; // [esp+8h] [ebp-154h] BYREF
  __int32 v12; // [esp+Ch] [ebp-150h] BYREF
  struct _WIN32_FIND_DATAA FindFileData; // [esp+10h] [ebp-14Ch] BYREF
  char *v14; // [esp+150h] [ebp-Ch] BYREF
  char *v15; // [esp+154h] [ebp-8h] BYREF
  char *v16; // [esp+158h] [ebp-4h] BYREF
  int savedregs; // [esp+15Ch] [ebp+0h] BYREF

  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = a2;
  v16 = a1;
  sub_4033FC((int)a1);
  sub_4033FC((int)v15);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_4051DB;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  sub_403094(a3);
  if ( v16 )
  {
    v4 = sub_40320C((int)v16);
    if ( v16[v4 - 1] != 92 )
      sub_403214(&v16, (__int32)dword_4051F0);
  }
  if ( v15 && *v15 == 92 )
  {
    sub_404728((int)v15, 2, &v12);
    sub_40312C((volatile __int32 *)&v15, v12);
  }
  sub_403258((volatile __int32 *)&v14, v16, v15);
  v5 = sub_40340C(v14);
  FirstFileA = FindFirstFileA(v5, &FindFileData);
  for ( i = FirstFileA != 0; i; i = FindNextFileA(FirstFileA, &FindFileData) )
  {
    if ( (FindFileData.dwFileAttributes & 0x10) == 0 )
    {
      if ( *a3 )
        sub_403214(a3, (__int32)&dword_4051FC);
      sub_4031F4(&v11, FindFileData.cFileName, 260);
      sub_4032CC(a3, 3);
    }
  }
  FindClose(FirstFileA);
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_4051E2;
  sub_4030B8((int)&v11, 2);
  return sub_4030B8((int)&v14, 3);
}
// 4051F0: using guessed type int dword_4051F0[3];
// 4051FC: using guessed type int dword_4051FC;

//----- (00405200) --------------------------------------------------------
void *__usercall sub_405200@<eax>(void *a1@<eax>, int a2@<ebx>)
{
  void *v2; // ebx
  char *v3; // eax
  BOOL v4; // eax
  char *v6; // [esp-14h] [ebp-24h]
  unsigned int v7[2]; // [esp-10h] [ebp-20h] BYREF
  int *v8; // [esp-8h] [ebp-18h]
  int v9; // [esp-4h] [ebp-14h]
  char *v10; // [esp+0h] [ebp-10h] BYREF
  char *v11; // [esp+4h] [ebp-Ch] BYREF
  char *v12; // [esp+8h] [ebp-8h] BYREF
  void *v13; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = a2;
  v2 = a1;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_405291;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  sub_404ED0(a1, &v11);
  v6 = v11;
  sub_404EEC(v2, &v10);
  sub_405080(v10, v6, (char **)&v13);
  LOBYTE(v2) = 1;
  while ( v13 )
  {
    sub_404798(&v13, &v12);
    if ( (_BYTE)v2 && (v3 = sub_40340C(v12), v4 = DeleteFileA(v3)) )
      LOBYTE(v4) = 1;
    else
      v4 = 0;
    v2 = (void *)v4;
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_405298;
  sub_4030B8((int)&v10, 4);
  return v2;
}
// 405200: could not find valid save-restore pair for ebx

//----- (004052AC) --------------------------------------------------------
char *__usercall sub_4052AC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char *v6; // ebx

  v6 = sub_4044F8(0, (int)off_404488);
  sub_405634(v6, a1, a2, a2, a3);
  return v6;
}
// 404488: using guessed type int (*off_404488[2])();

//----- (004052D8) --------------------------------------------------------
_DWORD *__usercall sub_4052D8@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ecx

  v1 = (_DWORD *)_InterlockedExchange(result + 6, 0);
  if ( v1 )
    return sub_40458C(v1);
  return result;
}

//----- (004052E8) --------------------------------------------------------
int __usercall sub_4052E8@<eax>(_DWORD *a1@<eax>)
{
  sub_4052D8(a1);
  sub_403094(a1 + 7);
  return sub_40452C(a1);
}

//----- (00405300) --------------------------------------------------------
unsigned __int8 __usercall sub_405300@<al>(__int32 a1@<eax>, volatile __int32 *a2@<edx>)
{
  unsigned __int8 result; // al

  sub_4030E8(a2, a1);
  result = (unsigned __int8)a2;
  if ( !*a2 )
    return (unsigned __int8)sub_4031C4((char **)a2, (char *)&loc_405319);
  return result;
}

//----- (00405320) --------------------------------------------------------
int __usercall sub_405320@<eax>(int a1@<eax>, int a2@<edx>)
{
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 24) + 4 * a2);
}

//----- (0040532C) --------------------------------------------------------
int __usercall sub_40532C@<eax>(int a1@<eax>)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 24);
  if ( result )
    return *(_DWORD *)(result + 28);
  return result;
}

//----- (00405338) --------------------------------------------------------
_DWORD *__usercall sub_405338@<eax>(int a1@<eax>, int a2@<edx>, char **a3@<ecx>)
{
  return sub_4031C4(a3, (char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 24) + 4 * a2) + 44));
}

//----- (0040534C) --------------------------------------------------------
BOOL __usercall sub_40534C@<eax>(int a1@<eax>, int a2@<edx>)
{
  return (*(_DWORD *)sub_405320(a1, a2) & 0x10) != 0;
}

//----- (0040536C) --------------------------------------------------------
char __userpurge sub_40536C@<al>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4)
{
  char v4; // di
  bool v6; // al
  char v7; // zf
  int v8; // eax
  int v9; // edi
  char *v10; // ebx
  bool v11; // al
  char *v13; // [esp-10h] [ebp-14Ch]
  char *v14; // [esp-10h] [ebp-14Ch]
  unsigned int v15[2]; // [esp-Ch] [ebp-148h] BYREF
  int *v16; // [esp-4h] [ebp-140h]
  char *v17; // [esp+Ch] [ebp-130h] BYREF
  char *v18; // [esp+10h] [ebp-12Ch] BYREF
  char *v19; // [esp+14h] [ebp-128h] BYREF
  char *v20; // [esp+18h] [ebp-124h] BYREF
  char *v21; // [esp+1Ch] [ebp-120h] BYREF
  char *v22; // [esp+20h] [ebp-11Ch] BYREF
  char *v23; // [esp+24h] [ebp-118h] BYREF
  char *v24; // [esp+28h] [ebp-114h] BYREF
  char v25[259]; // [esp+2Ch] [ebp-110h] BYREF
  char v26; // [esp+12Fh] [ebp-Dh]
  int v27; // [esp+130h] [ebp-Ch]
  bool v28; // [esp+137h] [ebp-5h]
  int v29; // [esp+138h] [ebp-4h]
  int savedregs; // [esp+13Ch] [ebp+0h] BYREF

  v17 = 0;
  v19 = 0;
  v18 = 0;
  v21 = 0;
  v20 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v4 = a3;
  v29 = a1;
  v16 = &savedregs;
  v15[1] = (unsigned int)&loc_405611;
  v15[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v15);
  v6 = a4 == (a3 & a4) || (a4 & 0x80) != 0;
  v28 = v6;
  if ( v6 )
  {
    sub_402770(v25, a2);
    sub_4025F0((int)v25, (int)dword_405624, (unsigned __int8)v25[0] + 1);
    if ( v7
      || (sub_4031C4(&v24, a2), Delphi_CompareCall_403358((int)v24, &dword_405630), v7)
      || (a4 & 0x80) == 0
      || a4 == 128
      || (a4 & 0x10) == 0
      || (v4 & 0x10) == 0 )
    {
      v26 = 1;
      v8 = *(_DWORD *)(v29 + 32);
      if ( *(_DWORD *)(v8 + 28) - 1 >= 0 )
      {
        v9 = *(_DWORD *)(v8 + 28);
        v27 = 0;
        do
        {
          v10 = *(char **)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v29 + 32) + 24) + 24) + 4 * v27);
          if ( v10 )
          {
            sub_402770(v25, v10);
            sub_4025F0((int)v25, (int)dword_405624, (unsigned __int8)v25[0] + 1);
            if ( v7 || (sub_4031C4(&v23, v10), Delphi_CompareCall_403358((int)v23, &dword_405630), v7) )
            {
              if ( v10 == a2 )
                goto LABEL_33;
            }
            else
            {
              sub_402770(v25, a2);
              sub_4025F0((int)v25, (int)dword_405624, (unsigned __int8)v25[0] + 1);
              if ( v7 )
                goto LABEL_26;
              sub_4031C4(&v22, a2);
              Delphi_CompareCall_403358((int)v22, &dword_405630);
              if ( v7 )
                goto LABEL_26;
            }
            if ( *v10 == 94 )
            {
              sub_4031C4(&v21, v10 + 1);
              v13 = v21;
              sub_4031C4(&v20, a2);
              if ( (unsigned __int8)sub_404894(v20, v13) )
              {
                v28 = 0;
                goto LABEL_33;
              }
            }
            else
            {
              v26 = 0;
              sub_4031C4(&v19, v10);
              v14 = v19;
              sub_4031C4(&v18, a2);
              if ( (unsigned __int8)sub_404894(v18, v14) )
              {
                v28 = 1;
                goto LABEL_33;
              }
            }
          }
LABEL_26:
          ++v27;
          --v9;
        }
        while ( v9 );
      }
      v11 = 0;
      if ( v26 )
      {
        sub_402770(v25, a2);
        sub_4025F0((int)v25, (int)dword_405624, (unsigned __int8)v25[0] + 1);
        if ( !v7 )
        {
          sub_4031C4(&v17, a2);
          Delphi_CompareCall_403358((int)v17, &dword_405630);
          if ( !v7 )
            v11 = 1;
        }
      }
      v28 = v11;
    }
  }
LABEL_33:
  __writefsdword(0, v15[0]);
  v16 = (int *)&loc_405618;
  sub_4030B8((int)&v17, 8);
  return v28;
}
// 40540A: variable 'v7' is possibly undefined
// 405624: using guessed type int dword_405624[3];
// 405630: using guessed type int dword_405630;

//----- (00405634) --------------------------------------------------------
_DWORD *__userpurge sub_405634@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<edi>, int a5)
{
  int v6; // ebx
  int v7; // eax
  char v8; // al
  void *v9; // edx
  HANDLE FirstFileA; // edi
  unsigned int v11; // kr00_4
  char v12; // zf
  char *v14; // [esp-Ch] [ebp-158h]
  int v15; // [esp-8h] [ebp-154h]
  struct _WIN32_FIND_DATAA v16; // [esp-4h] [ebp-150h] BYREF
  int v17; // [esp+13Ch] [ebp-10h]
  _BYTE v18[8]; // [esp+144h] [ebp-8h] BYREF
  int savedregs; // [esp+14Ch] [ebp+0h] BYREF

  v17 = a4;
  *(_DWORD *)&v16.cAlternateFileName[4] = a1;
  *(_DWORD *)v16.cAlternateFileName = a3;
  *(_DWORD *)&v16.cFileName[256] = a2;
  *(_DWORD *)&v16.cFileName[252] = a1;
  sub_4052D8(a1);
  a1[6] = sub_40456C();
  *(_DWORD *)&v16.cAlternateFileName[12] = &savedregs;
  *(_DWORD *)&v16.cAlternateFileName[8] = v18;
  sub_4030E8((volatile __int32 *)(*(_DWORD *)&v16.cAlternateFileName[4] + 28), *(__int32 *)&v16.cFileName[256]);
  v6 = *(_DWORD *)&v16.cAlternateFileName[4];
  v7 = *(_DWORD *)(*(_DWORD *)&v16.cAlternateFileName[4] + 28);
  if ( v7 )
  {
    *(_DWORD *)&v16.cAlternateFileName[12] = &savedregs;
    *(_DWORD *)&v16.cAlternateFileName[8] = v18;
    *(_DWORD *)&v16.cFileName[252] = v7;
    sub_404DB8(
      *(_DWORD *)(*(_DWORD *)&v16.cAlternateFileName[4] + 28),
      (volatile __int32 *)(*(_DWORD *)&v16.cAlternateFileName[4] + 28));
    if ( !*(_DWORD *)(*(_DWORD *)&v16.cAlternateFileName[4] + 32) )
    {
      *(_DWORD *)(*(_DWORD *)&v16.cAlternateFileName[4] + 32) = sub_405C80();
      *(_DWORD *)&v16.cAlternateFileName[12] = &savedregs;
      *(_DWORD *)&v16.cAlternateFileName[8] = v18;
      *(_DWORD *)&v16.cFileName[248] = *(_DWORD *)v16.cAlternateFileName;
      v8 = sub_4048D8(*(_BYTE **)v16.cAlternateFileName, &byte_40569B);
      v9 = *(void **)v16.cAlternateFileName;
      if ( !v8 )
        v9 = &loc_4056A7;
      sub_405CAC(*(_DWORD *)(*(_DWORD *)&v16.cAlternateFileName[4] + 32), (int)v9);
    }
    v6 = *(_DWORD *)&v16.cAlternateFileName[4];
    v16.ftCreationTime.dwLowDateTime = 0;
    v16.dwFileAttributes = 0;
    sub_405300(*(__int32 *)v16.cAlternateFileName, (volatile __int32 *)&v16);
    sub_403258((volatile __int32 *)&v16.ftCreationTime, *(char **)(v6 + 28), (char *)v16.dwFileAttributes);
    sub_4044A8();
    FirstFileA = FindFirstFileA((LPCSTR)v16.dwFileAttributes, (LPWIN32_FIND_DATAA)&v16.ftCreationTime);
    v11 = __readeflags();
    sub_403094(&v16);
    __writeeflags(v11);
    if ( !v12 )
    {
      while ( 1 )
      {
        if ( sub_40536C(v6, &v16.cFileName[4], v16.ftCreationTime.dwLowDateTime, a5) )
        {
          if ( !*(_DWORD *)(v6 + 36) )
            goto LABEL_11;
          v16.dwFileAttributes = 1;
          (*(void (__cdecl **)(struct _WIN32_FIND_DATAA *))(v6 + 36))(&v16);
          if ( v15 )
            break;
        }
LABEL_12:
        if ( !FindNextFileA(FirstFileA, &v16) )
        {
          FindClose(FirstFileA);
          return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(v6 + 32), 0));
        }
      }
      if ( v15 != 1 )
        return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(v6 + 32), 0));
LABEL_11:
      v14 = (char *)sub_402448(320);
      sub_4045E8(*(_DWORD **)(v6 + 24), (int)v14);
      sub_40254C((char *)&v16, v14, 320);
      goto LABEL_12;
    }
  }
  return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(v6 + 32), 0));
}
// 4056E7: variable 'v12' is possibly undefined
// 405713: variable 'v15' is possibly undefined
// 40569B: using guessed type char byte_40569B;

//----- (0040575C) --------------------------------------------------------
HKEY __usercall sub_40575C@<eax>(HKEY a1@<eax>, char *a2@<edx>, HKEY a3@<ecx>)
{
  char *v4; // eax
  HKEY v6; // [esp+0h] [ebp-Ch] BYREF

  v6 = a3;
  v4 = sub_40340C(a2);
  if ( RegOpenKeyExA_0(a1, v4, 0, 0x2001Fu, &v6) )
    return 0;
  return v6;
}

//----- (0040578C) --------------------------------------------------------
BOOL __usercall sub_40578C@<eax>(HKEY a1@<eax>, char *a2@<edx>, char *a3@<ecx>)
{
  char *v6; // eax
  BOOL result; // eax
  char *v8; // [esp-8h] [ebp-14h]
  DWORD v9; // [esp-4h] [ebp-10h]

  result = 0;
  if ( a1 )
  {
    v9 = sub_40320C((int)a3) + 1;
    v8 = sub_40340C(a3);
    v6 = sub_40340C(a2);
    if ( !RegSetValueExA(a1, v6, 0, 1u, (const BYTE *)v8, v9) )
      return 1;
  }
  return result;
}

//----- (004057CC) --------------------------------------------------------
HKEY __usercall sub_4057CC@<eax>(HKEY result@<eax>)
{
  if ( result )
    return (HKEY)RegCloseKey_0(result);
  return result;
}

//----- (004057D8) --------------------------------------------------------
double sub_4057D8()
{
  double v1; // [esp+0h] [ebp-18h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+8h] [ebp-10h] BYREF

  GetLocalTime(&SystemTime);
  sub_405834(&SystemTime.wYear, &v1);
  return v1;
}

//----- (004057F8) --------------------------------------------------------
bool __usercall sub_4057F8@<al>(unsigned __int16 a1@<ax>)
{
  return (a1 & 3) == 0 && (a1 % 0x64u || !(a1 % 0x190u));
}

//----- (00405834) --------------------------------------------------------
char __usercall sub_405834@<al>(unsigned __int16 *a1@<eax>, double *a2@<edx>)
{
  char *v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  char v10; // [esp+4h] [ebp-18h]

  v10 = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  v3 = (char *)&unk_4090B4 + 24 * (sub_4057F8(*a1) & 0x7F);
  if ( *a1 <= 0x270Fu
    && a1[1] <= 0xCu
    && *(_WORD *)&v3[2 * a1[1] - 2] >= a1[3]
    && a1[4] < 0x18u
    && a1[5] < 0x3Cu
    && a1[6] < 0x3Cu
    && a1[7] < 0x3E8u )
  {
    v4 = a1[3];
    v5 = a1[1] - 1;
    if ( v5 > 0 )
    {
      v6 = 1;
      do
      {
        v4 += *(unsigned __int16 *)&v3[2 * v6++ - 2];
        --v5;
      }
      while ( v5 );
    }
    v7 = *a1 - 1;
    if ( v7 < 0 )
      v7 = 0;
    *a2 = (double)(v7 / 400 + (v7 >> 2) + 365 * v7 - v7 / 100 + v4)
        + (double)(a1[7] + 1000 * a1[6] + 60000 * a1[5] + 3600000 * a1[4]) / 86400000.0;
    return 1;
  }
  return v10;
}
// 4058F4: conditional instruction was optimized away because ecx.4>=0

//----- (00405968) --------------------------------------------------------
int __usercall sub_405968@<eax>(int a1@<eax>)
{
  return sub_405990(a1);
}

//----- (00405974) --------------------------------------------------------
int __usercall sub_405974@<eax>(int a1@<eax>)
{
  return sub_405990(a1);
}

//----- (0040597C) --------------------------------------------------------
int __usercall sub_40597C@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(a1 + 32))();
}

//----- (00405980) --------------------------------------------------------
int __usercall sub_405980@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(a1 + 36))();
}

//----- (00405984) --------------------------------------------------------
int __usercall sub_405984@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 64);
}

//----- (00405988) --------------------------------------------------------
int __usercall sub_405988@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(a1 + 40))();
}

//----- (0040598C) --------------------------------------------------------
int __usercall sub_40598C@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(a1 + 44))();
}

//----- (00405990) --------------------------------------------------------
int __usercall sub_405990@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(a1 + 28))();
}

//----- (00405994) --------------------------------------------------------
int __usercall sub_405994@<eax>(int a1@<eax>)
{
  _DWORD *v2; // [esp-8h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 80);
  (*(void (**)(void))(a1 + 48))();
  sub_404520(v2);
  return sub_40452C((_DWORD *)a1);
}

//----- (004059A8) --------------------------------------------------------
char *__usercall sub_4059A8@<eax>(char *a1@<eax>)
{
  char *v2; // ebx

  v2 = sub_4044F8(0, (int)off_404438);
  sub_40254C(a1, v2 + 28, 32);
  *((_DWORD *)v2 + 6) = v2 + 28;
  return v2;
}
// 404438: using guessed type int (*off_404438[3])();

//----- (004059E4) --------------------------------------------------------
DWORD __usercall sub_4059E4@<eax>(int a1@<eax>)
{
  DWORD result; // eax

  result = GetFileSize(*(HANDLE *)(a1 + 64), 0);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (004059FC) --------------------------------------------------------
int sub_4059FC()
{
  return 0;
}

//----- (00405A18) --------------------------------------------------------
bool __usercall sub_405A18@<al>(int a1@<eax>)
{
  return sub_404B90(*(void **)(a1 + 64));
}

//----- (00405AEC) --------------------------------------------------------
int __usercall sub_405AEC@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v4; // esi
  void *v5; // eax
  int result; // eax

  v4 = sub_405968(a1);
  sub_405974(a1);
  v5 = (void *)sub_405984(a1);
  result = SetEndOfFile(v5);
  if ( a2 > v4 )
    return sub_405974(a1);
  return result;
}

//----- (00405B24) --------------------------------------------------------
char *__usercall sub_405B24@<eax>(const CHAR *a1@<eax>, DWORD a2@<edx>)
{
  char *v4; // ebx

  v4 = sub_4059A8((char *)&off_4090F4);
  *((_DWORD *)v4 + 10) = sub_405A00;
  *((_DWORD *)v4 + 11) = sub_405A0C;
  *((_DWORD *)v4 + 9) = sub_405AEC;
  *((_DWORD *)v4 + 16) = sub_404B68(a1, a2);
  return v4;
}
// 405A00: using guessed type int sub_405A00();
// 405A0C: using guessed type int sub_405A0C();
// 4090F4: using guessed type void *off_4090F4;

//----- (00405B60) --------------------------------------------------------
char *__usercall sub_405B60@<eax>(const CHAR *a1@<eax>)
{
  char *v2; // eax
  char *v3; // et1

  v2 = sub_4059A8((char *)&off_4090F4);
  *((_DWORD *)v2 + 10) = sub_405A00;
  v3 = v2;
  *((_DWORD *)v2 + 16) = sub_404B68(a1, 0x80000301);
  return v3;
}
// 405A00: using guessed type int sub_405A00();
// 4090F4: using guessed type void *off_4090F4;

//----- (00405B84) --------------------------------------------------------
char *__usercall sub_405B84@<eax>(void *a1@<eax>)
{
  char *v2; // ebx
  int v3; // esi

  v2 = sub_4059A8((char *)&off_4090F4);
  *((_DWORD *)v2 + 10) = sub_405A00;
  *((_DWORD *)v2 + 11) = sub_405A0C;
  *((_DWORD *)v2 + 9) = sub_405AEC;
  v3 = 512;
  if ( sub_404B9C(a1) )
    v3 = 768;
  *((_DWORD *)v2 + 16) = sub_404B68((const CHAR *)a1, v3 | 0xC0000001);
  return v2;
}
// 405A00: using guessed type int sub_405A00();
// 405A0C: using guessed type int sub_405A0C();
// 4090F4: using guessed type void *off_4090F4;

//----- (00405BDC) --------------------------------------------------------
char *sub_405BDC()
{
  return sub_4059A8((char *)&off_409114);
}
// 409114: using guessed type int (*off_409114)[50];

//----- (00405BE8) --------------------------------------------------------
int __usercall sub_405BE8@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // esi
  int v6; // ebp

  if ( *(_DWORD *)(a2 + 60) )
  {
    v5 = sub_40598C((int)a1);
    *(_DWORD *)(a2 + 76) += v5;
  }
  else if ( a1[15] )
  {
    if ( (unsigned int)(a3 + a1[19]) > a1[18] )
      sub_405980((int)a1);
    v5 = sub_405988(a2);
    a1[19] += v5;
  }
  else
  {
    v6 = sub_402448(a3);
    sub_405988(a2);
    v5 = sub_40598C((int)a1);
    sub_402468(v6);
  }
  return v5;
}

//----- (00405C80) --------------------------------------------------------
char *sub_405C80()
{
  return sub_4044F8(0, (int)off_40444C);
}
// 40444C: using guessed type int (*off_40444C[3])();

//----- (00405C90) --------------------------------------------------------
int __usercall sub_405C90@<eax>(_DWORD *a1@<eax>)
{
  sub_405CBC((int)a1);
  return sub_40452C(a1);
}

//----- (00405CA0) --------------------------------------------------------
int __usercall sub_405CA0@<eax>(int result@<eax>)
{
  *(_BYTE *)(result + 41) = byte_4090AC;
  return result;
}
// 4090AC: using guessed type char byte_4090AC;

//----- (00405CAC) --------------------------------------------------------
int __usercall sub_405CAC@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v3; // [esp-4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 28);
  sub_405DC4(a1, v3, a2);
  return v3;
}

//----- (00405CBC) --------------------------------------------------------
_DWORD *__usercall sub_405CBC@<eax>(int a1@<eax>)
{
  int i; // edx
  bool v3; // cc
  int v4; // edx
  __int32 v5; // eax
  int v7; // [esp-4h] [ebp-8h]

  for ( i = *(_DWORD *)(a1 + 28); ; i = v7 )
  {
    v3 = i < 1;
    v4 = i - 1;
    if ( v3 )
      break;
    v7 = v4;
    sub_405CEC((_DWORD *)a1, v4);
  }
  *(_DWORD *)(a1 + 37) = 0;
  v5 = _InterlockedExchange((volatile __int32 *)(a1 + 33), 0);
  if ( v5 )
    v5 = sub_402468(v5);
  return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(a1 + 24), v5));
}

//----- (00405CEC) --------------------------------------------------------
int __usercall sub_405CEC@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v2; // eax
  int result; // eax
  int v4; // ecx
  unsigned int v5; // [esp-8h] [ebp-8h]

  --a1[7];
  v2 = a1[6];
  v5 = *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4 * a2);
  sub_404618(v2, a2);
  result = v5;
  v4 = *(_DWORD *)((char *)a1 + 37);
  if ( !v4 || v5 < *(_DWORD *)((char *)a1 + 33) || v5 >= *(_DWORD *)((char *)a1 + 33) + v4 )
    return sub_402468(v5);
  return result;
}

//----- (00405D18) --------------------------------------------------------
_DWORD *__usercall sub_405D18@<eax>(int a1@<eax>, int a2@<edx>, char **a3@<ecx>)
{
  char *v3; // eax

  v3 = *(char **)(a1 + 24);
  if ( v3 )
    v3 = (char *)sub_40465C((int)v3, a2);
  return sub_4031C4(a3, v3);
}

//----- (00405D30) --------------------------------------------------------
_DWORD *__usercall sub_405D30@<eax>(int a1@<eax>, char **a2@<edx>, char **a3@<esi>)
{
  int v3; // ecx
  int v4; // eax
  int v6; // edx
  _BYTE *v7; // eax
  _DWORD *result; // eax
  int v9; // ecx
  char *v10; // edi
  int v11; // ecx
  char *v12; // edi
  int v13; // [esp-10h] [ebp-18h]
  char **v14; // [esp-Ch] [ebp-14h]
  char **v15; // [esp-8h] [ebp-10h]
  char *v16; // [esp-8h] [ebp-10h]
  int v17; // [esp-4h] [ebp-Ch]
  int v18; // [esp-4h] [ebp-Ch]

  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_DWORD *)(a1 + 24);
  v17 = v3;
  if ( v3 )
    a3 = *(char ***)(v4 + 24);
  v15 = a3;
  v6 = 0;
  if ( v3 )
  {
    v14 = a2;
    do
    {
      v13 = v3;
      v7 = *a3++;
      v6 += sub_40493C(v7) + 2;
      v3 = v13 - 1;
    }
    while ( v13 != 1 );
    a2 = v14;
    a3 = v15;
    v3 = v6;
    v15 = v14;
  }
  result = sub_403184(a2, 0, v3);
  v9 = v17;
  if ( v17 )
  {
    v10 = *v15;
    do
    {
      v18 = v9;
      v16 = *a3;
      v11 = sub_40493C(*a3);
      qmemcpy(v10, v16, v11);
      v12 = &v10[v11];
      ++a3;
      *(_WORD *)v12 = 2573;
      v10 = v12 + 2;
      v9 = v18 - 1;
    }
    while ( v18 != 1 );
    result = 0;
    *v10 = v9;
  }
  return result;
}

//----- (00405D84) --------------------------------------------------------
int __usercall sub_405D84@<eax>(int a1@<eax>, char *a2@<edx>)
{
  int v4; // ebx
  int i; // esi
  char *v6; // eax
  const char *v8; // [esp-4h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 28) - 1 < 0 )
    return -1;
  v4 = *(_DWORD *)(a1 + 28);
  for ( i = 0; ; ++i )
  {
    v8 = (const char *)sub_40465C(*(_DWORD *)(a1 + 24), i);
    v6 = sub_40340C(a2);
    if ( !sub_4048F8(v6, v8) )
      break;
    if ( !--v4 )
      return -1;
  }
  return i;
}

//----- (00405DC4) --------------------------------------------------------
char *__usercall sub_405DC4@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char *v4; // eax
  char *v5; // edx
  char *v6; // eax
  char *result; // eax
  int v8; // [esp-Ch] [ebp-10h]
  int v10; // [esp-8h] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 24) )
    *(_DWORD *)(a1 + 24) = sub_40456C();
  v8 = sub_40320C(a3) + 1;
  v4 = (char *)sub_402448(v8);
  *v4 = 0;
  v5 = v4;
  v6 = (char *)a3;
  v10 = (int)v5;
  if ( v6 )
    sub_40254C(v6, v5, v8);
  result = sub_404670(*(_DWORD **)(a1 + 24), a2, v10);
  ++*(_DWORD *)(a1 + 28);
  return result;
}

//----- (00405E04) --------------------------------------------------------
char *__usercall sub_405E04@<eax>(char *a1@<eax>, const CHAR *a2@<edx>)
{
  char *result; // eax
  char *v3; // ebx
  int FileSize; // eax
  int v5; // eax
  DWORD v6; // [esp-10h] [ebp-10h]
  char *v7; // [esp-Ch] [ebp-Ch] BYREF
  char *v8; // [esp-4h] [ebp-4h]

  v8 = a1;
  result = (char *)sub_404B68(a2, 0x80000301) + 1;
  if ( result )
  {
    v3 = result - 1;
    FileSize = GetFileSize(result - 1, 0);
    v7 = 0;
    v6 = FileSize;
    sub_403184(&v7, 0, FileSize);
    sub_404BC4(v6, v7, v3);
    sub_404B90(v3);
    v5 = (int)v8;
    v8 = v7;
    sub_405E94(v5, 0);
    result = (char *)sub_4044A8();
    LOBYTE(result) = 1;
  }
  return result;
}

//----- (00405E50) --------------------------------------------------------
char *__usercall sub_405E50@<eax>(char *a1@<eax>, const CHAR *a2@<edx>, char **a3@<esi>)
{
  char *result; // eax
  char *v4; // ebx
  char *v5; // eax
  int v6; // eax
  char *v7; // [esp-4h] [ebp-8h] BYREF

  v7 = a1;
  result = (char *)sub_404B68(a2, 0x40000400u) + 1;
  if ( result )
  {
    v4 = result - 1;
    v5 = v7;
    v7 = 0;
    sub_405D30((int)v5, &v7, a3);
    v6 = sub_40320C((int)v7);
    sub_404BE0(v6, v7, v4);
    SetEndOfFile(v4);
    sub_404B90(v4);
    return (char *)(sub_4044A8() + 1);
  }
  return result;
}

//----- (00405E94) --------------------------------------------------------
void __usercall sub_405E94(int a1@<eax>, char a2@<cl>)
{
  int v2; // eax
  char *v3; // edx
  _DWORD *v4; // ebx
  int v5; // edi
  char *v6; // eax
  int *v7; // esi
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  char *v11; // edx
  _BYTE *v12; // edi
  int v13; // ecx
  int v14; // edx
  bool v15; // zf
  _DWORD *v16; // eax
  _DWORD *v17; // edx
  int v18; // ecx
  _BYTE *v19; // edi
  bool v20; // zf
  _DWORD *v21; // [esp-18h] [ebp-18h]
  char *v22; // [esp-14h] [ebp-14h]
  __int32 v23; // [esp-14h] [ebp-14h]
  char *v24; // [esp-10h] [ebp-10h]
  int v25; // [esp-10h] [ebp-10h]
  int v26; // [esp-Ch] [ebp-Ch]
  _BYTE *v27; // [esp-Ch] [ebp-Ch]

  if ( a2 != 1 )
    sub_405CBC(a1);
  sub_40449C();
  if ( !v15 )
  {
    v4 = (_DWORD *)v2;
    v5 = *(_DWORD *)(v2 + 37);
    v26 = *((_DWORD *)v3 - 1) + 1;
    v24 = v3;
    v22 = *(char **)(v2 + 33);
    v6 = (char *)sub_402448(v5 + v26);
    *(_DWORD *)((char *)v4 + 33) = v6;
    if ( v5 )
    {
      sub_40254C(v22, v6, v5);
      v7 = *(int **)(v4[6] + 24);
      v8 = v4[7];
      do
      {
        v9 = *v7++;
        v10 = v9 - (_DWORD)v22;
        if ( v10 < *(_DWORD *)((char *)v4 + 37) )
          *(v7 - 1) = *(_DWORD *)((char *)v4 + 33) + v10;
        --v8;
      }
      while ( v8 );
      sub_402468((int)v22);
    }
    v11 = (char *)(*(_DWORD *)((char *)v4 + 33) + v5);
    *(_DWORD *)((char *)v4 + 37) += v26;
    sub_40254C(v24, v11, v26);
    v12 = (_BYTE *)(*(_DWORD *)((char *)v4 + 33) + v5);
    if ( !v4[6] )
      v4[6] = sub_40456C();
    v13 = v26;
    v14 = v4[7];
    v27 = v12;
    v25 = v13;
    while ( *v12 )
    {
      v15 = ++v14 == 0;
      do
      {
        if ( !v13 )
          break;
        v15 = *v12++ == 13;
        --v13;
      }
      while ( !v15 );
      if ( !v15 )
        break;
      if ( *v12 == 10 )
      {
        ++v12;
        if ( !--v13 )
          break;
      }
    }
    v4[7] = v14;
    v16 = (_DWORD *)v4[6];
    v23 = v14;
    v21 = v16;
    if ( v14 > v16[8] )
      sub_4045B4(v16, v14);
    v17 = (_DWORD *)(v21[6] + 4 * _InterlockedExchange(v21 + 7, v23));
    v18 = v25;
    v19 = v27;
    while ( *v19 )
    {
      *v17 = v19;
      v20 = ++v17 == 0;
      do
      {
        if ( !v18 )
          break;
        v20 = *v19++ == 13;
        --v18;
      }
      while ( !v20 );
      if ( !v20 )
        break;
      *(v19 - 1) = 0;
      if ( *v19 == 10 )
      {
        ++v19;
        if ( !--v18 )
          break;
      }
    }
  }
}
// 405E94: could not find valid save-restore pair for edi
// 405EA4: variable 'v15' is possibly undefined
// 405EAC: variable 'v2' is possibly undefined
// 405EB1: variable 'v3' is possibly undefined

//----- (00405F70) --------------------------------------------------------
int __usercall sub_405F70@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>)
{
  int result; // eax

  result = sub_4047F0(1064);
  *(_DWORD *)result = 40;
  *(_DWORD *)(result + 4) = a1;
  *(_DWORD *)(result + 8) = a2;
  *(_WORD *)(result + 12) = 1;
  *(_WORD *)(result + 14) = a3;
  return result;
}

//----- (00405F98) --------------------------------------------------------
int __usercall sub_405F98@<eax>(char a1@<al>)
{
  char *v1; // esi
  int v2; // ecx
  char v4; // al

  v1 = (char *)&unk_409135;
  v2 = 0;
  do
  {
    ++v2;
    v4 = *v1++;
  }
  while ( v4 != a1 && v4 );
  return v2;
}

//----- (00405FB4) --------------------------------------------------------
char *__usercall sub_405FB4@<eax>(int a1@<eax>, int a2@<edx>)
{
  char *result; // eax

  result = sub_4044F8(0, (int)off_404460);
  *((_DWORD *)result + 13) = nullsub_1;
  *((_DWORD *)result + 7) = a1;
  *((_DWORD *)result + 6) = a2;
  return result;
}
// 404460: using guessed type int (*off_404460[3])();
// 405FB0: using guessed type int nullsub_1();

//----- (00405FD8) --------------------------------------------------------
char *__usercall sub_405FD8@<eax>(int a1@<eax>, int a2@<edx>)
{
  char *v2; // eax
  int v3; // ecx
  HDC DC; // ebx
  int v6; // [esp-14h] [ebp-14h]
  char *v7; // [esp-Ch] [ebp-Ch]
  char *v10; // [esp-4h] [ebp-4h]

  v2 = sub_405FB4(a1, a2);
  v3 = a1;
  v10 = v2;
  ++v2[60];
  if ( v3 && a2 )
  {
    v7 = v2;
    v6 = v3;
    DC = GetDC(0);
    *((_DWORD *)v7 + 8) = CreateCompatibleBitmap(DC, v6, a2);
    ReleaseDC(0, DC);
  }
  return v10;
}

//----- (0040600C) --------------------------------------------------------
int __usercall sub_40600C@<eax>(int a1@<eax>)
{
  *(_BYTE *)(a1 + 16) = 3;
  return sub_40254C(byte_409140, (char *)(a1 + 40), 76);
}

//----- (00406024) --------------------------------------------------------
_DWORD *__usercall sub_406024@<eax>(int a1@<eax>)
{
  void *v2; // ecx
  int v3; // ecx
  int v4; // ecx

  (*(void (**)(void))(a1 + 52))();
  v2 = (void *)_InterlockedExchange((volatile __int32 *)(a1 + 32), 0);
  if ( v2 )
  {
    DeleteObject(v2);
    v2 = 0;
    *(_DWORD *)(a1 + 65) = 0;
  }
  v3 = _InterlockedExchange((volatile __int32 *)(a1 + 65), (__int32)v2);
  if ( v3 )
    sub_402468(v3);
  v4 = _InterlockedExchange((volatile __int32 *)(a1 + 61), 0);
  if ( v4 )
    sub_402468(v4);
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 86) = 0;
  *(_DWORD *)(a1 + 90) = 0;
  return sub_4064BC(a1);
}

//----- (00406068) --------------------------------------------------------
int __usercall sub_406068@<eax>(int a1@<eax>)
{
  int result; // eax

  sub_40646C(a1);
  sub_406024(a1);
  result = a1;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 114) = 0;
  return result;
}

//----- (00406084) --------------------------------------------------------
int __usercall sub_406084@<eax>(_DWORD *a1@<eax>)
{
  sub_406068((int)a1);
  return sub_40452C(a1);
}

//----- (00406094) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __userpurge sub_406094@<al>(
        BITMAPINFO *lpbmi@<ecx>,
        UINT iUsage@<edx>,
        int a3@<eax>,
        HDC a4@<ebx>,
        int a5@<esi>,
        int a6)
{
  int v6; // ebx
  bool v7; // zf
  int ObjectA; // eax
  HDC v9; // esi
  HDC v10; // eax
  int v11; // ecx
  __int32 v12; // esi
  int v14[2]; // [esp-10h] [ebp-30h] BYREF
  HDC v15; // [esp-8h] [ebp-28h]
  int v16; // [esp-4h] [ebp-24h]
  int v17; // [esp+0h] [ebp-20h]
  int v18; // [esp+4h] [ebp-1Ch]
  int v19; // [esp+8h] [ebp-18h]
  HDC v20; // [esp+Ch] [ebp-14h]
  const BITMAPINFO *v21; // [esp+10h] [ebp-10h]
  UINT v22; // [esp+14h] [ebp-Ch]
  DWORD v23; // [esp+18h] [ebp-8h]

  v22 = iUsage;
  v21 = lpbmi;
  v20 = a4;
  v19 = a5;
  while ( 1 )
  {
    v6 = a3;
    LOBYTE(a3) = sub_406144(a3);
    if ( v7 )
      break;
    if ( *(_DWORD *)(v6 + 32) )
    {
      ObjectA = GetObjectA(*(HANDLE *)(v6 + 32), 24, v14);
      v9 = v15;
      if ( !ObjectA )
        v9 = *(HDC *)(v6 + 24);
      sub_4044B8(v6);
      v18 = 13369376;
      v17 = 0;
      v16 = 0;
      v15 = v10;
      sub_4060E9((__int32)v9);
      BitBlt(v15, v16, v17, v18, v19, v20, (int)v21, v22, v23);
      LOBYTE(a3) = sub_4044E0();
      return a3;
    }
    v11 = *(_DWORD *)(v6 + 61);
    if ( v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( v12 < 0 )
        v12 = -v12;
      v18 = 13369376;
      v17 = 0;
      v16 = v11;
      v15 = *(HDC *)(v6 + 65);
      v14[1] = v12;
      v14[0] = *(_DWORD *)(v6 + 28);
      sub_4060E9(v12);
      a3 = StretchDIBits(0, 0, v14[0], v12, (int)v15, v16, 0, 13369376, v19, v20, v21, v22, v23);
      if ( !a3 )
      {
        v7 = sub_406154(v6) == 0;
        a3 = v6;
        if ( !v7 )
          continue;
      }
    }
    return a3;
  }
  return a3;
}
// 40613B: positive sp value 8 has been found
// 406094: could not find valid save-restore pair for ebx
// 406094: could not find valid save-restore pair for esi
// 4060A2: variable 'v7' is possibly undefined
// 4060D7: variable 'v10' is possibly undefined

//----- (004060E9) --------------------------------------------------------
void __usercall sub_4060E9(__int32 a1@<esi>)
{
  __int32 v1; // kr00_4
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v1 = _InterlockedExchange((volatile __int32 *)&retaddr, a1);
  __asm { jmp     esi }
}
// 4060F8: unbalanced stack, ignored a potential tail call

//----- (00406144) --------------------------------------------------------
bool __usercall sub_406144@<al>(int a1@<eax>)
{
  int v1; // ecx

  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
    v1 = *(_DWORD *)(a1 + 24);
  return v1 == 0;
}

//----- (00406154) --------------------------------------------------------
int __usercall sub_406154@<eax>(int a1@<eax>)
{
  int v2; // esi
  char *v3; // edi
  HDC DC; // esi

  v2 = 0;
  if ( !sub_406144(a1) )
  {
    if ( !*(_DWORD *)(a1 + 32) && *(_DWORD *)(a1 + 65) )
    {
      v3 = *(char **)(a1 + 65);
      DC = GetDC(0);
      *(_DWORD *)(a1 + 65) = 0;
      *(_DWORD *)(a1 + 32) = CreateDIBSection(DC, *(const BITMAPINFO **)(a1 + 61), 0, (void **)(a1 + 65), 0, 0);
      ReleaseDC(0, DC);
      if ( *(_DWORD *)(a1 + 32) )
      {
        sub_40254C(v3, *(char **)(a1 + 65), *(_DWORD *)(a1 + 69));
        if ( !*(_BYTE *)(a1 + 114) )
          sub_402468((int)v3);
        *(_BYTE *)(a1 + 114) = 1;
        *(_DWORD *)(a1 + 86) = 0;
        *(_DWORD *)(a1 + 90) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 65) = v3;
      }
    }
    return *(_DWORD *)(a1 + 32);
  }
  return v2;
}

//----- (004061E0) --------------------------------------------------------
__int32 __usercall sub_4061E0@<eax>(int a1@<eax>, void *a2@<edx>)
{
  int ObjectA; // eax
  int v3; // edx
  int v4; // ecx
  __int32 v5; // eax
  _DWORD v7[6]; // [esp-1Ch] [ebp-20h] BYREF
  HANDLE v8; // [esp-4h] [ebp-8h]
  __int32 v9; // [esp+0h] [ebp-4h] BYREF

  v9 = a1;
  v8 = a2;
  sub_406068(a1);
  if ( v8 )
  {
    ObjectA = GetObjectA(v8, 24, v7);
    v3 = v7[1];
    v4 = v7[2];
    if ( ObjectA )
    {
      v5 = _InterlockedExchange(&v9, (__int32)v8);
      *(_DWORD *)(v5 + 28) = v3;
      *(_DWORD *)(v5 + 24) = v4;
      *(_DWORD *)(v5 + 32) = v9;
      *(_BYTE *)(v5 + 60) = 1;
      return v5;
    }
  }
  return v9;
}

//----- (00406218) --------------------------------------------------------
char __usercall sub_406218@<al>(int a1@<eax>)
{
  bool v2; // zf
  int v3; // eax
  int v4; // edx
  char v5; // dl
  int v7; // [esp-4h] [ebp-8h]
  char v8; // [esp-4h] [ebp-8h]

  LOBYTE(v3) = sub_406144(a1);
  if ( !v2 )
  {
    v7 = v4;
    LOBYTE(v3) = sub_40648C(a1);
    v5 = v7;
    v2 = v3 == v7;
    if ( v3 != v7 )
    {
      if ( !v7 )
      {
        LOBYTE(v3) = sub_40647C(a1, 1);
        return v3;
      }
      *(_BYTE *)(a1 + 73) = v7;
      if ( (_BYTE)v7 == 5 )
        v5 = 4;
      v8 = v5;
      sub_40647C(a1, 0);
      v2 = (unsigned __int8)sub_405F98(*(_WORD *)(*(_DWORD *)(a1 + 61) + 14)) == (unsigned __int8)v8;
      v3 = a1;
    }
  }
  if ( !v2 )
    sub_40627C(v3);
  return v3;
}
// 406220: variable 'v2' is possibly undefined
// 406224: variable 'v4' is possibly undefined
// 40622B: variable 'v3' is possibly undefined

//----- (00406268) --------------------------------------------------------
unsigned int __usercall sub_406268@<eax>(int a1@<eax>)
{
  return (((unsigned int)*(unsigned __int16 *)(a1 + 14) * *(_DWORD *)(a1 + 4) + 31) >> 3) & 0xFFFFFFFC;
}

//----- (0040627C) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_40627C(int a1@<eax>)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  char v4; // zf
  HDC v5; // ebx
  int top; // esi
  LONG right; // edi
  int v8; // eax
  void *v9; // ecx
  HBITMAP CompatibleBitmap; // ebp
  signed int v11; // eax
  int v12; // eax
  int v13; // ecx
  HBITMAP DIBSection; // ebp
  struct tagBITMAPINFO *v15; // eax
  LONG v16; // eax
  HBITMAP v17; // eax
  int DIBits; // eax
  LONG v19; // edx
  UINT v20; // [esp-Ch] [ebp-40h]
  HBRUSH SolidBrush; // [esp-8h] [ebp-3Ch]
  void *v22; // [esp-8h] [ebp-3Ch]
  RECT v23; // [esp-4h] [ebp-38h] BYREF
  LPBITMAPINFO lpbmi; // [esp+Ch] [ebp-28h]
  HDC hDC; // [esp+10h] [ebp-24h]
  int v26; // [esp+14h] [ebp-20h]
  int v27; // [esp+18h] [ebp-1Ch]
  int v28; // [esp+1Ch] [ebp-18h]
  void **v29; // [esp+24h] [ebp-10h]
  void *retaddr; // [esp+34h] [ebp+0h] BYREF

  sub_406144(a1);
  if ( !v4 )
  {
    v29 = &retaddr;
    v28 = v3;
    v27 = v2;
    v26 = v1;
    v5 = (HDC)v1;
    (*(void (**)(void))(v1 + 52))();
    *((_DWORD *)v5 + 10) = 0;
    *(_DWORD *)((char *)v5 + 86) = 0;
    *(_DWORD *)((char *)v5 + 90) = 0;
    top = *((_DWORD *)v5 + 7);
    right = *((_DWORD *)v5 + 6);
    if ( *(_DWORD *)((char *)v5 + 65) )
    {
      v8 = *(_DWORD *)((char *)v5 + 61);
      top = *(_DWORD *)(v8 + 4);
      right = *(_DWORD *)(v8 + 8);
      if ( right < 0 )
        right = -right;
    }
    else
    {
      v9 = (void *)*((_DWORD *)v5 + 8);
      if ( v9 && GetObjectA(v9, 24, &v23) )
      {
        top = v23.top;
        right = v23.right;
      }
    }
    hDC = CreateCompatibleDC(0);
    if ( *((_BYTE *)v5 + 60) == 1 )
    {
      lpbmi = (LPBITMAPINFO)GetDC(0);
      CompatibleBitmap = CreateCompatibleBitmap((HDC)lpbmi, *((_DWORD *)v5 + 7), *((_DWORD *)v5 + 6));
      ReleaseDC(0, (HDC)lpbmi);
      lpbmi = (LPBITMAPINFO)SelectObject(hDC, CompatibleBitmap);
      v23.bottom = (int)v5[6];
      v23.right = (int)v5[7];
      v23.top = 0;
      v23.left = 0;
      v11 = sub_40469C(*((_DWORD *)v5 + 11));
      SolidBrush = CreateSolidBrush(v11);
      FillRect(hDC, &v23, SolidBrush);
      DeleteObject(SolidBrush);
      if ( *(_DWORD *)((char *)v5 + 65) )
      {
        SelectObject(hDC, lpbmi);
        SetDIBits(
          hDC,
          CompatibleBitmap,
          0,
          *((_DWORD *)v5 + 6),
          *(const void **)((char *)v5 + 65),
          *(const BITMAPINFO **)((char *)v5 + 61),
          0);
      }
      else
      {
        v23.bottom = (LONG)hDC;
        sub_406094(0, (UINT)hDC, (int)v5, v5, top, 0);
        SelectObject((HDC)v23.bottom, lpbmi);
      }
      sub_406024((int)v5);
      *((_DWORD *)v5 + 8) = CompatibleBitmap;
    }
    else
    {
      v12 = *((unsigned __int8 *)v5 + 73);
      do
      {
        v13 = v12;
        LOBYTE(v13) = byte_409188[v12];
        v12 = (unsigned __int8)byte_4090B0;
      }
      while ( !v13 );
      DIBSection = 0;
      v15 = (struct tagBITMAPINFO *)sub_405F70(*((_DWORD *)v5 + 7), *((_DWORD *)v5 + 6), v13);
      lpbmi = v15;
      if ( *((_BYTE *)v5 + 73) == 5 )
        sub_40600C((int)v15);
      v23.bottom = *((_DWORD *)v5 + 6) * sub_406268((int)lpbmi);
      v23.right = sub_402448(v23.bottom);
      v23.top = 0;
      v23.left = (LONG)lpbmi;
      v22 = (void *)v23.right;
      v16 = *((_DWORD *)v5 + 6);
      if ( v16 > right )
        v16 = right;
      v20 = v16;
      v17 = (HBITMAP)sub_406154((int)v5);
      DIBits = GetDIBits(hDC, v17, 0, v20, v22, (LPBITMAPINFO)v23.left, v23.top);
      v19 = *((_DWORD *)v5 + 6);
      if ( v19 > right )
        v19 = right;
      if ( DIBits != v19 )
      {
        sub_402468(v23.right);
        v23.right = 0;
        top = ~top;
        DIBSection = CreateDIBSection(hDC, lpbmi, 0, (void **)&v23.right, 0, 0);
        v23.top = (LONG)SelectObject(hDC, DIBSection);
        sub_406094(0, (UINT)hDC, (int)v5, v5, top, 0);
        SelectObject(hDC, (HGDIOBJ)v23.top);
      }
      sub_406024((int)v5);
      *(_DWORD *)((char *)v5 + 65) = v23.right;
      *(_DWORD *)((char *)v5 + 69) = v23.bottom;
      *(_DWORD *)((char *)v5 + 61) = lpbmi;
      *((_DWORD *)v5 + 8) = DIBSection;
      *((_BYTE *)v5 + 114) = 0;
      if ( top < 0 )
        ++*((_BYTE *)v5 + 114);
    }
    if ( *(_DWORD *)((char *)v5 + 74) )
      (*(void (__thiscall **)(int, LONG))((char *)v5 + 74))(top, right);
    DeleteDC(hDC);
  }
}
// 406283: variable 'v4' is possibly undefined
// 406289: variable 'v3' is possibly undefined
// 406289: variable 'v2' is possibly undefined
// 406289: variable 'v1' is possibly undefined
// 4090B0: using guessed type char byte_4090B0;

//----- (0040646C) --------------------------------------------------------
_DWORD *__usercall sub_40646C@<eax>(int a1@<eax>)
{
  int v2; // [esp-4h] [ebp-4h]

  (*(void (__cdecl **)(int))(a1 + 52))(a1);
  return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(v2 + 36), 0));
}
// 406473: variable 'v2' is possibly undefined

//----- (0040647C) --------------------------------------------------------
int __usercall sub_40647C@<eax>(int result@<eax>, char a2@<dl>)
{
  if ( a2 != *(_BYTE *)(result + 60) )
  {
    *(_BYTE *)(result + 60) = a2;
    sub_40627C(result);
  }
  return result;
}

//----- (0040648C) --------------------------------------------------------
char __usercall sub_40648C@<al>(int a1@<eax>)
{
  char result; // al

  if ( *(_BYTE *)(a1 + 60) == 1 || !*(_DWORD *)(a1 + 65) )
    return 0;
  result = sub_405F98(*(_WORD *)(*(_DWORD *)(a1 + 61) + 14));
  if ( result == 4 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 61) + 16) )
      return 5;
  }
  return result;
}

//----- (004064BC) --------------------------------------------------------
_DWORD *__usercall sub_4064BC@<eax>(int a1@<eax>)
{
  *(_DWORD *)(a1 + 82) = -1;
  return sub_404520((_DWORD *)_InterlockedExchange((volatile __int32 *)(a1 + 78), 0));
}

//----- (004064CC) --------------------------------------------------------
char *sub_4064CC()
{
  char *result; // eax

  result = sub_4044F8(0, (int)off_404474);
  *((_DWORD *)result + 6) = 32;
  return result;
}
// 404474: using guessed type int (*off_404474[3])();

//----- (004064E4) --------------------------------------------------------
int __usercall sub_4064E4@<eax>(int result@<eax>)
{
  HICON v1; // ecx
  int v2; // [esp-4h] [ebp-4h]

  v1 = (HICON)_InterlockedExchange((volatile __int32 *)(result + 28), 0);
  if ( v1 && !*(_BYTE *)(result + 32) )
  {
    v2 = result;
    DestroyIcon(v1);
    result = v2;
  }
  *(_BYTE *)(result + 32) = 0;
  return result;
}

//----- (00406500) --------------------------------------------------------
int __usercall sub_406500@<eax>(_DWORD *a1@<eax>)
{
  sub_4064E4((int)a1);
  return sub_40452C(a1);
}

//----- (00406510) --------------------------------------------------------
void __fastcall __spoils<edx,ecx> sub_406510(int a1, int a2)
{
  int v2; // [esp-4h] [ebp-4h] BYREF

  sub_406B48((int)&v2, 0, a2);
}

//----- (00406520) --------------------------------------------------------
HBITMAP __usercall sub_406520@<eax>(HBITMAP result@<eax>, HICON a2@<edx>)
{
  HBITMAP v3; // ebx
  ICONINFO v4; // [esp+0h] [ebp-34h] BYREF
  char pv[4]; // [esp+14h] [ebp-20h] BYREF
  int v6; // [esp+18h] [ebp-1Ch]

  v3 = result;
  if ( a2 != *((HICON *)result + 7) )
  {
    sub_4064E4((int)result);
    result = (HBITMAP)a2;
    *((_DWORD *)v3 + 7) = a2;
    if ( a2 )
    {
      GetIconInfo(a2, &v4);
      GetObjectA(v4.hbmMask, 24, pv);
      *((_DWORD *)v3 + 6) = v6;
      if ( v4.hbmMask )
        DeleteObject(v4.hbmMask);
      result = v4.hbmColor;
      if ( v4.hbmColor )
        return (HBITMAP)DeleteObject(v4.hbmColor);
    }
  }
  return result;
}
// 406520: using guessed type char pv[4];

//----- (00406580) --------------------------------------------------------
int __usercall sub_406580@<eax>(int a1@<eax>)
{
  _BYTE *v1; // edx
  int v2; // ecx

  v1 = &unk_409194;
  do
  {
    v2 = (unsigned __int8)*v1;
    if ( !*v1 )
      break;
    ++v1;
  }
  while ( 1 << v2 < a1 );
  return v2;
}

//----- (00406598) --------------------------------------------------------
int __cdecl sub_406598(int a1)
{
  int result; // eax
  unsigned __int8 v2; // dl

  result = 0;
  v2 = *(_BYTE *)(a1 - 14);
  if ( v2 >= 2u || *(_BYTE *)(a1 - 13) == 1 )
    return 4 * ((*(unsigned __int8 *)(a1 - 13) << 8) + v2);
  return result;
}

//----- (004065CC) --------------------------------------------------------
__int64 __usercall sub_4065CC@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int v5; // eax

  if ( *(_BYTE *)(a3 - 14) >= 2u || *(_BYTE *)(a3 - 13) == 1 )
    v5 = sub_406580((*(unsigned __int8 *)(a3 - 13) << 8) + *(unsigned __int8 *)(a3 - 14));
  else
    v5 = *(unsigned __int16 *)(a3 - 10);
  return a2 * (__int64)(4 * ((a1 * v5 + 31) / 32));
}

//----- (00406624) --------------------------------------------------------
__int64 __usercall sub_406624@<edx:eax>(int a1@<eax>, int a2@<edx>)
{
  return a2 * (__int64)(4 * ((a1 + 31) / 32));
}

//----- (00406638) --------------------------------------------------------
char __usercall sub_406638@<al>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  void *v3; // edi
  int v4; // ebx
  int v5; // esi
  HANDLE v6; // eax
  void *v7; // eax
  unsigned int v8; // edx
  int v9; // edi
  int v10; // edi
  void *v11; // edi
  int v12; // ebx
  int v13; // esi
  HANDLE v14; // eax
  HANDLE v15; // eax
  int v16; // eax
  int v17; // edi
  HANDLE v18; // eax
  int v19; // edi
  int v21; // [esp-10h] [ebp-A8h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-A4h] BYREF
  void *v23; // [esp-8h] [ebp-A0h]
  int *v24; // [esp-4h] [ebp-9Ch]
  char pv[4]; // [esp+Ch] [ebp-8Ch] BYREF
  int v26; // [esp+10h] [ebp-88h]
  int cy; // [esp+14h] [ebp-84h]
  unsigned __int16 v28; // [esp+1Ch] [ebp-7Ch]
  unsigned __int16 v29; // [esp+1Eh] [ebp-7Ah]
  int v30[2]; // [esp+24h] [ebp-74h] BYREF
  int v31; // [esp+2Ch] [ebp-6Ch]
  __int16 v32; // [esp+30h] [ebp-68h]
  unsigned __int16 v33; // [esp+32h] [ebp-66h]
  int v34; // [esp+38h] [ebp-60h]
  void **v35; // [esp+4Ch] [ebp-4Ch]
  void **v36; // [esp+50h] [ebp-48h]
  unsigned int v37; // [esp+54h] [ebp-44h]
  char *v38; // [esp+58h] [ebp-40h]
  __int16 v39; // [esp+5Eh] [ebp-3Ah]
  __int16 v40; // [esp+60h] [ebp-38h]
  unsigned __int16 v41; // [esp+62h] [ebp-36h]
  char *v42; // [esp+64h] [ebp-34h]
  _DWORD *v43; // [esp+68h] [ebp-30h]
  HANDLE h; // [esp+6Ch] [ebp-2Ch]
  int v45; // [esp+70h] [ebp-28h]
  int v46; // [esp+74h] [ebp-24h]
  char v47; // [esp+7Bh] [ebp-1Dh]
  int v48; // [esp+7Ch] [ebp-1Ch]
  unsigned int v49; // [esp+80h] [ebp-18h]
  void **v50; // [esp+84h] [ebp-14h]
  char v51[2]; // [esp+88h] [ebp-10h] BYREF
  unsigned __int16 v52; // [esp+8Ah] [ebp-Eh]
  unsigned __int16 v53; // [esp+8Eh] [ebp-Ah]
  int v54; // [esp+90h] [ebp-8h]
  int v55; // [esp+94h] [ebp-4h]
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  v48 = a3;
  v49 = a2;
  v50 = (void **)a1;
  v47 = 0;
  v39 = 0;
  v40 = 1;
  v41 = (int)(a2 + 1) / 2;
  if ( sub_40598C(a3) == 6 )
  {
    v45 = 16 * v41 + 6;
    v38 = sub_40456C();
    v43 = sub_405FD8(0, 0);
    v42 = sub_405FD8(0, 0);
    v24 = &savedregs;
    v23 = &loc_406B11;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    v37 = (v49 >> 1) + 1;
    v36 = v50;
    do
    {
      v3 = *v36;
      h = v36[1];
      if ( !v3 && !h )
        break;
      GetObjectA(h, 24, pv);
      v4 = v26;
      v5 = cy;
      if ( v3 )
        GetObjectA(v3, 24, pv);
      sub_402660(v51, 16, 0);
      v51[0] = v4;
      v51[1] = v5;
      if ( v3 )
      {
        v6 = CopyImage(v3, 0, v4, v5, 0x2000u);
        sub_4061E0((int)v43, v6);
        sub_402660((char *)v30, 40, 0);
        v30[0] = 40;
        v7 = (void *)sub_406154((int)v43);
        GetObjectA(v7, 24, pv);
        if ( v28 == 1 && v29 >= 0xFu )
        {
          v52 = 0;
          v53 = v29;
        }
        else
        {
          v8 = v28 * (1 << v29);
          if ( v8 >= 0x10 )
          {
            if ( v8 >= 0x100 )
            {
              sub_406218((int)v43);
              v52 = 256;
            }
            else
            {
              sub_406218((int)v43);
              LOBYTE(v52) = 16;
            }
          }
          else
          {
            sub_406218((int)v43);
            LOBYTE(v52) = 2;
          }
        }
      }
      else
      {
        LOBYTE(v52) = 2;
      }
      sub_4045E8(v38, (HIBYTE(v52) << 8) + (unsigned __int8)v52);
      v9 = sub_4065CC(v4, v5, (int)&savedregs);
      v10 = sub_406598((int)&savedregs) + 40 + v9;
      v54 = sub_406624(v4, v5) + v10;
      v55 = v45;
      if ( sub_40598C(v48) != 16 )
      {
LABEL_48:
        sub_402BEC((unsigned int)ExceptionList, (int)v23, (int)v24);
        return v47;
      }
      v45 += v54;
      v36 += 2;
      --v37;
    }
    while ( v37 );
    v37 = (v49 >> 1) + 1;
    v46 = 0;
    v35 = v50;
    while ( 1 )
    {
      v11 = *v35;
      h = v35[1];
      if ( !v11 && !h )
      {
LABEL_50:
        __writefsdword(0, (unsigned int)ExceptionList);
        v24 = (int *)&loc_406B18;
        sub_404520(v38);
        sub_404520(v43);
        sub_404520(v42);
        return 1;
      }
      GetObjectA(h, 24, pv);
      v12 = v26;
      v13 = cy;
      sub_402660((char *)v30, 40, 0);
      v30[0] = 40;
      v30[1] = v12;
      v31 = v13;
      if ( v11 )
        v31 = 2 * v12;
      v32 = 1;
      v52 = sub_40465C((int)v38, v46);
      if ( !v53 )
        v53 = sub_406580(v52);
      v33 = v53;
      v21 = sub_4065CC(v12, v13, (int)&savedregs) + 40;
      v34 = sub_406624(v12, v13) + v21;
      if ( sub_40598C(v48) != 40 )
        goto LABEL_48;
      if ( !v11 )
      {
        v15 = CopyImage(h, 0, v12, v13, 0);
        sub_4061E0((int)v43, v15);
        sub_406218((int)v43);
        goto LABEL_43;
      }
      v14 = CopyImage(v11, 0, v12, v13, 0);
      sub_4061E0((int)v43, v14);
      if ( v33 > 0x10u )
      {
        if ( v33 == 24 || v33 == 32 )
LABEL_38:
          sub_406218((int)v43);
      }
      else if ( v33 == 16 || v33 == 1 || v33 == 4 || v33 == 8 )
      {
        goto LABEL_38;
      }
LABEL_43:
      if ( *(_DWORD *)((char *)v43 + 65) )
      {
        v16 = sub_40598C(v48);
        if ( v16 != 4 * v52 )
          goto LABEL_48;
        sub_4065CC(v12, v13, (int)&savedregs);
        v17 = sub_40598C(v48);
        if ( v17 != (unsigned int)sub_4065CC(v12, v13, (int)&savedregs) )
          goto LABEL_48;
      }
      v18 = CopyImage(h, 0, v12, v13, 0);
      sub_4061E0((int)v42, v18);
      sub_406218((int)v42);
      sub_406624(v12, v13);
      v19 = sub_40598C(v48);
      if ( v19 != (unsigned int)sub_406624(v12, v13) )
        goto LABEL_48;
      ++v46;
      v35 += 2;
      if ( !--v37 )
        goto LABEL_50;
    }
  }
  return v47;
}
// 406638: using guessed type char pv[4];

//----- (00406B48) --------------------------------------------------------
OLECHAR ***__usercall sub_406B48@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // esi
  unsigned int v14[2]; // [esp-Ch] [ebp-44h] BYREF
  int *v15; // [esp-4h] [ebp-3Ch]
  ICONINFO piconinfo; // [esp+Ch] [ebp-2Ch] BYREF
  OLECHAR **v17[2]; // [esp+20h] [ebp-18h] BYREF
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v17[0] = 0;
  v19 = a3;
  v20 = a2;
  v21 = a1;
  v15 = &savedregs;
  v14[1] = (unsigned int)&loc_406C97;
  v14[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v14);
  if ( a2 < 0 )
  {
LABEL_9:
    v17[1] = (OLECHAR **)sub_405968(v19);
    sub_403B24(v17, (int)dword_406B2C, (void *)1, 2 * (v20 + 1));
    if ( v20 >= 0 )
    {
      v7 = v20 + 1;
      v18 = 0;
      v8 = v21;
      do
      {
        GetIconInfo(*(HICON *)(*(_DWORD *)v8 + 28), &piconinfo);
        v9 = 2 * v18;
        v17[0][v9] = (OLECHAR *)piconinfo.hbmColor;
        v17[0][v9 + 1] = (OLECHAR *)piconinfo.hbmMask;
        ++v18;
        v8 += 4;
        --v7;
      }
      while ( v7 );
    }
    v10 = sub_403970((int)v17[0]);
    if ( !sub_406638((int)v17[0], v10, v19) )
      sub_405990(v19);
    v11 = sub_403970((int)v17[0]);
    if ( v11 >= 0 )
    {
      v12 = v11 + 1;
      v18 = 0;
      do
      {
        if ( v17[0][v18] )
          DeleteObject(v17[0][v18]);
        ++v18;
        --v12;
      }
      while ( v12 );
    }
  }
  else
  {
    v3 = a2 + 1;
    v18 = 0;
    v4 = v21;
    while ( *(_DWORD *)(*(_DWORD *)v4 + 28) )
    {
      if ( v20 >= v18 + 1 )
      {
        v5 = v20 - v18;
        v6 = v21 + 4 * (v18 + 1);
        while ( *(_DWORD *)(*(_DWORD *)v4 + 24) != *(_DWORD *)(*(_DWORD *)v6 + 24) )
        {
          v6 += 4;
          if ( !--v5 )
            goto LABEL_8;
        }
        break;
      }
LABEL_8:
      ++v18;
      v4 += 4;
      if ( !--v3 )
        goto LABEL_9;
    }
  }
  __writefsdword(0, v14[0]);
  v15 = (int *)&loc_406C9E;
  return sub_403B30(v17, (int)dword_406B2C);
}
// 406B2C: using guessed type int dword_406B2C[3];

//----- (00406CA8) --------------------------------------------------------
HICON __usercall sub_406CA8@<eax>(UINT nIconIndex@<ecx>, HBITMAP a2@<eax>, char *a3@<edx>)
{
  char *v6; // eax
  HICON result; // eax

  sub_4064E4((int)a2);
  v6 = sub_40340C(a3);
  result = ExtractIconA(hwnd, v6, nIconIndex);
  if ( (int)result > 1 )
    return (HICON)sub_406520(a2, result);
  return result;
}

//----- (00406CE0) --------------------------------------------------------
int sub_406CE0()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_406D2F;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_40A68C )
  {
    if ( hLibModule )
      FreeLibrary_0(hLibModule);
    sub_403094(&off_4090E8);
    sub_403094(&dword_4090E4);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 4090E4: using guessed type _DWORD dword_4090E4;
// 4090E8: using guessed type char *off_4090E8;
// 40A68C: using guessed type int dword_40A68C;

//----- (00406D38) --------------------------------------------------------
void sub_406D38()
{
  --dword_40A68C;
}
// 40A68C: using guessed type int dword_40A68C;

//----- (00406D40) --------------------------------------------------------
_DWORD *__usercall sub_406D40@<eax>(char **a1@<eax>)
{
  unsigned __int8 i; // bl
  unsigned int v4[2]; // [esp-Ch] [ebp-B4h] BYREF
  int *v5; // [esp-4h] [ebp-ACh]
  char *v6; // [esp+Ch] [ebp-9Ch] BYREF
  CHAR Buffer[151]; // [esp+11h] [ebp-97h] BYREF
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  v6 = 0;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_406DFC;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  GetLogicalDriveStringsA(0x97u, Buffer);
  for ( i = 0; Buffer[i]; i += 4 )
  {
    if ( GetDriveTypeA(&Buffer[i]) != 5 && sub_40258C(Buffer[i]) != 65 && sub_40258C(Buffer[i]) != 66 )
    {
      sub_4031B4(&v6);
      sub_403214(a1, (__int32)v6);
    }
  }
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_406E03;
  return sub_403094(&v6);
}
// 406D40: using guessed type char *var_9C;
// 406D40: using guessed type CHAR Buffer[151];

//----- (00406E0C) --------------------------------------------------------
int sub_406E0C()
{
  char *v0; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v3; // [esp-4h] [ebp-14h]
  char *v4; // [esp+0h] [ebp-10h] BYREF
  char *v5; // [esp+4h] [ebp-Ch] BYREF
  double v6; // [esp+8h] [ebp-8h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v5 = 0;
  v4 = 0;
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_406E88;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  v6 = sub_4057D8();
  sub_405008((volatile __int32 *)&v5);
  sub_4031F4(&v4, aE, 11);
  sub_403214(&v5, (__int32)v4);
  v0 = sub_40340C(v5);
  sub_404BF8(v0, &v6, 8u);
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_406E8F;
  return sub_4030B8((int)&v4, 2);
}

//----- (00406E94) --------------------------------------------------------
int __usercall sub_406E94@<eax>(int a1@<ebx>)
{
  char *v1; // eax
  unsigned int v3[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v4; // [esp-4h] [ebp-18h]
  char *v5; // [esp+4h] [ebp-10h] BYREF
  char *v6; // [esp+8h] [ebp-Ch] BYREF
  double v7; // [esp+Ch] [ebp-8h] BYREF
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v6 = 0;
  v5 = 0;
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_406F22;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  LOBYTE(a1) = 1;
  sub_405008((volatile __int32 *)&v6);
  sub_4031F4(&v5, aE, 11);
  sub_403214(&v6, (__int32)v5);
  v1 = sub_40340C(v6);
  if ( sub_404C78(v1, &v7, 8u) )
    LOBYTE(a1) = sub_4057D8() - v7 > 5.0;
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_406F29;
  sub_4030B8((int)&v5, 2);
  return a1;
}

//----- (00406F34) --------------------------------------------------------
_DWORD *__usercall sub_406F34@<eax>(char a1@<al>, char **a2@<edx>)
{
  int v3; // esi
  int v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // esi
  int v8; // eax
  unsigned int v10[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v11; // [esp-4h] [ebp-18h]
  char *v12; // [esp+Ch] [ebp-8h] BYREF
  char v13; // [esp+13h] [ebp-1h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v12 = 0;
  v13 = a1;
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_406FC7;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  sub_403094(a2);
  if ( v13 )
    v3 = 1;
  else
    v3 = 2;
  v4 = v3;
  v5 = sub_404AE8();
  v6 = v5 - v3;
  if ( v5 >= v4 )
  {
    v7 = v6 + 1;
    do
    {
      sub_4049D0(v4, &v12);
      sub_4032CC(a2, 3);
      ++v4;
      --v7;
    }
    while ( v7 );
  }
  v8 = sub_40320C((int)*a2);
  sub_403534(a2, v8 - 1);
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_406FCE;
  return sub_403094(&v12);
}
// 406F34: using guessed type char *var_8;

//----- (00406FE4) --------------------------------------------------------
int __usercall sub_406FE4@<eax>(void *a1@<eax>, char *a2@<edx>, int a3@<ebx>)
{
  char v3; // zf
  int v5; // [esp-14h] [ebp-28h]
  unsigned int v6[2]; // [esp-10h] [ebp-24h] BYREF
  int *v7; // [esp-8h] [ebp-1Ch]
  int v8; // [esp-4h] [ebp-18h]
  int *v9; // [esp+0h] [ebp-14h] BYREF
  char *v10; // [esp+4h] [ebp-10h] BYREF
  __int32 v11; // [esp+8h] [ebp-Ch] BYREF
  char *v12; // [esp+Ch] [ebp-8h]
  void *v13; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = a3;
  v12 = a2;
  v13 = a1;
  sub_4033FC((int)a1);
  sub_4033FC((int)v12);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_407064;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_404F18(v13, &v10);
  sub_404700((__int32)v10, &v11);
  v5 = v11;
  sub_403258((volatile __int32 *)&v9, (char *)&dword_40707C, v12);
  Delphi_CompareCall_403358(v5, v9);
  LOBYTE(a3) = v3;
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_40706B;
  sub_4030B8((int)&v9, 5);
  return a3;
}
// 406FE4: could not find valid save-restore pair for ebx
// 407046: variable 'v3' is possibly undefined
// 40707C: using guessed type int dword_40707C;

//----- (00407080) --------------------------------------------------------
int __usercall sub_407080@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v5; // ebx

  result = (int)off_409214;
  *off_409214 = a3;
  v5 = a2;
  if ( a2 > 0 )
  {
    do
    {
      result = Delphi_Random_402680(0xFFu);
      *a1++ ^= result;
      --v5;
    }
    while ( v5 );
  }
  return result;
}
// 409214: using guessed type int *off_409214;

//----- (004070A4) --------------------------------------------------------
int sub_4070A4()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4070C9;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_40A694;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40A694: using guessed type int dword_40A694;

//----- (004070D4) --------------------------------------------------------
void sub_4070D4()
{
  --dword_40A694;
}
// 40A694: using guessed type int dword_40A694;

//----- (004070DC) --------------------------------------------------------
_DWORD *sub_4070DC()
{
  char *v0; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-10h] BYREF
  int *v3; // [esp-4h] [ebp-8h]
  char *v4; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v4 = 0;
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_407126;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  sub_4049D0(0, &v4);
  v0 = sub_40340C(v4);
  sub_404C78(v0, &unk_40A698, 0xA200u);
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_40712D;
  return sub_403094(&v4);
}

//----- (00407130) --------------------------------------------------------
int __usercall sub_407130@<eax>(const CHAR *a1@<eax>)
{
  HANDLE v1; // eax
  void *v2; // ebx
  int v3; // ebx
  unsigned int v5[2]; // [esp-Ch] [ebp-114h] BYREF
  int *v6; // [esp-4h] [ebp-10Ch]
  _DWORD Buffer[64]; // [esp+4h] [ebp-104h] BYREF
  const CHAR *v8; // [esp+104h] [ebp-4h] BYREF
  int savedregs; // [esp+108h] [ebp+0h] BYREF

  v8 = a1;
  sub_4033FC((int)a1);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_4071BF;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v1 = sub_404B68(v8, 0x80000303);
  v2 = v1;
  if ( v1 == (HANDLE)-1 )
  {
    v3 = 0;
  }
  else
  {
    sub_404BB4(v1, 1000, 0);
    sub_404BC4(0x100u, Buffer, v2);
    sub_404B90(v2);
    v3 = sub_4047D0(dword_40AA80, Buffer, 0x100u);
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_4071C6;
  sub_403094(&v8);
  return v3;
}
// 40AA80: using guessed type _DWORD dword_40AA80[8922];
// 407130: using guessed type _DWORD Buffer[64];

//----- (004071D0) --------------------------------------------------------
char __usercall sub_4071D0@<al>(char *a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  char *v4; // ebx
  char *v5; // eax
  char *v6; // ebx
  DWORD FileAttributesA; // edi
  char *v8; // ebx
  char *v9; // esi
  int v10; // ecx
  HANDLE v11; // eax
  void *v12; // ebx
  char *v13; // eax
  char *v15; // [esp-1Ch] [ebp-A238h]
  char *v16; // [esp-1Ch] [ebp-A238h]
  unsigned int v17[2]; // [esp-18h] [ebp-A234h] BYREF
  int *v18; // [esp-10h] [ebp-A22Ch]
  int v19; // [esp-Ch] [ebp-A228h]
  int v20; // [esp-8h] [ebp-A224h]
  int v21; // [esp-4h] [ebp-A220h]
  char *v22; // [esp+0h] [ebp-A21Ch] BYREF
  char *v23; // [esp+4h] [ebp-A218h] BYREF
  char *v24; // [esp+8h] [ebp-A214h] BYREF
  char *v25; // [esp+Ch] [ebp-A210h] BYREF
  char Buffer[1234]; // [esp+10h] [ebp-A20Ch] BYREF
  char v27[40238]; // [esp+4E2h] [ebp-9D3Ah] BYREF
  int v28; // [esp+A210h] [ebp-Ch] BYREF
  char v29; // [esp+A217h] [ebp-5h]
  char *v30; // [esp+A218h] [ebp-4h] BYREF
  int savedregs; // [esp+A21Ch] [ebp+0h] BYREF

  v21 = a2;
  v20 = a4;
  v19 = a3;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v30 = a1;
  sub_4033FC((int)a1);
  v18 = &savedregs;
  v17[1] = (unsigned int)&loc_40748C;
  v17[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v17);
  v29 = 0;
  sub_4031F4(&v25, asc_4091C0, 3);
  if ( (unsigned __int8)sub_406FE4(v30, v25, a2) )
  {
    sub_404F34(v30, &v24);
    sub_40312C((volatile __int32 *)&v30, (__int32)v24);
    sub_404F90((volatile __int32 *)&v23);
    v15 = sub_40340C(v23);
    v4 = sub_40340C(v30);
    if ( !sub_404B38(v4, v15) )
    {
      sub_405008((volatile __int32 *)&v22);
      v16 = sub_40340C(v22);
      if ( !sub_404B38(v4, v16) && sub_4034EC("\\PROGRA~1\\", v30) != (_BYTE *)3 )
      {
        v5 = sub_404F6C(v30);
        if ( (unsigned int)v5 > 0xA200 && (unsigned int)v5 <= 0x989680 && !(unsigned __int8)sub_407130(v30) )
        {
          v29 = 1;
          v6 = sub_40340C(v30);
          FileAttributesA = GetFileAttributesA(v6);
          if ( (FileAttributesA & 1) != 0 )
            SetFileAttributesA(v6, 0);
          v8 = sub_405BDC();
          v9 = sub_4064CC();
          sub_406CA8(0, (HBITMAP)v9, v30);
          sub_406510(v10, (int)v8);
          sub_405974((int)v8);
          sub_404198(byte_4135E8, 4264);
          sub_405988((int)v8);
          sub_404520(v8);
          sub_404520(v9);
          v11 = sub_404B68(v30, 0xC0000303);
          v12 = v11;
          if ( v11 != (HANDLE)-1 )
          {
            sub_404BC4(2u, Buffer, v11);
            if ( Buffer[0] == 77 && Buffer[1] == 90 )
            {
              sub_404BB4(v12, 0, 0);
              sub_404BC4(0xA200u, Buffer, v12);
              sub_40254C(v27, (char *)&v28, 4);
              sub_407080(Buffer, 1000, v28);
              sub_404BB4(v12, 0, 0);
              sub_404BE0(0xA200u, &unk_40A698, v12);
              sub_404BB4(v12, 0, 2u);
              sub_404BE0(0xA200u, Buffer, v12);
            }
          }
          sub_404B90(v12);
          if ( (FileAttributesA & 1) != 0 )
          {
            v13 = sub_40340C(v30);
            SetFileAttributesA(v13, FileAttributesA);
          }
        }
      }
    }
  }
  __writefsdword(0, v17[0]);
  v18 = (int *)&loc_407493;
  sub_4030B8((int)&v22, 4);
  sub_403094(&v30);
  return v29;
}
// 4071D0: could not find valid save-restore pair for edi
// 4071D0: could not find valid save-restore pair for esi
// 40734D: variable 'v10' is possibly undefined
// 4071D0: using guessed type int var_C;
// 4071D0: using guessed type char var_9D3A[40238];

//----- (004074B4) --------------------------------------------------------
int __usercall sub_4074B4@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5)
{
  char *v5; // ebx
  int v6; // eax
  int v7; // edi
  int v8; // esi
  unsigned int v10[2]; // [esp-18h] [ebp-30h] BYREF
  int *v11; // [esp-10h] [ebp-28h]
  int v12; // [esp-Ch] [ebp-24h]
  int v13; // [esp-8h] [ebp-20h]
  int v14; // [esp-4h] [ebp-1Ch]
  char *v15; // [esp+0h] [ebp-18h] BYREF
  char *v16; // [esp+4h] [ebp-14h] BYREF
  char *v17; // [esp+8h] [ebp-10h] BYREF
  __int32 v18; // [esp+Ch] [ebp-Ch] BYREF
  char *v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = a2;
  v13 = a4;
  v12 = a3;
  v20 = a1;
  sub_4033FC(a1);
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_40758B;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  sub_4031F4(&v19, &::a2, 3);
  v5 = sub_4052AC(v20, (int)v19, 0);
  v6 = sub_40532C((int)v5);
  if ( v6 - 1 >= 0 )
  {
    v7 = v6;
    v8 = 0;
    do
    {
      if ( sub_40534C((int)v5, v8) )
      {
        sub_405338((int)v5, v8, &v17);
        sub_403258(&v18, *((char **)v5 + 7), v17);
        sub_4074B4(a5);
      }
      else
      {
        sub_405338((int)v5, v8, &v15);
        sub_403258((volatile __int32 *)&v16, *((char **)v5 + 7), v15);
        sub_4071D0(v16, (int)v5, v7, v8);
      }
      ++v8;
      --v7;
    }
    while ( v7 );
  }
  sub_404520(v5);
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_407592;
  return sub_4030B8((int)&v15, 6);
}
// 4074B4: could not find valid save-restore pair for ebx
// 4074B4: could not find valid save-restore pair for edi
// 4074B4: could not find valid save-restore pair for esi
// 4091DC: using guessed type char a2;

//----- (0040759C) --------------------------------------------------------
int __usercall sub_40759C@<eax>(int a1@<ebx>)
{
  HANDLE v1; // edi
  int v2; // ebx
  int v3; // esi
  unsigned int v5[2]; // [esp-18h] [ebp-20h] BYREF
  int *v6; // [esp-10h] [ebp-18h]
  int v7; // [esp-4h] [ebp-Ch]
  char *v8; // [esp+0h] [ebp-8h] BYREF
  char *v9; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v9 = 0;
  v8 = 0;
  v7 = a1;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_40765C;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  if ( (unsigned __int8)sub_406E94(a1) )
  {
    sub_407080(Name, 20, 20);
    v1 = sub_404018(0, 0, Name);
    if ( GetLastError() != 183 )
    {
      sub_406D40(&v9);
      v2 = sub_40320C((int)v9);
      if ( v2 > 0 )
      {
        v3 = 1;
        do
        {
          sub_4031B4(&v8);
          sub_403214(&v8, (__int32)sub_407674);
          sub_4074B4((int)v8, v2--, (int)v1, v3++, (int)&savedregs);
        }
        while ( v2 );
      }
      sub_406E0C();
      ReleaseMutex(v1);
    }
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_407663;
  return sub_4030B8((int)&v8, 2);
}
// 40759C: could not find valid save-restore pair for ebx
// 407674: using guessed type int sub_407674();

//----- (00407678) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __usercall sub_407678@<eax>(char *a1@<ecx>, int a2@<ebx>)
{
  int v2; // eax
  char *v3; // eax
  char *v4; // eax
  const CHAR *v6; // [esp-10h] [ebp-A26Ch]
  LPCSTR ExceptionList; // [esp-Ch] [ebp-A268h] BYREF
  char *v8; // [esp-8h] [ebp-A264h]
  struct _EXCEPTION_REGISTRATION_RECORD *v9; // [esp-4h] [ebp-A260h] BYREF
  int v10; // [esp+0h] [ebp-A25Ch] BYREF
  char *v11; // [esp+4h] [ebp-A258h] BYREF
  LPCSTR v12; // [esp+8h] [ebp-A254h] BYREF
  LPCSTR v13; // [esp+Ch] [ebp-A250h] BYREF
  char *v14; // [esp+10h] [ebp-A24Ch] BYREF
  char *v15; // [esp+14h] [ebp-A248h] BYREF
  char *v16; // [esp+18h] [ebp-A244h] BYREF
  char *v17; // [esp+1Ch] [ebp-A240h] BYREF
  char *v18; // [esp+20h] [ebp-A23Ch] BYREF
  LPCSTR lpParameters; // [esp+24h] [ebp-A238h] BYREF
  LPCSTR lpDirectory; // [esp+28h] [ebp-A234h] BYREF
  INT nShowCmd; // [esp+2Ch] [ebp-A230h] BYREF
  char *v22; // [esp+30h] [ebp-A22Ch] BYREF
  char *v23; // [esp+34h] [ebp-A228h] BYREF
  char *v24; // [esp+38h] [ebp-A224h] BYREF
  char *v25; // [esp+3Ch] [ebp-A220h] BYREF
  __int32 v26; // [esp+40h] [ebp-A21Ch] BYREF
  char *v27; // [esp+44h] [ebp-A218h] BYREF
  char *v28; // [esp+48h] [ebp-A214h] BYREF
  char *v29; // [esp+4Ch] [ebp-A210h] BYREF
  char v30[1234]; // [esp+50h] [ebp-A20Ch] BYREF
  char v31[40238]; // [esp+522h] [ebp-9D3Ah] BYREF
  int v32; // [esp+A250h] [ebp-Ch] BYREF
  char *v33; // [esp+A254h] [ebp-8h]
  char *v34; // [esp+A258h] [ebp-4h]
  int savedregs; // [esp+A25Ch] [ebp+0h] BYREF

  v10 = (int)a1;
  v9 = (struct _EXCEPTION_REGISTRATION_RECORD *)&savedregs;
  v8 = (char *)&loc_40798C;
  ExceptionList = (LPCSTR)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_405008((volatile __int32 *)&v29);
  sub_4031F4(&v28, aJ, 9);
  sub_403214(&v29, (__int32)v28);
  sub_404DE0(v29, a2);
  sub_405008(&v26);
  sub_4031F4(&v25, aJ, 9);
  sub_4031F4(&v24, &::a2, 3);
  sub_4032CC(&v27, 3);
  sub_405200(v27, a2);
  sub_4049D0(0, &v23);
  v34 = sub_405B60(v23);
  v11 = (char *)&savedregs;
  v10 = (int)&loc_40789F;
  v9 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v9);
  sub_405008(&nShowCmd);
  v8 = (char *)nShowCmd;
  sub_4031F4((char **)&lpDirectory, aJ, 9);
  ExceptionList = lpDirectory;
  sub_4049D0(0, &v18);
  sub_404ED0(v18, (char **)&lpParameters);
  sub_4032CC(&v22, 3);
  v33 = sub_405B24(v22, 0x40000103u);
  v11 = (char *)&savedregs;
  v10 = (int)&loc_407882;
  v9 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v9);
  sub_40597C((int)v34);
  sub_405974((int)v34);
  sub_405988((int)v34);
  sub_40254C(v31, (char *)&v32, 4);
  sub_407080(v30, 1000, v32);
  sub_40598C((int)v33);
  sub_405974((int)v34);
  v2 = sub_40597C((int)v34);
  sub_405BE8(v33, (int)v34, v2 - 82944);
  __writefsdword(0, (unsigned int)v9);
  v11 = (char *)&loc_407889;
  sub_404520(v33);
  __writefsdword(0, (unsigned int)v9);
  v11 = (char *)&loc_4078A6;
  sub_404520(v34);
  sub_4049D0(0, &v16);
  sub_404EEC(v16, &v17);
  v3 = sub_40340C(v17);
  SetCurrentDirectoryA(v3);
  v10 = 1;
  v9 = 0;
  sub_406F34(1, &v15);
  v8 = sub_40340C(v15);
  sub_405008((volatile __int32 *)&v13);
  ExceptionList = v13;
  sub_4031F4((char **)&v12, aJ, 9);
  v6 = v12;
  sub_4049D0(0, (char **)&v10);
  sub_404ED0((void *)v10, &v11);
  sub_4032CC(&v14, 3);
  v4 = sub_40340C(v14);
  ShellExecuteA((HWND)hwnd, "open", v4, v6, ExceptionList, (INT)v8);
  __writefsdword(0, (unsigned int)v9);
  v11 = (char *)&loc_407993;
  return sub_4030B8((int)&v10, 20);
}
// 407986: bad sp value at call
// 4091DC: using guessed type char a2;
// 407678: using guessed type char var_A20C[1234];
// 407678: using guessed type char var_9D3A[40238];

//----- (004079A0) --------------------------------------------------------
int __usercall sub_4079A0@<eax>(int a1@<ebx>)
{
  char *v1; // eax
  char *v2; // eax
  HKEY v3; // ecx
  HKEY v4; // ebx
  char *v6; // [esp-14h] [ebp-2Ch]
  unsigned int v7[2]; // [esp-10h] [ebp-28h] BYREF
  int *v8; // [esp-8h] [ebp-20h]
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10; // [esp+0h] [ebp-18h] BYREF
  char *v11; // [esp+4h] [ebp-14h] BYREF
  char *v12; // [esp+8h] [ebp-10h] BYREF
  char *v13; // [esp+Ch] [ebp-Ch] BYREF
  char *v14; // [esp+10h] [ebp-8h] BYREF
  char *v15; // [esp+14h] [ebp-4h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = a1;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_407AC4;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  sub_407080(asc_4091E0, 11, 11);
  sub_4031F4(&v14, asc_4091E0, 11);
  v6 = v14;
  sub_404F90((volatile __int32 *)&v13);
  sub_403258((volatile __int32 *)&v15, v13, v6);
  if ( sub_404B9C(v15) )
  {
    v1 = sub_40340C(v15);
    DeleteFileA(v1);
  }
  v2 = sub_40340C(v15);
  if ( sub_404BF8(v2, &unk_40A698, 0xA200u) )
  {
    sub_407080(asc_4091EC, 26, 26);
    sub_4031F4(&v12, asc_4091EC, 26);
    v4 = sub_40575C(HKEY_CLASSES_ROOT, v12, v3);
    sub_407080(asc_409208, 8, 8);
    sub_4031F4(&v10, asc_409208, 8);
    sub_403258((volatile __int32 *)&v11, v15, v10);
    sub_40578C(v4, 0, v11);
    sub_4057CC(v4);
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_407ACB;
  return sub_4030B8((int)&v10, 6);
}
// 4079A0: could not find valid save-restore pair for ebx
// 407A5B: variable 'v3' is possibly undefined

//----- (00407AD0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_407AD0@<eax>(char *a1@<eax>, char **a2@<esi>)
{
  unsigned int v3[2]; // [esp-18h] [ebp-30h] BYREF
  void **v4; // [esp-10h] [ebp-28h]
  _DWORD v5[3]; // [esp-Ch] [ebp-24h] BYREF
  char *v6; // [esp+0h] [ebp-18h] BYREF
  char *v7; // [esp+4h] [ebp-14h] BYREF
  char *v8; // [esp+8h] [ebp-10h] BYREF
  char *v9; // [esp+Ch] [ebp-Ch] BYREF
  char *v10; // [esp+10h] [ebp-8h]
  char *v11; // [esp+14h] [ebp-4h] BYREF
  void *savedregs; // [esp+18h] [ebp+0h] BYREF

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v11 = a1;
  sub_4033FC((int)a1);
  v5[2] = &savedregs;
  v5[1] = &loc_407BC7;
  v5[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v10 = sub_405C80();
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_407B9D;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  sub_404F90((volatile __int32 *)&v9);
  sub_4031F4(&v8, aA, 11);
  sub_403214(&v9, (__int32)v8);
  sub_405E04(v10, v9);
  if ( sub_405D84((int)v10, v11) == -1 )
    sub_405CAC((int)v10, (int)v11);
  sub_404F90((volatile __int32 *)&v7);
  sub_4031F4(&v6, aA, 11);
  sub_403214(&v7, (__int32)v6);
  sub_405E50(v10, v7, a2);
  __writefsdword(0, v3[0]);
  v4 = (void **)&loc_407BA4;
  sub_404520(v10);
  __writefsdword(0, (unsigned int)v10);
  savedregs = &loc_407BCE;
  sub_4030B8((int)&v6, 4);
  return sub_403094(&v11);
}
// 407BB9: bad sp value at call
// 407BC1: bad sp value at call

//----- (00407BD4) --------------------------------------------------------
_DWORD *__usercall sub_407BD4@<eax>(unsigned __int8 *a1@<eax>, int a2@<ebx>, char **a3@<esi>)
{
  unsigned __int8 v3; // al
  bool v4; // cf
  char v5; // al
  char *v6; // ebx
  char *v7; // eax
  unsigned int v9[2]; // [esp-1Ch] [ebp-A230h] BYREF
  int *v10; // [esp-14h] [ebp-A228h]
  unsigned int v11[2]; // [esp-10h] [ebp-A224h] BYREF
  int *v12; // [esp-8h] [ebp-A21Ch]
  int v13; // [esp-4h] [ebp-A218h]
  char *v14; // [esp+0h] [ebp-A214h] BYREF
  char v15[1234]; // [esp+4h] [ebp-A210h] BYREF
  char v16[40238]; // [esp+4D6h] [ebp-9D3Eh] BYREF
  int v17; // [esp+A204h] [ebp-10h] BYREF
  char *v18; // [esp+A208h] [ebp-Ch]
  DWORD dwFileAttributes; // [esp+A20Ch] [ebp-8h]
  unsigned __int8 *v20; // [esp+A210h] [ebp-4h] BYREF
  int savedregs; // [esp+A214h] [ebp+0h] BYREF

  v13 = a2;
  v14 = 0;
  v20 = a1;
  sub_4033FC((int)a1);
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_407D8D;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  sub_4031F4(&v14, asc_4091C0, 3);
  if ( (unsigned __int8)sub_406FE4(v20, v14, a2) )
  {
    v3 = sub_40258C(*v20) - 65;
    v4 = v3 < 2u;
    v5 = v3 - 2;
    if ( !v4 && v5 != 25 )
    {
      sub_407AD0((char *)v20, a3);
      if ( (unsigned __int8)sub_407130((const CHAR *)v20) )
      {
        v6 = sub_40340C((char *)v20);
        dwFileAttributes = GetFileAttributesA(v6);
        if ( (dwFileAttributes & 1) != 0 )
          SetFileAttributesA(v6, 0);
        v18 = sub_405B84(v20);
        v10 = &savedregs;
        v9[1] = (unsigned int)&loc_407D4A;
        v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
        __writefsdword(0, (unsigned int)v9);
        sub_40597C((int)v18);
        sub_405974((int)v18);
        sub_405988((int)v18);
        sub_40254C(v16, (char *)&v17, 4);
        sub_407080(v15, 1000, v17);
        sub_405974((int)v18);
        sub_40598C((int)v18);
        sub_40597C((int)v18);
        sub_405980((int)v18);
        __writefsdword(0, v9[0]);
        v10 = (int *)&loc_407D51;
        sub_404520(v18);
        if ( (dwFileAttributes & 1) != 0 )
        {
          v10 = (int *)dwFileAttributes;
          v7 = sub_40340C((char *)v20);
          SetFileAttributesA(v7, (DWORD)v10);
        }
      }
    }
  }
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_407D94;
  sub_403094(&v14);
  return sub_403094(&v20);
}
// 407BD4: using guessed type char var_A210[1234];
// 407BD4: using guessed type char var_9D3E[40238];

//----- (00407D9C) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __usercall sub_407D9C@<eax>(unsigned __int8 *a1@<eax>, int a2@<ebx>, int a3@<edi>, char **a4@<esi>)
{
  char **v4; // esi
  int v5; // ebx
  char *v6; // eax
  _DWORD v8[5]; // [esp-14h] [ebp-2Ch] BYREF
  char *v9; // [esp+0h] [ebp-18h] BYREF
  char *v10; // [esp+4h] [ebp-14h] BYREF
  char *v11; // [esp+8h] [ebp-10h] BYREF
  char *v12; // [esp+Ch] [ebp-Ch] BYREF
  char *v13; // [esp+10h] [ebp-8h] BYREF
  char *v14; // [esp+14h] [ebp-4h]
  void *savedregs; // [esp+18h] [ebp+0h] BYREF

  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8[4] = a2;
  v8[3] = a4;
  v14 = (char *)a1;
  sub_4033FC((int)a1);
  v8[2] = &savedregs;
  v8[1] = &loc_407E75;
  v8[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  if ( *v14 == 92 )
    sub_4071D0(v14, a2, a3, (int)a4);
  else
    sub_407BD4((unsigned __int8 *)v14, a2, a4);
  v4 = (char **)sub_404AE8();
  if ( (int)v4 > 0 )
  {
    v5 = 1;
    do
    {
      sub_4049D0(v5, &v13);
      if ( *v13 == 92 )
      {
        sub_4049D0(v5, &v12);
        sub_4071D0(v12, v5, a3, (int)v4);
      }
      else
      {
        sub_4049D0(v5, &v11);
        sub_407BD4((unsigned __int8 *)v11, v5, v4);
      }
      ++v5;
      v4 = (char **)((char *)v4 - 1);
    }
    while ( v4 );
  }
  sub_406F34(0, &v9);
  sub_4032CC(&v10, 3);
  v6 = sub_40340C(v10);
  WinExec(v6, (UINT)v12);
  __writefsdword(0, (unsigned int)v13);
  savedregs = &loc_407E7C;
  return sub_4030B8((int)&v9, 6);
}
// 407D9C: could not find valid save-restore pair for ebx
// 407D9C: could not find valid save-restore pair for esi
// 407E6F: bad sp value at call

//----- (00407E90) --------------------------------------------------------
int __usercall sub_407E90@<eax>(int a1@<edi>, char **a2@<esi>)
{
  int v2; // ebx
  int v3; // ebx
  unsigned int v5[2]; // [esp-18h] [ebp-44h] BYREF
  int *v6; // [esp-10h] [ebp-3Ch]
  unsigned int v7[2]; // [esp-Ch] [ebp-38h] BYREF
  int *v8; // [esp-4h] [ebp-30h]
  char *v9; // [esp+4h] [ebp-28h] BYREF
  char *v10; // [esp+8h] [ebp-24h] BYREF
  char *v11; // [esp+Ch] [ebp-20h] BYREF
  char *v12; // [esp+10h] [ebp-1Ch] BYREF
  char *v13; // [esp+14h] [ebp-18h] BYREF
  char *v14; // [esp+18h] [ebp-14h] BYREF
  char *v15; // [esp+1Ch] [ebp-10h] BYREF
  char *v16; // [esp+20h] [ebp-Ch] BYREF
  char *v17; // [esp+24h] [ebp-8h] BYREF
  char *v18; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_408020;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  sub_404F90((volatile __int32 *)&v17);
  sub_4031F4(&v16, aA, 11);
  sub_403214(&v17, (__int32)v16);
  if ( sub_404B9C(v17) )
  {
    v18 = sub_405C80();
    v6 = &savedregs;
    v5[1] = (unsigned int)&loc_407FFE;
    v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v5);
    sub_404F90((volatile __int32 *)&v15);
    sub_4031F4(&v14, aA, 11);
    sub_403214(&v15, (__int32)v14);
    sub_405E04(v18, v15);
    v2 = 0;
    while ( v2 < *((_DWORD *)v18 + 7) )
    {
      sub_405D18((int)v18, v2, &v13);
      if ( sub_404B9C(v13) )
        ++v2;
      else
        sub_405CEC(v18, v2);
    }
    v3 = 0;
    while ( v3 < *((_DWORD *)v18 + 7) )
    {
      sub_405D18((int)v18, v3, &v12);
      if ( !sub_4071D0(v12, v3, a1, (int)a2) || (sub_405D18((int)v18, v3, &v11), (unsigned __int8)sub_407130(v11)) )
        sub_405CEC(v18, v3);
      else
        ++v3;
    }
    sub_404F90((volatile __int32 *)&v10);
    sub_4031F4(&v9, aA, 11);
    sub_403214(&v10, (__int32)v9);
    sub_405E50(v18, v10, a2);
    __writefsdword(0, v5[0]);
    v6 = (int *)&loc_408005;
    sub_404520(v18);
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_408027;
  return sub_4030B8((int)&v9, 9);
}

//----- (0040802C) --------------------------------------------------------
int sub_40802C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40804B;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}

//----- (004080E4) --------------------------------------------------------
void __usercall __noreturn start(int a1@<ebx>, int a2@<edi>, char **a3@<esi>)
{
  char *v3; // ecx
  void *v4; // ecx
  char *v5; // [esp-10h] [ebp-30h]
  unsigned int v6[2]; // [esp-Ch] [ebp-2Ch] BYREF
  int *v7; // [esp-4h] [ebp-24h]
  char *v8; // [esp+0h] [ebp-20h] BYREF
  char *v9; // [esp+4h] [ebp-1Ch] BYREF
  char *v10; // [esp+8h] [ebp-18h] BYREF
  char *v11; // [esp+Ch] [ebp-14h] BYREF
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v8 = 0;
  v10 = 0;
  v9 = 0;
  v11 = 0;
  sub_403F14((int)&dword_408054, (struct _EXCEPTION_REGISTRATION_RECORD *)&savedregs);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_408220;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_407080(aA, 11, 11);
  sub_407080(aJ, 9, 9);
  sub_407080(asc_4091C0, 3, 3);
  sub_407080(::a2, 3, 3);
  sub_407080(off_409210, 11, 11);
  sub_4070DC();
  sub_4049D0(0, &v11);
  if ( (int)sub_404F6C(v11) > 41472 )
    sub_407678(v3, a1);
  sub_407E90(a2, a3);
  sub_407080(&asc_4091C0[4], 3, 3);
  if ( sub_404AE8() )
  {
    sub_4049D0(0, &v10);
    v5 = v10;
    sub_4031F4(&v9, &asc_4091C0[4], 3);
    if ( (unsigned __int8)sub_406FE4(v5, v9, a1) )
    {
      sub_4049D0(1, &v8);
      sub_407D9C((unsigned __int8 *)v8, a1, a2, a3);
    }
  }
  sub_4079A0(a1);
  sub_40759C(a1);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_408227;
  sub_4030B8((int)&v8, 4);
  sub_402FA4(v4);
}
// 408192: variable 'v3' is possibly undefined
// 408227: variable 'v4' is possibly undefined
// 408054: using guessed type int dword_408054;
// 409210: using guessed type char *off_409210;

// nfuncs=446 queued=331 decompiled=331 lumina nreq=0 worse=0 better=0
// ALL OK, 331 function(s) have been successfully decompiled
